Project Path: arc_Bartis1313_csgo_l6m_skw0

Source Tree:

```txt
arc_Bartis1313_csgo_l6m_skw0
├── LICENSE
├── README.md
├── csgo-legit.sln
├── csgo-legit.vcxproj
├── hack
│   ├── SDK
│   │   ├── CCSGO_HudRadar.hpp
│   │   ├── CClientEffectRegistration.hpp
│   │   ├── CCommonHostState.hpp
│   │   ├── CEffectData.hpp
│   │   ├── CFlashlightEffect.hpp
│   │   ├── CGameMovement.hpp
│   │   ├── CGameRules.hpp
│   │   ├── CGlobalVars.hpp
│   │   ├── CGlowManager.cpp
│   │   ├── CGlowManager.hpp
│   │   ├── CHudChat.hpp
│   │   ├── CNewParticleEffect.cpp
│   │   ├── CNewParticleEffect.hpp
│   │   ├── CParticelCollection.hpp
│   │   ├── CPlayerResource.hpp
│   │   ├── CPredictionCopy.cpp
│   │   ├── CPredictionCopy.hpp
│   │   ├── CStudioHdr.hpp
│   │   ├── CTeslaInfo.hpp
│   │   ├── CUserCmd.hpp
│   │   ├── CUtlMemory.hpp
│   │   ├── CUtlReference.hpp
│   │   ├── CUtlString.hpp
│   │   ├── CUtlVector.hpp
│   │   ├── CViewSetup.hpp
│   │   ├── ClientClass.hpp
│   │   ├── ClientMode.hpp
│   │   ├── ConVar.hpp
│   │   ├── CutlBuffer.hpp
│   │   ├── EHandle.hpp
│   │   ├── Enums.hpp
│   │   ├── IBaseClientDll.hpp
│   │   ├── IBaseFileSystem.hpp
│   │   ├── IClientEntityList.hpp
│   │   ├── IClientState.hpp
│   │   ├── ICollideable.hpp
│   │   ├── ICvar.hpp
│   │   ├── IEffects.hpp
│   │   ├── IEngineSound.hpp
│   │   ├── IEngineTrace.hpp
│   │   ├── IGameEvent.hpp
│   │   ├── ILocalize.hpp
│   │   ├── IMDLCache.hpp
│   │   ├── IMatRenderContext.cpp
│   │   ├── IMatRenderContext.hpp
│   │   ├── IMaterialInternal.hpp
│   │   ├── IMaterialSystem.hpp
│   │   ├── IMemAlloc.hpp
│   │   ├── INetworkStringTableContainer.hpp
│   │   ├── IPanel.hpp
│   │   ├── IPhysicsCollision.hpp
│   │   ├── IPhysicsObject.hpp
│   │   ├── IPhysicsSurfaceProps.hpp
│   │   ├── IPrediction.cpp
│   │   ├── IPrediction.hpp
│   │   ├── ISurface.hpp
│   │   ├── ITexture.hpp
│   │   ├── IVDebugOverlay.hpp
│   │   ├── IVEffects.hpp
│   │   ├── IVEngineClient.hpp
│   │   ├── IVModelInfo.hpp
│   │   ├── IVModelRender.hpp
│   │   ├── IVRenderView.hpp
│   │   ├── IVStudioRender.hpp
│   │   ├── IViewRender.hpp
│   │   ├── IViewRenderBeams.hpp
│   │   ├── IWeapon.hpp
│   │   ├── Input.hpp
│   │   ├── InputSystem.hpp
│   │   ├── KeyValues.cpp
│   │   ├── KeyValues.hpp
│   │   ├── KeyValuesSys.hpp
│   │   ├── MapStruct.hpp
│   │   ├── PixEvent.hpp
│   │   ├── Recv.hpp
│   │   ├── animations.hpp
│   │   ├── checksum_crc.cpp
│   │   ├── checksum_crc.hpp
│   │   ├── clientHitVerify.hpp
│   │   ├── datamap.hpp
│   │   ├── helpers
│   │   │   ├── netvars.cpp
│   │   │   ├── netvars.hpp
│   │   │   ├── pad.hpp
│   │   │   └── vfunc.hpp
│   │   ├── interfaceNode.hpp
│   │   ├── interfaces
│   │   │   ├── ifc.hpp
│   │   │   ├── interfaces.cpp
│   │   │   └── interfaces.hpp
│   │   ├── lightdesc.hpp
│   │   ├── material.cpp
│   │   ├── material.hpp
│   │   ├── materialInit.hpp
│   │   ├── math
│   │   │   ├── AABB.hpp
│   │   │   ├── Rect.hpp
│   │   │   ├── Vector.hpp
│   │   │   ├── VectorAligned.hpp
│   │   │   └── matrix.hpp
│   │   ├── stencil.hpp
│   │   ├── structs
│   │   │   ├── Entity.cpp
│   │   │   ├── Entity.hpp
│   │   │   └── indexes.hpp
│   │   ├── varMapping.hpp
│   │   └── vars.hpp
│   ├── api.cpp
│   ├── api.hpp
│   ├── cheats
│   │   ├── features
│   │   │   ├── backtrack
│   │   │   │   ├── backteack.cpp
│   │   │   │   └── backtrack.hpp
│   │   │   ├── blacklist
│   │   │   │   ├── blacklist.cpp
│   │   │   │   └── blacklist.hpp
│   │   │   ├── cache
│   │   │   │   ├── cache.cpp
│   │   │   │   └── cache.hpp
│   │   │   ├── callbacks
│   │   │   │   ├── callbacks.cpp
│   │   │   │   └── callbacks.hpp
│   │   │   ├── combat
│   │   │   │   ├── RCS
│   │   │   │   │   ├── RCS.cpp
│   │   │   │   │   └── RCS.hpp
│   │   │   │   ├── aimbot
│   │   │   │   │   ├── aimbot.cpp
│   │   │   │   │   ├── aimbot.hpp
│   │   │   │   │   ├── aimbotDraw.cpp
│   │   │   │   │   ├── aimbotDraw.hpp
│   │   │   │   │   └── helper.hpp
│   │   │   │   └── triggerbot
│   │   │   │       ├── triggerbot.cpp
│   │   │   │       └── triggerbot.hpp
│   │   │   ├── events
│   │   │   │   ├── events.cpp
│   │   │   │   └── events.hpp
│   │   │   ├── fakelatency
│   │   │   │   ├── fakelatency.cpp
│   │   │   │   └── fakelatency.hpp
│   │   │   ├── logger
│   │   │   │   ├── logger.cpp
│   │   │   │   └── logger.hpp
│   │   │   ├── misc
│   │   │   │   ├── cameras
│   │   │   │   │   ├── freeCam.cpp
│   │   │   │   │   └── freeCam.hpp
│   │   │   │   ├── disable
│   │   │   │   │   ├── convars.cpp
│   │   │   │   │   ├── convars.hpp
│   │   │   │   │   ├── interpolate.cpp
│   │   │   │   │   └── interpolate.hpp
│   │   │   │   ├── flashlight
│   │   │   │   │   ├── flashlight.cpp
│   │   │   │   │   └── flashlight.hpp
│   │   │   │   ├── movement
│   │   │   │   │   ├── movement.cpp
│   │   │   │   │   └── movement.hpp
│   │   │   │   └── thirdperson
│   │   │   │       ├── thirdperson.cpp
│   │   │   │       └── thirdperson.hpp
│   │   │   ├── particle
│   │   │   │   ├── particle.cpp
│   │   │   │   └── particle.hpp
│   │   │   ├── prediction
│   │   │   │   ├── prediction.cpp
│   │   │   │   └── prediction.hpp
│   │   │   ├── tests
│   │   │   │   ├── test.cpp
│   │   │   │   └── test.hpp
│   │   │   └── visuals
│   │   │       ├── chams
│   │   │       │   ├── chams.cpp
│   │   │       │   ├── chams.hpp
│   │   │       │   ├── editor.cpp
│   │   │       │   ├── editor.hpp
│   │   │       │   └── factory
│   │   │       │       ├── factory.cpp
│   │   │       │       └── factory.hpp
│   │   │       ├── glow
│   │   │       │   ├── glow.cpp
│   │   │       │   └── glow.hpp
│   │   │       ├── hitmarker
│   │   │       │   ├── hitmark.cpp
│   │   │       │   └── hitmark.hpp
│   │   │       ├── list
│   │   │       │   ├── playerlist.cpp
│   │   │       │   ├── playerlist.hpp
│   │   │       │   ├── spectactors.cpp
│   │   │       │   └── spectactors.hpp
│   │   │       ├── mirrorcam
│   │   │       │   ├── mirrorCam.cpp
│   │   │       │   └── mirrorCam.hpp
│   │   │       ├── misc
│   │   │       │   ├── bulletUpdater.cpp
│   │   │       │   ├── bulletUpdater.hpp
│   │   │       │   ├── crosshair.cpp
│   │   │       │   ├── crosshair.hpp
│   │   │       │   ├── drawInfo.hpp
│   │   │       │   ├── drawinfo.cpp
│   │   │       │   ├── motionblur.cpp
│   │   │       │   ├── motionblur.hpp
│   │   │       │   ├── noscope.cpp
│   │   │       │   ├── noscope.hpp
│   │   │       │   ├── screenEffects.cpp
│   │   │       │   ├── screenEffects.hpp
│   │   │       │   ├── trails.cpp
│   │   │       │   └── trails.hpp
│   │   │       ├── player
│   │   │       │   ├── boxes.cpp
│   │   │       │   ├── boxes.hpp
│   │   │       │   ├── enemyWarn.cpp
│   │   │       │   ├── enemyWarn.hpp
│   │   │       │   ├── player.cpp
│   │   │       │   ├── player.hpp
│   │   │       │   ├── sounds.cpp
│   │   │       │   └── sounds.hpp
│   │   │       ├── plots
│   │   │       │   ├── plots.cpp
│   │   │       │   └── plots.hpp
│   │   │       ├── radar
│   │   │       │   ├── radar.cpp
│   │   │       │   └── radar.hpp
│   │   │       ├── streamproof
│   │   │       │   ├── streamproof.cpp
│   │   │       │   └── streamproof.hpp
│   │   │       ├── tracer
│   │   │       │   ├── tracer.cpp
│   │   │       │   └── tracer.hpp
│   │   │       └── world
│   │   │           ├── ambient.cpp
│   │   │           ├── ambient.hpp
│   │   │           ├── bomb.cpp
│   │   │           ├── bomb.hpp
│   │   │           ├── dropped.cpp
│   │   │           ├── dropped.hpp
│   │   │           ├── fog.cpp
│   │   │           ├── fog.hpp
│   │   │           ├── impacts.cpp
│   │   │           ├── impacts.hpp
│   │   │           ├── lights.cpp
│   │   │           ├── lights.hpp
│   │   │           ├── modulateColors.cpp
│   │   │           ├── modulateColors.hpp
│   │   │           ├── molotov.cpp
│   │   │           ├── molotov.hpp
│   │   │           ├── nadepred.cpp
│   │   │           ├── nadepred.hpp
│   │   │           ├── nadewarn.cpp
│   │   │           ├── nadewarn.hpp
│   │   │           ├── projectiles.cpp
│   │   │           ├── projectiles.hpp
│   │   │           ├── removeSky.cpp
│   │   │           ├── removeSky.hpp
│   │   │           ├── skybox.cpp
│   │   │           ├── skybox.hpp
│   │   │           ├── smoke.cpp
│   │   │           ├── smoke.hpp
│   │   │           ├── tone.cpp
│   │   │           ├── tone.hpp
│   │   │           ├── weather
│   │   │           │   ├── _menu.cpp
│   │   │           │   ├── _menu.hpp
│   │   │           │   ├── ground.cpp
│   │   │           │   ├── ground.hpp
│   │   │           │   ├── helper.hpp
│   │   │           │   ├── precipitation.cpp
│   │   │           │   └── precipitation.hpp
│   │   │           ├── zeus.cpp
│   │   │           └── zeus.hpp
│   │   ├── game
│   │   │   ├── game.cpp
│   │   │   ├── game.hpp
│   │   │   └── globals.hpp
│   │   ├── helper
│   │   │   ├── initable.hpp
│   │   │   └── shutdownable.hpp
│   │   └── hooks
│   │       ├── addEntity.cpp
│   │       ├── addEntity.hpp
│   │       ├── allocKeyvalues.cpp
│   │       ├── allocKeyvalues.hpp
│   │       ├── buildTransformations.cpp
│   │       ├── buildTransformations.hpp
│   │       ├── cHudIsHidden.hpp
│   │       ├── chudIsHidden.cpp
│   │       ├── clientModeCSNormalEvent.cpp
│   │       ├── clientModeCSNormalEvent.hpp
│   │       ├── createEvent.cpp
│   │       ├── createEvent.hpp
│   │       ├── createMove.cpp
│   │       ├── createMove.hpp
│   │       ├── createParticlePrecip.cpp
│   │       ├── createParticlePrecip.hpp
│   │       ├── decalAddToSurface.cpp
│   │       ├── decalAddToSurface.hpp
│   │       ├── decalCreate.cpp
│   │       ├── decalCreate.hpp
│   │       ├── dispatchInnerParticlePrecip.cpp
│   │       ├── dispatchInnerParticlePrecip.hpp
│   │       ├── doExtraBonesProcessing.cpp
│   │       ├── doExtraBonesProcessing.hpp
│   │       ├── doPostScreenEffects.cpp
│   │       ├── doPostScreenEffects.hpp
│   │       ├── drawEffects.cpp
│   │       ├── drawEffects.hpp
│   │       ├── drawIndexPrimitive.cpp
│   │       ├── drawIndexPrimitive.hpp
│   │       ├── drawModelExecute.cpp
│   │       ├── drawModelExecute.hpp
│   │       ├── drawSetColor.cpp
│   │       ├── drawSetColor.hpp
│   │       ├── drawTranslucentRenderables.cpp
│   │       ├── drawTranslucentRenderables.hpp
│   │       ├── drawWorldAndEntities.cpp
│   │       ├── drawWorldAndEntities.hpp
│   │       ├── filesCheck.cpp
│   │       ├── filesCheck.hpp
│   │       ├── findMaterial.cpp
│   │       ├── findMaterial.hpp
│   │       ├── frameStageNotify.cpp
│   │       ├── frameStageNotify.hpp
│   │       ├── getColorModulation.cpp
│   │       ├── getColorModulation.hpp
│   │       ├── getPMaterial.cpp
│   │       ├── getPMaterial.hpp
│   │       ├── getPhysicsProperties.cpp
│   │       ├── getPhysicsProperties.hpp
│   │       ├── getUnverifiedFileHashes.cpp
│   │       ├── getUnverifiedFileHashes.hpp
│   │       ├── getVCollide.cpp
│   │       ├── getVCollide.hpp
│   │       ├── getVelocity.cpp
│   │       ├── getVelocity.hpp
│   │       ├── helpers
│   │       │   ├── common.hpp
│   │       │   └── helper.hpp
│   │       ├── hooks.cpp
│   │       ├── hooks.hpp
│   │       ├── initializeParticlePrecip.cpp
│   │       ├── initializeParticlePrecip.hpp
│   │       ├── isDepth.cpp
│   │       ├── isDepth.hpp
│   │       ├── isFollowingEntity.cpp
│   │       ├── isFollowingEntity.hpp
│   │       ├── isHltv.cpp
│   │       ├── isHltv.hpp
│   │       ├── isUsingStaticPropDebugModes.cpp
│   │       ├── isUsingStaticPropDebugModes.hpp
│   │       ├── levelInitPostEntity.cpp
│   │       ├── levelInitPostEnttity.hpp
│   │       ├── levelInitPreEntity.cpp
│   │       ├── levelInitPreEntity.hpp
│   │       ├── levelShutdown.cpp
│   │       ├── levelShutdown.hpp
│   │       ├── lockCursor.cpp
│   │       ├── lockCursor.hpp
│   │       ├── mapLoaderInit.cpp
│   │       ├── mapLoaderInit.hpp
│   │       ├── newParticleEffectSetControlPoint.cpp
│   │       ├── newParticleEffectSetControlPoint.hpp
│   │       ├── overrideConfig.cpp
│   │       ├── overrideConfig.hpp
│   │       ├── overrideMouse.cpp
│   │       ├── overrideMouse.hpp
│   │       ├── overrideView.cpp
│   │       ├── overrideView.hpp
│   │       ├── paintTraverse.cpp
│   │       ├── paintTraverse.hpp
│   │       ├── particlesSimulation.cpp
│   │       ├── particlesSimulation.hpp
│   │       ├── playStepSound.cpp
│   │       ├── playStepSound.hpp
│   │       ├── present.cpp
│   │       ├── present.hpp
│   │       ├── processSpottedEntityUpdate.cpp
│   │       ├── processSpottedEntityUpdate.hpp
│   │       ├── removeEntity.cpp
│   │       ├── removeEntity.hpp
│   │       ├── renderSmokeOverlay.cpp
│   │       ├── renderSmokeOverlay.hpp
│   │       ├── reset.cpp
│   │       ├── reset.hpp
│   │       ├── screen2dEffect.hpp
│   │       ├── screen2deffect.cpp
│   │       ├── sendDatagram.cpp
│   │       ├── sendDatagram.hpp
│   │       ├── svcheats.cpp
│   │       ├── svcheats.hpp
│   │       ├── tracerDraw.cpp
│   │       ├── tracerDraw.hpp
│   │       ├── unknownFIleSys.cpp
│   │       ├── unknownFileSys.hpp
│   │       ├── unknownOverviewMap.cpp
│   │       ├── unknownOverviewMap.hpp
│   │       ├── unknownPlayerHurt.cpp
│   │       ├── unknownPlayerHurt.hpp
│   │       ├── unkownRoundEnd.cpp
│   │       ├── unkownRoundEnd.hpp
│   │       ├── updatePostEffects.cpp
│   │       ├── updatePostEffects.hpp
│   │       ├── vCollideLoad.cpp
│   │       ├── vCollideLoad.hpp
│   │       ├── viewFade.cpp
│   │       ├── viewFade.hpp
│   │       ├── viewRender.cpp
│   │       ├── viewRender.hpp
│   │       ├── wndproc.cpp
│   │       └── wndproc.hpp
│   ├── config
│   │   ├── cfgBeam.hpp
│   │   ├── cfgBox.hpp
│   │   ├── cfgCham.hpp
│   │   ├── cfgWeapon.cpp
│   │   ├── cfgWeapon.hpp
│   │   ├── cfgcolor.cpp
│   │   ├── cfgcolor.hpp
│   │   ├── config.cpp
│   │   ├── config.hpp
│   │   ├── enums.hpp
│   │   ├── jsonExtended.cpp
│   │   ├── jsonExtended.hpp
│   │   ├── key.cpp
│   │   ├── key.hpp
│   │   └── vars.hpp
│   ├── deps
│   │   ├── ImGui
│   │   │   ├── editor
│   │   │   │   ├── LanguageDefinitions.cpp
│   │   │   │   ├── TextEditor.cpp
│   │   │   │   └── TextEditor.hpp
│   │   │   ├── extraDraw.cpp
│   │   │   ├── extraDraw.hpp
│   │   │   └── imgui_markdown.h
│   │   ├── README.md
│   │   ├── delaunator-cpp
│   │   │   └── delaunator.hpp
│   │   ├── images
│   │   │   └── fatchad.png
│   │   ├── magic_enum
│   │   │   └── prettyNames.hpp
│   │   ├── mem
│   │   │   ├── aligned_alloc.h
│   │   │   ├── arch.h
│   │   │   ├── bitwise_enum.h
│   │   │   ├── boyer_moore_scanner.h
│   │   │   ├── char_queue.h
│   │   │   ├── cmd_param-inl.h
│   │   │   ├── cmd_param.h
│   │   │   ├── cpp.hint
│   │   │   ├── data_buffer.h
│   │   │   ├── defines.h
│   │   │   ├── execution_handler.h
│   │   │   ├── hasher.h
│   │   │   ├── init_function.h
│   │   │   ├── macros.h
│   │   │   ├── mem.h
│   │   │   ├── module.h
│   │   │   ├── pattern.h
│   │   │   ├── pattern_cache.h
│   │   │   ├── prot_flags.h
│   │   │   ├── protect.h
│   │   │   ├── rtti.h
│   │   │   ├── simd_scanner.h
│   │   │   ├── slice.h
│   │   │   ├── stub.h
│   │   │   └── utils.h
│   │   └── missing
│   │       ├── bluelight1.vmt
│   │       ├── bluelight1.vtf
│   │       ├── bluelightning.vmt
│   │       ├── bluelightning.vtf
│   │       ├── lgtning.vmt
│   │       ├── lgtning.vtf
│   │       ├── physcannon_bluelight1.vmt
│   │       ├── physcannon_bluelight1.vtf
│   │       ├── physcannon_bluelight1b.vmt
│   │       ├── physcannon_bluelight1b.vtf
│   │       ├── snowflake.vmt
│   │       └── snowflake.vtf
│   ├── gamememory
│   │   ├── address.cpp
│   │   ├── address.hpp
│   │   ├── memory.cpp
│   │   ├── memory.hpp
│   │   ├── modules.hpp
│   │   ├── sigs.hpp
│   │   └── system
│   │       ├── win.cpp
│   │       └── win.hpp
│   ├── menu
│   │   ├── GUI-ImGui
│   │   │   ├── imguiaddons.cpp
│   │   │   ├── imguiaddons.hpp
│   │   │   ├── menu.cpp
│   │   │   ├── menu.hpp
│   │   │   ├── sections
│   │   │   │   ├── background.cpp
│   │   │   │   ├── background.hpp
│   │   │   │   ├── combat
│   │   │   │   │   ├── aim.cpp
│   │   │   │   │   └── aim.hpp
│   │   │   │   ├── common.hpp
│   │   │   │   ├── editors
│   │   │   │   │   ├── chamsEditor.cpp
│   │   │   │   │   ├── chamsEditor.hpp
│   │   │   │   │   ├── editors.cpp
│   │   │   │   │   ├── editors.hpp
│   │   │   │   │   ├── styleEditor.cpp
│   │   │   │   │   └── styleEditor.hpp
│   │   │   │   ├── misc
│   │   │   │   │   ├── misc.cpp
│   │   │   │   │   └── misc.hpp
│   │   │   │   ├── settings
│   │   │   │   │   ├── settings.cpp
│   │   │   │   │   └── settings.hpp
│   │   │   │   └── visuals
│   │   │   │       ├── visuals.cpp
│   │   │   │       └── visuals.hpp
│   │   │   ├── selections.hpp
│   │   │   ├── styles
│   │   │   │   ├── styles.cpp
│   │   │   │   └── styles.hpp
│   │   │   └── tabrender.hpp
│   │   └── x88Menu
│   │       ├── x88menu.cpp
│   │       ├── x88menu.hpp
│   │       └── x88types.hpp
│   ├── render
│   │   ├── BBox.cpp
│   │   ├── BBox.hpp
│   │   ├── Color.cpp
│   │   ├── Color.hpp
│   │   ├── backend
│   │   │   ├── backend.cpp
│   │   │   └── backend.hpp
│   │   ├── fonts
│   │   │   ├── fontawesome.hpp
│   │   │   └── icon.hpp
│   │   ├── render.cpp
│   │   ├── render.hpp
│   │   ├── structures.cpp
│   │   └── structures.hpp
│   ├── resources
│   │   ├── csgo-legit.rc
│   │   └── resource.h
│   ├── setup
│   │   ├── setup.cpp
│   │   └── setup.hpp
│   └── utilities
│       ├── cStr.hpp
│       ├── console
│       │   ├── console.cpp
│       │   ├── console.hpp
│       │   ├── consoleDraw.cpp
│       │   ├── consoleDraw.hpp
│       │   └── consoleUtils.hpp
│       ├── inputSystem.cpp
│       ├── inputSystem.hpp
│       ├── math
│       │   ├── math.cpp
│       │   └── math.hpp
│       ├── rand.hpp
│       ├── res.cpp
│       ├── res.hpp
│       ├── runnable.hpp
│       ├── simpleTimer.hpp
│       ├── tools
│       │   ├── tools.cpp
│       │   ├── tools.hpp
│       │   └── wrappers.hpp
│       ├── utilities.cpp
│       └── utilities.hpp
├── pch.cpp
├── pch.h
├── pictures
│   ├── editor.png
│   ├── fixedBlurryGlowLine.png
│   ├── fixed_glow.png
│   ├── molotov.png
│   ├── nade1.png
│   ├── nade2.png
│   ├── obsProofGameMaterials.png
│   ├── plots.png
│   └── radar.png
├── source.cpp
└── vcpkg.json

```

`LICENSE`:

```
MIT License

Copyright (c) 2021-2022 Bartis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# Csgo

![Bartis internal CSGO](https://user-images.githubusercontent.com/69613796/179428634-adf44410-4002-4e5d-9ac5-b794dcb1c35f.png)

## Introduction

This project is and was a part of my c++ and game-hacking journey. The biggest focus of this cheat is on the visual aspects of the game Counter-Strike: Global Offensive (CSGO).

Please note that this cheat is for educational purposes only, provided as a training software. To ensure your safety while using cheats, it is recommended to use a reliable VAC module dumper and debug any outputted files. It is important to also look what client does to the game. You can start by understanding the information provided in the [VAC GitHub repository](https://github.com/danielkrupinski/VAC).

## Features

<details>
<summary>List of Features</summary>

* Aimbot: The aimbot feature provides various options such as smoothing, delay, and the ability to select hitboxes and define visibility rules. It sets the position of the mouse and retrieves data from the `createMove` function to ensure accuracy. It can be configured with a hotkey.
* Recoil Control System (RCS): The RCS feature allows you to control recoil by communicating with the game in a similar manner as the aimbot. It can be matched with custom pitch and yaw settings.
* Triggerbot: The triggerbot automatically shoots at targets when they are in your crosshair. It can be configured with a customizable delay.
* Backtrack: This feature manipulates the client to send a fake tickrate, enabling the storage of historical records. This allows you to shoot and hit targets as if they were in the past.
* Fake Latency: By sending fake latency to the server, this feature provides an additional tool for backtrack functionality.
* Bunnyhop: The bunnyhop feature enables automatic strafing and includes an autostrafe function to help accelerate sidemoves. It can be configured with a chance of successful bunnyhops.
* Thirdperson: This feature activates the third-person view in the game. It includes tracing to avoid clipping with walls. The position and hotkey can be customized.
* Crosshairs: This feature displays crosshairs in various styles or forces the game to display its own crosshair.
* Local Information: This feature provides information about the local player, such as ammunition, position, and more.
* Plots: The plots feature displays frames per second (FPS) and velocity using ImPlot. Velocity data is gathered from prediction.
* Hitmarker: When a hit occurs, this feature displays a hit position with a custom hitmark.
* No Scope: This feature nullifies the game's blur scope shader.
* Bullet Tracer: Bullet tracers use the game's engine beams to display the source and destination of bullets.
* Flashlight: This feature utilizes the game's flashlight effect.
* Nade Prediction: Predicts where grenades will land. A nade tracer displays the trajectory of grenades.
* Engine Prediction: Provides 1:1 prediction from the game, allowing accurate gathering of player data.
* Chams: Overrides the model with custom materials. It also allows the addition of custom materials at runtime using a user-friendly editor.
* Glow: This feature is a rebuild of game's build in glow system. And exposes visibility stencil done correctly.
* Sound Esp: A replica of the Apex Legends sound passive of the Bloodhound character.
* ESP (Extra Sensory Perception): Displays information about players, such as boxes, dlights, health, armor, flags, and more.
* Enemy Aiming at You Warning: Displays a small warning text when an enemy is aiming at you.
* 2D Radar: Displays a custom radar with a rotated background image, hiding the game's default radar to prevent overdraw.
* Skybox: Allows loading of any skybox into the game.
* Edit World Colors: Modulates the color of textures in the game world.
* Movement Trails: Displays lines representing recent player movement.
* Bullet Impacts: Displays cubes representing the positions where bullets hit.
* Edit Particle Color: Edits the color of effects such as molotov, smoke, and blood impacts.
* Draw Dropped Weapons: Displays dropped weapons with additional information.
* Bomb Overlay with Info: Displays bomb-related information as an overlay.
* Mirrorcam: Displays a mirror camera overlay.
* Freecam: Enables a freecam mode similar to Minecraft, allowing free movement.
* Blacklist: Sets priority for targeting specific entities.
* Playerlist: Stores entities in a centralized map.
* Logger: Logs game actions.
* Ambient: Forces the game to render ambient light.
* Fog: Control the fog effect in the game.
* Tone: Control the tone effect in the game.
* Weather: Renders precipitation effects in the game.
* Interpolation: Disables interpolation completely.
* Flashbang Reduce: Reduces the alpha of flashbang effects.
* Screen Effects: Forces the game to render selected effects.
* Motion Blur: Replicates the game's motion blur effect.
* Molotov and Smoke Overlays: Displays circles or polygons representing the radius of smoke or molotov effects.
* Zeus Display: Draws a circle representing the range of the Zeus taser and allows tracing of the polyline.
* World lights: Edit world lights directly, with possibility to restore original values.
</details>

<details>
<summary>Extra</summary>

* Threadsafe streamproof render wrapper, surface rendering is deprecated
* Icon extraction from the game to image
* Game callbacks
* Entity cache
* Hook-to-feature communication using handlers
* Logging console
* Game events (everything gathered from hooks, possible to create own though)
* Compile-time signature to optional bytes conversion
* Exports and memory class
* Netvars with dumping
* Interfaces with dumping
* Runtime shutdown with proper release of features
* Streamproof game's material rendering (some render states have problem)
</details>

## Building Instructions

### Requirements:

* [Git](https://git-scm.com/download/win)
* [Visual Studio](https://visualstudio.microsoft.com/)
* [C++ Redistributables](https://docs.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170)
* [DirectX](https://www.microsoft.com/en-us/download/details.aspx?id=35)
* [vcpkg](https://vcpkg.io/en/index.html)

Note: Git is optional but recommended for staying up to date with the project.

After making any configuration changes, delete the existing entry and let the program create a new default configuration.

### Dependencies

The dependencies folder is not for including dependencies themselves. If the dependencies are available in vcpkg, do not include them manually. Only include unsupported libraries or custom addons as rare exceptions.

## Building the Project

Please follow the steps outlined in the [Vcpkg Getting Started guide](https://github.com/Microsoft/vcpkg#getting-started). After installing the necessary dependencies, open the project in Visual Studio and click "Build". If any errors occur, please open an issue.

## Running the Cheat

The default key to open the cheat's menu is `INSERT`. Additional options within the menu will be self-explanatory.
For debugging the cheat please use injection method that lets you fully load pdb. As simpliest is better.
Debug build does allow exceptions, whereas release mode doesn't. Api will still take care to "simulate" the throws in the code.

# Log
<details>

* 1.0.0 - initial commit
* 1.0.1 - small fixes in code + rainbow chams
* 1.0.2 - improved a bit performance, changed render text function to modern wstring, aimbot big drops fixed, aimbot now uses ranged loop for hitboxes
* 1.0.3 - added PlayerResource class which contain kills deaths and ping. Improved some of the features again
* 1.0.4 - fixed typo for backtrack and added in comments ticks option to backtrack, I personally don't need it, hence why it's commented
* 1.0.5 - cleaned up the source in visuals and render. Added new player visuals. Fixed padding in one SDK class, added skeleton ESP. In utils there is a new conventer function which you can very easily use to get distance to enemy in meters (unit to meters)
* 1.0.6 - small update with removing fps drops while menu is opened
* 1.0.7 - big update for performance and cleanup in code, a lot of useless defines have been removed. Changed console::log function to take only one string and log type, string can be easily used with std::format
* 1.0.8 - small update with making menu usage more easier, items are now in map and features can be passed as name for vars::names map
* 1.0.9 - big update for performance, recode, and code style. All functions are camel case. I seperated visuals to be in few files since it's better to read and move in code. Added even more visuals once again. Fixed prediction, thanks: [kaposzta99](https://github.com/Bartis1313/csgo/issues/4)
* 1.1.0 - update came with fixes: triggerbot, backtrack records and SDK. Added Dlight and "nightmode" that just forces other skybox. Few very small addons to menu and code changes.
* 1.1.1 - small update with new planned feature and handling the error in case the directory can't be created.
* 1.1.2 - 2D plot added, for fps and velocity. From now if config fails to find file to save, it throws the error.
* 1.1.3 - Added hand/weapon chams, and rewrote chams code.
* 1.1.4 - Added global shots counter, which can result in getting valid accuracy per round, and hitmarker with sound got added.
* 1.1.5 - Added visibility check, in aimbot and triggerbot. Some visuals added.
* 1.1.6 - Changed aimbot, fixed visibility, aimbot now uses only one function to run. Added no scope overlay.
* 1.1.7 - fixed code, added more visuals. Added few more things to SDK.
* 1.1.8 - added image rendering, pretty simple as it does need only one argument. Console logging is a bit simplier now. Fixed the main thread call with handling critical errors correctly.
* 1.1.9 - very small update. Added check for paint hook, implemented idea of gui.
* 1.2.0 - update to gui and few fixes in random files. (broke the git again..., lol)
* 1.2.1 - GUI update with finishing ideas of everything, recode is still needed for automatic padding for GUI objects or add ideally add flags to choose.
* 1.2.2 - Big GUI update, it now can use auto padding, changed few comments to make it easier to understand in whole code. Still it needs few fixes.
* 1.2.3 - Almost GUI is finished, few things left.
* 1.2.4 - Update on new config system using type safe checks, menu is finally ready to work with variables and multiple configs. Fixed, removed bunch of functions. Deleted singleton as it's a very bad choice to work with single class objects. Reduced many calls. Made return address more easier.
* 1.2.5 - Made surface GUI example to be working correctly. Added ImGui + freetype libraries, as it's next goal to use this GUI framework as example + solid rendering. Fixed code in few places, and removed oftently changed files from precompilation, which could lead to errors.
* 1.2.6 - Added ImGui example, added ghetto fix for sendpacket, although it's not used. It's a temp fix. Made hooking even easier to use now.
* 1.2.7 - Added ImGuiRender class which has a rich amount of functions, arguments are almost everywhere same as in surface rendering. GUI made with surface has been deleted aswell as x88 menu, if you need to know how was it done, search old repo commits. Cleaned up whole sdk and code in few places.
* 1.2.8 - Fixed few rendering bugs. Added basic imgui menu, if you care for styling etc... go make a pull request so people can use it as some replacement. Keep in mind - any imgui addons that are not included in the lib should be made in imguiaddons.hpp at all. Color now has a different type, due to making it easier for floating points. You will still be able to use it as 0-255 range.
* 1.2.9 - Few fixes in some places, nothing really big. I will start making commits comments a bit better from now on, more detailed.
* 1.3.0 - Huge recode, cleaned up most of bloat header includes. Features are now not in namespace but class. Improved code quality almost everywhere. Fixed unloading the cheat not causing any errors. Plots are totally rewritten. Fixed couple of features, although chams are temporiarly not possible. I am thinking of clean solution for them. Added console from imgui demo which will show current loggings. Still a lot of code needs rewrite.
* 1.3.1 - Added option "load on start", which will load selected config on the start.
* 1.3.2 - The hitmarker is now finished. Nothing more in this version.
* 1.3.3 - Fixed "Enemy is aiming at you", aimbot, and many more. And added working chams, still small fixes are needed to them.
* 1.3.4 - Fixed stupid math calcAngle basing on src - dst logic, made it same as calcAngleRelative with how delta is achieved. Few rendering improvements such as rendering font. Use cached bones for calculating the pos. Added posibility to render icons from the game. Added lines to radar.
* 1.3.5 - Fixes in visuals and addons. Addons as nade timers, editing molotov color, flags done with distance scaling.
* 1.3.6 - Fixes new update crash and config based crashes. Added many effects and edited code in many places. Everything is detailed in the commit.
* 1.3.7 - Fake latency, and I hope last backtrack. Make sure prediction is updated when deltatick is any value, just like game does. Added bomb overlay, not perfect for resizing because the size is always the same.
* 1.3.8 - Key detection made properly. Using 2 classes to detect it, as first using messages coming from wndproc is running 24/7 and other only listens to given key from config. Why making own detection? ImGui has it, but then you will have to deal with flickering cursor problems if want to run it 24/7.
* 1.3.9 - Reback x88 menu, this time with better types detection and code. It also has ability to change config variables by operating on arrow keys.
* 1.4.0 - After some break, added the grenade warning, lacks of visuals and custom choices of colors etc... No more errors with std::format, small config issue fixed.
* 1.4.1 - Nade prediction should output given dmg by nade, or inform if inferno is in range. Fonts contain pixel size at the end now. Input system will now only work when: we are not in key hotkey, when vgui console is off, when chat window is off.
* 1.4.2 - Rainbow colors can be an option from picker, remade color picker + logic in config for color.
* 1.4.3 - Finish nade prediction at all, warning for tracers will be scaled with distance to the nade.
* 1.4.4 - Sound esp is done. Credits to the guy who had the idea with this. Scaling included for sound circles.
* 1.4.5 - Changes in code, mainly to render low levels things such as images by resources. Few slight changes into imgui: add ability to load up image by memory, ability to draw multicolors with poly. Discord rpc with updated information from client.
* 1.4.6 - Texture rendered in the radar, I run on some weird problems there and unfortunately because of the dds file format it's impossible to use Resource class. Cleaned the project settings. Instead of ignoring the error of unsafe function, getting time is threadsafe now. Game color edits are now run per each instead of applying whole list.
* 1.4.7 - Easy cfg load on start option, setting load cfg won't save current variables but only name to load.
* 1.4.8 - Added mirrorcam (rendering by ImGui), freecam, freelook, fixed SEH catching allocation for symbols. Console logging is now locked, it's better to run them in mutex.
* 1.4.9 - Flashlight fixed and added it as a feature. Recoded rendering to take ImVec2 instead of vector2D when using imgui. Fixed/recoded drawing 3d boxes completely. Init localplayer once (and this method probably fixes crashes). Gather prediction move data from stack. Pass std::span as normal copy, not cref.
* 1.5.0 - World screen effects added: fog, tone control, draw screen effects.
* 1.5.1 - Add weather effect.
* 1.5.2 - Added 1:1 motion blur from source leak. Controlling thirdperson should be quite better as now it traces the distance to any objects, just like game originally does. Added extra options to it as suggested in: [#41](https://github.com/Bartis1313/csgo/issues/41). Added comments for sigs, I can't shortly explain how to use RTTI info in 3 lines, so this is just very basic string ref info.
* 1.5.3 - HUGE recode, cleanup in way that features are inited and run. Also general cleanup/fixes in features. Now every change will be much easier to make, without calling some run() method manually, it all gets called by static object vec, code itself explains it very well. Each class has one task to do, or very limited to more.
* 1.5.4 - Simplified constructors in base classes. If possible they should be constexpr.
* 1.5.5 - Config update for weapons selection in aimbot. Fixed crash with weather on new map. Cleaned up menu a bit.
* 1.5.6 - Few checks added to aimbot, triggerbot, backtrack and player visuals.
* 1.5.7 - Visual update for fading, players and dropped weapons. Cleanup in Resource class.
* 1.5.8 - Cache for ents done, when drawing something ent based in present hook you should stick to normal classic loop, as commented in radar file.
* 1.5.9 - Memory cleanup, static offsets were always a problem due to short lag while gathering the offset. Now it run once at the start + adding it should be very easy. Handled exports, mostly needed for sig scan and CreateInterface.
* 1.6.0 - Include paths.
* 1.6.1 - Include paths v2.
* 1.6.2 - Source cleanup, generic vector & matrix.
* 1.6.3 - Once again better generic vector. Config is now stored in nice-looking json + accessing values is not painful. Cleanup is still needed. Better smoothing included in aimbot, still needs some extensions.  
* 1.6.4 - Config fix again, added magic_enum to not repat same names in the selections namespace.
* 1.6.5 - Bit of clean up with memory, interfaces and valid entity cache that will work for any frame. And maybe crash fixes?
* 1.6.6 - Cleanup, base classes for features are now more abstract. Fixed crash due to wrong allocation for vector. Rebuild hook structs to be defined with macros.
* 1.6.7 - Wip menu.
* 1.6.8 - Finished menu animations/movelikes.
* 1.6.9 - Playerlist added (blacklist not done yet), changed render to take unique ptr.
* 1.7.0 - Blacklist finished, including crash fixes.
* 1.7.1 - Refactor of code. Fixes, and some addons, especially hooks. Deatailed in commit.
* 1.7.2 - Cleanup for lerping animation.
* 1.7.3 - visuals health/armor bug fix, more "clear" hooked functions definitions, accurate info gathered directly from the game about shots, not using events to count them manually (awful!). Prediction last edits. SDK cleanup and addons. Sound is finally not using events, wip to remove other events. Editor still not finished, almost... Plots reworked to work for last rendering change. Fixes to radar, eg: MapStruct, triangle enemies.
* 2.0.0 - Made it as a new version since it does change a lot. Provided very simple instruction for people who want to use this at long end. Bunch of very few refactors/renames in functions. 2.0 is now having a friendly folder structure. Replaced render from utils to own folder. As well as other things which were "overnamed" to be in utils. Very soon to finally end that project.
* 2.0.1 - Removed xorstr from here, it's a public source. Fixed hotkey with id detection, removed FORMAT wrapper since there is now no need. Removed console macros to few wrapping functions, removed macro for EXPORT, replaced in memory namespace as a template function. Added game punch which should be more "smoothed". Wip SEHCatch as well as features cleanup.
* 2.0.2 - Ending it soon... Finally got some free time. What is worth mentioning is fixing the aimbot smooth as well as RCS, they both now never set angles. Chams editor is finally added, current code is very far from clean, but the generation / updating / deleting / saving work well. Molotov now has a better way of drawing its range, added fancy triangulation with some poor workarounds to make it scaled.
* 2.0.3 - Added proper icon parsing, glow 1:1 to the game's code, constexpr signature to hex, less logging on release, fixed few crashes under visual features, and possible crashes with material system. What's left is cleaning up this code.
* 2.0.4 - Dropped animations, it's useless to keep it updated all the time to newest lib version. Colorized the menu, and somewhat reworked look of it. render -> use namespace, and deprecate surface at all. Provided rendering backends for easier lookup. x88 menu now won't update keys if we don't want to. Control present / reset targets on own for streamproof method. Completely removed vectored handler - reason is because we can actually force memory leaks? That's happening eg: if you are the local host. Did some random cleanups.
* 2.0.5 - menu recode, I hope it's "clean" now. Recode of bunch of classes, WIP chams editor cleanup, because it annoys me how complicated it is.
* 3.0.0 - WIP refactor, making it as 3rd version due to the hard cleanup / refactor (not finished yet). I basically removed stupid OOP forcing to some real abstraction with hook and feature.
* 3.0.1 - Fixed UB stuff, detailed in commit message.
* 3.0.2 - Fixed the glow system, with better and more performant solution. I have also fixed the glow box lines with fading color. Added basic streamproof solution, which lacks some aspects and I couldn't force the game to understand some render states. Added interface names dumping.
* 3.0.3 - Streamproof chams added, world lights modulation added. Chams got somewhat better solutions to render them, especially see ignorez. Tried to mess with collide for weather particles, but failed to understand everything, code was left for testing usage only. Added alternative hooking method, in case anyone needs to mess with gameoverlay.dll. Fixed bug with round ends event. 
* 3.0.4 - Weather works for more types. Removed all listened events, instead gather information from another hook. Particle editing doesn't touch alpha channel anymore.
* 3.0.5 - Weather effects, and 2 bugs fixed. 1st is tone bug with default bloom, 2nd is wrapper for createMaterial missing loadFromBuffer. 
* 3.0.6 - Introduced simple api, to still be able to use ``throw`` instruction. [Manual map errors](https://github.com/Bartis1313/csgo/issues/77) are fixed. Fixed dumped vmt files. Few crashes with few forgotten checks where fixed. Removed discord RPC, because it is deprecated (discord-rpc lib). Introduced own ntdll functions for memory (not used, as currently lazy importer does great job with exports and modules). Cleaned up DllMain. Switched the timer class to use lower level functions for timers (abi didn't change). 
</details>

# People who helped
* [KittenPopo](https://github.com/KittenPopo) - answering questions I have been confused how something works and for cs18 leak which made reversing even easier.
* [Pawel Gozdur](https://github.com/carlos-konewka) - helping me with math, especially plot logic.
* [UC Wiki](https://www.unknowncheats.me/wiki/UnKnoWnCheaTs_Game_Hacking_Wiki) - for very helpful sources.
* [rollraw/qo0](https://github.com/rollraw) - swapchain render.

```

`csgo-legit.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31729.503
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "csgo-legit", "csgo-legit.vcxproj", "{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}.Debug|x86.ActiveCfg = Debug|Win32
		{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}.Debug|x86.Build.0 = Debug|Win32
		{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}.Release|x86.ActiveCfg = Release|Win32
		{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4A5E3217-9F26-49BA-C89A-B76C6BCFEF5C}
	EndGlobalSection
EndGlobal

```

`csgo-legit.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{B4CD8A1A-12C3-50FB-725E-A1B089F416D3}</ProjectGuid>
    <RootNamespace>csgo-legit</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>csgo-legit</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>$(SolutionDir)hack;$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
    <OutDir>.\build\debug\</OutDir>
    <TargetName>Debug_$(ProjectName)</TargetName>
    <SourcePath>$(SourcePath)</SourcePath>
    <IntDir>.\build\Intermediate\Debug\</IntDir>
    <IgnoreImportLibrary>true</IgnoreImportLibrary>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>.\build\Release\</OutDir>
    <LibraryPath>$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
    <IncludePath>$(SolutionDir)hack;$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <TargetName>$(ProjectName)</TargetName>
    <SourcePath>$(SourcePath)</SourcePath>
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <IntDir>.\build\Intermediate\Release\</IntDir>
    <IgnoreImportLibrary>true</IgnoreImportLibrary>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>
    </VcpkgUseMD>
    <VcpkgTriplet>x86-windows-static</VcpkgTriplet>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgTriplet>x86-windows-static</VcpkgTriplet>
    <VcpkgUseMD>
    </VcpkgUseMD>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>WIN32_LEAN_AND_MEAN;NOMINMAX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/std:c++latest %(AdditionalOptions)</AdditionalOptions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <ForcedIncludeFiles>pch.h</ForcedIncludeFiles>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <TreatWarningAsError>true</TreatWarningAsError>
      <BuildStlModules>false</BuildStlModules>
      <ExceptionHandling>Sync</ExceptionHandling>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <RuntimeTypeInfo>true</RuntimeTypeInfo>
    </ClCompile>
    <ProjectReference>
      <UseLibraryDependencyInputs>false</UseLibraryDependencyInputs>
    </ProjectReference>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
      <AdditionalDependencies>d3dx9.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <EntryPointSymbol>DllMainEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_HAS_EXCEPTIONS=0;WIN32_LEAN_AND_MEAN;NOMINMAX;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/std:c++latest /Gw %(AdditionalOptions)</AdditionalOptions>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <CreateHotpatchableImage>
      </CreateHotpatchableImage>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <ForcedIncludeFiles>pch.h</ForcedIncludeFiles>
      <UndefinePreprocessorDefinitions>
      </UndefinePreprocessorDefinitions>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <ForcedUsingFiles>
      </ForcedUsingFiles>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <BuildStlModules>false</BuildStlModules>
      <ExceptionHandling>false</ExceptionHandling>
      <SDLCheck>false</SDLCheck>
      <OmitFramePointers>false</OmitFramePointers>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FloatingPointExceptions>false</FloatingPointExceptions>
      <LanguageStandard_C>Default</LanguageStandard_C>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
    </ClCompile>
    <Link>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
      <AdditionalDependencies>d3dx9.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>DllMainEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="hack\api.cpp" />
    <ClCompile Include="hack\cheats\features\misc\disable\convars.cpp" />
    <ClCompile Include="hack\cheats\features\tests\test.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\chams\factory\factory.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\list\spectactors.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\bulletUpdater.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\noscope.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\streamproof\streamproof.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\lights.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\weather\ground.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\weather\_menu.cpp" />
    <ClCompile Include="hack\cheats\game\game.cpp" />
    <ClCompile Include="hack\cheats\hooks\addEntity.cpp" />
    <ClCompile Include="hack\cheats\hooks\allocKeyvalues.cpp" />
    <ClCompile Include="hack\cheats\hooks\buildTransformations.cpp" />
    <ClCompile Include="hack\cheats\hooks\chudIsHidden.cpp" />
    <ClCompile Include="hack\cheats\hooks\createEvent.cpp" />
    <ClCompile Include="hack\cheats\hooks\createMove.cpp" />
    <ClCompile Include="hack\cheats\hooks\createParticlePrecip.cpp" />
    <ClCompile Include="hack\cheats\hooks\decalAddToSurface.cpp" />
    <ClCompile Include="hack\cheats\hooks\decalCreate.cpp" />
    <ClCompile Include="hack\cheats\hooks\dispatchInnerParticlePrecip.cpp" />
    <ClCompile Include="hack\cheats\hooks\doExtraBonesProcessing.cpp" />
    <ClCompile Include="hack\cheats\hooks\doPostScreenEffects.cpp" />
    <ClCompile Include="hack\cheats\hooks\drawIndexPrimitive.cpp" />
    <ClCompile Include="hack\cheats\hooks\drawModelExecute.cpp" />
    <ClCompile Include="hack\cheats\hooks\drawSetColor.cpp" />
    <ClCompile Include="hack\cheats\hooks\drawTranslucentRenderables.cpp" />
    <ClCompile Include="hack\cheats\hooks\drawWorldAndEntities.cpp" />
    <ClCompile Include="hack\cheats\hooks\filesCheck.cpp" />
    <ClCompile Include="hack\cheats\hooks\findMaterial.cpp" />
    <ClCompile Include="hack\cheats\hooks\frameStageNotify.cpp" />
    <ClCompile Include="hack\cheats\hooks\clientModeCSNormalEvent.cpp" />
    <ClCompile Include="hack\cheats\hooks\getColorModulation.cpp" />
    <ClCompile Include="hack\cheats\hooks\getPhysicsProperties.cpp" />
    <ClCompile Include="hack\cheats\hooks\getPMaterial.cpp" />
    <ClCompile Include="hack\cheats\hooks\getUnverifiedFileHashes.cpp" />
    <ClCompile Include="hack\cheats\hooks\getVCollide.cpp" />
    <ClCompile Include="hack\cheats\hooks\getVelocity.cpp" />
    <ClCompile Include="hack\cheats\hooks\hooks.cpp" />
    <ClCompile Include="hack\cheats\hooks\initializeParticlePrecip.cpp" />
    <ClCompile Include="hack\cheats\hooks\isDepth.cpp" />
    <ClCompile Include="hack\cheats\hooks\isFollowingEntity.cpp" />
    <ClCompile Include="hack\cheats\hooks\isHltv.cpp" />
    <ClCompile Include="hack\cheats\hooks\isUsingStaticPropDebugModes.cpp" />
    <ClCompile Include="hack\cheats\hooks\levelInitPostEntity.cpp" />
    <ClCompile Include="hack\cheats\hooks\levelInitPreEntity.cpp" />
    <ClCompile Include="hack\cheats\hooks\levelShutdown.cpp" />
    <ClCompile Include="hack\cheats\hooks\lockCursor.cpp" />
    <ClCompile Include="hack\cheats\hooks\mapLoaderInit.cpp" />
    <ClCompile Include="hack\cheats\hooks\newParticleEffectSetControlPoint.cpp" />
    <ClCompile Include="hack\cheats\hooks\overrideConfig.cpp" />
    <ClCompile Include="hack\cheats\hooks\renderSmokeOverlay.cpp" />
    <ClCompile Include="hack\cheats\hooks\tracerDraw.cpp" />
    <ClCompile Include="hack\cheats\hooks\updatePostEffects.cpp" />
    <ClCompile Include="hack\cheats\hooks\overrideMouse.cpp" />
    <ClCompile Include="hack\cheats\hooks\overrideView.cpp" />
    <ClCompile Include="hack\cheats\hooks\paintTraverse.cpp" />
    <ClCompile Include="hack\cheats\hooks\particlesSimulation.cpp" />
    <ClCompile Include="hack\cheats\hooks\playStepSound.cpp" />
    <ClCompile Include="hack\cheats\hooks\present.cpp" />
    <ClCompile Include="hack\cheats\hooks\processSpottedEntityUpdate.cpp" />
    <ClCompile Include="hack\cheats\hooks\removeEntity.cpp" />
    <ClCompile Include="hack\cheats\hooks\reset.cpp" />
    <ClCompile Include="hack\cheats\hooks\screen2deffect.cpp" />
    <ClCompile Include="hack\cheats\hooks\sendDatagram.cpp" />
    <ClCompile Include="hack\cheats\hooks\svcheats.cpp" />
    <ClCompile Include="hack\cheats\hooks\unknownFIleSys.cpp" />
    <ClCompile Include="hack\cheats\hooks\unknownOverviewMap.cpp" />
    <ClCompile Include="hack\cheats\hooks\unknownPlayerHurt.cpp" />
    <ClCompile Include="hack\cheats\hooks\unkownRoundEnd.cpp" />
    <ClCompile Include="hack\cheats\hooks\drawEffects.cpp" />
    <ClCompile Include="hack\cheats\hooks\vCollideLoad.cpp" />
    <ClCompile Include="hack\cheats\hooks\viewFade.cpp" />
    <ClCompile Include="hack\cheats\hooks\viewRender.cpp" />
    <ClCompile Include="hack\cheats\hooks\wndproc.cpp" />
    <ClCompile Include="hack\cheats\features\prediction\prediction.cpp" />
    <ClCompile Include="hack\cheats\features\combat\RCS\RCS.cpp" />
    <ClCompile Include="hack\cheats\features\combat\triggerbot\triggerbot.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\chams\chams.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\chams\editor.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\glow\glow.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\hitmarker\hitmark.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\list\playerlist.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\mirrorcam\mirrorCam.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\crosshair.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\drawinfo.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\motionblur.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\screenEffects.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\misc\trails.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\player\boxes.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\player\enemyWarn.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\player\player.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\player\sounds.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\plots\plots.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\radar\radar.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\tracer\tracer.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\ambient.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\bomb.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\dropped.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\fog.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\impacts.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\modulateColors.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\molotov.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\nadepred.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\nadewarn.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\projectiles.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\removeSky.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\skybox.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\smoke.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\tone.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\weather\precipitation.cpp" />
    <ClCompile Include="hack\cheats\features\visuals\world\zeus.cpp" />
    <ClCompile Include="hack\cheats\features\combat\aimbot\aimbot.cpp" />
    <ClCompile Include="hack\cheats\features\combat\aimbot\aimbotDraw.cpp" />
    <ClCompile Include="hack\cheats\features\backtrack\backteack.cpp" />
    <ClCompile Include="hack\cheats\features\blacklist\blacklist.cpp" />
    <ClCompile Include="hack\cheats\features\cache\cache.cpp" />
    <ClCompile Include="hack\cheats\features\callbacks\callbacks.cpp" />
    <ClCompile Include="hack\cheats\features\events\events.cpp" />
    <ClCompile Include="hack\cheats\features\fakelatency\fakelatency.cpp" />
    <ClCompile Include="hack\cheats\features\logger\logger.cpp" />
    <ClCompile Include="hack\cheats\features\misc\cameras\freeCam.cpp" />
    <ClCompile Include="hack\cheats\features\misc\disable\interpolate.cpp" />
    <ClCompile Include="hack\cheats\features\misc\flashlight\flashlight.cpp" />
    <ClCompile Include="hack\cheats\features\misc\movement\movement.cpp" />
    <ClCompile Include="hack\cheats\features\misc\thirdperson\thirdperson.cpp" />
    <ClCompile Include="hack\cheats\features\particle\particle.cpp" />
    <ClCompile Include="hack\deps\ImGui\editor\LanguageDefinitions.cpp" />
    <ClCompile Include="hack\gamememory\address.cpp" />
    <ClCompile Include="hack\gamememory\system\win.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\sections\combat\aim.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\sections\editors\chamsEditor.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\sections\editors\editors.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\sections\editors\styleEditor.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\sections\misc\misc.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\sections\settings\settings.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\sections\visuals\visuals.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\styles\styles.cpp" />
    <ClCompile Include="hack\render\backend\backend.cpp" />
    <ClCompile Include="hack\SDK\CGlowManager.cpp" />
    <ClCompile Include="hack\SDK\CNewParticleEffect.cpp" />
    <ClCompile Include="hack\SDK\IMatRenderContext.cpp" />
    <ClCompile Include="hack\SDK\material.cpp" />
    <ClCompile Include="hack\utilities\tools\tools.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="hack\config\cfgcolor.cpp" />
    <ClCompile Include="hack\config\cfgWeapon.cpp" />
    <ClCompile Include="hack\config\config.cpp" />
    <ClCompile Include="hack\config\jsonExtended.cpp" />
    <ClCompile Include="hack\config\key.cpp" />
    <ClCompile Include="hack\deps\ImGui\extraDraw.cpp" />
    <ClCompile Include="hack\deps\ImGui\editor\TextEditor.cpp" />
    <ClCompile Include="hack\gamememory\memory.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\sections\background.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\imguiaddons.cpp" />
    <ClCompile Include="hack\menu\GUI-ImGui\menu.cpp" />
    <ClCompile Include="hack\menu\x88Menu\x88menu.cpp" />
    <ClCompile Include="hack\render\BBox.cpp" />
    <ClCompile Include="hack\render\Color.cpp" />
    <ClCompile Include="hack\render\render.cpp" />
    <ClCompile Include="hack\render\structures.cpp" />
    <ClCompile Include="hack\SDK\checksum_crc.cpp" />
    <ClCompile Include="hack\SDK\CPredictionCopy.cpp" />
    <ClCompile Include="hack\SDK\helpers\netvars.cpp" />
    <ClCompile Include="hack\SDK\interfaces\interfaces.cpp" />
    <ClCompile Include="hack\SDK\IPrediction.cpp" />
    <ClCompile Include="hack\SDK\KeyValues.cpp" />
    <ClCompile Include="hack\SDK\structs\Entity.cpp" />
    <ClCompile Include="hack\setup\setup.cpp" />
    <ClCompile Include="hack\utilities\console\console.cpp" />
    <ClCompile Include="hack\utilities\console\consoleDraw.cpp" />
    <ClCompile Include="hack\utilities\inputSystem.cpp" />
    <ClCompile Include="hack\utilities\math\math.cpp" />
    <ClCompile Include="hack\utilities\res.cpp" />
    <ClCompile Include="hack\utilities\utilities.cpp" />
    <ClCompile Include="source.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">pch.h</PrecompiledHeaderFile>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hack\api.hpp" />
    <ClInclude Include="hack\cheats\features\combat\aimbot\aimbot.hpp" />
    <ClInclude Include="hack\cheats\features\combat\aimbot\aimbotDraw.hpp" />
    <ClInclude Include="hack\cheats\features\combat\aimbot\helper.hpp" />
    <ClInclude Include="hack\cheats\features\backtrack\backtrack.hpp" />
    <ClInclude Include="hack\cheats\features\blacklist\blacklist.hpp" />
    <ClInclude Include="hack\cheats\features\cache\cache.hpp" />
    <ClInclude Include="hack\cheats\features\callbacks\callbacks.hpp" />
    <ClInclude Include="hack\cheats\features\events\events.hpp" />
    <ClInclude Include="hack\cheats\features\fakelatency\fakelatency.hpp" />
    <ClInclude Include="hack\cheats\features\logger\logger.hpp" />
    <ClInclude Include="hack\cheats\features\misc\cameras\freeCam.hpp" />
    <ClInclude Include="hack\cheats\features\misc\disable\convars.hpp" />
    <ClInclude Include="hack\cheats\features\misc\disable\interpolate.hpp" />
    <ClInclude Include="hack\cheats\features\misc\flashlight\flashlight.hpp" />
    <ClInclude Include="hack\cheats\features\misc\movement\movement.hpp" />
    <ClInclude Include="hack\cheats\features\misc\thirdperson\thirdperson.hpp" />
    <ClInclude Include="hack\cheats\features\particle\particle.hpp" />
    <ClInclude Include="hack\cheats\features\prediction\prediction.hpp" />
    <ClInclude Include="hack\cheats\features\combat\RCS\RCS.hpp" />
    <ClInclude Include="hack\cheats\features\combat\triggerbot\triggerbot.hpp" />
    <ClInclude Include="hack\cheats\features\tests\test.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\chams\chams.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\chams\editor.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\chams\factory\factory.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\glow\glow.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\hitmarker\hitmark.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\list\playerlist.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\list\spectactors.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\mirrorcam\mirrorCam.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\bulletUpdater.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\crosshair.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\drawInfo.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\motionblur.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\noscope.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\screenEffects.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\misc\trails.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\player\boxes.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\player\enemyWarn.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\player\player.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\player\sounds.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\plots\plots.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\radar\radar.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\streamproof\streamproof.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\tracer\tracer.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\ambient.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\bomb.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\dropped.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\fog.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\impacts.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\lights.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\modulateColors.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\molotov.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\nadepred.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\nadewarn.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\projectiles.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\removeSky.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\skybox.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\smoke.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\tone.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\weather\ground.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\weather\helper.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\weather\_menu.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\weather\precipitation.hpp" />
    <ClInclude Include="hack\cheats\features\visuals\world\zeus.hpp" />
    <ClInclude Include="hack\cheats\game\game.hpp" />
    <ClInclude Include="hack\cheats\game\globals.hpp" />
    <ClInclude Include="hack\cheats\helper\initable.hpp" />
    <ClInclude Include="hack\cheats\helper\shutdownable.hpp" />
    <ClInclude Include="hack\cheats\hooks\addEntity.hpp" />
    <ClInclude Include="hack\cheats\hooks\allocKeyvalues.hpp" />
    <ClInclude Include="hack\cheats\hooks\buildTransformations.hpp" />
    <ClInclude Include="hack\cheats\hooks\decalAddToSurface.hpp" />
    <ClInclude Include="hack\cheats\hooks\decalCreate.hpp" />
    <ClInclude Include="hack\cheats\hooks\dispatchInnerParticlePrecip.hpp" />
    <ClInclude Include="hack\cheats\hooks\drawTranslucentRenderables.hpp" />
    <ClInclude Include="hack\cheats\hooks\drawWorldAndEntities.hpp" />
    <ClInclude Include="hack\cheats\hooks\clientModeCSNormalEvent.hpp" />
    <ClInclude Include="hack\cheats\hooks\getPhysicsProperties.hpp" />
    <ClInclude Include="hack\cheats\hooks\getVCollide.hpp" />
    <ClInclude Include="hack\cheats\hooks\createParticlePrecip.hpp" />
    <ClInclude Include="hack\cheats\hooks\getVelocity.hpp" />
    <ClInclude Include="hack\cheats\hooks\initializeParticlePrecip.hpp" />
    <ClInclude Include="hack\cheats\hooks\drawEffects.hpp" />
    <ClInclude Include="hack\cheats\hooks\mapLoaderInit.hpp" />
    <ClInclude Include="hack\cheats\hooks\newParticleEffectSetControlPoint.hpp" />
    <ClInclude Include="hack\cheats\hooks\overrideConfig.hpp" />
    <ClInclude Include="hack\cheats\hooks\tracerDraw.hpp" />
    <ClInclude Include="hack\cheats\hooks\vCollideLoad.hpp" />
    <ClInclude Include="hack\deps\mem\aligned_alloc.h" />
    <ClInclude Include="hack\deps\mem\arch.h" />
    <ClInclude Include="hack\deps\mem\bitwise_enum.h" />
    <ClInclude Include="hack\deps\mem\boyer_moore_scanner.h" />
    <ClInclude Include="hack\deps\mem\char_queue.h" />
    <ClInclude Include="hack\deps\mem\cmd_param-inl.h" />
    <ClInclude Include="hack\deps\mem\cmd_param.h" />
    <ClInclude Include="hack\deps\mem\data_buffer.h" />
    <ClInclude Include="hack\deps\mem\defines.h" />
    <ClInclude Include="hack\deps\mem\execution_handler.h" />
    <ClInclude Include="hack\deps\mem\hasher.h" />
    <ClInclude Include="hack\deps\mem\init_function.h" />
    <ClInclude Include="hack\deps\mem\macros.h" />
    <ClInclude Include="hack\deps\mem\mem.h" />
    <ClInclude Include="hack\deps\mem\module.h" />
    <ClInclude Include="hack\deps\mem\pattern.h" />
    <ClInclude Include="hack\deps\mem\pattern_cache.h" />
    <ClInclude Include="hack\deps\mem\protect.h" />
    <ClInclude Include="hack\deps\mem\prot_flags.h" />
    <ClInclude Include="hack\deps\mem\rtti.h" />
    <ClInclude Include="hack\deps\mem\simd_scanner.h" />
    <ClInclude Include="hack\deps\mem\slice.h" />
    <ClInclude Include="hack\deps\mem\stub.h" />
    <ClInclude Include="hack\deps\mem\utils.h" />
    <ClInclude Include="hack\gamememory\system\win.hpp" />
    <ClInclude Include="hack\SDK\CCommonHostState.hpp" />
    <ClInclude Include="hack\cheats\hooks\cHudIsHidden.hpp" />
    <ClInclude Include="hack\cheats\hooks\createEvent.hpp" />
    <ClInclude Include="hack\cheats\hooks\createMove.hpp" />
    <ClInclude Include="hack\cheats\hooks\doExtraBonesProcessing.hpp" />
    <ClInclude Include="hack\cheats\hooks\doPostScreenEffects.hpp" />
    <ClInclude Include="hack\cheats\hooks\drawIndexPrimitive.hpp" />
    <ClInclude Include="hack\cheats\hooks\drawModelExecute.hpp" />
    <ClInclude Include="hack\cheats\hooks\drawSetColor.hpp" />
    <ClInclude Include="hack\cheats\hooks\filesCheck.hpp" />
    <ClInclude Include="hack\cheats\hooks\findMaterial.hpp" />
    <ClInclude Include="hack\cheats\hooks\frameStageNotify.hpp" />
    <ClInclude Include="hack\cheats\hooks\getColorModulation.hpp" />
    <ClInclude Include="hack\cheats\hooks\getPMaterial.hpp" />
    <ClInclude Include="hack\cheats\hooks\getUnverifiedFileHashes.hpp" />
    <ClInclude Include="hack\cheats\hooks\helpers\common.hpp" />
    <ClInclude Include="hack\cheats\hooks\helpers\helper.hpp" />
    <ClInclude Include="hack\cheats\hooks\renderSmokeOverlay.hpp" />
    <ClInclude Include="hack\cheats\hooks\updatePostEffects.hpp" />
    <ClInclude Include="hack\cheats\hooks\svcheats.hpp" />
    <ClInclude Include="hack\config\cfgBox.hpp" />
    <ClInclude Include="hack\config\cfgCham.hpp" />
    <ClInclude Include="hack\gamememory\address.hpp" />
    <ClInclude Include="hack\gamememory\modules.hpp" />
    <ClInclude Include="hack\SDK\CNewParticleEffect.hpp" />
    <ClInclude Include="hack\SDK\CutlBuffer.hpp" />
    <ClInclude Include="hack\SDK\CUtlMemory.hpp" />
    <ClInclude Include="hack\SDK\IEngineSound.hpp" />
    <ClInclude Include="hack\SDK\IMaterialInternal.hpp" />
    <ClInclude Include="hack\SDK\INetworkStringTableContainer.hpp" />
    <ClInclude Include="hack\SDK\IPhysicsCollision.hpp" />
    <ClInclude Include="hack\SDK\IPhysicsObject.hpp" />
    <ClInclude Include="hack\SDK\IPhysicsSurfaceProps.hpp" />
    <ClInclude Include="hack\SDK\lightdesc.hpp" />
    <ClInclude Include="hack\SDK\structs\indexes.hpp" />
    <ClInclude Include="hack\utilities\cStr.hpp" />
    <ClInclude Include="hack\utilities\runnable.hpp" />
    <ClInclude Include="hack\cheats\hooks\hooks.hpp" />
    <ClInclude Include="hack\cheats\hooks\isDepth.hpp" />
    <ClInclude Include="hack\cheats\hooks\isFollowingEntity.hpp" />
    <ClInclude Include="hack\cheats\hooks\isHltv.hpp" />
    <ClInclude Include="hack\cheats\hooks\isUsingStaticPropDebugModes.hpp" />
    <ClInclude Include="hack\cheats\hooks\levelInitPostEnttity.hpp" />
    <ClInclude Include="hack\cheats\hooks\levelInitPreEntity.hpp" />
    <ClInclude Include="hack\cheats\hooks\levelShutdown.hpp" />
    <ClInclude Include="hack\cheats\hooks\lockCursor.hpp" />
    <ClInclude Include="hack\cheats\hooks\overrideMouse.hpp" />
    <ClInclude Include="hack\cheats\hooks\overrideView.hpp" />
    <ClInclude Include="hack\cheats\hooks\paintTraverse.hpp" />
    <ClInclude Include="hack\cheats\hooks\particlesSimulation.hpp" />
    <ClInclude Include="hack\cheats\hooks\playStepSound.hpp" />
    <ClInclude Include="hack\cheats\hooks\present.hpp" />
    <ClInclude Include="hack\cheats\hooks\processSpottedEntityUpdate.hpp" />
    <ClInclude Include="hack\cheats\hooks\removeEntity.hpp" />
    <ClInclude Include="hack\cheats\hooks\reset.hpp" />
    <ClInclude Include="hack\cheats\hooks\screen2dEffect.hpp" />
    <ClInclude Include="hack\cheats\hooks\sendDatagram.hpp" />
    <ClInclude Include="hack\cheats\hooks\unknownFileSys.hpp" />
    <ClInclude Include="hack\cheats\hooks\unknownOverviewMap.hpp" />
    <ClInclude Include="hack\cheats\hooks\unknownPlayerHurt.hpp" />
    <ClInclude Include="hack\cheats\hooks\unkownRoundEnd.hpp" />
    <ClInclude Include="hack\cheats\hooks\viewFade.hpp" />
    <ClInclude Include="hack\cheats\hooks\viewRender.hpp" />
    <ClInclude Include="hack\cheats\hooks\wndproc.hpp" />
    <ClInclude Include="hack\config\cfgBeam.hpp" />
    <ClInclude Include="hack\config\cfgcolor.hpp" />
    <ClInclude Include="hack\config\cfgWeapon.hpp" />
    <ClInclude Include="hack\config\config.hpp" />
    <ClInclude Include="hack\config\enums.hpp" />
    <ClInclude Include="hack\config\jsonExtended.hpp" />
    <ClInclude Include="hack\config\key.hpp" />
    <ClInclude Include="hack\config\vars.hpp" />
    <ClInclude Include="hack\deps\ImGui\extraDraw.hpp" />
    <ClInclude Include="hack\deps\ImGui\editor\TextEditor.hpp" />
    <ClInclude Include="hack\deps\ImGui\imgui_markdown.h" />
    <ClInclude Include="hack\deps\magic_enum\prettyNames.hpp" />
    <ClInclude Include="hack\deps\delaunator-cpp\delaunator.hpp" />
    <ClInclude Include="hack\gamememory\memory.hpp" />
    <ClInclude Include="hack\gamememory\sigs.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\sections\background.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\imguiaddons.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\menu.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\sections\combat\aim.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\sections\common.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\sections\editors\chamsEditor.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\sections\editors\editors.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\sections\misc\misc.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\sections\settings\settings.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\sections\visuals\visuals.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\selections.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\styles\styles.hpp" />
    <ClInclude Include="hack\menu\GUI-ImGui\tabrender.hpp" />
    <ClInclude Include="hack\menu\x88Menu\x88menu.hpp" />
    <ClInclude Include="hack\menu\x88Menu\x88types.hpp" />
    <ClInclude Include="hack\render\backend\backend.hpp" />
    <ClInclude Include="hack\render\BBox.hpp" />
    <ClInclude Include="hack\render\Color.hpp" />
    <ClInclude Include="hack\render\fonts\fontawesome.hpp" />
    <ClInclude Include="hack\render\fonts\icon.hpp" />
    <ClInclude Include="hack\render\render.hpp" />
    <ClInclude Include="hack\render\structures.hpp" />
    <ClInclude Include="hack\SDK\animations.hpp" />
    <ClInclude Include="hack\SDK\CClientEffectRegistration.hpp" />
    <ClInclude Include="hack\SDK\CCSGO_HudRadar.hpp" />
    <ClInclude Include="hack\SDK\CEffectData.hpp" />
    <ClInclude Include="hack\SDK\CFlashlightEffect.hpp" />
    <ClInclude Include="hack\SDK\CGameMovement.hpp" />
    <ClInclude Include="hack\SDK\CGameRules.hpp" />
    <ClInclude Include="hack\SDK\CGlobalVars.hpp" />
    <ClInclude Include="hack\SDK\CGlowManager.hpp" />
    <ClInclude Include="hack\SDK\checksum_crc.hpp" />
    <ClInclude Include="hack\SDK\CHudChat.hpp" />
    <ClInclude Include="hack\SDK\ClientClass.hpp" />
    <ClInclude Include="hack\SDK\clientHitVerify.hpp" />
    <ClInclude Include="hack\SDK\ClientMode.hpp" />
    <ClInclude Include="hack\SDK\ConVar.hpp" />
    <ClInclude Include="hack\SDK\CParticelCollection.hpp" />
    <ClInclude Include="hack\SDK\CPlayerResource.hpp" />
    <ClInclude Include="hack\SDK\CPredictionCopy.hpp" />
    <ClInclude Include="hack\SDK\CStudioHdr.hpp" />
    <ClInclude Include="hack\SDK\CTeslaInfo.hpp" />
    <ClInclude Include="hack\SDK\CUserCmd.hpp" />
    <ClInclude Include="hack\SDK\CUtlReference.hpp" />
    <ClInclude Include="hack\SDK\CUtlString.hpp" />
    <ClInclude Include="hack\SDK\CUtlVector.hpp" />
    <ClInclude Include="hack\SDK\CViewSetup.hpp" />
    <ClInclude Include="hack\SDK\datamap.hpp" />
    <ClInclude Include="hack\SDK\EHandle.hpp" />
    <ClInclude Include="hack\SDK\Enums.hpp" />
    <ClInclude Include="hack\SDK\helpers\netvars.hpp" />
    <ClInclude Include="hack\SDK\helpers\pad.hpp" />
    <ClInclude Include="hack\SDK\helpers\vfunc.hpp" />
    <ClInclude Include="hack\SDK\IBaseClientDll.hpp" />
    <ClInclude Include="hack\SDK\IBaseFileSystem.hpp" />
    <ClInclude Include="hack\SDK\IClientEntityList.hpp" />
    <ClInclude Include="hack\SDK\IClientState.hpp" />
    <ClInclude Include="hack\SDK\ICollideable.hpp" />
    <ClInclude Include="hack\SDK\ICvar.hpp" />
    <ClInclude Include="hack\SDK\IEffects.hpp" />
    <ClInclude Include="hack\SDK\IEngineTrace.hpp" />
    <ClInclude Include="hack\SDK\IGameEvent.hpp" />
    <ClInclude Include="hack\SDK\ILocalize.hpp" />
    <ClInclude Include="hack\SDK\IMaterialSystem.hpp" />
    <ClInclude Include="hack\SDK\IMatRenderContext.hpp" />
    <ClInclude Include="hack\SDK\IMDLCache.hpp" />
    <ClInclude Include="hack\SDK\IMemAlloc.hpp" />
    <ClInclude Include="hack\SDK\Input.hpp" />
    <ClInclude Include="hack\SDK\InputSystem.hpp" />
    <ClInclude Include="hack\SDK\interfaceNode.hpp" />
    <ClInclude Include="hack\SDK\interfaces\ifc.hpp" />
    <ClInclude Include="hack\SDK\interfaces\interfaces.hpp" />
    <ClInclude Include="hack\SDK\IPanel.hpp" />
    <ClInclude Include="hack\SDK\IPrediction.hpp" />
    <ClInclude Include="hack\SDK\ISurface.hpp" />
    <ClInclude Include="hack\SDK\ITexture.hpp" />
    <ClInclude Include="hack\SDK\IVDebugOverlay.hpp" />
    <ClInclude Include="hack\SDK\IVEffects.hpp" />
    <ClInclude Include="hack\SDK\IVEngineClient.hpp" />
    <ClInclude Include="hack\SDK\IViewRender.hpp" />
    <ClInclude Include="hack\SDK\IViewRenderBeams.hpp" />
    <ClInclude Include="hack\SDK\IVModelInfo.hpp" />
    <ClInclude Include="hack\SDK\IVModelRender.hpp" />
    <ClInclude Include="hack\SDK\IVRenderView.hpp" />
    <ClInclude Include="hack\SDK\IVStudioRender.hpp" />
    <ClInclude Include="hack\SDK\IWeapon.hpp" />
    <ClInclude Include="hack\SDK\KeyValues.hpp" />
    <ClInclude Include="hack\SDK\KeyValuesSys.hpp" />
    <ClInclude Include="hack\SDK\MapStruct.hpp" />
    <ClInclude Include="hack\SDK\material.hpp" />
    <ClInclude Include="hack\SDK\materialInit.hpp" />
    <ClInclude Include="hack\SDK\math\AABB.hpp" />
    <ClInclude Include="hack\SDK\math\matrix.hpp" />
    <ClInclude Include="hack\SDK\math\Rect.hpp" />
    <ClInclude Include="hack\SDK\math\Vector.hpp" />
    <ClInclude Include="hack\SDK\math\VectorAligned.hpp" />
    <ClInclude Include="hack\SDK\PixEvent.hpp" />
    <ClInclude Include="hack\SDK\Recv.hpp" />
    <ClInclude Include="hack\SDK\stencil.hpp" />
    <ClInclude Include="hack\SDK\structs\Entity.hpp" />
    <ClInclude Include="hack\SDK\varMapping.hpp" />
    <ClInclude Include="hack\SDK\vars.hpp" />
    <ClInclude Include="hack\setup\setup.hpp" />
    <ClInclude Include="hack\utilities\console\console.hpp" />
    <ClInclude Include="hack\utilities\console\consoleDraw.hpp" />
    <ClInclude Include="hack\utilities\console\consoleUtils.hpp" />
    <ClInclude Include="hack\utilities\inputSystem.hpp" />
    <ClInclude Include="hack\utilities\math\math.hpp" />
    <ClInclude Include="hack\utilities\rand.hpp" />
    <ClInclude Include="hack\utilities\res.hpp" />
    <ClInclude Include="hack\utilities\simpleTimer.hpp" />
    <ClInclude Include="hack\utilities\tools\tools.hpp" />
    <ClInclude Include="hack\utilities\tools\wrappers.hpp" />
    <ClInclude Include="hack\utilities\utilities.hpp" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="dependencies\interfaces\ienginetrace.hpp" />
    <ClInclude Include="hack\resources\resource.h" />
    <ClInclude Include="utilities\csgo.hpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="hack\deps\mem\cpp.hint" />
    <None Include="hack\deps\missing\bluelight1.vmt" />
    <None Include="hack\deps\missing\bluelight1.vtf" />
    <None Include="hack\deps\missing\bluelightning.vmt" />
    <None Include="hack\deps\missing\bluelightning.vtf" />
    <None Include="hack\deps\missing\lgtning.vmt" />
    <None Include="hack\deps\missing\lgtning.vtf" />
    <None Include="hack\deps\missing\physcannon_bluelight1.vmt" />
    <None Include="hack\deps\missing\physcannon_bluelight1.vtf" />
    <None Include="hack\deps\missing\physcannon_bluelight1b.vmt" />
    <None Include="hack\deps\missing\physcannon_bluelight1b.vtf" />
    <None Include="hack\deps\missing\snowflake.vmt" />
    <None Include="hack\deps\missing\snowflake.vtf" />
    <None Include="hack\deps\README.md" />
    <None Include="hack\menu\GUI-ImGui\sections\editors\styleEditor.hpp" />
    <None Include="hack\resources\csgo-legit.aps" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="hack\deps\images\fatchad.png" />
    <Image Include="pictures\editor.png" />
    <Image Include="pictures\fixedBlurryGlowLine.png" />
    <Image Include="pictures\fixed_glow.png" />
    <Image Include="pictures\molotov.png" />
    <Image Include="pictures\nade1.png" />
    <Image Include="pictures\nade2.png" />
    <Image Include="pictures\obsProofGameMaterials.png" />
    <Image Include="pictures\plots.png" />
    <Image Include="pictures\radar.png" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="hack\resources\csgo-legit.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCPKG_INSTALLATION_ROOT)\scripts\buildsystems\msbuild\vcpkg.targets" Condition="'$(VCPKG_INSTALLATION_ROOT)' != ''" />
  </ImportGroup>
</Project>
```

`hack/SDK/CCSGO_HudRadar.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "helpers/pad.hpp"

// client.dll 55 8B EC 83 E4 F8 83 EC 60 A1 ? ? ? ? 56 57 | client.dll 55 8B EC 83 EC 18 8B 45 08 53 56 57
// call in ProcessSpottedEntityUpdate as game originally do
// this is why the fields might give not always pure 1:1 results to frequently updated player related fields
struct RadarEntity
{
	Vec3 m_origin;
	Vec3 m_viewAngles;
	PAD(28);
	float m_spottedTime;
	PAD(16);
	int m_index;
	PAD(4);
	int m_health;
	char m_name[32];
	PAD(117);
	bool m_visible;
	PAD(138);
	/*void write() const
	{
		printf("origin iszero? %i index %i health %i name %s visible %i\n", m_origin.isZero(), m_index, m_health, m_name, m_visible);
	}*/
};
static_assert(sizeof(RadarEntity) == 372);

struct CSRadar
{
	PAD(332);
	RadarEntity m_players[65];
};

struct CCSGO_HudRadar
{
	PAD(12);
	int m_maybeSizeOfImageRadar;
	PAD(512);
	int m_sizeOfPlayers;
};
```

`hack/SDK/CClientEffectRegistration.hpp`:

```hpp
#pragma once

#include "CEffectData.hpp"

using clientEffectCallback = std::add_pointer_t<void __cdecl(const CEffectData& data)>;

struct CClientEffectRegistration
{
	CClientEffectRegistration() = default;
	CClientEffectRegistration(const char* effectName, clientEffectCallback fn)
		: m_effectName{ effectName }, m_function{ fn }
	{}
	const char* m_effectName;
	clientEffectCallback m_function;
	CClientEffectRegistration* m_next;
};
```

`hack/SDK/CCommonHostState.hpp`:

```hpp
#pragma once

#include "IVModelRender.hpp"
#include "helpers/pad.hpp"
#include <SDK/CUtlVector.hpp>
#include <render/Color.hpp>

#include <gamememory/memory.hpp>

struct decal_t
{
	decal_t* pnext;				// linked list for each surface
	decal_t* pDestroyList;
	void* surfID;		// Surface id for persistence / unlinking
	IMaterial* material;
	float				lightmapOffset;

	// FIXME:
	// make dx and dy in decal space and get rid of position, so that
	// position can be rederived from the decal basis.
	Vec3		position;		// location of the decal center in world space.
	Vec3		saxis;			// direction of the s axis in world space
	float		dx;				// Offsets into surface texture (in texture coordinates, so we don't need floats)
	float		dy;
	float		scale;			// Pixel scale
	float		flSize;			// size of decal, used for rejecting on dispinfo planes
	float		fadeDuration;				// Negative value means to fade in
	float		fadeStartTime;
	SDKColor		color;
	void* userdata;		// For player decals only, decal index ( first player at slot 1 )
	uint16_t	m_DispDecal;	// Handle to displacement decals associated with this
	unsigned short		clippedVertCount;
	unsigned short		cacheHandle;
	unsigned short		m_iDecalPool;		// index into the decal pool.
	short		flags;			// Decal flags  DECAL_*		!!!SAVED AS A BYTE (SEE HOST_CMD.C)
	short		entityIndex;	// Entity this is attached to
	int			m_nTickCreated; // tick on which the decal was created

	// NOTE: The following variables are dynamic variables.
	// We could put these into a separate array and reference them
	// by index to reduce memory costs of this...

	int			m_iSortTree;			// MaterialSort tree id
	int			m_iSortMaterial;		// MaterialSort id.
};
static_assert(sizeof(decal_t) == 100U);

struct msurface2_t;
typedef msurface2_t* SurfaceHandle_t;
struct worldbrushdata_t;

struct msurface2_t
{
	unsigned int			flags;			// see SURFDRAW_ #defines (only 22-bits right now)
	// These are packed in to flags now
	//unsigned char			vertCount;		// number of verts for this surface
	//unsigned char			sortGroup;		// only uses 2 bits, subdivide?
#ifdef _PS3
	cplane_t				m_plane;			// pointer to shared plane
#else
	void* plane;			// pointer to shared plane
#endif
	int						firstvertindex;	// look up in model->vertindices[] (only uses 17-18 bits?)
	unsigned short		decals;
	unsigned short		m_ShadowDecals; // unsigned short
	unsigned short m_nFirstOverlayFragment;	// First overlay fragment on the surface (short)
	short					materialSortID;
	unsigned short			vertBufferIndex;

	unsigned short			m_bDynamicShadowsEnabled : 1;	// Can this surface receive dynamic shadows?
	unsigned short			texinfo : 15;

	void* pDispInfo;         // displacement map information
	int						visframe;		// should be drawn when node is crossed
};

// This structure contains the information used to create new decals
struct decalinfo_t
{
	Vec3		m_Position;			// world coordinates of the decal center
	Vec3		m_SAxis;			// the s axis for the decal in world coordinates
	model_t *m_pModel;			// the model the decal is going to be applied in
	worldbrushdata_t* m_pBrush;		// The shared brush data for this model
	IMaterial* m_pMaterial;		// The decal material
	float		m_Size;				// Size of the decal (in world coords)
	int			m_Flags;
	int			m_Entity;			// Entity the decal is applied to.
	float		m_scale;
	float		m_flFadeDuration;
	float		m_flFadeStartTime;
	int			m_decalWidth;
	int			m_decalHeight;
	SDKColor		m_Color;
	Vec3		m_Basis[3];
	void* m_pUserData;
	const Vec3* m_pNormal;
	CUtlVector<SurfaceHandle_t>	m_aApplySurfs;
};

enum emittype_t
{
	emit_surface,		// 90 degree spotlight
	emit_point,			// simple point light source
	emit_spotlight,		// spotlight with penumbra
	emit_skylight,		// directional light with no falloff (surface must trace to SKY texture)
	emit_quakelight,	// linear falloff, non-lambertian
	emit_skyambient,	// spherical light source with no falloff (surface must trace to SKY texture)
};

struct dworldlight_t
{
	//DECLARE_BYTESWAP_DATADESC();
	Vec3		origin;
	Vec3		intensity;
	Vec3		normal;			// for surfaces and spotlights
	Vec3		shadow_cast_offset;
	int			cluster;
	emittype_t	type;
	int			style;
	float		stopdot;		// start of penumbra for emit_spotlight
	float		stopdot2;		// end of penumbra for emit_spotlight
	float		exponent;		// 
	float		radius;			// cutoff distance
	// falloff for emit_spotlight + emit_point: 
	// 1 / (constant_attn + linear_attn * dist + quadratic_attn * dist^2)
	float		constant_attn;
	float		linear_attn;
	float		quadratic_attn;
	int			flags;			// Uses a combination of the DWL_FLAGS_ defines.
	int			texinfo;		// 
	int			owner;			// entity that this light it relative to
};
static_assert(sizeof(dworldlight_t) == 100U);

struct mtexinfo_t
{
	Vec4	textureVecsTexelsPerWorldUnits[2];	// [s/t] unit vectors in world space. 
	// [i][3] is the s/t offset relative to the origin.
	Vec4	lightmapVecsLuxelsPerWorldUnits[2];
	float		luxelsPerWorldUnit;
	float		worldUnitsPerLuxel;
	unsigned short flags;		// SURF_ flags.
	unsigned short texinfoFlags;// TEXINFO_ flags.
	IMaterial* material;

	mtexinfo_t(mtexinfo_t const& src)
	{
		// copy constructor needed since Vector4D has no copy constructor
		memcpy(this, &src, sizeof(mtexinfo_t));
	}
};


struct worldbrushdata_t
{
	PAD(92);
	int numtexinfo;
	mtexinfo_t* textinfo;
	PAD(16);
	int numsurfaces;
	struct msurface1_t* surfaces1;
	msurface2_t* surfaces2;
	PAD(40);
	int			numworldlights;
	dworldlight_t* worldlights;
	////...
};

class CCommonHostState
{
public:
	// worlsmodel doesn't exist here, due to CModelLoader
	//// cl_entitites[0].model
	//Model_t* worldmodel;
	worldbrushdata_t worldbrush;
	// Tick interval for game
	float interval_per_tick;
};

inline SurfaceHandle_t SurfaceHandleFromIndex(int surfaceIndex, worldbrushdata_t* pData)
{
	return &pData->surfaces2[surfaceIndex];
}

inline unsigned short& MSurf_Decals(SurfaceHandle_t surfID)
{
	return surfID->decals;
}

static inline decal_t* MSurf_DecalPointer(SurfaceHandle_t surfID)
{
	unsigned short handle = MSurf_Decals(surfID);
	constexpr int WORLD_DECAL_HANDLE_INVALID = 0xFFFF;
	if (handle == WORLD_DECAL_HANDLE_INVALID)
		return NULL;

	return memory::decalPool()[handle];
}

```

`hack/SDK/CEffectData.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

class CEffectData
{
public:
	Vec3 m_origin;
	Vec3 m_start;
	Vec3 m_normal;
	Vec3 m_angles;
	int m_flags;
	int m_entityIdx;
	float m_scale;
	float m_magnitude;
	float m_radius;
	int m_attachmentIndex;
	short m_surfaceProp;
	// Some TF2 specific things
	int m_material;
	int m_damageType;
	int m_hitBox;
	int m_otherEntIndex;
	unsigned char m_color;
	int getEffectNameIndex() { return m_iEffectName; }
private:
	int m_iEffectName;	// Entry in the EffectDispatch network string table. The is automatically handled by DispatchEffect().
};
```

`hack/SDK/CFlashlightEffect.hpp`:

```hpp
#pragma once

#include <cstdint>

class CFlashlightEffect
{
public:
	bool m_isOn;
private:
	char someweirdbuf[3]; // could be bools
public:
	int m_entIndex;
	uint16_t m_flashlightHandle;
	bool m_bigMode; // dunno how to name it
	bool m_muzzleFlashEnabled;
	float m_muzzleFlashBrightness;
	float m_fov;
	float m_farZ;
	float m_LinearAtten;
	bool m_castsShadows;
private:
	char someweirdbuf2[3]; // could be bools
public:
	float m_currentPullBackDist;
	uint32_t m_muzzleFlashTexture;
	uint32_t m_flashLightTexture;
	char m_textureName[64];
};
```

`hack/SDK/CGameMovement.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class Player_t;
class CMoveData;

class CGameMovement
{
public:
	VFUNC(void, processMovement, 1, (Player_t* local, CMoveData* moveData), (this, local, moveData));
	VFUNC(void, reset, 2, (), (this));
	VFUNC(void, startTrackPredictionErrors, 3, (Player_t* local), (this, local));
	VFUNC(void, finishTrackPredictionErrors, 4, (Player_t* local), (this, local));
	VFUNC(void, decayAimPunchAngle, 77, (), (this));
};
```

`hack/SDK/CGameRules.hpp`:

```hpp
#pragma once

#include "helpers/netvars.hpp"
#include "helpers/vfunc.hpp"
#include "math/Vector.hpp"

// Each mod defines these for itself.
class CViewVectors
{
public:
	CViewVectors() {}

	CViewVectors(
		Vec3 vView,
		Vec3 vHullMin,
		Vec3 vHullMax,
		Vec3 vDuckHullMin,
		Vec3 vDuckHullMax,
		Vec3 vDuckView,
		Vec3 vObsHullMin,
		Vec3 vObsHullMax,
		Vec3 vDeadViewHeight)
	{
		m_vView = vView;
		m_vHullMin = vHullMin;
		m_vHullMax = vHullMax;
		m_vDuckHullMin = vDuckHullMin;
		m_vDuckHullMax = vDuckHullMax;
		m_vDuckView = vDuckView;
		m_vObsHullMin = vObsHullMin;
		m_vObsHullMax = vObsHullMax;
		m_vDeadViewHeight = vDeadViewHeight;
	}

	// Height above entity position where the viewer's eye is.
	Vec3 m_vView;

	Vec3 m_vHullMin;
	Vec3 m_vHullMax;

	Vec3 m_vDuckHullMin;
	Vec3 m_vDuckHullMax;
	Vec3 m_vDuckView;

	Vec3 m_vObsHullMin;
	Vec3 m_vObsHullMax;

	Vec3 m_vDeadViewHeight;
};

class CGameRules
{
public:
	NETVAR(int, m_iRoundTime, "DT_CSGameRulesProxy", "m_iRoundTime");
	NETVAR(Vec3, m_vecPlayAreaMins, "DT_SurvivalGameRules", "m_vecPlayAreaMins");
	NETVAR(Vec3, m_vecPlayAreaMaxs, "DT_SurvivalGameRules", "m_vecPlayAreaMaxs");

	VFUNC(CViewVectors*, getViewVectors, 30, (), (this));
};
```

`hack/SDK/CGlobalVars.hpp`:

```hpp
#pragma once

class CGlobalVarsBase
{
public:
	float m_realtime;
	int m_frameCount;
	float m_absoluteframetime;
	float m_absoluteframestarttimestddev;
	float m_curtime;
	float m_frametime;
	int m_maxClients;
	int m_tickCount;
	float m_intervalPerTick;
	float m_interpolationAmount;
	int m_simTicksThisFrame;
	int m_networkProtocol;
	void* m_saveData;
	bool m_client;
	bool m_remoteClient;
	int m_networkingTimestamp;
	int m_networkingTimestampRandomize;
};
```

`hack/SDK/CGlowManager.cpp`:

```cpp
#include "CGlowManager.hpp"

#include <gamememory/memory.hpp>

void CGlowManager::addGlowBox(const Vec3& origin, const Vec3& angle, const Vec3& min, const Vec3& max, const Color& color, float lifetime)
{
	memory::addGlowBox()(this, origin, angle, min, max, SDKColor{ color }, lifetime);
}
```

`hack/SDK/CGlowManager.hpp`:

```hpp
#pragma once

#include <render/Color.hpp>
#include "helpers/pad.hpp"
#include "math/Vector.hpp"

class CGlowObject_t
{
public:
	void set(const Color& color, bool occluded = true, bool unocculuded = false, bool fullBloom = false, float amount = 1.0f)
	{
		m_color = color;
		m_occluded = occluded;
		m_unoccluded = unocculuded;
		m_fullBloom = fullBloom;
		m_bloomAmount = amount;
	}
	bool unused()
	{
		return m_nextFree != -2;
	}

	int m_nextFree;
	void* m_entity;
	Color m_color;
	PAD(8);
	float m_bloomAmount;
	PAD(4);
	bool m_occluded;
	bool m_unoccluded;
	bool m_fullBloom;
	PAD(13);
};

class CGlowManager
{
public:
	CGlowObject_t* m_objects;
	PAD(8);
	int m_size;
	
	void addGlowBox(const Vec3& origin, const Vec3& angle, const Vec3& min, const Vec3& max, const Color& color, float lifetime);
};
```

`hack/SDK/CHudChat.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"

class CHudChat
{
	PAD(84);
	int m_timesOpened;
	PAD(8);
	bool m_isOpen;
	PAD(1088);
};
```

`hack/SDK/CNewParticleEffect.cpp`:

```cpp
#include "CNewParticleEffect.hpp"

#include <gamememory/memory.hpp>

void CNewParticleEffect::setControlPoint(int whichPoint, const Vec3& v)
{
	memory::newParticleSetControlPoint()(this, whichPoint, std::cref(v));
}

void CNewParticleEffect::setControlPointEntity(int whichPoint, Entity_t* ent)
{
	memory::newParticleSetControlPointEnt()(this, whichPoint, ent);
}

CNewParticleEffect* CNewParticleEffect::create(const char* name, ParticleAttachment_t attachType, int attachPoint, Vec3 vecOriginOffset, Matrix3x4* vecOffsetMatrix)
{
	return memory::newParticleCreate()(name, attachType, attachPoint, vecOriginOffset, vecOffsetMatrix);
}
```

`hack/SDK/CNewParticleEffect.hpp`:

```hpp
#pragma once


#include "math/Vector.hpp"
#include "math/matrix.hpp"
#include "Enums.hpp"

#include "CParticelCollection.hpp"

class Entity_t;

class CNewParticleEffect
{
public:
	CParticleCollection* getParticleCollection() { return reinterpret_cast<CParticleCollection*>(this + 0x10); } // inherit
	 
	void setControlPoint(int whichPoint, const Vec3& v);
	void setControlPointEntity(int whichPoint, Entity_t* ent);
	//void setDrawOnlyForSplitScreenUse(int slot);

	// thisptr passed by stack, some inlined wrapper probs
	static CNewParticleEffect* create(const char* name, ParticleAttachment_t attachType, int attachPoint = -1, Vec3 vecOriginOffset = Vec3{ }, Matrix3x4* vecOffsetMatrix = nullptr);
};
```

`hack/SDK/CParticelCollection.hpp`:

```hpp
#pragma once

#include "CUtlReference.hpp"
#include "CUtlString.hpp"
#include "helpers/pad.hpp"

#include <render/Color.hpp>

#define PARTICLE_ATTRIBUTE_TINT_RGB 6
#define PARTICLE_ATTRIBUTE_ALPHA	7
#define PARTICLE_ATTRIBUTE_ALPHA_2	16

#define MAX_PARTICLE_ATTRIBUTES 24

struct CParticleAttributeAddressTable
{
	float* m_pAttributes[MAX_PARTICLE_ATTRIBUTES];
	size_t m_nFloatStrides[MAX_PARTICLE_ATTRIBUTES];

	float* floatAttribute(int attribute, int particleNum) const
	{
		int blockofs = particleNum / 4;
		return m_pAttributes[attribute] +
			m_nFloatStrides[attribute] * blockofs +
			(particleNum & 3);
	}
	// custom
	void modulateColor(const Color& color, int num)
	{
		/*
		0 : 0.948685
		1 : 0.942262
		2 : 0.898302
		3 : 0.932009
		4 : 0.885635
		5 : 0.878489
		6 : 0.717303
		7 : 0.840896
		8 : 0.670859
		*/

		auto rgb = floatAttribute(PARTICLE_ATTRIBUTE_TINT_RGB, num);
		auto a = floatAttribute(PARTICLE_ATTRIBUTE_ALPHA, num);


		rgb[0] = color.r();
		rgb[4] = color.g();
		rgb[8] = color.b();

		*a = color.a();
	}

	void modulateColorRGB(const Color& color, int num)
	{
		/*
		0 : 0.948685
		1 : 0.942262
		2 : 0.898302
		3 : 0.932009
		4 : 0.885635
		5 : 0.878489
		6 : 0.717303
		7 : 0.840896
		8 : 0.670859
		*/

		auto rgb = floatAttribute(PARTICLE_ATTRIBUTE_TINT_RGB, num);
		auto a = floatAttribute(PARTICLE_ATTRIBUTE_ALPHA, num);


		rgb[0] = color.r();
		rgb[4] = color.g();
		rgb[8] = color.b();
	}

	void modulateAlpha(float alpha, int num)
	{
		auto a = floatAttribute(PARTICLE_ATTRIBUTE_ALPHA, num);
		*a = alpha;
	}
};

class CParticleSystemDefinition
{
	PAD(308);
	CUtlString m_name;
};

class CParticleCollection
{
	PAD(48);
	int m_activeParticles;
	PAD(12);
	CUtlReference<CParticleSystemDefinition> m_def;
	PAD(60);
	CParticleCollection* m_parent;
	PAD(84);
	CParticleAttributeAddressTable m_particleAttributes;
};
```

`hack/SDK/CPlayerResource.hpp`:

```hpp
#pragma once

#include <utility>

#include "helpers/netvars.hpp"

class PlayerResource
{
public:
	int getKills(int id)
	{
		const static auto addr = netvars::getNetvar("DT_PlayerResource", "m_iKills");
		return *reinterpret_cast<int*>(uintptr_t(this) + addr + id * sizeof(int*));
	}
	int getDeaths(int id)
	{
		const static auto addr = netvars::getNetvar("DT_PlayerResource", "m_iDeaths");
		return *reinterpret_cast<int*>(uintptr_t(this) + addr + id * sizeof(int*));
	}
	int getPing(int id)
	{
		const static auto addr = netvars::getNetvar("DT_PlayerResource", "m_iPing");
		return *reinterpret_cast<int*>(uintptr_t(this) + addr + id * sizeof(int*));
	}
	std::string getRank(int id, bool useShortName = false)
	{
		const static auto addr = netvars::getNetvar("DT_CSPlayerResource", "m_iCompetitiveRanking");

		const static std::pair<std::string, std::string> ranks[] =
		{
			{ "-", "-"},
			{"Silver I", "S1"},
			{"Silver II", "S2"},
			{"Silver III", "S3"},
			{"Silver IV", "S4"},
			{"Silver Elite", "SE"},
			{"Silver Elite Master", "SEM"},
			{"Gold Nova I", "G1"},
			{"Gold Nova II", "G2"},
			{"Gold Nova III", "G3"},
			{"Gold Nova Master", "GM"},
			{"Master Guardian I", "MG1"},
			{"Master Guardian II", "MG2"},
			{"Master Guardian Elite", "MGE"},
			{"Distinguished Master Guardian", "DMG"},
			{"Legendary Eagle", "LE"},
			{"Legendary Eagle Master", "LEM"},
			{"Supreme Master First Class", "SUPREME"},
			{"The Global Elite", "GLOBAL"}
		};
		static size_t size = sizeof(ranks) / sizeof(ranks[0]);
		int rank = *reinterpret_cast<int*>(uintptr_t(this) + addr + id * sizeof(int*));
		const auto& str = !useShortName ? ranks[rank].first : ranks[rank].second;

		return str;
	}

	int getWins(int id)
	{
		const static auto addr = netvars::getNetvar("DT_CSPlayerResource", "m_iCompetitiveWins");
		return *reinterpret_cast<int*>(uintptr_t(this) + addr + id * sizeof(int*));
	}
};
```

`hack/SDK/CPredictionCopy.cpp`:

```cpp
#include "CPredictionCopy.hpp"

#include <gamememory/memory.hpp>

CPredictionCopy::CPredictionCopy(int type, byte* dest, bool dest_packed, const byte* src, bool src_packed, optype_t opType, FN_FIELD_COMPARE func)
{
	this->m_OpType = opType;
	this->m_type = type;
	this->m_dest = dest;
	this->m_src = src;
	m_destOffsetIndex = dest_packed ? TD_OFFSET_PACKED : TD_OFFSET_NORMAL;
	m_srcOffsetIndex = src_packed ? TD_OFFSET_PACKED : TD_OFFSET_NORMAL;

	m_errorCount = 0;
	m_entIndex = -1;

	m_watchField = NULL;
	m_fieldCompareFunc = func;
}

int CPredictionCopy::transferData(const char* operation, int entindex, DataMap_t* dmap)
{
	return memory::transferData()(this, operation, entindex, dmap);
}
```

`hack/SDK/CPredictionCopy.hpp`:

```hpp
#pragma once

#include "datamap.hpp"
#include <stack>

#define PC_DATA_PACKED true
#define PC_DATA_NORMAL false

typedef void (*FN_FIELD_COMPARE)(const char* classname, const char* fieldname, const char* fieldtype,
	bool networked, bool noterrorchecked, bool differs, bool withintolerance, const char* value);

enum
{
	SLOT_ORIGINALDATA = -1,
};

class CPredictionCopy
{
public:
	typedef enum
	{
		DIFFERS = 0,
		IDENTICAL,
		WITHINTOLERANCE,
	} difftype_t;

	typedef enum
	{
		TRANSFERDATA_COPYONLY = 0,  // Data copying only (uses runs)
		TRANSFERDATA_ERRORCHECK_NOSPEW, // Checks for errors, returns after first error found
		TRANSFERDATA_ERRORCHECK_SPEW,   // checks for errors, reports all errors to console
		TRANSFERDATA_ERRORCHECK_DESCRIBE, // used by hud_pdump, dumps values, etc, for all fields
	} optype_t;

	CPredictionCopy(int type, byte* dest, bool dest_packed, const byte* src, bool src_packed,
		optype_t opType, FN_FIELD_COMPARE func = NULL);

	int transferData(const char* operation, int entindex, DataMap_t* dmap);
private:
	optype_t m_OpType;
	int m_type;
	byte* m_dest;
	const byte* m_src;
	int m_destOffsetIndex;
	int	m_srcOffsetIndex;
	int	m_errorCount;
	int	m_entIndex;
	FN_FIELD_COMPARE m_fieldCompareFunc;
	const Typedescription_t* m_watchField;
	char const* m_operation;
	std::stack<const Typedescription_t*> m_fieldStack;
};

```

`hack/SDK/CStudioHdr.hpp`:

```hpp
#pragma once

#include "CUtlVector.hpp"
#include "IVModelInfo.hpp"

#include "helpers/pad.hpp"

struct Virtualmodel_t;

struct CStudioHdr
{
	const studiohdr_t* m_studioHdr;
	Virtualmodel_t* m_vModel;
	/*const virtualmodel_t* ResetVModel(const virtualmodel_t* pVModel) const;
	const studiohdr_t* GroupStudioHdr(int group);*/
	CUtlVector<const studiohdr_t*> m_studioHdrCache;
	int m_sizeframeUnlockCounter;
	int* m_frameUnlockCounter;
	/*CThreadFastMutex	m_FrameUnlockCounterMutex;*/
	PAD(8);
	CUtlVector<int> m_boneFlags;
	CUtlVector<int> m_boneParent;
};
```

`hack/SDK/CTeslaInfo.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include <render/Color.hpp>

class CTeslaInfo
{
public:
	Vec3 m_pos;
	Vec3 m_angles;
	int m_entIndex;
	const char* m_spriteName;
	float m_beamWidth;
	int m_beams;
	Vec3 m_color;
	float m_timeVisible;
	float m_radius;

	void setColor(const Color& color)
	{
		m_color = Vec3{ color.r(), color.g(), color.b() };
	}
};

```

`hack/SDK/CUserCmd.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "checksum_crc.hpp"

#include "helpers/pad.hpp"

class CUserCmd
{
public:
	CRC32_t getChecksum(void) const
	{
		CRC32_t crc;

		CRC32_Init(&crc);
		CRC32_ProcessBuffer(&crc, &m_commandNumber, sizeof(m_commandNumber));
		CRC32_ProcessBuffer(&crc, &m_tickcount, sizeof(m_tickcount));
		CRC32_ProcessBuffer(&crc, &m_viewangles, sizeof(m_viewangles));
		CRC32_ProcessBuffer(&crc, &m_aimdirection, sizeof(m_aimdirection));
		CRC32_ProcessBuffer(&crc, &m_forwardmove, sizeof(m_forwardmove));
		CRC32_ProcessBuffer(&crc, &m_sidemove, sizeof(m_sidemove));
		CRC32_ProcessBuffer(&crc, &m_upmove, sizeof(m_upmove));
		CRC32_ProcessBuffer(&crc, &m_buttons, sizeof(m_buttons));
		CRC32_ProcessBuffer(&crc, &m_impulse, sizeof(m_impulse));
		CRC32_ProcessBuffer(&crc, &m_weaponSelect, sizeof(m_weaponSelect));
		CRC32_ProcessBuffer(&crc, &m_weaponSubtype, sizeof(m_weaponSubtype));
		CRC32_ProcessBuffer(&crc, &m_randomSeed, sizeof(m_randomSeed));
		CRC32_ProcessBuffer(&crc, &m_mousedx, sizeof(m_mousedx));
		CRC32_ProcessBuffer(&crc, &m_mousedy, sizeof(m_mousedy));
		CRC32_Final(&crc);

		return crc;
	}

private:
	void* destroy;
public:
	int m_commandNumber;
	int m_tickcount;
	Vec3 m_viewangles;
	Vec3 m_aimdirection;
	float m_forwardmove;
	float m_sidemove;
	float m_upmove;
	int m_buttons;
	char m_impulse;
	int m_weaponSelect;
	int m_weaponSubtype;
	int m_randomSeed;
	short m_mousedx;
	short m_mousedy;
	bool m_predicted;
	Vec3 m_viewAnglesCopy;
	bool m_buttonsCopy;
	PAD(8);
};
static_assert(sizeof(CUserCmd) == 100);

class CVerifiedUserCmd
{
public:
	CUserCmd m_cmd;
	unsigned long m_crc;
};
```

`hack/SDK/CUtlMemory.hpp`:

```hpp
#pragma once

inline int UtlMemory_CalcNewAllocationCount(int nAllocationCount, int nGrowSize, int nNewSize, int nBytesItem)
{
	if (nGrowSize)
		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);
	else
	{
		if (!nAllocationCount)
			nAllocationCount = (31 + nBytesItem) / nBytesItem;

		while (nAllocationCount < nNewSize)
			nAllocationCount *= 2;
	}

	return nAllocationCount;
}

//-----------------------------------------------------------------------------
// The CUtlMemory class:
// A growable memory class which doubles in size by default.
//-----------------------------------------------------------------------------
template< class T, class I = int >
class CUtlMemory
{
public:
	CUtlMemory() = default;
	CUtlMemory(T* pMemory, int numElements) : m_pMemory(pMemory),
		m_nAllocationCount(numElements)
	{
		// Special marker indicating externally supplied modifyable memory
		m_nGrowSize = -1; // EXTERNAL_BUFFER_MARKER 
	}

	T& operator[](I i)
	{
		return m_pMemory[i];
	}

	T& operator[](I i) const
	{
		return m_pMemory[i];
	}

	T* Base()
	{
		return m_pMemory;
	}

	T* Base() const
	{
		return m_pMemory;
	}

	int NumAllocated() const
	{
		return m_nAllocationCount;
	}

	void Grow(int num = 1)
	{
		if (IsExternallyAllocated())
			return;

		int nAllocationRequested = m_nAllocationCount + num;
		int nNewAllocationCount = UtlMemory_CalcNewAllocationCount(m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T));

		if ((int)(I)nNewAllocationCount < nAllocationRequested)
		{
			if ((int)(I)nNewAllocationCount == 0 && (int)(I)(nNewAllocationCount - 1) >= nAllocationRequested)
				--nNewAllocationCount;
			else
			{
				if ((int)(I)nAllocationRequested != nAllocationRequested)
					return;

				while ((int)(I)nNewAllocationCount < nAllocationRequested)
					nNewAllocationCount = (nNewAllocationCount + nAllocationRequested) / 2;
			}
		}

		m_nAllocationCount = nNewAllocationCount;

		if (m_pMemory)
			m_pMemory = (T*)realloc(m_pMemory, m_nAllocationCount * sizeof(T));
		else
			m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
	}

	bool IsExternallyAllocated() const
	{
		return m_nGrowSize < 0;
	}

	void ConvertToGrowableMemory(int nGrowSize)
	{
		if (!IsExternallyAllocated())
			return;

		m_nGrowSize = nGrowSize;
		if (m_nAllocationCount) 
		{
			int nNumBytes = m_nAllocationCount * sizeof(T);
			T* pMemory = (T*)malloc(nNumBytes);
			memcpy(pMemory, m_pMemory, nNumBytes);
			m_pMemory = pMemory;
		}
		else 
		{
			m_pMemory = NULL;
		}
	}

public:
	T* m_pMemory;
	int m_nAllocationCount;
	int m_nGrowSize;
};
```

`hack/SDK/CUtlReference.hpp`:

```hpp
#pragma once

template<typename T>
struct CUtlReference
{
	CUtlReference* m_next;
	CUtlReference* m_prev;
	T* m_obj;
};

```

`hack/SDK/CUtlString.hpp`:

```hpp
#pragma once

struct CUtlString
{
	char* m_buffer;
	int m_capacity;
	int m_growSize;
	int m_length;
};
```

`hack/SDK/CUtlVector.hpp`:

```hpp
#pragma once

#include "CUtlMemory.hpp"

#include <cassert>

template <class T>
inline T* Construct(T* pMemory)
{
	return ::new(pMemory) T;
}

template <class T>
inline void Destruct(T* pMemory)
{
	pMemory->~T();
}

template <class T>
inline T* CopyConstruct(T* pMemory, T const& src)
{
	return ::new(pMemory) T(src);
}

template<class T, class A = CUtlMemory<T>>
class CUtlVector
{
	typedef A CAllocator;
public:
	CAllocator m_memory;
	int m_size;
	T* m_elements;

	T& operator[](int i)
	{
		return m_memory[i];
	}

	T& operator[](int i) const
	{
		return m_memory[i];
	}

	T& Element(int i)
	{
		return m_memory[i];
	}

	T& Element(int i) const
	{
		return m_memory[i];
	}

	T* Base()
	{
		return m_memory.Base();
	}

	int Count() const
	{
		return m_size;
	}

	void RemoveAll()
	{
		for (int i = m_size; --i >= 0;)
			Destruct(&Element(i));

		m_size = 0;
	}

	int AddToTail()
	{
		return InsertBefore(m_size);
	}

	int AddToTail(const T& src)
	{
		// Can't insert something that's in the list... reallocation may hose us
		assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
		return InsertBefore(m_size, src);
	}

	bool IsValidIndex(int i) const
	{
		return (i >= 0) && (i < m_size);
	}

	int InsertBefore(int elem)
	{
		GrowVector();
		ShiftElementsRight(elem);
		Construct(&Element(elem));

		return elem;
	}

	int InsertBefore(int elem, const T& src)
	{
		assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
		assert((elem == Count()) || IsValidIndex(elem));

		GrowVector();
		ShiftElementsRight(elem);
		CopyConstruct(&Element(elem), src);
		return elem;
	}

	int GetOffset(const T& src) const
	{
		for (int i = 0; i < Count(); ++i)
		{
			if (Element(i) == src)
				return i;
		}
		return -1;
	}

	void Remove(int elem)
	{
		Destruct(&Element(elem));
		ShiftElementsLeft(elem);
		--m_size;
	}

	bool FindAndRemove(const T& src)
	{
		int elem = GetOffset(src);
		if (elem != -1)
		{
			Remove(elem);
			return true;
		}
		return false;
	}

protected:
	void GrowVector(int num = 1)
	{
		if (m_size + num > m_memory.NumAllocated())
			m_memory.Grow(m_size + num - m_memory.NumAllocated());

		m_size += num;
		ResetDbgInfo();
	}

	void ShiftElementsRight(int elem, int num = 1)
	{
		int numToMove = m_size - elem - num;
		if ((numToMove > 0) && (num > 0))
			memmove(&Element(elem + num), &Element(elem), numToMove * sizeof(T));
	}

	void ShiftElementsLeft(int elem, int num = 1)
	{
		int numToMove = m_size - elem - num;
		if ((numToMove > 0) && (num > 0))
			memmove(&Element(elem), &Element(elem + num), numToMove * sizeof(T));
	}

	inline void ResetDbgInfo()
	{
		m_elements = Base();
	}
};
```

`hack/SDK/CViewSetup.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

#include "helpers/pad.hpp"

class CViewSetup
{
public:
	int x;
	int xOld;
	int y;
	int yOld;
	int m_width;
	int m_widthOld;
	int m_height;
	int m_heightOld;
	PAD(144);
	float m_fov;
	float m_viewModelFov;
	Vec3 m_origin;
	Vec3 m_angles;
	float m_nearZ;
	float m_farZ;
	float m_nearViewModelZ;
	float m_farViewModelZ;
	float m_aspectRatio;
	float m_nearBlurDepth;
	float m_nearFocusDepth;
	float m_farFocusDepth;
	float m_farBlurDepth;
	float m_nearBlurRadius;
	float m_farBlurRadius;
	float m_doFQuality;
	int m_motionBlurMode;
	float m_shutterTime;
	Vec3 m_shutterOpenPosition;
	Vec3 m_shutterOpenAngles;
	Vec3 m_shutterClosePosition;
	Vec3 m_shutterCloseAngles;
	float m_offCenterTop;
	float m_offCenterBottom;
	float m_offCenterLeft;
	float m_offCenterRight;
	int m_edgeBlur;
};
```

`hack/SDK/ClientClass.hpp`:

```hpp
#pragma once

#include "Recv.hpp"
#include "Enums.hpp"

class ClientClass
{
private:
	using createfn = std::add_pointer_t<void* __cdecl(int, int)>;
	using createeventfn = std::add_pointer_t<void* __cdecl()>;
public:
	createfn m_createFn;
	createeventfn m_createEventFn;
	char* m_networkName;
	RecvTable* m_recvTable;
	ClientClass* m_next;
	ClassID m_classID;
};
```

`hack/SDK/ClientMode.hpp`:

```hpp
#pragma once

class ClientMode;
```

`hack/SDK/ConVar.hpp`:

```hpp
#pragma once

#include "CUtlVector.hpp"
#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

//-----------------------------------------------------------------------------
// ConVar flags
//-----------------------------------------------------------------------------
// The default, no flags at all
#define FCVAR_NONE				0 

// Command to ConVars and ConCommands
// ConVar Systems
#define FCVAR_UNREGISTERED		(1<<0)	// If this is set, don't add to linked list, etc.
#define FCVAR_DEVELOPMENTONLY	(1<<1)	// Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
#define FCVAR_GAMEDLL			(1<<2)	// defined by the game DLL
#define FCVAR_CLIENTDLL			(1<<3)  // defined by the client DLL
#define FCVAR_HIDDEN			(1<<4)	// Hidden. Doesn't appear in find or auto complete. Like DEVELOPMENTONLY, but can't be compiled out.

// ConVar only
#define FCVAR_PROTECTED			(1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY			(1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define	FCVAR_ARCHIVE			(1<<7)	// set to cause it to be saved to vars.rc
#define	FCVAR_NOTIFY			(1<<8)	// notifies players when changed
#define	FCVAR_USERINFO			(1<<9)	// changes the client's info string

#define FCVAR_PRINTABLEONLY		(1<<10)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).

#define FCVAR_GAMEDLL_FOR_REMOTE_CLIENTS		(1<<10)  // When on concommands this allows remote clients to execute this cmd on the server. 
														 // We are changing the default behavior of concommands to disallow execution by remote clients without
														 // this flag due to the number existing concommands that can lag or crash the server when clients abuse them.

#define FCVAR_UNLOGGED			(1<<11)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log
#define FCVAR_NEVER_AS_STRING	(1<<12)  // never try to print that cvar

// It's a ConVar that's shared between the client and the server.
// At signon, the values of all such ConVars are sent from the server to the client (skipped for local
//  client, of course )
// If a change is requested it must come from the console (i.e., no remote client changes)
// If a value is changed while a server is active, it's replicated to all connected clients
#define FCVAR_REPLICATED		(1<<13)	// server setting enforced on clients, TODO rename to FCAR_SERVER at some time
#define FCVAR_CHEAT				(1<<14) // Only useable in singleplayer / debug / multiplayer & sv_cheats
#define FCVAR_SS				(1<<15) // causes varnameN where N == 2 through max splitscreen slots for mod to be autogenerated
#define FCVAR_DEMO				(1<<16) // record this cvar when starting a demo file
#define FCVAR_DONTRECORD		(1<<17) // don't record these command in demofiles
#define FCVAR_SS_ADDED			(1<<18) // This is one of the "added" FCVAR_SS variables for the splitscreen players
#define FCVAR_RELEASE			(1<<19) // Cvars tagged with this are the only cvars avaliable to customers
#define FCVAR_RELOAD_MATERIALS	(1<<20)	// If this cvar changes, it forces a material reload
#define FCVAR_RELOAD_TEXTURES	(1<<21)	// If this cvar changes, if forces a texture reload

#define FCVAR_NOT_CONNECTED		(1<<22)	// cvar cannot be changed by a client that is connected to a server
#define FCVAR_MATERIAL_SYSTEM_THREAD (1<<23)	// Indicates this cvar is read from the material system thread
#define FCVAR_ARCHIVE_GAMECONSOLE	(1<<24) // cvar written to config.cfg on the Xbox

#define FCVAR_SERVER_CAN_EXECUTE	(1<<28)// the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
#define FCVAR_SERVER_CANNOT_QUERY	(1<<29)// If this is set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).
#define FCVAR_CLIENTCMD_CAN_EXECUTE	(1<<30)	// IVEngineClient::ClientCmd is allowed to execute this command. 
											// Note: IVEngineClient::ClientCmd_Unrestricted can run any client command.

#define FCVAR_ACCESSIBLE_FROM_THREADS	(1<<25)	// used as a debugging tool necessary to check material system thread convars
// #define FCVAR_AVAILABLE			(1<<26)
// #define FCVAR_AVAILABLE			(1<<27)
// #define FCVAR_AVAILABLE			(1<<31)

#define FCVAR_MATERIAL_THREAD_MASK ( FCVAR_RELOAD_MATERIALS | FCVAR_RELOAD_TEXTURES | FCVAR_MATERIAL_SYSTEM_THREAD )

class IConVar
{
public:
	VFUNC(float, getFloat, 12, (), (this));
	VFUNC(int, getInt, 13, (), (this));
	VFUNC(void, setValue, 14, (const char* val), (this, val));
	VFUNC(void, setValue, 15, (float val), (this, val));
	VFUNC(void, setValue, 16, (int val), (this, val));
	VFUNC(void, setValue, 17, (bool val), (this, val));

private:
	void* sometable;
public:
	IConVar* m_next;
	alignas(4) bool registered;
	char* m_name;
	char* m_helper;
	int m_flags;
private:
	void* unkCallback;
public:
	IConVar* m_parent;
	const char* m_defaultValue;
	char* m_valueNow;
	int m_valueLength;
private:
	IConVar* parentCopy1;
	IConVar* parentCopy2;
public:
	char* valuenowCopied; // bit delayed
	int m_valueLengthCopied;
private:
	IConVar* parentCopy3;
	IConVar* parentCopy4; // wtf?
	PAD(16); // all zeros
	CUtlVector<std::add_pointer_t<void __cdecl()>> m_callbacks;
};
```

`hack/SDK/CutlBuffer.hpp`:

```hpp
#pragma once

#include "CUtlMemory.hpp"

class CByteswap
{
public:
	unsigned int m_bSwapBytes : 1;
	unsigned int m_bBigEndian : 1;
};

class CUtlBuffer
{
public:
	CUtlBuffer() = default;
	CUtlBuffer(const void* buffer, int size, int flags)
		: m_Memory((unsigned char*)buffer, size), m_Error(0)
	{
		m_Get = 0;
		m_Put = 0;
		m_nTab = 0;
		m_nOffset = 0;
		m_Flags = (unsigned char)flags;
		if (IsReadOnly()) 
		{
			m_nMaxPut = size;
		}
		else 
		{
			m_nMaxPut = -1;
			AddNullTermination();
		}
		SetOverflowFuncs(&CUtlBuffer::GetOverflow, &CUtlBuffer::PutOverflow);
	}

	enum SeekType_t
	{
		SEEK_HEAD = 0,
		SEEK_CURRENT,
		SEEK_TAIL
	};

	// flags
	enum BufferFlags_t
	{
		TEXT_BUFFER = 0x1,			// Describes how Get + put work (as strings, or binary)
		EXTERNAL_GROWABLE = 0x2,	// This is used w/ external buffers and causes the utlbuf to switch to reallocatable memory if an overflow happens when Putting.
		CONTAINS_CRLF = 0x4,		// For text buffers only, does this contain \n or \n\r?
		READ_ONLY = 0x8,			// For external buffers; prevents null termination from happening.
		AUTO_TABS_DISABLED = 0x10,	// Used to disable/enable push/pop tabs
	};

	typedef bool (CUtlBuffer::* UtlBufferOverflowFunc_t)(int nSize);

	void SetOverflowFuncs(UtlBufferOverflowFunc_t getFunc, UtlBufferOverflowFunc_t putFunc)
	{
		m_GetOverflowFunc = getFunc;
		m_PutOverflowFunc = putFunc;
	}

	void* PeekPut(int offset)
	{
		return &m_Memory[m_Put + offset - m_nOffset];
	}

	bool GetOverflow(int nSize)
	{
		return false;
	}

	inline bool IsGrowable() const
	{
		return (m_Flags & EXTERNAL_GROWABLE) != 0;
	}

	bool PutOverflow(int nSize)
	{
		if (m_Memory.IsExternallyAllocated()) 
		{
			if (!IsGrowable())
				return false;

			m_Memory.ConvertToGrowableMemory(0);
		}

		while (Size() < m_Put - m_nOffset + nSize) 
		{
			m_Memory.Grow();
		}

		return true;
	}

	int Size() const
	{
		return m_Memory.m_nAllocationCount;
	}

	bool IsReadOnly() const
	{
		return (m_Flags & READ_ONLY);
	}

	void AddNullTermination()
	{
		if (m_Put > m_nMaxPut) {
			if (!IsReadOnly() && ((m_Error & PUT_OVERFLOW) == 0)) 
			{
				// Add null termination value
				if (CheckPut(1)) 
				{
					m_Memory[m_Put - m_nOffset] = 0;
				}
				else 
				{
					// Restore the overflow state, it was valid before...
					m_Error &= ~PUT_OVERFLOW;
				}
			}
			m_nMaxPut = m_Put;
		}
	}

protected:
	// error flags
	enum
	{
		PUT_OVERFLOW = 0x1,
		GET_OVERFLOW = 0x2,
		MAX_ERROR_FLAG = GET_OVERFLOW,
	};

	bool OnPutOverflow(int nSize)
	{
		return (this->*m_PutOverflowFunc)(nSize);
	}

	bool OnGetOverflow(int nSize)
	{
		return (this->*m_GetOverflowFunc)(nSize);
	}

	bool CheckPut(const int nSize)
	{
		if ((m_Error & PUT_OVERFLOW) || IsReadOnly())
			return false;

		if ((m_Put < m_nOffset) || (m_Memory.NumAllocated() < m_Put - m_nOffset + nSize)) 
		{
			if (!OnPutOverflow(nSize)) 
			{
				m_Error |= PUT_OVERFLOW;
				return false;
			}
		}
		return true;
	}

	CUtlMemory<unsigned char> m_Memory;
	int m_Get;
	int m_Put;

	unsigned char m_Error;
	unsigned char m_Flags;
	unsigned char m_Reserved;
#if defined( _X360 )
	unsigned char pad;
#endif

	int m_nTab;
	int m_nMaxPut;
	int m_nOffset;

	UtlBufferOverflowFunc_t m_GetOverflowFunc;
	UtlBufferOverflowFunc_t m_PutOverflowFunc;

	CByteswap	m_Byteswap;
};
```

`hack/SDK/EHandle.hpp`:

```hpp
#pragma once

#include <cstdint>

struct CBaseHandle
{
	uint32_t handle;
	constexpr bool operator!() const { return handle != -1; } // 0xFFFFFFFF
	// when cant use ! at beginning
	constexpr bool isValid() const { return handle != -1; } // 0xFFFFFFFF
};

```

`hack/SDK/Enums.hpp`:

```hpp
#pragma once

#pragma region beams
enum BeamEffects
{
	TE_BEAMPOINTS = 0x00,		// beam effect between two points
	TE_SPRITE = 0x01,	// additive sprite, plays 1 cycle
	TE_BEAMDISK = 0x02,	// disk that expands to max radius over lifetime
	TE_BEAMCYLINDER = 0x03,		// cylinder that expands to max radius over lifetime
	TE_BEAMFOLLOW = 0x04,		// create a line of decaying beam segments until entity stops moving
	TE_BEAMRING = 0x05,		// connect a beam ring to two entities
	TE_BEAMSPLINE = 0x06,
	TE_BEAMRINGPOINT = 0x07,
	TE_BEAMLASER = 0x08,		// Fades according to viewpoint
	TE_BEAMTESLA = 0x09,
};

enum BeamTypes
{
	FBEAM_STARTENTITY = 0x00000001,
	FBEAM_ENDENTITY = 0x00000002,
	FBEAM_FADEIN = 0x00000004,
	FBEAM_FADEOUT = 0x00000008,
	FBEAM_SINENOISE = 0x00000010,
	FBEAM_SOLID = 0x00000020,
	FBEAM_SHADEIN = 0x00000040,
	FBEAM_SHADEOUT = 0x00000080,
	FBEAM_ONLYNOISEONCE = 0x00000100,		// Only calculate our noise once
	FBEAM_NOTILE = 0x00000200,
	FBEAM_USE_HITBOXES = 0x00000400,		// Attachment indices represent hitbox indices instead when this is set.
	FBEAM_STARTVISIBLE = 0x00000800,		// Has this client actually seen this beam's start entity yet?
	FBEAM_ENDVISIBLE = 0x00001000,		// Has this client actually seen this beam's end entity yet?
	FBEAM_ISACTIVE = 0x00002000,
	FBEAM_FOREVER = 0x00004000,
	FBEAM_HALOBEAM = 0x00008000,		// When drawing a beam with a halo, don't ignore the segments and endwidth
	FBEAM_REVERSED = 0x00010000,
	NUM_BEAM_FLAGS = 17	// KEEP THIS UPDATED!
};
#pragma endregion

#pragma region all_classes_ids

/*
* to get this faster from dump, run this js script
* let str = ``; // dumped all classes, raw output from console
* let arr = str.split('\n');

for(let i = 0; i < arr.length; i++) {
	let s = arr[i];
	let endPos = s.indexOf('(');
	let resultString = arr[i].substring(0, endPos);
	console.log(resultString + ',');
}
*/

enum ClassID
{
	CAI_BaseNPC,
	CAK47,
	CBaseAnimating,
	CBaseAnimatingOverlay,
	CBaseAttributableItem,
	CBaseButton,
	CBaseCombatCharacter,
	CBaseCombatWeapon,
	CBaseCSGrenade,
	CBaseCSGrenadeProjectile,
	CBaseDoor,
	CBaseEntity,
	CBaseFlex,
	CBaseGrenade,
	CBaseParticleEntity,
	CBasePlayer,
	CBasePropDoor,
	CBaseTeamObjectiveResource,
	CBaseTempEntity,
	CBaseToggle,
	CBaseTrigger,
	CBaseViewModel,
	CBaseVPhysicsTrigger,
	CBaseWeaponWorldModel,
	CBeam,
	CBeamSpotlight,
	CBoneFollower,
	CBRC4Target,
	CBreachCharge,
	CBreachChargeProjectile,
	CBreakableProp,
	CBreakableSurface,
	CBumpMine,
	CBumpMineProjectile,
	CC4,
	CCascadeLight,
	CChicken,
	CColorCorrection,
	CColorCorrectionVolume,
	CCSGameRulesProxy,
	CCSPlayer,
	CCSPlayerResource,
	CCSRagdoll,
	CCSTeam,
	CDangerZone,
	CDangerZoneController,
	CDEagle,
	CDecoyGrenade,
	CDecoyProjectile,
	CDrone,
	CDronegun,
	CDynamicLight,
	CDynamicProp,
	CEconEntity,
	CEconWearable,
	CEmbers,
	CEntityDissolve,
	CEntityFlame,
	CEntityFreezing,
	CEntityParticleTrail,
	CEnvAmbientLight,
	CEnvDetailController,
	CEnvDOFController,
	CEnvGasCanister,
	CEnvParticleScript,
	CEnvProjectedTexture,
	CEnvQuadraticBeam,
	CEnvScreenEffect,
	CEnvScreenOverlay,
	CEnvTonemapController,
	CEnvWind,
	CFEPlayerDecal,
	CFireCrackerBlast,
	CFireSmoke,
	CFireTrail,
	CFish,
	CFists,
	CFlashbang,
	CFogController,
	CFootstepControl,
	CFunc_Dust,
	CFunc_LOD,
	CFuncAreaPortalWindow,
	CFuncBrush,
	CFuncConveyor,
	CFuncLadder,
	CFuncMonitor,
	CFuncMoveLinear,
	CFuncOccluder,
	CFuncReflectiveGlass,
	CFuncRotating,
	CFuncSmokeVolume,
	CFuncTrackTrain,
	CGameRulesProxy,
	CGrassBurn,
	CHandleTest,
	CHEGrenade,
	CHostage,
	CHostageCarriableProp,
	CIncendiaryGrenade,
	CInferno,
	CInfoLadderDismount,
	CInfoMapRegion,
	CInfoOverlayAccessor,
	CItem_Healthshot,
	CItemCash,
	CItemDogtags,
	CKnife,
	CKnifeGG,
	CLightGlow,
	CMapVetoPickController,
	CMaterialModifyControl,
	CMelee,
	CMolotovGrenade,
	CMolotovProjectile,
	CMovieDisplay,
	CParadropChopper,
	CParticleFire,
	CParticlePerformanceMonitor,
	CParticleSystem,
	CPhysBox,
	CPhysBoxMultiplayer,
	CPhysicsProp,
	CPhysicsPropMultiplayer,
	CPhysMagnet,
	CPhysPropAmmoBox,
	CPhysPropLootCrate,
	CPhysPropRadarJammer,
	CPhysPropWeaponUpgrade,
	CPlantedC4,
	CPlasma,
	CPlayerPing,
	CPlayerResource,
	CPointCamera,
	CPointCommentaryNode,
	CPointWorldText,
	CPoseController,
	CPostProcessController,
	CPrecipitation,
	CPrecipitationBlocker,
	CPredictedViewModel,
	CProp_Hallucination,
	CPropCounter,
	CPropDoorRotating,
	CPropJeep,
	CPropVehicleDriveable,
	CRagdollManager,
	CRagdollProp,
	CRagdollPropAttached,
	CRopeKeyframe,
	CSCAR17,
	CSceneEntity,
	CSensorGrenade,
	CSensorGrenadeProjectile,
	CShadowControl,
	CSlideshowDisplay,
	CSmokeGrenade,
	CSmokeGrenadeProjectile,
	CSmokeStack,
	CSnowball,
	CSnowballPile,
	CSnowballProjectile,
	CSpatialEntity,
	CSpotlightEnd,
	CSprite,
	CSpriteOriented,
	CSpriteTrail,
	CStatueProp,
	CSteamJet,
	CSun,
	CSunlightShadowControl,
	CSurvivalSpawnChopper,
	CTablet,
	CTeam,
	CTeamplayRoundBasedRulesProxy,
	CTEArmorRicochet,
	CTEBaseBeam,
	CTEBeamEntPoint,
	CTEBeamEnts,
	CTEBeamFollow,
	CTEBeamLaser,
	CTEBeamPoints,
	CTEBeamRing,
	CTEBeamRingPoint,
	CTEBeamSpline,
	CTEBloodSprite,
	CTEBloodStream,
	CTEBreakModel,
	CTEBSPDecal,
	CTEBubbles,
	CTEBubbleTrail,
	CTEClientProjectile,
	CTEDecal,
	CTEDust,
	CTEDynamicLight,
	CTEEffectDispatch,
	CTEEnergySplash,
	CTEExplosion,
	CTEFireBullets,
	CTEFizz,
	CTEFootprintDecal,
	CTEFoundryHelpers,
	CTEGaussExplosion,
	CTEGlowSprite,
	CTEImpact,
	CTEKillPlayerAttachments,
	CTELargeFunnel,
	CTEMetalSparks,
	CTEMuzzleFlash,
	CTEParticleSystem,
	CTEPhysicsProp,
	CTEPlantBomb,
	CTEPlayerAnimEvent,
	CTEPlayerDecal,
	CTEProjectedDecal,
	CTERadioIcon,
	CTEShatterSurface,
	CTEShowLine,
	CTesla,
	CTESmoke,
	CTESparks,
	CTESprite,
	CTESpriteSpray,
	CTest_ProxyToggle_Networkable,
	CTestTraceline,
	CTEWorldDecal,
	CTriggerPlayerMovement,
	CTriggerSoundOperator,
	CVGuiScreen,
	CVoteController,
	CWaterBullet,
	CWaterLODControl,
	CWeaponAug,
	CWeaponAWP,
	CWeaponBaseItem,
	CWeaponBizon,
	CWeaponCSBase,
	CWeaponCSBaseGun,
	CWeaponCycler,
	CWeaponElite,
	CWeaponFamas,
	CWeaponFiveSeven,
	CWeaponG3SG1,
	CWeaponGalil,
	CWeaponGalilAR,
	CWeaponGlock,
	CWeaponHKP2000,
	CWeaponM249,
	CWeaponM3,
	CWeaponM4A1,
	CWeaponMAC10,
	CWeaponMag7,
	CWeaponMP5Navy,
	CWeaponMP7,
	CWeaponMP9,
	CWeaponNegev,
	CWeaponNOVA,
	CWeaponP228,
	CWeaponP250,
	CWeaponP90,
	CWeaponSawedoff,
	CWeaponSCAR20,
	CWeaponScout,
	CWeaponSG550,
	CWeaponSG552,
	CWeaponSG556,
	CWeaponShield,
	CWeaponSSG08,
	CWeaponTaser,
	CWeaponTec9,
	CWeaponTMP,
	CWeaponUMP45,
	CWeaponUSP,
	CWeaponXM1014,
	CWeaponZoneRepulsor,
	CWorld,
	CWorldVguiText,
	DustTrail,
	MovieExplosion,
	ParticleSmokeGrenade,
	RocketTrail,
	SmokeTrail,
	SporeExplosion,
	SporeTrail,
};
#pragma endregion

#pragma region framestage
enum FrameStage
{
	FRAME_UNDEFINED = -1,
	FRAME_START,
	FRAME_NET_UPDATE_START,
	FRAME_NET_UPDATE_POSTDATAUPDATE_START,
	FRAME_NET_UPDATE_POSTDATAUPDATE_END,
	FRAME_NET_UPDATE_END,
	FRAME_RENDER_START,
	FRAME_RENDER_END
};
#pragma endregion

#pragma region weapons
enum WeaponType
{
	WEAPONTYPE_KNIFE = 0,
	WEAPONTYPE_PISTOL,
	WEAPONTYPE_SUBMACHINEGUN,
	WEAPONTYPE_RIFLE,
	WEAPONTYPE_SHOTGUN,
	WEAPONTYPE_SNIPER_RIFLE,
	WEAPONTYPE_MACHINEGUN,
	WEAPONTYPE_C4,
	WEAPONTYPE_PLACEHOLDER,
	WEAPONTYPE_GRENADE,
	WEAPONTYPE_UNKNOWN
};

enum WeaponIndex
{
	WEAPON_NONE,
	WEAPON_DEAGLE,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_GLOCK,
	WEAPON_AK47 = 7,
	WEAPON_AUG,
	WEAPON_AWP,
	WEAPON_FAMAS,
	WEAPON_G3SG1,
	WEAPON_GALILAR = 13,
	WEAPON_M249,
	WEAPON_M4A1 = 16,
	WEAPON_MAC10,
	WEAPON_P90 = 19,
	WEAPON_ZONE_REPULSOR,
	WEAPON_MP5SD = 23,
	WEAPON_UMP45,
	WEAPON_XM1014,
	WEAPON_BIZON,
	WEAPON_MAG7,
	WEAPON_NEGEV,
	WEAPON_SAWEDOFF,
	WEAPON_TEC9,
	WEAPON_TASER,
	WEAPON_HKP2000,
	WEAPON_MP7,
	WEAPON_MP9,
	WEAPON_NOVA,
	WEAPON_P250,
	WEAPON_SHIELD,
	WEAPON_SCAR20,
	WEAPON_SG553,
	WEAPON_SSG08,
	WEAPON_KNIFEGG,
	WEAPON_KNIFE,
	WEAPON_FLASHBANG,
	WEAPON_HEGRENADE,
	WEAPON_SMOKEGRENADE,
	WEAPON_MOLOTOV,
	WEAPON_DECOY,
	WEAPON_INCGRENADE,
	WEAPON_C4,
	WEAPON_HEALTHSHOT = 57,
	WEAPON_KNIFE_T = 59,
	WEAPON_M4A1_SILENCER,
	WEAPON_USP_SILENCER,
	WEAPON_CZ75A = 63,
	WEAPON_REVOLVER,
	WEAPON_TAGRENADE = 68,
	WEAPON_FISTS,
	WEAPON_BREACHCHARGE,
	WEAPON_TABLET = 72,
	WEAPON_MELEE = 74,
	WEAPON_AXE,
	WEAPON_HAMMER,
	WEAPON_SPANNER = 78,
	WEAPON_KNIFE_GHOST = 80,
	WEAPON_FIREBOMB,
	WEAPON_DIVERSION,
	WEAPON_FRAG_GRENADE,
	WEAPON_SNOWBALL,
	WEAPON_BUMPMINE,
	WEAPON_KNIFE_BAYONET = 500,
	WEAPON_KNIFE_CSS = 503,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT,
	WEAPON_KNIFE_KARAMBIT,
	WEAPON_KNIFE_M9_BAYONET,
	WEAPON_KNIFE_TACTICAL,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_SURVIVAL_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY,
	WEAPON_KNIFE_PUSH,
	WEAPON_KNIFE_CORD,
	WEAPON_KNIFE_CANIS,
	WEAPON_KNIFE_URSUS,
	WEAPON_KNIFE_GYPSY_JACKKNIFE,
	WEAPON_KNIFE_OUTDOOR,
	WEAPON_KNIFE_STILETTO,
	WEAPON_KNIFE_WIDOWMAKER,
	WEAPON_KNIFE_SKELETON = 525,
	GLOVE_STUDDED_BLOODHOUND = 5027,
	GLOVE_T_SIDE,
	GLOVE_CT_SIDE,
	GLOVE_SPORTY,
	GLOVE_SLICK,
	GLOVE_LEATHER_WRAP,
	GLOVE_MOTORCYCLE,
	GLOVE_SPECIALIST,
	GLOVE_HYDRA,
};
#pragma endregion

#pragma region spec_stuff
enum ObserverTypes
{
	OBS_MODE_NONE = 0,	// not in spectator mode
	OBS_MODE_DEATHCAM,	// special mode for death cam animation
	OBS_MODE_FREEZECAM,	// zooms to a target, and freeze-frames on them
	OBS_MODE_FIXED,		// view from a fixed camera position
	OBS_MODE_IN_EYE,	// follow a player in first person view
	OBS_MODE_CHASE,		// follow a player in third person view
	OBS_MODE_POI,		// PASSTIME point of interest - game objective, big fight, anything interesting; added in the middle of the enum due to tons of hard-coded "<ROAMING" enum compares
	OBS_MODE_ROAMING,	// free roaming

	NUM_OBSERVER_MODES,
};
#pragma endregion

#pragma region collisions
enum CollisionGroup_t : size_t
{
	COLLISION_GROUP_NONE = 0,
	COLLISION_GROUP_DEBRIS,			// Collides with nothing but world and static stuff
	COLLISION_GROUP_DEBRIS_TRIGGER, // Same as debris, but hits triggers
	COLLISION_GROUP_INTERACTIVE_DEBRIS,	// Collides with everything except other interactive debris or debris
	COLLISION_GROUP_INTERACTIVE,	// Collides with everything except interactive debris or debris
	COLLISION_GROUP_PLAYER,
	COLLISION_GROUP_BREAKABLE_GLASS,
	COLLISION_GROUP_VEHICLE,
	COLLISION_GROUP_PLAYER_MOVEMENT,  // For HL2, same as Collision_Group_Player, for // TF2, this filters out other players and CBaseObjects
	COLLISION_GROUP_NPC,			// Generic NPC group
	COLLISION_GROUP_IN_VEHICLE,		// for any entity inside a vehicle
	COLLISION_GROUP_WEAPON,			// for any weapons that need collision detection
	COLLISION_GROUP_VEHICLE_CLIP,	// vehicle clip brush to restrict vehicle movement
	COLLISION_GROUP_PROJECTILE,		// Projectiles!
	COLLISION_GROUP_DOOR_BLOCKER,	// Blocks entities not permitted to get near moving doors
	COLLISION_GROUP_PASSABLE_DOOR,	// Doors that the player shouldn't collide with
	COLLISION_GROUP_DISSOLVING,		// Things that are dissolving are in this group
	COLLISION_GROUP_PUSHAWAY,		// Nonsolid on client and server, pushaway in player code
	COLLISION_GROUP_NPC_ACTOR,		// Used so NPCs in scripts ignore the player.
	COLLISION_GROUP_NPC_SCRIPTED,	// USed for NPCs in scripts that should not collide with each other
	LAST_SHARED_COLLISION_GROUP
};
#pragma endregion

#pragma region hitboxes
enum Hitboxes
{
	HITBOX_HEAD,
	HITBOX_NECK,
	HITBOX_PELVIS,
	HITBOX_BELLY,
	HITBOX_THORAX,
	HITBOX_LOWER_CHEST,
	HITBOX_UPPER_CHEST,
	HITBOX_RIGHT_THIGH,
	HITBOX_LEFT_THIGH,
	HITBOX_RIGHT_CALF,
	HITBOX_LEFT_CALF,
	HITBOX_RIGHT_FOOT,
	HITBOX_LEFT_FOOT,
	HITBOX_RIGHT_HAND,
	HITBOX_LEFT_HAND,
	HITBOX_RIGHT_UPPER_ARM,
	HITBOX_RIGHT_FOREARM,
	HITBOX_LEFT_UPPER_ARM,
	HITBOX_LEFT_FOREARM,
	HITBOX_MAX
};
#pragma endregion

#pragma region hitgroups
enum Hitgroups
{
	HITGROUP_GENERIC,
	HITGROUP_HEAD,
	HITGROUP_CHEST,
	HITGROUP_STOMACH,
	HITGROUP_LEFTARM,
	HITGROUP_RIGHTARM,
	HITGROUP_LEFTLEG,
	HITGROUP_RIGHTLEG,
	HITGROUP_GEAR // alerts NPC, but doesn't do damage or bleed (1/100th damage)
};
#pragma endregion

#pragma region render_target
enum MaterialRenderTargetDepth_t
{
	MATERIAL_RT_DEPTH_SHARED = 0x0,
	MATERIAL_RT_DEPTH_SEPARATE = 0x1,
	MATERIAL_RT_DEPTH_NONE = 0x2,
	MATERIAL_RT_DEPTH_ONLY = 0x3,
};

enum RenderTargetSizeMode_t
{
	RT_SIZE_NO_CHANGE = 0,			// Only allowed for render targets that don't want a depth buffer
	// (because if they have a depth buffer, the render target must be less than or equal to the size of the framebuffer).
	RT_SIZE_DEFAULT = 1,				// Don't play with the specified width and height other than making sure it fits in the framebuffer.
	RT_SIZE_PICMIP = 2,				// Apply picmip to the render target's width and height.
	RT_SIZE_HDR = 3,					// frame_buffer_width / 4
	RT_SIZE_FULL_FRAME_BUFFER = 4,	// Same size as frame buffer, or next lower power of 2 if we can't do that.
	RT_SIZE_OFFSCREEN = 5,			// Target of specified size, don't mess with dimensions
	RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP = 6 // Same size as the frame buffer, rounded up if necessary for systems that can't do non-power of two textures.
};
#pragma endregion

#pragma region image_format
enum ImageFormat
{
	IMAGE_FORMAT_UNKNOWN = -1,
	IMAGE_FORMAT_RGBA8888 = 0,
	IMAGE_FORMAT_ABGR8888,
	IMAGE_FORMAT_RGB888,
	IMAGE_FORMAT_BGR888,
	IMAGE_FORMAT_RGB565,
	IMAGE_FORMAT_I8,
	IMAGE_FORMAT_IA88,
	IMAGE_FORMAT_P8,
	IMAGE_FORMAT_A8,
	IMAGE_FORMAT_RGB888_BLUESCREEN,
	IMAGE_FORMAT_BGR888_BLUESCREEN,
	IMAGE_FORMAT_ARGB8888,
	IMAGE_FORMAT_BGRA8888,
	IMAGE_FORMAT_DXT1,
	IMAGE_FORMAT_DXT3,
	IMAGE_FORMAT_DXT5,
	IMAGE_FORMAT_BGRX8888,
	IMAGE_FORMAT_BGR565,
	IMAGE_FORMAT_BGRX5551,
	IMAGE_FORMAT_BGRA4444,
	IMAGE_FORMAT_DXT1_ONEBITALPHA,
	IMAGE_FORMAT_BGRA5551,
	IMAGE_FORMAT_UV88,
	IMAGE_FORMAT_UVWQ8888,
	IMAGE_FORMAT_RGBA16161616F,
	IMAGE_FORMAT_RGBA16161616,
	IMAGE_FORMAT_UVLX8888,
	IMAGE_FORMAT_R32F,			// Single-channel 32-bit floating point
	IMAGE_FORMAT_RGB323232F,
	IMAGE_FORMAT_RGBA32323232F,

	// Depth-stencil texture formats for shadow depth mapping
	IMAGE_FORMAT_NV_DST16,		//
	IMAGE_FORMAT_NV_DST24,		//
	IMAGE_FORMAT_NV_INTZ,		// Vendor-specific depth-stencil texture
	IMAGE_FORMAT_NV_RAWZ,		// formats for shadow depth mapping
	IMAGE_FORMAT_ATI_DST16,		//
	IMAGE_FORMAT_ATI_DST24,		//
	IMAGE_FORMAT_NV_NULL,		// Dummy format which takes no video memory

	// Compressed normal map formats
	IMAGE_FORMAT_ATI2N,			// One-surface ATI2N / DXN format
	IMAGE_FORMAT_ATI1N,			// Two-surface ATI1N format

	IMAGE_FORMAT_DXT1_RUNTIME,
	IMAGE_FORMAT_DXT5_RUNTIME,

	NUM_IMAGE_FORMATS
};
#pragma endregion

#pragma region texture_flags
enum CompiledVtfFlags
{
	// Flags from the *.txt config file
	TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
	TEXTUREFLAGS_TRILINEAR = 0x00000002,
	TEXTUREFLAGS_CLAMPS = 0x00000004,
	TEXTUREFLAGS_CLAMPT = 0x00000008,
	TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
	TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
	TEXTUREFLAGS_PWL_CORRECTED = 0x00000040,
	TEXTUREFLAGS_NORMAL = 0x00000080,
	TEXTUREFLAGS_NOMIP = 0x00000100,
	TEXTUREFLAGS_NOLOD = 0x00000200,
	TEXTUREFLAGS_ALL_MIPS = 0x00000400,
	TEXTUREFLAGS_PROCEDURAL = 0x00000800,

	// These are automatically generated by vtex from the texture data.
	TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
	TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,

	// Newer flags from the *.txt config file
	TEXTUREFLAGS_ENVMAP = 0x00004000,
	TEXTUREFLAGS_RENDERTARGET = 0x00008000,
	TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
	TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
	TEXTUREFLAGS_SINGLECOPY = 0x00040000,

	TEXTUREFLAGS_SRGB = 0x00080000, //SRGB correction has already been applied to this texture.

	TEXTUREFLAGS_DEFAULT_POOL = 0x00100000, // Nvidia Stereo Change: Water (Force a texture to the default pool)

	TEXTUREFLAGS_COMBINED = 0x00200000,

	TEXTUREFLAGS_ASYNC_DOWNLOAD = 0x00400000,

	TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,

	TEXTUREFLAGS_SKIP_INITIAL_DOWNLOAD = 0x01000000, // Skip initial download when creating a procedural texture

	TEXTUREFLAGS_CLAMPU = 0x02000000,
	TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,	// Usable as a vertex texture
	TEXTUREFLAGS_SSBUMP = 0x08000000,

	TEXTUREFLAGS_MOST_MIPS = 0x10000000, // Don't load the bottom few mips at runtime

	TEXTUREFLAGS_BORDER = 0x20000000,	// Clamp to border color on all texture coordinates

#if defined( _PS3 ) || defined SPU
	// PS3 extensions
	TEXTUREFLAGS_QUINCUNX = 0x40000000,
	TEXTUREFLAGS_QUINCUNX_ALT = 0x80000000,
#elif defined( _X360 )
	TEXTUREFLAGS_ALIAS_COLOR_AND_DEPTH_SURFACES = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
#else
	TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
#endif
};
#pragma endregion

#pragma region clear_flags
enum ClearFlags_t
{
	VIEW_CLEAR_COLOR = 0x1,
	VIEW_CLEAR_DEPTH = 0x2,
	VIEW_CLEAR_FULL_TARGET = 0x4,
	VIEW_NO_DRAW = 0x8,
	VIEW_CLEAR_OBEY_STENCIL = 0x10, // Draws a quad allowing stencil test to clear through portals
	VIEW_CLEAR_STENCIL = 0x20,
};
#pragma endregion

#pragma region particles
enum ParticleAttachment_t
{
	PATTACH_ABSORIGIN = 0,			// Create at absorigin, but don't follow
	PATTACH_ABSORIGIN_FOLLOW,		// Create at absorigin, and update to follow the entity
	PATTACH_CUSTOMORIGIN,			// Create at a custom origin, but don't follow
	PATTACH_CUSTOMORIGIN_FOLLOW,	// Create at a custom origin, follow relative position to specified entity
	PATTACH_POINT,					// Create on attachment point, but don't follow
	PATTACH_POINT_FOLLOW,			// Create on attachment point, and update to follow the entity
	PATTACH_EYES_FOLLOW,			// Create on eyes of the attached entity, and update to follow the entity
	PATTACH_OVERHEAD_FOLLOW,		// Create at the top of the entity's bbox
	PATTACH_WORLDORIGIN,			// Used for control points that don't attach to an entity
	PATTACH_ROOTBONE_FOLLOW,		// Create at the root bone of the entity, and update to follow

	MAX_PATTACH_TYPES,
};
#pragma endregion

#pragma region data_update_type
enum DataUpdateType_t
{
	DATA_UPDATE_CREATED = 0,	// indicates it was created +and+ entered the pvs
//	DATA_UPDATE_ENTERED_PVS,
	DATA_UPDATE_DATATABLE_CHANGED,
//	DATA_UPDATE_LEFT_PVS,
//	DATA_UPDATE_DESTROYED,		// FIXME: Could enable this, but it's a little worrying
								// since it changes a bunch of existing code
};
#pragma endregion

#pragma region preciptation
enum PrecipitationType_t
{
	PRECIPITATION_TYPE_RAIN = 0,
	PRECIPITATION_TYPE_SNOW,
	PRECIPITATION_TYPE_ASH,
	PRECIPITATION_TYPE_SNOWFALL,
	PRECIPITATION_TYPE_PARTICLERAIN,
	PRECIPITATION_TYPE_PARTICLEASH,
	PRECIPITATION_TYPE_PARTICLERAINSTORM,
	PRECIPITATION_TYPE_PARTICLESNOW,
	NUM_PRECIPITATION_TYPES
};
#pragma endregion

#pragma region team_ids
enum TeamID
{
	/*TEAM_UNASSIGNED,
	TEAM_SPECTATOR,
	TEAM_TERRORIST,
	TEAM_COUNTER_TERRORIST,*/
	None,
	Spectactor,
	Terrorist,
	Counter_Terrorist
};
#pragma endregion

#pragma region think_methods
enum thinkmethods_t
{
	THINK_FIRE_ALL_FUNCTIONS,
	THINK_FIRE_BASE_ONLY,
	THINK_FIRE_ALL_BUT_BASE,
};
#pragma endregion

#pragma region ent_flags
// entity flags, CBaseEntity::m_iEFlags
enum
{
	EFL_KILLME = (1 << 0),	// This entity is marked for death -- This allows the game to actually delete ents at a safe time
	EFL_DORMANT = (1 << 1),	// Entity is dormant, no updates to client
	EFL_NOCLIP_ACTIVE = (1 << 2),	// Lets us know when the noclip command is active.
	EFL_SETTING_UP_BONES = (1 << 3),	// Set while a model is setting up its bones.
	EFL_KEEP_ON_RECREATE_ENTITIES = (1 << 4), // This is a special entity that should not be deleted when we restart entities only

	EFL_DIRTY_SHADOWUPDATE = (1 << 5),	// Client only- need shadow manager to update the shadow...
	EFL_NOTIFY = (1 << 6),	// Another entity is watching events on this entity (used by teleport)

	// The default behavior in ShouldTransmit is to not send an entity if it doesn't
	// have a model. Certain entities want to be sent anyway because all the drawing logic
	// is in the client DLL. They can set this flag and the engine will transmit them even
	// if they don't have a model.
	EFL_FORCE_CHECK_TRANSMIT = (1 << 7),

	EFL_BOT_FROZEN = (1 << 8),	// This is set on bots that are frozen.
	EFL_SERVER_ONLY = (1 << 9),	// Non-networked entity.
	EFL_NO_AUTO_EDICT_ATTACH = (1 << 10), // Don't attach the edict; we're doing it explicitly

	// Some dirty bits with respect to abs computations
	EFL_DIRTY_ABSTRANSFORM = (1 << 11),
	EFL_DIRTY_ABSVELOCITY = (1 << 12),
	EFL_DIRTY_ABSANGVELOCITY = (1 << 13),
	EFL_DIRTY_SURROUNDING_COLLISION_BOUNDS = (1 << 14),
	EFL_DIRTY_SPATIAL_PARTITION = (1 << 15),
	EFL_HAS_PLAYER_CHILD = (1 << 16),	// One of the child entities is a player.

	EFL_IN_SKYBOX = (1 << 17),	// This is set if the entity detects that it's in the skybox.
	// This forces it to pass the "in PVS" for transmission.
	EFL_USE_PARTITION_WHEN_NOT_SOLID = (1 << 18),	// Entities with this flag set show up in the partition even when not solid
	EFL_TOUCHING_FLUID = (1 << 19),	// Used to determine if an entity is floating

	// FIXME: Not really sure where I should add this...
	EFL_IS_BEING_LIFTED_BY_BARNACLE = (1 << 20),
	EFL_NO_ROTORWASH_PUSH = (1 << 21),		// I shouldn't be pushed by the rotorwash
	EFL_NO_THINK_FUNCTION = (1 << 22),
	EFL_NO_GAME_PHYSICS_SIMULATION = (1 << 23),

	EFL_CHECK_UNTOUCH = (1 << 24),
	EFL_DONTBLOCKLOS = (1 << 25),		// I shouldn't block NPC line-of-sight
	EFL_DONTWALKON = (1 << 26),		// NPC;s should not walk on this entity
	EFL_NO_DISSOLVE = (1 << 27),		// These guys shouldn't dissolve
	EFL_NO_MEGAPHYSCANNON_RAGDOLL = (1 << 28),	// Mega physcannon can't ragdoll these guys.
	EFL_NO_WATER_VELOCITY_CHANGE = (1 << 29),	// Don't adjust this entity's velocity when transitioning into water
	EFL_NO_PHYSCANNON_INTERACTION = (1 << 30),	// Physcannon can't pick these up or punt them
	EFL_NO_DAMAGE_FORCES = (1 << 31),	// Doesn't accept forces from physics damage
};
#pragma endregion

#pragma region id_view
// This identifies the view for certain systems that are unique per view (e.g. pixel visibility)
// NOTE: This is identifying which logical part of the scene an entity is being redered in
// This is not identifying a particular render target necessarily.  This is mostly needed for entities that
// can be rendered more than once per frame (pixel vis queries need to be identified per-render call)
enum view_id_t
{
	VIEW_ILLEGAL = -2,
	VIEW_NONE = -1,
	VIEW_MAIN = 0,
	VIEW_3DSKY = 1,
	VIEW_MONITOR = 2,
	VIEW_REFLECTION = 3,
	VIEW_REFRACTION = 4,
	VIEW_INTRO_PLAYER = 5,
	VIEW_INTRO_CAMERA = 6,
	VIEW_SHADOW_DEPTH_TEXTURE = 7,
	VIEW_SSAO = 8,
	VIEW_ID_COUNT
};
#pragma endregion

#pragma region skybox_vis_flags
//-----------------------------------------------------------------------------
// Skybox visibility
//-----------------------------------------------------------------------------
enum SkyboxVisibility_t
{
	SKYBOX_NOT_VISIBLE = 0,
	SKYBOX_3DSKYBOX_VISIBLE,
	SKYBOX_2DSKYBOX_VISIBLE,
};
#pragma endregion
```

`hack/SDK/IBaseClientDll.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class ClientClass;

class IBaseClientDLL
{
public:
	VFUNC(ClientClass*, getAllClasses, 8, (), (this));
	VFUNC(bool, dispatchUserMsg, 38, (int msgType, size_t arg1, size_t length, const void* data = nullptr), (this, msgType, arg1, length, data));
};
```

`hack/SDK/IBaseFileSystem.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"
#include "CutlBuffer.hpp"

class IBaseFileSystem
{
public:
	VFUNC(int, read, 0, (void* out, int size, void* file), (this, out, size, file));
	VFUNC(int, write, 0, (void* const in, int size, void* file), (this, in, size, file));
	VFUNC(void*, open, 2, (const char* file, const char* options, const char* path), (this, file, options, path));
	VFUNC(void, close, 3, (void* file), (this, file));
	VFUNC(int, size, 7, (void* file), (this, file));
	VFUNC(bool, writeFile, 15, (const char* name, const char* path, CUtlBuffer& buffer), (this, name, path, buffer));
};
```

`hack/SDK/IClientEntityList.hpp`:

```hpp
#pragma once

#include "EHandle.hpp"
#include "helpers/vfunc.hpp"

class IClientEntityList
{
public:
	VFUNC(void*, getClientEntity, 3, (int index), (this, index));
	VFUNC(void*, getClientFromHandle, 4, (CBaseHandle handle), (this, handle.handle));
	VFUNC(int, numberOfEntites, 5, (bool includeNonNetw), (this, includeNonNetw));
	VFUNC(int, getHighestIndex, 6, (), (this));
	VFUNC(void, setMaxEntites, 7, (int num), (this, num));
	VFUNC(int, getMaxEntities, 8, (), (this));
};
```

`hack/SDK/IClientState.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"

class INetChannel;
class IClientState
{
	PAD(156);
	INetChannel* m_netChannel;
	PAD(212);
	int m_deltaTick;
	PAD(19380);
	int m_lastOutGoingCommand;
	int m_chockedCommands;
	int m_lastCommandAck;
	int m_commandAck;
};
```

`hack/SDK/ICollideable.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "math/matrix.hpp"

#include "helpers/vfunc.hpp"

class IPhysicsObject;

class ICollideable
{
public:
	VFUNC(Vec3&, OBBMins, 1, (), (this));
	VFUNC(Vec3&, OBBMaxs, 2, (), (this));
	VFUNC(Vec3&, getCollisionAngles, 9, (), (this));
	VFUNC(Matrix3x4&, collisionToWorldTransform, 10, (), (this));
	VFUNC(int, getSolid, 11, (), (this));
	VFUNC(int, getSolidFlags, 12, (), (this));
	VFUNC(IPhysicsObject*, getPhysicsObject, 18, (), (this));
};
```

`hack/SDK/ICvar.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IConVar;
struct SDKColor;

class ConCommandBase
{
public:
	VFUNC(bool, isFlagSet, 2, (int flag), (this, flag));
	VFUNC(void, addFlags, 3, (int flags), (this, flags));
	VFUNC(void, removeFlags, 4, (int flags), (this, flags));
	VFUNC(int, getFlags, 5, (), (this));
	VFUNC(ConCommandBase*, next, 9, (), (this));
	
	ConCommandBase* m_next;
	int m_registerted : 1;
	int oldFlags : 31;
	const char* name;
	const char* helper;
	int flags;
private:
	void* clb;
};

class ICvar
{
public:
	VFUNC(IConVar*, findVar, 15, (const char* name), (this, name));
	VFUNC(ConCommandBase*, findCommand, 17, (const char* name), (this, name));
	template <typename... Args_t>
	void consoleColorPrintf(const SDKColor& clr, const char* fmt, Args_t... args)
	{
		return vfunc::callVPack<void, 25, const SDKColor&, const char*, Args_t...>(this, std::cref(clr), fmt, args...);
	}
	template<typename... Args_t>
	void consolePrintf(const char* fmt, Args_t... args)
	{
		return vfunc::callVPack<void, 26, const char*, Args_t...>(this, fmt, args...);
	}

	class ICVarIteratorInternal
	{
	public:
		VFUNC(void, setFirst, 0, (), (this));
		VFUNC(void, next, 1, (), (this));
		VFUNC(bool, isValid, 2, (), (this));
		VFUNC(ConCommandBase*, get, 3, (), (this));
	};
	VFUNC(ICVarIteratorInternal*, factoryInternalIterator, 45, (), (this));
};
```

`hack/SDK/IEffects.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "helpers/vfunc.hpp"

class IEffects
{
public:
	VFUNC(void, beam, 1,
		(const Vec3& start, const Vec3& end, int modelIndex,
			int haloIndex, unsigned char frameStart, unsigned char frameRate,
			float life, unsigned char width, unsigned char endWidth, unsigned char fadeLength,
			unsigned char noise, unsigned char red, unsigned char green,
			unsigned char blue, unsigned char brightness, unsigned char speed),
		(this, std::cref(start), std::cref(end), modelIndex, haloIndex, frameStart, frameRate, life, width, endWidth, fadeLength, noise, red, green, blue, brightness, speed)
	);

	//-----------------------------------------------------------------------------
	// Purpose: Emits smoke sprites.
	// Input  : origin - Where to emit the sprites.
	//			scale - Sprite scale * 10.
	//			framerate - Framerate at which to animate the smoke sprites.
	//-----------------------------------------------------------------------------
	VFUNC(void, smoke, 2, (const Vec3& origin, int modelIndex, float scale, float framerate), (this, std::cref(origin), modelIndex, scale, framerate));
	VFUNC(void, sparks, 3, (const Vec3& position, int magnitude = 1, int trialLength = 1, const Vec3* pvecDir = NULL), (this, std::cref(position), magnitude, trialLength, pvecDir));
	VFUNC(void, dust, 4, (const Vec3& pos, const Vec3& dir, float size, float speed), (this, std::cref(pos), std::cref(dir), size, size, speed));
	VFUNC(void, muzzleFlash, 5, (const Vec3& vecOrigin, const Vec3& vecAngles, float scale, int type), (this, std::cref(vecOrigin), std::cref(vecAngles), scale, type));
	// like ricochet, but no sound
	VFUNC(void, metalSparks, 6, (const Vec3& position, const Vec3& direction), (this, std::cref(position), std::cref(direction)));
	VFUNC(void, energySplash, 7, (const Vec3& position, const Vec3& direction, bool explosive = false), (this, std::cref(position), std::cref(direction), explosive));
	VFUNC(void, ricochet, 8, (const Vec3& position, const Vec3& direction), (this, std::cref(position), std::cref(direction)));

	// if you want to mess with effects abit then add dispatch, I will probably never need it
};
```

`hack/SDK/IEngineSound.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"
#include "vars.hpp"

enum SoundFlags_t
{
	SND_NOFLAGS = 0,			// to keep the compiler happy
	SND_CHANGE_VOL = (1 << 0),		// change sound vol
	SND_CHANGE_PITCH = (1 << 1),		// change sound pitch
	SND_STOP = (1 << 2),		// stop the sound
	SND_SPAWNING = (1 << 3),		// we're spawning, used in some cases for ambients
	// not sent over net, only a param between dll and server.
	SND_DELAY = (1 << 4),		// sound has an initial delay
	SND_STOP_LOOPING = (1 << 5),		// stop all looping sounds on the entity.
	SND_SPEAKER = (1 << 6),		// being played again by a microphone through a speaker

	SND_SHOULDPAUSE = (1 << 7),		// this sound should be paused if the game is paused
	SND_IGNORE_PHONEMES = (1 << 8),
	SND_IGNORE_NAME = (1 << 9),		// used to change all sounds emitted by an entity, regardless of scriptname
	SND_IS_SCRIPTHANDLE = (1 << 10),		// server has passed the actual SoundEntry instead of wave filename

	SND_UPDATE_DELAY_FOR_CHOREO = (1 << 11),		// True if we have to update snd_delay_for_choreo with the IO latency.
	SND_GENERATE_GUID = (1 << 12),		// True if we generate the GUID when we send the sound.

	SND_OVERRIDE_PITCH = (1 << 13),		// The pitch given in code overrides what is present in the sound entry.
};

#define SND_FLAG_BITS_ENCODE 13

#define MAX_SOUND_INDEX_BITS	13
#define	MAX_SOUNDS				(1<<MAX_SOUND_INDEX_BITS)

// Todo: Morasky, we need to test against this #!
// MAX_MEASURED_SOUNDENTRIES

#if !defined( IN_XBOX_CODELINE )
// +/-4096 msec
#define MAX_SOUND_DELAY_MSEC_ENCODE_BITS	(13)
#else
// +/-65536 msec, 64 seconds
#define MAX_SOUND_DELAY_MSEC_ENCODE_BITS	(17)
#endif

// Subtract one to leave room for the sign bit
#define MAX_SOUND_DELAY_MSEC				(1<<(MAX_SOUND_DELAY_MSEC_ENCODE_BITS-1))    // 4096 msec or about 4 seconds

#define MAX_SOUND_SEED_BITS		6	// Used to encode 0-63 for seeding client side sound operators
									// NOTE: The LSB also carries the server side wave file selection
#define MIN_SOUND_SEED_VALUE	0
#define MAX_SOUND_SEED_VALUE	((1<<MAX_SOUND_SEED_BITS)-1)
#define MAX_SOUND_RNDWAVE_NUM	MAX_SOUND_SEED_VALUE

//-----------------------------------------------------------------------------
// common pitch values
//-----------------------------------------------------------------------------
#define	PITCH_NORM		100			// non-pitch shifted
#define PITCH_LOW		95			// other values are possible - 0-255, where 255 is very high
#define PITCH_HIGH		120

#define DEFAULT_SOUND_PACKET_VOLUME 1.0f
#define DEFAULT_SOUND_PACKET_PITCH	100
#define DEFAULT_SOUND_PACKET_DELAY	0.0f

//-----------------------------------------------------------------------------
// channels
//-----------------------------------------------------------------------------
enum
{
	CHAN_REPLACE = -1,
	CHAN_AUTO = 0,
	CHAN_WEAPON = 1,
	CHAN_VOICE = 2,
	CHAN_ITEM = 3,
	CHAN_BODY = 4,
	CHAN_STREAM = 5,		// allocate stream channel from the static or dynamic area
	CHAN_STATIC = 6,		// allocate channel from the static area 
	CHAN_VOICE_BASE = 7,		// allocate channel for network voice data
};

enum
{
	CHAN_USER_BASE = (CHAN_VOICE_BASE + 128)		// Anything >= this number is allocated to game code.
};

typedef unsigned int HSOUNDSCRIPTHASH;
#define SOUNDEMITTER_INVALID_HASH	(HSOUNDSCRIPTHASH)-1

class IEngineSound
{
public:
	VFUNC(void, stopSound, 8, (int entIndex, int channel, const char* sample, unsigned int soundEntryHash), (this, entIndex, channel, sample, soundEntryHash));
	VFUNC(void, emitAmbientSound, 12, (const char* sample, float volume, int pitch = PITCH_NORM, int flags = 0, float soundTime = 0.0f),
		(this, sample, volume, pitch, flags, soundTime));
};
```

`hack/SDK/IEngineTrace.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "math/VectorAligned.hpp"
#include "math/matrix.hpp"
#include "math/AABB.hpp"
#include "Enums.hpp"
#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

#pragma warning(disable: 26495)

class Player_t;

class Ray_t
{
public:
	VectorAligned m_start;
	VectorAligned m_delta;
	VectorAligned m_startOffset;
	VectorAligned m_extents;
	const Matrix3x4* m_mattrixWorldAxis;
	bool m_isRay{};
	bool m_isSwept{};

	Ray_t() = default;
	Ray_t(const Vec3& src, const Vec3& dest) :
		m_start{ src }, m_delta{ dest - src }, m_mattrixWorldAxis{ nullptr }, m_isRay{ true }
	{
		m_isSwept = m_delta.lengthSqrt();
	}
	Ray_t(const Vec3& src, const Vec3& dest, const Vec3& min, const Vec3& max)
	{
		m_delta = (dest - src);

		m_mattrixWorldAxis = nullptr;
		m_isSwept = m_delta.lengthSqrt();

		m_extents = max - min;
		m_extents *= 0.5f;
		m_isRay = m_extents.lengthSqrt() < 1e-6f;

		m_startOffset = min + max;
		m_startOffset *= 0.5f;
		m_start = src + m_startOffset;
		m_startOffset *= -1.0f;
	}
};

struct Csurface_t
{
	const char* m_name;
	short m_props;
	unsigned short m_flags;
};

struct Cplane_t
{
	Vec3 m_normal;
	float m_distance;
	char m_type;
	char m_signBits;
	PAD(2);
};

struct Trace_t
{
	Vec3 m_start;
	Vec3 m_end;
	Cplane_t m_plane;
	float m_fraction;
	int m_contents;
	unsigned short m_flags;
	bool m_allSolid;
	bool m_startSolid;
	float m_fractionLeftSolid;
	Csurface_t m_surface;
	int m_hitgroup;
	short m_physicsBone;
	Player_t* m_entity;
	int m_hitbox;

	bool didHit() const
	{
		return m_fraction < 1.0f || m_allSolid || m_startSolid;
	}
};

class TraceFilter
{
public:
	TraceFilter() = default;
	TraceFilter(void* entity) :
		m_skip{ entity }
	{}
	TraceFilter(void* entity, CollisionGroup_t group) :
		m_skip{ entity }, m_collisionGroup{ group }
	{}
	virtual bool shouldHitEntity(Player_t* ent, int) const
	{
		return ent != m_skip;
	}
	virtual int getTraceType() const
	{
		return m_collisionGroup;
	}
	void* m_skip;
	CollisionGroup_t m_collisionGroup = COLLISION_GROUP_NONE;
};

class IEngineTrace
{
public:
	VFUNC(int, getPointContents, 0, (const Vec3& absPosition, int contentsMask), (this, std::cref(absPosition), contentsMask, nullptr));
	VFUNC(void, traceRay, 5, (const Ray_t& ray, unsigned int mask, TraceFilter* filter, Trace_t* trace), (this, std::cref(ray), mask, filter, trace));
	VFUNC(bool, isFullyOccluded, 26, (int occlusionKey, const AABB_t& from, const AABB_t& to, const Vec3& shadow), (this, occlusionKey, std::cref(from), std::cref(to), std::cref(shadow)));
};
```

`hack/SDK/IGameEvent.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IGameEvent
{
public:
    VFUNC(const char*, getName, 1, (), (this));
    VFUNC(int, getInt, 6, (const char* keyName, int defaultValue = 0), (this, keyName, defaultValue));
    VFUNC(float, getFloat, 8, (const char* keyName, float defaultValue = 0.0f), (this, keyName, defaultValue));
    VFUNC(const char*, getString, 9, (const char* keyName, const char* defaultValue = ""), (this, keyName, defaultValue));
    VFUNC(void, setInt, 13, (const char* keyName, int value), (this, keyName, value));
    VFUNC(void, setString, 16, (const char* keyName, const char* value), (this, keyName, value));
};

class IGameEventListener
{
public:
    virtual ~IGameEventListener() {}

    virtual void fireGameEvent(IGameEvent* event) = 0;
    virtual int getEventDebugID(void) { return 42; };
};

class IGameEventManager
{
public:
    VFUNC(bool, addListener, 3, (IGameEventListener* listener, const char* name), (this, listener, name, false));
    VFUNC(void, removeListener, 5, (IGameEventListener* listener), (this, listener));
};

```

`hack/SDK/ILocalize.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class ILocalize
{
public:
	VFUNC(wchar_t*, findSafe, 12, (const char* name), (this, name));
	VFUNC(const char*, findAsUTF8, 47, (const char* tokenName), (this, tokenName));
};

```

`hack/SDK/IMDLCache.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IMDLCache
{
public:
	VFUNC(void, beginLock, 33, (), (this));
	VFUNC(void, endLock, 34, (), (this));
};

class CMDLCacheCriticalSection
{
public:
	CMDLCacheCriticalSection(IMDLCache* cache)
		: cache{ cache }
	{
		this->cache->beginLock();
	}

	~CMDLCacheCriticalSection()
	{
		cache->endLock();
	}
private:
	IMDLCache* cache;
};

#define MDLCACHE_CRITICAL_SECTION(cache) CMDLCacheCriticalSection cacheCriticalSection(cache)
```

`hack/SDK/IMatRenderContext.cpp`:

```cpp
#include "IMatRenderContext.hpp"

#include "math/Rect.hpp"
#include "interfaces/interfaces.hpp"
#include "IMaterialSystem.hpp"
#include <cheats/game/globals.hpp>
#include "PixEvent.hpp"

void IMatRenderContext::drawScreenEffectMaterial(IMaterial* material)
{
	/*int v11;
	__asm 
	{
		mov eax, [ebp - 10h]
		mov v11, eax
	}
	int v12;
	__asm
	{
		mov eax, [ebp - 12h]
		mov v12, eax
	}*/
	
	// v11 = height
	// v12 = width

	const static auto _call = memory::drawScreenEffectMaterial();
	__asm
	{
		push globals::screenY; v11
		xor edx, edx
		mov ecx, edi
		push globals::screenX; v12
		push 0
		xor edx, edx
		mov ecx, material
		call _call
		/*mov ecx, [esi]*/
		add esp, 12
	}
}
```

`hack/SDK/IMatRenderContext.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"
#include "stencil.hpp"

#include "math/Rect.hpp"

class ITexture;
class IMaterial;

enum MaterialMatrixMode_t
{
    MATERIAL_VIEW = 0,
    MATERIAL_PROJECTION,

    MATERIAL_MATRIX_UNUSED0,
    MATERIAL_MATRIX_UNUSED1,
    MATERIAL_MATRIX_UNUSED2,
    MATERIAL_MATRIX_UNUSED3,
    MATERIAL_MATRIX_UNUSED4,
    MATERIAL_MATRIX_UNUSED5,
    MATERIAL_MATRIX_UNUSED6,
    MATERIAL_MATRIX_UNUSED7,

    MATERIAL_MODEL,

    // Total number of matrices
    NUM_MATRIX_MODES = MATERIAL_MODEL + 1,
};

class IMatRenderContext
{
public:
    VFUNC(int, release, 1, (), (this));
    VFUNC(void, setRenderTarget, 6, (ITexture* texture), (this, texture));
    VFUNC(void, pushRenderTargetAndViewport, 119, (), (this));
    VFUNC(void, popRenderTargetAndViewport, 120, (), (this));
    VFUNC(void, drawScreenSpaceRectangle, 114,
        (IMaterial* material,
        int destX, int destY, int width, int height,
        float srcTextureX0, float srcTextureY0, float srcTextureX1, float srcTextureY1,
        int srcTextureWidth, int srcTextureHeight,
        void* clientRenderable = nullptr, int nXDice = 1, int nYDice = 1
        ), (this, material, destX, destY, width, height,
            srcTextureX0, srcTextureY0, srcTextureX1, srcTextureY1,
            srcTextureWidth, srcTextureHeight, clientRenderable, nXDice, nYDice));
    VFUNC(void, overrideDepthEnable, 80, (bool enable, bool depthWrite, bool depthTestEnable = true), (this, enable, depthWrite, depthTestEnable));
    VFUNC(void, setStencilState, 128, (const ShaderStencilState_t& state), (this, std::cref(state)));
    VFUNC(void, setRenderTargetEx, 130, (int id, ITexture* texture), (this, id, texture));
    VFUNC(void, beginPIXEvent, 144, (unsigned long color, const char* name), (this, color, name));
    VFUNC(void, endPIXEvent, 145, (), (this));
    VFUNC(void, viewport, 40, (int x, int y, int width, int height), (this, x, y, width, height));
    VFUNC(void, getViewport, 41, (int& x, int& y, int& width, int& height), (this, std::ref(x), std::ref(y), std::ref(width), std::ref(height)));
    VFUNC(void, clearColor3ub, 78, (unsigned char r, unsigned char g, unsigned char b), (this, r, g, b));
    VFUNC(void, clearColor4ub, 79, (unsigned char r, unsigned char g, unsigned char b, unsigned char a), (this, r, g, b, a));
    VFUNC(void, depthRange, 11, (float zNear, float zFar), (this, zNear, zFar));
    VFUNC(void, clearBuffers, 12, (bool clearColor, bool clearDepth, bool clearStencil = false), (this, clearColor, clearDepth, clearStencil));
    VFUNC(void, overrideAlphaWriteEnable, 195, (bool overrideEnable, bool alphaWriteEnable), (this, overrideEnable, alphaWriteEnable));
    VFUNC(void, overrideColorWriteEnable, 196, (bool overrideEnable, bool alphaWriteEnable), (this, overrideEnable, alphaWriteEnable));
    VFUNC(void, copyRenderTargetToTexture, 19, (ITexture* texture), (this, texture));
    VFUNC(void, bind, 9, (IMaterial* material, void* proxy = nullptr), (this, material, proxy));
    VFUNC(void, matrixMode, 22, (MaterialMatrixMode_t mode), (this, mode));
    VFUNC(void, pushMatrix, 23, (), (this));
    VFUNC(void, popMatrix, 24, (), (this));
    VFUNC(void, loadIdentity, 33, (), (this));
    VFUNC(void, ortho, 34, (double left, double top, double right, double bottom, double zNear, double zFar), (this, left, top, right, bottom, zNear, zFar));
    VFUNC(void, scale, 39, (float x, float y, float z), (this, x, y, z));
    VFUNC(void, copyRenderTargetToTextureEx, 123, (int renderTargetID, ITexture* texture, Rect_t* srcRect, Rect_t* dstRect = nullptr), 
        (this, renderTargetID, texture, srcRect, dstRect));

    void disableStencil()
    {
        ShaderStencilState_t stencilState;
        stencilState.m_bEnable = false;
        this->setStencilState(stencilState);
    }

    // custom
    void drawScreenEffectMaterial(IMaterial* material);
};
```

`hack/SDK/IMaterialInternal.hpp`:

```hpp
#pragma once

#include "material.hpp"

class IMaterialInternal : public IMaterial
{

};
```

`hack/SDK/IMaterialSystem.hpp`:

```hpp
#pragma once

#include "material.hpp"
#include "Enums.hpp"
#include "vars.hpp"

#include "helpers/vfunc.hpp"
#include <gamememory/memory.hpp>

class IMaterial;
class KeyValues;
class IMatRenderContext;
class ITexture;

// we can make some leak, but enabling the allocation here might make a lag
// game inits it always before the game, not a big deal to just see an error
//#define DONT_IGNORE_MATSYS_ALLOCATION_ERRORS

class IMaterialSystem
{
public:
	VFUNC(IMaterial*, createMaterial, 83, (const char* materialName, KeyValues* keyValues), (this, materialName, keyValues));
	VFUNC(IMaterial*, findMaterial, 84, (char const* name, const char* group, bool complain = true, const char* prefix = nullptr), (this, name, group, complain, prefix));
	VFUNC(short, firstMaterial, 86, (), (this));
	VFUNC(short, nextMaterial, 87, (int handle), (this, handle));
	VFUNC(short, invalidMaterialFromHandle, 88, (), (this));
	VFUNC(IMaterial*, getMaterial, 89, (short handle), (this, handle));
	VFUNC(int, getMaterialCount, 90, (), (this));
	VFUNC(ITexture*, findTexture, 91, (const char* name, const char* group, bool complain = true, int additionalFlags = 0),
		(this, name, group, complain, additionalFlags));
	VFUNC(IMatRenderContext*, getRenderContext, 115, (), (this));
	VFUNC(void, beginRenderTargetAllocation, 94, (), (this));
	VFUNC(void, endRenderTargetAllocation, 95, (), (this));
	VFUNC(ITexture*, createNamedRenderTargetTextureEx, 97,
		(const char* name, int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat format,
			MaterialRenderTargetDepth_t depth, unsigned int textureFlags, unsigned int renderTargetFlags),
		(this, name, w, h, sizeMode, format, depth, textureFlags, renderTargetFlags));

	ITexture* createFullFrameRenderTarget(const char* name)
	{
		return createNamedRenderTargetTextureEx(
			name, 1, 1, RT_SIZE_FULL_FRAME_BUFFER,
			IMAGE_FORMAT_RGB888, MATERIAL_RT_DEPTH_SHARED,
			TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT,
			CREATERENDERTARGETFLAGS_HDR);
	}
	VFUNC(ImageFormat, getBackBufferFormat, 36, (), (this));

	// https://www.unknowncheats.me/forum/counterstrike-global-offensive/234226-mirrorcam-ported-window.html

	void beginRenderTargetAllocationEx()
	{
#if defined DONT_IGNORE_MATSYS_ALLOCATION_ERRORS
		bool old = m_disableRenderTargetAllocationForever;
		m_disableRenderTargetAllocationForever = false;
#endif
		beginRenderTargetAllocation();
#if defined DONT_IGNORE_MATSYS_ALLOCATION_ERRORS
		m_disableRenderTargetAllocationForever = old;
#endif
	}

	void endRenderTargetAllocationEx()
	{
#if defined DONT_IGNORE_MATSYS_ALLOCATION_ERRORS
		bool old = m_disableRenderTargetAllocationForever;
		m_disableRenderTargetAllocationForever = false;
#endif
		endRenderTargetAllocation();
#if defined DONT_IGNORE_MATSYS_ALLOCATION_ERRORS
		m_disableRenderTargetAllocationForever = old;
#endif
	}

	void forceSingleThreaded()
	{
		memory::forceSingleThreaded()(this);
	}

	VFUNC(bool, allowThreading, 138, (bool enabled, int thread), (this, enabled, thread));

	PAD(11288);
	bool m_disableRenderTargetAllocationForever;
	PAD(40);
};
```

`hack/SDK/IMemAlloc.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IMemAlloc
{
public:
	VFUNC(void*, _alloc, 1, (size_t size), (this, size));
};
```

`hack/SDK/INetworkStringTableContainer.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"
#include "IVModelInfo.hpp"
#include "interfaces/interfaces.hpp"

#define INVALID_STRING_TABLE -1
const unsigned short INVALID_STRING_INDEX = (unsigned short)-1;

class INetworkStringTable
{
public:
	VFUNC(int, addString, 8, (bool isServer, const char* value, int length = -1, const void* userdata = nullptr), (this, isServer, value, length, userdata));
};

class INetworkStringTableContainer
{
public:
	VFUNC(INetworkStringTable*, findTable, 3, (const char* name), (this, name));
};

// https://www.unknowncheats.me/forum/counterstrike-global-offensive/214919-precache-models.html
inline bool precacheModel(const char* name)
{
	INetworkStringTable* table = memory::interfaces::clientStringTableContainer->findTable("modelprecache");

	if (table)
	{
		memory::interfaces::modelInfo->findOrLoadModel(name);

		int idx = table->addString(false, name);

		if (idx != INVALID_STRING_INDEX)
			return true;
	}
	return false;
}
```

`hack/SDK/IPanel.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IPanel
{
public:
	VFUNC(const char*, getName, 36, (unsigned int panel), (this, panel));
	VFUNC(void, setMouseInputEnabled, 32, (unsigned int panel, bool state), (this, panel, state));
};
```

`hack/SDK/IPhysicsCollision.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"
#include "IVModelInfo.hpp"

class IPhysicsCollision
{
public:
    VFUNC(void, vcollideLoad, 36, (vcollide_t* output, int solidCount, const char* buffer, int size, bool swap = false), (this, output, solidCount, buffer, size, swap));
    VFUNC(void, vcollideUnload, 37, (vcollide_t* collide), (this, collide));
};
```

`hack/SDK/IPhysicsObject.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"
#include "math/Vector.hpp"

class IPhysicsObject
{
public:
	VFUNC(void, getVelocity, 52, (Vec3* velocity, Vec3* angularVelocity), (this, velocity, angularVelocity));
};
```

`hack/SDK/IPhysicsSurfaceProps.hpp`:

```hpp
#pragma once

class IPhysicsSurfaceProps;
```

`hack/SDK/IPrediction.cpp`:

```cpp
#include "IPrediction.hpp"

#include <gamememory/memory.hpp>

void IPrediction::shutdownPredictables()
{
	memory::shutdownPredicatbles()();
}

int IPrediction::reinitPredictables()
{
	return memory::reinitPredicatbles()();
}
```

`hack/SDK/IPrediction.hpp`:

```hpp
#pragma once

#include "CUserCmd.hpp"
#include "math/Vector.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

class Player_t;

class IMoveHelper
{
public:
	VFUNC(void, setHost, 1, (Player_t* host), (this, host));
	VFUNC(void, processImpacts, 4, (), (this));
};

class CMoveData
{
public:
	bool m_firstRunOfFunctions;
	bool m_gameCodeMovedPlayer;
	int m_playerHandle;
	int m_impulseCommand;
	Vec3 m_viewAngles;
	Vec3 m_absViewAngles;
	int m_buttons;
	int m_oldButtons;
	float m_forwardMove;
	float m_sideMove;
	float m_upMove;
	float m_maxSpeed;
	float m_clientMaxSpeed;
	Vec3 m_velocity;
	Vec3 m_angles;
	Vec3 m_oldAngles;
	float m_outStepHeight;
	Vec3 m_outWishVel;
	Vec3 m_outJumpVel;
	Vec3 m_constraintCenter;
	float m_constraintRadius;
	float m_constraintWidth;
	float m_constraintSpeedFactor;
	PAD(20);
	Vec3 m_absOrigin;
};

class IPrediction
{
public:
	VFUNC(void, update, 3, (int startframe, bool validframe, int incomingAcknowledged, int outgoingCommand),
		(this, startframe, validframe, incomingAcknowledged, outgoingCommand));
	VFUNC(void, setLocalViewangles, 13, (Vec3& angle), (this, std::ref(angle)));
	VFUNC(bool, inPrediction, 14, (), (this));
	VFUNC(bool, checkMovingGround, 18, (Player_t* player, double frameTime), (this, player, frameTime));
	VFUNC(void, setupMove, 20, (Player_t* localPlayer, CUserCmd* cmd, IMoveHelper* moveHelper, CMoveData* moveData), (this, localPlayer, cmd, moveHelper, moveData));
	VFUNC(void, finishMove, 21, (Player_t* localPlayer, CUserCmd* cmd, CMoveData* moveData), (this, localPlayer, cmd, moveData));
	void shutdownPredictables();
	int reinitPredictables();

	PAD(8);
	bool m_inPrediction;
	bool m_oldCLPredictValue;
	bool m_firstTimePredicted;
	bool m_enginePaused;
	PAD(13);
	int m_commandsPredicted;
	PAD(4);
	int m_previousAckHadErrors;
};

```

`hack/SDK/ISurface.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include <render/Color.hpp>

#include "helpers/vfunc.hpp"

struct Vertex_t
{
	Vertex_t() = default;
	constexpr Vertex_t(const Vec2& pos, const Vec2& coord = Vec2{})
		: m_Position{ pos }, m_TexCoord{ coord }
	{}

	Vec2 m_Position;
	Vec2 m_TexCoord;
};

class ISurface
{
public:
	VFUNC(void, pushMakeCurrent, 12, (unsigned long panel, bool useInsets), (this, panel, useInsets));
	VFUNC(void, popMakeCurrent, 13, (unsigned long panel), (this, panel));
	VFUNC(void, drawSetColor, 14, (SDKColor color), (this, color));
	VFUNC(void, setTextColor, 24, (SDKColor color), (this, color));
	VFUNC(void, drawTexturedPolygon, 106, (int n, Vertex_t* vertice, bool clip = true), (this, n, vertice, clip));
	VFUNC(void, drawFilledRectangle, 16, (int x, int y, int w, int h), (this, x, y, x + w, y + h));
	VFUNC(void, drawSetTexture, 38, (int id), (this, id));
	VFUNC(void, setTextureRGBA, 37, (int id, const unsigned char* rgba, int wide, int tall), (this, id, rgba, wide, tall));
	VFUNC(void, setTextureRGBA, 37, (int id, Color* rgba, int wide, int tall), (this, id, rgba, wide, tall));
	VFUNC(int, createNewTextureID, 43, (bool procedural = false), (this, procedural));
	VFUNC(bool, deleteTextureID, 39, (int id), (this, id));
	VFUNC(void, drawOutlinedRect, 18, (int x, int y, int w, int h), (this, x, y, x + w, y + h));
	VFUNC(void, drawLine, 19, (int x1, int y1, int x2, int y2), (this, x1, y1, x2, y2));
	VFUNC(void, drawPolyLine, 20, (int* px, int* py, int numPoints), (this, px, py, numPoints));
	VFUNC(void, drawTextFont, 23, (unsigned long font), (this, font));
	VFUNC(void, drawTextPos, 26, (int x, int y), (this, x, y));
	VFUNC(void, drawRenderText, 28, (const wchar_t* text, int textLen), (this, text, textLen, 0));
	VFUNC(unsigned long, fontCreate, 71, (), (this));
	VFUNC(void, setFontGlyph, 72, (unsigned long font, const char* windowsFontName, int tall, int weight, int blur, int scanlines, int flags),
		(this, font, windowsFontName, tall, weight, blur, scanlines, flags, 0, 0));
	VFUNC(void, getTextSize, 79, (unsigned long font, const wchar_t* text, int& wide, int& tall),
		(this, font, text, std::ref(wide), std::ref(tall)));
	VFUNC(void, unlockCursor, 66, (), (this));
	VFUNC(void, setClipRect, 147, (int x, int y, int w, int h), (this, x, y, w, h));
	VFUNC(void, drawFilledFadeRect, 123, (int x, int y, int w, int h, unsigned int alpha1, unsigned int alpha2, bool horizontal),
		(this, x, y, x + w, y + h, alpha1, alpha2, horizontal));
	VFUNC(void, drawColorText, 163, (unsigned long font, int x, int y, Color col, int alpha, const char* text),
		(this, font, x, y, col, alpha, text));
	VFUNC(void, getScreenSize, 44, (int& width, int& height),
		(this, std::ref(width), std::ref(height)));
	VFUNC(void, drawOutlinedCircle, 103, (int x, int y, int radius, int points), (this, x, y, radius, points));
	VFUNC(void, drawTextureFromName, 36, (int id, const char* name, int filter, bool reload = 0), (this, id, name, filter, reload));
	VFUNC(void, getCursor, 100, (int& x, int& y), (this, std::ref(x), std::ref(y)));
	VFUNC(void, drawTexturedRect, 41, (int x, int y, int width, int height), (this, x, y, width, height));
	VFUNC(void, playSound, 82, (const char* name), (this, name));
	VFUNC(bool, isTextureValid, 42, (int id), (this, id));
};
```

`hack/SDK/ITexture.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

struct IDirect3DTexture9;

struct TextureHandle_t
{
	PAD(12);
	IDirect3DTexture9* m_texture;
};

class ITexture
{
public:
	VFUNC(int, getActualWidth, 3, (), (this));
	VFUNC(int, getActualHeight, 4, (), (this));
	void release()
	{
		if (!this)
		{
#ifdef _DEBUG
			printf("can't release texture, fatal err");
#endif
			return;
		}

		return vfunc::callVFunc<void, 11>(this);
	}
	PAD(80);
	TextureHandle_t** m_handle;
};
```

`hack/SDK/IVDebugOverlay.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

#include "helpers/vfunc.hpp"

class IVDebugOverlay
{
public:
	VFUNC(void, box, 2, (const Vec3& origin, const Vec3& mins, const Vec3& max, Vec3 const& orientation,
		int r, int g, int b, int a, float duration), (this, std::cref(origin), std::cref(mins), std::cref(max), std::cref(orientation), r, g, b, a, duration));
	VFUNC(bool, worldToScreen, 13, (const Vec3& in, Vec3& out), (this, std::cref(in), std::ref(out)));
};
```

`hack/SDK/IVEffects.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include <render/Color.hpp>

#include "helpers/vfunc.hpp"
#include "helpers/pad.hpp"

#define MAX_DLIGHTS 32

enum
{
	DLIGHT_NO_WORLD_ILLUMINATION = 0x1,
	DLIGHT_NO_MODEL_ILLUMINATION = 0x2,

	// NOTE: These two features are used to dynamically tweak the alpha on displacements
	// which is a special effect for selecting which texture to use. If 
	// we ever change how alpha is stored for displacements, we'll have to kill this feature
	DLIGHT_ADD_DISPLACEMENT_ALPHA = 0x4,
	DLIGHT_SUBTRACT_DISPLACEMENT_ALPHA = 0x8,
	DLIGHT_DISPLACEMENT_MASK = (DLIGHT_ADD_DISPLACEMENT_ALPHA | DLIGHT_SUBTRACT_DISPLACEMENT_ALPHA),
};

class DLight_t
{
private:
	struct DColor
	{
		DColor() = default;
		constexpr DColor(uint8_t _r, uint8_t _g, uint8_t _b)
			: r{ _r }, g{ _g }, b{ _b }
		{}
		constexpr DColor(const Color& clr)
			: r{ clr.rMultiplied() }, g{ clr.gMultiplied() }, b{ clr.bMultiplied() }
		{}

		uint8_t r, g, b;
	};
public:
	int m_flags;
	Vec3 m_origin;
	float m_radius;
	DColor m_color;
	char m_exponent;
	float m_die;
	float m_decay;
	float m_minlight;
	int m_key;
	int m_style;
	Vec3 m_direction;
	float m_innerAngle;
	float m_outerAngle;
	PAD(4);
};
static_assert(sizeof(DLight_t) == 68);

class IVEfx
{
public:
	VFUNC(DLight_t*, clAllocDLight, 4, (int key), (this, key));
	VFUNC(DLight_t*, clAllocElight, 5, (int key), (this, key));
	VFUNC(int, clGetActiveDlights, 6, (DLight_t* list[MAX_DLIGHTS]), (this, list));
	VFUNC(DLight_t*, getElightByKey, 8, (int key), (this, key));
};
```

`hack/SDK/IVEngineClient.hpp`:

```hpp
#pragma once
#include <cstdint>

#include "math/matrix.hpp"
#include "math/Vector.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

#define FLOW_OUTGOING	0
#define FLOW_INCOMING	1
#define MAX_FLOWS		2

class INetChannel
{
public:
	VFUNC(char*, getAddress, 1, (), (this));
	VFUNC(float, getTime, 2, (), (this));
	VFUNC(bool, isLoopBack, 6, (), (this));
	VFUNC(bool, isPlayBack, 8, (), (this));
	VFUNC(float, getLatency, 9, (int flow), (this, flow));
	PAD(24);
	int m_outSequenceNr;
	int m_inSequenceNr;
	int m_outSequenceNrAck;
	int m_outReliableState;
	int m_inReliableState;
	int m_chockedPackets;
};

struct PlayerInfo_t
{
	PAD(8);
	union
	{
		uint64_t m_steamID64;
		struct
		{
			int m_xuidlow;
			int m_xuidhigh;
		};
	};
	char m_name[128];
	int m_userID;
	char m_guid[33];
	uint32_t m_friendsID;
	char m_friendsName[128];
	bool m_fakePlayer;
	bool m_ishltv;
	size_t m_cutomFiles[4];
	uint8_t m_filesDownloaded;
};

class IVEngineClient
{
public:
	VFUNC(bool, isInGame, 26, (), (this));
	VFUNC(bool, isConnected, 27, (), (this));
	VFUNC(int, getLocalPlayer, 12, (), (this));
	VFUNC(int, getPlayerID, 9, (int id), (this, id));
	VFUNC(void, setViewAngles, 19, (const Vec3& angles), (this, std::cref(angles)));
	VFUNC(void, getViewAngles, 18, (Vec3& angles), (this, std::ref(angles)));
	VFUNC(int, getMaxClients, 20, (), (this));
	VFUNC(int, getPlayerInfo, 8, (int index, PlayerInfo_t* info), (this, index, info));
	VFUNC(void, getScreenSize, 5, (int& width, int& height), (this, std::ref(width), std::ref(height)));
	VFUNC(void, executeClientCMD, 114, (const char* cmd, bool fromConsole = false), (this, cmd, fromConsole));
	VFUNC(Matrix4x4&, worldToScreenMatrix, 37, (), (this));
	VFUNC(const char*, getLevelName, 53, (), (this));
	VFUNC(INetChannel*, getNameNetChannel, 78, (), (this));
	VFUNC(bool, isTakingScreenshot, 92, (), (this));
	VFUNC(bool, isConsoleVisible, 11, (), (this));
};

```

`hack/SDK/IVModelInfo.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

struct mstudiobone_t
{
	int m_nameIndex;
	int m_parent;
	PAD(152);
	int m_flags;
	PAD(52);
};

struct mstudiobbox_t
{
	int m_bone;
	int m_group;
	Vec3 m_bbmin;
	Vec3 m_bbmax;
	int m_hitboxnameindex;
	PAD(12);
	float m_radius;
	PAD(16);

	const char* getName() const
	{
		return (!m_hitboxnameindex) ? nullptr : reinterpret_cast<const char*>((uint8_t*)this + m_hitboxnameindex);
	}
};

struct mstudiohitboxset_t
{
	int m_nameIndex;
	int m_hitboxesCount;
	int m_hitboxesIndex;

	const char* getName() const
	{
		return (!m_nameIndex) ? nullptr : reinterpret_cast<const char*>((uint8_t*)this + m_hitboxesIndex);
	}

	mstudiobbox_t* getHitbox(int i) const
	{
		return (i > m_hitboxesCount) ? nullptr : reinterpret_cast<mstudiobbox_t*>((uint8_t*)this + m_hitboxesIndex) + i;
	}
};

struct model_t
{
	void* m_handle;
	char m_name[260];
	int m_loadFlags;
	int m_serverCount;
	int m_type;
	int m_flags;
	Vec3 m_vecMins;
	Vec3 m_vecMaxs;
	float m_radius;
	PAD(28);
};

struct studiohdr_t
{
	int m_id;
	int m_version;
	long m_checksum;
	char m_name[64];
	int m_length;
	Vec3 m_eyePos;
	Vec3 m_illiumPos;
	Vec3 m_hullMins;
	Vec3 m_hullMaxs;
	Vec3 m_mins;
	Vec3 m_maxs;
	int m_flags;
	int m_bonesCount;
	int m_boneIndex;
	int m_boneControllersCount;
	int m_boneControllerIndex;
	int m_hitboxSetsCount;
	int m_hitboxSetIndex;

	mstudiohitboxset_t* getHitboxSet(int i) const
	{
		return (i > m_hitboxSetsCount) ? nullptr : reinterpret_cast<mstudiohitboxset_t*>((uint8_t*)this + m_hitboxSetIndex) + i;
	}

	mstudiobone_t* getBone(int i) const
	{
		return (i > m_bonesCount) ? nullptr : reinterpret_cast<mstudiobone_t*>((uint8_t*)this + m_boneIndex) + i;
	}
};

class CPhysCollide;

struct vcollide_t
{
	unsigned short solidCount : 15;
	unsigned short isPacked : 1;
	unsigned short descSize;
	// VPhysicsSolids
	CPhysCollide** solids;
	char* pKeyValues;
	void* pUserData;
};

class IVModelInfo
{
public:
	VFUNC(model_t*, getModel, 1, (int modelindex), (this, modelindex));
	VFUNC(int, getModelIndex, 2, (const char* name), (this, name));
	VFUNC(vcollide_t*, getVCollide, 5, (model_t* model), (this, model));
	VFUNC(vcollide_t*, getVCollide, 6, (int modelIdx), (this, modelIdx));
	VFUNC(studiohdr_t*, getStudioModel, 32, (const model_t* model), (this, model));
	VFUNC(model_t*, findOrLoadModel, 43, (const char* name), (this, name));
};
```

`hack/SDK/IVModelRender.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "math/matrix.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

#include "lightdesc.hpp"

struct model_t;
struct studiohdr_t;
class IMaterial;

struct ModelRenderInfo_t
{
	Vec3 m_origin;
	Vec3 m_angles;
	PAD(4);
	void* m_renderable;
	const model_t* m_model;
	const Matrix3x4* m_modelWorld;
	const Matrix3x4* m_lightOffset;
	const Vec3* m_lightOrigin;
	int m_flags;
	int m_entIndex;
	int m_skin;
	int m_body;
	int m_hitboxset;
	unsigned short m_instance;
	ModelRenderInfo_t()
	{
		m_modelWorld = NULL;
		m_lightOffset = NULL;
		m_lightOrigin = NULL;
	}
};

struct DrawModelState_t
{
	studiohdr_t* m_studioHdr;
	void* m_studioHWData;
	void* m_renderable;
	const Matrix3x4* m_modelToWorld;
	void* m_decals;
	int m_drawFlags;
	int m_lod;
};

struct DrawModelResults_t
{
	/*int m_ActualTriCount;
	int m_TextureMemoryBytes;
	int m_NumHardwareBones;
	int m_NumBatches;
	int m_NumMaterials;
	int m_nLODUsed;
	int m_flLODMetric;
	CFastTimer m_RenderTime;
	CUtlVectorFixed<IMaterial*, MAX_DRAW_MODEL_INFO_MATERIALS> m_Materials;*/
};

struct ColorMeshInfo_t
{
	// A given color mesh can own a unique Mesh, or it can use a shared Mesh
	// (in which case it uses a sub-range defined by m_nVertOffset and m_nNumVerts)
	void* m_mesh;
	void* m_pooledVBAllocator;
	int	m_vertOffsetInBytes;
	int	m_numVerts;
};

enum
{
	MATERIAL_MAX_LIGHT_COUNT = 4,
};

struct MaterialLightingState_t
{
	Vec3 m_vecAmbientCube[6];		// ambient, and lights that aren't in locallight[]
	Vec3 m_vecLightingOrigin;		// The position from which lighting state was computed
	int	m_localLightCount;
	LightDesc_t m_localLightDesc[MATERIAL_MAX_LIGHT_COUNT];
};

struct DrawModelInfo_t
{
	studiohdr_t* m_studioHdr;
	void* m_hardwareData;
	void* m_Decals;
	int	m_Skin;
	int	m_Body;
	int	m_HitboxSet;
	void* m_pClientEntity;
	int	m_Lod;
	ColorMeshInfo_t* m_pColorMeshes;
	bool m_bStaticLighting;
	MaterialLightingState_t	m_LightingState;
};

class IVModelRender
{
public:
	VFUNC(void, overrideMaterial, 1, (IMaterial* material, int x = 0, int y = 0), (this, material, x, y));
	VFUNC(bool, isForcedMaterial, 2, (), (this));
};

```

`hack/SDK/IVRenderView.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class IMaterial;

class IVRenderView
{
public:
	VFUNC(void, setBlend, 4, (float blend), (this, blend));
	VFUNC(float, getBlend, 5, (), (this));
	VFUNC(void, modulateColor, 6, (float const* blend), (this, blend));
	VFUNC(void, getcolor, 7, (float* blend), (this, blend));
};
```

`hack/SDK/IVStudioRender.hpp`:

```hpp
#pragma once

#include "material.hpp"

#include <utilities/tools/tools.hpp>
#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"
#include "math/Vector.hpp"

#include <string>

class IVStudioRender
{
    PAD(592);
private:
    IMaterial* m_material;
    PAD(12);
private:
    OverrideType_t m_type;
public:
    VFUNC(int, getNumAbientLightSamples, 18, (), (this));
    VFUNC(void, setAmbientLightColors, 21, (const Vec3* colors), (this, colors));

    VFUNC(void, forcedMaterialOverride, 33, (IMaterial* mat, OverrideType_t type = OverrideType_t::OVERRIDE_NORMAL, int index = -1), (this, mat, type, index));
    bool isForced()
    {
        return (!m_material)
            ? m_type == OverrideType_t::OVERRIDE_DEPTH_WRITE || m_type == OverrideType_t::OVERRIDE_SSAO_DEPTH_WRITE
            : std::string_view(m_material->getName()).starts_with("dev/glow")
            ;
    }
};
```

`hack/SDK/IViewRender.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"

class IViewRender
{
	PAD(1416);
	float smokeAlpha;
};
```

`hack/SDK/IViewRenderBeams.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "helpers/vfunc.hpp"

class Entity_t;

struct BeamInfo_t
{
	int m_type;
	Entity_t* m_startEnt;
	int m_startAttachment;
	Entity_t* m_endEnt;
	int m_EndAttachment;
	Vec3 m_vecStart;
	Vec3 m_vecEnd;
	int m_modelIndex;
	const char* m_modelName;
	int m_haloIndex;
	const char* m_haloName;
	float m_haloScale;
	float m_life;
	float m_width;
	float m_endWidth;
	float m_fadeLength;
	float m_amplitude;
	float m_brightness;
	float m_speed;
	int m_startFrame;
	float m_frameRate;
	float m_red;
	float m_green;
	float m_blue;
	bool m_renderable;
	int m_segments;
	int m_flags;
	Vec3 m_vecCenter;
	float m_startRadius;
	float m_endRadius;
};

class Beam_t;

class IViewRenderBeams
{
public:
	VFUNC(void, drawBeam, 4, (Beam_t* beam), (this, beam));
	VFUNC(Beam_t*, createBeamPoints, 12, (BeamInfo_t& beamInfo), (this, std::ref(beamInfo)));
	VFUNC(Beam_t*, createBeamRingPoint, 16, (BeamInfo_t& beamInfo), (this, std::ref(beamInfo)));
	VFUNC(Beam_t*, createBeamFollow, 18, (BeamInfo_t& beamInfo), (this, std::ref(beamInfo)));
};
```

`hack/SDK/IWeapon.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

class WeaponInfo
{
public:
	PAD(4);
	const char* m_consoleName;
	PAD(12);
	int m_maxClip1;
	int m_maxClip2;
	PAD(8);
	int m_primaryMaxAmmo;
	int m_secondaryMaxAmmo;
	PAD(92);
	const char* m_WeaponName;
	PAD(60);
	int m_type;
	PAD(4);
	int m_price;
	int m_priceKKillAward;
	PAD(4);
	float m_cycleTime;
	float m_cycleTimeAlt;
	PAD(8);
	bool isFullAuto;
	PAD(3);
	int m_damage;
	float m_hsMultiplier;
	float m_armorRatio;
	int m_bullets;
	float m_penetration;
	PAD(8);
	float m_range;
	float m_rangeModyfier;
	float m_throwVelocity;
	PAD(12);
	bool isSilenced;
	PAD(123);
	//float m_recoil; not sure
};

class IWeapon
{
public:
	VFUNC(WeaponInfo*, getWpnData, 2, (unsigned int ItemDefinitionIndex), (this, ItemDefinitionIndex));
};
```

`hack/SDK/Input.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "CUserCmd.hpp"
#include "vars.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

class Input
{
public:
    PAD(169);
    bool m_cameraInThirdPerson;
    PAD(2);
    Vec3 m_cameraOffset;
    PAD(56);
    CUserCmd* m_commands;
    CVerifiedUserCmd* m_verifiedCommands;

    VFUNC(CUserCmd*, getUserCmd, 8, (int slot, int sequence), (this, slot, sequence));

    CVerifiedUserCmd* getVerifiedUserCmd(int sequence)
    {
        return &m_verifiedCommands[sequence % MULTIPLAYER_BACKUP];
    }
};
```

`hack/SDK/InputSystem.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class InputSystem
{
public:
	VFUNC(void, enableInput, 11, (bool enable), (this, enable));
	VFUNC(void, resetState, 39, (), (this));
};
```

`hack/SDK/KeyValues.cpp`:

```cpp
#include "KeyValues.hpp"

#include "KeyValuesSys.hpp"
#include "interfaces/interfaces.hpp"

#include <gamememory/memory.hpp>

KeyValues::KeyValues(const char* key, const char* maybeSomePreValue, int caseSensitive)
{
	memory::keyValuesConstruct()(this, key, maybeSomePreValue, caseSensitive);
}

KeyValues::~KeyValues()
{
	// direct reference: [actual address in first opcode] E8 ? ? ? ? 8B 4B 14 5F 
	// probably casted sign or just int, from quick lookup seems 1 is default
	memory::keyValuesDestruct()(this, 1);
}

KeyValues* KeyValues::fromString(const char* name, const char* value)
{
	const static auto fromstring = memory::keyValuesFromString();
	KeyValues* res{};

	__asm
	{
		push 0
		mov edx, value
		mov ecx, name
		call fromstring
		add esp, 4
		mov res, eax
	}

	return res;
}

void KeyValues::fromBuffer(const char* name, const char* buffer, void* filesystem, const char* pathId, void* symbolProc, int unk)
{
	memory::loadFromBuffer()(this, name, buffer, filesystem, pathId, symbolProc, unk);
}

void* KeyValues::operator new(size_t size)
{
	return memory::interfaces::keyValuesSys->allocKeysMemory(size);
}

void KeyValues::setString(const char* name, const char* value)
{
	auto key = findKey(name, true);
	if (key)
	{
		memory::setString()(this, name, value);
	}
}

KeyValues* KeyValues::findKey(const char* name, bool create)
{
	return memory::findKey()(this, name, create);
}
```

`hack/SDK/KeyValues.hpp`:

```hpp
#pragma once

#include "helpers/pad.hpp"

using getSymbolProc_t = bool(__cdecl*)(const char*);

class KeyValues
{
public:
	KeyValues(const char* key, const char* maybeSomePreValue = nullptr, int caseSensitive = 0);
	~KeyValues();
	static KeyValues* fromString(const char* name, const char* value = nullptr);
	void fromBuffer(const char* name, const char* buffer, void* filesystem = nullptr, const char* pathId = nullptr, void* symbolProc = nullptr, int unk = 0);
	void* operator new(size_t size);
	void setString(const char* name, const char* value);
	KeyValues* findKey(const char* name, bool create);

	PAD(0x2C); // keep this updated to prevent calling size allocation yourself manually
};
static_assert(sizeof(KeyValues) == 0x2C);
```

`hack/SDK/KeyValuesSys.hpp`:

```hpp
#pragma once

#include "helpers/vfunc.hpp"

class KeyValuesSys
{
public:
	VFUNC(void*, allocKeysMemory, 2, (size_t size), (this, size));
	VFUNC(void, freeKeysMemory, 3, (void* memory), (this, memory));
	VFUNC(int, getSymbolForString, 4, (const char* name, bool create = true), (this, name, create));
};
```

`hack/SDK/MapStruct.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"
#include "helpers/pad.hpp"

struct MapStruct
{
	PAD(276);
	Vec2 m_origin;
	PAD(12);
	float m_scale;
	PAD(200);
	int m_numberRadarPlayers;
};
```

`hack/SDK/PixEvent.hpp`:

```hpp
#pragma once

#include "IMatRenderContext.hpp"

#define PIX_VALVE_ORANGE 0xFFF5940F

class PIXEvent
{
public:
	PIXEvent(IMatRenderContext* pRenderContext, const char* szName, unsigned long color = PIX_VALVE_ORANGE)
	{
		m_pRenderContext = pRenderContext;
		//Assert(m_pRenderContext);
		//Assert(szName);
		m_pRenderContext->beginPIXEvent(color, szName);
	}
	~PIXEvent()
	{
		m_pRenderContext->endPIXEvent();
	}
private:
	IMatRenderContext* m_pRenderContext;
};

#ifndef CONCAT_IMPL
#define CONCAT_IMPL(x, y) x##y
#endif

#ifndef MACRO_CONCAT
#define MACRO_CONCAT(x, y) CONCAT_IMPL(x, y)
#endif

#define PIXEVENT PIXEvent MACRO_CONCAT(pix_, __COUNTER__)

```

`hack/SDK/Recv.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

enum SendPropType
{
	DPT_INT = 0,
	DPT_FLOAT,
	DPT_VECTOR,
	DPT_VECTOR2D,
	DPT_STRING,
	DPT_ARRAY,
	DPT_DATATABLE,
	DPT_INT64,
	DPT_SENDPROPTYPEMAX
};

class DVariant
{
public:
	union
	{
		float m_float;
		long m_int;
		char* m_string;
		void* m_data;
		Vec3 m_vector;
		int64_t m_int64;
	};
	SendPropType m_type;
};

class RecvTable;
class RecvProp;

class CRecvProxyData
{
public:
	const RecvProp* m_recvProp;
	DVariant m_value;
	int	m_element;
	int	m_objectID;
};

using RecvVarProxyFn = std::add_pointer_t<void __cdecl(CRecvProxyData&, void*, void*)>;

class RecvProp
{
public:
	char* m_varName;
	SendPropType m_recvType;
	int m_flags;
	int m_stringBufferSize;
	int m_insideArray;
	const void* m_extraData;
	RecvProp* m_arrayProp;
	void* m_arrayLengthProxy;
	RecvVarProxyFn m_proxyFn;
	void* m_dataTableProxyFn;
	RecvTable* m_dataTable;
	int m_offset;
	int m_elementStride;
	int m_elements;
	const char* m_parentArrayPropName;
};

class RecvTable
{
public:
	RecvProp* m_props;
	int m_propsNum;
	void* m_decoder;
	char* m_netTableName;
	bool m_initialized;
	bool m_inMainList;
};

```

`hack/SDK/animations.hpp`:

```hpp
#pragma once

class AnimationLayer
{
public:
	float m_animationTime;
	float m_fadeOut;
	void* m_studio;
	int m_dispatchedSrc;
	int m_dispatchedDst;
	int m_order;
	size_t m_sequence;
	float m_prevCycle;
	float m_weight;
	float m_weightDeltaRate;
	float m_playbackRate;
	float m_cycle;
	void* m_entity;
	int m_invalidatePhysicsBits;
};
```

`hack/SDK/checksum_crc.cpp`:

```cpp
#include "checksum_crc.hpp"

#define CRC32_INIT_VALUE 0xFFFFFFFFUL
#define CRC32_XOR_VALUE  0xFFFFFFFFUL

#define NUM_BYTES 256
static const CRC32_t pulCRCTable[NUM_BYTES] =
{
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
    0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
    0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
    0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
    0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
    0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
    0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
    0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
    0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
    0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
    0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
    0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
    0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
    0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
    0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
    0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
    0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
    0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

void CRC32_Init(CRC32_t* pulCRC)
{
    *pulCRC = CRC32_INIT_VALUE;
}

void CRC32_Final(CRC32_t* pulCRC)
{
    *pulCRC ^= CRC32_XOR_VALUE;
}

CRC32_t	CRC32_GetTableEntry(unsigned int slot)
{
    return pulCRCTable[(unsigned char)slot];
}

void CRC32_ProcessBuffer(CRC32_t* pulCRC, const void* pBuffer, int nBuffer)
{
    CRC32_t ulCrc = *pulCRC;
    unsigned char* pb = (unsigned char*)pBuffer;
    unsigned int nFront;
    int nMain;

JustAfew:

    switch (nBuffer)
    {
    case 7:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 6:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 5:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 4:
        ulCrc ^= LittleLong(*(CRC32_t*)pb);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        *pulCRC = ulCrc;
        return;

    case 3:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 2:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 1:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

    case 0:
        *pulCRC = ulCrc;
        return;
    }

    // We may need to do some alignment work up front, and at the end, so that
    // the main loop is aligned and only has to worry about 8 byte at a time.
    //
    // The low-order two bits of pb and nBuffer in total control the
    // upfront work.
    //
    nFront = ((unsigned int)pb) & 3;
    nBuffer -= nFront;
    switch (nFront)
    {
    case 3:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
    case 2:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
    case 1:
        ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
    }

    nMain = nBuffer >> 3;
    while (nMain--)
    {
        ulCrc ^= LittleLong(*(CRC32_t*)pb);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc ^= LittleLong(*(CRC32_t*)(pb + 4));
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
        pb += 8;
    }

    nBuffer &= 7;
    goto JustAfew;
}
```

`hack/SDK/checksum_crc.hpp`:

```hpp
#pragma once

#define LittleLong( val )			( val )
using CRC32_t = unsigned int;

void CRC32_Init(CRC32_t* pulCRC);
void CRC32_ProcessBuffer(CRC32_t* pulCRC, const void* p, int len);
void CRC32_Final(CRC32_t* pulCRC);
CRC32_t	CRC32_GetTableEntry(unsigned int slot);

inline CRC32_t CRC32_ProcessSingleBuffer(const void* p, int len)
{
	CRC32_t crc;

	CRC32_Init(&crc);
	CRC32_ProcessBuffer(&crc, p, len);
	CRC32_Final(&crc);

	return crc;
}
```

`hack/SDK/clientHitVerify.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

struct ClientHitVerify_t
{
	Vec3 m_pos;
	float m_time;
	float m_expire;
};
```

`hack/SDK/datamap.hpp`:

```hpp
#pragma once

#include "CUtlVector.hpp"
#include "helpers/pad.hpp"

#define ALIGN_VALUE( val, alignment ) ( ( val + alignment - 1 ) & ~( alignment - 1 ) )

enum fieldtype_t
{
	FIELD_VOID = 0,			// No type or value
	FIELD_FLOAT,			// Any floating point value
	FIELD_STRING,			// A string ID (return from ALLOC_STRING)
	FIELD_VECTOR,			// Any vector, QAngle, or AngularImpulse
	FIELD_QUATERNION,		// A quaternion
	FIELD_INTEGER,			// Any integer or enum
	FIELD_BOOLEAN,			// boolean, implemented as an int, I may use this as a hint for compression
	FIELD_SHORT,			// 2 byte integer
	FIELD_CHARACTER,		// a byte
	FIELD_COLOR32,			// 8-bit per channel r,g,b,a (32bit color)
	FIELD_EMBEDDED,			// an embedded object with a datadesc, recursively traverse and embedded class/structure based on an additional typedescription
	FIELD_CUSTOM,			// special type that contains function pointers to it's read/write/parse functions
	FIELD_CLASSPTR,			// CBaseEntity *
	FIELD_EHANDLE,			// Entity handle
	FIELD_EDICT,			// edict_t *
	FIELD_POSITION_VECTOR,	// A world coordinate (these are fixed up across level transitions automagically)
	FIELD_TIME,				// a floating point time (these are fixed up automatically too!)
	FIELD_TICK,				// an integer tick count( fixed up similarly to time)
	FIELD_MODELNAME,		// Engine string that is a model name (needs precache)
	FIELD_SOUNDNAME,		// Engine string that is a sound name (needs precache)
	FIELD_INPUT,			// a list of inputed data fields (all derived from CMultiInputVar)
	FIELD_FUNCTION,			// A class function pointer (Think, Use, etc)
	FIELD_VMATRIX,			// a vmatrix (output coords are NOT worldspace)
	FIELD_VMATRIX_WORLDSPACE,// A VMatrix that maps some local space to world space (translation is fixed up on level transitions)
	FIELD_MATRIX3X4_WORLDSPACE,	// matrix3x4_t that maps some local space to world space (translation is fixed up on level transitions)
	FIELD_INTERVAL,			// a start and range floating point interval ( e.g., 3.2->3.6 == 3.2 and 0.4 )
	FIELD_MODELINDEX,		// a model index
	FIELD_MATERIALINDEX,	// a material index (using the material precache string table)
	FIELD_VECTOR2D,			// 2 floats
	FIELD_TYPECOUNT,		// MUST BE LAST
};

#define FTYPEDESC_GLOBAL			0x0001		// This field is masked for global entity save/restore
#define FTYPEDESC_SAVE				0x0002		// This field is saved to disk
#define FTYPEDESC_KEY				0x0004		// This field can be requested and written to by string name at load time
#define FTYPEDESC_INPUT				0x0008		// This field can be written to by string name at run time, and a function called
#define FTYPEDESC_OUTPUT			0x0010		// This field propogates it's value to all targets whenever it changes
#define FTYPEDESC_FUNCTIONTABLE		0x0020		// This is a table entry for a member function pointer
#define FTYPEDESC_PTR				0x0040		// This field is a pointer, not an embedded object
#define FTYPEDESC_OVERRIDE			0x0080		// The field is an override for one in a base class (only used by prediction system for now)

// Flags used by other systems (e.g., prediction system)
#define FTYPEDESC_INSENDTABLE		0x0100		// This field is present in a network SendTable
#define FTYPEDESC_PRIVATE			0x0200		// The field is local to the client or server only (not referenced by prediction code and not replicated by networking)
#define FTYPEDESC_NOERRORCHECK		0x0400		// The field is part of the prediction typedescription, but doesn't get compared when checking for errors

#define FTYPEDESC_MODELINDEX		0x0800		// The field is a model index (used for debugging output)

#define FTYPEDESC_INDEX				0x1000		// The field is an index into file data, used for byteswapping. 

// These flags apply to C_BasePlayer derived objects only
#define FTYPEDESC_VIEW_OTHER_PLAYER		0x2000		// By default you can only view fields on the local player (yourself), 
													//   but if this is set, then we allow you to see fields on other players
#define FTYPEDESC_VIEW_OWN_TEAM			0x4000		// Only show this data if the player is on the same team as the local player
#define FTYPEDESC_VIEW_NEVER			0x8000		// Never show this field to anyone, even the local player (unusual)

#define TD_MSECTOLERANCE		0.001f		// This is a FIELD_FLOAT and should only be checked to be within 0.001 of the networked info

enum
{
	TD_OFFSET_NORMAL = 0,
	TD_OFFSET_PACKED = 1,
	TD_OFFSET_COUNT,
};

struct InputData;
struct DataMap_t;

struct Typedescription_t
{
	fieldtype_t	m_type;
	const char* m_name;
	int m_offset[TD_OFFSET_COUNT];
	uint16_t m_size;
	int16_t	m_flags;
	PAD(12);
	DataMap_t* m_dataMap;
	int m_sizeInBytes;
	Typedescription_t* overrideField;
	int overrideCount;
	float fieldTolerance;
	PAD(8);
};

enum
{
	PC_NON_NETWORKED_ONLY = 0,
	PC_NETWORKED_ONLY,

	PC_COPYTYPE_COUNT,
	PC_EVERYTHING = PC_COPYTYPE_COUNT,
};

struct DataMap_t
{
	Typedescription_t* m_dataDescription;
	int m_dataFields;
	const char* m_dataClassName;
	DataMap_t* m_baseMap;
	bool m_chainsValidated;
	bool m_packedOffsetsComputed;
	int m_packedSize;
	void* m_optimizedDataMap;
};

```

`hack/SDK/helpers/netvars.cpp`:

```cpp
#include "netvars.hpp"

#include <SDK/Recv.hpp>
#include <SDK/IBaseClientDll.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/config.hpp>
#include <utilities/utilities.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/console/console.hpp>

#include <array>
#include <ranges>
#include <fstream>
#include <unordered_map>

namespace netvars
{
	std::unordered_map<std::string_view, RecvTable*> m_Tables{ };
	std::ofstream file{ };

	[[nodiscard]] uintptr_t getProp(const std::string_view tableName, const std::string_view propName, RecvProp** prop = nullptr);
	[[nodiscard]] uintptr_t getProp(RecvTable* recvTable, const std::string_view propName, RecvProp** prop = nullptr);
	[[nodiscard]] RecvTable* getTable(const std::string_view tableName);
	[[nodiscard]] std::string getType(RecvProp* recvTable);
	void dump(RecvTable* recvTable);
}

void netvars::init()
{
	auto clientClass = memory::interfaces::client->getAllClasses();
	if (!clientClass)
		return;

	while (clientClass)
	{
		auto recvTable = clientClass->m_recvTable;
		m_Tables.emplace(recvTable->m_netTableName, recvTable);

		clientClass = clientClass->m_next;
	}

	dump();

	console::debug("Netvars inited");
}

uintptr_t netvars::getNetvar(const std::string_view tableName, const std::string_view propName)
{
	auto offset = getProp(tableName, propName);
	if (!offset)
		return 0;

	return offset;
}

uintptr_t netvars::getProp(const std::string_view tableName, const std::string_view propName, RecvProp** prop)
{
	auto recvTable = getTable(tableName);
	if (!recvTable)
		return 0;

	auto offset = getProp(recvTable, propName, prop);
	if (!offset)
		return 0;

	return offset;
}

uintptr_t netvars::getProp(RecvTable* recvTable, const std::string_view propName, RecvProp** prop)
{
	uintptr_t extraOffset = 0;

	for (auto i : std::views::iota(0, recvTable->m_propsNum))
	{
		auto recvProp = &recvTable->m_props[i];
		auto recvChild = recvProp->m_dataTable;

		if (recvChild && (recvChild->m_propsNum > 0))
		{
			auto temp = getProp(recvChild, propName, prop);

			if (temp)
				extraOffset += (recvProp->m_offset + temp);
		}

		if (std::string_view name = recvProp->m_varName; name != propName)
			continue;

		if (prop)
			*prop = recvProp;

		return (recvProp->m_offset + extraOffset);
	}

	return extraOffset;
}

RecvTable* netvars::getTable(const std::string_view tableName)
{
	if (m_Tables.empty())
		return nullptr;

	for(const auto& [name, recv] : m_Tables)
	{
		if (name == tableName)
			return recv;
	}

	return nullptr;
}

std::string netvars::getType(RecvProp* recvTable)
{
	static std::unordered_map<SendPropType, std::string> props =
	{
		{ SendPropType::DPT_INT, "int"},
		{ SendPropType::DPT_FLOAT, "float"},
		{ SendPropType::DPT_VECTOR, "Vec3"},
		{ SendPropType::DPT_VECTOR2D, "Vec2"},
		{ SendPropType::DPT_STRING, "char"},
		{ SendPropType::DPT_ARRAY, "array"},
		{ SendPropType::DPT_DATATABLE, "datatable (void*)"},
		{ SendPropType::DPT_INT64, "__int64"},
	};

	// buffers
	if (auto type = recvTable->m_recvType; type == DPT_STRING)
		return std::format("{}[{}]", props.at(recvTable->m_recvType), recvTable->m_stringBufferSize);
	else if(type == DPT_ARRAY)
		return std::format("{}[{}]", props.at(recvTable->m_recvType), recvTable->m_elements);

	return props.at(recvTable->m_recvType);
}

void netvars::dump(RecvTable* recvTable)
{
	for (auto i : std::views::iota(0, recvTable->m_propsNum))
	{
		auto recvProp = &recvTable->m_props[i];

		if (!recvProp)
			continue;

		std::string_view recvName = recvProp->m_varName;
		if (recvName.find("baseclass") != std::string::npos)
			continue;

		if (::isdigit(recvProp->m_varName[0]))
			continue;

		file << std::format("[{}::{}] -> 0x{:X} -> ({})",
			recvTable->m_netTableName,
			recvName, recvProp->m_offset,
			getType(recvProp))
			<< '\n';

		if (recvProp->m_dataTable)
			dump(recvProp->m_dataTable);
	}
}

#include <SDK/datamap.hpp>

uintptr_t netvars::getDataMap(DataMap_t* map, const std::string_view name)
{
	while (map)
	{
		for (auto i : std::views::iota(0, map->m_dataFields))
		{
			const auto descriptor = map->m_dataDescription[i];

			if (descriptor.m_name == nullptr)
				continue;

			if (name == std::string_view{ descriptor.m_name })
				return descriptor.m_offset[TD_OFFSET_NORMAL];

			if (descriptor.m_type == FIELD_EMBEDDED)
			{
				if (descriptor.m_dataMap)
				{
					if (const auto offset = getDataMap(descriptor.m_dataMap, name))
						return offset;
				}
			}
		}
		map = map->m_baseMap;
	}

	return 0U;
}

#include <utilities/simpleTimer.hpp>

void netvars::dump()
{
	file = std::ofstream{ api::getHackPath() / "netvarsDump.txt" };
	file << std::format("Netvars from: {}", utilities::getTime()) << "\n\n";

	TimeCount timer{};
	size_t count{ 0U };

	auto client = memory::interfaces::client->getAllClasses();
	do {
		const auto recvTable = client->m_recvTable;
		dump(recvTable);
		client = client->m_next;
		++count;
	} while (client);

	timer.end();

	file << '\n' << std::format("Found {} netvars\nFinished in {:.2f} secs", count, timer.getTime());
	file.close();
}
```

`hack/SDK/helpers/netvars.hpp`:

```hpp
#pragma once

#include <type_traits>

struct DataMap_t;

namespace netvars
{
	void init();
	void dump();

	[[nodiscard]] uintptr_t getNetvar(const std::string_view tableName, const std::string_view propName);
	[[nodiscard]] uintptr_t getDataMap(DataMap_t* map, const std::string_view name);
}

// generate netvar address
// type - template type for return type
// name - name your function
// table - table name to search the netvar prop
// prop - prop name
#define NETVAR(type, name, table, prop) \
[[nodiscard]] std::add_lvalue_reference_t<type> name() { \
	static uintptr_t offset = netvars::getNetvar(table, prop); \
	return *reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset ); \
	}

// generate netvar, but address as the pointer
// type - template type for return type
// name - name your function
// table - table name to search the netvar prop
// prop - prop name
#define PTRNETVAR(type, name, table, prop) \
[[nodiscard]] std::add_pointer_t<type> name() { \
	static uintptr_t offset = netvars::getNetvar(table, prop); \
	return reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset); \
	}

// define literal offset
// type - template type for return type
// name - name your function
// offset - offset to add
#define OFFSET(type, name, offset) \
[[nodiscard]] std::add_lvalue_reference_t<type> name() { \
	return *reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset); \
	}

// define literal offset as pointer
// type - template type for return type
// name - name your function
// offset - offset to add
#define PTROFFSET(type, name, offset) \
[[nodiscard]] std::add_pointer_t<type> name() { \
	return reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset); \
	}

// use like normal netvar, with bytes to add as last argument
// type - template type for return type
// name - name your function
// table - table name to search the netvar prop
// prop - prop name
// addr - extra offset to add
#define NETVAR_ADDR(type, name, table, prop, addr) \
[[nodiscard]] std::add_lvalue_reference_t<type> name() { \
	static uintptr_t offset = netvars::getNetvar(table, prop); \
	return *reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset + addr); \
	}

// use like normal netvar, with bytes to add as last argument, returns as pointer
// type - template type for return type
// name - name your function
// table - table name to search the netvar prop
// prop - prop name
// addr - extra offset to add
#define PTRNETVAR_ADDR(type, name, table, prop, addr) \
[[nodiscard]] std::add_pointer_t<type> name() { \
	static uintptr_t offset = netvars::getNetvar(table, prop); \
	return reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset + addr); \
	}

// generate datamap address
// type - template type for return type
// name - name your function
// table - table name to search the netvar prop
// prop - prop name
#define DATAMAP_FIELD(type, name, map, prop) \
[[nodiscard]] std::add_lvalue_reference_t<type> name() { \
	static uintptr_t offset = netvars::getDataMap(map, prop); \
	return *reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset ); \
	}

// generate netvar address as pointer
// type - template type for return type
// name - name your function
// table - table name to search the netvar prop
// prop - prop name
#define PTRDATAMAP_FIELD(type, name, map, prop) \
[[nodiscard]] std::add_pointer_t<type> name() { \
	static uintptr_t offset = netvars::getDataMap(map, prop); \
	return reinterpret_cast<std::add_pointer_t<type>>((uintptr_t)this + offset ); \
	}
```

`hack/SDK/helpers/pad.hpp`:

```hpp
#pragma once

#include <cstddef>

#define CONCAT_IMPL(x, y) x##y
#define MACRO_CONCAT(x, y) CONCAT_IMPL(x, y)
#define PAD(SIZE) \
private: \
	std::byte MACRO_CONCAT(_pad, __COUNTER__)[SIZE]; \
public:
```

`hack/SDK/helpers/vfunc.hpp`:

```hpp
#pragma once

namespace vfunc
{
	inline constexpr void* getVFunc(void* thisptr, size_t index)
	{
		return (*static_cast<void***>(thisptr))[index];
	}

	// use for any function that does not represent packed args and can be thiscall
	template <typename T, size_t index, typename ... Args_t>
	inline constexpr T callVFunc(void* thisptr, Args_t... args)
	{
		using virtualFunction = T(__thiscall***)(void*, Args_t...);
		return (*reinterpret_cast<virtualFunction>(thisptr))[index](thisptr, args...);
	}

	// ONLY for packed arguments in base case !!!
	template<typename T, size_t index, typename... Args_t>
	inline constexpr T callVPack(void* thisptr, Args_t... args)
	{
		using packedVirtualFunction = T(__cdecl***)(void*, Args_t...);
		return (*reinterpret_cast<packedVirtualFunction>(thisptr))[index](thisptr, args...);
	}
}
// type - type of function
// name - function's name
// index - vtable index for this method
// args - args to pass eg: (int value)
// variables - variables from args, the starting will always be a pointer to class, eg: (this, value)
#define VFUNC(type, name, index, args, variables) \
type name args { \
	return vfunc::callVFunc<type, index>variables; \
}

//#define VFUNC_VA_ARGS(type, name, index, ...) \
//template <typename... Args_t> \
//type name(Args_t&&... args) { \
//    return vfunc::callVPack<type, index, Args...>(this, std::forward<Args>(args)...); \
//}
```

`hack/SDK/interfaceNode.hpp`:

```hpp
#pragma once

#include <type_traits>

struct InterfacesNode
{
	std::add_pointer_t<void* __cdecl()> m_createFn;
	const char* m_name;
	InterfacesNode* m_next;
};
```

`hack/SDK/interfaces/ifc.hpp`:

```hpp
#pragma once

#include <string_view>
#include <gamememory/modules.hpp>

template<typename T>
struct Interface
{
	using value = T;

	T base{ };
	std::string_view module{ CLIENT_DLL };

	[[nodiscard]] constexpr T operator->() const
	{ 
		return base;
	}

	[[nodiscard]] constexpr T operator()() const
	{
		return base;
	}
};
```

`hack/SDK/interfaces/interfaces.cpp`:

```cpp
#include "interfaces.hpp"

#include "ifc.hpp"
#include "../interfaceNode.hpp"
#include <gamememory/modules.hpp>

#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/console/console.hpp>
#include <utilities/utilities.hpp>
#include <utilities/simpleTimer.hpp>
#include <config/config.hpp>
#include <gamememory/memory.hpp>

#include <Windows.h>
#include <d3d9.h>
#include <string>
#include <optional>

// #define CAPTURE_INTERFACES

#ifdef CAPTURE_INTERFACES
static std::unordered_map<std::string, std::vector<std::pair<std::string, void*>>> allInterfaces;

static void initInterfacesAndDump()
{
	auto file = std::ofstream{ config::getHackPath() / "interfacesDump.txt" };
	file << std::format("Interfaces from: {}", utilities::getTime()) << "\n\n";

	TimeCount timer{};

	const auto mainPath = std::filesystem::current_path();

	for (const auto& entry : std::filesystem::directory_iterator{ mainPath / "bin" })
	{
		if (entry.is_regular_file())
		{
			if (const auto mod = entry.path().filename(); mod.extension() == ".dll")
			{
				using fun = std::add_pointer_t<void* __cdecl(const char*, int*)>;
				// not using by export, because it's all contexpr
				auto capture = memory::Address<void*>{ GetProcAddress(GetModuleHandleA(mod.string().c_str()), "CreateInterface") }.cast<fun>();
				if (!capture.getAddr())
					continue;

				const auto addr = memory::Address<std::add_pointer_t<InterfacesNode>>{ capture.getAddr() };
				const auto esi = addr.rel(0x5, 0x6).deRef(memory::Dereference::TWICE);

				for (auto el = esi(); el; el = el->m_next)
				{
					if (const auto name = std::string_view{ el->m_name }; !name.empty())
					{
						allInterfaces[mod.string()].emplace_back(std::make_pair(name, el->m_createFn()));
					}
				}
			}
		}
	}

	for (const auto& entry : std::filesystem::directory_iterator{ mainPath / "csgo" / "bin" })
	{
		if (entry.is_regular_file())
		{
			if (const auto mod = entry.path().filename(); mod.extension() == ".dll")
			{
				using fun = std::add_pointer_t<void* __cdecl(const char*, int*)>;
				auto capture = memory::Address<void*>{ GetProcAddress(GetModuleHandleA(mod.string().c_str()), "CreateInterface") }.cast<fun>();
				if (!capture.getAddr())
					continue;

				const auto addr = memory::Address<std::add_pointer_t<InterfacesNode>>{ capture.getAddr() };
				const auto esi = addr.rel(0x5, 0x6).deRef(memory::Dereference::TWICE);

				for (auto el = esi(); el; el = el->m_next)
				{
					if (const auto name = std::string_view{ el->m_name }; !name.empty())
					{
						allInterfaces[mod.string()].emplace_back(std::make_pair(name, el->m_createFn()));
					}
				}
			}
		}
	}

	timer.end();

	size_t count{ 0U };
	for (const auto [mod, detail] : allInterfaces)
	{
		file << mod << '\n';
		for (const auto [dllname, addr] : detail)
		{
			file << '\t' << dllname << '\n';
			++count;
		}
		file << '\n';
	}

	file << '\n' << std::format("Found {} interfaces\nFinished in {:.2f} secs", count, timer.getTime());
}
#endif

#ifdef CAPTURE_INTERFACES
template<typename T>
static void findInterface(Interface<T>& ifc, const std::string_view name)
{
	bool found{ false };
	for (const auto [mod, detail] : allInterfaces)
	{
		for (const auto [dllname, addr] : detail)
		{
			if (dllname.starts_with(name))
			{
				ifc = Interface<T>{ .base = static_cast<T>(addr) };
				found = true;
				break;
			}
		}
	}

	assert(found);
}
#else
template <typename T>
static std::optional<Interface<T>> findInterface(const std::string_view moduleName, const std::string_view interfaceName)
{
	using fun = std::add_pointer_t<void* __cdecl(const char*, int*)>;
	auto capture = memory::byExport<"CreateInterface"_hasher>(moduleName).cast<fun>();

	const auto addr = memory::Address<std::add_pointer_t<InterfacesNode>>{ capture.getAddr() };
	const auto esi = addr.rel(0x5, 0x6).deRef(memory::Dereference::TWICE);

	for (auto el = esi(); el; el = el->m_next)
	{
		if (std::string_view{ el->m_name }.starts_with(interfaceName))
		{
			return Interface<T>{.base = static_cast<T>(el->m_createFn()), .module = moduleName };
		}
	}

	return std::nullopt;
}
#endif

#if !defined(CAPTURE_INTERFACES)
// capture and log
// var - var you want to init
// _module - module name from the game, eg: engine.dll
// _interface - interface' name
#define CAP(var, _module, _interface) \
	if(auto val = findInterface<decltype(var)::value>(_module, _interface); val.has_value()) \
		var = val.value(); \
	else \
		throw std::runtime_error(std::format("Interface {} was nullptr", _interface)); \
	console::debug("found {} at addr: 0x{:X}", _interface, reinterpret_cast<uintptr_t>(var.base));
#endif

void memory::interfaces::init()
{
#ifdef CAPTURE_INTERFACES
	initInterfacesAndDump();

	findInterface(engine, "VEngineClient0");
	findInterface(panel, "VGUI_Panel0");
	findInterface(surface, "VGUI_Surface0");
	findInterface(client, "VClient0");
	findInterface(entList, "VClientEntityList0");
	findInterface(cvar, "VEngineCvar0");
	findInterface(trace, "EngineTraceClient0");
	findInterface(renderView, "VEngineRenderView0");
	findInterface(matSys, "VMaterialSystem0");
	findInterface(modelInfo, "VModelInfoClient0");
	findInterface(prediction, "VClientPrediction0");
	findInterface(gameMovement, "GameMovement0");
	findInterface(debugOverlay, "VDebugOverlay0");
	findInterface(localize,"Localize_0");
	findInterface(modelRender, "VEngineModel0");
	findInterface(studioRender, "VStudioRender0");
	findInterface(eventManager, "GAMEEVENTSMANAGER002");
	findInterface(efx, "VEngineEffects0");
	findInterface(iSystem, "InputSystemVersion0");
	findInterface(effects, "IEffects0");
	findInterface(fileSystem, "VFileSystem0");
	findInterface(mdlCache, "MDLCache0");
	findInterface(baseFileSystem, "VBaseFileSystem0");
	findInterface(physicsCollision, "VPhysicsCollision0");
	findInterface(engineSound, "IEngineSoundClient0");
	findInterface(physicsProps, "VPhysicsSurfaceProps0");
	findInterface(clientStringTableContainer, "VEngineClientStringTable0");
#else
	CAP(engine, ENGINE_DLL, "VEngineClient0");
	CAP(panel, VGUI_DLL, "VGUI_Panel0");
	CAP(surface, VGUIMAT_DLL, "VGUI_Surface0");
	CAP(client, CLIENT_DLL, "VClient0");
	CAP(entList, CLIENT_DLL, "VClientEntityList0");
	CAP(cvar, VSTD_DLL, "VEngineCvar0");
	CAP(trace, ENGINE_DLL, "EngineTraceClient0");
	CAP(renderView, ENGINE_DLL, "VEngineRenderView0");
	CAP(matSys, MATERIAL_DLL, "VMaterialSystem0");
	CAP(modelInfo, ENGINE_DLL, "VModelInfoClient0");
	CAP(prediction, CLIENT_DLL, "VClientPrediction0");
	CAP(gameMovement, CLIENT_DLL, "GameMovement0");
	CAP(debugOverlay, ENGINE_DLL, "VDebugOverlay0");
	CAP(localize, LOCALIZE_DLL, "Localize_0");
	CAP(modelRender, ENGINE_DLL, "VEngineModel0");
	CAP(studioRender, STUDIORENDER_DLL, "VStudioRender0");
	CAP(eventManager, ENGINE_DLL, "GAMEEVENTSMANAGER002");
	CAP(efx, ENGINE_DLL, "VEngineEffects0");
	CAP(iSystem, INPUTSYSTEM_DLL, "InputSystemVersion0");
	CAP(effects, CLIENT_DLL, "IEffects0");
	CAP(fileSystem, FILESYS_DLL, "VFileSystem0");
	CAP(mdlCache, DATACACHE_DLL, "MDLCache0");
	CAP(baseFileSystem, FILESYS_DLL, "VBaseFileSystem0");
	CAP(physicsCollision, VPHYSICS_DLL, "VPhysicsCollision0");
	CAP(engineSound, ENGINE_DLL, "IEngineSoundClient0");
	CAP(physicsProps, VPHYSICS_DLL, "VPhysicsSurfaceProps0");
	CAP(clientStringTableContainer, ENGINE_DLL, "VEngineClientStringTable0");
#endif

	console::debug("interfaces success");
}
```

`hack/SDK/interfaces/interfaces.hpp`:

```hpp
#pragma once

#include "ifc.hpp"

#pragma region declarations
class IPanel;
class ClientMode;
class ISurface;
class IVEngineClient;
class IBaseClientDLL;
class IWeapon;
class IClientEntityList;
class IClientMode;
class CClientState;
class Input;
class CGlobalVarsBase;
class IEngineTrace;
class IMaterialSystem;
class IVModelInfo;
class IVDebugOverlay;
class IGameEventManager;
class IViewRender;
class IVRenderView;
class CGlowManager;
class CGameMovement;
class IPrediction;
class IMoveHelper;
class ILocalize;
class ICvar;
class IConVar;
class IViewRenderBeams;
class IVModelRender;
class IVStudioRender;
class PlayerResource;
class IVEfx;
class InputSystem;
struct IDirect3DDevice9;
class IEffects;
class KeyValuesSys;
class IMemAlloc;
class CTeslaInfo;
class CEffectData;
class IClientState;
class Entity_t;
class IFileSystem;
class CGameRules;
class CEngineSoundClient;
class IMDLCache;
class IBaseFileSystem;
class IPhysicsCollision;
class IEngineSound;
class IPhysicsSurfaceProps;
class INetworkStringTableContainer;
#pragma endregion

namespace memory::interfaces
{
	inline Interface<IVEngineClient*> engine;
	inline Interface<IPanel*> panel;
	inline Interface<ISurface*> surface;
	inline Interface<IBaseClientDLL*> client;
	inline Interface<IClientEntityList*> entList;
	inline Interface<ICvar*> cvar;
	inline Interface<IEngineTrace*> trace;
	inline Interface<IVRenderView*> renderView;
	inline Interface<IMaterialSystem*> matSys;
	inline Interface<IVModelInfo*> modelInfo;
	inline Interface<IPrediction*> prediction;
	inline Interface<CGameMovement*> gameMovement;
	inline Interface<IVDebugOverlay*> debugOverlay;
	inline Interface<ILocalize*> localize;
	inline Interface<IVModelRender*> modelRender;
	inline Interface<IVStudioRender*> studioRender;
	inline Interface<IGameEventManager*> eventManager;
	inline Interface<IVEfx*> efx;
	inline Interface<InputSystem*> iSystem;
	inline Interface<IEffects*> effects;
	inline Interface<IFileSystem*> fileSystem;
	inline Interface<IMDLCache*> mdlCache;
	inline Interface<IBaseFileSystem*> baseFileSystem;
	inline Interface<IPhysicsCollision*> physicsCollision;
	inline Interface<IEngineSound*> engineSound;
	inline Interface<IPhysicsSurfaceProps*> physicsProps;
	inline Interface<INetworkStringTableContainer*> clientStringTableContainer;

	void init();
}
```

`hack/SDK/lightdesc.hpp`:

```hpp
#pragma once

#include "math/Vector.hpp"

enum LightType_t
{
	MATERIAL_LIGHT_DISABLE = 0,
	MATERIAL_LIGHT_POINT,
	MATERIAL_LIGHT_DIRECTIONAL,
	MATERIAL_LIGHT_SPOT,
};

enum LightType_OptimizationFlags_t
{
	LIGHTTYPE_OPTIMIZATIONFLAGS_HAS_ATTENUATION0 = 1,
	LIGHTTYPE_OPTIMIZATIONFLAGS_HAS_ATTENUATION1 = 2,
	LIGHTTYPE_OPTIMIZATIONFLAGS_HAS_ATTENUATION2 = 4,
	LIGHTTYPE_OPTIMIZATIONFLAGS_DERIVED_VALUES_CALCED = 8,
};

struct LightDesc_t
{
	LightType_t m_Type;										//< MATERIAL_LIGHT_xxx
	Vec3 m_Color;											//< color+intensity 
	Vec3 m_Position;										//< light source center position
	Vec3 m_Direction;										//< for SPOT, direction it is pointing
	float m_Range;											//< distance range for light.0=infinite
	float m_Falloff;										//< angular falloff exponent for spot lights
	float m_Attenuation0;									//< constant distance falloff term
	float m_Attenuation1;									//< linear term of falloff
	float m_Attenuation2;									//< quadatic term of falloff

	// NOTE: theta and phi are *half angles*
	float m_Theta;											//< inner cone angle. no angular falloff 
	//< within this cone
	float m_Phi;											//< outer cone angle

	// the values below are derived from the above settings for optimizations
	// These aren't used by DX8. . used for software lighting.

	// NOTE: These dots are cos( m_Theta ), cos( m_Phi )
	float m_ThetaDot;
	float m_PhiDot;
	float m_OneOverThetaDotMinusPhiDot;
	unsigned int m_Flags;
protected:
	float m_RangeSquared;
public:

	//void RecalculateDerivedValues(void);			 // calculate m_xxDot, m_Type for changed parms
	//void RecalculateOneOverThetaDotMinusPhiDot();

	//LightDesc_t(void)
	//{
	//}

	//// constructors for various useful subtypes

	//// a point light with infinite range
	//LightDesc_t(const Vector& pos, const Vector& color)
	//{
	//	InitPoint(pos, color);
	//}

	//LightDesc_t& operator=(const LightDesc_t& src)
	//{
	//	memcpy(this, &src, sizeof(LightDesc_t));
	//	return *this;
	//}

	///// a simple light. cone boundaries in radians. you pass a look_at point and the
	///// direciton is derived from that.
	//LightDesc_t(const Vector& pos, const Vector& color, const Vector& point_at,
	//	float inner_cone_boundary, float outer_cone_boundary)
	//{
	//	InitSpot(pos, color, point_at, inner_cone_boundary, outer_cone_boundary);
	//}

	//void InitPoint(const Vector& pos, const Vector& color);
	//void InitDirectional(const Vector& dir, const Vector& color);
	//void InitSpot(const Vector& pos, const Vector& color, const Vector& point_at,
	//	float inner_cone_boundary, float outer_cone_boundary);

	///// Given 4 points and 4 normals, ADD lighting from this light into "color".
	//void ComputeLightAtPoints(const FourVectors& pos, const FourVectors& normal,
	//	FourVectors& color, bool DoHalfLambert = false) const;
	//void ComputeNonincidenceLightAtPoints(const FourVectors& pos, FourVectors& color) const;
	//void ComputeLightAtPointsForDirectional(const FourVectors& pos,
	//	const FourVectors& normal,
	//	FourVectors& color, bool DoHalfLambert = false) const;

	//// warning - modifies color!!! set color first!!
	//void SetupOldStyleAttenuation(float fQuadatricAttn, float fLinearAttn, float fConstantAttn);

	//void SetupNewStyleAttenuation(float fFiftyPercentDistance, float fZeroPercentDistance);


	///// given a direction relative to the light source position, is this ray within the
	//	/// light cone (for spotlights..non spots consider all rays to be within their cone)
	//bool IsDirectionWithinLightCone(const Vector& rdir) const
	//{
	//	return ((m_Type != MATERIAL_LIGHT_SPOT) || (rdir.Dot(m_Direction) >= m_PhiDot));
	//}

	//float OneOverThetaDotMinusPhiDot() const
	//{
	//	return m_OneOverThetaDotMinusPhiDot;
	//}

	//float DistanceAtWhichBrightnessIsLessThan(float flAmount) const;
};

```

`hack/SDK/material.cpp`:

```cpp
#include "material.hpp"

#include <gamememory/memory.hpp>

void IMaterial::destroy()
{
	memory::destroyMaterial()(this);
}

bool IMaterial::precacheVars(void* vmtValues, void* patchValues, void* includes)
{
	return memory::precacheVars()(this, vmtValues, patchValues, includes);
}
```

`hack/SDK/material.hpp`:

```hpp
#pragma once

#include <render/Color.hpp>
#include "math/Vector.hpp"
#include "KeyValues.hpp"

#include "helpers/pad.hpp"
#include "helpers/vfunc.hpp"

enum OverrideType_t
{
    OVERRIDE_NORMAL = 0,
    OVERRIDE_BUILD_SHADOWS,
    OVERRIDE_DEPTH_WRITE,
    OVERRIDE_SELECTIVE,
    OVERRIDE_SSAO_DEPTH_WRITE,
};

enum MaterialVarFlags_t
{
    MATERIAL_VAR_DEBUG = (1 << 0),
    MATERIAL_VAR_NO_DEBUG_OVERRIDE = (1 << 1),
    MATERIAL_VAR_NO_DRAW = (1 << 2),
    MATERIAL_VAR_USE_IN_FILLRATE_MODE = (1 << 3),
    MATERIAL_VAR_VERTEXCOLOR = (1 << 4),
    MATERIAL_VAR_VERTEXALPHA = (1 << 5),
    MATERIAL_VAR_SELFILLUM = (1 << 6),
    MATERIAL_VAR_ADDITIVE = (1 << 7),
    MATERIAL_VAR_ALPHATEST = (1 << 8),
    //MATERIAL_VAR_UNUSED = (1 << 9),
    MATERIAL_VAR_ZNEARER = (1 << 10),
    MATERIAL_VAR_MODEL = (1 << 11),
    MATERIAL_VAR_FLAT = (1 << 12),
    MATERIAL_VAR_NOCULL = (1 << 13),
    MATERIAL_VAR_NOFOG = (1 << 14),
    MATERIAL_VAR_IGNOREZ = (1 << 15),
    MATERIAL_VAR_DECAL = (1 << 16),
    MATERIAL_VAR_ENVMAPSPHERE = (1 << 17), // OBSOLETE
    MATERIAL_VAR_UNUSED = (1 << 18), // UNUSED
    MATERIAL_VAR_ENVMAPCAMERASPACE = (1 << 19), // OBSOLETE
    MATERIAL_VAR_BASEALPHAENVMAPMASK = (1 << 20),
    MATERIAL_VAR_TRANSLUCENT = (1 << 21),
    MATERIAL_VAR_NORMALMAPALPHAENVMAPMASK = (1 << 22),
    MATERIAL_VAR_NEEDS_SOFTWARE_SKINNING = (1 << 23), // OBSOLETE
    MATERIAL_VAR_OPAQUETEXTURE = (1 << 24),
    MATERIAL_VAR_ENVMAPMODE = (1 << 25), // OBSOLETE
    MATERIAL_VAR_SUPPRESS_DECALS = (1 << 26),
    MATERIAL_VAR_HALFLAMBERT = (1 << 27),
    MATERIAL_VAR_WIREFRAME = (1 << 28),
    MATERIAL_VAR_ALLOWALPHATOCOVERAGE = (1 << 29),
    MATERIAL_VAR_ALPHA_MODIFIED_BY_PROXY = (1 << 30),
    MATERIAL_VAR_VERTEXFOG = (1 << 31),
};

//-----------------------------------------------------------------------------
// Internal flags not accessible from outside the material system. Stored in Flags2
//-----------------------------------------------------------------------------
enum MaterialVarFlags2_t
{
    // NOTE: These are for $flags2!!!!!
    //	UNUSED											= (1 << 0),

    MATERIAL_VAR2_LIGHTING_UNLIT = 0,
    MATERIAL_VAR2_LIGHTING_VERTEX_LIT = (1 << 1),
    MATERIAL_VAR2_LIGHTING_LIGHTMAP = (1 << 2),
    MATERIAL_VAR2_LIGHTING_BUMPED_LIGHTMAP = (1 << 3),
    MATERIAL_VAR2_LIGHTING_MASK =
    (MATERIAL_VAR2_LIGHTING_VERTEX_LIT |
        MATERIAL_VAR2_LIGHTING_LIGHTMAP |
        MATERIAL_VAR2_LIGHTING_BUMPED_LIGHTMAP),

    // FIXME: Should this be a part of the above lighting enums?
    MATERIAL_VAR2_DIFFUSE_BUMPMAPPED_MODEL = (1 << 4),
    MATERIAL_VAR2_USES_ENV_CUBEMAP = (1 << 5),
    MATERIAL_VAR2_NEEDS_TANGENT_SPACES = (1 << 6),
    MATERIAL_VAR2_NEEDS_SOFTWARE_LIGHTING = (1 << 7),
    // GR - HDR path puts lightmap alpha in separate texture...
    MATERIAL_VAR2_BLEND_WITH_LIGHTMAP_ALPHA = (1 << 8),
    MATERIAL_VAR2_NEEDS_BAKED_LIGHTING_SNAPSHOTS = (1 << 9),
    MATERIAL_VAR2_USE_FLASHLIGHT = (1 << 10),
    MATERIAL_VAR2_USE_FIXED_FUNCTION_BAKED_LIGHTING = (1 << 11),
    MATERIAL_VAR2_NEEDS_FIXED_FUNCTION_FLASHLIGHT = (1 << 12),
    MATERIAL_VAR2_USE_EDITOR = (1 << 13),
    MATERIAL_VAR2_NEEDS_POWER_OF_TWO_FRAME_BUFFER_TEXTURE = (1 << 14),
    MATERIAL_VAR2_NEEDS_FULL_FRAME_BUFFER_TEXTURE = (1 << 15),
    MATERIAL_VAR2_IS_SPRITECARD = (1 << 16),
    MATERIAL_VAR2_USES_VERTEXID = (1 << 17),
    MATERIAL_VAR2_SUPPORTS_HW_SKINNING = (1 << 18),
    MATERIAL_VAR2_SUPPORTS_FLASHLIGHT = (1 << 19),
    MATERIAL_VAR2_USE_GBUFFER0 = (1 << 20),
    MATERIAL_VAR2_USE_GBUFFER1 = (1 << 21),
    MATERIAL_VAR2_SELFILLUMMASK = (1 << 22),
    MATERIAL_VAR2_SUPPORTS_TESSELLATION = (1 << 23)
};

class IMaterialVar;

enum ShaderMaterialVars_t
{
    FLAGS = 0,
    FLAGS_DEFINED,	// mask indicating if the flag was specified
    FLAGS2,
    FLAGS_DEFINED2,
    COLOR,
    ALPHA,
    BASETEXTURE,
    FRAME,
    BASETEXTURETRANSFORM,
    FLASHLIGHTTEXTURE,
    FLASHLIGHTTEXTUREFRAME,
    COLOR2,
    SRGBTINT,

    NUM_SHADER_MATERIAL_VARS
};

class IMaterial
{
public:
    VFUNC(const char*, getName, 0, (), (this));
    VFUNC(const char*, getTextureGroupName, 1, (), (this));
    VFUNC(IMaterialVar*, findVar, 11, (const char* name, bool* found = nullptr, bool complain = true), (this, name, found, complain));
    VFUNC(void, alphaModulate, 27, (float alpha), (this, alpha));
    VFUNC(void, alphaModulate, 27, (const Color& color), (this, color.a()));
    VFUNC(void, colorModulate, 28, (float r, float g, float b), (this, r, g, b));
    VFUNC(void, colorModulate, 28, (const Color& color), (this, color.r(), color.g(), color.b()));
    VFUNC(void, setMaterialVarFlag, 29, (MaterialVarFlags_t flag, bool on), (this, flag, on));
    VFUNC(void, refresh, 37, (), (this));
    VFUNC(IMaterialVar**, getShaderParams, 41, (), (this));
    VFUNC(bool, isError, 42, (), (this));
    VFUNC(void, addRefCount, 12, (), (this));
    VFUNC(void, removeRefCount, 13, (), (this));
    VFUNC(float, getAlphaModulation, 44, (), (this));
    VFUNC(void, getColorModulation, 45, (float* r, float* g, float* b), (this, r, g, b));
    VFUNC(void, refreshPreservingMaterialVars, 53, (), (this));

    // goes for rgba
    void modulateAllColor(const Color& color)
    {
        this->colorModulate(color);
        this->alphaModulate(color);
    }

    void destroy();
    // crashing
    bool precacheVars(void* vmtValues = nullptr, void* patchValues = nullptr, void* includes = nullptr);

    PAD(124);
    KeyValues* m_keyValues;
};


class IMaterialVar
{
public:
    VFUNC(void, setValue, 4, (float val), (this, val));
    VFUNC(void, setValue, 5, (int val), (this, val));
    VFUNC(void, setValue, 6, (const char* val), (this, val));
    VFUNC(void, setValues, 11, (const Vec3& val), (this, val[0], val[1], val[2]));
    VFUNC(void, setValues, 11, (const Color& val), (this, val.r(), val.g(), val.b()));
    VFUNC(void, setValues, 11, (float x, float y, float z), (this, x, y, z));
    VFUNC(void, setVectorComponent, 26, (float val, int component), (this, val, component));

    VFUNC(const char*, getString, 7, (), (this));
    VFUNC(int, getInt, 27, (), (this));
    VFUNC(const float*, getVector, 30, (), (this));
};
```

`hack/SDK/materialInit.hpp`:

```hpp
#pragma once

#include <mutex>
//#include <source_location> because somewhat __FUNCTON__ is still more accurate
#include <utilities/console/console.hpp>

// or create a class that does exactly same thing but add static keyword before object
#define INIT_MATERIALS_ONCE(func) \
{ \
    static auto name = __FUNCTION__; \
    static std::once_flag func##_flag; \
    std::call_once(func##_flag, [&]() { \
        func(); \
        console::debug("init function, location {}", name); \
    } ); \
}
```

`hack/SDK/math/AABB.hpp`:

```hpp
#pragma once

#include "Vector.hpp"

struct AABB_t
{
	Vec3 m_minBounds;
	Vec3 m_maxBounds;
};
```

`hack/SDK/math/Rect.hpp`:

```hpp
#pragma once

struct Rect_t
{
	int x, y;
	int width, height;
};

struct Rect3D_t
{
	int x, y, z;
	int width, height, depth;

	Rect3D_t(int nX, int nY, int nZ, int nWidth, int nHeight, int nDepth)
	{
		x = nX;
		y = nY;
		z = nZ;
		width = nWidth;
		height = nHeight;
		depth = nDepth;
	}

	Rect3D_t(void)
	{
	}

};

```

`hack/SDK/math/Vector.hpp`:

```hpp
#pragma once

#include <array>
#include <type_traits>
#include <ranges>
#include <cmath>
#include <algorithm>
#include <compare>

#include <utilities/tools/wrappers.hpp>

enum class Coord { X, Y, Z };

template<typename T, size_t SIZE>
class Vector
{
protected:
	std::array<T, SIZE> m_arr{(T)0};
public:
	constexpr Vector()
	{
		for (auto& el : m_arr)
			el = static_cast<T>(0);
	}

	template<typename... Args_t>
	explicit constexpr Vector(const Args_t&... args)
		: m_arr{ args... }
	{
		static_assert(sizeof...(Args_t) == SIZE, "packed args mismatch");
	}

	explicit constexpr Vector(const std::array<T, SIZE>& arr)
		: m_arr{ arr }
	{}

	explicit constexpr Vector(const T* arr)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] = arr[i];
	}

	constexpr static T MAX_ARG = static_cast<T>(0x7FFF);

	[[nodiscard]] constexpr auto get() const
	{
		return *this;
	}

	[[nodiscard]] constexpr auto begin()
	{
		return m_arr.begin();
	}

	[[nodiscard]] const constexpr auto begin() const
	{
		return m_arr.cbegin();
	}

	[[nodiscard]] constexpr auto end()
	{
		return m_arr.end();
	}

	[[nodiscard]] const constexpr auto end() const
	{
		return m_arr.cend();
	}

	[[nodiscard]] constexpr size_t size() const
	{
		return SIZE;
	}

	[[nodiscard]] constexpr bool isZero() const
	{
		bool res = std::all_of(m_arr.cbegin(), m_arr.cend(),
			[zero = static_cast<T>(0)](T el)
		{
			return el == zero;
		});

		return res;
	}

	[[nodiscard]] constexpr bool isValid() const
	{
		bool res = std::all_of(m_arr.cbegin(), m_arr.cend(),
			[](T el)
			{
				return std::isfinite(el);
			});

		return res;
	}

	constexpr auto& clamp()
	{
		m_arr[0] = std::clamp(m_arr[0], (T)-89, (T)89);
		m_arr[1] = std::clamp(std::remainder(m_arr[1], (T)360), (T)-180, (T)180);
		if constexpr (SIZE > 3)
			m_arr[2] = std::clamp(m_arr[2], (T)-50, (T)50);

		return *this;
	}

	[[nodiscard]] T length() const
	{
		return std::sqrt(this->dotFields());
	}

	[[nodiscard]] constexpr T lengthSqrt() const
	{
		return this->dotFields();
	}

	[[nodiscard]] constexpr auto toVecPrev() const
	{
		return Vector<T, SIZE - 1U>{ getPack<SIZE - 1U>() };
	}

	constexpr const auto operator[](size_t i) const
	{
		return this->m_arr[i];
	}

	constexpr auto& operator[](size_t idx)
	{
		return this->m_arr[idx];
	}

	constexpr const auto operator[](Coord coord) const
	{
		return this->m_arr[static_cast<size_t>(coord)];
	}

	constexpr auto& operator[](Coord coord)
	{
		return this->m_arr[static_cast<size_t>(coord)];
	}

	constexpr auto& operator+=(const Vector& vec)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] += vec[i];

		return *this;
	}

	constexpr auto& operator+=(T val)
	{
		for (auto& el : m_arr)
			el += val;

		return *this;
	}

	constexpr auto& operator-=(const Vector& vec)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] -= vec[i];

		return *this;
	}

	constexpr auto& operator-=(T val)
	{
		for (auto& el : m_arr)
			el -= val;

		return *this;
	}

	constexpr auto& operator*=(const Vector& vec)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] *= vec[i];

		return *this;
	}

	constexpr auto& operator*=(T val)
	{
		for (auto& el : m_arr)
			el *= val;

		return *this;
	}

	constexpr auto& operator/=(const Vector& vec)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] /= vec[i];

		return *this;
	}

	constexpr auto& operator/=(T val)
	{
		for (auto i : std::views::iota(0U, SIZE))
			m_arr[i] /= val;

		return *this;
	}

	constexpr auto operator+(const Vector& vec) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] + vec[i];

		return res;
	}

	constexpr auto operator-(const Vector& vec) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] - vec[i];

		return res;
	}

	constexpr auto operator*(const Vector& vec) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] * vec[i];

		return res;
	}

	constexpr auto operator/(const Vector& vec) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] / vec[i];

		return res;
	}

	constexpr auto operator*(T val) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] * val;

		return res;
	}

	constexpr auto operator/(T val) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] / val;

		return res;
	}

	constexpr auto operator+(T val) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] + val;

		return res;
	}

	constexpr auto operator-(T val) const
	{
		Vector res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res[i] = this->m_arr[i] - val;

		return res;
	}

	constexpr auto operator<=>(const Vector&) const = default;

	[[nodiscard]] constexpr auto toArray() const
	{
		return m_arr;
	}

	constexpr auto& normalize()
	{
		m_arr[0] = std::isfinite(m_arr[0]) ? (T)std::remainder(m_arr[0], (T)360) : (T)0;
		m_arr[1] = std::isfinite(m_arr[1]) ? (T)std::remainder(m_arr[1], (T)360) : (T)0;
		if constexpr(SIZE > 2)
			m_arr[2] = (T)0;

		return* this;
	}

	[[nodiscard]] auto normalizeInPlace() const
	{
		const auto n = length();
		if (n > 1e-4f)
		{
			Vector res = {};
			for (auto i : std::views::iota(0U, SIZE))
				res[i] = this->m_arr[i] / n;

			return res;
		}

		return Vector{};
	}

	[[nodiscard]] constexpr auto normalized() const
	{
		Vector vec = this->get();
		vec.normalize();

		return vec;
	}

	[[nodiscard]] constexpr T dot(const Vector& vec) const
	{
		T res = {};
		for (auto i : std::views::iota(0U, SIZE))
			res += m_arr[i] * vec[i];

		return res;
	}

	[[nodiscard]] T distTo(const Vector& vec) const
	{
		return Vector{ *this - vec }.length();
	}

	[[nodiscard]] T distToMeters(const Vector& vec) const
	{
		return distTo(vec) * (T)0.0254f;
	}

	[[nodiscard]] constexpr auto lerp(const Vector& end, float t) const
	{
		return Vector{ *this + (end - *this) * t };
	}
private:
	[[nodiscard]] constexpr T dotFields(size_t times = SIZE) const
	{
		T temp = static_cast<T>(0);
		for (auto i : std::views::iota(0U, times))
			temp += m_arr[i] * m_arr[i];

		return temp;
	}

	template<size_t SIZ = SIZE, typename TT = T>
	[[nodiscard]] constexpr std::array<TT, SIZ> getPack() const
	{
		std::array<TT, SIZ> arr = {};
		for (auto i : std::views::iota(0U, SIZ))
			arr[i] = (TT)m_arr[i];

		return arr;
	}
public:

	static_assert(std::is_same_v<T, float> || std::is_same_v<T, int>, "Possible types are only: float, int");
	static_assert(SIZE >= 2 && SIZE <=4, "Sizes mismatch");
};

using Vec2 = Vector<float, 2U>;
using Vec3 = Vector<float, 3U>;
using Vec4 = Vector<float, 4U>;

#undef ASSERT_VEC3
```

`hack/SDK/math/VectorAligned.hpp`:

```hpp
#pragma once

#include "Vector.hpp"

#include <ranges>

class VectorAligned : public Vec3
{
public:
	constexpr VectorAligned() = default;

	constexpr VectorAligned(const Vec3& v) :
		Vec3{ v }, w{ 0.0f }
	{}

	constexpr VectorAligned& operator=(const Vec3& v)
	{
		for (auto i : std::views::iota(0U, v.size()))
			m_arr[i] = v[i];

		w = 0.0f;
		return *this;
	}

	float w = {};
};
```

`hack/SDK/math/matrix.hpp`:

```hpp
#pragma once

#include "Vector.hpp"

#include <array>

template<size_t ROWS = 3, size_t COLS = 4>
struct Matrix
{
	constexpr Matrix() = default;

	[[nodiscard]] constexpr auto origin() const
	{
		return Vec3{ m_matValues[0][3], m_matValues[1][3], m_matValues[2][3] };
	}

	constexpr const auto operator[](size_t i) const
	{
		return m_matValues[i];
	}

	constexpr auto operator[](size_t i)
	{
		return m_matValues[i];
	}
private:
	std::array<std::array<float, COLS>, ROWS> m_matValues;

	static_assert(ROWS >= 2 && ROWS >= 2, "Did you want to create a vector?");
};

using Matrix3x4 = Matrix<3, 4>;
using Matrix4x4 = Matrix<4, 4>;
```

`hack/SDK/stencil.hpp`:

```hpp
#pragma once

enum ShaderStencilOp_t
{
#if !defined( _X360 )
	SHADER_STENCILOP_KEEP = 1,
	SHADER_STENCILOP_ZERO = 2,
	SHADER_STENCILOP_SET_TO_REFERENCE = 3,
	SHADER_STENCILOP_INCREMENT_CLAMP = 4,
	SHADER_STENCILOP_DECREMENT_CLAMP = 5,
	SHADER_STENCILOP_INVERT = 6,
	SHADER_STENCILOP_INCREMENT_WRAP = 7,
	SHADER_STENCILOP_DECREMENT_WRAP = 8,
#else
	SHADER_STENCILOP_KEEP = D3DSTENCILOP_KEEP,
	SHADER_STENCILOP_ZERO = D3DSTENCILOP_ZERO,
	SHADER_STENCILOP_SET_TO_REFERENCE = D3DSTENCILOP_REPLACE,
	SHADER_STENCILOP_INCREMENT_CLAMP = D3DSTENCILOP_INCRSAT,
	SHADER_STENCILOP_DECREMENT_CLAMP = D3DSTENCILOP_DECRSAT,
	SHADER_STENCILOP_INVERT = D3DSTENCILOP_INVERT,
	SHADER_STENCILOP_INCREMENT_WRAP = D3DSTENCILOP_INCR,
	SHADER_STENCILOP_DECREMENT_WRAP = D3DSTENCILOP_DECR,
#endif
	SHADER_STENCILOP_FORCE_DWORD = 0x7fffffff
};

enum ShaderStencilFunc_t
{
#if !defined( _X360 )
	SHADER_STENCILFUNC_NEVER = 1,
	SHADER_STENCILFUNC_LESS = 2,
	SHADER_STENCILFUNC_EQUAL = 3,
	SHADER_STENCILFUNC_LEQUAL = 4,
	SHADER_STENCILFUNC_GREATER = 5,
	SHADER_STENCILFUNC_NOTEQUAL = 6,
	SHADER_STENCILFUNC_GEQUAL = 7,
	SHADER_STENCILFUNC_ALWAYS = 8,
#else
	SHADER_STENCILFUNC_NEVER = D3DCMP_NEVER,
	SHADER_STENCILFUNC_LESS = D3DCMP_LESS,
	SHADER_STENCILFUNC_EQUAL = D3DCMP_EQUAL,
	SHADER_STENCILFUNC_LEQUAL = D3DCMP_LESSEQUAL,
	SHADER_STENCILFUNC_GREATER = D3DCMP_GREATER,
	SHADER_STENCILFUNC_NOTEQUAL = D3DCMP_NOTEQUAL,
	SHADER_STENCILFUNC_GEQUAL = D3DCMP_GREATEREQUAL,
	SHADER_STENCILFUNC_ALWAYS = D3DCMP_ALWAYS,
#endif

	SHADER_STENCILFUNC_FORCE_DWORD = 0x7fffffff
};

#if defined( _X360 )
enum ShaderHiStencilFunc_t
{
	SHADER_HI_STENCILFUNC_EQUAL = D3DHSCMP_EQUAL,
	SHADER_HI_STENCILFUNC_NOTEQUAL = D3DHSCMP_NOTEQUAL,

	SHADER_HI_STENCILFUNC_FORCE_DWORD = 0x7fffffff
};
#endif


struct ShaderStencilState_t
{
	bool m_bEnable;
	ShaderStencilOp_t m_FailOp;
	ShaderStencilOp_t m_ZFailOp;
	ShaderStencilOp_t m_PassOp;
	ShaderStencilFunc_t m_CompareFunc;
	int m_nReferenceValue;
	uint32_t m_nTestMask;
	uint32_t m_nWriteMask;

#if defined( _X360 )
	bool m_bHiStencilEnable;
	bool m_bHiStencilWriteEnable;
	ShaderHiStencilFunc_t m_HiStencilCompareFunc;
	int m_nHiStencilReferenceValue;
#endif

	ShaderStencilState_t()
	{
		m_bEnable = false;
		m_PassOp = m_FailOp = m_ZFailOp = SHADER_STENCILOP_KEEP;
		m_CompareFunc = SHADER_STENCILFUNC_ALWAYS;
		m_nReferenceValue = 0;
		m_nTestMask = m_nWriteMask = 0xFFFFFFFF;

#if defined( _X360 )
		m_bHiStencilEnable = false;
		m_bHiStencilWriteEnable = false;
		m_HiStencilCompareFunc = SHADER_HI_STENCILFUNC_EQUAL;
		m_nHiStencilReferenceValue = 0;
#endif
	}
};

```

`hack/SDK/structs/Entity.cpp`:

```cpp
#include "Entity.hpp"

#include "../IVModelInfo.hpp"
#include "../ClientClass.hpp"
#include "../Enums.hpp"
#include "../ICollideable.hpp"
#include "../IClientEntityList.hpp"
#include "../IVEngineClient.hpp"
#include "../CPlayerResource.hpp"
#include "../IEngineTrace.hpp"
#include "../IMDLCache.hpp"
#include "../IWeapon.hpp"
#include "../math/matrix.hpp"
#include "../math/Vector.hpp"
#include "../interfaces/interfaces.hpp"

#include <gamememory/memory.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/math/math.hpp>

#include <array>

////////////////////////////////////////////////////////////////////////

Vec3 Entity_t::getAimPunch()
{
	Vec3 vec{ };
	vfunc::callVFunc<void, PUNCH>(this, std::ref(vec));
	return vec;
}

Vec3 Entity_t::getEyePos()
{
	Vec3 vec{ };
	vfunc::callVFunc<void, EYE_POS>(this, std::ref(vec));
	return vec;
}

AnimationLayer* Entity_t::getAnimOverlays()
{
	const auto offset = memory::animOverlays();
	return *reinterpret_cast<AnimationLayer**>(uintptr_t(this) + offset);
}

size_t Entity_t::getSequenceActivity(size_t sequence)
{
	const auto studio = memory::interfaces::modelInfo->getStudioModel(this->getModel());
	if (!studio)
		return 0;

	return memory::sequenceActivity()(this, studio, sequence);
}

bool Entity_t::isBreakable()
{
	if (!this)
		return false;

	if (!this->getIndex())
		return false;

	if (const bool res = memory::isBreakable()(this); !res)
		return false;

	const auto cl = this->clientClass();
	if (!cl)
		return false;

	const auto id = cl->m_classID;

	constexpr std::array breakableIds = // for surface ids ONLY!
	{
		CBaseDoor,
		CBreakableSurface,
	};

	if (const auto it = std::find(std::cbegin(breakableIds), std::cend(breakableIds), id); it != breakableIds.cend()) // if id was found from surface
		return true;

	// there we finally check actual entity
	if (id == CBaseEntity && this->getCollideable()->getSolid() == 1) // can mess with masks, but it's the same
		return true;

	return false;
}

Entity_t* Entity_t::firstMoveChild()
{
	const auto offset = memory::firstMoveChild();
	const auto handle = *reinterpret_cast<CBaseHandle*>((uintptr_t)this + offset);
	return reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientFromHandle(handle));
}

Entity_t* Entity_t::nextMovePeer()
{
	const auto offset = memory::nextMovePeer();
	const auto handle = *reinterpret_cast<CBaseHandle*>((uintptr_t)this + offset);
	return reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientFromHandle(handle));
}

int Entity_t::m_takedamage()
{
	const auto offset = memory::takeDmg();
	return *reinterpret_cast<int*>((uintptr_t)this + offset);
}

IPhysicsObject* Entity_t::vPhysicsGetObject()
{
	const auto offset = memory::vPhysicsGetObject();
	return reinterpret_cast<IPhysicsObject*>((uintptr_t)this + offset);
}

int Entity_t::baseAnimatingDrawModel(int flags, uint8_t alpha)
{
	return memory::baseAnimatingDrawModel()(this, flags, alpha);
}

void Entity_t::setAbsOrigin(const Vec3& origin)
{
	memory::setAbsOrigin()(this, std::cref(origin));
}

void Entity_t::setAbsAngle(const Vec3& angle)
{
	memory::setAbsAngle()(this, std::cref(angle));
}

void Entity_t::setAbsVelocity(const Vec3& velocity)
{
	memory::setAbsVelocity()(this, std::cref(velocity));
}

void Entity_t::stopSound(const char* sample)
{
	memory::stopSound()(this, sample);
}

bool Entity_t::setupBonesShort(Matrix3x4* _out, int maxBones, int mask, float time)
{
	__asm
	{
		mov edi, this
		mov eax, [edi + 0x4]
		lea ecx, [edi + 0x4]
		push time
		push mask
		push maxBones
		push _out
		call dword ptr[eax + 0x34]
	}
}

CUtlVector<Matrix3x4>& Entity_t::m_CachedBoneData()
{
	const auto offset = memory::cachedBones();
	return *reinterpret_cast<CUtlVector<Matrix3x4>*>(uintptr_t(this) + offset);
}

////////////////////////////////////////////////////////////////////////

std::string Weapon_t::getWpnName()
{
	switch (this->m_iItemDefinitionIndex())
	{
	case WEAPON_DEAGLE:					return "DEAGLE";
	case WEAPON_ELITE:					return "DUAL BERETTAS";
	case WEAPON_FIVESEVEN:				return "FIVE-SEVEN";
	case WEAPON_GLOCK:					return "GLOCK";
	case WEAPON_AK47:					return "AK-47";
	case WEAPON_AUG:					return "AUG";
	case WEAPON_AWP:					return "AWP";
	case WEAPON_FAMAS:					return "FAMAS";
	case WEAPON_G3SG1:					return "G3SG1";
	case WEAPON_GALILAR:				return "GAIL";
	case WEAPON_M249:					return "M249";
	case WEAPON_M4A1:					return "M4A1";
	case WEAPON_MAC10:					return "MAC-10";
	case WEAPON_P90:					return "P90";
	case WEAPON_ZONE_REPULSOR:			return "REPULSOR";
	case WEAPON_MP5SD:					return "MP5";
	case WEAPON_UMP45:					return "UMP-45";
	case WEAPON_XM1014:					return "XM1014";
	case WEAPON_BIZON:					return "PP-BIZON";
	case WEAPON_MAG7:					return "MAG-7";
	case WEAPON_NEGEV:					return "NEGEV";
	case WEAPON_SAWEDOFF:				return "SAWEDOFF";
	case WEAPON_TEC9:					return "TEC-9";
	case WEAPON_TASER:					return "TASER";
	case WEAPON_HKP2000:				return "P2000";
	case WEAPON_MP7:					return "MP7";
	case WEAPON_MP9:					return "MP9";
	case WEAPON_NOVA:					return "NOVA";
	case WEAPON_P250:					return "P250";
	case WEAPON_SHIELD:					return "SHIELD";
	case WEAPON_SCAR20:					return "SCAR-20";
	case WEAPON_SG553:					return "SG-553";
	case WEAPON_SSG08:					return "SCOUT";
	case WEAPON_FLASHBANG:				return "FLASHBANG";
	case WEAPON_HEGRENADE:				return "GRENADE";
	case WEAPON_SMOKEGRENADE:			return "SMOKE";
	case WEAPON_MOLOTOV:				return "MOLOTOV";
	case WEAPON_DECOY:					return "DECOY";
	case WEAPON_INCGRENADE:				return "INC NADE";
	case WEAPON_C4:						return "C4";
	case WEAPON_HEALTHSHOT:				return "HEALTHSHOT";
	case WEAPON_KNIFE_T:				return "KNIFE";
	case WEAPON_M4A1_SILENCER:			return "M4A1-S";
	case WEAPON_USP_SILENCER:			return "USP-S";
	case WEAPON_CZ75A:					return "CZ75-A";
	case WEAPON_REVOLVER:				return "REVOLVER";
	case WEAPON_TAGRENADE:				return "TA GRENADE";
	case WEAPON_FISTS:					return "FISTS";
	case WEAPON_BREACHCHARGE:			return "BREACH CHARGE";
	case WEAPON_TABLET:					return "TABLET";
	case WEAPON_MELEE:					return "KNIFE";
	case WEAPON_AXE:					return "AXE";
	case WEAPON_HAMMER:					return "HAMMER";
	case WEAPON_SPANNER:				return "SPANNER";
	case WEAPON_KNIFE_GHOST:			return "KNIFE";
	case WEAPON_FIREBOMB:				return "FIREBOMB";
	case WEAPON_DIVERSION:				return "DIVERSION";
	case WEAPON_FRAG_GRENADE:			return "FRAG NADE";
	case WEAPON_SNOWBALL:				return "SNOWBALL";
	case WEAPON_BUMPMINE:				return "BUMPMINE";
	case WEAPON_KNIFEGG:
	case WEAPON_KNIFE:
	case WEAPON_KNIFE_BAYONET:
	case WEAPON_KNIFE_CSS:
	case WEAPON_KNIFE_FLIP:
	case WEAPON_KNIFE_GUT:
	case WEAPON_KNIFE_KARAMBIT:
	case WEAPON_KNIFE_M9_BAYONET:
	case WEAPON_KNIFE_TACTICAL:
	case WEAPON_KNIFE_FALCHION:
	case WEAPON_KNIFE_SURVIVAL_BOWIE:
	case WEAPON_KNIFE_BUTTERFLY:
	case WEAPON_KNIFE_PUSH:
	case WEAPON_KNIFE_CORD:
	case WEAPON_KNIFE_CANIS:
	case WEAPON_KNIFE_URSUS:
	case WEAPON_KNIFE_GYPSY_JACKKNIFE:
	case WEAPON_KNIFE_OUTDOOR:
	case WEAPON_KNIFE_STILETTO:
	case WEAPON_KNIFE_WIDOWMAKER:
	case WEAPON_KNIFE_SKELETON:			return "KNIFE";
	default:
		return "Err";
	}
}

bool Weapon_t::isRifle()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_RIFLE;
}

bool Weapon_t::isSmg()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_SUBMACHINEGUN;
}

bool Weapon_t::isMachineGun()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_MACHINEGUN;
}

bool Weapon_t::isShotgun()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_SHOTGUN;
}

bool Weapon_t::isPistol()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_PISTOL;
}

bool Weapon_t::isSniper()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_SNIPER_RIFLE;
}

bool Weapon_t::isGrenade()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_GRENADE;
}

bool Weapon_t::isKnife()
{
	if (!this->getWpnInfo())
		return false;

	return this->getWpnInfo()->m_type == WEAPONTYPE_KNIFE;
}

bool Weapon_t::isNonAimable()
{
	const auto idx = m_iItemDefinitionIndex();

	if (idx == WEAPON_C4 || idx == WEAPON_HEALTHSHOT)
		return true;

	if (isKnife())
		return true;

	if (isGrenade())
		return true;

	return false;
}

size_t Weapon_t::getNadeRadius()
{
	switch (this->m_iItemDefinitionIndex())
	{
	case WEAPON_MOLOTOV:
	case WEAPON_INCGRENADE:
		return 180;
	case WEAPON_SMOKEGRENADE:
		return 144;
	case WEAPON_HEGRENADE:
		return 50;
	default:
		return 10; // because we need to somewhat render it, it's fake
	}
}

/////////////////////////////////////////////////////////////////////////////////

CUserCmd& Player_t::m_LastCmd()
{
	const auto offset = memory::lastCommand();
	return *reinterpret_cast<CUserCmd*>((uintptr_t)this + offset);
}

void Player_t::runThink()
{
	checkHasThinkFunction();
	think();
}

// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/c_baseplayer.cpp#L2667
void Player_t::postThink()
{
//#if !defined( NO_ENTITY_PREDICTION )
	MDLCACHE_CRITICAL_SECTION(memory::interfaces::mdlCache());

	if (isAlive())
	{
		updateCollisionBounds();

		//if (!CommentaryModeShouldSwallowInput(this))
		//{
		//	// do weapon stuff
		//	ItemPostFrame();
		//}

		if (m_fFlags() & FL_ONGROUND)
		{
			m_flFallVelocity() = 0;
		}

		// Don't allow bogus sequence on player
		if (m_nSequence() == -1)
		{
			setSequence(0);
		}

		studioFrameAdvance();
		memory::postThinkPhysics()(this);
	}

	// Even if dead simulate entities
	memory::simulateEntities()(this);
//#endif
}

void Player_t::checkHasThinkFunction(bool isThinkingHint)
{
	memory::checkThinkFunction()(this, isThinkingHint);
}

void Player_t::restoreData(const char* context, int slot, int type)
{
	memory::restoreData()(this, context, slot, type);
}

void Player_t::saveData(const char* context, int slot, int type)
{
	memory::saveData()(this, context, slot, type);
}

bool Player_t::usingStandardWeaponsInVehicle()
{
	return memory::usingStandardWeaponsVehicle()(this);
}

bool Player_t::physicsRunThink(thinkmethods_t think)
{
	return memory::physicsRunThink()(this, think);
}

Weapon_t* Player_t::getActiveWeapon()
{
	return reinterpret_cast<Weapon_t*>(memory::interfaces::entList->getClientFromHandle(this->m_hActiveWeapon()));
}

Vec3 Player_t::getHitboxPos(const int id)
{
	if (auto modelStudio = memory::interfaces::modelInfo->getStudioModel(this->getModel()); modelStudio != nullptr)
	{
		if (auto hitbox = modelStudio->getHitboxSet(0)->getHitbox(id); hitbox != nullptr)
		{
			Vec3 min = math::transformVector(hitbox->m_bbmin, m_CachedBoneData().m_memory[hitbox->m_bone]);
			Vec3 max = math::transformVector(hitbox->m_bbmax, m_CachedBoneData().m_memory[hitbox->m_bone]);

			return Vec3{ min + max } *0.5f;
		}
	}

	return {};
}

Vec3 Player_t::getBonePos(const int id)
{
	return m_CachedBoneData().m_memory[id].origin();
}

Vec3 Player_t::getHitgroupPos(const int hitgroup)
{
	if (auto modelStudio = memory::interfaces::modelInfo->getStudioModel(this->getModel()); modelStudio != nullptr)
	{
		if (auto hitbox = modelStudio->getHitboxSet(this->m_nHitboxSet())->getHitbox(hitgroup); hitbox != nullptr)
		{
			Vec3 min = math::transformVector(hitbox->m_bbmin, m_CachedBoneData().m_memory[hitbox->m_bone]);
			Vec3 max = math::transformVector(hitbox->m_bbmax, m_CachedBoneData().m_memory[hitbox->m_bone]);
			return Vec3{ min + max } *0.5f;
		}
	}
	return {};
}

bool Player_t::isC4Owner()
{
	return memory::isC4Owner()(this);
}

std::string Player_t::getName()
{
	PlayerInfo_t info;
	memory::interfaces::engine->getPlayerInfo(this->getIndex(), &info);

	std::string name = info.m_name;

	if (name.length() > 20)
		name = name.substr(0, 20).append("...");

	// use when surface
	/*std::for_each(name.begin(), name.end(), [](char& el)
		{
			if (el < 0 || el > 128)
				el = '?';
		});*/

	return name;
}

std::string_view Player_t::getRawName()
{
	PlayerInfo_t info;
	memory::interfaces::engine->getPlayerInfo(this->getIndex(), &info);

	constexpr auto maxLength = 32U;

	std::array<char, maxLength> buf;
	const auto nameLength = std::min(maxLength - 1, strlen(info.m_name));
	std::memcpy(buf.data(), info.m_name, nameLength);
	buf.back() = '\0';

	return std::string_view{ buf };
}

int Player_t::getKills()
{
	return memory::interfaces::resourceInterface->getKills(this->getIndex());
}

int Player_t::getDeaths()
{
	return memory::interfaces::resourceInterface->getDeaths(this->getIndex());
}

int Player_t::getPing()
{
	return memory::interfaces::resourceInterface->getPing(this->getIndex());
}

std::string Player_t::getRank(bool useShortName)
{
	return memory::interfaces::resourceInterface->getRank(this->getIndex());
}

int Player_t::getWins()
{
	return memory::interfaces::resourceInterface->getWins(this->getIndex());
}

bool Player_t::isPossibleToSee(Player_t* player, const Vec3& pos)
{
	Trace_t tr{ };
	TraceFilter filter{ };
	filter.m_skip = this;
	memory::interfaces::trace->traceRay({ this->getEyePos(), pos }, MASK_PLAYER, &filter, &tr);

	return tr.m_entity == player || tr.m_fraction > 0.97f;
}

bool Player_t::isViewInSmoke(const Vec3& pos)
{
	return memory::throughSmoke()(this->getEyePos(), pos);
}

uintptr_t Player_t::getLiteralAddress()
{
	return *reinterpret_cast<uintptr_t*>(this);
}

CUtlVector<ClientHitVerify_t> Player_t::m_vecBulletVerifyListClient()
{
	const auto offset = memory::vecClientImpacts();
	return *reinterpret_cast<CUtlVector<ClientHitVerify_t>*>((uintptr_t)this + offset);
}

AABB_t Player_t::getOcclusionBounds()
{
	const auto col = this->getCollideable();
	const auto& mins = col->OBBMins();
	const auto& maxs = col->OBBMaxs();

	const auto m_usSolidFlags = col->getSolidFlags();
	const auto m_nSolidType = col->getSolid();

	auto isBoundsDefinedInEntitySpace = [=]()
	{
		return ((m_usSolidFlags & 0x40) == 0) &&
			(m_nSolidType != 2) && (m_nSolidType != 0);
	};

	if (!isBoundsDefinedInEntitySpace() || col->getCollisionAngles().isZero())
	{
		const auto& pos = this->absOrigin();
		return { pos + mins, pos + maxs };
	}
	else
	{
		Matrix3x4 mat = col->collisionToWorldTransform();
		auto [boundsMin, boundsMax] = math::transformAABB(mat, mins, maxs);
		return { boundsMin, boundsMax };
	}
}

#include "../ICvar.hpp"
#include "../ConVar.hpp"

AABB_t Player_t::getCameraBounds()
{
	const static auto occlusion_test_camera_margins = memory::interfaces::cvar->findVar("occlusion_test_camera_margins");
	const static auto occlusion_test_jump_margin = memory::interfaces::cvar->findVar("occlusion_test_jump_margin");

	const auto& pos = this->m_vecOrigin();
	const float cameraMargins = occlusion_test_camera_margins->getFloat();
	const float jumpMargin = occlusion_test_jump_margin->getFloat();

	return {
		pos + Vec3{ 0.0f, 0.0f, 46.0f } - Vec3{ cameraMargins, cameraMargins, 0.0f },
		pos + Vec3{ 0.0f, 0.0f, 64.0f } + Vec3{ cameraMargins, cameraMargins, jumpMargin }
	};
}

bool Player_t::isOtherTeam(Player_t* player)
{
	const static auto mp_teammates_are_enemies = memory::interfaces::cvar->findVar("mp_teammates_are_enemies");
	
	if (this->m_iTeamNum() != player->m_iTeamNum())
		return true;
	else if (mp_teammates_are_enemies->getInt())
		return true;

	return false;
}

////////////////////////////////////////////////////////////////

Vec3 Inferno_t::getInfernoPos(size_t indexFire)
{
	return Vec3
	{
		static_cast<float>(m_fireXDelta()[indexFire]),
		static_cast<float>(m_fireYDelta()[indexFire]),
		static_cast<float>(m_fireZDelta()[indexFire])
	};
}
```

`hack/SDK/structs/Entity.hpp`:

```hpp
#pragma once

#include "../CUtlVector.hpp"
#include "../vars.hpp"
#include "../Enums.hpp"
#include "../math/Vector.hpp"
#include "../math/matrix.hpp"
#include "../math/AABB.hpp"
#include "../varMapping.hpp"
#include "../EHandle.hpp"
#include "indexes.hpp"

#include "../helpers/netvars.hpp"
#include "../helpers/vfunc.hpp"
#include <render/Color.hpp>

class Weapon_t;
class Player_t;
class ClientClass;
class ICollideable;
class AnimationLayer;
struct model_t;
class WeaponInfo;
struct DataMap_t;
class CUserCmd;
class CMoveData;
struct ClientHitVerify_t;
class IPhysicsObject;

/*
* This file is so far probably the easiest when it comes to netvar usage
* You find the netvar - throw table and name, pretty easy
* in my source I accept only "raw" table names for netvars, it's more reliable for me
* Sometimes values need extra adress or are pointers
* Try to keep longer methods in cpp file
*/

////////////////////////////////////////////////////////////////////////////////////////////

// TODO: create real interfaces like game has them stored
#define RENDERABLE 0x4
#define NETWORKABLE 0x8

struct IClientAlphaProperty
{
	VFUNC(void, setAlphaModulation, SET_ALPHA, (uint8_t alpha), (this, alpha));
};

class Entity_t
{
public:
	VFUNC(void, setRefEHandle, SET_HANDLE, (const CBaseHandle& ref), (this, std::cref(ref)));
	VFUNC(const CBaseHandle&, getRefEHandle, GET_HANDLE, (), (this));

	VFUNC(ICollideable*, getCollideable, COLLIDEABLE, (), (this));
	VFUNC(IClientAlphaProperty*, getClientAlphaProperty, GET_CLIENT_ALPHA, (), (this));

	VFUNC(bool, shouldDraw, SHOULD_DRAW, (), (this + RENDERABLE));
	VFUNC(model_t*, getModel, GET_MODEL, (), (this + RENDERABLE));
	VFUNC(int, drawModel, DRAW_MODEL, (int flags, const uint8_t& alpha), (this + RENDERABLE, flags, std::cref(alpha)));
	VFUNC(void, getRenderBounds, RENDER_BOUNDS, (Vec3& mins, Vec3& maxs), (this + RENDERABLE, std::ref(mins), std::ref(maxs)));
	VFUNC(Matrix3x4&, renderableToWorldTransform, RENDERABLE_TO_WORLD, (), (this + RENDERABLE));

	VFUNC(void, release, RELEASE, (), (this + NETWORKABLE));
	VFUNC(ClientClass*, clientClass, CLIENT_CLASS, (), (this + NETWORKABLE));
	VFUNC(void, onPreDataChanged, PRE_DATA_CHANGED, (DataUpdateType_t type), (this + NETWORKABLE, type));
	VFUNC(void, onDataChanged, DATA_CHANGED, (DataUpdateType_t type), (this + NETWORKABLE, type));
	VFUNC(void, preDataUpdate, PRE_DATA_UPDATE, (DataUpdateType_t type), (this + NETWORKABLE, type));
	VFUNC(void, postDataUpdate, POST_DATA_UPDATE, (DataUpdateType_t type), (this + NETWORKABLE, type));
	VFUNC(bool, isDormant, IS_DORMANT, (), (this + NETWORKABLE));
	VFUNC(int, getIndex, GET_INDEX, (), (this + NETWORKABLE));

	NETVAR(Vec3, m_ViewOffset, "DT_BasePlayer", "m_vecViewOffset[0]");
	NETVAR(Vec3, m_vecOrigin, "DT_BaseEntity", "m_vecOrigin");
	NETVAR(CBaseHandle, m_hOwnerEntity, "DT_BaseEntity", "m_hOwnerEntity");
	NETVAR(CBaseHandle, m_hVehicle, "DT_BaseEntity", "m_hVehicle");
	NETVAR(int, m_CollisionGroup, "DT_BaseEntity", "m_CollisionGroup");
	NETVAR(bool, m_bSpotted, "DT_BaseEntity", "m_bSpotted");
	NETVAR(float, m_flSimulationTime, "DT_BaseEntity", "m_flSimulationTime");
	NETVAR(float, m_flMaxspeed, "DT_BasePlayer", "m_flMaxspeed");
	NETVAR_ADDR(int, m_MoveType, "DT_BasePlayer", "m_nRenderMode", 0x1);
	NETVAR(Vec3, m_vecMins, "DT_BaseEntity", "m_vecMins");
	NETVAR(Vec3, m_vecMaxs, "DT_BaseEntity", "m_vecMaxs");
	NETVAR(int, moveparent, "DT_BaseEntity", "moveparent");
	NETVAR(int, m_fEffects, "DT_BaseEntity", "m_fEffects");
	NETVAR(int, m_nModelIndex, "DT_BaseEntity", "m_nModelIndex");
	PTRNETVAR(int, m_nNextThinkTick, "DT_BasePlayer", "m_nNextThinkTick");
	NETVAR_ADDR(int, m_nCreationTick, "DT_BaseEntity", "m_hEffectEntity", 0xC);
	NETVAR_ADDR(bool, m_bCanUseFastPath, "DT_BaseAnimating", "m_flRecoilIndex", 0x4);
	NETVAR_ADDR(bool, m_bDormant, "DT_BaseEntity", "m_fEffects", -0x3);
	NETVAR(SDKColor, m_clrRender, "DT_BaseEntity", "m_clrRender");
	VFUNC(bool, isPlayer, ISPLAYER, (), (this));
	VFUNC(bool, isWeapon, ISWEAPON, (), (this));
	VFUNC(const char*, getClassName, CLASS_NAME, (), (this));
	VFUNC(int, getMaxHealth, GET_MAX_HEALTH, (), (this));
	VFUNC(Vec3&, absOrigin, ABS_ORIGIN, (), (this));
	VFUNC(Vec3&, absAngles, ABS_ANGLE, (), (this));
	
	[[nodiscard]] CUtlVector<Matrix3x4>& m_CachedBoneData();
	[[nodiscard]] Vec3 getAimPunch();
	[[nodiscard]] Vec3 getEyePos();
	[[nodiscard]] AnimationLayer* getAnimOverlays();
	[[nodiscard]] size_t getSequenceActivity(size_t sequence);
	[[nodiscard]] bool isBreakable();
	[[nodiscard]] Entity_t* firstMoveChild();
	[[nodiscard]] Entity_t* nextMovePeer();
	[[nodiscard]] int m_takedamage();
	[[nodiscard]] IPhysicsObject* vPhysicsGetObject();
	int baseAnimatingDrawModel(int flags, uint8_t alpha);
	bool setupBonesShort(Matrix3x4* out, int maxBones, int mask, float time);

	void setAbsOrigin(const Vec3& origin);
	void setAbsAngle(const Vec3& angle);
	void setAbsVelocity(const Vec3& velocity);
	void stopSound(const char* sample);

	template<typename T>
	T cast()
	{
		return static_cast<T>(this);
	}
};

class Weapon_t : public Entity_t
{
public:
	NETVAR(float, m_flNextPrimaryAttack, "DT_BaseCombatWeapon", "m_flNextPrimaryAttack");
	NETVAR(float, m_flNextSecondaryAttack, "DT_BaseCombatWeapon", "m_flNextSecondaryAttack");
	NETVAR(short, m_iItemDefinitionIndex, "DT_BaseAttributableItem", "m_iItemDefinitionIndex");
	NETVAR(int, m_iClip1, "DT_BaseCombatWeapon", "m_iClip1");
	NETVAR(int, m_iClip2, "DT_BaseCombatWeapon", "m_iClip2");
	NETVAR(int, m_iPrimaryReserveAmmoCount, "DT_BaseCombatWeapon", "m_iPrimaryReserveAmmoCount");
	NETVAR(int, m_iEntityQuality, "DT_BaseCombatWeapon", "m_iEntityQuality");
	NETVAR(bool, m_bBurstMode, "DT_BaseCombatWeapon", "m_bBurstMode");
	NETVAR(int, m_iBurstShotsRemaining, "DT_BaseCombatWeapon", "m_iBurstShotsRemaining");
	NETVAR(int, m_zoomLevel, "DT_WeaponCSBaseGun", "m_zoomLevel");
	NETVAR(bool, m_bPinPulled, "DT_BaseCSGrenade", "m_bPinPulled");
	NETVAR(float, m_fThrowTime, "DT_BaseCSGrenade", "m_fThrowTime");
	NETVAR(float, m_flThrowStrength, "DT_BaseCSGrenade", "m_flThrowStrength");
	NETVAR(int, m_nExplodeEffectTickBegin, "DT_BaseCSGrenadeProjectile", "m_nExplodeEffectTickBegin");
	NETVAR(float, m_fAccuracyPenalty, "DT_WeaponCSBase", "m_fAccuracyPenalty");
	NETVAR(float, m_flRecoilIndex, "DT_WeaponCSBaseGun", "m_flRecoilIndex");

	VFUNC(float, getInaccuracy, INACCURACY, (), (this));
	VFUNC(float, getSpread, SPREAD, (), (this));
	VFUNC(WeaponInfo*, getWpnInfo, WEAPONINFO, (), (this));
	VFUNC(void, updateAccuracyPenalty, UPDATE_WEAPON_PENALTY, (), (this));

	[[nodiscard]] std::string getWpnName();

	[[nodiscard]] bool isEmpty() { return m_iClip1() <= 0; }
	[[nodiscard]] bool isRifle();
	[[nodiscard]] bool isSmg();
	[[nodiscard]] bool isMachineGun();
	[[nodiscard]] bool isShotgun();
	[[nodiscard]] bool isPistol();
	[[nodiscard]] bool isSniper();
	[[nodiscard]] bool isGrenade();
	[[nodiscard]] bool isKnife();
	[[nodiscard]] bool isNonAimable();

	[[nodiscard]] size_t getNadeRadius();
};

////////////////////////////////////////////////////////////////////////////////////////////

class Inferno_t : public Entity_t
{
public:
	[[nodiscard]] static float expireTime() { return 7.0f; }
	OFFSET(float, spawnTime, 0x20);
	NETVAR(int, m_fireCount, "DT_Inferno", "m_fireCount");
	PTRNETVAR(int, m_fireXDelta, "DT_Inferno", "m_fireXDelta");
	PTRNETVAR(int, m_fireYDelta, "DT_Inferno", "m_fireYDelta");
	PTRNETVAR(int, m_fireZDelta, "DT_Inferno", "m_fireZDelta");
	[[nodiscard]] Vec3 getInfernoPos(size_t indexFire);
};

////////////////////////////////////////////////////////////////////////////////////////////

class Nade_t : public Entity_t
{
public:
	NETVAR_ADDR(float, m_flSpawnTime, "DT_BaseCSGrenadeProjectile", "m_vecExplodeEffectOrigin", 0xC);
	NETVAR(CBaseHandle, m_hThrower, "DT_BaseCSGrenadeProjectile", "m_hThrower");
	NETVAR(int, m_nExplodeEffectTickBegin, "DT_BaseCSGrenadeProjectile", "m_nExplodeEffectTickBegin");
	NETVAR(Vec3, m_vecVelocity, "DT_BaseCSGrenadeProjectile", "m_vecVelocity");
	NETVAR(Vec3, m_vecOrigin, "DT_BaseCSGrenadeProjectile", "m_vecOrigin");
};

////////////////////////////////////////////////////////////////////////////////////////////

class Smoke_t : public Entity_t
{
public:
	[[nodiscard]] static float expireTime() { return 19.0f; }
	NETVAR(int, m_nSmokeEffectTickBegin, "DT_SmokeGrenadeProjectile", "m_nSmokeEffectTickBegin");
};

////////////////////////////////////////////////////////////////////////////////////////////

class Bomb_t : public Entity_t
{
public:
	NETVAR(float, m_flDefuseCountDown, "DT_PlantedC4", "m_flDefuseCountDown");
	NETVAR(CBaseHandle, m_hBombDefuser, "DT_PlantedC4", "m_hBombDefuser");
	NETVAR(float, m_flC4Blow, "DT_PlantedC4", "m_flC4Blow");
	NETVAR(bool, m_bBombDefused, "DT_PlantedC4", "m_bBombDefused");
	NETVAR(bool, m_nBombSite, "DT_PlantedC4", "m_nBombSite");
	[[nodiscard]] char getBombSiteName() { return m_nBombSite() == 0 ? 'A' : 'B'; }
};

////////////////////////////////////////////////////////////////////////////////////////////

class Player_t : public Entity_t
{
public:
	NETVAR(int, m_iTeamNum, "DT_CSPlayer", "m_iTeamNum");
	NETVAR(Vec3, m_angEyeAngles, "DT_CSPlayer", "m_angEyeAngles");
	NETVAR(Vec3, m_viewPunchAngle, "DT_BasePlayer", "m_viewPunchAngle");
	NETVAR(Vec3, m_aimPunchAngle, "DT_BasePlayer", "m_aimPunchAngle");
	NETVAR(Vec3, m_vecVelocity, "DT_BasePlayer", "m_vecVelocity[0]");
	NETVAR(int, m_iHealth, "DT_CSPlayer", "m_iHealth");
	NETVAR(int, m_ArmorValue, "DT_CSPlayer", "m_ArmorValue");
	NETVAR(bool, m_bIsScoped, "DT_CSPlayer", "m_bIsScoped");
	NETVAR(bool, m_bHasHelmet, "DT_CSPlayer", "m_bHasHelmet");
	NETVAR(int, m_iShotsFired, "DT_CSPlayer", "m_iShotsFired");
	NETVAR(bool, m_bGunGameImmunity, "DT_CSPlayer", "m_bGunGameImmunity");
	NETVAR(float, m_flNextAttack, "DT_CSPlayer", "m_flNextAttack");
	NETVAR(bool, m_bHasDefuser, "DT_CSPlayer", "m_bHasDefuser");
	NETVAR(CBaseHandle, m_hViewModel, "DT_BasePlayer", "m_hViewModel[0]");
	NETVAR(float, m_flLowerBodyYawTarget, "DT_CSPlayer", "m_flLowerBodyYawTarget");
	NETVAR(float, m_flFlashDuration, "DT_CSPlayer", "m_flFlashDuration");
	NETVAR_ADDR(float, m_flFlashBangTime, "DT_CSPlayer", "m_flFlashDuration", -0x10);
	NETVAR_ADDR(float, m_flNightVisionAlpha, "DT_CSPlayer", "m_flFlashDuration", -0x1C);
	NETVAR(bool, m_bNightVisionOn, "DT_CSPlayer", "m_bNightVisionOn");
	NETVAR(int, m_lifeState, "DT_CSPlayer", "m_lifeState");
	NETVAR(int, m_fFlags, "DT_CSPlayer", "m_fFlags");
	NETVAR(int, m_nHitboxSet, "DT_CSPlayer", "m_nHitboxSet");
	NETVAR(int, m_nTickBase, "DT_CSPlayer", "m_nTickBase");
	NETVAR(float, m_flDuckSpeed, "DT_CSPlayer", "m_flDuckSpeed");
	NETVAR(float, m_flDuckAmount, "DT_CSPlayer", "m_flDuckAmount");
	NETVAR(bool, m_bDucked, "DT_CSPlayer", "m_bDucked");
	NETVAR(bool, m_bDucking, "DT_CSPlayer", "m_bDucking");
	NETVAR(float, m_flHealthShotBoostExpirationTime, "DT_CSPlayer", "m_flHealthShotBoostExpirationTime");
	NETVAR(CBaseHandle, m_hObserverTarget, "DT_BasePlayer", "m_hObserverTarget");
	NETVAR(ObserverTypes, m_iObserverMode, "DT_BasePlayer", "m_iObserverMode");
	NETVAR(CBaseHandle, m_hActiveWeapon, "DT_CSPlayer", "m_hActiveWeapon");
	NETVAR(int, m_iAccount, "DT_CSPlayer", "m_iAccount");
	PTRNETVAR(const char, m_szLastPlaceName, "DT_BasePlayer", "m_szLastPlaceName");
	NETVAR(float, m_flFallVelocity, "DT_BasePlayer", "m_flFallVelocity");
	NETVAR(int, m_nSequence, "DT_BaseAnimating", "m_nSequence");
	NETVAR(float, m_flVelocityModifier, "DT_CSPlayer", "m_flVelocityModifier");	
	NETVAR(int, m_iNumRoundKillsHeadshots, "DT_CSPlayer", "m_iNumRoundKillsHeadshots");
	NETVAR(int, m_totalHitsOnServer, "DT_CSPlayer", "m_totalHitsOnServer");
	PTROFFSET(VarMapping_t, getVarMap, 0x24);
	DATAMAP_FIELD(int, m_afButtonLast, getPredictionDataMap(), "m_afButtonLast");
	DATAMAP_FIELD(int, m_afButtonPressed, getPredictionDataMap(), "m_afButtonPressed");
	DATAMAP_FIELD(int, m_afButtonReleased, getPredictionDataMap(), "m_afButtonReleased");
	NETVAR_ADDR(int, m_afButtonForced, "DT_BasePlayer", "m_iDefaultFOV", 0x8);
	NETVAR_ADDR(int, m_afButtonDisabled, "DT_BasePlayer", "m_iDefaultFOV", 0x4);
	PTRNETVAR_ADDR(CUserCmd*, m_pCurrentCommand, "DT_BasePlayer", "m_iDefaultFOV", 0xC);
	NETVAR_ADDR(float, m_flSpawnTime, "DT_CSPlayer", "m_iAddonBits", -0x4);
	NETVAR(int, m_iHideHUD, "DT_CSPlayer", "m_iHideHUD");
	[[nodiscard]] CUserCmd& m_LastCmd();
	PTRDATAMAP_FIELD(int, m_nButtons, getPredictionDataMap(), "m_nButtons");
	PTRDATAMAP_FIELD(int, m_nImpulse, getPredictionDataMap(), "m_nImpulse");
	DATAMAP_FIELD(Vec3, m_vecAbsVelocity, getPredictionDataMap(), "m_vecAbsVelocity");
	DATAMAP_FIELD(Vec3, m_vecNetworkOrigin, getPredictionDataMap(), "m_vecNetworkOrigin");
	DATAMAP_FIELD(int, m_iEFlags, getPredictionDataMap(), "m_iEFlags");
	VFUNC(DataMap_t*, getPredictionDataMap, DATAMAP_PREDICTION, (), (this));
	VFUNC(void, preThink, PRE_THINK, (), (this));
	VFUNC(void, think, THINK, (), (this));
	void runThink();
	void postThink();
	void checkHasThinkFunction(bool isThinkingHint = false);
	void restoreData(const char* context, int slot, int type);
	void saveData(const char* context, int slot, int type);
	VFUNC(void, selectItem, SELECTITEM, (const char* string, int subType = 0), (this, string, subType));
	bool usingStandardWeaponsInVehicle();
	VFUNC(void, updateCollisionBounds, UPDATE_COLLISION_BOUNDS, (), (this));
	VFUNC(void, setSequence, SET_SEQUENCE, (int seq), (this, seq));
	VFUNC(void, studioFrameAdvance, STUDIO_FRAME_ADVANCE, (), (this));
	// VEHICLES ONLY
	VFUNC(void, processMovement, PROCESS_MOVEMENT, (Entity_t* veh, Player_t* player, CMoveData* data), (this, veh, player, data));
	[[nodiscard]] bool physicsRunThink(thinkmethods_t think);
	[[nodiscard]] CUtlVector<ClientHitVerify_t> m_vecBulletVerifyListClient();

	[[nodiscard]] Weapon_t* getActiveWeapon();
	[[nodiscard]] bool isAlive() { return m_iHealth() > 0; }
	[[nodiscard]] bool isInAir() { return !(m_fFlags() & FL_ONGROUND); }
	[[nodiscard]] bool isMoving() { return m_vecVelocity().toVecPrev().length() > 0.1f; }

	[[nodiscard]] Vec3 getHitboxPos(const int id);
	[[nodiscard]] Vec3 getBonePos(const int id);
	[[nodiscard]] Vec3 getHitgroupPos(const int hitgroup);
	[[nodiscard]] bool isC4Owner();
	[[nodiscard]] std::string getName();
	[[nodiscard]] std::string_view getRawName();
	[[nodiscard]] int getKills();
	[[nodiscard]] int getDeaths();
	[[nodiscard]] int getPing();
	[[nodiscard]] std::string getRank(bool useShortName = false);
	[[nodiscard]] int getWins();
	[[nodiscard]] bool isPossibleToSee(Player_t* player, const Vec3& pos);
	[[nodiscard]] bool isViewInSmoke(const Vec3& pos);
	[[nodiscard]] bool isOtherTeam(Player_t* player);
	// address as number
	[[nodiscard]] uintptr_t getLiteralAddress();

	// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/shared/collisionproperty.cpp#L845
	[[nodiscard]] AABB_t getOcclusionBounds();
	// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/server/gameinterface.cpp#L2772
	[[nodiscard]] AABB_t getCameraBounds();
};

////////////////////////////////////////////////////////////////////////////////////////////

class FogController_t : public Entity_t
{
public:
	NETVAR(bool, m_fogenable, "DT_FogController", "m_fog.enable");
	NETVAR(float, m_fogstart, "DT_FogController", "m_fog.start");
	NETVAR(float, m_fogend, "DT_FogController", "m_fog.end");
	NETVAR(float, m_fogmaxdensity, "DT_FogController", "m_fog.maxdensity");
	NETVAR(int, m_fogcolorPrimary, "DT_FogController", "m_fog.colorPrimary");
	NETVAR(int, m_fogcolorSecondary, "DT_FogController", "m_fog.colorSecondary");
};

////////////////////////////////////////////////////////////////////////////////////////////

class EnvTonemapController_t : public Entity_t
{
public:
	NETVAR(bool, m_bUseCustomAutoExposureMin, "DT_EnvTonemapController", "m_bUseCustomAutoExposureMin");
	NETVAR(bool, m_bUseCustomAutoExposureMax, "DT_EnvTonemapController", "m_bUseCustomAutoExposureMax");
	NETVAR(float, m_flCustomAutoExposureMin, "DT_EnvTonemapController", "m_flCustomAutoExposureMin");
	NETVAR(float, m_flCustomAutoExposureMax, "DT_EnvTonemapController", "m_flCustomAutoExposureMax");
	NETVAR(bool, m_bUseCustomBloomScale, "DT_EnvTonemapController", "m_bUseCustomBloomScale");
	NETVAR(float, m_flCustomBloomScale, "DT_EnvTonemapController", "m_flCustomBloomScale");
};

struct SDKColor;

class EnvAmbientLight_t : public Entity_t
{
public:
	NETVAR(SDKColor, m_Color, "DT_EnvAmbientLight", "m_Color");
	NETVAR(Vec3, m_vecColor, "DT_EnvAmbientLight", "m_vecColor");
};

class World_t : public Entity_t
{
public:
	NETVAR(Vec3, m_WorldMins, "DT_World", "m_WorldMins");
	NETVAR(Vec3, m_WorldMaxs, "DT_World", "m_WorldMaxs");
};

#include "../CUtlReference.hpp"

class Precipitation_t : public Entity_t
{
public:
	NETVAR(PrecipitationType_t, m_nPrecipType, "DT_Precipitation", "m_nPrecipType");
	OFFSET(const char*, m_pParticleOuterDef, 0xA70);
	OFFSET(const char*, m_pParticleInnerNearDef, 0xA68);
	OFFSET(const char*, m_pParticleInnerFarDef, 0xA6C);
	OFFSET(bool, m_bParticlePrecipInitialized, 0xAA1);
	OFFSET(float, m_flParticleInnerDist, 0xA64);
	OFFSET(float, m_flDensity, 0xA08);
};

class CascadeLight_t : public Entity_t
{
public:
	// this field does nothing
	NETVAR(bool, m_bEnabled, "DT_CascadeLight", "m_bEnabled");
	NETVAR(int, m_LightColor, "DT_CascadeLight", "m_LightColor");
	NETVAR(int, m_LightColorScale, "DT_CascadeLight", "m_LightColorScale");
	NETVAR(float, m_flMaxShadowDist, "DT_CascadeLight", "m_flMaxShadowDist");
};

class DynamicLight_t : public Entity_t
{
public:
	NETVAR(int, m_Flags, "DT_DynamicLight", "m_Flags");
	NETVAR(int, m_LightStyle, "DT_DynamicLight", "m_LightStyle");
	NETVAR(float, m_Radius, "DT_DynamicLight", "m_Radius");
	NETVAR(int, m_Exponent, "DT_DynamicLight", "m_Exponent");
	NETVAR(float, m_InnerAngle, "DT_DynamicLight", "m_InnerAngle");
	NETVAR(float, m_OuterAngle, "DT_DynamicLight", "m_OuterAngle");
	NETVAR(float , m_SpotRadius, "DT_DynamicLight", "m_SpotRadius");
};

// localplayer data
class Skybox_t : public Entity_t
{
public:
	NETVAR(int, m_skybox3dscale, "DT_Local", "m_skybox3d.scale");
	NETVAR(Vec3, m_skybox3dorigin, "DT_Local", "m_skybox3d.origin");
	NETVAR(int, m_skybox3darea, "DT_Local", "m_skybox3d.area");
};

class Sun_t : public Entity_t
{
public:
	NETVAR(bool, m_bOn, "DT_Sun", "m_bOn");
	NETVAR(int, m_nSize, "DT_Sun", "m_nSize");
	NETVAR(int, m_clrOverlay, "DT_Sun", "m_clrOverlay");
	NETVAR(int, m_nOverlaySize, "DT_Sun", "m_nOverlaySize");
	NETVAR(float, HDRColorScale, "DT_Sun", "HDRColorScale");
};

#undef RENDERABLE
#undef NETWORKABLE
#undef THINKABLE
#undef ALPHA_PROP

////////////////////////////////////////////////////////////////////////////////////////////
```

`hack/SDK/structs/indexes.hpp`:

```hpp
#pragma once

enum VTableIndexes
{
	ISPLAYER = 158,
	ISWEAPON = 166,
	INACCURACY = 483,
	SPREAD = 453,
	WEAPONINFO = 461,
	PUNCH = 346,
	EYE_POS = 285,
	ABS_ORIGIN = 10,
	ABS_ANGLE = 11,
	CLIENT_CLASS = 2,
	COLLIDEABLE = 3,
	GET_INDEX = 10,
	RENDER_BOUNDS = 17,
	SETUP_BONES = 13,
	GET_MODEL = 8,
	GET_MODEL_INDEX = 9,
	DRAW_MODEL = 9,
	IS_DORMANT = 9,
	RENDERABLE_TO_WORLD = 32,
	RELEASE = 1,
	PRE_DATA_CHANGED = 4,
	DATA_CHANGED = 5,
	PRE_DATA_UPDATE = 6,
	POST_DATA_UPDATE = 7,
	DATAMAP_PREDICTION = 17,
	PRE_THINK = 318,
	THINK = 139,
	UPDATE_WEAPON_PENALTY = 484,
	UPDATE_COLLISION_BOUNDS = 340,
	POST_THINK = 319,
	SET_SEQUENCE = 219,
	STUDIO_FRAME_ADVANCE = 220,
	SELECTITEM = 330,
	PROCESS_MOVEMENT = 5,
	CLIENT_THINK = 1,
	CLASS_NAME = 143,
	GET_MAX_HEALTH = 123,
	IS_MAX_HEALTH = 122,
	SHOULD_DRAW = 3,
	SET_ALPHA = 1,
	GET_CLIENT_ALPHA = 9,
	GET_HANDLE = 2,
	SET_HANDLE = 1
};
```

`hack/SDK/varMapping.hpp`:

```hpp
#pragma once

#include "CUtlVector.hpp"

class VarMapEntry_t
{
public:
	uint16_t m_type;
	uint16_t m_needsToInterpolate;	// Set to false when this var doesn't
	// need Interpolate() called on it anymore.
	void* m_data;
	/*IInterpolatedVar**/ void* m_watcher;
};

struct VarMapping_t
{
	constexpr VarMapping_t() :
		m_interpolatedEntries{ 0 }
	{}

	CUtlVector<VarMapEntry_t> m_Entries;
	int	m_interpolatedEntries;
	float m_lastInterpolationTime;
};
```

`hack/SDK/vars.hpp`:

```hpp
#pragma once

#pragma region bone_masks
#define BONE_CALCULATE_MASK			0x1F
#define BONE_PHYSICALLY_SIMULATED	0x01	// bone is physically simulated when physics are active
#define BONE_PHYSICS_PROCEDURAL		0x02	// procedural when physics is active
#define BONE_ALWAYS_PROCEDURAL		0x04	// bone is always procedurally animated
#define BONE_SCREEN_ALIGN_SPHERE	0x08	// bone aligns to the screen, not constrained in motion.
#define BONE_SCREEN_ALIGN_CYLINDER	0x10	// bone aligns to the screen, constrained by it's own axis.

#define BONE_USED_MASK				0x0007FF00
#define BONE_USED_BY_ANYTHING		0x0007FF00
#define BONE_USED_BY_HITBOX			0x00000100	// bone (or child) is used by a hit box
#define BONE_USED_BY_ATTACHMENT		0x00000200	// bone (or child) is used by an attachment point
#define BONE_USED_BY_VERTEX_MASK	0x0003FC00
#define BONE_USED_BY_VERTEX_LOD0	0x00000400	// bone (or child) is used by the toplevel model via skinned vertex
#define BONE_USED_BY_VERTEX_LOD1	0x00000800
#define BONE_USED_BY_VERTEX_LOD2	0x00001000
#define BONE_USED_BY_VERTEX_LOD3	0x00002000
#define BONE_USED_BY_VERTEX_LOD4	0x00004000
#define BONE_USED_BY_VERTEX_LOD5	0x00008000
#define BONE_USED_BY_VERTEX_LOD6	0x00010000
#define BONE_USED_BY_VERTEX_LOD7	0x00020000
#define BONE_USED_BY_BONE_MERGE		0x00040000	// bone is available for bone merge to occur against it

// 256 actually, correct me if I am wrong, but for simple stuff such as getbone or gethitbox to 3d pos
// there is no need to go with its 256 value
#define MAX_BONES 128
#pragma endregion

#pragma region player_masks
// CBaseEntity::m_fFlags
// PLAYER SPECIFIC FLAGS FIRST BECAUSE WE USE ONLY A FEW BITS OF NETWORK PRECISION
#define	FL_ONGROUND				(1<<0)	// At rest / on the ground
#define FL_DUCKING				(1<<1)	// Player flag -- Player is fully crouched
#define	FL_WATERJUMP			(1<<3)	// player jumping out of water
#define FL_ONTRAIN				(1<<4) // Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_INRAIN				(1<<5)	// Indicates the entity is standing in rain
#define FL_FROZEN				(1<<6) // Player is frozen for 3rd person camera
#define FL_ATCONTROLS			(1<<7) // Player can't move, but keeps key inputs for controlling another entity
#define	FL_CLIENT				(1<<8)	// Is a player
#define FL_FAKECLIENT			(1<<9)	// Fake client, simulated server side; don't send network messages to them
#define	FL_INWATER				(1<<10)	// In water

// NOTE if you move things up, make sure to change this value
#define PLAYER_FLAG_BITS		11

// NON-PLAYER SPECIFIC (i.e., not used by GameMovement or the client .dll ) -- Can still be applied to players, though
#define	FL_FLY					(1<<11)	// Changes the SV_Movestep() behavior to not need to be on ground
#define	FL_SWIM					(1<<12)	// Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)
#define	FL_CONVEYOR				(1<<13)
#define	FL_NPC					(1<<14)
#define	FL_GODMODE				(1<<15)
#define	FL_NOTARGET				(1<<16)
#define	FL_AIMTARGET			(1<<17)	// set if the crosshair needs to aim onto the entity
#define	FL_PARTIALGROUND		(1<<18)	// not all corners are valid
#define FL_STATICPROP			(1<<19)	// Eetsa static prop!
#define FL_GRAPHED				(1<<20) // worldgraph has this ent listed as something that blocks a connection
#define FL_GRENADE				(1<<21)
#define FL_STEPMOVEMENT			(1<<22)	// Changes the SV_Movestep() behavior to not do any processing
#define FL_DONTTOUCH			(1<<23)	// Doesn't generate touch functions, generates Untouch() for anything it was touching when this flag was set
#define FL_BASEVELOCITY			(1<<24)	// Base velocity has been applied this frame (used to convert base velocity into momentum)
#define FL_WORLDBRUSH			(1<<25)	// Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)
#define FL_OBJECT				(1<<26) // Terrible name. This is an object that NPCs should see. Missiles, for example.
#define FL_KILLME				(1<<27)	// This entity is marked for death -- will be freed by game DLL
#define FL_ONFIRE				(1<<28)	// You know...
#define FL_DISSOLVING			(1<<29) // We're dissolving!
#define FL_TRANSRAGDOLL			(1<<30) // In the process of turning into a client side ragdoll.
#define FL_UNBLOCKABLE_BY_PLAYER (1<<31) // pusher that can't be blocked by the player


#define IN_ATTACK  (1 << 0)
#define IN_JUMP   (1 << 1)
#define IN_DUCK   (1 << 2)
#define IN_FORWARD  (1 << 3)
#define IN_BACK   (1 << 4)
#define IN_USE   (1 << 5)
#define IN_CANCEL  (1 << 6)
#define IN_LEFT   (1 << 7)
#define IN_RIGHT  (1 << 8)
#define IN_MOVELEFT  (1 << 9)
#define IN_MOVERIGHT (1 << 10)
#define IN_ATTACK2  (1 << 11)
#define IN_RUN   (1 << 12)
#define IN_RELOAD  (1 << 13)
#define IN_ALT1   (1 << 14)
#define IN_ALT2   (1 << 15)
#define IN_SCORE  (1 << 16)
#define IN_SPEED  (1 << 17)
#define IN_WALK   (1 << 18)
#define IN_ZOOM   (1 << 19)
#define IN_WEAPON1  (1 << 20)
#define IN_WEAPON2  (1 << 21)
#define IN_BULLRUSH  (1 << 22)
#define IN_GRENADE1  (1 << 23)
#define IN_GRENADE2  (1 << 24)
#define IN_LOOKSPIN  (1 << 25)
#pragma endregion

#pragma region texture_names
#define TEXTURE_GROUP_LIGHTMAP						"Lightmaps"
#define TEXTURE_GROUP_WORLD							"World textures"
#define TEXTURE_GROUP_MODEL							"Model textures"
#define TEXTURE_GROUP_STATIC_PROP					"StaticProp textures"
#define TEXTURE_GROUP_COMBINED						"Combined Textures"
#define TEXTURE_GROUP_COMPOSITE						"Composited Textures"
#define TEXTURE_GROUP_VGUI							"VGUI textures"
#define TEXTURE_GROUP_PARTICLE						"Particle textures"
#define TEXTURE_GROUP_DECAL							"Decal textures"
#define TEXTURE_GROUP_SKYBOX						"SkyBox textures"
#define TEXTURE_GROUP_CLIENT_EFFECTS				"ClientEffect textures"
#define TEXTURE_GROUP_OTHER							"Other textures"
#define TEXTURE_GROUP_PRECACHED						"Precached"				// TODO: assign texture groups to the precached materials
#define TEXTURE_GROUP_CUBE_MAP						"CubeMap textures"
#define TEXTURE_GROUP_RENDER_TARGET					"RenderTargets"
#define TEXTURE_GROUP_UNACCOUNTED					"Unaccounted textures"	// Textures that weren't assigned a texture group.
//#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER		"Static Vertex"
#define TEXTURE_GROUP_STATIC_INDEX_BUFFER			"Static Indices"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_DISP		"Displacement Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_COLOR	"Lighting Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_WORLD	"World Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_MODELS	"Model Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_OTHER	"Other Verts"
#define TEXTURE_GROUP_DYNAMIC_INDEX_BUFFER			"Dynamic Indices"
#define TEXTURE_GROUP_DYNAMIC_VERTEX_BUFFER			"Dynamic Verts"
#define TEXTURE_GROUP_DEPTH_BUFFER					"DepthBuffer"
#define TEXTURE_GROUP_VIEW_MODEL					"ViewModel"
#define TEXTURE_GROUP_PIXEL_SHADERS					"Pixel Shaders"
#define TEXTURE_GROUP_VERTEX_SHADERS				"Vertex Shaders"
#define TEXTURE_GROUP_RENDER_TARGET_SURFACE			"RenderTarget Surfaces"
#define TEXTURE_GROUP_MORPH_TARGETS					"Morph Targets"
#define TEXTURE_GROUP_SCALEFORM						"Scaleform textures"
#pragma endregion

#pragma region content_masks
#define	CONTENTS_EMPTY			0		// No contents

#define	CONTENTS_SOLID			0x1		// an eye is never valid in a solid
#define	CONTENTS_WINDOW			0x2		// translucent, but not watery (glass)
#define	CONTENTS_AUX			0x4
#define	CONTENTS_GRATE			0x8		// alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't
#define	CONTENTS_SLIME			0x10
#define	CONTENTS_WATER			0x20
#define	CONTENTS_BLOCKLOS		0x40	// block AI line of sight
#define CONTENTS_OPAQUE			0x80	// things that cannot be seen through (may be non-solid though)
#define	LAST_VISIBLE_CONTENTS	0x80
#define ALL_VISIBLE_CONTENTS (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1))

#define CONTENTS_TESTFOGVOLUME	0x100
#define CONTENTS_UNUSED			0x200	

// unused 
// NOTE: If it's visible, grab from the top + update LAST_VISIBLE_CONTENTS
// if not visible, then grab from the bottom.
#define CONTENTS_UNUSED6		0x400

#define CONTENTS_TEAM1			0x800	// per team contents used to differentiate collisions 
#define CONTENTS_TEAM2			0x1000	// between players and objects on different teams

// ignore CONTENTS_OPAQUE on surfaces that have SURF_NODRAW
#define CONTENTS_IGNORE_NODRAW_OPAQUE	0x2000

// hits entities which are MOVETYPE_PUSH (doors, plats, etc.)
#define CONTENTS_MOVEABLE		0x4000

// remaining contents are non-visible, and don't eat brushes
#define	CONTENTS_AREAPORTAL		0x8000

#define	CONTENTS_PLAYERCLIP		0x10000
#define	CONTENTS_MONSTERCLIP	0x20000

// currents can be added to any other contents, and may be mixed
#define	CONTENTS_CURRENT_0		0x40000
#define	CONTENTS_CURRENT_90		0x80000
#define	CONTENTS_CURRENT_180	0x100000
#define	CONTENTS_CURRENT_270	0x200000
#define	CONTENTS_CURRENT_UP		0x400000
#define	CONTENTS_CURRENT_DOWN	0x800000

#define	CONTENTS_ORIGIN			0x1000000	// removed before bsping an entity

#define	CONTENTS_MONSTER		0x2000000	// should never be on a brush, only in game
#define	CONTENTS_DEBRIS			0x4000000
#define	CONTENTS_DETAIL			0x8000000	// brushes to be added after vis leafs
#define	CONTENTS_TRANSLUCENT	0x10000000	// auto set if any surface has trans
#define	CONTENTS_LADDER			0x20000000
#define CONTENTS_HITBOX			0x40000000	// use accurate hitboxes on trace


#define	CONTENTS_ORIGIN			0x1000000	// removed before bsping an entity

#define	CONTENTS_MONSTER		0x2000000	// should never be on a brush, only in game
#define	CONTENTS_DEBRIS			0x4000000
#define	CONTENTS_DETAIL			0x8000000	// brushes to be added after vis leafs
#define	CONTENTS_TRANSLUCENT	0x10000000	// auto set if any surface has trans
#define	CONTENTS_LADDER			0x20000000
#define CONTENTS_HITBOX			0x40000000	// use accurate hitboxes on trace
#pragma endregion

#pragma region masks
#define MASK_ALL						(0xFFFFFFFF)
#define MASK_SOLID						(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define MASK_PLAYERSOLID				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define MASK_NPCSOLID					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define MASK_NPCFLUID					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define MASK_WATER						(CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME)
#define MASK_OPAQUE						(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE)
#define MASK_OPAQUE_AND_NPCS			(MASK_OPAQUE|CONTENTS_MONSTER)
#define MASK_BLOCKLOS					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS)
#define MASK_BLOCKLOS_AND_NPCS			(MASK_BLOCKLOS|CONTENTS_MONSTER)
#define MASK_VISIBLE					(MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define MASK_VISIBLE_AND_NPCS			(MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define MASK_SHOT						(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)
#define MASK_SHOT_BRUSHONLY				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_DEBRIS)
#define MASK_SHOT_HULL					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE)
#define MASK_SHOT_PORTAL				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define MASK_SOLID_BRUSHONLY			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE)
#define MASK_PLAYERSOLID_BRUSHONLY		(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE)
#define MASK_NPCSOLID_BRUSHONLY			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define MASK_NPCWORLDSTATIC				(CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define MASK_NPCWORLDSTATIC_FLUID		(CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP)
#define MASK_SPLITAREAPORTAL			(CONTENTS_WATER|CONTENTS_SLIME)
#define MASK_CURRENT					(CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN)
#define MASK_DEADSOLID					(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE)
#define	MASK_PLAYER						(CONTENTS_HITBOX|CONTENTS_MONSTER|CONTENTS_DEBRIS|CONTENTS_MOVEABLE|CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_GRATE)
#pragma endregion

#pragma region netflows
#define FLOW_OUTGOING	0
#define FLOW_INCOMING	1
#define MAX_FLOWS		2		// in & out
#pragma endregion

#pragma region create_render_flags
#define CREATERENDERTARGETFLAGS_HDR				0x00000001
#define CREATERENDERTARGETFLAGS_AUTOMIPMAP		0x00000002
#define CREATERENDERTARGETFLAGS_UNFILTERABLE_OK 0x00000004
#pragma endregion

#pragma region edicts
// How many bits to use to encode an edict.
#define	MAX_EDICT_BITS				11			// # of bits needed to represent max edicts
// Max # of edicts in a level
#define	MAX_EDICTS					(1<<MAX_EDICT_BITS)

// How many bits to use to encode an server class index
#define MAX_SERVER_CLASS_BITS		9
// Max # of networkable server classes
#define MAX_SERVER_CLASSES			(1<<MAX_SERVER_CLASS_BITS)
#pragma endregion

// no idea how to call it
#pragma region defs_unknown_name
#define TICK_NEVER_THINK		( -1 )
#pragma endregion

#pragma region studio_render
#define STUDIO_NONE						0x00000000
#define STUDIO_RENDER					0x00000001
#define STUDIO_VIEWXFORMATTACHMENTS		0x00000002
#define STUDIO_DRAWTRANSLUCENTSUBMODELS 0x00000004
#define STUDIO_TWOPASS					0x00000008
#define STUDIO_STATIC_LIGHTING			0x00000010
#define STUDIO_WIREFRAME				0x00000020
#define STUDIO_ITEM_BLINK				0x00000040
#define STUDIO_NOSHADOWS				0x00000080
#define STUDIO_WIREFRAME_VCOLLIDE		0x00000100
#define STUDIO_NOLIGHTING_OR_CUBEMAP	0x00000200
#define STUDIO_SKIP_FLEXES				0x00000400
#define STUDIO_DONOTMODIFYSTENCILSTATE	0x00000800
#define STUDIO_DEPTH_ONLY				0x01000000
#define STUDIO_AOPREPASSTEXURE			0x02000000
#define STUDIO_KEEP_SHADOWS				0x04000000
#define STUDIO_SSAODEPTHTEXTURE			0x08000000
#define STUDIO_TRANSPARENCY				0x80000000
#define STUDIO_SHADOWDEPTHTEXTURE		0x40000000
#define STUDIO_SHADOWTEXTURE			0x20000000
#define STUDIO_SKIP_DECALS				0x10000000
#pragma endregion

#pragma region slots
// How many data slots to use when in multiplayer.
#define MULTIPLAYER_BACKUP			150
#pragma endregion

#pragma region hud_flags
// Hud Element hiding flags
#define	HIDEHUD_WEAPONSELECTION		( 1<<0 )	// Hide ammo count & weapon selection
#define	HIDEHUD_FLASHLIGHT			( 1<<1 )
#define	HIDEHUD_ALL					( 1<<2 )
#define HIDEHUD_HEALTH				( 1<<3 )	// Hide health & armor / suit battery
#define HIDEHUD_PLAYERDEAD			( 1<<4 )	// Hide when local player's dead
#define HIDEHUD_NEEDSUIT			( 1<<5 )	// Hide when the local player doesn't have the HEV suit
#define HIDEHUD_MISCSTATUS			( 1<<6 )	// Hide miscellaneous status elements (trains, pickup history, death notices, etc)
#define HIDEHUD_CHAT				( 1<<7 )	// Hide all communication elements (saytext, voice icon, etc)
#define	HIDEHUD_CROSSHAIR			( 1<<8 )	// Hide crosshairs
#define	HIDEHUD_VEHICLE_CROSSHAIR	( 1<<9 )	// Hide vehicle crosshair
#define HIDEHUD_INVEHICLE			( 1<<10 )
#define HIDEHUD_BONUS_PROGRESS		( 1<<11 )	// Hide bonus progress display (for bonus map challenges)
#define HIDEHUD_RADAR				( 1<<12 )   // Hides the radar in CS1.5
#define HIDEHUD_MINISCOREBOARD      ( 1<<13 )   // Hides the miniscoreboard in CS1.5
#pragma endregion

#pragma region dmg_type
#define	DAMAGE_NO				0
#define DAMAGE_EVENTS_ONLY		1		// Call damage functions, but don't modify health
#define	DAMAGE_YES				2
#define	DAMAGE_AIM				3
#pragma endregion

#pragma region qlimits
#define MAX_NUM_ARGVS	50

// SYSTEM INFO
#define	MAX_QPATH		96			// max length of a game pathname
#define	MAX_OSPATH		260			// max length of a filesystem pathname

#define	ON_EPSILON		0.1			// point on plane side epsilon


// Resource counts;
// Must have this value in sync(-1) with const.h and effect_dispatch_data.cpp
#define MAX_MODEL_INDEX_BITS	12   // sent as a short
#define	MAX_MODELS				(1<<MAX_MODEL_INDEX_BITS)

#define MAX_GENERIC_INDEX_BITS	9
#define MAX_GENERIC				(1<<MAX_GENERIC_INDEX_BITS)
#define MAX_DECAL_INDEX_BITS	9
#define MAX_BASE_DECALS			(1<<MAX_DECAL_INDEX_BITS)
#pragma endregion
```

`hack/api.cpp`:

```cpp
#include "api.hpp"

#include <ShObjIdl_core.h>

std::filesystem::path api::getDocumentsPath()
{
	if (static CHAR documents[MAX_PATH]; SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, documents)))
		return std::filesystem::path{ documents };
	
	messageBox("Couldn't find windows documents path", "Documents Error");
	return {};
}

std::filesystem::path api::getHackPath()
{
	std::filesystem::path toReturn;
	toReturn.assign(getDocumentsPath() / localization.path);
	return toReturn;
}

std::string api::getDefaultConfigName()
{
	return localization.defaultConfigName;
}

std::filesystem::path api::getExtraLoadPath()
{
	return localization.utilityPath;
}
```

`hack/api.hpp`:

```hpp
#pragma once

#if defined _DEBUG
#define WANT_EXCEPTIONS
#endif

#if defined WANT_EXCEPTIONS
// nothing
#else
#define JSON_NOEXCEPTION 1
#endif

#if defined WANT_EXCEPTIONS
#include <stdexcept>
#define HACK_CATCH_TYPE std::runtime_error
#else
#define HACK_CATCH_TYPE
#endif

#include <Windows.h>
#include <format>

#if defined WANT_EXCEPTIONS
#define HACK_TRY try
#define HACK_CATCH(exception) catch(exception)
#define HACK_THROW(exception) throw HACK_CATCH_TYPE{ exception }
#else
#define HACK_TRY if(true)
#define HACK_CATCH(exception) if(false)
#define HACK_THROW(exception) { const int res = api::messageBox(std::string{ exception }.c_str(), "Exception throw!", MB_TASKMODAL | MB_ICONERROR | MB_YESNOCANCEL); res; /*do smth with res*/  }
#endif

#define HACK_FASTCALL __fastcall
#define HACK_THISCALL __thiscall
#define HACK_STDCALL __stdcall
#define HACK_CDECL __cdecl

#define HACK_THISPTR void* thisptr
#define HACK_FAST_ARGS [[maybe_unused]] HACK_THISPTR, [[maybe_unused]] void* edx

// mark functions implicitly that will execute in dllmain
#define HACK_INIT

extern "C" BOOL WINAPI _CRT_INIT(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);

#include <filesystem>

namespace api
{
	inline int messageBox(const char* text, const char* caption, int flags = MB_ICONERROR | MB_OK)
	{
		return MessageBoxA(nullptr, text, caption, flags);
	}

	struct Localization
	{
		std::filesystem::path path;
		std::string defaultConfigName;
		std::filesystem::path utilityPath;
		std::string defaultLoadName;
	};

	inline const Localization localization
	{
		.path = std::filesystem::path{ "Bartis_internal" } / "csgo",
		.defaultConfigName = "default.cfg",
		.utilityPath = "utility",
		.defaultLoadName = "load.LOAD"
	};

	[[nodiscard]] std::filesystem::path getDocumentsPath();
	[[nodiscard]] std::filesystem::path getHackPath();
	[[nodiscard]] std::string getDefaultConfigName();
	[[nodiscard]] std::filesystem::path getExtraLoadPath();
}
```

`hack/cheats/features/backtrack/backteack.cpp`:

```cpp
#include "backtrack.hpp"

#include "../cache/cache.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/vars.hpp>
#include <SDK/Enums.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>

#include <cheats/hooks/createMove.hpp>
#include <cheats/hooks/frameStageNotify.hpp>

namespace
{
	struct BacktrackCMHandler : hooks::CreateMove
	{
		BacktrackCMHandler()
		{
			this->registerInit(backtrack::init);
			this->registerRunPrediction(backtrack::run);
		}
	} handlerCM;

	struct BacktrackStageHandler : hooks::FrameStageNotify
	{
		BacktrackStageHandler()
		{
			this->registerRun(backtrack::updater::run);
		}
	} handlerFSN;
}

namespace backtrack
{
	IConVar* cl_updaterate{ nullptr };
	IConVar* sv_maxupdaterate{ nullptr };
	IConVar* cl_interp{ nullptr };
	IConVar* cl_interp_ratio{ nullptr };
	IConVar* sv_client_min_interp_ratio{ nullptr };
	IConVar* sv_client_max_interp_ratio{ nullptr };
	IConVar* sv_maxunlag{ nullptr };
	float correctTime{ };

	float extraTicks();
}

void backtrack::init()
{
	cl_updaterate = memory::interfaces::cvar->findVar("cl_updaterate");
	sv_maxupdaterate = memory::interfaces::cvar->findVar("sv_maxupdaterate");

	cl_interp = memory::interfaces::cvar->findVar("cl_interp");
	cl_interp_ratio = memory::interfaces::cvar->findVar("cl_interp_ratio");
	sv_client_min_interp_ratio = memory::interfaces::cvar->findVar("sv_client_min_interp_ratio");
	sv_client_max_interp_ratio = memory::interfaces::cvar->findVar("sv_client_max_interp_ratio");
	sv_maxunlag = memory::interfaces::cvar->findVar("sv_maxunlag");
};

float backtrack::getLerp()
{
	float updateRate = sv_maxupdaterate ? sv_maxupdaterate->getFloat() : cl_updaterate->getFloat();
	float ratio = cl_interp_ratio->getFloat() == 0.0f ? 1.0f : cl_interp_ratio->getFloat();

	ratio = std::clamp(ratio, sv_client_min_interp_ratio->getFloat(), sv_client_max_interp_ratio->getFloat());
	return std::max(cl_interp->getFloat(), (ratio / updateRate));
}

bool backtrack::isValid(float simtime)
{
	const auto network = memory::interfaces::engine->getNameNetChannel();
	if (!network)
		return false;

	if (auto time = static_cast<int>(game::serverTime() - sv_maxunlag->getFloat()); simtime < time)
	{
		//printf("simtime precheck, sim %f lag sim %f\n", simtime, game::serverTime() - cvarsRatios.maxUnlag);
		return false;
	}

	const auto delta = std::clamp(network->getLatency(FLOW_OUTGOING) + network->getLatency(FLOW_INCOMING) + getLerp(),
		0.0f, sv_maxunlag->getFloat()) - (game::serverTime() - simtime);
	return std::abs(delta) <= 0.2f;
}

float backtrack::extraTicks()
{
	if (!vars::misc->fakeLatency->enabled)
		return 0.0f;

	return vars::misc->fakeLatency->amount / 1000.0f;
}

void backtrack::run(CUserCmd* cmd)
{
	if (!vars::backtrack->enabled)
		return;

	if (!game::localPlayer)
		return;

	if (!game::localPlayer->isAlive())
		return;

	if (!(cmd->m_buttons & IN_ATTACK))
		return;

	float bestFov = 180.0f;
	Player_t* bestPlayer = nullptr;
	int bestPlayerIdx = -1;
	int bestRecordIdx = -1;
	Vec3 bestPos = {};

	const auto aimPunch = game::localPlayer->getAimPunch();
	const auto myEye = game::localPlayer->getEyePos();

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		auto ent = reinterpret_cast<Player_t*>(entity);

		if (ent == game::localPlayer)
			continue;

		if (!ent->isAlive())
			continue;

		if (ent->isDormant())
			continue;

		if (!ent->isOtherTeam(game::localPlayer()))
			continue;

		const auto& pos = ent->absOrigin();

		const auto fov = math::calcFovReal(myEye, pos, cmd->m_viewangles + aimPunch);
		if (fov < bestFov)
		{
			bestFov = fov;
			bestPlayer = ent;
			bestPlayerIdx = idx;
			bestPos = pos;
		}
	}

	if (bestPlayer)
	{
		if (game::localPlayer->m_flFlashDuration() > 0.0f)
		{
			if (game::localPlayer->m_flFlashBangTime() >= vars::backtrack->flashLimit)
				return;
		}

		if (vars::backtrack->smoke && game::localPlayer->isViewInSmoke(bestPos))
			return;

		bestFov = 180.0f;

		for (size_t i = 0; const auto & el : records.at(bestPlayerIdx))
		{
			if (!isValid(el.simtime))
				continue;

			const auto fov = math::calcFovReal(myEye, el.head, cmd->m_viewangles + aimPunch);

			if (fov < bestFov)
			{
				bestFov = fov;
				bestRecordIdx = i;
			}

			i++;
		}
	}

	if (bestRecordIdx != -1)
	{
		const auto& record = records.at(bestPlayerIdx).at(bestRecordIdx);

		auto simTimeCorrected = record.simtime;
		if (auto deltaLerp = getLerp() - memory::interfaces::globalVars->m_intervalPerTick; deltaLerp > 0.0f)
			simTimeCorrected += memory::interfaces::globalVars->m_intervalPerTick - deltaLerp;

		cmd->m_tickcount = game::timeToTicks(simTimeCorrected + getLerp());
	}
}

void backtrack::updater::run(FrameStage stage)
{
	correctTime = vars::backtrack->time / 1000.0f + extraTicks();

	if (stage != FRAME_RENDER_START)
		return;

	if (!game::isAvailable())
		return;

	if (!vars::backtrack->enabled || !game::localPlayer->isAlive())
	{
		for (auto& el : records)
			el.clear();
		return;
	}

	constexpr auto isGoodEnt = [](Player_t* ent)
	{
		if (ent == game::localPlayer)
			return false;

		if (ent->isDormant())
			return false;

		if (!ent->isAlive())
			return false;

		if (!ent->isOtherTeam(game::localPlayer()))
			return false;

		return true;
	};

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		const auto ent = reinterpret_cast<Player_t*>(entity);
		const auto i = idx;

		if (!isGoodEnt(ent))
		{
			records.at(i).clear();
			continue;
		}

		if (records.at(i).size() && (records.at(i).front().simtime == ent->m_flSimulationTime()))
			continue;

		if (!isValid(ent->m_flSimulationTime() /*m_correct.at(i).m_correctSimtime*/))
			continue;

		StoredRecord record{ };
		record.origin = ent->absOrigin();
		record.simtime = ent->m_flSimulationTime();
		if (!ent->setupBonesShort(record.matrices.data(), ent->m_CachedBoneData().m_size,
			BONE_USED_MASK, memory::interfaces::globalVars->m_curtime))
			continue;
		record.head = record.matrices[8].origin();
		record.angle = ent->absAngles();

		records.at(i).push_front(record);

		while (records.at(i).size() > 3 && records.at(i).size() > static_cast<size_t>(game::timeToTicks(correctTime)))
			records.at(i).pop_back();

		const auto invalid = std::find_if(std::cbegin(records.at(i)), std::cend(records.at(i)), [](const StoredRecord& rec)
			{
				return !isValid(rec.simtime);
			});

		if (invalid != std::cend(records.at(i)))
			records.at(i).erase(invalid, std::cend(records.at(i)));
	}
}

```

`hack/cheats/features/backtrack/backtrack.hpp`:

```hpp
#pragma once

#include <SDK/vars.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/math/matrix.hpp>

#include <deque>
#include <array>

class CUserCmd;
enum FrameStage;

namespace backtrack
{
	struct StoredRecord
	{
		float simtime{ };
		Vec3 head{ };
		Vec3 origin{ };
		Vec3 angle{ };
		std::array<Matrix3x4, BONE_USED_BY_HITBOX> matrices;
	};

	void init();
	void run(CUserCmd* cmd);

	[[nodiscard]] float getLerp();
	[[nodiscard]] bool isValid(float simtime);
	
	inline std::array<std::deque<StoredRecord>, 65> records;

	namespace updater
	{
		void run(FrameStage stage);
	}
};
```

`hack/cheats/features/blacklist/blacklist.cpp`:

```cpp
#include "blacklist.hpp"

#include <config/config.hpp>
#include <config/jsonExtended.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/console/console.hpp>

#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>

#include <cheats/helper/initable.hpp>
#include <cheats/helper/shutdownable.hpp>
#include <cheats/hooks/helpers/common.hpp>
#include <cheats/hooks/levelInitPreEntity.hpp>

namespace
{
	struct BlacklistInit : InitAble
	{
		BlacklistInit()
		{
			this->registerInit(blacklist::init);
		}
	} blacklistInit;

	struct BlacklistShutdown : ShutdownAble
	{
		BlacklistShutdown()
		{
			this->registerShutdown(blacklist::shutdown);
		}
	} blacklistShutdown;

	struct BlacklistReset : hooks::LevelInitPreEntity
	{
		BlacklistReset()
		{
			this->registerReset(blacklist::reset);
		}
	} blacklistReset;
}

namespace blacklist
{
	bool loadCfg();
	std::filesystem::path getPathForConfig();
	std::string getCorrectKey(const BlacklistedPlayer& player);

	std::vector<BlacklistedPlayer> allGuids;
	constexpr std::string_view folderName{ "blacklist" };
	std::filesystem::path saveDir;
	nlohmann::json m_json;
}

using json = nlohmann::json;

void from_json(const json& j, blacklist::BlacklistedPlayer& val)
{
	from_json(j, "Guid", val.guid);
	from_json(j, "Bot", val.bot);
	from_json(j, "Name", val.playerName);
}

void to_json(json& j, const blacklist::BlacklistedPlayer& val)
{
	j["Guid"] = val.guid;
	j["Bot"] = val.bot;
	j["Name"] = val.playerName;
}

void blacklist::init()
{
	saveDir = api::getHackPath() / api::getExtraLoadPath() / folderName / getPathForConfig();

	loadCfg();

	console::debug("blacklist init");
}

// we only erase bots after the whole match has ended, players are left untouched
void blacklist::reset()
{
	if (allGuids.empty())
		return;

	allGuids.erase(std::remove_if(allGuids.begin(), allGuids.end(), [](const BlacklistedPlayer& player)
		{
			if (player.bot)
			{
				m_json.erase(m_json.find(getCorrectKey(player)));
				return true;
			}

			return false;
		})
	);
}

bool blacklist::loadCfg()
{
	if (auto path = api::getHackPath() / api::getExtraLoadPath() / folderName; !std::filesystem::exists(path))
		std::filesystem::create_directories(path);

	std::ifstream input{ saveDir };
	if (!input)
		return false;

	if (!std::filesystem::is_empty(saveDir))
	{
		m_json = json::parse(input);

		for (const auto& [key, value] : m_json.items())
		{
			BlacklistedPlayer player{ };
			from_json(value, player);

			allGuids.push_back(player);
		}
	}

	return true;
}

bool saveCfg()
{
	std::ofstream out{ blacklist::saveDir };
	if (!out)
		return false;

	json j;
	for (const auto& el : blacklist::allGuids)
		to_json(j[blacklist::getCorrectKey(el)], el);

	if (!j.empty())
		blacklist::m_json.update(j);

	out << std::setw(4) << blacklist::m_json;

	return true;
}

// we will be saving only at end, because it doesn't really matter to save it instantly
void blacklist::shutdown()
{
	if (!saveCfg())
		console::error("Saving config has failed");
}

bool blacklist::isBlacklisted(Player_t* ent)
{
	const auto guid = getGuid(ent);
	auto itr = std::ranges::find_if(allGuids, [guid](const BlacklistedPlayer& player)
		{
			return player == guid;
		}
	);

	return itr != allGuids.end();
}

void blacklist::add(Player_t* ent)
{
	const auto guid = getGuid(ent);
	if (!isBlacklisted(ent))
	{
		allGuids.push_back(guid);
		json j;
		to_json(j[getCorrectKey(guid)], guid);
		m_json.update(j);
	}
	else
		console::warn("Player already blacklisted! guid: {} isBot {}", guid.guid, guid.bot);
}

void blacklist::remove(Player_t* ent)
{
	const auto guid = getGuid(ent);
	allGuids.erase(std::remove_if(allGuids.begin(), allGuids.end(), [guid](const BlacklistedPlayer& player)
		{
			if (player == guid)
			{
				m_json.erase(m_json.find(getCorrectKey(player)));
				return true;
			}

			return false;
		})
	);
}

std::filesystem::path blacklist::getPathForConfig()
{
	std::filesystem::path path{ folderName };
	if (path.extension() != ".json")
		path.replace_extension(".json");

	return path;
}

std::string blacklist::getCorrectKey(const blacklist::BlacklistedPlayer& player)
{
	auto key = player.bot
		? std::format("{} BOT", player.bot)
		: std::format("{}", player.guid);

	return key;
}

blacklist::BlacklistedPlayer blacklist::getGuid(Player_t* ent)
{
	PlayerInfo_t info{ };
	memory::interfaces::engine->getPlayerInfo(ent->getIndex(), &info);
	const auto guid = info.m_fakePlayer
		? BlacklistedPlayer{ .bot = true, .guid = static_cast<uint64_t>(info.m_userID), .playerName = std::string{ info.m_name } }
		: BlacklistedPlayer{ .bot = false, .guid = info.m_steamID64, .playerName = std::string{ info.m_name } };

	return guid;
}
```

`hack/cheats/features/blacklist/blacklist.hpp`:

```hpp
#pragma once

class Player_t;

namespace blacklist
{
	struct BlacklistedPlayer
	{
		[[nodiscard]] constexpr bool operator==(const BlacklistedPlayer& rhs) const
		{
			return this->guid == rhs.guid && this->bot == rhs.bot;
		}

		bool bot;
		uint64_t guid;
		std::string playerName;
	};

	[[nodiscard]] bool isBlacklisted(Player_t* ent);
	[[nodiscard]] BlacklistedPlayer getGuid(Player_t* ent);

	void init();
	void shutdown();
	void reset();

	void add(Player_t* ent);
	void remove(Player_t* ent);
};
```

`hack/cheats/features/cache/cache.cpp`:

```cpp
#include "cache.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/Enums.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>

#include <ranges>

//const auto predictor = [](const EntityCache::HolderData& lhs, const EntityCache::HolderData& rhs)
//{
//	// do comparison by length to our location
//	const auto lhsToLocal = lhs.ent->absOrigin() - game::localPlayer->absOrigin();
//	const auto rhsToLocal = rhs.ent->absOrigin() - game::localPlayer->absOrigin();
//	return lhsToLocal.length() > rhsToLocal.length();
//};

void EntityCache::init()
{
	const int maxIdx = memory::interfaces::entList->getHighestIndex();
	if (maxIdx <= 1)
		return;

	for (auto i : std::views::iota(1, maxIdx))
	{
		auto entity = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientEntity(i));
		if (!entity)
			continue;

		const auto cl = entity->clientClass();
		if (!cl)
			continue;

		HolderData data{ .ent = entity, .idx = i, .classID = cl->m_classID };
		fill(data);
	}
}

#define CACHE_LOGGING false

void EntityCache::add(Entity_t* ent)
{
#ifdef _DEBUG
#if CACHE_LOGGING == true
	auto cl = ent->clientClass();
	if (!cl)
		printf("couldn't get the entity clientclass\n");
	else
		printf("adding entity: %s enum: %i\n", cl->m_networkName, cl->m_classID);
#endif
#endif

	if (!checkRepeatable(ent))
		return;

	const auto possibleIndexes = getIndexes(ent);
	if (!possibleIndexes.has_value())
		return;

	const auto [index, classID] = possibleIndexes.value();

	const auto data = HolderData{ .ent = ent, .idx = index, .classID = classID };
	fill(data);
}

std::optional<std::pair<int, ClassID>> EntityCache::getIndexes(Entity_t* ent)
{
	int i = ent->getIndex();
	if (i <= 1)
		return std::nullopt;

	const auto cl = ent->clientClass();
	if (!cl)
		return std::nullopt;

	return std::make_pair(i, cl->m_classID);
}

bool EntityCache::checkRepeatable(Entity_t* ent)
{
	if (!ent)
		return false;

	for (const auto& [cacheType, ents] : entCacheMap)
	{
		if (auto itr = std::ranges::find_if(ents,
			[ent](const HolderData& el)
			{
				return el.ent == ent;
			}
		); itr != ents.cend()) // do not add the same memory place
		{
			return false;
		}
	}

	return true;
}

void EntityCache::fill(const HolderData& data)
{
	constexpr std::array specialWeaponIds = 
	{
		CAK47, CDEagle, CHEGrenade, CDecoyGrenade, CIncendiaryGrenade, CMolotovGrenade, CSensorGrenade, CSmokeGrenade, CFlashbang
	};

	if (auto id = data.classID; id >= CWeaponAug && id <= CWeaponXM1014
		|| std::ranges::find(specialWeaponIds, id) != specialWeaponIds.cend())
	{
		entCacheMap[EntCacheType::WEAPON].push_back(data);
	}

	switch (data.classID)
	{
	case CCSPlayer:
		entCacheMap[EntCacheType::PLAYER].push_back(data);
		break;
	case CBaseCSGrenadeProjectile:
	case CDecoyProjectile:
	case CMolotovProjectile:
	case CSmokeGrenadeProjectile:
	case CInferno:
		entCacheMap[EntCacheType::GRENADE_PROJECTILES].push_back(data);
		break;
	case CPlantedC4:
		entCacheMap[EntCacheType::WORLD_ENTS].push_back(data);
		break;
	default:
		break;
	}
}

void EntityCache::erase(Entity_t* ent)
{
	for (auto& [cacheType, ents] : entCacheMap)
	{
		if (auto itr = std::ranges::find_if(ents,
			[ent](const auto& el)
			{
				return el.ent == ent;
			}
		); itr != ents.cend())
		{
			ents.erase(itr);
		}
	}
}

void EntityCache::clear()
{
	for ([[maybe_unused]] auto& [type, vec] : entCacheMap)
		vec.clear();
}

#include <gamememory/memory.hpp>

void EntityCache::CacheFields::update()
{
	const auto hud = memory::Address<CCSGO_HudRadar*>{ game::findHudElement<CCSGO_HudRadar*>("CCSGO_HudRadar") };
	if (!hud())
		return;

	const auto radar = hud.sub(0x14).cast<CSRadar*>()();

	for (int i = 1; i <= hud->m_sizeOfPlayers + 1; i++)
	{
		const auto& player = radar->m_players[i];

		//player.write();

		if (const auto idx = player.m_index; !idx)
			continue;
		else
			cachedPlayers.at(player.m_index) = player;
	}
}
```

`hack/cheats/features/cache/cache.hpp`:

```hpp
#pragma once

#include <vector>
#include <unordered_map>
#include <utility>
#include <optional>

#include <SDK/CCSGO_HudRadar.hpp>

class Entity_t;
enum ClassID;

enum class EntCacheType // add more if needed, each group should contain many idx's, player is the exception
{
	PLAYER,
	GRENADE_PROJECTILES,
	WORLD_ENTS, // c4 and such...
	WEAPON,
};

class EntityCache final
{
public:
	static auto getCache(const EntCacheType& type) { return entCacheMap[type]; }

	// for playerlist for better access to dormant fields
	class CacheFields final
	{
	public:
		static void update();
		static auto getCachedFields() { return cachedPlayers; }
	private:
		inline static std::array<RadarEntity, 65> cachedPlayers;
	};

	static void add(Entity_t* ent);
	static void erase(Entity_t* ent);
	static void clear();
	// we need to call this once
	// manual init is a thing due to unload during the round
	HACK_INIT static void init();

	struct HolderData
	{
		Entity_t* ent;
		int idx;
		ClassID classID;
	};
private:
	static void fill(const HolderData& data);
	static bool checkRepeatable(Entity_t* ent);
	static std::optional<std::pair<int, ClassID>> getIndexes(Entity_t* ent);
	inline static std::unordered_map<EntCacheType, std::vector<HolderData>> entCacheMap;
};
```

`hack/cheats/features/callbacks/callbacks.cpp`:

```cpp
#include "callbacks.hpp"

#include <SDK/CEffectData.hpp>
#include <SDK/CClientEffectRegistration.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/console/console.hpp>
#include <gamememory/memory.hpp>

#include <cheats/helper/initable.hpp>
#include <cheats/helper/shutdownable.hpp>

#include <ranges>
#include <vector>
#include <string>

namespace
{
	/*struct InitCallback : InitAble
	{
		InitCallback()
		{
			this->registerInit(callbacks::init);
		}
	} clInit;

	struct ShutdownCallback : ShutdownAble
	{
		ShutdownCallback()
		{
			this->registerShutdown(callbacks::shutdown);
		}
	} clShutdown;*/
}

namespace callbacks
{
	struct clbStruct
	{
		std::string m_name; // effect's name
		clientEffectCallback m_function = nullptr; // init this on add as custom func
		clientEffectCallback m_callback = nullptr; // will be later inited
	};

	clientEffectCallback getCallbackByMemory(/*const */clientEffectCallback/*&*/ callb);
	void addCallBack(const clbStruct& callb);

	std::vector<clbStruct> callbacks;
	CClientEffectRegistration* head;
}

void callbacks::addCallBack(const clbStruct& callb)
{
	auto itr = std::ranges::find_if(callbacks, [name = callb.m_name](const clbStruct& el)
		{
			return el.m_name == name;
		});

	if (itr != callbacks.cend())
		console::warn("{} already exists! skipping...", callb.m_name);
	else
		callbacks.push_back(callb);
}

// custom1
void example(const CEffectData& data)
{
	auto call = callbacks::getCallbackByMemory(&example);
	call(data);
}

// custom2 - fail
void example2(const CEffectData& data)
{
	auto call = callbacks::getCallbackByMemory(&example2);
	call(data);
}

void callbacks::init()
{
	addCallBack({ "Impact", &example, nullptr });
	addCallBack({ "Impact", &example2, nullptr });

	head = memory::callbacksHead();
	while(head = head->m_next)
	{
		for (auto& el : callbacks)
		{
			// check by names on init, somehow we gotta point to correct name we passed
			if (std::string_view name = head->m_effectName; name == el.m_name)
			{
				el.m_callback = head->m_function; // own now the original function
				head->m_function = el.m_function; // point our edited function

				console::debug("custom function inited, name: {} at addr {:#0x}",
					name, reinterpret_cast<uintptr_t>(el.m_function));
			}
		}
	}
}

void callbacks::shutdown()
{
	head = memory::callbacksHead();
	while (head = head->m_next)
	{
		for (auto& el : callbacks)
		{
			if (el.m_function == head->m_function) // check by address
				head->m_function = el.m_callback; // do not point to custom funcs anymore
		}
	}
}

clientEffectCallback callbacks::getCallbackByMemory(/*const */clientEffectCallback/*&*/ callb)
{
	for (const auto& el : callbacks)
	{
		if (el.m_function == callb)
			return el.m_callback;
	}

	return nullptr;
}

#pragma region dumped_effect_names
/*
ManhackSparks
TeslaZap
TeslaHitboxes
CommandPointer
GunshipImpact
Smoke
MuzzleFlash
Error
BoltImpact
RPGShotDown
GlassImpact
EjectBrass_338Mag
EjectBrass_762Nato
EjectBrass_556
EjectBrass_57
EjectBrass_12Gauge
EjectBrass_9mm
CS_MuzzleFlash_X
CS_MuzzleFlash
KnifeSlash
Impact
CS_HolidayLight
csblood
waterripple
gunshotsplash
watersplashquiet
watersplash
TracerSound
ParticleTracer
Tracer
ShotgunShellEject
RifleShellEject
ShellEject
RagdollImpact
HelicopterMegaBomb
WaterSurfaceExplosion
Explosion
HunterDamage
BloodImpact
bloodspray
WheelDust
ShakeRopes
ParticleEffectStop
ParticleEffect
*/
#pragma endregion

```

`hack/cheats/features/callbacks/callbacks.hpp`:

```hpp
#pragma once

// not used! See examples inside
namespace callbacks
{
	void init();
	void shutdown();
};
```

`hack/cheats/features/combat/RCS/RCS.cpp`:

```cpp
#include "RCS.hpp"

#include "../aimbot/aimbot.hpp"
#include "../aimbot/helper.hpp"

#include <SDK/CUserCmd.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/CGameMovement.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>

#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>

#include <cheats/hooks/overrideMouse.hpp>
#include <cheats/hooks/createMove.hpp>

namespace
{
	struct RcsHandler : hooks::OverrideMouse
	{
		RcsHandler()
		{
			this->registerRun(rcs::runMouse);
		}
	} rcsHandler;

	struct RcsHandlerCM : hooks::CreateMove
	{
		RcsHandlerCM()
		{
			this->registerInit(rcs::init);
			this->registerRunPrediction(rcs::run);
		}
	} rcsHandlerCM;
}

namespace rcs
{
	IConVar* weapon_recoil_scale{ };
	IConVar* m_yaw{ };
	IConVar* m_pitch{ };
	CfgWeapon cfg{ };

	bool shouldWork{ };
	float scale{ };
	std::mutex mutex{ };
	CUserCmd* m_cmd{ };

	bool inited{ false };
}

void rcs::init()
{
	weapon_recoil_scale = memory::interfaces::cvar->findVar("weapon_recoil_scale");
	m_yaw = memory::interfaces::cvar->findVar("m_yaw");
	m_pitch = memory::interfaces::cvar->findVar("m_pitch");

	inited = true;
}

void rcs::runMouse(float* x, float* y)
{
	std::lock_guard lock{ mutex };

	if (!inited)
		return;

	if (!shouldWork)
		return;

	if (m_cmd->m_buttons & IN_ATTACK)
	{
		if (game::localPlayer()->m_iShotsFired() > 2)
		{
			const Vec3 view = m_cmd->m_viewangles;
			const Vec3 punch = game::localPlayer->getAimPunch();

			const Vec3 delta = punch - lastPunch;
			const Vec3 addon{ delta[0] * scale * cfg.rcsX, delta[1] * scale * cfg.rcsY, 0.0f };

			const Vec3 rcsAngle = view - addon;
			auto& toAdd = Vec3{ view - rcsAngle }.normalize().clamp();

			toAdd[0] /= m_pitch->getFloat();
			toAdd[1] /= m_yaw->getFloat();

			Vec2 mouse = Vec2{ *x, *y };
			Vec2 mouseScreen = Vec2{ toAdd[1], -toAdd[0] };

			mouseScreen[0] = (mouseScreen[0] + mouse[0]) / scale;
			mouseScreen[1] = (mouseScreen[1] + mouse[1]) / scale;

			*x = mouseScreen[0];
			*y = mouseScreen[1];
		}

		lastPunch = game::localPlayer->getAimPunch();
	}
	else
	{
		lastPunch = Vec3{ 0.0f, 0.0f, 0.0f };
	}
}

void rcs::run(CUserCmd* cmd)
{
	std::lock_guard lock{ mutex };

	shouldWork = false;

	const auto maybeConfig = configWeapon::get();
	if (!maybeConfig.has_value())
		return;

	cfg = maybeConfig.value();

	if (!cfg.rcs)
		return;

	if (!game::isAvailable())
		return;

	auto weapon = game::localPlayer->getActiveWeapon();

	if (!weapon)
		return;

	if (weapon->isNonAimable())
		return;

	if (weapon->isSniper())
		return;

	const float recoilScale = weapon_recoil_scale->getFloat();
	if (recoilScale <= 0.0f) // recoil doesn't exist, or reversed, then ignore
		return;

	m_cmd = cmd;
	scale = recoilScale;

	shouldWork = true;
}
```

`hack/cheats/features/combat/RCS/RCS.hpp`:

```hpp
#pragma once

#include <SDK/math/Vector.hpp>

class CUserCmd;

namespace rcs
{
	void init();
	void run(CUserCmd* cmd);
	void runMouse(float* x, float* y);

	inline Vec3 lastPunch{ };
}
```

`hack/cheats/features/combat/aimbot/aimbot.cpp`:

```cpp
#include "aimbot.hpp"

#include "../RCS/RCS.hpp"
#include "helper.hpp"
#include <cheats/features/cache/cache.hpp>
#include <cheats/features/backtrack/backtrack.hpp>

#include <SDK/IVEngineClient.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/vars.hpp>
#include <SDK/Enums.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <config/vars.hpp>
#include <cheats/game/globals.hpp>
#include <cheats/game/game.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/rand.hpp>
#include <cheats/features/blacklist/blacklist.hpp>

#include <cheats/hooks/createMove.hpp>
#include <cheats/hooks/overrideMouse.hpp>
#include <cheats/hooks/wndproc.hpp>
#include <cheats/hooks/createMove.hpp>

namespace
{
	struct HandlerAim : hooks::OverrideMouse
	{
		HandlerAim()
		{
			this->registerRun(Aimbot::runMouse);
		}
	} handlerAim;

	struct HandlerAimKeys : hooks::wndProcSys
	{
		HandlerAimKeys()
		{
			this->registerRun(Aimbot::updateKeys);
		}
	} handlerAimKeys;

	struct HandlerAimCM : hooks::CreateMove
	{
		HandlerAimCM()
		{
			this->registerInit(Aimbot::init);
			this->registerRunPrediction(Aimbot::run);
		}
	} handlerAimCM;
}

namespace Aimbot
{
	struct AimbotTarget_t
	{
		Player_t* player{ };
		float fov{ };
		Hitboxes hitbox{ };
		Vec3 pos{ };
	};

	void resetFields();
	bool isClicked(CUserCmd* cmd);
	void addBacktrack();
	void sortTargets();
	bool addDelay();
	void addTargets(CUserCmd* cmd, Weapon_t* wpn, const Vec3& eye, const Vec3& punch);
	std::vector<Hitboxes> getHitboxes();

	bool inDelay{ false };
	Vec3 toAdd{ };
	bool shouldWork{ false };
	std::mutex mutex;
	std::vector<AimbotTarget_t> targets;
	CfgWeapon cfgWeapon;

	IConVar* weapon_recoil_scale{ };
	IConVar* m_yaw{ };
	IConVar* m_pitch{ };

	bool inited{ false };
}

void Aimbot::init()
{
	weapon_recoil_scale = memory::interfaces::cvar->findVar("weapon_recoil_scale");
	m_yaw = memory::interfaces::cvar->findVar("m_yaw");
	m_pitch = memory::interfaces::cvar->findVar("m_pitch");

	inited = true;
}

void Aimbot::updateKeys()
{
	cfgWeapon.key.update();
}

void Aimbot::addBacktrack()
{
	if (cfgWeapon.aimBacktrack)
	{
		if (targets.empty())
			return;

		auto& [player, fov, bestHitbox, bestpos] = targets.front();

		int boneID = 8; // HEAD start
		if (auto modelStudio = memory::interfaces::modelInfo->getStudioModel(player->getModel()); modelStudio != nullptr)
		{
			if (auto hitbox = modelStudio->getHitboxSet(0)->getHitbox(bestHitbox); hitbox != nullptr)
			{
				boneID = hitbox->m_bone;
			}
		}
		const auto& record = backtrack::records.at(player->getIndex());
		bestpos = record.at(record.size() / 2).matrices[boneID].origin(); // middle, u can play with this as u want to
	}
}

void Aimbot::sortTargets()
{
	// everything sorted by fov. Blacklists go on top + they ofc are sorted
	// we always want front() as current target
	std::ranges::sort(targets,
		[](const AimbotTarget_t& lhs, const AimbotTarget_t& rhs) // std::tie won't work in that case
		{
			if (blacklist::isBlacklisted(lhs.player) ^ blacklist::isBlacklisted(rhs.player))
				return blacklist::isBlacklisted(lhs.player);

			return lhs.fov < rhs.fov;
		});
}

bool Aimbot::addDelay()
{
	if (targets.empty())
		return true;

	static float delay{ 0.0f };
	// will not work for the special case:
	// delay did not hit timer limit but we switched manually to new target -> should reset the timer. I couldn't detect it without false positives :(
	// epic solution - stop shooting and start again
	if (cfgWeapon.aimDelay)
	{
		if (targets.size() && !inDelay && !targets.front().player->isAlive()) // if ent is found and dead, then set field to delay and wait curr time + cfgtime
		{
			inDelay = true;
			delay = memory::interfaces::globalVars->m_curtime + (cfgWeapon.aimDelayVal / 1000.0f);
		}
		if (inDelay) // if the delay is hit, check time, so when ent died
		{
			if (delay <= memory::interfaces::globalVars->m_curtime)
				inDelay = false;
			else // need reset fields here and stop the method
			{
				targets.clear();
				return false;
			}
		}
	}

	return true;
}

void Aimbot::runMouse(float* x, float* y)
{
	std::lock_guard lock{ mutex };

	if (!shouldWork)
		return;

	Vec2 mouseScreen = Vec2{ toAdd[1], -toAdd[0] };

	*x += mouseScreen[0];
	*y += mouseScreen[1];
}

void Aimbot::run(CUserCmd* cmd)
{
	std::lock_guard lock{ mutex };

	if (!inited)
		return;

	if (!game::isAvailable())
		return;

	shouldWork = false;

	const auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	const auto maybeCfg = configWeapon::get();
	if (!maybeCfg.has_value())
		return;

	cfgWeapon = maybeCfg.value();

	if (!cfgWeapon.enabled)
		return;

	if (weapon->isNonAimable())
	{
		resetFields(); // switching to knife when clicked
		return;
	}

	if (weapon->isSniper() && !game::localPlayer->m_bIsScoped())
		return;

	if (!isClicked(cmd))
	{
		resetFields();
		return;
	}

	const Vec3 myEye = game::localPlayer->getEyePos();
	Vec3 punch{ };
	if (game::localPlayer->m_iShotsFired())
	{
		punch = (weapon->isRifle() || weapon->isSmg()) ? game::localPlayer->getAimPunch() : Vec3{};
		if (cfgWeapon.rcs)
			punch = rcs::lastPunch;
	}

	addTargets(cmd, weapon, myEye, punch);
	sortTargets();

	if (targets.empty())
		return;

	const auto [player, fov, bestHitbox, bestpos] = targets.front();

	const auto currentAngle = Vec3{ cmd->m_viewangles + punch };
	const auto angle = math::calcAngle(myEye, bestpos);
	float smoothingFactor = std::min(memory::interfaces::globalVars->m_frametime * cfgWeapon.frametimeMulttiply, 1.0f);
	const float clampedSmooth = std::clamp(smoothingFactor, 0.01f, 1.0f);
	const auto& lerpedAngle = currentAngle.lerp(angle, clampedSmooth);

	toAdd = Vec3{ currentAngle - lerpedAngle }.normalize().clamp();

	toAdd[0] /= m_pitch->getFloat();
	toAdd[1] /= m_yaw->getFloat();

	shouldWork = true;
}

// because for any reason optimizations cause deadlock
#pragma optimize("", off)
void Aimbot::addTargets(CUserCmd* cmd, Weapon_t* wpn, const Vec3& eye, const Vec3& punch)
{
	if (!addDelay())
		return;

	targets.clear();

	if (game::localPlayer->m_flFlashDuration() > 0.0f)
	{
		if (game::localPlayer->m_flFlashBangTime() >= cfgWeapon.flashLimit)
			return;
	}

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		auto ent = reinterpret_cast<Player_t*>(entity);

		if (!ent)
			continue;

		if (ent == game::localPlayer)
			continue;

		if (!ent->isAlive() || !game::localPlayer->isAlive())
			continue;

		if (!ent->isOtherTeam(game::localPlayer()))
			continue;

		if (ent->isDormant())
			continue;

		if (ent->m_bGunGameImmunity())
			continue;

		float bestFov{ cfgWeapon.fov };
		Vec3 bestPos{ };
		Hitboxes bestHitbox{ HITBOX_HEAD };
		bool readyToAdd{ false };

		for (const auto hitbox : getHitboxes())
		{
			const Vec3 hitPos = ent->getHitboxPos(hitbox);
			const Vec3 angles = cmd->m_viewangles + punch;

			const auto fov = cfgWeapon.methodAim == E2T(AimbotMethod::CROSSHAIR)
				? math::calcFov(eye, hitPos, angles)
				: math::calcFovReal(eye, hitPos, angles);

			if (fov > bestFov)
				continue;

			if (!game::localPlayer->isPossibleToSee(ent, hitPos))
				continue;

			if (cfgWeapon.smokeCheck && game::localPlayer->isViewInSmoke(hitPos))
				continue;

			if (fov < bestFov)
			{
				bestFov = fov;
				bestHitbox = hitbox;
				bestPos = hitPos;

				readyToAdd = true;
			}
		}

		if (readyToAdd)
		{
			targets.emplace_back(ent, bestFov, bestHitbox, bestPos);
		}
	}

	addBacktrack();
}
#pragma optimize("", on)

void Aimbot::resetFields()
{
	targets.clear();
	inDelay = false;
}

bool Aimbot::isClicked(CUserCmd* cmd)
{
	if (cfgWeapon.useKey)
	{
		if (cfgWeapon.key.isEnabled())
			return true;
		else
			return false;
	}
	else
		return cmd->m_buttons & IN_ATTACK;

	return false;
}

std::vector<Hitboxes> Aimbot::getHitboxes()
{
	static std::vector<Hitboxes> allHitboxes(HITBOX_MAX);
	static std::once_flag once;
	std::call_once(once, [&]()
	{
		// iota won't work, so doing it manually
		for (int i = HITBOX_HEAD; i < HITBOX_MAX; i++)
			allHitboxes.at(i) = static_cast<Hitboxes>(i);
	});
	static std::vector<Hitboxes> headHitbox{ HITBOX_HEAD };
	static std::vector<Hitboxes> chestHitbox{ HITBOX_LOWER_CHEST, HITBOX_UPPER_CHEST };


	switch (cfgWeapon.aimSelection)
	{
	case E2T(AimbotHitboxes::NEAREST):
		return allHitboxes;
	case E2T(AimbotHitboxes::HEAD):
		return headHitbox;
	case E2T(AimbotHitboxes::CHEST):
		return chestHitbox;
	}

	return {};
}
```

`hack/cheats/features/combat/aimbot/aimbot.hpp`:

```hpp
#pragma once

class CUserCmd;

namespace Aimbot
{
	void init();
	void runMouse(float* x, float* y);
	void run(CUserCmd* cmd);
	void updateKeys();
};
```

`hack/cheats/features/combat/aimbot/aimbotDraw.cpp`:

```cpp
#include "aimbotDraw.hpp"

#include "helper.hpp"
#include "aimbot.hpp"

#include <SDK/IWeapon.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <render/render.hpp>
#include <utilities/tools/wrappers.hpp>

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct DrawHandler : hooks::PaintTraverse
	{
		DrawHandler()
		{
			this->registerRender(AimbotDraw::draw);
		}
	} aimbotDraw;
}

void AimbotDraw::draw()
{
	const auto maybecfg = configWeapon::get();
	if (!maybecfg.has_value())
		return;

	const auto cfg = maybecfg.value();

	if (!vars::aimPaint->enabledFov)
		return;

	if (!cfg.enabled)
		return;

	if (!cfg.fov)
		return;

	if (!game::isAvailable())
		return;

	const auto weapon = game::localPlayer->getActiveWeapon();

	if (!weapon)
		return;

	if (weapon->isNonAimable())
		return;

	float radius = 0.0f;

	switch (cfg.methodAim)
	{
	case E2T(AimbotMethod::CROSSHAIR):
	{
		radius = std::tan(math::DEG2RAD(cfg.fov) / 2.0f) / std::tan(math::DEG2RAD(globals::FOV) / 2.0f) * globals::screenX;

		break;
	}
	case E2T(AimbotMethod::DYNAMIC): // not very very accurate
	{
		Trace_t trace;
		TraceFilter filter{ game::localPlayer() };
		const auto myEye = game::localPlayer->getEyePos();
		constexpr float range = 8192.0f; // because we need max range possible
		const auto view = game::getViewAngles();
		const auto end = myEye + (math::angleVec(view) * range);
		memory::interfaces::trace->traceRay({ myEye, end }, MASK_SHOT, &filter, &trace);
		// 3d end
		const auto destination = trace.m_end;

		// turn for visualization
		auto forward = math::angleVec(Vec3{ view[0], view[1] + 90.f, 0.f });
		// dist in calcFovReal
		forward *= cfg.fov * 10.0f;
		// final vector where we aim
		auto aimingView = destination + forward;

		if (ImVec2 v; ImRender::worldToScreen(aimingView, v))
			radius = std::abs(globals::screenX / 2.0f - v.x);

		break;
	}
	}

	ImRender::drawCircle(globals::screenX / 2.0f, globals::screenY / 2.0f, radius, 32, vars::aimPaint->colorFov());
}
```

`hack/cheats/features/combat/aimbot/aimbotDraw.hpp`:

```hpp
#pragma once

namespace AimbotDraw
{
	void draw();
};
```

`hack/cheats/features/combat/aimbot/helper.hpp`:

```hpp
#pragma once

#include <config/cfgWeapon.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <menu/GUI-ImGui/menu.hpp>

#include <optional>

namespace configWeapon
{
	inline std::optional<CfgWeapon> get()
	{
		if (ImGuiMenu::active)
			return std::nullopt;

		if (!game::localPlayer)
			return std::nullopt;

		const auto weapon = game::localPlayer->getActiveWeapon();
		if (!weapon)
			return std::nullopt;

		const auto weaponCfg = CfgWeapon::getWeaponByIndex(weapon->m_iItemDefinitionIndex());

		if (weaponCfg == WeaponList::WEAPON_UNKNOWN)
			return std::nullopt;

		return vars::aim->weapons.at(static_cast<size_t>(weaponCfg));
	}
}
```

`hack/cheats/features/combat/triggerbot/triggerbot.cpp`:

```cpp
#include "triggerbot.hpp"

#include "../aimbot/helper.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/vars.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <utilities/math/math.hpp>

#include <cheats/hooks/createMove.hpp>

namespace
{
	struct TriggerbotHandler : hooks::CreateMove
	{
		TriggerbotHandler()
		{
			this->registerRunPrediction(triggerbot::run);
		}
	} triggerbotHandler;
}

void triggerbot::run(CUserCmd* cmd)
{
	auto maybeConfig = configWeapon::get();
	if (!maybeConfig.has_value())
		return;

	auto cfg = maybeConfig.value();

	if (!cfg.triggerbot)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	const auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	if (weapon->isNonAimable() || weapon->isEmpty())
		return;

	if (weapon->isSniper() && !game::localPlayer->m_bIsScoped())
		return;

	const auto myEye = game::localPlayer->getEyePos();
	const auto range = weapon->getWpnInfo()->m_range;
	// punch is needed to not fallback with bad constant shooting
	const auto end = myEye + math::angleVec(cmd->m_viewangles + game::localPlayer->getAimPunch()) * range;

	// initialize delays, timer api is not needed since game shares this information
	/*static auto delay = std::chrono::high_resolution_clock::now();
	const auto current = std::chrono::high_resolution_clock::now();*/
	static auto delay = memory::interfaces::globalVars->m_realtime;
	const auto current = memory::interfaces::globalVars->m_realtime;

	// because this time is in seconds, so delay must be /1000 (s->ms), when using chrono, you can cast to ms so it's more flexible
	if ((current - delay) < cfg.triggerbotDelay / 1000.0f)
		return;

	if (game::localPlayer->m_flFlashDuration() > 0.0f)
	{
		if (game::localPlayer->m_flFlashBangTime() >= cfg.flashLimit)
			return;
	}

	Trace_t trace;
	TraceFilter filter;

	filter.m_skip = game::localPlayer();
	memory::interfaces::trace->traceRay({ myEye, end }, MASK_PLAYER, &filter, &trace);

	// so this way we skip time of trace
	delay = current;
	
	if (cfg.smokeCheck && game::localPlayer->isViewInSmoke(trace.m_end))
		return;

	if (trace.m_hitgroup == 0)
		return;

	auto entity = trace.m_entity;
	if (!entity)
		return;

	if (!entity->isOtherTeam(game::localPlayer()))
		return;

	if (!entity->isPlayer())
		return;

	if (entity->isDormant())
		return;

	if (!entity->isAlive())
		return;

	if (entity->m_bGunGameImmunity())
		return;

	//if (!game::localPlayer->isPossibleToSee(entity, entity->getEyePos()))
	//	return;

	// that is bad way
	/*if (delay >= vars::iTriggerDelay)
	{
		delay = 0;
		cmd->m_buttons |= IN_ATTACK;
	}*/

	cmd->m_buttons |= IN_ATTACK;
	delay = 0.0f;
}
```

`hack/cheats/features/combat/triggerbot/triggerbot.hpp`:

```hpp
#pragma once

class CUserCmd;

namespace triggerbot
{
	void run(CUserCmd* cmd);
};

```

`hack/cheats/features/events/events.cpp`:

```cpp
#include "events.hpp"

#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/globals.hpp>

void EventCallback::addToCallback(const std::string_view eventName, const callbackType& callback)
{
	if (auto itr = events.find(eventName); itr != events.end())
	{
		// if found, then only push to vector with functions
		itr->second.push_back(callback);
	}
	else // create new
	{
		memory::interfaces::eventManager->addListener(this, eventName.data());
		events.emplace(std::make_pair
		(
			eventName,
			std::vector<callbackType>{ callback }
		));
	}
}

void EventCallback::fireGameEvent(IGameEvent* event)
{
	for (const auto [name, funcs] : events)
	{
		if (const std::string_view ename{ event->getName() }; ename == name)
		{
			for (const auto& func : funcs)
				func(event);
		}
	}
}

void EventCallback::shutdown()
{
	memory::interfaces::eventManager->removeListener(this);
}
```

`hack/cheats/features/events/events.hpp`:

```hpp
#pragma once

#include <SDK/IGameEvent.hpp>

#include <string>
#include <functional>
#include <vector>
#include <unordered_map>

class EventsWrapper : public IGameEventListener
{
public:
	constexpr std::string_view getName() const { return name; }
protected:
	std::string_view name{ };
	virtual void fireGameEvent(IGameEvent* event) override {};
};

class EventCallback : public EventsWrapper
{
public:
	using callbackType = std::function<void(IGameEvent*)>;

	void addToCallback(const std::string_view eventName, const callbackType& callback);
	void shutdown();
private:
	virtual void fireGameEvent(IGameEvent* event) override;
	std::unordered_map<std::string_view, std::vector<callbackType>> events{ };
};

namespace events
{
	inline EventCallback globalEvent{ };
	inline void shutdown()
	{
		globalEvent.shutdown();
	}
	inline void add(const std::string_view eventName, const EventCallback::callbackType& callback)
	{
		globalEvent.addToCallback(eventName, callback);
	}
}

```

`hack/cheats/features/fakelatency/fakelatency.cpp`:

```cpp
#include "fakelatency.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>

#include <cheats/hooks/sendDatagram.hpp>
#include <cheats/hooks/createMove.hpp>

#include <deque>

namespace
{
	struct FakeLatencyCM : hooks::CreateMove
	{
		FakeLatencyCM()
		{
			this->registerInit(fakeLatency::init);
			this->registerRunPrePrediction(fakeLatency::run);
		}
	} fakeLatCM;
}

namespace fakeLatency
{
	struct SequenceRecord
	{
		int inReliableState;
		int outReliableState;
		int m_sequenceNr;
		float m_curtime;
	};

	int lastSequence{ 0 };
	std::deque<SequenceRecord> sequences;
	IConVar* sv_maxunlag;

	void addLatency(INetChannel* netChannel, float latency);
	void updateSequences();
	void clearSequences();
}

void fakeLatency::init()
{
	sv_maxunlag = memory::interfaces::cvar->findVar("sv_maxunlag");
}

int fakeLatency::runDatagram(INetChannel* netChannel, void* datagram)
{
	int reliableStateBackup = netChannel->m_inReliableState;
	int sequenceNrBackup = netChannel->m_inSequenceNr;

	float maxLatency = std::max(0.0f, std::clamp(vars::misc->fakeLatency->amount / 1000.f, 0.f, sv_maxunlag->getFloat())
		- netChannel->getLatency(FLOW_OUTGOING));
	addLatency(netChannel, maxLatency);

	const auto ret = hooks::SendDatagram::getOriginal()(netChannel, datagram);

	netChannel->m_inReliableState = reliableStateBackup;
	netChannel->m_inSequenceNr = sequenceNrBackup;

	return ret;
}

void fakeLatency::run(CUserCmd* cmd)
{
	updateSequences();
}

void fakeLatency::updateSequences()
{
	if (!game::isAvailable())
		return;

	if (!vars::misc->fakeLatency->enabled)
	{
		clearSequences();
		return;
	}

	auto network = memory::interfaces::engine->getNameNetChannel();
	if (!network)
		return;

	if (lastSequence == 0)
		lastSequence = network->m_inSequenceNr;

	if (network->m_inSequenceNr > lastSequence)
	{
		lastSequence = network->m_inSequenceNr;
		sequences.emplace_front(
			SequenceRecord
			{
				.inReliableState = network->m_inReliableState,
				.outReliableState = network->m_outReliableState,
				.m_sequenceNr = network->m_inSequenceNr,
				.m_curtime = game::serverTime()
			}
		);
	}

	if (sequences.size() > 2048)
		sequences.pop_back();
}

void fakeLatency::clearSequences()
{
	if (!sequences.empty())
	{
		lastSequence = 0;
		sequences.clear();
	}
}

void fakeLatency::addLatency(INetChannel* netChannel, float latency)
{
	for (auto& el : sequences)
	{
		if (game::serverTime() - el.m_curtime >= latency)
		{
			netChannel->m_inReliableState = el.inReliableState;
			netChannel->m_inSequenceNr = el.m_sequenceNr;
			break;
		}
	}
}

```

`hack/cheats/features/fakelatency/fakelatency.hpp`:

```hpp
#pragma once

class CUserCmd;
class INetChannel;

// https://www.unknowncheats.me/forum/counterstrike-global-offensive/227226-synced-fake-ping.html
namespace fakeLatency
{
	void init();
	int runDatagram(INetChannel* netChannel, void* datagram);
	void run([[maybe_unused]] CUserCmd* cmd);
};
```

`hack/cheats/features/logger/logger.cpp`:

```cpp
#include "logger.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <render/render.hpp>
#include <config/vars.hpp>
#include <cheats/features/events/events.hpp>
#include <cheats/game/globals.hpp>

#include <cheats/hooks/present.hpp>
#include <cheats/hooks/unknownPlayerHurt.hpp>

namespace logger
{
	void handleHits(IGameEvent* event);
	void draw();

	std::vector<Log_t> logs{ };
}

namespace
{
	struct LoggerDraw : hooks::Present
	{
		LoggerDraw()
		{
			this->registerRun(logger::draw);
		}
	} loggerDraw;

	struct LoggerHits : hooks::UnknownPlayerHurt
	{
		LoggerHits()
		{
			this->registerRun(logger::handleHits);
		}
	} loggerHits;
}

void logger::add(const Log_t& log)
{
	if (!vars::misc->logs->enabled)
		return;

	logs.push_back(log);
}

void logger::draw()
{
	if (!vars::misc->logs->enabled)
		return;

	constexpr float animation = 0.2f;
	constexpr float fineClip = 10.0f;

	for (size_t i = 0; const auto & el : logs)
	{
		float in = std::clamp((memory::interfaces::globalVars->m_curtime - el.time) / animation, 0.10f, 1.0f);
		float out = std::clamp((memory::interfaces::globalVars->m_curtime - el.time - vars::misc->logs->time) / animation, 0.0f, 1.0f);

		float alpha = in * (1.0f - out);
		if (alpha <= 0.0f)
		{
			logs.erase(logs.begin() + i);
			continue;
		}

		float x = in * fineClip - out * fineClip;
		float y = ((el.font->FontSize * i) + fineClip) * alpha;

		if (y > globals::screenY * 0.3f)
		{
			logs.pop_back();
			break;
		}

		drawing::Text text{ el.font, ImVec2{ x, y }, Color::U32(el.color.getColorEditAlpha(alpha)), el.text, false, false };
		text.draw(ImGui::GetForegroundDrawList());

		i++;
	}
}

void logger::handleHits(IGameEvent* event)
{
	auto attacker = memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt("attacker")));
	if (!attacker)
		return;

	// very important
	if (attacker != game::localPlayer)
		return;

	auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt("userid"))));
	if (!ent) // should never happen
		return;

	auto dmg_health = event->getInt("dmg_health");
	auto health = ent->m_iHealth() - dmg_health;
	auto hitgroup = event->getInt("hitgroup");

	auto hitGroupToStr = [hitgroup]() -> std::string_view
	{
		switch (hitgroup)
		{
		case HITGROUP_HEAD:
			return "Head";
		case HITGROUP_CHEST:
			return "Chest";
		case HITGROUP_STOMACH:
			return "Belly";
		case HITGROUP_LEFTARM:
			return "Left arm";
		case HITGROUP_RIGHTARM:
			return "right arm";
		case HITGROUP_LEFTLEG:
			return "Left leg";
		case HITGROUP_RIGHTLEG:
			return "Right arm";
		default:
			return std::format("Unk {}", hitgroup);
		}
	};

	add(Log_t
		{
			.text = std::format("Hit {} for [{} hp {}hp left] dmg in {}", ent->getName(), dmg_health, health, hitGroupToStr()),
			.color = Colors::Cyan,
			.time = memory::interfaces::globalVars->m_curtime,
			.font = ImRender::fonts::tahoma14
		});
}

```

`hack/cheats/features/logger/logger.hpp`:

```hpp
#pragma once

#include <render/Color.hpp>

#include <string>

struct ImFont;

namespace logger
{
	struct Log_t
	{
		std::string text;
		Color color;
		float time;
		ImFont* font;
	};

	void add(const Log_t& log);
}
```

`hack/cheats/features/misc/cameras/freeCam.cpp`:

```cpp
#include "freeCam.hpp"

#include <SDK/CViewSetup.hpp>
#include <SDK/math/Vector.hpp>
#include <utilities/inputSystem.hpp>
#include <utilities/math/math.hpp>
#include <config/vars.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <menu/GUI-ImGui/menu.hpp>
#include <cheats/game/game.hpp>

#include <cheats/hooks/overrideView.hpp>
#include <cheats/hooks/wndproc.hpp>

namespace
{
	struct FreecamKeys : hooks::wndProcSys
	{
		FreecamKeys()
		{
			this->registerRun(freecam::updateKeys);
		}
	} freecamKeys;

	struct FreecamView : hooks::OverrideView
	{
		FreecamView()
		{
			this->registerRun(freecam::run);
		}
	} freecamView;
}

void freecam::updateKeys()
{
	vars::keys->freeCam.update();
}

void freecam::run(CViewSetup* view)
{
	if (!game::isAvailable())
		return;

	static Vec3 viewAngles{ view->m_angles };

	if (vars::misc->freeCam->enabled && vars::keys->freeCam.isEnabled())
	{
		isInCam = true;

		/*auto model = game::localPlayer->getModel();
		if (!model)
			return;

		auto studio = memory::interfaces::modelInfo->getStudioModel(model);
		if (!studio)
			return;

		studio->m_flags |= 0x0080;*/

		const auto [forward, right, up] = math::angleVectors(view->m_angles);

		if (inputSystem::isKeyDown(VK_SPACE))
		{
			viewAngles += up * vars::misc->freeCam->speed;
		}
		if (inputSystem::isKeyDown(0x57)) // w
		{
			viewAngles += forward * vars::misc->freeCam->speed;
		}
		if (inputSystem::isKeyDown(0x41)) // a
		{
			viewAngles -= right * vars::misc->freeCam->speed;
		}
		if (inputSystem::isKeyDown(0x53)) // s
		{
			viewAngles -= forward * vars::misc->freeCam->speed;
		}
		if (inputSystem::isKeyDown(0x44)) // d
		{
			viewAngles += right * vars::misc->freeCam->speed;
		}

		view->m_origin += viewAngles;
	}
	else
	{
		viewAngles = view->m_angles;
		isInCam = false;
	}
}
```

`hack/cheats/features/misc/cameras/freeCam.hpp`:

```hpp
#pragma once

class CViewSetup;

namespace freecam
{
	void run(CViewSetup* view);
	void updateKeys();

	inline bool isInCam{ false };
};
```

`hack/cheats/features/misc/disable/convars.cpp`:

```cpp
#include "convars.hpp"

#include <SDK/ConVar.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include <config/vars.hpp>
#include <cheats/helper/shutdownable.hpp>

namespace
{
	struct CvarHandler : ShutdownAble
	{
		CvarHandler()
		{
			this->registerShutdown(convars::shutdown);
		}
	} cvarHandler;
}

namespace convars
{
	std::vector<ConCommandBase*> oldVars;

	void runOnce();
}

void convars::runOnce()
{
	const auto itr = memory::interfaces::cvar->factoryInternalIterator();
	for (itr->setFirst(); itr->isValid(); itr->next())
	{
		auto cmd = itr->get();
		if (cmd->isFlagSet(FCVAR_DEVELOPMENTONLY | FCVAR_HIDDEN))
		{
			oldVars.push_back(cmd);
			cmd->removeFlags(FCVAR_DEVELOPMENTONLY | FCVAR_HIDDEN);
			cmd->oldFlags &= ~(FCVAR_DEVELOPMENTONLY | FCVAR_HIDDEN);
		}
	}
}

void convars::run()
{
	static std::once_flag onceFlag;
	std::call_once(onceFlag, runOnce);
}

void convars::shutdown()
{
	for (auto var : oldVars)
	{
		var->addFlags(FCVAR_DEVELOPMENTONLY | FCVAR_HIDDEN);
		var->oldFlags |= (FCVAR_DEVELOPMENTONLY | FCVAR_HIDDEN);
	}
}
```

`hack/cheats/features/misc/disable/convars.hpp`:

```hpp
#pragma once

namespace convars
{
	void run();
	void shutdown();
}
```

`hack/cheats/features/misc/disable/interpolate.cpp`:

```cpp
#include "interpolate.hpp"

#include <cheats/game/game.hpp>
#include <cheats/features/cache/cache.hpp>
#include <config/vars.hpp>

#include <cheats/hooks/frameStageNotify.hpp>

namespace
{
	struct InterpolateHandler : hooks::FrameStageNotify
	{
		InterpolateHandler()
		{
			this->registerRun(interpolate::run);
		}
	} interpolateHandler;
}

void interpolate::run(FrameStage stage)
{
	if (!vars::misc->disableItems->interpolate)
		return;

	if (stage != FRAME_NET_UPDATE_POSTDATAUPDATE_END)
		return;

	for (const auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		const auto player = entity->cast<Player_t*>();
		const auto map = player->getVarMap();
		if (!map)
			continue;

		for (int i = 0; i < map->m_interpolatedEntries; ++i)
		{
			const auto entry = &map->m_Entries[i];
			entry->m_needsToInterpolate = false;
		}
	}
}
```

`hack/cheats/features/misc/disable/interpolate.hpp`:

```hpp
#pragma once

enum FrameStage;

namespace interpolate
{
	void run(FrameStage stage);
};
```

`hack/cheats/features/misc/flashlight/flashlight.cpp`:

```cpp
#include "flashlight.hpp"

#include <SDK/CFlashlightEffect.hpp>
#include <SDK/IMemAlloc.hpp>
#include <SDK/Enums.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/ISurface.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <gamememory/memory.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/tools/tools.hpp>

#include <cheats/hooks/frameStageNotify.hpp>
#include <cheats/hooks/wndproc.hpp>

namespace
{
	struct FlashlightFSN : hooks::FrameStageNotify
	{
		FlashlightFSN()
		{
			this->registerRun(flashlight::run);
			this->registerShutdown(flashlight::shutdown);
		}
	} flashlightFSN;

	struct FlashlightKeys : hooks::wndProcSys
	{
		FlashlightKeys()
		{
			this->registerRun(flashlight::updateKeys);
		}
	};
}

namespace flashlight
{
	CFlashlightEffect* createFlashlight(float fov, Entity_t* ent, float farZ = 1000.0f, float linearAtten = 1000.0f);
	void destroyFlashLight(CFlashlightEffect* flashlight);
	void updateFlashlight(CFlashlightEffect* flashlight, const Vec3& pos, const Vec3& forward, const Vec3& right, const Vec3& up);

	CFlashlightEffect* flashlightPtr{ nullptr };
	const std::string_view flashlightEffect{ "effects/flashlight001" };
	const std::string_view flashlightSound{ "items\\flashlight1.wav" };
}

#pragma optimize("", off)
void flashlight::run(FrameStage stage)
{
	if (globals::isShutdown)
		return;

	if (stage != FRAME_RENDER_START)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	if (!vars::misc->flashLight->enabled)
		return;

	const auto key = vars::keys->flashLight;
	switch (key.getKeyMode())
	{
	case KeyMode::DOWN:
	{
		static bool done = false;

		if (key.isDown())
		{
			if (!done)
			{
				memory::interfaces::surface->playSound(flashlightSound.data());
				flashlightPtr = createFlashlight(vars::misc->flashLight->fov, game::localPlayer());
				done = true;
			}
		}
		else
		{
			if (done)
			{
				destroyFlashLight(flashlightPtr);
				flashlightPtr = nullptr;
				done = false;
			}
		}

		break;
	}
	case KeyMode::TOGGLE:
	{
		if (key.isPressed())
		{
			memory::interfaces::surface->playSound(flashlightSound.data());

			if (flashlightPtr)
			{
				destroyFlashLight(flashlightPtr);
				flashlightPtr = nullptr;
			}
			else
				flashlightPtr = createFlashlight(vars::misc->flashLight->fov, game::localPlayer());
		}

		break;
	}
	}

	if (!flashlightPtr)
		return;

	const auto [forward, right, up] = math::angleVectors(game::getViewAngles());

	flashlightPtr->m_isOn = true;
	flashlightPtr->m_castsShadows = true;
	flashlightPtr->m_bigMode = vars::misc->flashLight->bigMode;
	flashlightPtr->m_fov = vars::misc->flashLight->fov;

	updateFlashlight(flashlightPtr, game::localPlayer->getEyePos(), forward, right, up);
}
#pragma optimize("", on)

#pragma optimize("", off)
CFlashlightEffect* flashlight::createFlashlight(float fov, Entity_t* ent, float farZ, float linearAtten)
{
	const auto flashlightMemory = reinterpret_cast<CFlashlightEffect*>(memory::interfaces::memAlloc->_alloc(sizeof(CFlashlightEffect)));
	if (!flashlightMemory)
		return nullptr;

	memory::flashlightCreate()(flashlightMemory, nullptr, 0.0f, 0.0f, 0.0f, fov, ent->getIndex(), flashlightEffect.data(), farZ, linearAtten);

	return flashlightMemory;
}
#pragma optimize("", on)

#pragma optimize("", off)
void flashlight::destroyFlashLight(CFlashlightEffect* flashlight)
{
	memory::flashlightDestroy()(flashlight, nullptr); // second arg is not even used there
}
#pragma optimize("", on)

#pragma optimize("", off)
void flashlight::updateFlashlight(CFlashlightEffect* flashlight, const Vec3& pos, const Vec3& forward, const Vec3& right, const Vec3& up)
{
	memory::flashlightUpdate()(flashlight, flashlight->m_entIndex, pos, forward, right, up, flashlight->m_fov,
		flashlight->m_farZ, flashlight->m_LinearAtten, flashlight->m_castsShadows, flashlight->m_textureName);
}
#pragma optimize("", on)

#pragma optimize("", off)
void flashlight::shutdown()
{
	if (flashlightPtr)
	{
		destroyFlashLight(flashlightPtr);
		flashlightPtr = nullptr;
	}
}
#pragma optimize("", on)

void flashlight::updateKeys()
{
	vars::keys->flashLight.update();
}
```

`hack/cheats/features/misc/flashlight/flashlight.hpp`:

```hpp
#pragma once

enum FrameStage;

namespace flashlight
{
	void run(FrameStage stage);
	void shutdown();
	void updateKeys();
}
```

`hack/cheats/features/misc/movement/movement.cpp`:

```cpp
#include "movement.hpp"

#include <SDK/CUserCmd.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/rand.hpp>

#include <cheats/hooks/createMove.hpp>

namespace
{
	struct MovementHander : hooks::CreateMove
	{
		MovementHander()
		{
			this->registerInit(movement::init);
			this->registerRunPrePrediction(movement::run);
		}
	} movementHandler;
}

enum movetypes
{
	NOCLIP = 8,
	LADDER = 9
};

namespace movement
{
	// https://www.unknowncheats.me/forum/counterstrike-global-offensive/333797-humanised-bhop.html
	void bunnyhop(CUserCmd* cmd);
	void strafe(CUserCmd* cmd);

	IConVar* sideSpeed{ };
}

void movement::init()
{
	sideSpeed = memory::interfaces::cvar->findVar("cl_sidespeed");
}

void movement::run(CUserCmd* cmd)
{
	bunnyhop(cmd);
	strafe(cmd);
}

void movement::bunnyhop(CUserCmd* cmd)
{
	if (!vars::misc->bunnyHop->enabled)
		return;

	static bool skip = false;
	static bool jumped = false;

	if (!game::localPlayer)
		return;

	if (auto moveType = game::localPlayer->m_MoveType(); moveType == NOCLIP || moveType == LADDER)
		return;

	if (Random::getRandom<int>(0, 100) > vars::misc->bunnyHop->chance)
		return;

	const bool jump = cmd->m_buttons & IN_JUMP;

	if (!jumped && skip)
	{
		skip = false;
		cmd->m_buttons |= IN_JUMP;
	}
	else if (jump)
	{
		if (!game::localPlayer->isInAir())
		{
			jumped = true;
			skip = true;
		}
		else
		{
			cmd->m_buttons &= ~IN_JUMP;
			jumped = true;
		}
	}
	else
	{
		jumped = false;
		skip = false;
	}
}

void movement::strafe(CUserCmd* cmd)
{
	const int mode = vars::misc->bunnyHop->indexStrafe;
	if (mode == E2T(MovementStraferMode::OFF))
		return;

	if (!game::localPlayer)
		return;

	if (auto moveType = game::localPlayer->m_MoveType(); moveType == NOCLIP || moveType == LADDER)
		return;

	[[maybe_unused]] const bool jump = cmd->m_buttons & IN_JUMP;
	const bool inAir = game::localPlayer->isInAir();

	if (!game::localPlayer->isMoving())
		return;

	const float speed = game::localPlayer->m_vecVelocity().toVecPrev().length();

	switch (mode)
	{
	case E2T(MovementStraferMode::SIDESPEED):
	{
		if (inAir)
			cmd->m_sidemove = cmd->m_mousedx > 1 ? sideSpeed->getFloat() : -sideSpeed->getFloat();

		break;
	}
	case E2T(MovementStraferMode::ROTATE):
	{
		auto rotateStrafe = [=](float rotation, const float forward)
		{
			rotation *= math::DEG2RAD(1.0f);

			cmd->m_forwardmove = std::cos(rotation) * forward;
			cmd->m_sidemove = std::sin(rotation) * forward;
		};

		if (inAir)
		{
			// https://www.quakeworld.nu/wiki/QW_physics_air
			const float idealAngle = std::clamp(math::RAD2DEG(std::asin(30.0f / speed) * 0.5f), 0.0f, 45.0f);
			const float side = cmd->m_commandNumber % 2 ? 1.0f : -1.0f; // or use static -/+
			rotateStrafe((idealAngle - 90.0f) * side, sideSpeed->getFloat());
		}

		break;
	}
	case E2T(MovementStraferMode::DIRECTIONAL):
	{
		if (inAir)
		{
			auto calcDelta = [=]() // https://www.unknowncheats.me/wiki/Counter_Strike_Global_Offensive:Proper_auto-strafer
			{
				const static float maxSpeed = game::localPlayer->m_flMaxspeed(); // this does not change, or it does? correct me
				//printf("maxspee %f\n", maxSpeed);
				const static auto sv_airaccelerate = memory::interfaces::cvar->findVar("sv_airaccelerate");
				const float term = 30.0f / sv_airaccelerate->getFloat() / maxSpeed * 100.0f / speed;

				if (term < 1.0f && term > -1.0f)
					return std::acos(term);

				return 0.0f;
			};

			const float deltaAir = calcDelta();

			if (deltaAir != 0.0f)
			{
				const float yaw = math::DEG2RAD(cmd->m_viewangles[1]);
				const auto velocityVec = game::localPlayer->m_vecVelocity();
				const float velocityDirection = std::atan2(velocityVec[1], velocityVec[0]) - yaw;
				const float bestAngleMove = std::atan2(-cmd->m_sidemove, cmd->m_forwardmove);

				auto deltaAngle = [](float first, float second) // used to point out angle to finally calculate, detection of dir
				{
					const float delta = first - second;
					float res = std::isfinite(delta) ? std::remainder(delta, math::PI_2) : 0.0f;

					if (first > second)
					{
						if (res >= math::PI)
							res -= math::PI_2;
					}
					else
					{
						if (res <= -math::PI)
							res += math::PI_2;
					}

					return res;
				};

				const float delta = deltaAngle(velocityDirection, bestAngleMove);
				const float finalMove = delta < 0.0f ? velocityDirection + deltaAir : velocityDirection - deltaAir;

				cmd->m_forwardmove = std::cos(finalMove) * sideSpeed->getFloat();
				cmd->m_sidemove = -std::sin(finalMove) * sideSpeed->getFloat();
			}
		}

		break;
	}
	}
}

void movement::fixMovement(CUserCmd* cmd, const Vec3& oldAngle)
{
	const Vec3 angle = Vec3{ 0.0f, oldAngle[1], 0.0f };
	auto [forward, right, up] = math::angleVectors(angle);
	forward.normalize(); right.normalize(); // because those are not yet normalized

	const Vec3 angleNow = Vec3{ 0.0f, cmd->m_viewangles[1], 0.0f };
	auto [forwardNow, rightNow, upNow] = math::angleVectors(angleNow);

	const Vec3 forwardOld = forward * cmd->m_forwardmove;
	const Vec3 sideOld = right * cmd->m_sidemove;

	const float newForwardMove = forwardOld.dot(forwardNow) + sideOld.dot(forwardNow);
	const float newSideMove = forwardOld.dot(rightNow) + sideOld.dot(rightNow);

	cmd->m_forwardmove = newForwardMove;
	cmd->m_sidemove = newSideMove;
}
```

`hack/cheats/features/misc/movement/movement.hpp`:

```hpp
#pragma once

#include <SDK/math/Vector.hpp>

class CUserCmd;

namespace movement
{
	void run(CUserCmd* cmd);
	void init();

	void fixMovement(CUserCmd* cmd, const Vec3& oldAngle);
}
```

`hack/cheats/features/misc/thirdperson/thirdperson.cpp`:

```cpp
#include "thirdperson.hpp"

#include <SDK/IEngineTrace.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/Input.hpp>
#include <SDK/vars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <utilities/math/math.hpp>
#include <config/vars.hpp>

#include <cheats/hooks/overrideView.hpp>
#include <cheats/hooks/wndproc.hpp>

namespace
{
	struct ThirdpersonView : hooks::OverrideView
	{
		ThirdpersonView()
		{
			this->registerRun(thirdperson::run);
		}
	} thispersonView;

	struct ThirdpersonKeys : hooks::wndProcSys
	{
		ThirdpersonKeys()
		{
			this->registerRun(thirdperson::updateKeys);
		}
	} thirpersonKeys;
}

void thirdperson::updateKeys()
{
	vars::keys->thirdP.update();
}

void thirdperson::run(CViewSetup* view)
{
	if (!vars::misc->thirdp->enabled)
		return;

	if (!game::isAvailable())
		return;

	if (bool state = vars::keys->thirdP.isEnabled(); state)
	{
		Vec3 angles = game::getViewAngles();

		Trace_t trace;

		float fixedX = angles[0] += vars::misc->thirdp->x;
		float fixedY = angles[1] += vars::misc->thirdp->y;

		Vec3 camera = Vec3
		{
			std::cos(math::DEG2RAD(fixedY)) * vars::misc->thirdp->distance,
			std::sin(math::DEG2RAD(fixedY)) * vars::misc->thirdp->distance,
			std::sin(math::DEG2RAD(-fixedX)) * vars::misc->thirdp->distance,
		};
		Vec3 eyePos = game::localPlayer->getEyePos();
		TraceFilter filter;
		filter.m_skip = game::localPlayer();
		memory::interfaces::trace->traceRay({ eyePos, (eyePos - camera) }, MASK_SOLID, &filter, &trace);

		memory::interfaces::input->m_cameraInThirdPerson = state;
		memory::interfaces::input->m_cameraOffset = Vec3{ fixedX, fixedY, vars::misc->thirdp->distance * ((trace.m_fraction < 1.0f) ? trace.m_fraction : 1.0f) };
	}
	else if (globals::isShutdown || !state)
	{
		memory::interfaces::input->m_cameraInThirdPerson = false;
		memory::interfaces::input->m_cameraOffset = {};
	}
}
```

`hack/cheats/features/misc/thirdperson/thirdperson.hpp`:

```hpp
#pragma once

class CViewSetup;

namespace thirdperson
{
	void run([[maybe_unused]] CViewSetup* view);
	void updateKeys();
};

```

`hack/cheats/features/particle/particle.cpp`:

```cpp
#include "particle.hpp"

#include <SDK/interfaces/interfaces.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/CEffectData.hpp>
#include <utilities/utilities.hpp>
#include <gamememory/memory.hpp>

void* Particle::getCallAddr(const std::string_view name)
{
	int ret = -1;
	if (memory::particleIsCached()(memory::particleSystem(), name.data()))
		memory::particleFindStringIndex()(reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(memory::particleSystem()) + 0x14), &ret, name.data()); // esi+14h

	if (ret == -1)
		return nullptr;
	// *v3 + 4 * v5 - > v5 is casted unsigned __int16
	return *reinterpret_cast<void**>(*reinterpret_cast<uintptr_t*>(memory::particleSystem()) + (0x4 * static_cast<uint16_t>(ret)));
}

void Particle::dispatchParticleEffect(const std::string_view name, const Vec3& pos)
{
	Vec3 copyPos = pos;

	void* addr = getCallAddr(name);
	const static auto _call = memory::particleCall();
	void* created = createParticle(_call, addr, &copyPos);

	// update pos, you can see bytes in set control point
	__asm add esp, 8
	*reinterpret_cast<Vec3*>(reinterpret_cast<uintptr_t>(created) + 0x3B4) = copyPos;

	// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/c_particle_system.cpp#L339
	memory::particleSetControlPoint()(created, 0, &copyPos);
	memory::particleSetControlPoint()(created, 1, &copyPos);
}

// because calling ParticleStart or doing this by DispatchEvent did not work
// have to wrap this for new particle keyvalues method, new because judging by xrefs there was some "old" method
__declspec(naked) void* Particle::createParticle(void* caller, void* addr, Vec3* pos)
{
	__asm
	{
		push ebp
		mov ebp, esp
		push 0x0FFFFFFFF
		push 0
		mov edx, addr
		push ecx
		push pos
		call caller
		add esp, 0x10
		mov esp, ebp
		pop ebp
		retn
	}
}
```

`hack/cheats/features/particle/particle.hpp`:

```hpp
#pragma once

#include <SDK/math/Vector.hpp>

#include <string>


class Particle
{	
public:
	static void dispatchParticleEffect(const std::string_view name, const Vec3& pos);
private:
	static void* getCallAddr(const std::string_view name);
	// caller is passed because it's a naked function
	static void* createParticle(void* caller, void* addr, Vec3* pos);
};
```

`hack/cheats/features/prediction/prediction.cpp`:

```cpp
#include "prediction.hpp"

#include <SDK/IPrediction.hpp>
#include <SDK/CGameMovement.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/CPredictionCopy.hpp>
#include <SDK/IClientState.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>
#include <gamememory/memory.hpp>

#include <cheats/hooks/createMove.hpp>

#include <mutex>

namespace
{
	struct PredictionInit : hooks::CreateMove
	{
		PredictionInit()
		{
			this->registerInit(prediction::init);
		}
	} preidictionInit;
}

namespace prediction
{
	struct PredictionCache
	{
		bool isInPrediction;
		bool isFirstTimePredicted;
		float curTime;
		float frameTime;
		int tick;
		float weaponPenalty;
		float recoilIndex;
	} cache;

	uintptr_t* predictionRandomSeed;
	CMoveData* data;
	Player_t** player;

	void update();
	void end();
}

void prediction::init()
{
	predictionRandomSeed = memory::predictionSeed();
	data = memory::predictionData();
	player = memory::predictedPlayer();
}

// 55 8B EC 83 E4 C0 83 EC 34 53 56 8B 75 08
void prediction::begin(CUserCmd* cmd)
{
	if (!game::localPlayer)
		return;

	update();

	*game::localPlayer->m_pCurrentCommand() = cmd;
	game::localPlayer->m_LastCmd() = *cmd;

	*predictionRandomSeed = cmd->m_randomSeed;
	*player = game::localPlayer();

	// backup pre-prediction
	cache = PredictionCache
	{
		.isInPrediction = memory::interfaces::prediction->m_inPrediction,
		.isFirstTimePredicted = memory::interfaces::prediction->m_firstTimePredicted,
		.curTime = memory::interfaces::globalVars->m_curtime,
		.frameTime = memory::interfaces::globalVars->m_frametime,
		.tick = game::localPlayer->m_nTickBase(),
	};

	const auto weapon = game::localPlayer()->getActiveWeapon();
	if (weapon && !weapon->isNonAimable())
	{
		cache.weaponPenalty = weapon->getInaccuracy();
		cache.recoilIndex = weapon->m_flRecoilIndex();
	}

	memory::interfaces::globalVars->m_curtime = game::ticksToTime(game::localPlayer->m_nTickBase());
	memory::interfaces::globalVars->m_frametime = (memory::interfaces::prediction->m_enginePaused/* || game::localPlayer->m_fFlags() & FL_FROZEN*/)
		? 0.0f : memory::interfaces::globalVars->m_intervalPerTick;
	memory::interfaces::globalVars->m_tickCount = game::localPlayer->m_nTickBase();
	memory::interfaces::prediction->m_inPrediction = true;
	memory::interfaces::prediction->m_firstTimePredicted = false;

	// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/prediction.cpp#L1058
	cmd->m_buttons |= game::localPlayer->m_afButtonForced();
	cmd->m_buttons &= ~game::localPlayer->m_afButtonDisabled();

	memory::interfaces::gameMovement->startTrackPredictionErrors(game::localPlayer());

	if (cmd->m_weaponSelect != 0)
	{
		// >=0 < 0x2000
		const auto weaponFromHandle = reinterpret_cast<Weapon_t*>(memory::interfaces::entList->getClientEntity(cmd->m_weaponSelect));
		if (weaponFromHandle)
		{
			const auto data = memory::interfaces::weaponInterface->getWpnData(weaponFromHandle->m_iItemDefinitionIndex());
			if (data)
			{
				game::localPlayer->selectItem(data->m_WeaponName, cmd->m_weaponSubtype);
			}
		}
	}

	Entity_t* veh = nullptr;
	if (const auto vehHandle = game::localPlayer->m_hVehicle(); vehHandle.isValid()) // 0xFFFFFFFF
		veh = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientFromHandle(vehHandle));

	if (cmd->m_impulse && (!veh || game::localPlayer->usingStandardWeaponsInVehicle()))
		*game::localPlayer->m_nImpulse() = cmd->m_impulse;

	// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/prediction.cpp#L1090
	const auto cmdButtons = cmd->m_buttons;
	const auto localButtons = *game::localPlayer->m_nButtons();
	const auto buttonChanged = cmdButtons ^ localButtons;
	game::localPlayer()->m_afButtonLast() = localButtons;
	*game::localPlayer->m_nButtons() = cmdButtons;
	game::localPlayer->m_afButtonPressed() = buttonChanged & cmdButtons;
	game::localPlayer->m_afButtonReleased() = buttonChanged & (~cmdButtons);

	memory::interfaces::prediction->checkMovingGround(game::localPlayer(), memory::interfaces::globalVars->m_frametime);
	memory::interfaces::prediction->setLocalViewangles(cmd->m_viewangles);

	if (game::localPlayer->physicsRunThink(THINK_FIRE_ALL_FUNCTIONS))
		game::localPlayer->preThink();

	if (auto tick = game::localPlayer->m_nNextThinkTick();
		*tick > 0 && *tick <= game::localPlayer->m_nTickBase())
	{
		*tick = TICK_NEVER_THINK;
		game::localPlayer->runThink();
	}

	memory::interfaces::moveHelper->setHost(game::localPlayer());
	memory::interfaces::prediction->setupMove(game::localPlayer(), cmd, memory::interfaces::moveHelper(), data);
	if (!veh)
		memory::interfaces::gameMovement->processMovement(game::localPlayer(), data);
	else
		game::localPlayer->processMovement(veh, game::localPlayer(), data);
	memory::interfaces::prediction->finishMove(game::localPlayer(), cmd, data);
	memory::interfaces::moveHelper->processImpacts();
	//game::localPlayer->m_vecAbsVelocity() = m_data->m_velocity;
	//game::localPlayer->setAbsOrigin(game::localPlayer->m_vecNetworkOrigin());
	// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/prediction.cpp#L1513
	//game::localPlayer->m_iEFlags() &= ~(EFL_DIRTY_ABSTRANSFORM | EFL_DIRTY_ABSVELOCITY);

	game::localPlayer->postThink();

	if (weapon && !weapon->isNonAimable())
		weapon->updateAccuracyPenalty();

	memory::interfaces::prediction->m_inPrediction = cache.isInPrediction;
	memory::interfaces::prediction->m_firstTimePredicted = cache.isFirstTimePredicted;
}

void prediction::end()
{
	if (!game::localPlayer)
		return;

	memory::interfaces::gameMovement->finishTrackPredictionErrors(game::localPlayer());
	memory::interfaces::moveHelper->setHost(nullptr);

	*predictionRandomSeed = -1;
	*player = nullptr;
	*game::localPlayer->m_pCurrentCommand() = nullptr;

	memory::interfaces::globalVars->m_curtime = cache.curTime;
	memory::interfaces::globalVars->m_frametime = cache.frameTime;
	memory::interfaces::globalVars->m_tickCount = cache.tick;

	if (memory::interfaces::globalVars->m_frametime > 0.0f)
		++game::localPlayer->m_nTickBase();

	if (const auto wpn = game::localPlayer->getActiveWeapon(); wpn && !wpn->isNonAimable())
	{
		wpn->m_fAccuracyPenalty() = cache.weaponPenalty;
		wpn->m_flRecoilIndex() = cache.recoilIndex;
	}

	memory::interfaces::gameMovement->reset();

	//game::localPlayer->restoreData("Prediction::postEnd", 1313, PC_EVERYTHING);
}

void prediction::patchDatamap()
{
	// https://www.unknowncheats.me/forum/counterstrike-global-offensive/564094-guwop-prediction-datamap-variable-fix.html
	const auto map = game::localPlayer->getPredictionDataMap();
	static std::unique_ptr<Typedescription_t[]> data(new Typedescription_t[map->m_dataFields + 1]);
	std::memcpy(data.get(), map->m_dataDescription, map->m_dataFields * sizeof(Typedescription_t));

	Typedescription_t velmod = {};

	velmod.m_type = FIELD_FLOAT;
	velmod.m_name = "m_flVelocityModifier";
	velmod.m_offset[TD_OFFSET_NORMAL] = netvars::getNetvar("DT_CSPlayer", "m_flVelocityModifier");
	//int copiedPackedSize = map->m_packedSize;
	//copiedPackedSize = ALIGN_VALUE(copiedPackedSize, sizeof(float));
	//velmod.m_offset[TD_OFFSET_PACKED] = copiedPackedSize;
	velmod.m_size = 1;
	velmod.m_flags = FTYPEDESC_INSENDTABLE;
	velmod.m_sizeInBytes = sizeof(float);
	velmod.fieldTolerance = 0.1f;

	std::memcpy(&data.get()[map->m_dataFields], &velmod, sizeof(Typedescription_t));

	map->m_dataDescription = data.get();
	map->m_dataFields += 1;
	// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/shared/predictioncopy.cpp#L1556
	map->m_optimizedDataMap = nullptr; // Forcing the game to recompute flattened chains.

	//memory::interfaces::prediction->shutdownPredictables();
	//memory::interfaces::prediction->reinitPredictables();
}

void prediction::update()
{
	const static auto state = memory::interfaces::clientState;
	// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/engine/cl_pred.cpp#L64
	if (bool validframe = state->m_deltaTick > 0)
		memory::interfaces::prediction->update(state->m_deltaTick, validframe,
			state->m_lastCommandAck, state->m_lastOutGoingCommand + state->m_chockedCommands);

	//game::localPlayer->saveData("Prediction::preUpdate", 1313, PC_EVERYTHING);
}
```

`hack/cheats/features/prediction/prediction.hpp`:

```hpp
#pragma once

class CUserCmd;

namespace prediction
{
	void init();
	// move to allocation hook
	void patchDatamap();

	void begin(CUserCmd* cmd);
	void end();
}

```

`hack/cheats/features/tests/test.cpp`:

```cpp
#include "test.hpp"

#include <SDK/Enums.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/CUtlVector.hpp>
#include <SDK/material.hpp>
#include <SDK/IEffects.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/CTeslaInfo.hpp>
#include <SDK/IClientState.hpp>
#include <cheats/game/game.hpp>
#include <cheats/features/particle/particle.hpp>
#include <utilities/inputSystem.hpp>
#include <render/render.hpp>

#include <utilities/math/math.hpp>
#include <gamememory/memory.hpp>
#include <cheats/hooks/frameStageNotify.hpp>
#include <cheats/hooks/paintTraverse.hpp>

// place anything you want to test

namespace
{
	struct WeatherHandler : hooks::FrameStageNotify
	{
		WeatherHandler()
		{
			this->registerRun(test::run);
		}
	} /*weatherHandler*/;

	struct RenderTest : hooks::PaintTraverse
	{
		RenderTest()
		{
			this->registerRender(test::draw);
		}
	} /*renderTest*/;
}

void test::run(FrameStage stage)
{
	
	
}

void test::draw()
{
	if (!game::isAvailable())
		return;

	const Vec3& mins = memory::interfaces::gameWorld->m_WorldMins();
	const Vec3& maxs = memory::interfaces::gameWorld->m_WorldMaxs();
	const Vec3 center = (mins + maxs) * 0.5f;
	
	const float halfLength = std::abs(maxs[0] - mins[0]) * 0.5f;
	const float halfWidth = std::abs(maxs[1]  - mins[1]) * 0.5f;
	const float partHeight = std::abs(maxs[2] - mins[2]) * 0.75f;

	const Vec3 corner1 = Vec3{ center[0] + halfLength, center[1] + halfWidth, center[2] + partHeight };
	const Vec3 corner2 = Vec3{ center[0] + halfLength, center[1] - halfWidth, center[2] + partHeight };
	const Vec3 corner3 = Vec3{ center[0] - halfLength, center[1] + halfWidth, center[2] + partHeight };
	const Vec3 corner4 = Vec3{ center[0] - halfLength, center[1] - halfWidth, center[2] + partHeight };

	/*if (ImVec2 s; ImRender::worldToScreen(corner1, s))
	{
		ImRender::drawCircleFilled(s.x, s.y, 32.0f, 64, Colors::Orange);
	}
	if (ImVec2 s; ImRender::worldToScreen(corner2, s))
	{
		ImRender::drawCircleFilled(s.x, s.y, 32.0f, 64, Colors::Orange);
	}
	if (ImVec2 s; ImRender::worldToScreen(corner3, s))
	{
		ImRender::drawCircleFilled(s.x, s.y, 32.0f, 64, Colors::Orange);
	}
	if (ImVec2 s; ImRender::worldToScreen(corner4, s))
	{
		ImRender::drawCircleFilled(s.x, s.y, 32.0f, 64, Colors::Orange);
	}*/
}

/*
* adding entity: CWorld enum: 275
adding entity: CCSPlayer enum: 40
adding entity: CCSTeam enum: 43
adding entity: CCSTeam enum: 43
adding entity: CCSTeam enum: 43
adding entity: CCSTeam enum: 43
adding entity: CCSPlayerResource enum: 41
adding entity: CCSGameRulesProxy enum: 39
adding entity: CVoteController enum: 229
adding entity: CVoteController enum: 229
adding entity: CVoteController enum: 229
adding entity: CFogController enum: 78
adding entity: CSprite enum: 164
adding entity: CFuncRotating enum: 90
adding entity: CSprite enum: 164
adding entity: CSprite enum: 164
adding entity: CSprite enum: 164
adding entity: CLightGlow enum: 109
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSprite enum: 164
adding entity: CSprite enum: 164
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CBaseEntity enum: 11
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CBaseEntity enum: 11
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CColorCorrection enum: 37
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CWaterLODControl enum: 231
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CSprite enum: 164
adding entity: CSprite enum: 164
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CPredictedViewModel enum: 140
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CSpriteOriented enum: 165
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CFuncRotating enum: 90
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CPrecipitation enum: 138
adding entity: CWeaponNegev enum: 255
adding entity: CBaseWeaponWorldModel enum: 23
adding entity: CWeaponNegev enum: 255
adding entity: CBaseWeaponWorldModel enum: 23
adding entity: CWeaponNegev enum: 255
adding entity: CBaseWeaponWorldModel enum: 23
adding entity: CWeaponNegev enum: 255
adding entity: CBaseWeaponWorldModel enum: 23
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CCascadeLight enum: 35
adding entity: CBaseAnimating enum: 2
adding entity: CBreakableProp enum: 30
adding entity: CBreakableProp enum: 30
*/
/*
* adding entity: CWorld enum: 275
adding entity: CCSPlayer enum: 40
adding entity: CCSTeam enum: 43
adding entity: CCSTeam enum: 43
adding entity: CCSTeam enum: 43
adding entity: CCSTeam enum: 43
adding entity: CCSPlayerResource enum: 41
adding entity: CCSGameRulesProxy enum: 39
adding entity: CVoteController enum: 229
adding entity: CVoteController enum: 229
adding entity: CVoteController enum: 229
adding entity: CFogController enum: 78
adding entity: CSprite enum: 164
adding entity: CFuncRotating enum: 90
adding entity: CSprite enum: 164
adding entity: CSprite enum: 164
adding entity: CSprite enum: 164
adding entity: CLightGlow enum: 109
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSprite enum: 164
adding entity: CSprite enum: 164
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CBaseEntity enum: 11
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CBaseEntity enum: 11
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CColorCorrection enum: 37
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CBaseEntity enum: 11
adding entity: CDynamicLight enum: 51
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CWaterLODControl enum: 231
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CRopeKeyframe enum: 149
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CSprite enum: 164
adding entity: CSprite enum: 164
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CSpriteOriented enum: 165
adding entity: CDynamicProp enum: 52
adding entity: CPredictedViewModel enum: 140
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CSpriteOriented enum: 165
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CLightGlow enum: 109
adding entity: CFuncRotating enum: 90
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CSpriteOriented enum: 165
adding entity: CPrecipitation enum: 138
adding entity: CWeaponNegev enum: 255
adding entity: CBaseWeaponWorldModel enum: 23
adding entity: CWeaponNegev enum: 255
adding entity: CBaseWeaponWorldModel enum: 23
adding entity: CWeaponNegev enum: 255
adding entity: CBaseWeaponWorldModel enum: 23
adding entity: CWeaponNegev enum: 255
adding entity: CBaseWeaponWorldModel enum: 23
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CDynamicProp enum: 52
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CSpotlightEnd enum: 163
adding entity: CBeam enum: 24
adding entity: CCascadeLight enum: 35
adding entity: CBaseAnimating enum: 2
adding entity: CBreakableProp enum: 30
adding entity: CBreakableProp enum: 30
*/
```

`hack/cheats/features/tests/test.hpp`:

```hpp
#pragma once

enum FrameStage;

namespace test
{
	void run(FrameStage stage);
	void draw();
}
```

`hack/cheats/features/visuals/chams/chams.cpp`:

```cpp
#include "chams.hpp"

#include "editor.hpp"

#include <SDK/material.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/KeyValuesSys.hpp>
#include <SDK/KeyValues.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVModelRender.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IVStudioRender.hpp>
#include <SDK/IMatRenderContext.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/materialInit.hpp>

#include <utilities/tools/wrappers.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/console/console.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>

#include <cheats/features/cache/cache.hpp>
#include <cheats/hooks/drawModelExecute.hpp>
#include <cheats/helper/initable.hpp>

namespace
{
	struct ChamsHandler : hooks::DrawModelExecute
	{
		ChamsHandler()
		{
			this->registerInit(chams::initMaterials);
		}
	} chamsHandler;

	struct ChamsInit : InitAble
	{
		ChamsInit()
		{
			this->registerInit(chams::init);
		}
	} chamsInit;
}

namespace chams
{
	bool initedMats{ false };
}

void chams::init()
{
	MaterialData flat
	{ 
		.name = "Flat",
		.key = "UnlitGeneric",
		.createType = CreationType::FROM_STRING 
	};
	materials.push_back(flat);

	MaterialData _generic
	{ 
		.name = "Generic",
		.key = "VertexLitGeneric",
		.createType = CreationType::FROM_STRING 
	};
	materials.push_back(_generic);

	MaterialData glow
	{	.name = "Glow",
		.key = "VertexLitGeneric",
		.buffer = "$additive 1 $envmap models/effects/cube_white $envmapfresnel 1 $envmaptint 1",
		.createType = CreationType::FROM_STRING,
		.materialType = MaterialTypes::GLOW
	};
	materials.push_back(glow);

	MaterialData metalic
	{ 
		.name = "Metalic",
		.key = "VertexLitGeneric",
		.buffer = "$basetexture white $envmap env_cubemap $normalmapalphaenvmapmask 1 $envmapcontrast 1 $nofog 1 $model 1 $nocull 0 $selfillum 1 $halfambert 1 $znearer 0 $flat 1",
		.createType = CreationType::FROM_STRING,
	};
	materials.push_back(metalic);


	MaterialData pearlescent
	{
		.name = "Pearlescent",
		.key = "VertexLitGeneric",
		.buffer = "$ambientonly 1 $phong 1 $pearlescent 3 $basemapalphaphongmask 1",
		.createType = CreationType::FROM_STRING
	};
	materials.push_back(pearlescent);

	console::debug("chams init");
}

void chams::initMaterials()
{
	for (auto& materialData : materials)
		materialData.material = material::factory::createMaterial(materialData);

	streamProof.init();
	streamProofDME.init();

	initedMats = true;
}

namespace chams::manual
{
	void overrideChams(int styles, bool wireframe, const Color& color);
	void passChams(Player_t* player, CfgCham& cham);
	void drawModel(Player_t* player, bool visible);
	void drawBacktrack(Player_t* player);

	bool shouldRun{ false };
	constexpr int renderFlags = STUDIO_RENDER | STUDIO_DRAWTRANSLUCENTSUBMODELS | STUDIO_SKIP_FLEXES | STUDIO_DONOTMODIFYSTENCILSTATE | STUDIO_SKIP_DECALS;
}

namespace chams::DME
{
	enum class Type
	{
		NONE,
		PLAYER,
		LOCAL_WEAPON,
		ARMS
	};

	void callOriginal();

	namespace stored
	{
		IMatRenderContext* ctx;
		DrawModelState_t state;
		ModelRenderInfo_t info;
		Matrix3x4* matrix;
	}

	bool shouldDisable{ false };
}

#pragma region DME
void chams::DME::callOriginal()
{
	hooks::DrawModelExecute::getOriginal()(memory::interfaces::modelRender(), stored::ctx, stored::state, stored::info, stored::matrix);
}

bool chams::DME::shouldDisableDME(const ModelRenderInfo_t& info)
{
	if (!vars::visuals->chams->players.enabled)
		return false;

	const auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(info.m_entIndex));
	if (ent && ent->isPlayer() && ent->isOtherTeam(game::localPlayer()))
	{
		if (vars::visuals->chams->streamProof)
		{
			// HACK, trick the render streamproof to render something
			//memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
			callOriginal();
		}

		return true;
	}

	return false;
}

bool chams::DME::run(IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix)
{
	stored::ctx = ctx;
	stored::state = state;
	stored::info = info;
	stored::matrix = matrix;

	chams::streamProofDME.setActive(vars::visuals->chams->streamProof);

	const auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(info.m_entIndex));
	std::string_view name = info.m_model->m_name;

	constexpr std::string_view prefix = "models/weapons/v_";
	if (name.starts_with(prefix))
	{
		name = name.substr(prefix.length());

		if (name.find("arms") != std::string::npos)
		{
			if (vars::visuals->chams->arms.enabled)
			{
				if (vars::visuals->chams->streamProof)
				{
					callOriginal();
				}

				streamProofDME.beginMaterialHook();

				manual::overrideChams(vars::visuals->chams->arms.index, vars::visuals->chams->arms.wireframe, vars::visuals->chams->arms.color());
				callOriginal();
				memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
				streamProofDME.endMaterialHook();

				return true;
			}
		}
		else if (auto cl = ent->clientClass(); ent && cl && cl->m_classID == CPredictedViewModel)
		{
			if (vars::visuals->chams->weapon.enabled)
			{
				if (vars::visuals->chams->streamProof)
				{
					callOriginal();
				}

				streamProofDME.beginMaterialHook();

				manual::overrideChams(vars::visuals->chams->weapon.index, vars::visuals->chams->weapon.wireframe, vars::visuals->chams->weapon.color());
				callOriginal();
				memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
				streamProofDME.endMaterialHook();

				return true;
			}
		}
	}

	return false;
}
#pragma endregion

#pragma region manual
void chams::manual::overrideChams(int styles, bool wireframe, const Color& color)
{
	const auto& mat = materials.at(styles);

	mat.material->setMaterialVarFlag(MATERIAL_VAR_WIREFRAME, wireframe);

	if (mat.materialType == MaterialTypes::GLOW)
	{
		if (const auto envmap = mat.material->findVar("$envmaptint"))
			envmap->setValues(color);

		mat.material->setMaterialVarFlag(MATERIAL_VAR_ADDITIVE, true);
	}

	mat.material->modulateAllColor(color);

	memory::interfaces::studioRender->forcedMaterialOverride(mat.material);
}

// this is messy arg, visible is for attachments only
void chams::manual::drawModel(Player_t* player, bool visible)
{
	const uint8_t instanceAlpha = 255;

	if (vars::visuals->chams->players.enabled)
		player->drawModel(renderFlags, instanceAlpha);

	if (vars::visuals->chams->attachement.enabled)
	{
		Entity_t* attachment = player->firstMoveChild();

		while (attachment)
		{
			if (attachment->shouldDraw())
			{
				auto& cfg = vars::visuals->chams->attachement;
				overrideChams(cfg.index, cfg.wireframe, visible ? cfg.color() : cfg.colorXQZ());

				attachment->drawModel(renderFlags, instanceAlpha);
			}
			attachment = attachment->nextMovePeer();
		}
	}
}

// some maybe "more engine friendly" drawing through walls with using stencils rather than doing it raw
void chams::manual::passChams(Player_t* player, CfgCham& cham)
{
	DME::shouldDisable = true;

	if (cham.ignorez)
	{
		auto ctx = memory::interfaces::matSys->getRenderContext();
		if (!ctx)
			return;

		// don't clear any, we just want to mess with stencils
		ctx->clearBuffers(false, false, true);

		ShaderStencilState_t stencilVisible;
		stencilVisible.m_bEnable = true;
		stencilVisible.m_nWriteMask = 0xFF;
		stencilVisible.m_nReferenceValue = 1;
		stencilVisible.m_nTestMask = 0x0;
		stencilVisible.m_CompareFunc = SHADER_STENCILFUNC_ALWAYS;
		stencilVisible.m_PassOp = SHADER_STENCILOP_SET_TO_REFERENCE;
		stencilVisible.m_FailOp = SHADER_STENCILOP_KEEP;
		stencilVisible.m_ZFailOp = SHADER_STENCILOP_KEEP;

		ctx->setStencilState(stencilVisible);

		overrideChams(cham.index, cham.wireframe, cham.color());
		drawModel(player, true);

		ShaderStencilState_t stencilIgnorez;
		stencilIgnorez.m_bEnable = true;
		stencilIgnorez.m_nWriteMask = 0x0;
		stencilIgnorez.m_nReferenceValue = 0;
		stencilIgnorez.m_nTestMask = 0xFF;
		stencilIgnorez.m_CompareFunc = SHADER_STENCILFUNC_EQUAL;
		stencilIgnorez.m_PassOp = SHADER_STENCILOP_KEEP;
		stencilIgnorez.m_FailOp = SHADER_STENCILOP_KEEP;
		stencilIgnorez.m_ZFailOp = SHADER_STENCILOP_KEEP;

		ctx->setStencilState(stencilIgnorez);

		overrideChams(cham.index, cham.wireframe, cham.colorXQZ());
		ctx->depthRange(0.0f, 0.01f); // 0.01f is not magic, it comes as lowest possible for pixel visibility system
		drawModel(player, false);
		ctx->depthRange(0.0f, 1.0f);

		ctx->disableStencil();

		memory::interfaces::studioRender->forcedMaterialOverride(nullptr);

		return;
	}

	// otherwise, let the engine do all

	overrideChams(cham.index, cham.wireframe, cham.color());
	drawModel(player, true);
	memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
}

#include <SDK/IVRenderView.hpp>
#include <SDK/CGlobalVars.hpp>
#include <cheats/features/backtrack/backtrack.hpp>

// saves a lot, many drawmodel calls may end up tragic for performance
#define OPTIMIZE_BT_CHAMS true

void chams::manual::drawBacktrack(Player_t* player)
{
	if (!vars::visuals->chams->backtrackEnabled)
		return;

	auto& records = backtrack::records.at(player->getIndex());
	if (records.empty())
		return;
	
#if OPTIMIZE_BT_CHAMS == true
	constexpr size_t backtrackSkips = 3;
#else
	constexpr size_t backtrackSkips = 1;
#endif
	constexpr uint8_t instanceAlpha = 255;
	const Vec3& backupOrigin = player->absOrigin();
	const Vec3& backupAngles = player->absAngles();

	if (backupOrigin == records.back().origin)
		return;

	switch (vars::visuals->chams->backtrackMode)
	{
	case E2T(BTChamsType::STABLE):
	{
		for (size_t i = 1; i < records.size(); i += backtrackSkips)
		{
			if (!backtrack::isValid(records.at(i).simtime))
				break;

			overrideChams(vars::visuals->chams->backtrackIndex, false, vars::visuals->chams->backtrackColor());

			const auto backupMemory = player->m_CachedBoneData().m_memory;

			CUtlMemory<Matrix3x4> memoryBacktrack{ };
			memoryBacktrack.m_pMemory = records.at(i).matrices.data();		

			player->m_CachedBoneData().m_memory = memoryBacktrack;

			player->drawModel(renderFlags, instanceAlpha);

			player->m_CachedBoneData().m_memory = backupMemory;

			memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
		}

		break;
	}
	case E2T(BTChamsType::LAST_TICK):
	{
		if (backtrack::isValid(records.front().simtime))
		{
			overrideChams(vars::visuals->chams->backtrackIndex, false, vars::visuals->chams->backtrackColor());

			const auto backupMemory = player->m_CachedBoneData().m_memory;

			CUtlMemory<Matrix3x4> memoryBacktrack{ };
			memoryBacktrack.m_pMemory = records.back().matrices.data();

			player->m_CachedBoneData().m_memory = memoryBacktrack;

			player->drawModel(renderFlags, instanceAlpha);

			player->m_CachedBoneData().m_memory = backupMemory;

			memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
		}

		break;
	}
	case E2T(BTChamsType::COLOR_CHANGE):
	{
		Color fromCfg = vars::visuals->chams->backtrackColor();

		for (size_t i = 1; i < records.size(); i += backtrackSkips)
		{
			if (!backtrack::isValid(records.at(i).simtime))
				break;

			Color color{ fromCfg.r() - (i * (1.0f / records.size())),
				i * (fromCfg.g() / records.size()), fromCfg.b(), fromCfg.a() };

			overrideChams(vars::visuals->chams->backtrackIndex, false, color);

			const auto backupMemory = player->m_CachedBoneData().m_memory;

			CUtlMemory<Matrix3x4> memoryBacktrack{ };
			memoryBacktrack.m_pMemory = records.at(i).matrices.data();

			player->m_CachedBoneData().m_memory = memoryBacktrack;

			player->drawModel(renderFlags, instanceAlpha);

			player->m_CachedBoneData().m_memory = backupMemory;

			memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
		}

		break;
	}
	}
}

void chams::manual::run()
{
	DME::shouldDisable = false;

	if (!initedMats)
		return;

	if (!game::isAvailable())
		return;

	if (vars::visuals->chams->players.enabled || vars::visuals->chams->attachement.enabled || vars::visuals->chams->backtrackEnabled)
	{
		for (auto [ent, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
		{
			const auto player = ent->cast<Player_t*>();
			if (!player->isOtherTeam(game::localPlayer()))
				continue;

			drawBacktrack(player);
			passChams(player, vars::visuals->chams->players);
		}
	}
}
#pragma endregion
```

`hack/cheats/features/visuals/chams/chams.hpp`:

```hpp
#pragma once

#include "factory/factory.hpp"
#include "../streamproof/streamproof.hpp"

#include <SDK/math/matrix.hpp>

#include <vector>

struct DrawModelState_t;
struct ModelRenderInfo_t;
class IMatRenderContext;

namespace chams
{
	void init();
	void initMaterials();

	namespace DME
	{
		bool shouldDisableDME(const ModelRenderInfo_t& info);
		bool run(IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix);
	}

	namespace manual
	{
		void run();
	}

	inline std::vector<MaterialData> materials;
	inline StreamProof streamProof{ "chams1337" };
	inline StreamProof streamProofDME{ "chams1337dme" };
}
```

`hack/cheats/features/visuals/chams/editor.cpp`:

```cpp
#include "editor.hpp"

#include "factory/factory.hpp"
#include "chams.hpp"

#include <utilities/tools/wrappers.hpp>
#include <utilities/tools/tools.hpp>
#include <menu/GUI-ImGui/imguiaddons.hpp>
#include <deps/ImGui/imgui_markdown.h>
#include <deps/magic_enum/prettyNames.hpp>
#include <config/jsonExtended.hpp>
#include <config/config.hpp>
#include <SDK/material.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/KeyValues.hpp>
#include <SDK/KeyValuesSys.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>

#include <imgui.h>
#include <imgui_internal.h>
#include <imgui_stdlib.h>
#include <ranges>
#include <fstream>
#include <Shellapi.h>
#include <nlohmann/json.hpp>
#include <deps/ImGui/editor/TextEditor.hpp>

#include <cheats/helper/initable.hpp>
#include <cheats/hooks/drawModelExecute.hpp>

//#define USE_IMGUI_VANILLA_EDITOR

namespace
{
	struct EditorHandler : InitAble
	{
		EditorHandler()
		{
			this->registerInit(materialEditor::initEditor);
		}
	} editorHandler;

	struct EditorDME : hooks::DrawModelExecute
	{
		EditorDME()
		{
			this->registerRun(materialEditor::passDME);
		}
	} editorDME;
}

#if defined USE_IMGUI_VANILLA_EDITOR
struct SimpleEditor
{
	void SetText(const std::string& text)
	{
		this->text = text;
	}
	std::string GetText() const
	{
		return text;
	}

	void Render(const std::string& title)
	{
		ImGui::InputTextMultiline(title.c_str(), &text, ImVec2(-FLT_MIN, -FLT_MIN), ImGuiInputTextFlags_AllowTabInput | ImGuiInputTextFlags_CtrlEnterForNewLine);
	}

	std::string text;
};
#endif

namespace materialEditor
{
	bool loadCfg();
	bool saveCfg();
	bool saveCfgIndex();

	bool isMaterialValid(MaterialData& data, bool updating = false);
	std::filesystem::path getPathForConfig();

	void renderHelpBar();
	void renderAddMaterial();
	void renderMaterialsList();
	void renderMaterialsView();
	void renderMaterialInfo(MaterialData& mat);
	void passCreationDme(const MaterialData& data, int index, bool push);

	std::vector<MaterialData> editorMaterials;
	size_t index{ 0 };
	size_t initialIndexChams{ 0 }; // manual chams are on top so 5 manual + edited... as example

	bool opened{ false };
	bool subAddOpened{ false };

	constexpr std::string_view folderName{ "materials" };
	std::filesystem::path saveDir;

#if defined USE_IMGUI_VANILLA_EDITOR
	SimpleEditor mainEditor;
	SimpleEditor subAddEditor;
#else
	TextEditor mainEditor;
	TextEditor subAddEditor;
#endif

	MaterialData materialToAdd;
	nlohmann::json m_json;

	namespace DME
	{
		MaterialData temp;
		bool createdMaterial{ true };
		int index{ 0 };
		bool toPush{ false };
	}
}

using json = nlohmann::json;

void from_json(const json& j, MaterialData& val)
{
	from_json(j, "Name", val.name);
	from_json(j, "Key", val.key);
	from_json(j, "Buf", val.buffer);
	from_json(j, "Creation", val.createType);
	from_json(j, "Type", val.materialType);
}

void to_json(json& j, const MaterialData& val)
{
	j["Name"] = val.name;
	j["Key"] = val.key;
	j["Buf"] = val.buffer;
	j["Creation"] = val.createType;
	j["Type"] = val.materialType;
}

void markdownEditor(const std::string& markdown_)
{
	static ImGui::MarkdownConfig mdConfig;

	auto callback = [](ImGui::MarkdownLinkCallbackData clbData)
	{
		std::string url{ clbData.link, static_cast<size_t>(clbData.linkLength) };
		if (!clbData.isImage)
		{
			ShellExecuteA(NULL, "open", url.c_str(), NULL, NULL, SW_SHOWNORMAL);
		}
	};

	mdConfig.linkCallback = callback;
	ImGui::Markdown(markdown_.c_str(), markdown_.length(), mdConfig);
}

void materialEditor::draw()
{
	if (!game::isAvailable())
	{
		ImGui::TextUnformatted("Editor will show after you load to the map");
		return;
	}

	ImGui::BeginChild("##editor");
	{
		renderAddMaterial();
		renderMaterialsList();
		renderMaterialsView();
	}
	ImGui::EndChild();
}

void materialEditor::renderHelpBar()
{
	const std::string text
	{
		"First, read basics written [here](https://developer.valvesoftware.com/wiki/KeyValues)\n"
		"Second, read about [materials](https://developer.valvesoftware.com/wiki/Material)\n"
		"**CTRL-S as a shortcut adds / updates current material**"
	};
	markdownEditor(text);
}

void materialEditor::renderAddMaterial()
{
	if (!subAddOpened)
		return;

	if (ImGui::Begin("New material", &subAddOpened, ImGuiWindowFlags_NoCollapse))
	{
		renderMaterialInfo(materialToAdd);

		if (ImGui::Shortcut(ImGuiMod_Ctrl | ImGuiKey_S))
		{
			// override always on saving attempt only
			materialToAdd.buffer = subAddEditor.GetText();
			if (isMaterialValid(materialToAdd))
			{
				// everything provided, now update material
				passCreationDme(materialToAdd, initialIndexChams + index + 1, true);

				// update to general view
				editorMaterials.push_back(materialToAdd);

				// force new material to be selected in view child
				index = editorMaterials.size() - 1;
				// force new material buffer to be displayed in view
				mainEditor.SetText(materialToAdd.buffer);

				saveCfgIndex();

				ImNotify::add(ImNotify{ 5.0f, "Added material", std::format("Name {} Key {}\nBuf length {}", materialToAdd.name, materialToAdd.key, materialToAdd.buffer.length()) });

				subAddOpened = false;
				// after close, we could reset materialtoadd, I prefer to cache last added
			}
			else
				ImNotify::add(ImNotify{ 5.0f, "Error adding material", "Please check duplication or you left inputs empty" });
		}

		subAddEditor.Render("Material to add");

		ImGui::End();
	}
}

void materialEditor::renderMaterialInfo(MaterialData& mat)
{
	ImGui::TextUnformatted("Strategy");
	ImGui::RadioButton("Buffer", reinterpret_cast<int*>(&mat.createType), 0);
	ImGui::SameLine();
	ImGui::RadioButton("From String", reinterpret_cast<int*>(&mat.createType), 1);
	ImGui::InputText("Name", &mat.name);
	ImGui::InputText("Key", &mat.key);
	ImGui::Combo("Style", reinterpret_cast<int*>(&mat.materialType), magic_enum::enum_names_pretty<MaterialTypes>());
}

void materialEditor::renderMaterialsList()
{
	ImGui::BeginChild("left pane", ImVec2{ 150.0f, 0.0f }, true);
	{
		for (size_t i = 0; i < editorMaterials.size(); ++i)
		{
			if (ImGui::Selectable(editorMaterials.at(i).name.c_str(), index == i))
			{
				// cache text
				editorMaterials.at(index).buffer = mainEditor.GetText();
				index = i;
				mainEditor.SetText(editorMaterials.at(index).buffer);
			}
		}

		ImGui::EndChild();
	}
	ImGui::SameLine();
}

void materialEditor::renderMaterialsView()
{
	ImGui::BeginChild("Materials view");
	{

		ImGui::BeginChild("InfoL", ImVec2{ ImGui::GetContentRegionAvail().x * 0.5f, 50.0f }, false);
		{
			renderHelpBar();

			ImGui::EndChild();
		}

		ImGui::SameLine();

		ImGui::BeginChild("InfoR", ImVec2{ 0.0f, 50.0f }, false);
		{
			if (ImGui::Button("Press to open Add-Window##material"))
			{
				subAddOpened = true;
			}

			if (ImGui::Button("Delete"))
			{
				if (!editorMaterials.empty())
				{
					const auto& backupName = editorMaterials.at(index).name;
					m_json.erase(m_json.find(editorMaterials.at(index).name));
					chams::materials.erase(chams::materials.end() - editorMaterials.size() + index);
					editorMaterials.erase(editorMaterials.begin() + index);
					index -= 1;

					saveCfg();

					if (editorMaterials.empty())
						mainEditor.SetText("");
					else
						mainEditor.SetText(editorMaterials.at(index).buffer);

					ImNotify::add(ImNotify{ 5.0f, "Deleted material", std::format("Name {}", backupName) });
				}
				else
					ImNotify::add(ImNotify{ 5.0f, "Deleted nothing", "You have 0 materials..." });
			}

			ImGui::EndChild();
		}


		if (!editorMaterials.empty())
			ImGui::TextUnformatted(std::format("{}", editorMaterials.at(index).name).c_str());
		else
			ImGui::TextUnformatted("No materials yet, add one!");

		if (editorMaterials.size())
		{
			ImGui::Separator();

			auto& materialNow = editorMaterials.at(index);

			renderMaterialInfo(materialNow);

			if (ImGui::Shortcut(ImGuiMod_Ctrl | ImGuiKey_D))
			{
				/*const auto toCopy = m_ImEditor.GetCurrentLineText();
				m_ImEditor.Paste(toCopy);*/
			}

			mainEditor.Render("Editor##mat");

			// we update the material that already exists.
			if (ImGui::Shortcut(ImGuiMod_Ctrl | ImGuiKey_S))
			{
				if (isMaterialValid(materialNow, true))
				{
					// overwrite material
					materialNow.buffer = mainEditor.GetText();
					passCreationDme(materialNow, initialIndexChams + index + 1, false);

					saveCfgIndex();

					ImNotify::add(ImNotify{ 5.0f, "Updated material", std::format("Name {} Key {}\nBuf length {}", materialNow.name, materialNow.key, materialNow.buffer.length()) });
				}
				else
					ImNotify::add(ImNotify{ 5.0f, "Error updating material", "Can't update material\nInvalid name / key" });
			}
		}

		ImGui::EndChild();
	}
}

void materialEditor::passCreationDme(const MaterialData& data, int index, bool push)
{
	DME::temp = data;
	DME::index = index;
	DME::toPush = push;

	DME::createdMaterial = false;
}

void materialEditor::passDME(IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix)
{
	if (DME::createdMaterial)
		return;

	DME::temp.material = material::factory::createMaterial(DME::temp);
	if (DME::toPush)
		chams::materials.push_back(DME::temp);
	else
		chams::materials.at(DME::index) = DME::temp;

	DME::createdMaterial = true;
}

bool materialEditor::isMaterialValid(MaterialData& _data, bool updating)
{
	auto allMaterials = editorMaterials;
	// special case: we update material and want to keep detection, but add current record as exception
	if (updating)
		allMaterials.erase(allMaterials.begin() + index);

	const auto itr = std::ranges::find_if(allMaterials, [_data](const MaterialData& data) { return data.name == _data.name; });
	if (itr != allMaterials.end())
		return false;
	
	return !_data.name.empty()
		&& !_data.key.empty();
}

void materialEditor::initEditor()
{
	saveDir = api::getHackPath() / api::getExtraLoadPath() / folderName / getPathForConfig();

	initialIndexChams = chams::materials.size() - 1;

	loadCfg();

	mainEditor.SetText(editorMaterials.empty() ? "" : editorMaterials.front().buffer);

#if !defined USE_IMGUI_VANILLA_EDITOR
	mainEditor.SetLanguageDefinition(TextEditor::LanguageDefinition::ValveKeyValues());
	subAddEditor.SetLanguageDefinition(TextEditor::LanguageDefinition::ValveKeyValues());
#endif

	console::debug("editor init");
}

bool materialEditor::loadCfg()
{
	if (auto path = api::getHackPath() / api::getExtraLoadPath() / folderName; !std::filesystem::exists(path))
		std::filesystem::create_directories(path);

	std::ifstream input{ saveDir };
	if (!input)
		return false;

	if (!std::filesystem::is_empty(saveDir))
	{
		m_json = json::parse(input);

		for (const auto& [key, value] : m_json.items())
		{
			MaterialData material;
			from_json(value, material);

			editorMaterials.push_back(material);
			// now also inform chams to add those
			chams::materials.push_back(material);
		}
	}

	return true;
}

bool materialEditor::saveCfg()
{
	std::ofstream out{ saveDir };
	if (!out)
		return false;

	json j;

	for (auto& material : editorMaterials)
		to_json(j[material.name], material);

	if (!j.empty())
		m_json.update(j);

	out << std::setw(4) << m_json;

	return true;
}

bool materialEditor::saveCfgIndex()
{
	std::ofstream out{ saveDir };
	if (!out)
		return false;

	json j;
	
	to_json(j[editorMaterials.at(index).name], editorMaterials.at(index));

	if (!j.empty())
		m_json.update(j);

	out << std::setw(4) << m_json;

	return true;
}

std::filesystem::path materialEditor::getPathForConfig()
{
	std::filesystem::path path{ folderName };
	if (path.extension() != ".json")
		path.replace_extension(".json");

	return path;
}
```

`hack/cheats/features/visuals/chams/editor.hpp`:

```hpp
#pragma once

struct MaterialData;
class IMatRenderContext;
struct DrawModelState_t;
struct ModelRenderInfo_t;

#include <SDK/math/matrix.hpp>

namespace materialEditor
{
	void draw();
	void initEditor();
	void passDME([[maybe_unused]]IMatRenderContext* ctx, [[maybe_unused]] const DrawModelState_t& state, [[maybe_unused]] const ModelRenderInfo_t& info, [[maybe_unused]] Matrix3x4* matrix);
}
```

`hack/cheats/features/visuals/chams/factory/factory.cpp`:

```cpp
#include "factory.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <SDK/KeyValuesSys.hpp>
#include <SDK/KeyValues.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <utilities/console/console.hpp>

#include <cheats/hooks/drawModelExecute.hpp>

namespace
{
	struct MaterialsShutdown : hooks::DrawModelExecute
	{
		MaterialsShutdown()
		{
			this->registerShutdown(material::factory::shutdown);
		}
	} materialShutdown;
}

IMaterial* material::factory::createMaterial(const MaterialData& data)
{
	KeyValues* keys{ nullptr };
	if (data.createType == CreationType::BY_BUFFER)
	{
		keys = new KeyValues{ data.key.c_str() };
		keys->fromBuffer(data.name.c_str(), data.buffer.c_str());
	}
	else
	{
		constexpr auto toRemove = [](char c) { return c == '\n' || c == '\t'; };

		std::string fixedBuffer{ data.buffer };
		fixedBuffer.erase(std::remove_if(fixedBuffer.begin(), fixedBuffer.end(), toRemove), fixedBuffer.end());

		keys = KeyValues::fromString(data.key.c_str(), fixedBuffer.c_str());
	}
	assert(keys);

	const auto material = memory::interfaces::matSys->createMaterial(data.name.data(), keys);

	assert(material);
	assert(material->isError() == false); // handle on own?

	//material->addRefCount();

	MaterialData dataToPush{ data };
	dataToPush.material = material;

	materials.push_back(dataToPush);

	console::debug("Added {} material", data.name);

	return material;
}

IMaterial* material::factory::findMaterial(char const* name, const char* group, bool complain, const char* prefix)
{
	IMaterial* mat = memory::interfaces::matSys->findMaterial(name, group, complain, prefix);
	assert(mat);

	return mat;
}

ITexture* material::factory::findTexture(char const* name, const char* group, bool complain, int additionalFlags)
{
	ITexture* tex = memory::interfaces::matSys->findTexture(name, group, complain, additionalFlags);
	assert(tex);

	return tex;
}

void material::factory::shutdown()
{
	/*for (const auto& materialData : materials)
	{
		materialData.material->removeRefCount();
	}*/
}
```

`hack/cheats/features/visuals/chams/factory/factory.hpp`:

```hpp
#pragma once

#include <string_view>

class IMaterial;
class ITexture;

enum class CreationType
{
	BY_BUFFER,
	FROM_STRING
};

// extenmd if specific values are needed
enum class MaterialTypes
{
	DEFAULT,
	GLOW
};

struct MaterialData
{
	std::string name{ };
	std::string key{ };
	std::string buffer{ };

	CreationType createType{ CreationType::BY_BUFFER };
	MaterialTypes materialType{ MaterialTypes::DEFAULT };

	IMaterial* material{ };
};

// wrappers for safe material handling
namespace material
{
	namespace factory
	{
		IMaterial* createMaterial(const MaterialData& data);
		IMaterial* findMaterial(char const* name, const char* group, bool complain = true, const char* prefix = nullptr);
		ITexture* findTexture(char const* name, const char* group, bool complain = true, int additionalFlags = 0);
		void shutdown();

		inline std::vector<MaterialData> materials;
	}
}
```

`hack/cheats/features/visuals/glow/glow.cpp`:

```cpp
#include "glow.hpp"

#include "../chams/factory/factory.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <SDK/IVStudioRender.hpp>
#include <SDK/IVModelRender.hpp>
#include <SDK/IViewRender.hpp>
#include <SDK/IVRenderView.hpp>
#include <SDK/IMatRenderContext.hpp>
#include <SDK/ITexture.hpp>
#include <SDK/CGlowManager.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/stencil.hpp>
#include <SDK/PixEvent.hpp>
#include <SDK/Enums.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/KeyValues.hpp>
#include <SDK/materialInit.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <cheats/features/cache/cache.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <render/render.hpp>
#include <cheats/features/visuals/player/boxes.hpp>

#include <cheats/hooks/doPostScreenEffects.hpp>

#include "../streamproof/streamproof.hpp"

// rebuild of: https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/glow_outline_effect.cpp
// 1 - less drawModel calls
// 2 - no occluded and unonccluded confusing shit
// 3 - full bloom removed - useless
// 4 - visible / zbuffer chams
// 5 - actual blurred lines
// 6 - THANK YOU tlxkjc2407 for the glow visibility

namespace
{
	struct GlowHandler : hooks::DoPostScreenEffects
	{
		GlowHandler()
		{
			this->registerInit(glow::initMaterials);
			this->registerRun(glow::run);
		}
	} glowHandler;
}

#define GLOWBOX_PASS_COLOR 0
#define GLOWBOX_PASS_STENCIL 1

namespace glow
{
	struct GlowBoxDefinition_t
	{
		Vec3 m_position;
		Vec3 m_angOrientation;
		Vec3 m_mins;
		Vec3 m_maxs;
		float m_birthTimeIndex;
		float m_terminationTimeIndex; //when to die
		Color m_color;
	};

	void downSampleAndBlurRT(IMatRenderContext* ctx);
	void renderGlowModels(IMatRenderContext* ctx);
	void renderGlowBoxes(int pass, IMatRenderContext* ctx);
	void renderGlowMisc(IMatRenderContext* ctx);
	void beginGlow(IMatRenderContext* ctx);
	void endGlow(IMatRenderContext* ctx);
	void addBackbufferGlow(IMatRenderContext* ctx);
	void addHaloScreen(IMatRenderContext* ctx);
	void applyEntityGlowEffects(IMatRenderContext* ctx);
	void drawModel(Player_t* ent, float alpha);

	ITexture* _rt_FullFrameFB{ };
	ITexture* _rt_FullFrameFB1{ };
	ITexture* _rt_FullScreen{ };
	ITexture* _rt_SmallFB0{ };
	ITexture* _rt_SmallFB1{ };

	IMaterial* glow_color{ };
	IMaterial* glow_rim3d{ };
	IMaterial* glow_downsample{ };
	IMaterial* glow_blur_x{ };
	IMaterial* glow_blur_y{ };
	IMaterial* halo_add_to_screen{ };
	IMaterial* glow_edge_highlight{ };
	IMaterial* __utilVertexColor{ };
	IMaterial* __utilVertexColorIgnoreZ{ };
	IMaterial* debugfbtexture1{ };

	std::array<float, 3> originalColorBegin;
	float originalBlendBegin;

	std::vector<GlowBoxDefinition_t> glowBoxDefinitions{ };

	constexpr int renderFlags{ STUDIO_RENDER | STUDIO_SKIP_FLEXES | STUDIO_DONOTMODIFYSTENCILSTATE | STUDIO_NOLIGHTING_OR_CUBEMAP | STUDIO_SKIP_DECALS };
}

static void setRenderTargetAndViewPort(ITexture* rt, int w, int h)
{
	const auto ctx = memory::interfaces::matSys->getRenderContext();
	ctx->setRenderTarget(rt);
	ctx->viewport(0, 0, w, h);
}

static void renderBox(const Vec3& origin, const Vec3& angles, const Vec3& mins, const Vec3& maxs, const Color& color, bool zBuffer, bool insideOut)
{
	IMaterial* mat = zBuffer ? glow::__utilVertexColor : glow::__utilVertexColorIgnoreZ;

	// added this because alpha didn't seem to change, I missed something
	// tho, this is fairly enough
	mat->alphaModulate(color.a());

	memory::renderBoxInternal()(origin, angles, mins, maxs, SDKColor{ color }, mat, insideOut);
}

static void renderLine(const Vec3& start, const Vec3& end, const Color& color, bool zBuffer)
{
	memory::renderLine()(start, end, SDKColor{ color }, zBuffer);
}

void glow::initMaterials()
{
	_rt_FullFrameFB = material::factory::findTexture("_rt_FullFrameFB", TEXTURE_GROUP_RENDER_TARGET);
	_rt_FullFrameFB1 = material::factory::findTexture("_rt_FullFrameFB1", TEXTURE_GROUP_RENDER_TARGET);
	_rt_FullScreen = material::factory::findTexture("_rt_FullScreen", TEXTURE_GROUP_RENDER_TARGET);
	_rt_SmallFB0 = material::factory::findTexture("_rt_SmallFB0", TEXTURE_GROUP_RENDER_TARGET);
	_rt_SmallFB1 = material::factory::findTexture("_rt_SmallFB1", TEXTURE_GROUP_RENDER_TARGET);

	glow_color = material::factory::findMaterial("dev/glow_color", TEXTURE_GROUP_OTHER);
	MaterialData downSampleFixed
	{
		.name = "downsampleGlow_fixed",
		.key = "Downsample_nohdr",
		.buffer = "$bloomtintenable 1 $bloomtype 1 $basetexture _rt_FullFrameFB $bloomexp 2.5 $bloomsaturation 1.0 $noToolTexture 1",
		.createType = CreationType::FROM_STRING
	};
	glow_downsample = material::factory::createMaterial(downSampleFixed);
	glow_rim3d = material::factory::findMaterial("dev/glow_rim3d", TEXTURE_GROUP_OTHER);
	glow_blur_x = material::factory::findMaterial("dev/glow_blur_x", TEXTURE_GROUP_OTHER);
	glow_blur_y = material::factory::findMaterial("dev/glow_blur_y", TEXTURE_GROUP_OTHER);
	halo_add_to_screen = material::factory::findMaterial("dev/halo_add_to_screen", TEXTURE_GROUP_OTHER);
	glow_edge_highlight = material::factory::findMaterial("dev/glow_edge_highlight", TEXTURE_GROUP_OTHER);
	MaterialData utilVertex
	{
		.name = "__utilVertex",
		.key = "unlitgeneric",
		.buffer = "$vertexcolor 1 vertexalpha 1",
		.createType = CreationType::FROM_STRING
	};
	__utilVertexColor = material::factory::createMaterial(utilVertex);
	MaterialData utilVertexIgnorez
	{
		.name = "__utilVertex",
		.key = "unlitgeneric",
		.buffer = "$vertexcolor 1 vertexalpha 1 $ignorez 1",
		.createType = CreationType::FROM_STRING
	};
	__utilVertexColorIgnoreZ = material::factory::createMaterial(utilVertexIgnorez);
	MaterialData debugmat
	{
		.name = "debugfbtexture1",
		.key = "UnlitGeneric",
		.buffer = "$basetexture _rt_FullFrameFB1 $noToolTexture 1",
		.createType = CreationType::FROM_STRING
	};
	debugfbtexture1 = material::factory::createMaterial(debugmat);

	streamProof.init();

	console::debug("loaded all glow textures / materials");
}

void glow::downSampleAndBlurRT(IMatRenderContext* ctx)
{
	const int srcWidth = globals::screenX;
	const int srcHeight = globals::screenY;

	if ((_rt_SmallFB0->getActualWidth() != (globals::screenX / 4)) || (_rt_SmallFB0->getActualHeight() != (globals::screenY / 4)))
	{
		setRenderTargetAndViewPort(_rt_SmallFB0, _rt_SmallFB0->getActualWidth(), _rt_SmallFB0->getActualHeight());
		ctx->clearColor3ub(0, 0, 0);
		ctx->clearBuffers(true, false);
	}

	setRenderTargetAndViewPort(_rt_SmallFB0, globals::screenX / 4, globals::screenY / 4);

	if (const auto var = glow_downsample->findVar("$bloomexp"))
		var->setValue(vars::visuals->glow->exponent);

	if (const auto var = glow_downsample->findVar("$bloomsaturation"))
		var->setValue(vars::visuals->glow->saturation);

	const int fullFbWidth = srcWidth;
	const int fullFbHeight = srcHeight;

	ctx->drawScreenSpaceRectangle(glow_downsample, 0, 0, srcWidth / 4, srcHeight / 4,
		0, 0, fullFbWidth - 4.0f, fullFbHeight - 4.0f,
		_rt_FullFrameFB->getActualWidth(), _rt_FullFrameFB->getActualHeight());

	static bool first = true;
	if (first || (_rt_SmallFB1->getActualWidth() != (globals::screenX / 4)) || (_rt_SmallFB1->getActualHeight() != (globals::screenY / 4)))
	{
		first = false;
		setRenderTargetAndViewPort(_rt_SmallFB1, _rt_SmallFB1->getActualWidth(), _rt_SmallFB1->getActualHeight());
		ctx->clearColor3ub(0, 0, 0);
		ctx->clearBuffers(true, false);
	}

	setRenderTargetAndViewPort(_rt_SmallFB1, globals::screenX / 4, globals::screenY / 4);

	ctx->drawScreenSpaceRectangle(glow_blur_x, 0, 0, srcWidth / 4, srcHeight / 4,
		0, 0, srcWidth / 4.0f - 1.0f, srcHeight / 4.0f - 1.0f,
		_rt_SmallFB0->getActualWidth(), _rt_SmallFB0->getActualHeight());

	setRenderTargetAndViewPort(_rt_SmallFB0, globals::screenX / 4, globals::screenY / 4);

	if (const auto var = glow_blur_y->findVar("$bloomamount"))
		var->setValue(vars::visuals->glow->thickness);

	ctx->drawScreenSpaceRectangle(glow_blur_y, 0, 0, srcWidth / 4, srcHeight / 4,
		0, 0, srcWidth / 4.0f - 1.0f, srcHeight / 4.0f - 1.0f,
		_rt_SmallFB1->getActualWidth(), _rt_SmallFB1->getActualHeight());
}

void glow::renderGlowModels(IMatRenderContext* ctx)
{
	if (!vars::visuals->glow->enabled)
		return;

	if (!vars::visuals->glow->usedMats.at(E2T(GlowRenderStyle::DEFAULT)))
		return;

	ShaderStencilState_t stencilState;
	stencilState.m_bEnable = true;
	stencilState.m_nReferenceValue = 1;
	stencilState.m_CompareFunc = SHADER_STENCILFUNC_ALWAYS;
	stencilState.m_PassOp = SHADER_STENCILOP_SET_TO_REFERENCE;
	stencilState.m_FailOp = SHADER_STENCILOP_KEEP;
	stencilState.m_ZFailOp = SHADER_STENCILOP_SET_TO_REFERENCE;

	ctx->setStencilState(stencilState);

	ctx->overrideDepthEnable(vars::visuals->glow->visible, false);
	memory::interfaces::renderView->setBlend(vars::visuals->glow->colorPlayer().a());

	for (auto [ent, idx, classid] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		const auto player = ent->cast<Player_t*>();

		if (player->isDormant())
			continue;

		if (!player->isOtherTeam(game::localPlayer()))
			continue;

		memory::interfaces::renderView->modulateColor(vars::visuals->glow->colorPlayer().data());
		drawModel(player, vars::visuals->glow->colorPlayer().a());
	}
}

void glow::renderGlowBoxes(int pass, IMatRenderContext* ctx)
{
	for (size_t i = 0; auto & glowBox : glowBoxDefinitions)
	{
		if (glowBox.m_terminationTimeIndex < memory::interfaces::globalVars->m_curtime)
		{
			glowBoxDefinitions.erase(glowBoxDefinitions.begin() + i);
			continue;
		}

		float lifeLeft = (glowBox.m_terminationTimeIndex - memory::interfaces::globalVars->m_curtime) /
			(glowBox.m_terminationTimeIndex - glowBox.m_birthTimeIndex);
		if (lifeLeft > 0.95f)
			lifeLeft = (0.05f - (lifeLeft - 0.95f)) / 0.05f; // fade in the first 5% of lifetime
		else
			lifeLeft = std::min(lifeLeft * 4.0f, 1.0f); // fade out the last 25% of lifetime

		glowBox.m_color.a() = lifeLeft;

		if (pass == GLOWBOX_PASS_COLOR)
		{
			const Vec3 forward = math::angleVec(glowBox.m_angOrientation);
			const Vec3 lineEnd = glowBox.m_position + (forward * glowBox.m_mins[0]);

			renderLine(glowBox.m_position, lineEnd, glowBox.m_color, false);
		}
		else if (pass == GLOWBOX_PASS_STENCIL)
		{
			ShaderStencilState_t stencilState;
			stencilState.m_bEnable = true;
			stencilState.m_nReferenceValue = 1;
			stencilState.m_CompareFunc = SHADER_STENCILFUNC_ALWAYS;
			stencilState.m_PassOp = SHADER_STENCILOP_KEEP;
			stencilState.m_FailOp = SHADER_STENCILOP_KEEP;
			stencilState.m_ZFailOp = SHADER_STENCILOP_KEEP;

			ctx->setStencilState(stencilState);

			renderBox(glowBox.m_position, glowBox.m_angOrientation, glowBox.m_mins, glowBox.m_maxs, glowBox.m_color, false, false);
		}

		++i;
	}
}

void glow::renderGlowMisc(IMatRenderContext* ctx)
{
	if (!vars::visuals->glow->enabled)
		return;

	if (std::ranges::all_of(vars::visuals->glow->usedMats, [](const bool b) { return !b; }))
		return;

	std::vector<Player_t*> rim3DGlows, edgeHighlightGlows;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		auto ent = reinterpret_cast<Player_t*>(entity);

		if (ent->isDormant())
			continue;

		if (!ent->isOtherTeam(game::localPlayer()))
			continue;

		if (const auto cfg = vars::visuals->glow->usedMats; cfg.at(E2T(GlowRenderStyle::RIMGLOW3D)))
		{
			rim3DGlows.push_back(ent);
		}
		else if (cfg.at(E2T(GlowRenderStyle::EDGE_HIGHLIGHT)) || cfg.at(E2T(GlowRenderStyle::EDGE_HIGHLIGHT_PULSE)))
		{
			edgeHighlightGlows.push_back(ent);
		}
	}

	if (rim3DGlows.size())
	{
		const float pulse = 0.5f + 0.5f * std::sin(memory::interfaces::globalVars->m_curtime * vars::visuals->glow->pulseSpeeeds.at(E2T(GlowRenderPulse::RIM)));

		memory::interfaces::studioRender->forcedMaterialOverride(glow_rim3d);
		glow_rim3d->setMaterialVarFlag(MATERIAL_VAR_IGNOREZ, vars::visuals->glow->ignorez.at(E2T(GlowIgnorez::RIMGLOW3D)));

		for (const auto& ent : rim3DGlows)
		{
			if (vars::visuals->glow->colorPlayer().a() <= 0.0f)
				continue;

			if (const auto var = glow_rim3d->findVar("$envmaptint"))
			{
				var->setVectorComponent(std::clamp(vars::visuals->glow->colorPlayer().a() * vars::visuals->glow->colorPlayer().r(), 0.0f, 1.0f), 0);
				var->setVectorComponent(std::clamp(vars::visuals->glow->colorPlayer().a() * vars::visuals->glow->colorPlayer().g(), 0.0f, 1.0f), 1);
				var->setVectorComponent(std::clamp(vars::visuals->glow->colorPlayer().a() * vars::visuals->glow->colorPlayer().b(), 0.0f, 1.0f), 2);
			}

			if (const auto var = glow_rim3d->findVar("$envmapfresnelminmaxexp"))
			{
				var->setVectorComponent(0.0f, 0);
				var->setVectorComponent(1.5f, 1);
				var->setVectorComponent(3.0f + pulse, 2);
			}

			drawModel(ent, vars::visuals->glow->colorPlayer().a());
		}

		memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
	}

	if (edgeHighlightGlows.size())
	{
		ctx->pushRenderTargetAndViewport();

		auto originalColor = Colors::Blank.getRGB();
		memory::interfaces::renderView->getcolor(originalColor.data());

		setRenderTargetAndViewPort(_rt_FullScreen, globals::screenX, globals::screenY);

		ctx->clearColor3ub(0, 0, 0);
		ctx->clearBuffers(true, true, true);

		memory::interfaces::studioRender->forcedMaterialOverride(glow_color);

		memory::interfaces::renderView->setBlend(1.0f);

		auto overrideColor = Colors::White.getRGB();
		memory::interfaces::renderView->modulateColor(overrideColor.data());

		for (const auto& ent : edgeHighlightGlows)
			drawModel(ent, vars::visuals->glow->colorPlayer().a());

		memory::interfaces::studioRender->forcedMaterialOverride(nullptr);

		ctx->popRenderTargetAndViewport();

		memory::interfaces::studioRender->forcedMaterialOverride(glow_edge_highlight);

		ctx->overrideDepthEnable(true, false);

		glow_edge_highlight->setMaterialVarFlag(MATERIAL_VAR_IGNOREZ,
			vars::visuals->glow->ignorez.at(E2T(GlowIgnorez::EDGE_HIGHLIGHT))
			|| vars::visuals->glow->ignorez.at(E2T(GlowIgnorez::EDGE_HIGHLIGHT_PULSE)));

		for (const auto& ent : edgeHighlightGlows)
		{
			Vec3 vecTempColor = Vec3{ vars::visuals->glow->colorPlayer().getRGB() } *vars::visuals->glow->colorPlayer().a() * 1.4f;

			if (vars::visuals->glow->usedMats.at(E2T(GlowRenderStyle::EDGE_HIGHLIGHT_PULSE)))
			{
				const float pulse = 1.5f + 0.5f * std::sin(memory::interfaces::globalVars->m_curtime * vars::visuals->glow->pulseSpeeeds.at(E2T(GlowRenderPulse::EDGE)));
				vecTempColor *= (pulse * 0.5f);
			}

			memory::interfaces::renderView->modulateColor(vecTempColor.toArray().data());

			drawModel(ent, vars::visuals->glow->colorPlayer().a());
		}

		memory::interfaces::renderView->modulateColor(originalColor.data());
	}
}

void glow::beginGlow(IMatRenderContext* ctx)
{
	ctx->copyRenderTargetToTexture(_rt_FullFrameFB1);
	ctx->clearColor3ub(0, 0, 0);
	ctx->clearBuffers(true, false);

	originalColorBegin = Colors::Blank.getRGB();
	memory::interfaces::renderView->getcolor(originalColorBegin.data());
	originalBlendBegin = memory::interfaces::renderView->getBlend();

	memory::interfaces::studioRender->forcedMaterialOverride(glow_color);
}

void glow::endGlow(IMatRenderContext* ctx)
{
	memory::interfaces::studioRender->forcedMaterialOverride(nullptr);
	memory::interfaces::renderView->modulateColor(originalColorBegin.data());
	memory::interfaces::renderView->setBlend(originalBlendBegin);

	ctx->overrideDepthEnable(false, false);
}

void glow::addBackbufferGlow(IMatRenderContext* ctx)
{
	ctx->copyRenderTargetToTexture(_rt_FullFrameFB);
	ctx->disableStencil();

	const int srcWidth = globals::screenX;
	const int srcHeight = globals::screenY;
	int viewportX, viewportY, viewportW, viewportH;
	ctx->getViewport(viewportX, viewportY, viewportW, viewportH);

	ctx->overrideDepthEnable(true, false);
	ctx->drawScreenSpaceRectangle(debugfbtexture1,
		0, 0, viewportW, viewportH,
		0, 0, srcWidth - 1.0f, srcHeight - 1.0f,
		_rt_FullFrameFB1->getActualWidth(), _rt_FullFrameFB1->getActualHeight());
	ctx->overrideDepthEnable(false, false);
}

void glow::addHaloScreen(IMatRenderContext* ctx)
{
	if (const auto var = halo_add_to_screen->findVar("$C0_X"))
		var->setValue(vars::visuals->glow->C0_X);

	ShaderStencilState_t stencilState;
	stencilState.m_bEnable = true;
	stencilState.m_nWriteMask = 0x1;
	stencilState.m_nReferenceValue = 1;
	stencilState.m_nTestMask = 0x1;
	stencilState.m_CompareFunc = SHADER_STENCILFUNC_NOTEQUAL;
	stencilState.m_PassOp = SHADER_STENCILOP_KEEP;
	stencilState.m_FailOp = SHADER_STENCILOP_KEEP;
	stencilState.m_ZFailOp = SHADER_STENCILOP_KEEP;
	ctx->setStencilState(stencilState);

	const int srcWidth = globals::screenX;
	const int srcHeight = globals::screenY;
	int viewportX, viewportY, viewportW, viewportH;
	ctx->getViewport(viewportX, viewportY, viewportW, viewportH);

	ctx->drawScreenSpaceRectangle(halo_add_to_screen, 0, 0, srcWidth, srcHeight,
		0.0f, -0.5f, srcWidth / 4.0f - 1.0f, srcHeight / 4.0f - 1.0f,
		_rt_SmallFB1->getActualWidth(),
		_rt_SmallFB1->getActualHeight());

	ctx->disableStencil();
}

void glow::applyEntityGlowEffects(IMatRenderContext* ctx)
{
	if (!vars::visuals->glow->enabled && glowBoxDefinitions.empty())
		return;

	renderGlowMisc(ctx);

	ctx->pushRenderTargetAndViewport();

	beginGlow(ctx);
	{
		renderGlowBoxes(GLOWBOX_PASS_STENCIL, ctx);
		renderGlowModels(ctx);
	}
	endGlow(ctx);

	addBackbufferGlow(ctx);

	downSampleAndBlurRT(ctx);

	ctx->popRenderTargetAndViewport();

	addHaloScreen(ctx);
}

void glow::addGlowBox(const Vec3& origin, const Vec3& angOrientation, const Vec3& mins, const Vec3& maxs, const Color& color, float lifetime)
{
#if USE_GLOWBOX_CUSTOM == true
	GlowBoxDefinition_t glowBox
	{
		.m_position = origin,
		.m_angOrientation = angOrientation,
		.m_mins = mins,
		.m_maxs = maxs,
		.m_birthTimeIndex = memory::interfaces::globalVars->m_curtime,
		.m_terminationTimeIndex = memory::interfaces::globalVars->m_curtime + lifetime,
		.m_color = color
	};

	glowBoxDefinitions.push_back(glowBox);
#else
	memory::interfaces::glowManager->addGlowBox(origin, angOrientation, mins, maxs, color, lifetime);
#endif
}

void glow::run()
{
#ifdef USE_GLOW_CUSTOM
	if (!game::isAvailable())
		return;

	auto ctx = memory::interfaces::matSys->getRenderContext();

	applyEntityGlowEffects(ctx);
#else
	// else run it from the interface, careful of register check
#endif
}

void glow::drawModel(Player_t* ent, float alpha)
{
	const uint8_t instanceAlpha = static_cast<uint8_t>(alpha * 255);

	ent->drawModel(renderFlags, instanceAlpha);
	Entity_t* attachment = ent->firstMoveChild();

	while (attachment)
	{
		if (attachment->shouldDraw())
		{
			attachment->drawModel(renderFlags, instanceAlpha);
		}
		attachment = attachment->nextMovePeer();
	}
}
```

`hack/cheats/features/visuals/glow/glow.hpp`:

```hpp
#pragma once

#include <SDK/math/Vector.hpp>
#include <render/Color.hpp>

#include "../streamproof/streamproof.hpp"

#define USE_GLOWBOX_CUSTOM true
// not recommended to use not custom
#define USE_GLOW_CUSTOM true

namespace glow
{
	inline StreamProof streamProof{ "yologlow" };

	void run();
	void initMaterials();
	void addGlowBox(const Vec3& origin, const Vec3& angOrientation, const Vec3& mins, const Vec3& maxs, const Color& color, float lifetime);
}
```

`hack/cheats/features/visuals/hitmarker/hitmark.cpp`:

```cpp
#include "hitmark.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/ISurface.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/clientHitVerify.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <cheats/features/events/events.hpp>

#include <functional>
#include <imgui_internal.h>

#include <cheats/hooks/paintTraverse.hpp>
#include <cheats/hooks/unknownPlayerHurt.hpp>

namespace
{
	struct HitmarkerHandler : hooks::PaintTraverse
	{
		HitmarkerHandler()
		{
			this->registerRender(hitmarker::draw);
		}
	} hitmarkerHandler;

	struct HitmarkerHits : hooks::UnknownPlayerHurt
	{
		HitmarkerHits()
		{
			this->registerRun(hitmarker::handleHits);
		}
	} hitmarkerHits;
}

namespace hitmarker
{
	struct Hitmark_t
	{
		float expireTime;
		int damage;
		int health;
		bool wasHeadshot;
		Player_t* player;
		// dont touch those outside of loop
		Vec3 pos;
		float alpha;
	};

	inline std::vector<Hitmark_t> allHits;
}

void hitmarker::draw()
{
	if (!vars::misc->hitmarker->enabled)
		return;

	if (!game::localPlayer)
		return;

	if (!game::localPlayer->isAlive())
		return;

	float x, y;
	const bool mode3D = vars::misc->hitmarker->enabled3D;
	if (!mode3D)
	{
		x = globals::screenX / 2.0f;
		y = globals::screenY / 2.0f;
	}

	const auto bulletList = game::localPlayer->m_vecBulletVerifyListClient();

	for (size_t i = 0; auto & [expire, damage, health, wasHeadhsot, player, hitPos, alpha] : allHits)
	{
		// cant think of anything else, hitgroups are limited
		if (const auto bulletPos = bulletList[bulletList.m_size - 2].m_pos; bulletPos != hitPos)
			hitPos = bulletPos;

		const float diff = expire - memory::interfaces::globalVars->m_curtime;
		if (diff <= 0.0f)
		{
			allHits.erase(allHits.begin() + i);
			continue;
		}

		if (mode3D)
		{
			if (ImVec2 s; ImRender::worldToScreen(hitPos, s))
			{
				x = s.x;
				y = s.y;
			}
		}

		alpha = diff / vars::misc->hitmarker->time;
		Color actualColor = vars::misc->hitmarker->colorNormal().getColorEditAlpha(alpha);
		float lineX = 10.0f;
		float lineY = 5.0f;

		if (health >= 0 && wasHeadhsot)
		{
			actualColor = vars::misc->hitmarker->colorHead().getColorEditAlpha(alpha);
			lineX = 14.0f;
			lineY = 7.0f;
		}
		else if (health <= 0)
		{
			actualColor = vars::misc->hitmarker->colorDead().getColorEditAlpha(alpha);
			lineX = 18.0f;
			lineY = 9.0f;
		}

		float lineAddonX = lineX;
		float lineAddonY = lineY;
		if (vars::misc->hitmarker->enabledResize)
		{
			lineAddonX = lineX * alpha;
			lineAddonY = lineY * alpha;
		}

		ImRender::drawLine(x - lineAddonX, y + lineAddonX, x - lineAddonY, y + lineAddonY, actualColor);
		ImRender::drawLine(x + lineAddonX, y + lineAddonX, x + lineAddonY, y + lineAddonY, actualColor);
		ImRender::drawLine(x - lineAddonX, y - lineAddonX, x - lineAddonY, y - lineAddonY, actualColor);
		ImRender::drawLine(x + lineAddonX, y - lineAddonX, x + lineAddonY, y - lineAddonY, actualColor);
		
		Box box{ player };
		if (!box.isValid())
			continue;

		const auto headPos = player->getHitboxPos(HITBOX_HEAD);

		const auto text = std::format("{}", damage);
		const float fontSize = game::getScaledFont(game::localPlayer->getEyePos(), headPos, 150.0f, 12.0f, 30.0f) * std::max(0.7f, alpha);
		const auto textSize = ImRender::getTextSize(ImRender::fonts::franklinGothic30, fontSize, text);

		ImVec2 coord{ (box.x + box.w / 2) - textSize.x / 2, box.y };
		coord.y -= (i + 1) * fontSize; // some scaling with alpha would be nice
		ImRender::text(coord.x, coord.y, fontSize, ImRender::fonts::franklinGothic30, text, true, actualColor, false);

		i++;
	}
}

void hitmarker::handleHits(IGameEvent* event)
{
	if (!vars::misc->hitmarker->enabled)
		return;

	const auto attacker = memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt("attacker")));
	if (!attacker)
		return;

	// very important
	if (attacker != game::localPlayer)
		return;

	const auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt("userid"))));
	if (!ent) // should never happen
		return;

	const auto dmg_health = event->getInt("dmg_health");
	const auto health = ent->m_iHealth() - dmg_health;
	const auto hitgroup = event->getInt("hitgroup");

	Hitmark_t hit // rest fields are controlled in loop
	{
		.expireTime = memory::interfaces::globalVars->m_curtime + vars::misc->hitmarker->time,
		.damage = dmg_health,
		.health = ent->m_iHealth() - dmg_health,
		.wasHeadshot = hitgroup == HITGROUP_HEAD,
		.player = ent
	};

	allHits.push_back(hit);

	if (vars::misc->hitmarker->play)
		memory::interfaces::surface->playSound("buttons\\arena_switch_press_02.wav");
}
```

`hack/cheats/features/visuals/hitmarker/hitmark.hpp`:

```hpp
#pragma once

class IGameEvent;

namespace hitmarker
{
	void handleHits(IGameEvent* event);
	void draw();
}
```

`hack/cheats/features/visuals/list/playerlist.cpp`:

```cpp
#include "playerlist.hpp"

#include <cheats/features/cache/cache.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/Enums.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/CCSGO_HudRadar.hpp>
#include <cheats/features/blacklist/blacklist.hpp>
#include <render/Color.hpp>

#include <imgui.h>
#include <magic_enum.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

#include <ranges>
#include <iostream>

#include <cheats/hooks/present.hpp>

namespace
{
	struct PlayerListhandler : hooks::Present
	{
		PlayerListhandler()
		{
			this->registerRun(playerList::draw);
		}
	} playerlistHandler;
}

struct TableStruct
{
	std::string_view name;
	int flags;
	bool* cfg = nullptr; // some are default always
};

void playerList::draw()
{
	if (!vars::misc->playerList->enabled)
		return;

	if (!game::isAvailable())
		return;

	// ImGui demo: Tables/Borders
	if (ImGui::Begin("PlayerList", &vars::misc->playerList->enabled, ImGuiWindowFlags_NoCollapse))
	{
		static std::array tableNames
		{
			TableStruct{ "Name", ImGuiTableColumnFlags_NoHide },
			TableStruct{ "Health", ImGuiTableColumnFlags_WidthFixed, &vars::misc->playerList->health },
			TableStruct{ "Money", ImGuiTableColumnFlags_WidthFixed, &vars::misc->playerList->money },
			TableStruct{ "Team", ImGuiTableColumnFlags_WidthFixed, &vars::misc->playerList->teamID },
			TableStruct{ "Place", ImGuiTableColumnFlags_WidthFixed, &vars::misc->playerList->lastPlace },
			TableStruct{ "Blacklist", ImGuiTableColumnFlags_WidthFixed | ImGuiTableColumnFlags_NoResize }
		};

		if (ImGui::BeginTable("", tableNames.size(),
			ImGuiTableFlags_Borders | ImGuiTableFlags_Hideable | ImGuiTableFlags_Resizable /*| ImGuiTableFlags_Sortable*/))
		{
			for (size_t i = 0; const auto [name, flags, cfg] : tableNames)
			{
				ImGui::TableSetupColumn(name.data(), flags);
				if (cfg)
					ImGui::TableSetColumnEnabled(i, *cfg);

				i++;
			}
			ImGui::TableHeadersRow();

			auto players = EntityCache::getCache(EntCacheType::PLAYER);
			std::ranges::sort(players,
				[](const EntityCache::HolderData& lhs, const EntityCache::HolderData& rhs)
				{
					auto lhsEnt = reinterpret_cast<Player_t*>(lhs.ent);
					auto rhsEnt = reinterpret_cast<Player_t*>(rhs.ent);
					bool lhsIsOtherTeam = lhsEnt->isOtherTeam(game::localPlayer());
					bool rhsIsOtherTeam = rhsEnt->isOtherTeam(game::localPlayer());

					if (lhsIsOtherTeam ^ rhsIsOtherTeam)
						return lhsIsOtherTeam;

					return false;
				}
			);

			for (size_t i = 0; auto [entity, idx, classID] : players)
			{
				auto ent = reinterpret_cast<Player_t*>(entity);

				if (ent == game::localPlayer)
					continue;

				// check once again, will be faster than extra vector
				bool isEnemy = ent->isOtherTeam(game::localPlayer());

				// allow buttons to be executed for ONLY selected player
				ImGui::PushID(i);

				ImGui::TableNextRow();

				if (ImGui::TableNextColumn())
				{
					ImVec4 color = isEnemy ? ImVec4{ 1.0f, 0.0f, 0.0f, 1.0f } : ImVec4{ 0.0f, 1.0f, 0.0f, 1.0f };
					ImGui::PushStyleColor(ImGuiCol_Text, color);
					ImGui::TextUnformatted(ent->getName().c_str());
					ImGui::PopStyleColor();
				}

				if (ImGui::TableNextColumn())
				{
					const auto health = ent->isDormant()
						? EntityCache::CacheFields::getCachedFields().at(idx).m_health
						: ent->m_iHealth();
					ImVec4 color;
					std::memcpy(&color, Color::healthBased(health).data(), 4 * sizeof(float));

					ImGui::PushStyleColor(ImGuiCol_Text, color);
					std::string text = health == 0 ? "DEAD" : std::format("{}", health);
					ImGui::TextUnformatted(text.c_str());
					ImGui::PopStyleColor();

					if (health)
					{
						ImGui::SameLine();
						ImGui::TextUnformatted("HP");
					}
				}

				if (ImGui::TableNextColumn())
				{
					ImGui::TextUnformatted(std::format("{}$", ent->m_iAccount()).c_str());
				}

				if (ImGui::TableNextColumn())
				{
					ImGui::TextUnformatted(std::format("{} ({})", ent->m_iTeamNum(),
						magic_enum::enum_names<TeamID>().at(ent->m_iTeamNum())).c_str());
				}

				if (ImGui::TableNextColumn())
				{
					ImGui::TextUnformatted(ent->m_szLastPlaceName());
				}

				if (ImGui::TableNextColumn())
				{
					enum class BlacklistAction { ADD, REMOVE };

					const auto blacklist = !blacklist::isBlacklisted(ent)
						? std::make_pair(std::format("Add##{}", idx), BlacklistAction::ADD)
						: std::make_pair(std::format("Delete##{}", idx), BlacklistAction::REMOVE);

					const auto [title, isOn] = blacklist;

					if (ImGui::Button(title.c_str(), ImVec2{ -std::numeric_limits<float>::min(), 0.0f }))
					{	
						isOn == BlacklistAction::ADD
							? blacklist::add(ent)
							: blacklist::remove(ent);
					}
				}

				ImGui::PopID();

				i++;
			}

			ImGui::EndTable();
		}

		ImGui::End();
	}
}

```

`hack/cheats/features/visuals/list/playerlist.hpp`:

```hpp
#pragma once

namespace playerList
{
	void draw();
}
```

`hack/cheats/features/visuals/list/spectactors.cpp`:

```cpp
#include "spectactors.hpp"

#include <cheats/features/cache/cache.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>

#include <SDK/structs/Entity.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include <array>

#include <cheats/hooks/present.hpp>
#include <cheats/hooks/unkownRoundEnd.hpp>

namespace
{
	struct SpectactorHandler : hooks::Present
	{
		SpectactorHandler()
		{
			this->registerRun(spectactor::draw);
		}
	} specHandler;

	struct SpectactorReset : hooks::UnknownRoundEnd
	{
		SpectactorReset()
		{
			this->registerRun(spectactor::reset);
		}
	} specReset;
}

namespace spectactor
{
	std::unordered_map<ObserverTypes, std::string_view> modeToString
	{
		{ OBS_MODE_NONE, "None" },
		{ OBS_MODE_DEATHCAM, "Deathcam" },
		{ OBS_MODE_FREEZECAM, "Freezecam" },
		{ OBS_MODE_FIXED, "Fixed" },
		{ OBS_MODE_IN_EYE, "In-eye" },
		{ OBS_MODE_CHASE, "Chase" },
		{ OBS_MODE_POI, "Poi" },
		{ OBS_MODE_ROAMING, "Roaming" }
	};

	std::vector<std::pair<std::string, ObserverTypes>> allSpecs;
}

void spectactor::reset()
{
	allSpecs.clear();
}

void spectactor::draw()
{
	if (!vars::misc->spectactorList->enabled)
		return;

	if (!game::isAvailable())
		return;

	allSpecs.clear();

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		auto ent = reinterpret_cast<Player_t*>(entity);

		auto observer = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientFromHandle(ent->m_hObserverTarget()));
		if (!observer)
			continue;

		if (observer == game::localPlayer)
			continue;

		if(const auto type = observer->m_iObserverMode() != ObserverTypes::OBS_MODE_NONE)
			allSpecs.emplace_back(observer->getName(), observer->m_iObserverMode());
	}

	if (allSpecs.empty())
		return;

	if (ImGui::Begin("Spectactors", &vars::misc->spectactorList->enabled, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDecoration))
	{	
		for (size_t i = 0; auto [name, mode] : allSpecs)
		{
			ImGui::TextUnformatted(std::format("{} | {}", name, modeToString.at(mode)).c_str());
			if (i != allSpecs.size())
				ImGui::Separator();

			i++;
		}

		ImGui::End();
	}
}
```

`hack/cheats/features/visuals/list/spectactors.hpp`:

```hpp
#pragma once

namespace spectactor
{
	void draw();
	void reset();
}
```

`hack/cheats/features/visuals/mirrorcam/mirrorCam.cpp`:

```cpp
#include "mirrorCam.hpp"

#include <d3d9.h>

#include <imgui.h>

#include <SDK/interfaces/interfaces.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/ITexture.hpp>
#include <SDK/IMatRenderContext.hpp>
#include <SDK/CViewSetup.hpp>
#include <SDK/IVRenderView.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/materialInit.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/inputSystem.hpp>
#include <utilities/console/console.hpp>
#include <cheats/hooks/hooks.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>

#include <cheats/hooks/wndproc.hpp>
#include <cheats/hooks/present.hpp>
#include <cheats/hooks/viewRender.hpp>

namespace
{
	struct MirrorDraw : hooks::Present
	{
		MirrorDraw()
		{
			this->registerRun(mirrorcam::draw);
		}
	} mirrorDraw;

	struct MirrrorKeys : hooks::wndProcSys
	{
		MirrrorKeys()
		{
			this->registerRun(mirrorcam::updateKeys);
		}
	} mirrorKeys;

	struct MirrorView : hooks::ViewRender
	{
		MirrorView()
		{
			this->registerInit(mirrorcam::initTexture);
			this->registerRun(mirrorcam::run);
		}
	} mirrorView;
}

namespace mirrorcam
{
	Vec2 size{ 1.0f, 1.0f };
	ITexture* texture;
}

void mirrorcam::initTexture()
{
	memory::interfaces::matSys->beginRenderTargetAllocationEx();
	texture = memory::interfaces::matSys->createFullFrameRenderTarget("mirrorCam");
	memory::interfaces::matSys->endRenderTargetAllocationEx();
}

void mirrorcam::updateKeys()
{
	vars::keys->mirrorCam.update();
}

void mirrorcam::run(const CViewSetup& view)
{
	// this might eat some FPS, if enabled
	if (!vars::misc->mirrorCam->enabled)
		return;

	CViewSetup v = view;

	v.m_angles[Coord::Y] = v.m_angles[Coord::Y] + 180.0f; // back
	v.x = v.xOld = 0;
	v.y = v.yOld = 0;
	v.m_width = v.m_widthOld = static_cast<int>(size[Coord::X]);
	v.m_height = v.m_heightOld = static_cast<int>(size[Coord::Y]);
	v.m_aspectRatio = static_cast<float>(v.m_width / v.m_height);
	v.m_nearZ = v.m_nearViewModelZ = 7.0f;
	v.m_fov = 50.0f;

	auto ctx = memory::interfaces::matSys->getRenderContext();
	ctx->pushRenderTargetAndViewport();
	ctx->setRenderTarget(texture);

	hooks::ViewRender::getOriginal()(memory::interfaces::viewRender(), v, v, VIEW_CLEAR_COLOR | VIEW_CLEAR_DEPTH | VIEW_CLEAR_STENCIL, 0);

	ctx->popRenderTargetAndViewport();
	ctx->release();
}

auto getTexture()
{
	return mirrorcam::texture->m_handle[0]->m_texture;
}

void mirrorcam::draw()
{
	if (!game::isAvailable())
		return;

	if (!vars::misc->mirrorCam->enabled)
		return;

	if (vars::misc->mirrorCam->onKey)
	{
		if (!vars::keys->mirrorCam.isEnabled())
			return;
	}

	if (ImGui::Begin("Camera", nullptr, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse))
	{
		// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/tier2/renderutils.cpp#L988
		// ^ is proper scaling what game does

		if (auto size = ImGui::GetContentRegionAvail(); size.x != 0.0f && size.y != 0.0f) // / 0
		{
			float xRatio = static_cast<float>(texture->getActualWidth()) / size.x;
			float yRatio = static_cast<float>(texture->getActualHeight()) / size.y;

			mirrorcam::size = Vec2{ size.x * xRatio, size.y * yRatio };
			ImGui::Image(getTexture(), size);
		}

		ImGui::End();
	}
}

```

`hack/cheats/features/visuals/mirrorcam/mirrorCam.hpp`:

```hpp
#pragma once

class CViewSetup;

namespace mirrorcam
{
	void run(const CViewSetup& view);
	void updateKeys();
	void initTexture();
	void draw();
}
```

`hack/cheats/features/visuals/misc/bulletUpdater.cpp`:

```cpp
#include "bulletUpdater.hpp"

#include <SDK/Enums.hpp>
#include <SDK/clientHitVerify.hpp>
#include <SDK/CUtlVector.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>

#include <cheats/hooks/frameStageNotify.hpp>

namespace
{
	struct BulletHandler : hooks::FrameStageNotify
	{
		BulletHandler()
		{
			this->registerRun(bulletUpdater::run);
		}
	} bulletHandler;
}

namespace bulletUpdater
{
	std::vector<Vec3> lastBullets;
}

void bulletUpdater::run(FrameStage stage)
{
	if (stage != FRAME_START)
		return;

	if (!game::isAvailable())
		return;

	const auto bulletsList = game::localPlayer->m_vecBulletVerifyListClient();
	static int gameBulletCount = bulletsList.m_size; // init current count
	if (gameBulletCount == bulletsList.m_size)
	{
		lastBullets.clear();
		return;
	}

	for (int i = bulletsList.m_size; i > gameBulletCount; i--)
		lastBullets.emplace_back(bulletsList[i - 1].m_pos);
	
	if (bulletsList.m_size != gameBulletCount)
		gameBulletCount = bulletsList.m_size;
}

std::vector<Vec3> bulletUpdater::getLastBullets()
{
	return lastBullets;
}
```

`hack/cheats/features/visuals/misc/bulletUpdater.hpp`:

```hpp
#pragma once

#include <SDK/math/Vector.hpp>

#include <vector>

enum FrameStage;

namespace bulletUpdater
{
	// 2 hit
	// 1 no hit
	[[nodiscard]] std::vector<Vec3> getLastBullets();

	void run(FrameStage stage);
}
```

`hack/cheats/features/visuals/misc/crosshair.cpp`:

```cpp
#include "crosshair.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/math/math.hpp>
#include <render/render.hpp>

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct CrosshairHandler : hooks::PaintTraverse
	{
		CrosshairHandler()
		{
			this->registerInit(crosshair::init);
			this->registerRender(crosshair::draw);
			this->registerShutdown(crosshair::shutdown);
		}
	} crosshairHandler;
}

namespace crosshair
{
	IConVar* m_crosshair;
	IConVar* weapon_recoil_scale;
	IConVar* cl_crosshair_recoil;
}

void crosshair::init()
{
	m_crosshair = memory::interfaces::cvar->findVar("crosshair");
	cl_crosshair_recoil = memory::interfaces::cvar->findVar("cl_crosshair_recoil");
	weapon_recoil_scale = memory::interfaces::cvar->findVar("weapon_recoil_scale");
}

void crosshair::draw()
{
	int cfgCross = vars::misc->crosshair->index;
	if(!m_crosshair->getInt())
		m_crosshair->setValue(true);

	if (cl_crosshair_recoil->getInt())
		cl_crosshair_recoil->setValue(false);

	if (!cfgCross)
		return;

	cl_crosshair_recoil->setValue(cfgCross == E2T(CrossHairTypes::ENGINE) ? true : false);
	if (cl_crosshair_recoil->getInt())
		m_crosshair->setValue(true);
	else
		m_crosshair->setValue(false);

	if (!game::localPlayer)
		return;

	if (!memory::interfaces::engine->isConnected())
		return;

	if (!game::localPlayer->isAlive())
		return;

	float x = globals::screenX / 2.0f;
	float y = globals::screenY / 2.0f;

	const auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	auto getPunchPos = [=]()
	{
		Vec3 angle;
		memory::interfaces::engine->getViewAngles(angle);
		angle += game::localPlayer->m_aimPunchAngle() * weapon_recoil_scale->getFloat();

		auto start = game::localPlayer->getEyePos();
		auto end = start + math::angleVec(angle) * weapon->getWpnInfo()->m_range;

		return end;
	};

	switch (cfgCross)
	{
	case E2T(CrossHairTypes::STATIC):
	{
		float moveCross = 8.0f;

		ImRender::drawLine(x - moveCross, y, x + moveCross, y, Colors::Black, 3.0f);
		ImRender::drawLine(x, y - moveCross, x, y + moveCross, Colors::Black, 3.0f);

		moveCross -= 1.5f;

		ImRender::drawLine(x - moveCross, y, x + moveCross, y, Colors::LightBlue, 1.0f);
		ImRender::drawLine(x, y - moveCross, x, y + moveCross, Colors::LightBlue, 1.0f);
		break;
	}
	case E2T(CrossHairTypes::RECOIL):
	{
		if (ImVec2 endScreen; ImRender::worldToScreen(getPunchPos(), endScreen))
		{
			float x = endScreen.x;
			float y = endScreen.y;

			float moveCross = 8.0f;

			ImRender::drawLine(x - moveCross, y, x + moveCross, y, Colors::Black, 3.0f);
			ImRender::drawLine(x, y - moveCross, x, y + moveCross, Colors::Black, 3.0f);

			moveCross -= 1.5f;

			ImRender::drawLine(x - moveCross, y, x + moveCross, y, Colors::LightBlue, 1.0f);
			ImRender::drawLine(x, y - moveCross, x, y + moveCross, Colors::LightBlue, 1.0f);
		}
		break;
	}
	case E2T(CrossHairTypes::SPREAD):
	{
		if (ImVec2 endScreen; ImRender::worldToScreen(getPunchPos(), endScreen))
		{
			// this is game's logic how to do it
			/*float spread = weapon->getSpread();
			float inaccuracy = weapon->getInaccuracy();
			float scaledSpread = ((inaccuracy + spread) * 320.0f / std::tan(DEG2RAD(globals::FOV) / 2.0f));
			int radiusSpread = scaledSpread * y / 480.0f;

			if (game::localPlayer->m_vecVelocity().length2D() > 0.0f)
				radiusSpread = inaccuracy * 1000.0f;*/
			float inaccuracy = weapon->getInaccuracy();
			float radiusSpread = inaccuracy * 1000.0f;
			float x = endScreen.x;
			float y = endScreen.y;

			ImRender::drawCircle(x, y, radiusSpread, 32, Colors::Black);
			ImRender::drawCircleFilled(x, y, radiusSpread, 32, Colors::LightBlue.getColorEditAlpha(0.2f));
		}
		break;
	}
	default:
		break;
	}
}

void crosshair::shutdown()
{
	m_crosshair->setValue(true);
	cl_crosshair_recoil->setValue(false);
}

```

`hack/cheats/features/visuals/misc/crosshair.hpp`:

```hpp
#pragma once

namespace crosshair
{
	void init();
	void draw();
	void shutdown();
};
```

`hack/cheats/features/visuals/misc/drawInfo.hpp`:

```hpp
#pragma once

class IGameEvent;

namespace miscInfo
{
	void addHits(IGameEvent* event);
	void init();
	void draw();
	void reset();

	inline uint32_t allHits;
}
```

`hack/cheats/features/visuals/misc/drawinfo.cpp`:

```cpp
#include "drawinfo.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/render.hpp>
#include <cheats/features/events/events.hpp>

#include <cheats/hooks/levelInitPreEntity.hpp>
#include <cheats/helper/initable.hpp>
#include <cheats/hooks/present.hpp>
#include <cheats/hooks/unknownPlayerHurt.hpp>

namespace
{
	struct MiscInfoHandler : hooks::LevelInitPreEntity
	{
		MiscInfoHandler()
		{
			this->registerReset(miscInfo::reset);
		}
	} miscInfoHandler;

	struct MiscInit : InitAble
	{
		MiscInit()
		{
			this->registerInit(miscInfo::init);
		}
	} miscInit;

	struct MiscDrawer : hooks::Present
	{
		MiscDrawer()
		{
			this->registerRun(miscInfo::draw);
		}
	} miscDrawer;

	struct MiscHits : hooks::UnknownPlayerHurt
	{
		MiscHits()
		{
			this->registerRun(miscInfo::addHits);
		}
	} miscHits;
}

void miscInfo::init()
{
	if(game::isAvailable())
		allHits = game::localPlayer->m_totalHitsOnServer(); // those gets clamped at 255 :(

	console::debug("misc init");
}

void miscInfo::addHits(IGameEvent* event)
{
	auto attacker = memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt("attacker")));
	if (!attacker)
		return;

	// very important
	if (attacker != game::localPlayer)
		return;

	auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt("userid"))));
	if (!ent) // should never happen
		return;

	++allHits;
}

void miscInfo::reset()
{
	allHits = 0;
}

void miscInfo::draw()
{
	if (!vars::misc->info->enabled)
		return;

	if (!game::isAvailable())
		return;

	const auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	auto text = [](const std::string& text, const Color& color)
	{
		ImGui::PushStyleColor(ImGuiCol_Text, ImVec4{ color.r(), color.g(), color.b(), color.a() });
		ImGui::TextUnformatted(text.c_str()); // because textcolored is formatted by va args
		ImGui::PopStyleColor();
	};

	// bulletlist - m_allHits is done because bulletlist contain hits too

	if (ImGui::Begin("##info", nullptr, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoTitleBar
		| ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoScrollbar))
	{
		text(std::format("Map: {}", memory::interfaces::engine->getLevelName()), Colors::Green);
		text(std::format("Weapon {}", weapon->getWpnInfo()->m_WeaponName), Colors::Yellow);
		text(std::format("[{} / {}] DMG [{}HP]", weapon->m_iClip1(), weapon->m_iPrimaryReserveAmmoCount(), weapon->getWpnInfo()->m_damage), Colors::Yellow);
		text(std::format("Current In-accuracy {:.2f}%", weapon->getInaccuracy() * 100.0f), Colors::Yellow);
		text(std::format("Zoom level {}", weapon->m_zoomLevel()), Colors::Yellow);
		text(std::format("POS: X {:.2f} Y {:.2f} Z {:.2f}", game::localPlayer->absOrigin()[Coord::X], game::localPlayer->absOrigin()[Coord::Y], game::localPlayer->absOrigin()[Coord::Z]), Colors::Yellow);
		text(std::format("Velocity {:.2f}", game::localPlayer->m_vecVelocity().toVecPrev().length()), Colors::Yellow);
		text(std::format("Kills {}", game::localPlayer->getKills()), Colors::Yellow);
		text(std::format("Deaths {}", game::localPlayer->getDeaths()), Colors::Yellow);
		// escape divide by zero exceptions by using this trick
		float kd = game::localPlayer->getKills() / (game::localPlayer->getDeaths() ? game::localPlayer->getDeaths() : 1.0f);
		float kpm = game::localPlayer->getKills() / (game::serverTime() / 60.0f);
		text(std::format("KD {:.2f} KPM: {:.2f}", kd, kpm), Colors::Yellow);
		text(std::format("Ping {}", game::localPlayer->getPing()), Colors::Yellow);
		float accuracy = game::localPlayer->m_vecBulletVerifyListClient().m_size
			? (static_cast<float>(allHits) / static_cast<float>(game::localPlayer->m_vecBulletVerifyListClient().m_size - allHits)) * 100.0f
			: 0.0f;
		float fixedKills = game::localPlayer->getKills() ? game::localPlayer->getKills() : 1.0f;
		float hs = game::localPlayer->m_iNumRoundKillsHeadshots()
			? (static_cast<float>(game::localPlayer->m_iNumRoundKillsHeadshots()) / fixedKills) * 100.0f
			: 0.0f;
		text(std::format("Accuracy [{} / {}] {:.2f}% HS {:.2f}%",
			allHits, game::localPlayer->m_vecBulletVerifyListClient().m_size - allHits, accuracy, hs), Colors::Yellow);

		ImGui::End();
	}
}
```

`hack/cheats/features/visuals/misc/motionblur.cpp`:

```cpp
#include "motionblur.hpp"

#include <SDK/CViewSetup.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/IMatRenderContext.hpp>
#include <SDK/ITexture.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/materialInit.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/console/console.hpp>
#include <gamememory/memory.hpp>

#include <cheats/hooks/overrideView.hpp>

namespace
{
	struct MotionHandler : hooks::OverrideView
	{
		MotionHandler()
		{
			this->registerRun(motionBlur::run);
		}
	} motionHandler;
}

namespace motionBlur
{
	struct MotionBlurHistory_t
	{
		float lastTimeUpdate{ };
		float previousPitch{ };
		float previousYaw{ };
		Vec3 previousPositon{ };
		float noRotationalMotionBlurUntil{ };
	} motionHistory;

	IMaterial* motion_blur;
	ITexture* _rt_FullFrameFB;

	std::array motionBlurValues{ 0.0f, 0.0f, 0.0f, 0.0f };
	std::array motionBlurViewportValues{ 0.0f, 0.0f, 0.0f, 0.0f };
}

void motionBlur::initMaterials()
{
	motion_blur = memory::interfaces::matSys->findMaterial("dev/motion_blur", TEXTURE_GROUP_RENDER_TARGET, false);
	_rt_FullFrameFB = memory::interfaces::matSys->findTexture("_rt_FullFrameFB", TEXTURE_GROUP_RENDER_TARGET);
}

// 1:1 from https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/viewpostprocess.cpp#L2996
// with small reduce of code because we dont care for portal/ps3 stuff and also we dont care for detecting blur, but knowing it's enabled
void motionBlur::run(CViewSetup* view)
{
	if (!vars::misc->motionBlur->enabled)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	constexpr auto resetArr = [](std::array<float, 4>& arr, size_t indexesToReset)
	{
		for (size_t i = 0; auto & el : arr)
		{
			if (i == indexesToReset)
				break;

			el = 0.0f;

			i++;
		}
	};

	if (view)
	{
		float timeElapsed = memory::interfaces::globalVars->m_realtime - motionHistory.lastTimeUpdate;

		float currentPitch = view->m_angles[Coord::X];
		while (currentPitch > 180.0f)
			currentPitch -= 360.0f;
		while (currentPitch < -180.0f)
			currentPitch += 360.0f;

		float currentYaw = view->m_angles[Coord::Y];
		while (currentYaw > 180.0f)
			currentYaw -= 360.0f;
		while (currentYaw < -180.0f)
			currentYaw += 360.0f;

		auto [currentForwardVec, currentSideVec, uselessVec ] = math::angleVectors(view->m_angles);

		Vec3 currentPosition = view->m_origin;
		Vec3 positionChange = motionHistory.previousPositon - currentPosition;

		if ((positionChange.length() > 30.0f) && (timeElapsed >= 0.5f))
		{
			resetArr(motionBlurValues, motionBlurValues.size());
		}
		else if (timeElapsed > (1.0f / 15.0f))
		{
			resetArr(motionBlurValues, motionBlurValues.size());
		}
		else if (positionChange.length() > 50.0f)
		{
			motionHistory.noRotationalMotionBlurUntil = memory::interfaces::globalVars->m_realtime + 1.0f;
		}
		else
		{
			const float horizontalFov = view->m_fov;
			const float verticalFov = (view->m_aspectRatio <= 0.0f) ? (view->m_fov) : (view->m_fov / view->m_aspectRatio);
			const float viewDotMotion = currentForwardVec.dot(positionChange);

			if (vars::misc->motionBlur->forward)
				motionBlurValues[2] = viewDotMotion;
			else
				motionBlurValues[2] = viewDotMotion * std::abs(currentForwardVec[2]);

			const float sideDotMotion = currentSideVec.dot(positionChange);
			float yawDiffOriginal = motionHistory.previousYaw - currentYaw;
			if (((motionHistory.previousYaw - currentYaw > 180.0f) || (motionHistory.previousYaw - currentYaw < -180.0f)) &&
				((motionHistory.previousYaw + currentYaw > -180.0f) && (motionHistory.previousYaw + currentYaw < 180.0f)))
				yawDiffOriginal = motionHistory.previousYaw + currentYaw;

			float yawDiffAdjusted = yawDiffOriginal + (sideDotMotion / 3.0f);

			if (yawDiffOriginal < 0.0f)
				yawDiffAdjusted = std::clamp(yawDiffAdjusted, yawDiffOriginal, 0.0f);
			else
				yawDiffAdjusted = std::clamp(yawDiffAdjusted, 0.0f, yawDiffOriginal);

			const float undampenedYaw = yawDiffAdjusted / horizontalFov;
			motionBlurValues[0] = undampenedYaw * (1.0f - (std::abs(currentPitch) / 90.0f));

			const float pitchCompensateMask = 1.0f - ((1.0f - std::abs(currentForwardVec[2])) * (1.0f - std::abs(currentForwardVec[2])));
			const float pitchDiffOriginal = motionHistory.previousPitch - currentPitch;
			float pitchdiffAdjusted = pitchDiffOriginal;

			if (currentPitch > 0.0f)
				pitchdiffAdjusted = pitchDiffOriginal - ((viewDotMotion / 2.0f) * pitchCompensateMask);
			else
				pitchdiffAdjusted = pitchDiffOriginal + ((viewDotMotion / 2.0f) * pitchCompensateMask);

			if (pitchDiffOriginal < 0.0f)
				pitchdiffAdjusted = std::clamp(pitchdiffAdjusted, pitchDiffOriginal, 0.0f);
			else
				pitchdiffAdjusted = std::clamp(pitchdiffAdjusted, 0.0f, pitchDiffOriginal);

			motionBlurValues[1] = pitchdiffAdjusted / verticalFov;
			motionBlurValues[3] = undampenedYaw;
			motionBlurValues[3] *= (std::abs(currentPitch) / 90.0f) * (std::abs(currentPitch) / 90.0f) * (std::abs(currentPitch) / 90.0f);

			if (timeElapsed > 0.0f)
				motionBlurValues[2] /= timeElapsed * 30.0f;
			else
				motionBlurValues[2] = 0.0f;

			motionBlurValues[2] = std::clamp((std::abs(motionBlurValues[2]) - vars::misc->motionBlur->fallingMin) / (vars::misc->motionBlur->fallingMax - vars::misc->motionBlur->fallingMin),
				0.0f, 1.0f) * (motionBlurValues[2] >= 0.0f ? 1.0f : -1.0f);
			motionBlurValues[2] /= 30.0f;
			motionBlurValues[0] *= vars::misc->motionBlur->rotationIntensity * vars::misc->motionBlur->strength;
			motionBlurValues[1] *= vars::misc->motionBlur->rotationIntensity * vars::misc->motionBlur->strength;
			motionBlurValues[2] *= vars::misc->motionBlur->fallingIntensity * vars::misc->motionBlur->strength;
			motionBlurValues[3] *= vars::misc->motionBlur->rollIntensity * vars::misc->motionBlur->strength;

			float slowFps = 30.0f;
			float fastFps = 50.0f;
			float currentFps = (timeElapsed > 0.0f) ? (1.0f / timeElapsed) : 0.0f;
			float dumpenFactor = std::clamp(((currentFps - slowFps) / (fastFps - slowFps)), 0.0f, 1.0f);

			motionBlurValues[0] *= dumpenFactor;
			motionBlurValues[1] *= dumpenFactor;
			motionBlurValues[2] *= dumpenFactor;
			motionBlurValues[3] *= dumpenFactor;
		}

		if (memory::interfaces::globalVars->m_realtime < motionHistory.noRotationalMotionBlurUntil)
		{
			resetArr(motionBlurValues, 3);
		}
		else
		{
			motionHistory.noRotationalMotionBlurUntil = 0.0f;
		}

		motionHistory.previousPositon = currentPosition;
		motionHistory.previousPitch = currentPitch;
		motionHistory.previousYaw = currentYaw;
		motionHistory.lastTimeUpdate = memory::interfaces::globalVars->m_realtime;

		int x = view->x;
		int y = view->y;
		int w = view->m_width;
		int h = view->m_height;

		float srcWidth = static_cast<float>(_rt_FullFrameFB->getActualWidth());
		float srcHeight = static_cast<float>(_rt_FullFrameFB->getActualHeight());
		int offset;
		offset = (x > 0) ? 1 : 0;
		motionBlurViewportValues[0] = static_cast<float>(x + offset) / (srcWidth - 1);

		offset = (x < (srcWidth - 1)) ? -1 : 0;
		motionBlurViewportValues[3] = static_cast<float>(x + w + offset) / (srcWidth - 1);

		offset = (y > 0) ? 1 : 0;
		motionBlurViewportValues[1] = static_cast<float>(y + offset) / (srcHeight - 1);

		offset = (y < (srcHeight - 1)) ? -1 : 0;
		motionBlurViewportValues[2] = static_cast<float>(y + h + offset) / (srcHeight - 1);

		for (auto& el : motionBlurViewportValues)
		{
			if (el <= 0.0f)
				el = -1.0f;
			else if (el >= 1.0f)
				el = 2.0f;
		}
	}
}

void motionBlur::drawBlur()
{
	IMaterialVar* MotionBlurInternal = motion_blur->findVar("$MotionBlurInternal", nullptr, false);

	MotionBlurInternal->setVectorComponent(motionBlurValues[0], 0);
	MotionBlurInternal->setVectorComponent(motionBlurValues[1], 1);
	MotionBlurInternal->setVectorComponent(motionBlurValues[2], 2);
	MotionBlurInternal->setVectorComponent(motionBlurValues[3], 3);

	// todo: find easiest way to trick the game we run motion blur, (easiest and best way - mempatch correct bytes)

	// edit those fields from memory, todo
	//float* motionBlurIntervalValues = *reinterpret_cast<float**>(m_motionBlurAddr);
	//motionBlurIntervalValues = m_motionBlurValues.data();

	IMaterialVar* MotionBlurViewPortInternal = motion_blur->findVar("$MotionBlurViewportInternal", nullptr, false);

	MotionBlurViewPortInternal->setVectorComponent(motionBlurViewportValues[0], 0);
	MotionBlurViewPortInternal->setVectorComponent(motionBlurViewportValues[1], 1);
	MotionBlurViewPortInternal->setVectorComponent(motionBlurViewportValues[2], 2);
	MotionBlurViewPortInternal->setVectorComponent(motionBlurViewportValues[3], 3);

	auto ctx = memory::interfaces::matSys->getRenderContext();
	ctx->drawScreenEffectMaterial(motion_blur);
}

void motionBlur::render()
{
	INIT_MATERIALS_ONCE(initMaterials);

	if (!vars::misc->motionBlur->enabled)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	drawBlur();
}

```

`hack/cheats/features/visuals/misc/motionblur.hpp`:

```hpp
#pragma once

class CViewSetup;

namespace motionBlur
{
	void render();
	void run(CViewSetup* view);

	void initMaterials();
	void drawBlur();
}

```

`hack/cheats/features/visuals/misc/noscope.cpp`:

```cpp
#include "noscope.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <SDK/vars.hpp>
#include <SDK/Enums.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <render/render.hpp>

//void NoScope::draw()
//{
//	if (!vars::misc->scope->enabled)
//		return;
//
//	if (!game::isAvailable())
//		return;
//
//	auto weapon = game::localPlayer->getActiveWeapon();
//	if (!weapon)
//		return;
//
//	if (!weapon->isSniper())
//		return;
//
//	if (game::localPlayer->m_bIsScoped())
//	{
//		ImRender::drawLine(globals::screenX / 2.0f, 0.0f, globals::screenX / 2.0f, static_cast<float>(globals::screenY), Colors::Black);
//		ImRender::drawLine(0.0f, globals::screenY / 2.0f, static_cast<float>(globals::screenX), globals::screenY / 2.0f, Colors::Black);
//	}
//}
//
//void NoScopeBlur::init()
//{
//	/*m_blurScope = memory::interfaces::matSys->findMaterial("dev/scope_bluroverlay", TEXTURE_GROUP_OTHER);
//	m_filterX = memory::interfaces::matSys->findMaterial("dev/blurfilterx_nohdr", TEXTURE_GROUP_OTHER);
//	m_filterY = memory::interfaces::matSys->findMaterial("dev/blurfiltery_nohdr", TEXTURE_GROUP_OTHER);
//	scope_lens_dirt = memory::interfaces::matSys->findMaterial("models/weapons/shared/scope/scope_lens_dirt", TEXTURE_GROUP_OTHER);*/
//}
//
//void NoScopeBlur::run()
//{
//	/*m_blurScope->setMaterialVarFlag(MATERIAL_VAR_NO_DRAW, vars::misc->scope->enabled);
//	m_filterX->setMaterialVarFlag(MATERIAL_VAR_NO_DRAW, vars::misc->scope->enabled);
//	m_filterY->setMaterialVarFlag(MATERIAL_VAR_NO_DRAW, vars::misc->scope->enabled);
//	scope_lens_dirt->setMaterialVarFlag(MATERIAL_VAR_NO_DRAW, vars::misc->scope->enabled);*/
//}
//
//#include <SDK/CViewSetup.hpp>
//
//void NoScopeBlurSnipers::run(CViewSetup* v)
//{
//	if (!vars::misc->scope->enabled)
//		return;
//
//	/*v->m_edgeBlur = 0;*/
//}
//

```

`hack/cheats/features/visuals/misc/noscope.hpp`:

```hpp
#pragma once

class IMaterial;

//// or find it in post proccess for those params
//class NoScope : protected RenderableSurfaceType
//{
//public:
//	constexpr NoScope() :
//		RenderableSurfaceType{}
//	{}
//
//protected:
//	virtual void draw() override;
//};
//
//GLOBAL_FEATURE(NoScope);
//
//class NoScopeBlur : protected DoPostScreenType
//{
//public:
//	constexpr NoScopeBlur() :
//		DoPostScreenType{}
//	{}
//
//protected:
//	virtual void run() override;
//	virtual void init() override;
//private:
//	IMaterial* m_blurScope;
//	IMaterial* m_filterX;
//	IMaterial* m_filterY;
//	IMaterial* scope_lens_dirt;
//};
//
//GLOBAL_FEATURE(NoScopeBlur);
//
//class CViewSetup;
//
//class NoScopeBlurSnipers : protected OverrideViewType
//{
//public:
//	constexpr NoScopeBlurSnipers() :
//		OverrideViewType{}
//	{}
//
//protected:
//	virtual void run(CViewSetup* v) override;
//};
//
//GLOBAL_FEATURE(NoScopeBlurSnipers);

```

`hack/cheats/features/visuals/misc/screenEffects.cpp`:

```cpp
#include "screenEffects.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <SDK/IMatRenderContext.hpp>
#include <SDK/vars.hpp>
#include <SDK/materialInit.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <menu/GUI-ImGui/selections.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <gamememory/memory.hpp>
#include <utilities/console/console.hpp>

#include <cheats/hooks/screen2dEffect.hpp>

namespace
{
	struct ScreenEffectshandler : hooks::Screen2DEffect
	{
		ScreenEffectshandler()
		{
			this->registerInit(screenEffects::initMaterials);
			this->registerRun(screenEffects::run);
		}
	} screenEffectsHandler;
}

namespace screenEffects
{
	std::vector<std::pair<IMaterial*, bool>> screenMaterials;
}

void screenEffects::initMaterials()
{
	for (const std::string_view el : selections::screenEffects)
	{
		bool mark = false;
		if (el == "effects/nightvision") // nighvision is special case, because overwriting a netvar just works
			mark = true;

		screenMaterials.emplace_back(std::make_pair(memory::interfaces::matSys->findMaterial(
			el.data(), TEXTURE_GROUP_CLIENT_EFFECTS), mark));
	}
}

void screenEffects::run(CViewSetup* view)
{
	if (!game::isAvailable())
		return;

	int cfg = vars::visuals->world->screenEffect->index;
	if (cfg == 0 || globals::isShutdown)
	{
		if (auto& night = game::localPlayer->m_bNightVisionOn())
			night = false;

		return;
	}

	const Color color = vars::visuals->world->screenEffect->color();

	const auto [material, isNightVision] = screenMaterials.at(cfg);
	material->colorModulate(color); // wont work for every material, to do on every refer how glow chams are made

	// only materials in special key have this, not all
	bool found{ false };
	if(const auto var = material->findVar("$c0_x", &found); var && found)
		var->setValue(vars::visuals->world->screenEffect->param);

	if (auto& night = game::localPlayer->m_bNightVisionOn(); !night && isNightVision)
	{
		night = true;
		game::localPlayer->m_flNightVisionAlpha() = color.a();
	}
	else if(night && !isNightVision)
		night = false;

	const auto ctx = memory::interfaces::matSys->getRenderContext();
	ctx->drawScreenEffectMaterial(material);
}

```

`hack/cheats/features/visuals/misc/screenEffects.hpp`:

```hpp
#pragma once

class CViewSetup;

namespace screenEffects
{
	void run([[maybe_unused]] CViewSetup* view);
	void initMaterials();
}
```

`hack/cheats/features/visuals/misc/trails.cpp`:

```cpp
#include "trails.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IViewRenderBeams.hpp>
#include <SDK/IEffects.hpp>
#include <SDK/material.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <menu/GUI-ImGui/selections.hpp>

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct TrailsHandler : hooks::PaintTraverse
	{
		TrailsHandler()
		{
			this->registerRender(trails::draw);
		}
	} trailsHandler;
}

namespace trails
{
	struct Trail_t
	{
		Vec3 pos;
		float expire;
	};

	std::vector<Trail_t> trailsList;
}

void trails::draw()
{
	if (!game::isAvailable())
		return;

	const int type = vars::misc->trail->mode;

	if (!vars::misc->trail->enabled)
		return;

	switch (type)
	{
	case E2T(MovementTrail::BEAM):
	{
		if (!game::localPlayer->isMoving())
			return;
		
		// we will use vecorigin for trails, absorigin updates too often
		static Vec3 end = game::localPlayer->m_vecOrigin();
		const Vec3 start = game::localPlayer->m_vecOrigin();

		CfgBeam cfgbeam = vars::misc->trail->beam;

		BeamInfo_t info = {};

		// or create a beam follow, I ended up displaying nothing
		info.m_type = TE_BEAMPOINTS;
		info.m_modelName = selections::beamNames.at(cfgbeam.index);
		info.m_modelIndex = -1;
		info.m_haloIndex = -1;
		info.m_haloScale = 0.0f;
		info.m_life = cfgbeam.life;
		info.m_width = cfgbeam.width;
		info.m_endWidth = cfgbeam.width;
		info.m_fadeLength = cfgbeam.fadeLength;
		info.m_amplitude = cfgbeam.amplitude;
		info.m_red = cfgbeam.color().rMultiplied();
		info.m_green = cfgbeam.color().gMultiplied();
		info.m_blue = cfgbeam.color().bMultiplied();
		info.m_brightness = cfgbeam.color().aMultiplied();
		info.m_speed = cfgbeam.speed;
		info.m_startFrame = static_cast<int>(cfgbeam.startFrame);
		info.m_frameRate = cfgbeam.frameRate;
		info.m_vecStart = start;
		info.m_vecEnd = end;
		info.m_segments = cfgbeam.segments;
		info.m_renderable = true;

		memory::interfaces::beams->createBeamPoints(info);

		end = start;

		break;
	}
	case E2T(MovementTrail::LINE):
	{
		if (game::localPlayer->isMoving())
			trailsList.emplace_back(game::localPlayer->m_vecOrigin(),
				memory::interfaces::globalVars->m_curtime + vars::misc->trail->lineLife);

		std::vector<ImVec2> points;
		for (size_t i = 0; const auto [pos, expire] : trailsList)
		{
			if (expire < memory::interfaces::globalVars->m_curtime)
			{
				trailsList.erase(trailsList.begin() + i);
				continue;
			}

			if (ImVec2 screen; ImRender::worldToScreen(pos, screen))
				points.push_back(screen);

			i++;
		}

		if (!points.empty())
			ImRender::drawPolyLine(points, vars::misc->trail->colorLine(), 0, 2.0f);

		break;
	}
	case E2T(MovementTrail::SPLASH):
	{
		static auto spark = memory::interfaces::matSys->findMaterial("effects/spark", TEXTURE_GROUP_PARTICLE);
		if (spark)
			spark->modulateAllColor(vars::misc->trail->colorSplash());

		if (game::localPlayer->isMoving())
			memory::interfaces::effects->energySplash(game::localPlayer->m_vecOrigin(),
				 game::localPlayer->m_angEyeAngles() * (game::localPlayer->m_vecVelocity().length() / game::localPlayer->m_flMaxspeed()), true);

		break;
	}
	default:
		break;
	}
}
```

`hack/cheats/features/visuals/misc/trails.hpp`:

```hpp
#pragma once

namespace trails
{
	void draw();
}
```

`hack/cheats/features/visuals/player/boxes.cpp`:

```cpp
#include "boxes.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>

void boxes::drawInnerOutline(const Box& box, float extraAlpha)
{
	ImRender::drawRect(box.x + 1.0f, box.y + 1.0f, box.w - 2.0f, box.h - 2.0f, Colors::Black.getColorEditAlpha(extraAlpha));
}

void boxes::drawOuterOutline(const Box& box, float extraAlpha)
{
	ImRender::drawRect(box.x - 1.0f, box.y - 1.0f, box.w + 2.0f, box.h + 2.0f, Colors::Black.getColorEditAlpha(extraAlpha));
}

void boxes::drawRect(const Box& box, const Color& color, float extraAlpha)
{
	ImRender::drawRect(box.x, box.y, box.w, box.h, color.getColorEditAlpha(extraAlpha));
}

void boxes::drawRectFilled(const Box& box, const Color& color, float extraAlpha)
{
	ImRender::drawRectFilled(box.x, box.y, box.w, box.h, color.getColorEditAlpha(extraAlpha));
}

void boxes::drawRectGradient(const Box& box, const Color& color1, const Color& color2, const Color& color3, const Color& color4, float extraAlpha)
{
	ImRender::drawRectFilledMultiColor(box.x, box.y, box.w, box.h,
		color1.getColorEditAlpha(extraAlpha),
		color2.getColorEditAlpha(extraAlpha),
		color3.getColorEditAlpha(extraAlpha),
		color4.getColorEditAlpha(extraAlpha));
}

void boxes::drawBox3D(const Box& box, const Color& color, float extraAlpha)
{
	for (size_t i = 1; i < 5; i++)
	{
		// BOTTOM 0,1,2,3
		ImRender::drawLine(box.points.at(i - 1), box.points.at(i % 4), color.getColorEditAlpha(extraAlpha));
		// TOP 4,5,6,7
		ImRender::drawLine(box.points.at(i + 3), box.points.at(i % 4 + 4), color.getColorEditAlpha(extraAlpha));
		// MISSING TOP
		ImRender::drawLine(box.points.at(i - 1), box.points.at(i + 3), color.getColorEditAlpha(extraAlpha));
	}
}

void boxes::drawBoxFilled3D(const Box& box, const Color& color, float extraAlpha)
{
	const auto maybeScanned = math::grahamScan(box.points);
	if (!maybeScanned.has_value())
		return;

	auto points = maybeScanned.value();

	std::reverse(points.begin(), points.end());
	ImRender::drawPolyGon(points, color.getColorEditAlpha(extraAlpha));
}
```

`hack/cheats/features/visuals/player/boxes.hpp`:

```hpp
#pragma once

#include <render/BBox.hpp>
#include <config/cfgBox.hpp>

namespace boxes
{
	void drawInnerOutline(const Box& box, float extraAlpha = 1.0f);
	void drawOuterOutline(const Box& box, float extraAlpha = 1.0f);
	void drawRect(const Box& box, const Color& color, float extraAlpha = 1.0f);
	void drawRectFilled(const Box& box, const Color& color, float extraAlpha = 1.0f);
	void drawRectGradient(const Box& box, const Color& color1, const Color& color2, const Color& color3, const Color& color4, float extraAlpha = 1.0f);
	void drawBox3D(const Box& box, const Color& color, float extraAlpha = 1.0f);
	void drawBoxFilled3D(const Box& box, const Color& color, float extraAlpha = 1.0f);
};

```

`hack/cheats/features/visuals/player/enemyWarn.cpp`:

```cpp
#include "enemyWarn.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/math/math.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>

namespace enemyWarning
{
	using checkType = std::optional<std::pair<bool, bool>>;
	checkType check(Player_t* ent);

	std::array<checkType, 65> spottedEnts;
}

enemyWarning::checkType enemyWarning::check(Player_t* ent)
{
	if (!game::isAvailable())
		return std::nullopt;

	auto posDelta = ent->getEyePos() - game::localPlayer->getEyePos();
	/*Vector idealAimAngle = math::vectorToAngle(posDelta);

	idealAimAngle -= ent->m_aimPunchAngle() * m_scale->getFloat();

	Vector curEnemyAngle = ent->m_angEyeAngles();
	curEnemyAngle.normalize();*/

	auto forward = math::angleVec(game::localPlayer->m_angEyeAngles());
	// yeah that's hardcoded and not 100% accurate, I thought of something like in radar as "fov view", but we can't be sure if enemy uses fov changer
	bool isBehind = posDelta.dot(forward) < 15.0f;

	bool check = ent->isPossibleToSee(game::localPlayer(), game::localPlayer->getEyePos()) && !isBehind;

	// dynamic fov
	// float fov = math::calcFovReal(ent->getEyePos(), game::localPlayer->getBonePos(3), curEnemyAngle); // 3 is middle body

	Trace_t trace;
	TraceFilter filter{ ent };
	const auto eye = ent->getEyePos();
	constexpr float range = 8192.0f; // because we need max range possible
	const auto end = eye + (math::angleVec(ent->m_angEyeAngles()) * range);
	memory::interfaces::trace->traceRay({ eye, end }, MASK_PLAYER, &filter, &trace);

	bool checkAim = trace.m_hitgroup != 0;

	return std::pair{ check, checkAim };
}

void enemyWarning::beginThink(Player_t* ent)
{
	if (!vars::misc->aimWarn->enabled)
		return;

	spottedEnts.at(ent->getIndex()) = check(ent);
}

void enemyWarning::endThink()
{
	for (auto& spot : spottedEnts)
		spot = std::nullopt;
}

void enemyWarning::draw()
{
	if (!vars::misc->aimWarn->enabled)
		return;

	bool visible{ false };
	bool aiming{ false };
	for (const auto& spot : spottedEnts)
	{
		if (spot.has_value())
		{
			const auto [vis, aim] = spot.value();
			if (vis)
				visible = true;

			if (aim)
				aiming = true;
		}
	}

	if(visible)
		ImRender::text(globals::screenX / 2.0f, 60.0f, ImRender::fonts::tahoma14, "Enemy can see you", true, Colors::Green);
	if(aiming)
		ImRender::text(globals::screenX / 2.0f, 80.0f, ImRender::fonts::tahoma14, "Enemy is aiming you", true, Colors::Red);
}
```

`hack/cheats/features/visuals/player/enemyWarn.hpp`:

```hpp
#pragma once

#include <utility>

class Player_t;

namespace enemyWarning
{
	void draw();
	void beginThink(Player_t* ent);
	void endThink();
}

```

`hack/cheats/features/visuals/player/player.cpp`:

```cpp
#include "player.hpp"

#include "boxes.hpp"
#include "enemyWarn.hpp"
#include "sounds.hpp"

#include "../../backtrack/backtrack.hpp"
#include "../../events/events.hpp"
#include "../../cache/cache.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IVEffects.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/IViewRenderBeams.hpp>
#include <SDK/animations.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/ILocalize.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <cheats/game/globals.hpp>

#include <ranges>

#include <cheats/hooks/paintTraverse.hpp>
#include <cheats/hooks/unkownRoundEnd.hpp>

namespace
{
	struct PlayerVisualsHandler : hooks::PaintTraverse
	{
		PlayerVisualsHandler()
		{
			this->registerRender(playerVisuals::draw);
		}
	} playerVisualsHandler;

	struct PlayerVisualsReset : hooks::UnknownRoundEnd
	{
		PlayerVisualsReset()
		{
			this->registerRun(playerVisuals::roundRestart);
		}
	} playerVisualsReset;
}

namespace playerVisuals
{
	struct DormacyInfo_t
	{
		float alpha;

		[[nodiscard]] bool isValid() const
		{
			if (alpha == 0.0f)
				return false;

			return true;
		}
	};

	struct VisualEntity
	{
		Player_t* entity;
		Box box;
		DormacyInfo_t dormacyInfo;
		float health; // handled on own
		float armor; // handled on own
	};

	struct Paddings
	{
		float top{ 0.0f };
		float bottom{ 0.0f };
		float left{ 0.0f };
		float right{ 0.0f };
	};

	std::array<VisualEntity, 65> players{ };
	Paddings padding{ };

	void drawBoxes(VisualEntity& player);
	void drawnName(VisualEntity& player);
	void runDLight(VisualEntity& player);
	void drawHealth(VisualEntity& player);
	void drawArmor(VisualEntity& player);
	void drawFlags(VisualEntity& player);
	void drawWeapon(VisualEntity& player);
	void drawSkeleton(VisualEntity& player);
	void drawSnapLine(VisualEntity& player);
	void drawLaser(VisualEntity& player);
	void updateDormacy(VisualEntity& player);
}

static float getDormantAlpha(const playerVisuals::DormacyInfo_t& dormacy, float originalCfg)
{
	if (dormacy.alpha > originalCfg)
		return originalCfg;
	else if (dormacy.alpha < originalCfg)
		return dormacy.alpha;

	return originalCfg;
}

void playerVisuals::draw()
{
	if (!game::isAvailable())
		return;

	bool isFlashOk{ true };

	if (game::localPlayer->m_flFlashDuration() > 0.0f)
	{
		if (game::localPlayer->m_flFlashBangTime() >= vars::visuals->esp->checks->flashLimit)
			isFlashOk = false;
	}

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		const auto player = reinterpret_cast<Player_t*>(entity);

		if (player == game::localPlayer)
			continue;

		if (!player->isAlive())
			continue;

		if (!player->isOtherTeam(game::localPlayer()))
			continue;

		auto& visual = players.at(idx);
		visual.entity = player;

		updateDormacy(visual);

		sound::findBest(player);
		enemyWarning::beginThink(player);

		if (!visual.dormacyInfo.isValid())
			continue;

		Box box{ player };
		if (!box.isValid())
			continue;

		if (!isFlashOk)
			continue;

		visual.box = box;

		if (vars::visuals->esp->checks->visible)
		{
			const bool check1 = game::localPlayer->isPossibleToSee(player, player->getHitboxPos(HITBOX_HEAD));
			const bool check2 = game::localPlayer->isPossibleToSee(player, player->getHitboxPos(HITBOX_BELLY));

			if (!check1 && !check2)
				continue;
		}

		if (vars::visuals->esp->checks->smoke)
		{
			const bool check1 = game::localPlayer->isViewInSmoke(player->getHitboxPos(HITBOX_HEAD));
			const bool check2 = game::localPlayer->isViewInSmoke(player->getHitboxPos(HITBOX_BELLY));

			if (!check1 && !check2)
				continue;
		}

		if (vars::visuals->esp->checks->dead)
		{
			if (game::localPlayer->isAlive())
				continue;
		}
		
		drawBoxes(visual);
		drawnName(visual);
		runDLight(visual);
		drawSkeleton(visual);
		drawSnapLine(visual);
		drawLaser(visual);
		drawHealth(visual);
		drawArmor(visual);
		drawWeapon(visual);
		drawFlags(visual);

		padding = Paddings{ };
	}

	sound::draw();
	enemyWarning::draw();

	enemyWarning::endThink();
}

void playerVisuals::drawBoxes(VisualEntity& player)
{
	if (vars::visuals->esp->boxes->box.mode == E2T(BoxTypes::OFF))
		return;

	padding.bottom += 4.0f;
	padding.top -= 2.0f;
	padding.left -= 4.0f;
	padding.right += 4.0f;

	const auto box = player.box;
	auto cfg = vars::visuals->esp->boxes->box;
	const float limitAlphaOutline = std::max(cfg.color().a(), cfg.fill().a());

	if (cfg.mode == E2T(BoxTypes::BOX2D))
	{
		const bool outlined = cfg.outline;

		if (outlined)
		{
			boxes::drawInnerOutline(box, getDormantAlpha(player.dormacyInfo, limitAlphaOutline));
			boxes::drawOuterOutline(box, getDormantAlpha(player.dormacyInfo, limitAlphaOutline));
		}

		boxes::drawRect(box, cfg.color.getColor(), getDormantAlpha(player.dormacyInfo, cfg.color().a()));
	}
	else if (cfg.mode == E2T(BoxTypes::FILLED2D))
	{
		const bool outlined = cfg.outline;
		const bool gradient = cfg.gradient;

		if (gradient)
		{
			ImRender::drawRectFilledMultiColor(box.x, box.y, box.w, box.h,
				cfg.gradientCol1().getColorEditAlpha(getDormantAlpha(player.dormacyInfo, cfg.gradientCol1().a())),
				cfg.gradientCol2().getColorEditAlpha(getDormantAlpha(player.dormacyInfo, cfg.gradientCol2().a())),
				cfg.gradientCol3().getColorEditAlpha(getDormantAlpha(player.dormacyInfo, cfg.gradientCol3().a())),
				cfg.gradientCol4().getColorEditAlpha(getDormantAlpha(player.dormacyInfo, cfg.gradientCol4().a())));
		}
		else
			boxes::drawRectFilled(box, cfg.fill(), getDormantAlpha(player.dormacyInfo, cfg.fill().a()));

		if (outlined)
		{
			boxes::drawOuterOutline(box, getDormantAlpha(player.dormacyInfo, Colors::Black.a()));
		}
	}
	else if (cfg.mode == E2T(BoxTypes::BOX3D))
	{
		boxes::drawBox3D(box, cfg.color(), getDormantAlpha(player.dormacyInfo, cfg.color().a()));
	}
	else if (cfg.mode == E2T(BoxTypes::FILLED3D))
	{
		boxes::drawBoxFilled3D(box, cfg.fill(), getDormantAlpha(player.dormacyInfo, cfg.fill().a()));
		boxes::drawBox3D(box, cfg.fill(), getDormantAlpha(player.dormacyInfo, cfg.fill().a()));
	}
}

void playerVisuals::drawnName(VisualEntity& player)
{
	if (!vars::visuals->esp->nameBar->enabled)
		return;

	const float fontSize = game::getScaledFont(player.entity->absOrigin(), game::localPlayer()->absOrigin());

	ImRender::text(player.box.x + player.box.w / 2.0f, player.box.y - fontSize - 2.0f, fontSize, ImRender::fonts::verdana12, player.entity->getName(), true,
		Color::healthBased(player.entity->m_iHealth()).getColorEditAlpha(player.dormacyInfo.alpha), false);
}

void playerVisuals::runDLight(VisualEntity& player)
{
	// https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/sp/src/game/client/c_spotlight_end.cpp#L112

	if (!vars::visuals->esp->dlight->enabled)
		return;

	// in theory this should boost performance, in reality nope
	// the real performance would be rebuild of dlight not using many useless allocations
	//constexpr auto lightDie = 1e4f;
	//static std::array<DLight_t*, 128> dlights;
	//static std::once_flag once;
	//std::call_once(once, [&]()
	//	{
	//		for (size_t i = 0; i < dlights.size(); ++i)
	//		{
	//			dlights.at(i) = memory::interfaces::efx->clAllocDLight(i);
	//			// so this will 
	//			dlights.at(i)->m_die = memory::interfaces::globalVars->m_curtime + lightDie;
	//		}
	//	});

	//auto& dLight = dlights.at(player.entity->getIndex());
	//if (dLight->m_die == memory::interfaces::globalVars->m_curtime)
	//{
	//	// reallocate the light
	//	dLight = memory::interfaces::efx->clAllocDLight(player.entity->getIndex());
	//	dLight->m_die = memory::interfaces::globalVars->m_curtime + lightDie;
	//}

	auto dLight = memory::interfaces::efx->clAllocDLight(player.entity->getIndex());
	dLight->m_color = vars::visuals->esp->dlight->color();
	dLight->m_origin = player.entity->m_vecOrigin();
	dLight->m_radius = vars::visuals->esp->dlight->radius;
	dLight->m_die = memory::interfaces::globalVars->m_curtime + 0.1f;
	dLight->m_exponent = static_cast<char>(vars::visuals->esp->dlight->exponent);
	dLight->m_decay = vars::visuals->esp->dlight->decay;
	dLight->m_key = player.entity->getIndex();
}

// yoinked: https://www.unknowncheats.me/wiki/Counter_Strike_Global_Offensive:Bone_ESP
void playerVisuals::drawSkeleton(VisualEntity& player)
{
	if (!vars::visuals->esp->skeleton->enabled)
		return;

	const auto model = player.entity->getModel();
	if (!model)
		return;

	const auto studio = memory::interfaces::modelInfo->getStudioModel(model);
	if (!studio)
		return;

	const auto& btRecords = backtrack::records.at(player.entity->getIndex());

	auto skeletPos = [=](const size_t idx)
	{
		const auto child = btRecords.empty()
			? player.entity->getBonePos(idx)
			: btRecords.back().matrices[idx].origin();
		return child;
	};

	// bone IDs
	constexpr auto chest = 6;
	constexpr auto lowerChest = 5;

	for (auto i : std::views::iota(0, studio->m_bonesCount))
	{
		auto bone = studio->getBone(i);
		if (!bone)
			continue;

		if (bone->m_parent == -1)
			continue;

		if (!(bone->m_flags & BONE_USED_BY_HITBOX))
			continue;

		if (!btRecords.empty() && !backtrack::isValid(btRecords.front().simtime))
			continue;

		auto child = skeletPos(i);
		auto parent = skeletPos(bone->m_parent);
		auto chestbone = skeletPos(chest);
		auto upper = skeletPos(chest + 1) - chestbone;
		auto breast = chestbone + upper / 2.0f;

		auto deltachild = child - breast;
		auto deltaparent = parent - breast;

		if (deltaparent.length() < 9.0f && deltachild.length() < 9.0f)
			parent = breast;

		if (i == lowerChest)
			child = breast;

		if (std::abs(deltachild[Coord::Z]) < 5.0f && deltaparent.length() < 5.0f && deltachild.length() < 5.0f || i == chest)
			continue;

		if (vars::visuals->esp->skeleton->showDebug)
		{
			if (ImVec2 s; ImRender::worldToScreen(player.entity->getBonePos(i), s))
				ImRender::text(s.x, s.y, ImRender::fonts::franklinGothic12, std::format("{}", i), true, Colors::White, true);
		}

		if (ImVec2 start, end; ImRender::worldToScreen(parent, start) && ImRender::worldToScreen(child, end))
			ImRender::drawLine(start, end, vars::visuals->esp->skeleton->color().getColorEditAlpha(getDormantAlpha(player.dormacyInfo, vars::visuals->esp->skeleton->color().a())));
	}
}

void playerVisuals::drawHealth(VisualEntity& player)
{
	if (!vars::visuals->esp->healthBar->enabled)
		return;

	int maxHealth = player.entity->getMaxHealth();
	float frequency = maxHealth * (1.0f / 0.5f);

	auto& health = player.health;
	const auto realHealth = player.entity->m_iHealth();
	if (health > realHealth)
		health -= frequency * memory::interfaces::globalVars->m_frametime;
	else
		health = static_cast<float>(realHealth);

	const auto offset = health * player.box.h / maxHealth;
	const auto pad = player.box.h - offset;

	Box newBox
	{
		player.box.x + padding.left - 2.0f,
		player.box.y,
		2.0f,
		player.box.h,
	};

	ImRender::drawRectFilled(newBox.x - 1.0f, newBox.y - 1.0f, 4.0f, newBox.h + 2.0f, Colors::Black.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f)));
	ImRender::drawRectFilled(newBox.x, newBox.y + pad, 2.0f, offset, Color::healthBased(player.entity->m_iHealth()).getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f)));

	// if the player has health below max, then draw HP info
	if (health < 100)
	{
		auto text = std::format("{}", realHealth);
		float fontSize = game::getScaledFont(player.entity->absOrigin(), game::localPlayer->absOrigin(), 100.0f, 10.0f, 14.0f);
		auto size = ImRender::fonts::franklinGothic12->CalcTextSizeA(fontSize, std::numeric_limits<float>::max(), 0.0f, text.c_str());

		ImRender::text(newBox.x - 4.0f - size.x, newBox.y + pad - 4.0f,
			fontSize, ImRender::fonts::franklinGothic12, text, false, Colors::White.getColorEditAlpha(player.dormacyInfo.alpha));
	}

	padding.left -= 6.0f;
}

void playerVisuals::drawArmor(VisualEntity& player)
{
	if (!vars::visuals->esp->armorBar->enabled)
		return;
	
	constexpr int maxArmor = 100;
	constexpr float frequency = maxArmor * (1.0f / 0.5f);
	auto& armor = player.armor;
	const auto realArmor = player.entity->m_ArmorValue();

	if (armor > realArmor)
		armor -= frequency * memory::interfaces::globalVars->m_frametime;
	else
		armor = static_cast<float>(realArmor);

	const auto offset = armor * player.box.h / maxArmor;
	const auto pad = player.box.h - offset;

	Box newBox
	{
		player.box.x + player.box.w + padding.right,
		player.box.y,
		2.0f,
		player.box.h,
	};

	const Color armorCol{ 0, static_cast<int>(armor * 1.4f), 255 };

	if (armor != 0)
	{
		ImRender::drawRectFilled(newBox.x - 1.0f, newBox.y - 1.0f, 4.0f, newBox.h + 2.0f, Colors::Black.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f)));
		ImRender::drawRectFilled(newBox.x, newBox.y + pad, 2.0f, offset, armorCol.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f)));
	}

	padding.right += 6.0f;
}

#include <SDK/ILocalize.hpp>

void playerVisuals::drawWeapon(VisualEntity& player)
{
	if (!vars::visuals->esp->weaponBar->enabled)
		return;

	const auto weapon = player.entity->getActiveWeapon();
	if (!weapon)
		return;

	Color tex = vars::visuals->esp->weaponBar->text();

	const int maxAmmo = weapon->getWpnInfo()->m_maxClip1;
	const int currentAmmo = weapon->m_iClip1();

	ImRender::text(player.box.x + player.box.w / 2, player.box.y + player.box.h + 5, ImRender::fonts::franklinGothic12, std::format("{} {}/{}",
		vars::visuals->esp->weaponBar->translate ? memory::interfaces::localize->findAsUTF8(weapon->getWpnInfo()->m_WeaponName) : player.entity->getActiveWeapon()->getWpnName(), currentAmmo, maxAmmo),
		true, vars::visuals->esp->weaponBar->text().getColorEditAlpha(getDormantAlpha(player.dormacyInfo, vars::visuals->esp->weaponBar->text().a())));

	// skip useless trash for calculations
	if (weapon->isNonAimable())
		return;

	Box newBox =
	{
		player.box.x,
		player.box.y + player.box.h + padding.bottom,
		player.box.w + 2.0f,
		2.0f
	};

	float barWidth = currentAmmo * player.box.w / maxAmmo;
	const auto animlayer = player.entity->getAnimOverlays()[1];

	if (animlayer.m_sequence)
	{
		const auto sequenceActivity = player.entity->getSequenceActivity(animlayer.m_sequence);
		const bool isReloading = sequenceActivity == 967 && animlayer.m_weight; // ACT_CSGO_RELOAD

		if (isReloading && animlayer.m_weight != 0.0f && animlayer.m_cycle < 0.99f)
			barWidth = (animlayer.m_cycle * player.box.w) / 1.0f;
	}

	const float alphaLimit = vars::visuals->esp->weaponBar->bar().a();

	ImRender::drawRectFilled(newBox.x - 1.0f, newBox.y - 1.0f, newBox.w, 4.0f, Colors::Black.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, alphaLimit)));
	ImRender::drawRectFilled(newBox.x, newBox.y, barWidth, 2.0f, vars::visuals->esp->weaponBar->bar().getColorEditAlpha(getDormantAlpha(player.dormacyInfo, alphaLimit)));

	padding.bottom += 6.0f;
}

void playerVisuals::drawFlags(VisualEntity& player)
{
	std::vector<std::pair<std::string, Color>> flags{ };

	PlayerInfo_t info{ };
	if (!memory::interfaces::engine->getPlayerInfo(player.entity->getIndex(), &info))
		return;

	const auto cfgflags = vars::visuals->esp->flags->flags;

	if (cfgflags.at(E2T(EspFlags::BOT)))
	{
		if (info.m_fakePlayer)
			flags.emplace_back(std::make_pair("BOT", Colors::Yellow.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f))));
	}

	if (cfgflags.at(E2T(EspFlags::MONEY)))
	{
		flags.emplace_back(std::make_pair(std::format("{}$", player.entity->m_iAccount()), Colors::Green.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f))));
	}

	if (cfgflags.at(E2T(EspFlags::WINS)))
	{
		flags.emplace_back(std::make_pair(std::format("Wins {}", player.entity->getWins()), Colors::Green.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f))));
	}

	if (cfgflags.at(E2T(EspFlags::RANK)))
	{
		flags.emplace_back(std::make_pair(std::format("Rank {}", player.entity->getRank()), Colors::White.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f))));
	}

	if (cfgflags.at(E2T(EspFlags::ARMOR)))
	{
		std::string text{ };
		if (player.entity->m_bHasHelmet() && player.entity->m_ArmorValue())
			text = "H KEV";
		else if (!player.entity->m_bHasHelmet() && player.entity->m_ArmorValue())
			text = "KEV";

		flags.emplace_back(std::make_pair(text, Colors::White.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f))));
	}

	if (cfgflags.at(E2T(EspFlags::ZOOM)))
	{
		if (player.entity->m_bIsScoped())
			flags.emplace_back(std::make_pair("ZOOM", Colors::White.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f))));
	}

	if (cfgflags.at(E2T(EspFlags::C4)))
	{
		if (player.entity->isC4Owner())
			flags.emplace_back(std::make_pair("C4", Colors::Orange.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f))));
	}

	const float fontSize = game::getScaledFont(player.entity->absOrigin(), game::localPlayer()->absOrigin(), 60.0f, 11.0f, 16.0f);

	float paddingText = 0.0f;
	for (size_t i = 0; const auto & [name, color] : flags)
	{
		ImRender::text(player.box.x + player.box.w + padding.right + 2.0f, player.box.y + paddingText, fontSize,
			ImRender::fonts::verdana12, name, false, color, false);
		const auto textSize = ImRender::fonts::verdana12->CalcTextSizeA(fontSize, std::numeric_limits<float>::max(), 0.0f, name.c_str());
		paddingText += textSize.y;

		i++;

		if (i != flags.size() && paddingText + fontSize > player.box.h) // when too many flags for long distances
		{
			ImRender::text(player.box.x + player.box.w + padding.right + 2.0f, player.box.y + paddingText, fontSize, ImRender::fonts::verdana12,
				std::format("{} more...", flags.size() - i), false, Colors::White.getColorEditAlpha(getDormantAlpha(player.dormacyInfo, 1.0f)), false);
			break;
		}
	}

	// I don't handle padding here, because flags should be last to display
}

void playerVisuals::drawSnapLine(VisualEntity& player)
{
	if (!vars::visuals->esp->snapline->enabled)
		return;

	ImRender::drawLine(globals::screenX / 2.0f, 
		static_cast<float>(globals::screenY), player.box.x + player.box.w / 2, player.box.y + player.box.h, vars::visuals->esp->snapline->color());
}

void playerVisuals::drawLaser(VisualEntity& player)
{
	if (!vars::visuals->esp->lasers->enabled)
		return;

	// get from where to start, "laser ESP" is always starting from head I think
	const auto start = player.entity->getBonePos(8);
	// get angle to draw with correct view
	const auto forward = math::angleVec(player.entity->m_angEyeAngles());
	// end is where lines just ends, this 70 is hardcoded, but whatever here tbh
	constexpr float okayishDist{ 70.f };
	const auto end = start + forward * okayishDist;

	if (ImVec2 startP, endLine; ImRender::worldToScreen(start, startP) && ImRender::worldToScreen(end, endLine))
	{
		ImRender::drawCircleFilled(startP.x, startP.y, 3, 32, Colors::Red);
		ImRender::drawLine(startP, endLine, vars::visuals->esp->lasers->color().getColorEditAlpha(getDormantAlpha(player.dormacyInfo, vars::visuals->esp->lasers->color().a())));
	}
}

void playerVisuals::updateDormacy(VisualEntity& player)
{
	auto& dormacy = player.dormacyInfo;

	const float ratio = 1.0f / vars::visuals->dormacy->time;
	const float step = ratio * memory::interfaces::globalVars->m_frametime;

	player.entity->isDormant() ? dormacy.alpha -= step : dormacy.alpha += step;

	dormacy.alpha = std::clamp(dormacy.alpha, 0.0f, 1.0f);
}

void playerVisuals::roundRestart()
{
	for (auto& player : players)
		player.dormacyInfo.alpha = 0.0f;
}
```

`hack/cheats/features/visuals/player/player.hpp`:

```hpp
#pragma once

namespace playerVisuals
{
	void draw();
	void roundRestart();
}

```

`hack/cheats/features/visuals/player/sounds.cpp`:

```cpp
#include "sounds.hpp"

#include "../../events/events.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

#include <imgui_internal.h>
#include <deque>

namespace sound
{
	struct StepData_t
	{
		Player_t* player{ nullptr };
		Vec3 pos;
		float expire;
		float maxPixels;
		float timeToPrint;
		float fontSize;
	};

	std::array<std::deque<StepData_t>, 65> steps;
	StepData_t bestStep{ };
}

// https://www.unknowncheats.me/forum/counterstrike-global-offensive/333825-bloodhound-inspired-legit-csgo-esp.html
void sound::findBest(Player_t* ent)
{
	if (!vars::visuals->sound->enabled)
		return;

	const int index = ent->getIndex();

	const float x = globals::screenX / 2.0f;
	const float y = globals::screenY / 2.0f;
	const float maxDist = vars::visuals->sound->maxDist;
	const float maxDistLine = vars::visuals->sound->maxDistLine;

	for (size_t i = 0; const auto & el : steps.at(index))
	{
		float diff = el.expire - memory::interfaces::globalVars->m_curtime;

		if (diff < 0.0f)
		{
			steps.at(index).erase(steps.at(index).begin() + i);
			continue;
		}

		ImVec2 elPos;
		if (!ImRender::worldToScreen(el.pos, elPos))
			continue;

		//float scale = diff / config.get<float>(vars.fStepTime); // ratio
		float alpha = (maxDist - el.pos.distToMeters(game::localPlayer->absOrigin())) / maxDist; // alpha fading per distance
		if (alpha < 0.1f)
			continue;

		if (constexpr float maxDiff = 1.0f; diff < maxDiff) // fading effect
			alpha = (diff / maxDiff) * alpha;

		const float rad = game::getScaledFont(el.pos, game::localPlayer->absOrigin(), 50.0f, 3.0f, 8.0f);;
		ImRender::drawCircleFilled(elPos.x, elPos.y, rad, 32,
			vars::visuals->sound->color().getColorEditAlpha(alpha));

		const ImVec2 fromScreen = ImVec2{ elPos.x - x,  elPos.y - y };
		const float distFromMiddle = std::round(ImSqrt(ImLengthSqr(fromScreen)));

		if (distFromMiddle < maxDistLine)
		{
			if (!bestStep.player || distFromMiddle < bestStep.maxPixels)
			{
				bestStep.player = el.player;
				bestStep.pos = el.pos;
				bestStep.timeToPrint = diff;
				bestStep.maxPixels = distFromMiddle;
				// better not
				/*bestStep.m_fontSize = scaledFont(50.0f, 10.0f, 18.0f);*/
			}
		}

		i++;
	}
}

void sound::draw()
{
	float x = globals::screenX / 2.0f;
	const float y = globals::screenY / 2.0f;

	if (bestStep.player)
	{
		if (ImVec2 pos; ImRender::worldToScreen(bestStep.pos, pos))
		{
			std::string_view place = bestStep.player->m_szLastPlaceName();
			if (place.empty())
				place = "Unknown";
			const std::string nameText = std::format("{} -> {} [{:.1f}m]", bestStep.player->getName(),
				place, game::localPlayer->absOrigin().distToMeters(bestStep.pos));
			const std::string timeText = std::format("Time left {:.1f}s", bestStep.timeToPrint);

			x = globals::screenX / 2.5f;

			const float textSize = std::max(
				ImRender::getTextSize(ImRender::fonts::tahoma14, ImRender::fonts::tahoma14->FontSize, timeText).x,
				ImRender::getTextSize(ImRender::fonts::tahoma14, ImRender::fonts::tahoma14->FontSize, nameText).x);

			static float fontSize = ImRender::fonts::tahoma14->FontSize + 2.0f;

			ImRender::text(x, y, ImRender::fonts::tahoma14, timeText, false, Colors::White);
			ImRender::text(x, y - fontSize, ImRender::fonts::tahoma14, nameText, false, Colors::White);
			ImRender::drawLine(x, y, x + textSize, y, vars::visuals->sound->colorLine());
			ImRender::drawLine(x + textSize, y, pos.x, pos.y, vars::visuals->sound->colorLine());
		}

		bestStep.player = nullptr;
	}
}

void sound::pushSteps(Player_t* ent)
{
	if (!ent->isOtherTeam(game::localPlayer()))
		return;

	const StepData_t step
	{
		.player =  ent,
		.pos = ent->absOrigin(),
		.expire = memory::interfaces::globalVars->m_curtime + vars::visuals->sound->time 
	};

	steps.at(step.player->getIndex()).push_back(step);
}
```

`hack/cheats/features/visuals/player/sounds.hpp`:

```hpp
#pragma once

class Player_t;

namespace sound
{
	void draw();
	void findBest(Player_t* ent);
	void pushSteps(Player_t* ent);
};

```

`hack/cheats/features/visuals/plots/plots.cpp`:

```cpp
#include "plots.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/utilities.hpp>
#include <render/render.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

#include <menu/GUI-ImGui/imguiaddons.hpp>
#include <imgui.h>
#include <imgui_internal.h>
#include <implot.h>

#include <numeric>

#include <cheats/hooks/present.hpp>
#include <cheats/hooks/createMove.hpp>
#include <cheats/helper/initable.hpp>

namespace
{
	struct PlotIniter : InitAble
	{
		PlotIniter()
		{
			this->registerInit(plots::init);
		}
	} plotsInit;

	struct PlotHandler : hooks::Present
	{
		PlotHandler()
		{
			this->registerRun(plots::draw);
		}
	} plotHandler;

	struct PlotVelocityCollector : hooks::CreateMove
	{
		PlotVelocityCollector()
		{
			this->registerRunPrediction(plots::collectVelocity);
		}
	} plotVelocityCollector;
}

namespace plots
{
	constexpr size_t MAX_ELEMENTS_PLOTS{ 1000 };

	// using vector, because it's easier to implement in code (emplace_back)
	// even tho, it has known capacity so no big deal
	std::vector<double> velocityRecords;
	std::vector<double> fpsRecords;

	// both plots will use it
	std::array<double, MAX_ELEMENTS_PLOTS> sharedXS;
}

void plots::init()
{
	velocityRecords.reserve(MAX_ELEMENTS_PLOTS);
	fpsRecords.reserve(MAX_ELEMENTS_PLOTS);

	std::iota(sharedXS.begin(), sharedXS.end(), 0);

	console::debug("plots init");
}

void plots::draw()
{
	drawFps();
	drawVelocity();
}

void plots::drawFps()
{
	if (!vars::misc->plots->enabledFps)
		return;

	auto getfps = []() -> double // this is how they do it
	{
		static double realfps = 0.0;
		realfps = 0.9 * realfps + (1.0 - 0.9) * memory::interfaces::globalVars->m_absoluteframetime;

		return 1.0 / realfps;
	};

	const double fps = getfps();
	// when loading, you have a chance of freezing
	if (std::isinf(fps))
	{
		console::warn("record for plot got skipped due to infinity");
		return;
	}

	fpsRecords.emplace_back(fps);

	while (fpsRecords.size() > MAX_ELEMENTS_PLOTS)
		fpsRecords.erase(fpsRecords.begin());

	static float MAX_FPS = memory::interfaces::engine->isInGame() ? 350.0f : 120.0f;

	if (ImGui::Begin("##DummyFps", &vars::misc->plots->enabledFps, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_MenuBar))
	{
		if (ImGui::BeginMenuBar())
		{
			if (ImGui::BeginMenu("Menu"))
			{
				ImGui::SliderFloat("Set max FPS", &MAX_FPS, 30.0f, 1000.0f, "%.2f", ImGuiSliderFlags_Logarithmic);
				ImGui::SliderInt("Records size", &vars::misc->plots->sizeFps, 10, 1000);
				ImGui::ColorPicker("Color lines plot fps", &vars::misc->plots->colorFPS);

				ImGui::EndMenu();
			}
	
			ImGui::EndMenuBar();
		}

		if (fpsRecords.size() != MAX_ELEMENTS_PLOTS)
		{
			ImGui::TextUnformatted("Wait for buffer to load!");
			ImGui::ProgressBar(fpsRecords.size() / static_cast<float>(MAX_ELEMENTS_PLOTS), ImVec2{ 0, 0 });

			ImGui::End();
			return;
		}

		std::vector<double> xs{ sharedXS.begin(), sharedXS.begin() + vars::misc->plots->sizeFps };
		std::vector<double> fps{ fpsRecords.end() - vars::misc->plots->sizeFps, fpsRecords.end() };

		ImPlot::SetNextAxesLimits(0, vars::misc->plots->sizeFps, 0, MAX_FPS, ImPlotCond_::ImPlotCond_Always);
		ImPlot::PushStyleColor(ImPlotCol_Fill, Color::U32(vars::misc->plots->colorFPS().getColorEditAlpha(0.25f)));
		ImPlot::PushStyleColor(ImPlotCol_Line, Color::U32(vars::misc->plots->colorFPS()));
		ImPlot::PushStyleColor(ImPlotCol_FrameBg, { 0,0,0,0 });
		ImPlot::PushStyleColor(ImPlotCol_PlotBg, { 0,0,0,0 });

		if (ImPlot::BeginPlot("Fps", ImVec2{ -1, -1 }))
		{

			ImPlot::SetupAxes("Records", "Fps");		
			ImPlot::PlotShaded("##plotfps", xs.data(), fps.data(), vars::misc->plots->sizeFps);
			ImPlot::PlotLine("##plotfps", xs.data(), fps.data(), vars::misc->plots->sizeFps);

			ImPlot::EndPlot();
		}

		ImPlot::PopStyleColor(4);

		ImGui::End();
	}
}

void plots::drawVelocity()
{
	if (!vars::misc->plots->enabledVelocity)
		return;

	if (!memory::interfaces::engine->isInGame() || !game::localPlayer->isAlive())
		return;

	static float MAX_SPEEED_MOVE = memory::interfaces::cvar->findVar("sv_maxspeed")->getFloat(); // should be accurate

	if (velocityRecords.empty())
		return;

	std::vector<double> xs(velocityRecords.size());
	for (size_t i = 0; auto& el : xs)
	{
		el = i;

		++i;
	}

	const int flags = vars::misc->plots->transparencyVelocity
		? ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoResize
		: ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_MenuBar;

	if (ImGui::Begin("##DummyVel", &vars::misc->plots->enabledVelocity, flags))
	{
		if (!vars::misc->plots->transparencyVelocity)
		{
			if (ImGui::BeginMenuBar())
			{
				if (ImGui::BeginMenu("Menu"))
				{
					ImGui::SliderInt("Records size", &vars::misc->plots->sizeVelocity, 10, MAX_ELEMENTS_PLOTS - 1);
					ImGui::ColorPicker("Color lines plot vel", &vars::misc->plots->colorVelocity);

					ImGui::EndMenu();
				}

				ImGui::EndMenuBar();
			}
		}

		if (velocityRecords.size() != MAX_ELEMENTS_PLOTS)
		{
			ImGui::TextUnformatted("Wait for buffer to load!");
			ImGui::ProgressBar(velocityRecords.size() / static_cast<float>(MAX_ELEMENTS_PLOTS), ImVec2{ 0, 0 });

			ImGui::End();
			return;
		}

		std::vector<double> xs{ sharedXS.begin(), sharedXS.begin() + vars::misc->plots->sizeVelocity };
		std::vector<double> vel{ velocityRecords.end() - vars::misc->plots->sizeVelocity, velocityRecords.end() };

		ImPlot::SetNextAxesLimits(0, vars::misc->plots->sizeVelocity, 0, MAX_SPEEED_MOVE + 20, ImPlotCond_::ImPlotCond_Always);
		ImPlot::PushStyleColor(ImPlotCol_Fill, Color::U32(vars::misc->plots->colorVelocity().getColorEditAlpha(0.25f)));
		ImPlot::PushStyleColor(ImPlotCol_Line, Color::U32(vars::misc->plots->colorVelocity()));
		ImPlot::PushStyleColor(ImPlotCol_FrameBg, { 0,0,0,0 });
		ImPlot::PushStyleColor(ImPlotCol_PlotBg, { 0,0,0,0 });

		const int flags = vars::misc->plots->transparencyVelocity ? ImPlotFlags_NoTitle : ImPlotFlags_None;

		if (ImPlot::BeginPlot("Velocity", ImVec2{ -1, -1 }, flags))
		{
			ImPlot::SetupAxes("Records", "Velocity", 
				vars::misc->plots->transparencyVelocity ? ImPlotAxisFlags_NoDecorations : ImPlotAxisFlags_None,
				vars::misc->plots->transparencyVelocity ? ImPlotAxisFlags_NoDecorations : ImPlotAxisFlags_None);

			if(!vars::misc->plots->transparencyVelocity)
				ImPlot::PlotShaded("##plotvel", xs.data(), vel.data(), vars::misc->plots->sizeVelocity);
			ImPlot::PlotLine("##plotvel", xs.data(), vel.data(), vars::misc->plots->sizeVelocity);

			ImPlot::EndPlot();
		}

		ImPlot::PopStyleColor(4);

		ImGui::End();
	}
}

void plots::collectVelocity(CUserCmd* cmd)
{
	if (!vars::misc->plots->enabledVelocity)
		return;

	if (!game::localPlayer)
		return;

	if (!memory::interfaces::engine->isInGame())
	{
		velocityRecords.clear();
		return;
	}

	float vel = game::localPlayer->m_vecVelocity().toVecPrev().length();
	if (std::isinf(vel))
	{
		console::warn("record for plot got skipped due to infinity");
		return;
	}

	velocityRecords.emplace_back(game::localPlayer->m_vecVelocity().toVecPrev().length());

	// width
	while (velocityRecords.size() > MAX_ELEMENTS_PLOTS)
		velocityRecords.erase(velocityRecords.begin());
}

```

`hack/cheats/features/visuals/plots/plots.hpp`:

```hpp
#pragma once

class CUserCmd;

namespace plots
{
	void draw();
	void init();

	void drawFps();
	void drawVelocity();

	void collectVelocity(CUserCmd* cmd);
}

```

`hack/cheats/features/visuals/radar/radar.cpp`:

```cpp
#include "radar.hpp"

#include <cheats/features/cache/cache.hpp>

#include <SDK/IVEngineClient.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/MapStruct.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <utilities/res.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

#include <imgui.h>
#include <imgui_internal.h>

#include <d3dx9.h>

#include <cheats/hooks/present.hpp>

namespace
{
	struct RadarHandler : hooks::Present
	{
		RadarHandler()
		{
			this->registerRun(radar::draw);
		}
	} adarhandler;
}

namespace radar
{
	struct MapInfo
	{
		Vec2 pos;
		float scale;
	} mapInfo;

	ImVec2 entToRadar(const Vec3& eye, const Vec3& angles, const Vec3& entPos, const float scale, bool clipRanges);
	void drawMap();
	void manuallyInitPos();

	bool inited{ false };
	constexpr float MAP_SCALE_MULTIPLY_OK{ 1000.0f };
}

ImVec2 radar::entToRadar(const Vec3& eye, const Vec3& angles, const Vec3& entPos, const float scale, bool clipRanges)
{
	float dotThickness = vars::misc->radar->thickness;

	float directionX = entPos[Coord::X] - eye[Coord::X];
	float directionY = -(entPos[Coord::Y] - eye[Coord::Y]);

	const auto yawDeg = angles[Coord::Y] - 90.0f;
	// calculate dots of radian and return correct view
	const auto yawToRadian = math::DEG2RAD(yawDeg);
	const auto cosine = std::cos(yawToRadian);
	const auto sine = std::sin(yawToRadian);
	// this 20 is a magic scaling value, it seems to be the best and without need as configurable
	// game also does hardcoded scaling
	// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/cstrike15/Scaleform/HUD/sfhudradar.cpp#L184
	float dotX = (directionX * cosine - directionY * sine) / 20.0f;
	float dotY = (directionX * sine + directionY * cosine) / 20.0f;
	dotX *= scale;
	dotY *= scale;

	const auto size = ImGui::GetWindowSize();

	// correct it for our center screen of rectangle radar
	dotX += size.x / 2.0f;
	dotY += size.y / 2.0f;

	// do not draw out of range, added pos, even we pass 0, but for clarity
	if (clipRanges && vars::misc->radar->ranges)
	{
		dotX = std::clamp(dotX, dotThickness, size.x - dotThickness);
		dotY = std::clamp(dotY, dotThickness, size.y - dotThickness);
	}

	const auto pos = ImGui::GetWindowPos();
	dotX += pos.x;
	dotY += pos.y;

	return ImVec2{ dotX, dotY };
}

void radar::manuallyInitPos()
{
	if (!game::isAvailable())
		return;

	const auto map = memory::Address<MapStruct*>{ game::findHudElement("CCSGO_MapOverview") }.sub(0x14);
	mapInfo.pos = map->m_origin;
	mapInfo.scale = map->m_scale * MAP_SCALE_MULTIPLY_OK;

	inited = true;
}

bool radar::manuallyInitTexture()
{
	if (!game::isAvailable())
		return false;

	std::string levelName = memory::interfaces::engine->getLevelName();

	// not really working for workshops
	if (const auto place = levelName.rfind('/'); place != std::string::npos)
		levelName = levelName.substr(place + 1, levelName.size());

	const std::string path = std::format("csgo\\resource\\overviews\\{}_radar.dds", levelName);

	if (auto hr = D3DXCreateTextureFromFileA(memory::interfaces::dx9Device(), path.c_str(), &mapTexture); hr == D3D_OK)
		console::info("Created map texture from path: {}", path);
	else
	{
		console::error("Creating map texture from path failed, code: {}", hr);
		return false;
	}

	return true;
}

void radar::drawMap()
{
	if (!inited)
		manuallyInitPos();

	// square
	const auto size = mapInfo.scale;
	const auto pos = mapInfo.pos;
	const std::array poses =
	{
		Vec3{ pos[Coord::X], pos[Coord::Y], 0.0f },
		Vec3{ pos[Coord::X] + size, pos[Coord::Y], 0.0f },
		Vec3{ pos[Coord::X] + size, pos[Coord::Y] - size, 0.0f },
		Vec3{ pos[Coord::X], pos[Coord::Y] - size, 0.0f },
	};

	const auto myEye = game::localPlayer->getEyePos();
	const auto ang = game::getViewAngles();
	const float scale = vars::misc->radar->scale;

	auto p1 = entToRadar(myEye, ang, poses.at(0), scale, false);
	auto p2 = entToRadar(myEye, ang, poses.at(1), scale, false);
	auto p3 = entToRadar(myEye, ang, poses.at(2), scale, false);
	auto p4 = entToRadar(myEye, ang, poses.at(3), scale, false);

	ImGui::GetWindowDrawList()->AddImageQuad(mapTexture, p1, p2, p3, p4);
}

void radar::draw()
{
	if (!vars::misc->radar->enabled)
		return;

	if (!game::localPlayer)
		return;

	if (!memory::interfaces::engine->isInGame())
		return;

	// force square sized window
	const auto maxSize = std::max(globals::screenX, globals::screenY);
	ImGui::SetNextWindowSizeConstraints(ImVec2{ 100.0f, 100.0f }, ImVec2{ static_cast<float>(maxSize), static_cast<float>(maxSize) },
		[](ImGuiSizeCallbackData* data) { data->DesiredSize.x = data->DesiredSize.y; });
	if (ImGui::Begin("Radar", &vars::misc->radar->enabled, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar))
	{
		const auto windowList = ImGui::GetWindowDrawList();
		const auto windowPos = ImGui::GetWindowPos();
		const auto windowSize = ImGui::GetWindowSize();

		const float middleX = windowSize.x / 2.0f;
		const float middleY = windowSize.y / 2.0f;

		drawMap();

		// draw small circle where are we
		drawing::CircleFilled{ 
			ImVec2{ windowPos.x + middleX, windowPos.y + middleY },
			5.0f, 12, Color::U32(Colors::Green) }.draw(windowList);

		const auto myEye = game::localPlayer->getEyePos();
		Vec3 viewAngle = game::getViewAngles();

		for(auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
		{
			auto ent = reinterpret_cast<Player_t*>(entity);

			if (!ent)
				continue;

			if (ent->isDormant())
				continue;

			if (ent == game::localPlayer)
				continue;

			if (!ent->isAlive() || !game::localPlayer->isAlive())
				continue;

			if (!ent->isOtherTeam(game::localPlayer()))
				continue;

			const auto entRotatedPos = entToRadar(myEye, viewAngle, ent->absOrigin(),
				vars::misc->radar->scale, true);

			const auto entYaw = math::normalizeYaw(ent->m_angEyeAngles()[Coord::Y]);

			// or use atan2 if 270 is magic for you
			const auto rotated = 270.0f - entYaw + viewAngle[Coord::Y];
			const auto dotRad = vars::misc->radar->length;

			const auto finalX = dotRad * std::cos(math::DEG2RAD(rotated));
			const auto finalY = dotRad * std::sin(math::DEG2RAD(rotated));

			const bool isZeroEnt = vars::misc->radar->ranges ? true : entRotatedPos.x != 0.0f && entRotatedPos.y != 0.0f;
			if (!isZeroEnt)
				return;

			if (vars::misc->radar->mode == E2T(RadarMode::TRIANGLE))
			{
				const auto dotThickness = vars::misc->radar->thickness;
				const float radian = math::DEG2RAD(rotated);
				const float radian90 = math::DEG2RAD(rotated + 90);

				const ImVec2 p1 = ImVec2{ (dotThickness / 2.0f) * std::cos(radian90) + entRotatedPos.x, (dotThickness / 2.0f) * std::sin(radian90) + entRotatedPos.y };
				const ImVec2 p2 = ImVec2{ (-dotThickness / 2.0f) * std::cos(radian90) + entRotatedPos.x, (-dotThickness / 2.0f) * std::sin(radian90) + entRotatedPos.y };
				const ImVec2 p3 = ImVec2{ dotThickness * std::cos(radian) + entRotatedPos.x, dotThickness * std::sin(radian) + entRotatedPos.y };
				drawing::TriangleFilled{ p1, p2, p3, Color::U32(vars::misc->radar->colorPlayer()) }.draw(windowList);
			}
			else if (vars::misc->radar->mode == E2T(RadarMode::CIRCLE))
			{
				const auto dotThickness = vars::misc->radar->thickness;
				const float radian = math::DEG2RAD(rotated);

				// we use p3 as a reference to triangles because we need optimal start where to draw based on enemy angles
				const ImVec2 p3 = ImVec2{ dotThickness * std::cos(radian) + entRotatedPos.x, dotThickness * std::sin(radian) + entRotatedPos.y };

				drawing::CircleFilled{ entRotatedPos, dotThickness, 32, Color::U32(vars::misc->radar->colorPlayer()) }.draw(windowList);
				drawing::Line{ p3, { p3.x + finalX, p3.y + finalY }, Color::U32(vars::misc->radar->colorLine()), 1.0f }.draw(windowList);
			}
		}
		
		ImGui::End();
	}
}

// important to call this after hook return
void radar::gatherMap(MapStruct* map)
{
	mapInfo.pos = map->m_origin;
	mapInfo.scale = map->m_scale * MAP_SCALE_MULTIPLY_OK;

	inited = true;
}

```

`hack/cheats/features/visuals/radar/radar.hpp`:

```hpp
#pragma once

struct MapStruct;
struct IDirect3DTexture9;

// texture - https://www.unknowncheats.me/forum/counterstrike-global-offensive/317765-getting-map-overview-information-textured-radar.html
namespace radar
{
	void draw();
	bool manuallyInitTexture();
	void gatherMap(MapStruct* map);

	inline IDirect3DTexture9* mapTexture{ nullptr };
};

```

`hack/cheats/features/visuals/streamproof/streamproof.cpp`:

```cpp
#include "streamproof.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <SDK/ITexture.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include <cheats/game/globals.hpp>
#include <utilities/console/console.hpp>
#include <config/vars.hpp>

// we create an extra backbuffer to set our render target to it
void StreamProof::init()
{
	const auto backBuffer = memory::interfaces::matSys->getBackBufferFormat();
	memory::interfaces::matSys->beginRenderTargetAllocationEx();
	renderTarget = memory::interfaces::matSys->createNamedRenderTargetTextureEx(
		targetName.data(), 1, 1, RT_SIZE_FULL_FRAME_BUFFER,
		backBuffer, MATERIAL_RT_DEPTH_SHARED,
		TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT,
		CREATERENDERTARGETFLAGS_HDR);
	memory::interfaces::matSys->endRenderTargetAllocationEx();

	console::debug("loaded streamproof texture {}", targetName);
}

void StreamProof::shutdown()
{
	if (renderTarget)
		renderTarget->release();
}

// here, we render this backbuffer texture
// srcBlend is usually D3DBLEND_SRCCOLOR correct
void StreamProof::beginPresent(IDirect3DDevice9* device, _D3DBLEND srcBlend)
{
	std::lock_guard lock{ mutex };

	if (!active)
		return;

	if (!renderTarget)
		return;

	const auto texture = getGameTexture();
	if (!texture)
	{
#ifdef _DEBUG
		printf("couldn't find texture\n");
#endif
		return;
	}

	IDirect3DSurface9* backbuffer{ };
	D3DSURFACE_DESC desc{ };
	device->GetRenderTarget(0, &backbuffer);
	backbuffer->GetDesc(&desc);

	// full sceenspace vertex resource
	const CUSTOMVERTEX vertexArray[]
	{
		{ 0.f, 0.f, 0.f, 1.0f, 0.f, 0.f }, // top-left vertex
		{ static_cast<float>(desc.Width), 0.0f, 0.0f, 1.0f, 1.0f, 0.0f }, // top-right vertex
		{ 0.0f, static_cast<float>(desc.Height), 0.0f, 1.0f, 0.0f, 1.0f }, // bottom-left vertex
		{ static_cast<float>(desc.Width), static_cast<float>(desc.Height), 0.0f, 1.0f, 1.0f, 1.0f } // bottom-right vertex
	};

	IDirect3DVertexBuffer9* vertexBuffer{ };
	// CUSTOMVERTEX is xyzrhw, and we have only 1 texture
	constexpr auto dxFVF{ D3DFVF_XYZRHW | D3DFVF_TEX1 };
	device->CreateVertexBuffer(sizeof(vertexArray), D3DUSAGE_WRITEONLY, dxFVF, D3DPOOL_DEFAULT, &vertexBuffer, nullptr);

	void* verticesData{ nullptr };
	vertexBuffer->Lock(0, 0, &verticesData, 0);
	std::memcpy(verticesData, vertexArray, sizeof(vertexArray));
	vertexBuffer->Unlock();

	// be careful with those flags, as you can see we don't clear anything. We let the game do that.
	device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	device->SetRenderState(D3DRS_SRCBLEND, srcBlend);
	device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCCOLOR);
	//device->SetRenderState(D3DRS_ZENABLE, TRUE); // does not sync to texture

	// set this extra backbuffer texture to draw
	device->SetTexture(0, texture);

	device->SetFVF(dxFVF);
	device->SetStreamSource(0, vertexBuffer, 0, sizeof(CUSTOMVERTEX));

	device->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
}

void StreamProof::endPresent()
{
	std::lock_guard lock{ mutex };

	if (!active)
		return;

	if (!renderTarget)
		return;

	// overriding depth may lead to fatal errors
	renderGameContext = memory::interfaces::matSys->getRenderContext();
	renderGameContext->pushRenderTargetAndViewport();
	renderGameContext->setRenderTarget(renderTarget);
	renderGameContext->clearColor4ub(0, 0, 0, 255); // color clears weird, looks like some var is not used for depth
	renderGameContext->clearBuffers(true, true, true); // may crash on other vars
	renderGameContext->popRenderTargetAndViewport();
	renderGameContext->release();
}

// here we tell the game to use our render target during the drawing proccess
void StreamProof::beginMaterialHook()
{
	if (!active)
		return;

	if (!renderTarget)
		return;

	mutex.lock();

	renderGameContext = memory::interfaces::matSys->getRenderContext();
	renderGameContext->pushRenderTargetAndViewport();
	renderGameContext->setRenderTarget(renderTarget);
}

// here we tell the game to manually backup our render target, so we don't have artifacts
void StreamProof::endMaterialHook()
{
	if (!active)
		return;

	if (!renderTarget)
		return;

	renderGameContext->popRenderTargetAndViewport();
	renderGameContext->release();

	mutex.unlock();
}

IDirect3DTexture9* StreamProof::getGameTexture() const
{
	return renderTarget->m_handle[0]->m_texture;
}
```

`hack/cheats/features/visuals/streamproof/streamproof.hpp`:

```hpp
#pragma once

#include <d3d9.h>
#include <SDK/IMatRenderContext.hpp>

#include <mutex>
#include <string_view>
#include <functional>

// works somewhat, but not really as game wants to
// I leave this for anyone who reads this to spend their pain on game's mesh builders queue'd rendering
// if you want to use this for surface - don't, you will cause massive threading deadlocks
// TODO: add handlers, this is currently all manual
class StreamProof final
{
public:
	StreamProof() = default;
	// target name better be unique
	StreamProof(const std::string_view targetName)
		: targetName{ targetName }
	{}

	// run in game thread once
	void init();
	void shutdown();
	// force texture draw in the present
	void beginPresent(IDirect3DDevice9* device, _D3DBLEND srcBlend);
	// cleanup with game's functions
	void endPresent();
	// before any render
	void beginMaterialHook();
	// after any render
	// "any" can be used in mixed scenario as:
	// 1. only game calls drawModel() and we want to proof it
	// 2. game + us, this happens in the glow
	void endMaterialHook();
	void setActive(const bool var) { active = var; }

	ITexture* getRenderTarget() const { return renderTarget; }
	IDirect3DTexture9* getGameTexture() const;
private:
	struct CUSTOMVERTEX
	{
		FLOAT x, y, z; // position coordinates
		FLOAT rhw; // reciprocal of homogeneous W
		// D3DCOLOR color; // vertex color
		FLOAT tu, tv; // texture coordinates
	};

	bool active{ };
	std::mutex mutex{ };
	std::string_view targetName{ };
	IMatRenderContext* renderGameContext{ };
	ITexture* renderTarget{ };
};
```

`hack/cheats/features/visuals/tracer/tracer.cpp`:

```cpp
#include "tracer.hpp"

#include "../../events/events.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/IViewRenderBeams.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/clientHitVerify.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/utilities.hpp>
#include <menu/GUI-ImGui/selections.hpp>

#include <ranges>

#include "../misc/bulletUpdater.hpp"

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct BulletTracerHandler : hooks::PaintTraverse
	{
		BulletTracerHandler()
		{
			this->registerRender(bulletTracer::draw);
		}
	} bulletHandler;
}

void bulletTracer::draw()
{
	if (!vars::visuals->world->tracer->enabled)
		return;

	if (!game::isAvailable())
		return;

	if (!game::localPlayer->isAlive())
		return;

	const auto lastbullets = bulletUpdater::getLastBullets();
	if (lastbullets.empty())
		return;

	CfgBeam cfgbeam = vars::visuals->world->tracer->beamTracer;

	const Vec3 correctEnd = lastbullets.size() == 2 ? lastbullets.back() : lastbullets.front();
	const Vec3 src{ game::localPlayer->getEyePos() };

	BeamInfo_t info{ };
	info.m_type = TE_BEAMPOINTS;
	info.m_flags = utilities::convertStringToFlag(cfgbeam.flags);
	info.m_modelName = selections::beamNames.at(cfgbeam.index);
	info.m_modelIndex = -1;
	info.m_haloIndex = -1;
	info.m_haloScale = 0.0f;
	info.m_life = cfgbeam.life;
	info.m_width = cfgbeam.width;
	info.m_endWidth = cfgbeam.width;
	info.m_fadeLength = cfgbeam.fadeLength;
	info.m_amplitude = cfgbeam.amplitude;
	info.m_red = cfgbeam.color().rMultiplied();
	info.m_green = cfgbeam.color().gMultiplied();
	info.m_blue = cfgbeam.color().bMultiplied();
	info.m_brightness = cfgbeam.color().aMultiplied();
	info.m_speed = cfgbeam.speed;
	info.m_startFrame = static_cast<int>(cfgbeam.startFrame);
	info.m_frameRate = cfgbeam.frameRate;
	info.m_vecStart = src;
	info.m_vecEnd = correctEnd;
	info.m_segments = cfgbeam.segments;
	info.m_renderable = true;

	memory::interfaces::beams->createBeamPoints(info);
}
```

`hack/cheats/features/visuals/tracer/tracer.hpp`:

```hpp
#pragma once

namespace bulletTracer
{
	void draw();
}

```

`hack/cheats/features/visuals/world/ambient.cpp`:

```cpp
#include "ambient.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/Enums.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <utilities/tools/tools.hpp>
#include <config/vars.hpp>
#include <cheats/game/globals.hpp>

#include <cheats/hooks/frameStageNotify.hpp>

namespace
{
	struct AmbientHandler : hooks::FrameStageNotify
	{
		AmbientHandler()
		{
			this->registerInit(ambientLight::init);
			this->registerRun(ambientLight::run);
			this->registerShutdown(ambientLight::shutdown);
		}
	} ambientHandler;
}

namespace ambientLight
{
	IConVar* ambientR;
	IConVar* ambientG;
	IConVar* ambientB;
}

// C7 44 24 ? ? ? ? ? 8B 84 24 ? ? ? ? in sdsshader_dx9 looks to be an array of those
void ambientLight::init()
{
	ambientR = memory::interfaces::cvar->findVar("mat_ambient_light_r");
	ambientG = memory::interfaces::cvar->findVar("mat_ambient_light_g");
	ambientB = memory::interfaces::cvar->findVar("mat_ambient_light_b");
}

void ambientLight::run(FrameStage stage)
{
	if (stage != FRAME_RENDER_START)
		return;

	// cant use env from memory, it wont differ just by changing fields

	if (auto cfg = vars::visuals->world->ambient->enabled; cfg && (buttonState || pickerState))
	{
		auto cfgCol = vars::visuals->world->ambient->color();

		ambientR->setValue(cfgCol.r());
		ambientG->setValue(cfgCol.g());
		ambientB->setValue(cfgCol.b());

	}
	else if (!cfg && buttonState)
	{
		ambientR->setValue(0.0f);
		ambientG->setValue(0.0f);
		ambientB->setValue(0.0f);
	}
}

void ambientLight::shutdown()
{
	ambientR->setValue(0.0f);
	ambientG->setValue(0.0f);
	ambientB->setValue(0.0f);
}
```

`hack/cheats/features/visuals/world/ambient.hpp`:

```hpp
#pragma once

enum FrameStage;

namespace ambientLight
{
	void run(FrameStage stage);
	void init();
	void shutdown();

	inline bool buttonState{ false };
	inline bool pickerState{ false };
}
```

`hack/cheats/features/visuals/world/bomb.cpp`:

```cpp
#include "bomb.hpp"

#include "../../events/events.hpp"
#include "../../cache/cache.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IEffects.hpp>
#include <SDK/Enums.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/IBaseClientDll.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>

#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>

#include <cheats/hooks/present.hpp>
#include <cheats/hooks/frameStageNotify.hpp>
#include <cheats/hooks/unkownRoundEnd.hpp>
#include <cheats/hooks/clientModeCSNormalEvent.hpp>

namespace
{
	struct BombDrawer : hooks::Present
	{
		BombDrawer()
		{
			this->registerRun(bombOverlay::draw);
		}
	} bombDrawer;

	struct BombEntHandler : hooks::FrameStageNotify
	{
		BombEntHandler()
		{
			this->registerInit(bombOverlay::init);
			this->registerRun(bombOverlay::run);
		}
	} bombEntHandler;

	struct BombReset : hooks::UnknownRoundEnd
	{
		BombReset()
		{
			this->registerRun(bombOverlay::roundRestart);
		}
	} bombReset;

	struct BombEvent : hooks::ClientModeCSNormalEvent
	{
		BombEvent()
		{
			this->registerEvent(bombOverlay::handleWhoPlanted);
		}
	} bombEvent;
}

namespace bombOverlay
{
	Bomb_t* bombEnt{ };
	IConVar* c4Timer{ };
	std::string whoPlanted{ };
}

void bombOverlay::init()
{
	c4Timer = memory::interfaces::cvar->findVar("mp_c4timer");

	//events::add("bomb_planted", std::bind(&handleWhoPlanted, std::placeholders::_1));
}

void bombOverlay::roundRestart()
{
	bombEnt = nullptr;
}

void bombOverlay::draw()
{
	if (!game::isAvailable())
		bombEnt = nullptr;

	if (!bombEnt)
		return;

	if (!vars::visuals->world->bomb->enabled)
		return;

	const auto bombent = reinterpret_cast<Bomb_t*>(bombEnt);
	const auto bombtime = bombent->m_flC4Blow() - memory::interfaces::globalVars->m_curtime;
	const auto defusetime = bombEnt->m_flDefuseCountDown() - memory::interfaces::globalVars->m_curtime;
	auto ent = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientFromHandle(bombEnt->m_hBombDefuser()));
	const auto defuseMaxTime = ent && ent->m_bHasDefuser() ? 5.0f : 10.0f; // check ent too

	if (bombtime < 0.0f || bombent->m_bBombDefused())
	{
		bombEnt = nullptr;
		return;
	}

	// https://www.unknowncheats.me/forum/counterstrike-global-offensive/389530-bomb-damage-indicator.html
	constexpr float bombRadius = 500.0f; // there is no info for this, run some map scanner
	constexpr float sigma = (bombRadius * 3.5f) / 3.0f;
	const auto bombEyeEye = bombEnt->m_vecOrigin() + bombEnt->m_ViewOffset();
	const float hypDist = (bombEyeEye - game::localPlayer->getEyePos()).length();
	const float dmg = game::scaleDamageArmor((bombRadius * (std::exp(-hypDist * hypDist / (2.0f * sigma * sigma)))), static_cast<float>(game::localPlayer->m_ArmorValue()));
	const bool isSafe = dmg < game::localPlayer->m_iHealth();

	float scaled = bombEnt->m_hBombDefuser().isValid() ? (defusetime / defuseMaxTime) : (bombtime / c4Timer->getFloat());

	float fdef = defusetime / defuseMaxTime;
	float fbomb = bombtime / c4Timer->getFloat();
	float forRed = bombEnt->m_hBombDefuser().isValid() ? fdef : fbomb;
	float forGreen = bombEnt->m_hBombDefuser().isValid() ? fdef : fbomb;

	float r = (1.0f - forRed);
	Color color{ r, forGreen, 0.0f, 0.8f };

	ImGui::SetNextWindowSize({ 300.0f, 150.0f });
	ImGui::PushStyleColor(ImGuiCol_WindowBg, Color::U32(vars::visuals->world->bomb->background()));
	if (ImGui::Begin("Bomb c4", &vars::visuals->world->bomb->enabled, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize))
	{
		const auto size = ImGui::GetWindowSize();
		const auto pos = ImGui::GetWindowPos();
		const auto draw = ImGui::GetWindowDrawList();

		constexpr float minAngle = -90.0f;
		const float maxAngle = math::RAD2DEG(math::PI * 2.0f * scaled) + minAngle;

		const float scaledRadius = std::min(size.x, size.y) / 4.0f;
		const auto xCircle = (size.x - scaledRadius) * 0.95f;
		const auto yCircle = size.y / 2.0f;

		drawing::Arc{ ImVec2{ pos.x + xCircle, pos.y + yCircle }, scaledRadius, math::DEG2RAD(minAngle), math::DEG2RAD(maxAngle), 32, Color::U32(color), 0, 5.0f }.draw(draw);
		const auto text = defusetime > bombtime ? "Too late" : std::format("{:.2f}", bombEnt->m_hBombDefuser().isValid() ? defusetime : bombtime);
		drawing::Text{ ImRender::fonts::tahoma14, ImVec2{ pos.x + xCircle, pos.y + yCircle - ImRender::fonts::tahoma14->FontSize / 2.0f },
			Color::U32(Colors::White), text, false, true }.draw(draw);

		const auto icon = game::getWeaponIcon("weapon_c4");
		drawing::Image{ icon.texture, ImVec2{ pos.x + 5.0f, pos.y + 5.0f }, ImVec2{ pos.x + 5.0f + 30.0f, pos.y + 5.0f + 40.0f },
			ImVec2{ 0.0f, 0.0f }, ImVec2{ 1.0f, 1.0f }, Color::U32(Colors::White) }.draw(draw);

		float yPosInfo = pos.y + size.y / 2.0f;

		if (!whoPlanted.empty())
		{
			drawing::Text{ ImRender::fonts::tahoma20, ImVec2{ pos.x + 5.0f, yPosInfo }, Color::U32(Colors::White),
			std::format("Planted by {}s", whoPlanted), false, false }.draw(draw);
			yPosInfo -= ImRender::fonts::tahoma20->FontSize;
		}
		if (bombEnt->m_hBombDefuser().isValid())
		{
			drawing::Text{ ImRender::fonts::tahoma20, ImVec2{ pos.x + 5.0f, yPosInfo }, Color::U32(Colors::White),
			std::format("Defusing {}", ent->getName()), false, false }.draw(draw);
			yPosInfo -= ImRender::fonts::tahoma20->FontSize;
		}

		float yCentreInfo = pos.y + 2.0f + ImRender::fonts::tahoma20->FontSize;
		drawing::Text{ ImRender::fonts::tahoma20, ImVec2{ pos.x + size.x / 2.0f, yCentreInfo }, Color::U32(Colors::White), std::format("Site {}",
			bombEnt->getBombSiteName()), false, true }.draw(draw);
		yCentreInfo += ImRender::fonts::tahoma20->FontSize;
		drawing::Text{ ImRender::fonts::tahoma20, ImVec2{ pos.x + size.x / 2.0f, yCentreInfo }, Color::U32(isSafe ? Colors::Green : Colors::Red),
			std::format("Damage {:.2f}", dmg), false, true }.draw(draw);

		ImGui::End();
	}
	ImGui::PopStyleColor();
}

void bombOverlay::handleWhoPlanted(IGameEvent* event)
{
	if (std::string_view{ event->getName() } != "bomb_planted")
		return;

	auto who = reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(event->getInt("userid"))));
	if (!who)
		return;

	whoPlanted = who->getName();
}

void bombOverlay::run(FrameStage stage)
{
	if (stage != FRAME_RENDER_START)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::WORLD_ENTS))
	{
		if (classID != CPlantedC4)
			continue;

		bombEnt = reinterpret_cast<Bomb_t*>(entity);
	}
}
```

`hack/cheats/features/visuals/world/bomb.hpp`:

```hpp
#pragma once

enum FrameStage;
class IGameEvent;

namespace bombOverlay
{
	void run(FrameStage stage);
	void draw();
	void init();
	void roundRestart();
	void handleWhoPlanted(IGameEvent* _event);
}
```

`hack/cheats/features/visuals/world/dropped.cpp`:

```cpp
#include "dropped.hpp"

#include "../../cache/cache.hpp"

#include <SDK/ILocalize.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/render.hpp>
#include <utilities/utilities.hpp>
#include <cheats/features/visuals/player/boxes.hpp>

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct DroppedHandler : hooks::PaintTraverse
	{
		DroppedHandler()
		{
			this->registerRender(dropped::draw);
		}
	} droppedHandler;
}

void dropped::draw()
{
	if (!vars::visuals->esp->dropped->enabled)
		return;
	
	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::WEAPON))
	{
		auto wpn = reinterpret_cast<Weapon_t*>(entity);
		if (!wpn)
			continue;

		auto handle = memory::interfaces::entList->getClientFromHandle(wpn->m_hOwnerEntity());
		if (handle)
			continue;

		Box box{ entity };
		if (!box.isValid())
			continue;
	
		const float fontSize = game::getScaledFont(entity->absOrigin(), game::localPlayer()->absOrigin(), 60.0f, 11.0f, 16.0f);
		float padding = 0.0f;

		constexpr float maxDist = 25.0f;
		const float alpha = (maxDist - entity->absOrigin().distToMeters(game::localPlayer->absOrigin())) / (maxDist / 1.5f);

		if (alpha < 0.0f)
			continue;

		auto getTextSize = [=](const std::string& text, ImFont* font = ImRender::fonts::verdana12)
		{
			return font->CalcTextSizeA(fontSize, std::numeric_limits<float>::max(), 0.0f, text.c_str());
		};

		const auto flags = vars::visuals->esp->dropped->flags;

		if (flags.at(E2T(DroppedFlags::BOX))) // startpoint - no pad
		{
			auto cfg = vars::visuals->esp->dropped->box;

			if (cfg.mode == E2T(BoxTypes::BOX2D))
			{
				const bool outlined = cfg.outline;

				if (outlined)
				{
					boxes::drawInnerOutline(box, alpha);
					boxes::drawOuterOutline(box, alpha);
				}

				boxes::drawRect(box, cfg.color.getColor(), alpha);
			}
			else if (cfg.mode == E2T(BoxTypes::FILLED2D))
			{
				const bool outlined = cfg.outline;
				const bool gradient = cfg.gradient;

				const std::array allAlphasGradient
				{
					cfg.gradientCol1().a(),
					cfg.gradientCol2().a(),
					cfg.gradientCol3().a(),
					cfg.gradientCol4().a(),
					alpha
				};

				const float filledAlpha = *std::ranges::min_element(allAlphasGradient);
				if (gradient)
				{
					ImRender::drawRectFilledMultiColor(box.x, box.y, box.w, box.h,
						cfg.gradientCol1().getColorEditAlpha(filledAlpha),
						cfg.gradientCol2().getColorEditAlpha(filledAlpha),
						cfg.gradientCol3().getColorEditAlpha(filledAlpha),
						cfg.gradientCol4().getColorEditAlpha(filledAlpha));
				}
				else
					boxes::drawRectFilled(box, cfg.fill(), std::min(alpha, cfg.fill().a()));

				if (outlined)
				{
					boxes::drawOuterOutline(box, alpha);
				}
			}
			else if (cfg.mode == E2T(BoxTypes::BOX3D))
			{
				boxes::drawBox3D(box, cfg.color(), alpha);
			}
			else if (cfg.mode == E2T(BoxTypes::FILLED3D))
			{
				boxes::drawBoxFilled3D(box, cfg.fill(), std::min(alpha, cfg.fill().a()));
				boxes::drawBox3D(box, cfg.fill(), alpha);
			}
		}
		if (flags.at(E2T(DroppedFlags::AMMO)) && !wpn->isNonAimable()) // no pad font logic, we just draw extra box
		{
			constexpr float startPad = 3.0f;

			ImRender::drawRectFilled(box.x - 1.0f, box.y + box.h - 1.0f + startPad, box.w + 2.0f, 4.0f, Colors::Black.getColorEditAlpha(alpha));
			ImRender::drawRectFilled(box.x, box.y + box.h + startPad,
				wpn->m_iClip1() * box.w / wpn->getWpnInfo()->m_maxClip1, 2.0f, vars::visuals->esp->dropped->ammoColor().getColorEditAlpha(alpha));

			padding += 4.0f;
		}
		if (flags.at(E2T(DroppedFlags::TEXT)))
		{
			const auto name = vars::visuals->esp->weaponBar->translate
				? memory::interfaces::localize->findAsUTF8(wpn->getWpnInfo()->m_WeaponName)
				: wpn->getWpnName();
			ImRender::text(box.x + box.w / 2, box.y + box.h + 2 + padding, fontSize, ImRender::fonts::verdana12,
				name, true, vars::visuals->esp->dropped->textColor().getColorEditAlpha(alpha));

			auto textSize = getTextSize(name);
			padding += textSize.y;
		}
		if (flags.at(E2T(DroppedFlags::ICON)))
		{
			const auto iconData = game::getWeaponIcon(wpn->getWpnInfo()->m_consoleName);
			
			// I couldnt find in panorama scaling arguments passed by, it's usually -1.0f for them?
			auto goodSize = ImVec2{ iconData.width, iconData.height };
			goodSize = wpn->isGrenade() ? ImVec2{ 8.0f, 12.0f } : ImVec2{ 22.0f, 14.0f };

			ImRender::drawImage(iconData.texture, ImVec2{ box.x + box.w / 2, box.y + box.h + 2 + padding },
				goodSize, vars::visuals->esp->dropped->iconColor().getColorEditAlpha(alpha));

			padding += goodSize.y;
		}
	}
}

```

`hack/cheats/features/visuals/world/dropped.hpp`:

```hpp
#pragma once

namespace dropped
{
	void draw();
}

```

`hack/cheats/features/visuals/world/fog.cpp`:

```cpp
#include "fog.hpp"

#include "../../cache/cache.hpp"

#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>

#include <cheats/hooks/frameStageNotify.hpp>

namespace
{
	struct FogHandler : hooks::FrameStageNotify
	{
		FogHandler()
		{
			this->registerRun(fogController::run);
			this->registerShutdown(fogController::shutdown);
		}
	} fogHandler;
}

namespace fogController
{
	FogController_t* ent;
}

static constexpr uint32_t U32RGB(const SDKColor& clr)
{
	return (clr.r & 0x0FF) | ((clr.g & 0x0FF) << 8) | ((clr.b & 0x0FF) << 16);
}

void fogController::run(FrameStage stage)
{
	if (stage != FRAME_RENDER_START)
		return;

	if (!game::isAvailable())
		return;

	ent = memory::interfaces::fogController();
	if (!ent) // not all maps support it by default
		return;

	if (vars::visuals->world->fog->enabled)
		ent->m_fogenable() = true;
	else
	{
		ent->m_fogenable() = false;
		
		return;
	}

	const SDKColor col = vars::visuals->world->fog->color();

	ent->m_fogstart() = 0.0f;
	ent->m_fogend() = vars::visuals->world->fog->distance * 10.0f;
	ent->m_fogmaxdensity() = col.a / 100.0f;
	ent->m_fogcolorPrimary() = U32RGB(col);
	ent->m_fogcolorSecondary() = U32RGB(col);
}

void fogController::shutdown()
{
	if (!ent)
		return;

	ent->m_fogenable() = false;
}
```

`hack/cheats/features/visuals/world/fog.hpp`:

```hpp
#pragma once

enum FrameStage;

namespace fogController
{
	void run(FrameStage stage);
	void shutdown();
}

```

`hack/cheats/features/visuals/world/impacts.cpp`:

```cpp
#include "impacts.hpp"

#include "../../events/events.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/IGameEvent.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/clientHitVerify.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>

#include "../misc/bulletUpdater.hpp"

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct BulletImpactHandler : hooks::PaintTraverse
	{
		BulletImpactHandler()
		{
			this->registerRender(bulletImpacts::draw);
		}
	} bulletImpactHandler;
}

namespace bulletImpacts
{
	struct HitStruct_t
	{
		Vec3 pos{ };
		float expire{ };
	};

	std::vector<HitStruct_t> hits{ };
}

void bulletImpacts::draw()
{
    if (!vars::visuals->world->impacts->enabledClient)
    {
        if (!hits.empty())
            hits.clear();
        return;
    }

    if (!game::isAvailable())
        return;

    for (const auto& el : bulletUpdater::getLastBullets())
    {
        hits.emplace_back(HitStruct_t
            {
                el,
                memory::interfaces::globalVars->m_curtime + vars::visuals->world->impacts->timeClient
            });
    }

    const Color outline = vars::visuals->world->impacts->colorClient();
    const Color fill = vars::visuals->world->impacts->colorClientFill();

    for (size_t i = 0; const auto [pos, expire] : hits)
    {
        float diff = expire - memory::interfaces::globalVars->m_curtime;

        if (diff < 0.0f)
        {
            hits.erase(hits.begin() + i);
            continue;
        }

        ImRender::drawBox3DFilled(pos, 4.0f, 4.0f, outline, fill);

        ++i;
    }
}

```

`hack/cheats/features/visuals/world/impacts.hpp`:

```hpp
#pragma once

namespace bulletImpacts
{
	void draw();
}

```

`hack/cheats/features/visuals/world/lights.cpp`:

```cpp
#include "lights.hpp"

#include <SDK/CCommonHostState.hpp>
#include <SDK/IVEffects.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/material.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include <cheats/game/game.hpp>
#include <config/vars.hpp>

#include <cheats/hooks/frameStageNotify.hpp>
#include <cheats/hooks/levelInitPostEnttity.hpp>

namespace
{
	struct LightsHandler : hooks::FrameStageNotify
	{
		LightsHandler()
		{
			this->registerInit(lights::init);
			this->registerRun(lights::run);
			this->registerShutdown(lights::shutdown);
		}
	} lightsHandler;

	struct LightReset : hooks::LevelInitPostEntity
	{
		LightReset()
		{
			this->registerPostReset(lights::postReset);
		}
	} lightReset;
}

namespace lights
{
	std::vector<Vec3> savedColors{ };
	IConVar* r_decals{ };
}

void lights::init()
{
	r_decals = memory::interfaces::cvar->findVar("r_decals");
}

void lights::run(FrameStage stage)
{
	if (stage != FRAME_RENDER_START)
		return;

	if (!game::isAvailable())
		return;

	if (savedColors.empty())
		postReset();

	for (int i = 0; i < memory::interfaces::hostState()->worldbrush.numworldlights; ++i)
	{
		dworldlight_t* light = &memory::interfaces::hostState()->worldbrush.worldlights[i];
		const emittype_t type = light->type;

		if (!vars::visuals->world->modulate->enabledLights.at(type))
			continue;
	
		light->intensity = Vec3{ vars::visuals->world->modulate->lights.at(type)().getRGB()} *vars::visuals->world->modulate->lightsStrenght.at(type);
	}

	const int maxDecals = std::max(64, r_decals->getInt());
	int counter = 0;

	/*for (int i = 0; i < maxDecals; ++i)
	{
		decal_t* decal = memory::decalPool()[i];

		if (decal)
		{
			if (decal->material)
			{
				const std::string_view name = decal->material->getName();
				if (name.contains("blood"))
					printf("colors [%i %i %i %i]\n", decal->color.r, decal->color.g, decal->color.b, decal->color.a);

				printf("decal material name %s\n", name.data());
			}
		}
	}*/
}

void lights::postReset()
{
	savedColors.clear();

	for (int i = 0; i < memory::interfaces::hostState->worldbrush.numworldlights; ++i)
	{
		dworldlight_t* light = &memory::interfaces::hostState->worldbrush.worldlights[i];
		const emittype_t type = light->type;

		savedColors.emplace_back(light->intensity);
	}
}

void lights::forceReset()
{
	if (!game::isAvailable())
		return;

	for (int i = 0; i < memory::interfaces::hostState->worldbrush.numworldlights; ++i)
	{
		dworldlight_t* light = &memory::interfaces::hostState->worldbrush.worldlights[i];
		const emittype_t type = light->type;

		light->intensity = savedColors.at(i);
	}
}

void lights::shutdown()
{
	forceReset();
}
```

`hack/cheats/features/visuals/world/lights.hpp`:

```hpp
#pragma once

enum FrameStage;

namespace lights
{
	void init();
	void run(FrameStage stage);
	void postReset();
	void forceReset();
	void shutdown();
}
```

`hack/cheats/features/visuals/world/modulateColors.cpp`:

```cpp
#include "modulateColors.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <cheats/game/globals.hpp>

#include <array>

struct modulate_t
{
	bool* enabled;
	std::string_view name;
	CfgColor* color;
};

void modulateColor::run(void* thisptr, float* r, float* g, float* b)
{
	const auto material = reinterpret_cast<IMaterial*>(thisptr);

	if (!material)
		return;

	if (material->isError())
		return;

	static std::array mats =
	{
		modulate_t{ &vars::visuals->world->modulate->enabledTexture, TEXTURE_GROUP_WORLD, &vars::visuals->world->modulate->texture },
		modulate_t{ &vars::visuals->world->modulate->enabledProp, TEXTURE_GROUP_STATIC_PROP, &vars::visuals->world->modulate->prop },
		modulate_t{ &vars::visuals->world->modulate->enabledSky, TEXTURE_GROUP_SKYBOX, &vars::visuals->world->modulate->sky },
	};

	bool goodMat = false;
	const std::string_view group = material->getTextureGroupName();
	if (auto itr = std::ranges::find_if(mats, [group](const auto& mat)
		{
			if (!(*mat.enabled))
				return false;

			return mat.name == group;
		}); itr != mats.end())
	{
		itr->color->refresh();
		*r = itr->color->getColor().r();
		*g = itr->color->getColor().g();
		*b = itr->color->getColor().b();

		goodMat = true;
	}

	constexpr int shaderAlpha = 5;
	auto shader = material->getShaderParams()[shaderAlpha];
	if (vars::visuals->world->modulate->enabledShader)
		shader->setValue(vars::visuals->world->modulate->shader / 100.0f);

	if (globals::isShutdown)
		shader->setValue(1.0f);
}
```

`hack/cheats/features/visuals/world/modulateColors.hpp`:

```hpp
#pragma once

namespace modulateColor
{
	void run(void* thisptr, float* r, float* g, float* b);
};

```

`hack/cheats/features/visuals/world/molotov.cpp`:

```cpp
#include "molotov.hpp"

#include "../../cache/cache.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>

#include <deps/delaunator-cpp/delaunator.hpp>
#include <imgui_internal.h>

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct MolotovHandler : hooks::PaintTraverse
	{
		MolotovHandler()
		{
			this->registerRender(molotov::draw);
		}
	} molotovHandler;
}

static constexpr float orient(const ImVec2& a, const ImVec2& b, const ImVec2& c)
{
	return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

// returns list of pair when outer or not
static std::optional<std::vector<std::pair<bool, ImVec2>>> grahamScanIndicies(std::span<const ImVec2> points)
{
	// case when it's impossible
	if (points.size() < 3)
		return std::nullopt;

	// make a temp copy to allow use swap
	std::vector<ImVec2> v{ points.begin(), points.end() };

	// now at index 0 we have most left point
	std::ranges::iter_swap(v.begin(), std::ranges::min_element(v, {}, [](const ImVec2& p) { return p.x; }));

	std::ranges::sort(v.begin() + 1, v.end(),
		[p0 = v.at(0)](const ImVec2& a, const ImVec2& b)
		{
			auto _orient = orient(p0, a, b);
			return _orient == 0.0f ? ImLengthSqr(p0 - a) < ImLengthSqr(p0 - b) : _orient < 0.0f;
		}
	);

	std::vector<std::pair<size_t, ImVec2>> hull;
	for (size_t i = 0; const auto & el : v)
	{
		while (hull.size() > 1 && orient(hull[hull.size() - 2].second, hull[hull.size() - 1].second, el) >= 0.0f)
			hull.pop_back();

		hull.emplace_back(std::make_pair(i, el));

		++i;
	}

	std::vector<std::pair<bool, ImVec2>> result(points.size());
	// init all with false outers.
	std::ranges::transform(v, result.begin(), [](const ImVec2& p) { return std::make_pair(false, p); });
	// fill possible outer points.
	std::ranges::for_each(v, [&](const auto& el)
		{
			size_t i = &el - v.data();
			if (std::ranges::find_if(hull, [i](const auto& pair) { return i == pair.first; }) != hull.end())
				result.at(i) = { true, v[i] };
		});

	return result;
}

static void removeClosePoints(std::vector<std::pair<bool, ImVec2>>& points, float threshold)
{
	// I hate the formatting of lambdas in vs, please don't reformat this
	std::erase_if(points, [&](const auto& p1)
		{
			if (p1.first) // skip outer
				return false;

			return std::ranges::any_of(points, [&](const auto& p2)
				{
					if (p2.first)
						return false;

					const ImVec2 between = p2.second - p1.second;
					const float dist = std::sqrt(ImLengthSqr(between));

					return dist < threshold && &p1 != &p2;
				});
		});
}

void molotov::draw()
{
	if (!vars::visuals->world->molotov->enabled)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::GRENADE_PROJECTILES))
	{
		if (classID != CInferno)
			continue;

		auto molotov = reinterpret_cast<Inferno_t*>(entity);

		// https://github.com/perilouswithadollarsign/cstrike15_src/blob/master/game/server/cstrike15/Effects/inferno.cpp
		// here you can see ratios and everything

		float time = molotov->spawnTime() + molotov->expireTime() - memory::interfaces::globalVars->m_curtime;
		float scale = time / molotov->expireTime();

		const auto& origin = molotov->absOrigin();
		constexpr float molotovRadius{ 60 }; // 30 * 2

		std::vector<Vec3> molotovWorldPoints;
		for (auto i = 0; i <= molotov->m_fireCount(); i++)
		{
			auto pos = origin + molotov->getInfernoPos(i);
			molotovWorldPoints.push_back(pos);
		}

		// applying a very general fix for every part of possible angle.
		static const auto extraFlames = []
		{
			constexpr auto extraPoints = 4;
			constexpr float step = math::PI_2 / extraPoints;

			std::array<Vec3, extraPoints> points;
			for (float angle = 0.0f; auto & el : points)
			{
				el = Vec3{ molotovRadius * std::cos(angle), molotovRadius * std::sin(angle), 0.0f };
				angle += step;
			}

			return points;
		}();

		std::vector<ImVec2> points;
		for (const auto& el : molotovWorldPoints)
		{
			for (const auto& flame : extraFlames)
			{
				if (ImVec2 s; ImRender::worldToScreen(el + flame, s))
					points.push_back(s);
			}
		}

		auto hull = grahamScanIndicies(points);
		if (!hull.has_value())
			continue;

		std::vector<ImVec2> hullOuter;
		for (const auto& [outer, coord] : hull.value())
		{
			if (outer)
				hullOuter.push_back(coord);
		}

		if (hullOuter.size() < 3) // can't even contrcut a triangle of edges
			continue;

		// bit hardocding to give acceptable treshold
		constexpr float acceptableScaled = 100.0f;
		constexpr float minDist = 20.0f;
		// very hardcoded scaling, works kind of well, or not really...
		const float test = game::localPlayer->absOrigin().distToMeters(origin) * 7;
		const float testingScale = std::max(std::min(acceptableScaled - test, acceptableScaled), minDist);
		removeClosePoints(hull.value(), testingScale);

		// todo: edit triangulation in some time to pass concept template of vec2 with floating point fields
		std::vector<float> triangPoints;
		for (const auto& el : hull.value())
		{
			triangPoints.emplace_back(el.second.x);
			triangPoints.emplace_back(el.second.y);
		}

		const delaunator::Delaunator<float> d{ triangPoints };

		if (vars::visuals->world->molotov->triangulation && d.triangles.size() > 6)
		{
			for (std::size_t i = 0; i < d.triangles.size(); i += 3)
			{
				ImVec2 p1{ d.coords.at(2 * d.triangles.at(i)), d.coords.at(2 * d.triangles.at(i) + 1) };
				ImVec2 p2{ d.coords.at(2 * d.triangles.at(i + 1)), d.coords.at(2 * d.triangles.at(i + 1) + 1) };
				ImVec2 p3{ d.coords.at(2 * d.triangles.at(i + 2)), d.coords.at(2 * d.triangles.at(i + 2) + 1) };

				ImRender::drawTriangle(p1, p2, p3, Colors::White);
			}
		}

		ImRender::drawPolyGon(hullOuter, vars::visuals->world->molotov->color());

		auto centerPolygon = [hullOuter, hullsize = hullOuter.size()]()
		{
			ImVec2 centre{ };
			for (const auto& el : hullOuter)
			{
				centre.x += el.x;
				centre.y += el.y;
			}

			return centre / static_cast<float>(hullsize);
		};

		static float size = ImRender::fonts::tahoma14->FontSize;
		const auto centerPoint = centerPolygon();
		ImRender::drawProgressRing(centerPoint.x, centerPoint.y, 25, 32, -90.0f, scale, 5.0f, Colors::LightBlue);
		ImRender::text(centerPoint.x, centerPoint.y - (size / 2.0f), ImRender::fonts::tahoma14, std::format("{:.2f}s", time), true, Colors::White);
	}
}
```

`hack/cheats/features/visuals/world/molotov.hpp`:

```hpp
#pragma once

namespace molotov
{
	void draw();
}

```

`hack/cheats/features/visuals/world/nadepred.cpp`:

```cpp
#include "nadepred.hpp"

#include <SDK/math/Vector.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/Convar.hpp>
#include <SDK/Enums.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <gamememory/memory.hpp>

#include "../../cache/cache.hpp"

#include <ranges>

#include <cheats/hooks/createMove.hpp>
#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct NadePredDraw : hooks::PaintTraverse
	{
		NadePredDraw()
		{
			this->registerRender(grenadePrediction::draw);
		}
	} nadeDraw;

	struct NadeButtons : hooks::CreateMove
	{
		NadeButtons()
		{
			this->registerRunPrePrediction(grenadePrediction::run);
		}
	} nadeButtons;
}

#define DETONATE 1
#define BOUNCE 2

namespace grenadePrediction
{
	std::vector<Vec3> pathNade;
	std::vector<Vec3> bouncesNade;
	bool isReady;
	int weaponIndex;
	void setup(Vec3& src, Vec3& vecThrow, const Vec3& viewangles);
	size_t step(Vec3& src, Vec3& vecThrow, int tick, float interval);
	void simulate();
	bool checkDetonate(const Vec3& vecThrow, const Trace_t& tr, int tick, float interval);
	void addGravityMove(Vec3& move, Vec3& vel, float frametime);
	void traceHull(Vec3& src, Vec3& end, Trace_t& tr);
	void pushEntity(Vec3& src, const Vec3& move, Trace_t& tr);
	void resolveFlyCollisionCustom(Trace_t& tr, Vec3& velocity, const Vec3& move, float interval);
	void physicsClipVelocity(const Vec3& in, const Vec3& normal, Vec3& out, float overbounce);
}

void grenadePrediction::run(CUserCmd* cmd)
{
	if (!vars::misc->nade->enabledPred)
		return;

	isReady = false;

	if (vars::misc->nade->predAlways)
		isReady = true;
	else
		isReady = cmd->m_buttons & (IN_ATTACK | IN_ATTACK2);

	auto wpn = game::localPlayer->getActiveWeapon();
	if (!wpn || !wpn->isGrenade())
		return;

	if (isReady)
	{
		weaponIndex = wpn->m_iItemDefinitionIndex();
		simulate();
	}
	else
		weaponIndex = WEAPON_NONE;
}

struct DmgNadeInfo_t
{
	ImVec2 m_pos;
	std::string m_textDmg;
	Color m_color;
};

void grenadePrediction::draw()
{
	if (!vars::misc->nade->enabledPred)
		return;

	if (!game::isAvailable())
		return;

	auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	if (!weapon->isGrenade())
		return;

	if (!weaponIndex)
		return;

	if (pathNade.empty())
		return;

	std::vector<DmgNadeInfo_t> nadesDmg = {};

	// valve values
	constexpr float a = 105.0f;
	constexpr float b = 25.0f;
	constexpr float c = 140.0f;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::PLAYER))
	{
		auto ent = reinterpret_cast<Player_t*>(entity);
		if (!ent)
			continue;

		if (ent->isDormant())
			continue;

		if (!ent->isAlive())
			continue;

		if (!ent->isOtherTeam(game::localPlayer()))
			continue;

		float deltaDist = (ent->absOrigin() - pathNade.back()).length();

		if (int idx = weapon->m_iItemDefinitionIndex(); idx == WEAPON_HEGRENADE)
		{
			if (deltaDist > 350.0f) // nade always same
				continue;

			float d = ((deltaDist - b) / c);
			float dmg = a * std::exp(-d * d);
			float resultDmg = game::scaleDamageArmor(dmg, static_cast<float>(ent->m_ArmorValue()));
			if (resultDmg < 0.1f)
				continue;

			float dmgDealt = ent->m_iHealth() - resultDmg;
			if (ImVec2 pos; ImRender::worldToScreen(ent->absOrigin(), pos))
			{
				std::string text = dmgDealt < 0.0f ? "DIE" : std::format("{:.2f}", -resultDmg);
				nadesDmg.emplace_back(pos, text, Color::healthBased(static_cast<uint8_t>(dmgDealt)));
			}
		}
		else if (idx == WEAPON_MOLOTOV || idx == WEAPON_INCGRENADE)
		{
			if (deltaDist > 180.0f) // 180 is not always accurate perfectly
				continue;

			if (ImVec2 pos; ImRender::worldToScreen(ent->absOrigin(), pos))
				nadesDmg.emplace_back(pos, "In range", Colors::LightBlue);
		}
	}

	std::vector<ImVec2> points;
	for (const auto & el : pathNade)
	{
		if (ImVec2 screen; ImRender::worldToScreen(el, screen))
			points.push_back(screen);
	}
	if (!points.empty())
		ImRender::drawPolyLine(points, vars::misc->nade->colorPredLine(), 0, 2.0f);

	for (const auto& el : bouncesNade)
	{
		ImRender::drawBox3DFilled(el, 2.0f, 2.0f, vars::misc->nade->colorPredBox(), vars::misc->nade->colorPredBoxFill());
	}

	for (const auto& [pos, text, color] : nadesDmg)
	{
		ImRender::text(pos.x, pos.y, ImRender::fonts::tahoma20, text, true, color, false);
	}

	//ImRender::drawCircle3D(m_path.back(), weapon->getNadeRadius(), 32, Colors::White);
}

// not using magic value given by valve, so we never are based on buttons
void grenadePrediction::setup(Vec3& src, Vec3& vecThrow, const Vec3& viewangles)
{
	auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	Vec3 angThrow = viewangles;
	float pitch = math::normalizePitch(angThrow[Coord::X]);

	constexpr float inversed = 10.0f / 90.0f;
	angThrow[Coord::X] -= (90.0f - std::abs(angThrow[Coord::X])) * inversed;
	Vec3 forward = math::angleVec(angThrow);

	float m_flThrowStrength = weapon->m_flThrowStrength();
	float clampedVelWeapon = std::min(std::max(weapon->getWpnInfo()->m_throwVelocity * 0.9f, 15.0f), 750.0f);

	float throwHeight = (m_flThrowStrength * 12.0f) - 12.0f;

	src = game::localPlayer->getEyePos();

	float finalVel = clampedVelWeapon * ((0.7f * m_flThrowStrength) + 0.3f);

	Vec3 start = game::localPlayer->getEyePos() += Vec3{ 0.0f, 0.0f, throwHeight };
	Vec3 end = start + (forward * 22.0f);

	Trace_t tr;
	traceHull(src, end, tr);

	Vec3 back = forward;
	back *= 6.0f;
	src = tr.m_end;
	src -= back;

	vecThrow = game::localPlayer->m_vecVelocity();
	vecThrow *= 1.25f;
	vecThrow += forward * finalVel;
}

void grenadePrediction::simulate()
{
	Vec3 vecSrc, vecThrow;
	Vec3 angles; memory::interfaces::engine->getViewAngles(angles);
	setup(vecSrc, vecThrow, angles);

	float interval = memory::interfaces::globalVars->m_intervalPerTick;
	size_t logstep = static_cast<size_t>(0.05f / interval);
	size_t logtimer = 0;

	pathNade.clear();
	bouncesNade.clear();

	for (auto i : std::views::iota(0, 1024)) // 1024 is hardcoded, we prob will never ever reach it
	{
		if (!logtimer)
			pathNade.push_back(vecSrc);

		size_t s = step(vecSrc, vecThrow, i, interval);

		if (s & DETONATE)
			break;

		if (s & BOUNCE || logtimer >= logstep)
			logtimer = 0;
		else
			++logtimer;

		if (vecThrow.isZero())
			break;
	}

	pathNade.push_back(vecSrc);
	bouncesNade.push_back(vecSrc);
}

size_t grenadePrediction::step(Vec3& src, Vec3& vecThrow, int tick, float interval)
{
	Vec3 move;
	addGravityMove(move, vecThrow, interval);
	Trace_t tr;
	pushEntity(src, move, tr);

	size_t result = 0;

	if (checkDetonate(vecThrow, tr, tick, interval))
		result |= DETONATE;

	if (tr.didHit())
	{
		result |= BOUNCE;
		resolveFlyCollisionCustom(tr, vecThrow, move, interval);
		bouncesNade.push_back(tr.m_end);
	}

	if (auto size = bouncesNade.size() - 1; !bouncesNade.empty() && size > 20)
		bouncesNade.erase(bouncesNade.begin() + size);

	src = tr.m_end;
	return result;
}

bool grenadePrediction::checkDetonate(const Vec3& vecThrow, const Trace_t& tr, int tick, float interval)
{
	auto check = [=](float amount = 0.2f)
	{
		return !(tick % game::timeToTicks(amount));
	};

	const float time = game::ticksToTime(tick);

	switch (weaponIndex)
	{
	case WEAPON_SMOKEGRENADE:
	{
		return vecThrow.toVecPrev().length() <= 0.1f && check();
	}
	case WEAPON_DECOY:
	{
		return vecThrow.toVecPrev().length() <= 0.2f && check();
	}
	case WEAPON_MOLOTOV:
	case WEAPON_INCGRENADE:
	{
		const static float molotov_throw_detonate_time = memory::interfaces::cvar->findVar("molotov_throw_detonate_time")->getFloat();
		const static float weapon_molotov_maxdetonateslope = memory::interfaces::cvar->findVar("weapon_molotov_maxdetonateslope")->getFloat();

		if (tr.didHit() && tr.m_plane.m_normal[Coord::Z] >= std::cos(math::DEG2RAD(weapon_molotov_maxdetonateslope)))
			return true;

		return time >= molotov_throw_detonate_time && check(0.1f);
	}
	case WEAPON_FLASHBANG:
	case WEAPON_HEGRENADE:
		return time >= 1.5f && check();
	default:
		return false;
	}

	return false;
}

// should add more traces, as in some cases the prediction can fail badly
void grenadePrediction::traceHull(Vec3& src, Vec3& end, Trace_t& tr)
{
	uintptr_t filter[] =
	{
		*reinterpret_cast<uintptr_t*>(memory::traceFilterSimple()),
		reinterpret_cast<uintptr_t>(game::localPlayer()),
		0,
		0
	};

	memory::interfaces::trace->traceRay({ src, end, Vec3{ -2.0f, -2.0f, -2.0f }, Vec3{ 2.0f, 2.0f, 2.0f } }, MASK_SOLID, reinterpret_cast<TraceFilter*>(&filter), &tr);
}

void grenadePrediction::addGravityMove(Vec3& move, Vec3& vel, float frametime)
{
	move[Coord::X] = vel[Coord::X] * frametime;
	move[Coord::Y] = vel[Coord::Y] * frametime;

	const static float svgrav = memory::interfaces::cvar->findVar("sv_gravity")->getFloat();
	float gravity = svgrav * 0.4f;
	float z = vel[Coord::Z] - (gravity * frametime);
	move[Coord::Z] = ((vel[Coord::Z] + z) / 2.0f) * frametime;

	vel[Coord::Z] = z;
}

void grenadePrediction::pushEntity(Vec3& src, const Vec3& move, Trace_t& tr)
{
	Vec3 end = src;
	end += move;
	traceHull(src, end, tr);
}

inline bool fClassnameIs(Entity_t* ent, const std::string_view name)
{
	if (!ent)
		return false;

	auto cl = ent->clientClass();
	if (!cl)
		return false;

	return std::string_view{ cl->m_networkName } == name;
}

void grenadePrediction::resolveFlyCollisionCustom(Trace_t& tr, Vec3& velocity, const Vec3& move, float interval)
{
	// better fix isbroken, temp solution
	if (tr.m_entity->isPlayer() && tr.m_entity->m_iHealth() > 0)
	{
		velocity *= 0.4f;
		//tr.m_entity->setAbsVelocity(velocity);

		return;
	}

	float surfaceElasticity = 1.0f;
	if (tr.m_entity->isPlayer())
		surfaceElasticity = 0.3f;

	constexpr float nadeElascity = 0.45f;
	float totalElascity = surfaceElasticity * nadeElascity;
	totalElascity = std::clamp(totalElascity, 0.0f, 0.9f);

	Vec3 absVelocity;
	physicsClipVelocity(velocity, tr.m_plane.m_normal, absVelocity, 2.0f);
	absVelocity *= totalElascity;

	constexpr float minSpeed = 20.0f * 20.0f;
	float speedAbsSqr = absVelocity.lengthSqrt();

	if (speedAbsSqr < minSpeed)
		absVelocity = {};

	if (tr.m_plane.m_normal[Coord::Z] > 0.7f)
	{
		velocity = absVelocity;
		absVelocity *= ((1.0f - tr.m_fraction) * interval);
		pushEntity(tr.m_end, absVelocity * ((1.0f - tr.m_fraction) * interval), tr);
	}
	else
	{
		velocity = absVelocity;
	}
}

void grenadePrediction::physicsClipVelocity(const Vec3& in, const Vec3& normal, Vec3& out, float overbounce)
{
	constexpr float STOP_EPSILON = 0.1f;

	float backoff = in.dot(normal) * overbounce;
	for (auto i : std::views::iota(0, 3))
	{
		out[i] = in[i] - (normal[i] * backoff);

		if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
			out[i] = 0.0f;
	}
}

```

`hack/cheats/features/visuals/world/nadepred.hpp`:

```hpp
#pragma once

class CUserCmd;

// a lot of code is in cstrike15 leak, as I tried to do this I run on few cases where it was not pixel perfect
// fix is def needed, for breakables bounces
namespace grenadePrediction
{
	void draw();
	void run(CUserCmd* cmd);
}

```

`hack/cheats/features/visuals/world/nadewarn.cpp`:

```cpp
#include "nadewarn.hpp"

#include <SDK/math/Vector.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/IEngineTrace.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/Convar.hpp>
#include <SDK/Enums.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/utilities.hpp>
#include <gamememory/memory.hpp>

#include <ranges>

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct NadeWarningHandler : hooks::PaintTraverse
	{
		NadeWarningHandler()
		{
			this->registerRender(grenadeWarning::draw);
		}
	} nadeWarningHandler;
}

// code not fully made by me
// Uses much less math than predicting the full throw due to existance of networkable values
class NadeTrace_t
{
public:
	NadeTrace_t() = default;
	constexpr NadeTrace_t(Player_t* owner, WeaponIndex index) :
		nadeOwner{ owner }, weaponIndex{ index }
	{}

	void simulate(const Vec3& pos, const Vec3& velocity, float nadeThrowTime, uint32_t ticks);
	bool draw(WeaponIndex idx);
private:
	void addGravityMove(Vec3& move, Vec3& vel, float frametime);
	void physicsClipVelocity(const Vec3& in, const Vec3& normal, Vec3& out, float overbounce);
	void destroyTrace();
	void push();
	void handleDetonates();
	void handleDestroy();
	bool step(float interval);
	void traceHull(const Vec3& src, const Vec3& end, Entity_t* entity, Trace_t* tr);
	void pushEntity(const Vec3& src, Trace_t& tr);
	void resolveFlyCollisionCustom(Trace_t& tr, float interval);
	std::optional<std::string_view> getConsoleName(WeaponIndex idx) const;

	bool m_detonated{ false };
	// nade index
	WeaponIndex weaponIndex{ };
	// current tick for nade loop
	uint32_t nadeTick{ };
	// next tick, based on passed addon, to make this more perfect with tick timing
	uint32_t nextNadeTick{ };
	// for decoy
	size_t bouncesNadeCount{ 0 };

	Player_t* nadeOwner{ };
	Vec3 pos{ };
	Vec3 velocity{ };
	float nadeDetonateTime{ };
	float nadeEndTime{ };
	std::vector<Vec3> nadePath{ };
};

namespace grenadeWarning
{
	std::unordered_map<int, NadeTrace_t> nadeTraces;
}

bool NadeTrace_t::step(float interval)
{
	if (m_detonated)
		return true;

	Vec3 move;
	addGravityMove(move, velocity, interval);
	Trace_t tr;
	pushEntity(move, tr);

	if (tr.didHit())
		resolveFlyCollisionCustom(tr, interval);

	pos = tr.m_end;

	return false;
}

void NadeTrace_t::physicsClipVelocity(const Vec3& in, const Vec3& normal, Vec3& out, float overbounce)
{
	constexpr float STOP_EPSILON = 0.1f;

	float backoff = in.dot(normal) * overbounce;
	for (auto i : std::views::iota(0, 3))
	{
		out[i] = in[i] - (normal[i] * backoff);

		if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
			out[i] = 0.f;
	}
}

void NadeTrace_t::addGravityMove(Vec3& move, Vec3& vel, float frametime)
{
	move[Coord::X] = vel[Coord::X] * frametime;
	move[Coord::Y] = vel[Coord::Y] * frametime;

	const static float svgrav = memory::interfaces::cvar->findVar("sv_gravity")->getFloat();
	float gravity = svgrav * 0.4f;
	float z = vel[Coord::Z] - (gravity * frametime);
	move[Coord::Z] = ((vel[Coord::Z] + z) / 2.0f) * frametime;

	vel[Coord::Z] = z;
}

void NadeTrace_t::traceHull(const Vec3& src, const Vec3& end, Entity_t* entity, Trace_t* tr)
{
	uintptr_t filter[] =
	{
		*reinterpret_cast<uintptr_t*>(memory::traceFilterSimple()),
		reinterpret_cast<uintptr_t>(entity),
		0,
		0
	};

	memory::interfaces::trace->traceRay({ src, end, Vec3{ -2.0f, -2.0f, -2.0f }, Vec3{ 2.f, 2.0f, 2.0f } }, MASK_SOLID, reinterpret_cast<TraceFilter*>(&filter), tr);
}

void NadeTrace_t::pushEntity(const Vec3& src, Trace_t& tr)
{
	traceHull(pos, pos + src, nadeOwner, &tr);

	// lazy attempt... see nadepred check code
	if (weaponIndex == WEAPON_MOLOTOV || weaponIndex == WEAPON_INCGRENADE)
	{
		const static float weapon_molotov_maxdetonateslope = memory::interfaces::cvar->findVar("weapon_molotov_maxdetonateslope")->getFloat();

		if (bool res = tr.didHit() && tr.m_plane.m_normal[Coord::Z] >= std::cos(math::DEG2RAD(weapon_molotov_maxdetonateslope)); res)
			destroyTrace();
	}
}

void NadeTrace_t::resolveFlyCollisionCustom(Trace_t& tr, float interval)
{
	/*float surfaceElasticity = 1.0;*/
	if (auto e = tr.m_entity; e) // if it's any entity
	{
		if (auto e = tr.m_entity; e->isPlayer()) // if player don't stop but make it bouned a lot slower
		{
			/*surfaceElasticity = 0.3f;*/
			velocity *= 0.3f;
			return;
		}

		if (e->isBreakable()) // for example glass or window
		{
			if (!e->isAlive()) // any better solution?
			{
				velocity *= 0.4f;
				return;
			}
		}
		// here some checks are needed, I honestly don't know how to make it pixel perfect in this case
	}

	constexpr float surfaceElasticity = 1.0f;
	constexpr float nadeElascity = 0.45f;
	float totalElascity = surfaceElasticity * nadeElascity;
	totalElascity = std::clamp(totalElascity, 0.0f, 0.9f);

	Vec3 absVelocity;
	physicsClipVelocity(velocity, tr.m_plane.m_normal, absVelocity, 2.0f);
	absVelocity *= totalElascity;

	constexpr float minSpeed = 20.0f * 20.0f;
	float speedAbsSqr = absVelocity.lengthSqrt();

	if (speedAbsSqr < minSpeed)
		absVelocity = {};

	if (tr.m_plane.m_normal[Coord::Z] > 0.7f)
	{
		velocity = absVelocity;
		absVelocity *= ((1.0f - tr.m_fraction) * interval);
		pushEntity(absVelocity * ((1.0f - tr.m_fraction) * interval), tr);
	}
	else
		velocity = absVelocity;

	// or velocity
	if (bouncesNadeCount > 20)
		return destroyTrace();

	++bouncesNadeCount;
}

void NadeTrace_t::handleDestroy()
{
	if (weaponIndex == WEAPON_DECOY || weaponIndex == WEAPON_SMOKEGRENADE)
		if (velocity.toVecPrev().length() <= 0.1f) // ghetto workaround, at least we can be sure this is accurate
		{
			//printf("did destroy\n");
			destroyTrace();
		}

	if (game::ticksToTime(nadeTick) > nadeDetonateTime)
		destroyTrace();

	nextNadeTick = nadeTick + game::timeToTicks(0.2f);
}

void NadeTrace_t::handleDetonates()
{
	switch (weaponIndex)
	{
	case WEAPON_SMOKEGRENADE:
	{
		nadeDetonateTime = 3.0f;
		break;
	}
	case WEAPON_DECOY:
	{
		nadeDetonateTime = 5.0f;
		break;
	}
	case WEAPON_FLASHBANG:
	case WEAPON_HEGRENADE:
	{
		nadeDetonateTime = 1.5f;
		break;
	}
	case WEAPON_MOLOTOV:
	case WEAPON_INCGRENADE:
	{
		const static auto molotov_throw_detonate_time = memory::interfaces::cvar->findVar("molotov_throw_detonate_time");
		nadeDetonateTime = molotov_throw_detonate_time->getFloat();
		break;
	}
	default:
		nadeDetonateTime = 0.0f;
		break;
	}
}

void NadeTrace_t::simulate(const Vec3& _pos, const Vec3& _velocity, float nadeThrowTime, uint32_t ticks)
{
	pos = _pos;
	velocity = _velocity;

	handleDetonates();

	float interval = memory::interfaces::globalVars->m_intervalPerTick;
	for (; nadeTick < game::timeToTicks(500.0f); nadeTick++) // 500 = 500 * 2 about 1000+
	{
		if (nextNadeTick <= nadeTick)
			handleDestroy();

		if (nadeTick < ticks)
			continue;

		if (step(interval))
			break;

		push();
	}

	nadeEndTime = nadeThrowTime + game::ticksToTime(nadeTick);
}

void NadeTrace_t::destroyTrace()
{
	m_detonated = true;
}

void NadeTrace_t::push()
{
	nadePath.push_back(pos);
}

bool NadeTrace_t::draw(WeaponIndex idx)
{
	if (nadePath.empty())
		return false;

	ImVec2 start; // need access outside
	if (float dist = nadePath.back().distToMeters(game::localPlayer->absOrigin()); dist > vars::misc->nade->tracerDist)
		return false;

	std::vector<ImVec2> points;
	for (const auto & el : nadePath)
	{
		if (ImRender::worldToScreen(el, start))
			points.push_back(start);
	}
	if (!points.empty())
		ImRender::drawPolyLine(points, vars::misc->nade->colorTracer(), 0, 2.0f);

	const float scale = ((nadeEndTime - memory::interfaces::globalVars->m_curtime) / game::ticksToTime(nadeTick));
	const float rad = game::getScaledFont(nadePath.back(), game::localPlayer->absOrigin());

	ImRender::drawCircleFilled(start.x, start.y, rad, 32, Colors::Black);
	ImRender::drawProgressRing(start.x, start.y, rad, 32, -90, scale, 3.0f, Colors::Green);


	if (const auto maybeName = getConsoleName(idx); maybeName.has_value())
	{
		const auto icon = game::getWeaponIcon(maybeName.value());
		const auto sizeIcon = ImVec2{ rad + 2.0f, rad + 2.0f };
		ImRender::drawImage(icon.texture, ImVec2{ start.x - (sizeIcon.y / 2.0f), start.y - (sizeIcon.y / 2.0f) }, sizeIcon, Colors::White);

		auto rotatePoint2D = [](const Vec2& source, const Vec2& dest, float rotateAngle)
		{
			const auto delta = dest - source;

			Vec2 pointRotation
			{
				delta[Coord::X] * std::sin(rotateAngle) - delta[Coord::Y] * std::cos(rotateAngle),
				delta[Coord::X] * std::cos(rotateAngle) + delta[Coord::Y] * std::sin(rotateAngle)
			};

			return source + pointRotation;
		};

		ImVec2 uselessVec;
		if (vars::misc->nade->tracerWarn && !ImRender::worldToScreen(pos, uselessVec))
		{
			const auto centre = Vec2{ globals::screenX / 2.0f, globals::screenY / 2.0f };

			Vec3 localViewAngle;
			memory::interfaces::engine->getViewAngles(localViewAngle);
			const auto& localPos = game::localPlayer->absOrigin();
			const auto angleToNade = math::calcAngleRelative(localPos, pos, localViewAngle);

			auto screenPosition = centre;
			screenPosition[Coord::X] -= std::clamp(localPos.distTo(pos), 120.0f, centre[Coord::Y] - 12.0f); // 12.0f - min size possible here so wanna clip it

			const auto pos = rotatePoint2D(centre, screenPosition, math::DEG2RAD(angleToNade[Coord::Y]));

			ImRender::drawCircleFilled(pos[Coord::X], pos[Coord::Y], rad, 32, Colors::Black);
			ImRender::drawProgressRing(pos[Coord::X], pos[Coord::Y], rad, 32, -90.0f, scale, 3.0f, Colors::Green);
			ImRender::drawImage(icon.texture, ImVec2{ pos[Coord::X] - (sizeIcon.x / 2), pos[Coord::Y] - (sizeIcon.y / 2.0f) }, sizeIcon, Colors::White);
		}
	}

	return true;
}

#include "../../cache/cache.hpp"

void grenadeWarning::draw()
{
	if (!nadeTraces.empty())
		nadeTraces.clear();

	if (!vars::misc->nade->enabledTracer)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::GRENADE_PROJECTILES))
	{
		auto ent = reinterpret_cast<Nade_t*>(entity);

		if (ent->isDormant())
			continue;

		auto model = ent->getModel();
		if (!model)
			continue;

		auto studio = memory::interfaces::modelInfo->getStudioModel(model);
		if (!studio)
			continue;

		auto wpnIdx = game::getNadeByClass(classID, studio);
		if (wpnIdx == WEAPON_NONE)
			continue;

		nadeTraces.emplace(std::make_pair(
			idx,
			NadeTrace_t
			{
				reinterpret_cast<Player_t*>(memory::interfaces::entList->getClientFromHandle(ent->m_hThrower())),
				wpnIdx
			}));

		// simulates, in this place because there is no much math related stuff needed for angles etc
		nadeTraces.at(idx).simulate(
			ent->m_vecOrigin(),
			reinterpret_cast<Player_t*>(ent)->m_vecVelocity(),
			ent->m_flSpawnTime(),
			game::timeToTicks(reinterpret_cast<Player_t*>(ent)->m_flSimulationTime() - ent->m_flSpawnTime())
		);

		// if no path, then delete this owner from map
		if (!nadeTraces.at(idx).draw(wpnIdx))
			nadeTraces.erase(idx);
	}
}

std::optional<std::string_view> NadeTrace_t::getConsoleName(WeaponIndex idx) const
{
	static std::unordered_map<WeaponIndex, std::string_view> names =
	{
		{ WEAPON_HEGRENADE, "weapon_hegrenade" },
		{ WEAPON_FLASHBANG, "weapon_flashbang" },
		{ WEAPON_SMOKEGRENADE, "weapon_smokegrenade" },
		{ WEAPON_MOLOTOV, "weapon_molotov" },
		{ WEAPON_INCGRENADE, "weapon_inferno" },
		{ WEAPON_DECOY, "weapon_decoy" }
	};

	if (const auto itr = names.find(idx); itr != names.end())
		return itr->second;

	return std::nullopt;
}
```

`hack/cheats/features/visuals/world/nadewarn.hpp`:

```hpp
#pragma once

namespace grenadeWarning
{
	void draw();
}
```

`hack/cheats/features/visuals/world/projectiles.cpp`:

```cpp
#include "projectiles.hpp"

#include "nadewarn.hpp"
#include "../../cache/cache.hpp"

#include <SDK/IWeapon.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <render/render.hpp>

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct ProjectileHandler : hooks::PaintTraverse
	{
		ProjectileHandler()
		{
			this->registerRender(projectiles::draw);
		}
	} projectilesHandler;
}

void projectiles::draw()
{
	if(!game::isAvailable())
		return;

	if (!vars::visuals->world->projectiles->enabled)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::GRENADE_PROJECTILES))
	{
		auto model = entity->getModel();
		if (!model)
			continue;

		auto studio = memory::interfaces::modelInfo->getStudioModel(model);
		if (!studio)
			continue;

		auto wpn = reinterpret_cast<Weapon_t*>(entity);
		if (!wpn) // should not ever happen
			continue;

		auto wpnIdx = game::getNadeByClass(classID, studio);
		if (wpnIdx == WEAPON_NONE)
			continue;

		std::pair<std::string, Color> nades;

		switch (wpnIdx)
		{
		case WEAPON_FLASHBANG:
		{
			nades = { "FLASHBANG", vars::visuals->world->projectiles->flash() };
			break;
		}
		case WEAPON_HEGRENADE:
		{
			if (wpn->m_nExplodeEffectTickBegin() < 1) // prevent too long time
				nades = { "GRENADE", vars::visuals->world->projectiles->nade() };
			break;
		}
		case WEAPON_MOLOTOV:
		case WEAPON_INCGRENADE:
		{
			nades = { "FIRE", vars::visuals->world->projectiles->molotov() };
			break;
		}
		case WEAPON_SMOKEGRENADE:
		{
			if (!reinterpret_cast<Smoke_t*>(wpn)->m_nSmokeEffectTickBegin()) // prevent too long time
				nades = { "SMOKE", vars::visuals->world->projectiles->smoke() };
			break;
		}
		case WEAPON_DECOY:
		{
			nades = { "DECOY", vars::visuals->world->projectiles->decoy() }; // this nade time is also too long, check velocity if it's very low
			break;
		}
		case WEAPON_NONE: // understand as NADE_NONE
			return;
		}

		const auto [text, col] = nades;
		if (Box box{ entity }; box.isValid())
			ImRender::text(box.x + box.w / 2, box.y + box.h + 2, ImRender::fonts::verdana12, text, true, col);
	}
}
```

`hack/cheats/features/visuals/world/projectiles.hpp`:

```hpp
#pragma once

namespace projectiles
{
	void draw();
}

```

`hack/cheats/features/visuals/world/removeSky.cpp`:

```cpp
#include "removeSky.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/Convar.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>

#include <cheats/hooks/doPostScreenEffects.hpp>

namespace
{
	struct SkyHandler : hooks::DoPostScreenEffects
	{
		SkyHandler()
		{
			this->registerInit(sky::init);
			this->registerRun(sky::run);
		}
	} skyHandler;
}

namespace sky
{
	IConVar* r_3dsky;
}

void sky::init()
{
	r_3dsky = memory::interfaces::cvar->findVar("r_3dsky");
}

void sky::run()
{
	// do smth about sky controller as well, TODO

	vars::visuals->world->sky->removeSky ? r_3dsky->setValue(false) : r_3dsky->setValue(true);
}

```

`hack/cheats/features/visuals/world/removeSky.hpp`:

```hpp
#pragma once

namespace sky
{
	void run();
	void init();
}

```

`hack/cheats/features/visuals/world/skybox.cpp`:

```cpp
#include "skybox.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <gamememory/memory.hpp>
#include <menu/GUI-ImGui/selections.hpp>

#include <cheats/hooks/frameStageNotify.hpp>
#include <cheats/helper/initable.hpp>

namespace
{
	struct SkyboxHandler : hooks::FrameStageNotify
	{
		SkyboxHandler()
		{
			this->registerInit(skybox::init);
			this->registerRun(skybox::run);
			this->registerShutdown(skybox::shutdown);
		}
	} skyboxHandler;
}

namespace skybox
{
	void loadSkybox(const std::string& name);
	void checkCustomSkybox();

	std::filesystem::path m_pathCustomSkybox;
	IConVar* sv_skyname;
}

void skybox::init()
{
	checkCustomSkybox();
	reloadCustomSkyboxes();

	sv_skyname = memory::interfaces::cvar->findVar("sv_skyname");
}

void skybox::run(FrameStage stage)
{
	if (stage != FRAME_RENDER_START)
		return;

	if (!changedState)
		return;

	if (!game::isAvailable())
		return;

	// bool to point true = custom
	std::pair<int, bool> keySky;
	if (auto custom = vars::visuals->world->sky->indexCustom; custom > 0)
		keySky = { custom, true };
	else
		keySky = { vars::visuals->world->sky->indexNormal, false };

	if (keySky.first != 0 && !globals::isShutdown) // is not none and there is no shutdown
	{
		keySky.second == true
			? loadSkybox(customSkyboxes.at(keySky.first).c_str())
			: loadSkybox(selections::skyboxes.at(keySky.first));
	}
	else
	{
		// restore the sky
		loadSkybox(sv_skyname->m_valueNow);
	}
}

void skybox::loadSkybox(const std::string& name)
{
	memory::loadSky()(name.c_str());
}

void skybox::checkCustomSkybox()
{
	auto path = std::filesystem::current_path() / "csgo" / "materials" / "skybox";

	if (!std::filesystem::exists(path))
	{
		if (!std::filesystem::create_directories(path))
			return;
	}

	m_pathCustomSkybox = path;
}

void skybox::reloadCustomSkyboxes()
{
	customSkyboxes.clear();
	customSkyboxes.emplace_back("none");
	auto iterator = std::filesystem::directory_iterator(m_pathCustomSkybox);
	for (const auto& entry : iterator)
	{
		if (std::string name = entry.path().filename().string();
			entry.path().extension() == ".vtf" && !name.empty())
		{
			customSkyboxes.push_back(name);
		}
	}
}

void skybox::shutdown()
{
	loadSkybox(sv_skyname->m_valueNow);
}

```

`hack/cheats/features/visuals/world/skybox.hpp`:

```hpp
#pragma once

#include <vector>

enum FrameStage;
class IConVar;

namespace skybox
{
	void reloadCustomSkyboxes();

	void run(FrameStage stage);
	void init();
	void shutdown();

	inline std::vector<std::string> customSkyboxes;
	inline bool changedState{ false };
}

```

`hack/cheats/features/visuals/world/smoke.cpp`:

```cpp
#include "smoke.hpp"

#include "../../cache/cache.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IEffects.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/render.hpp>
#include <utilities/math/math.hpp>
#include <gamememory/memory.hpp>

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct SmokeHandler : hooks::PaintTraverse
	{
		SmokeHandler()
		{
			this->registerRender(smoke::draw);
		}
	} smokeHandler;
}

void smoke::draw()
{
	if (!vars::visuals->world->smoke->enabled)
		return;

	for (auto [entity, idx, classID] : EntityCache::getCache(EntCacheType::GRENADE_PROJECTILES))
	{
		if (classID != CSmokeGrenadeProjectile)
			continue;

		auto ent = reinterpret_cast<Smoke_t*>(entity);

		if (!ent->m_nSmokeEffectTickBegin())
		{
			//drawCustomSmokeEffect(ent->absOrigin(), 30.0f);
			continue;
		}

		float time = game::ticksToTime(ent->m_nSmokeEffectTickBegin()) + ent->expireTime() - memory::interfaces::globalVars->m_curtime;
		float scale = time / ent->expireTime();

		const auto& origin = ent->absOrigin();
		constexpr int smokeRadius = 144;

		ImRender::drawCircle3DFilled(origin, smokeRadius, 216, Colors::Grey, Colors::Black, true, 2.0f);
		//drawCustomSmokeEffect(origin, smokeRadius);

		static float size = ImRender::fonts::tahoma14->FontSize;
		if (ImVec2 s; ImRender::worldToScreen(origin, s))
		{
			ImRender::drawProgressRing(s.x, s.y, 25, 32, -90, scale, 5.0f, Colors::LightBlue);
			ImRender::text(s.x, s.y - (size / 2.0f), ImRender::fonts::tahoma14, std::format("{:.2f}s", time), true, Colors::White);
		}
	}
}

void drawCustomSmokeEffect(const Vec3& pos, float radius)
{
	// clockwise for better effect
	Vec3 end = Vec3
	{
		radius * std::sin(memory::interfaces::globalVars->m_curtime) + pos[Coord::X],
		radius * std::cos(memory::interfaces::globalVars->m_curtime) + pos[Coord::Y],
		pos[Coord::Z]
	};

	memory::interfaces::effects->smoke(end, -1, 5.0f, 1.0f);
}
```

`hack/cheats/features/visuals/world/smoke.hpp`:

```hpp
#pragma once

namespace smoke
{
	void draw();
}

```

`hack/cheats/features/visuals/world/tone.cpp`:

```cpp
#include "tone.hpp"

#include "../../cache/cache.hpp"

#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>

#include <cheats/hooks/frameStageNotify.hpp>
#include <cheats/hooks/levelInitPostEnttity.hpp>

namespace
{
	struct ToneHandler : hooks::FrameStageNotify
	{
		ToneHandler()
		{
			this->registerRun(toneController::run);
			this->registerShutdown(toneController::shutdown);
		}
	} toneHandler;

	struct ToneGrabber : hooks::LevelInitPostEntity
	{
		ToneGrabber()
		{
			this->registerPostReset(toneController::grabberDefault);
		}
	} toneGrabber;
}

namespace toneController
{
	struct Tone
	{
		bool useExposureMin;
		bool useExposureMax;
		bool useBloom;
		float min;
		float max;
		float bloom;
	} toneDefault;
}

void toneController::run(FrameStage stage)
{
	if (stage != FRAME_RENDER_START)
		return;

	if (!game::isAvailable())
		return;

	auto ent = memory::interfaces::toneController();
	if (!ent) // not all maps support it by default
		return;

	if (bool cfg = vars::visuals->world->tone->enabled; cfg)
	{
		ent->m_bUseCustomAutoExposureMin() = true;
		ent->m_bUseCustomAutoExposureMax() = true;
		ent->m_bUseCustomBloomScale() = true;
		ent->m_flCustomAutoExposureMin() = vars::visuals->world->tone->min;
		ent->m_flCustomAutoExposureMax() = vars::visuals->world->tone->max;
		ent->m_flCustomBloomScale() = vars::visuals->world->tone->bloom;
	}
	else if (!cfg)
	{
		shutdown();
	}
}

void toneController::grabberDefault()
{
	auto ent = memory::interfaces::toneController();
	if (!ent)
		return;

	toneDefault.useExposureMin = ent->m_bUseCustomAutoExposureMin();
	toneDefault.useExposureMax = ent->m_bUseCustomAutoExposureMax();
	toneDefault.useBloom = ent->m_bUseCustomBloomScale();
	toneDefault.min = ent->m_flCustomAutoExposureMin();
	toneDefault.max = ent->m_flCustomAutoExposureMax();
	toneDefault.bloom = ent->m_flCustomBloomScale();
}

void toneController::shutdown()
{
	auto ent = memory::interfaces::toneController();
	if (!ent)
		return;

	ent->m_bUseCustomAutoExposureMin() = toneDefault.useExposureMin;
	ent->m_bUseCustomAutoExposureMax() = toneDefault.useExposureMax;
	ent->m_bUseCustomBloomScale() = toneDefault.useBloom;
	ent->m_flCustomAutoExposureMin() = toneDefault.min;
	ent->m_flCustomAutoExposureMax() = toneDefault.max;
	ent->m_flCustomBloomScale() = toneDefault.bloom;
}
```

`hack/cheats/features/visuals/world/tone.hpp`:

```hpp
#pragma once

enum FrameStage;

namespace toneController
{
	void run(FrameStage stage);
	void grabberDefault();
	void shutdown();
}

```

`hack/cheats/features/visuals/world/weather/_menu.cpp`:

```cpp
#include "_menu.hpp"

#include "helper.hpp"
#include "precipitation.hpp"
#include "ground.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IEngineSound.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include <cheats/game/game.hpp>
#include <menu/GUI-ImGui/imguiaddons.hpp>
#include <config/vars.hpp>

struct ConfigWeather
{
	IConVar* convar;
	float defaultVal;
	float min, max;
	float* configRef;
};

void weather::menu::draw()
{
	const static ConfigWeather cvarlength
	{
		.convar = memory::interfaces::cvar->findVar("r_rainlength"),
		.defaultVal = memory::interfaces::cvar->findVar("r_rainlength")->getFloat(),
		.min = 0.0f,
		.max = 1.0f,
		.configRef = &vars::visuals->world->weather->length
	};
	const static ConfigWeather cvarRadius
	{
		.convar = memory::interfaces::cvar->findVar("r_rainradius"),
		.defaultVal = memory::interfaces::cvar->findVar("r_rainradius")->getFloat(),
		.min = 0.0f,
		.max = 3000.0f,
		.configRef = &vars::visuals->world->weather->radius
	};
	const static ConfigWeather cvarWidth
	{
		.convar = memory::interfaces::cvar->findVar("r_rainwidth"),
		.defaultVal = memory::interfaces::cvar->findVar("r_rainwidth")->getFloat(),
		.min = 0.0f,
		.max = 5.0f,
		.configRef = &vars::visuals->world->weather->width
	};
	const static ConfigWeather cvarSidevel
	{
		.convar = memory::interfaces::cvar->findVar("r_RainSideVel"),
		.defaultVal = memory::interfaces::cvar->findVar("r_RainSideVel")->getFloat(),
		.min = 50.0f,
		.max = 1000.0f,
		.configRef = &vars::visuals->world->weather->velocity
	};
	const static ConfigWeather cvarAlpha
	{
		.convar = memory::interfaces::cvar->findVar("r_rainalpha"),
		.defaultVal = memory::interfaces::cvar->findVar("r_rainalpha")->getFloat(),
		.min = 0.0f,
		.max = 1.0f,
		.configRef = &vars::visuals->world->weather->alpha
	};
	const static ConfigWeather cvarWindSpeed
	{
		.convar = memory::interfaces::cvar->findVar("cl_windspeed"),
		.defaultVal = memory::interfaces::cvar->findVar("cl_windspeed")->getFloat(),
		.min = 0.0f,
		.max = 1000.0f,
		.configRef = &vars::visuals->world->weather->windSpeed
	};
	const static ConfigWeather cvarParticleDensity
	{
		.convar = memory::interfaces::cvar->findVar("r_RainParticleDensity"),
		.defaultVal = memory::interfaces::cvar->findVar("r_RainParticleDensity")->getFloat(),
		.min = 0.0f,
		.max = 15.0f, // supposed to be max of 1
		.configRef = &vars::visuals->world->weather->particleDensity
	};

	static std::array allvarsNonParticle
	{
		cvarlength,
			cvarRadius,
			cvarWidth,
			cvarSidevel,
			cvarAlpha,
			cvarWindSpeed
	};

	static std::array allvarsParticle
	{
		cvarParticleDensity
	};

	static std::once_flag onceFlag;
	std::call_once(onceFlag, []()
		{
			for (auto& cfg : allvarsNonParticle)
				*cfg.configRef = cfg.defaultVal;

			for (auto& cfg : allvarsParticle)
				*cfg.configRef = cfg.defaultVal;
		});

	const helper::CustomPrecipitationType_t precipType = helper::configToPrecip(vars::visuals->world->weather->type);
	const bool isParticle = vars::visuals->world->weather->type >= 2;

	if (!isParticle)
	{
		for (auto& cfg : allvarsNonParticle)
		{
			if (ImGui::SliderFloat(cfg.convar->m_name, cfg.configRef, cfg.min, cfg.max))
				cfg.convar->setValue(*cfg.configRef);

			if (cfg.convar->m_helper)
			{
				ImGui::SameLine();
				ImGui::HelpMarker(cfg.convar->m_helper);
			}
		}
	}
	else
	{
		if (ImGui::SliderFloat("Sound volume", &vars::visuals->world->weather->volume, 0.0f, 1.0f))
		{
			memory::interfaces::engineSound->emitAmbientSound(precipitation::pickSoundForPrecip(precipType).data(),
				vars::visuals->world->weather->volume, PITCH_NORM, SND_STOP);

			memory::interfaces::engineSound->emitAmbientSound(precipitation::pickSoundForPrecip(precipType).data(),
				vars::visuals->world->weather->volume, PITCH_NORM, SND_SPAWNING | SND_STOP_LOOPING);
		}

		if (precipType == helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAINSTORM)
		{
			ImGui::Checkbox("Use storm effects", &vars::visuals->world->weather->storm);
			ImGui::SameLine();
			ImGui::HelpMarker("Emits dlight around localplayer and creates thunder lights");
		}

		auto drawGround = []()
		{
			ImGui::Checkbox("Use Ground", &vars::visuals->world->weather->useGround);
			ImGui::SameLine();
			ImGui::HelpMarker("Rain particles types will get very reflective ground\nSnow changes texture to the snow");
			ImGui::SameLine();
			if (ImGui::Button("Create##ground"))
				ground::calledCreate = true;

			ImGui::SameLine();
			if (ImGui::Button("Shutdown##ground"))
				ground::calledShutdown = true;

			ImGui::SameLine();
			ImGui::HelpMarker("It is recommended to not use those, because for now we can't shutdown mats from findmaterial solution\n"
				"Manual solution should reinit textures well, although there are artifacts");
		};

		if (!game::isAvailable())
		{
			drawGround();
		}
		else
		{
			const auto& groundInfo = weather::ground::getGroundInfo();
			auto mapIt = groundInfo.find(memory::interfaces::engine->getLevelName());
			if (mapIt == groundInfo.end())
			{
				ImGui::TextUnformatted("Unsupported map!");
				ImGui::BeginDisabled();
				drawGround();
				ImGui::EndDisabled();
			}
			else
				drawGround();
		}

		for (auto& cfg : allvarsParticle)
		{
			if (ImGui::SliderFloat(cfg.convar->m_name, cfg.configRef, cfg.min, cfg.max))
				cfg.convar->setValue(*cfg.configRef);

			if (cfg.convar->m_helper)
			{
				ImGui::SameLine();
				ImGui::HelpMarker(cfg.convar->m_helper);
			}
		}
	}

	if (!isParticle)
	{
		if (ImGui::Button("Default rain cvars"))
		{
			for (const auto& cfg : allvarsNonParticle)
			{
				*cfg.configRef = cfg.defaultVal;
				cfg.convar->setValue(cfg.defaultVal);
			}
		}
	}
	else
	{
		if (ImGui::Button("Default rain cvars"))
		{
			for (const auto& cfg : allvarsParticle)
			{
				*cfg.configRef = cfg.defaultVal;
				cfg.convar->setValue(cfg.defaultVal);
			}
		}
	}

	if (isParticle)
	{
		/*if (precipType == CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLESNOW)
		{
			ImGui::Checkbox("Snow Edit", &vars::visuals->world->weather->snowParticleEdit);
			ImGui::ColorPicker("Inner Near##snow", &vars::visuals->world->weather->snowParticleInnerNearColor);
			ImGui::SameLine();
			ImGui::ColorPicker("Inner Far##snow", &vars::visuals->world->weather->snowParticleInnerFarColor);
			ImGui::SameLine();
			ImGui::ColorPicker("Outer##snow", &vars::visuals->world->weather->snowParticleOuterColor);
		}*/
		if (precipType == helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAIN)
		{
			ImGui::Checkbox("Rain Edit", &vars::visuals->world->weather->rainParticleEdit);
			ImGui::ColorPicker("Inner Near##rain", &vars::visuals->world->weather->rainParticleInnerNearColor);
			/*ImGui::SameLine();
			ImGui::ColorPicker("Inner Far##rain", &vars::visuals->world->weather->rainParticleInnerFarColor);
			ImGui::SameLine();
			ImGui::ColorPicker("Outer##rain", &vars::visuals->world->weather->rainParticleOuterColor);*/
		}
		else if (precipType == helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAINSTORM)
		{
			ImGui::Checkbox("Rain Storm Edit", &vars::visuals->world->weather->rainStormParticleEdit);
			ImGui::ColorPicker("Inner Near##rainst", &vars::visuals->world->weather->rainStormParticleInnerNearColor);
			ImGui::SameLine();
			ImGui::ColorPicker("Inner Far##rainst", &vars::visuals->world->weather->rainStormParticleInnerFarColor);
			ImGui::SameLine();
			ImGui::ColorPicker("Outer##rainst", &vars::visuals->world->weather->rainStormParticleOuterColor);
		}

		ImGui::SliderFloat("Near##w", &vars::visuals->world->weather->customNear, 0.0f, 200.0f);
		ImGui::SliderFloat("Far##w", &vars::visuals->world->weather->customFar, 0.0f, 500.0f);
	}
}
```

`hack/cheats/features/visuals/world/weather/_menu.hpp`:

```hpp
#pragma once

namespace weather::menu
{
	void draw();
}
```

`hack/cheats/features/visuals/world/weather/ground.cpp`:

```cpp
#include "ground.hpp"

#include "helper.hpp"

#include <SDK/material.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/CCommonHostState.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientState.hpp>
#include <SDK/vars.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>

#include <config/vars.hpp>
#include <utilities/console/console.hpp>
#include <menu/GUI-ImGui/imguiaddons.hpp>

#include <cheats/hooks/frameStageNotify.hpp>
#include <cheats/hooks/levelInitPreEntity.hpp>
#include <cheats/features/visuals/chams/factory/factory.hpp>


// artifacts is thta manual solution won't reload texture sounds, decals coming from them etc...
// also material vars dont apply to it, dont know why, even though they are precached once again
// thanks ze-elite for good texture restoring method

namespace
{
	struct GroundFSN : hooks::FrameStageNotify
	{
		GroundFSN()
		{
			this->registerInit(weather::ground::init);
			this->registerRun(weather::ground::resetFindMat);
		}
	} groundFSN;

	struct GroundRoundReset : hooks::LevelInitPreEntity
	{
		GroundRoundReset()
		{
			this->registerReset(weather::ground::reset);
		}
	} groundRoundReset;
}

namespace weather::ground
{
	struct MatSaver
	{
		std::string_view name;
		std::string_view varName;
		Vec3 varValue;
	};

	std::vector<std::pair<int, IMaterial*>> oldMaterialsManualPaired;
	std::vector<std::string_view> oldMaterialsFindMat;
	std::vector<MatSaver> oldMaterialsFindMatVars;
	std::vector<std::string_view> oldMaterialsAll;
}

void weather::ground::init()
{

}

void weather::ground::reset()
{
	oldMaterialsManualPaired.clear();
}

// this is not called automatically. it's hard to make it working with not destroying the context too soon and magically tell matsys to wait for x time
void weather::ground::shutdown()
{
	if (!calledShutdown)
		return;

	// because this is only important ofr mid-round shutdown
	if (!game::isAvailable())
		return;

	if (!oldMaterialsFindMatVars.empty())
	{
		for (int i = 0; i < memory::interfaces::hostState->worldbrush.numtexinfo; ++i)
		{
			auto mat = memory::interfaces::hostState->worldbrush.textinfo[i].material;

			if (auto it = std::ranges::find_if(oldMaterialsFindMatVars, [mat](const MatSaver& matSaver)
				{
					if (std::string_view{ mat->getName() } == matSaver.name)
						return true;

					return false;
				}
			); it != oldMaterialsFindMatVars.end())
			{
				mat->findVar("$envmap")->setValue(it->varName.data());
				mat->findVar("$envmaptint")->setValues(it->varValue);
			}
		}

		oldMaterialsFindMatVars.clear();
	}

	if (!oldMaterialsFindMat.empty())
	{
		// how 2 sort dis, not names, indexes how?
		for (int i = 0; i < memory::interfaces::hostState->worldbrush.numtexinfo; ++i)
		{
			auto mat = memory::interfaces::hostState->worldbrush.textinfo[i].material;

		}

		//memory::restoreMaterialSystemObjects()(0x1);

		oldMaterialsFindMat.clear();

		return;
	}

	if (!oldMaterialsManualPaired.empty())
	{
		// manual ones will get renamed, we replaced pointer, so we need to reassign it
		for (int i = 0; i < memory::interfaces::hostState->worldbrush.numtexinfo; ++i)
		{
			for (auto& [index, oldMaterial] : oldMaterialsManualPaired)
			{
				if (i == index)
				{
					memory::interfaces::hostState->worldbrush.textinfo[i].material = oldMaterial;
				}
			}
		}
		oldMaterialsManualPaired.clear();

		memory::interfaces::matSys->forceSingleThreaded();
		memory::restoreMaterialSystemObjects()(0x1);

		return;
	}

	calledShutdown = false;
}

void weather::ground::resetFindMat(FrameStage stage)
{
	// ok we are not on serv yet, or we cleared mats already
	if (oldMaterialsFindMat.empty())
		return;

	// do only if we quit the game
	if (!game::isAvailable())
		oldMaterialsFindMat.clear();
}

// we won't care for wet ground here, it is so far not working with anything... vars cant get saved for cubemap on mid-round, and touching files manually is bad
void weather::ground::applyManually()
{
	if (!game::isAvailable())
		return;

	if (calledShutdown)
	{
		ImNotify::add(ImNotify{ 3.0, "Restored textures", "If you called them after findmat - they won't change" });
		shutdown();
	}

	if (!oldMaterialsFindMatVars.empty())
		return;

	create();
}

void weather::ground::create()
{
	if (!game::isAvailable())
		return;

	if (!calledCreate)
		return;

	const auto& groundInfo = getGroundInfo();
	auto mapIt = groundInfo.find(memory::interfaces::engine->getLevelName());
	if (mapIt == groundInfo.end())
	{
		//ImNotify::add(ImNotify{ 3.0, "Can't create textures", "You are on unsupported map, add keys by yourself" });
		return;
	}

	ImNotify::add(ImNotify{ 3.0, "Created textures manually", "You can restart them without issues" });

	const static auto materialSnow = material::factory::findMaterial("ground/snow01", TEXTURE_GROUP_WORLD);

	for (int i = 0; i < memory::interfaces::hostState->worldbrush.numtexinfo; ++i)
	{
		auto& mat = memory::interfaces::hostState->worldbrush.textinfo[i].material;
		std::string_view materialName = memory::interfaces::hostState->worldbrush.textinfo[i].material->getName();
		auto mapIt = groundInfo.find(memory::interfaces::engine->getLevelName());
		if (mapIt != groundInfo.end())
		{
			if (std::string_view{ mat->getTextureGroupName() } == TEXTURE_GROUP_WORLD)
			{
				const auto& textures = mapIt->second;
				if (std::ranges::find_if(textures, [materialName](std::string_view textureFilter)
					{
						return materialName.contains(textureFilter);
					}) != textures.end())
				{
					oldMaterialsManualPaired.emplace_back(std::make_pair(i, mat));

					memory::interfaces::hostState->worldbrush.textinfo[i].material = materialSnow;
				}
			}
		}
	}

	memory::interfaces::matSys->forceSingleThreaded();
	memory::restoreMaterialSystemObjects()(0x1);

	calledCreate = false;
}

IMaterial* weather::ground::applyFindMat(IMaterial* mat)
{
	if (globals::isShutdown)
		return nullptr;

	if (!vars::visuals->world->weather->useGround)
		return nullptr;

	const auto type = helper::configToPrecip(vars::visuals->world->weather->type);

	if (type != helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAIN
		&& type != helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAINSTORM
		&& type != helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLESNOW)
		return nullptr;

	// grab only on map load
	if (memory::interfaces::clientState->m_deltaTick != -1)
		return nullptr;

	const auto& groundInfo = getGroundInfo();
	const std::string_view materialName = mat->getName();

	auto mapIt = groundInfo.find(memory::levelName()); // fastest way
	if (mapIt != groundInfo.end())
	{
		if (std::string_view{ mat->getTextureGroupName() } == TEXTURE_GROUP_WORLD)
		{
			const auto& textures = mapIt->second;
			if (std::ranges::find_if(textures, [materialName](std::string_view textureFilter)
				{
					return materialName.contains(textureFilter);
				}) != textures.end())
			{
				if (type == helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAIN || type == helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAINSTORM)
				{
					const auto envmap = mat->findVar("$envmap");
					const auto envmaptint = mat->findVar("$envmaptint");

					const auto nameMap = envmap->getString();
					const auto valuesMap = envmap->getVector();

					oldMaterialsFindMatVars.emplace_back(MatSaver{ materialName, nameMap, Vec3{ valuesMap[0], valuesMap[1], valuesMap[2] } });

					envmap->setValue("env_cubemap");
					envmaptint->setValues(Vec3{ 1.0f, 1.0f, 1.0f });
				}
				else if (type == helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLESNOW)
				{
					oldMaterialsFindMat.push_back(materialName);

					const static auto materialSnow = material::factory::findMaterial("ground/snow01", TEXTURE_GROUP_WORLD);
					return materialSnow;
				}

				return mat;
			}
		}
	}

	return nullptr;
}

weather::ground::groundInfo weather::ground::getGroundInfo()
{
	static groundInfo gInfo;
	gInfo["de_mirage"] =
	{
		"maps/de_mirage/de_mirage",
		"de_mirage/ground",
		"de_mirage/tile",
		"concrete/street_overlay_parkingstripe",
		"de_dust/sitebwall08a",
		"de_dust/tilefloor",
		"de_dust/stonestep",
		"maps/de_mirage/de_dust/tilefloor",
		"wood/woodfloor",
		"marble",
		"concrete/blend_blacktopsand_01",
		"concrete/concrete_floor_04",
		"wood/plywood02",
		"wood/milbeams",
		"wood/woodbeam001"
	};

	return gInfo;
}
```

`hack/cheats/features/visuals/world/weather/ground.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <atomic>

class IMaterial;
enum FrameStage;

// DO NOT USE LOCKS HERE
namespace weather::ground
{
	using groundInfo = std::unordered_map<std::string_view, std::vector<std::string_view>>;

	groundInfo getGroundInfo();

	void reset();
	// CRITICAL SECTION
	void shutdown();
	void resetFindMat([[maybe_unused]] FrameStage stage);
	void init();
	void create();
	void findIndexes();
	// CRITICAL SECTION
	void applyManually();
	IMaterial* applyFindMat(IMaterial* mat);

	inline bool calledShutdown = false;
	inline bool calledCreate = false;
}
```

`hack/cheats/features/visuals/world/weather/helper.hpp`:

```hpp
#pragma once

namespace weather::helper
{
	enum class CustomPrecipitationType_t
	{
		PRECIPITATION_TYPE_NONE = -1,
		PRECIPITATION_TYPE_RAIN = 0,
		PRECIPITATION_TYPE_SNOW,
		PRECIPITATION_TYPE_PARTICLERAIN = 4,
		PRECIPITATION_TYPE_PARTICLERAINSTORM = 6,
		PRECIPITATION_TYPE_PARTICLESNOW,
		PRECIPITATION_TYPE_CUSTOM,
	};

	constexpr CustomPrecipitationType_t configToPrecip(int cfg)
	{
		switch (cfg)
		{
		case 1:
			return CustomPrecipitationType_t::PRECIPITATION_TYPE_RAIN;
		case 2:
			return CustomPrecipitationType_t::PRECIPITATION_TYPE_SNOW;
		case 3:
			return CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAIN;
		case 4:
			return CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAINSTORM;
		case 5:
			return CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLESNOW;
		default:
			return CustomPrecipitationType_t::PRECIPITATION_TYPE_NONE;
		}
	}
}
```

`hack/cheats/features/visuals/world/weather/precipitation.cpp`:

```cpp
#include "precipitation.hpp"

#include "helper.hpp"

#include <SDK/CGlobalVars.hpp>
#include <SDK/IEffects.hpp>
#include <SDK/Enums.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/IBaseClientDll.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/ICollideable.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/math/Vector.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <config/vars.hpp>
#include <utilities/utilities.hpp>
#include <utilities/rand.hpp>
#include <SDK/CUtlVector.hpp>
#include <SDK/IEngineSound.hpp>
#include <SDK/IViewRenderBeams.hpp>
#include <SDK/IPhysicsCollision.hpp>
#include <SDK/IVEffects.hpp>

#include <menu/GUI-ImGui/imguiaddons.hpp>
#include <utilities/console/console.hpp>
#include <utilities/math/math.hpp>

#include <cheats/hooks/frameStageNotify.hpp>
#include <cheats/hooks/levelInitPreEntity.hpp>
#include <cheats/hooks/clientModeCSNormalEvent.hpp>
#include <cheats/hooks/drawModelExecute.hpp>
#include <cheats/features/visuals/chams/factory/factory.hpp>

namespace
{
	struct WeatherHandler : hooks::FrameStageNotify
	{
		WeatherHandler()
		{
			this->registerInit(weather::precipitation::init);
			this->registerRun(weather::precipitation::run);
			this->registerShutdown(weather::precipitation::shutdown);
		}
	} weatherHandler;

	struct WeatherHandlerReset : hooks::LevelInitPreEntity
	{
		WeatherHandlerReset()
		{
			this->registerReset(weather::precipitation::reset);
		}
	} weatherReseter;

	struct WeatherFiles : hooks::DrawModelExecute
	{
		WeatherFiles()
		{
			this->registerInit(weather::precipitation::preacheCustomFiles);
		}
	} weatherFiles;
}

namespace weather::precipitation
{
	// thanks clarification, for more reference see dump logs on RAIN maps
	constexpr std::array<uint8_t, 546> weatherBuffer
	{
		0xB8, 0x01, 0x00, 0x00, 0x56, 0x50, 0x48, 0x59, 0x00, 0x01, 0x00, 0x00, 0x9C, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x16, 0x6A, 0xC1, 0xC0, 0x0E, 0x1C, 0xC1, 0x80, 0x13, 0xD0, 0x3F, 0xE2, 0x26, 0x11, 0x48,
		0xE2, 0x26, 0x11, 0x48, 0xE2, 0x26, 0x11, 0x48, 0x72, 0x4E, 0x08, 0x44, 0xD1, 0x9C, 0x01, 0x00,
		0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x56, 0x50, 0x53,
		0xD0, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x15, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
		0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x12, 0x00,
		0x01, 0x80, 0x00, 0x00, 0x02, 0x00, 0xFD, 0x7F, 0x01, 0x00, 0x15, 0x00, 0x03, 0x00, 0x28, 0x00,
		0x02, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x04, 0x00, 0x0F, 0x00, 0x01, 0x00, 0xF6, 0x7F,
		0x03, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x15, 0x00, 0x04, 0x00, 0xFA, 0x7F,
		0x04, 0x70, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06, 0x00, 0x13, 0x00, 0x05, 0x00, 0xFA, 0x7F,
		0x05, 0x60, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x7F, 0x02, 0x00, 0x18, 0x00, 0x06, 0x00, 0xFA, 0x7F,
		0x06, 0x50, 0x00, 0x00, 0x01, 0x00, 0xF1, 0x7F, 0x04, 0x00, 0x03, 0x00, 0x03, 0x00, 0xEB, 0x7F,
		0x07, 0x40, 0x00, 0x00, 0x03, 0x00, 0xFD, 0x7F, 0x04, 0x00, 0x04, 0x00, 0x07, 0x00, 0x0C, 0x00,
		0x08, 0x10, 0x00, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0xFC, 0x7F, 0x04, 0x00, 0xEB, 0x7F,
		0x09, 0x00, 0x00, 0x00, 0x05, 0x00, 0xED, 0x7F, 0x06, 0x00, 0x03, 0x00, 0x07, 0x00, 0xFA, 0x7F,
		0x0A, 0x30, 0x00, 0x00, 0x07, 0x00, 0xFD, 0x7F, 0x06, 0x00, 0x03, 0x00, 0x03, 0x00, 0xF4, 0x7F,
		0x0B, 0x20, 0x00, 0x00, 0x03, 0x00, 0xFD, 0x7F, 0x06, 0x00, 0xE8, 0x7F, 0x02, 0x00, 0xD8, 0x7F,
		0x46, 0xAD, 0x9D, 0xC3, 0x1F, 0x0D, 0x9C, 0xC3, 0x80, 0xAE, 0xAA, 0x43, 0x00, 0x00, 0x00, 0x00,
		0x46, 0xAD, 0x9D, 0xC3, 0x33, 0x4C, 0x92, 0x43, 0x80, 0xAE, 0xAA, 0x43, 0x00, 0x00, 0x00, 0x00,
		0x46, 0xAD, 0x9D, 0xC3, 0x1F, 0x0D, 0x9C, 0xC3, 0x59, 0x0E, 0xA9, 0xC3, 0x00, 0x00, 0x00, 0x00,
		0x46, 0xAD, 0x9D, 0xC3, 0x33, 0x4C, 0x92, 0x43, 0x59, 0x0E, 0xA9, 0xC3, 0x00, 0x00, 0x00, 0x00,
		0xE4, 0x0B, 0x8F, 0x43, 0x33, 0x4C, 0x92, 0x43, 0x80, 0xAE, 0xAA, 0x43, 0x00, 0x00, 0x00, 0x00,
		0xE4, 0x0B, 0x8F, 0x43, 0x1F, 0x0D, 0x9C, 0xC3, 0x80, 0xAE, 0xAA, 0x43, 0x00, 0x00, 0x00, 0x00,
		0xE4, 0x0B, 0x8F, 0x43, 0x1F, 0x0D, 0x9C, 0xC3, 0x59, 0x0E, 0xA9, 0xC3, 0x00, 0x00, 0x00, 0x00,
		0xE4, 0x0B, 0x8F, 0x43, 0x33, 0x4C, 0x92, 0x43, 0x59, 0x0E, 0xA9, 0xC3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xB0, 0xFE, 0xFF, 0xFF, 0x20, 0x16, 0x6A, 0xC1, 0xC0, 0x0E, 0x1C, 0xC1,
		0x80, 0x13, 0xD0, 0x3F, 0x72, 0x4E, 0x08, 0x44, 0x8A, 0x8B, 0x9C, 0x00, 0x73, 0x6F, 0x6C, 0x69,
		0x64, 0x20, 0x7B, 0x0A, 0x22, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x22, 0x20, 0x22, 0x30, 0x22, 0x0A,
		0x22, 0x6D, 0x61, 0x73, 0x73, 0x22, 0x20, 0x22, 0x35, 0x30, 0x30, 0x30, 0x30, 0x2E, 0x30, 0x30,
		0x30, 0x30, 0x30, 0x30, 0x22, 0x0A, 0x22, 0x73, 0x75, 0x72, 0x66, 0x61, 0x63, 0x65, 0x70, 0x72,
		0x6F, 0x70, 0x22, 0x20, 0x22, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x22, 0x0A, 0x22, 0x76,
		0x6F, 0x6C, 0x75, 0x6D, 0x65, 0x22, 0x20, 0x22, 0x31, 0x35, 0x30, 0x38, 0x30, 0x32, 0x33, 0x32,
		0x30, 0x35, 0x38, 0x38, 0x38, 0x30, 0x2E, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x22, 0x0A, 0x7D,
		0x0A, 0x00
	};

	struct WeatherFields_t
	{
		Precipitation_t* ent;
		Entity_t* networkable;
		vcollide_t collide;
	} weatherFields;

	bool done = false;
	bool newMap = false;
	float lastTimeStorm = 0.0f;
	size_t lightRapidsCounter = 0;
	DLight_t* lightStrike = nullptr;
	
	std::vector<std::pair<IMaterial*, std::string_view>> groundWorld;

	void create(PrecipitationType_t precip);
	void loadCollide();
	void createCustom();
	std::string_view pickRandomSoundForThunder();
}

#include <resources/resource.h>

HGLOBAL loadResourceData(HMODULE hModule, const int idRes, const char* resourceType, DWORD& dataSize) 
{
	HRSRC hResource = FindResourceA(hModule, MAKEINTRESOURCEA(idRes), resourceType);
	if (!hResource)
		return nullptr;

	HGLOBAL hGlobal = LoadResource(hModule, hResource);
	if (!hGlobal)
		return nullptr;

	dataSize = SizeofResource(hModule, hResource);
	return hGlobal;
}

std::vector<char> loadFile(HMODULE hModule, const int idRes, const char* resourceType)
{
	DWORD dataSize;
	HGLOBAL hGlobal = loadResourceData(hModule, idRes, resourceType, dataSize);
	if (!hGlobal)
		return {};

	const char* dataPtr = static_cast<const char*>(LockResource(hGlobal));
	if (!dataPtr)
		return {};

	UnlockResource(hGlobal);

	return std::vector<char>{ dataPtr, dataPtr + dataSize };
}

void saveResourceToDest(const std::vector<char>& data, const std::filesystem::path& path)
{
	if (data.empty())
	{
		console::error("data for {} was empty, correct resource?", path.string());
		return;
	}

	std::ofstream resFile{ path, std::ios::binary };
	resFile.write(data.data(), data.size());
}

#include <SDK/IBaseFileSystem.hpp>
#include <SDK/INetworkStringTableContainer.hpp>
#include <SDK/interfaces/interfaces.hpp>

void weather::precipitation::init()
{
	const auto pathSprites = std::filesystem::current_path() / "csgo" / "materials" / "sprites";
	if (!std::filesystem::exists(pathSprites))
		std::filesystem::create_directories(pathSprites);

	const auto bluelightningVMT = loadFile(globals::instance, IDR_VMT_FILE2, "VMT_FILE");
	saveResourceToDest(bluelightningVMT, pathSprites / "bluelightning.vmt");
	
	const auto bluelightningVTF = loadFile(globals::instance, IDR_VTF_FILE2, "VTF_FILE");
	saveResourceToDest(bluelightningVTF, pathSprites / "bluelightning.vtf");

	const auto bluelight1VMT = loadFile(globals::instance, IDR_VMT_FILE3, "VMT_FILE");
	saveResourceToDest(bluelight1VMT, pathSprites / "bluelight1.vmt");

	const auto bluelight1VTF = loadFile(globals::instance, IDR_VTF_FILE3, "VTF_FILE");
	saveResourceToDest(bluelight1VTF, pathSprites / "bluelight1.vtf");

	const auto lgtningVMT = loadFile(globals::instance, IDR_VMT_FILE4, "VMT_FILE");
	saveResourceToDest(lgtningVMT, pathSprites / "lgtning.vmt");

	const auto lgtningVTF = loadFile(globals::instance, IDR_VTF_FILE4, "VTF_FILE");
	saveResourceToDest(lgtningVTF, pathSprites / "lgtning.vtf");

	const auto physcannon_bluelight1VMT = loadFile(globals::instance, IDR_VMT_FILE5, "VMT_FILE");
	saveResourceToDest(physcannon_bluelight1VMT, pathSprites / "physcannon_bluelight1.vmt");

	const auto physcannon_bluelight1VTF = loadFile(globals::instance, IDR_VTF_FILE5, "VTF_FILE");
	saveResourceToDest(physcannon_bluelight1VTF, pathSprites / "physcannon_bluelight1.vtf");

	const auto physcannon_bluelight1bVMT = loadFile(globals::instance, IDR_VMT_FILE6, "VMT_FILE");
	saveResourceToDest(physcannon_bluelight1bVMT, pathSprites / "physcannon_bluelight1b.vmt");

	const auto physcannon_bluelight1bVTF = loadFile(globals::instance, IDR_VTF_FILE6, "VTF_FILE");
	saveResourceToDest(physcannon_bluelight1bVTF, pathSprites / "physcannon_bluelight1b.vtf");

	const auto pathParticles = std::filesystem::current_path() / "csgo" / "materials" / "particle";
	if (!std::filesystem::exists(pathParticles))
		std::filesystem::create_directories(pathParticles);

	const auto snowflakeVMT = loadFile(globals::instance, IDR_VMT_FILE1, "VMT_FILE");
	saveResourceToDest(snowflakeVMT, pathParticles / "snowflake.vmt");

	const auto snowflakeVTF = loadFile(globals::instance, IDR_VTF_FILE1, "VTF_FILE");
	saveResourceToDest(snowflakeVTF, pathParticles / "snowflake.vtf");
}

void weather::precipitation::preacheCustomFiles()
{
	precacheModel("materials/sprites/bluelightning.vmt");
	precacheModel("materials/sprites/bluelight1.vmt");
	precacheModel("materials/sprites/lgtning.vmt");
	precacheModel("materials/sprites/physcannon_bluelight1.vmt");
	precacheModel("materials/sprites/physcannon_bluelight1b.vmt");
	precacheModel("materials/particle/snowflake.vmt");
}

void weather::precipitation::create(PrecipitationType_t precip)
{
	auto getNetworkable = []() -> Entity_t*
	{
		auto ent = reinterpret_cast<Entity_t*>(memory::interfaces::preciptation->m_createFn(MAX_EDICTS - 1, 0));

		if (!ent)
			return nullptr;

		return ent;
	};

	const auto net = getNetworkable();
	weatherFields.networkable = net;
	if (!net)
		return;

	loadCollide();

	weatherFields.ent = reinterpret_cast<Precipitation_t*>((uintptr_t)weatherFields.networkable - 8); // make normal ent from networkbale
	if (!weatherFields.ent)
		return;

	weatherFields.ent->m_nPrecipType() = precip;

	weatherFields.ent->m_nModelIndex() = uniqueModelIndex;
	weatherFields.ent->m_bDormant() = false;

	weatherFields.ent->getClientAlphaProperty()->setAlphaModulation(255);
	
	assert(memory::interfaces::gameWorld());

	const auto& mins = memory::interfaces::gameWorld->m_WorldMins();
	const auto& maxs = memory::interfaces::gameWorld->m_WorldMaxs();

	weatherFields.ent->getCollideable()->OBBMins() = mins;
	weatherFields.ent->getCollideable()->OBBMaxs() = maxs;

	weatherFields.ent->onDataChanged(DATA_UPDATE_CREATED);

	done = true;
}

void weather::precipitation::createCustom()
{
	// play with fields I provided, change particles to some good from:
	// https://developer.valvesoftware.com/wiki/List_of_CS:GO_Particles
}

// https://www.unknowncheats.me/forum/counterstrike-global-offensive/418432-precipitation-effect-similar-llamahook.html
void weather::precipitation::run(FrameStage stage)
{
	if (stage != FRAME_START)
		return;

	if (!game::isAvailable())
		return;

	static int lastType = vars::visuals->world->weather->type;
	int lastCopyPostChanged = lastType;
	bool shouldCreate = false;
	if (lastType != vars::visuals->world->weather->type)
	{
		shouldCreate = true;
		lastType = vars::visuals->world->weather->type;
	}

	const helper::CustomPrecipitationType_t precipType = helper::configToPrecip(lastType);
	const helper::CustomPrecipitationType_t prePrecipType = helper::configToPrecip(lastCopyPostChanged);

	static std::once_flag onceFlag;
	std::call_once(onceFlag, [&shouldCreate, precipType]()
		{
			if (!shouldCreate && precipType != helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_NONE)
				shouldCreate = true;
		});

	if (precipType == helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_NONE)
	{
		if (shouldCreate)
		{
			// stop sounds used by last weather
			memory::interfaces::engineSound->emitAmbientSound(pickSoundForPrecip(prePrecipType).data(),
				vars::visuals->world->weather->volume, PITCH_NORM, SND_STOP);

			game::localPlayer->stopSound(pickSoundForPrecip(prePrecipType).data());
			shutdown();
		}

		return;
	}

	if (precipType != helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_NONE)
	{
		if (newMap)
		{
			shouldCreate = true;
			newMap = false;
		}
	}

	if (shouldCreate)
	{
		shutdown();
		memory::interfaces::engineSound->emitAmbientSound(pickSoundForPrecip(prePrecipType).data(),
			vars::visuals->world->weather->volume, PITCH_NORM, SND_STOP);
		create(static_cast<PrecipitationType_t>(precipType));

		// creating the initial one
		memory::interfaces::engineSound->emitAmbientSound(pickSoundForPrecip(precipType).data(),
			vars::visuals->world->weather->volume, PITCH_NORM, SND_SPAWNING | SND_STOP_LOOPING);
	}

	if (precipType == helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLESNOW)
	{
		// just loop thru manually, this sound for some reason doesnt loop
		static float lastTime = memory::interfaces::globalVars->m_curtime;
		if (memory::interfaces::globalVars->m_curtime - lastTime >= 6.0f)
		{
			memory::interfaces::engineSound->emitAmbientSound(pickSoundForPrecip(precipType).data(),
				vars::visuals->world->weather->volume, PITCH_NORM, SND_SPAWNING | SND_STOP_LOOPING);

			lastTime = memory::interfaces::globalVars->m_curtime;
		}
	}

	if (!vars::visuals->world->weather->storm)
	{
		lightRapidsCounter = 0;
		if (lightStrike)
		{
			lightStrike->m_die = memory::interfaces::globalVars->m_curtime;
			lightStrike = nullptr;
		}

		return;
	}

	constexpr size_t maxRapids = 3;
	constexpr float radius = 1200.0f;
	if (precipType == helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAINSTORM)
	{
		if (memory::interfaces::globalVars->m_curtime > lastTimeStorm)
		{
			const Vec3 directionVector = math::angleVec(game::localPlayer->absAngles());
			const Vec3 localHead = game::localPlayer->getHitboxPos(HITBOX_HEAD);
			const Vec3 newPosition
			{
				localHead[0] + (directionVector[0] * 50.0f),
				localHead[1] + (directionVector[1] * 50.0f),
				localHead[2] + 200.0f // dont care, just add a lot
			};

			if (vars::visuals->world->weather->saveFpsStorm)
			{
				// do the fullbright, white ambient + forced tone
			}
			else
			{
				// this is far from proper, Clight seems better
				lightStrike = memory::interfaces::efx->clAllocDLight(1337);
				lightStrike->m_key = 1337;
				//dynamic->m_style = 10; // DUMPED
				lightStrike->m_radius = radius;
				//dynamic->m_flags = 2563; // DUMPED
				float m_OuterAngle = 0.0f;
				float m_InnerAngle = 0.0f;
				if (m_OuterAngle > 0.0f)
					lightStrike->m_flags |= DLIGHT_NO_WORLD_ILLUMINATION;
				lightStrike->m_color = Colors::White;
				lightStrike->m_exponent = 7;
				lightStrike->m_origin = newPosition;
				lightStrike->m_innerAngle = m_InnerAngle;
				lightStrike->m_outerAngle = m_OuterAngle;
				lightStrike->m_die = memory::interfaces::globalVars->m_curtime + 1e6f;
				lightStrike->m_direction = directionVector;

				memory::interfaces::engineSound->emitAmbientSound(pickRandomSoundForThunder().data(),
					vars::visuals->world->weather->volume, PITCH_NORM, SND_SPAWNING | SND_STOP_LOOPING);
			}

			lastTimeStorm = memory::interfaces::globalVars->m_curtime + Random::getRandom<float>(2.0f, 5.0f);
		}
	}

	if (lightStrike)
	{
		if (lightRapidsCounter < maxRapids)
		{
			constexpr float duration = 0.35f;
			static float currentStrikeRadius = radius;

			if (currentStrikeRadius < radius)
			{
				currentStrikeRadius += (radius / duration) * memory::interfaces::globalVars->m_frametime;
			}
			else
			{
				currentStrikeRadius = 0.0f;
				lightRapidsCounter += 1;

				BeamInfo_t info{ };
				info.m_type = TE_BEAMPOINTS;
				info.m_flags = FBEAM_FADEOUT | FBEAM_ONLYNOISEONCE;
				info.m_modelName = "sprites/bluelightning.vmt";
				info.m_modelIndex = memory::interfaces::modelInfo->getModelIndex("materials/sprites/bluelightning.vmt");
				info.m_haloIndex = -1;
				info.m_haloScale = 0.0f;
				info.m_life = duration + 0.2f;
				info.m_width = 70.0f;
				info.m_endWidth = 2.0f;
				info.m_fadeLength = 1.0f;
				info.m_amplitude = 20.0f;
				info.m_red = 205;
				info.m_green = 180;
				info.m_blue = 255;
				info.m_brightness = 255;
				info.m_speed = 0.0f;
				info.m_startFrame = 0;
				info.m_frameRate = 1.0f;
				const float randomX = Random::getRandom(200.0f, 800.0f);
				const float randomY = Random::getRandom(200.0f, 800.0f);

				const Vec3 directionVector = math::angleVec(game::localPlayer->absAngles());
				const Vec3 localHead = game::localPlayer->getHitboxPos(HITBOX_HEAD);

				info.m_vecStart = Vec3
				{
					localHead[0] + (directionVector[0] * randomX),
					localHead[1] + (directionVector[1] * randomY),
					localHead[2] + 2000.0f // hope its fine 
				};
				info.m_vecEnd = Vec3
				{
					localHead[0] + (directionVector[0] * randomX),
					localHead[1] + (directionVector[1] * randomY),
					game::localPlayer->absOrigin()[2]
				};
				info.m_segments = 35;
				info.m_renderable = true;

				Beam_t* strike = memory::interfaces::beams->createBeamPoints(info);
			}

			lightStrike->m_radius = currentStrikeRadius;
		}
		else
		{
			lightRapidsCounter = 0;
			lightStrike->m_die = memory::interfaces::globalVars->m_curtime;
			lightStrike = nullptr;
		}
	}
}

void weather::precipitation::reset()
{
	// engine does it
	//shutdown();
	weatherFields.ent = nullptr;

	newMap = true;

	preacheCustomFiles(); // this needs to be run on everymap

	lastTimeStorm = memory::interfaces::globalVars->m_curtime + Random::getRandom(2.0f, 5.0f);
	lightRapidsCounter = 0;
}

void weather::precipitation::shutdown()
{
	if (weatherFields.ent)
	{
		// if executed automatically, then remove this entry sound at all
		if (globals::isShutdown)
		{
			const helper::CustomPrecipitationType_t precipType = helper::configToPrecip(vars::visuals->world->weather->type);
			if (precipType != helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_NONE)
			{
				memory::interfaces::engineSound->emitAmbientSound(pickSoundForPrecip(precipType).data(),
					vars::visuals->world->weather->volume, PITCH_NORM, SND_STOP);
			}
		}

		//memory::gPrecipitations().FindAndRemove(weatherFields.ent);		 
		memory::precipDestruct()(weatherFields.ent);
		weatherFields.ent = nullptr;
		memory::interfaces::physicsCollision->vcollideUnload(&weatherFields.collide);
		if(lightStrike)
			lightStrike->m_die = memory::interfaces::globalVars->m_curtime;
		lightStrike = nullptr;
		done = false;
	}
}

void weather::precipitation::loadCollide()
{
	// weather solid counts is always 1, buffer is about 530-550 size with always very similar data, see dumps
	memory::interfaces::physicsCollision->vcollideLoad(&weatherFields.collide, 1, reinterpret_cast<const char*>(weatherBuffer.data()), weatherBuffer.size(), false);
}

vcollide_t& weather::precipitation::getCollide()
{
	return weatherFields.collide;
}

Precipitation_t* weather::precipitation::getPrecip()
{
	if (!done)
		return nullptr;

	return weatherFields.ent;
}

std::string_view weather::precipitation::pickSoundForPrecip(helper::CustomPrecipitationType_t precip)
{
	// some sounds may not play in a loop

	switch (precip)
	{
	case helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_RAIN:
		return "ambient/weather/aztec_rain_lp_01.wav";
	case helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_SNOW:
		return "ambient/wind/lightwind_02.wav";
	case helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAIN:
		return "ambient/weather/rumble_rain_nowind.wav";
	case helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLERAINSTORM:
		return "ambient/weather/rumble_rain.wav";
	case helper::CustomPrecipitationType_t::PRECIPITATION_TYPE_PARTICLESNOW:
		return "ambient/wind/windgust.wav";
	default:
		return "";
	}
}

std::string_view weather::precipitation::pickRandomSoundForThunder()
{
	constexpr std::array allTHunders
	{
		"ambient/weather/thunder1.wav",
		"ambient/weather/thunder2.wav",
		"ambient/weather/thunder3.wav",
		"ambient/weather/thunderstorm/lightning_strike_1.wav",
		"ambient/weather/thunderstorm/lightning_strike_2.wav",
		"ambient/weather/thunderstorm/lightning_strike_3.wav",
		"ambient/weather/thunderstorm/lightning_strike_4.wav"
	};

	return allTHunders.at(Random::getRandom<size_t>(0, allTHunders.size() - 1));
}
```

`hack/cheats/features/visuals/world/weather/precipitation.hpp`:

```hpp
#pragma once

#include <SDK/IVModelInfo.hpp>
#include <SDK/vars.hpp>

#include "helper.hpp"

enum FrameStage;
struct vcollide_t;
class IGameEvent;
class Precipitation_t;
class DynamicLight_t;

namespace weather::precipitation
{
	void init();
	void run(FrameStage stage);
	void reset();
	void shutdown();
	void preacheCustomFiles();
	std::string_view pickSoundForPrecip(helper::CustomPrecipitationType_t precip);

	Precipitation_t* getPrecip();
	vcollide_t& getCollide();

	constexpr int uniqueModelIndex{ MAX_MODELS - 1 };
}
```

`hack/cheats/features/visuals/world/zeus.cpp`:

```cpp
#include "zeus.hpp"

#include <SDK/ICvar.hpp>
#include <SDK/ConVar.hpp>
#include <SDK/IWeapon.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>
#include <utilities/utilities.hpp>
#include <render/render.hpp>

#include <cheats/hooks/paintTraverse.hpp>

namespace
{
	struct ZeusHandlder : hooks::PaintTraverse
	{
		ZeusHandlder()
		{
			this->registerInit(zeus::init);
			this->registerRender(zeus::draw);
			this->registerShutdown(zeus::shutdown);
		}
	} zeusHandler;
}

namespace zeus
{
	IConVar* sv_party_mode;
}

void zeus::init()
{
	sv_party_mode = memory::interfaces::cvar->findVar("sv_party_mode");
}

void zeus::shutdown()
{
	sv_party_mode->setValue(false);
}

void zeus::draw()
{
	if (!game::isAvailable())
		return;

	vars::visuals->world->zeus->party ? sv_party_mode->setValue(true) : sv_party_mode->setValue(false);

	if (!vars::visuals->world->zeus->enabled)
		return;

	auto weapon = game::localPlayer->getActiveWeapon();
	if (!weapon)
		return;

	if (weapon->m_iItemDefinitionIndex() == WEAPON_TASER)
	{
		const static float range = weapon->getWpnInfo()->m_range;
		const Vec3 abs = game::localPlayer->absOrigin() + Vec3{ 0.0f, 0.0f, 30.0f }; // small correction to get correct trace visually, will still throw false positives on stairs etc...

		Color color = vars::visuals->world->zeus->color();

		if (vars::visuals->world->zeus->tracing)
			ImRender::drawCircle3DTraced(abs, range, 64, game::localPlayer(), color, true, 2.5f);
		else
			ImRender::drawCircle3D(abs, range, 64, color, true, 2.0f);
	}
}
```

`hack/cheats/features/visuals/world/zeus.hpp`:

```hpp
#pragma once

namespace zeus
{
	void draw();
	void init();
	void shutdown();
}

```

`hack/cheats/game/game.cpp`:

```cpp
#include "game.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/CUserCmd.hpp>
#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include "../features/cache/cache.hpp"
#include "../helper/initable.hpp"
#include "../helper/shutdownable.hpp"
#include "../features/events/events.hpp"

void game::init()
{
	localPlayer.init();
	EntityCache::init();
	InitAble::Storage::runs.run();
}

void game::shutdown()
{
	ShutdownAble::Storage::shutdowns.run();
	events::shutdown();
}

bool game::isAvailable()
{
	if (!localPlayer)
		return false;

	if (!memory::interfaces::engine->isConnected())
		return false;

	if (!memory::interfaces::engine->isInGame())
		return false;

	return true;
}

float game::serverTime(CUserCmd* cmd)
{
	static int tick;
	static CUserCmd* lastCmd;

	if (cmd)
	{
		if (!lastCmd || lastCmd->m_predicted)
			tick = localPlayer->m_nTickBase();
		else
			tick++;
		lastCmd = cmd;
	}
	return tick * memory::interfaces::globalVars->m_intervalPerTick;
}

void LocalPlayer::init()
{
	m_local = memory::localPlayer();

	console::debug("Local player init");
}

uint32_t game::timeToTicks(float time)
{
	return static_cast<uint32_t>(0.5f + time / memory::interfaces::globalVars->m_intervalPerTick);
}

float game::ticksToTime(uint32_t ticks)
{
	return memory::interfaces::globalVars->m_intervalPerTick * static_cast<float>(ticks);
}

// https://www.unknowncheats.me/forum/counterstrike-global-offensive/183347-bomb-damage-indicator.html
float game::scaleDamageArmor(float dmg, const float armor)
{
	if (armor > 0.0f)
	{
		float newDmg = dmg * 0.5f;
		float scaledArmor = (dmg - newDmg) * 0.5f;

		if (scaledArmor > armor)
		{
			scaledArmor = armor * (1.0f / 0.5f);
			newDmg = dmg - scaledArmor;
		}
		dmg = newDmg;
	}

	return dmg;
}

#include <SDK/CHudChat.hpp>

bool game::isChatOpen()
{
	const auto chat = findHudElement<CHudChat*>("CCSGO_HudChat");
	return chat->m_isOpen;
}

float game::getScaledFont(const Vec3& source, const Vec3& destination, const float division, const float min, const float max)
{
	const float dist = source.distTo(destination);
	const float fontSize = std::clamp(division / (dist / division), min, max);
	return fontSize;
}

#include <SDK/CStudioHdr.hpp>

WeaponIndex game::getNadeByClass(int idx, studiohdr_t* studio)
{
	switch (std::string_view name = studio->m_name; idx)
	{
	case CBaseCSGrenadeProjectile:
	{
		if (name.find("ggrenade") != std::string::npos)
			return WEAPON_HEGRENADE;
		else
			return WEAPON_FLASHBANG;
	}
	case CSmokeGrenadeProjectile:
		return WEAPON_SMOKEGRENADE;
	case CMolotovProjectile:
	{
		if (name.find("molotov") != std::string::npos)
			return WEAPON_MOLOTOV;
		else
			return WEAPON_INCGRENADE;
	}
	case CDecoyProjectile:
		return WEAPON_DECOY;
	default:
		break;
	}

	return WEAPON_NONE;
}

Vec3 game::getViewAngles()
{
	Vec3 ret;
	memory::interfaces::engine->getViewAngles(ret);

	return ret;
}

#include <d3d9.h>
#include <d3dx9.h>
#include <unordered_map>
#include <SDK/IBaseFileSystem.hpp>

#pragma warning (disable : 4244)
#define NANOSVG_IMPLEMENTATION
#include <nanosvg/nanosvg.h>
#define NANOSVGRAST_IMPLEMENTATION
#include <nanosvg/nanosvgrast.h>

#include <cassert>

std::optional<game::BitMapData> getSvgIcon(char* data, const float scale)
{
	constexpr float csDPI = 96.0f;
	NSVGimage* image = nsvgParse(data, "px", csDPI);
	if (!image)
	{
		nsvgDelete(image);
		return std::nullopt;
	}

	NSVGrasterizer* rasterizer = nsvgCreateRasterizer();
	if (!rasterizer)
	{
		nsvgDeleteRasterizer(rasterizer);
		nsvgDelete(image);

		return std::nullopt;
	}

	const auto width = static_cast<size_t>(image->width * scale);
	const auto height = static_cast<size_t>(image->height * scale);
	const auto imgData = std::make_unique<uint8_t[]>(width * height * 4);
	nsvgRasterize(rasterizer, image, 0, 0, scale, imgData.get(), width, height, width * 4);

	LPDIRECT3DTEXTURE9 texture;
	if (memory::interfaces::dx9Device->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &texture, NULL) != D3D_OK)
		return std::nullopt;

	D3DLOCKED_RECT lockedRect;
	constexpr UINT levelLock = 0U;
	if (texture->LockRect(levelLock, &lockedRect, NULL, 0) != D3D_OK)
		return std::nullopt;

	for (size_t y = 0; y < height; ++y)
	{
		const auto src = imgData.get() + y * width * 4;
		const auto dst = static_cast<uint8_t*>(lockedRect.pBits) + y * lockedRect.Pitch;
		std::ranges::copy(src, src + width * 4, dst);
	}

	texture->UnlockRect(levelLock);

	const auto fwidth = image->width * scale;
	const auto fheight = image->width * scale;

	nsvgDeleteRasterizer(rasterizer);
	nsvgDelete(image);

	return game::BitMapData{ .width = fwidth, .height = fheight, .texture = texture };
}

std::optional<game::BitMapData> getIconTexture(const std::string& path, float scale)
{
	const auto file = memory::interfaces::baseFileSystem->open(path.c_str(), "r", "GAME");
	if (!file)
		return std::nullopt;

	std::vector<char> buffer(memory::interfaces::baseFileSystem->size(file));

	memory::interfaces::baseFileSystem->read(buffer.data(), buffer.size(), file);
	memory::interfaces::baseFileSystem->close(file);

	const auto texture = getSvgIcon(buffer.data(), scale);
	if (!texture.has_value())
		return std::nullopt;

	return texture;
}

game::BitMapData game::getWeaponIcon(const std::string_view weapon)
{
	static std::unordered_map<std::string_view, BitMapData> icons;

	if (const auto itr = icons.find(weapon); itr != icons.end())
		return itr->second;

	// remove weapon_ prefix!
	const std::string path = std::format("materials/panorama/images/icons/equipment/{}.svg", weapon.substr(7));
	const auto maybetexture = getIconTexture(path, 1.0f);

	assert(maybetexture.has_value() == true);
	icons.emplace(weapon, maybetexture.value());

	return maybetexture.value();
}

game::BitMapData game::getImage(const std::string& path)
{
	static std::unordered_map<std::string, BitMapData> pics;

	if (const auto itr = pics.find(path); itr != pics.end())
		return itr->second;

	const auto file = memory::interfaces::baseFileSystem->open(path.c_str(), "r", "GAME");
	assert(file != nullptr);

	std::vector<char> buffer(memory::interfaces::baseFileSystem->size(file));

	memory::interfaces::baseFileSystem->read(buffer.data(), buffer.size(), file);
	memory::interfaces::baseFileSystem->close(file);

	LPDIRECT3DTEXTURE9 texture;
	const auto hrRes = D3DXCreateTextureFromFileInMemory(memory::interfaces::dx9Device(), buffer.data(), buffer.size(), &texture);
	assert(hrRes == D3D_OK);

	D3DSURFACE_DESC desc;
	texture->GetLevelDesc(0, &desc);

	const auto bitmap = game::BitMapData{ .width = static_cast<float>(desc.Width), .height = static_cast<float>(desc.Height), .texture = texture };
	pics.emplace(path, bitmap);

	return bitmap;
}

```

`hack/cheats/game/game.hpp`:

```hpp
#pragma once

#include <SDK/structs/Entity.hpp>
#include <gamememory/memory.hpp>

class CUserCmd;
struct studiohdr_t;
struct IDirect3DTexture9;
using LPDIRECT3DTEXTURE9 = IDirect3DTexture9*;

class LocalPlayer final
{
public:
	// 
	constexpr LocalPlayer()
		: m_local{ nullptr }
	{}
	// do it once only
	void init();
	// ent == localplayer
	[[nodiscard]] constexpr bool operator==(void* ent) const { return *m_local == ent; }
	// !localplayer
	[[nodiscard]] constexpr bool operator!() const { return *m_local == nullptr; }
	// get pointer to localplayer
	[[nodiscard]] constexpr Player_t* operator()() const { return *m_local; }
	// operator for making it like normal pointer
	// possible alternative use: localplayer()->
	// ^ uses no overloaded operator
	[[nodiscard]] constexpr Player_t* operator->() const { return *m_local; }
private:
	Player_t** m_local;
};

namespace game
{
	struct BitMapData
	{
		float width, height;
		LPDIRECT3DTEXTURE9 texture;
	};

	HACK_INIT void init();
	void shutdown();

	inline LocalPlayer localPlayer;
	[[nodiscard]] bool isAvailable();
	float serverTime(CUserCmd* cmd = nullptr);
	[[nodiscard]] uint32_t timeToTicks(float time);
	[[nodiscard]] float ticksToTime(uint32_t ticks);
	[[nodiscard]] float scaleDamageArmor(float dmg, const float armor);
	template<typename T = uintptr_t*>
	[[nodiscard]] T findHudElement(const std::string_view name);
	[[nodiscard]] bool isChatOpen();
	[[nodiscard]] float getScaledFont(const Vec3& source, const Vec3& destination, const float division = 80.0f, const float min = 12.0f, const float max = 30.0f);
	// studio is special case arg - because henade and flashbang have exactly same class id
	// and people who think definition index is ok are wrong, player ents DON'T hold the nade anymore in that case
	[[nodiscard]] WeaponIndex getNadeByClass(int idx, studiohdr_t* studio);
	[[nodiscard]] Vec3 getViewAngles();
	[[nodiscard]] BitMapData getWeaponIcon(const std::string_view weapon);
	// not for svg, string_view is not passed due to high possibility of using std::format
	// eg path: resource/flash/econ/weapons/base_weapons/ + weapon name + .png
	[[nodiscard]] BitMapData getImage(const std::string& path);
}

template<typename T>
T game::findHudElement(const std::string_view name)
{
	return reinterpret_cast<T>(memory::hudfindElement()(memory::csgoHud(), name.data()));
}
```

`hack/cheats/game/globals.hpp`:

```hpp
#pragma once

#include <Windows.h>

namespace globals
{
	inline float FOV = 90.0f;
	inline HMODULE instance = NULL;
	inline int screenX = 0;
	inline int screenY = 0;
	inline int mouseX = 0;
	inline int mouseY = 0;
	inline HWND csgoWHND = NULL;
	inline bool isShutdown = false;
	inline bool isInHotkey = false;
}
```

`hack/cheats/helper/initable.hpp`:

```hpp
#pragma once

#include <utilities/runnable.hpp>

#include <cheats/game/game.hpp>

class InitAble
{
	friend void game::init();
protected:
	static void registerInit(const std::function<void()>& func) { Storage::runs.push_back(func); }
private:
	struct Storage
	{
		inline static vectorRunnable<std::function<void()>> runs;
	};
};
```

`hack/cheats/helper/shutdownable.hpp`:

```hpp
#pragma once

#include <utilities/runnable.hpp>

#include <cheats/game/game.hpp>

class ShutdownAble
{
	friend void game::shutdown();
protected:
	static void registerShutdown(const std::function<void()>& func) { Storage::shutdowns.push_back(func); }
private:
	struct Storage
	{
		inline static vectorRunnable<std::function<void()>> shutdowns;
	};
};
```

`hack/cheats/hooks/addEntity.cpp`:

```cpp
#include "hooks.hpp"

#include <SDK/IClientEntityList.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/features/cache/cache.hpp>
#include "addEntity.hpp"

hooks::AddEntity::value hooks::AddEntity::hook(HACK_FAST_ARGS, void* handleEnt, CBaseHandle handle)
{
	Entity_t* ent = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientFromHandle(handle));
	
	EntityCache::add(ent);
	
	original(thisptr, handleEnt, handle);
}

```

`hack/cheats/hooks/addEntity.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/EHandle.hpp>

_HOOK_BEGIN
class AddEntity
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, void*, CBaseHandle);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, void*, CBaseHandle handle);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/allocKeyvalues.cpp`:

```cpp
#include "allocKeyvalues.hpp"

#include <gamememory/memory.hpp>

#include <intrin.h>

hooks::AllocKeyValues::value hooks::AllocKeyValues::hook(HACK_FAST_ARGS, size_t size)
{
	if (reinterpret_cast<uintptr_t>(_ReturnAddress()) == memory::allocKeyValuesEngine()
		|| reinterpret_cast<uintptr_t>(_ReturnAddress()) == memory::allocKeyValuesClient())
	{
		return nullptr;
	}

	return original(thisptr, size);
}

```

`hack/cheats/hooks/allocKeyvalues.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class AllocKeyValues
{
	ADD_HOOK_FRIEND;
private:
	using value = void*;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, size_t);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, size_t size);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/buildTransformations.cpp`:

```cpp
#include "buildTransformations.hpp"

#include <SDK/vars.hpp>

// prevent spoofing convar for jiggle bones
hooks::BuildTransformations::value hooks::BuildTransformations::hook(HACK_FAST_ARGS, CStudioHdr* hdr, void* pos, void* q, const Matrix3x4& matrix, int boneMask, void* computed)
{
	CUtlVector<int> flags = hdr->m_boneFlags;
	for (int i = 0; i < hdr->m_boneFlags.m_size; i++)
	{
		hdr->m_boneFlags.m_elements[i] &= ~BONE_ALWAYS_PROCEDURAL;
	}

	original(thisptr, hdr, pos, q, matrix, boneMask, computed);

	hdr->m_boneFlags = flags;
}
```

`hack/cheats/hooks/buildTransformations.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/math/matrix.hpp>
#include <SDK/math/vector.hpp>
#include <SDK/CStudioHdr.hpp>

_HOOK_BEGIN
class BuildTransformations
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, CStudioHdr*, void*, void*, const Matrix3x4&, int, void*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, CStudioHdr* hdr, void* pos, void* q, const Matrix3x4& matrix, int boneMask, void* computed);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/cHudIsHidden.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class CHudIsHidden
{
	ADD_HOOK_FRIEND;
private:
	using value = bool;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, int);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, int flags);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/chudIsHidden.cpp`:

```cpp
#include "cHudIsHidden.hpp"

#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include <SDK/structs/Entity.hpp>

// or hook CHudElement::ShouldDraw() and do this here, and set the field inside CHudElement stackptr
hooks::CHudIsHidden::value hooks::CHudIsHidden::hook(HACK_FAST_ARGS, int flags)
{
	if (vars::misc->radar->enabled && game::isAvailable())
	{
		// m_bHud_RadarHidden forcing didn't work
		game::localPlayer->m_iHideHUD() |= HIDEHUD_RADAR;
	}
	
	// return true if all elements should be disabled
	return original(thisptr, flags);
}
```

`hack/cheats/hooks/clientModeCSNormalEvent.cpp`:

```cpp
#include "clientModeCSNormalEvent.hpp"

hooks::ClientModeCSNormalEvent::value hooks::ClientModeCSNormalEvent::hook(HACK_FAST_ARGS, IGameEvent* _event)
{
	Storage::runs.run(_event);

	original(thisptr, _event);
}
```

`hack/cheats/hooks/clientModeCSNormalEvent.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/IGameEvent.hpp>

_HOOK_BEGIN
class ClientModeCSNormalEvent
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, IGameEvent*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, IGameEvent* _event);
	inline static call original;

	using clRun = std::function<void(IGameEvent*)>;
protected:
	void registerEvent(const clRun& callback) { Storage::runs.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clRun> runs;
	};
};
_HOOK_END
```

`hack/cheats/hooks/createEvent.cpp`:

```cpp
#include "createEvent.hpp"

hooks::CreateEvent::value HACK_FASTCALL hooks::CreateEvent::hook(HACK_FAST_ARGS, const char* name, bool allowed, uint32_t unk)
{
	//allowed = true;

	return original(thisptr, name, allowed, unk);
}
```

`hack/cheats/hooks/createEvent.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/IGameEvent.hpp>

#undef CreateEvent

_HOOK_BEGIN
class CreateEvent
{
	ADD_HOOK_FRIEND;
private:
	using value = IGameEvent*;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, const char*, bool, uint32_t);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, const char* name, bool allowed, uint32_t unk);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/createMove.cpp`:

```cpp
#include "createMove.hpp"

#include "../features/prediction/prediction.hpp"
#include "../features/misc/movement/movement.hpp"
#include "../features/misc/cameras/freeCam.hpp"

#include <SDK/CUserCmd.hpp>
#include <SDK/Input.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/ClientClass.hpp>
#include <SDK/IPrediction.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>

hooks::CreateMove::value hooks::CreateMove::hook(HACK_FAST_ARGS, float inputFrame, CUserCmd* cmd)
{
	original(thisptr, inputFrame, cmd);

	if (!cmd || !cmd->m_commandNumber || !game::localPlayer)
		return original(thisptr, inputFrame, cmd);

	// thanks for reminding me https://github.com/Bartis1313/csgo/issues/4
	if (original(thisptr, inputFrame, cmd))
		memory::interfaces::prediction->setLocalViewangles(cmd->m_viewangles);

	static std::once_flag onceFlag;
	std::call_once(onceFlag, []() { Storage::inits.run(); });

	Vec3 oldAngle = cmd->m_viewangles;

	// otherwise we moving
	if (freecam::isInCam)
	{
		cmd->m_buttons = 0;
		cmd->m_forwardmove = 0;
		cmd->m_sidemove = 0;
		cmd->m_upmove = 0;
	}

	game::serverTime(cmd);

	Storage::runsPrePrediction.run(cmd);
	{
		prediction::begin(cmd);
		Storage::runsPrediction.run(cmd);
		prediction::end();
	}
	Storage::runsPostPrediction.run(cmd);

	movement::fixMovement(cmd, oldAngle);

	// don't get untrusted
	cmd->m_viewangles[0] = std::clamp(cmd->m_viewangles[0], -89.0f, 89.0f);
	cmd->m_viewangles[1] = std::clamp(cmd->m_viewangles[1], -180.0f, 180.0f);
	cmd->m_viewangles[2] = 0.0f;

	cmd->m_forwardmove = std::clamp(cmd->m_forwardmove, -450.0f, 450.0f);
	cmd->m_sidemove = std::clamp(cmd->m_sidemove, -450.0f, 450.0f);
	cmd->m_upmove = std::clamp(cmd->m_upmove, -320.0f, 320.0f);

	cmd->m_viewAnglesCopy = cmd->m_viewangles;
	cmd->m_buttonsCopy = cmd->m_buttons;

	return false;
}
```

`hack/cheats/hooks/createMove.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/CUserCmd.hpp>

_HOOK_BEGIN
class CreateMove
{
	ADD_HOOK_FRIEND;
private:
	using value = bool;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, float, CUserCmd*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, float inputFrame, CUserCmd* cmd);
	inline static call original;

	using clInit = std::function<void()>;
	using clRun = std::function<void(CUserCmd*)>;
	using clShutdown = std::function<void()>;
protected:
	void registerInit(const clInit& callback) { Storage::inits.push_back(callback); }
	void registerRunPrePrediction(const clRun& callback) { Storage::runsPrePrediction.push_back(callback); }
	void registerRunPrediction(const clRun& callback) { Storage::runsPrediction.push_back(callback); }
	void registerRunPostPrediction(const clRun& callback) { Storage::runsPostPrediction.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clInit> inits;
		inline static vectorRunnable<clRun> runsPrePrediction;
		inline static vectorRunnable<clRun> runsPrediction;
		inline static vectorRunnable<clRun> runsPostPrediction;
	};
};
_HOOK_END
```

`hack/cheats/hooks/createParticlePrecip.cpp`:

```cpp
#include "createParticlePrecip.hpp"

#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/CUtlVector.hpp>

#include <gamememory/memory.hpp>

#include <SDK/structs/Entity.hpp>

hooks::CreateParticlePrecip::value hooks::CreateParticlePrecip::hook(HACK_FAST_ARGS)
{
	auto precip = reinterpret_cast<Precipitation_t*>(thisptr);
	bool m_bParticlePrecipInitialized = precip->m_bParticlePrecipInitialized();

	if (!m_bParticlePrecipInitialized)
	{
		hooks::calledInitprecip = true;
	}
	else
	{
		hooks::calledInitprecip = false;
	}

	original(thisptr);
}
```

`hack/cheats/hooks/createParticlePrecip.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class CreateParticlePrecip
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/decalAddToSurface.cpp`:

```cpp
#include "decalAddToSurface.hpp"

hooks::R_AddDecalToSurface::value hooks::R_AddDecalToSurface::hook(void* a1, void* a2, void* a3, void* a4)
{
	//printf("called\n");

	return original(a1, a2, a3, a4);
}
```

`hack/cheats/hooks/decalAddToSurface.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/CCommonHostState.hpp>

_HOOK_BEGIN
class R_AddDecalToSurface
{
	ADD_HOOK_FRIEND;
private:
	using value = int*;
	using call = value(HACK_CDECL*)(void*, void*, void*, void*);

	static value HACK_CDECL hook(void*, void*, void*, void*);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/decalCreate.cpp`:

```cpp
#include "decalCreate.hpp"

#include <SDK/material.hpp>

hooks::R_DecalCreate::value hooks::R_DecalCreate::hook(int a1, int a2, int a3, int a4, int a5, char a6, char a7)
{
	original(a1, a2, a3, a4, a5, a6, a7);
}
```

`hack/cheats/hooks/decalCreate.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/CCommonHostState.hpp>

_HOOK_BEGIN
class R_DecalCreate
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_CDECL*)(int, int, int, int, int, char, char);

	static value HACK_CDECL hook(int a1, int a2, int a3, int a4, int a5, char a6, char a7);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/dispatchInnerParticlePrecip.cpp`:

```cpp
#include "dispatchInnerParticlePrecip.hpp"

hooks::DispatchInnerParticlePrecip::value hooks::DispatchInnerParticlePrecip::hook(HACK_FAST_ARGS, int slot, void* player, Vec3 vec)
{
	original(thisptr, slot, player, vec);
}
```

`hack/cheats/hooks/dispatchInnerParticlePrecip.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/math/Vector.hpp>

_HOOK_BEGIN
class DispatchInnerParticlePrecip
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, int, void*, Vec3);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, int slot, void* player, Vec3 forward);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/doExtraBonesProcessing.cpp`:

```cpp
#include "doExtraBonesProcessing.hpp"

hooks::DoExtraBonesProcessing::value hooks::DoExtraBonesProcessing::hook(HACK_FAST_ARGS, [[maybe_unused]] void* hdr, [[maybe_unused]] void* pos,
	[[maybe_unused]] void* q, [[maybe_unused]] const Matrix3x4& matrix,
	[[maybe_unused]] void* computed, [[maybe_unused]] void* contex)
{
	return;
}
```

`hack/cheats/hooks/doExtraBonesProcessing.hpp`:

```hpp
#pragma once

#pragma once

#include "helpers/common.hpp"

#include <SDK/math/matrix.hpp>

_HOOK_BEGIN
class DoExtraBonesProcessing
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, void*, void*, void*, const Matrix3x4&, void*, void*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, [[maybe_unused]] void* hdr, [[maybe_unused]] void* pos,
		[[maybe_unused]] void* q, [[maybe_unused]] const Matrix3x4& matrix,
		[[maybe_unused]] void* computed, [[maybe_unused]] void* contex);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/doPostScreenEffects.cpp`:

```cpp
#include "doPostScreenEffects.hpp"

#include <cheats/features/visuals/streamproof/streamproof.hpp>
#include <cheats/features/visuals/glow/glow.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>
#include "viewFade.hpp"
#include "particlesSimulation.hpp"

#include <SDK/IViewRender.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/material.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/CParticelCollection.hpp>
#include <cheats/features/visuals/glow/glow.hpp>
#include <gamememory/memory.hpp>

hooks::DoPostScreenEffects::value hooks::DoPostScreenEffects::hook(HACK_FAST_ARGS, int val)
{
	if (globals::isShutdown)
	{
		static std::once_flag onceFlag;
		std::call_once(onceFlag, []() { Storage::shutdowns.run(); });
		return original(thisptr, val);
	}

	static std::once_flag onceFlag;
	std::call_once(onceFlag, []() { Storage::inits.run(); });
	
	const auto ret = original(thisptr, val);

	glow::streamProof.setActive(game::isAvailable() && vars::visuals->glow->streamProof);

	glow::streamProof.beginMaterialHook();

	Storage::runs.run();

	glow::streamProof.endMaterialHook();
	return ret;
}
```

`hack/cheats/hooks/doPostScreenEffects.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class DoPostScreenEffects
{
	ADD_HOOK_FRIEND;
private:
	using value = int;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, int);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, int val);
	inline static call original;

	using cl = std::function<void()>;
protected:
	void registerInit(const cl& callback) { Storage::inits.push_back(callback); }
	void registerRun(const cl& callback) { Storage::runs.push_back(callback); }
	void registerShutdown(const cl& callback) { Storage::shutdowns.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<cl> inits;
		inline static vectorRunnable<cl> runs;
		inline static vectorRunnable<cl> shutdowns;
	};
};
_HOOK_END
```

`hack/cheats/hooks/drawEffects.cpp`:

```cpp
#include "drawEffects.hpp"

hooks::DrawEffects::value hooks::DrawEffects::hook(HACK_FAST_ARGS, double framerate)
{
	original(thisptr, framerate);
}
```

`hack/cheats/hooks/drawEffects.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/Enums.hpp>
#include <SDK/CViewSetup.hpp>

_HOOK_BEGIN
class DrawEffects
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, double);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, double framerate);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/drawIndexPrimitive.cpp`:

```cpp
#include "drawIndexPrimitive.hpp"

#include <gamememory/memory.hpp>

// not placed in SDK, unique use-case
//struct MaterialEbp
//{
//private:
//	void* context1; // 2, probs due to 2 textures in here
//	void* context2;
//	void* stack; // is present before material is not null
//public:
//	IMaterial* material;
//private:
//	void* dynamicProp; // attachment
//	void* unkStack;
//	int unkMaybeInit;
//	void* texture1;
//	void* texture2;
//	void* heapAfterTextureCleanup;
//};

// data[0] - all combined? some global instance of stack materials
// data[1] - studiorender
// data[2] - materialsystem
// data[3] - world render list
// data[4] - entity
// ... many other heaps that pretty often are copies / post calls results. Don't need this here
static volatile void* getStack(volatile void** data)
{
	if (IsBadReadPtr(data, sizeof(void*)))
		return nullptr;

	auto next = data ? *(volatile void***)(data) : nullptr;

	if(!next)
		return nullptr;

	const static auto retAddr = memory::renderDrawPoints();
	if (next && data[1] == retAddr)
	{
		/*auto m = *reinterpret_cast<IMaterial**>((uintptr_t)data[2] + 0xC);
		if (m)
		{
			printf("%s\n", m->getName());
		}*/

		return next[4];
	}

	return getStack(next);
}

hooks::DrawIndexedPrimitive::value hooks::DrawIndexedPrimitive::hook(IDirect3DDevice9* device, D3DPRIMITIVETYPE primType, INT basevertexIndex, UINT minVertexIndex,
	UINT numVertices, UINT startIndex, UINT primCount)
{
	if (globals::isShutdown)
	{
		static std::once_flag onceFlag;
		std::call_once(onceFlag, []() { Storage::shutdowns.run(); });
		return original(device, primType, basevertexIndex, minVertexIndex, numVertices, startIndex, primCount);
	}

	volatile void** data{ };
	__asm mov data, ebp
	
	auto test = getStack(data);

	static std::once_flag onceFlag;
	std::call_once(onceFlag, []() { Storage::inits.run(); });

	Storage::runs.run(device, primType, basevertexIndex, minVertexIndex, numVertices, startIndex, primCount);

	return original(device, primType, basevertexIndex, minVertexIndex, numVertices, startIndex, primCount);
}
```

`hack/cheats/hooks/drawIndexPrimitive.hpp`:

```hpp
#pragma once

#include <d3d9.h>

#include "helpers/common.hpp"

_HOOK_BEGIN
class DrawIndexedPrimitive
{
	ADD_HOOK_FRIEND;
private:
	using value = HRESULT;
	using call = value(D3DAPI*)(IDirect3DDevice9*, D3DPRIMITIVETYPE, INT, UINT, UINT, UINT, UINT);

	static value D3DAPI hook(IDirect3DDevice9* device, D3DPRIMITIVETYPE primType, INT basevertexIndex, UINT minVertexIndex, UINT numVertices, UINT startIndex, UINT primCount);
	inline static call original;

	using clInit = std::function<void()>;
	using clRun = std::function<void(IDirect3DDevice9*, D3DPRIMITIVETYPE, INT, UINT, UINT, UINT, UINT)>;
protected:
	void registerInit(const clInit& callback) { Storage::inits.push_back(callback); }
	void registerRun(const clRun& callback) { Storage::runs.push_back(callback); }
	void registerShutdown(const clInit& callback) { Storage::shutdowns.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clInit> inits;
		inline static vectorRunnable<clRun> runs;
		inline static vectorRunnable<clInit> shutdowns;
	};
};
_HOOK_END
```

`hack/cheats/hooks/drawModelExecute.cpp`:

```cpp
#include "drawModelExecute.hpp"

#include <cheats/features/visuals/chams/chams.hpp>
#include <cheats/features/visuals/chams/editor.hpp>
#include <config/vars.hpp>

#include <cheats/features/visuals/glow/glow.hpp>
#include <SDK/material.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/KeyValuesSys.hpp>
#include <SDK/KeyValues.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/IVModelRender.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/IVStudioRender.hpp>
#include <SDK/IMatRenderContext.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/materialInit.hpp>
#include <SDK/structs/Entity.hpp>
#include <cheats/game/game.hpp>

hooks::DrawModelExecute::value hooks::DrawModelExecute::hook(HACK_FAST_ARGS, IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix)
{
	if (globals::isShutdown)
	{
		static std::once_flag onceFlag;
		std::call_once(onceFlag, []() { Storage::shutdowns.run(); });
		return original(thisptr, ctx, state, info, matrix);
	}

	static std::once_flag onceFlag;
	std::call_once(onceFlag, []() { Storage::inits.run(); });

	if (memory::interfaces::modelRender->isForcedMaterial())
		return original(thisptr, ctx, state, info, matrix);

	Storage::runs.run(ctx, state, info, matrix);

	if (chams::DME::run(ctx, state, info, matrix))
		return;

	if (chams::DME::shouldDisableDME(info))
		return;

	original(thisptr, ctx, state, info, matrix);

	memory::interfaces::modelRender->overrideMaterial(nullptr);
}
```

`hack/cheats/hooks/drawModelExecute.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/IVModelRender.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/IMatRenderContext.hpp>
#include <SDK/interfaces/interfaces.hpp>

_HOOK_BEGIN
class DrawModelExecute
{
public:
	static auto getOriginal() { return original; }
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, IMatRenderContext*, const DrawModelState_t&, const ModelRenderInfo_t&, Matrix3x4*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& info, Matrix3x4* matrix);
	inline static call original;

	using clInit = std::function<void()>;
	using clRun = std::function<void(IMatRenderContext*, const DrawModelState_t&, const ModelRenderInfo_t&, Matrix3x4*)>;
protected:
	void registerInit(const clInit& callback) { Storage::inits.push_back(callback); }
	void registerRun(const clRun& callback) { Storage::runs.push_back(callback); }
	void registerShutdown(const clInit& callback) { Storage::shutdowns.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clInit> inits;
		inline static vectorRunnable<clRun> runs;
		inline static vectorRunnable<clInit> shutdowns;
	};
};
_HOOK_END
```

`hack/cheats/hooks/drawSetColor.cpp`:

```cpp
#include "drawSetColor.hpp"

#include <gamememory/memory.hpp>
#include <config/vars.hpp>

#include <intrin.h>

hooks::setDrawColor::value hooks::setDrawColor::hook(HACK_FAST_ARGS, int r, int g, int b, int a)
{
	const auto ret = reinterpret_cast<uintptr_t>(_ReturnAddress());

	if (vars::misc->scope->enabled)
	{
		if (ret == memory::scopeArc() || ret == memory::scopeDust())
		{
			a = 0;
		}
	}

	return original(thisptr, r, g, b, a);
}
```

`hack/cheats/hooks/drawSetColor.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class setDrawColor
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, int, int, int, int);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, int r, int g, int b, int a);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/drawTranslucentRenderables.cpp`:

```cpp
#include "drawTranslucentRenderables.hpp"

#include <cheats/features/visuals/chams/chams.hpp>
#include <config/vars.hpp>

static void renderChams()
{
	chams::streamProof.setActive(vars::visuals->chams->streamProof);
	chams::streamProof.beginMaterialHook();
	chams::manual::run();
	chams::streamProof.endMaterialHook();
}

hooks::DrawTranslucentRenderables::value hooks::DrawTranslucentRenderables::hook(HACK_FAST_ARGS, bool inSkybox, bool shadowDepth)
{
	const bool renderThroughSmoke = vars::visuals->chams->ignoreSmoke;

	if (!renderThroughSmoke)
	{
		renderChams();
		original(thisptr, inSkybox, shadowDepth);
	}
	else
	{
		original(thisptr, inSkybox, shadowDepth);
		renderChams();
	}
}
```

`hack/cheats/hooks/drawTranslucentRenderables.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class DrawTranslucentRenderables
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, bool, bool);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, bool inSkybox, bool shadowDepth);
	inline static call original;
};
_HOOK_END

```

`hack/cheats/hooks/drawWorldAndEntities.cpp`:

```cpp
#include "drawWorldAndEntities.hpp"

#include "particlesSimulation.hpp"

#include <cheats/features/visuals/chams/chams.hpp>

hooks::DrawWorldAndEntities::value hooks::DrawWorldAndEntities::hook(HACK_FAST_ARGS, bool drawSkybox, const CViewSetup& viewIn, int clearFlags, void* customVisibility)
{
	original(thisptr, drawSkybox, viewIn, clearFlags, customVisibility);
}
```

`hack/cheats/hooks/drawWorldAndEntities.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/CViewSetup.hpp>

_HOOK_BEGIN
class DrawWorldAndEntities
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, bool, const CViewSetup&, int, void*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, bool drawSkybox, const CViewSetup& viewIn, int clearFlags, void* customVisibility);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/filesCheck.cpp`:

```cpp
#include "filesCheck.hpp"

hooks::FilesCheck::value hooks::FilesCheck::hook(HACK_FAST_ARGS)
{
	return 1; // 2 is kick
}
```

`hack/cheats/hooks/filesCheck.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class FilesCheck
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = int;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/findMaterial.cpp`:

```cpp
#include "findMaterial.hpp"

#include <cheats/features/visuals/world/weather/ground.hpp>

hooks::FindMaterial::value hooks::FindMaterial::hook(HACK_FAST_ARGS, char const* name, const char* group, bool complain, const char* prefix)
{
	const std::string_view sName = std::string_view{ name };

	auto mat = original(thisptr, name, group, complain, prefix);
	auto custom = weather::ground::applyFindMat(mat);

	return custom ? custom : mat;
}
```

`hack/cheats/hooks/findMaterial.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"
#include <SDK/material.hpp>

// char const* name, const char* group, bool complain = true, const char* prefix = nullptr

_HOOK_BEGIN
class FindMaterial
{
	ADD_HOOK_FRIEND;
private:
	using value = IMaterial*;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, char const* name, const char* group, bool complain, const char* prefix);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, char const* name, const char* group, bool complain, const char* prefix);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/frameStageNotify.cpp`:

```cpp
#include "frameStageNotify.hpp"

hooks::FrameStageNotify::value hooks::FrameStageNotify::hook(HACK_FAST_ARGS, FrameStage stage)
{
	if (globals::isShutdown)
	{
		static std::once_flag onceFlag;
		std::call_once(onceFlag, []() { Storage::shutdowns.run(); });
		return original(thisptr, stage);
	}

	static std::once_flag onceFlag;
	std::call_once(onceFlag, []() { Storage::inits.run(); });

	Storage::runs.run(stage);

	original(thisptr, stage);
}

```

`hack/cheats/hooks/frameStageNotify.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/Enums.hpp>

_HOOK_BEGIN
class FrameStageNotify
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, FrameStage);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, FrameStage stage);
	inline static call original;

	using clInit = std::function<void()>;
	using clRun = std::function<void(FrameStage)>;
protected:
	void registerInit(const clInit& callback) { Storage::inits.push_back(callback); }
	void registerRun(const clRun& callback) { Storage::runs.push_back(callback); }
	void registerShutdown(const clInit& callback) { Storage::shutdowns.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clInit> inits;
		inline static vectorRunnable<clRun> runs;
		inline static vectorRunnable<clInit> shutdowns;
	};
};
_HOOK_END
```

`hack/cheats/hooks/getColorModulation.cpp`:

```cpp
#include "getColorModulation.hpp"

#include <cheats/features/visuals/world/modulateColors.hpp>

hooks::GetColorModulation::value hooks::GetColorModulation::hook(HACK_FAST_ARGS, float* r, float* g, float* b)
{
	original(thisptr, r, g, b);

	modulateColor::run(thisptr, r, g, b);
}
```

`hack/cheats/hooks/getColorModulation.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/Enums.hpp>

_HOOK_BEGIN
class GetColorModulation
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, float*, float*, float*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, float* r, float* g, float* b);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/getPMaterial.cpp`:

```cpp
#include "getPMaterial.hpp"

// called on init only, as cached materials
hooks::GetPMaterial::value hooks::GetPMaterial::hook(HACK_FAST_ARGS, const char* name)
{
#ifdef _DEBUG
	//printf("name %s\n", name);
#endif

	return original(thisptr, name);
}
```

`hack/cheats/hooks/getPMaterial.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/EHandle.hpp>

_HOOK_BEGIN
class GetPMaterial
{
	ADD_HOOK_FRIEND;
private:
	using value = void*;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, const char*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, const char* name);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/getPhysicsProperties.cpp`:

```cpp
#include "getPhysicsProperties.hpp"

hooks::GetPhysicsProperties::value hooks::GetPhysicsProperties::hook(HACK_FAST_ARGS, int index, float* density, float* thickness, float* friction, float* elasticity)
{
	original(thisptr, index, density, thickness, friction, elasticity);

	printf("for model index %i\n", index);
}
```

`hack/cheats/hooks/getPhysicsProperties.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class GetPhysicsProperties
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, int, float*, float*, float*, float*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, int index, float* density, float* thickness, float* friction, float* elasticity);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/getUnverifiedFileHashes.cpp`:

```cpp
#include "getUnverifiedFileHashes.hpp"

hooks::GetUnverifiedFileHashes::value hooks::GetUnverifiedFileHashes::hook(HACK_FAST_ARGS, int maxFiles)
{
	return 0;
}
```

`hack/cheats/hooks/getUnverifiedFileHashes.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class GetUnverifiedFileHashes
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = int;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, int);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, int maxFiles);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/getVCollide.cpp`:

```cpp
#include "getVCollide.hpp"

#include <gamememory/memory.hpp>
#include <SDK/CUtlVector.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>

#include <cheats/game/game.hpp>
#include <utilities/console/console.hpp>

#include <cheats/features/visuals/world/weather/precipitation.hpp>
#include <utilities/console/console.hpp>

#include <intrin.h>

// server modelinfo
// 8B 0D ? ? ? ? 8B 04 B0 0F BF 90 ? ? ? ? 8B 01 52 FF 50 18 85 C0 0F 84 ? ? ? ? B9 ? ? ? ? 66 85 08 0F 86 ? ? ? ? 8B 0D ? ? ? ? 8D 5D F4 8B 40 04 53 8B 11

// if we get null, we can't get rain meshes working! this is for particle type case
// so for own handling we need to provide generated vcollide
hooks::GetVCollide::value hooks::GetVCollide::hook(HACK_FAST_ARGS, int modelIndex)
{
    auto org = original(thisptr, modelIndex);
    
#if DUMP_WEATHER == true
    if (hooks::calledInitprecip)
    {
        if (org)
        {
            console::debug("COLLIDE WEATHER DUMP");
            console::debug("solidcount : {}, descSize : {}", static_cast<size_t>(org->solidCount), static_cast<size_t>(org->descSize)); // 1, 84
            console::debug("END COLLIDE WEATHER DUMP");
        }
    }
#endif


    if (reinterpret_cast<uintptr_t>(_ReturnAddress()) == memory::particleGetVCollideRet())
    {
        if (modelIndex == weather::precipitation::uniqueModelIndex)
            return &weather::precipitation::getCollide();
    }

    return org;
}
```

`hack/cheats/hooks/getVCollide.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/IVModelInfo.hpp>

_HOOK_BEGIN
class GetVCollide
{
	ADD_HOOK_FRIEND;
private:
	using value = vcollide_t*;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, int);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, int modelIndex);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/getVelocity.cpp`:

```cpp
#include "getVelocity.hpp"

hooks::GetVelocity::value hooks::GetVelocity::hook(HACK_FAST_ARGS, Vec3* a1, Vec3* a2)
{
	printf("called\n");
	return original(thisptr, a1, a2);
}
```

`hack/cheats/hooks/getVelocity.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/math/Vector.hpp>

_HOOK_BEGIN
class GetVelocity
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, Vec3* a1, Vec3* a2);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, Vec3* a1, Vec3* a2);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/helpers/common.hpp`:

```hpp
#pragma once

#include "../hooks.hpp"

#include <utilities/runnable.hpp>
#include <cheats/game/globals.hpp>

#define _HOOK_BEGIN			namespace hooks {
#define _HOOK_END			}

// we somehow need to pass option for private fields for place where hooks init
#define ADD_HOOK_FRIEND		friend void hooks::init(); friend void hooks::shutdown();
```

`hack/cheats/hooks/helpers/helper.hpp`:

```hpp
#pragma once

#include <Minhook.h>
#include <gamememory/memory.hpp>

#include <utilities/tools/tools.hpp>
#include <utilities/console/console.hpp>

#include <vector>

namespace hookHelper
{
	template<typename T>
	inline constexpr void** ORIGINAL(T& arg)
	{
		return reinterpret_cast<void**>(&arg);
	}

	namespace MinHook
	{
		inline void tryHook(void* target, void* detour, void* original, const std::string_view name)
		{
			const MH_STATUS hk = MH_CreateHook(static_cast<LPVOID>(target), static_cast<LPVOID>(detour), static_cast<LPVOID*>(original));
			if (hk != MH_OK)
				HACK_THROW(std::format("{} hook error", name));
			console::debug("{} -> {} hooked at addr 0x{:X}", name, MH_StatusToString(hk), reinterpret_cast<uintptr_t>(target));

			const MH_STATUS enable = MH_EnableHook(static_cast<LPVOID>(target));
			if(enable != MH_OK)
				HACK_THROW(std::format("{} hook enable error", name));
		}

		inline void initMinhook()
		{
			const MH_STATUS status = MH_Initialize();
			if(status != MH_OK)
				HACK_THROW("Can't init MinHook");

			console::debug("Minhook init -> {}", MH_StatusToString(status));
		}

		inline void shutdownAllHooks()
		{
			MH_DisableHook(MH_ALL_HOOKS);
			MH_RemoveHook(MH_ALL_HOOKS);
			MH_Uninitialize();

			// no need to log
		}
	}

	namespace Valve
	{
		namespace detail
		{
			inline std::vector<std::pair<void*, std::string_view>> allHooks;
		}

		inline void tryHook(void* target, void* detour, void* original, const std::string_view name)
		{
			const bool status = memory::valveHook()(target, detour, original, 0);
			if(!status)
				HACK_THROW(std::format("{} hook error", name));
			console::debug("{} -> {} hooked at addr 0x{:X}", name, status, reinterpret_cast<uintptr_t>(target));

			detail::allHooks.emplace_back(std::make_pair(target, name));
		}

		inline void tryUnhook(void* target, const std::string_view name)
		{
			const bool status = memory::valveUnHook()(reinterpret_cast<uintptr_t>(target), 0);
			if (!status)
				HACK_THROW(std::format("can't unhook! {}", name));
		}

		inline void shutdownAllHooks()
		{
			for (const auto& [target, name] : detail::allHooks)
			{
				tryUnhook(target, name);
			}
		}
	}
}
```

`hack/cheats/hooks/hooks.cpp`:

```cpp
#include "hooks.hpp"
#include "helpers/helper.hpp"
#include "wndproc.hpp"

#include <SDK/ConVar.hpp>
#include <SDK/ICvar.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <gamememory/memory.hpp>

#include "addEntity.hpp"
#include "allocKeyvalues.hpp"
#include "buildTransformations.hpp"
#include "cHudIsHidden.hpp"
#include "createEvent.hpp"
#include "createMove.hpp"
#include "doExtraBonesProcessing.hpp"
#include "doPostScreenEffects.hpp"
#include "drawIndexPrimitive.hpp"
#include "drawModelExecute.hpp"
#include "filesCheck.hpp"
#include "frameStageNotify.hpp"
#include "getColorModulation.hpp"
#include "getUnverifiedFileHashes.hpp"
#include "isDepth.hpp"
#include "isFollowingEntity.hpp"
#include "isHltv.hpp"
#include "isUsingStaticPropDebugModes.hpp"
#include "levelInitPostEnttity.hpp"
#include "levelInitPreEntity.hpp"
#include "levelShutdown.hpp"
#include "lockCursor.hpp"
#include "overrideMouse.hpp"
#include "overrideView.hpp"
#include "paintTraverse.hpp"
#include "particlesSimulation.hpp"
#include "playStepSound.hpp"
#include "present.hpp"
#include "processSpottedEntityUpdate.hpp"
#include "removeEntity.hpp"
#include "reset.hpp"
#include "screen2dEffect.hpp"
#include "sendDatagram.hpp"
#include "svcheats.hpp"
#include "unknownFileSys.hpp"
#include "unknownOverviewMap.hpp"
#include "unknownPlayerHurt.hpp"
#include "unkownRoundEnd.hpp"
#include "viewFade.hpp"
#include "viewRender.hpp"
#include "updatePostEffects.hpp"
#include "drawSetColor.hpp"
#include "renderSmokeOverlay.hpp"
#include "findMaterial.hpp"
#include "getPMaterial.hpp"
#include "decalAddToSurface.hpp"
#include "decalCreate.hpp"
#include "createParticlePrecip.hpp"
#include "initializeParticlePrecip.hpp"
#include "getVCollide.hpp"
#include "vCollideLoad.hpp"
#include "drawEffects.hpp"
#include "drawWorldAndEntities.hpp"
#include "drawTranslucentRenderables.hpp"
#include "clientModeCSNormalEvent.hpp"
#include "tracerDraw.hpp"
#include "dispatchInnerParticlePrecip.hpp"
#include "getPhysicsProperties.hpp"
#include "newParticleEffectSetControlPoint.hpp"
#include "getVelocity.hpp"
#include "overrideConfig.hpp"
#include "mapLoaderInit.hpp"

#define HOOK(target, _struct) \
	hookHelper::MinHook::tryHook(target, &_struct::hook, hookHelper::ORIGINAL(_struct::original), #_struct);

#define HOOK_VALVE(target, _struct) \
	hookHelper::Valve::tryHook(target, &_struct::hook, hookHelper::ORIGINAL(_struct::original), #_struct);

void hooks::init()
{
	hooks::wndProcSys::init();

	hookHelper::MinHook::initMinhook();

	hooks::Present::original = memory::Address<hooks::Present::call>{ memory::present() }.deRef(memory::Dereference::TWICE)();
	hooks::Reset::original = memory::Address<hooks::Reset::call>{ memory::reset() }.deRef(memory::Dereference::TWICE)();
	**reinterpret_cast<void***>(memory::present()) = Present::hook;
	**reinterpret_cast<void***>(memory::reset()) = Reset::hook;

	//HOOK(vfunc::getVFunc(memory::interfaces::dx9Device(), DRAW_IDX_PRIMITIVE), hooks::DrawIndexedPrimitive);
	HOOK(vfunc::getVFunc(memory::interfaces::keyValuesSys(), ALLOC_KEYVALUE), hooks::AllocKeyValues);

	HOOK(memory::isUsingPropDebug(), hooks::IsUsingStaticPropDebugModes);
	HOOK(memory::getColorModulation(), hooks::GetColorModulation);
	HOOK(memory::extraBonesProcessing(), hooks::DoExtraBonesProcessing);
	HOOK(memory::buildTransformations(), hooks::BuildTransformations);
	HOOK(memory::particleSimulate(), hooks::ParticlesSimulations);
	HOOK(memory::sendDataGram(), hooks::SendDatagram);
	HOOK(memory::unkOverviewMap(), hooks::UnknownOverviewMap);
	HOOK(memory::isDepth(), hooks::IsDepthOfField);
	HOOK(memory::addEnt(), hooks::AddEntity);
	HOOK(memory::removeEnt(), hooks::RemoveEntity);
	HOOK(vfunc::getVFunc(memory::interfaces::client(), FRAMESTAGE), hooks::FrameStageNotify);
	HOOK(vfunc::getVFunc(memory::interfaces::client(), LEVEL_INIT_PREENT), hooks::LevelInitPreEntity);
	HOOK(vfunc::getVFunc(memory::interfaces::client(), LEVEL_INIT_POSTENT), hooks::LevelInitPostEntity);
	HOOK(vfunc::getVFunc(memory::interfaces::client(), LEVEL_SHUTDOWN), hooks::LevelShudown);
	HOOK(vfunc::getVFunc(memory::interfaces::panel(), PAINTTRAVERSE), hooks::PaintTraverse);
	HOOK(vfunc::getVFunc(memory::interfaces::modelRender(), DRAWMODEL_EXECUTE), hooks::DrawModelExecute);
	HOOK(vfunc::getVFunc(memory::interfaces::clientMode(), CREATEMOVE), hooks::CreateMove);
	HOOK(vfunc::getVFunc(memory::interfaces::clientMode(), OVERRIDE), hooks::OverrideView);
	HOOK(vfunc::getVFunc(memory::interfaces::clientMode(), OVERRIDE_MOUSE), hooks::OverrideMouse);
	HOOK(vfunc::getVFunc(memory::interfaces::clientMode(), POSTSCREENEFFECT), hooks::DoPostScreenEffects);
	HOOK(vfunc::getVFunc(memory::interfaces::surface(), LOCK_CURSOR), hooks::LockCursor);
	HOOK(vfunc::getVFunc(memory::interfaces::cvar->findVar("sv_cheats"), SV_CHEATS), hooks::SvCheats);
	HOOK(vfunc::getVFunc(memory::interfaces::fileSystem(), UNK_ALLOC_FILESYS), hooks::UnknownFileSysAlloc);
	HOOK(vfunc::getVFunc(memory::interfaces::fileSystem(), LOSE_FILES_CHECK), hooks::FilesCheck);
	HOOK(vfunc::getVFunc(memory::interfaces::fileSystem(), UNVERIFIED_FILE_HASHES), hooks::GetUnverifiedFileHashes);
	HOOK(vfunc::getVFunc(memory::interfaces::viewRender(), RENDER_VIEW), hooks::ViewRender);
	HOOK(vfunc::getVFunc(memory::interfaces::viewRender(), SCREEN_2D_EFFECT), hooks::Screen2DEffect);
	HOOK(vfunc::getVFunc(memory::interfaces::engine(), IS_HLTV), hooks::IsHltv);
	HOOK(memory::isFollowedEntity(), hooks::IsFollowingEntity);
	HOOK(memory::spottedEntityUpdate(), hooks::ProcessSpottedEntityUpdate);
	HOOK(vfunc::getVFunc(memory::interfaces::eventManager(), CREATE_EVENT), hooks::CreateEvent);
	HOOK(memory::preRound(), hooks::UnknownRoundEnd);
	HOOK(memory::playSoundStep(), hooks::PlayStepSound);
	HOOK(memory::chudIsHidden(), hooks::CHudIsHidden);
	HOOK(memory::viewFade(), hooks::ViewFade);
	HOOK(memory::unkRound(), hooks::UnknownPlayerHurt);
	HOOK(memory::updatePostEffects(), hooks::UpdatePostEffects);
	HOOK(vfunc::getVFunc(memory::interfaces::surface(), SET_DRAW_COLOR), hooks::setDrawColor);
	HOOK(vfunc::getVFunc(memory::interfaces::viewRender(), RENDER_SMOKE_OVERLAY), hooks::RenderSmokeOverlay); 
	HOOK(vfunc::getVFunc(memory::interfaces::matSys(), FIND_MATERIAL), hooks::FindMaterial);
	HOOK(memory::createParticlePrecip(), hooks::CreateParticlePrecip);
	HOOK(vfunc::getVFunc(memory::interfaces::modelInfo(), GET_VCOLLIDE), hooks::GetVCollide);
	HOOK(memory::initializeParticlePrecip(), hooks::InitializeParticlePrecip);
	HOOK(memory::drawTransculentRenderables(), hooks::DrawTranslucentRenderables);
	HOOK(vfunc::getVFunc(memory::interfaces::physicsCollision(), VCOLLIDE_LOAD), hooks::VCollideLoad);
	HOOK(memory::clientCsNormalEvent(), hooks::ClientModeCSNormalEvent);
	HOOK(memory::newParticleSetControlPoint.cast<void*>()(), hooks::NewParticleEffectSetControlPoint);
	HOOK(vfunc::getVFunc(memory::interfaces::matSys(), OVERRIDE_CONFIG), hooks::OverrideConfig);

	// figure out why tf they corrupt stack, incorrect args?
	//HOOK(memory::decalAddToSurface(), hooks::R_AddDecalToSurface);
	//HOOK(memory::createDecal(), hooks::R_DecalCreate);

#undef HOOK
#undef HOOK_VALVE

	console::debug("hooks success");
}

void hooks::shutdown()
{
	hooks::wndProcSys::shutdown();

	**reinterpret_cast<void***>(memory::present()) = hooks::Present::original;
	**reinterpret_cast<void***>(memory::reset()) = hooks::Reset::original;

	hookHelper::MinHook::shutdownAllHooks();

	hookHelper::Valve::shutdownAllHooks();
}
```

`hack/cheats/hooks/hooks.hpp`:

```hpp
#pragma once

enum hookIndexes
{
	PAINTTRAVERSE = 41,
	CREATEMOVE = 24,
	DRAWMODEL_EXECUTE = 21,
	DRAWMODEL = 29,
	OVERRIDE = 18,
	POSTSCREENEFFECT = 44,
	FRAMESTAGE = 37,
	LOCK_CURSOR = 67,
	RESETDX = 16,
	PRESENTDX = 17,
	PROXY_MOVE = 22,
	END_SCENE = 42,
	SV_CHEATS = 13,
	DRAW_IDX_PRIMITIVE = 82,
	UNK_ALLOC_FILESYS = 89, // probably some from the IO operation method used by textures for optimal use
	UNVERIFIED_FILE_HASHES= 101,
	LOSE_FILES_CHECK = 128, // 512 / 4
	RENDER_VIEW = 6,
	IS_HLTV = 93,
	SCREEN_2D_EFFECT = 39,
	LEVEL_INIT_PREENT = 5,
	LEVEL_INIT_POSTENT = 6,
	LEVEL_SHUTDOWN = 7,
	EMIT_SOUND = 5,
	CREATE_EVENT = 7,
	RUN_COMMAND = 19,
	RENDER_VIEW_SCENE_END = 9,
	OVERRIDE_MOUSE = 23,
	ALLOC_KEYVALUE = 2,
	SET_DRAW_COLOR = 15, // overloaded
	RENDER_SMOKE_OVERLAY = 41,
	FIND_MATERIAL = 84,
	GET_VCOLLIDE = 6, // by index
	VCOLLIDE_LOAD = 36,
	OVERRIDE_CONFIG = 21,
};

#define DUMP_WEATHER false

namespace hooks
{
	void init();
	void shutdown();

	// if you lazy to find every pattern, and know your thisptr is some sort of interface or your wanted class, store those here
	namespace capture
	{
		inline void* engineRenderer{ };
		inline void* particleEffects{ };
	}

	inline bool calledInitprecip = false;
}
```

`hack/cheats/hooks/initializeParticlePrecip.cpp`:

```cpp
#include "initializeParticlePrecip.hpp"

#include <gamememory/memory.hpp>
#include <SDK/CUtlVector.hpp>
#include <SDK/IVModelInfo.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/ICollideable.hpp>
#include <SDK/CGameRules.hpp>

#include <utilities/console/console.hpp>

hooks::InitializeParticlePrecip::value hooks::InitializeParticlePrecip::hook(HACK_FAST_ARGS)
{
    using CClient_Precipitation = Precipitation_t;

#if DUMP_WEATHER == true
    console::debug("PRECIP COORDS DUMP");
#endif

    for (int i = 0; i < memory::gPrecipitations().m_size; i++)
    {
        CClient_Precipitation* volume = memory::gPrecipitations()[i];

#if DUMP_WEATHER == true
        auto coll = volume->collideable();
        if (coll)
        {
            console::debug("g_Precipitations[{}]", i);
            console::debug("{");
            console::debug("\tMaxs {} {} {}\tMins {} {} {}", volume->m_vecMaxs()[0], volume->m_vecMaxs()[1], volume->m_vecMaxs()[2], volume->m_vecMins()[0], volume->m_vecMins()[1], volume->m_vecMins()[2]);
            console::debug("\tOBBMaxs {} {} {}\tOBBMins {} {} {}", coll->OBBMaxs()[0], coll->OBBMaxs()[1], coll->OBBMaxs()[2], coll->OBBMins()[0], coll->OBBMins()[1], coll->OBBMins()[2]);
            console::debug("}");
        }
#endif
    }

#if DUMP_WEATHER == true
    console::debug("END PRECIP COORDS DUMP");
#endif

    original(thisptr);
}
```

`hack/cheats/hooks/initializeParticlePrecip.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class InitializeParticlePrecip
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/isDepth.cpp`:

```cpp
#include "isDepth.hpp"

#include <cheats/features/visuals/misc/motionblur.hpp>

hooks::IsDepthOfField::value hooks::IsDepthOfField::hook()
{
	motionBlur::render();

	return false;
}
```

`hack/cheats/hooks/isDepth.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class IsDepthOfField
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = bool;
	using call = value(HACK_STDCALL*)();

	static value HACK_STDCALL hook();
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/isFollowingEntity.cpp`:

```cpp
#include "isFollowingEntity.hpp"

#include <gamememory/memory.hpp>
#include <config/vars.hpp>

#include <intrin.h>

hooks::IsFollowingEntity::value hooks::IsFollowingEntity::hook(HACK_FAST_ARGS)
{
	if (vars::misc->disableItems->interpolate && reinterpret_cast<uintptr_t>(_ReturnAddress()) == memory::retAddrToInterpolation())
	{
		return true;
	}

	return original(thisptr);
}
```

`hack/cheats/hooks/isFollowingEntity.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class IsFollowingEntity
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = bool;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/isHltv.cpp`:

```cpp
#include "isHltv.hpp"

#include <SDK/CGlobalVars.hpp>
#include <gamememory/memory.hpp>
#include <config/vars.hpp>

#include <intrin.h>

hooks::IsHltv::value hooks::IsHltv::hook(HACK_FAST_ARGS)
{
	volatile uintptr_t ent{ };
	__asm mov ent, edi

	const retaddr_t ret = reinterpret_cast<retaddr_t>(_ReturnAddress());

	if (!ent)
		return original(thisptr);

	// 53 8B DC 83 EC 08 83 E4 F8 83 C4 04 55 8B 6B 04 89 6C 24 04 8B EC 83 EC 30 56 57 8B F9 8B 0D ? ? ? ? 8B 01 8B 80 ? ? ? ? FF D0 84 C0 0F 85 ? ? ? ?
	if (ret == memory::occlusion() && vars::misc->mirrorCam->enabled)
	{
		*reinterpret_cast<int*>(ent + 0xA24) = -1; // m_nCustomBlendingRuleMask
		*reinterpret_cast<int*>(ent + 0xA30) = memory::interfaces::globalVars->m_frameCount; // m_nComputedLODframe
		*reinterpret_cast<int*>(ent + 0xA2C) = *reinterpret_cast<int*>(ent + 0xA28); // m_nAnimLODflagsOld
		*reinterpret_cast<int*>(ent + 0xA28) = 0; // m_nAnimLODflags

		return true;
	}

	return original(thisptr);
}
```

`hack/cheats/hooks/isHltv.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class IsHltv
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = bool;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/isUsingStaticPropDebugModes.cpp`:

```cpp
#include "isUsingStaticPropDebugModes.hpp"

#include <config/vars.hpp>

hooks::IsUsingStaticPropDebugModes::value hooks::IsUsingStaticPropDebugModes::hook()
{
	return vars::visuals->world->modulate->enabledProp;
}
```

`hack/cheats/hooks/isUsingStaticPropDebugModes.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class IsUsingStaticPropDebugModes
{
	ADD_HOOK_FRIEND;
private:
	using value = bool;
	using call = value(HACK_STDCALL*)();

	static value HACK_STDCALL hook();
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/levelInitPostEntity.cpp`:

```cpp
#include "levelInitPostEnttity.hpp"

#include <gamememory/memory.hpp>

hooks::LevelInitPostEntity::value hooks::LevelInitPostEntity::hook(HACK_FAST_ARGS)
{
	original(thisptr);

	memory::postInit();

	Storage::runs.run();
}
```

`hack/cheats/hooks/levelInitPostEnttity.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class LevelInitPostEntity
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;

	using clRun = std::function<void()>;
protected:
	void registerPostReset(const clRun& callback) { Storage::runs.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clRun> runs;
	};
};
_HOOK_END
```

`hack/cheats/hooks/levelInitPreEntity.cpp`:

```cpp
#include "levelInitPreEntity.hpp"

hooks::LevelInitPreEntity::value HACK_FASTCALL hooks::LevelInitPreEntity::hook(HACK_FAST_ARGS, const char* map)
{
	Storage::runs.run();

	original(thisptr, map);
}
```

`hack/cheats/hooks/levelInitPreEntity.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class LevelInitPreEntity
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, const char*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, const char*);
	inline static call original;

	using clRun = std::function<void()>;
protected:
	void registerReset(const clRun& callback) { Storage::runs.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clRun> runs;
	};

};
_HOOK_END
```

`hack/cheats/hooks/levelShutdown.cpp`:

```cpp
#include "levelShutdown.hpp"

hooks::LevelShudown::value hooks::LevelShudown::hook(HACK_FAST_ARGS)
{
	original(thisptr);
}
```

`hack/cheats/hooks/levelShutdown.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class LevelShudown
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/lockCursor.cpp`:

```cpp
#include "lockCursor.hpp"

#include <SDK/ISurface.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <menu/GUI-ImGui/menu.hpp>

hooks::LockCursor::value hooks::LockCursor::hook(HACK_FAST_ARGS)
{
	if (ImGuiMenu::active)
	{
		memory::interfaces::surface->unlockCursor();
		return;
	}

	original(thisptr);
}
```

`hack/cheats/hooks/lockCursor.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class LockCursor
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/mapLoaderInit.cpp`:

```cpp
#include "mapLoaderInit.hpp"

hooks::MapLoaderInit::value hooks::MapLoaderInit::hook(HACK_FAST_ARGS, model_t* model, const char* pathName)
{
	printf("path name %s\n", pathName);

	original(thisptr, model, pathName);
}
```

`hack/cheats/hooks/mapLoaderInit.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/IVModelInfo.hpp>

_HOOK_BEGIN
class MapLoaderInit
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, model_t*, const char*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, model_t* model, const char* pathName);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/newParticleEffectSetControlPoint.cpp`:

```cpp
#include "newParticleEffectSetControlPoint.hpp"

#include <cheats/features/visuals/world/weather/precipitation.hpp>
#include <cheats/game/game.hpp>
#include <utilities/math/math.hpp>
#include <SDK/CNewParticleEffect.hpp>
#include <SDK/CCommonHostState.hpp>

#include <config/vars.hpp>

size_t tempCallCounter = 0;

hooks::NewParticleEffectSetControlPoint::value hooks::NewParticleEffectSetControlPoint::hook(HACK_FAST_ARGS, int whichPoint, const Vec3& vec)
{
	const auto precip = weather::precipitation::getPrecip();
	if (!precip)
		return original(thisptr, whichPoint, vec);

	if (whichPoint != 1)
		return original(thisptr, whichPoint, vec);

	const auto particleEffect = reinterpret_cast<CNewParticleEffect*>(thisptr);
	const auto collection = particleEffect->getParticleCollection();

	bool detectedWeather = false;
	if (collection)
	{
		const std::string_view name = collection->m_def.m_obj->m_name.m_buffer;
		if (name.contains("rain") || name.contains("snow"))
		{
			detectedWeather = true;
		}
	}

	// dont care, will be same
	// bool outer = false;
	bool innerFar = false;
	bool innerNear = false;

	if (detectedWeather)
	{
		++tempCallCounter;

		if (tempCallCounter == 2)
		{
			innerNear = true;
		}
		else if (tempCallCounter == 3)
		{
			innerFar = true;
		}
		else if (tempCallCounter > 3)
			tempCallCounter = 0;
	}

	if (innerNear)
	{
		const auto forward = math::angleVec(game::getViewAngles());
		const Vec3 customPos = game::localPlayer->getEyePos() + Vec3{ 0.0f, 0.0f, 180.0f } + forward * vars::visuals->world->weather->customNear;
		return original(thisptr, whichPoint, std::cref(customPos));
	}

	if (innerFar)
	{
		const auto forward = math::angleVec(game::getViewAngles());
		const Vec3 customPos = game::localPlayer->getEyePos() + Vec3{ 0.0f, 0.0f, 180.0f } + forward * vars::visuals->world->weather->customFar;
		return original(thisptr, whichPoint, std::cref(customPos));
	}

	original(thisptr, whichPoint, vec);
}
```

`hack/cheats/hooks/newParticleEffectSetControlPoint.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/math/Vector.hpp>

_HOOK_BEGIN
class NewParticleEffectSetControlPoint
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, int, const Vec3&);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, int whichPoint, const Vec3& vec);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/overrideConfig.cpp`:

```cpp
#include "overrideConfig.hpp"

#include <cheats/features/visuals/world/weather/ground.hpp>

hooks::OverrideConfig::value hooks::OverrideConfig::hook(HACK_FAST_ARGS, void* config, bool update)
{
	weather::ground::applyManually();

	auto res = original(thisptr, config, update);

	return res;
}
```

`hack/cheats/hooks/overrideConfig.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class OverrideConfig
{
	ADD_HOOK_FRIEND;
private:
	using value = bool;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, void*, bool);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, void* config, bool update);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/overrideMouse.cpp`:

```cpp
#include "overrideMouse.hpp"

#include <menu/GUI-ImGui/menu.hpp>

hooks::OverrideMouse::value hooks::OverrideMouse::hook(HACK_FAST_ARGS, float* x, float* y)
{
	static std::once_flag onceFlag;
	std::call_once(onceFlag, []() { Storage::intis.run(); });

	if (ImGuiMenu::active)
		return original(thisptr, x, y);

	original(thisptr, x, y);

	Storage::runs.run(x, y);
}
```

`hack/cheats/hooks/overrideMouse.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class OverrideMouse
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, float*, float*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, float* x, float* y);
	inline static call original;

	using clRun = std::function<void(float*, float*)>;
	using clInit = std::function<void()>;
protected:
	void registerRun(const clRun& callback) { Storage::runs.push_back(callback); }
	void registerInit(const clInit& callback) { Storage::intis.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clRun> runs;
		inline static vectorRunnable<clInit> intis;
	};
};
_HOOK_END
```

`hack/cheats/hooks/overrideView.cpp`:

```cpp
#include "overrideView.hpp"


#include <SDK/CViewSetup.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/globals.hpp>
#include <cheats/game/game.hpp>
#include <config/vars.hpp>

hooks::OverrideView::value hooks::OverrideView::hook(HACK_FAST_ARGS, CViewSetup* view)
{	
	if(!game::isAvailable())
		return original(thisptr, view);

	if (!game::localPlayer->m_bIsScoped())
		if (auto fov = vars::misc->fov->value; fov > 0.0f || fov < 0.0f)
			view->m_fov += fov;

	globals::FOV = view->m_fov;
	Storage::runs.run(view);

	original(thisptr, view);
}
```

`hack/cheats/hooks/overrideView.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/CViewSetup.hpp>

_HOOK_BEGIN
class OverrideView
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, CViewSetup*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, CViewSetup* view);
	inline static call original;

	using clRun = std::function<void(CViewSetup*)>;
protected:
	void registerRun(const clRun& callback) { Storage::runs.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clRun> runs;
	};
};
_HOOK_END
```

`hack/cheats/hooks/paintTraverse.cpp`:

```cpp
#include "paintTraverse.hpp"

#include <render/render.hpp>
#include <gamememory/memory.hpp>

#include <SDK/IVEngineClient.hpp>
#include <SDK/ISurface.hpp>
#include <SDK/IPanel.hpp>
#include <SDK/interfaces/interfaces.hpp>

static void getScreen()
{
	int x, y;
	memory::interfaces::engine->getScreenSize(x, y);
	globals::screenX = x;
	globals::screenY = y;
}

static void getMouse()
{
	int x, y;
	memory::interfaces::surface->getCursor(x, y);
	globals::mouseX = x;
	globals::mouseY = y;
}

hooks::PaintTraverse::value hooks::PaintTraverse::hook(HACK_FAST_ARGS, uint32_t panel, bool forceRepaint, bool allowForce)
{
	if (globals::isShutdown)
	{
		static std::once_flag onceFlag;
		std::call_once(onceFlag, []() { Storage::shutdowns.run(); });
		return original(thisptr, panel, forceRepaint, allowForce);
	}

	static std::once_flag onceFlag;
	std::call_once(onceFlag, []() { Storage::inits.run(); });

	getScreen();
	getMouse();

	if (memory::interfaces::engine->isTakingScreenshot())
		return;

	const std::string_view panelName = memory::interfaces::panel->getName(panel);
	
	static uint32_t panelID = 0;

	original(thisptr, panel, forceRepaint, allowForce);

	if (!panelID)
	{
		if (panelName == "FocusOverlayPanel")
			panelID = panel;
	}
	else if (panelID == panel)
	{
		memory::interfaces::surface->pushMakeCurrent(panel, false);
		ImRender::beginThink();
		Storage::runs.run();
		ImRender::endThink();
		memory::interfaces::surface->popMakeCurrent(panel);
	}
}
```

`hack/cheats/hooks/paintTraverse.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class PaintTraverse
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, uint32_t, bool, bool);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, uint32_t panel, bool forceRepaint, bool allowForce);
	inline static call original;

	using clRun = std::function<void()>;
	using clInit = std::function<void()>;
protected:
	void registerRender(const clRun& callback) { Storage::runs.push_back(callback); }
	void registerInit(const clRun& callback) { Storage::inits.push_back(callback); }
	void registerShutdown(const clRun& callback) { Storage::shutdowns.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clRun> runs;
		inline static vectorRunnable<clRun> inits;
		inline static vectorRunnable<clRun> shutdowns;
	};
};
_HOOK_END
```

`hack/cheats/hooks/particlesSimulation.cpp`:

```cpp
#include "particlesSimulation.hpp"

#include <SDK/CParticelCollection.hpp>
#include <config/vars.hpp>

#include <array>
#include <string>
#include <ranges>

constexpr std::array mollyNames =
{
	"explosion_molotov_air",
	"extinguish_fire",
	"molotov_groundfire",
	"molotov_groundfire_fallback",
	"molotov_groundfire_fallback2",
	"molotov_explosion",
	"weapon_molotov_held",
	"weapon_molotov_fp",
	"weapon_molotov_thrown",
};

constexpr std::array smokenames =
{
	"explosion_smokegrenade",
	"explosion_smokegrenade_fallback"
};

constexpr std::array bloodnames =
{
	"blood_impact_light",
	"blood_impact_medium",
	"blood_impact_heavy",
	"blood_impact_light_headshot"
};

struct WeatherParticleCfg { const char* name; bool* cfg; CfgColor* color; };

const std::array weatherParticles
{
	WeatherParticleCfg{ "snow", &vars::visuals->world->weather->snowParticleEdit, &vars::visuals->world->weather->snowParticleInnerNearColor },
	WeatherParticleCfg{ "snow_outer", &vars::visuals->world->weather->snowParticleEdit, &vars::visuals->world->weather->snowParticleOuterColor },

	WeatherParticleCfg{ "rain", &vars::visuals->world->weather->rainParticleEdit, &vars::visuals->world->weather->rainParticleInnerNearColor },
	WeatherParticleCfg{ "rain_outer", &vars::visuals->world->weather->rainParticleEdit, &vars::visuals->world->weather->rainParticleOuterColor },

	WeatherParticleCfg{ "rain_storm", &vars::visuals->world->weather->rainStormParticleEdit, &vars::visuals->world->weather->rainStormParticleInnerNearColor },
	WeatherParticleCfg{ "rain_storm_screen", &vars::visuals->world->weather->rainStormParticleEdit, &vars::visuals->world->weather->rainStormParticleInnerFarColor },
	WeatherParticleCfg{ "rain_storm_outer", &vars::visuals->world->weather->rainStormParticleEdit, &vars::visuals->world->weather->rainStormParticleOuterColor }
};

hooks::ParticlesSimulations::value hooks::ParticlesSimulations::hook(HACK_FAST_ARGS)
{
	hooks::capture::particleEffects = thisptr;

	original(thisptr);

	const auto ptr = reinterpret_cast<CParticleCollection*>(thisptr);

	CParticleCollection* root = ptr;
	while (root->m_parent)
		root = root->m_parent;

	const std::string_view name = root->m_def.m_obj->m_name.m_buffer;
	const Color colorMolly = vars::visuals->world->particles->colorMolotov();
	const Color colorBlood = vars::visuals->world->particles->colorBlood();
	const Color colorSmoke = vars::visuals->world->particles->colorSmoke();

	// modulateColor() for alpha, but it can fuckup the render, because alpha is very often clamped with time etc...

	if (vars::visuals->world->particles->enabledSmoke)
	{
		if (auto itr = std::ranges::find(smokenames, name); itr != smokenames.cend())
		{
			for (auto i : std::views::iota(0, ptr->m_activeParticles))
			{
				ptr->m_particleAttributes.modulateColorRGB(colorSmoke, i);
			}
		}
	}

	if (vars::visuals->world->particles->enabledBlood)
	{
		if (auto itr = std::ranges::find(bloodnames, name); itr != bloodnames.cend())
		{
			for (auto i : std::views::iota(0, ptr->m_activeParticles))
			{
				ptr->m_particleAttributes.modulateColorRGB(colorBlood, i);
			}
		}
	}

	if (vars::visuals->world->particles->enabledMolotov)
	{
		if (auto itr = std::ranges::find(mollyNames, name); itr != mollyNames.cend())
		{
			for (auto i : std::views::iota(0, ptr->m_activeParticles))
			{
				ptr->m_particleAttributes.modulateColorRGB(colorMolly, i);
			}
		}
	}

	auto weatherParticleIsFine = [name](const WeatherParticleCfg& wp) { return *wp.cfg && std::string_view{ wp.name } == name; };

	if (auto itr = std::ranges::find_if(weatherParticles, weatherParticleIsFine); itr != weatherParticles.end())
	{
		for (auto i : std::views::iota(0, ptr->m_activeParticles))
		{
			itr->color->refresh();
			ptr->m_particleAttributes.modulateColorRGB(itr->color->getColor(), i);
		}
	}
}
```

`hack/cheats/hooks/particlesSimulation.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class ParticlesSimulations
{
public:
	static auto getOriginal() { return original; }
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/playStepSound.cpp`:

```cpp
#include "playStepSound.hpp"

#include <cheats/game/game.hpp>
#include <cheats/features/visuals/player/sounds.hpp>

hooks::PlayStepSound::value hooks::PlayStepSound::hook(HACK_FAST_ARGS, Vec3& origin, void* surface, float volume, bool force, void* unk)
{
	if (!thisptr)
		return original(thisptr, origin, surface, volume, force, unk);

	if(thisptr == game::localPlayer)
		return original(thisptr, origin, surface, volume, force, unk);

	sound::pushSteps(static_cast<Player_t*>(thisptr));

	return original(thisptr, origin, surface, volume, force, unk);
}
```

`hack/cheats/hooks/playStepSound.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/math/Vector.hpp>

_HOOK_BEGIN
class PlayStepSound
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = int;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, Vec3&, void*, float, bool, void*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, Vec3& origin, void* surface, float volume, bool force, void* unk);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/present.cpp`:

```cpp
#include "present.hpp"

#include <menu/GUI-ImGui/menu.hpp>
#include <render/render.hpp>
#include <render/backend/backend.hpp>
#include <utilities/console/console.hpp>
#include <utilities/res.hpp>
#include <utilities/tools/tools.hpp>
#include <gamememory/memory.hpp>

#include <imgui_impl_dx9.h>
#include <imgui_impl_win32.h>

#include <d3d9.h>
#include <mutex>

#include <cheats/features/visuals/glow/glow.hpp>
#include <cheats/features/visuals/chams/chams.hpp>
#include <cheats/features/visuals/streamproof/streamproof.hpp>

hooks::Present::value hooks::Present::hook(IDirect3DDevice9* device, RECT* srcRect, RECT* dstRect, HWND window, RGNDATA* region)
{
	// check if there is any context, needed when shutdown
	if (!ImGui::GetCurrentContext())
		return original(device, srcRect, dstRect, window, region);

	renderbackend::impl(device);

	// BEGIN DRAW
	ImGui_ImplDX9_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();
	{
		ImRender::present(ImGui::GetBackgroundDrawList());

		glow::streamProof.beginPresent(device, D3DBLEND_INVSRCALPHA);
		chams::streamProof.beginPresent(device, D3DBLEND_SRCCOLOR);
		chams::streamProofDME.beginPresent(device, D3DBLEND_SRCCOLOR);

		Storage::runs.run();
		ImNotify::handle();
	}

	// END DRAW
	ImGui::EndFrame();
	ImGui::Render();

	// CHECK RENDER
	if (device->BeginScene() == D3D_OK)
	{
		ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
		device->EndScene();
	}

	glow::streamProof.endPresent();
	chams::streamProof.endPresent();
	chams::streamProofDME.endPresent();

	return original(device, srcRect, dstRect, window, region);
}
```

`hack/cheats/hooks/present.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <d3d9.h>

_HOOK_BEGIN
class Present
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = HRESULT;
	using call = value(D3DAPI*)(IDirect3DDevice9*, RECT*, RECT*, HWND, RGNDATA*);

	static value D3DAPI hook(IDirect3DDevice9* device, RECT* srcRect, RECT* dstRect, HWND window, RGNDATA* region);
	inline static call original;
	using clRun = std::function<void()>;
protected:
	void registerRun(const clRun& callback) { Storage::runs.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clRun> runs;
	};
};
_HOOK_END
```

`hack/cheats/hooks/processSpottedEntityUpdate.cpp`:

```cpp
#include "processSpottedEntityUpdate.hpp"

#include <cheats/features/cache/cache.hpp>

hooks::ProcessSpottedEntityUpdate::value hooks::ProcessSpottedEntityUpdate::hook(HACK_FAST_ARGS, void* unk) // CCSUsrMsg_ProcessSpottedEntityUpdate
{
	//int size = *reinterpret_cast<int*>((uintptr_t)unk + 0xC);
	//printf("size is %i\n", size);

	EntityCache::CacheFields::update();

	return original(thisptr, unk);
}
```

`hack/cheats/hooks/processSpottedEntityUpdate.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class ProcessSpottedEntityUpdate
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = bool;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, void*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, void* unk);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/removeEntity.cpp`:

```cpp
#include "removeEntity.hpp"

#include <cheats/features/cache/cache.hpp>
#include <gamememory/memory.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>

hooks::RemoveEntity::value hooks::RemoveEntity::hook(HACK_FAST_ARGS, void* handleEnt, CBaseHandle handle)
{
	Entity_t* ent = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientFromHandle(handle));
	EntityCache::erase(ent);

	original(thisptr, handleEnt, handle);
}
```

`hack/cheats/hooks/removeEntity.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/EHandle.hpp>

_HOOK_BEGIN
class RemoveEntity
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, void*, CBaseHandle);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, void* handleEnt, CBaseHandle handle);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/renderSmokeOverlay.cpp`:

```cpp
#include "renderSmokeOverlay.hpp"

#include "viewFade.hpp"

#include <gamememory/memory.hpp>
#include <SDK/IViewRender.hpp>
#include <SDK/IMaterialSystem.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <config/vars.hpp>

hooks::RenderSmokeOverlay::value hooks::RenderSmokeOverlay::hook(HACK_FAST_ARGS, bool enabled)
{
	// edx+588h

	original(thisptr, enabled);
}

```

`hack/cheats/hooks/renderSmokeOverlay.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class RenderSmokeOverlay
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, bool);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, bool enabled);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/reset.cpp`:

```cpp
#include "reset.hpp"

#include <imgui_impl_dx9.h>

hooks::Reset::value hooks::Reset::hook(IDirect3DDevice9* device, D3DPRESENT_PARAMETERS* params)
{
	ImGui_ImplDX9_InvalidateDeviceObjects();

	const auto hr = original(device, params);

	if (hr == D3D_OK)
		ImGui_ImplDX9_CreateDeviceObjects();

	return hr;
}
```

`hack/cheats/hooks/reset.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <d3d9.h>

_HOOK_BEGIN
class Reset
{
	ADD_HOOK_FRIEND;
private:
	using value = HRESULT;
	using call = value(D3DAPI*)(IDirect3DDevice9*, D3DPRESENT_PARAMETERS*);

	static value D3DAPI hook(IDirect3DDevice9* device, D3DPRESENT_PARAMETERS* params);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/screen2dEffect.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/CViewSetup.hpp>

_HOOK_BEGIN
class Screen2DEffect
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, CViewSetup*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, CViewSetup* view);
	inline static call original;

	using clInit = std::function<void()>;
	using clRun = std::function<void(CViewSetup*)>;
protected:
	void registerInit(const clInit& callback) { Storage::inits.push_back(callback); }
	void registerRun(const clRun& callback) { Storage::runs.push_back(callback); }
	void registerShutdown(const clInit& callback) { Storage::shutdowns.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clInit> inits;
		inline static vectorRunnable<clRun> runs;
		inline static vectorRunnable<clInit> shutdowns;
	};
};
_HOOK_END
```

`hack/cheats/hooks/screen2deffect.cpp`:

```cpp
#include "screen2dEffect.hpp"

hooks::Screen2DEffect::value hooks::Screen2DEffect::hook(HACK_FAST_ARGS, CViewSetup* view)
{
	if (globals::isShutdown)
	{
		static std::once_flag onceFlag;
		std::call_once(onceFlag, []() { Storage::shutdowns.run(); });

		return original(thisptr, view);
	}

	static std::once_flag onceFlag;
	std::call_once(onceFlag, []() { Storage::inits.run(); });

	Storage::runs.run(view);

	original(thisptr, view);
}
```

`hack/cheats/hooks/sendDatagram.cpp`:

```cpp
#include "sendDatagram.hpp"

#include <cheats/features/fakelatency/fakelatency.hpp>
#include <config/vars.hpp>
#include <cheats/game/game.hpp>

hooks::SendDatagram::value hooks::SendDatagram::hook(HACK_FAST_ARGS, void* datagram)
{
	if (datagram || !vars::misc->fakeLatency->enabled || !game::isAvailable())
		return original(thisptr, datagram);

	return fakeLatency::runDatagram(static_cast<INetChannel*>(thisptr), datagram);
}
```

`hack/cheats/hooks/sendDatagram.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class SendDatagram
{
public:
	static auto getOriginal() { return original; }
	ADD_HOOK_FRIEND;
private:
	using value = int;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, void*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, void* datagram);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/svcheats.cpp`:

```cpp
#include "svcheats.hpp"

#include <gamememory/memory.hpp>
#include <config/vars.hpp>

#include <intrin.h>

hooks::SvCheats::value hooks::SvCheats::hook(HACK_FAST_ARGS)
{
	if (reinterpret_cast<uintptr_t>(_ReturnAddress()) == memory::camThink() && vars::misc->thirdp->enabled)
		return true;

	return original(thisptr);
}
```

`hack/cheats/hooks/svcheats.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class SvCheats
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = bool;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/tracerDraw.cpp`:

```cpp
#include "tracerDraw.hpp"

hooks::TracerDraw::value hooks::TracerDraw::hook(void* mesh, void* start, void* end, float w, float* color)
{
	printf("working\n");
	original(mesh, start, end, w, color);
}
```

`hack/cheats/hooks/tracerDraw.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class TracerDraw
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_STDCALL*)(void*, void*, void*, float, float*);

	static value HACK_STDCALL hook(void* mesh, void* start, void* end, float w, float* color);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/unknownFIleSys.cpp`:

```cpp
#include "unknownFileSys.hpp"

#include <d3dx9.h>
#include <intrin.h>

#include "../features/visuals/radar/radar.hpp"

#include <SDK/interfaces/interfaces.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <gamememory/memory.hpp>

// A DWORD (magic number) containing the four character code value 'DDS ' (0x20534444).
#define DDS_HEADER 0x20534444

hooks::UnknownFileSysAlloc::value hooks::UnknownFileSysAlloc::hook(HACK_FAST_ARGS, void* image)
{
	volatile uintptr_t thisptrStack{ };
	__asm mov thisptrStack, ebx;

	if (image && _ReturnAddress() == memory::returnAddrRadarImage() && *reinterpret_cast<uintptr_t*>(image) == DDS_HEADER)
	{
		size_t size = *reinterpret_cast<size_t*>(thisptrStack + 0x50);

		if (auto hr = D3DXCreateTextureFromFileInMemory(memory::interfaces::dx9Device(), image, size, &radar::mapTexture); hr == D3D_OK)
			console::debug("Created map texture, size: {}", size);
		else
			console::error("Creating map texture failed, code: {}", hr);
	}

	return original(thisptr, image);
}
```

`hack/cheats/hooks/unknownFileSys.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class UnknownFileSysAlloc
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = int;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, void*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, void* image);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/unknownOverviewMap.cpp`:

```cpp
#include "unknownOverviewMap.hpp"

#include <cheats/features/visuals/radar/radar.hpp>

hooks::UnknownOverviewMap::value hooks::UnknownOverviewMap::hook(HACK_FAST_ARGS, int unk)
{
	const int ret = original(thisptr, unk);

	radar::gatherMap(static_cast<MapStruct*>(thisptr));
	
	return ret;
}
```

`hack/cheats/hooks/unknownOverviewMap.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class UnknownOverviewMap
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = int;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, int);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, int unk);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/unknownPlayerHurt.cpp`:

```cpp
#include "unknownPlayerHurt.hpp"

#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include <gamememory/memory.hpp>
#include <cheats/game/game.hpp>

hooks::UnknownPlayerHurt::value hooks::UnknownPlayerHurt::hook(HACK_FAST_ARGS, void* _event)
{
	const auto ev = reinterpret_cast<IGameEvent*>(_event);
	const auto name = ev->getName();

	const auto attacker = memory::interfaces::entList->getClientEntity(memory::interfaces::engine->getPlayerID(ev->getInt("attacker")));
	if (attacker == game::localPlayer)
	{
		Storage::runs.run(ev);
	}

	original(thisptr, _event);
}
```

`hack/cheats/hooks/unknownPlayerHurt.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/IGameEvent.hpp>

_HOOK_BEGIN
class UnknownPlayerHurt
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, void*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, void* _event);
	inline static call original;

	using clRun = std::function<void(IGameEvent*)>;
protected:
	void registerRun(const clRun& callback) { Storage::runs.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clRun> runs;
	};
};
_HOOK_END
```

`hack/cheats/hooks/unkownRoundEnd.cpp`:

```cpp
#include "unkownRoundEnd.hpp"

#include <SDK/IGameEvent.hpp>

hooks::UnknownRoundEnd::value hooks::UnknownRoundEnd::hook(HACK_FAST_ARGS, void* _event)
{
	const auto ev = reinterpret_cast<IGameEvent*>(_event);
	const std::string_view name = ev->getName();
	
	if (name == "round_end")
	{
		Storage::runs.run();
	}

	original(thisptr, _event);
}
```

`hack/cheats/hooks/unkownRoundEnd.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class UnknownRoundEnd
{
public:
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, void*);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, void* _event);
	inline static call original;

	using clRun = std::function<void()>;
protected:
	void registerRun(const clRun& callback) { Storage::runs.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clRun> runs;
	};
};
_HOOK_END
```

`hack/cheats/hooks/updatePostEffects.cpp`:

```cpp
#include "updatePostEffects.hpp"

#include <SDK/IMaterialSystem.hpp>
#include <config/vars.hpp>
#include <cheats/features/visuals/chams/factory/factory.hpp>
#include <cheats/game/game.hpp>

hooks::UpdatePostEffects::value hooks::UpdatePostEffects::hook(HACK_FAST_ARGS)
{
	IMaterial* blurOverlayMaterial{ };

	if (game::isAvailable())
	{
		static std::once_flag onceFlag;
		std::call_once(onceFlag, [&blurOverlayMaterial]() { blurOverlayMaterial = material::factory::findMaterial("dev/scope_bluroverlay", TEXTURE_GROUP_OTHER); });
	}

	if(blurOverlayMaterial)
		blurOverlayMaterial->setMaterialVarFlag(MATERIAL_VAR_NO_DRAW, vars::misc->scope->enabled);

	if (globals::isShutdown)
	{
		if(blurOverlayMaterial)
			blurOverlayMaterial->setMaterialVarFlag(MATERIAL_VAR_NO_DRAW, false);
	}

	original(thisptr);

	if(vars::misc->scope->enabled)
		*memory::vignetteBlurStrengthPost() = 0.0f;
}
```

`hack/cheats/hooks/updatePostEffects.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

_HOOK_BEGIN
class UpdatePostEffects
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/vCollideLoad.cpp`:

```cpp
#include "vCollideLoad.hpp"

#include <utilities/console/console.hpp>
hooks::VCollideLoad::value hooks::VCollideLoad::hook(HACK_FAST_ARGS, vcollide_t* output, int solidCount, const char* buffer, int size, bool swap)
{
    original(thisptr, output, solidCount, buffer, size, swap);

#if DUMP_WEATHER == true
    if (output && solidCount == 1 && output->descSize == 84) // see getvcollide dump
    {
        console::debug("(Possible) WEATHER BUFFER DUMP"); // because not always we will get the weather by that check
        console::detail::disablePrefix();

        console::debug("constexpr std::array<uint8_t, {}> weatherBuffer", size);
        console::debug("{");
        
        console::detail::disableNewLine();

        constexpr int limitPerLine = 16;

        for (int i = 0; i < size; i += limitPerLine)
        {
            console::debug("\t");

            for (int j = 0; j < limitPerLine && i + j < size; j++)
            {
                const uint8_t byte = buffer[i + j] & 0xFF;
                const std::string_view sign = (i + j + 1 < size) ? ", " : "";

                console::debug("0x{:02X}{}", byte, sign);
            }

            console::debug("\n");
        }

        console::debug("};\n");

        console::detail::enableNewLine();
        console::detail::enablePrefix();

        console::debug("END WEATHER DUMP");
    }
#endif
}
```

`hack/cheats/hooks/vCollideLoad.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/IVModelInfo.hpp>

_HOOK_BEGIN
class VCollideLoad
{
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, vcollide_t*, int, const char*, int, bool);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, vcollide_t* pOutput, int solidCount, const char* pBuffer, int size, bool swap);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/viewFade.cpp`:

```cpp
#include "viewFade.hpp"

#include <gamememory/memory.hpp>
#include <config/vars.hpp>

#include <intrin.h>

hooks::ViewFade::value hooks::ViewFade::hook(HACK_FAST_ARGS, uint8_t* color, IMaterial* material, bool t)
{
	hooks::capture::engineRenderer = thisptr;

	const auto retAddr = reinterpret_cast<retaddr_t>(_ReturnAddress());

	/*if (retAddr == memory::viewFadeSmokeRet())
	{
		return;
	}*/

	if (retAddr == memory::flashbangRet() || retAddr == memory::flashbangWhiteRet())
	{
		// R, G, B go go in 0 255 range, where A stays 255 always
		for (int i = 0; i < 4; ++i)
			color[i] = static_cast<uint8_t>(color[i] * vars::misc->disableItems->flashPercentage);
	}

	original(thisptr, color, material, t);
}
```

`hack/cheats/hooks/viewFade.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/material.hpp>

_HOOK_BEGIN
class ViewFade
{
public:
	static auto getOriginal() { return original; }
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, uint8_t*, IMaterial*, bool);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, uint8_t* color, IMaterial* material, bool t);
	inline static call original;
};
_HOOK_END
```

`hack/cheats/hooks/viewRender.cpp`:

```cpp
#include "viewRender.hpp"

#include <cheats/features/visuals/glow/glow.hpp>
#include <gamememory/memory.hpp>

hooks::ViewRender::value hooks::ViewRender::hook(HACK_FAST_ARGS, const CViewSetup& view, const CViewSetup& hud, int clearFlags, int whatToDraw)
{
	static std::once_flag onceFlag;
	std::call_once(onceFlag, []() { Storage::inits.run(); });

	Storage::runs.run(view);

	original(thisptr, view, hud, clearFlags, whatToDraw);
}
```

`hack/cheats/hooks/viewRender.hpp`:

```hpp
#pragma once

#include "helpers/common.hpp"

#include <SDK/CViewSetup.hpp>

_HOOK_BEGIN
class ViewRender
{
public:
	static auto getOriginal() { return original; }
	ADD_HOOK_FRIEND;
private:
	using value = void;
	using call = value(HACK_THISCALL*)(HACK_THISPTR, const CViewSetup&, const CViewSetup&, int, int);

	static value HACK_FASTCALL hook(HACK_FAST_ARGS, const CViewSetup& view, const CViewSetup& hud, int clearFlags, int whatToDraw);
	inline static call original;

	using clRun = std::function<void(const CViewSetup&)>;
	using clInit = std::function<void()>;
protected:
	void registerRun(const clRun& callback) { Storage::runs.push_back(callback); }
	void registerInit(const clInit& callback) { Storage::inits.push_back(callback); }
private:
	struct Storage
	{
		inline static vectorRunnable<clRun> runs;
		inline static vectorRunnable<clInit> inits;
	};
};
_HOOK_END
```

`hack/cheats/hooks/wndproc.cpp`:

```cpp
#include "wndproc.hpp"

#include <menu/GUI-ImGui/menu.hpp>
#include <config/vars.hpp>
#include <utilities/tools/tools.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <gamememory/memory.hpp>
#include <utilities/console/console.hpp>
#include <utilities/console/consoleDraw.hpp>

#include <MinHook.h>
#include <imgui_impl_win32.h>
#include <implot.h>

#include <mutex>

void hooks::wndProcSys::init()
{
	currentWindow = FindWindowA("Valve001", NULL);
	wndProcOriginal = reinterpret_cast<WNDPROC>(SetWindowLongW(currentWindow, GWL_WNDPROC, reinterpret_cast<LONG>(wndProcSys::wndproc)));
}

#include <SDK/InputSystem.hpp>
#include <config/key.hpp>
#include <utilities/inputSystem.hpp>
#include <menu/x88Menu/x88menu.hpp>
#include <render/backend/backend.hpp>

void hooks::wndProcSys::shutdown()
{
	SetWindowLongW(currentWindow, GWL_WNDPROC, reinterpret_cast<LONG>(wndProcSys::wndProcOriginal));
	memory::interfaces::iSystem->enableInput(true);
}

extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);

LRESULT hooks::wndProcSys::wndproc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
{
	renderbackend::createContext(hwnd);

	inputSystem::run(message, wparam);
	Storage::runs.run();

	memory::interfaces::iSystem->enableInput(!ImGuiMenu::active);
	
	if(ImGuiMenu::active && ImGui_ImplWin32_WndProcHandler(hwnd, message, wparam, lparam))
		return TRUE;
	
	return CallWindowProcA(wndProcOriginal, hwnd, message, wparam, lparam);
}
```

`hack/cheats/hooks/wndproc.hpp`:

```hpp
#pragma once

#include <Windows.h>

#include "helpers/common.hpp"

_HOOK_BEGIN
class wndProcSys
{
	ADD_HOOK_FRIEND;
public:
	inline static LRESULT wndproc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);

	static void init();
	static void shutdown();

	inline static WNDPROC wndProcOriginal = nullptr;
	inline static HWND currentWindow = nullptr;
protected:
	static void registerRun(const std::function<void()>& func) { Storage::runs.push_back(func); }
private:
	struct Storage
	{
		inline static vectorRunnable<std::function<void()>> runs;
	};
};
_HOOK_END
```

`hack/config/cfgBeam.hpp`:

```hpp
#pragma once

#include "cfgcolor.hpp"

struct CfgBeam
{
	int index{ 0 };
	std::string flags{ "4" };
	float life{ 2.0f };
	CfgColor color{ Colors::LightBlue };
	float width{ 2.0f };
	float fadeLength{ 1.0f };
	float amplitude{ 2.0f };
	float speed{ 0.0f };
	float startFrame{ 0.0f };
	float frameRate{ 0.0f };
	int segments{ 2 };
};
```

`hack/config/cfgBox.hpp`:

```hpp
#pragma once

#include "cfgcolor.hpp"

struct CfgBox
{
	int mode{ 0 };
	bool outline{ false };
	bool gradient{ false };
	CfgColor color{ };
	CfgColor fill{ };

	CfgColor gradientCol1{ };
	CfgColor gradientCol2{ };
	CfgColor gradientCol3{ };
	CfgColor gradientCol4{ };
};
```

`hack/config/cfgCham.hpp`:

```hpp
#pragma once

#include "cfgcolor.hpp"

struct CfgCham
{
	bool enabled{ false };
	bool hide{ };
	bool ignorez{ };
	bool wireframe{ };
	int index{ 0 };
	CfgColor color{ };
	CfgColor colorXQZ{ };
};
```

`hack/config/cfgWeapon.cpp`:

```cpp
#include "cfgWeapon.hpp"

#include <SDK/Enums.hpp>

WeaponList CfgWeapon::getWeaponByIndex(int weaponID)
{
	switch (weaponID)
	{
	case WEAPON_GLOCK:
	case WEAPON_USP_SILENCER:
	case WEAPON_CZ75A:
	case WEAPON_P250:
	case WEAPON_TEC9:
	case WEAPON_FIVESEVEN:
	case WEAPON_ELITE:
	case WEAPON_HKP2000:
		return WeaponList::WEAPON_PISTOL;
	case WEAPON_DEAGLE:
		return WeaponList::WEAPON_DEAGLE;
	case WEAPON_REVOLVER:
		return WeaponList::WEAPON_REVOLVER;
	case WEAPON_AK47:
	case WEAPON_M4A1:
	case WEAPON_M4A1_SILENCER:
	case WEAPON_GALILAR:
	case WEAPON_FAMAS:
	case WEAPON_SG553:
	case WEAPON_AUG:
		return WeaponList::WEAPON_RIFFLE;
	case WEAPON_SSG08:
		return WeaponList::WEAPON_SCOUT;
	case WEAPON_AWP:
		return WeaponList::WEAPON_AWP;
	case WEAPON_SCAR20:
	case WEAPON_G3SG1:
		return WeaponList::WEAPON_AUTOSNIPER;
	case WEAPON_NOVA:
	case WEAPON_MAG7:
	case WEAPON_XM1014:
	case WEAPON_SAWEDOFF:
		return WeaponList::WEAPON_SHOTGUN;
	case WEAPON_NEGEV:
	case WEAPON_M249:
		return WeaponList::WEAPON_MG;
	case WEAPON_P90:
	case WEAPON_MAC10:
	case WEAPON_MP7:
	case WEAPON_MP9:
	case WEAPON_MP5SD:
	case WEAPON_UMP45:
	case WEAPON_BIZON:
		return WeaponList::WEAPON_SMG;
	default:
		return WeaponList::WEAPON_UNKNOWN;
	}
}
```

`hack/config/cfgWeapon.hpp`:

```hpp
#pragma once

#include "enums.hpp"
#include "key.hpp"

#include <array>

enum class WeaponList
{
	WEAPON_RIFFLE,
	WEAPON_SMG,
	WEAPON_MG,
	WEAPON_PISTOL,
	WEAPON_DEAGLE,
	WEAPON_REVOLVER,
	WEAPON_SCOUT,
	WEAPON_AWP,
	WEAPON_AUTOSNIPER,
	WEAPON_SHOTGUN,
	WEAPON_UNKNOWN,
};

class CfgWeapon
{
public:
	bool enabled{ false };
	bool useKey{ false };
	Key key{ KeyMode::DOWN, VK_LBUTTON };
	float fov{ 5.0f };
	float maxDistanceMeters{ 75.0f };
	float frametimeMulttiply{ 8.0f };
	int methodAim{ static_cast<int>(AimbotMethod::CROSSHAIR) };
	int aimSelection{ static_cast<int>(AimbotHitboxes::NEAREST) };
	bool aimDelay{ false };
	float aimDelayVal{ 0.0f };
	bool aimBacktrack{ false };
	bool rcs{ false };
	float rcsX{ 0.5f };
	float rcsY{ 0.5f };
	bool triggerbot{ false };
	float triggerbotDelay{ 150.0f };
	bool smokeCheck{ true };
	float flashLimit{ 120.0f };

	static WeaponList getWeaponByIndex(int weaponID);
};
```

`hack/config/cfgcolor.cpp`:

```cpp
#include "cfgcolor.hpp"

#include <cmath>
#include <numbers>

#include <SDK/CGlobalVars.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include "cfgcolor.hpp"

#include <cmath>
#include <numbers>

#include <SDK/CGlobalVars.hpp>
#include <gamememory/memory.hpp>

void CfgColor::updateCol(float gameTime, float multiply)
{
	this->m_color.at(0) = std::cos(gameTime * multiply) * 0.5f + 0.5f;
	this->m_color.at(1) = std::cos(gameTime * multiply - 2.0f * std::numbers::pi_v<float> / 3.0f) * 0.5f + 0.5f;
	this->m_color.at(2) = std::cos(gameTime * multiply - 4.0f * std::numbers::pi_v<float> / 3.0f) * 0.5f + 0.5f;
}

void CfgColor::refresh()
{
	if (memory::interfaces::globalVars())
	{
		if (this->getRainbow())
			this->updateCol(memory::interfaces::globalVars->m_realtime, this->getSpeed());
	}
}
```

`hack/config/cfgcolor.hpp`:

```hpp
#pragma once

#include <render/Color.hpp>

class CfgColor
{
public:
	CfgColor() = default;
	constexpr CfgColor(const Color& color, bool rainbow = false, float speed = 0.5f)
		: m_color{ color }, m_rainbow{ rainbow }, m_speed{ speed }
	{}

	constexpr CfgColor& operator=(const CfgColor& other)
	{
		this->m_color = other.getColor();
		this->m_rainbow = other.getRainbow();
		this->m_speed = other.getSpeed();
		//this->refresh();
		return *this;
	}
	constexpr CfgColor& operator=(const Color& other)
	{
		this->m_color = other;
		return *this;
	}

	auto operator()() { refresh(); return m_color; }

	constexpr Color getColor() const { return m_color; }
	constexpr Color& getColorRef() { return m_color; }
	constexpr bool getRainbow() const { return m_rainbow; }
	constexpr bool& getRainbowRef() { return m_rainbow; }
	constexpr float getSpeed() const { return m_speed; }
	constexpr float& getSpeedRef() { return m_speed; }
	void refresh();
private:
	void updateCol(float gameTime, float multiply);
	bool m_rainbow;
	Color m_color;
	float m_speed = 0.5f;
};
```

`hack/config/config.cpp`:

```cpp
#include "config.hpp"

#include "vars.hpp"
#include "jsonExtended.hpp"

#include <shlobj.h>
#include <stdexcept>
#include <format>
#include <fstream>
#include <filesystem>

#include <utilities/utilities.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/Color.hpp>

namespace config
{
	std::vector<std::string> allConfigFiles{ };
	std::string loadedCfgName{ };

	std::filesystem::path getPathForConfig(const std::string& file);
}

bool config::save(const std::string& file)
{
	if (file.empty())
	{
		console::error("provided config name was empty");
		return false;
	}

	json j;

	to_json(j["Aim"], *vars::aim);
	to_json(j["AimPaint"], *vars::aimPaint);
	to_json(j["Visuals"], *vars::visuals);
	to_json(j["Keys"], *vars::keys);
	to_json(j["Backtrack"], *vars::backtrack);
	to_json(j["Misc"], *vars::misc);
	to_json(j["Styling"], *vars::styling);

	HACK_TRY
	{
		std::ofstream out{ utilities::toLowerCase((api::getHackPath() / getPathForConfig(file)).string()) };
		if (!out)
			return false;

		out << std::setw(4) << j;
	}
	HACK_CATCH (const std::ofstream::failure& err)
	{
#if defined WANT_EXCEPTIONS
		console::error("Saving {} file has failed: {}", file, err.what());
#endif
	}

	console::debug("Saving file {}", file);

	return true;
}

bool config::load(const std::string& file)
{
	std::ifstream input{ api::getHackPath() / getPathForConfig(file) };
	if (!input)
		return false;

	json j = json::parse(input);

	from_json(j["Aim"], *vars::aim);
	from_json(j["AimPaint"], *vars::aimPaint);
	from_json(j["Visuals"], *vars::visuals);
	from_json(j["Keys"], *vars::keys);
	from_json(j["Backtrack"], *vars::backtrack);
	from_json(j["Misc"], *vars::misc);
	from_json(j["Styling"], *vars::styling);

	console::debug("Loading file {}", file);

	return true;
}

std::filesystem::path config::getPathForConfig(const std::string& file)
{
	std::filesystem::path path(file);
	if (path.extension() != ".cfg")
		path.replace_extension(".cfg");

	return path;
}

bool config::init()
{
	// check if the path to where save files is even a directory
	if (auto path = api::getHackPath(); !std::filesystem::exists(path))
	{
		// after removal, create the folder, from there the path is possible to reach
		if (!std::filesystem::create_directories(path))
			return false;
	}

	// same thing in load
	if (auto path = api::getHackPath() / api::localization.utilityPath; !std::filesystem::exists(path))
	{
		// after removal, create the folder, from there the path is possible to reach
		if (!std::filesystem::create_directories(path))
			return false;
	}

	// default file doesn't exist
	if (auto path = api::getHackPath() / api::localization.defaultConfigName; !std::filesystem::exists(path))
	{
		console::warn("Creating default file, because it doesn't exist: {}", path.string());

		if (!save(api::localization.defaultConfigName))
			return false;
	}

	// loading file doesnt exists
	if (auto path = api::getHackPath() / api::localization.utilityPath / api::localization.defaultLoadName; !std::filesystem::exists(path))
	{
		console::warn("Creating loading file, because it doesn't exist: {}", path.string());

		if (!startSave(api::localization.defaultConfigName))
			return false;
	}

	if (!startLoad())
		return false;

	// loaded file exists but config file is gone, then cleanup
	if (auto path = api::getHackPath() / loadedCfgName; !std::filesystem::exists(path))
	{
		console::warn("Creating loaded file, because it doesn't exist: {}", path.string());

		if (!save(loadedCfgName))
			return false;
	}

	if (!load(loadedCfgName))
		return false;

	// push file names with .cfg into vector
	reload();

	return true;
}

bool config::startLoad()
{
	std::ifstream input{ api::getHackPath() / api::localization.utilityPath / api::localization.defaultLoadName };
	if (!input)
		return false;

	json j = json::parse(input);

	from_json(j, "Name", loadedCfgName);

	return true;
}

bool config::startSave(const std::string& name)
{
	json j;
	j["Name"] = name;

	std::ofstream out{ api::getHackPath() / api::localization.utilityPath / api::localization.defaultLoadName };
	if (!out)
		return false;

	out << j;

	return true;
}

void config::reload()
{
	allConfigFiles.clear();
	auto iterator = std::filesystem::directory_iterator(api::getHackPath());
	for (const auto& entry : iterator)
	{
		if (std::string name = entry.path().filename().string();
			entry.path().extension() == ".cfg" && !name.empty())
		{
			allConfigFiles.push_back(name);
		}
	}
}

std::string config::getCfgToLoad()
{
	return loadedCfgName;
}

std::vector<std::string> config::getAllConfigFiles()
{
	return allConfigFiles;
}

void config::deleteCfg(const std::string& file)
{
	auto path = getPathForConfig(file);

	if (path.string() == api::localization.defaultConfigName)
	{
		console::error("Can't delete default config");
		return;
	}

	if (auto toDel = api::getHackPath() / path; std::filesystem::remove(toDel))
		console::debug("Removed config {}", toDel.filename().string());
}
```

`hack/config/config.hpp`:

```hpp
#pragma once

#include <filesystem>
#include <vector>
#include <string>

namespace config
{
	bool save(const std::string& file);
	bool load(const std::string& file);
	bool startLoad();
	bool startSave(const std::string& name);
	void deleteCfg(const std::string& file);
	HACK_INIT bool init();
	void reload();
	
	// file to load
	[[nodiscard]] std::string getCfgToLoad();
	// get all files
	[[nodiscard]] std::vector<std::string> getAllConfigFiles();
}
```

`hack/config/enums.hpp`:

```hpp
#pragma once

enum class AimbotWeapon
{
	RIFFLE,
	SMG,
	MACHINE_GUN,
	PISTOL,
	DEAGLE,
	REVOLVER,
	SCOUT,
	AWP,
	AUTO_SNIPER,
	SHOTGUN
};

enum class AimbotHitboxes
{
	NEAREST,
	HEAD,
	CHEST
};

enum class SmoothMode
{
	LINEAR,
	AIM_LENGTH,
	AIM_CUBIC
};

enum class CrossHairTypes
{
	OFF,
	STATIC,
	RECOIL,
	ENGINE,
	SPREAD
};

enum class ChamsType
{
	FLAT,
	GENERIC,
	GLOW,
	METALIC,
	PEARLSCENT
};

enum class BTChamsType
{
	STABLE,
	LAST_TICK,
	COLOR_CHANGE
};

enum class BoxTypes
{
	OFF,
	BOX2D,
	FILLED2D,
	BOX3D,
	FILLED3D
};

enum class MovementTrail
{
	BEAM,
	LINE,
	SPLASH
};

enum class EspFlags
{
	BOT,
	MONEY,
	WINS,
	RANK,
	ARMOR,
	ZOOM,
	C4,
};

enum class DroppedFlags
{
	BOX,
	TEXT,
	ICON,
	AMMO,
};

enum class MovementStraferMode
{
	OFF,
	SIDESPEED,
	ROTATE,
	DIRECTIONAL
};

enum class AimbotMethod
{
	CROSSHAIR,
	DYNAMIC
};

enum class MenuTypes
{
	CHERRY,
	DARK,
	CLASSIC,
	WHITE
};

enum class GlowRenderStyle
{
	DEFAULT = 0,
	RIMGLOW3D,
	EDGE_HIGHLIGHT,
	EDGE_HIGHLIGHT_PULSE
};

enum class GlowIgnorez
{
	RIMGLOW3D,
	EDGE_HIGHLIGHT,
	EDGE_HIGHLIGHT_PULSE
};

enum class GlowRenderPulse
{
	RIM,
	EDGE
};

enum class RadarMode
{
	TRIANGLE,
	CIRCLE
};

enum class PrecipitationConfig
{
	NONE,
	RAIN,
	SNOW,
	PARTICLERAIN,
	PARTICLERAINSTORM,
	PARTICLESNOW
};
```

`hack/config/jsonExtended.cpp`:

```cpp
#include "jsonExtended.hpp"

using namespace nlohmann::detail;

void from_json(const json& j, CfgWeapon& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "UseKey", val.useKey);
	from_json(j["Key"], val.key);
	from_json(j, "Fov", val.fov);
	from_json(j, "Smooth", val.frametimeMulttiply);
	from_json(j, "Aim method", val.methodAim);
	from_json(j, "Aim selection", val.aimSelection);
	from_json(j, "Aim delay enabled", val.aimDelay);
	from_json(j, "Aim delay ms", val.aimDelayVal);
	from_json(j, "Rcs enabled", val.rcs);
	from_json(j, "Rcs X", val.rcsX);
	from_json(j, "Rcs Y", val.rcsY);
	from_json(j, "Triggerbot enabled", val.triggerbot);
	from_json(j, "Triggerbot delay", val.triggerbotDelay);
	from_json(j, "Smoke check", val.smokeCheck);
	from_json(j, "Flash alpha limit", val.flashLimit);
}

void to_json(json& j, const CfgWeapon& val)
{
	j["Enabled"] = val.enabled;
	j["UseKey"] = val.useKey;
	j["Key"] = val.key;
	j["Fov"] = val.fov;
	j["Smooth"] = val.frametimeMulttiply;
	j["Aim method"] = val.methodAim;
	j["Aim selection"] = val.aimSelection;
	j["Aim delay enabled"] = val.aimDelay;
	j["Aim delay ms"] = val.aimDelayVal;
	j["Rcs enabled"] = val.rcs;
	j["Rcs X"] = val.rcsX;
	j["Rcs Y"] = val.rcsY;
	j["Triggerbot enabled"] = val.triggerbot;
	j["Triggerbot delay"] = val.triggerbotDelay;
	j["Smoke check"] = val.smokeCheck;
	j["Flash alpha limit"] = val.flashLimit;
}

void from_json(const json& j, CfgColor& val)
{
	from_json(j, "RGBA", val.getColorRef().getRef());
	from_json(j, "Rainbow", val.getRainbowRef());
	from_json(j, "Speed", val.getSpeedRef());
}
#include <iostream>

void to_json(json& j, const CfgColor& val)
{
	j["RGBA"] = val.getColor().get();
	j["Rainbow"] = val.getRainbow();
	j["Speed"] = val.getSpeed();
}

void from_json(const json& j, CfgBeam& val)
{
	from_json(j["Index"], val.index);
	from_json(j["Flags"], val.flags);
	from_json(j["Life"], val.life);
	from_json(j["BeamCol"], val.color);
	from_json(j["Width"], val.width);
	from_json(j["Fade length"], val.fadeLength);
	from_json(j["Amplitude"], val.amplitude);
	from_json(j["Speed"], val.speed);
	from_json(j["Start frame"], val.startFrame);
	from_json(j["Framerate"], val.frameRate);
	from_json(j["Segments"], val.segments);
}

void to_json(json& j, const CfgBeam& val)
{
	j["Index"] = val.index;
	j["Flags"] = val.flags;
	j["Life"] = val.life;
	j["BeamCol"] = val.color;
	j["Width"] = val.width;
	j["Fade length"] = val.fadeLength;
	j["Amplitude"] = val.amplitude;
	j["Speed"] = val.speed;
	j["Start frame"] = val.startFrame;
	j["Framerate"] = val.frameRate;
	j["Segments"] = val.segments;
}

void from_json(const json& j, Key& val)
{
	from_json(j, "Mode", val.getKeyModeInt());
	from_json(j, "Code", val.getKeyCode());
}

void to_json(json& j, const Key& val)
{
	j["Mode"] = val.getKeyMode();
	j["Code"] = val.getKeyCode();
}

void from_json(const json& j, CfgBox& val)
{
	from_json(j["Mode"], val.mode);
	from_json(j["Outline"], val.outline);
	from_json(j["Gradient"], val.gradient);
	from_json(j["Color"], val.color);
	from_json(j["Fill"], val.color);
	from_json(j["Gradient1"], val.gradientCol1);
	from_json(j["Gradient2"], val.gradientCol2);
	from_json(j["Gradient3"], val.gradientCol3);
	from_json(j["Gradient4"], val.gradientCol4);
}

void to_json(json& j, const CfgBox& val)
{
	j["Mode"] = val.mode;
	j["Outline"] = val.outline;
	j["Gradient"] = val.gradient;
	j["Color"] = val.color;
	j["Fill"] = val.fill;
	j["Gradient1"] = val.gradientCol1;
	j["Gradient2"] = val.gradientCol2;
	j["Gradient3"] = val.gradientCol3;
	j["Gradient4"] = val.gradientCol4;
}

void from_json(const json& j, CfgCham& val)
{
	from_json(j["Enabled"], val.enabled);
	from_json(j["Hide"], val.hide);
	from_json(j["Ignorez"], val.ignorez);
	from_json(j["Wireframe"], val.wireframe);
	from_json(j["Index"], val.index);
	from_json(j["Color"], val.color);
	from_json(j["ColorXQZ"], val.colorXQZ);
}

void to_json(json& j, const CfgCham& val)
{
	j["Enabled"] = val.enabled;
	j["Hide"] = val.hide;
	j["Ignorez"] = val.ignorez;
	j["Wireframe"] = val.wireframe;
	j["Index"] = val.index;
	j["Color"] = val.color;
	j["ColorXQZ"] = val.colorXQZ;
}

void from_json(const json& j, VarAim& val)
{
	from_json(j, "AimbotArr", val.weapons);
}

void to_json(json& j, const VarAim& val)
{
	j["AimbotArr"] = val.weapons;
}

void from_json(const json& j, VarAimPaint& val)
{
	from_json(j, "Enabled fov", val.enabledFov);
	from_json(j["Color Fov"], val.colorFov);
}

void to_json(json& j, const VarAimPaint& val)
{
	j["Enabled fov"] = val.enabledFov;
	j["Color Fov"] = val.colorFov;
}

void from_json(const json& j, VarVisuals& val)
{
	from_json(j["Chams"], *val.chams);
	from_json(j["Glow"], *val.glow);
	from_json(j["Esp"], *val.esp);
	from_json(j["Sound"], *val.sound);
	from_json(j["Dormacy"], *val.dormacy);
	from_json(j["World"], *val.world);
}

void to_json(json& j, const VarVisuals& val)
{
	to_json(j["Chams"], *val.chams);
	to_json(j["Glow"], *val.glow);
	to_json(j["Esp"], *val.esp);
	to_json(j["Sound"], *val.sound);
	to_json(j["Dormacy"], *val.dormacy);
	to_json(j["World"], *val.world);
}

void from_json(const json& j, VarVisuals::VarChams& val)
{
	from_json(j["Players"], val.players);
	from_json(j["Local Weapon"], val.weapon);
	from_json(j["Arms"], val.arms);
	from_json(j["Attachment"], val.attachement);
	from_json(j, "Backtrack enabled", val.backtrackEnabled);
	from_json(j, "Backtrack index", val.backtrackIndex);
	from_json(j, "Backtrack mode", val.backtrackMode);
	from_json(j["Backtrack Color"], val.backtrackColor);
	from_json(j["Attachment"], val.attachement);
	from_json(j["Streamproof"], val.streamProof);
	from_json(j["Ignore smoke"], val.ignoreSmoke);
}

void to_json(json& j, const VarVisuals::VarChams& val)
{
	j["Players"] = val.players;
	j["Local Weapon"] = val.weapon;
	j["Arms"] = val.arms;
	j["Attachment"] = val.attachement;
	j["Backtrack enabled"] = val.backtrackEnabled;
	j["Backtrack index"] = val.backtrackIndex;
	j["Backtrack mode"] = val.backtrackMode;
	j["Backtrack Color"] = val.backtrackColor;
	j["Attachment"] = val.attachement;
	j["Streamproof"] = val.streamProof;
	j["Ignore smoke"] = val.ignoreSmoke;
}

void from_json(const json& j, VarVisuals::VarGlow& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Streamproof", val.streamProof);
	from_json(j, "Full Bloom", val.fullBloom);
	from_json(j["Color player"], val.colorPlayer);
	from_json(j, "Speeds", val.pulseSpeeeds);
	from_json(j, "Visible", val.visible);
	from_json(j, "Exponent", val.exponent);
	from_json(j, "Saturation", val.saturation);
	from_json(j, "Bloom", val.C0_X);
	from_json(j, "Thickness", val.thickness);
	from_json(j, "UsedMats", val.usedMats);
	from_json(j, "Ignorez", val.ignorez);
}

void to_json(json& j, const VarVisuals::VarGlow& val)
{
	j["Enabled"] = val.enabled;
	j["Streamproof"] = val.streamProof;
	j["Full Bloom"] = val.fullBloom;
	j["Color player"] = val.colorPlayer;
	j["Speeds"] = val.pulseSpeeeds;
	j["Visible"] = val.visible;
	j["Exponent"] = val.exponent;
	j["Saturation"] = val.saturation;
	j["Bloom"] = val.C0_X;
	j["Thickness"] = val.thickness;
	j["UsedMats"] = val.usedMats;
	j["Ignorez"] = val.ignorez;
}

void from_json(const json& j, VarVisuals::VarEsp& val)
{
	from_json(j["Boxes"], *val.boxes);
	from_json(j["HealthBar"], *val.healthBar);
	from_json(j["ArmorBar"], *val.armorBar);
	from_json(j["WeaponBar"], *val.weaponBar);
	from_json(j["Name"], *val.nameBar);
	from_json(j["Skeleton"], *val.skeleton);
	from_json(j["Dlight"], *val.dlight);
	from_json(j["ExtraInfo"], *val.extraInfo);
	from_json(j["Flags"], *val.flags);
	from_json(j["Lasers"], *val.lasers);
	from_json(j["Checks"], *val.checks);
	from_json(j["Dropped"], *val.dropped);
}

void to_json(json& j, const VarVisuals::VarEsp& val)
{
	to_json(j["Boxes"], *val.boxes);
	to_json(j["HealthBar"], *val.healthBar);
	to_json(j["ArmorBar"], *val.armorBar);
	to_json(j["WeaponBar"], *val.weaponBar);
	to_json(j["Name"], *val.nameBar);
	to_json(j["Skeleton"], *val.skeleton);
	to_json(j["Dlight"], *val.dlight);
	to_json(j["ExtraInfo"], *val.extraInfo);
	to_json(j["Flags"], *val.flags);
	to_json(j["Lasers"], *val.lasers);
	to_json(j["Checks"], *val.checks);
	to_json(j["Dropped"], *val.dropped);
}

void from_json(const json& j, VarVisuals::VarEsp::VarBoxes& val)
{
	from_json(j, "Box", val.box);
}

void to_json(json& j, const VarVisuals::VarEsp::VarBoxes& val)
{
	j["Box"] = val.box;
}

void from_json(const json& j, VarVisuals::VarEsp::VarSnapline& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarEsp::VarSnapline& val)
{
	j["Enabled"] = val.enabled;
	j["Color"] = val.color;
}

void from_json(const json& j, VarVisuals::VarEsp::VarHealthBar& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarVisuals::VarEsp::VarHealthBar& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarVisuals::VarEsp::VarArmorBar& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarVisuals::VarEsp::VarArmorBar& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarVisuals::VarEsp::VarWeaponBar& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Enabled Translate", val.translate);
	from_json(j["Text"], val.text);
	from_json(j["Bar"], val.bar);
}

void to_json(json& j, const VarVisuals::VarEsp::VarWeaponBar& val)
{
	j["Enabled"] = val.enabled;
	j["Enabled Translate"] = val.translate;
	j["Text"] = val.text;
	j["Bar"] = val.bar;
}

void from_json(const json& j, VarVisuals::VarEsp::VarName& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarVisuals::VarEsp::VarName& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarVisuals::VarEsp::VarSkeleton& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Lines"], val.color);
	from_json(j, "Debug points", val.showDebug);
}

void to_json(json& j, const VarVisuals::VarEsp::VarSkeleton& val)
{
	j["Enabled"] = val.enabled;
	j["Lines"] = val.color;
	j["Debug points"] = val.showDebug;
}

void from_json(const json& j, VarVisuals::VarEsp::VarDlight& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color"], val.color);
	from_json(j, "Radius", val.radius);
	from_json(j, "Decay", val.decay);
	from_json(j, "Exponent", val.exponent);
}

void to_json(json& j, const VarVisuals::VarEsp::VarDlight& val)
{
	j["Enabled"] = val.enabled;
	j["Color"] = val.color;
	j["Radius"] = val.radius;
	j["Decay"] = val.decay;
	j["Exponent"] = val.exponent;
}

void from_json(const json& j, VarVisuals::VarEsp::VarExtraInfo& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarVisuals::VarEsp::VarExtraInfo& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarVisuals::VarEsp::VarFlags& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Flags", val.flags);
}

void to_json(json& j, const VarVisuals::VarEsp::VarFlags& val)
{
	j["Enabled"] = val.enabled;
	j["Flags"] = val.flags;
}

void from_json(const json& j, VarVisuals::VarEsp::VarLasers& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarVisuals::VarEsp::VarLasers& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarVisuals::VarEsp::VarChecks& val)
{
	from_json(j, "Dead only", val.dead);
	from_json(j, "Smoke check", val.smoke);
	from_json(j, "Visible check", val.visible);
	from_json(j, "Flash limit", val.flashLimit);
}

void to_json(json& j, const VarVisuals::VarEsp::VarChecks& val)
{
	j["Dead only"] = val.dead;
	j["Smoke check"] = val.smoke;
	j["Visible check"] = val.visible;
	j["Flash limit"] = val.flashLimit;
}

void from_json(const json& j, VarVisuals::VarEsp::VarDropped& val)
{
	from_json(j, "Enbaled", val.enabled);
	from_json(j["Ammo Color"], val.ammoColor);
	from_json(j["Text Color"], val.textColor);
	from_json(j["Icon Color"], val.iconColor);
	from_json(j, "Flags", val.flags);
}

void to_json(json& j, const VarVisuals::VarEsp::VarDropped& val)
{
	j["Enabled"] = val.enabled;
	j["Ammo Color"] = val.ammoColor;
	j["Text Color"] = val.textColor;
	j["Icon Color"] = val.iconColor;
	j["Flags"] = val.flags;
}

void from_json(const json& j, VarVisuals::VarSound& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color"], val.color);
	from_json(j, "Time", val.time);
	from_json(j, "Max dist", val.maxDist);
	from_json(j, "Max dist line", val.maxDistLine);
	from_json(j["Line"], val.colorLine);
}

void to_json(json& j, const VarVisuals::VarSound& val)
{
	j["Enabled"] = val.enabled;
	j["Color"] = val.color;
	j["Time"] = val.enabled;
	j["Max dist"] = val.enabled;
	j["Max dist line"] = val.enabled;
	j["Line"] = val.colorLine;
}

void from_json(const json& j, VarVisuals::VarDormacy& val)
{
	from_json(j, "Time", val.time);
	from_json(j, "Time limit", val.limit);
}

void to_json(json& j, const VarVisuals::VarDormacy& val)
{
	j["Time"] = val.time;
	j["Time limit"] = val.limit;
}

void from_json(const json& j, VarVisuals::VarWorld& val)
{
	from_json(j["Bomb"], *val.bomb);
	from_json(j["Projectiles"], *val.projectiles);
	from_json(j["Sky"], *val.sky);
	from_json(j["Modulate"], *val.modulate);
	from_json(j["Molotov"], *val.molotov);
	from_json(j["Smoke"], *val.smoke);
	from_json(j["Zeus"], *val.zeus);
	from_json(j["Particles"], *val.particles);
	from_json(j["Tracer"], *val.tracer);
	from_json(j["Impacts"], *val.impacts);
	from_json(j["Fog"], *val.fog);
	from_json(j["ScreenEffect"], *val.screenEffect);
	from_json(j["Tone"], *val.tone);
	from_json(j["Weather"], *val.weather);
	from_json(j["Ambient"], *val.ambient);
}

void to_json(json& j, const VarVisuals::VarWorld& val)
{
	to_json(j["Bomb"], *val.bomb);
	to_json(j["Projectiles"], *val.projectiles);
	to_json(j["Sky"], *val.sky);
	to_json(j["Modulate"], *val.modulate);
	to_json(j["Molotov"], *val.molotov);
	to_json(j["Smoke"], *val.smoke);
	to_json(j["Zeus"], *val.zeus);
	to_json(j["Particles"], *val.particles);
	to_json(j["Tracer"], *val.tracer);
	to_json(j["Impacts"], *val.impacts);
	to_json(j["Fog"], *val.fog);
	to_json(j["ScreenEffect"], *val.screenEffect);
	to_json(j["Tone"], *val.tone);
	to_json(j["Weather"], *val.weather);
	to_json(j["Ambient"], *val.ambient);
}

void from_json(const json& j, VarVisuals::VarWorld::VarBomb& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color"], val.background);
}

void to_json(json& j, const VarVisuals::VarWorld::VarBomb& val)
{
	j["Enabled"] = val.enabled;
	j["Color"] = val.background;
}

void from_json(const json& j, VarVisuals::VarWorld::VarProjectiles& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Flash"], val.flash);
	from_json(j["Nade"], val.nade);
	from_json(j["Molotov"], val.molotov);
	from_json(j["Smoke"], val.smoke);
	from_json(j["Decoy"], val.decoy);
}

void to_json(json& j, const VarVisuals::VarWorld::VarProjectiles& val)
{
	j["Enabled"] = val.enabled;
	j["Flash"] = val.flash;
	j["Nade"] = val.nade;
	j["Molotov"] = val.molotov;
	j["Smoke"] = val.smoke;
	j["Decoy"] = val.decoy;
}

void from_json(const json& j, VarVisuals::VarWorld::VarSky& val)
{
	from_json(j, "Skybox normal", val.indexNormal);
	from_json(j, "Skybox custom", val.indexCustom);
	from_json(j, "Remove sky", val.removeSky);
}

void to_json(json& j, const VarVisuals::VarWorld::VarSky& val)
{
	j["Skybox normal"] = val.indexNormal;
	j["Skybox custom"] = val.indexCustom;
	j["Remove sky"] = val.removeSky;
}

void from_json(const json& j, VarVisuals::VarWorld::VarModulate& val)
{
	from_json(j, "EnabledTexture", val.enabledTexture);
	from_json(j["Texture"], val.texture);
	from_json(j, "EnabledProp", val.enabledProp);
	from_json(j["Prop"], val.prop);
	from_json(j, "EnabledSky", val.enabledSky);
	from_json(j["Sky"], val.sky);
	from_json(j, "EnabledLights", val.enabledLights);
	from_json(j["Light"], val.lights);
	from_json(j["LightStrenght"], val.lightsStrenght);
	from_json(j, "EnabledShader", val.enabledShader);
	from_json(j, "Shader param", val.shader);
}

void to_json(json& j, const VarVisuals::VarWorld::VarModulate& val)
{
	j["EnabledTexture"] = val.enabledTexture;
	j["Texture"] = val.texture;
	j["EnabledProp"] = val.enabledProp;
	j["Prop"] = val.prop;
	j["EnabledSky"] = val.enabledSky;
	j["Sky"] = val.sky;
	j["EnabledLights"] = val.enabledLights;
	j["Light"] = val.lights;
	j["LightStrenght"] = val.lightsStrenght;
	j["EnabledShader"] = val.enabledShader;
	j["Shader param"] = val.shader;
}

void from_json(const json& j, VarVisuals::VarWorld::VarMolotov& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Triangulation", val.triangulation);
	from_json(j["Molly"], val.color);
	from_json(j["Text"], val.colorText);
}

void to_json(json& j, const VarVisuals::VarWorld::VarMolotov& val)
{
	j["Enabled"] = val.enabled;
	j["Triangulation"] = val.triangulation;
	j["Molly"] = val.color;
	j["Text"] = val.colorText;
}

void from_json(const json& j, VarVisuals::VarWorld::VarSmoke& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarWorld::VarSmoke& val)
{
	j["Enabled"] = val.enabled;
	j["Color"] = val.color;
}

void from_json(const json& j, VarVisuals::VarWorld::VarZeus& val)
{
	from_json(j, "Range", val.enabled);
	from_json(j, "Party", val.party);
	from_json(j, "Tracing", val.tracing);
	from_json(j["Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarWorld::VarZeus& val)
{
	j["Range"] = val.enabled;
	j["Party"] = val.party;
	j["Tracing"] = val.tracing;
	j["Color"] = val.color;
}

void from_json(const json& j, VarVisuals::VarWorld::VarParticles& val)
{
	from_json(j, "Enabled Smoke", val.enabledSmoke);
	from_json(j["Smoke"], val.colorSmoke);
	from_json(j, "Enabled Blood", val.enabledBlood);
	from_json(j["Blood"], val.colorBlood);
	from_json(j, "Enabled Molly", val.enabledMolotov);
	from_json(j["Molly"], val.colorMolotov);
}

void to_json(json& j, const VarVisuals::VarWorld::VarParticles& val)
{
	j["Enabled Smoke"] = val.enabledSmoke;
	j["Smoke"], val.colorSmoke;
	j["Enabled Blood"] = val.enabledBlood;
	j["Blood"], val.colorBlood;
	j["Enabled Molly"] = val.enabledMolotov;
	j["Molly"], val.colorMolotov;
}

void from_json(const json& j, VarVisuals::VarWorld::VarTracer& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Beam"], val.beamTracer);
}

void to_json(json& j, const VarVisuals::VarWorld::VarTracer& val)
{
	j["Enabled"] = val.enabled;
	j["Beam"] = val.beamTracer;
}

void from_json(const json& j, VarVisuals::VarWorld::VarImpacts& val)
{
	from_json(j, "Client enabled", val.enabledClient);
	from_json(j, "Client time", val.timeClient);
	from_json(j["LineClient"], val.colorClient);
	from_json(j["FillClient"], val.colorClientFill);
	from_json(j, "Local enabled", val.enabledClient);
	from_json(j, "Local time", val.timeLocal);
	from_json(j["LineLocal"], val.colorLocal);
	from_json(j["FillLocal"], val.colorLocalFill);
}

void to_json(json& j, const VarVisuals::VarWorld::VarImpacts& val)
{
	j["Client enabled"] = val.enabledClient;
	j["Client time"] = val.timeClient;
	j["LineClient"] = val.colorClient;
	j["FillClient"] = val.colorClientFill;
	j["Local enabled"] = val.enabledClient;
	j["Local time"] = val.timeLocal;
	j["LineLocal"] = val.colorLocal;
	j["FillLocal"] = val.colorLocalFill;
}

void from_json(const json& j, VarVisuals::VarWorld::VarFog& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Distance", val.distance);
	from_json(j["Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarWorld::VarFog& val)
{
	j["Enabled"] = val.enabled;
	j["Distance"] = val.distance;
	j["Color"] = val.color;
}

void from_json(const json& j, VarVisuals::VarWorld::VarScreenEffect& val)
{
	from_json(j, "Index", val.index);
	from_json(j, "Param", val.param);
	from_json(j["Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarWorld::VarScreenEffect& val)
{
	j["Index"] = val.index;
	j["Param"] = val.param;
	j["Color"] = val.color;
}

void from_json(const json& j, VarVisuals::VarWorld::VarTone& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Min", val.min);
	from_json(j, "max", val.max);
	from_json(j, "Bloom", val.bloom);
}

void to_json(json& j, const VarVisuals::VarWorld::VarTone& val)
{
	j["Enabled"] = val.enabled;
	j["Min"] = val.min;
	j["Max"] = val.max;
	j["Bloom"] = val.bloom;
}

void from_json(const json& j, VarVisuals::VarWorld::VarWeather& val)
{
	from_json(j, "Type", val.type);
	from_json(j, "Length", val.length);
	from_json(j, "Rain Speed", val.rainSpeed);
	from_json(j, "Width", val.width);
	from_json(j, "Velocity", val.velocity);
	from_json(j, "Alpha", val.alpha);
	from_json(j, "Wind", val.windSpeed);
	from_json(j, "Volume", val.volume);
	from_json(j, "Snow Edit", val.snowParticleEdit);
	from_json(j["Snow Particle Inner Near"], val.snowParticleInnerNearColor);
	from_json(j["Snow Particle Inner Far"], val.snowParticleInnerFarColor);
	from_json(j["Snow Particle Outer"], val.snowParticleOuterColor);
	from_json(j, "Rain Edit", val.rainParticleEdit);
	from_json(j["Rain Particle Inner Near"], val.rainParticleInnerNearColor);
	from_json(j["Rain Particle Inner Far"], val.rainParticleInnerFarColor);
	from_json(j["Rain Particle Outer"], val.rainParticleOuterColor);
	from_json(j, "Rain Storm Edit", val.rainStormParticleEdit);
	from_json(j["Rain Storm Particle Inner Near"], val.rainStormParticleInnerNearColor);
	from_json(j["Rain Storm Particle Inner Far"], val.rainStormParticleInnerFarColor);
	from_json(j["Rain Storm Particle Outer"], val.rainStormParticleOuterColor);
	from_json(j, "CustomNear", val.customNear);
	from_json(j, "CustomFar", val.customFar);
	from_json(j, "UseGround", val.useGround);
	from_json(j, "Storm Effects", val.storm);
}

void to_json(json& j, const VarVisuals::VarWorld::VarWeather& val)
{
	j["Type"] = val.type;
	j["Length"] = val.length;
	j["Rain Speed"] = val.rainSpeed;
	j["Width"] = val.width;
	j["Velocity"] = val.velocity;
	j["Alpha"] = val.alpha;
	j["Wind"] = val.windSpeed;
	j["Volume"] = val.volume;
	j["Snow Edit"] = val.snowParticleEdit;
	j["Snow Particle Inner Near"] = val.snowParticleInnerNearColor;
	j["Snow Particle Inner Far"] = val.snowParticleInnerFarColor;
	j["Snow Particle Outer"] = val.snowParticleOuterColor;
	j["Rain Edit"] = val.rainParticleEdit;
	j["Rain Particle Inner Near"] = val.rainParticleInnerNearColor;
	j["Rain Particle Inner Far"] = val.rainParticleInnerFarColor;
	j["Rain Particle Outer"] = val.rainParticleOuterColor;
	j["Rain Storm Edit"] = val.rainStormParticleEdit;
	j["Rain Storm Particle Inner Near"] = val.rainStormParticleInnerNearColor;
	j["Rain Storm Particle Inner Far"] = val.rainStormParticleInnerFarColor;
	j["Rain Storm Particle Outer"] = val.rainStormParticleOuterColor;
	j["CustomNear"] = val.customNear;
	j["CustomFar"] = val.customFar;
	j["UseGround"] = val.useGround;
	j["Storm Effects"] = val.storm;
}

void from_json(const json& j, VarVisuals::VarWorld::VarAmbient& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Color"], val.color);
}

void to_json(json& j, const VarVisuals::VarWorld::VarAmbient& val)
{
	j["Enabled"] = val.enabled;
	j["Color"], val.color;
}

void from_json(const json& j, VarKeys& val)
{
	from_json(j, "Enabled X88", val.enabledX88Menu);
	from_json(j, "X88", val.x88Toggle);
	from_json(j["Menu"], val.menu);
	from_json(j["Panic"], val.panic);
	from_json(j["Logs"], val.console);
	from_json(j["MirrorCam"], val.mirrorCam);
	from_json(j["FreeCam"], val.freeCam);
	from_json(j["FlashLight"], val.flashLight);
	from_json(j["Thirdp"], val.thirdP);
}

void to_json(json& j, const VarKeys& val)
{
	j["Enabled X88"] = val.enabledX88Menu;
	j["X88"] = val.x88Toggle;
	j["Menu"] = val.menu;
	j["Panic"] = val.panic;
	j["Logs"] = val.console;
	j["MirrorCam"] = val.mirrorCam;
	j["FreeCam"] = val.freeCam;
	j["FlashLight"] = val.flashLight;
	j["Thirdp"] = val.thirdP;
}

void from_json(const json& j, VarBacktrack& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Time", val.time);
	from_json(j, "Smoke", val.smoke);
	from_json(j, "Flash limit", val.flashLimit);
}

void to_json(json& j, const VarBacktrack& val)
{
	j["Enabled"] = val.enabled;
	j["Time"] = val.time;
	j["Smoke"] = val.smoke;
	j["Flash limit"] = val.flashLimit;
}

void from_json(const json& j, VarMisc& val)
{
	from_json(j["Logs"], *val.logs);
	from_json(j["Fov"], *val.fov);
	from_json(j["ThridP"], *val.thirdp);
	from_json(j["Crosshair"], *val.crosshair);
	from_json(j["FakeLatency"], *val.fakeLatency);
	from_json(j["BunnyHop"], *val.bunnyHop);
	from_json(j["Hitmarker"], *val.hitmarker);
	from_json(j["Scope"], *val.scope);
	from_json(j["Plots"], *val.plots);
	from_json(j["Info"], *val.info);
	from_json(j["Playerlist"], *val.playerList);
	from_json(j["Spectactors"], *val.spectactorList);
	from_json(j["AimWarn"], *val.aimWarn);
	from_json(j["Radar"], *val.radar);
	from_json(j["Trail"], *val.trail);
	from_json(j["Nades"], *val.nade);
	from_json(j["MotionBlur"], *val.motionBlur);
	from_json(j["MirrorCam"], *val.mirrorCam);
	from_json(j["FreeCam"], *val.freeCam);
	from_json(j["Flashlight"], *val.flashLight);
	from_json(j["DisableItems"], *val.disableItems);
}

void to_json(json& j, const VarMisc& val)
{
	to_json(j["Logs"], *val.logs);
	to_json(j["Fov"], *val.fov);
	to_json(j["ThridP"], *val.thirdp);
	to_json(j["Crosshair"], *val.crosshair);
	to_json(j["FakeLatency"], *val.fakeLatency);
	to_json(j["BunnyHop"], *val.bunnyHop);
	to_json(j["Hitmarker"], *val.hitmarker);
	to_json(j["Scope"], *val.scope);
	to_json(j["Plots"], *val.plots);
	to_json(j["Info"], *val.info);
	to_json(j["Playerlist"], *val.playerList);
	to_json(j["Spectactors"], *val.spectactorList);
	to_json(j["AimWarn"], *val.aimWarn);
	to_json(j["Radar"], *val.radar);
	to_json(j["Trail"], *val.trail);
	to_json(j["Nades"], *val.nade);
	to_json(j["MotionBlur"], *val.motionBlur);
	to_json(j["MirrorCam"], *val.mirrorCam);
	to_json(j["FreeCam"], *val.freeCam);
	to_json(j["Flashlight"], *val.flashLight);
	to_json(j["DisableItems"], *val.disableItems);
}

void from_json(const json& j, VarMisc::VarLogs& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Time", val.time);
}

void to_json(json& j, const VarMisc::VarLogs& val)
{
	j["Enabled"] = val.enabled;
	j["Time"] = val.time;
}

void from_json(const json& j, VarMisc::VarFov& val)
{
	from_json(j, "Fov", val.value);
}

void to_json(json& j, const VarMisc::VarFov& val)
{
	j["Fov"] = val.value;
}

void from_json(const json& j, VarMisc::VarThridP& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Distance", val.distance);
	from_json(j, "X", val.x);
	from_json(j, "Y", val.y);
}

void to_json(json& j, const VarMisc::VarThridP& val)
{
	j["Enabled"] = val.enabled;
	j["Distance"] = val.distance;
	j["X"] = val.x;
	j["Y"] = val.y;
}

void from_json(const json& j, VarMisc::VarCrosshair& val)
{
	from_json(j, "Mode", val.index);
}

void to_json(json& j, const VarMisc::VarCrosshair& val)
{
	j["Mode"] = val.index;
}

void from_json(const json& j, VarMisc::VarFakeLatency& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Amount", val.amount);
}

void to_json(json& j, const VarMisc::VarFakeLatency& val)
{
	j["Enabled"] = val.enabled;
	j["Amount"] = val.amount;
}

void from_json(const json& j, VarMisc::VarBunnyHop& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Chance", val.chance);
	from_json(j, "Mode", val.indexStrafe);
}

void to_json(json& j, const VarMisc::VarBunnyHop& val)
{
	j["Enabled"] = val.enabled;
	j["Chance"] = val.chance;
	j["Mode"] = val.indexStrafe;
}

void from_json(const json& j, VarMisc::VarHitmarker& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Play", val.play);
	from_json(j, "3D", val.enabled3D);
	from_json(j, "Resize", val.enabledResize);
	from_json(j["Normal"], val.colorNormal);
	from_json(j["Head"], val.colorHead);
	from_json(j["Dead"], val.colorDead);
	from_json(j, "Time", val.time);
}

void to_json(json& j, const VarMisc::VarHitmarker& val)
{
	j["Enabled"] = val.enabled;
	j["Play"] = val.play;
	j["3D"] = val.enabled3D;
	j["Resize"] = val.enabledResize;
	j["Normal"] = val.colorNormal;
	j["Head"] = val.colorHead;
	j["Dead"] = val.colorDead;
	j["Time"] = val.time;
}

void from_json(const json& j, VarMisc::VarScope& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarMisc::VarScope& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarMisc::VarPlots& val)
{
	from_json(j, "Enabled FPS", val.enabledFps);
	from_json(j, "Enabled Velocity", val.enabledVelocity);
	from_json(j["Fps"], val.colorFPS);
	from_json(j["Velocity"], val.colorVelocity);
	from_json(j, "FPS size", val.sizeFps);
	from_json(j, "Velocity size", val.sizeVelocity);
	from_json(j, "Velocity transparency", val.transparencyVelocity);
}

void to_json(json& j, const VarMisc::VarPlots& val)
{
	j["Enabled FPS"] = val.enabledFps;
	j["Enabled Velocity"] = val.enabledVelocity;
	j["Fps"] = val.colorFPS;
	j["Velocity"] = val.colorVelocity;
	j["FPS size"] = val.sizeFps;
	j["Velocity size"] = val.sizeVelocity;
	j["Velocity transparency"] = val.transparencyVelocity;
}

void from_json(const json& j, VarMisc::VarInfo& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarMisc::VarInfo& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarMisc::VarPlayerList& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Health", val.health);
	from_json(j, "Team", val.teamID);
	from_json(j, "Money", val.money);
	from_json(j, "LastPlace", val.lastPlace);
}

void to_json(json& j, const VarMisc::VarPlayerList& val)
{
	j["Enabled"] = val.enabled;
	j["Health"] = val.health;
	j["Team"] = val.teamID;
	j["Money"] = val.money;
	j["LastPlace"] = val.lastPlace;
}

void from_json(const json& j, VarMisc::VarSpectactorList& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarMisc::VarSpectactorList& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarMisc::VarAimWarn& val)
{
	from_json(j, "Enabled", val.enabled);
}

void to_json(json& j, const VarMisc::VarAimWarn& val)
{
	j["Enabled"] = val.enabled;
}

void from_json(const json& j, VarMisc::VarRadar& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j["Line"], val.colorLine);
	from_json(j["Player"], val.colorPlayer);
	from_json(j, "Thickness", val.thickness);
	from_json(j, "Length", val.length);
	from_json(j, "Scale", val.scale);
	from_json(j, "Ranges", val.ranges);
}

void to_json(json& j, const VarMisc::VarRadar& val)
{
	j["Enabled"] = val.enabled;
	j["Line"] = val.colorLine;
	j["Player"] = val.colorPlayer;
	j["Thickness"] = val.thickness;
	j["Length"] = val.length;
	j["Scale"] = val.scale;
	j["Ranges"] = val.ranges;
}

void from_json(const json& j, VarMisc::VarTrail& val)
{
	from_json(j, "Enabled", val.enabled);
	from_json(j, "Mode", val.mode);
	from_json(j["Beam"], val.beam);
	from_json(j["Color line"], val.colorLine);
	from_json(j, "Line life", val.lineLife);
	from_json(j["Color splash"], val.colorSplash);
}

void to_json(json& j, const VarMisc::VarTrail& val)
{
	j["Enabled"] = val.enabled;
	j["Mode"] = val.mode;
	j["Beam"] = val.beam;
	j["Color line"] = val.colorLine;
	j["Line life"] = val.lineLife;
	j["Color splash"] = val.colorSplash;
}

void from_json(const json& j, VarMisc::VarNades& val)
{
	from_json(j, "Enable prediction", val.enabledPred);
	from_json(j, "Always", val.predAlways);
	from_json(j["Pred"], val.colorPredLine);
	from_json(j["Fill"], val.colorPredBoxFill);
	from_json(j["Outline"], val.colorPredBox);
	from_json(j["Enable tracer"], val.enabledTracer);
	from_json(j["TracerLine"], val.colorTracer);
	from_json(j, "Tracer distance", val.tracerDist);
	from_json(j, "Tracer warning", val.tracerWarn);
}

void to_json(json& j, const VarMisc::VarNades& val)
{
	j["Enable prediction"] = val.enabledPred;
	j["Always"] = val.predAlways;
	j["Pred"] = val.colorPredLine;
	j["Fill"] = val.colorPredBoxFill;
	j["Outline"] = val.colorPredBox;
	j["Enable tracer"] = val.enabledTracer;
	j["TracerLine"] = val.colorTracer;
	j["Tracer distance"] = val.tracerDist;
	j["Tracer warning"] = val.tracerWarn;
}

void from_json(const json& j, VarMisc::VarMotionBlur& val)
{
	from_json(j, "Enable", val.enabled);
	from_json(j, "Forward", val.forward);
	from_json(j, "Falling Intensity", val.fallingIntensity);
	from_json(j, "Falling Min", val.fallingMin);
	from_json(j, "Falling Max", val.fallingMax);
	from_json(j, "Strength", val.strength);
	from_json(j, "Rotation Intensity", val.rotationIntensity);
	from_json(j, "Roll Intensity", val.rollIntensity);
}

void to_json(json& j, const VarMisc::VarMotionBlur& val)
{
	j["Enable"] = val.enabled;
	j["Forward"] = val.forward;
	j["Falling Intensity"] = val.fallingIntensity;
	j["Falling Min"] = val.fallingMin;
	j["Falling Max"] = val.fallingMax;
	j["Strength"] = val.strength;
	j["Rotation Intensity"] = val.rotationIntensity;
	j["Roll Intensity"] = val.rollIntensity;
}

void from_json(const json& j, VarMisc::VarMirrorCam& val)
{
	from_json(j, "Enable", val.enabled);
	from_json(j, "On key", val.onKey);
}

void to_json(json& j, const VarMisc::VarMirrorCam& val)
{
	j["Enable"] = val.enabled;
	j["On key"] = val.onKey;
}

void from_json(const json& j, VarMisc::VarFreeCam& val)
{
	from_json(j, "Enable", val.enabled);
	from_json(j, "Speed", val.speed);
}

void to_json(json& j, const VarMisc::VarFreeCam& val)
{
	j["Enable"] = val.enabled;
	j["Speed"] = val.speed;
}

void from_json(const json& j, VarMisc::VarFlashlight& val)
{
	from_json(j, "Enable", val.enabled);
	from_json(j, "Big mode", val.bigMode);
	from_json(j, "Fov", val.fov);
}

void to_json(json& j, const VarMisc::VarFlashlight& val)
{
	j["Enable"] = val.enabled;
	j["Big mode"] = val.bigMode;
	j["Fov"] = val.fov;
}

void from_json(const json& j, VarMisc::DisableItems& val)
{
	from_json(j, "Interpolate", val.interpolate);
	from_json(j, "Flash", val.flashPercentage);
}

void to_json(json& j, const VarMisc::DisableItems& val)
{
	j["Interpolate"] = val.interpolate;
	j["Flash"] = val.flashPercentage;
}

#include <imgui.h>

void from_json(const json& j, VarStyling& val)
{
	from_json(j, "Index", val.index);
	from_json(j, "Background", val.background);
	from_json(j, "Background speed", val.speed);
	from_json(j, "Background distance points", val.distance);
	from_json(j, "Background points size", val.size);
	from_json(j["1"], val.color1);
	from_json(j["2"], val.color2);
	from_json(j["3"], val.color3);
	from_json(j["ImGuiStyling"], val.imStyle);
	from_json(j["GroupPanel Colors"], val.groupPanelBackground);
	from_json(j["GroupPanel Line"], val.groupPanelLines);
}

void to_json(json& j, const VarStyling& val)
{
	j["Index"] = val.index;
	j["Background"] = val.background;
	j["Background speed"] = val.speed;
	j["Background distance points"] = val.distance;
	j["Background points size"] = val.size;
	j["1"], val.color1;
	j["2"], val.color2;
	j["3"], val.color3;
	j["ImGuiStyling"] = val.imStyle;
	j["GroupPanel Colors"] = val.groupPanelBackground;
	j["GroupPanel Line"] = val.groupPanelLines;
}

void from_json(const json& j, ImVec2& val)
{
	from_json(j, "x", val.x);
	from_json(j, "y", val.y);
}

void to_json(json& j, const ImVec2& val)
{
	j["x"] = val.x;
	j["y"] = val.y;
}

void from_json(const json& j, ImVec4& val)
{
	from_json(j, "x", val.x);
	from_json(j, "y", val.y);
	from_json(j, "z", val.z);
	from_json(j, "w", val.w);
}

void to_json(json& j, const ImVec4& val)
{
	j["x"] = val.x;
	j["y"] = val.y;
	j["z"] = val.z;
	j["w"] = val.w;
}

// only reason for this: because span won't wrap it in one func
template<typename T, size_t SIZE>
void from_json(const json& j, const std::string& key, T val[SIZE])
{
	if (!j.contains(key))
		return;

	if (auto jval = j.at(key); jval.is_array())
	{
		// get_to throwing some weird exception to allow only numbers?
		for (size_t i = 0; i < jval.size(); i++)
			val[i] = jval[i];
		/*jval.get_to<T>(val[i]);*/
	}
}

void from_json(const json& j, ImGuiStyle& val)
{
	from_json(j, "Alpha", val.Alpha);
	from_json(j, "AisabledAlpha", val.DisabledAlpha);
	from_json(j["WindowPadding"], val.WindowPadding);
	from_json(j, "WindowRounding", val.WindowRounding);
	from_json(j, "WindowBorderSize", val.WindowBorderSize);
	from_json(j["WindowMinSize"], val.WindowMinSize);
	from_json(j["WindowTitleAlign"], val.WindowTitleAlign);
	from_json(j, "WindowMenuButtonPosition", val.WindowMenuButtonPosition);
	from_json(j, "ChildRounding", val.ChildRounding);
	from_json(j, "ChildBorderSize", val.ChildBorderSize);
	from_json(j, "PopupRounding", val.PopupRounding);
	from_json(j, "PopupBorderSize", val.PopupBorderSize);
	from_json(j["FramePadding"], val.FramePadding);
	from_json(j, "FrameRounding", val.FrameRounding);
	from_json(j, "FrameBorderSize", val.FrameBorderSize);
	from_json(j["ItemSpacing"], val.ItemSpacing);
	from_json(j["ItemInnerSpacing"], val.ItemInnerSpacing);
	from_json(j["CellPadding"], val.CellPadding);
	from_json(j["TouchExtraPadding"], val.TouchExtraPadding);
	from_json(j, "IndentSpacing", val.IndentSpacing);
	from_json(j, "ColumnsMinSpacing", val.ColumnsMinSpacing);
	from_json(j, "ScrollbarSize", val.ScrollbarSize);
	from_json(j, "ScrollbarRounding", val.ScrollbarRounding);
	from_json(j, "GrabMinSize", val.GrabMinSize);
	from_json(j, "LogSliderDeadzone", val.LogSliderDeadzone);
	from_json(j, "TabRounding", val.TabRounding);
	from_json(j, "TabBorderSize", val.TabBorderSize);
	from_json(j, "TabMinWidthForCloseButton", val.TabMinWidthForCloseButton);
	from_json(j, "ColorButtonPosition", val.ColorButtonPosition);
	from_json(j["ButtonTextAlign"], val.ButtonTextAlign);
	from_json(j["SelectableTextAlign"], val.SelectableTextAlign);
	from_json(j["DisplayWindowPadding"], val.DisplayWindowPadding);
	from_json(j["DisplaySafeAreaPadding"], val.DisplaySafeAreaPadding);
	from_json(j, "MouseCursorScale", val.MouseCursorScale);
	from_json(j, "AntiAliasedLines", val.AntiAliasedLines);
	from_json(j, "AntiAliasedLinesUseTex", val.AntiAliasedLinesUseTex);
	from_json(j, "AntiAliasedFill", val.AntiAliasedFill);
	from_json(j, "CurveTessellationTol", val.CurveTessellationTol);
	from_json(j, "CircleTessellationMaxError", val.CircleTessellationMaxError);
	from_json<ImVec4, ImGuiCol_COUNT>(j, "Colors", val.Colors);
}

void to_json(json& j, const ImGuiStyle& val)
{
	j["Alpha"] = val.Alpha;
	j["AisabledAlpha"] = val.DisabledAlpha;
	j["WindowPadding"] = val.WindowPadding;
	j["WindowRounding"] = val.WindowRounding;
	j["WindowBorderSize"] = val.WindowBorderSize;
	j["WindowMinSize"] = val.WindowMinSize;
	j["WindowTitleAlign"] = val.WindowTitleAlign;
	j["WindowMenuButtonPosition"] = val.WindowMenuButtonPosition;
	j["ChildRounding"] = val.ChildRounding;
	j["ChildBorderSize"] = val.ChildBorderSize;
	j["PopupRounding"] = val.PopupRounding;
	j["PopupBorderSize"] = val.PopupBorderSize;
	j["FramePadding"] = val.FramePadding;
	j["FrameRounding"] = val.FrameRounding;
	j["FrameBorderSize"] = val.FrameBorderSize;
	j["ItemSpacing"] = val.ItemSpacing;
	j["ItemInnerSpacing"] = val.ItemInnerSpacing;
	j["CellPadding"] = val.CellPadding;
	j["TouchExtraPadding"] = val.TouchExtraPadding;
	j["IndentSpacing"] = val.IndentSpacing;
	j["ColumnsMinSpacing"] = val.ColumnsMinSpacing;
	j["ScrollbarSize"] = val.ScrollbarSize;
	j["ScrollbarRounding"] = val.ScrollbarRounding;
	j["GrabMinSize"] = val.GrabMinSize;
	j["LogSliderDeadzone"] = val.LogSliderDeadzone;
	j["TabRounding"] = val.TabRounding;
	j["TabBorderSize"] = val.TabBorderSize;
	j["TabMinWidthForCloseButton"] = val.TabMinWidthForCloseButton;
	j["ColorButtonPosition"] = val.ColorButtonPosition;
	j["ButtonTextAlign"] = val.ButtonTextAlign;
	j["SelectableTextAlign"] = val.SelectableTextAlign;
	j["DisplayWindowPadding"] = val.DisplayWindowPadding;
	j["DisplaySafeAreaPadding"] = val.DisplaySafeAreaPadding;
	j["MouseCursorScale"] = val.MouseCursorScale;
	j["AntiAliasedLines"] = val.AntiAliasedLines;
	j["AntiAliasedLinesUseTex"] = val.AntiAliasedLinesUseTex;
	j["AntiAliasedFill"] = val.AntiAliasedFill;
	j["CurveTessellationTol"] = val.CurveTessellationTol;
	j["CircleTessellationMaxError"] = val.CircleTessellationMaxError;
	j["Colors"] = val.Colors;
}

```

`hack/config/jsonExtended.hpp`:

```hpp
#pragma once

#include <imgui.h>

#include "vars.hpp"

#include <nlohmann/json.hpp>
#include <nlohmann/detail/macro_scope.hpp>

// todo, change this all to NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE

struct ImVec2;
struct ImVec4;
struct ImGuiStyle;

using json = nlohmann::json;

template<typename T>
void from_json(const json& j, const std::string& key, T& val);

void to_json(json& j, const CfgWeapon& val);
void to_json(json& j, const CfgColor& val);
void to_json(json& j, const CfgBeam& val);
void to_json(json& j, const Key& val);
void to_json(json& j, const CfgBox& val);
void to_json(json& j, const CfgCham& val);

void to_json(json& j, const VarAim& val);
void to_json(json& j, const VarAimPaint& val);
void to_json(json& j, const VarVisuals& val);
void to_json(json& j, const VarVisuals::VarChams& val);
void to_json(json& j, const VarVisuals::VarGlow& val);
void to_json(json& j, const VarVisuals::VarEsp& val);
void to_json(json& j, const VarVisuals::VarEsp::VarBoxes& val);
void to_json(json& j, const VarVisuals::VarEsp::VarSnapline& val);
void to_json(json& j, const VarVisuals::VarEsp::VarHealthBar& val);
void to_json(json& j, const VarVisuals::VarEsp::VarArmorBar& val);
void to_json(json& j, const VarVisuals::VarEsp::VarWeaponBar& val);
void to_json(json& j, const VarVisuals::VarEsp::VarName& val);
void to_json(json& j, const VarVisuals::VarEsp::VarSkeleton& val);
void to_json(json& j, const VarVisuals::VarEsp::VarDlight& val);
void to_json(json& j, const VarVisuals::VarEsp::VarExtraInfo& val);
void to_json(json& j, const VarVisuals::VarEsp::VarFlags& val);
void to_json(json& j, const VarVisuals::VarEsp::VarLasers& val);
void to_json(json& j, const VarVisuals::VarEsp::VarChecks& val);
void to_json(json& j, const VarVisuals::VarEsp::VarDropped& val);
void to_json(json& j, const VarVisuals::VarSound& val);
void to_json(json& j, const VarVisuals::VarDormacy& val);
void to_json(json& j, const VarVisuals::VarWorld& val);
void to_json(json& j, const VarVisuals::VarWorld::VarBomb& val);
void to_json(json& j, const VarVisuals::VarWorld::VarProjectiles& val);
void to_json(json& j, const VarVisuals::VarWorld::VarSky& val);
void to_json(json& j, const VarVisuals::VarWorld::VarModulate& val);
void to_json(json& j, const VarVisuals::VarWorld::VarMolotov& val);
void to_json(json& j, const VarVisuals::VarWorld::VarSmoke& val);
void to_json(json& j, const VarVisuals::VarWorld::VarZeus& val);
void to_json(json& j, const VarVisuals::VarWorld::VarParticles& val);
void to_json(json& j, const VarVisuals::VarWorld::VarTracer& val);
void to_json(json& j, const VarVisuals::VarWorld::VarImpacts& val);
void to_json(json& j, const VarVisuals::VarWorld::VarFog& val);
void to_json(json& j, const VarVisuals::VarWorld::VarScreenEffect& val);
void to_json(json& j, const VarVisuals::VarWorld::VarTone& val);
void to_json(json& j, const VarVisuals::VarWorld::VarWeather& val);
void to_json(json& j, const VarVisuals::VarWorld::VarAmbient& val);
void to_json(json& j, const VarKeys& val);
void to_json(json& j, const VarBacktrack& val);
void to_json(json& j, const VarMisc& val);
void to_json(json& j, const VarMisc::VarLogs& val);
void to_json(json& j, const VarMisc::VarFov& val);
void to_json(json& j, const VarMisc::VarThridP& val);
void to_json(json& j, const VarMisc::VarCrosshair& val);
void to_json(json& j, const VarMisc::VarFakeLatency& val);
void to_json(json& j, const VarMisc::VarBunnyHop& val);
void to_json(json& j, const VarMisc::VarHitmarker& val);
void to_json(json& j, const VarMisc::VarScope& val);
void to_json(json& j, const VarMisc::VarPlots& val);
void to_json(json& j, const VarMisc::VarInfo& val);
void to_json(json& j, const VarMisc::VarPlayerList& val);
void to_json(json& j, const VarMisc::VarSpectactorList& val);
void to_json(json& j, const VarMisc::VarAimWarn& val);
void to_json(json& j, const VarMisc::VarRadar& val);
void to_json(json& j, const VarMisc::VarTrail& val);
void to_json(json& j, const VarMisc::VarNades& val);
void to_json(json& j, const VarMisc::VarMotionBlur& val);
void to_json(json& j, const VarMisc::VarMirrorCam& val);
void to_json(json& j, const VarMisc::VarFreeCam& val);
void to_json(json& j, const VarMisc::VarFlashlight& val);
void to_json(json& j, const VarMisc::DisableItems& val);
void to_json(json& j, const VarStyling& val);
void to_json(json& j, const ImVec2& val);
void to_json(json& j, const ImVec4& val);
void to_json(json& j, const ImGuiStyle& val);

void from_json(const json& j, CfgWeapon& val);
void from_json(const json& j, CfgColor& val);
void from_json(const json& j, CfgBeam& val);
void from_json(const json& j, Key& val);
void from_json(const json& j, CfgBox& val);
void from_json(const json& j, CfgCham& val);

void from_json(const json& j, VarAim& val);
void from_json(const json& j, VarAimPaint& val);
void from_json(const json& j, VarVisuals& val);
void from_json(const json& j, VarVisuals::VarChams& val);
void from_json(const json& j, VarVisuals::VarGlow& val);
void from_json(const json& j, VarVisuals::VarEsp& val);
void from_json(const json& j, VarVisuals::VarEsp::VarBoxes& val);
void from_json(const json& j, VarVisuals::VarEsp::VarSnapline& val);
void from_json(const json& j, VarVisuals::VarEsp::VarHealthBar& val);
void from_json(const json& j, VarVisuals::VarEsp::VarArmorBar& val);
void from_json(const json& j, VarVisuals::VarEsp::VarWeaponBar& val);
void from_json(const json& j, VarVisuals::VarEsp::VarName& val);
void from_json(const json& j, VarVisuals::VarEsp::VarSkeleton& val);
void from_json(const json& j, VarVisuals::VarEsp::VarDlight& val);
void from_json(const json& j, VarVisuals::VarEsp::VarExtraInfo& val);
void from_json(const json& j, VarVisuals::VarEsp::VarFlags& val);
void from_json(const json& j, VarVisuals::VarEsp::VarLasers& val);
void from_json(const json& j, VarVisuals::VarEsp::VarChecks& val);
void from_json(const json& j, VarVisuals::VarEsp::VarDropped& val);
void from_json(const json& j, VarVisuals::VarSound& val);
void from_json(const json& j, VarVisuals::VarDormacy& val);
void from_json(const json& j, VarVisuals::VarWorld& val);
void from_json(const json& j, VarVisuals::VarWorld::VarBomb& val);
void from_json(const json& j, VarVisuals::VarWorld::VarProjectiles& val);
void from_json(const json& j, VarVisuals::VarWorld::VarSky& val);
void from_json(const json& j, VarVisuals::VarWorld::VarModulate& val);
void from_json(const json& j, VarVisuals::VarWorld::VarMolotov& val);
void from_json(const json& j, VarVisuals::VarWorld::VarSmoke& val);
void from_json(const json& j, VarVisuals::VarWorld::VarZeus& val);
void from_json(const json& j, VarVisuals::VarWorld::VarParticles& val);
void from_json(const json& j, VarVisuals::VarWorld::VarTracer& val);
void from_json(const json& j, VarVisuals::VarWorld::VarImpacts& val);
void from_json(const json& j, VarVisuals::VarWorld::VarFog& val);
void from_json(const json& j, VarVisuals::VarWorld::VarScreenEffect& val);
void from_json(const json& j, VarVisuals::VarWorld::VarTone& val);
void from_json(const json& j, VarVisuals::VarWorld::VarWeather& val);
void from_json(const json& j, VarVisuals::VarWorld::VarAmbient& val);
void from_json(const json& j, VarKeys& val);
void from_json(const json& j, VarBacktrack& val);
void from_json(const json& j, VarMisc& val);
void from_json(const json& j, VarMisc::VarLogs& val);
void from_json(const json& j, VarMisc::VarFov& val);
void from_json(const json& j, VarMisc::VarThridP& val);
void from_json(const json& j, VarMisc::VarCrosshair& val);
void from_json(const json& j, VarMisc::VarFakeLatency& val);
void from_json(const json& j, VarMisc::VarBunnyHop& val);
void from_json(const json& j, VarMisc::VarHitmarker& val);
void from_json(const json& j, VarMisc::VarScope& val);
void from_json(const json& j, VarMisc::VarPlots& val);
void from_json(const json& j, VarMisc::VarInfo& val);
void from_json(const json& j, VarMisc::VarPlayerList& val);
void from_json(const json& j, VarMisc::VarSpectactorList& val);
void from_json(const json& j, VarMisc::VarAimWarn& val);
void from_json(const json& j, VarMisc::VarRadar& val);
void from_json(const json& j, VarMisc::VarTrail& val);
void from_json(const json& j, VarMisc::VarNades& val);
void from_json(const json& j, VarMisc::VarMotionBlur& val);
void from_json(const json& j, VarMisc::VarMirrorCam& val);
void from_json(const json& j, VarMisc::VarFreeCam& val);
void from_json(const json& j, VarMisc::VarFlashlight& val);
void from_json(const json& j, VarMisc::DisableItems& val);
void from_json(const json& j, VarStyling& val);
void from_json(const json& j, ImVec2& val);
void from_json(const json& j, ImVec4& val);
void from_json(const json& j, ImGuiStyle& val);

template<typename T>
void from_json(const json& j, const std::string& key, T& val)
{
	if (!j.contains(key))
		return;

	auto& jval = j.at(key);
	jval.get_to<T>(val);
}
```

`hack/config/key.cpp`:

```cpp
#include "key.hpp"

#include <Windows.h>
#include <array>

#include <utilities/inputSystem.hpp>

#include <imgui.h>

// should pass to hotkey by some callback or array arg
constexpr std::array badKeys =
{
	0x5B, 0x5C
};

// used only in menu so no need to care for own input handler here
bool Key::checkKey()
{
	for (const auto el : badKeys)
	{
		if (ImGui::IsKeyPressed(static_cast<ImGuiKey>(el)))
			return true;
	}
	// imgui has many key handlers, so mouse is not treated like keyboard
	// 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5)
	for (int i = 0; i < IM_ARRAYSIZE(ImGui::GetIO().MouseDown); i++)
	{
		if (ImGui::IsMouseClicked(i))
		{
			// need this switch because imgui has own bool arr
			switch (i)
			{
			case 0:
				m_keyCode = VK_LBUTTON;
				break;
			case 1:
				m_keyCode = VK_RBUTTON;
				break;
			case 2:
				m_keyCode = VK_MBUTTON;
				break;
			case 3:
				m_keyCode = VK_XBUTTON1;
				break;
			case 4:
				m_keyCode = VK_XBUTTON2;
				break;
			default:
				break;
			}

			return true;
		}

	}

	for (int i = 0; i < IM_ARRAYSIZE(ImGui::GetIO().KeysDown); i++)
	{
		if (ImGui::IsKeyPressed(static_cast<ImGuiKey>(i)))
		{

			m_keyCode = i;
			return true;
		}
	}

	return false;
}

// for mouse events
//static constexpr int keyToImKey(int id)
//{
//    switch (id)
//    {
//    case VK_LBUTTON:
//        return 0;
//    case VK_RBUTTON:
//        return 1;
//    case VK_MBUTTON:
//        return 2;
//    case VK_XBUTTON1:
//        return 3;
//    case VK_XBUTTON2:
//        return 4;
//    default:
//        return -1;
//    }
//}

void Key::update()
{
	if (m_keyMode != KeyMode::TOGGLE)
		return;

	if (isPressed())
		m_toggle = !m_toggle;
}

bool Key::isPressed() const
{
	return inputSystem::isKeyPressed(m_keyCode);
}

bool Key::isDown() const
{
	/*auto msk = keyToImKey(m_keyCode);

	if (msk >= 0 && msk <= 4)
		return ImGui::IsMouseDown(msk);*/

	return inputSystem::isKeyDown(m_keyCode);
}

bool Key::isToggled() const
{
	return m_toggle;
}

bool Key::isEnabled() const
{
	switch (m_keyMode)
	{
	case KeyMode::DOWN:
		return isDown();
	case KeyMode::TOGGLE:
		return isToggled();
	default:
		break;
	}
	return false;
}

std::array<std::pair<KeyMode, const char*>, E2T(KeyMode::KEYMODE_SIZE)> Key::getKeyPairs()
{
	static std::array p =
	{
		std::make_pair(KeyMode::DOWN, "DOWN"),
		std::make_pair(KeyMode::TOGGLE, "TOGGLE")
	};
	return p;
}

```

`hack/config/key.hpp`:

```hpp
#pragma once

#include <vector>
#include <string>
#include <utility>

#include <utilities/tools/wrappers.hpp>

enum class KeyMode : size_t
{
	DOWN,
	TOGGLE,
	KEYMODE_SIZE
};

// cleanup this
class Key
{
public:
	Key() = default;
	constexpr Key(KeyMode mode, int code)
		: m_keyMode{ mode }, m_keyCode{ code }
	{}
	// use only for simple keys for features etc...
	// if class contains an "active" field then this will be a problem
	void update();
	bool isEnabled() const;
	// to hotkey
	bool checkKey();
	bool isPressed() const;
	bool isDown() const;
	bool isToggled() const;
	int getKeyCode() const { return m_keyCode; }
	int& getKeyCode() { return m_keyCode; }
	KeyMode getKeyMode() const { return m_keyMode; }
	KeyMode& getKeyMode() { return m_keyMode; }
	int& getKeyModeInt() { return (int&)(m_keyMode); }
	void setKeyMode(KeyMode mode) { m_keyMode = mode; }
	static std::array<std::pair<KeyMode, const char*>, E2T(KeyMode::KEYMODE_SIZE)> getKeyPairs();
private:
	bool m_toggle = false;
	int m_keyCode;
	KeyMode m_keyMode;
};
```

`hack/config/vars.hpp`:

```hpp
#pragma once

#include "enums.hpp"
#include "cfgWeapon.hpp"
#include "cfgcolor.hpp"
#include "key.hpp"
#include "cfgBeam.hpp"
#include "cfgBox.hpp"
#include "cfgCham.hpp"

#include <utilities/tools/wrappers.hpp>
#include <utilities/utilities.hpp>
#include <magic_enum.hpp>

#include <memory>
#include <cstdint>
#include <array>

#define USE_NAMESPACE_VARS(cl, name) \
namespace vars { \
	inline std::unique_ptr<cl> name{ std::make_unique<cl>() }; \
}

#define ADD_MEMBER_PTR(_structName, memberName) std::unique_ptr<_structName> memberName{ std::make_unique<_structName>() };

struct VarAim
{
	std::array<CfgWeapon, magic_enum::enum_count<WeaponList>()> weapons;
};
USE_NAMESPACE_VARS(VarAim, aim);

struct VarAimPaint
{
	bool enabledFov{ false };
	bool enabledPoint{ false };
	CfgColor colorFov{ Colors::LightBlue };
	CfgColor colorPoint{ Colors::LightBlue };
};
USE_NAMESPACE_VARS(VarAimPaint, aimPaint);

struct VarVisuals
{
	struct VarChams
	{
		CfgCham players{ };
		CfgCham attachement{ };
		CfgCham weapon{ };
		CfgCham arms{ };
		bool backtrackEnabled{ false };
		int backtrackIndex{ };
		int backtrackMode{ };
		CfgColor backtrackColor{ };
		bool streamProof{ false };
		bool ignoreSmoke{ false };
	};
	ADD_MEMBER_PTR(VarChams, chams);

	struct VarGlow
	{
		bool enabled{ false };
		bool streamProof{ false };
		bool fullBloom{ false };
		CfgColor colorPlayer{ Colors::Purple };
		std::array<float, magic_enum::enum_count<GlowRenderPulse>()> pulseSpeeeds{ utilities::getFilledArray<float, magic_enum::enum_count<GlowRenderPulse>()>(12.0f) };
		bool visible{ true };
		float exponent{ 1.0f };
		float saturation{ 1.0f };
		float C0_X{ 1.0f };
		float thickness{ 1.0f };
		std::array<bool, magic_enum::enum_count<GlowRenderStyle>()> usedMats{ utilities::getFilledArray<bool, magic_enum::enum_count<GlowRenderStyle>()>(false) };
		std::array<bool, magic_enum::enum_count<GlowIgnorez>()> ignorez{ utilities::getFilledArray<bool, magic_enum::enum_count<GlowIgnorez>()>(false) };
	};
	ADD_MEMBER_PTR(VarGlow, glow);

	struct VarEsp
	{
		struct VarBoxes
		{
			CfgBox box{ };
		};
		ADD_MEMBER_PTR(VarBoxes, boxes);

		struct VarSnapline
		{
			bool enabled{ false };
			CfgColor color{ };
		};
		ADD_MEMBER_PTR(VarSnapline, snapline);

		struct VarHealthBar
		{
			bool enabled{ false };
		};
		ADD_MEMBER_PTR(VarHealthBar, healthBar);

		struct VarArmorBar
		{
			bool enabled{ false };
		};
		ADD_MEMBER_PTR(VarArmorBar, armorBar);

		struct VarWeaponBar
		{
			bool enabled{ false };
			bool translate{ false };
			CfgBox box{ };
			CfgColor text{ Colors::White };
			CfgColor bar{ Colors::Turquoise };
		};
		ADD_MEMBER_PTR(VarWeaponBar, weaponBar);

		struct VarName
		{
			bool enabled{ false };
		};
		ADD_MEMBER_PTR(VarName, nameBar);

		struct VarSkeleton
		{
			bool enabled{ false };
			CfgColor color{ Colors::White };
			bool showDebug{ false };
		};
		ADD_MEMBER_PTR(VarSkeleton, skeleton);

		struct VarDlight
		{
			bool enabled{ false };
			CfgColor color{ Color{ 20, 70, 150, 255 } };
			float radius{ 50.0f };
			float decay{ 30.0f };
			float exponent{ 8.0f };
		};
		ADD_MEMBER_PTR(VarDlight, dlight);

		struct VarExtraInfo
		{
			bool enabled{ false };
		};
		ADD_MEMBER_PTR(VarExtraInfo, extraInfo);

		struct VarFlags
		{
			std::array<bool, magic_enum::enum_count<EspFlags>()> flags{ false };
			bool enabled{ false };
		};
		ADD_MEMBER_PTR(VarFlags, flags);

		struct VarLasers
		{
			bool enabled{ false };
			CfgColor color{ };
		};
		ADD_MEMBER_PTR(VarLasers, lasers);

		struct VarChecks
		{
			bool dead{ false };
			bool smoke{ false };
			bool visible{ false };
			float flashLimit{ 120.0f };
		};
		ADD_MEMBER_PTR(VarChecks, checks);

		struct VarDropped
		{
			bool enabled{ false };
			CfgBox box{ };
			CfgColor ammoColor{ Colors::White };
			CfgColor textColor{ Colors::White };
			CfgColor iconColor{ Colors::White };
			std::array<bool, magic_enum::enum_count<DroppedFlags>()> flags{ false };
		};
		ADD_MEMBER_PTR(VarDropped, dropped);
	};
	ADD_MEMBER_PTR(VarEsp, esp);

	struct VarSound
	{
		bool enabled{ false };
		CfgColor color{ Colors::LightBlue };
		float time{ 10.0f };
		float maxDist{ 50.0f };
		float maxDistLine{ 80.0f };
		CfgColor colorLine{ Colors::White };
	};
	ADD_MEMBER_PTR(VarSound, sound);

	struct VarDormacy
	{
		float time{ 1.0f };
		float limit{ 15.0f };
	};
	ADD_MEMBER_PTR(VarDormacy, dormacy);

	struct VarWorld
	{
		struct VarBomb
		{
			bool enabled{ false };
			CfgColor background{ Colors::Black };
		};
		ADD_MEMBER_PTR(VarBomb, bomb);

		struct VarProjectiles
		{
			bool enabled{ false };
			CfgColor flash{ Color{ 130, 0, 200, 255 } };
			CfgColor nade{ Color{ 130, 180, 20, 255 } };
			CfgColor molotov{ Color{ 130, 200, 120, 255 } };
			CfgColor smoke{ Color{ 20, 70, 30, 255 } };
			CfgColor decoy{ Color{ 0, 30, 60, 255 } };
		};
		ADD_MEMBER_PTR(VarProjectiles, projectiles);

		struct VarSky
		{
			int indexNormal{ 0 };
			int indexCustom{ 0 };
			bool removeSky{ false };
		};
		ADD_MEMBER_PTR(VarSky, sky);

		struct VarModulate
		{
			bool enabledTexture{ false };
			CfgColor texture{ Colors::White };
			bool enabledProp{ false };
			CfgColor prop{ Colors::White };
			bool enabledSky{ false };
			CfgColor sky{ Colors::White };
			std::array<bool, 6> enabledLights;
			std::array<CfgColor, 6> lights;
			std::array<float, 6> lightsStrenght;
			bool enabledShader{ false };
			float shader{ 100.0f };
		};
		ADD_MEMBER_PTR(VarModulate, modulate);

		struct VarMolotov
		{
			bool enabled{ false };
			bool triangulation{ false };
			CfgColor color{ Colors::Red.getColorEditAlpha(0.3f) };
			CfgColor colorText{ Colors::White };
		};
		ADD_MEMBER_PTR(VarMolotov, molotov);

		struct VarSmoke
		{
			bool enabled{ false };
			CfgColor color{ Colors::White };
		};
		ADD_MEMBER_PTR(VarSmoke, smoke);

		struct VarZeus
		{
			bool enabled{ false };
			bool party{ false };
			bool tracing{ false };
			CfgColor color{ Colors::Palevioletred, true, 4.0f };
		};
		ADD_MEMBER_PTR(VarZeus, zeus);

		struct VarParticles
		{
			bool enabledBlood{ false };
			CfgColor colorBlood{ Colors::Purple };
			bool enabledMolotov{ false };
			CfgColor colorMolotov{ Colors::Purple };
			bool enabledSmoke{ false };
			CfgColor colorSmoke{ Colors::Purple };
		};
		ADD_MEMBER_PTR(VarParticles, particles);

		struct VarTracer
		{
			bool enabled{ false };
			CfgBeam beamTracer
			{
				0U,
				"4|8",
				2.0f,
				Colors::LightBlue,
				2.0f,
				1.0f,
				2.0f,
				1.0f,
				0.0f,
				60.0f,
				2
			};
		};
		ADD_MEMBER_PTR(VarTracer, tracer);

		struct VarImpacts
		{
			bool enabledClient{ false };
			float timeClient{ 3.0f };
			CfgColor colorClient{ Colors::Cyan };
			CfgColor colorClientFill{ Colors::Red };
			bool enabledLocal{ false };
			float timeLocal{ 3.0f };
			CfgColor colorLocal{ Colors::Cyan };
			CfgColor colorLocalFill{ Colors::Red };
		};
		ADD_MEMBER_PTR(VarImpacts, impacts);

		struct VarFog
		{
			bool enabled{ false };
			float distance{ 500.0f };
			CfgColor color{ Colors::Purple };
		};
		ADD_MEMBER_PTR(VarFog, fog);

		struct VarScreenEffect
		{
			int index{ 0 };
			float param{ 1.0f };
			CfgColor color{ Colors::LightBlue };
		};
		ADD_MEMBER_PTR(VarScreenEffect, screenEffect);

		struct VarTone
		{
			bool enabled{ false };
			float min{ 0.5f };
			float max{ 0.5f };
			float bloom{ 0.0f };
		};
		ADD_MEMBER_PTR(VarTone, tone);

		struct VarWeather
		{
			float length{ 0.0f };
			float rainSpeed{ 0.0f };
			float radius{ 0.0f };
			float width{ 0.0f };
			float velocity{ 0.0f };
			float alpha{ 0.0f };
			float windSpeed{ 0.0f };
			float particleDensity{ 0.0f };
			int type{ 0 };
			float volume{ 0.65f };
			bool snowParticleEdit{ false };
			CfgColor snowParticleInnerNearColor{ };
			CfgColor snowParticleInnerFarColor{ };
			CfgColor snowParticleOuterColor{ };
			bool rainParticleEdit{ false };
			CfgColor rainParticleInnerNearColor{ };
			CfgColor rainParticleInnerFarColor{ };
			CfgColor rainParticleOuterColor{ };
			bool rainStormParticleEdit{ false };
			CfgColor rainStormParticleInnerNearColor{ };
			CfgColor rainStormParticleInnerFarColor{ };
			CfgColor rainStormParticleOuterColor{ };
			float customNear{ 32.0f };
			float customFar{ 100.0f };
			bool useGround{ false };
			bool storm{ false };
			bool saveFpsStorm{ false };
		};
		ADD_MEMBER_PTR(VarWeather, weather);

		struct VarAmbient
		{
			bool enabled{ false };
			CfgColor color{ Colors::LightBlue };
		};
		ADD_MEMBER_PTR(VarAmbient, ambient);
	};
	ADD_MEMBER_PTR(VarWorld, world);
};
USE_NAMESPACE_VARS(VarVisuals, visuals);

struct VarKeys
{
	bool enabledX88Menu{ true };
	Key x88Toggle{ KeyMode::TOGGLE, VK_F10 };
	Key menu{ KeyMode::TOGGLE, VK_INSERT };
	Key panic{ KeyMode::DOWN, VK_DELETE };
	Key console{ KeyMode::TOGGLE, VK_HOME };
	Key mirrorCam{ KeyMode::TOGGLE, VK_F1 };
	Key freeCam{ KeyMode::TOGGLE, VK_F2 };
	Key flashLight{ KeyMode::TOGGLE, 0x4C }; // L key
	Key thirdP{ KeyMode::TOGGLE, 0x56 }; // V key
};
USE_NAMESPACE_VARS(VarKeys, keys);

struct VarBacktrack
{
	bool enabled{ false };
	float time{ 200.0f };
	bool smoke{ true };
	float flashLimit{ 120.0f };
};
USE_NAMESPACE_VARS(VarBacktrack, backtrack);

struct VarMisc
{
	struct VarLogs
	{
		float time{ 4.0f };
		bool enabled{ false };
	};
	ADD_MEMBER_PTR(VarLogs, logs);

	struct VarFov
	{
		float value{ 0.0f };
	};
	ADD_MEMBER_PTR(VarFov, fov);

	struct VarThridP
	{
		bool enabled{ false };
		float distance{ 200.0f };
		float x{ 0.0f };
		float y{ 0.0f };
	};
	ADD_MEMBER_PTR(VarThridP, thirdp);

	struct VarCrosshair
	{
		int index{ 0 };
	};
	ADD_MEMBER_PTR(VarCrosshair, crosshair);

	struct VarFakeLatency
	{
		bool enabled{ false };
		float amount{ 200.0f };
	};
	ADD_MEMBER_PTR(VarFakeLatency, fakeLatency);

	struct VarBunnyHop
	{
		bool enabled{ false };
		int chance{ 0 };
		int indexStrafe{ 0 };
	};
	ADD_MEMBER_PTR(VarBunnyHop, bunnyHop);

	struct VarHitmarker
	{
		bool enabled{ false };
		bool play{ false };
		bool enabled3D{ false };
		bool enabledResize{ false };
		CfgColor colorNormal{ Colors::White };
		CfgColor colorHead{ Colors::Pink };
		CfgColor colorDead{ Colors::Green };
		float time{ 0.8f };
	};
	ADD_MEMBER_PTR(VarHitmarker, hitmarker);

	struct VarScope
	{
		bool enabled{ false };
	};
	ADD_MEMBER_PTR(VarScope, scope);

	struct VarPlots
	{
		bool enabledFps{ false };
		bool enabledVelocity{ false };
		bool transparencyVelocity{ false };
		CfgColor colorVelocity{ Colors::White };
		CfgColor colorFPS{ Colors::White };
		int sizeFps{ 300 };
		int sizeVelocity{ 300 };
	};
	ADD_MEMBER_PTR(VarPlots, plots);

	struct VarInfo
	{
		bool enabled{ false };
	};
	ADD_MEMBER_PTR(VarInfo, info);

	struct VarPlayerList
	{
		bool enabled{ false };
		bool health{ false };
		bool teamID{ false };
		bool money{ false };
		bool lastPlace{ false };
	};
	ADD_MEMBER_PTR(VarPlayerList, playerList);

	struct VarSpectactorList
	{
		bool enabled{ false };
	};
	ADD_MEMBER_PTR(VarSpectactorList, spectactorList);

	struct VarAimWarn
	{
		bool enabled{ false };
	};
	ADD_MEMBER_PTR(VarAimWarn, aimWarn);

	struct VarRadar
	{
		bool enabled{ false };
		CfgColor colorLine{ Colors::White };
		CfgColor colorPlayer{ Colors::Purple };
		float thickness{ 5.0f };
		float length{ 20.0f };
		float scale{ 1.8f };
		bool ranges{ true };
		int mode{ 0 };
	};
	ADD_MEMBER_PTR(VarRadar, radar);

	struct VarTrail
	{
		int mode{ 0 };
		bool enabled{ false };
		CfgBeam beam;
		CfgColor colorLine;
		float lineLife;
		CfgColor colorSplash;
	};
	ADD_MEMBER_PTR(VarTrail, trail);

	struct VarNades
	{
		bool enabledPred{ false };
		bool predAlways{ false };
		CfgColor colorPredLine{ Colors::LightBlue };
		CfgColor colorPredBoxFill{ Colors::Green };
		CfgColor colorPredBox{ Colors::Green };
		bool enabledTracer{ false };
		CfgColor colorTracer{ Colors::LightBlue };
		float tracerDist{ 30.0f };
		bool tracerWarn{ false };
	};
	ADD_MEMBER_PTR(VarNades, nade);

	struct VarHat
	{
		bool enabled{ false };
		bool rainbow{ false };
		float rainbowSpeed{ 3.0f };
		float size{ -30.0f };
		float radius{ 20.0f };
		int rainbowAlpha{ 70 };
		int rainbowLinesAlpha{ 180 };
		CfgColor colorTriangle{ Colors::Palevioletred };
		CfgColor colorLine{ Colors::Palevioletred };
	};
	ADD_MEMBER_PTR(VarHat, hat);

	struct VarMotionBlur
	{
		bool enabled{ false };
		bool forward{ false };
		float fallingIntensity{ 1.0f };
		float fallingMin{ 10.0f };
		float fallingMax{ 20.0f };
		float strength{ 1.0f };
		float rotationIntensity{ 0.15f };
		float rollIntensity{ 0.3f };
	};
	ADD_MEMBER_PTR(VarMotionBlur, motionBlur);

	struct VarMirrorCam
	{
		bool enabled{ false };
		bool onKey{ false };
	};
	ADD_MEMBER_PTR(VarMirrorCam, mirrorCam);

	struct VarFreeCam
	{
		bool enabled{ false };
		float speed{ 1.0f };
	};
	ADD_MEMBER_PTR(VarFreeCam, freeCam);

	struct VarFlashlight
	{
		bool enabled{ false };
		bool bigMode{ false };
		float fov{ 30.0f };
	};
	ADD_MEMBER_PTR(VarFlashlight, flashLight);

	struct DisableItems
	{
		bool interpolate{ false };
		float flashPercentage{ 1.0f };
	};
	ADD_MEMBER_PTR(DisableItems, disableItems);
};
USE_NAMESPACE_VARS(VarMisc, misc);

#include <menu/GUI-ImGui/styles/styles.hpp>

struct VarStyling
{
	int index{ 0 };
	bool background{ false };
	float speed{ 2.0f };
	float distance{ 200.0f };
	int size{ 150 };
	CfgColor color1{ Color{ 220, 10, 100, 255 } };
	CfgColor color2{ Color{ 65, 75, 105, 255 } };
	CfgColor color3{ Color{ 220, 240, 240, 255 } };
	ImGuiStyle imStyle{ styles::getCherryStyle().style };
	std::array<CfgColor, 4> groupPanelBackground{ styles::getCherryStyle().extraColors };
	CfgColor groupPanelLines{ Colors::White };
};
USE_NAMESPACE_VARS(VarStyling, styling);

#undef USE_NAMESPACE_VARS
#undef ADD_MEMBER_PTR
```

`hack/deps/ImGui/editor/LanguageDefinitions.cpp`:

```cpp
#include "TextEditor.hpp"

static bool TokenizeCStyleString(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	const char* p = in_begin;

	if (*p == '"')
	{
		p++;

		while (p < in_end)
		{
			// handle end of string
			if (*p == '"')
			{
				out_begin = in_begin;
				out_end = p + 1;
				return true;
			}

			// handle escape character for "
			if (*p == '\\' && p + 1 < in_end && p[1] == '"')
				p++;

			p++;
		}
	}

	return false;
}

static bool TokenizeCStyleCharacterLiteral(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	const char* p = in_begin;

	if (*p == '\'')
	{
		p++;

		// handle escape characters
		if (p < in_end && *p == '\\')
			p++;

		if (p < in_end)
			p++;

		// handle end of character literal
		if (p < in_end && *p == '\'')
		{
			out_begin = in_begin;
			out_end = p + 1;
			return true;
		}
	}

	return false;
}

static bool TokenizeCStyleIdentifier(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	const char* p = in_begin;

	if ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || *p == '_')
	{
		p++;

		while ((p < in_end) && ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*p >= '0' && *p <= '9') || *p == '_'))
			p++;

		out_begin = in_begin;
		out_end = p;
		return true;
	}

	return false;
}

static bool TokenizeCStyleNumber(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	const char* p = in_begin;

	const bool startsWithNumber = *p >= '0' && *p <= '9';

	if (*p != '+' && *p != '-' && !startsWithNumber)
		return false;

	p++;

	bool hasNumber = startsWithNumber;

	while (p < in_end && (*p >= '0' && *p <= '9'))
	{
		hasNumber = true;

		p++;
	}

	if (hasNumber == false)
		return false;

	bool isFloat = false;
	bool isHex = false;
	bool isBinary = false;

	if (p < in_end)
	{
		if (*p == '.')
		{
			isFloat = true;

			p++;

			while (p < in_end && (*p >= '0' && *p <= '9'))
				p++;
		}
		else if (*p == 'x' || *p == 'X')
		{
			// hex formatted integer of the type 0xef80

			isHex = true;

			p++;

			while (p < in_end && ((*p >= '0' && *p <= '9') || (*p >= 'a' && *p <= 'f') || (*p >= 'A' && *p <= 'F')))
				p++;
		}
		else if (*p == 'b' || *p == 'B')
		{
			// binary formatted integer of the type 0b01011101

			isBinary = true;

			p++;

			while (p < in_end && (*p >= '0' && *p <= '1'))
				p++;
		}
	}

	if (isHex == false && isBinary == false)
	{
		// floating point exponent
		if (p < in_end && (*p == 'e' || *p == 'E'))
		{
			isFloat = true;

			p++;

			if (p < in_end && (*p == '+' || *p == '-'))
				p++;

			bool hasDigits = false;

			while (p < in_end && (*p >= '0' && *p <= '9'))
			{
				hasDigits = true;

				p++;
			}

			if (hasDigits == false)
				return false;
		}

		// single precision floating point type
		if (p < in_end && *p == 'f')
			p++;
	}

	if (isFloat == false)
	{
		// integer size type
		while (p < in_end && (*p == 'u' || *p == 'U' || *p == 'l' || *p == 'L'))
			p++;
	}

	out_begin = in_begin;
	out_end = p;
	return true;
}

static bool TokenizeCStylePunctuation(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	(void)in_end;

	switch (*in_begin)
	{
	case '[':
	case ']':
	case '{':
	case '}':
	case '!':
	case '%':
	case '^':
	case '&':
	case '*':
	case '(':
	case ')':
	case '-':
	case '+':
	case '=':
	case '~':
	case '|':
	case '<':
	case '>':
	case '?':
	case ':':
	case '/':
	case ';':
	case ',':
	case '.':
		out_begin = in_begin;
		out_end = in_begin + 1;
		return true;
	}

	return false;
}

static bool TokenizeLuaStyleString(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	const char* p = in_begin;

	bool is_single_quote = false;
	bool is_double_quotes = false;
	bool is_double_square_brackets = false;

	switch (*p)
	{
	case '\'':
		is_single_quote = true;
		break;
	case '"':
		is_double_quotes = true;
		break;
	case '[':
		p++;
		if (p < in_end && *(p) == '[')
			is_double_square_brackets = true;
		break;
	}

	if (is_single_quote || is_double_quotes || is_double_square_brackets)
	{
		p++;

		while (p < in_end)
		{
			// handle end of string
			if ((is_single_quote && *p == '\'') || (is_double_quotes && *p == '"') || (is_double_square_brackets && *p == ']' && p + 1 < in_end && *(p + 1) == ']'))
			{
				out_begin = in_begin;

				if (is_double_square_brackets)
					out_end = p + 2;
				else
					out_end = p + 1;

				return true;
			}

			// handle escape character for "
			if (*p == '\\' && p + 1 < in_end && (is_single_quote || is_double_quotes))
				p++;

			p++;
		}
	}

	return false;
}

static bool TokenizeLuaStyleIdentifier(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	const char* p = in_begin;

	if ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || *p == '_')
	{
		p++;

		while ((p < in_end) && ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*p >= '0' && *p <= '9') || *p == '_'))
			p++;

		out_begin = in_begin;
		out_end = p;
		return true;
	}

	return false;
}

static bool TokenizeLuaStyleNumber(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	const char* p = in_begin;

	const bool startsWithNumber = *p >= '0' && *p <= '9';

	if (*p != '+' && *p != '-' && !startsWithNumber)
		return false;

	p++;

	bool hasNumber = startsWithNumber;

	while (p < in_end && (*p >= '0' && *p <= '9'))
	{
		hasNumber = true;

		p++;
	}

	if (hasNumber == false)
		return false;

	if (p < in_end)
	{
		if (*p == '.')
		{
			p++;

			while (p < in_end && (*p >= '0' && *p <= '9'))
				p++;
		}

		// floating point exponent
		if (p < in_end && (*p == 'e' || *p == 'E'))
		{
			p++;

			if (p < in_end && (*p == '+' || *p == '-'))
				p++;

			bool hasDigits = false;

			while (p < in_end && (*p >= '0' && *p <= '9'))
			{
				hasDigits = true;

				p++;
			}

			if (hasDigits == false)
				return false;
		}
	}

	out_begin = in_begin;
	out_end = p;
	return true;
}

static bool TokenizeLuaStylePunctuation(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	(void)in_end;

	switch (*in_begin)
	{
	case '[':
	case ']':
	case '{':
	case '}':
	case '!':
	case '%':
	case '#':
	case '^':
	case '&':
	case '*':
	case '(':
	case ')':
	case '-':
	case '+':
	case '=':
	case '~':
	case '|':
	case '<':
	case '>':
	case '?':
	case ':':
	case '/':
	case ';':
	case ',':
	case '.':
		out_begin = in_begin;
		out_end = in_begin + 1;
		return true;
	}

	return false;
}

const TextEditor::LanguageDefinition& TextEditor::LanguageDefinition::CPlusPlus()
{
	static bool inited = false;
	static LanguageDefinition langDef;
	if (!inited)
	{
		static const char* const cppKeywords[] = {
			"alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit", "atomic_noexcept", "auto", "bitand", "bitor", "bool", "break", "case", "catch", "char", "char16_t", "char32_t", "class",
			"compl", "concept", "const", "constexpr", "const_cast", "continue", "decltype", "default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern", "false", "float",
			"for", "friend", "goto", "if", "import", "inline", "int", "long", "module", "mutable", "namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "private", "protected", "public",
			"register", "reinterpret_cast", "requires", "return", "short", "signed", "sizeof", "static", "static_assert", "static_cast", "struct", "switch", "synchronized", "template", "this", "thread_local",
			"throw", "true", "try", "typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void", "volatile", "wchar_t", "while", "xor", "xor_eq"
		};
		for (auto& k : cppKeywords)
			langDef.mKeywords.insert(k);

		static const char* const identifiers[] = {
			"abort", "abs", "acos", "asin", "atan", "atexit", "atof", "atoi", "atol", "ceil", "clock", "cosh", "ctime", "div", "exit", "fabs", "floor", "fmod", "getchar", "getenv", "isalnum", "isalpha", "isdigit", "isgraph",
			"ispunct", "isspace", "isupper", "kbhit", "log10", "log2", "log", "memcmp", "modf", "pow", "printf", "sprintf", "snprintf", "putchar", "putenv", "puts", "rand", "remove", "rename", "sinh", "sqrt", "srand", "strcat", "strcmp", "strerror", "time", "tolower", "toupper",
			"std", "string", "vector", "map", "unordered_map", "set", "unordered_set", "min", "max"
		};
		for (auto& k : identifiers)
		{
			Identifier id;
			id.mDeclaration = "Built-in function";
			langDef.mIdentifiers.insert(std::make_pair(std::string(k), id));
		}

		langDef.mTokenize = [](const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end, PaletteIndex& paletteIndex) -> bool
		{
			paletteIndex = PaletteIndex::Max;

			while (in_begin < in_end && isascii(*in_begin) && isblank(*in_begin))
				in_begin++;

			if (in_begin == in_end)
			{
				out_begin = in_end;
				out_end = in_end;
				paletteIndex = PaletteIndex::Default;
			}
			else if (TokenizeCStyleString(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::String;
			else if (TokenizeCStyleCharacterLiteral(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::CharLiteral;
			else if (TokenizeCStyleIdentifier(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Identifier;
			else if (TokenizeCStyleNumber(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Number;
			else if (TokenizeCStylePunctuation(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Punctuation;

			return paletteIndex != PaletteIndex::Max;
		};

		langDef.mCommentStart = "/*";
		langDef.mCommentEnd = "*/";
		langDef.mSingleLineComment = "//";

		langDef.mCaseSensitive = true;
		langDef.mAutoIndentation = true;

		langDef.mName = "C++";

		inited = true;
	}
	return langDef;
}

const TextEditor::LanguageDefinition& TextEditor::LanguageDefinition::HLSL()
{
	static bool inited = false;
	static LanguageDefinition langDef;
	if (!inited)
	{
		static const char* const keywords[] = {
			"AppendStructuredBuffer", "asm", "asm_fragment", "BlendState", "bool", "break", "Buffer", "ByteAddressBuffer", "case", "cbuffer", "centroid", "class", "column_major", "compile", "compile_fragment",
			"CompileShader", "const", "continue", "ComputeShader", "ConsumeStructuredBuffer", "default", "DepthStencilState", "DepthStencilView", "discard", "do", "double", "DomainShader", "dword", "else",
			"export", "extern", "false", "float", "for", "fxgroup", "GeometryShader", "groupshared", "half", "Hullshader", "if", "in", "inline", "inout", "InputPatch", "int", "interface", "line", "lineadj",
			"linear", "LineStream", "matrix", "min16float", "min10float", "min16int", "min12int", "min16uint", "namespace", "nointerpolation", "noperspective", "NULL", "out", "OutputPatch", "packoffset",
			"pass", "pixelfragment", "PixelShader", "point", "PointStream", "precise", "RasterizerState", "RenderTargetView", "return", "register", "row_major", "RWBuffer", "RWByteAddressBuffer", "RWStructuredBuffer",
			"RWTexture1D", "RWTexture1DArray", "RWTexture2D", "RWTexture2DArray", "RWTexture3D", "sample", "sampler", "SamplerState", "SamplerComparisonState", "shared", "snorm", "stateblock", "stateblock_state",
			"static", "string", "struct", "switch", "StructuredBuffer", "tbuffer", "technique", "technique10", "technique11", "texture", "Texture1D", "Texture1DArray", "Texture2D", "Texture2DArray", "Texture2DMS",
			"Texture2DMSArray", "Texture3D", "TextureCube", "TextureCubeArray", "true", "typedef", "triangle", "triangleadj", "TriangleStream", "uint", "uniform", "unorm", "unsigned", "vector", "vertexfragment",
			"VertexShader", "void", "volatile", "while",
			"bool1","bool2","bool3","bool4","double1","double2","double3","double4", "float1", "float2", "float3", "float4", "int1", "int2", "int3", "int4", "in", "out", "inout",
			"uint1", "uint2", "uint3", "uint4", "dword1", "dword2", "dword3", "dword4", "half1", "half2", "half3", "half4",
			"float1x1","float2x1","float3x1","float4x1","float1x2","float2x2","float3x2","float4x2",
			"float1x3","float2x3","float3x3","float4x3","float1x4","float2x4","float3x4","float4x4",
			"half1x1","half2x1","half3x1","half4x1","half1x2","half2x2","half3x2","half4x2",
			"half1x3","half2x3","half3x3","half4x3","half1x4","half2x4","half3x4","half4x4",
		};
		for (auto& k : keywords)
			langDef.mKeywords.insert(k);

		static const char* const identifiers[] = {
			"abort", "abs", "acos", "all", "AllMemoryBarrier", "AllMemoryBarrierWithGroupSync", "any", "asdouble", "asfloat", "asin", "asint", "asint", "asuint",
			"asuint", "atan", "atan2", "ceil", "CheckAccessFullyMapped", "clamp", "clip", "cos", "cosh", "countbits", "cross", "D3DCOLORtoUBYTE4", "ddx",
			"ddx_coarse", "ddx_fine", "ddy", "ddy_coarse", "ddy_fine", "degrees", "determinant", "DeviceMemoryBarrier", "DeviceMemoryBarrierWithGroupSync",
			"distance", "dot", "dst", "errorf", "EvaluateAttributeAtCentroid", "EvaluateAttributeAtSample", "EvaluateAttributeSnapped", "exp", "exp2",
			"f16tof32", "f32tof16", "faceforward", "firstbithigh", "firstbitlow", "floor", "fma", "fmod", "frac", "frexp", "fwidth", "GetRenderTargetSampleCount",
			"GetRenderTargetSamplePosition", "GroupMemoryBarrier", "GroupMemoryBarrierWithGroupSync", "InterlockedAdd", "InterlockedAnd", "InterlockedCompareExchange",
			"InterlockedCompareStore", "InterlockedExchange", "InterlockedMax", "InterlockedMin", "InterlockedOr", "InterlockedXor", "isfinite", "isinf", "isnan",
			"ldexp", "length", "lerp", "lit", "log", "log10", "log2", "mad", "max", "min", "modf", "msad4", "mul", "noise", "normalize", "pow", "printf",
			"Process2DQuadTessFactorsAvg", "Process2DQuadTessFactorsMax", "Process2DQuadTessFactorsMin", "ProcessIsolineTessFactors", "ProcessQuadTessFactorsAvg",
			"ProcessQuadTessFactorsMax", "ProcessQuadTessFactorsMin", "ProcessTriTessFactorsAvg", "ProcessTriTessFactorsMax", "ProcessTriTessFactorsMin",
			"radians", "rcp", "reflect", "refract", "reversebits", "round", "rsqrt", "saturate", "sign", "sin", "sincos", "sinh", "smoothstep", "sqrt", "step",
			"tan", "tanh", "tex1D", "tex1D", "tex1Dbias", "tex1Dgrad", "tex1Dlod", "tex1Dproj", "tex2D", "tex2D", "tex2Dbias", "tex2Dgrad", "tex2Dlod", "tex2Dproj",
			"tex3D", "tex3D", "tex3Dbias", "tex3Dgrad", "tex3Dlod", "tex3Dproj", "texCUBE", "texCUBE", "texCUBEbias", "texCUBEgrad", "texCUBElod", "texCUBEproj", "transpose", "trunc"
		};
		for (auto& k : identifiers)
		{
			Identifier id;
			id.mDeclaration = "Built-in function";
			langDef.mIdentifiers.insert(std::make_pair(std::string(k), id));
		}

		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[ \\t]*#[ \\t]*[a-zA-Z_]+", PaletteIndex::Preprocessor));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("L?\\\"(\\\\.|[^\\\"])*\\\"", PaletteIndex::String));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("\\'\\\\?[^\\']\\'", PaletteIndex::CharLiteral));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)([eE][+-]?[0-9]+)?[fF]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?[0-9]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[0-7]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[xX][0-9a-fA-F]+[uU]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[a-zA-Z_][a-zA-Z0-9_]*", PaletteIndex::Identifier));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[\\[\\]\\{\\}\\!\\%\\^\\&\\*\\(\\)\\-\\+\\=\\~\\|\\<\\>\\?\\/\\;\\,\\.]", PaletteIndex::Punctuation));

		langDef.mCommentStart = "/*";
		langDef.mCommentEnd = "*/";
		langDef.mSingleLineComment = "//";

		langDef.mCaseSensitive = true;
		langDef.mAutoIndentation = true;

		langDef.mName = "HLSL";

		inited = true;
	}
	return langDef;
}

const TextEditor::LanguageDefinition& TextEditor::LanguageDefinition::GLSL()
{
	static bool inited = false;
	static LanguageDefinition langDef;
	if (!inited)
	{
		static const char* const keywords[] = {
			"auto", "break", "case", "char", "const", "continue", "default", "do", "double", "else", "enum", "extern", "float", "for", "goto", "if", "inline", "int", "long", "register", "restrict", "return", "short",
			"signed", "sizeof", "static", "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while", "_Alignas", "_Alignof", "_Atomic", "_Bool", "_Complex", "_Generic", "_Imaginary",
			"_Noreturn", "_Static_assert", "_Thread_local"
		};
		for (auto& k : keywords)
			langDef.mKeywords.insert(k);

		static const char* const identifiers[] = {
			"abort", "abs", "acos", "asin", "atan", "atexit", "atof", "atoi", "atol", "ceil", "clock", "cosh", "ctime", "div", "exit", "fabs", "floor", "fmod", "getchar", "getenv", "isalnum", "isalpha", "isdigit", "isgraph",
			"ispunct", "isspace", "isupper", "kbhit", "log10", "log2", "log", "memcmp", "modf", "pow", "putchar", "putenv", "puts", "rand", "remove", "rename", "sinh", "sqrt", "srand", "strcat", "strcmp", "strerror", "time", "tolower", "toupper"
		};
		for (auto& k : identifiers)
		{
			Identifier id;
			id.mDeclaration = "Built-in function";
			langDef.mIdentifiers.insert(std::make_pair(std::string(k), id));
		}

		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[ \\t]*#[ \\t]*[a-zA-Z_]+", PaletteIndex::Preprocessor));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("L?\\\"(\\\\.|[^\\\"])*\\\"", PaletteIndex::String));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("\\'\\\\?[^\\']\\'", PaletteIndex::CharLiteral));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)([eE][+-]?[0-9]+)?[fF]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?[0-9]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[0-7]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[xX][0-9a-fA-F]+[uU]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[a-zA-Z_][a-zA-Z0-9_]*", PaletteIndex::Identifier));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[\\[\\]\\{\\}\\!\\%\\^\\&\\*\\(\\)\\-\\+\\=\\~\\|\\<\\>\\?\\/\\;\\,\\.]", PaletteIndex::Punctuation));

		langDef.mCommentStart = "/*";
		langDef.mCommentEnd = "*/";
		langDef.mSingleLineComment = "//";

		langDef.mCaseSensitive = true;
		langDef.mAutoIndentation = true;

		langDef.mName = "GLSL";

		inited = true;
	}
	return langDef;
}

const TextEditor::LanguageDefinition& TextEditor::LanguageDefinition::Python()
{
	static bool inited = false;
	static LanguageDefinition langDef;
	if (!inited)
	{
		static const char* const keywords[] = {
			"False", "await", "else", "import", "pass", "None", "break", "except", "in", "raise", "True", "class", "finally", "is", "return", "and", "continue", "for", "lambda", "try", "as", "def", "from", "nonlocal", "while", "assert", "del", "global", "not", "with", "async", "elif", "if", "or", "yield"
		};
		for (auto& k : keywords)
			langDef.mKeywords.insert(k);

		static const char* const identifiers[] = {
			"abs", "aiter", "all", "any", "anext", "ascii", "bin", "bool", "breakpoint", "bytearray", "bytes", "callable", "chr", "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod", "enumerate", "eval", "exec", "filter", "float", "format", "frozenset", "getattr", "globals", "hasattr", "hash", "help", "hex", "id", "input", "int", "isinstance", "issubclass", "iter", "len", "list", "locals", "map", "max", "memoryview", "min", "next", "object", "oct", "open", "ord", "pow", "print", "property", "range", "repr", "reversed", "round", "set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super", "tuple", "type", "vars", "zip", "__import__"
		};
		for (auto& k : identifiers)
		{
			Identifier id;
			id.mDeclaration = "Built-in function";
			langDef.mIdentifiers.insert(std::make_pair(std::string(k), id));
		}

		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("(b|u|f|r)?\\\"(\\\\.|[^\\\"])*\\\"", PaletteIndex::String));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("(b|u|f|r)?\\\'(\\\\.|[^\\\'])*\\\'", PaletteIndex::String));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)([eE][+-]?[0-9]+)?[fF]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?[0-9]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[0-7]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[xX][0-9a-fA-F]+[uU]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[a-zA-Z_][a-zA-Z0-9_]*", PaletteIndex::Identifier));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[\\[\\]\\{\\}\\!\\%\\^\\&\\*\\(\\)\\-\\+\\=\\~\\|\\<\\>\\?\\/\\;\\,\\.]", PaletteIndex::Punctuation));

		langDef.mCommentStart = "\"\"\"";
		langDef.mCommentEnd = "\"\"\"";
		langDef.mSingleLineComment = "#";

		langDef.mCaseSensitive = true;
		langDef.mAutoIndentation = true;

		langDef.mName = "Python";

		inited = true;
	}
	return langDef;
}

const TextEditor::LanguageDefinition& TextEditor::LanguageDefinition::C()
{
	static bool inited = false;
	static LanguageDefinition langDef;
	if (!inited)
	{
		static const char* const keywords[] = {
			"auto", "break", "case", "char", "const", "continue", "default", "do", "double", "else", "enum", "extern", "float", "for", "goto", "if", "inline", "int", "long", "register", "restrict", "return", "short",
			"signed", "sizeof", "static", "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while", "_Alignas", "_Alignof", "_Atomic", "_Bool", "_Complex", "_Generic", "_Imaginary",
			"_Noreturn", "_Static_assert", "_Thread_local"
		};
		for (auto& k : keywords)
			langDef.mKeywords.insert(k);

		static const char* const identifiers[] = {
			"abort", "abs", "acos", "asin", "atan", "atexit", "atof", "atoi", "atol", "ceil", "clock", "cosh", "ctime", "div", "exit", "fabs", "floor", "fmod", "getchar", "getenv", "isalnum", "isalpha", "isdigit", "isgraph",
			"ispunct", "isspace", "isupper", "kbhit", "log10", "log2", "log", "memcmp", "modf", "pow", "putchar", "putenv", "puts", "rand", "remove", "rename", "sinh", "sqrt", "srand", "strcat", "strcmp", "strerror", "time", "tolower", "toupper"
		};
		for (auto& k : identifiers)
		{
			Identifier id;
			id.mDeclaration = "Built-in function";
			langDef.mIdentifiers.insert(std::make_pair(std::string(k), id));
		}

		langDef.mTokenize = [](const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end, PaletteIndex& paletteIndex) -> bool
		{
			paletteIndex = PaletteIndex::Max;

			while (in_begin < in_end && isascii(*in_begin) && isblank(*in_begin))
				in_begin++;

			if (in_begin == in_end)
			{
				out_begin = in_end;
				out_end = in_end;
				paletteIndex = PaletteIndex::Default;
			}
			else if (TokenizeCStyleString(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::String;
			else if (TokenizeCStyleCharacterLiteral(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::CharLiteral;
			else if (TokenizeCStyleIdentifier(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Identifier;
			else if (TokenizeCStyleNumber(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Number;
			else if (TokenizeCStylePunctuation(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Punctuation;

			return paletteIndex != PaletteIndex::Max;
		};

		langDef.mCommentStart = "/*";
		langDef.mCommentEnd = "*/";
		langDef.mSingleLineComment = "//";

		langDef.mCaseSensitive = true;
		langDef.mAutoIndentation = true;

		langDef.mName = "C";

		inited = true;
	}
	return langDef;
}

const TextEditor::LanguageDefinition& TextEditor::LanguageDefinition::SQL()
{
	static bool inited = false;
	static LanguageDefinition langDef;
	if (!inited)
	{
		static const char* const keywords[] = {
			"ADD", "EXCEPT", "PERCENT", "ALL", "EXEC", "PLAN", "ALTER", "EXECUTE", "PRECISION", "AND", "EXISTS", "PRIMARY", "ANY", "EXIT", "PRINT", "AS", "FETCH", "PROC", "ASC", "FILE", "PROCEDURE",
			"AUTHORIZATION", "FILLFACTOR", "PUBLIC", "BACKUP", "FOR", "RAISERROR", "BEGIN", "FOREIGN", "READ", "BETWEEN", "FREETEXT", "READTEXT", "BREAK", "FREETEXTTABLE", "RECONFIGURE",
			"BROWSE", "FROM", "REFERENCES", "BULK", "FULL", "REPLICATION", "BY", "FUNCTION", "RESTORE", "CASCADE", "GOTO", "RESTRICT", "CASE", "GRANT", "RETURN", "CHECK", "GROUP", "REVOKE",
			"CHECKPOINT", "HAVING", "RIGHT", "CLOSE", "HOLDLOCK", "ROLLBACK", "CLUSTERED", "IDENTITY", "ROWCOUNT", "COALESCE", "IDENTITY_INSERT", "ROWGUIDCOL", "COLLATE", "IDENTITYCOL", "RULE",
			"COLUMN", "IF", "SAVE", "COMMIT", "IN", "SCHEMA", "COMPUTE", "INDEX", "SELECT", "CONSTRAINT", "INNER", "SESSION_USER", "CONTAINS", "INSERT", "SET", "CONTAINSTABLE", "INTERSECT", "SETUSER",
			"CONTINUE", "INTO", "SHUTDOWN", "CONVERT", "IS", "SOME", "CREATE", "JOIN", "STATISTICS", "CROSS", "KEY", "SYSTEM_USER", "CURRENT", "KILL", "TABLE", "CURRENT_DATE", "LEFT", "TEXTSIZE",
			"CURRENT_TIME", "LIKE", "THEN", "CURRENT_TIMESTAMP", "LINENO", "TO", "CURRENT_USER", "LOAD", "TOP", "CURSOR", "NATIONAL", "TRAN", "DATABASE", "NOCHECK", "TRANSACTION",
			"DBCC", "NONCLUSTERED", "TRIGGER", "DEALLOCATE", "NOT", "TRUNCATE", "DECLARE", "NULL", "TSEQUAL", "DEFAULT", "NULLIF", "UNION", "DELETE", "OF", "UNIQUE", "DENY", "OFF", "UPDATE",
			"DESC", "OFFSETS", "UPDATETEXT", "DISK", "ON", "USE", "DISTINCT", "OPEN", "USER", "DISTRIBUTED", "OPENDATASOURCE", "VALUES", "DOUBLE", "OPENQUERY", "VARYING","DROP", "OPENROWSET", "VIEW",
			"DUMMY", "OPENXML", "WAITFOR", "DUMP", "OPTION", "WHEN", "ELSE", "OR", "WHERE", "END", "ORDER", "WHILE", "ERRLVL", "OUTER", "WITH", "ESCAPE", "OVER", "WRITETEXT"
		};

		for (auto& k : keywords)
			langDef.mKeywords.insert(k);

		static const char* const identifiers[] = {
			"ABS", "ACOS", "ADD_MONTHS", "ASCII", "ASCIISTR", "ASIN", "ATAN", "ATAN2", "AVG", "BFILENAME", "BIN_TO_NUM", "BITAND", "CARDINALITY", "CASE", "CAST", "CEIL",
			"CHARTOROWID", "CHR", "COALESCE", "COMPOSE", "CONCAT", "CONVERT", "CORR", "COS", "COSH", "COUNT", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "CURRENT_DATE",
			"CURRENT_TIMESTAMP", "DBTIMEZONE", "DECODE", "DECOMPOSE", "DENSE_RANK", "DUMP", "EMPTY_BLOB", "EMPTY_CLOB", "EXP", "EXTRACT", "FIRST_VALUE", "FLOOR", "FROM_TZ", "GREATEST",
			"GROUP_ID", "HEXTORAW", "INITCAP", "INSTR", "INSTR2", "INSTR4", "INSTRB", "INSTRC", "LAG", "LAST_DAY", "LAST_VALUE", "LEAD", "LEAST", "LENGTH", "LENGTH2", "LENGTH4",
			"LENGTHB", "LENGTHC", "LISTAGG", "LN", "LNNVL", "LOCALTIMESTAMP", "LOG", "LOWER", "LPAD", "LTRIM", "MAX", "MEDIAN", "MIN", "MOD", "MONTHS_BETWEEN", "NANVL", "NCHR",
			"NEW_TIME", "NEXT_DAY", "NTH_VALUE", "NULLIF", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "NVL", "NVL2", "POWER", "RANK", "RAWTOHEX", "REGEXP_COUNT", "REGEXP_INSTR",
			"REGEXP_REPLACE", "REGEXP_SUBSTR", "REMAINDER", "REPLACE", "ROUND", "ROWNUM", "RPAD", "RTRIM", "SESSIONTIMEZONE", "SIGN", "SIN", "SINH",
			"SOUNDEX", "SQRT", "STDDEV", "SUBSTR", "SUM", "SYS_CONTEXT", "SYSDATE", "SYSTIMESTAMP", "TAN", "TANH", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_DSINTERVAL", "TO_LOB",
			"TO_MULTI_BYTE", "TO_NCLOB", "TO_NUMBER", "TO_SINGLE_BYTE", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_YMINTERVAL", "TRANSLATE", "TRIM", "TRUNC", "TZ_OFFSET", "UID", "UPPER",
			"USER", "USERENV", "VAR_POP", "VAR_SAMP", "VARIANCE", "VSIZE"
		};
		for (auto& k : identifiers)
		{
			Identifier id;
			id.mDeclaration = "Built-in function";
			langDef.mIdentifiers.insert(std::make_pair(std::string(k), id));
		}

		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("L?\\\"(\\\\.|[^\\\"])*\\\"", PaletteIndex::String));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("\\\'[^\\\']*\\\'", PaletteIndex::String));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)([eE][+-]?[0-9]+)?[fF]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?[0-9]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[0-7]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[xX][0-9a-fA-F]+[uU]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[a-zA-Z_][a-zA-Z0-9_]*", PaletteIndex::Identifier));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[\\[\\]\\{\\}\\!\\%\\^\\&\\*\\(\\)\\-\\+\\=\\~\\|\\<\\>\\?\\/\\;\\,\\.]", PaletteIndex::Punctuation));

		langDef.mCommentStart = "/*";
		langDef.mCommentEnd = "*/";
		langDef.mSingleLineComment = "--";

		langDef.mCaseSensitive = false;
		langDef.mAutoIndentation = false;

		langDef.mName = "SQL";

		inited = true;
	}
	return langDef;
}

const TextEditor::LanguageDefinition& TextEditor::LanguageDefinition::AngelScript()
{
	static bool inited = false;
	static LanguageDefinition langDef;
	if (!inited)
	{
		static const char* const keywords[] = {
			"and", "abstract", "auto", "bool", "break", "case", "cast", "class", "const", "continue", "default", "do", "double", "else", "enum", "false", "final", "float", "for",
			"from", "funcdef", "function", "get", "if", "import", "in", "inout", "int", "interface", "int8", "int16", "int32", "int64", "is", "mixin", "namespace", "not",
			"null", "or", "out", "override", "private", "protected", "return", "set", "shared", "super", "switch", "this ", "true", "typedef", "uint", "uint8", "uint16", "uint32",
			"uint64", "void", "while", "xor"
		};

		for (auto& k : keywords)
			langDef.mKeywords.insert(k);

		static const char* const identifiers[] = {
			"cos", "sin", "tab", "acos", "asin", "atan", "atan2", "cosh", "sinh", "tanh", "log", "log10", "pow", "sqrt", "abs", "ceil", "floor", "fraction", "closeTo", "fpFromIEEE", "fpToIEEE",
			"complex", "opEquals", "opAddAssign", "opSubAssign", "opMulAssign", "opDivAssign", "opAdd", "opSub", "opMul", "opDiv"
		};
		for (auto& k : identifiers)
		{
			Identifier id;
			id.mDeclaration = "Built-in function";
			langDef.mIdentifiers.insert(std::make_pair(std::string(k), id));
		}

		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("L?\\\"(\\\\.|[^\\\"])*\\\"", PaletteIndex::String));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("\\'\\\\?[^\\']\\'", PaletteIndex::String));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)([eE][+-]?[0-9]+)?[fF]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?[0-9]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[0-7]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[xX][0-9a-fA-F]+[uU]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[a-zA-Z_][a-zA-Z0-9_]*", PaletteIndex::Identifier));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[\\[\\]\\{\\}\\!\\%\\^\\&\\*\\(\\)\\-\\+\\=\\~\\|\\<\\>\\?\\/\\;\\,\\.]", PaletteIndex::Punctuation));

		langDef.mCommentStart = "/*";
		langDef.mCommentEnd = "*/";
		langDef.mSingleLineComment = "//";

		langDef.mCaseSensitive = true;
		langDef.mAutoIndentation = true;

		langDef.mName = "AngelScript";

		inited = true;
	}
	return langDef;
}

const TextEditor::LanguageDefinition& TextEditor::LanguageDefinition::Lua()
{
	static bool inited = false;
	static LanguageDefinition langDef;
	if (!inited)
	{
		static const char* const keywords[] = {
			"and", "break", "do", "else", "elseif", "end", "false", "for", "function", "goto", "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while"
		};

		for (auto& k : keywords)
			langDef.mKeywords.insert(k);

		static const char* const identifiers[] = {
			"assert", "collectgarbage", "dofile", "error", "getmetatable", "ipairs", "loadfile", "load", "loadstring", "next", "pairs", "pcall", "print", "rawequal", "rawlen", "rawget", "rawset",
			"select", "setmetatable", "tonumber", "tostring", "type", "xpcall", "_G", "_VERSION","arshift", "band", "bnot", "bor", "bxor", "btest", "extract", "lrotate", "lshift", "replace",
			"rrotate", "rshift", "create", "resume", "running", "status", "wrap", "yield", "isyieldable", "debug","getuservalue", "gethook", "getinfo", "getlocal", "getregistry", "getmetatable",
			"getupvalue", "upvaluejoin", "upvalueid", "setuservalue", "sethook", "setlocal", "setmetatable", "setupvalue", "traceback", "close", "flush", "input", "lines", "open", "output", "popen",
			"read", "tmpfile", "type", "write", "close", "flush", "lines", "read", "seek", "setvbuf", "write", "__gc", "__tostring", "abs", "acos", "asin", "atan", "ceil", "cos", "deg", "exp", "tointeger",
			"floor", "fmod", "ult", "log", "max", "min", "modf", "rad", "random", "randomseed", "sin", "sqrt", "string", "tan", "type", "atan2", "cosh", "sinh", "tanh",
			"pow", "frexp", "ldexp", "log10", "pi", "huge", "maxinteger", "mininteger", "loadlib", "searchpath", "seeall", "preload", "cpath", "path", "searchers", "loaded", "module", "require", "clock",
			"date", "difftime", "execute", "exit", "getenv", "remove", "rename", "setlocale", "time", "tmpname", "byte", "char", "dump", "find", "format", "gmatch", "gsub", "len", "lower", "match", "rep",
			"reverse", "sub", "upper", "pack", "packsize", "unpack", "concat", "maxn", "insert", "pack", "unpack", "remove", "move", "sort", "offset", "codepoint", "char", "len", "codes", "charpattern",
			"coroutine", "table", "io", "os", "string", "utf8", "bit32", "math", "debug", "package"
		};
		for (auto& k : identifiers)
		{
			Identifier id;
			id.mDeclaration = "Built-in function";
			langDef.mIdentifiers.insert(std::make_pair(std::string(k), id));
		}

		langDef.mTokenize = [](const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end, PaletteIndex& paletteIndex) -> bool
		{
			paletteIndex = PaletteIndex::Max;

			while (in_begin < in_end && isascii(*in_begin) && isblank(*in_begin))
				in_begin++;

			if (in_begin == in_end)
			{
				out_begin = in_end;
				out_end = in_end;
				paletteIndex = PaletteIndex::Default;
			}
			else if (TokenizeLuaStyleString(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::String;
			else if (TokenizeLuaStyleIdentifier(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Identifier;
			else if (TokenizeLuaStyleNumber(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Number;
			else if (TokenizeLuaStylePunctuation(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Punctuation;

			return paletteIndex != PaletteIndex::Max;
		};

		langDef.mCommentStart = "--[[";
		langDef.mCommentEnd = "]]";
		langDef.mSingleLineComment = "--";

		langDef.mCaseSensitive = true;
		langDef.mAutoIndentation = false;

		langDef.mName = "Lua";

		inited = true;
	}
	return langDef;
}

const TextEditor::LanguageDefinition& TextEditor::LanguageDefinition::CSharp()
{
	static bool inited = false;
	static LanguageDefinition langDef;
	if (!inited)
	{
		static const char* const keywords[] = {
			"abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "in (generic modifier)", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "out (generic modifier)", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "using static", "void", "volatile", "while"
		};
		for (auto& k : keywords)
			langDef.mKeywords.insert(k);

		static const char* const identifiers[] = {
			"add", "alias", "ascending", "async", "await", "descending", "dynamic", "from", "get", "global", "group", "into", "join", "let", "orderby", "partial", "remove", "select", "set", "value", "var", "when", "where", "yield"
		};
		for (auto& k : identifiers)
		{
			Identifier id;
			id.mDeclaration = "Built-in function";
			langDef.mIdentifiers.insert(std::make_pair(std::string(k), id));
		}

		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("($|@)?\\\"(\\\\.|[^\\\"])*\\\"", PaletteIndex::String));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)([eE][+-]?[0-9]+)?[fF]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[+-]?[0-9]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[0-7]+[Uu]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("0[xX][0-9a-fA-F]+[uU]?[lL]?[lL]?", PaletteIndex::Number));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[a-zA-Z_][a-zA-Z0-9_]*", PaletteIndex::Identifier));
		langDef.mTokenRegexStrings.push_back(std::make_pair<std::string, PaletteIndex>("[\\[\\]\\{\\}\\!\\%\\^\\&\\*\\(\\)\\-\\+\\=\\~\\|\\<\\>\\?\\/\\;\\,\\.]", PaletteIndex::Punctuation));

		langDef.mCommentStart = "/*";
		langDef.mCommentEnd = "*/";
		langDef.mSingleLineComment = "//";

		langDef.mCaseSensitive = true;
		langDef.mAutoIndentation = true;

		langDef.mName = "C#";

		inited = true;
	}
	return langDef;
}

static bool TokenizeValveNumber(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	const char* p = in_begin;

	// cant begin without quotes
	if (*p != '"')
		return false;

	p++;

	// beginning array of numbers
	const bool specialMode = *p == '[';

	if (specialMode)
		p++;

	while (p < in_end)
	{
		bool isNumber = false;

		// .6 as example
		if (*p == '.')
			p++;

		// prefixes
		if (*p == '+' || *p == '-')
			p++;

		// is any number?
		while (p < in_end && (*p >= '0' && *p <= '9'))
		{
			isNumber = true;
			p++;
		}

		if (isNumber == false)
			return false;

		bool isFloat = false;
		bool isHex = false;
		bool isBinary = false;

		if (p < in_end)
		{
			// for example 6.
			if (*p == '.')
			{
				isFloat = true;

				p++;

				while (p < in_end && (*p >= '0' && *p <= '9'))
					p++;
			}
			else if (*p == 'x' || *p == 'X')
			{
				// hex formatted integer of the type 0xef80

				isHex = true;

				p++;

				while (p < in_end && ((*p >= '0' && *p <= '9') || (*p >= 'a' && *p <= 'f') || (*p >= 'A' && *p <= 'F')))
					p++;
			}
			else if (*p == 'b' || *p == 'B')
			{
				// binary formatted integer of the type 0b01011101

				isBinary = true;

				p++;

				while (p < in_end && (*p >= '0' && *p <= '1'))
					p++;
			}
		}

		if (isHex == false && isBinary == false)
		{
			// floating point exponent
			if (p < in_end && (*p == 'e' || *p == 'E'))
			{
				isFloat = true;

				p++;

				if (p < in_end && (*p == '+' || *p == '-'))
					p++;

				bool hasDigits = false;

				while (p < in_end && (*p >= '0' && *p <= '9'))
				{
					hasDigits = true;
					p++;
				}

				if (hasDigits == false)
					return false;
			}

			// single precision floating point type
			if (p < in_end && *p == 'f')
				p++;
		}

		// integer size type
		while (p < in_end && (*p == 'u' || *p == 'U' || *p == 'l' || *p == 'L'))
			p++;

		// only go loop again if there are spaces
		if (specialMode && *p == ' ')
			p++;
		// if not array and there is an end, finish it
		else if (!specialMode && *p == '"')
		{
			out_begin = in_begin;
			out_end = p + 1;
			return true;
		}
		// if array mode and there is an end, finish it
		else if (specialMode && *p == ']' && *(p + 1) == '"')
		{
			out_begin = in_begin;
			out_end = p + 2;
			return true;
		}
		else // only false on every unmatched
			return false;
	}

	return false;
}

static bool TokenizeValvePunctation(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	const char* p = in_begin;

	if (*p == '"')
	{
		p++;

		switch (*p) 
		{
		case '!':
		case '%':
		case '&':
		case '?':
		case '$':
			while (p < in_end)
			{
				// handle end of string
				if (*p == '"')
				{
					out_begin = in_begin;
					out_end = p + 1;
					return true;
				}

				// handle escape character for "
				if (*p == '\\' && p + 1 < in_end && p[1] == '"')
					p++;

				p++;
			}
		}
	}

	return false;
}

static bool TokenizeValveString(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end)
{
	std::array badStart = { '!', '%', '&', '?', '$' };
	for (const auto& el : badStart)
		if (in_begin[1] == el)
			return false;

	return TokenizeCStyleString(in_begin, in_end, out_begin, out_end);
}

const TextEditor::LanguageDefinition& TextEditor::LanguageDefinition::ValveKeyValues()
{
	static bool inited = false;
	static LanguageDefinition langDef;
	if (!inited)
	{
		static const char* const ppnames[] = {
			"Add", "Multiply", "Subtract", "Divide", "Equals", "Abs", "Frac", "Int", "Clamp", "LessOrEqual", "SelectFirstIfNonZero", "WrapMinMax", "Exponential",
			"Sine", "LinearRamp", "CurrentTime", "UniformNoise", "GaussianNoise", "MatrixRotate",
			"Alpha", "Cycle", "PlayerProximity", "PlayerTeamMatch", "PlayerView", "PlayerSpeed", "PlayerPosition", "EntitySpeed", "EntityOrigin", "EntityRandom", "Health", "IsNPC", "WorldDims", "CrosshairColor",
			"AnimatedTexture", "AnimatedEntityTexture", "AnimatedOffsetTexture", "AnimateSpecificTexture", "Pupil", "TextureTransform", "TextureScroll", "LampBeam", "LampHalo", "CustomSteamImageOnModel",
			"MaterialModify", "MaterialModifyAnimated", "WaterLOD", "BreakableSurface", "ConveyorScroll", "Camo", "FleshInterior", "HeliBlade", "ParticleSphereProxy", "PlayerLogo", "Shadow", "ShadowModel", "ToggleTexture",
			"Empty", "Dummy",
			"ConVar"
		};

		// was too lazy to make actual structured solution for this
		static const char* const ppvalues[] = {
			"Calculation", "Calculation", "Calculation", "Calculation", "Calculation", "Calculation", "Calculation", "Calculation", "Calculation", "Calculation", "Calculation", "Calculation", "Calculation",
			"Number generation", "Number generation", "Number generation", "Number generation", "Number generation", "Number generation",
			"Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access", "Entity Data Access",
			"Texture manipulation", "Texture manipulation", "Texture manipulation", "Texture manipulation", "Texture manipulation", "Texture manipulation", "Texture manipulation", "Texture manipulation", "Texture manipulation", "Texture manipulation",
			"Entity integration", "Entity integration", "Entity integration", "Entity integration", "Entity integration", "Entity integration", "Entity integration", "Entity integration", "Entity integration", "Entity integration", "Entity integration", "Entity integration", "Entity integration", 
			"Empty", "Dummy",
			"ConVar"
		};

		for (int i = 0; i < sizeof(ppnames) / sizeof(ppnames[0]); ++i)
		{
			TextEditor::Identifier id;
			id.mDeclaration = ppvalues[i];
			langDef.mPreprocIdentifiers.insert(std::make_pair(std::string(ppnames[i]), id));
		}

		// missing https://developer.valvesoftware.com/wiki/Material_optimization
		// missing https://developer.valvesoftware.com/wiki/Material_Map_Compile_Flags
		// is that really needed?
		static const char* const identifiers[] = {
			"Proxies"
		};

		static const char* idecls[] = {
			"Manipulate properties"
		};

		for (auto& k : identifiers)
		{
			Identifier id;
			id.mDeclaration = "Built-in function";
			langDef.mIdentifiers.insert(std::make_pair(std::string(k), id));
		}

		langDef.mTokenize = [](const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end, PaletteIndex& paletteIndex) -> bool
		{
			paletteIndex = PaletteIndex::Max;

			while (in_begin < in_end && isascii(*in_begin) && isblank(*in_begin))
				in_begin++;

			if (in_begin == in_end)
			{
				out_begin = in_end;
				out_end = in_end;
				paletteIndex = PaletteIndex::Default;
			}
			if (TokenizeValveNumber(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Number;
			else if (TokenizeValveString(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::String;
			else if (TokenizeCStyleIdentifier(in_begin, in_end, out_begin, out_end)) // no need for special ones
				paletteIndex = PaletteIndex::Identifier;
			else if (TokenizeValvePunctation(in_begin, in_end, out_begin, out_end))
				paletteIndex = PaletteIndex::Punctuation;

			return paletteIndex != PaletteIndex::Max;
		};

		langDef.mCommentStart = "//";
		langDef.mSingleLineComment = "//";

		langDef.mCaseSensitive = true;
		langDef.mAutoIndentation = true;

		langDef.mName = "Valve Scripting Language";

		inited = true;
	}
	return langDef;
}
```

`hack/deps/ImGui/editor/TextEditor.cpp`:

```cpp
#include <algorithm>
#include <chrono>
#include <string>
#include <regex>
#include <cmath>

#include "TextEditor.hpp"

#define IMGUI_DEFINE_MATH_OPERATORS
#include "imgui.h" // for imGui::GetCurrentWindow()

// TODO
// - multiline comments vs single-line: latter is blocking start of a ML

template<class InputIt1, class InputIt2, class BinaryPredicate>
bool equals(InputIt1 first1, InputIt1 last1,
	InputIt2 first2, InputIt2 last2, BinaryPredicate p)
{
	for (; first1 != last1 && first2 != last2; ++first1, ++first2)
	{
		if (!p(*first1, *first2))
			return false;
	}
	return first1 == last1 && first2 == last2;
}

TextEditor::TextEditor()
	: mLineSpacing(1.0f)
	, mUndoIndex(0)
	, mTabSize(4)
	, mOverwrite(false)
	, mReadOnly(false)
	, mWithinRender(false)
	, mScrollToCursor(false)
	, mScrollToTop(false)
	, mTextChanged(false)
	, mColorizerEnabled(true)
	, mTextStart(20.0f)
	, mLeftMargin(10)
	, mColorRangeMin(0)
	, mColorRangeMax(0)
	, mSelectionMode(SelectionMode::Normal)
	, mCheckComments(true)
	, mHandleKeyboardInputs(true)
	, mHandleMouseInputs(true)
	, mIgnoreImGuiChild(false)
	, mShowWhitespaces(true)
	, mShowShortTabGlyphs(false)
	, mStartTime(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count())
	, mLastClick(-1.0f)
{
	SetPalette(GetMarianaPalette());
	mLines.push_back(Line());
}

TextEditor::~TextEditor()
{
}

void TextEditor::SetLanguageDefinition(const LanguageDefinition& aLanguageDef)
{
	mLanguageDefinition = &aLanguageDef;
	mRegexList.clear();

	for (const auto& r : mLanguageDefinition->mTokenRegexStrings)
		mRegexList.push_back(std::make_pair(std::regex(r.first, std::regex_constants::optimize), r.second));

	Colorize();
}

const char* TextEditor::GetLanguageDefinitionName() const
{
	return mLanguageDefinition != nullptr ? mLanguageDefinition->mName.c_str() : "unknown";
}

void TextEditor::SetPalette(const Palette& aValue)
{
	mPaletteBase = aValue;
}

std::string TextEditor::GetText(const Coordinates& aStart, const Coordinates& aEnd) const
{
	std::string result;

	auto lstart = aStart.mLine;
	auto lend = aEnd.mLine;
	auto istart = GetCharacterIndexR(aStart);
	auto iend = GetCharacterIndexR(aEnd);
	size_t s = 0;

	for (int i = lstart; i < lend; i++)
		s += mLines[i].size();

	result.reserve(s + s / 8);

	while (istart < iend || lstart < lend)
	{
		if (lstart >= (int)mLines.size())
			break;

		auto& line = mLines[lstart];
		if (istart < (int)line.size())
		{
			result += line[istart].mChar;
			istart++;
		}
		else
		{
			istart = 0;
			++lstart;
			result += '\n';
		}
	}

	return result;
}

TextEditor::Coordinates TextEditor::GetActualCursorCoordinates(int aCursor) const
{
	if (aCursor == -1)
		return SanitizeCoordinates(mState.mCursors[mState.mCurrentCursor].mCursorPosition);
	else
		return SanitizeCoordinates(mState.mCursors[aCursor].mCursorPosition);
}

TextEditor::Coordinates TextEditor::SanitizeCoordinates(const Coordinates& aValue) const
{
	auto line = aValue.mLine;
	auto column = aValue.mColumn;
	if (line >= (int)mLines.size())
	{
		if (mLines.empty())
		{
			line = 0;
			column = 0;
		}
		else
		{
			line = (int)mLines.size() - 1;
			column = GetLineMaxColumn(line);
		}
		return Coordinates(line, column);
	}
	else
	{
		column = mLines.empty() ? 0 : std::min(column, GetLineMaxColumn(line));
		return Coordinates(line, column);
	}
}

// https://en.wikipedia.org/wiki/UTF-8
// We assume that the char is a standalone character (<128) or a leading byte of an UTF-8 code sequence (non-10xxxxxx code)
static int UTF8CharLength(TextEditor::Char c)
{
	if ((c & 0xFE) == 0xFC)
		return 6;
	if ((c & 0xFC) == 0xF8)
		return 5;
	if ((c & 0xF8) == 0xF0)
		return 4;
	else if ((c & 0xF0) == 0xE0)
		return 3;
	else if ((c & 0xE0) == 0xC0)
		return 2;
	return 1;
}

// "Borrowed" from ImGui source
static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)
{
	if (c < 0x80)
	{
		buf[0] = (char)c;
		return 1;
	}
	if (c < 0x800)
	{
		if (buf_size < 2) return 0;
		buf[0] = (char)(0xc0 + (c >> 6));
		buf[1] = (char)(0x80 + (c & 0x3f));
		return 2;
	}
	if (c >= 0xdc00 && c < 0xe000)
	{
		return 0;
	}
	if (c >= 0xd800 && c < 0xdc00)
	{
		if (buf_size < 4) return 0;
		buf[0] = (char)(0xf0 + (c >> 18));
		buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
		buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
		buf[3] = (char)(0x80 + ((c) & 0x3f));
		return 4;
	}
	//else if (c < 0x10000)
	{
		if (buf_size < 3) return 0;
		buf[0] = (char)(0xe0 + (c >> 12));
		buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));
		buf[2] = (char)(0x80 + ((c) & 0x3f));
		return 3;
	}
}

void TextEditor::Advance(Coordinates& aCoordinates) const
{
	if (aCoordinates.mLine >= (int)mLines.size())
		return;

	auto& line = mLines[aCoordinates.mLine];
	auto cindex = GetCharacterIndexL(aCoordinates);

	if (cindex < (int)line.size())
	{
		auto delta = UTF8CharLength(line[cindex].mChar);
		cindex = std::min(cindex + delta, (int)line.size());
	}
	else if ((int)mLines.size() > aCoordinates.mLine + 1)
	{
		++aCoordinates.mLine;
		cindex = 0;
	}
	aCoordinates.mColumn = GetCharacterColumn(aCoordinates.mLine, cindex);
}

void TextEditor::DeleteRange(const Coordinates& aStart, const Coordinates& aEnd)
{
	assert(aEnd >= aStart);
	assert(!mReadOnly);

	//printf("D(%d.%d)-(%d.%d)\n", aStart.mLine, aStart.mColumn, aEnd.mLine, aEnd.mColumn);

	if (aEnd == aStart)
		return;

	auto start = GetCharacterIndexL(aStart);
	auto end = GetCharacterIndexR(aEnd);

	if (aStart.mLine == aEnd.mLine)
	{
		auto n = GetLineMaxColumn(aStart.mLine);
		if (aEnd.mColumn >= n)
			RemoveGlyphsFromLine(aStart.mLine, start); // from start to end of line
		else
			RemoveGlyphsFromLine(aStart.mLine, start, end);
	}
	else
	{
		RemoveGlyphsFromLine(aStart.mLine, start); // from start to end of line
		RemoveGlyphsFromLine(aEnd.mLine, 0, end);
		auto& firstLine = mLines[aStart.mLine];
		auto& lastLine = mLines[aEnd.mLine];

		if (aStart.mLine < aEnd.mLine)
			AddGlyphsToLine(aStart.mLine, firstLine.size(), lastLine.begin(), lastLine.end());

		if (aStart.mLine < aEnd.mLine)
			RemoveLines(aStart.mLine + 1, aEnd.mLine + 1);
	}

	mTextChanged = true;
}

int TextEditor::InsertTextAt(Coordinates& /* inout */ aWhere, const char* aValue)
{
	assert(!mReadOnly);

	int cindex = GetCharacterIndexR(aWhere);
	int totalLines = 0;
	while (*aValue != '\0')
	{
		assert(!mLines.empty());

		if (*aValue == '\r')
		{
			// skip
			++aValue;
		}
		else if (*aValue == '\n')
		{
			if (cindex < (int)mLines[aWhere.mLine].size())
			{
				auto& newLine = InsertLine(aWhere.mLine + 1);
				auto& line = mLines[aWhere.mLine];
				AddGlyphsToLine(aWhere.mLine + 1, 0, line.begin() + cindex, line.end());
				RemoveGlyphsFromLine(aWhere.mLine, cindex);
			}
			else
			{
				InsertLine(aWhere.mLine + 1);
			}
			++aWhere.mLine;
			aWhere.mColumn = 0;
			cindex = 0;
			++totalLines;
			++aValue;
		}
		else
		{
			auto& line = mLines[aWhere.mLine];
			auto d = UTF8CharLength(*aValue);
			while (d-- > 0 && *aValue != '\0')
				AddGlyphToLine(aWhere.mLine, cindex++, Glyph(*aValue++, PaletteIndex::Default));
			aWhere.mColumn = GetCharacterColumn(aWhere.mLine, cindex);
		}

		mTextChanged = true;
	}

	return totalLines;
}

void TextEditor::AddUndo(UndoRecord& aValue)
{
	assert(!mReadOnly);
	//printf("AddUndo: (@%d.%d) +\'%s' [%d.%d .. %d.%d], -\'%s', [%d.%d .. %d.%d] (@%d.%d)\n",
	//	aValue.mBefore.mCursorPosition.mLine, aValue.mBefore.mCursorPosition.mColumn,
	//	aValue.mAdded.c_str(), aValue.mAddedStart.mLine, aValue.mAddedStart.mColumn, aValue.mAddedEnd.mLine, aValue.mAddedEnd.mColumn,
	//	aValue.mRemoved.c_str(), aValue.mRemovedStart.mLine, aValue.mRemovedStart.mColumn, aValue.mRemovedEnd.mLine, aValue.mRemovedEnd.mColumn,
	//	aValue.mAfter.mCursorPosition.mLine, aValue.mAfter.mCursorPosition.mColumn
	//	);

	mUndoBuffer.resize((size_t)(mUndoIndex + 1));
	mUndoBuffer.back() = aValue;
	++mUndoIndex;
}

TextEditor::Coordinates TextEditor::ScreenPosToCoordinates(const ImVec2& aPosition, bool aInsertionMode, bool* isOverLineNumber) const
{
	ImVec2 origin = ImGui::GetCursorScreenPos();
	ImVec2 local(aPosition.x - origin.x + 3.0f, aPosition.y - origin.y);

	if (isOverLineNumber != nullptr)
		*isOverLineNumber = local.x < mTextStart;

	float spaceSize = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ").x;

	int lineNo = std::max(0, (int)floor(local.y / mCharAdvance.y));

	int columnCoord = 0;

	if (lineNo >= 0 && lineNo < (int)mLines.size())
	{
		auto& line = mLines.at(lineNo);

		int columnIndex = 0;
		std::string cumulatedString = "";
		float columnWidth = 0.0f;
		float columnX = 0.0f;
		int delta = 0;

		// First we find the hovered column coord.
		for (size_t columnIndex = 0; columnIndex < line.size(); ++columnIndex)
		{
			float columnWidth = 0.0f;
			int delta = 0;

			if (line[columnIndex].mChar == '\t')
			{
				float oldX = columnX;
				columnX = (1.0f + std::floor((1.0f + columnX) / (float(mTabSize) * spaceSize))) * (float(mTabSize) * spaceSize);
				columnWidth = columnX - oldX;
				delta = mTabSize - (columnCoord % mTabSize);
			}
			else
			{
				char buf[7];
				auto d = UTF8CharLength(line[columnIndex].mChar);
				int i = 0;
				while (i < 6 && d-- > 0)
					buf[i++] = line[columnIndex].mChar;
				buf[i] = '\0';
				columnWidth = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buf).x;
				columnX += columnWidth;
				delta = 1;
			}

			if (mTextStart + columnX - (aInsertionMode ? 0.5f : 0.0f) * columnWidth < local.x)
				columnCoord += delta;
			else
				break;
		}

		// Then we reduce by 1 column coord if cursor is on the left side of the hovered column.
		//if (aInsertionMode && mTextStart + columnX - columnWidth * 2.0f < local.x)
		//	columnIndex = std::min((int)line.size() - 1, columnIndex + 1);
	}

	return SanitizeCoordinates(Coordinates(lineNo, columnCoord));
}

TextEditor::Coordinates TextEditor::FindWordStart(const Coordinates& aFrom) const
{
	Coordinates at = aFrom;
	if (at.mLine >= (int)mLines.size())
		return at;

	auto& line = mLines[at.mLine];
	auto cindex = GetCharacterIndexL(at);

	if (cindex >= (int)line.size())
		return at;

	bool initialIsWordChar = IsGlyphWordChar(line[cindex]);
	bool initialIsSpace = isspace(line[cindex].mChar);
	uint8_t initialChar = line[cindex].mChar;
	bool needToAdvance = false;
	while (true)
	{
		--cindex;
		if (cindex < 0)
		{
			cindex = 0;
			break;
		}

		auto c = line[cindex].mChar;
		if ((c & 0xC0) != 0x80)	// not UTF code sequence 10xxxxxx
		{
			bool isWordChar = IsGlyphWordChar(line[cindex]);
			bool isSpace = isspace(line[cindex].mChar);
			if (initialIsSpace && !isSpace || initialIsWordChar && !isWordChar || !initialIsWordChar && !initialIsSpace && initialChar != line[cindex].mChar)
			{
				needToAdvance = true;
				break;
			}
		}
	}
	at.mColumn = GetCharacterColumn(at.mLine, cindex);
	if (needToAdvance)
		Advance(at);
	return at;
}

TextEditor::Coordinates TextEditor::FindWordEnd(const Coordinates& aFrom) const
{
	Coordinates at = aFrom;
	if (at.mLine >= (int)mLines.size())
		return at;

	auto& line = mLines[at.mLine];
	auto cindex = GetCharacterIndexL(at);

	if (cindex >= (int)line.size())
		return at;

	bool initialIsWordChar = IsGlyphWordChar(line[cindex]);
	bool initialIsSpace = isspace(line[cindex].mChar);
	uint8_t initialChar = line[cindex].mChar;
	while (true)
	{
		auto d = UTF8CharLength(line[cindex].mChar);
		cindex += d;
		if (cindex >= (int)line.size())
			break;

		bool isWordChar = IsGlyphWordChar(line[cindex]);
		bool isSpace = isspace(line[cindex].mChar);
		if (initialIsSpace && !isSpace || initialIsWordChar && !isWordChar || !initialIsWordChar && !initialIsSpace && initialChar != line[cindex].mChar)
			break;
	}
	at.mColumn = GetCharacterColumn(at.mLine, cindex);
	return at;
}

TextEditor::Coordinates TextEditor::FindNextWord(const Coordinates& aFrom) const
{
	Coordinates at = aFrom;
	if (at.mLine >= (int)mLines.size())
		return at;

	// skip to the next non-word character
	auto cindex = GetCharacterIndexR(aFrom);
	bool isword = false;
	bool skip = false;
	if (cindex < (int)mLines[at.mLine].size())
	{
		auto& line = mLines[at.mLine];
		isword = !!isalnum(line[cindex].mChar);
		skip = isword;
	}

	while (!isword || skip)
	{
		if (at.mLine >= (int)mLines.size())
		{
			auto l = std::max(0, (int)mLines.size() - 1);
			return Coordinates(l, GetLineMaxColumn(l));
		}

		auto& line = mLines[at.mLine];
		if (cindex < (int)line.size())
		{
			isword = isalnum(line[cindex].mChar);

			if (isword && !skip)
				return Coordinates(at.mLine, GetCharacterColumn(at.mLine, cindex));

			if (!isword)
				skip = false;

			cindex++;
		}
		else
		{
			cindex = 0;
			++at.mLine;
			skip = false;
			isword = false;
		}
	}

	return at;
}

int TextEditor::GetCharacterIndexL(const Coordinates& aCoordinates) const
{
	if (aCoordinates.mLine >= (int)mLines.size())
		return -1;

	auto& line = mLines[aCoordinates.mLine];
	int c = 0;
	int i = 0;
	int tabCoordsLeft = 0;

	for (; i < (int)line.size() && c < aCoordinates.mColumn;)
	{
		if (line[i].mChar == '\t')
		{
			if (tabCoordsLeft == 0)
				tabCoordsLeft = mTabSize - (c % mTabSize);
			if (tabCoordsLeft > 0)
				tabCoordsLeft--;
			c++;
		}
		else
			++c;
		if (tabCoordsLeft == 0)
			i += UTF8CharLength(line[i].mChar);
	}
	return i;
}

int TextEditor::GetCharacterIndexR(const Coordinates& aCoordinates) const
{
	if (aCoordinates.mLine >= (int)mLines.size())
		return -1;
	auto& line = mLines[aCoordinates.mLine];
	int c = 0;
	int i = 0;
	for (; i < (int)line.size() && c < aCoordinates.mColumn;)
	{
		if (line[i].mChar == '\t')
			c = (c / mTabSize) * mTabSize + mTabSize;
		else
			++c;
		i += UTF8CharLength(line[i].mChar);
	}
	return i;
}

int TextEditor::GetCharacterColumn(int aLine, int aIndex) const
{
	if (aLine >= (int)mLines.size())
		return 0;
	auto& line = mLines[aLine];
	int col = 0;
	int i = 0;
	while (i < aIndex && i < (int)line.size())
	{
		auto c = line[i].mChar;
		i += UTF8CharLength(c);
		if (c == '\t')
			col = (col / mTabSize) * mTabSize + mTabSize;
		else
			col++;
	}
	return col;
}

int TextEditor::GetLineCharacterCount(int aLine) const
{
	if (aLine >= (int)mLines.size())
		return 0;
	auto& line = mLines[aLine];
	int c = 0;
	for (unsigned i = 0; i < line.size(); c++)
		i += UTF8CharLength(line[i].mChar);
	return c;
}

int TextEditor::GetLineMaxColumn(int aLine) const
{
	if (aLine >= (int)mLines.size())
		return 0;
	auto& line = mLines[aLine];
	int col = 0;
	for (unsigned i = 0; i < line.size(); )
	{
		auto c = line[i].mChar;
		if (c == '\t')
			col = (col / mTabSize) * mTabSize + mTabSize;
		else
			col++;
		i += UTF8CharLength(c);
	}
	return col;
}

bool TextEditor::IsOnWordBoundary(const Coordinates& aAt) const
{
	if (aAt.mLine >= (int)mLines.size() || aAt.mColumn == 0)
		return true;

	auto& line = mLines[aAt.mLine];
	auto cindex = GetCharacterIndexR(aAt);
	if (cindex >= (int)line.size())
		return true;

	if (mColorizerEnabled)
		return line[cindex].mColorIndex != line[size_t(cindex - 1)].mColorIndex;

	return isspace(line[cindex].mChar) != isspace(line[cindex - 1].mChar);
}

void TextEditor::RemoveLines(int aStart, int aEnd)
{
	assert(!mReadOnly);
	assert(aEnd >= aStart);
	assert(mLines.size() > (size_t)(aEnd - aStart));

	ErrorMarkers etmp;
	for (auto& i : mErrorMarkers)
	{
		ErrorMarkers::value_type e(i.first >= aStart ? i.first - 1 : i.first, i.second);
		if (e.first >= aStart && e.first <= aEnd)
			continue;
		etmp.insert(e);
	}
	mErrorMarkers = std::move(etmp);

	Breakpoints btmp;
	for (auto i : mBreakpoints)
	{
		if (i >= aStart && i <= aEnd)
			continue;
		btmp.insert(i >= aStart ? i - 1 : i);
	}
	mBreakpoints = std::move(btmp);

	mLines.erase(mLines.begin() + aStart, mLines.begin() + aEnd);
	assert(!mLines.empty());

	mTextChanged = true;

	OnLinesDeleted(aStart, aEnd);
}

void TextEditor::RemoveLine(int aIndex, const std::unordered_set<int>* aHandledCursors)
{
	assert(!mReadOnly);
	assert(mLines.size() > 1);

	ErrorMarkers etmp;
	for (auto& i : mErrorMarkers)
	{
		ErrorMarkers::value_type e(i.first > aIndex ? i.first - 1 : i.first, i.second);
		if (e.first - 1 == aIndex)
			continue;
		etmp.insert(e);
	}
	mErrorMarkers = std::move(etmp);

	Breakpoints btmp;
	for (auto i : mBreakpoints)
	{
		if (i == aIndex)
			continue;
		btmp.insert(i >= aIndex ? i - 1 : i);
	}
	mBreakpoints = std::move(btmp);

	mLines.erase(mLines.begin() + aIndex);
	assert(!mLines.empty());

	mTextChanged = true;

	OnLineDeleted(aIndex, aHandledCursors);
}

void TextEditor::RemoveCurrentLines()
{
	UndoRecord u;
	u.mBefore = mState;

	if (HasSelection())
	{
		for (int c = mState.mCurrentCursor; c > -1; c--)
		{
			u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
			DeleteSelection(c);
		}
	}

	for (int c = mState.mCurrentCursor; c > -1; c--)
	{
		int currentLine = mState.mCursors[c].mCursorPosition.mLine;
		int nextLine = currentLine + 1;
		int prevLine = currentLine - 1;

		Coordinates toDeleteStart, toDeleteEnd;
		if ((int)mLines.size() > nextLine) // next line exists
		{
			toDeleteStart = Coordinates(currentLine, 0);
			toDeleteEnd = Coordinates(nextLine, 0);
			SetCursorPosition({ mState.mCursors[c].mCursorPosition.mLine, 0 }, c);
		}
		else if (prevLine > -1) // previous line exists
		{
			toDeleteStart = Coordinates(prevLine, GetLineMaxColumn(prevLine));
			toDeleteEnd = Coordinates(currentLine, GetLineMaxColumn(currentLine));
			SetCursorPosition({ prevLine, 0 }, c);
		}
		else
		{
			toDeleteStart = Coordinates(currentLine, 0);
			toDeleteEnd = Coordinates(currentLine, GetLineMaxColumn(currentLine));
			SetCursorPosition({ currentLine, 0 }, c);
		}

		u.mOperations.push_back({ GetText(toDeleteStart, toDeleteEnd), toDeleteStart, toDeleteEnd, UndoOperationType::Delete });

		std::unordered_set<int> handledCursors = { c };
		if (toDeleteStart.mLine != toDeleteEnd.mLine)
			RemoveLine(currentLine, &handledCursors);
		else
			DeleteRange(toDeleteStart, toDeleteEnd);
	}

	u.mAfter = mState;
	AddUndo(u);
}

void TextEditor::OnLineChanged(bool aBeforeChange, int aLine, int aColumn, int aCharCount, bool aDeleted)
{
	static std::unordered_map<int, int> cursorCharIndices;
	if (aBeforeChange)
	{
		cursorCharIndices.clear();
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			if (mState.mCursors[c].mCursorPosition.mLine == aLine)
			{
				if (mState.mCursors[c].mCursorPosition.mColumn > aColumn)
				{
					cursorCharIndices[c] = GetCharacterIndexR({ aLine, mState.mCursors[c].mCursorPosition.mColumn });
					cursorCharIndices[c] += aDeleted ? -aCharCount : aCharCount;
				}
			}
		}
	}
	else
	{
		for (auto& item : cursorCharIndices)
			SetCursorPosition({ aLine, GetCharacterColumn(aLine, item.second) }, item.first);
	}
}

void TextEditor::RemoveGlyphsFromLine(int aLine, int aStartChar, int aEndChar)
{
	int column = GetCharacterColumn(aLine, aStartChar);
	int deltaX = GetCharacterColumn(aLine, aEndChar) - column;
	auto& line = mLines[aLine];
	OnLineChanged(true, aLine, column, aEndChar - aStartChar, true);
	line.erase(line.begin() + aStartChar, aEndChar == -1 ? line.end() : line.begin() + aEndChar);
	OnLineChanged(false, aLine, column, aEndChar - aStartChar, true);
}

void TextEditor::AddGlyphsToLine(int aLine, int aTargetIndex, Line::iterator aSourceStart, Line::iterator aSourceEnd)
{
	int targetColumn = GetCharacterColumn(aLine, aTargetIndex);
	int charsInserted = std::distance(aSourceStart, aSourceEnd);
	auto& line = mLines[aLine];
	OnLineChanged(true, aLine, targetColumn, charsInserted, false);
	line.insert(line.begin() + aTargetIndex, aSourceStart, aSourceEnd);
	OnLineChanged(false, aLine, targetColumn, charsInserted, false);
}

void TextEditor::AddGlyphToLine(int aLine, int aTargetIndex, Glyph aGlyph)
{
	int targetColumn = GetCharacterColumn(aLine, aTargetIndex);
	auto& line = mLines[aLine];
	OnLineChanged(true, aLine, targetColumn, 1, false);
	line.insert(line.begin() + aTargetIndex, aGlyph);
	OnLineChanged(false, aLine, targetColumn, 1, false);
}

TextEditor::Line& TextEditor::InsertLine(int aIndex)
{
	assert(!mReadOnly);

	auto& result = *mLines.insert(mLines.begin() + aIndex, Line());

	ErrorMarkers etmp;
	for (auto& i : mErrorMarkers)
		etmp.insert(ErrorMarkers::value_type(i.first >= aIndex ? i.first + 1 : i.first, i.second));
	mErrorMarkers = std::move(etmp);

	Breakpoints btmp;
	for (auto i : mBreakpoints)
		btmp.insert(i >= aIndex ? i + 1 : i);
	mBreakpoints = std::move(btmp);

	OnLineAdded(aIndex);

	return result;
}

std::string TextEditor::GetWordUnderCursor() const
{
	auto c = GetCursorPosition();
	return GetWordAt(c);
}

std::string TextEditor::GetWordAt(const Coordinates& aCoords) const
{
	auto start = FindWordStart(aCoords);
	auto end = FindWordEnd(aCoords);

	std::string r;

	auto istart = GetCharacterIndexR(start);
	auto iend = GetCharacterIndexR(end);

	for (auto it = istart; it < iend; ++it)
		r.push_back(mLines[aCoords.mLine][it].mChar);

	return r;
}

ImU32 TextEditor::GetGlyphColor(const Glyph& aGlyph) const
{
	if (!mColorizerEnabled)
		return mPalette[(int)PaletteIndex::Default];
	if (aGlyph.mComment)
		return mPalette[(int)PaletteIndex::Comment];
	if (aGlyph.mMultiLineComment)
		return mPalette[(int)PaletteIndex::MultiLineComment];
	auto const color = mPalette[(int)aGlyph.mColorIndex];
	if (aGlyph.mPreprocessor)
	{
		const auto ppcolor = mPalette[(int)PaletteIndex::Preprocessor];
		const int c0 = ((ppcolor & 0xff) + (color & 0xff)) / 2;
		const int c1 = (((ppcolor >> 8) & 0xff) + ((color >> 8) & 0xff)) / 2;
		const int c2 = (((ppcolor >> 16) & 0xff) + ((color >> 16) & 0xff)) / 2;
		const int c3 = (((ppcolor >> 24) & 0xff) + ((color >> 24) & 0xff)) / 2;
		return ImU32(c0 | (c1 << 8) | (c2 << 16) | (c3 << 24));
	}
	return color;
}

bool TextEditor::IsGlyphWordChar(const Glyph& aGlyph)
{
	int sizeInBytes = UTF8CharLength(aGlyph.mChar);
	return sizeInBytes > 1 ||
		aGlyph.mChar >= 'a' && aGlyph.mChar <= 'z' ||
		aGlyph.mChar >= 'A' && aGlyph.mChar <= 'Z' ||
		aGlyph.mChar >= '0' && aGlyph.mChar <= '9' ||
		aGlyph.mChar == '_';
}

void TextEditor::HandleKeyboardInputs(bool aParentIsFocused)
{
	if (ImGui::IsWindowFocused() || aParentIsFocused)
	{
		if (ImGui::IsWindowHovered())
			ImGui::SetMouseCursor(ImGuiMouseCursor_TextInput);
		//ImGui::CaptureKeyboardFromApp(true);

		ImGuiIO& io = ImGui::GetIO();
		auto isOSX = io.ConfigMacOSXBehaviors;
		auto alt = io.KeyAlt;
		auto ctrl = io.KeyCtrl;
		auto shift = io.KeyShift;
		auto super = io.KeySuper;

		auto isShortcut = (isOSX ? (super && !ctrl) : (ctrl && !super)) && !alt && !shift;
		auto isShiftShortcut = (isOSX ? (super && !ctrl) : (ctrl && !super)) && shift && !alt;
		auto isWordmoveKey = isOSX ? alt : ctrl;
		auto isAltOnly = alt && !ctrl && !shift && !super;
		auto isCtrlOnly = ctrl && !alt && !shift && !super;
		auto isShiftOnly = shift && !alt && !ctrl && !super;

		io.WantCaptureKeyboard = true;
		io.WantTextInput = true;

		if (!IsReadOnly() && isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Z)))
			Undo();
		else if (!IsReadOnly() && isAltOnly && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Backspace)))
			Undo();
		else if (!IsReadOnly() && isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Y)))
			Redo();
		else if (!IsReadOnly() && isShiftShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Z)))
			Redo();
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_UpArrow)))
			MoveUp(1, shift);
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_DownArrow)))
			MoveDown(1, shift);
		else if ((isOSX ? !ctrl : !alt) && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_LeftArrow)))
			MoveLeft(1, shift, isWordmoveKey);
		else if ((isOSX ? !ctrl : !alt) && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_RightArrow)))
			MoveRight(1, shift, isWordmoveKey);
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_PageUp)))
			MoveUp(GetPageSize() - 4, shift);
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_PageDown)))
			MoveDown(GetPageSize() - 4, shift);
		else if (ctrl && !alt && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Home)))
			MoveTop(shift);
		else if (ctrl && !alt && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_End)))
			MoveBottom(shift);
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Home)))
			MoveHome(shift);
		else if (!alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_End)))
			MoveEnd(shift);
		else if (!IsReadOnly() && !alt && !shift && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Delete)))
			Delete(ctrl);
		else if (!IsReadOnly() && !alt && !shift && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Backspace)))
			Backspace(ctrl);
		else if (!IsReadOnly() && !alt && ctrl && shift && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_K)))
			RemoveCurrentLines();
		else if (!IsReadOnly() && !alt && ctrl && !shift && !super && ImGui::IsKeyPressed(ImGuiKey_LeftBracket))
			ChangeCurrentLinesIndentation(false);
		else if (!IsReadOnly() && !alt && ctrl && !shift && !super && ImGui::IsKeyPressed(ImGuiKey_RightBracket))
			ChangeCurrentLinesIndentation(true);
		else if (!alt && !ctrl && !shift && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Insert)))
			mOverwrite ^= true;
		else if (isCtrlOnly && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Insert)))
			Copy();
		else if (isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))
			Copy();
		else if (!IsReadOnly() && isShiftOnly && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Insert)))
			Paste();
		else if (!IsReadOnly() && isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_V)))
			Paste();
		else if (isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_X)))
			Cut();
		else if (isShiftOnly && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Delete)))
			Cut();
		else if (isShortcut && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_A)))
			SelectAll();
		else if (!IsReadOnly() && !alt && !ctrl && !shift && !super && (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Enter)) || ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_KeyPadEnter))))
			EnterCharacter('\n', false);
		else if (!IsReadOnly() && !alt && !ctrl && !super && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Tab)))
			EnterCharacter('\t', shift);
		if (!IsReadOnly() && !io.InputQueueCharacters.empty() && !ctrl && !super)
		{
			for (int i = 0; i < io.InputQueueCharacters.Size; i++)
			{
				auto c = io.InputQueueCharacters[i];
				if (c != 0 && (c == '\n' || c >= 32))
					EnterCharacter(c, shift);
			}
			io.InputQueueCharacters.resize(0);
		}
	}
}

void TextEditor::HandleMouseInputs()
{
	ImGuiIO& io = ImGui::GetIO();
	auto shift = io.KeyShift;
	auto ctrl = io.ConfigMacOSXBehaviors ? io.KeySuper : io.KeyCtrl;
	auto alt = io.ConfigMacOSXBehaviors ? io.KeyCtrl : io.KeyAlt;

	if (ImGui::IsWindowHovered())
	{
		auto click = ImGui::IsMouseClicked(0);
		if (!shift && !alt)
		{
			auto doubleClick = ImGui::IsMouseDoubleClicked(0);
			auto t = ImGui::GetTime();
			auto tripleClick = click && !doubleClick && (mLastClick != -1.0f && (t - mLastClick) < io.MouseDoubleClickTime);

			/*
			Left mouse button triple click
			*/

			if (tripleClick)
			{
				if (ctrl)
					mState.AddCursor();
				else
					mState.mCurrentCursor = 0;

				mState.mCursors[mState.mCurrentCursor].mCursorPosition = mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = ScreenPosToCoordinates(ImGui::GetMousePos());
				mSelectionMode = SelectionMode::Line;
				SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd, mSelectionMode);

				mLastClick = -1.0f;
			}

			/*
			Left mouse button double click
			*/

			else if (doubleClick)
			{
				if (ctrl)
					mState.AddCursor();
				else
					mState.mCurrentCursor = 0;

				mState.mCursors[mState.mCurrentCursor].mCursorPosition = mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = ScreenPosToCoordinates(ImGui::GetMousePos());
				mState.mCursors[mState.mCurrentCursor].mInteractiveStart = FindWordStart(mState.mCursors[mState.mCurrentCursor].mCursorPosition);
				mState.mCursors[mState.mCurrentCursor].mCursorPosition = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = FindWordEnd(mState.mCursors[mState.mCurrentCursor].mCursorPosition);
				if (mSelectionMode == SelectionMode::Line)
					mSelectionMode = SelectionMode::Normal;
				else
					mSelectionMode = SelectionMode::Word;
				SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd, mSelectionMode);

				mLastClick = (float)ImGui::GetTime();
			}

			/*
			Left mouse button click
			*/
			else if (click)
			{
				if (ctrl)
					mState.AddCursor();
				else
					mState.mCurrentCursor = 0;

				bool isOverLineNumber;
				mState.mCursors[mState.mCurrentCursor].mCursorPosition = mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = ScreenPosToCoordinates(ImGui::GetMousePos(), !mOverwrite, &isOverLineNumber);
				if (isOverLineNumber)
					mSelectionMode = SelectionMode::Line;
				else if (ctrl)
					mSelectionMode = SelectionMode::Word;
				else
					mSelectionMode = SelectionMode::Normal;
				SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd, mSelectionMode, -1, ctrl);

				mLastClick = (float)ImGui::GetTime();
			}
			// Mouse left button dragging (=> update selection)
			else if (ImGui::IsMouseDragging(0) && ImGui::IsMouseDown(0))
			{
				mDraggingSelection = true;
				io.WantCaptureMouse = true;
				mState.mCursors[mState.mCurrentCursor].mCursorPosition = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = ScreenPosToCoordinates(ImGui::GetMousePos(), !mOverwrite);
				SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd, mSelectionMode);
			}
			else if (ImGui::IsMouseReleased(0))
			{
				mDraggingSelection = false;

				// sort from cursors from top to bottom
				std::sort(mState.mCursors.begin(), mState.mCursors.begin() + (mState.mCurrentCursor + 1), [](const Cursor& a, const Cursor& b) -> bool
					{
						return a.mSelectionStart < b.mSelectionStart;
					});
				MergeCursorsIfPossible();
			}
		}
		else if (shift)
		{
			if (click)
			{
				Coordinates oldCursorPosition = mState.mCursors[mState.mCurrentCursor].mCursorPosition;
				Coordinates newSelection = ScreenPosToCoordinates(ImGui::GetMousePos(), !mOverwrite);
				if (newSelection > mState.mCursors[mState.mCurrentCursor].mCursorPosition)
					SetSelectionEnd(newSelection);
				else
					SetSelectionStart(newSelection);
				mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = mState.mCursors[mState.mCurrentCursor].mSelectionEnd;
				mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mSelectionStart;
				mState.mCursors[mState.mCurrentCursor].mCursorPosition = newSelection;
				mState.mCursors[mState.mCurrentCursor].mCursorPositionChanged = oldCursorPosition != newSelection;
			}
		}
	}
}

void TextEditor::UpdatePalette()
{
	/* Update palette with the current alpha from style */
	for (int i = 0; i < (int)PaletteIndex::Max; ++i)
	{
		auto color = U32ColorToVec4(mPaletteBase[i]);
		color.w *= ImGui::GetStyle().Alpha;
		mPalette[i] = ImGui::ColorConvertFloat4ToU32(color);
	}
}

void TextEditor::Render(bool aParentIsFocused)
{
	/* Compute mCharAdvance regarding to scaled font size (Ctrl + mouse wheel)*/
	const float fontSize = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, "#", nullptr, nullptr).x;
	mCharAdvance = ImVec2(fontSize, ImGui::GetTextLineHeightWithSpacing() * mLineSpacing);

	assert(mLineBuffer.empty());

	auto contentSize = ImGui::GetWindowContentRegionMax();
	auto drawList = ImGui::GetWindowDrawList();
	float longest(mTextStart);

	if (mScrollToTop)
	{
		mScrollToTop = false;
		ImGui::SetScrollY(0.f);
	}

	ImVec2 cursorScreenPos = ImGui::GetCursorScreenPos();
	auto scrollX = ImGui::GetScrollX();
	auto scrollY = ImGui::GetScrollY();

	auto lineNo = (int)floor(scrollY / mCharAdvance.y);
	auto globalLineMax = (int)mLines.size();
	auto lineMax = std::max(0, std::min((int)mLines.size() - 1, lineNo + (int)floor((scrollY + contentSize.y) / mCharAdvance.y)));

	// Deduce mTextStart by evaluating mLines size (global lineMax) plus two spaces as text width
	char buf[16];
	snprintf(buf, 16, " %d ", globalLineMax);
	mTextStart = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buf, nullptr, nullptr).x + mLeftMargin;

	if (!mLines.empty())
	{
		float spaceSize = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr).x;

		while (lineNo <= lineMax)
		{
			ImVec2 lineStartScreenPos = ImVec2(cursorScreenPos.x, cursorScreenPos.y + lineNo * mCharAdvance.y);
			ImVec2 textScreenPos = ImVec2(lineStartScreenPos.x + mTextStart, lineStartScreenPos.y);

			auto& line = mLines[lineNo];
			longest = std::max(mTextStart + TextDistanceToLineStart(Coordinates(lineNo, GetLineMaxColumn(lineNo))), longest);
			auto columnNo = 0;
			Coordinates lineStartCoord(lineNo, 0);
			Coordinates lineEndCoord(lineNo, GetLineMaxColumn(lineNo));

			// Draw selection for the current line
			for (int c = 0; c <= mState.mCurrentCursor; c++)
			{
				float sstart = -1.0f;
				float ssend = -1.0f;

				assert(mState.mCursors[c].mSelectionStart <= mState.mCursors[c].mSelectionEnd);
				if (mState.mCursors[c].mSelectionStart <= lineEndCoord)
					sstart = mState.mCursors[c].mSelectionStart > lineStartCoord ? TextDistanceToLineStart(mState.mCursors[c].mSelectionStart) : 0.0f;
				if (mState.mCursors[c].mSelectionEnd > lineStartCoord)
					ssend = TextDistanceToLineStart(mState.mCursors[c].mSelectionEnd < lineEndCoord ? mState.mCursors[c].mSelectionEnd : lineEndCoord);

				if (mState.mCursors[c].mSelectionEnd.mLine > lineNo)
					ssend += mCharAdvance.x;

				if (sstart != -1 && ssend != -1 && sstart < ssend)
				{
					ImVec2 vstart(lineStartScreenPos.x + mTextStart + sstart, lineStartScreenPos.y);
					ImVec2 vend(lineStartScreenPos.x + mTextStart + ssend, lineStartScreenPos.y + mCharAdvance.y);
					drawList->AddRectFilled(vstart, vend, mPalette[(int)PaletteIndex::Selection]);
				}
			}

			// Draw breakpoints
			auto start = ImVec2(lineStartScreenPos.x + scrollX, lineStartScreenPos.y);

			if (mBreakpoints.count(lineNo + 1) != 0)
			{
				auto end = ImVec2(lineStartScreenPos.x + contentSize.x + 2.0f * scrollX, lineStartScreenPos.y + mCharAdvance.y);
				drawList->AddRectFilled(start, end, mPalette[(int)PaletteIndex::Breakpoint]);
			}

			// Draw error markers
			auto errorIt = mErrorMarkers.find(lineNo + 1);
			if (errorIt != mErrorMarkers.end())
			{
				auto end = ImVec2(lineStartScreenPos.x + contentSize.x + 2.0f * scrollX, lineStartScreenPos.y + mCharAdvance.y);
				drawList->AddRectFilled(start, end, mPalette[(int)PaletteIndex::ErrorMarker]);

				if (ImGui::IsMouseHoveringRect(lineStartScreenPos, end))
				{
					ImGui::BeginTooltip();
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.2f, 0.2f, 1.0f));
					ImGui::Text("Error at line %d:", errorIt->first);
					ImGui::PopStyleColor();
					ImGui::Separator();
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 0.2f, 1.0f));
					ImGui::Text("%s", errorIt->second.c_str());
					ImGui::PopStyleColor();
					ImGui::EndTooltip();
				}
			}

			// Draw line number (right aligned)
			snprintf(buf, 16, "%d  ", lineNo + 1);

			auto lineNoWidth = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buf, nullptr, nullptr).x;
			drawList->AddText(ImVec2(lineStartScreenPos.x + mTextStart - lineNoWidth, lineStartScreenPos.y), mPalette[(int)PaletteIndex::LineNumber], buf);

			std::vector<Coordinates> cursorCoordsInThisLine;
			for (int c = 0; c <= mState.mCurrentCursor; c++)
			{
				if (mState.mCursors[c].mCursorPosition.mLine == lineNo)
					cursorCoordsInThisLine.push_back(mState.mCursors[c].mCursorPosition);
			}
			if (cursorCoordsInThisLine.size() > 0)
			{
				auto focused = ImGui::IsWindowFocused() || aParentIsFocused;

				// Render the cursors
				if (focused)
				{
					for (const auto& cursorCoords : cursorCoordsInThisLine)
					{
						float width = 1.0f;
						auto cindex = GetCharacterIndexR(cursorCoords);
						float cx = TextDistanceToLineStart(cursorCoords);

						if (mOverwrite && cindex < (int)line.size())
						{
							auto c = line[cindex].mChar;
							if (c == '\t')
							{
								auto x = (1.0f + std::floor((1.0f + cx) / (float(mTabSize) * spaceSize))) * (float(mTabSize) * spaceSize);
								width = x - cx;
							}
							else
							{
								char buf2[2];
								buf2[0] = line[cindex].mChar;
								buf2[1] = '\0';
								width = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buf2).x;
							}
						}
						ImVec2 cstart(textScreenPos.x + cx, lineStartScreenPos.y);
						ImVec2 cend(textScreenPos.x + cx + width, lineStartScreenPos.y + mCharAdvance.y);
						drawList->AddRectFilled(cstart, cend, mPalette[(int)PaletteIndex::Cursor]);
					}
				}
			}

			// Render colorized text
			auto prevColor = line.empty() ? mPalette[(int)PaletteIndex::Default] : GetGlyphColor(line[0]);
			ImVec2 bufferOffset;

			for (int i = 0; i < (int)line.size();)
			{
				auto& glyph = line[i];
				auto color = GetGlyphColor(glyph);

				if ((color != prevColor || glyph.mChar == '\t' || glyph.mChar == ' ') && !mLineBuffer.empty())
				{
					const ImVec2 newOffset(textScreenPos.x + bufferOffset.x, textScreenPos.y + bufferOffset.y);
					drawList->AddText(newOffset, prevColor, mLineBuffer.c_str());
					auto textSize = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, mLineBuffer.c_str(), nullptr, nullptr);
					bufferOffset.x += textSize.x;
					mLineBuffer.clear();
				}
				prevColor = color;

				if (glyph.mChar == '\t')
				{
					auto oldX = bufferOffset.x;
					bufferOffset.x = (1.0f + std::floor((1.0f + bufferOffset.x) / (float(mTabSize) * spaceSize))) * (float(mTabSize) * spaceSize);
					++i;

					if (mShowWhitespaces)
					{
						ImVec2 p1, p2, p3, p4;

						if (mShowShortTabGlyphs)
						{
							const auto s = ImGui::GetFontSize();
							const auto x1 = textScreenPos.x + oldX + 1.0f;
							const auto x2 = textScreenPos.x + oldX + mCharAdvance.x - 1.0f;
							const auto y = textScreenPos.y + bufferOffset.y + s * 0.5f;

							p1 = ImVec2(x1, y);
							p2 = ImVec2(x2, y);
							p3 = ImVec2(x2 - s * 0.16f, y - s * 0.16f);
							p4 = ImVec2(x2 - s * 0.16f, y + s * 0.16f);
						}
						else
						{
							const auto s = ImGui::GetFontSize();
							const auto x1 = textScreenPos.x + oldX + 1.0f;
							const auto x2 = textScreenPos.x + bufferOffset.x - 1.0f;
							const auto y = textScreenPos.y + bufferOffset.y + s * 0.5f;

							p1 = ImVec2(x1, y);
							p2 = ImVec2(x2, y);
							p3 = ImVec2(x2 - s * 0.2f, y - s * 0.2f);
							p4 = ImVec2(x2 - s * 0.2f, y + s * 0.2f);
						}

						drawList->AddLine(p1, p2, mPalette[(int)PaletteIndex::ControlCharacter]);
						drawList->AddLine(p2, p3, mPalette[(int)PaletteIndex::ControlCharacter]);
						drawList->AddLine(p2, p4, mPalette[(int)PaletteIndex::ControlCharacter]);
					}
				}
				else if (glyph.mChar == ' ')
				{
					if (mShowWhitespaces)
					{
						const auto s = ImGui::GetFontSize();
						const auto x = textScreenPos.x + bufferOffset.x + spaceSize * 0.5f;
						const auto y = textScreenPos.y + bufferOffset.y + s * 0.5f;
						drawList->AddCircleFilled(ImVec2(x, y), 1.5f, 0x80808080, 4);
					}
					bufferOffset.x += spaceSize;
					i++;
				}
				else
				{
					auto l = UTF8CharLength(glyph.mChar);
					while (l-- > 0)
						mLineBuffer.push_back(line[i++].mChar);
				}
				++columnNo;
			}

			if (!mLineBuffer.empty())
			{
				const ImVec2 newOffset(textScreenPos.x + bufferOffset.x, textScreenPos.y + bufferOffset.y);
				drawList->AddText(newOffset, prevColor, mLineBuffer.c_str());
				mLineBuffer.clear();
			}

			++lineNo;
		}

		// Draw a tooltip on known identifiers/preprocessor symbols
		if (ImGui::IsMousePosValid() && ImGui::IsWindowHovered() && mLanguageDefinition != nullptr)
		{
			auto mpos = ImGui::GetMousePos();
			ImVec2 origin = ImGui::GetCursorScreenPos();
			ImVec2 local(mpos.x - origin.x, mpos.y - origin.y);
			//printf("Mouse: pos(%g, %g), origin(%g, %g), local(%g, %g)\n", mpos.x, mpos.y, origin.x, origin.y, local.x, local.y);
			if (local.x >= mTextStart)
			{
				auto pos = ScreenPosToCoordinates(mpos);
				//printf("Coord(%d, %d)\n", pos.mLine, pos.mColumn);
				auto id = GetWordAt(pos);
				if (!id.empty())
				{
					auto it = mLanguageDefinition->mIdentifiers.find(id);
					if (it != mLanguageDefinition->mIdentifiers.end())
					{
						ImGui::BeginTooltip();
						ImGui::TextUnformatted(it->second.mDeclaration.c_str());
						ImGui::EndTooltip();
					}
					else
					{
						auto pi = mLanguageDefinition->mPreprocIdentifiers.find(id);
						if (pi != mLanguageDefinition->mPreprocIdentifiers.end())
						{
							ImGui::BeginTooltip();
							ImGui::TextUnformatted(pi->second.mDeclaration.c_str());
							ImGui::EndTooltip();
						}
					}
				}
			}
		}
	}

	ImGui::SetCursorPos(ImVec2(0, 0));
	ImGui::Dummy(ImVec2((longest + 2), mLines.size() * mCharAdvance.y));

	if (mScrollToCursor)
	{
		EnsureCursorVisible();
		mScrollToCursor = false;
	}
}

bool TextEditor::Render(const char* aTitle, bool aParentIsFocused, const ImVec2& aSize, bool aBorder)
{
	for (int c = 0; c <= mState.mCurrentCursor; c++)
	{
		if (mState.mCursors[c].mCursorPositionChanged)
			OnCursorPositionChanged(c);
		if (c <= mState.mCurrentCursor)
			mState.mCursors[c].mCursorPositionChanged = false;
	}

	mWithinRender = true;
	mTextChanged = false;

	UpdatePalette();

	ImGui::PushStyleColor(ImGuiCol_ChildBg, ImGui::ColorConvertU32ToFloat4(mPalette[(int)PaletteIndex::Background]));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
	if (!mIgnoreImGuiChild)
		ImGui::BeginChild(aTitle, aSize, aBorder, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNavInputs);

	bool isFocused = ImGui::IsWindowFocused();
	if (mHandleKeyboardInputs)
	{
		HandleKeyboardInputs(aParentIsFocused);
		ImGui::PushAllowKeyboardFocus(true);
	}

	if (mHandleMouseInputs)
		HandleMouseInputs();

	ColorizeInternal();
	Render(aParentIsFocused);

	if (mHandleKeyboardInputs)
		ImGui::PopAllowKeyboardFocus();

	if (!mIgnoreImGuiChild)
		ImGui::EndChild();

	ImGui::PopStyleVar();
	ImGui::PopStyleColor();

	mWithinRender = false;
	return isFocused;
}

void TextEditor::SetText(const std::string& aText)
{
	mLines.clear();
	mLines.emplace_back(Line());
	for (auto chr : aText)
	{
		if (chr == '\r')
		{
			// ignore the carriage return character
		}
		else if (chr == '\n')
			mLines.emplace_back(Line());
		else
		{
			mLines.back().emplace_back(Glyph(chr, PaletteIndex::Default));
		}
	}

	mTextChanged = true;
	mScrollToTop = true;

	mUndoBuffer.clear();
	mUndoIndex = 0;

	Colorize();
}

void TextEditor::SetTextLines(const std::vector<std::string>& aLines)
{
	mLines.clear();

	if (aLines.empty())
	{
		mLines.emplace_back(Line());
	}
	else
	{
		mLines.resize(aLines.size());

		for (size_t i = 0; i < aLines.size(); ++i)
		{
			const std::string& aLine = aLines[i];

			mLines[i].reserve(aLine.size());
			for (size_t j = 0; j < aLine.size(); ++j)
				mLines[i].emplace_back(Glyph(aLine[j], PaletteIndex::Default));
		}
	}

	mTextChanged = true;
	mScrollToTop = true;

	mUndoBuffer.clear();
	mUndoIndex = 0;

	Colorize();
}


void TextEditor::ChangeCurrentLinesIndentation(bool aIncrease)
{
	assert(!mReadOnly);

	UndoRecord u;
	u.mBefore = mState;

	for (int c = mState.mCurrentCursor; c > -1; c--)
	{
		auto start = mState.mCursors[c].mSelectionStart;
		auto end = mState.mCursors[c].mSelectionEnd;
		auto originalEnd = end;

		if (start > end)
			std::swap(start, end);
		start.mColumn = 0;
		//			end.mColumn = end.mLine < mLines.size() ? mLines[end.mLine].size() : 0;
		if (end.mColumn == 0 && end.mLine > 0)
			--end.mLine;
		if (end.mLine >= (int)mLines.size())
			end.mLine = mLines.empty() ? 0 : (int)mLines.size() - 1;
		end.mColumn = GetLineMaxColumn(end.mLine);

		//if (end.mColumn >= GetLineMaxColumn(end.mLine))
		//	end.mColumn = GetLineMaxColumn(end.mLine) - 1;

		UndoOperation removeOperation = { GetText(start, end) , start, end, UndoOperationType::Delete };

		bool modified = false;

		for (int i = start.mLine; i <= end.mLine; i++)
		{
			auto& line = mLines[i];
			if (!aIncrease)
			{
				if (!line.empty())

				{
					if (line.front().mChar == '\t')
					{
						RemoveGlyphsFromLine(i, 0, 1);
						modified = true;
					}
					else
					{
						for (int j = 0; j < mTabSize && !line.empty() && line.front().mChar == ' '; j++)
						{
							RemoveGlyphsFromLine(i, 0, 1);
							modified = true;
						}
					}
				}
			}
			else if (mLines[i].size() > 0)
			{
				AddGlyphToLine(i, 0, Glyph('\t', TextEditor::PaletteIndex::Background));
				modified = true;
			}
		}

		if (modified)
		{
			start = Coordinates(start.mLine, GetCharacterColumn(start.mLine, 0));
			Coordinates rangeEnd;
			std::string addedText;
			if (originalEnd.mColumn != 0)
			{
				end = Coordinates(end.mLine, GetLineMaxColumn(end.mLine));
				rangeEnd = end;
				addedText = GetText(start, end);
			}
			else
			{
				end = Coordinates(originalEnd.mLine, 0);
				rangeEnd = Coordinates(end.mLine - 1, GetLineMaxColumn(end.mLine - 1));
				addedText = GetText(start, rangeEnd);
			}

			u.mOperations.push_back(removeOperation);
			u.mOperations.push_back({ addedText , start, rangeEnd, UndoOperationType::Add });
			u.mAfter = mState;

			mState.mCursors[c].mSelectionStart = start;
			mState.mCursors[c].mSelectionEnd = end;

			mTextChanged = true;
		}
	}

	EnsureCursorVisible();
	if (u.mOperations.size() > 0)
		AddUndo(u);
}

void TextEditor::EnterCharacter(ImWchar aChar, bool aShift)
{
	assert(!mReadOnly);

	bool hasSelection = HasSelection();
	bool anyCursorHasMultilineSelection = false;
	for (int c = mState.mCurrentCursor; c > -1; c--)
		if (mState.mCursors[c].mSelectionStart.mLine != mState.mCursors[c].mSelectionEnd.mLine)
		{
			anyCursorHasMultilineSelection = true;
			break;
		}
	bool isIndentOperation = hasSelection && anyCursorHasMultilineSelection && aChar == '\t';
	if (isIndentOperation)
	{
		ChangeCurrentLinesIndentation(!aShift);
		return;
	}

	UndoRecord u;
	u.mBefore = mState;

	if (hasSelection)
	{
		for (int c = mState.mCurrentCursor; c > -1; c--)
		{
			u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
			DeleteSelection(c);
		}
	} // HasSelection

	std::vector<Coordinates> coords;
	for (int c = mState.mCurrentCursor; c > -1; c--) // order important here for typing \n in the same line at the same time
	{
		auto coord = GetActualCursorCoordinates(c);
		coords.push_back(coord);
		UndoOperation added;
		added.mType = UndoOperationType::Add;
		added.mStart = coord;

		assert(!mLines.empty());

		if (aChar == '\n')
		{
			InsertLine(coord.mLine + 1);
			auto& line = mLines[coord.mLine];
			auto& newLine = mLines[coord.mLine + 1];

			added.mText = "";
			added.mText += (char)aChar;
			if (mLanguageDefinition != nullptr && mLanguageDefinition->mAutoIndentation)
				for (size_t it = 0; it < line.size() && isascii(line[it].mChar) && isblank(line[it].mChar); ++it)
				{
					newLine.push_back(line[it]);
					added.mText += line[it].mChar;
				}

			const size_t whitespaceSize = newLine.size();
			auto cindex = GetCharacterIndexR(coord);
			AddGlyphsToLine(coord.mLine + 1, newLine.size(), line.begin() + cindex, line.end());
			RemoveGlyphsFromLine(coord.mLine, cindex);
			SetCursorPosition(Coordinates(coord.mLine + 1, GetCharacterColumn(coord.mLine + 1, (int)whitespaceSize)), c);
		}
		else
		{
			char buf[7];
			int e = ImTextCharToUtf8(buf, 7, aChar);
			if (e > 0)
			{
				buf[e] = '\0';
				auto& line = mLines[coord.mLine];
				auto cindex = GetCharacterIndexR(coord);

				if (mOverwrite && cindex < (int)line.size())
				{
					auto d = UTF8CharLength(line[cindex].mChar);

					UndoOperation removed;
					removed.mType = UndoOperationType::Delete;
					removed.mStart = mState.mCursors[c].mCursorPosition;
					removed.mEnd = Coordinates(coord.mLine, GetCharacterColumn(coord.mLine, cindex + d));

					while (d-- > 0 && cindex < (int)line.size())
					{
						removed.mText += line[cindex].mChar;
						RemoveGlyphsFromLine(coord.mLine, cindex, cindex + 1);
					}
					u.mOperations.push_back(removed);
				}

				for (auto p = buf; *p != '\0'; p++, ++cindex)
					AddGlyphToLine(coord.mLine, cindex, Glyph(*p, PaletteIndex::Default));
				added.mText = buf;

				SetCursorPosition(Coordinates(coord.mLine, GetCharacterColumn(coord.mLine, cindex)), c);
			}
			else
				continue;
		}

		mTextChanged = true;

		added.mEnd = GetActualCursorCoordinates(c);
		u.mOperations.push_back(added);
	}

	u.mAfter = mState;
	AddUndo(u);

	for (const auto& coord : coords)
		Colorize(coord.mLine - 1, 3);
	EnsureCursorVisible();
}

void TextEditor::SetReadOnly(bool aValue)
{
	mReadOnly = aValue;
}

void TextEditor::OnCursorPositionChanged(int aCursor)
{
	if (mDraggingSelection)
		return;

	//std::cout << "Cursor position changed\n";
	// sort from cursors from top to bottom
	std::sort(mState.mCursors.begin(), mState.mCursors.begin() + (mState.mCurrentCursor + 1), [](const Cursor& a, const Cursor& b) -> bool
		{
			return a.mSelectionStart < b.mSelectionStart;
		});
	MergeCursorsIfPossible();
}

void TextEditor::SetColorizerEnable(bool aValue)
{
	mColorizerEnabled = aValue;
}

void TextEditor::SetCursorPosition(const Coordinates& aPosition, int aCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	//std::string log = "Moved cursor " + std::to_string(aCursor) + " from " +
	//	std::to_string(mState.mCursors[aCursor].mCursorPosition.mLine) + "," + std::to_string(mState.mCursors[aCursor].mCursorPosition.mColumn) + " to ";

	if (mState.mCursors[aCursor].mCursorPosition != aPosition)
	{
		mState.mCursors[aCursor].mCursorPosition = aPosition;
		mState.mCursors[aCursor].mCursorPositionChanged = true;
		EnsureCursorVisible();
	}

	//log += std::to_string(mState.mCursors[aCursor].mCursorPosition.mLine) + "," + std::to_string(mState.mCursors[aCursor].mCursorPosition.mColumn);
	//std::cout << log << std::endl;
}

void TextEditor::SetCursorPosition(int aLine, int aCharIndex, int aCursor)
{
	SetCursorPosition({ aLine, GetCharacterColumn(aLine, aCharIndex) }, aCursor);
}

void TextEditor::SetSelectionStart(const Coordinates& aPosition, int aCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	mState.mCursors[aCursor].mSelectionStart = SanitizeCoordinates(aPosition);
	if (mState.mCursors[aCursor].mSelectionStart > mState.mCursors[aCursor].mSelectionEnd)
		std::swap(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionEnd);
}

void TextEditor::SetSelectionEnd(const Coordinates& aPosition, int aCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	mState.mCursors[aCursor].mSelectionEnd = SanitizeCoordinates(aPosition);
	if (mState.mCursors[aCursor].mSelectionStart > mState.mCursors[aCursor].mSelectionEnd)
		std::swap(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionEnd);
}

void TextEditor::SetSelection(const Coordinates& aStart, const Coordinates& aEnd, SelectionMode aMode, int aCursor, bool isSpawningNewCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	auto oldSelStart = mState.mCursors[aCursor].mSelectionStart;
	auto oldSelEnd = mState.mCursors[aCursor].mSelectionEnd;

	mState.mCursors[aCursor].mSelectionStart = SanitizeCoordinates(aStart);
	mState.mCursors[aCursor].mSelectionEnd = SanitizeCoordinates(aEnd);
	if (mState.mCursors[aCursor].mSelectionStart > mState.mCursors[aCursor].mSelectionEnd)
		std::swap(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionEnd);

	switch (aMode)
	{
	case TextEditor::SelectionMode::Normal:
	case TextEditor::SelectionMode::Word:
		break;
	case TextEditor::SelectionMode::Line:
	{
		const auto lineNo = mState.mCursors[aCursor].mSelectionEnd.mLine;
		const auto lineSize = (size_t)lineNo < mLines.size() ? mLines[lineNo].size() : 0;
		mState.mCursors[aCursor].mSelectionStart = Coordinates(mState.mCursors[aCursor].mSelectionStart.mLine, 0);
		mState.mCursors[aCursor].mSelectionEnd = (int)mLines.size() > lineNo + 1 ? Coordinates(lineNo + 1, 0) : Coordinates(lineNo, GetLineMaxColumn(lineNo));
		mState.mCursors[aCursor].mCursorPosition = mState.mCursors[aCursor].mSelectionEnd;
		break;
	}
	default:
		break;
	}

	if (mState.mCursors[aCursor].mSelectionStart != oldSelStart ||
		mState.mCursors[aCursor].mSelectionEnd != oldSelEnd)
		if (!isSpawningNewCursor)
			mState.mCursors[aCursor].mCursorPositionChanged = true;
}

void TextEditor::SetSelection(int aStartLine, int aStartCharIndex, int aEndLine, int aEndCharIndex, SelectionMode aMode, int aCursor, bool isSpawningNewCursor)
{
	SetSelection(
		{ aStartLine, GetCharacterColumn(aStartLine, aStartCharIndex) },
		{ aEndLine, GetCharacterColumn(aEndLine, aEndCharIndex) },
		aMode, aCursor, isSpawningNewCursor);
}

void TextEditor::SetTabSize(int aValue)
{
	mTabSize = std::max(0, std::min(32, aValue));
}

void TextEditor::InsertText(const std::string& aValue, int aCursor)
{
	InsertText(aValue.c_str(), aCursor);
}

void TextEditor::InsertText(const char* aValue, int aCursor)
{
	if (aValue == nullptr)
		return;
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	auto pos = GetActualCursorCoordinates(aCursor);
	auto start = std::min(pos, mState.mCursors[aCursor].mSelectionStart);
	int totalLines = pos.mLine - start.mLine;

	totalLines += InsertTextAt(pos, aValue);

	SetSelection(pos, pos, SelectionMode::Normal, aCursor);
	SetCursorPosition(pos, aCursor);
	Colorize(start.mLine - 1, totalLines + 2);
}

void TextEditor::DeleteSelection(int aCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	assert(mState.mCursors[aCursor].mSelectionEnd >= mState.mCursors[aCursor].mSelectionStart);

	if (mState.mCursors[aCursor].mSelectionEnd == mState.mCursors[aCursor].mSelectionStart)
		return;

	DeleteRange(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionEnd);

	SetSelection(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionStart, SelectionMode::Normal, aCursor);
	SetCursorPosition(mState.mCursors[aCursor].mSelectionStart, aCursor);
	mState.mCursors[aCursor].mInteractiveStart = mState.mCursors[aCursor].mSelectionStart;
	mState.mCursors[aCursor].mInteractiveEnd = mState.mCursors[aCursor].mSelectionEnd;
	Colorize(mState.mCursors[aCursor].mSelectionStart.mLine, 1);
}

void TextEditor::MoveUp(int aAmount, bool aSelect)
{
	if (HasSelection() && !aSelect)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			SetSelection(mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionStart, SelectionMode::Normal, c);
			SetCursorPosition(mState.mCursors[c].mSelectionStart);
		}
	}
	else
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			auto oldPos = mState.mCursors[c].mCursorPosition;
			mState.mCursors[c].mCursorPosition.mLine = std::max(0, mState.mCursors[c].mCursorPosition.mLine - aAmount);
			if (oldPos != mState.mCursors[c].mCursorPosition)
			{
				if (aSelect)
				{
					if (oldPos == mState.mCursors[c].mInteractiveStart)
						mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
					else if (oldPos == mState.mCursors[c].mInteractiveEnd)
						mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
					else
					{
						mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
						mState.mCursors[c].mInteractiveEnd = oldPos;
					}
				}
				else
					mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
				SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, SelectionMode::Normal, c);
			}
		}
	}
	EnsureCursorVisible();
}

void TextEditor::MoveDown(int aAmount, bool aSelect)
{
	if (HasSelection() && !aSelect)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			SetSelection(mState.mCursors[c].mSelectionEnd, mState.mCursors[c].mSelectionEnd, SelectionMode::Normal, c);
			SetCursorPosition(mState.mCursors[c].mSelectionEnd);
		}
	}
	else
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			assert(mState.mCursors[c].mCursorPosition.mColumn >= 0);
			auto oldPos = mState.mCursors[c].mCursorPosition;
			mState.mCursors[c].mCursorPosition.mLine = std::max(0, std::min((int)mLines.size() - 1, mState.mCursors[c].mCursorPosition.mLine + aAmount));

			if (mState.mCursors[c].mCursorPosition != oldPos)
			{
				if (aSelect)
				{
					if (oldPos == mState.mCursors[c].mInteractiveEnd)
						mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
					else if (oldPos == mState.mCursors[c].mInteractiveStart)
						mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
					else
					{
						mState.mCursors[c].mInteractiveStart = oldPos;
						mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
					}
				}
				else
					mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
				SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, SelectionMode::Normal, c);

			}
		}
	}
	EnsureCursorVisible();
}

static bool IsUTFSequence(char c)
{
	return (c & 0xC0) == 0x80;
}

void TextEditor::MoveLeft(int aAmount, bool aSelect, bool aWordMode)
{
	if (mLines.empty())
		return;

	if (HasSelection() && !aSelect && !aWordMode)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			SetSelection(mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionStart, SelectionMode::Normal, c);
			SetCursorPosition(mState.mCursors[c].mSelectionStart);
		}
	}
	else
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			int amount = aAmount;
			auto oldPos = mState.mCursors[c].mCursorPosition;
			mState.mCursors[c].mCursorPosition = GetActualCursorCoordinates(c);
			auto line = mState.mCursors[c].mCursorPosition.mLine;
			auto cindex = GetCharacterIndexR(mState.mCursors[c].mCursorPosition);

			while (amount-- > 0)
			{
				if (cindex == 0)
				{
					if (line > 0)
					{
						--line;
						if ((int)mLines.size() > line)
							cindex = (int)mLines[line].size();
						else
							cindex = 0;
					}
				}
				else
				{
					--cindex;
					if (cindex > 0)
					{
						if ((int)mLines.size() > line)
						{
							while (cindex > 0 && IsUTFSequence(mLines[line][cindex].mChar))
								--cindex;
						}
					}
				}

				mState.mCursors[c].mCursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
				if (aWordMode)
				{
					mState.mCursors[c].mCursorPosition = FindWordStart(mState.mCursors[c].mCursorPosition);
					cindex = GetCharacterIndexR(mState.mCursors[c].mCursorPosition);
				}
			}

			mState.mCursors[c].mCursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
			std::cout << "changed from " << oldPos.mColumn << " to " << mState.mCursors[c].mCursorPosition.mColumn << std::endl;

			assert(mState.mCursors[c].mCursorPosition.mColumn >= 0);
			if (aSelect)
			{
				if (oldPos == mState.mCursors[c].mInteractiveStart)
					mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
				else if (oldPos == mState.mCursors[c].mInteractiveEnd)
					mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
				else
				{
					mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
					mState.mCursors[c].mInteractiveEnd = oldPos;
				}
			}
			else
			{
				if (HasSelection() && !aWordMode)
					mState.mCursors[c].mCursorPosition = mState.mCursors[c].mInteractiveStart;
				mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
			}
			std::cout << "Setting selection for " << c << std::endl;
			SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, aSelect && aWordMode ? SelectionMode::Word : SelectionMode::Normal, c);
		}
	}
	EnsureCursorVisible();
}

void TextEditor::MoveRight(int aAmount, bool aSelect, bool aWordMode)
{
	if (mLines.empty())
		return;

	if (HasSelection() && !aSelect && !aWordMode)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			SetSelection(mState.mCursors[c].mSelectionEnd, mState.mCursors[c].mSelectionEnd, SelectionMode::Normal, c);
			SetCursorPosition(mState.mCursors[c].mSelectionEnd);
		}
	}
	else
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			auto oldPos = mState.mCursors[c].mCursorPosition;
			if (oldPos.mLine >= (int)mLines.size())
				continue;

			int amount = aAmount;
			auto cindex = GetCharacterIndexR(mState.mCursors[c].mCursorPosition);
			while (amount-- > 0)
			{
				auto lindex = mState.mCursors[c].mCursorPosition.mLine;
				auto& line = mLines[lindex];

				if (cindex >= (int)line.size())
				{
					if (mState.mCursors[c].mCursorPosition.mLine < (int)mLines.size() - 1)
					{
						mState.mCursors[c].mCursorPosition.mLine = std::max(0, std::min((int)mLines.size() - 1, mState.mCursors[c].mCursorPosition.mLine + 1));
						mState.mCursors[c].mCursorPosition.mColumn = 0;
					}
					else
						continue;
				}
				else
				{
					cindex += UTF8CharLength(line[cindex].mChar);
					mState.mCursors[c].mCursorPosition = Coordinates(lindex, GetCharacterColumn(lindex, cindex));
					if (aWordMode)
						mState.mCursors[c].mCursorPosition = FindWordEnd(mState.mCursors[c].mCursorPosition);
				}
			}

			if (aSelect)
			{
				if (oldPos == mState.mCursors[c].mInteractiveEnd)
					mState.mCursors[c].mInteractiveEnd = SanitizeCoordinates(mState.mCursors[c].mCursorPosition);
				else if (oldPos == mState.mCursors[c].mInteractiveStart)
					mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
				else
				{
					mState.mCursors[c].mInteractiveStart = oldPos;
					mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
				}
			}
			else
			{
				if (HasSelection() && !aWordMode)
					mState.mCursors[c].mCursorPosition = mState.mCursors[c].mInteractiveEnd;
				mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
			}
			SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, aSelect && aWordMode ? SelectionMode::Word : SelectionMode::Normal, c);
		}
	}
	EnsureCursorVisible();
}

void TextEditor::MoveTop(bool aSelect)
{
	mState.mCurrentCursor = 0;
	auto oldPos = mState.mCursors[mState.mCurrentCursor].mCursorPosition;
	SetCursorPosition(Coordinates(0, 0));

	if (mState.mCursors[mState.mCurrentCursor].mCursorPosition != oldPos)
	{
		if (aSelect)
		{
			mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = oldPos;
			mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mCursorPosition;
		}
		else
			mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = mState.mCursors[mState.mCurrentCursor].mCursorPosition;
		SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd);
	}
}

void TextEditor::TextEditor::MoveBottom(bool aSelect)
{
	mState.mCurrentCursor = 0;
	auto oldPos = GetCursorPosition();
	auto newPos = Coordinates((int)mLines.size() - 1, 0);
	SetCursorPosition(newPos);
	if (aSelect)
	{
		mState.mCursors[mState.mCurrentCursor].mInteractiveStart = oldPos;
		mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = newPos;
	}
	else
		mState.mCursors[mState.mCurrentCursor].mInteractiveStart = mState.mCursors[mState.mCurrentCursor].mInteractiveEnd = newPos;
	SetSelection(mState.mCursors[mState.mCurrentCursor].mInteractiveStart, mState.mCursors[mState.mCurrentCursor].mInteractiveEnd);
}

void TextEditor::MoveHome(bool aSelect)
{
	for (int c = 0; c <= mState.mCurrentCursor; c++)
	{
		auto oldPos = mState.mCursors[c].mCursorPosition;
		SetCursorPosition(Coordinates(mState.mCursors[c].mCursorPosition.mLine, 0), c);

		if (aSelect)
		{
			if (oldPos == mState.mCursors[c].mInteractiveStart)
				mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
			else if (oldPos == mState.mCursors[c].mInteractiveEnd)
				mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
			else
			{
				mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
				mState.mCursors[c].mInteractiveEnd = oldPos;
			}
		}
		else
			mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
		SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, SelectionMode::Normal, c);
	}
}

void TextEditor::MoveEnd(bool aSelect)
{
	for (int c = 0; c <= mState.mCurrentCursor; c++)
	{
		auto oldPos = mState.mCursors[c].mCursorPosition;
		SetCursorPosition(Coordinates(mState.mCursors[c].mCursorPosition.mLine, GetLineMaxColumn(oldPos.mLine)), c);

		if (aSelect)
		{
			if (oldPos == mState.mCursors[c].mInteractiveEnd)
				mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
			else if (oldPos == mState.mCursors[c].mInteractiveStart)
				mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mCursorPosition;
			else
			{
				mState.mCursors[c].mInteractiveStart = oldPos;
				mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
			}
		}
		else
			mState.mCursors[c].mInteractiveStart = mState.mCursors[c].mInteractiveEnd = mState.mCursors[c].mCursorPosition;
		SetSelection(mState.mCursors[c].mInteractiveStart, mState.mCursors[c].mInteractiveEnd, SelectionMode::Normal, c);
	}
}

void TextEditor::Delete(bool aWordMode)
{
	assert(!mReadOnly);

	if (mLines.empty())
		return;

	UndoRecord u;
	u.mBefore = mState;

	if (HasSelection())
	{
		for (int c = mState.mCurrentCursor; c > -1; c--)
		{
			u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
			DeleteSelection(c);
		}
	}
	else
	{
		std::vector<Coordinates> positions;
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			auto pos = GetActualCursorCoordinates(c);
			positions.push_back(pos);
			SetCursorPosition(pos, c);
			auto& line = mLines[pos.mLine];

			if (pos.mColumn == GetLineMaxColumn(pos.mLine))
			{
				if (pos.mLine == (int)mLines.size() - 1)
					continue;

				Coordinates startCoords = GetActualCursorCoordinates(c);
				Coordinates endCoords = startCoords;
				Advance(endCoords);
				u.mOperations.push_back({ "\n", startCoords, endCoords, UndoOperationType::Delete });

				auto& nextLine = mLines[pos.mLine + 1];
				AddGlyphsToLine(pos.mLine, line.size(), nextLine.begin(), nextLine.end());
				for (int otherCursor = c + 1;
					otherCursor <= mState.mCurrentCursor && mState.mCursors[otherCursor].mCursorPosition.mLine == pos.mLine + 1;
					otherCursor++) // move up cursors in next line
				{
					int otherCursorCharIndex = GetCharacterIndexR(mState.mCursors[otherCursor].mCursorPosition);
					int otherCursorNewCharIndex = GetCharacterIndexR(pos) + otherCursorCharIndex;
					auto targetCoords = Coordinates(pos.mLine, GetCharacterColumn(pos.mLine, otherCursorNewCharIndex));
					SetCursorPosition(targetCoords, otherCursor);
				}
				RemoveLine(pos.mLine + 1);
			}
			else
			{
				if (aWordMode)
				{
					Coordinates end = FindWordEnd(mState.mCursors[c].mCursorPosition);
					u.mOperations.push_back({ GetText(mState.mCursors[c].mCursorPosition, end),  mState.mCursors[c].mCursorPosition , end, UndoOperationType::Delete });
					DeleteRange(mState.mCursors[c].mCursorPosition, end);
					int charactersDeleted = end.mColumn - mState.mCursors[c].mCursorPosition.mColumn;
				}
				else
				{
					auto cindex = GetCharacterIndexR(pos);

					Coordinates start = GetActualCursorCoordinates(c);
					Coordinates end = start;
					end.mColumn++;
					u.mOperations.push_back({ GetText(start, end), start, end, UndoOperationType::Delete });

					auto d = UTF8CharLength(line[cindex].mChar);
					while (d-- > 0 && cindex < (int)line.size())
						RemoveGlyphsFromLine(pos.mLine, cindex, cindex + 1);
				}
			}
		}

		mTextChanged = true;

		for (const auto& pos : positions)
			Colorize(pos.mLine, 1);
	}

	u.mAfter = mState;
	AddUndo(u);
}

void TextEditor::Backspace(bool aWordMode)
{
	assert(!mReadOnly);

	if (mLines.empty())
		return;

	UndoRecord u;
	u.mBefore = mState;

	if (HasSelection())
	{
		for (int c = mState.mCurrentCursor; c > -1; c--)
		{
			u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
			DeleteSelection(c);
		}
	}
	else
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			auto pos = GetActualCursorCoordinates(c);
			SetCursorPosition(pos, c);

			if (mState.mCursors[c].mCursorPosition.mColumn == 0)
			{
				if (mState.mCursors[c].mCursorPosition.mLine == 0)
					continue;

				Coordinates startCoords = Coordinates(pos.mLine - 1, GetLineMaxColumn(pos.mLine - 1));
				Coordinates endCoords = startCoords;
				Advance(endCoords);
				u.mOperations.push_back({ "\n", startCoords, endCoords, UndoOperationType::Delete });

				auto& line = mLines[mState.mCursors[c].mCursorPosition.mLine];
				int prevLineIndex = mState.mCursors[c].mCursorPosition.mLine - 1;
				auto& prevLine = mLines[prevLineIndex];
				auto prevSize = GetLineMaxColumn(prevLineIndex);
				AddGlyphsToLine(prevLineIndex, prevLine.size(), line.begin(), line.end());
				std::unordered_set<int> cursorsHandled = { c };
				for (int otherCursor = c + 1;
					otherCursor <= mState.mCurrentCursor && mState.mCursors[otherCursor].mCursorPosition.mLine == mState.mCursors[c].mCursorPosition.mLine;
					otherCursor++) // move up cursors in same line
				{
					int otherCursorCharIndex = GetCharacterIndexR(mState.mCursors[otherCursor].mCursorPosition);
					int otherCursorNewCharIndex = GetCharacterIndexR({ prevLineIndex, prevSize }) + otherCursorCharIndex;
					auto targetCoords = Coordinates(prevLineIndex, GetCharacterColumn(prevLineIndex, otherCursorNewCharIndex));
					SetCursorPosition(targetCoords, otherCursor);
					cursorsHandled.insert(otherCursor);
				}

				ErrorMarkers etmp;
				for (auto& i : mErrorMarkers)
					etmp.insert(ErrorMarkers::value_type(i.first - 1 == mState.mCursors[c].mCursorPosition.mLine ? i.first - 1 : i.first, i.second));
				mErrorMarkers = std::move(etmp);

				RemoveLine(mState.mCursors[c].mCursorPosition.mLine, &cursorsHandled);
				SetCursorPosition({ mState.mCursors[c].mCursorPosition.mLine - 1, prevSize }, c);
			}
			else
			{
				auto& line = mLines[mState.mCursors[c].mCursorPosition.mLine];

				if (aWordMode)
				{
					Coordinates start = FindWordStart(mState.mCursors[c].mCursorPosition - Coordinates(0, 1));
					u.mOperations.push_back({ GetText(start, mState.mCursors[c].mCursorPosition) , start, mState.mCursors[c].mCursorPosition, UndoOperationType::Delete });
					DeleteRange(start, mState.mCursors[c].mCursorPosition);
					int charactersDeleted = mState.mCursors[c].mCursorPosition.mColumn - start.mColumn;
					mState.mCursors[c].mCursorPosition.mColumn -= charactersDeleted;
				}
				else
				{
					auto cindex = GetCharacterIndexR(pos) - 1;
					auto cend = cindex + 1;
					while (cindex > 0 && IsUTFSequence(line[cindex].mChar))
						--cindex;

					//if (cindex > 0 && UTF8CharLength(line[cindex].mChar) > 1)
					//	--cindex;

					UndoOperation removed;
					removed.mType = UndoOperationType::Delete;
					removed.mStart = removed.mEnd = GetActualCursorCoordinates(c);

					if (line[cindex].mChar == '\t')
					{
						int tabStartColumn = GetCharacterColumn(removed.mStart.mLine, cindex);
						int tabLength = removed.mStart.mColumn - tabStartColumn;
						mState.mCursors[c].mCursorPosition.mColumn -= tabLength;
						removed.mStart.mColumn -= tabLength;
					}
					else
					{
						--mState.mCursors[c].mCursorPosition.mColumn;
						--removed.mStart.mColumn;
					}

					while (cindex < (int)line.size() && cend-- > cindex)
					{
						removed.mText += line[cindex].mChar;
						RemoveGlyphsFromLine(mState.mCursors[c].mCursorPosition.mLine, cindex, cindex + 1);
					}
					u.mOperations.push_back(removed);
				}
				mState.mCursors[c].mCursorPositionChanged = true;
			}
		}

		mTextChanged = true;

		EnsureCursorVisible();
		for (int c = 0; c <= mState.mCurrentCursor; c++)
			Colorize(mState.mCursors[c].mCursorPosition.mLine, 1);
	}

	u.mAfter = mState;
	AddUndo(u);
}

void TextEditor::SelectWordUnderCursor()
{
	auto c = GetCursorPosition();
	SetSelection(FindWordStart(c), FindWordEnd(c));
}

void TextEditor::SelectAll()
{
	SetSelection(Coordinates(0, 0), Coordinates((int)mLines.size(), 0), SelectionMode::Line);
}

bool TextEditor::HasSelection() const
{
	for (int c = 0; c <= mState.mCurrentCursor; c++)
		if (mState.mCursors[c].mSelectionEnd > mState.mCursors[c].mSelectionStart)
			return true;
	return false;
}

void TextEditor::Copy()
{
	if (HasSelection())
	{
		std::string clipboardText = GetClipboardText();
		ImGui::SetClipboardText(clipboardText.c_str());
	}
	else
	{
		if (!mLines.empty())
		{
			std::string str;
			auto& line = mLines[GetActualCursorCoordinates().mLine];
			for (auto& g : line)
				str.push_back(g.mChar);
			ImGui::SetClipboardText(str.c_str());
		}
	}
}

void TextEditor::Cut()
{
	if (IsReadOnly())
	{
		Copy();
	}
	else
	{
		if (HasSelection())
		{
			UndoRecord u;
			u.mBefore = mState;

			Copy();
			for (int c = mState.mCurrentCursor; c > -1; c--)
			{
				u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
				DeleteSelection(c);
			}

			u.mAfter = mState;
			AddUndo(u);
		}
	}
}

void TextEditor::Paste()
{
	if (IsReadOnly())
		return;

	// check if we should do multicursor paste
	std::string clipText = ImGui::GetClipboardText();
	bool canPasteToMultipleCursors = false;
	std::vector<std::pair<int, int>> clipTextLines;
	if (mState.mCurrentCursor > 0)
	{
		clipTextLines.push_back({ 0,0 });
		for (int i = 0; i < (int)clipText.length(); i++)
		{
			if (clipText[i] == '\n')
			{
				clipTextLines.back().second = i;
				clipTextLines.push_back({ i + 1, 0 });
			}
		}
		clipTextLines.back().second = clipText.length();
		canPasteToMultipleCursors = clipTextLines.size() == mState.mCurrentCursor + 1;
	}

	if (clipText.length() > 0)
	{
		UndoRecord u;
		u.mBefore = mState;

		if (HasSelection())
		{
			for (int c = mState.mCurrentCursor; c > -1; c--)
			{
				u.mOperations.push_back({ GetSelectedText(c), mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd, UndoOperationType::Delete });
				DeleteSelection(c);
			}
		}

		for (int c = mState.mCurrentCursor; c > -1; c--)
		{
			Coordinates start = GetActualCursorCoordinates(c);
			if (canPasteToMultipleCursors)
			{
				std::string clipSubText = clipText.substr(clipTextLines[c].first, clipTextLines[c].second - clipTextLines[c].first);
				InsertText(clipSubText, c);
				u.mOperations.push_back({ clipSubText, start, GetActualCursorCoordinates(c), UndoOperationType::Add });
			}
			else
			{
				InsertText(clipText, c);
				u.mOperations.push_back({ clipText, start, GetActualCursorCoordinates(c), UndoOperationType::Add });
			}
		}

		u.mAfter = mState;
		AddUndo(u);
	}
}

bool TextEditor::CanUndo() const
{
	return !mReadOnly && mUndoIndex > 0;
}

bool TextEditor::CanRedo() const
{
	return !mReadOnly && mUndoIndex < (int)mUndoBuffer.size();
}

void TextEditor::Undo(int aSteps)
{
	while (CanUndo() && aSteps-- > 0)
		mUndoBuffer[--mUndoIndex].Undo(this);
}

void TextEditor::Redo(int aSteps)
{
	while (CanRedo() && aSteps-- > 0)
		mUndoBuffer[mUndoIndex++].Redo(this);
}

const TextEditor::Palette& TextEditor::GetDarkPalette()
{
	const static Palette p = { {
			0xb0b0b0ff,	// Default
			0x569cd6ff,	// Keyword
			0x00ff00ff,	// Number
			0xe07070ff,	// String
			0xe0a070ff, // Char literal
			0xffffffff, // Punctuation
			0x808040ff,	// Preprocessor
			0xaaaaaaff, // Identifier
			0x4dc69bff, // Known identifier
			0xa040c0ff, // Preproc identifier
			0x206020ff, // Comment (single line)
			0x206040ff, // Comment (multi line)
			0x101010ff, // Background
			0xe0e0e0ff, // Cursor
			0x2060a080, // Selection
			0xff200080, // ErrorMarker
			0x90909090, // ControlCharacter
			0x0080f040, // Breakpoint
			0x007070ff, // Line number
			0x00000040, // Current line fill
			0x80808040, // Current line fill (inactive)
			0xa0a0a040, // Current line edge
		} };
	return p;
}

const TextEditor::Palette& TextEditor::GetMarianaPalette()
{
	const static Palette p = { {
			0xffffffff,	// Default
			0xc695c6ff,	// Keyword
			0xf9ae58ff,	// Number
			0x99c794ff,	// String
			0xe0a070ff, // Char literal
			0x5fb4b4ff, // Punctuation
			0x808040ff,	// Preprocessor
			0xffffffff, // Identifier
			0x4dc69bff, // Known identifier
			0xe0a0ffff, // Preproc identifier
			0xa6acb9ff, // Comment (single line)
			0xa6acb9ff, // Comment (multi line)
			0x303841ff, // Background
			0xe0e0e0ff, // Cursor
			0x4e5a6580, // Selection
			0xec5f6680, // ErrorMarker
			0xffffff30, // ControlCharacter
			0x0080f040, // Breakpoint
			0xffffffb0, // Line number
			0x4e5a6580, // Current line fill
			0x4e5a6530, // Current line fill (inactive)
			0x4e5a65b0, // Current line edge
		} };
	return p;
}

const TextEditor::Palette& TextEditor::GetLightPalette()
{
	const static Palette p = { {
			0x404040ff,	// None
			0x060cffff,	// Keyword	
			0x008000ff,	// Number
			0xa02020ff,	// String
			0x704030ff, // Char literal
			0x000000ff, // Punctuation
			0x606040ff,	// Preprocessor
			0x404040ff, // Identifier
			0x106060ff, // Known identifier
			0xa040c0ff, // Preproc identifier
			0x205020ff, // Comment (single line)
			0x205040ff, // Comment (multi line)
			0xffffffff, // Background
			0x000000ff, // Cursor
			0x00006040, // Selection
			0xff1000a0, // ErrorMarker
			0x90909090, // ControlCharacter
			0x0080f080, // Breakpoint
			0x005050ff, // Line number
			0x00000040, // Current line fill
			0x80808040, // Current line fill (inactive)
			0x00000040, // Current line edge
		} };
	return p;
}

const TextEditor::Palette& TextEditor::GetRetroBluePalette()
{
	const static Palette p = { {
			0xffff00ff,	// None
			0x00ffffff,	// Keyword	
			0x00ff00ff,	// Number
			0x008080ff,	// String
			0x008080ff, // Char literal
			0xffffffff, // Punctuation
			0x008000ff,	// Preprocessor
			0xffff00ff, // Identifier
			0xffffffff, // Known identifier
			0xff00ffff, // Preproc identifier
			0x808080ff, // Comment (single line)
			0x404040ff, // Comment (multi line)
			0x000080ff, // Background
			0xff8000ff, // Cursor
			0x00ffff80, // Selection
			0xff0000a0, // ErrorMarker
			0x0080ff80, // Breakpoint
			0x008080ff, // Line number
			0x00000040, // Current line fill
			0x80808040, // Current line fill (inactive)
			0x00000040, // Current line edge
		} };
	return p;
}

void TextEditor::MergeCursorsIfPossible()
{
	// requires the cursors to be sorted from top to bottom
	std::unordered_set<int> cursorsToDelete;
	if (HasSelection())
	{
		// merge cursors if they overlap
		for (int c = mState.mCurrentCursor; c > 0; c--)// iterate backwards through pairs
		{
			int pc = c - 1;

			bool pcContainsC = mState.mCursors[pc].mSelectionEnd >= mState.mCursors[c].mSelectionEnd;
			bool pcContainsStartOfC = mState.mCursors[pc].mSelectionEnd >= mState.mCursors[c].mSelectionStart;

			if (pcContainsC)
			{
				cursorsToDelete.insert(c);
			}
			else if (pcContainsStartOfC)
			{
				mState.mCursors[pc].mSelectionEnd = mState.mCursors[c].mSelectionEnd;
				mState.mCursors[pc].mInteractiveEnd = mState.mCursors[c].mSelectionEnd;
				mState.mCursors[pc].mInteractiveStart = mState.mCursors[pc].mSelectionStart;
				mState.mCursors[pc].mCursorPosition = mState.mCursors[c].mSelectionEnd;
				cursorsToDelete.insert(c);
			}
		}
	}
	else
	{
		// merge cursors if they are at the same position
		for (int c = mState.mCurrentCursor; c > 0; c--)// iterate backwards through pairs
		{
			int pc = c - 1;
			if (mState.mCursors[pc].mCursorPosition == mState.mCursors[c].mCursorPosition)
				cursorsToDelete.insert(c);
		}
	}
	for (int c = mState.mCurrentCursor; c > -1; c--)// iterate backwards through each of them
	{
		if (cursorsToDelete.find(c) != cursorsToDelete.end())
			mState.mCursors.erase(mState.mCursors.begin() + c);
	}
	mState.mCurrentCursor -= cursorsToDelete.size();
}


std::string TextEditor::GetText() const
{
	auto lastLine = (int)mLines.size() - 1;
	auto lastLineLength = GetLineMaxColumn(lastLine);
	return GetText(Coordinates(), Coordinates(lastLine, lastLineLength));
}

std::vector<std::string> TextEditor::GetTextLines() const
{
	std::vector<std::string> result;

	result.reserve(mLines.size());

	for (auto& line : mLines)
	{
		std::string text;

		text.resize(line.size());

		for (size_t i = 0; i < line.size(); ++i)
			text[i] = line[i].mChar;

		result.emplace_back(std::move(text));
	}

	return result;
}

std::string TextEditor::GetClipboardText() const
{
	std::string result;
	for (int c = 0; c <= mState.mCurrentCursor; c++)
	{
		if (mState.mCursors[c].mSelectionStart < mState.mCursors[c].mSelectionEnd)
		{
			if (result.length() != 0)
				result += '\n';
			result += GetText(mState.mCursors[c].mSelectionStart, mState.mCursors[c].mSelectionEnd);
		}
	}
	return result;
}

std::string TextEditor::GetSelectedText(int aCursor) const
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	return GetText(mState.mCursors[aCursor].mSelectionStart, mState.mCursors[aCursor].mSelectionEnd);
}

std::string TextEditor::GetCurrentLineText()const
{
	auto lineLength = GetLineMaxColumn(mState.mCursors[mState.mCurrentCursor].mCursorPosition.mLine);
	return GetText(
		Coordinates(mState.mCursors[mState.mCurrentCursor].mCursorPosition.mLine, 0),
		Coordinates(mState.mCursors[mState.mCurrentCursor].mCursorPosition.mLine, lineLength));
}

void TextEditor::ProcessInputs()
{
}

void TextEditor::Colorize(int aFromLine, int aLines)
{
	int toLine = aLines == -1 ? (int)mLines.size() : std::min((int)mLines.size(), aFromLine + aLines);
	mColorRangeMin = std::min(mColorRangeMin, aFromLine);
	mColorRangeMax = std::max(mColorRangeMax, toLine);
	mColorRangeMin = std::max(0, mColorRangeMin);
	mColorRangeMax = std::max(mColorRangeMin, mColorRangeMax);
	mCheckComments = true;
}

void TextEditor::ColorizeRange(int aFromLine, int aToLine)
{
	if (mLines.empty() || aFromLine >= aToLine || mLanguageDefinition == nullptr)
		return;

	std::string buffer;
	std::cmatch results;
	std::string id;

	int endLine = std::max(0, std::min((int)mLines.size(), aToLine));
	for (int i = aFromLine; i < endLine; ++i)
	{
		auto& line = mLines[i];

		if (line.empty())
			continue;

		buffer.resize(line.size());
		for (size_t j = 0; j < line.size(); ++j)
		{
			auto& col = line[j];
			buffer[j] = col.mChar;
			col.mColorIndex = PaletteIndex::Default;
		}

		const char* bufferBegin = &buffer.front();
		const char* bufferEnd = bufferBegin + buffer.size();

		auto last = bufferEnd;

		for (auto first = bufferBegin; first != last; )
		{
			const char* token_begin = nullptr;
			const char* token_end = nullptr;
			PaletteIndex token_color = PaletteIndex::Default;

			bool hasTokenizeResult = false;

			if (mLanguageDefinition->mTokenize != nullptr)
			{
				if (mLanguageDefinition->mTokenize(first, last, token_begin, token_end, token_color))
					hasTokenizeResult = true;
			}

			if (hasTokenizeResult == false)
			{
				// todo : remove
				//printf("using regex for %.*s\n", first + 10 < last ? 10 : int(last - first), first);

				for (const auto& p : mRegexList)
				{
					if (std::regex_search(first, last, results, p.first, std::regex_constants::match_continuous))
					{
						hasTokenizeResult = true;

						auto& v = *results.begin();
						token_begin = v.first;
						token_end = v.second;
						token_color = p.second;
						break;
					}
				}
			}

			if (hasTokenizeResult == false)
			{
				first++;
			}
			else
			{
				const size_t token_length = token_end - token_begin;

				if (token_color == PaletteIndex::Identifier)
				{
					id.assign(token_begin, token_end);

					// todo : allmost all language definitions use lower case to specify keywords, so shouldn't this use ::tolower ?
					if (!mLanguageDefinition->mCaseSensitive)
						std::transform(id.begin(), id.end(), id.begin(), ::toupper);

					if (!line[first - bufferBegin].mPreprocessor)
					{
						if (mLanguageDefinition->mKeywords.count(id) != 0)
							token_color = PaletteIndex::Keyword;
						else if (mLanguageDefinition->mIdentifiers.count(id) != 0)
							token_color = PaletteIndex::KnownIdentifier;
						else if (mLanguageDefinition->mPreprocIdentifiers.count(id) != 0)
							token_color = PaletteIndex::PreprocIdentifier;
					}
					else
					{
						if (mLanguageDefinition->mPreprocIdentifiers.count(id) != 0)
							token_color = PaletteIndex::PreprocIdentifier;
					}
				}

				for (size_t j = 0; j < token_length; ++j)
					line[(token_begin - bufferBegin) + j].mColorIndex = token_color;

				first = token_end;
			}
		}
	}
}

void TextEditor::ColorizeInternal()
{
	if (mLines.empty() || !mColorizerEnabled || mLanguageDefinition == nullptr)
		return;

	if (mCheckComments)
	{
		auto endLine = mLines.size();
		auto endIndex = 0;
		auto commentStartLine = endLine;
		auto commentStartIndex = endIndex;
		auto withinString = false;
		auto withinSingleLineComment = false;
		auto withinPreproc = false;
		auto firstChar = true;			// there is no other non-whitespace characters in the line before
		auto concatenate = false;		// '\' on the very end of the line
		auto currentLine = 0;
		auto currentIndex = 0;
		while (currentLine < (int)endLine || currentIndex < endIndex)
		{
			auto& line = mLines[currentLine];

			if (currentIndex == 0 && !concatenate)
			{
				withinSingleLineComment = false;
				withinPreproc = false;
				firstChar = true;
			}

			concatenate = false;

			if (!line.empty())
			{
				auto& g = line[currentIndex];
				auto c = g.mChar;

				if (c != mLanguageDefinition->mPreprocChar && !isspace(c))
					firstChar = false;

				if (currentIndex == (int)line.size() - 1 && line[line.size() - 1].mChar == '\\')
					concatenate = true;

				bool inComment = ((int)commentStartLine < currentLine || ((int)commentStartLine == currentLine && commentStartIndex <= currentIndex));

				if (withinString)
				{
					line[currentIndex].mMultiLineComment = inComment;

					if (c == '\"')
					{
						if (currentIndex + 1 < (int)line.size() && line[currentIndex + 1].mChar == '\"')
						{
							currentIndex += 1;
							if (currentIndex < (int)line.size())
								line[currentIndex].mMultiLineComment = inComment;
						}
						else
							withinString = false;
					}
					else if (c == '\\')
					{
						currentIndex += 1;
						if (currentIndex < (int)line.size())
							line[currentIndex].mMultiLineComment = inComment;
					}
				}
				else
				{
					if (firstChar && c == mLanguageDefinition->mPreprocChar)
						withinPreproc = true;

					if (c == '\"')
					{
						withinString = true;
						line[currentIndex].mMultiLineComment = inComment;
					}
					else
					{
						auto pred = [](const char& a, const Glyph& b) { return a == b.mChar; };
						auto from = line.begin() + currentIndex;
						auto& startStr = mLanguageDefinition->mCommentStart;
						auto& singleStartStr = mLanguageDefinition->mSingleLineComment;

						if (!withinSingleLineComment && currentIndex + startStr.size() <= line.size() &&
							equals(startStr.begin(), startStr.end(), from, from + startStr.size(), pred))
						{
							commentStartLine = currentLine;
							commentStartIndex = currentIndex;
						}
						else if (singleStartStr.size() > 0 &&
							currentIndex + singleStartStr.size() <= line.size() &&
							equals(singleStartStr.begin(), singleStartStr.end(), from, from + singleStartStr.size(), pred))
						{
							withinSingleLineComment = true;
						}

						inComment = ((int)commentStartLine < currentLine || (commentStartLine == currentLine && commentStartIndex <= currentIndex));

						line[currentIndex].mMultiLineComment = inComment;
						line[currentIndex].mComment = withinSingleLineComment;

						auto& endStr = mLanguageDefinition->mCommentEnd;
						if (currentIndex + 1 >= (int)endStr.size() &&
							equals(endStr.begin(), endStr.end(), from + 1 - endStr.size(), from + 1, pred))
						{
							commentStartIndex = endIndex;
							commentStartLine = endLine;
						}
					}
				}
				if (currentIndex < (int)line.size())
					line[currentIndex].mPreprocessor = withinPreproc;
				currentIndex += UTF8CharLength(c);
				if (currentIndex >= (int)line.size())
				{
					currentIndex = 0;
					++currentLine;
				}
			}
			else
			{
				currentIndex = 0;
				++currentLine;
			}
		}
		mCheckComments = false;
	}

	if (mColorRangeMin < mColorRangeMax)
	{
		const int increment = (mLanguageDefinition->mTokenize == nullptr) ? 10 : 10000;
		const int to = std::min(mColorRangeMin + increment, mColorRangeMax);
		ColorizeRange(mColorRangeMin, to);
		mColorRangeMin = to;

		if (mColorRangeMax == mColorRangeMin)
		{
			mColorRangeMin = std::numeric_limits<int>::max();
			mColorRangeMax = 0;
		}
		return;
	}
}

float TextEditor::TextDistanceToLineStart(const Coordinates& aFrom) const
{
	auto& line = mLines[aFrom.mLine];
	float distance = 0.0f;
	float spaceSize = ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr).x;
	int colIndex = GetCharacterIndexR(aFrom);
	for (size_t it = 0u; it < line.size() && (int)it < colIndex; )
	{
		if (line[it].mChar == '\t')
		{
			distance = (1.0f + std::floor((1.0f + distance) / (float(mTabSize) * spaceSize))) * (float(mTabSize) * spaceSize);
			++it;
		}
		else
		{
			auto d = UTF8CharLength(line[it].mChar);
			char tempCString[7];
			int i = 0;
			for (; i < 6 && d-- > 0 && it < (int)line.size(); i++, it++)
				tempCString[i] = line[it].mChar;

			tempCString[i] = '\0';
			distance += ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, tempCString, nullptr, nullptr).x;
		}
	}

	return distance;
}

void TextEditor::EnsureCursorVisible(int aCursor)
{
	if (aCursor == -1)
		aCursor = mState.mCurrentCursor;

	if (!mWithinRender)
	{
		mScrollToCursor = true;
		return;
	}

	float scrollX = ImGui::GetScrollX();
	float scrollY = ImGui::GetScrollY();

	auto height = ImGui::GetWindowHeight();
	auto width = ImGui::GetWindowWidth();

	auto top = 1 + (int)ceil(scrollY / mCharAdvance.y);
	auto bottom = (int)ceil((scrollY + height) / mCharAdvance.y);

	auto left = (int)ceil(scrollX / mCharAdvance.x);
	auto right = (int)ceil((scrollX + width) / mCharAdvance.x);

	auto pos = GetActualCursorCoordinates(aCursor);
	auto len = TextDistanceToLineStart(pos);

	if (pos.mLine < top)
		ImGui::SetScrollY(std::max(0.0f, (pos.mLine - 1) * mCharAdvance.y));
	if (pos.mLine > bottom - 4)
		ImGui::SetScrollY(std::max(0.0f, (pos.mLine + 4) * mCharAdvance.y - height));
	if (len + mTextStart < left + 4)
		ImGui::SetScrollX(std::max(0.0f, len + mTextStart - 4));
	if (len + mTextStart > right - 4)
		ImGui::SetScrollX(std::max(0.0f, len + mTextStart + 4 - width));
}

int TextEditor::GetPageSize() const
{
	auto height = ImGui::GetWindowHeight() - 20.0f;
	return (int)floor(height / mCharAdvance.y);
}

TextEditor::UndoRecord::UndoRecord(
	const std::vector<UndoOperation>& aOperations,
	TextEditor::EditorState& aBefore,
	TextEditor::EditorState& aAfter)
	: mOperations(aOperations)
	, mBefore(aBefore)
	, mAfter(aAfter)
{
	for (const UndoOperation& o : mOperations)
		assert(o.mStart <= o.mEnd);
}

void TextEditor::UndoRecord::Undo(TextEditor* aEditor)
{
	for (int i = mOperations.size() - 1; i > -1; i--)
	{
		const UndoOperation& operation = mOperations[i];
		if (!operation.mText.empty())
		{
			switch (operation.mType)
			{
			case UndoOperationType::Delete:
			{
				auto start = operation.mStart;
				aEditor->InsertTextAt(start, operation.mText.c_str());
				aEditor->Colorize(operation.mStart.mLine - 1, operation.mEnd.mLine - operation.mStart.mLine + 2);
				break;
			}
			case UndoOperationType::Add:
			{
				aEditor->DeleteRange(operation.mStart, operation.mEnd);
				aEditor->Colorize(operation.mStart.mLine - 1, operation.mEnd.mLine - operation.mStart.mLine + 2);
				break;
			}
			}
		}
	}

	aEditor->mState = mBefore;
	aEditor->EnsureCursorVisible();
}

void TextEditor::UndoRecord::Redo(TextEditor* aEditor)
{
	for (int i = 0; i < (int)mOperations.size(); i++)
	{
		const UndoOperation& operation = mOperations[i];
		if (!operation.mText.empty())
		{
			switch (operation.mType)
			{
			case UndoOperationType::Delete:
			{
				aEditor->DeleteRange(operation.mStart, operation.mEnd);
				aEditor->Colorize(operation.mStart.mLine - 1, operation.mEnd.mLine - operation.mStart.mLine + 1);
				break;
			}
			case UndoOperationType::Add:
			{
				auto start = operation.mStart;
				aEditor->InsertTextAt(start, operation.mText.c_str());
				aEditor->Colorize(operation.mStart.mLine - 1, operation.mEnd.mLine - operation.mStart.mLine + 1);
				break;
			}
			}
		}
	}

	aEditor->mState = mAfter;
	aEditor->EnsureCursorVisible();
}
```

`hack/deps/ImGui/editor/TextEditor.hpp`:

```hpp
#pragma once

#include <iostream>
#include <string>
#include <vector>
#include <array>
#include <memory>
#include <unordered_set>
#include <unordered_map>
#include <map>
#include <regex>
#include "imgui.h"

class IMGUI_API TextEditor
{
public:
	enum class PaletteIndex
	{
		Default,
		Keyword,
		Number,
		String,
		CharLiteral,
		Punctuation,
		Preprocessor,
		Identifier,
		KnownIdentifier,
		PreprocIdentifier,
		Comment,
		MultiLineComment,
		Background,
		Cursor,
		Selection,
		ErrorMarker,
		ControlCharacter,
		Breakpoint,
		LineNumber,
		CurrentLineFill,
		CurrentLineFillInactive,
		CurrentLineEdge,
		Max
	};

	enum class SelectionMode
	{
		Normal,
		Word,
		Line
	};

	struct Breakpoint
	{
		int mLine;
		bool mEnabled;
		std::string mCondition;

		Breakpoint()
			: mLine(-1)
			, mEnabled(false)
		{}
	};

	// Represents a character coordinate from the user's point of view,
	// i. e. consider an uniform grid (assuming fixed-width font) on the
	// screen as it is rendered, and each cell has its own coordinate, starting from 0.
	// Tabs are counted as [1..mTabSize] count empty spaces, depending on
	// how many space is necessary to reach the next tab stop.
	// For example, coordinate (1, 5) represents the character 'B' in a line "\tABC", when mTabSize = 4,
	// because it is rendered as "    ABC" on the screen.
	struct Coordinates
	{
		int mLine, mColumn;
		Coordinates() : mLine(0), mColumn(0) {}
		Coordinates(int aLine, int aColumn) : mLine(aLine), mColumn(aColumn)
		{
			assert(aLine >= 0);
			assert(aColumn >= 0);
		}
		static Coordinates Invalid() { static Coordinates invalid(-1, -1); return invalid; }

		bool operator ==(const Coordinates& o) const
		{
			return
				mLine == o.mLine &&
				mColumn == o.mColumn;
		}

		bool operator !=(const Coordinates& o) const
		{
			return
				mLine != o.mLine ||
				mColumn != o.mColumn;
		}

		bool operator <(const Coordinates& o) const
		{
			if (mLine != o.mLine)
				return mLine < o.mLine;
			return mColumn < o.mColumn;
		}

		bool operator >(const Coordinates& o) const
		{
			if (mLine != o.mLine)
				return mLine > o.mLine;
			return mColumn > o.mColumn;
		}

		bool operator <=(const Coordinates& o) const
		{
			if (mLine != o.mLine)
				return mLine < o.mLine;
			return mColumn <= o.mColumn;
		}

		bool operator >=(const Coordinates& o) const
		{
			if (mLine != o.mLine)
				return mLine > o.mLine;
			return mColumn >= o.mColumn;
		}

		Coordinates operator -(const Coordinates& o)
		{
			return Coordinates(mLine - o.mLine, mColumn - o.mColumn);
		}
	};

	struct Identifier
	{
		Coordinates mLocation;
		std::string mDeclaration;
	};

	typedef std::string String;
	typedef std::unordered_map<std::string, Identifier> Identifiers;
	typedef std::unordered_set<std::string> Keywords;
	typedef std::map<int, std::string> ErrorMarkers;
	typedef std::unordered_set<int> Breakpoints;
	typedef std::array<ImU32, (unsigned)PaletteIndex::Max> Palette;
	typedef uint8_t Char;

	struct Glyph
	{
		Char mChar;
		PaletteIndex mColorIndex = PaletteIndex::Default;
		bool mComment : 1;
		bool mMultiLineComment : 1;
		bool mPreprocessor : 1;

		Glyph(Char aChar, PaletteIndex aColorIndex) : mChar(aChar), mColorIndex(aColorIndex),
			mComment(false), mMultiLineComment(false), mPreprocessor(false) {}
	};

	typedef std::vector<Glyph> Line;
	typedef std::vector<Line> Lines;

	struct LanguageDefinition
	{
		typedef std::pair<std::string, PaletteIndex> TokenRegexString;
		typedef std::vector<TokenRegexString> TokenRegexStrings;
		typedef bool(*TokenizeCallback)(const char* in_begin, const char* in_end, const char*& out_begin, const char*& out_end, PaletteIndex& paletteIndex);

		std::string mName;
		Keywords mKeywords;
		Identifiers mIdentifiers;
		Identifiers mPreprocIdentifiers;
		std::string mCommentStart, mCommentEnd, mSingleLineComment;
		char mPreprocChar;
		bool mAutoIndentation;

		TokenizeCallback mTokenize;

		TokenRegexStrings mTokenRegexStrings;

		bool mCaseSensitive;

		LanguageDefinition()
			: mPreprocChar('#'), mAutoIndentation(true), mTokenize(nullptr), mCaseSensitive(true)
		{
		}

		static const LanguageDefinition& CPlusPlus();
		static const LanguageDefinition& HLSL();
		static const LanguageDefinition& GLSL();
		static const LanguageDefinition& Python();
		static const LanguageDefinition& C();
		static const LanguageDefinition& SQL();
		static const LanguageDefinition& AngelScript();
		static const LanguageDefinition& Lua();
		static const LanguageDefinition& CSharp();
		static const LanguageDefinition& ValveKeyValues();
	};

	enum class UndoOperationType { Add, Delete };
	struct UndoOperation
	{
		std::string mText;
		TextEditor::Coordinates mStart;
		TextEditor::Coordinates mEnd;
		UndoOperationType mType;
	};

	TextEditor();
	~TextEditor();

	void SetLanguageDefinition(const LanguageDefinition& aLanguageDef);
	const char* GetLanguageDefinitionName() const;

	const Palette& GetPalette() const { return mPaletteBase; }
	void SetPalette(const Palette& aValue);

	void SetErrorMarkers(const ErrorMarkers& aMarkers) { mErrorMarkers = aMarkers; }
	void SetBreakpoints(const Breakpoints& aMarkers) { mBreakpoints = aMarkers; }

	bool Render(const char* aTitle, bool aParentIsFocused = false, const ImVec2& aSize = ImVec2(), bool aBorder = false);
	void SetText(const std::string& aText);
	std::string GetText() const;

	void SetTextLines(const std::vector<std::string>& aLines);
	std::vector<std::string> GetTextLines() const;

	std::string GetClipboardText() const;
	std::string GetSelectedText(int aCursor = -1) const;
	std::string GetCurrentLineText()const;

	int GetTotalLines() const { return (int)mLines.size(); }
	bool IsOverwrite() const { return mOverwrite; }

	void SetReadOnly(bool aValue);
	bool IsReadOnly() const { return mReadOnly; }
	bool IsTextChanged() const { return mTextChanged; }

	void OnCursorPositionChanged(int aCursor);

	bool IsColorizerEnabled() const { return mColorizerEnabled; }
	void SetColorizerEnable(bool aValue);

	Coordinates GetCursorPosition() const { return GetActualCursorCoordinates(); }
	void SetCursorPosition(const Coordinates& aPosition, int aCursor = -1);
	void SetCursorPosition(int aLine, int aCharIndex, int aCursor = -1);

	inline void OnLineDeleted(int aLineIndex, const std::unordered_set<int>* aHandledCursors = nullptr)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			if (mState.mCursors[c].mCursorPosition.mLine >= aLineIndex)
			{
				if (aHandledCursors == nullptr || aHandledCursors->find(c) == aHandledCursors->end()) // move up if has not been handled already
					SetCursorPosition({ mState.mCursors[c].mCursorPosition.mLine - 1, mState.mCursors[c].mCursorPosition.mColumn }, c);
			}
		}
	}
	inline void OnLinesDeleted(int aFirstLineIndex, int aLastLineIndex)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			if (mState.mCursors[c].mCursorPosition.mLine >= aFirstLineIndex)
				SetCursorPosition({ mState.mCursors[c].mCursorPosition.mLine - (aLastLineIndex - aFirstLineIndex), mState.mCursors[c].mCursorPosition.mColumn }, c);
		}
	}
	inline void OnLineAdded(int aLineIndex)
	{
		for (int c = 0; c <= mState.mCurrentCursor; c++)
		{
			if (mState.mCursors[c].mCursorPosition.mLine >= aLineIndex)
				SetCursorPosition({ mState.mCursors[c].mCursorPosition.mLine + 1, mState.mCursors[c].mCursorPosition.mColumn }, c);
		}
	}

	inline void SetHandleMouseInputs(bool aValue) { mHandleMouseInputs = aValue; }
	inline bool IsHandleMouseInputsEnabled() const { return mHandleMouseInputs; }

	inline void SetHandleKeyboardInputs(bool aValue) { mHandleKeyboardInputs = aValue; }
	inline bool IsHandleKeyboardInputsEnabled() const { return mHandleKeyboardInputs; }

	inline void SetImGuiChildIgnored(bool aValue) { mIgnoreImGuiChild = aValue; }
	inline bool IsImGuiChildIgnored() const { return mIgnoreImGuiChild; }

	inline void SetShowWhitespaces(bool aValue) { mShowWhitespaces = aValue; }
	inline bool IsShowingWhitespaces() const { return mShowWhitespaces; }

	inline void SetShowShortTabGlyphs(bool aValue) { mShowShortTabGlyphs = aValue; }
	inline bool IsShowingShortTabGlyphs() const { return mShowShortTabGlyphs; }

	inline ImVec4 U32ColorToVec4(ImU32 in) {
		float s = 1.0f / 255.0f;
		return ImVec4(
			((in >> IM_COL32_A_SHIFT) & 0xFF) * s,
			((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
			((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
			((in >> IM_COL32_R_SHIFT) & 0xFF) * s);
	}

	void SetTabSize(int aValue);
	inline int GetTabSize() const { return mTabSize; }

	void InsertText(const std::string& aValue, int aCursor = -1);
	void InsertText(const char* aValue, int aCursor = -1);

	void MoveUp(int aAmount = 1, bool aSelect = false);
	void MoveDown(int aAmount = 1, bool aSelect = false);
	void MoveLeft(int aAmount = 1, bool aSelect = false, bool aWordMode = false);
	void MoveRight(int aAmount = 1, bool aSelect = false, bool aWordMode = false);
	void MoveTop(bool aSelect = false);
	void MoveBottom(bool aSelect = false);
	void MoveHome(bool aSelect = false);
	void MoveEnd(bool aSelect = false);

	void SetSelectionStart(const Coordinates& aPosition, int aCursor = -1);
	void SetSelectionEnd(const Coordinates& aPosition, int aCursor = -1);
	void SetSelection(const Coordinates& aStart, const Coordinates& aEnd, SelectionMode aMode = SelectionMode::Normal, int aCursor = -1, bool isSpawningNewCursor = false);
	void SetSelection(int aStartLine, int aStartCharIndex, int aEndLine, int aEndCharIndex, SelectionMode aMode = SelectionMode::Normal, int aCursor = -1, bool isSpawningNewCursor = false);
	void SelectWordUnderCursor();
	void SelectAll();
	bool HasSelection() const;

	void Copy();
	void Cut();
	void Paste();
	void Paste(const std::string& text);
	void Delete(bool aWordMode = false);

	bool CanUndo() const;
	bool CanRedo() const;
	void Undo(int aSteps = 1);
	void Redo(int aSteps = 1);

	static const Palette& GetMarianaPalette();
	static const Palette& GetDarkPalette();
	static const Palette& GetLightPalette();
	static const Palette& GetRetroBluePalette();

	static bool IsGlyphWordChar(const Glyph& aGlyph);

	void ImGuiDebugPanel(const std::string& panelName = "Debug");
	void UnitTests();
private:
	typedef std::vector<std::pair<std::regex, PaletteIndex>> RegexList;

	struct Cursor
	{
		Coordinates mCursorPosition = { 0, 0 };
		Coordinates mSelectionStart = { 0,0 };
		Coordinates mSelectionEnd = { 0,0 };
		Coordinates mInteractiveStart = { 0,0 };
		Coordinates mInteractiveEnd = { 0,0 };
		bool mCursorPositionChanged = false;
	};

	struct EditorState
	{
		int mCurrentCursor = 0;
		std::vector<Cursor> mCursors = { {{0,0}} };
		void AddCursor()
		{
			mCurrentCursor++;
			mCursors.resize(mCurrentCursor + 1);
		}
	};

	void MergeCursorsIfPossible();

	class UndoRecord
	{
	public:
		UndoRecord() {}
		~UndoRecord() {}

		UndoRecord(
			const std::vector<UndoOperation>& aOperations,
			TextEditor::EditorState& aBefore,
			TextEditor::EditorState& aAfter);

		void Undo(TextEditor* aEditor);
		void Redo(TextEditor* aEditor);

		std::vector<UndoOperation> mOperations;

		EditorState mBefore;
		EditorState mAfter;
	};

	typedef std::vector<UndoRecord> UndoBuffer;

	void ProcessInputs();
	void Colorize(int aFromLine = 0, int aCount = -1);
	void ColorizeRange(int aFromLine = 0, int aToLine = 0);
	void ColorizeInternal();
	float TextDistanceToLineStart(const Coordinates& aFrom) const;
	void EnsureCursorVisible(int aCursor = -1);
	int GetPageSize() const;
	std::string GetText(const Coordinates& aStart, const Coordinates& aEnd) const;
	Coordinates GetActualCursorCoordinates(int aCursor = -1) const;
	Coordinates SanitizeCoordinates(const Coordinates& aValue) const;
	void Advance(Coordinates& aCoordinates) const;
	void DeleteRange(const Coordinates& aStart, const Coordinates& aEnd);
	int InsertTextAt(Coordinates& aWhere, const char* aValue);
	void AddUndo(UndoRecord& aValue);
	Coordinates ScreenPosToCoordinates(const ImVec2& aPosition, bool aInsertionMode = false, bool* isOverLineNumber = nullptr) const;
	Coordinates FindWordStart(const Coordinates& aFrom) const;
	Coordinates FindWordEnd(const Coordinates& aFrom) const;
	Coordinates FindNextWord(const Coordinates& aFrom) const;
	int GetCharacterIndexL(const Coordinates& aCoordinates) const;
	int GetCharacterIndexR(const Coordinates& aCoordinates) const;
	int GetCharacterColumn(int aLine, int aIndex) const;
	int GetLineCharacterCount(int aLine) const;
	int GetLineMaxColumn(int aLine) const;
	bool IsOnWordBoundary(const Coordinates& aAt) const;
	void RemoveLines(int aStart, int aEnd);
	void RemoveLine(int aIndex, const std::unordered_set<int>* aHandledCursors = nullptr);
	void RemoveCurrentLines();
	void OnLineChanged(bool aBeforeChange, int aLine, int aColumn, int aCharCount, bool aDeleted);
	void RemoveGlyphsFromLine(int aLine, int aStartChar, int aEndChar = -1);
	void AddGlyphsToLine(int aLine, int aTargetIndex, Line::iterator aSourceStart, Line::iterator aSourceEnd);
	void AddGlyphToLine(int aLine, int aTargetIndex, Glyph aGlyph);
	Line& InsertLine(int aIndex);
	void ChangeCurrentLinesIndentation(bool aIncrease);
	void EnterCharacter(ImWchar aChar, bool aShift);
	void Backspace(bool aWordMode = false);
	void DeleteSelection(int aCursor = -1);
	std::string GetWordUnderCursor() const;
	std::string GetWordAt(const Coordinates& aCoords) const;
	ImU32 GetGlyphColor(const Glyph& aGlyph) const;

	void HandleKeyboardInputs(bool aParentIsFocused = false);
	void HandleMouseInputs();
	void UpdatePalette();
	void Render(bool aParentIsFocused = false);

	float mLineSpacing;
	Lines mLines;
	EditorState mState;
	UndoBuffer mUndoBuffer;
	int mUndoIndex;

	int mTabSize;
	bool mOverwrite;
	bool mReadOnly;
	bool mWithinRender;
	bool mScrollToCursor;
	bool mScrollToTop;
	bool mTextChanged;
	bool mColorizerEnabled;
	float mTextStart;                   // position (in pixels) where a code line starts relative to the left of the TextEditor.
	int  mLeftMargin;
	int mColorRangeMin, mColorRangeMax;
	SelectionMode mSelectionMode;
	bool mHandleKeyboardInputs;
	bool mHandleMouseInputs;
	bool mIgnoreImGuiChild;
	bool mShowWhitespaces;
	bool mShowShortTabGlyphs;
	bool mDraggingSelection = false;

	Palette mPaletteBase;
	Palette mPalette;
	const LanguageDefinition* mLanguageDefinition = nullptr;
	RegexList mRegexList;

	bool mCheckComments;
	Breakpoints mBreakpoints;
	ErrorMarkers mErrorMarkers;
	ImVec2 mCharAdvance;
	std::string mLineBuffer;
	uint64_t mStartTime;

	float mLastClick;
};
```

`hack/deps/ImGui/extraDraw.cpp`:

```cpp
#include <deps/ImGui/extraDraw.hpp>

#include <imgui_internal.h>

static inline ImDrawFlags FixRectCornerFlags(ImDrawFlags flags)
{
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // Obsoleted in 1.82 (from February 2021)
    // Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
    //   ~0   --> ImDrawFlags_RoundCornersAll or 0
    if (flags == ~0)
        return ImDrawFlags_RoundCornersAll;

    // Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations)
    //   0x01 --> ImDrawFlags_RoundCornersTopLeft (VALUE 0x01 OVERLAPS ImDrawFlags_Closed but ImDrawFlags_Closed is never valid in this path!)
    //   0x02 --> ImDrawFlags_RoundCornersTopRight
    //   0x03 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight
    //   0x04 --> ImDrawFlags_RoundCornersBotLeft
    //   0x05 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBotLeft
    //   ...
    //   0x0F --> ImDrawFlags_RoundCornersAll or 0
    // (See all values in ImDrawCornerFlags_)
    if (flags >= 0x01 && flags <= 0x0F)
        return (flags << 4);

    // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
#endif

    // If this triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
    // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc...
    IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");

    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
        flags |= ImDrawFlags_RoundCornersAll;

    return flags;
}

void ImGui::ExtraDrawlist::AddRectFilledMultiColor(ImDrawList* draw_list, const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left, float rounding, ImDrawFlags flags)
{
    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
        return;

    flags = FixRectCornerFlags(flags);
    rounding = ImMin(rounding, ImFabs(p_max.x - p_min.x) * (((flags & ImDrawCornerFlags_Top) == ImDrawCornerFlags_Top) || ((flags & ImDrawCornerFlags_Bot) == ImDrawCornerFlags_Bot) ? 0.5f : 1.0f) - 1.0f);
    rounding = ImMin(rounding, ImFabs(p_max.y - p_min.y) * (((flags & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((flags & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f) - 1.0f);

    // https://github.com/ocornut/imgui/issues/3710#issuecomment-758555966
    if (rounding > 0.0f)
    {
        const int size_before = draw_list->VtxBuffer.Size;
        draw_list->AddRectFilled(p_min, p_max, IM_COL32_WHITE, rounding, flags);
        const int size_after = draw_list->VtxBuffer.Size;

        for (int i = size_before; i < size_after; i++)
        {
            ImDrawVert* vert = draw_list->VtxBuffer.Data + i;

            ImVec4 upr_left = ImGui::ColorConvertU32ToFloat4(col_upr_left);
            ImVec4 bot_left = ImGui::ColorConvertU32ToFloat4(col_bot_left);
            ImVec4 up_right = ImGui::ColorConvertU32ToFloat4(col_upr_right);
            ImVec4 bot_right = ImGui::ColorConvertU32ToFloat4(col_bot_right);

            float X = ImClamp((vert->pos.x - p_min.x) / (p_max.x - p_min.x), 0.0f, 1.0f);

            // 4 colors - 8 deltas

            float r1 = upr_left.x + (up_right.x - upr_left.x) * X;
            float r2 = bot_left.x + (bot_right.x - bot_left.x) * X;

            float g1 = upr_left.y + (up_right.y - upr_left.y) * X;
            float g2 = bot_left.y + (bot_right.y - bot_left.y) * X;

            float b1 = upr_left.z + (up_right.z - upr_left.z) * X;
            float b2 = bot_left.z + (bot_right.z - bot_left.z) * X;

            float a1 = upr_left.w + (up_right.w - upr_left.w) * X;
            float a2 = bot_left.w + (bot_right.w - bot_left.w) * X;


            float Y = ImClamp((vert->pos.y - p_min.y) / (p_max.y - p_min.y), 0.0f, 1.0f);
            float r = r1 + (r2 - r1) * Y;
            float g = g1 + (g2 - g1) * Y;
            float b = b1 + (b2 - b1) * Y;
            float a = a1 + (a2 - a1) * Y;
            ImVec4 RGBA(r, g, b, a);

            RGBA = RGBA * ImGui::ColorConvertU32ToFloat4(vert->col);

            vert->col = ImColor(RGBA);
        }
        return;
    }

    const ImVec2 uv = draw_list->_Data->TexUvWhitePixel;
    draw_list->PrimReserve(6, 4);
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx)); 
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx + 1));
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx + 2));
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx));
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx + 2));
    draw_list->PrimWriteIdx((ImDrawIdx)(draw_list->_VtxCurrentIdx + 3));
    draw_list->PrimWriteVtx(p_min, uv, col_upr_left);
    draw_list->PrimWriteVtx(ImVec2(p_max.x, p_min.y), uv, col_upr_right);
    draw_list->PrimWriteVtx(p_max, uv, col_bot_right);
    draw_list->PrimWriteVtx(ImVec2(p_min.x, p_max.y), uv, col_bot_left);
}

void ImGui::ExtraDrawlist::AddConvexPolyFilledMultiColor(ImDrawList* draw_list, const ImVec2* points, const ImU32* col, const int points_count)
{
    const ImVec2 uv = draw_list->_Data->TexUvWhitePixel;

    if (draw_list->Flags & ImDrawListFlags_AntiAliasedFill)
    {
        // Anti-aliased Fill
        const float AA_SIZE = 1.0f;
        const int idx_count = (points_count - 2) * 3 + points_count * 6;
        const int vtx_count = (points_count * 2);
        draw_list->PrimReserve(idx_count, vtx_count);

        // Add indexes for fill
        unsigned int vtx_inner_idx = draw_list->_VtxCurrentIdx;
        unsigned int vtx_outer_idx = draw_list->_VtxCurrentIdx + 1;
        for (int i = 2; i < points_count; i++)
        {
            draw_list->_IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx);
            draw_list->_IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1));
            draw_list->_IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
            draw_list->_IdxWritePtr += 3;
        }

        // Compute normals
        ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2)); //-V630
        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            const ImVec2& p0 = points[i0];
            const ImVec2& p1 = points[i1];
            ImVec2 diff = p1 - p0;
            diff *= ImInvLength(diff, 1.0f);
            temp_normals[i0].x = diff.y;
            temp_normals[i0].y = -diff.x;
        }

        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            // Average normals
            const ImVec2& n0 = temp_normals[i0];
            const ImVec2& n1 = temp_normals[i1];
            ImVec2 dm = (n0 + n1) * 0.5f;
            float dmr2 = dm.x * dm.x + dm.y * dm.y;
            if (dmr2 > 0.000001f)
            {
                float scale = 1.0f / dmr2;
                if (scale > 100.0f) scale = 100.0f;
                dm *= scale;
            }
            dm *= AA_SIZE * 0.5f;

            // Add vertices
            draw_list->_VtxWritePtr[0].pos = (points[i1] - dm);
            draw_list->_VtxWritePtr[0].uv = uv;
            draw_list->_VtxWritePtr[0].col = col[i1];        // Inner
            draw_list->_VtxWritePtr[1].pos = (points[i1] + dm);
            draw_list->_VtxWritePtr[1].uv = uv;
            draw_list->_VtxWritePtr[1].col = col[i1] & ~IM_COL32_A_MASK;  // Outer
            draw_list->_VtxWritePtr += 2;

            // Add indexes for fringes
            draw_list->_IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
            draw_list->_IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1));
            draw_list->_IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
            draw_list->_IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
            draw_list->_IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); 
            draw_list->_IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
            draw_list->_IdxWritePtr += 6;
        }
        draw_list->_VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // Non Anti-aliased Fill
        const int idx_count = (points_count - 2) * 3;
        const int vtx_count = points_count;
        draw_list->PrimReserve(idx_count, vtx_count);
        for (int i = 0; i < vtx_count; i++)
        {
            draw_list->_VtxWritePtr[0].pos = points[i];
            draw_list->_VtxWritePtr[0].uv = uv;
            draw_list->_VtxWritePtr[0].col = col[i];
            draw_list->_VtxWritePtr++;
        }
        for (int i = 2; i < points_count; i++)
        {
            draw_list->_IdxWritePtr[0] = (ImDrawIdx)(draw_list->_VtxCurrentIdx);
            draw_list->_IdxWritePtr[1] = (ImDrawIdx)(draw_list->_VtxCurrentIdx + i - 1);
            draw_list->_IdxWritePtr[2] = (ImDrawIdx)(draw_list->_VtxCurrentIdx + i);
            draw_list->_IdxWritePtr += 3;
        }
        draw_list->_VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
}
```

`hack/deps/ImGui/extraDraw.hpp`:

```hpp
#pragma once

#include <imgui.h>

namespace ImGui
{
	namespace ExtraDrawlist
	{
		void AddRectFilledMultiColor(ImDrawList* draw_list, const ImVec2& p_min, const ImVec2& p_max,
			ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left, float rounding, ImDrawFlags flags = 0);
		void AddConvexPolyFilledMultiColor(ImDrawList* draw_list, const ImVec2* points, const ImU32* col, const int points_count);
	}
}
```

`hack/deps/ImGui/imgui_markdown.h`:

```h
#pragma once

// License: zlib
// Copyright (c) 2019 Juliette Foucaut & Doug Binks
// 
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
// 
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/*
API BREAKING CHANGES
====================
- 2020/04/22 - Added tooltipCallback parameter to ImGui::MarkdownConfig
- 2019/02/01 - Changed LinkCallback parameters, see https://github.com/juliettef/imgui_markdown/issues/2
- 2019/02/05 - Added imageCallback parameter to ImGui::MarkdownConfig
- 2019/02/06 - Added useLinkCallback member variable to MarkdownImageData to configure using images as links
*/

/*
imgui_markdown https://github.com/juliettef/imgui_markdown
Markdown for Dear ImGui

A permissively licensed markdown single-header library for https://github.com/ocornut/imgui

Currently requires C++11 or above

imgui_markdown currently supports the following markdown functionality:
 - Wrapped text
 - Headers H1, H2, H3
 - Emphasis
 - Indented text, multi levels
 - Unordered lists and sub-lists
 - Link
 - Image
 - Horizontal rule

Syntax

Wrapping:
Text wraps automatically. To add a new line, use 'Return'.

Headers:
# H1
## H2
### H3

Emphasis:
*emphasis*
_emphasis_
**strong emphasis**
__strong emphasis__

Indents:
On a new line, at the start of the line, add two spaces per indent.
  Indent level 1
    Indent level 2

Unordered lists:
On a new line, at the start of the line, add two spaces, an asterisks and a space.
For nested lists, add two additional spaces in front of the asterisk per list level increment.
  * Unordered List level 1
    * Unordered List level 2

Link:
[link description](https://...)

Image:
![image alt text](image identifier e.g. filename)

Horizontal Rule:
***
___

===============================================================================

// Example use on Windows with links opening in a browser

#include "ImGui.h"                // https://github.com/ocornut/imgui
#include "imgui_markdown.h"       // https://github.com/juliettef/imgui_markdown
#include "IconsFontAwesome5.h"    // https://github.com/juliettef/IconFontCppHeaders

// Following includes for Windows LinkCallback
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include "Shellapi.h"
#include <string>

void LinkCallback( ImGui::MarkdownLinkCallbackData data_ );
inline ImGui::MarkdownImageData ImageCallback( ImGui::MarkdownLinkCallbackData data_ );

static ImFont* H1 = NULL;
static ImFont* H2 = NULL;
static ImFont* H3 = NULL;

static ImGui::MarkdownConfig mdConfig;


void LinkCallback( ImGui::MarkdownLinkCallbackData data_ )
{
    std::string url( data_.link, data_.linkLength );
    if( !data_.isImage )
    {
        ShellExecuteA( NULL, "open", url.c_str(), NULL, NULL, SW_SHOWNORMAL );
    }
}

inline ImGui::MarkdownImageData ImageCallback( ImGui::MarkdownLinkCallbackData data_ )
{
    // In your application you would load an image based on data_ input. Here we just use the imgui font texture.
    ImTextureID image = ImGui::GetIO().Fonts->TexID;
    // > C++14 can use ImGui::MarkdownImageData imageData{ true, false, image, ImVec2( 40.0f, 20.0f ) };
    ImGui::MarkdownImageData imageData;
    imageData.isValid =         true;
    imageData.useLinkCallback = false;
    imageData.user_texture_id = image;
    imageData.size =            ImVec2( 40.0f, 20.0f );

    // For image resize when available size.x > image width, add
    ImVec2 const contentSize = ImGui::GetContentRegionAvail();
    if( imageData.size.x > contentSize.x )
    {
        float const ratio = imageData.size.y/imageData.size.x;
        imageData.size.x = contentSize.x;
        imageData.size.y = contentSize.x*ratio;
    }

    return imageData;
}

void LoadFonts( float fontSize_ = 12.0f )
{
    ImGuiIO& io = ImGui::GetIO();
    io.Fonts->Clear();
    // Base font
    io.Fonts->AddFontFromFileTTF( "myfont.ttf", fontSize_ );
    // Bold headings H2 and H3
    H2 = io.Fonts->AddFontFromFileTTF( "myfont-bold.ttf", fontSize_ );
    H3 = mdConfig.headingFormats[ 1 ].font;
    // bold heading H1
    float fontSizeH1 = fontSize_ * 1.1f;
    H1 = io.Fonts->AddFontFromFileTTF( "myfont-bold.ttf", fontSizeH1 );
}

void ExampleMarkdownFormatCallback( const ImGui::MarkdownFormatInfo& markdownFormatInfo_, bool start_ )
{
    // Call the default first so any settings can be overwritten by our implementation.
    // Alternatively could be called or not called in a switch statement on a case by case basis.
    // See defaultMarkdownFormatCallback definition for furhter examples of how to use it.
    ImGui::defaultMarkdownFormatCallback( markdownFormatInfo_, start_ );

    switch( markdownFormatInfo_.type )
    {
    // example: change the colour of heading level 2
    case ImGui::MarkdownFormatType::HEADING:
    {
        if( markdownFormatInfo_.level == 2 )
        {
            if( start_ )
            {
                ImGui::PushStyleColor( ImGuiCol_Text, ImGui::GetStyle().Colors[ ImGuiCol_TextDisabled ] );
            }
            else
            {
                ImGui::PopStyleColor();
            }
        }
        break;
    }
    default:
    {
        break;
    }
    }
}

void Markdown( const std::string& markdown_ )
{
    // You can make your own Markdown function with your prefered string container and markdown config.
    // > C++14 can use ImGui::MarkdownConfig mdConfig{ LinkCallback, NULL, ImageCallback, ICON_FA_LINK, { { H1, true }, { H2, true }, { H3, false } }, NULL };
    mdConfig.linkCallback =         LinkCallback;
    mdConfig.tooltipCallback =      NULL;
    mdConfig.imageCallback =        ImageCallback;
    mdConfig.linkIcon =             ICON_FA_LINK;
    mdConfig.headingFormats[0] =    { H1, true };
    mdConfig.headingFormats[1] =    { H2, true };
    mdConfig.headingFormats[2] =    { H3, false };
    mdConfig.userData =             NULL;
    mdConfig.formatCallback =       ExampleMarkdownFormatCallback;
    ImGui::Markdown( markdown_.c_str(), markdown_.length(), mdConfig );
}

void MarkdownExample()
{
    const std::string markdownText = u8R"(
# H1 Header: Text and Links
You can add [links like this one to enkisoftware](https://www.enkisoftware.com/) and lines will wrap well.
You can also insert images ![image alt text](image identifier e.g. filename)
Horizontal rules:
***
___
*Emphasis* and **strong emphasis** change the appearance of the text.
## H2 Header: indented text.
  This text has an indent (two leading spaces).
    This one has two.
### H3 Header: Lists
  * Unordered lists
    * Lists can be indented with two extra spaces.
  * Lists can have [links like this one to Avoyd](https://www.avoyd.com/) and *emphasized text*
)";
    Markdown( markdownText );
}

===============================================================================
*/


#include <stdint.h>

#include <imgui.h>

namespace ImGui
{
    //-----------------------------------------------------------------------------
    // Basic types
    //-----------------------------------------------------------------------------

    struct Link;
    struct MarkdownConfig;

    struct MarkdownLinkCallbackData                                 // for both links and images
    {
        const char* text;                               // text between square brackets []
        int                     textLength;
        const char* link;                               // text between brackets ()
        int                     linkLength;
        void* userData;
        bool                    isImage;                            // true if '!' is detected in front of the link syntax
    };

    struct MarkdownTooltipCallbackData                              // for tooltips
    {
        MarkdownLinkCallbackData linkData;
        const char* linkIcon;
    };

    struct MarkdownImageData
    {
        bool                    isValid = false;                    // if true, will draw the image
        bool                    useLinkCallback = false;            // if true, linkCallback will be called when image is clicked
        ImTextureID             user_texture_id = 0;                // see ImGui::Image
        ImVec2                  size = ImVec2(100.0f, 100.0f);    // see ImGui::Image
        ImVec2                  uv0 = ImVec2(0, 0);               // see ImGui::Image
        ImVec2                  uv1 = ImVec2(1, 1);               // see ImGui::Image
        ImVec4                  tint_col = ImVec4(1, 1, 1, 1);    // see ImGui::Image
        ImVec4                  border_col = ImVec4(0, 0, 0, 0);  // see ImGui::Image
    };

    enum class MarkdownFormatType
    {
        NORMAL_TEXT,
        HEADING,
        UNORDERED_LIST,
        LINK,
        EMPHASIS,
    };

    struct MarkdownFormatInfo
    {
        MarkdownFormatType      type = MarkdownFormatType::NORMAL_TEXT;
        int32_t                 level = 0;                               // Set for headings: 1 for H1, 2 for H2 etc.
        bool                    itemHovered = false;                       // Currently only set for links when mouse hovered, only valid when start_ == false
        const MarkdownConfig* config = NULL;
    };

    typedef void                MarkdownLinkCallback(MarkdownLinkCallbackData data);
    typedef void                MarkdownTooltipCallback(MarkdownTooltipCallbackData data);

    inline void defaultMarkdownTooltipCallback(MarkdownTooltipCallbackData data_)
    {
        if (data_.linkData.isImage)
        {
            ImGui::SetTooltip("%.*s", data_.linkData.linkLength, data_.linkData.link);
        }
        else
        {
            ImGui::SetTooltip("%s Open in browser\n%.*s", data_.linkIcon, data_.linkData.linkLength, data_.linkData.link);
        }
    }

    typedef MarkdownImageData   MarkdownImageCallback(MarkdownLinkCallbackData data);
    typedef void                MarkdownFormalCallback(const MarkdownFormatInfo& markdownFormatInfo_, bool start_);

    inline void defaultMarkdownFormatCallback(const MarkdownFormatInfo& markdownFormatInfo_, bool start_);

    struct MarkdownHeadingFormat
    {
        ImFont* font;                               // ImGui font
        bool                    separator;                          // if true, an underlined separator is drawn after the header
    };

    // Configuration struct for Markdown
    // - linkCallback is called when a link is clicked on
    // - linkIcon is a string which encode a "Link" icon, if available in the current font (e.g. linkIcon = ICON_FA_LINK with FontAwesome + IconFontCppHeaders https://github.com/juliettef/IconFontCppHeaders)
    // - headingFormats controls the format of heading H1 to H3, those above H3 use H3 format
    struct MarkdownConfig
    {
        static const int        NUMHEADINGS = 3;

        MarkdownLinkCallback* linkCallback = NULL;
        MarkdownTooltipCallback* tooltipCallback = NULL;
        MarkdownImageCallback* imageCallback = NULL;
        const char* linkIcon = "";                      // icon displayd in link tooltip
        MarkdownHeadingFormat   headingFormats[NUMHEADINGS] = { { NULL, true }, { NULL, true }, { NULL, true } };
        void* userData = NULL;
        MarkdownFormalCallback* formatCallback = defaultMarkdownFormatCallback;
    };

    //-----------------------------------------------------------------------------
    // External interface
    //-----------------------------------------------------------------------------

    inline void Markdown(const char* markdown_, size_t markdownLength_, const MarkdownConfig& mdConfig_);

    //-----------------------------------------------------------------------------
    // Internals
    //-----------------------------------------------------------------------------

    struct TextRegion;
    struct Line;
    inline void UnderLine(ImColor col_);
    inline void RenderLine(const char* markdown_, Line& line_, TextRegion& textRegion_, const MarkdownConfig& mdConfig_);

    struct TextRegion
    {
        TextRegion() : indentX(0.0f)
        {
        }
        ~TextRegion()
        {
            ResetIndent();
        }

        // ImGui::TextWrapped will wrap at the starting position
        // so to work around this we render using our own wrapping for the first line
        void RenderTextWrapped(const char* text_, const char* text_end_, bool bIndentToHere_ = false)
        {
            float       scale = ImGui::GetIO().FontGlobalScale;
            float       widthLeft = GetContentRegionAvail().x;
            const char* endLine = ImGui::GetFont()->CalcWordWrapPositionA(scale, text_, text_end_, widthLeft);
            ImGui::TextUnformatted(text_, endLine);
            if (bIndentToHere_)
            {
                float indentNeeded = GetContentRegionAvail().x - widthLeft;
                if (indentNeeded)
                {
                    ImGui::Indent(indentNeeded);
                    indentX += indentNeeded;
                }
            }
            widthLeft = GetContentRegionAvail().x;
            while (endLine < text_end_)
            {
                text_ = endLine;
                if (*text_ == ' ') { ++text_; }    // skip a space at start of line
                endLine = ImGui::GetFont()->CalcWordWrapPositionA(scale, text_, text_end_, widthLeft);
                if (text_ == endLine)
                {
                    endLine++;
                }
                ImGui::TextUnformatted(text_, endLine);
            }
        }

        void RenderListTextWrapped(const char* text_, const char* text_end_)
        {
            ImGui::Bullet();
            ImGui::SameLine();
            RenderTextWrapped(text_, text_end_, true);
        }

        bool RenderLinkText(const char* text_, const char* text_end_, const Link& link_,
            const char* markdown_, const MarkdownConfig& mdConfig_, const char** linkHoverStart_);

        void RenderLinkTextWrapped(const char* text_, const char* text_end_, const Link& link_,
            const char* markdown_, const MarkdownConfig& mdConfig_, const char** linkHoverStart_, bool bIndentToHere_ = false);

        void ResetIndent()
        {
            if (indentX > 0.0f)
            {
                ImGui::Unindent(indentX);
            }
            indentX = 0.0f;
        }

    private:
        float       indentX;
    };

    // Text that starts after a new line (or at beginning) and ends with a newline (or at end)
    struct Line {
        bool isHeading = false;
        bool isEmphasis = false;
        bool isUnorderedListStart = false;
        bool isLeadingSpace = true;     // spaces at start of line
        int  leadSpaceCount = 0;
        int  headingCount = 0;
        int  emphasisCount = 0;
        int  lineStart = 0;
        int  lineEnd = 0;
        int  lastRenderPosition = 0;     // lines may get rendered in multiple pieces
    };

    struct TextBlock {                  // subset of line
        int start = 0;
        int stop = 0;
        int size() const
        {
            return stop - start;
        }
    };

    struct Link {
        enum LinkState {
            NO_LINK,
            HAS_SQUARE_BRACKET_OPEN,
            HAS_SQUARE_BRACKETS,
            HAS_SQUARE_BRACKETS_ROUND_BRACKET_OPEN,
        };
        LinkState state = NO_LINK;
        TextBlock text;
        TextBlock url;
        bool isImage = false;
        int num_brackets_open = 0;
    };

    struct Emphasis {
        enum EmphasisState {
            NONE,
            LEFT,
            MIDDLE,
            RIGHT,
        };
        EmphasisState state = NONE;
        TextBlock text;
        char sym;
    };

    inline void UnderLine(ImColor col_)
    {
        ImVec2 min = ImGui::GetItemRectMin();
        ImVec2 max = ImGui::GetItemRectMax();
        min.y = max.y;
        ImGui::GetWindowDrawList()->AddLine(min, max, col_, 1.0f);
    }

    inline void RenderLine(const char* markdown_, Line& line_, TextRegion& textRegion_, const MarkdownConfig& mdConfig_)
    {
        // indent
        int indentStart = 0;
        if (line_.isUnorderedListStart)    // ImGui unordered list render always adds one indent
        {
            indentStart = 1;
        }
        for (int j = indentStart; j < line_.leadSpaceCount / 2; ++j)    // add indents
        {
            ImGui::Indent();
        }

        // render
        MarkdownFormatInfo formatInfo;
        formatInfo.config = &mdConfig_;
        int textStart = line_.lastRenderPosition + 1;
        int textSize = line_.lineEnd - textStart;
        if (line_.isUnorderedListStart)    // render unordered list
        {
            formatInfo.type = MarkdownFormatType::UNORDERED_LIST;
            mdConfig_.formatCallback(formatInfo, true);
            const char* text = markdown_ + textStart + 1;
            textRegion_.RenderListTextWrapped(text, text + textSize - 1);
        }
        else if (line_.isHeading)          // render heading
        {
            formatInfo.level = line_.headingCount;
            formatInfo.type = MarkdownFormatType::HEADING;
            mdConfig_.formatCallback(formatInfo, true);
            const char* text = markdown_ + textStart + 1;
            textRegion_.RenderTextWrapped(text, text + textSize - 1);
        }
        else if (line_.isEmphasis)         // render emphasis
        {
            formatInfo.level = line_.emphasisCount;
            formatInfo.type = MarkdownFormatType::EMPHASIS;
            mdConfig_.formatCallback(formatInfo, true);
            const char* text = markdown_ + textStart;
            textRegion_.RenderTextWrapped(text, text + textSize);
        }
        else                                // render a normal paragraph chunk
        {
            formatInfo.type = MarkdownFormatType::NORMAL_TEXT;
            mdConfig_.formatCallback(formatInfo, true);
            const char* text = markdown_ + textStart;
            textRegion_.RenderTextWrapped(text, text + textSize);
        }
        mdConfig_.formatCallback(formatInfo, false);

        // unindent
        for (int j = indentStart; j < line_.leadSpaceCount / 2; ++j)
        {
            ImGui::Unindent();
        }
    }

    // render markdown
    inline void Markdown(const char* markdown_, size_t markdownLength_, const MarkdownConfig& mdConfig_)
    {
        static const char* linkHoverStart = NULL; // we need to preserve status of link hovering between frames
        ImGuiStyle& style = ImGui::GetStyle();
        Line        line;
        Link        link;
        Emphasis    em;
        TextRegion  textRegion;

        char c = 0;
        for (int i = 0; i < (int)markdownLength_; ++i)
        {
            c = markdown_[i];               // get the character at index
            if (c == 0) { break; }         // shouldn't happen but don't go beyond 0.

            // If we're at the beginning of the line, count any spaces
            if (line.isLeadingSpace)
            {
                if (c == ' ')
                {
                    ++line.leadSpaceCount;
                    continue;
                }
                else
                {
                    line.isLeadingSpace = false;
                    line.lastRenderPosition = i - 1;
                    if ((c == '*') && (line.leadSpaceCount >= 2))
                    {
                        if (((int)markdownLength_ > i + 1) && (markdown_[i + 1] == ' '))    // space after '*'
                        {
                            line.isUnorderedListStart = true;
                            ++i;
                            ++line.lastRenderPosition;
                        }
                        // carry on processing as could be emphasis
                    }
                    else if (c == '#')
                    {
                        line.headingCount++;
                        bool bContinueChecking = true;
                        int j = i;
                        while (++j < (int)markdownLength_ && bContinueChecking)
                        {
                            c = markdown_[j];
                            switch (c)
                            {
                            case '#':
                                line.headingCount++;
                                break;
                            case ' ':
                                line.lastRenderPosition = j - 1;
                                i = j;
                                line.isHeading = true;
                                bContinueChecking = false;
                                break;
                            default:
                                line.isHeading = false;
                                bContinueChecking = false;
                                break;
                            }
                        }
                        if (line.isHeading)
                        {
                            // reset emphasis status, we do not support emphasis around headers for now
                            em = Emphasis();
                            continue;
                        }
                    }
                }
            }

            // Test to see if we have a link
            switch (link.state)
            {
            case Link::NO_LINK:
                if (c == '[' && !line.isHeading) // we do not support headings with links for now
                {
                    link.state = Link::HAS_SQUARE_BRACKET_OPEN;
                    link.text.start = i + 1;
                    if (i > 0 && markdown_[i - 1] == '!')
                    {
                        link.isImage = true;
                    }
                }
                break;
            case Link::HAS_SQUARE_BRACKET_OPEN:
                if (c == ']')
                {
                    link.state = Link::HAS_SQUARE_BRACKETS;
                    link.text.stop = i;
                }
                break;
            case Link::HAS_SQUARE_BRACKETS:
                if (c == '(')
                {
                    link.state = Link::HAS_SQUARE_BRACKETS_ROUND_BRACKET_OPEN;
                    link.url.start = i + 1;
                    link.num_brackets_open = 1;
                }
                break;
            case Link::HAS_SQUARE_BRACKETS_ROUND_BRACKET_OPEN:
                if (c == '(')
                {
                    ++link.num_brackets_open;
                }
                else if (c == ')')
                {
                    --link.num_brackets_open;
                }
                if (link.num_brackets_open == 0)
                {
                    // reset emphasis status, we do not support emphasis around links for now
                    em = Emphasis();
                    // render previous line content
                    line.lineEnd = link.text.start - (link.isImage ? 2 : 1);
                    RenderLine(markdown_, line, textRegion, mdConfig_);
                    line.leadSpaceCount = 0;
                    link.url.stop = i;
                    line.isUnorderedListStart = false;    // the following text shouldn't have bullets
                    ImGui::SameLine(0.0f, 0.0f);
                    if (link.isImage)   // it's an image, render it.
                    {
                        bool drawnImage = false;
                        bool useLinkCallback = false;
                        if (mdConfig_.imageCallback)
                        {
                            MarkdownImageData imageData = mdConfig_.imageCallback({ markdown_ + link.text.start, link.text.size(), markdown_ + link.url.start, link.url.size(), mdConfig_.userData, true });
                            useLinkCallback = imageData.useLinkCallback;
                            if (imageData.isValid)
                            {
                                ImGui::Image(imageData.user_texture_id, imageData.size, imageData.uv0, imageData.uv1, imageData.tint_col, imageData.border_col);
                                drawnImage = true;
                            }
                        }
                        if (!drawnImage)
                        {
                            ImGui::Text("( Image %.*s not loaded )", link.url.size(), markdown_ + link.url.start);
                        }
                        if (ImGui::IsItemHovered())
                        {
                            if (ImGui::IsMouseReleased(0) && mdConfig_.linkCallback && useLinkCallback)
                            {
                                mdConfig_.linkCallback({ markdown_ + link.text.start, link.text.size(), markdown_ + link.url.start, link.url.size(), mdConfig_.userData, true });
                            }
                            if (link.text.size() > 0 && mdConfig_.tooltipCallback)
                            {
                                mdConfig_.tooltipCallback({ { markdown_ + link.text.start, link.text.size(), markdown_ + link.url.start, link.url.size(), mdConfig_.userData, true }, mdConfig_.linkIcon });
                            }
                        }
                    }
                    else                 // it's a link, render it.
                    {
                        textRegion.RenderLinkTextWrapped(markdown_ + link.text.start, markdown_ + link.text.start + link.text.size(), link, markdown_, mdConfig_, &linkHoverStart, false);
                    }
                    ImGui::SameLine(0.0f, 0.0f);
                    // reset the link by reinitializing it
                    link = Link();
                    line.lastRenderPosition = i;
                    break;
                }
            }

            // Test to see if we have emphasis styling
            switch (em.state)
            {
            case Emphasis::NONE:
                if (link.state == Link::NO_LINK && !line.isHeading)
                {
                    int next = i + 1;
                    int prev = i - 1;
                    if ((c == '*' || c == '_')
                        && (i == line.lineStart
                            || markdown_[prev] == ' '
                            || markdown_[prev] == '\t') // empasis must be preceded by whitespace or line start
                        && (int)markdownLength_ > next // emphasis must precede non-whitespace
                        && markdown_[next] != ' '
                        && markdown_[next] != '\n'
                        && markdown_[next] != '\t')
                    {
                        em.state = Emphasis::LEFT;
                        em.sym = c;
                        em.text.start = i;
                        line.emphasisCount = 1;
                        continue;
                    }
                }
                break;
            case Emphasis::LEFT:
                if (em.sym == c)
                {
                    ++line.emphasisCount;
                    continue;
                }
                else
                {
                    em.text.start = i;
                    em.state = Emphasis::MIDDLE;
                }
                break;
            case Emphasis::MIDDLE:
                if (em.sym == c)
                {
                    em.state = Emphasis::RIGHT;
                    em.text.stop = i;
                    // pass through to case Emphasis::RIGHT
                }
                else
                {
                    break;
                }
            case Emphasis::RIGHT:
                if (em.sym == c)
                {
                    if (line.emphasisCount < 3 && (i - em.text.stop + 1 == line.emphasisCount))
                    {
                        // render text up to emphasis
                        int lineEnd = em.text.start - line.emphasisCount;
                        if (lineEnd > line.lineStart)
                        {
                            line.lineEnd = lineEnd;
                            RenderLine(markdown_, line, textRegion, mdConfig_);
                            ImGui::SameLine(0.0f, 0.0f);
                            line.isUnorderedListStart = false;
                            line.leadSpaceCount = 0;
                        }
                        line.isEmphasis = true;
                        line.lastRenderPosition = em.text.start - 1;
                        line.lineStart = em.text.start;
                        line.lineEnd = em.text.stop;
                        RenderLine(markdown_, line, textRegion, mdConfig_);
                        ImGui::SameLine(0.0f, 0.0f);
                        line.isEmphasis = false;
                        line.lastRenderPosition = i;
                        em = Emphasis();
                    }
                    continue;
                }
                else
                {
                    em.state = Emphasis::NONE;
                    // render text up to here
                    int start = em.text.start - line.emphasisCount;
                    if (start < line.lineStart)
                    {
                        line.lineEnd = line.lineStart;
                        line.lineStart = start;
                        line.lastRenderPosition = start - 1;
                        RenderLine(markdown_, line, textRegion, mdConfig_);
                        line.lineStart = line.lineEnd;
                        line.lastRenderPosition = line.lineStart - 1;
                    }
                }
                break;
            }

            // handle end of line (render)
            if (c == '\n')
            {
                // first check if the line is a horizontal rule
                line.lineEnd = i;
                if (em.state == Emphasis::MIDDLE && line.emphasisCount >= 3 &&
                    (line.lineStart + line.emphasisCount) == i)
                {
                    ImGui::Separator();
                }
                else
                {
                    // render the line: multiline emphasis requires a complex implementation so not supporting
                    RenderLine(markdown_, line, textRegion, mdConfig_);
                }

                // reset the line and emphasis state
                line = Line();
                em = Emphasis();

                line.lineStart = i + 1;
                line.lastRenderPosition = i;

                textRegion.ResetIndent();

                // reset the link
                link = Link();
            }
        }

        if (em.state == Emphasis::LEFT && line.emphasisCount >= 3)
        {
            ImGui::Separator();
        }
        else
        {
            // render any remaining text if last char wasn't 0
            if (markdownLength_ && line.lineStart < (int)markdownLength_ && markdown_[line.lineStart] != 0)
            {
                // handle both null terminated and non null terminated strings
                line.lineEnd = (int)markdownLength_;
                if (0 == markdown_[line.lineEnd - 1])
                {
                    --line.lineEnd;
                }
                RenderLine(markdown_, line, textRegion, mdConfig_);
            }
        }
    }

    inline bool TextRegion::RenderLinkText(const char* text_, const char* text_end_, const Link& link_,
        const char* markdown_, const MarkdownConfig& mdConfig_, const char** linkHoverStart_)
    {
        MarkdownFormatInfo formatInfo;
        formatInfo.config = &mdConfig_;
        formatInfo.type = MarkdownFormatType::LINK;
        mdConfig_.formatCallback(formatInfo, true);
        ImGui::PushTextWrapPos(-1.0f);
        ImGui::TextUnformatted(text_, text_end_);
        ImGui::PopTextWrapPos();

        bool bThisItemHovered = ImGui::IsItemHovered();
        if (bThisItemHovered)
        {
            *linkHoverStart_ = markdown_ + link_.text.start;
        }
        bool bHovered = bThisItemHovered || (*linkHoverStart_ == (markdown_ + link_.text.start));

        formatInfo.itemHovered = bHovered;
        mdConfig_.formatCallback(formatInfo, false);

        if (bHovered)
        {
            if (ImGui::IsMouseReleased(0) && mdConfig_.linkCallback)
            {
                mdConfig_.linkCallback({ markdown_ + link_.text.start, link_.text.size(), markdown_ + link_.url.start, link_.url.size(), mdConfig_.userData, false });
            }
            if (mdConfig_.tooltipCallback)
            {
                mdConfig_.tooltipCallback({ { markdown_ + link_.text.start, link_.text.size(), markdown_ + link_.url.start, link_.url.size(), mdConfig_.userData, false }, mdConfig_.linkIcon });
            }
        }
        return bThisItemHovered;
    }

    inline void TextRegion::RenderLinkTextWrapped(const char* text_, const char* text_end_, const Link& link_,
        const char* markdown_, const MarkdownConfig& mdConfig_, const char** linkHoverStart_, bool bIndentToHere_)
    {
        float       scale = ImGui::GetIO().FontGlobalScale;
        float       widthLeft = GetContentRegionAvail().x;
        const char* endLine = ImGui::GetFont()->CalcWordWrapPositionA(scale, text_, text_end_, widthLeft);
        bool bHovered = RenderLinkText(text_, endLine, link_, markdown_, mdConfig_, linkHoverStart_);
        if (bIndentToHere_)
        {
            float indentNeeded = GetContentRegionAvail().x - widthLeft;
            if (indentNeeded)
            {
                ImGui::Indent(indentNeeded);
                indentX += indentNeeded;
            }
        }
        widthLeft = GetContentRegionAvail().x;
        while (endLine < text_end_)
        {
            text_ = endLine;
            if (*text_ == ' ') { ++text_; }    // skip a space at start of line
            endLine = ImGui::GetFont()->CalcWordWrapPositionA(scale, text_, text_end_, widthLeft);
            if (text_ == endLine)
            {
                endLine++;
            }
            bool bThisLineHovered = RenderLinkText(text_, endLine, link_, markdown_, mdConfig_, linkHoverStart_);
            bHovered = bHovered || bThisLineHovered;
        }
        if (!bHovered && *linkHoverStart_ == markdown_ + link_.text.start)
        {
            *linkHoverStart_ = NULL;
        }
    }


    inline void defaultMarkdownFormatCallback(const MarkdownFormatInfo& markdownFormatInfo_, bool start_)
    {
        switch (markdownFormatInfo_.type)
        {
        case MarkdownFormatType::NORMAL_TEXT:
            break;
        case MarkdownFormatType::EMPHASIS:
        {
            MarkdownHeadingFormat fmt;
            // default styling for emphasis uses last headingFormats - for your own styling
            // implement EMPHASIS in your formatCallback
            if (markdownFormatInfo_.level == 1)
            {
                // normal emphasis
                if (start_)
                {
                    ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyle().Colors[ImGuiCol_TextDisabled]);
                }
                else
                {
                    ImGui::PopStyleColor();
                }
            }
            else
            {
                // strong emphasis
                fmt = markdownFormatInfo_.config->headingFormats[MarkdownConfig::NUMHEADINGS - 1];
                if (start_)
                {
                    if (fmt.font)
                    {
                        ImGui::PushFont(fmt.font);
                    }
                }
                else
                {
                    if (fmt.font)
                    {
                        ImGui::PopFont();
                    }
                }
            }
            break;
        }
        case MarkdownFormatType::HEADING:
        {
            MarkdownHeadingFormat fmt;
            if (markdownFormatInfo_.level > MarkdownConfig::NUMHEADINGS)
            {
                fmt = markdownFormatInfo_.config->headingFormats[MarkdownConfig::NUMHEADINGS - 1];
            }
            else
            {
                fmt = markdownFormatInfo_.config->headingFormats[markdownFormatInfo_.level - 1];
            }
            if (start_)
            {
                if (fmt.font)
                {
                    ImGui::PushFont(fmt.font);
                }
                ImGui::NewLine();
            }
            else
            {
                if (fmt.separator)
                {
                    ImGui::Separator();
                    ImGui::NewLine();
                }
                else
                {
                    ImGui::NewLine();
                }
                if (fmt.font)
                {
                    ImGui::PopFont();
                }
            }
            break;
        }
        case MarkdownFormatType::UNORDERED_LIST:
            break;
        case MarkdownFormatType::LINK:
            if (start_)
            {
                ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered]);
            }
            else
            {
                ImGui::PopStyleColor();
                if (markdownFormatInfo_.itemHovered)
                {
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::UnderLine(ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered]);
                }
                else
                {
                    ImGui::UnderLine(ImGui::GetStyle().Colors[ImGuiCol_Button]);
                }
            }
            break;
        }
    }

}
```

`hack/deps/README.md`:

```md
Additional stuff for dependencies, contain extra functionalities.
```

`hack/deps/delaunator-cpp/delaunator.hpp`:

```hpp
#pragma once

#include <algorithm>
#include <cmath>
#include <exception>
#include <iostream>
#include <limits>
#include <memory>
#include <utility>
#include <vector>

namespace delaunator {

    //@see https://stackoverflow.com/questions/33333363/built-in-mod-vs-custom-mod-function-improve-the-performance-of-modulus-op/33333636#33333636
    inline size_t fast_mod(const size_t i, const size_t c) {
        return i >= c ? i % c : i;
    }

    // Kahan and Babuska summation, Neumaier variant; accumulates less FP error
    template<std::floating_point T>
    inline T sum(const std::vector<T>& x) {
        T sum = x[0];
        T err = (T)0;

        for (size_t i = 1; i < x.size(); i++) {
            const T k = x[i];
            const T m = sum + k;
            err += std::fabs(sum) >= std::fabs(k) ? sum - m + k : k - m + sum;
            sum = m;
        }
        return sum + err;
    }

    template<std::floating_point T>
    inline T dist(
        const T ax,
        const T ay,
        const T bx,
        const T by) {
        const T dx = ax - bx;
        const T dy = ay - by;
        return dx * dx + dy * dy;
    }

    template<std::floating_point T>
    inline T circumradius(
        const T ax,
        const T ay,
        const T bx,
        const T by,
        const T cx,
        const T cy) {
        const T dx = bx - ax;
        const T dy = by - ay;
        const T ex = cx - ax;
        const T ey = cy - ay;

        const T bl = dx * dx + dy * dy;
        const T cl = ex * ex + ey * ey;
        const T d = dx * ey - dy * ex;

        const T x = (ey * bl - dy * cl) * (T)0.5 / d;
        const T y = (dx * cl - ex * bl) * (T)0.5 / d;

        if ((bl > (T)0.0 || bl < (T)0.0) && (cl > (T)0.0 || cl < (T)0.0) && (d > (T)0.0 || d < (T)0.0)) {
            return x * x + y * y;
        }
        else {
            return std::numeric_limits<T>::max();
        }
    }

    template<std::floating_point T>
    inline bool orient(
        const T px,
        const T py,
        const T qx,
        const T qy,
        const T rx,
        const T ry) {
        return (qy - py) * (rx - qx) - (qx - px) * (ry - qy) < (T)0.0;
    }

    template<std::floating_point T>
    inline std::pair<T, T> circumcenter(
        const T ax,
        const T ay,
        const T bx,
        const T by,
        const T cx,
        const T cy) {
        const T dx = bx - ax;
        const T dy = by - ay;
        const T ex = cx - ax;
        const T ey = cy - ay;

        const T bl = dx * dx + dy * dy;
        const T cl = ex * ex + ey * ey;
        const T d = dx * ey - dy * ex;

        const T x = ax + (ey * bl - dy * cl) * (T)0.5 / d;
        const T y = ay + (dx * cl - ex * bl) * (T)0.5 / d;

        return std::make_pair(x, y);
    }

    template<std::floating_point T>
    struct compare {

        std::vector<T> const& coords;
        T cx;
        T cy;

        bool operator()(std::size_t i, std::size_t j) {
            const T d1 = dist(coords[2 * i], coords[2 * i + 1], cx, cy);
            const T d2 = dist(coords[2 * j], coords[2 * j + 1], cx, cy);
            const T diff1 = d1 - d2;
            const T diff2 = coords[2 * i] - coords[2 * j];
            const T diff3 = coords[2 * i + 1] - coords[2 * j + 1];

            if (diff1 > (T)0.0 || diff1 < (T)0.0) {
                return diff1 < 0;
            }
            else if (diff2 > (T)0.0 || diff2 < (T)0.0) {
                return diff2 < 0;
            }
            else {
                return diff3 < 0;
            }
        }
    };

    template<std::floating_point T>
    inline bool in_circle(
        const T ax,
        const T ay,
        const T bx,
        const T by,
        const T cx,
        const T cy,
        const T px,
        const T py) {
        const T dx = ax - px;
        const T dy = ay - py;
        const T ex = bx - px;
        const T ey = by - py;
        const T fx = cx - px;
        const T fy = cy - py;

        const T ap = dx * dx + dy * dy;
        const T bp = ex * ex + ey * ey;
        const T cp = fx * fx + fy * fy;

        return (dx * (ey * cp - bp * fy) -
            dy * (ex * cp - bp * fx) +
            ap * (ex * fy - ey * fx)) < 0.0;
    }

    template<std::floating_point T>
    constexpr double EPSILON = std::numeric_limits<T>::epsilon();
    constexpr std::size_t INVALID_INDEX = std::numeric_limits<std::size_t>::max();

    template<std::floating_point T>
    inline bool check_pts_equal(T x1, T y1, T x2, T y2) {
        return std::fabs(x1 - x2) <= EPSILON<T> &&
            std::fabs(y1 - y2) <= EPSILON<T>;
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    template<std::floating_point T>
    inline T pseudo_angle(const T dx, const T dy) {
        const T p = dx / (std::abs(dx) + std::abs(dy));
        return (dy > (T)0.0 ? (T)3.0 - p : (T)1.0 + p) / (T)4.0; // [0..1)
    }

    template<std::floating_point T>
    struct DelaunatorPoint {
        std::size_t i;
        T x;
        T y;
        std::size_t t;
        std::size_t prev;
        std::size_t next;
        bool removed;
    };

    template<std::floating_point T>
    class Delaunator {

    public:
        std::vector<T> const& coords;
        std::vector<std::size_t> triangles;
        std::vector<std::size_t> halfedges;
        std::vector<std::size_t> hull_prev;
        std::vector<std::size_t> hull_next;
        std::vector<std::size_t> hull_tri;
        std::size_t hull_start;

        Delaunator(std::vector<T> const& in_coords);

        T get_hull_area();

    private:
        std::vector<std::size_t> m_hash;
        T m_center_x;
        T m_center_y;
        std::size_t m_hash_size;
        std::vector<std::size_t> m_edge_stack;

        std::size_t legalize(std::size_t a);
        std::size_t hash_key(T x, T y) const;
        std::size_t add_triangle(
            std::size_t i0,
            std::size_t i1,
            std::size_t i2,
            std::size_t a,
            std::size_t b,
            std::size_t c);
        void link(std::size_t a, std::size_t b);
    };

    template<std::floating_point T>
    Delaunator<T>::Delaunator(std::vector<T> const& in_coords)
        : coords(in_coords),
        triangles(),
        halfedges(),
        hull_prev(),
        hull_next(),
        hull_tri(),
        hull_start(),
        m_hash(),
        m_center_x(),
        m_center_y(),
        m_hash_size(),
        m_edge_stack() {
        std::size_t n = coords.size() >> 1;

        T max_x = std::numeric_limits<T>::min();
        T max_y = std::numeric_limits<T>::min();
        T min_x = std::numeric_limits<T>::max();
        T min_y = std::numeric_limits<T>::max();
        std::vector<std::size_t> ids;
        ids.reserve(n);

        for (std::size_t i = 0; i < n; i++) {
            const T x = coords[2 * i];
            const T y = coords[2 * i + 1];

            if (x < min_x) min_x = x;
            if (y < min_y) min_y = y;
            if (x > max_x) max_x = x;
            if (y > max_y) max_y = y;

            ids.push_back(i);
        }
        const T cx = (min_x + max_x) / 2;
        const T cy = (min_y + max_y) / 2;
        T min_dist = std::numeric_limits<T>::max();

        std::size_t i0 = INVALID_INDEX;
        std::size_t i1 = INVALID_INDEX;
        std::size_t i2 = INVALID_INDEX;

        // pick a seed point close to the centroid
        for (std::size_t i = 0; i < n; i++) {
            const T d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
            if (d < min_dist) {
                i0 = i;
                min_dist = d;
            }
        }

        const T i0x = coords[2 * i0];
        const T i0y = coords[2 * i0 + 1];

        min_dist = std::numeric_limits<T>::max();

        // find the point closest to the seed
        for (std::size_t i = 0; i < n; i++) {
            if (i == i0) continue;
            const T d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
            if (d < min_dist && d > 0.0) {
                i1 = i;
                min_dist = d;
            }
        }

        T i1x = coords[2 * i1];
        T i1y = coords[2 * i1 + 1];

        T min_radius = std::numeric_limits<T>::max();

        // find the third point which forms the smallest circumcircle with the first two
        for (std::size_t i = 0; i < n; i++) {
            if (i == i0 || i == i1) continue;

            const T r = circumradius(
                i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);

            if (r < min_radius) {
                i2 = i;
                min_radius = r;
            }
        }

        if (!(min_radius < std::numeric_limits<T>::max())) {
            throw std::runtime_error("not triangulation");
        }

        T i2x = coords[2 * i2];
        T i2y = coords[2 * i2 + 1];

        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
            std::swap(i1, i2);
            std::swap(i1x, i2x);
            std::swap(i1y, i2y);
        }

        std::tie(m_center_x, m_center_y) = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);

        // sort the points by distance from the seed triangle circumcenter
        std::sort(ids.begin(), ids.end(), compare{ coords, m_center_x, m_center_y });

        // initialize a hash table for storing edges of the advancing convex hull
        m_hash_size = static_cast<std::size_t>(std::llround(std::ceil(std::sqrt(n))));
        m_hash.resize(m_hash_size);
        std::fill(m_hash.begin(), m_hash.end(), INVALID_INDEX);

        // initialize arrays for tracking the edges of the advancing convex hull
        hull_prev.resize(n);
        hull_next.resize(n);
        hull_tri.resize(n);

        hull_start = i0;

        size_t hull_size = 3;

        hull_next[i0] = hull_prev[i2] = i1;
        hull_next[i1] = hull_prev[i0] = i2;
        hull_next[i2] = hull_prev[i1] = i0;

        hull_tri[i0] = 0;
        hull_tri[i1] = 1;
        hull_tri[i2] = 2;

        m_hash[hash_key(i0x, i0y)] = i0;
        m_hash[hash_key(i1x, i1y)] = i1;
        m_hash[hash_key(i2x, i2y)] = i2;

        std::size_t max_triangles = n < 3 ? 1 : 2 * n - 5;
        triangles.reserve(max_triangles * 3);
        halfedges.reserve(max_triangles * 3);
        add_triangle(i0, i1, i2, INVALID_INDEX, INVALID_INDEX, INVALID_INDEX);
        T xp = std::numeric_limits<T>::quiet_NaN();
        T yp = std::numeric_limits<T>::quiet_NaN();
        for (std::size_t k = 0; k < n; k++) {
            const std::size_t i = ids[k];
            const T x = coords[2 * i];
            const T y = coords[2 * i + 1];

            // skip near-duplicate points
            if (k > 0 && check_pts_equal(x, y, xp, yp)) continue;
            xp = x;
            yp = y;

            // skip seed triangle points
            if (
                check_pts_equal(x, y, i0x, i0y) ||
                check_pts_equal(x, y, i1x, i1y) ||
                check_pts_equal(x, y, i2x, i2y)) continue;

            // find a visible edge on the convex hull using edge hash
            std::size_t start = 0;

            size_t key = hash_key(x, y);
            for (size_t j = 0; j < m_hash_size; j++) {
                start = m_hash[fast_mod(key + j, m_hash_size)];
                if (start != INVALID_INDEX && start != hull_next[start]) break;
            }

            start = hull_prev[start];
            size_t e = start;
            size_t q;

            while (q = hull_next[e], !orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) { //TODO: does it works in a same way as in JS
                e = q;
                if (e == start) {
                    e = INVALID_INDEX;
                    break;
                }
            }

            if (e == INVALID_INDEX) continue; // likely a near-duplicate point; skip it

            // add the first triangle from the point
            std::size_t t = add_triangle(
                e,
                i,
                hull_next[e],
                INVALID_INDEX,
                INVALID_INDEX,
                hull_tri[e]);

            hull_tri[i] = legalize(t + 2);
            hull_tri[e] = t;
            hull_size++;

            // walk forward through the hull, adding more triangles and flipping recursively
            std::size_t next = hull_next[e];
            while (
                q = hull_next[next],
                orient(x, y, coords[2 * next], coords[2 * next + 1], coords[2 * q], coords[2 * q + 1])) {
                t = add_triangle(next, i, q, hull_tri[i], INVALID_INDEX, hull_tri[next]);
                hull_tri[i] = legalize(t + 2);
                hull_next[next] = next; // mark as removed
                hull_size--;
                next = q;
            }

            // walk backward from the other side, adding more triangles and flipping
            if (e == start) {
                while (
                    q = hull_prev[e],
                    orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
                    t = add_triangle(q, i, e, INVALID_INDEX, hull_tri[e], hull_tri[q]);
                    legalize(t + 2);
                    hull_tri[q] = t;
                    hull_next[e] = e; // mark as removed
                    hull_size--;
                    e = q;
                }
            }

            // update the hull indices
            hull_prev[i] = e;
            hull_start = e;
            hull_prev[next] = i;
            hull_next[e] = i;
            hull_next[i] = next;

            m_hash[hash_key(x, y)] = i;
            m_hash[hash_key(coords[2 * e], coords[2 * e + 1])] = e;
        }
    }

    template<std::floating_point T>
    T Delaunator<T>::get_hull_area() {
        std::vector<double> hull_area;
        size_t e = hull_start;
        do {
            hull_area.push_back((coords[2 * e] - coords[2 * hull_prev[e]]) * (coords[2 * e + 1] + coords[2 * hull_prev[e] + 1]));
            e = hull_next[e];
        } while (e != hull_start);
        return sum(hull_area);
    }

    template<std::floating_point T>
    std::size_t Delaunator<T>::legalize(std::size_t a) {
        std::size_t i = 0;
        std::size_t ar = 0;
        m_edge_stack.clear();

        // recursion eliminated with a fixed-size stack
        while (true) {
            const size_t b = halfedges[a];

            /* if the pair of triangles doesn't satisfy the Delaunay condition
            * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
            * then do the same check/flip recursively for the new pair of triangles
            *
            *           pl                    pl
            *          /||\                  /  \
            *       al/ || \bl            al/    \a
            *        /  ||  \              /      \
            *       /  a||b  \    flip    /___ar___\
            *     p0\   ||   /p1   =>   p0\---bl---/p1
            *        \  ||  /              \      /
            *       ar\ || /br             b\    /br
            *          \||/                  \  /
            *           pr                    pr
            */
            const size_t a0 = 3 * (a / 3);
            ar = a0 + (a + 2) % 3;

            if (b == INVALID_INDEX) {
                if (i > 0) {
                    i--;
                    a = m_edge_stack[i];
                    continue;
                }
                else {
                    //i = INVALID_INDEX;
                    break;
                }
            }

            const size_t b0 = 3 * (b / 3);
            const size_t al = a0 + (a + 1) % 3;
            const size_t bl = b0 + (b + 2) % 3;

            const std::size_t p0 = triangles[ar];
            const std::size_t pr = triangles[a];
            const std::size_t pl = triangles[al];
            const std::size_t p1 = triangles[bl];

            const bool illegal = in_circle(
                coords[2 * p0],
                coords[2 * p0 + 1],
                coords[2 * pr],
                coords[2 * pr + 1],
                coords[2 * pl],
                coords[2 * pl + 1],
                coords[2 * p1],
                coords[2 * p1 + 1]);

            if (illegal) {
                triangles[a] = p1;
                triangles[b] = p0;

                auto hbl = halfedges[bl];

                // edge swapped on the other side of the hull (rare); fix the halfedge reference
                if (hbl == INVALID_INDEX) {
                    std::size_t e = hull_start;
                    do {
                        if (hull_tri[e] == bl) {
                            hull_tri[e] = a;
                            break;
                        }
                        e = hull_next[e];
                    } while (e != hull_start);
                }
                link(a, hbl);
                link(b, halfedges[ar]);
                link(ar, bl);
                std::size_t br = b0 + (b + 1) % 3;

                if (i < m_edge_stack.size()) {
                    m_edge_stack[i] = br;
                }
                else {
                    m_edge_stack.push_back(br);
                }
                i++;

            }
            else {
                if (i > 0) {
                    i--;
                    a = m_edge_stack[i];
                    continue;
                }
                else {
                    break;
                }
            }
        }
        return ar;
    }

    template<std::floating_point T>
    inline std::size_t Delaunator<T>::hash_key(const T x, const T y) const {
        const T dx = x - m_center_x;
        const T dy = y - m_center_y;
        return fast_mod(
            static_cast<std::size_t>(std::llround(std::floor(pseudo_angle(dx, dy) * static_cast<T>(m_hash_size)))),
            m_hash_size);
    }

    template<std::floating_point T>
    std::size_t Delaunator<T>::add_triangle(
        std::size_t i0,
        std::size_t i1,
        std::size_t i2,
        std::size_t a,
        std::size_t b,
        std::size_t c) {
        std::size_t t = triangles.size();
        triangles.push_back(i0);
        triangles.push_back(i1);
        triangles.push_back(i2);
        link(t, a);
        link(t + 1, b);
        link(t + 2, c);
        return t;
    }

    template<std::floating_point T>
    void Delaunator<T>::link(const std::size_t a, const std::size_t b) {
        std::size_t s = halfedges.size();
        if (a == s) {
            halfedges.push_back(b);
        }
        else if (a < s) {
            halfedges[a] = b;
        }
        else {
            throw std::runtime_error("Cannot link edge");
        }
        if (b != INVALID_INDEX) {
            std::size_t s2 = halfedges.size();
            if (b == s2) {
                halfedges.push_back(a);
            }
            else if (b < s2) {
                halfedges[b] = a;
            }
            else {
                throw std::runtime_error("Cannot link edge");
            }
        }
    }

} //namespace delaunator
```

`hack/deps/magic_enum/prettyNames.hpp`:

```hpp
#pragma once

#include <magic_enum.hpp>

// Returns a copy of enum_names() as std::array<std::string, SIZE> with "pretty name"
   // pretty name means:
   // MY_NAME -> My name
   // OKAYLONG -> Okaylong
namespace magic_enum {
    template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
    [[nodiscard]] constexpr auto enum_names_pretty() noexcept {
        constexpr auto ctoLower = [](char c) noexcept {
            return (c >= 'A' && c <= 'Z') ? static_cast<char>(c + ('a' - 'A')) : c;
        };

        constexpr auto view_arr = detail::names_v<std::decay_t<E>, S>;
        std::array<std::string, view_arr.size()> pretty;

        for (size_t i = 0; i < view_arr.size(); i++) {
            std::string name{ view_arr[i].data(), view_arr[i].length() };
            for (size_t sign = 1; sign < name.length(); sign++) {
                name[sign] = ctoLower(name[sign]);

                if (name[sign] == '_')
                    name[sign] = ' ';
            }
            pretty[i] = name;
        }

        return pretty;
    }
}
```

`hack/deps/mem/aligned_alloc.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_ALIGNED_ALLOC_BRICK_H
#define MEM_ALIGNED_ALLOC_BRICK_H

#include "defines.h"

#include <memory>

#if defined(_WIN32)
#    include <malloc.h>
#else
#    include <cstdlib>
#endif

namespace mem
{
    void* aligned_alloc(std::size_t size, std::size_t alignment);
    void aligned_free(void* address);

    MEM_STRONG_INLINE void* aligned_alloc(std::size_t size, std::size_t alignment)
    {
#if defined(_WIN32)
        return _aligned_malloc(size, alignment);
#elif (_POSIX_C_SOURCE >= 200112L)
        void* result = nullptr;

        if (posix_memalign(&result, size, alignment) != 0)
        {
            return nullptr;
        }

        return result;
#else
        const std::size_t max_offset = alignment - 1 + sizeof(void*);
        void* result = std::malloc(size + max_offset);

        if (result)
        {
            void* aligned_result = reinterpret_cast<void*>(
                (reinterpret_cast<std::uintptr_t>(result) + max_offset) / alignment * alignment);
            reinterpret_cast<void**>(aligned_result)[-1] = result;
            result = aligned_result;
        }

        return result;
#endif
    }

    MEM_STRONG_INLINE void aligned_free(void* address)
    {
        if (!address)
        {
            return;
        }

#if defined(_WIN32)
        _aligned_free(address);
#elif (_POSIX_C_SOURCE >= 200112L)
        free(address);
#else
        std::free(reinterpret_cast<void**>(address)[-1]);
#endif
    }
} // namespace mem

#endif // MEM_ALIGNED_ALLOC_BRICK_H

```

`hack/deps/mem/arch.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_ARCH_BRICK_H
#define MEM_ARCH_BRICK_H

#include "defines.h"

#if defined(MEM_ARCH_X86) || defined(MEM_ARCH_X86_64)
#    if defined(_MSC_VER)
#        include <intrin.h>
#        pragma intrinsic(__rdtsc)
#        pragma intrinsic(_BitScanForward)
#    else
#        include <x86intrin.h>
#    endif
#endif

namespace mem
{
#if defined(MEM_ARCH_X86) || defined(MEM_ARCH_X86_64)
    MEM_STRONG_INLINE std::uint64_t rdtsc() noexcept
    {
        return __rdtsc();
    }

    MEM_STRONG_INLINE unsigned int bsf(unsigned int x) noexcept
    {
#    if defined(__GNUC__) && ((__GNUC__ >= 4) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4)))
        return static_cast<unsigned int>(__builtin_ctz(x));
#    elif defined(_MSC_VER)
        unsigned long result;
        _BitScanForward(&result, static_cast<unsigned long>(x));
        return static_cast<unsigned int>(result);
#    else
        unsigned int result;
        asm("bsf %1, %0" : "=r"(result) : "rm"(x));
        return result;
#    endif
    }
#endif
} // namespace mem

#endif // MEM_ARCH_BRICK_H

```

`hack/deps/mem/bitwise_enum.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_BITWISE_ENUM_BRICK_H
#define MEM_BITWISE_ENUM_BRICK_H

#include "defines.h"

#include <type_traits>

#define MEM_DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE)                                              \
    MEM_STRONG_INLINE constexpr ENUMTYPE operator|(ENUMTYPE a, ENUMTYPE b) noexcept           \
    {                                                                                         \
        return static_cast<ENUMTYPE>(static_cast<std::underlying_type<ENUMTYPE>::type>(a) |   \
            static_cast<std::underlying_type<ENUMTYPE>::type>(b));                            \
    }                                                                                         \
    MEM_STRONG_INLINE MEM_CONSTEXPR_14 ENUMTYPE& operator|=(ENUMTYPE& a, ENUMTYPE b) noexcept \
    {                                                                                         \
        return a = a | b;                                                                     \
    }                                                                                         \
    MEM_STRONG_INLINE constexpr ENUMTYPE operator&(ENUMTYPE a, ENUMTYPE b) noexcept           \
    {                                                                                         \
        return static_cast<ENUMTYPE>(static_cast<std::underlying_type<ENUMTYPE>::type>(a) &   \
            static_cast<std::underlying_type<ENUMTYPE>::type>(b));                            \
    }                                                                                         \
    MEM_STRONG_INLINE MEM_CONSTEXPR_14 ENUMTYPE& operator&=(ENUMTYPE& a, ENUMTYPE b) noexcept \
    {                                                                                         \
        return a = a & b;                                                                     \
    }                                                                                         \
    MEM_STRONG_INLINE constexpr ENUMTYPE operator^(ENUMTYPE a, ENUMTYPE b) noexcept           \
    {                                                                                         \
        return static_cast<ENUMTYPE>(static_cast<std::underlying_type<ENUMTYPE>::type>(a) ^   \
            static_cast<std::underlying_type<ENUMTYPE>::type>(b));                            \
    }                                                                                         \
    MEM_STRONG_INLINE MEM_CONSTEXPR_14 ENUMTYPE& operator^=(ENUMTYPE& a, ENUMTYPE b) noexcept \
    {                                                                                         \
        return a = a ^ b;                                                                     \
    }                                                                                         \
    MEM_STRONG_INLINE constexpr ENUMTYPE operator~(ENUMTYPE a) noexcept                       \
    {                                                                                         \
        return static_cast<ENUMTYPE>(~static_cast<std::underlying_type<ENUMTYPE>::type>(a));  \
    }

#endif // MEM_BITWISE_ENUM_BRICK_H

```

`hack/deps/mem/boyer_moore_scanner.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_BOYER_MOORE_SCANNER_BRICK_H
#define MEM_BOYER_MOORE_SCANNER_BRICK_H

#include "pattern.h"

namespace mem
{
    class boyer_moore_scanner : public scanner_base<boyer_moore_scanner>
    {
    private:
        const pattern* pattern_ {nullptr};

        // Boyer–Moore + Boyer–Moore–Horspool Implementation
        std::vector<std::size_t> bc_skips_ {};
        std::vector<std::size_t> gs_skips_ {};

        std::size_t skip_pos_ {SIZE_MAX};

        std::size_t get_longest_run(std::size_t& length) const;

        bool is_prefix(std::size_t pos) const;
        std::size_t get_suffix_length(std::size_t pos) const;

    public:
        boyer_moore_scanner() = default;

        boyer_moore_scanner(const pattern& pattern);
        boyer_moore_scanner(const pattern& pattern, std::size_t min_bc_skip, std::size_t min_gs_skip);

        pointer scan(region range) const;
    };

    static constexpr const std::size_t default_min_bc_skip {5};
    static constexpr const std::size_t default_min_gs_skip {25};

    inline boyer_moore_scanner::boyer_moore_scanner(const pattern& _pattern)
        : boyer_moore_scanner(_pattern, default_min_bc_skip, default_min_gs_skip)
    {}

    inline boyer_moore_scanner::boyer_moore_scanner(
        const pattern& _pattern, std::size_t min_bc_skip, std::size_t min_gs_skip)
        : pattern_(&_pattern)
    {
        std::size_t max_skip = 0;
        std::size_t skip_pos = get_longest_run(max_skip);

        const byte* const bytes = pattern_->bytes();
        const std::size_t trimmed_size = pattern_->trimmed_size();

        if ((min_bc_skip > 0) && (max_skip >= min_bc_skip))
        {
            bc_skips_.resize(256, max_skip);
            skip_pos_ = skip_pos + max_skip - 1;

            for (std::size_t i = skip_pos, last = skip_pos + max_skip - 1; i < last; ++i)
                bc_skips_[bytes[i]] = last - i;

            if ((skip_pos == 0) && (max_skip == trimmed_size) && (min_gs_skip > 0) && (max_skip >= min_gs_skip))
            {
                gs_skips_.resize(trimmed_size);

                const std::size_t last = trimmed_size - 1;

                std::size_t last_prefix = last;

                for (std::size_t i = trimmed_size; i--;)
                {
                    if (is_prefix(i + 1))
                        last_prefix = i + 1;

                    gs_skips_[i] = last_prefix + (last - i);
                }

                for (std::size_t i = 0; i < last; ++i)
                {
                    std::size_t suffix_length = get_suffix_length(i);
                    std::size_t pos = last - suffix_length;

                    if (bytes[i - suffix_length] != bytes[pos])
                        gs_skips_[pos] = suffix_length + (last - i);
                }
            }
            else
            {
                bc_skips_[bytes[skip_pos_]] = 0;
            }
        }
    }

    inline std::size_t boyer_moore_scanner::get_longest_run(std::size_t& length) const
    {
        std::size_t max_skip = 0;
        std::size_t skip_pos = 0;

        std::size_t current_skip = 0;

        const byte* const masks = pattern_->masks();

        for (std::size_t i = 0; i < pattern_->trimmed_size(); ++i)
        {
            if (masks[i] != 0xFF)
            {
                if (current_skip > max_skip)
                {
                    max_skip = current_skip;
                    skip_pos = i - current_skip;
                }

                current_skip = 0;
            }
            else
            {
                ++current_skip;
            }
        }

        if (current_skip > max_skip)
        {
            max_skip = current_skip;
            skip_pos = pattern_->trimmed_size() - current_skip;
        }

        length = max_skip;

        return skip_pos;
    }

    inline bool boyer_moore_scanner::is_prefix(std::size_t pos) const
    {
        const std::size_t suffix_length = pattern_->trimmed_size() - pos;

        const byte* const bytes = pattern_->bytes();

        for (std::size_t i = 0; i < suffix_length; ++i)
            if (bytes[i] != bytes[pos + i])
                return false;

        return true;
    }

    inline std::size_t boyer_moore_scanner::get_suffix_length(std::size_t pos) const
    {
        const std::size_t last = pattern_->trimmed_size() - 1;

        const byte* const bytes = pattern_->bytes();

        std::size_t i = 0;

        while ((i < pos) && (bytes[pos - i] == bytes[last - i]))
            ++i;

        return i;
    }

    inline pointer boyer_moore_scanner::scan(region range) const
    {
        const std::size_t trimmed_size = pattern_->trimmed_size();

        if (!trimmed_size)
            return nullptr;

        const std::size_t original_size = pattern_->size();
        const std::size_t region_size = range.size;

        if (original_size > region_size)
            return nullptr;

        const byte* const region_base = range.start.as<const byte*>();
        const byte* const region_end = region_base + region_size;

        const byte* current = region_base;
        const byte* const end = region_end - original_size + 1;

        const std::size_t last = trimmed_size - 1;

        const byte* const pat_bytes = pattern_->bytes();
        const std::size_t* const pat_skips = !bc_skips_.empty() ? bc_skips_.data() : nullptr;

        if (pattern_->needs_masks())
        {
            const byte* const pat_masks = pattern_->masks();

            if (pat_skips)
            {
                const std::size_t pat_skip_pos = skip_pos_;

                while (MEM_LIKELY(current < end))
                {
                    [[MEM_ATTR_LIKELY]];

                    std::size_t skip = pat_skips[current[pat_skip_pos]];
                    current += skip;

                    if (MEM_LIKELY(skip != 0)) [[MEM_ATTR_LIKELY]]
                        continue;

                    for (std::size_t i = last; MEM_LIKELY((current[i] & pat_masks[i]) == pat_bytes[i]); --i)
                    {
                        [[MEM_ATTR_LIKELY]];

                        if (MEM_UNLIKELY(i == 0)) [[MEM_ATTR_UNLIKELY]]
                            return current;
                    }

                    ++current;
                }

                return nullptr;
            }
            else
            {
                while (MEM_LIKELY(current < end))
                {
                    [[MEM_ATTR_LIKELY]];

                    for (std::size_t i = last; MEM_LIKELY((current[i] & pat_masks[i]) == pat_bytes[i]); --i)

                    {
                        [[MEM_ATTR_LIKELY]];

                        if (MEM_UNLIKELY(i == 0)) [[MEM_ATTR_UNLIKELY]]
                            return current;
                    }

                    ++current;
                }

                return nullptr;
            }
        }
        else
        {
            if (pat_skips && !gs_skips_.empty())
            {
                const std::size_t* const pat_suffixes = gs_skips_.data();

                current += last;
                const byte* const end_plus_last = end + last;

                while (MEM_LIKELY(current < end_plus_last))
                {
                    [[MEM_ATTR_LIKELY]];

                    std::size_t i = last;

                    while (MEM_LIKELY(*current == pat_bytes[i]))
                    {
                        [[MEM_ATTR_LIKELY]];

                        if (MEM_UNLIKELY(i == 0)) [[MEM_ATTR_UNLIKELY]]
                            return current;

                        --current;
                        --i;
                    }

                    const std::size_t bc_skip = pat_skips[*current];
                    const std::size_t gs_skip = pat_suffixes[i];

                    current += (bc_skip > gs_skip) ? bc_skip : gs_skip;
                }

                return nullptr;
            }
            else if (pat_skips)
            {
                while (MEM_LIKELY(current < end))
                {
                    [[MEM_ATTR_LIKELY]];

                    std::size_t skip = pat_skips[current[last]];
                    current += skip;

                    if (MEM_LIKELY(skip != 0)) [[MEM_ATTR_LIKELY]]
                        continue;

                    for (std::size_t i = last; MEM_LIKELY(current[i] == pat_bytes[i]); --i)
                    {
                        [[MEM_ATTR_LIKELY]];

                        if (MEM_UNLIKELY(i == 0)) [[MEM_ATTR_UNLIKELY]]
                            return current;
                    }

                    ++current;
                }

                return nullptr;
            }
            else
            {
                while (MEM_LIKELY(current < end))
                {
                    [[MEM_ATTR_LIKELY]];

                    for (std::size_t i = last; MEM_LIKELY(current[i] == pat_bytes[i]); --i)
                    {
                        [[MEM_ATTR_LIKELY]];

                        if (MEM_UNLIKELY(i == 0)) [[MEM_ATTR_UNLIKELY]]
                            return current;
                    }

                    ++current;
                }

                return nullptr;
            }
        }
    }
} // namespace mem

#endif // MEM_BOYER_MOORE_SCANNER_BRICK_H

```

`hack/deps/mem/char_queue.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_CHAR_QUEUE_BRICK_H
#define MEM_CHAR_QUEUE_BRICK_H

#include "defines.h"

#include <cstring>

namespace mem
{
    class char_queue
    {
    private:
        const char* start {nullptr};
        const char* end {nullptr};
        const char* current {nullptr};

    public:
        char_queue(const char* string);
        constexpr char_queue(const char* string, std::size_t length);

        constexpr int peek() const noexcept;

        MEM_CONSTEXPR_14 void pop() noexcept;
        constexpr std::size_t pos() const noexcept;

        constexpr explicit operator bool() const noexcept;
    };

    constexpr int xctoi(int value) noexcept;
    constexpr int dctoi(int value) noexcept;
    constexpr int octoi(int value) noexcept;

    MEM_STRONG_INLINE char_queue::char_queue(const char* string)
        : char_queue(string, std::strlen(string))
    {}

    MEM_STRONG_INLINE constexpr char_queue::char_queue(const char* string, std::size_t length)
        : start(string)
        , end(start + length)
        , current(start)
    {}

    MEM_STRONG_INLINE constexpr int char_queue::peek() const noexcept
    {
        return (current < end) ? static_cast<byte>(*current) : -1;
    }

    MEM_STRONG_INLINE MEM_CONSTEXPR_14 void char_queue::pop() noexcept
    {
        if (current < end)
        {
            ++current;
        }
    }

    MEM_STRONG_INLINE constexpr std::size_t char_queue::pos() const noexcept
    {
        return static_cast<std::size_t>(current - start);
    }

    MEM_STRONG_INLINE constexpr char_queue::operator bool() const noexcept
    {
        return current < end;
    }

    MEM_STRONG_INLINE constexpr int xctoi(int value) noexcept
    { // clang-format off
        return (value >= '0' && value <= '9') ? (value - '0')
             : (value >= 'a' && value <= 'f') ? (value - 'a' + 10)
             : (value >= 'A' && value <= 'F') ? (value - 'A' + 10)
             : -1;
    } // clang-format on

    MEM_STRONG_INLINE constexpr int dctoi(int value) noexcept
    {
        return (value >= '0' && value <= '9') ? (value - '0') : -1;
    }

    MEM_STRONG_INLINE constexpr int octoi(int value) noexcept
    {
        return (value >= '0' && value <= '7') ? (value - '0') : -1;
    }
} // namespace mem

#endif // MEM_CHAR_QUEUE_BRICK_H

```

`hack/deps/mem/cmd_param-inl.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#if defined(MEM_CMD_PARAM_INL_BRICK_H)
#    error mem/cmd_param-inl.h should only be included once
#endif // MEM_CMD_PARAM_INL_BRICK_H

#define MEM_CMD_PARAM_INL_BRICK_H

#if !defined(CMD_ALLOC_BUFFER_CAPACITY)
#    define CMD_ALLOC_BUFFER_CAPACITY 0x1000
#endif

#include "cmd_param.h"

#include <cctype>
#include <cstring>

namespace mem
{
    cmd_param* cmd_param::ROOT {nullptr};

    static inline bool cmd_is_option(const char* arg)
    {
        return (arg[0] == '-') && (static_cast<unsigned char>(arg[1] - '0') > 9);
    }

    static inline bool cmd_chr_equal(char lhs, char rhs)
    {
        const char x = rhs ^ lhs;

        return (x == 0) || ((x == 0x20) && (static_cast<unsigned char>((lhs | 0x20) - 'a') < 26));
    }

    static char cmd_alloc_buffer[CMD_ALLOC_BUFFER_CAPACITY];
    static std::size_t cmd_alloc_buffer_len {0};

    static char* cmd_strdup(const char* value, std::size_t len)
    {
        if (cmd_alloc_buffer_len + len >= CMD_ALLOC_BUFFER_CAPACITY)
            return nullptr;

        char* result = &cmd_alloc_buffer[cmd_alloc_buffer_len];
        std::memcpy(result, value, len);
        result[len] = '\0';

        cmd_alloc_buffer_len += len + 1;

        return result;
    }

    static char* cmd_unquote(const char* arg)
    {
        std::size_t len = std::strlen(arg);

        if (arg[0] == '"')
        {
            ++arg;
            --len;

            if (arg[len - 1] == '"')
                --len;
        }

        return cmd_strdup(arg, len);
    }

    static bool cmd_arg_equal(const char* lhs, const char* rhs)
    {
        while (true)
        {
            char a = *lhs++;
            char b = *rhs++;

            if (a == '\0')
                return (b == '\0') || (b == '=');

            if (!cmd_chr_equal(a, b))
                return false;
        }
    }

    void cmd_param::init(const char* const* argv)
    {
        int argc = 0;

        while (argv[argc])
            ++argc;

        init(argc, argv);
    }

    void cmd_param::init(int argc, const char* const* argv)
    {
        bool done_positionals = false;

        for (int i = 1; i < argc; ++i)
        {
            const char* arg = argv[i];

            if (cmd_is_option(arg))
            {
                while (arg[0] == '-')
                    ++arg;

                done_positionals = true;

                const char* value = nullptr;

                for (cmd_param* j = ROOT; j; j = j->next_)
                {
                    if (!j->name_ || !cmd_arg_equal(j->name_, arg))
                        continue;

                    if (!value)
                    {
                        if (const char* val = std::strchr(arg, '='))
                            value = cmd_unquote(val + 1);
                        else if (i + 1 < argc && !cmd_is_option(argv[i + 1]))
                            value = cmd_unquote(argv[i + 1]);

                        if (!value)
                            value = "1";
                    }

                    j->value_ = value;
                }

                if (!value)
                {
                    for (cmd_param* j = ROOT; j; j = j->next_)
                    {
                        if (!j->name_)
                            continue;

                        // clang-format off
                        if ((!std::strncmp("no", arg,      2) && cmd_arg_equal(j->name_, arg + 2)) ||
                            (!std::strncmp("no", j->name_, 2) && cmd_arg_equal(j->name_ + 2, arg)))
                            j->value_ = "0";
                        // clang-format on
                    }
                }
            }
            else if (!done_positionals)
            {
                const char* value = nullptr;

                for (cmd_param* j = ROOT; j; j = j->next_)
                {
                    if (j->pos_ != i)
                        continue;

                    if (!value)
                    {
                        value = cmd_unquote(arg);

                        if (!value)
                            value = "";
                    }

                    j->value_ = value;
                }
            }
        }
    }

    void cmd_param::reset()
    {
        for (cmd_param* j = ROOT; j; j = j->next_)
            j->value_ = nullptr;

        cmd_alloc_buffer_len = 0;
    }
} // namespace mem

```

`hack/deps/mem/cmd_param.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_CMD_PARAM_BRICK_H
#define MEM_CMD_PARAM_BRICK_H

#include "defines.h"

#include <cstdlib>

#include <istream>
#include <streambuf>

namespace mem
{
    class cmd_param
    {
    public:
        cmd_param(const char* name, int pos = 0) noexcept;
        ~cmd_param();

        cmd_param(const cmd_param&) = delete;
        cmd_param(cmd_param&&) = delete;

        template <typename T = const char*>
        T get() const;

        template <typename T>
        bool get(T& out) const;

        template <typename T>
        T get_or(T value) const;

        explicit operator bool() const;

        static void init(const char* const* argv);
        static void init(int argc, const char* const* argv);
        static void reset();

    private:
        const char* name_ {nullptr};
        int pos_ {0};
        const char* value_ {nullptr};
        cmd_param* next_ {nullptr};

        static cmd_param* ROOT;
    };

    MEM_STRONG_INLINE cmd_param::cmd_param(const char* name, int pos) noexcept
        : name_(name)
        , pos_(pos)
        , next_(ROOT)
    {
        ROOT = this;
    }

    inline cmd_param::~cmd_param()
    {
        for (cmd_param** i = &ROOT; *i; i = &(*i)->next_)
        {
            if (*i == this)
            {
                *i = next_;

                break;
            }
        }
    }

    namespace internal
    {
        template <typename T>
        class fixed_basic_streambuf final : public std::basic_streambuf<T>
        {
        public:
            fixed_basic_streambuf(const T* ptr, std::size_t num)
            {
                T* source = const_cast<T*>(ptr);

                std::basic_streambuf<T>::setg(source, source, source + num);
            }
        };

        using fixed_streambuf = fixed_basic_streambuf<char>;
    } // namespace internal

    template <typename T>
    MEM_STRONG_INLINE bool parse_cmd(const char* value, T& out)
    {
        internal::fixed_streambuf buf(value, std::strlen(value));

        std::istream strm(&buf);

        strm >> out;

        return strm.good();
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<bool>(const char* value, bool& out)
    {
        if (!std::strcmp(value, "false") || !std::strcmp(value, "0"))
        {
            out = false;
        }
        else
        {
            out = true;
        }

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<short>(const char* value, short& out)
    {
        out = static_cast<short>(std::strtol(value, nullptr, 0));

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<unsigned short>(const char* value, unsigned short& out)
    {
        out = static_cast<unsigned short>(std::strtoul(value, nullptr, 0));

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<int>(const char* value, int& out)
    {
        out = static_cast<int>(std::strtol(value, nullptr, 0));

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<unsigned int>(const char* value, unsigned int& out)
    {
        out = static_cast<unsigned int>(std::strtoul(value, nullptr, 0));

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<long>(const char* value, long& out)
    {
        out = std::strtol(value, nullptr, 0);

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<unsigned long>(const char* value, unsigned long& out)
    {
        out = std::strtoul(value, nullptr, 0);

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<long long>(const char* value, long long& out)
    {
        out = std::strtoll(value, nullptr, 0);

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<unsigned long long>(const char* value, unsigned long long& out)
    {
        out = std::strtoull(value, nullptr, 0);

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<float>(const char* value, float& out)
    {
        out = std::strtof(value, nullptr);

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<double>(const char* value, double& out)
    {
        out = std::strtod(value, nullptr);

        return true;
    }

    template <>
    MEM_STRONG_INLINE bool parse_cmd<long double>(const char* value, long double& out)
    {
        out = std::strtold(value, nullptr);

        return true;
    }

    template <>
    MEM_STRONG_INLINE const char* cmd_param::get<const char*>() const
    {
        return value_;
    }

    template <>
    MEM_STRONG_INLINE bool cmd_param::get<bool>() const
    {
        bool result = false;

        if (value_)
        {
            parse_cmd(value_, result);
        }

        return result;
    }

    template <typename T>
    MEM_STRONG_INLINE bool cmd_param::get(T& out) const
    {
        if (value_)
        {
            return parse_cmd(value_, out);
        }

        return false;
    }

    template <typename T>
    MEM_STRONG_INLINE T cmd_param::get_or(T value) const
    {
        if (value_)
        {
            parse_cmd(value_, value);
        }

        return value;
    }

    MEM_STRONG_INLINE cmd_param::operator bool() const
    {
        return get<bool>();
    }
} // namespace mem

#endif // MEM_CMD_PARAM_BRICK_H

```

`hack/deps/mem/cpp.hint`:

```hint
#define MEM_CONSTEXPR_14

#define MEM_STRONG_INLINE
#define MEM_NOINLINE

```

`hack/deps/mem/data_buffer.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_DATA_BUFFER_BRICK_H
#define MEM_DATA_BUFFER_BRICK_H

#include "defines.h"

#include <cstdlib>
#include <cstring>

#include <type_traits>

namespace mem
{
    template <typename T>
    class data_buffer
    {
    private:
        static_assert(std::is_trivial<T>::value, "Type is not trivially copyable");

        T* data_ {nullptr};
        std::size_t size_ {0};
        std::size_t capacity_ {0};

        std::size_t calculate_growth(std::size_t new_size) const noexcept;
        void reallocate(std::size_t length);

    public:
        data_buffer() noexcept = default;

        data_buffer(std::size_t length);

        data_buffer(const data_buffer& other);
        data_buffer(data_buffer&& other) noexcept;

        ~data_buffer();

        data_buffer& operator=(const data_buffer& other);
        data_buffer& operator=(data_buffer&& other);

        void swap(data_buffer& other) noexcept;

        void reserve(std::size_t length);
        void resize(std::size_t length);
        void reset(std::size_t length = 0);

        void assign(const T* source, std::size_t length);
        void append(const T* source, std::size_t length);

        void push_back(const T& value);

        void clear() noexcept;
        void shrink_to_fit();

        T& operator[](std::size_t index) noexcept;
        const T& operator[](std::size_t index) const noexcept;

        T* data() noexcept;
        T* begin() noexcept;
        T* end() noexcept;

        const T* data() const noexcept;
        const T* begin() const noexcept;
        const T* end() const noexcept;

        std::size_t size() const noexcept;
        std::size_t capacity() const noexcept;
        bool empty() const noexcept;

        using value_type = T;

        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;

        using reference = value_type&;
        using const_reference = const value_type&;

        using pointer = value_type*;
        using const_pointer = const value_type*;

        using iterator = value_type*;
        using const_iterator = const value_type*;
    };

    using byte_buffer = data_buffer<byte>;

    template <typename T>
    inline data_buffer<T>::data_buffer(std::size_t length)
    {
        resize(length);
    }

    template <typename T>
    inline data_buffer<T>::data_buffer(const data_buffer<T>& other)
    {
        if (this != &other)
        {
            assign(other.data(), other.size());
        }
    }

    template <typename T>
    inline data_buffer<T>::data_buffer(data_buffer<T>&& other) noexcept
    {
        if (this != &other)
        {
            swap(other);
        }
    }

    template <typename T>
    inline data_buffer<T>::~data_buffer()
    {
        clear();
    }

    template <typename T>
    inline data_buffer<T>& data_buffer<T>::operator=(const data_buffer<T>& other)
    {
        if (this != &other)
        {
            assign(other.data(), other.size());
        }

        return *this;
    }

    template <typename T>
    inline data_buffer<T>& data_buffer<T>::operator=(data_buffer<T>&& other)
    {
        if (this != &other)
        {
            clear();

            swap(other);
        }

        return *this;
    }

    template <typename T>
    inline std::size_t data_buffer<T>::calculate_growth(std::size_t new_size) const noexcept
    {
        std::size_t old_capacity = capacity();

        if (new_size > old_capacity)
        {
            std::size_t new_capacity = old_capacity + (old_capacity >> 1);

            if (new_capacity < new_size)
            {
                new_capacity = new_size;
            }

            return new_capacity;
        }
        else
        {
            return old_capacity;
        }
    }

    template <typename T>
    inline void data_buffer<T>::reallocate(std::size_t length)
    {
        if (length != capacity_)
        {
            void* new_data = nullptr;

            if (length)
            {
                new_data = std::realloc(data_, length * sizeof(T));

                if (new_data == nullptr)
                {
                    std::abort();
                }
            }
            else
            {
                std::free(data_);
            }

            data_ = static_cast<T*>(new_data);
            capacity_ = length;

            if (size_ > capacity_)
            {
                size_ = capacity_;
            }
        }
    }

    template <typename T>
    inline void data_buffer<T>::swap(data_buffer<T>& other) noexcept
    {
        if (this != &other)
        {
            T* temp_data = data_;
            std::size_t temp_size = size_;
            std::size_t temp_capacity = capacity_;

            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;

            other.data_ = temp_data;
            other.size_ = temp_size;
            other.capacity_ = temp_capacity;
        }
    }

    template <typename T>
    inline void data_buffer<T>::reserve(std::size_t length)
    {
        if (length > capacity_)
        {
            reallocate(length);
        }
    }

    template <typename T>
    inline void data_buffer<T>::resize(std::size_t length)
    {
        reallocate(length);

        size_ = length;
    }

    template <typename T>
    inline void data_buffer<T>::reset(std::size_t length)
    {
        clear();

        resize(length);
    }

    template <typename T>
    inline void data_buffer<T>::assign(const T* source, std::size_t length)
    {
        clear();

        append(source, length);
    }

    template <typename T>
    inline void data_buffer<T>::append(const T* source, std::size_t length)
    {
        std::size_t old_size = size_;
        std::size_t new_size = old_size + length;

        reserve(calculate_growth(new_size));
        std::memcpy(data_ + old_size, source, length * sizeof(T));

        size_ = new_size;
    }

    template <typename T>
    inline void data_buffer<T>::push_back(const T& value)
    {
        append(&value, 1);
    }

    template <typename T>
    inline void data_buffer<T>::clear() noexcept
    {
        size_ = 0;
    }

    template <typename T>
    inline void data_buffer<T>::shrink_to_fit()
    {
        resize(size_);
    }

    template <typename T>
    inline T& data_buffer<T>::operator[](std::size_t index) noexcept
    {
        return data_[index];
    }

    template <typename T>
    inline const T& data_buffer<T>::operator[](std::size_t index) const noexcept
    {
        return data_[index];
    }

    template <typename T>
    inline T* data_buffer<T>::data() noexcept
    {
        return data_;
    }

    template <typename T>
    inline T* data_buffer<T>::begin() noexcept
    {
        return data_;
    }

    template <typename T>
    inline T* data_buffer<T>::end() noexcept
    {
        return data_ + size_;
    }

    template <typename T>
    inline const T* data_buffer<T>::data() const noexcept
    {
        return data_;
    }

    template <typename T>
    inline const T* data_buffer<T>::begin() const noexcept
    {
        return data_;
    }

    template <typename T>
    inline const T* data_buffer<T>::end() const noexcept
    {
        return data_ + size_;
    }

    template <typename T>
    inline std::size_t data_buffer<T>::size() const noexcept
    {
        return size_;
    }

    template <typename T>
    inline std::size_t data_buffer<T>::capacity() const noexcept
    {
        return capacity_;
    }

    template <typename T>
    inline bool data_buffer<T>::empty() const noexcept
    {
        return size_ == 0;
    }
} // namespace mem

#endif // MEM_DATA_BUFFER_BRICK_H

```

`hack/deps/mem/defines.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_DEFINES_BRICK_H
#define MEM_DEFINES_BRICK_H

#if defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)
#    define MEM_ARCH_X86_64
#elif defined(__i386) || defined(_M_IX86)
#    define MEM_ARCH_X86
#endif

#if defined(__AVX2__)
#    define MEM_SIMD_AVX2
#endif

#if defined(__AVX__) || defined(MEM_SIMD_AVX2)
#    define MEM_SIMD_AVX
#endif

#if defined(__SSSE3__) || defined(MEM_SIMD_AVX)
#    define MEM_SIMD_SSSE3
#endif

#if defined(__SSE3__) || defined(_M_AMD64) || defined(_M_X64) || (defined(_M_IX86_FP) && (_M_IX86_FP == 2)) || \
    defined(MEM_SIMD_SSSE3)
#    define MEM_SIMD_SSE3
#endif

#if defined(__SSE2__) || defined(_M_AMD64) || defined(_M_X64) || (defined(_M_IX86_FP) && (_M_IX86_FP == 2)) || \
    defined(MEM_SIMD_SSE3)
#    define MEM_SIMD_SSE2
#endif

#if defined(__SSE__) || (defined(_M_IX86_FP) && (_M_IX86_FP == 1)) || defined(MEM_SIMD_SSE2)
#    define MEM_SIMD_SSE
#endif

#if !defined(MEM_CONSTEXPR_14)
#    if (defined(__cpp_constexpr) && (__cpp_constexpr >= 201304)) || \
        (defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 191426433))
#        define MEM_CONSTEXPR_14 constexpr
#    else
#        define MEM_CONSTEXPR_14
#    endif
#endif

#if defined(__GNUC__) || defined(__clang__)
#    define MEM_LIKELY(x) __builtin_expect(static_cast<bool>(x), 1)
#    define MEM_UNLIKELY(x) __builtin_expect(static_cast<bool>(x), 0)
#else
#    define MEM_LIKELY(x) static_cast<bool>(x)
#    define MEM_UNLIKELY(x) static_cast<bool>(x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#    define MEM_STRONG_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
#    define MEM_STRONG_INLINE __pragma(warning(suppress : 4714)) inline __forceinline
#else
#    define MEM_STRONG_INLINE inline
#endif

#if defined(__GNUC__) || defined(__clang__)
#    define MEM_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
#    define MEM_NOINLINE __declspec(noinline)
#else
#    define MEM_NOINLINE
#endif

#if defined(__cplusplus) && defined(__has_cpp_attribute)
#    define MEM_HAS_ATTRIBUTE(attrib, value) (__has_cpp_attribute(attrib) >= value)
#else
#    define MEM_HAS_ATTRIBUTE(attrib, value) (0)
#endif

#if MEM_HAS_ATTRIBUTE(likely, 201803L)
#    define MEM_ATTR_LIKELY likely
#else
#    define MEM_ATTR_LIKELY
#endif

#if MEM_HAS_ATTRIBUTE(unlikely, 201803L)
#    define MEM_ATTR_UNLIKELY unlikely
#else
#    define MEM_ATTR_UNLIKELY
#endif

#include <climits>
#include <cstddef>
#include <cstdint>

#if CHAR_BIT != 8
#    error Only 8-bit bytes are supported
#endif

namespace mem
{
    using byte = unsigned char;

    inline namespace conventions
    {
        template <typename Result, typename... Args>
        using func_t = Result (*)(Args...);

        template <typename Result, typename Class, typename... Args>
        using member_func_t = Result (Class::*)(Args...);

#if defined(MEM_ARCH_X86)
#    if defined(__GNUC__) || defined(__clang__)
        template <typename Result, typename... Args>
        using cdecl_t = Result(__attribute__((cdecl)) *)(Args...);

        template <typename Result, typename... Args>
        using stdcall_t = Result(__attribute__((stdcall)) *)(Args...);

        template <typename Result, typename... Args>
        using fastcall_t = Result(__attribute__((fastcall)) *)(Args...);

        template <typename Result, typename... Args>
        using thiscall_t = Result(__attribute__((thiscall)) *)(Args...);
#    elif defined(_MSC_VER)
        template <typename Result, typename... Args>
        using cdecl_t = Result(__cdecl*)(Args...);

        template <typename Result, typename... Args>
        using stdcall_t = Result(__stdcall*)(Args...);

        template <typename Result, typename... Args>
        using fastcall_t = Result(__fastcall*)(Args...);

        template <typename Result, typename... Args>
        using thiscall_t = Result(__thiscall*)(Args...);
#    endif
#endif
    } // namespace conventions
} // namespace mem

#endif // MEM_DEFINES_BRICK_H

```

`hack/deps/mem/execution_handler.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_EXECUTION_HANDLER_BRICK_H
#define MEM_EXECUTION_HANDLER_BRICK_H

#include "defines.h"

#include <memory>
#include <stdexcept>

#if defined(_WIN32)
#    if !defined(WIN32_LEAN_AND_MEAN)
#        define WIN32_LEAN_AND_MEAN
#    endif
#    include <Windows.h>
#    include <eh.h>
#elif defined(__unix__)
#    include <setjmp.h>
#    include <signal.h>
#else
#    error Unknown Platform
#endif

namespace mem
{
#if defined(_WIN32)
    class scoped_seh
    {
    private:
        _se_translator_function old_handler_ {nullptr};

    public:
        scoped_seh();
        ~scoped_seh();

        scoped_seh(const scoped_seh&) = delete;
        scoped_seh(scoped_seh&&) = delete;

        template <typename Func, typename... Args>
        auto execute(Func func, Args&&... args) -> decltype(func(std::forward<Args>(args)...))
        {
            return func(std::forward<Args>(args)...);
        }
    };

    using execution_handler = scoped_seh;
#elif defined(__unix__)
    class signal_handler
    {
    private:
        std::unique_ptr<char[]> sig_stack_;
        stack_t old_stack_;
        struct sigaction old_actions_[3];
        sigjmp_buf jmp_buffer_;

        static void sig_handler(int sig, siginfo_t* info, void* ucontext);
        static signal_handler*& current_handler();

        class scoped_handler
        {
        private:
            signal_handler* prev_ {nullptr};

        public:
            scoped_handler(signal_handler* handler);
            ~scoped_handler();

            scoped_handler(const scoped_handler&) = delete;
            scoped_handler(scoped_handler&&) = delete;
        };

    public:
        signal_handler();
        ~signal_handler();

        signal_handler(const signal_handler&) = delete;
        signal_handler(signal_handler&&) = delete;

        template <typename Func, typename... Args>
        auto execute(Func func, Args&&... args) -> decltype(func(std::forward<Args>(args)...))
        {
            scoped_handler scope(this);

            if (sigsetjmp(jmp_buffer_, 1))
            {
                throw std::runtime_error("Execution Error");
            }

            return func(std::forward<Args>(args)...);
        }
    };

    using execution_handler = signal_handler;
#endif

#if defined(_WIN32)
    namespace internal
    {
        inline MEM_CONSTEXPR_14 const char* translate_exception_code(std::uint32_t code) noexcept
        {
            switch (code)
            {
                case 0x80000001: return "STATUS_GUARD_PAGE_VIOLATION";
                case 0x80000002: return "STATUS_DATATYPE_MISALIGNMENT";
                case 0x80000003: return "STATUS_BREAKPOINT";
                case 0x80000004: return "STATUS_SINGLE_STEP";
                case 0x80000026: return "STATUS_LONGJUMP";
                case 0x80000029: return "STATUS_UNWIND_CONSOLIDATE";
                case 0x80010001: return "DBG_EXCEPTION_NOT_HANDLED";
                case 0xC0000005: return "STATUS_ACCESS_VIOLATION";
                case 0xC0000006: return "STATUS_IN_PAGE_ERROR";
                case 0xC0000008: return "STATUS_INVALID_HANDLE";
                case 0xC000000D: return "STATUS_INVALID_PARAMETER";
                case 0xC0000017: return "STATUS_NO_MEMORY";
                case 0xC000001D: return "STATUS_ILLEGAL_INSTRUCTION";
                case 0xC0000025: return "STATUS_NONCONTINUABLE_EXCEPTION";
                case 0xC0000026: return "STATUS_INVALID_DISPOSITION";
                case 0xC000008C: return "STATUS_ARRAY_BOUNDS_EXCEEDED";
                case 0xC000008D: return "STATUS_FLOAT_DENORMAL_OPERAND";
                case 0xC000008E: return "STATUS_FLOAT_DIVIDE_BY_ZERO";
                case 0xC000008F: return "STATUS_FLOAT_INEXACT_RESULT";
                case 0xC0000090: return "STATUS_FLOAT_INVALID_OPERATION";
                case 0xC0000091: return "STATUS_FLOAT_OVERFLOW";
                case 0xC0000092: return "STATUS_FLOAT_STACK_CHECK";
                case 0xC0000093: return "STATUS_FLOAT_UNDERFLOW";
                case 0xC0000094: return "STATUS_INTEGER_DIVIDE_BY_ZERO";
                case 0xC0000095: return "STATUS_INTEGER_OVERFLOW";
                case 0xC0000096: return "STATUS_PRIVILEGED_INSTRUCTION";
                case 0xC00000FD: return "STATUS_STACK_OVERFLOW";
                case 0xC0000135: return "STATUS_DLL_NOT_FOUND";
                case 0xC0000138: return "STATUS_ORDINAL_NOT_FOUND";
                case 0xC0000139: return "STATUS_ENTRYPOINT_NOT_FOUND";
                case 0xC000013A: return "STATUS_CONTROL_C_EXIT";
                case 0xC0000142: return "STATUS_DLL_INIT_FAILED";
                case 0xC00002B4: return "STATUS_FLOAT_MULTIPLE_FAULTS";
                case 0xC00002B5: return "STATUS_FLOAT_MULTIPLE_TRAPS";
                case 0xC00002C9: return "STATUS_REG_NAT_CONSUMPTION";
                case 0xC0000374: return "STATUS_HEAP_CORRUPTION";
                case 0xC0000409: return "STATUS_STACK_BUFFER_OVERRUN";
                case 0xC0000417: return "STATUS_INVALID_CRUNTIME_PARAMETER";
                case 0xC0000420: return "STATUS_ASSERTION_FAILURE";
                case 0xC00004A2: return "STATUS_ENCLAVE_VIOLATION";
            }

            return "UNKNOWN_EXCEPTION";
        }

        inline void translate_seh(unsigned int code, EXCEPTION_POINTERS* ep)
        {
            const char* code_name = translate_exception_code(code);

            char buffer[2048];

            std::snprintf(buffer, sizeof(buffer), // clang-format off
#if defined(MEM_ARCH_X86_64)
                "%s (0x%08X) at 0x%016llX\n"
                "RAX = 0x%016llX RBX = 0x%016llX RCX = 0x%016llX RDX = 0x%016llX\n"
                "RSP = 0x%016llX RBP = 0x%016llX RSI = 0x%016llX RDI = 0x%016llX\n"
                "R8  = 0x%016llX R9  = 0x%016llX R10 = 0x%016llX R11 = 0x%016llX\n"
                "R12 = 0x%016llX R13 = 0x%016llX R14 = 0x%016llX R15 = 0x%016llX\n",
                code_name, code,
                reinterpret_cast<DWORD64>(ep->ExceptionRecord->ExceptionAddress),
                ep->ContextRecord->Rax, ep->ContextRecord->Rbx, ep->ContextRecord->Rcx, ep->ContextRecord->Rdx,
                ep->ContextRecord->Rsp, ep->ContextRecord->Rbp, ep->ContextRecord->Rsi, ep->ContextRecord->Rdi,
                ep->ContextRecord->R8,  ep->ContextRecord->R9,  ep->ContextRecord->R10, ep->ContextRecord->R11,
                ep->ContextRecord->R12, ep->ContextRecord->R13, ep->ContextRecord->R14, ep->ContextRecord->R15
#else /*if defined(MEM_ARCH_X86)*/
                "%s (0x%08X) at 0x%08X\n"
                "EAX = 0x%08lX EBX = 0x%08lX ECX = 0x%08lX EDX = 0x%08lX\n"
                "ESP = 0x%08lX EBP = 0x%08lX ESI = 0x%08lX EDI = 0x%08lX\n",
                code_name, code,
                reinterpret_cast<DWORD>(ep->ExceptionRecord->ExceptionAddress),
                ep->ContextRecord->Eax, ep->ContextRecord->Ebx, ep->ContextRecord->Ecx, ep->ContextRecord->Edx,
                ep->ContextRecord->Esp, ep->ContextRecord->Ebp, ep->ContextRecord->Esi, ep->ContextRecord->Edi
#endif
            ); // clang-format on

            throw std::runtime_error(buffer);
        }
    } // namespace internal

#    if defined(_MSC_VER)
#        pragma warning(push)
#        pragma warning(disable : 4535) // warning C4535: calling _set_se_translator() requires /EHa
#    endif

    inline scoped_seh::scoped_seh()
        : old_handler_(_set_se_translator(&internal::translate_seh))
    {}

    inline scoped_seh::~scoped_seh()
    {
        _set_se_translator(old_handler_);
    }

#    if defined(_MSC_VER)
#        pragma warning(pop)
#    endif

#elif defined(__unix__)
    inline signal_handler::signal_handler()
        : sig_stack_(new char[MINSIGSTKSZ])
    {
        stack_t new_stack {};

        new_stack.ss_sp = sig_stack_.get();
        new_stack.ss_size = MINSIGSTKSZ;
        new_stack.ss_flags = 0;
        sigaltstack(&new_stack, &old_stack_);

        struct sigaction sa;

        sa.sa_sigaction = &sig_handler;
        sa.sa_flags = SA_ONSTACK | SA_SIGINFO;
        sigemptyset(&sa.sa_mask);

        sigaction(SIGSEGV, &sa, &old_actions_[0]);
        sigaction(SIGILL, &sa, &old_actions_[1]);
        sigaction(SIGFPE, &sa, &old_actions_[2]);
    }

    inline signal_handler::~signal_handler()
    {
        sigaction(SIGSEGV, &old_actions_[0], nullptr);
        sigaction(SIGILL, &old_actions_[1], nullptr);
        sigaction(SIGFPE, &old_actions_[2], nullptr);

        sigaltstack(&old_stack_, nullptr);
    }

    inline void signal_handler::sig_handler(int /*sig*/, siginfo_t* /*info*/, void* /*ucontext*/)
    {
        signal_handler* current = current_handler();

        if (!current)
        {
            std::abort();
        }

        siglongjmp(current->jmp_buffer_, 1);
    }

    inline signal_handler*& signal_handler::current_handler()
    {
        static thread_local signal_handler* current {nullptr};

        return current;
    }

    inline signal_handler::scoped_handler::scoped_handler(signal_handler* handler)
        : prev_(current_handler())
    {
        current_handler() = handler;
    }

    inline signal_handler::scoped_handler::~scoped_handler()
    {
        current_handler() = prev_;
    }
#endif
} // namespace mem

#endif // MEM_EXECUTION_HANDLER_BRICK_H

```

`hack/deps/mem/hasher.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_HASHER_BRICK_H
#define MEM_HASHER_BRICK_H

#include "defines.h"

namespace mem
{
    class hasher
    {
    private:
        std::uint32_t hash_;

    public:
        hasher(std::uint32_t seed = 0) noexcept;

        void update(const void* data, std::size_t length) noexcept;

        template <typename T>
        void update(const T& value) noexcept;

        std::uint32_t digest() const noexcept;
    };

    MEM_STRONG_INLINE hasher::hasher(std::uint32_t seed) noexcept
        : hash_(seed)
    {}

    MEM_STRONG_INLINE void hasher::update(const void* data, std::size_t length) noexcept
    {
        std::uint32_t hash = hash_;

        for (std::size_t i = 0; i < length; ++i)
        {
            hash += static_cast<const std::uint8_t*>(data)[i];
            hash += (hash << 10);
            hash ^= (hash >> 6);
        }

        hash_ = hash;
    }

    template <typename T>
    MEM_STRONG_INLINE void hasher::update(const T& value) noexcept
    {
        static_assert(std::is_integral<T>::value, "Invalid Type");

        update(&value, sizeof(value));
    }

    MEM_STRONG_INLINE std::uint32_t hasher::digest() const noexcept
    {
        std::uint32_t hash = hash_;

        hash += (hash << 3);
        hash ^= (hash >> 11);
        hash += (hash << 15);

        return hash;
    }
} // namespace mem

#endif // MEM_HASHER_BRICK_H

```

`hack/deps/mem/init_function.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_INIT_FUNCTION_BRICK_H
#define MEM_INIT_FUNCTION_BRICK_H

#include "defines.h"

namespace mem
{
    class init_function
    {
    public:
        using callback_t = void (*)();

        constexpr init_function() noexcept = default;
        init_function(callback_t callback) noexcept;
        init_function(init_function*& parent, callback_t callback) noexcept;

        init_function(const init_function&) = delete;
        init_function(init_function&&) = delete;

        static std::size_t init(init_function*& root = ROOT(), bool clear = true);

        static init_function*& ROOT() noexcept;

    private:
        callback_t callback_ {nullptr};
        init_function* next_ {nullptr};
    };

    MEM_STRONG_INLINE init_function::init_function(callback_t callback) noexcept
        : init_function(ROOT(), callback)
    {}

    MEM_STRONG_INLINE init_function::init_function(init_function*& parent, callback_t callback) noexcept
        : callback_(callback)
        , next_(parent)
    {
        parent = this;
    }

    MEM_STRONG_INLINE init_function*& init_function::ROOT() noexcept
    {
        static init_function* root {nullptr};

        return root;
    }

    MEM_STRONG_INLINE std::size_t init_function::init(init_function*& root, bool clear)
    {
        std::size_t total = 0;

        init_function* i = root;

        if (clear)
            root = nullptr;

        while (i)
        {
            if (i->callback_)
            {
                i->callback_();

                if (clear)
                    i->callback_ = nullptr;

                ++total;
            }

            init_function* j = i->next_;

            if (clear)
                i->next_ = nullptr;

            i = j;
        }

        return total;
    }
} // namespace mem

#endif // MEM_INIT_FUNCTION_BRICK_H

```

`hack/deps/mem/macros.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_MACROS_BRICK_H
#define MEM_MACROS_BRICK_H

#include "init_function.h"
#include "mem.h"

#define mem_decl_extern(TYPE, NAME) typename std::add_lvalue_reference<TYPE>::type NAME
#define mem_defn_extern(ADDRESS, NAME) decltype(NAME) NAME = mem::pointer(ADDRESS).as<decltype(NAME)>()

#ifdef __INTELLISENSE__
#    define mem_extern_var(ADDRESS, TYPE, NAME)               \
        typename std::add_lvalue_reference<TYPE>::type NAME = \
            *static_cast<typename std::add_pointer<TYPE>::type>(nullptr)
#else
#    define mem_extern_var(ADDRESS, TYPE, NAME)               \
        typename std::add_lvalue_reference<TYPE>::type NAME = \
            mem::pointer(ADDRESS).as<typename std::add_lvalue_reference<TYPE>::type>()
#endif

#define mem_check_size(TYPE, SIZE)                                                         \
    static_assert(sizeof(TYPE) >= (SIZE), #TYPE " too small: sizeof(" #TYPE ") < " #SIZE); \
    static_assert(sizeof(TYPE) <= (SIZE), #TYPE " too large: sizeof(" #TYPE ") > " #SIZE)

#define mem_paste_(LHS, RHS) LHS##RHS
#define mem_paste(LHS, RHS) mem_paste_(LHS, RHS)

#define mem_str_(VALUE) #VALUE
#define mem_str(VALUE) mem_str_(VALUE)

#define mem_run_once static mem::init_function mem_paste(run_once_, __LINE__)

#if defined(_MSC_VER)
#    define mem_define_dummy_symbol(NAME)         \
        extern "C" namespace dummy                \
        {                                         \
            void mem_paste(dummy_symbol_, NAME)() \
            {}                                    \
        }
#    if defined(MEM_ARCH_X86)
#        define dummy_symbol_prefix "_"
#    else
#        define dummy_symbol_prefix ""
#    endif
#    define mem_include_dummy_symbol(NAME) \
        __pragma(comment(linker, "/INCLUDE:" dummy_symbol_prefix mem_str(mem_paste(dummy_symbol_, NAME))))
#endif

#endif // MEM_MACROS_BRICK_H

```

`hack/deps/mem/mem.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_BRICK_H
#define MEM_BRICK_H

#include "defines.h"

#include <cstring>
#include <type_traits>
#include <utility>

namespace mem
{
    class any_pointer;

    class pointer
    {
    private:
        std::uintptr_t value_ {0};

    public:
        constexpr pointer() noexcept;

        constexpr pointer(std::nullptr_t) noexcept;
        constexpr pointer(std::uintptr_t address) noexcept;

        template <typename T>
        pointer(T* address) noexcept;

        template <typename T, typename C>
        pointer(T C::*address) noexcept;

        constexpr pointer add(std::size_t count) const noexcept;
        constexpr pointer sub(std::size_t count) const noexcept;

        constexpr pointer offset(std::ptrdiff_t count) const noexcept;

        constexpr pointer shift(pointer from, pointer to) const noexcept;

        constexpr pointer align_up(std::size_t align) const noexcept;
        constexpr pointer align_down(std::size_t align) const noexcept;

#if defined(MEM_ARCH_X86_64)
        pointer rip(std::size_t offset) const noexcept;
#endif // MEM_ARCH_X86_64

        pointer& deref() const noexcept;

        constexpr pointer operator+(std::size_t count) const noexcept;
        constexpr pointer operator-(std::size_t count) const noexcept;

        constexpr std::ptrdiff_t operator-(pointer rhs) const noexcept;

        MEM_CONSTEXPR_14 pointer& operator+=(std::size_t count) noexcept;
        MEM_CONSTEXPR_14 pointer& operator-=(std::size_t count) noexcept;

        MEM_CONSTEXPR_14 pointer& operator++() noexcept;
        MEM_CONSTEXPR_14 pointer& operator--() noexcept;

        MEM_CONSTEXPR_14 pointer operator++(int) noexcept;
        MEM_CONSTEXPR_14 pointer operator--(int) noexcept;

        constexpr bool operator==(pointer rhs) const noexcept;
        constexpr bool operator!=(pointer rhs) const noexcept;

        constexpr bool operator<(pointer rhs) const noexcept;
        constexpr bool operator>(pointer rhs) const noexcept;

        constexpr bool operator<=(pointer rhs) const noexcept;
        constexpr bool operator>=(pointer rhs) const noexcept;

        constexpr bool operator!() const noexcept;

        constexpr explicit operator bool() const noexcept;

        template <typename T = pointer>
        typename std::add_lvalue_reference<T>::type at(std::size_t offset) const noexcept;

        template <typename T>
        constexpr typename std::enable_if<std::is_integral<T>::value, T>::type as() const noexcept;

        template <typename T>
        typename std::enable_if<std::is_pointer<T>::value, T>::type as() const noexcept;

        template <typename T>
        typename std::enable_if<std::is_member_pointer<T>::value, T>::type as() const noexcept;

        template <typename T>
        typename std::enable_if<std::is_lvalue_reference<T>::value, T>::type as() const noexcept;

        template <typename T>
        typename std::enable_if<std::is_array<T>::value, typename std::add_lvalue_reference<T>::type>::type
        as() const noexcept;

        template <typename T>
        typename std::enable_if<!std::is_reference<T>::value, typename std::add_lvalue_reference<T>::type>::type
        rcast() & noexcept;

        template <typename Func>
        constexpr pointer and_then(Func&& func) const;

        template <typename Func>
        constexpr pointer or_else(Func&& func) const;

        constexpr any_pointer any() const noexcept;
    };

    static_assert((sizeof(pointer) == sizeof(void*)) && (alignof(pointer) == alignof(void*)), "Hmm...");

    class any_pointer
    {
    private:
        std::uintptr_t value_ {0};

    public:
        constexpr any_pointer(std::uintptr_t value) noexcept;

        constexpr operator std::uintptr_t() const noexcept;

        template <typename T>
        operator T*() const noexcept;
    };

    class region
    {
    public:
        pointer start {nullptr};
        std::size_t size {0};

        constexpr region() noexcept;

        constexpr region(pointer start, std::size_t size) noexcept;

        constexpr bool contains(region rhs) const noexcept;

        constexpr bool contains(pointer address) const noexcept;
        constexpr bool contains(pointer start, std::size_t size) const noexcept;

        template <typename T>
        constexpr bool contains(pointer address) const noexcept;

        constexpr bool operator==(region rhs) const noexcept;
        constexpr bool operator!=(region rhs) const noexcept;

        void copy(pointer source) const noexcept;
        void fill(byte value) const noexcept;

        constexpr region sub_region(pointer address) const noexcept;
    };

    template <typename T>
    typename std::add_lvalue_reference<T>::type field(pointer base, std::ptrdiff_t offset = 0) noexcept;

    template <typename F>
    typename std::add_lvalue_reference<F>::type vfunc(
        pointer inst, std::size_t index, std::ptrdiff_t table = 0) noexcept;

    template <typename To, typename From>
    To bit_cast(const From& src) noexcept;

    MEM_STRONG_INLINE constexpr pointer::pointer() noexcept = default;

    MEM_STRONG_INLINE constexpr pointer::pointer(std::nullptr_t) noexcept
        : value_(0)
    {}

    MEM_STRONG_INLINE constexpr pointer::pointer(std::uintptr_t address) noexcept
        : value_(address)
    {}

    template <typename T>
    MEM_STRONG_INLINE pointer::pointer(T* address) noexcept
        : value_(reinterpret_cast<std::uintptr_t>(address))
    {}

    template <typename T, typename C>
    MEM_STRONG_INLINE pointer::pointer(T C::*address) noexcept
        : value_(bit_cast<std::uintptr_t>(address))
    {}

    MEM_STRONG_INLINE constexpr pointer pointer::add(std::size_t count) const noexcept
    {
        return value_ + count;
    }

    MEM_STRONG_INLINE constexpr pointer pointer::sub(std::size_t count) const noexcept
    {
        return value_ - count;
    }

    MEM_STRONG_INLINE constexpr pointer pointer::offset(std::ptrdiff_t count) const noexcept
    {
        return static_cast<std::uintptr_t>(static_cast<std::intptr_t>(value_) + count);
    }

    MEM_STRONG_INLINE constexpr pointer pointer::shift(pointer from, pointer to) const noexcept
    {
        return (value_ - from.value_) + to.value_;
    }

    MEM_STRONG_INLINE constexpr pointer pointer::align_up(std::size_t align) const noexcept
    {
        return (value_ + align - 1) / align * align;
    }

    MEM_STRONG_INLINE constexpr pointer pointer::align_down(std::size_t align) const noexcept
    {
        return value_ - (value_ % align);
    }

#if defined(MEM_ARCH_X86_64)
    MEM_STRONG_INLINE pointer pointer::rip(std::size_t offset) const noexcept
    {
        return static_cast<std::uintptr_t>(
            static_cast<std::intptr_t>(value_ + offset) + *reinterpret_cast<const std::int32_t*>(value_));
    }
#endif // MEM_ARCH_X86_64

    MEM_STRONG_INLINE pointer& pointer::deref() const noexcept
    {
        return *reinterpret_cast<pointer*>(value_);
    }

    MEM_STRONG_INLINE constexpr pointer pointer::operator+(std::size_t count) const noexcept
    {
        return value_ + count;
    }

    MEM_STRONG_INLINE constexpr pointer pointer::operator-(std::size_t count) const noexcept
    {
        return value_ - count;
    }

    MEM_STRONG_INLINE constexpr std::ptrdiff_t pointer::operator-(pointer rhs) const noexcept
    {
        return static_cast<std::ptrdiff_t>(static_cast<std::intptr_t>(value_) - static_cast<std::intptr_t>(rhs.value_));
    }

    MEM_STRONG_INLINE MEM_CONSTEXPR_14 pointer& pointer::operator+=(std::size_t count) noexcept
    {
        value_ += count;

        return *this;
    }

    MEM_STRONG_INLINE MEM_CONSTEXPR_14 pointer& pointer::operator-=(std::size_t count) noexcept
    {
        value_ -= count;

        return *this;
    }

    MEM_STRONG_INLINE MEM_CONSTEXPR_14 pointer& pointer::operator++() noexcept
    {
        ++value_;

        return *this;
    }

    MEM_STRONG_INLINE MEM_CONSTEXPR_14 pointer& pointer::operator--() noexcept
    {
        --value_;

        return *this;
    }

    MEM_STRONG_INLINE MEM_CONSTEXPR_14 pointer pointer::operator++(int) noexcept
    {
        pointer result = *this;

        ++value_;

        return result;
    }

    MEM_STRONG_INLINE MEM_CONSTEXPR_14 pointer pointer::operator--(int) noexcept
    {
        pointer result = *this;

        --value_;

        return result;
    }

    MEM_STRONG_INLINE constexpr bool pointer::operator==(pointer rhs) const noexcept
    {
        return value_ == rhs.value_;
    }

    MEM_STRONG_INLINE constexpr bool pointer::operator!=(pointer rhs) const noexcept
    {
        return value_ != rhs.value_;
    }

    MEM_STRONG_INLINE constexpr bool pointer::operator<(pointer rhs) const noexcept
    {
        return value_ < rhs.value_;
    }

    MEM_STRONG_INLINE constexpr bool pointer::operator>(pointer rhs) const noexcept
    {
        return value_ > rhs.value_;
    }

    MEM_STRONG_INLINE constexpr bool pointer::operator<=(pointer rhs) const noexcept
    {
        return value_ <= rhs.value_;
    }

    MEM_STRONG_INLINE constexpr bool pointer::operator>=(pointer rhs) const noexcept
    {
        return value_ >= rhs.value_;
    }

    MEM_STRONG_INLINE constexpr bool pointer::operator!() const noexcept
    {
        return !value_;
    }

    MEM_STRONG_INLINE constexpr pointer::operator bool() const noexcept
    {
        return value_ != 0;
    }

    template <typename T>
    MEM_STRONG_INLINE constexpr typename std::enable_if<std::is_integral<T>::value, T>::type
    pointer::as() const noexcept
    {
        static_assert(
            std::is_same<typename std::make_unsigned<T>::type, std::uintptr_t>::value, "Invalid Integer Type");

        return static_cast<T>(value_);
    }

    template <typename T>
    MEM_STRONG_INLINE typename std::add_lvalue_reference<T>::type pointer::at(std::size_t offset) const noexcept
    {
        return *reinterpret_cast<typename std::add_pointer<T>::type>(value_ + offset);
    }

    template <typename T>
    MEM_STRONG_INLINE typename std::enable_if<std::is_pointer<T>::value, T>::type pointer::as() const noexcept
    {
        return reinterpret_cast<T>(value_);
    }

    template <typename T>
    MEM_STRONG_INLINE typename std::enable_if<std::is_member_pointer<T>::value, T>::type pointer::as() const noexcept
    {
        return bit_cast<T>(value_);
    }

    template <typename T>
    MEM_STRONG_INLINE typename std::enable_if<std::is_lvalue_reference<T>::value, T>::type pointer::as() const noexcept
    {
        return *reinterpret_cast<typename std::add_pointer<T>::type>(value_);
    }

    template <typename T>
    MEM_STRONG_INLINE
        typename std::enable_if<std::is_array<T>::value, typename std::add_lvalue_reference<T>::type>::type
        pointer::as() const noexcept
    {
        return *reinterpret_cast<typename std::add_pointer<T>::type>(value_);
    }

    template <typename T>
    MEM_STRONG_INLINE
        typename std::enable_if<!std::is_reference<T>::value, typename std::add_lvalue_reference<T>::type>::type
        pointer::rcast() & noexcept
    {
        static_assert(sizeof(T) == sizeof(pointer), "That's no pointer. It's a space station.");

        return *reinterpret_cast<typename std::add_pointer<T>::type>(this);
    }

    template <typename Func>
    MEM_STRONG_INLINE constexpr pointer pointer::and_then(Func&& func) const
    {
        return value_ ? std::forward<Func>(func)(*this) : nullptr;
    }

    template <typename Func>
    MEM_STRONG_INLINE constexpr pointer pointer::or_else(Func&& func) const
    {
        return value_ ? *this : std::forward<Func>(func)();
    }

    MEM_STRONG_INLINE constexpr any_pointer pointer::any() const noexcept
    {
        return any_pointer(value_);
    }

    MEM_STRONG_INLINE constexpr any_pointer::any_pointer(std::uintptr_t value) noexcept
        : value_(value)
    {}

    MEM_STRONG_INLINE constexpr any_pointer::operator std::uintptr_t() const noexcept
    {
        return value_;
    }

    template <typename T>
    MEM_STRONG_INLINE any_pointer::operator T*() const noexcept
    {
        return reinterpret_cast<T*>(value_);
    }

    MEM_STRONG_INLINE constexpr region::region() noexcept = default;

    MEM_STRONG_INLINE constexpr region::region(pointer start_, std::size_t size_) noexcept
        : start(start_)
        , size(size_)
    {}

    MEM_STRONG_INLINE constexpr bool region::contains(region rhs) const noexcept
    {
        return (rhs.start >= start) && ((rhs.start + rhs.size) <= (start + size));
    }

    MEM_STRONG_INLINE constexpr bool region::contains(pointer address) const noexcept
    {
        return (address >= start) && (address < (start + size));
    }

    MEM_STRONG_INLINE constexpr bool region::contains(pointer start_, std::size_t size_) const noexcept
    {
        return (start_ >= start) && ((start_ + size_) <= (start + size));
    }

    template <typename T>
    MEM_STRONG_INLINE constexpr bool region::contains(pointer address) const noexcept
    {
        return (address >= start) && ((address + sizeof(T)) <= (start + size));
    }

    MEM_STRONG_INLINE constexpr bool region::operator==(region rhs) const noexcept
    {
        return (start == rhs.start) && (size == rhs.size);
    }

    MEM_STRONG_INLINE constexpr bool region::operator!=(region rhs) const noexcept
    {
        return (start != rhs.start) || (size != rhs.size);
    }

    MEM_STRONG_INLINE void region::copy(pointer source) const noexcept
    {
        std::memcpy(start.as<void*>(), source.as<const void*>(), size);
    }

    MEM_STRONG_INLINE void region::fill(byte value) const noexcept
    {
        std::memset(start.as<void*>(), value, size);
    }

    MEM_STRONG_INLINE constexpr region region::sub_region(pointer address) const noexcept
    {
        return region(address, size - static_cast<std::size_t>(address - start));
    }

    template <typename T>
    MEM_STRONG_INLINE typename std::add_lvalue_reference<T>::type field(pointer base, std::ptrdiff_t offset) noexcept
    {
        return base.at<T>(offset);
    }

    template <typename F>
    MEM_STRONG_INLINE typename std::add_lvalue_reference<F>::type vfunc(
        pointer inst, std::size_t index, std::ptrdiff_t table) noexcept
    {
        return inst.as<pointer**>()[table][index].rcast<F>();
    }

    template <typename To, typename From>
    MEM_STRONG_INLINE To bit_cast(const From& src) noexcept
    {
        static_assert(sizeof(To) == sizeof(From), "sizeof(To) != sizeof(From)");
        static_assert(std::is_trivially_copyable<From>::value, "From is not trivially copyable");
        static_assert(std::is_trivially_copyable<To>::value, "To is not trivially copyable");

        typename std::aligned_storage<sizeof(To), alignof(To)>::type dst;
        std::memcpy(&dst, &src, sizeof(To));
        return reinterpret_cast<To&>(dst);
    }
} // namespace mem
#endif // !MEM_BRICK_H

```

`hack/deps/mem/module.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_MODULE_BRICK_H
#define MEM_MODULE_BRICK_H

#include "mem.h"
#include "prot_flags.h"
#include "slice.h"

#include <cstdio>
#include <cstdlib>
#include <memory>

#if defined(_WIN32)
#    if !defined(WIN32_LEAN_AND_MEAN)
#        define WIN32_LEAN_AND_MEAN
#    endif
#    include <Windows.h>
#    include <intrin.h>
#    if defined(_WIN64)
#        pragma intrinsic(__readgsqword)
#    else
#        pragma intrinsic(__readfsdword)
#    endif
#elif defined(__unix__)
#    ifndef _GNU_SOURCE
#        define _GNU_SOURCE
#    endif
#    include <link.h>
#    if defined(MEM_USE_DLFCN) // Requires -ldl linker flag
#        include <dlfcn.h>
#    endif
#else
#    error Unknown Platform
#endif

namespace mem
{
    class module : public region
    {
    public:
        using region::region;

#if defined(_WIN32)
        static module nt(pointer address);
        static module named(const wchar_t* name);

        const IMAGE_DOS_HEADER& dos_header();
        const IMAGE_NT_HEADERS& nt_headers();
        slice<const IMAGE_SECTION_HEADER> section_headers();
#elif defined(__unix__)
        static module elf(pointer address);

        const ElfW(Ehdr) & elf_header();
        slice<const ElfW(Phdr)> program_headers();
        slice<const ElfW(Shdr)> section_headers();
#endif

        static module named(const char* name);

        static module main();
        static module self();

        template <typename Func>
        void enum_segments(Func func);

#if defined(_WIN32)
        template <typename Func>
        void enum_exports(Func func);
#endif
    };

#if defined(_WIN32)
    namespace internal
    {
        extern "C" IMAGE_DOS_HEADER __ImageBase;
    }

    struct PEB
    {
        UCHAR InheritedAddressSpace;
        UCHAR ReadImageFileExecOptions;
        UCHAR BeingDebugged;
        UCHAR Spare;
        PVOID Mutant;
        PVOID ImageBaseAddress;
    };

    MEM_STRONG_INLINE PEB* get_peb() noexcept
    {
#    if defined(_WIN64)
        return reinterpret_cast<PEB*>(__readgsqword(0x60));
#    else
        return reinterpret_cast<PEB*>(__readfsdword(0x30));
#    endif
    }

    MEM_STRONG_INLINE module module::nt(pointer address)
    {
        if (!address)
            return module();

        const IMAGE_DOS_HEADER& dos = address.at<const IMAGE_DOS_HEADER>(0);

        if (dos.e_magic != IMAGE_DOS_SIGNATURE)
            return module();

        const IMAGE_NT_HEADERS& nt = address.at<const IMAGE_NT_HEADERS>(dos.e_lfanew);

        if (nt.Signature != IMAGE_NT_SIGNATURE)
            return module();

        if (nt.FileHeader.SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER))
            return module();

        return module(address, nt.OptionalHeader.SizeOfImage);
    }

    MEM_STRONG_INLINE module module::named(const char* name)
    {
        return nt(GetModuleHandleA(name));
    }

    MEM_STRONG_INLINE module module::named(const wchar_t* name)
    {
        return nt(GetModuleHandleW(name));
    }

    MEM_STRONG_INLINE module module::main()
    {
        return nt(get_peb()->ImageBaseAddress);
    }

    MEM_STRONG_INLINE module module::self()
    {
        return nt(&internal::__ImageBase);
    }

    MEM_STRONG_INLINE const IMAGE_DOS_HEADER& module::dos_header()
    {
        return start.at<const IMAGE_DOS_HEADER>(0);
    }

    MEM_STRONG_INLINE const IMAGE_NT_HEADERS& module::nt_headers()
    {
        return start.at<const IMAGE_NT_HEADERS>(dos_header().e_lfanew);
    }

    MEM_STRONG_INLINE slice<const IMAGE_SECTION_HEADER> module::section_headers()
    {
        const IMAGE_NT_HEADERS& nt = nt_headers();
        const IMAGE_SECTION_HEADER* sections = IMAGE_FIRST_SECTION(&nt);

        return {sections, nt.FileHeader.NumberOfSections};
    }

    template <typename Func>
    MEM_STRONG_INLINE void module::enum_segments(Func func)
    {
        for (const IMAGE_SECTION_HEADER& section : section_headers())
        {
            mem::region range(start.add(section.VirtualAddress), section.Misc.VirtualSize);

            if (!range.size)
                continue;

            prot_flags prot = prot_flags::NONE;

            if (section.Characteristics & IMAGE_SCN_MEM_READ)
                prot |= prot_flags::R;

            if (section.Characteristics & IMAGE_SCN_MEM_WRITE)
                prot |= prot_flags::W;

            if (section.Characteristics & IMAGE_SCN_MEM_EXECUTE)
                prot |= prot_flags::X;

            if (func(range, prot))
                return;
        }
    }

    template <typename Func>
    MEM_STRONG_INLINE void module::enum_exports(Func func)
    {
        const IMAGE_DATA_DIRECTORY& export_data_dir =
            nt_headers().OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

        if (export_data_dir.Size < sizeof(IMAGE_EXPORT_DIRECTORY))
            return;

        const IMAGE_EXPORT_DIRECTORY& export_dir =
            start.add(export_data_dir.VirtualAddress).as<const IMAGE_EXPORT_DIRECTORY&>();

        const uint32_t name_count = export_dir.NumberOfNames;
        const uint32_t func_count = export_dir.NumberOfFunctions;

        const uint32_t* const names = start.add(export_dir.AddressOfNames).as<const uint32_t*>();
        const uint16_t* const ordinals = start.add(export_dir.AddressOfNameOrdinals).as<const uint16_t*>();
        const uint32_t* const functions = start.add(export_dir.AddressOfFunctions).as<const uint32_t*>();

        for (uint32_t i = 0; i < func_count; ++i)
        {
            const char* name = (i < name_count) ? start.add(names[i]).as<const char*>() : nullptr;
            const uint16_t ordinal = ordinals[i];
            const pointer function = start.add(functions[ordinal]);

            if (func(name, ordinal, function))
                break;
        }
    }

#elif defined(__unix__)
    // https://github.com/torvalds/linux/blob/master/fs/binfmt_elf.c
    inline std::size_t total_mapping_size(const ElfW(Phdr) * cmds, std::size_t count)
    {
        std::size_t first_idx = SIZE_MAX, last_idx = SIZE_MAX;

        for (std::size_t i = 0; i < count; ++i)
        {
            if (cmds[i].p_type == PT_LOAD)
            {
                last_idx = i;

                if (first_idx == SIZE_MAX)
                    first_idx = i;
            }
        }

        if (first_idx == SIZE_MAX)
            return 0;

        return cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -
            (cmds[first_idx].p_vaddr & ~(cmds[first_idx].p_align - 1));
    }

    MEM_STRONG_INLINE module module::elf(pointer address)
    {
        if (!address)
            return module();

        const ElfW(Ehdr)& ehdr = address.at<const ElfW(Ehdr)&>(0);

        // clang-format off
        if (ehdr.e_ident[EI_MAG0] != ELFMAG0 ||
            ehdr.e_ident[EI_MAG1] != ELFMAG1 ||
            ehdr.e_ident[EI_MAG2] != ELFMAG2 ||
            ehdr.e_ident[EI_MAG3] != ELFMAG3)
            return module();

        if (ehdr.e_phentsize != sizeof(ElfW(Phdr)) ||
            ehdr.e_shentsize != sizeof(ElfW(Shdr)))
            return module();
        // clang-format on

        const ElfW(Phdr)* phdr = address.at<const ElfW(Phdr)[]>(ehdr.e_phoff);
        const std::size_t mapping_size = total_mapping_size(phdr, ehdr.e_phnum);

        return module(address, mapping_size);
    }

    MEM_STRONG_INLINE const ElfW(Ehdr) & module::elf_header()
    {
        return start.at<const ElfW(Ehdr)>(0);
    }

    MEM_STRONG_INLINE slice<const ElfW(Phdr)> module::program_headers()
    {
        const ElfW(Ehdr)& ehdr = elf_header();
        const ElfW(Phdr)* phdr = start.at<const ElfW(Phdr)[]>(ehdr.e_phoff);

        return {phdr, ehdr.e_phnum};
    }

    MEM_STRONG_INLINE slice<const ElfW(Shdr)> module::section_headers()
    {
        const ElfW(Ehdr)& ehdr = elf_header();
        const ElfW(Shdr)* shdr = start.at<const ElfW(Shdr)[]>(ehdr.e_shoff);

        return {shdr, ehdr.e_shnum};
    }

    template <typename Func>
    MEM_STRONG_INLINE void module::enum_segments(Func func)
    {
        for (const ElfW(Phdr) & section : program_headers())
        {
            if (section.p_type != PT_LOAD)
                continue;

            if (!section.p_memsz)
                continue;

            mem::region range(start.add(section.p_vaddr), section.p_memsz);

            prot_flags prot = prot_flags::NONE;

            if (section.p_flags & PF_R)
                prot |= prot_flags::R;

            if (section.p_flags & PF_W)
                prot |= prot_flags::W;

            if (section.p_flags & PF_X)
                prot |= prot_flags::X;

            if (func(range, prot))
                return;
        }
    }

    MEM_STRONG_INLINE module module::main()
    {
        return named(nullptr);
    }

    namespace internal
    {
        extern "C" ElfW(Ehdr) __ehdr_start;
    }

    MEM_STRONG_INLINE module module::self()
    {
        return elf(&internal::__ehdr_start);
    }

#    if defined(MEM_USE_DLFCN)
    MEM_STRONG_INLINE module module::named(const char* name)
    {
        void* handle = dlopen(name, RTLD_LAZY | RTLD_NOLOAD);

        if (handle)
        {
#        if defined(MEM_USE_DLINFO)
            const link_map* lm = nullptr;

            if (dlinfo(handle, RTLD_DI_LINKMAP, &lm))
                lm = nullptr;
#        else
            const link_map* lm = static_cast<const link_map*>(handle);
#        endif

            void* base_addr = nullptr;

            if (lm && lm->l_ld)
            {
                Dl_info info;

                if (dladdr(lm->l_ld, &info))
                {
                    base_addr = info.dli_fbase;
                }
            }

            dlclose(handle);

            return elf(base_addr);
        }

        return module();
    }
#    else
    namespace internal
    {
        struct dl_iterate_query
        {
            const char* name {nullptr};
            void* result {nullptr};
        };

        inline int dl_iterate_callback(struct dl_phdr_info* info, std::size_t size, void* data)
        {
            (void) size;

            dl_iterate_query* search_info = static_cast<dl_iterate_query*>(data);

            const char* file_path = info->dlpi_name;
            const char* file_name = std::strrchr(file_path, '/');

            if (file_name)
            {
                ++file_name;
            }
            else
            {
                file_name = file_path;
            }

            if (!std::strcmp(search_info->name, file_name))
            {
                for (int i = 0; i < info->dlpi_phnum; ++i)
                {
                    if (info->dlpi_phdr[i].p_type == PT_LOAD)
                    {
                        search_info->result = reinterpret_cast<void*>(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);

                        return 1;
                    }
                }

                return 2;
            }

            return 0;
        }
    } // namespace internal

    MEM_STRONG_INLINE module module::named(const char* name)
    {
        internal::dl_iterate_query search;

        search.name = name ? name : "";

        if (dl_iterate_phdr(&internal::dl_iterate_callback, &search) == 1)
        {
            return elf(search.result);
        }

        return module();
    }
#    endif
#endif
} // namespace mem

#endif // MEM_MODULE_BRICK_H

```

`hack/deps/mem/pattern.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_PATTERN_BRICK_H
#define MEM_PATTERN_BRICK_H

#include "char_queue.h"
#include "mem.h"

#include <string>
#include <vector>

namespace mem
{
    class region;

    class pattern
    {
    private:
        std::vector<byte> bytes_ {};
        std::vector<byte> masks_ {};
        std::size_t trimmed_size_ {0};
        bool needs_masks_ {true};

        void finalize();

        bool parse_chunk(char_queue& input, char wildcard);

    public:
        explicit pattern() = default;

        enum class wildcard_t : char
        {
        };

        explicit pattern(const char* string, wildcard_t wildcard = static_cast<wildcard_t>('?'));
        explicit pattern(const void* bytes, const char* masks, wildcard_t wildcard = static_cast<wildcard_t>('?'));

        explicit pattern(const void* bytes, const void* masks, std::size_t length);

        bool match(pointer address) const noexcept;

        const byte* bytes() const noexcept;
        const byte* masks() const noexcept;

        std::size_t size() const noexcept;
        std::size_t trimmed_size() const noexcept;

        bool needs_masks() const noexcept;

        std::size_t get_skip_pos(const byte* frequencies) const noexcept;

        explicit operator bool() const noexcept;

        std::string to_string() const;
    };

    mem::pointer scan(const mem::pattern& pattern, mem::region range);
    std::vector<mem::pointer> scan_all(const mem::pattern& pattern, mem::region range);

    inline bool pattern::parse_chunk(char_queue& input, char wildcard)
    {
        byte value = 0x00;
        byte mask = 0x00;

        std::size_t count = 1;

        int current = -1;
        int temp = -1;

        // clang-format off
        current = input.peek();
        if ((temp = xctoi(current)) != -1) { input.pop(); value = static_cast<byte>(temp); mask = 0xFF; }
        else if (current == wildcard)      { input.pop(); value = 0x00;                    mask = 0x00; }
        else                               { return false;                                              }

        current = input.peek();
        if ((temp = xctoi(current)) != -1) { input.pop(); value = (value << 4) | static_cast<byte>(temp); mask = (mask << 4) | 0x0F; }
        else if (current == wildcard)      { input.pop(); value = (value << 4);                           mask = (mask << 4);        }

        if (input.peek() == '&')
        {
            input.pop();

            byte expl_mask = 0xFF;

            if ((temp = xctoi(input.peek())) != -1) { input.pop(); expl_mask = static_cast<byte>(temp); }
            else                                    { return false; }

            if ((temp = xctoi(input.peek())) != -1) { input.pop(); expl_mask = (expl_mask << 4) | static_cast<byte>(temp); }

            mask &= expl_mask;
        }

        if (input.peek() == '#')
        {
            input.pop();

            count = 0;

            while (true)
            {
                if ((temp = dctoi(input.peek())) != -1) { input.pop(); count = (count * 10) + static_cast<std::size_t>(temp); }
                else if (count > 0)                     { break;                                                              }
                else                                    { return false;                                                       }
            }
        }
        // clang-format on

        value &= mask;

        for (std::size_t i = 0; i < count; ++i)
        {
            bytes_.push_back(value);
            masks_.push_back(mask);
        }

        return true;
    }

    inline pattern::pattern(const char* string, wildcard_t wildcard)
    {
        char_queue input(string);

        while (input)
        {
            if (input.peek() == ' ')
            {
                input.pop();

                continue;
            }

            if (!parse_chunk(input, static_cast<char>(wildcard)))
            {
                masks_.clear();
                bytes_.clear();

                break;
            }
        }

        finalize();
    }

    inline pattern::pattern(const void* bytes, const char* mask, wildcard_t wildcard)
    {
        if (mask)
        {
            const std::size_t size = std::strlen(mask);

            bytes_.resize(size);
            masks_.resize(size);

            for (std::size_t i = 0; i < size; ++i)
            {
                if (mask[i] == static_cast<char>(wildcard))
                {
                    bytes_[i] = 0x00;
                    masks_[i] = 0x00;
                }
                else
                {
                    bytes_[i] = static_cast<const byte*>(bytes)[i];
                    masks_[i] = 0xFF;
                }
            }
        }
        else
        {
            const std::size_t size = std::strlen(static_cast<const char*>(bytes));

            bytes_.resize(size);
            masks_.resize(size);

            for (std::size_t i = 0; i < size; ++i)
            {
                bytes_[i] = static_cast<const byte*>(bytes)[i];
                masks_[i] = 0xFF;
            }
        }

        finalize();
    }

    inline pattern::pattern(const void* bytes, const void* mask, std::size_t length)
    {
        if (mask)
        {
            bytes_.resize(length);
            masks_.resize(length);

            for (std::size_t i = 0; i < length; ++i)
            {
                const byte v = static_cast<const byte*>(bytes)[i];
                const byte m = static_cast<const byte*>(mask)[i];

                bytes_[i] = v & m;
                masks_[i] = m;
            }
        }
        else
        {
            bytes_.resize(length);
            masks_.resize(length);

            for (std::size_t i = 0; i < length; ++i)
            {
                bytes_[i] = static_cast<const byte*>(bytes)[i];
                masks_[i] = 0xFF;
            }
        }

        finalize();
    }

    inline void pattern::finalize()
    {
        if (bytes_.size() != masks_.size())
        {
            bytes_.clear();
            masks_.clear();
            trimmed_size_ = 0;
            needs_masks_ = false;

            return;
        }

        for (std::size_t i = 0; i < bytes_.size(); ++i)
        {
            bytes_[i] &= masks_[i];
        }

        std::size_t trimmed_size = bytes_.size();

        while (trimmed_size && (masks_[trimmed_size - 1] == 0x00))
        {
            --trimmed_size;
        }

        trimmed_size_ = trimmed_size;

        needs_masks_ = false;

        for (std::size_t i = trimmed_size_; i--;)
        {
            if (masks_[i] != 0xFF)
            {
                needs_masks_ = true;

                break;
            }
        }
    }

    inline bool pattern::match(pointer address) const noexcept
    {
        const byte* const pat_bytes = bytes();

        if (!pat_bytes)
        {
            return false;
        }

        const byte* current = address.as<const byte*>();

        const std::size_t last = trimmed_size() - 1;

        if (needs_masks())
        {
            const byte* const pat_masks = masks();

            for (std::size_t i = last; MEM_LIKELY((current[i] & pat_masks[i]) != pat_bytes[i]); --i)
            {
                if (MEM_UNLIKELY(i == 0))
                    return true;
            }

            return false;
        }
        else
        {
            for (std::size_t i = last; MEM_LIKELY(current[i] != pat_bytes[i]); --i)
            {
                if (MEM_UNLIKELY(i == 0))
                    return true;
            }

            return false;
        }
    }

    MEM_STRONG_INLINE const byte* pattern::bytes() const noexcept
    {
        return !bytes_.empty() ? bytes_.data() : nullptr;
    }

    MEM_STRONG_INLINE const byte* pattern::masks() const noexcept
    {
        return !masks_.empty() ? masks_.data() : nullptr;
    }

    MEM_STRONG_INLINE std::size_t pattern::size() const noexcept
    {
        return bytes_.size();
    }

    MEM_STRONG_INLINE std::size_t pattern::trimmed_size() const noexcept
    {
        return trimmed_size_;
    }

    MEM_STRONG_INLINE bool pattern::needs_masks() const noexcept
    {
        return needs_masks_;
    }

    MEM_STRONG_INLINE std::size_t pattern::get_skip_pos(const byte* frequencies) const noexcept
    {
        std::size_t min = SIZE_MAX;
        std::size_t result = SIZE_MAX;

        for (std::size_t i = 0; i < size(); ++i)
        {
            if (masks_[i] == 0xFF)
            {
                std::size_t f = frequencies[bytes_[i]];

                if (f <= min)
                {
                    result = i;
                    min = f;
                }
            }
        }

        return result;
    }

    MEM_STRONG_INLINE pattern::operator bool() const noexcept
    {
        return !bytes_.empty() && !masks_.empty();
    }

    inline std::string pattern::to_string() const
    {
        const char* const hex_chars = "0123456789ABCDEF";

        std::string result;

        for (std::size_t i = 0; i < size(); ++i)
        {
            if (i)
            {
                result += ' ';
            }

            const byte mask = masks_[i];
            const byte value = bytes_[i];

            if (mask != 0x00)
            {
                result += hex_chars[static_cast<std::size_t>(value >> 4)];
                result += hex_chars[static_cast<std::size_t>(value & 0xF)];

                if (mask != 0xFF)
                {
                    result += '&';
                    result += hex_chars[static_cast<std::size_t>(mask >> 4)];
                    result += hex_chars[static_cast<std::size_t>(mask & 0xF)];
                }
            }
            else
            {
                result += '?';
            }
        }

        return result;
    }

    template <typename Scanner>
    class scanner_base
    {
    public:
        pointer operator()(region range) const;

        template <typename Func>
        pointer operator()(region range, Func func) const;

        std::vector<pointer> scan_all(region range) const;
    };

    template <typename Scanner>
    MEM_STRONG_INLINE pointer scanner_base<Scanner>::operator()(region range) const
    {
        return static_cast<const Scanner*>(this)->scan(range);
    }

    template <typename Scanner>
    template <typename Func>
    inline pointer scanner_base<Scanner>::operator()(region range, Func func) const
    {
        while (true)
        {
            const pointer result = static_cast<const Scanner*>(this)->scan(range);

            if (result)
            {
                if (func(result))
                {
                    return result;
                }

                range = range.sub_region(result + 1);
            }
            else
            {
                break;
            }
        }

        return nullptr;
    }

    template <typename Scanner>
    inline std::vector<pointer> scanner_base<Scanner>::scan_all(region range) const
    {
        std::vector<pointer> results;

        (*this)(range, [&results](pointer result) {
            results.emplace_back(result);

            return false;
        });

        return results;
    }
} // namespace mem

#include "simd_scanner.h"

namespace mem
{
    using default_scanner = class simd_scanner;

    inline mem::pointer scan(const mem::pattern& pattern, mem::region range)
    {
        return mem::default_scanner(pattern).scan(range);
    }

    inline std::vector<mem::pointer> scan_all(const mem::pattern& pattern, mem::region range)
    {
        return mem::default_scanner(pattern).scan_all(range);
    }
} // namespace mem

#endif // MEM_PATTERN_BRICK_H

```

`hack/deps/mem/pattern_cache.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_PATTERN_CACHE_BRICK_H
#define MEM_PATTERN_CACHE_BRICK_H

#include "hasher.h"
#include "pattern.h"

#include <unordered_map>

#include <istream>
#include <ostream>

namespace mem
{
    class pattern_cache
    {
    private:
        struct pattern_results
        {
            std::vector<pointer> results {};
            bool checked {false};
        };

        region region_;
        std::unordered_map<std::uint32_t, pattern_results> results_;

        static std::uint32_t hash_pattern(const pattern& pattern);

    public:
        pattern_cache(region range);

        pointer scan(const pattern& pattern, std::size_t index = 0, std::size_t expected = 1);
        const std::vector<pointer>& scan_all(const pattern& pattern);

        void save(std::ostream& output) const;
        bool load(std::istream& input);
    };

    inline std::uint32_t pattern_cache::hash_pattern(const pattern& pattern)
    {
        hasher hash;

        std::size_t length = pattern.size();

        hash.update(length);

        const byte* bytes = pattern.bytes();
        const byte* masks = pattern.masks();

        hash.update(0x435E89AB);
        hash.update(bytes, length);

        hash.update(0xAE1E9528);
        hash.update(masks, length);

        return hash.digest();
    }

    inline pattern_cache::pattern_cache(region range)
        : region_(range)
    {}

    inline pointer pattern_cache::scan(const pattern& pattern, std::size_t index, std::size_t expected)
    {
        const auto& results = scan_all(pattern);

        if (results.size() != expected)
        {
            return nullptr;
        }

        if (index >= results.size())
        {
            return nullptr;
        }

        return results[index];
    }

    inline const std::vector<pointer>& pattern_cache::scan_all(const pattern& pattern)
    {
        const std::uint32_t hash = hash_pattern(pattern);

        auto find = results_.find(hash);

        if (find != results_.end())
        {
            if (!find->second.checked)
            {
                bool changed = false;

                for (pointer result : find->second.results)
                {
                    if (!pattern.match(result))
                    {
                        changed = true;

                        break;
                    }
                }

                if (changed)
                {
                    default_scanner scanner(pattern);

                    find->second.results = scanner.scan_all(region_);
                }
            }
        }
        else
        {
            pattern_results results;

            default_scanner scanner(pattern);
            results.results = scanner.scan_all(region_);

            find = results_.emplace(hash, std::move(results)).first;
        }

        find->second.checked = true;

        return find->second.results;
    }

    namespace stream
    {
        template <typename T>
        inline void write(std::ostream& output, const T& value)
        {
            static_assert(std::is_trivial<T>::value, "Invalid Value");

            output.write(reinterpret_cast<const char*>(&value), sizeof(value));
        }

        template <typename T>
        inline T read(std::istream& input)
        {
            static_assert(std::is_trivial<T>::value, "Invalid Value");

            T result;

            input.read(reinterpret_cast<char*>(&result), sizeof(result));

            return result;
        }
    } // namespace stream

    inline void pattern_cache::save(std::ostream& output) const
    {
        stream::write<std::uint32_t>(output, 0x50415443); // PATC
        stream::write<std::uint32_t>(output, sizeof(std::size_t));
        stream::write<std::size_t>(output, region_.size);
        stream::write<std::size_t>(output, results_.size());

        for (const auto& pattern : results_)
        {
            stream::write<std::uint32_t>(output, pattern.first);
            stream::write<std::size_t>(output, pattern.second.results.size());

            for (const auto& result : pattern.second.results)
            {
                stream::write<std::size_t>(output, static_cast<std::size_t>(result - region_.start));
            }
        }
    }

    inline bool pattern_cache::load(std::istream& input)
    {
        try
        {
            if (stream::read<std::uint32_t>(input) == 0x50415443)
                return false;

            if (stream::read<std::uint32_t>(input) != sizeof(std::size_t))
                return false;

            if (stream::read<std::size_t>(input) != region_.size)
                return false;

            const std::size_t pattern_count = stream::read<std::size_t>(input);

            results_.clear();

            for (std::size_t i = 0; i < pattern_count; ++i)
            {
                const std::uint32_t hash = stream::read<std::uint32_t>(input);
                const std::size_t result_count = stream::read<std::size_t>(input);

                pattern_results results;
                results.checked = false;
                results.results.reserve(result_count);

                for (std::size_t j = 0; j < result_count; ++j)
                {
                    results.results.push_back(region_.start + stream::read<std::size_t>(input));
                }

                results_.emplace(hash, std::move(results));
            }

            return true;
        }
        catch (...)
        {
            return false;
        }
    }
} // namespace mem

#endif // MEM_PATTERN_CACHE_BRICK_H

```

`hack/deps/mem/prot_flags.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_PROT_FLAGS_BRICK_H
#define MEM_PROT_FLAGS_BRICK_H

#include "bitwise_enum.h"
#include "defines.h"

#if defined(_WIN32)
#    if !defined(WIN32_LEAN_AND_MEAN)
#        define WIN32_LEAN_AND_MEAN
#    endif
#    include <Windows.h>
#elif defined(__unix__)
#    include <sys/mman.h>
#else
#    error Unknown Platform
#endif

namespace mem
{
    namespace enums
    {
        enum prot_flags : std::uint32_t
        { // clang-format off
            NONE = 0x0, // No Access

            R = 0x1, // Read
            W = 0x2, // Write
            X = 0x4, // Execute
            C = 0x8, // Copy On Write

            G = 0x10, // Guard

            INVALID = 0x80000000, // Invalid

            RW   = R | W,
            RX   = R     | X,
            RWX  = R | W | X,
            RWC  = R | W     | C,
            RWXC = R | W | X | C,
        }; // clang-format on

        MEM_DEFINE_ENUM_FLAG_OPERATORS(prot_flags)
    } // namespace enums

    using enums::prot_flags;

#if defined(_WIN32)
    using native_prot = DWORD;
#elif defined(__unix__)
    using native_prot = int;
#endif

    MEM_CONSTEXPR_14 native_prot from_prot_flags(prot_flags flags) noexcept;
    MEM_CONSTEXPR_14 prot_flags to_prot_flags(native_prot flags) noexcept;

    inline MEM_CONSTEXPR_14 native_prot from_prot_flags(prot_flags flags) noexcept
    { // clang-format off
#if defined(_WIN32)
        native_prot result = PAGE_NOACCESS;

        if (flags & prot_flags::X)
        {
            if      (flags & prot_flags::C) { result = PAGE_EXECUTE_WRITECOPY; }
            else if (flags & prot_flags::W) { result = PAGE_EXECUTE_READWRITE; }
            else if (flags & prot_flags::R) { result = PAGE_EXECUTE_READ;      }
            else                            { result = PAGE_EXECUTE;           }
        }
        else
        {
            if      (flags & prot_flags::C) { result = PAGE_EXECUTE_WRITECOPY; }
            else if (flags & prot_flags::W) { result = PAGE_READWRITE; }
            else if (flags & prot_flags::R) { result = PAGE_READONLY;  }
            else                            { result = PAGE_NOACCESS;  }
        }

        if (flags & prot_flags::G)
            result |= PAGE_GUARD;

        return result;
#elif defined(__unix__)
        native_prot result = 0;

        if (flags & prot_flags::R)
            result |= PROT_READ;
        if (flags & prot_flags::W)
            result |= PROT_WRITE;
        if (flags & prot_flags::X)
            result |= PROT_EXEC;

        return result;
#endif
    } // clang-format on

    inline MEM_CONSTEXPR_14 prot_flags to_prot_flags(native_prot flags) noexcept
    { // clang-format off
#if defined(_WIN32)
        prot_flags result = prot_flags::NONE;

        switch (flags & 0xFF)
        {
            case PAGE_EXECUTE:
                result = prot_flags::X;
                break;
            case PAGE_EXECUTE_READ:
                result = prot_flags::RX;
                break;
            case PAGE_EXECUTE_READWRITE:
                result = prot_flags::RWX;
                break;
            case PAGE_EXECUTE_WRITECOPY:
                result = prot_flags::RWXC;
                break;
            case PAGE_NOACCESS:
                result = prot_flags::NONE;
                break;
            case PAGE_READONLY:
                result = prot_flags::R;
                break;
            case PAGE_READWRITE:
                result = prot_flags::RW;
                break;
            case PAGE_WRITECOPY:
                result = prot_flags::RWC;
                break;
            default:
                result = prot_flags::INVALID;
                break;
        }

        if (flags & PAGE_GUARD)
            result |= prot_flags::G;

        return result;
#elif defined(__unix__)
        prot_flags result = prot_flags::NONE;

        if (flags & PROT_READ)
            result |= prot_flags::R;

        if (flags & PROT_WRITE)
            result |= prot_flags::W;

        if (flags & PROT_EXEC)
            result |= prot_flags::X;

        return result;
#endif
    } // clang-format on
} // namespace mem

#endif // MEM_PROT_FLAGS_BRICK_H

```

`hack/deps/mem/protect.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_PROTECT_BRICK_H
#define MEM_PROTECT_BRICK_H

#include "mem.h"
#include "prot_flags.h"

#include <cstdio>

#if defined(_WIN32)
#    if !defined(WIN32_LEAN_AND_MEAN)
#        define WIN32_LEAN_AND_MEAN
#    endif
#    include <Windows.h>
#elif defined(__unix__)
#    if !defined(_GNU_SOURCE)
#        define _GNU_SOURCE
#    endif
#    include <cinttypes>
#    include <sys/mman.h>
#    include <unistd.h>
#else
#    error Unknown Platform
#endif

namespace mem
{
    std::size_t page_size();

    void* protect_alloc(std::size_t length, prot_flags flags);
    void protect_free(void* memory, std::size_t length);

    prot_flags protect_query(void* memory);

    bool protect_modify(void* memory, std::size_t length, prot_flags flags, prot_flags* old_flags = nullptr);

#if defined(__unix__)
    struct region_info
    {
        std::uintptr_t start;
        std::uintptr_t end;
        std::size_t offset;
        int prot;
        int flags;
        const char* path_name;
    };

    int iter_proc_maps(int (*callback)(region_info*, void*), void* data);
#endif

    class protect : public region
    {
    private:
        prot_flags old_flags_ {prot_flags::INVALID};
        bool success_ {false};

    public:
        protect(region range, prot_flags flags = prot_flags::RWX);
        ~protect();

        protect(protect&& rhs) noexcept;
        protect(const protect&) = delete;

        explicit operator bool() const noexcept;
        prot_flags release() noexcept;
    };

    inline std::size_t page_size()
    {
#if defined(_WIN32)
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        return static_cast<std::size_t>(si.dwPageSize);
#elif defined(__unix__)
        return static_cast<std::size_t>(sysconf(_SC_PAGESIZE));
#endif
    }

    inline void* protect_alloc(std::size_t length, prot_flags flags)
    {
#if defined(_WIN32)
        return VirtualAlloc(nullptr, length, MEM_RESERVE | MEM_COMMIT, from_prot_flags(flags));
#elif defined(__unix__)
        void* result = mmap(nullptr, length, from_prot_flags(flags), MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
        if (result == MAP_FAILED)
            result = nullptr;
        return result;
#endif
    }

    inline void protect_free(void* memory, std::size_t length)
    {
        if (memory != nullptr)
        {
#if defined(_WIN32)
            (void) length;
            VirtualFree(memory, 0, MEM_RELEASE);
#elif defined(__unix__)
            munmap(memory, length);
#endif
        }
    }

#if defined(__unix__)
    namespace internal
    {
        struct prot_query
        {
            std::uintptr_t address;
            prot_flags result;
        };

        inline int prot_query_callback(region_info* region, void* data)
        {
            prot_query* query = static_cast<prot_query*>(data);

            if ((query->address >= region->start) && (query->address < region->end))
            {
                query->result = to_prot_flags(region->prot);

                return 1;
            }

            return 0;
        }
    } // namespace internal
#endif

    inline prot_flags protect_query(void* memory)
    {
#if defined(_WIN32)
        MEMORY_BASIC_INFORMATION info;

        if (VirtualQuery(memory, &info, sizeof(info)))
            return to_prot_flags(info.Protect);

        return prot_flags::INVALID;
#elif defined(__unix__)
        internal::prot_query query;
        query.address = reinterpret_cast<std::uintptr_t>(memory);

        if (iter_proc_maps(&internal::prot_query_callback, &query))
        {
            return query.result;
        }

        return prot_flags::INVALID;
#endif
    }

    inline bool protect_modify(void* memory, std::size_t length, prot_flags flags, prot_flags* old_flags)
    {
        if (flags == prot_flags::INVALID)
            return false;

#if defined(_WIN32)
        DWORD old_protect = 0;
        bool success = VirtualProtect(memory, length, from_prot_flags(flags), &old_protect) != FALSE;

        if (old_flags)
            *old_flags = success ? to_prot_flags(old_protect) : prot_flags::INVALID;

        return success;
#elif defined(__unix__)
        if (old_flags)
            *old_flags = protect_query(memory);

        return mprotect(memory, length, from_prot_flags(flags)) == 0;
#endif
    }

#if defined(__unix__)
    inline int iter_proc_maps(int (*callback)(region_info*, void*), void* data)
    {
        std::FILE* maps = std::fopen("/proc/self/maps", "r");

        int result = 0;

        if (maps != nullptr)
        {
            char buffer[256];

            region_info region;

            char perms[5];
            char pathname[256];

            while (std::fgets(buffer, 256, maps))
            {
                int count = std::sscanf(buffer, "%" SCNxPTR "-%" SCNxPTR " %4s %zx %*x:%*x %*u %255s", &region.start,
                    &region.end, perms, &region.offset, pathname);

                if (count < 4)
                    continue;

                region.prot = PROT_NONE;
                region.flags = 0;

                if (perms[0] == 'r')
                    region.prot |= PROT_READ;

                if (perms[1] == 'w')
                    region.prot |= PROT_WRITE;

                if (perms[2] == 'x')
                    region.prot |= PROT_EXEC;

                if (perms[3] == 's')
                    region.flags |= MAP_SHARED;
                else if (perms[3] == 'p')
                    region.flags |= MAP_PRIVATE;

                if (count > 4)
                {
                    region.path_name = pathname;
                }
                else
                {
                    region.flags |= MAP_ANONYMOUS;
                    region.path_name = nullptr;
                }

                result = callback(&region, data);

                if (result)
                    break;
            }

            std::fclose(maps);
        }

        return result;
    }
#endif

    MEM_STRONG_INLINE protect::protect(region range, prot_flags flags)
        : region(range)
        , old_flags_(prot_flags::INVALID)
        , success_(protect_modify(start.as<void*>(), size, flags, &old_flags_))
    {}

    MEM_STRONG_INLINE protect::~protect()
    {
        if (success_)
        {
            protect_modify(start.as<void*>(), size, old_flags_, nullptr);
        }
    }

    MEM_STRONG_INLINE protect::protect(protect&& rhs) noexcept
        : region(rhs)
        , old_flags_(rhs.old_flags_)
        , success_(rhs.success_)
    {
        rhs.old_flags_ = prot_flags::INVALID;
        rhs.success_ = false;
    }

    MEM_STRONG_INLINE protect::operator bool() const noexcept
    {
        return success_;
    }

    MEM_STRONG_INLINE prot_flags protect::release() noexcept
    {
        success_ = false;

        return old_flags_;
    }
} // namespace mem

#endif // MEM_PROTECT_BRICK_H

```

`hack/deps/mem/rtti.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_RTTI_BRICK_H
#define MEM_RTTI_BRICK_H

#include "mem.h"

#if defined(MEM_ARCH_X86) || defined(MEM_ARCH_X86_64)
#    if !defined(_WIN32)
#        error mem::rtti only supports windows
#    endif // !_WIN32
#else
#    error mem::rtti only supports x86 and x64
#endif

#include <functional>

namespace mem
{
    namespace rtti
    {
        struct PMD;
        struct RTTITypeDescriptor;
        struct RTTICompleteObjectLocator;
        struct RTTIClassHierarchyDescriptor;
        struct RTTIBaseClassArray;
        struct RTTIBaseClassDescriptor;

        struct PMD
        {
            std::int32_t mdisp; // member displacement
            std::int32_t pdisp; // vbtable displacement
            std::int32_t vdisp; // displacement inside vbtable
        };

        struct RTTITypeDescriptor // type_info
        {
            void* vTable;
            const char* UndecoratedName;
            const char DecoratedName[1];

#if defined(MEM_RTTI_DEMANGLE)
            std::string demangle() const;
#endif // MEM_RTTI_DEMANGLE
        };

        struct RTTICompleteObjectLocator
        {
            std::uint32_t signature;        // 0 = x86, 1 = x64
            std::uint32_t offset;           // offset of this vtable in the complete class
            std::uint32_t cdOffset;         // constructor displacement offset
            std::uint32_t pTypeDescriptor;  // TypeDescriptor of the complete class
            std::uint32_t pClassDescriptor; // describes inheritance hierarchy

#if defined(MEM_ARCH_X86_64)
            std::uint32_t pSelf;
#endif // MEM_ARCH_X86_64

            bool check_signature() const;
            RTTITypeDescriptor* get_type(const region& region) const;
            RTTIClassHierarchyDescriptor* get_class(const region& region) const;

#if defined(MEM_ARCH_X86_64)
            RTTICompleteObjectLocator* get_self(const region& region) const;
#endif // MEM_ARCH_X86_64
        };

        struct RTTIClassHierarchyDescriptor
        {
            std::uint32_t signature;      // 0 = x86, 1 = x64
            std::uint32_t attributes;     // bit 0 set = multiple inheritance, bit 1 set = virtual inheritance
            std::uint32_t numBaseClasses; // number of base classes
            std::uint32_t pBaseClassArray;

            bool check_signature() const;
            std::uint32_t get_base_count() const;
            RTTIBaseClassArray* get_base_classes(const region& region) const;

            bool inherits_from(const region& region, const RTTITypeDescriptor* type) const;
        };

        struct RTTIBaseClassArray
        {
            std::uint32_t arrayOfBaseClassDescriptors[1];

            RTTIBaseClassDescriptor* get_base_class(const region& region, std::uint32_t index) const;
        };

        struct RTTIBaseClassDescriptor
        {
            std::uint32_t pTypeDescriptor;   // type descriptor of the class
            std::uint32_t numContainedBases; // number of nested classes following in the Base Class Array
            PMD where;                       // pointer-to-member displacement info
            std::uint32_t attributes;        // flags, usually 0

            RTTITypeDescriptor* get_type(const region& region) const;
        };

        void enumerate_rtti(const region& region,
            std::function<bool(
                const void** vTable, const RTTICompleteObjectLocator* object, const RTTITypeDescriptor* type)>
                callback);
        const RTTITypeDescriptor* find_rtti_type(const region& region, const char* name);

        inline constexpr bool check_rtti_signature(std::uint32_t signature) noexcept
        {
#if defined(MEM_ARCH_X86_64)
            return signature == 1;
#elif defined(MEM_ARCH_X86)
            return signature == 0;
#else
#    error "Invalid Architecture"
#endif
        }

        template <typename T>
        inline T* get_rtti_pointer(const region& region, std::uint32_t address) noexcept
        {
#if defined(MEM_ARCH_X86_64)
            return region.start.add(address).as<T*>();
#elif defined(MEM_ARCH_X86)
            const pointer result = address;

            return region.contains(result) ? result.as<T*>() : nullptr;
#else
#    error "Invalid Architecture"
#endif
        }

#if defined(MEM_RTTI_DEMANGLE)
        inline std::string RTTITypeDescriptor::demangle() const
        {
            char buffer[1024];

            if (DWORD symbol_size = UnDecorateSymbolName(DecoratedName + 1, buffer, 1024,
                    UNDNAME_32_BIT_DECODE | UNDNAME_NAME_ONLY | UNDNAME_NO_ARGUMENTS | UNDNAME_NO_MS_KEYWORDS))
            {
                return std::string(buffer, symbol_size);
            }

            return "";
        }
#endif // MEM_RTTI_DEMANGLE

        inline bool RTTICompleteObjectLocator::check_signature() const
        {
            return check_rtti_signature(signature);
        }

        inline RTTITypeDescriptor* RTTICompleteObjectLocator::get_type(const region& region) const
        {
            return get_rtti_pointer<RTTITypeDescriptor>(region, pTypeDescriptor);
        }

        inline RTTIClassHierarchyDescriptor* RTTICompleteObjectLocator::get_class(const region& region) const
        {
            return get_rtti_pointer<RTTIClassHierarchyDescriptor>(region, pClassDescriptor);
        }

#if defined(MEM_ARCH_X86_64)
        inline RTTICompleteObjectLocator* RTTICompleteObjectLocator::get_self(const region& region) const
        {
            return get_rtti_pointer<RTTICompleteObjectLocator>(region, pSelf);
        }
#endif // MEM_ARCH_X86_64

        inline bool RTTIClassHierarchyDescriptor::check_signature() const
        {
            return check_rtti_signature(signature);
        }

        inline std::uint32_t RTTIClassHierarchyDescriptor::get_base_count() const
        {
            return numBaseClasses;
        }

        inline RTTIBaseClassArray* RTTIClassHierarchyDescriptor::get_base_classes(const region& region) const
        {
            return get_rtti_pointer<RTTIBaseClassArray>(region, pBaseClassArray);
        }

        inline bool RTTIClassHierarchyDescriptor::inherits_from(
            const region& region, const RTTITypeDescriptor* type) const
        {
            const RTTIBaseClassArray* base_classes = get_base_classes(region);

            for (std::uint32_t i = 1; i < get_base_count(); ++i)
            {
                const RTTIBaseClassDescriptor* base_class = base_classes->get_base_class(region, i);
                const RTTITypeDescriptor* base_type = base_class->get_type(region);

                if (!std::strcmp(base_type->DecoratedName, type->DecoratedName))
                {
                    return true;
                }
            }

            return false;
        }

        inline RTTIBaseClassDescriptor* RTTIBaseClassArray::get_base_class(
            const region& region, std::uint32_t index) const
        {
            return get_rtti_pointer<RTTIBaseClassDescriptor>(region, arrayOfBaseClassDescriptors[index]);
        }

        inline RTTITypeDescriptor* RTTIBaseClassDescriptor::get_type(const region& region) const
        {
            return get_rtti_pointer<RTTITypeDescriptor>(region, pTypeDescriptor);
        }

        inline void enumerate_rtti(const region& region,
            std::function<bool(
                const void** vTable, const RTTICompleteObjectLocator* object, const RTTITypeDescriptor* type)>
                callback)
        {
            for (std::size_t i = 0; i < region.size; i += sizeof(void*))
            {
                const RTTICompleteObjectLocator*& locator = region.start.at<const RTTICompleteObjectLocator*>(i);

                if (!region.contains<RTTICompleteObjectLocator>(locator))
                {
                    continue;
                }

                if (!locator->check_signature())
                {
                    continue;
                }

#if defined(MEM_ARCH_X86_64)
                if (locator->get_self(region) != locator)
                {
                    continue;
                }
#endif // MEM_ARCH_X86_64

                const RTTITypeDescriptor* type = locator->get_type(region);

                if (!type)
                {
                    continue;
                }

                if (!region.contains<void*>(type->vTable))
                {
                    continue;
                }

                if (strncmp(type->DecoratedName, ".?", 2))
                {
                    continue;
                }

                if (callback(reinterpret_cast<const void**>(&locator + 1), locator, type))
                {
                    break;
                }
            }
        }

#if defined(MEM_RTTI_DEMANGLE)
        inline const RTTITypeDescriptor* find_rtti_type(const region& region, const char* name)
        {
            const RTTITypeDescriptor* result = nullptr;

            enumerate_rtti(region,
                [&result, name](
                    const void**, const RTTICompleteObjectLocator*, const RTTITypeDescriptor* type) -> bool {
                    if (type->demangle() == name)
                    {
                        result = type;

                        return true;
                    }

                    return false;
                });

            return result;
        }
#endif // MEM_RTTI_DEMANGLE
    }  // namespace rtti
} // namespace mem
#endif // !MEM_RTTI_BRICK_H

```

`hack/deps/mem/simd_scanner.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_SIMD_SCANNER_BRICK_H
#define MEM_SIMD_SCANNER_BRICK_H

#include "pattern.h"

#if !defined(MEM_SIMD_SCANNER_USE_MEMCHR)
#    if defined(MEM_SIMD_AVX2)
#        include <immintrin.h>
#    elif defined(MEM_SIMD_SSE2)
#        include <emmintrin.h>
#    else
#        define MEM_SIMD_SCANNER_USE_MEMCHR
#    endif
#endif

#if !defined(MEM_SIMD_SCANNER_USE_MEMCHR)
#    include "arch.h"
#endif

namespace mem
{
    class simd_scanner : public scanner_base<simd_scanner>
    {
    private:
        const pattern* pattern_ {nullptr};
        std::size_t skip_pos_ {SIZE_MAX};

    public:
        simd_scanner() = default;

        simd_scanner(const pattern& pattern);
        simd_scanner(const pattern& pattern, const byte* frequencies);

        pointer scan(region range) const;

        static const byte* default_frequencies() noexcept;
    };

    const byte* find_byte(const byte* ptr, byte value, std::size_t num);

    inline simd_scanner::simd_scanner(const pattern& _pattern)
        : simd_scanner(_pattern, default_frequencies())
    {}

    inline simd_scanner::simd_scanner(const pattern& _pattern, const byte* frequencies)
        : pattern_(&_pattern)
        , skip_pos_(_pattern.get_skip_pos(frequencies))
    {}

    MEM_STRONG_INLINE const byte* simd_scanner::default_frequencies() noexcept
    {
        // clang-format off
        static constexpr const byte frequencies[256]
        {
            0xFF,0xFB,0xF2,0xEE,0xEC,0xE7,0xDC,0xC8,0xED,0xB7,0xCC,0xC0,0xD3,0xCD,0x89,0xFA,
            0xF3,0xD6,0x8D,0x83,0xC1,0xAA,0x7A,0x72,0xC6,0x60,0x3E,0x2E,0x98,0x69,0x39,0x7C,
            0xEB,0x76,0x24,0x34,0xF9,0x50,0x04,0x07,0xE5,0xAC,0x53,0x65,0x9B,0x4D,0x6D,0x5C,
            0xDA,0x93,0x7F,0xCB,0x92,0x49,0x43,0x09,0xBA,0x8E,0x1E,0x91,0x8A,0x5B,0x11,0xA1,
            0xE8,0xF5,0x9E,0xAD,0xEF,0xE6,0x79,0x7B,0xFE,0xE0,0x1F,0x54,0xE4,0xBD,0x7D,0x6A,
            0xDF,0x67,0x7E,0xA4,0xB6,0xAF,0x88,0xA0,0xC3,0xA9,0x26,0x77,0xD1,0x71,0x61,0xC2,
            0x9A,0xCA,0x29,0x9F,0xD8,0xE2,0xD0,0x6E,0xB4,0xB8,0x25,0x3C,0xBF,0x73,0xB5,0xCF,
            0xD4,0x01,0xCE,0xBE,0xF1,0xDB,0x52,0x37,0x9D,0x63,0x02,0x6B,0x80,0x45,0x2B,0x95,
            0xE1,0xC4,0x36,0xF0,0xD5,0xE3,0x57,0x9C,0xB1,0xF7,0x82,0xFC,0x42,0xF6,0x18,0x33,
            0xD2,0x48,0x05,0x0F,0x41,0x1D,0x03,0x27,0x70,0x10,0x00,0x08,0x55,0x16,0x2F,0x0E,
            0x94,0x35,0x2C,0x40,0x6F,0x3B,0x1C,0x28,0x90,0x68,0x81,0x4B,0x56,0x30,0x2A,0x3D,
            0x97,0x17,0x06,0x13,0x32,0x0B,0x5A,0x75,0xA5,0x86,0x78,0x4F,0x2D,0x51,0x46,0x5F,
            0xE9,0xDE,0xA2,0xDD,0xC9,0x4C,0xAB,0xBB,0xC7,0xB9,0x74,0x8F,0xF8,0x6C,0x85,0x8B,
            0xC5,0x84,0x8C,0x66,0x21,0x23,0x64,0x59,0xA3,0x87,0x44,0x58,0x3A,0x0D,0x12,0x19,
            0xAE,0x5E,0x3F,0x38,0x31,0x22,0x0A,0x14,0xF4,0xD9,0x20,0xB0,0xB2,0x1A,0x0C,0x15,
            0xB3,0x47,0x5D,0xEA,0x4A,0x1B,0x99,0xBC,0xD7,0xA6,0x62,0x4E,0xA8,0x96,0xA7,0xFD,
        };
        // clang-format on

        return frequencies;
    }

    inline pointer simd_scanner::scan(region range) const
    {
        const std::size_t trimmed_size = pattern_->trimmed_size();

        if (!trimmed_size)
            return nullptr;

        const std::size_t original_size = pattern_->size();
        const std::size_t region_size = range.size;

        if (original_size > region_size)
            return nullptr;

        const byte* const region_base = range.start.as<const byte*>();
        const byte* const region_end = region_base + region_size;

        const byte* current = region_base;
        const byte* const end = region_end - original_size + 1;

        const std::size_t last = trimmed_size - 1;

        const byte* const pat_bytes = pattern_->bytes();

        const std::size_t skip_pos = skip_pos_;

        if (skip_pos != SIZE_MAX)
        {
            if (pattern_->needs_masks())
            {
                const byte* const pat_masks = pattern_->masks();

                while (MEM_LIKELY(current < end))
                {
                    [[MEM_ATTR_LIKELY]];

                    for (std::size_t i = last; MEM_LIKELY((current[i] & pat_masks[i]) == pat_bytes[i]); --i)
                    {
                        [[MEM_ATTR_LIKELY]];

                        if (MEM_UNLIKELY(i == 0)) [[MEM_ATTR_UNLIKELY]]
                            return current;
                    }

                    ++current;
                    current =
                        find_byte(current + skip_pos, pat_bytes[skip_pos], static_cast<std::size_t>(end - current)) -
                        skip_pos;
                }

                return nullptr;
            }
            else
            {
                while (MEM_LIKELY(current < end))
                {
                    [[MEM_ATTR_LIKELY]];

                    for (std::size_t i = last; MEM_LIKELY(current[i] == pat_bytes[i]); --i)
                    {
                        [[MEM_ATTR_LIKELY]];

                        if (MEM_UNLIKELY(i == 0)) [[MEM_ATTR_UNLIKELY]]
                            return current;
                    }

                    ++current;
                    current =
                        find_byte(current + skip_pos, pat_bytes[skip_pos], static_cast<std::size_t>(end - current)) -
                        skip_pos;
                }

                return nullptr;
            }
        }
        else
        {
            const byte* const pat_masks = pattern_->masks();

            while (MEM_LIKELY(current < end))
            {
                [[MEM_ATTR_LIKELY]];

                for (std::size_t i = last; MEM_LIKELY((current[i] & pat_masks[i]) == pat_bytes[i]); --i)
                {
                    [[MEM_ATTR_LIKELY]];

                    if (MEM_UNLIKELY(i == 0)) [[MEM_ATTR_UNLIKELY]]
                        return current;
                }

                ++current;
            }

            return nullptr;
        }
    }

    MEM_STRONG_INLINE const byte* find_byte(const byte* ptr, byte value, std::size_t num)
    {
#if !defined(MEM_SIMD_SCANNER_USE_MEMCHR)
#    if defined(MEM_SIMD_AVX2)
#        define l_SIMD_TYPE __m256i
#        define l_SIMD_FILL(x) _mm256_set1_epi8(static_cast<char>(x))
#        define l_SIMD_LOAD(x) _mm256_loadu_si256(x)
#        define l_SIMD_CMPEQ(x, y) _mm256_cmpeq_epi8(x, y)
#        define l_SIMD_MOVEMASK(x) static_cast<unsigned int>(_mm256_movemask_epi8(x))
#    elif defined(MEM_SIMD_SSE2)
#        define l_SIMD_TYPE __m128i
#        define l_SIMD_FILL(x) _mm_set1_epi8(static_cast<char>(x))
#        define l_SIMD_LOAD(x) _mm_loadu_si128(x)
#        define l_SIMD_CMPEQ(x, y) _mm_cmpeq_epi8(x, y)
#        define l_SIMD_MOVEMASK(x) static_cast<unsigned int>(_mm_movemask_epi8(x))
#    else
#        error Sorry, No Potatoes
#    endif

#    define l_SIMD_SIZEOF(N) (sizeof(l_SIMD_TYPE) * N)
#    define l_SIMD_CMPEQ_MASK(x, y) l_SIMD_MOVEMASK(l_SIMD_CMPEQ(x, y))

        if (MEM_LIKELY(num >= l_SIMD_SIZEOF(1)))
        {
            [[MEM_ATTR_LIKELY]];

            const l_SIMD_TYPE simd_value = l_SIMD_FILL(value);

            while (MEM_LIKELY(num >= l_SIMD_SIZEOF(4)))
            {
                [[MEM_ATTR_LIKELY]];

                num -= l_SIMD_SIZEOF(4);

                const l_SIMD_TYPE value0 = l_SIMD_LOAD(reinterpret_cast<const l_SIMD_TYPE*>(ptr));
                const l_SIMD_TYPE value1 = l_SIMD_LOAD(reinterpret_cast<const l_SIMD_TYPE*>(ptr + l_SIMD_SIZEOF(1)));
                const l_SIMD_TYPE value2 = l_SIMD_LOAD(reinterpret_cast<const l_SIMD_TYPE*>(ptr + l_SIMD_SIZEOF(2)));
                const l_SIMD_TYPE value3 = l_SIMD_LOAD(reinterpret_cast<const l_SIMD_TYPE*>(ptr + l_SIMD_SIZEOF(3)));

                ptr += l_SIMD_SIZEOF(4);

                {
                    const auto mask = l_SIMD_CMPEQ_MASK(value0, simd_value);

                    if (MEM_UNLIKELY(mask != 0)) [[MEM_ATTR_UNLIKELY]]
                        return ptr - l_SIMD_SIZEOF(4) + bsf(mask);
                }

                {
                    const auto mask = l_SIMD_CMPEQ_MASK(value1, simd_value);

                    if (MEM_UNLIKELY(mask != 0)) [[MEM_ATTR_UNLIKELY]]
                        return ptr - l_SIMD_SIZEOF(3) + bsf(mask);
                }

                {
                    const auto mask = l_SIMD_CMPEQ_MASK(value2, simd_value);

                    if (MEM_UNLIKELY(mask != 0)) [[MEM_ATTR_UNLIKELY]]
                        return ptr - l_SIMD_SIZEOF(2) + bsf(mask);
                }

                {
                    const auto mask = l_SIMD_CMPEQ_MASK(value3, simd_value);

                    if (MEM_UNLIKELY(mask != 0)) [[MEM_ATTR_UNLIKELY]]
                        return ptr - l_SIMD_SIZEOF(1) + bsf(mask);
                }
            }

            while (MEM_LIKELY(num >= l_SIMD_SIZEOF(1)))
            {
                [[MEM_ATTR_LIKELY]];

                num -= l_SIMD_SIZEOF(1);

                const auto mask = l_SIMD_CMPEQ_MASK(l_SIMD_LOAD(reinterpret_cast<const l_SIMD_TYPE*>(ptr)), simd_value);

                ptr += l_SIMD_SIZEOF(1);

                if (MEM_UNLIKELY(mask != 0)) [[MEM_ATTR_UNLIKELY]]
                    return ptr - l_SIMD_SIZEOF(1) + bsf(mask);
            }
        }

        while (MEM_LIKELY(num != 0))
        {
            [[MEM_ATTR_LIKELY]];

            --num;

            if (MEM_UNLIKELY(*ptr == value)) [[MEM_ATTR_UNLIKELY]]
                return ptr;

            ++ptr;
        }

        return ptr;

#    undef l_SIMD_TYPE
#    undef l_SIMD_FILL
#    undef l_SIMD_LOAD
#    undef l_SIMD_LOADU
#    undef l_SIMD_CMPEQ
#    undef l_SIMD_MOVEMASK
#    undef l_SIMD_SIZEOF
#    undef l_SIMD_CMPEQ_MASK
#else
        const byte* result = static_cast<const byte*>(std::memchr(ptr, value, num));

        if (MEM_UNLIKELY(result == nullptr)) [[MEM_ATTR_UNLIKELY]]
            result = ptr + num;

        return result;
#endif
    }
} // namespace mem

#endif // MEM_SIMD_SCANNER_BRICK_H

```

`hack/deps/mem/slice.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_SLICE_BRICK_H
#define MEM_SLICE_BRICK_H

#include "defines.h"

namespace mem
{
    template <typename T, typename U>
    struct copy_cv
    {
        typedef U type;
    };

    template <typename T, typename U>
    struct copy_cv<const T, U>
    {
        typedef const U type;
    };

    template <typename T, typename U>
    struct copy_cv<volatile T, U>
    {
        typedef volatile U type;
    };

    template <typename T, typename U>
    struct copy_cv<const volatile T, U>
    {
        typedef const volatile U type;
    };

    template <typename T>
    class slice
    {
    private:
        T* start_ {nullptr};
        std::size_t size_ {0};

    public:
        constexpr slice() noexcept = default;
        constexpr slice(T* begin, T* end) noexcept;
        constexpr slice(T* start_, std::size_t size_) noexcept;

        constexpr T& operator[](std::size_t index) const noexcept;

        constexpr T* data() const noexcept;
        constexpr T* begin() const noexcept;
        constexpr T* end() const noexcept;

        constexpr std::size_t size() const noexcept;
        constexpr bool empty() const noexcept;

        slice<typename copy_cv<T, byte>::type> as_bytes() const noexcept;

        using value_type = T;

        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;

        using reference = value_type&;
        using const_reference = const value_type&;

        using pointer = value_type*;
        using const_pointer = const value_type*;

        using iterator = value_type*;
        using const_iterator = const value_type*;
    };

    template <typename T>
    MEM_STRONG_INLINE constexpr slice<T>::slice(T* begin, T* end) noexcept
        : start_(begin)
        , size_(end - begin)
    {}

    template <typename T>
    MEM_STRONG_INLINE constexpr slice<T>::slice(T* start, std::size_t size) noexcept
        : start_(start)
        , size_(size)
    {}

    template <typename T>
    MEM_STRONG_INLINE constexpr T& slice<T>::operator[](std::size_t index) const noexcept
    {
        return start_[index];
    }

    template <typename T>
    MEM_STRONG_INLINE constexpr T* slice<T>::data() const noexcept
    {
        return start_;
    }

    template <typename T>
    MEM_STRONG_INLINE constexpr T* slice<T>::begin() const noexcept
    {
        return start_;
    }

    template <typename T>
    MEM_STRONG_INLINE constexpr T* slice<T>::end() const noexcept
    {
        return start_ + size_;
    }

    template <typename T>
    MEM_STRONG_INLINE constexpr std::size_t slice<T>::size() const noexcept
    {
        return size_;
    }

    template <typename T>
    MEM_STRONG_INLINE constexpr bool slice<T>::empty() const noexcept
    {
        return size_ == 0;
    }

    template <typename T>
    MEM_STRONG_INLINE slice<typename copy_cv<T, byte>::type> slice<T>::as_bytes() const noexcept
    {
        return {reinterpret_cast<typename copy_cv<T, byte>::type*>(start_), size_ * sizeof(T)};
    }
} // namespace mem

#endif // MEM_SLICE_BRICK_H

```

`hack/deps/mem/stub.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_STUB_BRICK_H
#define MEM_STUB_BRICK_H

#include "mem.h"

#if defined(__cpp_lib_invoke) && (__cpp_lib_invoke >= 201411)
#    include <functional>
#else
#    error mem::stub requires std::invoke
#endif

namespace mem
{
    template <typename Func, typename... Args>
    MEM_STRONG_INLINE decltype(auto) stub(mem::pointer address, Args&&... args)
    {
        return std::invoke(address.as<Func>(), std::forward<Args>(args)...);
    }
} // namespace mem

#endif // MEM_STUB_BRICK_H

```

`hack/deps/mem/utils.h`:

```h
/*
    Copyright 2018 Brick

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    and associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MEM_UTILS_BRICK_H
#define MEM_UTILS_BRICK_H

#include "mem.h"

#include <string>
#include <vector>

#include "char_queue.h"

namespace mem
{
    bool is_ascii(region range) noexcept;
    bool is_utf8(region range) noexcept;

    std::string as_string(region range);
    std::string as_hex(region range, bool upper_case = true, bool padded = true);

    std::vector<byte> unescape(const char* string, std::size_t length, bool strict = false);

    MEM_STRONG_INLINE bool is_ascii(region range) noexcept
    {
        for (std::size_t i = 0; i < range.size; ++i)
        {
            if (range.start.at<const byte>(i) >= 0x80)
            {
                return false;
            }
        }

        return true;
    }

    inline bool is_utf8(region range) noexcept
    {
        // clang-format off
        static constexpr const std::uint8_t utf8_length_table[256]
        {
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
            4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,
        };
        // clang-format on

        for (std::size_t i = 0; i < range.size;)
        {
            const std::size_t length = utf8_length_table[range.start.at<const byte>(i)];

            if (length == 0)
            {
                return false;
            }

            if ((i + length) > range.size)
            {
                return false;
            }

            for (std::size_t j = 1; j < length; ++j)
            {
                if ((range.start.at<const byte>(i + j) & 0xC0) != 0x80)
                {
                    return false;
                }
            }

            i += length;
        }

        return true;
    }

    inline std::string as_string(region range)
    {
        return std::string(range.start.as<const char*>(), range.size);
    }

    inline std::string as_hex(region range, bool upper_case, bool padded)
    {
        const char* const char_hex_table = upper_case ? "0123456789ABCDEF" : "0123456789abcdef";

        std::string result;

        result.reserve(range.size * (padded ? 3 : 2));

        for (std::size_t i = 0; i < range.size; ++i)
        {
            if (i && padded)
            {
                result.push_back(' ');
            }

            const byte value = range.start.at<const byte>(i);

            result.push_back(char_hex_table[(value >> 4) & 0xF]);
            result.push_back(char_hex_table[(value >> 0) & 0xF]);
        }

        return result;
    }

    inline std::vector<byte> unescape(const char* string, std::size_t length, bool strict)
    {
        std::vector<byte> results;

        char_queue input(string, length);

        while (input)
        {
            std::size_t result = SIZE_MAX;
            std::size_t count = 0;

            bool output_utf8 = false;

            int current = -1;
            int temp = -1;

            current = input.peek();
            input.pop();

            if (current == '\\')
            { // clang-format off
                current = input.peek();
                input.pop();

                if      (current == '\'') { result = 0x27; }
                else if (current == '\"') { result = 0x22; }
                else if (current == '\\') { result = 0x5C; }
                else if (current == '?')  { result = 0x3F; }
                else if (current == 'a')  { result = 0x07; }
                else if (current == 'b')  { result = 0x08; }
                else if (current == 'e')  { result = 0x1B; }
                else if (current == 'f')  { result = 0x0C; }
                else if (current == 'n')  { result = 0x0A; }
                else if (current == 'r')  { result = 0x0D; }
                else if (current == 't')  { result = 0x09; }
                else if (current == 'v')  { result = 0x0B; }
                else if (current == 'x')
                {
                    result = 0;
                    count = 0;

                    while ((temp = xctoi(input.peek())) != -1)
                    {
                        input.pop();
                        result = (result * 16) + static_cast<std::size_t>(temp);
                        ++count;
                    }

                    if (strict && (count == 0))
                    {
                        return {};
                    }
                }
                else if (current == 'u' || current == 'U')
                {
                    result = 0;
                    count = 0;
                    output_utf8 = true;

                    std::size_t limit = (current == 'U') ? 8 : 4;

                    while ((temp = xctoi(input.peek())) != -1)
                    {
                        input.pop();
                        result = (result * 16) + static_cast<std::size_t>(temp);
                        ++count;

                        if (count == limit)
                        {
                            break;
                        }
                    }

                    if (strict && (count != limit))
                    {
                        return {};
                    }
                }
                else if ((temp = octoi(current)) != -1)
                {
                    result = static_cast<std::size_t>(temp);
                    count = 1;

                    while ((temp = octoi(input.peek())) != -1)
                    {
                        input.pop();
                        result = (result * 8) + static_cast<std::size_t>(temp);
                        ++count;

                        if (count == 3)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    if (strict)
                    {
                        return {};
                    }

                    result = static_cast<std::size_t>(current);
                }
            } // clang-format on
            else
            {
                result = static_cast<std::size_t>(current);
            }

            if (output_utf8)
            {
                if ((result > 0x10FFFF) || ((result >= 0xD800) && (result <= 0xDFFF)))
                {
                    if (strict)
                    {
                        return {};
                    }
                    else
                    {
                        result = 0xFFFD;
                    }
                }

                byte values[4];
                byte* values_end = values;

                if (result < 0x80)
                {
                    *values_end++ = static_cast<byte>(result);
                }
                else
                {
                    if (result < 0x800)
                    {
                        *values_end++ = static_cast<byte>((result >> 6) | 0xC0);
                    }
                    else
                    {
                        if (result < 0x10000)
                        {
                            *values_end++ = static_cast<byte>((result >> 12) | 0xE0);
                        }
                        else
                        {
                            *values_end++ = static_cast<byte>((result >> 18) | 0xF0);
                            *values_end++ = static_cast<byte>(((result >> 12) & 0x3F) | 0x80);
                        }

                        *values_end++ = static_cast<byte>(((result >> 6) & 0x3F) | 0x80);
                    }

                    *values_end++ = static_cast<byte>((result & 0x3F) | 0x80);
                }

                results.insert(results.end(), values, values_end);
            }
            else
            {
                if (result > UCHAR_MAX)
                {
                    if (strict)
                    {
                        return {};
                    }
                    else
                    {
                        result &= UCHAR_MAX;
                    }
                }

                results.push_back(static_cast<byte>(result));
            }
        }

        return results;
    }
} // namespace mem

#endif // MEM_UTILS_BRICK_H

```

`hack/deps/missing/bluelight1.vmt`:

```vmt
"Sprite"
{
	"$spriteorientation" "parallel_upright"
	"$spriteorigin" "[ 0.50 0.50 ]"
	"$basetexture" "sprites/bluelight1"
}

```

`hack/deps/missing/bluelightning.vmt`:

```vmt
Sprite
{
	$spriteorientation oriented
	$spriteorigin "[ 0.50 0.50 ]"
	$basetexture "sprites/bluelightning"
}
```

`hack/deps/missing/lgtning.vmt`:

```vmt
"Sprite"
{
	"$spriteorientation" "vp_parallel"
	"$spriteorigin" "[ 0.50 0.50 ]"
	"$basetexture" "sprites/lgtning"
}

```

`hack/deps/missing/physcannon_bluelight1.vmt`:

```vmt
"Sprite"
{
	"$spriteorientation" "vp_parallel"
	"$spriteorigin" "[ 0.50 0.50 ]"
	"$basetexture" "sprites/physcannon_bluelight1"
}

```

`hack/deps/missing/physcannon_bluelight1b.vmt`:

```vmt
"Sprite"
{
	"$spriteorientation" "vp_parallel"
	"$spriteorigin" "[ 0.50 0.50 ]"
	"$basetexture" "sprites/physcannon_bluelight1b"
}

```

`hack/deps/missing/snowflake.vmt`:

```vmt
"Sprite"
{
	"$basetexture" "particle/snowflake"
	"$spriterendermode" 5
	"$vertexcolor"  1
}
```

`hack/gamememory/address.cpp`:

```cpp
#include "address.hpp"

#include <SDK/interfaces/interfaces.hpp>
#include <SDK/IBaseClientDll.hpp>
#include <SDK/structs/Entity.hpp>
#include <SDK/IBaseClientDll.hpp>

memory::Address<uintptr_t> memory::findFromGame(ClassID id)
{
	for (auto _class = memory::interfaces::client->getAllClasses(); _class; _class = _class->m_next)
	{
		if (_class->m_classID == id)
			return Address<uintptr_t>{ reinterpret_cast<uintptr_t>(_class) };
	}

	return Address<uintptr_t>{ 0U };
}

#include <SDK/IVEngineClient.hpp>
#include <SDK/IClientEntityList.hpp>

memory::Address<uintptr_t> memory::findFromGameLoop(ClassID id)
{
	for (auto i = memory::interfaces::engine->getMaxClients(); i <= memory::interfaces::entList->getHighestIndex(); i++)
	{
		auto entity = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientEntity(i));
		if (!entity)
			continue;

		auto idx = entity->clientClass()->m_classID;
		if (idx == id)
			return Address<uintptr_t>{ reinterpret_cast<uintptr_t>(entity) };
	}

	return Address<uintptr_t>{ 0U };
}


std::optional<std::vector<memory::Address<uintptr_t>>> memory::findMultipleFromGameLoop(ClassID id)
{
	std::vector<memory::Address<uintptr_t>> possibleEnts;

	for (auto i = memory::interfaces::engine->getMaxClients(); i <= memory::interfaces::entList->getHighestIndex(); i++)
	{
		auto entity = reinterpret_cast<Entity_t*>(memory::interfaces::entList->getClientEntity(i));
		if (!entity)
			continue;

		auto idx = entity->clientClass()->m_classID;
		if (idx == id)
			possibleEnts.emplace_back(Address<uintptr_t>{ reinterpret_cast<uintptr_t>(entity) });
	}

	if (possibleEnts.empty())
		return std::nullopt;

	return possibleEnts;
}

```

`hack/gamememory/address.hpp`:

```hpp
#pragma once

#include "system/win.hpp"

#include <SDK/ClientClass.hpp>
#include <utilities/tools/wrappers.hpp>
#include <SDK/interfaces/ifc.hpp>

#include <utilities/console/console.hpp>

#include <array>
#include <optional>

namespace memory
{
	enum class Dereference : size_t
	{
		ONCE = 1,
		TWICE,
		THREE
	};

	class AddressBase
	{
	protected:
		uintptr_t m_addr{ };

	public:
		AddressBase() = default;
		constexpr AddressBase(uintptr_t addr)
			: m_addr{ addr }
		{}

		// raw place in memory as offset
		constexpr auto getAddr() const { return m_addr; }
	};

	template<typename T>
	class Address : public AddressBase
	{
	public:
		constexpr Address() = default;
		// pass by offset
		constexpr Address(uintptr_t addr) :
			AddressBase{ addr }
		{}
		// pass by pointer
		constexpr Address(void* addr) :
			AddressBase{ reinterpret_cast<uintptr_t>(addr) }
		{}
		// pass by another addr
		template<typename U>
		constexpr Address(const Address<U>& other)
			: AddressBase{ other.getAddr() }
		{}

		// cast to anything
		template<typename U>
		constexpr auto cast() const { return Address<U>{ m_addr }; }
		constexpr auto add(uintptr_t extraOffset) const { return Address{ m_addr + extraOffset }; }
		constexpr auto sub(uintptr_t extraOffset) const { return Address{ m_addr - extraOffset }; }
		// dereference x times. Possible args are: 1, 2, 3.
		// There will for sure won't be a case for 4 level dereference. 3rd is very rare.
		constexpr auto deRef(Dereference times = Dereference::ONCE) const
		{
			auto addr = m_addr;
			for (size_t i = 0U; i < E2T(times); ++i)
				addr = *reinterpret_cast<uintptr_t*>(addr);

			return Address<T>{ addr };
		}
		// get as rel32
		constexpr auto rel(uintptr_t relOffset = 0x1, uintptr_t absOffset = 0x0) const
		{
			const auto jump = m_addr + relOffset;
			const auto target = *reinterpret_cast<decltype(jump)*>(jump);
			return Address<T>{ jump + absOffset + 0x4 + target };
		}
		// will work for classes types too
		constexpr T operator()() const
		{
			if constexpr (std::is_class_v<T>)
				return *reinterpret_cast<T*>(m_addr);
			else
				return (T)(m_addr);
		}

		constexpr T operator->() const
		{
			if constexpr (std::is_class_v<T>)
				return *reinterpret_cast<T*>(m_addr);
			else
				return (T)(m_addr);
		}
	};

	Address<uintptr_t> scan(const std::string_view mod, const std::string_view pattern);
	template<li::detail::offset_hash_pair hash>
	Address<uintptr_t> byExport(const std::string_view module);
	// non template version, used to wrap nt stuff
	Address<uintptr_t> byExport(const std::string_view module, const std::string_view exportName);
	template<typename U>
	Address<uintptr_t> byVFunc(const Interface<U>& ifc, size_t index);
	// static pointer
	Address<uintptr_t> findFromGame(ClassID id);
	// anything that changes every round
	Address<uintptr_t> findFromGameLoop(ClassID id);
	// for more objects with same id
	std::optional<std::vector<Address<uintptr_t>>> findMultipleFromGameLoop(ClassID id);
}

#include <deps/mem/pattern.h>

inline memory::Address<uintptr_t> memory::scan(const std::string_view mod, const std::string_view pattern)
{
	const auto _module = memory::modules::getModule(mod);
	const auto dosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(_module);
	const auto ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<uint8_t*>(_module) + dosHeader->e_lfanew);
	const auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;

	mem::pattern pat{ pattern.data() };
	mem::simd_scanner scanner{ pat };
	const mem::pointer scanned = scanner.scan(mem::region{ _module, sizeOfImage });
	const auto result = scanned.as<uintptr_t>();
	
	if(!scanned)
		HACK_THROW(std::format("Couldn't find signature, module {}, signature: {}", mod, pattern));

	return Address<uintptr_t>{ result };
}

template<li::detail::offset_hash_pair hash>
memory::Address<uintptr_t> memory::byExport(const std::string_view _module)
{
	const auto addr = static_cast<uintptr_t>(::li::detail::lazy_function<hash, uintptr_t>().in(modules::getModule(_module)));

	return Address<uintptr_t>{ addr };
}

inline memory::Address<uintptr_t> memory::byExport(const std::string_view _module, const std::string_view exportName)
{
	// windows::getModuleHandle caches modules, although we better don't use modules:: namespace here
	const auto addr = reinterpret_cast<uintptr_t>(windows::getExportAddress(windows::getModuleHandle(_module), exportName));

	return Address<uintptr_t>{ addr };
}

#include <SDK/helpers/vfunc.hpp>

template<typename TT>
memory::Address<uintptr_t> memory::byVFunc(const Interface<TT>& ifc, size_t index)
{
	const auto addr = reinterpret_cast<uintptr_t>(vfunc::getVFunc(reinterpret_cast<void*>(ifc.base), index));

	return Address<uintptr_t>{ addr };
}
```

`hack/gamememory/memory.cpp`:

```cpp
#include "memory.hpp"

#include "sigs.hpp"
#include "modules.hpp"

#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/console/console.hpp>
#include <SDK/math/matrix.hpp>
#include <SDK/CTeslaInfo.hpp>
#include <SDK/CEffectData.hpp>
#include <SDK/IPrediction.hpp>
#include <SDK/CGameRules.hpp>
#include <SDK/Input.hpp>
#include <SDK/IViewRenderBeams.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <cheats/game/game.hpp>
#include <SDK/IViewRenderBeams.hpp>

void memory::init()
{
	memory::modules::addModule<"engine.dll">();
	memory::modules::addModule<"client.dll">();
	memory::modules::addModule<"vstdlib.dll">();
	memory::modules::addModule<"vgui2.dll">();
	memory::modules::addModule<"vguimatsurface.dll">();
	memory::modules::addModule<"materialsystem.dll">();
	memory::modules::addModule<"localize.dll">();
	memory::modules::addModule<"studiorender.dll">();
	memory::modules::addModule<"inputsystem.dll">();
	memory::modules::addModule<"shaderapidx9.dll">();
	memory::modules::addModule<"tier0.dll">();
	memory::modules::addModule<"panorama.dll">();
	memory::modules::addModule<"filesystem_stdio.dll">();
	memory::modules::addModule<"datacache.dll">();
	memory::modules::addModule<"gameoverlayrenderer.dll">();
	memory::modules::addModule<"vphysics.dll">();

	memory::interfaces::init();

	using namespace memory;
	using namespace memory::interfaces;

	traceFilterSimple = scan(CLIENT_DLL, CTRACE_FILTER_SIMPLE).add(0x3D);
	returnAddrRadarImage = scan(PANORAMA_DLL, UNK_FILESYS);
	viewMatrixAddr = scan(CLIENT_DLL, VIEW_MATRIX_CLIENT).add(0x3).deRef().add(0xB0);
	drawScreenEffectMaterial = scan(CLIENT_DLL, DRAW_EFFECT_MATRIAL);
	motionBlurVec = scan(CLIENT_DLL, BLUR_MATERIAL_ARR_1).add(0x1).deRef();
	throughSmoke = scan(CLIENT_DLL, GOES_THROUGH_SMOKE);
	smokeCount = throughSmoke.add(0x8).deRef().cast<uintptr_t>();
	loadSky = scan(ENGINE_DLL, LOAD_SKY);
	callbacksHead = scan(CLIENT_DLL, HEAD_OF_EFFECTS).add(0x2).deRef(Dereference::TWICE);
	camThink = scan(CLIENT_DLL, CAM_THINK);
	renderDrawPoints = scan(STUDIORENDER_DLL, R_STUDIODRAWPOINTS);
	localPlayer = scan(CLIENT_DLL, LOCAL_PLAYER).add(0x2).deRef(); game::localPlayer.init();
	csgoHud = scan(CLIENT_DLL, CSGO_HUD).add(0x1).deRef();
	hudfindElement = scan(CLIENT_DLL, FIND_ELEMENT);
	keyValuesFromString = scan(CLIENT_DLL, KEY_VALUES_FROM_STR);
	animOverlays = scan(CLIENT_DLL, ANIMATION_LAYER).add(0x2).deRef();
	sequenceActivity = scan(CLIENT_DLL, SEQUENCE_ACTIVITY);
	cachedBones = scan(CLIENT_DLL, CACHED_BONE).add(0x2).deRef().add(0x4);
	setAbsOrigin = scan(CLIENT_DLL, SETABSORIGIN);
	setAbsAngle = scan(CLIENT_DLL, SETABSANGLES);
	isC4Owner = scan(CLIENT_DLL, HASC4);
	isBreakable = scan(CLIENT_DLL, IS_BREAKBLE);
	predictionData = scan(CLIENT_DLL, PREDICTION_MOVE_DATA).add(0x1).deRef(Dereference::TWICE);
	predictionSeed = scan(CLIENT_DLL, PREDICTIONRANDOMSEED).add(0x2).deRef();
	flashlightCreate = scan(CLIENT_DLL, FLASHLIGHT_CREATE);
	flashlightUpdate = scan(CLIENT_DLL, FLASHLIGHT_UPDATE);
	flashlightDestroy = scan(CLIENT_DLL, FLASHLIGHT_DESTROY);
	occlusion = scan(CLIENT_DLL, SETUP_OCCLUSION);
	velocity = scan(CLIENT_DLL, SETUP_VELOCITY);
	accumulate = scan(CLIENT_DLL, ACCUMULATE_LAYERS);
	particleIsCached = scan(CLIENT_DLL, IS_EFFECT_CACHED);
	particleSystem = scan(CLIENT_DLL, PARTICLE_SYSTEM).add(0x7).deRef(Dereference::TWICE);
	particleFindStringIndex = scan(CLIENT_DLL, FIND_STRING_INDEX);
	particleCall = scan(CLIENT_DLL, PARTICLE_CALL);
	particleSetControlPoint = scan(CLIENT_DLL, SET_PARTICLE_POINT);
	predictedPlayer = scan(CLIENT_DLL, PREDICTED_PLAYER).add(0x2).deRef();
	physicsRunThink = scan(CLIENT_DLL, PHYSICS_RUN_THINK);
	lastCommand = scan(CLIENT_DLL, LAST_COMMAND).add(0x2).deRef();
	retAddrToInterpolation = scan(CLIENT_DLL, RET_ADDR_INTERPOLATION);
	postThinkPhysics = scan(CLIENT_DLL, POST_THINK_PHYSICS);
	simulateEntities = scan(CLIENT_DLL, SIMULATE_ENTITIES);
	vecClientImpacts = scan(CLIENT_DLL, VEC_CLIENT_IPACT_LIST).add(0x2).deRef();
	loadFromBuffer = scan(CLIENT_DLL, LOAD_FROM_BUFFER);
	keyValuesConstruct = scan(CLIENT_DLL, KEYVALUES_CONSTRUCT);
	keyValuesDestruct = scan(CLIENT_DLL, KEYVALUES_DESTRUCT);
	checkThinkFunction = scan(CLIENT_DLL, CHECK_HAS_THINK_FN);
	usingStandardWeaponsVehicle = scan(CLIENT_DLL, USING_STANDARD_WEAPONS_VEH);
	selectItem = scan(CLIENT_DLL, SELECT_ITEM);
	transferData = scan(CLIENT_DLL, TRANSFER_DATA);
	reinitPredicatbles = scan(CLIENT_DLL, REINIT_PREDICTABLES);
	shutdownPredicatbles = scan(CLIENT_DLL, SHUTDOWN_PREDICTABLES);
	destroyMaterial = scan(MATERIAL_DLL, MATERIAL_DESTRUCT);
	allocKeyValuesClient = scan(CLIENT_DLL, RET_ADDR_KEYVALUES_CLIENT).add(0x3E);
	allocKeyValuesEngine = scan(ENGINE_DLL, RET_ADDR_KEYVALUES_ENGINE).add(0x4A);
	flashbangRet = scan(CLIENT_DLL, FLASH_EFFECT_RET).add(0x3);
	flashbangWhiteRet = scan(CLIENT_DLL, FLASH_EFFECT_WHITE_RET).add(0xA);
	precipitationClientThink = scan(CLIENT_DLL, CLIENT_THINK_PRECIPITATION);
	precipitationInit = scan(CLIENT_DLL, PRECIPITATION_INIT);
	takeDmg = scan(CLIENT_DLL, TAKE_DMG).add(0x2).deRef();
	setAbsVelocity = scan(CLIENT_DLL, SET_ABS_VELOCITY);
	firstMoveChild = scan(CLIENT_DLL, FIRST_MOVE_CHILD).add(0x2).deRef();
	nextMovePeer = scan(CLIENT_DLL, NEXT_PEER).add(0x2).deRef();
	getParticleSystemIndex = scan(CLIENT_DLL, GET_PARTICLE_SYSTEM_IDX);
	dispatchParticleEffect = scan(CLIENT_DLL, DISPATCH_PARTICLE_EFFECT);
	renderBoxInternal = scan(CLIENT_DLL, RENDER_BOX);
	renderLine = scan(CLIENT_DLL, RENDER_LINE);
	vignetteBlurStrengthPost = scan(CLIENT_DLL, BLURSCOPE_VIGNETTEPOST).add(0x3).deRef().add(0x4);
	scopeDust = scan(CLIENT_DLL, SCOPE_DUST_RET).add(0x3);
	scopeArc = scan(CLIENT_DLL, SCOPE_ARC_RET);
	addGlowBox = scan(CLIENT_DLL, ADD_GLOW_BOX);
	setString = scan(ENGINE_DLL, KEY_VALUES_SET_STRING);
	findKey = scan(ENGINE_DLL, KEY_VALUES_FIND_KEY);
	decalPool = scan(ENGINE_DLL, S_ADECALPOOL).add(0x1).deRef();
	valveHook = scan(GAME_OVERLAY, VALVE_HOOK);
	valveUnHook = scan(GAME_OVERLAY, VALVE_UNHOOK);
	viewFadeSmokeRet = scan(CLIENT_DLL, VIEW_FACE_SMOKE_RET).add(0xC);
	gPrecipitations = scan(CLIENT_DLL, G_PRECIPICATION).add(0x1).deRef();
	precipDestruct = scan(CLIENT_DLL, DESTRUCT_PRECIPICATION);
	stopSound = scan(CLIENT_DLL, STOP_SOUND);
	particleGetVCollideRet = scan(CLIENT_DLL, WEATHER_GETVCOLLIDE_RET).add(0x2D);
	vPhysicsGetObject = scan(CLIENT_DLL, VPHYSICS_GET_OBJ).add(0x2).deRef();
	restoreMaterialSystemObjects = scan(ENGINE_DLL, RESTOTRE_MATERIALS);
	forceSingleThreaded = scan(MATERIAL_DLL, FORCE_SINGLE_THREADED);
	precacheVars = scan(MATERIAL_DLL, PRECACHE_VARS);
	levelName = scan(ENGINE_DLL, LEVEL_NAME).add(0x2).deRef();

	// HOOKS

	isUsingPropDebug = scan(ENGINE_DLL, IS_USING_PROP_DEBUG).rel(0x1);
	getColorModulation = scan(MATERIAL_DLL, GET_COLOR_MODULATION);
	extraBonesProcessing = scan(CLIENT_DLL, EXTRA_BONES_PROCCESSING);
	buildTransformations = scan(CLIENT_DLL, BUILD_TRANSFORMATIONS);
	particleSimulate = scan(CLIENT_DLL, PARTICLE_SIMULATE);
	sendDataGram = scan(ENGINE_DLL, SEND_DATAGRAM);
	unkOverviewMap = scan(CLIENT_DLL, UNK_OVERVIEWMAP);
	isDepth = scan(CLIENT_DLL, IS_DEPTH);
	fxBlood = scan(CLIENT_DLL, FX_BLOOD);
	fxBloodSpray = scan(CLIENT_DLL, FX_BLOOD_SPRAY);
	bloodCallback = scan(CLIENT_DLL, BLOOD_CALLBACK);
	addEnt = scan(CLIENT_DLL, ADD_ENT);
	removeEnt = scan(CLIENT_DLL, REMOVE_ENT);
	isFollowedEntity = scan(CLIENT_DLL, IS_FOLLOWED_ENT);
	spottedEntityUpdate = scan(CLIENT_DLL, SPOTTED_ENTITIY_UPDATE);
	fireInternfn = scan(ENGINE_DLL, FIRE_INTERN);
	preRound = scan(CLIENT_DLL, GAME_INSTRUCTOR_EVENT);
	playSoundStep = scan(CLIENT_DLL, PLAY_STEP_SOUND);
	restoreData = scan(CLIENT_DLL, RESTORE_DATA);
	saveData = scan(CLIENT_DLL, SAVE_DATA);
	bloodUtilCallback = scan(CLIENT_DLL, BLOOD_UTIL_CALLBACK);
	chudIsHidden = scan(CLIENT_DLL, CHUD_IS_HIDDEN);
	viewFade = scan(ENGINE_DLL, VIEW_FADE);
	unkRound = scan(CLIENT_DLL, UNK_SURVIVAL_RELATED);
	present = scan(GAME_OVERLAY, DX9_PRESENT).add(0x2);
	reset = scan(GAME_OVERLAY, DX9_RESET).add(0x9);
	updatePostEffects = scan(CLIENT_DLL, UPDATEPOST_EFFECTS);
	getPMaterial = scan(CLIENT_DLL, GET_PMATERIAL);
	decalAddToSurface = scan(ENGINE_DLL, R_DECAL_ADD_TO_SURFACE);
	createDecal = scan(ENGINE_DLL, R_DECAL_CREATE);
	createParticlePrecip = scan(CLIENT_DLL, CREATE_PARTICLE_PRECIP);
	initializeParticlePrecip = scan(CLIENT_DLL, INITIALIZE_PRECIP_PARTICLE);
	viewDrawScene = scan(CLIENT_DLL, VIEW_DRAW_SCENE);
	drawEffects = scan(CLIENT_DLL, DRAW_EFFECTS);
	drawWorldAndEntities = scan(CLIENT_DLL, DRAW_WORLD_AND_ENTITIES);
	drawTransculentRenderables = scan(CLIENT_DLL, DRAW_TRANSCULENT_RENDERABLE);
	clientCsNormalEvent = scan(CLIENT_DLL, CLIENTMODE_CSNORMAL_EVENT);
	tracerDraw = scan(CLIENT_DLL, TRACER_DRAW);
	dispatchInnerParticlePrecip = scan(CLIENT_DLL, DISPATCH_INNER_PRECIP);
	newParticleCreate = scan(CLIENT_DLL, NEW_PARTICLE_EFFECT_CREATE);
	newParticleSetControlPoint = scan(CLIENT_DLL, NEW_PARTICLE_SET_POINT);
	newParticleSetControlPointEnt = scan(CLIENT_DLL, NEW_PARTICLE_SET_POINT_ENT);
	getVelocity = scan(CLIENT_DLL, GET_VELOCITY).add(0x2);

	// REST

	tesla = scan(CLIENT_DLL, FX_TESLA);
	dispatchEffect = scan(CLIENT_DLL, DISPATCH_EFFECT);

	// SDK INTERFACES

	glowManager = scan(CLIENT_DLL, GLOWMANAGER).add(0x3).deRef();
	weaponInterface = scan(CLIENT_DLL, WEAPONDATA).add(0x2).deRef();
	moveHelper = scan(CLIENT_DLL, MOVEHELPER).add(0x2).deRef(Dereference::TWICE);
	dx9Device = scan(SHARED_API, DX9_DEVICE).add(0x1).deRef(Dereference::TWICE);
	clientState = scan(ENGINE_DLL, CLIENT_STATE).add(0x1).deRef(Dereference::TWICE);
	viewRender = scan(CLIENT_DLL, VIEW_RENDER).add(0x2).deRef(Dereference::TWICE);

	keyValuesSys = byExport<"KeyValuesSystem"_hasher>(VSTD_DLL).cast<keyValuesSystem_t>()()();
	memAlloc = byExport<"g_pMemAlloc"_hasher>(TIER_DLL).deRef();

	moveHelper = scan(CLIENT_DLL, MOVEHELPER).add(0x2).deRef(Dereference::TWICE);
	beams = scan(CLIENT_DLL, BEAMS).add(0x1).deRef();

	globalVars = byVFunc(memory::interfaces::client, 0).add(0x1F).deRef(Dereference::TWICE);
	clientMode = byVFunc(memory::interfaces::client, 10).add(0x5).deRef(Dereference::TWICE);
	input = byVFunc(memory::interfaces::client, 16).add(0x1).deRef();

	postInit();
	netvars::init();

	console::debug("memory init success");
}


void memory::postInit()
{
	using namespace memory::interfaces;

	preciptation = findFromGame(CPrecipitation);
	resourceInterface = findFromGameLoop(CCSPlayerResource);
	gameRules = findFromGameLoop(CCSGameRulesProxy);
	toneController = findFromGameLoop(CEnvTonemapController);
	fogController = findFromGameLoop(CFogController);
	ambientLight = findFromGameLoop(CEnvAmbientLight);
	dynamicLight = findFromGame(CDynamicLight);

	hostState = scan(ENGINE_DLL, HOST_STATE).add(0x1).deRef(Dereference::TWICE);
	gameWorld = scan(CLIENT_DLL, CLIENT_WORLD).add(0x1).deRef(Dereference::TWICE);

	console::debug("memory post init success");
}
```

`hack/gamememory/memory.hpp`:

```hpp
#pragma once

#include "address.hpp"

#include <SDK/math/Vector.hpp>
#include <SDK/math/matrix.hpp>
#include <SDK/interfaces/ifc.hpp>
#include <SDK/CPlayerResource.hpp>
#include <SDK/CUtlVector.hpp>
#include <utilities/tools/tools.hpp>

#include <cstdint>
#include <string>
#include <unordered_map>
#include <Windows.h>
#include <variant>
#include <type_traits>

struct CClientEffectRegistration;
class Player_t;
class AnimationLayer;
class CMoveData;
class ClientMode;
class IViewRenderBeams;
class CGlowManager;
class IWeapon;
class IMoveHelper;
class PlayerResource;
struct IDirect3DDevice9;
class IClientState;
class CGameRules;
class IViewRender;
class CTeslaInfo;
class CEffectData;
class KeyValuesSys;
class IMemAlloc;
class CGlobalVarsBase;
class Input;
class CFlashlightEffect;
class ClientClass;
class IMaterial;
class EnvTonemapController_t;
class FogController_t;
class EnvAmbientLight_t;
struct SDKColor;
struct SDKColorInt;
enum ClassID;
class KeyValues;
class CCommonHostState;
struct decal_t;
class World_t;
class Entity_t;
class CascadeLight_t;
class Precipitation_t;
enum ParticleAttachment_t;
class CNewParticleEffect;

using retaddr_t = uintptr_t;

namespace memory
{
	HACK_INIT void init();
	void postInit();
};

namespace memory
{
	using loadSky_t = void(HACK_FASTCALL*)(const char*);
	using findHud_t = uintptr_t * (HACK_THISCALL*)(void* /*uintptr_t*/, const char*);
	using sequenceActivity_t = int(HACK_FASTCALL*)(void*, void*, int);
	using inSmoke_t = bool(HACK_CDECL*)(Vec3, Vec3);
	using isBreakable_t = bool(HACK_THISCALL*)(void*);
	using flashlightDestroy_t = void(HACK_THISCALL*)(void*, void*);
	using flashlightCreate_t = void* (HACK_THISCALL*)(void*, void*, float, float, float, float, int, const char*, float, float);
	using flashlightUpdate_t = void(HACK_THISCALL*)(void*, int, const Vec3&, const Vec3&, const Vec3&, const Vec3&, float, float, float, bool, const char*);
	using setAbsOrigin_t = void(HACK_THISCALL*)(void*, const Vec3&);
	using setAbsAngle_t = void(HACK_THISCALL*)(void*, const Vec3&);
	using isC4Owner_t = bool(HACK_THISCALL*)(void*);
	using teslaCreate_t = void(HACK_THISCALL*)(CTeslaInfo&);
	using dispatchEffect_t = int(HACK_FASTCALL*)(const char*, const CEffectData&);
	using particleCached_t = bool(HACK_THISCALL*)(void*, const char*);
	using particleFindString_t = void(HACK_THISCALL*)(void*, int*, const char*);
	using setParticleControlPoint_t = void(HACK_THISCALL*)(void*, int, Vec3*);
	using physicsRunThink_t = bool(HACK_THISCALL*)(void*, int);
	using postThinkPhysics_t = bool(HACK_THISCALL*)(Player_t*);
	using simulateEntities_t = void(HACK_THISCALL*)(Player_t*);
	using loadFromBuffer_t = void(HACK_THISCALL*)(void*, const char*, const char*, void*, const char*, void*, int);
	using keyValuesConstruct_t = void(HACK_THISCALL*)(void*, const char*, const char*, int); // or 3rd (2nd without thisptr) arg is int, not sure
	using keyValuesDestruct_t = void(HACK_THISCALL*)(void*, int);
	using keyValuesSystem_t = KeyValuesSys * (HACK_CDECL*)();
	using checkThinkFunction_t = void(HACK_THISCALL*)(void*, bool);
	using usingStandardWeaponsInVehicle_t = bool(HACK_THISCALL*)(void*);
	using selectItem_t = void(HACK_THISCALL*)(void*, const char*, int);
	using transferData_t = int(HACK_THISCALL*)(void*, const char*, int, void*);
	using reinitPredictables_t = int(HACK_STDCALL*)();
	using shutdownPredictables_t = void(HACK_STDCALL*)();
	using destroyMaterial_t = void(HACK_THISCALL*)(void*);
	using restoreData_t = void(HACK_THISCALL*)(Player_t*, const char*, int, int);
	using saveData_t = void(HACK_THISCALL*)(Player_t*, const char*, int, int);
	using precipClientThink_t = void(HACK_THISCALL*)(void*);
	using precipInit_t = int(HACK_THISCALL*)(void*);
	using setAbsVelocity_t = void(HACK_THISCALL*)(void*, const Vec3&);
	using getParticleSystemIndex_t = int(HACK_STDCALL*)(const char*);
	using dispatchParticleEffect_t = void(HACK_STDCALL*)(const char*, const Vec3&, const Vec3&, ParticleAttachment_t, void*, int);
	using renderBoxInternal_t = void(HACK_STDCALL*)(const Vec3&, const Vec3&, const Vec3&, const Vec3&, SDKColor, IMaterial*, bool);
	using renderLine_t = void(HACK_STDCALL*)(const Vec3&, const Vec3&, SDKColor, bool);
	using addGlowBox_t = int(HACK_THISCALL*)(void*, Vec3, Vec3, Vec3, Vec3, SDKColor, float);
	using drawModel_t = int(HACK_THISCALL*)(void*, int, uint8_t);
	using setString_t = void(HACK_THISCALL*)(void*, const char*, const char*);
	using findKey_t = KeyValues*(HACK_THISCALL*)(void*, const char*, bool);
	using valveHook_t = char(HACK_CDECL*)(void*, void*, void*, int);
	using valveUnHook_t = char(HACK_CDECL*)(uintptr_t, char);
	using precipDestruct_t = void(HACK_THISCALL*)(void*);
	using stopSound_t = void(HACK_THISCALL*)(void*, const char*);
	using newParticleCreate_t = CNewParticleEffect*(HACK_STDCALL*)(const char*, ParticleAttachment_t, int, Vec3, Matrix3x4*);
	using newParticleSetControlPoint_t = void(HACK_THISCALL*)(void*, int, const Vec3&);
	using newParticleSetControlPointEnt_t = void(HACK_THISCALL*)(void*, int, void*);
	using restoreMaterialSystemObjects_t = void(HACK_CDECL*)(int);
	using restoreMaterialSystemObjectsMdl_t = void(HACK_THISCALL*)(void*, int);
	using releaseMaterialSystemObjects_t = void(HACK_CDECL*)();
	using forceSingleThreaded_t = void(HACK_THISCALL*)(void*);
	using restoreShaderObjects_t = void(HACK_THISCALL*)(void*, int, void*, int);
	using releaseShaderObjects_t = void(HACK_THISCALL*)(void*, int);
	using precacheVars_t = bool(HACK_THISCALL*)(void*, void*, void*, void*);

	inline Address<uintptr_t> traceFilterSimple;
	inline Address<uintptr_t*> returnAddrRadarImage;
	inline Address<Matrix4x4> viewMatrixAddr;
	inline Address<uintptr_t> drawScreenEffectMaterial;
	inline Address<float*> motionBlurVec;
	inline Address<inSmoke_t> throughSmoke;
	inline Address<uintptr_t> smokeCount;
	inline Address<loadSky_t> loadSky;
	inline Address<CClientEffectRegistration*> callbacksHead;
	inline Address<retaddr_t> camThink;
	inline Address<void*> renderDrawPoints;
	inline Address<Player_t**> localPlayer;
	inline Address<void*> csgoHud;
	inline Address<findHud_t> hudfindElement;
	inline Address<uintptr_t> keyValuesFromString;
	inline Address<uintptr_t> animOverlays;
	inline Address<sequenceActivity_t> sequenceActivity;
	inline Address<uintptr_t> cachedBones;
	inline Address<setAbsOrigin_t> setAbsOrigin;
	inline Address<setAbsAngle_t> setAbsAngle;
	inline Address<isC4Owner_t> isC4Owner;
	inline Address<isBreakable_t> isBreakable;
	inline Address<CMoveData*> predictionData;
	inline Address<uintptr_t*> predictionSeed;
	inline Address<flashlightCreate_t> flashlightCreate;
	inline Address<flashlightUpdate_t> flashlightUpdate;
	inline Address<flashlightDestroy_t> flashlightDestroy;
	inline Address<uintptr_t> occlusion;
	inline Address<uintptr_t> velocity;
	inline Address<uintptr_t> accumulate;
	inline Address<particleCached_t> particleIsCached;
	inline Address<void**> particleSystem;
	inline Address<particleFindString_t> particleFindStringIndex;
	inline Address<void*> particleCall;
	inline Address<setParticleControlPoint_t> particleSetControlPoint;
	inline Address<Player_t**> predictedPlayer;
	inline Address<physicsRunThink_t> physicsRunThink;
	inline Address<uintptr_t> lastCommand;
	inline Address<uintptr_t> retAddrToInterpolation;
	inline Address<postThinkPhysics_t> postThinkPhysics;
	inline Address<simulateEntities_t> simulateEntities;
	inline Address<uintptr_t> vecClientImpacts;
	inline Address<loadFromBuffer_t> loadFromBuffer;
	inline Address<keyValuesConstruct_t> keyValuesConstruct;
	inline Address<keyValuesDestruct_t> keyValuesDestruct;
	inline Address<checkThinkFunction_t> checkThinkFunction;
	inline Address<usingStandardWeaponsInVehicle_t> usingStandardWeaponsVehicle;
	inline Address<selectItem_t> selectItem;
	inline Address<transferData_t> transferData;
	inline Address<reinitPredictables_t> reinitPredicatbles;
	inline Address<shutdownPredictables_t> shutdownPredicatbles;
	inline Address<destroyMaterial_t> destroyMaterial;
	inline Address<restoreData_t> restoreData;
	inline Address<saveData_t> saveData;
	inline Address<retaddr_t> allocKeyValuesClient;
	inline Address<retaddr_t> allocKeyValuesEngine;
	inline Address<retaddr_t> flashbangRet;
	inline Address<retaddr_t> flashbangWhiteRet;
	inline Address<precipClientThink_t> precipitationClientThink;
	inline Address<precipInit_t> precipitationInit;
	inline Address<uintptr_t> takeDmg;
	inline Address<setAbsVelocity_t> setAbsVelocity;
	inline Address<uintptr_t> firstMoveChild;
	inline Address<uintptr_t> nextMovePeer;
	inline Address<getParticleSystemIndex_t> getParticleSystemIndex;
	inline Address<dispatchParticleEffect_t> dispatchParticleEffect;
	inline Address<renderBoxInternal_t> renderBoxInternal;
	inline Address<renderLine_t> renderLine;
	inline Address<float*> vignetteBlurStrengthPost;
	inline Address<retaddr_t> scopeDust;
	inline Address<retaddr_t> scopeArc;
	inline Address<addGlowBox_t> addGlowBox;
	inline Address<drawModel_t> baseAnimatingDrawModel;
	inline Address<retaddr_t> renderViewRet;
	inline Address<setString_t> setString;
	inline Address<findKey_t> findKey;
	inline Address<CUtlVector<decal_t*>> decalPool;
	inline Address<valveHook_t> valveHook;
	inline Address<valveUnHook_t> valveUnHook;
	inline Address<retaddr_t> viewFadeSmokeRet;
	inline Address<CUtlVector<Precipitation_t*>> gPrecipitations;
	inline Address<precipDestruct_t> precipDestruct;
	inline Address<stopSound_t> stopSound;
	inline Address<retaddr_t> particleGetVCollideRet;
	inline Address<newParticleCreate_t> newParticleCreate;
	inline Address<newParticleSetControlPoint_t> newParticleSetControlPoint;
	inline Address<newParticleSetControlPointEnt_t> newParticleSetControlPointEnt;
	inline Address<retaddr_t> setControlPointParticleWeatherRet;
	inline Address<uintptr_t> vPhysicsGetObject;
	inline Address<restoreMaterialSystemObjects_t> restoreMaterialSystemObjects;
	inline Address<forceSingleThreaded_t> forceSingleThreaded;
	inline Address<precacheVars_t> precacheVars;
	inline Address<char*> levelName; // sizeof here [actual address in first opcode] E8 ? ? ? ? 83 C4 08 83 3E 0A

	inline Address<void*> isUsingPropDebug;
	inline Address<void*> getColorModulation;
	inline Address<void*> extraBonesProcessing;
	inline Address<void*> buildTransformations;
	inline Address<void*> particleSimulate;
	inline Address<void*> sendDataGram;
	inline Address<void*> unkOverviewMap;
	inline Address<void*> isDepth;
	inline Address<void*> fxBlood;
	inline Address<void*> fxBloodSpray;
	inline Address<void*> bloodCallback;
	inline Address<void*> addEnt;
	inline Address<void*> removeEnt;
	inline Address<void*> isFollowedEntity;
	inline Address<void*> spottedEntityUpdate;
	inline Address<void*> fireInternfn;
	inline Address<void*> preRound;
	inline Address<void*> playSoundStep;
	inline Address<void*> bloodUtilCallback;
	inline Address<void*> chudIsHidden;
	inline Address<void*> viewFade;
	inline Address<void*> unkRound;
	inline Address<void*> present;
	inline Address<void*> reset;
	inline Address<void*> updatePostEffects;
	inline Address<void*> getPMaterial;
	inline Address<void*> decalAddToSurface;
	inline Address<void*> createDecal;
	inline Address<void*> drawSmokeFogOverlay;
	inline Address<void*> createParticlePrecip;
	inline Address<void*> initializeParticlePrecip;
	inline Address<void*> viewDrawScene;
	inline Address<void*> drawEffects;
	inline Address<void*> drawWorldAndEntities;
	inline Address<void*> drawTransculentRenderables;
	inline Address<void*> clientCsNormalEvent;
	inline Address<void*> tracerDraw;
	inline Address<void*> dispatchInnerParticlePrecip;
	inline Address<void*> getVelocity;

	inline Address<teslaCreate_t> tesla;
	inline Address<dispatchEffect_t> dispatchEffect;

	namespace interfaces
	{
		inline Address<CGlowManager*> glowManager;
		inline Address<IWeapon*> weaponInterface;
		inline Address<PlayerResource*> resourceInterface;
		inline Address<IDirect3DDevice9*> dx9Device;
		inline Address<IClientState*> clientState;
		inline Address<IViewRender*> viewRender;
		inline Address<IMoveHelper*> moveHelper;
		inline Address<IViewRenderBeams*> beams;
		inline Address<KeyValuesSys*> keyValuesSys;
		inline Address<IMemAlloc*> memAlloc;
		inline Address<CGameRules*> gameRules;
		inline Address<CGlobalVarsBase*> globalVars;
		inline Address<ClientMode*> clientMode;
		inline Address<Input*> input;
		inline Address<ClientClass*> preciptation;
		inline Address<EnvTonemapController_t*> toneController;
		inline Address<FogController_t*> fogController;
		inline Address<EnvAmbientLight_t*> ambientLight;
		inline Address<CCommonHostState*> hostState;
		inline Address<World_t*> gameWorld;
		inline Address<ClientClass*> dynamicLight;
	}
}
```

`hack/gamememory/modules.hpp`:

```hpp
#pragma once

#include <Windows.h>

#include <utilities/cStr.hpp>
#include <utilities/tools/wrappers.hpp>

#include <unordered_map>
#include <string>

#include <lazy_importer.hpp>

namespace memory
{
	namespace modules
	{
		inline std::unordered_map<std::string_view, HMODULE> allmodules;

		template<cStr str>
		inline void addModule()
		{
			allmodules[std::string_view{ str.c_str() }] = reinterpret_cast<HMODULE>(::li::detail::lazy_module<hasher(str.c_str())>().cached());
		}
		inline HMODULE getModule(const std::string_view str)
		{
			return allmodules.at(str);
		}
	}
}

#define ENGINE_DLL					"engine.dll"
#define CLIENT_DLL					"client.dll"
#define VSTD_DLL					"vstdlib.dll"
#define VGUI_DLL					"vgui2.dll"
#define VGUIMAT_DLL					"vguimatsurface.dll"
#define MATERIAL_DLL				"materialsystem.dll"
#define LOCALIZE_DLL				"localize.dll"
#define STUDIORENDER_DLL			"studiorender.dll"
#define INPUTSYSTEM_DLL				"inputsystem.dll"
#define SHARED_API					"shaderapidx9.dll"
#define TIER_DLL					"tier0.dll"
#define PANORAMA_DLL				"panorama.dll"
#define FILESYS_DLL					"filesystem_stdio.dll"
#define DATACACHE_DLL				"datacache.dll"
#define GAME_OVERLAY				"gameoverlayrenderer.dll"
#define VPHYSICS_DLL				"vphysics.dll"
```

`hack/gamememory/sigs.hpp`:

```hpp
#pragma once

// I found by strictly setting glow color in console and finding what exactly changed in reclass
// or go EntityGlowEffects, list up xrefs. https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/glow_outline_effect.cpp#L34
#define GLOWMANAGER                     "0F 11 05 ? ? ? ? 83 C8 01"
// const CViewRenderBeams::`vftable should be pushed in:
// #STR #STR: "r_drawbrushmodels", "engine/writez", "debug/debugtranslucentsinglecolor", "engine/modulatesinglecolor", "vgui/white", "r_drawentities", "Other textures"
#define BEAMS                           "B9 ? ? ? ? A1 ? ? ? ? FF 10 A1 ? ? ? ? B9"
// #STR: "%s stuck on object %i/%s", "client"
#define MOVEHELPER                      "8B 0D ? ? ? ? 8B 45 ? 51 8B D4 89 02 8B 01"
// #STR SelectWeightedSequence
// or never sig it and use exactly code that game uses
#define PREDICTIONRANDOMSEED            "8B 0D ? ? ? ? BA ? ? ? ? E8 ? ? ? ? 83 C4 04"
// no STR
// it will be easier to find by live debugger
// or just find it below setabs one which is easier to find
#define SETABSANGLES                    "55 8B EC 83 E4 F8 83 EC 64 53 56 57 8B F1 E8"
// Ignoring unreasonable position (%f,%f,%"... is a hint
#define SETABSORIGIN                    "55 8B EC 83 E4 F8 51 53 56 57 8B F1 E8"
// should call check ammo cvar or smth
// #STR: ammo_50AE_impulse
#define WEAPONDATA                      "8B 35 ? ? ? ? FF 10 0F B7 C0"
// #STR: "weapon_c4"
#define HASC4                           "56 8B F1 85 F6 74 31"
// #STR: (mod_studio)
#define INVALIDATE_BONE_CACHE           "80 3D ? ? ? ? ? 74 16 A1 ? ? ? ? 48 C7 81"
// useless since in here you can read it can be forced, but it's safer
// https://www.unknowncheats.me/forum/counterstrike-global-offensive/213556-changing-sky-spoofing-cvar.html
#define LOAD_SKY                        "55 8B EC 81 EC ? ? ? ? 56 57 8B F9 C7 45"
// anything with literal named bones/hitboxes
#define ANIMATION_LAYER                 "8B 89 ? ? ? ? 8D 0C D1"
// #STR: "No model!", "Not Found!
// and anything with sequence
#define SEQUENCE_ACTIVITY               "55 8B EC 53 8B 5D 08 56 8B F1 83"
// also: 55 8B EC 8B 45 10 50 8B 4D 04
// #STR: "value2", "value"
#define RET_ADDR_KEYVALUES_ENGINE       "55 8B EC 56 57 8B F9 8B F2 83 FF 11 0F 87"
// #STR: "value2", "value"
#define RET_ADDR_KEYVALUES_CLIENT       "55 8B EC 56 57 8B F9 8B F2 83 FF 11 0F 87"
// #STR: "Video driver has crashed and been reset, re-uploading reso
#define DX9_DEVICE                      "A1 ? ? ? ? 50 8B 08 FF 51 0C"
// https://aixxe.net/2017/09/steam-overlay-rendering
#define DX9_PRESENT                     "FF 15 ? ? ? ? 8B F0 85 FF"
// https://aixxe.net/2017/09/steam-overlay-rendering
// less safe sig: FF 15 ? ? ? ? 8B D8 85 DB 78 18
#define DX9_RESET                       "C7 45 ? ? ? ? ? FF 15 ? ? ? ? 8B D8"
// #STR: DebugView
// #STR: debug/
// finding it with live debugger is easier and I don't think it needs any explanation how to find your local view matrix
#define VIEW_MATRIX_CLIENT              "0F 10 05 ? ? ? ? 8D 85 ? ? ? ? B9"
// #STR: "func_breakable", "func_breakable_surf"
#define IS_BREAKBLE                     "55 8B EC 51 56 8B F1 85 F6 74 68"
// this is needed because this convar will rely on many things, the r_drawspecificstaticprop and forcing isn't enough
// #STR: "CStaticProp::DrawModel", "Static_Prop_Rendering"
// just like in engine source, before Static_Prop_Rendering there will be a check before to that function
// first call is that function
// now, normal sig from selection points to many other functions so use a relative one
#define IS_USING_PROP_DEBUG             "E8 ? ? ? ? 84 C0 8B 45 08"
// see how many pushes are logically to color struct
// should call this one:
// #STR: "CMaterial::PrecacheVars: error loading vmt file for %s\n", "vmt_patches"
#define GET_COLOR_MODULATION            "55 8B EC 83 EC ? 56 8B F1 8A 46"
// disable useless processing on setupbones
// #STR: "ankle_R", "hand_L", "ball_L", "ball_R", "lh_ik_driver", "weapon_hand_R", "ankle_L"
#define EXTRA_BONES_PROCCESSING         "55 8B EC 83 E4 F8 81 EC ? ? ? ? 53 56 8B F1 57 89 74 24 1C 80"
// disable jiggle bones without forcing convar
// better to use live debugger to find it by easier way
#define BUILD_TRANSFORMATIONS           "55 8B EC 83 E4 F0 81 EC ? ? ? ? 56 57 8B F9 8B 0D ? ? ? ? 89 7C 24 28 8B"
// #STR: "view angles", "Pitch: %6.1f   Yaw: %6.1f %38s", "ideal angles", "Pitch: %6.1f   Yaw: %6.1f   Dist: %6.1f %19s", "camera offset", "Pitch: %6.1f   Yaw: %6.1f   Dist: %6.1f %16s", "sv_cheats"
#define CAM_THINK                       "85 C0 75 30 38 87"
// "#empty#", "#int#"
// also easy to find as 'KeyValuesSystem' should be generated in ida as externs
#define KEY_VALUES_FROM_STR             "55 8B EC 83 E4 F8 81 EC 0C 05"
// found by checking what's inside bone threads
// str anything like bone access
// allocation done here? direct reference: 55 8B EC 83 EC 08 56 8B F1 8A 86
#define CACHED_BONE                     "FF B7 ? ? ? ? 52"
// #STR: "CParticleCollection::Simulate", "Particle Simulation"
#define PARTICLE_SIMULATE               "55 8B EC 83 E4 F8 83 EC 30 56 57 8B F9 0F 28 E1 8B 0D ? ? ? ? F3 0F 11 64 24 ? 89 7C 24 18 8B 81"
// #STR: "DispatchEffect: effect \"%s\" not found on client\n", "Encountered multiple different effects with the same nam
// see what calls this and you can see head ptr, should be close to actual message
#define HEAD_OF_EFFECTS                 "8B 35 ? ? ? ? 85 F6 0F 84 ? ? ? ? 0F 1F 00"
// check CTraceFilterOmitPlayers
#define GOES_THROUGH_SMOKE              "55 8B EC 83 EC 08 8B 15 ? ? ? ? 0F 57 C0"
// #STR: "TempEntity", "TE_DispatchEffect %s %s", "originx", "originy", "originz", "startx", "starty", "startz", "normalx", "normaly"
#define DISPATCH_EFFECT                 "55 8B EC 83 E4 F8 83 EC 20 56 57 8B F9 C7 44 24 ? ? ? ? ? 8D 4C 24 08 C7 44 24 ? ? ? ? ? 8B F2 C7 44 24"
// #STR: "effects/tesla_glow_noz"
#define FX_TESLA                        "55 8B EC 81 EC ? ? ? ? 56 57 8B F9 8B 47 18"
// #STR: "effects/flashlight001", "Other textures"
#define FLASHLIGHT_CREATE               "55 8B EC F3 0F 10 45 ? B8"
// #STR: "entindex", "flashlightHandle", "flashlightState", "FlashlightState"
#define FLASHLIGHT_DESTROY              "56 8B F1 E8 ? ? ? ? 8B 4E 28"
// #STR: "CFlashlightEffect::UpdateLight", "FlashlightState", "entindex", "flashlightHandle", "flashlightState", "Flashlight Shadows"
#define FLASHLIGHT_UPDATE               "55 8B EC 81 EC ? ? ? ? 53 56 8B F1 8B 0D ? ? ? ? 57 8B 81"
// my method is to first lookup the const CClientState::`vftable'
// we can see this function: direct reference: [actual address in first opcode] E8 ? ? ? ? EB 02 33 F6 85 FF
// a lot of initialization going on here, but most importantly we must find the pointer to clientstate
// skip reading to the last memset operation, see mov eax, edi -> this copies to the result
// first operation below is the offset to add. This although is very stupid method, better is this:
// "CEngineClient::SetViewAngles:  rejecting invalid value [%f %f %f]\n" see what is called under
// currently dword_1059F194, now to get it, there are many functions containing it. This sig needs small opcode add.
#define CLIENT_STATE                    "A1 ? ? ? ? 8B 88 ? ? ? ? 85 C9 75 07"
// STR: "CNetChan_TransmitBits->send", "CNetChan::SendDatagram
#define SEND_DATAGRAM                   "55 8B EC 83 E4 F0 B8 ? ? ? ? E8 ? ? ? ? 56 57 8B F9 89 7C 24 14"
// STR: const CTraceFilterSimple
#define CTRACE_FILTER_SIMPLE            "55 8B EC 83 E4 F0 83 EC 7C 56 52"
// #STR: "CHudWeaponSelection"
#define CSGO_HUD                        "B9 ? ? ? ? 68 ? ? ? ? E8 ? ? ? ? 89"
// #STR: "[%d] Could not find Hud Element: %s\n"
#define FIND_ELEMENT                    "55 8B EC 53 8B 5D 08 56 57 8B F9 33 F6 39 77 28 7E 1E"
// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/studiorender/r_studiodraw.cpp#L451
// inside: direct reference: [actual address in first opcode] E8 ? ? ? ? 8B 4D 2C
// for ( i = this; v12 < a4; v11 += R_StudioDrawPoints((int)i, a2, a3, a6, a7, a8, v18, a10, a11) )
// need to get now mov instruction for ebp
// got it from here: https://www.unknowncheats.me/forum/counterstrike-global-offensive/125029-d3d-chams-without-vertcounts.html
#define R_STUDIODRAWPOINTS              "8B 7D FC 03 F8 89 7D FC EB 1F"
// to find it you must check it yourself
// anything like Failed to convert image data to RGBA might help to path it
#define UNK_FILESYS                     "C7 43 ? ? ? ? ? 83 7C 24 ? ? 7C 25 8B 54 24 48"
// #STR: "Error! CMapOverview::SetMap: couldn't load file %s.\n", "file://{images_overviews}/%s_radar_spectate.dds", "pos_x", "pos_y", "scale", "resource/overviews/%s.txt"
#define UNK_OVERVIEWMAP                 "55 8B EC 81 EC ? ? ? ? 53 8B 5D 08 8B D3"
// #STR: "ClientScheme", "resource/ClientScheme.res", "VPhysics031", "VPhysicsSurfaceProps001", "VPhysicsCollision007", "ClientDLL"
// get this ptr https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/cdll_client_int.cpp#L1323
#define VIEW_RENDER                     "8B 0D ? ? ? ? FF 75 0C 8B 45 08"
// #STR: "Client_Animation", "C_BaseAnimating::SetupBones", "*** ERROR: Bone access not allowed (entity %i:%s)\n", "%d:%s", "SetupBones: invalid bone array size (%d - needs %d)\n", "Client_Animation_Threaded"
#define ACCUMULATE_LAYERS               "84 C0 75 0D F6 87"
#define SETUP_VELOCITY                  "84 C0 75 38 8B 0D ? ? ? ? 8B 01 8B 80"
#define SETUP_OCCLUSION                 "84 C0 0F 85 ? ? ? ? A1 ? ? ? ? 8B B7"
// #STR: "Tried BeginRenderTargetAllocation after game startup. If I
#define DISABLE_RENDER_TARGET_ALLOC		"80 B9 ? ? ? ? ? 74 0F"
// #STR: "userid", "entindex", "weaponhud_selection"
#define LOCAL_PLAYER                    "8B 0D ? ? ? ? 83 FF FF 74 07"
// from prediction stack
#define PREDICTION_MOVE_DATA            "A1 ? ? ? ? F3 0F 59 CD"
// #STR: "Client: Missing precache for particle system \"%s\"!\n" - this func is a mess to start working on rain manually
#define DISPATCH_PARTICLE               "55 8B EC 83 E4 F8 83 EC 6C 53 56 57 8B F9 8B DA 8D 4C 24 10 E8"
// see what's under:
// ; #STR: "$c0_x", "_rt_FullFrameFB", "_rt_SmallFB0", "Other textures", "dev/blurgaussian_3x3", "_rt_SmallFB1", "$c0_y", "$c1_x", "$c1_y", "RenderTargets"
// is called
#define IS_DEPTH                        "8B 0D ? ? ? ? 56 8B 01 FF 50 34 8B F0 85 F6 75 04"
// wrapper to allow in other hooks
// #STR: "effects/underwater_overlay", "$c0_x", "$c0_y", "$c0_z", "ClientEffect textures"
#define DRAW_EFFECT_MATRIAL             "55 8B EC 83 E4 ? 83 EC ? 53 56 57 8D 44 24 ? 89 4C"
// #STR: "StartParticleEffect:  Failed to find precached particle sy
#define START_PARTICLE_EFFECT           "55 8B EC 83 EC 34 80 3D ? ? ? ? ? 53 56 57 8B DA 8B F1 0F 85"
// #STR: "state", "ParticleSystem_Destroy"
#define PARTICLE_SYSTEM_DESTROY         "56 8B F1 F6 86 ? ? ? ? ? C7 06"
// #STR: "Attempted to create unknown particle system type \"%s\"!\n, "error", "explosion_smokegrenade"
// see what under this str gets called
#define PARTICLE_CALL                   "55 8B EC 83 EC ? 53 56 8B F2 89 75"
// found by following leak's code again use unknown particle as str ref
#define IS_EFFECT_CACHED                "55 8B EC 83 EC ? 53 56 57 8B 7D ? 8D 59 ? 85 FF"
// #STR: "state", "ParticleSystem_SetControlPointPosition"
#define SET_PARTICLE_POINT              "55 8B EC 53 8B 5D ? 56 8B F1 F6 86"
// explosion_smokegrenade, check inside: unknown particle
#define PARTICLE_SYSTEM                 "55 8B EC 51 56 8B 35 ? ? ? ? 8B CE"
// followed by leak's code
#define FIND_STRING_INDEX               "55 8B EC 83 EC ? 53 8B 5D ? 57 8B F9 89 7D ? 85 DB"
// #STR: "Particle/Effect_Rendering", "FX_Blood"
#define FX_BLOOD                        "55 8B EC 83 EC 34 53 56 57 8B F9 F3 0F"
// #STR: "$MotionBlurViewportInternal", "$MotionBlurInternal"
// you can see there is an offset with pointer that is pushed below, "push 4" is helpful, this is the part of editing vector
#define BLUR_MATERIAL_ARR_1             "68 ? ? ? ? FF 50 34 8B 4E 08 5E 85 C9 74 0C"
// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/cstrike15/fx_cs_blood.cpp#L381
#define BLOOD_CALLBACK                  "55 8B EC 8B 4D 08 F3 0F 10 51 ? 8D 51 18"
// old was in VClientEntityList0 exactly like
// https://github.com/perilouswithadollarsign/cstrike15_src/blob/f82112a2388b841d72cb62ca48ab1846dfcc11c8/game/client/cliententitylist.h#L130
// now can't get addr by index, they are placed exactly in same place tho
// there is now one class for cache - it only has 2 vfuncs. Same way like apex has and all updated source engine games
// sig for the new class ptr B9 ? ? ? ? E8 ? ? ? ? 8B C8 E8 ? ? ? ? 8B F0 8B CE
#define ADD_ENT                         "55 8B EC 51 8B 45 0C 53 56 8B F1 57"
#define REMOVE_ENT                      "55 8B EC 51 8B 45 0C 53 8B D9 56 57 83 F8 FF 75 07"
// #STR: "CPrediction::ProcessMovement", and see what calls random seed by 0FFFFFFFF, at the bottom the jump is predicted player
#define PREDICTED_PLAYER                "89 35 ? ? ? ? F3 0F 10 48 20"
// #STR: "CLIENT:  %s(%s) thinking for %.02f ms!!!\n", ".PAVC_BaseEntity@@"
#define PHYSICS_RUN_THINK               "55 8B EC 83 EC 10 53 56 57 8B F9 8B 87"
// #STR: CPrediction::ProcessMovement
// and leak RunCommand
#define BUTTONS_FORCED                  "8B 86 44 33 ? ? 09 47 30"
// #STR: "CPrediction::ProcessMovement"
// and leak RunCommand
#define LAST_COMMAND                    "8D 8E ? ? ? ? 89 5C 24 3C"
// found by looking around in C_BaseEntity, I looked in mac binaries and compared current one
#define IS_FOLLOWED_ENT                 "F6 ? ? ? ? ? ? 74 31 80"
// #STR: "cl_updaterate"
#define RET_ADDR_INTERPOLATION          "84 C0 0F 85 ? ? ? ? 38 05 ? ? ? ? 0F 84 ? ? ? ? 53"
// #STR: CPrediction::ProcessMovement
// and leak RunCommand
#define POST_THINK_PHYSICS              "55 8B EC 83 E4 F8 81 EC ? ? ? ? 53 8B D9 56 57 83 BB"
// #STR: CPrediction::ProcessMovement
// and leak RunCommand
#define SIMULATE_ENTITIES               "56 8B F1 57 8B BE ? ? ? ? 83 EF 01 78 74"
// #STR: "CCSPlayer", "CPlantedC4", "CHostage", "Unknown entity update received by ProcessSpottedEntityUpda, "Unknown entity class received in ProcessSpottedEntityUpdat
#define SPOTTED_ENTITIY_UPDATE          "55 8B EC 83 EC 18 8B 45 08 53 56 57"
// "\ntime\tbullet\trange\trecovery\tinaccu"
// xref addtoTail() function or follow player stack direct reference: [actual address in first opcode] E8 ? ? ? ? 46 3B B3 ? ? ? ? 7C 8C
#define VEC_CLIENT_IPACT_LIST           "8D 8F ? ? ? ? F3 0F 10 84 24"
// #STR: "Server event \"%s\", Tick %i:\n", "GameEventListener2 callback in list that should NOT be - %, "Callback for event \"%s\" is NULL!!!\n", "portal2", "FireEvent: event '%s' not registered.\n", "Game event \"%s\", Tick %i:\n"
#define FIRE_INTERN                     "55 8B EC 83 E4 F8 83 EC 0C 8B C1 53 56"
// #STR: "KeyValues::LoadFromBuffer(%s%s%s): Begin"
#define LOAD_FROM_BUFFER                "55 8B EC 83 E4 F8 83 EC 34 53 8B 5D 0C 89"
// #STR: "KeyValues::ParseIncludedKeys: Couldn't load included keyva
#define KEYVALUES_CONSTRUCT             "55 8B EC 56 8B F1 33 C0 8B 4D 0C 81"
// #STR: "KeyValues::ParseIncludedKeys: Couldn't load included keyva
#define KEYVALUES_DESTRUCT              "56 8B F1 E8 ? ? ? ? 8B 4E 14"
// #STR: CPrediction::ProcessMovement
#define USING_STANDARD_WEAPONS_VEH      "56 57 8B F9 8B 97 ? ? ? ? 83 FA FF 74 43 0F"
// #STR: C_BasePlayer::`vftable
#define SELECT_ITEM                     "55 8B EC 56 8B F1 ? ? ? 85 C9 74 71 8B 06"
// #STR: CPrediction::ProcessMovement
#define CHECK_HAS_THINK_FN              "55 8B EC 56 57 8B F9 8B B7 ? ? ? ? 8B"
// #STR: "C_BaseEntity::SaveData"
// just after first offset has been pushed with "SaveData", there is a copy
#define TRANSFER_DATA                   "55 8B EC 8B 45 10 53 56 8B F1 57"
// #STR: "Shutdown %i predictable entities and %i client-created ent
#define SHUTDOWN_PREDICTABLES           "53 56 8B 35 ? ? ? ? 33 DB 57 33 FF"
// #STR: "%d:  Reinitialized %i predictable entities\n"
#define REINIT_PREDICTABLES             "A1 ? ? ? ? B9 ? ? ? ? 53 56 FF 50 18"
// #STR: "userid", "gg_halftime"
#define SERVER_PREROUND                 "55 8B EC 83 EC 0C 53 8B D9 56 57 8B 03"
// #STR: "Can't find specific footstep sound! (%s) - Using the defau, "Heavy.Step", "T_Default.Suit", "CT_Default.Suit", "ct_%s"
#define PLAY_STEP_SOUND                 "55 8B EC 8B 45 18 81 EC"
// #STR: "userid", "health", "priority", "player_hurt", "attacker"
#define ON_TAKE_DMFG_ALIVE              "55 8B EC 83 EC 18 56 57 8B 7D 08 8B F1 57"
// #STR: "Rain simulation: %du (%d tracers)"
#define SIMULATE_PARTICLE               "55 8B EC 83 E4 F8 83 EC 1C 53 8B D9 F3 0F 11 4C 24"
// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/shared/physics_main_shared.cpp#L1783
#define SIMULATION_TICK                 "8B 86 AC 02"
// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/c_baseplayer.cpp#L2906
#define COMMAND_CONTEXT                 "C6 86 0C 35"
// #STR: "Reference Count for Material %s (%d) != 0\n"
#define MATERIAL_DESTRUCT               "55 8B EC 64 A1 ? ? ? ? 6A FF 68 ? ? ? ? 50 64 89 25 ? ? ? ? 56 8B F1 B9"
// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/cstrike15/cs_hud_scope.cpp#L126
#define SCOPE_PAINT                     "55 8B EC 83 E4 F8 83 EC 78 56 89 4C 24 14"
// #STR: "C_BaseEntity::RestoreData"
#define RESTORE_DATA                    "55 8B EC 83 E4 F8 83 EC 44 53 56 8B 75 0C 8B"
// #STR: "C_BaseEntity::SaveData"
#define SAVE_DATA                       "55 8B EC 83 E4 F8 83 EC 40 56 8B 75 0C 57 8B"
// bloodspray or something, those callbacks straight up never get called
#define BLOOD_UTIL_CALLBACK             "56 57 8B FA 8B F1 83 FF FF 0F 84 ? ? ? ? 85 FF 75 0C A1 ? ? ? ? B9 ? ? ? ? EB 0A"
// #STR: "hidehud"
#define CHUD_IS_HIDDEN                  "55 8B EC 83 EC 10 80 79 7C 00"
// #STR: "effects/flashbang", "$basetexture", "effects/flashbang_white", "ClientEffect textures"
#define FLASH_EFFECT_RET                "FF 50 74 83 EF 01"
// #STR: "effects/flashbang", "$basetexture", "effects/flashbang_white", "ClientEffect textures"
#define FLASH_EFFECT_WHITE_RET          "88 4D F4 8B 0D"
// #STR: "ViewDrawFade", "World Rendering"
#define VIEW_FADE                       "55 8B EC 8B 0D ? ? ? ? 56 8B B1"
// #STR: "effects/blood_gore", "blooddrops", "effects/blood_drop", "effects/blood_core"
#define FX_BLOOD_SPRAY                  "55 8B EC 81 EC ? ? ? ? 53 8B DA F3 0F 11 55"
// puprose is to never use events and get ptr to it from here, ez
// #STR: "duration", "AvatarSpec__HealthBar_PulseOnce", "show_survival_respawn_status", "loc_token", "#Survival_Respawn_Countdown", "player_hurt", "userid"
#define UNK_SURVIVAL_RELATED            "55 8B EC 51 53 8B 5D 08 56 57 8B F9 8B CB 8B 03 89 7D FC FF 50 04 8B D0 BE ? ? ? ? 0F 1F 00 8A 08 3A 0E 75 1A 84 C9 74 12 8A 48 01 3A 4E 01 75 0E 83 C0 02 83 C6 02 84 C9 75 E4 33 C0 EB 05 1B C0 83 C8 01 85 C0 0F 85 ? ? ? ?"
// #STR: "GameInstructor", "C_GameInstructor::FireGameEvent", "gameinstructor_draw", "Round ended...\n", "Set to draw...\n", "gameinstructor_nodraw", "Set to not draw...\n", "round_end", "hltv_replay", "GAME INSTRUCTOR:"
#define GAME_INSTRUCTOR_EVENT           "55 8B EC 83 EC 08 53 56 57 8B F9 8B 0D ? ? ? ? 8B 81 ? ? ? ?"
// #STR: "snow_outer", "rain_storm", "rain_storm_screen", "rain_storm_outer", "rain_outer", "ash_outer"
#define PRECIPITATION_INIT              "55 8B EC 83 EC 5C 8B C1"
// #STR: "Rain simulation: %du (%d tracers)"
#define CLIENT_THINK_PRECIPITATION      "A1 ? ? ? ? 83 C1 F4"
// very, very many places. I picked the one with this str ref:
// #STR: "origin: <%d, %d, %d>\n", "light:  %d\n"
#define HOST_STATE                      "A1 ? ? ? ? 83 EC 08 56 BE ? ? ? ?"
// found from glow DrawModel function
#define FIRST_MOVE_CHILD                "8B 80 0C 03 00 00 83 F8 FF 0F 84 C2 00 00 00"
// found from glow DrawModel function
#define NEXT_PEER                       "8B 8E ? ? ? ? 83 F9 FF 74 1F 0F B7 C1 C1 E0 04 05 ? ? ? ? 74 0C C1 E9 10 39 48 04 75 04 8B 30 EB 02 33 F6 85 F6 75 B5"
// #STR: "func_breakable", "func_breakable_surf"
#define TAKE_DMG                        "80 BE ? ? ? ? ? 75 46 8B 86 ? ? ? ? 83 F8 11"
// below other setabs... functions, as a reference take anything in client that uses it
#define SET_ABS_VELOCITY                "55 8B EC 83 E4 F8 83 EC 0C 53 56 57 8B 7D 08 8B F1 F3 0F 10 07 0F 2E 86 ? ? ? ? 9F F6 C4 44 7A 28 F3 0F"
// #STR: "Client: Missing precache for particle system \"%s\"!\n"
#define GET_PARTICLE_SYSTEM_IDX         "56 8B F1 85 F6 74 22 8B 0D ? ? ? ?"
// #STR: "Client: Missing precache for particle system \"%s\"!\n"
#define DISPATCH_PARTICLE_EFFECT        "55 8B EC 83 E4 F8 81 EC ? ? ? ? 56 8B F1 85 F6"
// spotted in the glow
#define RENDER_BOX                      "55 8B EC 83 E4 F8 81 EC ? ? ? ? 53 56 57 E8 ? ? ? ? 8B 0D ? ? ? ? 8B 01 FF 90 ? ? ? ? 8B F0 89 74 24 2C 85 F6 74 07 8B 06"
// close to render box
#define RENDER_LINE                     "55 8B EC 81 EC ? ? ? ? 53 56 57 E8 ? ? ? ? 8B 0D ? ? ? ? 8B 01 FF 90 ? ? ? ? 8B F0 85 F6 74 07 8B 06"
// CEnginePostMaterialProxy::OnBind
#define MATERIALPROXY_ONBIND            "56 8B F1 57 8B 4E 04 85 C9"
// ClientModeCSNormal::UpdatePostProcessingEffects
// https://www.unknowncheats.me/forum/2019182-post26.html
#define BLURSCOPE_VIGNETTEPOST          "0F 11 05 ? ? ? ? F3 0F 7E 87"
// ClientModeCSNormal::UpdatePostProcessingEffects()
#define UPDATEPOST_EFFECTS              "55 8B EC 51 53 56 57 8B F9 8B 4D 04 E8 ? ? ? ? 8B 35 ? ? ? ? 85 F6"
// https://www.unknowncheats.me/forum/counterstrike-global-offensive/331329-achieving-noscope-blurry-lines.html
#define SCOPE_DUST_RET                  "FF 50 3C 8B 4C 24 20"
// https://www.unknowncheats.me/forum/counterstrike-global-offensive/331329-achieving-noscope-blurry-lines.html
#define SCOPE_ARC_RET                   "8B 0D ? ? ? ? FF B7 ? ? ? ? 8B 01 FF 90 ? ? ? ? 8B 7C 24 1C"
// refer to other glow sigs, or glow_outline code
#define ADD_GLOW_BOX                    "55 8B EC 53 56 8D 59"
// #STR: "C_BaseAnimating::DrawModel"
#define BASE_ANIMATING_DRAW_MODEL       "55 8B EC 83 EC 10 53 56 8B F1 8B 0D ? ? ? ? 57 89 75 F8 8B 81 ? ? ? ?"
// find any place in sdk that setString is used, often material inits
#define KEY_VALUES_SET_STRING           "55 8B EC A1 ? ? ? ? 53 56 57 8B F9 8B 08 8B 01 FF 77 04"
// same...
#define KEY_VALUES_FIND_KEY             "55 8B EC 83 EC 1C 53 8B D9 85 DB"
// follow refs as some effects, eg: embers
#define GET_PMATERIAL                   "55 8B EC 83 EC 18 53 8B D9 56 57 83 7B 60 00 75 0B"
// r_printdecalinfo
#define S_ADECALPOOL                    "A1 ? ? ? ? 8B 0C B0"
// "psurface NULL in R_DecalCreate!\n"
#define R_DECAL_CREATE                  "53 8B DC 83 EC 08 83 E4 F8 83 C4 04 55 8B 6B 04 89 6C 24 04 8B EC 83 EC 38 8B C2 F3 0F 11 5D ? F3 0F 11 55 ? 89 45 FC"
// reverse decal adding
#define R_DECAL_ADD_TO_SURFACE          "55 8B EC 83 EC 08 53 56 8B D9 B9 ? ? ? ? 57"
// reverse init decals
#define G_ADECALSORTPOOL                "B9 ? ? ? ? E8 ? ? ? ? A1 ? ? ? ? B9 ? ? ? ? FF 05 ? ? ? ?"
// #STR: "Couldn't get trampoline region lock, will continue possibl
#define VALVE_HOOK                      "55 8B EC 51 8B 45 10 C7"
// #STR: "Aborting UnhookFunc because pRealFunctionAddr is null\n", "System page size: %u\n", "UnhookFunc not restoring original bytes - jump instruction, "UnhookFunc not restoring original bytes - jump target has , "Warning: VirtualProtect call failed during unhook\n", "Warning: VirtualProtect (2) call failed during unhook\n", "Warning: VirtualProtect (2) call failed to restore protect, "Warning: VirtualProtect call failed to restore protection , "UnhookFunc not restoring original bytes - function is unma, "Aborting UnhookFunc because pRealFunctionAddr is not hooke
#define VALVE_UNHOOK                    "55 8B EC 64 A1 ? ? ? ? 6A FF 68 ? ? ? ? 50 64 89 25 ? ? ? ? 81 EC ? ? ? ? 56 8B 75 08 85 F6 75 26 80 7D 0C 00 0F 84 ? ? ? ?"
// saw in the renderoverlaysmoke
#define VIEW_FACE_SMOKE_RET             "F3 0F 2C C0 88 45 FF 8B 01 FF 50 74"
// r_flashlightdepthtexture check at end
#define VIEW_DRAW_SCENE                 "53 8B DC 83 EC 08 83 E4 F8 83 C4 04 55 8B 6B 04 89 6C 24 04 8B EC 83 EC 10 A1 ? ? ? ? 56 8B F1 57 8B 40 04 48"
// follow effects sode for precip
#define CREATE_PARTICLE_PRECIP          "55 8B EC 51 A1 ? ? ? ? 53 56 8B F1 B9 ? ? ? ?"
// follow effects sode for precip
#define INITIALIZE_PRECIP_PARTICLE      "55 8B EC 83 EC 5C 8B C1"
// #STR: "CEffectsList::DrawEffects", "Particle/Effect_Rendering"
#define DRAW_EFFECTS                    "55 8B EC 83 EC 08 A1 ? ? ? ? 89 4D FC 8B 90 ? ? ? ?"
// #STR: "$depth_feather"
#define DRAW_WORLD_AND_ENTITIES         "55 8B EC 83 EC 4C 53 56 57 8B 3D ? ? ? ? 8B F1 8B CF 89 75 F8 8B 07 FF 90 ? ? ? ? 8B 0D ? ? ? ? 8D 45 B8 8B 5D 0C 50 6A 00"
// #STR: "DrawTranslucentEntities"
#define DRAW_TRANSCULENT_RENDERABLE     "55 8B EC 81 EC ? ? ? ? 83 3D ? ? ? ? ? 53 56 8B D9 57 89 5D E4 74 1C 8B 0D ? ? ? ? 8B 01 FF 90 ? ? ? ? 6A 00"
// saw in the renderview where precip loop is executed (inlined call though)
#define PRECIPICATION_UNK_COUNTER       "3B 35 ? ? ? ? 7C E9 A1 ? ? ? ? B9 ? ? ? ? 8B 40 34"
// ^ like so
#define G_PRECIPICATION                 "A1 ? ? ? ? 8B 0D ? ? ? ? 8B 04 B0 0F BF 90 ? ? ? ? 8B 01 52 FF 50 18 85 C0 0F 84 ? ? ? ? B9 ? ? ? ? 66 85 08 0F 86 ? ? ? ? 8B 0D ? ? ? ? 8D 5D F4 8B 40 04 53 8B 11"
// string ref "World" strcpy
#define CLIENT_WORLD                    "A1 ? ? ? ? F3 0F 10 4D ? EB 71"
// see the g_precips vec, when it removes element
#define DESTRUCT_PRECIPICATION          "55 8B EC 51 56 8B F1 8D 45 FC 57"
// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/c_baseentity.cpp#L1189
#define DORMANT_STATE                   "66 C7 86 ? ? ? ? ? ? C7 86 ? ? ? ? ? ? ? ? C7 86 ? ? ? ? ? ? ? ? C7 86 ? ? ? ? ? ? ? ? 66 89 86 ? ? ? ? 89 86 ? ? ? ?"
// check strings used for stop in leak
#define STOP_SOUND                      "55 8B EC 51 56 57 8B F9 8B 47 08 8D 4F 08 FF 50 28 83 F8 FF 75 1A 8B 07"
// https://gitlab.com/KittenPopo/csgo-2018-source/-/blob/main/game/client/cstrike15/clientmode_csnormal.cpp#L2246
// lot of events
#define CLIENTMODE_CSNORMAL_EVENT       "55 8B EC 83 E4 C0 B8 ? ? ? ? E8 ? ? ? ? 89 4C 24 08"
// reversed rain draw
#define TRACER_DRAW                     "55 8B EC 83 EC 40 8B C2 8B 55 08 0F 28 D3 56 8B F1 8D 4D C0 51 8B C8 E8 ? ? ? ? 83 C4 04"
// reversed weather code
#define WEATHER_GETVCOLLIDE_RET         "83 0F 02 83 0B 02 39 35 ? ? ? ? 0F 8E ? ? ? ? A1 ? ? ? ? 8B 0D ? ? ? ? 8B 04 B0 0F BF 90 ? ? ? ? 8B 01 52 FF 50 18"
// reversed weather code
#define DISPATCH_INNER_PRECIP           "55 8B EC 83 EC 40 53 56 57 8B 7D 08 8B F1 57"
// #STR: "Attempting to create unknown particle system '%s' \n"
#define NEW_PARTICLE_EFFECT_CREATE      "55 8B EC 51 53 56 8B 35 ? ? ? ? 57 8B 7D 08 89 4D FC 8B CE 57 E8 ? ? ? ? 84 C0"
// #STR: "ParticleSystem_SetControlPointPosition"
#define NEW_PARTICLE_SET_POINT          "55 8B EC 53 8B 5D 0C 56 8B F1 F6 86 ? ? ? ? ? 0F 84 ? ? ? ?"
// #STR: "ParticleSystem_SetControlPointObject"
#define NEW_PARTICLE_SET_POINT_ENT      "55 8B EC 53 56 8B F1 57 8B 7D 0C F6 86 ? ? ? ? ? 0F 84 ? ? ? ?"
// reversed weather code, dispatch
#define SET_CONTROL_POINT_WEATHER       "8D 45 C0 50 6A 01 E8 ? ? ? ?"
// reversed physics
#define GET_VELOCITY                    "FF 90 ? ? ? ? F3 0F 10 8C 24 ? ? ? ? F3 0F 10 84 24 ? ? ? ?"
// #STR: "CTempEnts::PhysicsProp: model index %i not found\n"
#define VPHYSICS_GET_OBJ                "8B 8E ? ? ? ? 85 C9 74 3A"
// "Can't force single thread from within t"...
#define FORCE_SINGLE_THREADED           "53 56 57 8B F9 FF 15 ? ? ? ? 84 C0 75 0E"
// reversed engine models
#define RESTOTRE_MATERIALS              "55 8B EC 83 E4 F8 83 EC 08 8B 0D ? ? ? ?"
// "Mod_LoadCubemapSamples: funny lump size"
#define CUBEMAP_LOAD                    "55 8B EC 81 EC ? ? ? ? 53 56 57 51 6A 2A 8D 8D ? ? ? ? E8 ? ? ? ?"
// "CMaterial::PrecacheVars: error loading vmt file for %s\n"
#define PRECACHE_VARS                   "55 8B EC 6A FF 68 ? ? ? ? 64 A1 ? ? ? ? 50 64 89 25 ? ? ? ? 83 EC 14 53 8B D9 56 8B 75 10 89 5D EC 57 8D 7B 50 85 F6"
// find yourself, scan the game
#define LEVEL_NAME                      "80 3D ? ? ? ? ? 74 ? 8A 08 80 F9 ? 74 ? 80 F9 ? 75 ? C6 00 ? 40 80 38 ? 75 ? 8A 45"
// "ClientDll"
#define INIT_GAME_SYSTEMS               "55 8B EC 83 EC 08 57 8B F9 89 7D FC E8 ? ? ? ? 84 C0"
```

`hack/gamememory/system/win.cpp`:

```cpp
#include "win.hpp"

#include <codecvt>
#include <string_view>
#include <unordered_map>

namespace windows
{
	std::unordered_map<std::string_view, HMODULE> cachedModules;
}

PPEB windows::getPeb()
{
#if defined(_WIN64)
	return reinterpret_cast<PPEB>(READ_PEB_POINTER(0x60));
#else
	return reinterpret_cast<PPEB>(READ_PEB_POINTER(0x30));
#endif
}

FARPROC windows::getExportAddress(HMODULE hModule, const std::string_view exportName)
{
	PIMAGE_DOS_HEADER pDosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
	if (!pDosHeader)
		return nullptr;

	PIMAGE_NT_HEADERS pNtHeader = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<BYTE*>(hModule) + pDosHeader->e_lfanew);

	if (pNtHeader->Signature != IMAGE_NT_SIGNATURE)
		return nullptr;

	PIMAGE_EXPORT_DIRECTORY pExportDir = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(reinterpret_cast<BYTE*>(hModule) + pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	DWORD* pFuncTable = reinterpret_cast<DWORD*>(reinterpret_cast<BYTE*>(hModule) + pExportDir->AddressOfFunctions);
	DWORD* pNameTable = reinterpret_cast<DWORD*>(reinterpret_cast<BYTE*>(hModule) + pExportDir->AddressOfNames);
	WORD* pOrdinalTable = reinterpret_cast<WORD*>(reinterpret_cast<BYTE*>(hModule) + pExportDir->AddressOfNameOrdinals);

	for (DWORD i = 0; i < pExportDir->NumberOfNames; ++i) 
	{
		std::string_view currentName = reinterpret_cast<const char*>(reinterpret_cast<BYTE*>(hModule) + pNameTable[i]);
		if (currentName == exportName) 
		{
			WORD ordinal = pOrdinalTable[i];
			DWORD functionRVA = pFuncTable[ordinal];
			return reinterpret_cast<FARPROC>(reinterpret_cast<BYTE*>(hModule) + functionRVA);
		}
	}

	return nullptr;
}

HMODULE windows::getModuleHandle(std::string_view moduleName)
{
	if (auto it = cachedModules.find(moduleName); it != cachedModules.end())
		return it->second;

	const PPEB pPeb = getPeb();
	const PPEB_LDR_DATA pLdrData = pPeb->Ldr;

	PLDR_DATA_TABLE_ENTRY pModuleEntry = reinterpret_cast<PLDR_DATA_TABLE_ENTRY>(pLdrData->InLoadOrderModuleList.Flink);

	HMODULE moduleBase = nullptr;
	while (pModuleEntry != nullptr && pModuleEntry->DllBase != nullptr)
	{
		std::wstring moduleNameWide(pModuleEntry->BaseDllName.Buffer, pModuleEntry->BaseDllName.Length / sizeof(wchar_t));
		std::string moduleNameString(moduleNameWide.length(), 0);
		// because warning
		std::transform(moduleNameWide.begin(), moduleNameWide.end(), moduleNameString.begin(), [](wchar_t wc)
			{
				return static_cast<char>(wc);
			});
		if (moduleNameString == moduleName)
		{
			moduleBase = static_cast<HMODULE>(pModuleEntry->DllBase);
		}

		pModuleEntry = reinterpret_cast<PLDR_DATA_TABLE_ENTRY>(pModuleEntry->InLoadOrderLinks.Flink);
	}

	cachedModules[moduleName] = moduleBase;

	return moduleBase;
}
```

`hack/gamememory/system/win.hpp`:

```hpp
#pragma once

#include <Windows.h>

#ifdef _WIN64
#define READ_PEB_POINTER __readgsqword
#else
#define READ_PEB_POINTER __readfsdword
#endif

extern "C"
{
	typedef struct _UNICODE_STRING
	{
		USHORT Length;
		USHORT MaximumLength;
		PWSTR Buffer;
	} UNICODE_STRING, * PUNICODE_STRING;
	typedef const UNICODE_STRING* PCUNICODE_STRING;

	typedef struct _PEB_LDR_DATA
	{
		ULONG Length;
		BOOLEAN Initialized;
		HANDLE SsHandle;
		LIST_ENTRY InLoadOrderModuleList;
		LIST_ENTRY InMemoryOrderModuleList;
		LIST_ENTRY InInitializationOrderModuleList;
		PVOID EntryInProgress;
		BOOLEAN ShutdownInProgress;
		HANDLE ShutdownThreadId;
		// ..
	} PEB_LDR_DATA, * PPEB_LDR_DATA;

	typedef struct _LDR_DATA_TABLE_ENTRY
	{
		LIST_ENTRY InLoadOrderLinks;
		LIST_ENTRY InMemoryOrderLinks;
		union
		{
			LIST_ENTRY InInitializationOrderLinks;
			LIST_ENTRY InProgressLinks;
		};
		PVOID DllBase;
		PVOID EntryPoint;
		ULONG SizeOfImage;
		UNICODE_STRING FullDllName;
		UNICODE_STRING BaseDllName;
		// ...
	} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

	typedef struct _PEB
	{
		BOOLEAN InheritedAddressSpace;
		BOOLEAN ReadImageFileExecOptions;
		BOOLEAN BeingDebugged;
		HANDLE Mutant;
		PVOID ImageBaseAddress;
		PPEB_LDR_DATA Ldr;
		PVOID ProcessParameters; // PRTL_USER_PROCESS_PARAMETERS
		// ...
	} PEB, * PPEB;
}

namespace windows
{
	PPEB getPeb();
	FARPROC getExportAddress(HMODULE hModule, std::string_view exportName);
	HMODULE getModuleHandle(std::string_view moduleName);
}
```

`hack/menu/GUI-ImGui/imguiaddons.cpp`:

```cpp
#include "imguiaddons.hpp"

#include "menu.hpp"

#include <config/config.hpp>
#include <utilities/utilities.hpp>
#include <cheats/game/globals.hpp>

#include <imgui_internal.h>

void ImNotify::handle()
{
	const ImVec2 screenSize = ImGui::GetIO().DisplaySize;
	constexpr float widthRect = 200.0f;
	constexpr float fineClip = 5.0f;

	constexpr float animationOUT = 0.5f;
	constexpr float animationIN = 0.02f; // bigger values wont look good cuz its small pos difference

	float height = fineClip;
	for (size_t i = 0; auto& notify : m_allNotifies)
	{
		const float in = static_cast<float>(ImClamp((ImGui::GetTime() - notify.time) / animationIN, 0.95, 1.0));
		const float out = static_cast<float>(ImClamp(((ImGui::GetTime() - notify.time) - notify.maxTime) / animationOUT, 0.0, 1.0));

		const float alpha = in * (1.0f - out);
		notify.alpha = alpha;

		if (notify.alpha <= 0.0f)
		{
			m_allNotifies.erase(m_allNotifies.begin() + i);
			continue;
		}

		char name[15];
		ImFormatString(name, IM_ARRAYSIZE(name), "##UNIQUE%i", i);
		ImGui::SetNextWindowBgAlpha(alpha);

		const float initX = screenSize.x - fineClip;
		const float xAnimated = in * initX + out * initX;
		ImGui::SetNextWindowPos(ImVec2{ xAnimated, height + fineClip }, ImGuiCond_Always, ImVec2{ 1.0f, 0.0f });
		ImGui::Begin(name, nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoInputs
			| ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoFocusOnAppearing);
		{
			ImGui::PushTextWrapPos(widthRect);

			ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetColorU32(ImGuiCol_Text, alpha));
			ImGui::TextUnformatted(notify.title.c_str());
			ImGui::Separator();
			ImGui::TextUnformatted(notify.message.c_str());

			ImGui::PopStyleColor();

			ImGui::PopTextWrapPos();
		}

		height += (ImGui::GetWindowHeight() + fineClip) * alpha;

		ImGui::End();

		i++;
	}
}

void ImNotify::add(const ImNotify& notify)
{
	m_allNotifies.push_back(notify);
}

void ImGui::HelpMarker(const char* desc)
{
	ImGui::TextDisabled("(?)");
	if (ImGui::IsItemHovered())
	{
		ImGui::BeginTooltip();
		ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
		ImGui::TextUnformatted(desc);
		ImGui::PopTextWrapPos();
		ImGui::EndTooltip();
	}
}

#include <config/cfgcolor.hpp>

#include <config/vars.hpp>
#include <unordered_map>
#include <render/render.hpp>
#include <deps/ImGui/extraDraw.hpp>

static std::unordered_map<ImGuiID, std::pair<ImVec2, ImVec2>> m_mapSizes = {};
static const char* g_GroupPanelName = nullptr;
static ImVector<ImRect> s_GroupPanelLabelStack;

void ImGui::BeginGroupPanel(const char* name, const ImVec2& size)
{
	g_GroupPanelName = name;

	auto id = ImGui::GetCurrentWindow()->GetID(name);
	auto [min, max] = m_mapSizes[id];

	ImGui::ExtraDrawlist::AddRectFilledMultiColor(
		ImGui::GetWindowDrawList(),
		min, max,
		Color::U32(vars::styling->groupPanelBackground[0]()),
		Color::U32(vars::styling->groupPanelBackground[1]()),
		Color::U32(vars::styling->groupPanelBackground[2]()),
		Color::U32(vars::styling->groupPanelBackground[3]()),
		ImGui::GetStyle().FrameRounding
	);

	ImGui::BeginGroup();

	auto cursorPos = ImGui::GetCursorScreenPos();
	auto itemSpacing = ImGui::GetStyle().ItemSpacing;
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));

	auto frameHeight = ImGui::GetFrameHeight();
	ImGui::BeginGroup();

	ImVec2 effectiveSize = size;
	if (size.x < 0.0f)
		effectiveSize.x = ImGui::GetContentRegionAvail().x;
	else
		effectiveSize.x = size.x;
	ImGui::Dummy(ImVec2(effectiveSize.x, 0.0f));

	ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
	ImGui::SameLine(0.0f, 0.0f);
	ImGui::BeginGroup();
	ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
	ImGui::SameLine(0.0f, 0.0f);
	ImGui::PushFont(ImRender::fonts::tahoma20);
	ImGui::TextUnformatted(name);
	ImGui::PopFont();
	auto labelMin = ImGui::GetItemRectMin();
	auto labelMax = ImGui::GetItemRectMax();
	ImGui::SameLine(0.0f, 0.0f);
	ImGui::Dummy(ImVec2(0.0, frameHeight + itemSpacing.y));
	ImGui::BeginGroup();

	//ImGui::GetWindowDrawList()->AddRect(labelMin, labelMax, IM_COL32(255, 0, 255, 255));

	ImGui::PopStyleVar(2);

	ImGui::GetCurrentWindow()->ContentRegionRect.Max.x -= frameHeight * 0.5f;
	ImGui::GetCurrentWindow()->WorkRect.Max.x -= frameHeight * 0.5f;
	ImGui::GetCurrentWindow()->InnerRect.Max.x -= frameHeight * 0.5f;

	ImGui::GetCurrentWindow()->Size.x -= frameHeight;

	auto itemWidth = ImGui::CalcItemWidth();
	ImGui::PushItemWidth(ImMax(0.0f, itemWidth - frameHeight));

	s_GroupPanelLabelStack.push_back(ImRect(labelMin, labelMax));
}

void ImGui::EndGroupPanel()
{
	ImGui::PopItemWidth();

	auto itemSpacing = ImGui::GetStyle().ItemSpacing;

	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));

	auto frameHeight = ImGui::GetFrameHeight();

	ImGui::EndGroup();

	//ImGui::GetWindowDrawList()->AddRectFilled(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(0, 255, 0, 64), 4.0f);

	ImGui::EndGroup();

	ImGui::SameLine(0.0f, 0.0f);
	ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
	ImGui::Dummy(ImVec2(0.0, frameHeight - frameHeight * 0.5f - itemSpacing.y));

	ImGui::EndGroup();

	auto itemMin = ImGui::GetItemRectMin();
	auto itemMax = ImGui::GetItemRectMax();
	//ImGui::GetWindowDrawList()->AddRectFilled(itemMin, itemMax, IM_COL32(255, 0, 0, 64), 4.0f);

	auto labelRect = s_GroupPanelLabelStack.back();
	s_GroupPanelLabelStack.pop_back();

	ImVec2 halfFrame = ImVec2(frameHeight * 0.25f, frameHeight) * 0.5f;
	ImRect frameRect = ImRect(itemMin + halfFrame, itemMax + ImVec2{ 0.0f, 2.0f });
	labelRect.Min.x -= itemSpacing.x;
	labelRect.Max.x += itemSpacing.x;
	const auto colorLine = Color::U32(vars::styling->groupPanelLines());
	for (int i = 0; i < 4; ++i)
	{
		switch (i)
		{
			// left half-plane
		case 0: ImGui::PushClipRect(ImVec2(-FLT_MAX, -FLT_MAX), ImVec2(labelRect.Min.x, FLT_MAX), true); break;
			// right half-plane
		case 1: ImGui::PushClipRect(ImVec2(labelRect.Max.x, -FLT_MAX), ImVec2(FLT_MAX, FLT_MAX), true); break;
			// top
		case 2: ImGui::PushClipRect(ImVec2(labelRect.Min.x, -FLT_MAX), ImVec2(labelRect.Max.x, labelRect.Min.y), true); break;
			// bottom
		case 3: ImGui::PushClipRect(ImVec2(labelRect.Min.x, labelRect.Max.y), ImVec2(labelRect.Max.x, FLT_MAX), true); break;
		}

		ImGui::GetWindowDrawList()->AddRect(
			frameRect.Min, frameRect.Max,
			colorLine,
			ImGui::GetStyle().FrameRounding);

		ImGui::PopClipRect();
	}

	auto id = ImGui::GetCurrentWindow()->GetID(g_GroupPanelName);

	auto [itr, emplaced] = m_mapSizes.try_emplace(id, std::make_pair(frameRect.Min, frameRect.Max));
	if (!emplaced)
		itr->second = std::make_pair(frameRect.Min, frameRect.Max);

	ImGui::PopStyleVar(2);

	ImGui::GetCurrentWindow()->ContentRegionRect.Max.x += frameHeight * 0.5f;
	ImGui::GetCurrentWindow()->WorkRect.Max.x += frameHeight * 0.5f;
	ImGui::GetCurrentWindow()->InnerRect.Max.x += frameHeight * 0.5f;

	ImGui::GetCurrentWindow()->Size.x += frameHeight;

	ImGui::Dummy(ImVec2(0.0f, 0.0f));

	ImGui::EndGroup();
}

void ImGui::LoadCustomSettings()
{
	ImGuiContext& g = *GImGui;
	for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
	{
		const ImVec2 pos = ImVec2{ static_cast<float>(settings->Pos.x), static_cast<float>(settings->Pos.y) };
		const ImVec2 size = ImVec2{ static_cast<float>(settings->Size.x), static_cast<float>(settings->Size.y) };

		//std::cout << "name : " << settings->GetName() << " Size " << size.x << " " << size.y << '\n';
		
		extraGlobals::settings[ImGui::GetID(settings->GetName())] =
			ImWindowSettings
		{
			.id = settings->ID,
			.pos = pos + (size / 2),
			.size = ImVec2{},
			.targetSize = size,
			.alpha = 0.0f
		};
	}
}

// leaving this, because it might be helpful
static void RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float angle, float scale)
{
	const float h = draw_list->_Data->FontSize * 1.00f;
	float r = h * 0.40f * scale;
	ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);
	ImVec2 a, b, c;

	const float cangle = ImCos(angle);
	const float sangle = ImSin(angle);

	switch (dir)
	{
	case ImGuiDir_Up:
	case ImGuiDir_Down:
		if (dir == ImGuiDir_Up) r = -r;
		a = ImRotate(ImVec2(+0.000f, +0.750f), cangle, sangle) * r;
		b = ImRotate(ImVec2(-0.866f, -0.750f), cangle, sangle) * r;
		c = ImRotate(ImVec2(+0.866f, -0.750f), cangle, sangle) * r;
		break;
	case ImGuiDir_Left:
	case ImGuiDir_Right:
		if (dir == ImGuiDir_Left) r = -r;
		a = ImRotate(ImVec2(+0.750f, +0.000f), cangle, sangle) * r;
		b = ImRotate(ImVec2(-0.750f, +0.866f), cangle, sangle) * r;
		c = ImRotate(ImVec2(-0.750f, -0.866f), cangle, sangle) * r;
		break;
	case ImGuiDir_None:
	case ImGuiDir_COUNT:
		IM_ASSERT(0);
		break;
	}

	draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
}

bool ImGui::PopupButton(const char* label, const std::function<void()>& fun)
{
	ImGui::PushID(label);

	if (ImGui::Button("Options"))
		ImGui::OpenPopup("");

	bool ret = false;
	if (ImGui::BeginPopup(""))
	{
		fun();
		ret = true;

		ImGui::EndPopup();
	}

	ImGui::PopID();

	return ret;
}

bool ImGui::ColorPicker(const char* label, CfgColor* clr)
{
	constexpr auto pickerFlags = ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaBar;
	constexpr auto pickerButtonFlags = ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_AlphaPreview;
	constexpr auto paletteButoonFlags = ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_NoTooltip;

	bool toReturn = false;

	static std::array<Color, 32> palette = {};
	static auto bOnce = [=]()
	{
		for (size_t i = 0; auto & el : palette)
		{
			ImGui::ColorConvertHSVtoRGB(i / static_cast<float>(palette.size()), 1.0f, 1.0f,
				el.at(0), el.at(1), el.at(2));
			el.at(3) = 1.0f;

			i++;
		}
		return true;
	} ();

	ImGui::PushID(label);

	bool openPopup = ImGui::ColorButton("##colbut", ImVec4{ clr->getColor().r(), clr->getColor().g(), clr->getColor().b(), clr->getColor().a() }, pickerButtonFlags);

	if (std::strncmp(label, "##", 2))
	{
		ImGui::SameLine();
		ImGui::TextUnformatted(label, std::strstr(label, "##"));
	}

	if (openPopup)
		ImGui::OpenPopup("##colpop");

	if (ImGui::BeginPopup("##colpop"))
	{
		std::array col{ clr->getColor().r(), clr->getColor().g(), clr->getColor().b(), clr->getColor().a() };
		toReturn = ImGui::ColorPicker4("##colpicker", col.data(), pickerFlags);
		*clr = CfgColor{ col, clr->getRainbow(), clr->getSpeed() };

		ImGui::SameLine();

		constexpr int seperateLimit = 7;
		constexpr auto paletteButtonSize = ImVec2{ 20.0f, 20.0f };

		if (ImGui::BeginChild("##colorsaddon", { seperateLimit * paletteButtonSize.x, 0.0f }))
		{
			for (size_t i = 0; const auto & el : palette)
			{
				ImGui::PushID(i);
				if ((i % seperateLimit) != 0)
					ImGui::SameLine(0.0f, ImGui::GetStyle().ItemSpacing.y);

				if (ImGui::ColorButton("##palette", ImVec4{ el.r(), el.g(), el.b(), el.a() }, paletteButoonFlags, paletteButtonSize))
				{
					*clr = CfgColor{ Color{ el, clr->getColor().a() }, clr->getRainbow(), clr->getSpeed() };
					toReturn = true;
				}
				ImGui::PopID();

				i++;
			}

			ImGui::Checkbox("Rainbow mode", &clr->getRainbowRef());
			if (clr->getRainbow())
			{
				ImGui::PushItemWidth(seperateLimit * paletteButtonSize.x);
				ImGui::SliderFloat("##ranbowspeed", &clr->getSpeedRef(), 0.0f, 15.0f, "Speed %.1f", ImGuiSliderFlags_Logarithmic);
				ImGui::PopItemWidth();

				// apply return as updated color
				toReturn = true;
			}

			ImGui::EndChild();
		}

		ImGui::EndPopup();

	}
	ImGui::PopID();

	return toReturn;
}

// because some update made stack for those items kinda different, I will use own non api-like solution to solve this
static std::unordered_map<ImGuiID, bool> stackHotkey;

bool ImGui::Hotkey(const char* label, Key* key, bool useExtended, const ImVec2& size)
{
	ImGui::PushID(label);
	if (std::strncmp(label, "##", 2))
		ImGui::TextUnformatted(label, std::strstr(label, "##"));

	ImGui::SameLine();
	const auto id = ImGui::GetID(label);

	bool isInHotkey = stackHotkey[id];

	if (isInHotkey)
	{
		ImGui::Button("...", size);
		ImGui::SetItemAllowOverlap();

		if (key->checkKey())
		{
			globals::isInHotkey = false;
			stackHotkey[id] = false;
			ImGui::ClearActiveID();
		}

	}
	else if (ImGui::Button(utilities::getKeyName(key->getKeyCode()).c_str(), size))
	{
		globals::isInHotkey = true;
		stackHotkey[id] = true;
		ImGui::SetActiveID(id, GetCurrentWindow());
	}

	if (useExtended)
	{
		if (ImGui::BeginPopup("##pop", ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove))
		{
			for (const auto [mode, name] : Key::getKeyPairs())
			{
				bool selected = key->getKeyMode() == mode;
				if (ImGui::Selectable(name, &selected))
				{
					if (selected)
						key->setKeyMode(mode);
				}
			}

			ImGui::EndPopup();
		}
		if (IsItemHovered())
		{
			ImGui::SetTooltip("Key mode");

			if (ImGui::GetIO().MouseClicked[1])
				ImGui::OpenPopup("##pop");
		}
	}

	ImGui::PopID();

	return true;
}

void ImGui::Window(const char* label, bool* opened, const ImGui::WindowConfig& config, const std::function<void()>& callback)
{
	const ImGuiID id = ImGui::GetID(label);
	ImGuiIO& io = ImGui::GetIO();

	auto itr = ImGui::extraGlobals::settings.find(id);
	const bool newWindow = itr == ImGui::extraGlobals::settings.end();
	if (newWindow)
	{
		ImGui::extraGlobals::settings[id] = ImWindowSettings
		{
			.id = id,
			.pos = config.defaultPos + (config.defaultSize / 2),
			.size = ImVec2{ 0, 0 },
			.targetSize = config.defaultSize,
			.alpha = 0.0f
		};
		// force itr to be updated
		itr = ImGui::extraGlobals::settings.find(id);
	}

	auto inTransmission = [opened, config, itr](const auto min, const auto max)
	{
		constexpr float lerpThreshold = 0.01f;

		if (itr->second.alpha >= max - lerpThreshold)
			return false;

		if (itr->second.alpha <= min + lerpThreshold)
			return false;

		return true;
	};

	auto isMovedWindow = [id]()
	{
		const ImGuiWindow* movingWindow = GImGui->MovingWindow;
		if (movingWindow == nullptr)
			return false;

		/*if (movingWindow->ID != id)
			return false;*/

		return true;
	};

	auto isResizedWindow = []()
	{
		for (int i = 0; i < 4; i++)
		{
			if (ImGui::GetWindowResizeCornerID(ImGui::GetCurrentWindow(), i) != ImGui::GetActiveID())
				continue;

			return true;
		}

		for (int i = 0; i < 4; i++)
		{
			if (ImGui::GetWindowResizeBorderID(ImGui::GetCurrentWindow(), i) != ImGui::GetActiveID())
				continue;

			return true;
		}

		return false;
	};


	auto renderGui = [&](ImGuiWindowFlags flags)
	{
		if (ImGui::Begin(label, opened, flags))
		{
			// cant perfectly know when lerp ended, this is enough
			/*if (const auto size = ImGui::GetWindowSize(); size.x > 35 && size.y > 35)
				io.IniFilename = menu.m_iniFile.c_str();*/

			ImGui::GetForegroundDrawList()->AddCircleFilled(ImGui::GetWindowPos(), 10, ImColor{ 255, 60, 255, 255 }, 18);

			const bool sizeChanged = isResizedWindow();
			const bool posChanged = isMovedWindow();

			if (sizeChanged || posChanged)
			{
				itr->second.targetSize = ImGui::GetWindowSize();
				itr->second.pos = ImGui::GetWindowPos() + itr->second.targetSize / 2;

				//ImGui::SaveIniSettingsToDisk(menu.m_iniFile.c_str());
			}

			callback();

			ImGui::End();
		}
	};

#ifdef _DEBUG
	//ImGui::GetForegroundDrawList()->AddCircleFilled(itr->second.pos, 10, ImColor{ 0, 60, 255, 255 }, 18);
#endif

	ImGuiStyle& style = ImGui::GetStyle();
	//const ImGuiStyle& backupStyle = style;

	constexpr float min = 0.0f, max = 1.0f;
	const float wantedAlpha = *opened ? max : min;
	//const float step = ImGui::GetIO().DeltaTime * 4.0f;
	itr->second.alpha = ImLerp(itr->second.alpha, wantedAlpha, ImGui::GetIO().DeltaTime * 10.0f);
	//itr->second.alpha = ImClamp(itr->second.alpha + (*opened ? step : -step), min, max);
	//itr->second.size = itr->second.targetSize * itr->second.alpha
	const ImVec2 target = *opened ? itr->second.targetSize : ImVec2{ 0, 0 };
	// 14 is passed to accelrate the lerping steps, so the inTransmission check can work well enough
	itr->second.size = ImLerp(itr->second.size, target, ImGui::GetIO().DeltaTime * 14.0f);

	ImGui::GetForegroundDrawList()->AddCircleFilled(itr->second.pos, 10, ImColor{ 0, 60, 255, 255 }, 18);

	if (inTransmission(min, max))
	{
		io.IniFilename = nullptr;

		for (int i = 0; i < ImGuiCol_COUNT; ++i)
		{
			ImVec4 color = style.Colors[i];
			color.w *= itr->second.alpha;
			ImGui::PushStyleColor(i, color);
		}

		ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, style.WindowBorderSize * itr->second.alpha);
		ImGui::PushStyleVar(ImGuiStyleVar_ScrollbarSize, style.ScrollbarSize * itr->second.alpha);

		ImGui::SetNextWindowPos(itr->second.pos, ImGuiCond_Always, ImVec2{ 0.5f, 0.5f });
		ImGui::SetNextWindowSize(itr->second.size);

		renderGui(ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize);

		ImGui::PopStyleColor(ImGuiCol_COUNT);

		ImGui::PopStyleVar(2);
		return;
	}
	if (*opened)
	{
		if (newWindow)
		{
			ImGui::SetNextWindowPos(itr->second.pos, ImGuiCond_Once);
			ImGui::SetNextWindowSize(itr->second.size);
		}

		renderGui(config.flags);
	}
}

#include <d3d9.h>

#ifdef IMGUI_USE_BGRA_PACKED_COLOR
#define IMGUI_COL_TO_DX9_ARGB(_COL)     (_COL)
#else
#define IMGUI_COL_TO_DX9_ARGB(_COL)     (((_COL) & 0xFF00FF00) | (((_COL) & 0xFF0000) >> 16) | (((_COL) & 0xFF) << 16))
#endif

struct ImGui_ImplDX9_Data
{
	LPDIRECT3DDEVICE9           pd3dDevice;
	LPDIRECT3DVERTEXBUFFER9     pVB;
	LPDIRECT3DINDEXBUFFER9      pIB;
	LPDIRECT3DTEXTURE9          FontTexture;
	int                         VertexBufferSize;
	int                         IndexBufferSize;

	ImGui_ImplDX9_Data() { memset(this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }
};

static ImGui_ImplDX9_Data* ImGui_ImplDX9_GetBackendData()
{
	return ImGui::GetCurrentContext() ? (ImGui_ImplDX9_Data*)ImGui::GetIO().BackendRendererUserData : NULL;
}

void* ImGui_CreateTexture(const void* data, int width, int height)
{
	ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();
	unsigned char* pixels;

	if (!bd || !bd->pd3dDevice || !data)
		return NULL;

	// Convert RGBA32 to BGRA32 (because RGBA32 is not well supported by DX9 devices)
#ifndef IMGUI_USE_BGRA_PACKED_COLOR
	ImU32* dst_start = (ImU32*)ImGui::MemAlloc((size_t)width * height * 4);
	for (ImU32* src = (ImU32*)data, *dst = dst_start, *dst_end = dst_start + (size_t)width * height; dst < dst_end; src++, dst++)
		*dst = IMGUI_COL_TO_DX9_ARGB(*src);
	pixels = (unsigned char*)dst_start;
#endif

	LPDIRECT3DTEXTURE9 temp;
	if (bd->pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_SYSTEMMEM, &temp, NULL) < 0)
		return NULL;
	D3DLOCKED_RECT tex_locked_rect;
	if (temp->LockRect(0, &tex_locked_rect, NULL, D3DLOCK_DISCARD) != D3D_OK)
	{
		temp->Release();
		return NULL;
	}
	for (int y = 0; y < height; ++y)
		memcpy((unsigned char*)tex_locked_rect.pBits + tex_locked_rect.Pitch * y, pixels + (width * 4) * y, (width * 4));
	temp->UnlockRect(0);

	LPDIRECT3DTEXTURE9 texture;
	if (bd->pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &texture, NULL) != D3D_OK)
	{
		temp->Release();
		return NULL;
	}
	bd->pd3dDevice->UpdateTexture(temp, texture);
	temp->Release();

#ifndef IMGUI_USE_BGRA_PACKED_COLOR
	ImGui::MemFree(pixels);
#endif

	return texture;
}

void ImGui_DestroyTexture(void* texture)
{
	IM_ASSERT(texture != NULL && "passed texture to destroy was null!");
	reinterpret_cast<IDirect3DTexture9*>(texture)->Release();
}
```

`hack/menu/GUI-ImGui/imguiaddons.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <functional>

#include <imgui.h>

class CfgColor;
class Color;
class Key;

struct ImNotify
{
    ImNotify() = default;
    ImNotify(double maxTime, const std::string& title, const std::string& message)
        : maxTime{ maxTime }, title{ title }, message{ message }
    {
        time = ImGui::GetTime();
    }

    double maxTime;
    std::string title;
    std::string message;
    double time;
    float alpha;

    static void handle();
    static void add(const ImNotify& notify);
    inline static std::vector<ImNotify> m_allNotifies;
};

// ImGuiWindowSettings wrapper
struct ImWindowSettings
{
    ImGuiID id;
    ImVec2 pos, size;
    ImVec2 targetSize;
    float alpha;
};

namespace ImGui
{
	// from demo
	void HelpMarker(const char* desc);
	// from widgets, https://github.com/ocornut/imgui/issues/1496#issuecomment-569892444
	void BeginGroupPanel(const char* name, const ImVec2& size = { 0.0f, 0.0f });
	void EndGroupPanel();

	template<class T>
	concept dataLike = requires(T t)
	{
		t.size();
		t.data();
		t.begin();
		t.end();
	};

	// heavily based on code from demo, look "palette" in imgui demo file
	bool ColorPicker(const char* label, CfgColor* clr);
	bool PopupButton(const char* label, const std::function<void()>& fun);
	bool Hotkey(const char* label, Key* key, bool useExtended = true, const ImVec2& size = { 0.0f, 0.0f });
	template<dataLike T>
	bool Combo(const char* label, int* item, const T& data, int height_in_items = -1);
	template<dataLike T>
	bool ListBox(const char* label, int* item, const T& data, int height_in_items = -1);
	template<typename T, size_t SIZE>
	requires (SIZE > 0U)
	void MultiCombo(const char* label, const std::array<T, SIZE>& names, std::array<bool, SIZE>* options);
	struct WindowConfig
	{
		ImGuiWindowFlags flags{ 0 };

		// will only work at the very first start, later it will be saved in config
		ImVec2 defaultPos, defaultSize;
	};

	// DONT USE NOW, this is working, but saving is completely broken with this
	// reasoning is:
	// I find using ImGuiStorage for this painfull
	// This manipulates how imgui originally should handle stack window openinig/closing.
	void Window(const char* label, bool* opened, const WindowConfig& config, const std::function<void()>& callback);

    void LoadCustomSettings();
    namespace extraGlobals
    {
        inline std::unordered_map<ImGuiID, ImWindowSettings> settings;
    }
}

template<typename T, size_t SIZE>
requires (SIZE > 0U)
void ImGui::MultiCombo(const char* label, const std::array<T, SIZE>& names, std::array<bool, SIZE>* options)
{
	ImVector<T> actives = {};
	for (size_t i = 0; const auto el : *options)
	{
		if (el) // if active selected
			actives.push_back(names[i]);

		i++;
	}

	std::string previewName = "";
	for (int i = 0; const auto & el : actives)
	{
		previewName += el;

		if (i < actives.size() - 1) // add ", " on every option but not last
			previewName += ", ";

		i++;
	}

	if (ImGui::BeginCombo(label, previewName.c_str()))
	{
		for (size_t i = 0; i < SIZE; i++) // creating view to make it "forced" to detect it as valid function args
		{
			if (ImGui::Selectable(std::string_view{ names[i] }.data(), options->at(i), ImGuiSelectableFlags_DontClosePopups))
				options->at(i) = !options->at(i);
		}

		ImGui::EndCombo();
	}
}

template<ImGui::dataLike T>
bool ImGui::Combo(const char* label, int* item, const T& data, int height_in_items)
{
	using typeContainer = typename std::decay<decltype(*data.begin())>::type;

	auto getter_arr = [](void* data, int idx, const char** out)
	{
		auto& v = *static_cast<T*>(data);

		if (out)
		{
			if constexpr (std::is_same_v<typeContainer, std::string>)
				*out = v[idx].c_str();
			else if constexpr (std::is_same_v<typeContainer, std::string_view>)
				*out = v[idx].data();
			else
				*out = v[idx];
		}
		return true;
	};

	return ImGui::Combo(label, item, getter_arr, const_cast<void*>(reinterpret_cast<const void*>(&data)), data.size(), height_in_items);
}

template<ImGui::dataLike T>
bool ImGui::ListBox(const char* label, int* item, const T& data, int height_in_items)
{
	using typeContainer = typename std::decay<decltype(*data.begin())>::type;

	auto getter_arr = [](void* data, int idx, const char** out)
	{
		auto& v = *static_cast<T*>(data);

		if (out)
		{
			if constexpr (std::is_same_v<typeContainer, std::string>)
				*out = v[idx].c_str();
			else if constexpr (std::is_same_v<typeContainer, std::string_view>)
				*out = v[idx].data();
			else
				*out = v[idx];
		}
		return true;
	};

	return ImGui::ListBox(label, item, getter_arr, const_cast<void*>(reinterpret_cast<const void*>(&data)), data.size(), height_in_items);
}



IMGUI_IMPL_API void* ImGui_CreateTexture(const void* data, int width, int height);
IMGUI_IMPL_API void ImGui_DestroyTexture(void* texture);
```

`hack/menu/GUI-ImGui/menu.cpp`:

```cpp
#include "menu.hpp"

#include "tabrender.hpp"
#include "sections/combat/aim.hpp"
#include "sections/visuals/visuals.hpp"
#include "sections/editors/editors.hpp"
#include "sections/misc/misc.hpp"
#include "sections/settings/settings.hpp"

#include <config/vars.hpp>
#include <config/config.hpp>
#include <SDK/InputSystem.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include <cheats/hooks/wndproc.hpp>
#include <cheats/hooks/present.hpp>

namespace
{
	struct MenuDraw : hooks::Present
	{
		MenuDraw()
		{
			this->registerRun(ImGuiMenu::draw);
		}
	} menuDraw;

	struct MenuKeys : hooks::wndProcSys
	{
		MenuKeys()
		{
			this->registerRun(ImGuiMenu::updateKeys);
		}
	} menuKeys;
}

namespace ImGuiMenu
{
	void updateKeys();

	std::string iniFile{ };
	static constexpr auto menuTitle{ "csgo legit" };
}

void ImGuiMenu::updateKeys()
{
	if (vars::keys->menu.isPressed())
	{
		active = !active;

		if (!active)
			memory::interfaces::iSystem->resetState();
	}
}

void ImGuiMenu::setStyles()
{
	ImGuiIO& io = ImGui::GetIO();
	ImGuiStyle& style = ImGui::GetStyle();

	style = vars::styling->imStyle;

	iniFile = std::filesystem::path{ api::getHackPath() / "window.ini" }.string();

	io.IniFilename = iniFile.c_str();
	io.LogFilename = nullptr;
}

static std::array allTabs =
{
	TabRender{ "Aimbot", &tabs::aim::draw },
	TabRender{ "Visuals", &tabs::visuals::draw },
	TabRender{ "Misc", &tabs::misc::draw },
	TabRender{ "Settings", &tabs::settings::draw },
	TabRender{ "Editors", &tabs::editors::draw },
};

void ImGuiMenu::draw()
{
	if (!active)
		return;

	if (ImGui::Begin(menuTitle, &active, ImGuiWindowFlags_NoCollapse))
	{
		ImGuiStyle& style = ImGui::GetStyle();
		ImVec2 backupPadding = style.FramePadding;
		const float width = ImGui::GetContentRegionAvail().x;

		// remove tab underline
		ImGui::PushStyleColor(ImGuiCol_TabActive, Color::U32(Colors::Blank));
		ImGui::PushStyleColor(ImGuiCol_TabUnfocusedActive, Color::U32(Colors::Blank));

		if (ImGui::BeginTabBar("tabbar", ImGuiTabBarFlags_Reorderable))
		{
			style.FramePadding = { width / allTabs.size(), backupPadding.y }; // still this is clamped by imgui in tabs
			ImGui::PopStyleColor(2);
			for (const auto& el : allTabs)
			{
				if (ImGui::BeginTabItem(el.m_name))
				{
					style.FramePadding = backupPadding;
					if (el.funcExist())
						el.m_func();

					ImGui::EndTabItem();
				}
			}
			ImGui::EndTabBar();
		}
	}
	ImGui::End();
}
```

`hack/menu/GUI-ImGui/menu.hpp`:

```hpp
#pragma once

namespace ImGuiMenu
{
	void draw();
	void updateKeys();
	void setStyles();

	inline bool active{ true };
};
```

`hack/menu/GUI-ImGui/sections/background.cpp`:

```cpp
#include "background.hpp"

#include "../menu.hpp"

#include <imgui.h>
#include <cheats/game/globals.hpp>
#include <utilities/utilities.hpp>
#include <utilities/rand.hpp>
#include <config/vars.hpp>

#include <cheats/hooks/present.hpp>

namespace
{
	struct BackgroundHandle : hooks::Present
	{
		BackgroundHandle()
		{
			this->registerRun(background::draw);
		}
	} backgroundHandle;
}

namespace background
{
	void pushRandomPoints();
	void update(ParticlePoint_t& particle);
	void find(ParticlePoint_t& particle);

	void drawLine(const Vec2& start, const Vec2& end, const Color& color, float thickness = 1.0f);
	void drawCircleFilled(const Vec2& pos, float radius, size_t points, const Color& color);
	void drawRectFilled(float x, float y, float width, float height, const Color& color);

	size_t particlesCount; // how many particless
	float maxDistance; // dist between

	std::vector<ParticlePoint_t> particles;
	std::vector<Color> colors;

	ImDrawList* ImDraw;
}

void background::drawLine(const Vec2& start, const Vec2& end, const Color& color, float thickness)
{
	ImDraw->AddLine(ImVec2{ start[Coord::X], start[Coord::Y] }, ImVec2{ end[Coord::X], end[Coord::Y] }, Color::U32(color), thickness);
}

void background::drawCircleFilled(const Vec2& pos, float radius, size_t points, const Color& color)
{
	ImDraw->AddCircleFilled(ImVec2{ pos[Coord::X], pos[Coord::Y] }, radius, Color::U32(color), points);
}

void background::drawRectFilled(float x, float y, float width, float height, const Color& color)
{
	ImDraw->AddRectFilled(ImVec2{ x, y }, ImVec2{ x + width, y + height }, Color::U32(color));
}

void background::init()
{
	particlesCount = static_cast<size_t>(vars::styling->size);
	maxDistance = vars::styling->distance;
	colors =
	{
		vars::styling->color1(),
		vars::styling->color2(),
		vars::styling->color3()
	};

	pushRandomPoints();
}

void background::pushRandomPoints()
{
	particles.clear();

	float speed = vars::styling->speed;
	for (size_t i = 0; i < particlesCount; i++)
	{
		particles.emplace_back(
			ParticlePoint_t
			{
				Vec2{ static_cast<float>(Random::getRandom<size_t>(0, globals::screenX)), static_cast<float>(Random::getRandom<size_t>(0, globals::screenY)) }, // pos
				Vec2{ Random::getRandom<float>(-0.1f, 0.1f) * speed, Random::getRandom<float>(-0.1f, 0.1f) * speed }, // move
				Color	{ colors.at(Random::getRandom<size_t>(0, colors.size() - 1)) } // color
			});
	}
}

void background::update(ParticlePoint_t& particle)
{
	// not working perfectly
	/*const auto circlePos = Vec2{ float(globals::mouseX), float(globals::mouseY) };
	float distToCircle = particle.m_pos.distTo(circlePos);
	float circleRadius = 60.0f;
	drawCircleFilled(circlePos, circleRadius, 64, Colors::Green.getColorEditAlpha(0.1f));

	if (distToCircle < circleRadius)
	{
		auto alp = (circleRadius - distToCircle) / circleRadius;

		Vec2 dir = (particle.m_pos - circlePos) * alp;
		particle.m_pos += dir * (circleRadius - distToCircle) * 1.2f;

		particle.m_move = particle.m_move * -1.0f;
	}*/

	if (particle.m_pos[Coord::X] > globals::screenX || particle.m_pos[Coord::X] < 0)
		particle.m_move[Coord::X] = -particle.m_move[Coord::X];

	if (particle.m_pos[Coord::Y] > globals::screenY || particle.m_pos[Coord::Y] < 0)
		particle.m_move[Coord::Y] = -particle.m_move[Coord::Y];

	particle.m_pos += particle.m_move;
}

void background::find(ParticlePoint_t& particle)
{
	for (auto& el : particles)
	{
		if (const auto dis = particle.m_pos.distTo(el.m_pos); dis < maxDistance)
		{
			el.m_alpha = (maxDistance - dis) / maxDistance;
			drawLine(particle.m_pos, el.m_pos, particle.m_color.getColorEditAlpha(el.m_alpha));
		}
	}
}

void background::draw()
{
	if (globals::isShutdown)
		return;

	ImDraw = ImGui::GetBackgroundDrawList();

	if (!ImGuiMenu::active)
		return;

	if (!vars::styling->background)
		return;

	static std::once_flag onceFlag;
	std::call_once(onceFlag, []() { init(); });

	drawRectFilled(0.0f, 0.0f, static_cast<float>(globals::screenX), static_cast<float>(globals::screenY), Colors::Grey);

	for (auto& el : particles)
	{
		update(el);
		find(el);
		drawCircleFilled(el.m_pos, 2, 6, Colors::Black);
	}
}
```

`hack/menu/GUI-ImGui/sections/background.hpp`:

```hpp
#pragma once

#include <render/Color.hpp>
#include <SDK/math/Vector.hpp>

struct ParticlePoint_t
{
	Vec2 m_pos{ }; // actual pos to draw
	Vec2 m_move{ }; // how much to move the element +/- need small values!
	Color m_color{ };
	float m_alpha{ 1.0f };
};

namespace background
{
	void init();
	void draw();
};
```

`hack/menu/GUI-ImGui/sections/combat/aim.cpp`:

```cpp
#include "aim.hpp"

#include "../common.hpp"

void tabs::aim::draw()
{
	ImGuiStyle& style = ImGui::GetStyle();
	ImVec2 backupPadding = style.FramePadding;
	const float width = ImGui::GetContentRegionAvail().x;

	// remove tab underline
	ImGui::PushStyleColor(ImGuiCol_TabActive, Color::U32(Colors::Blank));
	ImGui::PushStyleColor(ImGuiCol_TabUnfocusedActive, Color::U32(Colors::Blank));

	if (ImGui::BeginTabBar("tabbaraim"))
	{
		const static auto weaponNames = magic_enum::enum_names_pretty<AimbotWeapon>();

		style.FramePadding = { width / weaponNames.size(), backupPadding.y }; // still this is clamped by imgui in tabs
		ImGui::PopStyleColor(2);

		for (size_t i = 0; const auto& name : weaponNames)
		{
			if (ImGui::BeginTabItem(name.c_str()))
			{
				style.FramePadding = backupPadding;

				auto& weapons = vars::aim->weapons;
				auto& cfg = weapons.at(i);

				ImGui::Columns(2, nullptr, false);

				ImGui::BeginGroupPanel("Aimbot", ImGui::GetContentRegionAvail());
				{
					ImGui::Checkbox("Enabled##aim", &cfg.enabled);

					ImGui::BeginDisabled(!cfg.enabled);

					ImGui::Checkbox("Use key", &cfg.useKey);
					ImGui::SameLine();
					ImGui::HelpMarker("Using key will let you select custom key and select states of it\nRecommended to use");
					if (cfg.useKey)
					{
						ImGui::SameLine();
						ImGui::Hotkey("Key##aim", &cfg.key);
					}

					ImGui::SliderFloat("Fov##aim", &cfg.fov, 0.0f, 50.0f, "%.3f", ImGuiSliderFlags_Logarithmic);
					ImGui::Combo("Hitboxes##aim", &cfg.aimSelection, magic_enum::enum_names_pretty<AimbotHitboxes>());
					ImGui::Combo("Method##aim", &cfg.methodAim, magic_enum::enum_names_pretty<AimbotMethod>());
					ImGui::Checkbox("Delay##aim", &cfg.aimDelay);
					if (cfg.aimDelay)
					{
						ImGui::SliderFloat("Delay ms##aim", &cfg.aimDelayVal, 0.0f, 400.0f);
					}
					ImGui::Checkbox("Aim at Backtrack", &cfg.aimBacktrack);
					ImGui::SameLine();
					ImGui::HelpMarker("Will aim at middle of records!");


					ImGui::SliderFloat("Multiply##aim", &cfg.frametimeMulttiply, 0.0f, 30.0f, "%.3f", ImGuiSliderFlags_Logarithmic);
					ImGui::SameLine();
					ImGui::HelpMarker("Scales with the frametime, more = faster");

					ImGui::Checkbox("Smoke check##Aimbot", &cfg.smokeCheck);
					ImGui::SliderFloat("Flash limit##Aimbot", &cfg.flashLimit, 0.0f, 255.0f);

					ImGui::EndDisabled();
				}
				ImGui::EndGroupPanel();

				ImGui::NextColumn();

				ImGui::BeginGroupPanel("Triggerbot", ImGui::GetContentRegionAvail());
				{
					ImGui::Checkbox("Enabled##trigger", &cfg.triggerbot);
					if (cfg.triggerbot)
					{
						ImGui::SliderFloat("Delay##trigger", &cfg.triggerbotDelay, 0.0f, 200.0f);
					}
				}
				ImGui::EndGroupPanel();

				ImGui::BeginGroupPanel("RCS", ImGui::GetContentRegionAvail());
				{
					ImGui::Checkbox("Enabled##RCS", &cfg.rcs);
					if (cfg.rcs)
					{
						ImGui::SliderFloat("Pitch##Rcsx", &cfg.rcsX, 0.0f, 1.0f);
						ImGui::SliderFloat("Yaw##Rcsy", &cfg.rcsY, 0.0f, 1.0f);
					}
				}
				ImGui::EndGroupPanel();

				ImGui::BeginGroupPanel("Extra", ImGui::GetContentRegionAvail());
				{
					ImGui::Checkbox("Backtrack##enabled", &vars::backtrack->enabled);
					ImGui::SliderFloat("Backtrack ms", &vars::backtrack->time, 0.0f, 200.0f);
					ImGui::Checkbox("Smoke check##Backtrack", &vars::backtrack->smoke);
					ImGui::SliderFloat("Flash limit##Backtrack", &vars::backtrack->flashLimit, 0.0f, 255.0f);
				}
				ImGui::EndGroupPanel();

				ImGui::BeginGroupPanel("Drawing", ImGui::GetContentRegionAvail());
				{
					ImGui::Checkbox("Draw fov", &vars::aimPaint->enabledFov);
					if (vars::aimPaint->enabledFov)
					{
						ImGui::SameLine();
						ImGui::ColorPicker("Color##fov", &vars::aimPaint->colorFov);
						ImGui::SameLine();
						ImGui::HelpMarker("Draws a circle representing your aimbot FOV");
						ImGui::Checkbox("Draw aimbot point", &vars::aimPaint->enabledPoint);
						ImGui::SameLine();
						ImGui::ColorPicker("Color##bestpoint", &vars::aimPaint->colorPoint);
					}
				}
				ImGui::EndGroupPanel();

				ImGui::Columns();


				ImGui::EndTabItem();
			}

			i++;
		}

		ImGui::EndTabBar();
	}
}
```

`hack/menu/GUI-ImGui/sections/combat/aim.hpp`:

```hpp
#pragma once

namespace tabs::aim
{
	void draw();
}
```

`hack/menu/GUI-ImGui/sections/common.hpp`:

```hpp
#pragma once

#include "../imguiaddons.hpp"

#include <render/render.hpp>
#include <render/fonts/icon.hpp>
#include <config/vars.hpp>
#include <deps/magic_enum/prettyNames.hpp>
```

`hack/menu/GUI-ImGui/sections/editors/chamsEditor.cpp`:

```cpp
#include "chamsEditor.hpp"

#include <cheats/features/visuals/chams/editor.hpp>

void chamsEditor::draw()
{
	materialEditor::draw();
}
```

`hack/menu/GUI-ImGui/sections/editors/chamsEditor.hpp`:

```hpp
#pragma once

namespace chamsEditor
{
	void draw();
}
```

`hack/menu/GUI-ImGui/sections/editors/editors.cpp`:

```cpp
#include "editors.hpp"

#include "../common.hpp"
#include "../../tabrender.hpp"
#include "chamsEditor.hpp"
#include "styleEditor.hpp"

#include <cheats/features/visuals/chams/editor.hpp>

std::array allTabs
{
	TabRender{ "Chams", &chamsEditor::draw },
	TabRender{ "Menu style", &styleEditor::draw }
};

void tabs::editors::draw()
{
	ImGuiStyle& style = ImGui::GetStyle();
	ImVec2 backupPadding = style.FramePadding;
	const float width = ImGui::GetContentRegionAvail().x;

	// remove tab underline
	ImGui::PushStyleColor(ImGuiCol_TabActive, Color::U32(Colors::Blank));
	ImGui::PushStyleColor(ImGuiCol_TabUnfocusedActive, Color::U32(Colors::Blank));

	if (ImGui::BeginTabBar("tabbareditor"))
	{
		style.FramePadding = { width / allTabs.size(), backupPadding.y }; // still this is clamped by imgui in tabs
		ImGui::PopStyleColor(2);

		for (size_t i = 0; const auto & tab : allTabs)
		{
			if (ImGui::BeginTabItem(tab.m_name))
			{
				style.FramePadding = backupPadding;

				if (tab.funcExist())
					tab.m_func();

				ImGui::EndTabItem();
			}
		}
		ImGui::EndTabBar();
	}
}

```

`hack/menu/GUI-ImGui/sections/editors/editors.hpp`:

```hpp
#pragma once

namespace tabs::editors
{
	void draw();
}
```

`hack/menu/GUI-ImGui/sections/editors/styleEditor.cpp`:

```cpp
#include "styleEditor.hpp"

#include "../common.hpp"
#include "../background.hpp"

#include <imgui_freetype.h>
#include <imgui_internal.h>

void styleEditor::draw()
{
	// You can pass in a reference ImGuiStyle structure to compare to, revert to and save to
	// (without a reference style pointer, we will use one compared locally as a reference)
	ImGuiStyle& style = ImGui::GetStyle();
	static ImGuiStyle ref_saved_style = style;
	ImGuiStyle* ref = &ref_saved_style;
	// ugly methods for custom colors, TODO: do own struct for this
	static auto ref_saved_gradient = vars::styling->groupPanelBackground;
	static auto ref_saved_color_panel_line = vars::styling->groupPanelLines;

	ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.50f);

	ImGui::Checkbox("Background", &vars::styling->background);
	ImGui::SliderFloat("Background speed", &vars::styling->speed, 1.0f, 8.0f);
	ImGui::SliderFloat("Background max dist", &vars::styling->distance, 10.0f, 400.0f);
	ImGui::SliderInt("Background amount of records", &vars::styling->size, 20, 400);
	ImGui::Text("They are temp limited with dynamic size + saving!");
	ImGui::ColorPicker("Background color1", &vars::styling->color1);
	ImGui::SameLine();
	ImGui::ColorPicker("Background color2", &vars::styling->color2);
	ImGui::SameLine();
	ImGui::ColorPicker("Background color3", &vars::styling->color3);
	if (ImGui::Button("Refresh background"))
		background::init();

	if (ImGui::ShowStyleSelector("Colors##Selector"))
		ref_saved_style = style;
	ImGui::ShowFontSelector("Fonts##Selector");

	// Simplified Settings (expose floating-pointer border sizes as boolean representing 0.0f or 1.0f)
	if (ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f"))
		style.GrabRounding = style.FrameRounding; // Make GrabRounding always the same value as FrameRounding
	{ bool border = (style.WindowBorderSize > 0.0f); if (ImGui::Checkbox("WindowBorder", &border)) { style.WindowBorderSize = border ? 1.0f : 0.0f; } }
	ImGui::SameLine();
	{ bool border = (style.FrameBorderSize > 0.0f);  if (ImGui::Checkbox("FrameBorder", &border)) { style.FrameBorderSize = border ? 1.0f : 0.0f; } }
	ImGui::SameLine();
	{ bool border = (style.PopupBorderSize > 0.0f);  if (ImGui::Checkbox("PopupBorder", &border)) { style.PopupBorderSize = border ? 1.0f : 0.0f; } }

	// Save/Revert button
	if (ImGui::Button("Save Ref"))
		*ref = ref_saved_style = style;
	ImGui::SameLine();
	if (ImGui::Button("Revert Ref"))
		style = *ref;
	ImGui::SameLine();
	ImGui::HelpMarker(
		"Save/Revert in local non-persistent storage. Default Colors definition are not affected. "
		"Use \"Export\" below to save them somewhere.");

	ImGui::Separator();

	if (ImGui::BeginTabBar("##tabs", ImGuiTabBarFlags_None))
	{
		if (ImGui::BeginTabItem("Sizes"))
		{
			bool changedbut = false; // small optimazation for stack. Won't be huge, just less copying
			ImGui::Text("Main");
			changedbut |= ImGui::SliderFloat2("WindowPadding", (float*)&style.WindowPadding, 0.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat2("FramePadding", (float*)&style.FramePadding, 0.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat2("CellPadding", (float*)&style.CellPadding, 0.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat2("ItemSpacing", (float*)&style.ItemSpacing, 0.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat2("ItemInnerSpacing", (float*)&style.ItemInnerSpacing, 0.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat2("TouchExtraPadding", (float*)&style.TouchExtraPadding, 0.0f, 10.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("IndentSpacing", &style.IndentSpacing, 0.0f, 30.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("ScrollbarSize", &style.ScrollbarSize, 1.0f, 20.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("GrabMinSize", &style.GrabMinSize, 1.0f, 20.0f, "%.0f");
			ImGui::Text("Borders");
			changedbut |= ImGui::SliderFloat("WindowBorderSize", &style.WindowBorderSize, 0.0f, 1.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("ChildBorderSize", &style.ChildBorderSize, 0.0f, 1.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("PopupBorderSize", &style.PopupBorderSize, 0.0f, 1.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("FrameBorderSize", &style.FrameBorderSize, 0.0f, 3.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("TabBorderSize", &style.TabBorderSize, 0.0f, 1.0f, "%.0f");
			ImGui::Text("Rounding");
			changedbut |= ImGui::SliderFloat("WindowRounding", &style.WindowRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("ChildRounding", &style.ChildRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("PopupRounding", &style.PopupRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("ScrollbarRounding", &style.ScrollbarRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("GrabRounding", &style.GrabRounding, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("LogSliderDeadzone", &style.LogSliderDeadzone, 0.0f, 12.0f, "%.0f");
			changedbut |= ImGui::SliderFloat("TabRounding", &style.TabRounding, 0.0f, 12.0f, "%.0f");
			ImGui::Text("Alignment");
			changedbut |= ImGui::SliderFloat2("WindowTitleAlign", (float*)&style.WindowTitleAlign, 0.0f, 1.0f, "%.2f");
			int window_menu_button_position = style.WindowMenuButtonPosition + 1;
			if (changedbut |= ImGui::Combo("WindowMenuButtonPosition", (int*)&window_menu_button_position, "None\0Left\0Right\0"))
				style.WindowMenuButtonPosition = window_menu_button_position - 1;
			changedbut |= ImGui::Combo("ColorButtonPosition", (int*)&style.ColorButtonPosition, "Left\0Right\0");
			changedbut |= ImGui::SliderFloat2("ButtonTextAlign", (float*)&style.ButtonTextAlign, 0.0f, 1.0f, "%.2f");
			ImGui::SameLine(); ImGui::HelpMarker("Alignment applies when a button is larger than its text content.");
			changedbut |= ImGui::SliderFloat2("SelectableTextAlign", (float*)&style.SelectableTextAlign, 0.0f, 1.0f, "%.2f");
			ImGui::SameLine(); ImGui::HelpMarker("Alignment applies when a selectable is larger than its text content.");
			ImGui::Text("Safe Area Padding");
			ImGui::SameLine(); ImGui::HelpMarker("Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).");
			changedbut |= ImGui::SliderFloat2("DisplaySafeAreaPadding", (float*)&style.DisplaySafeAreaPadding, 0.0f, 30.0f, "%.0f");
			ImGui::EndTabItem();

			if (changedbut)
			{
				// this should obvioulsy be in some struct, or just overwite varstyle = style. But then we would save unwanted stuff
				vars::styling->imStyle.WindowPadding = style.WindowPadding;
				vars::styling->imStyle.FramePadding = style.FramePadding;
				vars::styling->imStyle.CellPadding = style.CellPadding;
				vars::styling->imStyle.ItemSpacing = style.ItemSpacing;
				vars::styling->imStyle.ItemInnerSpacing = style.ItemInnerSpacing;
				vars::styling->imStyle.TouchExtraPadding = style.TouchExtraPadding;
				vars::styling->imStyle.IndentSpacing = style.IndentSpacing;
				vars::styling->imStyle.ScrollbarSize = style.ScrollbarSize;
				vars::styling->imStyle.GrabMinSize = style.GrabMinSize;
				vars::styling->imStyle.WindowBorderSize = style.WindowBorderSize;
				vars::styling->imStyle.ChildBorderSize = style.ChildBorderSize;
				vars::styling->imStyle.PopupBorderSize = style.PopupBorderSize;
				vars::styling->imStyle.FrameBorderSize = style.FrameBorderSize;
				vars::styling->imStyle.TabBorderSize = style.TabBorderSize;
				vars::styling->imStyle.WindowRounding = style.WindowRounding;
				vars::styling->imStyle.ChildRounding = style.ChildRounding;
				vars::styling->imStyle.FrameRounding = style.FrameRounding;
				vars::styling->imStyle.PopupRounding = style.PopupRounding;
				vars::styling->imStyle.ScrollbarRounding = style.ScrollbarRounding;
				vars::styling->imStyle.GrabRounding = style.GrabRounding;
				vars::styling->imStyle.LogSliderDeadzone = style.LogSliderDeadzone;
				vars::styling->imStyle.TabRounding = style.TabRounding;
				vars::styling->imStyle.WindowMenuButtonPosition = style.WindowMenuButtonPosition;
				vars::styling->imStyle.ColorButtonPosition = style.ColorButtonPosition;
				vars::styling->imStyle.ButtonTextAlign = style.ButtonTextAlign;
				vars::styling->imStyle.SelectableTextAlign = style.SelectableTextAlign;
				vars::styling->imStyle.DisplaySafeAreaPadding = style.DisplaySafeAreaPadding;
			}
		}

		if (ImGui::BeginTabItem("Colors"))
		{
			static int output_dest = 0;
			static bool output_only_modified = true;
			if (ImGui::Button("Export"))
			{
				if (output_dest == 0)
					ImGui::LogToClipboard();
				else
					ImGui::LogToTTY();
				ImGui::LogText("ImVec4* colors = ImGui::GetStyle().Colors;" IM_NEWLINE);
				for (int i = 0; i < ImGuiCol_COUNT; i++)
				{
					const ImVec4& col = style.Colors[i];
					const char* name = ImGui::GetStyleColorName(i);
					if (!output_only_modified || memcmp(&col, &ref->Colors[i], sizeof(ImVec4)) != 0)
						ImGui::LogText("colors[ImGuiCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);" IM_NEWLINE,
							name, 23 - (int)strlen(name), "", col.x, col.y, col.z, col.w);
				}
				ImGui::LogFinish();
			}
			ImGui::SameLine(); ImGui::SetNextItemWidth(120); ImGui::Combo("##output_type", &output_dest, "To Clipboard\0To TTY\0");
			ImGui::SameLine(); ImGui::Checkbox("Only Modified Colors", &output_only_modified);

			static ImGuiTextFilter filter;
			filter.Draw("Filter colors", ImGui::GetFontSize() * 16);

			static ImGuiColorEditFlags alpha_flags = 0;
			if (ImGui::RadioButton("Opaque", alpha_flags == ImGuiColorEditFlags_None)) { alpha_flags = ImGuiColorEditFlags_None; } ImGui::SameLine();
			if (ImGui::RadioButton("Alpha", alpha_flags == ImGuiColorEditFlags_AlphaPreview)) { alpha_flags = ImGuiColorEditFlags_AlphaPreview; } ImGui::SameLine();
			if (ImGui::RadioButton("Both", alpha_flags == ImGuiColorEditFlags_AlphaPreviewHalf)) { alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf; } ImGui::SameLine();
			ImGui::HelpMarker(
				"In the color list:\n"
				"Left-click on color square to open color picker,\n"
				"Right-click to open edit options menu.");

			ImGui::BeginChild("##colors", ImVec2(0, 0), true, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar | ImGuiWindowFlags_NavFlattened);
			ImGui::PushItemWidth(-160);
			for (int i = 0; i < ImGuiCol_COUNT; i++)
			{
				const char* name = ImGui::GetStyleColorName(i);
				if (!filter.PassFilter(name))
					continue;
				ImGui::PushID(i);
				ImGui::ColorEdit4("##color", (float*)&style.Colors[i], ImGuiColorEditFlags_AlphaBar | alpha_flags);
				if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0)
				{
					// Tips: in a real user application, you may want to merge and use an icon font into the main font,
					// so instead of "Save"/"Revert" you'd use icons!
					// Read the FAQ and docs/FONTS.md about using icon fonts. It's really easy and super convenient!
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Save"))
					{
						ref->Colors[i] = style.Colors[i];
						vars::styling->imStyle.Colors[i] = style.Colors[i];
					}
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Revert")) { style.Colors[i] = ref->Colors[i]; }
				}
				ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);
				ImGui::TextUnformatted(name);
				ImGui::PopID();
			}

			// should fix this... by own struct
			for (size_t i = 0; i < vars::styling->groupPanelBackground.size(); i++)
			{
				constexpr std::array names = { "Groupleft_up", "Groupright_up", "Groupright_down", "Groupleft_down" };
				const char* name = names[i];
				if (!filter.PassFilter(name))
					continue;
				ImGui::PushID(names[i]);

				ImGui::ColorEdit4("##color2", vars::styling->groupPanelBackground[i].getColorRef().data(), ImGuiColorEditFlags_AlphaBar | alpha_flags);
				if (memcmp(vars::styling->groupPanelBackground[i].getColorRef().data(), ref_saved_gradient[i].getColorRef().data(), sizeof(ImVec4)) != 0)
				{
					// Tips: in a real user application, you may want to merge and use an icon font into the main font,
					// so instead of "Save"/"Revert" you'd use icons!
					// Read the FAQ and docs/FONTS.md about using icon fonts. It's really easy and super convenient!
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Save"))
					{
						ref_saved_gradient[i] = vars::styling->groupPanelBackground[i];
					}
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Revert")) { vars::styling->groupPanelBackground[i] = ref_saved_gradient[i]; }
				}
				ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);
				ImGui::TextUnformatted(name);
				ImGui::PopID();
			}

			const char* name = "Groupline";
			if (filter.PassFilter(name))
			{
				ImGui::PushID(name);
				ImGui::ColorEdit4("##color3", vars::styling->groupPanelLines.getColorRef().data(), ImGuiColorEditFlags_AlphaBar | alpha_flags);

				if (memcmp(vars::styling->groupPanelLines.getColorRef().data(), ref_saved_color_panel_line.getColorRef().data(), sizeof(ImVec4)) != 0)
				{
					// Tips: in a real user application, you may want to merge and use an icon font into the main font,
					// so instead of "Save"/"Revert" you'd use icons!
					// Read the FAQ and docs/FONTS.md about using icon fonts. It's really easy and super convenient!
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Save"))
					{
						ref_saved_color_panel_line = vars::styling->groupPanelLines;
					}
					ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Revert")) { vars::styling->groupPanelLines = ref_saved_color_panel_line; }
				}

				ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);
				ImGui::TextUnformatted(name);
				ImGui::PopID();
			}

			ImGui::PopItemWidth();
			ImGui::EndChild();

			ImGui::EndTabItem();
		}

		if (ImGui::BeginTabItem("Fonts"))
		{
			ImGuiIO& io = ImGui::GetIO();
			ImFontAtlas* atlas = io.Fonts;
			ImGui::TextWrapped(
				"Below we are displaying the font texture (which is the only texture we have access to in this demo). "
				"Use the 'ImTextureID' type as storage to pass pointers or identifier to your own texture data. "
				"Hover the texture for a zoomed view!");

			// Below we are displaying the font texture because it is the only texture we have access to inside the demo!
			// Remember that ImTextureID is just storage for whatever you want it to be. It is essentially a value that
			// will be passed to the rendering backend via the ImDrawCmd structure.
			// If you use one of the default imgui_impl_XXXX.cpp rendering backend, they all have comments at the top
			// of their respective source file to specify what they expect to be stored in ImTextureID, for example:
			// - The imgui_impl_dx11.cpp renderer expect a 'ID3D11ShaderResourceView*' pointer
			// - The imgui_impl_opengl3.cpp renderer expect a GLuint OpenGL texture identifier, etc.
			// More:
			// - If you decided that ImTextureID = MyEngineTexture*, then you can pass your MyEngineTexture* pointers
			//   to ImGui::Image(), and gather width/height through your own functions, etc.
			// - You can use ShowMetricsWindow() to inspect the draw data that are being passed to your renderer,
			//   it will help you debug issues if you are confused about it.
			// - Consider using the lower-level ImDrawList::AddImage() API, via ImGui::GetWindowDrawList()->AddImage().
			// - Read https://github.com/ocornut/imgui/blob/master/docs/FAQ.md
			// - Read https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples
			ImTextureID my_tex_id = io.Fonts->TexID;
			float my_tex_w = (float)io.Fonts->TexWidth;
			float my_tex_h = (float)io.Fonts->TexHeight;
			{
				static bool use_text_color_for_tint = false;
				ImGui::Checkbox("Use Text Color for Tint", &use_text_color_for_tint);
				ImGui::Text("%.0fx%.0f", my_tex_w, my_tex_h);
				ImVec2 pos = ImGui::GetCursorScreenPos();
				ImVec2 uv_min = ImVec2(0.0f, 0.0f);                 // Top-left
				ImVec2 uv_max = ImVec2(1.0f, 1.0f);                 // Lower-right
				ImVec4 tint_col = use_text_color_for_tint ? ImGui::GetStyleColorVec4(ImGuiCol_Text) : ImVec4(1.0f, 1.0f, 1.0f, 1.0f);   // No tint
				ImVec4 border_col = ImGui::GetStyleColorVec4(ImGuiCol_Border);
				ImGui::Image(my_tex_id, ImVec2(my_tex_w, my_tex_h), uv_min, uv_max, tint_col, border_col);
				if (ImGui::IsItemHovered() && ImGui::BeginTooltip())
				{
					float region_sz = 32.0f;
					float region_x = io.MousePos.x - pos.x - region_sz * 0.5f;
					float region_y = io.MousePos.y - pos.y - region_sz * 0.5f;
					float zoom = 4.0f;
					if (region_x < 0.0f) { region_x = 0.0f; }
					else if (region_x > my_tex_w - region_sz) { region_x = my_tex_w - region_sz; }
					if (region_y < 0.0f) { region_y = 0.0f; }
					else if (region_y > my_tex_h - region_sz) { region_y = my_tex_h - region_sz; }
					ImGui::Text("Min: (%.2f, %.2f)", region_x, region_y);
					ImGui::Text("Max: (%.2f, %.2f)", region_x + region_sz, region_y + region_sz);
					ImVec2 uv0 = ImVec2((region_x) / my_tex_w, (region_y) / my_tex_h);
					ImVec2 uv1 = ImVec2((region_x + region_sz) / my_tex_w, (region_y + region_sz) / my_tex_h);
					ImGui::Image(my_tex_id, ImVec2(region_sz * zoom, region_sz * zoom), uv0, uv1, tint_col, border_col);
					ImGui::EndTooltip();
				}
			}

			// Post-baking font scaling. Note that this is NOT the nice way of scaling fonts, read below.
			// (we enforce hard clamping manually as by default DragFloat/SliderFloat allows CTRL+Click text to get out of bounds).
			const float MIN_SCALE = 0.3f;
			const float MAX_SCALE = 2.0f;
			ImGui::HelpMarker(
				"Those are old settings provided for convenience.\n"
				"However, the _correct_ way of scaling your UI is currently to reload your font at the designed size, "
				"rebuild the font atlas, and call style.ScaleAllSizes() on a reference ImGuiStyle structure.\n"
				"Using those settings here will give you poor quality results.");
			static float window_scale = 1.0f;
			ImGui::PushItemWidth(ImGui::GetFontSize() * 8);
			if (ImGui::DragFloat("window scale", &window_scale, 0.005f, MIN_SCALE, MAX_SCALE, "%.2f", ImGuiSliderFlags_AlwaysClamp)) // Scale only this window
				ImGui::SetWindowFontScale(window_scale);
			ImGui::DragFloat("global scale", &io.FontGlobalScale, 0.005f, MIN_SCALE, MAX_SCALE, "%.2f", ImGuiSliderFlags_AlwaysClamp); // Scale everything
			ImGui::PopItemWidth();

			ImGui::EndTabItem();
		}

		if (ImGui::BeginTabItem("Rendering"))
		{
			ImGui::Checkbox("Anti-aliased lines", &style.AntiAliasedLines);
			ImGui::SameLine();
			ImGui::HelpMarker("When disabling anti-aliasing lines, you'll probably want to disable borders in your style as well.");

			ImGui::Checkbox("Anti-aliased lines use texture", &style.AntiAliasedLinesUseTex);
			ImGui::SameLine();
			ImGui::HelpMarker("Faster lines using texture data. Require backend to render with bilinear filtering (not point/nearest filtering).");

			ImGui::Checkbox("Anti-aliased fill", &style.AntiAliasedFill);
			ImGui::PushItemWidth(ImGui::GetFontSize() * 8);
			ImGui::DragFloat("Curve Tessellation Tolerance", &style.CurveTessellationTol, 0.02f, 0.10f, 10.0f, "%.2f");
			if (style.CurveTessellationTol < 0.10f) style.CurveTessellationTol = 0.10f;

			// When editing the "Circle Segment Max Error" value, draw a preview of its effect on auto-tessellated circles.
			ImGui::DragFloat("Circle Tessellation Max Error", &style.CircleTessellationMaxError, 0.005f, 0.10f, 5.0f, "%.2f", ImGuiSliderFlags_AlwaysClamp);
			if (ImGui::IsItemActive())
			{
				ImGui::SetNextWindowPos(ImGui::GetCursorScreenPos());
				ImGui::BeginTooltip();
				ImGui::TextUnformatted("(R = radius, N = number of segments)");
				ImGui::Spacing();
				ImDrawList* draw_list = ImGui::GetWindowDrawList();
				const float min_widget_width = ImGui::CalcTextSize("N: MMM\nR: MMM").x;
				for (int n = 0; n < 8; n++)
				{
					const float RAD_MIN = 5.0f;
					const float RAD_MAX = 70.0f;
					const float rad = RAD_MIN + (RAD_MAX - RAD_MIN) * (float)n / (8.0f - 1.0f);

					ImGui::BeginGroup();

					ImGui::Text("R: %.f\nN: %d", rad, draw_list->_CalcCircleAutoSegmentCount(rad));

					const float canvas_width = ImMax(min_widget_width, rad * 2.0f);
					const float offset_x = floorf(canvas_width * 0.5f);
					const float offset_y = floorf(RAD_MAX);

					const ImVec2 p1 = ImGui::GetCursorScreenPos();
					draw_list->AddCircle(ImVec2(p1.x + offset_x, p1.y + offset_y), rad, ImGui::GetColorU32(ImGuiCol_Text));
					ImGui::Dummy(ImVec2(canvas_width, RAD_MAX * 2));

					/*
					const ImVec2 p2 = ImGui::GetCursorScreenPos();
					draw_list->AddCircleFilled(ImVec2(p2.x + offset_x, p2.y + offset_y), rad, ImGui::GetColorU32(ImGuiCol_Text));
					ImGui::Dummy(ImVec2(canvas_width, RAD_MAX * 2));
					*/

					ImGui::EndGroup();
					ImGui::SameLine();
				}
				ImGui::EndTooltip();
			}
			ImGui::SameLine();
			ImGui::HelpMarker("When drawing circle primitives with \"num_segments == 0\" tesselation will be calculated automatically.");

			ImGui::DragFloat("Global Alpha", &style.Alpha, 0.005f, 0.20f, 1.0f, "%.2f"); // Not exposing zero here so user doesn't "lose" the UI (zero alpha clips all widgets). But application code could have a toggle to switch between zero and non-zero.
			ImGui::DragFloat("Disabled Alpha", &style.DisabledAlpha, 0.005f, 0.0f, 1.0f, "%.2f"); ImGui::SameLine(); ImGui::HelpMarker("Additional alpha multiplier for disabled items (multiply over current value of Alpha).");
			ImGui::PopItemWidth();

			ImGui::EndTabItem();
		}

		ImGui::EndTabBar();
	}

	ImGui::PopItemWidth();
}
```

`hack/menu/GUI-ImGui/sections/editors/styleEditor.hpp`:

```hpp
#pragma once

namespace styleEditor
{
	void draw();
}
```

`hack/menu/GUI-ImGui/sections/misc/misc.cpp`:

```cpp
#include "misc.hpp"

#include "../common.hpp"

#include "../../selections.hpp"
#include <cheats/features/visuals/world/skybox.hpp>
#include <cheats/features/visuals/world/ambient.hpp>
#include <cheats/features/misc/disable/convars.hpp>

void tabs::misc::draw()
{
	ImGui::Columns(2, nullptr, false);

	ImGui::BeginGroupPanel("Locals", ImGui::GetContentRegionAvail());
	{
		ImGui::Checkbox("Motion blur", &vars::misc->motionBlur->enabled);
		if (vars::misc->motionBlur->enabled)
		{
			ImGui::Checkbox("Forward##Motion Blur", &vars::misc->motionBlur->forward);
			ImGui::SliderFloat("Failling intensity##Motion Blur", &vars::misc->motionBlur->fallingIntensity, 0.0f, 5.0f);
			ImGui::SliderFloat("Falling max##Motion Blur", &vars::misc->motionBlur->fallingMax, 0.0f, 30.0f);
			ImGui::SliderFloat("Falling min##Motion Blur", &vars::misc->motionBlur->fallingMin, 0.0f, 30.0f);
			ImGui::SliderFloat("Strength##Motion Blur", &vars::misc->motionBlur->strength, 0.0f, 20.0f);
			ImGui::SliderFloat("Roll intensity##Motion Blur", &vars::misc->motionBlur->rollIntensity, 0.0f, 1.0f);
		}

		ImGui::SliderFloat("FOV local", &vars::misc->fov->value, -50.0f, 50.0f);
		ImGui::Checkbox("Third Person", &vars::misc->thirdp->enabled);
		if (vars::misc->thirdp->enabled)
		{
			ImGui::SameLine();
			ImGui::Hotkey("ThirdP", &vars::keys->thirdP);
			ImGui::SliderFloat("Distance##thirdp", &vars::misc->thirdp->distance, 1.0f, 500.0f);
			ImGui::SliderFloat("Extra X##thirdp", &vars::misc->thirdp->x, -180.0f, 180.0f);
			ImGui::SliderFloat("Extra Y##thirdp", &vars::misc->thirdp->y, -180.0f, 180.0f);
		}

		ImGui::Checkbox("Latency##enabled", &vars::misc->fakeLatency->enabled);
		if (vars::misc->fakeLatency->enabled)
		{
			ImGui::SliderFloat("Fake latency ms", &vars::misc->fakeLatency->amount, 0.0f, 200.0f);
		}

		ImGui::Checkbox("Bunnyhop", &vars::misc->bunnyHop->enabled);
		if (vars::misc->bunnyHop->enabled)
		{
			ImGui::SliderInt("Hitchance##bunny", &vars::misc->bunnyHop->chance, 0, 100, "%i%%");
		}
		ImGui::Combo("Autostrafe", &vars::misc->bunnyHop->indexStrafe, magic_enum::enum_names_pretty<MovementStraferMode>());
		ImGui::Combo("Crosshair type", &vars::misc->crosshair->index, magic_enum::enum_names_pretty<CrossHairTypes>());
	}
	ImGui::EndGroupPanel();

	ImGui::BeginGroupPanel("Windows", ImGui::GetContentRegionAvail());
	{
		ImGui::Checkbox("FPS Plot", &vars::misc->plots->enabledFps);
		ImGui::Checkbox("Velocity Plot", &vars::misc->plots->enabledVelocity);
		ImGui::SameLine();
		ImGui::Checkbox("Run transparent", &vars::misc->plots->transparencyVelocity);
		ImGui::SameLine();
		ImGui::HelpMarker("Will add some flags!\nEg: no resize");

		ImGui::Checkbox("Draw misc info", &vars::misc->info->enabled);
		ImGui::Checkbox("Playerlist##checkbox", &vars::misc->playerList->enabled);
		ImGui::SameLine();
		ImGui::PopupButton("##playerlistpop", []()
			{
				ImGui::Checkbox("Health##playerlist", &vars::misc->playerList->health);
				ImGui::Checkbox("Money##playerlist", &vars::misc->playerList->money);
				ImGui::Checkbox("Team##playerlist", &vars::misc->playerList->teamID);
				ImGui::Checkbox("Place##playerlist", &vars::misc->playerList->lastPlace);
			});
		
		ImGui::Checkbox("Spectactors##specson", &vars::misc->spectactorList->enabled);
	}
	ImGui::EndGroupPanel();

	ImGui::NextColumn();
	{
		ImGui::BeginGroupPanel("Extras", ImGui::GetContentRegionAvail());
		{
			ImGui::Checkbox("Game logs", &vars::misc->logs->enabled);
			ImGui::SameLine();
			ImGui::SliderFloat("Time##Gamelogs", &vars::misc->logs->time, 1.0f, 10.0f);
			ImGui::Checkbox("FreeCam", &vars::misc->freeCam->enabled);
			ImGui::SameLine();
			ImGui::Hotkey("##fc", &vars::keys->freeCam);
			ImGui::SameLine();
			ImGui::SliderFloat("Speed##fc", &vars::misc->freeCam->speed, 1.0f, 20.0f);
			ImGui::Checkbox("MirrorCam", &vars::misc->mirrorCam->enabled);
			ImGui::SameLine();
			ImGui::Checkbox("On key##mcam", &vars::misc->mirrorCam->onKey);
			ImGui::SameLine();
			ImGui::Hotkey("##mcam", &vars::keys->mirrorCam);
			ImGui::Checkbox("Flashlight", &vars::misc->flashLight->enabled);
			ImGui::SameLine();
			ImGui::Hotkey("##flashl key", &vars::keys->flashLight);
			ImGui::SameLine();
			ImGui::Checkbox("Big mode", &vars::misc->flashLight->bigMode);
			ImGui::SliderFloat("Flashlight FOV", &vars::misc->flashLight->fov, 1.0f, 100.0f);
		}
		ImGui::EndGroupPanel();

		ImGui::BeginGroupPanel("Removals", ImGui::GetContentRegionAvail());
		{
			ImGui::Checkbox("No scope", &vars::misc->scope->enabled);
			ImGui::Checkbox("Disable Interpolation", &vars::misc->disableItems->interpolate);
			ImGui::SliderFloat("Flashbang %", &vars::misc->disableItems->flashPercentage, 0.0f, 1.0f);
			if(ImGui::Button("Disable cvar locks"))
				convars::run();
		}
		ImGui::EndGroupPanel();
	}

	ImGui::Columns();
}
```

`hack/menu/GUI-ImGui/sections/misc/misc.hpp`:

```hpp
#pragma once

namespace tabs::misc
{
	void draw();
}
```

`hack/menu/GUI-ImGui/sections/settings/settings.cpp`:

```cpp
#include "settings.hpp"

#include "../common.hpp"

#include "../background.hpp"
#include <config/config.hpp>
#include <utilities/console/console.hpp>

#include <imgui_stdlib.h>

void tabs::settings::draw()
{
	static std::string text = "Your new config name";
	static int currentcfg = 0;

	std::once_flag onceFlag;
	std::call_once(onceFlag, []
		{
			for (size_t i = 0; const auto & el : config::getAllConfigFiles())
			{
				if (el == config::getCfgToLoad())
					currentcfg = i;

				i++;
			}
		});

	ImGui::Columns(2, nullptr, false);

	ImGui::BeginChild("##leftconfig");
	{
		const auto allcfg = config::getAllConfigFiles();

		ImGui::BeginGroupPanel("Config", ImGui::GetContentRegionAvail());
		{
			if (ImGui::InputText("Config name", &text, ImGuiInputTextFlags_EnterReturnsTrue))
			{
				if (utilities::toLowerCase(text) != api::getDefaultConfigName())
				{
					config::save(text);
					text.clear();
					config::reload();
				}
				else
					console::error("provided config name was same as default");
			}
			ImGui::SameLine();
			ImGui::HelpMarker("Press enter to create new config");
			ImGui::ListBox("All configs", &currentcfg, std::span(allcfg.data(), allcfg.size()));

			static bool dontAskMe = false;
			static bool delayedClose = false; // not instant close for modal 
			if (ImGui::Button("Delete"))
			{
				if (dontAskMe && delayedClose)
				{
					config::deleteCfg(allcfg.at(currentcfg));
					config::reload();
				}
				else
					ImGui::OpenPopup("Delete?");
			}

			if (ImGui::BeginPopupContextItem())
			{
				if (ImGui::Button("Reset asking"))
				{
					dontAskMe = false;
					delayedClose = false;
					ImGui::CloseCurrentPopup();
				}

				ImGui::EndPopup();
			}

			if (ImGui::BeginPopupModal("Delete?", nullptr, ImGuiWindowFlags_AlwaysAutoResize))
			{
				ImGui::TextUnformatted(std::format("Are you sure you want to delete {} file?", allcfg.at(currentcfg)).c_str());
				ImGui::Separator();
				ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, { 0.0f, 0.0f });
				ImGui::Checkbox("Don't ask again", &dontAskMe);
				ImGui::PopStyleVar();

				if (ImGui::Button("OK", { 120.0f, 0.0f }))
				{
					config::deleteCfg(allcfg.at(currentcfg));
					config::reload();
					ImGui::CloseCurrentPopup();

					if (dontAskMe)
						delayedClose = true;
					else
						delayedClose = false;
				}
				ImGui::SameLine();
				if (ImGui::Button("Cancel", { 120.0f, 0.0f }))
				{
					ImGui::CloseCurrentPopup();

					if (dontAskMe)
						delayedClose = true;
					else
						delayedClose = false;
				}

				ImGui::EndPopup();
			}

			ImGui::SameLine();
			if (ImGui::Button("Save"))
			{
				config::save(allcfg.at(currentcfg));
			}
			ImGui::SameLine();
			if (ImGui::Button("Load"))
			{
				config::load(allcfg.at(currentcfg));
			}
			if (ImGui::Button("Load on start"))
			{
				// this is only saving the load name, nothing more
				config::startSave(allcfg.at(currentcfg));
				console::info("{} will be now loaded config on the start", allcfg.at(currentcfg));
			}
			ImGui::SameLine();
			ImGui::HelpMarker("This config will load on the start");
		}
		ImGui::EndGroupPanel();
	}

	ImGui::EndChild();
	ImGui::NextColumn();

	ImGui::BeginChild("##rigthconfig");
	{
		ImGui::BeginGroupPanel("Config keys", ImGui::GetContentRegionAvail());
		{
			ImGui::Hotkey("Menu key", &vars::keys->menu, false);
			ImGui::Hotkey("Console key", &vars::keys->console, false);
			ImGui::Hotkey("Panic key", &vars::keys->panic, false);
			ImGui::Hotkey("X88 key", &vars::keys->x88Toggle, false);
			ImGui::Checkbox("Enable x88 menu", &vars::keys->enabledX88Menu);
		}
		ImGui::EndGroupPanel();
	}

	ImGui::EndChild();
	ImGui::Columns();
}
```

`hack/menu/GUI-ImGui/sections/settings/settings.hpp`:

```hpp
#pragma once

namespace tabs::settings
{
	void draw();
}
```

`hack/menu/GUI-ImGui/sections/visuals/visuals.cpp`:

```cpp
#include "visuals.hpp"

#include "../common.hpp"
#include "../../selections.hpp"

#include <cheats/features/visuals/chams/chams.hpp>
#include <cheats/features/visuals/world/skybox.hpp>
#include <cheats/features/visuals/world/weather/_menu.hpp>
#include <cheats/features/visuals/world/ambient.hpp>
#include <cheats/features/visuals/radar/radar.hpp>
#include <cheats/features/visuals/world/lights.hpp>

#include <SDK/CCommonHostState.hpp>

#include <imgui_stdlib.h>

static void boxesMenu(const char* uniqueID, CfgBox& box)
{
	ImGui::PushID(uniqueID);

	ImGui::Combo("Boxes mode", &box.mode, magic_enum::enum_names_pretty<BoxTypes>());
	ImGui::ColorPicker("color##box", &box.color);
	ImGui::SameLine();
	ImGui::ColorPicker("filled##box", &box.fill);
	ImGui::SameLine();
	ImGui::Checkbox("Outlined", &box.outline);
	ImGui::Checkbox("Gradient", &box.gradient);
	if (box.gradient)
	{
		ImGui::ColorPicker("##gradient1", &box.gradientCol1);
		ImGui::SameLine();
		ImGui::ColorPicker("##gradient2", &box.gradientCol2);
		ImGui::SameLine();
		ImGui::ColorPicker("##gradient3", &box.gradientCol3);
		ImGui::SameLine();
		ImGui::ColorPicker("##gradient4", &box.gradientCol4);
	}

	ImGui::PopID();
}

void tabs::visuals::draw()
{
	ImGui::Columns(2, nullptr, false);
	ImGui::BeginChild("##visualsleft");
	{
		ImGui::BeginGroupPanel("Player", ImGui::GetContentRegionAvail());
		{
			boxesMenu("playerespbox", vars::visuals->esp->boxes->box);
			ImGui::Checkbox("Health", &vars::visuals->esp->healthBar->enabled);
			ImGui::SameLine();
			ImGui::Checkbox("Armor", &vars::visuals->esp->armorBar->enabled);
			ImGui::SameLine();
			ImGui::Checkbox("Name", &vars::visuals->esp->nameBar->enabled);
			ImGui::Checkbox("Enemy aiming warn", &vars::misc->aimWarn->enabled);
			ImGui::Checkbox("##Skeleton", &vars::visuals->esp->skeleton->enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Skeleton##color", &vars::visuals->esp->skeleton->color);
#ifdef _DEBUG
			ImGui::SameLine();
			ImGui::Checkbox("Debug##skelet", &vars::visuals->esp->skeleton->showDebug);
#endif
			ImGui::Checkbox("##esplaser", &vars::visuals->esp->lasers->enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Lasers##esp", &vars::visuals->esp->lasers->color);
			ImGui::Checkbox("##espsnap", &vars::visuals->esp->snapline->enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Snapline##esp", &vars::visuals->esp->snapline->color);
			ImGui::MultiCombo("Esp flags", magic_enum::enum_names_pretty<EspFlags>(), &vars::visuals->esp->flags->flags);
			ImGui::Checkbox("Weapon bar", &vars::visuals->esp->weaponBar->enabled);
			if (vars::visuals->esp->weaponBar->enabled)
			{
				ImGui::SameLine();
				ImGui::Checkbox("Translate", &vars::visuals->esp->weaponBar->translate);
				ImGui::ColorPicker("Text", &vars::visuals->esp->weaponBar->text);
				ImGui::SameLine();
				ImGui::ColorPicker("Bar", &vars::visuals->esp->weaponBar->bar);
			}
			ImGui::Checkbox("Sound ESP", &vars::visuals->sound->enabled);
			if (vars::visuals->sound->enabled)
			{
				ImGui::SameLine();
				ImGui::ColorPicker("Color##sound", &vars::visuals->sound->color);
				ImGui::SameLine();
				ImGui::ColorPicker("Line##sound", &vars::visuals->sound->colorLine);
				ImGui::SliderFloat("Step time", &vars::visuals->sound->time, 1.0f, 20.0f);
				ImGui::SliderFloat("Step max distance", &vars::visuals->sound->maxDist, 5.0f, 500.0f);
				ImGui::SliderFloat("Lines info distance", &vars::visuals->sound->maxDistLine, 2.0f, 200.0f);
				ImGui::SameLine();
				ImGui::HelpMarker("Max pixels to decide to draw info from centre of screen to the best point");
			}
			ImGui::Checkbox("Dlight", &vars::visuals->esp->dlight->enabled);
			if (vars::visuals->esp->dlight->enabled)
			{
				ImGui::SameLine();
				ImGui::ColorPicker("Color##dlig", &vars::visuals->esp->dlight->color);
				ImGui::SliderFloat("Radius##dlig", &vars::visuals->esp->dlight->radius, 0.0f, 300.0f);
				ImGui::SliderFloat("Exponent##dlig", &vars::visuals->esp->dlight->exponent, 0.0f, 12.0f);
				ImGui::SliderFloat("Decay##dlig", &vars::visuals->esp->dlight->decay, 0.0f, 100.0f);
			}
		}
		ImGui::EndGroupPanel();

		ImGui::BeginGroupPanel("Chams", ImGui::GetContentRegionAvail());
		{
			const auto& materials = chams::materials;
			std::vector<std::string> matNames(materials.size());
			for (size_t i = 0; const auto & mat : materials)
				matNames[i++] = mat.name;

			ImGui::Checkbox("Streamproof##chams", &vars::visuals->chams->streamProof);
			ImGui::SameLine();
			ImGui::HelpMarker("Switching cham type with streamproof turned on might end in UB :("
				"\nMight look a bit overdrawn, that's because we call draw twice rather than once"
				"\nI don't know solution for this");
			ImGui::Checkbox("Ignore smoke##chams", &vars::visuals->chams->ignoreSmoke);
			ImGui::SameLine();
			ImGui::HelpMarker("Chams will render after transculents\nIf there are artifacts with color - just call it sceneend");

			ImGui::Checkbox("Players##chamsp", &vars::visuals->chams->players.enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Color##chamsp", &vars::visuals->chams->players.color);
			ImGui::SameLine();
			ImGui::ColorPicker("ColorXQZ##chamsp", &vars::visuals->chams->players.colorXQZ);
			ImGui::Checkbox("Ignorez##chamsp", &vars::visuals->chams->players.ignorez);
			ImGui::SameLine();
			ImGui::Checkbox("Wireframe##chamsp", &vars::visuals->chams->players.wireframe);
			ImGui::SameLine();
			ImGui::Combo("##Indexchamsp", &vars::visuals->chams->players.index, matNames);

			ImGui::Checkbox("Attachments##chamsa", &vars::visuals->chams->attachement.enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Color##chamsa", &vars::visuals->chams->attachement.color);
			ImGui::Checkbox("Wireframe##chamsa", &vars::visuals->chams->attachement.wireframe);
			ImGui::SameLine();
			ImGui::Combo("##Indexchamsa", &vars::visuals->chams->attachement.index, matNames);

			ImGui::Checkbox("Local Weapon##chamsw", &vars::visuals->chams->weapon.enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Color##chamsw", &vars::visuals->chams->weapon.color);
			ImGui::Checkbox("Wireframe##chamsw", &vars::visuals->chams->weapon.wireframe);
			ImGui::SameLine();
			ImGui::Combo("##Indexchamsw", &vars::visuals->chams->weapon.index, matNames);

			ImGui::Checkbox("Arms##chamsar", &vars::visuals->chams->arms.enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Color##chamsar", &vars::visuals->chams->arms.color);
			ImGui::Checkbox("Wireframe##chamsar", &vars::visuals->chams->arms.wireframe);
			ImGui::SameLine();
			ImGui::Combo("##Indexchamsar", &vars::visuals->chams->arms.index, matNames);

			ImGui::Checkbox("Backtrack##chamsb", &vars::visuals->chams->backtrackEnabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Color##chamsb", &vars::visuals->chams->backtrackColor);
			ImGui::Combo("##Modechamsb", &vars::visuals->chams->backtrackMode, magic_enum::enum_names_pretty<BTChamsType>());
			ImGui::Combo("##Indexchamsb", &vars::visuals->chams->backtrackIndex, matNames);
			
			ImGui::Checkbox("Glow##enabled", &vars::visuals->glow->enabled);
			if (vars::visuals->glow->enabled)
			{
				ImGui::Checkbox("Streamproof##glow", &vars::visuals->glow->streamProof);
				ImGui::SameLine();
				ImGui::HelpMarker("THIS IS AN ATTEMPT FOR QUEUED RENDER\nReally hard to track errors here!");
				ImGui::MultiCombo("Type", magic_enum::enum_names_pretty<GlowRenderStyle>(), &vars::visuals->glow->usedMats);
				ImGui::MultiCombo("Ignorez", magic_enum::enum_names_pretty<GlowIgnorez>(), &vars::visuals->glow->ignorez);
				ImGui::ColorPicker("Color", &vars::visuals->glow->colorPlayer);
				ImGui::Checkbox("Visible", &vars::visuals->glow->visible);
				ImGui::SliderFloat("Exponent", &vars::visuals->glow->exponent, 0.0f, 10.0f);
				ImGui::SliderFloat("Saturation", &vars::visuals->glow->saturation, 0.0f, 50.0f);
				ImGui::SliderFloat("$C0_X (halo add screen)", &vars::visuals->glow->C0_X, 0.0f, 1.0f);
				ImGui::SliderFloat("Thickness", &vars::visuals->glow->thickness, 0.0f, 100.0f);
				if (vars::visuals->glow->usedMats.at(E2T(GlowRenderStyle::RIMGLOW3D)))
				{
					ImGui::SliderFloat("Pulse rim3d",
						&vars::visuals->glow->pulseSpeeeds.at(E2T(GlowRenderPulse::RIM)), 1.0f, 50.0f);
				}

				if (vars::visuals->glow->usedMats.at(E2T(GlowRenderStyle::EDGE_HIGHLIGHT_PULSE)))
				{
					ImGui::SliderFloat("Pulse edge",
						&vars::visuals->glow->pulseSpeeeds.at(E2T(GlowRenderPulse::EDGE)), 1.0f, 50.0f);
				}
			}

			ImGui::EndGroupPanel();
		}

		ImGui::BeginGroupPanel("Radar", ImGui::GetContentRegionAvail());
		{
			ImGui::Checkbox("Radar 2D", &vars::misc->radar->enabled);
			ImGui::SameLine();
			ImGui::Checkbox("Draw out of radar", &vars::misc->radar->ranges);
			ImGui::SameLine();
			ImGui::HelpMarker("If enemy is out of the radar\nThen icons will still appear but clamped");
			ImGui::ColorPicker("Lines##radar", &vars::misc->radar->colorLine);
			ImGui::SameLine();
			ImGui::ColorPicker("Players##radar", &vars::misc->radar->colorPlayer);
			ImGui::SliderFloat("Thickness##radar", &vars::misc->radar->thickness, 0.0f, 20.0f);
			if (vars::misc->radar->mode == E2T(RadarMode::CIRCLE))
			{
				ImGui::SliderFloat("Length##radar", &vars::misc->radar->length, 0.0f, 40.0f);
			}
			ImGui::SliderFloat("Scale##radar", &vars::misc->radar->scale, 0.0f, 10.0f);
			ImGui::Combo("Mode", &vars::misc->radar->mode, magic_enum::enum_names_pretty<RadarMode>());
			if (ImGui::Button("Refresh texture manually"))
			{
				radar::manuallyInitTexture();
			}
			ImGui::SameLine();
			ImGui::HelpMarker("Will not work for workshop maps\nYou can try forcing the engine to re-render by pressing escape few times");
		}
		ImGui::EndGroupPanel();

		ImGui::BeginGroupPanel("Checks", ImGui::GetContentRegionAvail());
		{
			ImGui::Checkbox("Visible only##Visuals", &vars::visuals->esp->checks->visible);
			ImGui::Checkbox("Dead only ##Visuals", &vars::visuals->esp->checks->dead);
			ImGui::Checkbox("Smoke check##Visuals", &vars::visuals->esp->checks->smoke);
			ImGui::SliderFloat("Flash limit##Visuals", &vars::visuals->esp->checks->flashLimit, 0.0f, 255.0f);
			ImGui::SliderFloat("Dormacy time##Visuals", &vars::visuals->dormacy->time, 0.0f, 15.0f);
			//ImGui::SliderFloat("Dormacy limit##Visuals", &vars::visuals->dormacy->limit, 0.0f, 15.0f);
		}
		ImGui::EndGroupPanel();
	}
	ImGui::EndChild();

	ImGui::NextColumn();

	ImGui::BeginChild("##rightvisuals");
	{
		ImGui::BeginGroupPanel("World", ImGui::GetContentRegionAvail());
		{
			ImGui::Checkbox("##Bombenabled", &vars::visuals->world->bomb->enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Bomb info", &vars::visuals->world->bomb->background);
			ImGui::Checkbox("Projectiles##enbaled", &vars::visuals->world->projectiles->enabled);
			if (vars::visuals->world->projectiles->enabled)
			{
				ImGui::ColorPicker("Flashbang##proj", &vars::visuals->world->projectiles->flash);
				ImGui::SameLine();
				ImGui::ColorPicker("Granede##proj", &vars::visuals->world->projectiles->nade);
				ImGui::SameLine();
				ImGui::ColorPicker("Molotov##proj", &vars::visuals->world->projectiles->molotov);
				ImGui::SameLine();
				ImGui::ColorPicker("Smoke##proj", &vars::visuals->world->projectiles->smoke);
				ImGui::SameLine();
				ImGui::ColorPicker("Decoy##proj", &vars::visuals->world->projectiles->decoy);
			}
			ImGui::Checkbox("Dropped##enabled", &vars::visuals->esp->dropped->enabled);
			if (vars::visuals->esp->dropped->enabled)
			{
				ImGui::MultiCombo("##Dropped flags", magic_enum::enum_names_pretty<DroppedFlags>(), &vars::visuals->esp->dropped->flags);
				ImGui::ColorPicker("Ammo##dropped", &vars::visuals->esp->dropped->ammoColor);
				ImGui::ColorPicker("Text##dropped", &vars::visuals->esp->dropped->textColor);
				ImGui::ColorPicker("Icon##dropped", &vars::visuals->esp->dropped->iconColor);
				if (vars::visuals->esp->dropped->flags.at(E2T(DroppedFlags::BOX)))
				{
					boxesMenu("droppedbox", vars::visuals->esp->dropped->box);
				}
			}
			ImGui::Checkbox("##molotov polygon", &vars::visuals->world->molotov->enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Molotov##molrange", &vars::visuals->world->molotov->color);
			ImGui::SameLine();
			ImGui::Checkbox("Triangulation", &vars::visuals->world->molotov->triangulation);
			ImGui::Checkbox("##Enabled smoke circle", &vars::visuals->world->smoke->enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Smoke##smokerange", &vars::visuals->world->smoke->color);

			ImGui::Checkbox("Nade pred", &vars::misc->nade->enabledPred);
			ImGui::SameLine();
			ImGui::Checkbox("Show always", &vars::misc->nade->predAlways);
			ImGui::ColorPicker("Nade pred color", &vars::misc->nade->colorPredLine);
			ImGui::ColorPicker("Nade pred color box fill", &vars::misc->nade->colorPredBoxFill);
			ImGui::ColorPicker("Nade pred color box outline", &vars::misc->nade->colorPredBox);
			ImGui::Checkbox("Nade trails", &vars::misc->nade->enabledTracer);
			ImGui::ColorPicker("Nade trail color", &vars::misc->nade->colorTracer);
			ImGui::SliderFloat("Nade trail max dist", &vars::misc->nade->tracerDist, 1.0f, 100.0f);
			ImGui::Checkbox("Nade trail warn", &vars::misc->nade->tracerWarn);
			ImGui::SameLine();
			ImGui::HelpMarker("Draws scaled circles behind you where nade is");
			ImGui::Checkbox("##Zeusenabl", &vars::visuals->world->zeus->enabled);
			ImGui::SameLine();
			ImGui::ColorPicker("Zeus", &vars::visuals->world->zeus->color);
			ImGui::Checkbox("Tracing##zeus", &vars::visuals->world->zeus->tracing);
			ImGui::SameLine();
			ImGui::Checkbox("Party##zeus", &vars::visuals->world->zeus->party);

		}
		ImGui::EndGroupPanel();

		ImGui::BeginGroupPanel("Edits", ImGui::GetContentRegionAvail());
		{
			// FIX PERFORMANCE simply only colormodulate when color pickers state is true
			
			ImGui::Checkbox("Remove sky", &vars::visuals->world->sky->removeSky);
			ImGui::Checkbox("##textureb", &vars::visuals->world->modulate->enabledTexture);
			ImGui::SameLine();
			ImGui::ColorPicker("Texture", &vars::visuals->world->modulate->texture);
			ImGui::Checkbox("##skyb", &vars::visuals->world->modulate->enabledSky);
			ImGui::SameLine();
			ImGui::ColorPicker("Sky", &vars::visuals->world->modulate->sky);

			ImGui::Checkbox("##propb", &vars::visuals->world->modulate->enabledProp);
			ImGui::SameLine();
			ImGui::ColorPicker("Prop", &vars::visuals->world->modulate->prop);

			for (size_t i = 0; i < 6; ++i)
			{
				ImGui::Checkbox(std::format("##Enabled {}", i).c_str(), &vars::visuals->world->modulate->enabledLights.at(i));
				ImGui::SameLine();
				ImGui::ColorPicker(std::format("##Lights {}", i).c_str(), &vars::visuals->world->modulate->lights.at(i));
				ImGui::SameLine();
				ImGui::SliderFloat(std::format("{}##strenght", magic_enum::enum_name<emittype_t>(magic_enum::enum_value<emittype_t>(i))).c_str(), &vars::visuals->world->modulate->lightsStrenght.at(i), 0.0f, 10000.0f, "%.3f", ImGuiSliderFlags_Logarithmic);
			}
			if (ImGui::Button("Reset lights"))
			{
				lights::forceReset();
			}
			
			ImGui::Checkbox("##shaderalp", &vars::visuals->world->modulate->enabledShader);
			ImGui::SameLine();
			ImGui::SliderFloat("Shader Alpha", &vars::visuals->world->modulate->shader, 0.0f, 100.0f);

			ImGui::Checkbox("##Edit molotov", &vars::visuals->world->particles->enabledMolotov);
			ImGui::SameLine();
			ImGui::ColorPicker("Molotov##edited", &vars::visuals->world->particles->colorMolotov);
			ImGui::Checkbox("##Edit blood", &vars::visuals->world->particles->enabledBlood);
			ImGui::SameLine();
			ImGui::ColorPicker("Blood##edited", &vars::visuals->world->particles->colorBlood);
			ImGui::Checkbox("##Edit smoke", &vars::visuals->world->particles->enabledSmoke);
			ImGui::SameLine();
			ImGui::ColorPicker("Smoke##edited", &vars::visuals->world->particles->colorSmoke);

			const auto& customsky = skybox::customSkyboxes;
			bool state{ false };
			state |= ImGui::Combo("Normal", &vars::visuals->world->sky->indexNormal, std::span(selections::skyboxes.data(), selections::skyboxes.size()));
			state |= ImGui::Combo("Custom##Skybox", &vars::visuals->world->sky->indexCustom, customsky);
			skybox::changedState = state;
			if (ImGui::Button("Reload Custom Skybox"))
			{
				skybox::reloadCustomSkyboxes();
			}

			ImGui::Checkbox("Fog", &vars::visuals->world->fog->enabled);
			if (vars::visuals->world->fog->enabled)
			{
				ImGui::SliderFloat("Distance##fog", &vars::visuals->world->fog->distance, 1.0f, 1000.0f);
				ImGui::SameLine();
				ImGui::ColorPicker("Color##fog", &vars::visuals->world->fog->color);
			}

			ImGui::Checkbox("Tone", &vars::visuals->world->tone->enabled);
			if (vars::visuals->world->tone->enabled)
			{
				ImGui::SliderFloat("Min##ton", &vars::visuals->world->tone->min, 0.0f, 1.0f);
				ImGui::SliderFloat("Max##ton", &vars::visuals->world->tone->max, 0.0f, 1.0f);
				ImGui::SliderFloat("Bloom##ton", &vars::visuals->world->tone->bloom, 0.0f, 16.0f);
			}
			
			ImGui::Combo("Weather", &vars::visuals->world->weather->type, magic_enum::enum_names_pretty<PrecipitationConfig>());
			if (vars::visuals->world->weather->type)
			{
				weather::menu::draw();
			}

			bool changedButton{ false };
			changedButton |= ImGui::Checkbox("##Ambientenab", &vars::visuals->world->ambient->enabled);
			ambientLight::buttonState = changedButton;

			ImGui::SameLine();
			bool changedPicker{ false };
			changedPicker |= ImGui::ColorPicker("Ambient", &vars::visuals->world->ambient->color);
			ambientLight::pickerState = changedPicker;

			ImGui::Combo("Screen effect", &vars::visuals->world->screenEffect->index, selections::screenEffects);
			ImGui::SliderFloat("Param##Screen effect", &vars::visuals->world->screenEffect->param, 0.0f, 1.0f);
			ImGui::SameLine();
			ImGui::ColorPicker("Color##Screen effect", &vars::visuals->world->screenEffect->color);

		}
		ImGui::EndGroupPanel();

		ImGui::BeginGroupPanel("Hitmarker", ImGui::GetContentRegionAvail());
		{
			ImGui::Checkbox("Hitmarker", &vars::misc->hitmarker->enabled);
			ImGui::SameLine();
			ImGui::Checkbox("3D##Hitm", &vars::misc->hitmarker->enabled3D);
			ImGui::SameLine();
			ImGui::Checkbox("Resize##Hitm", &vars::misc->hitmarker->enabledResize);
			ImGui::ColorPicker("Hitmarker normal", &vars::misc->hitmarker->colorNormal);
			ImGui::ColorPicker("Hitmarker hs", &vars::misc->hitmarker->colorHead);
			ImGui::SameLine();
			ImGui::Text("Hitmarker hs");
			ImGui::ColorPicker("Hitmarker dead", &vars::misc->hitmarker->colorDead);
			ImGui::SliderFloat("Hitmarker time", &vars::misc->hitmarker->time, 0.0f, 2.0f);
			ImGui::Checkbox("Play hitmarker", &vars::misc->hitmarker->play);
			ImGui::SameLine();
			ImGui::HelpMarker("Will play the sound after every kill");
		}
		ImGui::EndGroupPanel();

		ImGui::BeginGroupPanel("Bullets and trails", ImGui::GetContentRegionAvail());
		{
			constexpr auto flagList = "Flags list\n"
				"FBEAM_STARTENTITY 1\n"
				"FBEAM_ENDENTITY 2\n"
				"FBEAM_FADEIN 4\n"
				"FBEAM_FADEOUT 8\n"
				"FBEAM_SINENOISE 16\n"
				"FBEAM_SOLID 32\n"
				"FBEAM_SHADEIN 64\n"
				"FBEAM_SHADEOUT 128\n"
				"FBEAM_ONLYNOISEONCE 256\n"
				"FBEAM_NOTILE 512\n"
				"FBEAM_USE_HITBOXES 1024\n"
				"FBEAM_STARTVISIBLE 2048\n"
				"FBEAM_ENDVISIBLE 4096\n"
				"FBEAM_ISACTIVE 8192\n"
				"FBEAM_FOREVER 16384\n"
				"FBEAM_HALOBEAM 32768\n"
				"FBEAM_REVERSED 65536\n";

			ImGui::Checkbox("Movement trail", &vars::misc->trail->enabled);
			ImGui::Combo("Trail type", &vars::misc->trail->mode, magic_enum::enum_names_pretty<MovementTrail>());
			switch (vars::misc->trail->mode)
			{
			case E2T(MovementTrail::BEAM):
			{
				ImGui::SameLine();
				ImGui::PopupButton("Options##movement", []()
					{

						ImGui::Combo("Beam sprite", &vars::misc->trail->beam.index, selections::beamNames);
						ImGui::InputTextWithHint("Beam flags", "eg: 4|8, spaces allowed", &vars::misc->trail->beam.flags);
						ImGui::SameLine();
						ImGui::HelpMarker(flagList);
						ImGui::ColorPicker("Tracers color", &vars::misc->trail->beam.color);
						ImGui::SliderFloat("Tracers life", &vars::misc->trail->beam.life, 0.0f, 10.0f);
						ImGui::SliderFloat("Tracers width", &vars::misc->trail->beam.width, 0.0f, 20.0f);
						ImGui::SliderFloat("Tracers fadelength", &vars::misc->trail->beam.fadeLength, 0.0f, 20.0f);
						ImGui::SliderFloat("Tracers amplitude", &vars::misc->trail->beam.amplitude, 0.0f, 20.0f);
						ImGui::SliderFloat("Tracers speed", &vars::misc->trail->beam.speed, 0.0f, 200.0f);
						ImGui::SliderFloat("Tracers startFrame", &vars::misc->trail->beam.startFrame, 0.0f, 300.0f);
						ImGui::SliderFloat("Tracers frameRate", &vars::misc->trail->beam.frameRate, 0.0f, 200.0f);
						ImGui::SliderInt("Tracers segmnets", &vars::misc->trail->beam.segments, 0, 30);
					});

				break;
			}
			case E2T(MovementTrail::LINE):
			{
				ImGui::SliderFloat("Life", &vars::misc->trail->lineLife, 0.0f, 10.0f);
				ImGui::SameLine();
				ImGui::ColorPicker("Color", &vars::misc->trail->colorLine);
				break;
			}
			case E2T(MovementTrail::SPLASH):
				ImGui::SameLine();
				ImGui::ColorPicker("Color", &vars::misc->trail->colorSplash);
				break;
			}

			ImGui::Checkbox("Enable tracers", &vars::visuals->world->tracer->enabled);
			ImGui::SameLine();
			ImGui::PopupButton("Options##tracbeam", []()
				{
					ImGui::Combo("Beam sprite", &vars::visuals->world->tracer->beamTracer.index, selections::beamNames);
					ImGui::InputTextWithHint("Beam flags", "eg: 4|8, spaces allowed", &vars::visuals->world->tracer->beamTracer.flags);
					ImGui::SameLine();
					ImGui::HelpMarker(flagList);
					ImGui::ColorPicker("Tracers color", &vars::visuals->world->tracer->beamTracer.color);
					ImGui::SliderFloat("Tracers life", &vars::visuals->world->tracer->beamTracer.life, 0.0f, 10.0f);
					ImGui::SliderFloat("Tracers width", &vars::visuals->world->tracer->beamTracer.width, 0.0f, 20.0f);
					ImGui::SliderFloat("Tracers fadelength", &vars::visuals->world->tracer->beamTracer.fadeLength, 0.0f, 20.0f);
					ImGui::SliderFloat("Tracers amplitude", &vars::visuals->world->tracer->beamTracer.amplitude, 0.0f, 20.0f);
					ImGui::SliderFloat("Tracers speed", &vars::visuals->world->tracer->beamTracer.speed, 0.0f, 200.0f);
					ImGui::SliderFloat("Tracers startFrame", &vars::visuals->world->tracer->beamTracer.startFrame, 0.0f, 300.0f);
					ImGui::SliderFloat("Tracers frameRate", &vars::visuals->world->tracer->beamTracer.frameRate, 0.0f, 200.0f);
					ImGui::SliderInt("Tracers segmnets", &vars::visuals->world->tracer->beamTracer.segments, 0, 30);
				});

			ImGui::Checkbox("Client bullets", &vars::visuals->world->impacts->enabledClient);
			ImGui::SameLine();
			ImGui::ColorPicker("Outline##Client bullets", &vars::visuals->world->impacts->colorClient);
			ImGui::SameLine();
			ImGui::ColorPicker("Fill##Client bullets", &vars::visuals->world->impacts->colorClientFill);
			ImGui::SliderFloat("Time##Client bullets", &vars::visuals->world->impacts->timeClient, 0.0f, 5.0f);
		}
		ImGui::EndGroupPanel();
	}

	ImGui::EndChild();
	ImGui::Columns();
}
```

`hack/menu/GUI-ImGui/sections/visuals/visuals.hpp`:

```hpp
#pragma once

namespace tabs::visuals
{
	void draw();
}
```

`hack/menu/GUI-ImGui/selections.hpp`:

```hpp
#pragma once

#include <array>

namespace selections
{
	// https://developer.valvesoftware.com/wiki/Counter-Strike:_Global_Offensive_Sky_List - i did not check if they are up to date
	// to use custom skybox, you need to first load it in root folder and then to actually force the sky you should bypass file checks.
	inline constexpr std::array skyboxes =
	{
		"none",
		"cs_baggage_skybox_",
		"cs_tibet",
		"vietnam",
		"sky_lunacy",
		"embassy",
		"italy",
		"jungle",
		"office",
		"sky_cs15_daylight01_hdr",
		"sky_cs15_daylight02_hdr",
		"sky_day02_05",
		"nukeblank",
		"dustblank",
		"sky_venice",
		"sky_cs15_daylight03_hdr",
		"sky_cs15_daylight04_hdr",
		"sky_csgo_cloudy01",
		"sky_csgo_night02",
		"sky_csgo_night02b",
		"vertigo",
		"vertigoblue_hdr",
		"sky_dust",
		"sky_hr_aztec"
	};

	inline constexpr std::array screenEffects =
	{
		"none",
		"effects/healthboost",
		"effects/parachute",
		"effects/screentear",
		"effects/dronecam",
		"effects/nightvision",
		"effects/dangerzone_screen",
		"effects/underwater_overlay",
		"effects/survival_zone_projection_distancefield_inv",
		"dev/screenhighlight_pulse",
	};

	inline constexpr std::array beamNames =
	{
		"sprites/blueglow1.vmt",
		"sprites/bubble.vmt",
		"sprites/glow01.vmt",
		"sprites/physbeam.vmt",
		"sprites/purpleglow1.vmt",
		"sprites/purplelaser1.vmt",
		"sprites/radio.vmt",
		"sprites/white.vmt",
		"sprites/laserbeam.vmt"
	};
}
```

`hack/menu/GUI-ImGui/styles/styles.cpp`:

```cpp
#include "styles.hpp"

ImStyleCustom styles::getCherryStyle()
{
	ImGuiStyle cherry{ };

	cherry.WindowBorderSize = 1;
	cherry.ChildBorderSize = 0;
	cherry.PopupBorderSize = 1;
	cherry.FrameBorderSize = 1;
	cherry.TabBorderSize = 1;
	cherry.GrabMinSize = 8;

	cherry.FrameRounding = 6;
	cherry.WindowRounding = 8;
	cherry.ChildRounding = 6;
	cherry.PopupRounding = 6;
	cherry.TabRounding = 6;
	cherry.GrabRounding = 6;

    // https://github.com/GraphicsProgramming/dear-imgui-styles#simongeilfuscinder-imgui
	ImVec4* colors = cherry.Colors;
	colors[ImGuiCol_Text] = ImVec4(0.86f, 0.93f, 0.89f, 0.78f);
	colors[ImGuiCol_TextDisabled] = ImVec4(0.86f, 0.93f, 0.89f, 0.28f);
	colors[ImGuiCol_WindowBg] = ImVec4(0.13f, 0.14f, 0.17f, 0.98f);
	colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_PopupBg] = ImVec4(0.20f, 0.22f, 0.27f, 0.90f);
	colors[ImGuiCol_Border] = ImVec4(0.92f, 0.18f, 0.29f, 0.06f);
	colors[ImGuiCol_BorderShadow] = ImVec4(0.92f, 0.18f, 0.29f, 0.04f);
	colors[ImGuiCol_FrameBg] = ImVec4(0.20f, 0.22f, 0.27f, 1.00f);
	colors[ImGuiCol_FrameBgHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.63f);
	colors[ImGuiCol_FrameBgActive] = ImVec4(0.92f, 0.18f, 0.29f, 0.74f);
	colors[ImGuiCol_TitleBg] = ImVec4(0.08f, 0.27f, 0.42f, 0.29f);
	colors[ImGuiCol_TitleBgActive] = ImVec4(0.08f, 0.27f, 0.42f, 0.29f);
	colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.20f, 0.22f, 0.27f, 0.75f);
	colors[ImGuiCol_MenuBarBg] = ImVec4(0.20f, 0.22f, 0.27f, 0.47f);
	colors[ImGuiCol_ScrollbarBg] = ImVec4(0.20f, 0.22f, 0.27f, 0.00f);
	colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.71f, 0.22f, 0.27f, 0.16f);
	colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.63f);
	colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.92f, 0.18f, 0.29f, 0.74f);
	colors[ImGuiCol_CheckMark] = ImVec4(0.71f, 0.22f, 0.27f, 1.00f);
	colors[ImGuiCol_SliderGrab] = ImVec4(0.47f, 0.77f, 0.83f, 0.14f);
	colors[ImGuiCol_SliderGrabActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
	colors[ImGuiCol_Button] = ImVec4(0.47f, 0.77f, 0.83f, 0.14f);
	colors[ImGuiCol_ButtonHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.63f);
	colors[ImGuiCol_ButtonActive] = ImVec4(0.92f, 0.18f, 0.29f, 0.74f);
	colors[ImGuiCol_Header] = ImVec4(0.92f, 0.18f, 0.29f, 0.63f);
	colors[ImGuiCol_HeaderHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.63f);
	colors[ImGuiCol_HeaderActive] = ImVec4(0.92f, 0.18f, 0.29f, 0.74f);
	colors[ImGuiCol_Separator] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);
	colors[ImGuiCol_SeparatorHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);
	colors[ImGuiCol_SeparatorActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
	colors[ImGuiCol_ResizeGrip] = ImVec4(0.47f, 0.77f, 0.83f, 0.04f);
	colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);
	colors[ImGuiCol_ResizeGripActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
	colors[ImGuiCol_Tab] = ImVec4(0.71f, 0.22f, 0.27f, 1.00f);
	colors[ImGuiCol_TabHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.63f);
	colors[ImGuiCol_TabActive] = ImVec4(0.58f, 0.17f, 0.23f, 0.63f);
	colors[ImGuiCol_TabUnfocused] = ImVec4(0.07f, 0.10f, 0.15f, 0.97f);
	colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.14f, 0.26f, 0.42f, 1.00f);
	colors[ImGuiCol_PlotLines] = ImVec4(0.86f, 0.93f, 0.89f, 0.63f);
	colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
	colors[ImGuiCol_PlotHistogram] = ImVec4(0.86f, 0.93f, 0.89f, 0.63f);
	colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
	colors[ImGuiCol_TableHeaderBg] = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
	colors[ImGuiCol_TableBorderStrong] = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);
	colors[ImGuiCol_TableBorderLight] = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);
	colors[ImGuiCol_TableRowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
	colors[ImGuiCol_TextSelectedBg] = ImVec4(0.92f, 0.18f, 0.29f, 0.43f);
	colors[ImGuiCol_DragDropTarget] = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
	colors[ImGuiCol_NavHighlight] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
	colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
	colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.20f, 0.22f, 0.27f, 0.73f);

	std::array extraColors
	{
		CfgColor{ Color{ 0.083f, 0.271f, 0.419f, 0.099f } },
		CfgColor{ Color{ 0.083f, 0.271f, 0.419f, 0.099f } },
		CfgColor{ Color{ 0.576f, 0.172f, 0.232f, 0.241f } },
		CfgColor{ Color{ 0.576f, 0.172f, 0.232f, 0.241f } },
	};

	return ImStyleCustom{ .style = cherry, .extraColors = extraColors };
}
```

`hack/menu/GUI-ImGui/styles/styles.hpp`:

```hpp
#pragma once

#include <imgui.h>
#include <array>
#include <config/cfgcolor.hpp>

struct ImStyleCustom
{
	ImGuiStyle style{ };
	std::array<CfgColor, 4> extraColors{ };
};

namespace styles
{
	ImStyleCustom getCherryStyle();
}
```

`hack/menu/GUI-ImGui/tabrender.hpp`:

```hpp
#pragma once

#include <functional>

struct TabRender
{
	TabRender() = default;
	TabRender(const char* name, const std::function<void()>& func)
		: m_name{ name }, m_func{ func }
	{}
	TabRender(const char* name)
		: m_name{ name }, m_func{ nullptr }
	{}

	[[nodiscard]] bool funcExist() const
	{
		return m_func != nullptr;
	}

	const char* m_name;
	std::function<void()> m_func;
};
```

`hack/menu/x88Menu/x88menu.cpp`:

```cpp
#include "x88menu.hpp"

#include "x88types.hpp"

#include <cheats/game/game.hpp>
#include <cheats/game/globals.hpp>
#include <SDK/structs/Entity.hpp>
#include <config/vars.hpp>
#include <render/render.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/inputSystem.hpp>
#include <magic_enum.hpp>

#include <cheats/hooks/wndproc.hpp>

#define ORIGINAL_DRAW true
#if ORIGINAL_DRAW == true
#include <cheats/hooks/paintTraverse.hpp>
#else
#include <cheats/hooks/present.hpp>
#endif

namespace
{
#if ORIGINAL_DRAW == true
	struct x88Draw : hooks::PaintTraverse
	{
		x88Draw()
		{
			this->registerRender(x88Menu::draw);
		}
	} x88Draw;
#else
	struct x88Draw : hooks::Present
	{
		x88Draw()
		{
			this->registerRun(x88Menu::draw);
		}
	} x88Draw;
#endif

	struct x88Keys : hooks::wndProcSys
	{
		x88Keys()
		{
			this->registerRun(x88Menu::updateKeys);
		}
	} x88Keys;
}
#if ORIGINAL_DRAW == true
static void drawText(float x, float y, unsigned long font, const std::string& text, const Color& color)
{
	SurfaceRender::text(static_cast<int>(x), static_cast<int>(y), font, text, false, color);
}
#else
static void drawText(float x, float y, ImFont* font, const std::string& text, const Color& color)
{
	drawing::Text{ font, ImVec2{ x, y }, Color::U32(color), text, false, false }.draw(ImGui::GetBackgroundDrawList());
}
#endif

namespace x88Menu
{
	// in pixels, padding for X
	size_t addSpaces(const std::string& text);

	size_t index{ 0 };
	size_t m_longestNameSize{ };
	bool m_inited{ false };
	X88Types x88types{ };
}

void x88Menu::draw()
{
	if (!vars::keys->enabledX88Menu)
		return;

	if (!m_inited)
		return;

	const static Color highlight = Colors::Grey.getColorEditAlpha(0.85f);
	const static Color normal = Colors::White;
#if ORIGINAL_DRAW == true
	const static auto font = SurfaceRender::fonts::tahoma;
#else
	const static auto font = ImRender::fonts::csgoTahoma15;
#endif

	float x = globals::screenX * 0.2f;
	float y = 20.0f;

	if (!game::localPlayer)
	{
		drawText(x, y, font, "Hello undefined :)", Colors::Yellow);
#if ORIGINAL_DRAW == true
		y += 14.0f; // size of tahoma
#else
		y += font->FontSize;
#endif
	}
	else
	{
		drawText(x, y, font, std::format("Hello {} :) Local Player {:#0x}", game::localPlayer->getName(), game::localPlayer->getLiteralAddress()), Colors::Yellow);
#if ORIGINAL_DRAW == true
		y += 14.0f; // size of tahoma
#else
		y += font->FontSize;
#endif
	}

	const float yBackup = y;

	for (size_t i = 0; const auto& [x88p, limits] : x88types.getVars())
	{
		Color color = normal;
		if (vars::keys->x88Toggle.isToggled())
		{
			if (index == i)
				color = highlight;
		}

		if (!(i % 10) && i != 0)
		{
			x += 150.0f; // hardcode
			y = yBackup;
		}

		const auto value = x88p.second;
		const auto& name = x88p.first;
#if ORIGINAL_DRAW == true
		const auto __vSize = SurfaceRender::getTextSizeXY(font, name);
		const auto vecSize = ImVec2{ __vSize[0], __vSize[1] };
#else
		const auto vecSize = ImRender::getTextSize(font, font->FontSize, name);
#endif

		if (std::holds_alternative<bool*>(value))
		{
			auto val = *std::get<bool*>(value);
			Color active = val ? Colors::LightBlue : Colors::White;

			drawText(x, y, font, name, color);
			drawText(x + addSpaces(name) + vecSize.x, y, font, std::format("{}", val), active);
			y += vecSize.y;
		}
		else if(std::holds_alternative<int*>(value))
		{
			drawText(x, y, font, name, color);
			drawText(x + addSpaces(name) + vecSize.x, y, font, std::format("{}", *std::get<int*>(value)), color);
			y += vecSize.y;
		}
		else if (std::holds_alternative<float*>(value))
		{
			drawText(x, y, font, name, color);
			drawText(x + addSpaces(name) + vecSize.x, y, font, std::format("{:.2f}", *std::get<float*>(value)), color);
			y += vecSize.y;
		}

		i++;
	}

}

void x88Menu::setStyles()
{
	//x88types.push("Chams", &vars::visuals->chams->indexPlayers, magic_enum::enum_count<ChamsType>() - 1);
	x88types.push("FOV", &vars::misc->fov->value, { -50.0f, 50.0f} );
	x88types.push("Backtrack", &vars::backtrack->enabled);
	x88types.push("Backtrack MS", &vars::backtrack->time, { 0.0f, 200.0f });
	x88types.push("No Sky", &vars::visuals->world->sky->removeSky);
	x88types.push("2D Radar", &vars::misc->radar->enabled);
	x88types.push("Bunnyhop", &vars::misc->bunnyHop->enabled);
	x88types.push("Autostrafe", &vars::misc->bunnyHop->indexStrafe, magic_enum::enum_count<MovementStraferMode>() - 1);
	x88types.push("ThirdP", &vars::misc->thirdp->enabled);
	x88types.push("Draw Info", &vars::misc->info->enabled);

	size_t longest = 0;
#if ORIGINAL_DRAW == true
	for (const auto& [x88p, limits] : x88types.getVars())
	{
		if (auto size = static_cast<size_t>(SurfaceRender::getTextSize(SurfaceRender::fonts::tahoma, x88p.first)); size > longest)
			longest = size;
	}
#else
	for (const auto& [x88p, limits] : x88types.getVars())
	{
		if (auto size = static_cast<size_t>(ImRender::getTextSize(ImRender::fonts::csgoTahoma15, ImRender::fonts::csgoTahoma15->FontSize, x88p.first).x); size > longest)
			longest = size;
	}
#endif
	m_longestNameSize = longest;

	m_inited = true;
}

size_t x88Menu::addSpaces(const std::string& text)
{
	// 5px added to align them well for max size
#if ORIGINAL_DRAW == true
	auto size = (m_longestNameSize + 5) - SurfaceRender::getTextSize(SurfaceRender::fonts::tahoma, text);
	return static_cast<size_t>(size);
#else
	auto size = (m_longestNameSize + 5) - ImRender::getTextSize(ImRender::fonts::csgoTahoma15, ImRender::fonts::csgoTahoma15->FontSize, text).x;
	return static_cast<size_t>(size);
#endif
}

void x88Menu::updateKeys()
{
	if (!vars::keys->enabledX88Menu)
		return;

	vars::keys->x88Toggle.update();

	if (!vars::keys->x88Toggle.isToggled())
		return;

	if (!m_inited)
		return;

	if (inputSystem::isKeyPressed(VK_DOWN))
	{
		if (index != x88types.getVars().size() - 1)
			index++;
		else
			index = 0;
	}

	if (inputSystem::isKeyPressed(VK_UP))
	{
		if (index != 0)
			index--;
		else
			index = x88types.getVars().size() - 1;
	}

	auto current = x88types.getVars().at(index);
	auto& value = current.first.second;
	auto limits = current.second;

	if (std::holds_alternative<bool*>(value))
	{
		// don't care, bools have 0 or 1
		if (inputSystem::isKeyPressed(VK_RIGHT) || inputSystem::isKeyPressed(VK_LEFT))
		{
			*std::get<bool*>(value) = !*std::get<bool*>(value);
		}
	}
	else if (std::holds_alternative<int*>(value)) // no passed limits in negative, since I throw only indexes
	{
		// run on stack to make it safe for values changed by
		auto valNow = *std::get<int*>(value);

		if (inputSystem::isKeyPressed(VK_RIGHT))
		{
			valNow++;
			if (valNow > limits.m_intLimtis)
				valNow = 0;

			*std::get<int*>(value) = valNow;
		}
		if (inputSystem::isKeyPressed(VK_LEFT))
		{
			valNow--;
			if (valNow < 0)
				valNow = limits.m_intLimtis;

			*std::get<int*>(value) = valNow;
		}
	}
	else if (std::holds_alternative<float*>(value)) // passed both limits
	{
		auto valNow = *std::get<float*>(value);

		if (inputSystem::isKeyDown(VK_RIGHT))
		{
			valNow += 0.5f;
			if (valNow > limits.m_floatLimits.second) // max
				valNow = limits.m_floatLimits.first; // min

			*std::get<float*>(value) = valNow;
		}
		if (inputSystem::isKeyDown(VK_LEFT))
		{
			valNow -= 0.5f;
			if (valNow < limits.m_floatLimits.first)
				valNow = limits.m_floatLimits.second;

			*std::get<float*>(value) = valNow;
		}
	}
}
```

`hack/menu/x88Menu/x88menu.hpp`:

```hpp
#pragma once

namespace x88Menu
{
	void draw();
	void updateKeys();
	void setStyles();
};
```

`hack/menu/x88Menu/x88types.hpp`:

```hpp
#pragma once

#pragma warning(disable: 26495)

#include <variant>
#include <string>
#include <vector>
#include <utility>
#include <type_traits>

// pair in pair
class X88Types
{
private:
	// ptr to get actual config vars updated
	using Types = std::variant<bool*, int*, float*>;
	using X88Pair = std::pair<std::string, Types>;

	struct Limits
	{
		Limits() = default;
		constexpr Limits(const std::pair<float, float>& limits)
			: m_floatLimits{ limits }
		{}
		constexpr Limits(int limits)
			: m_intLimtis{ limits }
		{}

		std::pair<float, float> m_floatLimits;
		int m_intLimtis;
	};
public:
	template<typename T>
	constexpr void push(const std::string& name, const T& var)
	{
		m_vars.emplace_back(std::make_pair(X88Pair{ name, var }, Limits{}));
	}
	template<typename T>
	constexpr void push(const std::string& name, const T& var, const std::pair<float, float>& limits)
	{
		m_vars.emplace_back(std::make_pair(X88Pair{ name, var }, Limits{ limits }));
		return;
	}
	template<typename T>
	constexpr void push(const std::string& name, const T& var, int limits)
	{
		m_vars.emplace_back(std::make_pair(X88Pair{ name, var }, Limits{ limits }));
	}
	constexpr std::vector<std::pair<X88Pair, Limits>> getVars() const { return m_vars; }
private:
	std::vector<std::pair<X88Pair, Limits>> m_vars{ };
};
```

`hack/render/BBox.cpp`:

```cpp
#include "BBox.hpp"

#include "render.hpp"

#include <SDK/ICollideable.hpp>
#include <SDK/structs/Entity.hpp>
#include <utilities/math/math.hpp>

Box::Box(Entity_t* ent)
{
	const auto col = ent->getCollideable();
	if (!col)
	{
		m_isValid = false;
		return;
	}
	const auto& min = col->OBBMins();
	const auto& max = col->OBBMaxs();
	const auto& matrixWorld = ent->renderableToWorldTransform();

	float left = std::numeric_limits<float>::max();
	float top = std::numeric_limits<float>::max();
	float right = -std::numeric_limits<float>::max();
	float bottom = -std::numeric_limits<float>::max();

	const auto points = buildAABB(min, max);

	std::array<ImVec2, 8> screen = {};
	for (size_t i = 0; auto & el : screen)
	{
		if (!ImRender::worldToScreen(math::transformVector(points.at(i), matrixWorld), el))
		{
			m_isValid = false;
			return;
		}

		left = std::min(left, el.x);
		top = std::min(top, el.y);
		right = std::max(right, el.x);
		bottom = std::max(bottom, el.y);

		this->points.at(i) = el;

		i++;
	}

	this->x = left;
	this->y = top;
	this->w = right - left;
	this->h = bottom - top;

	// get important points, eg: if you use 3d box, you want to render health by quads, not rects

	this->topleft = screen.at(7);
	this->topright = screen.at(6);
	this->bottomleft = screen.at(3);
	this->bottomright = screen.at(2);

	m_isValid = true;
}

Box::Box(Entity_t* ent, const Vec3& min, const Vec3& max)
{
	const auto& matrixWorld = ent->renderableToWorldTransform();

	float left = std::numeric_limits<float>::max();
	float top = std::numeric_limits<float>::max();
	float right = -std::numeric_limits<float>::max();
	float bottom = -std::numeric_limits<float>::max();

	const auto points = buildAABB(min, max);

	std::array<ImVec2, 8> screen = {};
	for (size_t i = 0; auto & el : screen)
	{
		if (!ImRender::worldToScreen(math::transformVector(points.at(i), matrixWorld), el))
		{
			m_isValid = false;
			return;
		}

		left = std::min(left, el.x);
		top = std::min(top, el.y);
		right = std::max(right, el.x);
		bottom = std::max(bottom, el.y);

		this->points.at(i) = el;

		i++;
	}

	this->x = left;
	this->y = top;
	this->w = right - left;
	this->h = bottom - top;

	// get important points, eg: if you use 3d box, you want to render health by quads, not rects

	this->topleft = screen.at(7);
	this->topright = screen.at(6);
	this->bottomleft = screen.at(3);
	this->bottomright = screen.at(2);

	m_isValid = true;
}


std::array<Vec3, 8> Box::buildAABB(const Vec3& min, const Vec3& max)
{
	std::array points =
	{
		Vec3{ min[Coord::X], min[Coord::Y], min[Coord::Z] },
		Vec3{ min[Coord::X], max[Coord::Y], min[Coord::Z] },
		Vec3{ max[Coord::X], max[Coord::Y], min[Coord::Z] },
		Vec3{ max[Coord::X], min[Coord::Y], min[Coord::Z] },
		Vec3{ min[Coord::X], min[Coord::Y], max[Coord::Z] },
		Vec3{ min[Coord::X], max[Coord::Y], max[Coord::Z] },
		Vec3{ max[Coord::X], max[Coord::Y], max[Coord::Z] },
		Vec3{ max[Coord::X], min[Coord::Y], max[Coord::Z] }
	};

	return points;
}
```

`hack/render/BBox.hpp`:

```hpp
#pragma once
#pragma warning(disable:26495)

#include <SDK/math/Vector.hpp>
#include <imgui.h>

#include <array>
#include <utility>

class Entity_t;

struct Box final
{
	Box() = default;
	constexpr Box(float x, float y, float w, float h) :
		x{ x }, y{ y }, w{ w }, h{ h }
	{}
	constexpr Box(const std::array<ImVec2, 8>& arr) :
		points{ arr }
	{}
	Box(Entity_t* ent, const Vec3& min, const Vec3& max);
	Box(Entity_t* ent);

	constexpr bool isValid() const { return m_isValid; }

	std::array<ImVec2, 8> points;
	float x, y, w, h;
	ImVec2 topleft;
	ImVec2 topright;
	ImVec2 bottomleft;
	ImVec2 bottomright;
private:
	std::array<Vec3, 8> buildAABB(const Vec3& min, const Vec3& max);
	bool m_isValid;
};
```

`hack/render/Color.cpp`:

```cpp
#include "Color.hpp"

#include <imgui_impl_dx9.h>

Color Color::getColorEditAlpha(const float amount) const
{
	Color clr = *this;
	clr.at(3) = amount;
	return clr;
}

Color Color::getColorEditAlphaInt(const int amount) const
{
	Color clr = *this;
	clr.at(3) = amount / 255.0f;
	return clr;
}

ImU32 Color::U32(const Color& color)
{
	return ImColor{ color.r(), color.g(), color.b(), color.a() };
}

#include <cmath>
#include <numbers>

Color Color::rainbowColor(const float gameTime, const float multiply)
{
	return Color
	{
		std::cos(gameTime * multiply) * 0.5f + 0.5f,
		std::cos(gameTime * multiply - 2.0f * std::numbers::pi_v<float> / 3.0f) * 0.5f + 0.5f,
		std::cos(gameTime * multiply - 4.0f * std::numbers::pi_v<float> / 3.0f) * 0.5f + 0.5f 
	};
}

Color Color::healthBased(uint8_t health, uint8_t alpha)
{
	const int g = static_cast<int>(health * 2.55f);
	const int r = 255 - g;
	return Color{ r, g, 0, alpha };
}

```

`hack/render/Color.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <array>
#include <stdexcept>

using ImU32 = unsigned int;

// 0.0 - 1.0, you can pass ints as 0-255 though
class Color
{
public:
	constexpr Color()
	{
		setColor(1.0f, 1.0f, 1.0f, 1.0f); 
	};
	constexpr Color(float r, float g, float b, float a = 1.0f)
	{
		setColor(r, g, b, a);
	}
	constexpr Color(int r, int g, int b, int a = 255)
	{
		setColor(r / 255.0f, g / 255.0f, b / 255.0f, a / 255.0f);
	}
	constexpr Color(const std::array<float, 4>& colArr)
	{
		setColor(colArr.at(0), colArr.at(1), colArr.at(2), colArr.at(3));
	}
	constexpr Color(float colArr[4])
	{
		setColor(colArr[0], colArr[1], colArr[2], colArr[3]);
	}
	constexpr Color(const Color& col, float alpha)
	{
		setColor(col.r(), col.g(), col.b(), alpha);
	}

	constexpr void setColor(float r, float g, float b, float a = 1.0f)
	{
		m_color.at(0) = r; m_color.at(1) = g; m_color.at(2) = b; m_color.at(3) = a;
	}

	constexpr void setAlpha(float a) { m_color.at(3) = a; }
	constexpr void setAlphaInt(int a) { m_color.at(3) = a / 255.0f; }

	[[nodiscard]] constexpr auto get() const { return m_color; }
	[[nodiscard]] constexpr auto& getRef() { return m_color; }
	[[nodiscard]] constexpr auto data() { return m_color.data(); }
	[[nodiscard]] constexpr auto getRGB() const { return std::array{ r(), g(), b() }; }

	[[nodiscard]] constexpr float r() const { return m_color.at(0); }
	[[nodiscard]] constexpr float g() const { return m_color.at(1); }
	[[nodiscard]] constexpr float b() const { return m_color.at(2); }
	[[nodiscard]] constexpr float a() const { return m_color.at(3); }

	[[nodiscard]] constexpr float& r() { return m_color.at(0); }
	[[nodiscard]] constexpr float& g() { return m_color.at(1); }
	[[nodiscard]] constexpr float& b() { return m_color.at(2); }
	[[nodiscard]] constexpr float& a() { return m_color.at(3); }

	// edits alpha
	[[nodiscard]] Color getColorEditAlpha(const float amount) const;
	[[nodiscard]] Color getColorEditAlphaInt(const int amount) const;

	[[nodiscard]] constexpr uint8_t rMultiplied() const { return static_cast<uint8_t>(m_color.at(0) * 255.0f); }
	[[nodiscard]] constexpr uint8_t gMultiplied() const { return static_cast<uint8_t>(m_color.at(1) * 255.0f); }
	[[nodiscard]] constexpr uint8_t bMultiplied() const { return static_cast<uint8_t>(m_color.at(2) * 255.0f); }
	[[nodiscard]] constexpr uint8_t aMultiplied() const { return static_cast<uint8_t>(m_color.at(3) * 255.0f); }

	constexpr const float operator[](size_t index) const { return m_color.at(index); }
	constexpr float& operator[](size_t index) { return m_color.at(index); }
	constexpr const float at(size_t index) const { if (index >= m_color.size()) throw std::runtime_error("Out of range!"); return m_color.at(index); }
	constexpr float& at(size_t index) { if (index >= m_color.size()) throw std::runtime_error("Out of range!"); return m_color.at(index); }
	constexpr bool operator==(const Color& rhs) const { return (*((uintptr_t*)this) == *((uintptr_t*)&rhs)); }
	constexpr bool operator!=(const Color& rhs) const { return !(operator==(rhs)); }
	[[nodiscard]] static Color rainbowColor(const float gameTime, const float multiply = 0.5f); // http://basecase.org/env/on-rainbows
	// health 0-100
	[[nodiscard]] static Color healthBased(uint8_t health, uint8_t alpha = 255);
	[[nodiscard]] static ImU32 U32(const Color& color);
private:
	std::array<float, 4> m_color;
};

namespace Colors
{
	inline Color White = Color{ 255, 255, 255, 255 };
	inline Color Black = Color{ 0, 0, 0, 255 };
	inline Color Red = Color{ 255, 0, 0, 255 };
	inline Color Green = Color{ 0, 255, 0, 255 };
	inline Color DarkBlue = Color{ 0, 0, 255, 255 };
	inline Color LightBlue = Color{ 0, 140, 250, 255 };
	inline Color Grey = Color{ 128, 128, 128, 128 };
	inline Color Yellow = Color{ 255, 255, 0, 255 };
	inline Color Purple = Color{ 140, 20, 252, 255 };
	inline Color Turquoise = Color{ 60, 210, 200, 255 };
	inline Color Palevioletred = Color{ 220, 110, 150, 255 };
	inline Color Pink = Color{ 255, 100, 180, 255 };
	inline Color Coral = Color{ 255, 127, 80, 255 };
	inline Color Cyan = Color{ 0, 255, 255, 255 };
	inline Color Blank = Color{ 0, 0, 0, 0 };
	inline Color Orange = Color{ 255, 125, 0, 255 };
}

// 0-255 & 1byte type
struct SDKColor
{
	SDKColor() = default;
	constexpr SDKColor(uint8_t r, uint8_t g, uint8_t b, uint8_t a = 255)
		: r{ r }, g{ g }, b{ b }, a{ a }
	{}
	constexpr SDKColor(const Color& color)
		: r{ color.rMultiplied() }, g{ color.gMultiplied() }, b{ color.bMultiplied() }, a{ color.aMultiplied() }
	{}

	uint8_t r, g, b, a;
	
	[[nodiscard]] constexpr auto data() { return std::array{ r, g, b, a }.data(); }
};

// 0-255 & 4byte type
struct SDKColorInt
{
	SDKColorInt() = default;
	constexpr SDKColorInt(int r, int g, int b, int a = 255)
		: r{ r }, g{ g }, b{ b }, a{ a }
	{}
	constexpr SDKColorInt(const Color& color)
		: r{ color.rMultiplied() }, g{ color.gMultiplied() }, b{ color.bMultiplied() }, a{ color.aMultiplied() }
	{}

	int r, g, b, a;
};
```

`hack/render/backend/backend.cpp`:

```cpp
#include "backend.hpp"

#include "../render.hpp"
#include <menu/GUI-ImGui/menu.hpp>
#include <menu/x88Menu/x88menu.hpp>
#include <utilities/console/console.hpp>

#include <mutex>
#include <imgui_impl_dx9.h>

void renderbackend::impl(IDirect3DDevice9* device)
{
	static std::once_flag once;
	std::call_once(once, [device]
		{
			ImGui_ImplDX9_Init(device);
			ImRender::init(ImGui::GetIO());
			ImGuiMenu::setStyles();
			x88Menu::setStyles();

			console::debug("renderbackend::impl success");
		});
}

#include <imgui_impl_win32.h>
#include <implot.h>

void renderbackend::createContext(HWND hwnd)
{
	static std::once_flag once;
	std::call_once(once, [hwnd]()
		{
#ifdef SURFACE_RENDER
			SurfaceRender::init();
#endif
			ImGui::CreateContext();
			ImPlot::CreateContext();
			ImGui_ImplWin32_Init(hwnd);

			console::debug("renderbackend::createContext success");
		});
}

#include <utilities/res.hpp>

void renderbackend::shutdown()
{
	static std::once_flag once;
	std::call_once(once, []()
		{
			Resource::destroyAll();

			ImGui_ImplDX9_Shutdown();
			ImGui_ImplWin32_Shutdown();
			ImGui::DestroyContext();
			ImPlot::DestroyContext();
		});
}
```

`hack/render/backend/backend.hpp`:

```hpp
#pragma once

#include <windef.h>

struct IDirect3DDevice9;

// this is safe to use without checking if called once
namespace renderbackend
{
	void impl(IDirect3DDevice9* device);
	void createContext(HWND hwnd);
	void shutdown();
}
```

`hack/render/fonts/fontawesome.hpp`:

```hpp
// File: '.\fontawesome-webfont.ttf' (165548 bytes)
// Exported using binary_to_compressed_c.cpp
static const unsigned int fontawesome_compressed_size = 124565;
static const unsigned int fontawesome_compressed_data[124568 / 4] =
{
    0x0000bc57, 0x00000000, 0xac860200, 0x00000400, 0x00010037, 0x000d0000, 0x00030080, 0x54464650, 0x47be6b4d, 0x860200b9, 0x28158290, 0x4544471c,
    0x00f00246, 0x200f8204, 0x2c0f8270, 0x2f534f20, 0x7a328832, 0x01000040, 0x360f8258, 0x616d6360, 0x3abf0a70, 0x0c00007f, 0x020000a8, 0x736167f2,
    0x82ffff70, 0x86022249, 0x381f8268, 0x796c6708, 0xaef78f66, 0x1a00004d, 0x4c0200ac, 0x616568bc, 0xe5891064, 0x201b822d, 0x210382dc, 0x10826836,
    0x0a030f27, 0x010000b5, 0x280f8214, 0x746d6824, 0x18794578, 0x3c0f8285, 0x0a0000b8, 0x636f6cf0, 0xa2f50261, 0x0f00005c, 0x0b00009c, 0x78616d10,
    0x022c0370, 0x201f821c, 0x272f8238, 0x6d616e20, 0x8b97e365, 0x67355b82, 0x04000068, 0x736f7086, 0x9b8faf74, 0x6b0200a1, 0x1a0000f0, 0x2ddb8475,
    0x90cb0104, 0x5f5978cf, 0x00f53c0f, 0x3682070b, 0xd4000025, 0x8332cd33, 0x20078308, 0x22b082ff, 0x83060109, 0x0008220e, 0x20318402, 0x22058300,
    0x82ff0006, 0x00092113, 0xff221f82, 0x17860109, 0x02851182, 0x83b50221, 0xc3022511, 0x27001902, 0x02211184, 0x20358300, 0x20058201, 0x83038240,
    0x06032c02, 0x00900169, 0x04000005, 0x8233048c, 0x85862010, 0x73022107, 0x8a202882, 0x02980f82, 0x72797029, 0x00400073, 0x8500f520, 0x85062083,
    0x875b837c, 0x00202633, 0x00800301, 0x280e8370, 0x00005502, 0x0000c001, 0xa20c8207, 0x065d2103, 0x06212782, 0x202f8980, 0x830b8206, 0x82052003,
    0x86072017, 0x8307200b, 0x2403850b, 0x00800579, 0x2023876e, 0x82138506, 0x00002297, 0x212b8505, 0x1382061a, 0x80221784, 0x27843200, 0x17870f86,
    0x17821f88, 0x33820420, 0x00000724, 0x07820640, 0x0f860320, 0x17857b84, 0x47860020, 0x13820020, 0x82050a21, 0x8306201f, 0x87038217, 0x82042023,
    0x83072013, 0x999f89bf, 0x823783f7, 0x20338327, 0x84078606, 0x834f863b, 0x234f880b, 0x057a0080, 0x1f412f86, 0x263b840b, 0x05010002, 0x829a0000,
    0x845a2003, 0x8edf961b, 0x8440201b, 0x0080230f, 0x03820635, 0x37857784, 0x82050d21, 0x20038367, 0x41738206, 0x05200b1b, 0x77411782, 0x8310200a,
    0x0ca7410f, 0x07233f82, 0x845a0000, 0x832b8203, 0x411f841b, 0x4021054b, 0x201f8207, 0x839b8a08, 0x8203840f, 0x217f8a1f, 0x0f870300, 0x06200782,
    0x88068341, 0x2013861f, 0x87078606, 0x870520ab, 0x00802757, 0x0000042c, 0x9b41065f, 0x8605200a, 0x266b842b, 0x06400000, 0x86020000, 0x4100200b,
    0x0f8d0e13, 0x15008022, 0x05232783, 0x41050080, 0x4b8308d3, 0x10008023, 0x20078507, 0x20178273, 0x20238601, 0x864b8b04, 0x8c0f205f, 0x008022b7,
    0x410f821b, 0x9f830577, 0x09200382, 0x4b830382, 0x07820420, 0x02230383, 0x82400080, 0x06002103, 0x13875f82, 0x47880783, 0x0b822782, 0x3b412820,
    0x220f8208, 0x84008003, 0x82062083, 0x0b334233, 0x03835783, 0x83072341, 0x2003821b, 0x83138740, 0x821b88af, 0x821f8477, 0x82062043, 0x23cb870b,
    0x2d000004, 0x0d240382, 0x4d008004, 0x9b820383, 0x03822d20, 0x63870f88, 0x00211b82, 0x20d38603, 0x21438506, 0x6b410700, 0x20078305, 0x82138800,
    0x137b411b, 0x9f844787, 0x80223783, 0x13820d00, 0x0f822d20, 0x02253b83, 0x02008005, 0x06134106, 0x60210786, 0x820f8202, 0x06622403, 0x83050000,
    0x202f8203, 0x821b8401, 0x82052017, 0x8305203f, 0x240b858f, 0x00800603, 0x0b434124, 0xd342df87, 0x830c2006, 0x8204201b, 0x8206202b, 0x82052033,
    0x43012007, 0x07230a6b, 0x87360000, 0x00042317, 0x03830300, 0x221c3742, 0x41000000, 0x34220abb, 0x0f828203, 0x04000322, 0x07208f83, 0x05231b82,
    0x88380000, 0x0080233f, 0x03820622, 0x00000723, 0x82038322, 0x84222017, 0x00802103, 0x82053341, 0x220f822f, 0x8480051b, 0x420020e3, 0x0b200ac3,
    0x23824388, 0x4b440520, 0x06442109, 0x03200f82, 0x0383a782, 0x20064f41, 0x821f8400, 0x21078423, 0x3b880000, 0x00000523, 0x44db842c, 0x07200a87,
    0x07821386, 0x80064028, 0x80072000, 0x3b41ffff, 0x83052007, 0x00002243, 0x43ff9015, 0x05200aab, 0x08200b82, 0xb386bf8a, 0x42080021, 0x062306ef,
    0x456d0000, 0x0b840ba7, 0x23833f86, 0xf6220f84, 0x638b2900, 0x9b457f88, 0x83402009, 0x44092013, 0xa3430a53, 0x00002208, 0x86478310, 0x8320204b,
    0x89042047, 0x0de3437b, 0x20192b45, 0x07af4427, 0x2020bf86, 0x13200782, 0x4421638a, 0x05cb4106, 0x13823920, 0x6b831220, 0x820fd742, 0x053e240f,
    0x8f180000, 0x8a2787c7, 0x82192007, 0x8264200b, 0x86592027, 0x862a20b7, 0x82092067, 0x83272007, 0x820393e3, 0x830e202b, 0x41052003, 0x0620063b,
    0x538a8f82, 0x93870020, 0x1f830787, 0x00205f86, 0x0f874f83, 0x00000523, 0x062b410b, 0x8b081b41, 0x0a4b410f, 0x1b845384, 0x03827383, 0x13201b86,
    0x53874b83, 0x2006e342, 0x061f4102, 0x6f450020, 0x0702280a, 0x08010080, 0x86060000, 0x8202201b, 0x0504210b, 0x42054741, 0x838407db, 0xcf871383,
    0x7b846386, 0x03871383, 0x24062341, 0x00f80800, 0x427b8354, 0x2b41070f, 0x4205200f, 0x7f4206db, 0x8763840a, 0x42378727, 0xcf4410d3, 0x0bbf4206,
    0x210b4b41, 0xa348b507, 0x42178209, 0x0523088f, 0x84660000, 0x00b8224b, 0x86978700, 0x08774643, 0x00202f82, 0x16201382, 0x0e202782, 0x1d200782,
    0x20121342, 0x06f74500, 0x2b862520, 0x86081f41, 0x41522017, 0x3f820b07, 0x6b8a4520, 0xd3872020, 0x2420db8a, 0xdf42df8f, 0x8221200a, 0x046b241b,
    0x41280000, 0x03200673, 0x820fc348, 0x05ef4217, 0x27008022, 0x03216782, 0x06e34305, 0x2f885f86, 0x00ff0524, 0x8f460625, 0x08934706, 0x00000026,
    0x0f008006, 0x820b2342, 0x86cf840f, 0x8a252093, 0x820020bb, 0x83152013, 0x4103831f, 0x072007fb, 0x03444382, 0x0887420a, 0x1d201382, 0x73453b87,
    0x8700200a, 0x8207200b, 0x203786a7, 0x41438701, 0x07210f4f, 0x479f8202, 0x0823068f, 0x82300080, 0x84252027, 0x00802297, 0x0897412f, 0x26008022,
    0x8205994b, 0x20029928, 0x057a4503, 0x001c0023, 0x24098201, 0x00ec0100, 0x24098403, 0x0104001c, 0x081182d0, 0x40007076, 0x30000500, 0xa9002000,
    0xb400ae00, 0xd800c600, 0x1e222221, 0x0ef06022, 0x3ef01ef0, 0x5ef04ef0, 0x7ef06ef0, 0x9ef08ef0, 0xb2f0aef0, 0xdef0cef0, 0xfef0eef0, 0x1ef10ef1,
    0x3ef12ef1, 0x5ef14ef1, 0x7ef16ef1, 0x9ef18ef1, 0xbef1aef1, 0xdef1cef1, 0xfef1eef1, 0x1ef20ef2, 0x4ef23ef2, 0x6ef25ef2, 0x8ef27ef2, 0xaef29ef2,
    0xcef2bef2, 0xeef2def2, 0xffff00f5, 0x20227982, 0x718ea800, 0xf0005808, 0xf021f010, 0xf050f040, 0xf070f060, 0xf090f080, 0xf0b0f0a0, 0xf0d0f0c0,
    0xf1f0f0e0, 0xf110f100, 0xf130f120, 0xf150f140, 0xf170f160, 0xf190f180, 0xf1b0f1a0, 0xf1d0f1c0, 0xf2f0f1e0, 0xf210f200, 0xf240f221, 0xf260f250,
    0xf280f270, 0xf2a0f290, 0xf2c0f2b0, 0x83e0f2d0, 0xff6f0871, 0xff5cffe3, 0xff53ff58, 0xde31ff42, 0xddeddde8, 0x100d10ac, 0x100a100c, 0x10081009,
    0x10061007, 0x10041005, 0x0f021003, 0x0ff40ff5, 0x0ff20ff3, 0x0ff00ff1, 0x0fee0fef, 0x0fec0fed, 0x0fea0feb, 0x0fe80fe9, 0x0fe60fe7, 0x0fe40fe5,
    0x0fe20fe3, 0x0fe00fe1, 0x0fdd0fde, 0x0fdb0fdc, 0x0fd90fda, 0x0fd70fd8, 0x0fd50fd6, 0x0dd30fd4, 0x820100c2, 0x2202eee1, 0x88000601, 0x02012676,
    0x02000000, 0x23008d00, 0x03000001, 0x0df8118d, 0x0a050628, 0x080c0407, 0x81d70b09, 0x58822c20, 0x902403af, 0x14010000, 0x98240382, 0x74020000,
    0xd0240382, 0x4c030000, 0xf0280382, 0x54040000, 0x24060000, 0xe0280382, 0x6c080000, 0x78090000, 0x1f820382, 0x17820a20, 0x00280b34, 0x00d40b00,
    0x00840c00, 0x00640d00, 0x00a80e00, 0x0f820f00, 0x0f821020, 0x86821120, 0x009c1124, 0x33821200, 0x002c1329, 0x00d81300, 0x82801400, 0x00fc2303,
    0x6f821500, 0x00341628, 0x00101700, 0x37821800, 0x00cc1829, 0x00701900, 0x82481a00, 0x00942b03, 0x00241b00, 0x00641c00, 0x37821d00, 0x00081e28,
    0x00741e00, 0x6b821f00, 0x008c2024, 0x93822000, 0x00a0212c, 0x00302200, 0x00202300, 0x23822400, 0x9b822420, 0x00442630, 0x00e42700, 0x009c2800,
    0x00542900, 0x37822a00, 0x00bc2a24, 0x63822c00, 0x00f42c24, 0x7f822d00, 0x00402e24, 0x07822e00, 0x00602f28, 0x00bc2f00, 0xf3823000, 0x00a43024,
    0x73823100, 0x00903224, 0x73823300, 0x97823420, 0x0f823420, 0x5b823520, 0x00803528, 0x00b83500, 0x0b823600, 0x825c3621, 0x20338207, 0x25a38237,
    0x0000a837, 0x03820c38, 0x38254782, 0x390000b4, 0x8203824c, 0x683a3007, 0xec3a0000, 0xc03b0000, 0x703c0000, 0x823d0000, 0x3c3e2803, 0xe43e0000,
    0x823f0000, 0xd83f241b, 0x82400000, 0x8240203f, 0x82412047, 0x824120bf, 0x5842285b, 0xf8420000, 0x82430000, 0x8243207b, 0x824420bb, 0x8244204b,
    0x8245202f, 0x8246201b, 0x8247200f, 0xdc473427, 0xec480000, 0x8c490000, 0x384a0000, 0xac4b0000, 0x824c0000, 0x824d2023, 0x824e2033, 0x824e20ff,
    0xd44e28a7, 0xb04f0000, 0x82500000, 0x82502093, 0x3451289f, 0xa0510000, 0x82520000, 0x6c5224a7, 0x82530000, 0x98532427, 0x82540000, 0x8255201f,
    0xf0572453, 0x82580000, 0x085a2557, 0x405b0000, 0x5b820382, 0xab825c20, 0x8b825c20, 0x27825d20, 0x00285e24, 0x63825e00, 0x43825f20, 0xc7826020,
    0x3f826220, 0x00f46225, 0x82046400, 0x2c8b8203, 0x00005065, 0x0000d065, 0x0000c466, 0x20538267, 0x20738267, 0x20bb8269, 0x24fb8269, 0x0000446a,
    0x2077826b, 0x2093826b, 0x209b826c, 0x205f826d, 0x203f826e, 0x281f826f, 0x00008470, 0x0000a471, 0x257b8272, 0x00007873, 0x03821074, 0x75203b82,
    0x7b203382, 0x7c284782, 0x7c000000, 0x7d0000bc, 0x7d201782, 0x7e282782, 0x7f000088, 0x80000094, 0x81241382, 0x81000018, 0x8325a782, 0x84000048,
    0x82038214, 0x8285205f, 0x8285203b, 0x828620a7, 0x828720e3, 0x82882067, 0x828920bb, 0x828b2083, 0xc88c243f, 0x828d0000, 0x828e202f, 0x828f201b,
    0x20902433, 0x82900000, 0x5491241b, 0x82920000, 0x8292209f, 0x82922013, 0x8292208f, 0xfc922413, 0x82930000, 0x8293207f, 0x82942033, 0x829420e3,
    0xf094244b, 0x82950000, 0x249630bf, 0x5c970000, 0x58980000, 0x1c990000, 0x829a0000, 0xb89a24ab, 0x829b0000, 0xa09c246b, 0x829d0000, 0x829e204f,
    0xf89e281b, 0x9c9f0000, 0x82a00000, 0x50a1241f, 0x82a20000, 0x82a220f3, 0x38a324c3, 0x82a30000, 0x64a424a7, 0x82a50000, 0x90a82847, 0x08ab0000,
    0x82ac0000, 0xecac244b, 0x82ad0000, 0xe8ad240f, 0x82ae0000, 0x82af206b, 0xb0af24e3, 0x82b00000, 0xe0b0259b, 0x78b10000, 0xcc230382, 0x82b20000,
    0x74b221bb, 0x9f820782, 0x6b82b320, 0x00f4b329, 0x0070b400, 0x8200b500, 0x20578203, 0x254b82b6, 0x0000d4b6, 0x0382b4b7, 0xb820b782, 0xb9203782,
    0xb9202f82, 0xba209382, 0x03873f82, 0x8782bb20, 0xf382bc20, 0xdf82bd20, 0xe782be20, 0x4f82bf20, 0x00c4c025, 0x820cc200, 0x008c2303, 0x9f82c300,
    0x6b82c420, 0x00bcc425, 0x8210c500, 0x25e78203, 0x000094c6, 0x038230c8, 0xc9208f82, 0xc9206b82, 0xca204f82, 0xcb204782, 0xcb20af82, 0xcc201382,
    0xcd208b82, 0xce202382, 0xce207382, 0xcf20c782, 0xd020bf82, 0xd1204b82, 0xd124ff82, 0xd2000088, 0xd220eb82, 0xd3200782, 0xd3206382, 0xd3201782,
    0xd424f382, 0xd5000038, 0xd5251f82, 0xd600009c, 0x82038260, 0x6cd72437, 0x82d80000, 0x82d820f7, 0x82d920c3, 0x82d92013, 0x54da2497, 0x82da0000,
    0x18db2483, 0x82db0000, 0x82dc2063, 0x82dc20b7, 0x82dd20b3, 0x82dd202b, 0x82de20e7, 0x82df20cb, 0xacdf241b, 0x82e00000, 0x82e120b3, 0x70e22417,
    0x82e30000, 0xe4e324c3, 0x82e40000, 0x82e520a3, 0xc0e6242f, 0x82e70000, 0x82e72027, 0x82e8207b, 0xd8e92417, 0x82ea0000, 0x82eb2003, 0xd4ec2c03,
    0xd0ed0000, 0xdcee0000, 0x82ef0000, 0x04f2241b, 0x82f30000, 0x82f420d3, 0x34f5253b, 0x10f60000, 0xa7820382, 0x3f82f720, 0x0058f824, 0x4b82f800,
    0x0024f924, 0x6b82fa00, 0x7382fb20, 0x0028fc24, 0xa382fc00, 0xdf82fd20, 0xb782fd20, 0xbf82fd20, 0xf382fe20, 0x1382fe20, 0x0008ff3d, 0x00140001,
    0x00b40501, 0x00f40601, 0x00f80701, 0x00d00801, 0x00640901, 0x82100a01, 0x00982803, 0x00180b01, 0x82040c01, 0x00a42f03, 0x002c0d01, 0x00000e01,
    0x00880f01, 0x0b821101, 0x00a01129, 0x00cc1201, 0x82381301, 0x00e42803, 0x00901401, 0x82281501, 0x082b8203, 0x00581621, 0x00fc1601, 0x00c01701,
    0x00841801, 0x00781901, 0x007c1a01, 0x00541b01, 0x00d41c01, 0x82401d01, 0x20078203, 0x2033821e, 0x205f821f, 0x201b821f, 0x20378220, 0x202f8221,
    0x282b8222, 0x01000823, 0x01006c23, 0x201b8224, 0x2c638224, 0x01006827, 0x0100e828, 0x01004c2a, 0x2043822c, 0x2407822e, 0x01007431, 0x25b78231,
    0x0100e032, 0x03823033, 0x0100b027, 0x0100a834, 0x20178235, 0x2c238236, 0x01002437, 0x01000c38, 0x01004839, 0x24cf823a, 0x0100f03a, 0x206f823b,
    0x248f823c, 0x0100d83c, 0x24a3823f, 0x01001c40, 0x24738241, 0x0100c842, 0x24038243, 0x01009c44, 0x202f8245, 0x24038246, 0x01007047, 0x20078248,
    0x248f8249, 0x0100204a, 0x20e3824a, 0x20b3824b, 0x24f7824c, 0x0100184d, 0x20c3824e, 0x20038250, 0x200f8251, 0x24838252, 0x01004453, 0x20278254,
    0x249b8255, 0x01006056, 0x202b8256, 0x24638257, 0x01003458, 0x20238258, 0x25cb825a, 0x0100885a, 0x0382645b, 0x5c202f82, 0x5d20f382, 0x5e208782,
    0x60241b82, 0x61010094, 0x61246b82, 0x620100bc, 0x6320a782, 0x64243782, 0x650100ac, 0x6620cb82, 0x672cfb82, 0x680100dc, 0x690100b4, 0x6a01005c,
    0x6e208f82, 0x7020c382, 0x73207b82, 0x76204782, 0x7720db82, 0x7820bb82, 0x7920db82, 0x7a245f82, 0x7b01008c, 0x7c203382, 0x7d200782, 0x7d24df82,
    0x7f0100a4, 0x7f213782, 0x27078298, 0x800100f8, 0x8101006c, 0x82205782, 0x83202f82, 0x83209b82, 0x84201f82, 0x85243f82, 0x860100b0, 0x88200b82,
    0x89201b82, 0x8a243b82, 0x8b010038, 0x9f820383, 0xd3828e20, 0x00a88e28, 0x00548f01, 0x6f829001, 0x00149124, 0x3f829301, 0x07829420, 0xd7829520,
    0x00fc9524, 0x5b829601, 0x2b829720, 0x007c9924, 0x4f829a01, 0x27829c20, 0x00089d24, 0xe3829d01, 0x13829e20, 0x00189f30, 0x00e89f01, 0x00c4a001,
    0x000ca201, 0x7b82a301, 0xcb82a420, 0x7782a520, 0x0080a624, 0x6382a701, 0xaf82a820, 0x5782a820, 0x00eca823, 0x29038701, 0x010058a9, 0x010028aa,
    0x038220ab, 0x0100cc27, 0x0100acac, 0x208b82ad, 0x200f82ae, 0x20ef82ae, 0x207f82af, 0x240f82af, 0x010040b0, 0x240f82b0, 0x0100bcb6, 0x24e382b7,
    0x0100e0b8, 0x20cb82b9, 0x251f82ba, 0x010094ba, 0x038224bb, 0xbc20df82, 0xbc209382, 0xbd207782, 0xbe206f82, 0x13820383, 0x4b82bf20, 0x0048c024,
    0xa382c101, 0x9f82c120, 0x3382c320, 0x00e4c324, 0xcf82c401, 0xf382c520, 0x7f82c620, 0x9382c620, 0xb782c820, 0x0382c920, 0x6782ca20, 0x1b82cb20,
    0xf382cc20, 0xb382ce20, 0x5f82cf20, 0x7382d020, 0x0064d129, 0x00dcd201, 0x8250d301, 0x241b8203, 0x010084d5, 0x2c6b82d6, 0x010070d7, 0x0100fcd7,
    0x0100f4d8, 0x20bf82da, 0x205382db, 0x200382dc, 0x244b82dd, 0x0100f0dd, 0x204f82de, 0x248b82df, 0x010080e1, 0x203782e2, 0x208782e4, 0x241b82e5,
    0x01003ce6, 0x209782e7, 0x20df82e7, 0x24bf82e8, 0x0100d4e8, 0x206782e9, 0x207382ea, 0x200b82ea, 0x25a382eb, 0x010034ec, 0x0382b8ec, 0xed205b82,
    0xef204b82, 0xef20df82, 0xf020d382, 0xf024c382, 0xf10100cc, 0xf220db82, 0xf3208f82, 0xf3243782, 0xf50100e8, 0xf6285782, 0xf601002c, 0xf70100c0,
    0xf7249b82, 0xf80100e0, 0xf9209f82, 0xfa201382, 0xfb240f82, 0xfc010074, 0xfc202382, 0xfd20cb82, 0xfd240782, 0xfe01008c, 0xff206382, 0xff3c5782,
    0x010200d0, 0x02020034, 0x0302001c, 0x0402002c, 0x05020068, 0x070200d4, 0x09020050, 0x0a201782, 0x0c2c0b82, 0x0d0200e0, 0x0f0200f0, 0x10020018,
    0x11281382, 0x130200e4, 0x1402003c, 0x15202f82, 0x16200382, 0x17301382, 0x18020030, 0x19020038, 0x1a020024, 0x1b020088, 0x1d250b82, 0x1e0200b4,
    0x27038254, 0x200200cc, 0x2102007c, 0x22285b82, 0x240200ac, 0x2502004c, 0x26242f82, 0x27020048, 0x28282b82, 0x290200f4, 0x2a02008c, 0x2a281382,
    0x2b0200dc, 0x2c020094, 0x2e200782, 0x2e244b82, 0x300200ec, 0x31250382, 0x32020084, 0x2b038240, 0x330200fc, 0x340200b8, 0x35020074, 0x36201f82,
    0x39243b82, 0x3a020020, 0x3a203f82, 0x3b24ab82, 0x3b02000c, 0x3c285382, 0x3c020028, 0x3d0200d8, 0x3f209b82, 0x40242f82, 0x41020098, 0x4324c782,
    0x440200a0, 0x46204382, 0x48240f82, 0x48020060, 0x49203f82, 0x4c239f82, 0xbb0200bc, 0x70002603, 0x10030000, 0x3c048206, 0x00000700, 0x21112137,
    0x11211103, 0xfec001e0, 0xa0027040, 0xfa200570, 0xfa000670, 0x08008300, 0x5d000137, 0xa30600ff, 0x1d008005, 0x14010000, 0x21110107, 0x06141632,
    0x26222123, 0x21333634, 0x35260111, 0x33013e34, 0x011e3221, 0xfd2ba306, 0x1a400188, 0xfc1a2626, 0x2f058380, 0x88fd4001, 0x1728242b, 0x28178005,
    0x23460524, 0xfd241e82, 0x26342600, 0x032a0282, 0x2b780200, 0x081b1723, 0x56821b08, 0xff00003b, 0x05000600, 0x002b0080, 0x14110100, 0x2e22020e,
    0x023e3402, 0x11173233, 0x300e8d05, 0x01373634, 0x16323336, 0x68440006, 0x68675a67, 0x23068244, 0xfd57692d, 0x26330e8d, 0x0c40031e, 0x05382810,
    0x32a0fb20, 0x15152b4e, 0x82644e2b, 0x02272506, 0x3bfded19, 0x032a108b, 0x0a331fc7, 0x38040001, 0x83840200, 0x8005802c, 0x21000700, 0x10000000,
    0x03832000, 0xea820120, 0x27223f08, 0x22230601, 0x10022624, 0x20243612, 0x15121604, 0x16010714, 0xf9fe8004, 0xf9fe8efe, 0x72010701, 0x344c0703,
    0xa9fe2436, 0xfe8fdcb3, 0x6f6fbdfb, 0x010501bd, 0xbd05011e, 0x57017c6f, 0x20820225, 0x85070121, 0x80fe272c, 0x01264c34, 0x21897c56, 0xfebd6f2c,
    0xb3dc8ffb, 0x0025a9fe, 0x83820300, 0x07804108, 0x00000500, 0x003d001a, 0x2500004d, 0x04070611, 0x2b020e07, 0x012e2202, 0x26252627, 0x16141127,
    0x36322133, 0x2e023c11, 0x22212303, 0x17141506, 0x041e1716, 0x3e32023b, 0x37363703, 0x1137013e, 0x23059c41, 0x36341135, 0x7c082982, 0x20800616,
    0x9ef4fe25, 0x306d4033, 0x6d300101, 0xfe9e3340, 0x132025f4, 0x0dc0050d, 0x06050113, 0x40fa080c, 0xc193130d, 0x223a06d0, 0x01142e37, 0x372e1401,
    0xd0063a22, 0x805d36c1, 0x40fa425e, 0x425e5e42, 0x5e42c005, 0x24000320, 0x2b84ce1e, 0x30313130, 0x1ece842b, 0x0d00fd24, 0x28041313, 0x11091202,
    0x13050a08, 0x9874a80d, 0x1a3105a5, 0x25121225, 0xa505311a, 0x60912b98, 0x223782fb, 0x8304425e, 0x00002243, 0x2bdb8601, 0x001c0080, 0x27220400,
    0x35042e01, 0x4208a182, 0x17021e32, 0x3233033e, 0x07141516, 0x349a0301, 0x0a90fd12, 0x2f3c4c23, 0x813ee0fe, 0x2424506f, 0x3e816f50, 0xfde5fee0,
    0x02128091, 0x5f24085a, 0xdc438e64, 0x40492bf8, 0x49402424, 0xdddcf82b, 0x85a8fde5, 0x06ad265b, 0x00e00580, 0x820c8222, 0x82132048, 0x2306254e,
    0x05252722, 0x26250582, 0x13373435, 0x08058301, 0x36132550, 0x05131732, 0x1a800616, 0x015695fe, 0x15131415, 0x3ffe3ffe, 0x15151216, 0x94fe5602,
    0xf6013819, 0x133c13e1, 0x38f601e1, 0x1a167903, 0x0cfe9efe, 0x1d150d07, 0x0cecec0c, 0x0e06151d, 0x6201f401, 0x0925151b, 0x29c70149, 0x4939fe29,
    0x00820009, 0xd7820220, 0x092f7b85, 0x00002b00, 0x0b250109, 0x03010501, 0x86010525, 0x32869987, 0x32017104, 0xbdbd5afe, 0x32015afe, 0x017a0149,
    0x84c70179, 0x99292097, 0x14023196, 0x013e2901, 0x3e82fe7e, 0x5bfed7fe, 0x0a03c7c7, 0x3220a687, 0xa383a59a, 0x0005802b, 0x15008005, 0x00001d00,
    0x06214225, 0x3e344208, 0x20163303, 0x031e3237, 0x20061000, 0x20361026, 0x587d0005, 0x7d58aafc, 0x75472e11, 0x6c01834c, 0x47754c83, 0x00ff112e,
    0xe1c2fee1, 0x893e01e1, 0x6d9c9c6d, 0x6d999755, 0x45808045, 0x0397996d, 0x081785c1, 0x0000e135, 0x00000b00, 0x800700ff, 0x0f008005, 0x2f001f00,
    0x4f003f00, 0x6f005f00, 0x8f007f00, 0xaf009f00, 0x35050000, 0x012b2634, 0x011d0622, 0x013b1614, 0x9e113632, 0x1101280f, 0x21232634, 0x42150622,
    0x012006f2, 0x0f902f8e, 0x6f9f2f9e, 0x260f3843, 0x1a268001, 0x98261a80, 0x00042504, 0x00fd1a26, 0x03202083, 0xfc200582, 0x2d870d82, 0x398a0520,
    0x0b82fe20, 0x539f2589, 0x425e802d, 0x5e42c0f9, 0x4006425e, 0x88405e42, 0x9a01217d, 0xfd220a93, 0x7e84021a, 0x0583fe20, 0x22890420, 0x0a89fb20,
    0x228b0320, 0x4594fe20, 0xba215b8a, 0x207b84fa, 0x237b8205, 0x0004005e, 0x06200082, 0x210bcf41, 0x5a440100, 0x0119210e, 0x9f0d6a44, 0x00032a1f,
    0x00fe344c, 0x344c4c34, 0x89058402, 0x8003210b, 0x02231997, 0x8380fe00, 0x83012031, 0xcc022105, 0xfc200c8a, 0x198c0c8b, 0x82090021, 0x070022ba,
    0x148b4200, 0x15010022, 0x3d21b585, 0x05204501, 0x0f8e1120, 0x0fcf1f8f, 0x022b6f8f, 0xfe283800, 0x383828c0, 0x83400128, 0x210b8905, 0x198b8002,
    0x0d8cfd20, 0x0d8d1b8d, 0x518b299b, 0x84200121, 0x21048376, 0x0a88d801, 0x0a89fd20, 0x15940320, 0x4c8a20a0, 0x06000022, 0x41148b41, 0x55415085,
    0x00052a29, 0x40fc2838, 0x28383828, 0x20f38203, 0x0c7d41fb, 0x278b1b8d, 0x41362b41, 0x003f0c0a, 0x00790001, 0x0487060e, 0x001600b2, 0x07140000,
    0x22060701, 0x2601012f, 0x36013f34, 0x82091732, 0x011f2f04, 0xfd1c8706, 0x501c882c, 0x96fe881c, 0x08831c1c, 0x02260123, 0x220f8390, 0x8450f203,
    0x881c231a, 0x0f836a01, 0xfe1c1c25, 0x829102d9, 0x32578223, 0x05eeff6e, 0x00920412, 0x24000023, 0x06010f14, 0x82092722, 0x822f2004, 0x0937215a,
    0x16265f8d, 0x01090714, 0x59841205, 0xfedafe23, 0x214985da, 0x09822601, 0x01231384, 0x85260126, 0xdafe2113, 0x87821582, 0x971c1c21, 0x839f851d,
    0x05bb4845, 0x80060024, 0x83828005, 0x44002b29, 0x15010000, 0x852b0614, 0x26222404, 0x8323013d, 0x36342404, 0x8335013b, 0x16322804, 0x3233011d,
    0x4910011e, 0x00200565, 0x2c176549, 0x0d130004, 0x400d13e0, 0x0de0130d, 0x490a8a13, 0x4b210c7b, 0x177b4935, 0x90e00221, 0x22448339, 0x497201e6,
    0xb5220890, 0x90494b6a, 0x24d38b16, 0x0017000f, 0x21d38530, 0xc9852123, 0xa6213321, 0xc0fd21bf, 0x0220ba83, 0xb5ab8982, 0x1320f484, 0x2b08a9a7,
    0x00020000, 0x0680ff00, 0x00000600, 0x00350029, 0x02140100, 0x24200406, 0x34350226, 0x16363712, 0x07061617, 0x1415010e, 0x3e32021e, 0x41081282,
    0x012e2726, 0x17013e37, 0x11011216, 0x26220614, 0x36341135, 0x00061632, 0xe4fece7a, 0xe4fec8fe, 0x92a17ace, 0x201f692b, 0x6b622a0f, 0xd0bd8a51,
    0x6b518abd, 0x200f2a62, 0x922a6a1f, 0x4c80fda1, 0x02824c68, 0x9c800222, 0x7a322983, 0x9c1c01ce, 0x6d4201b6, 0x2a2b0e20, 0xd64a2069, 0x2e826879,
    0x68353582, 0x204ad679, 0x0e2b2a69, 0xbefe6d20, 0x80fd4a02, 0x344c4c34, 0x20058302, 0x20008200, 0x080f4a05, 0x26092f48, 0x14152500, 0x41012b06,
    0x3b24055f, 0x25163201, 0x0f839d82, 0x0f939f83, 0x1f8bbd83, 0x00250f90, 0x0ec00e12, 0x21048412, 0x0bad8001, 0x38876020, 0xfe721222, 0x01210a84,
    0x21498240, 0x0b84fdf2, 0x0b830220, 0xfc720122, 0x0e210683, 0x22128303, 0x84faf201, 0x8305200c, 0x41df820c, 0x0530068f, 0x00070080, 0x0000006e,
    0x06222634, 0x01321614, 0x0f2de182, 0x16070601, 0x07141617, 0x2223010e, 0x210c822f, 0xf5840706, 0x26012f3e, 0x23060727, 0x27262722, 0x37343526,
    0x2637013e, 0x012e012f, 0x3634013d, 0x3736013f, 0x33221587, 0x0d821f32, 0x3637362f, 0x1632013b, 0x1716011f, 0x32333637, 0x20508217, 0x20518315,
    0x08128207, 0x04011e45, 0x96d49600, 0x9602d496, 0x13b90c10, 0x0a482314, 0x16901b09, 0x2c8a0e0c, 0x070d102f, 0x150ede1d, 0x29311c01, 0x0e0f0a8d,
    0x07277e0b, 0x12480f08, 0x0db70e1b, 0xba0b1010, 0x4328190e, 0x911a090a, 0x8d0d0d16, 0x098e262c, 0x810c0d0f, 0x212c8424, 0x2c820f1a, 0x83160221,
    0x962e0861, 0x0cde6d01, 0x361c0216, 0x0c583225, 0x8e250a1a, 0x0f176c09, 0x111c3288, 0x1510b80d, 0x720b096b, 0x0c0d0a36, 0x195b150b, 0x021b3132,
    0x2b840d15, 0x392e2e2b, 0x0a0c0c51, 0x0a8f240d, 0x242c8b6b, 0x0833770a, 0x2b2c850e, 0x15021c30, 0x00060000, 0x0580ff00, 0x26098348, 0x0043003b,
    0x41000067, 0x05200fe5, 0x8f0e2542, 0x1113380f, 0x1e141121, 0x32213301, 0x2101013e, 0x21272627, 0x15050706, 0x482b0614, 0x9d4409b0, 0x21332306,
    0x27833e37, 0x011f162c, 0x02163221, 0x400e1200, 0x0484120e, 0x0b960120, 0xfc802108, 0x030f0e80, 0x0f034003, 0x0160fd0e, 0x0a0730c0, 0x070ac3fe,
    0x0e126f03, 0xfc425e60, 0x605e42c0, 0x01314083, 0x4e0f4635, 0x28400128, 0x01460f4e, 0x03120e35, 0x0a464220, 0x0b960e20, 0x031efd32, 0x164cfcb4,
    0x25111125, 0x09754a04, 0x95090202, 0xfc278d82, 0x7579534c, 0x84b80353, 0x25a72795, 0xa7253434, 0x00820012, 0x1a00022c, 0x66060000, 0x13000305,
    0x23413500, 0x21232105, 0x2120f882, 0x3805dd43, 0x16010935, 0x07060737, 0x09272223, 0x26270601, 0x3626012f, 0x32360137, 0x078f451f, 0x11153b08,
    0x05011e17, 0xfe1a2680, 0xfe00ff80, 0x01261a80, 0x3f023f02, 0x083edf01, 0x080d030d, 0x4cfd4cfd, 0x080d0c0c, 0x0a02083e, 0x5820cf02, 0x0e12f420,
    0xdb120ec0, 0x2002020a, 0x2c8220fe, 0x82fe8021, 0x0129083a, 0x010401e0, 0x26feda01, 0x094a4102, 0x41020702, 0x0108bffd, 0x0a4a0902, 0x5702081b,
    0xc3cc1a1a, 0x0e12120e, 0x08b668fe, 0x075b451b, 0x00060022, 0x1a28af82, 0x00002300, 0x15011e01, 0x290e604a, 0x21110717, 0x26012726, 0xc5841101,
    0x11212908, 0x281cbc05, 0xc0fa2838, 0x28383828, 0x60288003, 0x7801841c, 0xc7fe0c0a, 0xfe63010c, 0xfd382860, 0x1c840400, 0x80fb2860, 0x06211f83,
    0x322a8240, 0x88fe441c, 0x39010c1d, 0x0412fa0c, 0x01283800, 0x8200faa0, 0x00032e00, 0x0680ff00, 0x00800500, 0x00200014, 0x072d412c, 0x20077744,
    0x05a14611, 0x2e10003b, 0x010e2001, 0x20011e10, 0x02100036, 0x02242004, 0x20241210, 0x12800304, 0x0511440e, 0x12e02608, 0x120e400e, 0xfa92a001,
    0x92fad8fe, 0x2801fa92, 0xce7201fa, 0x5efe9ffe, 0xcece9ffe, 0xa2016101, 0xe0036101, 0x084342fe, 0xff826020, 0x82fefd21, 0x842b8225, 0x5f022131,
    0xce312a8b, 0x000000ce, 0x00320002, 0x054e0700, 0x00110000, 0x37998243, 0x012e0335, 0x0622012b, 0x06150307, 0x32013b16, 0x23140136, 0x27363221,
    0x23211682, 0x2a168321, 0x21331606, 0x37343522, 0x82013e01, 0x0f062208, 0x23268501, 0x012e012f, 0x163d2882, 0x04160117, 0x14011857, 0x140dba0d,
    0x12011801, 0x120cf40c, 0xfd2ef602, 0x01120d40, 0x21168214, 0x1782f0fe, 0x1201142e, 0x2e40fd0d, 0x08a1011a, 0x53011424, 0x0f201182, 0xa6201182,
    0x0f202282, 0x013d2282, 0x08241453, 0x021aa101, 0x4001041c, 0x0d13130d, 0x0c04c0fe, 0x39fe1010, 0x010d1349, 0x20108300, 0x290582ff, 0x043e3649,
    0x131c1314, 0xe582c00d, 0x0dc00e22, 0xfb240a82, 0x04003eec, 0x0023d382, 0x82068006, 0x0f0028d4, 0x3d002500, 0x45240000, 0x0787060b, 0xf6411320,
    0x1617350c, 0x21013f32, 0x16011632, 0x22060107, 0x37260127, 0x11213336, 0x2405ab4b, 0x32211115, 0x05415205, 0x26260123, 0x08028234, 0x2838a62e,
    0x382840fa, 0xd1012838, 0x3a9c3a87, 0x28d00188, 0x11bbfe38, 0x1240fe1f, 0x40fe1236, 0x2a11111f, 0x1a260001, 0x261a0001, 0xa62a0001, 0x38853283,
    0x20012622, 0x3a09694b, 0x88383888, 0x29110238, 0x1340fe1d, 0x1dc00113, 0xc0012729, 0x1a26261a, 0x420040fe, 0x1828092b, 0x30002400, 0x14010000,
    0x3b219788, 0x062a4201, 0x33111525, 0x42021632, 0x3e24062c, 0x04261001, 0x330a2f42, 0xfe0a6004, 0x0b180bc1, 0x080fc0fe, 0x12c01608, 0x120ec00e,
    0xcc200282, 0x21083342, 0x35429292, 0x60023710, 0xc1fe0c0c, 0x40010909, 0x01141310, 0x12120e60, 0x12a0fe0e, 0x69423202, 0x42bd200a, 0xab92103a,
    0x4705e344, 0x232a0522, 0x34352622, 0x32360137, 0xab990117, 0xa18a5e20, 0x3f010a22, 0x0123b682, 0x9cd20f40, 0x149423aa, 0xa083a0fe, 0x1260012e,
    0x010c0c0e, 0xfe09093f, 0xf90110c0, 0x0221aa9a, 0x38008200, 0x00050006, 0x23000d00, 0x21010000, 0x0327012e, 0x010e0321, 0x21172107, 0x090d4225,
    0x45133721, 0x172d058d, 0xff031613, 0x03013c01, 0x3cfdd401, 0x080682d4, 0x5f3c0121, 0x60024001, 0x80fa1a26, 0xee19261a, 0x031a350a, 0x0a351a40,
    0x400219ee, 0x01020b03, 0x8210fef0, 0xa2c03406, 0x261a1efe, 0xe2011a26, 0x28023d3e, 0x19222219, 0x413dd8fd, 0x0f240a23, 0x27001b00, 0x142f8882,
    0x23060107, 0x35262722, 0x36373411, 0x43160117, 0x042e16f6, 0xe0fd20a0, 0x1010110f, 0x1f212020, 0xf4432002, 0xa502321c, 0xc0fe124a, 0x25130809,
    0x13258002, 0xc0fe1312, 0x1bf543cb, 0x8f440120, 0x44332008, 0x2739088b, 0x26013f26, 0x020e2223, 0x33021e14, 0x36373632, 0x011f3237, 0x0607011e,
    0x088a5404, 0x04323323, 0x2db18217, 0x26000616, 0x2a40fe1a, 0x8a1f1111, 0x7c49c994, 0xd4772e07, 0x0f100749, 0x0109890a, 0xcafe6d08, 0x09aa49ac,
    0x13019332, 0x291d826b, 0xfe000527, 0x28261a40, 0x898a1e27, 0x3a06e249, 0x020a5f68, 0x19088a09, 0x7a91840a, 0x011c01ce, 0xce1c0138, 0x81656f7a,
    0x4a11111f, 0x0531085f, 0x00240080, 0x01000047, 0x00020714, 0x27242221, 0x063e4a07, 0x32213325, 0x820f1416, 0x24ac85a1, 0x32013b36, 0x07d84316,
    0xca843420, 0x48070621, 0x3d2406e7, 0x21001201, 0x2708bb84, 0xe7051632, 0x68fe4001, 0xfe92eefe, 0x13816bef, 0x1a262634, 0x261ac001, 0xb4478913,
    0x46e88661, 0x16082a0b, 0x19130dc0, 0x1582df83, 0x1486de82, 0x130dc72c, 0x019a0141, 0x14019213, 0x3682826b, 0x05e0012b, 0xfef4fe02, 0x81666eb3,
    0x2d428513, 0x89133426, 0x72824842, 0x13176411, 0xea831303, 0x8a211182, 0x25108589, 0x0c01070d, 0xda824d01, 0x00261322, 0x08200082, 0x2214a34e,
    0x827f006f, 0x0e914ae7, 0x0f9e3520, 0x830f2d50, 0x0a314c2f, 0x0f8f1620, 0xb5521320, 0x0d0b450e, 0x01163223, 0x05084c80, 0x0d400d23, 0x20099313,
    0x201f8204, 0x211b84fc, 0x2183c003, 0x24820b95, 0x2484fa20, 0x24820520, 0xd7558020, 0x6001210b, 0xf3205888, 0xfd200992, 0x13891493, 0x0333fd22,
    0xfc203484, 0x13225682, 0xf0554d04, 0x0002210b, 0x04310082, 0x00800580, 0x001f0007, 0x35210100, 0x06222634, 0x09724915, 0x3b36342b, 0x00343501,
    0x011d0020, 0x27e78233, 0x96000240, 0x400396d4, 0x0807744f, 0x08012039, 0x08017001, 0x03382820, 0x966ac000, 0xe0fe6a96, 0x3828c0fd, 0x40022838,
    0xb8c03828, 0xf8fe0801, 0x0038c0b8, 0x40000200, 0x000780ff, 0x11008005, 0x00003700, 0x4a071401, 0x2626080d, 0x32363435, 0x0f820516, 0x23060727,
    0x23022e22, 0x050e5622, 0x37341125, 0x82363736, 0x16172574, 0x023e3233, 0x40227d84, 0xc9820d13, 0x4b405408, 0xc0054b6a, 0x9ad71b19, 0x8b5c7d3d,
    0xf0fec049, 0x261a1011, 0xec3a151f, 0x7eba6bb9, 0x7f363226, 0x1a0d535d, 0x48000526, 0x0d0efb26, 0x040d1313, 0x354826f2, 0xfd754b4b, 0x0e1b1905,
    0x2c342c74, 0x1a260992, 0x1720e602, 0x3a781d0e, 0x342a133b, 0x8200262a, 0x27038294, 0x05800600, 0x004b0080, 0x0f24a182, 0x23010e02, 0x4c064742,
    0x1d3407d9, 0x17163201, 0x34353637, 0x04202402, 0x1f141502, 0x33013e01, 0x20062a4f, 0x25d18615, 0x2622013d, 0xd582022f, 0x27068658, 0x143c8006,
    0x588916b9, 0x3109a54a, 0x44227647, 0xd7feb01d, 0xd7feb2fe, 0x22441db0, 0x1b894776, 0x1689583e, 0x863c14b9, 0x013401e0, 0xe034014c, 0xa68a0286,
    0x53213194, 0x120e206b, 0x40020e12, 0x20320583, 0x5f0c3c47, 0x06019462, 0xfafe9c9c, 0x0c5f6294, 0x1d84473c, 0x84c0fd21, 0x536b2e1d, 0xa6943121,
    0xcd180197, 0xfecd7a7a, 0x26d785e8, 0x04000320, 0x821300e0, 0x23a5820c, 0x21012722, 0x08056f4a, 0x01213322, 0x03163236, 0x13342600, 0xfafeb3fe,
    0x1a26261a, 0x4d010601, 0x04263413, 0x1ac0fba0, 0x4d011326, 0x80221182, 0x1382261a, 0x82002621, 0x00022600, 0x04200000, 0x204b8480, 0x234d952d,
    0x07061400, 0x2a05cf57, 0x2e34033e, 0x36343503, 0x94173233, 0x80012b63, 0x0f0a4655, 0x2218261a, 0x03831822, 0x0f1a2624, 0x7892460a, 0x9812fe2f,
    0x25051c83, 0x151d151b, 0x2f422f19, 0x23078219, 0x1b05251b, 0x00298a82, 0xff000004, 0x058006b9, 0x24db8247, 0x0049002d, 0x2293ab6b, 0x86021004,
    0x363727a9, 0x34013e37, 0x01822726, 0x1b8aaf86, 0x82013e21, 0x1236231e, 0x1e820210, 0x27012e23, 0x08d1af26, 0xaa55012a, 0x1b0c0d8c, 0x14382726,
    0x4a53534a, 0x26273814, 0x8c0d0d1a, 0xd3feaa01, 0x261a0d0d, 0x071f0727, 0x8a7b242e, 0x2e247b8a, 0x1c840a82, 0x0541d320, 0xfe373f29, 0x3bfdfece,
    0x271a2605, 0x360f1d14, 0x36a3b8a3, 0x27141d0f, 0x3b05261a, 0xfe34feb6, 0x19825b7f, 0x04172430, 0x1a19040d, 0x0110015b, 0x5b100132, 0x0e82191a,
    0x82241721, 0x005b2322, 0x0082000c, 0x80052208, 0x03008005, 0x0b000700, 0x13000f00, 0x1b001700, 0x23001f00, 0x33002f00, 0x00003700, 0x35231501,
    0x20038213, 0x22038221, 0x84112101, 0x20078301, 0x830a8201, 0x2b17831b, 0x35211113, 0x11231123, 0x35331521, 0x21201783, 0x80201b83, 0x03270082,
    0x80fc8080, 0x84fe8001, 0x00032103, 0xff250983, 0x0480fd00, 0x20108280, 0x84168280, 0x80fd2207, 0x208182fd, 0x211284fd, 0x35820003, 0x01fc8025,
    0x82017f01, 0x8337830f, 0x8002221d, 0x221784fe, 0x83fe0002, 0x82022035, 0x82032023, 0x80022546, 0x800280fd, 0x0021c182, 0x081b4610, 0x2722c791,
    0xcb862b00, 0x3f003b29, 0x23330000, 0xba133311, 0x823f2003, 0x20202500, 0x9d1f1f5e, 0x3e250282, 0x1f1f7e3e, 0x2202843f, 0x823f3f9d, 0x3f7e2202,
    0x2602823f, 0xbd3f3f5e, 0x823f5e5e, 0x3f3f2726, 0x81fa8005, 0x03b47f05, 0x83058021, 0x000226dc, 0x0595ff00, 0x220b82eb, 0x501d0007, 0x11490aa3,
    0x2e012206, 0x07455c01, 0x01172208, 0x4bc00116, 0x6a4b4b6a, 0xfe257604, 0x35342715, 0x2635fd25, 0x01344c35, 0x268035a0, 0x0425cb02, 0x361c830b,
    0x3540fe4b, 0x2514fe25, 0x25cc0225, 0xa0013580, 0x26354c34, 0x822736fd, 0x0300215a, 0x07216b83, 0x206b866b, 0x206d9f35, 0x26838505, 0x36012726,
    0x82273435, 0x33232389, 0x85a01632, 0x84800121, 0x2e24259c, 0x25d6011e, 0x8022a183, 0x9fa2e035, 0xb482cd82, 0x821f1c21, 0x236c8234, 0x3526ca02,
    0x0326b685, 0x80ff0a00, 0xb3827906, 0x6400543e, 0x00007400, 0x01071601, 0x2123010e, 0x26272622, 0x37363437, 0x3e372636, 0x013e3702, 0x01200884,
    0x1a820890, 0x07170626, 0x32213336, 0x07233787, 0x82161706, 0x3736270e, 0x16273601, 0x0b840605, 0x36013f23, 0x09ca4d26, 0x88363221, 0x0666080f,
    0xfe162867, 0x417313ed, 0x8f4d65fc, 0x0616181c, 0x01080101, 0x06150c02, 0x03082c17, 0x1c030205, 0x042a1503, 0x04040701, 0x2f130424, 0x02080104,
    0x06160e02, 0x130d1108, 0x1c272114, 0x020d2601, 0x16504af9, 0x4724eefe, 0x1b9bfc5d, 0x180a0b0b, 0x1d9b0378, 0x2c010836, 0xfb260207, 0x0e0c04ed,
    0x190d6002, 0x08821504, 0x82a0fd21, 0x90682008, 0x044d0811, 0xfc483922, 0x6b574076, 0x043c434e, 0x1b080e2e, 0x1b140b06, 0x266b260a, 0x0b08280a,
    0x70240622, 0x052e0922, 0x1a05230d, 0x23082675, 0x1a140809, 0x21250c08, 0x01161927, 0x70090306, 0x7776fc4a, 0x1b100f45, 0x031a1f46, 0x0f2316db,
    0x08c0481e, 0x88c0fe21, 0x0000310a, 0xff000001, 0x05000597, 0x001c0080, 0x17320100, 0x21050550, 0xa8500607, 0x42058205, 0x37340584, 0x8c043336,
    0x27211517, 0x19132127, 0x47fe2330, 0x2f2447fe, 0x15330f85, 0x09800517, 0xfa22380d, 0x0d3822f7, 0xa8012008, 0x832158fe, 0x0905210f, 0x09210f82,
    0x20008200, 0x21638204, 0x8b440680, 0x000c2705, 0x003c0014, 0x4c442900, 0x22232605, 0x21013d26, 0x06904e00, 0x56113721, 0xb14906b2, 0x471c8205,
    0x7d4e059e, 0x011f2106, 0x33279c83, 0x80011632, 0x82fc8003, 0x28a02603, 0x0480fd38, 0x05884e80, 0xe00d1322, 0x3c05bb48, 0x71130de0, 0x2838404f,
    0x6028a002, 0x281c981c, 0x01714f40, 0x01800100, 0xa0283880, 0x252b84fd, 0x60fe4026, 0x3d82130d, 0x132a1182, 0x4fa0010d, 0x28200271, 0x2c822838,
    0xff286026, 0x03007100, 0x0729af83, 0x00000680, 0x00210007, 0x29c18229, 0x06141632, 0x01342622, 0x23511632, 0x013b210b, 0x5708ae52, 0x102f0647,
    0xa9ee4903, 0x03a9eea9, 0x96966ae0, 0x8380fa6a, 0x33e02c05, 0x02356513, 0x13653500, 0x5667fd33, 0x032109f9, 0x26278260, 0x4902eea9, 0x84fc6a96,
    0x82032027, 0x31882805, 0x88314747, 0x600180fb, 0x9b4708b3, 0x41ff2006, 0x072c053f, 0x00005000, 0x16320301, 0x26373233, 0x042f7d82, 0x3b011337,
    0x13171601, 0x1e171216, 0x84161701, 0x15200804, 0x22150614, 0x04222326, 0x013f3407, 0x35053e32, 0x27012e34, 0x15020625, 0x33031e14, 0x07141516,
    0x99081c83, 0x02062306, 0xcf21aad5, 0x57261339, 0x1702cafc, 0x26333042, 0x1801ed0c, 0x0308354b, 0x299221cd, 0x141d560f, 0x0f8a130f, 0xfe3f0106,
    0xeafe4c40, 0x01830427, 0x09150817, 0x523e050d, 0x1a3efe01, 0x263b1c65, 0x0201034c, 0x083ae93a, 0x03500325, 0x043efed1, 0x76fcfd02, 0x0a0b074f,
    0x021f2713, 0x0ed40268, 0x4e20fe07, 0x225f99fe, 0x0c2d3add, 0x26061d0f, 0x04110513, 0x2b010e10, 0x02051c23, 0x0c0a0607, 0xc2a11008, 0xfe3a0203,
    0x1f1619ed, 0x13080912, 0x14120927, 0xf7570e08, 0x05802105, 0x00330182, 0x002b0015, 0x25000061, 0x11203316, 0x042e2734, 0x82072223, 0x061429dc,
    0x1603011e, 0x023e3233, 0x0220da82, 0xd5821383, 0x14150625, 0x823e3701, 0x3c042402, 0x82103501, 0x012f252b, 0x32332436, 0x1e282682, 0x0e141503,
    0x011e0703, 0x23200683, 0xcb08fc83, 0x4a2b0204, 0x29780142, 0x5f42451b, 0x1c493a49, 0x08010201, 0x52432a06, 0x3a33627a, 0x32427464, 0xfd010850,
    0x8c0f02e4, 0x060b0724, 0x04160105, 0x332e3524, 0x01620405, 0x5a1783e4, 0x7c854617, 0x2d21385c, 0x9a353e54, 0x9f7546cd, 0xb02c5ca8, 0x6efe6a2c,
    0x4f01200f, 0x3c2c4272, 0x0a041121, 0x0834d435, 0x025d4a77, 0x3f1a07d6, 0x69465474, 0x320d1c3b, 0x6a1b33ca, 0x70fc2e1a, 0x0f18045e, 0x1c251e0c,
    0x0532152f, 0x082bd603, 0x0405090d, 0x13025301, 0x543a1a01, 0x57344b7d, 0x18203a39, 0x6495c623, 0x1c45669f, 0x01001606, 0x80ff0000, 0x80050004,
    0x00003a00, 0x023e3715, 0x36373637, 0x3527011a, 0x3727022e, 0x3233021e, 0x0624f282, 0x07010e07, 0x0621e182, 0x27058202, 0x1716011f, 0x06220706,
    0x7208e883, 0x06222326, 0x414f1611, 0x010d1c1b, 0x18016a7a, 0x13134e3d, 0x3a7dae21, 0x1c8d6530, 0x8f1e0e05, 0x060c0825, 0x791b0209, 0x12160211,
    0x1101010e, 0x0b0d03a8, 0x741d0b2b, 0x33448a1c, 0x07557eb8, 0x230e1313, 0x34020742, 0x19230b02, 0x03050b0d, 0x05090267, 0x27020905, 0x0f250a32,
    0x3a212f13, 0xe1fd940d, 0x52620954, 0x04120f55, 0x03372c1b, 0x42120214, 0xfa2009af, 0x1b28b382, 0x00007d00, 0x0f163225, 0x23050d5b, 0x11013b36,
    0x3f239782, 0x82323601, 0x2b0634a6, 0x17011101, 0x36323316, 0x33163233, 0x3e163221, 0x82013f02, 0x15162709, 0x07060714, 0xe1822726, 0x83032e21,
    0x062229c7, 0x14170607, 0x06141512, 0x8207e042, 0x8224204f, 0x262333db, 0x023e013d, 0x34113637, 0x34013d02, 0x012e3436, 0x16822627, 0x020e0722,
    0x11283e82, 0x1221d006, 0x3a147e14, 0x12230382, 0x8b505021, 0xf959080c, 0xc70c36d1, 0x242cb02c, 0x2501248f, 0x150b1e06, 0x042a080e, 0x05020414,
    0x1d191d27, 0x010d1003, 0x07130c06, 0x6311021d, 0x09204e32, 0x05050401, 0x24a8280a, 0x4c220305, 0x3241e4fe, 0x110333ca, 0x13186c59, 0x04020106,
    0x21970b03, 0x1e131478, 0x0e2a1a21, 0xa21a2580, 0x2202821a, 0x87000425, 0xfc690809, 0x1bff0400, 0x01010405, 0x0b0d0501, 0xe0700101, 0x040e1d50,
    0x4e09542c, 0x09080145, 0x01010203, 0x37510404, 0xa1b4fd5e, 0x21486f10, 0x28102b15, 0x010f0e0a, 0x33121402, 0x201b0901, 0x012a0e1a, 0x94016555,
    0x1b027565, 0x04141c17, 0x0d0e180c, 0x1a026777, 0x007f0112, 0x00000200, 0x000603ff, 0x61008005, 0x00009500, 0x06474113, 0x17042423, 0x0e444116,
    0x27263530, 0x26222326, 0x06070622, 0x1435011f, 0x4741011e, 0x023e2418, 0x83352634, 0x013e2102, 0x360d4941, 0x021e3201, 0x07141617, 0x2223030e,
    0x3634012e, 0x16142135, 0x82010e14, 0x2702340c, 0x3e373426, 0x1e323303, 0x15061401, 0x34263421, 0x4151013e, 0x4627055b, 0x00016101, 0x41172177,
    0x0e2e0b58, 0x3d05110a, 0x6c507e1e, 0x0101092a, 0x57410102, 0x09072e14, 0x01050103, 0x04050101, 0xf429970b, 0x055b4110, 0x0c1e0537, 0x0440373c,
    0x40041a1a, 0x0d0c3c37, 0xfc03050f, 0x0f050300, 0x20158f0d, 0x29158304, 0x051b7f05, 0x04010204, 0x72412001, 0x464d300a, 0x02060d01, 0x51050402,
    0x37349837, 0x4148a2c6, 0x30081572, 0x87af7410, 0x1d0703ac, 0x484a0708, 0x0c053651, 0x770c0b1b, 0x121a0268, 0xfffa7f01, 0x03362c27, 0x03153815,
    0x15272c36, 0x02231f24, 0x241f2302, 0x22149415, 0x50040000, 0x002110d3, 0x3ee96025, 0x2600072a, 0x1a80f91a, 0x061a2626, 0xfe250582, 0xfb1a2680,
    0x200d8300, 0x20058205, 0x201b8201, 0x200d84fa, 0x84058206, 0x2029841b, 0x20058204, 0x09bd62c0, 0x0a9e6620, 0xfc20b7e6, 0x03208684, 0xb7840582,
    0x05200d84, 0xfd20d386, 0x02200d84, 0xa360b7d2, 0x410f9f0f, 0x6d410d6f, 0x1a26210b, 0x82096b41, 0x35694117, 0x9f246b41, 0x8f1f8fa3, 0x092f42b3,
    0x8b0b3b42, 0x2c1d420b, 0x53000021, 0x3d5e1aab, 0x5e9b830f, 0x0f8f0b4d, 0x600fab53, 0x342509ac, 0x32013b36, 0x8f1f8f16, 0x260f8feb, 0x0d130001,
    0x98130dc0, 0x82062004, 0x84fa201f, 0x40052420, 0x8afa130d, 0x21198d2d, 0x25890d13, 0xe0200b8b, 0x01215c88, 0x210a9373, 0x1588f3fc, 0x20890420,
    0x3695158a, 0x05000022, 0x20102b44, 0x05ed504f, 0x27222329, 0x37342601, 0x41333601, 0x1d41310d, 0x13802f10, 0xfe090e0d, 0x010909e0, 0x0d0e0920,
    0x0f820513, 0x0d40f926, 0x060d1313, 0xfb20b684, 0x04200584, 0x0b8b1184, 0x03222389, 0x2382fde0, 0x1c203e83, 0x13200483, 0xef8ad9a0, 0x0024e395,
    0x06010714, 0x2306e64b, 0x09173233, 0x902ff141, 0x836020e3, 0x83dc82e0, 0x200125ea, 0x0d13a905, 0x0222e2ad, 0x41831cce, 0x020d1325, 0x82130d40,
    0x09fe2109, 0x4113e841, 0x012017c7, 0x2806c741, 0x001f0000, 0x14110100, 0x20db8207, 0x4fd38727, 0x1d2307ca, 0x82360101, 0x162708eb, 0x0d270007,
    0xfe121b0c, 0xfd77a96d, 0xa9a97740, 0x77c00277, 0x129301a9, 0x270d0c1b, 0xc0fba004, 0x1305112a, 0x87a69301, 0x77a92719, 0x139201a5, 0x62831105,
    0x9f4c0420, 0x80052905, 0x0e000700, 0x2e001e00, 0x142f1482, 0x34262206, 0x11013236, 0x17013521, 0x69210109, 0x788209b8, 0x5b172621, 0x32340ce2,
    0x70800216, 0xa07070a0, 0x80fa7004, 0x02a04001, 0xf9000200, 0x0620e884, 0x1321f682, 0x0b056993, 0x83100421, 0xfd702528, 0xc040fec0, 0x01242a84,
    0xfb0d1320, 0x0d212683, 0x28328204, 0x4240fb20, 0x04425e5e, 0x200582c0, 0x08978400, 0x05eb0523, 0x0006006b, 0x00190014, 0x21000025, 0x15072737,
    0x34011533, 0x01072223, 0x33141506, 0x36013732, 0x3a9f8227, 0x0f140111, 0x36370101, 0x011f3233, 0x5b6b0116, 0x02805beb, 0x070a1676, 0x8207e2fd,
    0x1e023605, 0xa0013607, 0x60fec0fc, 0xa625eb05, 0x24a660fe, 0xeb263536, 0x24258225, 0xa003806b, 0x22258316, 0x8207160a, 0xfeca3325, 0x01c0fc60,
    0x35e002a0, 0xa001a625, 0xea2626a5, 0xcd820027, 0x2207334b, 0x50170007, 0x0e2c0de9, 0x27262201, 0x34352601, 0x03002000, 0x3305a461, 0xfe219601,
    0x483f1094, 0x93fe0f3f, 0x012c0121, 0x032c01a8, 0x31065b61, 0xfc466d00, 0x262621fa, 0x46060321, 0x2c01d46d, 0x5b85d4fe, 0x05000631, 0x00070080,
    0x25000013, 0x010e2211, 0x5e011e10, 0x00270ca0, 0x9292fa94, 0x5e9403fa, 0x60220e8a, 0x945b4004, 0xf1022105, 0x20113b5c, 0x05d84102, 0x00c0053b,
    0x002d0015, 0x27340100, 0x2627032e, 0x030e0722, 0x14150607, 0x25363216, 0x08b28214, 0x37343553, 0x3e37033e, 0x17163201, 0x1617031e, 0x01140002,
    0x071c161d, 0x07042204, 0x011d161c, 0x4b6a4b14, 0xd4fe0002, 0xd4fe58fe, 0x59710651, 0x32091c6e, 0x1c083334, 0x0671596e, 0x24800151, 0x212b0121,
    0x10101737, 0x2b213717, 0x35242101, 0xd4b54b4b, 0x31d782fe, 0x098291d4, 0x5dd98ba3, 0x1e22221e, 0xa38bd95d, 0xaf437f09, 0xf8063005, 0x06008005,
    0x39000e00, 0x48003e00, 0x41010000, 0x002805cd, 0x06010726, 0x13013716, 0x4206d048, 0x172706da, 0x0f161716, 0x6c270601, 0x5e080c36, 0x3f34013d,
    0x03163601, 0x11210109, 0x37010701, 0x011f3236, 0x78031416, 0x60749874, 0x11200002, 0x2011a2fe, 0x515e0111, 0xc0fc77a9, 0x77a9a977, 0x363f4003,
    0x0c03030f, 0x17120e31, 0x42c0fc16, 0x03425e5e, 0x095e4240, 0x60280f40, 0x60fd2001, 0x5c04e0fe, 0x5ce0fe5c, 0x981c501c, 0x8260011c, 0x60382346,
    0x4788c002, 0xbecffd22, 0x77254585, 0x100719a9, 0x21468211, 0x08620606, 0x425e2305, 0x45820d7e, 0xcd021025, 0x82fde0fe, 0x1c02264a, 0x5c20015c,
    0x2145821c, 0x00820050, 0x82000221, 0x80062900, 0x2b000006, 0x00005a00, 0x210d4b6b, 0x934c3231, 0x2b062205, 0x09574301, 0x3726d982, 0x17363736,
    0xbf5c1316, 0x013d3b05, 0x06072023, 0x06071613, 0x2e272223, 0x3e343504, 0x35013b07, 0x33363734, 0xf2821732, 0x87800521, 0xff0029e2, 0x4d1a130d,
    0x70060a38, 0x3408dd87, 0x101a1c12, 0xfeed1513, 0x0c1b1280, 0xfea0270d, 0x2d7773bd, 0x04081703, 0x160a0a10, 0x07232a39, 0x4e3b2315, 0x6ab58a6f,
    0x0c0d27a0, 0x8001131a, 0xfe230213, 0x26e787fd, 0x051b0d13, 0x8704221a, 0xd62c08e5, 0x180d0a13, 0x01090810, 0x1380fedc, 0xc02a1105, 0xb0fe8983,
    0x0d020b17, 0x6067220e, 0x54313884, 0x41535060, 0xc016273a, 0x1305112a, 0x34222282, 0xfb850000, 0x80057f26, 0x44002f00, 0x3220fb8f, 0x8206d641,
    0x12d841d4, 0xff83db82, 0x68272221, 0xee890fe5, 0x2308d141, 0x06030d0a, 0x2f0dd341, 0x06060d0a, 0xd2fce714, 0xfe184218, 0x6e181852, 0x01230782,
    0x82870207, 0x186e2506, 0xc2fe5e02, 0x210dca41, 0xca41020a, 0x0dfe2808, 0x030a4009, 0x82d40108, 0x0118223b, 0x223084ae, 0x82f9fe18, 0x2044833a,
    0x2a008200, 0xff000001, 0x06000700, 0x82430000, 0x07142c0d, 0x26220601, 0x1121013d, 0x84163233, 0x27b0830c, 0x11013b36, 0x06141521, 0x3725bd84,
    0x16323601, 0x2221821d, 0x5f262223, 0x142207a6, 0x21822b06, 0x36343532, 0x07011732, 0x00ff1300, 0xfe263413, 0x261a8080, 0x04830a84, 0x801a2626,
    0x342680fe, 0x13210a83, 0x201e8301, 0x831e8401, 0x820f830a, 0x8301201e, 0x0001231e, 0x24849a02, 0x13202fa8, 0x07506d8d, 0x001d290a, 0x16360100,
    0x06141115, 0x2720c382, 0x49086d5b, 0x152d0533, 0x03373611, 0x1a1a13d3, 0x093afd13, 0x093c6f04, 0x05090436, 0x1a0c1373, 0x0c1a40fa, 0x09c60213,
    0x1a5afd0a, 0x051a2626, 0x2625ca82, 0x0a5afd1a, 0x255f8509, 0x80050007, 0x5f8f2b00, 0x84846696, 0x06373622, 0x73916d88, 0x13c60223, 0x2079901a,
    0x8282963a, 0x1a0c232c, 0x8b843afd, 0x52ff7a21, 0x192005ef, 0x34218b92, 0x20798737, 0x83e78753, 0x82132079, 0x216d98d7, 0x1d833413, 0xeb845e86,
    0x057c2b08, 0x0084057f, 0x0900000b, 0x35260601, 0x17363411, 0x05141601, 0x17d0fa68, 0x05172121, 0x61021730, 0x140d1efd, 0x1ac0051a, 0x09820d14,
    0x68002421, 0x0f200c53, 0x2106e147, 0x6f5b2306, 0x16322208, 0x0e644705, 0x2600062a, 0x1a00fe1a, 0x021a2626, 0xfc210582, 0x220d8b80, 0x4cfa4005,
    0x262108f5, 0x820b8a1a, 0x05eb4166, 0x05000625, 0x430f0080, 0x1620108d, 0x2f895583, 0x3b89478c, 0x80050627, 0x00001900, 0x20da8817, 0x20e18617,
    0x2aed8407, 0x132d0706, 0x02131a1a, 0x830409c6, 0x13132a05, 0x1a133afd, 0x13730904, 0x20f0830c, 0x240e820c, 0xc6020a09, 0x2108831a, 0x0d823413,
    0x02231782, 0x88090ac6, 0x0727425f, 0x66835f90, 0x55013b21, 0xf5620525, 0x94062005, 0x0d9a4271, 0x86827d99, 0x261aa622, 0x23072041, 0x090aa602,
    0x0c212b82, 0x238c861a, 0xff000001, 0x20051b53, 0x8feb8f1d, 0x43ef8884, 0xef8d0b12, 0x0024688e, 0x00020000, 0x062a6182, 0x00060501, 0x001b000b,
    0xbb631300, 0x23062405, 0x5d262221, 0xec850967, 0xc6020e22, 0x25076342, 0x0c1a40fa, 0xa241c605, 0x02262209, 0x201c822d, 0x23b88213, 0xe6fd1a1a,
    0x25050b65, 0x00ff1a26, 0x6282261a, 0x9a2f6182, 0xa6049aff, 0x1400e605, 0x02090000, 0x650f1416, 0x34210575, 0x05245337, 0x93041429, 0x1302edfd,
    0x82a61313, 0x1afd255f, 0xe6021313, 0xa6270882, 0xfdd30413, 0x84edfded, 0x8212850a, 0x85238317, 0x825a2053, 0x86662053, 0x10886e53, 0x14160124,
    0x4a825304, 0x2f823420, 0x13021322, 0x5c844582, 0x02214082, 0x85168293, 0x8518820c, 0x2011825c, 0x0cfb4234, 0x2f00232b, 0x35010000, 0x21232634,
    0x05527411, 0x21111522, 0x2c055774, 0x14112133, 0x32013b16, 0x21113536, 0x0cb46732, 0x83c00421, 0x1a2624f2, 0x83261a80, 0x1a2623f9, 0x0c840001,
    0x1a000125, 0x49400126, 0x02210e28, 0x83268240, 0x21339119, 0x3a492b01, 0x0002210e, 0x22074b68, 0x871b000f, 0x918d8797, 0x82fd2083, 0x1a26226f,
    0x84759803, 0x90262094, 0x0b7f6365, 0x37002b22, 0x34256782, 0x3637012f, 0x25058235, 0x0f222326, 0x05842701, 0x14150625, 0x8407011f, 0x33162505,
    0x17013f32, 0x07410584, 0x137d290d, 0x1313b5b5, 0x1a1b135a, 0x1a210883, 0x910a821b, 0x83012111, 0x210e1141, 0x2e9b9e01, 0x01214086, 0x181b41ce,
    0x23001722, 0x2622b385, 0xac820722, 0xa582b182, 0x82011721, 0x0137239f, 0x2c67013e, 0x0405290a, 0x34135b12, 0xe268fe13, 0x5b250582, 0x6a011212,
    0x23a38213, 0xfc121f02, 0x0329918e, 0x5a121c22, 0x69fe1313, 0x27cd82e2, 0x121b1c12, 0x131396fe, 0x4a202782, 0x0320838e, 0x250a9f41, 0x0046003a,
    0x47762500, 0x2e34270f, 0x07222301, 0x8d841f06, 0x3637362b, 0x15163233, 0x0e070614, 0x07a97601, 0x36343526, 0x24043e37, 0x0320a58a, 0x080b4b6e,
    0xa66f0024, 0x0f80f357, 0x0c078417, 0x21350910, 0x4b303422, 0x693f3028, 0x0ec00e12, 0x20212b12, 0x191f3a22, 0xbd8e8001, 0x5c6ea020, 0x02230808,
    0x529658ae, 0x641218d5, 0x18440c06, 0x26213418, 0x751c162e, 0x120e2443, 0x3d130e12, 0x31151213, 0x8e3d4a2f, 0x0ac366d2, 0x2e001e24, 0xd3873a00,
    0x85064a64, 0x231121b6, 0x20098442, 0x68f28e03, 0x00250c9d, 0x12600e12, 0x05d06a0e, 0x83606021, 0x82012077, 0x20e08a9c, 0x24bc9002, 0x02120ea0,
    0x82298300, 0xc0fe2308, 0x06820e12, 0x8e031222, 0x0a840583, 0xaf8fc120, 0x24092343, 0x005f002f, 0x090b7200, 0x27012e22, 0x25084f65, 0x3307010e,
    0xbc821632, 0x012b0625, 0x6217011e, 0x1d2406fb, 0x01013e01, 0x1f822384, 0x37822b88, 0xad6b2320, 0x013e2207, 0x822b8837, 0x32438237, 0x1a6dad04,
    0x6d1a2626, 0x266ca120, 0x261a801a, 0x8f20a16c, 0x73012710, 0x258f1a26, 0x1f84a1eb, 0x25eba123, 0x8e30838f, 0x44022010, 0x3d920521, 0x01214e88,
    0x965e822c, 0x2060863e, 0x0c6f6c00, 0x2f00232b, 0x00003b00, 0x22060701, 0x2404852f, 0x013f3426, 0x05017427, 0x9d4c1f20, 0x010f2507, 0x36141617,
    0x26178768, 0x1a0a9249, 0x8289890a, 0x0a922104, 0x0a200783, 0xcd200f8e, 0x211b8e6c, 0x3495c901, 0x19204488, 0x8c1ba868, 0x063b6dcb, 0x2f460920,
    0x013f2506, 0x011f3236, 0x16210484, 0x18446914, 0x5afe932a, 0xfe133413, 0x661313da, 0x93220782, 0x05821301, 0x7a136622, 0x0221b29b, 0x223382d3,
    0x84260113, 0x83132029, 0x203b8332, 0x3da7a6fa, 0x00090085, 0x00220012, 0x27340100, 0x32331601, 0x0105023e, 0x0e222326, 0x00141501, 0x23730210,
    0x06d77d05, 0x20054a08, 0x890efd57, 0x92c96fa0, 0x0219fc56, 0x94a587f3, 0x200592fa, 0xe3fecd7a, 0xe3fec8fe, 0xcd7a7acd, 0x38011d01, 0x02cd1d01,
    0xfd86a183, 0x9257590f, 0xf202bccb, 0x94fc925b, 0xfe3f01a2, 0xcee2fec6, 0x01ce7a7a, 0x013a011e, 0x8209831d, 0x40002972, 0x000635ff, 0x20004b05,
    0x152e0c82, 0x21230614, 0x0f141601, 0x22230601, 0x8c6b0127, 0x32332205, 0x3912821f, 0x32210107, 0x41000616, 0x0140fd34, 0x4b262625, 0x27343525,
    0x252575fd, 0x25828b02, 0x264b2634, 0x02dbfe26, 0x024134c0, 0x4b358080, 0x6c24dafe, 0x1b824c24, 0x25838c20, 0x268a0226, 0x6a264a26, 0x4b202082,
    0x00256282, 0x0535ff00, 0x526f86c0, 0x2f2505db, 0x37342601, 0x08b37401, 0x3f210d82, 0x05114e01, 0x25c00528, 0x342775fd, 0x5f822733, 0xfd25012b,
    0x41413440, 0xfec00234, 0x297f82db, 0x26353426, 0x02258b02, 0x22823640, 0x4b252522, 0x01236082, 0x82354b25, 0x2601217d, 0x30827d82, 0x2375fd22,
    0x35286f83, 0x4b0680ff, 0x21004005, 0xd8870c82, 0x4708114c, 0x352005f8, 0x24053f54, 0x06160117, 0x2449824b, 0xfe243635, 0x844a84da, 0x244a82c8,
    0x37238b02, 0x22ea8236, 0x9a350225, 0x2188828b, 0x00820027, 0x35000124, 0x7382b5ff, 0x22008022, 0x07207383, 0x86084c41, 0x08916dd6, 0x1f20e583,
    0xe5837484, 0x3f823520, 0x4a262637, 0x25353427, 0x344c2601, 0x014c3480, 0x34352526, 0x02254b27, 0x351b82c0, 0x02252574, 0x3536248c, 0x25254b26,
    0xc002dafe, 0x344c4c34, 0x228240fd, 0x824b2521, 0x00012a75, 0x0780ff00, 0x00c00500, 0x08cb4d2c, 0x23113534, 0x15050e22, 0x16141714, 0x23061415,
    0x022e2722, 0xeb820227, 0x33211222, 0xaf4d8282, 0xfe250805, 0x26341300, 0x999b62e0, 0x233e6271, 0x0f110505, 0x0c070c10, 0x357f030f, 0xe0c902a2,
    0x02133426, 0x349a0300, 0x08258213, 0x011a2621, 0x361f0c00, 0x65a07555, 0x23064437, 0x11140f09, 0x07221a09, 0xc7a61d01, 0x01930186, 0x82261a00,
    0x0b034825, 0x2f001722, 0x17218985, 0x09837b16, 0x26077e43, 0x06141101, 0x41012f22, 0x3424057e, 0x26270137, 0x28053d6f, 0xfe0af302, 0x261390b4,
    0x060d6b1a, 0x4c019028, 0x720a1a0a, 0x8a821703, 0xb4fe9022, 0x0a230b83, 0x834c010a, 0xc0012621, 0xed01261a, 0x212f841a, 0x9e822634, 0x13200f82,
    0x2e822f83, 0x3e834920, 0x30831320, 0x82720a21, 0x82308333, 0x2a8e8222, 0x0d000200, 0xf3058dff, 0x84007305, 0x2387979f, 0x01071400, 0x0321b793,
    0x96889500, 0x400221b7, 0x02218894, 0x83b69493, 0x8301209f, 0x80052504, 0x23008005, 0x42078f43, 0x214308ac, 0x08404208, 0x16322135, 0x28388005,
    0x283860fe, 0xfe3828c0, 0x38382860, 0x84a00128, 0xa001250c, 0x20033828, 0x2f841593, 0x6b826683, 0x05000224, 0x434d0380, 0x0e795b05, 0xfb215783,
    0x20508340, 0x84448204, 0x38578449, 0x01000038, 0x80ff7a00, 0x80050606, 0x00003500, 0x0f011e01, 0x27010e01, 0x31a68825, 0x2f260605, 0x37362601,
    0x012e012d, 0x013e013f, 0xaf880517, 0x1636253c, 0x0616011f, 0xca050507, 0x401a1b2e, 0xfe2e671a, 0x80344cf6, 0xf6fe4c34, 0x0f82672e, 0x012e1b23,
    0x850a820a, 0x0a01211a, 0x01211a84, 0x231a860a, 0xe601f6fe, 0x6e203182, 0x992d3982, 0x4c34cdfe, 0x3301344c, 0x2e1b1a99, 0x211f826e, 0x19879a9a,
    0x83330121, 0xcdfe2119, 0x00201988, 0x240a8b48, 0x001b000b, 0x22fa822d, 0x49120420, 0xa37f072a, 0x13032b0f, 0x2b262734, 0x06072201, 0xa84b1315,
    0x2f022605, 0x6101a201, 0x081e49ce, 0x12b20227, 0x140dc00d, 0x30048214, 0x0a120212, 0x0edc0e0a, 0x14110a0a, 0x130eb90e, 0x0f874805, 0xbeeffb39,
    0x0d14130e, 0x13140dbe, 0x6d026601, 0x0808060c, 0x93fd0c06, 0x820f0f0a, 0x82042085, 0x06003603, 0x00400500, 0x0016000d, 0x004a001f, 0x11352500,
    0x11152135, 0x2a798515, 0x26273301, 0x14062223, 0x82342416, 0x010f2307, 0x37763233, 0x08444f05, 0x29071758, 0x34262221, 0x1f323336, 0x05823701,
    0x14162c08, 0x32212306, 0xfea00316, 0xc01c24c0, 0x38fe241c, 0x2b1a7ec3, 0x02383828, 0x2b2838d8, 0x28c27d1a, 0x0e12b001, 0xfb283860, 0x493828c0,
    0xb82a054d, 0x5d83835d, 0x80803d6b, 0x09836b3d, 0x0eb80136, 0x0138b412, 0xfec0c0d4, 0x1b19382c, 0xa165031b, 0x3850381f, 0x1f210282, 0x215582a1,
    0x6942120e, 0x0e122c07, 0x120e4001, 0x4d83ba83, 0x824da5a5, 0x00122206, 0x06df5702, 0x15008024, 0x0b824e00, 0x0423b883, 0x82060706, 0x323323d1,
    0xa0823e37, 0x32332427, 0x06071401, 0x05035400, 0x2223012c, 0x2223020e, 0x032e2726, 0xf7793435, 0x83262005, 0x3e372208, 0x08028204, 0x1e323391,
    0x26000502, 0xdcfeac1a, 0x26137ae3, 0x1b15181a, 0x0189145e, 0x021ab607, 0xfe2e1426, 0xe0d6dbeb, 0x920f8a94, 0x2b2f1017, 0x292b1d3e, 0x03080219,
    0x3e4a3e03, 0x5709021c, 0x376dbe97, 0x95b2b3b4, 0x14270a27, 0x27182722, 0x0310203f, 0x63263426, 0x181587a9, 0x1813261a, 0x687c135e, 0x625f0601,
    0x6dc2fee0, 0x4a052f6c, 0x23404c40, 0x060e042a, 0x4d23070d, 0x04133a36, 0x35330a44, 0x779fd273, 0x030f1224, 0x0a252709, 0x09171127, 0x4474845c,
    0x002d0543, 0x800500ff, 0x0f000006, 0x00003300, 0x0e394305, 0x0e140122, 0x17241282, 0x042e1727, 0x0529c982, 0x17273435, 0x05041e27, 0x0b275b80,
    0x3100ff2f, 0x4f60604f, 0x01044331, 0x5a898c5a, 0x210d8537, 0x0d850342, 0x0d40a025, 0x830d1313, 0x13043304, 0x535d844e, 0x335b4848, 0x01018060,
    0x81745429, 0x118762ac, 0x86825e21, 0x06bf4911, 0x07000032, 0x00800400, 0x00210011, 0x01000031, 0x15162726, 0x2a060f57, 0x04160706, 0x34002420,
    0x57222326, 0x35300528, 0x32333634, 0x06071400, 0x27002000, 0x36373426, 0x6e080782, 0x98800617, 0xf9fe3de5, 0xf9fe8efe, 0x8598e53d, 0xd4019101,
    0xb5fd9101, 0xb37d141c, 0x7a1c281c, 0x6c031456, 0x27fe8c14, 0x27fef2fd, 0x8c14148c, 0x0e02d901, 0x028cd901, 0x6875ec40, 0xf9feb979, 0x79b90701,
    0xcdec7568, 0x3902f3f3, 0x7db31c28, 0x141c1c14, 0xd2fe7a56, 0xfee62344, 0xe51601eb, 0xe5234423, 0xeafe1601, 0x000500e5, 0x82a0ff00, 0x00e036ab,
    0x00190009, 0x0043003d, 0x25000055, 0x35012e37, 0x07063734, 0x20a78f12, 0x48a78325, 0x26200591, 0x2e212182, 0x23b18501, 0x37173221, 0x1e2ac582,
    0x13161703, 0x01070614, 0x27820416, 0x04060732, 0x24363723, 0x37272637, 0x0217011e, 0x62574e2b, 0xa722cb82, 0xc5898902, 0x87014208, 0x5cfe6a01,
    0x120a3169, 0x2c107a0c, 0x1458f18f, 0xc6019914, 0x5b590d01, 0x05120a36, 0x211e241a, 0x9e251003, 0x08180182, 0x2714c001, 0x75fe9646, 0x01d44ade,
    0xa7737969, 0x39af5f3f, 0xc03f8dc9, 0x23e7836b, 0x6e02fefe, 0xef29e689, 0xfdbd0207, 0x1059bc0c, 0x08568246, 0xd8414b2b, 0x1f4c1f89, 0x111001eb,
    0x130c1061, 0x0a021312, 0xe58b30fe, 0x2df60132, 0x40224684, 0x84beac51, 0xb3bcee12, 0xb2407073, 0x05bb415f, 0x80ff102c, 0x0006f006, 0x21000f00,
    0xff4d3300, 0x11934411, 0x16010323, 0x08e56907, 0x013e0125, 0x5d041632, 0x02270aab, 0x0b0d0a12, 0x440d0bdc, 0x0d3a0695, 0x25230003, 0xfa223b11,
    0x113b2200, 0x00032325, 0x3c463c11, 0x130ebea1, 0x04830e13, 0x84012108, 0x070ccb01, 0x0e070b0b, 0x0d0a37fe, 0xfab0030d, 0x1d3f3f80, 0x3f1d2222,
    0x1f80053f, 0x01002424, 0x052ea483, 0x006c056c, 0x01000032, 0x010f0616, 0x8f411613, 0x09272306, 0x0b831701, 0x26012b28, 0x2726022f, 0xd2483f26,
    0x01092105, 0x27080b85, 0x3e370517, 0x2c600501, 0xa0a14c40, 0x07801105, 0x0f03040c, 0xfee9fe06, 0x0d0535fd, 0x020e0960, 0xfcbd090f, 0x0a01020b,
    0x50080b82, 0x01c20206, 0x0e04fe03, 0x800b0203, 0x9902100e, 0x05c04ca0, 0x4cc03460, 0x1348fda1, 0x0106600e, 0xfc010d03, 0x11c2fdfe, 0x0209600e,
    0x07bdfc0b, 0x610c0d10, 0x01350109, 0x08170103, 0x800b1010, 0xa09f050d, 0x0f00404c, 0x00ff0000, 0x00068006, 0x110b6d00, 0x37003331, 0x3f003b00,
    0x73004f00, 0x21170000, 0x82012111, 0x8e252003, 0x88138307, 0x08bc5117, 0x8a068f45, 0x8e37202f, 0x0a13761b, 0x40183620, 0x21210a41, 0x4b401835,
    0x80162d09, 0xe0fe2001, 0x40016001, 0xa0fec0fe, 0x02210b8f, 0x201784e0, 0x21058380, 0x1d830003, 0x0b84fe20, 0x44a0fe21, 0x0d23050a, 0x82130d40,
    0x85418223, 0x84012017, 0x8920204d, 0x8001301c, 0x80fa344c, 0x344c4c34, 0x40425e80, 0x85015e42, 0x84118206, 0x20012229, 0x255a8340, 0x01404001,
    0x5f82fc20, 0x85c00121, 0x01402c07, 0x01200240, 0x13130d20, 0x82e0fe0d, 0xadfc2105, 0xa8822284, 0x8ac02021, 0xfb4d2216, 0x205a8300, 0x25058205,
    0x5e5e4260, 0x05856042, 0x00004c39, 0x00000300, 0x0007a0ff, 0x1200e005, 0x71003700, 0x06010000, 0x60042e07, 0x003d0ad6, 0x06010714, 0x3d262223,
    0x010e2201, 0x3627062e, 0x33041e37, 0x36343521, 0x01173233, 0x271c8812, 0x020e2221, 0x0e070607, 0x260b5f7f, 0x3637023e, 0x88063e37, 0x0225082d,
    0x164d3c9a, 0x4b33331e, 0x120ee02c, 0xfae00e12, 0xfe090605, 0x0d0e09c0, 0x386a2013, 0x324c345a, 0x1b3a3442, 0x2222863b, 0x77120001, 0x228308ee,
    0x3000ff30, 0x182a3c4e, 0x291d2e20, 0x5d573d43, 0x43854478, 0x3587148e, 0x5c1f0430, 0x48372db5, 0x0e121d29, 0xfc120ec0, 0x68831c0e, 0xc00d132e,
    0x07030101, 0x2e22170e, 0xb45d273d, 0x1d821f84, 0xc1fe0a24, 0x20877703, 0x3f3c1e2c, 0x426d3e2e, 0x5650785a, 0x3c842133, 0x2e85118c, 0x0000002d,
    0xff000001, 0x05000700, 0x82260000, 0x0210300d, 0x27222304, 0x07060506, 0x35272606, 0x82263626, 0x3e5b08fa, 0x02263705, 0x013e3435, 0x04323324,
    0xfef00007, 0x4b46f464, 0x31fafec6, 0x041b1141, 0x0a010503, 0x07020c02, 0x18291530, 0xb59d0b1e, 0x4c01f08e, 0x9c01f4b6, 0xa4fe2e03, 0x08abd9fe,
    0x080e43af, 0x01121602, 0x0f041004, 0x08020e03, 0x2e381735, 0x01592848, 0xed829606, 0x49ab65ac, 0x23240b17, 0x43003300, 0x15369082, 0x20040214,
    0x013d0224, 0x21333634, 0x011d1632, 0x32031e14, 0x0f87033e, 0x570df15b, 0xc53613cd, 0x48fea1fe, 0x26c5a1fe, 0x1a80011a, 0x523c2f26, 0x522e2a2e,
    0x0e852f3c, 0x2600fc24, 0x1682fe1a, 0x04200d85, 0x022a0d8c, 0xfec980c0, 0x01b5b5be, 0x2184c942, 0x4c34802a, 0x04041626, 0x344c2616, 0x02210f83,
    0x8b388966, 0x00262144, 0x012e0082, 0x15005a00, 0x2004a606, 0x00001400, 0x44180725, 0x8e560b59, 0x06142605, 0x3413a693, 0x110d5613, 0x13a5cd23,
    0x05dd5513, 0x3513a52b, 0x13e50213, 0x131bfd13, 0x25538635, 0xa606e0ff, 0x5383eb03, 0x210b3f50, 0x3f500917, 0x93062306, 0x6f561afd, 0x205c8306,
    0x070d5602, 0x82d80221, 0x214b8343, 0x5d821335, 0x82059856, 0x4954825d, 0x8026051b, 0x25008004, 0xa9824b00, 0x23061430, 0x032e2221, 0x013d013c,
    0x26222311, 0xf97a3435, 0x5b152006, 0x32260553, 0x0116011f, 0xbb500714, 0x34352905, 0x11013b36, 0x012f2221, 0x37082782, 0x32213336, 0x011c031e,
    0x3311011d, 0x00051632, 0x40fc0d13, 0x04070b08, 0x261ac002, 0x1340010f, 0x4001133c, 0xc01a260f, 0x09104002, 0x800207a0, 0x14c0fe0f, 0xc0fe143a,
    0xfd211383, 0x231383c0, 0xc0030d13, 0x28083187, 0x04130d20, 0x0611060a, 0x01a00114, 0x181a26a0, 0x16800111, 0x1180fe16, 0xfe261a18, 0x0ac00b80,
    0x11189501, 0x171780fe, 0x25128401, 0xc00c8001, 0x32890b09, 0x2660fe22, 0x2e067f48, 0x800680ff, 0x07000005, 0x3a000f00, 0x61240000, 0x0420066d,
    0x13290786, 0x07061411, 0x14151605, 0x9c4f1807, 0x34352508, 0x0337023e, 0x3420f982, 0x0421d084, 0x28198217, 0x684c8002, 0x03684c4c, 0x360684cc,
    0xfb1821cc, 0x03180dec, 0x26261a98, 0x1a00fc1a, 0x1b101026, 0x83ccb102, 0x00012d0d, 0x0c0e1910, 0x04010704, 0x34261ab1, 0x36823383, 0x032d0283,
    0x1800fec0, 0x3c7a0325, 0x2630100a, 0x26378234, 0x311f290b, 0x82370305, 0x120d250b, 0x0726151f, 0x0120af84, 0xaf82b483, 0x14008022, 0x21113f5a,
    0x8982011d, 0x8480062a, 0x5c40fb5c, 0x015c8484, 0x02260582, 0x03845ca0, 0x0f84fda0, 0x83c00321, 0x84202115, 0x02214283, 0x2b008200, 0x80055707,
    0x2a001300, 0x14010000, 0x21077d71, 0xee7e3435, 0x16322c05, 0x22211501, 0x07010706, 0x6f352634, 0x5f8406a5, 0x1f57072e, 0x9b2bb0fe, 0x22c0fb42,
    0x50011f35, 0x042e0982, 0xfe352240, 0x5ec0fca9, 0xaffe3dce, 0x78860105, 0x845c2030, 0x231f4802, 0x473374fe, 0x231f1e1a, 0x07828c01, 0xa03a012a,
    0x74fe485f, 0x04110406, 0x012a8c8a, 0x00ff4000, 0x0006c002, 0x94821f00, 0x2b061423, 0x10ca5d01, 0x2309b85d, 0x1a26c002, 0x230fa65d, 0x13261a80,
    0x2606965d, 0x2634da04, 0x5d2600fc, 0x04200ab5, 0x1d820d83, 0x82ff1321, 0x0100295c, 0x40010000, 0xc0030007, 0x07266b85, 0x26220601, 0x295e013d,
    0x5e352010, 0x50940c17, 0x8a09f55d, 0x8813207e, 0x386c829c, 0xff000005, 0x05000880, 0x00030080, 0x000d0007, 0x00150011, 0x21110100, 0x23038411,
    0x33112115, 0x11820985, 0xff800223, 0x26038300, 0x00f80005, 0x85000580, 0x8002240c, 0x820200fe, 0x00fc3601, 0x80fb0004, 0xfa000680, 0xfd800380,
    0x01000300, 0x0480fb80, 0x0aaf6280, 0x40003022, 0x06255982, 0x06373607, 0x052c4b07, 0x012e1733, 0x14150627, 0x15272617, 0x06171614, 0x1e272223,
    0x28068401, 0x3e323316, 0x27343503, 0x10144536, 0x38006208, 0x41194441, 0x575c3d45, 0xe281057b, 0x2f5b1d4f, 0x1d496435, 0x151a0d16, 0x9174446b,
    0xae94181a, 0x658cc470, 0x013f0131, 0xfc77a92a, 0xa9a97740, 0x77c00377, 0x199e03a9, 0x264d2809, 0x577b420d, 0x7407131d, 0x72383261, 0x0219013d,
    0x080e754b, 0x01523f04, 0x475e035a, 0x54a99b77, 0x012d0912, 0x21358902, 0xb08200a9, 0xff000022, 0x0525d582, 0x00240080, 0x08595c00, 0x37331129,
    0x36343523, 0x83353733, 0x011d25c9, 0x11331523, 0x2107895d, 0x7583e004, 0x1ec7bc2e, 0x7a442fe5, 0xa388733f, 0xecfdc8c8, 0x05211283, 0x2e928580,
    0x94e85302, 0xcf013838, 0xab92a009, 0x85adfde8, 0x820020a1, 0x83072000, 0x0007316b, 0x0f008005, 0x1b001700, 0x27002300, 0x3e002e00, 0x5d4c1982,
    0x4336200e, 0x012b06f7, 0x00213521, 0x06202610, 0x83201610, 0x2103250b, 0x0721013d, 0x080b427f, 0x2133362b, 0xa0031632, 0x5e420e12, 0x38121c12,
    0x96f20e28, 0xd49696d4, 0x000696fc, 0x800400fa, 0xe1c2fee1, 0xfc3e01e1, 0xfe8001e1, 0x2fe68280, 0xfd40c4fc, 0x4b80067c, 0x3500fa35, 0x06354b4b,
    0x022c0582, 0x5e121cb2, 0x12120e42, 0x0838280e, 0x96283b83, 0x0180c2fc, 0xe13e011f, 0x04293c83, 0xc0fe8002, 0x80808a76, 0x203084fb, 0x21058305,
    0xc7820200, 0x93064822, 0x1522c782, 0xbd844700, 0x1506223c, 0x23261714, 0x16140622, 0x34353632, 0x32331627, 0x23061401, 0x27022e22, 0x40531707,
    0x82012006, 0x3526260f, 0x33241234, 0x22118232, 0x79370107, 0x1e2b07e2, 0x70400304, 0x291370a0, 0x8670502a, 0x03350807, 0x091162c3, 0x032b2227,
    0x4e1cdc60, 0xfd1c282a, 0xa3bdb061, 0x3201becd, 0x83cda3a0, 0x03606301, 0x6220222e, 0x060a0d11, 0x39595450, 0x70a0b003, 0x292a5070, 0x843c8213,
    0x00fe2607, 0x22206211, 0x083c832e, 0x4e2a2820, 0x839f021c, 0x01a0a3cd, 0xa3cdbe32, 0x9dfeb0bd, 0x222b0360, 0x62110927, 0x524d060a, 0xbe82425a,
    0x82060021, 0x070f30cf, 0x00f00580, 0x00110007, 0x007f001b, 0x86fb00bd, 0x22d082d7, 0x4d263401, 0x112006fa, 0x01200988, 0x09e74718, 0x47181520,
    0x47181ae8, 0x4d8431e6, 0x1f160725, 0x82011e01, 0x06072363, 0x11821607, 0x2223062d, 0x22062726, 0x23010e27, 0x82262722, 0x27262854, 0x34013d26,
    0x83373637, 0x023e2d0c, 0x17163233, 0x36173236, 0x1732013f, 0x16232f83, 0x83111617, 0x2e3cb736, 0xd4968003, 0x03d49696, 0x4c684c96, 0x854b6a4b,
    0xfe2c0805, 0x9b090e80, 0x3822150b, 0x77170707, 0x730a0b13, 0x0c0b2825, 0x0bba1707, 0x22170112, 0x0d077629, 0x07900a0b, 0x17103e0a, 0x0e0a980c,
    0x16212a88, 0x212a8378, 0x2a8b2b22, 0x830c0821, 0x3c0c242a, 0x820b170f, 0x0220082a, 0x120c9580, 0x027a0433, 0x140e4c08, 0x4c0e1414, 0x047a0208,
    0x950c1233, 0x33110d95, 0x383e0404, 0x33291886, 0x78040629, 0x0d113304, 0x212faf95, 0xcd831602, 0x00ff962b, 0x344c4c34, 0x044b4b35, 0x08088635,
    0xb990fe2c, 0x1801130a, 0x43302923, 0x070c090b, 0x5a07771e, 0x2f6c0c13, 0x990a0f18, 0x0759150a, 0x091b8508, 0x164e0e0a, 0x0118262c, 0x2a8b0b11,
    0x761e0828, 0x0e125a07, 0x2a8a2e6c, 0x100b083e, 0x2230164c, 0xfd110217, 0x0f108ce0, 0x1971191b, 0x5e470304, 0x15020215, 0x0403475e, 0x1b220e82,
    0x1882100f, 0x83171d21, 0x24022318, 0x1a825d20, 0x02294723, 0x241b8346, 0x030f1d17, 0x2035b3f0, 0x20008200, 0x06574402, 0x00003308, 0x004f0025,
    0x06100000, 0x27222304, 0x07060706, 0x27262223, 0x053e3426, 0x37043e37, 0x3435012e, 0x04202436, 0x07061401, 0x1e17041e, 0x0e071406, 0x1f822701,
    0x2306272a, 0x33162720, 0x3e372432, 0x39082282, 0x05011e27, 0xbbfebc80, 0x7c5a56bf, 0x0332249a, 0x0102130b, 0x05020301, 0x05010603, 0x151d1024,
    0xbc8e7c0a, 0x7e014501, 0x3c024501, 0x150a7c8e, 0x0524101d, 0x05030601, 0x26820302, 0x0c144408, 0x7c9a2432, 0xf1fe565a, 0xa11e3ac9, 0x7d742801,
    0x96811786, 0xeafe8b03, 0x581089ec, 0x10070928, 0x0607030d, 0x03070406, 0x26060107, 0x18282515, 0x8b77d248, 0xfd8989ec, 0x48d17889, 0x15252818,
    0x82010626, 0x0604371c, 0x0e030706, 0x09070110, 0x84105828, 0x5c545a04, 0x4b4d86f0, 0x774bd647, 0x00062808, 0x3c000700, 0x18006d00, 0x27086d46,
    0x23263401, 0x35363421, 0x094d0682, 0x33112208, 0x2ae98232, 0x32013b16, 0x3e273435, 0x83273401, 0x2408821e, 0x16071437, 0x25038615, 0x22022b06,
    0x3b822726, 0x62482220, 0x37362706, 0x023e3736, 0x3b823637, 0x24820120, 0x32336008, 0x26000116, 0x34262634, 0x324ea604, 0x4060a0fe, 0x25181a60,
    0x04371629, 0x242c1926, 0x20102729, 0x1d250d20, 0x0530172f, 0xc07983d3, 0x12231e05, 0x200f1435, 0x0931802b, 0x013c0326, 0x5d248dac, 0x747bbb60,
    0x35e0fe16, 0x01354b4b, 0x3a652412, 0x26171831, 0x5433272b, 0xb0304686, 0x83a69868, 0x2653085a, 0x4d338002, 0x623bcb3a, 0x85761a5e, 0x0544172b,
    0x23352032, 0x80fd1224, 0x080f0706, 0xa7490211, 0x49101e1a, 0x4532204a, 0x01113d19, 0x4a59245c, 0x434d2421, 0x4d651615, 0x2b2da18b, 0x02354b28,
    0x184b3580, 0x19354b83, 0x252a8479, 0x5d758a41, 0x41009863, 0x0021052b, 0x054b6a06, 0x71003e22, 0x230cd144, 0x35013e27, 0x20060f41, 0x053e5e36,
    0x050e0725, 0x8211012b, 0x170527f5, 0x021e1716, 0x17833217, 0x32213535, 0x06143736, 0x1516012b, 0x010e0714, 0x2e272223, 0x82262703, 0x09976401,
    0x013e3728, 0x1632013b, 0x52411507, 0x082f4108, 0x202b5908, 0x1235140f, 0x62051e23, 0xd3838057, 0x2f173005, 0x200d251d, 0x29271020, 0x26192c24,
    0x29163704, 0x601a1825, 0x60016040, 0x98804e32, 0x2330b068, 0x33548623, 0x0b282227, 0x3b301318, 0xeefe2465, 0x354b4b35, 0x74162001, 0x7069be80,
    0x3c01ad8c, 0x31092603, 0x26342604, 0x41080282, 0x5c2300fe, 0x193d1101, 0x261f3245, 0x1e104925, 0x4952551a, 0x0f081102, 0x80fd0607, 0x35232412,
    0x44053220, 0x76852b17, 0x3b625e1a, 0x324d3acb, 0x5d639867, 0x41454476, 0x53622125, 0x4d321556, 0x37411883, 0x2c283c05, 0x05899e2c, 0x1516654d,
    0x21244d43, 0x00000049, 0xff000001, 0x054003ad, 0x821200e0, 0x1811200c, 0x23106458, 0x3ffe4003, 0x0d545818, 0xfae00523, 0x445818c5, 0x0b9b4311,
    0x1c008024, 0x4d823900, 0x032e3429, 0x07020e22, 0x83272206, 0x15032708, 0x01091714, 0xa94c3736, 0x33591806, 0x0625080e, 0x60432b80, 0x6578685c,
    0x3e121848, 0x65481812, 0x605c6878, 0x02bb2b43, 0xbc440245, 0x91fde580, 0xfd123412, 0x4f591890, 0x03230812, 0x497c51ac, 0x4d33102e, 0x16161c43,
    0x334d431c, 0x7c492e10, 0xfdbba851, 0xbc2f02d0, 0xfde5dda8, 0x181212a8, 0x86126e59, 0x000030af, 0x00052006, 0x40002800, 0x14250000, 0x66020e16,
    0x15200b84, 0x062b1086, 0x16141115, 0x023a2133, 0x8400031e, 0x352621bd, 0x37082149, 0x36341121, 0x02011732, 0x05010280, 0xc0fe0d0f, 0x77a9a977,
    0x130d4001, 0x2a080e86, 0x425e5e42, 0x14012001, 0x0a061106, 0x13a00304, 0x3413e0fd, 0x1a40fe26, 0x011a2626, 0x133426c0, 0x04602002, 0x0d1a1520,
    0x820277a9, 0x0d13213a, 0x5e2c0c84, 0x4240fd42, 0x0704025e, 0x3432020b, 0x2c823283, 0x0c4f2020, 0x20012305, 0x1182261a, 0x1f6e0020, 0x00063605,
    0x03008005, 0x25000f00, 0x00003500, 0x23113337, 0x22012e37, 0x08155806, 0x26341133, 0x33072223, 0x03162335, 0x37341133, 0x3233013e, 0x0f864a15,
    0xe7e7ed3f, 0x744601f6, 0x01394749, 0x4902483b, 0x887892e7, 0x03e70249, 0x0f07e703, 0x01742c3c, 0x0b7a4ad4, 0xb6027a3e, 0x444434d6, 0x45453334,
    0x8e01a7fc, 0x65759e9a, 0x018cfd42, 0x23122684, 0x73029d31, 0x260b6d4a, 0xff000002, 0x82800400, 0x000b259f, 0x0100002e, 0x3a054e48, 0x32161411,
    0x06140136, 0x0e032123, 0x22012b01, 0x22210327, 0x36343526, 0x5b221133, 0x1b8206d8, 0x16321127, 0x1c12e001, 0x39028212, 0x1a26a002, 0x023353fe,
    0x1b010c11, 0x6cfe4c05, 0x639d261a, 0x344c4c34, 0x05838002, 0x029d632b, 0x0ec001a0, 0xfe0e1212, 0x33058240, 0x261aaefe, 0x110c1dfe, 0x26e5011b,
    0x02c57b1a, 0x4c684c00, 0xfe220282, 0x3746c500, 0x00002905, 0x00060007, 0x3f002700, 0x8213c94d, 0x0de86f78, 0x013b3622, 0x7f5c8882, 0x6c052016,
    0x02200881, 0xfd228084, 0x5d6d4240, 0x0e122106, 0x01278b82, 0x13342680, 0x5c74fdb0, 0x02230587, 0x6813b08c, 0x022105b8, 0x05214260, 0x77400323,
    0x232884a9, 0xc0fc425e, 0x01203983, 0x12263482, 0x00fe5203, 0x3784261a, 0x82720a21, 0x2337833a, 0x00262634, 0x09634a18, 0x40001724, 0x83420000,
    0x41092016, 0x343208d9, 0x33023e26, 0x35363221, 0x23263411, 0x2e022a21, 0x12863503, 0x42041621, 0x01251382, 0xfe77a973, 0x06b342c0, 0xc9840120,
    0x42e0fe21, 0x022506b3, 0x0d0f0501, 0x21ae8201, 0x8a429a02, 0x33012215, 0x421d82fd, 0x022008b9, 0x022fce82, 0x080b0704, 0x1a152004, 0x0300a90d,
    0x6aff0000, 0x0637057f, 0x49000d00, 0x26010000, 0x14152135, 0x21352516, 0x013e0714, 0x46141537, 0x012005c1, 0x33631382, 0x63481806, 0x25c18208,
    0x26272634, 0x58522e27, 0x34352206, 0x056d5236, 0x32213508, 0x4aca0116, 0x04bd00ff, 0x4a00ffc3, 0x5380bd8d, 0x2a71cd8d, 0x3d1d2635, 0x12754b43,
    0x0ec0fc0e, 0x434b7512, 0x35261d3d, 0x8dcd712a, 0x01283853, 0x02425e20, 0x3708d882, 0x38282001, 0xd1a28d02, 0xf6a84e60, 0x1da2d160, 0x4780cea8,
    0x054f7490, 0x4d222936, 0x5b4a3633, 0x120e4045, 0x45400e12, 0x33364a5b, 0x3629224d, 0x90744f05, 0x38288047, 0x2405c354, 0x00000038, 0x3ecf8409,
    0x00800500, 0x000f0007, 0x001f0017, 0x002c0027, 0x00810032, 0x01000091, 0x07262736, 0x85161706, 0x36372205, 0x210f8627, 0xc6823617, 0x17201782,
    0x1e270f85, 0x22233401, 0x82263714, 0x01363211, 0x00200034, 0x17121415, 0x34353616, 0x2e020e27, 0x08f08401, 0x32333624, 0x1e17011e, 0x37363201,
    0x032e3736, 0x26373435, 0x1f163637, 0x17323601, 0x1617023e, 0x14151607, 0x0583030e, 0x14150626, 0x12363716, 0x250fd543, 0x07040702, 0x03820509,
    0x0705173c, 0x05070606, 0x07022f06, 0x07030107, 0x01021608, 0x05080603, 0x0b025b06, 0x03820409, 0x0a0c2e2a, 0x0216023d, 0x82021402, 0x0805eb70,
    0x129ac43f, 0x13060111, 0x082b2c34, 0x05022217, 0x0e0b030b, 0x0c2a1206, 0x202c2b10, 0x311a070e, 0x3527484a, 0x47131d18, 0x8c3a1a19, 0x4c230b3a,
    0x35181d13, 0x3d402b1c, 0x11012326, 0x01c49a12, 0x0b2f4400, 0x06500123, 0x3e7b8207, 0x072e0707, 0x08080403, 0x04310403, 0x05040204, 0x01130203,
    0x08070207, 0x07470607, 0x82070304, 0x04590803, 0x070f1010, 0x04080704, 0x01d44501, 0xd4d4fe2c, 0x34f5fea7, 0x340c1003, 0x0103012b, 0x3b1a1f09,
    0x0b05010f, 0x1b040708, 0x071c1c16, 0x06162f06, 0x46633519, 0x4a3e3a4f, 0x10101b06, 0x16071111, 0x3e4a061e, 0x57394f3a, 0x04102435, 0x6228401f,
    0x03100c02, 0x020b0134, 0x0b934487, 0x0000042c, 0x800680ff, 0x0700c005, 0x07440f00, 0xbf4f1805, 0x011e2f1d, 0x36322133, 0x16322137, 0x21230601,
    0x04821411, 0x35262227, 0x27222111, 0x06825326, 0x4f180520, 0x260816c1, 0x3d6315ab, 0x633d0001, 0x28ab0115, 0x11bbfe38, 0x2600ff2a, 0x1a00ff1a,
    0x2a00ff26, 0x011f1111, 0x123612c0, 0x471fc001, 0x058505dd, 0x0bc44f18, 0x48483827, 0x60023838, 0x07294628, 0x1e27282a, 0x1313c001, 0x001e40fe,
    0x02200082, 0x0537c783, 0x008005ff, 0x00630031, 0x26340100, 0x35022e27, 0x34353634, 0x7e232627, 0x222f05ad, 0x0607010e, 0x15020e07, 0x14151614,
    0x7e161406, 0x322c0618, 0x12013e37, 0x06021437, 0x22230607, 0x38842b86, 0x34352625, 0x6837023e, 0x2b850531, 0x38083682, 0x021e1415, 0x05011e17,
    0x0c0b0e7f, 0x0a0a080a, 0x4e130904, 0x3be83c14, 0x3843672b, 0x7f604189, 0x18161931, 0x19611816, 0xb539e139, 0x77d58167, 0x9bfc8c80, 0xe239ca7c,
    0x08138238, 0x1665496d, 0x80492419, 0xc29a4e56, 0x3ae73c7a, 0x51144c13, 0x03040a4a, 0x1210020c, 0x8b2cc602, 0x2d1c1e1b, 0x165b171a, 0x09011225,
    0x16181730, 0xe9493136, 0xa02881ef, 0x2c571729, 0x241f161d, 0x1401d72d, 0xbbfea58b, 0x1d2c37fb, 0x18496f1d, 0xa1281758, 0xced56f29, 0x3d3b41b6,
    0x650a304e, 0x175a1754, 0x2009180d, 0x009d2804, 0x82000100, 0x80052900, 0x4f008005, 0x14010000, 0xde83dc82, 0x2705bc49, 0x27262700, 0x3435042e,
    0x3e23db82, 0x49323301, 0x1e2405ee, 0x0e141502, 0xde840382, 0x031e1726, 0x023e3233, 0x20057043, 0x08208202, 0x8005166e, 0x65150b14, 0x341b5c5e,
    0x09501f3f, 0xfe7f4d62, 0x23304fee, 0x120b1e03, 0x32383307, 0x0e1b5719, 0x0b231207, 0x030f2026, 0x43390e1d, 0x15070a39, 0x89c44c01, 0x1b0e2202,
    0x32381209, 0x1d0e143c, 0x3919042a, 0x06461346, 0x1b280103, 0x38321957, 0x0b120733, 0x3023031e, 0x7f12014f, 0x5009624d, 0x1b343f1f, 0x15655e5c,
    0x0603140b, 0x39362782, 0x1d2a0419, 0x323c140e, 0x1b091238, 0x8902220e, 0x15014cc4, 0x5b820a07, 0x031d0e29, 0x0b26200f, 0x41071223, 0x002105f7,
    0x22e78400, 0x821f000f, 0x0daf46e9, 0x6f172621, 0x04210e33, 0x055b4660, 0x42400326, 0xa9de5e5e, 0x23081474, 0x0005a977, 0x83077746, 0xfca0281b,
    0xa9a977c0, 0x82400377, 0x02002605, 0x97ff0000, 0x23658205, 0x23000600, 0x11256383, 0x01173701, 0xcc441813, 0xfc802c1c, 0x59a70100, 0x0ca70159,
    0x18211517, 0x2a15d544, 0x0126fb00, 0xfe555596, 0x185a056a, 0x691ddf44, 0x4722095f, 0x7f825700, 0x042e3428, 0x23022e27, 0x03820e22, 0x27022e24,
    0x0060012e, 0x340a8308, 0x07222305, 0x1415010e, 0x1617041e, 0x051e1700, 0x37363233, 0x0f0b4536, 0x00054208, 0x2e312004, 0x1c05062d, 0x2b0f0a16,
    0x070d2924, 0x03160c13, 0x02388e63, 0x2907060d, 0x140a2931, 0x1a180303, 0x0b0a171b, 0x442e3530, 0x070d0505, 0x013c0212, 0x3006a439, 0x24192912,
    0x15933910, 0x0ed64416, 0x0a0b572a, 0x181a1b17, 0x0a140303, 0x34083f82, 0x020d0607, 0x03638f37, 0x07130c16, 0x2b24290d, 0x1c160a0f, 0x2e2d0605,
    0x16042031, 0x10399315, 0x12291924, 0xfea40630, 0x12023cc7, 0x05050d07, 0x03352e44, 0x0b974439, 0x2c000136, 0x54060000, 0x31000005, 0x06010000,
    0x14151607, 0x04010e02, 0x2005a94e, 0x22e78237, 0x82323316, 0x3d720806, 0x2e171601, 0x37343501, 0x26170416, 0x33363435, 0x37361732, 0x06360706,
    0x015f4354, 0xfed69b4c, 0xf1feacd2, 0xe12b23e1, 0x1fa669b0, 0x2a2b1c21, 0x4e449370, 0x792c4e42, 0x08c65b01, 0x608c86bd, 0x6925606d, 0x6268045d,
    0x821c0e45, 0xb7eefdfe, 0x8a04916d, 0x05617d02, 0x75b1170b, 0x2c032604, 0x4b58538e, 0x260ab395, 0x66bd8624, 0x3f733915, 0x8e82000a, 0xff5f0027,
    0x06bf0380, 0x05ff5600, 0x0622232a, 0x0321011d, 0x11211123, 0x84840382, 0xbf032208, 0x013c569d, 0xfefe2725, 0xff00ffce, 0x0593add0, 0x48f8fef4,
    0xd8febd48, 0xf70209fd, 0xbada2801, 0x384782cd, 0xff000008, 0x050006a7, 0x00540080, 0x0064005c, 0x0073006b, 0x0082007a, 0x271b8288, 0x15120420,
    0x06070014, 0x3524d483, 0x043e2734, 0x24080482, 0x06262736, 0x2226010f, 0x07022e07, 0x15061706, 0x17031e14, 0x010e0706, 0x2e272622, 0x22012f01,
    0x1f011e06, 0x2e038401, 0x14013f03, 0x06141516, 0x35002627, 0x47131234, 0x84470872, 0x05724705, 0x06851620, 0x07841720, 0x16170631, 0x22073437,
    0x32371415, 0x06072637, 0x63023616, 0x500805b8, 0x1be8dbfe, 0x3934011a, 0x2941615b, 0x1c2d254f, 0x5d26276a, 0x35105dc6, 0x252d1c72, 0x6140294f,
    0x0a27395b, 0x41423015, 0x143b1317, 0x06101514, 0x1607070c, 0x0d0a0a2b, 0x1643483e, 0x1b1a0117, 0xcedbfee8, 0x0a0a0355, 0x090a0303, 0x0a090723,
    0x08038206, 0x09092493, 0x12090908, 0x0c0c0832, 0x0c0d0908, 0x0f100341, 0x430f1108, 0x10111011, 0x1010023a, 0x80052004, 0xd19ffece, 0x4d6ffefb,
    0x03121805, 0x2d613d93, 0x4f361806, 0x57775583, 0x2809715b, 0x1a1a1818, 0x092d200b, 0x77575b71, 0x36508255, 0x43240618, 0x292b0a0a, 0x03042820,
    0x050e0e09, 0x17380a05, 0x0d2f2617, 0x26040401, 0x18120465, 0x91014d05, 0x6101d1fb, 0x05077ffc, 0x05070503, 0x0b051a06, 0x0b050609, 0x0c07260a,
    0x1a05070d, 0x0c0b0824, 0x34038209, 0x04050b10, 0x07060416, 0x0d0b020d, 0x020b1502, 0x00081803, 0x05474500, 0x05800628, 0x00250080, 0xa7650100,
    0x26342608, 0x011d0622, 0xaf471833, 0x2133370d, 0x20003435, 0x26800600, 0x261a401a, 0x6096d496, 0x28383828, 0x058340fc, 0x01a00239, 0x01720107,
    0xffc00307, 0x26261a00, 0x6a00011a, 0xc06a9696, 0x18fd2838, 0x2409f550, 0xfe0701b9, 0x257382f9, 0xff000005, 0x73830780, 0x19000f28, 0x27002300,
    0x9b562b00, 0x088b4d08, 0x80831520, 0x34352133, 0x32112326, 0x21113536, 0x33161411, 0x15213537, 0x23038233, 0x5e42e006, 0x2807647b, 0x8006130d,
    0x130d0d13, 0x240582f9, 0x80000160, 0x22578201, 0x7bfb425e, 0x16820856, 0x0de0e02e, 0x1300fb13, 0xfd60020d, 0x80130da0, 0x00220083, 0x00820003,
    0x2b820520, 0x00070025, 0x7c3d0021, 0x16390a01, 0x012b0607, 0x26272622, 0x012e2700, 0x3734013d, 0x16013b36, 0x12161704, 0x22198805, 0x89240002,
    0x010c211b, 0x01201b82, 0x0805107c, 0x02700238, 0x871d1213, 0x16022419, 0x19e5bbfe, 0x1a111521, 0x2401a005, 0x02877271, 0x1214020d, 0x251a8f1c,
    0xfeb20c01, 0xd77dfee3, 0x12142319, 0x0601031a, 0xbbbadf01, 0x257c01d6, 0xfe330805, 0x15141cc5, 0x01e51921, 0x24021645, 0x121d8719, 0x72870d11,
    0xa2dcfe71, 0x2314141b, 0x8301d719, 0x0db21d01, 0x8f192501, 0x0d12121c, 0xfebabbd6, 0x82050021, 0x060021b9, 0x07280683, 0x1f000f00, 0x3f002900,
    0x5f5bcb89, 0x18172007, 0x290ea553, 0x2e032101, 0x22212301, 0x37450706, 0xad56180a, 0x1004270a, 0x2f2f422f, 0x03820142, 0x9f220282, 0xb07c0d13,
    0x32fb2e09, 0x049d9c04, 0xf2fc0e18, 0x0404180e, 0x056941b1, 0x11c5102d, 0x0e03375c, 0xc5115c37, 0x83610110, 0x2939853a, 0x4001f02f, 0x0d13130d,
    0x0582c0fe, 0x01ed012b, 0x11110de2, 0xfe7efd0d, 0x05fe4cc0, 0x32192108, 0x42355e02, 0xa2fd3542, 0x00020032, 0x0783ff00, 0x00800500, 0x0034002e,
    0x16320100, 0x11230614, 0x00290382, 0x16010e25, 0x1e010e17, 0x26048202, 0x042e2726, 0x6f233736, 0x3322053b, 0x26822021, 0x03152808, 0x11050011,
    0x35800604, 0x4c354b4b, 0xfe5ffe34, 0x04423a75, 0x12061426, 0x1d262f31, 0x072eaca5, 0x031b132d, 0x847a110a, 0xe0300873, 0xcd01b301, 0xfe804c34,
    0x018afe76, 0x4b800379, 0x80fe4b6a, 0x5b014c34, 0x6b5e1321, 0x33412127, 0x3a1e293b, 0x172a1b32, 0x54763c81, 0x425e3671, 0x2308aa82, 0x344c8001,
    0xba0324fc, 0xfe29d2fe, 0x00002af2, 0x40000300, 0xc00600ff, 0x0b000006, 0x41001900, 0x34040000, 0x35339282, 0x14152234, 0x21013316, 0x2e341100,
    0x020e2202, 0x82011015, 0x142126bf, 0x35262206, 0x08038221, 0x35043e2b, 0x26371234, 0x32363435, 0x07141516, 0x14151216, 0x9003031e, 0x20553b10,
    0x76fd4967, 0xf6fe1405, 0xba995a30, 0x04305a99, 0x08c882c0, 0xd4964056, 0x3440fe96, 0x5852324c, 0xbeea273d, 0x38503808, 0x27eabe08, 0xb052583d,
    0x103b5520, 0x01674910, 0x022c0130, 0x626c3314, 0x6c623f3f, 0xfeecfd33, 0x6a4c34d4, 0x4c6a9696, 0x935c2a34, 0x988bf2aa, 0x131c0501, 0x38382814,
    0x1c131428, 0x8b98fbfe, 0x5c93aaf2, 0x0132bf82, 0x80ff0200, 0x7d05fe05, 0x00004900, 0x07161701, 0x05840f06, 0x07012f27, 0x23060706, 0x21078322,
    0x05852627, 0x27013f25, 0x83262726, 0x36372105, 0x1f250585, 0x37363701, 0x21058336, 0x05851617, 0x45823d83, 0x60052708, 0x0c0a1e8a, 0x0c35bc28,
    0xba291d1f, 0x0c290a30, 0x87141f07, 0x292a1c87, 0x29ba300a, 0x350c1f1d, 0x0a0c28bc, 0x258e8a1e, 0x871d2925, 0x8d291d87, 0x80022123, 0x0221368e,
    0x21368316, 0x5c89290b, 0x8d1c2a21, 0x0a29285a, 0x8b8b1f0c, 0x8c0a0b1e, 0x03002623, 0x80ff0000, 0x05bb4d07, 0x68003522, 0x260f4f55, 0x3435023e,
    0x83222326, 0x540383f7, 0x01210520, 0x0c4f5533, 0x20072254, 0x05545506, 0x22230622, 0x2e0b4e55, 0x37053e32, 0x043e3736, 0x15163233, 0x55210714,
    0x053b084d, 0xfd324ea6, 0x1e241ec0, 0x42184759, 0x48280d18, 0x47451e47, 0xbe482020, 0x55bd51c5, 0x01320645, 0x804c344b, 0x04a96997, 0x013c0321,
    0xbd858dac, 0x46553ba4, 0x0a203506, 0x1b151817, 0x4102180e, 0x22280d23, 0x7d263f2f, 0x760116a3, 0x320b4c55, 0x53353914, 0x8b3d432b, 0x5140152c,
    0xfd391951, 0x55404080, 0x4c250b44, 0x3e986935, 0x05415539, 0x543b4521, 0x09330508, 0x0f1c1113, 0x374a031c, 0x403e5215, 0x447a8623, 0x4100983c,
    0x352f0a1f, 0x71003d00, 0x33250000, 0x2e222311, 0x84262702, 0x042e2a01, 0x15062223, 0x15021e14, 0x2b078321, 0x0e213316, 0x17141501, 0x17161406,
    0x16241682, 0x013e3233, 0x20074e4d, 0x058a4a13, 0x23060726, 0x013f2622, 0x8205c559, 0x3435240a, 0x48213336, 0x2c0805ba, 0x1617031e, 0x33061e17,
    0x05163221, 0x23202060, 0x1d283c41, 0x28480408, 0x1301180e, 0x08151612, 0x241e5947, 0x32c0fd1e, 0x01344c4e, 0x0559554b, 0x61046708, 0xbec65457,
    0x34266801, 0xa6342626, 0xe0fe354b, 0x7fbea43b, 0x0101b08e, 0x0421033d, 0x989769a9, 0x16760168, 0x3f267da3, 0x0d28222f, 0x18024123, 0x18151b0e,
    0x20010a17, 0x02804b35, 0x2a321880, 0x51050921, 0x032e1640, 0x17262127, 0x532b433d, 0x4d143935, 0x114c3433, 0x3245193d, 0x10494a20, 0x52552018,
    0x5f844040, 0x02262808, 0x3580fd80, 0x9b453b4b, 0x664c058c, 0x3e391516, 0x98676998, 0x867a443c, 0x523e4023, 0x034a3715, 0x111c0f1c, 0x564b0913,
    0x2008097b, 0x07000006, 0x68003500, 0x34040000, 0x14062226, 0x34133216, 0x2e072223, 0x26072201, 0x07062223, 0x05f95c11, 0x2e221123, 0x230e8202,
    0x16171415, 0x1d2b0185, 0x34352101, 0x1437013e, 0x4b150607, 0x2e2109c2, 0x06b94c05, 0x32333625, 0x82341117, 0x1d162405, 0x82171601, 0x36172207,
    0x06764e16, 0xe641a620, 0x3334220c, 0x0e09424d, 0x40800228, 0x3b458040, 0xca83354b, 0x2012f241, 0x09184267, 0x26345a22, 0x0321f782, 0x0b8f423c,
    0x2017b442, 0x229d4256, 0x4108ca42, 0x342d0c1f, 0x70003c00, 0x34010000, 0x013d012e, 0x06fb5121, 0x0607062e, 0x15040e07, 0x32331614, 0x1133023e,
    0x36220783, 0x0d821135, 0x32163724, 0x07823736, 0x41023621, 0x012c064f, 0x012f0614, 0x27222306, 0x14150706, 0x26220782, 0x05841135, 0x033e3435,
    0x3e373637, 0x34113506, 0x32213336, 0x14111516, 0x82051617, 0x41fd20fc, 0x2e211af5, 0x09f44139, 0xfb828020, 0x01342623, 0x06ec4126, 0x98413629,
    0x36986769, 0x4187794a, 0x352c0eec, 0x4b358002, 0x4002453b, 0x48bec654, 0x2a1fb542, 0x23123523, 0x0361041e, 0x8226343d, 0x44fd215e, 0x2105a942,
    0xa942071e, 0x06d7421d, 0x00820020, 0x6b520220, 0x001f2308, 0x277a002b, 0x36373206, 0x26012f34, 0x07010722, 0x011f1406, 0x3f321601, 0x20118301,
    0x0d9f7921, 0x26000534, 0xbd0afe1a, 0x125b1313, 0x96fe1236, 0x5b12125b, 0x0a826a01, 0xbd260882, 0x261af601, 0xc5770001, 0x4002250e, 0xbd261a80,
    0x8305a878, 0x1236242f, 0x8296fe5b, 0x20338235, 0x1dc379bd, 0x00209b84, 0x95829482, 0x83010f21, 0x22212894, 0x14011d06, 0x84213316, 0x321625a2,
    0x24370137, 0x210a7178, 0x5b840505, 0x122a6182, 0x0afebd12, 0x1a26261a, 0xaa86f601, 0x5b6a0124, 0x9a8f0d01, 0x2a826520, 0x1220bd82, 0xbd22cb83,
    0xa8891a26, 0xfe202d82, 0x410ea077, 0x00220e33, 0xa3792734, 0x2d988405, 0x013f3216, 0x3b161411, 0x35363201, 0x0d831711, 0x0421978c, 0x88f99012,
    0x0e01216c, 0x6622958f, 0x7f821236, 0xcb961220, 0x979ffd20, 0x26012f2f, 0x11010f22, 0x012b2634, 0x11150622, 0x230d8327, 0x01171406, 0x45189684,
    0x05210c03, 0x25f99404, 0x5b123612, 0x97916a01, 0x58416420, 0xf6012305, 0x0342261a, 0xff002112, 0x9f43988e, 0x05176206, 0xd8010b24, 0xf7701802,
    0x010e270e, 0x013e3207, 0x01833637, 0x36261730, 0x3f013e37, 0x27260601, 0x26340714, 0x924f2706, 0x0e222707, 0x0e262301, 0x2c820702, 0x26273627,
    0x27263607, 0x291a8433, 0x011e0607, 0x15061615, 0x1a831614, 0x17160626, 0x0f020e16, 0x26203e83, 0x03832582, 0x3e222d83, 0x56823501, 0x16230222,
    0x37295b82, 0x33011e36, 0x16273616, 0x291d8327, 0x0e261706, 0x012e2701, 0x52832227, 0x09823620, 0x1e224682, 0x4d821702, 0x06070224, 0x19820716,
    0x012f1623, 0x238e8222, 0x17363726, 0x06210d82, 0x25448507, 0x17163717, 0x0d820726, 0x86820720, 0x08832220, 0x021e1727, 0x36071637, 0x82828217,
    0x293c8236, 0x14062237, 0x16061707, 0x13820637, 0x82050952, 0x06222451, 0x83011e23, 0x8298822b, 0x3227226e, 0x8468821e, 0x3223231d, 0x1a831716,
    0x05830320, 0x36321624, 0x4a823637, 0x84063721, 0x3617221b, 0x29488237, 0x27063536, 0x36022e34, 0xff823233, 0x262b8c83, 0x15061427, 0x013e2722,
    0x83033e37, 0x820e208d, 0x8226204b, 0x34352355, 0x1584013e, 0x36160123, 0x2ae78237, 0x17361623, 0x26343716, 0x84371637, 0x8236207c, 0x265c82bd,
    0x2f26013e, 0x82353401, 0x05a55d30, 0x37322727, 0x23012e22, 0x213a8336, 0x06853716, 0x37343628, 0x013f013e, 0x10832336, 0x36207682, 0x26230783,
    0x82373603, 0x2726227f, 0x27fd8236, 0x2306032e, 0x17030e07, 0x02267882, 0x010e0706, 0xda822607, 0x83040e21, 0x012e2209, 0x266f8235, 0x07060716,
    0x82141706, 0x0fc17202, 0x44034108, 0x02060f02, 0x06010505, 0x22260e10, 0x03170211, 0x02031803, 0x06010b0c, 0x0a020e09, 0x0201060a, 0x0301020f,
    0x08060503, 0x06030107, 0x03020603, 0x100f030b, 0x0309060a, 0x0f010507, 0x34080314, 0x57080782, 0x1c0d0107, 0x031a0304, 0x02070705, 0x04050601,
    0x04130b03, 0x06170907, 0x21192405, 0x0c070606, 0x09030203, 0x03070c01, 0x0d050f23, 0x130a0904, 0x09030e05, 0x0404090c, 0x0a080f0c, 0x08101101,
    0x08050901, 0x0a1c0308, 0x1b071b13, 0x0b010506, 0x0e020d0a, 0x0a0d0206, 0x3f087182, 0x03080505, 0x040a2007, 0x04051118, 0x04030104, 0x302e030e,
    0x10050606, 0x05082202, 0x1707060e, 0x02070214, 0x080e0f04, 0x59920610, 0x02040507, 0x06090a03, 0x02132b01, 0x10010d03, 0x07070301, 0x022a9d82,
    0x0d0d1103, 0x03020621, 0x72820c12, 0x17020836, 0x01030101, 0x01031903, 0x02060402, 0x03020f1a, 0x08020205, 0x4d083582, 0x140e0a03, 0x08100602,
    0x05061609, 0x0d020206, 0x0503140c, 0x0c0a081b, 0x1c0f0511, 0x02132407, 0x02070b05, 0x06051a05, 0x08140301, 0x05121f0e, 0x04020203, 0x01060209,
    0x05021401, 0x0d030516, 0x02030102, 0x02060901, 0x07130c0b, 0xf7820401, 0x0d07222a, 0x06010513, 0x02040c03, 0x0130bc83, 0x07010303, 0x070f062b,
    0x18050205, 0x03051903, 0x0527d982, 0x080b020a, 0x83010807, 0x0f5f0800, 0x010a0a07, 0x1504110e, 0x01040706, 0x09010708, 0x05050507, 0x07080c09,
    0x07031f05, 0x16040302, 0x03031102, 0x100a0d12, 0x03090c03, 0x160f0211, 0x91cebd11, 0x12031303, 0x09070106, 0x0a020310, 0x07060b04, 0x06050303,
    0x0f150102, 0x0b090c05, 0x01020506, 0x03050e07, 0x040e090f, 0x8203020d, 0x02132bd3, 0x13070304, 0x1004021b, 0xa0740110, 0xfe220810, 0x011101c5,
    0x07010c0a, 0x08060608, 0x01160213, 0x16050502, 0x020d1001, 0x04020706, 0x18090301, 0xc9820503, 0x06075408, 0x020a0a05, 0x01050101, 0x05010202,
    0x04010406, 0x09040610, 0x09050208, 0x13090604, 0x050e0603, 0x080d1107, 0x15080410, 0x05040206, 0x05020203, 0x05190f16, 0x0d0d0908, 0x0e010509,
    0x1706030f, 0x010a0d02, 0x0f040c0f, 0x06051805, 0x18010a01, 0x82120108, 0x04093560, 0x0c170104, 0x0119010b, 0x010e080f, 0x02040f0c, 0x07090705,
    0x35081482, 0x0501040a, 0x14040204, 0x04190504, 0x04010309, 0x0c080702, 0x0d030204, 0x011a0f02, 0x01090202, 0x1005070e, 0x06030409, 0x03060c06,
    0x0101080e, 0x01078e50, 0xc2821001, 0x010b2408, 0x0b04111c, 0x030e0207, 0x20011b05, 0x0c010427, 0x2803032d, 0x0b020108, 0x23050609, 0x091c0606,
    0x830e0702, 0x14022833, 0x0504192a, 0x82030415, 0x1507346d, 0x06021610, 0x0809151b, 0x0d070624, 0x02020a06, 0x82040311, 0x222d08eb, 0x01081304,
    0x030b120d, 0x04061206, 0x02180805, 0x210f1d03, 0x09080901, 0x04120706, 0x09031808, 0x09010802, 0x1d030102, 0x0d100408, 0x3481820c, 0x080f0313,
    0x04020303, 0x0a102a08, 0x02101121, 0x0101030f, 0x36608201, 0x09030302, 0x010d0b06, 0x121b0511, 0x02030403, 0x05030207, 0x82280a0e, 0x0b113109,
    0x09090807, 0x13120308, 0x08050109, 0x09101304, 0x0b2d6982, 0x0c021003, 0x0708080a, 0x08020607, 0x25798210, 0x02040b01, 0x76820b0d, 0x0101022a,
    0x05060a02, 0x992482fc, 0x07236782, 0x830c0701, 0x030822ad, 0x22188206, 0x82030303, 0x09013360, 0x05060205, 0x19050314, 0x06030606, 0x0309020b,
    0xcc821004, 0x320a033e, 0x19111f0d, 0x0704160f, 0x0006081b, 0x15000300, 0x7e0615ff, 0x07008005, 0x2f001500, 0x2309334d, 0x23060109, 0x3905656c,
    0x011e0137, 0x0e071401, 0x00222301, 0x32330010, 0x14161716, 0x17150507, 0x0b82023e, 0x5a490120, 0x022b0805, 0x2556fdaa, 0x6a273435, 0xa9022626,
    0xdc029727, 0x8deb2f17, 0x01f9feb9, 0x7f3ab907, 0xfe10102c, 0x9405c1db, 0x110f097b, 0x82263426, 0xe4012102, 0x25242e82, 0x3536246c, 0x62272e82,
    0x278c0197, 0x52a78643, 0x212f0554, 0x0b220b1e, 0x036be0a9, 0x0014475b, 0x82060000, 0x219a8203, 0xa9828005, 0x0b00072f, 0x2b001b00, 0x00003b00,
    0x21352125, 0x57038701, 0x19210e17, 0x09677a01, 0x32213323, 0x2a0f8f16, 0x80020004, 0x80fe80fd, 0x82fc0004, 0x82012009, 0x00022109, 0x17f15118,
    0x8022178b, 0x02840180, 0x5240fc21, 0x1a2407f6, 0xe6012626, 0x002c0c97, 0x05000100, 0x7b0580ff, 0x15000005, 0x16250c82, 0x14110107, 0x064f7d07,
    0x26011124, 0x9c823637, 0x7b053108, 0x13fe1f11, 0x1b0c0d27, 0x1300ff12, 0x111f13fe, 0x00052a11, 0x29d9042a, 0xfd13fe1d, 0x05112a1a, 0x13000113,
    0x01e6011a, 0x27291ded, 0x04000000, 0x2f050f41, 0x03000006, 0x1b001700, 0x00002f00, 0x21352101, 0x2309db51, 0x16141521, 0x362b5882, 0x1523013d,
    0x11013521, 0x82341121, 0x0b5a5d68, 0x02800237, 0x0400fe00, 0xfa425e80, 0x025e4240, 0x011a26a0, 0x60261a40, 0x365b82ff, 0x425e00f9, 0x28386001,
    0x38284002, 0x5e426001, 0xfd800005, 0x5120fe00, 0xa020054e, 0x1a32ee82, 0x018080a0, 0x0180fee0, 0xa05e4280, 0x28383828, 0x80825ea0, 0x2808c74a,
    0x09000047, 0x17363702, 0x06e84c16, 0x3f262727, 0x17010901, 0x63f68216, 0x37220564, 0x10821f36, 0x22220e82, 0xcd4b2627, 0x16172206, 0x2012820f,
    0x050f4127, 0x1d843883, 0xfe030526, 0x9063019d, 0x2632f482, 0x2a40fe1a, 0x901f1111, 0x9dfe9dfe, 0x11111f90, 0xae82fe2a, 0x1e272825, 0x82630190,
    0x1a132410, 0x82280c0c, 0x84c020c2, 0x63012123, 0x23833482, 0x1ac0012a, 0x0c0d2726, 0xe303131a, 0x1e213795, 0x23358e27, 0x2a110513, 0x59833583,
    0x21847b84, 0x05247b83, 0x06000013, 0x2408e382, 0x06800700, 0x00110000, 0x00390031, 0x00530041, 0x0100005b, 0x22230706, 0x33103526, 0x33011e32,
    0x15063732, 0x077c4214, 0x053e3422, 0x02201482, 0x3005795a, 0x06140005, 0x36342622, 0x06100032, 0x36102620, 0x2b258220, 0x2726012b, 0x27343536,
    0x3e323316, 0x02203b82, 0x37082186, 0x67a25102, 0x7c705286, 0x3b784b06, 0x04054243, 0xfc799280, 0x07927996, 0x46362015, 0x420a3d65, 0x86888650,
    0x3d0a4250, 0x20364665, 0x00fc0715, 0x9696d496, 0xe15603d4, 0x2f051d6b, 0x52702103, 0x51a26786, 0x3b434205, 0x7c064b78, 0x3d05fc68, 0x7b058002,
    0x61014e51, 0x25172b2a, 0x0efd8b1d, 0x788b8b78, 0x64756535, 0x2b28435f, 0x02822b35, 0x5f432827, 0x05657564, 0x224b8332, 0x851ffe96, 0xfde12f4b,
    0x7b514e9f, 0x1d8b7505, 0x2a2b1725, 0x1c846a01, 0x00820020, 0x00032208, 0x0690ff10, 0x00f00570, 0x00430021, 0x01000069, 0x26012f34, 0x1e072223,
    0x06141504, 0x032e2223, 0xd8451827, 0x86362009, 0x010f211c, 0x37201387, 0x24071a64, 0x00361703, 0x44178214, 0x27200767, 0x21057144, 0x3c763f34,
    0x16350805, 0x17071415, 0x1f323336, 0x1cb00501, 0x2a281cd0, 0x0b20031e, 0x28380713, 0x0c1a190f, 0x1c21031f, 0x28291bce, 0xfd1c931c, 0x1cce1c41,
    0x931d2728, 0x1bd01c1c, 0x31258f29, 0x93557f03, 0x53797853, 0x585853ce, 0x54787a56, 0x0f8e54d0, 0x28400122, 0x202b5d82, 0x1a0c1f03, 0x38280f19,
    0x820b1307, 0x282a290b, 0x1a1bcf1c, 0xe8021c92, 0x1c240882, 0x271c921b, 0x1b212482, 0x2d248d1f, 0x53f0e1fd, 0xcf555392, 0x567b7853, 0x59825858,
    0x6f570e8d, 0x80072705, 0x1b008005, 0x17420000, 0x35002b05, 0x26373634, 0x33003435, 0xdb830432, 0x4d08e383, 0x8007011e, 0xc0fb9fe1, 0x8ef9feb9,
    0x2c010274, 0x01019ed4, 0x6a60463b, 0xa8812996, 0xe19f8001, 0x84b90701, 0x0f1c36db, 0xb02c01d4, 0x6a963e8e, 0xd11e3f4b, 0x73000200, 0x0d0680ff,
    0x17008005, 0x00002100, 0x23061625, 0x37262221, 0x46711101, 0x16220807, 0x012b0614, 0x21010511, 0x11352701, 0x05151123, 0x6a4538f7, 0x456a80fb,
    0x40f70138, 0x1a26261a, 0x05830002, 0xecfe4033, 0xc802f0fe, 0x8014f0fe, 0x7f7f5958, 0x01190359, 0x05a3458f, 0x4471fe2e, 0xad0153fe, 0x8f01251f,
    0x002571fe, 0x07250082, 0x80ff0100, 0x057f5607, 0x5c004e2a, 0x78006a00, 0x8c008600, 0x09f35f18, 0x1601052e, 0x010f0607, 0x27222306, 0x07060701,
    0x8205134c, 0x37262e0c, 0x3637013e, 0x36173233, 0x2627013f, 0x201f8327, 0x2008822e, 0x27138436, 0x1617011e, 0x011f1607, 0x8206f441, 0x36052f0c,
    0x23262726, 0x16060722, 0x32331617, 0x2a823e03, 0x0e200d82, 0x332b2782, 0x35170132, 0x27013f34, 0x83010e07, 0x28358202, 0x07150127, 0x1e171617,
    0x200b8201, 0x21758337, 0x6246a603, 0x6c390805, 0x031cfb01, 0x0d801e05, 0xfd0e1110, 0x04086e4e, 0x6207040e, 0x88918453, 0x070b5a56, 0x92845262,
    0x0d094453, 0x090d7a7a, 0x84925344, 0x05076252, 0x89552b29, 0x62538491, 0x35298207, 0xb2026e08, 0x0d10110e, 0x03051e80, 0x2e5cfb1c, 0x645c5132,
    0x0685274a, 0x32512e27, 0x644a272e, 0x3706855c, 0x21600e01, 0x031a4f0e, 0x0402050e, 0x0260d701, 0x00fd80e0, 0x050209a0, 0x1a294482, 0xfd806003,
    0x0b02b1f8, 0x05244702, 0xfe1a4308, 0x23241472, 0x08074010, 0x04428301, 0x4d303101, 0x4e54358d, 0x8e4c7b54, 0x0d1f5435, 0x09494909, 0x35541f0d,
    0x6c3b4c8e, 0x34544f27, 0x31304d8e, 0x01420401, 0x40070883, 0x14242310, 0x33842a8a, 0x0483243b, 0x333bfd25, 0x84242a84, 0x023b0804, 0x240b3aa0,
    0x1a2f0814, 0x02041003, 0x20e90103, 0xfe404002, 0x08607151, 0x10040402, 0xc0fe1a04, 0x8a980140, 0x00000403, 0xff000005, 0x06000700, 0x001f0000,
    0x00250022, 0x593c0033, 0xa0450e87, 0x72362005, 0x152c07ad, 0x07333611, 0x01092101, 0x11011321, 0x82051b61, 0x36342106, 0x06210c88, 0x07115aa0,
    0x28e0fd2b, 0x011c2838, 0x28601c98, 0x27148201, 0xfe803c44, 0xfd2b01d5, 0xc42d0584, 0x80fe3c01, 0x60fe2838, 0x03280002, 0x200a85d8, 0x21108204,
    0x3d8340fb, 0x38200127, 0x28a00228, 0x823c8360, 0xb8fe3d43, 0xd5fed528, 0xd5feab02, 0x3c01a4fe, 0x60fea001, 0x80fd3828, 0x60280001, 0x8004f8fc,
    0x00200d85, 0x0032b682, 0x0584ff04, 0x007c057c, 0x2500003f, 0x22230614, 0x75540127, 0x01172305, 0x0f861516, 0x26058253, 0x32331601, 0x82343536,
    0x870f871f, 0x3435241f, 0x82323336, 0x0562082f, 0x87759e7c, 0x71f7fc64, 0x739e9fdc, 0x3d0a5d02, 0xfd0a0d10, 0x6a664fa2, 0x08034c92, 0x5440523f,
    0x1abbfd3f, 0x19261d22, 0x3e0a9a01, 0xfe0a0c10, 0x52723f66, 0x45023d58, 0x9e759764, 0x73080364, 0x71de9f9c, 0x0c0aa2fd, 0x020a3d10, 0x6a964d5f,
    0xf7fc4c69, 0x5240543f, 0x1845023f, 0x1b201d26, 0x1b8266fe, 0x010a3e27, 0x52583d9a, 0x204c8272, 0x0cdb6762, 0x31002134, 0x00004500, 0x21110129,
    0x34113301, 0x2e012726, 0xd0482301, 0x11232108, 0xf2521382, 0x094a5005, 0x1805e050, 0x330f414f, 0x011e0117, 0x00038001, 0x800300fd, 0xfe0a1480,
    0x0f300ae7, 0x2a05915b, 0x28388080, 0x38284003, 0x181380fe, 0x2008f359, 0x23138202, 0x3828c0fa, 0xa0361982, 0x011c6028, 0x01281c18, 0x0380fe80,
    0x0a310e80, 0x140a1901, 0x1b8360fe, 0xfba00125, 0x83a00100, 0x00022109, 0x210add59, 0x1d84fc13, 0x53820520, 0xfe1c2826, 0x00601ce8, 0x180b0348,
    0x6414874f, 0x04210b35, 0x0b1c5f60, 0x03203b82, 0xd75a0382, 0x000f2505, 0x002f001f, 0x10fd5d18, 0x0fbb5818, 0x4f180f8f, 0x26210de7, 0x504e181a,
    0x250b8a0a, 0x261a80c0, 0x04831a26, 0x93e60121, 0x2782820a, 0x07c0ff00, 0x00400500, 0x25055f5b, 0x00370027, 0xc1760047, 0x47122008, 0x012006a1,
    0x200ee77f, 0x8f179600, 0x06375ca5, 0xa0707022, 0x05210282, 0x0b695bf0, 0x525cfa20, 0x8b148d05, 0x83d02020, 0x01702233, 0x24068490, 0x0dc0a0fd,
    0x05cb4113, 0x8fe30321, 0x18012011, 0x4109595b, 0x0f210556, 0x36ce82ff, 0x1e00f705, 0x4c003c00, 0x6c005c00, 0x00007c00, 0x23061405, 0x43372722,
    0x0738051d, 0x37023e27, 0x23062235, 0x21352315, 0x011e0715, 0x26211513, 0x033e3435, 0x2c052f59, 0x33013e27, 0x14151632, 0x3307020e, 0x2ffc8f35,
    0x35211501, 0x3d363433, 0x07062301, 0x11333727, 0x04411f8f, 0x7d310810, 0x426a516d, 0x1d393139, 0x081a692b, 0x10132431, 0x016a1041, 0x3c335f4d,
    0x0696fe02, 0x2f42422f, 0x232e191d, 0x3a5f1855, 0x52446449, 0x057f0145, 0x050741ea, 0x040e1222, 0xfa2df582, 0x6bb1fe80, 0x2a080201, 0x056a8847,
    0x41198bec, 0x31080b2d, 0x425c5054, 0x1c1d2d58, 0x0a380840, 0x01122943, 0x58983502, 0x024a0c73, 0x12249f40, 0x2b345433, 0x1b19172c, 0x39333b3a,
    0x53324753, 0x3c19372e, 0x5041c1fe, 0x120e3205, 0x63760313, 0x29a12963, 0x4c25110c, 0xfe6cfe7f, 0x4118887d, 0x03200e57, 0x2a086b5a, 0x0035000f,
    0x01000065, 0x471d1632, 0x263105e3, 0x3634013d, 0x27262533, 0x37343526, 0x17322136, 0x25018316, 0x010f1415, 0xd846012f, 0x081c5806, 0x16210326,
    0x06071415, 0x23210185, 0x82208422, 0x2627273e, 0x3735013f, 0x3a85021e, 0x37323331, 0x35363736, 0x06262734, 0x12120ee0, 0x8340f90e, 0x014e0805,
    0x30171cc3, 0x04018586, 0x6f427532, 0x050e0b0a, 0x320e540c, 0x727a5835, 0x42424344, 0x3a6845d5, 0x9b01ec25, 0x30172907, 0x49504825, 0x51727b50,
    0x080f398c, 0x02010102, 0x0f1e0f66, 0x2b2d2305, 0x40493b3e, 0x2f2d4d4b, 0x80022251, 0x53840e12, 0x4e080482, 0x622d2340, 0x7f80b55a, 0x26240c13,
    0x123c7b50, 0x0206031b, 0x3b5b3895, 0x4349583a, 0x2e143e43, 0x00ff181c, 0x656f3527, 0x2e233038, 0x17151230, 0x080c1028, 0x306c0d0e, 0x2c25261e,
    0x264a2202, 0x24253908, 0x1a1b1615, 0x54443d3c, 0x55001d49, 0x632d09af, 0x00007300, 0x012f2613, 0x17323336, 0x30d38416, 0x17073732, 0x22230615,
    0x14150607, 0x13171516, 0x84ef8316, 0x83ef8219, 0x412e20f1, 0x0f280532, 0x33372701, 0x17371617, 0x83082c41, 0x1316222f, 0x09394116, 0x83262721,
    0x11352901, 0x01262734, 0x23263435, 0x0808a356, 0x303632c3, 0x0d030825, 0x84343c1b, 0x74525622, 0x011e381e, 0x3c403c02, 0x01010d13, 0x232d060e,
    0x6859583d, 0x302b3857, 0x15112411, 0x04060f07, 0x2b221305, 0x54020e64, 0x12784ccd, 0x272d0406, 0x030f0649, 0x15060e08, 0x4a261a0f, 0x926d6b4b,
    0x3c7775a7, 0x1110163d, 0x12560519, 0x0e40fa0e, 0x050e1212, 0x05120ec0, 0x58020221, 0x03070401, 0x0e020104, 0x19090940, 0x270d760e, 0xe8fee506,
    0x213b4e7c, 0x21121c2f, 0x3a381c24, 0x624f9c49, 0x433b5693, 0x02012315, 0x030a5603, 0x0d26020d, 0x010c1807, 0x1a0f060b, 0x130b2807, 0x6dc387fe,
    0x3a412e4c, 0x2e212039, 0x774c4b2f, 0x4d019d50, 0xfa2419bc, 0x83668482, 0x00002304, 0x0082000a, 0x18800621, 0x23142f84, 0x2500009f, 0x1120fb8e,
    0x1b410f8e, 0x8f0fcf0f, 0x06285c6f, 0x2a08f17a, 0x0e120002, 0x120ec0fe, 0x84010e12, 0x8d0b89d4, 0x8cfe2019, 0x8d1b8d27, 0x8b299b0d, 0x5e802d6b,
    0x42c0fa42, 0x05425e5e, 0xa05e4240, 0x04838284, 0x888e0121, 0x89fe200a, 0x0e03210a, 0x20a01593, 0x01224c8a, 0x6d84fb4e, 0x6d820420, 0x005e2108,
    0x00060000, 0x069bff1b, 0x00000680, 0x00130003, 0x0023001b, 0x0033002b, 0x27010900, 0x07142401, 0x08ff4a18, 0x1f32362c, 0x0f172501, 0x3f012f01,
    0x07960101, 0x01a60433, 0xdbfe6b25, 0xfa122a02, 0x123612fa, 0x051212c6, 0x25078306, 0x6262cbfa, 0x03821e1e, 0xc47c0125, 0x823c3cc4, 0xde032103,
    0xfd211186, 0x2108869e, 0x3b84bb03, 0x8336d521, 0x203a823b, 0x223b8336, 0x8491c612, 0x621e2337, 0x3784fcfe, 0xfdc43c23, 0x2111865e, 0x08861e02,
    0x0422c382, 0xff4b4000, 0x00102408, 0x524d0018, 0x0129092d, 0x22231121, 0x1506010f, 0x07ca5b00, 0x0e141125, 0x61232604, 0x05840510, 0x06222322,
    0x2a05f84d, 0x3e263411, 0x3e013f03, 0x50013b01, 0x02310696, 0x4c684c80, 0xccfe684c, 0x0d9e8001, 0x0509c309, 0x2d0f8400, 0x13084c01, 0x270c210e,
    0x96d49603, 0x048280fe, 0x2703403a, 0x130e210c, 0x011a2608, 0x13090401, 0x3f13c60d, 0x1a26a01b, 0x261a0004, 0x4c243084, 0x00018002, 0x0d223f82,
    0x4f83aefd, 0xc0044c2f, 0x170f00fc, 0x0103090e, 0x96966a01, 0x3003836a, 0x09030101, 0x1a0f170e, 0x08400126, 0x1b2f1636, 0x24448222, 0x261ac01a,
    0x0cc34826, 0x0d824a20, 0x0402102e, 0x36272223, 0x1e373637, 0x3e323301, 0x2e31ab82, 0x0e222301, 0x16141503, 0x3e371617, 0x27363701, 0x20bf8326,
    0x05724a32, 0x60372621, 0xa008065f, 0x17141506, 0x26170603, 0x12343502, 0x06042024, 0x9ffece00, 0x3b6b6fd1, 0x142d0913, 0xbe793d6a, 0x8ee27768,
    0x5b7fb669, 0x1e4d502b, 0x020c0208, 0xd1331106, 0x89a997a9, 0x0e4a3d6b, 0x36172508, 0x19563e32, 0xce041163, 0x6101cefe, 0x6101a201, 0x5efe5103,
    0x20ce9ffe, 0xb122475d, 0xf0893927, 0x7ec87296, 0x867d603a, 0x209e6843, 0x3007200c, 0x3d141706, 0xa4d9975a, 0x57eeaa83, 0x5975233d, 0x7242321f,
    0xfe314955, 0x5b6b465e, 0xd1e97c01, 0xcece6101, 0x00010000, 0x0680ff00, 0x00800500, 0x0af74b4c, 0x1224dd87, 0x022e3435, 0x1583dc88, 0x2320dc9d,
    0x7c066076, 0x2408053f, 0x17552bfd, 0x69152c09, 0x46e5b53c, 0x686ab67b, 0x2b5a7db5, 0x150d4d4f, 0x06050a04, 0xa7cf3211, 0x6a87a795, 0x2fdc833c,
    0x3d313516, 0x18621855, 0xa977b711, 0x800577a9, 0x0805154a, 0x22587a39, 0x013827af, 0x9d54e227, 0x60394979, 0x6642857b, 0x0a05209c, 0x17112c0e,
    0x96583e13, 0xa881a2d5, 0x223c57ec, 0x311f5775, 0x48537141, 0x6462fe31, 0x0377a99a, 0x5aa977c0, 0x1b240cdb, 0x37002700, 0x3426db82, 0x33152127,
    0x074f030e, 0x17323705, 0x22232637, 0x33161006, 0x33253632, 0x23352335, 0x33152315, 0x436a3315, 0x95033e0f, 0xd996fe06, 0x55301b03, 0x8c8c6336,
    0x683d5c63, 0xe0a0956c, 0xcba5a0e0, 0x6d6d5901, 0x2100826e, 0xad851201, 0x02347985, 0x84261a77, 0x23363418, 0x3b8ec88e, 0xfee16465, 0x77d2e1c2,
    0x6e232582, 0x4a85026e, 0x022c0cdd, 0xa3ff0000, 0x5d050009, 0x2f002300, 0x142f9d82, 0x22230402, 0x10022624, 0x33243612, 0x82071720, 0x010e2e9d,
    0x33011e14, 0x37033e32, 0x16213521, 0x82a08225, 0x353808a6, 0x15333533, 0xfeae9d05, 0xfe95d0be, 0x7474c4f0, 0x951001c4, 0xc7cd1e01, 0xd17baf75,
    0x7bd17a7a, 0x435a8b53, 0x60fe061f, 0x030cb402, 0xd1d2d163, 0x6f02d2d1, 0xb7bbfed0, 0x01352883, 0xc410012a, 0x71bfc074, 0xd5fcd57c, 0x58452e7c,
    0x3ffc234e, 0x2223833f, 0x5400d1d1, 0x36080743, 0x00000580, 0x001c000c, 0x003c002c, 0x35210100, 0x07231123, 0x33373617, 0x14242311, 0x2e22020e,
    0x023e3402, 0x01011e32, 0x35262211, 0x23061421, 0x15163211, 0x45363421, 0x03340fd1, 0x80800100, 0x2a4d9472, 0x0280020d, 0x7e4d2a00, 0x2a4d7e96,
    0x02360685, 0xfb966a2a, 0x6a6a9680, 0x96800496, 0xf91a26ea, 0x26261a00, 0x0582071a, 0x60800132, 0x5089c001, 0xe0fe1425, 0x7c908ce6, 0x907c4e4e,
    0xfe230685, 0x8300022a, 0x84fe2030, 0x40032305, 0x328380fb, 0x05830420, 0x0282a482, 0x00044026, 0x0d008003, 0x1433c582, 0x22060107, 0x34260127,
    0x32213336, 0xfe130004, 0x83341340, 0x1a262604, 0x031a8003, 0x250b845a, 0x13c00113, 0x2c822634, 0x00010022, 0x3b820282, 0x3b854020, 0x21230625,
    0x6f342622, 0x042405e4, 0xfc1a2600, 0x2c846182, 0x01250482, 0x2626345a, 0x20088234, 0x854e8213, 0x0040253b, 0x04800280, 0x01227784, 0x76851411,
    0x16223c83, 0x29828002, 0x3b847982, 0x40042622, 0x1320478b, 0x82065344, 0x8540203b, 0x08d9733b, 0x32363426, 0x40020117, 0x6b85b384, 0x899a0221,
    0x862620bc, 0x00032a77, 0x0680ff00, 0x00800580, 0x2ab58206, 0x3300001d, 0x11211121, 0x82251614, 0x32212105, 0x2d108941, 0xfd6002a0, 0x6d051380,
    0x600280fd, 0xef46130d, 0x80042e0c, 0x130da0fb, 0xfb600420, 0xcd041380, 0x083069fb, 0x02005e22, 0xc0286382, 0x40050004, 0x1b000d00, 0x210f5541,
    0x27411412, 0x0d63410d, 0x36412620, 0x41da200e, 0x43410a72, 0xff002112, 0x02216782, 0x21bb4100, 0x488b0120, 0x00820020, 0x00000124, 0xa3860003,
    0x8e000021, 0x20848d93, 0x0fbb4103, 0xdf820220, 0x2205b352, 0x763a001a, 0x20080b17, 0x17041716, 0x023b021e, 0x37013e32, 0x13362536, 0x00070614,
    0x2b040e07, 0x032e2202, 0x27242627, 0x079c462e, 0x57000721, 0x64080528, 0x6a01392c, 0x76473987, 0x33010133, 0xaa394776, 0x2b394801, 0x88fe4962,
    0x2b410a5c, 0x0117363d, 0x3d361701, 0x5b0a412b, 0x3e22aafe, 0x054d536e, 0x035f41c0, 0x42e6fc3a, 0x03425e5e, 0xf626311a, 0x312f2a63, 0x7b2a2f31,
    0x560127de, 0xfe33904f, 0x2f0740fb, 0x1212241d, 0x072f1d24, 0x2a18ed40, 0x684e3f93, 0x26e8825e, 0x06b0ff00, 0x826c0500, 0x000f2209, 0x27b1832b,
    0x16011121, 0x22012b06, 0x22054d68, 0x64211101, 0x62080568, 0x11150607, 0x2f101221, 0x23152101, 0x3233033e, 0xfe5d0116, 0x015f01b6, 0x52025467,
    0x64a66764, 0xb7fe8f04, 0x553f5651, 0xb7fe0b15, 0x01010102, 0x2a140249, 0xab3f6747, 0xfc8f03d0, 0x01df0321, 0x62624932, 0x61614a49, 0xc8fdddfc,
    0x77691202, 0x331e3345, 0x8f01d7fd, 0x3030f001, 0x38302090, 0x4100e31f, 0xff20057b, 0x20053746, 0x3c0d8234, 0x04060210, 0x27242223, 0x013f3626,
    0x17163336, 0x3233011e, 0x2e34023e, 0x06222302, 0x0ee65707, 0x24362708, 0x16043233, 0xce7a0006, 0xac9ce4fe, 0x076dcafe, 0x0a890801, 0x4907100f,
    0xbd6877d4, 0x8a51518a, 0xb46268bd, 0xd1578946, 0x6b823b0a, 0x9c931301, 0x03ce1c01, 0xfec8fe1c, 0x917acee4, 0x08190a84, 0x0a02098a, 0x2e82685f,
    0x3582d020, 0x8a424722, 0x330ab957, 0x7a6f6581, 0x000100ce, 0x0615ff28, 0x00d805eb, 0x21000071, 0x0cb45618, 0x2206072a, 0x15061e27, 0x050e0714,
    0x28062552, 0x3637043e, 0x051e3233, 0x06fe4317, 0x35062e37, 0x053e3734, 0x01173233, 0x0e141516, 0x23060704, 0x27052e22, 0x82468216, 0x081583e2,
    0x25eb0639, 0x3534276b, 0x2695fe25, 0x7e00ff2b, 0x020e280e, 0x04100415, 0x031c0308, 0x121a0b1b, 0x1c280d1a, 0x091c68fe, 0x1e0b1609, 0x0a261e03,
    0x110a1110, 0x0e021406, 0x935c010e, 0x9801212a, 0x7e352a92, 0x352b0001, 0x6b012734, 0x6c253525, 0x6c012525, 0x2b353624, 0x236b8201, 0x0614020e,
    0x10224f82, 0x5b82260a, 0x09160b24, 0x3f821c09, 0x820d2821, 0x1b0b2575, 0x08031c03, 0x15218782, 0x82668202, 0x822a916b, 0x232a9295, 0x2b00ff7e,
    0x2723cb82, 0x43070000, 0x072c081b, 0x21000f00, 0x31002900, 0x4b003900, 0x49095b7d, 0x133008cc, 0x06012e36, 0x010e0307, 0x011e0607, 0x26363736,
    0x87070868, 0x07116721, 0x0710013a, 0x22212306, 0x34112627, 0x20243612, 0x01121604, 0x4b6a4b80, 0x0b016a4b, 0xf7330685, 0x321b0665, 0x3c65072e,
    0x5014105e, 0x10148a9a, 0x8462022c, 0xcbfd2119, 0x02200684, 0x8b332786, 0xfa23138d, 0x8d132386, 0x4c01f08e, 0x4c016c01, 0x84018ef0, 0x024b2220,
    0x364f830b, 0x019ffe4b, 0x0e2d1a7e, 0x82fe1a1b, 0x4d3c4d05, 0x4d50288a, 0x840e723c, 0xcb02211a, 0x75200684, 0xfe2a0584, 0xdefbfec0, 0x01dd1d1d,
    0x4483b606, 0xfef08e23, 0x21e082b4, 0x4b180200, 0x162c0873, 0x00003c00, 0x06042000, 0x1f161415, 0x072ce082, 0x17013f36, 0x24323316, 0x04261036,
    0x2505044a, 0x07060506, 0x4b182223, 0x12200f8d, 0x043adf82, 0xfe68fe4c, 0x828fd19d, 0x2e181b57, 0x392b7b98, 0x01cc3d45, 0x01d1d163, 0x4b18f051,
    0x052309a3, 0x1804180f, 0x3d0fa44b, 0x019c01f0, 0x049c01e8, 0x89ec8b80, 0x324acb70, 0x3f515b60, 0x0806266c, 0x1201ec8b, 0x4b18c7ec, 0x152109b8,
    0xb74b1811, 0x01ae2412, 0x69abab27, 0x002609cf, 0x3a001400, 0xc58b6400, 0x3421c388, 0x22a58226, 0x18061016, 0x20184541, 0x3f411801, 0x1520081d,
    0x59030614, 0xf6fecefe, 0x61606a9d, 0x2c1c2223, 0x994b4e35, 0x9d9d0a01, 0x7e019efd, 0xbcbc4501, 0x1d5d4118, 0x0a3a0522, 0x23554118, 0x80048e36,
    0x5266b268, 0x54383898, 0x0a1f1314, 0xccb2680e, 0xec89e8b2, 0x1e6a4118, 0x18f8fb23, 0x65411828, 0x787b3d1f, 0x000100d1, 0x0300ff01, 0x0080057c,
    0x01000021, 0x06010716, 0x2e272223, 0x05133701, 0x26200883, 0x08070c6f, 0x0714154a, 0x33362503, 0x12750332, 0x0de4fd0b, 0x110a041d, 0xfec50411,
    0x1208046a, 0xc905120d, 0x01101804, 0x051a1348, 0x088c01ab, 0xca031304, 0x7bfb1814, 0x1c050219, 0x65280310, 0x180f0b01, 0x120e3903, 0x0a081119,
    0x026231fe, 0x5b436682, 0x00802206, 0x0b754655, 0x3b363426, 0x15213501, 0x960e6c71, 0x36342413, 0x4b352133, 0x2129076a, 0x11151632, 0x012b0614,
    0x21098215, 0x4182011d, 0x3800072d, 0x28c0fe28, 0x60283838, 0x836000fe, 0x220d9407, 0x8502344c, 0x4001211d, 0x02232b84, 0x824c3400, 0x1801202d,
    0x210a5388, 0x4987c0c0, 0x0d8e2383, 0x824c3421, 0x833b851d, 0x4cc0245f, 0x4238c034, 0x0629067b, 0x00c00580, 0x004f0013, 0x46e38559, 0x152806a2,
    0x36321614, 0x32361135, 0x28056554, 0x2223012e, 0x010e0706, 0x05764107, 0x012e2722, 0x1e830e8e, 0x0805e769, 0x0036373b, 0x04323324, 0x1617011e,
    0x22261501, 0x36343507, 0x80031632, 0x2698d098, 0x644e2634, 0x033e214e, 0x0b0d1321, 0x3a58310c, 0x072b7844, 0x110b0415, 0x15040b12, 0x88772b07,
    0x210e8477, 0x0e841112, 0x3a44783b, 0x0b0c3158, 0x2d01130d, 0x5501ff00, 0x0d018cbe, 0x0121a5e0, 0x2c2a00fd, 0x0849822a, 0xfdc40224, 0x989868bc,
    0x26261a68, 0x4e4e321a, 0x0b440232, 0x0a130d26, 0x3c4a2e2e, 0x1106240a, 0x0a240611, 0x0b8b4a3c, 0x0a2e2e35, 0x02050d13, 0x881101b7, 0x8ae39350,
    0x62d20202, 0x82620202, 0x0400213e, 0x31085759, 0x00180008, 0x0037001b, 0x11210500, 0x35262221, 0x5c512111, 0x09212110, 0x2007774c, 0x1465183d,
    0x17163a0d, 0x03011e01, 0xfe800300, 0xfe382860, 0x13000180, 0x0d40fd0d, 0x020d1313, 0x26c382c0, 0xfe2b0100, 0x730002d5, 0xfd38057e, 0x383828e0,
    0x28400428, 0x010f1538, 0x80281c98, 0x28388002, 0x2001a001, 0x082b5618, 0x826dfd21, 0xfd55212f, 0x38254982, 0x2838a028, 0x2a2a8205, 0xb8fe2838,
    0x68fe0f0d, 0x8200601c, 0x00032100, 0x070b6618, 0x28001029, 0x00005c00, 0x82061401, 0x263421b0, 0x2206334d, 0x7017011e, 0x142106d5, 0x2d0b8217,
    0x36331716, 0x37013e37, 0x07143736, 0x186f020e, 0x14152105, 0x06260783, 0x22010e23, 0x3b832726, 0x35263723, 0x22038434, 0x8227022e, 0x023e2b0a,
    0x02021e32, 0x131a13e0, 0xc783346c, 0x4b633233, 0x876f45a0, 0x456f878a, 0x0a290a44, 0x0de40d80, 0x08078280, 0x67804427, 0x043c3b2d, 0x2d19192f,
    0x142e3f0d, 0x14505e50, 0x2d0d3f2e, 0x042f1919, 0x672d3b3c, 0xbeb79159, 0x035991b7, 0x214283c0, 0x4d82322e, 0x344c2033, 0x2d4f7c48, 0x487c4f2d,
    0x2c0b4f65, 0x9191990b, 0x3d068299, 0x719b654f, 0x32734c31, 0x1b25361c, 0x1d34251b, 0x322e1817, 0x2c34342c, 0x17182e32, 0x1383341d, 0x321c363e,
    0x71314c73, 0x71ab639b, 0xab714141, 0x00000200, 0x0007a0ff, 0x1a00e004, 0x00003400, 0x5a05b656, 0x3733091b, 0x32333601, 0x21011d16, 0x14101632,
    0x23060107, 0x183d2622, 0x2009995e, 0x053b5a35, 0x1300073a, 0x13a0fa0d, 0xfe0c0c0d, 0x010909c1, 0x0d0e0940, 0x0d600513, 0xc0fe0913, 0xfa210a83,
    0x29b683a0, 0x0e126005, 0x3f010c0c, 0xc5826001, 0x0a200282, 0x0d212782, 0x262d830e, 0x13c00d13, 0x831c2102, 0x200a832d, 0x181c820d, 0x83081252,
    0x00002f9f, 0x80058007, 0x35001900, 0x34010000, 0x015a2b26, 0x07cb5a09, 0xa6823220, 0x06140525, 0x5e222123, 0x05241557, 0xe00e1200, 0x0d225b82,
    0x9582e013, 0x09600128, 0x5f01091c, 0x6d5e020a, 0x768c3507, 0xd42c0102, 0x3b03019c, 0x966a5f47, 0x02a78229, 0x01120e60, 0x1322c082, 0xd682fe0d,
    0xfe090e23, 0x38d682a0, 0x9fd40c5f, 0xb90701e1, 0x1e37dc82, 0x2c01d40d, 0x963e90ae, 0x1f3e4c6a, 0x2aa391d1, 0x22260127, 0x15060107, 0x6b3b1614,
    0x33220987, 0xfb5e3632, 0x0005211b, 0x1c246683, 0x0aa1fe09, 0xa39aac8a, 0x090ea022, 0x2f82c982, 0x0e0c0c2e, 0x0da0fe12, 0x010d1313, 0xedfe1360,
    0xef42a496, 0x80052a07, 0x07008005, 0x60005800, 0x08d15900, 0x2a053b41, 0x3e343526, 0x1d063703, 0x44010e01, 0x342c05b9, 0x34352726, 0x37201637,
    0x22011d16, 0xd0831782, 0x35363223, 0x21158234, 0x13823236, 0x26280f8a, 0x2e363427, 0x041e2702, 0x5d08d861, 0x240805ea, 0x79922604, 0x927996fc,
    0x683a250b, 0x463a1644, 0x4770a070, 0x01841939, 0x6a198446, 0x50382096, 0x684c2038, 0x2e07844c, 0x01013b45, 0x44080a04, 0x0b253a68, 0x61e1c0fe,
    0x3508057a, 0x262634da, 0x797d2634, 0x44798a8a, 0x5b73967e, 0xcb44340f, 0x503d6414, 0x3d507070, 0x3ecb1464, 0x1f68681f, 0x6a96403e, 0x282a1d59,
    0x2a283838, 0x4c34591d, 0x0d89344c, 0x2277442f, 0x341f410a, 0x5b0f132a, 0x037e9673, 0xfb9c18d8, 0x00022409, 0x4180ff00, 0x4d20060b, 0x0809e949,
    0x06143722, 0x04141107, 0x013d2420, 0x1135012e, 0x32333634, 0x33013e17, 0x06141632, 0x11272223, 0x36201614, 0x83058b6f, 0x60162019, 0x112005b9,
    0x15203382, 0x33821985, 0x32363422, 0x3c08b670, 0xf9fe3947, 0xf9fe8efe, 0x1a26dca4, 0x3c110a06, 0x4b4b3523, 0xbc1f2135, 0x1fbc0801, 0x280b8321,
    0x0a113c23, 0xdc261a06, 0x251283a4, 0xa0704739, 0x74600370, 0x40210805, 0xfe15623e, 0xe1e19f75, 0xd814849f, 0x1a000290, 0x241e0226, 0x124b6a4b,
    0x966a6efe, 0x92016a96, 0x2a0c8212, 0x26021e24, 0x9000fe1a, 0x848414d8, 0x158b2814, 0x70503e62, 0x47040070, 0x032e0873, 0x1b000d00, 0x00002500,
    0x21352101, 0x43471105, 0x21112308, 0x73543311, 0x011d2206, 0x22c08205, 0x8211012b, 0x800231e4, 0x00fe0002, 0x5c40a0fe, 0x045c8484, 0x8000fca0,
    0x24050265, 0x5c840002, 0x24148240, 0x80808004, 0x200b82fb, 0x350b8203, 0x000500fb, 0x383828a0, 0xfce0a028, 0x05845cc0, 0x02008400, 0x23764000,
    0x00332108, 0x760d2176, 0x03212915, 0x26087640, 0x3324f875, 0xff000003, 0x05400780, 0x00070000, 0x0022000f, 0x26340000, 0x0121ec84, 0x25928321,
    0x10002622, 0xf5442b06, 0x06cb5305, 0x0632213a, 0x40507080, 0xf0f95040, 0x6a960007, 0x966a00fb, 0x9fe14007, 0xfd5c8440, 0x2008f682, 0x80041a26,
    0xa030039f, 0xfd80fe70, 0x96966ac0, 0xc2fe0904, 0x845c20e1, 0xe0025c84, 0x0000261a, 0x2f6f8202, 0x06800500, 0x002d0000, 0x01000042, 0x07061411,
    0x4208617a, 0x32230552, 0x48111516, 0x34210519, 0x410b8d36, 0x87830589, 0x2c08a941, 0x80021632, 0x344c3947, 0x394c3480, 0x051b4247, 0x03210588,
    0x08178400, 0x130de022, 0x000184bc, 0xc005261a, 0x643d80fd, 0x34f5fc14, 0x03344c4c, 0x3d64140b, 0x261a8002, 0x60fe1a26, 0x01210583, 0x210b8fa0,
    0x2883c0f9, 0x1300022a, 0x8420030d, 0x060026bc, 0x0620bb83, 0x132a0683, 0x23001a00, 0x43003300, 0x93185300, 0x012025e5, 0x08205718, 0x21230622,
    0x0520c082, 0x5c0e055c, 0x94180f15, 0x012f2015, 0x020e1200, 0x12120ec0, 0x0e40fd0e, 0x87e00212, 0x24158b09, 0x84040e12, 0x3b94181c, 0x6003211f,
    0x43823a83, 0xa00e1222, 0x2009dd5b, 0x845e82ff, 0x21048213, 0xb3411400, 0x000f2108, 0x1307a118, 0xcf00bf30, 0xef00df00, 0x0f01ff00, 0x2d011f01,
    0x995f3d01, 0x012b2405, 0x823d2622, 0x823b20f8, 0x153523dc, 0x0f8b0614, 0x0f8e0520, 0x0fe77a18, 0x1f9e0120, 0x0f8f2f8f, 0x6f9f3fef, 0x0122ef8f,
    0x01821121, 0x18066244, 0x21108b49, 0x8f188001, 0x01211317, 0x20158900, 0x200b8aff, 0x8b179603, 0x202fdf23, 0x8d839602, 0x800124b3, 0x820180fb,
    0x40012edb, 0x0002130d, 0x00fb1a26, 0x1a26261a, 0x20058205, 0x08954ae0, 0x0988f320, 0x13920d20, 0x1ebc8f18, 0x28c73c89, 0x5289fe20, 0xfa269993,
    0xfa000693, 0xc049e000, 0x80f92105, 0x0620ce83, 0x00210583, 0x1c33430d, 0xdb00b724, 0x2543f500, 0x33a54271, 0x4208c462, 0x192b0aaf, 0x2b263401,
    0x1d062201, 0x85352301, 0x11152b09, 0x013b1614, 0x013d3632, 0x09851533, 0x6d6d2520, 0x0890770c, 0x18322121, 0x4216ff91, 0xe9420d29, 0x23dd4209,
    0x29277d42, 0x283800ff, 0x382840fe, 0x854200ff, 0x43678407, 0x0a850a6d, 0x2b099b42, 0x28384001, 0x3828c001, 0x261a4001, 0x4246a342, 0xfc321e51,
    0x20800493, 0x28383828, 0xe080fb20, 0x0d13130d, 0x5265c003, 0x4b602005, 0xc0200570, 0x0b841383, 0x3e432d20, 0x84012009, 0xe0fe3631, 0x00050026,
    0x0780ff40, 0x00800580, 0x00100007, 0x003c0018, 0x0d7d5d63, 0x010f0624, 0x8e530706, 0x35132507, 0x012b2634, 0x22240484, 0x23011d06, 0x2105b077,
    0xc341013b, 0x013d2906, 0x01363233, 0x2b061411, 0x2505f94d, 0x22061421, 0xfd4d3526, 0x34112805, 0x3e013f36, 0x41013b01, 0x022006da, 0x3c05bf53,
    0x8001cbfe, 0xc3080e9e, 0x00050207, 0x4b4b6a4b, 0x0e12cb6a, 0xc00e12e0, 0x0ee0120e, 0x240a8a12, 0x1a260001, 0x07af5dc0, 0x261a802e, 0x131a1a26,
    0x1a4013c6, 0x041a26a0, 0x3a840e82, 0x80024b2b, 0x07020001, 0xfd0a0cc3, 0x224a83ad, 0x9020034b, 0x22528347, 0x82fb2e02, 0x5d6a2032, 0x262606b9,
    0xa0012634, 0x4d82401a, 0x40011a22, 0x00225882, 0xef490500, 0x00232a08, 0x00310027, 0x0049003f, 0x9ef58500, 0x24154afa, 0x95000521, 0x4afd20e2,
    0x802a052d, 0x84845c20, 0xfbc0045c, 0x2d4aa0c0, 0x82202009, 0xa0012114, 0xee20cd95, 0x201c444a, 0x82ba8200, 0x07002603, 0x00800480, 0x350c823a,
    0x07010d06, 0x32330123, 0x2b061416, 0x11333503, 0x27230723, 0x01823335, 0x37352724, 0x01822335, 0x17333722, 0x35221582, 0x2284023b, 0x01012808,
    0x1e051733, 0x80071701, 0xfee1fe01, 0xfe40e0a0, 0x261a45db, 0xa0601a26, 0xc0a04040, 0x80202060, 0x2080c0c0, 0x83c06020, 0x8360200f, 0x01452c19,
    0x01e04025, 0x08908060, 0x82204002, 0xa0fe3001, 0x20090e09, 0x20e0a001, 0x180820c0, 0x82081880, 0x01e02307, 0x158220a0, 0x40a0fe26, 0x0a301c20,
    0x41089f82, 0x00400002, 0x05800600, 0x00060080, 0x01000018, 0x14112111, 0x15013316, 0x23373521, 0x11352622, 0x37213727, 0x11071721, 0x00ff8002,
    0x8004354b, 0x808080fb, 0x2040e19f, 0x0320e001, 0x024020c0, 0x18820180, 0x4b352308, 0xc0c040fe, 0x019fe1c0, 0x80804040, 0xe0fc20c0, 0x00000200,
    0x000680ff, 0x23008005, 0x00003300, 0x7f441125, 0x88212007, 0x057f4409, 0x71843520, 0x42013b21, 0x441805c0, 0x212a0842, 0x00051632, 0x1a801a26,
    0x0685fe26, 0x02200b84, 0x47180b85, 0xc0210dde, 0x24258203, 0xc0fe1a26, 0xffad1801, 0xc0fe260c, 0x0326261a, 0x0cbd5dba, 0x978f0020, 0x8805d251,
    0xcb751892, 0x0f5b5e14, 0xfe219783, 0x848f84c0, 0x011a2263, 0x830c8440, 0x21998d7e, 0x99824002, 0x308f9585, 0x8d3a0221, 0x00022f98, 0x034d002d,
    0x003304f3, 0x00290014, 0x77182400, 0x0723100b, 0x93040109, 0x73022c14, 0x1a0a320a, 0x0a2efe0a, 0x82d2010a, 0x0a322808, 0x0177fe0a, 0x948a0189,
    0x1aad2116, 0x28851682, 0x22852d82, 0x77fe7722, 0x3f843785, 0x0025168b, 0x00020000, 0x2097820d, 0x209787d3, 0x09db6200, 0x26010928, 0x36013f34,
    0x97821732, 0x8908f062, 0x53022114, 0x6e859383, 0x61828920, 0x01216b84, 0x829782d2, 0x211690aa, 0xc2854d02, 0xbc82ca83, 0x90858920, 0x04822984,
    0x89213b85, 0x83168801, 0x004d2697, 0x0433048d, 0x0c2f4153, 0x78630920, 0x0117220a, 0x052f4112, 0x0421148d, 0x41f59f33, 0xed200c0c, 0x0a20aa90,
    0x0121d782, 0x20169476, 0x20978500, 0x209782ad, 0x41978573, 0x2720052f, 0x24072a41, 0x32360109, 0x5e97821f, 0x3f2007ea, 0x17200f82, 0x97821485,
    0xdf41ee98, 0x0b1c4106, 0x41ad0221, 0x0a2211f3, 0x9883320a, 0x820f0a42, 0x00002a16, 0x002d0001, 0x0473024d, 0x20978233, 0x21958200, 0x79180109,
    0x02260f6e, 0x77fe0a73, 0x2d828901, 0x210c4e42, 0x6882ed03, 0x82122242, 0x000122eb, 0x2053820d, 0x41538853, 0x0442077c, 0x17ed4120, 0x4d265384,
    0x33040d01, 0xa7855303, 0x53820f20, 0xc0412720, 0x6d012125, 0x24179341, 0x014d0001, 0x2053822d, 0x41538573, 0x03212a7c, 0x1465412d, 0x022fa782,
    0x80ff0000, 0x00068007, 0x2f000f00, 0x18010000, 0x610ea547, 0x14210555, 0x08914f1e, 0x013e3424, 0x994f2135, 0x162a0808, 0x0d130007, 0x130dc0f9,
    0x40060d13, 0x5e80130d, 0x20e0fd42, 0xfe1a2620, 0x20261a00, 0x42e0fd20, 0x06425e5e, 0x025e4240, 0x1e820320, 0xfc0d1322, 0x03332a83, 0x42c0fb4d,
    0x3d51255e, 0x26261a0d, 0x503c0e1a, 0x66425e26, 0x0021078e, 0x056b4604, 0x0000052c, 0x001f000f, 0x0033002b, 0x6e890100, 0x14111526, 0x11012306,
    0x20054976, 0x21ab8635, 0x334a3301, 0x05332a08, 0x012b3432, 0x01331422, 0x847a83a0, 0xfb422555, 0x040d13a0, 0xfb207e84, 0x05257e82, 0x425ea060,
    0x2c8082f9, 0x107003a0, 0x1010a010, 0x425e0001, 0x820f8202, 0x21a982bb, 0xe0566003, 0xfc132b09, 0x38286053, 0x60602838, 0x96832020, 0x04830320,
    0xeb480420, 0x00172205, 0x09e74827, 0x35412520, 0x71b68914, 0x01210667, 0x060141a6, 0x41030d21, 0xfc20052c, 0x03207684, 0x66277682, 0x34262634,
    0x8203e026, 0x822382a0, 0x0313221d, 0x0ca867cd, 0x80850420, 0x00000528, 0x00170007, 0x1179001f, 0x277d8f0a, 0x012b3402, 0x013b1422, 0x330d114b,
    0xd0011632, 0x2f2f422f, 0x13ff0042, 0x0d00fe0d, 0x020d1313, 0xc02b0582, 0x1010a010, 0x4c3001a0, 0x5000fe34, 0x3422057d, 0x26835f4c, 0x02f02f22,
    0xfd208c84, 0x4d248c84, 0xfc202020, 0x04202084, 0x7f460583, 0x820b200b, 0x00002a8f, 0x10010e20, 0x3e20011e, 0x059c5c01, 0x08e8a318, 0xa0189420,
    0x04211bf7, 0xb47618a0, 0x18bd200a, 0x20102040, 0x27f38302, 0x80058006, 0x43002100, 0x220cad5a, 0x503b023e, 0xea8206c1, 0x011d0624, 0x0f831614,
    0x950a7a70, 0x00033a20, 0x80fe5070, 0x8a517050, 0x1a4068bd, 0x401a2626, 0x2838966a, 0x037050e0, 0x21189680, 0x2f834002, 0x02507031, 0x8abd68c0,
    0x801a2651, 0x6a96261a, 0x85382820, 0x8317922e, 0x21b791b2, 0x8c50020e, 0x3d36210a, 0x6a05ce4c, 0xb782087c, 0x0321209d, 0x22b19000, 0x82015070,
    0x800321c8, 0x04231896, 0x8f40fdc0, 0x213083b1, 0x17965070, 0x00820020, 0x4000082e, 0xc00640ff, 0x09000006, 0x19001100, 0x26060b6a, 0x0047003b,
    0x5b142400, 0x36210508, 0x07557032, 0x84085d70, 0x36342319, 0x198f1632, 0x3536218d, 0x32333634, 0x4b0e0216, 0x4b4c3435, 0x4b3d026a, 0x6a4b4b6a,
    0x06848bfd, 0x4cfd0424, 0x0e823534, 0x3cfc4b29, 0x5e5e845e, 0x84f00484, 0xcbfd3316, 0x7070a070, 0x848202a0, 0x83835d5c, 0xc3845c5d, 0x28834b6a,
    0x83e7fe21, 0x024b213b, 0x2105485f, 0x50838efd, 0x034b4b23, 0x223a83f1, 0x85a3fd5e, 0x8390201c, 0xfe70223a, 0x20398572, 0x21de8284, 0xcb490100,
    0x820b2008, 0x1944180e, 0x1806200a, 0x680f9544, 0xe96806db, 0x08a76806, 0x0500072d, 0x002c00c0, 0x03140100, 0x4107020e, 0x35260611, 0x2e343536,
    0x7f652b05, 0x1547080d, 0x13203311, 0x7f000716, 0x070c0f03, 0x110f100c, 0x3e230505, 0x9b997162, 0x3426e062, 0x1300fe13, 0x13000213, 0x02e02634,
    0x0135a2c9, 0xe3fea6a0, 0x091a2207, 0x090f1411, 0x37440623, 0x5575a065, 0xff0c1f36, 0x84261a00, 0x26048326, 0x00ff1a26, 0x56866dfe, 0x062b054b,
    0x00000580, 0x0017000b, 0x82580031, 0x0e142bc9, 0x012e2201, 0x32013e34, 0x0b8a0416, 0x26341728, 0x06072223, 0x06822722, 0x14150633, 0x013b031e,
    0x13033e32, 0x040e0714, 0x042e2223, 0x07195b27, 0x17163222, 0x2b065657, 0x07141516, 0x19800216, 0x193d543d, 0x02210483, 0x080a8899, 0x768ab93d,
    0xac479a29, 0x762b9847, 0x9262408a, 0x52a85286, 0x40629286, 0x87263de0, 0x5c96c193, 0x8aa7804e, 0x3e216a88, 0x6c331b88, 0xa2936ba4, 0xa4698494,
    0x881b336b, 0x54506801, 0x8d544444, 0x7c330804, 0x0b15a878, 0x78a8150b, 0x2d4b8358, 0x4b2d0e0e, 0xcf080183, 0x3c704d7c, 0x13060923, 0x41643e29,
    0x9fedd07b, 0x66745852, 0x2023544f, 0x74664e52, 0x43a05157, 0x17250d57, 0x00002c00, 0x05754525, 0x013d2622, 0x2005576f, 0x06174615, 0x290f0968,
    0x3221011d, 0x38000616, 0xb218fd28, 0x04250a1c, 0x803828c0, 0x40691884, 0x02e0210e, 0x38211582, 0x20268428, 0x210583fc, 0x6918e802, 0x03200f51,
    0x073f8883, 0x00800575, 0x00270011, 0x01000045, 0x22212334, 0x06010706, 0x21331415, 0x01373632, 0x6e212536, 0x988a05dc, 0x013e0128, 0x01071405,
    0x174c010e, 0x3d97840b, 0x3233011d, 0x06161716, 0xc0fb35f5, 0xfe1a5b28, 0x043512da, 0x195c2840, 0xfb122601, 0xb483038b, 0xfe209284, 0x012e0582,
    0x05902c00, 0xd9fe2e39, 0xfb43922b, 0x69185cc0, 0x203a07f8, 0x36c0845c, 0x020f165a, 0x1f2b235d, 0x101895fe, 0x011f2c23, 0xa0b4166b, 0xca873828,
    0x3b01ab2e, 0x3ea34535, 0x3595fe3a, 0x035c8445, 0x20263b84, 0x31a05c84, 0xce83202e, 0x17430520, 0x00142808, 0x0024001c, 0x82400034, 0x010e2cd7,
    0x26272622, 0x16363736, 0x82011e17, 0x013e23d8, 0xd243011e, 0x14043407, 0x34262206, 0x10003236, 0x0e20022e, 0x021e1002, 0x18013e20, 0x0808b276,
    0x04202420, 0xca256e04, 0x0825cafe, 0x2f191a18, 0xa8871908, 0x30081987, 0x0afe1832, 0x4b4b6a4b, 0x0382026a, 0x01290282, 0xedab664b, 0xabedfcfe,
    0x27078266, 0xabed0401, 0x9ffecee6, 0x250b0446, 0x9479cd01, 0x40827994, 0x50294682, 0x1a506363, 0x012f1018, 0x854183cf, 0xfd4b2240, 0x833683fe,
    0x2146863e, 0x44464002, 0x23db950f, 0x26010e16, 0x8207ef5f, 0x3e372207, 0x09be4401, 0x0823dba2, 0x86303218, 0x192f24d5, 0x8308181a, 0x37fe21eb,
    0x3325dbad, 0x18102f19, 0x23d6851a, 0x192f0808, 0x0221ea82, 0x29dbb709, 0x0013000b, 0x002b001b, 0x87680037, 0x33362208, 0x08ab4521, 0x802dd2a1,
    0x80fd1a26, 0x1a26261a, 0xfe1a8002, 0x5cc9ad26, 0x01210514, 0x20bcacb5, 0x24a98204, 0x04800700, 0x06654600, 0x21514320, 0x07cf6525, 0x2c075052,
    0x23001024, 0x06232722, 0x10002223, 0x2cf18200, 0x0e124003, 0x800e12c0, 0x0ec0120e, 0x210a8a12, 0xd3844002, 0x38420120, 0x4b013405, 0xc0d4d4fe,
    0xc092dc92, 0x01d4fed4, 0x8003d42c, 0x90c001d4, 0x82122033, 0x84672049, 0x840120d4, 0xd44b2d3c, 0xd4fe58fe, 0x2c018080, 0x2c01a801, 0x0f20bf82,
    0x8024c386, 0x17000b00, 0x2f36c782, 0x47003b00, 0x5f005300, 0x77006b00, 0x8f008300, 0xa3009f00, 0xd982b300, 0x2b14152b, 0x013d2201, 0x32013b34,
    0x200b8a37, 0x240b8a27, 0x23141501, 0x82238321, 0x992520c5, 0x8e478823, 0x8217883b, 0x200b9447, 0x21538a05, 0x8f881105, 0x93833520, 0x21111323,
    0x0f1d5011, 0x10800124, 0x02821060, 0xe0108023, 0x86028210, 0x00042a0d, 0x10a0fc10, 0x10600310, 0x841f88fd, 0x8c2e8926, 0x2116870e, 0x4d8500fe,
    0x07890120, 0x70205682, 0x802d1482, 0x000780f9, 0x80f9354b, 0x354b4b35, 0x21058206, 0x41847001, 0x058af020, 0x0c8bfd20, 0xfe200b85, 0x0c86128b,
    0x01200686, 0x70851a85, 0x82fe1021, 0x106029ae, 0x00fd10f0, 0x80fc8003, 0x68830383, 0x68820320, 0x524b4b20, 0x053b7205, 0x1600802a, 0x56002a00,
    0x11010000, 0x2e050e64, 0x11072223, 0x1e323336, 0x16011f02, 0x5c013233, 0x34290e36, 0x05163236, 0x06071411, 0x262d8207, 0x022e012f, 0x83042223,
    0x26272b0a, 0x37341135, 0x3233033e, 0x36821716, 0x36377408, 0x16173637, 0x89a98006, 0xa8643f52, 0xf5e6ad5e, 0x636137bc, 0x2c1c3737, 0x6dfb7839,
    0x0e121d23, 0x1d120e40, 0x4b6a4b23, 0x0a23c005, 0x5897da07, 0x46401c46, 0xfe663a70, 0x120f5ff5, 0x1f201010, 0xa48d5723, 0x70c27049, 0xbc7a3326,
    0x1f1f0916, 0x02eb011f, 0x31205b68, 0xa9fd7f37, 0x19250f71, 0x03160e1b, 0x113a2371, 0x120e0efb, 0xf2040e12, 0x82233a11, 0x752708df, 0x122705fd,
    0x23740405, 0x1c1e210e, 0x08093a58, 0xe6022513, 0x2b151423, 0x373e263d, 0x050c7013, 0x00141210, 0x87000600, 0x000522fb, 0x2dfd820b, 0x00460032,
    0x01000072, 0x15070635, 0x05841336, 0x27290b82, 0x2e272635, 0x07222309, 0x24d48415, 0x33161517, 0x241c8232, 0x15272223, 0x3c164116, 0x40032c08,
    0xb3cdcbb5, 0x03d7d4ac, 0x1495ebe9, 0x0d380513, 0x1a2e1332, 0x162c232c, 0x66131a17, 0x14136bb5, 0xad78312a, 0x212d89a9, 0x41acfb94, 0x3008342b,
    0x10c01802, 0x0160b965, 0x7608c5b0, 0x38fe6fbd, 0xe02d74b8, 0x1c030906, 0x13071806, 0x04040b06, 0x353ade03, 0x11bc0609, 0x5bbd0702, 0x012ac408,
    0x354841ee, 0x0d00022e, 0x80060000, 0x14003304, 0x00002400, 0x1136b818, 0x14160122, 0x2107404f, 0x995d013d, 0x49022105, 0x25133e52, 0x122d040a,
    0xb518fc0e, 0x02210811, 0x13345229, 0xfe1a0a23, 0x7722842d, 0x002a0579, 0x2d000300, 0x530793ff, 0x7f84ed04, 0x00003924, 0x0a700725, 0x821f2009,
    0x0907217c, 0x092f0482, 0x2f010e01, 0x37012e01, 0x1f013e01, 0x94011e01, 0x690221a6, 0x2d138453, 0xfe45020a, 0x0c17048b, 0x040d0d3e, 0x08857501,
    0x948d0221, 0x328922c0, 0x1396530a, 0xfa210423, 0x253c82f5, 0x0d170411, 0x08850b05, 0x9568fd21, 0x540020dc, 0x072b05db, 0x00bb0500, 0x003b0015,
    0x18150100, 0x2f079e46, 0x36013734, 0x011d1617, 0x17140601, 0x030e1401, 0x25057143, 0x2e271237, 0x248e2701, 0x6a821520, 0x80021627, 0x1b0c0d27,
    0x056e4b12, 0x27291d38, 0x131373fe, 0x2b220d06, 0x08061c35, 0x19030614, 0x40952b02, 0x238da1d5, 0xbc9b0129, 0x46c601a9, 0x4b05112a, 0x1f3c077b,
    0x452a1111, 0x341372fe, 0x3a4dfe13, 0x387d7d97, 0x0801110c, 0xa590011a, 0xfb0d4f47, 0xfe25278e, 0xadc11cfa, 0x2c008200, 0xff020002, 0x057e06ad,
    0x000a00e0, 0x2dc38228, 0x012f012d, 0x05171103, 0x01092703, 0xc1181613, 0x2b080958, 0x26011337, 0x13253736, 0x17323336, 0x011e0513, 0x0101a204,
    0x1e429cfe, 0x3e013b9f, 0xf5010c3c, 0x055695fe, 0x17111716, 0x3ffe3ffe, 0x41080682, 0xfe560516, 0x2d122094, 0x14e1f601, 0xe1151c1d, 0x122df601,
    0x34fa4302, 0x42013c0a, 0xa81f3dfc, 0x01426301, 0xfe9efe35, 0x0c25210c, 0x250cecec, 0x01f40121, 0x07372062, 0x29c70149, 0x4939fe29, 0x9b823707,
    0x9b820120, 0x80058029, 0x16000005, 0x6a090000, 0x35280675, 0x2e222111, 0x01373601, 0x35088983, 0x7905011e, 0x281180fd, 0x1b160a05, 0x2316c0fd,
    0x0514120a, 0x1b100d00, 0x04070f12, 0x2300fba3, 0x16230502, 0x2c1b4002, 0x80020a28, 0x290e1307, 0x00030000, 0x7f57ff00, 0x00022405, 0x82380005,
    0x112124f1, 0x5c210109, 0x5c5f0501, 0x61212008, 0xa65f064b, 0x34353005, 0x32013b36, 0x21011d16, 0x17323637, 0x620f1416, 0x2d2405f4, 0x80fd5302,
    0xad220382, 0xe8588004, 0xa0fc2107, 0x2b0ccf59, 0x0af65303, 0x09090a1a, 0x120ee0f7, 0x5322cc82, 0x2e82dafd, 0xdd586020, 0x6003210a, 0x220a025a,
    0x820909f7, 0xfcf6232d, 0xfb8212ad, 0x63680420, 0x00072608, 0x0017000f, 0x09c5514b, 0x26341227, 0x16140622, 0x07634832, 0x0614372c, 0x06070207,
    0x1d010e07, 0xc8831e01, 0x3425bc82, 0x2e113736, 0x21b88201, 0xd4821632, 0x36110726, 0x35053e37, 0x01241086, 0x38503820, 0x02210287, 0x2f0984b8,
    0x022c3498, 0x808843e0, 0x70342c53, 0x2c3470a0, 0x36270686, 0x4c413764, 0x8411272a, 0x8418200e, 0xb8042135, 0x48200684, 0x60330584, 0xfe195934,
    0x2b267fe1, 0x1a453e28, 0x50345919, 0x82507070, 0x34032112, 0xfe290b89, 0x111f1a0f, 0x3c2a2519, 0x2214864f, 0x83080000, 0x80063adb, 0x0d000006,
    0x25001900, 0x5c004000, 0x74006800, 0x00008200, 0x22060109, 0x06597027, 0x17141625, 0x52061411, 0x3222059d, 0x76632616, 0x36342505, 0x05322133,
    0x2108a370, 0xf2823727, 0x36013f2f, 0x01273435, 0x01171637, 0x01070116, 0x05497926, 0x01171429, 0x01272607, 0x82343526, 0x3233211f, 0x04201b82,
    0x0120428a, 0x05205a8a, 0x0132748c, 0x0b00ffb7, 0x09090b18, 0x1a0a0001, 0x12a0090a, 0x0282121c, 0x0b7be020, 0x0525080a, 0x53935502, 0xfe537978,
    0xef1515b2, 0x521b1101, 0x1c1c931b, 0x2312eefe, 0x54500115, 0xfeef97fd, 0x27281cef, 0x2113821d, 0x13821201, 0x54b0fe22, 0x01242e85, 0x8e02154e,
    0xfd21468a, 0x215a85f2, 0x708c9701, 0xff090125, 0x82090900, 0x8401207a, 0xfe332106, 0x2009ee7b, 0x088a84e0, 0x5378a022, 0x01555392, 0x1223154f,
    0x011beefe, 0x271c921b, 0x13011c28, 0xfe1515ef, 0x5e0256b0, 0x1c120112, 0xfe231385, 0x8215f0ee, 0x76562192, 0xfe233084, 0x846915b1, 0x0002213f,
    0xa520528a, 0x00306c8c, 0x60000200, 0xfc030000, 0x0f000005, 0x00003c00, 0x250f195f, 0x030e1401, 0x158b0e07, 0x013e3723, 0x05c04f35, 0x2d066248,
    0x21123701, 0x02021e32, 0xf01018c0, 0x04841810, 0x1f3c0128, 0x272c4727, 0x0d823729, 0x82150f3c, 0x5d323b4e, 0x232b413d, 0x0c120d48, 0x050da40d,
    0x3001a008, 0x5282a250, 0x30871801, 0x02182708, 0x3b5e3648, 0x17161b3c, 0x1f111954, 0x532d1325, 0x3a1b2393, 0x1d402a2f, 0x08105a19, 0x0d1e0a7d,
    0x683e0a01, 0xaf830097, 0x04820020, 0x80058026, 0x2e001e00, 0x0df94218, 0x11013b25, 0x46262223, 0x152507c8, 0x16323311, 0x08815503, 0x33363431,
    0x02163221, 0xfe1a2680, 0x26261a00, 0x8340401a, 0x80012305, 0x0882261a, 0xff201582, 0x01201584, 0x42180582, 0x012008f6, 0x1f821682, 0xfd1a2627,
    0x660426c0, 0x7a2f83c0, 0x022205f8, 0x83826200, 0x83821e20, 0x1f000f24, 0x42470000, 0x0313210f, 0x22054f4f, 0x85260327, 0x26002274, 0x235e891a,
    0x27011c1e, 0x272c0e83, 0x25011c01, 0x1a40011a, 0xe0200125, 0x04835b83, 0x18060421, 0x2e094490, 0x00020026, 0x05000005, 0x006b05fe, 0x834a0025,
    0x2f2335eb, 0x23272601, 0x0607020e, 0x3521010f, 0x23031333, 0x16172135, 0x33310182, 0x21023f36, 0x13032315, 0x27211501, 0x3e343526, 0x07a34104,
    0x37362725, 0x73323336, 0x333b05a9, 0xf8810335, 0x0308189f, 0x04030103, 0x9b0f0a01, 0xc580fefe, 0x140189b9, 0x8215028b, 0x03690814, 0x018c1908,
    0xccb87d01, 0xfefdea02, 0x4e340403, 0x3b344e5a, 0x0e2e3329, 0x251a6916, 0x886e6953, 0x4c584b31, 0xa7e80337, 0x092afca7, 0x0907030c, 0xfa181402,
    0x012301a7, 0x04e4a810, 0x090c0926, 0xa8e42a0c, 0xd8fef5fe, 0x1bcea702, 0x6a40121c, 0x3e2e3f43, 0x27312621, 0x255c1b0b, 0x6377411d, 0x3a3b5e38,
    0x50213c2b, 0x28008200, 0xff050002, 0x03000600, 0x20db8282, 0x20dba549, 0x21db9905, 0xdba80703, 0xfefdec24, 0xdb8d0304, 0x6e6c5028, 0x64634588,
    0xdaa1044a, 0x1bced924, 0xd991012d, 0x43694225, 0x8327443a, 0x00022cd8, 0x07000001, 0x0000057f, 0x82170003, 0x21012ad7, 0x06160109, 0x23060107,
    0x05b65021, 0x3336013b, 0x03163221, 0xfd500180, 0x06b0fe00, 0x190b0ff5, 0x3a2680fc, 0x3f2600fd, 0x200b8210, 0x200b8203, 0x2e0b8203, 0xfe800180,
    0x22350480, 0x00fc1c4b, 0x8222292c, 0x82042007, 0x83002007, 0xdcff3a5d, 0x00068006, 0x00006800, 0x23061401, 0x23022e22, 0x16141522, 0x07221507,
    0x220a820e, 0x7d343526, 0x1e210958, 0x067e4802, 0x2f012e2a, 0x22272201, 0x021e1135, 0x2505ff4b, 0x022e3435, 0x1a423435, 0x2b258206, 0x36323316,
    0x020e1537, 0x14150607, 0x37082183, 0x3233023e, 0x59800616, 0x2d49294f, 0x206e2544, 0x220b1601, 0x3d2e687f, 0x23292354, 0x7654516c, 0x2e1e251e,
    0x965f5025, 0x0d092509, 0x02020201, 0x9603251f, 0x2e25505f, 0x76231782, 0x826c5055, 0x3d543625, 0x012fe840, 0x18010505, 0x162d2c23, 0x2b503139,
    0xb6015b52, 0x081a8351, 0x98277c24, 0x03010527, 0x39350a11, 0x492d4425, 0x5b594f29, 0x31502b52, 0x2c2d1639, 0x04021823, 0x01010202, 0x3a8e0004,
    0x39228986, 0x6d8e1e35, 0x97490020, 0x80043005, 0x27000006, 0x00003300, 0x00141501, 0x18211507, 0x2d0bcacc, 0x3d002635, 0x32363401, 0x14011d16,
    0x0b862000, 0x14110138, 0x35262006, 0x20363411, 0xfe800416, 0x0001d9d9, 0x1a26261a, 0x058380fd, 0xd900012d, 0x3426d9fe, 0x01070126, 0x82070172,
    0x00ff3108, 0xbcf8febc, 0xbc0801bc, 0xdd804003, 0x8418b9fe, 0x24055f69, 0x47011884, 0x263284dd, 0xf9feb980, 0x83b90701, 0x6601280b, 0xbc8400fe,
    0x830284bc, 0x03003405, 0x80ff0d00, 0x00067305, 0x43000b00, 0x00004b00, 0x88260701, 0x0109218e, 0x2305456f, 0x32331607, 0xc090a48a, 0x06072725,
    0x47012f22, 0x1f25052a, 0x25141601, 0x26b88201, 0x01163233, 0x822a650f, 0x69042b89, 0x84bc97fe, 0x61603637, 0xaf84b96c, 0x7d2acf90, 0x1a0afe6e,
    0x0a0a520a, 0x0784d204, 0xfd7afe2c, 0x6684bc93, 0x654f02a5, 0xc0856f67, 0x1e02352a, 0x848097fe, 0x336013bc, 0x1a20c886, 0x0d23ea8c, 0x820afe44,
    0x831a2041, 0x82078342, 0x21e18341, 0x83410076, 0x00053506, 0x06008005, 0x00002200, 0x11211101, 0x13363736, 0x050e1411, 0x2723b882, 0x8335062e,
    0x32213bae, 0xfe400416, 0xeb5e7740, 0x896343c0, 0x10357e74, 0x100c1c0c, 0x89747e35, 0xf0624363, 0x02240805, 0xfb800240, 0xb84a3f8f, 0x00fdb003,
    0x7c83a956, 0x071a4952, 0x1a070606, 0x837c5249, 0x000356a9, 0x0026261a, 0x32062f49, 0x06800600, 0x00030000, 0x00230013, 0x17000047, 0x61211121,
    0x14250907, 0x32013b16, 0x480f9136, 0x8d830513, 0x49013b21, 0x098809e8, 0x16323329, 0xfa800580, 0x6a800180, 0x03200904, 0x200a046a, 0x2c841801,
    0x00042a19, 0x0e2001c0, 0xfe0e1212, 0x8a0583e0, 0xfb4e260b, 0x4c4c3400, 0x03841834, 0x00022313, 0x7082ff03, 0x00e00525, 0x824c0007, 0x06eb49d7,
    0x4c112521, 0x2528055b, 0x2135012e, 0x15011e15, 0x230a4566, 0x22233537, 0x2506634c, 0x3e37012e, 0xe87a3704, 0x15220805, 0x34210714, 0x36253736,
    0x16173233, 0x34260002, 0x03342626, 0x0c080ca6, 0x40fe0304, 0x00ff0e0b, 0xfc46916f, 0x7d220805, 0x703b2063, 0x04143d47, 0x0d102811, 0x050c1117,
    0x69413813, 0x845e1938, 0x2e010e5e, 0xc0010b0e, 0x35820403, 0x40840520, 0x60264208, 0x0910c0fe, 0x02600107, 0x17660b12, 0xe0fc73b0, 0x1a26261a,
    0xa96a2003, 0x3b2f6f1e, 0x2308214a, 0x18320c07, 0x414b200a, 0x2c2a1245, 0x425e5e42, 0x120b1f21, 0x07016002, 0x02000009, 0x20ff2400, 0x82dd8206,
    0x892d20db, 0x140132db, 0x07060702, 0x05070603, 0x2f222306, 0x13372601, 0x83098801, 0x373908bf, 0x32212436, 0x38a00516, 0x50383850, 0xb2971801,
    0x02147251, 0x0780fe0e, 0x400b0c09, 0xfe55050d, 0x03ecfee7, 0x40090e06, 0x0ae00c11, 0x607b0110, 0x5401bc50, 0x140e0501, 0x05b14a04, 0x80012508,
    0xb395fef9, 0x85fe6050, 0x04e00a10, 0x120e4009, 0x19011401, 0x40090155, 0x80011413, 0x7214020e, 0x138ebb51, 0x01208f82, 0x00220382, 0x6f4cd106,
    0x03012705, 0x27361321, 0x07832b26, 0x0b822120, 0x83820320, 0x011e1733, 0xfea4d106, 0x1c0db2b2, 0xcca9381b, 0xfeccb2fe, 0x340583e2, 0x65fc0499,
    0x2a3c3bb1, 0x05fdfb02, 0x20384003, 0x0347fc21, 0x250383b9, 0x49514701, 0x5683bf49, 0xbb560220, 0x00202b0a, 0x36372500, 0x01092734, 0xef823436,
    0x01072229, 0x01171406, 0x59003216, 0x03380aea, 0x1313668d, 0x3301cdfe, 0x13661313, 0x3afe1334, 0xc6011313, 0x86023413, 0x820e7b56, 0x13342326,
    0x27823301, 0x28823420, 0x2c842783, 0x56d70221, 0x7f8f0e60, 0x27247a82, 0x0f222601, 0x09207a83, 0x1f200482, 0x02217f8e, 0x856e82cd, 0x2388824e,
    0xcdfe3301, 0x03218884, 0x827f8f46, 0x20808226, 0x821d84c6, 0x832782b0, 0x207f9f88, 0x82ff8301, 0x83fa837f, 0x0937217a, 0x04207f8e, 0x3a20ff84,
    0x6620fa86, 0xe4850782, 0x00410120, 0x4101200f, 0x80820501, 0x2d83fe20, 0x0120ac87, 0x180f0041, 0x250c2f60, 0x00200014, 0x7e412500, 0x41092007,
    0x838e0708, 0x822d0321, 0x057e41dc, 0xd786cd20, 0x58058441, 0xed200f00, 0x7e412782, 0x0bb04105, 0x41770221, 0x58081283, 0x05800540, 0x00110080,
    0x01000016, 0x21132137, 0x012f010f, 0x33051323, 0x21132535, 0x03210127, 0x6a042505, 0x2f8cfc10, 0xc5166402, 0x16af0dc4, 0x01046a01, 0x7cfd3267,
    0x0538fe0f, 0xbefd8080, 0xab03c2fd, 0xe4eafdaf, 0xfe8c3535, 0x630164ea, 0x01b52002, 0xa262fad5, 0x34df82a2, 0xff0c0001, 0x05f40640, 0x000f0080,
    0x09210100, 0x07211302, 0x08578205, 0x37211330, 0x05130121, 0xfcf6fee1, 0x4746fddc, 0x011d2901, 0x44e601a6, 0x043a48fb, 0x48fb26b9, 0xcbfa8005,
    0x0b01f5fe, 0xa1936401, 0x015301a1, 0x2b41bf29, 0x07102806, 0x00000600, 0x43550007, 0x87440aab, 0x012f2605, 0x24200406, 0x08495427, 0x2133362a,
    0x0f161732, 0x17011e01, 0x2107734b, 0x6f4e013b, 0x14153107, 0x33150706, 0x011d1632, 0x012b0614, 0x37013e11, 0x07ac5618, 0xc0032808, 0x26263426,
    0x14660334, 0x0b0c0408, 0x71fe775d, 0x71fe34fe, 0x0e095d77, 0x12140804, 0x1660010e, 0x640f0808, 0x4b95f543, 0x3a26056c, 0x96d49646, 0x0c853a46,
    0x43f5952d, 0x08080f64, 0x0e600116, 0x83e60412, 0xfc263046, 0x16a0fea0, 0x5d090208, 0x8fa7a78f, 0x8502095d, 0x1314391c, 0x7d5b6410, 0x26870214,
    0x261a801a, 0x467522a3, 0x6a96966a, 0xa3227546, 0xfd2b1084, 0x5b7d1479, 0x14131064, 0x82010012, 0x040022e7, 0x21f38280, 0x81180023, 0x085b07ff,
    0x013b2607, 0x20003411, 0x06215000, 0x2634352e, 0x11150622, 0x38282004, 0x40fc2838, 0x20200583, 0x23061948, 0x261a401a, 0x125ba682, 0x82022009,
    0x40012b1e, 0xfe0701b9, 0x261ab9f9, 0x7d831a26, 0x83c0fe21, 0x1805206a, 0x220e2b75, 0x18330027, 0x18098f6a, 0x2107eb81, 0x76821000, 0xc25a0384,
    0x82002017, 0xd496236e, 0xfb741601, 0x61012d06, 0x58fed4fe, 0x2c01d4fe, 0xac01a801, 0x231eba5a, 0x96d4ea02, 0xfe243e82, 0xe13e0161, 0x02213f83,
    0x223a8854, 0x5a7efd2c, 0x002b20b5, 0x00000300, 0x80050002, 0x71008003, 0x314e0503, 0x0fe16f10, 0x01260f8f, 0xc0283880, 0x04843828, 0x95000221,
    0x2003210b, 0x1f892187, 0x0020098a, 0x87820082, 0x01000022, 0x09d74b18, 0x11208790, 0x5108dc51, 0x0f8f05cd, 0x878a0120, 0x01206593, 0x01218389,
    0x8a8e88d8, 0x0000220a, 0x0acf4104, 0x35001b26, 0x00004500, 0x2c07e77f, 0x27002625, 0x011d0626, 0x1e171614, 0x2c028201, 0x3632013b, 0x2e022625,
    0x26272401, 0x22178507, 0x85120416, 0xa1711818, 0x6c022011, 0x25080532, 0xfe0daa01, 0x140ee9b9, 0xdc9a0d11, 0x0d12010b, 0x01140d80, 0xb166057f,
    0x9ae1fee9, 0x120a090e, 0x5c01cc0d, 0x188407d1, 0x010b0a23, 0x6f47181f, 0x6acb2c0b, 0x4b6a4b4b, 0x4701e922, 0x8214010d, 0x01123238, 0x0d9adc0b,
    0x9a0d1411, 0xb1e91f01, 0x0a010566, 0x2a15840a, 0xa4fed107, 0x0a120dcc, 0x69cd0309, 0x002a0f2f, 0x000680ff, 0x0b008005, 0x63181b00, 0x36230e01,
    0x82012734, 0x111527c5, 0x33161714, 0x61183732, 0xb22e1025, 0xe0fd2020, 0x2020211f, 0x0f111010, 0x41468005, 0x97fd3a0e, 0x01124a12, 0x13121340,
    0x2580fd25, 0x00090813, 0xff360003, 0x05cb0635, 0x260982ca, 0x002f0013, 0x84050900, 0x08284762, 0x0601092a, 0x36012f22, 0x07222634, 0x08062c52,
    0x06011f35, 0x37321614, 0x04141617, 0xfd3c0100, 0x01c4fec4, 0x136a0269, 0x1296fe13, 0x96fd1236, 0x6a011313, 0x8b033612, 0x6b2575fc, 0x70387e25,
    0x257d38a0, 0x828b0325, 0x837d200c, 0x257e2a0c, 0xc4fe3c04, 0x3c01c4fd, 0x203583fe, 0x832d8334, 0x83342035, 0x8f02243f, 0x822574fc, 0x70a02334,
    0x30827e38, 0x258a0325, 0x82387d25, 0x257d220c, 0x0c53466b, 0x1805fb4f, 0x490f2f4e, 0x332e0aa7, 0x05163221, 0xfc1a2600, 0x26261a80, 0x0582031a,
    0x78180120, 0x02210c0d, 0x83188440, 0x0dad6a04, 0x67820320, 0x42050021, 0x7a180edb, 0x55820805, 0x1f59c218, 0x12800430, 0x0ec0fc0e, 0x030e1212,
    0x80120e40, 0xd065425e, 0x18802009, 0x210bf774, 0xaf57e002, 0x32fe2508, 0x5e424003, 0x03222986, 0x7518fc82, 0x00220a02, 0x91820001, 0x05fa032b,
    0x001c007f, 0x2b060100, 0x29e48501, 0x013f2627, 0x11213336, 0x77182223, 0x230808fe, 0x2812fa03, 0xfd0e12c0, 0x08081540, 0x1009a00c, 0x28c04001,
    0x011a1112, 0x123e1240, 0x031b4001, 0xa0fc25a5, 0x142f9682, 0x020bc00f, 0x1f252580, 0x16168001, 0x822080fe, 0x216382ef, 0x638280ff, 0x1b000025,
    0x82130000, 0x111533e3, 0x07163233, 0x27220601, 0x36372601, 0x2111013b, 0x09832f22, 0xc002202a, 0x28c0130d, 0xc0fe1b24, 0xfe235482, 0x82111ac0,
    0xc0fe3072, 0x0da00b0e, 0x00050909, 0xa1fc0e13, 0x82fe204a, 0x80012c57, 0x0225261f, 0x0ec00b80, 0x4e001314, 0x06270523, 0x00800500, 0x48240014,
    0x01200a0b, 0x08686618, 0x5c321621, 0x02230f6a, 0x486602ad, 0x2d2406e7, 0x133413d3, 0x01250c82, 0x03341366, 0x0b694366, 0x2382ed20, 0xfe201a84,
    0x3c482382, 0x139a2305, 0x4d438603, 0x09f7450b, 0x10000632, 0x1f001500, 0x00002f00, 0x23071701, 0x01352335, 0x2729e383, 0x36013726, 0x01110309,
    0x05204a37, 0x23670f20, 0x94250811, 0x60383498, 0x110ed201, 0x0d11ddfe, 0x2301110e, 0x02fbfe11, 0xfde0fe20, 0x5c8003e0, 0x1c981c1c, 0x025c1c50,
    0x28988ba0, 0x3498ac01, 0xba013860, 0x2132830d, 0x32830d0e, 0x0240fd2c, 0xfd200120, 0x02e0fee0, 0x31825c60, 0x1c1c9823, 0x5c56185c, 0x09374a0e,
    0x29001922, 0xcb62a582, 0x06073005, 0x0601011f, 0x16011f14, 0x17013732, 0x44323316, 0x052c11b3, 0xfe1a2600, 0x11112a20, 0xeafd901f, 0x27053541,
    0x12901602, 0x270d0c1b, 0x270ef642, 0x1ae00160, 0x1d292726, 0x34242783, 0x13136613, 0x13242782, 0x2a021105, 0x890b3341, 0x00252587, 0x09000035,
    0x2605bf4a, 0x011d0607, 0x50050e22, 0x372705a2, 0x37022736, 0x8533013e, 0x0fbc410d, 0xed032308, 0x13136001, 0x271ea0fe, 0x83c27728, 0x0a213861,
    0x070e0ba7, 0x2c031606, 0x8ca82e6a, 0x1a0c0c28, 0x2e412602, 0x82b3200c, 0x3420082f, 0x1f600113, 0xa02a1111, 0x605f3f27, 0xb53c657a, 0x09030cdf,
    0x77620118, 0x2aa02f34, 0xc0020511, 0x450c2445, 0x023109ff, 0x12000600, 0x00001e00, 0x01012d01, 0x00110111, 0x5fcc1810, 0x80022b15, 0x00ff0001,
    0x00fe8001, 0x62682003, 0x7201210a, 0x310e2345, 0x8080c001, 0xe2fd4f01, 0x1e0200ff, 0x2801ddfe, 0x2d8692fa, 0x4a5f0221, 0x03200e63, 0x24088346,
    0x001d000d, 0x4381822d, 0x33220934, 0x29443221, 0x0f25410f, 0x12790436, 0x13c0fe17, 0xc0fe1342, 0x28111217, 0x98288002, 0x40fc0d13, 0x21056f73,
    0xb941130d, 0x5d032e0d, 0x40fe1f23, 0xc0011b1b, 0xfd23231f, 0x0c146a20, 0x910b1841, 0x23062293, 0x09244421, 0x112993a1, 0x2880fd28, 0x01171211,
    0x23998240, 0x75174001, 0x012e9399, 0x232323a3, 0x1bc0011f, 0x1f40fe1b, 0x93a9dafe, 0x07140024, 0xca180601, 0x93a00819, 0x5f834020, 0x6b836a82,
    0x5d12db21, 0x22410a0b, 0xa102210d, 0x820a4a41, 0xc0fe27c1, 0xc003ecfd, 0x3186120e, 0x18ce0321, 0x360de778, 0x03000000, 0x008005f3, 0x25000060,
    0x0f061617, 0x23070e01, 0x56270022, 0x3b2306c6, 0x88372601, 0x0036270a, 0x16173233, 0x23821617, 0x012f0128, 0x2223052e, 0x844b0706, 0x23062405,
    0x85170621, 0x0e2b080a, 0x1e212301, 0x3e323301, 0x36013f04, 0xd0031617, 0x0b0c0323, 0x130d0405, 0x22211b18, 0xfeea1327, 0x0d5f3fa2, 0x420d1313,
    0x83430302, 0x62610894, 0xe0610143, 0x090b5c66, 0x032b0306, 0x04040d16, 0x1b19140f, 0xc87e0e1f, 0x10d40132, 0x18030a09, 0x18fe1b05, 0xcb010303,
    0x03090a0f, 0x0b120218, 0xcb307dfe, 0x1f24127f, 0x0410151c, 0x0c0d0d05, 0x150c9fe5, 0x03020104, 0x05050506, 0x05010204, 0x710d13dd, 0x3039130d,
    0x0e720e12, 0x0001d212, 0x3e7f8217, 0x0d0d9f0d, 0x03010104, 0x02030304, 0x0c0c7080, 0x251a720e, 0x0f0c0c44, 0x750f0b70, 0x82040389, 0x02012838,
    0x00070705, 0x82000100, 0xfc032400, 0x18008005, 0x5b0a9182, 0x654c0592, 0x5c34200a, 0x0f2d0508, 0x06070601, 0x23022e27, 0x011d0622, 0x056d4c21,
    0x9b772320, 0x013b2f05, 0xfc031632, 0x44fc0e12, 0x0d13120e, 0xe9835f61, 0xf75f2508, 0x0996b9bf, 0x09670802, 0x050a0d0d, 0x552d602a, 0x0d310168,
    0xfe0d1313, 0x129e01cf, 0x120ea20e, 0x91fe8f01, 0x23082983, 0x01130d96, 0x830d137f, 0xabdf120e, 0x19087dde, 0x010b7f0a, 0x1c050902, 0xd74c5e24,
    0x0d830e12, 0xb585fe13, 0xaa823882, 0x34000130, 0xd20300ff, 0x62000006, 0x14010000, 0x724a0706, 0x042e3c08, 0x013f2627, 0x17363736, 0x17161730,
    0x36323316, 0x032e3435, 0x35082e27, 0x52373634, 0x1e23086b, 0x86161704, 0x820420c6, 0x141521c6, 0xae081082, 0xd203061e, 0x0e129fc7, 0x42130d87,
    0x1944507b, 0x670f1105, 0x090f1007, 0x25827102, 0x1e7b5125, 0x36345025, 0x2f4e2d27, 0x192e2942, 0x139dc411, 0x120e870d, 0x3c436b39, 0x0c110612,
    0x0e0f0851, 0x3717030d, 0x5f2a573e, 0x252a1178, 0x352f2e4b, 0x45376038, 0x5f011a25, 0xaf1add99, 0x0d13120e, 0x2d2c09af, 0x15061833, 0x020a8714,
    0x63020b02, 0x4f56081a, 0x2922321c, 0x12101517, 0x292c1b23, 0x294a3b39, 0xb41ed08a, 0x0e12130d, 0x212206b0, 0x1206102a, 0x010f9214, 0x12030a03,
    0x56171d23, 0x272c1a44, 0x1213231b, 0x262f1714, 0x4158413e, 0x822506b3, 0x3e008005, 0x06834b00, 0x07010e2e, 0x07160116, 0x22012b06, 0x26270027,
    0x2305c041, 0x21373632, 0x20079c59, 0x59198226, 0x1d2208a7, 0x29821401, 0x17162b08, 0x03163233, 0xa80e1282, 0xa7aad417, 0x0a0e2401, 0x10c31508,
    0xc0cefe09, 0x700d1309, 0xfe16a184, 0x12120e55, 0x399d010e, 0x9a8391d3, 0x83400321, 0xe920080e, 0x0eab112f, 0x662a0412, 0xb490120e, 0x9afeb214,
    0x0c121210, 0x09cc6f01, 0x130d7f0d, 0x0e125256, 0x71231882, 0x83850d13, 0x220a822b, 0x8212533d, 0x000430af, 0x05ff0300, 0x00450080, 0x22232100,
    0x88113526, 0x86352097, 0x013b2109, 0x30057248, 0x16131732, 0x37013e17, 0x013b3613, 0x07161732, 0x06d44e01, 0x15212322, 0x2e097042, 0x5b020614,
    0xfe130dac, 0x13130de0, 0x8520010d, 0xfed63a07, 0x0a0808bf, 0x0a13c212, 0x0a2513d7, 0x08bf0729, 0x0a11bf15, 0xc7fe0809, 0x232683d7, 0x2201defe,
    0x13200785, 0x3208d382, 0x670e124a, 0x1255130d, 0x130d680e, 0x10104202, 0x57fe1210, 0x58185726, 0x13a40111, 0xfd110e10, 0x680d13bd, 0x1355120e,
    0x120e670d, 0x130db6fe, 0x82000200, 0x00052100, 0x0722c382, 0x0a823800, 0x23263429, 0x32211121, 0x8b061000, 0x088c4299, 0x20084244, 0x55098835,
    0x0439058b, 0xfe6a8213, 0x6a4001c0, 0xc8fd6f01, 0xf901acfe, 0x0e12120e, 0x0d1307fe, 0x07d55ea7, 0xab78e020, 0x1b022e06, 0xc86703c8, 0x0140fe7c,
    0xf47efea1, 0x0fc86676, 0x95201082, 0x7524bb82, 0x0600120e, 0x23088f82, 0x05000700, 0x00080080, 0x0010000c, 0x001d0019, 0x0100006e, 0x16132313,
    0x36341714, 0x17213713, 0x23273321, 0x14211083, 0x4e108616, 0x03270523, 0x22012b06, 0x84230327, 0x82262007, 0x052f4208, 0x45013b21, 0x0329090f,
    0x3b363726, 0x13173201, 0x05934121, 0x16220787, 0x70500307, 0x82072008, 0x02023609, 0x014b9f51, 0x23740101, 0x0120dcfe, 0x46238ba1, 0xa24e9f01,
    0x32118251, 0xd7fe216f, 0x12800222, 0x07a4d50e, 0x07189f18, 0x82a7d1a6, 0x110b2407, 0x83d0a002, 0x21af22eb, 0x3e06838e, 0x0a05596d, 0x1a89100a,
    0x67015a05, 0x7e180761, 0x01620718, 0x1a055d6d, 0x0a0a1089, 0x836f5b05, 0x22913a22, 0x01120eb3, 0xfe2b0155, 0x010401d4, 0xac010501, 0xfd808080,
    0xfe2c01d4, 0x820c82d5, 0x80ad2c12, 0x0e402080, 0x1898fd12, 0x82680218, 0x0a0e2505, 0x0e126802, 0x59561182, 0x58012a05, 0x180c0d0f, 0x680198fe,
    0x24058518, 0xfe0f0d0c, 0x082086a8, 0x03000030, 0x00ff3800, 0x8005e804, 0x48003300, 0x00005c00, 0x1e071601, 0x040e0701, 0x35231507, 0x23152722,
    0x2b262211, 0x32333701, 0x26331137, 0x0b821123, 0x32173528, 0x15333537, 0x04823336, 0x03031e2e, 0x22042e34, 0x32112306, 0x063e3216, 0x0e210c83,
    0x080c8301, 0x04063ea6, 0x7595128f, 0x33070d74, 0x527f744e, 0x9a2a509a, 0xc8134812, 0x08326f1f, 0x0d0a0610, 0x40d46f4c, 0x28529a21, 0x687a4f9a,
    0x2c1ed13d, 0x32583c47, 0x3a08084f, 0x41314426, 0x131e312e, 0x3c241947, 0x412b4932, 0x223b0507, 0x263b2c42, 0x80031224, 0x961c4cb6, 0x466c478b,
    0xff04162f, 0x00fc01fb, 0x33b701ff, 0x01019201, 0x01a4441f, 0x02f7fc01, 0x1f07fcf5, 0x9dfd613b, 0x19243824, 0xfe02060c, 0x050301ae, 0x221a100c,
    0x21f8012e, 0x0a172133, 0xfe010106, 0x030101cd, 0x1f170e08, 0x0002002e, 0x0600ff00, 0x02820182, 0xf5821820, 0x1716112a, 0x05171601, 0x21331614,
    0x080c5a4d, 0x16000426, 0x0e98010e, 0x38a8fd0e, 0x38200228, 0x28c0fa28, 0x03283838, 0x01000420, 0xfe0e0ed8, 0x20160e68, 0xe0fb3828, 0x06251483,
    0x00382840, 0x24578c05, 0x00380028, 0x225d8248, 0x82211716, 0x8d032060, 0x1411235a, 0xd64d1316, 0xa65b180e, 0x210f8f0f, 0x7382bc05, 0x0e162823,
    0x298a8b44, 0x0e12c838, 0x120e40fd, 0x42180e12, 0x0b9109a0, 0x0e240423, 0x21b28316, 0xad89c4fd, 0xb782fd20, 0x4d20fd21, 0x0121089b, 0x080a930e,
    0x04000025, 0x00ff2200, 0x00067d06, 0x24000a00, 0x52004200, 0x33010000, 0x3526012f, 0x06140723, 0x07140107, 0x4d230601, 0x0551083e, 0x15230805,
    0x16323311, 0x35211505, 0x013f3601, 0x23062235, 0x15012b06, 0x15213523, 0x010f0601, 0x3b363715, 0x82133501, 0x2733241d, 0x83330723, 0x33133707,
    0xb1a70413, 0x04020c48, 0xfd040703, 0xc1fe0af0, 0x0b0c0d0a, 0xd418c0fe, 0x34080cee, 0xb8fd4403, 0x090c7101, 0x0309020b, 0x78e8120c, 0x8ffe3702,
    0x0e0b0f06, 0xd2f81509, 0x2f4be0fe, 0xfe4b2ff3, 0xa2e646e1, 0xda6804e6, 0x1404102f, 0xfb0c2201, 0x044a181e, 0x102f0807, 0x60051413, 0x0e12120e,
    0x8512a0fa, 0x11025ae9, 0x03090912, 0xe5730301, 0x08eefd59, 0x02020b12, 0x81037702, 0x90906a6a, 0x96026a6a, 0x82006afd, 0x20f78d00, 0x20f78334,
    0x20f78925, 0x20f79805, 0x20d98e01, 0x1c074103, 0x9d20f7a2, 0x1320dd8c, 0x88180541, 0x93e220f6, 0xfcfe21f5, 0x0421de89, 0x1002417f, 0x03030a3b,
    0x05007701, 0x00ff2200, 0x00060007, 0x29001900, 0x49003900, 0x00005900, 0x18ea9825, 0x610f5ba3, 0x0f9f0f08, 0x41e00221, 0x042115ea, 0x0b595020,
    0x0e12c029, 0x120e80fd, 0x82020e12, 0x210c8205, 0x0c8340fe, 0x0ec00123, 0x210c8212, 0x0c8400ff, 0x60200582, 0x8e20f593, 0x12212582, 0x2104830e,
    0x0a9ef201, 0x8705ee46, 0x890f20ff, 0x41e58fff, 0xa361190f, 0x0e186210, 0x0f8e1320, 0xc08c0420, 0x4120fe21, 0x0223150d, 0x8c0e12a0, 0x0c0d41f3,
    0xd684fc20, 0x0e400324, 0xe0882012, 0x0a417220, 0x72012113, 0x21210041, 0xff820004, 0x43ce0521, 0x432f06eb, 0x00005600, 0x23263425, 0x16140622,
    0x42363233, 0x252919f3, 0x23030e14, 0x27262722, 0x05874a37, 0x23372b08, 0x2223010e, 0x36343526, 0x03163233, 0x33352115, 0x3d363411, 0x06072301,
    0x3727010f, 0x42051133, 0x3e343b58, 0x46324449, 0xf4969efd, 0x1aee3008, 0x45755038, 0x12182e3e, 0x25100f27, 0x10655426, 0x2c511502, 0x6d90866a,
    0xfe1ea47b, 0x0201a72b, 0x3e120807, 0xdf7bc052, 0x724a6a3f, 0x9356364c, 0x372708f3, 0x526d773e, 0x07081031, 0x0d040771, 0x1c175775, 0x9269658f,
    0x722f02bd, 0x07b00172, 0x0c100518, 0x563a120d, 0x4372fdb9, 0xfb8808ef, 0xfb833720, 0xfb890120, 0x8e1de744, 0x411320de, 0xfba21b0e, 0xdf8bd020,
    0x0841c320, 0x8604201a, 0xaafb21fc, 0xfc20fd93, 0x0521e68f, 0x140f4133, 0x03000028, 0x80ff0000, 0x87554006, 0x415c2006, 0x152307f5, 0x18331614,
    0x2911d15a, 0x16071405, 0x16071615, 0x03840607, 0x22022b31, 0x2627012e, 0x35012e27, 0x37363411, 0x8237013e, 0x02680804, 0x37023e37, 0x1e323336,
    0x0e141505, 0x020e0701, 0x16322107, 0x1a260001, 0x1b25251b, 0x26a0261a, 0x1ae0fe1a, 0x011a2626, 0x04261a20, 0x030f37a0, 0x0f11112e, 0x403a0927,
    0x114c2485, 0x4d579c42, 0x261a237b, 0x68181924, 0x12214431, 0x0709091a, 0x13141c0b, 0x2f492e1a, 0x01090f21, 0x03121313, 0x0104080e, 0xc0724e15,
    0x53824483, 0x611b0221, 0x02210550, 0x08108380, 0x2c3f5639, 0x383d4c20, 0x7025393d, 0x1f024c45, 0x012b1a1b, 0x021a2501, 0x02251981, 0x57407202,
    0x253c1221, 0x3c2c272a, 0x1f151314, 0x1e3c2832, 0x2c4c2618, 0x14180622, 0x8200720e, 0x00032f00, 0x0600ff00, 0x00000540, 0x001b000b, 0xff62005c,
    0x06cb4205, 0x2b0fc14f, 0x0e151625, 0x1e212301, 0x021e1702, 0x0525e982, 0x2e272223, 0x23028302, 0x012e2726, 0x352e0282, 0x37363411, 0x023e3736,
    0x1716033b, 0x03840716, 0x41140721, 0x3b081708, 0x71013769, 0x04ebfe4e, 0x12030e08, 0x09011412, 0x492f210f, 0x14131a2e, 0x09070b1c, 0x21121a09,
    0x18683144, 0x1a262419, 0x574d7b23, 0x4c11429c, 0x3a408524, 0x110f2709, 0x03032e11, 0x21070941, 0x0341e5fd, 0xfd440805, 0x26261a80, 0x4e583daf,
    0x18140e72, 0x4d282506, 0x3c1e1826, 0x151f3228, 0x2c3c1413, 0x3c252a27, 0x40572112, 0x25020272, 0x1a810219, 0x2b010125, 0x021f1b1a, 0x2570454c,
    0x3d383d39, 0x0000204c, 0xff00000c, 0x08059b57, 0x0f00092c, 0x2b001700, 0x5c003d00, 0x7f006400, 0x9e008c00, 0xc200b200, 0x35250000, 0x07222334,
    0x32331615, 0x34353337, 0x15251522, 0x01821123, 0x1105352c, 0x23063523, 0x35262722, 0xbe573311, 0x05112106, 0x82062364, 0x15332722, 0x17323336,
    0x11831716, 0x2405ec5b, 0x3734013d, 0x24128236, 0x1523011d, 0x274d8214, 0x35343634, 0x22141501, 0x21081782, 0x27340132, 0x2627012e, 0x0e072021,
    0x15060701, 0x011e1714, 0x37201617, 0x3637013e, 0x07231301, 0x0f832327, 0x33151722, 0x27218c82, 0x228e8226, 0x58011d06, 0x36250531, 0x23113317,
    0x20878611, 0x52878623, 0x5b080f9a, 0x111d9703, 0x1d111010, 0xfd4242b8, 0x4e4a50c5, 0x2743b101, 0x06092125, 0x0e010142, 0x3f011614, 0x23290c07,
    0x20434321, 0x070c2924, 0x0c0302fb, 0x1d34351b, 0x661d1415, 0x2285151b, 0xfe010618, 0x02404081, 0x420a1315, 0xecfe882b, 0x2c88edfe, 0x14140a41,
    0x892b410a, 0x2b892602, 0x25080b82, 0x4b5a0dfd, 0x074e3533, 0x0b230820, 0x1521014a, 0x1b33311d, 0x331b1515, 0xb5151d31, 0x14164343, 0x4301010f,
    0x5d820b06, 0x54f70121, 0x61080b26, 0x10329de9, 0x22ab10e0, 0x46e83333, 0xa70159fe, 0x91fe7e46, 0x111c2d28, 0xfe220125, 0x0f0218f2, 0x6f18011f,
    0x2a153492, 0xed012429, 0x152a28a1, 0x0e1d09b6, 0x26281216, 0x3b813b1b, 0x1d26261b, 0x33414c39, 0x150c011a, 0x9c38030b, 0x349c3333, 0x53b103fd,
    0x0f053b2c, 0x2c3b050f, 0x54b0ad57, 0x0b833c2b, 0x542b3c32, 0x28013b03, 0x5c17c3c3, 0xc9376717, 0x1d3a8278, 0x3a203b82, 0x1b330684, 0xfe72013c,
    0x02101fe5, 0xfe100118, 0x1b1225db, 0x5208012d, 0x002b0b55, 0x1b000b00, 0xe50500ff, 0x42000006, 0x2508091f, 0x0063005b, 0x0089007d, 0x00af009b,
    0x14150100, 0x11272223, 0x05323336, 0x34352315, 0x35332532, 0x11331521, 0x96412133, 0x07bc4112, 0x11233536, 0x33163533, 0x25363732, 0x07142335,
    0x3d222306, 0x34353301, 0x080ed841, 0x0136372f, 0x1d223435, 0x01321401, 0x010e0714, 0x27200607, 0x2627012e, 0x3e373435, 0x20363701, 0x17011e17,
    0x03330116, 0x26112311, 0x33272627, 0x077b4213, 0x013d2624, 0x8f823734, 0x25161722, 0x0812a142, 0x27cb0357, 0x17161617, 0x5a520127, 0x6b3afc5a,
    0x6469c8fe, 0x59592001, 0x03121b1e, 0x0c085901, 0x0136302e, 0x361109ad, 0x59592b32, 0x1136302d, 0x5b520109, 0x2e210702, 0x43271bb3, 0x1d1c2744,
    0x24484527, 0xfd020312, 0x025656a0, 0x580e1acf, 0x1afdb83a, 0x0d593ab8, 0x230b821a, 0xe602b73b, 0x63080b84, 0x79661afc, 0x252f0e64, 0x01476a1c,
    0x44261cb6, 0x1c1c2643, 0x26444326, 0x5b4f011c, 0x0d2e3235, 0x03015b08, 0x011e1b12, 0x1643d324, 0x44162d01, 0x96442e2e, 0xc7fd5e5e, 0x86feee01,
    0x2003152a, 0x79fe6c01, 0x3d251831, 0x1a49c55e, 0xfdd93638, 0x37373069, 0x330d531b, 0x5745240a, 0x33254f67, 0xad4f2533, 0x35380682, 0x03091b1b,
    0x4545d2c2, 0x57fd46d2, 0x503b74ea, 0x06151506, 0xee703b50, 0x07230b83, 0x82071414, 0x0e04300b, 0xf1fe71fe, 0x8a4a0f01, 0xf9fe5467, 0x8251af46,
    0x5026233d, 0x068250af, 0x52252508, 0x3e370dfe, 0x01331825, 0x2191fe8a, 0x012b1602, 0x0200007d, 0x80ff0500, 0xf6057b05, 0x27001300, 0x06010000,
    0x2305414f, 0x27321337, 0x2407304f, 0x01071601, 0x08048215, 0x012b065d, 0x36012722, 0x013b3601, 0x0a550232, 0xef261bf7, 0xfd0a1415, 0x0ca10101,
    0xef17090b, 0xca031a28, 0xf0fd0b0b, 0x0a0b5001, 0x2aef160a, 0x12adfe18, 0x27190102, 0x650316f1, 0x2e4afe12, 0xc0011322, 0x16170101, 0x012d0f0f,
    0xfc151064, 0x99fd015a, 0x2d0f1114, 0x03206e02, 0x45002d8e, 0x9b4406a3, 0x208b8305, 0x228d8237, 0x82262734, 0x06072d74, 0x0315011f, 0x3b161706,
    0x01373201, 0x01221184, 0x0d840116, 0x01273626, 0x17360135, 0x080cde4d, 0x0216322d, 0x1f157ead, 0x070812b8, 0x09c47d08, 0xb9100809, 0x3703131f,
    0x1ebb1107, 0x0165fe13, 0x20140501, 0x080712b8, 0x01fcfe09, 0x43db0899, 0x23080ba0, 0xdd010303, 0x110c0b22, 0xa6fe01d8, 0x240d0e0e, 0x230c5103,
    0xfe0227fd, 0x0d0c2321, 0x01dc010f, 0x8810d302, 0x290d2e43, 0x00000200, 0x00070a00, 0x0982f604, 0xb1824920, 0x012d2108, 0x1f043213, 0x051e3201,
    0x17021e17, 0x1d17011e, 0x0e071601, 0x0e010f01, 0x21062306, 0x022f2426, 0x08054946, 0x27012e25, 0x3726013d, 0x013f013e, 0x3633063e, 0xe401c702,
    0xa8b91cfe, 0x49493901, 0x210e2001, 0x0e1e2018, 0x82271306, 0x01013ba5, 0x0e240713, 0x201e0e0e, 0x1f0f2118, 0x88fefb01, 0x30cffecf, 0x25242431,
    0x21911841, 0x200e3308, 0x9801fb01, 0x6701fdfa, 0x03040509, 0x100a0603, 0x19060f17, 0x9140375c, 0x91882829, 0x11593791, 0x0f170f11, 0x0303060a,
    0x03090213, 0x0a050404, 0x1f901920, 0x1f831020, 0x00122208, 0x40000500, 0xc00680ff, 0x03008a05, 0x17001300, 0x1f001b00, 0x04090000, 0x27150115,
    0x35013507, 0x08028217, 0x0915373f, 0x0192010c, 0xfeaafeee, 0xfe2c0516, 0xfe010116, 0x56019317, 0x57010101, 0x560151fd, 0xaefe12fe, 0x52012e05,
    0xa9fe17fe, 0xe9015701, 0x12feaefe, 0xcffe3d03, 0x3f01e3fe, 0xfe6ce4fe, 0x082882db, 0x25010134, 0x1c01606c, 0x02010102, 0xd804e4fe, 0xd0fee3fe,
    0xf2fe0e01, 0xc1fef1fe, 0x7e031d01, 0xf2fec1fe, 0x06003001, 0x00ff0b00, 0x0006f505, 0x0b000700, 0x8f860f00, 0x21050025, 0x82112311, 0x37252603,
    0x37010705, 0x08038401, 0x07010350, 0x21350109, 0xfb090515, 0x9e05a0a2, 0x2152fca0, 0xfd210f03, 0xd5024358, 0x66f4fd43, 0xd9666602, 0xfe80dd01,
    0x03b2fd23, 0xe0016020, 0x800280fd, 0x9ca59d2c, 0xfe921a02, 0xb60291ad, 0x7bfffd7b, 0x7ffd7b03, 0xfa810260, 0x009f9fa1, 0x835b0000, 0x82072009,
    0x00172479, 0x6267004f, 0x003d09e5, 0x26200610, 0x24203610, 0x26220614, 0x24323634, 0x020e2622, 0x07010e07, 0x1416030e, 0x05034206, 0x36031e2c,
    0x023e1632, 0x37013e37, 0x2482033e, 0x27022e29, 0x2e27012e, 0x44100003, 0x10200ae7, 0x2009e644, 0x06a66104, 0xfee6203d, 0x01e6e6b8, 0x36520148,
    0x4c36364c, 0x8b0e47fe, 0x1d557948, 0x0b144c32, 0x8201050f, 0x0f052a00, 0x324c140b, 0x4879551d, 0x2d1a998b, 0x0a056e02, 0xfe58d0e4, 0xe4d05836,
    0x0b84050a, 0x83ca0121, 0x1602280b, 0xd49696d4, 0x85a40196, 0x84e62065, 0x80362364, 0x56a40101, 0xfe21718d, 0x845f916e, 0x0cd7436b, 0x17000f24,
    0x2f631f00, 0x7a332010, 0x342a08f9, 0x14062226, 0xe0043216, 0x9743a977, 0x9a012807, 0x7c7cb07c, 0x84b002b0, 0x80052106, 0x210baf43, 0x1a83a8fc,
    0x02831d82, 0x03000022, 0x2408db48, 0x00090002, 0x28678215, 0x33052113, 0x37330109, 0x0c2e6721, 0xfec90030, 0x5e36026e, 0x35fe35fe, 0x0a02685e,
    0x415bfb01, 0x92032b0e, 0x02e0cefe, 0xa04dfdb3, 0x325b3101, 0x0500210e, 0x502e6382, 0xa3058105, 0x16000a00, 0x43002a00, 0x67826700, 0x06162808,
    0x36012e27, 0x011e3637, 0x07012e17, 0x1e17010e, 0x013e3701, 0x27022e13, 0x020e0524, 0x17021e07, 0x023e3716, 0x82030e13, 0x2726311b, 0x2627032e,
    0x16013f27, 0x011e3720, 0x03061306, 0x06212182, 0x20168225, 0x27198304, 0x3637043e, 0x16052437, 0xdc084282, 0x75082f03, 0x1c1d2735, 0x37492426,
    0x62c60e6f, 0x04034b3f, 0x7a5b5c93, 0x2c4814e4, 0xfeddfe31, 0x402e2bed, 0x375c1e12, 0x3fdce43c, 0x08565c35, 0x242c0d0f, 0x67c5cf56, 0x4052472e,
    0x06201914, 0x3702df12, 0x100615e0, 0x05551ab5, 0xfc212b2c, 0x92f89afe, 0x050d150f, 0x23090207, 0x03091a15, 0x2438221d, 0x01bc7d1e, 0x9b29017b,
    0x0201103c, 0x204c3fa5, 0x11525211, 0x113b0c12, 0x1c2c726b, 0x805b4579, 0x02980808, 0x09231b7a, 0x07312f08, 0x1c1a220a, 0x1d070923, 0x2308081c,
    0x651a12fc, 0x30144943, 0x0811032f, 0x23352214, 0x0910c460, 0x22069494, 0xa7b80338, 0x341e18fe, 0x267e111c, 0x1d0c701b, 0x09341b29, 0xac7bc832,
    0x1e2d1a48, 0x2e0b0f1e, 0x2e572512, 0x003e144c, 0x08ab4106, 0x00083a08, 0x00270013, 0x0059003a, 0x01000069, 0x06072634, 0x36161716, 0x010e1637,
    0x36262726, 0x13163637, 0x0607020e, 0x27022e27, 0x3637023e, 0x13021e17, 0x27263634, 0x0f272006, 0x41288201, 0x36270558, 0x26272627, 0x41070605,
    0x1e26056b, 0x17161703, 0x2e823704, 0x184a1220, 0x505c0810, 0x012b2452, 0x4a54272b, 0x6a845808, 0x2d370203, 0x14b68f46, 0x9b2c2743, 0x43262ca9,
    0x222e0d15, 0x21d2c61e, 0x0b383224, 0xfea10f05, 0x050ca268, 0x9d2f0f1a, 0x1e22b3f9, 0x1109870f, 0xfed8702b, 0x265e84f1, 0x0804332b, 0x01062416,
    0x0d120608, 0x0301b369, 0x1f1f18b5, 0x28013004, 0x080b9b42, 0x2b9a025f, 0x6914162e, 0x3d361712, 0x5c0c6e42, 0x14583143, 0x3a01521f, 0x05061a15,
    0x07061414, 0x18131419, 0x22230507, 0xfd190705, 0x19270703, 0x066a6a04, 0x51389a0c, 0x13632e1b, 0xc7026a41, 0x21371635, 0x220c1b3f, 0x1e30140f,
    0x24ca8c44, 0x22143405, 0x1c14500b, 0x26140d5b, 0x010b0115, 0x0e874632, 0x00016b08, 0x0480ff44, 0x00000600, 0x25000022, 0x07010e17, 0x35032e06,
    0x3e352311, 0x013e3704, 0x2111013b, 0x14112115, 0x3637021e, 0x1750b003, 0xad6859b0, 0xa8214e70, 0x30447248, 0x07010514, 0x4d01f404, 0x200db2fe,
    0xcf4e3043, 0x013e23ed, 0x785c3802, 0x20023a78, 0x5d571ad7, 0x052d576f, 0xfc58fe07, 0x341efafd, 0x02011e35, 0x5f5f0000, 0x001f2209, 0x336d822f,
    0x06230627, 0x1135022e, 0x11213521, 0x0e072223, 0x33150703, 0x3e216b84, 0x0f7f4101, 0x3e70043d, 0x34243b2c, 0x01010a19, 0x08bc00ff, 0x35190501,
    0x2b824465, 0x45639b57, 0x41a20187, 0x4b3e0b3f, 0x170116b7, 0x01172928, 0x4601c28e, 0x68562c0a, 0xfea51956, 0x6a74395e, 0x30010241, 0xfe8b2f04,
    0x03000126, 0xfd0240ff, 0x1724fb82, 0x16000000, 0x0815ba54, 0x10f5022b, 0x0aa2fe0d, 0xfe0a0e0d, 0x09080d9d, 0x0e12e014, 0xe0120ec0, 0x10260001,
    0x0a0a80fe, 0x13108001, 0x0ee00413, 0xfb0e1212, 0x83458220, 0x02002553, 0x00c005fd, 0x01205382, 0x2405b762, 0x2622012b, 0x2ae18235, 0x36013726,
    0x01173233, 0x88fd0216, 0x10152447, 0x835e010d, 0x6301275d, 0x1313040d, 0x498320fb, 0x26e00424, 0x5c820110, 0x1080fe22, 0x00295282, 0x01400001,
    0x03000703, 0x245384fd, 0x23061415, 0x23048221, 0x35260127, 0x2407047a, 0x07163221, 0x8e818300, 0xe0022194, 0x6389ab83, 0x840e6221, 0x265482c1,
    0x01000001, 0x86c00603, 0x05975e53, 0x5f183d20, 0xa7820c3d, 0x0ac00622, 0x958e8282, 0x0e830225, 0x859efe0a, 0x860e2048, 0xa2fe225e, 0x3053820a,
    0xff000002, 0x06710580, 0x00260000, 0x01000038, 0x05ce4d06, 0x83222321, 0x02032107, 0xfe83ad82, 0x32331622, 0x2005754b, 0x251f8217, 0x01161415,
    0x08820714, 0x46080382, 0x37363736, 0x1417011e, 0x27710516, 0x31808154, 0x3d41565b, 0x98335151, 0x71719395, 0x686948ab, 0x66622d22, 0x345e7747,
    0x41234f34, 0x1de1fe8a, 0x36363f1e, 0x4b034325, 0x0301b04a, 0x41010101, 0x20c47d7d, 0x82222120, 0x0527080c, 0x9092e4f2, 0x22221e1e, 0x43402441,
    0x7c715e33, 0x3d7a04c6, 0x363f4b4b, 0x95060b12, 0x03296b6c, 0x0c040310, 0x82040000, 0x060027af, 0x00800580, 0x1d480003, 0x01002705, 0x01112511,
    0x03822111, 0x02230785, 0x8356fdaa, 0x06250803, 0x0375fc80, 0x0275fc8b, 0x5e75fd12, 0xe7022d02, 0x35026dfd, 0xeefc77fd, 0x0395027d, 0x02e6fc6e,
    0x0000009d, 0x234f8306, 0x7e058005, 0x0f284d82, 0x37001c00, 0x5b004d00, 0x32271782, 0x22263436, 0x86041406, 0x32052507, 0x14111516, 0x20067478,
    0x20098205, 0x0550792b, 0x23013d2a, 0x23061415, 0x27352622, 0x11370483, 0x15011e01, 0x37363421, 0x36372627, 0x3236011f, 0x17363717, 0x82010716,
    0x081e8430, 0x33363443, 0xdd011632, 0x20171720, 0x20bc0116, 0x17201616, 0x3c2afbfc, 0x3c3c563b, 0x2d404f04, 0x3c563c4b, 0x2a2b3c8a, 0x2e4a013c,
    0x6bae0240, 0x8063fc80, 0x0c07476c, 0x5f48070d, 0x07485fd4, 0x01070c0d, 0x261f8396, 0x3c2b2a3c, 0x83171d04, 0x824a8247, 0x3ccf3202, 0x2b52fe2a,
    0x012b3c3c, 0x133c2aae, 0x402e66fd, 0x200d83e3, 0x3a0585e3, 0x9a022e40, 0xc5379501, 0x37c57575, 0x06070d83, 0x2a2a840c, 0x07060c84, 0x8795fd0d,
    0x2b2d0835, 0x09003b3b, 0x00ff0b00, 0x0006f905, 0x0f000800, 0x08012200, 0x25011501, 0x49013301, 0x0000f101, 0x23010e01, 0x37343506, 0x26061732,
    0x37d48207, 0x010e2601, 0x06070607, 0x37361617, 0x013c033e, 0x27340126, 0x3426033e, 0x2005ef48, 0x82f58216, 0x012e2c1c, 0x27042e27, 0x2627032e,
    0x83272636, 0x36012b0c, 0x07163637, 0x36371606, 0x16823534, 0x14170627, 0x06012e23, 0x201d8227, 0x222e8226, 0x8237011e, 0x2207221f, 0x222f8226,
    0x82163217, 0x82072011, 0x010e2664, 0x17031e17, 0x25658216, 0x1e173637, 0x13830601, 0x27221a82, 0x65821726, 0x053e372b, 0x0e141716, 0x020e0705,
    0x26368227, 0x14150607, 0x8217020e, 0x82062035, 0x21118366, 0xa5843637, 0x44821e20, 0x062b0283, 0x15021e07, 0x022e2736, 0x82013e37, 0x82362053,
    0x82288252, 0x3e172191, 0x26207c82, 0x33240f82, 0x0116013e, 0x15289083, 0x07321716, 0x05323306, 0x0420d283, 0x2605aa46, 0x012e3427, 0x82062207,
    0x14172178, 0x0d82ab82, 0x23262725, 0x8216010e, 0x1617217e, 0x32244183, 0x021e0136, 0x01208e83, 0xf984a682, 0x82222321, 0x840320b1, 0x820420fd,
    0x363724d7, 0x8236012e, 0x2002827c, 0x21a28435, 0xde820607, 0x06140723, 0x05026a17, 0x02229882, 0xcb85012e, 0x37262723, 0x200f823e, 0x82698203,
    0x209b83db, 0x82248336, 0x202b8431, 0x20e68216, 0x8259820e, 0x820e2056, 0x86a182cc, 0x06694158, 0x051eef08, 0x090b9702, 0x05130504, 0x0a0f045c,
    0xfe030818, 0x0504049b, 0x0a070303, 0x04110409, 0x01020201, 0x37550302, 0x03030704, 0x09010702, 0x234a0a01, 0x21572118, 0x0f1f270b, 0x15090b01,
    0x010d0d12, 0x1619220e, 0x0b140404, 0x063b0f27, 0x19160608, 0x0b0a1c25, 0x050d1512, 0x10161911, 0x0901126b, 0x01031929, 0x1d1b1c22, 0x11090102,
    0x04060a07, 0x0111070b, 0x11181401, 0x16010114, 0x01270809, 0x0e0a050d, 0x161b0a16, 0x2a02372f, 0x0905201b, 0x0903050b, 0x0949140c, 0x36191a2c,
    0x1001010a, 0x26112a19, 0x161b2122, 0x0602020d, 0x0d070b06, 0x364f1c03, 0x162a1516, 0x1d1e0103, 0x4f17120d, 0x06010208, 0x04201508, 0x05040602,
    0x2e240202, 0x14042805, 0x031009a8, 0x2a081e1f, 0x04272e0e, 0x0301060d, 0x782e0a14, 0x0b172c85, 0x7382020c, 0x1506fa08, 0x02021703, 0x0f160211,
    0x4e430124, 0x0b03a1fd, 0x03020906, 0x0b03030a, 0x02a30103, 0x05061109, 0x02060509, 0x122a0e03, 0x0ab40b09, 0x0406030c, 0x040e0304, 0x05360208,
    0x090f030d, 0x02030509, 0x04020a01, 0x080e0804, 0x020e1001, 0x02161437, 0x25171807, 0x2608261a, 0x66111c5f, 0x0a171226, 0x562c1e22, 0x2c144c13,
    0x1c332447, 0x1340a41d, 0x182b2440, 0x01220a05, 0x010a0a01, 0x11560e0a, 0x3515181e, 0x09223320, 0x0c02120d, 0x22010405, 0x14220303, 0x64182381,
    0x2b2b1741, 0x0a141203, 0x2d443079, 0x0103040b, 0x071e1201, 0x26162508, 0x0c0e6e14, 0x50340204, 0x6a354127, 0x05453924, 0x63222305, 0x080f5937,
    0x0a0b1206, 0x22361b1b, 0x09121b12, 0x2616020e, 0x13141012, 0x285a380a, 0x35493d3b, 0x20270b30, 0x0e032121, 0x1a0f0e01, 0x65041b10, 0x06011301,
    0x080e820c, 0x0b030f8a, 0x52fe060d, 0x05110801, 0x010b0805, 0x030a1001, 0x03050408, 0x9afe0203, 0x190f1812, 0x0a1d101b, 0x052b0722, 0x14146e30,
    0x2874a23f, 0x7a2d0402, 0x1f3c272e, 0x3e010c12, 0x16241e52, 0x08224115, 0x01011e03, 0x03013432, 0x0f131942, 0x05400407, 0x0915281e, 0x0f7e0803,
    0x07040309, 0x01014239, 0x2c0f1f39, 0x0b03021f, 0x131d0109, 0x2a011e16, 0x0e0f0424, 0x0e01170c, 0x1708051a, 0x02010b0f, 0x090c0111, 0x060e0911,
    0x40098982, 0x041f0603, 0x07050413, 0x0f040402, 0x0c010117, 0x090f1310, 0x05020904, 0x03060405, 0x3c0e0107, 0x3e0b0c1a, 0x0703091f, 0x44303f19,
    0x39a8061d, 0x18086612, 0x1c3f1f15, 0x0101131c, 0x0c654104, 0x87170420, 0x282e0f09, 0x313b0f03, 0x0844182e, 0x05020810, 0x10340709, 0x0826480f,
    0x43192e06, 0x13011d17, 0x69152074, 0x25121a59, 0x2a030b20, 0x02021a11, 0x0f010509, 0x0708c214, 0x0a030403, 0x02010706, 0x01043710, 0x110be012,
    0x04040108, 0x031b0401, 0x02ea0205, 0x0f020806, 0x060d0d01, 0x06050d04, 0x030c0603, 0xc8fa0401, 0x1617190c, 0x0d141116, 0x4a130412, 0x1207101b,
    0x11161d09, 0x01030101, 0x19201c01, 0x0d3c0101, 0x0c070b04, 0x57170b11, 0x2530100b, 0x040c0924, 0x2222120a, 0x05142149, 0x2a0f0d03, 0x160c1806,
    0x0e440f0b, 0x19060911, 0x0e200608, 0x342c0603, 0xbe112741, 0x09224a34, 0x1d161018, 0x1512302e, 0x14443666, 0xc670348f, 0x152b7b5a, 0x2a1b1d01,
    0x775f449f, 0xd03b6971, 0x28473157, 0x25220202, 0x0801011e, 0x051d0c13, 0x37540e25, 0x47417d46, 0x23312105, 0x2dd68219, 0x4a0b0b19, 0x331f0c47,
    0x0f0b1b1e, 0x474b0800, 0x0e360808, 0x27002000, 0x32002e00, 0x56003e00, 0x00006200, 0x23032625, 0x07040e07, 0x32331627, 0x04272603, 0x14150621,
    0x033e1716, 0x013e013f, 0x0e272627, 0x05200701, 0x11820726, 0x22010128, 0x26053607, 0x0c832223, 0x26130423, 0x2e358327, 0x011e1716, 0x32013e17,
    0x3617041e, 0x18040210, 0x0807fc50, 0x2a00045c, 0x10020262, 0x887e9436, 0xeab80f23, 0x20153d84, 0x96fec9fe, 0x32505801, 0x267b8a93, 0x67120425,
    0xc08a7c78, 0x032e0120, 0x57c7d2dc, 0xfc946f29, 0x010101f1, 0xf8b94f02, 0x73834f4c, 0x3c477a45, 0x9203e40f, 0x43140901, 0x19457d4b, 0x03090213,
    0x44464d24, 0x1e2b353c, 0x874d7a0a, 0x8324200e, 0x064d0839, 0x8e574d15, 0x02960b4d, 0x5d3e3193, 0xe17c0e07, 0x5e9b5959, 0x010d0e44, 0xa5d5d605,
    0xef97f241, 0xe6ef1f3c, 0x6d03e54b, 0xa4910101, 0x1ad4aa13, 0x153c3645, 0xb2e822fe, 0x40190c01, 0x351c4939, 0x0518052a, 0x05030405, 0x02050706,
    0x0fce4dc8, 0xcb4a0020, 0x3e380809, 0x00005e00, 0x032e3401, 0x042e012f, 0x32333435, 0x3233031e, 0x2e343536, 0x0e222301, 0x1e141502, 0x16011f02,
    0x14151617, 0x2e222306, 0x06222303, 0x33161415, 0x05023e32, 0x27201083, 0x24251482, 0x34350226, 0x05525837, 0x36174e08, 0x16043233, 0x07141512,
    0x27950416, 0x314d583a, 0x2a1c1e68, 0x2b900f12, 0x2c242844, 0x70392f1a, 0x804460ac, 0x4a26436f, 0x5a923c56, 0x41502016, 0x2a315133, 0x33321d32,
    0x8649a9f4, 0x6b01426f, 0x68829fe1, 0xfe8f494d, 0x106fbdfb, 0x210c8650, 0x0c830501, 0xd9014108, 0x2c365332, 0x07180b18, 0x1a101007, 0x21184d11,
    0x2d401822, 0x1f2e5937, 0x3d496f3f, 0x0e253c5b, 0x140e1624, 0x20332728, 0x3c202d2d, 0x25835c2d, 0x9f907546, 0x6f1050e1, 0x8f0501bd, 0x82684d49,
    0xfe210c85, 0x390c83fb, 0x03000000, 0x80ff2c00, 0x0006cb04, 0x3f002300, 0x00004400, 0x26363701, 0xe1822123, 0x3714112a, 0x3b013e01, 0x37363201,
    0x13830182, 0x27077b65, 0x0a063736, 0x040e0701, 0x07252682, 0x010e0106, 0xf9511827, 0x07510808, 0x011a3603, 0x0525e803, 0x38fd151c, 0x01061f17,
    0x211e1723, 0x031e16ef, 0x1f040d18, 0x1ddafe15, 0x011d2626, 0xe622125a, 0x043e4d0f, 0x1b160606, 0xf1fe2132, 0xfe08090d, 0x0c49165e, 0x03524c37,
    0x16405f78, 0x4d3e049e, 0x17c24e04, 0xfb142222, 0x276082b3, 0x1d0f1a60, 0x153d820f, 0x25083b82, 0x1b251d2a, 0x7dfe49ee, 0x1611c7fe, 0x14162c15,
    0x1bfe090a, 0x16090719, 0x3782054c, 0xfc6a6a5f, 0x390111ea, 0xd6828301, 0x210a0f50, 0xa94c000f, 0xd3541805, 0x1956180e, 0xe3541815, 0x12c02e0a,
    0x0e20fe0e, 0x010e1212, 0x02120ee0, 0x290d8ba0, 0xfa1a26a0, 0x26261a80, 0x0582051a, 0x0004c022, 0xfc202583, 0x01230583, 0x8380028e, 0x83fd200c,
    0x0e032105, 0x26202489, 0x022c9383, 0x00ff0000, 0xe0050005, 0x39003100, 0x2706855a, 0x15230327, 0x14151613, 0x280e654c, 0x13373435, 0x06032335,
    0x2b908223, 0x36013734, 0x17322133, 0x14001601, 0x08056752, 0x3800055c, 0xe31d3328, 0x2609f72d, 0x2e42c01a, 0xc0422ea0, 0xf709261a, 0x331de32d,
    0x01103828, 0x01674900, 0x01496780, 0x60fe1000, 0x8383ba83, 0x28e001ba, 0x55012b38, 0x0f65fe84, 0xfe261a12, 0x42422ef0, 0x2610012e, 0x010f121a,
    0xabfe849b, 0x1d28382b, 0x6b800118, 0x1880fe6b, 0x30836003, 0x84008321, 0x830420ab, 0x002522ab, 0x4aab822d, 0x232006ec, 0x34200796, 0x9f88a183,
    0x38000428, 0x42403850, 0x0384425c, 0x70270b82, 0x50800250, 0x84e0fe70, 0x40032b8d, 0x382860fe, 0x60012838, 0x898470fc, 0x30fed022, 0x03230783,
    0x84a0fe90, 0x50a02517, 0xcd017070, 0x17568789, 0x00153a05, 0x25000021, 0x26013e01, 0x010e2627, 0x22230607, 0x07022e27, 0x1716010e, 0x0aa34424,
    0x01050339, 0x1d11105e, 0x3d56282f, 0x3b3c2418, 0x563d1824, 0x111d2e29, 0x44580410, 0xea350e60, 0x4a16d901, 0x011a1f60, 0x28281c22, 0x1a01221c,
    0x164a601f, 0x1223448e, 0xff2c5c08, 0x05d40600, 0x000f00ff, 0x00000049, 0x22022e34, 0x1e14020e, 0x013e3202, 0x05070625, 0x06071411, 0x06072527,
    0x05012f22, 0x35262706, 0x27262511, 0x27013f26, 0x37363726, 0x37341125, 0x37051736, 0x011f3236, 0x16173625, 0x16051115, 0x010f1617, 0xc0051617,
    0xead59b5b, 0x855b9bd5, 0x01220806, 0xfe10046f, 0x0e0f0ddc, 0x0ab4dcfe, 0xfeb40a20, 0x0d0f0edc, 0x0410dcfe, 0xb4b40905, 0x10040509, 0x1c822401,
    0xb4240128, 0xb4092209, 0x1c822401, 0x86240121, 0x0b02211c, 0x4d824689, 0x050f353e, 0x10cefe60, 0x5e060a0a, 0xf80d0df8, 0x0a0a065e, 0x60320110,
    0x0c110f05, 0x100df8f8, 0x01211d82, 0x211d8532, 0x1d850c0c, 0x82cefe21, 0x1020081d, 0x0cf8f80d, 0x00000200, 0xbe0580ff, 0x12007f05, 0x00003100,
    0x22230625, 0x34350224, 0x15020637, 0x3325f082, 0x06252432, 0x20128204, 0x22138226, 0x82243612, 0x071623da, 0x1a82010e, 0x32330122, 0x33080c82,
    0xee04011e, 0xfeb63836, 0xc968b4ca, 0xedab66ff, 0x03019082, 0xfe5e2601, 0xfe9ce085, 0x737acee4, 0x991201c5, 0x2112112c, 0xfa925b56, 0x296e7694,
    0xe9070e1f, 0x4708cd82, 0xa5c0b636, 0xd7aefe3c, 0x66abed82, 0xf3cbc37b, 0x1c01ce7a, 0x1701999c, 0x02067dcc, 0x4e1f2929, 0xfa9473cf, 0x1f123392,
    0x0300280e, 0x80ff4000, 0x8005c006, 0x1b000b00, 0x00002b00, 0x23263400, 0x14062221, 0x32213316, 0x180f6d50, 0x220f3553, 0x18264004, 0x21094d43,
    0xc1436602, 0x2619820b, 0x261a00fa, 0x82061a26, 0xa6022a05, 0x34262634, 0xfc000126, 0x21128340, 0x0582c003, 0xffa60122, 0x08e64318, 0x0000262f,
    0xff200002, 0x056006a0, 0x004200c0, 0x37858248, 0x012b0614, 0x16170714, 0x22060714, 0x040e012f, 0x11231123, 0x2f022e22, 0x2d06a442, 0x26013f01,
    0x26222335, 0x013b3634, 0x06822711, 0x1f323808, 0x36372101, 0x0f141632, 0x32331101, 0x36342101, 0x60061620, 0x43e01a26, 0x121313d0, 0x05c61236,
    0x62424014, 0x65338030, 0x0f0e3b49, 0x181c14b7, 0x11031313, 0x82e03aca, 0x1a3d088a, 0x2613ade0, 0x03ad1334, 0x3413ad4c, 0xe0ad1326, 0xfd46fe1a,
    0x0a01bb80, 0x345a02bb, 0xd177ab26, 0x13133413, 0x1005c513, 0x031a2029, 0x1b80fc80, 0x0e0d2727, 0x121015cf, 0x72e31435, 0x20d883a0, 0x85388526,
    0xdafe3346, 0xbb850002, 0x010000bb, 0x0100ffff, 0x47047d07, 0x0c828500, 0x06071629, 0x1e020e07, 0x82161702, 0x021e3701, 0x0523010e, 0x012f2606,
    0x0e07032e, 0x06141704, 0x0706010f, 0xe1830623, 0x02032e22, 0x3f2ad182, 0x25333601, 0x011f011e, 0x05831716, 0x32031e31, 0x27043e37, 0x012f012e,
    0x37262726, 0x83363736, 0x14032445, 0x5715010e, 0x3e210615, 0x09158202, 0x3f013e0c, 0x17023e01, 0x17163625, 0xad177d07, 0x1e282918, 0x2e13071f,
    0x8d010422, 0x07070332, 0xff262a08, 0x14401800, 0x39501e14, 0x0a031841, 0x010f1318, 0x12040407, 0x96477323, 0x19185d71, 0x686c230a, 0x03063c8d,
    0x012a0f04, 0x05160c12, 0x14081005, 0x1d100f34, 0x1c282b36, 0x1206020d, 0x02050a09, 0x1906070e, 0x10120d3c, 0x52ba3516, 0x0e1b1435, 0x02030207,
    0x0e110601, 0x2a221208, 0x2f3c253e, 0x04050c04, 0x0a140602, 0x32272001, 0x40f80306, 0x333520e6, 0x2a1b392a, 0x02021f2c, 0x0f055a83, 0x04191e26,
    0x0c0c1405, 0x2f455615, 0x18050108, 0x0f2b4523, 0x13050619, 0x41290403, 0x0a181843, 0x01a08e28, 0x16108d06, 0x02130605, 0x03040902, 0x6b32150b,
    0x583c1d1c, 0x01051c31, 0x683a2408, 0x0d422849, 0x0209220c, 0x1a0b1316, 0x050c0102, 0x3a211f11, 0x0b265934, 0x1f2f223e, 0x1a040209, 0x683e5b2b,
    0x030f0a79, 0x02820103, 0x0f05023e, 0x00070009, 0x06aaff00, 0x004b05f7, 0x0015000a, 0x002f0021, 0x00690055, 0x2500007f, 0x2108134f, 0x0a863736,
    0x36161735, 0x27010e17, 0x3e37012e, 0x011e1701, 0x24012e25, 0x82040607, 0x37042f09, 0x14252436, 0x2004020e, 0x35012e24, 0x0e821234, 0x0716172a,
    0x36011e06, 0x3236013f, 0x0e220a82, 0x31821e01, 0x1e020224, 0x40850701, 0x07263623, 0x05524e06, 0x13842520, 0x64825382, 0x07012e25, 0x82012e06,
    0x1665086f, 0x1415a302, 0x154e2223, 0x51441216, 0x0d090874, 0x11071d0e, 0xb51e0e1e, 0x6b6fe22d, 0xd12f2f51, 0x015f6f6a, 0xfea0090b, 0xfedf92ff,
    0xa0090edb, 0xdf920101, 0x26012501, 0xfec1904a, 0xfee6fefd, 0x8b82d5f4, 0x5901a980, 0x042d414a, 0x060f0e06, 0x2ed68b06, 0x05022d2d, 0x390c0a0e,
    0x5474445c, 0x2b081319, 0x08988217, 0x3f58144a, 0x05042a18, 0x013c181a, 0x27335755, 0x1a363209, 0x3e241c08, 0x1c57ac3e, 0x1c1f0c30, 0x22fcf27b,
    0x1a0e0f46, 0x20452221, 0x1b0d9b1b, 0x0d0b0505, 0x0b050e1f, 0x2460665e, 0x5d5fb922, 0xb51d1b5c, 0x4694603c, 0x92ed170e, 0x29080685, 0x838f448e,
    0x77433e68, 0x01736cb7, 0x86a98004, 0x0e91404a, 0x0203020c, 0x3f3d3b02, 0x0b0e0d73, 0x3a120404, 0x5e5f0269, 0x7d82387b, 0x3f228382, 0x7d820d60,
    0x05291839, 0xfd604f0d, 0x121a1b73, 0xb4521b32, 0x12354544, 0x2f381f06, 0x484b1a06, 0x68080b5b, 0x00090072, 0x001d0013, 0x23060500, 0x013e2722,
    0x01011e37, 0x07021411, 0x12341126, 0x07100124, 0x11350226, 0x04120416, 0xc4c5ab6d, 0x22c38aab, 0x9bfec323, 0xa7b5ccfd, 0x35042401, 0xb3fdccb5,
    0x22a72401, 0xf8575e5e, 0x05f89090, 0xfc1bfe3d, 0xd76361fe, 0x01bb1801, 0x2afdd645, 0x63d7e8fe, 0x01fc9f01, 0xfed61ee5, 0x05eb53bb, 0x0500ff3f,
    0x0000067a, 0x0100006b, 0x032e030e, 0x0006012f, 0x34262207, 0x24363336, 0x2e020e37, 0x23818203, 0x3617021e, 0x05200b83, 0x05380b83, 0x3536011f,
    0x3736052e, 0x020e041e, 0x1416010f, 0x16053e07, 0x26060e17, 0x0a833982, 0x7a05f208, 0x685e5820, 0x3c4f5e63, 0xfe711110, 0x1a13d09f, 0x01ad131a,
    0x4824662b, 0x5662585e, 0xc8722153, 0x193f7287, 0x16071a35, 0x525f4447, 0x062d4056, 0x56627f46, 0x1621333d, 0x080c0405, 0x3438471b, 0x4933260e,
    0x05243c6d, 0x08121406, 0x03010107, 0x58362f0e, 0x0244815f, 0x554e3d27, 0x113b4c54, 0x06321711, 0x77504b18, 0xb1018e74, 0x203d7450, 0x191e0e03,
    0xfee40a0a, 0x261a01f9, 0xbcd50119, 0x0d08120e, 0x537e4a2c, 0x4e23142f, 0xa0832c4c, 0x03020301, 0x4a381d11, 0x111c4673, 0x3f3b2913, 0x100f313f,
    0x1406497a, 0x71704a45, 0x4919448d, 0x53585a50, 0x0f0f3646, 0x071a5c04, 0x3a353f17, 0x4e17021f, 0x1e3d527f, 0x03030112, 0x07889303, 0x262e3b17,
    0x04003102, 0x00ff1500, 0x0005eb04, 0x10000c00, 0x1e001400, 0x15010000, 0x012b0614, 0x05b36f01, 0x21150123, 0x38038311, 0x35211525, 0x21333634,
    0xeb041632, 0xfe395173, 0x51effdfc, 0xfbd60473, 0x3803872a, 0x4e035173, 0x1b017351, 0xfe775542, 0x770d01f3, 0x46014255, 0x01ff00ff, 0x25048248,
    0x5443438c, 0x674a7777, 0x00192c0a, 0x00310025, 0x07140000, 0x18230601, 0x1813c674, 0x361800d5, 0xc0fe0980, 0x130d0e09, 0x130da0fe, 0x60010d13,
    0x0c0c0e12, 0x75a93f01, 0xfa2006ba, 0x13420219, 0x1c8e0222, 0x11cf7418, 0xf075ab20, 0x2099821b, 0x082f4e03, 0x7518ab86, 0x34380d8d, 0x33360137,
    0x011d1632, 0x12163221, 0x20012e10, 0x1e10010e, 0x00362001, 0x250a5e49, 0x0d138004, 0xa083a0fe, 0x09c1fe25, 0x83400109, 0x600124b6, 0x9ca0130d,
    0xc0e02bac, 0x0ec0130d, 0x3f010a12, 0x34831c09, 0xc00d1325, 0x9cfffe13, 0x20ab89ad, 0x05bf4b0f, 0x14110122, 0x8605956c, 0x0fbf4ba6, 0x310fff47,
    0x1a260004, 0x40fe1114, 0xc0011b1b, 0x261a1411, 0x0c760001, 0xc0032719, 0x261a80fd, 0x3676010c, 0x260c2305, 0x0f76c6fc, 0x00072222, 0x21998213,
    0x934b0000, 0x41122006, 0x6018062e, 0xcf5d0f31, 0x182a2006, 0x211b3760, 0x8c5dea02, 0x0bdb7705, 0x113e6018, 0x0200b308, 0x00ff0000, 0xe0055d06,
    0x36001500, 0x17010000, 0x22230406, 0x34350224, 0x0e173712, 0x00141501, 0x013e3233, 0x06051725, 0x03272223, 0x27262221, 0x3e372603, 0x16323301,
    0x27061415, 0x21152113, 0x17322117, 0x66ff0313, 0xbbd0fe3a, 0x9bf7fe9c, 0x7a11aad1, 0xb9070192, 0x0275d57e, 0x00ff3a1b, 0x1128100d, 0x1828feef,
    0x02600325, 0x36560e08, 0x44685e42, 0xfea70125, 0xc7011069, 0x01e41128, 0xdeb3cc5d, 0x9c09019b, 0x3e2a01b5, 0x85df3683, 0x82f9feb9, 0x80721add,
    0xdd012307, 0x0b031821, 0x3f331911, 0x6145425e, 0x80dffe07, 0x39fe2380, 0x634f0000, 0x0023220a, 0x29b38233, 0x03262736, 0x07323336, 0xa482010e,
    0x26272624, 0x0a820607, 0x75170721, 0x1725059b, 0x13323316, 0x0fb94912, 0x0c052508, 0x51e7ab0a, 0x0b55262c, 0x2b238c04, 0x1e200d27, 0x1b693b82,
    0x4c341b6c, 0x0f32390b, 0x60440f3c, 0xfadce29d, 0x080ccb61, 0x06d88220, 0x13f3fe08, 0xa9dc3960, 0x0cbdc936, 0x60185d07, 0xb3344318, 0xb337db37,
    0x1b012601, 0x415b7f01, 0x0001210c, 0x04330082, 0x00800580, 0x01000044, 0x2b040214, 0x35262201, 0x83060711, 0x013d25a2, 0x35013f34, 0x116f0b8b,
    0x011d2a05, 0x1d163625, 0x05071401, 0x23088715, 0x35003611, 0x04301c85, 0xbcfebd80, 0x120ea0bf, 0x0a0603d7, 0xe9170d09, 0x12210787, 0x2614820e,
    0x1a0f7701, 0x8677fe17, 0x01bc2206, 0x33158404, 0xfebfc002, 0x0e12bdbc, 0x01426302, 0x80100a06, 0x5d470817, 0xfa280988, 0x0e12120e, 0x140574b5,
    0x79211783, 0x2508875d, 0x010d19fe, 0x1b82be14, 0x82030021, 0x050021c2, 0x2324c383, 0x43003300, 0x1527c782, 0x21230614, 0x85061411, 0x08ac74cc,
    0xa1851120, 0x21111525, 0x4f131632, 0x79410e13, 0x80042a0f, 0xa0fe0e12, 0x0e400e12, 0xcf031912, 0x210c8209, 0x1d7e6001, 0x842f9020, 0x7efe2049,
    0x00351a2d, 0x00000400, 0x800880ff, 0x27000005, 0x3f002f00, 0x00005000, 0x20be8201, 0x05044f35, 0x34012e26, 0x35263736, 0x352dbe83, 0x21173233,
    0x1e17011e, 0x010e1402, 0x08028207, 0x141637a3, 0x34361707, 0x06210127, 0x0f062207, 0x010e0101, 0x3303012b, 0x13230332, 0x17163233, 0x33041e01,
    0x02262105, 0x809e6e6c, 0x07130d40, 0x3a4d4d3a, 0x400d1307, 0x046e9e80, 0x10812a59, 0x2d2d7a59, 0x8110597a, 0x3535062a, 0xfb444451, 0xd9f70355,
    0x1b7039ef, 0x1ae0fe1c, 0x5d602d59, 0x1d9d9d1d, 0x582e605d, 0x0420011a, 0x49322f0e, 0xfcc80124, 0xa0017409, 0x212f4040, 0x11021918, 0x19021118,
    0x402f2118, 0x03160740, 0x242c330f, 0x030f332c, 0x24fc0716, 0x301e2470, 0xd6fe3094, 0x18302a26, 0x314b8218, 0x01d00126, 0x26d001e0, 0x04e0fe1a,
    0x1519210d, 0x1f434050, 0x06803006, 0x00520000, 0x01000056, 0x14151632, 0x8217010f, 0x82062005, 0x012f22f6, 0x200a8905, 0x050d5007, 0x013f3623,
    0x200a8903, 0x05735227, 0x011f1623, 0x210a8925, 0xf4433637, 0x0f320805, 0x36371301, 0x05032501, 0x533eef05, 0x0738ac5d, 0x4d2f3b54, 0xcafe370f,
    0x3c540837, 0x370f4c2f, 0x3d151d99, 0x9c2c3751, 0x161a9c69, 0x2c37523c, 0x1885359d, 0x36013625, 0x83550836, 0x3525082c, 0x3c1615a2, 0x9d2c3c55,
    0xfc18a469, 0x693601fc, 0xf802cafe, 0x21613d51, 0x1a15a73b, 0x2d36563b, 0x18a46aa5, 0x24088317, 0x500935a3, 0x2554823d, 0x36390135, 0x5e835108,
    0x189f352a, 0x36553c17, 0xa069a02d, 0x37352283, 0x0637a12c, 0x492d3b4f, 0xc4fe360f, 0xfafe0838, 0x6b3b0169, 0x0c974600, 0x29000f24, 0x23624900,
    0x11012511, 0x010e0706, 0x3925f482, 0x2e272201, 0x26028301, 0x33161411, 0x42363221, 0x142e07c0, 0x011e1716, 0x32061e17, 0x2537053e, 0x4462013e,
    0x032c080b, 0x22211fe0, 0x426235c5, 0xbe2f6242, 0x0a2a0c2f, 0x40032838, 0x29373828, 0x3828c0fc, 0xb52f253d, 0x0e1c0327, 0x1518131c, 0x13181514,
    0x03240982, 0x3f230b01, 0x080d6b62, 0x01e0fb2a, 0x161423b4, 0x4545247e, 0x08207920, 0x4cfe0826, 0x02383828, 0x383a2965, 0x194f2528, 0x021a7220,
    0x09110913, 0x0a05050a, 0x13240682, 0x4f17ae02, 0x0023d682, 0x71000006, 0x053f067b, 0x47003f00, 0x61005100, 0x00007100, 0x01373413, 0x14010226,
    0x0307030e, 0x3e373601, 0x500f2601, 0x1e2405d3, 0x13011f01, 0x37081288, 0x36232622, 0x04323324, 0x06222317, 0x061e1415, 0x13051617, 0x23061716,
    0x16012722, 0x07021415, 0x34353613, 0x16042000, 0x06021012, 0x26242004, 0x36121002, 0x36242000, 0x26240f82, 0x06042024, 0x24080f82, 0x01437f16,
    0x05eec46f, 0x080f0508, 0xfe4c041b, 0x132a2eea, 0xcd13130e, 0x110c7f4b, 0x0c0f0306, 0xfea87850, 0x081386e8, 0x0a20072a, 0xc6530169, 0x690b0193,
    0x044a370a, 0x12060c04, 0x3f031607, 0x01ed06fe, 0x70817e04, 0x5f7b0369, 0x3bebafd0, 0x6c01a2fc, 0x07df8318, 0xfe94fe37, 0x8e8ef0b4, 0x015501f0,
    0xe53d015a, 0xfee58888, 0xfea6fec3, 0x080983c3, 0xa380022a, 0x5f13fc96, 0x08017401, 0x1c3c2713, 0x00ff0d5a, 0x05033a03, 0x011d2102, 0x0109010a,
    0x0e13120c, 0xb8fe0801, 0x400308fe, 0x29081587, 0x606abba0, 0x180c3751, 0x1e0f1b13, 0x6b05240c, 0x0679fdd3, 0x04202c05, 0xd1c3ae52, 0x02669ffe,
    0x2a6ba9a6, 0xf08e3402, 0x7888b4fe, 0x8c844c20, 0x88b7f925, 0x8e3d01e5, 0x46002083, 0x6308067b, 0x00060007, 0x1b001200, 0x11010000, 0x26242605,
    0x24363435, 0x04061537, 0x17041415, 0x25130111, 0x35272637, 0x3e041704, 0xfee4f0fe, 0x01c9d68c, 0xfed9d95d, 0xea3501e9, 0xfd25ad03, 0xa17793f3,
    0x06cc1501, 0x8000fa00, 0x92fda414, 0x1aa4f78c, 0x8fe026ac, 0x051ee698, 0xfe3ffe50, 0x4653727a, 0x7c21ac1d, 0x3e06c342, 0x06800700, 0x000c0000,
    0x00300026, 0x15010900, 0x23061423, 0x35262221, 0x21013523, 0x8a113311, 0x16322403, 0x8221011d, 0x013b2289, 0x300a8705, 0x03c00333, 0x1c2980c0,
    0x291c0afa, 0x01000180, 0x85048200, 0x1c3b2302, 0x1882f929, 0x82063b21, 0x82f82008, 0x00062e08, 0x1a8080fe, 0x801a2626, 0x00fd00ff, 0x26038a03,
    0x40401a26, 0x82c0261a, 0x861f8219, 0x092708ff, 0x00800500, 0x0036000d, 0x16130100, 0x24200406, 0x05133726, 0x00373216, 0x06010714, 0x0e252722,
    0x15160701, 0x7b130714, 0x1d820678, 0x35264508, 0x37363734, 0x37342625, 0x17323601, 0x12ee0601, 0xd6feac04, 0xd6fea4fe, 0x021204ac, 0x1634163e,
    0xfb165004, 0x040c04a0, 0x382b74fd, 0x3a3a3f06, 0x0f090a02, 0x0a090fc0, 0x413a3a02, 0xb3fe570b, 0x60041616, 0x04281e82, 0xfebc0260, 0x457645c4,
    0x01380282, 0x0707b53c, 0x082e1002, 0x0101a0fe, 0x659b22ce, 0x26454924, 0x0b0e4ffe, 0x0e320082, 0x4526b101, 0x7bcf2649, 0x082e0868, 0x01016001,
    0xff82a0fe, 0x80ff6d24, 0xd3629305, 0x13013505, 0x07222326, 0x02002613, 0x32331627, 0x12011e37, 0x37033e17, 0x3a080a83, 0x07030e31, 0x0d5b0306,
    0x40292b3e, 0xfffe280d, 0x323a5db0, 0x8d3f432c, 0x91252ac1, 0x362f785a, 0x1c3a3835, 0x0a4e2340, 0xfd430292, 0x020b0b3d, 0xc50145c3, 0x0f8b2801,
    0x82ed6f0f, 0xe93d2d99, 0x0e57cd93, 0x3a63270e, 0x00f81186, 0x00207382, 0xe12c7382, 0x23008005, 0x21010000, 0x02141516, 0x2705ef52, 0x24361210,
    0x07172033, 0x0e268582, 0x011e1001, 0x7e823233, 0x03212f08, 0x0cd50200, 0xdaaffeb6, 0xcee4fe9d, 0x01ce7979, 0x2c019d1c, 0xb77bd1d7, 0x8080db81,
    0x925781db, 0x0621465e, 0xee024cfe, 0xfed93d43, 0x2083c0ab, 0x013a0133, 0xc979ce1c, 0xdf8277c9, 0x82dff8fe, 0x525c4830, 0x339c1825, 0x0010280b,
    0x00220019, 0x825e004e, 0x0716297f, 0x26272006, 0x17323637, 0x362be883, 0x06142432, 0x34352622, 0x4a053236, 0x162e0671, 0x22263437, 0x13272607,
    0x32161417, 0x9c823436, 0x26270725, 0x83060307, 0x150624a6, 0x82171614, 0x33042904, 0x34352432, 0x24013e27, 0x080a2544, 0x04202422, 0x10470416,
    0xeefe3e10, 0x0610103e, 0x79300612, 0x12063178, 0x4a34d3fe, 0x014a3535, 0x344a35bf, 0xfb270982, 0x82246446, 0x82c83fb5, 0x25353b0a, 0x13dd1a36,
    0x81b44506, 0x46323423, 0x01061f25, 0x01c6c518, 0x241e0718, 0x8f436601, 0x71012d12, 0x3e3e0f10, 0x0606100f, 0xd4063131, 0x25244c82, 0x255a3426,
    0x27085383, 0x46315234, 0x01065a24, 0x34252d1b, 0x32354a35, 0xfe150531, 0x255a07c8, 0x3a233146, 0x8e1d1b0f, 0x208ecaca, 0xbb390f19, 0x230ee043,
    0x00f08e8e, 0x05200082, 0x2808bf4c, 0x0019000f, 0x00510023, 0x05274161, 0x27412220, 0x37322406, 0x41253236, 0x16210726, 0x2c098805, 0x23263437,
    0x27260722, 0x011e1737, 0x172a4133, 0x20056d7f, 0x11b76427, 0x0dab033a, 0x35ec350d, 0x10050d0d, 0x2ace2a05, 0xfefe1005, 0x2d2e3e2e, 0x52012d40,
    0x27080785, 0x2a2b3cd7, 0x369a711f, 0x1f2d01ab, 0x202d2d20, 0x11bd1530, 0x6f9a3c04, 0x3c2b2c1e, 0xf0051a20, 0x06f0aaa9, 0x33011f19, 0x0c364418,
    0x54829720, 0x06285382, 0x062a2a06, 0x2e2e1f96, 0x07863984, 0x3c2a4729, 0xf3044e1f, 0x822c2027, 0x2a2b3965, 0xf4fe1205, 0x3c204d06, 0x0d321e2a,
    0xad7a1719, 0x18197aad, 0xe401310d, 0x200bc44a, 0x081b4103, 0x30001e2d, 0x00003c00, 0x34353701, 0x62062226, 0x3d2405a5, 0x14152301, 0x1121e084,
    0x05e34d34, 0x82350521, 0x05a74e11, 0x82270721, 0x4d32201b, 0x03340ce6, 0xa0745a62, 0x1b261c74, 0x51527397, 0x13141b73, 0x9689011b, 0x5a260683,
    0x73a2743c, 0x4b575101, 0x022a080e, 0x4f3e1bb9, 0xfe4f6f70, 0x1b1b14e5, 0x527a7814, 0x01507172, 0x1c1c1318, 0x7adf3613, 0x1c1b147e, 0x1c1a7b13,
    0x7272507b, 0x6057ad01, 0x8202200f, 0x07a325b7, 0x005d0580, 0x0021b783, 0x2bb48801, 0x35262223, 0x14112111, 0x35363216, 0x0721b487, 0x83108205,
    0x113523b4, 0x1a853717, 0x3c26042a, 0xb1fc3c54, 0x4801fbb2, 0xfd2e0882, 0xc3fcb0af, 0x48018f01, 0xfcb1b2fb, 0x1182c383, 0x38032e08, 0x3c3c2a76,
    0xaf9cfd2a, 0x01b2fbf8, 0x2bfafe0a, 0x022b3b3b, 0xf4f2ab6c, 0xa13a88ac, 0xfbb2f6fe, 0x0c01b0f9, 0xf2fe3a3d, 0x2a3b3b2a, 0x0aaf4c00, 0x1d000d25,
    0x82250000, 0x22212382, 0x06831506, 0x2d123775, 0xfe40fdc0, 0x02835d20, 0x5de001c0, 0xdf414083, 0x01a02d0b, 0x83c002e0, 0xfd20fe5d, 0x1d048340,
    0x330c6e4c, 0x00000800, 0x00081a00, 0x0500e604, 0x0d000900, 0x19001100, 0x25266b82, 0x00002900, 0x69833301, 0x23011930, 0x33110111, 0x33150311,
    0x11211335, 0x01823521, 0x82112521, 0x340b8b13, 0xecfdcc48, 0x017b4801, 0xcdcdcd99, 0xfd150252, 0xfe4801eb, 0x221083b8, 0x8214029a, 0xfe472b19,
    0x7b4701b9, 0x29fce604, 0x1b82b902, 0x8ffe7122, 0x472e2382, 0x1e01b902, 0xe2fecccc, 0x52a352fc, 0x148401a4, 0x8d820a88, 0x32091f74, 0x00230013,
    0x00400030, 0x06140000, 0x11272223, 0x8a323336, 0x26102509, 0x06072223, 0x11260182, 0x33163537, 0x0f840232, 0x0c852320, 0x2910884f, 0x2b354c16,
    0x352a1c1b, 0x0886f5fe, 0xb07e0239, 0x1713147d, 0xd37c5737, 0xa77d4233, 0x434a7db1, 0x3d37d3ba, 0x6917037d, 0x442a0c44, 0x010f5a80, 0x51011115,
    0x07835b80, 0x0131fd30, 0x4e03be0c, 0xfd065f3a, 0x13ce2984, 0x0e826902, 0xb8fc2422, 0x01210a82, 0x0d5f41f8, 0x000a3508, 0x0709ff29, 0x000006cd,
    0x00bc0082, 0x00ce00ca, 0x00e300dc, 0x00e900e7, 0x00ef00ed, 0x1e360100, 0x021e1703, 0x07020e17, 0x0f23052e, 0x1e171601, 0x16011f07, 0x26200e82,
    0x2634ea83, 0x3e373435, 0x07262702, 0x2223010e, 0x2627012e, 0x22230427, 0x362d1482, 0x34262537, 0x3e37033e, 0x16323301, 0x07614b17, 0x82060221,
    0x353624ff, 0x82022e34, 0x82272036, 0x82272008, 0x051e2d19, 0x030e3717, 0x072e3717, 0x2a022e27, 0x072e4682, 0x1e37053e, 0x15013f02, 0x3e373617,
    0xb3643f08, 0x24708205, 0x1415011e, 0x82508303, 0x23063391, 0x37012722, 0x16010717, 0x030e1415, 0x023e2707, 0x05820133, 0x13216d82, 0x08158233,
    0x0f1535e5, 0x04023f01, 0x63894bc6, 0x212b4167, 0x30453c5b, 0x2c249c79, 0x2e271b3c, 0x060a4963, 0x2c060904, 0x12051f07, 0x01010603, 0x11080701,
    0x20842303, 0x03022127, 0x01373b02, 0x97241318, 0x7065193d, 0xfe15061c, 0x18101f1e, 0xe6010e11, 0x13150b08, 0x1704051b, 0x071a0f06, 0x191109a3,
    0x01b60f11, 0x2f16a501, 0x2f372f90, 0x052b440a, 0x372c3e52, 0x0a15142a, 0x03320c18, 0x01232d28, 0x0711053d, 0x070a060e, 0x0f070409, 0x0e2f121a,
    0x28105b7e, 0x471d3f44, 0x20200c08, 0xf7160c16, 0x292c1c7c, 0x230e2219, 0x07082b0b, 0xfc4f2902, 0x2c380eb4, 0xf72b0311, 0x0936b927, 0x19171d1b,
    0x3d7b7902, 0x30f9fe40, 0xa101496d, 0x33392303, 0x15070438, 0xfe1c414f, 0x0a066045, 0xd3130c2d, 0x03290a1f, 0x83020179, 0x5fd50801, 0x77462f03,
    0x6a384861, 0x371e3d37, 0x9c25103f, 0x6195bcad, 0x09050402, 0x1d072505, 0x25191e0c, 0x3f1a2116, 0x010f4c29, 0x1f100a15, 0x390d164a, 0x1a02153d,
    0x997e5d35, 0x701a0414, 0x170f1016, 0x160e6a03, 0x05040a0d, 0x200d0102, 0x11162511, 0x2803160f, 0xa0b71a10, 0x03222431, 0x12101814, 0x1a492c13,
    0x0e031020, 0x401f240d, 0x2828191c, 0xd60f0b02, 0x0f081505, 0x05050a06, 0x01040302, 0x1a211e2b, 0x09531b2e, 0x011c2d09, 0x5f014c01, 0x2724155f,
    0x39112d17, 0x090f4c13, 0xc6a55635, 0x0a09032b, 0x07361309, 0x1a54fc0b, 0x2e361f2b, 0x0b2d0538, 0xb10c2403, 0x0fd0fe30, 0x0b0f0701, 0x2b010708,
    0x02070d02, 0x01111474, 0x537cfd0c, 0x0131060c, 0x35598401, 0x00040000, 0x0612ff00, 0x00ee0500, 0x00360017, 0x0083005d, 0x6a420500, 0x26273105,
    0x0e072223, 0x011e1701, 0x023e3736, 0x26273637, 0x06201184, 0x23065267, 0x1e323307, 0x372d1c83, 0x2e340136, 0x0e222302, 0x2e062301, 0x82308203,
    0x011e2a1f, 0x023e3233, 0x17031e17, 0x223b8216, 0x4c143701, 0x352b0611, 0x37053e34, 0x3e37033e, 0x4d163701, 0xfe08051f, 0x13058f04, 0x814a721e,
    0x0b080540, 0x0801070f, 0x32626b22, 0x072b5729, 0x14132c0c, 0x182f3517, 0x0e1a311d, 0x03171109, 0x090e060f, 0x0b130e10, 0x080b231b, 0x170a050a,
    0x170a5a01, 0x80211e2d, 0x491b2482, 0x3770584f, 0x0202a473, 0x46431d4c, 0x7a769639, 0x414e1a20, 0x2f231447, 0x351d1c20, 0xebfed07c, 0xe6fed0fe,
    0x3b2780d5, 0x2f524b52, 0x234a0e13, 0x2c241e3d, 0x2c398108, 0x24152bac, 0x37534355, 0x0e133227, 0x04312216, 0x0a14060c, 0x03031c20, 0x071b2104,
    0x0e2f840c, 0x2c0c0a0f, 0x07081418, 0x040d0214, 0x0306040a, 0x0f0e0f02, 0x0c040611, 0x2d162f01, 0x54531c2d, 0x3a3a2801, 0x9b010128, 0x14347065,
    0x404d4111, 0x493d0101, 0x2203013e, 0xce78292e, 0xbfe7fea4, 0x01c7736c, 0xa759a01c, 0x404b717c, 0x25080a1d, 0x1c182814, 0x269b5159, 0x0d1b4e1d,
    0x76484518, 0x4100ab7e, 0x4f5e057f, 0x001e2f05, 0x005a003c, 0x01000078, 0x010e020f, 0xde7c0e27, 0x37340806, 0x013f3626, 0x14060717, 0x3f321617,
    0x07170303, 0x06222627, 0x07031f14, 0x012e022f, 0x35012e37, 0x32333634, 0x16361716, 0x23061401, 0x06272622, 0x37012f26, 0x23082b82, 0x032f3436,
    0x1e021f37, 0x011e0701, 0x07061403, 0x010f0616, 0x34363727, 0x030f2226, 0x3e023f27, 0x013e1701, 0x43083882, 0x97a02e04, 0x55ad411e, 0x55497010,
    0x16455978, 0x970c412e, 0x2525250b, 0x971e2568, 0x980cbea1, 0x4a68250c, 0xa0981d25, 0x1e97a197, 0x461b2c44, 0x4c55785a, 0xab540c73, 0x55786703,
    0x560e724a, 0x970b44bb, 0x1e222384, 0x0182a098, 0x2f401d2c, 0x02654c15, 0x2e1a4c66, 0x18820c43, 0x47824a20, 0x24081682, 0x431d98a1, 0x730b56b8,
    0x0178554e, 0x1e98a0cf, 0x46152e40, 0x4855795a, 0xae561070, 0x0b980c41, 0x25266825, 0x21418225, 0x71831202, 0x83694a21, 0x24368271, 0x57b9431e,
    0x2d98820f, 0x144a6279, 0x5595fb2f, 0x1c475e79, 0x2284442c, 0x4a835785, 0x0b55ad2b, 0x4d170473, 0xb7550b74, 0x82af8643, 0x2c3d8449, 0x664b1a2d,
    0x08000079, 0x00ff0000, 0x08018206, 0x00450026, 0x005b0058, 0x0067005f, 0x0089006a, 0x010000a3, 0x012f2606, 0x012e2726, 0x06070627, 0x27010e07,
    0x013e3736, 0x26260283, 0x07020e07, 0x14821406, 0x26270622, 0x15820182, 0x36373623, 0x27068233, 0x1617023e, 0x010e1407, 0x17221a82, 0x0282011e,
    0x82160321, 0x2306210a, 0x37222583, 0x2582011e, 0x05323736, 0x25012717, 0x17010511, 0x17032703, 0x05011737, 0x07170111, 0x2b226283, 0x27822201,
    0x36343522, 0x21063d43, 0x70823233, 0x0137022c, 0x04062511, 0x34272223, 0x3f831127, 0x37365809, 0x2c320511, 0x15323301, 0x018e0211, 0x2c141417,
    0x0444072b, 0x18514343, 0x06031f04, 0x0e81154c, 0x08024411, 0x1e270866, 0x05010202, 0x1218171a, 0x0601040a, 0x2f3a0b25, 0x420a0264, 0x0419090b,
    0x19030204, 0x3419031c, 0x057d0c40, 0x03cf0d04, 0x1e260c07, 0x0e171a1e, 0x21030104, 0x13243014, 0x3fbe0211, 0x02f8fb8b, 0x044afdb6, 0x64b566d9,
    0xd32d66d8, 0x3d022efe, 0x369efafe, 0x3a928228, 0xf14f5421, 0x080a083f, 0x04211c04, 0x5f47ad49, 0x1f0f5590, 0x95010a25, 0xfd0efafc, 0x050d072e,
    0x05010301, 0x022a6b0f, 0x3d01022e, 0x14043b01, 0x0703ca01, 0x1d140908, 0x67023505, 0x020f5f4e, 0x58040204, 0x1e1bb618, 0x22010989, 0x01080b02,
    0x0a011102, 0x04070705, 0x02110611, 0x10100306, 0x04230223, 0x01010a03, 0x3202150c, 0x51320539, 0x0234061c, 0xe0013101, 0x0f170d0f, 0x0f17030c,
    0x0403031a, 0x020c0e04, 0xfd2ae392, 0x0804e899, 0x1f36fde9, 0xfd1f9102, 0x416e1fe8, 0x01b83b03, 0x0d11fa7c, 0x195342a0, 0x072e4e0c, 0x0f0b0809,
    0x31250212, 0x1107241d, 0x80040615, 0x06f6c9fb, 0x02010df3, 0x01093604, 0x0e240506, 0x6ec68001, 0x5efe156b, 0x50000c00, 0x0f3607ff, 0x37002700,
    0x57004700, 0x77006700, 0x97008700, 0xb700a700, 0xe951c000, 0x05a35408, 0x33363424, 0x5c181e05, 0x33250cb2, 0x1f163221, 0x23138201, 0x26343501,
    0x06282482, 0x1614011d, 0x3632013b, 0x1fb92719, 0x13212fdf, 0x05e25911, 0x20011127, 0x425e5e42, 0x29048380, 0x463ae005, 0xa0fc6a96, 0x0b195e42,
    0xfd2609e8, 0x800e1220, 0x0498120e, 0x98000121, 0x9f18841a, 0xa0602b1f, 0x80fd3828, 0x425e8004, 0x8383c0fb, 0x42400439, 0x7622a35e, 0x6a00fd45,
    0x06425e96, 0x28382800, 0x601c981c, 0x8880fb28, 0x89012085, 0x200a8a90, 0xab1594fe, 0x8e013920, 0x28380001, 0x0000fea0, 0xff000014, 0x06800500,
    0x000f0000, 0x002f001f, 0x0ff72919, 0x8818bf20, 0x2f220cef, 0x07423f01, 0x21232908, 0x11352622, 0x01333634, 0x08418318, 0x2005f741, 0x200fae11,
    0x2e2f4203, 0x82234f42, 0x1d06229c, 0x06775401, 0x9f425fbe, 0x269f9f2f, 0x261a4005, 0x62fb1a26, 0xc02005a5, 0x09826018, 0x8020099d, 0x1d931e9d,
    0x18000221, 0x200a9968, 0x93219312, 0x82012013, 0x0e402135, 0x42842ea8, 0xb4180620, 0xfe210c2c, 0x213f88e0, 0x0a9ff2fe, 0x2088b220, 0x15024918,
    0xfb211595, 0x4e45180e, 0x0e022108, 0xfc2041a9, 0x788a2baa, 0x0000003b, 0xff400002, 0x05c00410, 0x001f0060, 0x09000027, 0x06141101, 0x11352622,
    0x24078623, 0x37342601, 0x062c6436, 0x14161723, 0x06f75124, 0xfea40423, 0x065b67dc, 0xdcfe2308, 0x4f1d1c1c, 0x7001e41c, 0x1c501ce4, 0x83a0fe1c,
    0xba8383ba, 0xdcfedc03, 0x422ec8fc, 0x80012e42, 0x078380fe, 0x01380323, 0x22208324, 0x83e4e41c, 0x67e52030, 0x4f51055b, 0x05803005, 0x000f0080,
    0x0033001d, 0x00510043, 0x4c140100, 0x352c05f7, 0x33013e34, 0x01011e32, 0x22230614, 0x2e06f648, 0x3205011e, 0x14151204, 0x2223020e, 0x82222326,
    0x21258218, 0x1e842502, 0x1b822d85, 0x32250123, 0x82068316, 0x281d8222, 0x260c0301, 0x7c4c3d58, 0x2905823c, 0xfe3c7b4d, 0x4c4d54aa, 0x04844683,
    0x768a013b, 0x22b81201, 0x442b423f, 0xfd423fef, 0xa770b74a, 0x3d4801d0, 0x7b3c2658, 0x2705834d, 0x4d64017c, 0x4c834654, 0x04270483, 0x4e6b3c28,
    0x83499c73, 0x9b220805, 0x7650d3fd, 0x504a9c6f, 0x2f9d6f77, 0x73e9fec3, 0x0b1d3d2e, 0x5692595a, 0xd376aed3, 0x4a3c6b4e, 0x0582739b, 0x739c4930,
    0x4a507768, 0x50766f9c, 0x006f9d4a, 0xe1180001, 0x152007ab, 0x062ae383, 0x06161307, 0x2622012b, 0xdb831337, 0x82013e21, 0x022908e9, 0x2d5f72c0,
    0xc01a2402, 0x2d02241a, 0x9655725f, 0x035596aa, 0x25c591f0, 0x261acbfc, 0x35031a26, 0x8091c525, 0xf39d9df3, 0x08008200, 0x00000322, 0x800600ff,
    0x03008005, 0x1f000700, 0x01050000, 0x2d270511, 0x11010d01, 0x01070614, 0x01272206, 0x11225882, 0x44553634, 0x1e4c0805, 0x02800301, 0x4080fd80,
    0x46fdba02, 0xfa0546fd, 0x40fd1f24, 0xfd1c421c, 0x2e241f40, 0x16c00226, 0xc002162c, 0x015d2e26, 0xe97c025d, 0xfefefe71, 0x2300fd02, 0x80fe113c,
    0x80011010, 0x03233c11, 0x0e422800, 0x08080001, 0x420e00ff, 0x73827e82, 0x08237f82, 0x84000680, 0x000b277f, 0x0013000f, 0x1a820017, 0x84250521,
    0x01052187, 0x27200786, 0x97840786, 0x97820520, 0x27262524, 0x08840706, 0x2520a086, 0x2528a583, 0x05173236, 0x1115011e, 0x022e0482, 0xfe800180,
    0x94014080, 0x6cfe6cfe, 0x0c8ad405, 0x0b852c20, 0x47feb933, 0xf90547fe, 0x40fe2126, 0xfe194019, 0x02030440, 0x250a8605, 0x232b2621, 0x0382b201,
    0x3617c036, 0x23c00117, 0x24b2012b, 0x01c0602a, 0xad70a43a, 0x8dfdadad, 0x78340987, 0xa40a01a5, 0xbdbdbd70, 0x60fe3dfd, 0xe0103e24, 0x02e00e0e,
    0x07830082, 0x243e102a, 0x4026a001, 0x9001ba10, 0xc0360582, 0x10c00a0a, 0x70fe2640, 0x004010ba, 0x00000600, 0x0008feff, 0xf7820205, 0x00092208,
    0x0026001f, 0x0041002e, 0x15210100, 0x06220321, 0x03262107, 0x33373632, 0x02222102, 0x33003435, 0x2fd18232, 0x14210714, 0x32212516, 0x21233435,
    0x36322135, 0x0e820783, 0x15021e24, 0x1e830714, 0x030e7a08, 0x38072123, 0xff0101fe, 0x06705afc, 0xa6129801, 0xdd11763f, 0xd6b9fe64, 0xce0501fd,
    0x0265cd8a, 0xfb736efd, 0xcd280136, 0x01d2fec7, 0xbe5b4e19, 0xebfefcfe, 0x88575202, 0x72ac3f75, 0x72533174, 0x9dfd4680, 0xfe7cad04, 0xc35a69d2,
    0x3740b7fd, 0x0801cdfe, 0x1301d0d7, 0x1189de88, 0x32796f1e, 0x49beb4a7, 0x1cd7904d, 0xb55b7e43, 0x79a62052, 0x3a547b4b, 0x0000001a, 0x08b35307,
    0x1e000f26, 0x2c002500, 0x4722c982, 0x0d474b00, 0x21132211, 0x20b88411, 0x28bc8227, 0x2303022e, 0x15323335, 0x24068614, 0x35262205, 0x22178221,
    0x6e222326, 0x372d0595, 0x03010e23, 0x3e231732, 0x15210301, 0x0b095b21, 0xfed33008, 0x757e018d, 0x276b8fa0, 0xb04d544a, 0xb96177a3, 0x0a027cbd,
    0x9b014844, 0x80819501, 0xcd869ea4, 0x490b8a3e, 0xfe0b7131, 0x016a4604, 0x5bc1fe3f, 0x2d080d05, 0xedfc91fe, 0x2a9e7173, 0x4f397034, 0xc2fe112a,
    0xfe5e5ab8, 0x6871d9b1, 0x0a454c20, 0xacb18414, 0xbfa48782, 0x6e012822, 0x0142387a, 0x6b4d4d0a, 0x00072307, 0xe9828005, 0x27001b24, 0x13823f00,
    0x2106c344, 0xaf823400, 0x1e170722, 0x25067f66, 0x33011e27, 0x13830132, 0x5b08c385, 0x00143736, 0x010e0123, 0x2f262223, 0x36051101, 0x01173233,
    0x32330036, 0x8f2e0600, 0xca8f8fca, 0x68928dfd, 0x4d681b1b, 0x981f1f41, 0x1452154c, 0x68477620, 0x7eb3d003, 0x7fb3b37f, 0xfe96b37e, 0x4bfebcf5,
    0x7984c20c, 0x01e619ba, 0x0d5e4f85, 0x021c0116, 0xbcbb0b01, 0x1f040b01, 0x8f353f83, 0x92d0befb, 0x971f2a06, 0x1f404d4c, 0x3c082108, 0x7edf0349,
    0x383f82b3, 0xbd7fb2b2, 0xc1fef6fe, 0x7498b281, 0x9dad015c, 0x97010230, 0xfe0801bb, 0x21ba82f5, 0xaf410400, 0x00082508, 0x0043001b, 0x3422e383,
    0xb2832226, 0x27051c53, 0x17162726, 0x36373616, 0xb282b482, 0x59110121, 0x3d2105ff, 0x05765601, 0x32253722, 0x2106a741, 0xfd830307, 0x34112528,
    0x32213336, 0x13410316, 0x32333e05, 0x72da0416, 0xa07171a0, 0x527410fe, 0x34195e38, 0x19783c2e, 0x523d3318, 0x03521416, 0x051a53fc, 0x14ac3408,
    0x9a685f93, 0x9659010a, 0x9496d3d3, 0x09e102d2, 0xfe3e4b13, 0x0377a9d7, 0xf7a977c0, 0x8d8dc88e, 0x038d6564, 0x7271a029, 0xfe71504f, 0x3a73a6c8,
    0x82141430, 0x783c2643, 0x02052118, 0x0527536d, 0x45996808, 0x678c785c, 0x9695d3fc, 0xfe94d1d3, 0x772501be, 0xa977d401, 0x64a0fea9, 0x8ec88d8d,
    0x0006008d, 0x0656ff10, 0x00ff05ef, 0x001e000d, 0x003c002d, 0x005c004b, 0x07030100, 0x27012e25, 0x023e012e, 0x011b1637, 0x0f030e27, 0x012e0301,
    0x3736013f, 0x0e030127, 0x06010f01, 0x13031707, 0x37361617, 0x25030601, 0x823e1327, 0x010529f8, 0x07061613, 0x2607050e, 0xe8081182, 0x37250337,
    0x012f032e, 0x1f163605, 0x44031601, 0x5cfe020f, 0x0b103e24, 0x22090f07, 0xb42c4e02, 0x30613f93, 0xbe04031f, 0x08070211, 0x068c4f23, 0x310cbc80,
    0x94471213, 0x07d3e608, 0xfd39e2aa, 0xfeda2f27, 0x14e113c3, 0x31182850, 0x30183023, 0x12d49702, 0x280d160b, 0x46213d24, 0x01e7220b, 0xdc8e7c39,
    0x22975dfe, 0x113c4552, 0x1f950111, 0x270b0c36, 0x90fe6f01, 0x39031d16, 0x4a381b25, 0x0c075c24, 0x85fe3a02, 0x6991485c, 0x01151554, 0x113c1a65,
    0x567d3f12, 0x99feeafd, 0x0403231d, 0x01a40507, 0xad6a016f, 0x03161610, 0x8cfe3fb2, 0x64010cbb, 0x02041c1f, 0x192c1614, 0xfec5fe36, 0x234e2595,
    0x16162214, 0x4803120a, 0xedc36c01, 0x148bfe53, 0x5d9a5956, 0x010d0d43, 0x0f0f1b03, 0x0400003d, 0x40ff0000, 0x05f34208, 0x19001124, 0x42184300,
    0x1327092d, 0x012e0321, 0x18222123, 0x220a3e8e, 0x7a061411, 0x21280838, 0x22061415, 0x23013d26, 0x0805024b, 0x13013b22, 0x2133013e, 0x13171632,
    0x01163233, 0x5e845ee0, 0x0382845e, 0x180259f8, 0x0900fd09, 0x03050218, 0xfe281284, 0x70600e12, 0x00fc70a0, 0x60340482, 0x5d83120e, 0xa217691c,
    0x62000362, 0x1c6917a2, 0x7e01835d, 0x5e2a3783, 0x6501e001, 0x08131308, 0x0e8519fd, 0x80fe002a, 0x5080120e, 0x80507070, 0x12230585, 0x8280010e,
    0x5ea3272d, 0xfe5e7f7f, 0xc784835d, 0x0008002c, 0x33000006, 0x45003b00, 0x95444d00, 0x21b09c08, 0x5167013b, 0x011d2106, 0x1722b582, 0x2f7b0013,
    0x89012006, 0x231186fb, 0x835d2007, 0x8020ba94, 0xc0208a82, 0xc0839c82, 0x85faf921, 0x8a6420ae, 0x210421f7, 0x02231384, 0x835d8380, 0x834020c4,
    0x854020c4, 0x25c48905, 0x12120ee0, 0xca83e00e, 0x5e20fe22, 0x01212f83, 0x05004182, 0x84bbfc21, 0x0100270e, 0x00ff2000, 0xdf84e005, 0x14240028,
    0x1e212306, 0xaf431501, 0x27c18205, 0x26222137, 0x23013734, 0x3628058a, 0x16011732, 0x012b0614, 0x05370586, 0xfe1a26e0, 0x240a0132, 0x19c0fe19,
    0xfe010a24, 0x13261a32, 0x84e59201, 0x83c52005, 0x13802b05, 0x80011334, 0xc51a2613, 0x05829201, 0x9201e530, 0x1126345a, 0x2319268d, 0x8d261923,
    0x1d822611, 0x04889320, 0x13138023, 0x243082fe, 0x136dfe26, 0x44048234, 0x152a0a6b, 0x44002b00, 0x00005000, 0x10543401, 0x14152e05, 0x37323316,
    0x17323336, 0x36323316, 0x22158237, 0x45072221, 0x15820537, 0x15842020, 0x15821320, 0x22232424, 0xd4820e07, 0x04202d86, 0x3e211883, 0x0bcc6701,
    0x1e674008, 0x9a85fec1, 0x05161b2a, 0xe26f8420, 0x130e13ab, 0xed23601c, 0x9699c9fe, 0x07192330, 0x01817a1e, 0x0e18d117, 0x286c2319, 0xb0b2fe7e,
    0x1f17a0cc, 0x1d0b1f29, 0x019fae85, 0x1315672d, 0x5acd2b1d, 0x2f080e07, 0x13204601, 0x2b092273, 0x1b081d14, 0xec1b0b67, 0x2a8d1528, 0x2319330d,
    0x0d7c2108, 0x2f110123, 0x2f4b4917, 0x1f1e2507, 0x4425082a, 0x5b290c3d, 0x390e0c5a, 0xff000001, 0x06000480, 0x00130000, 0x17010900, 0x07211121,
    0x11210703, 0x09822701, 0x37133738, 0xfe000421, 0x170118d1, 0x8e2c05fe, 0x01d3fe1e, 0xe9fe182f, 0x0b82fb01, 0x042d013b, 0x1fbafdd1, 0xfe1e61fe,
    0x2f011eef, 0x011e4702, 0x11011e9f, 0x0000001e, 0x08038211, 0x00098c37, 0x0e007404, 0x2f002500, 0x3c003b00, 0x54004800, 0x63006200, 0x7f007100,
    0x90008d00, 0xac009e00, 0xd400c000, 0x37250000, 0x23012e03, 0x03150622, 0x33011e17, 0x3e0e8232, 0x22262734, 0x07150607, 0x15171403, 0x33161714,
    0x35363732, 0x06071701, 0x37012f22, 0x82373236, 0x22232d09, 0x34372735, 0x03013233, 0x23140717, 0x33251784, 0x07011f32, 0x85188706, 0x8326200b,
    0x33362725, 0x13010932, 0x1b821407, 0x13012f22, 0x16210d82, 0x850d8f37, 0x8334201a, 0x3901231b, 0x1e830301, 0x82262221, 0x3634242c, 0x88171632,
    0x013e280d, 0x07131632, 0x82061431, 0x1302231b, 0x0d423635, 0x01172105, 0x21255982, 0x1135012e, 0x21108334, 0x45831700, 0x10034d08, 0x0d011010,
    0x0e0e090a, 0x090d010e, 0x0b2a0116, 0x10080d0c, 0x0a010d08, 0x0e09060b, 0xfb09090b, 0x021414ec, 0x1111020e, 0x1a580e02, 0x0908021a, 0x08091717,
    0x19bc1a01, 0x020a0b19, 0x0a021515, 0x17175e0b, 0x150d0c02, 0x600c0d15, 0x0e3c0f82, 0x14140906, 0x010e0609, 0x15dffe81, 0x10070a15, 0x02121202,
    0x5e0a0710, 0x080b1313, 0x0f820982, 0x620b0822, 0x02091382, 0x10021314, 0x09080d10, 0xc689010c, 0x140f0f0f, 0x0e0e010e, 0x630f140f, 0x16100e0e,
    0x0c0c0110, 0x0f161001, 0x1a120ed5, 0x06060112, 0x090a020c, 0x0e07080b, 0xa6660402, 0x0deefc75, 0x60551c12, 0x111e01c3, 0xa6753935, 0x0b02f1a4,
    0x0a0e0e0a, 0x0af1f5fd, 0x02d3340d, 0x0508104a, 0x06100805, 0xeb01bdfd, 0x0b070a01, 0x010d0709, 0x097e806c, 0x09807e09, 0x09cbcf46, 0x09cfca0a,
    0xeb0132fe, 0x0b0bedf5, 0x050cf5ed, 0x0d0df4fc, 0x1f0dfcf4, 0x0910f6ea, 0x06eaf607, 0x0216fe09, 0xf684fe6d, 0xf6120b07, 0x0b127c01, 0xf42cfe4f,
    0xf4130b08, 0x0b13d401, 0xf206fe20, 0x01f21515, 0x0d0d09fa, 0xea0211fd, 0x0aef02fe, 0xef0b0e0f, 0x0e0bfe01, 0x14fe1e0e, 0x10100bec, 0xec01ec0b,
    0xfe10100c, 0x120de708, 0x75720d12, 0x0f037c02, 0x08050709, 0x7594fd12, 0x0d1202a5, 0x0a178303, 0xc0f9fe22, 0x4600a616, 0x0021050f, 0x27018206,
    0x1b000d00, 0x39002900, 0x202d1382, 0x14153724, 0x24200406, 0x16013d26, 0x230d9c00, 0x011d1604, 0x34332a87, 0x01130236, 0x779c01da, 0xfe9efece,
    0xce9efe60, 0x9e9c0177, 0x01b9250f, 0xce6201a0, 0xce282f87, 0x54560003, 0x457645aa, 0xaa230282, 0x8aaafc54, 0x2a01210c, 0x04210c8a, 0x2020822a,
    0x82278580, 0x0acf5506, 0x1a001331, 0x5e002300, 0x74006300, 0x87007f00, 0x53010000, 0x172a11af, 0x26211107, 0x01260127, 0xc25d2111, 0x16012c05,
    0x32333617, 0x14071617, 0x57150706, 0x07350533, 0x2f222302, 0x26272601, 0x37013e37, 0x15161736, 0x37363736, 0x210a822e, 0x2883023b, 0x82070621,
    0x2a0482f6, 0x0e373601, 0x17060101, 0x82343736, 0x3526211f, 0x27230182, 0x83030714, 0x26272d2a, 0x06070627, 0x16232605, 0x34373233, 0x20ee9b18,
    0xfe025e08, 0x3a3b3321, 0x0e101e93, 0x41060102, 0xdd3f8630, 0x0f5999ab, 0x0501180d, 0x5e09040a, 0x02090e55, 0x24443734, 0x0b0d0d18, 0x1701151f,
    0x0209120c, 0x0c020102, 0x341bfe37, 0x01493355, 0x010d0f81, 0x03010706, 0x0c010101, 0x95877c01, 0x4c051602, 0x1e381b33, 0x74187702, 0x040e304c,
    0x269c1804, 0x02430821, 0x071e1a51, 0x011e1631, 0x26010102, 0x3b182128, 0x0c07fafe, 0x1a0a0401, 0x092d6728, 0x5502020f, 0x527e8870, 0x0f28329b,
    0x02062f15, 0x7b1e0503, 0x1bfea445, 0x58288618, 0x5a2a7a03, 0x28032507, 0x82010404, 0x0e16353b, 0x69fd0101, 0x11011b36, 0x566d4305, 0x180b386f,
    0x0001011c, 0x410c6742, 0x542005a3, 0x2e259b41, 0x13331513, 0x37361333, 0x17333536, 0x8217011e, 0x3533350b, 0x03331521, 0x23010f06, 0x35012e34,
    0x0327012e, 0x010e0323, 0x27250e82, 0x33032726, 0x20694135, 0xa4466938, 0x0307809f, 0x01030402, 0x9f800305, 0xd4fe46a4, 0x0205635a, 0xbd820402,
    0x9002062e, 0x05029072, 0x02040401, 0x5a630502, 0x08223641, 0x6b80032e, 0xe5016bfd, 0x08101a14, 0x09220318, 0x95021bfe, 0x4afe6b6b, 0x03151a14,
    0x05020907, 0x21020920, 0x1f09dffd, 0x1a151506, 0x6bb60114, 0x410b6f43, 0x53200507, 0x30250741, 0x35211525, 0x023e3723, 0x1716013b, 0x011f021e,
    0x270f8323, 0x35331303, 0x07331521, 0x2624fe84, 0x012f2627, 0x13210f84, 0x20044103, 0x012d0128, 0x05674b19, 0xf482050a, 0x02042008, 0x6b030705,
    0x4423014c, 0xfe43c3c0, 0x04674ae9, 0x0202030c, 0x0b060401, 0xdefe4c6a, 0x41c2bd44, 0xea3a2206, 0x07a16a6a, 0x06040813, 0x04090704, 0x016a6aa1,
    0x6b1a0111, 0x13079f6b, 0x47820304, 0x6b9f0c28, 0xfef0fe6b, 0x008200e5, 0x00000523, 0x056f44ff, 0x3822ff85, 0x01414300, 0x3335272a, 0x013e3732,
    0xec823435, 0xf9822320, 0x2301112b, 0x17323311, 0x07141516, 0x38f3a106, 0x5d470120, 0x432a4c89, 0x303f4a4f, 0x5c90fe52, 0x78770501, 0x3e381f34,
    0x35e0a51f, 0x80170fa7, 0x1b785152, 0xd5fd6b13, 0x0c011801, 0x59522112, 0xd3930f1f, 0x32002a22, 0x012ed3a5, 0x37352111, 0x22040117, 0x32363426,
    0xc2a01416, 0xfc80042e, 0x0180c000, 0xa050fe80, 0x70a07070, 0x0124b7a2, 0xc0c0fec0, 0x80203283, 0x70242f82, 0x090000a0, 0x30087f41, 0x00070003,
    0x000f000b, 0x002a0023, 0x004a0037, 0x27b38252, 0x05152335, 0x011d2335, 0x15200785, 0x39213d45, 0x35231523, 0x13011121, 0x06141516, 0x34352622,
    0x35133637, 0x32331533, 0x464b0216, 0x80022406, 0x84000180, 0x03380803, 0x38281c3c, 0x28c0fa28, 0x03283838, 0x1c602880, 0x0a780184, 0x0cc7fe0c,
    0x60fe6301, 0x80803828, 0x8d0200fe, 0xde91086b, 0x63150891, 0x22164f80, 0x4b4b6abc, 0x80044b6a, 0x0120008a, 0x3d1fc844, 0x00fa8080, 0xa3fed102,
    0x6d53191b, 0x1b19536d, 0x804d013f, 0x1afe1a80, 0x26263426, 0x00820034, 0x7f420620, 0x0039240e, 0x415e004c, 0x162926ad, 0x07141115, 0x2f222306,
    0x70621801, 0x36373508, 0x36373201, 0x012e2710, 0x17010e07, 0x06071016, 0x27161716, 0x34201282, 0x11831282, 0x11823082, 0x0820d941, 0x14ec0132,
    0x0c040814, 0x0e83a60b, 0x830e1212, 0xb40110a6, 0x8181131f, 0x15143610, 0x64641105, 0x12150511, 0x57141bbd, 0x26361257, 0x34341302, 0x14130213,
    0x0822fd41, 0x082e0337, 0x16e0fd16, 0xa7090208, 0x0ec00e12, 0xfd0fa712, 0x019f1847, 0x06159f98, 0x15351111, 0x7bc2fe7b, 0x0f103515, 0xfc5d1494,
    0x2402135d, 0x94391435, 0x12351439, 0x12a74311, 0x4705b36f, 0x3222234d, 0x58501516, 0x11352506, 0x05333634, 0x26073541, 0x01350127, 0x41323336,
    0x0226200a, 0x4c4c3480, 0x0584fe34, 0x146c032c, 0x0e040814, 0x01f7fe09, 0xc7460909, 0x80032124, 0x01203b87, 0x02204182, 0xc020ff82, 0x0125ff83,
    0x0a015a0a, 0x12ff4109, 0x4b003724, 0xff415b00, 0x3e260826, 0x1e011f01, 0x17010f01, 0x010f0616, 0x03272606, 0x16213726, 0x010e0307, 0x012e012f,
    0x2627013f, 0x36013f36, 0x0c821716, 0x85133721, 0x201c832b, 0x2cf1a027, 0x1a086001, 0x030b330b, 0x08b6b608, 0x23088203, 0x0ee2081a, 0x0e22ec82,
    0x178fe20e, 0x0d76fe29, 0x028a020f, 0x863f0d16, 0x23044207, 0x59828020, 0x49822620, 0x0bf3f325, 0x8226081a, 0x2d012261, 0x21008213, 0x178fd3fe,
    0x8206fd21, 0x83032059, 0x820a205a, 0xc1fc2108, 0x28086382, 0x27000100, 0xd90597ff, 0x36000006, 0x15010000, 0x02062306, 0x27060706, 0x010a042e,
    0x1a162127, 0x36171601, 0x35022637, 0x056f6434, 0x010e0726, 0x27012e22, 0x080bee53, 0x65d90565, 0xa2c94161, 0x1c52502f, 0x73646941, 0x011b5760,
    0x79581a1b, 0x76a94f7a, 0xb4d0a28e, 0x073abeb2, 0x413b4319, 0x323a1f12, 0xa2d24035, 0xc6c5023e, 0xf2fe8817, 0x302d1aa1, 0x8f723511, 0x010701e1,
    0xfedacf6e, 0xc6effe97, 0x48eda960, 0xc0b92801, 0x9fc0d3f5, 0x0c04017f, 0x51672027, 0x5b635a57, 0x4a00d7ba, 0x07250503, 0x00000600, 0x08048203,
    0x0e000a28, 0x15001200, 0x2d001900, 0x01130000, 0x37052511, 0x25010927, 0x012d2705, 0x11252705, 0x11170109, 0x11012505, 0x646c1105, 0x26013605,
    0x37341135, 0x17323601, 0x02d81601, 0xfeb2fe5b, 0x03c1c1b5, 0x08098233, 0xb2fef325, 0xfe10014d, 0x8bf0fef0, 0xa5fd4e01, 0xfec1cd04, 0xfd0d01b5,
    0x223303a5, 0x2c15cdfc, 0x22cdfc15, 0x82330322, 0x08108208, 0xfe6f013d, 0xdf67016e, 0xfc818124, 0xb49201dc, 0xb6b686df, 0x01df5db6, 0xfe6efe67,
    0x020181ef, 0x9201b424, 0xfd2b99fe, 0xfd1729de, 0x020d0dde, 0x02291722, 0x02172922, 0xfd0d0d22, 0x820017de, 0x00022100, 0x083b0082, 0x00780500,
    0x00570023, 0x011e0100, 0x23061415, 0x21232622, 0x012e022b, 0x18363435, 0x2408c043, 0x04323324, 0x281c8212, 0x33161401, 0x012e3732, 0x82268327,
    0x32332520, 0x3233051e, 0x21057e41, 0x93411707, 0x081a8205, 0x23052e8b, 0x08070622, 0xa7ec896f, 0xfb030f04, 0x05020147, 0x5c6eecaa, 0x5f75a40c,
    0x27014b4d, 0x1801a6b3, 0xccfa01a3, 0x67897ca8, 0x430c3f10, 0x4d4d374d, 0x41512c35, 0x71514941, 0xa8a77941, 0x5d628f7b, 0x50344c42, 0x4f2b394a,
    0x52494241, 0xaa7a3f6f, 0xc72efc02, 0x01e9a47a, 0x6ea5e70a, 0x2b2736ba, 0x9a3aa273, 0xecfea1bc, 0xfe1806a3, 0x638e7af0, 0x410e4914, 0x44353643,
    0x5252442a, 0x778f2a44, 0x6c618e79, 0x39334240, 0x20108545, 0x088b458d, 0x0600072f, 0x000f0000, 0x001f0017, 0x002f0027, 0x70188237, 0x24210e34,
    0x2cca8220, 0x01371732, 0x37342637, 0x00100627, 0x34058220, 0x12072722, 0x26103620, 0x05100620, 0x27103617, 0x02141607, 0x11fa6fca, 0xfec00234,
    0x52c2ab84, 0xfbc252aa, 0x1c1cc2f1, 0x42025ac2, 0x10857c01, 0x3e01ca30, 0xc2fee1e1, 0xc26403e1, 0x1cc25a5a, 0x296c0006, 0x820e2012, 0x831c2018,
    0x2441833a, 0xfd84feab, 0x221084be, 0x85e12601, 0xc208223c, 0x084e85ab, 0x00010024, 0x0620ff20, 0x00d705e0, 0x01000021, 0x04060214, 0x02262420,
    0x24123435, 0x00061537, 0x021e1415, 0x0e823e20, 0x27002a08, 0x12041635, 0xe789e006, 0xa0fec0fe, 0x89e7c0fe, 0xce5001c2, 0x66ddfedd, 0x0401edab,
    0xfe66abed, 0x01cedddd, 0x8002c250, 0x2f1c83b0, 0x4001e789, 0x7301d5b0, 0x2de41ff0, 0x82e6a0fe, 0x28822082, 0x01e68229, 0x1fe42d60, 0x828dfef0,
    0x13003d6a, 0xee0600ff, 0x63000006, 0x36130000, 0x31323712, 0x040e0714, 0x1e17011e, 0x3f013e01, 0x2e2e0382, 0x2e012f01, 0x37012f03, 0x011f011e,
    0x08822636, 0x010e1723, 0x841c840f, 0x010e2208, 0x302b8716, 0x2f042e02, 0x16332601, 0x17081e31, 0x23040212, 0x08c28222, 0xd80813c5, 0x080105c5,
    0x21384028, 0x32484905, 0x103e4d68, 0x0f1c2710, 0x0a0e0d1b, 0x0e2a2d29, 0x4e27680d, 0x27011314, 0xa0a11415, 0x04032721, 0x1c1c4f16, 0x13522c67,
    0x14221f13, 0x5159212f, 0x3c151647, 0x20041849, 0x0e29312a, 0x0a070e0d, 0x314f2d28, 0x1c302b44, 0xde030113, 0xb9ff6efe, 0x85ebb4fe, 0x01d99602,
    0x0201817a, 0x77663308, 0x47a69598, 0x1f102732, 0x83331011, 0x1d1e6472, 0x1a213119, 0x11730606, 0x301b1a46, 0xb71f206f, 0x22712eb5, 0x11472521,
    0x480e7311, 0x9b381d1d, 0x1f2d40b9, 0x10112114, 0x7c777c35, 0x3d536770, 0x030d1111, 0x3242221d, 0x68664a50, 0xfdfe4782, 0x94e664fe, 0x485201f8,
    0x073f05f7, 0x00000600, 0x001b000c, 0x00500028, 0x006c005d, 0x00890079, 0x05000099, 0x27242615, 0x82171637, 0x07210802, 0x16070116, 0x10260717,
    0x07061737, 0x14150617, 0x04061701, 0x37363507, 0x17373627, 0x16070336, 0x21158214, 0x1b832707, 0x37272226, 0x26072726, 0x34200582, 0x05821d85,
    0x82173221, 0x1637233d, 0x20831501, 0x27252683, 0x10002436, 0x233c8207, 0x34353627, 0x27212a82, 0x84328337, 0x35272635, 0x10000416, 0x080c7302,
    0x1c730420, 0x082c7305, 0x20245608, 0x6a031604, 0x6a9efed0, 0x412c1d3a, 0x4111dc94, 0x1653e2fd, 0x6262391b, 0x52131e39, 0x3a080523, 0xd09efe6a,
    0xdc114138, 0x7a2c4194, 0xe80e0ee9, 0x39b9431f, 0x5c34305a, 0x395a3034, 0xe81f43b9, 0x21e90e0e, 0x583bb942, 0x2c6c2c30, 0xb93b5830, 0x412afe42,
    0x362e8338, 0x6a392326, 0x10046001, 0x161b3962, 0x52232453, 0x16391e13, 0x83262339, 0x41383a64, 0x016001d1, 0xfee4870d, 0xfea6fec4, 0x8787e4c4,
    0x013c01e4, 0xe43c015a, 0x122043b3, 0x42664008, 0x22accf06, 0xa8393231, 0x020c562c, 0x343c1c11, 0x9a01b421, 0x383821b4, 0x6d70641c, 0xac22e8fe,
    0x014206cf, 0xa82c560c, 0x5b023239, 0x2a562a50, 0xa24d5c50, 0x0af11243, 0x4312f10a, 0x845c4da2, 0x5d2d0812, 0x1244a24c, 0xf00a0af0, 0x4ca24412,
    0x02422602, 0xa92a560b, 0x21382a38, 0xabfdcfac, 0x21b466fe, 0x671c3c34, 0x1c64706d, 0x26213838, 0x24188221, 0x0b562aa9, 0x217a8202, 0x998400fd,
    0xad89a382, 0x6f9f0221, 0xcb5a139d, 0x00073709, 0x00390010, 0x00690045, 0x00830073, 0x23142500, 0x33343522, 0x07860332, 0x35371624, 0xac5a2306,
    0x15172406, 0x84141506, 0x021e2d04, 0x34353233, 0x012e2726, 0x3e373435, 0x272e0482, 0x26331336, 0x37341135, 0x11151623, 0x33820514, 0x013d2228,
    0x33163233, 0x13832335, 0x23011d24, 0x0e833615, 0x15231528, 0x33031e14, 0x88590132, 0x25362107, 0x080b1d49, 0x16322152, 0x6b5d4602, 0x4a246662,
    0x26244d4d, 0x32394ea6, 0x3b76563c, 0x7129262c, 0x2b4c4428, 0x1b4e60e0, 0x5a4d3131, 0x8947250a, 0x03890202, 0x261efa01, 0x23093435, 0x8c036909,
    0x01243c04, 0x02041003, 0x381f1205, 0xc8fe4026, 0x32314830, 0x64023146, 0x080ba36c, 0x3f42e45a, 0x55950140, 0x25335a54, 0x721d1d7d, 0x0f683256,
    0x35441103, 0x66250318, 0x1023432d, 0x0e4043bc, 0x2c181f05, 0x4f6e0f08, 0xfe091c18, 0x01371b61, 0x17172e83, 0x3278fe30, 0x52157909, 0x527502e1,
    0x2f1f1814, 0x02010375, 0x3b3625d9, 0xda021826, 0x25363724, 0x53363524, 0x080dd26c, 0x00060022, 0x0600ff44, 0x000006bc, 0x00100007, 0x0048003c,
    0x0077006c, 0x23342500, 0x33141522, 0x26340332, 0x01380885, 0x16070615, 0x07061415, 0x1415010e, 0x1015051e, 0x022e2221, 0x35373435, 0x2208d782,
    0x012e3537, 0x33363435, 0x01321732, 0x11353623, 0x06332734, 0x25141115, 0x22230615, 0x1135032e, 0x82223533, 0x35072345, 0x19843533, 0x22153326,
    0x11012b26, 0x00215d82, 0x08ff4614, 0x5302b808, 0x97ac9ea5, 0x7c3b3c3b, 0x0d01777c, 0x92102b24, 0x2d27287c, 0x47565647, 0x4595fe2d, 0xb6416e7a,
    0x5f483f43, 0x52608cbe, 0xdeb60162, 0x04de0404, 0x67475d02, 0x1d325a3e, 0x18070208, 0x60261506, 0xab06e306, 0x550e390f, 0xf0fd3d57, 0x503a394e,
    0x163a3b4f, 0x03656864, 0x91523d5c, 0xcacd0187, 0x292b0a0c, 0x0817b37f, 0x291f2726, 0x2d1e1517, 0xd0fe3953, 0x4a6b3919, 0x29043ca5, 0x041c6d55,
    0x8b51a918, 0xbefc2fb9, 0x6102592d, 0x5b21225e, 0xb1599bfd, 0x3c2827c4, 0x013b5860, 0x0602045f, 0x23364cbe, 0x04be7c29, 0x048393fe, 0x5757740e,
    0x00583b3a, 0x5b020000, 0x0b3008bb, 0x00001b00, 0x03230109, 0x03270706, 0x33110123, 0x2f0fb06e, 0x0a012903, 0x14189d70, 0x01789b2a, 0xd7026507,
    0x300bf041, 0xf3011402, 0x2c30c8fe, 0xfe38015c, 0x03bcfe13, 0x0ba6418a, 0x00022308, 0x0400ff39, 0x000006c7, 0x0049001d, 0x06140000, 0x06272223,
    0x16130207, 0x22230706, 0x3e262726, 0x63483703, 0x04322405, 0x82040210, 0x012e361c, 0x17013e37, 0x3e323316, 0x022e3402, 0x15020e22, 0x0e161714,
    0x082a8201, 0x3e34353a, 0x04323302, 0x4f724a03, 0x353e333c, 0x1b012df7, 0x1e140515, 0x26150e02, 0x3d284446, 0xa0711047, 0xfe9cee01, 0x43409ef3,
    0x05051715, 0x39331524, 0x4c80b261, 0xc2b2804c, 0x32080682, 0x260d0a34, 0x5d400a29, 0x9e76d89c, 0x14040d01, 0x432371a0, 0xfe8dfe4f, 0x02211618,
    0xf37e141b, 0x3c82b5bf, 0x2a234b5a, 0xfe2e7150, 0x9cf4fec4, 0x8225050e, 0x0d042179, 0x06823e86, 0x68726136, 0x0e142814, 0x778e7b13, 0x9c5c9cd8,
    0x12000100, 0xee0600ff, 0x6926db82, 0x26010000, 0xc8823435, 0x34373635, 0x33363712, 0x061e1732, 0x1516011f, 0x14150614, 0x4915011e, 0x2e2e0655,
    0x23262704, 0x1e070607, 0x010e1702, 0x4a6f0607, 0x012e2406, 0x82010e27, 0x8303200b, 0x013e2d40, 0x36373237, 0x012e2735, 0x0722012f, 0x23212582,
    0x08f98322, 0x0e0110bc, 0x010d1608, 0x7db90e11, 0x8585b98b, 0x323c5231, 0x0c141f22, 0x03123701, 0x27574d04, 0x11150924, 0x01100b15, 0x3b050201,
    0x37531449, 0x05040208, 0x7335ee40, 0x080f4051, 0x2908400e, 0x442352ad, 0x14415476, 0x143b0b1f, 0x02020a04, 0x050d7830, 0x49120804, 0x04040129,
    0xda021703, 0x3a142113, 0x0c3e1610, 0x3c2b018b, 0x36153742, 0x63464e3a, 0x53053a50, 0x0c340e43, 0x01050501, 0x2b6cc972, 0x20140f72, 0x01021f15,
    0x14459a04, 0x042a2e25, 0x12610618, 0x02051316, 0x2d010104, 0x1a0f0328, 0x27282536, 0x0116021d, 0x03020202, 0x033ebd0b, 0x04432914, 0x2e360109,
    0x77491301, 0x083e3007, 0x00c20500, 0x0016000a, 0x002d0021, 0x825b0049, 0x09df5e18, 0x0a890120, 0x95023621, 0x26013f16, 0x02042223, 0x06171415,
    0x032e2223, 0x24370727, 0x24123411, 0x16043233, 0x07061401, 0x16822717, 0x10262423, 0x34118436, 0x29324402, 0x2b42422b, 0x33190329, 0x2d2d1b28,
    0xec33281b, 0x23118531, 0x2734ac02, 0x26081183, 0xf6fe3427, 0xfea9271f, 0x2317a3e4, 0x3e301a21, 0xfd09521b, 0xc3defe48, 0xb0c54d01, 0x02d33901,
    0x3775896f, 0x834496c7, 0x01a33a20, 0x01a1a91c, 0x0a04ab1c, 0x28333252, 0x5ffe3327, 0x1b2d2c1c, 0x012c2d1c, 0x08108fef, 0x9a04aa3c, 0x4e9cf9fe,
    0x0a03034a, 0x7f021104, 0x1f01cbda, 0xa31c01a9, 0x3ffde984, 0xb557d575, 0xf28d256d, 0x8df21e01, 0x0100f38d, 0x00ff0000, 0x0006ff06, 0x00001e00,
    0x01071601, 0xc1820706, 0x03252722, 0x53080583, 0x1135012e, 0x26250109, 0x01372627, 0x06323336, 0xff0621e4, 0x0e1b0500, 0xfe0d0b11, 0x1f12f23b,
    0x1713090d, 0xd3fb6003, 0x032575fe, 0x80062202, 0x0514110f, 0xfa2818f5, 0x08101d00, 0xd9feb905, 0x21070417, 0x045d0114, 0xa263fc23, 0x1328290e,
    0x0009c003, 0x02200082, 0x05257385, 0x001a00f7, 0x20758c20, 0x86758701, 0x13012573, 0x01090501, 0xfd3d778b, 0x12d6fef1, 0x13090e1d, 0x2528fe16,
    0x06230303, 0xcbfe2380, 0x0166fadd, 0xfe5f0350, 0x237d8922, 0x15b9fed7, 0xc4337d84, 0x27290ec1, 0x15c00314, 0x2b050efa, 0x0289c5fc, 0x44e3fc7f,
    0x34220c77, 0x0f824900, 0x06021023, 0xd9c11804, 0x4605202d, 0x3d2606cf, 0x3b363401, 0x04831101, 0x18163221, 0x3035eec1, 0x0e12fafd, 0x120ec0fe,
    0x12e00e12, 0x120e400e, 0xfec11803, 0xfe98212b, 0x21071367, 0x42826001, 0x0f22db8c, 0x0f821b00, 0x020e202b, 0x20021e10, 0x2e10023e, 0x34441801,
    0x8203230b, 0x594bfcfe, 0x04012105, 0x01210784, 0x0e385c91, 0x66000522, 0x0d3a9d18, 0x5cb7fe21, 0x3e2f101b, 0xc20680ff, 0x85008005, 0x22050000,
    0x46222326, 0x3e330592, 0x35363702, 0x26273403, 0x07222123, 0x14031506, 0x4d031e17, 0x218b06d5, 0x34112729, 0x27042e36, 0x7f22012e, 0x3329062f,
    0x32333632, 0x0e141516, 0x26358202, 0x16171413, 0x82322133, 0x34132349, 0x6d4f2e27, 0x84218f06, 0x062b0857, 0x2db12c92, 0x182cb02c, 0x3a2c221a,
    0x01012110, 0x5dfd250d, 0x01010d26, 0x32401025, 0x2f181928, 0xaa2b2eb9, 0x1f19172a, 0x820f3629, 0x0201381d, 0x090e0805, 0x242e3c0f, 0xb92e1818,
    0x2aa92a2e, 0x2b221919, 0x82230f38, 0x021a2338, 0x388219bb, 0x51122325, 0x82191933, 0xac2b2752, 0x2319192b, 0x1c823a2d, 0x10223d08, 0x18242f3c,
    0x29070780, 0x041e1f19, 0x77150a0a, 0x0a158701, 0x150a0404, 0x168e8dfe, 0x1d01060a, 0x072c1a1f, 0x1e182a07, 0x0a0a051e, 0x03397817, 0x1b2e032d,
    0x18272232, 0x1c040a06, 0x2c331b84, 0x021b1e1a, 0x8b150a06, 0x0b15c0fe, 0x150b0303, 0x828b4001, 0x26172108, 0x1c823883, 0x05011c3d, 0xfc8a170a,
    0x0a157751, 0x1e1d0207, 0x00002c1a, 0x18000100, 0xfe0480ff, 0x82008005, 0x051b4f0d, 0x07060729, 0x14111506, 0x68012b06, 0x09850798, 0x82272621,
    0x35400801, 0x37363734, 0x32012936, 0x25fe0416, 0x1a043218, 0x19240306, 0x8f24196c, 0x1a6c1a23, 0x7e629323, 0x58584042, 0x32016f79, 0x2419df01,
    0x1d494305, 0x19060140, 0x80fb350b, 0x19242419, 0x3efbc204, 0x013f0783, 0x3a2f0cf0, 0xa68e7579, 0x25297678, 0x00090024, 0x0680ff00, 0x00000500,
    0x00130003, 0x6c1b0017, 0x43290641, 0x00004700, 0x35211525, 0x0eff5225, 0x13820120, 0x23151323, 0x20078335, 0x8e1b8f03, 0x8205200f, 0x82132027,
    0x6001272f, 0xc002a0fe, 0x4e18261a, 0xa0290811, 0xe0e0a0fc, 0x20fd0006, 0x211489e0, 0x0b898003, 0xe0400226, 0x80a0fce0, 0x32880082, 0x261a0023,
    0x240f8201, 0x80800002, 0x210382fc, 0x198b8004, 0x8b00fe21, 0x2126860d, 0x83480100, 0x00253708, 0x16320100, 0x26200610, 0x25373435, 0x26222306,
    0x32333610, 0x0e822517, 0x82203621, 0x22233517, 0x14160527, 0x04360507, 0xbbbb85c0, 0x02bbf6fe, 0x7e5c98fe, 0x852a0a82, 0x68015c7e, 0x0a01bb02,
    0x0a82bbbb, 0x0298fe28, 0x5c680102, 0x22830002, 0x0c85bb25, 0x8356b416, 0xb456231a, 0x36850c16, 0x18200982, 0xab431482, 0x0025310c, 0x24000035,
    0x22232634, 0x34362707, 0x33163727, 0x23054a56, 0x07171415, 0x06211482, 0x24108214, 0x15061737, 0xd8801814, 0x00053411, 0x3d54587d, 0xf10202f1,
    0x7d58543d, 0x027eb07d, 0x82533ef1, 0x53582808, 0x7e02f13e, 0x497d01b0, 0xfd3d0b2a, 0x783a7eb0, 0x78100e10, 0x7db07e3a, 0x1007587d, 0xb07d3978,
    0x1078397d, 0x037d5807, 0x0b3749e0, 0x00000736, 0x000700ff, 0x11000006, 0x3e002f00, 0x58004c00, 0x73006400, 0x2e28b582, 0x010e0701, 0x17160607,
    0x3e2d9383, 0x01363701, 0x16170717, 0x16010f14, 0x07025015, 0x36121030, 0x17323324, 0x1f323637, 0x23061301, 0x356b2f22, 0x14162307, 0x0d8b0617,
    0xc5423620, 0x36342605, 0x2732013b, 0x056b6315, 0x32363425, 0x82071716, 0x26272635, 0x36013f34, 0x085b8232, 0x14450250, 0xa66c1930, 0x19140a2c,
    0x122a0b0d, 0x19548122, 0xf42eb803, 0x40131344, 0xfebd6f59, 0xfee2fefb, 0x6f6fbdfb, 0x8f0501bd, 0x1340a1b6, 0xfb441335, 0x0a0d0c0a, 0x0a09095b,
    0x0a5a0a1a, 0x0b180bdc, 0x090a0a5a, 0x095b091b, 0x600e1220, 0x0483120e, 0x1c12ae23, 0x21028212, 0x2a835b97, 0x26820a20, 0x090a1a38, 0x14329a03,
    0x6ca62c0a, 0x050a3019, 0x22815428, 0x2ead010b, 0x508244f3, 0xb6a14023, 0x2c63878f, 0x05011e01, 0x40596fbd, 0x01441313, 0x8238862c, 0xef1b2259,
    0x20058309, 0x20118409, 0x205b84bb, 0x226a86a0, 0x87451212, 0x2191827f, 0x5b410300, 0x00042c08, 0x00350014, 0x05250100, 0x52022103, 0x2a080e02,
    0x013d3601, 0x17132707, 0x05172726, 0x07063725, 0x27071337, 0x37171415, 0x16071305, 0x13273732, 0x01610225, 0x6d1f011f, 0x52059dfe, 0x29081103,
    0x66956d04, 0x96863ff0, 0xe1fe35ef, 0xef35e1fe, 0xf03e8796, 0x011e9566, 0x75748b46, 0x8b7475f6, 0xd0024601, 0xb0fed0d0, 0xe04e8004, 0xfb280812,
    0x03fbcb48, 0x4301e059, 0x7c4cce0c, 0x4c7c9f9f, 0xbdfe0cce, 0xfb0359e0, 0xfe2884cb, 0x272745d6, 0x282a0145, 0x0c000000, 0x00240382, 0x80050007,
    0x32085370, 0x00590049, 0x00790069, 0x00a20089, 0x00bc00b2, 0x41152500, 0x284705e1, 0x16322205, 0x200f8e03, 0x8f0f8e01, 0x2225251f, 0x21013d26,
    0x23202482, 0x1fa1299f, 0x34352126, 0x011d0405, 0x3e270682, 0x04202404, 0x8e11041e, 0x210f837c, 0x71832123, 0x12c00126, 0x120ec00e, 0x0a8a0484,
    0x94400221, 0xc2fd2916, 0x0202261c, 0xff021b26, 0x35961e94, 0xfd800139, 0xfe82fefe, 0x11fefd82, 0xb38d5033, 0x3e010d01, 0x8db40c01, 0x89113350,
    0x1b262645, 0x261b80fe, 0x228a87e0, 0x88720112, 0x89fe200a, 0x27158a0a, 0x811b2692, 0xfd261b81, 0x013832aa, 0x680a0d8a, 0x0a650102, 0x4c34110d,
    0x253a4d4b, 0x4b4d3a25, 0x57fe344c, 0x01216a88, 0x82528254, 0x82002058, 0x42052000, 0x102f08bb, 0x25001400, 0x39002f00, 0x11010000, 0x4f230614,
    0x132608e2, 0x11213336, 0xc24d1121, 0x26222a09, 0x32211135, 0x21150117, 0x055d6935, 0x09880520, 0x26c00232, 0xfe1a261a, 0xf9261a00, 0xe8021807,
    0x000400ff, 0x1a310e85, 0x18a80126, 0xfed9fc07, 0x010e12a0, 0x02120e20, 0x220987a0, 0x82fdc004, 0xc0fd302e, 0x1a26261a, 0x69030002, 0x0240fd17,
    0x8380fcc0, 0x28108243, 0x031a2640, 0x37011700, 0x056d66e0, 0x00210583, 0x20b38801, 0x34ab821d, 0x01071416, 0x04060717, 0x35230127, 0x3f122601,
    0x36011701, 0x82148432, 0x06290807, 0xfe2525db, 0xa3a0966f, 0xfeb93bfe, 0x6a01b596, 0xa0a32f7c, 0x26900196, 0xfe254a6a, 0x9101ea70, 0x3b046a26,
    0xfe266926, 0x21238270, 0x22847c2f, 0xc501b922, 0x91232383, 0x826b4a25, 0xea20083b, 0x00259001, 0x00040000, 0x060cff19, 0x000006e7, 0x00150009,
    0x0067003a, 0x06140100, 0x34352622, 0x05206c82, 0x1809bb4f, 0x270aef49, 0x3632051e, 0x16173633, 0x36380182, 0x021e3217, 0x0637053e, 0x06071207,
    0x26270607, 0x2e350337, 0x16032701, 0x272b0b83, 0x27261326, 0x1e173626, 0x41111701, 0x1529054f, 0x16363711, 0xb27f6903, 0x0802827f, 0x7ef6015e,
    0x7f7f595a, 0xe17e5a59, 0xa8fb4f40, 0x5b2b3b53, 0x59335b47, 0x4402551c, 0x1a04061b, 0x056f0723, 0x2644173f, 0x3d493347, 0xfb79c64a, 0x75426b54,
    0x04564e68, 0x07210801, 0x4f570401, 0x69417568, 0x1979fb53, 0x0f04272a, 0x04435e03, 0x155e43e9, 0x1c032a27, 0x53777753, 0x54767654, 0xfe2d0786,
    0x579b02f8, 0xfd5c4449, 0x1622175f, 0x0839820f, 0x061c015a, 0x5b1a1903, 0x01010304, 0x100b0603, 0x95181f17, 0xb4e3fe67, 0x2f202371, 0x46017133,
    0x01080201, 0x3272aefe, 0x7224202f, 0x671b01b4, 0x1b342595, 0x02030a02, 0x666648b6, 0x0f4afd48, 0x0000341b, 0xff640004, 0x069c0680, 0x00030000,
    0x000f0007, 0x01000019, 0x21112311, 0x13210382, 0x08068237, 0x3715212a, 0x21011101, 0x21352307, 0x80031311, 0x911f0291, 0x56fbfd91, 0x03d94601,
    0xfe4efe1c, 0xfed9d9ba, 0x4e046d72, 0xb2014efe, 0xfd2e0383, 0x1b03fe08, 0xd9d9e7fb, 0x0bfcaa04, 0x07824efe, 0x21018622, 0x3b05c342, 0x0501ff59,
    0x00fd05aa, 0x002b0016, 0x004e003f, 0x25000065, 0x06070215, 0x27260607, 0x37240182, 0x3237013e, 0x17280482, 0x0627011e, 0x2304010f, 0x3e381584,
    0x17321701, 0x1e011f16, 0x010e0101, 0x26270607, 0x36262703, 0x16173637, 0x17232682, 0x82160116, 0x26012412, 0x82243637, 0x12162210, 0x230e8205,
    0x37070605, 0x37215083, 0x824b8236, 0x1edc0828, 0x05031701, 0x270c0501, 0x0d23ff36, 0x04050104, 0x3b01973c, 0x1819310f, 0x3103961b, 0x11edfe78,
    0x050c1323, 0x232a1208, 0x2c47bd0d, 0x03191754, 0x33a90739, 0xaa0e1a25, 0x11050e2f, 0x76013023, 0x1c084ecb, 0x3b055afd, 0x86fe383a, 0x01291b08,
    0x09283a4d, 0x9b022603, 0xfe0f1d03, 0x011843c6, 0x1e0e2e17, 0x7d4a011e, 0x251c0932, 0xd9069630, 0x0ddcfe7f, 0x5e090820, 0x0c150f2a, 0xb34a0a0e,
    0x090b1346, 0x37e4260a, 0x0258270f, 0x4c321922, 0x4d0244b5, 0x0922121d, 0x36bcfe2b, 0x150e14d6, 0x4d15010a, 0x2b153215, 0x42270111, 0x0216071b,
    0x11146651, 0x23560258, 0x0f5d2b1b, 0xfd12230a, 0x1427c8c1, 0x080f4c0a, 0x16140602, 0x6501282f, 0x130642ab, 0x39dd1711, 0x0a000000, 0x00240382,
    0x80050008, 0x350cfb70, 0x0023001b, 0x0038002c, 0x11210100, 0x21151321, 0x21110135, 0x07830111, 0x1127038b, 0x16141123, 0x82253632, 0x0714241b,
    0x18363221, 0x2b09f24c, 0x00043521, 0x800180fe, 0x0280fd80, 0x05240382, 0x0200fe00, 0xfc37038a, 0x34268000, 0xfa800626, 0xcb050b00, 0x7080261a,
    0x5080f950, 0x83000170, 0x00ff2534, 0x00038080, 0x09823784, 0x038a0120, 0x0340fc3b, 0x1a40fcc0, 0x041a2626, 0x21c0fb40, 0xda04261f, 0x705040fb,
    0x40045070, 0x313a8280, 0x070d002a, 0x008005d6, 0x001f0009, 0x00510039, 0xb5432400, 0x14152906, 0x012e2237, 0x23010e22, 0x372d1083, 0x1632013e,
    0x14151617, 0x27220106, 0x2113822e, 0x1785030e, 0x20243623, 0x23178404, 0x26272213, 0x07200b82, 0x2005144d, 0x08178837, 0x28140456, 0x7d527d92,
    0x7f4c0268, 0x034b7f82, 0x4e0a9712, 0x4eece6ec, 0xff00970a, 0xe8880c0b, 0x7fab5598, 0x11023a64, 0x01840a96, 0x01800178, 0x960a8478, 0xb30b0bfe,
    0x38fe7ffe, 0x0bb37ffe, 0x0a97110b, 0x020402bb, 0xbb04021a, 0x930d970a, 0x2c2c2014, 0x327c1420, 0x963e0082, 0x4d0a0d12, 0x0a4d5858, 0x0196120d,
    0x63690810, 0x2c3e3e2c, 0x0a0c1296, 0x84929284, 0x14820c0a, 0x9d090f26, 0x099d9f9f, 0xba232883, 0x83bacccc, 0x00002c28, 0xff00000d, 0x06800600,
    0x5a070000, 0x3f350c95, 0x53004b00, 0x6b006300, 0x00007b00, 0x22263404, 0x32161406, 0x20078624, 0x2107ae00, 0x30831101, 0x82111521, 0x87362042,
    0x2f52183b, 0x8610200f, 0x09004253, 0x3336342e, 0x01163221, 0x4b6a4b80, 0xcb016a4b, 0xfe200684, 0x03200685, 0x02821182, 0x14940d86, 0x4c4b0324,
    0x02824c68, 0x3f87fe20, 0x23078e77, 0x261a0005, 0xcb294b84, 0x80fa344c, 0x344c4c34, 0x20058205, 0x85648335, 0x014b2255, 0x200c84cb, 0x860685fe,
    0x2214940d, 0x840180fd, 0x83fe2041, 0xff022105, 0x01223684, 0x618201c0, 0x21066f4c, 0x1384a5fe, 0xfa000323, 0x20698300, 0x08058306, 0x0002002b,
    0x0500ff09, 0x000006ef, 0x00450027, 0x07160100, 0x22232102, 0x03010f06, 0x2b010e07, 0x37262201, 0x3637033e, 0x3716013b, 0x28018436, 0x1716013e,
    0x07142716, 0x29018206, 0x22272314, 0x06030607, 0x26822123, 0x0807916e, 0x05011eae, 0x571612ef, 0x192c22fe, 0x37040526, 0x19270502, 0x031815fb,
    0x24122309, 0x83260509, 0x70af6785, 0x0b183566, 0x04040301, 0x502e994f, 0x5a8b71de, 0x0212645a, 0xfe0b0153, 0x031d16d9, 0x1d2d05e8, 0x7f225602,
    0x03716b30, 0xfe78547a, 0x131a2144, 0x1a0fa6fe, 0x38151e21, 0x38df70e0, 0x27170225, 0x46975f69, 0x0103063f, 0x6bb33b03, 0x2852e981, 0x60010102,
    0x0af6fd08, 0xbf051621, 0x131a261d, 0x0000a429, 0xff270004, 0x06000700, 0x000a0000, 0x00190012, 0x01000028, 0x13001732, 0x26030221, 0x06013336,
    0x36030207, 0x12131237, 0x09251183, 0x02031001, 0x08188401, 0x1632216f, 0xb9011217, 0x0a011321, 0x7f42fe60, 0x14120cf0, 0x4c31a403, 0x0428b14f,
    0x01ebe1d3, 0x3dfe232b, 0x0400fe29, 0xfe436568, 0x045119dc, 0x67011013, 0x73052315, 0xfe1a6003, 0x0166fe94, 0x103401b9, 0xc79bfe23, 0x013601c2,
    0xfee4dd1c, 0xfe8f01ac, 0xfe13fdbc, 0x03990271, 0xfec0fd27, 0x027cfe58, 0x010b0230, 0x101b012d, 0xfe141a19, 0x08a28267, 0x80ff003b, 0x80050009,
    0x0f000800, 0x1c001800, 0x49003e00, 0x00005900, 0x3f362301, 0x37013e01, 0x26030517, 0x04072123, 0x2e270325, 0x33132701, 0x13330301, 0x23260523,
    0x06070622, 0x064f5517, 0x07012f28, 0x36163316, 0x22823437, 0x36343531, 0x011f3633, 0x07222325, 0x33373303, 0x42331716, 0x56080fc5, 0x0e8ab707,
    0x0c040334, 0x82fa0c03, 0xfe400b3a, 0x370102f4, 0x11a20f01, 0x8748761a, 0x250501af, 0x02a668a6, 0x7b504598, 0x9201019c, 0x273c2630, 0x17164656,
    0x9d826f4a, 0x2c318c02, 0x36462e31, 0x80c0010f, 0xaef61641, 0x0f05d423, 0x344c809a, 0x4c3400f8, 0x8208344c, 0x02430805, 0x098e2522, 0x370a200a,
    0x36270178, 0xfe5c4f0d, 0x7746594a, 0x0202fe1d, 0x027efd81, 0x761b1082, 0x1748665e, 0x201e1524, 0x22900b21, 0x6a647801, 0x15221944, 0x19012116,
    0xfd369b08, 0x4a1660b4, 0x84fbc203, 0x8305204c, 0x18002205, 0x071b4100, 0x00116508, 0x002b0019, 0x00400033, 0x00580047, 0x00670063, 0x007a0071,
    0x00b8009c, 0x00e500c7, 0x010b01f9, 0x012d0119, 0x014a013c, 0x017b0158, 0x0100008b, 0x0e222326, 0x1e141502, 0x37323302, 0x37120226, 0x17120206,
    0x27021236, 0x07021216, 0x3e323316, 0x2e343502, 0x01222302, 0x15233533, 0x023b1533, 0x27072335, 0x35360982, 0x03373317, 0x35012b15, 0x3315013b,
    0x37333227, 0x012f3436, 0x0c822b22, 0x24333522, 0x2d066861, 0x24222306, 0x04231732, 0x16323634, 0x0d821415, 0x09863620, 0x17222a08, 0x26222722,
    0x34352635, 0x36373437, 0x36353231, 0x16173233, 0x16151731, 0x011c0715, 0x23060723, 0x35332506, 0x22272634, 0x209e8207, 0x24798307, 0x32333435,
    0x8284821d, 0x17152606, 0x23013d33, 0x21198215, 0xa1821406, 0x82013f21, 0x824a8279, 0x83372042, 0x14152313, 0x6e82011f, 0x27222322, 0x3622bf83,
    0x78822717, 0x39823d20, 0x46822320, 0x1521b882, 0x21e88214, 0xff6f0622, 0x201b8305, 0x21698327, 0x65882233, 0x26371723, 0x25578316, 0x27062737,
    0xca832622, 0x23211182, 0x8c748f22, 0x201c8630, 0x26908622, 0x06232207, 0x82150607, 0x14172464, 0x82011e17, 0x3f342a70, 0x36373601, 0x26273435,
    0x21ad8227, 0x6b4b2622, 0x05304509, 0x5f042108, 0xbd679980, 0x88515188, 0x809968bc, 0xa35f5e83, 0x7f5b5c7e, 0x5d5c5b7f, 0x835e5f82, 0xbc689980,
    0xbd3a1b83, 0x65029967, 0x03071107, 0x0605041d, 0x06030506, 0x02080504, 0x03020303, 0x00840104, 0x06010237, 0x16fb0103, 0x16121316, 0x01131216,
    0x46053ca5, 0x24168701, 0x29108217, 0x172417fa, 0x02872417, 0x2b820102, 0x02010228, 0x01030202, 0x35830204, 0x79081282, 0x1d1ebcfa, 0x0e0f2019,
    0x1e0f181f, 0x1d1e211e, 0x1da61e21, 0x1d1a111d, 0x1c1d2626, 0x0e2fb20f, 0x14171917, 0x1a21160c, 0x180d2f1e, 0x0d14191f, 0x211d2119, 0x0d0d0882,
    0x1e303013, 0x152f1c1c, 0x27261d65, 0x0e16211e, 0x07221512, 0x17832465, 0x1d1e1e0c, 0x0909080a, 0x1d212712, 0x11120e13, 0x12171712, 0x140e1013,
    0x1ece211c, 0x1d1b0f1e, 0x1c1d2727, 0x0c17850e, 0x26831d1d, 0x1d7f082b, 0x27380f1d, 0x0e1d1c27, 0x838c824e, 0x03012699, 0x04030402, 0x820d8302,
    0x220783a2, 0x43670104, 0x23080b40, 0x5155ab04, 0x6867bc88, 0x555188bc, 0x013d016b, 0xfe63533c, 0x63d4fed3, 0x012c0163, 0xfe6b7b2d, 0x6ac3fec3,
    0x68212183, 0x08218267, 0x03d9fc22, 0x0d141103, 0x0d0f140d, 0x0239fe0d, 0x01050a03, 0x01010401, 0x262c050d, 0x13121918, 0x1f205718, 0x19220885,
    0x0f831924, 0x1d821d20, 0x03020223, 0x837e8201, 0x0104237d, 0x0b820102, 0x042d0d82, 0x011d1855, 0x10141818, 0x24244b87, 0x3403834b, 0x14104344,
    0x14283e28, 0x02062218, 0x0b0f0a04, 0x14180e18, 0x3b0a8321, 0x11170e11, 0x07190e18, 0x291b3d16, 0x323d1b29, 0x201f288e, 0x0f161327, 0x27200c21,
    0x4c243f82, 0x041c0423, 0x102a3882, 0x18010d18, 0x180c1826, 0x4a878b10, 0x1e877a20, 0x7a448b29, 0x3c291447, 0x82031429, 0x0301257e, 0x02030402,
    0x01200083, 0x03270083, 0x02040302, 0x82010301, 0xe5042100, 0x210b0a44, 0x0b440c00, 0x0a250808, 0x1b001100, 0x42001f00, 0x62005700, 0x71006a00,
    0x8a007d00, 0x00009a00, 0x06071401, 0x3335012b, 0x25161732, 0x2d088414, 0x2b263405, 0x32331101, 0x33173637, 0x0d822311, 0x21061f45, 0x52431732,
    0x17162106, 0x43053a49, 0x05210755, 0x08cc5c35, 0x43351721, 0x01280789, 0x0c010e11, 0x32210502, 0x2b082f48, 0x07231325, 0x37132327, 0x35233533,
    0x01240386, 0x35362733, 0x35206e85, 0x0810355c, 0x243901d1, 0x11113c1d, 0x06241c3d, 0x141340f0, 0x6453f93f, 0x4a5f5f4f, 0x411e3c2d, 0x29400141,
    0x1b151d37, 0x22181d15, 0x3c2c3929, 0x08252e24, 0x30161c13, 0x472c2a17, 0x16014033, 0x3f312925, 0x262b2e3f, 0x674a2828, 0x042a4a66, 0xfe9f41f7,
    0xfea9fec4, 0x06fefe14, 0xfc261a21, 0x6a966aad, 0x0201966a, 0x595a4790, 0xb8d08e47, 0x77737377, 0x508701b8, 0x383e4c69, 0x01094161, 0xf8374d21,
    0x4d4d3708, 0x37f80737, 0x33f7024d, 0x1bdc1a21, 0x65340d1f, 0xfe5d4a72, 0x593326b3, 0x28e84d01, 0x120a142c, 0x1b15100e, 0x2837252c, 0x0d102923,
    0x14160c06, 0x40282c1b, 0x254d293d, 0x43303241, 0x65144d26, 0xb7fd6592, 0x58280f02, 0x308c8192, 0x83c40226, 0x6a210874, 0xe0560108, 0x09aafee0,
    0x4a385a38, 0x8cb3fe39, 0x342f4e10, 0x0285b3fe, 0x380cfb24, 0x04384e4e, 0x200582f4, 0x20008200, 0x08bb4112, 0x00023b08, 0x000e000b, 0x001c0015,
    0x00260023, 0x004f003a, 0x00ce005b, 0x01f900e2, 0x01090105, 0x013f0124, 0x13000062, 0x37012733, 0x33152327, 0x25152315, 0x34173517, 0x3315012b,
    0x06852532, 0x06850120, 0x2733053d, 0x35231125, 0x15272307, 0x07232723, 0x13331323, 0x37173311, 0x040e1401, 0x82232622, 0x21072513, 0x37172111,
    0x15223682, 0x48831123, 0x013e0383, 0x23061415, 0x35262221, 0x33373311, 0x17353317, 0x21153733, 0x1d323735, 0x1e352101, 0x14873602, 0x15231122,
    0x272a7d82, 0x35072223, 0x23261523, 0x0d840721, 0xe34e0720, 0x82188408, 0x1521221c, 0x82998226, 0x27072103, 0x37206c82, 0x33285082, 0x33153732,
    0x16323335, 0x0a835182, 0x1425322b, 0x011e0706, 0x3523011d, 0x83278234, 0x1632228a, 0x23138701, 0x032e3634, 0x23224082, 0x14821711, 0x1123a68b,
    0x42011123, 0x368205c0, 0x012e2232, 0x3b363435, 0x22231501, 0x36161415, 0x1537011e, 0x8205e542, 0x2e06221b, 0x231b8902, 0x1103011e, 0x22070e41,
    0x82343522, 0x26222331, 0x3382040e, 0x013b2208, 0x11133337, 0x77351733, 0x41022d59, 0x8ea3464a, 0x633d018e, 0x535428bd, 0x2a210129, 0xfe2b5152,
    0x080583ea, 0x59cb0132, 0x4216fc2c, 0x845e395e, 0x46198719, 0x6a6e6074, 0x98024d55, 0x181c110b, 0x09291827, 0xff53507e, 0x50040100, 0xfe6dcf52,
    0x98d9d9dd, 0xd4059494, 0x08055b42, 0x37196f2a, 0x7113da19, 0x0a1d0214, 0x1717010a, 0x09552940, 0xe3193819, 0x19b4b622, 0x45f917b9, 0x3118ac28,
    0x2b2b8cfd, 0x4ea916c6, 0x08058642, 0x1e3378a9, 0xfe1737b1, 0xd1381fc4, 0x36ea4417, 0x01a3fe32, 0xd3343757, 0xae1f3b15, 0x02040808, 0xa81f3911,
    0x182dfd3c, 0x41121916, 0x41452218, 0xfe3a309a, 0x1a1519eb, 0x01014111, 0x12170c05, 0x31994046, 0xd811023a, 0x949497d8, 0x0242edfe, 0x7e7e66f7,
    0x32312222, 0x82283422, 0x31232477, 0x18ef2331, 0x217d7d40, 0x252b2519, 0x81283519, 0x4f3a2476, 0x847a5c94, 0x4b19861a, 0x073f8581, 0x0c1f0f2a,
    0x241b0611, 0x6d615c1d, 0x56037263, 0x4f86fd6c, 0x3637314f, 0x3cd96e4e, 0x1d284521, 0x1df2013d, 0x2f6c263c, 0x82d4f1fe, 0x3c3c3e00, 0xfffe0f01,
    0xb8b80101, 0x1e14d4fd, 0x02070d14, 0x5a5a5b01, 0x59590f01, 0x0f0138fc, 0x3e378239, 0x37e5d1fd, 0x02374f4f, 0x2e3d3da6, 0x632f2f2e, 0x17560e01,
    0x02010c0c, 0x3a3a3d3d, 0x822c7a01, 0x82162000, 0x61612600, 0x01b32c2c, 0x21298387, 0x0f825afd, 0x20080284, 0x86fe3a3a, 0x0d593b3b, 0x08046366,
    0xfb181857, 0x09092817, 0x2d361d22, 0x01631521, 0xa8011e0f, 0x2f0f8218, 0x09351e21, 0x0a160f23, 0x0f016207, 0x74fd1d01, 0x28087582, 0x36373138,
    0xf1fea902, 0x74fd0f01, 0x10193a56, 0x2426070a, 0x19392a27, 0x06010910, 0x23650e25, 0x0c0d193a, 0x250b0501, 0x3e14831e, 0x02060414, 0xcbf2fe42,
    0x853c3ccb, 0x01023b8a, 0x1d110a03, 0xd5282613, 0x000100ff, 0x8200bcbc, 0x430b2000, 0x0b37089f, 0x23001700, 0x53003a00, 0x85006e00, 0xae009f00,
    0xc900b900, 0x52010000, 0x25200a27, 0x07280b82, 0x013b3637, 0x05011e32, 0x3428178b, 0x22012b26, 0x16060307, 0x3f2b1a82, 0x32023e01, 0x36323316,
    0x84361305, 0x23262116, 0x24069b48, 0x15063736, 0x20218214, 0x222e8400, 0x8327010f, 0x2212821e, 0x8517011e, 0x01372218, 0x2049a725, 0x22318514,
    0x84343513, 0x14072279, 0x24588216, 0x010e0137, 0x20a08523, 0x0f8e4816, 0x33e9023b, 0x32231d25, 0x03251c25, 0x202c2c11, 0x120b0211, 0x01181a16,
    0x1d24335f, 0x39158324, 0x3e4da8fa, 0x410213a0, 0x4c060801, 0x01120214, 0x1610120c, 0x01625603, 0x11832935, 0x030e2108, 0x6548441b, 0x3c1c3a45,
    0x450d0412, 0x08c20113, 0x070b4d05, 0x11052c6a, 0x2708054b, 0x0d52012d, 0x00270e82, 0x4d7e01ff, 0x84149f3e, 0x0c522244, 0x21449104, 0x4483451a,
    0x113c1d22, 0xdd234483, 0x840b4a0d, 0x1342282a, 0x0549f902, 0x8221272a, 0x28132494, 0x48720724, 0x02330b16, 0x20312576, 0x2133251c, 0x011e2a78,
    0x15040b6b, 0x843224a9, 0x8e33080f, 0xfe13353b, 0x130a0668, 0x030a086e, 0x01e26102, 0x210a0605, 0x3b496c28, 0x0c141846, 0x15011009, 0x9c0a090a,
    0x05091096, 0x04847202, 0x0a0d0870, 0x86387001, 0x740d2132, 0x01323291, 0x01100410, 0x0b0e01ac, 0x050260fe, 0x13011309, 0x6e821623, 0xdf011722,
    0x210c8a47, 0x2f420a00, 0x0a210808, 0x32000f00, 0x57004800, 0x6c005b00, 0x8b007400, 0x00009b00, 0x06071401, 0x35272223, 0x05323336, 0x26048323,
    0x2e272634, 0x4a343501, 0x073d06c9, 0x16141506, 0x15011e17, 0x26222314, 0x33160727, 0x01363732, 0x0f352337, 0x14153303, 0x650e8317, 0x053505d0,
    0x22232635, 0x23270706, 0x36113311, 0x33133233, 0x34052311, 0x83138227, 0x35372112, 0xc04f3784, 0x82188408, 0x203f8458, 0x227e8327, 0x51332726,
    0x8e4a0ac0, 0x06780805, 0x2113153d, 0x1c1d1217, 0x6eb60139, 0xf9333206, 0x244442ec, 0x423a2620, 0x4d524312, 0x4341302e, 0x1d301f27, 0x48121f52,
    0x33305160, 0x60132701, 0x112e1281, 0x49262c3e, 0x0c202f20, 0x0f89012a, 0x0a2f200d, 0x1a96830a, 0x962f1038, 0x2d6e0296, 0x35404728, 0x24968408,
    0x3d335320, 0x422e2cfe, 0x03422e2e, 0x5e3230b0, 0x373f6f60, 0x103b656a, 0x142b4739, 0x02f80517, 0x080d254d, 0x25457952, 0x1ee00923, 0x3be96256,
    0x160d1941, 0x70211a0e, 0x46272620, 0x0e18413a, 0x191f1017, 0x25297112, 0x6f230129, 0x08721587, 0x2454db67, 0x07760b1e, 0x8b19c532, 0x381e2003,
    0x320129fe, 0x01affe1f, 0x397aded7, 0xfd2f3834, 0x0b97197b, 0xc4014138, 0x2f337983, 0x3f71ebfe, 0x80728440, 0x6728373c, 0x2f13131f, 0x41b1020e,
    0x3d080cb8, 0xff0e0003, 0x06f20700, 0x000b0000, 0x003f0017, 0x17120100, 0x21230614, 0x26220614, 0x34320527, 0x35262223, 0x14152234, 0x06160116,
    0x26060107, 0x3626012f, 0x3526013f, 0x3435043e, 0x32563712, 0x15280805, 0x011e0714, 0x16360117, 0x3d160617, 0xfe344ced, 0x95d49640, 0x10000101,
    0x20553b10, 0x08330467, 0xb0f80a01, 0x54081b0a, 0xba320882, 0x58523213, 0xbeea273d, 0x38503808, 0x35be7c08, 0x1982a201, 0xfeac023d, 0x4c34c89c,
    0x6a95966a, 0x3b5520af, 0x67491010, 0x1b0a4006, 0x08aaf909, 0x82600a02, 0x20a13920, 0x935c2a22, 0x988bf2aa, 0x131c0501, 0x38382814, 0x12131428,
    0x6b015d81, 0x00202082, 0x04200082, 0x1627c78a, 0x4e002600, 0x89040000, 0x09332bbc, 0x23012e01, 0x15020e22, 0xdd880110, 0x26213727, 0x01123703,
    0x20d8a217, 0x2dca8504, 0x03f7fd49, 0x85b52a6d, 0x305a995d, 0xe887c004, 0xf5029528, 0x3d6f3da6, 0xdf834301, 0xb020e89d, 0x012ddc86, 0x58f802eb,
    0x6c623f75, 0xfe80fe33, 0x28f88540, 0x1001bb81, 0x049cfe61, 0xa5ef82a8, 0x052f56f8, 0x80ff0023, 0x2e018205, 0x1f000f00, 0x37002f00, 0x00005b00,
    0x45341125, 0x11220542, 0xaa181614, 0x1f8d159d, 0x2721012c, 0x06212726, 0x14150507, 0x20452b06, 0x06557309, 0x3721332a, 0x2133013e, 0x011f1632,
    0x02200482, 0x0a9a4918, 0x0ba64918, 0x2d080b8b, 0xc001e0fd, 0xfe0a0730, 0x03070ac3, 0x600e126f, 0xc0fc425e, 0x0e605e42, 0x010e1212, 0x4e0f4635,
    0x28400128, 0x01460f4e, 0xa0120e35, 0x1683c002, 0x8340fd21, 0x270b9605, 0x0975ee03, 0x95090202, 0xfc292382, 0x7579534c, 0x12b80353, 0x080c820e,
    0x3425a72e, 0x12a72534, 0x00000300, 0x000680ff, 0x2c008005, 0x48003c00, 0x15010000, 0x23020e14, 0x34350022, 0x1e323300, 0x14011d03, 0x3d22012b,
    0x820b4465, 0x3b36250c, 0x02163201, 0x08178362, 0x497e0421, 0xcd397973, 0x1001edfe, 0x675322cb, 0x76103852, 0x8c488310, 0x448eb7b1, 0x7706098c,
    0x62fc0a06, 0x23081fa3, 0x326dce01, 0x01162b4e, 0x01cbcf16, 0x291b0910, 0x106d2d48, 0x312b4610, 0xc59792b7, 0x07462a30, 0x2b030909, 0x211fc562,
    0x87680000, 0x000e2209, 0x2dd98262, 0x22232634, 0x1415020e, 0x3e323316, 0xe6820501, 0x44220721, 0x0e2005d9, 0x2905fa55, 0x32333612, 0x013f1716,
    0xde82013e, 0x07161724, 0x2b830603, 0x35043e25, 0x82210010, 0x1e102d38, 0x37323302, 0x011f1636, 0x07060716, 0xea183383, 0x400808f3, 0x6bcc0300,
    0x627a3f5e, 0x60616b3d, 0x340255a0, 0x4b8c7b4a, 0x5f071306, 0x34051c2f, 0xb1a15e9f, 0x5785e284, 0x0b022688, 0x76050901, 0x02050805, 0x20190578,
    0x42583a1c, 0xfea4fe30, 0xabed82dc, 0x08cc8266, 0xb1e48252, 0x29081a0b, 0x0a020108, 0x9c85fb66, 0x7acee4fe, 0x1c01ce7a, 0x0158019c, 0x6cf902a8,
    0xa66c3d7a, 0x857a7061, 0xac6f11c7, 0x01023362, 0x42322135, 0x9daebf58, 0x479b0a01, 0x06381340, 0x0b050b0c, 0x18189afd, 0x09011a27, 0x4e763d27,
    0x5c012401, 0x2a072241, 0x0b020990, 0x0d0c0c31, 0x835a5309, 0x38012852, 0x7ace1c01, 0x820058fe, 0x00022300, 0xd753ff00, 0x00233d05, 0x00000028,
    0x010f1016, 0x0f141617, 0x2f220601, 0x2b060101, 0x13270501, 0x01373435, 0x0806b45f, 0x37011f22, 0x27010936, 0x44061501, 0x68e15ebc, 0x0ad20a0a,
    0xfd690a1a, 0xcb3525a5, 0x804000ff, 0x695b0225, 0x68311385, 0xc5fc5ddf, 0xfdc04002, 0xbc0006c0, 0xdf5df7fe, 0x21288268, 0x2b840ad2, 0x01408025,
    0x8435cb00, 0x821a202b, 0x680a2540, 0x40fa5ee1, 0xc0212b84, 0x308f8400, 0x0006fe06, 0x29001000, 0x32010000, 0x07141516, 0x076b5700, 0x36016608,
    0x1f011e01, 0x23001601, 0x35022e22, 0x3233031e, 0x06043e37, 0x2d69464f, 0x6185b4fe, 0x5cb57e79, 0xfc3b7e02, 0x538727ba, 0xf5fe0401, 0x73be7bd7,
    0x3844073a, 0x0e290f3e, 0x664a4119, 0x5d000668, 0xfd583f46, 0xb95b7b8b, 0x0254807f, 0xf6fb3643, 0x47166c4c, 0x5df4fed5, 0x0576cca2, 0x25222732,
    0x243b5d42, 0x0c0f5d0f, 0x6f002d3c, 0x8f007f00, 0x00009f00, 0x11211125, 0x37013e32, 0x3233013e, 0x1e17011e, 0x0d843302, 0x16200682, 0x0b840c82,
    0x0b831982, 0x2215132d, 0x2e27012e, 0x0e222302, 0x820e0701, 0x95262006, 0x2301260c, 0x3b363435, 0x20578201, 0x22038621, 0x4a163233, 0x3e24071e,
    0x16323504, 0x9107134a, 0x0721080c, 0x2d00f900, 0x1e1c2650, 0x2818232b, 0x241d1616, 0x502d2e50, 0x17151e24, 0x2b231827, 0x50261c1e, 0x201c855a,
    0x200c8422, 0x2723862d, 0x24502e2d, 0x2816161d, 0x32912383, 0x50821d84, 0x40507024, 0x01870001, 0x70504030, 0x384800fb, 0x1c134b35, 0x26131c22,
    0x0c98025a, 0x80fe8036, 0x1b1c8001, 0x0e161b18, 0x1a191310, 0x19191d1c, 0x160e1013, 0x1c201082, 0x09841584, 0xc0400122, 0x1c211d85, 0x8e1d851a,
    0x191a2a28, 0x50c0161b, 0xfec00170, 0x2f038740, 0x4d100370, 0x1d354b53, 0x1f20182c, 0x4c94263a, 0x00380c98, 0xff000002, 0x05000880, 0x00050080,
    0x2100000b, 0x33112115, 0x21010911, 0x08250382, 0x8000f800, 0x25d58206, 0xc00180f9, 0x0a824002, 0x0480fa2d, 0x0280fc00, 0xfd400240, 0x450000c0,
    0xc022060b, 0x39820006, 0x00103d08, 0x09000016, 0x23040601, 0x10022422, 0x13332412, 0x07021421, 0x32112113, 0x00031204, 0xfe6a2202, 0xfed19de5,
    0x01cece9f, 0x03bbd161, 0xa46c7805, 0x01d100fd, 0x8602ce61, 0x786cdefd, 0x01211582, 0x2c0d82a2, 0xfe9d00fd, 0xa2026ae5, 0xfece0003, 0x209b8c9f,
    0x259b871f, 0x06141101, 0x6e43012f, 0x01272d05, 0x011f3236, 0x36262701, 0x16322133, 0x072faf84, 0x79102700, 0x1a0a87fd, 0x60fee90a, 0x834902c0,
    0xd0012908, 0x15111079, 0x120eb301, 0xe024c385, 0x11154dfe, 0x24872584, 0x83e90a21, 0x12272223, 0x82ed8200, 0x000725d8, 0x60005704, 0x143a0c82,
    0x17031e17, 0x06141504, 0x062e2223, 0x23032e27, 0x15010e22, 0x32331614, 0x23723637, 0x22212c05, 0x34350226, 0x3233023e, 0x8217061e, 0x35362217,
    0x08288234, 0x343526c0, 0x011e1736, 0x021e2317, 0x27260717, 0x22232635, 0x0a0c0506, 0x24341e0a, 0xd3450125, 0x4e693b95, 0x1e39324c, 0x3b200b31,
    0x60527858, 0x9dd566ae, 0x1b3851b1, 0x011d0f54, 0x93fffe83, 0x915788f5, 0x905769c7, 0x3b3a5767, 0x601a3a2a, 0x26735189, 0x5857523f, 0x030b384a,
    0x554e6faf, 0x160c0130, 0x1a81041e, 0x314a171c, 0x06400346, 0x1b291d23, 0xf15b0a0d, 0x3625c192, 0x4f7f505f, 0x69511c86, 0xb26f2858, 0x5fefa060,
    0x2298353f, 0x9e980124, 0x69920101, 0x265c97ca, 0x8664623e, 0xc8369273, 0x3c2a5061, 0x2d171f20, 0x1046693b, 0x04a46e11, 0x0b2a1703, 0x63052d1b,
    0x15011531, 0x0b460042, 0x00572d0b, 0x01000067, 0x022e2734, 0x012e3427, 0x2705a36f, 0x37171623, 0x012e2726, 0x1521d782, 0x30e98314, 0x011d031e,
    0x22230616, 0x23052e27, 0x17010e22, 0x05fb4515, 0x46273721, 0x3627062a, 0x17163233, 0x5c33071e, 0x134b0bd4, 0x054e0805, 0x2423ea98, 0x02040928,
    0x11362431, 0x5d131401, 0x45210a27, 0x027c5033, 0x1d646110, 0x011b3228, 0x46613b53, 0x45273917, 0x6553804f, 0x04036ab6, 0xba6dae5d, 0x3c0b145d,
    0x7359722a, 0x7068a498, 0x23082e74, 0x37242916, 0x6b2a4c38, 0xe5656898, 0x0149080b, 0x0a42ade4, 0x021c250d, 0x24020b0d, 0x240f0f2f, 0x1d0a3647,
    0x07507314, 0x1d586010, 0x291c0f08, 0x463a051a, 0x66952f90, 0x70314877, 0x6c0164b8, 0x1b6e71b6, 0x48506d18, 0xa86975ae, 0x5f15776b, 0x44395b3a,
    0x028b1b27, 0x0b1166e5, 0x03000022, 0x2606e35d, 0x000f0000, 0x8233001f, 0x05206f0d, 0x021e1426, 0x24013e32, 0x23270c82, 0x10121621, 0x82210702,
    0x1012390e, 0x2123020e, 0x10022e22, 0x2133023e, 0x04011e32, 0xbd8a5180, 0x518abdd0, 0x03200685, 0x68320783, 0x8b777efe, 0x8201778b, 0xd18abd68,
    0x82edab66, 0xe54600fd, 0x83032007, 0x18022109, 0x37863089, 0xfe5a512c, 0xfeccfef4, 0x8a515af4, 0x1f48a701, 0x05bf410e, 0x0800002d, 0x00000500,
    0x00230013, 0x85011800, 0x8602207d, 0x0401218d, 0x2208d66f, 0x83011e14, 0x20678471, 0x217b8866, 0x718cb204, 0x6bfe0121, 0xed20061e, 0x91206a86,
    0x0020c48c, 0x00226883, 0x06830900, 0x000e2508, 0x00180012, 0x005c002c, 0x22210100, 0x26013f26, 0x10062223, 0x36323316, 0x27263327, 0x07210105,
    0x10041716, 0x20081482, 0x06161307, 0x22230607, 0x15060327, 0x00201614, 0x00200010, 0x37363435, 0x2b060127, 0x23010e01, 0x2d118222, 0x37173233,
    0x34262223, 0x15213336, 0x09862721, 0x17325c08, 0x32333601, 0xc6fefa02, 0xbc182328, 0xbc844841, 0xb07384bc, 0x3912baa3, 0x20017101, 0x696320fe,
    0xbc050515, 0xae3d3c84, 0x0f160a0f, 0xae122315, 0x0801bc5d, 0xf9fe3c01, 0xf9fe8efe, 0xfe41464f, 0xc521129f, 0xb9a8fc17, 0x0701f9fe, 0x896572b9,
    0x26261ae0, 0x0180011a, 0x84de55b3, 0x002e0809, 0x0b011421, 0x01b9655b, 0xfb204680, 0xf8febc1f, 0x55ef91bc, 0x8001943f, 0xc4956784, 0x18bc0801,
    0x3417fcfe, 0x011d0b0e, 0x84825f04, 0x578401bc, 0x61354982, 0xfe623fad, 0xdca41a2b, 0x72010701, 0xb7370701, 0x80263426, 0x26048280, 0x2c70fe1c,
    0x7e050000, 0x072a087f, 0x1f000f00, 0x4b002b00, 0x424e0000, 0x5d242007, 0x032f07f3, 0x2123012e, 0x03070622, 0x21331606, 0x18023632, 0x200c4778,
    0x061c6823, 0x07862120, 0x3411232c, 0x013e1337, 0x16042024, 0x1f5e1317, 0x4b042307, 0x02826a4b, 0x481d2008, 0xfc172305, 0x0523176a, 0x1e260548,
    0x261e2604, 0xfd141ce7, 0x1c1c1480, 0x14800214, 0x8280ac01, 0x00fd2125, 0x80300482, 0xb1096719, 0x56011b01, 0x09b11b01, 0x0b011769, 0x3d0aff5d,
    0x80010c02, 0x171d1d17, 0x2e1e80fe, 0x286e022e, 0x1c281c1c, 0xa5fd5bfd, 0x4b4b3580, 0x05858035, 0x705b0230, 0x4ec6016f, 0x763c3c76, 0x663afe4e,
    0xe7820300, 0x0008882a, 0x0b00f805, 0x52002e00, 0x1421e382, 0x22d28206, 0x82363426, 0x340526d0, 0x26222127, 0x210b8335, 0x46702426, 0x5a212006,
    0x212a05c8, 0x32330416, 0x1401023e, 0x44692b06, 0x22232406, 0x84232700, 0x013b212d, 0x123b3382, 0x32332436, 0x32331700, 0x32b70516, 0x2442fd24,
    0x02243232, 0x080124be, 0x832afc17, 0x8c032c0b, 0xaddafe58, 0xafd3feb1, 0x83d60317, 0x74fc3910, 0xad270158, 0x68aef284, 0x24327301, 0xdc831183,
    0xf6a7cffe, 0xbd636bfe, 0x84201d83, 0x013d0f82, 0x01f5a831, 0x24bc6395, 0x46e30232, 0x33463333, 0x32545656, 0x8f322423, 0xd4feafa8, 0x320b87b1,
    0x01f1af67, 0x55322384, 0xcffea755, 0x0a0183dd, 0x842432d9, 0x012e080d, 0xfe83dd31, 0x0032d9f6, 0x0b000600, 0xf50400ff, 0x07000006, 0x1b000f00,
    0x75002c00, 0x0000a300, 0x12170301, 0x22233435, 0x36171601, 0xda822e37, 0x33361335, 0x26031732, 0x03062223, 0x33011e14, 0x34353632, 0x84032e27,
    0x8317200e, 0x3637320f, 0x012e3411, 0x23242627, 0x15060722, 0x37041e14, 0x2b308232, 0x07061716, 0x010e0706, 0x15161415, 0x26251682, 0x16230627,
    0x06fc5215, 0x46163721, 0x26200678, 0x07214582, 0x08287c34, 0x34350222, 0x13266b82, 0x053e1716, 0x2d823233, 0x1e032a09, 0x02141503, 0x2223010e,
    0x03022627, 0xa57572b9, 0x8cfe3926, 0x2225031e, 0xfe232a0c, 0x20119fcd, 0x4b793c0f, 0x4f141330, 0x0e228467, 0x260d2017, 0x141d4239, 0x3b199e33,
    0x9be39df9, 0x14150298, 0x73c9fe38, 0x2b0c0c25, 0x52585744, 0x1807101d, 0x1c040f10, 0x40203d44, 0x04032559, 0x21080989, 0x52365102, 0x083421a9,
    0x1d0c384d, 0x362b1daf, 0x1c5e5572, 0x291d3d7a, 0x834e52a3, 0x060206c2, 0x3e43292e, 0x5247254f, 0x264f3d9f, 0xfcaa5e0e, 0x95706f98, 0xfe8604da,
    0xc30115b8, 0x70fc3843, 0x192a0850, 0x03070702, 0x59fe6285, 0x5f01050a, 0xf5fc23dc, 0x1a8ca624, 0x204e180e, 0x36406250, 0x3f299dfe, 0xa9aaa491,
    0x302b0201, 0x3531124c, 0x221e050b, 0x04131c34, 0x13130204, 0x161a1c24, 0x45882e18, 0x0c1e731f, 0xce0a020c, 0x350e0702, 0x22519c49, 0x680c4021,
    0xde220c11, 0x7c653759, 0x3e1e4a1a, 0xce010f7a, 0xfd655069, 0x100611bb, 0x65916e7f, 0x6c496248, 0x3e0f46fe, 0x96405d5e, 0x6ebefcfe, 0x0d01392a,
    0x21008200, 0x17490004, 0x001a2a07, 0x005b0036, 0x0100005f, 0x0bcc4633, 0xfd462320, 0x021e2406, 0x98253233, 0x25362c19, 0x2e272634, 0x21262702,
    0x820e0720, 0x01320893, 0x17161415, 0x1617021e, 0x37202104, 0x3e37023e, 0x21111301, 0xcf110311, 0xa282a90e, 0x948cbab9, 0x05cb0da8, 0x3f39333d,
    0x27361a0a, 0xced6025f, 0x1787a80e, 0x3e04cc23, 0x08178332, 0x31273541, 0x1f6d0137, 0x1c0f062d, 0x9dfd5602, 0x05558ffd, 0x2d061119, 0x062d1e1e,
    0x2c061712, 0x13018701, 0x05576202, 0x2e051118, 0x00f8c01e, 0xb59e1002, 0xebc2c8e8, 0x4640a0ae, 0x48307579, 0x8f8b2443, 0x4c270810, 0x3dc8cfb6,
    0x02120c08, 0x0f043f3f, 0xc73c080d, 0x3dc7d0d1, 0x050e0e08, 0x04412021, 0x3c090e0e, 0xfacb03c6, 0x83000600, 0x00022100, 0x052a0082, 0x00800560,
    0x003b001d, 0x7f6f0100, 0x26342308, 0x0c892123, 0x21333625, 0x82011e32, 0x010e211d, 0x2c05f158, 0x013b3634, 0x11151632, 0x35363221, 0x2a0c8511,
    0x0e12e003, 0xa0120ea0, 0x84f0fe70, 0x0e122f08, 0xe487d001, 0x85800185, 0x30fe87e4, 0x1484120e, 0x70100123, 0x230884a0, 0x10fe9003, 0x01251383,
    0xfba070f0, 0x29098380, 0x120e4005, 0x4901e485, 0x358290fc, 0x030e1222, 0x2405dc4f, 0x0370a000, 0x411e8270, 0x062b07c3, 0x00800500, 0x003e000f,
    0x18630053, 0x22110bc2, 0x56343505, 0x2b26051f, 0x1d062201, 0xa4821401, 0x9307ae4f, 0x8225200d, 0x22cf822e, 0x85111506, 0x82162029, 0x10e5532f,
    0x1b1f0527, 0x1c18ca18, 0x0804821c, 0x16fe1b27, 0x44853541, 0x82441c1c, 0x37154135, 0x5e191b16, 0x36151c18, 0x61181c16, 0x37161b18, 0x424d0215,
    0x35f8fe35, 0x340a8242, 0x35bf3f1f, 0x60887e42, 0x8860d0fb, 0x30046088, 0xb6028860, 0x83458372, 0xfafe2b04, 0x34344135, 0x16fa3541, 0x1383e616,
    0x0788e620, 0x359a762e, 0xfe354141, 0xb4151566, 0x9d02412a, 0x88223d89, 0xab500000, 0x00022409, 0x82190009, 0x1b2123fd, 0x01832101, 0x99560920,
    0x032d080f, 0x93dafe93, 0xfe3701e9, 0xfe48febc, 0x013701bc, 0xaa6a027f, 0x7640fc76, 0x0376aaaa, 0x01aa76c0, 0xfc2702c2, 0xfc000497, 0x023a0100,
    0x211789a6, 0x008200aa, 0x00173f08, 0x0800ff00, 0x00000600, 0x0055004d, 0x00680061, 0x0072006d, 0x007f0078, 0x00890084, 0x00960091, 0x00a0009c,
    0x00a700a4, 0x00af00aa, 0x00bb00b8, 0x00c100be, 0x010000cb, 0x03070614, 0x05871516, 0x27222324, 0x03830621, 0x26222328, 0x03373435, 0x0587012e,
    0x13373623, 0x20128334, 0x25048213, 0x17323336, 0x03833621, 0x82323321, 0x1307253b, 0x1415011e, 0xd8820583, 0x82012321, 0x84012019, 0x37172915,
    0x07062711, 0x25172101, 0x22085382, 0x27373601, 0x03372307, 0x37011701, 0x36012113, 0x21013305, 0x03161711, 0x0f013721, 0x07353301, 0x83141116,
    0x172f0834, 0x17113711, 0x07012f01, 0x06273711, 0x17052325, 0x25020915, 0x07051127, 0x13170133, 0x3d26022f, 0x27260301, 0x03350209, 0x01132313,
    0x83013f07, 0x3738088e, 0x3617010b, 0x141a0008, 0x141903cd, 0x182103c1, 0x70fe1019, 0xfe113411, 0x171a1171, 0x14c10422, 0x14ce0319, 0xc7141b19,
    0x04d12201, 0x121a1722, 0x36108c01, 0x128e0110, 0x83081d83, 0x072017cf, 0xfc1913bb, 0xfe850127, 0xaafe8faa, 0x2a126801, 0x02015bfc, 0xbbbc0fd0,
    0xa802100d, 0x02be7cfe, 0x10e8fe2a, 0x01af022c, 0x1e114004, 0xd8fefc16, 0x1077013f, 0x0155fe41, 0x70fc084d, 0xfe560105, 0x120e048b, 0xfe409201,
    0xa3c19dcb, 0x080104a8, 0x01991eab, 0x04dfdf29, 0x0306bfcd, 0x93fd1077, 0x01d7fed5, 0xfd280137, 0xe601887b, 0x2501552a, 0x010384ee, 0x05d80816,
    0x014bfe08, 0xa3c0fc36, 0x04350082, 0x2882303d, 0xab0302cf, 0x02054d81, 0x041f1581, 0x09099cfe, 0x38068214, 0x170808af, 0x14141222, 0x08182114,
    0x044f010c, 0x0909141f, 0x1f056401, 0x2d238214, 0x04015801, 0x010f2401, 0x18080a6b, 0x00821521, 0x18213e08, 0x9afe0c06, 0x0d162101, 0x04bcfe0e,
    0x01cdfc1f, 0x109efe62, 0x09041c03, 0x98fe050a, 0x5b01c706, 0x010208c2, 0x10c8c8c0, 0x050654fb, 0x01694f44, 0x40cdfe0a, 0x011c90fe, 0x04a9fe36,
    0x082d820f, 0x0506b176, 0x01427801, 0xbddda641, 0x350308b1, 0x10010201, 0x0d01b10d, 0x9dc9fe0b, 0xdeec3a01, 0x4af8fe08, 0xe00c02c9, 0xc5fe2be1,
    0x3301c1fe, 0xe4fe8d0f, 0x88012cdd, 0x057002fb, 0x100d1501, 0x01780102, 0xfe31fe04, 0xdff601b9, 0x89fce6fe, 0x1b01e5fe, 0x0146e3e3, 0x01040a69,
    0xfd28010f, 0x0003529c, 0xff000002, 0x06800500, 0x000d0000, 0x1100001b, 0x21333634, 0x22080c43, 0x49112725, 0x3608056d, 0x16141115, 0x0283b733,
    0xb76001e6, 0x83f4fc83, 0xb0d004b7, 0x1cfe2e40, 0x2d41402e, 0xbf835803, 0x42fa6601, 0x84bebe84, 0xa901b424, 0x2e42422e, 0x432e14fe, 0x82040000,
    0x06833c5b, 0x007d0500, 0x0014000a, 0x0029001e, 0x00040100, 0x34352603, 0x32332412, 0x83171605, 0x1227260c, 0x00120100, 0x080c8525, 0x27260577,
    0x00360706, 0x16070637, 0xc3fea603, 0x147722fe, 0xd06001cd, 0x5d640152, 0xfd7bfe47, 0x3e5d6fc5, 0xfe360270, 0x110273a3, 0x0e286301, 0x40fedcfe,
    0xcf036777, 0x9b87aec1, 0xcc4a016d, 0x05415015, 0x1dfe796a, 0x5759c1fe, 0xcd6101d0, 0x715a418a, 0x7bfec1fd, 0x82015a48, 0x3cfb3a02, 0x14026401,
    0x78675c76, 0xdbfe3efe, 0x4132140e, 0x01cd1754, 0x84986e4b, 0x061b44af, 0x04000829, 0x001600f7, 0x823b002b, 0x221326a9, 0x22232627, 0x2f038307,
    0x13012b06, 0x17322136, 0x01203336, 0x03171632, 0x03231787, 0x8233023e, 0x03372215, 0x22268406, 0x83013e03, 0x1779080e, 0x839b6507, 0xe2c1c87e,
    0xc1e29494, 0x057c80c8, 0x0201e09b, 0xe99a9ae9, 0xf1fe0201, 0x7c9dce81, 0x96e0c5ab, 0xabc5e096, 0xb079697c, 0xacacca5a, 0x94d337f2, 0xa0b0de98,
    0x75d17c72, 0xcaaca5d1, 0x08fb7804, 0x94945b39, 0xf804395b, 0xfb6a6a7f, 0x034139a6, 0x8d8d4efd, 0x2b03fc4e, 0x6c6c232c, 0x048b0322, 0xfc429b97,
    0x66323353, 0x0000056b, 0xff000005, 0x050008a5, 0x086f715b, 0x87565c20, 0x10b75631, 0x1805a34a, 0x2d0e6945, 0x1415011e, 0x05011e07, 0x5d141edc,
    0x04841e14, 0x1ee4fe24, 0x0b836514, 0xfe200482, 0x0b931782, 0x88052108, 0x24fba6ec, 0x697eeca6, 0x6671a10a, 0x2a012d4e, 0x93fc95bd, 0xa5ac870e,
    0x1e15dd02, 0x23fd151e, 0x02214083, 0x21058313, 0x0583edfd, 0x83ad0121, 0x53fe2105, 0x6a200b84, 0x96200b84, 0x77080582, 0xececa6a6, 0x32c574a6,
    0xa1712722, 0x93eab743, 0x384295fc, 0x0000db21, 0x00002700, 0x00063eff, 0x04000006, 0x0d000900, 0x15001100, 0x1d001900, 0x25002100, 0x2d002900,
    0x35003100, 0x3d003900, 0x45004100, 0x4d004900, 0x55005100, 0x5d005900, 0x67006100, 0x6f006b00, 0x77007300, 0x7f007b00, 0x89008500, 0x91008d00,
    0x99009500, 0xd500a500, 0x21110000, 0x25010911, 0x35270584, 0x15131521, 0x8f173523, 0x17372303, 0x038a1707, 0x17013f23, 0x20038b07, 0x202f8201,
    0x83039a21, 0x1533221f, 0x26219637, 0x35233517, 0x92071533, 0x22252103, 0x2805fd45, 0x06141516, 0x021e1401, 0x23088236, 0x23272223, 0x21084f67,
    0x20820601, 0x33013e3f, 0x33171632, 0x23062e37, 0x06020e22, 0xfdf8fc00, 0xfa9c0508, 0x029502c8, 0x51c8faa3, 0x24008725, 0x0f690f3f, 0x2003821f,
    0x2607841e, 0x694f0f68, 0x8278690f, 0x86792003, 0x41fc2a07, 0x73140172, 0x01731501, 0x89088214, 0xb8fb240b, 0x8fa27325, 0x4ef02217, 0x08588873,
    0x88fd254b, 0x81b8b881, 0xfeb7b782, 0x443c27d9, 0x6170273c, 0x431f031a, 0x38371d5f, 0x4f503723, 0x15282937, 0x030f4922, 0x0924031e, 0x161a0e1e,
    0x35371d0c, 0xfa000621, 0x01aefe90, 0x9e034152, 0xdafe62fc, 0xc9c92805, 0x7373d6fe, 0x27028a94, 0x212f228f, 0x222e220e, 0x0d2b0383, 0x22222e21,
    0x5e2f212e, 0x832e222e, 0x2f5d2603, 0xd1042e22, 0x23008e24, 0x734facfe, 0x7322128d, 0x538c244f, 0x23225f82, 0xad8582b7, 0x7d012708, 0x05092924,
    0x31151301, 0x0a2a3f33, 0x2e1f2c16, 0x0b01072f, 0x06181514, 0x013a1716, 0x030b030f, 0x170a0206, 0x0082002d, 0x0000032e, 0x000873ff, 0x07008d05,
    0x2a001000, 0x770ec34e, 0x1d21139c, 0x07f27201, 0x5f032508, 0x9e9ee09f, 0x9efe03e0, 0xe09f9fe0, 0x2d3fe001, 0x3f2dd8f8, 0xaf012d3f, 0xf202402c,
    0xaf012c40, 0x88013f2d, 0x9e201b83, 0x702c2883, 0x38049e71, 0x3f2cbcfa, 0x44052c3f, 0xa1210583, 0x820582a1, 0x00022871, 0x08280000, 0x82d90400,
    0x005a2407, 0x4e050100, 0x22230542, 0x5f23072e, 0x3e2108e9, 0x05214802, 0x23040628, 0x35012e22, 0x49180034, 0x062d0b22, 0x35262223, 0x34353634,
    0x0e222326, 0x220c8402, 0x85013e37, 0x36a90830, 0x04019605, 0x9edad294, 0x727a9a55, 0x78726768, 0xc39a5398, 0xd8649fd0, 0x1c200555, 0x3c150e08,
    0x7ff5fe65, 0x0187e185, 0xd578ce1b, 0x8685919e, 0x85665aa5, 0x671e5f81, 0x111f1411, 0x6b3a9fd7, 0x0f08323d, 0xb03b1915, 0x04febf5e, 0xccb90339,
    0xd19d92c5, 0x84785c37, 0x375c7885, 0xba9d99b7, 0x1d043d4b, 0x180e1513, 0x746c5835, 0x01cd86d6, 0xa78b5710, 0x7b578ba8, 0x25805f65, 0x4e12141e,
    0x25d09f14, 0x0f15252c, 0x49431b13, 0x1d25befb, 0x0004000f, 0x0680ff00, 0x00000580, 0x0023001b, 0x0057002b, 0x26340000, 0x24d5822b, 0x1d062226,
    0x29f48201, 0x013b1614, 0x32161415, 0xc5823d36, 0x06140028, 0x36342622, 0x07860432, 0x1411132d, 0x1e050706, 0x07141502, 0x44163221, 0x3e2307ea,
    0x51033701, 0x1e220753, 0x19821704, 0x26c0042a, 0x3426801a, 0x261a8026, 0xfd270887, 0x4b6a4be6, 0x6e036a4b, 0xcb2a056d, 0xecfb1920, 0x18050701,
    0x22839803, 0x1a00fc28, 0x02251626, 0x3651ccb1, 0x19102b05, 0x07040b0f, 0x1ab10401, 0x458d0326, 0xfd204e83, 0x2d0b586e, 0x00fec003, 0x7a032518,
    0x0a181d07, 0x2c823010, 0x0e1a2627, 0x03044433, 0x260a8237, 0x161f120d, 0x82260725, 0x26f78ae2, 0x001f0017, 0x82530027, 0x26342514, 0x11010f22,
    0x2005466f, 0x26fe8227, 0x16011714, 0xb7013732, 0x000525f3, 0x93133426, 0x93287682, 0x13263413, 0x34130001, 0xfd210482, 0x24f5b893, 0x25019213,
    0x23ef821a, 0x1392dbfe, 0xff225982, 0x4f831300, 0x54512220, 0x20fba60a, 0x05574b07, 0x80052008, 0x05000200, 0x0c000900, 0x14001000, 0x00002600,
    0x21030913, 0x09211327, 0x21252102, 0x82012103, 0x5f252001, 0x223d0532, 0x012e0127, 0x33360137, 0x02d43221, 0x01d4fe6f, 0xfd5d01e9, 0xfecc8946,
    0x03e0fefa, 0x081182fd, 0xc2fcbd3a, 0xfeccaa02, 0x016f02ee, 0xfee0fe5a, 0x015901fa, 0x10020e80, 0x3a1240fc, 0x1040fc12, 0x80010e02, 0x80042112,
    0xfd000321, 0xfc990267, 0x800403fc, 0x80fe8001, 0x9902e7fc, 0x31080884, 0xfe668001, 0x112f1200, 0x141400fc, 0x2f110004, 0x1a000212, 0x13000300,
    0xed0700ff, 0x49000006, 0xa0009700, 0x36050000, 0x07011f32, 0x22060727, 0x049d012f, 0x1c7b3720, 0x83372005, 0x20049330, 0x87428325, 0x03113624,
    0x013f3626, 0x21353311, 0x21152135, 0x17113315, 0x0307011e, 0x9f378911, 0x15012572, 0x23350525, 0x072d3c82, 0x13341313, 0x53535a80, 0x53123612,
    0x980b8253, 0x9b248304, 0xfa53221f, 0x824a862d, 0x40532906, 0x1e1411d2, 0x000180b1, 0x80250183, 0x11141eb1, 0x846983d2, 0x2a6ea05d, 0x80014001,
    0xfe808001, 0x84131300, 0x1313219b, 0x03943782, 0x19949484, 0x83795321, 0x5252303b, 0x40521313, 0x3a012501, 0x3a0a3d1a, 0x82802b01, 0xd5fe2a00,
    0x1a3d0a3a, 0xdbfec6fe, 0x821c8212, 0x21449a20, 0x30821a04, 0x00210282, 0x057f4300, 0x0680053d, 0x00030000, 0x00430007, 0x21000076, 0x01012f13,
    0x01010f13, 0x23262726, 0x4a060722, 0x06310537, 0x1e171607, 0x091e1701, 0x033e3233, 0x1e32013b, 0x26088203, 0x013e3708, 0x44013637, 0x0327086f,
    0x26332737, 0x83373435, 0x26198303, 0x32163233, 0x83323336, 0x15162f38, 0x07160714, 0x031e0733, 0x60604002, 0x7e820180, 0x00016030, 0x560a0202,
    0x1c076146, 0x56466107, 0x0083020a, 0x020b2208, 0x0c030b02, 0x110b0d05, 0x240d1712, 0x0d0a132e, 0x0d0b0c0b, 0x242e130a, 0x1112170d, 0x0c050d0b,
    0x08228303, 0x0102025f, 0xfc7992a2, 0x09927996, 0x35512e1d, 0x0216d65a, 0x4511d2c2, 0x1e2c2024, 0x1e6c3c6c, 0x4524202c, 0x07c2d211, 0x3f52d61b,
    0x01102a59, 0xfd4080c0, 0x40800280, 0x04320280, 0x02130802, 0x02081302, 0x03091204, 0x21040707, 0x14081a08, 0x04040c07, 0x19222319, 0x19232219,
    0x070c0404, 0x08148214, 0x0704212f, 0xfc090307, 0x8a8a79a3, 0x89723d79, 0xdc1a616e, 0x140c4040, 0x2a393828, 0x252a903e, 0x2a253e3e, 0x392a3e90,
    0x4f512838, 0xa07f21e1, 0x0637588f, 0x0005fd37, 0x5c004c00, 0x00007000, 0x020e1601, 0x27012e27, 0x27373626, 0x051d6a0e, 0x560e2321, 0x263509f8,
    0x2622012b, 0x013b3634, 0x17021e32, 0x23273321, 0x3e372622, 0x220e8201, 0x8337011f, 0x1d163e15, 0x2b061401, 0x17361701, 0x3201011e, 0x22213736,
    0x13372627, 0x06222326, 0x01281610, 0x10635736, 0x0cfd0834, 0x67bb8244, 0x0c10eda1, 0x60474f4f, 0xff1b256e, 0x06574500, 0x4c220808, 0xb57b184c,
    0x26261a40, 0x864e801a, 0x021d2c63, 0xde557300, 0x0405261e, 0x21fd1826, 0x13724614, 0x1c83651b, 0x8373b33b, 0xf8ca8f90, 0x17b073d4, 0x1423c6fe,
    0x2f931112, 0xbcbc842c, 0x08018005, 0x0d7357bc, 0x67f40132, 0x074c88bf, 0x6fa0e40b, 0x506b47c7, 0x271b82e4, 0x32071957, 0x266e2d1b, 0x321b2634,
    0x2d80161d, 0x1c1e171e, 0x82137269, 0x261a3576, 0x1a1b3fac, 0x91fbfdd9, 0x1f201f6f, 0xbc0d1501, 0xbcbcf8fe, 0x080f6e57, 0x03000038, 0x00ff0000,
    0xe0058005, 0x4f003500, 0x00005700, 0x020e1421, 0x35022e20, 0x37023e34, 0x16171636, 0x040e0706, 0x32041e07, 0x2e37033e, 0x012e2704, 0x17013e37,
    0xab52031e, 0x42112005, 0x112c068c, 0x35262223, 0x33363411, 0x02163221, 0x08062547, 0x7b80055b, 0xfafef5cd, 0x427bcdf5, 0x1a477874, 0x1f05042c,
    0x39603a1a, 0x03010f28, 0xbf826230, 0x6282bfd4, 0x0f010330, 0x3a603928, 0x04051f1a, 0x78471a2c, 0x80fe4274, 0x26401a26, 0x1a00ff1a, 0x261a4026,
    0x8001354b, 0x83604b35, 0xba8383ba, 0x1f3d653f, 0x3f653d1f, 0x23364f31, 0x824a820c, 0x1b0a3550, 0x04101718, 0x1e231f0b, 0x241e1414, 0x0e040c1f,
    0x0a1b1718, 0x4f824982, 0x36230c29, 0xfe4f034f, 0x83261a80, 0x1a262203, 0x83588201, 0x014b224c, 0x224d83a8, 0x82020083, 0x078021f7, 0x003bf982,
    0x003f001b, 0x0e210100, 0x01010f01, 0x01272206, 0x32212726, 0x011b3736, 0x8233011e, 0x17132607, 0x07140116, 0x2bf88221, 0x0b070607, 0x22012e01,
    0x21030706, 0x08053c4b, 0x17021e8a, 0x3233033e, 0x01000516, 0x040a0531, 0x1291fd03, 0x90fd1234, 0x71011005, 0x46052316, 0x162206be, 0x92062215,
    0x27021238, 0x6f8ffe67, 0x2d132308, 0x06c4810b, 0x05222c23, 0x6759fe74, 0x813ee0fe, 0x2424506f, 0x3e816f50, 0x0002fee0, 0x04030906, 0x1212a8fd,
    0x12025a02, 0x1901151b, 0x1a1465fd, 0xe501141a, 0xac012370, 0x11dd9b91, 0x29050214, 0xae0252fe, 0x151b1a14, 0x919b30fe, 0x492bf8dc, 0x40242440,
    0x00f82b49, 0x022acf82, 0x800400ff, 0x2b00fc05, 0xcf823300, 0x07001423, 0x429a8211, 0x152905d5, 0x012b0614, 0x013d2622, 0x33048323, 0x013b3634,
    0x02012e11, 0x37023e37, 0x24120436, 0x00200010, 0x04250382, 0xd9d9fe80, 0x344618e0, 0x2d0a8509, 0x0c81f396, 0x85e18b0b, 0xae2a01aa, 0x8b5900fc,
    0xf9fe3005, 0xc0038efe, 0x18b9fedd, 0x0e12fcfe, 0x8a120e40, 0x04013335, 0x1201ae10, 0x92e6869b, 0xfe92130f, 0x8efe12ea, 0x3585f9fe, 0x220b075d,
    0x822f0027, 0x163222a3, 0x08e55415, 0x1516012e, 0x22020e14, 0x3e34022e, 0x17323302, 0x08dda018, 0x00259b85, 0x1ac00510, 0x296b8426, 0x5b7e82fe,
    0xd5ead59b, 0x06825b9b, 0x9ccb7526, 0xfbfe7e01, 0xfd25b483, 0x01720167, 0x269a8307, 0x8005f9fe, 0x64fe1a26, 0x062505b6, 0xcb9c81fe, 0x832d8575,
    0x017e2234, 0x2146847e, 0xcb8980fa, 0x00820020, 0x00000236, 0x800400ff, 0x3d000006, 0x00004500, 0x15121601, 0x15070014, 0x321a4241, 0x35002635,
    0x26371234, 0x3b362627, 0x1e173201, 0x44363201, 0x07210549, 0x26b48706, 0xb1913e03, 0x84d9d9fe, 0x84602089, 0x3a0a8576, 0xb1d9fed9, 0x063fa591,
    0x15451113, 0xecc02c08, 0x1d082cc0, 0x0613113d, 0x89a4fd3f, 0xc4042ac4, 0xa7ebfe48, 0x18b9fedd, 0x843a8a84, 0x1884370a, 0xa7dd4701, 0x60481501,
    0x141b10b1, 0x6a82826a, 0xb1101b14, 0xd28adcfb, 0x02000222, 0x22069b51, 0x824a0042, 0x059c43cf, 0x23076f41, 0x1607013d, 0x2e2edfa0, 0x36370201,
    0x16363700, 0x22232517, 0xd4873526, 0x12000425, 0x4120010e, 0x7e20078d, 0x9531df93, 0x100c82f3, 0x76cb2001, 0xff0058dc, 0xfd120e86, 0x26d68987,
    0x120ee005, 0x82fe1a26, 0x0e122505, 0xc99eff86, 0x1030e095, 0x9b1101ae, 0x172b01cc, 0xfe46420e, 0x60fb0e12, 0x002dda8a, 0xff000002, 0x06800600,
    0x006b0000, 0x2fdbb573, 0x34350026, 0x0e072737, 0x2e012f01, 0x27013f01, 0x44062143, 0x364307c4, 0x37172105, 0x08a95818, 0x41203621, 0x05200d04,
    0x31210441, 0x7ed9fed9, 0x1a096534, 0x010a300a, 0x126f6909, 0xf883400e, 0x0e200128, 0x850e1212, 0x1886566a, 0x9e395a25, 0x419e9201, 0x18313625,
    0xc9dd4701, 0x0a6f359e, 0x082c0801, 0x70730a1b, 0x415c8386, 0x6b21089c, 0x2318865e, 0x7e7e3863, 0x3a104541, 0x00050000, 0x0600ff02, 0x00fd05fe,
    0x003e0038, 0x0052004b, 0x0100005f, 0x44060216, 0x2120133a, 0x3f164444, 0x36370036, 0x16173617, 0x10360100, 0x03100627, 0x35263732, 0x23263734,
    0x00100022, 0x27261101, 0x01214c82, 0x2d0b8232, 0x16072223, 0x16071415, 0x810cfe06, 0x314496f3, 0x00fe210a, 0x080a4344, 0x81f3962d, 0x2701110c,
    0xababcecd, 0x2701cdce, 0x808093fc, 0x6773c080, 0x73679a9a, 0x01f9feb9, 0x89f90207, 0x02897777, 0x0701b940, 0x84b9f9fe, 0xef032618, 0xaeeefe9b,
    0x0c8a4410, 0x3b119044, 0x132d01ce, 0x15737315, 0xfdd3fe13, 0x6c0183ca, 0x94fe8383, 0xa539f6fe, 0x39a7e0e2, 0x2a053444, 0x040180fe, 0x0f4f4f0f,
    0x4401fcfe, 0x3938061b, 0xa5e2e0a7, 0x04000039, 0x06ff0100, 0x00068007, 0x50004600, 0x6c005e00, 0x2b137342, 0x0607011e, 0x24060700, 0x37032e27,
    0x20053a47, 0x066d4525, 0x44213321, 0x3d2409e8, 0x17160701, 0x08065043, 0x27340126, 0x1415010e, 0x25013e17, 0x26171614, 0x37003435, 0x2223012e,
    0x00320100, 0x27263435, 0x00141516, 0x06011e07, 0x380c6942, 0x1f163f4c, 0xd2b7f2fe, 0x7543a3fe, 0x085093d0, 0x87e28a09, 0x0059db76, 0x0df941ff,
    0x223bfe24, 0x148492b6, 0x0400fe24, 0x0282daa2, 0xde80fc32, 0x0e0103a5, 0x87dd35cb, 0x03f9feb9, 0x0701b9c0, 0xfe211082, 0x211082f2, 0x91436004,
    0xee5f320b, 0xfcfeb680, 0xbfda1d1a, 0xdea36706, 0x95ea8777, 0x0583430f, 0x258b4020, 0x095f4a2d, 0x0e12fe73, 0x2614a0fe, 0x84a7fa19, 0xfca83104,
    0xd21e1d17, 0x78253f01, 0xfcf9fe92, 0xb9070107, 0x1c241182, 0xc1fed21f, 0x00311182, 0xff060004, 0x06000800, 0x004a0000, 0x005c0050, 0x1a434168,
    0x45062721, 0x98441d78, 0x36172307, 0x96433233, 0x057b4205, 0x0010002b, 0x26373233, 0x23263710, 0x08734222, 0x16071024, 0xb1448006, 0x3f4c2a0b,
    0xf7fe2016, 0x75badfb5, 0x1098458b, 0x7df99b2c, 0x0d011917, 0x92bae0ba, 0x9543c9ae, 0x80002506, 0x80fd8080, 0x7528ce82, 0x659a9a65, 0x3903b975,
    0x84057c42, 0x0dcd440e, 0x80ee5f2a, 0x1bfcfeb4, 0x0f4e7c22, 0x3111b345, 0x2201b911, 0x0f01bba2, 0x617c221d, 0x0e12fe7e, 0x8642e7fb, 0x6f012c06,
    0xf9fe8efe, 0xc001a739, 0x42fc39a7, 0xfe23087a, 0x6439a740, 0x3b220c3b, 0x33474300, 0x6907200e, 0x0720082c, 0x200d3d47, 0x09316937, 0xf1472120,
    0x47332005, 0xd5291047, 0x2e09098c, 0x8c0a1a09, 0x0d4f474e, 0x85ac4e21, 0xd5ac2117, 0x231d5747, 0x1a0a8cd6, 0x09224082, 0x5f474f8d, 0xac4e210d,
    0xac211785, 0x166747d5, 0x04ff023c, 0x00068004, 0x41003900, 0x16010000, 0x02141500, 0x022e2704, 0x36122627, 0xa0483537, 0x07352d08, 0x012f2206,
    0x013f3426, 0x011f3236, 0x4707146a, 0x0224098f, 0x00100020, 0x02370382, 0x2701d980, 0xaad6feae, 0x0b8be185, 0x96f3810c, 0x12120ea0, 0x855ca00e,
    0x13ca2484, 0x85ca1334, 0x855c20cf, 0x46f92018, 0x03330989, 0xb9fe187c, 0xeafea7dd, 0x920f1392, 0x019b86e6, 0x4110ae12, 0xa52105b6, 0x2333855c,
    0xc91313c9, 0x5c214885, 0x20cd84a5, 0x0c3548fb, 0x04000228, 0x80070000, 0xcb877e04, 0x01071422, 0x2e45b587, 0x0006240a, 0x49242223, 0x1624066d,
    0x34353317, 0x20066f4c, 0x06a54121, 0x9b411720, 0x6d072e07, 0xdafe1313, 0x2d091b09, 0xfeb90a0a, 0x207184da, 0x25a39784, 0x0ab92601, 0x2c822d0a,
    0x8940fb21, 0x6d0221d2, 0xfe21f082, 0x201885da, 0x050545b9, 0xd9fed925, 0x412a01ae, 0x1485081f, 0x6585b920, 0x47edfc21, 0x04271057, 0x00000680,
    0x4a1f0017, 0x394a0643, 0x11352a05, 0x34350026, 0x1e32023e, 0x08064802, 0xd9fe8023, 0x82a284d9, 0x06914960, 0x8907fd21, 0x05204a8a, 0x0e9cfd2b,
    0x020e1212, 0x47011864, 0x068549dd, 0x8ecbfd21, 0x00002773, 0x80048004, 0x75820700, 0xd4410020, 0x4a638205, 0x3224080c, 0x0004011e, 0x8405a145,
    0x49872037, 0xea2309fd, 0x48019bd5, 0x02210a59, 0x06154a35, 0xc0820685, 0xff000029, 0x05000680, 0x43240080, 0x23370839, 0x37331121, 0x36343523,
    0x26353733, 0x1d062223, 0x33152301, 0x4c222111, 0x053505bf, 0x323223ab, 0xc779fe23, 0x442fe51e, 0x88733f7a, 0xfdc8c8a3, 0x3d138321, 0x23328005,
    0x3223aafa, 0x94e85302, 0xcf013838, 0xab92a009, 0x32adfde8, 0x23560523, 0x6b860032, 0x0600053d, 0x004c0000, 0x3e341100, 0x04323303, 0x0e141516,
    0x26222303, 0x0f060e27, 0x82262701, 0x37122174, 0x8205394c, 0x15062919, 0x32331614, 0x3435043e, 0x8d088682, 0x1e141500, 0x06141502, 0x2e272223,
    0xac844b03, 0x019e67c6, 0x5226aa10, 0x4467ac76, 0x240a1d86, 0x2a161e0b, 0x090e2532, 0x075a2b0f, 0x3d506820, 0x405a5844, 0x313f5e37, 0xb0db0d1b,
    0x19f4fec8, 0x161e191d, 0x4f330f02, 0xab03162b, 0x688ebf6c, 0xa0fe8534, 0x81aab860, 0x2738404d, 0x2b632b93, 0x05324952, 0x5c1f9d0a, 0x1e5a01e5,
    0x92536841, 0xfa423e51, 0x32533f3e, 0x69756856, 0xfec1ad2f, 0x522cc7fd, 0x1c092b30, 0x520f035a, 0xce826d6b, 0x0003002f, 0x067aff00, 0x00860500,
    0x003e002b, 0x22128251, 0x82171632, 0x0e0722b6, 0x82a48301, 0x353726ce, 0x33363736, 0x74c48232, 0xd0820501, 0x22821720, 0x10821720, 0x10670320,
    0x14152e08, 0x16370717, 0x16042012, 0x06021012, 0x083a8204, 0x26130535, 0x36123435, 0xa91acc03, 0x10110205, 0x85392f6e, 0x484c9062, 0x18470301,
    0x0718061c, 0x08080f13, 0x22054532, 0x0c5f3844, 0x7f700f0a, 0x6464a8e9, 0x82fee9a8, 0x783d0806, 0x229ef24f, 0x17013201, 0xca7878ca, 0xc399e9fe,
    0x885ffeaa, 0x02ca786c, 0x05095832, 0x272b210a, 0x922d3e35, 0x08576b70, 0x0316435b, 0x8814150d, 0x0a491507, 0x40490807, 0xfe073035, 0x8244864f,
    0xcb7f2706, 0x684de9a5, 0x44836605, 0xfecefe2c, 0x5e78cae9, 0xb2950186, 0x598299d3, 0x09000022, 0x0026e982, 0x80050007, 0x06820300, 0x13000f33,
    0x23001b00, 0x2b002700, 0x00002f00, 0x21352137, 0x74038211, 0x0b8a08aa, 0x73661220, 0x21112307, 0x03860111, 0x00048024, 0x038300fc, 0x38200628,
    0x50383850, 0x0c8a18fa, 0x02820f82, 0x82f99821, 0x26038566, 0x80018080, 0x8398fd80, 0x04382228, 0x20098720, 0x23398402, 0xfe20fd38, 0x02211e82,
    0x5c058900, 0xab820877, 0x9f820720, 0xb9824e20, 0x1026202e, 0x10162036, 0x16322101, 0x0614011d, 0x460a4562, 0x21210707, 0x057e4411, 0x14011526,
    0x15213316, 0x22262282, 0x3e343526, 0xc14c3305, 0x3d088207, 0x15062223, 0xc2fe5f03, 0x3e01e1e1, 0x014002e1, 0x13130d60, 0x13a0fe0d, 0x130dc00d,
    0x0c83a0fe, 0x84600121, 0xfd22080c, 0x01344c20, 0xfc674400, 0x07927996, 0x46362015, 0x14133d65, 0x97b2974f, 0x8413144f, 0x4c34df55, 0x42838002,
    0xc2fee124, 0x3d919ffe, 0xfd305785, 0xee4c34c0, 0x35798a32, 0x5f647565, 0x3d112843, 0x11230082, 0x82344c60, 0x000326cd, 0x0780ff00, 0x22df84f7,
    0x8a560033, 0x16172bdf, 0x010f1415, 0x2f222306, 0x05840701, 0x3f22c382, 0x05842701, 0x32333625, 0x8437011f, 0x26258205, 0x06070507, 0x821f1415,
    0x8821202b, 0x201621e8, 0x17251e83, 0x1415010e, 0x2de78917, 0x0909f9b5, 0x0e0d0988, 0x09f9f909, 0x0a820d0e, 0x118e0883, 0xb515fd27, 0x15532525,
    0x2af08c17, 0x9a4a019a, 0x1d1c1314, 0x88251a1c, 0xdffd21ef, 0x5f824499, 0xb5265686, 0x25353625, 0xfc890353, 0x117a7a29, 0x212e1b06, 0x82002536,
    0x000032fb, 0x00050008, 0x1a001200, 0x00002400, 0x16322101, 0x06a76f15, 0x4206c241, 0x21200786, 0x3d084963, 0xc0060001, 0x00ff261a, 0x00ff00fa,
    0x1a801a26, 0x96400226, 0xd49696d4, 0x9fe15605, 0x0e8240fd, 0xfe221582, 0x1d820140, 0x27820420, 0xfe1a2623, 0x231d8316, 0xe19f4096, 0x80210b82,
    0x066f4800, 0x82060021, 0x16002301, 0x75821900, 0x15330333, 0x15210721, 0x21010921, 0x21272135, 0x21033335, 0x2e0c8201, 0x00062313, 0xeefec0c0,
    0xfe490137, 0x829bfe65, 0x01653d01, 0xeefe3749, 0x0001c0c0, 0x7a014301, 0x00fe4301, 0x0006d86c, 0x80c040fe, 0x03c0fcc0, 0x01220683, 0xd682fdc0,
    0x7e82fb20, 0xdf826782, 0x6785ff20, 0x1f001724, 0x69822300, 0x1504323f, 0x07061411, 0x23061617, 0x3f262221, 0x35012e01, 0x33243411, 0x34363212,
    0x14062226, 0x08fb8201, 0xb9400437, 0xb4fb0701, 0x161010d5, 0x1016e0fb, 0xfbb4d510, 0xf0b90701, 0xa07070a0, 0xfb000370, 0xbb000680, 0x8280fc85,
    0x0fca05b8, 0xca0f2828, 0x0382b805, 0xfabb8580, 0x261e82c0, 0xd001a070, 0x82fe0002, 0x00002179, 0x85093b6a, 0x002b227b, 0x207f992f, 0x207f8a02,
    0x2b8ba000, 0x5e5e84e2, 0x40025e84, 0xfe03e0fd, 0x01230a84, 0x96c0fd40, 0x82e02096, 0x845e2329, 0x9683c201, 0x0c8bfd20, 0x2808a483, 0xff000004,
    0x0500078a, 0x00120076, 0x001c0015, 0x01000028, 0x23061411, 0x2e252722, 0x34113501, 0x17323336, 0x09171601, 0x82148202, 0x14012513, 0x01090700,
    0x5d081485, 0x18195502, 0x2ffe1011, 0x13141d15, 0xff011e0e, 0x16024003, 0x6b04eafd, 0xfe17301c, 0xfd190247, 0x7afe2cff, 0x23114401, 0x1d020c0e,
    0xfb5b0404, 0x0823196b, 0x172f0ae9, 0x1c147404, 0x0300ff0f, 0x019efc67, 0xfb46020a, 0x0d1f19e2, 0x03e503dc, 0x0247bffc, 0x1c0f027a, 0x02f2fe06,
    0x53470200, 0x000b2308, 0x5d18000f, 0x21210e5f, 0x535d1811, 0x00fa210f, 0x0e495d18, 0xfaaa0431, 0x00000600, 0x54001800, 0xa40806ff, 0x7c00ff05,
    0x3b0805a7, 0x0044002f, 0x01fc004d, 0x01120106, 0x0125011b, 0x013c0132, 0x01510147, 0x016c015e, 0x01b30177, 0x01d901c2, 0x02fe01e9, 0x0500000d,
    0x0607010e, 0x36262726, 0x05163637, 0x1617011e, 0x0e820882, 0x84370621, 0x3435210b, 0x23850b83, 0x82343521, 0x0116261a, 0x1e072233, 0x055d4701,
    0x30057547, 0x37263436, 0x3e07012e, 0x01011e02, 0x15160716, 0x2d518516, 0x010e2504, 0x37012e27, 0x37263736, 0x05871736, 0xdf4e3420, 0x35172205,
    0x201b8222, 0x2c198227, 0x16023e37, 0x17163317, 0x013e1716, 0x216c8237, 0x4c823427, 0x36273785, 0x1e141716, 0x83161703, 0x82072042, 0x37362604,
    0x2427042e, 0x272b8201, 0x033e3337, 0x013e013f, 0x16223582, 0x6f820706, 0x07061523, 0x82968206, 0x82362066, 0x8301201b, 0x161721bb, 0x06241883,
    0x36071423, 0x15237385, 0x82361716, 0x22058214, 0x82071401, 0x836c8205, 0x831e8333, 0x07062a72, 0x17162722, 0x26363732, 0x82ac8205, 0x283e82f8,
    0x26171617, 0x26313736, 0x82628227, 0x06372831, 0x0635010f, 0x82051617, 0x011e225f, 0x30b08337, 0x15062200, 0x36321614, 0x26033435, 0x16063507,
    0x29178417, 0x013e0526, 0x06352726, 0xad820e23, 0x25011e22, 0x16211782, 0x342f8336, 0x07160706, 0x36170416, 0x37263724, 0x3d013e34, 0x012e1501,
    0x20bb8227, 0x298c8227, 0x23080e27, 0x030e2706, 0x06820607, 0x11840620, 0x1b822620, 0x36031623, 0x22248235, 0x82010e26, 0x8217205b, 0x84888346,
    0x06142335, 0xf6821615, 0x23070622, 0x17229382, 0x2d832504, 0x10823783, 0x25321522, 0x3723f582, 0x83353607, 0x37262258, 0x82078226, 0x3605237b,
    0xd682012e, 0x85140721, 0xde012aa6, 0x19122608, 0x52010235, 0x39d4821b, 0x13260734, 0x02013519, 0x16161b53, 0x22570d39, 0x30874a2d, 0x72fa2f28,
    0x0a85560d, 0x022eda09, 0x232901c9, 0x2636221b, 0x70051c34, 0x7070504f, 0x7cf363e0, 0x767d6f1b, 0x08f20251, 0x5b010713, 0x58303680, 0xfd51fd16,
    0x315717c4, 0x0201bb56, 0x06081305, 0x071b0e19, 0x1d1c0b09, 0x1c170d1e, 0x14121a23, 0x5835070b, 0x0f09090b, 0x2622024e, 0x2e0d051c, 0x0a02030e,
    0x0f0f0a29, 0x3e014417, 0x15201c71, 0x174a1008, 0x0203033a, 0x1b050704, 0x28323031, 0x663d2f7a, 0x2a148991, 0x0c3e2134, 0x35015302, 0x24553c62,
    0x04070501, 0x03010202, 0x1249173a, 0x1c201507, 0x18473c6f, 0x2a0b110e, 0x10040109, 0x1c050d2c, 0x4f022226, 0x0c08090e, 0x070a3558, 0x1a121401,
    0x0e171c23, 0x0b1b1a21, 0x0d1c080a, 0x09f5fe17, 0x1b041e52, 0x4e20141c, 0x430d1923, 0x03050d1e, 0x4a0f3338, 0x0b2a0e1e, 0x1e101615, 0x521ebef9,
    0x1c132109, 0x441d281b, 0x2523190d, 0x0437330f, 0x3b0eba09, 0x2e2d2413, 0xd903191a, 0x03031108, 0x2c28110d, 0xe0fe1801, 0xe8a6a6e8, 0x6a6936a6,
    0x1d0a0701, 0x04091f81, 0x08f2fe05, 0xd4020403, 0x06060402, 0xfe86220b, 0x39291098, 0x0303120f, 0xc245050a, 0x01842503, 0x01aca617, 0x03219b15,
    0x42110201, 0x33381a0f, 0x0704051f, 0x0906020a, 0x10080c07, 0x6a041308, 0x1e0c0439, 0x03061c10, 0x360218b3, 0x080c2c2f, 0x1d3a0911, 0x11035101,
    0x79292744, 0x82230558, 0x0d563336, 0xc5c30417, 0x0661a562, 0x091f0217, 0x130a2c0c, 0x13030201, 0x02140255, 0x4caefe65, 0x41080850, 0x01d0d040,
    0x04a00401, 0x01130e18, 0x2a0f0f03, 0x021f090e, 0xb3cc0c10, 0x056002c6, 0x262a7858, 0x0a031145, 0x82363356, 0x0725108b, 0x16131909, 0x33040542,
    0x2c0b8a15, 0x09411b58, 0x2e21230d, 0x5505056d, 0x080b8a22, 0x0f42049d, 0x231b2d08, 0x13172b32, 0x9469694a, 0x2d6dda69, 0x06493c43, 0xdcfa6d28,
    0x11171f0b, 0x02467138, 0x192a2f02, 0x02302919, 0x16539b03, 0x0a0b1f12, 0x1d1d1609, 0x140e0a09, 0x0c081d0e, 0x0407051c, 0x0a02490f, 0x2b263545,
    0x2511213e, 0x0512190a, 0x01040312, 0x060b0105, 0x04060328, 0x241f2102, 0x357e3870, 0x011d1710, 0x0e18101a, 0x2e020e03, 0x2e12041c, 0x0d49353a,
    0x080d0f08, 0xfe7e030e, 0x0a8a54f7, 0x180e0313, 0x1c0e0e0f, 0x7e341118, 0x20237039, 0x020a0221, 0x820c0529, 0x03052147, 0xb7085182, 0x11260818,
    0x29283f20, 0x02094635, 0x040f1831, 0x0c1c0507, 0x12101c09, 0x1c0a090d, 0x0308151e, 0x20191daf, 0x1d7b2564, 0x2a760413, 0x200d3a85, 0x65400e0e,
    0x010a0f10, 0x44037c73, 0x20643186, 0x04121d19, 0x8b7b1d13, 0x853a0e1f, 0x100f062a, 0x41114164, 0x0e046f7c, 0x6b590113, 0x8d262703, 0x08071213,
    0x023c8314, 0x74a58302, 0x75a5a575, 0x0226fe74, 0x761b0102, 0x0b010e07, 0xba434803, 0x13585804, 0x54140301, 0x020f0552, 0x19773bc8, 0x10120608,
    0x82021d94, 0xc68d0d17, 0x99c23137, 0x0302150d, 0x01010103, 0x5a010702, 0x0627262a, 0x05310d08, 0x03050608, 0x69084482, 0x11140901, 0x02030b13,
    0x3f391101, 0x0d2e0809, 0x06241d0d, 0x84fd0204, 0x7647100e, 0x6b350c0b, 0x02503536, 0x3fdc3c02, 0x343d7138, 0x09046188, 0x12020601, 0x0d0b1713,
    0x2243530b, 0x931515cd, 0x03162331, 0x3c1c1503, 0x362f0180, 0x01212642, 0x11084c4d, 0x12141809, 0x08040504, 0x8c3b5ebe, 0x0c356b36, 0x1046770b,
    0xbe82310e, 0x00005034, 0xff000003, 0x05010943, 0x000700bd, 0x003b000f, 0x99612400, 0x1e01300e, 0x33010c05, 0x0e041e32, 0x07060703, 0x822e053e,
    0x24410806, 0xf405072e, 0x61618860, 0x6173fd88, 0x88606088, 0x6b395afd, 0xcdc38987, 0x39012701, 0x97d38bd8, 0x2a032d61, 0x4d7c6c47, 0x5f1d65b9,
    0x2646605d, 0xfe9a4f0c, 0xdcfea8b1, 0x7382bddc, 0x2f214444, 0x8234832b, 0x083a823e, 0x3105612f, 0x334b593c, 0x050e1728, 0x2f20170a, 0x65514838,
    0x5a9d416c, 0x665f7433, 0x333c5051, 0x0203101f, 0x33341e10, 0x37543b4a, 0x00000051, 0x82af8207, 0x00062104, 0x1f2aad82, 0x3f002b00, 0x67004b00,
    0x19827700, 0x06042028, 0x16121002, 0x9b182004, 0x1f4d08c6, 0x7b202005, 0x133205d5, 0x14111532, 0x3522012b, 0x04333411, 0x14151632, 0x7d550706,
    0x012e2908, 0x20023435, 0x02101204, 0x44823d82, 0x89181320, 0x36310931, 0x011d1632, 0x013b1614, 0x013d3632, 0x06202634, 0x0b826901, 0x36322132,
    0xaefe2904, 0x84dfccfe, 0x3401df84, 0x34015201, 0xfd270983, 0x016c016d, 0x188ef04c, 0x380bb359, 0x20101072, 0x7b011010, 0x1d234b6a, 0x0e400e12,
    0x51231d12, 0x6101a201, 0xce5f18ce, 0x84d22008, 0xba832216, 0x2e078483, 0xcedcfece, 0x1a266003, 0x261a80fc, 0x82031a26, 0xc0052505, 0xccfedf84,
    0xc4206d8e, 0x0121638b, 0x2377844c, 0xfe104efd, 0xe0336b83, 0x354b4010, 0x72113a23, 0x0e12120e, 0x233a1172, 0x884b0335, 0x6101226d, 0x217d8201,
    0xaf53eefe, 0x835d2305, 0x09855d83, 0xcece9226, 0x00028efc, 0xfe207483, 0x00210583, 0x05374b00, 0x05000922, 0x172c0983, 0x00002f00, 0x11211101,
    0x23113301, 0x260e0a41, 0x14110135, 0x5c152306, 0x1e5907c0, 0x011d2f05, 0x80071632, 0x000780f9, 0x0e128080, 0x8b83c0f8, 0xfe820720, 0x4b000134,
    0xf8425e35, 0x5e5e42c0, 0x42400742, 0x044b355e, 0x6a82fd00, 0x01c0fd23, 0x05d05780, 0x077ffc20, 0xfea02505, 0xa04b3580, 0x03202683, 0xa0212c84,
    0x8c92824b, 0x881b2093, 0x16322293, 0x22829215, 0x90011915, 0x011121aa, 0x0220cf82, 0x858d5982, 0x0320a28e, 0x02239282, 0x8e354bc0, 0x60fd2182,
    0x0121a38d, 0x258fc320, 0x00048003, 0x8f404b35, 0x00022289, 0x491f4105, 0x82000221, 0x00092700, 0x17000005, 0x39522b00, 0x0e2c4209, 0x2014a941,
    0x20859d08, 0x249f4103, 0x00014d08, 0x0405ff00, 0x0000067b, 0x0100001c, 0x23060716, 0x06161321, 0x2606010f, 0x06010327, 0x26272223, 0x37341135,
    0x17323336, 0x111f6d04, 0x82fe2a11, 0x18140ac9, 0x0b3019b1, 0x13c8febf, 0x280c0c1a, 0x1b0c0c28, 0x1eed0112, 0x24fe2827, 0x4b201682, 0x01211e82,
    0x291b82c4, 0x052a1105, 0x05112ae0, 0x63830013, 0x80030032, 0x25000006, 0x20010000, 0x15331115, 0x21141123, 0x20290582, 0x23210627, 0x35203335,
    0x21058211, 0x0b843411, 0x82361721, 0x40033719, 0x8080c0fe, 0x40404001, 0x7070f0fe, 0x4040f0fe, 0x80804001, 0x0782c0fe, 0x70701038, 0x05401001,
    0x60fee080, 0xe0e0fd80, 0x80929280, 0x802002e0, 0x0a84a001, 0x20054e41, 0x06ff5700, 0x17001330, 0x1f001b00, 0x2f002b00, 0x3b003700, 0x7f824100,
    0x33112325, 0x7d352111, 0x23210530, 0x24078211, 0x15052135, 0x28108233, 0x35113533, 0x35251523, 0x208c8233, 0x22a18221, 0x82051533, 0x2101210f,
    0x8305084f, 0x83012007, 0x08152a0a, 0xfe808000, 0xfe00fb80, 0x28a18280, 0x01000580, 0x8000ff80, 0x201482f9, 0x20038206, 0x200785fb, 0x341582fe,
    0x80fe80fc, 0x00fd8003, 0x80fd8002, 0x00ff0004, 0x800480fe, 0x223586fc, 0x82010004, 0x2102843d, 0x068300fa, 0x05820420, 0x0986fc20, 0x0100fd29,
    0xfd000300, 0x82000280, 0x8230833c, 0x000a28d4, 0x0900ff00, 0x82000600, 0x072352cd, 0x3f003328, 0x47004300, 0xd58d5700, 0x1122db8d, 0xed821523,
    0x0120e183, 0x2324e58b, 0x21253315, 0x0120ea89, 0x2120e982, 0x19240382, 0x21352301, 0x20062041, 0x20388233, 0x22eb8409, 0x83fe80fc, 0x22f085f2,
    0x83018003, 0x23f584f7, 0xfa8000fd, 0x0520bd82, 0xfb220382, 0x05820380, 0x0382fc20, 0x80000223, 0x87068205, 0x80032132, 0x3b85cb83, 0x02203883,
    0x50833f83, 0x0a842382, 0xfb808022, 0x03820a83, 0x03820220, 0xfd80fd22, 0x01210d84, 0x200d8200, 0x212786fe, 0x0b4e0000, 0x00112209, 0x55ef8218,
    0xaa500846, 0x06223505, 0x0f062117, 0x04070601, 0x2860fc00, 0x05283838, 0xfe382840, 0x802b0982, 0x320f7d01, 0x015232b8, 0x8560fe20, 0x28382615,
    0x483860fc, 0x23148252, 0x0000000f, 0x24096b73, 0x000f0006, 0x26598223, 0x3f361523, 0x41253601, 0x342405f6, 0x14110136, 0x0e755882, 0x82332009,
    0x78053970, 0xb90c1df8, 0x01f2fe0c, 0x0300fb20, 0xc8013880, 0x1cb81c28, 0x00fc2860, 0x01237a87, 0x820af800, 0x039d2a21, 0x0100fb80, 0x03382820,
    0x201b82a0, 0x20248260, 0x82848628, 0x06002b7a, 0x80ff0000, 0x80050009, 0xd3820b00, 0x4100272b, 0x64005400, 0x14000000, 0x90501806, 0x88362008,
    0x3316250b, 0x23110516, 0x2705964f, 0x1f011e15, 0x35252001, 0x263a2782, 0x16173634, 0x012e3517, 0x0e26012f, 0x021e1402, 0x34253637, 0x3e352726,
    0x06823501, 0x23262222, 0xbc7dc782, 0x074a0811, 0x08171f9f, 0x0a99990a, 0x1e0d1708, 0x8b0c0317, 0x010b038b, 0xe469fb17, 0x796c434c, 0x2a298835,
    0xca024801, 0x7a6c6563, 0x63656c7a, 0x1c1c6830, 0x2c62b77f, 0x7fb7622c, 0x56490365, 0x52403942, 0x05120342, 0xeb0139fe, 0x48185f4a, 0x47080da2,
    0x05253434, 0x05028c02, 0x042232af, 0x04018101, 0xfe3401e0, 0x3b493acc, 0x01100f70, 0x34712101, 0xba620807, 0x33070862, 0x020f0c70, 0x50280602,
    0x50607460, 0x8e040628, 0x03054536, 0x372e4308, 0xfe010342, 0x36034902, 0x0c7f4818, 0x27410520, 0x00053108, 0x001a000b, 0x003e002e, 0x0e110100,
    0x24161401, 0x2308e482, 0x10003611, 0x22230402, 0x3435022e, 0x04202412, 0x022e3401, 0x04222123, 0x12141502, 0x32213304, 0x1101023e, 0x080d7b47,
    0x6a5a0332, 0x62028484, 0x016a6a84, 0xf2fe9d5b, 0x9dd9779f, 0x0e019d5d, 0x0e013e01, 0xb86f1c02, 0xd3fe83f3, 0xafd9feb0, 0xae2a01ae, 0xf5812d01,
    0x58016fb8, 0x0b564b18, 0x02270127, 0xeabd29b5, 0x290282bd, 0x294afd29, 0xc2fed101, 0x4182f2fe, 0x9f77d939, 0x9d9d0e01, 0xf58b4cfe, 0xfea260a6,
    0xfeabbad6, 0xa965aadb, 0x8c0603ec, 0x030021ce, 0x230cab49, 0x0500003b, 0x180e3048, 0x220f7957, 0x53231501, 0x14220876, 0x0e823b16, 0x3c090365,
    0x0d138006, 0x130dc0fb, 0x40040d13, 0x5e80130d, 0x42c0fb42, 0x04425e5e, 0xfe5e4240, 0x211b8880, 0x1487a0a0, 0x26836020, 0x04213286, 0x242c894d,
    0xa03e015e, 0x834683a0, 0x8346824c, 0x005e2340, 0xab830600, 0x82800821, 0x00022f06, 0x00350005, 0x0055003d, 0x0900006d, 0x02822101, 0x010e0124,
    0xff551107, 0x06fd5b08, 0x2e112124, 0x02562701, 0x013e2408, 0x87171632, 0xe9c21822, 0x59012007, 0x352a0571, 0x37033e34, 0x1e173236, 0x108f0504,
    0xfec00627, 0xf9000380, 0x2c058380, 0x3f0eb501, 0x0e600228, 0xfa0e1212, 0x260583c0, 0x3f286002, 0x8315fe0e, 0xeb01280a, 0x627c6215, 0x83eb0115,
    0x3ffd3e0c, 0x422f2f42, 0x5d90042f, 0x9384938e, 0x72465d8e, 0x12046864, 0x6804124c, 0xfb467264, 0x29159300, 0x40fd4004, 0x40fdc002, 0x52828003,
    0x12f5fa24, 0x4883400e, 0x05210482, 0x8474820b, 0x4739230e, 0x08843947, 0x5b821020, 0xfc422f39, 0x42744961, 0x74422121, 0xd18c0b49, 0x2107bab6,
    0xb6ba0721, 0x940b8cd1, 0x05b74415, 0x2a057b54, 0x004d002d, 0x02100100, 0x65121607, 0x2320072d, 0x27062641, 0x1210013b, 0x11022637, 0x2e0ac45f,
    0x0614011d, 0x033e0123, 0x1e142135, 0x821e1702, 0x0e07320d, 0x34211503, 0x2e27022e, 0x05363401, 0xa0a0d580, 0x051341d5, 0x6020b284, 0x05210f88,
    0x2fc283c0, 0x904d8afd, 0x00fc4673, 0x4d907346, 0x13171713, 0x04200d83, 0x052b0d87, 0xfefbfe80, 0xfe6a6a6f, 0x89fbfe6f, 0x050129f2, 0x6a6a9101,
    0x05019101, 0xfd301389, 0xb27f1d3c, 0xf28484f2, 0x071d7fb2, 0x07212821, 0xd3670e8d, 0x82062006, 0x2d0025e1, 0x3f003300, 0x2b27e1ae, 0x17142101,
    0x83113621, 0x822320d6, 0x2fd6a0df, 0x0900fce0, 0x4409ee03, 0xe64c8c71, 0x44718c4c, 0x422fc9a9, 0x43fa3d3e, 0x7fb1ef82, 0xb17f1f1f, 0x560082ef,
    0xbb830c17, 0xbbb53b20, 0x012e0327, 0x010e2327, 0x2bbaa307, 0x55560355, 0x67b73639, 0x36b767e6, 0xce2ab9a9, 0x0efcb2b2, 0x2a2ac98d, 0x4f428dc9,
    0xae47200d, 0x0e4f42b1, 0x21070623, 0x354c4226, 0x026b8928, 0x13896bbc, 0xc4a91717, 0x27104842, 0x33919133, 0x21282107, 0x2b0c8741, 0x0039000f,
    0x05000049, 0x011d1632, 0x3305b245, 0x3634013d, 0x083e3733, 0x27082e37, 0x07080e21, 0x1317081e, 0x05271d8e, 0x12120ee0, 0x8340fa0e, 0x03623605,
    0x313a221a, 0x2c593450, 0x592c2b2b, 0x3a315034, 0x04031a22, 0x201593fc, 0x23358962, 0x800e1240, 0x04820d83, 0x68374034, 0x4b405856, 0x1c1e412d,
    0x2d411e1c, 0x5658404b, 0x13933768, 0x89000621, 0x48c38234, 0x0035079f, 0x6a004100, 0x22010000, 0x23011d06, 0x23263435, 0x11150622, 0x82088527,
    0x011729d3, 0x16141516, 0x36322133, 0x3721d882, 0x5e058313, 0x22820619, 0x0a8b2720, 0x17322726, 0x16323336, 0x1d250484, 0x03071401, 0x07134c06,
    0x82260121, 0x201b823b, 0x05c67717, 0x35000328, 0x3040204b, 0x0484422e, 0x3601232c, 0x021a2627, 0x0a261a80, 0x15840a6c, 0x0e273223, 0x081c8209,
    0x05324132, 0x39415408, 0x22683b42, 0x8c64201b, 0x70066d0d, 0x5480fd50, 0x4cccfe6c, 0x050b638d, 0x345f8b06, 0x8004482e, 0x5d80354b, 0x2e424330,
    0xac1e53fe, 0xe0320783, 0xd8fe232f, 0x261a3f27, 0x29191a26, 0x24b40124, 0x1683f629, 0x7d202d08, 0x02084128, 0x7a802e42, 0x01054d33, 0x36223280,
    0x648f0731, 0xfe3933f6, 0x502f184c, 0x01547570, 0xe0664928, 0x5f018d63, 0x00451582, 0x2608eb59, 0x00000660, 0x82580031, 0x0622270f, 0x11231115,
    0x07822634, 0x84011921, 0x14152cf8, 0x33160117, 0x37363221, 0x85353613, 0x84218719, 0x080b4107, 0x15163626, 0x03071411, 0x21059249, 0xe55e0127,
    0x58172005, 0x363905a6, 0x425c9e03, 0x425c4220, 0x3540269a, 0x80011a4b, 0xb0024026, 0x4c073622, 0x83138205, 0x202a0817, 0x1f7388b4, 0x8d631713,
    0x4c089769, 0xfd517d0e, 0x246d3c50, 0x963380fe, 0x8d324e6a, 0x1f131763, 0x2e428005, 0x100270fd, 0x0782422e, 0x00fff033, 0x354b33cd, 0x00fe222b,
    0x01222c33, 0x011b2095, 0x211883f2, 0x2087f0fe, 0x90022308, 0x3d47c22e, 0x11638d04, 0xfe698c06, 0xfe2b280e, 0x37684f6c, 0x4400022f, 0x22966a56,
    0x8d63b201, 0xee823d04, 0x05002208, 0x80ff0000, 0x80050007, 0x35002600, 0x62004a00, 0x00008300, 0x27222305, 0x2e013d26, 0x37343501, 0x05326e21,
    0x08695a18, 0x4f210521, 0x072e05b4, 0x0f030605, 0x15010e01, 0x32331614, 0x2b822537, 0x26340128, 0x05072223, 0x1286040e, 0x03013e23, 0x20118225,
    0x250e8206, 0x21150517, 0x29820622, 0x35372126, 0x03013f34, 0x3e233082, 0x82113501, 0x07212530, 0x14111506, 0x21056574, 0xa3581415, 0x07320805,
    0xb1310405, 0x3e173fa3, 0xfbfe0549, 0x6a96966a, 0x5b4a2c71, 0x2d2e6a96, 0x91017402, 0x566c966a, 0x8f5cadfe, 0x241ea39b, 0x141a2e42, 0x3f315201,
    0x09834001, 0xdefe6a08, 0x102b121c, 0x14323f10, 0x1e600112, 0x76fde824, 0x4b351618, 0x0e02252d, 0x4b3580fd, 0x1702354b, 0x6c6f2ee9, 0x53014952,
    0x354b362b, 0x2488ccfe, 0x20425c42, 0x2e453439, 0x80cafe26, 0x0535318d, 0x2645751e, 0x96d4960a, 0x50831c11, 0xef11966a, 0x64fd6a96, 0x55158b58,
    0x47c70217, 0x21370e4a, 0x9a0a422e, 0xff32500a, 0x08088200, 0x080d843e, 0x1625151a, 0xa0094032, 0x1103370e, 0x354b08f8, 0xc80e4228, 0x4b6a4b40,
    0x2b3fc66a, 0x1300fc66, 0x2c450b55, 0x4b359c02, 0xfe31217e, 0x463e2ed8, 0x46d0d02e, 0x3551082c, 0x8d11482a, 0x2e087b42, 0x00060008, 0x62002400,
    0x32010000, 0x51011716, 0x21250510, 0x013d2622, 0x08ac4825, 0x09823720, 0x5d432720, 0x11013305, 0x26012734, 0x06222123, 0x011e1415, 0x33013e17,
    0x0c841521, 0x821e1721, 0x3233280a, 0x0f141516, 0x83010e01, 0x011d2a20, 0x21331614, 0x1e051732, 0x080a8601, 0x7f043636, 0x02246e3d, 0x5070763c,
    0x705080fe, 0xdefde2fe, 0x77a97050, 0xfd2aa401, 0x08936452, 0x06507041, 0xc3fd5dc0, 0x41fc4027, 0x1003261a, 0x1f330a11, 0xc0fc4003, 0x83080b82,
    0x022d4808, 0x38285b80, 0x320a4005, 0x4245fe1f, 0x021a265e, 0x010d1031, 0x261d183d, 0x1a80011a, 0x38000626, 0x9ff3fc31, 0x509dfec8, 0xb1507070,
    0x2050708f, 0x8780a977, 0x20674f63, 0xc0f97050, 0x7f9d6301, 0x26340d03, 0x2e23201a, 0x20261f14, 0x0e2c1a26, 0x28383a2c, 0x1dc00f0f, 0x20425e25,
    0x9e07261a, 0xc51b2e0d, 0x0026261a, 0x00000200, 0x800700ff, 0x32000006, 0x00007400, 0x27262201, 0x34352603, 0x36200484, 0x22055477, 0x82011b17,
    0x613220fa, 0x07230575, 0x84053e03, 0x070634f9, 0x03230601, 0x03070622, 0x012e0323, 0x15062223, 0x8a131714, 0x011e2c0a, 0x011e1317, 0x37322133,
    0x42353601, 0x352405ad, 0x37011a34, 0x36830c85, 0x0a831320, 0xcb01d708, 0x6513794d, 0x0774050d, 0x83115d7c, 0x14825357, 0x82146753, 0x0e855953,
    0x7b07785c, 0x3016370a, 0x69193122, 0xfe323996, 0x31554405, 0xa4093d26, 0x3d09917f, 0x03403026, 0x09631a84, 0x422f263e, 0x04077403, 0x34086408,
    0x2ab60221, 0x38fb0122, 0x222b344b, 0x4840cdfe, 0x2f400403, 0x74093d27, 0x3f03961a, 0x4b5f00ff, 0x33399101, 0xdd01162d, 0x885d1e1b, 0x676c550a,
    0x01a4fe51, 0x736751ac, 0x5d8a0a57, 0x00fe2318, 0x1e102b07, 0x69940b0b, 0xfe26703e, 0x80063384, 0x56fd2630, 0x30265a02, 0x0d0f2f42, 0x9801ddfd,
    0x2e423325, 0x22fe0c0e, 0xfe1e741c, 0x1a29206f, 0x432b7b01, 0xe61a4934, 0x0c0104e3, 0x120d2801, 0x30442f0b, 0x021efe26, 0x300e0e70, 0xf35d0044,
    0x06802f05, 0x00330000, 0x005f005b, 0x00670063, 0xe9440100, 0x013d2315, 0x19822634, 0x46062a46, 0x08820833, 0x2634112b, 0x1d163227, 0x32333601,
    0x82038617, 0x14f8440d, 0x23111324, 0x03862111, 0x35800228, 0x4229974b, 0xfc444a34, 0x16ce3205, 0x185c0523, 0x20385038, 0x422e3040, 0x35364a20,
    0x3404824b, 0x0a16956b, 0x342f4a63, 0x1d1b4771, 0x5c1c825e, 0xfd426810, 0x05084532, 0x47699528, 0x20ea963b, 0x02832001, 0x80053d08, 0x00fe354b,
    0x36ca80fe, 0x222b344c, 0x1b3300fe, 0x60700115, 0x3c29d962, 0x303d2838, 0x402e4243, 0x4b4f375a, 0x3a026035, 0x9b804f37, 0x4502dc6b, 0x87075715,
    0x6d74d95e, 0x514090fe, 0x2b050645, 0x02239769, 0xfa966a23, 0xfe800180, 0x23410388, 0x06003106, 0x00250000, 0x00490034, 0x00820061, 0x17320100,
    0x3522e28b, 0xdc450311, 0x1f163205, 0x36343501, 0x11151632, 0x16323336, 0x0f062207, 0x30078202, 0x35361317, 0x22172634, 0x0307030e, 0x16141506,
    0x053a4633, 0x0126342b, 0x15131714, 0x013b3637, 0x07464637, 0x2005a542, 0x2c208401, 0x0e03013d, 0x26222301, 0x012b0627, 0x27338235, 0x21232634,
    0x11010f22, 0x34084082, 0x2f3c0805, 0x1555178d, 0x64fd588b, 0x11ef966a, 0x83506a96, 0xd496111c, 0x45151b96, 0x3721ba75, 0x37474a0e, 0x9a0a5032,
    0x16af420a, 0x081a1525, 0x420a840d, 0x0816822e, 0x4009a069, 0xf80841fb, 0xc63f2b66, 0x4b6a4b6a, 0x420ec840, 0x044b3528, 0x0b452c1c, 0x118d1355,
    0x51352a48, 0xd0462c08, 0x3e462ed0, 0x31d8fe2e, 0x354b7e21, 0x3f177903, 0x5c5eb1a3, 0x6c56adfe, 0x91016a96, 0x2e2d7402, 0x4a5b966a, 0x966a712c,
    0xfbfe6a96, 0x24374905, 0x3f9ba31e, 0x14520131, 0x87422e1a, 0x122b1010, 0x83defe1c, 0x2439080b, 0x1260011e, 0x013f3214, 0xfd181667, 0x2e6f4576,
    0x351702e9, 0xfd354b4b, 0x250e0280, 0xebfa4b2d, 0x53012b36, 0xfe5b5249, 0x452e26ca, 0x42203934, 0x8824425c, 0x4b35ccfe, 0x21008200, 0x00820002,
    0x04b4072a, 0x00190000, 0x01000047, 0x16d1b718, 0x0516322d, 0x06071613, 0x2622012b, 0x83010b27, 0x21068207, 0x0f82010e, 0x35262727, 0x3b013e13,
    0x90ec1801, 0x1631080c, 0x0d135903, 0x0d12d6fe, 0xfe130d87, 0x12130dd7, 0x0d19030e, 0x4d0e0413, 0x0d0a0901, 0x01120c86, 0x1508bd2e, 0xbc091478,
    0x0c12012d, 0x090a0d87, 0x3507824e, 0xdc09148e, 0x0d030a0a, 0x1409dd04, 0x03120d8d, 0x120d75e0, 0x3c84d4fc, 0x122c2d08, 0x120e750d, 0x3ffc0a13,
    0x110a0b0d, 0xfe4c020c, 0x01131357, 0x0cb2fdab, 0x0e0a0a11, 0x110cc103, 0x18f8fd13, 0x0923071b, 0x11130802, 0x0021d182, 0x08534f04, 0x2a000924,
    0x87703a00, 0x26272805, 0x3311012b, 0x86173632, 0x032722cb, 0x08047223, 0x3336342d, 0x1e173221, 0x06141501, 0x59021607, 0x00240e24, 0x04060210,
    0x08062059, 0x04202436, 0x3c120416, 0xa27b5421, 0xcd344842, 0x13080908, 0xc2081498, 0x860e129b, 0x0e12120e, 0x3e802601, 0x49556255, 0xd4fe2d06,
    0x75c5f0fe, 0x1001c575, 0x10012c01, 0xda200984, 0x32128558, 0x21584103, 0x4ae7fe12, 0x118bfed9, 0x0111100e, 0x83a2fe6d, 0xc0033147, 0x1f18120e,
    0x935c669c, 0x36030a24, 0xf0fec575, 0xfe294f8e, 0xfe94fe4b, 0x8e8ef0b4, 0x06ce58f0, 0x00200982, 0x2d37f78a, 0x6b005b00, 0x00007b00, 0x36373201,
    0x2726012f, 0x0e010f26, 0x43222305, 0x162f0842, 0x013f3637, 0x042e2736, 0x15062223, 0xa5211614, 0x101a4126, 0x5f672020, 0x061e4106, 0x5d022c08,
    0x0b0e6899, 0x1012062d, 0x0f04040b, 0x251e1b14, 0x60624c13, 0x1045254a, 0x100f0b10, 0x0f0d3508, 0x352c1003, 0xc4942d52, 0x820c03c2, 0x2d0a232a,
    0x2a9e1108, 0xc2c59323, 0x24fc8e27, 0xfdc57575, 0x113c5aa4, 0x2f012708, 0x52121268, 0x0d02040d, 0x0f0c0403, 0x64070c0e, 0x1c634c4d, 0x010b0e0e,
    0x144e0c02, 0x1f100413, 0x90c11419, 0x2583bf92, 0x9f030e21, 0x31042125, 0x21127641, 0xc3411501, 0x00200812, 0x40000200, 0xc007e0ff, 0x0b002005,
    0x00001700, 0x07170409, 0x37010927, 0x37270309, 0x07010917, 0x02390182, 0xfe8001e0, 0x0260fd80, 0x4860a8a0, 0xe00120fe, 0x02dffec1, 0xfda002a0,
    0x2c0f8260, 0x20fee001, 0x602101c1, 0xe00280fe, 0x832682fe, 0x83268418, 0x831f2016, 0x83268624, 0x60e12436, 0x4d008001, 0x07230727, 0x84000600,
    0x00272373, 0x69822500, 0x0907172f, 0x27371701, 0x27370509, 0x27010937, 0x0fba4207, 0x01cd023b, 0x58e9fe0f, 0xe9fe60c0, 0x57281701, 0x033afe7f,
    0xfec6012c, 0x01f1fe3a, 0x27158217, 0xe9fe1701, 0x4c035728, 0xb622e492, 0x22820f01, 0x0160bf23, 0x20388317, 0x22328280, 0x82c60142, 0x82f1203a,
    0x82bf204e, 0x2238824e, 0x42f90158, 0x0a281294, 0xdcff0000, 0x24050009, 0x132fa782, 0x25001c00, 0x39002f00, 0x53004500, 0x82005b00, 0x140121c8,
    0x2306c37f, 0x24163233, 0x2c06555d, 0x22263405, 0x32161406, 0x26342436, 0x20098423, 0x21258425, 0x23843634, 0x2622233e, 0x32333634, 0x23001000,
    0x14010e22, 0x3233011e, 0x20212601, 0x021e3207, 0x023e3415, 0x20201782, 0x13290383, 0x07010e21, 0x02141516, 0x2e308204, 0x2e070627, 0x010e2701,
    0x02242223, 0x82373435, 0x36213b0b, 0x04323324, 0x26378b02, 0x27373727, 0x82043726, 0x37374e37, 0x7127fc4e, 0x028271a0, 0x71810436, 0x71724f50,
    0xa345fca0, 0xa4a37473, 0x8204a3e6, 0xa37374a3, 0x4f080c82, 0xf1fedffc, 0x7cd47dbf, 0xbf7dd47c, 0xfefeab03, 0xfec1fed2, 0x5b99d475, 0x02ce9557,
    0xfef2fe51, 0x01f1fe82, 0x047e010f, 0x3e2c7f01, 0xfe9a6e09, 0xe8859bf8, 0x0b522f50, 0xe9502055, 0xf8fe9b85, 0x3e096e9a, 0x956d012c, 0xe0e29c01,
    0x1b028a01, 0x37217e85, 0x217d8302, 0x73835e36, 0x01717122, 0xc0208384, 0xa33f7884, 0xa3a3e601, 0x28fea3e6, 0x0f017e01, 0xd5fad57c, 0x6f0b047c,
    0xd49a5b6e, 0x98d17375, 0x8307fd5e, 0xf1fe2116, 0x04397683, 0x337f3304, 0xfe9cba97, 0x637099f8, 0x79167b38, 0x99716325, 0xba9c0801, 0x39178297,
    0x00707164, 0xff660003, 0x069a0400, 0x00090000, 0x004c0013, 0x00200000, 0x04823435, 0x63141521, 0x0128099c, 0x020e011e, 0x17070607, 0x2206fc6e,
    0x6e272627, 0x3734065c, 0x27263701, 0x3736032e, 0x1716023e, 0x3233041e, 0x3e013f36, 0x2b082e82, 0x88fe3c03, 0x0a01f6fe, 0x0a017801, 0x83b896fe,
    0x0183b883, 0x0d040d2c, 0x73272d28, 0x0b0149c8, 0x1f0c1e1e, 0xc8431f56, 0x561ff5fe, 0x1f280a82, 0xcb480b01, 0x282d2772, 0x0a382282, 0x21403024,
    0x48421405, 0xa65b3970, 0x40212625, 0x75022430, 0xbcbb0a01, 0xf6364982, 0x9b01bbbc, 0x835c5d83, 0xfd5d5c83, 0x242d1ba7, 0x49192129, 0x45844815,
    0x1e1e0d2b, 0xf4fec844, 0x1e0d1e1e, 0x3b4f8356, 0x21194915, 0x1b2d2429, 0x120e1e14, 0x230e041a, 0x1933161a, 0x0e121a19, 0x0004001e, 0x29078b6d,
    0x00360007, 0x004e003e, 0x67420000, 0x2e012906, 0x0e070601, 0x2f262202, 0x06240984, 0x17161716, 0x0627f882, 0x16011f14, 0x82013f32, 0x2305820e,
    0x022f3436, 0x0128f182, 0x20261002, 0x20161006, 0x08103e56, 0x845d9f27, 0x01845d5d, 0x3b240a33, 0x7c260a1f, 0x1b1b7682, 0x0a243b1f, 0x53432816,
    0x318e338f, 0x16091616, 0x72bf163d, 0x3205824d, 0xbf161609, 0x43548d34, 0xfebe4728, 0x01bebef4, 0x187a020c, 0x210bea54, 0x4983fe03, 0xf6fd5d38,
    0x19051814, 0x24281808, 0x05191212, 0x3b2d1418, 0x340e352c, 0x4086308e, 0x854c7321, 0x34be2a52, 0x3b2c350e, 0x0c011201, 0x294d83be, 0x40fce801,
    0x77a9a977, 0x0582c003, 0x0220e382, 0xb83cf784, 0x12008005, 0x00002800, 0x15163201, 0x06021411, 0x24222304, 0x11350226, 0x01333634, 0x2109914b,
    0x334e0109, 0x17540805, 0x1d061601, 0xe5885a41, 0xb0afc1fe, 0x88e6c1fe, 0xc102405c, 0x9401232f, 0x2f314525, 0xfebdfe23, 0x312e23bd, 0x95012445,
    0x5b800521, 0xb0f9fd41, 0x87e6c0fe, 0x4001e687, 0x400702b0, 0x21d8fb5c, 0x32238401, 0xfe214531, 0x213601ca, 0x22333145, 0x00217cfe, 0x8b827c82,
    0x09982c08, 0x00670500, 0x0500004c, 0x07000601, 0x26352606, 0x022e2700, 0x35263423, 0x020e1521, 0x17001617, 0x26371236, 0x27262702, 0x65150535,
    0x362b05c0, 0x27263637, 0x32353436, 0x8233013e, 0x03072712, 0x01171216, 0x2082022e, 0x0717a508, 0x07000706, 0xd9fed605, 0x41f5fe19, 0xfe523501,
    0x5b1556a5, 0x02012c74, 0x34512747, 0x7d011a10, 0x16da1f2d, 0x261dd613, 0x3c0102a3, 0x6c211543, 0x183f6e20, 0x40015f44, 0x3e1393d5, 0x0dd52172,
    0xb90107e5, 0x1a3b470e, 0x0101cc01, 0xf2fd3e8b, 0xb7026721, 0x85fffd31, 0xc1010101, 0x32ca1403, 0x26055673, 0x1c023208, 0xfc3b233a, 0x013d6490,
    0x01272a9b, 0x024535e4, 0x022f0132, 0xef462e2e, 0x3795d644, 0x24070231, 0x31010106, 0xfe323e02, 0xfefd2146, 0x26f90311, 0x32010e31, 0x042c0204,
    0x4b40fb8d, 0x2f05d74a, 0x00060007, 0x18000a00, 0x82007200, 0x00009200, 0x0808f144, 0x17163227, 0x07040e01, 0x25043e01, 0x022e0714, 0x14152223,
    0x07010e17, 0x22232627, 0x06011f06, 0x3e272223, 0x23343502, 0x31138222, 0x3727012e, 0x26343536, 0x3526010f, 0x021e3734, 0x0c823233, 0x3e012f39,
    0x16173701, 0x2f363233, 0x32333601, 0x14150617, 0x1e373233, 0x82071701, 0x3f162809, 0x10011e01, 0x48242602, 0xc8480dcc, 0xb503270c, 0x261a1921,
    0x56823222, 0x095e4408, 0x5f8b8675, 0x07a3fe03, 0x5e8c8478, 0x03688a02, 0x0d04191c, 0x83dd4a3b, 0x050e0110, 0x48100106, 0x01adc74a, 0x060d1318,
    0x71021716, 0x0a451f9e, 0x0e44050b, 0x1b21026d, 0x14190d04, 0x84e04d14, 0x820d020f, 0x0f260827, 0xafcc3f47, 0x250b0c27, 0x381f996f, 0x39040b0a,
    0xd67f550e, 0xbafed8fe, 0x7fd6d8fe, 0x2801d67f, 0x28014601, 0x6046dfd6, 0x83022312, 0x8e83261a, 0x0253213d, 0x7c6d0845, 0xfd065b82, 0x7b6e07bc,
    0xc93c5b83, 0x0f1202aa, 0x70220a0d, 0x8243209d, 0x0f443052, 0x1e250269, 0x281d0d04, 0x84e14b03, 0x830c030f, 0x43482e76, 0x1601adce, 0x13060c10,
    0x9a700c0c, 0x2d27821e, 0x6d0d4205, 0x400d0938, 0x0c82de4b, 0x23820e02, 0xe7480d22, 0x86827c84, 0x02219089, 0x12b24681, 0x00040026, 0x0701ff00,
    0x08055b47, 0x22001694, 0x00002a00, 0x16173601, 0x04262517, 0x24360107, 0x04160109, 0x24260337, 0x25103502, 0x06021216, 0x01250607, 0x24270236,
    0x06141632, 0x03342622, 0xe8d3f07d, 0xa01afd78, 0xfe33f4fe, 0x6e0180ec, 0x5101ddfd, 0x9a160148, 0xa6fed4e6, 0x3ac406c7, 0x8fce6403, 0x01f4fee6,
    0x650b5895, 0xb1fa38fe, 0x06b1fab1, 0x867a0200, 0xa70927ee, 0x9fa80192, 0xfd6cfead, 0x1d948f69, 0xf9213dfe, 0x01dc7f01, 0xfe96370b, 0xfdddfebf,
    0x020e8553, 0x3f01836f, 0x31820676, 0x82fab121, 0x02002994, 0x000700ff, 0x4d00c905, 0x33080c82, 0x26270020, 0x37011a02, 0x17013e03, 0x0e37013e,
    0x031e1701, 0x07061617, 0x1707020e, 0x021e0627, 0x17023e37, 0x0e07011e, 0x010e2704, 0x3e011e27, 0x2e363702, 0x17200883, 0xb208bb82, 0x16130004,
    0x04010e02, 0xe5fe8703, 0x3a6c45fe, 0x67984612, 0x0d720b0b, 0x3674ed2a, 0x4b190783, 0x0f085533, 0x1705190b, 0x8b0f385a, 0x50331512, 0x495e3329,
    0x09393d25, 0x160e0301, 0xa93c1a29, 0xa0b14a7d, 0x2b1b6b95, 0x572d4308, 0x910f1b64, 0x01090189, 0x55020426, 0xe9fed8a2, 0x2d0100ff, 0x540183f8,
    0x2b014501, 0x0ee7fe5d, 0x72511103, 0x3ccf2d02, 0x04040b08, 0x23510501, 0x0a301707, 0x4d2b43bd, 0x09071b38, 0x04022733, 0x0702243a, 0x03080d12,
    0x3d0b515f, 0x66491f2b, 0xaecb5b35, 0x47532626, 0x6f5a01aa, 0xfe6bfe4d, 0x00ff7fc5, 0x4463acdc, 0xff8206e3, 0x00063008, 0x37002300, 0x26010000,
    0x07042223, 0x1507010e, 0x1617011e, 0x37323304, 0x22230406, 0x26242627, 0x12343502, 0x013b2436, 0x14010416, 0x82060702, 0x36790814, 0x02343512,
    0x32333627, 0x05121617, 0x9bc2a5d5, 0x4b66ecfe, 0x59040459, 0x1401664b, 0x79a5c29b, 0x1da9cdfe, 0xc4feaf0e, 0xf08e86e4, 0x03b64c01, 0x013101a8,
    0x68889aa4, 0x9a768976, 0x779ac6c7, 0x876b7787, 0x6e1c0597, 0xfa5d7f92, 0xfa8d2a8d, 0x6e927f5d, 0x0801786c, 0x4401ee94, 0x4c01b6b1, 0x77018ef0,
    0xfec0f8fc, 0x543f7eab, 0xe4620138, 0x396201e3, 0xfe7d4153, 0x36b782ac, 0xff000004, 0x05000710, 0x002b00f0, 0x003f0035, 0x01000046, 0x4e210714,
    0x212305b5, 0x8204010e, 0x23063ba0, 0x37341122, 0x25123736, 0x00120306, 0x24173221, 0x021e3233, 0x16071415, 0xe7823403, 0xe2820720, 0x83013621,
    0x37930831, 0x0627012e, 0x012e2101, 0x07062223, 0x81fb0700, 0xad6394db, 0x38a70132, 0xa8cefee5, 0xa6e4a9bb, 0x5c112ded, 0xb81401c7, 0xb9013ff3,
    0x0f1e1901, 0x40b2ff00, 0x4b305568, 0x546a4665, 0xcb79926c, 0xc6f93345, 0x97735661, 0x622eb77a, 0xd802f801, 0x908fd805, 0x385702d7, 0x5dc59230,
    0x85f49f54, 0x07017453, 0xa93ca073, 0x4ff66801, 0x1201edfe, 0x75015f01, 0x4262371a, 0x01b6aa74, 0x466253b0, 0x876fa92f, 0x5d567cfb, 0x86de4853,
    0x8e4a02cd, 0x4100bebe, 0x802a069b, 0x80058007, 0x33000f00, 0x11660000, 0x05d55c0f, 0x2f5c1520, 0x75352010, 0x19820711, 0x1300072a, 0x0dc0f90d,
    0x060d1313, 0x2905cd5c, 0x600120fd, 0x0e12120e, 0x0583c0fc, 0xfd60012e, 0x5e5e4220, 0x42400642, 0x0320015e, 0xfc202884, 0x13232882, 0x82fccd03,
    0x5a802012, 0x802409b8, 0xc003425e, 0x97852a82, 0x80ff1636, 0x8005ea06, 0x3e001700, 0x33130000, 0x030e0706, 0x1617011e, 0x7d860184, 0x2e472920,
    0x06340805, 0x0336012b, 0x07030e05, 0x022e2706, 0x36012e27, 0x37013e37, 0x17031e36, 0xc58a2625, 0x2e243846, 0x1218030e, 0x33020413, 0xfe5f391e,
    0x444430f0, 0x3401e804, 0x35080682, 0x10d4b230, 0x14022bfe, 0x7b374d2a, 0x3d2a204c, 0x0a152322, 0x3c551412, 0x33394d2d, 0xd4011123, 0x40800544,
    0x85763855, 0x595f9d6b, 0x5bee0913, 0x304468ab, 0x38831805, 0xe8fa2108, 0x01d24430, 0x4a2d6563, 0x1a0c3146, 0xbe441b42, 0x4ec8a3a3, 0x0d402926,
    0x2f170b0c, 0xaf642031, 0x0439c383, 0x00ff0e00, 0x00067905, 0x46002500, 0xc500ab00, 0x07050000, 0x23060706, 0x060a6d22, 0x36372625, 0x85151617,
    0x331626d2, 0x3f363732, 0x25108201, 0x07011617, 0x26831617, 0x720ebd72, 0x338305b4, 0x82140521, 0x010e2347, 0x48832622, 0x84233521, 0x33172447,
    0x83363511, 0x15162222, 0x32628414, 0x011f3637, 0x3233011e, 0x27343536, 0x07222326, 0x82111506, 0x023e2164, 0x0f250e87, 0x27020e01, 0x052c702e,
    0x14322128, 0x33112123, 0x4084013e, 0x92821720, 0x14160322, 0x3c83aa88, 0x64822720, 0x17211c83, 0x08d18216, 0x9a9271cd, 0x9498a5a3, 0x2a3e716f,
    0x3334040c, 0x1c120105, 0x80626632, 0x858f9084, 0x0a066180, 0x24150c0f, 0x3f4215fe, 0x0f111c15, 0x423e090a, 0x100f0a05, 0x42081202, 0x121e1042,
    0x4107060d, 0x1b1e1241, 0x2d2ec701, 0xf2d65051, 0x2b5250d6, 0x3409010f, 0x3c250a32, 0x69630301, 0xd1d09394, 0x1c363a92, 0x0e1c100f, 0x680b260e,
    0x68474890, 0x6e40476b, 0x86b26084, 0xc78c8d49, 0x18358cc8, 0x210a0802, 0x151f1516, 0x1e6d0311, 0x01d5fc1e, 0x6d2e7c28, 0x50d6797a, 0x1f2e2d51,
    0x1a0b0b09, 0x6a07090d, 0x85948065, 0x09121b81, 0x820d0301, 0x8998a4a9, 0x3e71060b, 0x703f4040, 0x56679270, 0x1c08081c, 0x455a0301, 0x3662667c,
    0x82373838, 0x030425b1, 0x52022513, 0xab08b184, 0x05423d0a, 0x0e0f0210, 0x42410a07, 0x05121d10, 0x1e114142, 0x6e764a1b, 0x5c505169, 0x6852505c,
    0x111b0721, 0x44631c10, 0x88025301, 0x92ce6760, 0x0b10d093, 0x03083332, 0x678f0603, 0x50474665, 0x63fe5848, 0xb0864943, 0x8c8dc65f, 0x0222358c,
    0x080a090b, 0x020f1705, 0x6e170fa8, 0x542a1dfe, 0x505c2e13, 0x01706951, 0x101408d0, 0x5b071a0d, 0x0a31382a, 0x100d192f, 0x3a403904, 0x00040000,
    0x0600ff1d, 0x000006e1, 0x003e001b, 0x00820074, 0x16362500, 0x040e0714, 0x032e2223, 0x3e012e27, 0x16171601, 0x36250417, 0x07061625, 0x2b080182,
    0x013e3726, 0x0e032e27, 0x030e2302, 0x012e022a, 0x37362627, 0x14011636, 0x011f021e, 0x2f012e07, 0x0e272601, 0x35022e03, 0x37053e34, 0x3005f941,
    0x2507030e, 0x33033e34, 0x15031e32, 0x16171401, 0x08308237, 0x0e013db0, 0x0f0f0603, 0x3e0d0f16, 0x76df9981, 0xa5b4ee77, 0x04082264, 0x050d0a06,
    0x85016cc0, 0x01be9a01, 0x14110b98, 0x12113322, 0x112f1509, 0x1a211505, 0x012b132c, 0x09080e06, 0x03030605, 0x6a060101, 0xfe7c2e32, 0x26251b84,
    0x28e30d0e, 0x0b13134e, 0x8877260e, 0x3e688390, 0x787d5838, 0x1532638c, 0x15065722, 0x123c343c, 0x5a2cdafe, 0x6466b17e, 0x194161a2, 0x424660fd,
    0x0e1e5449, 0x416d683b, 0x1d06063c, 0x51371013, 0x5b3e3143, 0x09295d75, 0x0105090f, 0xb0317504, 0x10d22856, 0x2953316b, 0x2d130a0e, 0x09071699,
    0x02020203, 0x00830104, 0x02024a08, 0x07063010, 0x1fa9010c, 0x0b2a3242, 0x4d25e00b, 0x160b1414, 0x0628573b, 0x5b8f5330, 0x495d8c54, 0x02091c29,
    0x3520417f, 0x52251602, 0x763c1b37, 0x3231526c, 0x224f5d49, 0x2f569efd, 0x6219162c, 0x02a2382d, 0x005f2f14, 0x05034a00, 0x0680062d, 0x00230000,
    0x00430033, 0x676b0047, 0x6e4409d9, 0x013b2206, 0x05597535, 0x21011d22, 0x25300988, 0x3b161411, 0x35363201, 0x2b263411, 0x05062201, 0x012c0f8e,
    0x01112111, 0x1d163233, 0x2b061401, 0x09308418, 0x79612320, 0x28528805, 0x34000615, 0xfa344c4c, 0x26058380, 0x40425e80, 0x85015e42, 0x00ff2106,
    0x20092145, 0x250b8afd, 0x80fa8004, 0x40180003, 0x0a8a0ac9, 0x4c000524, 0x5084fb34, 0x05820520, 0x5e426025, 0x8660425e, 0x84fe2005, 0x20012526,
    0x0e12120e, 0xfa270b8a, 0xfc000412, 0x18400200, 0x890a6b41, 0x0c1f410a, 0x13000f29, 0x33002300, 0x54005700, 0xc9850689, 0x32213327, 0x11210116,
    0xeb531821, 0x06174110, 0x17411520, 0x11252106, 0x4109d763, 0x33281450, 0x80041632, 0xc0fd0e12, 0x0226a183, 0xfc120e40, 0xea820500, 0x28460120,
    0x4103200a, 0x01210a06, 0x14354180, 0x4c348024, 0x3c82a001, 0x1225c484, 0x0004d2fd, 0x85f390c0, 0x414e20ff, 0x4c201528, 0x220d1342, 0x42370027,
    0x25210513, 0x694d1807, 0x34262308, 0x497f013f, 0x07877e09, 0x14161722, 0x2e480741, 0x1a092e57, 0x0abcbc0a, 0x092e091a, 0x7ebdbd09, 0x0f870575,
    0x09bcbc24, 0x1a4120fc, 0x95972035, 0x8565824e, 0xe0fe216e, 0x323d2f41, 0x00180014, 0x00380028, 0x0900005c, 0x27220601, 0x7f342601, 0x012005a8,
    0x41052541, 0x05284720, 0x0a00fe17, 0xe0fe0a1a, 0x21051941, 0x2a4101dc, 0x60fb2105, 0x27351641, 0x00fe3c02, 0x20010909, 0x82056f41, 0x2156844d,
    0x0c413afd, 0x00012a32, 0x0700ff00, 0x00000600, 0x0647441d, 0x33360126, 0x11151632, 0x04430686, 0x01332809, 0x02261ac0, 0x87171118, 0x1a263305,
    0x261a80f9, 0x00061a26, 0x85fc1a26, 0x260ead01, 0x0685fe1a, 0x1785fb20, 0x00210582, 0x205f8303, 0x05fb4c04, 0x23001327, 0x32000000, 0x08275737,
    0x53200221, 0x2523055d, 0x50343632, 0x162b0531, 0x34353632, 0x84be0136, 0x821a263e, 0x01543b3e, 0xfe2c01a8, 0xfe58fed4, 0x0e0002d4, 0x920e1212,
    0x121c12ce, 0x0fc001a9, 0x7a8371fd, 0x048f0223, 0x241e8531, 0xa8012c01, 0x221b824c, 0x820e92ce, 0xa9772126, 0x7b826882, 0x00ff252e, 0x0006db06,
    0x25001b00, 0x00003b00, 0x20058252, 0x08134a23, 0x23081c45, 0x01173221, 0x08a95e18, 0x8206ac49, 0x422f2026, 0x332d050f, 0x15213521, 0x0a0ad106,
    0xfa281c8d, 0x207784c0, 0x269e8440, 0x1c280002, 0x8201bcfc, 0x21ab82ff, 0x19834003, 0x28c0fa24, 0x29848d1c, 0x01000227, 0x0ad70400, 0x2535821a,
    0x00011a26, 0x1f84261a, 0xfb1c4024, 0x0c82fedc, 0x031a2626, 0xff1a26c0, 0x2e820982, 0xc02b2383, 0x000400c0, 0x0800ff00, 0x82fb0500, 0x001f25af,
    0x00270023, 0x153eb182, 0x07061411, 0x25270601, 0x22230605, 0x11352627, 0x01373634, 0x25051736, 0x05110536, 0x01822511, 0x07820120, 0x1ce40730,
    0x80fd1216, 0x98fd1818, 0x0e0a98fd, 0x0e821113, 0x0e820220, 0x68022408, 0xfb206802, 0xfb400218, 0x04200260, 0x05e0fde0, 0xfa2114f5, 0x07201480,
    0x0b0b00ff, 0x0b05f6f6, 0x83052114, 0x8401200e, 0x9a0d340e, 0x04e60afb, 0x0afb0df6, 0xfaf604d9, 0xd9f604fd, 0x41000afb, 0x072505c3, 0x00000600,
    0x22958211, 0x41000035, 0x95820521, 0x83222321, 0x608f8290, 0x118d0550, 0x2207085f, 0x84012722, 0x000228b6, 0xfe11130d, 0x82080720, 0xe0012406,
    0x8ce80407, 0xa8fb2b0e, 0x00020608, 0x080d1312, 0x0682fe06, 0x13000631, 0x1440fa0d, 0x0400ff08, 0xc0050d13, 0x83010814, 0x2a118f08, 0x0a00ff03,
    0x0d40fa13, 0x82010313, 0xc0052408, 0x8200130d, 0x00043000, 0x0720ff00, 0x00000500, 0x000f0007, 0x82380017, 0x56342013, 0x65180503, 0x07870751,
    0x10002308, 0x22230402, 0x06050627, 0x27260607, 0x073e3726, 0x35012e37, 0x20241234, 0x4b800204, 0x6a4b4b6a, 0x068dcb01, 0xfef02208, 0x656ef464,
    0x34fafead, 0x03140c22, 0x25051804, 0x1a0f210e, 0x92050f0e, 0x9c01f0a7, 0x9c01e801, 0x82308402, 0x0802893a, 0xfe2e0121, 0xabd9fea4, 0x0a38ad12,
    0x0b0e0103, 0x2105160f, 0x301a250e, 0x5a274330, 0x01ae8ffd, 0x82abab27, 0x05db47a2, 0x2e22b78a, 0x5d545700, 0x74042009, 0x02380e23, 0x15060420,
    0x011f1614, 0x36070607, 0x1617013f, 0x36243233, 0x14012610, 0x2333d088, 0x35272622, 0x3e263626, 0x053e3702, 0x35022637, 0x82013e34, 0x011e21d7,
    0xe92dd994, 0x9dfe68fe, 0x57828fd1, 0x982e181b, 0xb052197b, 0x09325a29, 0x6ab50222, 0x4b26f48c, 0x80014b6a, 0x5219ec8b, 0x3d0811c6, 0xfeae8bfe,
    0xaf08abd9, 0x15080e43, 0x10040111, 0x0e030f04, 0x17350802, 0x28482e38, 0x96060159, 0x65aced82, 0x00edac65, 0xff000004, 0x05000409, 0x000300f7,
    0x000a0006, 0x0900000d, 0x02821101, 0x01190122, 0x02240784, 0xfe000200, 0x05830182, 0x012f0b83, 0xfd270159, 0x03d8feb1, 0x01b1fd77, 0x839e0428,
    0x4f02230b, 0x1583d9fe, 0x0000002d, 0xff520001, 0x05ad06c0, 0x82240040, 0x0106390c, 0x03222300, 0x23020326, 0x3e270722, 0x37363701, 0x12171636,
    0x32331617, 0x14820a83, 0x05125108, 0x0aad0616, 0xb3febefe, 0x2c628ee5, 0x12554858, 0xa8184d6d, 0x5f559c2e, 0x162c1774, 0x67334137, 0x7a0d0865,
    0x01784039, 0xfa03fb53, 0xfe61feec, 0xa0070151, 0x06014201, 0x9715624c, 0x09088a28, 0xe1fe8b81, 0xa1a1f956, 0x011a8b55, 0x00080b89, 0x22084755,
    0x82800500, 0x0a2b08d3, 0x21110000, 0x03012111, 0x03132113, 0xfa000601, 0xdd3d0400, 0xdd86fddd, 0x053d01dd, 0x0100fa80, 0x017702a5, 0xfdd7fe29,
    0x82d0fe89, 0x0400213a, 0x26087b56, 0x00120003, 0x86550041, 0x1707343f, 0x17371707, 0x27372737, 0x07232723, 0x07163205, 0x822e3437, 0x062208d6,
    0x1523011d, 0x11153233, 0x010f0614, 0x27352115, 0x013e022e, 0x37331135, 0x36372223, 0x3e34013d, 0x13820102, 0x36340128, 0x07211135, 0x27861617,
    0x87820620, 0x8c034108, 0x191f4b0c, 0x1f196b6b, 0x355f0c4b, 0x96fe3520, 0xae011920, 0x31484223, 0x4c608485, 0x490d0a14, 0x0695c001, 0x01010205,
    0x06e726bf, 0x0c030404, 0x3676021b, 0xfe020507, 0x175317ed, 0x05460e0c, 0x4b08be82, 0x5321c004, 0x39391972, 0x21537219, 0x20a36060, 0x4b37152f,
    0x7d730e25, 0xfe088048, 0x010c0e82, 0x0e565807, 0x04040101, 0x8301050a, 0x03060680, 0x1d1b1b50, 0x56c3fc0b, 0x03030109, 0x0802060c, 0x14071665,
    0x090e8efe, 0x00560902, 0x6431fb84, 0x00060007, 0x39002f00, 0x5b005100, 0x14010000, 0x05905906, 0x84592020, 0x34352f06, 0x17323336, 0x3e132536,
    0x3e051701, 0x40533301, 0x25352405, 0x82170403, 0x01162318, 0x67461614, 0x36012a06, 0x22262734, 0x22010e07, 0x29078326, 0x1e171406, 0x013e3202,
    0x44623226, 0x14770806, 0x323b0007, 0x90fed50c, 0x91fe50fe, 0x3e330bd5, 0x3c555374, 0x742901da, 0x010e1803, 0x2b481271, 0x7c58583e, 0x68b2fe57,
    0x3adb2c01, 0xfa745355, 0x587c57a2, 0x583d3e58, 0x0b0b2a03, 0x290b1e0a, 0x29a0a0a0, 0x0b0a1e0b, 0x5e972b0b, 0x16975e58, 0x3d58577c, 0xb202583e,
    0x2e195f3a, 0xf8fe9b32, 0x08019999, 0x192f2f9b, 0x75523a61, 0x020a983f, 0x03100d09, 0x822d2551, 0x3e572a45, 0x0928fe4a, 0xfe753d97, 0x366484e7,
    0x0b60fe58, 0x0a0a0b1e, 0x2a28282a, 0x1f0a0a0a, 0x09322b0b, 0x83f83209, 0x579d086c, 0x0000007c, 0xff450001, 0x06bb0602, 0x00300000, 0x3e331300,
    0x32332403, 0x1d161704, 0x031e2101, 0x1137013e, 0x27010c06, 0x26270226, 0x010e3712, 0x2e362107, 0x0e012f04, 0x10014503, 0x01be9155, 0x01e79401,
    0xfb686f6e, 0xa869019b, 0x49c9d7d3, 0xfeedfe5c, 0xf5bd8da2, 0xd3e40302, 0x02103c30, 0x3e20087b, 0x1644524f, 0xc6f98716, 0x7ee5029a, 0x5695cbe7,
    0xffbbc6d3, 0x52a36fbc, 0x33431a20, 0x4a3787fe, 0x01493602, 0x01f2c460, 0x833c6254, 0x4d7e4d5e, 0x010f1a38, 0x824f0501, 0x239b8297, 0xff000004,
    0x2b058370, 0x000d0009, 0x001b0011, 0x21113500, 0x2406574b, 0x35211501, 0x21038221, 0xac833201, 0x36343530, 0x5e000933, 0x4240f842, 0x0180025e,
    0xd882fd80, 0x42600624, 0x1382f75e, 0x6002202a, 0x5e42a0fd, 0x8022015e, 0x04270082, 0xe0425e80, 0x695e42e0, 0xfb8308db, 0xfd821f20, 0x00003b37,
    0x010e2725, 0x012e2223, 0x023e3435, 0x17163233, 0x23242637, 0x06a27822, 0x32334a08, 0x06010924, 0x24222100, 0x12100226, 0x20332436, 0x23031700,
    0x33112315, 0x0e011e32, 0xda300601, 0x938df54a, 0x915590f8, 0xe9836ec7, 0xfe6ed74c, 0xfea1ca9f, 0x7e7ed4da, 0xa12601d4, 0xfe7101d5, 0x74b50240,
    0xeefe4bfe, 0x07295fb6, 0x01b62408, 0x7da50104, 0x8860279f, 0x0a0c2d20, 0x786ff62d, 0x92f8908a, 0x5591c76e, 0xa97d6c79, 0xfed47ec0, 0x83befeda,
    0x02d62742, 0xfda0fe46, 0x2b45dafe, 0xfe5e0809, 0x74fee9f5, 0x286001a0, 0x00283838, 0xff200004, 0x06e00600, 0x00030000, 0x000b0007, 0x0900000f,
    0x01213701, 0x1f011127, 0x02091101, 0x93050121, 0x035c9afd, 0xb8b5fa57, 0x93149f04, 0x5c01ecfd, 0xa9fc0cfe, 0x3b036401, 0xfc978201, 0x5a0374de,
    0x5f6019fd, 0x4f01a6fc, 0xdefc7f02, 0xb3473b02, 0x80062306, 0x4f82f005, 0x7d001731, 0x35010000, 0x22012b34, 0x3b14011d, 0x8a253201, 0x1105280b,
    0x26341121, 0x83150622, 0x241b8207, 0x1133011d, 0x20078534, 0x25078835, 0x3316023e, 0x27632611, 0x07142805, 0x32333615, 0x82323316, 0x2b4e8205,
    0x26222306, 0x15072223, 0x021e3632, 0x33893b82, 0x15224382, 0x0f843311, 0x10800224, 0x02821060, 0x87000221, 0x80fd2507, 0xfd70a070, 0x03881683,
    0x070c053e, 0x21200110, 0x2d20212c, 0x104d1526, 0x10073c11, 0x49121b46, 0x01322813, 0x050c0710, 0x42822788, 0xe0100223, 0x30028910, 0x400110fd,
    0x50707050, 0xf002c0fe, 0x02701010, 0x84048270, 0x07063f03, 0x01010103, 0x17230f87, 0x23172020, 0x0f0a110f, 0x0fd2100f, 0x850c0f0d, 0x07030101,
    0x24847006, 0xfd101028, 0x00107090, 0x00820001, 0x0500092b, 0x006a0080, 0x14160100, 0x056e4907, 0x21013d28, 0x051e1716, 0xfb82013b, 0xe4483320,
    0x23063005, 0x3d262221, 0x2e222301, 0x032e2705, 0x820e2123, 0x34262e0a, 0x16323336, 0x3e323317, 0x063e3702, 0x05d7663b, 0x2306142d, 0x23272622,
    0x07040e22, 0x82210706, 0x08172140, 0x4a089f82, 0x0808c0fe, 0xfc100709, 0x102e25a6, 0x1f171f11, 0x12601120, 0x0e40010e, 0xfe0e1212, 0x60120ec0,
    0x2e2c3a20, 0x1312271c, 0x2d2c1c17, 0x1698fe18, 0x966a588a, 0x8a586a96, 0x2d186816, 0x13171c2c, 0x2e1c2712, 0x6b203a2c, 0x833e6215, 0x623e25f4,
    0x20116b15, 0x113b4782, 0x04252e10, 0x0210205a, 0x082608db, 0x0a0405c0, 0x6b3a8012, 0x203e2425, 0x87601024, 0x1232085c, 0x1b14600e, 0x274c2636,
    0x49393529, 0x966c5422, 0x546c96d4, 0x35394922, 0x264c2729, 0x39141b36, 0x70a07047, 0x24103947, 0x25243e20, 0x12803a6b, 0x1b600b14, 0x0007240d,
    0x82210011, 0x06142d12, 0x3311012b, 0x26100032, 0x33112123, 0xd4620984, 0x4f7e300e, 0x38fdfd38, 0x83b70201, 0xfdb44ffe, 0x59870282, 0x033012a3,
    0x014e703e, 0x01f7fe0d, 0x80fcb804, 0x69010d01, 0x37123c59, 0xff000004, 0x050009d9, 0x00270027, 0x004d003a, 0x01000061, 0x06272634, 0x07bf4918,
    0x35363723, 0x05ab5634, 0x16171628, 0x27220614, 0xa46a2326, 0x36322e05, 0x23061437, 0x35262221, 0x36373634, 0x32ac8224, 0x17011e17, 0x23060714,
    0x012e2722, 0x27103637, 0x82013e26, 0x10242133, 0x35211288, 0x05945234, 0x0617c108, 0x0735446d, 0x18290710, 0x1c1f0c0c, 0xd27a170a, 0x36e2867b,
    0x2c16506c, 0x694b1740, 0x6a96966a, 0x6f4f1604, 0xfb8ec999, 0xc8f0a9ea, 0x3e013e95, 0x5b01ebc3, 0xfa997417, 0x18291761, 0x120c1a13, 0x0c124747,
    0x61123f34, 0x17860001, 0x1a131729, 0x6c6c120d, 0x1a1a0d12, 0xb601123e, 0x2d155f3b, 0x031c182f, 0x471e390a, 0x7ad17b48, 0x4e1c7992, 0x162c4017,
    0x95d4954b, 0xc88e4e6f, 0xe499a9ef, 0xfee4b816, 0xbb19e7c3, 0x2190af79, 0x1a3f110d, 0x68020168, 0x0d243e1a, 0xfe448e1a, 0x0d22c718, 0xa41a3e12,
    0x1aa2c3c2, 0x0c12113f, 0x0002001b, 0x0500ff24, 0x000006dc, 0x006e0009, 0x06140500, 0x3227f584, 0x010e2716, 0x82171415, 0x052e3af1, 0x033e3435,
    0x15031e32, 0x011e0714, 0x3632011f, 0x042e3435, 0x2e272627, 0x20188303, 0x2e198433, 0x2223030e, 0x2e012a23, 0x012e3504, 0x8322012f, 0x1ec5083b,
    0x081e1703, 0xb47edc05, 0x7eb47f7f, 0x219b73e9, 0xb86de992, 0x2336627b, 0x2d1c090c, 0x2c526a53, 0x1c17081b, 0x7328276c, 0x362d1296, 0x1c495d5e,
    0x678e740f, 0x865b2929, 0xc8787ac7, 0x1e265a81, 0x112c362b, 0x1a130602, 0x1c2e2434, 0x25580f14, 0x2a634425, 0x7e44260a, 0x5d7d4c57, 0x13223049,
    0x590d020a, 0x5a597f7f, 0x0fbf7f7f, 0x404a76af, 0x56432a4e, 0x0e335254, 0x33412f13, 0x3b2f2324, 0x2f220e27, 0x01021e1b, 0x2d1a5266, 0x2d32262c,
    0x37070d22, 0x5e89725a, 0x6183904e, 0x6a523439, 0x492e3369, 0x0a0a1d2b, 0x57362612, 0x01131036, 0x254e3e01, 0x30362618, 0x39191d3b, 0x46374036,
    0x00334936, 0x09877700, 0x1f000f24, 0x3d582b00, 0x75252011, 0x00200e23, 0x2d07947e, 0x02042024, 0xff0e12c0, 0x12120e00, 0x0582010e, 0x0d8d0120,
    0xda7d8020, 0x6001230e, 0x2a834002, 0x52091452, 0x01210620, 0x1f9e18ff, 0x09cb490e, 0x17000b2b, 0x37002700, 0x20000000, 0x080d7f04, 0x3e200030,
    0x012e1001, 0x10010e20, 0x26222516, 0xd0531135, 0x52152005, 0x32210c94, 0x210f8416, 0xd37e2f02, 0x9e01290d, 0x92fa2801, 0xd8fefa92, 0x01210582,
    0x208f83ee, 0x849489c0, 0x8f05200a, 0xaefb23b8, 0x3588fa92, 0x0e124e22, 0xbf4ac695, 0x000f220c, 0x1149411b, 0x210b3941, 0xfc864004, 0x01214d84,
    0x1b2b41c0, 0x41101f41, 0x1f4109b3, 0x181d4105, 0x1d413720, 0x089c4505, 0x201c0d41, 0x07ab536e, 0x410e1221, 0x03452a02, 0x0b21080d, 0x3d002500,
    0x13250000, 0x23060716, 0x26272221, 0x13011337, 0x013e1321, 0x14152133, 0x3d363216, 0x25078801, 0x11251632, 0xa0840614, 0x06222623, 0x080b8715,
    0x16203620, 0x0323dd06, 0xf91d1313, 0x13131d80, 0x5d062303, 0x5654f956, 0x01192403, 0x4b6a4b00, 0x04838001, 0x2419002a, 0x342683fe, 0x96d49626,
    0xe13c0582, 0x80e13e01, 0x161cc7fe, 0x1c161515, 0x47033901, 0x0703f9fc, 0x35802118, 0x80354b4b, 0x21240585, 0x1a00ffa1, 0x08758f19, 0x9f220b87,
    0x6777e1e1, 0x36068306, 0x00230015, 0x003b002f, 0x006d0049, 0x16320100, 0x012b0614, 0x82010e03, 0x272630c6, 0x26222303, 0x01333634, 0x0327013e,
    0x6d0e012e, 0x25200566, 0x83061b48, 0x2f0b8cd8, 0x012e3613, 0x06030706, 0x32331716, 0x23030136, 0x3b21ff82, 0x263e8201, 0x15163221, 0x6d163233,
    0x2b2105b2, 0x06824501, 0x06222323, 0x2ca58407, 0x4808730f, 0x2e00fb2e, 0x0f730848, 0x28bb8235, 0x231a6501, 0x29022002, 0x23058334, 0xa0011925,
    0x0282eb82, 0x86800121, 0x20602507, 0x29342302, 0x232d2182, 0x2519051a, 0x845d7efb, 0x5a8c1365, 0x05af6ea7, 0x8c5aa729, 0x5d846513, 0x822d450b,
    0x80fe3310, 0x2da7261a, 0x4b000345, 0x6afd4b6a, 0x2e3c3c2e, 0x0a829602, 0x02e0fc30, 0xa0011a29, 0x2904231a, 0x1960fe1a, 0x0b824022, 0x82262621,
    0x821a200a, 0x200b8a05, 0x220b8215, 0x83230429, 0x02292a18, 0xfeda0422, 0x58b90164, 0x2724836f, 0x47fe586f, 0x382c9c01, 0x20080b83, 0x00020038,
    0x0680ff21, 0x008005df, 0x004f0003, 0x23130100, 0x06070103, 0x21032123, 0x0f161732, 0x26098301, 0x22012b06, 0x82372627, 0x20098719, 0x250f8221,
    0x3336013f, 0x09891321, 0x013b3622, 0x07233182, 0x87133303, 0x08418309, 0x40df0321, 0xfe0340fe, 0xfe180738, 0x370140b9, 0x040a0a0f, 0xfe1a0538,
    0x180751b9, 0x090a10e0, 0x82fe4e03, 0x0fe12109, 0xc9200984, 0x29820683, 0x40470123, 0x840b82fe, 0x47012529, 0xe0190751, 0x09881f85, 0x09394783,
    0x00010002, 0xf80100ff, 0x00ff18e0, 0xe00e0e0c, 0x18b8fe18, 0x01100c0c, 0x82078738, 0x18e0220c, 0x211b8501, 0x1b834801, 0x87c8fe21, 0x0c0c2207,
    0x26008200, 0xff6b0004, 0x79950500, 0x470806af, 0x00250011, 0x07170100, 0x03071711, 0x03110309, 0x17010907, 0x02100001, 0x2e22020e, 0x12100202,
    0x1e32023e, 0x94490302, 0x83949595, 0xcefed001, 0x30fe3201, 0x40015dff, 0x005dc0fe, 0x40cf02ff, 0xf6c1aa6f, 0x406faac1, 0x012d0887, 0x039594e3,
    0xfc94958c, 0x01d00161, 0x29018232, 0x009dfdd0, 0xbffe5dff, 0x3082bffe, 0xfe700131, 0xc9c7fe5e, 0x7c31317c, 0x013901c9, 0x853901a2, 0x2796820b,
    0x28000300, 0xd80300ff, 0x002f9788, 0x11273725, 0x09132737, 0x27011101, 0x82370109, 0x54022206, 0x080082ad, 0x6401202f, 0xd7fee5fd, 0xfe74016c,
    0x29016c8c, 0xac711b02, 0xac6e01ac, 0xfef1fdac, 0x02e4fd9c, 0x6cd8fec7, 0x75017501, 0x02d8fe6c, 0x00e4fdc7, 0x086f4f05, 0x0f00072a, 0x29001700,
    0x00003100, 0x52083952, 0x003a0651, 0x26200610, 0x13203610, 0x06010714, 0x2622012b, 0x01373435, 0x32013b36, 0x19860416, 0x4c000527, 0x684c4c68,
    0x820382fd, 0x4c043402, 0xe1c2fee1, 0x813e01e1, 0x13e0fb0d, 0x261aa020, 0x8420040d, 0x60fd2107, 0xcc201986, 0x4c212e83, 0x22358403, 0x851ffe4c,
    0x02e12c2e, 0xfa1214c0, 0x1a261a80, 0x82051214, 0x86bb2006, 0x00003116, 0x03000500, 0xfd0647ff, 0x0600b905, 0x10000a00, 0x1d3ba982, 0x09130000,
    0x37012e01, 0x01012913, 0x21130131, 0x01323613, 0x07061613, 0x83310109, 0x1721080b, 0xfc180368, 0x070e129c, 0x02ce0165, 0xfdb6fe94, 0x32fec6f0,
    0x053208c6, 0x0e076530, 0x039cfc12, 0x3f0e8418, 0xfc3e0308, 0x0d760209, 0x3401152b, 0x5b0609fc, 0x64029cfd, 0xfe85fd17, 0x0d2b15cc, 0xf7038afd,
    0x17200d82, 0x080a6f53, 0x0300e035, 0x13000f00, 0x00003100, 0x23353301, 0x07063501, 0x17272606, 0x3237011e, 0x21352101, 0x16071405, 0x23041415,
    0x06272622, 0x010e2722, 0x35242223, 0x53263734, 0x5f08056d, 0xa0800112, 0x684503a0, 0x60f9878b, 0x94f85801, 0x0228fe81, 0x0480fd80, 0xfe596380,
    0xce7ab8fd, 0x134c133a, 0xb87ace3a, 0x6359fdfe, 0x019d01f0, 0xf09d01e6, 0xfde0c002, 0x02245cd4, 0x604b5f01, 0x01016150, 0xbbc0e07d, 0x9d7f66a5,
    0x015869de, 0xde695801, 0xa5667f9d, 0x6101d1bb, 0x9ffecece, 0x0021a682, 0x08cf4109, 0x2807674d, 0x00280013, 0x002e002b, 0x23b1823e, 0x13352315,
    0x01230382, 0x88352115, 0x34112703, 0x01012b26, 0xab820727, 0x1115062c, 0x21331614, 0x37013632, 0x02820521, 0x080ef67d, 0xfc03022c, 0xf203fcfc,
    0x5501abfe, 0xa00260fd, 0x270360fd, 0xfe20080c, 0xfed2d286, 0x0c082086, 0xd804080c, 0xa9fc0c08, 0x026afeb9, 0x0482dd8b, 0x3e56e23a, 0x563e28fb,
    0xd8043e56, 0x7102563e, 0xff008080, 0x01fe7f7f, 0x00018080, 0xfc210b85, 0x293183a4, 0xabab00ff, 0x080c0001, 0x438228fb, 0x965e0425, 0x89149696,
    0x82562036, 0x570220d4, 0x1f2208bf, 0xc5823d00, 0xb25f2620, 0x1f062d05, 0x17031e01, 0x041e1716, 0x36371617, 0x02271383, 0x02052e01, 0x820c2027,
    0x0e900817, 0x15060701, 0x0e012301, 0x03022e02, 0x8b386880, 0x592422d0, 0x3e27270a, 0x2c355865, 0x502c0409, 0x4b937374, 0x32010199, 0xcc4d1c35,
    0x714c52fe, 0x2e3a3b53, 0x1101274b, 0x3501c101, 0x1e528ae9, 0x0d0d0e05, 0xfe684301, 0x688b16e7, 0x02ba95ac, 0xca52c4d0, 0x28111374, 0x2b1f1e10,
    0x545e8465, 0x8a540811, 0x207582aa, 0x22030642, 0x013a1524, 0x3c7efe32, 0xdc989d82, 0x883201c6, 0xa8b17048, 0x77e3aae5, 0xfe175454, 0x021d01b9,
    0x20020e18, 0x0520c882, 0x2f35c788, 0x47003700, 0x67005700, 0x2e000000, 0x20040701, 0x010e2625, 0x24cb8216, 0x010f020e, 0x37088206, 0x013f3233,
    0x16333736, 0x3316011f, 0x013e3732, 0x022e012f, 0x36373627, 0x20079943, 0x0e606f04, 0xb3660020, 0x6c26200d, 0x3d080fc5, 0x2d0c6405, 0xfefbfe1a,
    0x1afbfee8, 0x1a1b0c2d, 0x1b026dc2, 0x0a091c1a, 0x0e091916, 0x3608102c, 0x36112a11, 0x0e2c1008, 0x0a161909, 0x1b1a1c09, 0x1ac26d02, 0x6a4bb7fe,
    0x026a4b4b, 0xa3186f8b, 0x01340c62, 0xbd05011e, 0xc8fe4bfe, 0x7acee4fe, 0x1c01ce7a, 0x1c013801, 0xc8200984, 0x0813ff4c, 0x1b34552a, 0x063e3e06,
    0x062d341b, 0xde9e0c2e, 0x19154759, 0x29040a30, 0x78788b14, 0x0429148b, 0x1519300a, 0x9ede5947, 0xa3062e0c, 0x4b2b6d83, 0xfee2fe71, 0x6f6fbdfb,
    0x840501bd, 0x24098369, 0xfece7a6c, 0x21708ee4, 0x494d30fe, 0x00003812, 0xff440003, 0x06bb0500, 0x002f0000, 0x00480037, 0x07160000, 0x4d010e03,
    0x13260510, 0x14151607, 0x01532707, 0x08078205, 0x27013726, 0x012e0607, 0x3e013f36, 0x16011701, 0x010f1617, 0x26220225, 0x16323634, 0x37320114,
    0x22230617, 0x3435012e, 0x7a080882, 0x05161415, 0x2c05447c, 0x06293d04, 0x03392c03, 0x94378f23, 0x91cd5b89, 0x78896686, 0x950801a4, 0x3a5821b5,
    0x1aef2005, 0xe8011e44, 0x2b110c24, 0x297301cd, 0x94686894, 0x6adafc69, 0xbd928b5a, 0x7492fb94, 0x02cd3c8b, 0xfd2f46f6, 0x01382ad9, 0x012c4303,
    0x7f7108ad, 0x65899cd8, 0x5cce9186, 0x011b728a, 0x1ea1572c, 0x1d584205, 0x120717d5, 0x2f15e5fe, 0x14e83243, 0x8368a901, 0xbefa2e46, 0x92748b3d,
    0x94bc94fa, 0x916d588b, 0x4bd582cd, 0x0f28095b, 0x4e003e00, 0x00005a00, 0x4b09d05e, 0x01350548, 0x07020e14, 0x011d020e, 0x012b0614, 0x013d2622,
    0x37033e34, 0x25cf823e, 0x07222326, 0xdc820706, 0x2e012f22, 0x18056462, 0x2618a287, 0x0e127003, 0x84120ea0, 0x00012804, 0x262b3d1e, 0x84171d20,
    0x1523080d, 0x1d1f331b, 0x34572c35, 0x331d2738, 0x080b1009, 0x07040a6c, 0xdb81e37a, 0xedfcfeee, 0xab6666ab, 0x840401ed, 0x18012007, 0x210f58aa,
    0x51875001, 0xe201122c, 0x1e3a5032, 0x1c141215, 0x6583200f, 0x3b234438, 0x0d102324, 0x2a1f2419, 0x3f141b3b, 0x0752060c, 0xb3c00a1a, 0x4e824301,
    0xaa18568b, 0x0034108a, 0xff270004, 0x06590503, 0x00090000, 0x004f003e, 0x00000060, 0x2606214e, 0x14011415, 0x82272606, 0x010f26eb, 0x13011f06,
    0x22fb8203, 0x83270607, 0x011b26fa, 0x0e161707, 0x08178202, 0x35032e23, 0x33361303, 0x16011732, 0x1607011f, 0x1f011e05, 0x16171601, 0x012e0607,
    0x27262327, 0x15160103, 0x080c8414, 0x160126f9, 0x36013f36, 0x80ae0135, 0x5b805c5c, 0x433c8c01, 0x0791fe0e, 0x0703040e, 0xa1017a0b, 0x0d0f1943,
    0x191d3532, 0x05c30203, 0x0a042355, 0x07071412, 0x0b111f13, 0x17d32e04, 0x01204b5a, 0x030707a8, 0x6dfe0701, 0x18185b2b, 0x2f0b0624, 0x09283e23,
    0x7c020601, 0x031f9303, 0x06140b09, 0x03cbfe72, 0x0b030308, 0x415bc904, 0x405b5b40, 0x3223fd41, 0x01171623, 0x02070cb6, 0x8b0d0803, 0x37fe9efe,
    0x061a2ac0, 0x3c0d191a, 0x5902111b, 0xdea4a001, 0x0d132418, 0x0c030201, 0x020f1814, 0x7d012b01, 0xf7fd2822, 0x01030c05, 0xe071a60d, 0x205d3738,
    0x0c161b46, 0x09101320, 0xadfe5f01, 0x02050831, 0x0a290b05, 0x01e901ac, 0x09020204, 0x00000008, 0x00030007, 0x040009e3, 0x0002001c, 0x0023000b,
    0x004b0031, 0x007f0065, 0x03330100, 0x2b263405, 0x32331101, 0x42130136, 0x212f0746, 0x21230607, 0x01372622, 0x32213336, 0x84100416, 0x1135220d,
    0x310e8334, 0x030e1401, 0x033e2307, 0x2e34013f, 0x1e332703, 0x11a21f03, 0x01174d08, 0x0301abf8, 0x36606558, 0xfd6c5b34, 0x0e1301c2, 0xfe130ed8,
    0x120a37dd, 0x1315f5fe, 0x092c020d, 0x0e4c0112, 0xfb3b0314, 0x0ef2fec7, 0x010e1414, 0x9801c80c, 0x3d1c0f01, 0x3926332b, 0x0101101a, 0x381a0e01,
    0x3e292b26, 0xb902111d, 0x3e201782, 0x19201789, 0xb6201787, 0x38202f86, 0x17872f85, 0x1e02012e, 0x57a60901, 0x727cfe6a, 0x0cfdca01, 0x2c085d83,
    0x240f513e, 0x0ef50211, 0x7efec614, 0x020e14dc, 0xfe140ef4, 0x6b240b64, 0x2d2b7761, 0x1b5b6977, 0x5b1d081b, 0x2f3b835c, 0x1a596778, 0x0817ae1a,
    0x0004002b, 0x0500ff00, 0x00f20580, 0x005c004a, 0x0082006d, 0x2e340500, 0x022e2701, 0x22232627, 0x27222306, 0x2627032e, 0x033e3734, 0x05815437,
    0x023e3722, 0x35220282, 0x1f832634, 0x030e0728, 0x0e070607, 0xa7661001, 0x46172006, 0x1321051d, 0x22318222, 0x82343536, 0x32362838, 0x07141617,
    0x82221606, 0x3637220b, 0x21118610, 0x10850710, 0x10013e22, 0x34204782, 0x5e082483, 0x07021012, 0x241a6902, 0x09080102, 0x17240f09, 0x0d22185e,
    0x08050a06, 0x01252501, 0x060a0508, 0x5e18220d, 0x090f2417, 0x02010809, 0x20571a24, 0x40221914, 0x1d3f4f39, 0x3103061f, 0x38312626, 0x03743f1b,
    0x19224003, 0x9f572014, 0x2513261a, 0x34261325, 0x154b4b13, 0x131236b8, 0x83707013, 0x9696220d, 0x230c83a3, 0x5a61615a, 0x49080e83, 0x6d74746d,
    0x785e0b99, 0x1b2d0409, 0x0b0b0e08, 0x1d131505, 0x80fe8004, 0x15131d04, 0x0e0b0b05, 0x042d1b08, 0x0b5e7809, 0x080c3d16, 0x552f1112, 0x070c4337,
    0xf2feda6b, 0x277a6bda, 0x0101245b, 0x3d0c0812, 0x3526a703, 0xe9822513, 0x26341330, 0x4bd44b13, 0x1313b513, 0x01721334, 0x1083723c, 0x58fe9624,
    0x1083c896, 0x01ea5b25, 0x835bea00, 0xfe6d2812, 0xfeccfee8, 0x82006de8, 0x82142000, 0x08002503, 0x00800580, 0x0805eb4a, 0x27001f20, 0x37002f00,
    0x47003f00, 0x57004f00, 0x67005f00, 0x77006f00, 0x87007f00, 0x97008f00, 0x2f829f00, 0x14062227, 0x34363216, 0x20078624, 0x20078602, 0x8f178e00,
    0x5c27880f, 0x71180ed1, 0x0f870fab, 0x195d079f, 0x283f8f07, 0x5e840201, 0x015e845e, 0x820684a2, 0x20028209, 0x860c8502, 0x8cfd2013, 0x2721850d,
    0xa07020f9, 0x02a07070, 0x02820382, 0x0685fe20, 0x05200d8d, 0xfd201485, 0x0d860685, 0x37862994, 0x85600121, 0x2005845b, 0x22948302, 0x85fe845e,
    0x86058506, 0x210c8c13, 0x87830efc, 0x70226385, 0x0c919001, 0x1385fb20, 0x06850320, 0x28930d86, 0x2008d084, 0x09000070, 0x00ff0000, 0x0006fc06,
    0x0f000700, 0x1b001300, 0x54004c00, 0x7b006900, 0x00008c00, 0x068d4116, 0x07863620, 0x07011324, 0x0b862401, 0x0e140133, 0x030e0702, 0x23061415,
    0x36342622, 0x35363233, 0x067a4334, 0x00200022, 0x22211682, 0x22108326, 0x41021e32, 0x2520078b, 0x35203983, 0x5406d461, 0x2025058e, 0x06162516,
    0x2a418307, 0x2e272627, 0x013e3701, 0x85051617, 0x4f108911, 0xe62d05f7, 0x26263426, 0x00015334, 0x0100ff5a, 0x3e0c84ad, 0x3417e902, 0x1d1f2324,
    0x9fe10f26, 0x1a26261a, 0x3317966a, 0x27282224, 0xfef9fe24, 0x82f9fe8e, 0x9b5b2823, 0x9bd5ead5, 0x84fdfd5b, 0x4601212f, 0x83230682, 0x82845c5d,
    0xce290806, 0x01ce2401, 0x19160a8a, 0x21130e09, 0x159c4407, 0x34111008, 0x2501b715, 0x0b191509, 0x5c102c0c, 0x100716cd, 0xeb153410, 0x217683a6,
    0x05849a26, 0xff2d0127, 0x00015a00, 0x2c0c8587, 0x58633b00, 0x2623292f, 0x9f29423e, 0x305282e1, 0x61396a96, 0x2e273055, 0xb9376134, 0xf9fe0701,
    0x209383b9, 0x827e8275, 0x84db2085, 0x83402032, 0x835d2311, 0x07835d83, 0xcece922b, 0x0a30198f, 0xb2131604, 0x82688275, 0x85892180, 0x29220f83,
    0x0e829bee, 0xaf207d82, 0x24055f4f, 0x0800ff03, 0x066761fd, 0xb0006725, 0x18010000, 0x36085189, 0x3316011f, 0x36373632, 0x012f3425, 0x06222326,
    0x16070607, 0x82011e17, 0x0e012313, 0x11822701, 0x36320727, 0x17163233, 0x21198216, 0x19823223, 0x010e0723, 0x313e822b, 0x23060725, 0x26032722,
    0x13013f36, 0x36371236, 0x2082011e, 0x48820720, 0x07202a85, 0x2c823482, 0x16132528, 0x03010f06, 0x2d840206, 0x1e822620, 0xab413720, 0x4a0b8407,
    0x3e220523, 0x84821701, 0x41223721, 0x188205c4, 0x41223321, 0x3b2505c9, 0x05171602, 0x324a8237, 0x193b0804, 0x35253e11, 0x220a244b, 0x113e2530,
    0x87730219, 0x863b2009, 0xfe470819, 0x234c1156, 0x3033483e, 0x5c030d03, 0x1b11289d, 0x15151224, 0x111b2412, 0x065c9d28, 0xdefe1c10, 0x280f0eef,
    0x0e0ba011, 0x1194d116, 0x4f1f7995, 0x461f0732, 0x28907b2f, 0x3005043f, 0x2e4b5428, 0x24677335, 0x88b1031a, 0x231a2421, 0x85191d2d, 0x08042323,
    0x258b3724, 0x6a9a1220, 0x1c0e0124, 0x6b832301, 0x0240022f, 0x4b272235, 0x08213835, 0x3522271f, 0x20078682, 0x08158402, 0x2312012e, 0x111f111a,
    0x24536401, 0x0909114b, 0x53244b11, 0x1b020264, 0x01230778, 0x0d311740, 0x9b0b0177, 0x19641101, 0x1a4e3e07, 0x1154453b, 0xa782a182, 0x0a2d0a28,
    0x7c4b1232, 0x2183c0fe, 0x9bf5fe28, 0x1664effe, 0x21851f23, 0x24300122, 0x24202188, 0x00215b96, 0x050b4700, 0x06000736, 0x00130000, 0x004e0044,
    0x0100005c, 0x36321614, 0x20263435, 0x07f75a18, 0x16323627, 0x020e2202, 0x26178515, 0x15002000, 0x43010e14, 0x062207a7, 0xa7431614, 0x35032608,
    0x01012e34, 0x08777717, 0x14161733, 0x2726030f, 0x3236013f, 0x34262004, 0xdcfece26, 0x270682ce, 0x6884b884, 0x5b9bd5ea, 0x2b080a82, 0x72010701,
    0x27240701, 0x33242228, 0x1a6a9617, 0x9f1a2626, 0x1d260fe1, 0x3424231f, 0xfd9b5b17, 0xbdfde2c2, 0xa80c220c, 0x40060c0c, 0xe92a0482, 0x8142471a,
    0x220dcf5b, 0xee42c002, 0x42922006, 0x012506fe, 0xd59b5be3, 0x430c8375, 0x372a0527, 0x272e3461, 0x39615530, 0x6682966a, 0x299fe130, 0x23263e42,
    0x63582f29, 0x9bd5753b, 0x56838cfd, 0x222f5582, 0xa806060c, 0xe90d220c, 0x69994719, 0x570ccf5b, 0x14290bc3, 0x68005800, 0x14010000, 0x24ec8307,
    0x23060701, 0x05e35922, 0x16323323, 0x060a4801, 0x013e2730, 0x22233435, 0x15020e07, 0x32331614, 0x2f5a0714, 0x34352c05, 0x3435033e, 0x23012e27,
    0x84010e22, 0x013e2219, 0x05fa6137, 0x17323322, 0x83182882, 0x4e0810b7, 0x0b0d6203, 0x05020a29, 0x3a0b140b, 0x1c444634, 0x01111c17, 0x150d4ee6,
    0x02875b0d, 0x18f23103, 0x4a955e2c, 0x011993a1, 0x4b0e1604, 0x1d152a2d, 0x1807161e, 0x39231f45, 0x52576719, 0x06155992, 0x0b030513, 0x4f306d76,
    0x09050301, 0x7777a9b8, 0x48080953, 0x431bfd03, 0x0b32c832, 0x63020103, 0x26ac5840, 0x39fe210e, 0x08057b0e, 0xe216024d, 0x1106e941, 0x925fbc91,
    0x2202069e, 0x2f623453, 0x19202f18, 0x0703010f, 0x52441d16, 0x6a6c5822, 0x59165092, 0x3c060c16, 0x02090112, 0x2152890f, 0x008200a9, 0x00022a08,
    0x0500ff25, 0x00ff05da, 0x00650019, 0x2e340100, 0x07222302, 0x14150206, 0x3233021e, 0x37023e16, 0x36371236, 0x23061401, 0x27198527, 0x07010e07,
    0x2223030e, 0x08267d18, 0x030e1422, 0x26051a41, 0x34353703, 0x41012a26, 0x3883055f, 0x2033d508, 0x07021411, 0x33013e17, 0x011e1732, 0x0d04e802,
    0x2727171d, 0x24116c69, 0x1c042f45, 0x020a140c, 0x13104010, 0x080ff202, 0x40501606, 0x0fb8a71f, 0x081d0a06, 0xb2835e17, 0x279f8760, 0xa4263657,
    0x2e2e2101, 0x2d202120, 0x162b3550, 0x0a0a0705, 0xfae3010a, 0x6ebd7b45, 0x76013634, 0x6503054c, 0x1f1656a3, 0xcf047a13, 0x0f1f1d18, 0xf7fe3a17,
    0x4e532c89, 0x0501012f, 0x014d0a0c, 0xfd5b4d35, 0x010d07a7, 0x5d091003, 0x8b241308, 0x98b15b1f, 0x3588a75e, 0x1c436980, 0x32271701, 0x28212648,
    0x60765d3f, 0x0302092a, 0x6ce2f501, 0x138dc2e2, 0x6298fe09, 0x0324a2fe, 0x070d3e39, 0x000300bf, 0x0600ff01, 0x00fb057f, 0x0052003d, 0x01000087,
    0x16011f32, 0x07230282, 0x82010e03, 0x42232059, 0x25240548, 0x37262221, 0x2d23e482, 0x82012e01, 0x013b2307, 0x08842505, 0x0526f582, 0x33163217,
    0x1b4e3632, 0x17072b05, 0x2e03022f, 0x36262701, 0x45823637, 0x06294282, 0x16130116, 0x0f06010f, 0x27228201, 0x26012f26, 0x03072223, 0x17221e84,
    0x07850109, 0x0f861320, 0x1e171322, 0x19092484, 0x16323736, 0x1b203f03, 0x92313dde, 0x06480b28, 0xf1fd202f, 0x2709a0fe, 0x01263639, 0x2940fe04,
    0x3c020239, 0xfdba0127, 0x063229f7, 0x0a253906, 0xa1fee101, 0x06063026, 0x0e062336, 0x01d9c001, 0x0f170104, 0x0e23ba14, 0xba151b19, 0xee2405da,
    0x18010301, 0x4a1f200b, 0x06028e1b, 0x03122001, 0x0f040fa5, 0x6a370c30, 0x35922902, 0x2a22de40, 0x19eb2533, 0x4d21220e, 0xfe0a0118, 0x251515fa,
    0xf1144b23, 0x22150f88, 0xc1114e25, 0x181e0865, 0x38020c01, 0x03382729, 0x2894125f, 0x3c2eaa39, 0x2b2063fe, 0x38203804, 0x05362528, 0x27293c20,
    0x05400134, 0x2d232940, 0x3f0a5e3c, 0x022d2425, 0x2e012560, 0x51177d0d, 0x7dca2621, 0x01260225, 0x01050106, 0x17194e1f, 0x01931c0b, 0x6c2d0205,
    0xf6fea701, 0x3bdb4a49, 0x2f3e361c, 0x942a3daa, 0x38012517, 0x16175121, 0xa0fe2010, 0x5023c701, 0x22181213, 0x51015cfe, 0x13114e23, 0x61fe261a,
    0x14050fc4, 0x3c29e010, 0x03453901, 0x071e3c05, 0x00620500, 0x005d0052, 0x0070006d, 0x27222500, 0x2627012e, 0x063e3435, 0x82253637, 0x056b7207,
    0x2033363a, 0x14161700, 0x07010e07, 0x07141516, 0x2f222306, 0x06370102, 0x011a1607, 0x27210e85, 0x360c8201, 0x23141500, 0x012f2622, 0x1e070603,
    0x14131701, 0x13241725, 0x821e2502, 0x00062522, 0x32331614, 0x61453a82, 0x232a0805, 0x17272522, 0x04024f01, 0x1539a556, 0x070a0404, 0x0212060e,
    0x6e0c01b8, 0x120c7411, 0x645c7c0a, 0xcf010a01, 0x5b141493, 0x128297ff, 0x130b6708, 0xfe407c0a, 0x293a0744, 0x09eef803, 0x03393b0d, 0x2b2738fe,
    0x0b7c0118, 0x6a04890e, 0x02222ce0, 0x03b00720, 0x11013134, 0xe9feb4b1, 0xfe5e4843, 0x56141c6e, 0x1c281c7a, 0x01147eb2, 0xb4070952, 0x5cb03902,
    0x1409271e, 0x160c1410, 0xfb031708, 0x130dc672, 0xe510400a, 0xe8edfe13, 0x8e1f4c1f, 0x0dc640df, 0x10820914, 0x03774208, 0x17180734, 0xfe36fe05,
    0x02070348, 0x49030703, 0xfd2b281c, 0x2c0a0443, 0x9d01c506, 0x2c033535, 0x0ab9fe0c, 0x016f5b66, 0x70150112, 0x6a5ca940, 0x283b02bd, 0x14567a1c,
    0x7e141c1c, 0x070411b2, 0x34008200, 0xff000004, 0x05fe0497, 0x001f0069, 0x0035002f, 0x0100004f, 0x05f84714, 0x3e343528, 0x17323301, 0x8e6b0706,
    0x36203006, 0x36273435, 0x14271637, 0x22010f02, 0x82043e27, 0x2716280e, 0x1e272615, 0x82221301, 0x37362418, 0x4507010e, 0x9608057e, 0x37013e37,
    0x07141516, 0x1a04010e, 0xe8e69493, 0xf2889392, 0x20566093, 0xa74d4207, 0x5201e1e3, 0x394220e0, 0x9f9fcc29, 0x53211d0e, 0x0f2d487f, 0x49373703,
    0xfd6d5885, 0x48da4d53, 0xc32a0213, 0x1a22236b, 0x5e3b6f2e, 0x20184a1b, 0xd7ae0171, 0x9fa1a19f, 0x92f793d7, 0x1c403e1f, 0xedaaa8f6, 0x4d59aaed,
    0x4b62240d, 0x64cefec0, 0x8d200501, 0x5bafd2a8, 0xa2a02245, 0x3be2d602, 0x4bb9feff, 0x13257f78, 0x3619915e, 0x1a54253b, 0x55101e2c, 0x6d94693a,
    0x826b4d3d, 0x09c757ef, 0x29001a28, 0x44002e00, 0xf1825400, 0x06273423, 0x4aaf8207, 0xf382059c, 0x83373621, 0x161024f3, 0x82033620, 0x030e2e16,
    0x013b1607, 0x27341136, 0x1627012e, 0x232c8305, 0x1415010e, 0x20050979, 0x068a4907, 0x080e0356, 0x1c1a043c, 0x9a162c29, 0x739c9be8, 0x17042d35,
    0xcf9a413c, 0xcf3401cf, 0x1f0a02b2, 0x15395732, 0x26db0a15, 0x5c3a5004, 0x29338101, 0x18504553, 0x041d854a, 0x3a34448d, 0x11154e33, 0x1c464901,
    0x013f080b, 0x19454eef, 0x75403209, 0x7375a3a3, 0x2c2b13a9, 0xcafed915, 0xfd01d5d4, 0x783f2f18, 0x16617391, 0x10018b03, 0xb7506d74, 0x66299c27,
    0x13175648, 0x25284145, 0x34416411, 0x4a342677, 0x46f02a35, 0x002a1013, 0x000680ff, 0x4f008005, 0xf9845b00, 0x20064343, 0x05a14b02, 0x27222323,
    0x06164736, 0x60060721, 0xfe410530, 0x021e2505, 0x06071415, 0x1e261384, 0x36323302, 0x06833233, 0x0a823e20, 0x32331626, 0x3637013e, 0x3f0cee5d,
    0x664316ff, 0x2f27071d, 0x0c142527, 0x08040b28, 0x86241105, 0x114cc755, 0x0c0a0405, 0x23150a28, 0x073f1982, 0x89168640, 0x100f0802, 0x230e330c,
    0x29472c40, 0x402b482b, 0x0d330e23, 0x02080e10, 0x5e010189, 0x33080f22, 0x0f051684, 0x06134058, 0x1d0c160f, 0x10191316, 0x4f135f02, 0xa5574e23,
    0x5f134f23, 0x14180f02, 0x160c1d15, 0x8a13060f, 0x2e16051d, 0x132a0516, 0x1e231e09, 0x08260282, 0x16052814, 0x725ffb01, 0x0100320e, 0x80ff0f00,
    0x80057106, 0x00005b00, 0x17163601, 0x82de8216, 0x82d782c9, 0x820e2009, 0x1e1723ec, 0x16851701, 0x23020e26, 0x22232622, 0x5007cf74, 0x3641057f,
    0x36372205, 0x25fb8337, 0x022e3435, 0x88503435, 0x35262206, 0x08148234, 0x86500337, 0x091b39d5, 0x42120e0e, 0x3f361d12, 0x250c3f4b, 0x341c4f83,
    0x0807db1c, 0x54141714, 0x20192516, 0x5a3e363e, 0x3d593436, 0x1a1f3e36, 0x11531825, 0x07081419, 0x082282db, 0x24854e4b, 0x3f4c3f0c, 0x420f1d34,
    0x090e1214, 0x05d8401b, 0x7b8b0180, 0x902f793a, 0x1c241b07, 0x27132c20, 0x521c0f1c, 0x0b0c2188, 0x21461d06, 0x0d25380b, 0x29230505, 0x281b1b28,
    0x05052329, 0x0b3a250f, 0x061d4621, 0x8a200c0b, 0x2d288251, 0x1f2b1427, 0x071a251b, 0x3a7a308e, 0xb75f7a89, 0x004f220c, 0x4c03425f, 0x0fc14018,
    0x42000521, 0x29080507, 0x1425272e, 0x040c280b, 0x24110508, 0x4dc65685, 0x050a0612, 0x140a290b, 0x272e2723, 0x16864007, 0x0e08028a, 0x0d330d10,
    0x07424123, 0x23412b05, 0x0f0d340d, 0x8a01080f, 0x0c430001, 0x1684270c, 0x41580e05, 0x04420b0e, 0x343f2d08, 0x574e244e, 0x264d26a5, 0x1910024c,
    0x2b050442, 0x1d8a0e0b, 0x162f1605, 0x0a132a05, 0x26050442, 0x032b1309, 0x430b0316, 0x01200e0b, 0x28059368, 0x4f000006, 0x0e010000, 0x05fe4805,
    0x0607d608, 0x06052407, 0x3f013e07, 0x37033e01, 0x17320536, 0x0307011e, 0x23262706, 0x06070422, 0x012f022e, 0x33343534, 0x00123732, 0x051e3233,
    0x043e3717, 0x09033e37, 0x42704500, 0x03161635, 0x0f17330a, 0x08504146, 0xabfe682f, 0xd35cdffe, 0x0f104e2f, 0x8553b847, 0x1701ba4c, 0x060b0901,
    0x200fc206, 0xfe92e280, 0x86528800, 0x010c2a50, 0xc0e98a06, 0x05c96d01, 0x46353913, 0x660e3438, 0x47332602, 0x7c423461, 0x00064277, 0x49465c2e,
    0x12062f2a, 0x3f1d2eed, 0x1f062c26, 0x35ac0ec8, 0x071e107e, 0x204b1b07, 0x261f0d25, 0x0b160603, 0x071da7fe, 0x01025918, 0x11222e1c, 0x06010101,
    0x016e0137, 0x0f09013c, 0x2e492d22, 0x604d04b1, 0x5241907b, 0x00214a77, 0x21eb8205, 0x01820600, 0x00460029, 0x005e0058, 0x826a0064, 0x071424f3,
    0x8b061727, 0x27222403, 0x8b260737, 0x34352503, 0x36271737, 0x3325038b, 0x37071732, 0x25038c16, 0x23240234, 0x574a0e22, 0x12242606, 0x01091113,
    0x84018311, 0x08048306, 0x052a0525, 0x2713e0ec, 0x3f2cb1d6, 0x4f3d679d, 0x4c260e4f, 0x4a4e0e26, 0x3b9d6742, 0x27d6b231, 0x05ede013, 0x83e1ee05,
    0x3d2e2a20, 0x4943679e, 0x27240d4d, 0x26218526, 0xb12e3d9e, 0x821525d5, 0x1e510821, 0x9ef3fe9d, 0x5c9dd877, 0x77d89d5c, 0x9d0d019e, 0xfd6ffd49,
    0x0291026f, 0xfd3cfdc4, 0xfdc4053c, 0x0300fd00, 0x2d800200, 0x494e0e1f, 0x3d9e6744, 0x25d7b22f, 0x06f0e416, 0x13e2ee06, 0x2bb2d728, 0x45689e41,
    0x2a0e4f48, 0x0e2a2322, 0x6843494f, 0x8221839f, 0x06ec3c7c, 0x13e1ed06, 0x2fb2d628, 0x3e689f3d, 0x1f0e4e4f, 0x0f01a02e, 0xda9d5d9d, 0x82da7778,
    0x01260806, 0xfd1e020f, 0x0181fe02, 0x01fe027f, 0x01cbf97f, 0x0137039c, 0xfc65fe9b, 0xfc5b03c9, 0x0140fe80, 0x018003c0, 0x1b7100c0, 0x06a70805,
    0x00000680, 0x00290014, 0x01000036, 0x22210721, 0x14111506, 0x33161716, 0x26222315, 0x36341135, 0x0e013325, 0x36350706, 0x34353637, 0x13330127,
    0x36211101, 0x34112137, 0x1e372726, 0x02530101, 0x67fd1ab3, 0x5d799d6e, 0x8c2d4b17, 0xdf03c7c7, 0x171efef7, 0x4c353723, 0xa33e6c53, 0xfe141439,
    0x03bbe4e3, 0x25e5fc56, 0x63a60208, 0x7d651950, 0x9e482605, 0x5ffdfc6e, 0x48051395, 0x03038cc8, 0xfadac88c, 0x6f553df2, 0x2131514c, 0x9c1ac302,
    0x34363534, 0xb7fddd02, 0xa9fbf201, 0x0e041237, 0x431d8c55, 0x8200b322, 0x5b0a2000, 0x07200867, 0x212eb182, 0x39002d00, 0x6e005b00, 0x90007800,
    0x1f82e700, 0x22061434, 0x32363426, 0x26343503, 0x011d0622, 0x32331614, 0x0c953736, 0x3230188b, 0x04060136, 0x022e2223, 0x06373435, 0x17121415,
    0x08594e18, 0x0a833220, 0x3617162b, 0x23342712, 0x23060722, 0x82218522, 0x36372257, 0x22648301, 0x82161415, 0x6734203d, 0x3b8205c4, 0x33311984,
    0x14151632, 0x05013e07, 0x06070214, 0x15010f04, 0x23398214, 0x27220627, 0x23230684, 0x83352622, 0x37362308, 0x2e832726, 0x26272627, 0x033e3435,
    0x256b8233, 0x37013e37, 0x0582023e, 0x03820c83, 0x0e234682, 0x821e0702, 0x82072040, 0x38108384, 0x38225403, 0x82382222, 0x29283c29, 0xac291e1d,
    0x29293c28, 0xae291d1e, 0x20078229, 0x3306873c, 0xfe540c01, 0xd57bafd8, 0x68155290, 0x3d1e7882, 0x37201e38, 0x3d080382, 0x381e206e, 0x700d311c,
    0x11488e82, 0xe2365f1e, 0x92b2531e, 0xfe0d636f, 0x40624046, 0x023f643f, 0x62974b75, 0x3037904d, 0x5935665b, 0x35331124, 0x01554b04, 0x3a3c4317,
    0x045beefe, 0x40862b3b, 0x44823720, 0x382f4a08, 0x5d766c5a, 0x45713436, 0x4b592720, 0x121830c0, 0x426c412d, 0x1713163b, 0x0a031402, 0x5710181a,
    0x1b2388f9, 0x3953573b, 0x130d0c05, 0x10261101, 0x2319289d, 0x045a372d, 0x2f2f3ae8, 0x54fa2f3a, 0x2b2b1e72, 0x2c1e721e, 0x9a04822c, 0xca023109,
    0xab67c7a0, 0x565878e0, 0xfea2d7af, 0x323965d4, 0x39080084, 0x015e191f, 0x064bb313, 0x7656f313, 0xdd96947f, 0xb2023046, 0x324f4f32, 0xfe4f4f33,
    0x6ca660e0, 0x6d9f3b46, 0x06136a68, 0x141a3438, 0x6f72c344, 0x4042ebfe, 0x72011a9d, 0x3e84402b, 0x43323308, 0x01504430, 0x07601f13, 0x3872c02e,
    0x9c893968, 0x1d34547e, 0x06140319, 0x14262e0f, 0x4004846f, 0x05070539, 0x01130f11, 0x060c1806, 0x1ef08a13, 0x2b435031, 0x05874805, 0x2500192c,
    0x00003100, 0x21273401, 0x406b3315, 0x49172008, 0x33230681, 0x19253632, 0x480a938d, 0x033c0b64, 0x96fe0695, 0x507d0cd9, 0x638c8c63, 0x6c683c5d,
    0xe0e0a095, 0x01cba5a0, 0x6e6d6d59, 0x01210082, 0x0e424812, 0x21770232, 0x594c841f, 0x3b8fc68f, 0xfee16465, 0x77d2e1c2, 0x6e232682, 0x4876016e,
    0x8e820f1d, 0xff250022, 0x20052f45, 0x380c8227, 0x06071411, 0x23242223, 0x23110722, 0x35012e11, 0x16323634, 0x07061415, 0x05315315, 0x32335008,
    0x33013e37, 0x00061632, 0x49a4ae31, 0xa455e3fe, 0x4c3fa0ce, 0x4c80b680, 0x6399be3f, 0x34c30e63, 0x8a0b584d, 0x04261a14, 0x30b9fc00, 0x303b340e,
    0x5805aefe, 0x5b447019, 0x445b8080, 0x2c441970, 0x1229020f, 0x00262602, 0x00000500, 0x830951ff, 0x00053e06, 0x00560039, 0x0094005c, 0x36321200,
    0x05062226, 0x0727052e, 0x26272606, 0x2e013f36, 0x2a8f8202, 0x1123010f, 0x031e3632, 0x82160117, 0x36162381, 0x86821637, 0x0b822720, 0x26013e3a,
    0x23113317, 0x012b2627, 0x06010f22, 0x011e1714, 0x1e36013f, 0x011e0701, 0x17220a82, 0x4f840416, 0x5105ac47, 0x0e280538, 0x010e2701, 0x0127012e,
    0x26080f77, 0x013b063e, 0x82361732, 0x1e5d0804, 0x32211706, 0x20509816, 0x06205020, 0x1a390a09, 0x162e2332, 0x50fb537d, 0xb13a0139, 0x4c253a16,
    0x9e425c0b, 0x0c20059b, 0x08150e1b, 0x70732901, 0x6f392f4e, 0x14354a11, 0x210a0220, 0x071f442b, 0x9d5d6084, 0x59a76742, 0x1b1cd139, 0xc12c862b,
    0x0a253919, 0x1d145010, 0x01340b6b, 0x08568400, 0x26080185, 0x1b4efe1a, 0x5f21466e, 0x427d2a37, 0x6f7b843c, 0xfee1fe30, 0x26261a9a, 0x0ea5011a,
    0x2a3b1d42, 0x7524403c, 0x63525263, 0x314023a7, 0x1b332336, 0x63010e37, 0x8001261a, 0x06404040, 0x40224a0d, 0x8c17342a, 0x4560045e, 0x0bce44b2,
    0x4202010b, 0x01e0fd9e, 0x0b060301, 0x6fdcfe08, 0x3938142f, 0x37123206, 0x402a0a17, 0x0002184f, 0xf3434cb4, 0x33215421, 0x17da3202, 0x131f3303,
    0x8b241858, 0x824a420f, 0x022d084a, 0x1a80fd00, 0x0a534126, 0x350c4330, 0x0b220439, 0x012f4427, 0x021a261a, 0x0e261aa0, 0x17341c44, 0x38380b1c,
    0x1a24110c, 0x10411f35, 0x0c736126, 0x4f002524, 0x00490000, 0x3763080a, 0x3e37063e, 0x021e3203, 0x17061e17, 0x37240116, 0x012f013e, 0x0607012e,
    0x22030e07, 0x2627022e, 0x0f062627, 0x17160601, 0x041e0516, 0x07033e32, 0xfa425e00, 0x0b5e4240, 0x46153e08, 0x6ea57a46, 0x50305f05, 0x5c32503a,
    0x7aa56e06, 0x3e154646, 0xccfd0b08, 0x0b520701, 0x08260803, 0x70e70b1a, 0x82315e05, 0x5e31261f, 0x0b9dba05, 0x0813821a, 0x520b033b, 0x500a0701,
    0x4a4d4e32, 0x5230514d, 0x2efc7203, 0x425e5e42, 0x090fd203, 0x3a113707, 0x50795d35, 0x25214804, 0x05462225, 0x355d7950, 0x0737113a, 0xbfa8fd09,
    0x0b19083d, 0x22548234, 0x830351a9, 0x4821261d, 0x08748603, 0x2c128203, 0xbf3d0819, 0x2d223c08, 0x202f1616, 0x46ea823f, 0x072e05df, 0x00000600,
    0x00500031, 0x01000070, 0xcd821617, 0xd0820220, 0x83022b21, 0x24d582d2, 0x013f012e, 0x2e17823e, 0x3b031e17, 0x023e3202, 0x36372437, 0x82111316,
    0x2e2522ec, 0x20258203, 0x292d820e, 0x07060702, 0x33161411, 0x63533221, 0x3637240b, 0x833e3700, 0x021e2234, 0x3a028217, 0x27c20516, 0x2b0a0308,
    0x27047ea7, 0x254a4f2a, 0x4a250101, 0x05262c4e, 0x8227a778, 0x252008ac, 0x5e0b1b08, 0x2c4d05d4, 0x01011845, 0x4d2c4518, 0x37020105, 0x5ac61a0b,
    0xd6fe5b45, 0x462a5003, 0x46301683, 0xd703502a, 0x0e353ac9, 0x050d1307, 0x80130dc0, 0x28056041, 0xc6017b29, 0x4d2e2406, 0x0853834b, 0x2e4d4b6c,
    0xe2e22b24, 0x6f022958, 0x08190b33, 0x03618122, 0x17322020, 0x1f213217, 0x1e815d04, 0x340b1908, 0x4909040b, 0x1f3e04a3, 0x3e1f2222, 0x082cc604,
    0x0326fd03, 0x4a3853a0, 0x1e4202e6, 0x421e2323, 0x319fa602, 0xfc070c32, 0x13130d60, 0x60fcad03, 0x425e5e42, 0x2638a003, 0x05610172, 0x1831231e,
    0x1e233118, 0x52b6ac24, 0x00820026, 0x15000b27, 0xeb0500ff, 0x09df7106, 0x1e001a31, 0x26002200, 0x32002e00, 0x00007600, 0x822f1725, 0x052728ea,
    0x27031701, 0x82032501, 0x012f3007, 0x0f061614, 0x01161701, 0x01250305, 0x84170737, 0x37220816, 0x16170727, 0x3725010f, 0x0727020f, 0x06010f14,
    0x1417012f, 0x23060507, 0x26273526, 0x013f2603, 0x05872726, 0x32253727, 0x15160517, 0x2b258213, 0x17151617, 0x011f3637, 0x013f3437, 0x1e240682,
    0x15010e01, 0x07091682, 0xca4a0106, 0x1201d822, 0xfe0b1201, 0xe3eefed4, 0x3c01f530, 0xfe0e3d01, 0x5f8d01a0, 0x02026702, 0x07554e04, 0x00013ffd,
    0x04e9fe44, 0x02e60f66, 0x7501e1fd, 0x0359fe13, 0x02e2149a, 0x07020690, 0xb31e0201, 0x08471314, 0x0707ea04, 0xfe040762, 0x080204db, 0x023704e4,
    0x015e3d07, 0x5e080248, 0x02600285, 0x05b10109, 0x063d0103, 0x7e760614, 0x05790505, 0x05035406, 0xf50506ce, 0x140f0204, 0x0106bf04, 0xfed5ecd6,
    0xd7f5da33, 0x01d58601, 0xe2fdcc47, 0xc84401d6, 0xef50a3fe, 0x090f014f, 0x06463403, 0x01c89e02, 0xb3fbadd1, 0x02f0a4ea, 0xb901c271, 0xe9bbfca3,
    0x045f698e, 0xde5c7705, 0x3121e480, 0xbb030575, 0xa1530505, 0x02ea0305, 0x04f20102, 0x04071101, 0x01065625, 0x2d05075f, 0xd2010864, 0x0187030a,
    0xfe050499, 0x3d030731, 0x7b060255, 0x3804044a, 0x7e03066e, 0x04870303, 0x03877206, 0x05990205, 0x320bc349, 0x0027001d, 0x01000055, 0x23032e34,
    0x2e22040e, 0x55222703, 0x2123050d, 0x48033632, 0x152409ac, 0x012b0614, 0x497c0482, 0x16322209, 0x3c41181d, 0x8333200a, 0x8223840e, 0x04200809,
    0x301f0bb1, 0x37063350, 0x2e2f331e, 0x371e332f, 0x30503306, 0x3d540b1f, 0x543d4002, 0x99d699ad, 0x02330282, 0x600e127c, 0x40fb425e, 0x425e5e42,
    0x5e42c004, 0x82120e60, 0x08058811, 0x392a0127, 0x2d476564, 0x18102104, 0x10180a0a, 0x472d0421, 0x49396465, 0x9b026161, 0x6c98986c, 0xfe98986b,
    0x120ec04f, 0x203e83e0, 0x243e8205, 0x12e0425e, 0x2010820e, 0x36058680, 0x00040000, 0x0600ff00, 0x00000680, 0x002b0009, 0x00690059, 0x50140100,
    0x322505fb, 0x1e320316, 0x29ce8704, 0x3b033e34, 0x32051e01, 0x1f82043e, 0xcb8ce582, 0x13851d20, 0xd6601420, 0x21f9850b, 0x436f0115, 0x0404210e,
    0x2608da85, 0x2f492e30, 0x4f071020, 0x42c0fd42, 0x2d1c094f, 0x07053551, 0x1d2d1532, 0x1d292629, 0x0232152d, 0x600d13b3, 0x88130d60, 0x0c054105,
    0xff130d27, 0xfb0d1300, 0x251f8340, 0x130dc004, 0xea827c03, 0xf2826b20, 0x22b8fe35, 0x4c59493d, 0x67674329, 0x6a5b3043, 0x1f04344d, 0x8209170b,
    0x0b172900, 0x0d04011f, 0x0d138013, 0x05852e82, 0x830b1541, 0x8205204c, 0x0d132219, 0x3c5483fa, 0x00060000, 0x0880ff00, 0x00800500, 0x00210019,
    0x00410031, 0x00750051, 0x2e340000, 0x08014202, 0x16140233, 0x02322133, 0x06222634, 0x01321614, 0x23263435, 0x061c4b21, 0x36322122, 0x0f233f19,
    0x1e460f8f, 0x21348205, 0x3483012b, 0x09892120, 0x82051b4c, 0x1622085a, 0x29120004, 0x30063950, 0x2a2a2c1b, 0x301b2c2a, 0x29503906, 0x02364a12,
    0x85533600, 0xbc8585bc, 0x4a6f2204, 0x0f152b0b, 0x150fc8fd, 0x38020f15, 0x626f150f, 0x5e002b0c, 0x12a0fe42, 0x120e400e, 0x068400fd, 0xa0fe2008,
    0x425e5e42, 0x5e42c006, 0x6b805501, 0x1c043963, 0x0909140f, 0x041c0f14, 0x806b6339, 0x833f0255, 0xfe85225c, 0x843182e6, 0x0112222f, 0x21538212,
    0x04830f15, 0x890b0121, 0xfb4e2215, 0x0d934240, 0x2305a542, 0x0700005e, 0x37143f41, 0x00000085, 0x21230614, 0x3e342622, 0x041e3302, 0x37033e32,
    0x02011e32, 0x43065d4c, 0x3d20073b, 0x2006316e, 0x067c4235, 0x13200f97, 0x200c5b42, 0xdc441835, 0x0d554611, 0x52413620, 0x364a2505, 0x4a3600fe,
    0x20115841, 0x2a52418b, 0x0d138030, 0x130d40f9, 0x60010d13, 0x0e400e12, 0x57410312, 0x60012805, 0x5e80130d, 0x4140f942, 0xd522085e, 0x61415580,
    0xbb012310, 0x6b8285bc, 0x4160fd21, 0xee200848, 0x20085d41, 0x231388f5, 0xc00432fc, 0xfb206183, 0xf0436782, 0x0e122508, 0xcd041360, 0x20090f44,
    0x0d8b475e, 0x17000f2e, 0x00002800, 0x27012e25, 0x2622010e, 0x072e0482, 0x24200416, 0x20261002, 0x20161006, 0x51181000, 0x2e080799, 0x24361210,
    0x05160420, 0x778316f3, 0xb9ceb943, 0x16837743, 0x014a016a, 0x894a017e, 0xe1c2fee1, 0x023e01e1, 0xfeef8ee1, 0xfeb6b7b4, 0x788ef0b4, 0xc53208a0,
    0x4a10cd9b, 0x104a5353, 0xaf969bcd, 0x01b202af, 0x2e83e13e, 0xfe360126, 0xf1b5fe94, 0x09822789, 0x23480020, 0x0010240a, 0x822c0024, 0x227282aa,
    0x76141512, 0x01250912, 0x02343536, 0x2b898226, 0x14150206, 0x16331217, 0x26323720, 0x0230ac86, 0x016c01ca, 0x8d8ef04c, 0xfeb4fef0, 0xefb4fe92,
    0x04225382, 0xd668956d, 0x42952809, 0x6c0183f0, 0x86a9f083, 0x000622b0, 0x212a828e, 0xb082b5b6, 0xf18e8f24, 0x3e844b01, 0xcd47fb24, 0x6b699cfa,
    0xe4fe2905, 0x01cdfa9c, 0xa1808047, 0x3b41b586, 0x00062c08, 0x1f000006, 0x37002700, 0x44010000, 0x37210cf2, 0x06c06026, 0x0014152b, 0x16100620,
    0x13103620, 0x23b48332, 0x27200627, 0x163db483, 0x2fb10433, 0x2c425d55, 0xaafc8dc8, 0x422cc88d, 0x4f2f555d, 0xd0bd8a51, 0xfe518abd, 0x0549419f,
    0x2be12208, 0x939d7d58, 0x9182fe91, 0x587d9d93, 0x300ef002, 0x83d38562, 0x9adbdb9a, 0x6285d383, 0x937d0e30, 0x822d8268, 0x93682334, 0xcc861302,
    0x8fe1fa30, 0x1401ef66, 0x077f7f07, 0x66efecfe, 0x0082008f, 0x00000425, 0x830500ff, 0x001126ab, 0x00230019, 0x0c4d433d, 0x43321621, 0x11210c4a,
    0x11564921, 0x21333630, 0x3b161415, 0x3d363201, 0x16322101, 0x0a430004, 0x38513407, 0x3850d850, 0x87882951, 0xbe8787be, 0x00fca101, 0x49030d13,
    0x30080525, 0x5e4240fc, 0x6001425e, 0x0ec00e12, 0x42600112, 0x8056015e, 0x6c805656, 0x4b4b3964, 0xb9016439, 0xbc8585bc, 0x05a0fb85, 0x0da0fa60,
    0xcd051313, 0x202f84fa, 0x08ab4605, 0x00005e23, 0x080b4408, 0x1b00133b, 0x3b002b00, 0x5b004b00, 0x75006500, 0x34010000, 0x0623022e, 0x0e222722,
    0x23998202, 0x36322133, 0x45174e45, 0x25200f5e, 0x85082f45, 0x105e45d1, 0x8f452120, 0x21152106, 0x080e8e57, 0x0f800323, 0x402f4422, 0x442f40b8,
    0x2c3f0f22, 0x3f2caa01, 0x70a07080, 0x7004a070, 0x40fd0e12, 0x0e12120e, 0x24eb8202, 0x0e1280fe, 0x220782fe, 0x82010e12, 0x47012013, 0x12210532,
    0x8911840e, 0x80f92625, 0x0e120007, 0x202182f9, 0x0df84307, 0x5d36442f, 0x40403257, 0x365d5732, 0x014d4d37, 0x226083a3, 0x43e0fe70, 0x012108de,
    0x890a880e, 0x22148a09, 0x83606e01, 0x0bea4389, 0x451b4741, 0x352a0555, 0x33023e34, 0x32373216, 0x5345021e, 0x45252017, 0x05200e53, 0x2b200f82,
    0x2405ea6a, 0x32013b36, 0x0f734516, 0x48421320, 0x16322916, 0x2c3f8003, 0x3f2c56fe, 0x410a4d41, 0x80253947, 0x0d1300f9, 0x05724206, 0x240a3e45,
    0x4d4d3744, 0x08494137, 0xa0d60127, 0x70a07070, 0x184918fd, 0x41f22009, 0x13891244, 0x04b2fc27, 0x0da0fb60, 0x0e324513, 0x00023b08, 0x0600ff1d,
    0x000006e2, 0x0041001a, 0x02100100, 0x11022223, 0x32331210, 0x23042e37, 0x36270722, 0x17163233, 0x16330136, 0x2223030e, 0x0627022e, 0x26242223,
    0x12343502, 0x12792436, 0x02810805, 0x33011e07, 0xe7043632, 0xd0dee1d2, 0x394aded0, 0x35362216, 0x212e2949, 0x84ab6931, 0x014343a7, 0x0a037586,
    0x5c8d492b, 0x425c7747, 0x966c6121, 0x87dde3fe, 0x1d01de87, 0xc7eb7995, 0x8aa15699, 0x3d3a5d2f, 0x01ed0242, 0xfe39013e, 0xfec3fec6, 0x11c9fec4,
    0x2b463c2b, 0x5b61101d, 0xfe95656c, 0x6e501b85, 0x4a26415b, 0x741b3752, 0xa92901c9, 0xca2b01aa, 0xbd8c4874, 0xfebe89f9, 0x49466bc5, 0x070f444b,
    0x00096530, 0x20009b05, 0x99002e00, 0x0000bf00, 0xab821405, 0x27262722, 0x1321ce82, 0x20a2823e, 0x06a85916, 0x16171026, 0x25041e17, 0x28072542,
    0x32213336, 0x07140316, 0x0726610e, 0x07554f18, 0x82141521, 0x22428231, 0x61363435, 0x15250b10, 0x15030e14, 0x21438214, 0x1f821716, 0x27222324,
    0x3361012e, 0x27262606, 0x33343526, 0x255c8232, 0x051e1417, 0x36823233, 0x0f842620, 0x10050122, 0x23093f60, 0x34113637, 0x27222982, 0x5882052e,
    0x37082d82, 0x16171216, 0x1520c501, 0x633f0c01, 0x7027d5e1, 0x3f201326, 0x7b773162, 0x19025632, 0x0509140e, 0xfb1d233f, 0x23261ac7, 0x1a39041d,
    0x1943d726, 0x0b102759, 0x2e261007, 0x84081182, 0x2b0f0311, 0x0a034217, 0x05163a0d, 0x26200304, 0x2a263536, 0x0110321d, 0x1b061201, 0x47319877,
    0x1d193146, 0x3229131b, 0x273c293c, 0x0608101c, 0x0c0a0803, 0x1c170a11, 0x421b0a28, 0xd3023d48, 0x4e3a138a, 0x1e102054, 0xb7094f3a, 0x693a3429,
    0x130b1602, 0x1320080b, 0x60627e46, 0x1565020c, 0x7d0f0321, 0x88011c01, 0x11015501, 0x131b6933, 0x52663f1b, 0xe7fefac7, 0x035855d2, 0x1619101a,
    0x26271d7c, 0x0803821a, 0x864902aa, 0x14512663, 0x09060c0a, 0x2e55322a, 0x052a364c, 0x160d2f0c, 0x3a0f4c1a, 0x1915190f, 0x04040139, 0x251e3002,
    0x3e2e2e3e, 0x2b3e6225, 0x02050514, 0x2b0b1003, 0x79377ac1, 0x34776c6d, 0x10302935, 0x1d140c09, 0x4a333313, 0x21013040, 0x16152111, 0x19171c0b,
    0x4c461454, 0xeefe87a0, 0x5d5020e5, 0x0f101f3d, 0xe60b5347, 0xd0832d01, 0x036d776b, 0x11170c15, 0x21130914, 0xe4fe83a9, 0x00002aac, 0xff000002,
    0x06000700, 0x00180000, 0x25000028, 0x07263613, 0x16010e01, 0x3601011f, 0x01071617, 0x32070139, 0x1617013f, 0x080fd870, 0x93a50420, 0xfc202709,
    0x10151da0, 0x0102dd18, 0x0b070b15, 0x171061fe, 0x40e06c16, 0xf08e6c02, 0x2570b4fe, 0x02e53b0e, 0x0c262cb5, 0x1c0bb3fe, 0x01450719, 0x05080e43,
    0xe489fe0a, 0x24a56816, 0x2a8e9b02, 0xf08e8e22, 0x21053b4b, 0x97830400, 0x1f000d2a, 0x33002f00, 0x3b003700, 0x574c9f82, 0x11372906, 0x011e1133,
    0x27263417, 0x38064478, 0x1415010e, 0x37362016, 0x00200014, 0x11373435, 0x16203634, 0x13161115, 0x05797315, 0x022c0783, 0x70a07080, 0x3a803a46,
    0x3c448046, 0x3c260a82, 0x0a01bb44, 0xe46780bb, 0x84802005, 0xc080210b, 0x50320084, 0x3c507070, 0x8b031564, 0x641575fc, 0x2d864d3c, 0x12830003,
    0x2d00fd32, 0xbb854d86, 0xfeb985bb, 0xb90701f9, 0xc70283b6, 0xfd280d83, 0x8a018339, 0x00018080, 0xbb400385, 0x8b022285, 0xb8bb40fd, 0xfe8b0122,
    0x3522bbd4, 0x33421533, 0x8b8b2160, 0x42333142, 0x09240b33, 0x2b001b00, 0x2106f142, 0x474f2500, 0x32eb4208, 0x70a07022, 0x2323e942, 0x4f71714f,
    0x0830e342, 0x0000102e, 0x800700ff, 0x26000006, 0x36002e00, 0x46003e00, 0x56004e00, 0x66005e00, 0x76006e00, 0x86007e00, 0x96008e00, 0x00009e00,
    0x07141601, 0x3c061e68, 0x012e013f, 0x22232637, 0x21111506, 0x023e3411, 0x17163233, 0x37171636, 0x02173236, 0x05256c32, 0x26220424, 0x0b823634,
    0x06200383, 0x04200b82, 0x15841787, 0x24220622, 0x2f970f87, 0x37873f96, 0x37860620, 0x20080787, 0x0a0a9905, 0x1a0a8efd, 0x0a0a520a, 0x3813482c,
    0x966a664a, 0x8a5100ff, 0xbe6a68bd, 0x52ce5e47, 0x271a822c, 0x26263421, 0x5a012634, 0xc86b0684, 0x85fd2005, 0x00012106, 0x2005116c, 0x871a8400,
    0x21288b14, 0x358adafe, 0x3586fe20, 0x26203484, 0x05852685, 0x82070521, 0x82878267, 0x0a1a3a86, 0x63e85b2c, 0xfb6a9647, 0x68000500, 0x52518abd,
    0x411d274a, 0xfe0a0a2c, 0x203784a7, 0x2005905a, 0x6c628434, 0x1d9105df, 0x2f90da20, 0x2621cd83, 0x21298b34, 0x07461100, 0x1d260808, 0x2d002500,
    0x3d003500, 0x4d004500, 0x85007d00, 0x95008d00, 0xa5009d00, 0xb500ad00, 0xc500bd00, 0x15010000, 0xf2490714, 0x23062408, 0x88272221, 0x3d26230d,
    0xed6d0001, 0x8626200e, 0x05df410f, 0x87323621, 0x8207870f, 0x8243834d, 0x36342839, 0x3411013b, 0x42323336, 0x1f280514, 0x01071601, 0x26012f06,
    0x210b3642, 0x5f871632, 0x5f97478f, 0x0f87178f, 0x8080063b, 0x0e400e12, 0xfd413f12, 0x133f4100, 0x130d400d, 0x12400280, 0x1c12121c, 0x20058452,
    0x2005842e, 0x850b8a92, 0x52042111, 0x3105ad4b, 0x96600e12, 0x2e4c6c6a, 0x0b162968, 0x0b0b2a0b, 0x0684c6fe, 0x0924162d, 0x3533251c, 0x0ee0054b,
    0x9080fc12, 0x9cd2203d, 0x376d8511, 0xa9c0c001, 0x120ec275, 0x16760e12, 0x17116e16, 0x75ba1117, 0xae01c0a9, 0x12219b83, 0x84058a2e, 0x20118c4b,
    0x081e4cfd, 0x6a800227, 0x0e134e96, 0x2a9c8d20, 0x2332742e, 0x80fd354b, 0x90c00112, 0x9c52204d, 0x086b8511, 0x0000002b, 0xff010004, 0x05000600,
    0x000d00fe, 0x00480040, 0x01000071, 0x07060714, 0x26272006, 0x34352627, 0x00140120, 0x37260607, 0x2c018536, 0x02343512, 0x030e0724, 0x17121617,
    0x32018216, 0x1617011e, 0x012e2706, 0x12363702, 0x36372436, 0x6f121604, 0x012107da, 0x20458214, 0x2b458326, 0x35013e37, 0x07012e34, 0x0607010e,
    0x5d823482, 0x82010e21, 0x3e372133, 0xbb083582, 0xe203011e, 0x16181f11, 0x1816fcfe, 0xc001111f, 0xf4fe1e02, 0x010e08d8, 0x02040307, 0xc19f0801,
    0xb5c8feb6, 0x5fa1e27c, 0x9fc40101, 0x03030207, 0x01020801, 0xe294080f, 0x76070879, 0x8f0301bf, 0xdb2f01a4, 0x83e2fd83, 0xba8383ba, 0x5d6ba301,
    0x06021008, 0x3a0a0717, 0x71c67542, 0x0a0dc085, 0x070a4143, 0x10020518, 0x026b5f08, 0x82de8403, 0x0191f890, 0xd76f5658, 0x625a5a62, 0xa8576ed7,
    0xfef00001, 0x0c03567c, 0x20123009, 0x5103090f, 0xb4b83201, 0x0aa82d01, 0xe7ad6c07, 0xcffeb87d, 0x1509034f, 0x0c2f0918, 0x3a040c09, 0xa73101df,
    0xc105018f, 0x710a097a, 0x25dbfed0, 0x3e087383, 0x7a00ff83, 0x080647d5, 0x0a28340a, 0x5292360a, 0x0c61ba6f, 0x5c85c40f, 0x0a0a3ca8, 0x08093429,
    0x7dda4a06, 0x0689e283, 0x00f18607, 0xff000002, 0x05000780, 0x00030080, 0x25000013, 0x63211121, 0x01260f14, 0xfb000500, 0xee590600, 0x425e2a06,
    0x5e42c005, 0x01000380, 0x0bf74d60, 0x47850120, 0x00800123, 0x4d45820f, 0x2a5a0ebf, 0x203b8507, 0x213f82e0, 0x0483425e, 0x51000021, 0x0820057f,
    0x09825d82, 0x26000c30, 0x01290000, 0x11022911, 0x32331121, 0x89851516, 0x270c1a4f, 0x33363411, 0x01163221, 0xfd222e82, 0xbe820400, 0x6000fd25,
    0x82035e42, 0xa0fd239c, 0x0850425e, 0x60022405, 0x8203425e, 0x0002245f, 0x82ff0003, 0x00022119, 0x4f541783, 0x20178305, 0x20318201, 0x897b825e,
    0x002322fb, 0x24b58233, 0x2f343637, 0x24048401, 0x010f2226, 0x24048327, 0x011f1406, 0x24048307, 0x013f3216, 0xa5df1817, 0x97042b11, 0xe90a0a92,
    0x920a0ae9, 0x07831a0a, 0x08821a20, 0x02210f8c, 0x05c45973, 0xd720fa85, 0x36862697, 0x41130421, 0x03200b53, 0x20089b41, 0x06f75123, 0x28175718,
    0x4106444d, 0x0421062d, 0x217783e9, 0xa382a9a9, 0x0782ae82, 0x0f8aae84, 0x410dfc21, 0x012111e2, 0x882b95a9, 0xcdfe233b, 0x03420004, 0x09eb4b0c,
    0x13000328, 0x01090000, 0xd64b0121, 0x012e2810, 0xfe72fd32, 0x4b6005ce, 0x012712c3, 0xfd340266, 0x4bd001cc, 0x072a13af, 0x00ff0000, 0x00060207,
    0x5b820700, 0x00232408, 0x0043002e, 0x00d400c4, 0x0e260100, 0x3e161701, 0x22060501, 0x37342627, 0x16173236, 0x06071714, 0x18012f22, 0x22070f57,
    0x87271416, 0x1416331b, 0x27010e25, 0x023e012e, 0x071e1716, 0x3613010e, 0x0e82022e, 0x013e0732, 0x2736011f, 0x012f013e, 0x3637013e, 0x06262726,
    0x1e2a1c82, 0x012e1701, 0x26372627, 0x20822227, 0x34013f22, 0x06242982, 0x06373607, 0x1f831882, 0x83010f21, 0x06172679, 0x16140607, 0x2c378237,
    0x3e07022e, 0x37163304, 0x27343536, 0x823f8216, 0x16052b1f, 0x0e272617, 0x16171604, 0x22831236, 0x37220882, 0xe37d1236, 0x0b053b0e, 0x0b0c280f,
    0xfe10340e, 0x0717085a, 0x17070808, 0x239e0708, 0x260d230c, 0x06850c0c, 0x12837920, 0x0807b808, 0x8b011016, 0x26369322, 0x4d4a042e, 0x16022640,
    0x0e061307, 0x07030503, 0x201703c3, 0x58280622, 0x0c2a1345, 0x0624020c, 0x2b030301, 0x6a0a0638, 0x1c6c3c54, 0x3324071e, 0x0e562d1f, 0x0d103c1c,
    0x2e132732, 0x0a0d0d0d, 0x020d312d, 0x25010702, 0x2316191e, 0x5a212265, 0x0a0110b6, 0x2b150f0f, 0x1348292a, 0x11200902, 0x1f183817, 0x080e0d15,
    0x056a2807, 0x0d0d1c01, 0x1f161e04, 0x09020f13, 0x19160223, 0x0d0e132a, 0xb7c62d13, 0x1b76561f, 0x3f686b2f, 0xf08ef627, 0x94feb3fe, 0x8ef0b3fe,
    0x4d01f08e, 0x4d016c01, 0x112404f0, 0x11122811, 0x08d42405, 0x83160808, 0x52162fd2, 0x260d0d23, 0x230d220d, 0x0c270c0c, 0x17837623, 0x08084808,
    0x405a1610, 0x4d1c262b, 0x1e145662, 0x06150224, 0x0f150a15, 0xfe181416, 0x0e1d1412, 0x37470a14, 0x010b0d10, 0x142d2d01, 0x180a0a29, 0x85543252,
    0x3133070a, 0x364a6433, 0x3840040f, 0x0b15726c, 0x011a1813, 0x821c3201, 0x1d4f0834, 0x5f1c0304, 0x160e358b, 0x2e2f6d10, 0x1047b722, 0x19120c0b,
    0x1311163a, 0x06021e3d, 0x0f050109, 0x07010705, 0x66352529, 0x1d746730, 0x0706062a, 0x3b3f2932, 0x361e4243, 0x361e181a, 0x0b202c26, 0x0901b219,
    0x387f3460, 0x0353555d, 0x42790102, 0x00211382, 0x08936601, 0x00004735, 0x36161101, 0x013e013f, 0x0333013f, 0x2e272313, 0x54262701, 0x3e2106cd,
    0x2f138204, 0x2e070206, 0x21232701, 0x3e373505, 0x12133701, 0x2f2a2082, 0x21053501, 0x010e3732, 0x2f83010f, 0x21239008, 0x06020622, 0x2525b167,
    0x21112d44, 0x67070e67, 0x363c0f1d, 0x57f7fe57, 0x2365015a, 0x322f3d31, 0x595d122a, 0x92053306, 0xfd2c2deb, 0x7f88fe8c, 0x08013143, 0x2f020b03,
    0x78017f44, 0xeb8bbe02, 0x05041006, 0x561f205d, 0x1cdcfd46, 0xfd49050f, 0x03050171, 0x482d0203, 0xfebefe8e, 0x32447fc1, 0xd4fd0801, 0x0b044b4e,
    0x2a3e2719, 0x52fe25d8, 0x0106053d, 0x0d19660c, 0x83023730, 0x3df39201, 0x66180d2e, 0xfd441b0c, 0x797c5c5d, 0x59001175, 0x2108050f, 0x80050006,
    0x2c001100, 0x3e003000, 0x65005300, 0x00007500, 0x16141501, 0x1123040e, 0x1c031e32, 0x0c830501, 0x2223022a, 0x3c352627, 0x33023e03, 0x33231485,
    0x82012311, 0x26073e03, 0x33112327, 0x13331311, 0x2e273405, 0x22232205, 0x3211012b, 0x27361633, 0x34350526, 0x2136822e, 0x20823507, 0xaf723720,
    0x9a540814, 0x05020101, 0x09090e08, 0x0205080e, 0x01013c01, 0x09080b04, 0x04030405, 0x08060506, 0xfb010305, 0x017a7ade, 0x1c9f6ab2, 0x6b9e0c14,
    0x012b4c2d, 0x100305a9, 0x29152012, 0x04081511, 0xa924145b, 0x01010338, 0x220f043d, 0x751f2e1d, 0x2f1e076e, 0x5eb42032, 0x080a985c, 0xb6e30232,
    0x10081604, 0x01030807, 0x03080235, 0x63160510, 0x08170179, 0x0a09060f, 0x070a029b, 0x0308060b, 0x0b060603, 0x01ee0e05, 0x0128fed8, 0x4994ddd8,
    0x382d0682, 0x3f01c8fe, 0x1017430e, 0x050c1019, 0x31108203, 0x9f3e9b33, 0x23201d85, 0xfe9a220f, 0x3d241e28, 0xb4451203, 0x0000350b, 0x30000500,
    0x4b0802ff, 0x0c00f805, 0x1a001500, 0x8f005300, 0x3a081482, 0x042e2726, 0x16272627, 0x2e170100, 0x06012f01, 0x06131607, 0x01373607, 0x24260234,
    0x07042223, 0x033e0706, 0x031e011f, 0x020e2607, 0x17021e07, 0x3f023e16, 0x16013e01, 0x82071617, 0x1e2721ff, 0x16231c82, 0x82123637, 0x02062134,
    0x062d2c82, 0x20230627, 0x26220300, 0x021e0623, 0x2626821f, 0x012f032e, 0x8227062e, 0x5ada1839, 0x37730908, 0x17042436, 0x77041216, 0x2e0d0506,
    0x1f756b7e, 0x01429e11, 0xa85dfe52, 0x04032019, 0x7a052554, 0x1e2c222b, 0xd37ca005, 0x939fdefe, 0x1e6af4fe, 0x97a63c0f, 0x21282987, 0x03040928,
    0x7aa3cb7e, 0x380f0446, 0xb4f97b22, 0x16252591, 0x0e041a23, 0xfdfed035, 0x8a29b687, 0x27277d88, 0xeec3788f, 0x461a0e4a, 0x2230cfdf, 0x25245b48,
    0x45fee5fe, 0x0206014a, 0x25231106, 0x2e080e0d, 0x1d326b47, 0x39050203, 0x33314228, 0x3f130822, 0x0b0240a3, 0x1c872953, 0x20220f35, 0x0123019e,
    0xe2dc9639, 0x080301c5, 0xab6d641e, 0xd5220357, 0x3b02d6fe, 0x36b74c1c, 0x418e5235, 0x54403002, 0x9efe162e, 0xd42401a1, 0x3a60697d, 0x15413366,
    0x01030406, 0x0a25251d, 0x4d42150b, 0xf371243c, 0x4229063a, 0x10181944, 0x61191309, 0x14256118, 0x5da16004, 0x170c0b41, 0x7c016326, 0x4d870901,
    0x73ebfed0, 0x0a1a0b21, 0x015a0103, 0x7d32010d, 0x1a1a5b69, 0x8926460c, 0x2a2a838f, 0x1a0f1502, 0x0c1b1b18, 0x083c1f0a, 0xca8d9520, 0x1c6373a3,
    0x3c4a0f22, 0xfe734e26, 0x00050046, 0x060cff25, 0x00f405d8, 0x00300017, 0x00570040, 0x0100006d, 0x2e272636, 0x06070601, 0x021e1716, 0x36071e17,
    0x04020e01, 0x02012e24, 0x37033e37, 0x0c011a06, 0x36372401, 0x18021407, 0x230b349b, 0x2c012e05, 0x06261882, 0x02261702, 0x3683043e, 0x03014e08,
    0x22270036, 0x1e372627, 0x07030e04, 0x3d05033e, 0x3a56471d, 0x0c126587, 0x1f17230f, 0x3f241b3a, 0x1418252b, 0x010a0b0d, 0xecc13471, 0xfafef2fe,
    0x0567b4f0, 0x260a0f01, 0xf2683304, 0x60015401, 0x14745a01, 0x8851f302, 0x88bcd0bc, 0x08068551, 0x41700171, 0xfeedfee7, 0xfedbfecb, 0x1e50b6fe,
    0x8e4c0531, 0xf6efe1bd, 0x214bcee2, 0xfe0c3c3a, 0x0208f8d7, 0xd27d1a02, 0x17156088, 0x88e19164, 0x62a1bb6c, 0xab2cf002, 0x141d2739, 0x050a171b,
    0x0a0f0403, 0x2825250d, 0x0d182124, 0x7fcbfd01, 0x331861ba, 0x1701c083, 0x295729a4, 0xfed00d78, 0x9afefe86, 0x1ba4a10c, 0x1f02040d, 0x518abed0,
    0x85be8a51, 0x93063f06, 0x510863d0, 0xa4fef6b1, 0x2d01a1c7, 0x6597d2f4, 0xa4551729, 0xfe8e3273, 0x5801f481, 0x59820544, 0xbd945c2d, 0x92bccfd1,
    0x641e0259, 0x8200cf92, 0x0b260800, 0x80ff0000, 0x00060006, 0x1f000f00, 0x3f002f00, 0x5f004f00, 0x7f006f00, 0x9f008f00, 0x0000af00, 0x22231513,
    0x0383013d, 0x013b3425, 0xbf333435, 0x0b61180f, 0x2133270b, 0x15011632, 0x03842b14, 0x32333527, 0x3233011d, 0x240fbe35, 0x301070c0, 0x20028210,
    0x2f079e70, 0x2838b004, 0x3828c0fc, 0x40032838, 0x00013828, 0x528432a2, 0x80000126, 0x20101010, 0x09a70382, 0x82faa021, 0x28382260, 0x216c8305,
    0x398308fb, 0xf0204182, 0x0020079e, 0x012e0082, 0x00ff2f00, 0x00065106, 0x00009000, 0x877b0701, 0x012f2905, 0x26061617, 0x11250327, 0x0e360f82,
    0x012f2601, 0x22061415, 0x07013d26, 0x012e010e, 0x11013f36, 0x16820305, 0x67013f21, 0x272c07ea, 0x013e012e, 0x012d0517, 0x22230605, 0x11842184,
    0x27011f29, 0x17163626, 0x84110513, 0x1f16210e, 0x32059568, 0x3e37011d, 0x06011e01, 0x2511010f, 0x16013e13, 0x8237010f, 0x82162025, 0x276e840f,
    0x25272223, 0x3625010d, 0x4a082182, 0xbaa71e06, 0x0e0d0d17, 0x37ba1732, 0x0d47320d, 0xd0f1fe66, 0x21180210, 0x26701029, 0x10702634, 0x02182129,
    0xf1fed010, 0x32470d66, 0x17ba370d, 0x0d0d0e32, 0x1da7ba17, 0x1d2a091a, 0x0f013601, 0xcafef1fe, 0x221b0904, 0x831b1a04, 0x341a2248, 0x21478616,
    0x47920f01, 0x8e0f0121, 0x1a1b3947, 0x091b2204, 0xfecafe04, 0x010f01f1, 0x092a1d36, 0x21a3011a, 0x17330d6b, 0x2b089482, 0x3326a06a, 0x2c01250a,
    0xeec7fe9c, 0x131f2a12, 0xd6801208, 0x1a26261a, 0x081280d6, 0x122a1f13, 0x9c3901ee, 0x0a25d4fe, 0x6aa02633, 0x17329582, 0x216b0d33, 0x212f2e06,
    0x9d9d3e06, 0x2c24013e, 0x4983052a, 0x0e0e2e22, 0xfe244885, 0x39019cd4, 0xfe244895, 0x2c019cc7, 0x0524488d, 0x01242c2a, 0x06244883, 0x002e2f21,
    0x0806d74c, 0x0007003a, 0x12000006, 0x00002600, 0x022e3601, 0x020e2627, 0x021e0607, 0x12241617, 0x12160109, 0x04020607, 0x26010507, 0x12363702,
    0x24363724, 0x5007c105, 0x7475d092, 0x0769a5db, 0xd1350982, 0x14019b75, 0xfe4701ac, 0x0a7978a3, 0xd4feb60b, 0x0119fcb6, 0x310b845b, 0xa7b62d01,
    0x5f029a02, 0x65a1d976, 0x8f4e0707, 0x098475cf, 0x0088093e, 0xfe3d04ff, 0xcafe75a4, 0xc8feb7a6, 0x018419c7, 0x3701745b, 0x3801b8a6, 0x581619c7,
    0x07588c83, 0x000a2206, 0x2097820e, 0x36998216, 0x01000036, 0x010b2313, 0x37271323, 0x05010717, 0x17012d03, 0x82252707, 0x10042103, 0x2106715f,
    0x91181210, 0x062507a0, 0x26242004, 0x06136002, 0xb4033208, 0xabaf33a3, 0x154eb331, 0x45fe15f0, 0xfe823001, 0xf0da01d0, 0x7f01ef67, 0x02be52bf,
    0xfed37c3d, 0xfec2fede, 0x7c7cd3de, 0x012201d3, 0xd322013e, 0x136f4cec, 0xb7fefc2e, 0xa2fe5e01, 0x31217601, 0x69023266, 0x82294582, 0x66ef6777,
    0x51be515a, 0x8235845e, 0x2149893f, 0x154a7702, 0x0c200812, 0x01ff2600, 0xff055a07, 0x62005800, 0x77006c00, 0xab008100, 0xc200b700, 0xd800cd00,
    0xee00e400, 0x2e39e382, 0x3e262703, 0x27262701, 0x0e010f26, 0x012e2203, 0x27062e27, 0x0e070626, 0x85128203, 0x06152808, 0x013e3716, 0x82123637,
    0x16172105, 0x2a059550, 0x023e3736, 0x32173637, 0x46020607, 0x36250575, 0x07061604, 0x25338206, 0x1601013e, 0x0884010e, 0x0e001622, 0x2205b750,
    0x83161701, 0x012e2714, 0x16363736, 0x32821613, 0x22832720, 0x27253085, 0x3736022e, 0x82d2822e, 0x17162952, 0x07031e36, 0x0106021e, 0x30854d86,
    0x0a834f84, 0x46851684, 0x66850a84, 0x27202c8b, 0x4d833883, 0x05166c08, 0x342f0436, 0x4c05032d, 0x670e054a, 0x04031e2d, 0x07030702, 0x03030705,
    0x080b060c, 0x1e060b0b, 0x10011b24, 0x0b0c1509, 0x6a291e36, 0x25321017, 0x4651162b, 0x0712291e, 0x1f060590, 0x02061b0e, 0x33060162, 0x53041446,
    0x15140650, 0x7f02041d, 0x31320c07, 0x324b4411, 0x100641fc, 0x03190e0f, 0x021c1003, 0x22070c57, 0x820b0c29, 0x15fd2804, 0x1a1a3f24, 0x8212120c,
    0x053c0805, 0x380c1304, 0x1b0c2641, 0x4584411c, 0x6d5a6c35, 0x3d9e8114, 0xf467010c, 0x53033247, 0x3e262a77, 0x6a350424, 0x9f862044, 0x884847b1,
    0x062f5879, 0x20154634, 0x090e72fb, 0x0d311314, 0x28080584, 0x221204ac, 0x1303041c, 0x041c1110, 0x141504a5, 0x15082213, 0xfd211414, 0x1c0f106c,
    0x10103d1b, 0x023e360f, 0x0f1004fa, 0x8286830f, 0xbc65088c, 0x1616090f, 0x2c0a1e36, 0x182e0135, 0x1a180114, 0x27b1b92f, 0x11010265, 0x03010202,
    0x03040301, 0x0a050d02, 0x01030605, 0x01171005, 0x020d070f, 0x120d1b02, 0x8d1c2a2e, 0x4501907c, 0x1a020464, 0x75010d21, 0x070e0b08, 0xf312260f,
    0x1725260b, 0x9fa80826, 0x26011d09, 0x1cf9fe10, 0x09186435, 0xa81f030d, 0x286c851e, 0xdafe061a, 0x08182911, 0x08048311, 0x36360347, 0x4012130c,
    0x120c1b1a, 0x1c01fd13, 0x380c2643, 0x0c131442, 0xfe714002, 0x033f4cf9, 0x37055e50, 0x2d470109, 0x0e5b4968, 0x3aa18f71, 0x5372883c, 0x397e5509,
    0x07153717, 0x49875f41, 0x67605210, 0x31147002, 0x84f5820e, 0x23a08205, 0x1113081d, 0x0431f682, 0x143bfc13, 0x15040422, 0x04052228, 0x1b6a0317,
    0x08f6823f, 0x3e1c1b23, 0x54fd1022, 0x0304190f, 0x1a0f0e11, 0xe2100303, 0x0f103616, 0x20362c0a, 0x0000000a, 0x00260118, 0x83078201, 0x002f2202,
    0x240b8660, 0x000b0001, 0x240b86a8, 0x00070002, 0x240b86c4, 0x00110003, 0x240b86f0, 0x010b0004, 0x240b861a, 0x01120005, 0x200b864c, 0x20178206,
    0x240b8677, 0x02510007, 0x240b8627, 0x020c0008, 0x240b8693, 0x020a0009, 0x240b86b6, 0x0215000b, 0x2a0b86ed, 0x031e000e, 0x00030041, 0x82090401,
    0x825e2090, 0x240b8503, 0x00160001, 0x24178690, 0x000e0002, 0x240b86b4, 0x00220003, 0x240b86cc, 0x01160004, 0x220b8602, 0x82240005, 0x203b85d7,
    0x20178206, 0x2417865f, 0x01a20007, 0x240b8683, 0x02180008, 0x240b8679, 0x02140009, 0x240b86a0, 0x022a000b, 0x080b86c1, 0x3c000e20, 0x43000303,
    0x70006f00, 0x72007900, 0x67006900, 0x74006800, 0x44002000, 0x76006100, 0x09826500, 0x09824720, 0x64006e22, 0x202a1f82, 0x30003200, 0x36003100,
    0x17822e00, 0x6c004122, 0x20200182, 0x7320358a, 0x72201582, 0x73203382, 0x72200382, 0x64203d84, 0x003f2982, 0x79706f43, 0x68676972, 0x61442074,
    0x47206576, 0x79646e61, 0x31303220, 0x41202e36, 0x84206c6c, 0x20732d1a, 0x65736572, 0x64657672, 0x4600002e, 0x6e208f82, 0x41228582, 0x4d847700,
    0x6d006f22, 0x002e0782, 0x746e6f46, 0x73657741, 0x00656d6f, 0x11825200, 0x75006722, 0x61208182, 0x00278182, 0x75676552, 0x8372616c, 0x004f303b,
    0x0054004e, 0x0041004c, 0x003a0042, 0x8254004f, 0x0045244f, 0x82500058, 0x8252200b, 0x4600310d, 0x4c544e4f, 0x4f3a4241, 0x58454654, 0x54524f50,
    0x562071a5, 0x7322d584, 0x9d846900, 0x34002022, 0x3720db82, 0x30200382, 0x1741f582, 0x56002d07, 0x69737265, 0x34206e6f, 0x302e372e, 0x5ca5e484,
    0xc8825020, 0x61006524, 0x64827300, 0xd0822020, 0x66006522, 0x72200982, 0x74205a82, 0x20246e82, 0x68007400, 0xaa411984, 0x20338313, 0x87218263,
    0x82662098, 0x85398531, 0x200f8333, 0x831f826e, 0x82722045, 0x82642063, 0x826d2049, 0x00722207, 0x205f826b, 0x20198261, 0x24718274, 0x00620069,
    0x20458a75, 0x2445826e, 0x00690074, 0x202d8263, 0x34e68273, 0x656c5000, 0x20657361, 0x65666572, 0x6f742072, 0x65687420, 0x09da4120, 0x63657323,
    0x21f88374, 0x1c826f66, 0x66351982, 0x20746e6f, 0x64617274, 0x72616d65, 0x7461206b, 0x62697274, 0x26228475, 0x69746f6e, 0x41736563, 0x722006e8,
    0xea419984, 0x74722210, 0x08eb4120, 0x20138b42, 0x094b4200, 0x68000022, 0x7024c384, 0x2f003a00, 0xef870182, 0x3e426120, 0x822e200c, 0x826f20cb,
    0x7474252a, 0x2f2f3a70, 0x61209e83, 0x21054b42, 0x1683692e, 0x2f2241a8, 0x15416c00, 0x006e2406, 0x82650073, 0x6800216f, 0x2f215393, 0x24e4826c,
    0x2f65736e, 0x05e34800, 0x02980582, 0x82c30221, 0x01a00d1a, 0x03000200, 0x8b008e00, 0x8d008a00, 0x91009000, 0x92008c00, 0x02018f00, 0x04010301,
    0x06010501, 0x08010701, 0x0a010901, 0x0c010b01, 0x0e010d01, 0x10010f01, 0x12011101, 0x14011301, 0x16011501, 0x18011701, 0x1a011901, 0x1c011b01,
    0x1e011d01, 0x20011f01, 0x22012101, 0x24012301, 0x26012501, 0x28012701, 0x2a012901, 0x2c012b01, 0x2e012d01, 0x30012f01, 0x32013101, 0x34013301,
    0x36013501, 0x38013701, 0x3a013901, 0x3c013b01, 0x3e013d01, 0x40013f01, 0x42014101, 0x44014301, 0x46014501, 0x48014701, 0x4a014901, 0x4c014b01,
    0x4e014d01, 0x50014f01, 0x52015101, 0x54015301, 0x56015501, 0x58015701, 0x5a015901, 0x5c015b01, 0x5e015d01, 0x60015f01, 0x62016101, 0xef000e00,
    0x63010d00, 0x65016401, 0x67016601, 0x69016801, 0x6b016a01, 0x6d016c01, 0x6f016e01, 0x71017001, 0x73017201, 0x75017401, 0x77017601, 0x79017801,
    0x7b017a01, 0x7d017c01, 0x7f017e01, 0x81018001, 0x83018201, 0x85018401, 0x87018601, 0x89018801, 0x8b018a01, 0x8d018c01, 0x8f018e01, 0x91019001,
    0x93019201, 0x95019401, 0x97019601, 0x99019801, 0x9b019a01, 0x9d019c01, 0x9f019e01, 0xa101a001, 0xa301a201, 0xa501a401, 0xa701a601, 0xa901a801,
    0xab01aa01, 0xad01ac01, 0xaf01ae01, 0xb101b001, 0xb301b201, 0xb501b401, 0xb701b601, 0xb901b801, 0xbb01ba01, 0xbd01bc01, 0xbf01be01, 0xc101c001,
    0xc301c201, 0xc501c401, 0xc701c601, 0xc901c801, 0xcb01ca01, 0xcd01cc01, 0xcf01ce01, 0xd101d001, 0xd301d201, 0xd501d401, 0xd701d601, 0xd901d801,
    0xdb01da01, 0xdd01dc01, 0xdf01de01, 0xe101e001, 0xe301e201, 0xe501e401, 0xe701e601, 0xe901e801, 0xeb01ea01, 0xed01ec01, 0xef01ee01, 0xf101f001,
    0xf301f201, 0xf501f401, 0xf701f601, 0xf901f801, 0xfb01fa01, 0xfd01fc01, 0xff01fe01, 0x01020002, 0x03020202, 0x05020402, 0x07020602, 0x22000802,
    0x0a020902, 0x0c020b02, 0x0e020d02, 0x10020f02, 0x12021102, 0x14021302, 0x16021502, 0x18021702, 0x1a021902, 0x1c021b02, 0x1e021d02, 0x20021f02,
    0x22022102, 0x24022302, 0x26022502, 0x28022702, 0x2a022902, 0x2c022b02, 0x2e022d02, 0x30022f02, 0x32023102, 0x34023302, 0x36023502, 0x38023702,
    0x3a023902, 0x3c023b02, 0x3e023d02, 0x40023f02, 0x42024102, 0x44024302, 0x46024502, 0x48024702, 0x4a024902, 0x4c024b02, 0x4e024d02, 0x50024f02,
    0x52025102, 0xd2005302, 0x55025402, 0x57025602, 0x59025802, 0x5b025a02, 0x5d025c02, 0x5f025e02, 0x61026002, 0x63026202, 0x65026402, 0x67026602,
    0x69026802, 0x6b026a02, 0x6d026c02, 0x6f026e02, 0x71027002, 0x73027202, 0x75027402, 0x77027602, 0x79027802, 0x7b027a02, 0x7d027c02, 0x7f027e02,
    0x81028002, 0x83028202, 0x85028402, 0x87028602, 0x89028802, 0x8b028a02, 0x8d028c02, 0x8f028e02, 0x91029002, 0x93029202, 0x95029402, 0x97029602,
    0x99029802, 0x9b029a02, 0x9d029c02, 0x9f029e02, 0xa102a002, 0xa302a202, 0xa502a402, 0xa702a602, 0xa902a802, 0xab02aa02, 0xad02ac02, 0xaf02ae02,
    0xb102b002, 0xb302b202, 0xb502b402, 0xb702b602, 0xb902b802, 0xbb02ba02, 0xbd02bc02, 0xbf02be02, 0xc102c002, 0xc302c202, 0xc502c402, 0xc702c602,
    0xc902c802, 0xcb02ca02, 0xcd02cc02, 0xcf02ce02, 0xd102d002, 0xd302d202, 0xd502d402, 0xd702d602, 0xd902d802, 0xdb02da02, 0xdd02dc02, 0xdf02de02,
    0xe102e002, 0xe302e202, 0xe502e402, 0xe702e602, 0xe902e802, 0xeb02ea02, 0xed02ec02, 0xef02ee02, 0xf102f002, 0xf302f202, 0xf502f402, 0xf702f602,
    0xf902f802, 0xfb02fa02, 0xfd02fc02, 0xff02fe02, 0x01030003, 0x03030203, 0x05030403, 0x07030603, 0x09030803, 0x0b030a03, 0x0d030c03, 0x0f030e03,
    0x11031003, 0x13031203, 0x15031403, 0x17031603, 0x19031803, 0x1b031a03, 0x1d031c03, 0x1f031e03, 0x21032003, 0x23032203, 0x25032403, 0x27032603,
    0x29032803, 0x2b032a03, 0x2d032c03, 0x2f032e03, 0x31033003, 0x33033203, 0x35033403, 0x37033603, 0x39033803, 0x3b033a03, 0x3d033c03, 0x3f033e03,
    0x41034003, 0x43034203, 0x45034403, 0x47034603, 0x49034803, 0x4b034a03, 0x4d034c03, 0x4f034e03, 0x51035003, 0x53035203, 0x55035403, 0x57035603,
    0x59035803, 0x5b035a03, 0x5d035c03, 0x5f035e03, 0x61036003, 0x63036203, 0x65036403, 0x67036603, 0x69036803, 0x6b036a03, 0x6d036c03, 0x6f036e03,
    0x71037003, 0x73037203, 0x75037403, 0x77037603, 0x79037803, 0x7b037a03, 0x7d037c03, 0x7f037e03, 0x81038003, 0x83038203, 0x85038403, 0x87038603,
    0x89038803, 0x8b038a03, 0x8d038c03, 0x8f038e03, 0x91039003, 0x93039203, 0x95039403, 0x97039603, 0x99039803, 0x9b039a03, 0x9d039c03, 0x9f039e03,
    0xa103a003, 0xa303a203, 0xa503a403, 0xa703a603, 0xa903a803, 0xab03aa03, 0xad03ac03, 0xaf03ae03, 0xb103b003, 0x67059400, 0x7373616c, 0x73756d05,
    0x73066369, 0x63726165, 0x6e650868, 0x6f6c6576, 0x68056570, 0x74260f82, 0x61747304, 0x04830a72, 0x6d655f3c, 0x04797470, 0x72657375, 0x6c696604,
    0x6874086d, 0x72616c5f, 0x74026567, 0x0b830768, 0x74736935, 0x066b6f02, 0x6f6d6572, 0x7a076576, 0x5f6d6f6f, 0x84086e69, 0x756f3d07, 0x666f0374,
    0x69730666, 0x6c616e67, 0x676f6303, 0x61727405, 0x68046873, 0x08656d6f, 0x65344d82, 0x746c615f, 0x6d697404, 0x6f720465, 0x640c6461, 0x6c6e776f,
    0x16830882, 0x0c870820, 0x70750622, 0x05311383, 0x6f626e69, 0x6c700b78, 0x635f7961, 0x6c637269, 0x2d738265, 0x74616570, 0x66657207, 0x68736572,
    0x8a826c08, 0x6c295084, 0x046b636f, 0x67616c66, 0x2ecc820a, 0x6f687064, 0x0a73656e, 0x756c6f76, 0x825f656d, 0x860b208f, 0x8264200a, 0x8609206d,
    0x70752b0b, 0x63727106, 0x0765646f, 0x07846162, 0x61740324, 0x03820467, 0x62047326, 0x086b6f6f, 0x6d350483, 0x056b7261, 0x6e697270, 0x61630674,
    0x6172656d, 0x6e6f6604, 0x351f8274, 0x6906646c, 0x696c6174, 0x65740b63, 0x685f7478, 0x68676965, 0x0b840a74, 0x64697725, 0x820a6874, 0x6e67271b,
    0x66656c5f, 0x0a850c74, 0x6e656326, 0x0b726574, 0x72200c85, 0x0d202e83, 0x6a270b85, 0x69747375, 0x83047966, 0x690b23cb, 0x2782646e, 0x0b863785,
    0x0e262b84, 0x65636166, 0xcd826974, 0x64697638, 0x70076f65, 0x75746369, 0x70066572, 0x69636e65, 0x616d0a6c, 0xab835f70, 0x06726524, 0x50836461,
    0x82740421, 0x042808b3, 0x74696465, 0x61687305, 0x63056572, 0x6b636568, 0x766f6d04, 0x74730d65, 0x625f7065, 0x776b6361, 0x0d647261, 0x74736166,
    0x08200d88, 0x04331687, 0x79616c70, 0x75617005, 0x73046573, 0x07706f74, 0x83726f66, 0x840c202e, 0x840c872e, 0x260c8649, 0x656a6505, 0x820c7463,
    0x72762267, 0x20f9856f, 0x840c870d, 0x70092dc2, 0x5f73756c, 0x6e676973, 0x6e696d0a, 0x0b200a86, 0x84054442, 0x6f072216, 0x2607846b, 0x6575710d,
    0x82697473, 0x242c8344, 0x666e6909, 0x2b17846f, 0x7263730a, 0x736e6565, 0x0d746f68, 0x15423686, 0x82092005, 0x23098538, 0x6e61620a, 0x2b062a42,
    0x7272610a, 0x6c5f776f, 0x0b746665, 0x85840a85, 0x0b850820, 0x86707521, 0x6f642d1f, 0x73096e77, 0x65726168, 0x746c615f, 0x732b8e82, 0x5f657a69,
    0x6c6c7566, 0x8465720c, 0x6d732c0b, 0x106c6c61, 0x6c637865, 0x88616d61, 0x67043896, 0x04746669, 0x6661656c, 0x72696604, 0x79650865, 0x706f5f65,
    0x83096e65, 0x6c632c08, 0x0c65736f, 0x6e726177, 0x84676e69, 0x052508bb, 0x6e616c70, 0x61630865, 0x646e656c, 0x72067261, 0x6f646e61, 0x6f63076d,
    0x6e656d6d, 0x616d0674, 0x74656e67, 0x072f410a, 0x41707521, 0x9f830847, 0x65720728, 0x65657774, 0xfa820d74, 0x83707021, 0x61632b52, 0x660c7472,
    0x65646c6f, 0x6c845f72, 0x0c860b20, 0x0f208283, 0x7624b886, 0x69747265, 0x11207182, 0x682c0f86, 0x7a69726f, 0x61746e6f, 0x6162096c, 0xf4823782,
    0x740c7426, 0x74746977, 0x732a4582, 0x0d6e6769, 0x65636166, 0x86416f62, 0x420c2006, 0x5f2005f1, 0x722b7c82, 0x656b036f, 0x6f630479, 0x86087367,
    0x0d732fb2, 0x6d756874, 0x755f7362, 0x6c615f70, 0x0d860f74, 0x0f83ae83, 0x74730922, 0x68296282, 0x0b666c61, 0x72616568, 0x05534474, 0x65830720,
    0x74756f2c, 0x6e696c0d, 0x6964656b, 0x10835f6e, 0x75700724, 0xd6826873, 0x78650d22, 0x6e238982, 0x835f6c61, 0x8306201e, 0x6e692b1a, 0x6f727406,
    0x0b796870, 0x61826967, 0x2f846220, 0x1d440a20, 0x31668305, 0x6d656c05, 0x70056e6f, 0x656e6f68, 0x6568630b, 0x68856b63, 0xbc430e20, 0x200e8507,
    0x8420840a, 0x8607203c, 0x870820f0, 0x850620eb, 0x75062959, 0x636f6c6e, 0x72630b6b, 0x33089782, 0x61635f74, 0x72036472, 0x68037373, 0x62086464,
    0x686c6c75, 0x046e726f, 0x6c6c6562, 0x7265630b, 0x69666974, 0x65746163, 0x6e61680a, 0x69725f64, 0x09746867, 0x6c240a84, 0x07746665, 0x75210984,
    0x24118570, 0x6e776f64, 0x059c4211, 0x91425f20, 0x8c122009, 0x20408411, 0x21128c0f, 0x348d7075, 0x25084683, 0x6f6c6705, 0x77066562, 0x636e6572,
    0x61740568, 0x06736b73, 0x746c6966, 0x62097265, 0x66656972, 0x65736163, 0xab82660a, 0x08052743, 0x72670552, 0x0470756f, 0x6b6e696c, 0x6f6c6305,
    0x62066475, 0x656b6165, 0x75630372, 0x6f630474, 0x700a7970, 0x72657061, 0x696c635f, 0x61730470, 0x730a6576, 0x5f6e6769, 0x6e616c62, 0x6572076b,
    0x6564726f, 0x6c750272, 0x0d6c6f02, 0x69727473, 0x6874656b, 0x67245082, 0x6e750968, 0x56821982, 0x83826520, 0x656c6232, 0x67616d05, 0x74056369,
    0x6b637572, 0x6e697009, 0x65238f82, 0x880e7473, 0x835f2009, 0x67102756, 0x6c676f6f, 0x03445f65, 0x8a0b2008, 0x6d053110, 0x79656e6f, 0x7261630a,
    0x645f7465, 0x086e776f, 0x75210a85, 0x24138670, 0x7466656c, 0x3213850b, 0x68676972, 0x6f630774, 0x6e6d756c, 0x6f730473, 0x83097472, 0x20368404,
    0x22098407, 0x460c7075, 0x5f2407d9, 0x08746c61, 0x20076b42, 0x31b78204, 0x656c056f, 0x096c6167, 0x68736164, 0x72616f62, 0xce420b64, 0x20298306,
    0x200b860c, 0x3d0c8373, 0x6c6f6204, 0x69730774, 0x616d6574, 0x6d750870, 0x6c657262, 0x7005616c, 0x65747361, 0x84836c0a, 0x75625f33, 0x6508626c,
    0x61686378, 0x0e65676e, 0x756f6c63, 0x24868464, 0x64616f6c, 0x420e850c, 0x072805a9, 0x72657375, 0x0b646d5f, 0x74323b82, 0x63736f68, 0x0865706f,
    0x74697573, 0x65736163, 0x58826208, 0x06357183, 0x66666f63, 0x66046565, 0x0d646f6f, 0x656c6966, 0x7865745f, 0x28c28474, 0x6c697562, 0x676e6964,
    0x223c8208, 0x82746970, 0x6d6121c0, 0x612c7d82, 0x0665636e, 0x6b64656d, 0x660b7469, 0x65829283, 0x74656a38, 0x65656204, 0x5f680672, 0x6e676973,
    0x66306604, 0x6f641165, 0x4f826275, 0x0582a782, 0x66656c24, 0x118c1274, 0x3b837220, 0x128c0f20, 0x8d707521, 0x6f642434, 0x890a6e77, 0x850b203f,
    0x2038840a, 0x210b8508, 0x1f867075, 0x072b2a83, 0x6b736564, 0x06706f74, 0x8370616c, 0x61742106, 0x74247f82, 0x626f6d0c, 0x7025d783, 0x656e6f68,
    0x06ef420c, 0x616c622a, 0x710a6b6e, 0x65746f75, 0x8505ac45, 0x255a840a, 0x69707307, 0xcc826e6e, 0x05262b85, 0x6c706572, 0xb0430a79, 0x615f2405,
    0x4510746c, 0x10830b02, 0x06450f20, 0x260f830a, 0x7078650a, 0x41646e61, 0x6c2006dd, 0x73218d82, 0x220c8365, 0x826d7305, 0x66052288, 0x39d68272,
    0x68656d03, 0x6d616707, 0x64617065, 0x79656b08, 0x72616f62, 0x6c660864, 0x29836761, 0x08840e20, 0x65686337, 0x72656b63, 0x74086465, 0x696d7265,
    0x046c616e, 0x65646f63, 0x82908409, 0x0f6c2126, 0x4408ef44, 0x0e230571, 0x46636f6c, 0x6121052c, 0x25648272, 0x6f726304, 0x32830970, 0x6f665f31,
    0x75066b72, 0x6e696c6e, 0x325f046b, 0x460b3937, 0x0b2f0a59, 0x65707573, 0x72637372, 0x09747069, 0x85627573, 0x31268209, 0x700c3338, 0x6c7a7a75,
    0x69705f65, 0x0a656365, 0x5083696d, 0x6e6f6824, 0x0a890e65, 0x666f5f2b, 0x68730666, 0x646c6569, 0x0768460e, 0x11348d85, 0x65726966, 0x7478655f,
    0x75676e69, 0x65687369, 0x6f720672, 0x7428d082, 0x78616d06, 0x116e6463, 0x22077846, 0x47676973, 0x122005ba, 0x7225118c, 0x74686769, 0x21128c0f,
    0x348d7075, 0x776f6436, 0x7468056e, 0x04356c6d, 0x33737363, 0x636e6106, 0x0a726f68, 0x42055545, 0x6c2f06c4, 0x7965736c, 0x6c651365, 0x7370696c,
    0x465f7369, 0x11200990, 0xb4461388, 0x5f042a07, 0x09333033, 0x79616c70, 0x2294835f, 0x83697406, 0x48ed82af, 0x53830739, 0x2106f245, 0x1482696d,
    0x656c0829, 0x5f6c6576, 0x850a7075, 0x20908308, 0x20b2820a, 0x05544863, 0x64650924, 0x4a847469, 0x31275982, 0x68730a32, 0x84657261, 0x63072a0f,
    0x61706d6f, 0x63087373, 0x0520426f, 0x08870c20, 0x6f745f23, 0x082d8370, 0x65033726, 0x67037275, 0x75037062, 0x69036473, 0x6a03726e, 0x72037970,
    0x6b036275, 0x62037772, 0x66046374, 0x09656c69, 0x2708b343, 0x726f7310, 0x79625f74, 0x7025a282, 0x65626168, 0x22448274, 0x88123932, 0x06315215,
    0x16736522, 0x33821291, 0x870d7421, 0x726f2516, 0x11726564, 0x1f830d8c, 0x33214e82, 0x27048334, 0x6f790c35, 0x62757475, 0x0c86c886, 0x69780425,
    0x8309676e, 0x88df8404, 0x6c703123, 0x64077961, 0x62706f72, 0x730d786f, 0x6b636174, 0x2207bc44, 0x826e6909, 0x7267390f, 0x66066d61, 0x6b63696c,
    0x64610372, 0x3166046e, 0x620e3137, 0x75627469, 0x3b412982, 0x74062705, 0x6c626d75, 0x06850b72, 0x0f245e84, 0x676e6f6c, 0x2406da46, 0x6e776f64,
    0x210f8a0d, 0x1d8b7075, 0x66656c24, 0x1d8a1074, 0x67697228, 0x77077468, 0x36826e69, 0x61077323, 0x279a826e, 0x6c056469, 0x78756e69, 0x2408a682,
    0x6c626269, 0x6b730565, 0x0a657079, 0x72756f66, 0x61757173, 0x74066572, 0x6c6c6572, 0x6566066f, 0x656c616d, 0x08048304, 0x69670628, 0x70697474,
    0x6e757303, 0x36335f04, 0x72610736, 0x76696863, 0x75620365, 0x6b760267, 0x69657705, 0x72066f62, 0x02826e65, 0x37222082, 0xfb840e32, 0xfc875f20,
    0x34261383, 0x72726115, 0x3a4a776f, 0x615f2406, 0x835f746c, 0x241a83ad, 0x6f640e36, 0x83188a74, 0x0c382713, 0x656d6976, 0x93855f6f, 0x38221182,
    0xd9460d30, 0x21a48405, 0x12836f5f, 0x04833220, 0x04833320, 0x04833420, 0x04833520, 0x04833620, 0x04833720, 0x04833820, 0x7507392d, 0x3146696e,
    0x66043041, 0x82316131, 0x83392011, 0x33392134, 0x34200e83, 0x35200e83, 0x36200483, 0x37200483, 0x34830483, 0x04393925, 0x8430345f, 0x83622031,
    0x22318209, 0x83333034, 0x85342009, 0x3142214d, 0x34820c83, 0x82303421, 0x30342134, 0x34213482, 0x21348330, 0x18823031, 0x1d833120, 0x83323121,
    0x83332009, 0x83342004, 0x83352004, 0x83362004, 0x83372004, 0x20318304, 0x219b8631, 0x55853043, 0x82314321, 0x83322019, 0x33322137, 0x34200983,
    0x35200483, 0x36200483, 0x37200483, 0x37830483, 0x69833220, 0x82303321, 0x3133210e, 0x32200483, 0x33200483, 0x9e860483, 0x50864420, 0x85314421,
    0x84442058, 0x203a8321, 0x21728633, 0x19863544, 0x07863620, 0x3e823720, 0x43833420, 0x83343421, 0x83352009, 0x83362004, 0x83188404, 0x8634203a,
    0x3045213a, 0x35211682, 0x20048331, 0x20048332, 0x20048333, 0x20048334, 0x20048335, 0x20048336, 0x83048337, 0x83352034, 0x303621aa, 0x36210e82,
    0x20048331, 0x20048332, 0x86048333, 0x844620aa, 0x2534831b, 0x66043736, 0x1b846631, 0x37203483, 0x37211883, 0x212a8231, 0x04833237, 0x04833320,
    0x04833420, 0x04833520, 0x2c833620, 0x09836320, 0x37206683, 0x38213183, 0x210e8230, 0x04833138, 0x04833220, 0x04833320, 0x38203183, 0x38213183,
    0x200e8336, 0x83048337, 0x83382031, 0x30392131, 0x39210e82, 0x20048331, 0x20048332, 0x24048333, 0x32660434, 0x20188431, 0x84098336, 0x20318318,
    0x27318239, 0x04303035, 0x3130355f, 0x32200483, 0x33200483, 0x34200483, 0x35200483, 0x36200483, 0x37200483, 0x31820483, 0x39303528, 0x6e657605,
    0x0f827375, 0x83313121, 0x21328304, 0x09833331, 0x04833420, 0x04833520, 0x04833620, 0x04833720, 0x31203283, 0x32216483, 0x210e8230, 0x04833132,
    0x04833220, 0x04833320, 0x04833420, 0x04833520, 0x04833620, 0x04833720, 0x32203183, 0x33213183, 0x210e8230, 0x04833133, 0x04833220, 0x04833320,
    0x04833420, 0x04833520, 0x04833620, 0x04833720, 0x33203183, 0x34213183, 0x210e8230, 0x04833134, 0x04833220, 0x04833320, 0x04833420, 0x04833520,
    0x04833620, 0x04833720, 0x34203183, 0x35213183, 0x210e8230, 0x04833135, 0x04833220, 0x04833320, 0x04833420, 0x04833520, 0x04833620, 0x04833720,
    0x35203183, 0x36213183, 0x210e8230, 0x04833136, 0x04833220, 0x04833320, 0x04833420, 0x04833520, 0x04833620, 0x04833720, 0x36243183, 0x32660439,
    0x04823182, 0x13823120, 0x83323721, 0x8333200e, 0x83342009, 0x83352004, 0x83362004, 0x83372004, 0x20318304, 0x21638337, 0x0e823038, 0x83313821,
    0x83322004, 0x83332004, 0x83342004, 0x83352004, 0x83362004, 0x83372004, 0x20318304, 0x21318338, 0x0e823039, 0x83313921, 0x83322004, 0x83332004,
    0x83342004, 0x83352004, 0x83362004, 0x83372004, 0x82382004, 0x65372881, 0x696e7507, 0x43383246, 0x32200551, 0x36216983, 0x21378230, 0x37823036,
    0x42303621, 0x322105c5, 0x054e4338, 0x82383221, 0x3036213d, 0x36213d82, 0x216f8230, 0x6f823036, 0x30313627, 0x31365f04, 0x20048331, 0x20048332,
    0x20048333, 0x20048334, 0x20048335, 0x20048336, 0x83048337, 0x83312031, 0x30322131, 0x32210e82, 0x20048331, 0x20048332, 0x20048333, 0x20048334,
    0x20048335, 0x20048336, 0x83048337, 0x43322031, 0x32210596, 0x20a18641, 0x05f34341, 0x32413222, 0x4121b985, 0x86078633, 0x864120aa, 0x434120aa,
    0x322205f9, 0x1f863741, 0x07863820, 0x41204f87, 0x42200f86, 0x43200786, 0x44200786, 0x45200786, 0x42210785, 0x20078630, 0x86078631, 0x86422077,
    0x86422077, 0x86422077, 0x86422077, 0x86422077, 0x86422077, 0x86422077, 0x86422077, 0x86422077, 0x86422077, 0x86422077, 0x86422077, 0x06344577,
    0x31433222, 0x43207785, 0x43207786, 0x43207786, 0x43207786, 0x43207786, 0x43207786, 0x43207786, 0x43207786, 0x43207786, 0x43207786, 0x43207786,
    0x43207786, 0x43207786, 0x5b457786, 0x45322006, 0x3221065b, 0x20778644, 0x20778644, 0x45778644, 0x32210661, 0x20778644, 0x20778644, 0x20778644,
    0x20778644, 0x20778644, 0x20778644, 0x20778644, 0x20778644, 0x21778644, 0xe7853045, 0x86314521, 0x20778607, 0x20778645, 0x20778645, 0x20ef8645,
    0x25778645, 0x5f043745, 0x74863936, 0x74864520, 0x74864520, 0x74864520, 0x74864520, 0x74864520, 0x00454522, 0x01260084, 0x0200ffff, 0x0b820100,
    0x03820e20, 0x03821820, 0x0f840020, 0xc2020122, 0x04201582, 0x83089b5a, 0xcc002421, 0x82cfa23d, 0xcb002c11, 0x00303c4f, 0xd4000000, 0x05b96831,
    0xff9dfbfa, 0x000000cb,
};


```

`hack/render/fonts/icon.hpp`:

```hpp
// Generated by https://github.com/juliettef/IconFontCppHeaders script GenerateIconFontCppHeaders.py for languages C and C++
// from https://github.com/FortAwesome/Font-Awesome/raw/4.x/src/icons.yml
// for use with https://github.com/FortAwesome/Font-Awesome/blob/4.x/fonts/fontawesome-webfont.ttf
#pragma once

#define FONT_ICON_FILE_NAME_FA "fontawesome-webfont.ttf"

#define ICON_MIN_FA 0xf000
#define ICON_MAX_16_FA 0xf2e0
#define ICON_MAX_FA 0xf2e0
#define ICON_FA_GLASS "\xef\x80\x80"	// U+f000
#define ICON_FA_MUSIC "\xef\x80\x81"	// U+f001
#define ICON_FA_SEARCH "\xef\x80\x82"	// U+f002
#define ICON_FA_ENVELOPE_O "\xef\x80\x83"	// U+f003
#define ICON_FA_HEART "\xef\x80\x84"	// U+f004
#define ICON_FA_STAR "\xef\x80\x85"	// U+f005
#define ICON_FA_STAR_O "\xef\x80\x86"	// U+f006
#define ICON_FA_USER "\xef\x80\x87"	// U+f007
#define ICON_FA_FILM "\xef\x80\x88"	// U+f008
#define ICON_FA_TH_LARGE "\xef\x80\x89"	// U+f009
#define ICON_FA_TH "\xef\x80\x8a"	// U+f00a
#define ICON_FA_TH_LIST "\xef\x80\x8b"	// U+f00b
#define ICON_FA_CHECK "\xef\x80\x8c"	// U+f00c
#define ICON_FA_TIMES "\xef\x80\x8d"	// U+f00d
#define ICON_FA_SEARCH_PLUS "\xef\x80\x8e"	// U+f00e
#define ICON_FA_SEARCH_MINUS "\xef\x80\x90"	// U+f010
#define ICON_FA_POWER_OFF "\xef\x80\x91"	// U+f011
#define ICON_FA_SIGNAL "\xef\x80\x92"	// U+f012
#define ICON_FA_COG "\xef\x80\x93"	// U+f013
#define ICON_FA_TRASH_O "\xef\x80\x94"	// U+f014
#define ICON_FA_HOME "\xef\x80\x95"	// U+f015
#define ICON_FA_FILE_O "\xef\x80\x96"	// U+f016
#define ICON_FA_CLOCK_O "\xef\x80\x97"	// U+f017
#define ICON_FA_ROAD "\xef\x80\x98"	// U+f018
#define ICON_FA_DOWNLOAD "\xef\x80\x99"	// U+f019
#define ICON_FA_ARROW_CIRCLE_O_DOWN "\xef\x80\x9a"	// U+f01a
#define ICON_FA_ARROW_CIRCLE_O_UP "\xef\x80\x9b"	// U+f01b
#define ICON_FA_INBOX "\xef\x80\x9c"	// U+f01c
#define ICON_FA_PLAY_CIRCLE_O "\xef\x80\x9d"	// U+f01d
#define ICON_FA_REPEAT "\xef\x80\x9e"	// U+f01e
#define ICON_FA_REFRESH "\xef\x80\xa1"	// U+f021
#define ICON_FA_LIST_ALT "\xef\x80\xa2"	// U+f022
#define ICON_FA_LOCK "\xef\x80\xa3"	// U+f023
#define ICON_FA_FLAG "\xef\x80\xa4"	// U+f024
#define ICON_FA_HEADPHONES "\xef\x80\xa5"	// U+f025
#define ICON_FA_VOLUME_OFF "\xef\x80\xa6"	// U+f026
#define ICON_FA_VOLUME_DOWN "\xef\x80\xa7"	// U+f027
#define ICON_FA_VOLUME_UP "\xef\x80\xa8"	// U+f028
#define ICON_FA_QRCODE "\xef\x80\xa9"	// U+f029
#define ICON_FA_BARCODE "\xef\x80\xaa"	// U+f02a
#define ICON_FA_TAG "\xef\x80\xab"	// U+f02b
#define ICON_FA_TAGS "\xef\x80\xac"	// U+f02c
#define ICON_FA_BOOK "\xef\x80\xad"	// U+f02d
#define ICON_FA_BOOKMARK "\xef\x80\xae"	// U+f02e
#define ICON_FA_PRINT "\xef\x80\xaf"	// U+f02f
#define ICON_FA_CAMERA "\xef\x80\xb0"	// U+f030
#define ICON_FA_FONT "\xef\x80\xb1"	// U+f031
#define ICON_FA_BOLD "\xef\x80\xb2"	// U+f032
#define ICON_FA_ITALIC "\xef\x80\xb3"	// U+f033
#define ICON_FA_TEXT_HEIGHT "\xef\x80\xb4"	// U+f034
#define ICON_FA_TEXT_WIDTH "\xef\x80\xb5"	// U+f035
#define ICON_FA_ALIGN_LEFT "\xef\x80\xb6"	// U+f036
#define ICON_FA_ALIGN_CENTER "\xef\x80\xb7"	// U+f037
#define ICON_FA_ALIGN_RIGHT "\xef\x80\xb8"	// U+f038
#define ICON_FA_ALIGN_JUSTIFY "\xef\x80\xb9"	// U+f039
#define ICON_FA_LIST "\xef\x80\xba"	// U+f03a
#define ICON_FA_OUTDENT "\xef\x80\xbb"	// U+f03b
#define ICON_FA_INDENT "\xef\x80\xbc"	// U+f03c
#define ICON_FA_VIDEO_CAMERA "\xef\x80\xbd"	// U+f03d
#define ICON_FA_PICTURE_O "\xef\x80\xbe"	// U+f03e
#define ICON_FA_PENCIL "\xef\x81\x80"	// U+f040
#define ICON_FA_MAP_MARKER "\xef\x81\x81"	// U+f041
#define ICON_FA_ADJUST "\xef\x81\x82"	// U+f042
#define ICON_FA_TINT "\xef\x81\x83"	// U+f043
#define ICON_FA_PENCIL_SQUARE_O "\xef\x81\x84"	// U+f044
#define ICON_FA_SHARE_SQUARE_O "\xef\x81\x85"	// U+f045
#define ICON_FA_CHECK_SQUARE_O "\xef\x81\x86"	// U+f046
#define ICON_FA_ARROWS "\xef\x81\x87"	// U+f047
#define ICON_FA_STEP_BACKWARD "\xef\x81\x88"	// U+f048
#define ICON_FA_FAST_BACKWARD "\xef\x81\x89"	// U+f049
#define ICON_FA_BACKWARD "\xef\x81\x8a"	// U+f04a
#define ICON_FA_PLAY "\xef\x81\x8b"	// U+f04b
#define ICON_FA_PAUSE "\xef\x81\x8c"	// U+f04c
#define ICON_FA_STOP "\xef\x81\x8d"	// U+f04d
#define ICON_FA_FORWARD "\xef\x81\x8e"	// U+f04e
#define ICON_FA_FAST_FORWARD "\xef\x81\x90"	// U+f050
#define ICON_FA_STEP_FORWARD "\xef\x81\x91"	// U+f051
#define ICON_FA_EJECT "\xef\x81\x92"	// U+f052
#define ICON_FA_CHEVRON_LEFT "\xef\x81\x93"	// U+f053
#define ICON_FA_CHEVRON_RIGHT "\xef\x81\x94"	// U+f054
#define ICON_FA_PLUS_CIRCLE "\xef\x81\x95"	// U+f055
#define ICON_FA_MINUS_CIRCLE "\xef\x81\x96"	// U+f056
#define ICON_FA_TIMES_CIRCLE "\xef\x81\x97"	// U+f057
#define ICON_FA_CHECK_CIRCLE "\xef\x81\x98"	// U+f058
#define ICON_FA_QUESTION_CIRCLE "\xef\x81\x99"	// U+f059
#define ICON_FA_INFO_CIRCLE "\xef\x81\x9a"	// U+f05a
#define ICON_FA_CROSSHAIRS "\xef\x81\x9b"	// U+f05b
#define ICON_FA_TIMES_CIRCLE_O "\xef\x81\x9c"	// U+f05c
#define ICON_FA_CHECK_CIRCLE_O "\xef\x81\x9d"	// U+f05d
#define ICON_FA_BAN "\xef\x81\x9e"	// U+f05e
#define ICON_FA_ARROW_LEFT "\xef\x81\xa0"	// U+f060
#define ICON_FA_ARROW_RIGHT "\xef\x81\xa1"	// U+f061
#define ICON_FA_ARROW_UP "\xef\x81\xa2"	// U+f062
#define ICON_FA_ARROW_DOWN "\xef\x81\xa3"	// U+f063
#define ICON_FA_SHARE "\xef\x81\xa4"	// U+f064
#define ICON_FA_EXPAND "\xef\x81\xa5"	// U+f065
#define ICON_FA_COMPRESS "\xef\x81\xa6"	// U+f066
#define ICON_FA_PLUS "\xef\x81\xa7"	// U+f067
#define ICON_FA_MINUS "\xef\x81\xa8"	// U+f068
#define ICON_FA_ASTERISK "\xef\x81\xa9"	// U+f069
#define ICON_FA_EXCLAMATION_CIRCLE "\xef\x81\xaa"	// U+f06a
#define ICON_FA_GIFT "\xef\x81\xab"	// U+f06b
#define ICON_FA_LEAF "\xef\x81\xac"	// U+f06c
#define ICON_FA_FIRE "\xef\x81\xad"	// U+f06d
#define ICON_FA_EYE "\xef\x81\xae"	// U+f06e
#define ICON_FA_EYE_SLASH "\xef\x81\xb0"	// U+f070
#define ICON_FA_EXCLAMATION_TRIANGLE "\xef\x81\xb1"	// U+f071
#define ICON_FA_PLANE "\xef\x81\xb2"	// U+f072
#define ICON_FA_CALENDAR "\xef\x81\xb3"	// U+f073
#define ICON_FA_RANDOM "\xef\x81\xb4"	// U+f074
#define ICON_FA_COMMENT "\xef\x81\xb5"	// U+f075
#define ICON_FA_MAGNET "\xef\x81\xb6"	// U+f076
#define ICON_FA_CHEVRON_UP "\xef\x81\xb7"	// U+f077
#define ICON_FA_CHEVRON_DOWN "\xef\x81\xb8"	// U+f078
#define ICON_FA_RETWEET "\xef\x81\xb9"	// U+f079
#define ICON_FA_SHOPPING_CART "\xef\x81\xba"	// U+f07a
#define ICON_FA_FOLDER "\xef\x81\xbb"	// U+f07b
#define ICON_FA_FOLDER_OPEN "\xef\x81\xbc"	// U+f07c
#define ICON_FA_ARROWS_V "\xef\x81\xbd"	// U+f07d
#define ICON_FA_ARROWS_H "\xef\x81\xbe"	// U+f07e
#define ICON_FA_BAR_CHART "\xef\x82\x80"	// U+f080
#define ICON_FA_TWITTER_SQUARE "\xef\x82\x81"	// U+f081
#define ICON_FA_FACEBOOK_SQUARE "\xef\x82\x82"	// U+f082
#define ICON_FA_CAMERA_RETRO "\xef\x82\x83"	// U+f083
#define ICON_FA_KEY "\xef\x82\x84"	// U+f084
#define ICON_FA_COGS "\xef\x82\x85"	// U+f085
#define ICON_FA_COMMENTS "\xef\x82\x86"	// U+f086
#define ICON_FA_THUMBS_O_UP "\xef\x82\x87"	// U+f087
#define ICON_FA_THUMBS_O_DOWN "\xef\x82\x88"	// U+f088
#define ICON_FA_STAR_HALF "\xef\x82\x89"	// U+f089
#define ICON_FA_HEART_O "\xef\x82\x8a"	// U+f08a
#define ICON_FA_SIGN_OUT "\xef\x82\x8b"	// U+f08b
#define ICON_FA_LINKEDIN_SQUARE "\xef\x82\x8c"	// U+f08c
#define ICON_FA_THUMB_TACK "\xef\x82\x8d"	// U+f08d
#define ICON_FA_EXTERNAL_LINK "\xef\x82\x8e"	// U+f08e
#define ICON_FA_SIGN_IN "\xef\x82\x90"	// U+f090
#define ICON_FA_TROPHY "\xef\x82\x91"	// U+f091
#define ICON_FA_GITHUB_SQUARE "\xef\x82\x92"	// U+f092
#define ICON_FA_UPLOAD "\xef\x82\x93"	// U+f093
#define ICON_FA_LEMON_O "\xef\x82\x94"	// U+f094
#define ICON_FA_PHONE "\xef\x82\x95"	// U+f095
#define ICON_FA_SQUARE_O "\xef\x82\x96"	// U+f096
#define ICON_FA_BOOKMARK_O "\xef\x82\x97"	// U+f097
#define ICON_FA_PHONE_SQUARE "\xef\x82\x98"	// U+f098
#define ICON_FA_TWITTER "\xef\x82\x99"	// U+f099
#define ICON_FA_FACEBOOK "\xef\x82\x9a"	// U+f09a
#define ICON_FA_GITHUB "\xef\x82\x9b"	// U+f09b
#define ICON_FA_UNLOCK "\xef\x82\x9c"	// U+f09c
#define ICON_FA_CREDIT_CARD "\xef\x82\x9d"	// U+f09d
#define ICON_FA_RSS "\xef\x82\x9e"	// U+f09e
#define ICON_FA_HDD_O "\xef\x82\xa0"	// U+f0a0
#define ICON_FA_BULLHORN "\xef\x82\xa1"	// U+f0a1
#define ICON_FA_BELL "\xef\x83\xb3"	// U+f0f3
#define ICON_FA_CERTIFICATE "\xef\x82\xa3"	// U+f0a3
#define ICON_FA_HAND_O_RIGHT "\xef\x82\xa4"	// U+f0a4
#define ICON_FA_HAND_O_LEFT "\xef\x82\xa5"	// U+f0a5
#define ICON_FA_HAND_O_UP "\xef\x82\xa6"	// U+f0a6
#define ICON_FA_HAND_O_DOWN "\xef\x82\xa7"	// U+f0a7
#define ICON_FA_ARROW_CIRCLE_LEFT "\xef\x82\xa8"	// U+f0a8
#define ICON_FA_ARROW_CIRCLE_RIGHT "\xef\x82\xa9"	// U+f0a9
#define ICON_FA_ARROW_CIRCLE_UP "\xef\x82\xaa"	// U+f0aa
#define ICON_FA_ARROW_CIRCLE_DOWN "\xef\x82\xab"	// U+f0ab
#define ICON_FA_GLOBE "\xef\x82\xac"	// U+f0ac
#define ICON_FA_WRENCH "\xef\x82\xad"	// U+f0ad
#define ICON_FA_TASKS "\xef\x82\xae"	// U+f0ae
#define ICON_FA_FILTER "\xef\x82\xb0"	// U+f0b0
#define ICON_FA_BRIEFCASE "\xef\x82\xb1"	// U+f0b1
#define ICON_FA_ARROWS_ALT "\xef\x82\xb2"	// U+f0b2
#define ICON_FA_USERS "\xef\x83\x80"	// U+f0c0
#define ICON_FA_LINK "\xef\x83\x81"	// U+f0c1
#define ICON_FA_CLOUD "\xef\x83\x82"	// U+f0c2
#define ICON_FA_FLASK "\xef\x83\x83"	// U+f0c3
#define ICON_FA_SCISSORS "\xef\x83\x84"	// U+f0c4
#define ICON_FA_FILES_O "\xef\x83\x85"	// U+f0c5
#define ICON_FA_PAPERCLIP "\xef\x83\x86"	// U+f0c6
#define ICON_FA_FLOPPY_O "\xef\x83\x87"	// U+f0c7
#define ICON_FA_SQUARE "\xef\x83\x88"	// U+f0c8
#define ICON_FA_BARS "\xef\x83\x89"	// U+f0c9
#define ICON_FA_LIST_UL "\xef\x83\x8a"	// U+f0ca
#define ICON_FA_LIST_OL "\xef\x83\x8b"	// U+f0cb
#define ICON_FA_STRIKETHROUGH "\xef\x83\x8c"	// U+f0cc
#define ICON_FA_UNDERLINE "\xef\x83\x8d"	// U+f0cd
#define ICON_FA_TABLE "\xef\x83\x8e"	// U+f0ce
#define ICON_FA_MAGIC "\xef\x83\x90"	// U+f0d0
#define ICON_FA_TRUCK "\xef\x83\x91"	// U+f0d1
#define ICON_FA_PINTEREST "\xef\x83\x92"	// U+f0d2
#define ICON_FA_PINTEREST_SQUARE "\xef\x83\x93"	// U+f0d3
#define ICON_FA_GOOGLE_PLUS_SQUARE "\xef\x83\x94"	// U+f0d4
#define ICON_FA_GOOGLE_PLUS "\xef\x83\x95"	// U+f0d5
#define ICON_FA_MONEY "\xef\x83\x96"	// U+f0d6
#define ICON_FA_CARET_DOWN "\xef\x83\x97"	// U+f0d7
#define ICON_FA_CARET_UP "\xef\x83\x98"	// U+f0d8
#define ICON_FA_CARET_LEFT "\xef\x83\x99"	// U+f0d9
#define ICON_FA_CARET_RIGHT "\xef\x83\x9a"	// U+f0da
#define ICON_FA_COLUMNS "\xef\x83\x9b"	// U+f0db
#define ICON_FA_SORT "\xef\x83\x9c"	// U+f0dc
#define ICON_FA_SORT_DESC "\xef\x83\x9d"	// U+f0dd
#define ICON_FA_SORT_ASC "\xef\x83\x9e"	// U+f0de
#define ICON_FA_ENVELOPE "\xef\x83\xa0"	// U+f0e0
#define ICON_FA_LINKEDIN "\xef\x83\xa1"	// U+f0e1
#define ICON_FA_UNDO "\xef\x83\xa2"	// U+f0e2
#define ICON_FA_GAVEL "\xef\x83\xa3"	// U+f0e3
#define ICON_FA_TACHOMETER "\xef\x83\xa4"	// U+f0e4
#define ICON_FA_COMMENT_O "\xef\x83\xa5"	// U+f0e5
#define ICON_FA_COMMENTS_O "\xef\x83\xa6"	// U+f0e6
#define ICON_FA_BOLT "\xef\x83\xa7"	// U+f0e7
#define ICON_FA_SITEMAP "\xef\x83\xa8"	// U+f0e8
#define ICON_FA_UMBRELLA "\xef\x83\xa9"	// U+f0e9
#define ICON_FA_CLIPBOARD "\xef\x83\xaa"	// U+f0ea
#define ICON_FA_LIGHTBULB_O "\xef\x83\xab"	// U+f0eb
#define ICON_FA_EXCHANGE "\xef\x83\xac"	// U+f0ec
#define ICON_FA_CLOUD_DOWNLOAD "\xef\x83\xad"	// U+f0ed
#define ICON_FA_CLOUD_UPLOAD "\xef\x83\xae"	// U+f0ee
#define ICON_FA_USER_MD "\xef\x83\xb0"	// U+f0f0
#define ICON_FA_STETHOSCOPE "\xef\x83\xb1"	// U+f0f1
#define ICON_FA_SUITCASE "\xef\x83\xb2"	// U+f0f2
#define ICON_FA_BELL_O "\xef\x82\xa2"	// U+f0a2
#define ICON_FA_COFFEE "\xef\x83\xb4"	// U+f0f4
#define ICON_FA_CUTLERY "\xef\x83\xb5"	// U+f0f5
#define ICON_FA_FILE_TEXT_O "\xef\x83\xb6"	// U+f0f6
#define ICON_FA_BUILDING_O "\xef\x83\xb7"	// U+f0f7
#define ICON_FA_HOSPITAL_O "\xef\x83\xb8"	// U+f0f8
#define ICON_FA_AMBULANCE "\xef\x83\xb9"	// U+f0f9
#define ICON_FA_MEDKIT "\xef\x83\xba"	// U+f0fa
#define ICON_FA_FIGHTER_JET "\xef\x83\xbb"	// U+f0fb
#define ICON_FA_BEER "\xef\x83\xbc"	// U+f0fc
#define ICON_FA_H_SQUARE "\xef\x83\xbd"	// U+f0fd
#define ICON_FA_PLUS_SQUARE "\xef\x83\xbe"	// U+f0fe
#define ICON_FA_ANGLE_DOUBLE_LEFT "\xef\x84\x80"	// U+f100
#define ICON_FA_ANGLE_DOUBLE_RIGHT "\xef\x84\x81"	// U+f101
#define ICON_FA_ANGLE_DOUBLE_UP "\xef\x84\x82"	// U+f102
#define ICON_FA_ANGLE_DOUBLE_DOWN "\xef\x84\x83"	// U+f103
#define ICON_FA_ANGLE_LEFT "\xef\x84\x84"	// U+f104
#define ICON_FA_ANGLE_RIGHT "\xef\x84\x85"	// U+f105
#define ICON_FA_ANGLE_UP "\xef\x84\x86"	// U+f106
#define ICON_FA_ANGLE_DOWN "\xef\x84\x87"	// U+f107
#define ICON_FA_DESKTOP "\xef\x84\x88"	// U+f108
#define ICON_FA_LAPTOP "\xef\x84\x89"	// U+f109
#define ICON_FA_TABLET "\xef\x84\x8a"	// U+f10a
#define ICON_FA_MOBILE "\xef\x84\x8b"	// U+f10b
#define ICON_FA_CIRCLE_O "\xef\x84\x8c"	// U+f10c
#define ICON_FA_QUOTE_LEFT "\xef\x84\x8d"	// U+f10d
#define ICON_FA_QUOTE_RIGHT "\xef\x84\x8e"	// U+f10e
#define ICON_FA_SPINNER "\xef\x84\x90"	// U+f110
#define ICON_FA_CIRCLE "\xef\x84\x91"	// U+f111
#define ICON_FA_REPLY "\xef\x84\x92"	// U+f112
#define ICON_FA_GITHUB_ALT "\xef\x84\x93"	// U+f113
#define ICON_FA_FOLDER_O "\xef\x84\x94"	// U+f114
#define ICON_FA_FOLDER_OPEN_O "\xef\x84\x95"	// U+f115
#define ICON_FA_SMILE_O "\xef\x84\x98"	// U+f118
#define ICON_FA_FROWN_O "\xef\x84\x99"	// U+f119
#define ICON_FA_MEH_O "\xef\x84\x9a"	// U+f11a
#define ICON_FA_GAMEPAD "\xef\x84\x9b"	// U+f11b
#define ICON_FA_KEYBOARD_O "\xef\x84\x9c"	// U+f11c
#define ICON_FA_FLAG_O "\xef\x84\x9d"	// U+f11d
#define ICON_FA_FLAG_CHECKERED "\xef\x84\x9e"	// U+f11e
#define ICON_FA_TERMINAL "\xef\x84\xa0"	// U+f120
#define ICON_FA_CODE "\xef\x84\xa1"	// U+f121
#define ICON_FA_REPLY_ALL "\xef\x84\xa2"	// U+f122
#define ICON_FA_STAR_HALF_O "\xef\x84\xa3"	// U+f123
#define ICON_FA_LOCATION_ARROW "\xef\x84\xa4"	// U+f124
#define ICON_FA_CROP "\xef\x84\xa5"	// U+f125
#define ICON_FA_CODE_FORK "\xef\x84\xa6"	// U+f126
#define ICON_FA_CHAIN_BROKEN "\xef\x84\xa7"	// U+f127
#define ICON_FA_QUESTION "\xef\x84\xa8"	// U+f128
#define ICON_FA_INFO "\xef\x84\xa9"	// U+f129
#define ICON_FA_EXCLAMATION "\xef\x84\xaa"	// U+f12a
#define ICON_FA_SUPERSCRIPT "\xef\x84\xab"	// U+f12b
#define ICON_FA_SUBSCRIPT "\xef\x84\xac"	// U+f12c
#define ICON_FA_ERASER "\xef\x84\xad"	// U+f12d
#define ICON_FA_PUZZLE_PIECE "\xef\x84\xae"	// U+f12e
#define ICON_FA_MICROPHONE "\xef\x84\xb0"	// U+f130
#define ICON_FA_MICROPHONE_SLASH "\xef\x84\xb1"	// U+f131
#define ICON_FA_SHIELD "\xef\x84\xb2"	// U+f132
#define ICON_FA_CALENDAR_O "\xef\x84\xb3"	// U+f133
#define ICON_FA_FIRE_EXTINGUISHER "\xef\x84\xb4"	// U+f134
#define ICON_FA_ROCKET "\xef\x84\xb5"	// U+f135
#define ICON_FA_MAXCDN "\xef\x84\xb6"	// U+f136
#define ICON_FA_CHEVRON_CIRCLE_LEFT "\xef\x84\xb7"	// U+f137
#define ICON_FA_CHEVRON_CIRCLE_RIGHT "\xef\x84\xb8"	// U+f138
#define ICON_FA_CHEVRON_CIRCLE_UP "\xef\x84\xb9"	// U+f139
#define ICON_FA_CHEVRON_CIRCLE_DOWN "\xef\x84\xba"	// U+f13a
#define ICON_FA_HTML5 "\xef\x84\xbb"	// U+f13b
#define ICON_FA_CSS3 "\xef\x84\xbc"	// U+f13c
#define ICON_FA_ANCHOR "\xef\x84\xbd"	// U+f13d
#define ICON_FA_UNLOCK_ALT "\xef\x84\xbe"	// U+f13e
#define ICON_FA_BULLSEYE "\xef\x85\x80"	// U+f140
#define ICON_FA_ELLIPSIS_H "\xef\x85\x81"	// U+f141
#define ICON_FA_ELLIPSIS_V "\xef\x85\x82"	// U+f142
#define ICON_FA_RSS_SQUARE "\xef\x85\x83"	// U+f143
#define ICON_FA_PLAY_CIRCLE "\xef\x85\x84"	// U+f144
#define ICON_FA_TICKET "\xef\x85\x85"	// U+f145
#define ICON_FA_MINUS_SQUARE "\xef\x85\x86"	// U+f146
#define ICON_FA_MINUS_SQUARE_O "\xef\x85\x87"	// U+f147
#define ICON_FA_LEVEL_UP "\xef\x85\x88"	// U+f148
#define ICON_FA_LEVEL_DOWN "\xef\x85\x89"	// U+f149
#define ICON_FA_CHECK_SQUARE "\xef\x85\x8a"	// U+f14a
#define ICON_FA_PENCIL_SQUARE "\xef\x85\x8b"	// U+f14b
#define ICON_FA_EXTERNAL_LINK_SQUARE "\xef\x85\x8c"	// U+f14c
#define ICON_FA_SHARE_SQUARE "\xef\x85\x8d"	// U+f14d
#define ICON_FA_COMPASS "\xef\x85\x8e"	// U+f14e
#define ICON_FA_CARET_SQUARE_O_DOWN "\xef\x85\x90"	// U+f150
#define ICON_FA_CARET_SQUARE_O_UP "\xef\x85\x91"	// U+f151
#define ICON_FA_CARET_SQUARE_O_RIGHT "\xef\x85\x92"	// U+f152
#define ICON_FA_EUR "\xef\x85\x93"	// U+f153
#define ICON_FA_GBP "\xef\x85\x94"	// U+f154
#define ICON_FA_USD "\xef\x85\x95"	// U+f155
#define ICON_FA_INR "\xef\x85\x96"	// U+f156
#define ICON_FA_JPY "\xef\x85\x97"	// U+f157
#define ICON_FA_RUB "\xef\x85\x98"	// U+f158
#define ICON_FA_KRW "\xef\x85\x99"	// U+f159
#define ICON_FA_BTC "\xef\x85\x9a"	// U+f15a
#define ICON_FA_FILE "\xef\x85\x9b"	// U+f15b
#define ICON_FA_FILE_TEXT "\xef\x85\x9c"	// U+f15c
#define ICON_FA_SORT_ALPHA_ASC "\xef\x85\x9d"	// U+f15d
#define ICON_FA_SORT_ALPHA_DESC "\xef\x85\x9e"	// U+f15e
#define ICON_FA_SORT_AMOUNT_ASC "\xef\x85\xa0"	// U+f160
#define ICON_FA_SORT_AMOUNT_DESC "\xef\x85\xa1"	// U+f161
#define ICON_FA_SORT_NUMERIC_ASC "\xef\x85\xa2"	// U+f162
#define ICON_FA_SORT_NUMERIC_DESC "\xef\x85\xa3"	// U+f163
#define ICON_FA_THUMBS_UP "\xef\x85\xa4"	// U+f164
#define ICON_FA_THUMBS_DOWN "\xef\x85\xa5"	// U+f165
#define ICON_FA_YOUTUBE_SQUARE "\xef\x85\xa6"	// U+f166
#define ICON_FA_YOUTUBE "\xef\x85\xa7"	// U+f167
#define ICON_FA_XING "\xef\x85\xa8"	// U+f168
#define ICON_FA_XING_SQUARE "\xef\x85\xa9"	// U+f169
#define ICON_FA_YOUTUBE_PLAY "\xef\x85\xaa"	// U+f16a
#define ICON_FA_DROPBOX "\xef\x85\xab"	// U+f16b
#define ICON_FA_STACK_OVERFLOW "\xef\x85\xac"	// U+f16c
#define ICON_FA_INSTAGRAM "\xef\x85\xad"	// U+f16d
#define ICON_FA_FLICKR "\xef\x85\xae"	// U+f16e
#define ICON_FA_ADN "\xef\x85\xb0"	// U+f170
#define ICON_FA_BITBUCKET "\xef\x85\xb1"	// U+f171
#define ICON_FA_BITBUCKET_SQUARE "\xef\x85\xb2"	// U+f172
#define ICON_FA_TUMBLR "\xef\x85\xb3"	// U+f173
#define ICON_FA_TUMBLR_SQUARE "\xef\x85\xb4"	// U+f174
#define ICON_FA_LONG_ARROW_DOWN "\xef\x85\xb5"	// U+f175
#define ICON_FA_LONG_ARROW_UP "\xef\x85\xb6"	// U+f176
#define ICON_FA_LONG_ARROW_LEFT "\xef\x85\xb7"	// U+f177
#define ICON_FA_LONG_ARROW_RIGHT "\xef\x85\xb8"	// U+f178
#define ICON_FA_APPLE "\xef\x85\xb9"	// U+f179
#define ICON_FA_WINDOWS "\xef\x85\xba"	// U+f17a
#define ICON_FA_ANDROID "\xef\x85\xbb"	// U+f17b
#define ICON_FA_LINUX "\xef\x85\xbc"	// U+f17c
#define ICON_FA_DRIBBBLE "\xef\x85\xbd"	// U+f17d
#define ICON_FA_SKYPE "\xef\x85\xbe"	// U+f17e
#define ICON_FA_FOURSQUARE "\xef\x86\x80"	// U+f180
#define ICON_FA_TRELLO "\xef\x86\x81"	// U+f181
#define ICON_FA_FEMALE "\xef\x86\x82"	// U+f182
#define ICON_FA_MALE "\xef\x86\x83"	// U+f183
#define ICON_FA_GRATIPAY "\xef\x86\x84"	// U+f184
#define ICON_FA_SUN_O "\xef\x86\x85"	// U+f185
#define ICON_FA_MOON_O "\xef\x86\x86"	// U+f186
#define ICON_FA_ARCHIVE "\xef\x86\x87"	// U+f187
#define ICON_FA_BUG "\xef\x86\x88"	// U+f188
#define ICON_FA_VK "\xef\x86\x89"	// U+f189
#define ICON_FA_WEIBO "\xef\x86\x8a"	// U+f18a
#define ICON_FA_RENREN "\xef\x86\x8b"	// U+f18b
#define ICON_FA_PAGELINES "\xef\x86\x8c"	// U+f18c
#define ICON_FA_STACK_EXCHANGE "\xef\x86\x8d"	// U+f18d
#define ICON_FA_ARROW_CIRCLE_O_RIGHT "\xef\x86\x8e"	// U+f18e
#define ICON_FA_ARROW_CIRCLE_O_LEFT "\xef\x86\x90"	// U+f190
#define ICON_FA_CARET_SQUARE_O_LEFT "\xef\x86\x91"	// U+f191
#define ICON_FA_DOT_CIRCLE_O "\xef\x86\x92"	// U+f192
#define ICON_FA_WHEELCHAIR "\xef\x86\x93"	// U+f193
#define ICON_FA_VIMEO_SQUARE "\xef\x86\x94"	// U+f194
#define ICON_FA_TRY "\xef\x86\x95"	// U+f195
#define ICON_FA_PLUS_SQUARE_O "\xef\x86\x96"	// U+f196
#define ICON_FA_SPACE_SHUTTLE "\xef\x86\x97"	// U+f197
#define ICON_FA_SLACK "\xef\x86\x98"	// U+f198
#define ICON_FA_ENVELOPE_SQUARE "\xef\x86\x99"	// U+f199
#define ICON_FA_WORDPRESS "\xef\x86\x9a"	// U+f19a
#define ICON_FA_OPENID "\xef\x86\x9b"	// U+f19b
#define ICON_FA_UNIVERSITY "\xef\x86\x9c"	// U+f19c
#define ICON_FA_GRADUATION_CAP "\xef\x86\x9d"	// U+f19d
#define ICON_FA_YAHOO "\xef\x86\x9e"	// U+f19e
#define ICON_FA_GOOGLE "\xef\x86\xa0"	// U+f1a0
#define ICON_FA_REDDIT "\xef\x86\xa1"	// U+f1a1
#define ICON_FA_REDDIT_SQUARE "\xef\x86\xa2"	// U+f1a2
#define ICON_FA_STUMBLEUPON_CIRCLE "\xef\x86\xa3"	// U+f1a3
#define ICON_FA_STUMBLEUPON "\xef\x86\xa4"	// U+f1a4
#define ICON_FA_DELICIOUS "\xef\x86\xa5"	// U+f1a5
#define ICON_FA_DIGG "\xef\x86\xa6"	// U+f1a6
#define ICON_FA_PIED_PIPER_PP "\xef\x86\xa7"	// U+f1a7
#define ICON_FA_PIED_PIPER_ALT "\xef\x86\xa8"	// U+f1a8
#define ICON_FA_DRUPAL "\xef\x86\xa9"	// U+f1a9
#define ICON_FA_JOOMLA "\xef\x86\xaa"	// U+f1aa
#define ICON_FA_LANGUAGE "\xef\x86\xab"	// U+f1ab
#define ICON_FA_FAX "\xef\x86\xac"	// U+f1ac
#define ICON_FA_BUILDING "\xef\x86\xad"	// U+f1ad
#define ICON_FA_CHILD "\xef\x86\xae"	// U+f1ae
#define ICON_FA_PAW "\xef\x86\xb0"	// U+f1b0
#define ICON_FA_SPOON "\xef\x86\xb1"	// U+f1b1
#define ICON_FA_CUBE "\xef\x86\xb2"	// U+f1b2
#define ICON_FA_CUBES "\xef\x86\xb3"	// U+f1b3
#define ICON_FA_BEHANCE "\xef\x86\xb4"	// U+f1b4
#define ICON_FA_BEHANCE_SQUARE "\xef\x86\xb5"	// U+f1b5
#define ICON_FA_STEAM "\xef\x86\xb6"	// U+f1b6
#define ICON_FA_STEAM_SQUARE "\xef\x86\xb7"	// U+f1b7
#define ICON_FA_RECYCLE "\xef\x86\xb8"	// U+f1b8
#define ICON_FA_CAR "\xef\x86\xb9"	// U+f1b9
#define ICON_FA_TAXI "\xef\x86\xba"	// U+f1ba
#define ICON_FA_TREE "\xef\x86\xbb"	// U+f1bb
#define ICON_FA_SPOTIFY "\xef\x86\xbc"	// U+f1bc
#define ICON_FA_DEVIANTART "\xef\x86\xbd"	// U+f1bd
#define ICON_FA_SOUNDCLOUD "\xef\x86\xbe"	// U+f1be
#define ICON_FA_DATABASE "\xef\x87\x80"	// U+f1c0
#define ICON_FA_FILE_PDF_O "\xef\x87\x81"	// U+f1c1
#define ICON_FA_FILE_WORD_O "\xef\x87\x82"	// U+f1c2
#define ICON_FA_FILE_EXCEL_O "\xef\x87\x83"	// U+f1c3
#define ICON_FA_FILE_POWERPOINT_O "\xef\x87\x84"	// U+f1c4
#define ICON_FA_FILE_IMAGE_O "\xef\x87\x85"	// U+f1c5
#define ICON_FA_FILE_ARCHIVE_O "\xef\x87\x86"	// U+f1c6
#define ICON_FA_FILE_AUDIO_O "\xef\x87\x87"	// U+f1c7
#define ICON_FA_FILE_VIDEO_O "\xef\x87\x88"	// U+f1c8
#define ICON_FA_FILE_CODE_O "\xef\x87\x89"	// U+f1c9
#define ICON_FA_VINE "\xef\x87\x8a"	// U+f1ca
#define ICON_FA_CODEPEN "\xef\x87\x8b"	// U+f1cb
#define ICON_FA_JSFIDDLE "\xef\x87\x8c"	// U+f1cc
#define ICON_FA_LIFE_RING "\xef\x87\x8d"	// U+f1cd
#define ICON_FA_CIRCLE_O_NOTCH "\xef\x87\x8e"	// U+f1ce
#define ICON_FA_REBEL "\xef\x87\x90"	// U+f1d0
#define ICON_FA_EMPIRE "\xef\x87\x91"	// U+f1d1
#define ICON_FA_GIT_SQUARE "\xef\x87\x92"	// U+f1d2
#define ICON_FA_GIT "\xef\x87\x93"	// U+f1d3
#define ICON_FA_HACKER_NEWS "\xef\x87\x94"	// U+f1d4
#define ICON_FA_TENCENT_WEIBO "\xef\x87\x95"	// U+f1d5
#define ICON_FA_QQ "\xef\x87\x96"	// U+f1d6
#define ICON_FA_WEIXIN "\xef\x87\x97"	// U+f1d7
#define ICON_FA_PAPER_PLANE "\xef\x87\x98"	// U+f1d8
#define ICON_FA_PAPER_PLANE_O "\xef\x87\x99"	// U+f1d9
#define ICON_FA_HISTORY "\xef\x87\x9a"	// U+f1da
#define ICON_FA_CIRCLE_THIN "\xef\x87\x9b"	// U+f1db
#define ICON_FA_HEADER "\xef\x87\x9c"	// U+f1dc
#define ICON_FA_PARAGRAPH "\xef\x87\x9d"	// U+f1dd
#define ICON_FA_SLIDERS "\xef\x87\x9e"	// U+f1de
#define ICON_FA_SHARE_ALT "\xef\x87\xa0"	// U+f1e0
#define ICON_FA_SHARE_ALT_SQUARE "\xef\x87\xa1"	// U+f1e1
#define ICON_FA_BOMB "\xef\x87\xa2"	// U+f1e2
#define ICON_FA_FUTBOL_O "\xef\x87\xa3"	// U+f1e3
#define ICON_FA_TTY "\xef\x87\xa4"	// U+f1e4
#define ICON_FA_BINOCULARS "\xef\x87\xa5"	// U+f1e5
#define ICON_FA_PLUG "\xef\x87\xa6"	// U+f1e6
#define ICON_FA_SLIDESHARE "\xef\x87\xa7"	// U+f1e7
#define ICON_FA_TWITCH "\xef\x87\xa8"	// U+f1e8
#define ICON_FA_YELP "\xef\x87\xa9"	// U+f1e9
#define ICON_FA_NEWSPAPER_O "\xef\x87\xaa"	// U+f1ea
#define ICON_FA_WIFI "\xef\x87\xab"	// U+f1eb
#define ICON_FA_CALCULATOR "\xef\x87\xac"	// U+f1ec
#define ICON_FA_PAYPAL "\xef\x87\xad"	// U+f1ed
#define ICON_FA_GOOGLE_WALLET "\xef\x87\xae"	// U+f1ee
#define ICON_FA_CC_VISA "\xef\x87\xb0"	// U+f1f0
#define ICON_FA_CC_MASTERCARD "\xef\x87\xb1"	// U+f1f1
#define ICON_FA_CC_DISCOVER "\xef\x87\xb2"	// U+f1f2
#define ICON_FA_CC_AMEX "\xef\x87\xb3"	// U+f1f3
#define ICON_FA_CC_PAYPAL "\xef\x87\xb4"	// U+f1f4
#define ICON_FA_CC_STRIPE "\xef\x87\xb5"	// U+f1f5
#define ICON_FA_BELL_SLASH "\xef\x87\xb6"	// U+f1f6
#define ICON_FA_BELL_SLASH_O "\xef\x87\xb7"	// U+f1f7
#define ICON_FA_TRASH "\xef\x87\xb8"	// U+f1f8
#define ICON_FA_COPYRIGHT "\xef\x87\xb9"	// U+f1f9
#define ICON_FA_AT "\xef\x87\xba"	// U+f1fa
#define ICON_FA_EYEDROPPER "\xef\x87\xbb"	// U+f1fb
#define ICON_FA_PAINT_BRUSH "\xef\x87\xbc"	// U+f1fc
#define ICON_FA_BIRTHDAY_CAKE "\xef\x87\xbd"	// U+f1fd
#define ICON_FA_AREA_CHART "\xef\x87\xbe"	// U+f1fe
#define ICON_FA_PIE_CHART "\xef\x88\x80"	// U+f200
#define ICON_FA_LINE_CHART "\xef\x88\x81"	// U+f201
#define ICON_FA_LASTFM "\xef\x88\x82"	// U+f202
#define ICON_FA_LASTFM_SQUARE "\xef\x88\x83"	// U+f203
#define ICON_FA_TOGGLE_OFF "\xef\x88\x84"	// U+f204
#define ICON_FA_TOGGLE_ON "\xef\x88\x85"	// U+f205
#define ICON_FA_BICYCLE "\xef\x88\x86"	// U+f206
#define ICON_FA_BUS "\xef\x88\x87"	// U+f207
#define ICON_FA_IOXHOST "\xef\x88\x88"	// U+f208
#define ICON_FA_ANGELLIST "\xef\x88\x89"	// U+f209
#define ICON_FA_CC "\xef\x88\x8a"	// U+f20a
#define ICON_FA_ILS "\xef\x88\x8b"	// U+f20b
#define ICON_FA_MEANPATH "\xef\x88\x8c"	// U+f20c
#define ICON_FA_BUYSELLADS "\xef\x88\x8d"	// U+f20d
#define ICON_FA_CONNECTDEVELOP "\xef\x88\x8e"	// U+f20e
#define ICON_FA_DASHCUBE "\xef\x88\x90"	// U+f210
#define ICON_FA_FORUMBEE "\xef\x88\x91"	// U+f211
#define ICON_FA_LEANPUB "\xef\x88\x92"	// U+f212
#define ICON_FA_SELLSY "\xef\x88\x93"	// U+f213
#define ICON_FA_SHIRTSINBULK "\xef\x88\x94"	// U+f214
#define ICON_FA_SIMPLYBUILT "\xef\x88\x95"	// U+f215
#define ICON_FA_SKYATLAS "\xef\x88\x96"	// U+f216
#define ICON_FA_CART_PLUS "\xef\x88\x97"	// U+f217
#define ICON_FA_CART_ARROW_DOWN "\xef\x88\x98"	// U+f218
#define ICON_FA_DIAMOND "\xef\x88\x99"	// U+f219
#define ICON_FA_SHIP "\xef\x88\x9a"	// U+f21a
#define ICON_FA_USER_SECRET "\xef\x88\x9b"	// U+f21b
#define ICON_FA_MOTORCYCLE "\xef\x88\x9c"	// U+f21c
#define ICON_FA_STREET_VIEW "\xef\x88\x9d"	// U+f21d
#define ICON_FA_HEARTBEAT "\xef\x88\x9e"	// U+f21e
#define ICON_FA_VENUS "\xef\x88\xa1"	// U+f221
#define ICON_FA_MARS "\xef\x88\xa2"	// U+f222
#define ICON_FA_MERCURY "\xef\x88\xa3"	// U+f223
#define ICON_FA_TRANSGENDER "\xef\x88\xa4"	// U+f224
#define ICON_FA_TRANSGENDER_ALT "\xef\x88\xa5"	// U+f225
#define ICON_FA_VENUS_DOUBLE "\xef\x88\xa6"	// U+f226
#define ICON_FA_MARS_DOUBLE "\xef\x88\xa7"	// U+f227
#define ICON_FA_VENUS_MARS "\xef\x88\xa8"	// U+f228
#define ICON_FA_MARS_STROKE "\xef\x88\xa9"	// U+f229
#define ICON_FA_MARS_STROKE_V "\xef\x88\xaa"	// U+f22a
#define ICON_FA_MARS_STROKE_H "\xef\x88\xab"	// U+f22b
#define ICON_FA_NEUTER "\xef\x88\xac"	// U+f22c
#define ICON_FA_GENDERLESS "\xef\x88\xad"	// U+f22d
#define ICON_FA_FACEBOOK_OFFICIAL "\xef\x88\xb0"	// U+f230
#define ICON_FA_PINTEREST_P "\xef\x88\xb1"	// U+f231
#define ICON_FA_WHATSAPP "\xef\x88\xb2"	// U+f232
#define ICON_FA_SERVER "\xef\x88\xb3"	// U+f233
#define ICON_FA_USER_PLUS "\xef\x88\xb4"	// U+f234
#define ICON_FA_USER_TIMES "\xef\x88\xb5"	// U+f235
#define ICON_FA_BED "\xef\x88\xb6"	// U+f236
#define ICON_FA_VIACOIN "\xef\x88\xb7"	// U+f237
#define ICON_FA_TRAIN "\xef\x88\xb8"	// U+f238
#define ICON_FA_SUBWAY "\xef\x88\xb9"	// U+f239
#define ICON_FA_MEDIUM "\xef\x88\xba"	// U+f23a
#define ICON_FA_Y_COMBINATOR "\xef\x88\xbb"	// U+f23b
#define ICON_FA_OPTIN_MONSTER "\xef\x88\xbc"	// U+f23c
#define ICON_FA_OPENCART "\xef\x88\xbd"	// U+f23d
#define ICON_FA_EXPEDITEDSSL "\xef\x88\xbe"	// U+f23e
#define ICON_FA_BATTERY_FULL "\xef\x89\x80"	// U+f240
#define ICON_FA_BATTERY_THREE_QUARTERS "\xef\x89\x81"	// U+f241
#define ICON_FA_BATTERY_HALF "\xef\x89\x82"	// U+f242
#define ICON_FA_BATTERY_QUARTER "\xef\x89\x83"	// U+f243
#define ICON_FA_BATTERY_EMPTY "\xef\x89\x84"	// U+f244
#define ICON_FA_MOUSE_POINTER "\xef\x89\x85"	// U+f245
#define ICON_FA_I_CURSOR "\xef\x89\x86"	// U+f246
#define ICON_FA_OBJECT_GROUP "\xef\x89\x87"	// U+f247
#define ICON_FA_OBJECT_UNGROUP "\xef\x89\x88"	// U+f248
#define ICON_FA_STICKY_NOTE "\xef\x89\x89"	// U+f249
#define ICON_FA_STICKY_NOTE_O "\xef\x89\x8a"	// U+f24a
#define ICON_FA_CC_JCB "\xef\x89\x8b"	// U+f24b
#define ICON_FA_CC_DINERS_CLUB "\xef\x89\x8c"	// U+f24c
#define ICON_FA_CLONE "\xef\x89\x8d"	// U+f24d
#define ICON_FA_BALANCE_SCALE "\xef\x89\x8e"	// U+f24e
#define ICON_FA_HOURGLASS_O "\xef\x89\x90"	// U+f250
#define ICON_FA_HOURGLASS_START "\xef\x89\x91"	// U+f251
#define ICON_FA_HOURGLASS_HALF "\xef\x89\x92"	// U+f252
#define ICON_FA_HOURGLASS_END "\xef\x89\x93"	// U+f253
#define ICON_FA_HOURGLASS "\xef\x89\x94"	// U+f254
#define ICON_FA_HAND_ROCK_O "\xef\x89\x95"	// U+f255
#define ICON_FA_HAND_PAPER_O "\xef\x89\x96"	// U+f256
#define ICON_FA_HAND_SCISSORS_O "\xef\x89\x97"	// U+f257
#define ICON_FA_HAND_LIZARD_O "\xef\x89\x98"	// U+f258
#define ICON_FA_HAND_SPOCK_O "\xef\x89\x99"	// U+f259
#define ICON_FA_HAND_POINTER_O "\xef\x89\x9a"	// U+f25a
#define ICON_FA_HAND_PEACE_O "\xef\x89\x9b"	// U+f25b
#define ICON_FA_TRADEMARK "\xef\x89\x9c"	// U+f25c
#define ICON_FA_REGISTERED "\xef\x89\x9d"	// U+f25d
#define ICON_FA_CREATIVE_COMMONS "\xef\x89\x9e"	// U+f25e
#define ICON_FA_GG "\xef\x89\xa0"	// U+f260
#define ICON_FA_GG_CIRCLE "\xef\x89\xa1"	// U+f261
#define ICON_FA_TRIPADVISOR "\xef\x89\xa2"	// U+f262
#define ICON_FA_ODNOKLASSNIKI "\xef\x89\xa3"	// U+f263
#define ICON_FA_ODNOKLASSNIKI_SQUARE "\xef\x89\xa4"	// U+f264
#define ICON_FA_GET_POCKET "\xef\x89\xa5"	// U+f265
#define ICON_FA_WIKIPEDIA_W "\xef\x89\xa6"	// U+f266
#define ICON_FA_SAFARI "\xef\x89\xa7"	// U+f267
#define ICON_FA_CHROME "\xef\x89\xa8"	// U+f268
#define ICON_FA_FIREFOX "\xef\x89\xa9"	// U+f269
#define ICON_FA_OPERA "\xef\x89\xaa"	// U+f26a
#define ICON_FA_INTERNET_EXPLORER "\xef\x89\xab"	// U+f26b
#define ICON_FA_TELEVISION "\xef\x89\xac"	// U+f26c
#define ICON_FA_CONTAO "\xef\x89\xad"	// U+f26d
#define ICON_FA_500PX "\xef\x89\xae"	// U+f26e
#define ICON_FA_AMAZON "\xef\x89\xb0"	// U+f270
#define ICON_FA_CALENDAR_PLUS_O "\xef\x89\xb1"	// U+f271
#define ICON_FA_CALENDAR_MINUS_O "\xef\x89\xb2"	// U+f272
#define ICON_FA_CALENDAR_TIMES_O "\xef\x89\xb3"	// U+f273
#define ICON_FA_CALENDAR_CHECK_O "\xef\x89\xb4"	// U+f274
#define ICON_FA_INDUSTRY "\xef\x89\xb5"	// U+f275
#define ICON_FA_MAP_PIN "\xef\x89\xb6"	// U+f276
#define ICON_FA_MAP_SIGNS "\xef\x89\xb7"	// U+f277
#define ICON_FA_MAP_O "\xef\x89\xb8"	// U+f278
#define ICON_FA_MAP "\xef\x89\xb9"	// U+f279
#define ICON_FA_COMMENTING "\xef\x89\xba"	// U+f27a
#define ICON_FA_COMMENTING_O "\xef\x89\xbb"	// U+f27b
#define ICON_FA_HOUZZ "\xef\x89\xbc"	// U+f27c
#define ICON_FA_VIMEO "\xef\x89\xbd"	// U+f27d
#define ICON_FA_BLACK_TIE "\xef\x89\xbe"	// U+f27e
#define ICON_FA_FONTICONS "\xef\x8a\x80"	// U+f280
#define ICON_FA_REDDIT_ALIEN "\xef\x8a\x81"	// U+f281
#define ICON_FA_EDGE "\xef\x8a\x82"	// U+f282
#define ICON_FA_CREDIT_CARD_ALT "\xef\x8a\x83"	// U+f283
#define ICON_FA_CODIEPIE "\xef\x8a\x84"	// U+f284
#define ICON_FA_MODX "\xef\x8a\x85"	// U+f285
#define ICON_FA_FORT_AWESOME "\xef\x8a\x86"	// U+f286
#define ICON_FA_USB "\xef\x8a\x87"	// U+f287
#define ICON_FA_PRODUCT_HUNT "\xef\x8a\x88"	// U+f288
#define ICON_FA_MIXCLOUD "\xef\x8a\x89"	// U+f289
#define ICON_FA_SCRIBD "\xef\x8a\x8a"	// U+f28a
#define ICON_FA_PAUSE_CIRCLE "\xef\x8a\x8b"	// U+f28b
#define ICON_FA_PAUSE_CIRCLE_O "\xef\x8a\x8c"	// U+f28c
#define ICON_FA_STOP_CIRCLE "\xef\x8a\x8d"	// U+f28d
#define ICON_FA_STOP_CIRCLE_O "\xef\x8a\x8e"	// U+f28e
#define ICON_FA_SHOPPING_BAG "\xef\x8a\x90"	// U+f290
#define ICON_FA_SHOPPING_BASKET "\xef\x8a\x91"	// U+f291
#define ICON_FA_HASHTAG "\xef\x8a\x92"	// U+f292
#define ICON_FA_BLUETOOTH "\xef\x8a\x93"	// U+f293
#define ICON_FA_BLUETOOTH_B "\xef\x8a\x94"	// U+f294
#define ICON_FA_PERCENT "\xef\x8a\x95"	// U+f295
#define ICON_FA_GITLAB "\xef\x8a\x96"	// U+f296
#define ICON_FA_WPBEGINNER "\xef\x8a\x97"	// U+f297
#define ICON_FA_WPFORMS "\xef\x8a\x98"	// U+f298
#define ICON_FA_ENVIRA "\xef\x8a\x99"	// U+f299
#define ICON_FA_UNIVERSAL_ACCESS "\xef\x8a\x9a"	// U+f29a
#define ICON_FA_WHEELCHAIR_ALT "\xef\x8a\x9b"	// U+f29b
#define ICON_FA_QUESTION_CIRCLE_O "\xef\x8a\x9c"	// U+f29c
#define ICON_FA_BLIND "\xef\x8a\x9d"	// U+f29d
#define ICON_FA_AUDIO_DESCRIPTION "\xef\x8a\x9e"	// U+f29e
#define ICON_FA_VOLUME_CONTROL_PHONE "\xef\x8a\xa0"	// U+f2a0
#define ICON_FA_BRAILLE "\xef\x8a\xa1"	// U+f2a1
#define ICON_FA_ASSISTIVE_LISTENING_SYSTEMS "\xef\x8a\xa2"	// U+f2a2
#define ICON_FA_AMERICAN_SIGN_LANGUAGE_INTERPRETING "\xef\x8a\xa3"	// U+f2a3
#define ICON_FA_DEAF "\xef\x8a\xa4"	// U+f2a4
#define ICON_FA_GLIDE "\xef\x8a\xa5"	// U+f2a5
#define ICON_FA_GLIDE_G "\xef\x8a\xa6"	// U+f2a6
#define ICON_FA_SIGN_LANGUAGE "\xef\x8a\xa7"	// U+f2a7
#define ICON_FA_LOW_VISION "\xef\x8a\xa8"	// U+f2a8
#define ICON_FA_VIADEO "\xef\x8a\xa9"	// U+f2a9
#define ICON_FA_VIADEO_SQUARE "\xef\x8a\xaa"	// U+f2aa
#define ICON_FA_SNAPCHAT "\xef\x8a\xab"	// U+f2ab
#define ICON_FA_SNAPCHAT_GHOST "\xef\x8a\xac"	// U+f2ac
#define ICON_FA_SNAPCHAT_SQUARE "\xef\x8a\xad"	// U+f2ad
#define ICON_FA_PIED_PIPER "\xef\x8a\xae"	// U+f2ae
#define ICON_FA_FIRST_ORDER "\xef\x8a\xb0"	// U+f2b0
#define ICON_FA_YOAST "\xef\x8a\xb1"	// U+f2b1
#define ICON_FA_THEMEISLE "\xef\x8a\xb2"	// U+f2b2
#define ICON_FA_GOOGLE_PLUS_OFFICIAL "\xef\x8a\xb3"	// U+f2b3
#define ICON_FA_FONT_AWESOME "\xef\x8a\xb4"	// U+f2b4
#define ICON_FA_HANDSHAKE_O "\xef\x8a\xb5"	// U+f2b5
#define ICON_FA_ENVELOPE_OPEN "\xef\x8a\xb6"	// U+f2b6
#define ICON_FA_ENVELOPE_OPEN_O "\xef\x8a\xb7"	// U+f2b7
#define ICON_FA_LINODE "\xef\x8a\xb8"	// U+f2b8
#define ICON_FA_ADDRESS_BOOK "\xef\x8a\xb9"	// U+f2b9
#define ICON_FA_ADDRESS_BOOK_O "\xef\x8a\xba"	// U+f2ba
#define ICON_FA_ADDRESS_CARD "\xef\x8a\xbb"	// U+f2bb
#define ICON_FA_ADDRESS_CARD_O "\xef\x8a\xbc"	// U+f2bc
#define ICON_FA_USER_CIRCLE "\xef\x8a\xbd"	// U+f2bd
#define ICON_FA_USER_CIRCLE_O "\xef\x8a\xbe"	// U+f2be
#define ICON_FA_USER_O "\xef\x8b\x80"	// U+f2c0
#define ICON_FA_ID_BADGE "\xef\x8b\x81"	// U+f2c1
#define ICON_FA_ID_CARD "\xef\x8b\x82"	// U+f2c2
#define ICON_FA_ID_CARD_O "\xef\x8b\x83"	// U+f2c3
#define ICON_FA_QUORA "\xef\x8b\x84"	// U+f2c4
#define ICON_FA_FREE_CODE_CAMP "\xef\x8b\x85"	// U+f2c5
#define ICON_FA_TELEGRAM "\xef\x8b\x86"	// U+f2c6
#define ICON_FA_THERMOMETER_FULL "\xef\x8b\x87"	// U+f2c7
#define ICON_FA_THERMOMETER_THREE_QUARTERS "\xef\x8b\x88"	// U+f2c8
#define ICON_FA_THERMOMETER_HALF "\xef\x8b\x89"	// U+f2c9
#define ICON_FA_THERMOMETER_QUARTER "\xef\x8b\x8a"	// U+f2ca
#define ICON_FA_THERMOMETER_EMPTY "\xef\x8b\x8b"	// U+f2cb
#define ICON_FA_SHOWER "\xef\x8b\x8c"	// U+f2cc
#define ICON_FA_BATH "\xef\x8b\x8d"	// U+f2cd
#define ICON_FA_PODCAST "\xef\x8b\x8e"	// U+f2ce
#define ICON_FA_WINDOW_MAXIMIZE "\xef\x8b\x90"	// U+f2d0
#define ICON_FA_WINDOW_MINIMIZE "\xef\x8b\x91"	// U+f2d1
#define ICON_FA_WINDOW_RESTORE "\xef\x8b\x92"	// U+f2d2
#define ICON_FA_WINDOW_CLOSE "\xef\x8b\x93"	// U+f2d3
#define ICON_FA_WINDOW_CLOSE_O "\xef\x8b\x94"	// U+f2d4
#define ICON_FA_BANDCAMP "\xef\x8b\x95"	// U+f2d5
#define ICON_FA_GRAV "\xef\x8b\x96"	// U+f2d6
#define ICON_FA_ETSY "\xef\x8b\x97"	// U+f2d7
#define ICON_FA_IMDB "\xef\x8b\x98"	// U+f2d8
#define ICON_FA_RAVELRY "\xef\x8b\x99"	// U+f2d9
#define ICON_FA_EERCAST "\xef\x8b\x9a"	// U+f2da
#define ICON_FA_MICROCHIP "\xef\x8b\x9b"	// U+f2db
#define ICON_FA_SNOWFLAKE_O "\xef\x8b\x9c"	// U+f2dc
#define ICON_FA_SUPERPOWERS "\xef\x8b\x9d"	// U+f2dd
#define ICON_FA_WPEXPLORER "\xef\x8b\x9e"	// U+f2de
#define ICON_FA_MEETUP "\xef\x8b\xa0"	// U+f2e0
```

`hack/render/render.cpp`:

```cpp
#include "render.hpp"

#include <utilities/math/math.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>

#include <SDK/interfaces/interfaces.hpp>
#include <SDK/ISurface.hpp>
#include <SDK/math/matrix.hpp>
#include <utilities/res.hpp>

#include <ranges>

#define BUFFER_SIZE 256

#ifdef SURFACE_RENDER
enum FontFlags
{
	FONTFLAG_NONE,
	FONTFLAG_ITALIC = 0x001,
	FONTFLAG_UNDERLINE = 0x002,
	FONTFLAG_STRIKEOUT = 0x004,
	FONTFLAG_SYMBOL = 0x008,
	FONTFLAG_ANTIALIAS = 0x010,
	FONTFLAG_GAUSSIANBLUR = 0x020,
	FONTFLAG_ROTARY = 0x040,
	FONTFLAG_DROPSHADOW = 0x080,
	FONTFLAG_ADDITIVE = 0x100,
	FONTFLAG_OUTLINE = 0x200,
	FONTFLAG_CUSTOM = 0x400,
	FONTFLAG_BITMAP = 0x800,
};

unsigned long SurfaceRender::__createFont(const char* fontName, const int size, const int weight, const unsigned long flags)
{
	auto result = memory::interfaces::surface->fontCreate();
	memory::interfaces::surface->setFontGlyph(result, fontName, size, weight, 0, 0, flags);
	return result;
}

void SurfaceRender::init()
{
	fonts::tahoma = __createFont("Tahoma", 14, 800, FONTFLAG_OUTLINE);
	fonts::franklinGothic = __createFont("Franklin Gothic", 10, 300, FONTFLAG_ANTIALIAS | FONTFLAG_DROPSHADOW);
	fonts::verdana = __createFont("Verdana", 12, 350, FONTFLAG_ANTIALIAS | FONTFLAG_DROPSHADOW);

	console::debug("render init success");
}

void SurfaceRender::drawLine(const int x, const int y, const int x2, const int y2, const Color& color)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawLine(x, y, x2, y2);
}

void SurfaceRender::drawLine(const Vec2& start, const Vec2& end, const Color& color)
{
	drawLine(static_cast<int>(start[Coord::X]), static_cast<int>(start[Coord::Y]),
		static_cast<int>(end[Coord::X]), static_cast<int>(end[Coord::Y]), color);
}

void SurfaceRender::drawRect(const int x, const int y, const int w, const int h, const Color& color)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawOutlinedRect(x, y, w, h);
}

void SurfaceRender::drawRect(const Vec2& start, const Vec2& end, const Color& color)
{
	drawRect(static_cast<int>(start[Coord::X]), static_cast<int>(start[Coord::Y]),
		static_cast<int>(end[Coord::X]), static_cast<int>(end[Coord::Y]), color);
}

void SurfaceRender::drawRectFilled(const int x, const int y, const int w, const int h, const Color& color)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawFilledRectangle(x, y, w, h);
}

void SurfaceRender::drawRoundedRect(const int x, const int y, const int w, const int h, const int radius, const int numberOfVertices, const Color& color)
{
	if (numberOfVertices < 2)
		return;

	auto roundV = std::make_unique<Vertex_t[]>(4 * numberOfVertices);

	for (int i = 0; i < 4; i++)
	{
		int _x = x + ((i < 2) ? (w - radius) : radius);
		int _y = y + ((i % 3) ? (h - radius) : radius);

		for (int j = 0; j < numberOfVertices; j++)
		{
			float rad = math::DEG2RAD((90.f * i) + (j / static_cast<float>(numberOfVertices - 1)) * 90.f);

			roundV[(i * numberOfVertices) + j] = Vertex_t{ Vec2{_x + radius * std::sin(rad), _y - radius * std::cos(rad)} };
		}
	}

	drawPolyLine(4 * numberOfVertices, roundV.get(), color);
}

void SurfaceRender::drawRoundedRectFilled(const int x, const int y, const int w, const int h, const int radius, const int numberOfVertices, const Color& color)
{
	if (numberOfVertices < 2)
		return;

	auto roundV = std::make_unique<Vertex_t[]>(4 * numberOfVertices);

	for (int i = 0; i < 4; i++)
	{
		int _x = x + ((i < 2) ? (w - radius) : radius);
		int _y = y + ((i % 3) ? (h - radius) : radius);

		for (int j = 0; j < numberOfVertices; j++)
		{
			float rad = math::DEG2RAD((90.f * i) + (j / static_cast<float>(numberOfVertices - 1)) * 90.f);

			roundV[(i * numberOfVertices) + j] = Vertex_t{ Vec2{_x + radius * std::sin(rad), _y - radius * std::cos(rad)} };
		}
	}

	drawPolyGon(4 * numberOfVertices, roundV.get(), color);
}

void SurfaceRender::drawCircle(const int x, const int y, const int radius, const int points, const Color& color)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawOutlinedCircle(x, y, radius, points);
}

void SurfaceRender::drawCircleFilled(const int x, const int y, const int radius, const int points, const Color& color)
{
	std::vector<Vertex_t> verts = {};

	float step = math::PI_2 / points;
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		verts.emplace_back(Vec2{ x + (radius * std::cos(angle)), y + (radius * std::sin(angle)) });
	}

	drawPolyGon(verts.size(), verts.data(), color);
}

void SurfaceRender::drawCircle3D(const Vec3& pos, const int radius, const int points, const Color& color)
{
	float step = math::PI_2 / points;
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		Vec3 worldEnd = Vec3{ radius * std::cos(angle + step) + pos[Coord::X], radius * std::sin(angle + step) + pos[Coord::Y], pos[Coord::Z] };

		if (Vec2 start, end; worldToScreen(worldStart, start) && worldToScreen(worldEnd, end))
			drawLine(start, end, color);
	}
}

void SurfaceRender::drawFilledCircle3D(const Vec3& pos, const int radius, const int points, const Color& color)
{
	Vec2 orignalW2S = {};
	if (!worldToScreen(pos, orignalW2S))
		return;

	float step = math::PI_2 / points;
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		Vec3 worldEnd = Vec3{ radius * std::cos(angle + step) + pos[Coord::X], radius * std::sin(angle + step) + pos[Coord::Y], pos[Coord::Z] };

		if (Vec2 start, end; worldToScreen(worldStart, start) && worldToScreen(worldEnd, end))
		{
			drawLine(start, end, color);
			drawTriangle(orignalW2S, start, end, Color(color.r(), color.g(), color.b(), color.a() / 4.0f));
		}
	}
}

void SurfaceRender::drawTriangle(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Color& color)
{
	std::array verts =
	{
		Vertex_t{ p1 },
		Vertex_t{ p2 },
		Vertex_t{ p3 }
	};

	drawPolyLine(verts.size(), verts.data(), color);
}

void SurfaceRender::drawTriangleFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Color& color)
{
	std::array verts =
	{
		Vertex_t{ p1 },
		Vertex_t{ p2 },
		Vertex_t{ p3 }
	};

	drawPolyGon(verts.size(), verts.data(), color);
}

void SurfaceRender::drawQuadFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, const Color& color)
{
	std::array verts =
	{
		Vertex_t{ p1 },
		Vertex_t{ p2 },
		Vertex_t{ p3 },
		Vertex_t{ p4 }
	};

	drawPolyGon(verts.size(), verts.data(), color);
}

void SurfaceRender::drawQuad(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, const Color& color)
{
	std::array verts =
	{
		Vertex_t{ p1 },
		Vertex_t{ p2 },
		Vertex_t{ p3 },
		Vertex_t{ p4 }
	};

	drawPolyLine(verts.size(), verts.data(), color);
}

void SurfaceRender::drawPolyLine(int* x, int* y, const int count, const Color& color)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawPolyLine(x, y, count);
}

void SurfaceRender::drawPolyLine(const int count, Vertex_t* verts, const Color& color)
{
	auto x = std::make_unique<int[]>(count);
	auto y = std::make_unique<int[]>(count);

	for (auto i : std::views::iota(0, count))
	{
		x[i] = static_cast<int>(verts[i].m_Position[Coord::X]);
		y[i] = static_cast<int>(verts[i].m_Position[Coord::Y]);
	}

	drawPolyLine(x.get(), y.get(), count, color);
}

void SurfaceRender::drawPolyGon(const int count, Vertex_t* verts, const Color& color, const bool clipped)
{
	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawTexturedPolygon(count, verts, clipped);
}

// https://www.unknowncheats.me/forum/counterstrike-global-offensive/189418-medical-attention-gradients-surface.html got fixed gradient blend from there
void SurfaceRender::drawGradient(const int x, const int y, const int w, const int h, const Color& first, const Color& second, bool horizontal, bool blend)
{
	auto gradient = [=](const Color& clr, bool reversed)
	{
		memory::interfaces::surface->drawSetColor(clr);
		memory::interfaces::surface->drawFilledFadeRect(
			x, y, w, h,
			reversed ? clr.aMultiplied() : 0,
			reversed ? 0 : clr.aMultiplied(),
			horizontal ? true : false);
	};

	auto blendColor = [](const Color& first, const Color& second, float t)
	{
		return Color(
			first.r() + t * (second.r() - first.r()),
			first.g() + t * (second.g() - first.g()),
			first.b() + t * (second.b() - first.b()),
			first.a() + t * (second.a() - first.a()));
	};

	if (blend)
		drawRectFilled(x, y, w, h, blendColor(first, second, 0.5f));
	gradient(first, true);
	gradient(second, false);
}

void SurfaceRender::drawGradient(const int x, const int y, const int w, const int h, const Color& first, const Color& second, const Color& third, bool horizontal, bool blend)
{
	auto gradient = [=](const Color& clr, bool reversed)
	{
		memory::interfaces::surface->drawSetColor(clr);
		memory::interfaces::surface->drawFilledFadeRect(
			x, y, w, h,
			reversed ? clr.aMultiplied() : 0,
			reversed ? 0 : clr.aMultiplied(),
			horizontal ? true : false);
	};

	auto blendColor = [](const Color& first, const Color& second, const Color& third, float t)
	{
		return Color(
			first.r() + t * (second.r() - third.r()),
			first.g() + t * (second.g() - third.g()),
			first.b() + t * (second.b() - third.b()),
			first.a() + t * (second.a() - third.a()));
	};

	if (blend)
		drawRectFilled(x, y, w, h, blendColor(first, second, third, 0.5f));
	gradient(first, true);
	gradient(second, false);
	gradient(third, false);
}

void SurfaceRender::text(const int x, const int y, const unsigned long font, const wchar_t* text, const bool centered, const Color& color)
{
	memory::interfaces::surface->drawTextFont(font);
	int width, height;

	memory::interfaces::surface->getTextSize(font, text, width, height);
	memory::interfaces::surface->setTextColor(color);
	memory::interfaces::surface->drawTextPos(centered ? (x - (width / 2)) : x, y);
	memory::interfaces::surface->drawRenderText(text, std::char_traits<wchar_t>::length(text));
}

void SurfaceRender::text(const int x, const int y, const unsigned long font, const std::string& text, const bool centered, const Color& color)
{
	if (text.empty())
		return;

	const auto converted = std::wstring(text.cbegin(), text.cend());
	int width, height;

	memory::interfaces::surface->drawTextFont(font);
	memory::interfaces::surface->getTextSize(font, converted.c_str(), width, height);
	memory::interfaces::surface->setTextColor(color);
	memory::interfaces::surface->drawTextPos(centered ? (x - (width / 2)) : x, y);
	memory::interfaces::surface->drawRenderText(converted.c_str(), converted.size());
}

void SurfaceRender::textf(const int x, const int y, const unsigned long font, const bool centered, const Color& color, const char* fmt, ...)
{
	if (!fmt)
		return;

	if (strlen(fmt) < 2)
		return;

	if (strlen(fmt) > BUFFER_SIZE)
		return;

	va_list args;

	std::array<char, BUFFER_SIZE> buf;

	std::fill(buf.begin(), buf.end(), 0);

	va_start(args, fmt);
	vsnprintf(buf.data(), sizeof(buf), fmt, args);
	va_end(args);

	text(x, y, font, buf.data(), centered, color);
}

int SurfaceRender::getTextSize(const unsigned long font, const std::string& text)
{
	std::wstring wtext(text.begin(), text.end());

	int width, height;
	memory::interfaces::surface->getTextSize(font, wtext.c_str(), width, height);

	return width;
}

Vec2 SurfaceRender::getTextSizeXY(const unsigned long font, const std::string& text)
{
	std::wstring wtext(text.begin(), text.end());

	int width, height;
	memory::interfaces::surface->getTextSize(font, wtext.c_str(), width, height);

	return Vec2{ (float)width, (float)height };
}

#include <gamememory/memory.hpp>
#include <cheats/game/globals.hpp>

bool SurfaceRender::worldToScreen(const Vec3& in, Vec2& out)
{
	auto screenMatrix = memory::viewMatrixAddr();

	float w = screenMatrix[3][0] * in[Coord::X] + screenMatrix[3][1] * in[Coord::Y] + screenMatrix[3][2] * in[Coord::Z] + screenMatrix[3][3];

	if (w < 0.001f)
		return false;

	Vec2 viewport = Vec2{ (float)globals::screenX, (float)globals::screenY };

	float inversed = 1.0f / w;
	out[Coord::X] = (viewport[Coord::X] / 2.0f) +
		(0.5f * ((screenMatrix[0][0] * in[Coord::X] + screenMatrix[0][1] * in[Coord::Y] + screenMatrix[0][2] * in[Coord::Z] + screenMatrix[0][3]) * inversed) * viewport[Coord::X] + 0.5f);
	out[Coord::Y] = (viewport[Coord::Y] / 2.0f) -
		(0.5f * ((screenMatrix[1][0] * in[Coord::X] + screenMatrix[1][1] * in[Coord::Y] + screenMatrix[1][2] * in[Coord::Z] + screenMatrix[1][3]) * inversed) * viewport[Coord::Y] + 0.5f);

	return true;
}

// cs engine lines are not anti aliased :(

void SurfaceRender::drawBox3D(const std::array<Vec3, 8>& box, const Color& color, bool filled)
{
	// transormed points to get pos.x/.y
	std::array<Vec2, 8> lines = {};

	for (size_t i = 0; auto& el : lines)
	{
		if (!worldToScreen(box.at(i), el))
			return;

#ifdef DEBUG_RENDER
		textf(points.at(i).x, points.at(i).y, fonts::tahoma, false, Color(100, 20, 100, 255), "[%i] posX: %0.2f, posY: %0.2f", i, points.at(i).x, points.at(i).y);
#endif // DEBUG_RENDER

		i++;
	}

	// anything with low alpha
	Color fill{ color.rMultiplied(), color.gMultiplied(), color.bMultiplied(), 30 };

	// first fill then draw lines
	if (filled)
	{
		// auto points = math::grahamScan(box.points); -> overload this function, I dont use surface for this
		// std::reverse(points.begin(), points.end()); -> don't use in surface.
		// drawPolyGon(points.size(), points.data(), fill);
	}
	for (size_t i = 1; i < 5; i++)
	{
		// BOTTOM 0,1,2,3
		drawLine(lines.at(i - 1), lines.at(i % 4), color);
		// TOP 4,5,6,7
		drawLine(lines.at(i + 3), lines.at(i % 4 + 4), color);
		// MISSING TOP
		drawLine(lines.at(i - 1), lines.at(i + 3), color);
	}
}

void SurfaceRender::initNewTexture(int& id, Color* RGBA, const int w, const int h)
{
	id = memory::interfaces::surface->createNewTextureID(true);
	if (id)
		memory::interfaces::surface->setTextureRGBA(id, RGBA, w, h);
	else
		HACK_THROW(std::format("setTextureRGBA failed to create new texture, ID was: {}", id));
}
void SurfaceRender::initNewTexture(int& id, unsigned char* RGBA, const int w, const int h)
{
	id = memory::interfaces::surface->createNewTextureID(true);
	if (id)
		memory::interfaces::surface->setTextureRGBA(id, RGBA, w, h);
	else
		HACK_THROW(std::format("setTextureRGBA failed to create new texture, ID was: {}", id));
}

void SurfaceRender::drawImage(const Resource& res, const int x, const int y, const int w, const int h, const Color& color)
{
	if (!memory::interfaces::surface->isTextureValid(res.getTextureID()))
		return;

	memory::interfaces::surface->drawSetColor(color);
	memory::interfaces::surface->drawSetTexture(res.getTextureID());
	memory::interfaces::surface->drawTexturedRect(x, y, x + w, y + h);
}

void SurfaceRender::drawProgressRing(const int x, const int y, float radius, const int points, float percent, const float thickness, const Color& color)
{
	// basically telling how precision will be
	float step = math::PI_2 / points;

	// limit angle, based on percentage passed
	float maxAngle = math::PI_2 * percent;

	for (float angle = 0.0f; angle < maxAngle; angle += step)
	{
		float ax = x + (radius * std::cos(angle)); // - (math::PI / 2.0f)) - will make clock like turning order
		float ay = y + (radius * std::sin(angle));

		float bx = x + (radius + thickness) * std::cos(angle);
		float by = y + (radius + thickness) * std::sin(angle);

		float cx = x + (radius * std::cos(angle + step));
		float cy = y + (radius * std::sin(angle + step));

		float dx = x + (radius + thickness) * std::cos(angle + step);
		float dy = y + (radius + thickness) * std::sin(angle + step);

		// aswell you can pass triangles with a bit higher precision in drawing

		// somethign brokey in this function, that's why this order
		drawQuadFilled(
			Vec2{ cx, cy },
			Vec2{ dx, dy },
			Vec2{ bx, by },
			Vec2{ ax, ay },
			color);
	}
}
#endif

/*


		IMGUI DRAWING

*/


#include "fonts/fontawesome.hpp"
#include "fonts/icon.hpp"

#include <gamememory/memory.hpp>

#include <ShlObj.h>
#include <filesystem>
#include <imgui_internal.h>
#include <imgui_freetype.h>
#include <deque>
#include <array>
#include <shared_mutex>

namespace ImRender
{
	std::deque<std::unique_ptr<drawing::Draw>> drawData{ };
}

void ImRender::init(ImGuiIO& io)
{
	if (CHAR fontsPath[MAX_PATH]; SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_FONTS, NULL, SHGFP_TYPE_CURRENT, fontsPath)))
	{
		const std::filesystem::path path{ fontsPath };
		const std::filesystem::path csFontsPath{ std::filesystem::current_path() / "platform" / "vgui" / "fonts" };

		ImFontConfig cfg;
		cfg.OversampleH = 2;
		cfg.OversampleV = 1;

		ImFontConfig iconsCfg;
		iconsCfg.MergeMode = true;
		iconsCfg.PixelSnapH = true;

		constexpr ImWchar iconRanges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };

		ImVector<ImWchar> ranges;
		ImFontGlyphRangesBuilder builder;
		constexpr ImWchar textRanges[] =
		{
			0x0020, 0x00FF, // Basic Latin
			0x0100, 0x024F, // Latin Extended-A + Latin Extended-B
			0x0600, 0x06FF, // Arabic
			0x0E00, 0x0E7F, // Thai
			0
		};
		builder.AddRanges(textRanges);
		builder.AddRanges(ImGui::GetIO().Fonts->GetGlyphRangesCyrillic());
		builder.BuildRanges(&ranges);

#define ADD_MERGED_ICONS io.Fonts->AddFontFromMemoryCompressedTTF(fontawesome_compressed_data, fontawesome_compressed_size, 15.0f, &iconsCfg, iconRanges);

		fonts::tahoma14 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ path / "tahoma.ttf" }.string().c_str(), 14.0f, &cfg, ranges.Data);
		ADD_MERGED_ICONS;
		fonts::tahoma20 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ path / "tahoma.ttf" }.string().c_str(), 20.0f, &cfg, ranges.Data);
		ADD_MERGED_ICONS;
		fonts::franklinGothic12 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ path / "framd.ttf" }.string().c_str(), 12.0f, &cfg, ranges.Data);
		ADD_MERGED_ICONS;
		fonts::franklinGothic30 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ path / "framd.ttf" }.string().c_str(), 30.0f, &cfg, ranges.Data);
		ADD_MERGED_ICONS;
		fonts::verdana12 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ path / "Verdana.ttf" }.string().c_str(), 12.0f, &cfg, ranges.Data);
		ADD_MERGED_ICONS;
		fonts::csgoTahoma15 = io.Fonts->AddFontFromFileTTF(std::filesystem::path{ csFontsPath / "tahoma.ttf" }.string().c_str(), 15.0f, &cfg, ranges.Data);
		ADD_MERGED_ICONS;

		io.Fonts->Build();

#undef ADD_MERGED_ICONS
	}
	else
		api::messageBox("Could not reach windows path", "Render init");

	console::debug("init imgui fonts success");
}

void ImRender::drawLine(const float x, const float y, const float x2, const float y2, const Color& color, const float thickness)
{
	drawData.emplace_back(std::make_unique<drawing::Line>(ImVec2{ x, y }, ImVec2{ x2, y2 }, Color::U32(color), thickness));
}

void ImRender::drawLine(const ImVec2& start, const ImVec2& end, const Color& color, const float thickness)
{
	drawData.emplace_back(std::make_unique<drawing::Line>(start, end, Color::U32(color), thickness));
}

void ImRender::drawRect(const float x, const float y, const float w, const float h, const Color& color, const ImDrawFlags flags, const float thickness)
{
	drawData.emplace_back(std::make_unique<drawing::Rectangle>(ImVec2{ x, y }, ImVec2{ x + w, y + h }, Color::U32(color), 0.0f, flags, thickness));
}

void ImRender::drawRectFilled(const float x, const float y, const float w, const float h, const Color& color, const ImDrawFlags flags)
{
	drawData.emplace_back(std::make_unique<drawing::RectangleFilled>(ImVec2{ x, y }, ImVec2{ x + w, y + h }, Color::U32(color), 0.0f, flags));
}

void ImRender::drawRoundedRect(const float x, const float y, const float w, const float h, const float rounding, const Color& color, const ImDrawFlags flags, const float thickness)
{
	drawData.emplace_back(std::make_unique<drawing::Rectangle>(ImVec2{ x, y }, ImVec2{ x + w, y + h }, Color::U32(color), rounding, flags, thickness));
}

void ImRender::drawRoundedRectFilled(const float x, const float y, const float w, const float h, const float rounding, const Color& color, const ImDrawFlags flags)
{
	drawData.emplace_back(std::make_unique<drawing::RectangleFilled>(ImVec2{ x, y }, ImVec2{ x + w, y + h }, Color::U32(color), rounding, flags));
}

void ImRender::drawRectFilledMultiColor(const float x, const float y, const float w, const float h,
	const Color& colUprLeft, const Color& colUprRight, const Color& colBotRight, const Color& colBotLeft)
{
	drawData.emplace_back(std::make_unique<drawing::RectangleMultiColor>(ImVec2{ x, y }, ImVec2{ x + w, y + h },
		Color::U32(colUprLeft), Color::U32(colUprRight), Color::U32(colBotRight), Color::U32(colBotLeft)));
}

void ImRender::drawTrianglePoly(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color)
{
	std::vector verts =
	{
		p1,
		p2,
		p3
	};

	drawPolyGon(verts, color);
}

static ImVec2 operator-(const ImVec2& v, float val)
{
	return ImVec2{ v.x - val, v.y - val };
}

static ImVec2 operator+(const ImVec2& v, float val)
{
	return ImVec2{ v.x + val, v.y + val };
}

void ImRender::drawBox3D(const Vec3& pos, const float width, const float height, const Color& color, bool outlined, const float thickness)
{
	// dividing to get a centre to world position
	float boxW = width / 2.0f;
	float boxH = height / 2.0f;

	outlined = false; // looks bad

	std::array box =
	{
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] - boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] - boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] - boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] - boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] + boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] + boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] + boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] + boxH, pos[Coord::Z] - boxW},
	};

	std::array<ImVec2, box.size()> lines = {};
	
	for (size_t i = 0; auto& el : lines)
	{
		if (!worldToScreen(box.at(i), el))
			return;

		i++;
	}

	Color outlineCol = Colors::Black.getColorEditAlpha(color.a());

	for (size_t i = 1; i < 5; i++)
	{
		// BOTTOM 0,1,2,3
		drawLine(lines.at(i - 1), lines.at(i % 4), color, thickness);
		if (outlined)
			drawLine(lines.at(i - 1) + 1.0f - thickness, lines.at(i % 4) + 1.0f - thickness, outlineCol);
		// TOP 4,5,6,7
		drawLine(lines.at(i + 3), lines.at(i % 4 + 4), color, thickness);
		if (outlined)
			drawLine(lines.at(i + 3) + 1.0f - thickness, lines.at(i % 4 + 4) + 1.0f - thickness, outlineCol);
		// MISSING TOP
		drawLine(lines.at(i - 1), lines.at(i + 3), color, thickness);
		if (outlined)
			drawLine(lines.at(i - 1) + 1.0f - thickness, lines.at(i + 3) + 1.0f - thickness, outlineCol);
	}
}

void ImRender::drawBox3DFilled(const Vec3& pos, const float width, const float height, const Color& color, const Color& filling, bool outlined, const float thickness)
{
	// dividing to get a centre to world position
	float boxW = width / 2.0f;
	float boxH = height / 2.0f;

	outlined = false; // looks bad

	std::array box =
	{
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] - boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] - boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] - boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] - boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] + boxH, pos[Coord::Z] - boxW},
		Vec3{ pos[Coord::X] - boxW, pos[Coord::Y] + boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] + boxH, pos[Coord::Z] + boxW },
		Vec3{ pos[Coord::X] + boxW, pos[Coord::Y] + boxH, pos[Coord::Z] - boxW},
	};

	// transormed points to get pos.x/.y
	std::array<ImVec2, box.size()> lines = {};

	for (size_t i = 0; auto & el : lines)
	{
		if (!worldToScreen(box.at(i), el))
			return;

		i++;
	}

	auto maybeScanned = math::grahamScan(lines);
	if (!maybeScanned.has_value())
		return;

	auto points = maybeScanned.value();

	std::reverse(points.begin(), points.end());
	drawPolyGon(points, filling);

	Color outlineCol = Colors::Black.getColorEditAlpha(color.a());

	for (size_t i = 1; i < 5; i++)
	{
		// BOTTOM 0,1,2,3
		drawLine(lines.at(i - 1), lines.at(i % 4), color, thickness);
		if (outlined)
			drawLine(lines.at(i - 1) + 1.0f - thickness, lines.at(i % 4) + 1.0f - thickness, outlineCol);
		// TOP 4,5,6,7
		drawLine(lines.at(i + 3), lines.at(i % 4 + 4), color, thickness);
		if (outlined)
			drawLine(lines.at(i + 3) + 1.0f - thickness, lines.at(i % 4 + 4) + 1.0f - thickness, outlineCol);
		// MISSING TOP
		drawLine(lines.at(i - 1), lines.at(i + 3), color, thickness);
		if (outlined)
			drawLine(lines.at(i - 1) + 1.0f - thickness, lines.at(i + 3) + 1.0f - thickness, outlineCol);
	}
}

void ImRender::drawCircle(const float x, const float y, const float radius, const int points, const Color& color, const float thickness)
{
	drawData.emplace_back(std::make_unique<drawing::Circle>(ImVec2{ x, y }, radius, points, Color::U32(color), thickness));
}

void ImRender::drawCircleFilled(const float x, const float y, const float radius, const int points, const Color& color)
{
	drawData.emplace_back(std::make_unique<drawing::CircleFilled>(ImVec2{ x, y }, radius, points, Color::U32(color)));
}

void ImRender::drawCircle3D(const Vec3& pos, const float radius, const int points, const Color& color, const ImDrawFlags flags, const float thickness)
{
	float step = math::PI_2 / points;

	std::vector<ImVec2> pointsVec = {};
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		if (ImVec2 screenStart; worldToScreen(worldStart, screenStart))
			pointsVec.push_back(screenStart);
	}

	drawPolyLine(pointsVec, color, flags, thickness);
}

#include <SDK/IEngineTrace.hpp>
#include <SDK/vars.hpp>

void ImRender::drawCircle3DTraced(const Vec3& pos, const float radius, const int points, void* skip, const Color& color, const ImDrawFlags flags, const float thickness)
{
	float step = math::PI_2 / points;

	std::vector<ImVec2> pointsVec = {};
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };

		Trace_t trace;
		TraceFilter filter;
		filter.m_skip = skip;

		memory::interfaces::trace->traceRay({ pos, worldStart }, MASK_SHOT_BRUSHONLY, &filter, &trace);

		if (ImVec2 screenStart; worldToScreen(trace.m_end, screenStart))
			pointsVec.push_back(screenStart);
	}

	drawPolyLine(pointsVec, color, flags, thickness);
}

void ImRender::drawCircle3DFilled(const Vec3& pos, const float radius, const int points, const Color& color, const Color& outline, const ImDrawFlags flags, const float thickness)
{
	float step = math::PI_2 / points;

	std::vector<ImVec2> pointsVec = {};
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		if (ImVec2 screenStart; worldToScreen(worldStart, screenStart))
			pointsVec.push_back(screenStart);
	}

	drawPolyGon(pointsVec, color);
	drawPolyLine(pointsVec, color, flags, thickness);
}

void ImRender::drawCircle3DFilledTraced(const Vec3& pos, const float radius, const int points, void* skip, const Color& color, const Color& outline, const ImDrawFlags flags, const float thickness)
{
	float step = math::PI *2.0f / points;

	std::vector<ImVec2> pointsVec = {};
	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };

		Trace_t trace;
		TraceFilter filter;
		filter.m_skip = skip;

		memory::interfaces::trace->traceRay({ pos, worldStart }, MASK_SHOT_BRUSHONLY, &filter, &trace);

		if (ImVec2 screenStart; worldToScreen(trace.m_end, screenStart))
			pointsVec.push_back(screenStart);
	}

	drawPolyGon(pointsVec, color);
	drawPolyLine(pointsVec, color, flags, thickness);
}

void ImRender::drawTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color, const float thickness)
{
	drawData.emplace_back(std::make_unique<drawing::Triangle>(p1, p2, p3, Color::U32(color), thickness));
}

void ImRender::drawTriangle(const float x, const float y, const float w, const float h, const Color& color, const float angle, const float thickness)
{
	float radian = math::DEG2RAD(angle);
	float radian90 = math::DEG2RAD(angle + 90);

	const ImVec2 p1 = ImVec2{ (w / 2.0f) * std::cos(radian90) + x, (w / 2.0f) * std::sin(radian90) + y };
	const ImVec2 p2 = ImVec2{ (-w / 2.0f) * std::cos(radian90) + x, (-w / 2.0f) * std::sin(radian90) + y };
	const ImVec2 p3 = ImVec2{ h * std::cos(radian) + x, h * std::sin(radian) + y };

	drawData.emplace_back(std::make_unique<drawing::Triangle>(p1, p2, p3, Color::U32(color), thickness));
}

void ImRender::drawTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color)
{
	drawData.emplace_back(std::make_unique<drawing::TriangleFilled>(p1, p2, p3, Color::U32(color)));
}

void ImRender::drawTriangleFilled(const float x, const float y, const float w, const float h, const float angle, const Color& color)
{
	float radian = math::DEG2RAD(angle);
	float radian90 = math::DEG2RAD(angle + 90);

	const ImVec2 p1 = ImVec2{ (w / 2.0f) * std::cos(radian90) + x, (w / 2.0f) * std::sin(radian90) + y };
	const ImVec2 p2 = ImVec2{ (-w / 2.0f) * std::cos(radian90) + x, (-w / 2.0f) * std::sin(radian90) + y };
	const ImVec2 p3 = ImVec2{ h * std::cos(radian) + x, h * std::sin(radian) + y };

	drawData.emplace_back(std::make_unique<drawing::TriangleFilled>(p1, p2, p3, Color::U32(color)));
}

void ImRender::drawQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const Color& color, const float thickness)
{
	drawData.emplace_back(std::make_unique<drawing::Quad>(p1, p2, p3, p4, Color::U32(color), thickness));
}

void ImRender::drawQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const Color& color)
{
	drawData.emplace_back(std::make_unique<drawing::QuadFilled>(p1, p2, p3, p4, Color::U32(color)));
}

void ImRender::drawQuadFilledMultiColor(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4,
	const Color& colUprLeft, const Color& colUprRight, const Color& colBotRight, const Color& colBotLeft)
{
	drawData.emplace_back(std::make_unique<drawing::QuadMultiColor>(p1, p2, p3, p4,
		Color::U32(colUprLeft), Color::U32(colUprRight), Color::U32(colBotRight), Color::U32(colBotLeft)));
}

void ImRender::drawPolyLine(const std::vector<ImVec2>& verts, const Color& color, const ImDrawFlags flags, const float thickness)
{
	drawData.emplace_back(std::make_unique<drawing::Polyline>(verts, Color::U32(color), flags, thickness));
}

void ImRender::drawPolyGon(const std::vector<ImVec2>& verts, const Color& color)
{
	drawData.emplace_back(std::make_unique<drawing::Polygon>(verts, Color::U32(color)));
}

void ImRender::drawPolyGonMultiColor(const std::vector<ImVec2>& verts, const std::vector<ImU32>& colors)
{
	drawData.emplace_back(std::make_unique<drawing::PolygonMultiColor>(verts, colors));
}

void ImRender::drawGradient(const float x, const float y, const float w, const float h, const Color& first, const Color& second, bool horizontal)
{
	drawData.emplace_back(std::make_unique<drawing::RectangleGradient>(ImVec2{ x, y }, ImVec2{ x + w, y + h }, Color::U32(first), Color::U32(second), horizontal));
}

void ImRender::text(const float x, const float y, ImFont* font, const std::string& text, const bool centered, const Color& color, const bool dropShadow)
{
	drawData.emplace_back(std::make_unique<drawing::Text>(font, ImVec2{ x, y }, Color::U32(color), text, dropShadow, centered));
}

void ImRender::text(const float x, const float y, ImFont* font, const std::wstring& text, const bool centered, const Color& color, const bool dropShadow)
{
	std::string _text(text.length(), 0);
	// because warning
	std::transform(text.begin(), text.end(), _text.begin(), [](wchar_t wc)
		{
			return static_cast<char>(wc);
		});

	drawData.emplace_back(std::make_unique<drawing::Text>(font, ImVec2{ x, y }, Color::U32(color), _text, dropShadow, centered));
}

void ImRender::text(const float x, const float y, const float fontSize, ImFont* font, const std::string& text, const bool centered, const Color& color, const bool dropShadow)
{
	drawData.emplace_back(std::make_unique<drawing::TextSize>(fontSize, font, ImVec2{ x, y }, Color::U32(color), text, dropShadow, centered));
}

void ImRender::textf(const float x, const float y, ImFont* font, const bool centered, const Color& color, const bool dropShadow, const char* fmt, ...)
{
	if (!fmt)
		return;

	if (strlen(fmt) < 2)
		return;

	if (strlen(fmt) > BUFFER_SIZE)
		return;

	va_list args;

	std::array<char, BUFFER_SIZE> buf;

	std::fill(buf.begin(), buf.end(), 0);

	va_start(args, fmt);
	vsnprintf(buf.data(), sizeof(buf), fmt, args);
	va_end(args);

	text(x, y, font, buf.data(), centered, color, dropShadow);
}

ImVec2 ImRender::getTextSize(ImFont* font, float size, const std::string& text, float wrap, float wrapMax)
{
	auto ret = font->CalcTextSizeA(size, wrapMax, wrap, text.c_str());
	return ret;
}

bool ImRender::worldToScreen(const Vec3& in, ImVec2& out)
{
	auto screenMatrix = memory::viewMatrixAddr();

	float w = screenMatrix[3][0] * in[Coord::X] + screenMatrix[3][1] * in[Coord::Y] + screenMatrix[3][2] * in[Coord::Z] + screenMatrix[3][3];

	if (w < 0.001f)
		return false;

	ImVec2 viewport = ImGui::GetIO().DisplaySize;

	float inversed = 1.0f / w;
	out.x = (viewport.x / 2.0f) +
		(0.5f * ((screenMatrix[0][0] * in[Coord::X] + screenMatrix[0][1] * in[Coord::Y] + screenMatrix[0][2] * in[Coord::Z] + screenMatrix[0][3]) * inversed) * viewport.x + 0.5f);
	out.y = (viewport.y / 2.0f) -
		(0.5f * ((screenMatrix[1][0] * in[Coord::X] + screenMatrix[1][1] * in[Coord::Y] + screenMatrix[1][2] * in[Coord::Z] + screenMatrix[1][3]) * inversed) * viewport.y + 0.5f);

	return true;
}

void ImRender::drawArc(const float x, const float y, float radius, const int points, float angleMin, float angleMax, const float thickness, const Color& color, const ImDrawFlags flags)
{
	drawData.emplace_back(std::make_unique<drawing::Arc>(ImVec2{ x, y }, radius, math::DEG2RAD(angleMin), math::DEG2RAD(angleMax), points, Color::U32(color), flags, thickness));
}

void ImRender::drawProgressRing(const float x, const float y, const float radius, const int points, const float angleMin, float percent, const float thickness, const Color& color, const ImDrawFlags flags)
{
	float maxAngle = math::RAD2DEG(math::PI *2.0f * percent) + angleMin;
	drawData.emplace_back(std::make_unique<drawing::Arc>(ImVec2{ x, y }, radius, math::DEG2RAD(angleMin), math::DEG2RAD(maxAngle), points, Color::U32(color), flags, thickness));
}

void ImRender::drawSphere(const Vec3& pos, float radius, float angleSphere, const Color& color)
{
	std::vector<ImVec2> verts = {};

	float step = (1.0f / radius) + math::DEG2RAD(angleSphere);
	for (float angle = 0.0f; angle < math::PI; angle += step)
	{
		verts.clear();
		for (float angleBetween = 0.0f; angleBetween < math::PI_2; angleBetween += step)
		{
			Vec3 worldStart = Vec3
			{
				radius * std::sin(angle) * std::cos(angleBetween) + pos[Coord::X],
				radius * std::sin(angle) * std::sin(angleBetween) + pos[Coord::Y],
				radius * std::cos(angle) + pos[Coord::Z]
			};

			if (ImVec2 screenStart; worldToScreen(worldStart, screenStart))
				verts.push_back(screenStart);
		}

		if (verts.empty())
			continue;

		drawPolyLine(verts, color);
	}
}

void ImRender::drawCone(const Vec3& pos, const float radius, const int points, const float size, const Color& colCircle, const Color& colCone, const ImDrawFlags flags, const float thickness)
{
	ImVec2 orignalW2S = {};
	if (!worldToScreen(pos, orignalW2S))
		return;

	float step = math::PI_2 / points;

	for (float angle = 0.0f; angle < math::PI_2; angle += step)
	{
		Vec3 worldStart = Vec3{ radius * std::cos(angle) + pos[Coord::X], radius * std::sin(angle) + pos[Coord::Y], pos[Coord::Z] };
		Vec3 worldEnd = Vec3{ radius * std::cos(angle + step) + pos[Coord::X], radius * std::sin(angle + step) + pos[Coord::Y], pos[Coord::Z] };

		if (ImVec2 start, end; worldToScreen(worldStart, start) && worldToScreen(worldEnd, end))
		{
			drawLine(start, end, colCircle);
			// using surface because it does not add outlines
			drawTrianglePoly({ orignalW2S.x, orignalW2S.y + size /*- std::abs(size)*/ }, start, end, colCone);
		}
	}
}

void ImRender::drawImage(const ImTextureID img, const ImVec2& pos, const ImVec2& size, const Color& color, const float rounding, const ImDrawFlags flags)
{
	drawData.emplace_back(std::make_unique<drawing::Image>(img, pos, ImVec2{ pos.x + size.x, pos.y + size.y }, ImVec2{ 0.0f, 0.0f }, ImVec2{ 1.0f, 1.0f }, Color::U32(color), rounding, flags));
}

namespace ImRender
{
	std::deque<std::unique_ptr<drawing::Draw>> drawDataSafe{ };
	std::shared_mutex mutexRender{ };
}

void ImRender::beginThink()
{
	if (!drawData.empty())
		drawData.clear();
}

void ImRender::endThink()
{
	std::unique_lock lock{ mutexRender };
	drawData.swap(drawDataSafe);
}

void ImRender::present(ImDrawList* draw)
{
	std::unique_lock lock{ mutexRender };

	if (drawDataSafe.empty())
		return;

	for (const auto& data : drawDataSafe)
		data->draw(draw);
}

#undef BUFFER_SIZE
```

`hack/render/render.hpp`:

```hpp
#pragma once

#include "Color.hpp"
#include "BBox.hpp"

#include <string>
#include <SDK/math/Vector.hpp>

#define SURFACE_RENDER

class Color;
class Resource;

#ifdef SURFACE_RENDER
struct Vertex_t;

// rendering with game's engine
namespace SurfaceRender
{
	namespace fonts
	{
		inline unsigned long tahoma;
		inline unsigned long franklinGothic;
		inline unsigned long verdana;
	}

	void init();

	[[nodiscard]] unsigned long  __createFont(const char* fontName, const int size, const int weight, const unsigned long flags);

	void drawLine(const int x, const int y, const int x2, const int y2, const Color& color);
	void drawLine(const Vec2& start, const Vec2& end, const Color& color);
	void drawRect(const int x, const int y, const int w, const int h, const Color& color);
	void drawRect(const Vec2& start, const Vec2& end, const Color& color);
	void drawRectFilled(const int x, const int y, const int w, const int h, const Color& color);
	// https://www.unknowncheats.me/forum/counterstrike-global-offensive/181578-draw-rounded-box-static-dynamic.html
	void drawRoundedRect(const int x, const int y, const int w, const int h, const int radius, const int numberOfVertices, const Color& color);
	void drawRoundedRectFilled(const int x, const int y, const int w, const int h, const int radius, const int numberOfVertices, const Color& color);
	void drawCircle(const int x, const int y, const int radius, const int points, const Color& color);
	void drawCircleFilled(const int x, const int y, const int radius, const int points, const Color& color);
	void drawCircle3D(const Vec3& pos, const int radius, const int points, const Color& color);
	void drawFilledCircle3D(const Vec3& pos, const int radius, const int points, const Color& color);
	void drawTriangle(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Color& color);
	void drawTriangleFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Color& color);
	void drawQuad(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, const Color& color);
	void drawQuadFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, const Color& color);
	void drawPolyLine(int* x, int* y, const int count, const Color& color);
	void drawPolyLine(const int count, Vertex_t* verts, const Color& color);
	void drawPolyGon(const int count, Vertex_t* verts, const Color& color, const bool clipped = true);
	void drawGradient(const int x, const int y, const int w, const int h, const Color& first, const Color& second, bool horizontal, bool blend = true);
	void drawGradient(const int x, const int y, const int w, const int h, const Color& first, const Color& second, const Color& third, bool horizontal, bool blend = true);
	void text(const int x, const int y, const unsigned long font, const wchar_t* text, const bool centered, const Color& color);
	void text(const int x, const int y, const unsigned long font, const std::string& text, const bool centered, const Color& color);
	void textf(const int x, const int y, const unsigned long font, const bool centered, const Color& color, const char* fmt, ...);
	[[deprecated("You should only read comments from there, better results are with ImGuiRender class")]]
	void drawBox3D(const std::array<Vec3, 8>& box, const Color& color, bool filled = false);
	// percent should be passed in 0.0-1.0 range, credits for helping Carlos1216
	void drawProgressRing(const int x, const int y, float radius, const int points, float percent, const float thickness, const Color& color);
	// width only
	[[nodiscard]] int getTextSize(const unsigned long font, const std::string& text);
	// width and height
	[[nodiscard]] Vec2 getTextSizeXY(const unsigned long font, const std::string& text);
	[[nodiscard]] bool worldToScreen(const Vec3& in, Vec2& out);
	void initNewTexture(int& id, Color* RGBA, const int w, const int h);
	void initNewTexture(int& id, unsigned char* RGBA, const int w, const int h);
	void drawImage(const Resource& res, const int x, const int y, const int w, const int h, const Color& color);
};

#endif

#include <imgui.h>
#include "structures.hpp"

// rendering supported by dear ImGui, few changes and new functions comparing to surface draw
// thread safe idea - full credits to qo0' as I couldn't really rebuild manually w2s with any success removing this weird stutter
namespace ImRender
{
	namespace fonts
	{
		inline ImFont* tahoma14;
		inline ImFont* tahoma20;
		inline ImFont* franklinGothic30;
		inline ImFont* franklinGothic12;
		inline ImFont* verdana12;
		inline ImFont* csgoTahoma15;
	}

	void init(ImGuiIO& io);

	void drawLine(const float x, const float y, const float x2, const float y2, const Color& color, const float thickness = 1.0f);
	void drawLine(const ImVec2& start, const ImVec2& end, const Color& color, const float thickness = 1.0f);
	void drawRect(const float x, const float y, const float w, const float h, const Color& color, const ImDrawFlags flags = 0, const float thickness = 1.0f);
	void drawRectFilled(const float x, const float y, const float w, const float h, const Color& color, const ImDrawFlags flags = 0);
	void drawRoundedRect(const float x, const float y, const float w, const float h, const float rounding, const Color& color, const ImDrawFlags flags = 0, const float thickness = 1.0f);
	void drawRoundedRectFilled(const float x, const float y, const float w, const float h, const float rounding, const Color& color, const ImDrawFlags flags = 0);
	void drawRectFilledMultiColor(const float x, const float y, const float w, const float h,
		const Color& colUprLeft, const Color& colUprRight, const Color& colBotRight, const Color& colBotLeft);
	void drawCircle(const float x, const float y, const float radius, const int points, const Color& color, const float thickness = 1.0f);
	void drawCircleFilled(const float x, const float y, const float radius, const int points, const Color& color);
	void drawCircle3D(const Vec3& pos, const float radius, const int points, const Color& color, const ImDrawFlags flags = 1, const float thickness = 1.0f);
	void drawCircle3DTraced(const Vec3& pos, const float radius, const int points, void* skip, const Color& outline, const ImDrawFlags flags = 1, const float thickness = 1.0f);
	void drawCircle3DFilled(const Vec3& pos, const float radius, const int points, const Color& color, const Color& outline, const ImDrawFlags flags = 1, const float thickness = 1.0f);
	void drawCircle3DFilledTraced(const Vec3& pos, const float radius, const int points, void* skip, const Color& color, const Color& outline, const ImDrawFlags flags = 1, const float thickness = 1.0f);
	void drawTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color, const float thickness = 1.0f);
	void drawTriangle(const float x, const float y, const float w, const float h, const Color& color, const float angle, const float thickness = 1.0f);
	void drawTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color);
	void drawTriangleFilled(const float x, const float y, const float w, const float h, const float angle, const Color& color);
	void drawTrianglePoly(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const Color& color);
	void drawQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const Color& color, const float thickness = 1.0f);
	void drawQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const Color& color);
	void drawQuadFilledMultiColor(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4,
		const Color& colUprLeft, const Color& colUprRight, const Color& colBotRight, const Color& colBotLeft);
	void drawPolyLine(const std::vector<ImVec2>& verts, const Color& color, const ImDrawFlags flags = 0, const float thickness = 1.0f);
	void drawPolyGon(const std::vector<ImVec2>& verts, const Color& color);
	// for performace and reduce looping pass by using U32()
	void drawPolyGonMultiColor(const std::vector<ImVec2>& verts, const std::vector<ImU32>& colors);
	void drawGradient(const float x, const float y, const float w, const float h, const Color& first, const Color& second, bool horizontal);
	void text(const float x, const float y, ImFont* font, const std::string& text, const bool centered, const Color& color, const bool dropShadow = true);
	void text(const float x, const float y, const float fontSize, ImFont* font, const std::string& text, const bool centered, const Color& color, const bool dropShadow = true);
	void text(const float x, const float y, ImFont* font, const std::wstring& text, const bool centered, const Color& color, const bool dropShadow = true);
	void textf(const float x, const float y, ImFont* font, const bool centered, const Color& color, const bool dropShadow, const char* fmt, ...);
	void drawBox3D(const Vec3& pos, const float width, const float height, const Color& color, bool outlined = false, const float thickness = 2.0f);
	void drawBox3DFilled(const Vec3& pos, const float width, const float height, const Color& color, const Color& filling, bool outlined = false, const float thickness = 2.0f);
	void drawCone(const Vec3& pos, const float radius, const int points, const float size, const Color& colCircle, const Color& colCone, const ImDrawFlags flags = 1, const float thickness = 1.0f);
	void drawArc(const float x, const float y, float radius, const int points, float angleMin, float angleMax, const float thickness, const Color& color, const ImDrawFlags flags = 0);
	void drawProgressRing(const float x, const float y, const float radius, const int points, const float angleMin, float percent, const float thickness, const Color& color, const ImDrawFlags flags = 0);
	void drawSphere(const Vec3& pos, float radius, float angleSphere, const Color& color);
	void drawImage(const ImTextureID img, const ImVec2& pos, const ImVec2& size, const Color& color, const float rounding = 0.0f, const ImDrawFlags flags = 0);
	[[nodiscard]] ImVec2 getTextSize(ImFont* font, float size, const std::string& text, float wrap = 0.0f, float wrapMax = std::numeric_limits<float>::max());
	[[nodiscard]] bool worldToScreen(const Vec3& in, ImVec2& out);

	void beginThink();
	void endThink();
	void present(ImDrawList* draw);
};
```

`hack/render/structures.cpp`:

```cpp
#include "structures.hpp"

#include <imgui.h>
#include <SDK/math/Vector.hpp>
#include <render/Color.hpp>
#include <deps/ImGui/extraDraw.hpp>

#include <numeric>

using namespace drawing;

void Line::draw(ImDrawList* draw) const
{
	draw->AddLine(m_start, m_end, m_color, m_thickness);
}

void Rectangle::draw(ImDrawList* draw) const
{
	draw->AddRect(m_min, m_max, m_color, m_rounding, m_flags, m_thickness);
}

void RectangleFilled::draw(ImDrawList* draw) const
{
	draw->AddRectFilled(m_min, m_max, m_color, m_rounding, m_flags);
}

void RectangleGradient::draw(ImDrawList* draw) const
{
	if (!m_horizontal)
		draw->AddRectFilledMultiColor(m_min, m_max, m_color1, m_color2, m_color2, m_color1);
	else
		draw->AddRectFilledMultiColor(m_min, m_max, m_color1, m_color1, m_color2, m_color2);
}

void RectangleMultiColor::draw(ImDrawList* draw) const
{
	ImGui::ExtraDrawlist::AddRectFilledMultiColor(draw, m_min, m_max, m_color1, m_color2, m_color3, m_color4, m_rounding);
}

void Circle::draw(ImDrawList* draw) const
{
	draw->AddCircle(m_centre, m_radius, m_color, m_segments, m_thickness);
}

void CircleFilled::draw(ImDrawList* draw) const
{
	draw->AddCircleFilled(m_centre, m_radius, m_color, m_segments);
}

void Triangle::draw(ImDrawList* draw) const
{
	draw->AddTriangle(m_p1, m_p2, m_p3, m_color, m_thickness);
}

void TriangleFilled::draw(ImDrawList* draw) const
{
	draw->AddTriangleFilled(m_p1, m_p2, m_p3, m_color);
}

void TriangleMultiColor::draw(ImDrawList* draw) const
{
	if (((m_color1 | m_color2 | m_color3) & IM_COL32_A_MASK) == 0)
		return;

	ImVec2 verts[] = { m_p1, m_p2, m_p3 };
	ImU32 colors[] = { m_color1, m_color2, m_color3 };

	ImGui::ExtraDrawlist::AddConvexPolyFilledMultiColor(draw, verts, colors, IM_ARRAYSIZE(verts));
}

void Quad::draw(ImDrawList* draw) const
{
	draw->AddQuad(m_p1, m_p2, m_p3, m_p4, m_color, m_thickness);
}

void QuadFilled::draw(ImDrawList* draw) const
{
	draw->AddQuadFilled(m_p1, m_p2, m_p3, m_p4, m_color);
}

void QuadMultiColor::draw(ImDrawList* draw) const
{
	if (((m_color1 | m_color2 | m_color3 | m_color4) & IM_COL32_A_MASK) == 0)
		return;

	ImVec2 verts[] = { m_p1, m_p2, m_p3, m_p4 };
	ImU32 colors[] = { m_color1, m_color2, m_color3, m_color4 };

	ImGui::ExtraDrawlist::AddConvexPolyFilledMultiColor(draw, verts, colors, IM_ARRAYSIZE(verts));
}

void Polyline::draw(ImDrawList* draw) const
{
	draw->AddPolyline(m_verts.data(), m_verts.size(), m_color, m_flags, m_thickness);
}

void Polygon::draw(ImDrawList* draw) const
{
	draw->AddConvexPolyFilled(m_verts.data(), m_verts.size(), m_color);
}

void PolygonMultiColor::draw(ImDrawList* draw) const
{
	ImGui::ExtraDrawlist::AddConvexPolyFilledMultiColor(draw, m_verts.data(), m_colors.data(), m_verts.size());
}

void Text::draw(ImDrawList* draw) const
{
	ImGui::PushFont(m_font);
	ImVec2 pos = m_pos;

	if (auto tsize = ImGui::CalcTextSize(m_text.c_str()); m_centred)
		pos.x -= tsize.x / 2.0f;

	if (m_dropShadow)
	{
		const auto alpha = ImGui::ColorConvertU32ToFloat4(m_color).w;
		draw->AddText({ pos.x + 1.0f, pos.y + 1.0f }, Color::U32(Colors::Black.getColorEditAlpha(alpha)), m_text.c_str());
	}

	draw->AddText(pos, m_color, m_text.c_str());

	ImGui::PopFont();
}

void TextSize::draw(ImDrawList* draw) const
{
	ImGui::PushFont(m_font);
	ImVec2 pos = m_pos;

	if (auto tsize = m_font->CalcTextSizeA(m_size, std::numeric_limits<float>::max(), 0.0f, m_text.c_str()); m_centred)
		pos.x -= tsize.x / 2.0f;

	if (m_dropShadow)
	{
		const auto alpha = ImGui::ColorConvertU32ToFloat4(m_color).w;
		draw->AddText(m_font, m_size, { pos.x + 1.0f, pos.y + 1.0f }, Color::U32(Colors::Black.getColorEditAlpha(alpha)), m_text.c_str());
	}

	draw->AddText(m_font, m_size, pos, m_color, m_text.c_str());

	ImGui::PopFont();
}

void Arc::draw(ImDrawList* draw) const
{
	draw->PathArcTo(m_centre, m_radius, m_aMin, m_aMax, m_segments);
	draw->PathStroke(m_color, m_flags, m_thickness);
}

void Image::draw(ImDrawList* draw) const
{
	if (m_rounding > 0.0f)
		draw->AddImageRounded(m_texture, m_pmin, m_pmax, m_uvmin, m_uvmax, m_color, m_rounding, m_flags);
	else
		draw->AddImage(m_texture, m_pmin, m_pmax, m_uvmin, m_uvmax, m_color);
}


```

`hack/render/structures.hpp`:

```hpp
#pragma once

#include <vector>
#include <string>

#include <imgui.h>

// raw drawing
namespace drawing
{
	// base class, no fields. Use for any geometric structure.
	class Draw
	{
	public:
		virtual void draw(ImDrawList* draw) const = 0;
	};

	class Line : public Draw
	{
	public:
		constexpr Line(const ImVec2& min, const ImVec2& max, ImU32 color, float thickness)
			: m_start{ min }, m_end{ max }, m_color{ color }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_start;
		ImVec2 m_end;
		ImU32 m_color;
		float m_thickness;
	};

	class Rectangle : public Draw
	{
	public:
		constexpr Rectangle(const ImVec2& min, const ImVec2& max, ImU32 color, float rounding, ImDrawFlags flags, float thickness)
			: m_min{ min }, m_max{ max }, m_color{ color }, m_rounding{ rounding }, m_flags{ flags }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_min;
		ImVec2 m_max;
		ImU32 m_color;
		ImDrawFlags m_flags;
		float m_thickness;
		float m_rounding;
	};

	class RectangleFilled : public Draw
	{
	public:
		constexpr RectangleFilled(const ImVec2& min, const ImVec2& max, ImU32 color, float rounding, ImDrawFlags flags)
			: m_min{ min }, m_max{ max }, m_color{ color }, m_rounding{ rounding }, m_flags{ flags }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_min;
		ImVec2 m_max;
		ImU32 m_color;
		float m_rounding;
		ImDrawFlags m_flags;
	};

	class RectangleGradient : public Draw
	{
	public:
		constexpr RectangleGradient(const ImVec2& min, const ImVec2& max, ImU32 color1, ImU32 color2, bool horizontal)
			: m_min{ min }, m_max{ max }, m_color1{ color1 }, m_color2{ color2 }, m_horizontal{ horizontal }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_min;
		ImVec2 m_max;
		ImU32 m_color1; // left up / normal color
		ImU32 m_color2; // right up
		ImDrawFlags m_flags;
		bool m_horizontal;
	};

	class RectangleMultiColor : public Draw
	{
	public:
		constexpr RectangleMultiColor(const ImVec2& min, const ImVec2& max, ImU32 color1, ImU32 color2, ImU32 color3, ImU32 color4)
			: m_min{ min }, m_max{ max }, m_color1{ color1 }, m_color2{ color2 }, m_color3{ color3 }, m_color4{ color4 }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_min;
		ImVec2 m_max;
		ImU32 m_color1; // left up / normal color
		ImU32 m_color2; // right up
		ImU32 m_color3; // right bottom
		ImU32 m_color4; // left bottom
		ImDrawFlags m_flags;
		bool m_horizontal;
		float m_rounding;
	};

	class Circle : public Draw
	{
	public:
		constexpr Circle(const ImVec2& centre, float radius, int segments, ImU32 color, float thickness)
			: m_centre{ centre }, m_radius{ radius }, m_segments{ segments }, m_color{ color }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_centre;
		float m_radius;
		ImU32 m_color;
		int m_segments;
		float m_thickness;
	};

	class CircleFilled : public Draw
	{
	public:
		constexpr CircleFilled(const ImVec2& centre, float radius, int segments, ImU32 color)
			: m_centre{ centre }, m_radius{ radius }, m_segments{ segments }, m_color{ color }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_centre;
		float m_radius;
		ImU32 m_color;
		int m_segments;
	};

	class Triangle : public Draw
	{
	public:
		constexpr Triangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 color, float thickness)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_color{ color }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImU32 m_color;
		float m_thickness;
	};

	class TriangleFilled : public Draw
	{
	public:
		constexpr TriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 color)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_color{ color }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImU32 m_color;
	};

	class TriangleMultiColor : public Draw
	{
	public:
		constexpr TriangleMultiColor(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 color1, ImU32 color2, ImU32 color3)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_color1{ color1 }, m_color2{ color2 }, m_color3{ color3 }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImU32 m_color1;
		ImU32 m_color2;
		ImU32 m_color3;
	};

	class Quad : public Draw
	{
	public:
		constexpr Quad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 color, float thickness)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_p4{ p4 }, m_color{ color }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImVec2 m_p4;
		ImU32 m_color;
		float m_thickness;
	};

	class QuadFilled : public Draw
	{
	public:
		constexpr QuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 color)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_p4{ p4 }, m_color{ color }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImVec2 m_p4;
		ImU32 m_color;
	};

	class QuadMultiColor : public Draw
	{
	public:
		constexpr QuadMultiColor(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 color1, ImU32 color2, ImU32 color3, ImU32 color4)
			: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }, m_p4{ p4 }, m_color1{ color1 }, m_color2{ color2 }, m_color3{ color3 }, m_color4{ color4 }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_p1;
		ImVec2 m_p2;
		ImVec2 m_p3;
		ImVec2 m_p4;
		ImU32 m_color1; // left up / normal color
		ImU32 m_color2; // right up
		ImU32 m_color3; // right bottom
		ImU32 m_color4; // left bottom
	};

	class Polyline : public Draw
	{
	public:
		constexpr Polyline(const std::vector<ImVec2>& verts, ImU32 color, ImDrawFlags flags, float thickness)
			: m_count{ verts.size() }, m_verts{ verts }, m_color{ color }, m_flags{ flags }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		size_t m_count;
		std::vector<ImVec2> m_verts;
		ImU32 m_color;
		ImDrawFlags m_flags;
		float m_thickness;
	};

	class Polygon : public Draw
	{
	public:
		constexpr Polygon(const std::vector<ImVec2>& verts, ImU32 color)
			: m_count{ verts.size() }, m_verts{ verts }, m_color{ color }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		size_t m_count;
		std::vector<ImVec2> m_verts;
		ImU32 m_color;
	};

	class PolygonMultiColor : public Draw
	{
	public:
		constexpr PolygonMultiColor(const std::vector<ImVec2>& verts, const std::vector<ImU32>& colors)
			: m_count{ verts.size() }, m_verts{ verts }, m_colors{ colors }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		size_t m_count;
		std::vector<ImVec2> m_verts;
		std::vector<ImU32> m_colors;
	};

	class Text : public Draw
	{
	public:
		constexpr Text(ImFont* font, const ImVec2& pos, ImU32 color, const std::string& text, bool dropShadow, bool centered)
			: m_font{ font }, m_pos{ pos }, m_color{ color }, m_text{ text }, m_dropShadow{ dropShadow }, m_centred{ centered }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_pos;
		ImFont* m_font;
		std::string m_text;
		ImU32 m_color;
		bool m_dropShadow;
		bool m_centred;
	};

	class TextSize : public Draw
	{
	public:
		constexpr TextSize(float fontSize, ImFont* font, const ImVec2& pos, ImU32 color, const std::string& text, bool dropShadow, bool centered)
			: m_size{ fontSize }, m_font{ font }, m_pos{ pos }, m_color{ color }, m_text{ text }, m_dropShadow{ dropShadow }, m_centred{ centered }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_pos;
		ImFont* m_font;
		std::string m_text;
		ImU32 m_color;
		bool m_dropShadow;
		bool m_centred;
		float m_size;
	};

	class Arc : public Draw
	{
	public:
		constexpr Arc(const ImVec2& centre, float radius, float aMin, float aMax, int segments, ImU32 color, ImDrawFlags flags, float thickness)
			: m_centre{ centre }, m_radius{ radius }, m_aMin{ aMin }, m_aMax{ aMax }, m_segments{ segments }, m_color{ color }, m_flags{ flags }, m_thickness{ thickness }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImVec2 m_centre;
		float m_radius;
		float m_aMin;
		float m_aMax;
		int m_segments;
		ImU32 m_color;
		ImDrawFlags m_flags;
		float m_thickness;
	};

	class Image : public Draw
	{
	public:
		constexpr Image(const ImTextureID img, const ImVec2& pmin, const ImVec2& pmax, const ImVec2& uvmin, const ImVec2& uvmax, ImU32 col)
			: m_texture{ img }, m_pmin{ pmin }, m_pmax{ pmax }, m_uvmin{ uvmin }, m_uvmax{ uvmax }, m_color{ col }
		{}
		constexpr Image(const ImTextureID img, const ImVec2& pmin, const ImVec2& pmax, const ImVec2& uvmin, const ImVec2& uvmax, ImU32 col, float rounding, ImDrawFlags flags)
			: m_texture{ img }, m_pmin{ pmin }, m_pmax{ pmax }, m_uvmin{ uvmin }, m_uvmax{ uvmax }, m_color{ col }, m_rounding{ rounding }, m_flags{ flags }
		{}

		virtual void draw(ImDrawList* draw) const override;
	private:
		ImTextureID m_texture;
		ImVec2 m_pmin;
		ImVec2 m_pmax;
		ImVec2 m_uvmin;
		ImVec2 m_uvmax;
		ImU32 m_color;
		float m_rounding = 0.0f;
		ImDrawFlags m_flags = 0;
	};
}
```

`hack/resources/csgo-legit.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Polski (Polska) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_PLK)
LANGUAGE LANG_POLISH, SUBLANG_DEFAULT

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// VMT_FILE
//

IDR_VMT_FILE1           VMT_FILE                "hack\\deps\\missing\\snowflake.vmt"

IDR_VMT_FILE2           VMT_FILE                "hack\\deps\\missing\\bluelightning.vmt"

IDR_VMT_FILE3           VMT_FILE                "hack\\deps\\missing\\bluelight1.vmt"

IDR_VMT_FILE4           VMT_FILE                "hack\\deps\\missing\\lgtning.vmt"

IDR_VMT_FILE5           VMT_FILE                "hack\\deps\\missing\\physcannon_bluelight1.vmt"

IDR_VMT_FILE6           VMT_FILE                "hack\\deps\\missing\\physcannon_bluelight1b.vmt"


/////////////////////////////////////////////////////////////////////////////
//
// VTF_FILE
//

IDR_VTF_FILE1           VTF_FILE                "hack\\deps\\missing\\snowflake.vtf"

IDR_VTF_FILE2           VTF_FILE                "hack\\deps\\missing\\bluelightning.vtf"

IDR_VTF_FILE3           VTF_FILE                "hack\\deps\\missing\\bluelight1.vtf"

IDR_VTF_FILE4           VTF_FILE                "hack\\deps\\missing\\lgtning.vtf"

IDR_VTF_FILE5           VTF_FILE                "hack\\deps\\missing\\physcannon_bluelight1.vtf"

IDR_VTF_FILE6           VTF_FILE                "hack\\deps\\missing\\physcannon_bluelight1b.vtf"

#endif    // Polski (Polska) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`hack/resources/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Plik dołączany wygenerowany przez środowisko Microsoft Visual C++.
// Używany przez: csgo-legit.rc
//
#define IDR_VMT_FILE1                   101
#define IDR_VTF_FILE1                   102
#define IDR_VTF_FILE2                   103
#define IDR_VMT_FILE2                   104
#define IDR_VMT_FILE3                   105
#define IDR_VTF_FILE3                   106
#define IDR_VMT_FILE4                   107
#define IDR_VTF_FILE4                   108
#define IDR_VMT_FILE5                   109
#define IDR_VTF_FILE5                   110
#define IDR_VMT_FILE6                   111
#define IDR_VTF_FILE6                   112

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`hack/setup/setup.cpp`:

```cpp
#include "setup.hpp"

#include <config/vars.hpp>
#include <utilities/console/console.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <utilities/simpleTimer.hpp>
#include <SDK/helpers/netvars.hpp>
#include <render/backend/backend.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <menu/x88Menu/x88menu.hpp>
#include <menu/GUI-ImGui/menu.hpp>
#include <cheats/hooks/hooks.hpp>
#include <cheats/features/events/events.hpp>
#include <cheats/features/cache/cache.hpp>
#include <cheats/game/globals.hpp>
#include <cheats/game/game.hpp>
#include <gamememory/memory.hpp>
#include <utilities/res.hpp>
#include <cheats/hooks/wndProc.hpp>

#include <cheats/helper/initable.hpp>
#include <cheats/helper/shutdownable.hpp>

#include <Windows.h>

bool setup::init(void* instance)
{
	console::setLogger("CSGO DEBUG", "hack.log");
	console::info("Hack start, {} {}", __DATE__, __TIME__);

	TimeCount initTimer{};

	HACK_TRY
	{
		config::init();
		memory::init();
		game::init();
		hooks::init();
	}
	HACK_CATCH(const HACK_CATCH_TYPE& err)
	{
#ifdef WANT_EXCEPTIONS
		api::messageBox(err.what(), "Runtime hack error");
		console::error("Runtime hack error {}", err.what());
		FreeLibraryAndExitThread(static_cast<HMODULE>(instance), EXIT_FAILURE);
#endif
	}

	initTimer.end();
	console::info("Main thread took {:.5f}s", initTimer.getTime());

	return true;
}

void setup::shutdown(void* instance)
{
	// already executed
	if (globals::isShutdown)
		return;

	globals::isShutdown = true;

	game::shutdown();
	hooks::shutdown();
	// doing this after hooks shutdown very unlikely will throw those ctx nullptr errors
	renderbackend::shutdown();
	console::info("Hack shutdown");
	console::shutdown();

	_CRT_INIT(static_cast<HINSTANCE>(instance), DLL_PROCESS_DETACH, nullptr);
	FreeLibraryAndExitThread(static_cast<HMODULE>(instance), EXIT_SUCCESS); // crts may crash, game threadings etc...
}

void setup::looper(void* instance)
{
	while (!vars::keys->panic.isPressed())
	{
		Sleep(1000);
	}

	shutdown(instance);
}
```

`hack/setup/setup.hpp`:

```hpp
#pragma once

namespace setup
{
	bool init(void* instance);
	void shutdown(void* instance);
	void looper(void* instance);
};
```

`hack/utilities/cStr.hpp`:

```hpp
#pragma once

#include <array>

// is not a current feature in std
// https://youtu.be/zRYlQGMdISI?t=145
template<size_t SIZE>
struct cStr : public std::array<char, SIZE + 1U>
{
    constexpr cStr(const char* str)
        : std::array<char, SIZE + 1U>()
    {
        for (size_t i = 0U; i != SIZE; ++i)
            this->_Elems[i] = str[i];
    }

    constexpr const char* c_str() const 
    {
        return this->data();
    }
};

template<size_t SIZE>
cStr(const char(&)[SIZE]) -> cStr<SIZE - 1U>;
```

`hack/utilities/console/console.cpp`:

```cpp
#include "console.hpp"

#include <menu/GUI-ImGui/imguiaddons.hpp>
#include <utilities/utilities.hpp>
#include <utilities/tools/tools.hpp>
#include <utilities/tools/wrappers.hpp>
#include <render/Color.hpp>

#include <Windows.h>

void console::setLogger(const std::string_view title, const std::string_view logName)
{
	detail::m_logName = logName;
	assert(title.empty() == false); // not needed in release, will make code ugly if we add #idfefs everywhere
	assert(logName.empty() == false);

#ifdef _DEBUG
	AllocConsole();
	freopen_s(reinterpret_cast<FILE**>(stdout), "CONOUT$", "w", stdout);
	SetConsoleTitleA(title.data());
#endif
}

void console::detail::setColor(ColorsConsole color)
{
#ifdef _DEBUG
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), E2T(color));
#endif
	return;
}

void console::detail::reset()
{
#ifdef _DEBUG
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), E2T(ColorsConsole::CONSOLE_WHITE));
#endif
	return;
}

void console::shutdown() 
{
#ifdef _DEBUG
	fclose(stdout);
	FreeConsole();
#endif

	return;
}

void console::detail::addLogToStream(TypeLogs type, const std::string& buf)
{
#ifdef _DEBUG
	std::cout << buf;
#endif

	auto stream = std::ofstream{ api::getHackPath() / detail::m_logName, std::ofstream::out | std::ofstream::app };
	stream << buf;
	logDrawer::log.add(type, buf);
}

bool console::detail::isPossibleToLog(TypeLogs type)
{
#ifndef _DEBUG
	if (type == TypeLogs::LOG_ERR || type == TypeLogs::LOG_INFO)
		return true;

	return false;
#else
	return true;
#endif
}

std::string console::detail::generateTimeLog()
{
	return std::format("[{}] ", utilities::getTime());
}

void console::detail::addSigns(TypeLogs type)
{
#ifdef _DEBUG
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), E2T(colorsForConsole[type]));
	std::cout << std::format("{} {}", signs[type], consoleStrings[type]);
	reset();
#endif
}

void console::detail::enableNewLine()
{
	newline = true;
}

void console::detail::disableNewLine()
{
	newline = false;
}

void console::detail::enablePrefix()
{
	prefix = true;
}

void console::detail::disablePrefix()
{
	prefix = false;
}
```

`hack/utilities/console/console.hpp`:

```hpp
#pragma once

#include "consoleUtils.hpp"

#include <config/config.hpp>
#include <render/Color.hpp>

#include <string>
#include <unordered_map>
#include <iostream>
#include <fstream>
#include <mutex>
#include <cassert>
#include "consoleDraw.hpp"

struct SDKColor;

namespace console
{
	HACK_INIT void setLogger(const std::string_view title, const std::string_view logName);
	void shutdown();
	template<typename... Args_t>
	inline void log(TypeLogs type, const std::string_view fmt, Args_t&&... args);
	template<typename... Args_t>
	inline void error(const std::string_view fmt, Args_t&&... args) { log(TypeLogs::LOG_ERR, fmt, args...); }
	template<typename... Args_t>
	inline void warn(const std::string_view fmt, Args_t&&... args) { log(TypeLogs::LOG_WARN, fmt, args...); }
	template<typename... Args_t>
	inline void info(const std::string_view fmt, Args_t&&... args) { log(TypeLogs::LOG_INFO, fmt, args...); }
	template<typename... Args_t>
	inline void debug(const std::string_view fmt, Args_t&&... args) { log(TypeLogs::LOG_DEBUG, fmt, args...); }

	namespace detail
	{
		void setColor(ColorsConsole color);
		void reset();
		void addSigns(TypeLogs type);
		void addLogToStream(TypeLogs type, const std::string& buf);
		bool isPossibleToLog(TypeLogs type);
		void enableNewLine();
		void disableNewLine();
		void enablePrefix();
		void disablePrefix();
		std::string generateTimeLog();

		inline std::ofstream m_fileStream;
		inline std::string m_logName;
		inline std::mutex m_mutex;
		inline bool newline{ true };
		inline bool prefix{ true };

		inline std::unordered_map<TypeLogs, ColorsConsole> colorsForConsole
		{
			{ TypeLogs::LOG_ERR, ColorsConsole::CONSOLE_DARKRED },
			{ TypeLogs::LOG_WARN, ColorsConsole::CONSOLE_YELLOW },
			{ TypeLogs::LOG_INFO, ColorsConsole::CONSOLE_WHITE },
			{ TypeLogs::LOG_DEBUG, ColorsConsole::CONSOLE_CYAN },
		};
		inline std::unordered_map<TypeLogs, std::string_view> consoleStrings
		{
			{ TypeLogs::LOG_ERR, "[err]"},
			{ TypeLogs::LOG_WARN, "[warn]"},
			{ TypeLogs::LOG_INFO, "[info]"},
			{ TypeLogs::LOG_DEBUG, "[debug]"},
		};
		inline std::unordered_map<TypeLogs, Color> colorsForView
		{
			{ TypeLogs::LOG_ERR, Colors::Red },
			{ TypeLogs::LOG_WARN, Colors::Yellow },
			{ TypeLogs::LOG_INFO, Colors::White },
			{ TypeLogs::LOG_DEBUG, Colors::Cyan },
		};
		inline std::unordered_map<TypeLogs, char> signs
		{
			{ TypeLogs::LOG_ERR, '!'},
			{ TypeLogs::LOG_WARN, '^'},
			{ TypeLogs::LOG_INFO, '+'},
			{ TypeLogs::LOG_DEBUG, '*'},
		};
	}
};

// sorry for using cout
// https://youtu.be/TxhQQLGafZ4?t=78
// :D

template<typename... Args_t>
inline void console::log(TypeLogs type, const std::string_view fmt, Args_t&&... args)
{
	if (!detail::isPossibleToLog(type))
		return;

	if (fmt.empty())
		return;

	std::string buffer{ };
	if (detail::prefix)
	{
		detail::addSigns(type);
		buffer = detail::generateTimeLog();
	}
	if constexpr (sizeof...(args) > 0)
		buffer += std::vformat(fmt, std::make_format_args(args...));
	else
		buffer += fmt;
	
	if(detail::newline)
		buffer += '\n';

	detail::addLogToStream(type, buffer);
}
```

`hack/utilities/console/consoleDraw.cpp`:

```cpp
#include "consoleDraw.hpp"
#include "console.hpp"

#include <render/Color.hpp>
#include <utilities/tools/tools.hpp>

#include <cheats/hooks/present.hpp>
#include <cheats/hooks/wndproc.hpp>

namespace
{
	struct LogDraw : hooks::Present
	{
		LogDraw()
		{
			this->registerRun(logDrawer::draw);
		}
	} logDraw;

	struct LogKeys : hooks::wndProcSys
	{
		LogKeys()
		{
			this->registerRun(logDrawer::updateKeys);
		}
	} logKeys;
}

void logDrawer::ExampleAppLog::draw(const char* title, bool* p_open)
{
	if (!ImGui::Begin(title, p_open))
	{
		ImGui::End();
		return;
	}

	filter.Draw("Filter");

	ImGui::SameLine();
	bool clear = ImGui::Button("Clear");
	ImGui::SameLine();
	bool copy = ImGui::Button("Copy");
	ImGui::SameLine();
	if (ImGui::Button("Wrap"))
		wrap = !wrap;

	ImGui::Spacing();

	ImGui::BeginChild("scrolling", ImVec2(0, 0), false, wrap ? ImGuiWindowFlags_AlwaysHorizontalScrollbar : ImGuiWindowFlags_HorizontalScrollbar);

	if (clear)
		buffer.clear();
	if (copy)
		ImGui::LogToClipboard();

	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
	if (filter.IsActive())
	{
		for (const auto [text, color] : buffer)
		{
			if (filter.PassFilter(text.data()))
			{
				if (wrap)
					ImGui::PushTextWrapPos();
				ImGui::PushStyleColor(ImGuiCol_Text, Color::U32(console::detail::colorsForView.at(color)));
				ImGui::TextUnformatted(text.data());
				ImGui::PopStyleColor();
				if (wrap)
					ImGui::PopTextWrapPos();
			}
		}
	}
	else
	{
		ImGuiListClipper clipper;
		clipper.Begin(buffer.size());
		while (clipper.Step())
		{
			for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
			{
				const auto [text, color] = buffer.at(i);

				if (wrap)
					ImGui::PushTextWrapPos();
				ImGui::PushStyleColor(ImGuiCol_Text, Color::U32(console::detail::colorsForView.at(color)));
				ImGui::TextUnformatted(text.data());
				ImGui::PopStyleColor();
				if (wrap)
					ImGui::PopTextWrapPos();
			}
		}
		clipper.End();
	}
	ImGui::PopStyleVar();

	if (ImGui::GetScrollY() >= ImGui::GetScrollMaxY())
		ImGui::SetScrollHereY(1.0f);

	ImGui::EndChild();
	ImGui::End();
}

void logDrawer::draw()
{
	if (opened)
		log.draw("Logging Console", &opened);
}

#include <config/vars.hpp>

void logDrawer::updateKeys()
{
	if (vars::keys->console.isPressed())
		opened = !opened;
}
```

`hack/utilities/console/consoleDraw.hpp`:

```hpp
#pragma once

#include "consoleUtils.hpp"

#include <menu/GUI-ImGui/imguiaddons.hpp>

#include <vector>
#include <string>

namespace logDrawer
{
	void draw();
	void updateKeys();

	// from demo, slight edit, usage same as normal console.log
	struct ExampleAppLog
	{
		template<typename... Args_t>
		void add(TypeLogs type, const std::string_view fmt, Args_t&&... args);
		void draw(const char* title, bool* p_open = NULL);
	private:
		bool wrap{ false };
		ImGuiTextFilter filter{ };
		std::vector<std::pair<std::string, TypeLogs>> buffer{ };
	} inline log;

	inline bool opened{ false };
};

template<typename... Args_t>
void logDrawer::ExampleAppLog::add(TypeLogs logs, const std::string_view fmt, Args_t&&... args)
{
	std::string text{ };
	if constexpr (sizeof...(args) > 0)
		text += std::vformat(fmt, std::make_format_args(args...));
	else
		text += fmt;

	this->buffer.emplace_back(std::make_pair(text, logs));
}
```

`hack/utilities/console/consoleUtils.hpp`:

```hpp
#pragma once

#include <consoleapi2.h>

enum class TypeLogs
{
	LOG_ERR,
	LOG_WARN,
	LOG_INFO,
	LOG_DEBUG
};

enum class ColorsConsole
{
	CONSOLE_WHITE = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
	CONSOLE_BLACK = NULL,
	CONSOLE_DARKBLUE = FOREGROUND_BLUE,
	CONSOLE_DARKGREEN = FOREGROUND_GREEN,
	CONSOLE_DARKCYAN = FOREGROUND_GREEN | FOREGROUND_BLUE,
	CONSOLE_DARKRED = FOREGROUND_RED,
	CONSOLE_DARKMAGENTA = FOREGROUND_RED | FOREGROUND_BLUE,
	CONSOLE_DARKYELLOW = FOREGROUND_RED | FOREGROUND_GREEN,
	CONSOLE_DARKGRAY = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
	CONSOLE_GRAY = FOREGROUND_INTENSITY,
	CONSOLE_BLUE = FOREGROUND_INTENSITY | FOREGROUND_BLUE,
	CONSOLE_GREEN = FOREGROUND_INTENSITY | FOREGROUND_GREEN,
	CONSOLE_CYAN = FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_BLUE,
	CONSOLE_RED = FOREGROUND_INTENSITY | FOREGROUND_RED,
	CONSOLE_MAGENTA = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_BLUE,
	CONSOLE_YELLOW = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN,
};
```

`hack/utilities/inputSystem.cpp`:

```cpp
#include "inputSystem.hpp"

#include <cheats/game/globals.hpp>
#include <cheats/game/game.hpp>
#include <SDK/IVEngineClient.hpp>
#include <SDK/interfaces/interfaces.hpp>

#include <bitset>

enum class KeyState
{
	OFF,
	DOWN,
	UP,
	PRESS
};

namespace inputSystem
{
	constexpr size_t KEYS_SIZE{ 256U };
    std::bitset<KEYS_SIZE> m_keyStates;
    std::bitset<KEYS_SIZE> m_keyPressStates;
}

void inputSystem::run(UINT message, WPARAM wparam)
{
	if (game::isChatOpen() || memory::interfaces::engine->isConsoleVisible())
		return;

	if (globals::isInHotkey)
		return;

	// init starting keys, undefined
	UINT key = 0;
	auto state = KeyState::OFF;

	switch (message)
	{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	{
		if (wparam < KEYS_SIZE)
		{
			key = wparam;
			state = KeyState::DOWN;
		}
	}
	break;
	case WM_KEYUP:
	case WM_SYSKEYUP:
	{
		if (wparam < KEYS_SIZE)
		{
			key = wparam;
			state = KeyState::UP;
		}
	}
	break;
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_LBUTTONDBLCLK:
	{
		key = VK_LBUTTON;
		state = message == WM_LBUTTONUP ? KeyState::UP : KeyState::DOWN;
	}
	break;
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_RBUTTONDBLCLK:
	{
		key = VK_RBUTTON;
		state = message == WM_RBUTTONUP ? KeyState::UP : KeyState::DOWN;
	}
	break;
	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
	case WM_MBUTTONDBLCLK:
	{
		key = VK_MBUTTON;
		state = message == WM_MBUTTONUP ? KeyState::UP : KeyState::DOWN;
	}
	break;
	case WM_XBUTTONDOWN:
	case WM_XBUTTONUP:
	case WM_XBUTTONDBLCLK:
	{
		key = (GET_XBUTTON_WPARAM(wparam) == XBUTTON1 ? VK_XBUTTON1 : VK_XBUTTON2);
		state = message == WM_XBUTTONUP ? KeyState::UP : KeyState::DOWN;
	}
	break;
	default:
		break;
	}

	// save the key
	if (state == KeyState::DOWN)
	{
		m_keyStates.set(key);
	}
	else if (state == KeyState::UP)
	{
		m_keyStates.reset(key);
		m_keyPressStates.set(key);
	}
}

bool inputSystem::isKeyDown(UINT vKey)
{
	return m_keyStates[vKey];
}

bool inputSystem::isKeyPressed(UINT vKey)
{
	if (m_keyPressStates[vKey])
	{
		m_keyPressStates.reset(vKey);
		return true;
	}
	return false;
}

bool inputSystem::isKeyDown(const std::initializer_list<UINT>& vKeys)
{
	for (const auto vKey : vKeys)
	{
		if (!m_keyStates[vKey])
			return false;
	}
	return true;
}

bool inputSystem::isKeyPressed(const std::initializer_list<UINT>& vKeys)
{
	for (const auto vKey : vKeys)
	{
		if (!m_keyPressStates[vKey])
			return false;
	}

	for (const auto vKey : vKeys)
	{
		m_keyPressStates.reset(vKey);
	}
	return true;
}
```

`hack/utilities/inputSystem.hpp`:

```hpp
#pragma once

#include <windef.h>
#include <initializer_list>

namespace inputSystem
{
    void run(UINT message, WPARAM wparam);
    [[nodiscard]] bool isKeyDown(UINT vKey);
    [[nodiscard]] bool isKeyPressed(UINT vKey);
    [[nodiscard]] bool isKeyPressed(const std::initializer_list<UINT>& vKeys);
    [[nodiscard]] bool isKeyDown(const std::initializer_list<UINT>& vKeys);
};
```

`hack/utilities/math/math.cpp`:

```cpp
#include "math.hpp"

Vec3 math::calcAngleRelative(const Vec3& source, const Vec3& destination, const Vec3& viewAngles)
{
	const auto delta = destination - source;

	Vec3 angles
	{
		RAD2DEG(std::atan2(-delta[2], std::hypot(delta[0], delta[1]))) - viewAngles[0],
		RAD2DEG(std::atan2(delta[1], delta[0])) - viewAngles[1],
		0.0f
	};

	return angles;
}

Vec3 math::calcAngle(const Vec3& source, const Vec3& destination)
{
	const auto delta = destination - source;

	Vec3 angles
	{
		RAD2DEG(std::atan2(-delta[2], std::hypot(delta[0], delta[1]))),
		RAD2DEG(std::atan2(delta[1], delta[0])),
		0.0f
	};

	return angles;
}

float math::calcFov(const Vec3& source, const Vec3& destination, const Vec3& viewAngles)
{
	const auto angle = calcAngleRelative(source, destination, viewAngles);
	const auto fov = std::hypot(angle[0], angle[1]);
	return fov;
}

float math::calcFovReal(const Vec3& source, const Vec3& destination, const Vec3& viewAngles)
{
	float dist = source.distTo(destination);
	float realDist = dist / 10.0f;

	auto start = angleVec(viewAngles) * realDist;
	auto end = angleVec(calcAngle(source, destination)) * realDist;

	return start.distTo(end);
}

Vec3 math::transformVector(const Vec3& in, const Matrix3x4& matrix)
{
	return Vec3(in.dot(Vec3{ matrix[0].data() }) + matrix[0][3], in.dot(Vec3{ matrix[1].data() }) + matrix[1][3],
		in.dot(Vec3{ matrix[2].data() }) + matrix[2][3]);
}

Vec3 math::angleVec(const Vec3& angle)
{
	auto sy = std::sin(DEG2RAD(angle[1]));
	auto cy = std::cos(DEG2RAD(angle[1]));

	auto sp = std::sin(DEG2RAD(angle[0]));
	auto cp = std::cos(DEG2RAD(angle[0]));

	return Vec3{ cp * cy, cp * sy, -sp };
}

std::tuple<Vec3, Vec3, Vec3> math::angleVectors(const Vec3& angle)
{
	auto sy = std::sin(DEG2RAD(angle[1]));
	auto cy = std::cos(DEG2RAD(angle[1]));

	auto sp = std::sin(DEG2RAD(angle[0]));
	auto cp = std::cos(DEG2RAD(angle[0]));

	auto sr = std::sin(DEG2RAD(angle[2]));
	auto cr = std::cos(DEG2RAD(angle[2]));

	Vec3 forward
	{
		cp * cy,
		cp * sy,
		-sp
	};

	Vec3 right
	{
		-1.0f * sr * sp * cy + -1.0f * cr * -sy,
		-1.0f * sr * sp * sy + -1.0f * cr * cy,
		-1.0f * sr * cp
	};	

	Vec3 up
	{
		cr * sp * cy + -sr * -sy,
		cr * sp * sy + -sr * cy,
		cr * cp
	};

	return { forward, right, up };
}

float math::normalizeYaw(float yaw)
{
	while (yaw > 180.0f)
		yaw -= 360.0f;

	while (yaw < -180.0f)
		yaw += 360.0f;

	return yaw;
}

float math::normalizePitch(float pitch)
{
	while (pitch > 89.0f)
		pitch -= 180.0f;

	while (pitch < -89.0f)
		pitch += 180.0f;

	return pitch;
}

Vec3 math::vectorToAngle(const Vec3& vec)
{
	Vec3 angle;
	if (vec[0] == 0.0f && vec[1] == 0.0f)
	{
		angle[0] = (vec[2] > 0.0f) ? 270.0f : 90.0f;
		angle[1] = 0.0f;
	}
	else
	{
		angle[0] = RAD2DEG(std::atan2(-vec[2], std::hypot(vec[0], vec[1])));
		angle[1] = RAD2DEG(std::atan2(vec[1], vec[0]));

		if (angle[1] > 90.0f)
			angle[1] -= 180.0f;
		else if (angle[1] < 90.0f)
			angle[1] += 180.0f;
		else if (angle[1] == 90.0f)
			angle[1] = 0.0f;
	}
	angle[2] = 0.0f;
	return angle;
}

std::pair<Vec3, Vec3> math::transformAABB(const Matrix3x4& transform, const Vec3& mins, const Vec3& maxs)
{
	Vec3 localCenter = mins + maxs;
	localCenter *= 0.5f;

	Vec3 localExtents = maxs - localCenter;

	Vec3 worldCenter = transformVector(localCenter, transform);

	Vec3 worldExtents;

	worldExtents[0] = localExtents.dot(Vec3{ transform[0].data() });
	worldExtents[1] = localExtents.dot(Vec3{ transform[1].data() });
	worldExtents[2] = localExtents.dot(Vec3{ transform[2].data() });

	return {
		worldCenter - worldExtents,
		worldCenter + worldExtents
	};
}

#include <imgui_internal.h>
#include <algorithm>

static constexpr float orient(const ImVec2& a, const ImVec2& b, const ImVec2& c)
{
	return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

std::optional<std::vector<ImVec2>> math::grahamScan(std::span<const ImVec2> points)
{
	// case when it's impossible
	if (points.size() < 3)
		return std::nullopt;

	// make a temp copy to allow use swap
	std::vector<ImVec2> v{ points.begin(), points.end() };

	// now at index 0 we have most left point
	std::ranges::iter_swap(v.begin(), std::ranges::min_element(v, {}, [](const ImVec2& p) { return p.x; }));

	std::ranges::sort(v.begin() + 1, v.end(),
		[p0 = v.at(0)](const ImVec2& a, const ImVec2& b)
		{
			auto _orient = orient(p0, a, b);
			return _orient == 0.0f ? ImLengthSqr(p0 - a) < ImLengthSqr(p0 - b) : _orient < 0.0f;
		}
	);

	std::vector<ImVec2> hull;

	for (const auto& el : v)
	{
		while (hull.size() > 1 && orient(hull[hull.size() - 2], hull[hull.size() - 1], el) >= 0.0f)
			hull.pop_back();

		hull.push_back(el);
	}

	return hull;
}
```

`hack/utilities/math/math.hpp`:

```hpp
#pragma once

#include <SDK/math/matrix.hpp>
#include <SDK/math/Vector.hpp>

#include <numbers>
#include <span>
#include <vector>
#include <utility>
#include <tuple>
#include <optional>

struct ImVec2;

// read: https://www.unknowncheats.me/forum/counterstrike-global-offensive/137492-math-behind-hack-1-coding-better-aimbot-stop-using-calcangle.html
namespace math
{
	constexpr float PI = std::numbers::pi_v<float>;
	constexpr float PI_2 = std::numbers::pi_v<float> * 2.0f;

	[[nodiscard]] constexpr float DEG2RAD(float degrees) { return degrees * (PI / 180.0f); }
	[[nodiscard]] constexpr float RAD2DEG(float radians) { return radians * (180.0f / PI); }

	[[nodiscard]] Vec3 calcAngleRelative(const Vec3& src, const Vec3& dest, const Vec3& viewAngles);
	// classic
	[[nodiscard]] Vec3 calcAngle(const Vec3& src, const Vec3& dest);
	[[nodiscard]] float calcFov(const Vec3& source, const Vec3& destination, const Vec3& viewAngles);
	// based on distance, difference is that we dont have same fov everytime, since this is dynamic	
	[[nodiscard]] float calcFovReal(const Vec3& src, const Vec3& dest, const Vec3& viewAngles);
	[[nodiscard]] Vec3 transformVector(const Vec3& in, const Matrix3x4& matrix);
	[[nodiscard]] Vec3 angleVec(const Vec3& angle);
	[[nodiscard]] std::tuple<Vec3, Vec3, Vec3> angleVectors(const Vec3& angle);
	[[nodiscard]] float normalizeYaw(float yaw);
	[[nodiscard]] float normalizePitch(float pitch);
	// direction vector based on euler dimension
	[[nodiscard]] Vec3 vectorToAngle(const Vec3& vec);
	[[nodiscard]] std::optional<std::vector<ImVec2>> grahamScan(std::span<const ImVec2> points);
	[[nodiscard]] std::pair<Vec3, Vec3> transformAABB(const Matrix3x4& transform, const Vec3& mins, const Vec3& maxs);
}
```

`hack/utilities/rand.hpp`:

```hpp
#pragma once

#include <random>
#include <type_traits>

class Random // sfinae rule simple template static class
{
public:
    template<typename T>
    [[nodiscard]] static std::enable_if_t<std::is_arithmetic_v<T>, T> getRandom(T min, T max)
    {
        if constexpr (std::is_integral_v<T>)
        {
            return std::uniform_int_distribution<T>{min, max}(rng);
        }
        else
        {
            return std::uniform_real_distribution<T>{min, max}(rng);
        }
    }

private:
    inline static std::mt19937 rng{ std::random_device{}() };
};
```

`hack/utilities/res.cpp`:

```cpp
#include "res.hpp"

#include "tools/tools.hpp"
#include <render/render.hpp>
#include "../utilities/console/console.hpp"

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>
#include <imgui_impl_dx9.h>
#include <cheats/game/globals.hpp>
#include <SDK/interfaces/interfaces.hpp>
#include <SDK/ISurface.hpp>
#include <menu/GUI-ImGui/imguiaddons.hpp>

#include <Windows.h>
#include <d3dx9.h>

// not going to use D3DXCreateTextureFromFileA or D3DXCreateTextureFromResourceA
// first - this API is very old and second D3DXCreateTextureFromResourceA had problems and my resource was forced to be RCDATA type instead of generated one to work.

Resource::Resource(const std::string& path)
{
	if (path.empty())
		return;

	stbi_set_flip_vertically_on_load_thread(false);
	m_buffer = stbi_load(path.c_str(), &m_width, &m_height, nullptr, 4);
	if (!m_buffer)
	{
		console::error("Creating resource from path failed, reason: {}", stbi_failure_reason());
		return;
	}
	m_texture = reinterpret_cast<IDirect3DTexture9*>(ImGui_CreateTexture(m_buffer, m_width, m_height));
#ifdef SURFACE_RENDER
	SurfaceRender::initNewTexture(m_textureID, m_buffer, m_width, m_height);
#endif
	stbi_image_free(m_buffer);

	m_resBuf.push_back(*this);

	console::debug("Image with path {} loaded!", path);
}

Resource::Resource(int resID, const std::string_view type)
{
	HRSRC hResInfo = FindResourceA(globals::instance, MAKEINTRESOURCEA(resID), type.data());
	if (!hResInfo)
		HACK_THROW("Recource could not be found");

	HGLOBAL hResData = LoadResource(globals::instance, hResInfo);
	if (!hResData)
		HACK_THROW("Recource data could not be found");

	unsigned char* hResPtr = reinterpret_cast<unsigned char*>(LockResource(hResData));
	size_t size = SizeofResource(globals::instance, hResInfo);

	stbi_set_flip_vertically_on_load_thread(false);
	m_buffer = stbi_load_from_memory(hResPtr, size, &m_width, &m_height, nullptr, 4);
	if (!m_buffer)
	{
		console::error("Creating resource from resources file failed, reason: {}", stbi_failure_reason());
		return;
	}
	m_texture = reinterpret_cast<IDirect3DTexture9*>(ImGui_CreateTexture(m_buffer, m_width, m_height));
#ifdef SURFACE_RENDER
	SurfaceRender::initNewTexture(m_textureID, m_buffer, m_width, m_height);
#endif
	stbi_image_free(m_buffer);
	FreeResource(hResData);

	m_resBuf.push_back(*this);

	console::debug("Resource ID {}:{} image loaded!", resID, type);
}

Resource::Resource(void* data, size_t size)
{
	stbi_set_flip_vertically_on_load_thread(false);
	m_buffer = stbi_load_from_memory(reinterpret_cast<unsigned char*>(data), size, &m_width, &m_height, nullptr, 4);
	if (!m_buffer)
	{
		console::error("Creating resource from memory failed, reason: {}", stbi_failure_reason());
		return;
	}
	m_texture = reinterpret_cast<IDirect3DTexture9*>(ImGui_CreateTexture(m_buffer, m_width, m_height));
	stbi_image_free(m_buffer);

	m_resBuf.push_back(*this);

	console::debug("Image from memory loaded!");
}

void Resource::destroyAll()
{
	for (const auto& el : m_resBuf)
	{
		if (el.getTexture() && el.getTextureID())
		{
			ImGui_DestroyTexture(el.getTexture());
#ifdef SURFACE_RENDER
			memory::interfaces::surface->deleteTextureID(el.getTextureID());
#endif
		}
	}
}

```

`hack/utilities/res.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>

struct IDirect3DTexture9;

class Resource final
{
public:
	Resource(const std::string& path);
	Resource(int resID, const std::string_view type);
	Resource(void* data, size_t size);
	static void destroyAll();
	// imgui
	IDirect3DTexture9* getTexture() const { return m_texture; }
	// surface
	constexpr int getTextureID() const { return m_textureID; }
	constexpr int getWidth() const { return m_width; }
	constexpr int getHeight() const { return m_height; }
private:
	IDirect3DTexture9* m_texture;
	unsigned char* m_buffer;
	// surface
	int m_textureID = -1;
	int m_width;
	int m_height;

	inline static std::vector<Resource> m_resBuf;
};
```

`hack/utilities/runnable.hpp`:

```hpp
#pragma once

#include <functional>
#include <type_traits>

template<typename Func>
concept functionAble = requires
{
	typename std::function<std::decay_t<Func>>;
};

// this is from boost, because I failed to ANYHOW count std::function args by tuple size
template <typename T>
struct function_traits;

template <typename R, typename... Args>
struct function_traits<std::function<R(Args...)>>
{
	enum { arity = sizeof...(Args) };
	using result_type = R;
	using parameter_pack = std::tuple<Args...>;
};

template<functionAble F>
struct vectorRunnable : public std::vector<F>
{
	constexpr vectorRunnable() :
		std::vector<F>()
	{}

	template<typename T = void, typename... Args_t>
	T run(Args_t&&... args)
	{
		static_assert(sizeof...(Args_t) == std::tuple_size_v<typename function_traits<F>::parameter_pack>,
			"Number of arguments does not match stored function");

        if constexpr (std::is_same_v<T, bool>)
        {
            T ret{ false };
            for (auto& element : *this)
            {
                ret |= element(std::forward<Args_t>(args)...);
            }
            return ret;
        }
        else if constexpr (std::is_void_v<T>)
        {
            for (auto& element : *this)
            {
                element(std::forward<Args_t>(args)...);
            }
        }
        else // not handled, do this if needed
        {
            T ret{};
            for (auto& element : *this)
            {
                element(std::forward<Args_t>(args)...);
            }
            return ret;
        }
	}
};
```

`hack/utilities/simpleTimer.hpp`:

```hpp
#pragma once

#ifdef _WIN32
#include <Windows.h>
#else
#include <ctime>
#endif

enum class TimeUnit
{
    Seconds,
    Milliseconds,
    Microseconds
};

template <TimeUnit Unit = TimeUnit::Seconds>
class TimeCount
{
public:
    TimeCount()
    {
#ifdef _WIN32
        QueryPerformanceFrequency(&m_Frequency);
        QueryPerformanceCounter(&m_Start);
#else
        clock_gettime(CLOCK_MONOTONIC, &m_Start);
#endif
    }

    void end()
    {
#ifdef _WIN32
        QueryPerformanceCounter(&m_End);
#else
        clock_gettime(CLOCK_MONOTONIC, &m_End);
#endif
    }

    double elapsed() const
    {
#ifdef _WIN32
        return static_cast<double>(m_End.QuadPart - m_Start.QuadPart) / m_Frequency.QuadPart;
#else
        return static_cast<double>(m_End.tv_sec - m_Start.tv_sec) +
            static_cast<double>(m_End.tv_nsec - m_Start.tv_nsec) / 1e9;
#endif
    }

    template <TimeUnit U = Unit>
    auto getTime() const
    {
        if constexpr (U == TimeUnit::Seconds)
            return elapsed();
        else if constexpr (U == TimeUnit::Milliseconds)
            return elapsed() * 1000;
        else if constexpr (U == TimeUnit::Microseconds)
            return elapsed() * 1e6;
    }

private:
#ifdef _WIN32
    LARGE_INTEGER m_Start;
    LARGE_INTEGER m_End;
    LARGE_INTEGER m_Frequency;
#else
    timespec m_Start;
    timespec m_End;
#endif
};
```

`hack/utilities/tools/tools.cpp`:

```cpp
#include "tools.hpp"

#include <gamememory/modules.hpp>

uintptr_t spoof::getGadget(const std::string_view moduleName, const std::initializer_list<uint8_t>& jmpRbxBytes)
{
    static std::unordered_map<std::string_view, void*> modulesPassed;

    if (const auto itr = modulesPassed.find(moduleName); itr == modulesPassed.end())
    {
        const auto _module = memory::modules::getModule(moduleName);
        const auto dosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(_module);
        const auto ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<uint8_t*>(_module) + dosHeader->e_lfanew);
        const auto section = IMAGE_FIRST_SECTION(ntHeaders);

        const auto addrStart = reinterpret_cast<uint8_t*>(_module) + section->VirtualAddress;
        const auto addrEnd = addrStart + section->Misc.VirtualSize;
        const auto jumpRBXaddr = std::ranges::search(addrStart, addrEnd, jmpRbxBytes.begin(), jmpRbxBytes.end());

        modulesPassed.emplace(std::make_pair(moduleName, jumpRBXaddr.data()));

        return reinterpret_cast<uintptr_t>(jumpRBXaddr.data());
    }
    else
    {
        return reinterpret_cast<uintptr_t>(itr->second);
    }
}
```

`hack/utilities/tools/tools.hpp`:

```hpp
#pragma once

#include <string_view>
#include <initializer_list>

namespace spoof
{
    uintptr_t getGadget(const std::string_view moduleName, const std::initializer_list<uint8_t>& jmpRbxBytes = { 0xFF, 0x23 });
}
```

`hack/utilities/tools/wrappers.hpp`:

```hpp
#pragma once

#include <lazy_importer.hpp>

#include <type_traits>
#include <string>
#include <format>

template<typename T>
[[nodiscard]] inline constexpr auto E2T(T en)
{
    return static_cast<std::underlying_type_t<T>>(en);
}

[[nodiscard]] inline constexpr auto hasher(const std::string_view str)
{
    constexpr auto hashBasis = 2166136261U;
    return li::detail::khash(str.data(), hashBasis);
}

[[nodiscard]] inline constexpr auto operator"" _u8str(const char8_t* str, size_t s)
{
    return std::string{ str, str + s };
}

[[nodiscard]] inline constexpr auto operator"" _hasher(const char* str, size_t s)
{
    return hasher(str);
}
```

`hack/utilities/utilities.cpp`:

```cpp
#include "utilities.hpp"

#include "tools/tools.hpp"

#include <Windows.h>
#include <ctime>
#include <mutex>

#pragma warning(disable: 6001) // memory unallocated
#pragma warning(disable: 6054) // string terminated

std::string utilities::getTime()
{
	/*static std::mutex timeMtx;
	std::lock_guard lock{ timeMtx };*/

	std::time_t currentTime = std::time(nullptr);

	std::tm timeInfo;
	localtime_s(&timeInfo, &currentTime);

	char timeString[50];
	std::strftime(timeString, sizeof(timeString), "%d:%m:%Y-%X", &timeInfo);

	return timeString;
}

std::string utilities::getKeyName(const uint32_t virtualKey)
{
	uint32_t scanCode = MapVirtualKeyA(virtualKey, MAPVK_VK_TO_VSC);

	// because MapVirtualKey strips the extended bit for some keys
	switch (virtualKey)
	{
	case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN: // arrow keys
	case VK_PRIOR: case VK_NEXT: // page up and page down
	case VK_END: case VK_HOME:
	case VK_INSERT: case VK_DELETE:
	case VK_DIVIDE: // numpad slash
	case VK_NUMLOCK:
	{
		scanCode |= 0x100; // set extended bit
		break;
	}
	case 1:
		return "LMB";
		break;
	case 2:
		return "RMB";
		break;
	case 4:
		return "MMB";
		break;
	case 5:
		return "Side 1";
		break;
	case 6:
		return "Side 2";
		break;
	}

	if (char keyName[50]; GetKeyNameTextA(scanCode << 16, keyName, sizeof(keyName)) != 0)
		return keyName;
	else
		return "[None]";
}

std::string utilities::toLowerCase(const std::string& str)
{
	std::string result = str;
	std::for_each(result.begin(), result.end(), [](char& el)
		{
			el = ::tolower(el);
		});
	return result;
}

std::string utilities::toUpperCase(const std::string& str)
{
	std::string result = str;
	std::for_each(result.begin(), result.end(), [](char& el)
		{
			el = ::toupper(el);
		});
	return result;
}

std::vector<std::string> utilities::splitStr(const std::string& str, char limit)
{
	std::vector<std::string> res;
	std::stringstream content{ str };
	std::string word;
	while (std::getline(content, word, limit))
	{
		res.push_back(word);
	}
	return res;
}

uint32_t utilities::getKey(const uint32_t vKey)
{
	return GetAsyncKeyState(vKey);
}

std::string utilities::u8toStr(const std::u8string& u8str)
{
	return std::string{ u8str.cbegin(), u8str.cend() };
}

int utilities::convertStringToFlag(const std::string& flag)
{
	std::string fixed{ flag };
	fixed.erase(std::remove(fixed.begin(), fixed.end(), ' '), fixed.end());
	int ret{ 0 };
	for (const auto& el : std::views::split(fixed, '|'))
	{
		const std::string v{ el.begin(), el.end() };
		const int num = std::stoi(v);
		ret |= num;
	}

	return ret;
}
```

`hack/utilities/utilities.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <array>
#include <ranges>

namespace utilities
{
    [[nodiscard]] std::string getTime();
    [[nodiscard]] std::string getKeyName(const uint32_t virtualKey);
    [[nodiscard]] std::string toLowerCase(const std::string& str);
    [[nodiscard]] std::string toUpperCase(const std::string& str);
    template<typename T, size_t SIZE>
    [[nodiscard]] constexpr std::array<T, SIZE> getFilledArray(const T& val)
    {
        std::array<T, SIZE> arr;
        std::ranges::fill(arr, val);
        return arr;
    }
    // deprecated, https://www.youtube.com/watch?v=V14xGZAyVKI
    [[deprecated("use std::views::split")]]
    std::vector<std::string> splitStr(const std::string& str, char limit = ' ');
    [[deprecated("use key classes")]]
    uint32_t getKey(const uint32_t vKey);
    [[nodiscard]] std::string u8toStr(const std::u8string& u8str);
    [[nodiscard]] int convertStringToFlag(const std::string& flag);
}
```

`pch.cpp`:

```cpp
#include "pch.h"
```

`pch.h`:

```h
#pragma once

#include "hack/api.hpp"

#include <Windows.h>
#include <ShlObj.h>

#include <filesystem>
#include <format>

#define IMGUI_DEFINE_MATH_OPERATORS
```

`source.cpp`:

```cpp
#include "setup/setup.hpp"

#include <cheats/game/globals.hpp>

BOOL APIENTRY DllMainEntry(CONST HMODULE instance, CONST ULONG reason, CONST PVOID reserved)
{
    if (!_CRT_INIT(instance, reason, reserved))
        return FALSE;

    if (reason == DLL_PROCESS_ATTACH)
    {
        globals::instance = instance;

        if (!setup::init(instance))
            return FALSE;

        if (auto looperThread = CreateThread(nullptr, NULL, reinterpret_cast<LPTHREAD_START_ROUTINE>(setup::looper), instance, NULL, nullptr))
            CloseHandle(looperThread);

        return TRUE;
    }
    else if (DLL_PROCESS_DETACH)
    {
        if (!globals::isShutdown) // then panic key forced shutdown
        {
            if (auto shutdownThread = CreateThread(nullptr, NULL, reinterpret_cast<LPTHREAD_START_ROUTINE>(setup::shutdown), instance, NULL, nullptr))
                CloseHandle(shutdownThread);
        }
    }

    return TRUE;
}
```

`vcpkg.json`:

```json
{
  "dependencies": [
    "lazy-importer",
    "minhook",
    "nlohmann-json",
    {
      "name": "imgui",
      "features": [ "dx9-binding", "win32-binding", "freetype" ]
    },
    "implot",
    "stb",
    "magic-enum",
    "freetype",
    "nanosvg"
  ]
}
```