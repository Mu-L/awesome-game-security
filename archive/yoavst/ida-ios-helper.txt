Project Path: arc_yoavst_ida-ios-helper_coxzsk5y

Source Tree:

```txt
arc_yoavst_ida-ios-helper_coxzsk5y
├── LICENSE
├── README.md
├── ida-plugin.json
├── ida_plugin_stub.py
├── pyproject.toml
├── res
│   ├── jump_to_selector_xrefs.png
│   ├── jump_to_virtual_call.png
│   └── logo.png
├── src
│   ├── ioshelper
│   │   ├── __init__.py
│   │   ├── base
│   │   │   ├── __init__.py
│   │   │   ├── reloadable_plugin.py
│   │   │   └── utils.py
│   │   ├── core.py
│   │   ├── ida_plugin.py
│   │   └── plugins
│   │       ├── __init__.py
│   │       ├── common
│   │       │   ├── __init__.py
│   │       │   ├── clang_blocks
│   │       │   │   ├── __init__.py
│   │       │   │   ├── analyze_byref_args.py
│   │       │   │   ├── block.py
│   │       │   │   ├── block_arg_byref.py
│   │       │   │   ├── optimize_blocks_init.py
│   │       │   │   └── utils.py
│   │       │   ├── globals.py
│   │       │   ├── jump_to_string
│   │       │   │   ├── __init__.py
│   │       │   │   └── jump_to_string.py
│   │       │   ├── outline
│   │       │   │   ├── __init__.py
│   │       │   │   └── outline.py
│   │       │   ├── range_condition
│   │       │   │   ├── __init__.py
│   │       │   │   └── range_condition.py
│   │       │   ├── run_callback.py
│   │       │   └── segment_xrefs
│   │       │       ├── __init__.py
│   │       │       └── segment_xrefs.py
│   │       ├── kernelcache
│   │       │   ├── __init__.py
│   │       │   ├── cpp_vtbl
│   │       │   │   ├── __init__.py
│   │       │   │   └── cpp_vtbl.py
│   │       │   ├── func_renamers
│   │       │   │   ├── __init__.py
│   │       │   │   ├── external.py
│   │       │   │   ├── func_renamers.py
│   │       │   │   ├── handlers.py
│   │       │   │   ├── pac_applier.py
│   │       │   │   ├── renamer.py
│   │       │   │   └── visitor.py
│   │       │   ├── generic_calls_fix
│   │       │   │   ├── __init__.py
│   │       │   │   └── generic_calls_fix.py
│   │       │   ├── kalloc_type
│   │       │   │   ├── __init__.py
│   │       │   │   └── kalloc_type.py
│   │       │   └── obj_this
│   │       │       ├── __init__.py
│   │       │       └── obj_this.py
│   │       ├── objc
│   │       │   ├── __init__.py
│   │       │   ├── objc_ref
│   │       │   │   ├── __init__.py
│   │       │   │   └── objc_ref.py
│   │       │   ├── objc_refcnt
│   │       │   │   ├── __init__.py
│   │       │   │   └── optimizer.py
│   │       │   ├── objc_sugar
│   │       │   │   ├── __init__.py
│   │       │   │   └── objc_sugar.py
│   │       │   └── oslog
│   │       │       ├── __init__.py
│   │       │       ├── error_case_optimizer.py
│   │       │       ├── log_enabled_optimizer.py
│   │       │       ├── log_macro_optimizer.py
│   │       │       └── os_log.py
│   │       └── swift
│   │           ├── swift_strings
│   │           │   ├── __init__.py
│   │           │   ├── swift_string.py
│   │           │   └── swift_string_fixup.py
│   │           └── swift_types
│   │               ├── __init__.py
│   │               └── swift_types.py
│   └── scripts
│       ├── field_search.py
│       └── fix_dyld_xrefs.py
├── uv.lock
└── vermin.ini

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# IDA iOS Helper

A plugin for IDA Pro 9.0+ to help with iOS code analysis.

## Supported features

- KernelCache
    - Calls to `OSBaseClass::safeMetaCast` apply type info on the result.
    - Calls to `OSObject_typed_operator_new` apply type info on the result.
    - When the keyboard is on a virtual call (`cls->vcall()`), Shift+X will show a dialog with all the possible
      implementations of the virtual method. It requires vtable symbols to be present.
    - When in a C++ method named Class::func, Ctrl+T will change the first argument to `Class* this`. Also works for
      Obj-C instance methods.
    - Name globals from `OSSymbol::fromConst*` calls, locals from `get/setProperty` calls, ...
    - Rename and type all global kalloc_type_view. Use their signature to mark fields as pointers for the actual types.
    - Create a struct from a kalloc_type_view.
- Objective-C
    - Hide memory management
      functions - `objc_retain`, `objc_release`, `objc_autorelease`, `objc_retainAutoreleasedReturnValue`.
        - Optimize `_objc_storeStrong` to an assignment.
    - collapse `__os_log_impl` calls.
    - Hide selectors and static classes from Objective-c calls.
    - When in Obj-C method, Ctrl+4 will show xrefs to the selector.
- Swift
    - Add swift types declarations to the IDA type system.
    - Detect stack swift string and add a syntactic sugar for them.
- Common
    - Remove `__break` calls.
    - collapse blocks initializers and detect `__block` variables (use Alt+Shift+S to trigger detection).
    - Use `Ctrl+S` to jump to function by a string constant found in the code
    - Transform ranged conditions to a more readable form.
    - Try to detect outline functions and mark them as such.
    - Use `Ctrl+Shift+X` to find xrefs to a field inside a segment. This will decompile the whole segment and then
      search for the field.

## Installation

1. Install this package using your IDA's python pip: `pip install ida-ios-helper`
2. copy `ida-plugin.json` and `ida_plugin_stub.py` to your IDA's plugins folder: `~/.idapro/plugins/ida-ios-helper`.
3. Restart IDA.

## Examples

### Solve condition constraints

Before:

```c
if ( valueLength - 21 <= 0xFFFFFFFFFFFFFFEFLL ) 
{ 
  ... 
}
```

After:

```c
if ( 4 < valueLength || valueLength < 21 )
{
  ...
}
```

### Remove `__break`

Before:

```c
    if ( ((v6 ^ (2 * v6)) & 0x4000000000000000LL) != 0 )
      __break(0xC471u);
```

After: removed.

### Hide selectors of Obj-C calls

Before:

```c
   -[NSFileManager removeItemAtPath:error:](
      +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),
      "removeItemAtPath:error:",
      +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *(_QWORD *)&buf[v5]),
      0LL);
```

After:

```c
   -[NSFileManager removeItemAtPath:error:](
      +[NSFileManager defaultManager](),
      +[NSString stringWithUTF8String:](*(_QWORD *)&buf[v5]),
      0LL);
```

### Block initializers

Before:

```c
v10 = 0LL;
v15 = &v10;
v16 = 0x2000000000LL;
v17 = 0;
if ( a1 )
{
  x0_8 = *(NSObject **)(a1 + 16);
  v13.isa = _NSConcreteStackBlock;
  *(_QWORD *)&v13.flags = 0x40000000LL;
  v13.invoke = func_name_block_invoke;
  v13.descriptor = &stru_100211F48;
  v13.lvar3 = a1;
  v13.lvar4 = a2;
  v13.lvar1 = a3;
  v13.lvar2 = &v10;
  dispatch_sync(queue: x0_8, block: &v13);
  v11 = *((_BYTE *)v15 + 24);
}
else
{
  v11 = 0;
}
_Block_object_dispose(&v10, 8);
return v11 & 1;
```

After:

```c
v10 = _byref_block_arg_init(0);
v10.value = 0;
if ( a1 )
{
  v6 = *(NSObject **)(a1 + 16);
  v9 = _stack_block_init(0x40000000, &stru_100211F48, func_name_block_invoke);
  v9.lvar3 = a1;
  v9.lvar4 = a2;
  v9.lvar1 = a3;
  v9.lvar2 = &v10;
  dispatch_sync(queue: v6, block: &v9);
  value = v10.forwarding->value;
}
else
{
  value = 0;
}
return value & 1;
```

### Collapse `os_log`

Before:

```c
  v9 = gLogObjects;
  v10 = gNumLogObjects;
  if ( gLogObjects && gNumLogObjects >= 46 )
  {
    v11 = *(NSObject **)(gLogObjects + 360);
  }
  else
  {
    v11 = (NSObject *)&_os_log_default;
    if ( ((v6 ^ (2 * v6)) & 0x4000000000000000LL) != 0 )
      __break(0xC471u);
    if ( os_log_type_enabled(oslog: (os_log_t)&_os_log_default, type: OS_LOG_TYPE_ERROR) )
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)v54 = v9;
      *(_WORD *)&v54[8] = 1024;
      *(_DWORD *)&v54[10] = v10;
      if ( ((v6 ^ (2 * v6)) & 0x4000000000000000LL) != 0 )
        __break(0xC471u);
      _os_log_error_impl(
        dso: (void *)&_mh_execute_header,
        log: (os_log_t)&_os_log_default,
        type: OS_LOG_TYPE_ERROR,
        format: "Make sure you have called init_logging()!\ngLogObjects: %p, gNumLogObjects: %d",
        buf: buf,
        size: 0x12u);
    }
  }
  if ( ((v6 ^ (2 * v6)) & 0x4000000000000000LL) != 0 )
    __break(0xC471u);
  if ( os_log_type_enabled(oslog: v11, type: OS_LOG_TYPE_INFO) )
  {
    if ( a1 )
      v12 = *(_QWORD *)(a1 + 8);
    else
      v12 = 0LL;
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)v54 = v12;
    if ( ((v6 ^ (2 * v6)) & 0x4000000000000000LL) != 0 )
      __break(0xC471u);
    _os_log_impl(
      dso: (void *)&_mh_execute_header,
      log: v11,
      type: OS_LOG_TYPE_INFO,
      format: "Random log %@",
      buf: buf,
      size: 0xCu);
  }
```

after:

```c
  if ( oslog_info_enabled() )
  {
    if ( a1 )
      v4 = *(_QWORD *)(a1 + 8);
    else
      v4 = 0LL;
    oslog_info("Random log %@", v4);
  }
```

## Automatic casts with `OSBaseClass::safeMetaCast`

Before:

```c++
 OSObject *v5;
 v5 = OSBaseClass::safeMetaCast(a2, &IOThunderboltController::metaClass);
```

After:

```c++
 IOThunderboltController *v5;
 v5 = OSDynamicCast<IOThunderboltController>(a2);
```

## Automatic typing for `OSObject_typed_operator_new`

Run `Edit->Plugins->iOSHelper->Locate all kalloc_type_view` before.

Before:

```c++
IOAccessoryPowerSourceItemUSB_TypeC_Current *sub_FFFFFFF009B2AA14()
{
  OSObject *v0; // x19

  v0 = (OSObject *)OSObject_typed_operator_new(&UNK_FFFFFFF007DBC480, size: 0x38uLL);
  OSObject::OSObject(this: v0, &IOAccessoryPowerSourceItemUSB_TypeC_Current::gMetaclass)->__vftable = (OSObject_vtbl *)off_FFFFFFF007D941B0;
  OSMetaClass::instanceConstructed(this: &IOAccessoryPowerSourceItemUSB_TypeC_Current::gMetaclass);
  return (IOAccessoryPowerSourceItemUSB_TypeC_Current *)v0;
}
```

After:

```c++
IOAccessoryPowerSourceItemUSB_TypeC_Current *sub_FFFFFFF009B2AA14()
{
  IOAccessoryPowerSourceItemUSB_TypeC_Current *v0; // x19

  v0 = OSObjectTypeAlloc<IOAccessoryPowerSourceItemUSB_TypeC_Current>(0x38uLL);
  OSObject::OSObject(this: v0, &IOAccessoryPowerSourceItemUSB_TypeC_Current::gMetaclass)->__vftable = (OSObject_vtbl *)off_FFFFFFF007D941B0;
  OSMetaClass::instanceConstructed(this: &IOAccessoryPowerSourceItemUSB_TypeC_Current::gMetaclass);
  return v0;
}
```

## Jump to virtual call

Use `Shift+X` on a virtual call to jump.

![Jump to virtual call](res/jump_to_virtual_call.png)

## Xrefs to selector

Use `Ctrl+4` inside an Objective-C method to list xrefs to its selector.

![Jump to selector](res/jump_to_selector_xrefs.png)

## Rename function by argument of logging function

Given that the code contains calls like:

```c
log("func_name", ....);
```

You could use `rename_function_by_arg` to mass rename all functions that contain such calls.

```python
rename_function_by_arg(func_name="log", arg_index=0, prefix="_", force_name_change=False)
```

This will run on all the functions that call the log function, and rename them to the first argument of the call.

## Call the plugin from python

```python
import idaapi

# Call global analysis
idaapi.load_and_run_plugin("iOS Helper", 1)


# Call local analysis
def write_ea_arg(ea: int):
    n = idaapi.netnode()
    n.create("$ idaioshelper")
    n.altset(1, ea, "R")


write_ea_arg(func_ea)
idaapi.load_and_run_plugin("iOS Helper", 2)
```

## Development

In order to have autocomplete while developing, you need to add IDA's include folder ( `$IDA_INSTALLATION/python/3` ) to
your IDE.

- on Visual Studio code you can add the folder to the analyzer's extra paths in the `settings.json` file:

```json
{
  "python.analysis.extraPaths": [
    "$IDA_INSTALLATION\\python\\3"
  ]
}
```

- on PyCharm you can add the folder to the interpreter's paths in the project settings.
  Alternatively, you can create `idapython.pth` in `$VENV_FOLDER/Lib/site-packages` and add the path to it.

Inside IDA, you can use `ioshelper.reload()` to reload the plugin during development.
If you create file name `DEBUG` inside `src/`, then you can use `F2` to reload the
plugin.
```

`ida-plugin.json`:

```json
{
    "IDAMetadataDescriptorVersion": 1,
    "plugin": {
        "name": "iOSHelper",
        "description": "A plugin for IDA Pro 9.0+ to help with iOS code analysis.",
        "entryPoint": "ida_plugin_stub.py",
        "categories": ["decompilation"],
        "idaVersions": ">=9.0",
        "version": "1.0.19",
        "logoPath": "res/logo.png",
        "keywords": ["ios", "objc", "swift", "kernel-cache"],
        "license": "GPL-3.0",
        "pythonDependencies": ["ida-ios-helper==1.0.19"],
        "urls": {"repository": "https://github.com/yoavst/ida-ios-helper"},
        "authors": [{"name": "Yoav Sternberg", "email": "yoav.sternberg@gmail.com"}]
    }
}

```

`ida_plugin_stub.py`:

```py
"""
This is a stub file to be dropped in IDA plugins directory (usually ~/.idapro/plugins)
You should install ida-ios-helper package globally in your python installation (When developing, use an editable install...)
Make sure that this is the python version that IDA is using (otherwise you can switch with idapyswitch...)
Then copy:
- ida_plugin_stub.py to ~/idapro/plugins/ida_ios_helper/ida_plugin_stub.py
- ida-plugin.json to ~/idapro/plugins/ida_ios_helper/ida_plugin.json
"""

# noinspection PyUnresolvedReferences
__all__ = ["PLUGIN_ENTRY", "iOSHelperPlugin"]
try:
    from ioshelper.ida_plugin import PLUGIN_ENTRY, iOSHelperPlugin
except ImportError:
    print("[Error] Could not load ida-ios-helper plugin. ida-ios-helper Python package doesn't seem to be installed.")

```

`pyproject.toml`:

```toml
[project]
name = "ida-ios-helper"
dynamic = ['version']
description = "IDA Plugin for ease the reversing of iOS' usermode and kernelcache."
authors = [
    { name = "Yoav Sternberg", email = "yoav.sternberg@gmail.com" },
]
readme = "README.md"
repository = "https://github.com/yoavst/ida-ios-helper"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
    "Operating System :: OS Independent",
]

requires-python = ">=3.10"
dependencies = [
    "idahelper==1.0.18",
]

[project.urls]
Homepage = "https://github.com/yoavst/ida-ios-helper"
Issues = "https://github.com/yoavst/ida-ios-helper/issues"

[build-system]
requires = ["hatchling", "hatch-vcs"]
build-backend = "hatchling.build"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "only-version"
local_scheme = "no-local-version"

[tool.hatch.build.targets.wheel]
packages = ["src/ioshelper"]

[dependency-groups]
dev = [
    "ruff>=0.12.2",
    "vermin>=1.6.0",
]

[tool.ruff]
target-version = "py310"
line-length = 120
fix = true

[tool.ruff.lint]
select = [
    # flake8-2020
    "YTT",
    # flake8-bandit
    "S",
    # flake8-bugbear
    "B",
    # flake8-builtins
    "A",
    # flake8-comprehensions
    "C4",
    # flake8-debugger
    "T10",
    # flake8-simplify
    "SIM",
    # isort
    "I",
    # mccabe
    "C90",
    # pycodestyle
    "E",
    "W",
    # pyflakes
    "F",
    # pygrep-hooks
    "PGH",
    # pyupgrade
    "UP",
    # ruff
    "RUF",
    # tryceratops
    "TRY",
]
ignore = [
    # LineTooLong
    "E501",
    # DoNotAssignLambda
    "E731",
    # Asserts
    "S101",
    # Name for classes
    "N801",
    # Custom error classes
    "TRY003"
]

[tool.ruff.format]
preview = true

```

`src/ioshelper/base/reloadable_plugin.py`:

```py
# This code was inspired by Lucid's plugin core, which is licensed under the MIT License.
# However, this is a complete rewrite that only contains the _startup_hooks part from the original code.
# As such, I find it acceptable to use this code under the same license as the rest of the plugin.
# https://github.com/gaasedelen/lucid/blob/master/plugins/lucid/core.py
import abc
import contextlib
import dataclasses
import sys
from collections.abc import Callable
from pathlib import Path
from typing import Protocol

import ida_diskio
import ida_hexrays
import ida_idaapi
import ida_kernwin
import idaapi
from ida_idaapi import plugin_t
from ida_kernwin import UI_Hooks, action_desc_t

IS_DEBUG = (Path(__file__).parent.parent.parent / "DEBUG").exists()

DISABLED_PLUGINS_PATH = Path(ida_diskio.get_user_idadir()) / "ioshelper_disabled_plugins.txt"


def get_disabled_plugins() -> set[str]:
    """Return a list of disabled plugins."""
    if not DISABLED_PLUGINS_PATH.exists():
        return set()

    disabled_plugins: set[str] = set()
    with DISABLED_PLUGINS_PATH.open("r") as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith("#"):
                disabled_plugins.add(line)
    return disabled_plugins


class Component:
    """
    A component is a self-contained piece of functionality that can be loaded and unloaded independently.
    It will only be loaded and unloaded when the plugin core is loaded and unloaded.
    However, it can be mounted and unmounted independently of the plugin core.
    """

    def __init__(self, name: str, core: "PluginCore"):
        self.name = name
        self.core = core

    def load(self) -> bool:
        """Load the component and all the relevant resources"""
        return True

    def mount(self) -> bool:
        """Enable the functionality of the component"""
        return True

    def unmount(self):
        """Disable the functionality of the component"""
        pass

    def unload(self):
        """Unload the component and all the relevant resources"""
        pass


ComponentFactory = Callable[["PluginCore"], Component]
RunCallbackFactory = Callable[["PluginCore"], Callable[[int], None]]


class PluginCoreFactory(Protocol):
    def __call__(self, defer_load: bool, should_mount: bool) -> float: ...


class PluginCore:
    def __init__(
        self,
        name: str,
        component_factories: list[ComponentFactory],
        run_callback_factory: RunCallbackFactory,
        defer_load: bool = False,
        should_mount: bool = True,
    ):
        self.name = name
        self.run_callback = run_callback_factory(self)
        self.loaded = False
        self.mounted = False
        all_components = [factory(self) for factory in component_factories]
        self._components = [component for component in all_components if component.name not in get_disabled_plugins()]

        # we can 'defer' the load of the plugin core a little bit. this
        # ensures that all the other plugins (eg, decompilers) can get loaded
        # and initialized when opening an idb/bin

        def perform_load():
            self.load()
            if should_mount:
                self.mount()

        class UIHooks(UI_Hooks):
            def ready_to_run(self):
                perform_load()

        self._startup_hooks = UIHooks()

        if defer_load:
            self._startup_hooks.hook()
        else:
            perform_load()

    def load(self):
        self._startup_hooks.unhook()

        if not ida_hexrays.init_hexrays_plugin():
            print(f"[{self.name}] failed to load hex-rays plugin, aborting load.")
            return

        print(f"[{self.name}] loading plugin")
        for component in self._components:
            print(f"[{self.name}] loading component {component.name}")
            if not component.load():
                print(f"[{self.name}] failed to load component {component.name}, aborting load.")
                return

        self.loaded = True

    def mount(self):
        if not self.mounted:
            for component in self._components:
                if self.should_mount(component):
                    print(f"[{self.name}] mounting component {component.name}")
                    if not component.mount():
                        print(f"[{self.name}] failed to mount component {component.name}, aborting mount.")
                        return
            self.mounted = True

    def unmount(self):
        if self.mounted:
            for component in self._components:
                print(f"[{self.name}] unmounting component {component.name}")
                component.unmount()

            self.mounted = False

    def unload(self):
        """
        Unload the plugin core.
        """

        # unhook just in-case load() was never actually called...
        self._startup_hooks.unhook()

        # if the core was never fully loaded, there's nothing else to do
        if not self.loaded:
            return

        print(f"[{self.name}] unloading plugin")

        # mark the core as 'unloaded' and teardown its components
        self.loaded = False

        self.unmount()
        for component in self._components:
            print(f"[{self.name}] unloading component {component.name}")
            component.unload()

    def should_mount(self, _component: Component) -> bool:
        """
        Determine if a component should be mounted based on the current state of the plugin core.
        In the future, we will implement a more sophisticated system to determine if a component should be mounted.
        """
        return True

    def run(self, arg: int):
        """
        Proxy for the `run` method of the plugin_t interface.
        """
        self.run_callback(arg)

    @staticmethod
    def factory(
        name: str, component_factories: list[ComponentFactory], run_callback_factory: RunCallbackFactory
    ) -> PluginCoreFactory:
        def plugin_core_factory(defer_load: bool, should_mount: bool) -> PluginCore:
            return PluginCore(
                name, component_factories, run_callback_factory, defer_load=defer_load, should_mount=should_mount
            )

        # The type checker seems to have trouble with the factory method, so we need to suppress it
        # noinspection PyTypeChecker
        return plugin_core_factory


class ReloadablePlugin(abc.ABC, plugin_t):
    def __init__(
        self,
        global_name: str,
        base_package_name: str,
        plugin_core_factory: PluginCoreFactory,
        extra_packages_to_reload: list[str] | None = None,
    ):
        super().__init__()
        self._global_name = global_name
        self._plugin_core_factory = plugin_core_factory
        self._base_package_name = base_package_name
        self.core: PluginCore | None = None
        self._reload_plugin_action_id = f"{self._global_name}:reload_plugin"
        self.extra_packages_to_reload = extra_packages_to_reload or []

    def init(self) -> int:
        self.core = self._plugin_core_factory(defer_load=True, should_mount=True)
        # Provide access from ida python console
        setattr(sys.modules["__main__"], self._global_name, self)
        # register the reload action
        idaapi.register_action(
            idaapi.action_desc_t(
                self._reload_plugin_action_id,
                f"Reload plugin: {getattr(self, 'wanted_name', self._global_name)}",
                PluginReloadActionHandler(self),
                "f2" if IS_DEBUG else None,
            )
        )
        # Keep plugin alive
        return ida_idaapi.PLUGIN_KEEP

    def term(self) -> None:
        idaapi.unregister_action(self._reload_plugin_action_id)
        if self.core is not None:
            self.core.unload()

    def run(self, arg: int):
        if self.core is not None:
            self.core.run(arg)

    def reload(self):
        """Hot-reload the plugin core."""
        print(f"[{getattr(self, 'wanted_name', 'plugin')}] Reloading...")

        # Unload the core and all its components
        was_mounted = self.core.mounted if self.core else True
        if self.core is not None:
            self.core.unload()

        # Reload all modules in the base package
        modules_to_reload = [module_name for module_name in sys.modules if self.should_reload_pkg(module_name)]
        for module_name in modules_to_reload:
            with contextlib.suppress(ModuleNotFoundError):
                idaapi.require(module_name)

        # Load the plugin core
        self.core = self._plugin_core_factory(defer_load=False, should_mount=was_mounted)

    def should_reload_pkg(self, module_name: str) -> bool:
        """Should we reload this module on reloading the plugin?"""
        if module_name.startswith(self._base_package_name):
            return True
        return any(module_name.startswith(prefix) for prefix in self.extra_packages_to_reload)


class PluginReloadActionHandler(ida_kernwin.action_handler_t):
    def __init__(self, plugin: ReloadablePlugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.reload()
        print("Reloaded plugin!")
        return 1

    def update(self, ctx) -> int:
        return idaapi.AST_ENABLE_ALWAYS


# A common type of component is installing optimizers for the decompiler. This is a helper class to make it easier.

optimizer_t = ida_hexrays.optblock_t | ida_hexrays.optinsn_t
optimizer_factory_t = Callable[[], optimizer_t]


class OptimizersComponent(Component):
    def __init__(self, name: str, core: PluginCore, optimizer_factories: list[optimizer_factory_t]):
        super().__init__(name, core)
        self._optimizer_factories = optimizer_factories
        self._optimizers: list[optimizer_t] | None = None

    def load(self) -> bool:
        self._optimizers = [factory() for factory in self._optimizer_factories]
        return True

    def mount(self) -> bool:
        assert self._optimizers is not None, "Load must be called before mount"

        for optimizer in self._optimizers:
            optimizer.install()
        return True

    def unmount(self):
        assert self._optimizers is not None, "Load must be called before unmount"

        for optimizer in self._optimizers:
            optimizer.remove()

    def unload(self):
        self._optimizers = None

    @staticmethod
    def factory(name: str, optimizer_factories: list[optimizer_factory_t]) -> ComponentFactory:
        return lambda core: OptimizersComponent(name, core, optimizer_factories)


@dataclasses.dataclass
class UIAction:
    id: str
    action_desc: action_desc_t
    menu_location: str | None = None
    dynamic_menu_add: Callable[["TWidget *", "TPopupMenu *"], bool] | None = None  # noqa: F722

    @staticmethod
    def base_location(core: PluginCore) -> str:
        """
        Returns the base location for the plugin's UI actions.
        This is used to create a unique menu location for the actions.
        """
        return f"Edit/Plugins/{core.name}/"


class UIActionsComponentUIHooks(idaapi.UI_Hooks):
    def __init__(self, actions: list[UIAction]):
        super().__init__()
        self._actions = actions

    def finish_populating_widget_popup(self, widget, popup):
        for action in self._actions:
            if action.dynamic_menu_add is not None and action.dynamic_menu_add(widget, popup):
                idaapi.attach_action_to_popup(widget, popup, action.id)


# Another common type of component is installing ui actions. This is a helper class to make it easier.
class UIActionsComponent(Component):
    def __init__(self, name: str, core: PluginCore, action_factories: list[Callable[[PluginCore], UIAction]]):
        super().__init__(name, core)
        self._action_factories = action_factories
        self._actions: list[UIAction] | None = None
        self._ui_hooks: UI_Hooks | None = None

    def load(self) -> bool:
        self._actions = [factory(self.core) for factory in self._action_factories]
        if any(action.dynamic_menu_add is not None for action in self._actions):
            # Create a UI_Hooks instance to attach the dynamic menu
            self._ui_hooks = UIActionsComponentUIHooks(self._actions)
            self._ui_hooks.hook()

        for action in self._actions:
            if not idaapi.register_action(action.action_desc):
                print(f"[{self.name}] failed to register action {action.id}, aborting load.")
                return False

            if action.menu_location is not None and not idaapi.attach_action_to_menu(
                action.menu_location,
                action.id,
                0,
            ):
                print(
                    f"[{self.name}] failed to attach action {action.id} to menu {action.menu_location}, aborting load."
                )
                return False

        return True

    def unload(self):
        for action in self._actions:
            idaapi.unregister_action(action.id)

        if self._ui_hooks is not None:
            self._ui_hooks.unhook()

    @staticmethod
    def factory(name: str, action_factories: list[Callable[[PluginCore], UIAction]]) -> ComponentFactory:
        return lambda core: UIActionsComponent(name, core, action_factories)


# A common type of component is installing hooks for the decompiler. This is a helper class to make it easier.
class HexraysHookComponent(Component):
    def __init__(self, name: str, core: PluginCore, hook_factories: list[Callable[[], ida_hexrays.Hexrays_Hooks]]):
        super().__init__(name, core)
        self._hook_factories = hook_factories
        self._hooks: list[ida_hexrays.Hexrays_Hooks] | None = None

    def load(self):
        self._hooks = [hook_factory() for hook_factory in self._hook_factories]
        return True

    def mount(self) -> bool:
        assert self._hooks is not None, "load() must be called before mount()"
        for hook in self._hooks:
            hook.hook()
        return True

    def unmount(self):
        if self._hooks is not None:
            for hook in self._hooks:
                hook.unhook()

    def unload(self):
        self._hooks = None

    @staticmethod
    def factory(name: str, hook_factories: list[Callable[[], ida_hexrays.Hexrays_Hooks]]) -> ComponentFactory:
        return lambda core: HexraysHookComponent(name, core, hook_factories)


class StartupScriptComponent(Component):
    def __init__(self, name: str, core: PluginCore, callbacks: list[Callable[[], None]]):
        super().__init__(name, core)
        self._callbacks = callbacks

    def load(self):
        return True

    def mount(self) -> bool:
        for callback in self._callbacks:
            callback()
        return True

    def unmount(self):
        pass

    def unload(self):
        pass

    @staticmethod
    def factory(name: str, callbacks: list[Callable[[], None]]) -> ComponentFactory:
        return lambda core: StartupScriptComponent(name, core, callbacks)

```

`src/ioshelper/base/utils.py`:

```py
import contextlib
import re
from collections.abc import Callable, Hashable, Iterable, Iterator
from functools import wraps
from typing import Generic, TypeVar, overload


class CounterMixin:
    cnt: int = 0

    def count(self, amount: int = 1):
        self.cnt += amount


def match(arr: list[str | re.Pattern], item: str) -> bool:
    """Match a string against a list of strings or regex patterns."""
    for pat in arr:
        if isinstance(pat, str):
            if item == pat:
                return True
        else:
            if pat.match(item):
                return True
    return False


T = TypeVar("T")


def match_dict(patterns: dict[str | re.Pattern, T], item: str) -> T | None:
    """match a string against a dictionary of strings or regex patterns, Returns the value if matched."""
    for pat, val in patterns.items():
        if isinstance(pat, str):
            if item == pat:
                return val
        else:
            if pat.match(item):
                return val
    return None


K = TypeVar("K")
V = TypeVar("V")


class CustomDict(Generic[K, V]):
    def __init__(self, hasher: Callable[[K], Hashable]):
        self._hasher = hasher
        self._storage: dict[Hashable, tuple[K, V]] = {}

    def __setitem__(self, key: K, value: V):
        self._storage[self._hasher(key)] = (key, value)

    def __getitem__(self, key: K) -> V:
        return self._storage[self._hasher(key)][1]

    def __delitem__(self, key: K):
        del self._storage[self._hasher(key)]

    def __contains__(self, key: K) -> bool:
        return self._hasher(key) in self._storage

    def __str__(self) -> str:
        return f"{{ {', '.join(f'{key}: {value}' for key, value in self._storage.values())} }}"

    @overload
    def get(self, key: K) -> V | None: ...

    @overload
    def get(self, key: K, default: V) -> V: ...

    @overload
    def get(self, key: K, default: V | None) -> V | None: ...

    def get(self, key: K, default: V | None = None):
        if key in self:
            return self[key]
        return default

    def setdefault(self, key: K, default: V) -> V:
        cur = self.get(key)
        if cur is not None:
            return cur

        self[key] = default
        return default

    def __len__(self) -> int:
        return len(self._storage)

    def keys(self) -> Iterator[K]:
        return (k for k, _ in self._storage.values())

    def values(self) -> Iterator[V]:
        return (v for _, v in self._storage.values())

    def items(self) -> Iterator[tuple[K, V]]:
        return iter(self._storage.values())

    def __iter__(self) -> Iterator[K]:
        return self.keys()

    def __bool__(self) -> bool:
        return bool(self._storage)


class CustomSet(Generic[V]):
    def __init__(self, hasher: Callable[[V], Hashable]):
        self._hasher = hasher
        self._storage: dict[Hashable, V] = {}

    def add(self, value: V):
        self._storage[self._hasher(value)] = value

    def add_all(self, items: Iterator[V] | Iterable[V]):
        for item in items:
            self.add(item)

    def remove(self, value: V):
        del self._storage[self._hasher(value)]

    def discard(self, value: V):
        with contextlib.suppress(KeyError):
            self.remove(value)

    def __contains__(self, value: V) -> bool:
        return self._hasher(value) in self._storage

    def __len__(self) -> int:
        return len(self._storage)

    def __iter__(self) -> Iterator[V]:
        return iter(self._storage.values())

    def __bool__(self) -> bool:
        return bool(self._storage)

    def update(self, other: "CustomSet[V]") -> None:
        self._storage.update(other._storage)

    def __or__(self, other: "CustomSet[V]") -> "CustomSet[V]":
        new_set = CustomSet(self._hasher)
        new_set |= self
        new_set |= other
        return new_set

    def __ior__(self, other: "CustomSet[V]") -> "CustomSet[V]":
        self.update(other)
        return self

    def intersection_update(self, other: "CustomSet[V]") -> None:
        if not other:
            self._storage.clear()
            return

        self._storage = {k: self._storage[k] for k in (self._storage.keys() & other._storage.keys())}

    def __iand__(self, other: "CustomSet[V]") -> "CustomSet[V]":
        self.intersection_update(other)
        return self


def cache_fast(func: Callable[[], T]) -> Callable[[], T]:
    """Decorator to cache the result of a function for faster access."""
    cached_value: T | None = None

    @wraps(func)
    def wrapper():
        nonlocal cached_value
        if cached_value is None:
            cached_value = func()
        return cached_value

    return wrapper

```

`src/ioshelper/core.py`:

```py
__all__ = ["plugin_core"]

import ida_kernwin
import idaapi
from idahelper import file_format, widgets

from .base.reloadable_plugin import ComponentFactory, PluginCore, UIAction, UIActionsComponent
from .plugins.common.clang_blocks import clang_block_args_analyzer_component, clang_block_optimizer_component
from .plugins.common.globals import globals_component
from .plugins.common.jump_to_string import jump_to_string_component
from .plugins.common.outline import mark_outline_functions_component
from .plugins.common.range_condition import range_condition_optimizer_component
from .plugins.common.run_callback import run_callback
from .plugins.common.segment_xrefs import show_segment_xrefs_component
from .plugins.kernelcache.cpp_vtbl import jump_to_vtable_component
from .plugins.kernelcache.func_renamers import (
    apply_pac_component,
    local_func_renamer_component,
    mass_func_renamer_component,
)
from .plugins.kernelcache.generic_calls_fix import generic_calls_fix_component
from .plugins.kernelcache.kalloc_type import apply_kalloc_type_component, create_type_from_kalloc_component
from .plugins.kernelcache.obj_this import this_arg_fixer_component
from .plugins.objc.objc_ref import objc_xrefs_component
from .plugins.objc.objc_refcnt import component as objc_refcount_component
from .plugins.objc.objc_sugar import objc_sugar_component
from .plugins.objc.oslog import component as oslog_component
from .plugins.swift.swift_strings import swift_strings_component
from .plugins.swift.swift_types import swift_types_component

TOGGLE_ACTION_ID = "ioshelper:toggle"

toggle_ios_helper_mount_component = UIActionsComponent.factory(
    "toggle plugin mounting",
    [
        lambda core: UIAction(
            TOGGLE_ACTION_ID,
            idaapi.action_desc_t(
                TOGGLE_ACTION_ID,
                "Toggle iOS helper optimizations",
                IOSHelperToggleActionHandler(core),
            ),
            menu_location=UIAction.base_location(core),
        )
    ],
)


class IOSHelperToggleActionHandler(ida_kernwin.action_handler_t):
    def __init__(self, core: PluginCore):
        super().__init__()
        self.core = core

    def activate(self, ctx):
        if self.core.mounted:
            self.core.unmount()
        else:
            self.core.mount()

        widgets.refresh_pseudocode_widgets()

        print("Obj-C optimization are now:", "enabled" if self.core.mounted else "disabled")
        print("Note: You might need to perform decompile again for this change to take effect.")
        return 1

    def update(self, ctx) -> int:
        return idaapi.AST_ENABLE_ALWAYS


def get_modules_for_file() -> list[ComponentFactory]:
    return [
        *shared_modules(),
        *(objc_plugins() if file_format.is_objc() else []),
        *(kernel_cache_plugins() if file_format.is_kernelcache() else []),
    ]


def shared_modules() -> list[ComponentFactory]:
    return [
        this_arg_fixer_component,
        toggle_ios_helper_mount_component,
        clang_block_args_analyzer_component,
        clang_block_optimizer_component,
        jump_to_string_component,
        objc_refcount_component,
        range_condition_optimizer_component,
        mark_outline_functions_component,
        show_segment_xrefs_component,
        globals_component,
    ]


def objc_plugins() -> list[ComponentFactory]:
    return [
        oslog_component,
        objc_xrefs_component,
        objc_sugar_component,
        swift_types_component,
        swift_strings_component,
    ]


def kernel_cache_plugins() -> list[ComponentFactory]:
    return [
        jump_to_vtable_component,
        generic_calls_fix_component,
        local_func_renamer_component,
        mass_func_renamer_component,
        apply_kalloc_type_component,
        apply_pac_component,
        create_type_from_kalloc_component,
    ]


plugin_core = PluginCore.factory("iOSHelper", get_modules_for_file(), run_callback)

```

`src/ioshelper/ida_plugin.py`:

```py
import ida_idaapi
import idaapi
from ida_idaapi import plugin_t

from ioshelper.base.reloadable_plugin import PluginCore, ReloadablePlugin


# noinspection PyPep8Naming
class iOSHelperPlugin(ReloadablePlugin):
    flags = ida_idaapi.PLUGIN_HIDE
    wanted_name = "iOS helper"
    wanted_hotkey = ""
    comment = "Optimize iOS patterns in the code"
    help = ""

    def __init__(self):
        # Use lambda to plugin_core, so it could be fully reloaded from disk every time.
        # noinspection PyTypeChecker
        super().__init__("ioshelper", "ioshelper", plugin_core_wrapper_factory, extra_packages_to_reload=["idahelper"])


def plugin_core_wrapper_factory(*args, **kwargs) -> PluginCore:
    # Reload the module
    idaapi.require("ioshelper.core")
    # Bring the module into locals
    import ioshelper.core

    return ioshelper.core.plugin_core(*args, **kwargs)


# noinspection PyPep8Naming
def PLUGIN_ENTRY() -> plugin_t:
    return iOSHelperPlugin()

```

`src/ioshelper/plugins/common/clang_blocks/__init__.py`:

```py
__all__ = [
    "clang_block_args_analyzer_component",
    "clang_block_optimizer_component",
    "run_objc_plugin_on_func",
    "try_add_block_arg_byref_to_func",
]

import ida_kernwin
import idaapi
from idahelper import widgets

from ioshelper.base.reloadable_plugin import HexraysHookComponent, UIAction, UIActionsComponent

from .analyze_byref_args import try_add_block_arg_byref_to_func
from .optimize_blocks_init import objc_blocks_optimizer_hooks_t
from .utils import run_objc_plugin_on_func

ACTION_ID = "ioshelper:restore_llvm_block_args_byref"

clang_block_args_analyzer_component = UIActionsComponent.factory(
    "Clang Blocks - __block arguments",
    [
        lambda core: UIAction(
            ACTION_ID,
            idaapi.action_desc_t(
                ACTION_ID,
                "Analyze stack-allocated blocks and their __block args (current function)",
                ClangBlockDetectByrefAction(),
                "Alt+Shift+s",
            ),
            menu_location=UIAction.base_location(core),
        )
    ],
)

clang_block_optimizer_component = HexraysHookComponent.factory(
    "Clang Blocks - optimizer", [objc_blocks_optimizer_hooks_t]
)


class ClangBlockDetectByrefAction(ida_kernwin.action_handler_t):
    def activate(self, ctx: ida_kernwin.action_ctx_base_t):
        if ctx.cur_func is None:
            print("No function selected")
            return 0

        run_objc_plugin_on_func(ctx.cur_ea)
        widgets.refresh_pseudocode_widgets()
        if try_add_block_arg_byref_to_func(ctx.cur_func.start_ea):
            widgets.refresh_pseudocode_widgets()
        return 0

    def update(self, ctx) -> int:
        return idaapi.AST_ENABLE_ALWAYS

```

`src/ioshelper/plugins/common/clang_blocks/analyze_byref_args.py`:

```py
__all__ = ["try_add_block_arg_byref_to_func"]

from collections.abc import Callable
from dataclasses import dataclass

import ida_hexrays
from ida_hexrays import (
    cexpr_t,
    mba_t,
    minsn_t,
    mop_t,
)
from ida_typeinf import tinfo_t
from idahelper import tif
from idahelper.ast import cexpr, cfunc, lvars
from idahelper.ast.cexpr import getv
from idahelper.ast.lvars import VariableModification
from idahelper.microcode import mba, mblock, mop

from .block import (
    FLAG_BLOCK_HAS_COPY_DISPOSE,
    block_member_is_arg_field,
    get_ida_block_lvars,
)
from .block_arg_byref import (
    BlockArgByRefField,
    create_block_arg_byref_type,
    is_block_arg_byref_type,
)
from .utils import StructFieldAssignment, get_struct_fields_assignments


def try_add_block_arg_byref_to_func(ea: int) -> bool:
    func = cfunc.from_ea(ea)
    if func is None:
        print(f"Failed to decompile func at {ea:X}")
        return False

    block_lvars = get_ida_block_lvars(func)
    if not block_lvars:
        return False

    # Scan the cfunc for possible ref args for blocks
    assignments = get_struct_fields_assignments(func, block_lvars)
    stack_off_to_its_assignment: dict[int, StructFieldAssignment] = {}  # stack_offset -> assignment
    for lvar in block_lvars:
        if lvar.name not in assignments:
            print(f"[Error] Block variable {lvar.name} has no assignments")
            continue
        stack_off_to_its_assignment.update(get_by_ref_args_for_block_candidates(assignments[lvar.name]))

    if not stack_off_to_its_assignment:
        return False

    # scan the microcode using the offsets to see if any of them is a start of a by ref arg struct.
    lvar_modifications: dict[str, VariableModification] = {}  # lvar_name -> type_modification
    for result in ScanForRefArg(set(stack_off_to_its_assignment.keys())).scan(func.mba):
        new_type = create_block_arg_byref_type(result.initialization_ea, result.variable.size, result.has_helpers)
        block_arg_by_ref_lvar = cfunc.get_lvar_by_offset(func, result.initial_stack_offset)
        lvar_modifications[block_arg_by_ref_lvar.name] = VariableModification(type=new_type)

        # given: a.b = &block_by_ref, set b's type to block_by_ref*
        # It would not be a cast assign, as the type is already a pointer.
        assignment = stack_off_to_its_assignment[result.initial_stack_offset]
        set_new_type_for_member(assignment, tif.pointer_of(new_type))

    if lvar_modifications:
        # Apply new types for the lvars
        if not lvars.perform_lvar_modifications_by_ea(func.entry_ea, lvar_modifications):
            print("[Error] Failed to modify lvars")

        return True
    return False


def set_new_type_for_member(assignment: StructFieldAssignment, new_type: tinfo_t) -> bool:
    """Set the new type for the member of the struct"""
    if not tif.set_udm_type(assignment.type, assignment.member, new_type):
        print(f"[Error] Failed to set udm type for {assignment.member.name} in {assignment.type.get_type_name()}")
        return False
    return True


@dataclass
class ScanForBlockArgByRefState:
    current_field: BlockArgByRefField
    initialization_ea: int | None
    has_helpers: bool | None
    initial_stack_offset: int | None
    isa: mop_t | None
    flags: mop_t | None
    size: mop_t | None
    helper_keep: mop_t | None
    helper_dispose: mop_t | None
    variable: mop_t | None

    @staticmethod
    def initial() -> "ScanForBlockArgByRefState":
        return ScanForBlockArgByRefState(
            current_field=BlockArgByRefField.ISA,
            initialization_ea=None,
            has_helpers=None,
            initial_stack_offset=None,
            isa=None,
            flags=None,
            size=None,
            helper_keep=None,
            helper_dispose=None,
            variable=None,
        )

    def expected_offset(self) -> int:
        """Returns the expected relative offset for the next field to read"""
        assert self.initial_stack_offset is not None, "stack_offset must be set before calling expected_offset"

        return self.initial_stack_offset + self.current_field.get_offset(self.has_helpers)


class ScanForRefArg:
    def __init__(self, possible_stack_offsets: set[int]):
        self._state = ScanForBlockArgByRefState.initial()
        self._possible_stack_offsets = possible_stack_offsets
        self._results: list[ScanForBlockArgByRefState] = []
        self._state_handlers: dict[BlockArgByRefField, Callable[[mop_t, int], None]] = {
            BlockArgByRefField.ISA: self._isa,
            BlockArgByRefField.FORWARDING: self._forwarding,
            BlockArgByRefField.FLAGS: self._flags,
            BlockArgByRefField.SIZE: self._size,
            BlockArgByRefField.HELPER_KEEP: self._helper_keep,
            BlockArgByRefField.HELPER_DISPOSE: self._helper_dispose,
            BlockArgByRefField.VARIABLE: self._variable,
        }

    def scan(self, func_mba: mba_t) -> list[ScanForBlockArgByRefState]:
        # Clean state
        self._state = ScanForBlockArgByRefState.initial()
        self._results = []

        for block in mba.blocks(func_mba):
            for insn in mblock.instructions(block):
                self._on_instruction(insn)
        return self._results

    def _on_instruction(self, insn: minsn_t) -> None:
        # initialization of the block by reg arg is done using mov only.
        if insn.opcode != ida_hexrays.m_mov:
            self._state = ScanForBlockArgByRefState.initial()
            return

        # Check if the instruction is a mov to a stack variable
        offset = mop.get_stack_offset(insn.d)
        if offset is None:
            self._state = ScanForBlockArgByRefState.initial()
            return

        # Check if the write offset is correct
        if self._state.initial_stack_offset is not None and offset != self._state.expected_offset():
            self._state = ScanForBlockArgByRefState.initial()
            return

        if self._state.initialization_ea is None:
            self._state.initialization_ea = insn.ea

        self._state_handlers[self._state.current_field](insn.l, offset)

    def _isa(self, value: mop_t, offset: int) -> None:
        if (
            offset not in self._possible_stack_offsets
            or value.size != 8
            or value.t != ida_hexrays.mop_n
            or value.unsigned_value() != 0
        ):
            self._state = ScanForBlockArgByRefState.initial()
            return

        self._state.current_field = BlockArgByRefField.FORWARDING
        self._state.initial_stack_offset = offset
        self._state.isa = value

    def _forwarding(self, value: mop_t, _offset: int) -> None:
        if value.size != 8 or mop.get_stack_offset(value) != self._state.initial_stack_offset:
            self._state = ScanForBlockArgByRefState.initial()
            return

        self._state.current_field = BlockArgByRefField.FLAGS
        self._state.forwarding = value

    def _flags(self, value: mop_t, _offset: int) -> None:
        # Here we can encounter either a DWORD assignment for flags,
        # or a QWORD assignment for both the flags and size.
        if value.size not in (4, 8):
            self._state = ScanForBlockArgByRefState.initial()
            return

        numeric_value = mop.get_const_int(value, is_signed=False)
        if numeric_value is None:
            self._state = ScanForBlockArgByRefState.initial()
            return

        if value.size == 4:
            self._state.current_field = BlockArgByRefField.SIZE
            self._state.flags = value
            flags = numeric_value
        else:
            flags = numeric_value & 0xFF_FF_FF_FF
            size = (numeric_value >> 32) & 0xFFFF
            # Create new mop for size and flags
            self._state.flags = mop.from_const_value(flags, 4)
            self._state.size = mop.from_const_value(size, 4)

            if flags & FLAG_BLOCK_HAS_COPY_DISPOSE:
                self._state.has_helpers = True
                self._state.current_field = BlockArgByRefField.HELPER_KEEP
            else:
                self._state.has_helpers = False
                self._state.current_field = BlockArgByRefField.VARIABLE

    def _size(self, value: mop_t, _offset: int) -> None:
        if value.size != 4:
            self._state = ScanForBlockArgByRefState.initial()
            return

        # Check that value is a constant
        numeric_value = mop.get_const_int(value, is_signed=False)
        if numeric_value is None:
            self._state = ScanForBlockArgByRefState.initial()
            return

        self._state.size = value

        # Flags cannot be none because we checked it before
        flags = mop.get_const_int(self._state.flags, is_signed=False)
        if flags & FLAG_BLOCK_HAS_COPY_DISPOSE:
            self._state.has_helpers = True
            self._state.current_field = BlockArgByRefField.HELPER_KEEP
        else:
            self._state.has_helpers = False
            self._state.current_field = BlockArgByRefField.VARIABLE

    def _helper_keep(self, value: mop_t, _offset: int) -> None:
        if value.size != 8 or not value.is_glbaddr():
            self._state = ScanForBlockArgByRefState.initial()
            return

        self._state.helper_keep = value
        self._state.current_field = BlockArgByRefField.HELPER_DISPOSE

    def _helper_dispose(self, value: mop_t, _offset: int) -> None:
        if value.size != 8 or not value.is_glbaddr():
            self._state = ScanForBlockArgByRefState.initial()
            return

        self._state.helper_keep = value
        self._state.current_field = BlockArgByRefField.VARIABLE

    def _variable(self, value: mop_t, _offset: int) -> None:
        self._state.variable = value
        self._results.append(self._state)

        # Reset the state
        self._state = ScanForBlockArgByRefState.initial()


def get_by_ref_args_for_block_candidates(assignments: list[StructFieldAssignment]) -> dict[int, StructFieldAssignment]:
    """
    Filter assignments such that the rvalue is ref to stack variable.
    Return mapping of var_stack_offset to assignment
    """
    possible_stack_offsets = {}
    for assignment in assignments:
        stack_offset = -1
        # Skip fields that are not args
        if not block_member_is_arg_field(assignment.member):
            continue
        # Find assignments that are refs to the stack: "block.lvar2 = &v8" or, "block.lvar2 = v8" (and v8 is array type)
        expr = cexpr.strip_casts(assignment.expr)
        # block.lvar2 = &v8
        if expr.op == ida_hexrays.cot_ref:
            refed_expr: cexpr_t = expr.x
            if refed_expr.op != ida_hexrays.cot_var:
                continue
            # Check if the variable is not already handled
            if is_block_arg_byref_type(getv(refed_expr.v).type()):
                continue
            # Return the stack offset of the variable
            stack_offset = getv(refed_expr.v).get_stkoff()
        # block.lvar2 = v8 (and v8 is array type)
        elif expr.op == ida_hexrays.cot_var:
            # The variable could not have been handled, as it should be a ref in this case
            # Check it is an array type, as this is the only situation I can think of that
            # will represent a byref arg block and will not be a ref.
            if not getv(expr.v).type().is_array():
                continue
            stack_offset = getv(expr.v).get_stkoff()

        if stack_offset != -1:
            possible_stack_offsets[stack_offset] = assignment

    return possible_stack_offsets

```

`src/ioshelper/plugins/common/clang_blocks/block.py`:

```py
__all__ = [
    "FLAG_BLOCK_HAS_COPY_DISPOSE",
    "BlockBaseFieldsAssignments",
    "block_member_is_arg_field",
    "get_block_type",
    "get_ida_block_lvars",
    "is_block_type",
]

from dataclasses import dataclass

import ida_hexrays
from ida_hexrays import (
    cexpr_t,
    cfuncptr_t,
    cinsn_t,
    lvar_t,
)
from ida_typeinf import tinfo_t, udm_t
from idahelper.ast import cexpr

from .utils import StructFieldAssignment

IDA_BLOCK_TYPE_NAME_PREFIX = "Block_layout_"
IDA_BLOCK_TYPE_BASE_FIELD_NAMES = {
    "isa",
    "flags",
    "reserved",
    "invoke",
    "descriptor",
}

FLAG_BLOCK_HAS_COPY_DISPOSE = 1 << 25


def get_ida_block_lvars(func: cfuncptr_t) -> list[lvar_t]:
    """Get all Obj-C block variables in the function"""
    return [lvar for lvar in func.get_lvars() if is_block_type(lvar.type())]


def is_block_type(tinfo: tinfo_t) -> bool:
    """Check if the type is an Obj-C block type"""
    if not tinfo.is_struct():
        return False
    # noinspection PyTypeChecker
    name: str | None = tinfo.get_type_name()
    return name is not None and name.startswith(IDA_BLOCK_TYPE_NAME_PREFIX)


def block_member_is_arg_field(udm: udm_t) -> bool:
    """Check if the member is an argument field of an Obj-C block"""
    return udm.name not in IDA_BLOCK_TYPE_BASE_FIELD_NAMES


BLOCK_TYPES: dict[str, str] = {}
for typ in ["stack", "global", "malloc", "auto", "finalizing", "weak"]:
    typ_cap = typ.capitalize()
    BLOCK_TYPES[f"_NSConcrete{typ_cap}Block"] = typ
    BLOCK_TYPES[f"__NSConcrete{typ_cap}Block"] = typ
    BLOCK_TYPES[f"__NSConcrete{typ_cap}Block_ptr"] = typ
    BLOCK_TYPES[f"_OBJC_CLASS_$___NS{typ_cap}Block__"] = typ


def get_block_type(isa: str) -> str:
    """Get the block type from the isa symbol"""
    return BLOCK_TYPES.get(isa, "unknown")


@dataclass
class BlockBaseFieldsAssignments:
    assignments: list[cinsn_t]
    ea: int | None
    type: tinfo_t | None
    isa: cexpr_t | None
    flags: cexpr_t | None
    reserved: cexpr_t | None
    invoke: cexpr_t | None
    descriptor: cexpr_t | None

    def __str__(self) -> str:
        return (
            f"isa: {self.isa.dstr() if self.isa else 'None'}, "
            f"flags: {self.flags.dstr() if self.flags else 'None'}, "
            f"reserved: {self.reserved.dstr() if self.reserved else 'None'}, "
            f"invoke: {self.invoke.dstr() if self.invoke else 'None'}, "
            f"descriptor: {self.descriptor.dstr() if self.descriptor else 'None'}"
        )

    @staticmethod
    def initial() -> "BlockBaseFieldsAssignments":
        return BlockBaseFieldsAssignments(
            assignments=[], isa=None, flags=None, reserved=None, invoke=None, descriptor=None, type=None, ea=None
        )

    def is_completed(self) -> bool:
        """Check if all base fields have been assigned"""
        return (
            self.isa is not None
            and self.flags is not None
            and self.reserved is not None
            and self.invoke is not None
            and self.descriptor is not None
        )

    def add_assignment(self, assignment: StructFieldAssignment) -> bool:
        """Add an assignment to the list of assignments"""
        if self.type is None:
            self.type = assignment.type

        field_name = assignment.member.name
        if field_name == "isa":
            self.isa = assignment.expr
            self.ea = assignment.insn.ea
        elif field_name == "flags":
            if assignment.is_cast_assign:
                # We need to split it to flags and reserved
                expr = assignment.expr
                if expr.op != ida_hexrays.cot_num:
                    print(f"[Error] invalid flags assignment. Expected const, got: {expr.dstr()}")
                    return False

                num_val = expr.numval()
                self.flags = cexpr.from_const_value(num_val & 0xFF_FF_FF_FF, is_hex=True)
                self.reserved = cexpr.from_const_value(num_val >> 32, is_hex=True)
            else:
                self.flags = assignment.expr
        elif field_name == "reserved":
            self.reserved = assignment.expr
        elif field_name == "invoke":
            self.invoke = assignment.expr
        elif field_name == "descriptor":
            self.descriptor = assignment.expr
        else:
            return False

        self.assignments.append(assignment.insn)
        return True

```

`src/ioshelper/plugins/common/clang_blocks/block_arg_byref.py`:

```py
__all__ = [
    "BlockArgByRefField",
    "BlockByRefArgBaseFieldsAssignments",
    "create_block_arg_byref_type",
    "get_block_byref_args_lvars",
    "is_block_arg_byref_type",
]

from dataclasses import dataclass
from enum import Enum

import ida_hexrays
from ida_hexrays import cexpr_t, cfunc_t, cinsn_t, lvar_t
from ida_typeinf import tinfo_t
from idahelper import tif
from idahelper.ast import cexpr

from .utils import StructFieldAssignment

PTR_SIZE = 8
INT_SIZE = 4

OFFSET_ISA = 0
OFFSET_FORWARDING = OFFSET_ISA + PTR_SIZE
OFFSET_FLAGS = OFFSET_FORWARDING + PTR_SIZE
OFFSET_SIZE = OFFSET_FLAGS + INT_SIZE
OFFSET_BYREF_KEEP = OFFSET_SIZE + INT_SIZE
OFFSET_BYREF_DISPOSE = OFFSET_BYREF_KEEP + PTR_SIZE
OFFSETS = [OFFSET_ISA, OFFSET_FORWARDING, OFFSET_FLAGS, OFFSET_SIZE, OFFSET_BYREF_KEEP, OFFSET_BYREF_DISPOSE]


class BlockArgByRefField(Enum):
    """
    struct _block_byref_x {
        void *isa;
        struct _block_byref_x *forwarding;
        int flags;
        int size;
        /* optional */ void (*byref_keep)(void  *dst, void *src);
        /* optional */ void (*byref_dispose)(void *);
        typeof(marked_variable) marked_variable;
    };
    """

    ISA = 0
    FORWARDING = 1
    FLAGS = 2
    SIZE = 3
    HELPER_KEEP = 4
    HELPER_DISPOSE = 5
    VARIABLE = 6

    def get_offset(self, has_helpers: bool | None = None) -> int:
        if self == BlockArgByRefField.VARIABLE and has_helpers is None:
            raise ValueError("has_helpers must be specified for VARIABLE")

        if self == BlockArgByRefField.VARIABLE:
            return OFFSET_BYREF_DISPOSE + PTR_SIZE if has_helpers else OFFSET_BYREF_KEEP

        return OFFSETS[self.value]


TYPE_BLOCK_ARG_BYREF_PREFIX = "Block_byref_layout_"
TYPE_DECL_BLOCK_ARG_BYREF_WITH_HELPERS = """
#pragma pack(push, 1)
struct {class_name} {{
    void *isa;
    struct {class_name} *forwarding;
    int flags;
    int size;
    void (*byref_keep)(void  *dst, void *src);
    void (*byref_dispose)(void *);
    {var_type} value;
}};
#pragma pack(pop)
"""
TYPE_DECL_BLOCK_ARG_BYREF_WITHOUT_HELPERS = """
#pragma pack(push, 1)
struct {class_name} {{
    void *isa;
    struct {class_name} *forwarding;
    int flags;
    int size;
    {var_type} value;
}};
#pragma pack(pop)
"""


def get_type_name_for_addr(ea: int) -> str:
    return f"{TYPE_BLOCK_ARG_BYREF_PREFIX}{ea:08X}"


def is_block_arg_byref_type(tinfo: tinfo_t) -> bool:
    """Check if the given `tif` is a block arg byref type"""
    if not tinfo.is_struct():
        return False
    # noinspection PyTypeChecker
    name: str | None = tinfo.get_type_name()
    return name is not None and name.startswith(TYPE_BLOCK_ARG_BYREF_PREFIX)


def create_block_arg_byref_type(ea: int, var_size: int, has_helpers: bool) -> tinfo_t:
    """Create a tinfo_t for the block byref type"""
    class_name = get_type_name_for_addr(ea)

    if (existing_type := tif.from_struct_name(class_name)) is not None:
        return existing_type

    var_type = tif.from_size(var_size).dstr()
    if has_helpers:
        type_decl = TYPE_DECL_BLOCK_ARG_BYREF_WITH_HELPERS.format(class_name=class_name, var_type=var_type)
    else:
        type_decl = TYPE_DECL_BLOCK_ARG_BYREF_WITHOUT_HELPERS.format(class_name=class_name, var_type=var_type)

    tif.create_from_c_decl(type_decl)
    return tif.from_struct_name(class_name)


def get_block_byref_args_lvars(func: cfunc_t) -> list[lvar_t]:
    """Get all Obj-C block by ref args variables in the function"""
    return [lvar for lvar in func.get_lvars() if is_block_arg_byref_type(lvar.type())]


@dataclass
class BlockByRefArgBaseFieldsAssignments:
    assignments: list[cinsn_t]
    ea: int | None
    type: tinfo_t | None
    isa: cexpr_t | None
    forwarding: cexpr_t | None
    flags: cexpr_t | None
    size: cexpr_t | None
    byref_keep: cexpr_t | None
    byref_dispose: cexpr_t | None

    def __str__(self) -> str:
        return (
            f"isa: {self.isa.dstr() if self.isa else 'None'}, "
            f"forwarding: {self.forwarding.dstr() if self.forwarding else 'None'}, "
            f"flags: {self.flags.dstr() if self.flags else 'None'}, "
            f"size: {self.size.dstr() if self.size else 'None'}, "
            f"byref_keep: {self.byref_keep.dstr() if self.byref_keep else 'None'}, "
            f"byref_dispose: {self.byref_dispose.dstr() if self.byref_dispose else 'None'}, "
        )

    @staticmethod
    def initial() -> "BlockByRefArgBaseFieldsAssignments":
        return BlockByRefArgBaseFieldsAssignments(
            assignments=[],
            ea=None,
            type=None,
            isa=None,
            forwarding=None,
            flags=None,
            size=None,
            byref_keep=None,
            byref_dispose=None,
        )

    def is_completed(self) -> bool:
        """Check if all base fields have been assigned"""
        return self.isa is not None and self.forwarding is not None and self.flags is not None and self.size is not None

    def add_assignment(self, assignment: StructFieldAssignment) -> bool:
        """Add an assignment to the list of assignments"""
        if self.type is None:
            self.type = assignment.type

        field_name = assignment.member.name
        if field_name == "isa":
            self.isa = assignment.expr
            self.ea = assignment.insn.ea
        elif field_name == "forwarding":
            self.forwarding = assignment.expr
        elif field_name == "flags":
            if assignment.is_cast_assign:
                # We need to split it to flags and reserved
                expr = assignment.expr
                if expr.op != ida_hexrays.cot_num:
                    print(f"[Error] invalid flags assignment. Expected const, got: {expr.dstr()}")
                    return False

                num_val = expr.numval()
                self.flags = cexpr.from_const_value(num_val & 0xFF_FF_FF_FF, is_hex=True)
                self.size = cexpr.from_const_value(num_val >> 32, is_hex=True)
            else:
                self.flags = assignment.expr
        elif field_name == "size":
            self.size = assignment.expr
        elif field_name == "byref_keep":
            self.byref_keep = assignment.expr
        elif field_name == "byref_dispose":
            self.byref_dispose = assignment.expr
        else:
            return False

        self.assignments.append(assignment.insn)
        return True

```

`src/ioshelper/plugins/common/clang_blocks/optimize_blocks_init.py`:

```py
import ida_hexrays
from ida_hexrays import Hexrays_Hooks, cexpr_t, cfuncptr_t, cinsn_t
from idahelper import memory
from idahelper.ast import cexpr, cinsn

from .block import BlockBaseFieldsAssignments, get_block_type, get_ida_block_lvars
from .block_arg_byref import BlockByRefArgBaseFieldsAssignments, get_block_byref_args_lvars
from .utils import StructFieldAssignment, get_struct_fields_assignments


class objc_blocks_optimizer_hooks_t(Hexrays_Hooks):
    def maturity(self, func: cfuncptr_t, new_maturity: int) -> int:
        if new_maturity < ida_hexrays.CMAT_CPA:
            return 0

        optimize_blocks(func)
        optimize_block_byref_args(func)
        return 0


# region byref args
def optimize_block_byref_args(func: cfuncptr_t) -> bool:
    # Check if the function has blocks
    byref_lvars = get_block_byref_args_lvars(func)
    if not byref_lvars:
        return False

    assignments = get_struct_fields_assignments(func, byref_lvars)
    has_optimized = False
    for lvar, lvar_assignments in assignments.items():
        has_optimized |= optimize_block_byref_arg(lvar, func, lvar_assignments)

    return has_optimized


def optimize_block_byref_arg(lvar: str, func: cfuncptr_t, assignments: list[StructFieldAssignment]) -> bool:
    byref_fields = BlockByRefArgBaseFieldsAssignments.initial()
    for assignment in assignments:
        byref_fields.add_assignment(assignment)

    if not byref_fields.is_completed():
        return False

    new_insn = create_byref_init_insn(lvar, func, byref_fields)
    first_assignment = byref_fields.assignments[0]
    for assignment in byref_fields.assignments[1:]:
        assignment.cleanup()
    first_assignment.swap(new_insn)
    return True


def create_byref_init_insn(lvar: str, func: cfuncptr_t, byref_fields: BlockByRefArgBaseFieldsAssignments) -> cinsn_t:
    if byref_fields.byref_dispose is not None:
        call = cexpr.call_helper_from_sig(
            "_byref_block_arg_ex_init",
            byref_fields.type,
            [
                cexpr_t(byref_fields.flags),
                cexpr_t(byref_fields.byref_keep),
                cexpr_t(byref_fields.byref_dispose),
            ],
        )
    else:
        call = cexpr.call_helper_from_sig(
            "_byref_block_arg_init",
            byref_fields.type,
            [
                cexpr_t(byref_fields.flags),
            ],
        )

    lvar_exp = cexpr.from_var_name(lvar, func)

    return cinsn.from_expr(cexpr.from_assignment(lvar_exp, call), ea=byref_fields.ea)


# endregion


# region blocks
def optimize_blocks(func: cfuncptr_t) -> bool:
    # Check if the function has blocks
    block_lvars = get_ida_block_lvars(func)
    if not block_lvars:
        return False

    assignments = get_struct_fields_assignments(func, block_lvars)
    has_optimized = False
    for lvar, lvar_assignments in assignments.items():
        has_optimized |= optimize_block(lvar, func, lvar_assignments)

    return has_optimized


def optimize_block(lvar: str, func: cfuncptr_t, assignments: list[StructFieldAssignment]) -> bool:
    block_fields = BlockBaseFieldsAssignments.initial()
    for assignment in assignments:
        block_fields.add_assignment(assignment)

    if not block_fields.is_completed():
        return False

    new_insn = create_block_init_insn(lvar, func, block_fields)
    first_assignment = block_fields.assignments[0]
    for assignment in block_fields.assignments[1:]:
        assignment.cleanup()
    first_assignment.swap(new_insn)
    return True


def create_block_init_insn(lvar: str, func: cfuncptr_t, block_fields: BlockBaseFieldsAssignments) -> cinsn_t:
    if (isa := get_isa(block_fields.isa)) is not None:
        call = cexpr.call_helper_from_sig(
            f"_{get_block_type(isa)}_block_init",
            block_fields.type,
            [
                cexpr_t(block_fields.flags),
                cexpr_t(block_fields.descriptor),
                cexpr_t(block_fields.invoke),
            ],
        )
    else:
        call = cexpr.call_helper_from_sig(
            "_block_init",
            block_fields.type,
            [
                cexpr_t(block_fields.isa),
                cexpr_t(block_fields.flags),
                cexpr_t(block_fields.descriptor),
                cexpr_t(block_fields.invoke),
            ],
        )

    lvar_exp = cexpr.from_var_name(lvar, func)

    return cinsn.from_expr(cexpr.from_assignment(lvar_exp, call), ea=block_fields.ea)


def get_isa(isa: cexpr_t) -> str | None:
    """Get the isa name from the isa expression"""
    if isa.op == ida_hexrays.cot_ref:
        inner = isa.x
        if inner.op == ida_hexrays.cot_obj:
            return memory.name_from_ea(inner.obj_ea)
    elif isa.op == ida_hexrays.cot_helper:
        return isa.helper
    return None


# endregion

```

`src/ioshelper/plugins/common/clang_blocks/utils.py`:

```py
__all__ = ["StructFieldAssignment", "get_struct_fields_assignments", "run_objc_plugin_on_func"]

from dataclasses import dataclass

import ida_hexrays
import idaapi
from ida_hexrays import cexpr_t, cfuncptr_t, cinsn_t, lvar_t
from ida_typeinf import tinfo_t, udm_t
from idahelper import tif
from idahelper.ast.cexpr import getv


@dataclass
class StructFieldAssignment:
    type: tinfo_t
    member: udm_t
    expr: cexpr_t
    is_cast_assign: bool
    insn: cinsn_t

    def __repr__(self):
        return f"StructAssignment(member={self.member.name}, is_cast_assign={self.is_cast_assign},  expr={self.expr.dstr()}, insn={self.insn.dstr()})"


class LvarFieldsAssignmentsCollector(ida_hexrays.ctree_visitor_t):
    """
    Visitor for collecting assignments to a list of local variables.
    The local variables should be of struct type.
    The assignments we are searching for are for a member of the struct.

    For example: `a.b = c;` where `a` is a local variable of struct type and `b` is a member of that struct.
    """

    def __init__(self, target_lvars: list[lvar_t]):
        super().__init__(ida_hexrays.CV_PARENTS)
        self._target_lvars_names: dict[str, lvar_t] = {lvar.name: lvar for lvar in target_lvars}
        self.assignments: dict[str, list[StructFieldAssignment]] = {}

    def visit_expr(self, exp: cexpr_t) -> int:
        # We search for "a.b = c;" or "*(_XWORD *)&a.b = c;"
        # Check if the expression is an assignment
        if exp.op != ida_hexrays.cot_asg:
            return 0

        # Check if the left side is a member reference
        target = remove_ref_cast_dref(exp.x)
        is_cast_assign = target != exp.x
        if target.op != ida_hexrays.cot_memref:
            return 0

        # Check that it is a member reference to a local variable
        target_obj = target.x
        if target_obj.op != ida_hexrays.cot_var:
            return 0

        # Check if the local variable is what we are looking for
        target_obj_lvar: lvar_t = getv(target_obj.v)
        if target_obj_lvar.name not in self._target_lvars_names:
            return 0

        lvar_type = target_obj_lvar.type()
        member = tif.get_member(lvar_type, target.m)
        if member is None:
            return 0

        # Save the assignment
        self.assignments.setdefault(target_obj_lvar.name, []).append(
            StructFieldAssignment(
                type=lvar_type, member=member, expr=exp.y, insn=self.parent_insn(), is_cast_assign=is_cast_assign
            )
        )
        return 0


def remove_ref_cast_dref(expr: cexpr_t) -> cexpr_t:
    """Remove reference, cast and dereference from the expression"""
    while expr.op in (ida_hexrays.cot_ref, ida_hexrays.cot_cast, ida_hexrays.cot_ptr):
        expr = expr.x
    return expr


def get_struct_fields_assignments(cfunc: cfuncptr_t, lvars: list[lvar_t]) -> dict[str, list[StructFieldAssignment]]:
    """Get all assignments of the form "a.b = c" to the given local variables"""
    collector = LvarFieldsAssignmentsCollector(lvars)
    collector.apply_to(cfunc.body, None)  # pyright: ignore[reportArgumentType]
    return collector.assignments


def run_objc_plugin_on_func(ea: int) -> None:
    """Run IDA's Objective-C>Analyze stack-allocated blocks on the function at ea."""
    n = idaapi.netnode()
    n.create("$ objc")
    n.altset(1, ea, "R")  # the address can be any address within the function
    idaapi.load_and_run_plugin("objc", 5)

```

`src/ioshelper/plugins/common/globals.py`:

```py
import sys

from ioshelper.base.reloadable_plugin import Component, PluginCore


def globals_component(_core: PluginCore) -> Component:
    class GlobalsComponent(Component):
        def __init__(self, core: PluginCore):
            super().__init__("globals", core)
            self.global_module = sys.modules["__main__"]

            from ioshelper.plugins.kernelcache.func_renamers import (
                rename_function_by_arg,
                rename_function_by_callback,
            )

            self.globals = {
                "rename_function_by_arg": rename_function_by_arg,
                "rename_function_by_callback": rename_function_by_callback,
            }

        def mount(self) -> bool:
            for global_name, global_value in self.globals.items():
                setattr(self.global_module, global_name, global_value)
            return True

        def unmount(self):
            for global_name in self.globals:
                if hasattr(self.global_module, global_name):
                    delattr(self.global_module, global_name)

    return GlobalsComponent(_core)

```

`src/ioshelper/plugins/common/jump_to_string/__init__.py`:

```py
__all__ = ["jump_to_string_component"]

import ida_kernwin
import idaapi
from ida_kernwin import action_handler_t

from ioshelper.base.reloadable_plugin import UIAction, UIActionsComponent

from .jump_to_string import jump_to_string_ask

ACTION_ID = "ioshelper:jump_to_string"

jump_to_string_component = UIActionsComponent.factory(
    "Jump to function using a specific string",
    [
        lambda core: UIAction(
            ACTION_ID,
            idaapi.action_desc_t(ACTION_ID, "Jump to function using a specific string", JumpToStringAction(), "Ctrl+S"),
            menu_location=UIAction.base_location(core),
        )
    ],
)


class JumpToStringAction(action_handler_t):
    def activate(self, ctx: ida_kernwin.action_ctx_base_t):
        jump_to_string_ask()
        return 0

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

```

`src/ioshelper/plugins/common/jump_to_string/jump_to_string.py`:

```py
from idahelper import functions, memory, strings, widgets, xrefs


def find_matching_string(target_str: str) -> list[tuple[int, str]]:
    matches: list[tuple[int, str]] = []
    for s in strings.strings():
        if target_str in str(s):
            matches.append((s.ea, str(s)))  # type: ignore  # noqa: PGH003
    return matches


def show_xrefs_to_string(ea: int):
    s_xrefs = xrefs.get_xrefs_to(ea)
    if not s_xrefs:
        print("No cross-references found.")
    elif len(s_xrefs) == 1:
        widgets.jump_to(s_xrefs[0])
    else:
        print("Multiple xrefs to the string:")
        for xref in s_xrefs:
            print_xref(xref)


def print_xref(ea: int, match: str | None = None):
    func_start = functions.get_start_of_function(ea)
    if func_start is None:
        print(f"{ea:X}")
        return

    func_name = memory.name_from_ea(func_start) or "<unknown>"
    match_str = "" if match is None else f": {match}"

    print(f"{ea:X} at {func_name}+{ea - func_start:X}{match_str}")


def jump_to_string_ask():
    target_str = widgets.show_string_input("Enter substring to search in binary strings")
    if not target_str:
        return

    matches = find_matching_string(target_str)

    if not matches:
        print("[Warning] No matching strings found.")
        return

    # If there's only one result, or an exact match, show xrefs
    if len(matches) == 1 or any(s == target_str for _, s in matches):
        for ea, s in matches:
            if s == target_str or len(matches) == 1:
                show_xrefs_to_string(ea)
                return

    # Otherwise, let the user choose
    print("Multiple results for the string:")
    for ea, s in matches:
        print(f"{ea:X}: {s}")

```

`src/ioshelper/plugins/common/outline/__init__.py`:

```py
__all__ = ["mark_all_outline_functions", "mark_outline_functions_component"]

import ida_kernwin
import idaapi
from ida_kernwin import action_handler_t

from ioshelper.base.reloadable_plugin import UIAction, UIActionsComponent

from .outline import mark_all_outline_functions

ACTION_ID = "ioshelper:mark_outline_components"

mark_outline_functions_component = UIActionsComponent.factory(
    "Locate all the outline functions and mark them as such",
    [
        lambda core: UIAction(
            ACTION_ID,
            idaapi.action_desc_t(
                ACTION_ID,
                "Locate all the outline functions and mark them as such",
                MarkAllOutlineFunctionsAction(),
            ),
            menu_location=UIAction.base_location(core),
        )
    ],
)


class MarkAllOutlineFunctionsAction(action_handler_t):
    def activate(self, ctx: ida_kernwin.action_ctx_base_t):
        mark_all_outline_functions()
        return 0

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

```

`src/ioshelper/plugins/common/outline/outline.py`:

```py
__all__ = ["mark_all_outline_functions"]


import re
import zlib
from collections import Counter
from itertools import islice

import ida_ua
from ida_funcs import func_t
from ida_ua import insn_t
from idahelper import functions, instructions, memory, xrefs

MAX_INSN_COUNT = 15
OUTLINE_COMMON_REGISTERS = ["X19", "X20", "X21", "X22", "X23", "X24", "X25"]
HASHES = {
    2486657537,
    4051340011,
    835854959,
    4053891209,
    2284322540,
    3734446324,
    3486938057,
    3100884732,
    1520871260,
    3035036398,
    3354748321,
    1286661669,
    3963943914,
    1065801208,
    3035825621,
    3374831749,
    3277914534,
    2587032924,
    2868248941,
    3315843181,
    2622615498,
    3720341170,
    3337984774,
    1893466989,
    518987256,
    2803156496,
    671639713,
    218684989,
    1791333242,
    3457579667,
    3574749379,
    3434086350,
    4165857220,
    2131640558,
    3495698196,
    1340405478,
    229647317,
    4006608232,
    786104779,
    1126219089,
    2831582611,
    289234555,
    1661182837,
    3423629888,
    2309108340,
    3075689215,
    2236221560,
    1839174898,
    481463652,
    766791884,
    218698196,
    752795631,
    3344164986,
    1827242795,
    792695013,
    230959901,
    2997841865,
    568754444,
    1670421527,
    2184318906,
    3024877629,
    2387594438,
    557192575,
    2458769492,
    3922284957,
    4107181330,
    1578820194,
    1546391466,
    1163279958,
    1540647309,
    1049262605,
    2130556960,
    2163533787,
    2092533000,
    2426425641,
    4207618,
    2736070239,
    1277505515,
    1788212028,
    1368299300,
    3786044294,
    563839748,
    3199076566,
    876720633,
    2633791921,
    1428282898,
    146181378,
    472218750,
    304360983,
    1808920834,
    4174859059,
    85578290,
    631075697,
    1189335917,
    288603166,
    4177653000,
    3698829753,
    1630600770,
    1498027780,
    1149213890,
}


def calculate_outline_hash(top_hashes_count: int):
    # Calculate hashes
    hashes = Counter()
    for func in functions.iterate_functions():
        func_name = memory.name_from_ea(func.start_ea)
        assert func_name is not None

        if functions.has_flags(func, functions.FLAG_OUTLINE):
            hashes[function_hash(func)] += 1
            continue

    top_hashes = [key for key, _ in hashes.most_common(top_hashes_count)]
    top_hashes_match = sum(value for _, value in hashes.most_common(top_hashes_count))
    print(f"Top {top_hashes_count} hashes, should match {top_hashes_match} / {hashes.total()}")
    print(top_hashes)

    # Check for false positives
    top_hashes = set(top_hashes)
    for func in functions.iterate_functions():
        func_name = memory.name_from_ea(func.start_ea)
        assert func_name is not None

        if not functions.has_flags(func, functions.FLAG_OUTLINE):
            func_hash = function_hash(func)
            if func_hash in top_hashes:
                print(f"{func.start_ea:X} matches an hash for outlined func.")


def mark_all_outline_functions():
    count = 0
    for func in functions.iterate_functions():
        func_name = memory.name_from_ea(func.start_ea)
        assert func_name is not None

        # if functions.has_flags(func, functions.FLAG_OUTLINE):
        #     continue
        if func_name.startswith("_OUTLINED") or (
            not heuristic_not_outline(func, func_name) and (function_hash(func) in HASHES or heuristic_outline(func))
        ):
            print(f"Applied outline flag on {func.start_ea:X}")
            functions.apply_flag_to_function(func, functions.FLAG_OUTLINE)

            # Update name as well
            if "OUTLINED" not in func_name:
                memory.set_name(func.start_ea, f"__OUTLINED_{func_name}")
            count += 1

    print(f"Applied outlined to {count} functions")


def heuristic_not_outline(func: func_t, name: str) -> bool:
    # Assuming outlined functions are small - less than 10 instructions.
    if func.size() > MAX_INSN_COUNT * 4:
        return True

    if not name.startswith("sub_"):
        return True

    # Outlined functions will have no data xrefs
    if xrefs.get_xrefs_to(func.start_ea, is_data=True):
        return True

    # We only care for functions with xrefs.
    # One might think outline functions has to have more than one xref, but apparently it is incorrect...
    if not xrefs.get_xrefs_to(func.start_ea):
        return True

    first_instruction = instructions.decode_instruction(func.start_ea)
    return bool(first_instruction is None or first_instruction.get_canon_mnem() in ["PAC", "BTI"])


def heuristic_outline(func: func_t) -> bool:
    # Empty function are not outlined I guess
    if func.size() == 0:
        return False

    first_insn = instructions.decode_instruction(func.start_ea)
    if first_insn is None:
        return False

    # We don't deal right now with instructions that may branch on first instruction
    if instructions.is_flow_instruction(first_insn):
        return False

    # Check if we use an outline register without definition in the first instruction
    read_0, write_0 = instructions.analyze_reg_dependencies(first_insn)
    if any(reg in read_0 for reg in OUTLINE_COMMON_REGISTERS):
        return True

    # Check if we use an outline register without definition in the second instruction
    second_insn = instructions.decode_next_instruction(first_insn, func)
    if second_insn is None:
        return False

    read_1, _ = instructions.analyze_reg_dependencies(second_insn)
    return any(reg in read_1 and reg not in write_0 for reg in OUTLINE_COMMON_REGISTERS)


REG_GROUPS = {
    "a": range(0, 8),  # x0-x7
    "t": range(8, 16),  # x8-x15
    "i": range(16, 19),  # x16-x18
    "s1": range(19, 24),  # x19-x23
    "s2": range(24, 29),  # x24-x28
    "fp": [29],
    "lr": [30],
    "z": ["xzr"],
}


def classify_reg(reg: int) -> str:
    reg_name = instructions.get_register_name(reg).lower().strip()
    if reg_name == "sp":
        return "sp"
    if reg_name == "xzr" or reg_name == "wzr":
        return "z"
    if reg_name.startswith(("x", "w")):
        regnum = int(re.findall(r"\d+", reg_name)[0])
        for group, rset in REG_GROUPS.items():
            if regnum in rset:
                return group
        return "r"  # everything else
    return reg_name  # leave non-registers as-is


def get_normalized_pattern(insn: insn_t) -> str:
    mnem = insn.get_canon_mnem()
    ops = []
    for op in insn.ops:
        if op.type == ida_ua.o_void:
            reg = "V"
        elif op.type == ida_ua.o_imm:
            reg = str(op.value)
        elif op.type == ida_ua.o_mem:
            reg = "M"
        elif op.type == ida_ua.o_reg:
            reg = classify_reg(op.reg)
        elif op.type == ida_ua.o_phrase or op.type == ida_ua.o_idpspec0:
            reg = f"{classify_reg(op.reg)}:{op.phrase}"
        elif op.type == ida_ua.o_displ:
            reg = f"{classify_reg(op.reg)}:{op.phrase}:{op.value}"
        else:
            reg = f"U{op.type}"

        ops.append(reg)
    return f"{mnem}_{'_'.join(ops)}"


def get_function_pattern(func) -> str:
    patterns = []
    for insn in islice(instructions.from_func(func), 2):
        patterns.append(get_normalized_pattern(insn))
    return " ".join(patterns)


def function_hash(func) -> int:
    pattern = get_function_pattern(func)
    return zlib.crc32(pattern.encode())

```

`src/ioshelper/plugins/common/range_condition/__init__.py`:

```py
__all__ = ["range_condition_optimizer_component"]

from ioshelper.base.reloadable_plugin import HexraysHookComponent

from .range_condition import range_condition_optimizer

range_condition_optimizer_component = HexraysHookComponent.factory(
    "Range condition optimizer", [range_condition_optimizer]
)

```

`src/ioshelper/plugins/common/range_condition/range_condition.py`:

```py
from typing import Literal

import ida_hexrays
from ida_hexrays import Hexrays_Hooks, cexpr_t, cfunc_t
from idahelper import tif
from idahelper.ast import cexpr


def is_unsigned_comparison_expr(e: cexpr_t) -> bool:
    """Check if the expression is an unsigned comparison."""
    return e.op in (ida_hexrays.cot_uge, ida_hexrays.cot_ule, ida_hexrays.cot_ugt, ida_hexrays.cot_ult)


class RangeConditionTreeVisitor(ida_hexrays.ctree_visitor_t):
    def __init__(self, func: cfunc_t):
        super().__init__(ida_hexrays.CV_FAST)
        self.func = func

    def visit_expr(self, e: cexpr_t) -> int:
        # search for pattern of x ± const_1 < const_2
        if not is_unsigned_comparison_expr(e):
            return 0

        lhs, rhs = e.x, e.y
        if e.x.op == ida_hexrays.cot_cast:
            is_cast = True
            lhs = e.x.x
        else:
            is_cast = False

        if (
            rhs.op != ida_hexrays.cot_num
            or lhs.op not in (ida_hexrays.cot_add, ida_hexrays.cot_sub)
            or lhs.y.op != ida_hexrays.cot_num
            or lhs.x.has_side_effects()
        ):
            return 0

        # Get modulus for the expression size - use e.x instead of lhs to handle casts correctly
        expr_size_in_bytes = e.x.type.get_size()
        if expr_size_in_bytes not in (1, 2, 4, 8):
            print(f"[Warning] Unsupported expression size {expr_size_in_bytes} for {e.dstr()}")
            return 0
        mod = 1 << (expr_size_in_bytes << 3)

        # Get consts
        lhs_const = lhs.y.numval() % mod
        rhs_const = e.y.numval() % mod

        # Complement lhs const if the operation is addition
        if lhs.op == ida_hexrays.cot_add:
            lhs_const = mod - lhs_const

        x = cexpr.from_cast(lhs.x, e.x.type) if is_cast else lhs.x

        replacement_expr = (
            create_range_condition_greater_than
            if e.op in (ida_hexrays.cot_ugt, ida_hexrays.cot_uge)
            else create_range_condition_less_than
        )(e, lhs_const, rhs_const, mod, x, lhs.y.ea, self.func)
        e.swap(replacement_expr)

        self.prune_now()
        return 0


def create_range_condition_less_than(
    e: cexpr_t, lhs: int, rhs: int, mod: int, x: cexpr_t, lhs_ea: int, func: cfunc_t
) -> cexpr_t:
    """Create a range condition for the expression `x - lhs < rhs`."""

    lhs_plus_rhs = lhs + rhs
    lhs_plus_rhs_mod_n = lhs_plus_rhs % mod
    # if lhs + rhs < mod, we can use a single range condition
    #   x - lhs < rhs  => x ∈ [lhs, lhs + rhs) ==> lhs <= x && x < lhs + rhs
    #   x - lhs <= rhs => x ∈ [lhs, lhs + rhs] ==> lhs <= x && x <= lhs + rhs
    # if lhs + rhs >= mod, we need to use two range conditions
    #   x - lhs < rhs  => x ∈ [lhs, mod) U x ∈ [0, (lhs+rhs) mod n) ==> lhs <= x || x < (lhs + rhs) mod n
    #   x - lhs <= rhs => x ∈ [lhs, mod) U x ∈ [0, (lhs+rhs) mod n] ==> lhs <= x || x <= (lhs + rhs) mod n
    # Notice that the conditions are the same, but it is either && or || depending on whether lhs + rhs < mod or not.

    op: Literal["&&", "||"] = "||" if lhs_plus_rhs >= mod else "&&"
    lhs_plus_rhs_expr = cexpr.from_const_value(lhs_plus_rhs_mod_n, func, lhs_ea)
    lhs_expr = cexpr.from_const_value(lhs, func, e.y.ea)
    return _bin_op(
        _bin_op(lhs_expr, "<=", cexpr_t(x), e.ea),
        op,
        _bin_op(cexpr_t(x), IDA_OP_TO_MATH_OP[e.op], lhs_plus_rhs_expr, e.ea),
        e.ea,
    )


def create_range_condition_greater_than(
    e: cexpr_t, lhs: int, rhs: int, mod: int, x: cexpr_t, lhs_ea: int, func: cfunc_t
) -> cexpr_t:
    """Create a range condition for the expression `x - lhs > rhs`."""

    lhs_plus_rhs = lhs + rhs
    lhs_plus_rhs_mod_n = lhs_plus_rhs % mod

    lhs_plus_rhs_expr = cexpr.from_const_value(lhs_plus_rhs_mod_n, func, lhs_ea)
    lhs_expr = cexpr.from_const_value(lhs, func, e.y.ea)
    op: Literal["<", "<="] = "<" if e.op == ida_hexrays.cot_ugt else "<="

    # if lhs + rhs < mod:
    #   x - lhs > rhs  => x ∈ (lhs + rhs, mod) U x ∈ [0, lhs) ==> lhs + rhs < x || x < lhs
    #   x - lhs >= rhs => x ∈ [lhs + rhs, mod) U x ∈ [0, lhs] ==> lhs + rhs <= x || x <= lhs
    if lhs_plus_rhs < mod:
        return _bin_op(
            _bin_op(lhs_plus_rhs_expr, op, cexpr_t(x), e.ea),
            "||",
            _bin_op(cexpr_t(x), op, lhs_expr, e.ea),
            e.ea,
        )
    else:
        # if lhs + rhs >= mod:
        #   x - lhs > rhs  => x ∈ (lhs + rhs (mod n), lhs) ==> lhs + rhs (mod n) < x && x < lhs
        #   x - lhs >= rhs => x ∈ [lhs + rhs (mod n), lhs) ==> lhs + rhs (mod n) <= x && x < lhs
        return _bin_op(
            _bin_op(lhs_plus_rhs_expr, op, cexpr_t(x), e.ea),
            "&&",
            _bin_op(cexpr_t(x), "<", lhs_expr, e.ea),
            e.ea,
        )


def _bin_op(left: cexpr_t, op: Literal["<", "<=", ">", ">=", "&&", "||"], right: cexpr_t, ea: int) -> cexpr_t:
    """Create a boolean binary operation expression."""
    if op == "&&":
        ida_op = ida_hexrays.cot_land
    elif op == "||":
        ida_op = ida_hexrays.cot_lor
    else:
        ida_op = MATH_OP_TO_IDA_OP[op]
    return cexpr.from_binary_op(left, right, ida_op, tif.BOOL, ea)


IDA_OP_TO_MATH_OP: dict[int, Literal["<", "<=", ">", ">="]] = {
    ida_hexrays.cot_uge: ">=",
    ida_hexrays.cot_ule: "<=",
    ida_hexrays.cot_ugt: ">",
    ida_hexrays.cot_ult: "<",
}
MATH_OP_TO_IDA_OP = {v: k for k, v in IDA_OP_TO_MATH_OP.items()}


class range_condition_optimizer(Hexrays_Hooks):
    def maturity(self, cfunc: cfunc_t, new_maturity: int) -> int:
        if new_maturity != ida_hexrays.CMAT_NICE:
            return 0

        RangeConditionTreeVisitor(cfunc).apply_to(cfunc.body, None)  # pyright: ignore [reportArgumentType]
        return 0

```

`src/ioshelper/plugins/common/run_callback.py`:

```py
__all__ = ["run_callback"]

from collections.abc import Callable

import idaapi
from ida_funcs import func_t
from idahelper import file_format

from ioshelper.base.reloadable_plugin import PluginCore

from ..kernelcache.func_renamers import apply_global_rename, apply_pac
from ..kernelcache.kalloc_type import apply_kalloc_types
from .clang_blocks import run_objc_plugin_on_func, try_add_block_arg_byref_to_func
from .outline import mark_all_outline_functions

RUN_GLOBAL_ANALYSIS = 1
RUN_LOCAL_ANALYSIS = 2
NETNODE_NAME = "$ idaioshelper"


def run_callback(_core: PluginCore) -> Callable[[int], None]:
    def run(value: int):
        # Here you can implement the logic that uses the core and the value
        print(f"[Debug] iOS helper run({value})")
        if value == RUN_GLOBAL_ANALYSIS:
            run_global_analysis()
        elif value == RUN_LOCAL_ANALYSIS:
            ea = read_ea_arg()
            if ea is None:
                print("[Error] No function address provided for local analysis.")
                return
            func = idaapi.get_func(ea)
            if func is None:
                print(f"[Error] No function found at address {ea:X}.")
                return

            run_local_analysis(func)

    return run


def run_global_analysis():
    print("[Info] Running global analysis...")

    print("[Info] Running outline detection...")
    mark_all_outline_functions()
    print("[Info] Outline detection completed.")

    if file_format.is_kernelcache():
        print("[Info] Applying kalloc types...")
        apply_kalloc_types()
        print("[Info] Apply kalloc types completed.")

        print("[Info] Running global renaming...")
        apply_global_rename()
        print("[Info] Global renaming completed.")

    print("[Info] Global analysis completed.")


def run_local_analysis(func: func_t):
    print("[Info] Running local analysis...")
    # Implement local analysis logic here
    print("[Info] Use builtin Obj-C plugin to restore blocks")
    run_objc_plugin_on_func(func.start_ea)
    print("[Info] Use builtin Obj-C plugin to restore blocks completed.")

    print("[Info] Try restore byref arguments in blocks")
    try_add_block_arg_byref_to_func(func.start_ea)
    print("[Info] Try restore byref arguments in blocks completed.")

    print("[Info] Try use PAC to apply types to local variables and fields")
    apply_pac(func)
    print("[Info] Try use PAC to apply types to local variables and fields completed.")

    print("[Info] Local analysis completed.")


def write_ea_arg(ea: int):
    n = idaapi.netnode()
    n.create(NETNODE_NAME)
    n.altset(1, ea, "R")


def read_ea_arg() -> int | None:
    n = idaapi.netnode(NETNODE_NAME)
    val = n.altval(1, "R")
    n.kill()
    return val if val != 0 else None

```

`src/ioshelper/plugins/common/segment_xrefs/__init__.py`:

```py
__all__ = ["show_segment_xrefs_component"]

import ida_kernwin
import idaapi
from ida_kernwin import action_handler_t

from ioshelper.base.reloadable_plugin import UIAction, UIActionsComponent

from .segment_xrefs import can_show_segment_xrefs, get_current_expr, show_segment_xrefs

ACTION_ID = "ioshelper:show_segment_xrefs"

show_segment_xrefs_component = UIActionsComponent.factory(
    "Show Xrefs inside segment",
    [
        lambda core: UIAction(
            ACTION_ID,
            idaapi.action_desc_t(
                ACTION_ID,
                "Show Xrefs inside segment",
                ShowSegmentXrefsAction(),
                "Ctrl+Shift+X",
            ),
            dynamic_menu_add=lambda widget, popup: can_show_segment_xrefs(widget),
        )
    ],
)


class ShowSegmentXrefsAction(action_handler_t):
    def activate(self, ctx: ida_kernwin.action_ctx_base_t):
        expr = get_current_expr(ctx.widget)
        if expr is None:
            print("[Error] No expression found in the current context.")
            return False
        show_segment_xrefs(expr, func_ea=ctx.cur_func.start_ea)
        return False

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

```

`src/ioshelper/plugins/common/segment_xrefs/segment_xrefs.py`:

```py
__all__ = ["can_show_segment_xrefs", "get_current_expr", "show_segment_xrefs"]

from dataclasses import dataclass

import ida_hexrays
import idaapi
from ida_hexrays import cexpr_t, cfuncptr_t, cinsn_t, citem_t, get_widget_vdui
from ida_kernwin import Choose
from ida_typeinf import tinfo_t
from idahelper import cpp, functions, memory, segments, tif, widgets, xrefs


def show_segment_xrefs(expr: cexpr_t, func_ea: int):
    if not _can_show_segment_xrefs(expr):
        print(f"[Error] Cannot show segment xrefs for expression: {expr.dstr()}")
        return

    if expr.op == ida_hexrays.cot_obj:
        segment_xrefs = _ea_to_xrefs(expr.obj_ea)
        title = f"Segment Xrefs for {memory.name_from_ea(expr.obj_ea) or f'{expr.obj_ea:#X}'}"
    else:
        segment_xrefs = _expr_to_xrefs(expr, func_ea)
        title = f"Segment Xrefs for {expr.dstr()}"

    if not segment_xrefs:
        print("No segment xrefs found.")
        return

    res = XrefsChoose(title, segment_xrefs).show()
    if not res:
        print("[Error] failed to show segment xrefs.")
        return


@dataclass
class SegmentXref:
    address: int
    function: int
    line: str


def _ea_to_xrefs(ea: int) -> list[SegmentXref]:
    """Get all xrefs to the given EA"""
    segment_xrefs: list[SegmentXref] = []
    for xref in xrefs.code_xrefs_to(ea):
        decompiled = idaapi.decompile(ea, flags=ida_hexrays.DECOMP_GXREFS_FORCE)
        if decompiled is None:
            print(f"[Warning] Could not decompile function at {xref:X}")
            continue
        decompiled_line = _get_decompiled_line(decompiled, xref) or "<error>"
        segment_xrefs.append(SegmentXref(xref, decompiled.entry_ea, decompiled_line))

    return segment_xrefs


def _expr_to_xrefs(expr: cexpr_t, func_ea: int) -> list[SegmentXref]:
    assert expr.op in (ida_hexrays.cot_memptr, ida_hexrays.cot_memref)
    expr_obj_type: tinfo_t = expr.x.type
    if expr_obj_type.is_ptr_or_array():
        expr_obj_type.remove_ptr_or_array()
    expr_obj_offset: int = expr.m
    recursive_member = tif.get_member_recursive(expr_obj_type, expr_obj_offset)
    if recursive_member is None:
        print(f"[Error] Could not find member at offset {expr_obj_offset} in type {expr_obj_type.dstr()}")
        return []
    relevant_type: tinfo_t = recursive_member[0]
    possible_types: set[str] = {str(t) for t in tif.get_children_classes(relevant_type) or []}
    possible_types.add(str(relevant_type))

    current_segment = segments.get_segment_by_ea(func_ea)
    if current_segment is None:
        print(f"[Error] Could not find segment for function at {func_ea:X}")
        return []

    segment_xrefs: list[SegmentXref] = []
    for func in functions.iterate_functions(current_segment.start_ea, current_segment.end_ea):
        decompiled = idaapi.decompile(func.start_ea, flags=ida_hexrays.DECOMP_GXREFS_FORCE)
        if decompiled is None:
            print(f"[Warning] Could not decompile function at {func.start_ea:X}")
            continue

        segment_xrefs.extend(_find_xrefs_to_field(possible_types, expr_obj_offset, decompiled))

    return segment_xrefs


def _find_xrefs_to_field(possible_types: set[str], offset: int, func: cfuncptr_t) -> list[SegmentXref]:
    """Find all xrefs to the given field in the context of the function."""
    segment_xrefs: list[SegmentXref] = []
    for item in func.treeitems:
        actual_item: cexpr_t | cinsn_t = item.to_specific_type
        # Check if it is field access
        if not isinstance(actual_item, cexpr_t) or actual_item.op not in [
            ida_hexrays.cot_memptr,
            ida_hexrays.cot_memref,
        ]:
            continue
        # Check if the type and offset match
        item_type: tinfo_t = actual_item.x.type
        if item_type.is_ptr_or_array():
            item_type.remove_ptr_or_array()
        if str(item_type) not in possible_types or actual_item.m != offset:
            continue

        container_insn = _find_first_container_instruction(actual_item, func)
        if container_insn is None:
            print(f"[Warning] Could not find container instruction for item: {actual_item.dstr()}")
            continue

        item_ea = container_insn.ea
        segment_xrefs.append(SegmentXref(item_ea, func.entry_ea, container_insn.dstr()))
    return segment_xrefs


def _find_first_container_instruction(item: citem_t | None, func: cfuncptr_t) -> cinsn_t | None:
    """Find the EA of the given item in the context of the function."""
    while item is not None:
        if isinstance(item, cinsn_t):
            return item
        item = func.body.find_parent_of(item)
        if item is not None:
            item = item.to_specific_type

    return None


def _get_decompiled_line(func: cfuncptr_t, ea: int) -> str | None:
    """Get the decompiled line for the given EA in the context of the function."""
    ea_map = func.get_eamap()
    if ea not in ea_map:
        print(f"[Warning] {ea:X} is not in {func.entry_ea:X} ea map.")
        return None

    return "\n".join(stmt.dstr() for stmt in ea_map[ea])


def _can_show_segment_xrefs(expr: cexpr_t) -> bool:
    """Check if we can show segment xrefs for the given expression."""
    return expr.op in (ida_hexrays.cot_obj, ida_hexrays.cot_memref, ida_hexrays.cot_memptr)


def can_show_segment_xrefs(widget) -> bool:
    """Check if we can show segment xrefs in the current context."""
    expr = get_current_expr(widget)
    return expr is not None and _can_show_segment_xrefs(expr)


def get_current_expr(widget) -> cexpr_t | None:
    """Get the current expression in the context."""
    if idaapi.get_widget_type(widget) != idaapi.BWN_PSEUDOCODE:
        return None
    vu = get_widget_vdui(widget)
    if not vu or not vu.item or vu.item.citype != ida_hexrays.VDI_EXPR:
        return None
    return vu.item.it.to_specific_type


class XrefsChoose(Choose):
    def __init__(self, title: str, items: list[SegmentXref]):
        Choose.__init__(
            self,
            title,
            [
                ["Address", 20 | Choose.CHCOL_EA],
                ["Function", 40 | Choose.CHCOL_FNAME],
                ["Line", 40 | Choose.CHCOL_PLAIN],
            ],
            flags=Choose.CH_RESTORE,
            embedded=False,
        )
        self.items = items
        self.modal = False

    def OnInit(self) -> bool:
        return True

    def OnGetSize(self) -> int:
        return len(self.items)

    def OnGetLine(self, n):
        item = self.items[n]
        return (
            f"{item.address:X}",
            cpp.demangle_name_only(memory.name_from_ea(item.function) or f"SUB_{item.function:X}"),
            item.line,
        )

    def OnGetEA(self, n) -> int:
        return self.items[n].address

    def OnSelectLine(self, n):
        ea = self.items[n].address
        widgets.jump_to(ea)
        return (Choose.NOTHING_CHANGED,)

    def show(self) -> bool:
        ok = self.Show(self.modal) >= 0
        return ok

```

`src/ioshelper/plugins/kernelcache/cpp_vtbl/__init__.py`:

```py
import ida_kernwin
import idaapi
from ida_kernwin import action_handler_t

from ioshelper.base.reloadable_plugin import UIAction, UIActionsComponent

from .cpp_vtbl import get_vtable_call, show_vtable_xrefs

ACTION_ID = "ioshelper:jump_to_vtbl_xrefs"

jump_to_vtable_component = UIActionsComponent.factory(
    "Jump to VTables xrefs",
    [
        lambda core: UIAction(
            ACTION_ID,
            idaapi.action_desc_t(
                ACTION_ID,
                "Jump to VTables xrefs",
                JumpToVtablesXrefs(),
                "Shift+X",
            ),
            dynamic_menu_add=lambda widget, popup: (
                idaapi.get_widget_type(widget) == idaapi.BWN_PSEUDOCODE and get_vtable_call() is not None
            ),
        )
    ],
)


class JumpToVtablesXrefs(action_handler_t):
    def activate(self, ctx: ida_kernwin.action_ctx_base_t):
        show_vtable_xrefs()
        return False

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

```

`src/ioshelper/plugins/kernelcache/cpp_vtbl/cpp_vtbl.py`:

```py
import ida_hexrays
from ida_hexrays import cexpr_t
from ida_typeinf import tinfo_t
from idahelper import cpp, memory, tif, widgets
from idahelper.widgets import EAChoose


def get_vtable_call(verbose: bool = False) -> tuple[tinfo_t, str, int] | None:
    """If the mouse is on a virtual call, return the vtable type, method name and offset."""
    citem = widgets.get_current_citem()
    if citem is None:
        if verbose:
            print("[Error] No citem found. Do you have your cursor on a virtual call?")
        return None
    if not citem.is_expr():
        if verbose:
            print(
                f"[Error] Current citem is not an expression: {citem.dstr()}. Do you have your cursor on the virtual call?"
            )
        return None

    return get_vtable_call_from_expr(citem.cexpr, verbose)


def get_vtable_call_from_expr(expr: cexpr_t, verbose: bool = False) -> tuple[tinfo_t, str, int] | None:
    if expr.op not in [ida_hexrays.cot_memptr, ida_hexrays.cot_memref]:
        if verbose:
            print(
                f"[Error] Current citem is not a member pointer: {expr.dstr()} but a {ida_hexrays.get_ctype_name(expr.op)}. Do you have your cursor on the virtual call?"
            )
        return None

    tp: tinfo_t = expr.type
    if not tp.is_funcptr() and not tp.is_func():
        if verbose:
            print(
                f"[Error] Current member is not a function pointer: {expr.dstr()}. Do you have your cursor on a virtual call?"
            )
        return None
    offset = expr.m
    vtable_type = expr.x.type

    # A bit hack but should work. We could implement a better way to get the name in the future...
    call_name = expr.dstr().split(".")[-1].split("->")[-1]
    return vtable_type, call_name, offset


def show_vtable_xrefs():
    vtable_call = get_vtable_call(verbose=True)
    if vtable_call is None:
        return

    vtable_type, call_name, offset = vtable_call
    actual_type = get_actual_class_from_vtable(vtable_type)
    if actual_type is None:
        print(f"[Error] failed to find actual type for {vtable_type.get_type_name()}")
        return

    matches = get_vtable_xrefs(vtable_type, offset)

    method_name = f"{actual_type.get_type_name()}->{call_name}"
    if not matches:
        print(f"[Error] No implementations found for {method_name}")
    if len(matches) == 1:
        # Just jump to the function
        widgets.jump_to(next(iter(matches.keys())))
    elif matches:
        # Show the results in a chooser
        print(f"Implementations for {method_name}:")
        for ea, cls in matches.items():
            print(f"{hex(ea)}: {memory.name_from_ea(ea)} by {cls}")

        xrefs_choose = EAChoose(
            f"Implementations for {method_name}",
            list(matches.items()),
            col_names=("EA", "Implementing class"),
            modal=True,
        )
        xrefs_choose.show()


def get_vtable_xrefs(vtable_type: tinfo_t, offset: int) -> dict[int, str]:
    """Given a vtable type and offset, return the address of the function at that offset."""
    actual_type = get_actual_class_from_vtable(vtable_type)
    if actual_type is None:
        return {}

    children_classes = tif.get_children_classes(actual_type) or []
    pure_virtual_ea = (
        memory.ea_from_name("___cxa_pure_virtual")
        or memory.ea_from_name("__cxa_pure_virtual")
        or memory.ea_from_name("_cxa_pure_virtual")
    )
    assert pure_virtual_ea is not None
    matches: dict[int, str] = {}  # addr -> class_name

    # Get the base implementation, either from this class or its parent if it is inherited
    parent_impl = get_impl_from_parent(actual_type, offset, pure_virtual_ea)
    if parent_impl is not None:
        matches[parent_impl[0]] = parent_impl[1]

    for cls in children_classes:
        vtable_func_ea = get_vtable_entry(cls, offset, pure_virtual_ea)
        if vtable_func_ea is None:
            continue

        # Add it to the dict if not already present.
        # get_children_classes returns the classes in order of inheritance
        if vtable_func_ea not in matches:
            # noinspection PyTypeChecker
            matches[vtable_func_ea] = cls.get_type_name()  # pyright: ignore[reportArgumentType]
    return matches


def get_impl_from_parent(cls: tinfo_t, offset: int, pure_virtual_ea: int) -> tuple[int, str] | None:
    """
    Given a class and an offset to vtable entry, Iterate over its parents to find what will be the implementation
    for the given offset. If no implementation is found, return None.
    """
    impl, impl_cls = get_vtable_entry(cls, offset, pure_virtual_ea), cls.get_type_name()
    if impl is None:
        # If not implemented in this class, will not be implemented in its parents.
        return None
    for parent_cls in tif.get_parent_classes(cls):
        if offset >= cpp.vtable_methods_count(parent_cls, False) * 8:
            # If offset is greater than the size of the vtable, the method was defined in child class
            break
        this_impl = get_vtable_entry(parent_cls, offset, pure_virtual_ea)
        if this_impl is None or impl != this_impl:
            break
        else:
            impl_cls = parent_cls.get_type_name()

    return impl, f"{impl_cls} (Slot at {cls.get_type_name()})"


def get_vtable_entry(cls: tinfo_t, offset: int, pure_virtual_ea: int) -> int | None:
    """Given a class and an offset to vtable entry, return the ea of the function at the given offset
    if it is not pure virtual."""
    vtable_func_ea = cpp.vtable_func_at(cls, offset)
    return vtable_func_ea if vtable_func_ea and pure_virtual_ea != vtable_func_ea else None


def get_actual_class_from_vtable(vtable_type: tinfo_t) -> tinfo_t | None:
    # It is usually a pointer to a pointer to a vtable
    if vtable_type.is_ptr():
        vtable_type = vtable_type.get_pointed_object()

    return tif.type_from_vtable_type(vtable_type)

```

`src/ioshelper/plugins/kernelcache/func_renamers/__init__.py`:

```py
__all__ = [
    "apply_global_rename",
    "apply_pac",
    "apply_pac_component",
    "local_func_renamer_component",
    "mass_func_renamer_component",
    "rename_function_by_arg",
    "rename_function_by_callback",
]

import ida_kernwin
import idaapi
from ida_kernwin import action_handler_t
from idahelper import widgets

from ioshelper.base.reloadable_plugin import HexraysHookComponent, UIAction, UIActionsComponent

from .external import rename_function_by_arg, rename_function_by_callback
from .func_renamers import apply_global_rename, hooks
from .pac_applier import apply_pac

ACTION_ID = "ioshelper:func_renamer"

local_func_renamer_component = HexraysHookComponent.factory("Local rename based on function calls", [hooks])

mass_func_renamer_component = UIActionsComponent.factory(
    "Mass rename based on function calls",
    [
        lambda core: UIAction(
            ACTION_ID,
            idaapi.action_desc_t(
                ACTION_ID, "Mass rename globals and fields based on specific function calls", FuncRenameGlobalAction()
            ),
            menu_location=UIAction.base_location(core),
        )
    ],
)


class FuncRenameGlobalAction(action_handler_t):
    def activate(self, ctx: ida_kernwin.action_ctx_base_t):
        apply_global_rename()
        return 0

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


ACTION_ID_PAC = "ioshelper:apply_pac_on_function"


apply_pac_component = UIActionsComponent.factory(
    "Apply PAC types on current function",
    [
        lambda core: UIAction(
            ACTION_ID_PAC,
            idaapi.action_desc_t(ACTION_ID_PAC, "Apply PAC types on current function", ApplyPACAction(), "Ctrl+P"),
            menu_location=UIAction.base_location(core),
        )
    ],
)


class ApplyPACAction(action_handler_t):
    def activate(self, ctx: ida_kernwin.action_ctx_base_t) -> bool:
        if ctx.cur_func is None:
            print("[Error] Not inside a function")
            return False

        if apply_pac(ctx.cur_func) and ctx.widget is not None:
            widgets.refresh_widget(ctx.widget)
        return False

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

```

`src/ioshelper/plugins/kernelcache/func_renamers/external.py`:

```py
__all__ = ["rename_function_by_arg", "rename_function_by_callback"]

from collections.abc import Callable

import ida_funcs
from idahelper import memory

from .func_renamers import apply_specific_global_rename
from .renamer import FuncHandler, Modifications
from .visitor import Call, FuncXref, SourceXref, XrefsMatcher


class LogFuncNameRenamer(FuncHandler):
    def __init__(self, func_name: str, get_name: Callable[[Call], str | None], force_name_change: bool = False):
        super().__init__(func_name)
        func_ea = memory.ea_from_name(func_name)
        if func_ea is None:
            raise ValueError(f"Function {func_name} not found")
        func = ida_funcs.get_func(func_ea)
        if func is None:
            raise ValueError(f"Function {func_name} at {func_ea:X} is not a valid function")

        self._func_ea: int = func_ea
        self._get_name: Callable[[Call], str | None] = get_name
        self._force_name_change = force_name_change

    def get_source_xref(self) -> SourceXref | None:
        return FuncXref(self._func_ea)

    def on_call(self, call: Call, modifications: Modifications):
        name = self._get_name(call)
        if name is not None:
            modifications.set_func_name(name, self._force_name_change)


def rename_function_by_arg(func_name: str, arg_index: int, prefix: str = "", force_name_change: bool = False):
    def get_name(call: Call) -> str | None:
        if arg_index >= len(call.params):
            return None
        param = call.params[arg_index]
        if not isinstance(param, str):
            return None
        return f"{prefix}_{param}"

    rename_function_by_callback(func_name, get_name, force_name_change)


def rename_function_by_callback(
    func_name: str, callback: Callable[[Call], str | None], force_name_change: bool = False
):
    renamer = LogFuncNameRenamer(func_name, callback, force_name_change)
    # noinspection PyTypeChecker
    apply_specific_global_rename(renamer, XrefsMatcher.build([(renamer.get_source_xref(), renamer.on_call)]))

```

`src/ioshelper/plugins/kernelcache/func_renamers/func_renamers.py`:

```py
import time
from functools import cache

import ida_hexrays
from ida_hexrays import Hexrays_Hooks, cfunc_t
from idahelper import xrefs
from idahelper.microcode import mba

from .handlers import GLOBAL_HANDLERS, LOCAL_HANDLERS
from .renamer import (
    FuncHandler,
    Modifications,
)
from .visitor import FuncXref, XrefsMatcher, process_function_calls

ALL_HANDLERS = [*LOCAL_HANDLERS, *GLOBAL_HANDLERS]


@cache
def get_global_xref_matcher() -> XrefsMatcher:
    """Get a matcher for global xrefs."""
    callbacks = []
    for handler in GLOBAL_HANDLERS:
        source_xref = handler.get_source_xref()
        if source_xref is None or not isinstance(source_xref, FuncXref):
            continue
        callbacks.append((source_xref, handler.on_call))
    # noinspection PyTypeChecker
    return XrefsMatcher.build(callbacks)


@cache
def get_all_xref_matcher() -> XrefsMatcher:
    """Get a matcher for global xrefs."""
    callbacks = []
    for handler in ALL_HANDLERS:
        source_xref = handler.get_source_xref()
        if source_xref is None:
            continue
        callbacks.append((source_xref, handler.on_call))
    # noinspection PyTypeChecker
    return XrefsMatcher.build(callbacks)


def apply_global_rename():
    before = time.time()
    for i, handler in enumerate(GLOBAL_HANDLERS):
        print(f"Applying global rename {i + 1}/{len(GLOBAL_HANDLERS)}: {handler.name}")
        apply_specific_global_rename(handler, get_global_xref_matcher())
    after = time.time()
    print(f"Completed! Took {int(after - before)} seconds")


def apply_specific_global_rename(handler: FuncHandler, xrefs_matcher: XrefsMatcher):
    source_xref = handler.get_source_xref()
    if source_xref is None or not isinstance(source_xref, FuncXref):
        print(f"Function {handler.name} has no global source xref, skipping")
        return
    func_ea = source_xref.ea

    xrefs_in_funcs = xrefs.func_xrefs_to(func_ea)
    if not xrefs_in_funcs:
        print(f"Function {handler.name} not called")
        return

    print(f"Found {len(xrefs_in_funcs)} functions that call {handler.name}:")
    for j, xref_func_ea in enumerate(xrefs_in_funcs):
        with Modifications(xref_func_ea, func_lvars=None) as modifications:
            print(f"  {j + 1}/{len(xrefs_in_funcs)}: {xref_func_ea:#x}")
            process_function_calls(mba.from_func(xref_func_ea), xrefs_matcher, modifications)


class LocalRenameHooks(Hexrays_Hooks):
    def maturity(self, cfunc: cfunc_t, new_maturity: int) -> int:
        # For some reason, this maturity level is required for typing to be applied for local variables.
        if new_maturity != ida_hexrays.CMAT_CASTED:
            return 0

        with Modifications(cfunc.entry_ea, func_lvars=cfunc.get_lvars()) as modifications:
            process_function_calls(cfunc.mba, get_all_xref_matcher(), modifications)

        return 0


def hooks():
    # Load cache
    get_all_xref_matcher()
    return LocalRenameHooks()

```

`src/ioshelper/plugins/kernelcache/func_renamers/handlers.py`:

```py
__all__ = ["GLOBAL_HANDLERS", "LOCAL_HANDLERS"]


from idahelper import file_format, functions, instructions, memory, tif, xrefs

from .renamer import (
    FuncHandler,
    FuncHandlerByNameWithStringFinder,
    FuncHandlerVirtualGetter,
    FuncHandlerVirtualSetter,
    Modifications,
)
from .visitor import Call, FuncXref, SourceXref


class OSSymbolHandler(FuncHandlerByNameWithStringFinder):
    def __init__(self, name: str, search_string: str):
        super().__init__(
            name,
            tif.from_func_components("OSSymbol*", [tif.FuncParam("const char*", "cString")]),
            search_string,
            is_call=True,
        )

        self._cached_symbol_type = tif.from_c_type("OSSymbol*")

    def on_call(self, call: Call, modifications: Modifications):
        self._rename_assignee_by_index(modifications, call, 0, modifier=lambda name: f"sym_{name}")
        self._retype_assignee(modifications, call, self._cached_symbol_type)


OSSymbol_WithCStringNoCopy = OSSymbolHandler("OSSymbol::withCStringNoCopy", "IOMatchedPersonality")
OSSymbol_WithCString = OSSymbolHandler("OSSymbol::withCString", "ACIPCInterfaceProtocol")


class IORegistry_MakePlane(FuncHandlerByNameWithStringFinder):
    def __init__(self):
        super().__init__(
            "IORegistry::makePlane",
            tif.from_func_components("IORegistryPlane*", [tif.FuncParam("const char*", "name")]),
            "ChildLinks",
            is_call=False,
        )
        self._cached_registry_plane_type = tif.from_c_type("IORegistryPlane*")

    def on_call(self, call: Call, modifications: Modifications):
        self._rename_assignee_by_index(modifications, call, 0, modifier=lambda name: f"plane_{name}")
        self._retype_assignee(modifications, call, self._cached_registry_plane_type)


IOService_SetProperty = [
    FuncHandlerVirtualSetter(
        "IORegistryEntry::setProperty",
        tif.from_c_type("IORegistryEntry"),
        offset,
        name_index=1,
        rename_index=2,
        rename_prefix="val_",
    )
    for offset in range(0xB8, 0xF0, 8)
]
IOService_GetProperty = FuncHandlerVirtualGetter(
    "IORegistryEntry::getProperty", tif.from_c_type("IORegistryEntry"), 0x118, name_index=1, rename_prefix="val_"
)
IOService_CopyProperty = FuncHandlerVirtualGetter(
    "IORegistryEntry::copyProperty", tif.from_c_type("IORegistryEntry"), 0x148, name_index=1, rename_prefix="val_"
)


class MetaClassConstructor(FuncHandlerByNameWithStringFinder):
    def __init__(self):
        super().__init__(
            "__ZN11OSMetaClassC2EPKcPKS_j",
            tif.from_func_components(
                "OSMetaClass*",
                [
                    tif.FuncParam("OSMetaClass*", "this"),
                    tif.FuncParam("const char*", "className"),
                    tif.FuncParam("const OSMetaClass*", "superClass"),
                    tif.FuncParam("unsigned int", "classSize"),
                ],
            ),
            "OSMetaClass: preModLoad() wasn't called for class %s (runtime internal error).",
            is_call=False,
        )

        self._cached_metaclass_type = tif.from_c_type("OSMetaClass*")

    def on_call(self, call: Call, modifications: Modifications):
        self._rename_parameter_by_index(
            modifications,
            call,
            name_index=1,
            rename_index=0,
            modifier=lambda name: f"__ZN{len(name)}{name}10gMetaclassE",
        )
        self._retype_parameter_by_index(modifications, call, 0, self._cached_metaclass_type)


class peParseBootArgn(FuncHandler):
    def __init__(self):
        super().__init__("PE_parse_boot_argn")

    def get_source_xref(self) -> SourceXref | None:
        existing = memory.ea_from_name("PE_parse_boot_argn")
        if existing is not None:
            return FuncXref(existing)

    def on_call(self, call: Call, modifications: Modifications):
        self._rename_parameter_by_index(
            modifications, call, 0, 1, modifier=lambda name: f"boot_{name.replace('-', '_')}"
        )

        if isinstance(call.params[2], int):
            new_type = tif.from_size(call.params[2])
            if new_type is not None:
                self._retype_parameter_by_index(modifications, call, 1, tif.pointer_of(new_type))


class StackCheckFail(FuncHandler):
    def __init__(self):
        # For some reason I cannot set the name of the function to the original name, as IDA hides call to the function
        # So we use a different name
        super().__init__("__xnu_stack_check_fail")

    def get_source_xref(self) -> SourceXref | None:
        existing = memory.ea_from_name(self.name)
        if existing is not None:
            return FuncXref(existing)
        searched = list(xrefs.string_xrefs_to("stack_protector.c"))
        if not searched:
            print("[Error] Could not find xrefs to 'stack_protector.c' for", self.name)
            return None
        ldr_addr = searched[0]

        func_start_ea = StackCheckFail.get_previous_pacibsp(ldr_addr)
        func_end_ea = StackCheckFail.get_after_next_bl(ldr_addr)
        if func_start_ea is None or func_end_ea is None:
            print("[Error] Could not find function boundaries:", self.name)
            return None

        if not functions.is_in_function(func_start_ea) and not functions.add_function(func_start_ea, func_end_ea):
            print(f"[Error] Could not add function {self.name} at {func_start_ea:#x}")
            return None

        if not tif.apply_tinfo_to_ea(tif.from_func_components("void", [tif.FuncParam("void")]), func_start_ea):
            print(f"[Error] Could not apply tinfo to function {self.name} at {func_start_ea:#x}")
            return None

        if not functions.apply_flag_to_function(func_start_ea, functions.FLAG_NO_RETURN):
            print(f"[Error] Could not apply no-return flag to function {self.name} at {func_start_ea:#x}")
            return None

        if not memory.set_name(func_start_ea, self.name, retry=True):
            print(f"[Error] Could not set name for function {self.name} at {func_start_ea:#x}")
            return None

        return FuncXref(func_start_ea)

    @staticmethod
    def get_previous_pacibsp(call_ea: int) -> int | None:
        """Given a call, search previous instructions to find a movk call"""
        insn = instructions.decode_instruction(call_ea)
        if not insn:
            return None

        for _ in range(10):
            insn = instructions.decode_previous_instruction(insn)
            # No more instructions in this execution flow
            if insn is None:
                break
            if insn.get_canon_mnem() == "PAC":
                return insn.ea
        return None

    @staticmethod
    def get_after_next_bl(call_ea: int) -> int | None:
        """Given a call, search previous instructions to find a movk call"""
        insn = instructions.decode_instruction(call_ea)
        if not insn:
            return None

        for _ in range(10):
            insn = instructions.decode_instruction(insn.ea + insn.size)
            # No more instructions in this execution flow
            if insn is None:
                break
            if insn.get_canon_mnem() == "BL":
                return insn.ea + insn.size
        return None

    def on_call(self, call: Call, modifications: Modifications):
        # Do nothing on call, we just want to rename the function
        pass


if file_format.is_kernelcache():
    GLOBAL_HANDLERS: list[FuncHandler] = [
        OSSymbol_WithCStringNoCopy,
        OSSymbol_WithCString,
        IORegistry_MakePlane(),
        MetaClassConstructor(),
    ]
    LOCAL_HANDLERS: list[FuncHandler] = [
        *IOService_SetProperty,
        IOService_GetProperty,
        IOService_CopyProperty,
        peParseBootArgn(),
        StackCheckFail(),
    ]
else:
    GLOBAL_HANDLERS = []
    LOCAL_HANDLERS = []

```

`src/ioshelper/plugins/kernelcache/func_renamers/pac_applier.py`:

```py
from collections.abc import Callable, Iterable, Sequence

import ida_hexrays
import idaapi
from ida_funcs import func_t
from ida_hexrays import cexpr_t, ctree_parentee_t, lvar_t
from ida_typeinf import tinfo_t
from idahelper import tif
from idahelper.ast import cfunc
from idahelper.ast.lvars import VariableModification
from idahelper.pac import client as pac

from ioshelper.base.utils import CustomDict, CustomSet

from .renamer import (
    Modifications,
)
from .visitor import Call, XrefsMatcher, process_function_calls


def apply_pac(func: func_t) -> bool:
    print(f"Trying to apply pac signature on current function: {func.start_ea:X}")
    helper = MostSpecificAncestorHelper()
    xref_matcher = XrefsMatcher.build([], on_unknown_call_wrapper(helper))  # type: ignore  # noqa: PGH003
    decompiled_func = cfunc.from_func(func)
    if decompiled_func is None:
        return False

    with Modifications(decompiled_func.entry_ea, decompiled_func.get_lvars()) as modifications:
        process_function_calls(decompiled_func.mba, xref_matcher, modifications)
        has_changed = False
        for lvar, typ, calls in helper.lvars():
            if not lvar.has_user_type and should_modify_type(lvar.type(), typ):
                has_changed = True
                print(f"Modifying lvar {lvar.name} from {lvar.type()}* to {typ}")
                modifications.modify_local(lvar.name, VariableModification(type=tif.pointer_of(typ)))
                fix_calls(typ, calls)

        for (cls_type, offset), typ, calls in helper.fields():
            typ_res = tif.get_member_recursive(cls_type, offset)
            if typ_res is None:
                print(f"[Warning] Could not find member at offset {offset:X} in {cls_type}")
                continue
            actual_typ, member = typ_res
            if member.size == 64 and should_modify_type(member.type, typ):
                has_changed = True
                print(f"Modifying field {cls_type}::{member.name} from {member.type}* to {typ}")
                # noinspection PyTypeChecker
                modifications.modify_type(
                    actual_typ.get_type_name(),  # pyright: ignore [reportArgumentType]
                    offset,
                    VariableModification(type=tif.pointer_of(typ)),
                )
                fix_calls(typ, calls)

    if has_changed:
        fix_empty_calls(func)

    return has_changed


def fix_empty_calls(func: func_t):
    """If after the modifications there are calls with no parameters, do force the call type as it is better then nothing"""
    decompiled_func = ida_hexrays.decompile(func.start_ea, flags=ida_hexrays.DECOMP_NO_CACHE)
    if decompiled_func is None:
        print(f"[Warning] Could not decompile function {func.start_ea:X} to fix empty calls")
        return

    # noinspection PyTypeChecker
    EmptyCallTreeVisitor().apply_to(decompiled_func.body, None)  # pyright: ignore[reportIncompatibleMethodCall]


class EmptyCallTreeVisitor(ctree_parentee_t):
    def visit_expr(self, expr: cexpr_t) -> int:  # pyright: ignore[reportIncompatibleMethodOverride]
        # Filter dynamic calls with no parameters
        if (
            expr.op != ida_hexrays.cot_call
            or not expr.x.type.is_funcptr()
            or expr.a.size() != 0
            or expr.ea == idaapi.BADADDR
        ):
            return 0

        # Make sure it is a call to a vtable member
        x = expr.x
        # Handle cast of the function type
        if x.op == ida_hexrays.cot_cast:
            x = x.x

        # Check it is a member
        if x.op != ida_hexrays.cot_memptr:
            return 0

        # Check it is a member of a vtable
        possible_vtable_type: tinfo_t = x.x.type
        if not possible_vtable_type.is_ptr() or not possible_vtable_type.get_pointed_object().is_vftable():
            return 0

        # This is a vtable call with no parameters, apply the type to the call
        apply_vtable_type_to_call(expr.ea, possible_vtable_type.get_pointed_object(), expr.x.m, apply_if_no_args=True)
        return 0


def fix_calls(class_type: tinfo_t, calls: list[Call]):
    """Apply the call type from vtable definition to each of the calls in the list."""
    if not calls:
        return

    vtable_type = tif.vtable_type_from_type(class_type)
    if vtable_type is None:
        print(f"[Warning] Could not find vtable type for {class_type}")
        return

    for call in calls:
        assert call.indirect_info is not None
        offset = call.indirect_info.offset
        apply_vtable_type_to_call(call.ea, vtable_type, offset, apply_if_no_args=False)


def apply_vtable_type_to_call(call_ea: int, vtable_type: tinfo_t, offset: int, apply_if_no_args: bool) -> bool:
    """Apply the vtable type to the call at the given ea."""
    vtable_member = tif.get_member(vtable_type, offset)
    if vtable_member is None:
        print(f"[Warning] Could not find vtable member for {vtable_type} at {offset:X}")
        return False

    # There are a lot of false positive signatures that have only "this" argument.
    # We prefer not to force non-arguments calls rather than hide arguments.
    vtable_member_type: tinfo_t = tinfo_t(vtable_member.type)
    vtable_member_type.remove_ptr_or_array()
    if apply_if_no_args or vtable_member_type.get_nargs() != 1:
        tif.apply_tinfo_to_call(vtable_member.type, call_ea)
        print(
            f"Applying vtable type {vtable_member.type} to call at {call_ea:X} for {vtable_type}::{vtable_member.name} at offset {offset:X}"
        )
        return True
    return False


def should_modify_type(current_type: tinfo_t, new_type: tinfo_t) -> bool:
    if current_type == new_type:
        return False
    elif not current_type.is_ptr():
        return True
    current_type.remove_ptr_or_array()

    if current_type.is_void() or not current_type.is_struct() or current_type.get_type_name() == "OSObject":
        return True

    return current_type in tif.get_parent_classes(new_type, True)


class MostSpecificAncestorHelper:
    """Helper class to find the most specific ancestor of a PAC call."""

    def __init__(self):
        self._lvars: CustomDict[lvar_t, CustomSet[tinfo_t]] = CustomDict(lambda v: v.name)
        self._fields: CustomDict[tuple[tinfo_t, int], CustomSet[tinfo_t]] = CustomDict(lambda t: (t[0].get_tid(), t[1]))

        self._lvar_to_calls: CustomDict[lvar_t, list[Call]] = CustomDict(lambda v: v.name)
        self._fields_to_calls: CustomDict[tuple[tinfo_t, int], list[Call]] = CustomDict(
            lambda t: (t[0].get_tid(), t[1])
        )

        self._children_classes_cache: CustomDict[tinfo_t, list[tinfo_t]] = CustomDict(lambda t: t.get_tid())
        """Cache of mapping from a type to its children classes."""

    def update_lvar(self, lvar: lvar_t, predicate: Sequence[tinfo_t], call: Call):
        minimized = self._minimize(predicate)
        if lvar in self._lvars:
            self._lvars[lvar] &= self._children_of_union(minimized)
        else:
            self._lvars[lvar] = self._children_of_union(minimized)

        self._lvar_to_calls.setdefault(lvar, []).append(call)

    def update_field(self, cls_type: tinfo_t, offset: int, predicate: Sequence[tinfo_t], call: Call):
        if cls_type.is_vftable():
            return

        minimized = self._minimize(predicate)
        key = (cls_type, offset)
        if key in self._fields:
            self._fields[key] &= self._children_of_union(minimized)
        else:
            self._fields[key] = self._children_of_union(minimized)

        self._fields_to_calls.setdefault(key, []).append(call)

    def lvars(self) -> Iterable[tuple[lvar_t, tinfo_t, list[Call]]]:
        """Get all lvars with their most specific type."""
        for lvar, state in self._lvars.items():
            ancestor = tif.get_common_ancestor(list(state))
            if ancestor is None:
                continue
            yield lvar, ancestor, self._lvar_to_calls[lvar]

    def fields(self) -> Iterable[tuple[tuple[tinfo_t, int], tinfo_t, list[Call]]]:
        """Get all fields with their most specific type."""
        for field, state in self._fields.items():
            ancestor = tif.get_common_ancestor(list(state))
            if ancestor is None:
                continue
            yield field, ancestor, self._fields_to_calls[field]

    def _get_children_classes(self, typ: tinfo_t) -> list[tinfo_t]:
        """Get all children of a type, caching the result."""
        if typ not in self._children_classes_cache:
            children = tif.get_children_classes(typ) or []
            children.append(typ)
            self._children_classes_cache[typ] = children
        return self._children_classes_cache[typ]

    def _children_of_union(self, union: tuple[tinfo_t, ...]) -> CustomSet[tinfo_t]:
        """Get all children of a union type."""
        children: CustomSet[tinfo_t] = CustomSet(lambda t: t.get_tid())
        children.add_all(union)

        for typ in union:
            children.add_all(self._get_children_classes(typ))
        return children

    @staticmethod
    def _minimize(union: Sequence[tinfo_t]) -> tuple[tinfo_t, ...]:
        """Minimize the union to its most specific types."""
        if len(union) == 1:
            return (union[0],)

        minimized: list[tinfo_t] = []

        for i, typ in enumerate(union):
            # Quick exit if the type is OSObject, as it is a base class for all objects
            if typ.get_type_name() == "OSObject":
                return (typ,)

            typ_parents = tif.get_parent_classes(typ, True)
            for j, other_typ in enumerate(union):
                if i == j:
                    continue

                if other_typ in typ_parents:
                    break
            else:
                minimized.append(typ)

        return tuple(minimized)


def on_unknown_call_wrapper(helper: MostSpecificAncestorHelper) -> Callable[[Call, Modifications], None]:
    def on_unknown_call(call: Call, _modifications: Modifications):
        """Called when a call is found"""
        if call.indirect_info is None:
            return

        prev_movk = pac.get_previous_movk(call.ea)
        if prev_movk is None:
            return
        candidates = pac.pac_class_candidates_from_movk(prev_movk)
        if candidates:
            if call.indirect_info.var is not None:
                lvar = call.indirect_info.var
                helper.update_lvar(lvar, candidates, call)
            elif call.indirect_info.field is not None:
                cls_type, offset = call.indirect_info.field
                helper.update_field(cls_type, offset, candidates, call)

    return on_unknown_call

```

`src/ioshelper/plugins/kernelcache/func_renamers/renamer.py`:

```py
import abc
from abc import ABC
from collections.abc import Callable

import ida_hexrays
from ida_hexrays import lvars_t, minsn_t, mop_t
from ida_typeinf import tinfo_t
from idahelper import memory, tif, xrefs
from idahelper.ast import lvars
from idahelper.ast.lvars import VariableModification

from .visitor import Call, FuncXref, IndirectCallXref, ParsedParam, SourceXref


class Modifications:
    """Represents the modifications to be applied from a traversal of a single function"""

    def __init__(self, func_ea: int, func_lvars: lvars_t | None = None):
        self.func_ea = func_ea
        self.has_func_name = memory.is_user_defined_name(func_ea)
        self.lvars = func_lvars
        self._local_modifications: dict[str, VariableModification] = {}
        self._global_modifications: dict[int, VariableModification] = {}
        self._type_modifications: dict[tuple[str, int], VariableModification] = {}
        self._func_name: str | None = None

    def modify_local(self, name: str, modification: VariableModification):
        self._local_modifications[name] = self._merge_modifications(self._local_modifications.get(name), modification)

    def modify_global(self, ea: int, modification: VariableModification):
        self._global_modifications[ea] = self._merge_modifications(self._global_modifications.get(ea), modification)

    def modify_type(self, name: str, offset: int, modification: VariableModification):
        self._type_modifications[(name, offset)] = self._merge_modifications(
            self._type_modifications.get((name, offset)), modification
        )

    def set_func_name(self, name: str, force_name_change: bool = False):
        if force_name_change or not self.has_func_name:
            self._func_name = name

    def _apply(self):
        """Apply the modifications"""
        self._fix_modifications_name()
        self._apply_local_modifications()
        self._apply_global_modifications()
        self._apply_func_name()
        self._apply_type_modifications()

    def _fix_modifications_name(self):
        fix_name = lambda s: None if s is None else s.replace("-", "_").replace(" ", "_")
        for modification in self._local_modifications.values():
            modification.name = fix_name(modification.name)
        for modification in self._global_modifications.values():
            modification.name = fix_name(modification.name)

    def _apply_local_modifications(self):
        """Apply local modifications"""
        if self._local_modifications and self.lvars is not None:
            lvars.perform_lvar_modifications(self.func_ea, self.lvars, self._local_modifications, temp_fallback=True)

    def _apply_global_modifications(self):
        """Apply global modifications"""
        for ea, modification in self._global_modifications.items():
            if not modification.force_name_change and memory.is_user_defined_name(ea):
                continue
            if modification.name is not None and not memory.set_name(ea, modification.name, retry=True):
                print(f"Could not rename {hex(ea)} to {modification.name}")
            if modification.type is not None and not tif.apply_tinfo_to_ea(modification.type, ea):
                print(f"Could not retype {hex(ea)} to {modification.type}")

    def _apply_func_name(self):
        """Apply function name modification"""
        if self._func_name is not None and not memory.set_name(self.func_ea, self._func_name, retry=True):
            print(f"Could not rename {hex(self.func_ea)} to {self._func_name}")

    def _apply_type_modifications(self):
        """Apply type modifications"""
        for (name, offset), modification in self._type_modifications.items():
            cls_type = tif.from_struct_name(name)
            if cls_type is None:
                print(f"Could not find class type: {name}")
                continue
            member = tif.get_member(cls_type, offset)
            if member is None:
                print(f"Could not find member at offset: {cls_type.dstr()} at {offset}")
                return

            if modification.name is not None and not tif.set_udm_name(cls_type, member, modification.name):
                print(f"Could not rename {cls_type.dstr()} member at offset {offset} to {modification.name}")
            if modification.type is not None and not tif.set_udm_type(cls_type, member, modification.type):
                print(f"Could not retype {cls_type.dstr()} member at offset {offset} to {modification.type.dstr()}")

    # noinspection PyMethodMayBeStatic
    def _merge_modifications(
        self, original: VariableModification | None, new: VariableModification
    ) -> VariableModification:
        """Merge the modifications, preferring the new ones"""
        if original is None:
            return new

        return VariableModification(
            new.name or original.name,
            new.type or original.type,
            new.comment or original.comment,
            new.force_name_change or original.force_name_change,
        )

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._apply()

    def __str__(self):
        return (
            f"Modifications(func_ea={self.func_ea:#x}, local_modifications={self._local_modifications}, "
            f"global_modifications={self._global_modifications}, type_modifications={self._type_modifications}, "
            f"new_name={self._func_name})"
        )


class FuncHandler(abc.ABC):
    def __init__(self, name: str):
        self.name: str = name

    @abc.abstractmethod
    def get_source_xref(self) -> SourceXref | None:
        """Get the source xref of the handler"""
        ...

    @abc.abstractmethod
    def on_call(self, call: Call, modifications: Modifications):
        """Called when a call is found"""
        ...

    def _retype_assignee(
        self, modifications: Modifications, call: Call, new_type: tinfo_t | Callable[[Call], tinfo_t | None] | None
    ):
        """Try to retype the assignee of the call to the given type"""
        if new_type is None:
            # We don't have the type, so we can't retype the assignee
            return None
        elif call.assignee is None:
            print(f"Call {call} has no assignee")
            return

        if new_type is None:
            return
        elif isinstance(new_type, tinfo_t):
            typ = new_type
        else:
            typ = new_type(call)
            if typ is None:
                return

        self.__retype_mop(call.assignee, typ, modifications)

    def _rename_parameter_by_index(
        self,
        modifications: Modifications,
        call: Call,
        name_index: int,
        rename_index: int,
        modifier: Callable[[ParsedParam], str] | None = None,
    ):
        """
        Rename the {rename_index} parameter of the call from parameter {name_index}.
        Optionally, you can pass a modifier that receives the value of the parameter and returns a new name.
        """
        if name_index >= len(call.params) or rename_index >= len(call.params):
            print(
                f"Call {call} has only {len(call.params)} parameters, tried to access {name_index} and {rename_index}"
            )
            return
        param = call.params[name_index]
        if param is None:
            print(f"Call {call} param at index {name_index} is not const: {call.params_op[name_index].dstr()}")
            return
        if modifier is None and not isinstance(param, str):
            print(f"Call {call} param at index {name_index} is not a string: {param}")
            return

        name: str = modifier(param) if modifier else param
        self.__rename_mop(call.params_op[rename_index], name, modifications)

    def _retype_parameter_by_index(
        self,
        modifications: Modifications,
        call: Call,
        index: int,
        new_type: tinfo_t | Callable[[Call], tinfo_t | None] | None,
    ):
        """
        Retype the parameter at index {index}
        """
        if index >= len(call.params):
            print(f"Call {call} has only {len(call.params)} parameters, tried to access {index}")
            return

        if new_type is None:
            return
        elif isinstance(new_type, tinfo_t):
            typ = new_type
        else:
            typ = new_type(call)
            if typ is None:
                return

        self.__retype_mop(call.params_op[index], typ, modifications)

    def _rename_assignee_by_index(
        self, modifications: Modifications, call: Call, index: int, modifier: Callable[[ParsedParam], str] | None = None
    ):
        """
        Rename the assignee of the call to the given index.
        Optionally, you can pass a modifier that receives the value of the parameter and returns a new name.
        """

        if call.assignee is None:
            print(f"Call {call} has no assignee")
            return
        if index >= len(call.params):
            print(f"Call {call} has no parameter at index {index}")
            return
        param = call.params[index]
        if param is None:
            print(f"Call {call} param at index {index} is not const: {call.params_op[index].dstr()}")
            return
        if modifier is None and not isinstance(param, str):
            print(f"Call {call} param at index {index} is not a string: {param}")
            return

        name: str = modifier(param) if modifier else param
        self.__rename_mop(call.assignee, name, modifications)

    # noinspection PyMethodMayBeStatic
    def __retype_mop(self, op: mop_t, typ: tinfo_t, modifications: Modifications):
        """Try to retype the mop to the given name"""
        if op.t == ida_hexrays.mop_v:
            # Global variable
            modifications.modify_global(op.g, VariableModification(type=typ))
        elif op.t == ida_hexrays.mop_l:
            if op.l.off != 0:
                # Local variable with offset are unsupported for now
                print(f"Could not retype mop {op.dstr()} to {typ}: has offset {op.l.off}")
            # Local variable
            modifications.modify_local(op.l.var().name, VariableModification(type=typ))
        elif op.t == ida_hexrays.mop_a:
            # Deref the type
            self.__retype_mop(op.a, typ.get_pointed_object(), modifications)
        elif op.t == ida_hexrays.mop_d:
            inner_insn: minsn_t = op.d
            if ida_hexrays.is_mcode_xdsu(inner_insn.opcode):
                self.__retype_mop(inner_insn.l, typ, modifications)
            else:
                # TODO support fields
                print(f"Could not retype mop {op.dstr()} to {typ}: unsupported type {op.t} yet")

    # noinspection PyMethodMayBeStatic
    def __rename_mop(self, op: mop_t, name: str, modifications: Modifications, follow_address: bool = True):
        """Try to rename the mop to the given name"""
        if op.t == ida_hexrays.mop_v:
            # Global variable
            modifications.modify_global(op.g, VariableModification(name=name, force_name_change=False))
        elif op.t == ida_hexrays.mop_l:
            if op.l.off != 0:
                # Local variable with offset are unsupported for now
                print(f"Could not rename mop {op.dstr()} to {name}: has offset {op.l.off}")
            # Local variable
            modifications.modify_local(op.l.var().name, VariableModification(name=name, force_name_change=False))
        elif follow_address and op.t == ida_hexrays.mop_a:
            # Variable whose address is taken
            self.__rename_mop(op.a, name, modifications, follow_address)
        elif op.t == ida_hexrays.mop_d:
            inner_insn: minsn_t = op.d
            if ida_hexrays.is_mcode_xdsu(inner_insn.opcode):
                self.__rename_mop(inner_insn.l, name, modifications, follow_address)
            else:
                # TODO support fields
                print(f"Could not rename mop {op.dstr()} to {name}: unsupported type {op.t} yet")


class FuncHandlerByNameWithStringFinder(FuncHandler, ABC):
    def __init__(self, name: str, func_type: tinfo_t | None, search_string: str, is_call: bool):
        super().__init__(name)
        self.search_string: str = search_string
        self.func_type: tinfo_t | None = func_type
        self.is_call = is_call

    def get_source_xref(self) -> SourceXref | None:
        if self.func_type is None:
            return None

        existing = memory.ea_from_name(self.name)
        if existing is not None:
            return FuncXref(existing)

        if self.is_call:
            searched = xrefs.find_static_caller_for_string(self.search_string)
        else:
            searched = xrefs.find_func_containing_string(self.search_string)
        if searched is None:
            print("Could not find function", self.name)
            # Could not find the function
            return None

        memory.set_name(searched, self.name, retry=True)
        print(f"Found {self.name} at {searched:#x}, changing name")
        if not tif.apply_tinfo_to_ea(self.func_type, searched):
            print(f"Could not apply type {self.func_type} to {searched:#x}")
            return None

        return FuncXref(searched)


class FuncHandlerVirtualGetter(FuncHandler):
    def __init__(
        self, name: str, obj_type: tinfo_t | None, offset: int, name_index: int, rename_prefix: str | None = None
    ):
        super().__init__(name)
        self.obj_type: tinfo_t | None = obj_type
        self.offset = offset
        self.name_index = name_index
        self.rename_modifier = lambda n: f"{rename_prefix}{n}" if rename_prefix is not None else None

    def get_source_xref(self) -> SourceXref | None:
        if self.obj_type is None:
            return None
        return IndirectCallXref(self.obj_type, self.offset)

    def on_call(self, call: Call, modifications: Modifications):
        self._rename_assignee_by_index(modifications, call, self.name_index, self.rename_modifier)


class FuncHandlerVirtualSetter(FuncHandler):
    def __init__(
        self,
        name: str,
        obj_type: tinfo_t | None,
        offset: int,
        name_index: int,
        rename_index: int,
        rename_prefix: str | None = None,
    ):
        super().__init__(name)
        self.obj_type: tinfo_t | None = obj_type
        self.offset = offset
        self.name_index = name_index
        self.rename_index = rename_index
        self.rename_modifier = lambda n: f"{rename_prefix}{n}" if rename_prefix is not None else None

    def get_source_xref(self) -> SourceXref | None:
        if self.obj_type is None:
            return None
        return IndirectCallXref(self.obj_type, self.offset)

    def on_call(self, call: Call, modifications: Modifications):
        self._rename_parameter_by_index(modifications, call, self.name_index, self.rename_index, self.rename_modifier)

```

`src/ioshelper/plugins/kernelcache/func_renamers/visitor.py`:

```py
from collections.abc import Callable
from dataclasses import dataclass

import ida_hexrays
from ida_hexrays import lvar_t, mba_t, mcallarg_t, minsn_t, mop_t
from ida_typeinf import tinfo_t
from idahelper import memory, tif
from idahelper.microcode import mop
from idahelper.microcode.visitors import extended_microcode_visitor_t

from ..generic_calls_fix import CAST_FUNCTION_NAMES


@dataclass(frozen=True)
class HelperXref:
    name: str


@dataclass(frozen=True)
class FuncXref:
    ea: int


@dataclass(frozen=True)
class IndirectCallXref:
    type: tinfo_t
    offset: int


SourceXref = HelperXref | FuncXref | IndirectCallXref
CallCallback = Callable[["Call", object], None]


@dataclass(frozen=True)
class XrefsMatcher:
    helpers: dict[str, CallCallback]
    """Mapping between helper names and their callbacks"""
    calls: dict[int, CallCallback]
    """Mapping between function addresses and their callbacks"""
    indirect_calls: dict[int, list[tuple[int, CallCallback]]]
    """Mapping between indirect call offset -> type tid -> callback"""
    untyped_indirect_call_fallback: CallCallback | None
    """Callback for indirect call on untyped object"""

    def match_indirect_call(self, typ: tinfo_t, offset: int) -> CallCallback | None:
        if (not typ.is_ptr() and not typ.is_struct()) or (typ.is_ptr() and not typ.get_pointed_object().is_struct()):
            return self.untyped_indirect_call_fallback

        candidates = self.indirect_calls.get(offset)
        if candidates is None:
            return None
        if typ.is_ptr():
            typ = typ.get_pointed_object()

        type_parent_tifs = tif.get_parent_classes(typ)
        if type_parent_tifs is None:
            return None
        type_parent_tifs.append(typ)

        type_parents = {parent.get_tid() for parent in type_parent_tifs}
        for candidate_type, callback in candidates:
            if candidate_type in type_parents:
                return callback

        return None

    @staticmethod
    def build(
        callbacks: list[tuple[SourceXref, CallCallback]], untyped_indirect_callback: CallCallback | None = None
    ) -> "XrefsMatcher":
        """Build a matcher from the given callbacks."""
        helpers = {}
        calls = {}
        indirect_calls = {}
        for xref, callback in callbacks:
            if isinstance(xref, HelperXref):
                helpers[xref.name] = callback
            elif isinstance(xref, FuncXref):
                calls[xref.ea] = callback
            elif isinstance(xref, IndirectCallXref):
                indirect_calls.setdefault(xref.offset, []).append((xref.type.get_tid(), callback))

        return XrefsMatcher(helpers, calls, indirect_calls, untyped_indirect_callback)


def process_function_calls(func_mba: mba_t, matcher: XrefsMatcher, ref: object):
    """Get all calls to the given function in the current function."""
    StaticCallExtractorVisitor(matcher, ref).visit_function(func_mba)


# TODO: This is a hack, we should find a way to remove all consts
CHAR_POINTER_TYPES: list[tinfo_t] = [
    tif.from_c_type("char*"),
    tif.from_c_type("const char*"),
    tif.from_c_type("char* const"),
]  # type: ignore  # noqa: PGH003
VOID_POINTER_TYPE: tinfo_t = tif.from_c_type("void*")  # type: ignore  # noqa: PGH003
ParsedParam = str | int | None


@dataclass
class IndirectCallInfo:
    target_mop: mop_t
    """The target operand of the indirect call"""
    offset: int
    """The offset in the vtable of the call"""
    var: lvar_t | None = None
    """If called on a var, the var"""
    field: tuple[tinfo_t, int] | None = None
    """If called on a field, the type and the offset"""


@dataclass
class Call:
    """A call to a function"""

    func_ea: int
    """The ea of the function"""
    ea: int
    """The ea of the call instruction"""
    params_op: list[mcallarg_t]
    """The operands of the call instruction"""
    params: list[ParsedParam]
    """Parsed params of the call instruction"""
    params_names: list[str | None]
    """If the parameter is a global variable (or reference to it), return its name"""
    assignee: mop_t | None
    """The assignee of this call instruction"""
    indirect_info: IndirectCallInfo | None
    """Info about the indirect call"""

    def __str__(self):
        params_str = ", ".join([
            repr(param) if param is not None else op_param.dstr()
            for param, op_param in zip(self.params, self.params_op)  # noqa: B905
        ])
        assignee_str = f", assignee={self.assignee.dstr()}" if self.assignee is not None else ""
        return f"Call(ea={hex(self.ea)}, params=[{params_str}]{assignee_str}"


class StaticCallExtractorVisitor(extended_microcode_visitor_t):
    def __init__(self, matcher: XrefsMatcher, ref: object):
        super().__init__()
        self.matcher = matcher
        self.has_indirect_calls = bool(matcher.indirect_calls)
        self.has_direct_calls = bool(matcher.calls) or bool(matcher.helpers)
        self.ref = ref

    def _visit_insn(self, ins: minsn_t) -> int:
        if ins.opcode == ida_hexrays.m_call and self.has_direct_calls:
            self._visit_call(ins)
            return 0
        elif ins.opcode == ida_hexrays.m_icall:  # and self.has_indirect_calls:
            self._visit_icall(ins)
            return 0

        return 0

    def _visit_call(self, ins: minsn_t):
        """Search for direct call and invoke the callback."""
        if ins.l.t == ida_hexrays.mop_v:
            callback = self.matcher.calls.get(ins.l.g)
        elif ins.l.t == ida_hexrays.mop_h:
            callback = self.matcher.helpers.get(ins.l.helper)
        else:
            return

        if callback is None:
            return

        callback(self._build_call_for_callback(ins, indirect_info=None), self.ref)

    def _visit_icall(self, ins: minsn_t):  # noqa: C901
        # Search for indirect call of x->vtable->func or x->field->vtable->func
        # Which is x => *x => *x->vtable (offset 0) => *x->vtable + offsetOf(func) => *x->vtable->func
        # Expects ldx
        if ins.r.t != ida_hexrays.mop_d or ins.r.d.opcode != ida_hexrays.m_ldx:
            return

        # Expects add
        ldx_ins = ins.r.d
        if ldx_ins.r.t != ida_hexrays.mop_d or ldx_ins.r.d.opcode != ida_hexrays.m_add:
            return
        add_ins = ldx_ins.r.d

        # Expects add with const
        const_offset = mop.get_const_int(add_ins.r)
        if const_offset is None:
            return

        # Except ldx
        if add_ins.l.t != ida_hexrays.mop_d or add_ins.l.d.opcode != ida_hexrays.m_ldx:
            return
        ldx_ins_2 = add_ins.l.d

        # Maybe expect local
        if ldx_ins_2.r.t == ida_hexrays.mop_l:
            lvar = ldx_ins_2.r.l.var()
            lvar_type = lvar.type()
            callback = self.matcher.match_indirect_call(lvar_type, const_offset)
            indirect_info = IndirectCallInfo(ldx_ins_2.r, const_offset, var=lvar)
        # Maybe expect ldx of an add with const (field)
        elif ldx_ins_2.r.t == ida_hexrays.mop_d and ldx_ins_2.r.d.opcode == ida_hexrays.m_ldx:
            ldx_ins_3 = ldx_ins_2.r.d

            # Expect add with const
            if ldx_ins_3.r.t != ida_hexrays.mop_d or ldx_ins_3.r.d.opcode != ida_hexrays.m_add:
                return

            add_ins_2 = ldx_ins_3.r.d
            const_offset_2 = mop.get_const_int(add_ins_2.r)
            if const_offset_2 is None:
                return

            # Expect local
            if add_ins_2.l.t != ida_hexrays.mop_l:
                return

            lvar = add_ins_2.l.l.var()
            lvar_type: tinfo_t = lvar.type()
            if lvar_type.is_ptr():
                lvar_type = lvar_type.get_pointed_object()
            field_type = self._try_get_member_type(lvar_type, const_offset_2)
            callback = self.matcher.match_indirect_call(field_type, const_offset)
            indirect_info = IndirectCallInfo(ldx_ins_2.r, const_offset, field=(lvar_type, const_offset_2))
        else:
            return

        if callback is None:
            return

        callback(self._build_call_for_callback(ins, indirect_info), self.ref)

    @staticmethod
    def _try_get_member_type(typ: tinfo_t, offset: int) -> tinfo_t:
        res = tif.get_member_recursive(typ, offset)
        return tinfo_t(res[1].type) if res is not None else VOID_POINTER_TYPE

    def _build_call_for_callback(self, ins: minsn_t, indirect_info: IndirectCallInfo | None) -> Call:
        """Build a Call object for the given instruction."""
        params: list[mcallarg_t] = list(ins.d.f.args)
        parsed_params = [_parse_param(param) for param in params]
        parsed_params_name = [_parse_param_name(param) for param in params]
        assignee = _try_extract_assignee(self.parents)
        return Call(self.mba.entry_ea, ins.ea, params, parsed_params, parsed_params_name, assignee, indirect_info)


def _try_extract_assignee(parents: list[mop_t | minsn_t]) -> mop_t | None:
    """
    Try to extract the assignee from the parents of the call.
    """
    if not parents:
        # Direct call instruction, no assignee
        return None
    assert len(parents) >= 2, f"Expected at least 2 parents, got {len(parents)}: {[p.dstr() for p in parents]}"

    # Skip the first parent, which is the mop_d wrapper
    parent = parents[-2]
    # Mop can be a child of the following:
    # - direct instruction operand (l,r,d)
    # - function argument
    # - ref to a variable - not if we are a function call
    # - pair - never seen this so let's ignore it
    if isinstance(parent, mop_t):
        # In this case we are a function argument, therefore no assignee
        assert parent.t == ida_hexrays.mop_f, f"Expected mop_f, got {parent.dstr()}"
        # If this is a dynamic cast, we can try to unwrap it
        call: minsn_t = parents[-3]
        if call.l.t == ida_hexrays.mop_h and any(
            call.l.helper.startswith(cast_name) for cast_name in CAST_FUNCTION_NAMES
        ):
            # Skip the cast helper and try to extract the assignee from the next parent
            return _try_extract_assignee(parents[:-3])

        return None
    # minsn_t case
    elif parent.is_like_move() or parent.opcode == ida_hexrays.m_stx:
        # Check there is an actual assignee and not a nop one
        if parent.d.t != ida_hexrays.mop_z:
            return parent.d

    # Not a move or store, no assignee
    return None


def _parse_param(param: mcallarg_t) -> ParsedParam:
    """Try to parse the param to python constant"""
    if _is_string_param(param):
        return mop.get_str(param)
    return mop.get_const_int(param)


def _parse_param_name(param: mcallarg_t) -> str | None:
    """Try to parse the parameter global name"""
    if param.t == ida_hexrays.mop_v:
        return memory.name_from_ea(param.g)
    elif param.t == ida_hexrays.mop_a and param.a.t == ida_hexrays.mop_v:
        return memory.name_from_ea(param.a.g)

    return None


def _is_string_param(param: mcallarg_t) -> bool:
    """Check if the param is a string pointer."""
    if param.type.is_ptr_or_array() and param.type.get_pointed_object().is_char():
        return True

    # Sometimes IDA decides it is a _QWORD even though the signature has char* and this is string const.
    # Let's assume it is a string param and see if it decodes
    return mop.get_str(param) is not None

```

`src/ioshelper/plugins/kernelcache/generic_calls_fix/__init__.py`:

```py
__all__ = ["CAST_FUNCTION_NAMES", "generic_calls_fix_component"]

from ioshelper.base.reloadable_plugin import OptimizersComponent

from .generic_calls_fix import CAST_FUNCTIONS, generic_calls_fix_optimizer_t

generic_calls_fix_component = OptimizersComponent.factory("Generic calls fixer", [generic_calls_fix_optimizer_t])

CAST_FUNCTION_NAMES = list(CAST_FUNCTIONS.values())

```

`src/ioshelper/plugins/kernelcache/generic_calls_fix/generic_calls_fix.py`:

```py
__all__ = ["CAST_FUNCTIONS", "generic_calls_fix_optimizer_t"]

import re

import ida_hexrays
from ida_hexrays import mblock_t, mcallarg_t, mcallargs_t, mcallinfo_t, minsn_t, minsn_visitor_t
from ida_typeinf import tinfo_t
from idahelper import cpp, tif
from idahelper.microcode import mcallarg, minsn, mop

from ioshelper.base.utils import CounterMixin, match_dict

CAST_FUNCTIONS: dict[str | re.Pattern, str] = {
    "OSMetaClassBase::safeMetaCast": "OSDynamicCast",
    "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass": "OSDynamicCast",
    "OSMetaClassBase::requiredMetaCast": "OSRequiredCast",
    "__ZN15OSMetaClassBase16requiredMetaCastEPKS_PK11OSMetaClass": "OSDynamicCast",
}

ALLOC_FUNCTION: dict[str | re.Pattern, str] = {
    "OSObject_typed_operator_new": "OSObjectTypeAlloc",
    "_OSObject_typed_operator_new": "OSObjectTypeAlloc",
}

OS_OBJECT_TYPE: tinfo_t = tif.from_c_type("OSObject*")  # type: ignore  # noqa: PGH003
SIZE_T_TYPE: tinfo_t = tif.from_c_type("size_t")  # type: ignore  # noqa: PGH003


class insn_optimizer_t(minsn_visitor_t, CounterMixin):
    def visit_minsn(self) -> int:
        # We only want calls
        insn: minsn_t = self.curins
        if insn.opcode == ida_hexrays.m_call:
            self.visit_call_insn(insn, self.blk)
        return 0

    def visit_call_insn(self, insn: minsn_t, blk: mblock_t):
        res = self.try_convert_cast(insn)
        if not res:
            self.try_convert_alloc(insn)

    def try_convert_alloc(self, insn: minsn_t) -> bool:
        name = minsn.get_func_name_of_call(insn)
        if name is None or (new_name := match_dict(ALLOC_FUNCTION, name)) is None:
            return False

        # Verify call info
        call_info = self.get_call_info(insn, 2)
        if call_info is None:
            return True

        # Get the kty
        kty_name = self.get_arg_name(call_info, 0)
        if kty_name is None or not kty_name.endswith("_kty"):
            # No name, cannot optimize
            return True
        kty_name = kty_name[:-4]

        # Get the class
        cls_type = tif.from_struct_name(kty_name)
        if cls_type is None:
            print(f"[Error] Failed to get type for class: {kty_name}")
            return True

        self.modify_call(cls_type, new_name, insn, call_info, 0, SIZE_T_TYPE)
        return True

    def try_convert_cast(self, insn: minsn_t) -> bool:
        name = minsn.get_func_name_of_call(insn)
        if name is None or (new_name := match_dict(CAST_FUNCTIONS, name)) is None:
            return False

        # Verify call info
        call_info = self.get_call_info(insn, 2)
        if call_info is None:
            return True

        # Convert name to type
        cls_name_mangled = self.get_arg_name(call_info, 1)
        if cls_name_mangled is None:
            # No name, cannot optimize
            return True

        cls_name = cpp.demangle_class_only(cls_name_mangled)
        if cls_name is None:
            print(f"[Error] Failed to extract class name: {cls_name_mangled}")
            return True

        # Get the class
        cls_type = tif.from_struct_name(cls_name)
        if cls_type is None:
            print(f"[Error] Failed to get type for class: {cls_name}")
            return True

        self.modify_call(cls_type, new_name, insn, call_info, 1, OS_OBJECT_TYPE)
        return True

    def get_call_info(self, call_insn: minsn_t, required_args_count: int) -> mcallinfo_t | None:
        """Get call info of the given call instruction, verifying it has the required args count"""
        call_info: mcallinfo_t | None = call_insn.d.f
        if call_info is None or len(call_info.args) != required_args_count:
            return None
        return call_info

    def get_arg_name(self, call_info: mcallinfo_t, arg_index: int) -> str | None:
        """Get the name of the {arg_index} argument, assuming it is a global one"""
        arg: mcallarg_t = call_info.args[arg_index]
        if arg.t != ida_hexrays.mop_a:
            # not const
            return None

        return mop.get_name(arg.a)

    def modify_call(
        self,
        cls_type: tinfo_t,
        new_name: str,
        insn: minsn_t,
        call_info: mcallinfo_t,
        arg_to_remove: int,
        single_arg_type: tinfo_t,
    ) -> None:
        # Assumes size is 2

        cls_type_pointer = tif.pointer_of(cls_type)

        # Check if already handled
        if call_info.return_type == cls_type_pointer:
            return

        # Apply name and type changes
        insn.l.make_helper(f"{new_name}<{cls_type.get_type_name()}>")
        call_info.return_type = cls_type_pointer

        # Remove metaclass arg
        args: mcallargs_t = call_info.args
        if arg_to_remove == 0:
            args[0].swap(args[1])

        args.pop_back()
        call_info.solid_args -= 1

        # Remove the name associated with the first parameter, so there will be no inlay hint
        new_arg = mcallarg.from_mop(call_info.args[0], single_arg_type)
        call_info.args.pop_back()
        call_info.args.push_back(new_arg)

        self.count()


class generic_calls_fix_optimizer_t(ida_hexrays.optinsn_t):
    def func(self, blk: mblock_t, ins: minsn_t, optflags: int):
        # Let IDA reconstruct the calls before
        if blk.mba.maturity < ida_hexrays.MMAT_CALLS:
            return 0

        insn_optimizer = insn_optimizer_t(blk.mba, blk)
        ins.for_all_insns(insn_optimizer)
        return insn_optimizer.cnt

```

`src/ioshelper/plugins/kernelcache/kalloc_type/__init__.py`:

```py
__all__ = ["apply_kalloc_type_component", "apply_kalloc_types", "create_type_from_kalloc_component"]

import ida_kernwin
import idaapi
from ida_kernwin import action_handler_t
from idahelper import tif

from ioshelper.base.reloadable_plugin import UIAction, UIActionsComponent

from .kalloc_type import apply_kalloc_types, create_struct_from_kalloc_type

ACTION_ID_APPLY_KALLOC_TYPE = "ioshelper:apply_kalloc_type"

apply_kalloc_type_component = UIActionsComponent.factory(
    "Locate all the kalloc_type_view in the kernelcache and apply them on types",
    [
        lambda core: UIAction(
            ACTION_ID_APPLY_KALLOC_TYPE,
            idaapi.action_desc_t(
                ACTION_ID_APPLY_KALLOC_TYPE,
                "Locate all the kalloc_type_view in the kernelcache and apply them on types",
                ApplyKallocTypesAction(),
            ),
            menu_location=UIAction.base_location(core),
        )
    ],
)

ACTION_ID_CREATE_TYPE_FROM_KALLOC = "ioshelper:create_type_from_kalloc"


def dynamic_menu_add(widget, _popup) -> bool:
    if idaapi.get_widget_type(widget) != idaapi.BWN_DISASM:
        return False
    current_ea = idaapi.get_screen_ea()
    typ = tif.from_ea(current_ea)
    return typ is not None and typ.get_type_name() == "kalloc_type_view"


create_type_from_kalloc_component = UIActionsComponent.factory(
    "Create a struct from the currently selected kalloc_type_view",
    [
        lambda core: UIAction(
            ACTION_ID_CREATE_TYPE_FROM_KALLOC,
            idaapi.action_desc_t(
                ACTION_ID_CREATE_TYPE_FROM_KALLOC,
                "Create a struct from the currently selected kalloc_type_view",
                CreateTypeFromKalloc(),
            ),
            dynamic_menu_add=dynamic_menu_add,
            menu_location=UIAction.base_location(core),
        )
    ],
)


class ApplyKallocTypesAction(action_handler_t):
    def activate(self, ctx: ida_kernwin.action_ctx_base_t):
        apply_kalloc_types()
        return 0

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class CreateTypeFromKalloc(action_handler_t):
    def activate(self, ctx: ida_kernwin.action_ctx_base_t):
        create_struct_from_kalloc_type(ctx)
        return 0

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

```

`src/ioshelper/plugins/kernelcache/kalloc_type/kalloc_type.py`:

```py
__all__ = ["apply_kalloc_types", "create_struct_from_kalloc_type"]

import ida_kernwin
from ida_typeinf import tinfo_t
from idahelper import memory, segments, tif, widgets

KALLOC_TYPE_DEFINITIONS = """
struct zone_view {
    void*          zv_zone;
    void*    zv_stats;
    const char     *zv_name;
    void*     zv_next;
};

enum kalloc_type_flags_t : uint32_t {
    KT_DEFAULT        = 0x0001,
    KT_PRIV_ACCT      = 0x0002,
    KT_SHARED_ACCT    = 0x0004,
    KT_DATA_ONLY      = 0x0008,
    KT_VM             = 0x0010,
    KT_CHANGED        = 0x0020,
    KT_CHANGED2       = 0x0040,
    KT_PTR_ARRAY      = 0x0080,
    KT_NOSHARED       = 0x2000,
    KT_SLID           = 0x4000,
    KT_PROCESSED      = 0x8000,
    KT_HASH           = 0xffff0000,
};

struct kalloc_type_view {
    struct zone_view        kt_zv;
    const char             *kt_signature;
    kalloc_type_flags_t     kt_flags;
    uint32_t                kt_size;
    void                   *unused1;
    void                   *unused2;
};

struct kalloc_type_var_view {
	uint16_t                kt_version;
	uint16_t                kt_size_hdr;
	uint32_t                kt_size_type;
	void                   *kt_stats;
	const char             *kt_name;
	void                   *kt_next;
	uint16_t                kt_heap_start;
	uint8_t                 kt_zones[22];
	const char             *kt_sig_hdr;
	const char             *kt_sig_type;
	kalloc_type_flags_t     kt_flags;
}
"""
KALLOC_TYPE_VIEW_OFFSET_NAME = 16  # void *zv_zone + void *zv_stats
KALLOC_TYPE_VIEW_OFFSET_SIGNATURE = 32  # zone_view

KALLOC_TYPE_VAR_VIEW_OFFSET_NAME = (
    16  # uint16_t kt_version + uint16_t kt_size_hdr + uint32_t kt_size_type + void* kt_stats
)

VOID_PTR_TYPE: tinfo_t = tif.from_c_type("void*")  # type: ignore   # noqa: PGH003


def apply_kalloc_types():
    kalloc_type_view_tif = tif.from_struct_name("kalloc_type_view")
    kalloc_type_var_view_tif = tif.from_struct_name("kalloc_type_var_view")
    if kalloc_type_view_tif is None or kalloc_type_var_view_tif is None:
        if not tif.create_from_c_decl(KALLOC_TYPE_DEFINITIONS):
            print("[Error] failed to created kalloc_type_view type")

        kalloc_type_view_tif = tif.from_struct_name("kalloc_type_view")
        kalloc_type_var_view_tif = tif.from_struct_name("kalloc_type_var_view")
        if kalloc_type_view_tif is None or kalloc_type_var_view_tif is None:
            print("[Error] could not find kalloc type view")
            return

    classes_handled: set[str] = set()
    for segment in segments.get_segments():
        if segment.name.endswith("__kalloc_type"):
            set_kalloc_type_for_segment(segment, kalloc_type_view_tif, classes_handled)
        if segment.name.endswith("__kalloc_var"):
            set_kalloc_var_for_segment(segment, kalloc_type_var_view_tif)


def set_kalloc_type_for_segment(segment: segments.Segment, kalloc_type_view_tif: tinfo_t, classes_handled: set[str]):
    kalloc_type_view_size = kalloc_type_view_tif.get_size()

    if segment.size % kalloc_type_view_size != 0:
        print(
            f"[Warning] {segment.name} at {segment.start_ea:X} is not a multiple of kalloc_type_view size. is: {segment.size}, not multiple of: {kalloc_type_view_size}"
        )
        return

    for kty_ea in range(segment.start_ea, segment.end_ea, kalloc_type_view_size):
        if not tif.apply_tinfo_to_ea(kalloc_type_view_tif, kty_ea):
            print(f"[Error] failed to apply kalloc_type_view on {kty_ea:X}")

        site_name_ea = memory.qword_from_ea(kty_ea + KALLOC_TYPE_VIEW_OFFSET_NAME)
        site_name = memory.str_from_ea(site_name_ea)
        if site_name is None:
            print(f"[Error] failed to read name for kalloc_type_view on {kty_ea:X}")
            continue

        if not site_name.startswith("site."):
            print(f"[Error] invalid site name on {kty_ea:X}, is: {site_name!r}")
            continue

        class_name = site_name[5:]
        if class_name.startswith("struct "):
            class_name = class_name[7:]
        if class_name.startswith("typeof(") or class_name == "T":
            # Clang generates them using macro, so it might lead to some eccentric specific ones...
            continue

        new_name = f"{escape_name(class_name)}_kty"
        if not memory.set_name(kty_ea, new_name, retry=True, retry_count=50):
            print(f"[Error] failed to rename kalloc_type_view on {kty_ea:X} to {new_name!r}")
            continue

        signature_ea = memory.qword_from_ea(kty_ea + KALLOC_TYPE_VIEW_OFFSET_SIGNATURE)
        signature = memory.str_from_ea(signature_ea)
        if signature is None:
            print(f"[Error] failed to read signature for {new_name} on {kty_ea:X}")
            continue

        try_enrich_type(class_name, signature, classes_handled)


def try_enrich_type(class_name: str, signature: str, classes_handled: set[str]):
    # Don't try to enrich the same type multiple times
    if class_name in classes_handled:
        return
    classes_handled.add(class_name)

    class_tif = tif.from_struct_name(class_name)
    if class_tif is None:
        return

    class_base_offset = tif.get_base_offset_for_class(class_tif)
    if class_base_offset is None:
        return

    # Align it to multiplication of 8
    class_base_offset = int((class_base_offset + 7) / 8) * 8

    # The signature is on 8 bytes each time
    for i in range(class_base_offset // 8, len(signature)):
        c = signature[i]
        if c != "1":
            continue

        member = tif.get_member(class_tif, i * 8)
        if member is None:
            print(f"[Error] {class_name} has no member for at offset {i * 8:#X}")
            return

        # I check for if this is a pointer, because if it was union of data + pointer, the compiler should have yelled
        # So if you changed the type to non pointer, you were mistaken...
        if not member.type.is_ptr() and not tif.set_udm_type(class_tif, member, VOID_PTR_TYPE):
            print(f"[Error] failed to set type for {class_name} member at offset {member.offset}")


def set_kalloc_var_for_segment(segment: segments.Segment, kalloc_type_var_view_tif: tinfo_t):
    kalloc_type_view_size = kalloc_type_var_view_tif.get_size()

    if segment.size % kalloc_type_view_size != 0:
        print(
            f"[Warning] {segment.name} at {segment.start_ea:X} is not a multiple of kalloc_type_view size. is: {segment.size}, not multiple of: {kalloc_type_view_size}"
        )
        return

    for kty_ea in range(segment.start_ea, segment.end_ea, kalloc_type_view_size):
        if not tif.apply_tinfo_to_ea(kalloc_type_var_view_tif, kty_ea):
            print(f"[Error] failed to apply kalloc_type_view on {kty_ea:X}")

        site_name_ea = memory.qword_from_ea(kty_ea + KALLOC_TYPE_VAR_VIEW_OFFSET_NAME)
        site_name = memory.str_from_ea(site_name_ea)
        if site_name is None:
            print(f"[Error] failed to read name for kalloc_type_view on {kty_ea:X}")
            continue

        if not site_name.startswith("site."):
            print(f"[Error] invalid site name on {kty_ea:X}, is: {site_name!r}")
            continue

        class_name = site_name[5:]
        if class_name.startswith("struct "):
            class_name = class_name[7:]
        if class_name.startswith("typeof(") or class_name == "T":
            # Clang generates them using macro, so it might lead to some eccentric specific ones...
            continue

        new_name = f"{escape_name(class_name)}_kty"
        if not memory.set_name(kty_ea, new_name, retry=True, retry_count=50):
            print(f"[Error] failed to rename kalloc_type_view on {kty_ea:X} to {new_name!r}")
            continue


def create_struct_from_kalloc_type(ctx: ida_kernwin.action_ctx_base_t):
    kty_ea: int = ctx.cur_ea
    cur_type = tif.from_ea(kty_ea)
    if cur_type is None or cur_type.get_type_name() != "kalloc_type_view":
        print(f"[Error] You must be on a kalloc_type_view to create the struct. Current addr: {kty_ea:X}")
        return

    signature_ea = memory.qword_from_ea(kty_ea + KALLOC_TYPE_VIEW_OFFSET_SIGNATURE)
    signature = memory.str_from_ea(signature_ea)
    if signature is None:
        print(f"[Error] failed to read signature for {kty_ea:X}")
        return

    site_name_ea = memory.qword_from_ea(kty_ea + KALLOC_TYPE_VIEW_OFFSET_NAME)
    site_name = memory.str_from_ea(site_name_ea)
    class_name = None
    if site_name is None:
        print(f"[Error] failed to read name for kalloc_type_view on {kty_ea:X}")
    elif not site_name.startswith("site."):
        print(f"[Error] invalid site name on {kty_ea:X}, is: {site_name!r}")
    else:
        class_name = site_name[5:]
        if class_name.startswith("struct "):
            class_name = class_name[7:]
        if class_name.startswith("typeof(") or class_name == "T":
            # Clang generates them using macro, so it might lead to some eccentric specific ones...
            class_name = None

    chosen_name = widgets.show_string_input("Choose class name", class_name or site_name)
    if chosen_name is None:
        return
    chosen_name = chosen_name.strip()
    if not chosen_name:
        return

    create_struct_from_name_signature(class_name, signature)


def create_struct_from_name_signature(class_name: str, signature: str) -> bool:
    existing_type = tif.from_struct_name(class_name)
    if existing_type is not None:
        print(f"[Error] struct for {class_name} already exists")
        return False

    struct_definition = f"struct {class_name} {{\n"
    for i, t in enumerate(signature):
        t = int(t)
        field_name = f"field_{i * 8:#04x}"
        type_def = "void*" if t & 1 != 0 else "__int64"
        struct_definition += f"    {type_def} {field_name};\n"
    struct_definition += "};"

    if not tif.create_from_c_decl(struct_definition):
        print(f"[Error] failed to create struct for {class_name}")
        return False
    print(f"[Info] Created struct for {class_name}")

    return True


def escape_name(site_name: str) -> str:
    return site_name.replace("*", "_ptr_").replace(" ", "_").replace("<", "_").replace(">", "_")

```

`src/ioshelper/plugins/kernelcache/obj_this/__init__.py`:

```py
__all__ = ["this_arg_fixer_component"]

import ida_kernwin
import idaapi
from ida_kernwin import action_handler_t
from idahelper import functions, widgets

from ioshelper.base.reloadable_plugin import UIAction, UIActionsComponent

from .obj_this import update_argument

ACTION_ID = "ioshelper:this_arg_fixer"


def dynamic_menu_add(widget, _popup) -> bool:
    if idaapi.get_widget_type(widget) not in (idaapi.BWN_DISASM, idaapi.BWN_PSEUDOCODE):
        return False
    current_ea = idaapi.get_screen_ea()
    return functions.is_in_function(current_ea)


this_arg_fixer_component = UIActionsComponent.factory(
    "Convert first argument to this/self",
    [
        lambda core: UIAction(
            ACTION_ID,
            idaapi.action_desc_t(
                ACTION_ID,
                "Update the first function argument to this/self and change its type",
                ThisArgFixerAction(),
                "Ctrl+T",
            ),
            dynamic_menu_add=dynamic_menu_add,
        )
    ],
)


class ThisArgFixerAction(action_handler_t):
    def activate(self, ctx: ida_kernwin.action_ctx_base_t):
        if ctx.cur_func is None:
            print("[Error] Not inside a function")
            return False

        if update_argument(ctx.cur_func) and ctx.widget is not None:
            widgets.refresh_widget(ctx.widget)
        return False

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

```

`src/ioshelper/plugins/kernelcache/obj_this/obj_this.py`:

```py
__all__ = ["update_argument"]

from ida_funcs import func_t
from idahelper import cpp, memory, objc, tif


def update_argument(func: func_t) -> bool:
    func_name = memory.name_from_ea(func.start_ea)
    if func_name is None:
        print("[Error] Failed to get function name")
        return False

    if objc.is_objc_method(func_name):
        if objc.is_objc_static_method(func_name):
            print("[Error] Static Obj-C method has no self")
            return False

        is_objc = True
        class_name = func_name.split(" ")[0][2:]
    else:
        # Try C++
        is_objc = False
        class_name = cpp.demangle_class_only(memory.name_from_ea(func.start_ea))
        if class_name is None:
            print("[Error] Failed to get class name in C++ mode")
            return False

    func_details = tif.get_func_details(func)
    if func_details is None:
        print("[Error] Failed to get function type info")
        return False

    if func_details.size() < 1:
        print("[Error] Function does not have enough arguments")
        return False

    # Change first argument name and type
    class_tinfo = tif.from_struct_name(class_name)
    if class_tinfo is None:
        print(f"[Error] Failed to get class type info for {class_name}")
        return False

    func_details[0].name = "self" if is_objc else "this"
    func_details[0].type = tif.pointer_of(class_tinfo)

    # Apply the changes
    new_tinfo = tif.from_func_details(func_details)
    if not tif.apply_tinfo_to_func(new_tinfo, func):
        print("[Error] Failed to apply new type info on function")
        return False

    print("Successfully updated first argument")
    return True

```

`src/ioshelper/plugins/objc/objc_ref/__init__.py`:

```py
__all__ = ["objc_xrefs_component"]

import ida_kernwin
import idaapi

from ioshelper.base.reloadable_plugin import UIAction, UIActionsComponent

from .objc_ref import locate_selector_xrefs

ACTION_ID = "ioshelper:show_objc_xrefs"

objc_xrefs_component = UIActionsComponent.factory(
    "Show objc xrefs",
    [
        lambda core: UIAction(
            ACTION_ID,
            idaapi.action_desc_t(
                ACTION_ID, "Show xrefs for current Obj-C method's selector", ShowObjcXrefsActionHandler(), "Ctrl+4"
            ),
        )
    ],
)


class ShowObjcXrefsActionHandler(ida_kernwin.action_handler_t):
    def activate(self, ctx):
        locate_selector_xrefs()
        return 0

    def update(self, ctx) -> int:
        return idaapi.AST_ENABLE_ALWAYS

```

`src/ioshelper/plugins/objc/objc_ref/objc_ref.py`:

```py
__all__ = ["locate_selector_xrefs"]

import idautils
import idc
from idahelper.widgets import EAChoose

# Taken from: https://github.com/doronz88/ida-scripts/blob/main/objc_hotkeys.py
IGNORED_SECTIONS = ("__objc_const",)


def get_name_for_ea(ea: int) -> str:
    func_name = idc.get_func_name(ea)
    func_address = idc.get_name_ea_simple(func_name)
    return func_name if ea == func_address else f"{func_name}+{ea - func_address:08x}"


def locate_selector_xrefs() -> None:
    current_ea = idc.get_screen_ea()
    func_name = idc.get_func_name(current_ea)
    try:
        selector = func_name.split(" ")[1].split("]")[0]
    except IndexError:
        print("Failed to find current selector")
        return
    print(f"looking for references to: {selector}")

    items = [
        (ea.frm, get_name_for_ea(ea.frm))
        for ea in idautils.XrefsTo(idc.get_name_ea_simple(f"_objc_msgSend${selector}"))
    ]
    if items:
        for ea, name in items:
            print(f"0x{ea:08x} {name}")
        xrefs_choose = EAChoose(f"Xrefs to selector: {selector}", items, modal=True)
        xrefs_choose.show()

```

`src/ioshelper/plugins/objc/objc_refcnt/__init__.py`:

```py
__all__ = ["component"]

from ioshelper.base.reloadable_plugin import OptimizersComponent

from .optimizer import objc_calls_optimizer_t as optimizer

component = OptimizersComponent.factory("Obj-C refcount optimizer", [optimizer])

```

`src/ioshelper/plugins/objc/objc_refcnt/optimizer.py`:

```py
__all__ = ["objc_calls_optimizer_t"]

import re

import ida_hexrays
from ida_hexrays import (
    mblock_t,
    mcallinfo_t,
    minsn_t,
    minsn_visitor_t,
    mop_t,
    mop_visitor_t,
)
from idahelper.microcode import minsn, mreg

from ioshelper.base.utils import CounterMixin, match

# Replace f(x) with x
ID_FUNCTIONS_TO_REPLACE_WITH_ARG: list[str | re.Pattern] = [
    "objc_retain",
    "objc_retainAutorelease",
    "objc_autoreleaseReturnValue",
    "objc_autorelease",
    "_objc_claimAutoreleasedReturnValue",
    re.compile(r"_objc_claimAutoreleasedReturnValue_(\d+)"),
    "_objc_retainBlock",
    "objc_unsafeClaimAutoreleasedReturnValue",
    "objc_retainAutoreleasedReturnValue",
    "_swift_bridgeObjectRetain",
]

# Remove f(x) calls
VOID_FUNCTIONS_TO_REMOVE_WITH_SINGLE_ARG: list[str | re.Pattern] = [
    # Objective-C
    "objc_release",
    # intrinsics
    "__break",
    # CFoundation
    "_CFRelease",
    re.compile(r"_CFRelease_(\d+)"),
    # swift
    "_swift_bridgeObjectRelease",
]

VOID_FUNCTION_TO_REMOVE_WITH_MULTIPLE_ARGS: list[str | re.Pattern] = [
    # Blocks
    "__Block_object_dispose",
    "_Block_object_dispose",
    re.compile(r"__Block_object_dispose_(\d+)"),
]

# Replace assign(&x, y) with x = y;
ASSIGN_FUNCTIONS: list[str | re.Pattern] = [
    "_objc_storeStrong",
    "j__objc_storeStrong",
    re.compile(r"j__objc_storeStrong_(\d+)"),
]


class mop_optimizer_t(mop_visitor_t, CounterMixin):
    def visit_mop(self, op: mop_t, tp, is_target: bool) -> int:
        # No assignment dest, we want a call instruction
        if not is_target and op.d is not None:
            self.visit_instruction_mop(op)
        return 0

    def visit_instruction_mop(self, op: mop_t):
        # We only want calls
        insn: minsn_t = op.d
        if insn.opcode != ida_hexrays.m_call:
            return

        # Calls with names
        name = minsn.get_func_name_of_call(insn)
        if name is None:
            return

        # If it should be optimized to first arg, optimize
        if match(ID_FUNCTIONS_TO_REPLACE_WITH_ARG, name):
            fi: mcallinfo_t = insn.d.f
            if fi.args.empty():
                # No arguments, probably IDA have not optimized it yet
                return

            # Swap mop containing call with arg0
            op.swap(fi.args[0])
            self.count()


class insn_optimizer_t(minsn_visitor_t, CounterMixin):
    def visit_minsn(self) -> int:
        # We only want calls
        insn: minsn_t = self.curins
        if insn.opcode == ida_hexrays.m_call:
            self.visit_call_insn(insn, self.blk)
        return 0

    def visit_call_insn(self, insn: minsn_t, blk: mblock_t):
        # Calls with names
        name = minsn.get_func_name_of_call(insn)
        if name is None:
            return

        for optimization in [
            self.void_function_to_remove,
            self.id_function_to_replace_with_their_arg,
            self.assign_functions,
        ]:
            # noinspection PyArgumentList
            if optimization(name, insn, blk):
                return

    def void_function_to_remove(self, name: str, insn: minsn_t, blk: mblock_t) -> bool:
        if match(VOID_FUNCTIONS_TO_REMOVE_WITH_SINGLE_ARG, name):
            single_arg = True
        elif match(VOID_FUNCTION_TO_REMOVE_WITH_MULTIPLE_ARGS, name):
            single_arg = False
        else:
            return False

        fi: mcallinfo_t = insn.d.f
        if fi.args.empty() or (single_arg and len(fi.args) != 1):
            # No arguments, probably not optimized yet
            # Or not matching the number of arguments
            return False

        if any(arg.has_side_effects() for arg in fi.args):
            print("[Error] arguments with side effects are not supported yet!")
            return False

        if not fi.return_type or not fi.return_type.is_void():
            # embedded instruction, the result can be assigned to something.
            print(
                f"[Error] Cannot remove {name} as this is an embedded instruction. Is the return type correct? it should be void."
            )
            return False

        blk.make_nop(insn)
        self.count()
        return True

    def id_function_to_replace_with_their_arg(self, name: str, insn: minsn_t, _blk: mblock_t) -> bool:
        if not match(ID_FUNCTIONS_TO_REPLACE_WITH_ARG, name):
            return False

        # Might be a call with destination (for example, if it is the last statement in the function)
        fi: mcallinfo_t = insn.d.f
        if fi.args.empty() or fi.retregs.empty():
            # No arguments (probably not optimized yet) or no return reg
            return False

        # Make instruction mov instead of call
        insn.opcode = ida_hexrays.m_mov
        insn.l.swap(fi.args[0])
        insn.d.swap(fi.retregs[0])
        self.count()
        return True

    def assign_functions(self, name: str, insn: minsn_t, _blk: mblock_t) -> bool:
        if not match(ASSIGN_FUNCTIONS, name):
            return False

        fi: mcallinfo_t = insn.d.f
        if fi.args.size() != 2:
            # Not enough argument, probably not optimized yet
            return False
        insn.opcode = ida_hexrays.m_stx
        # src
        insn.l.swap(fi.args[1])
        # dest
        insn.d.swap(fi.args[0])
        # seg - need to be CS/DS according to the docs.
        insn.r.make_reg(mreg.cs_reg(), 2)
        self.count()
        return True


class objc_calls_optimizer_t(ida_hexrays.optinsn_t):
    def func(self, blk: mblock_t, ins: minsn_t, optflags: int):
        # Let IDA reconstruct the calls before
        if blk.mba.maturity < ida_hexrays.MMAT_CALLS:
            return 0

        mop_optimizer = mop_optimizer_t(blk.mba, blk)
        insn_optimizer = insn_optimizer_t(blk.mba, blk)
        ins.for_all_ops(mop_optimizer)
        ins.for_all_insns(insn_optimizer)
        changes = mop_optimizer.cnt + insn_optimizer.cnt
        if changes:
            blk.mark_lists_dirty()
        return changes

```

`src/ioshelper/plugins/objc/objc_sugar/__init__.py`:

```py
__all__ = ["objc_sugar_component"]

from ioshelper.base.reloadable_plugin import HexraysHookComponent

from .objc_sugar import objc_selector_hexrays_hooks_t

objc_sugar_component = HexraysHookComponent.factory("ObjcSugar", [objc_selector_hexrays_hooks_t])

```

`src/ioshelper/plugins/objc/objc_sugar/objc_sugar.py`:

```py
__all__ = ["objc_selector_hexrays_hooks_t"]

import itertools
import re

import ida_hexrays
from ida_hexrays import Hexrays_Hooks, carg_t, carglist_t, cexpr_t, cfunc_t, citem_t
from ida_kernwin import simpleline_t
from ida_lines import (
    COLOR_OFF,
    COLOR_ON,
    COLSTR,
    SCOLOR_ADDR,
    SCOLOR_DEMNAME,
    SCOLOR_IMPNAME,
    SCOLOR_LOCNAME,
    SCOLOR_SYMBOL,
    tag_remove,
)
from ida_pro import strvec_t
from idahelper import memory, objc
from idahelper.ast import cexpr

SELECTOR_MARKER = "!@#$sel$#@!"
COMMA_COLORED = COLSTR(",", SCOLOR_SYMBOL)
INSIGNIFICANT_LENGTH_FOR_LINE = 5
MAX_LINE_SIZE = 120


# COLOR_ON = 0x1, SCOLOR_ADDR = 0x28, SCOLOR_LOCNAME = 0x19, SCOLOR_SYMBOL = 0x9

SEL_TOKEN_REGEX = re.compile(
    "(?P<prefix>"
    + re.escape(COMMA_COLORED + " ")
    + r")?"
    + re.escape(COLOR_ON + SCOLOR_ADDR)
    + r"(?P<index>[0-9A-Fa-f]{16})"
    + re.escape(COLOR_ON + SCOLOR_ADDR)
    + r"(?P=index)"
    + re.escape(COLSTR('"', SCOLOR_SYMBOL))
    + re.escape(COLOR_ON + SCOLOR_LOCNAME)
    + r"(?P<selector>[A-Za-z0-9_:]+)"
    + '"'
    + re.escape(COLOR_OFF + SCOLOR_LOCNAME)
)

"""
a regex for a possible selector in IDA's pseudocode, with support for the prefix ", "
Its groups are: prefix, index, and selector.
"""

SEL_TOKEN_REGEX_2 = re.compile(
    "(?P<prefix>"
    + re.escape(COMMA_COLORED + " ")
    + r")?"
    + re.escape(COLOR_ON + SCOLOR_ADDR)
    + r"(?P<index>[0-9A-Fa-f]{16})"
    + re.escape(COLOR_ON + SCOLOR_LOCNAME)
    + r'"(?P<selector>[A-Za-z0-9_:]+)"'
    + re.escape(COLOR_OFF + SCOLOR_LOCNAME)
)
"""
another regex for a possible selector in IDA's pseudocode that I found in IDA 9.2, with support for the prefix ", "
Its groups are: prefix, index, and selector.
"""

SEL_TOKEN_REGEXES = [SEL_TOKEN_REGEX, SEL_TOKEN_REGEX_2]

# noinspection RegExpDuplicateCharacterInClass
CLASS_TOKEN_REGEX = re.compile(
    re.escape(COLOR_ON + SCOLOR_ADDR)
    + r"(?P<index>[0-9A-Fa-f]{16})"
    + re.escape(COLSTR("&", SCOLOR_SYMBOL))
    + re.escape(COLOR_ON + SCOLOR_ADDR)
    + r"(?P<index2>[0-9A-Fa-f]{16})"
    + re.escape(COLOR_ON)
    + ("[" + re.escape(SCOLOR_IMPNAME) + "|" + re.escape(SCOLOR_DEMNAME) + "]")
    + "OBJC_CLASS___"
    + "(?P<class>[A-Za-z0-9_]+)"
    + re.escape(COLOR_OFF)
    + ("[" + re.escape(SCOLOR_IMPNAME) + "|" + re.escape(SCOLOR_DEMNAME) + "]")
    + "(?P<postfix>"
    + re.escape(COMMA_COLORED)
    + r" ?)?"
)
"""
a regex for possible obj-c class in IDA's pseudocode, with support for the postfix ","
Its groups are: index, index2, class and postfix.
"""


class objc_selector_hexrays_hooks_t(Hexrays_Hooks):
    def func_printed(self, cfunc: cfunc_t) -> int:  # noqa: C901
        selectors_to_remove: dict[int, str] = {}  # obj_id -> selector
        classes_to_remove: set[int] = set()  # obj_id
        index_to_sel: dict[int, str] = {}  # index, selector
        class_indices_to_remove: set[int] = set()  # index

        for i, call_item in enumerate(cfunc.treeitems):
            call_item: citem_t
            # Get the index of the selector/class AST element
            if call_item.obj_id in selectors_to_remove:
                index_to_sel[i] = selectors_to_remove.pop(call_item.obj_id)
            elif call_item.obj_id in classes_to_remove:
                class_indices_to_remove.add(i)
                classes_to_remove.remove(call_item.obj_id)

            elif call_item.op == ida_hexrays.cot_call:
                call_expr: cexpr_t = call_item.cexpr

                # 1. Check if the function name looks like an Obj-C method
                call_func_name = cexpr.get_call_name(call_expr)
                if call_func_name is None or not objc.is_objc_method(call_func_name):
                    continue

                # 2. Collect selector from arglist
                arglist: carglist_t = call_expr.a
                if len(arglist) < 2:
                    print("[Error]: Obj-C method call with less than 2 arguments:", call_expr.dstr())
                    continue
                sel_arg: carg_t = arglist[1]
                if sel_arg.op == ida_hexrays.cot_str:
                    selectors_to_remove[sel_arg.obj_id] = sel_arg.string
                elif sel_arg.op == ida_hexrays.cot_obj and (sel := memory.str_from_ea(sel_arg.obj_ea)) is not None:
                    selectors_to_remove[sel_arg.obj_id] = sel
                else:
                    print("[Error]: Obj-C method call with non-string selector:", call_expr.dstr())
                    continue

                # 3. Check if the function is a class method
                if objc.is_objc_static_method(call_func_name):
                    # 4. Check if the class name is a ref to obj
                    class_arg: carg_t = arglist[0]
                    if class_arg.op != ida_hexrays.cot_ref or class_arg.x.op != ida_hexrays.cot_obj:
                        print("[Error]: Obj-C class method with unsupported class", call_expr.dstr())
                        continue
                    # 5. Collect the class name
                    classes_to_remove.add(class_arg.obj_id)

        if selectors_to_remove or classes_to_remove:
            print("[Error]: unmatched Obj-C selectors in the function: ", hex(cfunc.entry_ea))
        elif index_to_sel:
            modify_text(cfunc, index_to_sel, class_indices_to_remove)
        return 0


def modify_text(cfunc: cfunc_t, index_to_sel: dict[int, str], class_indices_to_remove: set[int]):
    # Early return if no tokens to replace
    if not index_to_sel:
        return

    ps: strvec_t = cfunc.get_pseudocode()
    lines_marked_for_removal: list[simpleline_t] = []
    for i, line in enumerate(ps):
        line: simpleline_t
        prev_line = ps[i - 1].line if i != 0 else ""
        should_merge = modify_selectors(index_to_sel, line, prev_line)
        should_merge |= modify_class(class_indices_to_remove, line, prev_line)

        if should_merge and i != 0:
            lines_marked_for_removal.append(line)
            merge(line.line, ps[i - 1])

    # Remove lines that are marked for removal
    for line_to_remove in reversed(lines_marked_for_removal):
        ps.erase(line_to_remove)


def modify_selectors(index_to_sel: dict[int, str], line: simpleline_t, prev_line: str):
    """Try to remove selectors from a line. Returns whether we should merge the line with the previous line"""
    should_merge = False
    # Find all obj-c calls in the line
    results_unsorted = itertools.chain(*[re.finditer(pattern, line.line) for pattern in SEL_TOKEN_REGEXES])
    # Reverse the results so indices will not change
    results = sorted(results_unsorted, key=lambda m: m.start(), reverse=True)
    for result in results:
        result: re.Match
        index = int(result.group("index"), 16)
        if index in index_to_sel:
            # We found a selector token, remove it from the list
            sel = index_to_sel.pop(index)
            if sel != result.group("selector"):
                print("[Error]: selector mismatch. Expected:", sel, "Actual:", result.group("selector"))
                continue

            # Remove the selector, check if we need to merge lines
            left, right = result.span()
            before_selector, after_selector = line.line[:left], line.line[right:]
            should_merge = should_merge or should_merge_line(before_selector, after_selector, prev_line)
            line.line = before_selector + after_selector
    return should_merge


def modify_class(class_indices_to_remove: set[int], line: simpleline_t, prev_line: str):
    """Try to remove class from a line. Returns whether we should merge the line with the previous line"""
    should_merge = False

    # Reverse the results so indices will not change
    for result in reversed(list(re.finditer(CLASS_TOKEN_REGEX, line.line))):
        result: re.Match
        index = int(result.group("index"), 16)
        index2 = int(result.group("index2"), 16)
        if index in class_indices_to_remove:
            # We found a class token, remove it from the list
            class_indices_to_remove.remove(index)

            if index2 != index + 1:
                print("[Error]: class indices mismatch for second object. Expected:", index + 1, "Actual:", index2)
                continue

            # Remove the class, check if we need to merge lines
            left, right = result.span()
            before_class, after_class = line.line[:left], line.line[right:]
            should_merge = should_merge or should_merge_line(before_class, after_class, prev_line)
            line.line = before_class + after_class
    return should_merge


def should_merge_line(before_selector: str, after_selector: str, prev_line: str) -> bool:
    """
    Given a `line` with a selector marker and the previous line, should we merge the two lines.
    """
    before_without_tags = tag_remove(before_selector)

    # We only remove lines that starts with the selector
    if before_without_tags and not before_without_tags.isspace():
        return False

    after_without_tags = tag_remove(after_selector)
    # If the line is short, allow merging
    if len(after_without_tags) < INSIGNIFICANT_LENGTH_FOR_LINE:
        return True

    # Merge if it will not lead to a long line
    prev_line_without_tags = tag_remove(prev_line)
    return len(after_without_tags) + len(prev_line_without_tags) < MAX_LINE_SIZE


def merge(text: str, line: simpleline_t) -> None:
    """Merge `text` to the end of `line`. If `line` ends with a comma, the comma will be removed."""
    line_without_tags = tag_remove(line.line)
    if line_without_tags.endswith(","):
        last_comma_index = line.line.rfind(COMMA_COLORED)
        line.line = line.line[:last_comma_index] + line.line[last_comma_index + len(COMMA_COLORED) :]
    line.line += text.strip()


def to_hex(n: int, *, length: int) -> str:
    """Convert an integer to a hex string with leading zeros"""
    return f"{n:0{length}X}"

```

`src/ioshelper/plugins/objc/oslog/__init__.py`:

```py
__all__ = ["component"]

from ioshelper.base.reloadable_plugin import OptimizersComponent

from .error_case_optimizer import log_error_case_optimizer_t
from .log_enabled_optimizer import os_log_enabled_optimizer_t
from .log_macro_optimizer import optimizer as log_macro_optimizer

component = OptimizersComponent.factory(
    "os_log optimizer", [log_error_case_optimizer_t, log_macro_optimizer, os_log_enabled_optimizer_t]
)

```

`src/ioshelper/plugins/objc/oslog/error_case_optimizer.py`:

```py
__all__ = ["log_error_case_optimizer_t"]

import re

import ida_hexrays
from ida_hexrays import mblock_t, minsn_t, minsn_visitor_t, mop_t, mop_visitor_t, optinsn_t
from idahelper.microcode import mop

from ioshelper.base.utils import CounterMixin, match_dict

# Replace var with val
VARIABLES_TO_OPTIMIZE_OUT: dict[str | re.Pattern, int] = {
    "_gNumLogObjects": 0x1000,
    re.compile(r"_gNumLogObjects_(\d+)"): 0x1000,
    "_gNumLogSignpostObjects": 0x1000,
    re.compile(r"_gNumLogSignpostObjects_(\d+)"): 0x1000,
}

# replace jz var, 0, #addr with goto/nop
# bool is "isZero"
JZ_TO_OPTIMIZE: dict[str | re.Pattern, bool] = {
    "_gLogObjects": False,
    re.compile(r"_gLogObjects_(\d+)"): False,
    "_gLogSignpostObjects": False,
    re.compile(r"_gLogSignpostObjects_(\d+)"): False,
}


class variable_optimizer_t(mop_visitor_t, CounterMixin):
    def visit_mop(self, op: mop_t, tp, is_target) -> int:
        # we want global mops
        if is_target or op.g is None:
            return 0

        # We want named global
        name = mop.get_name(op)
        if name is None:
            return 0

        # Convert number to the optimized value
        if (val := match_dict(VARIABLES_TO_OPTIMIZE_OUT, name)) is not None:
            op.make_number(val, op.size)
            self.count()

        return 0


class jz_optimizer_t(minsn_visitor_t, CounterMixin):
    def visit_minsn(self) -> int:
        insn: minsn_t = self.curins
        if insn.opcode not in [ida_hexrays.m_jnz, ida_hexrays.m_jz]:
            return 0

        # We want conditions on global variables
        name = mop.get_name(insn.l)
        if name is None:
            return 0

        if (is_zero := match_dict(JZ_TO_OPTIMIZE, name)) is not None:
            #     not zero, zero
            # jnz     1       0
            # jz      0       1
            should_jmp = is_zero == (insn.opcode == ida_hexrays.m_jz)

            # We don't optimize it directly to goto/nop, since it will require blocks in/out.
            # IDA can optimize it for us :)
            insn.l.make_number(0, 1)
            insn.r.make_number(0, 1)
            insn.opcode = ida_hexrays.m_jz if should_jmp else ida_hexrays.m_jnz
            self.count()

        return 0


class log_error_case_optimizer_t(optinsn_t):
    def func(self, blk: mblock_t, insn: minsn_t, optflags: int) -> int:
        if blk.mba.maturity < ida_hexrays.MMAT_CALLS:
            return 0

        variable_optimizer = variable_optimizer_t()
        jz_optimizer = jz_optimizer_t()
        insn.for_all_ops(variable_optimizer)
        insn.for_all_insns(jz_optimizer)
        cnt = variable_optimizer.cnt + jz_optimizer.cnt

        if cnt:
            blk.mark_lists_dirty()
        return cnt

```

`src/ioshelper/plugins/objc/oslog/log_enabled_optimizer.py`:

```py
__all__ = ["os_log_enabled_optimizer_t"]

import re

import ida_hexrays
from ida_hexrays import (
    mblock_t,
    mcallinfo_t,
    minsn_t,
    mop_t,
    mop_visitor_t,
)
from idahelper.microcode import minsn

from ioshelper.base.utils import CounterMixin, match

from . import os_log

OSLOG_FUNCTIONS_TO_REPLACE_WITH_HELPER: list[str | re.Pattern] = [
    "_os_log_type_enabled",
    re.compile(r"_os_log_type_enabled_(\d+)"),
]
OSLOG_TYPE_INDEX = 1

SIGNPOST_FUNCTIONS_TO_REPLACE_WITH_HELPER: list[str | re.Pattern] = [
    "_os_signpost_enabled",
    re.compile(r"_os_signpost_enabled_(\d+)"),
]


class mop_optimizer_t(mop_visitor_t, CounterMixin):
    def visit_mop(self, op: mop_t, tp, is_target: bool) -> int:
        # No assignment dest, we want a call instruction
        if not is_target and op.d is not None:
            self.visit_instruction_mop(op)
        return 0

    def visit_instruction_mop(self, op: mop_t) -> None:
        # We only want calls
        insn: minsn_t = op.d
        if insn.opcode != ida_hexrays.m_call:
            return

        # Calls with names
        name = minsn.get_func_name_of_call(insn)
        if name is None:
            return

        # If it should be optimized to first arg, optimize
        if match(OSLOG_FUNCTIONS_TO_REPLACE_WITH_HELPER, name):
            fi: mcallinfo_t = insn.d.f
            if fi.args.empty():
                # No arguments, probably IDA have not optimized it yet
                return

            # Log type
            log_type_arg = fi.args[OSLOG_TYPE_INDEX]
            if log_type_arg.t != ida_hexrays.mop_n:
                return
            log_type = log_type_arg.unsigned_value()

            # Change name
            insn.l.make_helper(f"oslog_{os_log.log_type_to_str(log_type, is_signpost=False)}_enabled")
            self.count()
            # Remove arguments
            fi.args.clear()
            fi.solid_args = 0
            self.count()
        elif match(SIGNPOST_FUNCTIONS_TO_REPLACE_WITH_HELPER, name):
            fi: mcallinfo_t = insn.d.f

            # Change name
            insn.l.make_helper("ossignpost_enabled")
            self.count()
            # Remove arguments
            fi.args.clear()
            fi.solid_args = 0
            self.count()


class os_log_enabled_optimizer_t(ida_hexrays.optinsn_t):
    def func(self, blk: mblock_t, ins: minsn_t, optflags: int) -> int:
        # Let IDA reconstruct the calls before
        if blk.mba.maturity < ida_hexrays.MMAT_CALLS:
            return 0

        mop_optimizer = mop_optimizer_t(blk.mba, blk)
        ins.for_all_ops(mop_optimizer)
        changes = mop_optimizer.cnt
        if changes:
            blk.mark_lists_dirty()
        return changes

```

`src/ioshelper/plugins/objc/oslog/log_macro_optimizer.py`:

```py
import dataclasses
from enum import Enum

import ida_hexrays
from ida_hexrays import mblock_t, mcallinfo_t, minsn_t, mop_t, optblock_t
from ida_typeinf import tinfo_t
from idahelper import tif
from idahelper.microcode import mblock, mcallarg, minsn, mop
from idahelper.microcode.optimizers import optblock_counter_t, optblock_counter_wrapper_t

from .os_log import LogCallInfo, LogCallParams, get_call_info_for_name, log_type_to_str


def log_func_to_tif() -> tinfo_t | None:
    """Create tif for a log function: void f(char *fmt, ...)"""
    return tif.from_func_components("void", [tif.FuncParam("char*", "fmt"), tif.FuncParam("...")])


class ScanLogState(Enum):
    HEADER = 0
    ITEM_HEADER = 1
    ITEM_VALUE = 2


@dataclasses.dataclass
class CollectLogParamsResult:
    instructions: list[minsn_t]
    call_params: list[mop_t]


# noinspection PyMethodMayBeStatic
class log_macro_optimizer_t(optblock_counter_t):
    def func(self, blk: mblock_t) -> int:
        if blk.mba.maturity < ida_hexrays.MMAT_CALLS:
            return 0

        self.optimize_log_macro(blk)

        if self.cnt:
            blk.mark_lists_dirty()
        return self.cnt

    def optimize_log_macro(self, blk: mblock_t) -> None:
        # Find log call and extract params
        if (res := self.find_log_call(blk)) is None:
            return
        call_insn, params = res

        # Collect parameters to log
        log_params_res = self.collect_log_params(blk, params)
        if log_params_res is None:
            return

        # All instructions up to the call are part of the logging macro starting from `from_index`,
        # so they can be safely removed.
        # First, convert the call insn to the helper call
        prefix = "ossignpost_" if params.is_signpost else "os_log_"
        call_insn.l.make_helper(f"{prefix}{log_type_to_str(params.log_type, params.is_signpost)}")
        self.count()

        # Then modify callinfo
        # Remove all arguments.
        fi: mcallinfo_t = call_insn.d.f
        fi.args.clear()
        # Not necessary but IDA will crash on inconsistency, and we prefer to keep it alive if there is a bug.
        fi.solid_args = 0
        self.count()

        # Add optional name string argument
        if params.name_str_ea is not None:
            new_arg = mcallarg.from_mop(mop.from_global_ref(params.name_str_ea), tif.from_c_type("char*"))
            fi.args.push_back(new_arg)
            fi.solid_args += 1
            self.count()

        # Add format string argument
        new_arg = mcallarg.from_mop(mop.from_global_ref(params.format_str_ea), tif.from_c_type("char*"))
        fi.args.push_back(new_arg)
        fi.solid_args += 1
        self.count()

        # Add params
        for param in log_params_res.call_params:
            fi.args.push_back(mcallarg.from_mop(param, tif.from_size(param.size)))
            fi.solid_args += 1
            self.count()

        # Apply final type signature. For some reason `set_type` crashes IDA, but swap works great...
        fi.get_type().swap(log_func_to_tif())  # TODO: sometimes IDA inserts incorrect casts. Fix it.
        self.count()

        # Finally, convert other instructions (that are part of the log macro) to nop
        for insn in log_params_res.instructions:
            blk.make_nop(insn)
            self.count()

    def collect_log_params(self, blk: mblock_t, params: LogCallParams) -> CollectLogParamsResult | None:  # noqa: C901
        """
        Collect the parameters of a log macro starting from `params.call_ea` and going backwards.
        Returns the index of the first instruction that is a part of the macro and the list of parameters.
        """
        base = params.stack_base_offset
        end = base + params.size
        call_params: list[mop_t] = []
        buffer_instructions: list[minsn_t] = []
        buffer_size = 0
        size_left_for_header: int | None = None
        state = ScanLogState.HEADER

        for insn in mblock.instructions(blk):
            # Stop at the call
            if insn.ea == params.call_ea:
                break

            if not self.check_insn_part_of_log_macro(insn, params.call_ea, base, end):
                continue

            buffer_instructions.append(insn)

            # Advance state
            if state == ScanLogState.HEADER:
                if insn.l.size == 2:
                    # Only the header
                    state = ScanLogState.ITEM_HEADER
                elif insn.l.size == 4:
                    # Header + item header
                    state = ScanLogState.ITEM_VALUE
                else:
                    print(f"[Error] invalid log macro header size of {hex(params.call_ea)}: {insn.dstr()}")
                    return None
            elif state == ScanLogState.ITEM_HEADER:
                if insn.d.size != 2:
                    if insn.d.size > 2:
                        print(
                            f"[Error] Unsupported log macro because header size is bigger than 2 bytes: {insn.dstr()}"
                        )
                        return None
                    elif size_left_for_header is None:
                        size_left_for_header = 2 - insn.d.size
                    else:
                        size_left_for_header -= insn.d.size
                        if size_left_for_header == 0:
                            state = ScanLogState.ITEM_VALUE
                            size_left_for_header = None
                else:
                    state = ScanLogState.ITEM_VALUE
            else:
                call_params.append(insn.l)
                state = ScanLogState.ITEM_HEADER

            buffer_size += insn.d.size

        if state == ScanLogState.HEADER:
            # Never found the beginning of the log macro
            return None
        elif state == ScanLogState.ITEM_VALUE:
            print(f"[Error] failed to parse log macro of {hex(params.call_ea)}")
            return None

        if buffer_size != params.size:
            print(
                f"[Error] log macro size mismatch of {hex(params.call_ea)}: "
                f"expected - {params.size}, found - {buffer_size}"
            )
            return None

        return CollectLogParamsResult(buffer_instructions, call_params)

    def find_log_call(self, blk: mblock_t) -> tuple[minsn_t, LogCallParams] | None:
        """Find an `os_log` call in the given block and extract the parameters from it"""
        for insn in mblock.instructions(blk):
            if insn.opcode != ida_hexrays.m_call:
                continue

            # Search for log call
            call_name = minsn.get_func_name_of_call(insn)
            if (call_info := get_call_info_for_name(call_name)) is None:
                continue

            params = self.extract_params_from_log_call(insn, call_info)
            if params is None:
                continue

            return insn, params
        return None

    def check_insn_part_of_log_macro(
        self, insn: minsn_t, call_ea: int, base: int, end: int, print_error: bool = False
    ) -> bool:
        """Check that the given `insn` is indeed part of a log macro"""
        # It is an Assignment
        if insn.opcode not in [
            ida_hexrays.m_mov,
            ida_hexrays.m_and,
            ida_hexrays.m_xds,
            ida_hexrays.m_xdu,
            ida_hexrays.m_low,
        ]:
            if print_error:
                print(f"[Error] unsupported instruction in log block of {hex(call_ea)}: {insn.dstr()}")
            return False

        # To stack
        if insn.d.t != ida_hexrays.mop_S:
            if print_error:
                print(f"[Error] unsupported dest in log block of {hex(call_ea)}: {insn.dstr()}")
            return False

        # in range
        addr, size = insn.d.s.off, insn.d.size
        if not (base <= addr and addr + size <= end):
            if print_error:
                print(f"[Error] assignment not in range in log block of {hex(call_ea)}: {insn.dstr()}")
            return False

        return True

    def extract_params_from_log_call(self, insn: minsn_t, log_call_info: LogCallInfo) -> LogCallParams | None:
        """Given the log call instruction and information about the indices to extract, extract them"""
        call_info: mcallinfo_t = insn.d.f
        if call_info.args.empty():
            # Not calls args, probably too early in IDA's optimization
            return None

        # Get operands
        size_param = call_info.args[log_call_info.size_index]
        buf_param = call_info.args[log_call_info.buf_index]
        format_param = call_info.args[log_call_info.format_index]
        type_param = call_info.args[log_call_info.type_index]
        name_param = call_info.args[log_call_info.name_index] if log_call_info.name_index is not None else None
        # Verify types of operands
        if (
            size_param.t != ida_hexrays.mop_n
            or type_param.t != ida_hexrays.mop_n
            or not format_param.is_glbaddr()
            or buf_param.t != ida_hexrays.mop_a
            or (name_param is not None and not name_param.is_glbaddr())
        ):
            return None

        size = size_param.unsigned_value()
        log_type = type_param.unsigned_value()
        format_str_ea = format_param.a.g
        name_str_ea = name_param.a.g if name_param is not None else None
        # Check if this is a stack variable
        if buf_param.a.t != ida_hexrays.mop_S:
            return None
        stack_base_offset = buf_param.a.s.off
        return LogCallParams(
            log_type, size, stack_base_offset, format_str_ea, insn.ea, name_str_ea, log_call_info.is_signpost
        )


def optimizer() -> optblock_t:
    return optblock_counter_wrapper_t(log_macro_optimizer_t)

```

`src/ioshelper/plugins/objc/oslog/os_log.py`:

```py
__all__ = ["LogCallInfo", "LogCallParams", "get_call_info_for_name", "log_type_to_str"]

import re
from dataclasses import dataclass

from ioshelper.base.utils import match_dict


@dataclass
class LogCallInfo:
    size_index: int
    buf_index: int
    format_index: int
    type_index: int
    name_index: int
    is_signpost: bool


@dataclass
class LogCallParams:
    log_type: int
    size: int
    stack_base_offset: int
    format_str_ea: int
    call_ea: int
    name_str_ea: int
    is_signpost: bool


OS_LOG_IMPL_CALL_INFO = LogCallInfo(
    type_index=2, format_index=3, buf_index=4, size_index=5, name_index=None, is_signpost=False
)
OS_SIGNPOST_EMIT_WITH_NAME_CALL_INFO = LogCallInfo(
    type_index=2, name_index=4, format_index=5, buf_index=6, size_index=7, is_signpost=True
)

OS_LOG_NAMES: dict[str | re.Pattern, LogCallInfo] = {
    "__os_log_impl": OS_LOG_IMPL_CALL_INFO,
    "__os_log_error_impl": OS_LOG_IMPL_CALL_INFO,
    "__os_log_debug_impl": OS_LOG_IMPL_CALL_INFO,
    "__os_log_info_impl": OS_LOG_IMPL_CALL_INFO,
    re.compile(r"__os_log_impl_(\d+)"): OS_LOG_IMPL_CALL_INFO,
    re.compile(r"__os_log_error_impl_(\d+)"): OS_LOG_IMPL_CALL_INFO,
    re.compile(r"__os_log_debug_impl_(\d+)"): OS_LOG_IMPL_CALL_INFO,
    re.compile(r"__os_log_info_impl(\d+)"): OS_LOG_IMPL_CALL_INFO,
    "__os_signpost_emit_with_name_impl": OS_SIGNPOST_EMIT_WITH_NAME_CALL_INFO,
    re.compile(r"__os_signpost_emit_with_name_impl_(\d+)"): OS_SIGNPOST_EMIT_WITH_NAME_CALL_INFO,
}

LOG_TYPES: dict[int, str] = {0: "default", 1: "info", 2: "debug", 16: "error", 17: "fault"}
SIGNPOST_TYPES: dict[int, str] = {0: "event", 1: "intervalBegin", 2: "intervalEnd"}


def log_type_to_str(log_type: int, is_signpost: bool) -> str:
    if not is_signpost:
        return LOG_TYPES.get(log_type, f"log{log_type}")
    else:
        return SIGNPOST_TYPES.get(log_type, f"signpost{log_type}")


def get_call_info_for_name(name: str) -> LogCallInfo | None:
    return match_dict(OS_LOG_NAMES, name)

```

`src/ioshelper/plugins/swift/swift_strings/__init__.py`:

```py
__all__ = ["swift_strings_component"]

from ioshelper.base.reloadable_plugin import HexraysHookComponent

from .swift_string_fixup import SwiftStringsHook

swift_strings_component = HexraysHookComponent.factory("SwiftStrings", [SwiftStringsHook])

```

`src/ioshelper/plugins/swift/swift_strings/swift_string.py`:

```py
__all__ = ["decode"]

import ida_bytes

MAX_READ = 1024
OBJECT_OFFSET = 0x20


def _read_cstring_from(addr: int, max_read: int = MAX_READ) -> tuple[str, bytes]:
    """Try to read a C-string from the given address. Returns (string, raw bytes)."""
    if not addr:
        return "", b""
    raw = ida_bytes.get_bytes(addr, max_read) or b""
    if not raw:
        return "", b""
    z = raw.find(b"\x00")
    if z >= 0:
        raw = raw[:z]
    try:
        s = raw.decode("utf-8")
    except UnicodeDecodeError:
        s = raw.decode("latin-1", errors="replace")
    return s, raw


def _decode_string_d(obj_addr: int) -> str:
    """
    Pointer-backed Swift::String ('D' layout):
    actual base is masked with 0x7FFF..., string is at (base + OBJECT_OFFSET)
    """
    base = obj_addr & 0x7FFFFFFFFFFFFFFF
    s, _ = _read_cstring_from(base + OBJECT_OFFSET)
    return s


def _decode_string_e(bits_val: int, obj_addr: int) -> str:
    """
    Immediate small string when top nibble of _object is 0xE.
    Length is (object >> 56) & 0xF.
    Bytes come from bits_val first (LE), then _object if needed.
    """
    top_nib = (obj_addr >> 60) & 0xF
    if top_nib != 0xE:
        return ""
    length = (obj_addr >> 56) & 0xF
    if length == 0:
        return ""
    cf = bits_val.to_bytes(8, byteorder="little", signed=False)
    oa = obj_addr.to_bytes(8, byteorder="little", signed=False)
    data = cf[:length]
    if len(data) < length:
        data += oa[: length - len(data)]
    try:
        return data.decode("utf-8", errors="strict")
    except UnicodeDecodeError:
        return data.decode("latin-1", errors="replace")


def decode(bits_val: int, obj_val: int, escape: bool = True) -> str | None:
    """Decode a Swift::String from the given countAndFlagsBits and _object values"""

    string_type_d = ((bits_val >> 60) & 0xF) == 0xD
    string_type_e = ((obj_val >> 60) & 0xF) == 0xE

    if string_type_d:
        s = _decode_string_d(obj_val)
    elif string_type_e:
        s = _decode_string_e(bits_val, obj_val)
    else:
        print(f"[swift-string] Got bad string: {bits_val:x} {obj_val:x}")
        return None

    if escape and s:
        s = s.encode("unicode_escape").decode("utf-8")

    return s

```

`src/ioshelper/plugins/swift/swift_strings/swift_string_fixup.py`:

```py
__all__ = ["SwiftStringsHook"]

from dataclasses import dataclass
from typing import Literal

import ida_hexrays
from ida_hexrays import (
    cexpr_t,
    cfuncptr_t,
    cinsn_t,
    citem_t,
    ctree_parentee_t,
)
from ida_typeinf import tinfo_t
from idahelper import tif
from idahelper.ast import cexpr

from .swift_string import decode as decode_swift_string


@dataclass
class MemrefConstInfo:
    """Holds the parts of a `<var>.<mem at off> op <const number>` expression where op is either `=` or `==`."""

    var: cexpr_t
    mem_off: int
    value: int
    # noinspection PyTypeHints
    op: "Literal[ida_hexrays.cot_asg] | Literal[ida_hexrays.cot_eq]"


def _unpack_memref_const(e: cexpr_t) -> MemrefConstInfo | None:
    """If `e` is `<var>.<mem at off> op <const number>`, return the parts. Otherwise, return None."""
    # Check assign
    if e.op not in (ida_hexrays.cot_asg, ida_hexrays.cot_eq):
        return None

    lhs, rhs = e.x, e.y
    # Check LHS is a memref
    if lhs.op != ida_hexrays.cot_memref:
        return None

    # Support a cast around the number
    if rhs.op == ida_hexrays.cot_cast and rhs.x.op == ida_hexrays.cot_num:
        rhs = rhs.x
    if rhs.op != ida_hexrays.cot_num:
        return None

    return MemrefConstInfo(var=lhs.x, mem_off=lhs.m, value=rhs.numval(), op=e.op)


def _is_memref_const_specific(e: cexpr_t, var_x: cexpr_t, wanted_off: int, wanted_op: int) -> bool:
    """Check if 'e' is '<var_x>.<mem at wanted_off> op <const number>'."""
    if (info := _unpack_memref_const(e)) is None:
        return False
    return _is_info_specific(info, var_x, wanted_off, wanted_op)


def _is_info_specific(info: MemrefConstInfo, var_x: cexpr_t, wanted_off: int, wanted_op: int) -> bool:
    """Check if 'e' is '<var_x>.<mem at wanted_off> op <const number>'."""
    return info.var == var_x and info.mem_off == wanted_off and info.op == wanted_op


@dataclass
class CommaContext:
    """Context for neutralizing a prior complementary assignment. For `x, y` expression when we are `x`"""

    parent: cexpr_t


@dataclass
class BlockContext:
    """Context for neutralizing a prior complementary assignment. For a block when we are statement at index `idx`"""

    parent: cexpr_t
    idx: int


def _find_prior_complementary_assignment(  # noqa: C901
    parents: list[citem_t], current: cexpr_t, var_x: cexpr_t, wanted_off: int
) -> tuple[cexpr_t, CommaContext | BlockContext] | tuple[None, None]:
    """
    Walk up the parent chain. If inside a comma-expr (we are 'y'), scan the left spine for a match.
    If inside a block, scan earlier statements in the block for a match.
    Also, if we enter a cit_expr that wraps our current cexpr_t, promote `current` to that cinsn_t
    so that the next cit_block step can locate the statement.
    If not found, return (None, None).
    """
    # We'll mutate this as we climb so that when we hit cit_block we point at the cinsn_t
    cur: cexpr_t | cinsn_t = current

    for _parent in reversed(parents):
        if _parent is None:
            continue
        parent: cexpr_t | cinsn_t = _parent.to_specific_type

        # If we're entering a statement wrapper for our expression, promote it to cinsn_t
        if parent.op == ida_hexrays.cit_expr:
            cur = parent
            continue
        # Comma-expression: (... , cur). We're the right side iff cur is exactly parent.y
        elif parent.op == ida_hexrays.cot_comma:
            if cur == parent.y:
                # Iterate the left spine for assignments to var_x at wanted_off
                comma_expr: cexpr_t = parent
                while True:
                    left_expr = comma_expr.x
                    if _is_memref_const_specific(left_expr, var_x, wanted_off, ida_hexrays.cot_asg):
                        return left_expr, CommaContext(parent)
                    elif left_expr.op == ida_hexrays.cot_comma:
                        comma_expr = left_expr
                    else:
                        break

            # If we are here we are either a left side, or the comma expression did not contain an assignment
            # Either way, move up
            cur = parent
            continue
        # Block: scan earlier statements
        elif parent.op == ida_hexrays.cit_block:
            block = parent.cblock
            # Find our index as a statement (cur must be a cinsn_t by now in normal cases)
            for i, insn_i in enumerate(block):
                if insn_i == cur:
                    # Look backwards for a candidate
                    for j in range(i - 1, -1, -1):
                        insn_j = block[j]
                        if insn_j.op == ida_hexrays.cit_expr:
                            insn_j_expr = insn_j.cexpr
                            if _is_memref_const_specific(insn_j_expr, var_x, wanted_off, ida_hexrays.cot_asg):
                                return insn_j_expr, BlockContext(parent, j)
                    break
            cur = parent
            continue

        # Default: keep walking up
        cur = parent
    return None, None


def _remove_prior_with_ctx(ctx: CommaContext | BlockContext, current: cexpr_t):
    """
    Neutralize the earlier complementary assignment.
    - In comma-exprs: replace '(left, current)' with '(1, current)'.
    - In blocks: turn the victim instruction into an empty statement (';').
    """
    if isinstance(ctx, CommaContext):
        # Swaping the parent can lead to deleting nodes we iterate over, so replace LHS with constant 1
        # TODO: Is there a cleaner way to do this?
        ctx.parent.x.swap(cexpr.from_const_value(1))
    elif isinstance(ctx, BlockContext):
        victim = ctx.parent.cblock[ctx.idx]
        victim.cleanup()


class SwiftStringsHook(ida_hexrays.Hexrays_Hooks):
    def maturity(self, func: cfuncptr_t, new_maturity: int) -> int:
        # Run once the function has a reasonably stable AST
        if new_maturity < ida_hexrays.CMAT_CPA:
            return 0

        swift_str_type = tif.from_c_type("Swift::String")
        if swift_str_type is None:
            return 0

        # noinspection PyTypeChecker,PyPropertyAccess
        SwiftStringVisitor(swift_str_type).apply_to(func.body, None)  # pyright: ignore[reportArgumentType]
        return 0


class SwiftStringVisitor(ctree_parentee_t):
    """
    Finds pairs of assignments to Swift::String.{_countAndFlagsBits (off 0), _object (off 8)}
    in either order, possibly separated by other statements, decodes the string,
    and rewrites the second assignment to construct the Swift::String directly.
    """

    def __init__(self, swift_str_type: tinfo_t):
        super().__init__()
        self.swift_str_type = swift_str_type

    def visit_expr(self, expr: cexpr_t) -> int:
        # Only process assignments
        if expr.op == ida_hexrays.cot_asg:
            self.visit_asg_expr(expr)
        elif expr.op == ida_hexrays.cot_land:
            self.visit_land_expr(expr)
        return 0

    def visit_asg_expr(self, expr: cexpr_t):
        if (asg_info := _unpack_memref_const(expr)) is None:
            return
        var_x, cur_off, value = asg_info.var, asg_info.mem_off, asg_info.value

        # Only offsets 0 (countAndFlagsBits) & 8 (_object)
        if cur_off not in (0, 8):
            return

        # Find the complementary assignment earlier in the same block/comma
        need_off = 0 if cur_off == 8 else 8
        prior_expr, ctx = _find_prior_complementary_assignment(self.parents, expr, var_x, need_off)
        if prior_expr is None:
            return

        # Extract values (bits @ off 0, object @ off 8)
        if cur_off == 8:
            bits_val = _unpack_memref_const(prior_expr).value
            obj_val = value
        else:  # cur_off == 0
            bits_val = value
            obj_val = _unpack_memref_const(prior_expr).value

        # Decode the string
        s = decode_swift_string(bits_val, obj_val)
        if s is None:
            return

        # Build a helper-call that returns Swift::String from a C string
        call = cexpr.call_helper_from_sig(
            "__SwiftStr",
            self.swift_str_type,
            [cexpr.from_string(s)],
        )

        # Replace RHS with the call
        expr.y.swap(call)

        # Assign directly to the struct/object (remove '._object'/'._countAndFlagsBits')
        lhs_parent = cexpr_t(expr.x.x)
        expr.x.swap(lhs_parent)

        # # Neutralize the older complementary assignment
        _remove_prior_with_ctx(ctx, expr)

    def visit_land_expr(self, expr: cexpr_t):
        # Support equality comparisons, for cases like `if (str._countAndFlagsBits == 0 && str._object == 0)`
        lhs, rhs = expr.x, expr.y

        # Check both sides are equality comparisons
        if lhs.op != ida_hexrays.cot_eq or rhs.op != ida_hexrays.cot_eq:
            return

        if (lhs_eq_info := _unpack_memref_const(lhs)) is None or (rhs_eq_info := _unpack_memref_const(rhs)) is None:
            return
        var_x_lhs, cur_off_lhs, value_lhs = lhs_eq_info.var, lhs_eq_info.mem_off, lhs_eq_info.value

        # Only offsets 0 (countAndFlagsBits) & 8 (_object)
        if cur_off_lhs not in (0, 8):
            return

        # Check if both sides refer to the same variable
        need_off = 0 if cur_off_lhs == 8 else 8
        if not _is_info_specific(rhs_eq_info, var_x_lhs, need_off, ida_hexrays.cot_eq):
            return

        # Extract values (bits @ off 0, object @ off 8)
        if cur_off_lhs == 8:
            bits_val = rhs_eq_info.value
            obj_val = value_lhs
        else:  # cur_off_lhs == 0
            bits_val = value_lhs
            obj_val = rhs_eq_info.value

        # Decode the string
        s = decode_swift_string(bits_val, obj_val)
        if not s:
            return

        # Build a helper-call that returns Swift::String from a C string
        call = cexpr.call_helper_from_sig(
            "__SwiftStr",
            self.swift_str_type,
            [cexpr.from_string(s)],
        )

        new_comparison = cexpr.from_binary_op(
            cexpr_t(lhs.x.x), call, ida_hexrays.cot_eq, tif.from_c_type("bool"), expr.ea
        )
        expr.swap(new_comparison)
        self.prune_now()

```

`src/ioshelper/plugins/swift/swift_types/__init__.py`:

```py
__all__ = ["swift_types_component"]

from ioshelper.base.reloadable_plugin import StartupScriptComponent

from .swift_types import fix_swift_types

swift_types_component = StartupScriptComponent.factory("SwiftTypes", [fix_swift_types])

```

`src/ioshelper/plugins/swift/swift_types/swift_types.py`:

```py
import ida_idp
import ida_typeinf
import idaapi
import idc
from idahelper import file_format, memory, tif

DECLS = """
typedef long long s64;
typedef unsigned long long u64;

typedef s64 Int;
typedef u64 Bool;

struct Swift::String
{
  u64 _countAndFlagsBits;
  void *_object;
};

union Swift_ElementAny {
    Swift::String stringElement;
};

struct Swift_Any {
    Swift_ElementAny element;
    u64 unknown;
    s64 type;
};

struct Swift_ArrayAny {
    s64 length;
    Swift_Any *items;
};
"""

FUNCTIONS_SIGNATURES = {
    # Base runtime
    "_swift_allocObject": "id *__fastcall swift_allocObject(void *metadata, size_t requiredSize, size_t requiredAlignmentMask)",
    # Dispatch
    "_$sSo17OS_dispatch_queueC8DispatchE5label3qos10attributes20autoreleaseFrequency6targetABSS_AC0D3QoSVAbCE10AttributesVAbCE011AutoreleaseI0OABSgtcfC": "__int64 __fastcall OS_dispatch_queue_init_label_qos_attributes_autoreleaseFrequency_target__(Swift::String label, _QWORD qos, _QWORD attributes, _QWORD frequency, _QWORD target)",
    "_$sSo17OS_dispatch_queueC8DispatchE4sync7executexxyKXE_tKlF": "_QWORD *__swiftClassCall OS_dispatch_queue_sync_A__execute__(_QWORD *__return_ptr, void *dispatchQueue, void *cb, id params, void *returnType)",
    "_$sSo17OS_dispatch_queueC8DispatchE4sync5flags7executexAC0D13WorkItemFlagsV_xyKXEtKlF": "_QWORD *__swiftClassCall OS_dispatch_queue_sync_A_flags_execute__(_QWORD *__return_ptr, void *dispatchQueue, int flags, void *cb, id params, void *returnType)",
    # Foundation.URL
    "_$s10Foundation3URLV6stringACSgSSh_tcfC": "void __swiftcall URL_init_string__(__int64 *__return_ptr, Swift::String url)",
    "_$s10Foundation3URLV4pathSSvg": "Swift::String __swiftClassCall URL_path_getter(void *self)",
    "_$s10Foundation3URLV22appendingPathComponentyACSSF": "__int64 __swiftClassCall URL_appendingPathComponent____(void *self, Swift::String component)",
    # print()
    "_$ss5print_9separator10terminatoryypd_S2StF": "void __fastcall print___separator_terminator__(Swift_ArrayAny *, Swift::String, Swift::String)",
    "_$ss10debugPrint_9separator10terminatoryypd_S2StFfA0_": "Swift::String default_argument_1_of_debugPrint___separator_terminator__(void)",
    # Arrays
    "_$ss27_allocateUninitializedArrayySayxG_BptBwlF": "Swift_ArrayAny *__fastcall _allocateUninitializedArray_A(u64 count, void *arrayType)",
    "_$ss27_finalizeUninitializedArrayySayxGABnlF": "Swift_ArrayAny *__fastcall _finalizeUninitializedArray_A(Swift_ArrayAny *, void *arrayType)",
    # Bridging
    "_$sSS10FoundationE36_unconditionallyBridgeFromObjectiveCySSSo8NSStringCSgFZ": "Swift::String __fastcall static_String__unconditionallyBridgeFromObjectiveC____(id)",
    "_$sSS10FoundationE19_bridgeToObjectiveCSo8NSStringCyF": "NSString __swiftcall String__bridgeToObjectiveC__(Swift::String)",
    "_swift_bridgeObjectRelease": "void swift_bridgeObjectRelease(id)",
    "_swift_bridgeObjectRetain": "id swift_bridgeObjectRetain(id)",
    "_$sSD10FoundationE19_bridgeToObjectiveCSo12NSDictionaryCyF": "NSDictionary __swiftcall Dictionary__bridgeToObjectiveC__(id swiftDict, id typeMetadata, id unknown, id protocolWitness)",
    "_$s10Foundation4DataV19_bridgeToObjectiveCSo6NSDataCyF": "NSData __swiftcall Data__bridgeToObjectiveC__(Swift::String)",
    "_$sSa10FoundationE19_bridgeToObjectiveCSo7NSArrayCyF": "NSArray __swiftcall Array__bridgeToObjectiveC__(Swift_ArrayAny *)",
    # Allocating global objects
    "___swift_allocate_value_buffer": "void *__fastcall __swift_allocate_value_buffer(void *typeInfo, void **pObject)",
    "___swift_project_value_buffer": "__int64 __fastcall __swift_project_value_buffer(void *typeInfo, void *object)",
    # String operations
    "_$sSS6appendyySSF": "Swift::Void __swiftClassCall String_append____(id, Swift::String);",
    "_$ss11_StringGutsV4growyySiF": "Swift::Void __swiftClassCall _StringGuts_grow____(id, Swift::Int);",
    "_$ss23CustomStringConvertibleP11descriptionSSvgTj": "Swift::String __swiftClassCall dispatch_thunk_of_CustomStringConvertible_description_getter(id obj, id typeMetadata, id protocolWitness);",
    "_$ss27_stringCompareWithSmolCheck__9expectingSbs11_StringGutsV_ADs01_G16ComparisonResultOtF": "__int64 __fastcall _stringCompareWithSmolCheck_____expecting__(Swift::String, Swift::String, _QWORD)",
    "_$sSS9hasPrefixySbSSF": "Swift::Bool __swiftcall String_hasPrefix____(Swift::String, Swift::String)",
    "_$sSS12ProxymanCoreE5toSHASSSgyF": "Swift::String_optional __swiftcall String_toSHA__(Swift::String)",
    "_$sSy10FoundationE4data5using20allowLossyConversionAA4DataVSgSSAAE8EncodingV_SbtF": "Swift::String __fastcall StringProtocol_data_using_allowLossyConversion__(_QWORD, _QWORD, _QWORD, _QWORD);",
    "_$sSS5countSivg": "__int64 __swiftClassCall String_count_getter(void *self, Swift::String)",
    "_$sSS10FoundationE10contentsOf8encodingSSAA3URLVh_SSAAE8EncodingVtKcfC": "Swift::String __usercall __spoils<X21> String_init_contentsOf_encoding__@<X0:X1>(Swift::String@<X0:X1>)",
    # Data operations
    "_$s10Foundation4DataV11referencingACSo6NSDataCh_tcfC": "Swift::String __fastcall Data_init_referencing__(_QWORD)",
    # String interpolation
    "_$ss26DefaultStringInterpolationV13appendLiteralyySSF": "Swift::Void __usercall DefaultStringInterpolation_appendLiteral____(void *@<X20>, Swift::String@<X0:X1>)",
    "_$ss26DefaultStringInterpolationV06appendC0yyxlF": "Swift::Void __usercall DefaultStringInterpolation_appendInterpolation_A(void *@<X20>, Swift::String@<X0:X1>)",
    "_$ss26DefaultStringInterpolationV15literalCapacity18interpolationCountABSi_SitcfC": "Swift::String __swiftcall __spoils<X8> DefaultStringInterpolation_init_literalCapacity_interpolationCount__(_QWORD, _QWORD)",
    "_$sSS19stringInterpolationSSs013DefaultStringB0V_tcfC": "Swift::String __fastcall String_init_stringInterpolation__(Swift::String)",
    # Dictionary operations
    "_$sSDyq_Sgxcig": "_QWORD *__swiftClassCall Dictionary_subscript_getter(_QWORD *__return_ptr a1, id object, Swift::String key)",
}


def _reg(name: str) -> int:
    """Resolve register name to internal index, or raise."""
    # try exact, upper, lower
    for n in (name, name.upper(), name.lower()):
        idx = ida_idp.str2reg(n)
        if idx is not None and idx != -1:
            return idx
    raise RuntimeError(f"Cannot resolve register '{name}'")


if file_format.is_arm64() and idaapi.IDA_SDK_VERSION >= 920:
    X0 = _reg("X0")
    X1 = _reg("X1")
    X2 = _reg("X2")
    X3 = _reg("X3")
    X4 = _reg("X4")
    X5 = _reg("X5")
    X6 = _reg("X6")
    X7 = _reg("X7")
    X8 = _reg("X8")
    X20 = _reg("X20")

    # first arg in X20, then normal ABI
    _REG_ORDER = [X20, X0, X1, X2, X3, X4, X5, X6, X7]

    FAH_HIDDEN = 0x0001
    FAH_RETLOC = 0x0002  # “return location” / hidden sret pointer
    FAH_VARARG = 0x0004  # used for varargs (rare)

    class swift_class_cc_t(ida_typeinf.custom_callcnv_t):
        def __init__(self):
            super().__init__()
            self.name = "__swiftClassCall"
            self.flags = 0
            # Not a vararg CC; no special ABI bits required for our purposes.
            self.abibits = 0

        # Sanity check
        def validate_func(self, fti: ida_typeinf.func_type_data_t):
            # Accept both fixed & vararg (Swift thunks are fixed; being permissive is fine)
            return True

        def calc_retloc(self, fti: ida_typeinf.func_type_data_t):
            if not fti.rettype.is_void():
                if fti.rettype.get_size() == 8:
                    # Return in X0 (standard AArch64)
                    fti.retloc.set_reg1(X0)
                elif fti.rettype.get_size() == 16:
                    # Or return structs in both X0:X1 (Such as `Swift::String`)
                    fti.retloc.set_reg2(X0, X1)
            return True

        def _find_return_ptr_idx(self, fti) -> int | None:
            """Find the index of an explicitly-declared __return_ptr argument."""
            for idx, fa in enumerate(fti):
                if fa.flags & FAH_RETLOC:
                    return idx
            return None

        def calc_arglocs(self, fti: ida_typeinf.func_type_data_t):
            # 1) If user declared __return_ptr, pin it to X8 and exclude X8 from others.
            retptr_idx = self._find_return_ptr_idx(fti)
            reserve_x8 = retptr_idx is not None

            # Place the retptr first so we don't accidentally reuse X8.
            if reserve_x8:
                rp = fti[retptr_idx]
                # Place exactly in X8. (We ignore size; it's a pointer.)
                rp.argloc.set_reg1(X8)

            # 2) Place the remaining arguments (excluding X8).
            reg_order = [r for r in _REG_ORDER if r != X8] if reserve_x8 else list(_REG_ORDER)

            stk_off = 0
            reg_i = 0
            for idx, fa in enumerate(fti):
                if reserve_x8 and idx == retptr_idx:
                    continue  # already placed in X8

                if reg_i < len(reg_order):
                    sz = fa.type.get_size()
                    if sz == 16 and reg_i + 1 < len(reg_order):
                        fa.argloc.set_reg2(reg_order[reg_i], reg_order[reg_i + 1])
                        reg_i += 2
                    else:
                        fa.argloc.set_reg1(reg_order[reg_i])
                        reg_i += 1
                else:
                    fa.argloc.set_stkoff(stk_off)
                    stk_off += 8

            self.stkargs = stk_off
            return self.calc_retloc(fti)

        # Variadic: same placement logic (we don't add hidden regs)
        def calc_varglocs(self, fti, regs, stkargs, nfixed):
            return self.calc_arglocs(fti)

        # Help decompiler infer this CC: list the GP regs typically used for args
        def get_cc_regs(self, callregs: "ida_typeinf.ccregs_t"):
            callregs.nregs = len(_REG_ORDER)
            for r in _REG_ORDER:
                callregs.gpregs.push_back(r)
            return True

        # No special stack-area requirements
        def get_stkarg_area_info(self, stkarg_area_info):
            return True

        # No stack purge semantics
        def calc_purged_bytes(self, fti, call_ea):
            return 0

        # Use default AArch64-style decoration (or none). UNKNOWN avoids x86 mangling.
        def decorate_name(self, name, should_decorate, cc, ftype):
            return ida_typeinf.gen_decorate_name(name, should_decorate, ida_typeinf.CM_CC_UNKNOWN, ftype)

    def register_calling_convention():
        ccid = ida_typeinf.register_custom_callcnv(swift_class_cc_t())
        if ccid != ida_typeinf.CM_CC_INVALID:
            print(f"[swift-types] Installed __swiftClassCall (id=0x{ccid:x})")
        else:
            print("[swift-types] Failed registering __swiftClassCall")

else:

    def register_calling_convention():
        pass


def fix_swift_types() -> None:
    tif.create_from_c_decl(DECLS)

    register_calling_convention()

    for name, sig in FUNCTIONS_SIGNATURES.items():
        if (ea := memory.ea_from_name(name)) is not None:
            idc.SetType(ea, sig)

```

`src/scripts/field_search.py`:

```py
__all__ = ["search_field_access"]

from collections.abc import Iterator
from dataclasses import dataclass
from enum import Enum
from typing import Generic, TypeVar

import ida_hexrays
from ida_funcs import func_t
from ida_hexrays import mblock_t, minsn_t, mop_t
from ida_typeinf import tinfo_t
from idahelper import cpp, memory, segments, tif
from idahelper.microcode import mba, mop
from idahelper.microcode.visitors import (
    TreeVisitOrder,
    extended_microcode_visitor_t,
)
from idahelper.segments import Segment

PTR_SIZE = 8


def search_field_access(
    struct_name: str,
    offset: int,
    segments_to_search: list[str],
    show_read: bool,
    show_write: bool,
    filter_types: bool = True,
):
    """
    Search for field access in the given segments.

    `struct_name` - "IOService"
    `offset`: 0x28
    `segments_to_search`: ["com.apple.iokit.IOPortFamily", "com.apple.kernel"]
    `show_read`: Should show read access to the field
    `show_write`: Should show write access to the field
    `filter_types`: Should filter results that we know their type does not match the struct type children.
    """
    typ = tif.from_struct_name(struct_name)
    assert typ is not None
    typ_children: set[str | None] = {f"{t!s} *" for t in tif.get_children_classes(typ) or []}
    typ_children.add(f"{struct_name} *")

    results: list[FieldAccess] = []
    for seg_to_search in segments_to_search:
        seg = _get_text_segment(seg_to_search)
        if seg is None:
            print(f"[Error] segment {seg_to_search} not found")
            continue
        print(f"Searching in {seg.name}")

        for result in _collect_field_accesses(seg):
            # Skip vtable
            if result.prev_access is not None and result.prev_access.offset == 0:
                continue

            if filter_types and result.src_type is not None and str(result.src_type) not in typ_children:
                continue

            if result.offset == offset:
                results.append(result)

        print(f"[Status] Finished scanning in {seg_to_search}!")

    for result in results:
        if (show_read and result.type == AccessType.READ) or (show_write and result.type == AccessType.WRITE):
            # noinspection PyBroadException
            try:
                print(result.compact_str())
            except:  # noqa: E722
                print(f"result: {result.ea}")


def _collect_field_accesses(segment: Segment) -> "Iterator[FieldAccess]":
    for func in segment.functions():
        name = memory.name_from_ea(func.start_ea)

        func_mba = mba.from_func(func.start_ea)
        if func_mba is None:
            print(f"[Error] failed to get mba of func {name}")
            continue

        collector = field_access_collector()
        collector.visit_function(func_mba)
        yield from collector.results


def _get_text_segment(name: str) -> Segment | None:
    """Get the text segment for the given name, or None if not found."""
    seg = segments.get_segment_by_name(f"{name}:__text")
    if seg is None:
        seg = segments.get_segment_by_name(f"{name}:__TEXT_EXEC.__text")
    return seg


class AccessType(Enum):
    READ = 0
    WRITE = 1
    UNKNOWN = 2


@dataclass
class FieldAccess:
    op: mop_t
    offset: int | None
    insn: minsn_t
    top_ins: minsn_t
    ea: int
    blk: mblock_t
    type: AccessType
    prev_access: "FieldAccess | None" = None
    src_type: tinfo_t | None = None

    def __str__(self) -> str:
        try:
            return f"FieldAccess(op={self.op.dstr()}, offset={self.offset}, type: {self.type}, prev_offset: {self.prev_access.offset if self.prev_access is not None else '<none>'}, ea: {self.ea:X}, src_type: {self.src_type}, insn: {self.insn.dstr()}), top_ins: {self.top_ins.dstr()})"
        except:  # noqa: E722
            return self.compact_str()

    def compact_str(self) -> str:
        return f"FieldAccess(offset={self.offset}, type: {self.type}, prev_offset: {self.prev_access.offset if self.prev_access is not None else '<none>'}, ea: {self.ea:X}, src_type: {self.src_type})"


T = TypeVar("T")


class MopDict(Generic[T]):
    def __init__(self):
        self._storage: dict[str, T] = {}

    def __setitem__(self, op: mop_t, obj: T):
        self._storage[op.dstr()] = obj

    def __getitem__(self, op: mop_t):
        return self._storage[op.dstr()]

    def __contains__(self, op: mop_t) -> bool:
        return op.dstr() in self._storage

    def __iter__(self):
        return iter(self._storage.values())

    def __len__(self):
        return len(self._storage)

    def get(self, op: mop_t, default: T) -> T:
        if op in self:
            return self[op]

        return default

    def get_or_none(self, op: mop_t) -> T | None:
        if op in self:
            return self[op]
        return None


# TODO: support globals
# TODO: support write to func result
# icall  cs.2{4}, [cs.2{4}:([cs.2{4}:x2_0.8{5}].8+#0x20.8)].8, <fast:_QWORD x2_0.8{5}>.0
class field_access_collector(extended_microcode_visitor_t):
    def __init__(self):
        super().__init__(TreeVisitOrder.POST_ORDER)
        self.results: list[FieldAccess] = []
        self.mop_to_offset: MopDict[int | None] = MopDict()
        self.mop_to_type: MopDict[tinfo_t | None] = MopDict()
        self.mop_to_prev_access: MopDict[FieldAccess] = MopDict()

    def is_offsetable(self, op: mop_t) -> bool:
        if op in self.mop_to_offset:
            return True

        return mop.get_local_variable(op) is not None

    def get_offset(self, op: mop_t) -> int | None:
        val = self.mop_to_offset.get_or_none(op)
        if val is not None:
            return val

        if mop.get_local_variable(op) is not None:
            return 0

        return None

    def get_prev_field_access(self, op: mop_t) -> FieldAccess | None:
        return self.mop_to_prev_access.get_or_none(op)

    def get_type(self, op: mop_t) -> tinfo_t | None:
        return self.mop_to_type.get_or_none(op)

    def track_offsetable_parent_mop(self, offset: int | None):
        """We were in instruction, which created a possible pointer. We want to mark the embedding mop as possible pointer"""
        if self.parents:
            assert isinstance(self.parents[-1], mop_t)
            self.mop_to_offset[self.parents[-1]] = offset

    def track_parent_type(self, typ: tinfo_t | None):
        """We were in instruction, which created a possible pointer. We want to mark the embedding mop as possible pointer"""
        if self.parents:
            assert isinstance(self.parents[-1], mop_t)
            self.mop_to_type[self.parents[-1]] = typ

    def track_prev_field_access(self, field_access: FieldAccess | None):
        if self.parents and field_access is not None:
            assert isinstance(self.parents[-1], mop_t)
            self.mop_to_prev_access[self.parents[-1]] = field_access

    def _visit_insn(self, ins: minsn_t) -> int:
        # print('  ' * len(self.parents), "MOP:", op.dstr())
        # print("  " * len(self.parents), "INS:", ins.dstr())

        if ins.opcode == ida_hexrays.m_add:
            return self._visit_add(ins)
        elif ins.opcode == ida_hexrays.m_ldx:
            return self._visit_ldx(ins)
        elif ins.opcode == ida_hexrays.m_stx:
            return self._visit_stx(ins)
        return 0

    def _visit_ldx(self, ins: minsn_t) -> int:
        if self.is_offsetable(ins.r):
            offset = self.get_offset(ins.r)

            access = FieldAccess(
                ins.r,
                offset,
                ins,
                self.top_ins,
                ins.ea,
                self.blk,
                AccessType.READ,
                self.get_prev_field_access(ins.r),
                self.get_type(ins.r),
            )
            self.results.append(access)
            self.track_offsetable_parent_mop(0)
            self.track_prev_field_access(access)

        return 0

    def _visit_stx(self, ins: minsn_t) -> int:
        if self.is_offsetable(ins.d):
            offset = self.get_offset(ins.d)

            access = FieldAccess(
                ins.d,
                offset,
                ins,
                self.top_ins,
                ins.ea,
                self.blk,
                AccessType.WRITE,
                self.get_prev_field_access(ins.d),
                self.get_type(ins.d),
            )
            self.results.append(access)
            self.track_offsetable_parent_mop(0)
            self.track_prev_field_access(access)
        return 0

    def _visit_add(self, ins: minsn_t) -> int:  # noqa: C901
        """Search for `add local, offset, .8`"""

        # Check output is of pointer size
        if ins.d.size != PTR_SIZE:
            return 0

        # Check if one of them is a possible pointer
        if self.is_offsetable(ins.l):
            ptr = ins.l
            offset = mop.get_const_int(ins.r)
        elif self.is_offsetable(ins.r):
            ptr = ins.r
            offset = mop.get_const_int(ins.l)
        else:
            return 0

        # Check if the offset is a const
        if offset is None:
            # print("Dynamic access!", hex(ins.ea), ins.dstr())
            return 0

        if not self.parents:
            # The add instruction is direct instruction in the block
            # print(
            #     f"TODO: {hex(ins.ea)} {ins.dstr()} is direct instruction in the block, need to follow destination to understand if it is a load or store"
            # )

            # TODO: hack
            self.mop_to_offset[ins.d] = offset
            return 0

        # Since this is an embedded instruction, there are at least 2 parents.
        # We can skip the first parent as it is an "instruction result" mop.
        parent = self.parents[-1]
        parent_of_parent = self.parents[-2]
        if isinstance(parent_of_parent, mop_t):
            if parent_of_parent.t != ida_hexrays.mop_f:
                print(f"TODO: parent of parent is not instruction {hex(self.top_ins.ea)}: {self.top_ins.dstr()}")
                print("pp:", parent_of_parent.t, parent_of_parent.dstr())
                return 0
            else:
                # Parameter of function, can be ignored
                return 0

        # TODO: get rid of this if else, it is here as sanity
        self.track_offsetable_parent_mop(offset)
        self.track_prev_field_access(self.get_prev_field_access(ptr))

        lvar = mop.get_local_variable(ptr)
        if lvar is not None and lvar.is_arg_var:
            if str(lvar.type()) not in ["_QWORD", "__int64"]:
                self.track_parent_type(lvar.type())  # type: ignore  # noqa: PGH003
            elif lvar == self.mba.arg(0):
                f: func_t = self.mba.get_curfunc()
                f_name = memory.name_from_ea(f.start_ea)
                if f_name is not None:
                    cls_name = cpp.demangle_class_only(f_name)
                    if cls_name is not None:
                        cls_typ = tif.from_struct_name(cls_name)
                        if cls_typ is not None:
                            self.track_parent_type(cls_typ)

        if parent_of_parent.opcode == ida_hexrays.m_stx:
            if parent != parent_of_parent.d:
                # We would not be the selector (because it will be so weird...), so we must be what we load.
                # print(
                #     f"TODO: {self.top_ins.dstr()} stores addition result to variable. Can we rule out this is normal addition and not pointer logic?"
                # )
                pass
        elif parent_of_parent.opcode == ida_hexrays.m_ldx:  # noqa: SIM102
            if parent != parent_of_parent.r:
                # We would not be the selector (because it will be so weird...), and I don't think we can ever be the destination as it have to be a register.
                print(f"TODO: {self.top_ins.dstr()} load to complex expression. How can it be?")

        return 0

```

`src/scripts/fix_dyld_xrefs.py`:

```py
from functools import lru_cache

import ida_xref
from ida_funcs import func_t
from ida_ua import insn_t
from idahelper import instructions, segments, xrefs

stubs = [s for s in segments.get_segments() if "__stubs" in s.name or "__auth_stubs" in s.name]


@lru_cache(1000)
def is_stub_address(ea: int) -> bool:
    """Check if the given address is within any stub segment"""
    return any(stub.start_ea <= ea < stub.end_ea for stub in stubs)


def fix_xrefs():
    global_total_modified = 0
    segments_count = 0
    for seg in segments.get_segments("CODE"):
        segments_count += 1
        print(f"[Info] Processing segment {seg.name}...")
        total_modified = 0
        for func in seg.functions():
            total_modified += handle_func(func)
        global_total_modified += total_modified
        print(f"[Info] Finished segment {seg.name}, total modified xrefs: {total_modified}")
    print(f"[Info] Finished fixing xrefs, added {global_total_modified} xrefs over {segments_count} segments.")


def handle_func(func: func_t) -> int:
    total_modified = 0
    for insn in instructions.from_func(func):
        if insn.get_canon_mnem() in ("B", "BL"):
            total_modified += handle_bl_insn(insn)
    return total_modified


def handle_bl_insn(insn: insn_t) -> bool:
    # Get the target of the BL instruction
    # noinspection PyPropertyAccess
    ea: int = insn.ea
    address: int = insn[0].addr

    # Check if the target function is a stub
    if not is_stub_address(address):
        return False

    # Check if there is xref from to the stub
    if ea in xrefs.code_xrefs_to(address):
        return False

    # Add code xref from the BL instruction to the stub
    insn.add_cref(address, 0, ida_xref.fl_CN | ida_xref.XREF_USER)
    return True


if __name__ == "__main__":
    fix_xrefs()

```

`uv.lock`:

```lock
version = 1
revision = 2
requires-python = ">=3.10"

[[package]]
name = "ida-ios-helper"
source = { editable = "." }
dependencies = [
    { name = "idahelper" },
]

[package.dev-dependencies]
dev = [
    { name = "ruff" },
    { name = "vermin" },
]

[package.metadata]
requires-dist = [{ name = "idahelper", specifier = "==1.0.18" }]

[package.metadata.requires-dev]
dev = [
    { name = "ruff", specifier = ">=0.12.2" },
    { name = "vermin", specifier = ">=1.6.0" },
]

[[package]]
name = "idahelper"
version = "1.0.18"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/fe/0f/384b06e711d2982066f0f6aa511db7f41bca599b0f80da27188858f73335/idahelper-1.0.18.tar.gz", hash = "sha256:f1b8bb57acfbe60022810bedd2db47ac260b92644fad183f74d4771ec859ffe8", size = 25640, upload-time = "2026-02-19T14:50:44.583Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/34/50/6113059e0868b772d79309069012345bd0feeac4c5cf4d882cabce39b00e/idahelper-1.0.18-py3-none-any.whl", hash = "sha256:906832330ce766b816cdc1534f507dc0a914b0946650c62083e424f30ec3d341", size = 31585, upload-time = "2026-02-19T14:50:43.277Z" },
]

[[package]]
name = "ruff"
version = "0.15.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/04/dc/4e6ac71b511b141cf626357a3946679abeba4cf67bc7cc5a17920f31e10d/ruff-0.15.1.tar.gz", hash = "sha256:c590fe13fb57c97141ae975c03a1aedb3d3156030cabd740d6ff0b0d601e203f", size = 4540855, upload-time = "2026-02-12T23:09:09.998Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/23/bf/e6e4324238c17f9d9120a9d60aa99a7daaa21204c07fcd84e2ef03bb5fd1/ruff-0.15.1-py3-none-linux_armv6l.whl", hash = "sha256:b101ed7cf4615bda6ffe65bdb59f964e9f4a0d3f85cbf0e54f0ab76d7b90228a", size = 10367819, upload-time = "2026-02-12T23:09:03.598Z" },
    { url = "https://files.pythonhosted.org/packages/b3/ea/c8f89d32e7912269d38c58f3649e453ac32c528f93bb7f4219258be2e7ed/ruff-0.15.1-py3-none-macosx_10_12_x86_64.whl", hash = "sha256:939c995e9277e63ea632cc8d3fae17aa758526f49a9a850d2e7e758bfef46602", size = 10798618, upload-time = "2026-02-12T23:09:22.928Z" },
    { url = "https://files.pythonhosted.org/packages/5e/0f/1d0d88bc862624247d82c20c10d4c0f6bb2f346559d8af281674cf327f15/ruff-0.15.1-py3-none-macosx_11_0_arm64.whl", hash = "sha256:1d83466455fdefe60b8d9c8df81d3c1bbb2115cede53549d3b522ce2bc703899", size = 10148518, upload-time = "2026-02-12T23:08:58.339Z" },
    { url = "https://files.pythonhosted.org/packages/f5/c8/291c49cefaa4a9248e986256df2ade7add79388fe179e0691be06fae6f37/ruff-0.15.1-py3-none-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a9457e3c3291024866222b96108ab2d8265b477e5b1534c7ddb1810904858d16", size = 10518811, upload-time = "2026-02-12T23:09:31.865Z" },
    { url = "https://files.pythonhosted.org/packages/c3/1a/f5707440e5ae43ffa5365cac8bbb91e9665f4a883f560893829cf16a606b/ruff-0.15.1-py3-none-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:92c92b003e9d4f7fbd33b1867bb15a1b785b1735069108dfc23821ba045b29bc", size = 10196169, upload-time = "2026-02-12T23:09:17.306Z" },
    { url = "https://files.pythonhosted.org/packages/2a/ff/26ddc8c4da04c8fd3ee65a89c9fb99eaa5c30394269d424461467be2271f/ruff-0.15.1-py3-none-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:1fe5c41ab43e3a06778844c586251eb5a510f67125427625f9eb2b9526535779", size = 10990491, upload-time = "2026-02-12T23:09:25.503Z" },
    { url = "https://files.pythonhosted.org/packages/fc/00/50920cb385b89413f7cdb4bb9bc8fc59c1b0f30028d8bccc294189a54955/ruff-0.15.1-py3-none-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:66a6dd6df4d80dc382c6484f8ce1bcceb55c32e9f27a8b94c32f6c7331bf14fb", size = 11843280, upload-time = "2026-02-12T23:09:19.88Z" },
    { url = "https://files.pythonhosted.org/packages/5d/6d/2f5cad8380caf5632a15460c323ae326f1e1a2b5b90a6ee7519017a017ca/ruff-0.15.1-py3-none-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:6a4a42cbb8af0bda9bcd7606b064d7c0bc311a88d141d02f78920be6acb5aa83", size = 11274336, upload-time = "2026-02-12T23:09:14.907Z" },
    { url = "https://files.pythonhosted.org/packages/a3/1d/5f56cae1d6c40b8a318513599b35ea4b075d7dc1cd1d04449578c29d1d75/ruff-0.15.1-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:4ab064052c31dddada35079901592dfba2e05f5b1e43af3954aafcbc1096a5b2", size = 11137288, upload-time = "2026-02-12T23:09:07.475Z" },
    { url = "https://files.pythonhosted.org/packages/cd/20/6f8d7d8f768c93b0382b33b9306b3b999918816da46537d5a61635514635/ruff-0.15.1-py3-none-manylinux_2_31_riscv64.whl", hash = "sha256:5631c940fe9fe91f817a4c2ea4e81f47bee3ca4aa646134a24374f3c19ad9454", size = 11070681, upload-time = "2026-02-12T23:08:55.43Z" },
    { url = "https://files.pythonhosted.org/packages/9a/67/d640ac76069f64cdea59dba02af2e00b1fa30e2103c7f8d049c0cff4cafd/ruff-0.15.1-py3-none-musllinux_1_2_aarch64.whl", hash = "sha256:68138a4ba184b4691ccdc39f7795c66b3c68160c586519e7e8444cf5a53e1b4c", size = 10486401, upload-time = "2026-02-12T23:09:27.927Z" },
    { url = "https://files.pythonhosted.org/packages/65/3d/e1429f64a3ff89297497916b88c32a5cc88eeca7e9c787072d0e7f1d3e1e/ruff-0.15.1-py3-none-musllinux_1_2_armv7l.whl", hash = "sha256:518f9af03bfc33c03bdb4cb63fabc935341bb7f54af500f92ac309ecfbba6330", size = 10197452, upload-time = "2026-02-12T23:09:12.147Z" },
    { url = "https://files.pythonhosted.org/packages/78/83/e2c3bade17dad63bf1e1c2ffaf11490603b760be149e1419b07049b36ef2/ruff-0.15.1-py3-none-musllinux_1_2_i686.whl", hash = "sha256:da79f4d6a826caaea95de0237a67e33b81e6ec2e25fc7e1993a4015dffca7c61", size = 10693900, upload-time = "2026-02-12T23:09:34.418Z" },
    { url = "https://files.pythonhosted.org/packages/a1/27/fdc0e11a813e6338e0706e8b39bb7a1d61ea5b36873b351acee7e524a72a/ruff-0.15.1-py3-none-musllinux_1_2_x86_64.whl", hash = "sha256:3dd86dccb83cd7d4dcfac303ffc277e6048600dfc22e38158afa208e8bf94a1f", size = 11227302, upload-time = "2026-02-12T23:09:36.536Z" },
    { url = "https://files.pythonhosted.org/packages/f6/58/ac864a75067dcbd3b95be5ab4eb2b601d7fbc3d3d736a27e391a4f92a5c1/ruff-0.15.1-py3-none-win32.whl", hash = "sha256:660975d9cb49b5d5278b12b03bb9951d554543a90b74ed5d366b20e2c57c2098", size = 10462555, upload-time = "2026-02-12T23:09:29.899Z" },
    { url = "https://files.pythonhosted.org/packages/e0/5e/d4ccc8a27ecdb78116feac4935dfc39d1304536f4296168f91ed3ec00cd2/ruff-0.15.1-py3-none-win_amd64.whl", hash = "sha256:c820fef9dd5d4172a6570e5721704a96c6679b80cf7be41659ed439653f62336", size = 11599956, upload-time = "2026-02-12T23:09:01.157Z" },
    { url = "https://files.pythonhosted.org/packages/2a/07/5bda6a85b220c64c65686bc85bd0bbb23b29c62b3a9f9433fa55f17cda93/ruff-0.15.1-py3-none-win_arm64.whl", hash = "sha256:5ff7d5f0f88567850f45081fac8f4ec212be8d0b963e385c3f7d0d2eb4899416", size = 10874604, upload-time = "2026-02-12T23:09:05.515Z" },
]

[[package]]
name = "vermin"
version = "1.8.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/24/7b/2c1b403f2a844e1acb36694fc336e323df742f7f752edb4188311ad43f9e/vermin-1.8.0.tar.gz", hash = "sha256:3621955ac2a2950175c5b4a9b2fc3bd24bd416da0388893c9eb6971264e4ca1f", size = 99913, upload-time = "2025-11-20T17:29:31.509Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e6/fd/6d2167767488e162efd01300a679c7f7d913dbb65baa0b15760ebb369854/vermin-1.8.0-py3-none-any.whl", hash = "sha256:6f2b98ad697a16ed3442e81a0f0baabfc38c185b78aaab1b1fecd87bdd6640b8", size = 98030, upload-time = "2025-11-20T17:29:29.931Z" },
]

```

`vermin.ini`:

```ini
[vermin]
targets = 3.10-
eval_annotations = yes
```