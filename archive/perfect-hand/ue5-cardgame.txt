Project Path: arc_perfect-hand_ue5-cardgame_2rbzihx9

Source Tree:

```txt
arc_perfect-hand_ue5-cardgame_2rbzihx9
├── CardGame.uplugin
├── Config
│   └── FilterPlugin.ini
├── LICENSE
├── README.md
├── Resources
│   └── Icon128.png
└── Source
    └── CardGame
        ├── CardGame.Build.cs
        ├── Classes
        │   ├── Assets
        │   │   ├── CardGameAbility.h
        │   │   ├── CardGameAbilityEffect.h
        │   │   ├── CardGameAttribute.h
        │   │   ├── CardGameCard.h
        │   │   ├── CardGameCardPile.h
        │   │   └── CardGameConfiguration.h
        │   ├── CardGameActor.h
        │   ├── CardGameActorManager.h
        │   ├── CardGameBlueprintFunctionLibrary.h
        │   ├── CardGameLogCategory.h
        │   ├── CardGameMode.h
        │   ├── CardGamePlayerController.h
        │   ├── CardGamePlayerState.h
        │   ├── CardGameServiceContext.h
        │   ├── Model
        │   │   ├── CardGameAttributeWithValue.h
        │   │   ├── CardGameCardModel.h
        │   │   ├── CardGameCardPileModel.h
        │   │   ├── CardGameModel.h
        │   │   ├── CardGamePlayerModel.h
        │   │   ├── CardGameScope.h
        │   │   └── CardGameScopedModel.h
        │   ├── Providers
        │   │   └── CardGameRandomNumberProvider.h
        │   └── Services
        │       ├── CardGameAttributeService.h
        │       ├── CardGameCardPileService.h
        │       ├── CardGameGameplayTagService.h
        │       └── CardGamePlayerService.h
        ├── Private
        │   ├── Assets
        │   │   ├── CardGameCard.cpp
        │   │   └── CardGameConfiguration.cpp
        │   ├── CardGame.cpp
        │   ├── CardGame.h
        │   ├── CardGameActor.cpp
        │   ├── CardGameActorManager.cpp
        │   ├── CardGameBlueprintFunctionLibrary.cpp
        │   ├── CardGameLogCategory.cpp
        │   ├── CardGameMode.cpp
        │   ├── CardGamePlayerController.cpp
        │   ├── CardGamePlayerState.cpp
        │   ├── CardGameServiceContext.cpp
        │   ├── Providers
        │   │   └── CardGameRandomNumberProvider.cpp
        │   ├── Services
        │   │   ├── CardGameAttributeService.cpp
        │   │   ├── CardGameCardPileService.cpp
        │   │   ├── CardGameGameplayTagService.cpp
        │   │   └── CardGamePlayerService.cpp
        │   └── Tests
        │       ├── CardGameAttributeServiceTest.cpp
        │       ├── CardGameCardPileServiceTest.cpp
        │       ├── CardGameGameplayTagServiceTest.cpp
        │       └── CardGamePlayerServiceTest.cpp
        └── Public
            └── ICardGame.h

```

`CardGame.uplugin`:

```uplugin
{
	"FileVersion" : 3,
	"Version" : 1,
	"VersionName" : "0.0.1",
	"FriendlyName" : "Card Game",
	"Description" : "Provides a gameplay framework for developing card games.",
	"Category" : "Card Game",
	"CreatedBy" : "Nick Pruehs",
	"CreatedByURL" : "https://github.com/npruehs",
	"DocsURL" : "https://github.com/npruehs/ue5-cardgame",
	"MarketplaceURL" : "",
	"SupportURL" : "https://github.com/npruehs/ue5-cardgame/issues",
	"EnabledByDefault" : true,
	"CanContainContent" : false,
	"IsBetaVersion" : true,
	"Installed" : false,
	"Modules" :
	[
		{
			"Name" : "CardGame",
			"Type" : "Runtime",
			"LoadingPhase" : "Default",
			"WhitelistPlatforms": [ "Win64" ]
		}
	]
}
```

`Config/FilterPlugin.ini`:

```ini
[FilterPlugin]
; This section lists additional files which will be packaged along with your plugin. Paths should be listed relative to the root plugin directory, and
; may include "...", "*", and "?" wildcards to match directories, files, and individual characters respectively.
;
; Examples:
;    /README.txt
;    /Extras/...
;    /Binaries/ThirdParty/*.dll

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Nick Pruehs

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ue5-cardgame

Card game plugin for Unreal Engine 5.

Note: This document is work-in-progress and subject to change.

## Goals

* Common Gameplay Features
* Blueprint API
* Networking
* Automated Tests
* Savegames
* Auto AI
* Diagnostics
* Simplicity
* Documentation

## Plugin Setup

1. Close your Unreal Editor.
1. Download the latest release.
1. Copy the CardGame folder to the Plugins folder next to your .uproject file (create if necessary).
1. Start the Unreal Editor.

## Usage

### Data

1. Add data assets of class CardGameCard.
1. Add data assets of class CardGameCardPile.
1. Add data assets of class CardGameAttribute.
1. Add a data asset of class CardGameConfiguration.
1. Add a (blueprint) class with parent class CardGameActor and implement Init.
1. Add a (blueprint) class with parent class CardGameActorManager and set Card Actor Class.
1. Add a (blueprint) class with parent class CardGamePlayerController and set Actor Manager Class.
1. Add a (blueprint) class with parent class CardGameMode and set Configuration and Player Controller Class.

### Game Setup

1. Using the Card Pile Subsystem, add cards to player piles, shuffle them and/or move cards betweem them.
1. Using the Attribute Subsystem, set global and player attribute values.
1. In your card game mode, call Start Game.

## Structure

* Assets: Unreal assets (`Blueprintable UObject`s, `UDataAsset`s). No logic. Used by plugin users for creating their content.
* Model: Pure model classes. No logic. Need to be copied for Auto AI.
* Providers: Value providers (e.g. ids, random numbers). Have logic and state.
* Services: Core game logic classes. Stateless.
* Subsystems: Unreal blueprint access to services. Trivial delegate pattern.

Layers similar to traditional model/view/controller or endpoint/service/DAO: 

* PlayerController (components) = (replication) endpoints
* services = services
* providers = DAO

## Design Decisions

* Provider subsystems are used for injecting dependencies for service subsystems. These dependencies need to be available before the game mode might have been initialized.
* RPCs for efficiency, events and secrets
* Relations expressed by indices, not pointers, to allow for copying.
* Player actions are just abilities. This allows Auto AI to automatically apply them.

## Commit Checklist

* Add unit tests.
* Add detailed documentation.

```

`Source/CardGame/CardGame.Build.cs`:

```cs
namespace UnrealBuildTool.Rules
{
	public class CardGame : ModuleRules
	{
		public CardGame(ReadOnlyTargetRules Target)
            : base(Target)
		{
            PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
            bEnforceIWYU = true;

            PrivateIncludePaths.AddRange(
                new string[]
                {
                    "CardGame/Private"
                });

            PublicDependencyModuleNames.AddRange(
                new string[]
                {
                    "Core",
                    "CoreUObject",
                    "Engine",
                    "GameplayTags"
                });
		}
	}
}

```

`Source/CardGame/Classes/Assets/CardGameAbility.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "CardGameAbility.generated.h"

UCLASS()
class CARDGAME_API UCardGameAbility : public UObject
{
	GENERATED_BODY()
};

```

`Source/CardGame/Classes/Assets/CardGameAbilityEffect.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "CardGameAbilityEffect.generated.h"

UCLASS()
class CARDGAME_API UCardGameAbilityEffect : public UObject
{
	GENERATED_BODY()
};

```

`Source/CardGame/Classes/Assets/CardGameAttribute.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "CardGameAttribute.generated.h"

UCLASS()
class CARDGAME_API UCardGameAttribute : public UDataAsset
{
	GENERATED_BODY()
};

```

`Source/CardGame/Classes/Assets/CardGameCard.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"

#include "GameplayTagContainer.h"

#include "CardGameAbility.h"

#include "CardGameCard.generated.h"

class UTexture2D;
class UCardGameAttribute;

UCLASS(BlueprintType)
class CARDGAME_API UCardGameCard : public UDataAsset
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintPure)
	FText GetCardName() const;
	
	const TMap<UCardGameAttribute*, int32>& GetInitialAttributes() const;
	void SetInitialAttributes(const TMap<UCardGameAttribute*, int32>& InInitialAttributes);
	
	const FGameplayTagContainer& GetInitialGameplayTags() const;
	void SetInitialGameplayTags(const FGameplayTagContainer& InInitialGameplayTags);
	
private:
	UPROPERTY(EditDefaultsOnly)
	FText CardName;

	UPROPERTY(EditDefaultsOnly)
	UTexture2D* CardImage;

	UPROPERTY(EditDefaultsOnly)
	FText GameText;

	UPROPERTY(EditDefaultsOnly)
	FText LoreText;

	UPROPERTY(EditDefaultsOnly)
	FGameplayTag CardSet;

	UPROPERTY(EditDefaultsOnly)
	int32 CardSetIndex;
	
	UPROPERTY(EditDefaultsOnly)
	TMap<UCardGameAttribute*, int32> InitialAttributes;

	UPROPERTY(EditDefaultsOnly)
	FGameplayTagContainer InitialGameplayTags;
	
	UPROPERTY(EditDefaultsOnly)
	TArray<TSubclassOf<UCardGameAbility>> Abilities;
};

```

`Source/CardGame/Classes/Assets/CardGameCardPile.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "CardGameCardPile.generated.h"

UCLASS(BlueprintType)
class CARDGAME_API UCardGameCardPile : public UDataAsset
{
	GENERATED_BODY()
};

```

`Source/CardGame/Classes/Assets/CardGameConfiguration.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "CardGameConfiguration.generated.h"

class UCardGameCardPile;

UCLASS()
class CARDGAME_API UCardGameConfiguration : public UDataAsset
{
	GENERATED_BODY()

public:
	TArray<UCardGameCardPile*> GetGlobalCardPileClasses() const;
	TArray<UCardGameCardPile*> GetPlayerCardPileClasses() const;
	void SetGlobalCardPileClasses(TArray<UCardGameCardPile*> InGlobalCardPileClasses);
	void SetPlayerCardPileClasses(TArray<UCardGameCardPile*> InPlayerCardPileClasses);
	
private:
	UPROPERTY(EditDefaultsOnly)
	TArray<UCardGameCardPile*> GlobalCardPileClasses;

	UPROPERTY(EditDefaultsOnly)
	TArray<UCardGameCardPile*> PlayerCardPileClasses;
};

```

`Source/CardGame/Classes/CardGameActor.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"

#include "Model/CardGameCardModel.h"

#include "CardGameActor.generated.h"

class UCardGameCardPile;
UCLASS(BlueprintType, Blueprintable)
class CARDGAME_API ACardGameActor : public AActor
{
	GENERATED_BODY()

public:
	void Init(const FCardGameCardModel& Model, UCardGameCardPile* CardPileClass, int32 PositionInCardPile,
		TOptional<uint8> PlayerIndex);

	int64 GetInstanceId() const;
	
	virtual void NotifyOnInit(const FCardGameCardModel& Model, UCardGameCardPile* CardPileClass,
		int32 PositionInCardPile, TOptional<uint8> PlayerIndex);
	
	UFUNCTION(BlueprintImplementableEvent, meta=(DisplayName="Init"))
	void ReceiveOnInit(const FCardGameCardModel& Model, UCardGameCardPile* CardPileClass, int32 PositionInCardPile,
		uint8 PlayerIndex, bool bHasPlayer);

private:
	int64 InstanceId;
};

```

`Source/CardGame/Classes/CardGameActorManager.h`:

```h
#pragma once

#include "CoreMinimal.h"

#include "UObject/Object.h"
#include "Templates/SubclassOf.h"

#include "CardGameActor.h"
#include "Model/CardGameModel.h"

#include "CardGameActorManager.generated.h"

class UCardGameServiceContext;
struct FCardGameCardModel;

UCLASS(BlueprintType, Blueprintable)
class CARDGAME_API UCardGameActorManager : public UObject
{
	GENERATED_BODY()

public:
	void Init(UCardGameServiceContext* InContext);
	void DeInit();
	
private:
	UPROPERTY(EditDefaultsOnly)
	TSubclassOf<ACardGameActor> CardActorClass;

	UPROPERTY()
	TMap<int64, TObjectPtr<ACardGameActor>> CardActors;

	UPROPERTY()
	TObjectPtr<UCardGameServiceContext> Context;
	
	UFUNCTION()
	void OnCardAddedToGlobalCardPile(UCardGameCardPile* CardPileClass, int32 PositionInCardPile, FCardGameCardModel Card);

	UFUNCTION()
	void OnCardAddedToPlayerCardPile(uint8 PlayerIndex, UCardGameCardPile* CardPileClass, int32 PositionInCardPile,
		FCardGameCardModel Card);

	void SpawnCardActor(UCardGameCardPile* CardPileClass, int32 PositionInCardPile, FCardGameCardModel Card,
		TOptional<uint8> PlayerIndex);
};

```

`Source/CardGame/Classes/CardGameBlueprintFunctionLibrary.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "CardGameBlueprintFunctionLibrary.generated.h"

class UCardGameCard;
struct FCardGameCardModel;

UCLASS()
class CARDGAME_API UCardGameBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
};

```

`Source/CardGame/Classes/CardGameLogCategory.h`:

```h
#pragma once

DECLARE_LOG_CATEGORY_EXTERN(LogCardGame, Log, All);

```

`Source/CardGame/Classes/CardGameMode.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Assets/CardGameConfiguration.h"
#include "GameFramework/GameModeBase.h"

#include "Model/CardGameModel.h"

#include "CardGameMode.generated.h"

class AController;

class UCardGameCard;
class UCardGameCardPile;
class ACardGamePlayerState;

UCLASS()
class CARDGAME_API ACardGameMode : public AGameModeBase
{
	GENERATED_BODY()

public:
	ACardGameMode(const FObjectInitializer& ObjectInitializer);

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
	
	UFUNCTION(BlueprintCallable, Category="Card Game")
	void StartGame();

	UFUNCTION(BlueprintPure, Category="Card Game")
	UCardGameServiceContext* GetContext() const;
	
protected:
	virtual FString InitNewPlayer(APlayerController* NewPlayerController, const FUniqueNetIdRepl& UniqueId,
		const FString& Options, const FString& Portal) override;

private:
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UCardGameConfiguration> Configuration;
	
	TSharedPtr<FCardGameModel> Model;

	UPROPERTY()
	TObjectPtr<UCardGameServiceContext> Context;
	
	UPROPERTY()
	TArray<TObjectPtr<ACardGamePlayerState>> Players;
};

```

`Source/CardGame/Classes/CardGamePlayerController.h`:

```h
#pragma once

#include "CoreMinimal.h"

#include "GameFramework/PlayerController.h"

#include "CardGameActorManager.h"
#include "Model/CardGameModel.h"

#include "CardGamePlayerController.generated.h"

class UCardGameConfiguration;
class UCardGameServiceContext;
class UCardGameAttribute;


UCLASS()
class CARDGAME_API ACardGamePlayerController : public APlayerController
{
	GENERATED_BODY()

public:
	ACardGamePlayerController(const FObjectInitializer& ObjectInitializer);

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
	
	UFUNCTION(Reliable, Client)
	void ClientGameStarted(UCardGameConfiguration* InGameConfiguration, const FCardGameModel& InModel);

	virtual void NotifyOnGameStarted();
	
	UFUNCTION(BlueprintImplementableEvent, meta=(DisplayName="On Game Started"))
	void ReceiveOnGameStarted();
	
private:
	UPROPERTY(EditDefaultsOnly)
	TSubclassOf<UCardGameActorManager> ActorManagerClass;

	TObjectPtr<UCardGameConfiguration> GameConfiguration;
	
	TSharedPtr<FCardGameModel> ClientModel;

	UPROPERTY()
	TObjectPtr<UCardGameServiceContext> Context;
	
	UPROPERTY()
	TObjectPtr<UCardGameActorManager> ActorManager;
};

```

`Source/CardGame/Classes/CardGamePlayerState.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerState.h"
#include "CardGamePlayerState.generated.h"


UCLASS()
class CARDGAME_API ACardGamePlayerState : public APlayerState
{
	GENERATED_BODY()

public:
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	virtual void CopyProperties(APlayerState* PlayerState) override;
	
	uint8 GetPlayerIndex() const;
	void SetPlayerIndex(uint8 InPlayerIndex);
	
private:
	UPROPERTY(Replicated)
	uint8 PlayerIndex;
};

```

`Source/CardGame/Classes/CardGameServiceContext.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Model/CardGameCardModel.h"
#include "Model/CardGameModel.h"
#include "UObject/Object.h"
#include "CardGameServiceContext.generated.h"

class ACardGameActor;
class FCardGamePlayerService;
class UCardGameConfiguration;
class UCardGameCard;
class FCardGameAttributeService;
class UCardGameAttribute;
class FCardGameGameplayTagService;
struct FGameplayTag;
struct FCardGameModel;
class FCardGameRandomNumberProvider;
class FCardGameCardInstanceIdProvider;
class FCardGameCardPileService;
class UCardGameCardPile;

DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(FCardGameServiceContextCardAddedToGlobalCardPileSignature, UCardGameCardPile*, CardPileClass, int32, PositionInCardPile, FCardGameCardModel, Card);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FCardGameServiceContextCardAddedToPlayerCardPileSignature, uint8, PlayerIndex, UCardGameCardPile*, CardPileClass, int32, PositionInCardPile, FCardGameCardModel, Card);

/** Provides context for using card game services (e.g. by blueprints or AI), and for registering for events. */
UCLASS(BlueprintType)
class CARDGAME_API UCardGameServiceContext : public UObject
{
	GENERATED_BODY()

public:
	void Init(TWeakPtr<FCardGameModel> InModel);
	void DeInit();

	TWeakPtr<const FCardGameModel> GetModel() const;
	
	UFUNCTION(BlueprintPure, Category="Card Game|Attributes")
	int32 GetGlobalAttributeValue(UCardGameAttribute* Attribute) const;

	UFUNCTION(BlueprintCallable, Category="Card Game|Attributes")
	void SetGlobalAttributeValue(UCardGameAttribute* Attribute, int32 NewValue);

	UFUNCTION(BlueprintPure, Category="Card Game|Attributes")
	int32 GetPlayerAttributeValue(AController* Player, UCardGameAttribute* Attribute) const;

	UFUNCTION(BlueprintCallable, Category="Card Game|Attributes")
	void SetPlayerAttributeValue(AController* Player, UCardGameAttribute* Attribute, int32 NewValue);

	TOptional<FCardGameCardModel> GetCardModel(const ACardGameActor* Card) const;
	void AddGlobalCardPiles(UCardGameConfiguration* Configuration);
	
	UFUNCTION(BlueprintCallable, Category="Card Game|Card Piles")
	void AddCardToGlobalCardPile(UCardGameCardPile* CardPileClass, UCardGameCard* CardClass);

	UFUNCTION(BlueprintCallable, Category="Card Game|Card Piles")
	void AddCardToPlayerCardPile(AController* Player, UCardGameCardPile* CardPileClass, UCardGameCard* CardClass);

	UFUNCTION(BlueprintCallable, Category="Card Game|Card Piles")
	void ShuffleGlobalCardPile(UCardGameCardPile* CardPileClass);

	UFUNCTION(BlueprintCallable, Category="Card Game|Card Piles")
	void ShufflePlayerCardPile(AController* Player, UCardGameCardPile* CardPileClass);

	UFUNCTION(BlueprintCallable, Category="Card Game|Card Piles")
	void MoveCardBetweenGlobalCardPiles(UCardGameCardPile* From, UCardGameCardPile* To, int64 CardInstanceId);
	
	UFUNCTION(BlueprintCallable, Category="Card Game|Card Piles")
	void MoveCardBetweenPlayerCardPiles(AController* Player, UCardGameCardPile* From, UCardGameCardPile* To, int64 CardInstanceId);

	UFUNCTION(BlueprintCallable, Category="Card Game|Card Piles")
	void MoveLastCardBetweenPlayerCardPiles(AController* Player, UCardGameCardPile* From, UCardGameCardPile* To);
	
	FGameplayTagContainer GetCardGameplayTags(const ACardGameActor* Card) const;
	
	UFUNCTION(BlueprintCallable, Category="Card Game|Gameplay Tags")
	void AddGlobalGameplayTag(const FGameplayTag& TagToAdd);

	UFUNCTION(BlueprintCallable, Category="Card Game|Gameplay Tags")
	void RemoveGlobalGameplayTag(const FGameplayTag& TagToRemove);

	int32 AddPlayer(const UCardGameConfiguration* Configuration);
	
	FCardGameServiceContextCardAddedToGlobalCardPileSignature OnCardAddedToGlobalCardPile;
	FCardGameServiceContextCardAddedToPlayerCardPileSignature OnCardAddedToPlayerCardPile;
	
private:
	TWeakPtr<FCardGameModel> Model;
	
	TUniquePtr<FCardGameRandomNumberProvider> RandomNumberProvider;

	TUniquePtr<FCardGameAttributeService> AttributeService;
	TUniquePtr<FCardGameCardPileService> CardPileService;
	TUniquePtr<FCardGameGameplayTagService> GameplayTagService;
	TUniquePtr<FCardGamePlayerService> PlayerService;
	
	FDelegateHandle OnCardAddedToGlobalCardPileHandle;
	FDelegateHandle OnCardAddedToPlayerCardPileHandle;
	
	UFUNCTION()
	void NotifyOnCardAddedToGlobalCardPile(UCardGameCardPile* CardPileClass, int32 PositionInCardPile, FCardGameCardModel Card);

	UFUNCTION()
	void NotifyOnCardAddedToPlayerCardPile(uint8 PlayerIndex, UCardGameCardPile* CardPileClass, int32 PositionInCardPile, FCardGameCardModel Card);
};

```

`Source/CardGame/Classes/Model/CardGameAttributeWithValue.h`:

```h
#pragma once

#include "CoreMinimal.h"

#include "CardGameAttributeWithValue.generated.h"

class UCardGameAttribute;

USTRUCT()
struct CARDGAME_API FCardGameAttributeWithValue
{
	GENERATED_BODY()

public:
	FCardGameAttributeWithValue()
	{
	}
	
	FCardGameAttributeWithValue(UCardGameAttribute* InAttribute, int32 InValue)
	{
		Attribute = InAttribute;
		Value = InValue;
	}
	
	UPROPERTY()
	UCardGameAttribute* Attribute = nullptr;

	UPROPERTY()
	int32 Value = 0;
};

```

`Source/CardGame/Classes/Model/CardGameCardModel.h`:

```h
#pragma once

#include "CoreMinimal.h"

#include "CardGameScopedModel.h"

#include "CardGameCardModel.generated.h"

class UCardGameCard;

USTRUCT(BlueprintType)
struct CARDGAME_API FCardGameCardModel
{
	GENERATED_BODY()

public:
	FCardGameCardModel()
	{
	}
	
	FCardGameCardModel(int64 InInstanceId, UCardGameCard* InCardClass)
	{
		InstanceId = InInstanceId;
		CardClass = InCardClass;
	}
	
	UPROPERTY()
	int64 InstanceId = 0;

	UPROPERTY(BlueprintReadOnly)
	UCardGameCard* CardClass = nullptr;

	UPROPERTY()
	FCardGameScopedModel CardModel;
};

```

`Source/CardGame/Classes/Model/CardGameCardPileModel.h`:

```h
#pragma once

#include "CoreMinimal.h"

#include "CardGameCardModel.h"

#include "CardGameCardPileModel.generated.h"

class UCardGameCard;
class UCardGameCardPile;

USTRUCT()
struct CARDGAME_API FCardGameCardPileModel
{
	GENERATED_BODY()

public:
	UPROPERTY()
	UCardGameCardPile* CardPileClass;

	/** Indices into card game model cards array. */
	UPROPERTY()
	TArray<int64> Cards;
};

```

`Source/CardGame/Classes/Model/CardGameModel.h`:

```h
#pragma once

#include "CoreMinimal.h"

#include "CardGameCardPileModel.h"
#include "CardGamePlayerModel.h"
#include "CardGameScopedModel.h"

#include "CardGameModel.generated.h"

class UCardGameCardPile;

USTRUCT()
struct CARDGAME_API FCardGameModel
{
	GENERATED_BODY()

public:
	UPROPERTY()
	FCardGameScopedModel GlobalModel;

	UPROPERTY()
	TArray<FCardGameCardPileModel> GlobalCardPiles;

	UPROPERTY()
	TArray<FCardGamePlayerModel> Players;

	/** Dense array of all cards, no matter if in any global or player card pile, or not in play anymore. */
	UPROPERTY()
	TArray<FCardGameCardModel> Cards;
};

```

`Source/CardGame/Classes/Model/CardGamePlayerModel.h`:

```h
#pragma once

#include "CoreMinimal.h"

#include "CardGameCardPileModel.h"
#include "CardGameScopedModel.h"

#include "CardGamePlayerModel.generated.h"

class UCardGameCardPile;

USTRUCT()
struct CARDGAME_API FCardGamePlayerModel
{
	GENERATED_BODY()

public:
	UPROPERTY()
	uint8 PlayerIndex;

	UPROPERTY()
	FCardGameScopedModel PlayerModel;

	UPROPERTY()
	TArray<FCardGameCardPileModel> PlayerCardPiles;
};

```

`Source/CardGame/Classes/Model/CardGameScope.h`:

```h
#pragma once

#include "CoreMinimal.h"

UENUM()
enum class ECardGameScope : uint8
{
	Global,
	Player,
	Card
};

```

`Source/CardGame/Classes/Model/CardGameScopedModel.h`:

```h
#pragma once

#include "CoreMinimal.h"

#include "GameplayTagContainer.h"
#include "Templates/SubclassOf.h"

#include "Assets/CardGameAbilityEffect.h"
#include "Model/CardGameAttributeWithValue.h"

#include "CardGameScopedModel.generated.h"

class UCardGameAttribute;

USTRUCT()
struct CARDGAME_API FCardGameScopedModel
{
	GENERATED_BODY()

public:
	UPROPERTY()
	TArray<FCardGameAttributeWithValue> Attributes;

	UPROPERTY()
	FGameplayTagContainer GameplayTags;

	UPROPERTY()
	TArray<TSubclassOf<UCardGameAbilityEffect>> ActiveEffects;
};

```

`Source/CardGame/Classes/Providers/CardGameRandomNumberProvider.h`:

```h
#pragma once

#include "CoreMinimal.h"

class CARDGAME_API FCardGameRandomNumberProvider
{
public:
	FCardGameRandomNumberProvider();

	int32 GetInt(int32 MaxExclusive) const;
	
private:
	FRandomStream RandomStream;
};

```

`Source/CardGame/Classes/Services/CardGameAttributeService.h`:

```h
#pragma once

#include "CoreMinimal.h"

class UCardGameAttribute;
struct FCardGameModel;
struct FCardGameScopedModel;

class CARDGAME_API FCardGameAttributeService
{
public:
	int32 GetGlobalAttributeValue(const FCardGameModel& Model, UCardGameAttribute* Attribute) const;
	void SetGlobalAttributeValue(FCardGameModel& Model, UCardGameAttribute* Attribute, int32 NewValue) const;
	int32 GetPlayerAttributeValue(const FCardGameModel& Model, int32 PlayerIndex, UCardGameAttribute* Attribute) const;
	void SetPlayerAttributeValue(FCardGameModel& Model, int32 PlayerIndex, UCardGameAttribute* Attribute,
		int32 NewValue) const;

private:
	int32 GetAttributeValue(const FCardGameScopedModel& ScopedModel, UCardGameAttribute* Attribute) const;
	void SetAttributeValue(FCardGameScopedModel& ScopedModel, UCardGameAttribute* Attribute, int32 NewValue) const;
};

```

`Source/CardGame/Classes/Services/CardGameCardPileService.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Model/CardGameCardModel.h"

class UCardGameCard;
class FCardGameCardInstanceIdProvider;
class UCardGameCardPile;
struct FCardGameCardPileModel;
class UCardGameConfiguration;
struct FCardGameModel;
struct FCardGamePlayerModel;
class FCardGameRandomNumberProvider;

DECLARE_MULTICAST_DELEGATE_ThreeParams(FCardGameCardPileSystemCardAddedToGlobalCardPileSignature, UCardGameCardPile* /* CardPileClass */, int32 /* PositionInCardPile */, FCardGameCardModel /* Card */);
DECLARE_MULTICAST_DELEGATE_FourParams(FCardGameCardPileSystemCardAddedToPlayerCardPileSignature, uint8 /* PlayerIndex */, UCardGameCardPile* /* CardPileClass */, int32 /* PositionInCardPile */, FCardGameCardModel /* Card */);

class CARDGAME_API FCardGameCardPileService
{
public:
	explicit FCardGameCardPileService(FCardGameRandomNumberProvider& RandomNumberProvider);

	TOptional<FCardGameCardModel> GetCardModelByInstanceId(const FCardGameModel& Model, int64 InstanceId) const;
	void AddGlobalCardPiles(FCardGameModel& Model, UCardGameConfiguration* Configuration) const;
	void AddCardToGlobalCardPile(FCardGameModel& Model, UCardGameCardPile* CardPileClass,
		UCardGameCard* CardClass) const;
	void AddCardToPlayerCardPile(FCardGameModel& Model, uint8 PlayerIndex, UCardGameCardPile* CardPileClass,
		UCardGameCard* CardClass) const;
	void ShuffleGlobalCardPile(FCardGameModel& Model, UCardGameCardPile* CardPileClass) const;
	void ShufflePlayerCardPile(FCardGameModel& Model, int32 PlayerIndex, UCardGameCardPile* CardPileClass) const;
	void MoveCardBetweenGlobalCardPiles(FCardGameModel& Model, UCardGameCardPile* From, UCardGameCardPile* To,
		int64 CardInstanceId) const;
	void MoveCardBetweenPlayerCardPiles(FCardGameModel& Model, int32 PlayerIndex, UCardGameCardPile* From,
		UCardGameCardPile* To, int64 CardInstanceId) const;
	void MoveLastCardBetweenPlayerCardPiles(FCardGameModel& Model, int32 PlayerIndex, UCardGameCardPile* From,
		UCardGameCardPile* To) const;
	
	FCardGameCardPileSystemCardAddedToGlobalCardPileSignature OnCardAddedToGlobalCardPile;
	FCardGameCardPileSystemCardAddedToPlayerCardPileSignature OnCardAddedToPlayerCardPile;
	
private:
	FCardGameRandomNumberProvider& RandomNumberProvider;
	
	FCardGameCardPileModel* GetGlobalCardPile(FCardGameModel& Model, UCardGameCardPile* CardPileClass) const;
	FCardGameCardPileModel* GetPlayerCardPile(FCardGamePlayerModel& Player, UCardGameCardPile* CardPileClass) const;
	FCardGameCardModel AddCard(FCardGameModel& Model, UCardGameCard* CardClass) const;
	void Shuffle(FCardGameCardPileModel& CardPile) const;
	void MoveCardBetweenPiles(FCardGameCardPileModel& From, FCardGameCardPileModel& To,
		int64 CardInstanceId) const;
};

```

`Source/CardGame/Classes/Services/CardGameGameplayTagService.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"

struct FCardGameCardModel;
struct FGameplayTag;
struct FCardGameModel;

class CARDGAME_API FCardGameGameplayTagService
{
public:
	FGameplayTagContainer GetCardGameplayTags(const FCardGameModel& GameModel,
		const FCardGameCardModel& CardModel) const;
	void AddGlobalGameplayTag(FCardGameModel& Model, const FGameplayTag& TagToAdd) const;
	void RemoveGlobalGameplayTag(FCardGameModel& Model, const FGameplayTag& TagToRemove) const;
};

```

`Source/CardGame/Classes/Services/CardGamePlayerService.h`:

```h
#pragma once

#include "CoreMinimal.h"

class UCardGameConfiguration;
struct FCardGameModel;

class CARDGAME_API FCardGamePlayerService
{
public:
	int32 AddPlayer(FCardGameModel& Model, const UCardGameConfiguration* Configuration) const;

private:
	int32 GetAvailablePlayerIndex(const FCardGameModel& Model) const;
	bool IsPlayerIndexInUse(const FCardGameModel& Model, int32 PlayerIndex) const;
};

```

`Source/CardGame/Private/Assets/CardGameCard.cpp`:

```cpp
#include "Assets/CardGameCard.h"

FText UCardGameCard::GetCardName() const
{
	return CardName;
}

const TMap<UCardGameAttribute*, int32>& UCardGameCard::GetInitialAttributes() const
{
	return InitialAttributes;
}

void UCardGameCard::SetInitialAttributes(const TMap<UCardGameAttribute*, int32>& InInitialAttributes)
{
	InitialAttributes = InInitialAttributes;
}

const FGameplayTagContainer& UCardGameCard::GetInitialGameplayTags() const
{
	return InitialGameplayTags;
}

void UCardGameCard::SetInitialGameplayTags(const FGameplayTagContainer& InInitialGameplayTags)
{
	InitialGameplayTags = InInitialGameplayTags;
}

```

`Source/CardGame/Private/Assets/CardGameConfiguration.cpp`:

```cpp
#include "Assets/CardGameConfiguration.h"

TArray<UCardGameCardPile*> UCardGameConfiguration::GetGlobalCardPileClasses() const
{
	return GlobalCardPileClasses;
}

void UCardGameConfiguration::SetGlobalCardPileClasses(TArray<UCardGameCardPile*> InGlobalCardPileClasses)
{
	GlobalCardPileClasses = InGlobalCardPileClasses;
}

TArray<UCardGameCardPile*> UCardGameConfiguration::GetPlayerCardPileClasses() const
{
	return PlayerCardPileClasses;
}

void UCardGameConfiguration::SetPlayerCardPileClasses(TArray<UCardGameCardPile*> InPlayerCardPileClasses)
{
	PlayerCardPileClasses = InPlayerCardPileClasses;
}

```

`Source/CardGame/Private/CardGame.cpp`:

```cpp
#include "CardGame.h"

#include "Modules/ModuleManager.h"

void FCardGame::StartupModule()
{
}

void FCardGame::ShutdownModule()
{
}

IMPLEMENT_MODULE(FCardGame, CardGame)

```

`Source/CardGame/Private/CardGame.h`:

```h
#pragma once

#include "ICardGame.h"

class FCardGame : public ICardGame
{
    /** IModuleInterface implementation */
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
};

```

`Source/CardGame/Private/CardGameActor.cpp`:

```cpp
#include "CardGameActor.h"

void ACardGameActor::Init(const FCardGameCardModel& Model, UCardGameCardPile* CardPileClass, int32 PositionInCardPile,
	TOptional<uint8> PlayerIndex)
{
	InstanceId = Model.InstanceId;
	
	NotifyOnInit(Model, CardPileClass, PositionInCardPile, PlayerIndex);
}

int64 ACardGameActor::GetInstanceId() const
{
	return InstanceId;
}

void ACardGameActor::NotifyOnInit(const FCardGameCardModel& Model, UCardGameCardPile* CardPileClass,
                                  int32 PositionInCardPile, TOptional<uint8> PlayerIndex)
{
	ReceiveOnInit(Model, CardPileClass, PositionInCardPile, PlayerIndex.Get(0), PlayerIndex.IsSet());
}

```

`Source/CardGame/Private/CardGameActorManager.cpp`:

```cpp
#include "CardGameActorManager.h"

#include "Assets/CardGameCard.h"
#include "Assets/CardGameCardPile.h"
#include "CardGameLogCategory.h"

void UCardGameActorManager::Init(UCardGameServiceContext* InContext)
{
	Context = InContext;
	
	Context->OnCardAddedToGlobalCardPile.AddDynamic(this, &UCardGameActorManager::OnCardAddedToGlobalCardPile);
	Context->OnCardAddedToPlayerCardPile.AddDynamic(this, &UCardGameActorManager::OnCardAddedToPlayerCardPile);
	
	// Raise initial events.
	const TSharedPtr<const FCardGameModel> Model = Context->GetModel().Pin();
	
	for (const FCardGameCardPileModel& CardPile : Model->GlobalCardPiles)
	{
		for (int32 Index = 0; Index < CardPile.Cards.Num(); ++Index)
		{
			const int64 InstanceId = CardPile.Cards[Index];
			OnCardAddedToGlobalCardPile(CardPile.CardPileClass, Index, Model->Cards[InstanceId]);
		}
	}

	for (const FCardGamePlayerModel& Player : Model->Players)
	{
		for (const FCardGameCardPileModel& CardPile : Player.PlayerCardPiles)
		{
			for (int32 Index = 0; Index < CardPile.Cards.Num(); ++Index)
			{
				const int64 InstanceId = CardPile.Cards[Index];
				OnCardAddedToPlayerCardPile(Player.PlayerIndex, CardPile.CardPileClass, Index, Model->Cards[InstanceId]);
			}
		}
	}
}

void UCardGameActorManager::DeInit()
{
	Context->OnCardAddedToGlobalCardPile.RemoveDynamic(this, &UCardGameActorManager::OnCardAddedToGlobalCardPile);
	Context->OnCardAddedToPlayerCardPile.RemoveDynamic(this, &UCardGameActorManager::OnCardAddedToPlayerCardPile);
}

void UCardGameActorManager::OnCardAddedToGlobalCardPile(UCardGameCardPile* CardPileClass, int32 PositionInCardPile,
                                                        FCardGameCardModel Card)
{
	SpawnCardActor(CardPileClass, PositionInCardPile, Card, TOptional<uint8>());
}

void UCardGameActorManager::OnCardAddedToPlayerCardPile(uint8 PlayerIndex, UCardGameCardPile* CardPileClass,
	int32 PositionInCardPile, FCardGameCardModel Card)
{
	SpawnCardActor(CardPileClass, PositionInCardPile, Card, PlayerIndex);
}

void UCardGameActorManager::SpawnCardActor(UCardGameCardPile* CardPileClass, int32 PositionInCardPile,
	FCardGameCardModel Card, TOptional<uint8> PlayerIndex)
{
	ACardGameActor* CardActor = GetWorld()->SpawnActor<ACardGameActor>(CardActorClass);

	if (!IsValid(CardActor))
	{
		UE_LOG(LogCardGame, Warning, TEXT("Failed to spawn actor for card %s (%d)."),
			*Card.CardClass->GetName(), Card.InstanceId);
		return;
	}

	CardActors.Add(Card.InstanceId, CardActor);

	UE_LOG(LogCardGame, Log, TEXT("Spawned actor %s for card %s (%d)."), *CardActor->GetName(),
		*Card.CardClass->GetName(), Card.InstanceId);

	CardActor->Init(Card, CardPileClass, PositionInCardPile, PlayerIndex);
}

```

`Source/CardGame/Private/CardGameBlueprintFunctionLibrary.cpp`:

```cpp
#include "CardGameBlueprintFunctionLibrary.h"

```

`Source/CardGame/Private/CardGameLogCategory.cpp`:

```cpp
#include "CardGameLogCategory.h"

#include "Logging/LogMacros.h"

DEFINE_LOG_CATEGORY(LogCardGame);

```

`Source/CardGame/Private/CardGameMode.cpp`:

```cpp
#include "CardGameMode.h"

#include "CardGameLogCategory.h"
#include "CardGamePlayerController.h"
#include "CardGamePlayerState.h"

ACardGameMode::ACardGameMode(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	PlayerStateClass = ACardGamePlayerState::StaticClass();

	Model = MakeShared<FCardGameModel>();
	
	Context = ObjectInitializer.CreateDefaultSubobject<UCardGameServiceContext>(this, TEXT("Context"));
	Context->Init(Model);
}

void ACardGameMode::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	if (Context)
	{
		Context->DeInit();
	}
}

void ACardGameMode::StartGame()
{
	// Add global card piles.
	Context->AddGlobalCardPiles(Configuration);

	// Start game.
	for (const ACardGamePlayerState* P : Players)
	{
		ACardGamePlayerController* PC = Cast<ACardGamePlayerController>(P->GetOwner());

		if (!IsValid(PC))
		{
			continue;
		}

		PC->ClientGameStarted(Configuration, *Model);
	}
}

UCardGameServiceContext* ACardGameMode::GetContext() const
{
	return Context;
}

FString ACardGameMode::InitNewPlayer(APlayerController* NewPlayerController, const FUniqueNetIdRepl& UniqueId,
                                     const FString& Options, const FString& Portal)
{
	FString ErrorMessage = Super::InitNewPlayer(NewPlayerController, UniqueId, Options, Portal);
	
	if (!ErrorMessage.IsEmpty())
	{
		return ErrorMessage;
	}

	ACardGamePlayerState* NewPlayer = NewPlayerController->GetPlayerState<ACardGamePlayerState>();

	if (!IsValid(NewPlayer))
	{
		return TEXT("Player " + NewPlayerController->GetName() + " is not using a CardGamePlayerState.");
	}

	// Store player reference.
	Players.Add(NewPlayer);
	
	// Add player to model.
	const int32 NewPlayerIndex = Context->AddPlayer(Configuration);
	
	// Set player index for future model reference.
	NewPlayer->SetPlayerIndex(NewPlayerIndex);

	UE_LOG(LogCardGame, Log, TEXT("Set player index of player %s to %d."), *NewPlayer->GetName(), NewPlayerIndex);

	return ErrorMessage;
}

```

`Source/CardGame/Private/CardGamePlayerController.cpp`:

```cpp
#include "CardGamePlayerController.h"

#include "CardGameLogCategory.h"
#include "CardGameServiceContext.h"
#include "Assets/CardGameConfiguration.h"

ACardGamePlayerController::ACardGamePlayerController(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	ActorManagerClass = UCardGameActorManager::StaticClass();
}

void ACardGamePlayerController::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	if (ActorManager)
	{
		ActorManager->DeInit();
	}

	if (Context)
	{
		Context->DeInit();
	}
}

void ACardGamePlayerController::ClientGameStarted_Implementation(UCardGameConfiguration* InGameConfiguration,
	const FCardGameModel& InModel)
{
	GameConfiguration = InGameConfiguration;
	
	ClientModel = MakeShared<FCardGameModel>();
	*ClientModel = InModel;

	Context = NewObject<UCardGameServiceContext>(this);
	Context->Init(ClientModel);
	
	// Setup actor manager.
	ActorManager = NewObject<UCardGameActorManager>(this, ActorManagerClass);
	ActorManager->Init(Context);

	UE_LOG(LogCardGame, Log, TEXT("Game started!"));
	
	NotifyOnGameStarted();
}

void ACardGamePlayerController::NotifyOnGameStarted()
{
	ReceiveOnGameStarted();
}

```

`Source/CardGame/Private/CardGamePlayerState.cpp`:

```cpp
#include "CardGamePlayerState.h"

#include "Net/UnrealNetwork.h"

void ACardGamePlayerState::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ACardGamePlayerState, PlayerIndex);
}

void ACardGamePlayerState::CopyProperties(APlayerState* PlayerState)
{
	Super::CopyProperties(PlayerState);

	ACardGamePlayerState* CardGamePlayerState = Cast<ACardGamePlayerState>(PlayerState);

	if (!IsValid(CardGamePlayerState))
	{
		return;
	}

	CardGamePlayerState->SetPlayerIndex(PlayerIndex);
}

uint8 ACardGamePlayerState::GetPlayerIndex() const
{
	return PlayerIndex;
}

void ACardGamePlayerState::SetPlayerIndex(uint8 InPlayerIndex)
{
	PlayerIndex = InPlayerIndex;
}

```

`Source/CardGame/Private/CardGameServiceContext.cpp`:

```cpp
#include "CardGameServiceContext.h"

#include "CardGameActor.h"
#include "CardGamePlayerState.h"
#include "Providers/CardGameRandomNumberProvider.h"
#include "Services/CardGameAttributeService.h"
#include "Services/CardGameCardPileService.h"
#include "Services/CardGameGameplayTagService.h"
#include "Services/CardGamePlayerService.h"

void UCardGameServiceContext::Init(TWeakPtr<FCardGameModel> InModel)
{
	Model = InModel;
	
	RandomNumberProvider = MakeUnique<FCardGameRandomNumberProvider>();

	AttributeService = MakeUnique<FCardGameAttributeService>();
	CardPileService = MakeUnique<FCardGameCardPileService>(*RandomNumberProvider);
	GameplayTagService = MakeUnique<FCardGameGameplayTagService>();
	PlayerService = MakeUnique<FCardGamePlayerService>();
	
	OnCardAddedToGlobalCardPileHandle = CardPileService->OnCardAddedToGlobalCardPile.AddUObject
		(this, &UCardGameServiceContext::NotifyOnCardAddedToGlobalCardPile);
	OnCardAddedToPlayerCardPileHandle = CardPileService->OnCardAddedToPlayerCardPile.AddUObject
		(this, &UCardGameServiceContext::NotifyOnCardAddedToPlayerCardPile);
}

void UCardGameServiceContext::DeInit()
{
	if (CardPileService.IsValid())
	{
		CardPileService->OnCardAddedToGlobalCardPile.Remove(OnCardAddedToGlobalCardPileHandle);
		CardPileService->OnCardAddedToPlayerCardPile.Remove(OnCardAddedToPlayerCardPileHandle);
	}
}

TWeakPtr<const FCardGameModel> UCardGameServiceContext::GetModel() const
{
	return Model;
}

int32 UCardGameServiceContext::GetGlobalAttributeValue(UCardGameAttribute* Attribute) const
{
	return AttributeService->GetGlobalAttributeValue(*Model.Pin(), Attribute);
}

void UCardGameServiceContext::SetGlobalAttributeValue(UCardGameAttribute* Attribute, int32 NewValue)
{
	AttributeService->SetGlobalAttributeValue(*Model.Pin(), Attribute, NewValue);
}

int32 UCardGameServiceContext::GetPlayerAttributeValue(AController* Player, UCardGameAttribute* Attribute) const
{
	if (!IsValid(Player))
	{
		return 0;
	}

	const ACardGamePlayerState* PlayerState = Player->GetPlayerState<ACardGamePlayerState>();

	if (!IsValid(PlayerState))
	{
		return 0;
	}
	
	return AttributeService->GetPlayerAttributeValue(*Model.Pin(), PlayerState->GetPlayerIndex(), Attribute);
}

void UCardGameServiceContext::SetPlayerAttributeValue(AController* Player, UCardGameAttribute* Attribute,
	int32 NewValue)
{
	if (!IsValid(Player))
	{
		return;
	}

	const ACardGamePlayerState* PlayerState = Player->GetPlayerState<ACardGamePlayerState>();

	if (!IsValid(PlayerState))
	{
		return;
	}
	
	return AttributeService->SetPlayerAttributeValue(*Model.Pin(), PlayerState->GetPlayerIndex(), Attribute, NewValue);
}

TOptional<FCardGameCardModel> UCardGameServiceContext::GetCardModel(const ACardGameActor* Card) const
{
	if (!IsValid(Card))
	{
		return TOptional<FCardGameCardModel>();
	}

	return CardPileService->GetCardModelByInstanceId(*Model.Pin(), Card->GetInstanceId());
}

void UCardGameServiceContext::AddGlobalCardPiles(UCardGameConfiguration* Configuration)
{
	CardPileService->AddGlobalCardPiles(*Model.Pin(), Configuration);
}

void UCardGameServiceContext::AddCardToGlobalCardPile(UCardGameCardPile* CardPileClass, UCardGameCard* CardClass)
{
	CardPileService->AddCardToGlobalCardPile(*Model.Pin(), CardPileClass, CardClass);
}

void UCardGameServiceContext::AddCardToPlayerCardPile(AController* Player, UCardGameCardPile* CardPileClass,
	UCardGameCard* CardClass)
{
	if (!IsValid(Player))
	{
		return;
	}

	const ACardGamePlayerState* PlayerState = Player->GetPlayerState<ACardGamePlayerState>();

	if (!IsValid(PlayerState))
	{
		return;
	}

	CardPileService->AddCardToPlayerCardPile(*Model.Pin(), PlayerState->GetPlayerIndex(), CardPileClass, CardClass);
}

void UCardGameServiceContext::ShuffleGlobalCardPile(UCardGameCardPile* CardPileClass)
{
	CardPileService->ShuffleGlobalCardPile(*Model.Pin(), CardPileClass);
}

void UCardGameServiceContext::ShufflePlayerCardPile(AController* Player, UCardGameCardPile* CardPileClass)
{
	if (!IsValid(Player))
	{
		return;
	}

	const ACardGamePlayerState* PlayerState = Player->GetPlayerState<ACardGamePlayerState>();

	if (!IsValid(PlayerState))
	{
		return;
	}

	CardPileService->ShufflePlayerCardPile(*Model.Pin(), PlayerState->GetPlayerIndex(), CardPileClass);
}

void UCardGameServiceContext::MoveCardBetweenGlobalCardPiles(UCardGameCardPile* From, UCardGameCardPile* To,
	int64 CardInstanceId)
{
	CardPileService->MoveCardBetweenGlobalCardPiles(*Model.Pin(), From, To, CardInstanceId);
}

void UCardGameServiceContext::MoveCardBetweenPlayerCardPiles(AController* Player, UCardGameCardPile* From,
                                                             UCardGameCardPile* To, int64 CardInstanceId)
{
	if (!IsValid(Player))
	{
		return;
	}

	const ACardGamePlayerState* PlayerState = Player->GetPlayerState<ACardGamePlayerState>();

	if (!IsValid(PlayerState))
	{
		return;
	}

	CardPileService->MoveCardBetweenPlayerCardPiles(*Model.Pin(), PlayerState->GetPlayerIndex(), From, To, CardInstanceId);
}

void UCardGameServiceContext::MoveLastCardBetweenPlayerCardPiles(AController* Player, UCardGameCardPile* From,
	UCardGameCardPile* To)
{
	if (!IsValid(Player))
	{
		return;
	}

	const ACardGamePlayerState* PlayerState = Player->GetPlayerState<ACardGamePlayerState>();

	if (!IsValid(PlayerState))
	{
		return;
	}

	CardPileService->MoveLastCardBetweenPlayerCardPiles(*Model.Pin(), PlayerState->GetPlayerIndex(), From, To);
}

FGameplayTagContainer UCardGameServiceContext::GetCardGameplayTags(const ACardGameActor* Card) const
{
	if (!IsValid(Card))
	{
		return FGameplayTagContainer();
	}

	TOptional<FCardGameCardModel> CardModel = GetCardModel(Card);

	if (!CardModel.IsSet())
	{
		return FGameplayTagContainer();
	}
	
	return GameplayTagService->GetCardGameplayTags(*Model.Pin(), CardModel.GetValue());
}

void UCardGameServiceContext::AddGlobalGameplayTag(const FGameplayTag& TagToAdd)
{
	GameplayTagService->AddGlobalGameplayTag(*Model.Pin(), TagToAdd);
}

void UCardGameServiceContext::RemoveGlobalGameplayTag(const FGameplayTag& TagToRemove)
{
	GameplayTagService->RemoveGlobalGameplayTag(*Model.Pin(), TagToRemove);
}

int32 UCardGameServiceContext::AddPlayer(const UCardGameConfiguration* Configuration)
{
	return PlayerService->AddPlayer(*Model.Pin(), Configuration);
}

void UCardGameServiceContext::NotifyOnCardAddedToGlobalCardPile(UCardGameCardPile* CardPileClass,
                                                                int32 PositionInCardPile, FCardGameCardModel Card)
{
	OnCardAddedToGlobalCardPile.Broadcast(CardPileClass, PositionInCardPile, Card);
}

void UCardGameServiceContext::NotifyOnCardAddedToPlayerCardPile(uint8 PlayerIndex, UCardGameCardPile* CardPileClass,
	int32 PositionInCardPile, FCardGameCardModel Card)
{
	OnCardAddedToPlayerCardPile.Broadcast(PlayerIndex, CardPileClass, PositionInCardPile, Card);
}

```

`Source/CardGame/Private/Providers/CardGameRandomNumberProvider.cpp`:

```cpp
#include "Providers/CardGameRandomNumberProvider.h"

FCardGameRandomNumberProvider::FCardGameRandomNumberProvider()
	: RandomStream(FRandomStream(FName()))
{
}

int32 FCardGameRandomNumberProvider::GetInt(int32 MaxExclusive) const
{
	return RandomStream.RandHelper(MaxExclusive);
}

```

`Source/CardGame/Private/Services/CardGameAttributeService.cpp`:

```cpp
#include "Services/CardGameAttributeService.h"

#include "CardGameLogCategory.h"
#include "Assets/CardGameAttribute.h"
#include "Model/CardGameAttributeWithValue.h"
#include "Model/CardGameModel.h"
#include "Model/CardGameScopedModel.h"

int32 FCardGameAttributeService::GetGlobalAttributeValue(const FCardGameModel& Model,
	UCardGameAttribute* Attribute) const
{
	return GetAttributeValue(Model.GlobalModel, Attribute);
}

void FCardGameAttributeService::SetGlobalAttributeValue(FCardGameModel& Model, UCardGameAttribute* Attribute,
	int32 NewValue) const
{
	SetAttributeValue(Model.GlobalModel, Attribute, NewValue);

	UE_LOG(LogCardGame, Log, TEXT("Set global attribute %s value to %d."), *Attribute->GetName(), NewValue);
}

int32 FCardGameAttributeService::GetPlayerAttributeValue(const FCardGameModel& Model, int32 PlayerIndex,
	UCardGameAttribute* Attribute) const
{
	for (const FCardGamePlayerModel& Player : Model.Players)
	{
		if (Player.PlayerIndex != PlayerIndex)
		{
			continue;
		}

		return GetAttributeValue(Player.PlayerModel, Attribute);
	}

	return 0;
}

void FCardGameAttributeService::SetPlayerAttributeValue(FCardGameModel& Model, int32 PlayerIndex,
	UCardGameAttribute* Attribute, int32 NewValue) const
{
	for (FCardGamePlayerModel& Player : Model.Players)
	{
		if (Player.PlayerIndex != PlayerIndex)
		{
			continue;
		}

		SetAttributeValue(Player.PlayerModel, Attribute, NewValue);

		UE_LOG(LogCardGame, Log, TEXT("Set player %d attribute %s value to %d."), PlayerIndex, *Attribute->GetName(),
			NewValue);
		return;
	}
}

int32 FCardGameAttributeService::GetAttributeValue(const FCardGameScopedModel& ScopedModel,
                                                   UCardGameAttribute* Attribute) const
{
	for (const FCardGameAttributeWithValue& AttributeWithValue : ScopedModel.Attributes)
	{
		if (AttributeWithValue.Attribute == Attribute)
		{
			return AttributeWithValue.Value;
		}
	}

	return 0.0f;
}

void FCardGameAttributeService::SetAttributeValue(FCardGameScopedModel& ScopedModel, UCardGameAttribute* Attribute,
	int32 NewValue) const
{
	for (FCardGameAttributeWithValue& AttributeWithValue : ScopedModel.Attributes)
	{
		if (AttributeWithValue.Attribute == Attribute)
		{
			AttributeWithValue.Value = NewValue;
			return;
		}
	}

	FCardGameAttributeWithValue NewAttributeWithValue;
	NewAttributeWithValue.Attribute = Attribute;
	NewAttributeWithValue.Value = NewValue;
	ScopedModel.Attributes.Add(NewAttributeWithValue);
}
```

`Source/CardGame/Private/Services/CardGameCardPileService.cpp`:

```cpp
#include "Services/CardGameCardPileService.h"

#include "CardGameLogCategory.h"
#include "Assets/CardGameCard.h"
#include "Assets/CardGameCardPile.h"
#include "Assets/CardGameConfiguration.h"
#include "Model/CardGameCardPileModel.h"
#include "Model/CardGameModel.h"
#include "Providers/CardGameRandomNumberProvider.h"

FCardGameCardPileService::FCardGameCardPileService(FCardGameRandomNumberProvider& RandomNumberProvider)
	: RandomNumberProvider(RandomNumberProvider)
{
}

TOptional<FCardGameCardModel> FCardGameCardPileService::GetCardModelByInstanceId(const FCardGameModel& Model,
	int64 InstanceId) const
{
	return Model.Cards.IsValidIndex(InstanceId) ? Model.Cards[InstanceId] : TOptional<FCardGameCardModel>();
}

void FCardGameCardPileService::AddGlobalCardPiles(FCardGameModel& Model, UCardGameConfiguration* Configuration) const
{
	for (UCardGameCardPile* CardPileClass : Configuration->GetGlobalCardPileClasses())
	{
		FCardGameCardPileModel NewCardPile;
		NewCardPile.CardPileClass = CardPileClass;
		Model.GlobalCardPiles.Add(NewCardPile);
	}
}

void FCardGameCardPileService::AddCardToGlobalCardPile(FCardGameModel& Model, UCardGameCardPile* CardPileClass,
	UCardGameCard* CardClass) const
{
	FCardGameCardPileModel* CardPile = GetGlobalCardPile(Model, CardPileClass);

	if (CardPile == nullptr)
	{
		return;
	}
	
	const FCardGameCardModel NewCard = AddCard(Model, CardClass);
	CardPile->Cards.Add(NewCard.InstanceId);
	
	UE_LOG(LogCardGame, Log, TEXT("Added %s (%d) to global card pile %s."),
		*CardClass->GetName(), NewCard.InstanceId, *CardPileClass->GetName());

	// Notify listeners.
	OnCardAddedToGlobalCardPile.Broadcast(CardPileClass, CardPile->Cards.Num(), NewCard);
}

void FCardGameCardPileService::AddCardToPlayerCardPile(FCardGameModel& Model, uint8 PlayerIndex,
	UCardGameCardPile* CardPileClass, UCardGameCard* CardClass) const
{
	for (FCardGamePlayerModel& Player : Model.Players)
	{
		if (Player.PlayerIndex != PlayerIndex)
		{
			continue;
		}

		FCardGameCardPileModel* CardPile = GetPlayerCardPile(Player, CardPileClass);

		if (CardPile == nullptr)
		{
			return;
		}
		
		const FCardGameCardModel NewCard = AddCard(Model, CardClass);
		CardPile->Cards.Add(NewCard.InstanceId);
	
		UE_LOG(LogCardGame, Log, TEXT("Added %s (%d) to %s of player %d."),
			*CardClass->GetName(), NewCard.InstanceId, *CardPileClass->GetName(), Player.PlayerIndex);

		// Notify listeners.
		OnCardAddedToPlayerCardPile.Broadcast(PlayerIndex, CardPileClass, CardPile->Cards.Num(), NewCard);
		return;
	}
}

void FCardGameCardPileService::ShuffleGlobalCardPile(FCardGameModel& Model, UCardGameCardPile* CardPileClass) const
{
	FCardGameCardPileModel* CardPile = GetGlobalCardPile(Model, CardPileClass);

	if (CardPile == nullptr)
	{
		return;
	}
	
	Shuffle(*CardPile);
	
	UE_LOG(LogCardGame, Log, TEXT("Shuffled global card pile %s."), *CardPileClass->GetName());
}

void FCardGameCardPileService::ShufflePlayerCardPile(FCardGameModel& Model, int32 PlayerIndex,
	UCardGameCardPile* CardPileClass) const
{
	for (FCardGamePlayerModel& Player : Model.Players)
	{
		if (Player.PlayerIndex != PlayerIndex)
		{
			continue;
		}

		FCardGameCardPileModel* CardPile = GetPlayerCardPile(Player, CardPileClass);

		if (CardPile == nullptr)
		{
			return;
		}
	
		Shuffle(*CardPile);
	
		UE_LOG(LogCardGame, Log, TEXT("Shuffled %s of player %d."), *CardPileClass->GetName(), Player.PlayerIndex);
		return;
	}
}

void FCardGameCardPileService::MoveCardBetweenGlobalCardPiles(FCardGameModel& Model, UCardGameCardPile* From,
	UCardGameCardPile* To, int64 CardInstanceId) const
{
	FCardGameCardPileModel* FromCardPile = GetGlobalCardPile(Model, From);
	FCardGameCardPileModel* ToCardPile = GetGlobalCardPile(Model, To);
	
	if (FromCardPile == nullptr || ToCardPile == nullptr)
	{
		return;
	}

	MoveCardBetweenPiles(*FromCardPile, *ToCardPile, CardInstanceId);

	const FCardGameCardModel Card = Model.Cards[CardInstanceId];
	UE_LOG(LogCardGame, Log, TEXT("Moved %s (%d) from global card pile %s to %s."), *Card.CardClass->GetName(),
		Card.InstanceId, *From->GetName(), *To->GetName());
}

void FCardGameCardPileService::MoveCardBetweenPlayerCardPiles(FCardGameModel& Model, int32 PlayerIndex,
	UCardGameCardPile* From, UCardGameCardPile* To, int64 CardInstanceId) const
{
	for (FCardGamePlayerModel& Player : Model.Players)
	{
		if (Player.PlayerIndex != PlayerIndex)
		{
			continue;
		}

		FCardGameCardPileModel* FromCardPile = GetPlayerCardPile(Player, From);
		FCardGameCardPileModel* ToCardPile = GetPlayerCardPile(Player, To);
	
		if (FromCardPile == nullptr || ToCardPile == nullptr)
		{
			return;
		}

		MoveCardBetweenPiles(*FromCardPile, *ToCardPile, CardInstanceId);

		const FCardGameCardModel Card = Model.Cards[CardInstanceId];
		UE_LOG(LogCardGame, Log, TEXT("Moved %s (%d) of player %d from %s to %s."), *Card.CardClass->GetName(),
			Card.InstanceId, Player.PlayerIndex, *From->GetName(), *To->GetName());
		return;
	}
}

void FCardGameCardPileService::MoveLastCardBetweenPlayerCardPiles(FCardGameModel& Model, int32 PlayerIndex,
	UCardGameCardPile* From, UCardGameCardPile* To) const
{
	for (FCardGamePlayerModel& Player : Model.Players)
	{
		if (Player.PlayerIndex != PlayerIndex)
		{
			continue;
		}

		FCardGameCardPileModel* FromCardPile = GetPlayerCardPile(Player, From);
		FCardGameCardPileModel* ToCardPile = GetPlayerCardPile(Player, To);
	
		if (FromCardPile == nullptr || ToCardPile == nullptr)
		{
			return;
		}

		const int64 CardInstanceId = FromCardPile->Cards.Last();
		FromCardPile->Cards.RemoveAt(FromCardPile->Cards.Num() - 1);
		ToCardPile->Cards.Add(CardInstanceId);

		const FCardGameCardModel Card = Model.Cards[CardInstanceId];
		UE_LOG(LogCardGame, Log, TEXT("Moved %s (%d) of player %d from %s to %s."), *Card.CardClass->GetName(),
			Card.InstanceId, Player.PlayerIndex, *From->GetName(), *To->GetName());
		return;
	}
}

FCardGameCardPileModel* FCardGameCardPileService::GetGlobalCardPile(FCardGameModel& Model,
                                                                    UCardGameCardPile* CardPileClass) const
{
	for (FCardGameCardPileModel& CardPile : Model.GlobalCardPiles)
	{
		if (CardPile.CardPileClass == CardPileClass)
		{
			return &CardPile;
		}
	}

	return nullptr;
}

FCardGameCardPileModel* FCardGameCardPileService::GetPlayerCardPile(FCardGamePlayerModel& Player,
	UCardGameCardPile* CardPileClass) const
{
	for (FCardGameCardPileModel& CardPile : Player.PlayerCardPiles)
	{
		if (CardPile.CardPileClass == CardPileClass)
		{
			return &CardPile;
		}
	}

	return nullptr;
}

FCardGameCardModel FCardGameCardPileService::AddCard(FCardGameModel& Model, UCardGameCard* CardClass) const
{
	FCardGameCardModel NewCard;
	NewCard.InstanceId = Model.Cards.Num();
	NewCard.CardClass = CardClass;
	
	for (const auto& InitialAttributeValue : CardClass->GetInitialAttributes())
	{
		FCardGameAttributeWithValue AttributeWithValue(InitialAttributeValue.Key, InitialAttributeValue.Value);
		NewCard.CardModel.Attributes.Add(AttributeWithValue);
	}

	NewCard.CardModel.GameplayTags.AppendTags(CardClass->GetInitialGameplayTags());
	
	Model.Cards.Add(NewCard);
	return NewCard;
}

void FCardGameCardPileService::Shuffle(FCardGameCardPileModel& CardPile) const
{
	TArray<int64> ShuffledCards;

	while (!CardPile.Cards.IsEmpty())
	{
		const int32 RandomIndex = RandomNumberProvider.GetInt(CardPile.Cards.Num());
		ShuffledCards.Add(CardPile.Cards[RandomIndex]);
		CardPile.Cards.RemoveAt(RandomIndex);
	}

	CardPile.Cards = ShuffledCards;
}

void FCardGameCardPileService::MoveCardBetweenPiles(FCardGameCardPileModel& From, FCardGameCardPileModel& To, int64 CardInstanceId) const
{
	// Find in pile.
	for (int32 Index = 0; Index < From.Cards.Num(); ++Index)
	{
		if (From.Cards[Index] != CardInstanceId)
		{
			continue;
		}
		
		From.Cards.RemoveAt(Index);
		To.Cards.Add(CardInstanceId);
		return;
	}
}

```

`Source/CardGame/Private/Services/CardGameGameplayTagService.cpp`:

```cpp
#include "Services/CardGameGameplayTagService.h"

#include "CardGameLogCategory.h"
#include "Model/CardGameModel.h"

FGameplayTagContainer FCardGameGameplayTagService::GetCardGameplayTags(const FCardGameModel& GameModel,
	const FCardGameCardModel& CardModel) const
{
	FGameplayTagContainer Result;
	Result.AppendTags(GameModel.GlobalModel.GameplayTags);
	Result.AppendTags(CardModel.CardModel.GameplayTags);
	return Result;
}

void FCardGameGameplayTagService::AddGlobalGameplayTag(FCardGameModel& Model, const FGameplayTag& TagToAdd) const
{
	Model.GlobalModel.GameplayTags.AddTag(TagToAdd);
	
	UE_LOG(LogCardGame, Log, TEXT("Added global gameplay tag %s."), *TagToAdd.ToString());
}

void FCardGameGameplayTagService::RemoveGlobalGameplayTag(FCardGameModel& Model, const FGameplayTag& TagToRemove) const
{
	Model.GlobalModel.GameplayTags.RemoveTag(TagToRemove);
	
	UE_LOG(LogCardGame, Log, TEXT("Removed global gameplay tag %s."), *TagToRemove.ToString());
}

```

`Source/CardGame/Private/Services/CardGamePlayerService.cpp`:

```cpp
#include "Services/CardGamePlayerService.h"

#include "Assets/CardGameCardPile.h"
#include "Assets/CardGameConfiguration.h"
#include "Model/CardGameCardPileModel.h"
#include "Model/CardGameModel.h"
#include "Model/CardGamePlayerModel.h"

int32 FCardGamePlayerService::AddPlayer(FCardGameModel& Model, const UCardGameConfiguration* Configuration) const
{
	FCardGamePlayerModel NewPlayer;
	NewPlayer.PlayerIndex = GetAvailablePlayerIndex(Model);

	if (IsValid(Configuration))
	{
		for (UCardGameCardPile* CardPileClass : Configuration->GetPlayerCardPileClasses())
		{
			FCardGameCardPileModel NewCardPile;
			NewCardPile.CardPileClass = CardPileClass;
			NewPlayer.PlayerCardPiles.Add(NewCardPile);
		}
	}

	Model.Players.Add(NewPlayer);

	return NewPlayer.PlayerIndex;
}

int32 FCardGamePlayerService::GetAvailablePlayerIndex(const FCardGameModel& Model) const
{
	int32 NewPlayerIndex = 0;
	bool bPlayerIndexInUse = true;
			
	while (bPlayerIndexInUse)
	{
		bPlayerIndexInUse = IsPlayerIndexInUse(Model, NewPlayerIndex);

		if (bPlayerIndexInUse)
		{
			++NewPlayerIndex;
		}
	}

	return NewPlayerIndex;
}

bool FCardGamePlayerService::IsPlayerIndexInUse(const FCardGameModel& Model, int32 PlayerIndex) const
{
	for (const FCardGamePlayerModel& ExistingPlayer : Model.Players)
	{
		if (ExistingPlayer.PlayerIndex == PlayerIndex)
		{
			return true;
		}
	}

	return false;
}

```

`Source/CardGame/Private/Tests/CardGameAttributeServiceTest.cpp`:

```cpp
#include "Misc/AutomationTest.h"

#include "Assets/CardGameAttribute.h"
#include "Model/CardGameModel.h"
#include "Services/CardGameAttributeService.h"

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FGetGlobalAttributeValueTest, "CardGame.AttributeService.GetGlobalAttributeValue", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FGetGlobalAttributeValueTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameAttribute* Attribute = NewObject<UCardGameAttribute>();
	const FCardGameAttributeWithValue AttributeWithValue(Attribute, 2);

	Model.GlobalModel.Attributes.Add(AttributeWithValue);

	// ACT
	constexpr FCardGameAttributeService AttributeService;
	const int32 Result = AttributeService.GetGlobalAttributeValue(Model, Attribute);

	// ASSERT
	TestEqual(TEXT("Attribute Value"), Result, AttributeWithValue.Value);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FSetGlobalAttributeValueAddsNewValueTest, "CardGame.AttributeService.SetGlobalAttributeValueAddsNewValue", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FSetGlobalAttributeValueAddsNewValueTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	UCardGameAttribute* Attribute = NewObject<UCardGameAttribute>();
	constexpr int32 NewAttributeValue = 2;
	
	// ACT
	constexpr FCardGameAttributeService AttributeService;
	AttributeService.SetGlobalAttributeValue(Model, Attribute, NewAttributeValue);

	// ASSERT
	TestEqual(TEXT("Number Of Attribute Values"), Model.GlobalModel.Attributes.Num(), 1);
	TestEqual(TEXT("Attribute Reference"), Model.GlobalModel.Attributes[0].Attribute, Attribute);
	TestEqual(TEXT("Attribute Value"), Model.GlobalModel.Attributes[0].Value, NewAttributeValue);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FSetGlobalAttributeValueChangesExistingValueTest, "CardGame.AttributeService.SetGlobalAttributeValueChangesExistingValue", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FSetGlobalAttributeValueChangesExistingValueTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameAttribute* Attribute = NewObject<UCardGameAttribute>();
	const FCardGameAttributeWithValue AttributeWithValue(Attribute, 2);

	Model.GlobalModel.Attributes.Add(AttributeWithValue);
	
	constexpr int32 NewAttributeValue = 3;
	
	// ACT
	constexpr FCardGameAttributeService AttributeService;
	AttributeService.SetGlobalAttributeValue(Model, Attribute, NewAttributeValue);

	// ASSERT
	TestEqual(TEXT("Attribute Value"), Model.GlobalModel.Attributes[0].Value, NewAttributeValue);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FGetPlayerAttributeValueTest, "CardGame.AttributeService.GetPlayerAttributeValue", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FGetPlayerAttributeValueTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;

	UCardGameAttribute* Attribute = NewObject<UCardGameAttribute>();
	const FCardGameAttributeWithValue AttributeWithValue(Attribute, 2);

	FCardGamePlayerModel Player;
	Player.PlayerIndex = 3;
	Player.PlayerModel.Attributes.Add(AttributeWithValue);

	Model.Players.Add(Player);
	
	// ACT
	constexpr FCardGameAttributeService AttributeService;
	const int32 Result = AttributeService.GetPlayerAttributeValue(Model, Player.PlayerIndex, Attribute);

	// ASSERT
	TestEqual(TEXT("Attribute Value"), Result, AttributeWithValue.Value);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FSetPlayerAttributeValueAddsNewValueTest, "CardGame.AttributeService.SetPlayerAttributeValueAddsNewValue", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FSetPlayerAttributeValueAddsNewValueTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	UCardGameAttribute* Attribute = NewObject<UCardGameAttribute>();
	constexpr int32 NewAttributeValue = 2;

	FCardGamePlayerModel Player;
	Player.PlayerIndex = 3;
	Model.Players.Add(Player);
	
	// ACT
	constexpr FCardGameAttributeService AttributeService;
	AttributeService.SetPlayerAttributeValue(Model, Player.PlayerIndex, Attribute, NewAttributeValue);

	// ASSERT
	TestEqual(TEXT("Number Of Attribute Values"), Model.Players[0].PlayerModel.Attributes.Num(), 1);
	TestEqual(TEXT("Attribute Reference"), Model.Players[0].PlayerModel.Attributes[0].Attribute, Attribute);
	TestEqual(TEXT("Attribute Value"), Model.Players[0].PlayerModel.Attributes[0].Value, NewAttributeValue);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FSetPlayerAttributeValueChangesExistingValueTest, "CardGame.AttributeService.SetPlayerAttributeValueChangesExistingValue", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FSetPlayerAttributeValueChangesExistingValueTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameAttribute* Attribute = NewObject<UCardGameAttribute>();
	const FCardGameAttributeWithValue AttributeWithValue(Attribute, 2);

	FCardGamePlayerModel Player;
	Player.PlayerIndex = 3;
	Player.PlayerModel.Attributes.Add(AttributeWithValue);

	Model.Players.Add(Player);
	
	constexpr int32 NewAttributeValue = 4;
	
	// ACT
	constexpr FCardGameAttributeService AttributeService;
	AttributeService.SetPlayerAttributeValue(Model, Player.PlayerIndex, Attribute, NewAttributeValue);

	// ASSERT
	TestEqual(TEXT("Attribute Value"), Model.Players[0].PlayerModel.Attributes[0].Value, NewAttributeValue);
	return true;
}

```

`Source/CardGame/Private/Tests/CardGameCardPileServiceTest.cpp`:

```cpp
#include "Misc/AutomationTest.h"

#include "GameplayTagsManager.h"

#include "Assets/CardGameAttribute.h"
#include "Assets/CardGameCard.h"
#include "Assets/CardGameCardPile.h"
#include "Assets/CardGameConfiguration.h"
#include "Model/CardGameModel.h"
#include "Providers/CardGameRandomNumberProvider.h"
#include "Services/CardGameCardPileService.h"

namespace CardGameCardPileServiceTest
{
	class FOnCardAddedToGlobalCardPileTestEventHandler
	{
	public:
		UCardGameCardPile* CardPileClass;
		int32 PositionInCardPile;
		FCardGameCardModel Card;
		
		void OnCardAddedToGlobalCardPile(UCardGameCardPile* InCardPileClass, int32 InPositionInCardPile, FCardGameCardModel InCard)
		{
			CardPileClass = InCardPileClass;
			PositionInCardPile = InPositionInCardPile;
			Card = InCard;
		}
	};

	class FOnCardAddedToPlayerCardPileTestEventHandler
	{
	public:
		uint8 PlayerIndex;
		UCardGameCardPile* CardPileClass;
		int32 PositionInCardPile;
		FCardGameCardModel Card;
		
		void OnCardAddedToPlayerCardPile(uint8 InPlayerIndex, UCardGameCardPile* InCardPileClass, int32 InPositionInCardPile, FCardGameCardModel InCard)
		{
			PlayerIndex = InPlayerIndex;
			CardPileClass = InCardPileClass;
			PositionInCardPile = InPositionInCardPile;
			Card = InCard;
		}
	};
	
	struct FNativeGameplayTags : FGameplayTagNativeAdder
	{
		FGameplayTag TestTagA;
		FGameplayTag TestTagB;
	
		virtual void AddTags() override
		{
			UGameplayTagsManager& Manager = UGameplayTagsManager::Get();
			TestTagA = Manager.AddNativeGameplayTag(TEXT("CardGameCardPileServiceTest.TestTag.A"));
			TestTagB = Manager.AddNativeGameplayTag(TEXT("CardGameCardPileServiceTest.TestTag.B"));
		}

		FORCEINLINE static const FNativeGameplayTags& Get()
		{
			return StaticInstance;
		}
		static FNativeGameplayTags StaticInstance;
	};
	FNativeGameplayTags FNativeGameplayTags::StaticInstance;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FGetCardModelByInstanceIdGetsGlobalCardTest, "CardGame.CardPileService.GetCardModelByInstanceIdGetsGlobalCard", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FGetCardModelByInstanceIdGetsGlobalCardTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameCardPile* TestCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel TestCardPile;
	TestCardPile.CardPileClass = TestCardPileClass;
	Model.GlobalCardPiles.Add(TestCardPile);

	UCardGameCard* TestCardClass = NewObject<UCardGameCard>();
	
	FCardGameCardModel TestCard;
	TestCard.InstanceId = Model.Cards.Num();
	TestCard.CardClass = TestCardClass;

	int64 InstanceId = Model.Cards.Add(TestCard);
	Model.GlobalCardPiles[0].Cards.Add(InstanceId);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	TOptional<FCardGameCardModel> FoundCard = CardPileService.GetCardModelByInstanceId(Model, TestCard.InstanceId);
	
	// ASSERT
	TestTrue(TEXT("Has Found Card"), FoundCard.IsSet());
	TestEqual(TEXT("Card Instance Id"), FoundCard.GetValue().InstanceId, 0LL);
	TestEqual(TEXT("Card Class"), FoundCard.GetValue().CardClass, TestCardClass);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FGetCardModelByInstanceIdGetsPlayerCardTest, "CardGame.CardPileService.GetCardModelByInstanceIdGetsPlayerCard", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FGetCardModelByInstanceIdGetsPlayerCardTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameCardPile* TestCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel TestCardPile;
	TestCardPile.CardPileClass = TestCardPileClass;
	
	FCardGamePlayerModel Player;
	Player.PlayerIndex = 2;
	Player.PlayerCardPiles.Add(TestCardPile);
	Model.Players.Add(Player);

	UCardGameCard* TestCardClass = NewObject<UCardGameCard>();
	
	FCardGameCardModel TestCard;
	TestCard.InstanceId = Model.Cards.Num();
	TestCard.CardClass = TestCardClass;

	int64 InstanceId = Model.Cards.Add(TestCard);
	Model.Players[0].PlayerCardPiles[0].Cards.Add(InstanceId);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	TOptional<FCardGameCardModel> FoundCard = CardPileService.GetCardModelByInstanceId(Model, TestCard.InstanceId);
	
	// ASSERT
	TestTrue(TEXT("Has Found Card"), FoundCard.IsSet());
	TestEqual(TEXT("Card Instance Id"), FoundCard.GetValue().InstanceId, 0LL);
	TestEqual(TEXT("Card Class"), FoundCard.GetValue().CardClass, TestCardClass);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddGlobalCardPilesTest, "CardGame.CardPileService.AddGlobalCardPiles", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddGlobalCardPilesTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;

	UCardGameCardPile* TestCardPile0 = NewObject<UCardGameCardPile>();
	UCardGameCardPile* TestCardPile1 = NewObject<UCardGameCardPile>();
	
	TArray<UCardGameCardPile*> CardPileClasses;
	CardPileClasses.Add(TestCardPile0);
	CardPileClasses.Add(TestCardPile1);
	
	UCardGameConfiguration* Configuration = NewObject<UCardGameConfiguration>();
	Configuration->SetGlobalCardPileClasses(CardPileClasses);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.AddGlobalCardPiles(Model, Configuration);
	
	// ASSERT
	TestEqual(TEXT("Num Global Card Piles"), Model.GlobalCardPiles.Num(), 2);
	TestEqual(TEXT("Global Card Pile 0"), Model.GlobalCardPiles[0].CardPileClass, TestCardPile0);
	TestEqual(TEXT("Global Card Pile 1"), Model.GlobalCardPiles[1].CardPileClass, TestCardPile1);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddCardToGlobalCardPileSetsCardClassTest, "CardGame.CardPileService.AddCardToGlobalCardPileSetsCardClass", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddCardToGlobalCardPileSetsCardClassTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameCardPile* TestCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel TestCardPile;
	TestCardPile.CardPileClass = TestCardPileClass;
	Model.GlobalCardPiles.Add(TestCardPile);

	UCardGameCard* TestCard = NewObject<UCardGameCard>();
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.AddCardToGlobalCardPile(Model, TestCardPileClass, TestCard);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.GlobalCardPiles[0].Cards.Num(), 1);
	TestEqual(TEXT("Card Class"), Model.Cards[0].CardClass, TestCard);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddCardToGlobalCardPileSetsAttributesTest, "CardGame.CardPileService.AddCardToGlobalCardPileSetsAttributes", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddCardToGlobalCardPileSetsAttributesTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameCardPile* TestCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel TestCardPile;
	TestCardPile.CardPileClass = TestCardPileClass;
	Model.GlobalCardPiles.Add(TestCardPile);

	UCardGameCard* TestCard = NewObject<UCardGameCard>();

	UCardGameAttribute* TestAttribute1 = NewObject<UCardGameAttribute>();
	UCardGameAttribute* TestAttribute2 = NewObject<UCardGameAttribute>();
	
	TMap<UCardGameAttribute*, int32> InitialAttributes;
	InitialAttributes.Add(TestAttribute1, 2);
	InitialAttributes.Add(TestAttribute2, 3);
	TestCard->SetInitialAttributes(InitialAttributes);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.AddCardToGlobalCardPile(Model, TestCardPileClass, TestCard);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.GlobalCardPiles[0].Cards.Num(), 1);
	TestEqual(TEXT("Num Attributes"), Model.Cards[0].CardModel.Attributes.Num(), 2);
	TestEqual(TEXT("Attribute 1 Class"), Model.Cards[0].CardModel.Attributes[0].Attribute, TestAttribute1);
	TestEqual(TEXT("Attribute 1 Value"), Model.Cards[0].CardModel.Attributes[0].Value, 2);
	TestEqual(TEXT("Attribute 2 Class"), Model.Cards[0].CardModel.Attributes[1].Attribute, TestAttribute2);
	TestEqual(TEXT("Attribute 2 Value"), Model.Cards[0].CardModel.Attributes[1].Value, 3);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddCardToGlobalCardPileSetsGameplayTagsTest, "CardGame.CardPileService.AddCardToGlobalCardPileSetsGameplayTags", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddCardToGlobalCardPileSetsGameplayTagsTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameCardPile* TestCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel TestCardPile;
	TestCardPile.CardPileClass = TestCardPileClass;
	Model.GlobalCardPiles.Add(TestCardPile);

	UCardGameCard* TestCard = NewObject<UCardGameCard>();
	
	const FGameplayTag TestTagA = CardGameCardPileServiceTest::FNativeGameplayTags::Get().TestTagA;
	const FGameplayTag TestTagB = CardGameCardPileServiceTest::FNativeGameplayTags::Get().TestTagB;

	FGameplayTagContainer TestGameplayTags;
	TestGameplayTags.AddTag(TestTagA);
	TestGameplayTags.AddTag(TestTagB);
	TestCard->SetInitialGameplayTags(TestGameplayTags);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.AddCardToGlobalCardPile(Model, TestCardPileClass, TestCard);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.GlobalCardPiles[0].Cards.Num(), 1);
	TestTrue(TEXT("Card Has Gameplay Tag A"), Model.Cards[0].CardModel.GameplayTags.HasTag(TestTagA));
	TestTrue(TEXT("Card Has Gameplay Tag A"), Model.Cards[0].CardModel.GameplayTags.HasTag(TestTagB));
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddCardToGlobalCardPileRaisesEventTest, "CardGame.CardPileService.AddCardToGlobalCardPileRaisesEvent", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddCardToGlobalCardPileRaisesEventTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameCardPile* TestCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel TestCardPile;
	TestCardPile.CardPileClass = TestCardPileClass;
	Model.GlobalCardPiles.Add(TestCardPile);

	UCardGameCard* TestCard = NewObject<UCardGameCard>();
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	FCardGameCardPileService CardPileService(RandomNumberProvider);

	CardGameCardPileServiceTest::FOnCardAddedToGlobalCardPileTestEventHandler TestEventHandler;
	CardPileService.OnCardAddedToGlobalCardPile.AddRaw(&TestEventHandler,
		&CardGameCardPileServiceTest::FOnCardAddedToGlobalCardPileTestEventHandler::OnCardAddedToGlobalCardPile);
	
	CardPileService.AddCardToGlobalCardPile(Model, TestCardPileClass, TestCard);
	
	// ASSERT
	TestEqual(TEXT("Event Card Pile Class"), TestEventHandler.CardPileClass, TestCardPileClass);
	TestEqual(TEXT("Event Card Class"), TestEventHandler.Card.CardClass, TestCard);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddCardToPlayerCardPileSetsCardClassTest, "CardGame.CardPileService.AddCardToPlayerCardPileSetsCardClass", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddCardToPlayerCardPileSetsCardClassTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameCardPile* TestCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel TestCardPile;
	TestCardPile.CardPileClass = TestCardPileClass;

	FCardGamePlayerModel Player;
	Player.PlayerIndex = 2;
	Player.PlayerCardPiles.Add(TestCardPile);
	Model.Players.Add(Player);

	UCardGameCard* TestCard = NewObject<UCardGameCard>();
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.AddCardToPlayerCardPile(Model, Player.PlayerIndex, TestCardPileClass, TestCard);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.Players[0].PlayerCardPiles[0].Cards.Num(), 1);
	TestEqual(TEXT("Card Class"), Model.Cards[0].CardClass, TestCard);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddCardToPlayerCardPileSetsAttributesTest, "CardGame.CardPileService.AddCardToPlayerCardPileSetsAttributes", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddCardToPlayerCardPileSetsAttributesTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameCardPile* TestCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel TestCardPile;
	TestCardPile.CardPileClass = TestCardPileClass;

	FCardGamePlayerModel Player;
	Player.PlayerIndex = 2;
	Player.PlayerCardPiles.Add(TestCardPile);
	Model.Players.Add(Player);

	UCardGameCard* TestCard = NewObject<UCardGameCard>();

	UCardGameAttribute* TestAttribute1 = NewObject<UCardGameAttribute>();
	UCardGameAttribute* TestAttribute2 = NewObject<UCardGameAttribute>();
	
	TMap<UCardGameAttribute*, int32> InitialAttributes;
	InitialAttributes.Add(TestAttribute1, 2);
	InitialAttributes.Add(TestAttribute2, 3);
	TestCard->SetInitialAttributes(InitialAttributes);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.AddCardToPlayerCardPile(Model, Player.PlayerIndex, TestCardPileClass, TestCard);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.Players[0].PlayerCardPiles[0].Cards.Num(), 1);
	TestEqual(TEXT("Num Attributes"), Model.Cards[0].CardModel.Attributes.Num(), 2);
	TestEqual(TEXT("Attribute 1 Class"), Model.Cards[0].CardModel.Attributes[0].Attribute, TestAttribute1);
	TestEqual(TEXT("Attribute 1 Value"), Model.Cards[0].CardModel.Attributes[0].Value, 2);
	TestEqual(TEXT("Attribute 2 Class"), Model.Cards[0].CardModel.Attributes[1].Attribute, TestAttribute2);
	TestEqual(TEXT("Attribute 2 Value"), Model.Cards[0].CardModel.Attributes[1].Value, 3);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddCardToPlayerCardPileSetsGameplayTagsTest, "CardGame.CardPileService.AddCardToPlayerCardPileSetsGameplayTags", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddCardToPlayerCardPileSetsGameplayTagsTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameCardPile* TestCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel TestCardPile;
	TestCardPile.CardPileClass = TestCardPileClass;

	FCardGamePlayerModel Player;
	Player.PlayerIndex = 2;
	Player.PlayerCardPiles.Add(TestCardPile);
	Model.Players.Add(Player);

	UCardGameCard* TestCard = NewObject<UCardGameCard>();
	
	const FGameplayTag TestTagA = CardGameCardPileServiceTest::FNativeGameplayTags::Get().TestTagA;
	const FGameplayTag TestTagB = CardGameCardPileServiceTest::FNativeGameplayTags::Get().TestTagB;

	FGameplayTagContainer TestGameplayTags;
	TestGameplayTags.AddTag(TestTagA);
	TestGameplayTags.AddTag(TestTagB);
	TestCard->SetInitialGameplayTags(TestGameplayTags);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.AddCardToPlayerCardPile(Model, Player.PlayerIndex, TestCardPileClass, TestCard);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.Players[0].PlayerCardPiles[0].Cards.Num(), 1);
	TestTrue(TEXT("Card Has Gameplay Tag A"), Model.Cards[0].CardModel.GameplayTags.HasTag(TestTagA));
	TestTrue(TEXT("Card Has Gameplay Tag A"), Model.Cards[0].CardModel.GameplayTags.HasTag(TestTagB));
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddCardToPlayerCardPileRaisesEventTest, "CardGame.CardPileService.AddCardToPlayerCardPileRaisesEvent", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddCardToPlayerCardPileRaisesEventTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	UCardGameCardPile* TestCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel TestCardPile;
	TestCardPile.CardPileClass = TestCardPileClass;
	
	FCardGamePlayerModel Player;
	Player.PlayerIndex = 2;
	Player.PlayerCardPiles.Add(TestCardPile);
	Model.Players.Add(Player);

	UCardGameCard* TestCard = NewObject<UCardGameCard>();
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	FCardGameCardPileService CardPileService(RandomNumberProvider);

	CardGameCardPileServiceTest::FOnCardAddedToPlayerCardPileTestEventHandler TestEventHandler;
	CardPileService.OnCardAddedToPlayerCardPile.AddRaw(&TestEventHandler,
		&CardGameCardPileServiceTest::FOnCardAddedToPlayerCardPileTestEventHandler::OnCardAddedToPlayerCardPile);
	
	CardPileService.AddCardToPlayerCardPile(Model, Player.PlayerIndex, TestCardPileClass, TestCard);
	
	// ASSERT
	TestEqual(TEXT("Event Player Index"), TestEventHandler.PlayerIndex, Player.PlayerIndex);
	TestEqual(TEXT("Event Card Pile Class"), TestEventHandler.CardPileClass, TestCardPileClass);
	TestEqual(TEXT("Event Card Class"), TestEventHandler.Card.CardClass, TestCard);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FMoveCardBetweenGlobalCardPilesRemovesCardFromOldPileTest, "CardGame.CardPileService.MoveCardBetweenGlobalCardPilesRemovesCardFromOldPile", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FMoveCardBetweenGlobalCardPilesRemovesCardFromOldPileTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;

	UCardGameCard* TestCardClass = NewObject<UCardGameCard>();

	FCardGameCardModel MovedCard(0, TestCardClass);
	FCardGameCardModel UnchangedCard(1, TestCardClass);

	Model.Cards.Add(MovedCard);
	Model.Cards.Add(UnchangedCard);
	
	UCardGameCardPile* OldCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel OldCardPile;
	OldCardPile.CardPileClass = OldCardPileClass;
	OldCardPile.Cards.Add(MovedCard.InstanceId);
	OldCardPile.Cards.Add(UnchangedCard.InstanceId);
	Model.GlobalCardPiles.Add(OldCardPile);

	UCardGameCardPile* NewCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel NewCardPile;
	NewCardPile.CardPileClass = NewCardPileClass;
	Model.GlobalCardPiles.Add(NewCardPile);

	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.MoveCardBetweenGlobalCardPiles(Model, OldCardPileClass, NewCardPileClass, MovedCard.InstanceId);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.GlobalCardPiles[0].Cards.Num(), 1);
	TestEqual(TEXT("Remaining Card Instance Id"), Model.GlobalCardPiles[0].Cards[0], UnchangedCard.InstanceId);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FMoveCardBetweenGlobalCardPilesAddsCardToNewPileTest, "CardGame.CardPileService.MoveCardBetweenGlobalCardPilesAddsCardToNewPile", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FMoveCardBetweenGlobalCardPilesAddsCardToNewPileTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;

	UCardGameCard* TestCardClass = NewObject<UCardGameCard>();

	FCardGameCardModel MovedCard(0, TestCardClass);
	FCardGameCardModel UnchangedCard(1, TestCardClass);

	Model.Cards.Add(MovedCard);
	Model.Cards.Add(UnchangedCard);
	
	UCardGameCardPile* OldCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel OldCardPile;
	OldCardPile.CardPileClass = OldCardPileClass;
	OldCardPile.Cards.Add(MovedCard.InstanceId);
	OldCardPile.Cards.Add(UnchangedCard.InstanceId);
	Model.GlobalCardPiles.Add(OldCardPile);

	UCardGameCardPile* NewCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel NewCardPile;
	NewCardPile.CardPileClass = NewCardPileClass;
	Model.GlobalCardPiles.Add(NewCardPile);

	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.MoveCardBetweenGlobalCardPiles(Model, OldCardPileClass, NewCardPileClass, MovedCard.InstanceId);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.GlobalCardPiles[1].Cards.Num(), 1);
	TestEqual(TEXT("New Card Instance Id"), Model.GlobalCardPiles[1].Cards[0], MovedCard.InstanceId);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FMoveCardBetweenPlayerCardPilesRemovesCardFromOldPileTest, "CardGame.CardPileService.MoveCardBetweenPlayerCardPilesRemovesCardFromOldPile", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FMoveCardBetweenPlayerCardPilesRemovesCardFromOldPileTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;

	FCardGamePlayerModel Player;
	Player.PlayerIndex = 2;
	
	UCardGameCard* TestCardClass = NewObject<UCardGameCard>();

	FCardGameCardModel MovedCard(0, TestCardClass);
	FCardGameCardModel UnchangedCard(1, TestCardClass);

	Model.Cards.Add(MovedCard);
	Model.Cards.Add(UnchangedCard);
	
	UCardGameCardPile* OldCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel OldCardPile;
	OldCardPile.CardPileClass = OldCardPileClass;
	OldCardPile.Cards.Add(MovedCard.InstanceId);
	OldCardPile.Cards.Add(UnchangedCard.InstanceId);
	Player.PlayerCardPiles.Add(OldCardPile);

	UCardGameCardPile* NewCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel NewCardPile;
	NewCardPile.CardPileClass = NewCardPileClass;
	Player.PlayerCardPiles.Add(NewCardPile);

	Model.Players.Add(Player);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.MoveCardBetweenPlayerCardPiles(Model, Player.PlayerIndex, OldCardPileClass, NewCardPileClass, MovedCard.InstanceId);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.Players[0].PlayerCardPiles[0].Cards.Num(), 1);
	TestEqual(TEXT("Remaining Card Instance Id"), Model.Players[0].PlayerCardPiles[0].Cards[0], UnchangedCard.InstanceId);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FMoveCardBetweenPlayerCardPilesAddsCardToNewPileTest, "CardGame.CardPileService.MoveCardBetweenPlayerCardPilesAddsCardToNewPile", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FMoveCardBetweenPlayerCardPilesAddsCardToNewPileTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;

	FCardGamePlayerModel Player;
	Player.PlayerIndex = 2;
	
	UCardGameCard* TestCardClass = NewObject<UCardGameCard>();

	FCardGameCardModel MovedCard(0, TestCardClass);
	FCardGameCardModel UnchangedCard(1, TestCardClass);

	Model.Cards.Add(MovedCard);
	Model.Cards.Add(UnchangedCard);
	
	UCardGameCardPile* OldCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel OldCardPile;
	OldCardPile.CardPileClass = OldCardPileClass;
	OldCardPile.Cards.Add(MovedCard.InstanceId);
	OldCardPile.Cards.Add(UnchangedCard.InstanceId);
	Player.PlayerCardPiles.Add(OldCardPile);

	UCardGameCardPile* NewCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel NewCardPile;
	NewCardPile.CardPileClass = NewCardPileClass;
	Player.PlayerCardPiles.Add(NewCardPile);

	Model.Players.Add(Player);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.MoveCardBetweenPlayerCardPiles(Model, Player.PlayerIndex, OldCardPileClass, NewCardPileClass, MovedCard.InstanceId);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.Players[0].PlayerCardPiles[1].Cards.Num(), 1);
	TestEqual(TEXT("New Card Instance Id"), Model.Players[0].PlayerCardPiles[1].Cards[0], MovedCard.InstanceId);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FMoveLastCardBetweenPlayerCardPilesRemovesCardFromOldPileTest, "CardGame.CardPileService.MoveLastCardBetweenPlayerCardPilesRemovesCardFromOldPile", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FMoveLastCardBetweenPlayerCardPilesRemovesCardFromOldPileTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;

	FCardGamePlayerModel Player;
	Player.PlayerIndex = 2;
	
	UCardGameCard* TestCardClass = NewObject<UCardGameCard>();

	FCardGameCardModel UnchangedCard(0, TestCardClass);
	FCardGameCardModel MovedCard(1, TestCardClass);

	Model.Cards.Add(UnchangedCard);
	Model.Cards.Add(MovedCard);

	UCardGameCardPile* OldCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel OldCardPile;
	OldCardPile.CardPileClass = OldCardPileClass;
	OldCardPile.Cards.Add(UnchangedCard.InstanceId);
	OldCardPile.Cards.Add(MovedCard.InstanceId);
	Player.PlayerCardPiles.Add(OldCardPile);

	UCardGameCardPile* NewCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel NewCardPile;
	NewCardPile.CardPileClass = NewCardPileClass;
	Player.PlayerCardPiles.Add(NewCardPile);

	Model.Players.Add(Player);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.MoveLastCardBetweenPlayerCardPiles(Model, Player.PlayerIndex, OldCardPileClass, NewCardPileClass);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.Players[0].PlayerCardPiles[0].Cards.Num(), 1);
	TestEqual(TEXT("Remaining Card Instance Id"), Model.Players[0].PlayerCardPiles[0].Cards[0], UnchangedCard.InstanceId);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FMoveLastCardBetweenPlayerCardPilesAddsCardToNewPileTest, "CardGame.CardPileService.MoveCardBetweenPlayerCardPilesAddsCardToNewPile", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FMoveLastCardBetweenPlayerCardPilesAddsCardToNewPileTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;

	FCardGamePlayerModel Player;
	Player.PlayerIndex = 2;
	
	UCardGameCard* TestCardClass = NewObject<UCardGameCard>();

	FCardGameCardModel UnchangedCard(0, TestCardClass);
	FCardGameCardModel MovedCard(1, TestCardClass);

	Model.Cards.Add(UnchangedCard);
	Model.Cards.Add(MovedCard);
	
	UCardGameCardPile* OldCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel OldCardPile;
	OldCardPile.CardPileClass = OldCardPileClass;
	OldCardPile.Cards.Add(UnchangedCard.InstanceId);
	OldCardPile.Cards.Add(MovedCard.InstanceId);
	Player.PlayerCardPiles.Add(OldCardPile);

	UCardGameCardPile* NewCardPileClass = NewObject<UCardGameCardPile>();
	FCardGameCardPileModel NewCardPile;
	NewCardPile.CardPileClass = NewCardPileClass;
	Player.PlayerCardPiles.Add(NewCardPile);

	Model.Players.Add(Player);
	
	// ACT
	FCardGameRandomNumberProvider RandomNumberProvider;
	const FCardGameCardPileService CardPileService(RandomNumberProvider);
	
	CardPileService.MoveLastCardBetweenPlayerCardPiles(Model, Player.PlayerIndex, OldCardPileClass, NewCardPileClass);
	
	// ASSERT
	TestEqual(TEXT("Num Cards"), Model.Players[0].PlayerCardPiles[1].Cards.Num(), 1);
	TestEqual(TEXT("New Card Instance Id"), Model.Players[0].PlayerCardPiles[1].Cards[0], MovedCard.InstanceId);
	return true;
}

```

`Source/CardGame/Private/Tests/CardGameGameplayTagServiceTest.cpp`:

```cpp
#include "GameplayTagsManager.h"
#include "Misc/AutomationTest.h"

#include "Model/CardGameModel.h"
#include "Services/CardGameGameplayTagService.h"

namespace CardGameGameplayTagServiceTest
{
	struct FNativeGameplayTags : FGameplayTagNativeAdder
	{
		FGameplayTag TestTagA;
		FGameplayTag TestTagB;
		
		virtual void AddTags() override
		{
			UGameplayTagsManager& Manager = UGameplayTagsManager::Get();
			TestTagA = Manager.AddNativeGameplayTag(TEXT("CardGameGameplayTagServiceTest.TestTag.A"));
			TestTagB = Manager.AddNativeGameplayTag(TEXT("CardGameGameplayTagServiceTest.TestTag.B"));
		}

		FORCEINLINE static const FNativeGameplayTags& Get()
		{
			return StaticInstance;
		}
		static FNativeGameplayTags StaticInstance;
	};
	FNativeGameplayTags FNativeGameplayTags::StaticInstance;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FGetCardGameplayTagsTest, "CardGame.GameplayTagService.GetCardGameplayTags", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FGetCardGameplayTagsTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	const FGameplayTag TestTagA = CardGameGameplayTagServiceTest::FNativeGameplayTags::Get().TestTagA;
	const FGameplayTag TestTagB = CardGameGameplayTagServiceTest::FNativeGameplayTags::Get().TestTagB;

	FCardGameModel GameModel;
	GameModel.GlobalModel.GameplayTags.AddTag(TestTagA);

	FCardGameCardModel CardModel;
	CardModel.CardModel.GameplayTags.AddTag(TestTagB);
	
	// ACT
	constexpr FCardGameGameplayTagService GameplayTagService;
	FGameplayTagContainer CombinedTags = GameplayTagService.GetCardGameplayTags(GameModel, CardModel);

	// ASSERT
	TestTrue(TEXT("CombinedTags Has Test Tag A"), CombinedTags.HasTag(TestTagA));
	TestTrue(TEXT("CombinedTags Has Test Tag B"), CombinedTags.HasTag(TestTagB));
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddGlobalGameplayTagTest, "CardGame.GameplayTagService.AddGlobalGameplayTag", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddGlobalGameplayTagTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	const FGameplayTag TestTag = CardGameGameplayTagServiceTest::FNativeGameplayTags::Get().TestTagA;
	FCardGameModel Model;
	
	// ACT
	constexpr FCardGameGameplayTagService GameplayTagService;
	GameplayTagService.AddGlobalGameplayTag(Model, TestTag);

	// ASSERT
	TestTrue(TEXT("Test Tag Added"), Model.GlobalModel.GameplayTags.HasTag(TestTag));
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FRemoveGlobalGameplayTagTest, "CardGame.GameplayTagService.RemoveGlobalGameplayTag", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FRemoveGlobalGameplayTagTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	const FGameplayTag TestTag = CardGameGameplayTagServiceTest::FNativeGameplayTags::Get().TestTagA;

	FCardGameModel Model;
	Model.GlobalModel.GameplayTags.AddTag(TestTag);
	
	// ACT
	constexpr FCardGameGameplayTagService GameplayTagService;
	GameplayTagService.RemoveGlobalGameplayTag(Model, TestTag);

	// ASSERT
	TestTrue(TEXT("Test Tag Removed"), !Model.GlobalModel.GameplayTags.HasTag(TestTag));
	return true;
}

```

`Source/CardGame/Private/Tests/CardGamePlayerServiceTest.cpp`:

```cpp
#include "Misc/AutomationTest.h"

#include "Assets/CardGameCardPile.h"
#include "Assets/CardGameConfiguration.h"
#include "Model/CardGameModel.h"
#include "Services/CardGamePlayerService.h"

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddPlayerUsesUniquePlayerIndexTest, "CardGame.PlayerService.AddPlayerUsesUniquePlayerIndex", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddPlayerUsesUniquePlayerIndexTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;
	
	FCardGamePlayerModel ExistingPlayer0;
	ExistingPlayer0.PlayerIndex = 0;
	Model.Players.Add(ExistingPlayer0);
	
	FCardGamePlayerModel ExistingPlayer1;
	ExistingPlayer1.PlayerIndex = 1;
	Model.Players.Add(ExistingPlayer1);
	
	// ACT
	constexpr FCardGamePlayerService PlayerService;
	const int32 NewPlayerIndex = PlayerService.AddPlayer(Model, nullptr);
	
	// ASSERT
	TestEqual(TEXT("Num Players"), Model.Players.Num(), 3);
	TestEqual(TEXT("New Player Index"), Model.Players[2].PlayerIndex, 2);
	TestEqual(TEXT("Returned Player Index"), NewPlayerIndex, 2);
	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FAddPlayerAddsPlayerCardPilesTest, "CardGame.PlayerService.AddPlayerAddsPlayerCardPiles", EAutomationTestFlags::EditorContext | EAutomationTestFlags::ProductFilter)

bool FAddPlayerAddsPlayerCardPilesTest::RunTest(const FString& Parameters)
{
	// ARRANGE
	FCardGameModel Model;

	UCardGameCardPile* TestCardPile0 = NewObject<UCardGameCardPile>();
	UCardGameCardPile* TestCardPile1 = NewObject<UCardGameCardPile>();
	
	TArray<UCardGameCardPile*> CardPileClasses;
	CardPileClasses.Add(TestCardPile0);
	CardPileClasses.Add(TestCardPile1);
	
	UCardGameConfiguration* Configuration = NewObject<UCardGameConfiguration>();
	Configuration->SetPlayerCardPileClasses(CardPileClasses);
	
	// ACT
	constexpr FCardGamePlayerService PlayerService;
	PlayerService.AddPlayer(Model, Configuration);
	
	// ASSERT
	TestEqual(TEXT("Num Players"), Model.Players.Num(), 1);
	TestEqual(TEXT("Num Player Card Piles"), Model.Players[0].PlayerCardPiles.Num(), 2);
	TestEqual(TEXT("Player Card Pile 0"), Model.Players[0].PlayerCardPiles[0].CardPileClass, TestCardPile0);
	TestEqual(TEXT("Player Card Pile 1"), Model.Players[0].PlayerCardPiles[1].CardPileClass, TestCardPile1);
	return true;
}

```

`Source/CardGame/Public/ICardGame.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"

class ICardGame : public IModuleInterface
{
public:

	/**
	 * Singleton-like access to this module's interface.  This is just for convenience!
	 * Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
	 *
	 * @return Returns singleton instance, loading the module on demand if needed
	 */
	static inline ICardGame& Get()
	{
		return FModuleManager::LoadModuleChecked< ICardGame >( "CardGame" );
	}

	/**
	 * Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
	 *
	 * @return True if the module is loaded and ready to use
	 */
	static inline bool IsAvailable()
	{
		return FModuleManager::Get().IsModuleLoaded( "CardGame" );
	}
};

```