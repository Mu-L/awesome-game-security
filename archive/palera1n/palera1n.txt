Project Path: arc_palera1n_palera1n_jphwtcuw

Source Tree:

```txt
arc_palera1n_palera1n_jphwtcuw
├── LICENSE
├── Makefile
├── README.md
├── assets
│   └── image-1.png
├── dep_root
│   └── .keep
├── docs
│   ├── Makefile
│   ├── mandoc.css
│   ├── p1ctl.8
│   └── palera1n.1
├── include
│   ├── ANSI-color-codes.h
│   ├── paleinfo.h
│   ├── palerain.h
│   ├── tui.h
│   └── xxd-embedded.h
├── packaging
│   ├── control
│   └── control.macosx
├── patches
│   ├── gpm
│   │   ├── 001_missing_V_option.patch
│   │   ├── 014_has_mouse_control.patch
│   │   ├── 031_max_consoles.patch
│   │   ├── 080_cross-compile.patch
│   │   ├── 092_fix-format-not-a-string-literal-and-no-format-arguments.patch
│   │   ├── 093_fix-typos.patch
│   │   ├── 094_gpm-1.20.7-glibc-2.26-1.patch
│   │   ├── 095_fix-compilation-with-gcc-10.patch
│   │   └── 096_fix-compilation-against-musl-libc.patch
│   └── mbedtls
│       └── 0001-Allow-empty-x509-cert-issuer.patch
└── src
    ├── Makefile
    ├── boyermoore_memmem.c
    ├── chkstk.S
    ├── credits.c
    ├── devhelper.c
    ├── dfuhelper.c
    ├── exec_checkra1n.c
    ├── fake_embedded.c
    ├── gen
    │   └── resources
    ├── lock_vars.c
    ├── log.c
    ├── main.c
    ├── obj
    │   └── gen
    ├── optparse.c
    ├── override_file.c
    ├── pongo_helper.c
    ├── resources
    │   └── .gitignore
    ├── tui_devhelper.c
    ├── tui_input.c
    ├── tui_main.c
    ├── tui_screen_enter_dfu.c
    ├── tui_screen_enter_recovery.c
    ├── tui_screen_jailbreak.c
    ├── tui_screen_main.c
    ├── tui_screen_options.c
    ├── usb.xml
    ├── usb_iokit.c
    └── usb_libusb.c

```

`LICENSE`:

```
Copyright 2023 palera1n team

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the 
"Software"), to deal in the Software without restriction, including 
without limitation the rights to use, copy, modify, merge, publish, 
distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject to 
the following conditions:

The above copyright notice and this permission notice shall be included 
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`Makefile`:

```
SRC = $(shell pwd)
DEP = $(SRC)/dep_root
STRIP = strip
CC ?= cc
CFLAGS += -isystem $(DEP)/include -I$(SRC)/include -I$(SRC) -D_XOPEN_SOURCE=500
CFLAGS += -Wall -Wextra -Wno-unused-parameter -DPALERAIN_VERSION=\"2.1\" -DHAVE_LIBIMOBILEDEVICE
CFLAGS += -Wno-unused-variable -I$(SRC)/src -std=c99 -pedantic-errors -D_C99_SOURCE -D_POSIX_C_SOURCE=200112L
LIBS += $(DEP)/lib/libimobiledevice-1.0.a $(DEP)/lib/libirecovery-1.0.a $(DEP)/lib/libusbmuxd-2.0.a
LIBS += $(DEP)/lib/libimobiledevice-glue-1.0.a $(DEP)/lib/libplist-2.0.a -pthread -lm
ifeq ($(TARGET_OS),)
TARGET_OS = $(shell uname -s)
UNAME = $(TARGET_OS)
else
UNAME = $(shell uname -s)
endif
ifeq ($(TARGET_OS),Darwin)
CFLAGS += -Wno-nullability-extension
ifeq (,$(findstring version-min=, $(CFLAGS)))
CFLAGS += -mmacosx-version-min=10.8
endif
LDFLAGS += -Wl,-dead_strip
LIBS += -framework CoreFoundation -framework IOKit
else
CFLAGS += -fdata-sections -ffunction-sections
LDFLAGS += -Wl,--gc-sections
endif
LIBS += $(DEP)/lib/libmbedtls.a $(DEP)/lib/libmbedcrypto.a $(DEP)/lib/libmbedx509.a $(DEP)/lib/libreadline.a

ifeq ($(TUI),1)
ifeq ($(TARGET_OS),Linux)
LIBS += $(DEP)/lib/libgpm.a
endif
endif

ifeq ($(DEV_BUILD),1)
CFLAGS += -O0 -g -DDEV_BUILD -fno-omit-frame-pointer
ifeq ($(ASAN),1)
BUILD_STYLE=ASAN
CFLAGS += -fsanitize=address,undefined -fsanitize-address-use-after-return=runtime
else ifeq ($(TSAN),1)
BUILD_STYLE=TSAN
CFLAGS += -fsanitize=thread,undefined
else
BUILD_STYLE = DEVELOPMENT
endif
else
CFLAGS += -Os -g
BUILD_STYLE = RELEASE
endif
LIBS += -lc

ifeq ($(TARGET_OS),Linux)
ifneq ($(shell echo '$(BUILD_STYLE)' | grep -q '[A-Z]\+SAN' && echo 1),1)
LDFLAGS += -static -no-pie
endif
endif

ifneq ($(BAKERAIN_DEVELOPE_R),)
CFLAGS += -DBAKERAIN_DEVELOPE_R="\"$(BAKERAIN_DEVELOPE_R)\""
endif

BUILD_NUMBER := $(shell git rev-list --count HEAD)
BUILD_TAG := $(shell git describe --dirty --tags --abbrev=7)
BUILD_BRANCH := $(shell git rev-parse --abbrev-ref HEAD)
BUILD_COMMIT := $(shell git rev-parse HEAD)

CFLAGS += -DBUILD_STYLE="\"$(BUILD_STYLE)\"" -DBUILD_TAG="\"$(BUILD_TAG)\""
CFLAGS += -DBUILD_NUMBER="\"$(BUILD_NUMBER)\"" -DBUILD_BRANCH="\"$(BUILD_BRANCH)\""
CFLAGS += -DBUILD_COMMIT="\"$(BUILD_COMMIT)\""

CPATH =
LIBRARY_PATH =

export SRC DEP UNAME CC CFLAGS LDFLAGS LIBS SHELL TARGET_OS DEV_BUILD BUILD_DATE BUILD_TAG BUILD_WHOAMI BUILD_STYLE BUILD_NUMBER BUILD_BRANCH

all: palera1n

palera1n: download-deps
	$(MAKE) -C src

clean:
	$(MAKE) -C src clean
	$(MAKE) -C docs clean

download-deps:
	$(MAKE) -C src $(patsubst %, resources/%, checkra1n-macos checkra1n-linux-arm64 checkra1n-linux-armel checkra1n-linux-x86 checkra1n-linux-x86_64 checkra1n-kpf-pongo ramdisk.dmg binpack.dmg Pongo.bin)

docs:
	$(MAKE) -C docs

distclean: clean
	$(MAKE) -C src distclean

.PHONY: all palera1n clean docs distclean


```

`README.md`:

```md
# palera1n
[![GitHub Release](https://img.shields.io/github/v/release/palera1n/palera1n?include_prereleases)](https://github.com/palera1n/palera1n/releases)
[![GitHub Downloads (all assets, all releases)](https://img.shields.io/github/downloads/palera1n/palera1n/total)](https://github.com/palera1n/palera1n/releases)
[![GitHub License](https://img.shields.io/github/license/palera1n/palera1n?color=%23C96FAD)](https://github.com/palera1n/palera1n/blob/main/LICENSE)


Jailbreak for A8 through A11, T2 devices, on iOS/iPadOS/tvOS 15.0, bridgeOS 5.0 and higher.




| ![Screenshot of macOS Terminal.app](assets/image-1.png)	| 
|:--:												| 
| A screenshot of palera1n being used in a Terminal | 

## Device Support

<!--- Mobile --->

| iPhone(s)                 | iPad(s)                        		| iPod(s)   					| Apple TV(s) 					|
|-							|-										|-								|-								|
| iPhone 6s                 | iPad mini 4							| iPod Touch (7th generation)	| Apple TV HD                 	|
| iPhone 6s Plus            | iPad (5th generation)					|								| Apple TV 4K (1st generation)	|
| iPhone SE (2016)          | iPad (6th generation)					|								|								|
| iPhone 7                  | iPad (7th generation)					|								|								|
| iPhone 7 Plus             | iPad Pro (9.7")						|								|								|
| iPhone 8                  | iPad Pro (12.9") (1st generation)		|								|								|
| iPhone 8 Plus             | iPad Pro (10.5")						|								|								|
| iPhone X                  | iPad Pro (12.9") (2nd generation)		|								|								|
|                           | iPad Air 2		|								|								|


> Note that on `A11` (iPhone X, 8, 8 Plus), **you must disable your passcode while in the jailbroken state** (on iOS 16, you need to **reset your device** before proceeding with palera1n).

<!--- T2 --->
<details>
<summary>Apple T2 Device Support (click to expand)</summary>

| Apple T2              	|
|-							|
| Apple T2 iMac20,1         |
| Apple T2 iMac20,2         |
| 			              	|
| Apple T2 MacBookAir8,1    |
| Apple T2 MacBookAir8,2    |
| Apple T2 MacBookAir9,1    |
| 			              	|
| Apple T2 MacBookPro15,1   |
| Apple T2 MacBookPro15,2   |
| Apple T2 MacBookPro15,3   |
| Apple T2 MacBookPro15,4   |
| Apple T2 MacBookPro16,1   |
| Apple T2 MacBookPro16,2   |
| Apple T2 MacBookPro16,3   |
| Apple T2 MacBookPro16,4   |
| 			              	|
| Apple T2 iMacPro1,1       |
| Apple T2 Macmini8,1       |
| Apple T2 MacPro7,1        |
|			              	|
| iBridge2,11 (Unknown Mac) |
| iBridge2,13 (Unknown Mac) |



</details>


## Computer Requirements
1. **USB-A** cables are recommended to use, USB-C to may have issues with palera1n and getting into DFU mode.
> Due to USB-C cables having different accessory IDs, your device may not be able to be recognized when using USB-C due to not being able to assert to its USB voltage pin.

2. **Linux or macOS computer**
> AMD CPUs (not AMD Mobile) have an issue where it causes them to have a very low success rate with checkm8 exploit. It is not recommended that you use them with palera1n.

> USB-C port on Apple Silicon Macs *may* require manual unplugging and replugging of the lightning cable after checkm8 exploit. This problem may be solved by connecting via USB hub, though extensions can vary.

## Usage 
```
Usage: palera1n [-DEhpvVdsSLRnPI] [-e boot arguments] [-k Pongo image] [-o overlay file] [-r ramdisk file] [-K KPF file] [-i checkra1n file]

	--version				Print version
	--force-revert				Remove jailbreak
	-d, --demote				Demote
	-D, --dfuhelper				Exit after entering DFU
	-e, --boot-args <boot arguments>	XNU boot arguments
	-E, --enter-recovery			Enter recovery mode
	-h, --help				Show this help
	-i, --override-checkra1n <file>		Override checkra1n
	-k, --override-pongo <file>		Override Pongo image
	-K, --override-kpf <file>		Override kernel patchfinder
	-L, --jbinit-log-to-file		Make jbinit log to /cores/jbinit.log (can be read from sandbox while jailbroken)
	-n, --exit-recovery			Exit recovery mode
	-I, --device-info			Print info about the connected device
	-o, --override-overlay <file>		Override overlay
	-p, --pongo-shell			Boots to PongoOS shell
	-P, --pongo-full			Boots to a PongoOS shell with default images already uploaded
	-r, --override-ramdisk <file>		Override ramdisk
	-R, --reboot-device			Reboot connected device in normal mode
	-s, --safe-mode				Enter safe mode
	-S, --no-colors				Disable colors on the command line
	-v, --debug-logging			Enable debug logging
		  This option can be repeated for extra verbosity.
	-V, --verbose-boot			Verbose boot

Environmental variables:
	TMPDIR		temporary diretory (path the built-in checkra1n will be extracted to)
```

## Installing
Visit https://palera.in

## Disclaimers
We are **NOT** responsible for any data loss, or the result of a device being bricked. When using palera1n, the user should accept responsibility if anything happens to their device during the process.
- If your device is stuck in recovery, please run futurerestore `--exit-recovery`, or use `irecovery -n`, or `palera1n -n`.
- If you're unable to get out of recovery via these methods please restore with iTunes or Finder.
- palera1n **will not work** in VirtualBox, VMware or any virtual machine that doesn't support PCI passthrough.

## Troubleshooting
Make sure you're following the guides provided [here](https://palera.in), also when asking for support make sure you provide full details on your device, such as:
- iPhone/iPad/iPod/Apple TV
- iOS Version
- Passcode enabled?
- Verbose from palera1n (specifying `-Vv` within palera1n)
- Panic logs, if panicked then send latest `panic-full` log from your device.

Create an issue here: https://github.com/palera1n/palera1n/issues/new/choose

## Credits

[All credits for palera1n can be found here](https://palera.in/)

If proper credit isn't shown please message us or create an issue.

```

`docs/Makefile`:

```
PAGES = palera1n.1.html p1ctl.8.html

all: $(PAGES)

%.html: %
	mandoc -T html -O style=mandoc.css $< > $@

clean:
	rm -f $(PAGES)

```

`docs/mandoc.css`:

```css
/* $OpenBSD: mandoc.css,v 1.35 2021/03/30 19:23:50 schwarze Exp $ */
/*
 * Standard style sheet for mandoc(1) -Thtml and man.cgi(8).
 *
 * Written by Ingo Schwarze <schwarze@openbsd.org>.
 * I place this file into the public domain.
 * Permission to use, copy, modify, and distribute it for any purpose
 * with or without fee is hereby granted, without any conditions.
 */

/* Global defaults. */

html {
		--bg: #FFFFFF;
		--fg: #000000; }
body {		background: var(--bg);
		color: var(--fg);
		font-family: monospace,Helvetica,Arial,sans-serif;
		max-width: 80ch;
		margin: 1em auto;
		padding: 0 1ch;
	}
h1 {		font-size: 110%; }
table {		margin-top: 0em;
		margin-bottom: 0em;
		border-collapse: collapse; }
/* Some browsers set border-color in a browser style for tbody,
 * but not for table, resulting in inconsistent border styling. */
tbody {		border-color: inherit; }
tr {		border-color: inherit; }
td {		vertical-align: top;
		padding-left: 0.2em;
		padding-right: 0.2em;
		border-color: inherit; }
ul, ol, dl {	margin-top: 0em;
		margin-bottom: 0em; }
li, dt {	margin-top: 1em; }
pre {		font-family: inherit; }

.permalink {	border-bottom: thin dotted;
		color: inherit;
		font: inherit;
		text-decoration: inherit; }
* {		clear: both }

/* Search form and search results. */

form {
	position: sticky;
	top: 0px;
	background-color: var(--bg);
	z-index: 1;
}

fieldset {	border: thin solid silver;
		border-radius: 0.3em;
		text-align: center; }
input[name=expr] {
		width: 25%; }

table.results {	margin-top: 1em;
		margin-left: 2em;
		font-size: smaller; }

/* Header and footer lines. */

table.head {	width: 100%;
		border-bottom: 1px dotted #808080;
		margin-bottom: 1em;
		font-size: smaller;
		overflow-wrap: anywhere; }
td.head-vol {	text-align: center; }
td.head-rtitle {
		text-align: right; }

table.foot {	width: 100%;
		border-top: 1px dotted #808080;
		margin-top: 1em;
		font-size: smaller;
		overflow-wrap: anywhere; }
td.foot-os {	text-align: right; }

table.Nm {
	overflow-wrap:anywhere;
}

/* Sections and paragraphs. */

.manual-text {
		margin-left: 3.8em; }
h1.Sh {		margin-top: 1.2em;
		margin-bottom: 0.6em;
		margin-left: -3.2em; }
h2.Ss {		margin-top: 1.2em;
		margin-bottom: 0.6em;
		margin-left: -1.2em;
		font-size: 105%; }
.Pp {		margin: 0.6em 0em; }

/* Displays and lists. */

.Bd-indent {	margin-left: 3.8em; }

.Bl-bullet {	list-style-type: disc;
		padding-left: 1em; }
.Bl-dash {	list-style-type: none;
		padding-left: 0em; }
.Bl-dash > li:before {
		content: "\2014  "; }
.Bl-item {	list-style-type: none;
		padding-left: 0em; }
.Bl-compact > li {
		margin-top: 0em; }

.Bl-enum {	padding-left: 2em; }
.Bl-compact > li {
		margin-top: 0em; }

.Bl-diag > dt {
		font-style: normal;
		font-weight: bold; }
.Bl-diag > dd {
		margin-left: 0em; }
.Bl-hang > dd {
		margin-left: 5.5em; }
.Bl-inset > dd {
		margin-left: 0em; }
.Bl-ohang > dd {
		margin-left: 0em; }
.Bl-tag {	margin-top: 0.6em;
		margin-left: 5.5em; }
.Bl-tag > dt {
		float: left;
		margin-top: 0em;
		margin-left: -5.5em;
		padding-right: 0.5em;
		vertical-align: top; }
.Bl-tag > dd {
		clear: right;
		column-count: 1;  /* Force block formatting context. */
		width: 100%;
		margin-top: 0em;
		margin-left: 0em;
		margin-bottom: 0.6em;
		vertical-align: top; }
.Bl-compact {	margin-top: 0em; }
.Bl-compact > dd {
		margin-bottom: 0em; }
.Bl-compact > dt {
		margin-top: 0em; }

.Bl-column > tbody > tr > td {
		margin-top: 1em; }
.Bl-compact > tbody > tr > td {
		margin-top: 0em; }

.Rs {		font-style: normal;
		font-weight: normal; }
.RsB {		font-style: italic;
		font-weight: normal; }
.RsI {		font-style: italic;
		font-weight: normal; }
.RsJ {		font-style: italic;
		font-weight: normal; }
.RsT {		text-decoration: underline; }

.tbl td {	vertical-align: middle; }

.HP {		margin-left: 3.8em;
		text-indent: -3.8em; }

/* Semantic markup for command line utilities. */

code.Nm {	font-style: normal;
		font-weight: bold;
		font-family: inherit;
		overflow-wrap: normal; }
.Fl {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Cm {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ar {		font-style: italic;
		font-weight: normal; }
.Op {		display: inline; }
.Ic {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ev {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }
.Pa {		font-style: italic;
		font-weight: normal; }

/* Semantic markup for function libraries. */

code.In {	font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Fd {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ft {		font-style: italic;
		font-weight: normal; }
.Fn {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Fa {		font-style: italic;
		font-weight: normal; }
.Vt {		font-style: italic;
		font-weight: normal; }
.Va {		font-style: italic;
		font-weight: normal; }
.Dv {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }
.Er {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }

/* Various semantic markup. */

.Cd {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ad {		font-style: italic;
		font-weight: normal; }
.Ms {		font-style: normal;
		font-weight: bold; }

/* Physical markup. */

.Bf {		display: inline; }
.No {		font-style: normal;
		font-weight: normal; }
.Em {		font-style: italic;
		font-weight: normal; }
.Sy {		font-style: normal;
		font-weight: bold; }
.Li {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }

/* Overrides to avoid excessive margins on small devices. */

@media (max-width: 37.5em) {
.manual-text {
		margin-left: 0.5em; }
h1.Sh, h2.Ss {	margin-left: 0em; }
.Bd-indent {	margin-left: 2em; }
.Bl-hang > dd {
		margin-left: 2em; }
.Bl-tag {	margin-left: 2em; }
.Bl-tag > dt {
		margin-left: -2em; }
.HP {		margin-left: 2em;
		text-indent: -2em; }
}

/* Overrides for a dark color scheme for accessibility. */

@media (prefers-color-scheme: dark) {
html {		--bg: #000000;
		--fg: #FFFFFF; }
:link {		color: #BAD7FF; }
:visited {	color: #BAD7FF; }
}


```

`docs/p1ctl.8`:

```8
.\"-
.\" Copyright (c.Xc 2024 Nick Chan
.\" SPDX-License-Identifier: MIT
.\"
.Dd "6 April 2024"
.Dt p1ctl 8
.Sh NAME
.Nm p1ctl
.Nd command-line access to palera1n loader
.Sh SYNOPSIS
.Nm
.Ar subcommand
.Op subcommand options
.Op subcommand arguments
.Sh DESCRIPTION
.Nm
provide a command-line interface to the graphical palera1n loader.
.Pp
.Nm
interfaces with the palera1n daemon as well as palera1n's launchd hook.

.Sh SUBCOMMANDS
.Bl -tag -width -indent
.It Xo Ar bootstrap Op Fl s
.Op Fl S Ar password
.Ar bootstrap-file
.Xc
Deploy a bootstrap from a zstd compressed tarball. With no additional options specified,
a new password for the mobile user will be prompted for. The bootstrap you are deploying
must match the jailbreak type (rootful or rootless) you are using.
.Bl -tag -width -indent
.It Fl s
Do not prompt for the password and do not set the mobile password.
.It Fl S Ar password
Do not prompt and set the mobile password to the password specified.
.El
.Pp
.Em NOTE:
Unlike the graphical palera1n loader, this command only deploys the bootstrap itself,
it does not add additional repositories nor install additional packages.
.It Xo Ar exitsafe
.Xc
Exit
.Nm palera1n
safe mode, and trigger a userspace reboot. This command will succeed
even if the device is not currently in safe mode. In this case, a userspace reboot
is still triggered.
.Pp
.Em NOTE:
Many tweak injection packages also provide their own safe mode, p1ctl does not
recognize and cannot control those safe modes.
.It Xo Ar help Op Ar subcommand
.Xc
Prints help text. If
.Ar subcommand
is specified, print help about the subcommand.
.It Xo Ar kbase
.Xc
Print a hexadecimal representation of the kernel base.
.It Xo Ar kslide
.Xc
Print a hexadecimal representation of the kernel slide.
.It Xo Ar palera1n_flags
.Xc
Print a representation of the palera1n flags, which corresponds to the options passed
to
.Xr palera1n 1
as well as hints to the palera1n userspace stack set by
.Nm PongoOS
\[char46]
By default, a hexadecimal representation of the flags will be printed.
.Bl -tag -width -indent
.It Fl d
Read the flags from the ramdisk block device instead of getting them by interfacing with palera1n daemon.
.It Fl s
Print a string representation of the flags. Each line will contain one flag, and the strings always start
with palerain_option_, and unknown flags are represented as palerain_option_undefined.
.El
.It Xo Ar reboot-userspace
.Xc
Unmount /Developer if mounted and then reboot the userspace.
This command exists because the /Developer mount will be broken
after a plain userspace reboot, which breaks debugging in Xcode.
.Nm palera1n
also hooks the
.Xr reboot3 3
call so that rebooting userspace using
.Xr launchctl 1
does not break the /Developer mount.
.It Xo Ar reload
.Xc
Causes the
.Nm palera1n
launchd hook to re-probe the environment and update its internal state.
This will affect the internal environmental variables passed onto new processes,
and is typically used after bootstrapping or reverting installs.
.It Xo Ar revert-install
.Xc
Remove jailbreak files from the device. This command is not supported on rootful with fakefs. On rootful with realfs, the device will reboot after issuing this command.
.Pp
To remove jailbreak files on rootful with fakefs, use
.Xr palera1n 1
on your computer with the
.Fl -force-revert
.Fl f
options instead.
.El
.Sh SEE ALSO
.Xr palera1n 1

```

`docs/palera1n.1`:

```1
.\"-
.\" Copyright (c) 2024 Nick Chan
.\" SPDX-License-Identifier: MIT
.\"
.Dd "23 December 2024"
.Dt palera1n 1
.Sh NAME
.Nm palera1n
.Nd arm64 iOS/iPadOS/tvOS 15.0-26.0, bridgeOS 5.0-10.0 jailbreaking tool
.Sh SYNOPSIS
.Nm
.Op Fl cCdDEfhIlLnpRsSTvV
.Op Fl e Ar Boot arguments
.Op Fl k Ar Pongo image
.Op Fl o Ar overlay file
.Op Fl r Ar ramdisk file
.Op Fl K Ar KPF file
.Op Fl i Ar checkra1n file
.Op Fl -version
.Op Fl -force-revert
.Sh DESCRIPTION
.Nm
jailbreaks an arm64 (arm64e excluded) iOS/iPadOS/tvOS 15.0-26.0, bridgeOS 5.0-10.0 device,
utilizing the
.Em checkm8
bootROM exploit.
.Pp
.Nm
provides rootful and rootless jailbreak modes.
On iOS/iPadOS 15.0 and later and on tvOS 18.2 or later,
.Nm
is able to jailbreak the device in fakefs-rootful mode, where /
is writable, as well as rootless mode, where / cannot be written to.
On tvOS and bridgeOS,
only rootful is supported. On versions where fakefs-rootful is not
applicable, palera1n modifies the actual root filesystem instead
of making a fakefs.
.Pp
Due to the nature of the
.Em checkm8
exploit,
.Nm
is semi-tethered. That is, you must run the
.Nm
tool after the device reboot in order to enter the jailbroken state.
However, it is not required for the device to boot.
.Pp
On A11 devices, that is, iPhone 8, iPhone 8 Plus and iPhone X, the passcode cannot
be used.
.Pp
On iOS 15, the passcode must be off while jailbroken.
.Pp
On iOS 16, the passcode must be off since restore, and
.Sy Reset All Contents and Settings
from settings app counts as a restore.
A backup may be used in this case.
.Pp
In the remainder of this document, the term "iOS" and "iPadOS" will be used interchangably
as the difference is negligible as far as the jailbreak is concerened.
.Pp
.Sh SUPPORTED DEVICES
As described above, arm64 iOS 15.0-18.0 devices are supported, here is an explicit
list of supported devicecs:

.Bl -tag -compact
.It iPhone 6s
.It iPhone 6s Plus
.It iPhone SE (2016)
.It iPhone 7
.It iPhone 7 Plus
.It iPhone 8
.It iPhone 8 Plus
.It iPhone X
.El

.Bl -tag -compact
.It iPad mini 4
.It iPad Air 2
.It iPad (5th generation)
.It iPad (6th generation)
.It iPad (7th generation)
.It iPad Pro (9.7")
.It iPad Pro (12.9") (1st generation)
.It iPad Pro (10.5")
.It iPad Pro (12.9") (2nd generation)
.El

.Bl -tag -compact
.It iPod Touch (7th generation)
.El

.Bl -tag -compact
.It Apple TV HD
.It Apple TV 4K (1st generation)
.El

.Bl -tag -compact
.It Apple T2 iMacPro1,1
.It Apple T2 MacBookPro15,1
.It Apple T2 MacBookPro15,2
.It Apple T2 Macmini8,1
.It Apple T2 MacPro7,1
.It Apple T2 MacBookPro15,3
.It Apple T2 MacBookAir8,1
.It Apple T2 MacBookPro15,4
.It Apple T2 MacBookAir8,2
.It Apple T2 MacBookPro16,1
.It Apple T2 MacBookAir9,1
.It Apple T2 MacBookPro16,2
.It Apple T2 iMac20,1
.It Apple T2 iMac20,2
.It Apple T2 MacBookPro16,3
.It Apple T2 MacBookPro16,4
.El

Support for the A8 HomePod on Darwin 21 and above could be added,
but it is currently unsupported.

arm64e devices will NEVER be supported.

.Sh OPTIONS
.Bl -tag -width -indent
.It Fl -version
Prints the program version and exit.
.It Fl -force-revert
Remove the jailbreak while keeping user data. Some jailbreak files may remain
after running this command. Additionally, jailbreak apps may remain on the
home screen on for a while even when the files are deleted as the icon cache
still has their icons. When used with
.Fl f , -fakefs ,
this will actually boot the device in rootless mode then delete the jailbreak
files. As a result, using the loader app to install the jailbreak environment
is not supported when this option is used together with
.Fl f , -fakefs
\[char46]
.It Fl B , -setup-fakefs-partial
Like
.Fl c , -setup-fakefs
but the size of the created fakefs is smaller at the expense of having unwritable
parts in rarely-written paths. When jailbreaking 16 GB devices, this option must be used
when setting up fakefs for rootful, as they do not have enough storage for full fakefs.
This flag is supported on iOS/iPadOS 15.0 or later and tvOS 18.2 or later, as they
require fakefs for rootful.
.It Fl c , -setup-fakefs
When used with
.Fl f , -fakefs ,
creates the new APFS volume required for rootful. Will fail if one already exists.
This flag is supported on iOS/iPadOS 15.0 or later and tvOS 18.2 or later, as they
require fakefs for rootful.
.It Fl C , -clean-fakefs
This option is not currently supported and is a no-operation in this version of
.Nm
\[char46]
.It Fl d , -demote
Set the effective production fuse to 0, so as to enable hardware debugging features.
.It Fl D , -dfuhelper
Execute the DFU helper to guide the user into putting the device into DFU mode
then exit.
.It Fl e , -boot-args Ar boot arguments
Specify custom XNU kernel command line. Additionally, the
.Em wdt=-1
argument is used during fakefs setup.
.It Fl E , -enter-recovery
Exit after entering recovery mode.
.It Fl f , -fakefs
Proceed in rootful mode. Despite its name, this applies to both full, partial fakefs, as well as realfs, and it still applies even when trying to force revert.
.It Fl h , -help
Prints help text.
.It Fl i , -checkra1n-file Ar checkra1n file
Specify the path to a custom checkra1n file.
.It Fl k , -override-pongo Ar pongo file
Override PongoOS image. The raw image, named
.Em Pongo.bin
when built, should be used. PongoOS 2.6.0 or later is required.
.It Fl K , -override-kpf Ar KPF file
Override the kernel patchfinder PongoOS module. The module is required to support setting
root filesystem in paleinfo with
.Em rootfs
command. If in doubt, use
.Sy https://github.com/palera1n/PongoOS
iOS15 branch or your own fork of it.
.It Fl l , -rootless
Proceed in rootless mode. This option is only supported on iOS/iPadOS.
.It Fl n , -exit-recovery
Exit recovery mode and exit.
.It Fl o , -override-overlay Ar overlay file
Specify the path to a custom overlay file, which is then mounted onto /cores/binpack
during boot, if the default ramdisk is used. The default ramdisk expects the overlay
to contain a folder named
.Em Applications
at the root of it, as well as a dmg named
.Em loader.dmg
at the root of it. Otherwise, the device will not boot. It is also expected that it
contains a shell, a ssh server, and various command line utilities.
.It Fl p , -pongo-shell
Exit after booting into a clean PongoOS shell
.It Fl P , -pongo-full
Like
.Fl p , -pongo-shell
but default images and options have been uploaded and applied respectively.
.It Fl r , -override-ramdisk Ar ramdisk file
Override the ramdisk. At a very minimum, it should contain
.Em /cores/ploosh
as well as a fake dyld
.Em /usr/lib/dyld
where the logic is expected to be in.
.It Fl R , -reboot-device
Reboot device in normal mode and exit.
.It Fl s , -safe-mode
Enter safe mode. An alert will be displayed on iOS/iPadOS/tvOS. Jailbreak daemons nor early boot executable files
specified (see
.Sy FILES
section below) will be executed. The loader app and the built in SSH server can still be used,
as well as any jailbreak-specific apps you have installed.
.It Fl S , -no-colors
Disable colors on the command line. External programs like checkra1n clones may still output colors.
.It Fl T , -telnetd
Enable the TELNET daemon on port 46, all interfaces. Please note that there is no authentication and is therefore insecure.
.It Fl v , -debug-logging
Enable debug logging. The option may be repeated for extra verbosity.
.It Fl V , -verbose-boot
Boots the device in verbose mode, allowing boot logs to be seen.
.It Fl I , -device-info
Prints info about device and exits.
.El
.Sh ENVIRONMENTAL VARIABLES
.Bl -tag -width -indent
.It Ev TMPDIR
This environmental variable should contain the a directory for temporary
files. Without the
.Fl i , -override-checkra1n
option, files must be executable from it as the built-in checkra1n file
is extracted and executed here. When not set, /tmp is used.
.El
.Sh EXAMPLES
To (re-)jailbreak in rootless mode:
.Pp
.Dl "palera1n -l"
.Pp
To setup fakefs for rootful mode:
.Pp
.Dl "palera1n -fc"
.Pp
After the device has rebooted into recovery mode, follow the following example.
.Pp
To re-jailbreak in rootful mode:
.Pp
.Dl "palera1n -f"
.Pp
To remove the jailbreak in rootful mode:
.Pp
.Dl "palera1n --force-revert -f"
.Pp
To remove the jailbreak in rootless mode:
.Pp
.Dl "palera1n --force-revert"
.Pp
To verbose boot in rootful mode:
.Pp
.Dl "palera1n -Vf"
.Pp
To create a partial fakefs with bind mounts:
.Pp
.Dl "palera1n -Bf"
.Pp
To exit recovery mode:
.Pp
.Dl "palera1n -n"
.Pp
.Sh CAVEATS
.Pp
.Em -v
is not a real XNU boot argument. It is interpreted by iBoot. However, since XNU
boot arguments are set in PongoOS, which is ran after iBoot has ran, it does nothing.
To verbose boot, use the
.Fl V , -verbose-boot
option when jailbreaking.
.Pp
Fakefs takes up around 5-10 GB of storage, and takes up to 10 minutes to setup.
.Pp
iOS 15.0 requires DER entitlements, and iOS 15.1 requires hash agility in code signatures.
As a result, binaries with the old code signature format need to be resigned with a recent
version of the Procursus fork of
.Xr ldid 1
before they can be ran on a device jailbroken with
.Nm
\[char46]
.Pp
When using rootful mode, the
.Fl f , -fakefs
flag must be specified at all times. It does not matter whether you want to create fakefs,
create partial fakefs, rejailbreak or remove jailbreak.
.Pp
Due to a stock bug, using the
.Fl V , -verbose-boot
option might cause some versions for tvOS to crash and not boot.
.Pp
Offical Apple USB-C cables as well as some other USB-C cables cannot be used to enter DFU mode.
USB-A cable with male USB-C to female USB-A adapter works fine.
.Sh POST INSTALLATION (iOS/iPadOS)
The palera1n loader app will take up to 1 minute to appear on the homescreen after the
device has booted. If it does not appear, you can try using the shortcut:
.Pp
.Lk https://www.icloud.com/shortcuts/8cd5f489c8854ee0ab9ee38f2e62f87d
.Pp
to open it. After opening the loader app, select a package manager to install.
This will also bootstrap your device.
.Pp
A built-in SSH server runs on port 44 on loopback interfaces.
.Sh POST INSTALLATION (tvOS)
.Pp
The palera1n loader app will appear on homescreen. Open the loader and select a package manager to install.
This will also bootstrap your device.
.Pp
A built-in SSH server runs on port 44 on all interfaces.
.Sh POST INSTALLATION (bridgeOS)
.Pp
A built-in SSH server runs on port 44 on all interfaces.
.Pp
Bootstrapping is currently not supported on this device.
.Sh FILES
During the jailbreak process, a temporary filesystem is mounted on /cores as a place
to stash jailbreak files needed during the boot process. No files are ever written
onto the actual disk if you do not use the SSH server to write files or using the
loader app to install additional jailbreak files.

.Bl -tag -width "/var/jb/Library/LaunchDaemons"
.It Pa /cores
The location of the temporary filesystem where jailbreak files are stashed during boot.
.It Pa /Library/LaunchDaemons
The directory where jailbreak-specific
.Xr launchd.plist 5
property list files should be placed on rootful.
.It Pa /var/jb/Library/LaunchDaemons
The directory where jailbreak-specific
.Xr launchd.plist 5
property list files should be placed on rootless.
.It Pa /etc/rc.d
The directory where executable files that needs to be executed during boot, before
daemons are launched, are placed on rootful. They are executed after all filesystems
has been mounted.
.It Pa /var/jb/etc/rc.d
The directory where executable files that needs to be executed during boot, before
daemons are launched, are placed on rootless. They are executed after all filesystems
has been mounted.
.El
.Sh BUGS
.Nm
may crash if the machine it is running on has non-compliant USB devices plugged in.
.Pp
.Nm
will fail to initialize on Linux when there are no USB devices plugged in.
Usually this is not a problem on PCs since the built-in root hubs are also
USB devices. However, on platforms such as Apple Silicon Macs in Linux, since
there are no built-in USB hubs, at least one USB device needs to be manually
plugged in for palera1n to be initialized.
.Pp
The exploit may also work less reliably on some hosts, like AMD desktops, or some MediaTek devices.
.Pp
The built-in SSH server might be not accessible with password after bootstrapping rootful,
since the bootstrap uses a custom crypt() function that is not supported
by the built-in SSH server.
.Pp
There are no DFU instructions for iBridge T2 as there are no known ways to connect to the T2's USB
interface when macOS has been booted.
.Sh DEPRECATED AND REMOVED FUNCTIONALITY
There was an option in
.Nm
to force create the fakefs even when one already exists (which would overwrite
the existing fakefs), by setting the palerain_option_setup_rootful_forced flag
in palera1n flags. This option was removed because using
.Fl -force-revert
and
.Fl c
at the same time has exactly the same effect.
.Pp
The hook that enabled
.Sy launchctl runstats
has been removed, since it leaks memory in launchd.
.Sh SEE ALSO
.Xr launchd 8
.Xr launchd.plist 5
.Xr ldid 1
.Xr p1ctl 8
.Sh HISTORY
The
.Nm
jailbreak was first written by Nebula and Mineek on September 26, 2022, as a shell
script. Tweak support with DEVELOPMENT kernels are added on October 2, 2022. RELEASE
kernel support is added on November 14, 2022. iOS 16 Support is added on
December 13, 2022. Later, the first attempt to rewrite palera1n into C begins on January
01 2023. The
.Nm
utility described here is the second attempt, which first started on January 16, 2023,
using checkra1n 1337 and a custom KPF.
Something happened on August 15, 2023.

```

`include/ANSI-color-codes.h`:

```h
/*
 * This is free and unencumbered software released into the public domain.
 *
 * For more information, please refer to <https://unlicense.org>
 */

#ifndef ANSI_COLOR_CODES_H
#define ANSI_COLOR_CODES_H

//Regular text
#define BLK "\033[0;30m"
#define RED "\033[0;31m"
#define GRN "\033[0;32m"
#define YEL "\033[0;33m"
#define BLU "\033[0;34m"
#define MAG "\033[0;35m"
#define CYN "\033[0;36m"
#define WHT "\033[0;37m"

//Regular bold text
#define BBLK "\033[1;30m"
#define BRED "\033[1;31m"
#define BGRN "\033[1;32m"
#define BYEL "\033[1;33m"
#define BBLU "\033[1;34m"
#define BMAG "\033[1;35m"
#define BCYN "\033[1;36m"
#define BWHT "\033[1;37m"

//Regular underline text
#define UBLK "\033[4;30m"
#define URED "\033[4;31m"
#define UGRN "\033[4;32m"
#define UYEL "\033[4;33m"
#define UBLU "\033[4;34m"
#define UMAG "\033[4;35m"
#define UCYN "\033[4;36m"
#define UWHT "\033[4;37m"

//Regular background
#define BLKB "\033[40m"
#define REDB "\033[41m"
#define GRNB "\033[42m"
#define YELB "\033[43m"
#define BLUB "\033[44m"
#define MAGB "\033[45m"
#define CYNB "\033[46m"
#define WHTB "\033[47m"

//High intensty background 
#define BLKHB "\033[0;100m"
#define REDHB "\033[0;101m"
#define GRNHB "\033[0;102m"
#define YELHB "\033[0;103m"
#define BLUHB "\033[0;104m"
#define MAGHB "\033[0;105m"
#define CYNHB "\033[0;106m"
#define WHTHB "\033[0;107m"

//High intensty text
#define HBLK "\033[0;90m"
#define HRED "\033[0;91m"
#define HGRN "\033[0;92m"
#define HYEL "\033[0;93m"
#define HBLU "\033[0;94m"
#define HMAG "\033[0;95m"
#define HCYN "\033[0;96m"
#define HWHT "\033[0;97m"

//Bold high intensity text
#define BHBLK "\033[1;90m"
#define BHRED "\033[1;91m"
#define BHGRN "\033[1;92m"
#define BHYEL "\033[1;93m"
#define BHBLU "\033[1;94m"
#define BHMAG "\033[1;95m"
#define BHCYN "\033[1;96m"
#define BHWHT "\033[1;97m"

//Reset
#define reset "\033[0m"
#define CRESET "\033[0m"
#define COLOR_RESET "\033[0m"

#endif

```

`include/paleinfo.h`:

```h
/*
 * jbinit - https://github.com/palera1n/jbinit
 *
 * This file is part of jbinit
 * 
 * SPDX-License-Identifier: MIT
 */

#ifndef PALEINFO_H
#define PALEINFO_H

#include <stdint.h>

#define PALEINFO_VERSION 2U
typedef uint64_t palerain_option_t;

// unified palera1n options
#define palerain_option_rootful              (UINT64_C(1) << 0) /* rootful jailbreak */
#define palerain_option_rootless             (UINT64_C(1) << 1) /* rootless jailbreak */
#define palerain_option_setup_rootful        (UINT64_C(1) << 2) /* create fakefs */
// (UINT64_C(1) << 3) /* Deprecated and removed */
#define palerain_option_setup_partial_root   (UINT64_C(1) << 4) /* fakefs creating should be partial */
#define palerain_option_checkrain_is_clone   (UINT64_C(1) << 5) /* supplied checkra1n is checkra1n clone */
#define palerain_option_rootless_livefs      (UINT64_C(1) << 6) /* mount root livefs on rootless */
#define palerain_option_ssv                  (UINT64_C(1) << 7) /* has signed system volume */
// (UINT64_C(1) << 8) /* reserved */
#define palerain_option_clean_fakefs         (UINT64_C(1) << 9) /* clean fakefs, but does not delete it */
#define palerain_option_tui                  (UINT64_C(1) << 10) /* terminal user interface */
// #define palerain_option_gui               (UINT64_C(1) << 11) /* graphical user interface*/
#define palerain_option_dfuhelper_only       (UINT64_C(1) << 12) /* dfuhelper only */
#define palerain_option_pongo_exit           (UINT64_C(1) << 13) /* boot to clean pongo shell */
#define palerain_option_demote               (UINT64_C(1) << 14) /* Demote effective production fuse status */
#define palerain_option_pongo_full           (UINT64_C(1) << 15) /* Boot to pongo with default images and options */
#define palerain_option_palerain_version     (UINT64_C(1) << 16) /* Print version */
#define palerain_option_exit_recovery        (UINT64_C(1) << 17) /* Exit recovery mode */
#define palerain_option_reboot_device        (UINT64_C(1) << 18) /* Reboot device in normal mode */
#define palerain_option_enter_recovery       (UINT64_C(1) << 19) /* Enter recovery mode */
#define palerain_option_device_info          (UINT64_C(1) << 20) /* Print device info */
#define palerain_option_no_colors            (UINT64_C(1) << 21) /* no colors */
#define palerain_option_bind_mount           (UINT64_C(1) << 22) /* bind mounts should be used (always true iOS 15+)*/
#define palerain_option_overlay              (UINT64_C(1) << 23) /* there is an overlay (should always be true) */
#define palerain_option_force_revert         (UINT64_C(1) << 24) /* Unjailbreak */
#define palerain_option_safemode             (UINT64_C(1) << 25) /* Enter safe mode */
#define palerain_option_verbose_boot         (UINT64_C(1) << 26) /* verbose boot */
// #define palerain_option_sf_ssh            (UINT64_C(1) << 27) /* safe mode with bootstrap ssh */
// #define palerain_option_sf_launchdaemons  (UINT64_C(1) << 28) /* safe mode with launchdaemons */
// #define palerain_option_emerg_mode        (UINT64_C(1) << 29) /* emergency mode (early boot usb shell) */
#define palerain_option_jbinit_log_to_file   (UINT64_C(1) << 30) /* deprecated (kept for compatibility) */
#define palerain_option_cli                  (UINT64_C(1) << 31) /* CLI mode */
#define palerain_option_telnetd              (UINT64_C(1) << 32) /* Enable TELNET daemon */

#define palerain_option_flower_chain         (UINT64_C(1) << 61) /* Flower chain */
#define palerain_option_test1                (UINT64_C(1) << 62) /* Developer test option 1 */
#define palerain_option_test2                (UINT64_C(1) << 63) /* Developer test option 2 */

#define PALEINFO_MAGIC 'PLSH'

#pragma clang diagnostic push
#pragma clang diagnostic warning "-Wpadded"

/* paleinfo version 2, appended to ramdisk */
struct paleinfo {
    uint32_t magic; /* 'PLSH' */
    uint32_t version; /* 2 */
    uint64_t kbase; /* kernel base */
    uint64_t kslide; /* kernel slide */
    uint64_t flags; /* unified palera1n flags */
    char rootdev[0x10]; /* ex. disk0s1s8 */
};

#pragma clang diagnostic pop

#endif

```

`include/palerain.h`:

```h
#ifndef PALERAIN_H
#define PALERAIN_H

#if defined(__APPLE__)
#define NSIG	__DARWIN_NSIG
#endif

#include "xxd-embedded.h"
#include "paleinfo.h"
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <stdarg.h>
#include <usbmuxd.h>
#include <libirecovery.h>
#include <libimobiledevice/libimobiledevice.h>

#define LOG(loglevel, ...) p1_log(loglevel, __FILE__, __LINE__, __func__, __VA_ARGS__)
#define CLEAR() printf("\33[2K\r");
#define palerain_option_case(x) (512 + x)
#define palerain_option_version 129
#define CMD_LEN_MAX 512
#define OVERRIDE_MAGIC 0xd803b376

#define palerain_option_case_version      palerain_option_case(0)
#define palerain_option_case_force_revert palerain_option_case(1)
#define palerain_option_case_libcheckra1nhelper_path palerain_option_case(2)
#define palerain_option_case_cli		  palerain_option_case(3)


#ifdef USE_LIBUSB
#include <libusb-1.0/libusb.h>

#define USB_RET_SUCCESS         LIBUSB_SUCCESS
#define USB_RET_NOT_RESPONDING  LIBUSB_ERROR_OTHER
#define USB_RET_IO              LIBUSB_ERROR_IO
#define USB_RET_NO_DEVICE		LIBUSB_ERROR_NO_DEVICE
typedef int32_t usb_ret_t;
typedef libusb_device_handle *usb_device_handle_t;

typedef struct stuff
{
    pthread_t th;
    libusb_device *dev;
    usb_device_handle_t handle;
} stuff_t;
usb_ret_t USBBulkUpload(usb_device_handle_t handle, void *data, int len);
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpedantic"
#include <IOKit/IOKitLib.h>
#include <IOKit/usb/IOUSBLib.h>
#include <IOKit/IOCFPlugIn.h>
#pragma clang diagnostic pop

#define USB_RET_SUCCESS         KERN_SUCCESS
#define USB_RET_NOT_RESPONDING  kIOReturnNotResponding
#define USB_RET_IO              kIOReturnNotReady
#define USB_RET_NO_DEVICE       kIOReturnNoDevice

typedef IOReturn usb_ret_t;
typedef IOUSBInterfaceInterface245 **usb_device_handle_t;

typedef struct
{
    pthread_t th;
    volatile uint64_t regID;
    IOUSBDeviceInterface245 **dev;
    usb_device_handle_t handle;
} stuff_t;
usb_ret_t USBBulkUpload(usb_device_handle_t handle, void *data, uint32_t len);
#endif

#ifndef PALERAIN_VERSION
#define PALERAIN_VERSION "2.2.1"
#endif

#if defined(__APPLE__)
#include <mach-o/loader.h>
#include <mach-o/ldsyms.h>
#else
#define MH_MAGIC_64 0xfeedfacf
#define MH_CIGAM_64 0xcffaedfe
#define MH_KEXT_BUNDLE 0xb

typedef int32_t cpu_type_t;
typedef int32_t cpu_subtype_t;

#define CPU_ARCH_ABI64          0x01000000
#define CPU_TYPE_ARM            ((cpu_type_t) 12)
#define CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)

struct mach_header_64
{
	uint32_t magic;			  /* mach magic number identifier */
	cpu_type_t cputype;		  /* cpu specifier */
	cpu_subtype_t cpusubtype; /* machine specifier */
	uint32_t filetype;		  /* type of file */
	uint32_t ncmds;			  /* number of load commands */
	uint32_t sizeofcmds;	  /* the size of all the load commands */
	uint32_t flags;			  /* flags */
	uint32_t reserved;		  /* reserved */
};
#endif

typedef void *(*pthread_start_t)(void *);

// Keep in sync with Pongo
#define PONGO_USB_VENDOR    0x05ac
#define PONGO_USB_PRODUCT   0x4141
#define CMD_LEN_MAX         512
#define UPLOADSZ_MAX        (1024 * 1024 * 128)

typedef enum {
	LOG_FATAL = 0,
	LOG_ERROR = 1,
	LOG_WARNING = 2,
	LOG_INFO = 3,
	LOG_VERBOSE = 4,
	LOG_VERBOSE2 = 5,
	LOG_VERBOSE3 = 6,
	LOG_VERBOSE4 = 7,
	LOG_VERBOSE5 = 8,
} log_level_t;

typedef struct {
	uint64_t ecid;
	char* productType;
	char* productVersion;
	char* buildVersion;
	char* CPUArchitecture;
	const char* displayName;
} devinfo_t;

typedef struct {
	int mode;
	int cpid;
	char product_type[0x20];
	char display_name[0x20];
	char iboot_ver[0x20];
} recvinfo_t;

typedef struct {
	uint32_t magic; /* 0xd803b376*/
	unsigned char* ptr; /* pointer to the override file in memory */
	uint32_t len; /* length of override file */
	unsigned char* orig_ptr; /* pointer to the overriden file */
	uint32_t orig_len; /* length of the overriden file */
	int fd; /* file descriptor of the override file */
} override_file_t;

typedef unsigned char niarelap_file_t[];

extern unsigned int verbose;

extern char* pongo_path;
#ifdef TUI
extern bool tui_started;
#endif

extern uint64_t palerain_flags;
extern uint64_t* palerain_flags_p;

extern pthread_t dfuhelper_thread, pongo_thread;
extern int pongo_thr_running, dfuhelper_thr_running;

extern niarelap_file_t *kpf_to_upload_1, *ramdisk_to_upload_1, *overlay_to_upload_1;
extern niarelap_file_t **kpf_to_upload, **ramdisk_to_upload, **overlay_to_upload;
extern override_file_t override_ramdisk, override_kpf, override_overlay;

extern uint64_t palerain_flags;
extern pthread_mutex_t log_mutex;

extern pthread_mutex_t spin_mutex, found_pongo_mutex, ecid_dfu_wait_mutex;

extern int pongo_thr_running, dfuhelper_thr_running;
extern bool device_has_booted;
extern char xargs_cmd[0x270];
extern char palerain_flags_cmd[0x30];
extern char* ext_checkra1n;

void thr_cleanup(void* ptr);
void* dfuhelper(void* ptr);
int p1_log(log_level_t loglevel, const char *fname, int lineno, const char *fxname, const char* __restrict format, ...);
/* devhelper helpers */
void devinfo_free(devinfo_t *dev);
bool cpid_is_arm64(unsigned int cpid);
/* devhelper commands */
int subscribe_cmd(usbmuxd_event_cb_t device_event_cb, irecv_device_event_cb_t irecv_event_cb);
int unsubscribe_cmd(void);
int devinfo_cmd(devinfo_t *dev, const char *udid);
int enter_recovery_cmd(const char* udid);
int reboot_cmd(const char* udid);
int passstat_cmd(unsigned char* status, const char* udid);
int recvinfo_cmd(recvinfo_t* info, const uint64_t ecid);
int autoboot_cmd(const uint64_t ecid);
int exitrecv_cmd(const uint64_t ecid);

int exec_checkra1n(void);
int override_file(override_file_t *finfo, niarelap_file_t** orig, unsigned int *orig_len, char *filename);
void* pongo_helper(void* ptr);
const unsigned char *
boyermoore_horspool_memmem(const unsigned char* haystack, size_t hlen,
                           const unsigned char* needle,   size_t nlen);


usb_ret_t USBControlTransfer(usb_device_handle_t handle, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint32_t wLength, void *data, uint32_t *wLenDone);
const char *usb_strerror(usb_ret_t err);
int wait_for_pongo(void);
int tui(void);
int optparse(int argc, char* argv[]);

bool get_spin(void);
bool set_spin(bool val);
bool get_found_pongo(void);
void* pongo_helper(void* _);
bool set_found_pongo(bool val);
uint64_t get_ecid_wait_for_dfu(void);
uint64_t set_ecid_wait_for_dfu(uint64_t ecid);

void io_start(stuff_t *stuff);
void io_stop(stuff_t *stuff);

void print_credits(void);

#endif

```

`include/tui.h`:

```h
#ifndef TUI_H
#define TUI_H
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <inttypes.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <locale.h>
#include <unistd.h>
#include <paleinfo.h>
#include <pthread.h>
#include <semaphore.h>

#define WIDTH 76
#define HEIGHT 19

#define CHECKBOX_STATE(flags, opt) (flags & opt) != 0 ? '*' : ' '

#define STR_HELPER(x) #x
#define STR(x) STR_HELPER(x)

#define CLEAR_SCREEN printf("\033[2J")
#define RESETFONT printf("\x1b[0m")
#define PRINTAT(x, y, str) printf("\x1b[%d;%dH%s", y, x, str)
#define PRINTATT(x, y, str) PRINTAT(tui_x_offset + x, tui_y_offset + y, str)
#define PRINTATLEN(x, y, str, len) printf("\x1b[%d;%dH%." STR(len) "s", y, x, str)
#define PRINTATLENT(x, y, str, len) PRINTATLEN(tui_x_offset + x, tui_y_offset + y, str, len)
#define MOVETO(x, y) printf("\x1b[%d;%dH", y, x)
#define MOVETOT(x, y) MOVETO(tui_x_offset + x, tui_y_offset + y)
#define SETCOLOR(fg, bg) printf("\x1b[%d;%dm", fg, bg)
#define SETCOLORA(fg, bg, a) printf("\x1b[" STR(fg) ";" STR(bg) ";" STR(a) "m")
#define COLOR(fg, bg) "\x1b[" STR(fg) ";" STR(bg) "m"
#define FG_BLACK 30
#define FG_YELLOW 33
#define FG_BLUE 34
#define FG_WHITE 37
#define BG_BLACK 40
#define BG_YELLOW 43
#define BG_BLUE 44
#define BG_WHITE 47
#define NONE 0
#define BOLD 1
extern bool supports_bright_colors;
#define FG_BRIGHT_BLACK 90
#define FG_BRIGHT_WHITE 97
#define BG_BRIGHT_BLACK 100
#define BG_BRIGHT_WHITE 107
#define G1D4(set) printf("\x1b\x29%c", set)
#define DSGON putchar('\x0e'); G1D4('0')
#define DSGOFF putchar('\x0f'); G1D4('B')
#define MOUSEON printf("\x1b[?1003h")
#define MOUSEOFF printf("\x1b[?1003l")
#define CIVIS printf("\x1b[?25l")
#define CNORM printf("\x1b[?25h")
#define SMCUP printf("\x1b[?1049h")
#define RMCUP printf("\x1b[?1049l")
#define DRAWLINE(x, y, len) \
    MOVETO(x, y); \
    DSGON; \
    for (int i = 0; i < len; i++) { \
        putchar(0x71); \
    } \
    DSGOFF;
#define DRAWLINET(x, y, len) DRAWLINE(tui_x_offset + x, tui_y_offset + y, len)

typedef enum tui_screens {
    ERROR_SCREEN = -1,
    EXIT_SCREEN = 0,
    MAIN_SCREEN = 1,
    OPTIONS_SCREEN = 2,
    ENTER_DFU_SCREEN = 3,
    JAILBREAK_SCREEN = 4,
    ENTER_RECOVERY_SCREEN = 5
} tui_screen_t;

typedef struct bitfield_checkbox_info {
    uint64_t* flags_p;
    uint64_t opt;
} tui_bit_info_t;

tui_screen_t tui_screen_main(void);
void tui_screen_main_redraw(void);
tui_screen_t tui_screen_options(void);
void tui_screen_options_redraw(void);
tui_screen_t tui_screen_enter_recovery(void);
void tui_screen_enter_recovery_redraw(void);
tui_screen_t tui_screen_enter_dfu(void);
void tui_screen_enter_dfu_redraw(void);
tui_screen_t tui_screen_jailbreak(void);
void tui_screen_jailbreak_redraw(void);

int redraw_screen(void);

void tui_draw_rectangle(int x1, int y1, int x2, int y2);

#ifdef BUILD_TAG
#define TUI_VERSION BUILD_TAG
#else
#define TUI_VERSION "Unknown Version"
#endif

extern int tui_x_offset;
extern int tui_y_offset;

extern int tui_mouse_x;
extern int tui_mouse_y;

enum {
    TUI_INPUT_NONE,
    TUI_INPUT_LEFT,
    TUI_INPUT_RIGHT,
    TUI_INPUT_UP,
    TUI_INPUT_DOWN,
    TUI_INPUT_MOUSE_MOVE,
    TUI_INPUT_MOUSE_DOWN,
    TUI_INPUT_MOUSE_UP,
    TUI_INPUT_SELECT,
    TUI_INPUT_TAB,
    TUI_INPUT_TAB_BACK,
    TUI_INPUT_BACKSPACE,
    TUI_INPUT_ESCAPE,
};

enum {
    TUI_EVENT_INPUT,
    TUI_EVENT_CONNECTED_DEVICES_CHANGED,
    TUI_EVENT_JAILBREAK_STATUS_CHANGED
};

int tui_get_input(void);
void *tui_input_thread(void *arg);
int tui_get_event(void);
int tui_try_get_event(void);

extern int tui_last_event;
extern int tui_last_input;
extern sem_t *tui_event_semaphore;
extern char tui_last_key;

void tui_devhelper(void);

enum tui_device_mode {
    TUI_DEVICE_MODE_NORMAL,
    TUI_DEVICE_MODE_RECOVERY,
    TUI_DEVICE_MODE_DFU
};

struct tui_connected_device {
    uint64_t ecid;
    char udid[44];
    char version[0x20];
    bool arm64;
    enum tui_device_mode mode;
    char product_type[0x20];
	char display_name[0x20];
    unsigned int cpid;
    bool requires_passcode_disabled;
    bool passcode_state;
    struct tui_connected_device *next;
};

extern struct tui_connected_device *tui_connected_devices;

void tui_jailbreak(void);
extern bool tui_is_jailbreaking;
extern int tui_jailbreak_stage;
extern char *tui_jailbreak_status;

void tui_jailbreak_status_changed(void);

extern bool tui_is_restarting;
void tui_terminate(int sig);

extern bool tui_options_safe_mode;
extern bool tui_options_verbose_boot;
extern bool tui_options_force_revert;
extern bool tui_options_flower_chain;

extern char tui_options_boot_args[0x1e0 + 1];

#endif

```

`include/xxd-embedded.h`:

```h
#ifndef XXD_EMBEDDED_H
#define XXD_EMBEDDED_H

#if defined(__APPLE__)
#include <TargetConditionals.h>
#endif

#include <stdint.h>

extern uint8_t checkra1n[];
extern uint32_t checkra1n_len;

extern uint8_t checkra1n_kpf_pongo_lzma[];
extern uint32_t checkra1n_kpf_pongo_lzma_len;

extern uint8_t ramdisk_dmg_lzma[];
extern uint32_t ramdisk_dmg_lzma_len;

extern uint8_t binpack_dmg[];
extern uint32_t binpack_dmg_len;

extern uint8_t Pongo_bin[];
extern uint32_t Pongo_bin_len;

#if defined(__APPLE__) && (TARGET_OS_IPHONE || defined(DEV_BUILD) || defined(FORCE_HELPER))
extern uint8_t libcheckra1nhelper_dylib[];
extern uint32_t libcheckra1nhelper_dylib_len;
#endif

#endif

```

`packaging/control`:

```
Package: palera1n
Name: palera1n
Version: @DEB_VERSION@
Architecture: @DEB_ARCH@
Maintainer: palera1n team
Author: palera1n team
Depends: usbmuxd
Section: Utilities
Priority: optional
Homepage: https://palera.in
Description: iOS 15.0+ semi-tethered checkm8 jailbreak
 palera1n is an iOS/iPadOS 15.0+ semi tethered jailbreak
 based on the checkm8 exploit.
 .
 palera1n is able to jailbreak the device in fakefs-rootful mode,
 where / is writable, as well as rootless mode, where / cannot be
 written to.
 .
 IMPORTANT: This does NOT make palera1n untethered or allow you to
 jailbreak your current device without a computer. It just allows
 you to jailbreak another iDevice using this device, given you have
 an appropriate cable. Also, the success rate is likely to be bad.

```

`packaging/control.macosx`:

```macosx
Package: palera1n
Name: palera1n
Version: @DEB_VERSION@
Architecture: @DEB_ARCH@
Maintainer: palera1n team
Author: palera1n team
Section: Utilities
Priority: optional
Homepage: https://palera.in
Description: iOS 15.0+ semi-tethered checkm8 jailbreak
 palera1n is an iOS/iPadOS 15.0+ semi tethered jailbreak
 based on the checkm8 exploit.
 .
 palera1n is able to jailbreak the device in fakefs-rootful mode,
 where / is writable, as well as rootless mode, where / cannot be
 written to.

```

`patches/gpm/001_missing_V_option.patch`:

```patch
Description: Add no-op option -V for compatibility

Index: b/src/daemon/cmdline.c
===================================================================
--- a/src/daemon/cmdline.c	2008-05-29 02:26:08.000000000 +0300
+++ b/src/daemon/cmdline.c	2008-06-11 05:46:23.000000000 +0300
@@ -32,7 +32,7 @@
 void cmdline(int argc, char **argv)
 {
    extern struct options option;
-   char options[]="a:A::b:B:d:Dg:hi:kl:m:Mo:pr:R::s:S:t:Tuv23";
+   char options[]="a:A::b:B:d:Dg:hi:kl:m:Mo:pr:R::s:S:t:TuvV23";
    int  opt;
 
    /* initialize for the dual mouse */ 
@@ -81,6 +81,7 @@ void cmdline(int argc, char **argv)
          case 'u': option.autodetect = 1;                break;
          case 'T': opt_test++;                           break;
          case 'v': printf(GPM_MESS_VERSION "\n");        exit(0);
+         case 'V': /* Compat code */                     break;
          case '2': (which_mouse->opt_three) = -1;                       break;
          case '3': (which_mouse->opt_three) =  1;                       break;
          default: exit(usage("commandline"));

```

`patches/gpm/014_has_mouse_control.patch`:

```patch
Description: source code of gpm_has_mouse_control helper

Index: b/contrib/control/gpm_has_mouse_control.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ b/contrib/control/gpm_has_mouse_control.c	2007-12-10 08:25:45.000000000 +0200
@@ -0,0 +1,20 @@
+#include <sys/fcntl.h>
+#include <sys/kd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+
+int main (int argc, char **argv)
+{
+    int  fd;
+    int  mode;
+    fd = open ("/dev/tty0", O_RDONLY);
+    if (fd == -1)
+	fd = open ("/dev/vc/0", O_RDONLY);
+    if (fd == -1)
+	perror ("open");
+    if (ioctl (fd, KDGETMODE, &mode) != 0)
+	perror ("ioctl");
+    exit(mode);
+}
+
Index: b/contrib/control/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ b/contrib/control/Makefile	2007-12-10 08:25:45.000000000 +0200
@@ -0,0 +1,7 @@
+CC := gcc
+
+all: gpm_has_mouse_control.c
+	$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -o gpm_has_mouse_control -Wall gpm_has_mouse_control.c
+
+clean:
+	-rm -f gpm_has_mouse_control

```

`patches/gpm/031_max_consoles.patch`:

```patch
Description: Use MAX_NR_CONSOLES instead of MAX_VC

--- a/src/daemon/gpm.c
+++ b/src/daemon/gpm.c
@@ -93,7 +93,7 @@
 int fifofd=-1;
 
 int eventFlag=0;
-Gpm_Cinfo *cinfo[MAX_VC+1];
+Gpm_Cinfo *cinfo[MAX_NR_CONSOLES+1];
 
 time_t last_selection_time;
 time_t opt_age_limit = 0;
--- a/src/daemon/old_main.c
+++ b/src/daemon/old_main.c
@@ -141,7 +141,7 @@
          signal(SIGWINCH,gpm_killed); /* reinstall handler */
 
          /* and notify clients */
-         for(i=0; i<MAX_VC+1; i++) {
+         for(i=0; i<=MAX_NR_CONSOLES; i++) {
             Gpm_Cinfo *ci;
             for (ci = cinfo[i]; ci; ci = ci->next) kill(ci->data.pid,SIGWINCH);
          }
@@ -214,7 +214,7 @@
       /*........................ got request */
 
      /* itz 10-22-96 check _all_ clients, not just those on top! */
-      for (i=0; pending && (i<=MAX_VC); i++) {
+      for (i=0; pending && (i<=MAX_NR_CONSOLES); i++) {
          Gpm_Cinfo* ci;
          for (ci = cinfo[i]; pending && ci; ci = ci->next) {
             if (FD_ISSET(ci->fd,&selSet)) {
--- a/src/daemon/processconn.c
+++ b/src/daemon/processconn.c
@@ -67,8 +67,8 @@
       return -1;
    }
 
-   if((vc = request->vc) > MAX_VC) {
-      gpm_report(GPM_PR_DEBUG, GPM_MESS_REQUEST_ON, vc, MAX_VC);
+   if((vc = request->vc) > MAX_NR_CONSOLES) {
+      gpm_report(GPM_PR_DEBUG, GPM_MESS_REQUEST_ON, vc, MAX_NR_CONSOLES);
       free(info);
       close(newfd);
       return -1;
--- a/src/daemon/processrequest.c
+++ b/src/daemon/processrequest.c
@@ -41,7 +41,7 @@
 
    gpm_report(GPM_PR_INFO, GPM_MESS_CON_REQUEST, ci->fd, vc);
 
-   if (vc>MAX_VC) return -1;
+   if (vc>MAX_NR_CONSOLES) return -1;
 
    /* itz 10-22-96 this shouldn't happen now */
    if (vc==-1) gpm_report(GPM_PR_OOPS, GPM_MESS_UNKNOWN_FD);
--- a/src/headers/daemon.h
+++ b/src/headers/daemon.h
@@ -26,6 +26,7 @@
  */
 #include "gpm.h"           /* Gpm_Event         */
 #include <sys/select.h>    /* fd_set            */
+#include <linux/vt.h>      /* for cinfo -- to be moved to os/linux in 2.x! */
 
 /*************************************************************************
  * Types / structures
@@ -104,13 +105,6 @@
  * Macros
  */
 
-/* How many virtual consoles are managed? */
-#ifndef MAX_NR_CONSOLES
-#  define MAX_NR_CONSOLES 64 /* this is always sure */
-#endif
-
-#define MAX_VC    MAX_NR_CONSOLES  /* doesn't work before 1.3.77 */
-
 /* for adding a mouse; add_mouse */
 #define GPM_ADD_DEVICE        0
 #define GPM_ADD_TYPE          1
@@ -174,7 +168,7 @@
 extern int              eventFlag;
 extern struct winsize   win;
 
-extern Gpm_Cinfo       *cinfo[MAX_VC+1];
+extern Gpm_Cinfo       *cinfo[MAX_NR_CONSOLES+1];
 
 extern struct mouse_features  mouse_table[3],
                              *which_mouse;      /*the current one*/
--- a/src/headers/gpmCfg.h
+++ b/src/headers/gpmCfg.h
@@ -32,14 +32,6 @@
 #include <linux/tty.h>
 #endif
 
-/* FIXME: still needed ?? */
-/* How many virtual consoles are managed? */
-#ifndef MAX_NR_CONSOLES
-#  define MAX_NR_CONSOLES 64 /* this is always sure */
-#endif
-
-#define MAX_VC    MAX_NR_CONSOLES  /* doesn't work before 1.3.77 */
-
 /* How many buttons may the mouse have? */
 /* #define MAX_BUTTONS 3  ===> not used, it is hardwired :-( */
 

```

`patches/gpm/080_cross-compile.patch`:

```patch
Description: Add AC_CANONICAL_HOST

--- a/configure.ac.footer
+++ b/configure.ac.footer
@@ -35,6 +35,8 @@
 # Find programs
 #
 
+AC_CANONICAL_HOST
+
 AC_PROG_CC
 AC_PROG_LIBTOOL
 AC_PROG_INSTALL

```

`patches/gpm/092_fix-format-not-a-string-literal-and-no-format-arguments.patch`:

```patch
Description: Fix FTBFS with -Wformat-security
Author: Axel Beckert <abe@debian.org>
Bug-Debian: https://bugs.debian.org/888792
Bug-Debian: https://bugs.debian.org/888797

--- a/src/lib/report-lib.c
+++ b/src/lib/report-lib.c
@@ -47,7 +47,7 @@
                            log_level = LOG_CRIT; break;
    }
 #ifdef HAVE_VSYSLOG
-   syslog(log_level, string);
+   syslog(log_level, "%s", string);
    vsyslog(log_level, text, ap);
 #else
    fprintf(stderr,"%s[%s(%d)]:\n",string,file,line);

```

`patches/gpm/093_fix-typos.patch`:

```patch
Description: Fix spelling errors found by lintian
Author: Axel Beckert <abe@debian.org>

--- a/doc/FAQ
+++ b/doc/FAQ
@@ -132,7 +132,7 @@
            to keep hold of processor time for at least 1 second).
      - no pnp vendor will be able to support three buttons any more (no
            more mouse protocols, all mice must behave the same).
-     - similary, only 1200 baud devices (any serial device) are supported,
+     - similarly, only 1200 baud devices (any serial device) are supported,
            because the initialization string of pnp devices only tells
            the vendor and release, with no information about required
            port configuration.
--- a/doc/doc.gpm.in
+++ b/doc/doc.gpm.in
@@ -394,7 +394,7 @@
         automatically forces the @emph{repeater} (@samp{\-R}) option on.
 
 @item \-o @var{list-of-extra-options}
-	The option works similary to the ``\-o'' option of mount; it is
+	The option works similarly to the ``\-o'' option of mount; it is
 	used to specify a list of ``extra options'' that are specific
 	to each mouse type. The list is comma-separated. The options
 	@samp{dtr}, @samp{rts} or @samp{both} are used by the serial
--- a/src/daemon/old_main.c
+++ b/src/daemon/old_main.c
@@ -190,7 +190,7 @@
 /*....................................... got mouse, process event */
 /*
  * Well, actually, run a loop to maintain inlining of functions without
- * lenghtening the file. This is not too clean a code, but it works....
+ * lengthening the file. This is not too clean a code, but it works....
  */
 
       for (i=1; i <= 1+opt_double; i++) {
--- a/src/mice.c
+++ b/src/mice.c
@@ -122,7 +122,7 @@
          break;
       }
       if (p->type == ARGV_END) { /* not found */
-         fprintf(stderr, "%s: Uknown option \"%s\" for pointer \"%s\"\n",
+         fprintf(stderr, "%s: Unknown option \"%s\" for pointer \"%s\"\n",
                   option.progname, argv[i], argv[0]);
          errors++;
          continue;
--- a/src/prog/mouse-test.c
+++ b/src/prog/mouse-test.c
@@ -524,7 +524,7 @@
       Gpm_Event event;
 
       if (packetsize!=cur->this->packetlen) {
-         REMOVETYPE(cur,"different packet lenght");
+         REMOVETYPE(cur,"different packet length");
          continue;
       }
 
--- a/src/synaptics.c
+++ b/src/synaptics.c
@@ -2471,7 +2471,7 @@
 #define PS2_SCALE_11      0xE6      /* Set scale to 1:1 */
 
 
-/* Normal ps2 responce */
+/* Normal ps2 response */
 #define PS2_ERROR         0xFC      /* Error, after a reset,resend or disconnect*/
 #define PS2_ACK           0xFA      /* Command acknowledge */
 #define PS2_READY         0xAA      /* Send after a calibration or ERROR */
@@ -2538,7 +2538,7 @@
   }
 
 # ifdef DEBUG_PUTBYTE_ACK
-  gpm_report(GPM_PR_DEBUG,"Responce %X to byte %X",ack,b);
+  gpm_report(GPM_PR_DEBUG,"Response %X to byte %X",ack,b);
 # endif
 
   return ack;
@@ -2565,11 +2565,11 @@
     
     /* Do some sanity checking */
     if((response[0] & 0xFC) != 0x84) {
-      gpm_report (GPM_PR_ERR,"Byte 0 of stick device responce is not valid");
+      gpm_report (GPM_PR_ERR,"Byte 0 of stick device response is not valid");
       return -1;
     }
     if((response[3] & 0xCC) != 0xC4) {
-      gpm_report (GPM_PR_ERR,"Byte 3 of stick device responce is not valid");
+      gpm_report (GPM_PR_ERR,"Byte 3 of stick device response is not valid");
       return -1;
     }
   }
@@ -2844,7 +2844,7 @@
   byte status,id_code = PS2_MOUSE_IDCODE;
   byte reset_cmd = PS2_RESET;
 
-  gpm_report(GPM_PR_DEBUG,"Reseting Synaptic PS/2 %s\n",(stick?"Stick":"Touchpad"));
+  gpm_report(GPM_PR_DEBUG,"Resetting Synaptic PS/2 %s\n",(stick?"Stick":"Touchpad"));
 
   /* Send reset command without eating the ack. */
   if(!stick) {
@@ -2871,11 +2871,11 @@
   usleep(750000);
 
   if ( (status  = syn_ps2_getbyte(fd,stick)) != PS2_READY ){
-    gpm_report(GPM_PR_ERR,"Reseting PS/2 Device failed: No READY, got %02X.\n"
+    gpm_report(GPM_PR_ERR,"Resetting PS/2 Device failed: No READY, got %02X.\n"
 	                  "Check pc_keyb.c for reconnect smartness.\n",status);
   }
   if ( (id_code = syn_ps2_getbyte(fd,stick)) != PS2_MOUSE_IDCODE){
-    gpm_report(GPM_PR_ERR,"Reseting PS/2 Device failed: Wrong ID, got %02X.\n",id_code);
+    gpm_report(GPM_PR_ERR,"Resetting PS/2 Device failed: Wrong ID, got %02X.\n",id_code);
   }
 
 }
@@ -3155,7 +3155,7 @@
 
 void syn_serial_reset(int fd)
 {
-  gpm_report (GPM_PR_INFO,"Reseting Synaptic Serial Touchpad.");
+  gpm_report (GPM_PR_INFO,"Resetting Synaptic Serial Touchpad.");
 
   syn_serial_set_mode (fd, (RELATIVE_MODE    |
 			    HIGH_REPORT_RATE |
@@ -3247,7 +3247,7 @@
 
 void syn_ps2_reset (int fd)
 {
-  gpm_report (GPM_PR_INFO,"Reseting Synaptic PS/2 Touchpad.");
+  gpm_report (GPM_PR_INFO,"Resetting Synaptic PS/2 Touchpad.");
 
   /* Stop incoming motion data (of whatever kind absolute/relative). */
   tp_ps2_disable_data(fd);

```

`patches/gpm/094_gpm-1.20.7-glibc-2.26-1.patch`:

```patch
Origin: http://download.nutyx.org/x86_64/rolling/cli/gpm/gpm-1.20.7-consolidated-1.patch
Bug: https://github.com/telmich/gpm/issues/21
Bug-Debian: https://bugs.debian.org/886903
Bug-LFS: https://wiki.linuxfromscratch.org/blfs/ticket/9616#ticket
Author: tnut from nutyx.org, https://github.com/tnut
Description: Fix FTBFS with glibc 2.26

--- a/src/daemon/open_console.c
+++ b/src/daemon/open_console.c
@@ -24,6 +24,10 @@
 #include <sys/ioctl.h>              /* ioctl             */
 #include <sys/types.h>              /* major()           */
 
+#ifdef HAVE_SYS_SYSMACROS_H
+#include <sys/sysmacros.h>          /* major() w/newer glibc */
+#endif
+
 /* Linux specific (to be outsourced in gpm2 */
 #include <linux/serial.h>           /* for serial console check */
 #include <asm/ioctls.h>            /* for serial console check */
--- a/src/prog/gpm-root.y
+++ b/src/prog/gpm-root.y
@@ -443,6 +443,7 @@
 }
 
 /*---------------------------------------------------------------------*/
+#if 0
 static int f_debug_one(FILE *f, Draw *draw)
 {
    DrawItem *ip;
@@ -465,6 +466,7 @@
 #undef LINE
    return 0;
 }
+#endif
 
 int f_debug(int mode, DrawItem *self, int uid)
 {
@@ -960,10 +962,8 @@
 /*------------*/
 static inline void scr_restore(int fd, FILE *f, unsigned char *buffer, int vc)
 {
-   int x,y, dumpfd;
+   int dumpfd;
    char dumpname[20];
-
-   x=buffer[2]; y=buffer[3];
    
    /* WILL NOT WORK WITH DEVFS! FIXME! */
    sprintf(dumpname,"/dev/vcsa%i",vc);
@@ -1196,11 +1196,7 @@
                                                         LOG_DAEMON : LOG_USER);
    /* reap your zombies */
    childaction.sa_handler=reap_children;
-#if defined(__GLIBC__)
-   __sigemptyset(&childaction.sa_mask);
-#else /* __GLIBC__ */
-   childaction.sa_mask=0;
-#endif /* __GLIBC__ */
+   sigemptyset(&childaction.sa_mask);
    childaction.sa_flags=SA_INTERRUPT; /* need to break the select() call */
    sigaction(SIGCHLD,&childaction,NULL);
 

```

`patches/gpm/095_fix-compilation-with-gcc-10.patch`:

```patch
Description: FTBFS with gcc-10 due to -fno-commons
Author: Sergei Trofimovich <slyfox@gentoo.org>
Reviewed-By: Helmut Grohne <helmut@subdivi.de>
Origin: https://gitweb.gentoo.org/repo/gentoo.git/commit/?id=8f7e2ac82fc5a1847c132057fb7de1a996d66c76
Forwarded: https://github.com/telmich/gpm/pull/37
Bug: https://github.com/telmich/gpm/pull/37
Bug-Gentoo: https://bugs.gentoo.org/705878
Bug-Debian: https://bugs.debian.org/953266

--- a/src/headers/daemon.h
+++ b/src/headers/daemon.h
@@ -176,7 +176,7 @@
 extern Gpm_Type         mice[];
 extern Gpm_Type         *repeated_type;
 
-time_t                  last_selection_time;
+extern time_t           last_selection_time;
 
 
 

```

`patches/gpm/096_fix-compilation-against-musl-libc.patch`:

```patch
Description: Add musl support
 * Use SA_NODEFER instead of its non-standard alias SA_NOMASK.
 * Add missing sys/select.h and fcntl.h includes.
 * Use standard sigemptyset unconditionally.
 * Define SA_INTERRUPT if it's not defined (historical no-op).
 * With these changes gpm builds against musl libc.
Author: Szabolcs Nagy <nsz@port70.net>
Bug-Debian: https://bugs.debian.org/813751

--- a/src/lib/liblow.c
+++ b/src/lib/liblow.c
@@ -179,7 +179,7 @@
   /* Reincarnation. Prepare for another death early. */
   sigemptyset(&sa.sa_mask);
   sa.sa_handler = gpm_suspend_hook;
-  sa.sa_flags = SA_NOMASK;
+  sa.sa_flags = SA_NODEFER;
   sigaction (SIGTSTP, &sa, 0);
 
   /* Pop the gpm stack by closing the useless connection */
@@ -386,7 +386,7 @@
 
          /* if signal was originally ignored, job control is not supported */
          if (gpm_saved_suspend_hook.sa_handler != SIG_IGN) {
-            sa.sa_flags = SA_NOMASK;
+            sa.sa_flags = SA_NODEFER;
             sa.sa_handler = gpm_suspend_hook;
             sigaction(SIGTSTP, &sa, 0);
          }
--- a/src/prog/display-buttons.c
+++ b/src/prog/display-buttons.c
@@ -36,6 +36,7 @@
 #include <stdio.h>            /* printf()             */
 #include <time.h>             /* time()               */
 #include <errno.h>            /* errno                */
+#include <sys/select.h>       /* fd_set, FD_ZERO      */
 #include <gpm.h>              /* gpm information      */
 
 /* display resulting data */
--- a/src/prog/display-coords.c
+++ b/src/prog/display-coords.c
@@ -37,6 +37,7 @@
 #include <stdio.h>            /* printf()             */
 #include <time.h>             /* time()               */
 #include <errno.h>            /* errno                */
+#include <sys/select.h>       /* fd_set, FD_ZERO      */
 #include <gpm.h>              /* gpm information      */
 
 /* display resulting data */
--- a/src/prog/gpm-root.y
+++ b/src/prog/gpm-root.y
@@ -1197,6 +1197,9 @@
    /* reap your zombies */
    childaction.sa_handler=reap_children;
    sigemptyset(&childaction.sa_mask);
+#ifndef SA_INTERRUPT
+#define SA_INTERRUPT 0
+#endif
    childaction.sa_flags=SA_INTERRUPT; /* need to break the select() call */
    sigaction(SIGCHLD,&childaction,NULL);
 
--- a/contrib/control/gpm_has_mouse_control.c
+++ b/contrib/control/gpm_has_mouse_control.c
@@ -1,4 +1,4 @@
-#include <sys/fcntl.h>
+#include <fcntl.h>
 #include <sys/kd.h>
 #include <stdio.h>
 #include <stdlib.h>

```

`patches/mbedtls/0001-Allow-empty-x509-cert-issuer.patch`:

```patch
From a2d012f3ba459f6debe636b576ad9aeab7b3c2aa Mon Sep 17 00:00:00 2001
From: Nick Chan <towinchenmi@gmail.com>
Date: Sat, 27 May 2023 23:50:23 +0800
Subject: [PATCH] Allow empty x509 cert issuer

---
 library/x509_crt.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/library/x509_crt.c b/library/x509_crt.c
index cf62532f2..ef25b3d77 100644
--- a/library/x509_crt.c
+++ b/library/x509_crt.c
@@ -1061,13 +1061,13 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
 
     if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
                                     MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
-        mbedtls_x509_crt_free(crt);
-        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
+        /*mbedtls_x509_crt_free(crt);
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);*/
     }
 
     if ((ret = mbedtls_x509_get_name(&p, p + len, &crt->issuer)) != 0) {
-        mbedtls_x509_crt_free(crt);
-        return ret;
+        /*mbedtls_x509_crt_free(crt);
+        return ret;*/
     }
 
     crt->issuer_raw.len = p - crt->issuer_raw.p;
-- 
2.39.1


```

`src/Makefile`:

```
all: palera1n

OBJDIR = obj
GENDIR = gen
RESOURCES_DIR = resources

C_SRC = $(wildcard *.c)
OBJS = $(patsubst %,$(OBJDIR)/%,$(C_SRC:.c=.c.o))

ifeq (,$(findstring macosx, $(CFLAGS)))
ifneq (,$(findstring version-min=, $(CFLAGS)))
ifneq ($(NO_EMBED_HELPER),1)
C_SRC += $(GENDIR)/gen-libcheckra1nhelper.dylib.c
endif
endif
endif

ifeq ($(NO_EMBED_HELPER),1)
CFLAGS += -DNO_EMBED_HELPER
endif

ifeq ($(DFUHELPER_AUTO_ONLY),1)
CFLAGS += -DDFUHELPER_AUTO_ONLY
endif

ifeq ($(FORCE_HELPER),1)
ifneq ($(NO_EMBED_HELPER),1)
C_SRC += $(GENDIR)/gen-libcheckra1nhelper.dylib.c
endif
CFLAGS += -DFORCE_HELPER
BUILD_OPTIONS += FORCE_HELPER
endif

ifneq ($(NO_RAMDISK),1)
C_SRC += $(GENDIR)/gen-ramdisk.dmg.lzma.c
else
CFLAGS += -DNO_RAMDISK -DRAMDISK_COMPRESSED_SIZE=\"0\"
BUILD_OPTIONS += NO_RAMDISK
endif
ifneq ($(NO_KPF),1)
C_SRC += $(GENDIR)/gen-checkra1n-kpf-pongo.lzma.c
else
CFLAGS += -DNO_KPF
BUILD_OPTIONS += NO_KPF
endif
ifneq ($(NO_OVERLAY),1)
C_SRC += $(GENDIR)/gen-binpack.dmg.c
else
CFLAGS += -DNO_OVERLAY
BUILD_OPTIONS += NO_OVERLAY
endif
ifneq ($(NO_CHECKRAIN),1)
C_SRC += $(GENDIR)/gen-checkra1n.c
else
CFLAGS += -DNO_CHECKRAIN
BUILD_OPTIONS += NO_CHECKRAIN
endif

ifneq ($(NO_CUSTOM_PONGO),1)
C_SRC += $(GENDIR)/gen-Pongo.bin.c
else
CFLAGS += -DNO_CUSTOM_PONGO
BUILD_OPTIONS += NO_CUSTOM_PONGO
endif

ifeq ($(TUI),1)
BUILD_OPTIONS += TUI
CFLAGS += -DTUI
endif

CHECKRA1N_VERSION ?= 0.1337.3
LIPO = lipo
LDID = ldid

ifeq ($(TARGET_OS),Darwin)
ifneq ($(USE_LIBUSB),1)
else
LIBS += -framework SystemConfiguration -framework Security
BUILD_OPTIONS += USE_LIBUSB
endif
# add lto and debug symbols for lto
CFLAGS += -flto=full -g
LDFLAGS += -Wl,-object_path_lto,obj/lto.o
else
USE_LIBUSB = 1
endif

ifeq ($(USE_LIBUSB),1)
CFLAGS += -DUSE_LIBUSB=1
LIBS += $(DEP)/lib/libusb-1.0.a
endif

ifneq ($(ROOTFUL),0)
CFLAGS += -DROOTFUL=1
BUILD_OPTIONS += ROOTFUL
endif

ifeq ($(BUILD_OPTIONS),)
BUILD_OPTIONS = (none)
endif

CFLAGS += -DBUILD_OPTIONS=\""$(BUILD_OPTIONS)"\"

ifeq ($(TARGET_OS),Linux)
ifeq ($(UNAME),Linux)
ifeq ($(CHECKRA1N_NAME),)
ifeq ($(shell arch),x86_64)
CHECKRA1N_NAME := linux-x86_64
else ifeq ($(shell arch | grep -q 'i[3-7]86' && echo 1),1)
CHECKRA1N_NAME := linux-x86
else ifeq ($(shell arch | grep -v '\(arm\|aarch\)[a-z]\?\+64' | grep -q arm && echo 1),1)
CHECKRA1N_NAME := linux-armel
else ifeq  ($(shell arch | grep -q '\(arm\|aarch\)[a-z]\?\+64' && echo 1),1)
CHECKRA1N_NAME := linux-arm64
endif
endif
endif
endif

$(RESOURCES_DIR)/checkra1n-%:
	curl -Lfo $@ https://assets.checkra.in/downloads/preview/$(CHECKRA1N_VERSION)/$$(echo $@ | cut -d/ -f2)
	chmod 755 $@

$(RESOURCES_DIR)/checkra1n: $(RESOURCES_DIR)/checkra1n-macos usb.xml
ifeq ($(TARGET_OS),Darwin)
ifneq (,$(findstring arm64, $(CFLAGS)))
	$(LIPO) -thin arm64 -output $(RESOURCES_DIR)/checkra1n $(RESOURCES_DIR)/checkra1n-macos
else ifneq (,$(findstring x86_64, $(CFLAGS)))
	$(LIPO) -thin x86_64 -output $(RESOURCES_DIR)/checkra1n $(RESOURCES_DIR)/checkra1n-macos
else ifeq ($(shell arch),i386)
	$(LIPO) -thin x86_64 -output $(RESOURCES_DIR)/checkra1n $(RESOURCES_DIR)/checkra1n-macos
else
	$(LIPO) -thin $(shell arch) -output $(RESOURCES_DIR)/checkra1n $(RESOURCES_DIR)/checkra1n-macos
endif
ifeq (,$(findstring macosx, $(CFLAGS)))
ifneq (,$(findstring version-min=, $(CFLAGS)))
	vtool -remove-build-version 1 -replace -output $(RESOURCES_DIR)/checkra1n $(RESOURCES_DIR)/checkra1n
	vtool -set-build-version $(FAKE_PLATFORM) $(FAKE_MINOS) $(FAKE_SDK) -replace -output $(RESOURCES_DIR)/checkra1n $(RESOURCES_DIR)/checkra1n
	install_name_tool -change /System/Library/Frameworks/IOKit.framework/Versions/A/IOKit /System/Library/Frameworks/IOKit.framework/IOKit $(RESOURCES_DIR)/checkra1n
	install_name_tool -change /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation $(RESOURCES_DIR)/checkra1n
	$(LDID) -Susb.xml $(RESOURCES_DIR)/checkra1n
endif
endif
else
	cp $(RESOURCES_DIR)/checkra1n-$(CHECKRA1N_NAME) $(RESOURCES_DIR)/checkra1n
endif

$(GENDIR)/gen-%.c: $(RESOURCES_DIR)/%
	echo '#include <stdint.h>' > $(RESOURCES_DIR)/../$@
	cd $(RESOURCES_DIR) && xxd -iC $$(echo $< | cut -d/ -f2) | sed -e 's/unsigned int/uint32_t/' -e 's/unsigned char/uint8_t/' >> ../$@


$(OBJDIR)/pongo_helper.c.o: pongo_helper.c $(wildcard ../include/*.h) $(RESOURCES_DIR)/ramdisk.dmg $(RESOURCES_DIR)/checkra1n-kpf-pongo
	$(CC) -c -o $@ $(CFLAGS) -DRAMDISK_UNCOMPRESSED_SIZE="\"$$(wc -c < $(RESOURCES_DIR)/ramdisk.dmg | tr -d ' ')\"" -DKPF_UNCOMPRESSED_SIZE="\"$$(wc -c < $(RESOURCES_DIR)/checkra1n-kpf-pongo | tr -d ' ')\"" $<

$(OBJDIR)/%.c.o: $(GENDIR)/gen-%.c $(wildcard ../include/*.h)
	$(CC) $(CFLAGS) -c -o $<

$(OBJDIR)/%.c.o: %.c $(wildcard ../include/*.h)
	$(CC) $(CFLAGS) -c -o $@ $<

palera1n: $(OBJS)
	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) $(LIBS) -o palera1n
ifeq (,$(findstring macosx, $(CFLAGS)))
ifneq (,$(findstring version-min=, $(CFLAGS)))
	$(LDID) -Susb.xml palera1n
endif
endif

$(RESOURCES_DIR)/libcheckra1nhelper.dylib: chkstk.S
	$(CC) $(CFLAGS) $(LDFLAGS) -shared chkstk.S -o $@

$(RESOURCES_DIR)/checkra1n-kpf-pongo:
	curl -Lfo $@ https://cdn.nickchan.lol/palera1n/artifacts/kpf/iOS15/checkra1n-kpf-pongo

$(RESOURCES_DIR)/ramdisk.dmg.lzma: $(RESOURCES_DIR)/ramdisk.dmg
	xz --format=lzma -vfc6ekT 0 $< > $@

$(RESOURCES_DIR)/checkra1n-kpf-pongo.lzma: $(RESOURCES_DIR)/checkra1n-kpf-pongo
	xz --format=lzma -vfc6ekT 0 $< > $@

$(RESOURCES_DIR)/ramdisk.dmg:
	curl -Lfo $@ https://cdn.nickchan.lol/palera1n/c-rewrite/deps/ramdisk.dmg

$(RESOURCES_DIR)/binpack.dmg:
	curl -Lfo $@ https://cdn.nickchan.lol/palera1n/c-rewrite/deps/binpack.dmg

$(RESOURCES_DIR)/Pongo.bin:
	curl -Lfo $@ https://cdn.nickchan.lol/palera1n/artifacts/kpf/iOS15/Pongo.bin

clean:
	rm -rf $(OBJDIR)/*.o $(GENDIR)/*.c $(GENDIR)/*.o palera1n palera1n.dSYM libcheckra1nhelper.dylib

distclean: clean
	rm -rf $(RESOURCES_DIR)/*

.PHONY: all clean

```

`src/boyermoore_memmem.c`:

```c
#include <limits.h>
#include <stdlib.h>

const unsigned char *
boyermoore_horspool_memmem(const unsigned char* haystack, size_t hlen,
                           const unsigned char* needle,   size_t nlen)
{
    size_t scan = 0;
    size_t bad_char_skip[UCHAR_MAX + 1]; /* Officially called:
                                          * bad character shift */
 
    /* Sanity checks on the parameters */
    if (nlen <= 0 || !haystack || !needle)
        return NULL;
 
    /* ---- Preprocess ---- */
    /* Initialize the table to default value */
    /* When a character is encountered that does not occur
     * in the needle, we can safely skip ahead for the whole
     * length of the needle.
     */
    for (scan = 0; scan <= UCHAR_MAX; scan = scan + 1)
        bad_char_skip[scan] = nlen;
 
    /* C arrays have the first byte at [0], therefore:
     * [nlen - 1] is the last byte of the array. */
    size_t last = nlen - 1;
 
    /* Then populate it with the analysis of the needle */
    for (scan = 0; scan < last; scan = scan + 1)
        bad_char_skip[needle[scan]] = last - scan;
 
    /* ---- Do the matching ---- */
 
    /* Search the haystack, while the needle can still be within it. */
    while (hlen >= nlen)
    {
        /* scan from the end of the needle */
        for (scan = last; haystack[scan] == needle[scan]; scan = scan - 1)
            if (scan == 0) /* If the first byte matches, we've found it. */
            {
                return haystack;
            }
 
        /* otherwise, we need to skip some bytes and start again.
           Note that here we are getting the skip value based on the last byte
           of needle, no matter where we didn't match. So if needle is: "abcd"
           then we are skipping based on 'd' and that value will be 4, and
           for "abcdd" we again skip on 'd' but the value will be only 1.
           The alternative of pretending that the mismatched character was
           the last character is slower in the normal case (E.g. finding
           "abcd" in "...azcd..." gives 4 by using 'd' but only
           4-2==2 using 'z'. */
        hlen     -= bad_char_skip[haystack[last]];
        haystack += bad_char_skip[haystack[last]];
    }
 
    return NULL;
}

```

`src/chkstk.S`:

```S
#define _PTHREAD_STRUCT_DIRECT_STACKADDR_OFFSET   -48
#define _PTHREAD_STRUCT_DIRECT_STACKBOTTOM_OFFSET -40

.align 4
_thread_chkstk_darwin:
        .globl ___chkstk_darwin
___chkstk_darwin: // %w9/x9 == alloca size
        stp     x10, x11, [sp, #-16]

        // validate that the frame pointer is on our stack (no alt stack)
        mrs     x10, TPIDRRO_EL0

        // (%sp - pthread_self()->stackaddr) > 0 ?
#if defined(__ARM64_ARCH_8_32__)
        ubfx    x9, x9, #0, #32
        ldur    w11, [x10, _PTHREAD_STRUCT_DIRECT_STACKADDR_OFFSET]
#else
        ldur    x11, [x10, _PTHREAD_STRUCT_DIRECT_STACKADDR_OFFSET]
#endif
        subs    x11, sp, x11
        b.hs    Lprobe

        // %sp <= pthread_self()->stackbottom ?
#if defined(__ARM64_ARCH_8_32__)
        ldur    w11, [x10, _PTHREAD_STRUCT_DIRECT_STACKBOTTOM_OFFSET]
#else
        ldur    x11, [x10, _PTHREAD_STRUCT_DIRECT_STACKBOTTOM_OFFSET]
#endif
        mov     x10, sp
        cmp     x10, x11
        b.ls    Lprobe

        // %sp - (uintptr_t)%x9 < pthread_self()->stackbottom ?
        subs    x10, x10, x9
        b.lo    Lcrash
        cmp     x10, x11
        b.lo    Lcrash

Lexit:
        ldp     x10, x11, [sp, #-16]
        ret

Lcrash:
        // POSIX mandates that stack overflow crashes with SIGSEGV
        // so load an address in the guard page and dereference it
        //
        // x11 contains pthread_self()->stackbottom already
        ldr     x11, [x11, #-8]
        // if main_thread caused stack growth with setrlimit()
        // fall into Lprobe and eventually cause SIGSEGV.

Lprobe:
        mov     x10, sp
        cmp     x9, #0x1000
        b.lo    Lend
Lloop:
        sub     x10, x10, #0x1000
        ldr     x11, [x10]
        sub     x9, x9, #0x1000
        cmp     x9, #0x1000
        b.hi    Lloop
Lend:
        sub     x10, x10, x9
        ldr     x11, [x10]
        b       Lexit

```

`src/credits.c`:

```c
#include <stdio.h>

#ifndef BAKERAIN_DEVELOPE_R
#define BAKERAIN_DEVELOPE_R "kok3shidoll"
#endif
#define THE_PLUSH "Ploosh"

#define NEKO_DEVELOPE_R "HAHALOSAH"

#define T void
#define R print_credits(void) {
#define O fprintf(
#define U stderr,
#define B "#\n# palera1n: " BUILD_TAG " \n#\n"
#define L "# ========  Made by  =======\n"
#define E "# Made by: Nick Chan, " THE_PLUSH ", Khcrysalis, Mineek, staturnz, " BAKERAIN_DEVELOPE_R ", " NEKO_DEVELOPE_R " \n"
#define M "# ======== Thanks to =======\n"
#define A "# Thanks to: llsc12, Nebula, Lrdsnow, nikias (libimobiledevice),\n"
#define K "# checkra1n team (Siguza, axi0mx, littlelailo et al.),\n"
#define I "# Procursus Team (Hayden Seay, Cameron Katri, Keto et.al)\n"
#define N "# ==========================\n\n"
#define G );
#define S }

T R O U B L E M A K I N G S

```

`src/devhelper.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdbool.h>
#include <fcntl.h>
#include <stddef.h>
#include <unistd.h>
#include <ctype.h>
#ifdef WIN32
#include <windows.h>
#include <winsock2.h>
#else
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/ioctl.h>
#include <signal.h>
#endif
#include <pthread.h>
#include <inttypes.h>

#include <libirecovery.h>
#include <usbmuxd.h>

#include <libimobiledevice/libimobiledevice.h>
#include <libimobiledevice/lockdown.h>
#include <libimobiledevice/diagnostics_relay.h>
#include <plist/plist.h>

#ifdef HAVE_LIB_TV_CONTROL
#include <libtvcontrol.h>
#endif

#include <palerain.h>

irecv_device_event_context_t irecvctx = NULL;
usbmuxd_subscription_context_t usbmuxdctx = NULL;

void devinfo_free(devinfo_t *dev) {
	free(dev->buildVersion);
	free(dev->productType);
	free(dev->productVersion);
	free(dev->CPUArchitecture);
	return;
}

bool cpid_is_arm64(unsigned int cpid) {
	/*
	* ========== 0x6000 ===========
	*      M1 Pro, M1 Max, etc.
	* ========== 0x7000 ===========
	* (ARM64)     A8(X)
	* ========== 0x7002 ===========
	*              S1
	* ========== 0x8000 ===========
	* (ARM64) A9 (Samsung), A9X
	* ========== 0x8002 ===========
	*          S1P, S2, T1
	* ========== 0x8003 ===========
	* (ARM64)   A9 (TSMC)
	* ========== 0x8004 ===========
	*           S3 - S5
	* ========== 0x8010 ===========
	* (ARM64) A10(X) - A11, T2
	* ========== 0x8020 ===========
	*        A12, M1, M2, etc
	* ========== 0x8700 ===========
	*          iPod SoCs
	* ========== 0x8747 ===========
	*            Haywire
	* ========== 0x8900 ===========
	*       S5L8900 - A6(X)
	* ========== 0x8960 ===========
	* (ARM64)      A7     
	*/
	return (
		cpid == 0x8960 || cpid == 0x7000 || cpid == 0x7001 || 
		cpid == 0x8000 || cpid == 0x8001 || cpid == 0x8003 || 
		cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8012 || 
		cpid == 0x8015
	);
}

int subscribe_cmd(usbmuxd_event_cb_t device_event_cb, irecv_device_event_cb_t irecv_event_cb)
{
	int ret;
	if ((ret = usbmuxd_events_subscribe(&usbmuxdctx, device_event_cb, NULL))) return ret;
	if ((ret = irecv_device_event_subscribe(&irecvctx, irecv_event_cb, NULL))) return ret;
	return 0;
}

int unsubscribe_cmd(void)
{
	int ret;
	if ((ret = usbmuxd_events_unsubscribe(usbmuxdctx))) return ret;
	if ((ret = irecv_device_event_unsubscribe(irecvctx))) return ret;
	irecvctx = NULL;
	usbmuxdctx = NULL;
	return 0;
}

int devinfo_cmd(devinfo_t *dev, const char *udid)
{
	int ret;
	uint64_t this_ecid = 0;
	char *productType = NULL;
	char *productVersion = NULL;
	char *buildVersion = NULL;
	const char *displayName = NULL;
	char *CPUArchitecture = NULL;
	idevice_t device = NULL;
	lockdownd_client_t lockdown = NULL;
	if ((ret = idevice_new_with_options(&device, udid, IDEVICE_LOOKUP_USBMUX)) != IDEVICE_E_SUCCESS)
	{
		LOG(LOG_ERROR, "Error connecting to device: %d (%s)", ret, lockdownd_strerror(ret));
		return -1;
	}
	if ((ret = lockdownd_client_new_with_handshake(device, &lockdown, "palera1n")) != LOCKDOWN_E_SUCCESS)
	{
		(void)idevice_free(device);
		LOG(LOG_ERROR, "Device is not in normal mode: %d (%s)", ret, lockdownd_strerror(ret));
		return -1;
	}
	plist_t node = NULL;
	if ((ret = lockdownd_get_value(lockdown, NULL, "UniqueChipID", &node)) != LOCKDOWN_E_SUCCESS)
	{
		(void)lockdownd_client_free(lockdown);
		(void)idevice_free(device);
		LOG(LOG_ERROR, "Error getting ECID: %d (%s)", ret, lockdownd_strerror(ret));
		return -1;
	}
	plist_get_uint_val(node, &this_ecid);
	plist_free(node);

	node = NULL;
	if ((ret = lockdownd_get_value(lockdown, NULL, "ProductType", &node)) != LOCKDOWN_E_SUCCESS)
	{
		(void)lockdownd_client_free(lockdown);
		(void)idevice_free(device);
		LOG(LOG_ERROR, "Error getting product type: %d (%s)", ret, lockdownd_strerror(ret));
		return -1;
	}
	plist_get_string_val(node, &productType);
	plist_free(node);

	node = NULL;
	if ((ret = lockdownd_get_value(lockdown, NULL, "CPUArchitecture", &node)) != LOCKDOWN_E_SUCCESS)
	{
		(void)lockdownd_client_free(lockdown);
		(void)idevice_free(device);
		LOG(LOG_ERROR, "Error getting CPU type: %d (%s)", ret, lockdownd_strerror(ret));
		return -1;
	}
	plist_get_string_val(node, &CPUArchitecture);
	plist_free(node);

	node = NULL;
	if ((ret = lockdownd_get_value(lockdown, NULL, "ProductVersion", &node)) != LOCKDOWN_E_SUCCESS)
	{
		(void)lockdownd_client_free(lockdown);
		(void)idevice_free(device);
		LOG(LOG_ERROR, "Error getting product version: %d (%s)", ret, lockdownd_strerror(ret));
		return -1;
	}
	plist_get_string_val(node, &productVersion);
	plist_free(node);

	node = NULL;
	if ((ret = lockdownd_get_value(lockdown, NULL, "BuildVersion", &node)) != LOCKDOWN_E_SUCCESS)
	{
		(void)lockdownd_client_free(lockdown);
		(void)idevice_free(device);
		LOG(LOG_ERROR, "Error getting build version: %d (%s)", ret, lockdownd_strerror(ret));
		return -1;
	}
	plist_get_string_val(node, &buildVersion);
	plist_free(node);
	(void)lockdownd_client_free(lockdown);
	(void)idevice_free(device);

	irecv_device_t rcvydev;
	if (irecv_devices_get_device_by_product_type(productType, &rcvydev) == IRECV_E_SUCCESS)
	{
		displayName = rcvydev->display_name;
	} else
	{
		displayName = productType;
	}
	dev->buildVersion = buildVersion;
	dev->ecid = this_ecid;
	dev->CPUArchitecture = CPUArchitecture;
	dev->displayName = displayName;
	dev->productType = productType;
	dev->productVersion = productVersion;
	return 0;
}

int enter_recovery_cmd(const char* udid) {
	idevice_t device = NULL;
	lockdownd_client_t lockdown = NULL;
	if (idevice_new(&device, udid) != IDEVICE_E_SUCCESS) {
		LOG(LOG_ERROR, "Could not connect to device");
		return -1;
	}
	lockdownd_error_t ldret = lockdownd_client_new(device, &lockdown, "palera1n");
	if (ldret != LOCKDOWN_E_SUCCESS) {
		LOG(LOG_ERROR, "Could not connect to lockdownd: %s", lockdownd_strerror(ldret));
		return -1;
	}
	ldret = lockdownd_enter_recovery(lockdown);
	if (ldret == LOCKDOWN_E_SESSION_INACTIVE) {
		lockdownd_client_free(lockdown);
		lockdown = NULL;
		ldret = lockdownd_client_new_with_handshake(device, &lockdown, "palera1n");
		if (ldret != LOCKDOWN_E_SUCCESS) {
			LOG(LOG_ERROR, "Could not connect to lockdownd: %s", lockdownd_strerror(ldret));
			return -1;
		}
		ldret = lockdownd_enter_recovery(lockdown);
	}
	if (ldret != LOCKDOWN_E_SUCCESS) {
		LOG(LOG_ERROR, "Could not trigger entering recovery mode: %s", lockdownd_strerror(ldret));
		return -1;
	}
	lockdownd_client_free(lockdown);
	idevice_free(device);
	return 0;
}

int reboot_cmd(const char* udid) {
	idevice_t device = NULL;
	lockdownd_client_t lockdown = NULL;
	if (idevice_new(&device, udid) != IDEVICE_E_SUCCESS) {
		LOG(LOG_ERROR, "Could not connect to device");
		return -1;
	} else {
		diagnostics_relay_client_t diag = NULL;
		if (diagnostics_relay_client_start_service(device, &diag, "palera1n") == DIAGNOSTICS_RELAY_E_SUCCESS) {
			if (diagnostics_relay_restart(diag, DIAGNOSTICS_RELAY_ACTION_FLAG_WAIT_FOR_DISCONNECT) != DIAGNOSTICS_RELAY_E_SUCCESS) {
				LOG(LOG_ERROR, "Could not reboot device.");
			}
			(void)diagnostics_relay_goodbye(diag);
			(void)diagnostics_relay_client_free(diag);
		} else {
			LOG(LOG_ERROR, "Could not connect to device.");
			return -1;
		}
		idevice_free(device);
	}
	return 0;
}

int passstat_cmd(unsigned char* status, const char* udid) {
	lockdownd_error_t lerr = LOCKDOWN_E_SUCCESS;
	diagnostics_relay_error_t derr = DIAGNOSTICS_RELAY_E_SUCCESS;

	idevice_t dev = NULL;
	lockdownd_client_t lockdown = NULL;
	lockdownd_service_descriptor_t service = NULL;
	diagnostics_relay_client_t diagnostics_client = NULL;
	plist_t node = NULL;
	plist_t keys = NULL;
	plist_t status_node = NULL;
	plist_t value_node = NULL;

	if (idevice_new(&dev, udid) != IDEVICE_E_SUCCESS)
	{
		LOG(LOG_ERROR, "Error detecting device type");
		return -1;
	}
	lerr = lockdownd_client_new_with_handshake(dev, &lockdown, "idevicediagnostics");
	if ((lerr != LOCKDOWN_E_SUCCESS) || !lockdown)
	{
		idevice_free(dev);
		LOG(LOG_ERROR, "Error connecting to lockdownd (lockdownd error %d: (%s))", lerr, lockdownd_strerror(lerr));
		return -1;
	}
	lerr = lockdownd_start_service(lockdown, "com.apple.mobile.diagnostics_relay", &service);
	if ((lerr != LOCKDOWN_E_SUCCESS) || !service)
		lerr = lockdownd_start_service(lockdown, "com.apple.iosdiagnostics.relay", &service);

	lockdownd_client_free(lockdown);
	if ((lerr != LOCKDOWN_E_SUCCESS) || !service)
	{
		idevice_free(dev);
		LOG(LOG_ERROR, "Error starting diagnostics service (lockdownd error %d: (%s))\nUnlock the device and try again.", lerr, lockdownd_strerror(lerr));
		return -1;
	}
	derr = diagnostics_relay_client_new(dev, service, &diagnostics_client);
	if ((derr != DIAGNOSTICS_RELAY_E_SUCCESS) || !diagnostics_client)
	{
		lockdownd_service_descriptor_free(service);
		idevice_free(dev);
		LOG(LOG_ERROR, "Error starting diagnostics client (diagnostics error %d)", derr);
		return -1;
	}
	keys = plist_new_array();
	plist_array_append_item(keys, plist_new_string("xsaMbRQ5rQ+eyKMKG+ZSSg"));
	derr = diagnostics_relay_query_mobilegestalt(diagnostics_client, keys, &node);

	plist_free(keys);
	(void)diagnostics_relay_client_free(diagnostics_client);
	(void)lockdownd_service_descriptor_free(service);
	(void)idevice_free(dev);

	if (derr != DIAGNOSTICS_RELAY_E_SUCCESS || !node)
	{
		LOG(LOG_ERROR, "Error getting passcode state (lockdownd error %d: (%s))", lerr, lockdownd_strerror(lerr));
		return -1;
	}
	status_node = plist_access_path(node, 2, "MobileGestalt", "Status");
	if (!status_node)
	{
		plist_free(node);
		LOG(LOG_ERROR, "Error getting passcode state (invalid status node)");
		return -1;
	}
	char* passstat_status;
	plist_get_string_val(status_node, &passstat_status);
	if (!status || strncmp(passstat_status, "Succ", 4))
	{
		if (passstat_status) 
			free(passstat_status);
		passstat_status = NULL;
		plist_free(node);
		LOG(LOG_ERROR, "Error getting passcode state (invalid status)");
		return -1;
	}

	free(passstat_status);
	value_node = plist_access_path(node, 2, "MobileGestalt", "xsaMbRQ5rQ+eyKMKG+ZSSg");
	if (!value_node)
	{
		plist_free(node);
		LOG(LOG_ERROR, "Error getting passcode state (invalid value node)");
		return -1;
	}
	uint8_t passcode_state = 2;
	plist_get_bool_val(value_node, &passcode_state);
	plist_free(node);
	*status = passcode_state;
	LOG(LOG_VERBOSE4, "Passcode state: %hhu", *status);
	return 0;
}

int recvinfo_cmd(recvinfo_t* info, const uint64_t ecid) {
	irecv_client_t client = NULL;
	irecv_error_t err = irecv_open_with_ecid(&client, ecid);
	if (err != IRECV_E_SUCCESS) goto err;
	int mode = 0;
	err = irecv_get_mode(client, &mode);
	if (err != IRECV_E_SUCCESS) goto err;
	char *ibootver = NULL;
	err = irecv_getenv(client, "build-version", &ibootver);
	if (err != IRECV_E_SUCCESS) goto err;
	irecv_device_t device;
	err = irecv_devices_get_device_by_client(client, &device);
	if (err != IRECV_E_SUCCESS) goto err;
	info->mode = mode;
	info->cpid = device->chip_id;
	snprintf(info->product_type, 0x20, "%s", device->product_type);
	snprintf(info->display_name, 0x20, "%s", device->display_name);
	snprintf(info->iboot_ver, 0x20, "%s", (ibootver) ? ibootver : "");
	free(ibootver);
	irecv_close(client);
	return 0;
err:
	LOG(LOG_ERROR, "libirecovery error: %d (%s)", err, irecv_strerror(err));
	return -1;
}

int autoboot_cmd(const uint64_t ecid) {
	irecv_client_t client = NULL;
	irecv_error_t err = irecv_open_with_ecid(&client, ecid);
	if (err != IRECV_E_SUCCESS) goto err;
	err = irecv_setenv(client, "auto-boot", "true");
	if (err != IRECV_E_SUCCESS) goto err;
	err = irecv_saveenv(client);
	if (err != IRECV_E_SUCCESS) goto err;
	err = irecv_close(client);
	if (err != IRECV_E_SUCCESS) goto err;
	return 0;
err:
	LOG(LOG_ERROR, "libirecovery error: %d (%s)", err, irecv_strerror(err));
		return -1;
}

int exitrecv_cmd(const uint64_t ecid) {
	irecv_client_t client = NULL;
	irecv_error_t err = irecv_open_with_ecid(&client, ecid);
	if (err != IRECV_E_SUCCESS) goto err;
	err = irecv_setenv(client, "auto-boot", "true");
	if (err != IRECV_E_SUCCESS) goto err;
	err = irecv_saveenv(client);
	if (err != IRECV_E_SUCCESS) goto err;
	err = irecv_reboot(client);
	if (err != IRECV_E_SUCCESS) goto err;
	err = irecv_close(client);
	if (err != IRECV_E_SUCCESS) goto err;
	return 0;
err:
	LOG(LOG_ERROR, "libirecovery error: %d (%s)", err, irecv_strerror(err));
	return -1;
}

```

`src/dfuhelper.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdbool.h>
#include <unistd.h>
#include <ctype.h>

#include <sys/select.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/ioctl.h>
#include <signal.h>
#include <pthread.h>
#include <errno.h>
#include <inttypes.h>

#include <libimobiledevice/libimobiledevice.h>
#include <libimobiledevice/lockdown.h>
#include <libimobiledevice/diagnostics_relay.h>
#include <plist/plist.h>
#include <libirecovery.h>
#include <usbmuxd.h>

#include <ANSI-color-codes.h>
#include <palerain.h>

#define FORMAT_KEY_VALUE 1
#define FORMAT_XML 2

#define NO_PHYSICAL_HOME_BUTTON (cpid == 0x8015 || (cpid == 0x8010 && (bdid == 0x08 || bdid == 0x0a || bdid == 0x0c || bdid == 0x0e)))
#define IS_APPLE_TV_HD (cpid == 0x7000 && bdid == 0x34)
#define IS_APPLE_TV_4K (cpid == 0x8011 && bdid == 0x02)
#define IS_APPLE_HOME1 (cpid == 0x7000 && bdid == 0x38)
#define IS_APPLE_HOME2 (cpid == 0x7000 && bdid == 0x1a)
#define IS_APPLE_HOME  (IS_APPLE_HOME1 || IS_APPLE_HOME1)
#define IS_APPLETV (IS_APPLE_TV_4K || IS_APPLE_TV_HD || IS_APPLE_HOME)

int dfuhelper_thr_running = false;

static void step(int time, int time2, char *text, bool (*cond)(uint64_t), uint64_t cond_arg) {
    for (int i = time2; i < time; i++) {
		printf(
			(palerain_flags & palerain_option_no_colors) 
			? "\r\033[K%s (%d)" 
			: BCYN "\r\033[K%s (%d)" CRESET, text, time - i + time2
		);
        fflush(stdout);
        sleep(1);
		if (cond != NULL && cond(cond_arg)) pthread_exit(NULL);
    }
    printf(
		(palerain_flags & palerain_option_no_colors)
		? "\r%s (%d)" 
		: CYN "\r%s (%d)" CRESET, text, time2
	);
	if (time2 == 0) puts("");
}

static int connected_normal_mode(const usbmuxd_device_info_t *usbmuxd_device) {
	devinfo_t dev;
	int ret;
	ret = devinfo_cmd(&dev, usbmuxd_device->udid);
	if (ret != 0) {
		LOG(LOG_ERROR, "Unable to get device information");
		return 0;
	}
	if (strcmp(dev.CPUArchitecture, "arm64")) {
		devinfo_free(&dev);
		LOG(LOG_WARNING, "Ignoring non-arm64 device...");
		LOG(LOG_WARNING, "palera1n doesn't and never will work on A12+ (arm64e)");
		return -1;
	}

	if ((palerain_flags & palerain_option_device_info)) {
		printf("Mode: normal\n");
		printf("ProductType: %s\n", dev.productType);
		printf("Architecture: %s\n", dev.CPUArchitecture);
		printf("Version: %s\n", dev.productVersion);
		printf("DisplayName: %s\n", dev.displayName);

		device_has_booted = true;
		set_spin(0);
		unsubscribe_cmd();
		return 0;
	}

	/* For Booting Linux etc */
	if (!getenv("PALERA1N_BYPASS_PASSCODE_CHECK") &&
		!strncmp(dev.productType, "iPhone10,", strlen("iPhone10,")
		)) {
		if (!(palerain_flags & palerain_option_device_info))
			LOG(LOG_VERBOSE2, "Product %s requires passcode to be disabled", dev.productType);
		unsigned char passcode_state = 0;
		ret = passstat_cmd(&passcode_state, usbmuxd_device->udid);
		if (ret != 0) {
			LOG(LOG_ERROR, "Failed to get passcode state");
			devinfo_free(&dev);
			return -1;
		}
		if (passcode_state) {
			LOG(LOG_ERROR, "Passcode must be disabled on this device");
			if (!(palerain_flags & palerain_option_device_info))
				LOG(LOG_ERROR, "Additionally, passcode must never be set since a restore on iOS 16+");
			devinfo_free(&dev);
			return -1;
		}
	}
	
	if (getenv("PALERA1N_BYPASS_PASSCODE_CHECK"))
		LOG(LOG_WARNING, "Bypassed passcode check");	

	if (verbose > 1) {
		/* (LOG_VERBOSE - 3) or below*/
		LOG(LOG_INFO, "Telling device with udid %s to enter recovery mode immediately", usbmuxd_device->udid);
	} else {
		/* At least (LOG_VERBOSE2 - 3) */
		LOG(LOG_INFO, "Entering recovery mode");
	}
	enter_recovery_cmd(usbmuxd_device->udid);
	devinfo_free(&dev);
	if ((palerain_flags & palerain_option_enter_recovery)) {
		device_has_booted = true;
		set_spin(0);
		unsubscribe_cmd();
	}
	return 0;
}

static bool conditional(uint64_t ecid) {
	return get_ecid_wait_for_dfu() != ecid;
}

static void* connected_recovery_mode(struct irecv_device_info* info) {
	int ret;
	uint64_t ecid;
	uint32_t cpid, bdid;
	cpid = info->cpid;
	ecid = info->ecid;
	bdid = info->bdid;
	info = NULL;
	if (!cpid_is_arm64(cpid)) {
		LOG(LOG_WARNING, "Ignoring non-arm64 device...");
		return NULL;
	}
	sleep(1);
	ret = autoboot_cmd(ecid);
	if (ret) {
		LOG(LOG_ERROR, "Cannot set auto-boot back to true");
		return NULL;
	}
#if !defined(DFUHELPER_AUTO_ONLY)
	if (IS_APPLE_TV_4K) {
		LOG(LOG_INFO, "Depending on your connection method, you might need to press a button on your cable/board during reboot");
	}
	LOG(LOG_INFO, "Press Enter when ready for DFU mode");
	getchar();
#endif
	if (IS_APPLETV) {
		if (IS_APPLE_TV_HD) {
			step(10, 8, "Hold menu + play button", NULL, 0);
			set_ecid_wait_for_dfu(ecid);
			ret = exitrecv_cmd(ecid);
			if (ret) {
				LOG(LOG_ERROR, "Cannot exit recovery mode");
				set_ecid_wait_for_dfu(0);
				return NULL;
			}
			printf("\r\033[K");
			step(8, 0, "Hold menu + play button", conditional, ecid);
		} else if (IS_APPLE_TV_4K) {
			step(2, 0, "About to reboot device", NULL, 0);
			set_ecid_wait_for_dfu(ecid);
			ret = exitrecv_cmd(ecid);
			if (ret) {
				LOG(LOG_ERROR, "Cannot exit recovery mode");
				set_ecid_wait_for_dfu(0);
				return NULL;
			}
			step(4, 0, "Waiting for device to reconnect in DFU mode", conditional, ecid);
		} else if (IS_APPLE_HOME) {
			step(6, 4, "Put device in upside down orientation", NULL, 0);
			set_ecid_wait_for_dfu(ecid);
			ret = exitrecv_cmd(ecid);
			if (ret) {
				LOG(LOG_ERROR, "Cannot exit recovery mode");
				set_ecid_wait_for_dfu(0);
				return NULL;
			}
			step(4, 0, "Put device upside down orientation", conditional, ecid);
		}
	} else if (cpid != 0x8012) {
		if (NO_PHYSICAL_HOME_BUTTON)
			step(4, 2, "Hold volume down + side button", NULL, 0);
		else
			step(4, 2, "Hold home + power button", NULL, 0);
		set_ecid_wait_for_dfu(ecid);
		ret = exitrecv_cmd(ecid);
		if (ret) {
			LOG(LOG_ERROR, "Cannot exit recovery mode");
			set_ecid_wait_for_dfu(0);
			return NULL;
		}
		printf("\r\033[K");
		if (NO_PHYSICAL_HOME_BUTTON) {
			step(2, 0, "Hold volume down + side button", NULL, 0);
			step(10, 0, "Hold volume down button", conditional, ecid);
		} else {
			step(2, 0, "Hold home + power button", NULL, 0);
			step(10, 0, "Hold home button", conditional, ecid);
		}
	}
	if (get_ecid_wait_for_dfu() == ecid) {
		LOG(LOG_WARNING, "Whoops, device did not enter DFU mode");
		LOG(LOG_INFO, "Waiting for device to reconnect...");
		set_ecid_wait_for_dfu(0);
		return NULL;
	}
	set_ecid_wait_for_dfu(0);
	pthread_exit(NULL);
	return NULL;
}

static void* connected_dfu_mode(struct irecv_device_info* info) {
	if (get_ecid_wait_for_dfu() == info->ecid) {
		set_ecid_wait_for_dfu(0);
		puts("");
		LOG(LOG_INFO, "Device entered DFU mode successfully");
	}
	unsigned int bdid = info->bdid;
	unsigned int cpid = info->cpid;
	if (IS_APPLE_HOME) {
		step(2, 0, "Put device in upright orientation", NULL, 0);
	}
	set_spin(0);
	unsubscribe_cmd();
	pthread_exit(NULL);
	return NULL;
}

static void device_event_cb(const usbmuxd_event_t *event, void* userdata) {
	if (event->device.conn_type != CONNECTION_TYPE_USB) return;
	switch (event->event) {
	case UE_DEVICE_ADD:
		LOG(LOG_VERBOSE, "Normal mode device connected");
		if ((palerain_flags & palerain_option_exit_recovery)) {
			break;
		} else if ((palerain_flags & palerain_option_reboot_device)) {
			int ret = reboot_cmd(event->device.udid);
			if (!ret) {
				LOG(LOG_INFO, "Restarted device");
				set_spin(0);
				unsubscribe_cmd();
			}
			pthread_exit(NULL);
			break;
		}
		connected_normal_mode(&event->device);
		break;
	case UE_DEVICE_REMOVE:
		LOG(LOG_VERBOSE, "Normal mode device disconnected");
		break;
	}
}

static void irecv_device_event_cb(const irecv_device_event_t *event, void* userdata) {
	pthread_t recovery_thread, dfu_thread;
	int ret;
	
	switch(event->type) {
		case IRECV_DEVICE_ADD:
			if (event->mode == IRECV_K_RECOVERY_MODE_1 || 
				event->mode == IRECV_K_RECOVERY_MODE_2 || 
				event->mode == IRECV_K_RECOVERY_MODE_3 || 
				event->mode == IRECV_K_RECOVERY_MODE_4) {
				if (!(palerain_flags & palerain_option_device_info))
					LOG(LOG_VERBOSE, "Recovery mode device %" PRIu64 " connected", event->device_info->ecid);
				if ((palerain_flags & palerain_option_exit_recovery)) {
					ret = exitrecv_cmd(event->device_info->ecid);
					if (!ret) {
						LOG(LOG_INFO, "Exited recovery mode");
						device_has_booted = true;
						set_spin(0);
						unsubscribe_cmd();
					} else {
						LOG(LOG_WARNING, "Could not exit recovery mode");
					}
					if (dfuhelper_thr_running) pthread_cancel(dfuhelper_thread);
					pthread_exit(NULL);
					break;
				}

				if ((palerain_flags & palerain_option_device_info)) {
					recvinfo_t info;
					ret = recvinfo_cmd(&info, event->device_info->ecid);
					if (ret) {
						LOG(LOG_WARNING, "Could not get info from device");
					} else {
						printf("Mode: Recovery\n");
						printf("ProductType: %s\n", info.product_type);
						printf("DisplayName: %s\n", info.display_name);

						device_has_booted = true;
						set_spin(0);
						unsubscribe_cmd();
					}
					if (dfuhelper_thr_running) pthread_cancel(dfuhelper_thread);
					pthread_exit(NULL);
					break;
				}

				if ((palerain_flags & palerain_option_enter_recovery) ||
					(palerain_flags & palerain_option_reboot_device)) return;
				pthread_create(&recovery_thread, NULL, (pthread_start_t)connected_recovery_mode, event->device_info);
			} else if (event->mode == IRECV_K_DFU_MODE) {
				if (!(palerain_flags & palerain_option_device_info))
					LOG(LOG_VERBOSE, "DFU mode device %" PRIu64 " connected", event->device_info->ecid);

				if ((palerain_flags & palerain_option_device_info)) {
					recvinfo_t info;
					ret = recvinfo_cmd(&info, event->device_info->ecid);
					if (ret) {
						LOG(LOG_WARNING, "Could not get info from device");
					} else {
						printf("Mode: DFU\n");
						printf("ProductType: %s\n", info.product_type);
						printf("DisplayName: %s\n", info.display_name);

						device_has_booted = true;
						set_spin(0);
						unsubscribe_cmd();
					}
					if (dfuhelper_thr_running) pthread_cancel(dfuhelper_thread);
					pthread_exit(NULL);
					break;
				}

				if (
					(palerain_flags & palerain_option_exit_recovery) ||
					(palerain_flags & palerain_option_enter_recovery) ||
					(palerain_flags & palerain_option_reboot_device)) {
						break;
				}
				pthread_create(&dfu_thread, NULL, (pthread_start_t)connected_dfu_mode, event->device_info);
			}
			break;
		case IRECV_DEVICE_REMOVE:
			LOG(LOG_VERBOSE, "Recovery mode device disconnected");
		break;
	}
}

void *dfuhelper(void* ptr) {
	dfuhelper_thr_running = true;
	set_spin(1);
	subscribe_cmd(device_event_cb, irecv_device_event_cb);
	while (get_spin()) {
		sleep(1);
	};
	dfuhelper_thr_running = false;
	return 0;
}

```

`src/exec_checkra1n.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdbool.h>
#include <unistd.h>
#include <spawn.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>

#include <assert.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <inttypes.h>
#include <sys/utsname.h>

#if defined(__APPLE__)
#include <TargetConditionals.h>
#endif

extern char **environ;
extern char* gOverrideLibcheckra1nHelper;

#include <palerain.h>
#ifdef TUI
#include <tui.h>
#endif
#include <xxd-embedded.h>
char* pongo_path = NULL;
bool external_pongo = false;
char* ext_checkra1n = NULL;

#define tmpdir getenv("TMPDIR") == NULL ? "/tmp" : getenv("TMPDIR")

int exec_checkra1n(void) {
	LOG(LOG_INFO, "About to execute checkra1n");
	int fd_checkra1n, fd_pongo, ret;
	char* checkra1n_path = NULL;
#ifndef NO_CUSTOM_PONGO
	if (pongo_path == NULL) {
		pongo_path = malloc(strlen(tmpdir) + 20);
		if (pongo_path == NULL) {
			LOG(LOG_FATAL, "memory allocation failed\n");
			return -1;
		}
		snprintf(pongo_path, strlen(tmpdir) + 20, "%s/Pongo.bin.XXXXXX", tmpdir);
		fd_pongo = mkstemp(pongo_path);
		if (fd_pongo == -1) {
			LOG(LOG_FATAL, "Cannot open temporary file %s: %d (%s)", pongo_path, errno, strerror(errno));
			free(pongo_path);
			return -1;
		}
		ssize_t didWrite_Pongo_bin = write(fd_pongo, Pongo_bin, Pongo_bin_len);
		if (didWrite_Pongo_bin != (ssize_t)Pongo_bin_len) {
			LOG(LOG_FATAL, "Size written to %s does not match expected: %zd != %" PRIu32 ": %d (%s)", pongo_path, didWrite_Pongo_bin, Pongo_bin_len, errno, strerror(errno));
			close(fd_pongo);
			unlink(pongo_path);
			free(pongo_path);
			pongo_path = NULL;
			return -1;
		}
	} else external_pongo = true;
#endif
	if (ext_checkra1n != NULL) {
		checkra1n_path = ext_checkra1n;
	} else {
		checkra1n_path = malloc(strlen(tmpdir) + 20);
		if (checkra1n_path == NULL) {
			LOG(LOG_FATAL, "memory allocation failed\n");
			return -1;
		}
		snprintf(checkra1n_path, strlen(tmpdir) + 20, "%s/checkra1n.XXXXXX", tmpdir);
		fd_checkra1n = mkstemp(checkra1n_path);
		if (fd_checkra1n == -1) {
			LOG(LOG_FATAL, "Cannot open temporary file %s: %d (%s)", checkra1n_path, errno, strerror(errno));
			free(checkra1n_path);
			checkra1n_path = NULL;
			return -1;
		}
		ssize_t didWrite_checkra1n = write(fd_checkra1n, checkra1n, checkra1n_len);
		if (didWrite_checkra1n != (ssize_t)checkra1n_len) {
			LOG(LOG_FATAL, "Size written to %s does not match expected: %zd != %" PRIu32 ": %d (%s)", checkra1n_path, didWrite_checkra1n, checkra1n_len, errno, strerror(errno));
			close(fd_checkra1n);
			unlink(checkra1n_path);
			free(checkra1n_path);
			checkra1n_path = NULL;
			return -1;
		}
		close(fd_checkra1n);
		ret = chmod(checkra1n_path, 0700);
		if (ret) {
			LOG(LOG_FATAL, "Cannot chmod %s: %d (%s)", checkra1n_path, errno, strerror(errno));
			unlink(checkra1n_path);
			free(checkra1n_path);
			checkra1n_path = NULL;
			return -1;
		}
	}
#if defined(__APPLE__) && defined(__arm64__) && (TARGET_OS_IPHONE || defined(FORCE_HELPER))
	char* libcheckra1nhelper_dylib_path = NULL;
	{
		struct utsname name;
		uname(&name);
		unsigned long darwinMajor = strtoul(name.release, NULL, 10);
		assert(darwinMajor != 0);
#if !defined(FORCE_HELPER)
		if (darwinMajor < 20) {
#endif
		if (gOverrideLibcheckra1nHelper) {
			libcheckra1nhelper_dylib_path = gOverrideLibcheckra1nHelper;
			goto setenv_ra1n;
		}
			libcheckra1nhelper_dylib_path = malloc(strlen(tmpdir) + 40);
			if (libcheckra1nhelper_dylib_path == NULL) {
				LOG(LOG_FATAL, "memory allocation failed\n");
				return -1;
			}
			snprintf(libcheckra1nhelper_dylib_path, strlen(tmpdir) + 40, "%s/libcheckra1nhelper.dylib.XXXXXX", tmpdir);
			int helper_fd = mkstemp(libcheckra1nhelper_dylib_path);
			if (helper_fd == -1) {
				LOG(LOG_FATAL, "Cannot open temporary file: %d (%s)", errno, strerror(errno));
				return -1;
			}
			ssize_t didWrite_libcheckra1nhelper = write(helper_fd, libcheckra1nhelper_dylib, libcheckra1nhelper_dylib_len);
			if ((unsigned int)didWrite_libcheckra1nhelper != libcheckra1nhelper_dylib_len) {
				LOG(LOG_FATAL, "Size written does not match expected: %zd != %" PRIu32 ": %d (%s)", didWrite_libcheckra1nhelper, libcheckra1nhelper_dylib_len, errno, strerror(errno));
				close(helper_fd);
				unlink(libcheckra1nhelper_dylib_path);
				return -1;
			}
			close(helper_fd);
			ret = chmod(libcheckra1nhelper_dylib_path, 0700);
			if (ret) {
				LOG(LOG_FATAL, "Cannot chmod %s: %d (%s)", libcheckra1nhelper_dylib_path, errno, strerror(errno));
				unlink(libcheckra1nhelper_dylib_path);
				return -1;
			}
setenv_ra1n:
			setenv("DYLD_INSERT_LIBRARIES", libcheckra1nhelper_dylib_path, 1);
#if !defined(FORCE_HELPER)
		}
#endif
	}
#endif
	char args[0x10] = "-E";
	if ((palerain_flags & palerain_option_demote)) strncat(args, "d", 0xf);
	if (!(palerain_flags & palerain_option_checkrain_is_clone)) {
		strncat(args, "p", 0xf);
		if (verbose >= 2) strncat(args, "v", 0xf);
		if ((palerain_flags & palerain_option_no_colors)) strncat(args, "n", 0xf);
	} else {
		strncat(args, "R", 0xf);
	}
	LOG(LOG_VERBOSE5, "%s", args);
	if (pongo_path != NULL) LOG(LOG_VERBOSE5, "%s", pongo_path);
	pid_t pid;
	posix_spawn_file_actions_t action;
    posix_spawn_file_actions_init(&action);
#ifdef TUI
	if (tui_is_jailbreaking) {
		// silence checkra1n
		posix_spawn_file_actions_addopen(&action, 1, "/dev/null", O_WRONLY, 0);
		posix_spawn_file_actions_addopen(&action, 2, "/dev/null", O_WRONLY, 0);
	}
#endif
	ret = posix_spawn(&pid, checkra1n_path, &action, NULL, (char* []){
		checkra1n_path,
		args,
		"-k",
		pongo_path,
		NULL
	}, environ);
	posix_spawn_file_actions_destroy(&action);
	if (ret) {
		LOG(LOG_FATAL, "Cannot posix spawn %s: %d (%s)", checkra1n_path, errno, strerror(errno));
		if (ext_checkra1n != NULL) unlink(checkra1n_path);
		return -1;
	}
	LOG(LOG_VERBOSE2, "%s spawned successfully", checkra1n_path);
	sleep(2);
	if (ext_checkra1n == NULL) {
		unlink(checkra1n_path);
		free(checkra1n_path);
		checkra1n_path = NULL;
	}
	waitpid(pid, NULL, 0);
		if (!external_pongo && pongo_path != NULL) {
		unlink(pongo_path);
	}
	if (pongo_path != NULL) free(pongo_path);
	pongo_path = NULL;
#if defined(__APPLE__) && defined(__arm64__) && (TARGET_OS_IPHONE || defined(FORCE_HELPER))
	if (libcheckra1nhelper_dylib_path != NULL) {
		if (!gOverrideLibcheckra1nHelper) unlink(libcheckra1nhelper_dylib_path);
		unsetenv("DYLD_INSERT_LIBRARIES");
		unsetenv("DYLD_FORCE_FLAT_NAMESPACE");
		if (!gOverrideLibcheckra1nHelper) free(libcheckra1nhelper_dylib_path);
		libcheckra1nhelper_dylib_path = NULL;
	}
#endif
	return 0;
}

```

`src/fake_embedded.c`:

```c
#include <stdlib.h>

#ifdef NO_KPF
unsigned char* checkra1n_kpf_pongo_lzma = NULL;
unsigned int checkra1n_kpf_pongo_lzma_len = 0;
#endif

#ifdef NO_RAMDISK
unsigned char* ramdisk_dmg_lzma = NULL;
unsigned int ramdisk_dmg_lzma_len = 0;
#endif

#ifdef NO_CHECKRAIN
unsigned char* checkra1n = NULL;
unsigned int checkra1n_len = 0;
#endif

#ifdef NO_OVERLAY
unsigned char* binpack_dmg = NULL;
unsigned int binpack_dmg_len = 0;
#endif

#ifdef NO_CUSTOM_PONGO
unsigned char* Pongo_bin = NULL;
unsigned int Pongo_bin_len = 0;
#endif

#ifdef NO_EMBED_HELPER
unsigned char* libcheckra1nhelper_dylib = NULL;
unsigned int libcheckra1nhelper_dylib_len = 0;
#endif

```

`src/lock_vars.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <stddef.h>
#include <unistd.h>
#include <stdarg.h>
#include <ctype.h>
#include <assert.h>

#include <sys/select.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/ioctl.h>
#include <signal.h>
#include <pthread.h>
#include <inttypes.h>
#include <getopt.h>
#include <errno.h>
#include <spawn.h>
#include <sys/mman.h>
#include <time.h>

#include <libimobiledevice/libimobiledevice.h>

#include <ANSI-color-codes.h>
#include <palerain.h>
#include <xxd-embedded.h>
#include <paleinfo.h>

pthread_mutex_t spin_mutex, found_pongo_mutex, ecid_dfu_wait_mutex;

bool spin, found_pongo = 0;
uint64_t ecid_wait_for_dfu = 0;

static bool get_locked_bool(bool* val, pthread_mutex_t* mutex) {
    // fprintf(stderr, "%s: val = %p mutex = %p\n", __func__, (void*)val, (void*)mutex);
    pthread_mutex_lock(mutex);
    bool ret = *val;
    pthread_mutex_unlock(mutex);
    return ret;
}

static bool set_locked_bool(bool* val, bool newval, pthread_mutex_t* mutex) {
    // fprintf(stderr, "%s: val = %p mutex = %p, newval = %d\n", __func__, (void*)val, (void*)mutex, newval);
    pthread_mutex_lock(mutex);
    *val = newval;
    pthread_mutex_unlock(mutex);
    return newval;
}

bool get_spin(void) {
    return get_locked_bool(&spin, &spin_mutex);
}

bool set_spin(bool newval) {
    return set_locked_bool(&spin, newval, &spin_mutex);
}

bool get_found_pongo(void) {
   return get_locked_bool(&found_pongo, &found_pongo_mutex);
}

bool set_found_pongo(bool val) {
    return set_locked_bool(&found_pongo, val, &found_pongo_mutex);
}

uint64_t get_ecid_wait_for_dfu(void) {
    LOG(LOG_VERBOSE5, "locking ecid wait for dfu mutex for get");
    pthread_mutex_lock(&ecid_dfu_wait_mutex);
    uint64_t ret = ecid_wait_for_dfu;
    LOG(LOG_VERBOSE5, "UN-locking ecid wait for dfu mutex, ecid_wait_for_dfu value is %llu", ret);
    pthread_mutex_unlock(&ecid_dfu_wait_mutex);
    return ret;
}

uint64_t set_ecid_wait_for_dfu(uint64_t ecid) {
    LOG(LOG_VERBOSE5, "locking ecid wait for dfu mutex for set ecid_wait_for_dfu = %llu", ecid);
    pthread_mutex_lock(&ecid_dfu_wait_mutex);
    ecid_wait_for_dfu = ecid;
    LOG(LOG_VERBOSE5, "UN-locking ecid wait for dfu mutex afrer setting ecid_wait_for_dfu");
    pthread_mutex_unlock(&ecid_dfu_wait_mutex);
    return ecid;
}

```

`src/log.c`:

```c
#include <time.h>
#include <stdio.h>
#include <stdarg.h>
#include <stddef.h>
#include <pthread.h>
#include <assert.h>

#include <ANSI-color-codes.h>
#include <palerain.h>

#ifdef TUI
#include <tui.h>
#endif

int p1_log(log_level_t loglevel, const char *fname, int lineno, const char *fxname, const char *__restrict format, ...)
{
#ifdef TUI
	if (tui_started) return 0;
#endif
    if (verbose >= 5 
#ifdef TUI
	&& !(palerain_flags & palerain_option_tui)
#endif
	) fprintf(stderr, "p1_log: loglevel %d from %s:%d:%s()\n", loglevel, fname, lineno, fxname);
	int ret = 0;
	char type[0x10];
	char colour[0x10];
	char colour_bold[0x10];
	va_list args;
	va_start(args, format);
	if (verbose < (loglevel - 3) && loglevel > LOG_INFO) {
        if (verbose >= 5
#ifdef TUI
		&& !tui_started
#endif
) fprintf(stderr, "p1_log: hid log with high log level (%d < %d)\n", verbose, loglevel - 3);
		va_end(args);
        return 0;
    }
	switch (loglevel) {
	case LOG_FATAL:
		snprintf(type, 0x10, "%s", "!");
		snprintf(colour, 0x10, "%s", RED);
		snprintf(colour_bold, 0x10, "%s", BRED);
		break;
	case LOG_ERROR:
		snprintf(type, 0x10, "%s", "Error");
		snprintf(colour, 0x10, "%s", RED);
		snprintf(colour_bold, 0x10, "%s", BRED);
		break;
	case LOG_WARNING:
		snprintf(type, 0x10, "%s", "Warning");
		snprintf(colour, 0x10, "%s", YEL);
		snprintf(colour_bold, 0x10, "%s", BYEL);
		break;
	case LOG_INFO:
		snprintf(type, 0x10, "%s", "Info");
		snprintf(colour, 0x10, "%s", CYN);
		snprintf(colour_bold, 0x10, "%s", BCYN);
		break;
	default:
		assert(loglevel >= 0);
		snprintf(type, 0x10, "%s", "Verbose");
		snprintf(colour, 0x10, "%s", WHT);
		snprintf(colour_bold, 0x10, "%s", BWHT);
		break;
	}
	if ((palerain_flags & palerain_option_no_colors)) {
		colour[0] = '\0';
		colour_bold[0] = '\0';
	}
	{
		pthread_mutex_lock(&log_mutex);
		char timestring[0x80];
		time_t curtime;
		time(&curtime);
		struct tm* timeinfo = localtime(&curtime);
		if (!(palerain_flags & palerain_option_no_colors))
			snprintf(timestring, 0x80, "%s[%s%02d/%02d/%d %02d:%02d:%02d%s]", CRESET, HBLK, timeinfo->tm_mon + 1, timeinfo->tm_mday, timeinfo->tm_year - 100, timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec, CRESET);
		else
			snprintf(timestring, 0x80, "[%02d/%02d/%d %02d:%02d:%02d]", timeinfo->tm_mon + 1, timeinfo->tm_mday, timeinfo->tm_year - 100, timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec);
		if (verbose >= 2 && !(palerain_flags & palerain_option_no_colors)) {
			printf("%s| - %s%s <%s> " CRESET "%s" HBLU "%s" CRESET ":" BLU "%d" CRESET ":" BMAG "%s()" CRESET ": \n%s| ----> ", colour_bold, timestring, colour_bold, type, WHT, fname, lineno, fxname, colour_bold);
		} else if (!(palerain_flags & palerain_option_no_colors)) {
			printf(" - %s %s<%s>%s: ", timestring, colour_bold, type, CRESET);
		} else if (verbose >= 2 && (palerain_flags & palerain_option_no_colors)) {
			printf("%s| - %s%s <%s> %s:%d:%s(): \n%s| ----> ", colour_bold, timestring, colour_bold, type, fname, lineno, fxname, colour_bold);
		} else if ((palerain_flags & palerain_option_no_colors)) {
			printf(" - %s %s<%s>: ", timestring, colour_bold, type);
		}
		printf("%s", colour);
		ret = vprintf(format, args);
		va_end(args);
	
		if (verbose < 2 && !(palerain_flags & palerain_option_no_colors))
			printf(CRESET "\n");
		else if (!(palerain_flags & palerain_option_no_colors))
			printf("\n%s-%s\n", colour, CRESET);
		else if (verbose < 2) 
			printf("\n");
		else 
			printf("\n%s-\n", colour);
		fflush(stdout);
	}
	pthread_mutex_unlock(&log_mutex);
	return ret;
}

```

`src/main.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <stddef.h>
#include <unistd.h>
#include <stdarg.h>
#include <ctype.h>
#include <limits.h>
#include <assert.h>

#include <sys/select.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/ioctl.h>
#include <signal.h>
#include <pthread.h>
#include <inttypes.h>
#include <errno.h>
#include <spawn.h>
#include <sys/mman.h>
#include <time.h>

#include <libimobiledevice/libimobiledevice.h>

#include <ANSI-color-codes.h>
#include <palerain.h>
#include <xxd-embedded.h>
#include <paleinfo.h>

#define CMD_LEN_MAX 512
#define OVERRIDE_MAGIC 0xd803b376

unsigned int verbose = 0;
/* we want to write to them so don't use string literals */
char xargs_cmd[0x270] = { 'x', 'a', 'r', 'g', 's', '\0' }, 
	palerain_flags_cmd[0x30] = { 'd', 'e', 'a', 'd', 'b', 'e', 'e', 'f', '\0' };
extern char** environ;

niarelap_file_t* kpf_to_upload_1 = &checkra1n_kpf_pongo_lzma;
niarelap_file_t* ramdisk_to_upload_1 = &ramdisk_dmg_lzma;
niarelap_file_t* overlay_to_upload_1 = &binpack_dmg;

niarelap_file_t** kpf_to_upload = &kpf_to_upload_1;
niarelap_file_t** ramdisk_to_upload = &ramdisk_to_upload_1;
niarelap_file_t** overlay_to_upload = &overlay_to_upload_1;

override_file_t override_ramdisk, override_kpf, override_overlay;

uint64_t palerain_flags = 0;

pthread_mutex_t log_mutex;
pthread_t dfuhelper_thread, pongo_thread;

void thr_cleanup(void* ptr) {
	*(int*)ptr = 0;
}

static int build_checks(void) {
#ifndef NO_CHECKRAIN
#if defined(__APPLE__)
	struct mach_header_64* c1_header = (struct mach_header_64*)&checkra1n[0];
	if (c1_header->magic != MH_MAGIC_64 && c1_header->magic != MH_CIGAM_64) {
		LOG(LOG_FATAL, "Broken build: checkra1n is not a thin Mach-O");
		return -1;
	}
	if (c1_header->cputype != _mh_execute_header.cputype) {
		LOG(LOG_FATAL, "Broken build: checkra1n CPU type does not match palera1n CPU type");
		return -1;
	}
#endif
	if (checkra1n_len <= (UCHAR_MAX + 1)) {
		LOG(LOG_FATAL, "checkra1n too small");
	}
	if (boyermoore_horspool_memmem(&checkra1n[0], checkra1n_len, (const unsigned char *)"[ra1npoc15-part] thanks to", strlen("[ra1npoc15-part] thanks to")) != NULL) {
		palerain_flags |= palerain_option_checkrain_is_clone;
	}
#endif
	return 0;
}

#ifdef TUI
bool tui_started = false;
#endif

#ifdef USE_LIBUSB
void log_cb(libusb_context *ctx, enum libusb_log_level level, const char *str) {
    LOG(level + 0, "%s", str);
}
#endif

// save argc, argv, and envp for restarting

int saved_argc;
char** saved_argv;
char** saved_envp;

static int palera1n(int argc, char *argv[], char *envp[]) {
	saved_argc = argc;
	saved_argv = argv;
	saved_envp = envp;
	
	print_credits();
	int ret = 0;
	pthread_mutex_init(&log_mutex, NULL);
	pthread_mutex_init(&spin_mutex, NULL);
	pthread_mutex_init(&found_pongo_mutex, NULL);
	pthread_mutex_init(&ecid_dfu_wait_mutex, NULL);
	if ((ret = build_checks())) return ret;
	if ((ret = optparse(argc, argv))) goto cleanup;
	if (!(palerain_flags & palerain_option_device_info) && (palerain_flags & palerain_option_palerain_version)) goto normal_exit;
#ifdef TUI
	if ((palerain_flags & palerain_option_tui) || (isatty(STDIN_FILENO) && isatty(STDOUT_FILENO) && !(palerain_flags & palerain_option_cli))) {
		ret = tui();
		if (ret) goto cleanup;
		else goto normal_exit;
	}
#endif
#ifdef USE_LIBUSB
	{
		libusb_set_log_cb(NULL, log_cb, LIBUSB_LOG_CB_GLOBAL);
		libusb_context* ctx = NULL;
		int test_libusb = libusb_init(&ctx);
		if (test_libusb) {
			LOG(LOG_ERROR, "cannot initialize libusb: %d (%s)\n", test_libusb, libusb_strerror(test_libusb));
			libusb_exit(ctx);
			goto cleanup;
		}
	libusb_exit(ctx);
	}
#endif

	if (!(palerain_flags & palerain_option_device_info))
		LOG(LOG_INFO, "Waiting for devices");

	if (getenv("USBMUXD_SOCKET_ADDRESS") == NULL && access("/var/run/usbmuxd", F_OK) != 0) 
		LOG(LOG_WARNING, "/var/run/usbmuxd not found, normal mode device detection will not work.");
	
	pthread_create(&pongo_thread, NULL, pongo_helper, NULL);
	pthread_create(&dfuhelper_thread, NULL, dfuhelper, NULL);
	pthread_join(dfuhelper_thread, NULL);
	set_spin(0);
	if ((palerain_flags & (palerain_option_dfuhelper_only | 
											  palerain_option_reboot_device  | 
											  palerain_option_exit_recovery  | 
											  palerain_option_enter_recovery | 
											  palerain_option_device_info)
								 ) || device_has_booted)
		goto normal_exit;
	pthread_cancel(pongo_thread);
	pthread_join(pongo_thread, NULL);
	if (exec_checkra1n()) goto cleanup;

	if ((palerain_flags & (palerain_option_pongo_exit | palerain_option_demote)))
		goto normal_exit;
	set_spin(1);
	sleep(2);
	pthread_create(&pongo_thread, NULL, pongo_helper, NULL);
	pthread_join(pongo_thread, NULL);
	while (get_spin())
	{
		sleep(1);
	}
normal_exit:
cleanup:
	if (override_kpf.magic == OVERRIDE_MAGIC) {
		munmap(override_kpf.ptr, (size_t)override_kpf.len);
		close(override_kpf.fd);
	}
	if (override_ramdisk.magic == OVERRIDE_MAGIC) {
		munmap(override_ramdisk.ptr, (size_t)override_ramdisk.len);
		close(override_ramdisk.fd);
	}
	if (override_overlay.magic == OVERRIDE_MAGIC) {
		munmap(override_overlay.ptr, (size_t)override_overlay.len);
		close(override_overlay.fd);
	}
	if (ext_checkra1n != NULL) free(ext_checkra1n);
	pthread_mutex_destroy(&log_mutex);
	pthread_mutex_destroy(&spin_mutex);
	pthread_mutex_destroy(&found_pongo_mutex);
	pthread_mutex_destroy(&ecid_dfu_wait_mutex);
	return ret;
}


int main (int argc, char* argv[], char* envp[]) {
	return palera1n(argc, argv, envp);
}

```

`src/optparse.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <stddef.h>
#include <unistd.h>
#include <stdarg.h>
#include <ctype.h>
#include <assert.h>
#include <getopt.h>
#include <limits.h>
#include <errno.h>
#include <palerain.h>
#include <sys/mman.h>
#include <inttypes.h>
#include <sys/stat.h>
#ifdef TUI
#include <tui.h>
#endif

uint64_t* palerain_flags_p = &palerain_flags;
char* gOverrideLibcheckra1nHelper = NULL;

static struct option longopts[] = {
	{"setup-partial-fakefs", no_argument, NULL, 'B'},
	{"setup-fakefs", no_argument, NULL, 'c'},
	{"clean-fakefs", no_argument, NULL, 'C'},
	{"dfuhelper", no_argument, NULL, 'D'},
	{"help", no_argument, NULL, 'h'},
	{"pongo-shell", no_argument, NULL, 'p'},
	{"pongo-full", no_argument, NULL, 'P'},
	{"debug-logging", no_argument, NULL, 'v'},
	{"verbose-boot", no_argument, NULL, 'V'},
	{"boot-args", required_argument, NULL, 'e'},
	{"fakefs", no_argument, NULL, 'f'},
	{"rootless", no_argument, NULL, 'l'},
	{"demote", no_argument, NULL, 'd'},
	{"force-revert", no_argument, NULL, palerain_option_case_force_revert},
	{"no-colors", no_argument, NULL, 'S'},
	{"safe-mode", no_argument, NULL, 's'},
	{"telnetd", no_argument, NULL, 'T'},
	{"version", no_argument, NULL, palerain_option_case_version},
	{"override-libcheckra1nhelper", required_argument, NULL, palerain_option_case_libcheckra1nhelper_path},
	{"override-pongo", required_argument, NULL, 'k'},
	{"override-overlay", required_argument, NULL, 'o'},
	{"override-ramdisk", required_argument, NULL, 'r'},
	{"override-kpf", required_argument, NULL, 'K'},
	{"override-checkra1n", required_argument, NULL, 'i'},
	{"reboot-device", no_argument, NULL, 'R'},
	{"exit-recovery", no_argument, NULL, 'n'},
	{"enter-recovery", no_argument, NULL, 'E'},
	{"device-info", no_argument, NULL, 'I'},
#ifdef DEV_BUILD
	{"test1", no_argument, NULL, '1'},
	{"test2", no_argument, NULL, '2'},
#endif
#ifdef TUI
	{"tui", no_argument, NULL, 't'},
#endif
	{"cli", no_argument, NULL, palerain_option_case_cli},
	{NULL, 0, NULL, 0}
};

static int usage(int e, char* prog_name)
{
	fprintf(stderr,
	"Usage: %s [-"
	"DEhpvVldsSTLRnPI"
#ifdef DEV_BUILD
			"12"
#endif
#ifdef ROOTFUL
			"cCfB"
#endif
#ifdef TUI
			"t"
#endif
			"] [-e boot arguments] [-k Pongo image] [-o overlay file] [-r ramdisk file] [-K KPF file] [-i checkra1n file]\n"
			"Copyright (C) 2024, palera1n team, All Rights Reserved.\n\n"
			"iOS/iPadOS/tvOS 15.0-26.0, bridgeOS 5.0-10.0 arm64 jailbreaking tool\n\n"
			"\t--version\t\t\t\tPrint version\n"
			"\t--force-revert\t\t\t\tRemove jailbreak\n"
#ifdef DEV_BUILD
			"\t-1, --test1\t\t\t\tSet palerain_option_test1\n"
			"\t-2, --test2\t\t\t\tSet palerain_option_test2\n"
#endif
#ifdef ROOTFUL
			"\t-B, --setup-partial-fakefs\t\tSetup partial fakefs\n"
			"\t-c, --setup-fakefs\t\t\tSetup fakefs\n"
			"\t-C, --clean-fakefs\t\t\tClean fakefs\n"
#endif
			"\t-d, --demote\t\t\t\tDemote\n"
			"\t-D, --dfuhelper\t\t\t\tExit after entering DFU\n"
			"\t-e, --boot-args <boot arguments>\tXNU boot arguments\n"
			"\t-E, --enter-recovery\t\t\tEnter recovery mode\n"
#ifdef ROOTFUL
			"\t-f, --fakefs \t\t\t\tBoots fakefs\n"
#endif
			"\t-h, --help\t\t\t\tShow this help\n"
			"\t-i, --override-checkra1n <file>\t\tOverride checkra1n\n"
			"\t-k, --override-pongo <file>\t\tOverride Pongo image\n"
			"\t-K, --override-kpf <file>\t\tOverride kernel patchfinder\n"
#ifdef ROOTFUL
			"\t-l, --rootless\t\t\t\tBoots rootless. This is the default\n"
#endif
			"\t-L, --jbinit-log-to-file\t\tMake jbinit log to /cores/jbinit.log (can be read from sandbox while jailbroken)\n"
			"\t-n, --exit-recovery\t\t\tExit recovery mode\n"
			"\t-I, --device-info\t\t\tPrint info about the connected device\n"
			"\t-o, --override-overlay <file>\t\tOverride overlay\n"
			"\t-p, --pongo-shell\t\t\tBoots to PongoOS shell\n"
			"\t-P, --pongo-full\t\t\tBoots to a PongoOS shell with default images already uploaded\n"
			"\t-r, --override-ramdisk <file>\t\tOverride ramdisk\n"
			"\t-R, --reboot-device\t\t\tReboot connected device in normal mode\n"
			"\t-s, --safe-mode\t\t\t\tEnter safe mode\n"
			"\t-S, --no-colors\t\t\t\tDisable colors on the command line\n"
			"\t-T, --telnetd\t\t\t\tEnable TELNET daemon on port 46 (insecure)\n"
			"\t-v, --debug-logging\t\t\tEnable debug logging\n"
			"\t\tThis option can be repeated for extra verbosity.\n"
			"\t-V, --verbose-boot\t\t\tVerbose boot\n"

#ifdef TUI
			"\t-t, --tui\t\t\t\tForce interactive TUI\n"
			"\t--cli\t\t\t\t\tForce cli mode\n"
#endif
		"\nEnvironmental variables:\n"
		"\tTMPDIR\t\ttemporary diretory (path the built-in checkra1n will be extracted to)\n"
			,
			prog_name);
	exit(e);
}

int optparse(int argc, char* argv[]) {
	int opt;
	int index;
	while ((opt = getopt_long(argc, argv,
	"DEhpvVlLdsSTtRnPIe:o:r:K:k:i:"
#ifdef DEV_BUILD
	"12"
#endif
#ifdef ROOTFUL
	"fCcB"
#endif
	,longopts, NULL)) != -1)
	{
		switch (opt) {
#ifdef ROOTFUL
		case 'B':
			palerain_flags |= palerain_option_setup_partial_root;
			palerain_flags |= palerain_option_setup_rootful;
			break;
		case 'c':
			palerain_flags |= palerain_option_setup_rootful;
			break;
		case 'C':
			palerain_flags |= palerain_option_clean_fakefs;
			break;
#endif
		case 'p':
			palerain_flags |= palerain_option_pongo_exit;
			break;
		case 'P':
			palerain_flags |= palerain_option_pongo_full;
			break;
		case 'D':
			palerain_flags |= palerain_option_dfuhelper_only;
			break;
		case 'h':
			usage(0, argv[0]);
			assert(0);
		case 'v':
			verbose++;
			break;
		case 'V':
			palerain_flags |= palerain_option_verbose_boot;
#ifdef TUI
			tui_options_verbose_boot = true;
#endif
			break;
		case 'e':
			if (strlen(optarg) > (sizeof(xargs_cmd) - 0x20)) {
                LOG(LOG_FATAL, "Boot arguments too long");
                return -1;
            }
			snprintf(xargs_cmd, sizeof(xargs_cmd), "xargs %s", optarg);
#ifdef TUI
			snprintf(tui_options_boot_args, sizeof(tui_options_boot_args), "%s", optarg);
#endif
			break;
#ifdef ROOTFUL
		case 'f':
			palerain_flags |= palerain_option_rootful;
			palerain_flags &= ~palerain_option_rootless;
			break;
#endif
		case 'l':
			palerain_flags &= ~palerain_option_rootful;
			palerain_flags |= palerain_option_rootless;
			break;
		case 'L':
			palerain_flags |= palerain_option_jbinit_log_to_file;
			break;
		case 'd':
			palerain_flags |= palerain_option_demote;
			break;
		case 'E':
			palerain_flags |= palerain_option_enter_recovery;
			break;
		case 's':
			palerain_flags |= palerain_option_safemode;
#ifdef TUI
			tui_options_safe_mode = true;
#endif
			break;
		case 'T':
			palerain_flags |= palerain_option_telnetd;
			break;
		case 'k':
			if (access(optarg, F_OK) != 0) {
				LOG(LOG_FATAL, "Cannot access pongo file at %s: %d (%s)", optarg, errno, strerror(errno));
				return -1;
			}
			pongo_path = malloc(strlen(optarg) + 1);
			if (pongo_path == NULL) {
				LOG(LOG_FATAL, "memory allocation failed");
				return -1;
			}
			snprintf(pongo_path, strlen(optarg) + 1, "%s", optarg);
			break;
		case 'o':
			if (override_file(&override_overlay, overlay_to_upload, &binpack_dmg_len, optarg))
				return 1;
			break;
		case 'r':
			if (override_file(&override_ramdisk, ramdisk_to_upload, &ramdisk_dmg_lzma_len, optarg))
				return 1;
			break;
		case 'K':
			if (override_file(&override_kpf, kpf_to_upload, &checkra1n_kpf_pongo_lzma_len, optarg))
				return 1;
			struct mach_header_64* hdr = (struct mach_header_64*)override_kpf.ptr;
			if (hdr->magic != MH_MAGIC_64 && hdr->magic != MH_CIGAM_64) {
				LOG(LOG_FATAL, "Invalid kernel patchfinder: Not thin 64-bit Mach-O");
				return -1;
			} else if (hdr->filetype != MH_KEXT_BUNDLE) {
				LOG(LOG_FATAL, "Invalid kernel patchfinder: Not a kext bundle");
				return -1;
			} else if (hdr->cputype != CPU_TYPE_ARM64) {
				LOG(LOG_FATAL, "Invalid kernel patchfinder: CPU type is not arm64");
				return -1;
			}
			break;
		case 'i': {};
			struct stat st;
			if (stat(optarg, &st) != 0) {
				LOG(LOG_FATAL, "cannot stat external checkra1n file: %d (%s)", errno, strerror(errno));
				return -1;
			} else if (!(st.st_mode & S_IXUSR) && !(st.st_mode & S_IXGRP) && !(st.st_mode & S_IXOTH)) {
				LOG(LOG_FATAL, "%s is not executable", optarg);
				return -1;
			} else if (!S_ISREG(st.st_mode)) {
				LOG(LOG_FATAL, "%s is not a regular file", optarg);
				return -1;
			}
			if (st.st_size < (UCHAR_MAX+1)) {
				LOG(LOG_FATAL, "%s too small", optarg);
				return -1;
			}
			int checkra1n_fd = open(optarg, O_RDONLY);
			if (checkra1n_fd == -1) {
				LOG(LOG_FATAL, "Cannot open %s: %d (%s)", optarg, errno, strerror(errno));
				return -1;
			}
			void* addr = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, checkra1n_fd, 0);
			if (addr == MAP_FAILED) {
				LOG(LOG_ERROR, "Failed to map file %s: %d (%s)", optarg, errno, strerror(errno));
				return -1;
			}
			if (boyermoore_horspool_memmem(addr, st.st_size, (const unsigned char*)"[ra1npoc15-part] thanks to", strlen("[ra1npoc15-part] thanks to")) != NULL) 
				{
					palerain_flags |= palerain_option_checkrain_is_clone;
					LOG(LOG_VERBOSE3, "%s is checkra1n clone", optarg);
				}
			else
			{
				palerain_flags &= ~palerain_option_checkrain_is_clone;
				LOG(LOG_VERBOSE3, "%s is checkra1n", optarg);
			}
			munmap(addr, st.st_size);
			close(checkra1n_fd);
			ext_checkra1n = calloc(1, strlen(optarg) + 1);
			snprintf(ext_checkra1n, strlen(optarg) + 1, "%s", optarg);
			break;
		case 'R':
			palerain_flags |= palerain_option_reboot_device;
			break;
		case 'n':
			palerain_flags |= palerain_option_exit_recovery;
			break;
		case 'I':
			palerain_flags |= palerain_option_device_info;
			break;
		case 'S':
			palerain_flags |= palerain_option_no_colors;
			break;
#ifdef TUI
		case 't':
			palerain_flags |= palerain_option_tui;
			break;
#endif
		case palerain_option_case_cli:
			palerain_flags |= palerain_option_cli;
			break;
#ifdef DEV_BUILD
		case '1':
			palerain_flags |= palerain_option_test1;
			break;
		case '2':
			palerain_flags |= palerain_option_test2;
			break;
#endif
		case palerain_option_case_force_revert:
			palerain_flags |= palerain_option_force_revert;
#ifdef TUI
			tui_options_force_revert = true;
#endif
			break;
		case palerain_option_case_version:
			palerain_flags |= palerain_option_palerain_version;
			break;
		case palerain_option_case_libcheckra1nhelper_path:
			printf("meow\n");
			gOverrideLibcheckra1nHelper = calloc(1, strlen(optarg) + 1);
			if (!gOverrideLibcheckra1nHelper) {
				return -1;
			}
			snprintf(gOverrideLibcheckra1nHelper, strlen(optarg) + 1, "%s", optarg);
			break;
		default:
			usage(1, argv[0]);
			break;
		}
	}
	if ((palerain_flags & palerain_option_palerain_version)) {
		printf(
			"palera1n " PALERAIN_VERSION "\n"
			BUILD_COMMIT " " BUILD_NUMBER " (" BUILD_BRANCH ")\n\n"
			"Build style: " BUILD_STYLE "\n"
			"Build tag: " BUILD_TAG "\n"
#ifdef USE_LIBUSB
			"USB backend: libusb\n"
#else
			"USB backend: IOKit\n"
#endif
			"Build options: " BUILD_OPTIONS "\n"
		);
		return 0;
	}

	if (palerain_flags & palerain_option_telnetd) {
		LOG(LOG_WARNING, "telnetd is enabled, this is a security hole");
	}

	if ((palerain_flags & (palerain_option_tui)) && (palerain_flags & (palerain_option_cli))) {
		LOG(LOG_FATAL, "cannot specify both --tui and --cli");
		return -1;
	}

	if ((palerain_flags & (palerain_option_exit_recovery | palerain_option_enter_recovery | palerain_option_reboot_device | palerain_option_device_info | palerain_option_dfuhelper_only | palerain_option_pongo_exit | palerain_option_pongo_full)) > 0) {
		palerain_flags &= ~palerain_option_tui;
		palerain_flags |= palerain_option_cli;
	} else {
#ifdef ROOTFUL
		if ((palerain_flags & (palerain_option_rootless | palerain_option_rootful)) == 0) {
			LOG(LOG_FATAL, "Please specify rootful (-f) or rootless (-l)");
			return -1;
		}
#else
		palerain_flags |= palerain_option_rootless;
#endif
	}
    
	snprintf(palerain_flags_cmd, 0x30, "palera1n_flags 0x%" PRIx64, palerain_flags);
	LOG(LOG_VERBOSE3, "palerain_flags: %s", palerain_flags_cmd);
	if (override_kpf.magic == OVERRIDE_MAGIC) {
		LOG(LOG_VERBOSE4, "kpf override length %" PRIu32 " -> %" PRIu32, override_kpf.orig_len, checkra1n_kpf_pongo_lzma_len);
		LOG(LOG_VERBOSE4, "kpf override ptr %p -> %p", override_kpf.orig_ptr, **kpf_to_upload);
	}
	if (override_ramdisk.magic == OVERRIDE_MAGIC) {
		LOG(LOG_VERBOSE4, "ramdisk override length %" PRIu32 " -> %" PRIu32, override_ramdisk.orig_len, ramdisk_dmg_lzma_len);
		LOG(LOG_VERBOSE4, "ramdisk override ptr %p -> %p", override_ramdisk.orig_ptr, **ramdisk_to_upload);
	}
	if (override_overlay.magic == OVERRIDE_MAGIC) {
		LOG(LOG_VERBOSE4, "overlay override length %" PRIu32 " -> %" PRIu32, override_overlay.orig_len, binpack_dmg_len);
		LOG(LOG_VERBOSE4, "overlay override ptr %p -> %p", override_overlay.orig_ptr, **overlay_to_upload);
	}
#ifdef ROOTFUL
	if (!(palerain_flags & palerain_option_rootful)) {
		if ((palerain_flags & palerain_option_setup_rootful)) {
			LOG(LOG_FATAL, "Cannot setup rootful when rootless is requested. Use -f to enable rootful mode.");
			return -1;
		}
	}
#endif
	if (!(
			(palerain_flags & palerain_option_dfuhelper_only) ||
			(palerain_flags & palerain_option_enter_recovery) ||
			(palerain_flags & palerain_option_exit_recovery) ||
			(palerain_flags & palerain_option_reboot_device)))
	{
#ifdef NO_CHECKRAIN
		if (checkra1n_len == 0 && ext_checkra1n == NULL)
		{
			LOG(LOG_FATAL, "checkra1n omitted in build but no override specified");
			return -1;
		}
		if (!((palerain_flags & palerain_option_pongo_exit) || (palerain_flags & palerain_option_pongo_exit)))
		{
#ifdef NO_KPF
			if (checkra1n_kpf_pongo_lzma_len == 0)
			{
				LOG(LOG_FATAL, "kernel patchfinder omitted in build but no override specified");
				return -1;
			}
#endif
		}
#endif

#ifdef NO_EMBED_HELPER
	if (libcheckra1nhelper_dylib_len == 0 && gOverrideLibcheckra1nHelper == NULL) {
			LOG(LOG_FATAL, "checkra1n helper omitted in build but no override specified");
			return -1;
	}
#endif
	}

	for (index = optind; index < argc; index++)
	{
		if (!strcmp("windows", argv[index]))
		{
			fprintf(stderr,
					"Windows not really using for manipulating OSX images,\n"
					"compiled in mingw tool for this working unstable and incorrectly\n");
			return -2;
		}
		else
		{
			fprintf(stderr, "%s: unknown argument: %s\n", argv[0], argv[index]);
			usage(1, argv[0]);
		}
	}
	if (verbose >= 2) setenv("LIBUSB_DEBUG", "1", 1);

	if (verbose >= 3)
	{
		libusbmuxd_set_debug_level(verbose - 2);
		irecv_set_debug_level(1);
		setenv("LIBUSB_DEBUG", "2", 1);
	}
	if (verbose >= 4) {
		idevice_set_debug_level(1);
		setenv("LIBUSB_DEBUG", "3", 1);
	}
	if (verbose >= 5)
		setenv("LIBUSB_DEBUG", "4", 1);
    return 0;
}

```

`src/override_file.c`:

```c
#include <palerain.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <stddef.h>
#include <unistd.h>
#include <stdarg.h>
#include <ctype.h>
#include <assert.h>
#include <getopt.h>
#include <sys/mman.h>
#include <errno.h>
#include <sys/stat.h>

int override_file(override_file_t *finfo, niarelap_file_t** orig, unsigned int *orig_len, char *filename) {
	int ret = 0;
	int fd = open(filename, O_RDONLY);
	LOG(LOG_VERBOSE5, "override_file() called!");
	if (fd == -1) {
		LOG(LOG_ERROR, "Cannot open file %s: %d (%s)", filename, errno, strerror(errno));
		return errno;
	}
	LOG(LOG_VERBOSE5, "override_file: opened %s!", filename);
	struct stat st;
	ret = fstat(fd, &st);
	if (ret) {
		LOG(LOG_ERROR, "Cannot fstat fd from file %s: %d (%s)", filename, errno, strerror(errno));
		return errno;
	}
	LOG(LOG_VERBOSE5, "override_file: fstat fd %d succeeded!", fd);	
	void *addr = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
	if (addr == MAP_FAILED) {
		LOG(LOG_ERROR, "Failed to map file %s: %d (%s)", filename, errno, strerror(errno));
		return errno;
	}
	LOG(LOG_VERBOSE5, "override_file: Override file mapped successfully");
	finfo->magic = OVERRIDE_MAGIC;
	finfo->fd = fd;
	finfo->len = (unsigned int)st.st_size;;
	finfo->ptr = *(niarelap_file_t*)addr;
	finfo->orig_len = *orig_len;
	finfo->orig_ptr = **orig;
	*orig = (niarelap_file_t*)addr;
	*orig_len = (unsigned int)st.st_size;
	LOG(LOG_VERBOSE5, "override_file() finished!");
	return 0;
}

```

`src/pongo_helper.c`:

```c
#include <errno.h>
#include <fcntl.h>              // open
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>             // exit, strtoull
#include <string.h>             // strlen, strerror, memcpy, memmove
#include <unistd.h>             // close
#include <sys/mman.h>           // mmap, munmap
#include <sys/stat.h>           // fstst

#include <palerain.h>
#ifdef TUI
#include <tui.h>
#endif
#include <ANSI-color-codes.h>

bool device_has_booted = 0;
int pongo_thr_running = 0;

#define ERR(...) LOG(LOG_VERBOSE, __VA_ARGS__)

static int issue_pongo_command(usb_device_handle_t, char*);
static int upload_pongo_file(usb_device_handle_t, unsigned char*, unsigned int);
static void write_stdout(char *buf, uint32_t len);

void* pongo_helper(void* ptr) {
	pongo_thr_running = 1;
	pthread_cleanup_push(thr_cleanup, &pongo_thr_running);
	wait_for_pongo();
	while (get_spin()) {
		sleep(1);
	}
	pthread_cleanup_pop(1);
	return NULL;
}

static void *pongo_usb_callback(stuff_t *arg) {
	if (get_found_pongo())
		return NULL;
	set_found_pongo(1);
#ifdef ROOTFUL
	if ((palerain_flags & palerain_option_setup_rootful)) {
		strncat(xargs_cmd, " wdt=-1", 0x270 - strlen(xargs_cmd) - 1);	
	}
#endif
	LOG(LOG_INFO, "Found PongoOS USB Device");
	if (palerain_flags & palerain_option_pongo_exit)
		goto done;

	usb_device_handle_t handle = arg->handle;
#ifdef TUI
	if (tui_is_jailbreaking) {
		tui_jailbreak_stage = 4;
    	tui_jailbreak_status = "Sending PongoOS commands";
    	tui_jailbreak_status_changed();
	}
#endif
	issue_pongo_command(handle, NULL);	
	issue_pongo_command(handle, "fuse lock");
	issue_pongo_command(handle, "sep auto");
#ifdef TUI
	if (tui_is_jailbreaking) {
		tui_jailbreak_stage = 5;
    	tui_jailbreak_status = "Sending KPF";
    	tui_jailbreak_status_changed();
	}
#endif
	upload_pongo_file(handle, **kpf_to_upload, checkra1n_kpf_pongo_lzma_len);
	if (*kpf_to_upload == &checkra1n_kpf_pongo_lzma) {
		issue_pongo_command(handle, "modload " KPF_UNCOMPRESSED_SIZE);
	} else {
		issue_pongo_command(handle, "modload");
	}
	issue_pongo_command(handle, palerain_flags_cmd);
#ifdef NO_RAMDISK
	if (ramdisk_dmg_lzma_len != 0)
#endif
	{
#ifdef TUI
		if (tui_is_jailbreaking) {
			tui_jailbreak_stage = 6;
			tui_jailbreak_status = "Sending ramdisk";
			tui_jailbreak_status_changed();
		}
#endif
		upload_pongo_file(handle, **ramdisk_to_upload, ramdisk_dmg_lzma_len);
		if ((*ramdisk_to_upload) == &ramdisk_dmg_lzma)
			issue_pongo_command(handle, "ramdisk " RAMDISK_UNCOMPRESSED_SIZE);
		else {
			issue_pongo_command(handle, "ramdisk");
		}
	}
#ifdef NO_OVERLAY
	if (binpack_dmg_len != 0)
#endif
	{
#ifdef TUI
		if (tui_is_jailbreaking) {
			tui_jailbreak_stage = 7;
			tui_jailbreak_status = "Sending binpack";
			tui_jailbreak_status_changed();
		}
#endif
		upload_pongo_file(handle, **overlay_to_upload, binpack_dmg_len);
		issue_pongo_command(handle, "overlay");
	}
	issue_pongo_command(handle, xargs_cmd);
	if ((palerain_flags & palerain_option_pongo_full)) goto done;

#ifdef TUI
	if (tui_is_jailbreaking) {
		tui_jailbreak_stage = 8;
		tui_jailbreak_status = "Booting";
		tui_jailbreak_status_changed();
	}
#endif
	issue_pongo_command(handle, "bootx");
	LOG(LOG_INFO, "Booting Kernel...");
#ifdef ROOTFUL
	if ((palerain_flags & palerain_option_setup_partial_root)) {
		LOG(LOG_INFO, "Please wait up to 5 minutes for the bindfs to be created.");
		LOG(LOG_INFO, "Once the device reboots into recovery mode, run again without the -B (Create BindFS) option to jailbreak.");
	} else if ((palerain_flags & palerain_option_setup_rootful)) {
		LOG(LOG_INFO, "Please wait up to 10 minutes for the fakefs to be created.");
		LOG(LOG_INFO, "Once the device reboots into recovery mode, run again without the -c (Create FakeFS) option to jailbreak.");
	}
#endif
	if (dfuhelper_thr_running) {
		pthread_cancel(dfuhelper_thread);
		dfuhelper_thr_running = false;
	}
done:
	device_has_booted = true;

#ifdef TUI
	if (tui_is_jailbreaking) {
		tui_jailbreak_stage = 9;
		tui_jailbreak_status = "All Done";
		tui_is_jailbreaking = false;
		tui_jailbreak_status_changed();
	}
#endif
#ifdef USE_LIBUSB
	libusb_unref_device(arg->dev);
#endif
	set_spin(0);
	return NULL;
}

static int issue_pongo_command(usb_device_handle_t handle, char *command)
{
	uint32_t outpos = 0;
	uint32_t outlen = 0;
	int ret = USB_RET_SUCCESS;
	uint8_t in_progress = 1;
	if (command == NULL) goto fetch_output;
	size_t len = strlen(command);
	char command_buf[512];
	char stdout_buf[0x2000];
	if (len > (CMD_LEN_MAX - 2))
	{
		LOG(LOG_ERROR, "Pongo command %s too long (max %d)", command, CMD_LEN_MAX - 2);
		return EINVAL;
	}
    if (verbose < 3 || verbose > 4) {
	    LOG(LOG_VERBOSE, "Executing PongoOS command: '%s'", command);
    } else {
        printf("%s\n", command);
    }
	snprintf(command_buf, 512, "%s\n", command);
	len = strlen(command_buf);
	ret = USBControlTransfer(handle, 0x21, 4, 1, 0, 0, NULL, NULL);
	if (ret)
		goto bad;
	ret = USBControlTransfer(handle, 0x21, 3, 0, 0, (uint32_t)len, command_buf, NULL);
fetch_output:
	while (in_progress) {
		ret = USBControlTransfer(handle, 0xa1, 2, 0, 0, (uint32_t)sizeof(in_progress), &in_progress, NULL);
		if (ret == USB_RET_SUCCESS)
		{
			ret = USBControlTransfer(handle, 0xa1, 1, 0, 0, 0x1000, stdout_buf + outpos, &outlen);
			if (ret == USB_RET_SUCCESS)
			{
				write_stdout(stdout_buf + outpos, outlen);
				outpos += outlen;
				if (outpos > 0x1000)
				{
					memmove(stdout_buf, stdout_buf + outpos - 0x1000, 0x1000);
					outpos = 0x1000;
				}
			}
		}
		if (ret != USB_RET_SUCCESS)
		{
			goto bad;
		}
	}
bad:
	if (ret != USB_RET_SUCCESS)
	{
        if (command != NULL && (!strncmp("boot", command, 4))) {
			if (ret == USB_RET_IO || ret == USB_RET_NO_DEVICE || ret == USB_RET_NOT_RESPONDING)
				return 0;
		}
		LOG(LOG_ERROR, "USB error: %s", usb_strerror(ret));
		return ret;
	}
	else
		return ret;
}

static int upload_pongo_file(usb_device_handle_t handle, unsigned char *buf, unsigned int buf_len)
{
	int ret = 0;
	ret = USBControlTransfer(handle, 0x21, 1, 0, 0, 4, &buf_len, NULL);
	if (ret == USB_RET_SUCCESS)
	{
		ret = USBBulkUpload(handle, buf, buf_len);
		if (ret == USB_RET_SUCCESS)
		{
		    if (verbose < 3 || verbose > 4) {
				LOG(LOG_VERBOSE, "Uploaded %llu bytes to PongoOS", (unsigned long long)buf_len);
    		} else {
				if ((palerain_flags & palerain_option_no_colors))
				    printf("/send mem:%p:%p\n[Uploaded %llu bytes]\n", (void*)buf, (void*)(buf + buf_len), (unsigned long long)buf_len);
				else
        			printf("/send mem:%p:%p\n" BCYN "[Uploaded %llu bytes]\n" CRESET, (void*)buf, (void*)(buf + buf_len), (unsigned long long)buf_len);
    		}
		}
	}
	if (verbose >= 3) printf("pongoOS> ");
	return ret;
}

void io_start(stuff_t *stuff)
{
    int r = pthread_create(&stuff->th, NULL, (pthread_start_t)pongo_usb_callback, stuff);
    if(r != 0)
    {
        ERR("pthread_create: %s", strerror(r));
        set_spin(0);
		return;
    }
    pthread_join(stuff->th, NULL);
}

void io_stop(stuff_t *stuff)
{
    int r = pthread_cancel(stuff->th);
    if(r != 0)
    {
        ERR("pthread_cancel: %s", strerror(r));
        set_spin(0);
		return;
    }
    r = pthread_join(stuff->th, NULL);
    if(r != 0)
    {
        ERR("pthread_join: %s", strerror(r));
        set_spin(0);
		return;
    }
#ifdef USE_LIBUSB
	libusb_unref_device(stuff->dev);
#endif
}

static void write_stdout(char *buf, uint32_t len)
{
    while(len > 0) {
        if (verbose >= 3) {
                ssize_t s = write(1, buf, len);
            if(s < 0) {
                LOG(LOG_ERROR, "write: %s", strerror(errno));
                pthread_exit(NULL);
            }
            buf += s;
            len -= s;
        } else break;
    }
}

```

`src/resources/.gitignore`:

```
*
!.gitignore

```

`src/tui_devhelper.c`:

```c
#ifdef TUI

#include <palerain.h>
#include <tui.h>

static irecv_device_t tui_get_recovery_device(uint64_t ecid) {
    irecv_client_t client = NULL;
	for (int i = 0; i <= 5; i++) {
		irecv_error_t err = irecv_open_with_ecid(&client, ecid);
		if (err == IRECV_E_UNSUPPORTED) {
			return NULL;
		}
		else if (err != IRECV_E_SUCCESS)
			sleep(1);
		else
			break;

		if (i == 5) {
			return NULL;
		}
	}

	irecv_device_t device = NULL;
	irecv_devices_get_device_by_client(client, &device);
    irecv_close(client);
    return device;
}

struct tui_connected_device *tui_connected_devices = NULL;

static void* tui_connected_recovery_mode(struct irecv_device_info* info) {
    //printf("Recovery mode device %" PRIu64 " connected\n", info->ecid);
    tui_last_event = TUI_EVENT_CONNECTED_DEVICES_CHANGED;
    sem_post(tui_event_semaphore);
	pthread_exit(NULL);
	return NULL;
}

static void* tui_disconnected_recovery_mode(struct irecv_device_info* info) {
    //printf("Recovery mode device %" PRIu64 " disconnected\n", info->ecid);
    tui_last_event = TUI_EVENT_CONNECTED_DEVICES_CHANGED;
    sem_post(tui_event_semaphore);
	pthread_exit(NULL);
	return NULL;
}

static void* tui_connected_dfu_mode(struct irecv_device_info* info) {
    //printf("DFU mode device %" PRIu64 " connected\n", info->ecid);
    tui_last_event = TUI_EVENT_CONNECTED_DEVICES_CHANGED;
    sem_post(tui_event_semaphore);
	pthread_exit(NULL);
	return NULL;
}

static void* tui_disconnected_dfu_mode(struct irecv_device_info* info) {
    //printf("DFU mode device %" PRIu64 " disconnected\n", info->ecid);
    tui_last_event = TUI_EVENT_CONNECTED_DEVICES_CHANGED;
    sem_post(tui_event_semaphore);
    pthread_exit(NULL);
    return NULL;
}

static int tui_connected_normal_mode(const usbmuxd_device_info_t *usbmuxd_device) {
    struct tui_connected_device *tui_dev = malloc(sizeof(struct tui_connected_device));
    snprintf(tui_dev->udid, sizeof(tui_dev->udid), "%s", usbmuxd_device->udid);
    tui_dev->next = tui_connected_devices;
    tui_dev->mode = TUI_DEVICE_MODE_NORMAL;
    tui_connected_devices = tui_dev;
	devinfo_t dev;
	int ret;
	ret = devinfo_cmd(&dev, usbmuxd_device->udid);
	if (ret != 0) {
		LOG(LOG_ERROR, "Unable to get device information");
        free(tui_dev);
		return 0;
	}
    snprintf(tui_dev->product_type, sizeof(tui_dev->product_type), "%s", dev.productType);
    snprintf(tui_dev->display_name, sizeof(tui_dev->display_name), "%s", dev.displayName);
    tui_dev->ecid = dev.ecid;
    if (strncmp(dev.CPUArchitecture, "arm64", strlen("arm64"))) {
        tui_dev->arm64 = false;
    } else {
        tui_dev->arm64 = true;
    }
    snprintf(tui_dev->version, sizeof(tui_dev->version), "%s", dev.productVersion);
	if (!strncmp(dev.productType, "iPhone10,", strlen("iPhone10,"))) {
		tui_dev->requires_passcode_disabled = true;
		unsigned char passcode_state = 0;
		ret = passstat_cmd(&passcode_state, usbmuxd_device->udid);
		if (ret != 0) {
			LOG(LOG_ERROR, "Failed to get passcode state");
			devinfo_free(&dev);
            free(tui_dev);
			return -1;
		}
		tui_dev->passcode_state = passcode_state;
    }

	//enter_recovery_cmd(usbmuxd_device->udid);
	devinfo_free(&dev);
	
    tui_last_event = TUI_EVENT_CONNECTED_DEVICES_CHANGED;
    sem_post(tui_event_semaphore);

	return 0;
}

static void tui_disconnected_normal_mode(const usbmuxd_device_info_t *usbmuxd_device) {
    struct tui_connected_device *cur = tui_connected_devices;
    struct tui_connected_device *prev = NULL;
    while (cur) {
        if (!strcmp(cur->udid, usbmuxd_device->udid)) {
            if (prev) {
                prev->next = cur->next;
            } else {
                tui_connected_devices = cur->next;
            }
            free(cur);
            break;
        }
        prev = cur;
        cur = cur->next;
    }

    tui_last_event = TUI_EVENT_CONNECTED_DEVICES_CHANGED;
    sem_post(tui_event_semaphore);
}

static void tui_device_event_cb(const usbmuxd_event_t *event, void* userdata) {
	if (event->device.conn_type != CONNECTION_TYPE_USB) return;
	switch (event->event) {
	case UE_DEVICE_ADD:
		LOG(LOG_VERBOSE, "Normal mode device connected");
		tui_connected_normal_mode(&event->device);
		break;
	case UE_DEVICE_REMOVE:
		LOG(LOG_VERBOSE, "Normal mode device disconnected");
        tui_disconnected_normal_mode(&event->device);
		break;
	}
}

static void tui_irecv_device_event_cb(const irecv_device_event_t *event, void* userdata) {
	pthread_t recovery_thread, dfu_thread;
	int ret;
	
	switch(event->type) {
		case IRECV_DEVICE_ADD: {
            struct tui_connected_device *dev = malloc(sizeof(struct tui_connected_device));
            dev->ecid = event->device_info->ecid;
            dev->next = tui_connected_devices;
            dev->arm64 = cpid_is_arm64(event->device_info->cpid);
            /*recvinfo_t info;
			ret = recvinfo_cmd(&info, event->device_info->ecid);
            if (ret) {
                LOG(LOG_WARNING, "Could not get info from device");
            } else {
                snprintf(dev->product_type, sizeof(dev->product_type), "%s", info.product_type);
                snprintf(dev->display_name, sizeof(dev->display_name), "%s", info.display_name);
            }*/
            irecv_device_t device = tui_get_recovery_device(event->device_info->ecid);
            if (!device) {
                LOG(LOG_WARNING, "Could not get info from device");
                free(dev);
                return;
            }
            snprintf(dev->product_type, sizeof(dev->product_type), "%s", device->product_type);
            snprintf(dev->display_name, sizeof(dev->display_name), "%s", device->display_name);
            dev->cpid = device->chip_id;
            tui_connected_devices = dev;

			if (event->mode == IRECV_K_RECOVERY_MODE_1 || 
				event->mode == IRECV_K_RECOVERY_MODE_2 || 
				event->mode == IRECV_K_RECOVERY_MODE_3 || 
				event->mode == IRECV_K_RECOVERY_MODE_4) {
				
                dev->mode = TUI_DEVICE_MODE_RECOVERY;
				pthread_create(&recovery_thread, NULL, (pthread_start_t)tui_connected_recovery_mode, event->device_info);
			} else if (event->mode == IRECV_K_DFU_MODE) {
                dev->mode = TUI_DEVICE_MODE_DFU;
				pthread_create(&dfu_thread, NULL, (pthread_start_t)tui_connected_dfu_mode, event->device_info);
			}
			break;
        }
		case IRECV_DEVICE_REMOVE: {
            struct tui_connected_device *cur = tui_connected_devices;
            struct tui_connected_device *prev = NULL;
            while (cur) {
                if (cur->ecid == event->device_info->ecid) {
                    if (prev) {
                        prev->next = cur->next;
                    } else {
                        tui_connected_devices = cur->next;
                    }
                    if (cur->mode == TUI_DEVICE_MODE_RECOVERY) {
                        LOG(LOG_VERBOSE, "Recovery mode device %" PRIu64 " disconnected", event->device_info->ecid);
				        pthread_create(&recovery_thread, NULL, (pthread_start_t)tui_disconnected_recovery_mode, event->device_info);
                    } else if (cur->mode == TUI_DEVICE_MODE_DFU) {
                        LOG(LOG_VERBOSE, "DFU mode device %" PRIu64 " disconnected", event->device_info->ecid);
				        pthread_create(&dfu_thread, NULL, (pthread_start_t)tui_disconnected_dfu_mode, event->device_info);
                    }
                    free(cur);
                    break;
                }
                prev = cur;
                cur = cur->next;
            }
		    break;
        }
	}
}

void tui_devhelper(void) {
    subscribe_cmd(tui_device_event_cb, tui_irecv_device_event_cb);
}

#else
/* ISO C forbids an empty translation unit */
extern char** environ;
#endif

```

`src/tui_input.c`:

```c
#ifdef TUI

#include <tui.h>

#ifdef __linux__
#include <gpm.h>
#endif

int tui_mouse_x = 0;
int tui_mouse_y = 0;
int tui_mouse_button = -1;

int tui_last_event = -1;
int tui_last_input = -1;
sem_t *tui_event_semaphore;
char tui_last_key = 0;

#ifdef __linux__
bool using_gpm = false;
#endif

int tui_get_input(void) {
    char c = getc(stdin);
    if (c == '\x1b' && getc(stdin) == '[') {
        char c3 = getc(stdin);
        switch (c3) {
        case 'D':
            return TUI_INPUT_LEFT;
        case 'C':
            return TUI_INPUT_RIGHT;
        case 'A':
            return TUI_INPUT_UP;
        case 'B':
            return TUI_INPUT_DOWN;
        case 'Z':
            return TUI_INPUT_TAB_BACK;
        case 'M': {
            char c4 = getc(stdin);
            char c5 = getc(stdin);
            char c6 = getc(stdin);

            int new_mouse_x = c5 - 33;
            if (new_mouse_x < 0) new_mouse_x += 256;
            int new_mouse_y = c6 - 33;
            if (new_mouse_y < 0) new_mouse_y += 256;
            int mouse_button = c4 & 3;

            if (tui_mouse_x != new_mouse_x || tui_mouse_y != new_mouse_y) {
                tui_mouse_x = new_mouse_x;
                tui_mouse_y = new_mouse_y;
                return TUI_INPUT_MOUSE_MOVE;
            }

            if (tui_mouse_button != (c4 & 1)) {
                tui_mouse_button = c4 & 1;
                if (tui_mouse_button == 0) {
                    return TUI_INPUT_MOUSE_DOWN;
                } else {
                    return TUI_INPUT_MOUSE_UP;
                }
            }

            break;
        }
        }
    }
    
    tui_last_key = c;

    if (c == '\x0d' || c == ' ') {
        return TUI_INPUT_SELECT;
    }

    if (c == '\t') {
        return TUI_INPUT_TAB;
    }

    if (c == '\x7f') {
        return TUI_INPUT_BACKSPACE;
    }

    if (c == '\x1b') {
        return TUI_INPUT_ESCAPE;
    }

    return TUI_INPUT_NONE;
}

#ifdef __linux__
void *tui_gpm_thread(void *arg) {
    Gpm_Event event;
    while (1) {
        if (Gpm_GetEvent(&event) == -1) {
            exit(1);
        }
        tui_mouse_x = event.x - 1;
        tui_mouse_y = event.y - 1;
        if (event.type & GPM_MOVE) {
            tui_last_event = TUI_EVENT_INPUT;
            tui_last_input = TUI_INPUT_MOUSE_MOVE;
            sem_post(tui_event_semaphore);
        }
        if (event.buttons & 4) {
            if (event.type & GPM_DOWN) {
                tui_mouse_button = 1;
                tui_last_event = TUI_EVENT_INPUT;
                tui_last_input = TUI_INPUT_MOUSE_DOWN;
                sem_post(tui_event_semaphore);
            } else if (event.type & GPM_UP) {
                tui_mouse_button = 0;
                tui_last_event = TUI_EVENT_INPUT;
                tui_last_input = TUI_INPUT_MOUSE_UP;
                sem_post(tui_event_semaphore);
            }
            continue;
        }
    }
}
#endif

void *tui_input_thread(void *arg) {
#ifdef __linux__
    if (strncmp(getenv("TERM"), "linux", 5) == 0) {
        Gpm_Connect conn;
        Gpm_Event event;
        conn.eventMask = GPM_UP | GPM_DOWN;
        conn.defaultMask = ~0;
        conn.minMod = 0;
        conn.maxMod = 0xffff;
        if (Gpm_Open(&conn, 0) != -1) {
            using_gpm = true;
            pthread_t gpm_thread;
            pthread_create(&gpm_thread, NULL, tui_gpm_thread, NULL);
        }
    }
#endif
    while (1) {
        int input = tui_get_input();
        tui_last_event = TUI_EVENT_INPUT;
        tui_last_input = input;
        sem_post(tui_event_semaphore);
    }
    return 0;
}

int tui_get_event(void) {
    sem_wait(tui_event_semaphore);
    int last_event = tui_last_event;
    tui_last_event = -1;
    return last_event;
}

int tui_try_get_event(void) {
    int ret = sem_trywait(tui_event_semaphore);
    if (ret == 0) {
        int last_event = tui_last_event;
        tui_last_event = -1;
        return last_event;
    }
    return -1;
}

#else
/* ISO C forbids an empty translation unit */
extern char** environ;
#endif

```

`src/tui_main.c`:

```c
#ifdef TUI
#ifdef __APPLE__
#define _DARWIN_C_SOURCE
#else
#define _DEFAULT_SOURCE
#endif
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <signal.h>
#include <inttypes.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <locale.h>
#include <unistd.h>
#include <assert.h>
#include <sys/ioctl.h>
#include <termios.h>
#include <unistd.h>
#include <time.h>

#include <palerain.h>
#include <tui.h>

#ifdef __APPLE__
int proc_pidpath(int pid, void * buffer, uint32_t buffersize);
char random_sem_name[sizeof("palera1n.tui_event_semaphore") + 16 + 1];
#endif

static int tui_state = 0;

int tui_x_offset = 0;
int tui_y_offset = 0;

bool supports_bright_colors = true;

static struct termios saved_termios;

int redraw_screen(void) {
    SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
    CLEAR_SCREEN;
    MOVETO(0, 0);
    
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    if (w.ws_col < 80 || w.ws_row < 24) {
        LOG(LOG_FATAL, "Terminal size must be at least 80x24");
        printf("\033[37;41mERROR: Terminal size must be at least 80x24!");
        fflush(stdout);
        return -1;
    }
    tui_y_offset = (w.ws_row - 24) / 2;
    for (int i = 0; i < tui_y_offset; i++) {
        printf("\n");
    }
    tui_x_offset = (w.ws_col - 80) / 2;
    
    const char* tui_version = TUI_VERSION;
    if (tui_version[0] == 'v') tui_version++;

    tui_draw_rectangle(0, 0, 79, 23);
    MOVETOT((int)(80 - (strlen("[palera1n - Version ]") + strlen(tui_version) ) - 1), 1);
    printf("[palera1n - Version %s]", tui_version);
    SETCOLOR(FG_WHITE, BG_BLACK);
    switch(tui_state) {
    case MAIN_SCREEN:
        tui_screen_main_redraw();
        break;
    case OPTIONS_SCREEN:
        tui_screen_options_redraw();
        break;
    case ENTER_RECOVERY_SCREEN:
        tui_screen_enter_recovery_redraw();
        break;
    case ENTER_DFU_SCREEN:
        tui_screen_enter_dfu_redraw();
        break;
    case JAILBREAK_SCREEN:
        tui_screen_jailbreak_redraw();
        break;
    }
    fflush(stdout);
    return 0;
}

static int destroy_window(void) {
    if (!tui_started) return 0;
    tui_started = false;
    tcsetattr(STDIN_FILENO, 0, &saved_termios);
    MOUSEOFF;
    CLEAR_SCREEN;

    MOVETO(0, 0);
    RMCUP;
    CNORM;
    
    return 0;
}

static int init_window(void) {
    setlocale(LC_ALL, NULL);

    tui_started = true;
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    if (w.ws_col < 80 || w.ws_row < 24) {
        tui_started = false;
        LOG(LOG_FATAL, "Terminal size must be at least 80x24");
        return -1;
    }
    LOG(LOG_VERBOSE3, "cols: %d, rows: %d\n", w.ws_col, w.ws_row);
    SMCUP;
    CIVIS;
    fflush(stdout);
    struct termios term;
    tcgetattr(STDIN_FILENO, &term);
    tcgetattr(STDIN_FILENO, &saved_termios);
    cfmakeraw(&term);
    term.c_lflag |= ISIG;
    tcsetattr(STDIN_FILENO, 0, &term);

    MOUSEON;

    return 0;
}

bool tui_is_restarting = false;

extern int saved_argc;
extern char** saved_argv;
extern char** saved_envp;

void tui_terminate(int sig) {
    destroy_window();
    if (tui_is_restarting) {
#ifdef __APPLE__
    sem_close(tui_event_semaphore);
    sem_unlink(random_sem_name);
    char pathbuf[4096];
    if (proc_pidpath(getpid(), pathbuf, sizeof(pathbuf)) <= 0) {
        LOG(LOG_FATAL, "Failed to get path of running executable");
        exit(1);
    }
    
    execve(pathbuf, saved_argv, saved_envp);
#elif defined(__linux__)
    execve("/proc/self/exe", saved_argv, saved_envp);
#endif
    } else {
        exit(0);
    }
}

static void resize_handler(int sig) {
    redraw_screen();
}

int tui(void) {
    if (strncmp(getenv("TERM"), "xterm", 5) != 0) {
        supports_bright_colors = false;
    }
    srand(time(NULL));
    int ret = 0;
    if ((ret = init_window())) return ret;
    signal(SIGINT, tui_terminate);
    signal(SIGTERM, tui_terminate);
    signal(SIGQUIT, tui_terminate);
    signal(SIGWINCH, resize_handler);

#ifdef __APPLE__
    // generate a 16 character random hex string from urandom
    int fd = open("/dev/urandom", O_RDONLY);
    if (fd < 0) {
        LOG(LOG_FATAL, "Failed to open /dev/urandom");
        return -1;
    }
    uint8_t random[8];
    if (read(fd, random, 8) != 8) {
        LOG(LOG_FATAL, "Failed to read from /dev/urandom");
        return -1;
    }
    close(fd);
    for (int i = 0; i < 8; i++) {
        sprintf(&random_sem_name[i * 2], "%02x", random[i]);
    }
    sem_unlink(random_sem_name);
    tui_event_semaphore = sem_open(random_sem_name, O_CREAT, 0644, 0);
#else
    tui_event_semaphore = malloc(sizeof(sem_t));
    sem_init(tui_event_semaphore, 0, 0);
#endif
    pthread_t input_thread;
    pthread_create(&input_thread, NULL, tui_input_thread, NULL);

    tui_devhelper();

    tui_state = MAIN_SCREEN;
    while (1) {
        switch (tui_state) {
        case ERROR_SCREEN:
        case EXIT_SCREEN:
            goto out;
            break;
        case MAIN_SCREEN:
            tui_state = tui_screen_main();
            break;
        case OPTIONS_SCREEN:
            tui_state = tui_screen_options();
            break;
        case ENTER_RECOVERY_SCREEN:
            tui_state = tui_screen_enter_recovery();
            break;
        case ENTER_DFU_SCREEN:
            tui_state = tui_screen_enter_dfu();
            break;
        case JAILBREAK_SCREEN:
            tui_state = tui_screen_jailbreak();
            break;
        default:
            assert(0);
            goto out;
        }
    }
out:
    destroy_window();
    return 0;
}

void tui_draw_rectangle(int x1, int y1, int x2, int y2) {
    if (x1 == x2 || y1 == y2) return;
    DSGON;
    MOVETOT(x1 + 1, y1 + 1);
    printf("%c", 0x6C);
    for (int x = x1 + 1; x < x2; x++) {
        putchar(0x71);
    }
    putchar(0x6B);
    MOVETOT(x1 + 1, y2 + 1);
    putchar(0x6D);
    for (int x = x1 + 1; x < x2; x++) {
        putchar(0x71);
    }
    putchar(0x6A);
    for (int y = y1 + 1; y < y2; y++) {
        PRINTATT(x1 + 1, y + 1, "\x78");
        PRINTATT(x2 + 1, y + 1, "\x78");
    }
    DSGOFF;
    fflush(stdout);
}

#else
/* ISO C forbids an empty translation unit */
extern char** environ;
#endif

```

`src/tui_screen_enter_dfu.c`:

```c
#ifdef TUI
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <locale.h>
#include <unistd.h>
#include <assert.h>

#include <palerain.h>
#include <tui.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <locale.h>
#include <unistd.h>
#include <assert.h>
#include <time.h>

#include <palerain.h>
#include <tui.h>

static int tui_enter_dfu_nav_selection = 1;
static bool tui_device_is_entering_dfu = false;
static int tui_enter_dfu_status = 0;

enum {
    DEVICE_TYPE_IPHONE_SE,
    DEVICE_TYPE_IPHONE_6S,
    DEVICE_TYPE_IPHONE_7_8,
    DEVICE_TYPE_IPHONE_X,
    DEVICE_TYPE_IPAD,
    DEVICE_TYPE_IPOD_TOUCH
} device_type;

static int tui_product_type_to_device_type(char *product_type) {
    if (strcmp(product_type, "iPhone8,1") == 0 || strcmp(product_type, "iPhone8,2") == 0) {
        return DEVICE_TYPE_IPHONE_6S;
    }
    if (strcmp(product_type, "iPhone8,4") == 0) return DEVICE_TYPE_IPHONE_SE;
    if (strcmp(product_type, "iPhone9,1") == 0 || strcmp(product_type, "iPhone9,2") == 0
        || strcmp(product_type, "iPhone9,3") == 0 || strcmp(product_type, "iPhone9,4") == 0) {
        return DEVICE_TYPE_IPHONE_7_8;
    }
    if (strcmp(product_type, "iPhone10,1") == 0 || strcmp(product_type, "iPhone10,2") == 0
        || strcmp(product_type, "iPhone10,4") == 0 || strcmp(product_type, "iPhone10,5") == 0) {
        return DEVICE_TYPE_IPHONE_7_8;
    }
    if (strcmp(product_type, "iPhone10,3") == 0 || strcmp(product_type, "iPhone10,6") == 0) {
        return DEVICE_TYPE_IPHONE_X;
    }
    if (strncmp(product_type, "iPad", strlen("iPad")) == 0) {
        return DEVICE_TYPE_IPAD;
    }
    if (strcmp(product_type, "iPod9,1") == 0) {
        return DEVICE_TYPE_IPOD_TOUCH;
    }

    // Not found
    return DEVICE_TYPE_IPHONE_SE;
}

static int tui_enter_dfu_device_type = DEVICE_TYPE_IPHONE_SE;

static int tui_enter_dfu_loading_progress = 1;

static void tui_screen_enter_dfu_nav(void) {
    MOVETOT(80 - 22, 23);
    printf("%s[ Cancel ]" COLOR(FG_WHITE, BG_BLACK) " %s[  %s ]" COLOR(FG_WHITE, BG_BLACK),
        tui_device_is_entering_dfu || tui_enter_dfu_status == 1 ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : tui_enter_dfu_nav_selection == 0 ? "\033[30;107m" : (
            (
                tui_mouse_x >= tui_x_offset + 80 - 23 && tui_mouse_x <= tui_x_offset + 80 - 23 + 10
            ) && (tui_mouse_y == tui_y_offset + 22) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ),
        tui_device_is_entering_dfu || tui_enter_dfu_status == 1 ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : tui_enter_dfu_nav_selection == 1 ? "\033[30;107m" : (
            (
                tui_mouse_x >= tui_x_offset + 80 - 12 && tui_mouse_x <= tui_x_offset + 80 - 12 + 10
            ) && (tui_mouse_y == tui_y_offset + 22) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ),
        tui_enter_dfu_status == 2 ? "Retry" : "Start"
    );
}

void tui_screen_enter_dfu_redraw(void) {
    SETCOLOR(FG_WHITE, BG_BLACK);
    switch(tui_enter_dfu_status) {
    case 0:
        PRINTATT(3, 3, "Time to put the device into DFU mode. Locate the buttons as marked below on");
        PRINTATT(3, 4, "your device and check the instructions on the right *before* clicking Start.");
        break;
    case 1:
        PRINTATT(3, 3, "Device entered DFU mode successfully.");
        break;
    case 2:
        PRINTATT(3, 3, "Whoops, the device didn't enter DFU mode. Click Retry to try again.");
        break;
    }
    
    tui_screen_enter_dfu_nav();

    switch(tui_enter_dfu_device_type) {
    case DEVICE_TYPE_IPHONE_SE:
    case DEVICE_TYPE_IPAD:
        if (tui_enter_dfu_loading_progress > 0 || tui_enter_dfu_status == 2) {
            if (supports_bright_colors) {
                SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
            } else {
                SETCOLOR(FG_BLUE, BG_BLACK);
            }
        }
        PRINTATT(51, 6, "1. Click Start");
        if (tui_enter_dfu_loading_progress > 0) {
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }

        if (!tui_device_is_entering_dfu || tui_enter_dfu_loading_progress > 4 || tui_enter_dfu_status == 2) {
            if (supports_bright_colors) {
                SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
            } else {
                SETCOLOR(FG_BLUE, BG_BLACK);
            }
        }
        PRINTATT(51, 7, "2. Press and hold the Top and");
        MOVETOT(54, 8);
        printf("Home buttons together (%d)", tui_enter_dfu_loading_progress > 4 ? 0 : tui_enter_dfu_loading_progress < 1 ? 4 : 5 - tui_enter_dfu_loading_progress);
        if (!tui_device_is_entering_dfu || tui_enter_dfu_loading_progress > 4) {
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }

        if (tui_enter_dfu_loading_progress < 5 || tui_enter_dfu_loading_progress > 14 || tui_enter_dfu_status == 2) {
            if (supports_bright_colors) {
                SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
            } else {
                SETCOLOR(FG_BLUE, BG_BLACK);
            }
        }
        PRINTATT(51, 9, "3. Release the Top button BUT");
        PRINTATT(54, 10, "KEEP HOLDING the Home");
        MOVETOT(54, 11);
        printf("button (%d)", tui_enter_dfu_loading_progress > 14 ? 0 : tui_enter_dfu_loading_progress < 5 ? 10 : 15 - tui_enter_dfu_loading_progress);
        if (tui_enter_dfu_loading_progress < 5 || tui_enter_dfu_loading_progress > 14) {
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }
        break;
    case DEVICE_TYPE_IPHONE_6S:
        if (tui_enter_dfu_loading_progress > 0 || tui_enter_dfu_status == 2) {
            if (supports_bright_colors) {
                SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
            } else {
                SETCOLOR(FG_BLUE, BG_BLACK);
            }
        }
        PRINTATT(51, 6, "1. Click Start");
        if (tui_enter_dfu_loading_progress > 0) {
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }

        if (!tui_device_is_entering_dfu || tui_enter_dfu_loading_progress > 4 || tui_enter_dfu_status == 2) {
            if (supports_bright_colors) {
                SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
            } else {
                SETCOLOR(FG_BLUE, BG_BLACK);
            }
        }
        PRINTATT(51, 7, "2. Press and hold the Side");
        PRINTATT(54, 8, "and Home buttons together");
        MOVETOT(54, 9);
        printf("(%d)", tui_enter_dfu_loading_progress > 4 ? 0 : tui_enter_dfu_loading_progress < 1 ? 4 : 5 - tui_enter_dfu_loading_progress);
        if (!tui_device_is_entering_dfu || tui_enter_dfu_loading_progress > 4) {
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }

        if (tui_enter_dfu_loading_progress < 5 || tui_enter_dfu_loading_progress > 14 || tui_enter_dfu_status == 2) {
            if (supports_bright_colors) {
                SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
            } else {
                SETCOLOR(FG_BLUE, BG_BLACK);
            }
        }
        PRINTATT(51, 10, "3. Release the Side button");
        PRINTATT(54, 11, "BUT KEEP HOLDING the Home");
        MOVETOT(54, 12);
        printf("button (%d)", tui_enter_dfu_loading_progress > 14 ? 0 : tui_enter_dfu_loading_progress < 5 ? 10 : 15 - tui_enter_dfu_loading_progress);
        if (tui_enter_dfu_loading_progress < 5 || tui_enter_dfu_loading_progress > 14) {
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }
        break;
    case DEVICE_TYPE_IPHONE_7_8:
    case DEVICE_TYPE_IPHONE_X:
        tui_draw_rectangle(17, 5, 33, 21);
        PRINTATT(17, 10, "|");
        MOVETOT(5, 11);
        printf("%sVolume down-", tui_enter_dfu_loading_progress > 14 ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : COLOR(FG_YELLOW, BG_BLACK));
        SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        putchar('|');
        DSGON;
        MOVETOT(35, 10);
        putchar(0x78);
        DSGOFF;
        printf("%s-Side button", tui_enter_dfu_loading_progress > 4 ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : COLOR(FG_YELLOW, BG_BLACK));
        SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);

        if (tui_enter_dfu_loading_progress > 0 || tui_enter_dfu_status == 2) {
            if (supports_bright_colors) {
                SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
            } else {
                SETCOLOR(FG_BLUE, BG_BLACK);
            }
        }
        PRINTATT(51, 6, "1. Click Start");
        if (tui_enter_dfu_loading_progress > 0) {
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }

        if (!tui_device_is_entering_dfu || tui_enter_dfu_loading_progress > 4 || tui_enter_dfu_status == 2) {
            if (supports_bright_colors) {
                SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
            } else {
                SETCOLOR(FG_BLUE, BG_BLACK);
            }
        }
        PRINTATT(51, 7, "2. Press and hold the Side");
        PRINTATT(54, 8, "and Volume down buttons");
        MOVETOT(54, 9);
        printf("together (%d)", tui_enter_dfu_loading_progress > 4 ? 0 : tui_enter_dfu_loading_progress < 1 ? 4 : 5 - tui_enter_dfu_loading_progress);
        if (!tui_device_is_entering_dfu || tui_enter_dfu_loading_progress > 4) {
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }

        if (tui_enter_dfu_loading_progress < 5 || tui_enter_dfu_loading_progress > 14 || tui_enter_dfu_status == 2) {
            if (supports_bright_colors) {
                SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
            } else {
                SETCOLOR(FG_BLUE, BG_BLACK);
            }
        }
        PRINTATT(51, 10, "3. Release the Side button");
        PRINTATT(54, 11, "BUT KEEP HOLDING the");
        MOVETOT(54, 12);
        printf("Volume down button (%d)", tui_enter_dfu_loading_progress > 14 ? 0 : tui_enter_dfu_loading_progress < 5 ? 10 : 15 - tui_enter_dfu_loading_progress);
        if (tui_enter_dfu_loading_progress < 5 || tui_enter_dfu_loading_progress > 14) {
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }
        break;
    }

    switch(tui_enter_dfu_device_type) {
    case DEVICE_TYPE_IPHONE_SE:
        tui_draw_rectangle(18, 6, 32, 21);
        tui_draw_rectangle(24, 19, 26, 20);
        for (int y = 9; y < 20; y++) {
            SETCOLOR(FG_BLACK, BG_BRIGHT_BLACK);
            PRINTATT(20, y, "             ");
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }
        PRINTATT(23, 8, "o ===");
        PRINTATT(18, 11, "|");
        PRINTATT(18, 12, "|");
        MOVETOT(30, 6);
        printf("__ %s-Top button", tui_enter_dfu_loading_progress > 4 ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : COLOR(FG_YELLOW, BG_BLACK));
        SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        MOVETOT(31, 20);
        printf("%s-Home button", tui_enter_dfu_loading_progress > 14 ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : COLOR(FG_YELLOW, BG_BLACK));
        SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);

        break;
    case DEVICE_TYPE_IPHONE_6S:
        tui_draw_rectangle(17, 5, 33, 21);
        tui_draw_rectangle(24, 19, 26, 20);
        for (int y = 8; y < 20; y++) {
            SETCOLOR(FG_BLACK, BG_BRIGHT_BLACK);
            PRINTATT(19, y, "               ");
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }
        PRINTATT(23, 7, "o ===");
        PRINTATT(17, 10, "|");
        PRINTATT(17, 11, "|");
        MOVETOT(35, 10);
        printf("|%s-Side button", tui_enter_dfu_loading_progress > 4 ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : COLOR(FG_YELLOW, BG_BLACK));
        SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        MOVETOT(30, 20);
        printf("%s-Home button", tui_enter_dfu_loading_progress > 14 ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : COLOR(FG_YELLOW, BG_BLACK));
        SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        break;
    case DEVICE_TYPE_IPHONE_7_8:
        tui_draw_rectangle(24, 19, 26, 20);
        for (int y = 8; y < 20; y++) {
            SETCOLOR(FG_BLACK, BG_BRIGHT_BLACK);
            PRINTATT(19, y, "               ");
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }
        PRINTATT(23, 7, "o ===");

        break;
    case DEVICE_TYPE_IPHONE_X:
        SETCOLOR(FG_BLACK, BG_BRIGHT_BLACK);
        PRINTATT(19, 7, "    ");
        SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        printf("       ");
        SETCOLOR(FG_BLACK, BG_BRIGHT_BLACK);
        printf("    ");
        SETCOLOR(FG_BLACK, BG_BRIGHT_BLACK);
        for (int y = 8; y < 22; y++) {
            PRINTATT(19, y, "               ");
        }
        SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);

        DSGON;
        MOVETOT(35, 11);
        putchar(0x78);
        DSGOFF;
        
        break;
    case DEVICE_TYPE_IPAD:
        tui_draw_rectangle(14, 6, 36, 21);
        tui_draw_rectangle(24, 19, 26, 20);
        for (int y = 9; y < 20; y++) {
            SETCOLOR(FG_BLACK, BG_BRIGHT_BLACK);
            PRINTATT(16, y, "                     ");
            SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        }
        PRINTATT(23, 8, "o ===");
        PRINTATT(14, 11, "|");
        PRINTATT(14, 12, "|");
        MOVETOT(33, 6);
        printf("__  %s-Top button", tui_enter_dfu_loading_progress > 4 ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : COLOR(FG_YELLOW, BG_BLACK));
        SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);
        MOVETOT(29, 21);
        printf("%s-Home button", tui_enter_dfu_loading_progress > 14 ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : COLOR(FG_YELLOW, BG_BLACK));
        SETCOLOR(FG_BRIGHT_WHITE, BG_BLACK);

        break;
    }
    fflush(stdout);
}

// TODO: IMPLEMENT REAL ENTER RECOVERY
static int dfu_time = 0;

static tui_screen_t tui_enter_dfu(void) {
    if (tui_connected_devices && !tui_connected_devices->next) {
        if (tui_connected_devices->mode == TUI_DEVICE_MODE_NORMAL) {
            tui_enter_dfu_status = 0;
            return ENTER_RECOVERY_SCREEN;
        }
    }
    int i = 0;
    tui_enter_dfu_loading_progress = 1;
    while(1) {
        if (++i % 10 == 0) {
            tui_enter_dfu_loading_progress++;
        }
        redraw_screen();
        usleep(100000);
        int event = tui_try_get_event();
        if (event == TUI_EVENT_CONNECTED_DEVICES_CHANGED) {
            if (tui_connected_devices && !tui_connected_devices->next) {
                if (tui_connected_devices->mode == TUI_DEVICE_MODE_RECOVERY || tui_connected_devices->mode == TUI_DEVICE_MODE_NORMAL) {
                    tui_enter_dfu_status = 2;
                    tui_device_is_entering_dfu = false;
                    return ENTER_DFU_SCREEN;
                } else {
                    tui_enter_dfu_status = 1;
                    tui_device_is_entering_dfu = false;
                    tui_enter_dfu_loading_progress = 15;
                    redraw_screen();
                    sleep(3);
                    tui_jailbreak();
                    return JAILBREAK_SCREEN;
                }
            }
        }
        if (i > 10 * (60 + 15)) {
            return MAIN_SCREEN;
        }
        if (i == 10 * 2) {
            exitrecv_cmd(tui_connected_devices->ecid);
        }
    }
    redraw_screen();
    fflush(stdout);
    sleep(3);
    return JAILBREAK_SCREEN;
}

static int tui_enter_dfu_nav_mouse_select = -1;

tui_screen_t tui_screen_enter_dfu(void) {
    if (tui_connected_devices && !tui_connected_devices->next) {
        tui_enter_dfu_device_type = tui_product_type_to_device_type(tui_connected_devices->product_type);
    }

    tui_device_is_entering_dfu = false;
    tui_enter_dfu_loading_progress = 0;
    tui_enter_dfu_nav_selection = 1;
    redraw_screen();
    
    tui_device_is_entering_dfu = false;
    tui_enter_dfu_loading_progress = 0;

    while(1) {
        int event = tui_get_event();
        switch (event) {
            case TUI_EVENT_CONNECTED_DEVICES_CHANGED:
                break;
            case TUI_EVENT_INPUT: {
                int input = tui_last_input;
                if (input == TUI_INPUT_NONE) continue;
                if (tui_device_is_entering_dfu) continue;

                switch (input) {
                    case TUI_INPUT_LEFT:
                    case TUI_INPUT_RIGHT:
                        tui_enter_dfu_nav_selection = !tui_enter_dfu_nav_selection;
                        redraw_screen();
                        break;
                    case TUI_INPUT_SELECT:
                        switch(tui_enter_dfu_nav_selection) {
                        case 0:
                            return MAIN_SCREEN;
                        case 1:
                            tui_device_is_entering_dfu = true;
                            redraw_screen();
                            return tui_enter_dfu();
                        }
                    case TUI_INPUT_MOUSE_MOVE:
                        tui_screen_enter_dfu_nav();
                        fflush(stdout);
                        break;
                    case TUI_INPUT_MOUSE_DOWN:
                        if (tui_mouse_y == tui_y_offset + 22) {
                            if (tui_mouse_x >= tui_x_offset + 80 - 23 && tui_mouse_x <= tui_x_offset + 80 - 23 + 10) {
                                tui_enter_dfu_nav_selection = 0;
                                tui_enter_dfu_nav_mouse_select = 0;
                                redraw_screen();
                            } else if (tui_mouse_x >= tui_x_offset + 80 - 12 && tui_mouse_x <= tui_x_offset + 80 - 12 + 10) {
                                tui_enter_dfu_nav_selection = 1;
                                tui_enter_dfu_nav_mouse_select = 1;
                                redraw_screen();
                            }
                        }
                        break;
                    case TUI_INPUT_MOUSE_UP:
                        if (tui_mouse_y == tui_y_offset + 22) {
                            if (tui_mouse_x >= tui_x_offset + 80 - 23 && tui_mouse_x <= tui_x_offset + 80 - 23 + 10) {
                                return MAIN_SCREEN;
                            } else if (tui_mouse_x >= tui_x_offset + 80 - 12 && tui_mouse_x <= tui_x_offset + 80 - 12 + 10) {
                                tui_device_is_entering_dfu = true;
                                redraw_screen();
                                return tui_enter_dfu();
                            }
                        }
                        tui_enter_dfu_nav_mouse_select = -1;
                        break;
                }
                break;
            }
        }
    }
    return MAIN_SCREEN;
}
#else
/* ISO C forbids an empty translation unit */
extern char** environ;
#endif

```

`src/tui_screen_enter_recovery.c`:

```c
#ifdef TUI
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <locale.h>
#include <unistd.h>
#include <assert.h>
#include <time.h>
#include <poll.h>
#include <palerain.h>
#include <tui.h>

int tui_enter_recovery_nav_selection = 1;
bool tui_device_is_entering_recovery = false;
bool tui_enter_recovery_mode_failed = false;

static void tui_screen_enter_recovery_nav(void) {
    MOVETOT(80 - 22, 23);
    printf("%s[  Back  ]" COLOR(FG_WHITE, BG_BLACK) " %s[  Next  ]" COLOR(FG_WHITE, BG_BLACK),
        tui_device_is_entering_recovery ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : tui_enter_recovery_nav_selection == 0 ? "\033[30;107m" : (
            (
                tui_mouse_x >= tui_x_offset + 80 - 23 && tui_mouse_x <= tui_x_offset + 80 - 23 + 10
            ) && (tui_mouse_y == tui_y_offset + 22) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ),
        tui_device_is_entering_recovery ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : tui_enter_recovery_nav_selection == 1 ? "\033[30;107m" : (
            (
                tui_mouse_x >= tui_x_offset + 80 - 12 && tui_mouse_x <= tui_x_offset + 80 - 12 + 10
            ) && (tui_mouse_y == tui_y_offset + 22) ? COLOR(FG_BLACK, BG_WHITE) : ""
        )
    );
}

static char enter_recovery_loading[9][8] = {
    "........",
    "|.......",
    ".|......",
    "..|.....",
    "...|....",
    "....|...",
    ".....|..",
    "......|.",
    ".......|"
};

static char enter_recovery_loading_troll[9][8] = {
    ".......",
    "t......",
    ".r.....",
    "..o....",
    "...l...",
    "....l..",
    ".....e.",
    "......d",
};

static bool is_troll;
static int tui_enter_recovery_loading_progress = 0;

static void tui_screen_enter_recovery_loading(void) {
    SETCOLOR(FG_YELLOW, BG_BLACK);
    PRINTATT(3, 8, "Entering recovery mode ");
    printf("%.8s", is_troll ? enter_recovery_loading_troll[tui_enter_recovery_loading_progress] : enter_recovery_loading[tui_enter_recovery_loading_progress]);
    SETCOLOR(FG_WHITE, BG_BLACK);
    fflush(stdout);
}

void tui_screen_enter_recovery_redraw(void) {
    PRINTATT(3, 3, "The device needs to be put into DFU mode to apply the jailbreak. This is a");
    PRINTATT(3, 4, "manual process and we will guide you through it.");
    PRINTATT(3, 5, "In order to prevent filesystem corruption through hard reset, the device");
    PRINTATT(3, 6, "will be put into recovery mode first. Click Next when you are ready.");
    
    if (tui_enter_recovery_mode_failed) {
        SETCOLOR(FG_YELLOW, BG_BLACK);
        PRINTATT(3, 8, "Hmm... device did not enter recovery mode!? Click Next to try again...");
        SETCOLOR(FG_WHITE, BG_BLACK);
    }

    tui_screen_enter_recovery_nav();
    if (tui_device_is_entering_recovery) {
        tui_screen_enter_recovery_loading();
    }

    fflush(stdout);
}

static int recovery_time = 0;

static tui_screen_t tui_enter_recovery(void) {
    enter_recovery_cmd(tui_connected_devices->udid);
    is_troll = false;
    if (rand() % 1000 == 0) {
        is_troll = true;
    }
    int i = 0;
    recovery_time = 0;
    while(1) {
        redraw_screen();
        tui_enter_recovery_loading_progress++;
        tui_enter_recovery_loading_progress %= 9;
        // 100ms sleep
        struct timespec ts;
        ts.tv_sec = 0;
        ts.tv_nsec = 100000000;
        nanosleep(&ts, NULL);
        
        int event = tui_try_get_event();
        if (event == TUI_EVENT_CONNECTED_DEVICES_CHANGED) {
            if (tui_connected_devices && !tui_connected_devices->next && tui_connected_devices->mode == TUI_DEVICE_MODE_RECOVERY) {
                SETCOLOR(FG_YELLOW, BG_BLACK);
                PRINTATT(3, 8, "Device is now in recovery mode.");
                SETCOLOR(FG_WHITE, BG_BLACK);
                fflush(stdout);

                sleep(3);
                
                return ENTER_DFU_SCREEN;
            }
        }
        if (i > 60 * 10) {
            tui_enter_recovery_mode_failed = true;
            return ENTER_RECOVERY_SCREEN;
        }
    }
}

static int tui_enter_recovery_nav_mouse_select = -1;

tui_screen_t tui_screen_enter_recovery(void) {
    tui_device_is_entering_recovery = false;
    tui_enter_recovery_loading_progress = 0;
    tui_enter_recovery_nav_selection = 1;
    redraw_screen();
    
    while(1) {
        int event = tui_get_event();
        switch (event) {
            case TUI_EVENT_CONNECTED_DEVICES_CHANGED:
                tui_enter_recovery_mode_failed = false;
                return MAIN_SCREEN;
            case TUI_EVENT_INPUT: {
                int input = tui_last_input;
                if (input == TUI_INPUT_NONE) continue;
                if (tui_device_is_entering_recovery) continue;

                switch (input) {
                    case TUI_INPUT_LEFT:
                    case TUI_INPUT_RIGHT:
                        tui_enter_recovery_nav_selection = !tui_enter_recovery_nav_selection;
                        redraw_screen();
                        break;
                    case TUI_INPUT_SELECT:
                        switch(tui_enter_recovery_nav_selection) {
                        case 0:
                            tui_enter_recovery_mode_failed = false;
                            return MAIN_SCREEN;
                        case 1:
                            tui_device_is_entering_recovery = true;
                            redraw_screen();
                            return tui_enter_recovery();
                        }
                        break;
                    case TUI_INPUT_MOUSE_MOVE:
                        tui_screen_enter_recovery_nav();
                        fflush(stdout);
                        break;
                    case TUI_INPUT_MOUSE_DOWN:
                        if (tui_mouse_y == tui_y_offset + 22) {
                            if (tui_mouse_x >= tui_x_offset + 80 - 23 && tui_mouse_x <= tui_x_offset + 80 - 23 + 10) {
                                tui_enter_recovery_nav_selection = 0;
                                tui_enter_recovery_nav_mouse_select = 0;
                                tui_screen_enter_recovery_nav();
                                fflush(stdout);
                            } else if (tui_mouse_x >= tui_x_offset + 80 - 12 && tui_mouse_x <= tui_x_offset + 80 - 12 + 10) {
                                tui_enter_recovery_nav_selection = 1;
                                tui_enter_recovery_nav_mouse_select = 1;
                                tui_screen_enter_recovery_nav();
                                fflush(stdout);
                            }
                        }
                        break;
                    case TUI_INPUT_MOUSE_UP:
                        if (tui_mouse_y == tui_y_offset + 22) {
                            if (tui_mouse_x >= tui_x_offset + 80 - 23 && tui_mouse_x <= tui_x_offset + 80 - 23 + 10) {
                                return MAIN_SCREEN;
                            } else if (tui_mouse_x >= tui_x_offset + 80 - 12 && tui_mouse_x <= tui_x_offset + 80 - 12 + 10) {
                                tui_device_is_entering_recovery = true;
                                redraw_screen();
                                return tui_enter_recovery();
                            }
                        }
                        tui_enter_recovery_nav_mouse_select = -1;
                        break;
                }
                break;
            }
        }
    }
    tui_enter_recovery_mode_failed = false;
    return MAIN_SCREEN;
}
#else
/* ISO C forbids an empty translation unit */
extern char** environ;
#endif

```

`src/tui_screen_jailbreak.c`:

```c
#ifdef TUI
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <locale.h>
#include <unistd.h>
#include <assert.h>

#include <palerain.h>
#include <tui.h>

bool tui_is_jailbreaking = false;

static void tui_screen_jailbreak_nav(void) {
    if (tui_is_jailbreaking) {
        if (supports_bright_colors) {
            SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
        } else {
            SETCOLOR(FG_BLUE, BG_BLACK);
        }
    } else {
        SETCOLOR(FG_BLACK, BG_BRIGHT_WHITE);
    }
    PRINTATT(80 - 11, 23, "[  Done  ]");
    SETCOLOR(FG_WHITE, BG_BLACK);
}

static pthread_t tui_jailbreak_thread_id;

int tui_jailbreak_stage = 0;
char *tui_jailbreak_status = NULL;

void tui_jailbreak_status_changed(void) {
    tui_last_event = TUI_EVENT_JAILBREAK_STATUS_CHANGED;
    sem_post(tui_event_semaphore);
}

static void *tui_jailbreak_thread(void *arg) {
    tui_jailbreak_stage = 1;
    tui_jailbreak_status = "About to execute checkra1n";

    tui_jailbreak_status_changed();

    if (!tui_connected_devices || tui_connected_devices->next || tui_connected_devices->mode != TUI_DEVICE_MODE_DFU) {
        tui_jailbreak_status = "ERROR: No single device in DFU mode found";
        tui_jailbreak_status_changed();
        pthread_exit(NULL);
        return NULL;
    }

    tui_jailbreak_stage = 2;
    tui_jailbreak_status = "Running exploit";
    tui_jailbreak_status_changed();

    if (exec_checkra1n() != 0) {
        tui_jailbreak_status = "ERROR: Failed to run exploit";
        tui_jailbreak_status_changed();
        pthread_exit(NULL);
        return NULL;
    }

    tui_jailbreak_stage = 3;
    tui_jailbreak_status = "Waiting for PongoOS";
    tui_jailbreak_status_changed();

    sleep(2);
    pthread_create(&pongo_thread, NULL, pongo_helper, NULL);

    // pongo helper will take care of the rest

    pthread_exit(NULL);
}

void tui_jailbreak(void) {
    tui_is_jailbreaking = true;
    if (tui_options_verbose_boot) {
        palerain_flags |= palerain_option_verbose_boot;
    } else {
        palerain_flags &= ~palerain_option_verbose_boot;
    }

    if (tui_options_safe_mode) {
        palerain_flags |= palerain_option_safemode;
    } else {
        palerain_flags &= ~palerain_option_safemode;
    }

    if (tui_options_force_revert) {
        palerain_flags |= palerain_option_force_revert;
    } else {
        palerain_flags &= ~palerain_option_force_revert;
    }

    snprintf(palerain_flags_cmd, 0x30, "palera1n_flags 0x%" PRIx64, palerain_flags);
    snprintf(xargs_cmd, sizeof(xargs_cmd), "xargs %s", tui_options_boot_args);

    pthread_create(&tui_jailbreak_thread_id, NULL, tui_jailbreak_thread, NULL);
}

void tui_screen_jailbreak_redraw(void) {
    PRINTATT(3, 3, "Installing jailbreak, this will take a moment. If the device asks for a");
    PRINTATT(3, 4, "passcode please enter it. Do not disconnect the device until finished.");

    if (tui_jailbreak_status) {
        SETCOLOR(FG_YELLOW, BG_BLACK);
        PRINTATT(3, 6, tui_jailbreak_status);
        SETCOLOR(FG_WHITE, BG_BLACK);
    }

    tui_draw_rectangle(5, 9, 80 - 6, 9 + 2);
    MOVETOT(6 + 1, 10 + 1);
    SETCOLOR(FG_BLACK, BG_WHITE);
    for (int i = 0; i < ((80 - 12) * ((float)tui_jailbreak_stage / 9)); i++) {
        putchar(' ');
    }
    SETCOLOR(FG_WHITE, BG_BLACK);

    tui_screen_jailbreak_nav();
}

static int tui_jailbreak_nav_mouse_select = -1;

tui_screen_t tui_screen_jailbreak(void) {
    redraw_screen();

    while(1) {
        int event = tui_get_event();
        switch (event) {
        case TUI_EVENT_INPUT: {
            int input = tui_last_input;
            if (input == TUI_INPUT_NONE) continue;

            switch (input) {
            case TUI_INPUT_SELECT:
                if (!tui_is_jailbreaking) {
                    tui_is_restarting = true;
                    tui_terminate(0);
                }
                break;
            case TUI_INPUT_MOUSE_DOWN:
                if (tui_mouse_y == tui_y_offset + 24 - 2 &&
                    tui_mouse_x >= tui_x_offset + 80 - 12 &&
                    tui_mouse_x <= tui_x_offset + 80 - 12 + 10) {
                    tui_jailbreak_nav_mouse_select = 0;
                    redraw_screen();
                }
                break;
            case TUI_INPUT_MOUSE_UP:
                if (tui_jailbreak_nav_mouse_select == 0) {
                    tui_jailbreak_nav_mouse_select = -1;
                    if (!tui_is_jailbreaking) {
                        tui_is_restarting = true;
                        tui_terminate(0);
                    }
                }
                break;
            }
            break;
        }
        case TUI_EVENT_JAILBREAK_STATUS_CHANGED:
            redraw_screen();
            break;
        }
    }

    return EXIT_SCREEN;
}

#else
/* ISO C forbids an empty translation unit */
extern char** environ;
#endif

```

`src/tui_screen_main.c`:

```c
#ifdef TUI
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <locale.h>
#include <unistd.h>
#include <assert.h>

#include <palerain.h>
#include <tui.h>

static int tui_compare_versions(const char *firstVersion, const char *secondVersion);

static bool showing_ecid = false;

static char palera1n_logo[17][16] = {
"       ++       ",
"      #@@#      ",
"     +@@@@+     ",
"    :@@@@@@:    ",
"    #@@@@@@#    ",
"   +@@@@@@@@+   ",
"  :#*@@@@@@*#:  ",
"  %###@@@@###%  ",
" .####%@@%####. ",
" @############@ ",
"=@@*########*@@=",
"+@@@@%####%@@@@+",
":@@@@%%**%%@@@@:",
" +@@%%*@@*%%@@+ ",        
"   ++%@@@@%++   ",
"      :++:      "
};

static char random_quotes[][150] = {
    "panic(cpu 1 caller 0xfffffff0232bd958): SEP Panic",
    "Now with Apple TV support!",
    "checkra1n will open source in 2020",
    "Try running palera1n on a Intel 80486!",
    "\"iOS 15 with SSV is unhackable\", but here we are.",
    "initproc exited -- exit reason namespace 1 subcode0x7 description: none",
    "totally not checkra1n",
    "Because the command line wasn't easy enough",
    "Checkra1n wrapper?",
    ""
};

#define PALERA1N_URL "https://palera.in"

static int tui_main_nav_selection = 1;
static bool quick_mode_enabled = false;
static bool tui_can_start = false;
static int random_quote;

bool easter_egg = false;

void tui_screen_main_nav(void) {
    MOVETOT(80 - 52, 23);
    printf("[%c] %sQuick Mode " COLOR(FG_WHITE, BG_BLACK) " %s[ Options ]" COLOR(FG_WHITE, BG_BLACK) " %s[  Start  ]" COLOR(FG_WHITE, BG_BLACK) " %s[  Quit   ]" COLOR(FG_WHITE, BG_BLACK), quick_mode_enabled ? 'x' : ' ',
        tui_main_nav_selection == 0 ? COLOR(FG_BLACK, BG_BRIGHT_WHITE) : (
            (
                tui_mouse_x >= tui_x_offset + 80 - 49 && tui_mouse_x <= tui_x_offset + 80 - 49 + 10
            ) && (tui_mouse_y == tui_y_offset + 22) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ),
        tui_main_nav_selection == 1 ? COLOR(FG_BLACK, BG_BRIGHT_WHITE) : (
            (
                tui_mouse_x >= tui_x_offset + 80 - 37 && tui_mouse_x <= tui_x_offset + 80 - 37 + 10
            ) && (tui_mouse_y == tui_y_offset + 22) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ),
        tui_main_nav_selection == 2 ? COLOR(FG_BLACK, BG_BRIGHT_WHITE) : !tui_can_start ? (supports_bright_colors ? COLOR(FG_BRIGHT_BLACK, BG_BLACK) : COLOR(FG_BLUE, BG_BLACK)) : (
            (
                tui_mouse_x >= tui_x_offset + 80 - 25 && tui_mouse_x <= tui_x_offset + 80 - 25 + 10
            ) && (tui_mouse_y == tui_y_offset + 22) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ),
        tui_main_nav_selection == 3 ? COLOR(FG_BLACK, BG_BRIGHT_WHITE) : (
            (
                tui_mouse_x >= tui_x_offset + 80 - 13 && tui_mouse_x <= tui_x_offset + 80 - 13 + 10
            ) && (tui_mouse_y == tui_y_offset + 22) ? COLOR(FG_BLACK, BG_WHITE) : ""
        )
    );
}

void tui_screen_main_redraw(void) {
    PRINTATT(3, 2, "Welcome to palera1n!");

    SETCOLOR(FG_WHITE, BG_BLACK);
    PRINTATT(3, 9, "Made by: Nick Chan, Ploosh, Khcrysalis, Mineek");
    PRINTATT(3, 10, "staturnz, kok3shidoll, ");
    if ((tui_mouse_y == tui_y_offset + 9 && tui_mouse_x >= tui_x_offset + 25 && tui_mouse_x <= tui_x_offset + 25 + 8) || easter_egg) {
        SETCOLORA(FG_BRIGHT_WHITE, BG_BLACK, BOLD);
    }
    printf("HAHALOSAH");
    RESETFONT;
    SETCOLOR(FG_WHITE, BG_BLACK);
    PRINTATT(3, 12, "Thanks to: llsc12, nebula,");
    PRINTATT(3, 13, "nikias (libimobiledevice), checkra1n");
    PRINTATT(3, 14, "(Siguza, axi0mx, littlelailo et al.), Procursus");
    PRINTATT(3, 15, "Team (Hayden Seay, Cameron Katri, Keto et.al),");
    PRINTATT(80 - (int)sizeof(PALERA1N_URL), 21, PALERA1N_URL);
    PRINTATT(80 - (int)sizeof("@palera1n"), 20, "@palera1n");
    PRINTATT(3, 20, "With <3 from HAHALOSAH");
    PRINTATT(3, 21, "Note: Backup your stuff. Use at your own risk.");
    DRAWLINET(2, 22, 78);
    DRAWLINET(2, 3, 50);

    if (supports_bright_colors) {
        SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
    } else {
        SETCOLOR(FG_BLUE, BG_BLACK);
    }
    DRAWLINET(2, 11, 50);
    DRAWLINET(2, 16, 50);

    for (int y = 0; y < 16; y++) {
        PRINTATLENT(80 - 22, y + 4, palera1n_logo[y], 16);
    }

    SETCOLOR(FG_YELLOW, BG_BLACK);
    if (tui_connected_devices == NULL) {
        PRINTATT(3, 5, "Connect your iPhone, iPad, iPod Touch, or Apple");
        PRINTATT(3, 6, "TV to begin.");
        tui_can_start = false;
    } else if (tui_connected_devices->next != NULL) {
        PRINTATT(3, 5, "Please attach only one device.");
        tui_can_start = false;
    } else {
        if (strlen(tui_connected_devices->display_name) == 0) {
            PRINTATT(3, 5, "ERROR: Failed to open device in recovery/DFU mode");
            PRINTATT(3, 6, "Please reopen palera1n and try again.");
        } else if (tui_connected_devices->mode == TUI_DEVICE_MODE_NORMAL) {
            MOVETOT(3, 5);
            int ecid_y;
            if (!tui_connected_devices->arm64) {
                printf("Sorry, %s (iOS %s) is not supported.", tui_connected_devices->display_name, tui_connected_devices->version);
                ecid_y = 6;
                tui_can_start = false;
            } else if (tui_compare_versions(tui_connected_devices->version, "15.0") < 0) {
                printf("Sorry, %s is supported, but iOS", tui_connected_devices->display_name);
                MOVETOT(3, 6);
                printf("%s is not.", tui_connected_devices->version);
                PRINTATT(3, 7, "Supported versions are 15.0+");
                ecid_y = 8;
                tui_can_start = false;
             } else if (tui_connected_devices->requires_passcode_disabled) {
                printf("Sorry, this devices passcode must be disabled on %s.", tui_connected_devices->version);
                MOVETOT(3, 6);
                printf("On 16.0+, you must reset the phone to factory settings");
                MOVETOT(3, 7);
                printf("and not have a passcode enabled ever since last restore.");
                ecid_y = 8;
                tui_can_start = false;
            } else {
                printf("%s (%s) connected in Normal mode.", tui_connected_devices->display_name, tui_connected_devices->version);
                ecid_y = 6;
                tui_can_start = true;
            }
            if (showing_ecid) {
                MOVETOT(3, ecid_y);
                printf("ECID: 0x%" PRIx64 " ", tui_connected_devices->ecid);
            } else {
                PRINTATT(3, ecid_y, "Press (E) to show ECID.");
            }
        } else if (tui_connected_devices->mode == TUI_DEVICE_MODE_RECOVERY) {
            MOVETOT(3, 5);
            printf("%s connected in Recovery mode.", tui_connected_devices->display_name);
            if (showing_ecid) {
                MOVETOT(3, 6);
                printf("ECID: 0x%" PRIx64 " ", tui_connected_devices->ecid);
            } else {
                PRINTATT(3, 6, "Press (E) to show ECID.");
            }
            PRINTATT(3, 7, "NOTE: Ensure installed iOS is in range 15.0+");
            tui_can_start = true;
        } else if (tui_connected_devices->mode == TUI_DEVICE_MODE_DFU) {
            MOVETOT(3, 5);
            printf("%s connected in DFU mode.", tui_connected_devices->display_name);
            if (showing_ecid) {
                MOVETOT(3, 6);
                printf("ECID: 0x%" PRIx64 " ", tui_connected_devices->ecid);
            } else {
                PRINTATT(3, 6, "Press (E) to show ECID.");
            }
#ifdef DEV_BUILD
            tui_can_start = true;
#else
            PRINTATT(3, 7, "Please connect device in Normal/Recovery mode");
            PRINTATT(3, 8, "or run palera1n in CLI mode");
            tui_can_start = false;
#endif
        }
    }

    if (!tui_can_start && tui_main_nav_selection == 2) {
        tui_main_nav_selection = 1;
    }

    SETCOLOR(FG_WHITE, BG_BLACK);

    for (int y = 0; y < 3; y++) {
        PRINTATLEN(tui_x_offset + 3, tui_y_offset + 17 + y, random_quotes[random_quote] + y * 50, 50);
    }

    tui_screen_main_nav();
    fflush(stdout);
}

static int tui_main_nav_mouse_select = -1;

tui_screen_t tui_screen_main(void) {
    random_quote = ((unsigned int)((rand()+rand())/2)) % 8;
    redraw_screen();

    while(1) {
        int event = tui_get_event();
        switch (event) {
            case TUI_EVENT_CONNECTED_DEVICES_CHANGED:
                redraw_screen();
                break;
            case TUI_EVENT_INPUT: {
                int input = tui_last_input;

                switch (input) {
                    case TUI_INPUT_NONE:
                        if (tui_last_key == 'E' || tui_last_key == 'e') {
                            showing_ecid = !showing_ecid;
                            tui_screen_main_redraw();
                        }
                        break;
                    case TUI_INPUT_LEFT:
                    case TUI_INPUT_TAB_BACK:
                        if (--tui_main_nav_selection == -1) tui_main_nav_selection = 3;
                        if (tui_main_nav_selection == 2 && !tui_can_start) tui_main_nav_selection = 1;
                        tui_screen_main_nav();
                        fflush(stdout);
                        break;
                    case TUI_INPUT_RIGHT:
                    case TUI_INPUT_TAB:
                        if (++tui_main_nav_selection == 4) tui_main_nav_selection = 0;
                        if (tui_main_nav_selection == 2 && !tui_can_start) tui_main_nav_selection = 3;
                        tui_screen_main_nav();
                        fflush(stdout);
                        break;
                    case TUI_INPUT_SELECT:
                        switch(tui_main_nav_selection) {
                        case 0:
                            quick_mode_enabled = !quick_mode_enabled;
                            tui_screen_main_nav();
                            fflush(stdout);
                            break;
                        case 1:
                            return OPTIONS_SCREEN;
                        case 2:
                            if (tui_can_start) {
                                if (tui_connected_devices->mode == TUI_DEVICE_MODE_NORMAL) {
                                    return ENTER_RECOVERY_SCREEN;
                                } else if (tui_connected_devices->mode == TUI_DEVICE_MODE_RECOVERY) {
                                    return ENTER_DFU_SCREEN;
                                } else if (tui_connected_devices->mode == TUI_DEVICE_MODE_DFU) {
                                    tui_jailbreak();
                                    return JAILBREAK_SCREEN;
                                }
                            }
                            break;
                        case 3:
                            return EXIT_SCREEN;
                        }
                        break;
                    case TUI_INPUT_MOUSE_MOVE:
                        tui_screen_main_redraw();
                        break;
                    case TUI_INPUT_MOUSE_DOWN:
                        if ((tui_mouse_y == tui_y_offset + 9 && tui_mouse_x >= tui_x_offset + 25 && tui_mouse_x <= tui_x_offset + 25 + 8)) {
                            easter_egg = true;
                            break;
                        }
                        if (tui_mouse_y == tui_y_offset + 22) {
                            if (tui_mouse_x >= tui_x_offset + 80 - 49 && tui_mouse_x <= tui_x_offset + 80 - 49 + 10) {
                                tui_main_nav_selection = 0;
                                tui_main_nav_mouse_select = 0;
                            } else if (tui_mouse_x >= tui_x_offset + 80 - 37 && tui_mouse_x <= tui_x_offset + 80 - 37 + 10) {
                                tui_main_nav_selection = 1;
                                tui_main_nav_mouse_select = 1;
                            } else if (tui_mouse_x >= tui_x_offset + 80 - 25 && tui_mouse_x <= tui_x_offset + 80 - 25 + 10) {
                                if (tui_can_start) {
                                    tui_main_nav_selection = 2;
                                    tui_main_nav_mouse_select = 2;
                                }
                            } else if (tui_mouse_x >= tui_x_offset + 80 - 13 && tui_mouse_x <= tui_x_offset + 80 - 13 + 10) {
                                tui_main_nav_selection = 3;
                                tui_main_nav_mouse_select = 3;
                            }
                            tui_screen_main_nav();
                            fflush(stdout);
                        }
                        break;
                    case TUI_INPUT_MOUSE_UP:
                        if (tui_mouse_y == tui_y_offset + 22) {
                            if (tui_mouse_x >= tui_x_offset + 80 - 49 && tui_mouse_x <= tui_x_offset + 80 - 49 + 10 && tui_main_nav_mouse_select == 0) {
                                quick_mode_enabled = !quick_mode_enabled;
                                redraw_screen();
                            } else if (tui_mouse_x >= tui_x_offset + 80 - 37 && tui_mouse_x <= tui_x_offset + 80 - 37 + 10 && tui_main_nav_mouse_select == 1) {
                                return OPTIONS_SCREEN;
                            } else if (tui_mouse_x >= tui_x_offset + 80 - 25 && tui_mouse_x <= tui_x_offset + 80 - 25 + 10 && tui_main_nav_mouse_select == 2) {
                                if (tui_can_start) {
                                    if (tui_connected_devices->mode == TUI_DEVICE_MODE_NORMAL) {
                                        return ENTER_RECOVERY_SCREEN;
                                    } else if (tui_connected_devices->mode == TUI_DEVICE_MODE_RECOVERY) {
                                        return ENTER_DFU_SCREEN;
                                    } else if (tui_connected_devices->mode == TUI_DEVICE_MODE_DFU) {
                                        tui_jailbreak();
                                        return JAILBREAK_SCREEN;
                                    }
                                }
                            } else if (tui_mouse_x >= tui_x_offset + 80 - 13 && tui_mouse_x <= tui_x_offset + 80 - 13 + 10 && tui_main_nav_mouse_select == 3) {
                                return EXIT_SCREEN;
                            }
                        }
                        tui_main_nav_mouse_select = -1;
                        break;
                }
                break;
            }
        }
        
    }

    return MAIN_SCREEN;
}

static int tui_version_extract_component(const char *version, int index) {
    int component = 0;
    int componentIndex = 0;
    for (int i = 0; version[i] != '\0'; i++) {
        if (version[i] == '.') {
            componentIndex++;
            if (componentIndex > index) {
                break;
            }
            continue;
        }
        if (componentIndex == index) {
            component *= 10;
            component += version[i] - '0';
        }
    }
    return component;
}

static int tui_compare_versions(const char *firstVersion, const char *secondVersion) {
    if (strcmp(firstVersion, secondVersion) == 0) {
        return 0;
    }

    int firstVersionMajor = tui_version_extract_component(firstVersion, 0);
    int firstVersionMinor = tui_version_extract_component(firstVersion, 1);
    int firstVersionPatch = tui_version_extract_component(firstVersion, 2);
    
    int secondVersionMajor = tui_version_extract_component(secondVersion, 0);
    int secondVersionMinor = tui_version_extract_component(secondVersion, 1);
    int secondVersionPatch = tui_version_extract_component(secondVersion, 2);
    
    if (firstVersionMajor != secondVersionMajor) {
        return firstVersionMajor - secondVersionMajor;
    }
    
    if (firstVersionMinor != secondVersionMinor) {
        return firstVersionMinor - secondVersionMinor;
    }
    
    return firstVersionPatch - secondVersionPatch;
}

#else
/* ISO C forbids an empty translation unit */
extern char** environ;
#endif

```

`src/tui_screen_options.c`:

```c
#ifdef TUI
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <locale.h>
#include <unistd.h>
#include <assert.h>

#include <palerain.h>
#include <tui.h>

static int tui_options_nav_selection = 0;
static int tui_options_nav_mouse_select = 0;

static bool tui_options_allow_untested = false;
bool tui_options_safe_mode = false;
bool tui_options_verbose_boot = false;
bool tui_options_force_revert = false;
bool tui_options_flower_chain = true;

bool tui_options_is_editing_boot_args = false;

char tui_options_boot_args[0x1e0 + 1] = {0};

int tui_options_boot_args_cursor = 0;
int tui_options_boot_args_offset = 0;

void tui_screen_options_nav(void) {
    SETCOLOR(FG_WHITE, BG_BLACK);
    MOVETOT(80 - 11, 23);
    printf("%s[  Back  ]" COLOR(FG_WHITE, BG_BLACK),
        tui_options_nav_selection == 0 ? COLOR(FG_BLACK, BG_BRIGHT_WHITE) : (
            (
                tui_mouse_x >= tui_x_offset + 80 - 12 && tui_mouse_x <= tui_x_offset + 80 - 12 + 10
            ) && (tui_mouse_y == tui_y_offset + 22) ? COLOR(FG_BLACK, BG_WHITE) : ""
        )
    );
#ifdef DEV_BUILD
    PRINTATT(3, 23, "DEV_BUILD");
#endif
}

extern bool easter_egg;

void tui_screen_options_options(void) {
    SETCOLOR( FG_BRIGHT_BLACK, BG_BLACK);
    MOVETOT(3, 8);
    printf("[%c] %sAllow untested iOS/iPadOS versions" COLOR(FG_WHITE, BG_BLACK),
        tui_options_allow_untested ? ' ' : ' ',
        COLOR(FG_BLACK, FG_BRIGHT_BLACK));
    SETCOLOR(FG_WHITE, BG_BLACK);
    MOVETOT(3, 9);
    printf("[%c] %sSafe Mode                         " COLOR(FG_WHITE, BG_BLACK),
        tui_options_safe_mode ? 'x' : ' ',
        tui_options_nav_selection == 1 ? COLOR(FG_BLACK, BG_BRIGHT_WHITE) : (
            (
                tui_mouse_x >= tui_x_offset + 5 && tui_mouse_x <= tui_x_offset + 5 + 34
            ) && (tui_mouse_y == tui_y_offset + 8) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ));
    MOVETOT(3, 10);
    printf("[%c] %sVerbose Boot                      " COLOR(FG_WHITE, BG_BLACK),
        tui_options_verbose_boot ? 'x' : ' ',
        tui_options_nav_selection == 2 ? COLOR(FG_BLACK, BG_BRIGHT_WHITE) : (
            (
                tui_mouse_x >= tui_x_offset + 5 && tui_mouse_x <= tui_x_offset + 5 + 34
            ) && (tui_mouse_y == tui_y_offset + 9) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ));
    MOVETOT(3, 11);
    printf("[%c] %sForce Revert                      " COLOR(FG_WHITE, BG_BLACK),
        tui_options_force_revert ? 'x' : ' ',
        tui_options_nav_selection == 3 ? COLOR(FG_BLACK, BG_BRIGHT_WHITE) : (
            (
                tui_mouse_x >= tui_x_offset + 5 && tui_mouse_x <= tui_x_offset + 5 + 34
            ) && (tui_mouse_y == tui_y_offset + 10) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ));
    if (supports_bright_colors) {
        SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
    } else {
        SETCOLOR(FG_BLUE, BG_BLACK);
    }
    DRAWLINET(3, 13, 76);
    SETCOLOR(FG_WHITE, BG_BLACK);
    MOVETOT(7, 15);
    printf("%sBoot Arguments:                   " COLOR(FG_WHITE, BG_BLACK),
        tui_options_nav_selection == 4 ? COLOR(FG_BLACK, BG_BRIGHT_WHITE) : (
            (
                tui_mouse_x >= tui_x_offset + 5 && tui_mouse_x <= tui_x_offset + 5 + 34
            ) && (
                tui_mouse_y == tui_y_offset + 14 || tui_mouse_y == tui_y_offset + 15
            ) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ));
    const char* boot_args_hint = tui_options_is_editing_boot_args ? "(press ENTER when done)" : "  (press ENTER to edit)";
    MOVETOT((int)(80 - 5 - strlen(boot_args_hint)), 15);
    printf("%s", boot_args_hint);
    MOVETOT(3, 17);
    printf("[%c] %s%s                      " COLOR(FG_WHITE, BG_BLACK),
        tui_options_flower_chain ? 'x' : ' ',
        tui_options_nav_selection == 5 ? COLOR(FG_BLACK, BG_BRIGHT_WHITE) : (
            (
                tui_mouse_x >= tui_x_offset + 5 && tui_mouse_x <= tui_x_offset + 5 + 34
            ) && (tui_mouse_y == tui_y_offset + 16) ? COLOR(FG_BLACK, BG_WHITE) : ""
        ), easter_egg ? "Neko Chain  " : "Flower Chain");

    MOVETOT(7, 16);
    if (supports_bright_colors) {
        SETCOLOR(tui_options_is_editing_boot_args ? FG_YELLOW : FG_WHITE, BG_BRIGHT_BLACK);
    } else {
        SETCOLOR(tui_options_is_editing_boot_args ? FG_YELLOW : FG_WHITE, BG_BLUE);
    }
    int boot_args_len = strlen(tui_options_boot_args);

    if ((tui_options_boot_args_cursor - tui_options_boot_args_offset) > (68 - 1)) {
        tui_options_boot_args_offset += (tui_options_boot_args_cursor - tui_options_boot_args_offset) - (68 - 1);
    }
    if ((tui_options_boot_args_cursor - tui_options_boot_args_offset) < 0) {
        tui_options_boot_args_offset = tui_options_boot_args_cursor;
    }
    if ((tui_options_boot_args_offset + 68 - 1) > boot_args_len && boot_args_len >= 68 - 1) {
        tui_options_boot_args_offset = boot_args_len - 68 + 1;
    }

    for (int i = 0; i < 68; i++) {
        putchar(((i + tui_options_boot_args_offset) < boot_args_len) ? tui_options_boot_args[i + tui_options_boot_args_offset] : ' ');
    }

    if (tui_options_is_editing_boot_args) {
        MOVETOT((int)(7 + tui_options_boot_args_cursor - tui_options_boot_args_offset), 16);
        if (supports_bright_colors) {
            SETCOLOR(FG_BRIGHT_BLACK, BG_YELLOW);
        } else {
            SETCOLOR(FG_BLUE, BG_YELLOW);
        }
        putchar(tui_options_boot_args_cursor < boot_args_len ? tui_options_boot_args[tui_options_boot_args_cursor] : ' ');
    }

    SETCOLOR(FG_WHITE, BG_BLACK);
    MOVETOT(5, 16);
    printf(tui_options_boot_args_offset > 0 ? "<<" : "  ");
    MOVETOT(75, 16);
    printf((strlen(tui_options_boot_args) - tui_options_boot_args_offset) > 68 ? ">>" : "  ");
}

void tui_screen_options_redraw(void) {
    SETCOLOR(FG_WHITE, BG_BLACK);
    PRINTATT(3, 3, "You may set the following options. If you don't know what they mean you'll");
    PRINTATT(3, 4, "probably have no reason to set them.");
    if (supports_bright_colors) {
        SETCOLOR(FG_BRIGHT_BLACK, BG_BLACK);
    } else {
        SETCOLOR(FG_BLUE, BG_BLACK);
    }
    DRAWLINET(3, 6, 76);
    tui_screen_options_nav();
    tui_screen_options_options();
    fflush(stdout);
}

tui_screen_t tui_screen_options(void) {
    redraw_screen();

    while(1) {
        int event = tui_get_event();
        if (event != TUI_EVENT_INPUT) continue;
        int input = tui_last_input;

        switch (input) {
            case TUI_INPUT_DOWN:
            case TUI_INPUT_TAB:
                if (tui_options_is_editing_boot_args) break;
                if (++tui_options_nav_selection > 5) tui_options_nav_selection = 0;
                tui_screen_options_nav();
                tui_screen_options_options();
                fflush(stdout);
                break;
            case TUI_INPUT_UP:
            case TUI_INPUT_TAB_BACK:
                if (tui_options_is_editing_boot_args) break;
                if (--tui_options_nav_selection < 0) tui_options_nav_selection = 5;
                tui_screen_options_nav();
                tui_screen_options_options();
                fflush(stdout);
                break;
            case TUI_INPUT_SELECT:
                if (tui_options_is_editing_boot_args && tui_last_key == ' ' && tui_options_boot_args[strlen(tui_options_boot_args)] == '\x00') {
                    size_t max_len = sizeof(tui_options_boot_args) - 1;
                    size_t len = strlen(tui_options_boot_args);
                    if (len >= max_len) {
                        break;
                    }
                    tui_options_boot_args[len] = ' ';
                    tui_options_boot_args[len + 1] = '\x00';
                    tui_options_boot_args_cursor++;
                    tui_screen_options_options();
                    fflush(stdout);
                    break;
                }
                switch(tui_options_nav_selection) {
                case 0:
                    return MAIN_SCREEN;
                // case 1:
                //     tui_options_allow_untested = !tui_options_allow_untested;
                //     break;
                case 1:
                    tui_options_safe_mode = !tui_options_safe_mode;
                    break;
                case 2:
                    tui_options_verbose_boot = !tui_options_verbose_boot;
                    break;
                case 3:
                    tui_options_force_revert = !tui_options_force_revert;
                    break;
                case 4:
                    tui_options_is_editing_boot_args = !tui_options_is_editing_boot_args;
                    tui_options_boot_args_cursor = tui_options_is_editing_boot_args ? strlen(tui_options_boot_args) : 0;
                    break;
                case 5:
                    tui_options_flower_chain = !tui_options_flower_chain;
                    break;
                }
                tui_screen_options_nav();
                tui_screen_options_options();
                fflush(stdout);
                break;
            case TUI_INPUT_MOUSE_MOVE:
                tui_screen_options_nav();
                tui_screen_options_options();
                fflush(stdout);
                break;
            case TUI_INPUT_MOUSE_DOWN:
                if (tui_mouse_y == tui_y_offset + 24 - 2 &&
                    tui_mouse_x >= tui_x_offset + 80 - 12 &&
                    tui_mouse_x <= tui_x_offset + 80 - 12 + 10) {
                    tui_options_nav_selection = 0;
                    tui_options_nav_mouse_select = 0;
                    redraw_screen();
                }

#define MOUSEDOWN_HANDLER(y, val)                               \
                if (tui_mouse_y == tui_y_offset + y &&          \
                    tui_mouse_x >= tui_x_offset + 5 - 4 &&      \
                    tui_mouse_x <= tui_x_offset + 5 + 34) {     \
                    tui_options_nav_selection = val;            \
                    tui_options_nav_mouse_select = val;         \
                    tui_screen_options_nav();                   \
                    tui_screen_options_options();               \
                    fflush(stdout);                             \
                }

                if (!tui_options_is_editing_boot_args) {
                    MOUSEDOWN_HANDLER(8, 1);
                    MOUSEDOWN_HANDLER(9, 2);
                    MOUSEDOWN_HANDLER(10, 3);
                    MOUSEDOWN_HANDLER(16, 5);
                }
                
                MOUSEDOWN_HANDLER(14, 4);
                MOUSEDOWN_HANDLER(15, 4);

#undef MOUSEDOWN_HANDLER
                break;
            case TUI_INPUT_MOUSE_UP:
                if (tui_mouse_y == tui_y_offset + 24 - 2 &&
                    tui_mouse_x >= tui_x_offset + 80 - 12 &&
                    tui_mouse_x <= tui_x_offset + 80 - 12 + 10 &&
                    tui_options_nav_mouse_select == 0) {
                    return MAIN_SCREEN;
                }

#define MOUSEUP_HANDLER(y, val, option, e)                          \
                if (tui_mouse_y == tui_y_offset + y &&              \
                    tui_mouse_x >= tui_x_offset + 5 - 4 &&          \
                    tui_mouse_x <= tui_x_offset + 5 + 34 &&         \
                    tui_options_nav_mouse_select == val) {          \
                    tui_options_##option = !tui_options_##option;   \
                    e                                               \
                    tui_screen_options_nav();                       \
                    tui_screen_options_options();                   \
                    fflush(stdout);                                 \
                }

                if (!tui_options_is_editing_boot_args) {
                    MOUSEUP_HANDLER(8, 1, safe_mode, );
                    MOUSEUP_HANDLER(9, 2, verbose_boot, );
                    MOUSEUP_HANDLER(10, 3, force_revert, );
                    MOUSEUP_HANDLER(16, 5, flower_chain, );
                }

                #define BOOTARGS_HANDLER                                                                                \
                tui_options_boot_args_cursor = tui_options_is_editing_boot_args ? strlen(tui_options_boot_args) : 0;

                MOUSEUP_HANDLER(14, 4, is_editing_boot_args, BOOTARGS_HANDLER);
                MOUSEUP_HANDLER(15, 4, is_editing_boot_args, BOOTARGS_HANDLER);
#undef MOUSEUP_HANDLER
                tui_options_nav_mouse_select = -1;
                break;
            case TUI_INPUT_BACKSPACE:
                if (tui_options_is_editing_boot_args && tui_options_boot_args_cursor > 0) {
                    memmove(tui_options_boot_args + tui_options_boot_args_cursor - 1, tui_options_boot_args + tui_options_boot_args_cursor, strlen(tui_options_boot_args) - tui_options_boot_args_cursor);
                    tui_options_boot_args[strlen(tui_options_boot_args) - 1] = '\x00';
                    tui_options_boot_args_cursor--;
                    tui_screen_options_options();
                    fflush(stdout);
                }
                break;
            case TUI_INPUT_NONE:
                if (tui_options_is_editing_boot_args && tui_options_boot_args[strlen(tui_options_boot_args)] == '\x00') {
                    size_t max_len = sizeof(tui_options_boot_args) - 1;
                    size_t len = strlen(tui_options_boot_args);
                    if (len >= max_len) {
                        break;
                    }
                    memmove(tui_options_boot_args + tui_options_boot_args_cursor + 1, tui_options_boot_args + tui_options_boot_args_cursor, strlen(tui_options_boot_args) - tui_options_boot_args_cursor);
                    tui_options_boot_args[tui_options_boot_args_cursor] = tui_last_key;
                    tui_options_boot_args[len + 1] = '\x00';
                    tui_options_boot_args_cursor++;
                    tui_screen_options_options();
                    fflush(stdout);
                }
                break;
            case TUI_INPUT_LEFT:
                if (tui_options_is_editing_boot_args) {
                    if (tui_options_boot_args_cursor > 0) {
                        tui_options_boot_args_cursor--;
                        tui_screen_options_options();
                        fflush(stdout);
                    }
                }
                break;
            case TUI_INPUT_RIGHT:
                if (tui_options_is_editing_boot_args) {
                    if (tui_options_boot_args_cursor < (int)strlen(tui_options_boot_args)) {
                        tui_options_boot_args_cursor++;
                        tui_screen_options_options();
                        fflush(stdout);
                    }
                }
                break;
        }
    }
}

#else
/* ISO C forbids an empty translation unit */
extern char** environ;
#endif

```

`src/usb.xml`:

```xml
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>platform-application</key>
	<true/>
	<key>com.apple.private.security.no-container</key>
	<true/>
	<key>com.apple.security.iokit-user-client-class</key>
	<array>
		<string>IOUserClient</string>
	</array>
</dict>
</plist>

```

`src/usb_iokit.c`:

```c
/*
 * pongoOS - https://checkra.in
 *
 * Copyright (C) 2019-2022 checkra1n team
 *
 * This file is part of pongoOS.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
#ifndef USE_LIBUSB
#include <errno.h>
#include <fcntl.h>              // open
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>             // exit, strtoull
#include <string.h>             // strlen, strerror, memcpy, memmove
#include <unistd.h>             // close
#include <wordexp.h>
#include <sys/mman.h>           // mmap, munmap
#include <sys/stat.h>           // fstst
#include <mach/mach.h>

#include <palerain.h>
#include <CoreFoundation/CoreFoundation.h>

#define ERR(...) LOG(LOG_VERBOSE, __VA_ARGS__)

const char *usb_strerror(usb_ret_t err)
{
    return mach_error_string(err);
}

usb_ret_t USBControlTransfer(usb_device_handle_t handle, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint32_t wLength, void *data, uint32_t *wLenDone)
{
    IOUSBDevRequest request =
    {
        .bmRequestType = bmRequestType,
        .bRequest = bRequest,
        .wValue = wValue,
        .wIndex = wIndex,
        .wLength = wLength,
        .pData = data,
    };
    usb_ret_t ret = (*handle)->ControlRequest(handle, 0, &request);
    if(wLenDone) *wLenDone = request.wLenDone;
    return ret;
}

usb_ret_t USBBulkUpload(usb_device_handle_t handle, void *data, uint32_t len)
{
    return (*handle)->WritePipe(handle, 2, data, len);
}

static void FoundDevice(void *refCon, io_iterator_t it)
{
    stuff_t *stuff = refCon;
    if(stuff->regID)
    {
        return;
    }
    io_service_t usbDev = MACH_PORT_NULL;
    while((usbDev = IOIteratorNext(it)))
    {
        uint64_t regID;
        kern_return_t ret = IORegistryEntryGetRegistryEntryID(usbDev, &regID);
        if(ret != KERN_SUCCESS)
        {
            ERR("IORegistryEntryGetRegistryEntryID: %s", mach_error_string(ret));
            goto next;
        }
        SInt32 score = 0;
        IOCFPlugInInterface **plugin = NULL;
        ret = IOCreatePlugInInterfaceForService(usbDev, kIOUSBDeviceUserClientTypeID, kIOCFPlugInInterfaceID, &plugin, &score);
        if(ret != KERN_SUCCESS)
        {
            ERR("IOCreatePlugInInterfaceForService(usbDev): %s", mach_error_string(ret));
            goto next;
        }
        HRESULT result = (*plugin)->QueryInterface(plugin, CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID), (LPVOID*)&stuff->dev);
        (*plugin)->Release(plugin);
        if(result != 0)
        {
            ERR("QueryInterface(dev): 0x%x", result);
            goto next;
        }
        ret = (*stuff->dev)->USBDeviceOpenSeize(stuff->dev);
        if(ret != KERN_SUCCESS)
        {
            ERR("USBDeviceOpenSeize: %s", mach_error_string(ret));
        }
        else
        {
            ret = (*stuff->dev)->SetConfiguration(stuff->dev, 1);
            if(ret != KERN_SUCCESS)
            {
                ERR("SetConfiguration: %s", mach_error_string(ret));
            }
            else
            {
                IOUSBFindInterfaceRequest request =
                {
                    .bInterfaceClass = kIOUSBFindInterfaceDontCare,
                    .bInterfaceSubClass = kIOUSBFindInterfaceDontCare,
                    .bInterfaceProtocol = kIOUSBFindInterfaceDontCare,
                    .bAlternateSetting = kIOUSBFindInterfaceDontCare,
                };
                io_iterator_t iter = MACH_PORT_NULL;
                ret = (*stuff->dev)->CreateInterfaceIterator(stuff->dev, &request, &iter);
                if(ret != KERN_SUCCESS)
                {
                    ERR("CreateInterfaceIterator: %s", mach_error_string(ret));
                }
                else
                {
                    io_service_t usbIntf = MACH_PORT_NULL;
                    while((usbIntf = IOIteratorNext(iter)))
                    {
                        ret = IOCreatePlugInInterfaceForService(usbIntf, kIOUSBInterfaceUserClientTypeID, kIOCFPlugInInterfaceID, &plugin, &score);
                        IOObjectRelease(usbIntf);
                        if(ret != KERN_SUCCESS)
                        {
                            ERR("IOCreatePlugInInterfaceForService(usbIntf): %s", mach_error_string(ret));
                            continue;
                        }
                        result = (*plugin)->QueryInterface(plugin, CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID), (LPVOID*)&stuff->handle);
                        (*plugin)->Release(plugin);
                        if(result != 0)
                        {
                            ERR("QueryInterface(intf): 0x%x", result);
                            continue;
                        }
                        ret = (*stuff->handle)->USBInterfaceOpen(stuff->handle);
                        if(ret != KERN_SUCCESS)
                        {
                            ERR("USBInterfaceOpen: %s", mach_error_string(ret));
                        }
                        else
                        {
                            io_start(stuff);
                            stuff->regID = regID;
                            while((usbIntf = IOIteratorNext(iter))) IOObjectRelease(usbIntf);
                            IOObjectRelease(iter);
                            while((usbDev = IOIteratorNext(it))) IOObjectRelease(usbDev);
                            IOObjectRelease(usbDev);
                            return;
                        }
                        (*stuff->handle)->Release(stuff->handle);
                        stuff->handle = NULL;
                    }
                    IOObjectRelease(iter);
                }
            }
        }

    next:;
        if(stuff->dev)
        {
            (*stuff->dev)->USBDeviceClose(stuff->dev);
            (*stuff->dev)->Release(stuff->dev);
            stuff->dev = NULL;
        }
        IOObjectRelease(usbDev);
    }
}

static void LostDevice(void *refCon, io_iterator_t it)
{
    stuff_t *stuff = refCon;
    io_service_t usbDev = MACH_PORT_NULL;
    while((usbDev = IOIteratorNext(it)))
    {
        uint64_t regID;
        kern_return_t ret = IORegistryEntryGetRegistryEntryID(usbDev, &regID);
        IOObjectRelease(usbDev);
        if(ret == KERN_SUCCESS && stuff->regID == regID)
        {
            io_stop(stuff);
            stuff->regID = 0;
            (*stuff->handle)->USBInterfaceClose(stuff->handle);
            (*stuff->handle)->Release(stuff->handle);
            (*stuff->dev)->USBDeviceClose(stuff->dev);
            (*stuff->dev)->Release(stuff->dev);
        }
    }
}

static const int pongo_usb_vendor = PONGO_USB_VENDOR;
static const int pongo_usb_product = PONGO_USB_PRODUCT;

int wait_for_pongo(void) {
    kern_return_t ret;
    stuff_t stuff = {0};
    io_iterator_t found, lost;

    void* cfdict_keys[3];
    void* cfdict_values[3];

    cfdict_keys[0] = (void*)CFSTR("IOProviderClass");
    cfdict_keys[1] = (void*)CFSTR("idVendor");
    cfdict_keys[2] = (void*)CFSTR("idProduct");

    cfdict_values[0] = (void*)CFSTR("IOUSBDevice");
    cfdict_values[1] = (void*)CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &pongo_usb_vendor);
    cfdict_values[2] = (void*)CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &pongo_usb_product);

    CFDictionaryRef cfdict = CFDictionaryCreate(kCFAllocatorDefault, (const void**)cfdict_keys, (const void**)cfdict_values, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    IONotificationPortRef notifyPort = IONotificationPortCreate(kIOMasterPortDefault);

    CFRetain(cfdict);
    // CFRunLoopAddSource(CFRunLoopGetCurrent(), IONotificationPortGetRunLoopSource(notifyPort), kCFRunLoopDefaultMode);

    ret = IOServiceAddMatchingNotification(notifyPort, kIOFirstMatchNotification, cfdict, &FoundDevice, &stuff, &found);
    if(ret != KERN_SUCCESS)
    {
        ERR("IOServiceAddMatchingNotification: %s", mach_error_string(ret));
        return -1;
    }
    FoundDevice(&stuff, found);

    CFRetain(cfdict);
    ret = IOServiceAddMatchingNotification(notifyPort, kIOTerminatedNotification, cfdict, &LostDevice, &stuff, &lost);
    if(ret != KERN_SUCCESS)
    {
        ERR("IOServiceAddMatchingNotification: %s", mach_error_string(ret));
        return -1;
    }
    LostDevice(&stuff, lost);
    // CFRunLoopRun();
    while (get_spin()) {
        sleep(1);
    }
    CFRelease(cfdict);
    return 0;
}
#else
/* ISO C forbids an empty translation unit */
extern char** environ;
#endif

```

`src/usb_libusb.c`:

```c
/*
 * pongoOS - https://checkra.in
 *
 * Copyright (C) 2019-2023 checkra1n team
 *
 * This file is part of pongoOS.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
#ifdef USE_LIBUSB
#include <errno.h>
#include <fcntl.h>              // open
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>             // exit, strtoull
#include <string.h>             // strlen, strerror, memcpy, memmove
#include <unistd.h>             // close
#include <sys/mman.h>           // mmap, munmap
#include <sys/stat.h>           // fstst

#include <palerain.h>
#define ERR(...) LOG(LOG_ERROR, __VA_ARGS__)

void io_start(stuff_t *stuff);
void io_stop(stuff_t *stuff);

const char *usb_strerror(usb_ret_t err)
{
    return libusb_error_name(err);
}

usb_ret_t USBControlTransfer(usb_device_handle_t handle, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint32_t wLength, void *data, uint32_t *wLenDone)
{
    usb_ret_t r = libusb_control_transfer(handle, bmRequestType, bRequest, wValue, wIndex, data, wLength, 0);
    if(r < 0) return r;
    if(wLenDone) *wLenDone = r;
    return USB_RET_SUCCESS;
}

usb_ret_t USBBulkUpload(usb_device_handle_t handle, void *data, int len)
{
    static uint32_t maxLen = 0;
    int transferred = 0;
    usb_ret_t r;
    if(maxLen == 0)
    {
        r = libusb_bulk_transfer(handle, 2, data, len, &transferred, 0);
        if(r == LIBUSB_SUCCESS)
        {
            return transferred == len ? USB_RET_SUCCESS : LIBUSB_ERROR_INTERRUPTED;
        }
        else if(r != LIBUSB_ERROR_NO_MEM)
        {
            return r;
        }
#if defined(__linux__)
        // We only get here on ENOMEM
        FILE *f = fopen("/sys/module/usbcore/parameters/usbfs_memory_mb", "r");
        if(f)
        {
            char str[32]; // More than enough to hold a uint64 in decimal
            size_t s = fread(str, 1, sizeof(str), f);
            fclose(f);
            if(s == 0 || s >= sizeof(str)) return r;
            str[s] = '\0';
            char *end = NULL;
            unsigned long long max = strtoull(str, &end, 0);
            // Using the limit as-is will lead to ENOMEM, so we multiply
            // by half a MB and impose an appropriate max value.
            if(*end == '\n') ++end;
            if(*end != '\0' || max == 0 || max >= 0x2000) return r;
            maxLen = (uint32_t)(max << 19);
        }
        else
#endif
        {
            // Just 1MB by default?
            maxLen = 0x100000;
        }
    }
    // If we get here, we have to chunk our data
    for(int done = transferred; done < len; )
    {
        uint32_t chunk = len - done;
        if(chunk > maxLen) chunk = maxLen;
        transferred = 0;
        r = libusb_bulk_transfer(handle, 2, (unsigned char*)data + done, chunk, &transferred, 0);
        done += transferred;
        if(r == LIBUSB_SUCCESS) continue;
        if(r != LIBUSB_ERROR_NO_MEM || maxLen <= 0x40) return r;
        maxLen /= 2;
    }
    return LIBUSB_SUCCESS;
}

static int FoundDevice(libusb_context *ctx, libusb_device *dev, libusb_hotplug_event event, void *arg)
{
    stuff_t *stuff = arg;
    if(stuff->handle)
    {
        return LIBUSB_SUCCESS;
    }
    LOG(LOG_VERBOSE, "PongoOS USB Device connected");

    libusb_device_handle *handle;
    int r = libusb_open(dev, &handle);
    if(r != LIBUSB_SUCCESS)
    {
        ERR("libusb_open: %s", libusb_error_name(r));
        return r;
    }

/* nah there would not be a kernel driver for pongoOS in Darwin */
#if !defined(__APPLE__)
    r = libusb_detach_kernel_driver(handle, 0);
    if(r != LIBUSB_SUCCESS && r != LIBUSB_ERROR_NOT_FOUND)
    {
        ERR("libusb_detach_kernel_driver: %s", libusb_error_name(r));
        return r;
    }
#endif

    r = libusb_set_configuration(handle, 1);
    if(r != LIBUSB_SUCCESS)
    {
        ERR("libusb_set_configuration: %s", libusb_error_name(r));
        return r;
    }

    r = libusb_claim_interface(handle, 0);
    if(r != LIBUSB_SUCCESS)
    {
        ERR("libusb_claim_interface: %s", libusb_error_name(r));
        return r;
    }

    stuff->dev = dev;
    stuff->handle = handle;
    io_start(stuff);

    return LIBUSB_SUCCESS;
}

static int LostDevice(libusb_context *ctx, libusb_device *dev, libusb_hotplug_event event, void *arg)
{
    stuff_t *stuff = arg;
    if(stuff->dev != dev)
    {
        return LIBUSB_SUCCESS;
    }
    LOG(LOG_VERBOSE, "PongoOS USB Device disconnected");

    io_stop(stuff);
    libusb_close(stuff->handle);
    libusb_unref_device(dev);
    stuff->handle = NULL;
    stuff->dev = NULL;

    return LIBUSB_SUCCESS;
}

int wait_for_pongo(void)
{
    stuff_t stuff = {0};
    libusb_hotplug_callback_handle hp[2];
    libusb_context* ctx = NULL;

    int r = libusb_init(&ctx);
    if(r != LIBUSB_SUCCESS)
    {
        ERR("libusb_init: %s", libusb_error_name(r));
        return -1;
    }

    if(!libusb_has_capability(LIBUSB_CAP_HAS_HOTPLUG))
    {
        ERR("libusb: no hotplug capability");
        libusb_exit(ctx);
        return -1;
    }

    r = libusb_hotplug_register_callback(ctx, LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT, 0, PONGO_USB_VENDOR, PONGO_USB_PRODUCT, LIBUSB_HOTPLUG_MATCH_ANY, LostDevice, &stuff, &hp[1]);
    if(r != LIBUSB_SUCCESS)
    {
        ERR("libusb_hotplug: %s", libusb_error_name(r));
        libusb_exit(ctx);
        return -1;
    }

    while (1) {
        r = libusb_handle_events(ctx);
        if(r != LIBUSB_SUCCESS)
        {
            ERR("libusb_handle_events: %s", libusb_error_name(r));
            break;
        }

        libusb_device **list;
        ssize_t sz = libusb_get_device_list(ctx, &list);
        bool done = false;
        if(sz < 0)
        {
            ERR("libusb_get_device_list: %s", libusb_error_name((int)sz));
            libusb_exit(ctx);
            return -1;
        }

        for(ssize_t i = 0; i < sz; ++i)
        {
            struct libusb_device_descriptor desc;
            r = libusb_get_device_descriptor(list[i], &desc);
            if(r != LIBUSB_SUCCESS)
            {
                ERR("libusb_get_device_descriptor: %s", libusb_error_name(r));
                // continue anyway
            }
            if(desc.idVendor != PONGO_USB_VENDOR || desc.idProduct != PONGO_USB_PRODUCT)
            {
                libusb_unref_device(list[i]);
                continue;
            }
            r = FoundDevice(ctx, list[i], LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED, &stuff);
            for (ssize_t j = i; j < sz; ++j) {
                libusb_unref_device(list[j]);
            }

            if(r != LIBUSB_SUCCESS)
            {
                libusb_free_device_list(list, 0);
                libusb_exit(ctx);
                return -1;
            } else {
                done = true;
            }
            break;
        }

        libusb_free_device_list(list, 0);

        if (done) goto end;
    }

    end:
        libusb_exit(ctx);
        return 0;
}
#else
/* ISO C forbids an empty translation unit */
extern char** environ;
#endif

```