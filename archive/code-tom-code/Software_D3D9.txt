Project Path: arc_code-tom-code_Software_D3D9_gbigynmc

Source Tree:

```txt
arc_code-tom-code_Software_D3D9_gbigynmc
├── LICENSE.txt
├── README.md
├── Software_d3d9
│   ├── DebuggableEnums.h
│   ├── DeviceState.h
│   ├── DitherTables.h
│   ├── FixedFuncEmu
│   │   ├── FFPS
│   │   │   ├── Include
│   │   │   │   ├── FFPS_ApplyColorStage.fxh
│   │   │   │   ├── FFPS_ArgumentSelector.fxh
│   │   │   │   └── FFPS_TexLoad.fxh
│   │   │   └── Source
│   │   │       └── FixedFunctionPixelShader.hlsl
│   │   └── FFVS
│   │       ├── Include
│   │       │   └── FFVS_CalculateSingleLight.fxh
│   │       └── Source
│   │           └── FixedFunctionVertexShader.hlsl
│   ├── FixedFunctionToPixelShader.cpp
│   ├── FixedFunctionToShader.cpp
│   ├── FixedFunctionToShader.h
│   ├── FixedFunctionToVertexShader.cpp
│   ├── GlobalToggles.h
│   ├── IDirect3D9Hook.cpp
│   ├── IDirect3D9Hook.h
│   ├── IDirect3DBaseTexture9Hook.cpp
│   ├── IDirect3DBaseTexture9Hook.h
│   ├── IDirect3DCubeTexture9Hook.cpp
│   ├── IDirect3DCubeTexture9Hook.h
│   ├── IDirect3DDevice9Hook.cpp
│   ├── IDirect3DDevice9Hook.h
│   ├── IDirect3DDevice9Hook_Accessors.cpp
│   ├── IDirect3DDevice9Hook_Creators.cpp
│   ├── IDirect3DIndexBuffer9Hook.cpp
│   ├── IDirect3DIndexBuffer9Hook.h
│   ├── IDirect3DPixelShader9Hook.cpp
│   ├── IDirect3DPixelShader9Hook.h
│   ├── IDirect3DQuery9Hook.cpp
│   ├── IDirect3DQuery9Hook.h
│   ├── IDirect3DResource9Hook.cpp
│   ├── IDirect3DResource9Hook.h
│   ├── IDirect3DStateBlock9Hook.cpp
│   ├── IDirect3DStateBlock9Hook.h
│   ├── IDirect3DSurface9Hook.cpp
│   ├── IDirect3DSurface9Hook.h
│   ├── IDirect3DSwapChain9Hook.cpp
│   ├── IDirect3DSwapChain9Hook.h
│   ├── IDirect3DTexture9Hook.cpp
│   ├── IDirect3DTexture9Hook.h
│   ├── IDirect3DVertexBuffer9Hook.cpp
│   ├── IDirect3DVertexBuffer9Hook.h
│   ├── IDirect3DVertexDeclaration9Hook.cpp
│   ├── IDirect3DVertexDeclaration9Hook.h
│   ├── IDirect3DVertexShader9Hook.cpp
│   ├── IDirect3DVertexShader9Hook.h
│   ├── IDirect3DVolume9Hook.cpp
│   ├── IDirect3DVolume9Hook.h
│   ├── IDirect3DVolumeTexture9Hook.cpp
│   ├── IDirect3DVolumeTexture9Hook.h
│   ├── Overlay
│   │   ├── DebugOverlay.cpp
│   │   ├── DebugOverlay.h
│   │   ├── FontMap.tga
│   │   ├── Overlay_DeviceState.cpp
│   │   └── Overlay_WelcomeScreen.cpp
│   ├── PShaderEngine.cpp
│   ├── PShaderEngine.h
│   ├── SemanticMappings.cpp
│   ├── SemanticMappings.h
│   ├── ShaderAnalysis.cpp
│   ├── ShaderAnalysis.h
│   ├── ShaderBase.h
│   ├── ShaderEngineBase.h
│   ├── ShaderIntrinsicFunctions.h
│   ├── ShaderIntrinsicFunctions4.h
│   ├── ShaderJIT.cpp
│   ├── ShaderJIT.h
│   ├── ShaderJIT_HLSL_to_CPP.cpp
│   ├── ShaderJIT_HLSL_to_CPP_Tables.h
│   ├── ShaderJIT_PrefixFile.cpp
│   ├── ShaderTextureFunctions.cpp
│   ├── ShaderTextureFunctions4.cpp
│   ├── SimpleFont256x256.png
│   ├── SimpleInstrumentedProfiler.h
│   ├── Software_d3d9.vcxproj
│   ├── Source.def
│   ├── VShaderEngine.cpp
│   ├── VShaderEngine.h
│   ├── VShaderEngine_InterpreterExec1.cpp
│   ├── VShaderEngine_InterpreterExec4.cpp
│   ├── d3d9.rc
│   ├── d3d9include.h
│   ├── hookd3d9.cpp
│   └── resource.h
└── Software_d3d9.sln

```

`LICENSE.txt`:

```txt
Copyright (c) June 2016 (first work) / February 2019 (first open-sourced on GitHub) by Tom Lopes

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

```

`README.md`:

```md
# Software D3D9

Performs software emulation for all of Direct3D 9 and Direct3D 9Ex via a proxy DLL (drop-in proxy replacement for Microsoft's official **d3d9.dll**). This project is intended to be a working full software emulation of Direct3D9 for educational purposes. It is intended to work with real games and other programs, and eventually should support a high level of compatibility with a wide range of existing D3D9 games and programs. Since this is software emulating hardware, this will never be as fast as a real GPU. Hopefully people can use this to learn more about how D3D9 works under the hood and to feel inspired about how 3D graphics works as a larger whole.

## Getting Started

Download the repo and open **Software_d3d9.sln** in Visual Studio 2017 or higher (or if you really want to you could hack the project and solution files to use an earlier version of Visual Studio).

### Prerequisites

You will need to have Visual Studio 2017 or higher installed, both for building this project, and for runtime JIT as well.
```
Get Visual Studio 2017 from Microsoft, it's free now for noncommercial use and it's still arguably the best IDE on Windows for C++ programming!
```

You will also need to have the DirectX9 SDK installed on your computer. The latest version of this is the "June 2010" DirectX SDK available here (https://www.microsoft.com/en-us/download/details.aspx?id=6812). This is currently needed for access to D3DX9, which will eventually be removed as a requirement in the future.

After installing the DirectX SDK, you need to add the Include and Lib paths to Visual Studio so that it knows where to look for these new **.h** header and **.lib** library files.
```
How this is done differs between versions of Visual Studio, but the way to do it in VS2017 is:
Go to the Property Manager (note that this is different than the Property Window), and under the Debug|Win32 or Release|Win32 folders, right-click and go to Properties for the Microsoft.Cpp.Win32.user property sheet.
Now go to VC++ Directories in the left hand tree view.
For Include Directories, add the entry that corresponds to the Includes directory where you just installed the DirectX SDK. By default that path will be: C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include
For Library Directories, add the entry that corresponds to the Lib directory where you just installed the DirectX SDK. Make sure to pick the right processor architecture that matches the current build configuration (so for a Win32 build configuration, you should select the x86 directory, and for a Win64 build configuration you should select the x64 directory). By default that path will be one of:
For x86: C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x86
For x64: C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x64
Now click OK at the bottom to save your changes, and you should be good to go!
```

### Building

Open the **Software_d3d9.sln** solution in Visual Studio 2017 (or higher).
Once the project and all associated files have finished loading/initializing, select the desired Solution Configuration for your target program.
```
Currently supported targets are:
Debug - Win32
Release - Win32

Future configuration targets will support Win64 as well.
```

If you run into any compilation errors with the C/C++ code, they're likely due to the language conformance setting in Visual Studio. This project was written without using many modern C/C++ features (basically the C++11 featureset), but also not necessarily conforming to any future strictness that may be added into the C++ standard.

If you experience missing includes for **d3dx9.h**, then make sure that you have the DirectX SDK installed (see above section) and that you have properly added the DirectX SDK's Include folder to your Include Directories.
```
By default, this path should be: C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include
```

If you run into any compilation errors with the HLSL code, that's likely due to shader model or shader type being set incorrectly. Make sure that the Shader Model is set to Shader Model 2 or Shader Model 3.
```
For Pixel Shaders, this should be either "ps_2_0" or "ps_3_0".
For Vertex Shaders, this should be either "vs_2_0" or "vs_3_0".
It's probably a good idea to keep all of the shaders built in this project on the same version if possible.
```

If you run into any linker errors, check and make sure that all of the **.c** and **.cpp** files are properly added to the project and that they are properly marked as "C/C++ compiler" under the "Item Type" property for each file so that they properly participate in the build.

If you have linker errors relating to **d3dx9.lib**, then ensure that you have properly added the DirectX SDK's Lib folder to your Include Directories.
```
By default, this path should be:
For x86: C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x86
For x64: C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x64
```

## Deployment

After building, go to the appropriate build output files folder depending on your build configuration:
```
Debug/Win32: .\Debug\
Release/Win32: .\Release\
Debug/Win64: .\x64\Debug\
Release/Win64: .\x64\Release\
```
Copy the newly built **d3d9.dll** file from that folder and paste it into the directory next to the program that you wish to test with it. Depending on how this program is launched and how it is configured to load DLLs, you may want to instead place the proxy DLL into the working directory of your test program rather than the immediate directory in which the executable resides. Due to how DLL loading works on Windows (unless programs specify otherwise), the proxy **d3d9.dll** should be picked up rather than the true Microsoft **d3d9.dll**.

If you run into errors while trying to launch your program about a missing **d3dx9_43.dll** (or any other version of "d3dx9_XX.dll"), then be sure to install the DirectX End-User Runtimes (https://www.microsoft.com/en-us/download/details.aspx?id=8109) before trying to launch your program. This should not be a problem on Windows 8 and up as these DLLs ship with the operating system, but may be an issue on Windows XP, Windows Vista, or Windows 7.

## Built With

* [Wrappit] (https://www.codeproject.com/Articles/16541/Create-your-Proxy-DLLs-automatically) - Used to generate the proxy DLL template (which has since been very heavily modified).
* [D3DX9] (https://www.microsoft.com/en-us/download/details.aspx?id=6812) - Used as a vector maths library (D3DXMath) and for some debug functionality (D3DXSaveSurfaceToFile(), for example, is useful for debugging surfaces dumped from memory to disk). In the future I plan to remove this as a requirement and replace D3DXMath with XNAMath.

## Authors

* **Tom Lopes** - *Initial work* - [code-tom-code](https://github.com/code-tom-code)

See also the list of [contributors](https://github.com/code-tom-code/Software_D3D9/contributors) who participated in this project.

## License

This project is licensed under the zLib/LibPNG License - see the [LICENSE.txt](LICENSE.txt) file for details

## Acknowledgments

* Thanks to Michael Chourdakis for his Wrappit code (https://www.codeproject.com/Articles/16541/Create-your-Proxy-DLLs-automatically). It's been useful for me for years now for easily generating a starting-point for a proxy DLL.
* Thanks to Microsoft and MSDN for having awesome documentation for the Direct3D9/9Ex API's and the HLSL shader bytecode format docs to go off of. They have really helped with navigating edge cases and solving tricky problems.
* Thanks to rygorous (Fabian 'ryg' Giesen) for authoring his series of articles that illuminate how modern GPUs work under the hood in great detail (https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/).

```

`Software_d3d9.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.1525
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "d3d9", "Software_d3d9\Software_d3d9.vcxproj", "{FFDB895B-11C0-4996-8C2E-194D85FFFAE6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FFDB895B-11C0-4996-8C2E-194D85FFFAE6}.Debug|Win32.ActiveCfg = Debug|Win32
		{FFDB895B-11C0-4996-8C2E-194D85FFFAE6}.Debug|Win32.Build.0 = Debug|Win32
		{FFDB895B-11C0-4996-8C2E-194D85FFFAE6}.Debug|x64.ActiveCfg = Debug|x64
		{FFDB895B-11C0-4996-8C2E-194D85FFFAE6}.Debug|x64.Build.0 = Debug|x64
		{FFDB895B-11C0-4996-8C2E-194D85FFFAE6}.Release|Win32.ActiveCfg = Release|Win32
		{FFDB895B-11C0-4996-8C2E-194D85FFFAE6}.Release|Win32.Build.0 = Release|Win32
		{FFDB895B-11C0-4996-8C2E-194D85FFFAE6}.Release|x64.ActiveCfg = Release|x64
		{FFDB895B-11C0-4996-8C2E-194D85FFFAE6}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5E04EDFD-1D25-4070-891C-F7243B95D719}
	EndGlobalSection
EndGlobal

```

`Software_d3d9/DebuggableEnums.h`:

```h
#pragma once

// This is copied from d3d9types.h
enum DEBUGGABLE_D3DSHADER_INSTRUCTION_OPCODE_TYPE : unsigned short
{
    _D3DSIO_NOP          = 0,
    _D3DSIO_MOV          ,
    _D3DSIO_ADD          ,
    _D3DSIO_SUB          ,
    _D3DSIO_MAD          ,
    _D3DSIO_MUL          ,
    _D3DSIO_RCP          ,
    _D3DSIO_RSQ          ,
    _D3DSIO_DP3          ,
    _D3DSIO_DP4          ,
    _D3DSIO_MIN          ,
    _D3DSIO_MAX          ,
    _D3DSIO_SLT          ,
    _D3DSIO_SGE          ,
    _D3DSIO_EXP          ,
    _D3DSIO_LOG          ,
    _D3DSIO_LIT          ,
    _D3DSIO_DST          ,
    _D3DSIO_LRP          ,
    _D3DSIO_FRC          ,
    _D3DSIO_M4x4         ,
    _D3DSIO_M4x3         ,
    _D3DSIO_M3x4         ,
    _D3DSIO_M3x3         ,
    _D3DSIO_M3x2         ,
    _D3DSIO_CALL         ,
    _D3DSIO_CALLNZ       ,
    _D3DSIO_LOOP         ,
    _D3DSIO_RET          ,
    _D3DSIO_ENDLOOP      ,
    _D3DSIO_LABEL        ,
    _D3DSIO_DCL          ,
    _D3DSIO_POW          ,
    _D3DSIO_CRS          ,
    _D3DSIO_SGN          ,
    _D3DSIO_ABS          ,
    _D3DSIO_NRM          ,
    _D3DSIO_SINCOS       ,
    _D3DSIO_REP          ,
    _D3DSIO_ENDREP       ,
    _D3DSIO_IF           ,
    _D3DSIO_IFC          ,
    _D3DSIO_ELSE         ,
    _D3DSIO_ENDIF        ,
    _D3DSIO_BREAK        ,
    _D3DSIO_BREAKC       ,
    _D3DSIO_MOVA         ,
    _D3DSIO_DEFB         ,
    _D3DSIO_DEFI         ,

    _D3DSIO_TEXCOORD     = 64,
    _D3DSIO_TEXKILL      ,
    _D3DSIO_TEX          ,
    _D3DSIO_TEXBEM       ,
    _D3DSIO_TEXBEML      ,
    _D3DSIO_TEXREG2AR    ,
    _D3DSIO_TEXREG2GB    ,
    _D3DSIO_TEXM3x2PAD   ,
    _D3DSIO_TEXM3x2TEX   ,
    _D3DSIO_TEXM3x3PAD   ,
    _D3DSIO_TEXM3x3TEX   ,
    _D3DSIO_RESERVED0    ,
    _D3DSIO_TEXM3x3SPEC  ,
    _D3DSIO_TEXM3x3VSPEC ,
    _D3DSIO_EXPP         ,
    _D3DSIO_LOGP         ,
    _D3DSIO_CND          ,
    _D3DSIO_DEF          ,
    _D3DSIO_TEXREG2RGB   ,
    _D3DSIO_TEXDP3TEX    ,
    _D3DSIO_TEXM3x2DEPTH ,
    _D3DSIO_TEXDP3       ,
    _D3DSIO_TEXM3x3      ,
    _D3DSIO_TEXDEPTH     ,
    _D3DSIO_CMP          ,
    _D3DSIO_BEM          ,
    _D3DSIO_DP2ADD       ,
    _D3DSIO_DSX          ,
    _D3DSIO_DSY          ,
    _D3DSIO_TEXLDD       ,
    _D3DSIO_SETP         ,
    _D3DSIO_TEXLDL       ,
    _D3DSIO_BREAKP       ,

    _D3DSIO_PHASE        = 0xFFFD,
    _D3DSIO_COMMENT      = 0xFFFE,
    _D3DSIO_END          = 0xFFFF
};

enum debuggableSwizzleChannel : unsigned char
{
	sourceX = 0x0,
	sourceY = 0x1,
	sourceZ = 0x2,
	sourceW = 0x3
};

enum debuggableFullSwizzle : unsigned char
{
	_xxxx = 0x00, _rrrr = 0x00,
	_yxxx = 0x01, _grrr = 0x01,
	_zxxx = 0x02, _brrr = 0x02,
	_wxxx = 0x03, _arrr = 0x03,
	_xyxx = 0x04, _rgrr = 0x04,
	_yyxx = 0x05, _ggrr = 0x05,
	_zyxx = 0x06, _bgrr = 0x06,
	_wyxx = 0x07, _agrr = 0x07,
	_xzxx = 0x08, _rbrr = 0x08,
	_yzxx = 0x09, _gbrr = 0x09,
	_zzxx = 0x0A, _bbrr = 0x0A,
	_wzxx = 0x0B, _abrr = 0x0B,
	_xwxx = 0x0C, _rarr = 0x0C,
	_ywxx = 0x0D, _garr = 0x0D,
	_zwxx = 0x0E, _barr = 0x0E,
	_wwxx = 0x0F, _aarr = 0x0F,
	_xxyx = 0x10, _rrgr = 0x10,
	_yxyx = 0x11, _grgr = 0x11,
	_zxyx = 0x12, _brgr = 0x12,
	_wxyx = 0x13, _argr = 0x13,
	_xyyx = 0x14, _rggr = 0x14,
	_yyyx = 0x15, _gggr = 0x15,
	_zyyx = 0x16, _bggr = 0x16,
	_wyyx = 0x17, _aggr = 0x17,
	_xzyx = 0x18, _rbgr = 0x18,
	_yzyx = 0x19, _gbgr = 0x19,
	_zzyx = 0x1A, _bbgr = 0x1A,
	_wzyx = 0x1B, _abgr = 0x1B,
	_xwyx = 0x1C, _ragr = 0x1C,
	_ywyx = 0x1D, _gagr = 0x1D,
	_zwyx = 0x1E, _bagr = 0x1E,
	_wwyx = 0x1F, _aagr = 0x1F,
	_xxzx = 0x20, _rrbr = 0x20,
	_yxzx = 0x21, _grbr = 0x21,
	_zxzx = 0x22, _brbr = 0x22,
	_wxzx = 0x23, _arbr = 0x23,
	_xyzx = 0x24, _rgbr = 0x24,
	_yyzx = 0x25, _ggbr = 0x25,
	_zyzx = 0x26, _bgbr = 0x26,
	_wyzx = 0x27, _agbr = 0x27,
	_xzzx = 0x28, _rbbr = 0x28,
	_yzzx = 0x29, _gbbr = 0x29,
	_zzzx = 0x2A, _bbbr = 0x2A,
	_wzzx = 0x2B, _abbr = 0x2B,
	_xwzx = 0x2C, _rabr = 0x2C,
	_ywzx = 0x2D, _gabr = 0x2D,
	_zwzx = 0x2E, _babr = 0x2E,
	_wwzx = 0x2F, _aabr = 0x2F,
	_xxwx = 0x30, _rrar = 0x30,
	_yxwx = 0x31, _grar = 0x31,
	_zxwx = 0x32, _brar = 0x32,
	_wxwx = 0x33, _arar = 0x33,
	_xywx = 0x34, _rgar = 0x34,
	_yywx = 0x35, _ggar = 0x35,
	_zywx = 0x36, _bgar = 0x36,
	_wywx = 0x37, _agar = 0x37,
	_xzwx = 0x38, _rbar = 0x38,
	_yzwx = 0x39, _gbar = 0x39,
	_zzwx = 0x3A, _bbar = 0x3A,
	_wzwx = 0x3B, _abar = 0x3B,
	_xwwx = 0x3C, _raar = 0x3C,
	_ywwx = 0x3D, _gaar = 0x3D,
	_zwwx = 0x3E, _baar = 0x3E,
	_wwwx = 0x3F, _aaar = 0x3F,
	_xxxy = 0x40, _rrrg = 0x40,
	_yxxy = 0x41, _grrg = 0x41,
	_zxxy = 0x42, _brrg = 0x42,
	_wxxy = 0x43, _arrg = 0x43,
	_xyxy = 0x44, _rgrg = 0x44,
	_yyxy = 0x45, _ggrg = 0x45,
	_zyxy = 0x46, _bgrg = 0x46,
	_wyxy = 0x47, _agrg = 0x47,
	_xzxy = 0x48, _rbrg = 0x48,
	_yzxy = 0x49, _gbrg = 0x49,
	_zzxy = 0x4A, _bbrg = 0x4A,
	_wzxy = 0x4B, _abrg = 0x4B,
	_xwxy = 0x4C, _rarg = 0x4C,
	_ywxy = 0x4D, _garg = 0x4D,
	_zwxy = 0x4E, _barg = 0x4E,
	_wwxy = 0x4F, _aarg = 0x4F,
	_xxyy = 0x50, _rrgg = 0x50,
	_yxyy = 0x51, _grgg = 0x51,
	_zxyy = 0x52, _brgg = 0x52,
	_wxyy = 0x53, _argg = 0x53,
	_xyyy = 0x54, _rggg = 0x54,
	_yyyy = 0x55, _gggg = 0x55,
	_zyyy = 0x56, _bggg = 0x56,
	_wyyy = 0x57, _aggg = 0x57,
	_xzyy = 0x58, _rbgg = 0x58,
	_yzyy = 0x59, _gbgg = 0x59,
	_zzyy = 0x5A, _bbgg = 0x5A,
	_wzyy = 0x5B, _abgg = 0x5B,
	_xwyy = 0x5C, _ragg = 0x5C,
	_ywyy = 0x5D, _gagg = 0x5D,
	_zwyy = 0x5E, _bagg = 0x5E,
	_wwyy = 0x5F, _aagg = 0x5F,
	_xxzy = 0x60, _rrbg = 0x60,
	_yxzy = 0x61, _grbg = 0x61,
	_zxzy = 0x62, _brbg = 0x62,
	_wxzy = 0x63, _arbg = 0x63,
	_xyzy = 0x64, _rgbg = 0x64,
	_yyzy = 0x65, _ggbg = 0x65,
	_zyzy = 0x66, _bgbg = 0x66,
	_wyzy = 0x67, _agbg = 0x67,
	_xzzy = 0x68, _rbbg = 0x68,
	_yzzy = 0x69, _gbbg = 0x69,
	_zzzy = 0x6A, _bbbg = 0x6A,
	_wzzy = 0x6B, _abbg = 0x6B,
	_xwzy = 0x6C, _rabg = 0x6C,
	_ywzy = 0x6D, _gabg = 0x6D,
	_zwzy = 0x6E, _babg = 0x6E,
	_wwzy = 0x6F, _aabg = 0x6F,
	_xxwy = 0x70, _rrag = 0x70,
	_yxwy = 0x71, _grag = 0x71,
	_zxwy = 0x72, _brag = 0x72,
	_wxwy = 0x73, _arag = 0x73,
	_xywy = 0x74, _rgag = 0x74,
	_yywy = 0x75, _ggag = 0x75,
	_zywy = 0x76, _bgag = 0x76,
	_wywy = 0x77, _agag = 0x77,
	_xzwy = 0x78, _rbag = 0x78,
	_yzwy = 0x79, _gbag = 0x79,
	_zzwy = 0x7A, _bbag = 0x7A,
	_wzwy = 0x7B, _abag = 0x7B,
	_xwwy = 0x7C, _raag = 0x7C,
	_ywwy = 0x7D, _gaag = 0x7D,
	_zwwy = 0x7E, _baag = 0x7E,
	_wwwy = 0x7F, _aaag = 0x7F,
	_xxxz = 0x80, _rrrb = 0x80,
	_yxxz = 0x81, _grrb = 0x81,
	_zxxz = 0x82, _brrb = 0x82,
	_wxxz = 0x83, _arrb = 0x83,
	_xyxz = 0x84, _rgrb = 0x84,
	_yyxz = 0x85, _ggrb = 0x85,
	_zyxz = 0x86, _bgrb = 0x86,
	_wyxz = 0x87, _agrb = 0x87,
	_xzxz = 0x88, _rbrb = 0x88,
	_yzxz = 0x89, _gbrb = 0x89,
	_zzxz = 0x8A, _bbrb = 0x8A,
	_wzxz = 0x8B, _abrb = 0x8B,
	_xwxz = 0x8C, _rarb = 0x8C,
	_ywxz = 0x8D, _garb = 0x8D,
	_zwxz = 0x8E, _barb = 0x8E,
	_wwxz = 0x8F, _aarb = 0x8F,
	_xxyz = 0x90, _rrgb = 0x90,
	_yxyz = 0x91, _grgb = 0x91,
	_zxyz = 0x92, _brgb = 0x92,
	_wxyz = 0x93, _argb = 0x93,
	_xyyz = 0x94, _rggb = 0x94,
	_yyyz = 0x95, _gggb = 0x95,
	_zyyz = 0x96, _bggb = 0x96,
	_wyyz = 0x97, _aggb = 0x97,
	_xzyz = 0x98, _rbgb = 0x98,
	_yzyz = 0x99, _gbgb = 0x99,
	_zzyz = 0x9A, _bbgb = 0x9A,
	_wzyz = 0x9B, _abgb = 0x9B,
	_xwyz = 0x9C, _ragb = 0x9C,
	_ywyz = 0x9D, _gagb = 0x9D,
	_zwyz = 0x9E, _bagb = 0x9E,
	_wwyz = 0x9F, _aagb = 0x9F,
	_xxzz = 0xA0, _rrbb = 0xA0,
	_yxzz = 0xA1, _grbb = 0xA1,
	_zxzz = 0xA2, _brbb = 0xA2,
	_wxzz = 0xA3, _arbb = 0xA3,
	_xyzz = 0xA4, _rgbb = 0xA4,
	_yyzz = 0xA5, _ggbb = 0xA5,
	_zyzz = 0xA6, _bgbb = 0xA6,
	_wyzz = 0xA7, _agbb = 0xA7,
	_xzzz = 0xA8, _rbbb = 0xA8,
	_yzzz = 0xA9, _gbbb = 0xA9,
	_zzzz = 0xAA, _bbbb = 0xAA,
	_wzzz = 0xAB, _abbb = 0xAB,
	_xwzz = 0xAC, _rabb = 0xAC,
	_ywzz = 0xAD, _gabb = 0xAD,
	_zwzz = 0xAE, _babb = 0xAE,
	_wwzz = 0xAF, _aabb = 0xAF,
	_xxwz = 0xB0, _rrab = 0xB0,
	_yxwz = 0xB1, _grab = 0xB1,
	_zxwz = 0xB2, _brab = 0xB2,
	_wxwz = 0xB3, _arab = 0xB3,
	_xywz = 0xB4, _rgab = 0xB4,
	_yywz = 0xB5, _ggab = 0xB5,
	_zywz = 0xB6, _bgab = 0xB6,
	_wywz = 0xB7, _agab = 0xB7,
	_xzwz = 0xB8, _rbab = 0xB8,
	_yzwz = 0xB9, _gbab = 0xB9,
	_zzwz = 0xBA, _bbab = 0xBA,
	_wzwz = 0xBB, _abab = 0xBB,
	_xwwz = 0xBC, _raab = 0xBC,
	_ywwz = 0xBD, _gaab = 0xBD,
	_zwwz = 0xBE, _baab = 0xBE,
	_wwwz = 0xBF, _aaab = 0xBF,
	_xxxw = 0xC0, _rrra = 0xC0,
	_yxxw = 0xC1, _grra = 0xC1,
	_zxxw = 0xC2, _brra = 0xC2,
	_wxxw = 0xC3, _arra = 0xC3,
	_xyxw = 0xC4, _rgra = 0xC4,
	_yyxw = 0xC5, _ggra = 0xC5,
	_zyxw = 0xC6, _bgra = 0xC6,
	_wyxw = 0xC7, _agra = 0xC7,
	_xzxw = 0xC8, _rbra = 0xC8,
	_yzxw = 0xC9, _gbra = 0xC9,
	_zzxw = 0xCA, _bbra = 0xCA,
	_wzxw = 0xCB, _abra = 0xCB,
	_xwxw = 0xCC, _rara = 0xCC,
	_ywxw = 0xCD, _gara = 0xCD,
	_zwxw = 0xCE, _bara = 0xCE,
	_wwxw = 0xCF, _aara = 0xCF,
	_xxyw = 0xD0, _rrga = 0xD0,
	_yxyw = 0xD1, _grga = 0xD1,
	_zxyw = 0xD2, _brga = 0xD2,
	_wxyw = 0xD3, _arga = 0xD3,
	_xyyw = 0xD4, _rgga = 0xD4,
	_yyyw = 0xD5, _ggga = 0xD5,
	_zyyw = 0xD6, _bgga = 0xD6,
	_wyyw = 0xD7, _agga = 0xD7,
	_xzyw = 0xD8, _rbga = 0xD8,
	_yzyw = 0xD9, _gbga = 0xD9,
	_zzyw = 0xDA, _bbga = 0xDA,
	_wzyw = 0xDB, _abga = 0xDB,
	_xwyw = 0xDC, _raga = 0xDC,
	_ywyw = 0xDD, _gaga = 0xDD,
	_zwyw = 0xDE, _baga = 0xDE,
	_wwyw = 0xDF, _aaga = 0xDF,
	_xxzw = 0xE0, _rrba = 0xE0,
	_yxzw = 0xE1, _grba = 0xE1,
	_zxzw = 0xE2, _brba = 0xE2,
	_wxzw = 0xE3, _arba = 0xE3,
	_xyzw = 0xE4, _rgba = 0xE4,
	_yyzw = 0xE5, _ggba = 0xE5,
	_zyzw = 0xE6, _bgba = 0xE6,
	_wyzw = 0xE7, _agba = 0xE7,
	_xzzw = 0xE8, _rbba = 0xE8,
	_yzzw = 0xE9, _gbba = 0xE9,
	_zzzw = 0xEA, _bbba = 0xEA,
	_wzzw = 0xEB, _abba = 0xEB,
	_xwzw = 0xEC, _raba = 0xEC,
	_ywzw = 0xED, _gaba = 0xED,
	_zwzw = 0xEE, _baba = 0xEE,
	_wwzw = 0xEF, _aaba = 0xEF,
	_xxww = 0xF0, _rraa = 0xF0,
	_yxww = 0xF1, _graa = 0xF1,
	_zxww = 0xF2, _braa = 0xF2,
	_wxww = 0xF3, _araa = 0xF3,
	_xyww = 0xF4, _rgaa = 0xF4,
	_yyww = 0xF5, _ggaa = 0xF5,
	_zyww = 0xF6, _bgaa = 0xF6,
	_wyww = 0xF7, _agaa = 0xF7,
	_xzww = 0xF8, _rbaa = 0xF8,
	_yzww = 0xF9, _gbaa = 0xF9,
	_zzww = 0xFA, _bbaa = 0xFA,
	_wzww = 0xFB, _abaa = 0xFB,
	_xwww = 0xFC, _raaa = 0xFC,
	_ywww = 0xFD, _gaaa = 0xFD,
	_zwww = 0xFE, _baaa = 0xFE,
	_wwww = 0xFF, _aaaa = 0xFF,

	// Special swizzles:
	_NoSwizzleXYZW = _xyzw, _NoSwizzleRGBA = _rgba,
	_ReplicateX = _xxxx, _ReplicateRed = _rrrr,
	_ReplicateY = _yyyy, _ReplicateGreen = _gggg,
	_ReplicateZ = _zzzz, _ReplicateBlue = _bbbb,
	_ReplicateW = _wwww, _ReplicateAlpha = _aaaa
};
static_assert(_NoSwizzleXYZW == _NoSwizzleRGBA, "Error: Color and vector channels mismatch!");
static_assert(_ReplicateX == _ReplicateRed, "Error: Color and vector channels mismatch!");
static_assert(_ReplicateY == _ReplicateGreen, "Error: Color and vector channels mismatch!");
static_assert(_ReplicateZ == _ReplicateBlue, "Error: Color and vector channels mismatch!");
static_assert(_ReplicateW == _ReplicateAlpha, "Error: Color and vector channels mismatch!");
static_assert(_NoSwizzleXYZW == (D3DSP_NOSWIZZLE >> D3DSP_SWIZZLE_SHIFT), "Error: Enum mismatches header definition!");
static_assert(_ReplicateRed == (D3DSP_REPLICATERED >> D3DSP_SWIZZLE_SHIFT), "Error: Enum mismatches header definition!");
static_assert(_ReplicateGreen == (D3DSP_REPLICATEGREEN >> D3DSP_SWIZZLE_SHIFT), "Error: Enum mismatches header definition!");
static_assert(_ReplicateBlue == (D3DSP_REPLICATEBLUE >> D3DSP_SWIZZLE_SHIFT), "Error: Enum mismatches header definition!");
static_assert(_ReplicateAlpha == (D3DSP_REPLICATEALPHA >> D3DSP_SWIZZLE_SHIFT), "Error: Enum mismatches header definition!");

enum writeMaskType : unsigned char
{
	WM_None = 0x0,
	WM_X = 0x1,
	WM_Y = 0x2,
	WM_XY = 0x3,
	WM_Z = 0x4,
	WM_XZ = 0x5,
	WM_YZ = 0x6,
	WM_XYZ = 0x7,
	WM_W = 0x8,
	WM_XW = 0x9,
	WM_YW = 0xA,
	WM_XYW = 0xB,
	WM_ZW = 0xC,
	WM_XZW = 0xD,
	WM_YZW = 0xE,
	WM_XYZW = 0xF,

	WM_ALL = WM_XYZW
};

enum resultModifierType : unsigned char
{
	RM_None = (D3DSPDM_NONE >> D3DSP_DSTMOD_SHIFT), // nop
	RM_Saturate = (D3DSPDM_SATURATE >> D3DSP_DSTMOD_SHIFT), // clamp to 0. to 1. range
	RM_PartialPrecision = (D3DSPDM_PARTIALPRECISION >> D3DSP_DSTMOD_SHIFT), // Partial precision hint
	RM_CentroidSample = (D3DSPDM_MSAMPCENTROID >> D3DSP_DSTMOD_SHIFT) /* Relevant to multisampling only:
																	  When the pixel center is not covered, sample
																	  attribute or compute gradients/LOD
																	  using multisample "centroid" location.
																	  "Centroid" is some location within the covered
																	  region of the pixel. */
};

enum debuggableSourceModifierType : unsigned char
{
	SM_None = (D3DSPSM_NONE >> D3DSP_SRCMOD_SHIFT), // nop
	SM_Negate = (D3DSPSM_NEG >> D3DSP_SRCMOD_SHIFT), // negate
    SM_Bias = (D3DSPSM_BIAS >> D3DSP_SRCMOD_SHIFT), // bias
    SM_BiasNegate = (D3DSPSM_BIASNEG >> D3DSP_SRCMOD_SHIFT), // bias and negate
    SM_Sign = (D3DSPSM_SIGN >> D3DSP_SRCMOD_SHIFT), // sign
    SM_SignNegate = (D3DSPSM_SIGNNEG >> D3DSP_SRCMOD_SHIFT), // sign and negate
    SM_Complement = (D3DSPSM_COMP >> D3DSP_SRCMOD_SHIFT), // complement
    SM_x2 = (D3DSPSM_X2 >> D3DSP_SRCMOD_SHIFT), // *2
    SM_x2Negate = (D3DSPSM_X2NEG >> D3DSP_SRCMOD_SHIFT), // *2 and negate
    SM_DivZ = (D3DSPSM_DZ >> D3DSP_SRCMOD_SHIFT), // divide through by z component
    SM_DivW = (D3DSPSM_DW >> D3DSP_SRCMOD_SHIFT), // divide through by w component
    SM_Abs = (D3DSPSM_ABS >> D3DSP_SRCMOD_SHIFT), // abs()
    SM_AbsNegate = (D3DSPSM_ABSNEG >> D3DSP_SRCMOD_SHIFT), // -abs()
    SM_Not = (D3DSPSM_NOT >> D3DSP_SRCMOD_SHIFT), // for predicate register: "!p0"
};

#define D3DFVF_TEXTUREFORMAT2U 0u         // Two floating point values
#define D3DFVF_TEXTUREFORMAT1U 3u         // One floating point value
#define D3DFVF_TEXTUREFORMAT3U 1u         // Three floating point values
#define D3DFVF_TEXTUREFORMAT4U 2u         // Four floating point values

// Using U for Unsigned here, otherwise the compiler chokes on D3DFVF_TEXCOORDSIZE4(7) and D3DFVF_TEXCOORDSIZE1(7) as the sign bit gets accessed and then the number can't be converted to a DWORD properly
#define D3DFVF_TEXCOORDSIZE3U(CoordIndex) (D3DFVF_TEXTUREFORMAT3U << (CoordIndex * 2u + 16u))
#define D3DFVF_TEXCOORDSIZE4U(CoordIndex) (D3DFVF_TEXTUREFORMAT4U << (CoordIndex * 2u + 16u))
#define D3DFVF_TEXCOORDSIZE1U(CoordIndex) (D3DFVF_TEXTUREFORMAT1U << (CoordIndex * 2u + 16u))

enum debuggableFVF_textureFormat : unsigned char
{
	textureFormatFloat2 = D3DFVF_TEXTUREFORMAT2U, // float2 (default)
	textureFormatFloat1 = D3DFVF_TEXTUREFORMAT1U, // float
	textureFormatFloat3 = D3DFVF_TEXTUREFORMAT3U, // float3
	textureFormatFloat4 = D3DFVF_TEXTUREFORMAT4U // float4
};

enum debuggableFVF_positionTypeLow : unsigned char
{
	dbgD3DFVF_NoPosition = 0x000, // This is most commonly used when this FVF is all 0x00000000, like when initializing a non-FVF vertex buffer intended for use with a vertex declaration instead
	dbgD3DFVF_RESERVED0 = D3DFVF_RESERVED0, // 0x001 // The RESERVED0 bit seems to be completely ignored by the FVF to Decl converter
	dbgD3DFVF_XYZ = D3DFVF_XYZ, // 0x002
	dbgD3DFVF_XYZRHW = D3DFVF_XYZRHW, // 0x004
	dbgD3DFVF_XYZB1 = D3DFVF_XYZB1, // 0x006
	dbgD3DFVF_XYZB2 = D3DFVF_XYZB2, // 0x008
	dbgD3DFVF_XYZB3 = D3DFVF_XYZB3, // 0x00a
	dbgD3DFVF_XYZB4 = D3DFVF_XYZB4, // 0x00c
	dbgD3DFVF_XYZB5 = D3DFVF_XYZB5 // 0x00e
};

// Some of these entries are commented-out. This makes me sad, but Visual Studio's debug visualizer will only properly display bitfield enums down if all of the enum's entries are power-of-2.
// Fortunately the majority of common FVF codes are comprised only out of power-of-2 FVF bits, but some rarer ones will not be displayed properly in the debugger...
enum debuggableFVF_enum : DWORD
{
	dD3DFVF_RESERVED0 = D3DFVF_RESERVED0, // 0x001
	dD3DFVF_XYZ = D3DFVF_XYZ, // 0x002
	dD3DFVF_XYZRHW = D3DFVF_XYZRHW, // 0x004
	//dD3DFVF_XYZB1 = D3DFVF_XYZB1, // 0x006
	dD3DFVF_XYZB2 = D3DFVF_XYZB2, // 0x008
	/*dD3DFVF_XYZB3 = D3DFVF_XYZB3, // 0x00a
	dD3DFVF_XYZB4 = D3DFVF_XYZB4, // 0x00c
	dD3DFVF_XYZB5 = D3DFVF_XYZB5, // 0x00e
	dD3DFVF_XYZW = D3DFVF_XYZW, // 0x4002*/
	
	dD3DFVF_NORMAL = D3DFVF_NORMAL, // 0x010
	dD3DFVF_PSIZE = D3DFVF_PSIZE, // 0x020
	dD3DFVF_DIFFUSE = D3DFVF_DIFFUSE, // 0x040
	dD3DFVF_SPECULAR = D3DFVF_SPECULAR, // 0x080
	
	dD3DFVF_TEX1 = D3DFVF_TEX1, // 0x100
	dD3DFVF_TEX2 = D3DFVF_TEX2, // 0x200
	//dD3DFVF_TEX3 = D3DFVF_TEX3, // 0x300
	dD3DFVF_TEX4 = D3DFVF_TEX4, // 0x400
	/*dD3DFVF_TEX5 = D3DFVF_TEX5, // 0x500
	dD3DFVF_TEX6 = D3DFVF_TEX6, // 0x600
	dD3DFVF_TEX7 = D3DFVF_TEX7, // 0x700*/
	dD3DFVF_TEX8 = D3DFVF_TEX8, // 0x800
	
	dD3DFVF_LASTBETA_UBYTE4 = D3DFVF_LASTBETA_UBYTE4, // 0x1000
	dD3DFVF_LASTBETA_D3DCOLOR = D3DFVF_LASTBETA_D3DCOLOR, // 0x8000
	
	//dD3DFVF_RESERVED2 = D3DFVF_RESERVED2, // 0x6000

	dTEXCOORDSIZE3_TEX1 = D3DFVF_TEXCOORDSIZE3U(0),
	dTEXCOORDSIZE4_TEX1 = D3DFVF_TEXCOORDSIZE4U(0),
	//dTEXCOORDSIZE1_TEX1 = D3DFVF_TEXCOORDSIZE1U(0),

	dTEXCOORDSIZE3_TEX2 = D3DFVF_TEXCOORDSIZE3U(1),
	dTEXCOORDSIZE4_TEX2 = D3DFVF_TEXCOORDSIZE4U(1),
	//dTEXCOORDSIZE1_TEX2 = D3DFVF_TEXCOORDSIZE1U(1),

	dTEXCOORDSIZE3_TEX3 = D3DFVF_TEXCOORDSIZE3U(2),
	dTEXCOORDSIZE4_TEX3 = D3DFVF_TEXCOORDSIZE4U(2),
	//dTEXCOORDSIZE1_TEX3 = D3DFVF_TEXCOORDSIZE1U(2),

	dTEXCOORDSIZE3_TEX4 = D3DFVF_TEXCOORDSIZE3U(3),
	dTEXCOORDSIZE4_TEX4 = D3DFVF_TEXCOORDSIZE4U(3),
	//dTEXCOORDSIZE1_TEX4 = D3DFVF_TEXCOORDSIZE1U(3),

	dTEXCOORDSIZE3_TEX5 = D3DFVF_TEXCOORDSIZE3U(4),
	dTEXCOORDSIZE4_TEX5 = D3DFVF_TEXCOORDSIZE4U(4),
	//dTEXCOORDSIZE1_TEX5 = D3DFVF_TEXCOORDSIZE1U(4),

	dTEXCOORDSIZE3_TEX6 = D3DFVF_TEXCOORDSIZE3U(5),
	dTEXCOORDSIZE4_TEX6 = D3DFVF_TEXCOORDSIZE4U(5),
	//dTEXCOORDSIZE1_TEX6 = D3DFVF_TEXCOORDSIZE1U(5),

	dTEXCOORDSIZE3_TEX7 = D3DFVF_TEXCOORDSIZE3U(6),
	dTEXCOORDSIZE4_TEX7 = D3DFVF_TEXCOORDSIZE4U(6),
	//dTEXCOORDSIZE1_TEX7 = D3DFVF_TEXCOORDSIZE1U(6),

	dTEXCOORDSIZE3_TEX8 = D3DFVF_TEXCOORDSIZE3U(7),
	dTEXCOORDSIZE4_TEX8 = D3DFVF_TEXCOORDSIZE4U(7),
	//dTEXCOORDSIZE1_TEX8 = D3DFVF_TEXCOORDSIZE1U(7)
};

union debuggableFVF
{
	struct _namedFVF
	{
		debuggableFVF_positionTypeLow positionTypeLow : 4; // This is the XYZ + matrix palette blending
		bool hasNormal : 1; // D3DFVF_NORMAL // This is the NORMAL0 semantic (float3) // 0x010
		bool hasPSize : 1; // D3DFVF_PSIZE // This is the PSIZE0 semantic (float) // 0x020
		bool hasDiffuse : 1; // D3DFVF_DIFFUSE // This is the COLOR0 semantic (D3DCOLOR) // 0x040
		bool hasSpecular : 1; // D3DFVF_SPECULAR // This is the COLOR1 semantic (D3DCOLOR) // 0x080
		unsigned char numTexcoordElementsPresent : 4; // Valid values for this are from 0 (meaning no texcoords present) thru 8 (meaning 8 sets of texcoords present)
		bool lastBeta_UBYTE4 : 1; // D3DFVF_LASTBETA_UBYTE4 // 0x1000
		bool hasFog : 1; // This is the underdocumented 0x2000 flag "D3DFVF_FOG". It is a float1 channel on stream 0 with usage 0 that implies D3DDECLUSAGE_FOG. It is placed between the lighting attributes and the texcoords in the vertex struct. // RESERVED2 is 0x6000, which is split between "has fog" and D3DFVF_XYZW // 0x2000
		bool positionTypeContainsUntransformedW : 1; // D3DFVF_XYZW // 0x4002
		bool lastBeta_D3DCOLOR : 1; // D3DFVF_LASTBETA_D3DCOLOR // 0x8000
		debuggableFVF_textureFormat texCoord0type : 2; // TEX1 type
		debuggableFVF_textureFormat texCoord1type : 2; // TEX2 type
		debuggableFVF_textureFormat texCoord2type : 2; // TEX3 type
		debuggableFVF_textureFormat texCoord3type : 2; // TEX4 type
		debuggableFVF_textureFormat texCoord4type : 2; // TEX5 type
		debuggableFVF_textureFormat texCoord5type : 2; // TEX6 type
		debuggableFVF_textureFormat texCoord6type : 2; // TEX7 type
		debuggableFVF_textureFormat texCoord7type : 2; // TEX8 type
	} namedFVF;

	debuggableFVF_enum typedFVF;

	DWORD rawFVF_DWORD;
};
static_assert(sizeof(debuggableFVF) == sizeof(DWORD), "Error! Unexpected struct size!");

```

`Software_d3d9/DeviceState.h`:

```h
#pragma once

// This is the line pattern struct from D3D8. It is used in the D3DRS_LINEPATTERN (10) render state.
// Header: D3d8types.h
/* This structure describes a line pattern.
These values are used by the D3DRS_LINEPATTERN render state in the D3DRENDERSTATETYPE enumerated type.
A line pattern specifies how a line is drawn. The line pattern is always the same, no matter where it is started. (This differs from stippling, which affects how objects are rendered; that is, to imitate transparency.)
The line pattern specifies up to a 16-pixel pattern of on and off pixels along the line. The wRepeatFactor member specifies how many pixels are repeated for each entry in wLinePattern. */
typedef struct _D3DLINEPATTERN
{
	WORD wRepeatFactor; // Number of times to repeat each series of 1s and 0s specified in the wLinePattern member. This allows an application to stretch the line pattern.
	WORD wLinePattern; // Bits specifying the line pattern. For example, the following value would produce a dotted line: 1100110011001100.
} D3DLINEPATTERN;

// This corresponds to the SetROP2 GDI function's mix modes. The default D3D render state value is R2_COPYPEN. Read here for more info: https://docs.microsoft.com/en-us/windows/desktop/api/wingdi/nf-wingdi-setrop2
typedef DWORD ROP2;

// This is from d3dtypes.h
// Note that the values do *not* line up with the D3D9 D3DTEXTUREFILTERTYPE enum after 2!
typedef enum _D3DTEXTUREFILTER
{
    D3DFILTER_NEAREST          = 1,
    D3DFILTER_LINEAR           = 2,
    D3DFILTER_MIPNEAREST       = 3,
    D3DFILTER_MIPLINEAR        = 4,
    D3DFILTER_LINEARMIPNEAREST = 5,
    D3DFILTER_LINEARMIPLINEAR  = 6,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DFILTER_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DTEXTUREFILTER;

// This is from d3dtypes.h
typedef enum _D3DTEXTUREBLEND
{
    D3DTBLEND_DECAL            = 1,
    D3DTBLEND_MODULATE         = 2,
    D3DTBLEND_DECALALPHA       = 3,
    D3DTBLEND_MODULATEALPHA    = 4,
    D3DTBLEND_DECALMASK        = 5,
    D3DTBLEND_MODULATEMASK     = 6,
    D3DTBLEND_COPY             = 7,
#if(DIRECT3D_VERSION >= 0x0500)
    D3DTBLEND_ADD              = 8,
    D3DTBLEND_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DTEXTUREBLEND;

// This is from d3dtypes.h
typedef float D3DVALUE;

// This is from d3dtypes.h
typedef LONG D3DFIXED;

// This is from d3dtypes.h
typedef enum _D3DANTIALIASMODE
{
    D3DANTIALIAS_NONE          = 0,
    D3DANTIALIAS_SORTDEPENDENT = 1,
    D3DANTIALIAS_SORTINDEPENDENT = 2,
    D3DANTIALIAS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DANTIALIASMODE;

#ifdef _DEBUG
// These are bit-fields for each of the deprecated render states (up to 255) as of D3D9.
// Note that the presence of a "1" bit indicates "deprecated" whereas a "0" bit can mean either "unused" or "not deprecated"
static const unsigned long deprecatedD3D9RenderStatesBits[8] =
{
	0xc0263c7e,
	0x000a7a83,
	0xffffffff,
	0x00000000,
	0x02010000,
	0x00000010,
	0x00000030,
	0x00000000
};
static const bool IsRenderStateD3D9Deprecated(const D3DRENDERSTATETYPE renderState)
{
	// Out of bounds states cannot be deprecated
	if (renderState > 255)
		return false;

	const unsigned bitmaskDWORDIndex = renderState / 32;
	const unsigned bitmask = 1 << (renderState % 32);
	return (deprecatedD3D9RenderStatesBits[bitmaskDWORDIndex] & bitmask) != 0;
}
#endif // #ifdef _DEBUG

// All of the render states available via SetRenderState() and GetRenderState()
// Reference for the D3D9-supported ones: https://msdn.microsoft.com/en-us/library/windows/desktop/bb172599(v=vs.85).aspx
__declspec(align(16) ) struct RenderStates
{
	RenderStates();

	~RenderStates()
	{
		memset(this, 0, sizeof(*this) );
	}

#define MAX_NUM_RENDERSTATES (D3DRS_BLENDOPALPHA + 1)

	union _renderStatesUnion
	{
		struct _namedStates
		{
			DWORD empty0; // 0
			DWORD textureHandle_D3D1; // 1 (only used in D3D1 thru D3D6)
			D3DANTIALIASMODE antialias_D3D5; // 2 (only used in D3D5, D3D6, and D3D7)
			D3DTEXTUREADDRESS textureAddress_D3D1; // 3 (only used in D3D1 thru D3D6)
			BOOL texturePerspective_D3D1; // 4 (only used in D3D1 thru D3D7)
			BOOL wrapU_D3D1; // 5 (only used in D3D1 thru D3D6)
			BOOL wrapV_D3D1; // 6 (only used in D3D1 thru D3D6)
			D3DZBUFFERTYPE zEnable; // 7
			D3DFILLMODE fillmode; // 8
			D3DSHADEMODE shadeMode; // 9
			D3DLINEPATTERN linePattern_D3D1; // 10 (only used in D3D1 thru D3D8)
			BOOL monoEnable_D3D1; // 11 (only used in D3D1 thru D3D6)
			ROP2 rop2_D3D1; // 12 (only used in D3D1 thru D3D6)
			DWORD planeMask_D3D1; // 13 (only used in D3D1 thru D3D6)
			BOOL zWriteEnable; // 14
			BOOL alphaTestEnable; // 15
			BOOL lastPixel; // 16
			D3DTEXTUREFILTER textureMag_D3D1; // 17 (only used in D3D1 thru D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
			D3DTEXTUREFILTER textureMin_D3D1; // 18 (only used in D3D1 thru D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
			D3DBLEND srcBlend; // 19
			D3DBLEND destBlend;// 20
			D3DTEXTUREBLEND textureMapBlend_D3D1; // 21 (only used in D3D1 thru D3D6)
			D3DCULL cullmode; // 22
			D3DCMPFUNC zFunc; // 23
			D3DFIXED alphaRef; // 24
			D3DCMPFUNC alphaFunc; // 25
			BOOL ditherEnable; // 26
			BOOL alphaBlendEnable; // 27 (D3D5+ only)
			BOOL fogEnable; // 28
			BOOL specularEnable; // 29
			BOOL zVisible_D3D1; // 30 (only used in D3D1 thru D3D8, seems to do a very similar thing as D3DRS_ZENABLE?)
			BOOL subPixel_D3D1; // 31 (only used in D3D1 thru D3D6)
			BOOL subPixelX_D3D1; // 32 (only used in D3D1 thru D3D6)
			BOOL stippledAlpha_D3D1; // 33 (only used in D3D1 thru D3D7)
			D3DCOLOR fogColor; // 34
			D3DFOGMODE fogTableMode; // 35
			float fogStart; // 36 (only used in D3D7+)
			float fogEnd; // 37 (only used in D3D7+)
			float fogDensity; // 38 (only used in D3D7+)
			BOOL stippleEnable_D3D1; // 39 (only used in D3D1 thru D3D6)
			BOOL edgeAntialias_D3D5; // 40 (only used in D3D5 thru D3D8)
			BOOL colorKeyEnable_D3D5; // 41 (only used in D3D5, D3D6, and D3D7)
			DWORD oldAlphaBlendEnable_D3D1; // 42 (only used in D3D1 thru D3D6, replaced with D3DRS_ALPHABLENDENABLE in D3D7+)
			D3DCOLOR borderColor_D3D5; // 43 (only used in D3D5 and D3D6, replaced with SetTextureStageState() in D3D7+)
			D3DTEXTUREADDRESS textureAddressU_D3D5; // 44 (only used in D3D5 and D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
			D3DTEXTUREADDRESS textureAddressV_D3D5; // 45 (only used in D3D5 and D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
			D3DVALUE mipMapLoDBias_D3D5; // 46 (only used in D3D5 and D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
			LONG zBias_D3D8; // 47 (only used in D3D5 thru D3D8)
			BOOL rangeFogEnable; // 48 (D3D5+ only)
			DWORD maxAnisotropy_D3D5; // 49 (only used in D3D5 and D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
			BOOL flushBatch_D3D5; // 50 (D3D5 only)
			BOOL translucentSortIndependent_D3D6; // 51 (D3D6 only)
			BOOL stencilEnable; // 52 (D3D6+ only)
			D3DSTENCILOP stencilFail; // 53 (D3D6+ only)
			D3DSTENCILOP stencilZFail; // 54 (D3D6+ only)
			D3DSTENCILOP stencilPass; // 55 (D3D6+ only)
			D3DCMPFUNC stencilFunc; // 56 (D3D6+ only)
			UINT stencilRef; // 57 (D3D6+ only)
			DWORD stencilMask; // 58 (D3D6+ only)
			DWORD stencilWriteMask; // 59 (D3D6+ only)
			D3DCOLOR textureFactor; // 60 (D3D6+ only)
			DWORD empty61[3]; // 61 thru 63
			DWORD stipplePattern[32]; // 64 thru 95 (D3D1 thru D3D6 only)
			DWORD empty96[32]; // 96 thru 127
			DWORD wrap0; // 128 (D3D6+ only) (This used to be "D3DRENDERSTATE_WRAPBIAS" in D3D6)
			DWORD wrap1; // 129	(D3D6+ only)
			DWORD wrap2; // 130	(D3D6+ only)
			DWORD wrap3; // 131	(D3D6+ only)
			DWORD wrap4; // 132	(D3D6+ only)
			DWORD wrap5; // 133	(D3D6+ only)
			DWORD wrap6; // 134	(D3D6+ only)
			DWORD wrap7; // 135	(D3D6+ only)
			BOOL clipping; // 136 (D3D7+ only)
			BOOL lighting; // 137 (D3D7+ only)
			BOOL extents_D3D7; // 138 (D3D7 only)
			D3DCOLOR ambient; // 139 (D3D7+ only)
			D3DFOGMODE fogVertexMode; // 140 (D3D7+ only)
			BOOL colorVertex; // 141 (D3D7+ only)
			BOOL localViewer; // 142 (D3D7+ only)
			BOOL normalizeNormals; // 143 (D3D7+ only)
			BOOL colorKeyBlendEnable_D3D7; // 144 (D3D7 only)
			D3DMATERIALCOLORSOURCE diffuseMaterialSource; // 145 (D3D7+ only)
			D3DMATERIALCOLORSOURCE specularMaterialSource; // 146 (D3D7+ only)
			D3DMATERIALCOLORSOURCE ambientMaterialSource; // 147 (D3D7+ only)
			D3DMATERIALCOLORSOURCE emissiveMaterialSource; // 148 (D3D7+ only)
			DWORD empty149[2]; // 149 and 150
			D3DVERTEXBLENDFLAGS vertexBlend; // 151 (D3D7+ only)
			DWORD clipPlaneEnable; // 152 (D3D7+ only)
			BOOL softwareVertexProcessing_D3D8; // 153 (only used in D3D8, replaced with IDirect3DDevice9::SetSoftwareVertexProcessing() in D3D9)
			float pointSize; // 154
			float pointSize_Min; // 155
			BOOL pointSpriteEnable; // 156
			BOOL pointScaleEnable; // 157
			float pointScale_A; // 158
			float pointScale_B; // 159
			float pointScale_C; // 160
			BOOL multisampleAntialias; // 161
			DWORD multisampleMask; // 162
			D3DPATCHEDGESTYLE patchEdgeStyle; // 163
			DWORD patchSegments_D3D8; // 164 (only used in D3D8)
			D3DDEBUGMONITORTOKENS debugMonitorToken; // 165
			float pointSize_Max; // 166
			BOOL indexedVertexBlendEnable; // 167
			DWORD colorWriteEnable; // 168
			DWORD empty169; // 169
			float tweenFactor; // 170
			D3DBLENDOP blendOp; // 171
			D3DDEGREETYPE positionDegree; // 172 (in D3D8 this was called "D3DRS_POSITIONORDER")
			D3DDEGREETYPE normalDegree; // 173 (in D3D8 this was called "D3DRS_NORMALORDER")
			BOOL scissorTestEnable; // 174
			float slopeScaledDepthBias; // 175
			BOOL antialiasedLineEnable; // 176
			DWORD empty177; // 177
			float minTessellationLevel; // 178
			float maxTessellationLevel; // 179
			float adaptiveness_X; // 180
			float adaptiveness_Y; // 181
			float adaptiveness_Z; // 182
			float adaptiveness_W; // 183
			BOOL enableAdaptiveTessellation; // 184
			BOOL twoSidedStencilMode; // 185
			D3DSTENCILOP ccw_StencilFail; // 186
			D3DSTENCILOP ccw_StencilZFail; // 187
			D3DSTENCILOP ccw_StencilPass; // 188
			D3DCMPFUNC ccw_StencilFunc; // 189
			DWORD colorWriteEnable1; // 190
			DWORD colorWriteEnable2; // 191
			DWORD colorWriteEnable3; // 192
			D3DCOLOR blendFactor; // 193
			BOOL sRGBWriteEnable; // 194
			float depthBias; // 195
			DWORD empty196[2]; // 196 and 197
			DWORD wrap8; // 198
			DWORD wrap9; // 199
			DWORD wrap10; // 200
			DWORD wrap11; // 201
			DWORD wrap12; // 202
			DWORD wrap13; // 203
			DWORD wrap14; // 204
			DWORD wrap15; // 205
			BOOL separateAlphaBlendEnable; // 206
			D3DBLEND srcBlendAlpha; // 207
			D3DBLEND destBlendAlpha; // 208
			D3DBLENDOP blendOpAlpha; // 209
		} namedStates;
		DWORD states[MAX_NUM_RENDERSTATES];
	} renderStatesUnion;
	static_assert(sizeof(_renderStatesUnion) == sizeof(DWORD) * MAX_NUM_RENDERSTATES, "Error: Unexpected union size!");

	// Cache some derived values from SetRenderState() for more efficient runtime usage:
	__declspec(align(16) ) float cachedAlphaRefFloat;
	__declspec(align(16) ) D3DXVECTOR4 cachedAmbient;
	__declspec(align(16) ) D3DXVECTOR4 cachedBlendFactor;
	__declspec(align(16) ) D3DXVECTOR4 cachedInvBlendFactor;
	__declspec(align(16) ) __m128 depthBiasSplatted;
	__declspec(align(16) ) __m128 alphaRefSplatted;

	enum _simplifiedAlphaBlendMode
	{
		noAlphaBlending = 0, // Alpha blending disabled
		alphaBlending, // D3DBLEND_SRCALPHA, D3DBLEND_INVSRCALPHA
		additiveBlending, // D3DBLEND_ONE, D3DBLEND_ONE
		multiplicativeBlending, // D3DBLEND_DESTCOLOR, D3DBLEND_ZERO or D3DBLEND_ZERO, D3DBLEND_SRCCOLOR
		otherAlphaBlending // Any other mode with alpha blending enabled (including separate alpha blend modes)
	} simplifiedAlphaBlendMode;

	bool alphaBlendNeedsDestRead;
};

enum renderStateStateBlockType : unsigned char
{
	notIncludedInStateBlockState = 0x0,
	vertexState = 0x1,
	pixelState = 0x2,
	SBT_ALL_State = (vertexState | pixelState)
};

// As a note, state-blocks didn't exist prior to Direct3D 7.0, so we should assume that states that don't exist in D3D7+ are unaffected by state blocks (unless the states clearly map to existing D3D8/D3D9 states that have been moved
// outside of SetRenderState, such as all of the TextureStageStates)
const renderStateStateBlockType renderStateStateBlockTypes[] =
{
	notIncludedInStateBlockState, // DWORD empty0; // 0
	notIncludedInStateBlockState, // DWORD textureHandle_D3D1; // 1 (only used in D3D1 thru D3D6)
	notIncludedInStateBlockState, // D3DANTIALIASMODE antialias_D3D5; // 2 (only used in D3D5, D3D6, and D3D7)
	notIncludedInStateBlockState, // D3DTEXTUREADDRESS textureAddress_D3D1; // 3 (only used in D3D1 thru D3D6)
	notIncludedInStateBlockState, // BOOL texturePerspective_D3D1; // 4 (only used in D3D1 thru D3D7)
	notIncludedInStateBlockState, // BOOL wrapU_D3D1; // 5 (only used in D3D1 thru D3D6)
	notIncludedInStateBlockState, // BOOL wrapV_D3D1; // 6 (only used in D3D1 thru D3D6)
	pixelState, // D3DZBUFFERTYPE zEnable; // 7
	pixelState, // D3DFILLMODE fillmode; // 8
	SBT_ALL_State, // D3DSHADEMODE shadeMode; // 9 // This isn't documented as such anywhere, but it empirically gets captured in vertex state blocks for some reason
	notIncludedInStateBlockState, // D3DLINEPATTERN linePattern_D3D1; // 10 (only used in D3D1 thru D3D8)
	notIncludedInStateBlockState, // BOOL monoEnable_D3D1; // 11 (only used in D3D1 thru D3D6)
	notIncludedInStateBlockState, // ROP2 rop2_D3D1; // 12 (only used in D3D1 thru D3D6)
	notIncludedInStateBlockState, // DWORD planeMask_D3D1; // 13 (only used in D3D1 thru D3D6)
	pixelState, // BOOL zWriteEnable; // 14
	pixelState, // BOOL alphaTestEnable; // 15
	pixelState, // BOOL lastPixel; // 16
	notIncludedInStateBlockState, // D3DTEXTUREFILTER textureMag_D3D1; // 17 (only used in D3D1 thru D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
	notIncludedInStateBlockState, // D3DTEXTUREFILTER textureMin_D3D1; // 18 (only used in D3D1 thru D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
	pixelState, // D3DBLEND srcBlend; // 19
	pixelState, // D3DBLEND destBlend;// 20
	notIncludedInStateBlockState, // D3DTEXTUREBLEND textureMapBlend_D3D1; // 21 (only used in D3D1 thru D3D6)
	vertexState, // D3DCULL cullmode; // 22
	pixelState, // D3DCMPFUNC zFunc; // 23
	pixelState, // D3DFIXED alphaRef; // 24
	pixelState, // D3DCMPFUNC alphaFunc; // 25
	pixelState, // BOOL ditherEnable; // 26
	pixelState, // BOOL alphaBlendEnable; // 27 (D3D5+ only)
	vertexState, // BOOL fogEnable; // 28 // The D3D8 and D3D9 docs don't list this one as getting captured under vertex state, but it does get captured under vertex state, and the D3D7 docs correctly state as such.
	vertexState, // BOOL specularEnable; // 29 // The D3D8 and D3D9 docs don't list this one as getting captured under vertex state, but it does get captured under vertex state, and the D3D7 docs correctly state as such.
	notIncludedInStateBlockState, // BOOL zVisible_D3D1; // 30 (only used in D3D1 thru D3D8, seems to do a very similar thing as D3DRS_ZENABLE?)
	notIncludedInStateBlockState, // BOOL subPixel_D3D1; // 31 (only used in D3D1 thru D3D6)
	notIncludedInStateBlockState, // BOOL subPixelX_D3D1; // 32 (only used in D3D1 thru D3D6)
	notIncludedInStateBlockState, // BOOL stippledAlpha_D3D1; // 33 (only used in D3D1 thru D3D7)
	vertexState, // D3DCOLOR fogColor; // 34
	vertexState, // D3DFOGMODE fogTableMode; // 35
	SBT_ALL_State, // float fogStart; // 36 (only used in D3D7+) // These three fog states (fogstart, fogend, and fogdensity) are shared with both vertex and pixel state blocks
	SBT_ALL_State, // float fogEnd; // 37 (only used in D3D7+)
	SBT_ALL_State, // float fogDensity; // 38 (only used in D3D7+)
	notIncludedInStateBlockState, // BOOL stippleEnable_D3D1; // 39 (only used in D3D1 thru D3D6)
	pixelState, // BOOL edgeAntialias_D3D5; // 40 (only used in D3D5 thru D3D8)
	notIncludedInStateBlockState, // BOOL colorKeyEnable_D3D5; // 41 (only used in D3D5, D3D6, and D3D7)
	notIncludedInStateBlockState, // DWORD oldAlphaBlendEnable_D3D1; // 42 (only used in D3D1 thru D3D6, replaced with D3DRS_ALPHABLENDENABLE in D3D7+)
	notIncludedInStateBlockState, // D3DCOLOR borderColor_D3D5; // 43 (only used in D3D5 and D3D6, replaced with SetTextureStageState() in D3D7+)
	notIncludedInStateBlockState, // D3DTEXTUREADDRESS textureAddressU_D3D5; // 44 (only used in D3D5 and D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
	notIncludedInStateBlockState, // D3DTEXTUREADDRESS textureAddressV_D3D5; // 45 (only used in D3D5 and D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
	notIncludedInStateBlockState, // D3DVALUE mipMapLoDBias_D3D5; // 46 (only used in D3D5 and D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
	notIncludedInStateBlockState, // LONG zBias_D3D8; // 47 (only used in D3D5 thru D3D8)
	vertexState, // BOOL rangeFogEnable; // 48 (D3D5+ only)
	notIncludedInStateBlockState, // DWORD maxAnisotropy_D3D5; // 49 (only used in D3D5 and D3D6, replaced with SetTextureStageState() in D3D7 and D3D8, then replaced with SetSamplerState() in D3D9)
	notIncludedInStateBlockState, // BOOL flushBatch_D3D5; // 50 (D3D5 only)
	notIncludedInStateBlockState, // BOOL translucentSortIndependent_D3D6; // 51 (D3D6 only)
	pixelState, // BOOL stencilEnable; // 52 (D3D6+ only)
	pixelState, // D3DSTENCILOP stencilFail; // 53 (D3D6+ only)
	pixelState, // D3DSTENCILOP stencilZFail; // 54 (D3D6+ only)
	pixelState, // D3DSTENCILOP stencilPass; // 55 (D3D6+ only)
	pixelState, // D3DCMPFUNC stencilFunc; // 56 (D3D6+ only)
	pixelState, // UINT stencilRef; // 57 (D3D6+ only)
	pixelState, // DWORD stencilMask; // 58 (D3D6+ only)
	pixelState, // DWORD stencilWriteMask; // 59 (D3D6+ only)
	pixelState, // D3DCOLOR textureFactor; // 60 (D3D6+ only)
	notIncludedInStateBlockState, // DWORD empty61[3]; // 61 thru 63
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, // DWORD stipplePattern[32]; // 64 thru 95 (D3D1 thru D3D6 only)
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, // DWORD empty96[32]; // 96 thru 127
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	notIncludedInStateBlockState, 
	pixelState, // DWORD wrap0; // 128 (D3D6+ only) (This used to be "D3DRENDERSTATE_WRAPBIAS" in D3D6)
	pixelState, // DWORD wrap1; // 129	(D3D6+ only)
	pixelState, // DWORD wrap2; // 130	(D3D6+ only)
	pixelState, // DWORD wrap3; // 131	(D3D6+ only)
	pixelState, // DWORD wrap4; // 132	(D3D6+ only)
	pixelState, // DWORD wrap5; // 133	(D3D6+ only)
	pixelState, // DWORD wrap6; // 134	(D3D6+ only)
	pixelState, // DWORD wrap7; // 135	(D3D6+ only)
	vertexState, // BOOL clipping; // 136 (D3D7+ only)
	vertexState, // BOOL lighting; // 137 (D3D7+ only)
	notIncludedInStateBlockState, // BOOL extents_D3D7; // 138 (D3D7 only)
	vertexState, // D3DCOLOR ambient; // 139 (D3D7+ only)
	vertexState, // D3DFOGMODE fogVertexMode; // 140 (D3D7+ only)
	vertexState, // BOOL colorVertex; // 141 (D3D7+ only)
	vertexState, // BOOL localViewer; // 142 (D3D7+ only) // The D3D9 docs lists this as a pixel state for some reason...
	vertexState, // BOOL normalizeNormals; // 143 (D3D7+ only) // Oddly enough, this is listed in the D3D8 and D3D7 documentation for vertex state block capture, but not in the D3D9 documentation for vertex state block capture.
	notIncludedInStateBlockState, // BOOL colorKeyBlendEnable_D3D7; // 144 (D3D7 only)
	vertexState, // D3DMATERIALCOLORSOURCE diffuseMaterialSource; // 145 (D3D7+ only) // The D3D9 docs mistakenly list these material source renderstates as a pixel state for some reason
	vertexState, // D3DMATERIALCOLORSOURCE specularMaterialSource; // 146 (D3D7+ only) // The D3D9 docs mistakenly list these material source renderstates as a pixel state for some reason
	vertexState, // D3DMATERIALCOLORSOURCE ambientMaterialSource; // 147 (D3D7+ only) // The D3D9 docs mistakenly list these material source renderstates as a pixel state for some reason
	vertexState, // D3DMATERIALCOLORSOURCE emissiveMaterialSource; // 148 (D3D7+ only) // The D3D9 docs mistakenly list these material source renderstates as a pixel state for some reason
	notIncludedInStateBlockState, // DWORD empty149[2]; // 149 and 150
	notIncludedInStateBlockState, 
	vertexState, // D3DVERTEXBLENDFLAGS vertexBlend; // 151 (D3D7+ only)
	vertexState, // DWORD clipPlaneEnable; // 152 (D3D7+ only)
	notIncludedInStateBlockState, // BOOL softwareVertexProcessing_D3D8; // 153 (only used in D3D8, replaced with IDirect3DDevice9::SetSoftwareVertexProcessing() in D3D9). Note that in D3D9 this value is *not* captured by state blocks on purpose!
	vertexState, // float pointSize; // 154
	vertexState, // float pointSize_Min; // 155
	vertexState, // BOOL pointSpriteEnable; // 156
	vertexState, // BOOL pointScaleEnable; // 157
	vertexState, // float pointScale_A; // 158
	vertexState, // float pointScale_B; // 159
	vertexState, // float pointScale_C; // 160
	vertexState, // BOOL multisampleAntialias; // 161
	vertexState, // DWORD multisampleMask; // 162
	vertexState, // D3DPATCHEDGESTYLE patchEdgeStyle; // 163
	notIncludedInStateBlockState, // DWORD patchSegments_D3D8; // 164 (only used in D3D8)
	notIncludedInStateBlockState, // D3DDEBUGMONITORTOKENS debugMonitorToken; // 165
	vertexState, // float pointSize_Max; // 166
	vertexState, // BOOL indexedVertexBlendEnable; // 167
	pixelState, // DWORD colorWriteEnable; // 168
	notIncludedInStateBlockState, // DWORD empty169; // 169
	vertexState, // float tweenFactor; // 170
	pixelState, // D3DBLENDOP blendOp; // 171
	vertexState, // D3DDEGREETYPE positionDegree; // 172 (in D3D8 this was called "D3DRS_POSITIONORDER")
	vertexState, // D3DDEGREETYPE normalDegree; // 173 (in D3D8 this was called "D3DRS_NORMALORDER")
	pixelState, // BOOL scissorTestEnable; // 174
	pixelState, // float slopeScaledDepthBias; // 175
	pixelState, // BOOL antialiasedLineEnable; // 176
	notIncludedInStateBlockState, // DWORD empty177; // 177
	vertexState, // float minTessellationLevel; // 178
	vertexState, // float maxTessellationLevel; // 179
	vertexState, // float adaptiveness_X; // 180
	vertexState, // float adaptiveness_Y; // 181
	vertexState, // float adaptiveness_Z; // 182
	vertexState, // float adaptiveness_W; // 183
	vertexState, // BOOL enableAdaptiveTessellation; // 184
	pixelState, // BOOL twoSidedStencilMode; // 185
	pixelState, // D3DSTENCILOP ccw_StencilFail; // 186
	pixelState, // D3DSTENCILOP ccw_StencilZFail; // 187
	pixelState, // D3DSTENCILOP ccw_StencilPass; // 188
	pixelState, // D3DCMPFUNC ccw_StencilFunc; // 189
	pixelState, // DWORD colorWriteEnable1; // 190
	pixelState, // DWORD colorWriteEnable2; // 191
	pixelState, // DWORD colorWriteEnable3; // 192
	pixelState, // D3DCOLOR blendFactor; // 193
	pixelState, // BOOL sRGBWriteEnable; // 194
	pixelState, // float depthBias; // 195
	notIncludedInStateBlockState, // DWORD empty196[2]; // 196 and 197
	notIncludedInStateBlockState,
	pixelState, // DWORD wrap8; // 198
	pixelState, // DWORD wrap9; // 199
	pixelState, // DWORD wrap10; // 200
	pixelState, // DWORD wrap11; // 201
	pixelState, // DWORD wrap12; // 202
	pixelState, // DWORD wrap13; // 203
	pixelState, // DWORD wrap14; // 204
	pixelState, // DWORD wrap15; // 205
	pixelState, // BOOL separateAlphaBlendEnable; // 206
	pixelState, // D3DBLEND srcBlendAlpha; // 207
	pixelState, // D3DBLEND destBlendAlpha; // 208
	pixelState // D3DBLENDOP blendOpAlpha; // 209
};
static_assert(ARRAYSIZE(renderStateStateBlockTypes) == MAX_NUM_RENDERSTATES, "Error! Array size mismatches enum size!");

```

`Software_d3d9/DitherTables.h`:

```h
#pragma once

// Some 4x4 tables for performing color dithering before being written to rendertargets

static const float uniform2bit[4][4] =
{
	{ (0.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (8.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (2.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (10.0f / 16.0f - 8.0f / 16.0f) / 4.0f },
	{ (12.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (4.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (14.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (6.0f / 16.0f - 8.0f / 16.0f) / 4.0f },
	{ (3.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (11.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (1.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (9.0f / 16.0f - 8.0f / 16.0f) / 4.0f },
	{ (15.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (7.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (13.0f / 16.0f - 8.0f / 16.0f) / 4.0f, (5.0f / 16.0f - 8.0f / 16.0f) / 4.0f }
};

static const float uniform3bit[4][4] =
{
	{ (0.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (8.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (2.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (10.0f / 16.0f - 8.0f / 16.0f) / 8.0f },
	{ (12.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (4.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (14.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (6.0f / 16.0f - 8.0f / 16.0f) / 8.0f },
	{ (3.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (11.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (1.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (9.0f / 16.0f - 8.0f / 16.0f) / 8.0f },
	{ (15.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (7.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (13.0f / 16.0f - 8.0f / 16.0f) / 8.0f, (5.0f / 16.0f - 8.0f / 16.0f) / 8.0f }
};

static const float uniform4bit[4][4] =
{
	{ (0.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (8.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (2.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (10.0f / 16.0f - 8.0f / 16.0f) / 16.0f },
	{ (12.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (4.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (14.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (6.0f / 16.0f - 8.0f / 16.0f) / 16.0f },
	{ (3.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (11.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (1.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (9.0f / 16.0f - 8.0f / 16.0f) / 16.0f },
	{ (15.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (7.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (13.0f / 16.0f - 8.0f / 16.0f) / 16.0f, (5.0f / 16.0f - 8.0f / 16.0f) / 16.0f }
};

static const float uniform5bit[4][4] =
{
	{ (0.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (8.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (2.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (10.0f / 16.0f - 8.0f / 16.0f) / 32.0f },
	{ (12.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (4.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (14.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (6.0f / 16.0f - 8.0f / 16.0f) / 32.0f },
	{ (3.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (11.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (1.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (9.0f / 16.0f - 8.0f / 16.0f) / 32.0f },
	{ (15.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (7.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (13.0f / 16.0f - 8.0f / 16.0f) / 32.0f, (5.0f / 16.0f - 8.0f / 16.0f) / 32.0f }
};

static const float uniform6bit[4][4] =
{
	{ (0.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (8.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (2.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (10.0f / 16.0f - 8.0f / 16.0f) / 64.0f },
	{ (12.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (4.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (14.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (6.0f / 16.0f - 8.0f / 16.0f) / 64.0f },
	{ (3.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (11.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (1.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (9.0f / 16.0f - 8.0f / 16.0f) / 64.0f },
	{ (15.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (7.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (13.0f / 16.0f - 8.0f / 16.0f) / 64.0f, (5.0f / 16.0f - 8.0f / 16.0f) / 64.0f }
};

```

`Software_d3d9/FixedFuncEmu/FFPS/Include/FFPS_ApplyColorStage.fxh`:

```fxh
#define MAKE_COLOR_STAGE_FUNCNAME(x) ApplyColorStage##x
#define MAKE_ALPHA_STAGE_FUNCNAME(x) ApplyAlphaStage##x

// Temp. defines for testing!
/*#define COLOROP D3DTOP_SELECTARG1
#define STAGE_NUM 0*/

inline float3 MAKE_COLOR_STAGE_FUNCNAME(STAGE_NUM)(in const float4 ARG1, 
	in const float4 ARG2,
	in const float4 ARG0,
	in const float VertexAlpha,
	in const float CurrentTexStageTextureAlpha,
	in const float4 CURRENT,
	inout float4 NextStageTexcoordsForBump,
	inout float NextStageLuma)
{
	// Reset the luma for the next stage:
#if COLOROP != D3DTOP_BUMPENVMAPLUMINANCE
	NextStageLuma = 1.0f;
#endif // #if COLOROP != D3DTOP_BUMPENVMAPLUMINANCE

#if COLOROP == D3DTOP_DISABLE
		return CURRENT.rgb;
#elif COLOROP == D3DTOP_SELECTARG1
		return ARG1.rgb;
#elif COLOROP == D3DTOP_SELECTARG2
		return ARG2.rgb;
#elif COLOROP == D3DTOP_MODULATE
		return ARG1.rgb * ARG2.rgb;
#elif COLOROP == D3DTOP_MODULATE2X
		return ARG1.rgb * ARG2.rgb * 2.0f;
#elif COLOROP == D3DTOP_MODULATE4X
		return ARG1.rgb * ARG2.rgb * 4.0f;
#elif COLOROP == D3DTOP_ADD
		return ARG1.rgb + ARG2.rgb;
#elif COLOROP == D3DTOP_ADDSIGNED
		return ARG1.rgb + ARG2.rgb - 0.5f;
#elif COLOROP == D3DTOP_ADDSIGNED2X
		return (ARG1.rgb + ARG2.rgb - 0.5f) * 2.0f;
#elif COLOROP == D3DTOP_SUBTRACT
		return ARG1.rgb - ARG2.rgb;
#elif COLOROP == D3DTOP_ADDSMOOTH
		return ARG1.rgb + ARG2.rgb - ARG1.rgb * ARG2.rgb;
#elif COLOROP == D3DTOP_BLENDDIFFUSEALPHA
		return ARG1.rgb * VertexAlpha + ARG2.rgb * (1.0f - VertexAlpha);
#elif COLOROP == D3DTOP_BLENDTEXTUREALPHA
		return ARG1.rgb * CurrentTexStageTextureAlpha + ARG2.rgb * (1.0f - CurrentTexStageTextureAlpha);
#elif COLOROP == D3DTOP_BLENDFACTORALPHA
		return ARG1.rgb * TFACTOR.a + ARG2.rgb * (1.0f - TFACTOR.a);
#elif COLOROP == D3DTOP_BLENDTEXTUREALPHAPM
		return ARG1.rgb + ARG2.rgb * (1.0f - CurrentTexStageTextureAlpha);
#elif COLOROP == D3DTOP_BLENDCURRENTALPHA
		return ARG1.rgb * CURRENT.a + ARG2.rgb * (1.0f - CURRENT.a);
#elif COLOROP == D3DTOP_PREMODULATE /* The output of stage n is arg1. Additionally, if there is a texture in stage n + 1, any D3DTA_CURRENT in stage n + 1 is premultiplied by texture in stage n + 1. */
		return ARG1.rgb;
#elif COLOROP == D3DTOP_MODULATEALPHA_ADDCOLOR
		return ARG1.rgb + ARG1.aaa * ARG2.rgb;
#elif COLOROP == D3DTOP_MODULATECOLOR_ADDALPHA
		return ARG1.rgb * ARG2.rgb + ARG1.aaa;
#elif COLOROP == D3DTOP_MODULATEINVALPHA_ADDCOLOR
		return (1.0f - ARG1.a) * ARG2.rgb + ARG1.rgb;
#elif COLOROP == D3DTOP_MODULATEINVCOLOR_ADDALPHA
		return (1.0f - ARG1.rgb) * ARG2.rgb + ARG1.aaa;
#elif COLOROP == D3DTOP_BUMPENVMAP
	#if STAGE_NUM < 7
		const float xComp = dot(ARG1.rgb, BUMPENVMAT[STAGE_NUM]._m00_m01_m02);
		const float yComp = dot(ARG1.rgb, BUMPENVMAT[STAGE_NUM]._m10_m11_m12);
		NextStageTexcoordsForBump.xy += float2(xComp, yComp);
	#endif // #if STAGE_NUM < 7
		return CURRENT.rgb;
#elif COLOROP == D3DTOP_BUMPENVMAPLUMINANCE
	#if STAGE_NUM < 7
		const float xComp = dot(ARG1.rgb, BUMPENVMAT[STAGE_NUM]._m00_m01_m02);
		const float yComp = dot(ARG1.rgb, BUMPENVMAT[STAGE_NUM]._m10_m11_m12);
		const float lumaScale = BUMPENVMAT[STAGE_NUM]._m03;
		const float lumaBias = BUMPENVMAT[STAGE_NUM]._m13;
		const float lumaValue = saturate(mad(ARG1.b, lumaScale, lumaBias) );
		NextStageTexcoordsForBump.xy += float2(xComp, yComp);
		NextStageLuma = lumaValue;
	#endif // #if STAGE_NUM < 7
		return CURRENT.rgb;
#elif COLOROP == D3DTOP_DOTPRODUCT3
		const float3 signedARG1 = (ARG1.rgb - 0.5f) * 4.0f;
		const float3 signedARG2 = (ARG2.rgb - 0.5f);
		const float dotResult = saturate(dot(signedARG1, signedARG2) );
		return float3(dotResult, dotResult, dotResult);
#elif COLOROP == D3DTOP_MULTIPLYADD
		return mad(ARG2.rgb, ARG1.rgb, ARG0.rgb);
#elif COLOROP == D3DTOP_LERP
		return lerp(ARG2.rgb, ARG1.rgb, ARG0.rgb);
#else
	#error ERROR: Unknown D3DTOP value passed to COLOROP used!
	//return float3(0.0f, 0.0f, 0.0f);
#endif
}

inline float MAKE_ALPHA_STAGE_FUNCNAME(STAGE_NUM)(in const float4 ARG1, 
	in const float4 ARG2,
	in const float4 ARG0,
	in const float VertexAlpha,
	in const float CurrentTexStageTextureAlpha,
	in const float4 CURRENT)
{

// This is a little bit strange, but in the case of DOT3 color-ops, they override whatever the alpha op is and broadcast
// the dot3 result into the alpha channel instead:
#if COLOROP == D3DTOP_DOTPRODUCT3
	{
		const float3 signedARG1 = (ARG1.rgb - 0.5f) * 4.0f;
		const float3 signedARG2 = (ARG2.rgb - 0.5f);
		const float dotResult = saturate(dot(signedARG1, signedARG2) );
		return dotResult;
	}
#endif

// It looks like D3DTOP_DISABLE passed to ALPHAOP means D3DTOP_SELECTARG1 and ARG1 = D3DTA_TFACTOR
#if ALPHAOP == D3DTOP_DISABLE
	return CURRENT.a;
	//return ARG1.a;
#elif ALPHAOP == D3DTOP_SELECTARG1
	return ARG1.a;
#elif ALPHAOP == D3DTOP_SELECTARG2
	return ARG2.a;
#elif ALPHAOP == D3DTOP_MODULATE
	return ARG1.a * ARG2.a;
#elif ALPHAOP == D3DTOP_MODULATE2X
	return ARG1.a * ARG2.a * 2.0f;
#elif ALPHAOP == D3DTOP_MODULATE4X
	return ARG1.a * ARG2.a * 4.0f;
#elif ALPHAOP == D3DTOP_ADD
	return ARG1.a + ARG2.a;
#elif ALPHAOP == D3DTOP_ADDSIGNED
	return ARG1.a + ARG2.a - 0.5f;
#elif ALPHAOP == D3DTOP_ADDSIGNED2X
	return (ARG1.a + ARG2.a - 0.5f) * 2.0f;
#elif ALPHAOP == D3DTOP_SUBTRACT
	return ARG1.a - ARG2.a;
#elif ALPHAOP == D3DTOP_ADDSMOOTH
	return ARG1.a + ARG2.a - ARG1.a * ARG2.a;
#elif ALPHAOP == D3DTOP_BLENDDIFFUSEALPHA
	return ARG1.a * VertexAlpha + ARG2.a * (1.0f - VertexAlpha);
#elif ALPHAOP == D3DTOP_BLENDTEXTUREALPHA
	return ARG1.a * CurrentTexStageTextureAlpha + ARG2.a * (1.0f - CurrentTexStageTextureAlpha);
#elif ALPHAOP == D3DTOP_BLENDFACTORALPHA
	return ARG1.a * TFACTOR.a + ARG2.a * (1.0f - TFACTOR.a);
#elif ALPHAOP == D3DTOP_BLENDTEXTUREALPHAPM
	return ARG1.a + ARG2.a * (1.0f - CurrentTexStageTextureAlpha);
#elif ALPHAOP == D3DTOP_BLENDCURRENTALPHA
	return ARG1.a * CURRENT.a + ARG2.a * (1.0f - CURRENT.a);
#elif ALPHAOP == D3DTOP_PREMODULATE /* The output of stage n is arg1. Additionally, if there is a texture in stage n + 1, any D3DTA_CURRENT in stage n + 1 is premultiplied by texture in stage n + 1. */
	return ARG1.a;
#elif ALPHAOP == D3DTOP_MODULATEALPHA_ADDCOLOR // Note: This is technically illegal to use as an D3DTSS_ALPHAOP
	return 1.0f;
#elif ALPHAOP == D3DTOP_MODULATECOLOR_ADDALPHA // Note: This is technically illegal to use as an D3DTSS_ALPHAOP
	return 1.0f;
#elif ALPHAOP == D3DTOP_MODULATEINVALPHA_ADDCOLOR // Note: This is technically illegal to use as an D3DTSS_ALPHAOP
	return 1.0f;
#elif ALPHAOP == D3DTOP_MODULATEINVCOLOR_ADDALPHA // Note: This is technically illegal to use as an D3DTSS_ALPHAOP
	return 1.0f;
#elif ALPHAOP == D3DTOP_BUMPENVMAP // Note: This is technically illegal to use as an D3DTSS_ALPHAOP
	return 1.0f;
#elif ALPHAOP == D3DTOP_BUMPENVMAPLUMINANCE // Note: This is technically illegal to use as an D3DTSS_ALPHAOP
	return 1.0f;
#elif ALPHAOP == D3DTOP_DOTPRODUCT3
	const float3 signedARG1 = (ARG1.rgb - 0.5f) * 4.0f;
	const float3 signedARG2 = (ARG2.rgb - 0.5f);
	const float dotResult = saturate(dot(signedARG1, signedARG2) );
	return dotResult;
#elif ALPHAOP == D3DTOP_MULTIPLYADD
	return mad(ARG2.a, ARG1.a, ARG0.a);
#elif ALPHAOP == D3DTOP_LERP
	return lerp(ARG2.a, ARG1.a, ARG0.a);
#else
	#error Unknown D3DTSS_ALPHAOP value used!
	//return float3(0.0f, 0.0f, 0.0f);
#endif
}

#undef MAKE_ALPHA_STAGE_FUNCNAME
#undef MAKE_COLOR_STAGE_FUNCNAME

```

`Software_d3d9/FixedFuncEmu/FFPS/Include/FFPS_ArgumentSelector.fxh`:

```fxh
#define MAKE_ARGSELECTOR_NAME(x) ArgumentSelect##x

inline const float4 MAKE_ARGSELECTOR_NAME(ARGNAME)(in const float4 diffuse, in const float4 specular, 
	in const float4 CURRENT, in const float4 currentStageTexture, in const float4 currentStateConstant, in const float4 TEMP, in const float TextureLumaScale)
{
#if ( (ARG) & (D3DTA_ALPHAREPLICATE | D3DTA_COMPLEMENT) ) == 0
	#if (ARG) == D3DTA_DIFFUSE
		return diffuse;
	#elif (ARG) == D3DTA_CURRENT
		#if STAGE_NUM == 0
			return diffuse;
		#else
			return CURRENT;
		#endif
	#elif (ARG) == D3DTA_TEXTURE
		#if STAGE_NUM == 0
			return currentStageTexture;
		#else
			return currentStageTexture * TextureLumaScale;
		#endif
	#elif (ARG) == D3DTA_TFACTOR
		return TFACTOR;
	#elif (ARG) == D3DTA_SPECULAR
		return specular;
	#elif (ARG) == D3DTA_TEMP
		return TEMP;
	#elif (ARG) == D3DTA_CONSTANT
		return currentStateConstant;
	#else
		#error ERROR: Invalid D3DTA type passed to ArgumentSelect!
	#endif
#else // #if (ARG & (D3DTA_ALPHAREPLICATE | D3DTA_COMPLEMENT) ) == 0
	float4 arg;
	#if ( (ARG) & D3DTA_SELECTMASK) == D3DTA_DIFFUSE
		arg = diffuse;
	#elif ( (ARG) & D3DTA_SELECTMASK) == D3DTA_CURRENT
		#if STAGE_NUM == 0
			arg = diffuse;
		#else
			arg = CURRENT;
		#endif
	#elif ( (ARG) & D3DTA_SELECTMASK) == D3DTA_TEXTURE
		arg = currentStageTexture;
	#elif ( (ARG) & D3DTA_SELECTMASK) == D3DTA_TFACTOR
		arg = TFACTOR;
	#elif ( (ARG) & D3DTA_SELECTMASK) == D3DTA_SPECULAR
		arg = specular;
	#elif ( (ARG) & D3DTA_SELECTMASK) == D3DTA_TEMP
		arg = TEMP;
		#if ARG == (D3DTA_ALPHAREPLICATE | D3DTA_TEMP) // This is some crazy strange undocumented behavior.
		arg.a = 1.0f;
		#endif // #if ARG == (D3DTA_ALPHAREPLICATE | TEMP)
	#elif ( (ARG) & D3DTA_SELECTMASK) == D3DTA_CONSTANT
		arg = currentStateConstant;
	#else
		#error ERROR: Invalid D3DTA type passed to ArgumentSelect!
	#endif

	// Note that the order of D3DTA_ALPHAREPLICATE and D3DTA_COMPLEMENT doesn't matter because these two modifiers act commutatively with one another:
	// args = 1.0 - args.aaaa;
	// is the same as:
	// args = args.a; args = 1.0f - args;
	#if ( ( (ARG) & (D3DTA_ALPHAREPLICATE | D3DTA_COMPLEMENT) ) == (D3DTA_ALPHAREPLICATE | D3DTA_COMPLEMENT) )
		float alphaArg = arg.a;
		alphaArg = 1.0f - alphaArg;
		arg.rgba = float4(alphaArg, alphaArg, alphaArg, alphaArg);
	#elif ( ( (ARG) & D3DTA_ALPHAREPLICATE) != 0)
		arg = arg.aaaa;
	#elif ( ( (ARG) & D3DTA_COMPLEMENT) != 0)
		arg = 1.0f - arg;
	#endif
	return arg;
#endif // #if (ARG & (D3DTA_ALPHAREPLICATE | D3DTA_COMPLEMENT) ) == 0
}

#undef MAKE_ARGSELECTOR_NAME
#undef ARG
#undef ARGNAME

```

`Software_d3d9/FixedFuncEmu/FFPS/Include/FFPS_TexLoad.fxh`:

```fxh
#define MAKE_TEXLOAD_NAME(x) TexLoad##x
#define TEXTURENAME(x) texture##x

inline const float4 MAKE_TEXLOAD_NAME(STAGE_NUM)(in const float4 texcoords)
{
#ifndef HAS_TEX_BOUND
	return float4(1.0f, 1.0f, 1.0f, 1.0f);
#else // #ifndef HAS_TEX_BOUND
	#if (TEXTYPE & TEXTYPEPROJ) != 0
		#if ( (TEXTYPE & 0x3) == TEXTYPE1D)
			float a;
			return tex1Dproj(TEXTURENAME(STAGE_NUM), texcoords);
		#elif ( (TEXTYPE & 0x3) == TEXTYPE2D)
			float b;
			return tex2Dproj(TEXTURENAME(STAGE_NUM), texcoords);
		#elif ( (TEXTYPE & 0x3) == TEXTYPE3D)
			float c;
			return tex3Dproj(TEXTURENAME(STAGE_NUM), texcoords);
		#elif ( (TEXTYPE & 0x3) == TEXTYPECUBE)
			float d;
			return texCUBEproj(TEXTURENAME(STAGE_NUM), texcoords);
		#else // // #if ( (TEXTYPE & 0x3) == TEXTYPE1D)
			#error INVALID TEXTYPE FOR PROJ TYPE!
		#endif // #if ( (TEXTYPE & 0x3) == TEXTYPE1D)
	#else // #if (TEXTYPE & TEXTYPEPROJ) != 0
		#if TEXTYPE == TEXTYPE1D
			float e;
			return tex1D(TEXTURENAME(STAGE_NUM), texcoords.x);
		#elif TEXTYPE == TEXTYPE2D
			float f;
			return tex2D(TEXTURENAME(STAGE_NUM), texcoords.xy);
		#elif TEXTYPE == TEXTYPE3D
			float g;
			return tex3D(TEXTURENAME(STAGE_NUM), texcoords.xyz);
		#elif TEXTYPE == TEXTYPECUBE
			float h;
			return texCUBE(TEXTURENAME(STAGE_NUM), texcoords.xyz);
		#else // #if TEXTYPE == TEXTYPE1D
			#error INVALID TEXTYPE FOR NON-PROJ TYPE!
		#endif // #if TEXTYPE == TEXTYPE1D
	#endif // #if (TEXTYPE & TEXTYPEPROJ) != 0
#endif // #ifndef HAS_TEX_BOUND
}

#undef TEXTURENAME
#undef MAKE_TEXLOAD_NAME
#undef HAS_TEX_BOUND
#undef TEXTYPE

```

`Software_d3d9/FixedFuncEmu/FFPS/Source/FixedFunctionPixelShader.hlsl`:

```hlsl
#define D3DTOP_DISABLE                   1
#define D3DTOP_SELECTARG1                2
#define D3DTOP_SELECTARG2                3
#define D3DTOP_MODULATE                  4
#define D3DTOP_MODULATE2X                5
#define D3DTOP_MODULATE4X                6
#define D3DTOP_ADD                       7
#define D3DTOP_ADDSIGNED                 8
#define D3DTOP_ADDSIGNED2X               9
#define D3DTOP_SUBTRACT                  10
#define D3DTOP_ADDSMOOTH                 11
#define D3DTOP_BLENDDIFFUSEALPHA         12
#define D3DTOP_BLENDTEXTUREALPHA         13
#define D3DTOP_BLENDFACTORALPHA          14
#define D3DTOP_BLENDTEXTUREALPHAPM       15
#define D3DTOP_BLENDCURRENTALPHA         16
#define D3DTOP_PREMODULATE               17
#define D3DTOP_MODULATEALPHA_ADDCOLOR    18
#define D3DTOP_MODULATECOLOR_ADDALPHA    19
#define D3DTOP_MODULATEINVALPHA_ADDCOLOR 20
#define D3DTOP_MODULATEINVCOLOR_ADDALPHA 21
#define D3DTOP_BUMPENVMAP                22
#define D3DTOP_BUMPENVMAPLUMINANCE       23
#define D3DTOP_DOTPRODUCT3               24
#define D3DTOP_MULTIPLYADD               25
#define D3DTOP_LERP                      26

#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
#define D3DTA_DIFFUSE           0x00000000  // select diffuse color (read only)
#define D3DTA_CURRENT           0x00000001  // select stage destination register (read/write)
#define D3DTA_TEXTURE           0x00000002  // select texture color (read only)
#define D3DTA_TFACTOR           0x00000003  // select D3DRS_TEXTUREFACTOR (read only)
#define D3DTA_SPECULAR          0x00000004  // select specular color (read only)
#define D3DTA_TEMP              0x00000005  // select temporary register color (read/write)
#define D3DTA_CONSTANT          0x00000006  // select texture stage constant
#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x (read modifier)
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components (read modifier)

#define TEXTYPE1D 0x0
#define TEXTYPE2D 0x1
#define TEXTYPE3D 0x2
#define TEXTYPECUBE 0x3
#define TEXTYPEPROJ 0x4

#ifndef SAMPLERTYPE0
	#define SAMPLERTYPE0 sampler2D
#endif // #ifndef SAMPLERTYPE0
#ifndef SAMPLERTYPE1
	#define SAMPLERTYPE1 sampler2D
#endif // #ifndef SAMPLERTYPE1
#ifndef SAMPLERTYPE2
	#define SAMPLERTYPE2 sampler2D
#endif // #ifndef SAMPLERTYPE2
#ifndef SAMPLERTYPE3
	#define SAMPLERTYPE3 sampler2D
#endif // #ifndef SAMPLERTYPE3
#ifndef SAMPLERTYPE4
	#define SAMPLERTYPE4 sampler2D
#endif // #ifndef SAMPLERTYPE4
#ifndef SAMPLERTYPE5
	#define SAMPLERTYPE5 sampler2D
#endif // #ifndef SAMPLERTYPE5
#ifndef SAMPLERTYPE6
	#define SAMPLERTYPE6 sampler2D
#endif // #ifndef SAMPLERTYPE6
#ifndef SAMPLERTYPE7
	#define SAMPLERTYPE7 sampler2D
#endif // #ifndef SAMPLERTYPE7

// Sample macro values follow for testing purposes (these should all be set programmatically!)
/*
#define D3DTSS_TEXCOORDINDEX0 0
#define D3DTSS_TEXCOORDINDEX1 1
#define D3DTSS_TEXCOORDINDEX2 2
#define D3DTSS_TEXCOORDINDEX3 3
#define D3DTSS_TEXCOORDINDEX4 4
#define D3DTSS_TEXCOORDINDEX5 5
#define D3DTSS_TEXCOORDINDEX6 6
#define D3DTSS_TEXCOORDINDEX7 7

#define D3DTSS_STAGE0_COLOROP D3DTOP_MODULATE
#define D3DTSS_STAGE0_ALPHAOP D3DTOP_SELECTARG1
#define D3DTSS_STAGE0_COLORARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE0_COLORARG2 D3DTA_CURRENT
#define D3DTSS_STAGE0_COLORARG0 D3DTA_CURRENT
#define D3DTSS_STAGE0_ALPHAARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE0_ALPHAARG2 D3DTA_CURRENT
#define D3DTSS_STAGE0_ALPHAARG0 D3DTA_CURRENT
#define D3DTSS_STAGE0_RESULTARG D3DTA_CURRENT

#define D3DTSS_STAGE1_COLOROP D3DTOP_MODULATE
#define D3DTSS_STAGE1_ALPHAOP D3DTOP_SELECTARG1
#define D3DTSS_STAGE1_COLORARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE1_COLORARG2 D3DTA_CURRENT
#define D3DTSS_STAGE1_COLORARG0 D3DTA_CURRENT
#define D3DTSS_STAGE1_ALPHAARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE1_ALPHAARG2 D3DTA_CURRENT
#define D3DTSS_STAGE1_ALPHAARG0 D3DTA_CURRENT
#define D3DTSS_STAGE1_RESULTARG D3DTA_CURRENT

#define D3DTSS_STAGE2_COLOROP D3DTOP_MODULATE
#define D3DTSS_STAGE2_ALPHAOP D3DTOP_SELECTARG1
#define D3DTSS_STAGE2_COLORARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE2_COLORARG2 D3DTA_CURRENT
#define D3DTSS_STAGE2_COLORARG0 D3DTA_CURRENT
#define D3DTSS_STAGE2_ALPHAARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE2_ALPHAARG2 D3DTA_CURRENT
#define D3DTSS_STAGE2_ALPHAARG0 D3DTA_CURRENT
#define D3DTSS_STAGE2_RESULTARG D3DTA_CURRENT

#define D3DTSS_STAGE3_COLOROP D3DTOP_MODULATE
#define D3DTSS_STAGE3_ALPHAOP D3DTOP_SELECTARG1
#define D3DTSS_STAGE3_COLORARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE3_COLORARG2 D3DTA_CURRENT
#define D3DTSS_STAGE3_COLORARG0 D3DTA_CURRENT
#define D3DTSS_STAGE3_ALPHAARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE3_ALPHAARG2 D3DTA_CURRENT
#define D3DTSS_STAGE3_ALPHAARG0 D3DTA_CURRENT
#define D3DTSS_STAGE3_RESULTARG D3DTA_CURRENT

#define D3DTSS_STAGE4_COLOROP D3DTOP_MODULATE
#define D3DTSS_STAGE4_ALPHAOP D3DTOP_SELECTARG1
#define D3DTSS_STAGE4_COLORARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE4_COLORARG2 D3DTA_CURRENT
#define D3DTSS_STAGE4_COLORARG0 D3DTA_CURRENT
#define D3DTSS_STAGE4_ALPHAARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE4_ALPHAARG2 D3DTA_CURRENT
#define D3DTSS_STAGE4_ALPHAARG0 D3DTA_CURRENT
#define D3DTSS_STAGE4_RESULTARG D3DTA_CURRENT

#define D3DTSS_STAGE5_COLOROP D3DTOP_MODULATE
#define D3DTSS_STAGE5_ALPHAOP D3DTOP_SELECTARG1
#define D3DTSS_STAGE5_COLORARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE5_COLORARG2 D3DTA_CURRENT
#define D3DTSS_STAGE5_COLORARG0 D3DTA_CURRENT
#define D3DTSS_STAGE5_ALPHAARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE5_ALPHAARG2 D3DTA_CURRENT
#define D3DTSS_STAGE5_ALPHAARG0 D3DTA_CURRENT
#define D3DTSS_STAGE5_RESULTARG D3DTA_CURRENT

#define D3DTSS_STAGE6_COLOROP D3DTOP_MODULATE
#define D3DTSS_STAGE6_ALPHAOP D3DTOP_SELECTARG1
#define D3DTSS_STAGE6_COLORARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE6_COLORARG2 D3DTA_CURRENT
#define D3DTSS_STAGE6_COLORARG0 D3DTA_CURRENT
#define D3DTSS_STAGE6_ALPHAARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE6_ALPHAARG2 D3DTA_CURRENT
#define D3DTSS_STAGE6_ALPHAARG0 D3DTA_CURRENT
#define D3DTSS_STAGE6_RESULTARG D3DTA_CURRENT

#define D3DTSS_STAGE7_COLOROP D3DTOP_MODULATE
#define D3DTSS_STAGE7_ALPHAOP D3DTOP_SELECTARG1
#define D3DTSS_STAGE7_COLORARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE7_COLORARG2 D3DTA_CURRENT
#define D3DTSS_STAGE7_COLORARG0 D3DTA_CURRENT
#define D3DTSS_STAGE7_ALPHAARG1 D3DTA_TEXTURE
#define D3DTSS_STAGE7_ALPHAARG2 D3DTA_CURRENT
#define D3DTSS_STAGE7_ALPHAARG0 D3DTA_CURRENT
#define D3DTSS_STAGE7_RESULTARG D3DTA_CURRENT

#define HAS_TEXCOORD0 1
#define HAS_TEXCOORD1 1
#define HAS_TEXCOORD2 1
#define HAS_TEXCOORD3 1
#define HAS_TEXCOORD4 1
#define HAS_TEXCOORD5 1
#define HAS_TEXCOORD6 1
#define HAS_TEXCOORD7 1
#define HAS_VERTEX_COLOR 1
#define HAS_SPECULAR 1
#define HAS_TEX0_BOUND 1
#define HAS_TEX1_BOUND 1
#define HAS_TEX2_BOUND 1
#define HAS_TEX3_BOUND 1
#define HAS_TEX4_BOUND 1
#define HAS_TEX5_BOUND 1
#define HAS_TEX6_BOUND 1
#define HAS_TEX7_BOUND 1
*/
// End sample macro values for testing

const float4 TFACTOR : register(c0); // This is the value set by SetRenderState(D3DTA_TFACTOR). It is shared across all texture stages.
const float4 FOGCOLOR : register(c1); // This is the value set by SetRenderState(D3DRS_FOGCOLOR). It is shared across all texture stages, and only applied if fog is enabled.
const float4 TEXTURESTAGE_CONSTANT[8] : register(c2); // This encompasses c2 thru c9. These are the values set by SetTextureStageState(x, D3DTSS_CONSTANT).
const row_major float2x4 BUMPENVMAT[8] : register(c10); // This encompasses c10 thru c27. These are the values set by SetTextureStageState(x, D3DTSS_BUMPENVMAT00 through D3DTSS_BUMPENVMAT11). The BUMPENVLUMASCALE and BUMPENVLUMAOFFSET values are stored in the .w components of each of the rows (scale in row 0's w, offset in row 1's w).
SAMPLERTYPE0 texture0 : register(s0);
SAMPLERTYPE1 texture1 : register(s1);
SAMPLERTYPE2 texture2 : register(s2);
SAMPLERTYPE3 texture3 : register(s3);
SAMPLERTYPE4 texture4 : register(s4);
SAMPLERTYPE5 texture5 : register(s5);
SAMPLERTYPE6 texture6 : register(s6);
SAMPLERTYPE7 texture7 : register(s7);

#ifdef FLAT_SHADING
	#define LIGHTING_INTERPOLATION nointerpolation
#else
	#define LIGHTING_INTERPOLATION linear
#endif

struct inProcessedVert
{
	LIGHTING_INTERPOLATION float4 diffuse : COLOR0;
	LIGHTING_INTERPOLATION float4 specular : COLOR1;

#ifdef FOG_ENABLE
	float fog : FOG;
#endif

#ifdef HAS_TEXCOORD0
	float4 texCoords0 : TEXCOORD0;
#endif // #ifdef HAS_TEXCOORD0
#ifdef HAS_TEXCOORD1
	float4 texCoords1 : TEXCOORD1;
#endif // #ifdef HAS_TEXCOORD1
#ifdef HAS_TEXCOORD2
	float4 texCoords2 : TEXCOORD2;
#endif // #ifdef HAS_TEXCOORD2
#ifdef HAS_TEXCOORD3
	float4 texCoords3 : TEXCOORD3;
#endif // #ifdef HAS_TEXCOORD3
#ifdef HAS_TEXCOORD4
	float4 texCoords4 : TEXCOORD4;
#endif // #ifdef HAS_TEXCOORD4
#ifdef HAS_TEXCOORD5
	float4 texCoords5 : TEXCOORD5;
#endif // #ifdef HAS_TEXCOORD5
#ifdef HAS_TEXCOORD6
	float4 texCoords6 : TEXCOORD6;
#endif // #ifdef HAS_TEXCOORD6
#ifdef HAS_TEXCOORD7
	float4 texCoords7 : TEXCOORD7;
#endif // #ifdef HAS_TEXCOORD7
};

#if D3DTSS_STAGE0_COLOROP != D3DTOP_DISABLE
	#define STAGE_NUM 0
	#ifdef HAS_TEX0_BOUND
		#define HAS_TEX_BOUND
		#define TEXTYPE TEXTYPE0
	#endif
	#include "FFPS_TexLoad.fxh"
	#define ARGNAME STAGE0_COLORARG1
	#define ARG D3DTSS_STAGE0_COLORARG1
	#include "FFPS_ArgumentSelector.fxh"
	#define ARGNAME STAGE0_COLORARG2
	#define ARG D3DTSS_STAGE0_COLORARG2
	#include "FFPS_ArgumentSelector.fxh"
	#define ARGNAME STAGE0_COLORARG0
	#define ARG D3DTSS_STAGE0_COLORARG0
	#include "FFPS_ArgumentSelector.fxh"
	#define ARGNAME STAGE0_ALPHAARG1
	#define ARG D3DTSS_STAGE0_ALPHAARG1
	#include "FFPS_ArgumentSelector.fxh"
	#define ARGNAME STAGE0_ALPHAARG2
	#define ARG D3DTSS_STAGE0_ALPHAARG2
	#include "FFPS_ArgumentSelector.fxh"
	#define ARGNAME STAGE0_ALPHAARG0
	#define ARG D3DTSS_STAGE0_ALPHAARG0
	#include "FFPS_ArgumentSelector.fxh"
	#define COLOROP D3DTSS_STAGE0_COLOROP
	#define ALPHAOP D3DTSS_STAGE0_ALPHAOP
	#include "FFPS_ApplyColorStage.fxh"
	#undef ALPHAOP
	#undef COLOROP
	#undef STAGE_NUM

	#if D3DTSS_STAGE1_COLOROP != D3DTOP_DISABLE
		#define STAGE_NUM 1
		#ifdef HAS_TEX1_BOUND
			#define HAS_TEX_BOUND
			#define TEXTYPE TEXTYPE1
		#endif
		#include "FFPS_TexLoad.fxh"
		#define ARGNAME STAGE1_COLORARG1
		#define ARG D3DTSS_STAGE1_COLORARG1
		#include "FFPS_ArgumentSelector.fxh"
		#define ARGNAME STAGE1_COLORARG2
		#define ARG D3DTSS_STAGE1_COLORARG2
		#include "FFPS_ArgumentSelector.fxh"
		#define ARGNAME STAGE1_COLORARG0
		#define ARG D3DTSS_STAGE1_COLORARG0
		#include "FFPS_ArgumentSelector.fxh"
		#define ARGNAME STAGE1_ALPHAARG1
		#define ARG D3DTSS_STAGE1_ALPHAARG1
		#include "FFPS_ArgumentSelector.fxh"
		#define ARGNAME STAGE1_ALPHAARG2
		#define ARG D3DTSS_STAGE1_ALPHAARG2
		#include "FFPS_ArgumentSelector.fxh"
		#define ARGNAME STAGE1_ALPHAARG0
		#define ARG D3DTSS_STAGE1_ALPHAARG0
		#include "FFPS_ArgumentSelector.fxh"
		#define COLOROP D3DTSS_STAGE1_COLOROP
		#define ALPHAOP D3DTSS_STAGE1_ALPHAOP
		#include "FFPS_ApplyColorStage.fxh"
		#undef ALPHAOP
		#undef COLOROP
		#undef STAGE_NUM
		#if D3DTSS_STAGE2_COLOROP != D3DTOP_DISABLE
			#define STAGE_NUM 2
			#ifdef HAS_TEX2_BOUND
				#define HAS_TEX_BOUND
				#define TEXTYPE TEXTYPE2
			#endif
			#include "FFPS_TexLoad.fxh"
			#define ARGNAME STAGE2_COLORARG1
			#define ARG D3DTSS_STAGE2_COLORARG1
			#include "FFPS_ArgumentSelector.fxh"
			#define ARGNAME STAGE2_COLORARG2
			#define ARG D3DTSS_STAGE2_COLORARG2
			#include "FFPS_ArgumentSelector.fxh"
			#define ARGNAME STAGE2_COLORARG0
			#define ARG D3DTSS_STAGE2_COLORARG0
			#include "FFPS_ArgumentSelector.fxh"
			#define ARGNAME STAGE2_ALPHAARG1
			#define ARG D3DTSS_STAGE2_ALPHAARG1
			#include "FFPS_ArgumentSelector.fxh"
			#define ARGNAME STAGE2_ALPHAARG2
			#define ARG D3DTSS_STAGE2_ALPHAARG2
			#include "FFPS_ArgumentSelector.fxh"
			#define ARGNAME STAGE2_ALPHAARG0
			#define ARG D3DTSS_STAGE2_ALPHAARG0
			#include "FFPS_ArgumentSelector.fxh"
			#define COLOROP D3DTSS_STAGE2_COLOROP
			#define ALPHAOP D3DTSS_STAGE2_ALPHAOP
			#include "FFPS_ApplyColorStage.fxh"
			#undef ALPHAOP
			#undef COLOROP
			#undef STAGE_NUM
			#if D3DTSS_STAGE3_COLOROP != D3DTOP_DISABLE
				#define STAGE_NUM 3
				#ifdef HAS_TEX3_BOUND
					#define HAS_TEX_BOUND
					#define TEXTYPE TEXTYPE3
				#endif
				#include "FFPS_TexLoad.fxh"
				#define ARGNAME STAGE3_COLORARG1
				#define ARG D3DTSS_STAGE3_COLORARG1
				#include "FFPS_ArgumentSelector.fxh"
				#define ARGNAME STAGE3_COLORARG2
				#define ARG D3DTSS_STAGE3_COLORARG2
				#include "FFPS_ArgumentSelector.fxh"
				#define ARGNAME STAGE3_COLORARG0
				#define ARG D3DTSS_STAGE3_COLORARG0
				#include "FFPS_ArgumentSelector.fxh"
				#define ARGNAME STAGE3_ALPHAARG1
				#define ARG D3DTSS_STAGE3_ALPHAARG1
				#include "FFPS_ArgumentSelector.fxh"
				#define ARGNAME STAGE3_ALPHAARG2
				#define ARG D3DTSS_STAGE3_ALPHAARG2
				#include "FFPS_ArgumentSelector.fxh"
				#define ARGNAME STAGE3_ALPHAARG0
				#define ARG D3DTSS_STAGE3_ALPHAARG0
				#include "FFPS_ArgumentSelector.fxh"
				#define COLOROP D3DTSS_STAGE3_COLOROP
				#define ALPHAOP D3DTSS_STAGE3_ALPHAOP
				#include "FFPS_ApplyColorStage.fxh"
				#undef ALPHAOP
				#undef COLOROP
				#undef STAGE_NUM
				#if D3DTSS_STAGE4_COLOROP != D3DTOP_DISABLE
					#define STAGE_NUM 4
					#ifdef HAS_TEX4_BOUND
						#define HAS_TEX_BOUND
						#define TEXTYPE TEXTYPE4
					#endif
					#include "FFPS_TexLoad.fxh"
					#define ARGNAME STAGE4_COLORARG1
					#define ARG D3DTSS_STAGE4_COLORARG1
					#include "FFPS_ArgumentSelector.fxh"
					#define ARGNAME STAGE4_COLORARG2
					#define ARG D3DTSS_STAGE4_COLORARG2
					#include "FFPS_ArgumentSelector.fxh"
					#define ARGNAME STAGE4_COLORARG0
					#define ARG D3DTSS_STAGE4_COLORARG0
					#include "FFPS_ArgumentSelector.fxh"
					#define ARGNAME STAGE4_ALPHAARG1
					#define ARG D3DTSS_STAGE4_ALPHAARG1
					#include "FFPS_ArgumentSelector.fxh"
					#define ARGNAME STAGE4_ALPHAARG2
					#define ARG D3DTSS_STAGE4_ALPHAARG2
					#include "FFPS_ArgumentSelector.fxh"
					#define ARGNAME STAGE4_ALPHAARG0
					#define ARG D3DTSS_STAGE4_ALPHAARG0
					#include "FFPS_ArgumentSelector.fxh"
					#define COLOROP D3DTSS_STAGE4_COLOROP
					#define ALPHAOP D3DTSS_STAGE4_ALPHAOP
					#include "FFPS_ApplyColorStage.fxh"
					#undef ALPHAOP
					#undef COLOROP
					#undef STAGE_NUM
					#if D3DTSS_STAGE5_COLOROP != D3DTOP_DISABLE
						#define STAGE_NUM 5
						#ifdef HAS_TEX5_BOUND
							#define HAS_TEX_BOUND
							#define TEXTYPE TEXTYPE5
						#endif
						#include "FFPS_TexLoad.fxh"
						#define ARGNAME STAGE5_COLORARG1
						#define ARG D3DTSS_STAGE5_COLORARG1
						#include "FFPS_ArgumentSelector.fxh"
						#define ARGNAME STAGE5_COLORARG2
						#define ARG D3DTSS_STAGE5_COLORARG2
						#include "FFPS_ArgumentSelector.fxh"
						#define ARGNAME STAGE5_COLORARG0
						#define ARG D3DTSS_STAGE5_COLORARG0
						#include "FFPS_ArgumentSelector.fxh"
						#define ARGNAME STAGE5_ALPHAARG1
						#define ARG D3DTSS_STAGE5_ALPHAARG1
						#include "FFPS_ArgumentSelector.fxh"
						#define ARGNAME STAGE5_ALPHAARG2
						#define ARG D3DTSS_STAGE5_ALPHAARG2
						#include "FFPS_ArgumentSelector.fxh"
						#define ARGNAME STAGE5_ALPHAARG0
						#define ARG D3DTSS_STAGE5_ALPHAARG0
						#include "FFPS_ArgumentSelector.fxh"
						#define COLOROP D3DTSS_STAGE5_COLOROP
						#define ALPHAOP D3DTSS_STAGE5_ALPHAOP
						#include "FFPS_ApplyColorStage.fxh"
						#undef ALPHAOP
						#undef COLOROP
						#undef STAGE_NUM
						#if D3DTSS_STAGE6_COLOROP != D3DTOP_DISABLE
							#define STAGE_NUM 6
							#ifdef HAS_TEX6_BOUND
								#define HAS_TEX_BOUND
								#define TEXTYPE TEXTYPE6
							#endif
							#include "FFPS_TexLoad.fxh"
							#define ARGNAME STAGE6_COLORARG1
							#define ARG D3DTSS_STAGE6_COLORARG1
							#include "FFPS_ArgumentSelector.fxh"
							#define ARGNAME STAGE6_COLORARG2
							#define ARG D3DTSS_STAGE6_COLORARG2
							#include "FFPS_ArgumentSelector.fxh"
							#define ARGNAME STAGE6_COLORARG0
							#define ARG D3DTSS_STAGE6_COLORARG0
							#include "FFPS_ArgumentSelector.fxh"
							#define ARGNAME STAGE6_ALPHAARG1
							#define ARG D3DTSS_STAGE6_ALPHAARG1
							#include "FFPS_ArgumentSelector.fxh"
							#define ARGNAME STAGE6_ALPHAARG2
							#define ARG D3DTSS_STAGE6_ALPHAARG2
							#include "FFPS_ArgumentSelector.fxh"
							#define ARGNAME STAGE6_ALPHAARG0
							#define ARG D3DTSS_STAGE6_ALPHAARG0
							#include "FFPS_ArgumentSelector.fxh"
							#define COLOROP D3DTSS_STAGE6_COLOROP
							#define ALPHAOP D3DTSS_STAGE6_ALPHAOP
							#include "FFPS_ApplyColorStage.fxh"
							#undef ALPHAOP
							#undef COLOROP
							#undef STAGE_NUM
							#if D3DTSS_STAGE7_COLOROP != D3DTOP_DISABLE
								#define STAGE_NUM 7
								#ifdef HAS_TEX7_BOUND
									#define HAS_TEX_BOUND
									#define TEXTYPE TEXTYPE7
								#endif
								#include "FFPS_TexLoad.fxh"
								#define ARGNAME STAGE7_COLORARG1
								#define ARG D3DTSS_STAGE7_COLORARG1
								#include "FFPS_ArgumentSelector.fxh"
								#define ARGNAME STAGE7_COLORARG2
								#define ARG D3DTSS_STAGE7_COLORARG2
								#include "FFPS_ArgumentSelector.fxh"
								#define ARGNAME STAGE7_COLORARG0
								#define ARG D3DTSS_STAGE7_COLORARG0
								#include "FFPS_ArgumentSelector.fxh"
								#define ARGNAME STAGE7_ALPHAARG1
								#define ARG D3DTSS_STAGE7_ALPHAARG1
								#include "FFPS_ArgumentSelector.fxh"
								#define ARGNAME STAGE7_ALPHAARG2
								#define ARG D3DTSS_STAGE7_ALPHAARG2
								#include "FFPS_ArgumentSelector.fxh"
								#define ARGNAME STAGE7_ALPHAARG0
								#define ARG D3DTSS_STAGE7_ALPHAARG0
								#include "FFPS_ArgumentSelector.fxh"
								#define COLOROP D3DTSS_STAGE7_COLOROP
								#define ALPHAOP D3DTSS_STAGE7_ALPHAOP
								#include "FFPS_ApplyColorStage.fxh"
								#undef ALPHAOP
								#undef COLOROP
								#undef STAGE_NUM
							#endif // #if D3DTSS_STAGE7_COLOROP != D3DTOP_DISABLE
						#endif // #if D3DTSS_STAGE6_COLOROP != D3DTOP_DISABLE
					#endif // #if D3DTSS_STAGE5_COLOROP != D3DTOP_DISABLE
				#endif // #if D3DTSS_STAGE4_COLOROP != D3DTOP_DISABLE
			#endif // #if D3DTSS_STAGE3_COLOROP != D3DTOP_DISABLE
		#endif // #if D3DTSS_STAGE2_COLOROP != D3DTOP_DISABLE
	#endif // #if D3DTSS_STAGE1_COLOROP != D3DTOP_DISABLE
#endif // #if D3DTSS_STAGE0_COLOROP != D3DTOP_DISABLE

float4 main(const in inProcessedVert input) : COLOR0
{
	float4 texCoords[8];
#ifdef HAS_TEXCOORD0
	texCoords[0] = input.texCoords0;
#else
	texCoords[0] = float4(0.0f, 0.0f, 0.0f, 0.0f);
#endif
#ifdef HAS_TEXCOORD1
	texCoords[1] = input.texCoords1;
#else
	texCoords[1] = float4(0.0f, 0.0f, 0.0f, 0.0f);
#endif
#ifdef HAS_TEXCOORD2
	texCoords[2] = input.texCoords2;
#else
	texCoords[2] = float4(0.0f, 0.0f, 0.0f, 0.0f);
#endif
#ifdef HAS_TEXCOORD3
	texCoords[3] = input.texCoords3;
#else
	texCoords[3] = float4(0.0f, 0.0f, 0.0f, 0.0f);
#endif
#ifdef HAS_TEXCOORD4
	texCoords[4] = input.texCoords4;
#else
	texCoords[4] = float4(0.0f, 0.0f, 0.0f, 0.0f);
#endif
#ifdef HAS_TEXCOORD5
	texCoords[5] = input.texCoords5;
#else
	texCoords[5] = float4(0.0f, 0.0f, 0.0f, 0.0f);
#endif
#ifdef HAS_TEXCOORD6
	texCoords[6] = input.texCoords6;
#else
	texCoords[6] = float4(0.0f, 0.0f, 0.0f, 0.0f);
#endif
#ifdef HAS_TEXCOORD7
	texCoords[7] = input.texCoords7;
#else
	texCoords[7] = float4(0.0f, 0.0f, 0.0f, 0.0f);
#endif

	float4 texRegisters[8];

	const float4 diffuseColor = input.diffuse;
	const float4 specularColor = input.specular;

	// Docs for D3DTA_TEMP specify that it should be initialized to (0, 0, 0, 0), but it seems like it might actually be initialized to (0,0,0,1) when combined with ALPHAREPLICATE?
	float4 tempRegister = float4(0.0f, 0.0f, 0.0f, 0.0f);

	float NextStageLumaMultiplier = 1.0f;

	float4 currentRegister = diffuseColor;

#if D3DTSS_STAGE0_COLOROP != D3DTOP_DISABLE
	texRegisters[0] = TexLoad0(texCoords[D3DTSS_TEXCOORDINDEX0]);
	const float4 stage0colorArg1 = ArgumentSelectSTAGE0_COLORARG1(diffuseColor, specularColor, currentRegister, texRegisters[0], TEXTURESTAGE_CONSTANT[0], tempRegister, 1.0f);
	const float4 stage0colorArg2 = ArgumentSelectSTAGE0_COLORARG2(diffuseColor, specularColor, currentRegister, texRegisters[0], TEXTURESTAGE_CONSTANT[0], tempRegister, 1.0f);
	const float4 stage0colorArg0 = ArgumentSelectSTAGE0_COLORARG0(diffuseColor, specularColor, currentRegister, texRegisters[0], TEXTURESTAGE_CONSTANT[0], tempRegister, 1.0f);
	const float4 stage0alphaArg1 = ArgumentSelectSTAGE0_ALPHAARG1(diffuseColor, specularColor, currentRegister, texRegisters[0], TEXTURESTAGE_CONSTANT[0], tempRegister, 1.0f);
	const float4 stage0alphaArg2 = ArgumentSelectSTAGE0_ALPHAARG2(diffuseColor, specularColor, currentRegister, texRegisters[0], TEXTURESTAGE_CONSTANT[0], tempRegister, 1.0f);
	const float4 stage0alphaArg0 = ArgumentSelectSTAGE0_ALPHAARG0(diffuseColor, specularColor, currentRegister, texRegisters[0], TEXTURESTAGE_CONSTANT[0], tempRegister, 1.0f);
	const float3 stage0resultColor = ApplyColorStage0(stage0colorArg1, stage0colorArg2, stage0colorArg0, diffuseColor.a, texRegisters[0].a, currentRegister, texCoords[D3DTSS_TEXCOORDINDEX1], NextStageLumaMultiplier);
	const float stage0resultAlpha = ApplyAlphaStage0(stage0alphaArg1, stage0alphaArg2, stage0alphaArg0, diffuseColor.a, texRegisters[0].a, currentRegister);
#if D3DTSS_STAGE0_RESULTARG == D3DTA_CURRENT
	currentRegister
#elif D3DTSS_STAGE0_RESULTARG == D3DTA_TEMP
	tempRegister
#else
	#error ERROR: Unknown RESULTARG register used in stage 0!
#endif
	 = float4(stage0resultColor, stage0resultAlpha);
	#if D3DTSS_STAGE1_COLOROP != D3DTOP_DISABLE
		texRegisters[1] = TexLoad1(texCoords[D3DTSS_TEXCOORDINDEX1]);
		const float4 stage1colorArg1 = ArgumentSelectSTAGE1_COLORARG1(diffuseColor, specularColor, currentRegister, texRegisters[1], TEXTURESTAGE_CONSTANT[1], tempRegister, NextStageLumaMultiplier);
		const float4 stage1colorArg2 = ArgumentSelectSTAGE1_COLORARG2(diffuseColor, specularColor, currentRegister, texRegisters[1], TEXTURESTAGE_CONSTANT[1], tempRegister, NextStageLumaMultiplier);
		const float4 stage1colorArg0 = ArgumentSelectSTAGE1_COLORARG0(diffuseColor, specularColor, currentRegister, texRegisters[1], TEXTURESTAGE_CONSTANT[1], tempRegister, NextStageLumaMultiplier);
		const float4 stage1alphaArg1 = ArgumentSelectSTAGE1_ALPHAARG1(diffuseColor, specularColor, currentRegister, texRegisters[1], TEXTURESTAGE_CONSTANT[1], tempRegister, NextStageLumaMultiplier);
		const float4 stage1alphaArg2 = ArgumentSelectSTAGE1_ALPHAARG2(diffuseColor, specularColor, currentRegister, texRegisters[1], TEXTURESTAGE_CONSTANT[1], tempRegister, NextStageLumaMultiplier);
		const float4 stage1alphaArg0 = ArgumentSelectSTAGE1_ALPHAARG0(diffuseColor, specularColor, currentRegister, texRegisters[1], TEXTURESTAGE_CONSTANT[1], tempRegister, NextStageLumaMultiplier);
		const float3 stage1resultColor = ApplyColorStage1(stage1colorArg1, stage1colorArg2, stage1colorArg0, diffuseColor.a, texRegisters[1].a, currentRegister, texCoords[D3DTSS_TEXCOORDINDEX2], NextStageLumaMultiplier);
		const float stage1resultAlpha = ApplyAlphaStage1(stage1alphaArg1, stage1alphaArg2, stage1alphaArg0, diffuseColor.a, texRegisters[1].a, currentRegister);
		#if D3DTSS_STAGE1_RESULTARG == D3DTA_CURRENT
		currentRegister
		#elif D3DTSS_STAGE1_RESULTARG == D3DTA_TEMP
		tempRegister
		#else
			#error ERROR: Unknown RESULTARG register used in stage 1!
		#endif
		 = float4(stage1resultColor, stage1resultAlpha);
		#if D3DTSS_STAGE2_COLOROP != D3DTOP_DISABLE
			texRegisters[2] = TexLoad2(texCoords[D3DTSS_TEXCOORDINDEX2]);
			const float4 stage2colorArg1 = ArgumentSelectSTAGE2_COLORARG1(diffuseColor, specularColor, currentRegister, texRegisters[2], TEXTURESTAGE_CONSTANT[2], tempRegister, NextStageLumaMultiplier);
			const float4 stage2colorArg2 = ArgumentSelectSTAGE2_COLORARG2(diffuseColor, specularColor, currentRegister, texRegisters[2], TEXTURESTAGE_CONSTANT[2], tempRegister, NextStageLumaMultiplier);
			const float4 stage2colorArg0 = ArgumentSelectSTAGE2_COLORARG0(diffuseColor, specularColor, currentRegister, texRegisters[2], TEXTURESTAGE_CONSTANT[2], tempRegister, NextStageLumaMultiplier);
			const float4 stage2alphaArg1 = ArgumentSelectSTAGE2_ALPHAARG1(diffuseColor, specularColor, currentRegister, texRegisters[2], TEXTURESTAGE_CONSTANT[2], tempRegister, NextStageLumaMultiplier);
			const float4 stage2alphaArg2 = ArgumentSelectSTAGE2_ALPHAARG2(diffuseColor, specularColor, currentRegister, texRegisters[2], TEXTURESTAGE_CONSTANT[2], tempRegister, NextStageLumaMultiplier);
			const float4 stage2alphaArg0 = ArgumentSelectSTAGE2_ALPHAARG0(diffuseColor, specularColor, currentRegister, texRegisters[2], TEXTURESTAGE_CONSTANT[2], tempRegister, NextStageLumaMultiplier);
			const float3 stage2resultColor = ApplyColorStage2(stage2colorArg1, stage2colorArg2, stage2colorArg0, diffuseColor.a, texRegisters[2].a, currentRegister, texCoords[D3DTSS_TEXCOORDINDEX3], NextStageLumaMultiplier);
			const float stage2resultAlpha = ApplyAlphaStage2(stage2alphaArg1, stage2alphaArg2, stage2alphaArg0, diffuseColor.a, texRegisters[2].a, currentRegister);
			#if D3DTSS_STAGE2_RESULTARG == D3DTA_CURRENT
			currentRegister
			#elif D3DTSS_STAGE2_RESULTARG == D3DTA_TEMP
			tempRegister
			#else
				#error ERROR: Unknown RESULTARG register used in stage 2!
			#endif
			 = float4(stage2resultColor, stage2resultAlpha);
			#if D3DTSS_STAGE3_COLOROP != D3DTOP_DISABLE
				texRegisters[3] = TexLoad3(texCoords[D3DTSS_TEXCOORDINDEX3]);
				const float4 stage3colorArg1 = ArgumentSelectSTAGE3_COLORARG1(diffuseColor, specularColor, currentRegister, texRegisters[3], TEXTURESTAGE_CONSTANT[3], tempRegister, NextStageLumaMultiplier);
				const float4 stage3colorArg2 = ArgumentSelectSTAGE3_COLORARG2(diffuseColor, specularColor, currentRegister, texRegisters[3], TEXTURESTAGE_CONSTANT[3], tempRegister, NextStageLumaMultiplier);
				const float4 stage3colorArg0 = ArgumentSelectSTAGE3_COLORARG0(diffuseColor, specularColor, currentRegister, texRegisters[3], TEXTURESTAGE_CONSTANT[3], tempRegister, NextStageLumaMultiplier);
				const float4 stage3alphaArg1 = ArgumentSelectSTAGE3_ALPHAARG1(diffuseColor, specularColor, currentRegister, texRegisters[3], TEXTURESTAGE_CONSTANT[3], tempRegister, NextStageLumaMultiplier);
				const float4 stage3alphaArg2 = ArgumentSelectSTAGE3_ALPHAARG2(diffuseColor, specularColor, currentRegister, texRegisters[3], TEXTURESTAGE_CONSTANT[3], tempRegister, NextStageLumaMultiplier);
				const float4 stage3alphaArg0 = ArgumentSelectSTAGE3_ALPHAARG0(diffuseColor, specularColor, currentRegister, texRegisters[3], TEXTURESTAGE_CONSTANT[3], tempRegister, NextStageLumaMultiplier);
				const float3 stage3resultColor = ApplyColorStage3(stage3colorArg1, stage3colorArg2, stage3colorArg0, diffuseColor.a, texRegisters[3].a, currentRegister, texCoords[D3DTSS_TEXCOORDINDEX4], NextStageLumaMultiplier);
				const float stage3resultAlpha = ApplyAlphaStage3(stage3alphaArg1, stage3alphaArg2, stage3alphaArg0, diffuseColor.a, texRegisters[3].a, currentRegister);
				#if D3DTSS_STAGE3_RESULTARG == D3DTA_CURRENT
				currentRegister
				#elif D3DTSS_STAGE3_RESULTARG == D3DTA_TEMP
				tempRegister
				#else
					#error ERROR: Unknown RESULTARG register used in stage 3!
				#endif
				 = float4(stage3resultColor, stage3resultAlpha);
				#if D3DTSS_STAGE4_COLOROP != D3DTOP_DISABLE
					texRegisters[4] = TexLoad4(texCoords[D3DTSS_TEXCOORDINDEX4]);
					const float4 stage4colorArg1 = ArgumentSelectSTAGE4_COLORARG1(diffuseColor, specularColor, currentRegister, texRegisters[4], TEXTURESTAGE_CONSTANT[4], tempRegister, NextStageLumaMultiplier);
					const float4 stage4colorArg2 = ArgumentSelectSTAGE4_COLORARG2(diffuseColor, specularColor, currentRegister, texRegisters[4], TEXTURESTAGE_CONSTANT[4], tempRegister, NextStageLumaMultiplier);
					const float4 stage4colorArg0 = ArgumentSelectSTAGE4_COLORARG0(diffuseColor, specularColor, currentRegister, texRegisters[4], TEXTURESTAGE_CONSTANT[4], tempRegister, NextStageLumaMultiplier);
					const float4 stage4alphaArg1 = ArgumentSelectSTAGE4_ALPHAARG1(diffuseColor, specularColor, currentRegister, texRegisters[4], TEXTURESTAGE_CONSTANT[4], tempRegister, NextStageLumaMultiplier);
					const float4 stage4alphaArg2 = ArgumentSelectSTAGE4_ALPHAARG2(diffuseColor, specularColor, currentRegister, texRegisters[4], TEXTURESTAGE_CONSTANT[4], tempRegister, NextStageLumaMultiplier);
					const float4 stage4alphaArg0 = ArgumentSelectSTAGE4_ALPHAARG0(diffuseColor, specularColor, currentRegister, texRegisters[4], TEXTURESTAGE_CONSTANT[4], tempRegister, NextStageLumaMultiplier);
					const float3 stage4resultColor = ApplyColorStage4(stage4colorArg1, stage4colorArg2, stage4colorArg0, diffuseColor.a, texRegisters[4].a, currentRegister, texCoords[D3DTSS_TEXCOORDINDEX5], NextStageLumaMultiplier);
					const float stage4resultAlpha = ApplyAlphaStage4(stage4alphaArg1, stage4alphaArg2, stage4alphaArg0, diffuseColor.a, texRegisters[4].a, currentRegister);
					#if D3DTSS_STAGE4_RESULTARG == D3DTA_CURRENT
					currentRegister
					#elif D3DTSS_STAGE4_RESULTARG == D3DTA_TEMP
					tempRegister
					#else
						#error ERROR: Unknown RESULTARG register used in stage 4!
					#endif
					 = float4(stage4resultColor, stage4resultAlpha);
					#if D3DTSS_STAGE5_COLOROP != D3DTOP_DISABLE
						texRegisters[5] = TexLoad5(texCoords[D3DTSS_TEXCOORDINDEX5]);
						const float4 stage5colorArg1 = ArgumentSelectSTAGE5_COLORARG1(diffuseColor, specularColor, currentRegister, texRegisters[5], TEXTURESTAGE_CONSTANT[5], tempRegister, NextStageLumaMultiplier);
						const float4 stage5colorArg2 = ArgumentSelectSTAGE5_COLORARG2(diffuseColor, specularColor, currentRegister, texRegisters[5], TEXTURESTAGE_CONSTANT[5], tempRegister, NextStageLumaMultiplier);
						const float4 stage5colorArg0 = ArgumentSelectSTAGE5_COLORARG0(diffuseColor, specularColor, currentRegister, texRegisters[5], TEXTURESTAGE_CONSTANT[5], tempRegister, NextStageLumaMultiplier);
						const float4 stage5alphaArg1 = ArgumentSelectSTAGE5_ALPHAARG1(diffuseColor, specularColor, currentRegister, texRegisters[5], TEXTURESTAGE_CONSTANT[5], tempRegister, NextStageLumaMultiplier);
						const float4 stage5alphaArg2 = ArgumentSelectSTAGE5_ALPHAARG2(diffuseColor, specularColor, currentRegister, texRegisters[5], TEXTURESTAGE_CONSTANT[5], tempRegister, NextStageLumaMultiplier);
						const float4 stage5alphaArg0 = ArgumentSelectSTAGE5_ALPHAARG0(diffuseColor, specularColor, currentRegister, texRegisters[5], TEXTURESTAGE_CONSTANT[5], tempRegister, NextStageLumaMultiplier);
						const float3 stage5resultColor = ApplyColorStage5(stage5colorArg1, stage5colorArg2, stage5colorArg0, diffuseColor.a, texRegisters[5].a, currentRegister, texCoords[D3DTSS_TEXCOORDINDEX6], NextStageLumaMultiplier);
						const float stage5resultAlpha = ApplyAlphaStage5(stage5alphaArg1, stage5alphaArg2, stage5alphaArg0, diffuseColor.a, texRegisters[5].a, currentRegister);
						#if D3DTSS_STAGE5_RESULTARG == D3DTA_CURRENT
						currentRegister
						#elif D3DTSS_STAGE5_RESULTARG == D3DTA_TEMP
						tempRegister
						#else
							#error ERROR: Unknown RESULTARG register used in stage 5!
						#endif
						 = float4(stage5resultColor, stage5resultAlpha);
						#if D3DTSS_STAGE6_COLOROP != D3DTOP_DISABLE
							texRegisters[6] = TexLoad6(texCoords[D3DTSS_TEXCOORDINDEX6]);
							const float4 stage6colorArg1 = ArgumentSelectSTAGE6_COLORARG1(diffuseColor, specularColor, currentRegister, texRegisters[6], TEXTURESTAGE_CONSTANT[6], tempRegister, NextStageLumaMultiplier);
							const float4 stage6colorArg2 = ArgumentSelectSTAGE6_COLORARG2(diffuseColor, specularColor, currentRegister, texRegisters[6], TEXTURESTAGE_CONSTANT[6], tempRegister, NextStageLumaMultiplier);
							const float4 stage6colorArg0 = ArgumentSelectSTAGE6_COLORARG0(diffuseColor, specularColor, currentRegister, texRegisters[6], TEXTURESTAGE_CONSTANT[6], tempRegister, NextStageLumaMultiplier);
							const float4 stage6alphaArg1 = ArgumentSelectSTAGE6_ALPHAARG1(diffuseColor, specularColor, currentRegister, texRegisters[6], TEXTURESTAGE_CONSTANT[6], tempRegister, NextStageLumaMultiplier);
							const float4 stage6alphaArg2 = ArgumentSelectSTAGE6_ALPHAARG2(diffuseColor, specularColor, currentRegister, texRegisters[6], TEXTURESTAGE_CONSTANT[6], tempRegister, NextStageLumaMultiplier);
							const float4 stage6alphaArg0 = ArgumentSelectSTAGE6_ALPHAARG0(diffuseColor, specularColor, currentRegister, texRegisters[6], TEXTURESTAGE_CONSTANT[6], tempRegister, NextStageLumaMultiplier);
							const float3 stage6resultColor = ApplyColorStage6(stage6colorArg1, stage6colorArg2, stage6colorArg0, diffuseColor.a, texRegisters[6].a, currentRegister, texCoords[D3DTSS_TEXCOORDINDEX7], NextStageLumaMultiplier);
							const float stage6resultAlpha = ApplyAlphaStage6(stage6alphaArg1, stage6alphaArg2, stage6alphaArg0, diffuseColor.a, texRegisters[6].a, currentRegister);
							#if D3DTSS_STAGE6_RESULTARG == D3DTA_CURRENT
							currentRegister
							#elif D3DTSS_STAGE6_RESULTARG == D3DTA_TEMP
							tempRegister
							#else
								#error ERROR: Unknown RESULTARG register used in stage 6!
							#endif
							 = float4(stage6resultColor, stage6resultAlpha);
							#if D3DTSS_STAGE7_COLOROP != D3DTOP_DISABLE
								texRegisters[7] = TexLoad7(texCoords[D3DTSS_TEXCOORDINDEX7]);
								const float4 stage7colorArg1 = ArgumentSelectSTAGE7_COLORARG1(diffuseColor, specularColor, currentRegister, texRegisters[7], TEXTURESTAGE_CONSTANT[7], tempRegister, NextStageLumaMultiplier);
								const float4 stage7colorArg2 = ArgumentSelectSTAGE7_COLORARG2(diffuseColor, specularColor, currentRegister, texRegisters[7], TEXTURESTAGE_CONSTANT[7], tempRegister, NextStageLumaMultiplier);
								const float4 stage7colorArg0 = ArgumentSelectSTAGE7_COLORARG0(diffuseColor, specularColor, currentRegister, texRegisters[7], TEXTURESTAGE_CONSTANT[7], tempRegister, NextStageLumaMultiplier);
								const float4 stage7alphaArg1 = ArgumentSelectSTAGE7_ALPHAARG1(diffuseColor, specularColor, currentRegister, texRegisters[7], TEXTURESTAGE_CONSTANT[7], tempRegister, NextStageLumaMultiplier);
								const float4 stage7alphaArg2 = ArgumentSelectSTAGE7_ALPHAARG2(diffuseColor, specularColor, currentRegister, texRegisters[7], TEXTURESTAGE_CONSTANT[7], tempRegister, NextStageLumaMultiplier);
								const float4 stage7alphaArg0 = ArgumentSelectSTAGE7_ALPHAARG0(diffuseColor, specularColor, currentRegister, texRegisters[7], TEXTURESTAGE_CONSTANT[7], tempRegister, NextStageLumaMultiplier);
								float4 dummyPostLastStageTexcoords = float4(0.0f, 0.0f, 0.0f, 0.0f);
								const float3 stage7resultColor = ApplyColorStage7(stage7colorArg1, stage7colorArg2, stage7colorArg0, diffuseColor.a, texRegisters[7].a, currentRegister, dummyPostLastStageTexcoords, NextStageLumaMultiplier);
								const float stage7resultAlpha = ApplyAlphaStage7(stage7alphaArg1, stage7alphaArg2, stage7alphaArg0, diffuseColor.a, texRegisters[7].a, currentRegister);
								#if D3DTSS_STAGE7_RESULTARG == D3DTA_CURRENT
								currentRegister
								#elif D3DTSS_STAGE7_RESULTARG == D3DTA_TEMP
								tempRegister
								#else
									#error ERROR: Unknown RESULTARG register used in stage 7!
								#endif
								 = float4(stage7resultColor, stage7resultAlpha);
							#endif // #if D3DTSS_STAGE7_COLOROP != D3DTOP_DISABLE
						#endif // #if D3DTSS_STAGE6_COLOROP != D3DTOP_DISABLE
					#endif // #if D3DTSS_STAGE5_COLOROP != D3DTOP_DISABLE
				#endif // #if D3DTSS_STAGE4_COLOROP != D3DTOP_DISABLE
			#endif // #if D3DTSS_STAGE3_COLOROP != D3DTOP_DISABLE
		#endif // #if D3DTSS_STAGE2_COLOROP != D3DTOP_DISABLE
	#endif // #if D3DTSS_STAGE1_COLOROP != D3DTOP_DISABLE
#endif // #if D3DTSS_STAGE0_COLOROP != D3DTOP_DISABLE

#ifdef HAS_SPECULAR
	currentRegister.rgb += input.specular.rgb; // Specular .a is not used (it actually may be the vertex shader's oFog scalar register, so the pixel shader should ignore it)
#endif // HAS_SPECULAR

#ifdef FOG_ENABLE
	currentRegister.rgb = lerp(FOGCOLOR.rgb, currentRegister.rgb, input.fog);
#endif

	return saturate(currentRegister);
}

```

`Software_d3d9/FixedFuncEmu/FFVS/Include/FFVS_CalculateSingleLight.fxh`:

```fxh
#ifndef LIGHTTYPE
	#error Error: Do not include this file without defining LIGHTTYPE first to one of: D3DLIGHT_POINT, D3DLIGHT_SPOT, or D3DLIGHT_DIRECTIONAL
#endif
#ifndef LIGHTINDEX
	#error Error: Do not include this file without defining LIGHTINDEX first!
#endif

#define FuncName(x) CalculateFixedFunctionLightingForSingleLight##x

const PerLightResults FuncName(LIGHTINDEX)(in const LightData lightdata, in const float3 viewspaceVertexPos, in const float3 viewspaceVertexNormal)
{
	PerLightResults ret;

	// Calculating Ldir (the light direction relative to the current vertex) is different for directional vs. point/spot lights: https://docs.microsoft.com/en-us/windows/win32/direct3d9/camera-space-transformations
#if LIGHTTYPE == D3DLIGHT_DIRECTIONAL
	const float3 vertexToLightDirNormalized = -lightdata.Direction.xyz;
#else
	const float3 vertexToLightDirRaw = lightdata.Position.xyz - viewspaceVertexPos;
	const float3 vertexToLightDirNormalized = normalize(vertexToLightDirRaw);
#endif

	// Attenuation is calculated based on the equations on this page: https://docs.microsoft.com/en-us/windows/win32/direct3d9/attenuation-and-spotlight-factor#attenuation
#if LIGHTTYPE == D3DLIGHT_POINT || LIGHTTYPE == D3DLIGHT_SPOT
	const float distToLight = length(vertexToLightDirRaw);
	float attenuation;
	[flatten] if (distToLight > lightdata.Position.w)
		attenuation = 0.0f;
	else
		attenuation = 1.0f / (lightdata.Attenuation.x + lightdata.Attenuation.y * distToLight + lightdata.Attenuation.z * (distToLight * distToLight) );
#endif // #if LIGHTTYPE == D3DLIGHT_POINT || LIGHTTYPE == D3DLIGHT_SPOT

	// Spotlight Factor is calculated based on the equations on this page: https://docs.microsoft.com/en-us/windows/win32/direct3d9/attenuation-and-spotlight-factor#spotlight-factor
#if LIGHTTYPE == D3DLIGHT_SPOT
	const float rho = -lightdata.Direction.xyz * vertexToLightDirNormalized;
	float spotlight;
	[flatten] if (rho > lightdata.SpotlightParams.z)
		spotlight = 1.0f;
	else if (rho <= lightdata.SpotlightParams.w)
		spotlight = 0.0f;
	else
		spotlight = pow( (rho - lightdata.SpotlightParams.w) * lightdata.Attenuation.w, lightdata.Direction.w);
#endif // #if LIGHTTYPE == D3DLIGHT_SPOT

#if (LIGHTTYPE < D3DLIGHT_POINT) || (LIGHTTYPE > D3DLIGHT_DIRECTIONAL)
	#error Error: Invalid light type for LIGHTTYPE
#endif

#if LIGHTTYPE == D3DLIGHT_POINT
	ret.Ambient = attenuation * lightdata.Ambient;
#elif LIGHTTYPE == D3DLIGHT_SPOT
	ret.Ambient = attenuation * spotlight * lightdata.Ambient;
#elif LIGHTTYPE == D3DLIGHT_DIRECTIONAL
	ret.Ambient = lightdata.Ambient;
#endif

#if LIGHTTYPE == D3DLIGHT_POINT
	const float NdotL = dot(viewspaceVertexNormal, vertexToLightDirNormalized);
	ret.Diffuse = (NdotL > 0.0f) ? (attenuation * NdotL * lightdata.Diffuse) : float4(0.0f, 0.0f, 0.0f, 0.0f);
#elif LIGHTTYPE == D3DLIGHT_SPOT
	const float NdotL = dot(viewspaceVertexNormal, vertexToLightDirNormalized);
	ret.Diffuse = (NdotL > 0.0f) ? (attenuation * spotlight * NdotL * lightdata.Diffuse) : float4(0.0f, 0.0f, 0.0f, 0.0f);
#elif LIGHTTYPE == D3DLIGHT_DIRECTIONAL
	const float NdotL = dot(viewspaceVertexNormal, vertexToLightDirNormalized);
	ret.Diffuse = (NdotL > 0.0f) ? (NdotL * lightdata.Diffuse) : float4(0.0f, 0.0f, 0.0f, 0.0f);
#endif

	// D3DRS_LOCALVIEWER changes the computation of the halfway vector, so account for that here
#ifdef D3DRS_LOCALVIEWER
	#if LIGHTTYPE == D3DLIGHT_POINT
	const float3 halfVector = normalize(normalize(-viewspaceVertexPos) + vertexToLightDirNormalized);
	#elif LIGHTTYPE == D3DLIGHT_SPOT
	const float3 halfVector = normalize(normalize(-viewspaceVertexPos) + lightdata.Direction.xyz);
	#elif LIGHTTYPE == D3DLIGHT_DIRECTIONAL
	const float3 halfVector = normalize(normalize(-viewspaceVertexPos) + lightdata.Direction.xyz);
	#endif
#else // #ifdef D3DRS_LOCALVIEWER
	#if LIGHTTYPE == D3DLIGHT_POINT
	const float3 halfVector = normalize(float3(0.0f, 0.0f, 1.0f) + vertexToLightDirNormalized);
	#elif LIGHTTYPE == D3DLIGHT_SPOT
	const float3 halfVector = normalize(float3(0.0f, 0.0f, 1.0f) + lightdata.Direction.xyz);
	#elif LIGHTTYPE == D3DLIGHT_DIRECTIONAL
	const float3 halfVector = normalize(float3(0.0f, 0.0f, 1.0f) + lightdata.Direction.xyz);
	#endif
#endif // #ifdef D3DRS_LOCALVIEWER

#if LIGHTTYPE == D3DLIGHT_POINT
	const float specComponent = pow(dot(viewspaceVertexNormal, halfVector), materialData.Specular.w);
	ret.Specular = attenuation * specComponent * lightdata.Specular;
#elif LIGHTTYPE == D3DLIGHT_SPOT
	const float specComponent = pow(dot(viewspaceVertexNormal, halfVector), materialData.Specular.w);
	ret.Specular = attenuation * spotlight * specComponent * lightdata.Specular;
#elif LIGHTTYPE == D3DLIGHT_DIRECTIONAL
	const float specComponent = pow(dot(viewspaceVertexNormal, halfVector), materialData.Specular.w);
	ret.Specular = specComponent * lightdata.Specular;
#endif

	return ret;
}

#undef LIGHTINDEX
#undef LIGHTTYPE

```

`Software_d3d9/FixedFuncEmu/FFVS/Source/FixedFunctionVertexShader.hlsl`:

```hlsl
#define D3DTSS_TCI_PASSTHRU 0
#define D3DTSS_TCI_CAMERASPACENORMAL 1
#define D3DTSS_TCI_CAMERASPACEPOSITION 2
#define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR 3
#define D3DTSS_TCI_SPHEREMAP 4

#define D3DMCS_MATERIAL 0
#define D3DMCS_COLOR1 1
#define D3DMCS_COLOR2 2

#define D3DLIGHT_POINT 1
#define D3DLIGHT_SPOT 2
#define D3DLIGHT_DIRECTIONAL 3

#define D3DFOG_NONE		0
#define D3DFOG_EXP		1
#define D3DFOG_EXP2		2
#define D3DFOG_LINEAR	3

#define D3DVBF_DISABLE 0 // Disable vertex blending
#define D3DVBF_0WEIGHTS 256 // one matrix is used with weight 1.0
#define D3DVBF_1WEIGHTS 1 // 2 matrix blending
#define D3DVBF_2WEIGHTS 2 // 3 matrix blending
#define D3DVBF_3WEIGHTS 3 // 4 matrix blending
#define D3DVBF_TWEENING 255 // blending using D3DRS_TWEENFACTOR

#define MAX_WORLD_TRANSFORMS 256

#ifndef TEX0TYPE
	#define TEX0TYPE float4
#endif // #ifndef TEX0TYPE

#ifndef TEX1TYPE
	#define TEX1TYPE float4
#endif // #ifndef TEX1TYPE

#ifndef TEX2TYPE
	#define TEX2TYPE float4
#endif // #ifndef TEX2TYPE

#ifndef TEX3TYPE
	#define TEX3TYPE float4
#endif // #ifndef TEX3TYPE

#ifndef TEX4TYPE
	#define TEX4TYPE float4
#endif // #ifndef TEX4TYPE

#ifndef TEX5TYPE
	#define TEX5TYPE float4
#endif // #ifndef TEX5TYPE

#ifndef TEX6TYPE
	#define TEX6TYPE float4
#endif // #ifndef TEX6TYPE

#ifndef TEX7TYPE
	#define TEX7TYPE float4
#endif // #ifndef TEX7TYPE

// These TEXNREMAP defines correspond to the D3DTSS_TEXCOORDINDEX setting for which texcoord channel to
// source from (when D3DTSS_TCI_PASSTHRU is used anyway, since auto-generated texcoords ignore input texcoord channels)
#ifndef TEX0REMAP
	#define TEX0REMAP tex0
#endif // #ifndef TEX0REMAP

#ifndef TEX1REMAP
	#define TEX1REMAP tex1
#endif // #ifndef TEX1REMAP

#ifndef TEX2REMAP
	#define TEX2REMAP tex2
#endif // #ifndef TEX2REMAP

#ifndef TEX3REMAP
	#define TEX3REMAP tex3
#endif // #ifndef TEX3REMAP

#ifndef TEX4REMAP
	#define TEX4REMAP tex4
#endif // #ifndef TEX4REMAP

#ifndef TEX5REMAP
	#define TEX5REMAP tex5
#endif // #ifndef TEX5REMAP

#ifndef TEX6REMAP
	#define TEX6REMAP tex6
#endif // #ifndef TEX6REMAP

#ifndef TEX7REMAP
	#define TEX7REMAP tex7
#endif // #ifndef TEX7REMAP

#ifndef D3DTSS_TEXCOORDINDEX0TYPE
	#define D3DTSS_TEXCOORDINDEX0TYPE D3DTSS_TCI_PASSTHRU
#endif // #ifndef D3DTSS_TEXCOORDINDEX0TYPE

#ifndef D3DTSS_TEXCOORDINDEX1TYPE
	#define D3DTSS_TEXCOORDINDEX1TYPE D3DTSS_TCI_PASSTHRU
#endif // #ifndef D3DTSS_TEXCOORDINDEX1TYPE

#ifndef D3DTSS_TEXCOORDINDEX2TYPE
	#define D3DTSS_TEXCOORDINDEX2TYPE D3DTSS_TCI_PASSTHRU
#endif // #ifndef D3DTSS_TEXCOORDINDEX2TYPE

#ifndef D3DTSS_TEXCOORDINDEX3TYPE
	#define D3DTSS_TEXCOORDINDEX3TYPE D3DTSS_TCI_PASSTHRU
#endif // #ifndef D3DTSS_TEXCOORDINDEX3TYPE

#ifndef D3DTSS_TEXCOORDINDEX4TYPE
	#define D3DTSS_TEXCOORDINDEX4TYPE D3DTSS_TCI_PASSTHRU
#endif // #ifndef D3DTSS_TEXCOORDINDEX4TYPE

#ifndef D3DTSS_TEXCOORDINDEX5TYPE
	#define D3DTSS_TEXCOORDINDEX5TYPE D3DTSS_TCI_PASSTHRU
#endif // #ifndef D3DTSS_TEXCOORDINDEX5TYPE

#ifndef D3DTSS_TEXCOORDINDEX6TYPE
	#define D3DTSS_TEXCOORDINDEX6TYPE D3DTSS_TCI_PASSTHRU
#endif // #ifndef D3DTSS_TEXCOORDINDEX6TYPE

#ifndef D3DTSS_TEXCOORDINDEX7TYPE
	#define D3DTSS_TEXCOORDINDEX7TYPE D3DTSS_TCI_PASSTHRU
#endif // #ifndef D3DTSS_TEXCOORDINDEX7TYPE

struct D3DMATERIAL9
{
	float4 Diffuse;
	float4 Specular; // This contains Specular as RGB and Specular Power as A
	float4 Ambient;
	float3 Emissive; // Emissive.a is not used
};

struct LightData
{
	float4 Diffuse;
	float4 Specular;
	float4 Ambient;
	float4 Position; // XYZ = Position (in view-space), W = Range
	float4 Direction; // XYZ = Direction (normalized and in view-space), W = Falloff
	float4 Attenuation; // XYZ = attenuation, W = 1.0f / (cos(theta / 2) - cos(phi / 2) )
	float4 SpotlightParams; // X = phi, Y = theta, Z = cos(theta / 2), W = cos(phi / 2)
};

#ifndef DIFFUSEMATERIALSOURCE
	#define DIFFUSEMATERIALSOURCE D3DMCS_COLOR1
#endif

#ifndef SPECULARMATERIALSOURCE
	#define SPECULARMATERIALSOURCE D3DMCS_COLOR2
#endif

#ifndef AMBIENTMATERIALSOURCE
	#define AMBIENTMATERIALSOURCE D3DMCS_MATERIAL
#endif

#ifndef EMISSIVEMATERIALSOURCE
	#define EMISSIVEMATERIALSOURCE D3DMCS_MATERIAL
#endif

// Testing!
/*#define OUTPUT_FOG 1
#define D3DFOG_LINEAR 3
#define D3DRS_FOGVERTEXMODE D3DFOG_LINEAR
#define OUTPUT_POINTSIZE 1
#define DECL_HAS_TEX0 1
#define DECL_HAS_NORMAL0 1
#define VERTEXBLEND D3DVBF_3WEIGHTS
#define INPUT_HAS_BLENDWEIGHTS 1
#define INPUT_HAS_LASTBETA 1
#define INDEXEDVERTEXBLENDENABLE 1
#define INPUT_HAS_TEXCOORD0 1
#define OUTPUT_TEX0 1
#define USE_TEXTRANSFORM0 1*/

struct wvMatrix
{
	row_major float4x4 wv;
	row_major float3x3 invTransposeWV;
};

const row_major float4x4 wvp : register(c3); // row_major seems to be more efficient than column_major from the vertex shader PoV
#ifdef VERTEX_TWEENING
	const float TWEENFACTOR : register(c7);
#endif // #ifdef VERTEX_TWEENING
#ifdef OUTPUT_POINTSIZE
	const float3 pointScaleParams : register(c8); // float3(D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, D3DRS_POINTSCALE_C). Example (using default D3D9 values): float3(1.0f, 0.0f, 0.0f)
	const float4 pointScaleData : register(c9); // float4(D3DRS_POINTSIZE_MAX, D3DRS_POINTSIZE_MIN, D3DRS_POINTSIZE, ViewportHeight (in whole-number pixels). Example: float4(8192.0f, 0.0f, 64.0f, 480.0f) for a 640x480 viewport
#endif // #ifdef OUTPUT_POINTSIZE
#ifdef OUTPUT_FOG
	const float3 fogData : register(c14); // float3(D3DRS_FOGSTART, D3DRS_FOGEND, D3DRS_FOGDENSITY) // TODO: Check that this is not reversed start/end or scale/offset format
#endif // #ifdef OUTPUT_FOG
const D3DMATERIAL9 materialData : register(c15); // c15, c16, c17, c18
const float4 AMBIENT : register(c19); // Global ambient color, set by SetRenderState(D3DRS_AMBIENT, ...)
const row_major float4x4 texMatrices[8] : register(c20); // It looks like texcoord matrix transforms get applied *after* autogeneration of texcoords (i.e. D3DTSS_TCI_CAMERA_*). c20 thru c51
const LightData enabledLightsData[8] : register(c52); // c52 thru c107
const row_major float4x4 proj : register(c108); // c108 thru c111
const wvMatrix wvBlendingMatrices[MAX_WORLD_TRANSFORMS] : register(c112); // This should always be last

#define D3DRS_POINTSIZE_MAX pointScaleData.x
#define D3DRS_POINTSIZE_MIN pointScaleData.y
#define D3DRS_POINTSIZE pointScaleData.z
#define ViewportHeight pointScaleData.w
#define D3DRS_POINTSCALE_A pointScaleParams.x
#define D3DRS_POINTSCALE_B pointScaleParams.y
#define D3DRS_POINTSCALE_C pointScaleParams.z
#define D3DRS_FOGSTART fogData.x
#define D3DRS_FOGEND fogData.y
#define D3DRS_FOGDENSITY fogData.z

struct inVert
{
	float3 POS0 : POSITION0;
#ifdef DECL_HAS_POSITION1
	float3 POS1 : POSITION1;
#endif // #ifdef DECL_HAS_POSITION1

#ifdef INPUT_HAS_BLENDWEIGHTS
	float4 blendweights : BLENDWEIGHT0;
#ifdef INPUT_HAS_LASTBETA
	int4 blendindices : BLENDINDICES0;
#endif // #ifdef INPUT_HAS_LASTBETA
#endif // #ifdef INPUT_HAS_BLENDWEIGHTS
#ifdef DECL_HAS_NORMAL0
	float3 NORM0 : NORMAL0;
#endif // #ifdef DECL_HAS_NORMAL0
#ifdef DECL_HAS_NORMAL1
	float3 NORM1 : NORMAL1;
#endif // #ifdef DECL_HAS_NORMAL1
#ifdef PER_VERTEX_POINTSIZE
	float PSIZ0 : PSIZE0;
#endif // #ifdef PER_VERTEX_POINTSIZE
#ifdef INPUT_HAS_DIFFUSE
	float4 diffuse : COLOR0;
#endif // #ifdef INPUT_HAS_DIFFUSE
#ifdef INPUT_HAS_SPECULAR
	float4 specular : COLOR1;
#endif // #ifdef INPUT_HAS_SPECULAR

#ifdef INPUT_HAS_TEXCOORD0
	TEX0TYPE TEX0 : TEXCOORD0;
#endif // #ifdef INPUT_HAS_TEX0
#ifdef INPUT_HAS_TEXCOORD1
	TEX1TYPE TEX1 : TEXCOORD1;
#endif // #ifdef INPUT_HAS_TEX1
#ifdef INPUT_HAS_TEXCOORD2
	TEX2TYPE TEX2 : TEXCOORD2;
#endif // #ifdef INPUT_HAS_TEX2
#ifdef INPUT_HAS_TEXCOORD3
	TEX3TYPE TEX3 : TEXCOORD3;
#endif // #ifdef INPUT_HAS_TEX3
#ifdef INPUT_HAS_TEXCOORD4
	TEX4TYPE TEX4 : TEXCOORD4;
#endif // #ifdef INPUT_HAS_TEX4
#ifdef INPUT_HAS_TEXCOORD5
	TEX5TYPE TEX5 : TEXCOORD5;
#endif // #ifdef INPUT_HAS_TEX5
#ifdef INPUT_HAS_TEXCOORD6
	TEX6TYPE TEX6 : TEXCOORD6;
#endif // #ifdef INPUT_HAS_TEX6
#ifdef INPUT_HAS_TEXCOORD7
	TEX7TYPE TEX7 : TEXCOORD7;
#endif // #ifdef INPUT_HAS_TEX7

};

struct outVert
{
	float4 OPOS : POSITION0;
#ifdef OUTPUT_POINTSIZE
	float oPts : PSIZE;
#endif // #ifdef OUTPUT_POINTSIZE
	float4 oDiffuse : COLOR0;
#if defined(D3DRS_SPECULARENABLE) && defined(LIGHTING)
	float4 oSpecular : COLOR1;
#endif // #if defined(D3DRS_SPECULARENABLE) && defined(LIGHTING)
#ifdef OUTPUT_FOG
	float oFog : FOG;
#endif // #ifdef OUTPUT_FOG
#ifdef OUTPUT_TEX0
	TEX0TYPE TEX0 : TEXCOORD0;
#endif // #ifdef OUTPUT_TEX0
#ifdef OUTPUT_TEX1
	TEX0TYPE TEX1 : TEXCOORD1;
#endif // #ifdef OUTPUT_TEX1
#ifdef OUTPUT_TEX2
	TEX0TYPE TEX2 : TEXCOORD2;
#endif // #ifdef OUTPUT_TEX2
#ifdef OUTPUT_TEX3
	TEX0TYPE TEX3 : TEXCOORD3;
#endif // #ifdef OUTPUT_TEX3
#ifdef OUTPUT_TEX4
	TEX0TYPE TEX4 : TEXCOORD4;
#endif // #ifdef OUTPUT_TEX4
#ifdef OUTPUT_TEX5
	TEX0TYPE TEX5 : TEXCOORD5;
#endif // #ifdef OUTPUT_TEX5
#ifdef OUTPUT_TEX6
	TEX0TYPE TEX6 : TEXCOORD6;
#endif // #ifdef OUTPUT_TEX6
#ifdef OUTPUT_TEX7
	TEX0TYPE TEX7 : TEXCOORD7;
#endif // #ifdef OUTPUT_TEX7
};

struct posNormal
{
	float4 OPOS;
	float3 worldViewPos;
	float3 oNormal;
};

const float4 GetVertexBlendWeights(in const inVert input)
{
#ifdef INPUT_HAS_BLENDWEIGHTS
	return input.blendweights;
#else // #ifdef INPUT_HAS_BLENDWEIGHTS
	return float4(1.0f, 0.0f, 0.0f, 0.0f);
#endif // #ifdef INPUT_HAS_BLENDWEIGHTS
}

const int4 GetVertexBlendIndices(in const inVert input)
{
#if defined(INPUT_HAS_BLENDWEIGHTS) && defined(INPUT_HAS_LASTBETA)
	return input.blendindices;
#else // #if defined(INPUT_HAS_BLENDWEIGHTS) && defined(INPUT_HAS_LASTBETA)
	return int4(0, 1, 2, 3);
#endif // #if defined(INPUT_HAS_BLENDWEIGHTS) && defined(INPUT_HAS_LASTBETA)
}

const float4 GetVertexDiffuse(in const inVert input)
{
#ifdef INPUT_HAS_DIFFUSE
	return input.diffuse;
#else // #ifdef INPUT_HAS_DIFFUSE
	return float4(1.0f, 1.0f, 1.0f, 1.0f);
#endif // #ifdef INPUT_HAS_DIFFUSE
}

const float4 GetVertexSpecular(in const inVert input)
{
#ifdef INPUT_HAS_SPECULAR
	return input.specular;
#else // #ifdef INPUT_HAS_SPECULAR
	return float4(1.0f, 1.0f, 1.0f, 1.0f);
#endif // #ifdef INPUT_HAS_SPECULAR
}

const float4 GetMaterialDiffuse(in const inVert input)
{
#if (DIFFUSEMATERIALSOURCE < D3DMCS_MATERIAL) || (DIFFUSEMATERIALSOURCE > D3DMCS_COLOR2)
	#error Error: Invalid DIFFUSEMATERIALSOURCE enum specified!
#endif

#if DIFFUSEMATERIALSOURCE == D3DMCS_COLOR1 && defined(INPUT_HAS_DIFFUSE)
	return input.diffuse;
#elif DIFFUSEMATERIALSOURCE == D3DMCS_COLOR2 && defined(INPUT_HAS_SPECULAR)
	return input.specular;
#else
	return materialData.Diffuse;
#endif
}

const float4 GetMaterialSpecular(in const inVert input)
{
#if (SPECULARMATERIALSOURCE < D3DMCS_MATERIAL) || (SPECULARMATERIALSOURCE > D3DMCS_COLOR2)
	#error Error: Invalid SPECULARMATERIALSOURCE enum specified!
#endif

#if SPECULARMATERIALSOURCE == D3DMCS_COLOR1 && defined(INPUT_HAS_DIFFUSE)
	return input.diffuse;
#elif SPECULARMATERIALSOURCE == D3DMCS_COLOR2 && defined(INPUT_HAS_SPECULAR)
	return input.specular;
#else
	return materialData.Specular;
#endif
}

const float4 GetMaterialAmbient(in const inVert input)
{
#if (AMBIENTMATERIALSOURCE < D3DMCS_MATERIAL) || (AMBIENTMATERIALSOURCE > D3DMCS_COLOR2)
	#error Error: Invalid AMBIENTMATERIALSOURCE enum specified!
#endif

#if AMBIENTMATERIALSOURCE == D3DMCS_COLOR1 && defined(INPUT_HAS_DIFFUSE)
	return input.diffuse;
#elif AMBIENTMATERIALSOURCE == D3DMCS_COLOR2 && defined(INPUT_HAS_SPECULAR)
	return input.specular;
#else
	return materialData.Ambient;
#endif
}

const float3 GetMaterialEmissive(in const inVert input)
{
#if (EMISSIVEMATERIALSOURCE < D3DMCS_MATERIAL) || (EMISSIVEMATERIALSOURCE > D3DMCS_COLOR2)
	#error Error: Invalid EMISSIVEMATERIALSOURCE enum specified!
#endif

#if EMISSIVEMATERIALSOURCE == D3DMCS_COLOR1 && defined(INPUT_HAS_DIFFUSE)
	return input.diffuse.rgb;
#elif EMISSIVEMATERIALSOURCE == D3DMCS_COLOR2 && defined(INPUT_HAS_SPECULAR)
	return input.specular.rgb;
#else
	return materialData.Emissive.rgb;
#endif
}

const float3 GetInputPosition0(in const inVert input)
{
#ifdef DECL_HAS_POSITION0
	return input.POS0;
#else // #ifdef DECL_HAS_POSITION0
	return float3(0.0f, 0.0f, 0.0f);
#endif // #ifdef DECL_HAS_POSITION0
}

const float3 GetInputNormal0(in const inVert input)
{
#ifdef DECL_HAS_NORMAL0
	return input.NORM0;
#else // #ifdef DECL_HAS_NORMAL0
	return float3(0.0f, 0.0f, 0.0f);
#endif // #ifdef DECL_HAS_NORMAL0
}

#ifdef VERTEX_TWEENING
const float3 GetInputPosition1(in const inVert input)
{
#ifdef DECL_HAS_POSITION1
	return input.POS1;
#else // #ifdef DECL_HAS_POSITION1
	reutrn input.POS0; // If a second vertex position is not available, don't do any tweening
#endif // #ifdef DECL_HAS_POSITION1
}

const float3 GetInputNormal1(in const inVert input)
{
#ifdef DECL_HAS_NORMAL1
	return input.NORM1;
#else // #ifdef DECL_HAS_NORMAL1
	return input.NORM0; // If a second vertex normal is not available, don't do any tweening
#endif // #ifdef DECL_HAS_NORMAL1
}
#endif // #ifdef VERTEX_TWEENING

const posNormal ComputePosNormal(in const inVert input)
{
	posNormal ret;

	float3 inPos = GetInputPosition0(input);
	float3 inNormal = GetInputNormal0(input);

#if VERTEXBLEND == D3DVBF_TWEENING
	const float3 inPos2 = GetInputPosition1(input);
	const float3 inNorm2 = GetInputNormal1(input);
	inPos = lerp(inPos, inPos2, TWEENFACTOR); // https://docs.microsoft.com/en-us/windows/win32/direct3d9/vertex-tweening
	inNormal = lerp(inNormal, inNorm2, TWEENFACTOR); // https://docs.microsoft.com/en-us/windows/win32/direct3d9/vertex-tweening
#endif // #if VERTEXBLEND == D3DVBF_TWEENING

#ifdef INDEXEDVERTEXBLENDENABLE
	const int4 indices = GetVertexBlendIndices(input);
#else
	const int4 indices = int4(0, 1, 2, 3);
#endif

	const float4 blendweights = GetVertexBlendWeights(input);

#if VERTEXBLEND == D3DVBF_3WEIGHTS // 4 matrix blending
	const float3 blend0 = mul(float4(inPos, 1.0f), wvBlendingMatrices[indices.x].wv).xyz;
	const float3 blend1 = mul(float4(inPos, 1.0f), wvBlendingMatrices[indices.y].wv).xyz;
	const float3 blend2 = mul(float4(inPos, 1.0f), wvBlendingMatrices[indices.z].wv).xyz;
	const float3 blend3 = mul(float4(inPos, 1.0f), wvBlendingMatrices[indices.w].wv).xyz;
	const float3 blendNormal0 = mul(wvBlendingMatrices[indices.x].invTransposeWV, inNormal);
	const float3 blendNormal1 = mul(wvBlendingMatrices[indices.y].invTransposeWV, inNormal);
	const float3 blendNormal2 = mul(wvBlendingMatrices[indices.z].invTransposeWV, inNormal);
	const float3 blendNormal3 = mul(wvBlendingMatrices[indices.w].invTransposeWV, inNormal);
	const float residual = (1.0f - (blendweights.x + blendweights.y + blendweights.z) );
	ret.worldViewPos = blend0 * blendweights.x + blend1 * blendweights.y + blend2 * blendweights.z + blend3 * residual;
	ret.OPOS = mul(float4(ret.worldViewPos, 1.0f), proj);
	ret.oNormal = blendNormal0 * blendweights.x + blendNormal1 * blendweights.y + blendNormal2 * blendweights.z + blendNormal3 * residual;
#elif VERTEXBLEND == D3DVBF_2WEIGHTS // 3 matrix blending
	const float3 blend0 = mul(float4(inPos, 1.0f), wvBlendingMatrices[indices.x].wv).xyz;
	const float3 blend1 = mul(float4(inPos, 1.0f), wvBlendingMatrices[indices.y].wv).xyz;
	const float3 blend2 = mul(float4(inPos, 1.0f), wvBlendingMatrices[indices.z].wv).xyz;
	const float3 blendNormal0 = mul(wvBlendingMatrices[indices.x].invTransposeWV, inNormal);
	const float3 blendNormal1 = mul(wvBlendingMatrices[indices.y].invTransposeWV, inNormal);
	const float3 blendNormal2 = mul(wvBlendingMatrices[indices.z].invTransposeWV, inNormal);
	const float residual = (1.0f - (blendweights.x + blendweights.y) );
	ret.worldViewPos = blend0 * blendweights.x + blend1 * blendweights.y + blend2 * residual;
	ret.OPOS = mul(float4(ret.worldViewPos, 1.0f), proj);
	ret.oNormal = blendNormal0 * blendweights.x + blendNormal1 * blendweights.y + blendNormal2 * residual;
#elif VERTEXBLEND == D3DVBF_1WEIGHTS // 2 matrix blending
	const float3 blend0 = mul(float4(inPos, 1.0f), wvBlendingMatrices[indices.x].wv).xyz;
	const float3 blend1 = mul(float4(inPos, 1.0f), wvBlendingMatrices[indices.y].wv).xyz;
	const float3 blendNormal0 = mul(wvBlendingMatrices[indices.x].invTransposeWV, inNormal);
	const float3 blendNormal1 = mul(wvBlendingMatrices[indices.y].invTransposeWV, inNormal);
	ret.worldViewPos = lerp(blend0, blend1, blendweights.x);
	ret.OPOS = mul(float4(ret.worldViewPos, 1.0f), proj);
	ret.oNormal = lerp(blendNormal0, blendNormal1, blendweights.x);
#elif VERTEXBLEND == D3DVBF_0WEIGHTS // 1 matrix blending
	ret.worldViewPos = mul(float4(inPos, 1.0f), wvBlendingMatrices[indices.x].wv).xyz;
	ret.OPOS = mul(float4(ret.worldViewPos, 1.0f), proj);
	ret.oNormal = mul(wvBlendingMatrices[indices.x].invTransposeWV, inNormal);
#else
	ret.worldViewPos = mul(float4(inPos, 1.0f), wvBlendingMatrices[0].wv).xyz;
	ret.OPOS = mul(float4(inPos, 1.0f), wvp);
	ret.oNormal = mul(wvBlendingMatrices[0].invTransposeWV, inNormal);
#endif

#ifdef D3DRS_NORMALIZENORMALS // This corresponds to the D3DRS_NORMALIZENORMALS render state
	ret.oNormal = (length(ret.oNormal) == 0.0f ? float3(0.0f, 0.0f, 0.0f) : normalize(ret.oNormal) );
#endif // #ifdef NORMALIZE_NORMALS

	return ret;
}

const float3 AutoGenTexcoords_CAMERASPACENORMAL(in const posNormal viewspacePN)
{
	return viewspacePN.oNormal;
}

const float3 AutoGenTexcoords_CAMERASPACEPOSITION(in const posNormal viewspacePN)
{
	return viewspacePN.worldViewPos;
}

const float3 AutoGenTexcoords_CAMERASPACEREFLECTIONVECTOR(in const posNormal viewspacePN)
{
	const float3 normalizedViewPos = normalize(viewspacePN.worldViewPos);
	const float scaleFactor = dot(normalizedViewPos, viewspacePN.oNormal) * 2.0f;
	return mad(-scaleFactor, viewspacePN.oNormal, normalizedViewPos);
}

const float2 AutoGenTexcoords_SPHEREMAP(in const posNormal viewspacePN)
{
	const float3 normalizedViewPos = normalize(viewspacePN.worldViewPos);
	const float rawSphereDirection = dot(viewspacePN.oNormal, normalizedViewPos) * 2.0f;
	float3 sphereReflectionVector = mad(-rawSphereDirection, viewspacePN.oNormal, normalizedViewPos);
	sphereReflectionVector.z -= 1.0f;
	sphereReflectionVector.z = length(sphereReflectionVector) * 0.5f;
	const float2 retVec = mad(sphereReflectionVector.xy, sphereReflectionVector.z, 0.5f);
	return retVec;
}

const TEX0TYPE GetTex0(in const inVert input)
{
#ifdef INPUT_HAS_TEXCOORD0
	return input.TEX0;
#else // #ifdef INPUT_HAS_TEXCOORD0
	return 0.0f;
#endif // #ifdef INPUT_HAS_TEXCOORD0
}

const TEX1TYPE GetTex1(in const inVert input)
{
#ifdef INPUT_HAS_TEXCOORD1
	return input.TEX1;
#else // #ifdef INPUT_HAS_TEXCOORD1
	return 0.0f;
#endif // #ifdef INPUT_HAS_TEXCOORD1
}

const TEX2TYPE GetTex2(in const inVert input)
{
#ifdef INPUT_HAS_TEXCOORD2
	return input.TEX2;
#else // #ifdef INPUT_HAS_TEXCOORD2
	return 0.0f;
#endif // #ifdef INPUT_HAS_TEXCOORD2
}

const TEX3TYPE GetTex3(in const inVert input)
{
#ifdef INPUT_HAS_TEXCOORD3
	return input.TEX3;
#else // #ifdef INPUT_HAS_TEXCOORD3
	return 0.0f;
#endif // #ifdef INPUT_HAS_TEXCOORD3
}

const TEX4TYPE GetTex4(in const inVert input)
{
#ifdef INPUT_HAS_TEXCOORD4
	return input.TEX4;
#else // #ifdef INPUT_HAS_TEXCOORD4
	return 0.0f;
#endif // #ifdef INPUT_HAS_TEXCOORD4
}

const TEX5TYPE GetTex5(in const inVert input)
{
#ifdef INPUT_HAS_TEXCOORD5
	return input.TEX5;
#else // #ifdef INPUT_HAS_TEXCOORD5
	return 0.0f;
#endif // #ifdef INPUT_HAS_TEXCOORD5
}

const TEX6TYPE GetTex6(in const inVert input)
{
#ifdef INPUT_HAS_TEXCOORD6
	return input.TEX6;
#else // #ifdef INPUT_HAS_TEXCOORD6
	return 0.0f;
#endif // #ifdef INPUT_HAS_TEXCOORD6
}

const TEX7TYPE GetTex7(in const inVert input)
{
#ifdef INPUT_HAS_TEXCOORD7
	return input.TEX7;
#else // #ifdef INPUT_HAS_TEXCOORD7
	return 0.0f;
#endif // #ifdef INPUT_HAS_TEXCOORD7
}

const float4 TransformOutTex0(in const float4 inTex)
{
#ifdef USE_TEXTRANSFORM0 // If enabled, texcoord transforms take place last (after D3DTSS_TEXCOORDINDEX selection, and after possible auto-generation of texcoords)
	return mul(inTex, texMatrices[0]);
#else // #ifdef USE_TEXTRANSFORM0
	return inTex;
#endif // #ifdef USE_TEXTRANSFORM0
}

const float4 TransformOutTex1(in const float4 inTex)
{
#ifdef USE_TEXTRANSFORM1 // If enabled, texcoord transforms take place last (after D3DTSS_TEXCOORDINDEX selection, and after possible auto-generation of texcoords)
	return mul(inTex, texMatrices[1]);
#else // #ifdef USE_TEXTRANSFORM1
	return inTex;
#endif // #ifdef USE_TEXTRANSFORM1
}

const float4 TransformOutTex2(in const float4 inTex)
{
#ifdef USE_TEXTRANSFORM2 // If enabled, texcoord transforms take place last (after D3DTSS_TEXCOORDINDEX selection, and after possible auto-generation of texcoords)
	return mul(inTex, texMatrices[2]);
#else // #ifdef USE_TEXTRANSFORM2
	return inTex;
#endif // #ifdef USE_TEXTRANSFORM2
}

const float4 TransformOutTex3(in const float4 inTex)
{
#ifdef USE_TEXTRANSFORM3 // If enabled, texcoord transforms take place last (after D3DTSS_TEXCOORDINDEX selection, and after possible auto-generation of texcoords)
	return mul(inTex, texMatrices[3]);
#else // #ifdef USE_TEXTRANSFORM3
	return inTex;
#endif // #ifdef USE_TEXTRANSFORM3
}

const float4 TransformOutTex4(in const float4 inTex)
{
#ifdef USE_TEXTRANSFORM4 // If enabled, texcoord transforms take place last (after D3DTSS_TEXCOORDINDEX selection, and after possible auto-generation of texcoords)
	return mul(inTex, texMatrices[4]);
#else // #ifdef USE_TEXTRANSFORM4
	return inTex;
#endif // #ifdef USE_TEXTRANSFORM4
}

const float4 TransformOutTex5(in const float4 inTex)
{
#ifdef USE_TEXTRANSFORM5 // If enabled, texcoord transforms take place last (after D3DTSS_TEXCOORDINDEX selection, and after possible auto-generation of texcoords)
	return mul(inTex, texMatrices[5]);
#else // #ifdef USE_TEXTRANSFORM5
	return inTex;
#endif // #ifdef USE_TEXTRANSFORM5
}

const float4 TransformOutTex6(in const float4 inTex)
{
#ifdef USE_TEXTRANSFORM6 // If enabled, texcoord transforms take place last (after D3DTSS_TEXCOORDINDEX selection, and after possible auto-generation of texcoords)
	return mul(inTex, texMatrices[6]);
#else // #ifdef USE_TEXTRANSFORM6
	return inTex;
#endif // #ifdef USE_TEXTRANSFORM6
}

const float4 TransformOutTex7(in const float4 inTex)
{
#ifdef USE_TEXTRANSFORM7 // If enabled, texcoord transforms take place last (after D3DTSS_TEXCOORDINDEX selection, and after possible auto-generation of texcoords)
	return mul(inTex, texMatrices[7]);
#else // #ifdef USE_TEXTRANSFORM7
	return inTex;
#endif // #ifdef USE_TEXTRANSFORM7
}

#ifdef OUTPUT_POINTSIZE
const float CalculatePointSizeOut(const float pointSize, const float3 viewspaceVertexPos)
{
	const float distEye = length(viewspaceVertexPos); // This is named "De" in the official D3D9 docs
	const float innerTerm = D3DRS_POINTSCALE_A + D3DRS_POINTSCALE_B * distEye + D3DRS_POINTSCALE_C * (distEye * distEye);
	[branch] if (innerTerm < 0.0f) // Branching here because the real FF VS branches on this too
	{
		return D3DRS_POINTSIZE_MAX;
	}
	else
	{
		// So this is strange, but the D3D9 documentation states that you need to clamp to D3DRS_POINTSIZE_MIN as well as D3DRS_POINTSIZE_MAX, however the FF VS only
		// seems to ever clamp to D3DRS_POINTSIZE_MAX. Maybe there's something weird going on that makes the min never needed?
		const float normalizedTerm = rsqrt(innerTerm);
		return normalizedTerm * pointSize * ViewportHeight;
	}
}
#endif // #ifdef OUTPUT_POINTSIZE

const float CalculateFogOut(const float3 viewspaceVertexPos)
{
#if D3DRS_FOGVERTEXMODE != D3DFOG_NONE
#ifdef D3DRS_RANGEFOGENABLE
	const float fogDistance = length(viewspaceVertexPos);
#else
	const float fogDistance = abs(viewspaceVertexPos.z);
#endif
#endif // #if D3DRS_FOGVERTEXMODE != D3DFOG_NONE

#if D3DRS_FOGVERTEXMODE == D3DFOG_NONE
	return 1.0f;
#elif D3DRS_FOGVERTEXMODE == D3DFOG_EXP
	const float dTimesDensity = fogDistance * D3DRS_FOGDENSITY;
	return exp(-dTimesDensity);
#elif D3DRS_FOGVERTEXMODE == D3DFOG_EXP2
	const float dTimesDensity = fogDistance * D3DRS_FOGDENSITY;
	const float dTimesDensitySquared = dTimesDensity * dTimesDensity;
	return exp(-dTimesDensitySquared);
#elif D3DRS_FOGVERTEXMODE == D3DFOG_LINEAR
	// These are the two constants used by the real FFVS. It precomputes these constants and stores them in c9.xy, then uses them to compute a mad() into oFog
	const float fogRange = D3DRS_FOGEND - D3DRS_FOGSTART;
	const float FFVSx = -1.0f / fogRange;
	const float FFVSy = D3DRS_FOGEND / fogRange;
	return mad(fogDistance, FFVSx, FFVSy);
#else
	#error Unknown D3DRS_FOGVERTEXMODE specified!
	return 1.0f;
#endif
}

struct PerLightResults
{
	float4 Ambient;
	float4 Diffuse;
	float4 Specular;
};

#if NUM_ENABLED_LIGHTS >= 1
#define LIGHTTYPE LIGHTTYPE0
#define LIGHTINDEX 0
#include "FFVS_CalculateSingleLight.fxh"
#if NUM_ENABLED_LIGHTS >= 2
#define LIGHTTYPE LIGHTTYPE1
#define LIGHTINDEX 1
#include "FFVS_CalculateSingleLight.fxh"
#if NUM_ENABLED_LIGHTS >= 3
#define LIGHTTYPE LIGHTTYPE2
#define LIGHTINDEX 2
#include "FFVS_CalculateSingleLight.fxh"
#if NUM_ENABLED_LIGHTS >= 4
#define LIGHTTYPE LIGHTTYPE3
#define LIGHTINDEX 3
#include "FFVS_CalculateSingleLight.fxh"
#if NUM_ENABLED_LIGHTS >= 5
#define LIGHTTYPE LIGHTTYPE4
#define LIGHTINDEX 4
#include "FFVS_CalculateSingleLight.fxh"
#if NUM_ENABLED_LIGHTS >= 6
#define LIGHTTYPE LIGHTTYPE5
#define LIGHTINDEX 5
#include "FFVS_CalculateSingleLight.fxh"
#if NUM_ENABLED_LIGHTS >= 7
#define LIGHTTYPE LIGHTTYPE6
#define LIGHTINDEX 6
#include "FFVS_CalculateSingleLight.fxh"
#if NUM_ENABLED_LIGHTS == 8
#define LIGHTTYPE LIGHTTYPE7
#define LIGHTINDEX 7
#include "FFVS_CalculateSingleLight.fxh"
#endif // #if NUM_ENABLED_LIGHTS == 8
#endif // #if NUM_ENABLED_LIGHTS >= 7
#endif // #if NUM_ENABLED_LIGHTS >= 6
#endif // #if NUM_ENABLED_LIGHTS >= 5
#endif // #if NUM_ENABLED_LIGHTS >= 4
#endif // #if NUM_ENABLED_LIGHTS >= 3
#endif // #if NUM_ENABLED_LIGHTS >= 2
#endif // #if NUM_ENABLED_LIGHTS >= 1

const PerLightResults CalculateFixedFunctionLightingForAllLights(in const float3 viewspaceVertexPos, in const float3 viewspaceVertexNormal)
{
	PerLightResults allLightsResults;

#if NUM_ENABLED_LIGHTS < 1 || NUM_ENABLED_LIGHTS > 8
	allLightsResults.Ambient = float4(0.0f, 0.0f, 0.0f, 0.0f);
	allLightsResults.Diffuse = float4(0.0f, 0.0f, 0.0f, 0.0f);
	allLightsResults.Specular = float4(0.0f, 0.0f, 0.0f, 0.0f);
	return allLightsResults;
#endif

#if NUM_ENABLED_LIGHTS >= 1
	{
	const PerLightResults light0result = CalculateFixedFunctionLightingForSingleLight0(enabledLightsData[0], viewspaceVertexPos, viewspaceVertexNormal);
	allLightsResults.Ambient = light0result.Ambient;
	allLightsResults.Diffuse = light0result.Diffuse;
	allLightsResults.Specular = light0result.Specular;
	}

#if NUM_ENABLED_LIGHTS >= 2
	{
	const PerLightResults light1result = CalculateFixedFunctionLightingForSingleLight1(enabledLightsData[1], viewspaceVertexPos, viewspaceVertexNormal);
	allLightsResults.Ambient += light1result.Ambient;
	allLightsResults.Diffuse += light1result.Diffuse;
	allLightsResults.Specular += light1result.Specular;
	}

#if NUM_ENABLED_LIGHTS >= 3
	{
	const PerLightResults light2result = CalculateFixedFunctionLightingForSingleLight2(enabledLightsData[2], viewspaceVertexPos, viewspaceVertexNormal);
	allLightsResults.Ambient += light2result.Ambient;
	allLightsResults.Diffuse += light2result.Diffuse;
	allLightsResults.Specular += light2result.Specular;
	}

#if NUM_ENABLED_LIGHTS >= 4
	{
	const PerLightResults light3result = CalculateFixedFunctionLightingForSingleLight3(enabledLightsData[3], viewspaceVertexPos, viewspaceVertexNormal);
	allLightsResults.Ambient += light3result.Ambient;
	allLightsResults.Diffuse += light3result.Diffuse;
	allLightsResults.Specular += light3result.Specular;
	}

#if NUM_ENABLED_LIGHTS >= 5
	{
	const PerLightResults light4result = CalculateFixedFunctionLightingForSingleLight4(enabledLightsData[4], viewspaceVertexPos, viewspaceVertexNormal);
	allLightsResults.Ambient += light4result.Ambient;
	allLightsResults.Diffuse += light4result.Diffuse;
	allLightsResults.Specular += light4result.Specular;
	}

#if NUM_ENABLED_LIGHTS >= 6
	{
	const PerLightResults light5result = CalculateFixedFunctionLightingForSingleLight5(enabledLightsData[5], viewspaceVertexPos, viewspaceVertexNormal);
	allLightsResults.Ambient += light5result.Ambient;
	allLightsResults.Diffuse += light5result.Diffuse;
	allLightsResults.Specular += light5result.Specular;
	}

#if NUM_ENABLED_LIGHTS >= 7
	{
	const PerLightResults light6result = CalculateFixedFunctionLightingForSingleLight6(enabledLightsData[6], viewspaceVertexPos, viewspaceVertexNormal);
	allLightsResults.Ambient += light6result.Ambient;
	allLightsResults.Diffuse += light6result.Diffuse;
	allLightsResults.Specular += light6result.Specular;
	}

#if NUM_ENABLED_LIGHTS == 8
	{
	const PerLightResults light7result = CalculateFixedFunctionLightingForSingleLight7(enabledLightsData[7], viewspaceVertexPos, viewspaceVertexNormal);
	allLightsResults.Ambient += light7result.Ambient;
	allLightsResults.Diffuse += light7result.Diffuse;
	allLightsResults.Specular += light7result.Specular;
	}

#endif // #if NUM_ENABLED_LIGHTS == 8
#endif // #if NUM_ENABLED_LIGHTS >= 7
#endif // #if NUM_ENABLED_LIGHTS >= 6
#endif // #if NUM_ENABLED_LIGHTS >= 5
#endif // #if NUM_ENABLED_LIGHTS >= 4
#endif // #if NUM_ENABLED_LIGHTS >= 3
#endif // #if NUM_ENABLED_LIGHTS >= 2
#endif // #if NUM_ENABLED_LIGHTS >= 1

	return allLightsResults;
}

const float4 CalculateFixedFunctionLighting(in const inVert input, const posNormal viewspacePN, out float4 outSpecular)
{
	const float4 materialAmbient = GetMaterialAmbient(input);
	const float3 emissive = GetMaterialEmissive(input);
#if NUM_ENABLED_LIGHTS >= 1
	const PerLightResults allLightsCombined = CalculateFixedFunctionLightingForAllLights(viewspacePN.worldViewPos, viewspacePN.oNormal);
	const float4 materialDiffuse = GetMaterialDiffuse(input);
	const float4 materialSpecular = GetMaterialSpecular(input);

	// These equations come from this page that describes how the D3D9 fixed-function pipeline handles lighting and materials: https://docs.microsoft.com/en-us/windows/win32/direct3d9/mathematics-of-lighting
	const float4 ambient = materialAmbient * (AMBIENT + allLightsCombined.Ambient);
	const float4 diffuse = materialDiffuse * allLightsCombined.Diffuse;
	const float4 specular = materialSpecular * allLightsCombined.Specular;

	outSpecular = specular;

	return ambient + diffuse + float4(emissive, 0.0f);
#else
	// With no lights enabled, the Diffuse and Specular terms completely fall away, and we're left with just Ambient and Emissive terms
	outSpecular = float4(0.0f, 0.0f, 0.0f, 1.0f);
	const float4 ambient = materialAmbient * AMBIENT;
	return ambient + float4(emissive, 0.0f);
#endif
}

const float4 ResolveTex0(const float4 tex0source, const posNormal viewspacePN)
{
#if D3DTSS_TEXCOORDINDEX0TYPE == D3DTSS_TCI_PASSTHRU
	return tex0source;
#elif D3DTSS_TEXCOORDINDEX0TYPE == D3DTSS_TCI_CAMERASPACENORMAL
	return float4(AutoGenTexcoords_CAMERASPACENORMAL(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX0TYPE == D3DTSS_TCI_CAMERASPACEPOSITION
	return float4(AutoGenTexcoords_CAMERASPACEPOSITION(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX0TYPE == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR
	return float4(AutoGenTexcoords_CAMERASPACEREFLECTIONVECTOR(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX0TYPE == D3DTSS_TCI_SPHEREMAP
	return float4(AutoGenTexcoords_SPHEREMAP(viewspacePN), 0.0f, 0.0f);
#else
	#error Error: Unknown D3DTSS_TEXCOORDINDEX0TYPE
#endif
}

const float4 ResolveTex1(const float4 tex1source, const posNormal viewspacePN)
{
#if D3DTSS_TEXCOORDINDEX1TYPE == D3DTSS_TCI_PASSTHRU
	return tex1source;
#elif D3DTSS_TEXCOORDINDEX1TYPE == D3DTSS_TCI_CAMERASPACENORMAL
	return float4(AutoGenTexcoords_CAMERASPACENORMAL(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX1TYPE == D3DTSS_TCI_CAMERASPACEPOSITION
	return float4(AutoGenTexcoords_CAMERASPACEPOSITION(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX1TYPE == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR
	return float4(AutoGenTexcoords_CAMERASPACEREFLECTIONVECTOR(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX1TYPE == D3DTSS_TCI_SPHEREMAP
	return float4(AutoGenTexcoords_SPHEREMAP(viewspacePN), 0.0f, 0.0f);
#else
	#error Error: Unknown D3DTSS_TEXCOORDINDEX1TYPE
#endif
}

const float4 ResolveTex2(const float4 tex2source, const posNormal viewspacePN)
{
#if D3DTSS_TEXCOORDINDEX2TYPE == D3DTSS_TCI_PASSTHRU
	return tex2source;
#elif D3DTSS_TEXCOORDINDEX2TYPE == D3DTSS_TCI_CAMERASPACENORMAL
	return float4(AutoGenTexcoords_CAMERASPACENORMAL(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX2TYPE == D3DTSS_TCI_CAMERASPACEPOSITION
	return float4(AutoGenTexcoords_CAMERASPACEPOSITION(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX2TYPE == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR
	return float4(AutoGenTexcoords_CAMERASPACEREFLECTIONVECTOR(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX2TYPE == D3DTSS_TCI_SPHEREMAP
	return float4(AutoGenTexcoords_SPHEREMAP(viewspacePN), 0.0f, 0.0f);
#else
	#error Error: Unknown D3DTSS_TEXCOORDINDEX2TYPE
#endif
}

const float4 ResolveTex3(const float4 tex3source, const posNormal viewspacePN)
{
#if D3DTSS_TEXCOORDINDEX3TYPE == D3DTSS_TCI_PASSTHRU
	return tex3source;
#elif D3DTSS_TEXCOORDINDEX3TYPE == D3DTSS_TCI_CAMERASPACENORMAL
	return float4(AutoGenTexcoords_CAMERASPACENORMAL(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX3TYPE == D3DTSS_TCI_CAMERASPACEPOSITION
	return float4(AutoGenTexcoords_CAMERASPACEPOSITION(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX3TYPE == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR
	return float4(AutoGenTexcoords_CAMERASPACEREFLECTIONVECTOR(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX3TYPE == D3DTSS_TCI_SPHEREMAP
	return float4(AutoGenTexcoords_SPHEREMAP(viewspacePN), 0.0f, 0.0f);
#else
	#error Error: Unknown D3DTSS_TEXCOORDINDEX3TYPE
#endif
}

const float4 ResolveTex4(const float4 tex4source, const posNormal viewspacePN)
{
#if D3DTSS_TEXCOORDINDEX4TYPE == D3DTSS_TCI_PASSTHRU
	return tex4source;
#elif D3DTSS_TEXCOORDINDEX4TYPE == D3DTSS_TCI_CAMERASPACENORMAL
	return float4(AutoGenTexcoords_CAMERASPACENORMAL(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX4TYPE == D3DTSS_TCI_CAMERASPACEPOSITION
	return float4(AutoGenTexcoords_CAMERASPACEPOSITION(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX4TYPE == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR
	return float4(AutoGenTexcoords_CAMERASPACEREFLECTIONVECTOR(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX4TYPE == D3DTSS_TCI_SPHEREMAP
	return float4(AutoGenTexcoords_SPHEREMAP(viewspacePN), 0.0f, 0.0f);
#else
	#error Error: Unknown D3DTSS_TEXCOORDINDEX4TYPE
#endif
}

const float4 ResolveTex5(const float4 tex5source, const posNormal viewspacePN)
{
#if D3DTSS_TEXCOORDINDEX5TYPE == D3DTSS_TCI_PASSTHRU
	return tex5source;
#elif D3DTSS_TEXCOORDINDEX5TYPE == D3DTSS_TCI_CAMERASPACENORMAL
	return float4(AutoGenTexcoords_CAMERASPACENORMAL(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX5TYPE == D3DTSS_TCI_CAMERASPACEPOSITION
	return float4(AutoGenTexcoords_CAMERASPACEPOSITION(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX5TYPE == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR
	return float4(AutoGenTexcoords_CAMERASPACEREFLECTIONVECTOR(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX5TYPE == D3DTSS_TCI_SPHEREMAP
	return float4(AutoGenTexcoords_SPHEREMAP(viewspacePN), 0.0f, 0.0f);
#else
	#error Error: Unknown D3DTSS_TEXCOORDINDEX5TYPE
#endif
}

const float4 ResolveTex6(const float4 tex6source, const posNormal viewspacePN)
{
#if D3DTSS_TEXCOORDINDEX6TYPE == D3DTSS_TCI_PASSTHRU
	return tex6source;
#elif D3DTSS_TEXCOORDINDEX6TYPE == D3DTSS_TCI_CAMERASPACENORMAL
	return float4(AutoGenTexcoords_CAMERASPACENORMAL(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX6TYPE == D3DTSS_TCI_CAMERASPACEPOSITION
	return float4(AutoGenTexcoords_CAMERASPACEPOSITION(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX6TYPE == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR
	return float4(AutoGenTexcoords_CAMERASPACEREFLECTIONVECTOR(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX6TYPE == D3DTSS_TCI_SPHEREMAP
	return float4(AutoGenTexcoords_SPHEREMAP(viewspacePN), 0.0f, 0.0f);
#else
	#error Error: Unknown D3DTSS_TEXCOORDINDEX6TYPE
#endif
}

const float4 ResolveTex7(const float4 tex7source, const posNormal viewspacePN)
{
#if D3DTSS_TEXCOORDINDEX7TYPE == D3DTSS_TCI_PASSTHRU
	return tex7source;
#elif D3DTSS_TEXCOORDINDEX7TYPE == D3DTSS_TCI_CAMERASPACENORMAL
	return float4(AutoGenTexcoords_CAMERASPACENORMAL(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX7TYPE == D3DTSS_TCI_CAMERASPACEPOSITION
	return float4(AutoGenTexcoords_CAMERASPACEPOSITION(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX7TYPE == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR
	return float4(AutoGenTexcoords_CAMERASPACEREFLECTIONVECTOR(viewspacePN), 0.0f);
#elif D3DTSS_TEXCOORDINDEX7TYPE == D3DTSS_TCI_SPHEREMAP
	return float4(AutoGenTexcoords_SPHEREMAP(viewspacePN), 0.0f, 0.0f);
#else
	#error Error: Unknown D3DTSS_TEXCOORDINDEX7TYPE
#endif
}

outVert main(in const inVert input)
{
	outVert ret;

	const posNormal pn = ComputePosNormal(input);
	ret.OPOS = pn.OPOS;

	float4 specularColor = float4(1.0f, 1.0f, 1.0f, 1.0f);

	ret.oDiffuse =
#ifdef LIGHTING
		CalculateFixedFunctionLighting(input, pn, specularColor);
#else // #ifdef LIGHTING
		GetVertexDiffuse(input);
#endif // #ifdef LIGHTING

#if defined(D3DRS_SPECULARENABLE) && defined(LIGHTING)
	ret.oSpecular = specularColor;
#endif // #if defined(D3DRS_SPECULARENABLE) && defined(LIGHTING)

#ifdef OUTPUT_POINTSIZE
	const float pointSize =
#ifdef PER_VERTEX_POINTSIZE
		input.PSIZ0;
#else // #ifdef PER_VERTEX_POINTSIZE
		D3DRS_POINTSIZE;
#endif // #ifdef PER_VERTEX_POINTSIZE
	ret.oPts = CalculatePointSizeOut(pointSize, pn.worldViewPos);
#endif // #ifdef OUTPUT_POINTSIZE

#ifdef OUTPUT_FOG
	ret.oFog = saturate(CalculateFogOut(pn.worldViewPos) );
#endif // #ifdef OUTPUT_FOG

	// For texture coordinates, the order in which they pass through the fixed-function pipeline when auto-generated texture coordinates are enabled for a texcoord channel is:
	// 1) Automatic texcoord generation (based on the camera data)
	// 2) Texture Transform matrix (optional)
	// 3) Output to the correct texcoord output register
	// For texture coordinates, the order in which they pass through the fixed-function pipeline when auto-generated texture coordinates are disabled for a texcoord channel is:
	// 1) Input and possible remapping (remapping is optional based on D3DTCI_ settings set via SetTextureStageState() calls)
	// 2) Texture Transform matrix (optional)
	// 3) Output to the correct texcoord output register
	const TEX0TYPE tex0 = GetTex0(input);
	const TEX1TYPE tex1 = GetTex1(input);
	const TEX2TYPE tex2 = GetTex2(input);
	const TEX3TYPE tex3 = GetTex3(input);
	const TEX4TYPE tex4 = GetTex4(input);
	const TEX5TYPE tex5 = GetTex5(input);
	const TEX6TYPE tex6 = GetTex6(input);
	const TEX7TYPE tex7 = GetTex7(input);

#ifdef OUTPUT_TEX0
	const float4 resolvedTex0 = ResolveTex0(TEX0REMAP, pn);
	ret.TEX0 = TransformOutTex0(resolvedTex0);
#endif // #ifdef OUTPUT_TEX0
#ifdef OUTPUT_TEX1
	const float4 resolvedTex1 = ResolveTex1(TEX1REMAP, pn);
	ret.TEX1 = TransformOutTex1(resolvedTex1);
#endif // #ifdef OUTPUT_TEX1
#ifdef OUTPUT_TEX2
	const float4 resolvedTex2 = ResolveTex2(TEX2REMAP, pn);
	ret.TEX2 = TransformOutTex2(resolvedTex2);
#endif // #ifdef OUTPUT_TEX2
#ifdef OUTPUT_TEX3
	const float4 resolvedTex3 = ResolveTex3(TEX3REMAP, pn);
	ret.TEX3 = TransformOutTex3(resolvedTex3);
#endif // #ifdef OUTPUT_TEX3
#ifdef OUTPUT_TEX4
	const float4 resolvedTex4 = ResolveTex4(TEX4REMAP, pn);
	ret.TEX4 = TransformOutTex4(resolvedTex4);
#endif // #ifdef OUTPUT_TEX4
#ifdef OUTPUT_TEX5
	const float4 resolvedTex5 = ResolveTex5(TEX5REMAP, pn);
	ret.TEX5 = TransformOutTex5(resolvedTex5);
#endif // #ifdef OUTPUT_TEX5
#ifdef OUTPUT_TEX6
	const float4 resolvedTex6 = ResolveTex6(TEX6REMAP, pn);
	ret.TEX6 = TransformOutTex6(resolvedTex6);
#endif // #ifdef OUTPUT_TEX6
#ifdef OUTPUT_TEX7
	const float4 resolvedTex7 = ResolveTex7(TEX7REMAP, pn);
	ret.TEX7 = TransformOutTex7(resolvedTex7);
#endif // #ifdef OUTPUT_TEX7

	return ret;
}

```

`Software_d3d9/FixedFunctionToPixelShader.cpp`:

```cpp
#include "FixedFunctionToShader.h"
#include "IDirect3DPixelShader9Hook.h"
#include "IDirect3DTexture9Hook.h"
#include "resource.h"

static const unsigned char TFACTOR_REGISTER = 0u; // c0
static const unsigned char FOGCOLOR_REGISTER = 1u; // c1
static const unsigned char TEXTURESTAGE_CONSTANTS_REGISTERS = 2u; // c2 thru c9
static const unsigned char STAGE_BUMPENVMAT_REGISTERS = 10u; // c10 thru c27

const FixedFunctionStateHash HashPixelState(const DeviceState& state)
{
	FixedFunctionStateHash retHash = 0;

	// Fixed function pixel pipeline cares about:
	// - Texture state stages
	// - Texture types for each stage (1D, 2D, 3D, Cubemap textures)

	for (unsigned x = 0; x < MAX_NUM_TEXTURE_STAGE_STATES; ++x)
	{
		const TextureStageState& thisTSS = state.currentStageStates[x];
		HashStruct(retHash, thisTSS);
	}

	for (unsigned x = 0; x < MAX_NUM_TEXTURE_STAGE_STATES; ++x)
	{
		if (state.currentTextures[x] != NULL) // tex2D or tex1D bound to this stage
		{
		}
		else if (state.currentCubeTextures[x] != NULL) // texCube bound to this stage
		{
		}
		else if (state.currentVolumeTextures[x] != NULL) // tex3D bound to this stage
		{
		}
		else // NULL texture bound to this stage
		{
		}
	}

	// Render states:
	// - Fog
	// - Texture factor (shared by all texture stages)
	// - Shading mode (gourad vs. flat shading)

	HashContinue(retHash, state.currentRenderStates.renderStatesUnion.namedStates.lighting);
	if (state.currentRenderStates.renderStatesUnion.namedStates.lighting)
	{
		HashContinue(retHash, state.currentRenderStates.renderStatesUnion.namedStates.specularEnable);
	}

	HashContinue(retHash, state.currentRenderStates.renderStatesUnion.namedStates.fogEnable);
	if (state.currentRenderStates.renderStatesUnion.namedStates.fogEnable)
	{
		HashContinue<unsigned char>(retHash, state.currentRenderStates.renderStatesUnion.namedStates.fogVertexMode);
		HashContinue<unsigned char>(retHash, state.currentRenderStates.renderStatesUnion.namedStates.fogTableMode);
		HashContinue<unsigned char>(retHash, state.currentRenderStates.renderStatesUnion.namedStates.rangeFogEnable);
	}
	HashContinue(retHash, state.currentRenderStates.renderStatesUnion.namedStates.textureFactor);
	HashContinue<unsigned char>(retHash, state.currentRenderStates.renderStatesUnion.namedStates.shadeMode);

	return retHash;
}

static const char* const coordIndices[MAX_NUM_TEXTURE_STAGE_STATES] =
{
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7"
};

static const char* const D3DTSS_TEXCOORDINDEXNStrings[MAX_NUM_TEXTURE_STAGE_STATES] =
{
	"D3DTSS_TEXCOORDINDEX0",
	"D3DTSS_TEXCOORDINDEX1",
	"D3DTSS_TEXCOORDINDEX2",
	"D3DTSS_TEXCOORDINDEX3",
	"D3DTSS_TEXCOORDINDEX4",
	"D3DTSS_TEXCOORDINDEX5",
	"D3DTSS_TEXCOORDINDEX6",
	"D3DTSS_TEXCOORDINDEX7"
};

static const char* const HAS_TEXN_BOUNDStrings[MAX_NUM_TEXTURE_STAGE_STATES] = 
{
	"HAS_TEX0_BOUND",
	"HAS_TEX1_BOUND",
	"HAS_TEX2_BOUND",
	"HAS_TEX3_BOUND",
	"HAS_TEX4_BOUND",
	"HAS_TEX5_BOUND",
	"HAS_TEX6_BOUND",
	"HAS_TEX7_BOUND"
};

static const char* const HAS_TEXCOORDNStrings[MAX_NUM_TEXTURE_STAGE_STATES] = 
{
	"HAS_TEXCOORD0",
	"HAS_TEXCOORD1",
	"HAS_TEXCOORD2",
	"HAS_TEXCOORD3",
	"HAS_TEXCOORD4",
	"HAS_TEXCOORD5",
	"HAS_TEXCOORD6",
	"HAS_TEXCOORD7"
};

static const char* const SamplerTypeNStrings[MAX_NUM_TEXTURE_STAGE_STATES] = 
{
	"SAMPLERTYPE0",
	"SAMPLERTYPE1",
	"SAMPLERTYPE2",
	"SAMPLERTYPE3",
	"SAMPLERTYPE4",
	"SAMPLERTYPE5",
	"SAMPLERTYPE6",
	"SAMPLERTYPE7"
};

static const char* const TexTypeNStrings[MAX_NUM_TEXTURE_STAGE_STATES] = 
{
	"TEXTYPE0",
	"TEXTYPE1",
	"TEXTYPE2",
	"TEXTYPE3",
	"TEXTYPE4",
	"TEXTYPE5",
	"TEXTYPE6",
	"TEXTYPE7"
};

static const char* const TexTypeEnumStrings[4 << 1] = 
{
	"TEXTYPE1D",
	"TEXTYPE2D",
	"TEXTYPE3D",
	"TEXTYPECUBE",
	"TEXTYPE1D | TEXTYPEPROJ",
	"TEXTYPE2D | TEXTYPEPROJ",
	"TEXTYPE3D | TEXTYPEPROJ",
	"TEXTYPECUBE | TEXTYPEPROJ"
};

static const char* const BoundTextureTypeStrings[4] =
{
	"sampler1D",
	"sampler2D",
	"sampler3D",
	"samplerCUBE"
};

enum boundTextureType
{
	TEXTYPE1D = 0x0,
	TEXTYPE2D = 0x1,
	TEXTYPE3D = 0x2,
	TEXTYPECUBE = 0x3,
	TEXTYPEPROJ = 0x4, // This is not a texture type per-se, but a flag on top of the texture type
};

static const char* const TEXCOORDNTYPEStrings[MAX_NUM_TEXTURE_STAGE_STATES] =
{
	"TEXCOORD0TYPE",
	"TEXCOORD1TYPE",
	"TEXCOORD2TYPE",
	"TEXCOORD3TYPE",
	"TEXCOORD4TYPE",
	"TEXCOORD5TYPE",
	"TEXCOORD6TYPE",
	"TEXCOORD7TYPE"
};

static const char* const D3DTTFF_STRINGS[4] =
{
	"D3DTTFF_COUNT1TYPE",
	"D3DTTFF_COUNT2TYPE",
	"D3DTTFF_COUNT3TYPE",
	"D3DTTFF_COUNT4TYPE"
};

static const char* const d3dtopStrings[D3DTOP_LERP + 1] =
{
	"D3DTOP_UNKNOWN (0)",
	"D3DTOP_DISABLE",                   
	"D3DTOP_SELECTARG1",                
	"D3DTOP_SELECTARG2",                
	"D3DTOP_MODULATE",                  
	"D3DTOP_MODULATE2X",                
	"D3DTOP_MODULATE4X",                
	"D3DTOP_ADD",                       
	"D3DTOP_ADDSIGNED",                 
	"D3DTOP_ADDSIGNED2X",               
	"D3DTOP_SUBTRACT",                  
	"D3DTOP_ADDSMOOTH",                 
	"D3DTOP_BLENDDIFFUSEALPHA",         
	"D3DTOP_BLENDTEXTUREALPHA",         
	"D3DTOP_BLENDFACTORALPHA",          
	"D3DTOP_BLENDTEXTUREALPHAPM",       
	"D3DTOP_BLENDCURRENTALPHA",         
	"D3DTOP_PREMODULATE",               
	"D3DTOP_MODULATEALPHA_ADDCOLOR",    
	"D3DTOP_MODULATECOLOR_ADDALPHA",    
	"D3DTOP_MODULATEINVALPHA_ADDCOLOR", 
	"D3DTOP_MODULATEINVCOLOR_ADDALPHA", 
	"D3DTOP_BUMPENVMAP",                
	"D3DTOP_BUMPENVMAPLUMINANCE",       
	"D3DTOP_DOTPRODUCT3",               
	"D3DTOP_MULTIPLYADD",               
	"D3DTOP_LERP"
};

static const char* const d3dtaStrings[64] =
{
	"D3DTA_DIFFUSE", 
	"D3DTA_CURRENT",  
	"D3DTA_TEXTURE",  
	"D3DTA_TFACTOR",  
	"D3DTA_SPECULAR", 
	"D3DTA_TEMP",     
	"D3DTA_CONSTANT",
	"UNKNOWN(7)",
	"UNKNOWN(8)",
	"UNKNOWN(9)",
	"UNKNOWN(10)",
	"UNKNOWN(11)",
	"UNKNOWN(12)",
	"UNKNOWN(13)",
	"UNKNOWN(14)",
	"UNKNOWN(15)",

	"D3DTA_DIFFUSE | D3DTA_COMPLEMENT", 
	"D3DTA_CURRENT | D3DTA_COMPLEMENT",  
	"D3DTA_TEXTURE | D3DTA_COMPLEMENT",  
	"D3DTA_TFACTOR | D3DTA_COMPLEMENT",  
	"D3DTA_SPECULAR | D3DTA_COMPLEMENT", 
	"D3DTA_TEMP | D3DTA_COMPLEMENT",     
	"D3DTA_CONSTANT | D3DTA_COMPLEMENT",
	"UNKNOWN | D3DTA_COMPLEMENT(23)",
	"UNKNOWN | D3DTA_COMPLEMENT(24)",
	"UNKNOWN | D3DTA_COMPLEMENT(25)",
	"UNKNOWN | D3DTA_COMPLEMENT(26)",
	"UNKNOWN | D3DTA_COMPLEMENT(27)",
	"UNKNOWN | D3DTA_COMPLEMENT(28)",
	"UNKNOWN | D3DTA_COMPLEMENT(29)",
	"UNKNOWN | D3DTA_COMPLEMENT(30)",
	"UNKNOWN | D3DTA_COMPLEMENT(31)",

	"D3DTA_DIFFUSE | D3DTA_ALPHAREPLICATE", 
	"D3DTA_CURRENT | D3DTA_ALPHAREPLICATE",  
	"D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE",  
	"D3DTA_TFACTOR | D3DTA_ALPHAREPLICATE",  
	"D3DTA_SPECULAR | D3DTA_ALPHAREPLICATE", 
	"D3DTA_TEMP | D3DTA_ALPHAREPLICATE",     
	"D3DTA_CONSTANT | D3DTA_ALPHAREPLICATE",
	"UNKNOWN | D3DTA_ALPHAREPLICATE(39)",
	"UNKNOWN | D3DTA_ALPHAREPLICATE(40)",
	"UNKNOWN | D3DTA_ALPHAREPLICATE(41)",
	"UNKNOWN | D3DTA_ALPHAREPLICATE(42)",
	"UNKNOWN | D3DTA_ALPHAREPLICATE(43)",
	"UNKNOWN | D3DTA_ALPHAREPLICATE(44)",
	"UNKNOWN | D3DTA_ALPHAREPLICATE(45)",
	"UNKNOWN | D3DTA_ALPHAREPLICATE(46)",
	"UNKNOWN | D3DTA_ALPHAREPLICATE(47)",

	"D3DTA_DIFFUSE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE", 
	"D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",  
	"D3DTA_TEXTURE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",  
	"D3DTA_TFACTOR | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",  
	"D3DTA_SPECULAR | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE", 
	"D3DTA_TEMP | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",     
	"D3DTA_CONSTANT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE"
	"UNKNOWN | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE(55)",
	"UNKNOWN | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE(56)",
	"UNKNOWN | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE(57)",
	"UNKNOWN | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE(58)",
	"UNKNOWN | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE(59)",
	"UNKNOWN | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE(60)",
	"UNKNOWN | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE(61)",
	"UNKNOWN | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE(62)",
	"UNKNOWN | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE(63)"
};

static const char* const STAGEN_COLOROPSTRINGS[MAX_NUM_TEXTURE_STAGE_STATES] = 
{
	"D3DTSS_STAGE0_COLOROP",
	"D3DTSS_STAGE1_COLOROP",
	"D3DTSS_STAGE2_COLOROP",
	"D3DTSS_STAGE3_COLOROP",
	"D3DTSS_STAGE4_COLOROP",
	"D3DTSS_STAGE5_COLOROP",
	"D3DTSS_STAGE6_COLOROP",
	"D3DTSS_STAGE7_COLOROP"
};

static const char* const STAGEN_ALPHAOPSTRINGS[MAX_NUM_TEXTURE_STAGE_STATES] = 
{
	"D3DTSS_STAGE0_ALPHAOP",
	"D3DTSS_STAGE1_ALPHAOP",
	"D3DTSS_STAGE2_ALPHAOP",
	"D3DTSS_STAGE3_ALPHAOP",
	"D3DTSS_STAGE4_ALPHAOP",
	"D3DTSS_STAGE5_ALPHAOP",
	"D3DTSS_STAGE6_ALPHAOP",
	"D3DTSS_STAGE7_ALPHAOP"
};

static const char* const STAGEN_COLORARG1STRINGS[MAX_NUM_TEXTURE_STAGE_STATES] =
{
	"D3DTSS_STAGE0_COLORARG1",
	"D3DTSS_STAGE1_COLORARG1",
	"D3DTSS_STAGE2_COLORARG1",
	"D3DTSS_STAGE3_COLORARG1",
	"D3DTSS_STAGE4_COLORARG1",
	"D3DTSS_STAGE5_COLORARG1",
	"D3DTSS_STAGE6_COLORARG1",
	"D3DTSS_STAGE7_COLORARG1"
};

static const char* const STAGEN_COLORARG2STRINGS[MAX_NUM_TEXTURE_STAGE_STATES] =
{
	"D3DTSS_STAGE0_COLORARG2",
	"D3DTSS_STAGE1_COLORARG2",
	"D3DTSS_STAGE2_COLORARG2",
	"D3DTSS_STAGE3_COLORARG2",
	"D3DTSS_STAGE4_COLORARG2",
	"D3DTSS_STAGE5_COLORARG2",
	"D3DTSS_STAGE6_COLORARG2",
	"D3DTSS_STAGE7_COLORARG2"
};

static const char* const STAGEN_COLORARG0STRINGS[MAX_NUM_TEXTURE_STAGE_STATES] =
{
	"D3DTSS_STAGE0_COLORARG0",
	"D3DTSS_STAGE1_COLORARG0",
	"D3DTSS_STAGE2_COLORARG0",
	"D3DTSS_STAGE3_COLORARG0",
	"D3DTSS_STAGE4_COLORARG0",
	"D3DTSS_STAGE5_COLORARG0",
	"D3DTSS_STAGE6_COLORARG0",
	"D3DTSS_STAGE7_COLORARG0"
};

static const char* const STAGEN_ALPHAARG1STRINGS[MAX_NUM_TEXTURE_STAGE_STATES] =
{
	"D3DTSS_STAGE0_ALPHAARG1",
	"D3DTSS_STAGE1_ALPHAARG1",
	"D3DTSS_STAGE2_ALPHAARG1",
	"D3DTSS_STAGE3_ALPHAARG1",
	"D3DTSS_STAGE4_ALPHAARG1",
	"D3DTSS_STAGE5_ALPHAARG1",
	"D3DTSS_STAGE6_ALPHAARG1",
	"D3DTSS_STAGE7_ALPHAARG1"
};

static const char* const STAGEN_ALPHAARG2STRINGS[MAX_NUM_TEXTURE_STAGE_STATES] =
{
	"D3DTSS_STAGE0_ALPHAARG2",
	"D3DTSS_STAGE1_ALPHAARG2",
	"D3DTSS_STAGE2_ALPHAARG2",
	"D3DTSS_STAGE3_ALPHAARG2",
	"D3DTSS_STAGE4_ALPHAARG2",
	"D3DTSS_STAGE5_ALPHAARG2",
	"D3DTSS_STAGE6_ALPHAARG2",
	"D3DTSS_STAGE7_ALPHAARG2"
};

static const char* const STAGEN_ALPHAARG0STRINGS[MAX_NUM_TEXTURE_STAGE_STATES] =
{
	"D3DTSS_STAGE0_ALPHAARG0",
	"D3DTSS_STAGE1_ALPHAARG0",
	"D3DTSS_STAGE2_ALPHAARG0",
	"D3DTSS_STAGE3_ALPHAARG0",
	"D3DTSS_STAGE4_ALPHAARG0",
	"D3DTSS_STAGE5_ALPHAARG0",
	"D3DTSS_STAGE6_ALPHAARG0",
	"D3DTSS_STAGE7_ALPHAARG0"
};

static const char* const STAGEN_RESULTARGSTRINGS[MAX_NUM_TEXTURE_STAGE_STATES] =
{
	"D3DTSS_STAGE0_RESULTARG",
	"D3DTSS_STAGE1_RESULTARG",
	"D3DTSS_STAGE2_RESULTARG",
	"D3DTSS_STAGE3_RESULTARG",
	"D3DTSS_STAGE4_RESULTARG",
	"D3DTSS_STAGE5_RESULTARG",
	"D3DTSS_STAGE6_RESULTARG",
	"D3DTSS_STAGE7_RESULTARG"
};

static inline const bool GetTextureTypeBoundForStage(const DeviceState& state, const unsigned stageNum, boundTextureType& outBoundTextureType)
{
	if (const IDirect3DTexture9Hook* const texturePtr = state.currentTextures[stageNum])
	{
		if (texturePtr->GetInternalHeight() > 1)
			outBoundTextureType = TEXTYPE2D;
		else
			outBoundTextureType = TEXTYPE1D;
		return true;
	}
	else if (state.currentCubeTextures[stageNum])
	{
		outBoundTextureType = TEXTYPECUBE;
		return true;
	}
	else if (state.currentVolumeTextures[stageNum])
	{
		outBoundTextureType = TEXTYPE3D;
		return true;
	}
	else
	{
		return false;
	}
}

static inline void BuildPixelStateDefines(const DeviceState& state, std::vector<D3DXMACRO>& defines)
{
	if (state.currentRenderStates.renderStatesUnion.namedStates.lighting)
	{
		D3DXMACRO lightingMacro = {0};
		lightingMacro.Name = "WITH_LIGHTING";
		lightingMacro.Definition = "1";
		defines.push_back(lightingMacro);

		if (state.currentRenderStates.renderStatesUnion.namedStates.specularEnable)
		{
			D3DXMACRO specularEnableMacro = {0};
			specularEnableMacro.Name = "SPECULAR_ENABLE";
			specularEnableMacro.Definition = "1";
			defines.push_back(specularEnableMacro);
		}
	}

	if (state.currentRenderStates.renderStatesUnion.namedStates.fogEnable)
	{
		D3DXMACRO fogEnableMacro = {0};
		fogEnableMacro.Name = "FOG_ENABLE";
		fogEnableMacro.Definition = "1";
		defines.push_back(fogEnableMacro);
	}

	if (state.currentRenderStates.renderStatesUnion.namedStates.colorVertex)
	{
		D3DXMACRO colorVertexMacro = {0};
		colorVertexMacro.Name = "WITH_COLORVERTEX";
		colorVertexMacro.Definition = "1";
		defines.push_back(colorVertexMacro);
	}

	if (true) // TODO: Make this work without vertex color too
	{
		D3DXMACRO vertexColor = {0};
		vertexColor.Name = "HAS_VERTEX_COLOR";
		vertexColor.Definition = "1";
		defines.push_back(vertexColor);
	}

	for (unsigned x = 0; x < MAX_NUM_TEXTURE_STAGE_STATES; ++x)
	{
		const TextureStageState& thisTextureStageState = state.currentStageStates[x];

		D3DXMACRO D3DTSS_TEXCOORDINDEXN = {0};
		D3DTSS_TEXCOORDINDEXN.Name = D3DTSS_TEXCOORDINDEXNStrings[x];
		D3DTSS_TEXCOORDINDEXN.Definition = coordIndices[x];
		defines.push_back(D3DTSS_TEXCOORDINDEXN);

		boundTextureType textureType;
		if (GetTextureTypeBoundForStage(state, x, textureType) )
		{
			D3DXMACRO HAS_TEXN_BOUND = {0};
			HAS_TEXN_BOUND.Name = HAS_TEXN_BOUNDStrings[x];
			HAS_TEXN_BOUND.Definition = "1";
			defines.push_back(HAS_TEXN_BOUND);

			// TODO: Change this to check in with the currently-set FVF or vertex declaration:
			D3DXMACRO HAS_TEXCOORDN = {0};
			HAS_TEXCOORDN.Name = HAS_TEXCOORDNStrings[x];
			HAS_TEXCOORDN.Definition = "1";
			defines.push_back(HAS_TEXCOORDN);

			D3DXMACRO SamplerTypeN = {0};
			SamplerTypeN.Name = SamplerTypeNStrings[x];
			SamplerTypeN.Definition = BoundTextureTypeStrings[textureType];
			defines.push_back(SamplerTypeN);

			D3DXMACRO TexTypeN = {0};
			TexTypeN.Name = TexTypeNStrings[x];
			if (thisTextureStageState.stageStateUnion.namedStates.textureTransformFlags & D3DTTFF_PROJECTED)
				TexTypeN.Definition = TexTypeEnumStrings[textureType | TEXTYPEPROJ];
			else
				TexTypeN.Definition = TexTypeEnumStrings[textureType];
			defines.push_back(TexTypeN);
		}

		{
			D3DXMACRO TEXCOORDNTYPE = {0};
			TEXCOORDNTYPE.Name = TEXCOORDNTYPEStrings[x];
			unsigned stringTableIndex = thisTextureStageState.stageStateUnion.namedStates.textureTransformFlags & 0xF;
			if (stringTableIndex > D3DTTFF_COUNT4)
				stringTableIndex = D3DTTFF_COUNT4;
			if (stringTableIndex == D3DTTFF_DISABLE)
				stringTableIndex = D3DTTFF_COUNT2;
			TEXCOORDNTYPE.Definition = D3DTTFF_STRINGS[stringTableIndex - 1]; // Minus one to convert from a 1-based index to a 0-based index
			defines.push_back(TEXCOORDNTYPE);
		}

		{
			D3DXMACRO STAGEN_COLOROP = {0};
			STAGEN_COLOROP.Name = STAGEN_COLOROPSTRINGS[x];
			STAGEN_COLOROP.Definition = d3dtopStrings[thisTextureStageState.stageStateUnion.namedStates.colorOp];
			defines.push_back(STAGEN_COLOROP);
		}

		{
			D3DXMACRO STAGEN_ALPHAOP = {0};
			STAGEN_ALPHAOP.Name = STAGEN_ALPHAOPSTRINGS[x];
			STAGEN_ALPHAOP.Definition = d3dtopStrings[thisTextureStageState.stageStateUnion.namedStates.alphaOp];
			defines.push_back(STAGEN_ALPHAOP);
		}

		{
			D3DXMACRO STAGEN_COLORARG1 = {0};
			STAGEN_COLORARG1.Name = STAGEN_COLORARG1STRINGS[x];
			STAGEN_COLORARG1.Definition = d3dtaStrings[thisTextureStageState.stageStateUnion.namedStates.colorArg1];
			defines.push_back(STAGEN_COLORARG1);
		}

		{
			D3DXMACRO STAGEN_COLORARG2 = {0};
			STAGEN_COLORARG2.Name = STAGEN_COLORARG2STRINGS[x];
			STAGEN_COLORARG2.Definition = d3dtaStrings[thisTextureStageState.stageStateUnion.namedStates.colorArg2];
			defines.push_back(STAGEN_COLORARG2);
		}

		{
			D3DXMACRO STAGEN_COLORARG0 = {0};
			STAGEN_COLORARG0.Name = STAGEN_COLORARG0STRINGS[x];
			STAGEN_COLORARG0.Definition = d3dtaStrings[thisTextureStageState.stageStateUnion.namedStates.colorArg0];
			defines.push_back(STAGEN_COLORARG0);
		}

		{
			D3DXMACRO STAGEN_ALPHAARG1 = {0};
			STAGEN_ALPHAARG1.Name = STAGEN_ALPHAARG1STRINGS[x];
			STAGEN_ALPHAARG1.Definition = d3dtaStrings[thisTextureStageState.stageStateUnion.namedStates.alphaArg1];
			defines.push_back(STAGEN_ALPHAARG1);
		}

		{
			D3DXMACRO STAGEN_ALPHAARG2 = {0};
			STAGEN_ALPHAARG2.Name = STAGEN_ALPHAARG2STRINGS[x];
			STAGEN_ALPHAARG2.Definition = d3dtaStrings[thisTextureStageState.stageStateUnion.namedStates.alphaArg2];
			defines.push_back(STAGEN_ALPHAARG2);
		}

		{
			D3DXMACRO STAGEN_ALPHAARG0 = {0};
			STAGEN_ALPHAARG0.Name = STAGEN_ALPHAARG0STRINGS[x];
			STAGEN_ALPHAARG0.Definition = d3dtaStrings[thisTextureStageState.stageStateUnion.namedStates.alphaArg0];
			defines.push_back(STAGEN_ALPHAARG0);
		}

		{
			D3DXMACRO STAGEN_RESULTARG = {0};
			STAGEN_RESULTARG.Name = STAGEN_RESULTARGSTRINGS[x];
			STAGEN_RESULTARG.Definition = d3dtaStrings[thisTextureStageState.stageStateUnion.namedStates.resultArg];
			defines.push_back(STAGEN_RESULTARG);
		}

		if (thisTextureStageState.stageStateUnion.namedStates.colorOp == D3DTOP_DISABLE)
		{
			// We can safely stop after we reach the first texture stage that is set to disabled
			break;
		}
	}

	if (!defines.empty() )
	{
		D3DXMACRO emptyLastMacro = {0};
		defines.push_back(emptyLastMacro);
	}
}

void BuildPixelShader(const DeviceState& state, IDirect3DDevice9Hook* const dev, IDirect3DPixelShader9Hook** const outNewShader)
{
#ifdef _DEBUG
	if (!outNewShader)
	{
		__debugbreak();
	}
#endif

	std::vector<D3DXMACRO> defines;
	BuildPixelStateDefines(state, defines);

	LPD3DXBUFFER outBytecode = NULL;
	LPD3DXBUFFER errorMessages = NULL;
	DWORD flags = D3DXSHADER_AVOID_FLOW_CONTROL | D3DXSHADER_PARTIALPRECISION; // Branching isn't currently well-supported in the software shader system
#ifdef _DEBUG
	flags |= D3DXSHADER_DEBUG;
#else
	flags |= D3DXSHADER_OPTIMIZATION_LEVEL3;
#endif

	HRESULT hr = E_FAIL;

	unsigned resourceSize = 0;
	const char* const resourceBytes = (const char* const)GetShaderResourceFile(MAKEINTRESOURCEA(IDR_HLSL_FFPS_SRC), resourceSize);
	if (resourceBytes != NULL)
	{
		hr = D3DXCompileShader( (const char* const)resourceBytes, resourceSize, defines.empty() ? NULL : &defines.front(), D3DXIncludeHandler::GetGlobalIncludeHandlerSingleton(), 
			"main", "ps_3_0", flags, &outBytecode, &errorMessages, NULL);
	}
	if (FAILED(hr) || !outBytecode)
	{
		const char* const errorMessage = errorMessages ? ( (const char* const)errorMessages->GetBufferPointer() ) : NULL;
		printf("%s", errorMessage); // Don't optimize this away

		// Should never happen for fixed-function shaders!
		MessageBoxA(NULL, errorMessage, "Fixed Function PS Compile Failure!", MB_OK);
		__debugbreak();

		return;
	}

#ifdef _DEBUG
	const char* const debugErrorMessage = errorMessages ? ( (const char* const)errorMessages->GetBufferPointer() ) : NULL;
	UNREFERENCED_PARAMETER(debugErrorMessage);
#endif

	IDirect3DPixelShader9* newPixelShader = NULL;
	if (FAILED(dev->CreatePixelShader( (const DWORD* const)outBytecode->GetBufferPointer(), &newPixelShader) ) || !newPixelShader)
	{
		// Should never happen for fixed-function shaders!
		__debugbreak();
	}

	IDirect3DPixelShader9Hook* newPixelShaderHook = dynamic_cast<IDirect3DPixelShader9Hook*>(newPixelShader);
	if (!newPixelShaderHook)
	{
		DbgBreakPrint("Error: CreatePixelShader returned a non-hooked pointer!");
	}

	newPixelShaderHook->GetModifyShaderInfo().fixedFunctionMacroDefines.swap(defines);

	*outNewShader = newPixelShaderHook;

	if (outBytecode)
	{
		outBytecode->Release();
		outBytecode = NULL;
	}
	if (errorMessages)
	{
		errorMessages->Release();
		errorMessages = NULL;
	}
}

void SetFixedFunctionPixelShaderState(const DeviceState& state, IDirect3DDevice9Hook* const dev)
{
	// TFACTOR (c0)
	const D3DCOLOR tfactorColor = state.currentRenderStates.renderStatesUnion.namedStates.textureFactor;
	const D3DXVECTOR4 tfactor( ( (tfactorColor >> 16) & 0xFF) / 255.0f,  // R
		( (tfactorColor >> 8) & 0xFF) / 255.0f,  // G
		(tfactorColor & 0xFF) / 255.0f, 		 // B
		( (tfactorColor >> 24) & 0xFF) / 255.0f); // A
	dev->SetPixelShaderConstantF(TFACTOR_REGISTER, &tfactor.x, 1);

	// FOGCOLOR (c1)
	const D3DCOLOR fogColor = state.currentRenderStates.renderStatesUnion.namedStates.fogColor;
	const D3DXVECTOR4 fogColorVec( ( (fogColor >> 16) & 0xFF) / 255.0f,  // R
		( (fogColor >> 8) & 0xFF) / 255.0f,  // G
		(fogColor & 0xFF) / 255.0f, 		 // B
		( (fogColor >> 24) & 0xFF) / 255.0f); // A
	dev->SetPixelShaderConstantF(FOGCOLOR_REGISTER, &fogColorVec.x, 1);

	// D3DTSS_CONSTANT (c2 thru c10)
	for (unsigned x = 0; x < MAX_NUM_TEXTURE_STAGE_STATES; ++x)
	{
		const D3DCOLOR stageConstantColor = state.currentStageStates[x].stageStateUnion.namedStates.constant;
		const D3DXVECTOR4 stageConstant( ( (stageConstantColor >> 16) & 0xFF) / 255.0f,  // R
			( (stageConstantColor >> 8) & 0xFF) / 255.0f,  // G
			(stageConstantColor & 0xFF) / 255.0f, 		 // B
			( (stageConstantColor >> 24) & 0xFF) / 255.0f); // A
		dev->SetPixelShaderConstantF(TEXTURESTAGE_CONSTANTS_REGISTERS + x, &stageConstant.x, 1);
	}

	// BUMPENVMAT matrices (c10 thru c27)
	for (unsigned x = 0; x < MAX_NUM_TEXTURE_STAGE_STATES; ++x)
	{
		D3DXVECTOR4 stageBumpEnvMat[2];
		stageBumpEnvMat[0] = D3DXVECTOR4(0.0f, 0.0f, 0.0f, 0.0f);
		stageBumpEnvMat[1] = D3DXVECTOR4(0.0f, 0.0f, 0.0f, 0.0f);

		const TextureStageState& currentStageState = state.currentStageStates[x];

		// Transpose the matrix on the CPU before sending to the GPU for more efficient matrix multiplication:
		// [0, 1]		  [0, 2]
		// [2, 3] becomes [1, 3]
		stageBumpEnvMat[0].x = currentStageState.stageStateUnion.namedStates.bumpEnvMat00;
		stageBumpEnvMat[0].y = currentStageState.stageStateUnion.namedStates.bumpEnvMat10;
		stageBumpEnvMat[1].x = currentStageState.stageStateUnion.namedStates.bumpEnvMat01;
		stageBumpEnvMat[1].y = currentStageState.stageStateUnion.namedStates.bumpEnvMat11;
		// Append the scale and offset to the last column of the matrices (this should be completely untouched by the "m3x2" instruction)
		stageBumpEnvMat[0].w = currentStageState.stageStateUnion.namedStates.bumpEnvLScale;
		stageBumpEnvMat[1].w = currentStageState.stageStateUnion.namedStates.bumpEnvLOffset;
		dev->SetPixelShaderConstantF(STAGE_BUMPENVMAT_REGISTERS + x * 2, &(stageBumpEnvMat[0].x), 2);
	}
}

```

`Software_d3d9/FixedFunctionToShader.cpp`:

```cpp
#pragma once

#include "FixedFunctionToShader.h"
#include "IDirect3DVertexShader9Hook.h"
#include "IDirect3DPixelShader9Hook.h"
#include "GlobalToggles.h"
#include <vector> // for std::vector
#include <map> // for std::map
#include "resource.h"

// Note: There's some good tidbits of information on this page: https://docs.microsoft.com/en-us/windows-hardware/drivers/display/converting-the-direct3d-fixed-function-state

/*static*/ D3DXIncludeHandler D3DXIncludeHandler::globalIncludeHandlerSingleton;

#ifndef NO_CACHING_FIXED_FUNCTION_SHADERS
// These maps map from device state hashes into shaders:
static std::map<FixedFunctionStateHash, IDirect3DVertexShader9Hook*> vertShadersHashMap;
static std::map<FixedFunctionStateHash, IDirect3DPixelShader9Hook*> pixelShadersHashMap;
#endif // NO_CACHING_FIXED_FUNCTION_SHADERS

DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE D3DXIncludeHandler::Open(THIS_ D3DXINCLUDE_TYPE IncludeType, LPCSTR pFileName, LPCVOID pParentData, LPCVOID *ppData, UINT *pBytes)
{
	UNREFERENCED_PARAMETER(pParentData);
	UNREFERENCED_PARAMETER(IncludeType);

	unsigned resourceSize = 0;
	const void* includeFileBytes = GetShaderResourceFile(pFileName, resourceSize);
	if (includeFileBytes != NULL)
	{
		*ppData = includeFileBytes;
		*pBytes = resourceSize;
		return S_OK;
	}
	else
		return E_FAIL;
}

DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE D3DXIncludeHandler::Close(THIS_ LPCVOID pData)
{
	UNREFERENCED_PARAMETER(pData);

	// We don't have to do anything on close, so this is okay!
	return S_OK;
}

// The resourceName passed in may also be a string from the MAKEINTRESOURCEA() macro.
// Returns NULL if the resource cannot be found!
const void* const GetShaderResourceFile(const char* const resourceNameA, unsigned& outFoundResourceSize, const char* const resourceCategory/* = "HLSL"*/)
{
	HRSRC hlslResource = FindResourceA(hLThisDLL, resourceNameA, resourceCategory);
	if (hlslResource)
	{
		HGLOBAL loadedResource = LoadResource(hLThisDLL, hlslResource);
		if (loadedResource)
		{
			const unsigned resourceSize = SizeofResource(hLThisDLL, hlslResource);
			if (resourceSize > 0)
			{
				const void* const resourceBytes = LockResource(loadedResource);
				if (resourceBytes)
				{
					outFoundResourceSize = resourceSize;
					return resourceBytes;
				}
			}
		}
	}
	outFoundResourceSize = 0;
	return NULL;
}

void FixedFunctionStateToVertexShader(const DeviceState& state, IDirect3DVertexShader9Hook** const outVertShader, IDirect3DDevice9Hook* const dev)
{
#ifdef _DEBUG
	if (!outVertShader)
	{
		__debugbreak();
	}
#endif

#ifndef NO_CACHING_FIXED_FUNCTION_SHADERS
	const FixedFunctionStateHash stateHash = HashVertexState(state);

	// If we can match the device state to a shader (should happen every time after the first) then just return that shader
	const std::map<FixedFunctionStateHash, IDirect3DVertexShader9Hook*>::const_iterator it = vertShadersHashMap.find(stateHash);
	if (it != vertShadersHashMap.end() )
	{
		*outVertShader = it->second;
		return;
	}
#endif // NO_CACHING_FIXED_FUNCTION_SHADERS

	// Construct new vertex shader from device state
	IDirect3DVertexShader9Hook* newVertShader = NULL;
	BuildVertexShader(state, dev, &newVertShader);

#ifndef NO_CACHING_FIXED_FUNCTION_SHADERS
	// Insert new vertex shader into vert shaders hash map
	vertShadersHashMap.insert(std::make_pair(stateHash, newVertShader) );
#endif // NO_CACHING_FIXED_FUNCTION_SHADERS

	*outVertShader = newVertShader;
}

void FixedFunctionStateToPixelShader(const DeviceState& state, IDirect3DPixelShader9Hook** const outPixelShader, IDirect3DDevice9Hook* const dev)
{
#ifdef _DEBUG
	if (!outPixelShader)
	{
		__debugbreak();
	}
#endif

#ifndef NO_CACHING_FIXED_FUNCTION_SHADERS
	const FixedFunctionStateHash stateHash = HashPixelState(state);

	// If we can match the device state to a shader (should happen every time after the first) then just return that shader
	const std::map<FixedFunctionStateHash, IDirect3DPixelShader9Hook*>::const_iterator it = pixelShadersHashMap.find(stateHash);
	if (it != pixelShadersHashMap.end() )
	{
		*outPixelShader = it->second;
		return;
	}
#endif // NO_CACHING_FIXED_FUNCTION_SHADERS

	// Construct new pixel shader from device state
	IDirect3DPixelShader9Hook* newPixelShader = NULL;
	BuildPixelShader(state, dev, &newPixelShader);

#ifndef NO_CACHING_FIXED_FUNCTION_SHADERS
	// Insert new pixel shader into pixel shaders hash map
	pixelShadersHashMap.insert(std::make_pair(stateHash, newPixelShader) );
#endif // NO_CACHING_FIXED_FUNCTION_SHADERS

	*outPixelShader = newPixelShader;
}

```

`Software_d3d9/FixedFunctionToShader.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

extern HINSTANCE hLThisDLL;

#ifndef NO_CACHING_FIXED_FUNCTION_SHADERS
typedef unsigned __int64 FixedFunctionStateHash;

template <typename T>
static inline void HashContinue(FixedFunctionStateHash& hash, const T data)
{
	const unsigned rotateAmount = (sizeof(T) * 8) % (sizeof(FixedFunctionStateHash) * 8);
	if (rotateAmount != 0)
		hash = _rotl64(hash, rotateAmount);
	hash ^= data;
}

// Need an explicit template specialization here because operator^= is not defined for floats:
template <>
static inline void HashContinue(FixedFunctionStateHash& hash, const float data)
{
	const unsigned rotateAmount = (sizeof(float) * 8) % (sizeof(FixedFunctionStateHash) * 8);
	if (rotateAmount != 0)
		hash = _rotl64(hash, rotateAmount);
	const DWORD dwFlt = *(const DWORD* const)&data;
	hash ^= dwFlt;
}

template <>
static inline void HashContinue(FixedFunctionStateHash& hash, const BOOL data)
{
	const unsigned rotateAmount = 1;
	hash = _rotl64(hash, rotateAmount);
	if (data)
		hash ^= 0x1;
}

template <>
static inline void HashContinue(FixedFunctionStateHash& hash, const bool data)
{
	const unsigned rotateAmount = 1;
	hash = _rotl64(hash, rotateAmount);
	if (data)
		hash ^= 0x1;
}

template <typename T>
static inline void HashStruct(FixedFunctionStateHash& hash, const T& data)
{
	const unsigned rotateAmount = (sizeof(T) * 8) % (sizeof(FixedFunctionStateHash) * 8);
	if (rotateAmount != 0)
		hash = _rotl64(hash, rotateAmount);

	const unsigned char* const uData = (const unsigned char* const)&data;
	for (unsigned x = 0; x < sizeof(T) / sizeof(unsigned char); ++x)
	{
		hash = _rotl64(hash, sizeof(unsigned char) * 8);
		hash ^= uData[x];
	}
}

// Forward-declares:
const FixedFunctionStateHash HashVertexState(const DeviceState& state);
const FixedFunctionStateHash HashPixelState(const DeviceState& state);

#endif // #ifndef NO_CACHING_FIXED_FUNCTION_SHADERS

void FixedFunctionStateToVertexShader(const DeviceState& state, IDirect3DVertexShader9Hook** const outVertShader, IDirect3DDevice9Hook* const dev);
void FixedFunctionStateToPixelShader(const DeviceState& state, IDirect3DPixelShader9Hook** const outPixelShader, IDirect3DDevice9Hook* const dev);
void SetFixedFunctionVertexShaderState(const DeviceState& state, IDirect3DDevice9Hook* const dev);
void SetFixedFunctionPixelShaderState(const DeviceState& state, IDirect3DDevice9Hook* const dev);
void BuildVertexShader(const DeviceState& state, IDirect3DDevice9Hook* const dev, IDirect3DVertexShader9Hook** const outNewShader);
void BuildPixelShader(const DeviceState& state, IDirect3DDevice9Hook* const dev, IDirect3DPixelShader9Hook** const outNewShader);

struct D3DXIncludeHandler : public ID3DXInclude
{
	STDMETHOD(Open)(THIS_ D3DXINCLUDE_TYPE IncludeType, LPCSTR pFileName, LPCVOID pParentData, LPCVOID *ppData, UINT *pBytes);
	STDMETHOD(Close)(THIS_ LPCVOID pData);

	virtual ~D3DXIncludeHandler()
	{
	}

	static inline D3DXIncludeHandler* const GetGlobalIncludeHandlerSingleton()
	{
		return &globalIncludeHandlerSingleton;
	}

private:
	static D3DXIncludeHandler globalIncludeHandlerSingleton;
};

// The resourceName passed in may also be a string from the MAKEINTRESOURCEA() macro.
// Returns NULL if the resource cannot be found!
const void* const GetShaderResourceFile(const char* const resourceNameA, unsigned& outFoundResourceSize, const char* const resourceCategory = "HLSL");

```

`Software_d3d9/FixedFunctionToVertexShader.cpp`:

```cpp
#include "FixedFunctionToShader.h"
#include "IDirect3DVertexShader9Hook.h"
#include "IDirect3DVertexDeclaration9Hook.h"
#include "resource.h"

#define M_PI       3.14159265358979323846f   // pi

static const unsigned char WVP_REGISTERS = 3u;
static const unsigned char TWEENFACTOR_REGISTER = 7u;
static const unsigned char POINTSCALEPARAMS_REGISTER = 8u;
static const unsigned char POINTSCALEDATA_REGISTER = 9u;
static const unsigned char FOGDATA_REGISTER = 14u;
static const unsigned char MATERIALDATA_REGISTERS = 15u;
static const unsigned char AMBIENT_REGISTER = 19u;
static const unsigned char TEXCOORD_TRANSFORM_REGISTERS = 20u;
static const unsigned char LIGHTDATA_REGISTERS = 52u;
static const unsigned char PROJMATRIX_REGISTERS = 108u;
static const unsigned char WORLDVIEW_TRANSFORM_REGISTERS = 112u;

#pragma pack(push)
#pragma pack(1)
struct wvShaderMatrix
{
	D3DXMATRIXA16 worldView; // Forwards worldview matrix (used for transforming vertex positions from modelspace to view-space)
	D3DXMATRIXA16 invWorldView; // Inverse of the worldView matrix (used for transforming vertex normals from modelspace to view-space)
};

struct shaderPackedLight
{
	D3DCOLORVALUE Diffuse;
	D3DCOLORVALUE Specular;
	D3DCOLORVALUE Ambient;
	D3DXVECTOR4 Position_Range; // XYZ = Position, W = Range
	D3DXVECTOR4 Direction_Falloff; // XYZ = Direction (normalized), W = Falloff
	D3DXVECTOR4 Attenuation; // XYZ = Attenunation, W = 1.0f / (cos(theta / 2) - cos(phi / 2) )
	D3DXVECTOR4 SpotLightParams; // X = phi, Y = theta, Z = cos(theta / 2), W = cos(phi / 2)
};
#pragma pack(pop)
static_assert(sizeof(wvShaderMatrix) == 4 * 4 * 2 * sizeof(float), "Error - unexpected struct size for wvShaderMatrix!");
static_assert(sizeof(shaderPackedLight) == 4 * 7 * sizeof(float), "Error - unexpected struct size for shaderPackedLight!");

const FixedFunctionStateHash HashVertexState(const DeviceState& state)
{
	FixedFunctionStateHash retHash = 0;

	for (unsigned x = 0; x < 8; ++x)
	{
		const TextureStageState::_stageStateUnion::_namedStates& currentStageStates = state.currentStageStates[x].stageStateUnion.namedStates;
		HashContinue<unsigned char>(retHash, (unsigned char)(LOWORD(currentStageStates.texCoordIndex) ) );
		HashContinue<unsigned char>(retHash, (unsigned char)(HIWORD(currentStageStates.texCoordIndex) ) );
		if (state.currentStageStates[x].stageStateUnion.namedStates.textureTransformFlags & D3DTTFF_PROJECTED)
			HashContinue<unsigned char>(retHash, (unsigned char)(currentStageStates.textureTransformFlags) | 0x8);
		else
			HashContinue<unsigned char>(retHash, currentStageStates.textureTransformFlags);
	}
	const RenderStates::_renderStatesUnion::_namedStates& currentNamedStates = state.currentRenderStates.renderStatesUnion.namedStates;
	HashContinue(retHash, currentNamedStates.colorVertex);
	HashContinue<unsigned char>(retHash, currentNamedStates.diffuseMaterialSource);
	HashContinue<unsigned char>(retHash, currentNamedStates.specularMaterialSource);
	HashContinue<unsigned char>(retHash, currentNamedStates.ambientMaterialSource);
	HashContinue<unsigned char>(retHash, currentNamedStates.emissiveMaterialSource);
	if (currentNamedStates.vertexBlend == D3DVBF_0WEIGHTS)
		HashContinue<unsigned char>(retHash, (unsigned char)(currentNamedStates.vertexBlend) | 0x4);
	else
		HashContinue<unsigned char>(retHash, currentNamedStates.vertexBlend);
	HashContinue(retHash, currentNamedStates.indexedVertexBlendEnable);
	HashContinue(retHash, currentNamedStates.normalizeNormals);
	HashContinue(retHash, currentNamedStates.fogEnable);
	if (currentNamedStates.fogEnable)
	{
		HashContinue<unsigned char>(retHash, currentNamedStates.fogVertexMode);
		HashContinue<unsigned char>(retHash, currentNamedStates.fogTableMode);
		HashContinue<unsigned char>(retHash, currentNamedStates.rangeFogEnable);
	}
	HashContinue(retHash, currentNamedStates.lighting);
	HashContinue(retHash, currentNamedStates.specularEnable);
	HashContinue(retHash, currentNamedStates.localViewer);
	if (currentNamedStates.lighting)
	{
		for (unsigned x = 0; x < 8; ++x)
		{
			D3DLIGHTTYPE thisLightType = (const D3DLIGHTTYPE)0; // Note that 0 does not map to a valid enum value, so this is okay
			if (state.enabledLightIndices[x])
				thisLightType = state.enabledLightIndices[x]->light.Type;
			HashContinue<unsigned char>(retHash, thisLightType);
		}
	}

	if (state.currentVertexDecl)
	{
		unsigned inputVertexDeclBits = 0;
		const std::vector<DebuggableD3DVERTEXELEMENT9>& declElements = state.currentVertexDecl->GetElementsInternal();
		const unsigned numElements = declElements.size();
		for (unsigned x = 0; x < numElements; ++x)
		{
			const DebuggableD3DVERTEXELEMENT9& thisElement = declElements[x];
			
			// These are all of the input types that the fixed function vertex pipeline cares about that could change its shadercode:
			if (thisElement.Usage == D3DDECLUSAGE_POSITION && thisElement.UsageIndex == 0) // POSITION0
				inputVertexDeclBits |= (1 << 0);
			else if (thisElement.Usage == D3DDECLUSAGE_POSITION && thisElement.UsageIndex == 1) // POSITION1 (used only when vertex tweening)
				inputVertexDeclBits |= (1 << 1);
			else if (thisElement.Usage == D3DDECLUSAGE_BLENDWEIGHT && thisElement.UsageIndex == 0) // BLENDWEIGHT
				inputVertexDeclBits |= (1 << 2);
			else if (thisElement.Usage == D3DDECLUSAGE_BLENDINDICES && thisElement.UsageIndex == 0) // BLENDINDICES
				inputVertexDeclBits |= (1 << 3);
			else if (thisElement.Usage == D3DDECLUSAGE_NORMAL && thisElement.UsageIndex == 0) // NORMAL0
				inputVertexDeclBits |= (1 << 4);
			else if (thisElement.Usage == D3DDECLUSAGE_NORMAL && thisElement.UsageIndex == 1) // NORMAL1 (used only when vertex tweening)
				inputVertexDeclBits |= (1 << 5);
			else if (thisElement.Usage == D3DDECLUSAGE_PSIZE && thisElement.UsageIndex == 0) // PSIZE
				inputVertexDeclBits |= (1 << 6);
			else if (thisElement.Usage == D3DDECLUSAGE_COLOR && thisElement.UsageIndex == 0) // COLOR0 (diffuse color)
				inputVertexDeclBits |= (1 << 7);
			else if (thisElement.Usage == D3DDECLUSAGE_COLOR && thisElement.UsageIndex == 1) // COLOR1 (specular color)
				inputVertexDeclBits |= (1 << 8);
			else if (thisElement.Usage == D3DDECLUSAGE_TEXCOORD) // TEXCOORDN (texcoords)
				inputVertexDeclBits |= (1 << (9 + thisElement.UsageIndex) );
		}
		HashContinue(retHash, inputVertexDeclBits);
	}

	return retHash;
}

static const char* const STAGE_MATERIALSOURCE[3] =
{
	"D3DMCS_MATERIAL", // 0
	"D3DMCS_COLOR1", // 1
	"D3DMCS_COLOR2" // 2
};

static const char* const VERTEX_FOGMODE[4] =
{
	"D3DFOG_NONE", //                 = 0,
    "D3DFOG_EXP", //                  = 1,
    "D3DFOG_EXP2", //                 = 2,
    "D3DFOG_LINEAR", //               = 3,
};

static const char* const lightCountStr[9] = 
{
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8"
};

static const char* const lightTypeStr[] =
{
	"D3DLIGHT_POINT",//          = 1,
    "D3DLIGHT_SPOT",//           = 2,
    "D3DLIGHT_DIRECTIONAL",//    = 3,
};

static const char* const lightTypesNamesStr[8] =
{
	"LIGHTTYPE0",
	"LIGHTTYPE1",
	"LIGHTTYPE2",
	"LIGHTTYPE3",
	"LIGHTTYPE4",
	"LIGHTTYPE5",
	"LIGHTTYPE6",
	"LIGHTTYPE7"
};

static const char* const texRemapStrings[8] = 
{
	"TEX0REMAP",
	"TEX1REMAP",
	"TEX2REMAP",
	"TEX3REMAP",
	"TEX4REMAP",
	"TEX5REMAP",
	"TEX6REMAP",
	"TEX7REMAP"
};

static const char* const texRemapDefStrings[8] = 
{
	"tex0",
	"tex1",
	"tex2",
	"tex3",
	"tex4",
	"tex5",
	"tex6",
	"tex7"
};

static const char* const texCoordGenerationTypeName[8] =
{
	"D3DTSS_TEXCOORDINDEX0TYPE",
	"D3DTSS_TEXCOORDINDEX1TYPE",
	"D3DTSS_TEXCOORDINDEX2TYPE",
	"D3DTSS_TEXCOORDINDEX3TYPE",
	"D3DTSS_TEXCOORDINDEX4TYPE",
	"D3DTSS_TEXCOORDINDEX5TYPE",
	"D3DTSS_TEXCOORDINDEX6TYPE",
	"D3DTSS_TEXCOORDINDEX7TYPE"
};

static const char* const texCoordGenerationTypeString[5] = 
{
	"D3DTSS_TCI_PASSTHRU",//                            0x0000
	"D3DTSS_TCI_CAMERASPACENORMAL",//                   0x0001
	"D3DTSS_TCI_CAMERASPACEPOSITION",//                 0x0002
	"D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR",//         0x0003
	"D3DTSS_TCI_SPHEREMAP"//                            0x0004
};

static const char* const texTransformStrings[8] =
{
	"USE_TEXTRANSFORM0",
	"USE_TEXTRANSFORM1",
	"USE_TEXTRANSFORM2",
	"USE_TEXTRANSFORM3",
	"USE_TEXTRANSFORM4",
	"USE_TEXTRANSFORM5",
	"USE_TEXTRANSFORM6",
	"USE_TEXTRANSFORM7"
};

struct elementMatchDefine
{
	const D3DDECLUSAGE usage;
	const DWORD usageIndex;
	const char* const defineString;
};

static const elementMatchDefine matchDefines[] =
{
	{ D3DDECLUSAGE_POSITION, 0, "DECL_HAS_POSITION0" },
	{ D3DDECLUSAGE_POSITION, 1, "DECL_HAS_POSITION1" },
	{ D3DDECLUSAGE_BLENDWEIGHT, 0, "INPUT_HAS_BLENDWEIGHTS" },
	{ D3DDECLUSAGE_BLENDINDICES, 0, "INPUT_HAS_LASTBETA" },
	{ D3DDECLUSAGE_NORMAL, 0, "DECL_HAS_NORMAL0" },
	{ D3DDECLUSAGE_PSIZE, 0, "PER_VERTEX_POINTSIZE" },
	{ D3DDECLUSAGE_COLOR, 0, "INPUT_HAS_DIFFUSE" },
	{ D3DDECLUSAGE_COLOR, 1, "INPUT_HAS_SPECULAR" },
	{ D3DDECLUSAGE_TEXCOORD, 0, "INPUT_HAS_TEXCOORD0" },
	{ D3DDECLUSAGE_TEXCOORD, 1, "INPUT_HAS_TEXCOORD1" },
	{ D3DDECLUSAGE_TEXCOORD, 2, "INPUT_HAS_TEXCOORD2" },
	{ D3DDECLUSAGE_TEXCOORD, 3, "INPUT_HAS_TEXCOORD3" },
	{ D3DDECLUSAGE_TEXCOORD, 4, "INPUT_HAS_TEXCOORD4" },
	{ D3DDECLUSAGE_TEXCOORD, 5, "INPUT_HAS_TEXCOORD5" },
	{ D3DDECLUSAGE_TEXCOORD, 6, "INPUT_HAS_TEXCOORD6" },
	{ D3DDECLUSAGE_TEXCOORD, 7, "INPUT_HAS_TEXCOORD7" }
};

static inline void BuildVertexDeclStateDefines(const IDirect3DVertexDeclaration9Hook* const decl, std::vector<D3DXMACRO>& defines)
{
	if (!decl)
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return;
	}

	const std::vector<DebuggableD3DVERTEXELEMENT9>& elements = decl->GetElementsInternal();
	const unsigned numElements = elements.size();
	for (unsigned x = 0; x < numElements; ++x)
	{
		const DebuggableD3DVERTEXELEMENT9& thisElement = elements[x];
		for (unsigned y = 0; y < ARRAYSIZE(matchDefines); ++y)
		{
			const elementMatchDefine& thisMatchDefine = matchDefines[y];
			if (thisMatchDefine.usage == thisElement.Usage && thisMatchDefine.usageIndex == thisElement.UsageIndex)
			{
				D3DXMACRO newDefine = {0};
				newDefine.Name = thisMatchDefine.defineString;
				newDefine.Definition = "1";
				defines.push_back(newDefine);
				break;
			}
		}
	}
}

static inline void BuildOutputStateDefines(const DeviceState& state, std::vector<D3DXMACRO>& defines)
{
	// TODO: VS Output defines
	/*VS OUTPUT (is this right???)
	OUTPUT_POINTSIZE // Only if point scale or point sprites are enabled?
	OUTPUT_FOG // Only if fog is enabled?
	OUTPUT_TEX0 thru OUTPUT_TEX7 // Check for consumption from pixelshader or FF pipeline*/
	{
		D3DXMACRO tex0_mcs = {0};
		tex0_mcs.Name = "OUTPUT_TEX0";
		tex0_mcs.Definition = "1";
		defines.push_back(tex0_mcs);
	}
}

static inline void BuildVertexStateDefines(const DeviceState& state, std::vector<D3DXMACRO>& defines)
{
	{
		D3DXMACRO diffuse_mcs = {0};
		diffuse_mcs.Name = "DIFFUSEMATERIALSOURCE";
		diffuse_mcs.Definition = STAGE_MATERIALSOURCE[state.currentRenderStates.renderStatesUnion.namedStates.colorVertex ? state.currentRenderStates.renderStatesUnion.namedStates.diffuseMaterialSource : D3DMCS_MATERIAL];
		defines.push_back(diffuse_mcs);
	}
	{
		D3DXMACRO specular_mcs = {0};
		specular_mcs.Name = "SPECULARMATERIALSOURCE";
		specular_mcs.Definition = STAGE_MATERIALSOURCE[state.currentRenderStates.renderStatesUnion.namedStates.colorVertex ? state.currentRenderStates.renderStatesUnion.namedStates.specularMaterialSource : D3DMCS_MATERIAL];
		defines.push_back(specular_mcs);
	}
	{
		D3DXMACRO ambient_mcs = {0};
		ambient_mcs.Name = "AMBIENTMATERIALSOURCE";
		ambient_mcs.Definition = STAGE_MATERIALSOURCE[state.currentRenderStates.renderStatesUnion.namedStates.ambientMaterialSource]; // D3DRS_AMBIENTMATERIALSOURCE does not appear to be affected by D3DRS_COLORVERTEX
		defines.push_back(ambient_mcs);
	}
	{
		D3DXMACRO emissive_mcs = {0};
		emissive_mcs.Name = "EMISSIVEMATERIALSOURCE";
		emissive_mcs.Definition = STAGE_MATERIALSOURCE[state.currentRenderStates.renderStatesUnion.namedStates.emissiveMaterialSource]; // D3DRS_EMISSIVEMATERIALSOURCE does not appear to be affected by D3DRS_COLORVERTEX
		defines.push_back(emissive_mcs);
	}

	if (state.currentRenderStates.renderStatesUnion.namedStates.vertexBlend == D3DVBF_TWEENING)
	{
		D3DXMACRO tweening = {0};
		tweening.Name = "VERTEX_TWEENING";
		tweening.Definition = "1";
		defines.push_back(tweening);
	}

	{
		D3DXMACRO vertexBlend = {0};
		state.currentRenderStates.renderStatesUnion.namedStates.vertexBlend;
		vertexBlend.Name = "VERTEXBLEND";
		switch (state.currentRenderStates.renderStatesUnion.namedStates.vertexBlend)
		{
		default:
		case D3DVBF_DISABLE:
			vertexBlend.Definition = "D3DVBF_DISABLE";
			break;
		case D3DVBF_1WEIGHTS:
			vertexBlend.Definition = "D3DVBF_1WEIGHTS";
			break;
		case D3DVBF_2WEIGHTS:
			vertexBlend.Definition = "D3DVBF_2WEIGHTS";
			break;
		case D3DVBF_3WEIGHTS:
			vertexBlend.Definition = "D3DVBF_3WEIGHTS";
			break;
		case D3DVBF_TWEENING:
			vertexBlend.Definition = "D3DVBF_TWEENING";
			break;
		case D3DVBF_0WEIGHTS:
			vertexBlend.Definition = "D3DVBF_0WEIGHTS";
			break;
		}
		defines.push_back(vertexBlend);
	}

	if (state.currentRenderStates.renderStatesUnion.namedStates.indexedVertexBlendEnable)
	{
		D3DXMACRO indexedVertexBlendEnable = {0};
		indexedVertexBlendEnable.Name = "INDEXEDVERTEXBLENDENABLE";
		indexedVertexBlendEnable.Definition = "1";
		defines.push_back(indexedVertexBlendEnable);
	}

	if (state.currentRenderStates.renderStatesUnion.namedStates.normalizeNormals)
	{
		D3DXMACRO normalizeNormalsEnable = {0};
		normalizeNormalsEnable.Name = "D3DRS_NORMALIZENORMALS";
		normalizeNormalsEnable.Definition = "1";
		defines.push_back(normalizeNormalsEnable);
	}

	if (state.currentRenderStates.renderStatesUnion.namedStates.fogEnable)
	{
		D3DXMACRO fogEnable = {0};
		fogEnable.Name = "OUTPUT_FOG";
		fogEnable.Definition = "1";
		defines.push_back(fogEnable);

		D3DFOGMODE fogMode = D3DFOG_NONE;

		// TODO: Confirm that table-fog overrides vertex-fog and not the other way around:
		if (state.currentRenderStates.renderStatesUnion.namedStates.fogVertexMode > D3DFOG_NONE)
			fogMode = state.currentRenderStates.renderStatesUnion.namedStates.fogVertexMode;
		if (state.currentRenderStates.renderStatesUnion.namedStates.fogTableMode > D3DFOG_NONE)
			fogMode = state.currentRenderStates.renderStatesUnion.namedStates.fogTableMode;

		D3DXMACRO vertexFogmode = {0};
		vertexFogmode.Name = "D3DRS_FOGVERTEXMODE";
		vertexFogmode.Definition = VERTEX_FOGMODE[fogMode];
		defines.push_back(vertexFogmode);

		if (state.currentRenderStates.renderStatesUnion.namedStates.rangeFogEnable)
		{
			D3DXMACRO rangeFogEnable = {0};
			rangeFogEnable.Name = "D3DRS_RANGEFOGENABLE";
			rangeFogEnable.Definition = "1";
			defines.push_back(rangeFogEnable);
		}
	}

	if (state.currentRenderStates.renderStatesUnion.namedStates.lighting)
	{
		unsigned numEnabledLights = 0;
		for (unsigned x = 0; x < 8; ++x)
		{
			if (state.enabledLightIndices[x] != NULL)
			{
				++numEnabledLights;
			}
		}

		// Note that it *is* possible to have a situation where NUM_ENABLED_LIGHTS is 0 and LIGHTING is 1
		D3DXMACRO lightCount = {0};
		lightCount.Name = "NUM_ENABLED_LIGHTS";
		lightCount.Definition = lightCountStr[numEnabledLights];
		defines.push_back(lightCount);

		D3DXMACRO lightingMacro = {0};
		lightingMacro.Name = "LIGHTING";
		lightingMacro.Definition = "1";
		defines.push_back(lightingMacro);

		if (state.currentRenderStates.renderStatesUnion.namedStates.specularEnable)
		{
			D3DXMACRO specularEnableMacro = {0};
			specularEnableMacro.Name = "D3DRS_SPECULARENABLE";
			specularEnableMacro.Definition = "1";
			defines.push_back(specularEnableMacro);
		}

		if (state.currentRenderStates.renderStatesUnion.namedStates.localViewer)
		{
			D3DXMACRO specularEnableMacro = {0};
			specularEnableMacro.Name = "D3DRS_LOCALVIEWER";
			specularEnableMacro.Definition = "1";
			defines.push_back(specularEnableMacro);
		}

		// LIGHTTYPE0 thru LIGHTTYPE7 (defined as strings D3DLIGHT_POINT, D3DLIGHT_SPOT, or D3DLIGHT_DIRECTIONAL)
		unsigned foundLightTypes = 0;
		for (unsigned y = 0; y < 8; ++y)
		{
			if (foundLightTypes < numEnabledLights)
			{
				const LightInfo* const thisLightInfo = state.enabledLightIndices[y];
				if (thisLightInfo)
				{
					D3DXMACRO lightNType = {0};
					lightNType.Name = lightTypesNamesStr[foundLightTypes++];
					lightNType.Definition = lightTypeStr[thisLightInfo->light.Type - 1]; // Minus one here because light types are 1-based instead of 0-based
					defines.push_back(lightNType);
				}
			}
		}
	}
	else
	{
		D3DXMACRO numEnabledLights = {0};
		numEnabledLights.Name = "NUM_ENABLED_LIGHTS";
		numEnabledLights.Definition = "0";
		defines.push_back(numEnabledLights);
	}

	// TEX0REMAP thru TEX7REMAP (defined as strings "tex0" thru "tex7" which remap indices for texcoord lookups)
	for (unsigned x = 0; x < 8; ++x)
	{
		const TextureStageState& thisStageState = state.currentStageStates[x];
		const UINT texCoordIndex = thisStageState.stageStateUnion.namedStates.texCoordIndex;
		const UINT targetIndex = LOWORD(texCoordIndex);
		const UINT texCoordGeneration = HIWORD(texCoordIndex);
		const D3DTEXTURETRANSFORMFLAGS transformFlags = thisStageState.stageStateUnion.namedStates.textureTransformFlags;

#ifdef _DEBUG
		if (targetIndex >= 8)
		{
			// Invalid texcoord remapping for the fixed-function vertex pipeline
			__debugbreak();
		}

		if (texCoordGeneration > D3DTSS_TCI_SPHEREMAP)
		{
			__debugbreak(); // Invalid texcoord generation method
		}
#endif

		D3DXMACRO texCoordGenerationType = {0};
		texCoordGenerationType.Name = texCoordGenerationTypeName[x];
		texCoordGenerationType.Definition = texCoordGenerationTypeString[texCoordGeneration];
		defines.push_back(texCoordGenerationType);

		if (texCoordGeneration == D3DTSS_TCI_PASSTHRU)
		{
			D3DXMACRO texCoordRemap = {0};
			texCoordRemap.Name = texRemapStrings[x];
			texCoordRemap.Definition = texRemapDefStrings[targetIndex % 8];
			defines.push_back(texCoordRemap);
		}

		// Texture matrix transforms take place after texcoord generation and texcoord remapping
		if (LOBYTE(transformFlags) != D3DTTFF_DISABLE)
		{
			D3DXMACRO texTransformEnable = {0};
			texTransformEnable.Name = texTransformStrings[x];
			texTransformEnable.Definition = "1";
			defines.push_back(texTransformEnable);
		}
	}

	BuildVertexDeclStateDefines(state.currentVertexDecl, defines);

	BuildOutputStateDefines(state, defines);

	if (!defines.empty() )
	{
		D3DXMACRO emptyLastMacro = {0};
		defines.push_back(emptyLastMacro);
	}
}

void BuildVertexShader(const DeviceState& state, IDirect3DDevice9Hook* const dev, IDirect3DVertexShader9Hook** const outNewShader)
{
#ifdef _DEBUG
	if (!outNewShader)
	{
		__debugbreak();
	}
#endif

	std::vector<D3DXMACRO> defines;
	BuildVertexStateDefines(state, defines);

	LPD3DXBUFFER outBytecode = NULL;
	LPD3DXBUFFER errorMessages = NULL;
	DWORD flags = D3DXSHADER_AVOID_FLOW_CONTROL | D3DXSHADER_PARTIALPRECISION; // Branching isn't currently well-supported in the software shader system
#ifdef _DEBUG
	flags |= D3DXSHADER_DEBUG;
#else
	flags |= D3DXSHADER_OPTIMIZATION_LEVEL3;
#endif

	HRESULT hr = E_FAIL;

	unsigned resourceSize = 0;
	const char* const resourceBytes = (const char* const)GetShaderResourceFile(MAKEINTRESOURCEA(IDR_HLSL_FFVS_SRC), resourceSize);
	if (resourceBytes != NULL)
	{
		hr = D3DXCompileShader( (const char* const)resourceBytes, resourceSize, defines.empty() ? NULL : &defines.front(), D3DXIncludeHandler::GetGlobalIncludeHandlerSingleton(), 
			"main", "vs_3_0", flags, &outBytecode, &errorMessages, NULL);
	}
	if (FAILED(hr) || !outBytecode)
	{
		const char* const errorMessage = errorMessages ? ( (const char* const)errorMessages->GetBufferPointer() ) : NULL;

		// Should never happen for fixed-function shaders!
		MessageBoxA(NULL, errorMessage, "Fixed Function VS Compile Failure!", MB_OK);
		__debugbreak();

		printf("%s", errorMessage); // Don't optimize this away

		return;
	}

#ifdef _DEBUG
	const char* const debugErrorMessage = errorMessages ? ( (const char* const)errorMessages->GetBufferPointer() ) : NULL;
	UNREFERENCED_PARAMETER(debugErrorMessage);
#endif

	IDirect3DVertexShader9* newVertexShader = NULL;
	if (FAILED(dev->CreateVertexShader( (const DWORD* const)outBytecode->GetBufferPointer(), &newVertexShader) ) || !newVertexShader)
	{
		// Should never happen for fixed-function shaders!
		__debugbreak();
	}

	IDirect3DVertexShader9Hook* newVertexShaderHook = dynamic_cast<IDirect3DVertexShader9Hook*>(newVertexShader);
	if (!newVertexShaderHook)
	{
		DbgBreakPrint("Error: CreateVertexShader returned a non-hooked pointer!");
	}

	newVertexShaderHook->GetModifyShaderInfo().fixedFunctionMacroDefines.swap(defines);

	*outNewShader = newVertexShaderHook;

	if (outBytecode)
	{
		outBytecode->Release();
		outBytecode = NULL;
	}
	if (errorMessages)
	{
		errorMessages->Release();
		errorMessages = NULL;
	}
}

static void SetFixedFunctionVertexShaderState_IndexedVertexBlendWorldViews(const Transforms& transforms, IDirect3DDevice9Hook* const dev)
{
	// This takes up quite a lot of stack-space, which is why it's broken out into its own function
	wvShaderMatrix indexedWorldViewBlendingMatrices[MAX_WORLD_TRANSFORMS];
	for (unsigned char x = 0; x < 4; ++x)
	{
		wvShaderMatrix& thisShaderWVMatrices = indexedWorldViewBlendingMatrices[x];
		thisShaderWVMatrices.worldView = transforms.GetWVTransformFromCache(x);
		thisShaderWVMatrices.invWorldView = transforms.GetInvWVTransformFromCache(x);
	}
	for (unsigned short x = 4; x < MAX_WORLD_TRANSFORMS; ++x)
	{
		wvShaderMatrix& thisShaderWVMatrices = indexedWorldViewBlendingMatrices[x];
		thisShaderWVMatrices.worldView = transforms.WorldTransforms[x] * transforms.ViewTransform;
		D3DXMatrixInverse(&thisShaderWVMatrices.invWorldView, NULL, &(thisShaderWVMatrices.worldView) );
	}
	for (unsigned short x = 0; x < MAX_WORLD_TRANSFORMS; ++x)
	{
		dev->SetVertexShaderConstantF(WORLDVIEW_TRANSFORM_REGISTERS + 7 * x, (const float* const)&(indexedWorldViewBlendingMatrices[x]), 7);
	}
}

void SetFixedFunctionVertexShaderState(const DeviceState& state, IDirect3DDevice9Hook* const dev)
{
	const Transforms& transforms = state.currentTransforms;

	// WVP transform:
	const D3DXMATRIXA16& wvpTransform = transforms.GetWVPTransform();
	dev->SetVertexShaderConstantF(WVP_REGISTERS, (const float* const)&(wvpTransform), 4);

	const RenderStates::_renderStatesUnion::_namedStates& namedRenderStates = state.currentRenderStates.renderStatesUnion.namedStates;

	// Vertex tweening factor
	const D3DXVECTOR4 tweenFactor(namedRenderStates.tweenFactor, 0.0f, 0.0f, 0.0f);
	dev->SetVertexShaderConstantF(TWEENFACTOR_REGISTER, &tweenFactor.x, 1);

	// Point Scale
	const D3DXVECTOR4 pointScaleParams(namedRenderStates.pointScale_A, namedRenderStates.pointScale_B, namedRenderStates.pointScale_C, 0.0f);
	dev->SetVertexShaderConstantF(POINTSCALEPARAMS_REGISTER, &pointScaleParams.x, 1);
	const D3DXVECTOR4 pointScaleData(namedRenderStates.pointSize_Max, namedRenderStates.pointSize_Min, namedRenderStates.pointSize, state.cachedViewport.fHeight);
	dev->SetVertexShaderConstantF(POINTSCALEDATA_REGISTER, &pointScaleData.x, 1);

	// Fog
	const D3DXVECTOR4 fogData(namedRenderStates.fogStart, namedRenderStates.fogEnd, namedRenderStates.fogDensity, 0.0f);
	dev->SetVertexShaderConstantF(FOGDATA_REGISTER, &fogData.x, 1);

	// Material data (with specular power packed into specular.a)
	const D3DXVECTOR4 packedMaterialData[4] =
	{
		*(const D3DXVECTOR4* const)&(state.currentMaterial.Diffuse),
		D3DXVECTOR4(state.currentMaterial.Specular.r, state.currentMaterial.Specular.g, state.currentMaterial.Specular.b, state.currentMaterial.Power),
		*(const D3DXVECTOR4* const)&(state.currentMaterial.Ambient),
		*(const D3DXVECTOR4* const)&(state.currentMaterial.Emissive)
	};
	dev->SetVertexShaderConstantF(MATERIALDATA_REGISTERS, (const float* const)&packedMaterialData, 4);

	// Ambient color
	D3DXVECTOR4 ambient;
	ColorDWORDToFloat4<0xF>(namedRenderStates.ambient, ambient);
	dev->SetVertexShaderConstantF(AMBIENT_REGISTER, &ambient.x, 1);

	// Texture transform matrices (8 4x4 matrices):
	dev->SetVertexShaderConstantF(TEXCOORD_TRANSFORM_REGISTERS, (const float* const)&(transforms.TextureTransforms), 4 * D3DDP_MAXTEXCOORD);

	// Light data:
	if (namedRenderStates.lighting && state.enabledLightIndices[0] != NULL)
	{
		D3DXMATRIXA16 inverseViewMat, invTransposeViewMat;
		D3DXMatrixInverse(&inverseViewMat, NULL, &transforms.ViewTransform);
		D3DXMatrixTranspose(&invTransposeViewMat, &inverseViewMat);
		shaderPackedLight enabledLights[8];
		for (unsigned char enabledLightIndex = 0; enabledLightIndex < 8; ++enabledLightIndex)
		{
			const LightInfo* const enabledLight = state.enabledLightIndices[enabledLightIndex];
			if (!enabledLight)
				break;

			const D3DLIGHT9& lightInfo = enabledLight->light;

			shaderPackedLight& thisPackedLight = enabledLights[enabledLightIndex];
			thisPackedLight.Diffuse = lightInfo.Diffuse;
			thisPackedLight.Specular = lightInfo.Specular;
			thisPackedLight.Ambient = lightInfo.Ambient;
			float range = lightInfo.Range;
			if (range < 0.0f)
				range = 0.0f;
			else if (range > sqrtf(FLT_MAX) )
				range = sqrtf(FLT_MAX);
			D3DXVECTOR3 transformedPosition;
			D3DXVec3TransformCoord(&transformedPosition, (const D3DXVECTOR3* const)&lightInfo.Position, &transforms.ViewTransform);
			thisPackedLight.Position_Range = D3DXVECTOR4(transformedPosition.x, transformedPosition.y, transformedPosition.z, range);
			D3DXVECTOR3 normalizedDirection, viewspaceNormalizedDirection;
			D3DXVec3Normalize(&normalizedDirection, (const D3DXVECTOR3* const)&lightInfo.Direction);
			D3DXVec3TransformNormal(&viewspaceNormalizedDirection, &normalizedDirection, &invTransposeViewMat);
			thisPackedLight.Direction_Falloff = D3DXVECTOR4(viewspaceNormalizedDirection.x, viewspaceNormalizedDirection.y, viewspaceNormalizedDirection.z, lightInfo.Falloff);
			
			float phi = lightInfo.Phi;
			if (phi < 0.0f)
				phi = 0.0f;
			else if (phi > M_PI)
				phi = M_PI;

			float theta = lightInfo.Theta;
			if (theta < 0.0f)
				theta = 0.0f;
			else if (theta > phi)
				theta = phi;

			const float halfThetaStrength = cosf(theta * 0.5f);
			const float halfPhiStrength = cosf(phi * 0.5f);

			thisPackedLight.Attenuation = D3DXVECTOR4(lightInfo.Attenuation0, lightInfo.Attenuation1, lightInfo.Attenuation2, 1.0f / (halfThetaStrength - halfPhiStrength) );

			thisPackedLight.SpotLightParams = D3DXVECTOR4(phi, theta, halfThetaStrength, halfPhiStrength);
		}
		dev->SetVertexShaderConstantF(LIGHTDATA_REGISTERS, (const float* const)&enabledLights, 7 * 8);
	}

	// Forwards projection matrix ("p matrix")
	dev->SetVertexShaderConstantF(PROJMATRIX_REGISTERS, (const float* const)&(transforms.ProjectionTransform), 4);

	// World-view matrices:
	if (namedRenderStates.indexedVertexBlendEnable)
	{
		SetFixedFunctionVertexShaderState_IndexedVertexBlendWorldViews(transforms, dev);
	}
	else
	{
		for (unsigned char x = 0; x < 4; ++x)
		{
			wvShaderMatrix thisShaderWVMatrices;
			thisShaderWVMatrices.worldView = transforms.GetWVTransformFromCache(x);
			thisShaderWVMatrices.invWorldView = transforms.GetInvWVTransformFromCache(x);
			dev->SetVertexShaderConstantF(WORLDVIEW_TRANSFORM_REGISTERS + 7 * x, (const float* const)&thisShaderWVMatrices, 7);
		}
	}
}

```

`Software_d3d9/GlobalToggles.h`:

```h
#pragma once

// Uncomment to disable fixed function shader caching
// #define NO_CACHING_FIXED_FUNCTION_SHADERS 1

// Uncomment to disable FVF vertex decl caching
// #define NO_CACHING_FVF_VERT_DECLS 1

// Uncomment this line for debugging vertex shader engines:
// Note that if the JIT pixel shader fails to compile, the renderer will still fall back to using the interpreter pixel shader engine regardless of this setting
// #define FORCE_INTERPRETED_VERTEX_SHADER 1

// Uncomment this line for debugging pixel shader engines:
// Note that if the JIT pixel shader fails to compile, the renderer will still fall back to using the interpreter pixel shader engine regardless of this setting
// #define FORCE_INTERPRETED_PIXEL_SHADER 1

// Comment out to disable
// #define DUMP_TEXTURES_ON_FIRST_SET 1

// Comment out to disable
// #define COMPUTE_SURFACE_HASHES_FOR_DEBUGGING 1

// Commment this out to enable "fully correct" gamma correction calculations
#define USE_CHEAP_GAMMA_APPROXIMATION 1

// Comment out to disable
#ifdef _DEBUG
// #define DEBUG_VERTEX_OUT_POSITIONS 1
#endif

// Uncomment to enable showing the shader compilation window when compiling (does not play nicely with fullscreen windows)
// #define DEBUG_SHOW_SHADERCOMPILE_WINDOW 1

// These are useful for debugging: Forcing windowed mode, and forcing no VSync
#ifdef _DEBUG
	#define OVERRIDE_FORCE_WINDOWED_MODE 1
#endif
#define OVERRIDE_FORCE_NO_VSYNC 1
#ifdef _DEBUG
	#define OVERRIDE_FORCE_NO_VSYNC 1
#endif
#define OVERRIDE_HIDE_CURSOR 1

// If this is not defined, all shaders will run in solo threads rather than warps (usually of at least 2x2 pixels or vertices)
#define RUN_SHADERS_IN_WARPS 1

// Defines for different kinds of parallel libraries
#define PARALLELLIB_CONCRT 1
#define PARALLELLIB_TBB 2

// Use this define to set which parallel library to use (ConcRT or TBB are currently supported):
#define PARALLEL_LIBRARY PARALLELLIB_CONCRT

// Comment this line out to disable multithread shading
#define MULTITHREAD_SHADING 1

// Comment these out to disable shader execution profiling
#ifndef MULTITHREAD_SHADING
	//#define PROFILE_AVERAGE_VERTEX_SHADE_TIMES 1
	//#define PROFILE_AVERAGE_PIXEL_SHADE_TIMES 1
#endif

// If defined, the software renderer will improve the system's scheduler resolution (which is useful when running many threads in the job system).
// This increase only lasts as long as the process is running, and the default scheduler resolution will be applied when the process terminates.
#ifdef MULTITHREAD_SHADING
	#define INCREASE_SYSTEM_SCHEDULER_RESOLUTION 1
#endif

#ifdef MULTITHREAD_SHADING
	#define TRIANGLEJOBS 1
	#define PIXELJOBS 2
	#define TRIANGLEJOBS_OR_PIXELJOBS PIXELJOBS
#endif

// Comment out to disable
//#define INDEX_BUFFER_MAGIC_COOKIE 1

// Comment out to disable
//#define VERTEX_BUFFER_MAGIC_COOKIE 1

// Comment out to disable
//#define SURFACE_MAGIC_COOKIE 1

// Comment out to disable printing when D3D hook objects are fully released (deleted)
#define DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES 1

// Comment out to disable memset'ing a D3DHook object after it's destructed
#define WIPE_ON_DESTRUCT_D3DHOOKOBJECT 1

// Comment out to use a more efficient allocator for surface alloc. Leave uncommented for a safer way to make sure reads and writes don't go past the end of the surface
#ifndef SURFACE_MAGIC_COOKIE
	//#define SURFACE_ALLOC_PAGE_NOACCESS 1
#endif

// If defined, this will wipe surfaces when D3DLOCK_DISCARD is specified during a LockRect operation
#ifdef _DEBUG
	#define SURFACE_ENFORCE_DISCARD_ON_LOCK 1
#endif

// Comment out to use a more efficient allocator for vertex buffer alloc. Leave uncommented for a safer way to make sure reads and writes don't go past the end of the buffer
#ifndef VERTEX_BUFFER_MAGIC_COOKIE
	//#define VERTEX_BUFFER_ALLOC_PAGE_NOACCESS 1
#endif

// If defined, this will force vertex buffer data to be made read-only after Unlock() is called
#ifdef VERTEX_BUFFER_ALLOC_PAGE_NOACCESS
	//#define VERTEX_BUFFER_ENFORCE_READONLY_WHILE_UNLOCKED 1
#endif

// If defined, this will wipe vertex buffers when D3DLOCK_DISCARD is specified during a Lock operation
#ifdef _DEBUG
	#define VERTEX_BUFFER_ENFORCE_DISCARD_ON_LOCK 1
#endif

// Comment out to use a more efficient allocator for index buffer alloc. Leave uncommented for a safer way to make sure reads and writes don't go past the end of the buffer
#ifndef INDEX_BUFFER_MAGIC_COOKIE
	//#define INDEX_BUFFER_ALLOC_PAGE_NOACCESS 1
#endif

// If defined, this will force index buffer data to be made read-only after Unlock() is called
#ifdef INDEX_BUFFER_ALLOC_PAGE_NOACCESS
	//#define INDEX_BUFFER_ENFORCE_READONLY_WHILE_UNLOCKED 1
#endif

// If defined, this will wipe index buffers when D3DLOCK_DISCARD is specified during a Lock operation
#ifdef _DEBUG
	#define INDEX_BUFFER_ENFORCE_DISCARD_ON_LOCK 1
#endif

// Uncomment this to enable holding the "END" key to skip draw calls (very useful in debug mode where draw calls can take a very long time to complete)
#define ENABLE_END_TO_SKIP_DRAWS 1

// Comment this out to allow the early Z testing optimization
//#define DISALLOW_EARLY_Z_TESTING 1

```

`Software_d3d9/IDirect3D9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3D9Hook.h"

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj) 
{
	HRESULT ret = d3d9->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3D9Hook::AddRef(THIS) 
{
	ULONG ret = d3d9->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3D9Hook::Release(THIS) 
{
	ULONG ret = d3d9->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked D3D9 %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::RegisterSoftwareDevice(THIS_ void* pInitializeFunction) 
{
	HRESULT ret = d3d9->RegisterSoftwareDevice(pInitializeFunction);
	return ret;
}

COM_DECLSPEC_NOTHROW UINT STDMETHODCALLTYPE IDirect3D9Hook::GetAdapterCount(THIS)
{
	UINT ret = d3d9->GetAdapterCount();
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::GetAdapterIdentifier(THIS_ UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER9* pIdentifier) 
{
	HRESULT ret = d3d9->GetAdapterIdentifier(Adapter, Flags, pIdentifier);
	return ret;
}

COM_DECLSPEC_NOTHROW UINT STDMETHODCALLTYPE IDirect3D9Hook::GetAdapterModeCount(THIS_ UINT Adapter, D3DFORMAT Format)
{
	UINT ret = d3d9->GetAdapterModeCount(Adapter, Format);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::EnumAdapterModes(THIS_ UINT Adapter, D3DFORMAT Format, UINT Mode, D3DDISPLAYMODE* pMode)
{
	HRESULT ret = d3d9->EnumAdapterModes(Adapter, Format, Mode, pMode);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::GetAdapterDisplayMode(THIS_ UINT Adapter, D3DDISPLAYMODE* pMode)
{
	HRESULT ret = d3d9->GetAdapterDisplayMode(Adapter, pMode);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::CheckDeviceType(THIS_ UINT Adapter, D3DDEVTYPE DevType, D3DFORMAT AdapterFormat, D3DFORMAT BackBufferFormat, BOOL bWindowed)
{
	HRESULT ret = d3d9->CheckDeviceType(Adapter, DevType, AdapterFormat, BackBufferFormat, bWindowed);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::CheckDeviceFormat(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat)
{
	HRESULT ret = d3d9->CheckDeviceFormat(Adapter, DeviceType, AdapterFormat, Usage, RType, CheckFormat);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::CheckDeviceMultiSampleType(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType, DWORD* pQualityLevels)
{
	HRESULT ret = d3d9->CheckDeviceMultiSampleType(Adapter, DeviceType, SurfaceFormat, Windowed, MultiSampleType, pQualityLevels);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::CheckDepthStencilMatch(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat)
{
	HRESULT ret = d3d9->CheckDepthStencilMatch(Adapter, DeviceType, AdapterFormat, RenderTargetFormat, DepthStencilFormat);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::CheckDeviceFormatConversion(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SourceFormat, D3DFORMAT TargetFormat)
{
	HRESULT ret = d3d9->CheckDeviceFormatConversion(Adapter, DeviceType, SourceFormat, TargetFormat);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::GetDeviceCaps(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS9* pCaps)
{
	HRESULT ret = d3d9->GetDeviceCaps(Adapter, DeviceType, pCaps);
	if (FAILED(ret) )
		return ret;

	if (pCaps && DeviceType == D3DDEVTYPE_HAL)
	{
		IDirect3DDevice9Hook::ModifyDeviceCaps(*pCaps);
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HMONITOR STDMETHODCALLTYPE IDirect3D9Hook::GetAdapterMonitor(THIS_ UINT Adapter)
{
	HMONITOR ret = d3d9->GetAdapterMonitor(Adapter);
	return ret;
}

static inline const char* const GetBackbufferFormatString(const D3DFORMAT fmt)
{
	// These are the valid backbuffer surface formats for D3D9
	switch (fmt)
	{
	case D3DFMT_A2R10G10B10:
		return "D3DFMT_A2R10G10B10";
	case D3DFMT_A8R8G8B8:
		return "D3DFMT_A8R8G8B8";
	case D3DFMT_X8R8G8B8:
		return "D3DFMT_X8R8G8B8";
	case D3DFMT_A1R5G5B5:
		return "D3DFMT_A1R5G5B5";
	case D3DFMT_X1R5G5B5:
		return "D3DFMT_X1R5G5B5";
	case D3DFMT_R5G6B5:
		return "D3DFMT_R5G6B5";
	default:
		return "Unknown";
	}
}

static inline const char* const GetDepthbufferFormatString(const D3DFORMAT fmt)
{
	switch (fmt)
	{
	case D3DFMT_D16_LOCKABLE:
		return "D3DFMT_D16_LOCKABLE";
	case D3DFMT_D32:
		return "D3DFMT_D32";
	case D3DFMT_D15S1:
		return "D3DFMT_D15S1";
	case D3DFMT_D24S8:
		return "D3DFMT_D24S8";
	case D3DFMT_D24X8:
		return "D3DFMT_D24X8";
	case D3DFMT_D24X4S4:
		return "D3DFMT_D24X4S4";
	case D3DFMT_D32F_LOCKABLE:
		return "D3DFMT_D32F_LOCKABLE";
	case D3DFMT_D24FS8:
		return "D3DFMT_D24FS8";
	case D3DFMT_D32_LOCKABLE:
		return "D3DFMT_D32_LOCKABLE";
	case D3DFMT_S8_LOCKABLE:
		return "D3DFMT_S8_LOCKABLE";
	case D3DFMT_D16:
		return "D3DFMT_D16";
	default:
		return "Unknown";
	}
}

static inline const char* const GetDeviceTypeString(const D3DDEVTYPE DeviceType)
{
	switch (DeviceType)
	{
	case D3DDEVTYPE_HAL:
		return "D3DDEVTYPE_HAL";
	case D3DDEVTYPE_REF:
		return "D3DDEVTYPE_REF";
	case D3DDEVTYPE_SW:
		return "D3DDEVTYPE_SW";
	case D3DDEVTYPE_NULLREF:
		return "D3DDEVTYPE_NULLREF";
	default:
		return "Unknown";
	}
}

static const DWORD BehaviorCreateFlags[] =
{
	D3DCREATE_ADAPTERGROUP_DEVICE,
	D3DCREATE_DISABLE_DRIVER_MANAGEMENT,
	D3DCREATE_DISABLE_DRIVER_MANAGEMENT_EX,
	D3DCREATE_DISABLE_PRINTSCREEN,
	D3DCREATE_DISABLE_PSGP_THREADING,
	D3DCREATE_ENABLE_PRESENTSTATS,
	D3DCREATE_FPU_PRESERVE,
	D3DCREATE_HARDWARE_VERTEXPROCESSING,
	D3DCREATE_MIXED_VERTEXPROCESSING,
	D3DCREATE_SOFTWARE_VERTEXPROCESSING,
	D3DCREATE_MULTITHREADED,
	D3DCREATE_NOWINDOWCHANGES,
	D3DCREATE_PUREDEVICE,
	D3DCREATE_SCREENSAVER
};

static const char* const BehaviorCreateFlagStrings[] =
{
	"D3DCREATE_ADAPTERGROUP_DEVICE",
	"D3DCREATE_DISABLE_DRIVER_MANAGEMENT",
	"D3DCREATE_DISABLE_DRIVER_MANAGEMENT_EX",
	"D3DCREATE_DISABLE_PRINTSCREEN",
	"D3DCREATE_DISABLE_PSGP_THREADING",
	"D3DCREATE_ENABLE_PRESENTSTATS",
	"D3DCREATE_FPU_PRESERVE",
	"D3DCREATE_HARDWARE_VERTEXPROCESSING",
	"D3DCREATE_MIXED_VERTEXPROCESSING",
	"D3DCREATE_SOFTWARE_VERTEXPROCESSING",
	"D3DCREATE_MULTITHREADED",
	"D3DCREATE_NOWINDOWCHANGES",
	"D3DCREATE_PUREDEVICE",
	"D3DCREATE_SCREENSAVER"
};

static inline const char* const StaticGetDeviceBehaviorFlagsString(const DWORD BehaviorFlags)
{
	static char staticBuffer[512] = {0};
	bool hasBehaviorFlags = false;
	for (unsigned x = 0; x < ARRAYSIZE(BehaviorCreateFlags); ++x)
	{
		if (BehaviorFlags & BehaviorCreateFlags[x])
		{
#pragma warning(push)
#pragma warning(disable:4996)
			if (hasBehaviorFlags)
				strcat(staticBuffer, " | ");
			strcat(staticBuffer, BehaviorCreateFlagStrings[x]);
#pragma warning(pop)
			hasBehaviorFlags = true;
		}
	}
	return staticBuffer;
}

static inline const char* const SwapEffectToString(const D3DSWAPEFFECT SwapEffect)
{
	switch (SwapEffect)
	{
	case D3DSWAPEFFECT_DISCARD:
		return "D3DSWAPEFFECT_DISCARD";
	case D3DSWAPEFFECT_FLIP:
		return "D3DSWAPEFFECT_FLIP";
	case D3DSWAPEFFECT_COPY:
		return "D3DSWAPEFFECT_COPY";
	case D3DSWAPEFFECT_OVERLAY:
		return "D3DSWAPEFFECT_OVERLAY";
	case D3DSWAPEFFECT_FLIPEX:
		return "D3DSWAPEFFECT_FLIPEX";
	default:
		return "Unknown";
	}
}

static const DWORD PresentFlags[] =
{
	D3DPRESENTFLAG_LOCKABLE_BACKBUFFER,
	D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL,
	D3DPRESENTFLAG_DEVICECLIP,
	D3DPRESENTFLAG_VIDEO,
	D3DPRESENTFLAG_NOAUTOROTATE,
	D3DPRESENTFLAG_UNPRUNEDMODE,
	D3DPRESENTFLAG_OVERLAY_LIMITEDRGB,
	D3DPRESENTFLAG_OVERLAY_YCbCr_BT709,
	D3DPRESENTFLAG_OVERLAY_YCbCr_xvYCC,
	D3DPRESENTFLAG_RESTRICTED_CONTENT,
	D3DPRESENTFLAG_RESTRICT_SHARED_RESOURCE_DRIVER
};

static const char* const PresentFlagStrings[] =
{
	"D3DPRESENTFLAG_LOCKABLE_BACKBUFFER",
	"D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL",
	"D3DPRESENTFLAG_DEVICECLIP",
	"D3DPRESENTFLAG_VIDEO",
	"D3DPRESENTFLAG_NOAUTOROTATE",
	"D3DPRESENTFLAG_UNPRUNEDMODE",
	"D3DPRESENTFLAG_OVERLAY_LIMITEDRGB",
	"D3DPRESENTFLAG_OVERLAY_YCbCr_BT709",
	"D3DPRESENTFLAG_OVERLAY_YCbCr_xvYCC",
	"D3DPRESENTFLAG_RESTRICTED_CONTENT",
	"D3DPRESENTFLAG_RESTRICT_SHARED_RESOURCE_DRIVER"
};

static inline const char* const StaticGetPresentFlagsString(const DWORD Flagss)
{
	static char staticBuffer[512] = {0};
	bool hasPresentFlags = false;
	for (unsigned x = 0; x < ARRAYSIZE(PresentFlags); ++x)
	{
		if (Flagss & PresentFlags[x])
		{
#pragma warning(push)
#pragma warning(disable:4996)
			if (hasPresentFlags)
				strcat(staticBuffer, " | ");
			strcat(staticBuffer, PresentFlagStrings[x]);
#pragma warning(pop)
			hasPresentFlags = true;
		}
	}
	return staticBuffer;
}

static inline const char* const GetPresentationIntervalString(const UINT PresentInterval)
{
	switch (PresentInterval)
	{
	case D3DPRESENT_INTERVAL_DEFAULT:
		return "D3DPRESENT_INTERVAL_DEFAULT";
	case D3DPRESENT_INTERVAL_ONE:
		return "D3DPRESENT_INTERVAL_ONE";
	case D3DPRESENT_INTERVAL_TWO:
		return "D3DPRESENT_INTERVAL_TWO";
	case D3DPRESENT_INTERVAL_THREE:
		return "D3DPRESENT_INTERVAL_THREE";
	case D3DPRESENT_INTERVAL_FOUR:
		return "D3DPRESENT_INTERVAL_FOUR";
	case D3DPRESENT_INTERVAL_IMMEDIATE:
		return "D3DPRESENT_INTERVAL_IMMEDIATE";
	default:
		return "Unknown";
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3D9Hook::CreateDevice(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, 
		DWORD BehaviorFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DDevice9** ppReturnedDeviceInterface)
{
	D3DPRESENT_PARAMETERS modifiedParams = *pPresentationParameters;
	IDirect3DDevice9Hook::ModifyPresentParameters(modifiedParams);

#ifdef _DEBUG
	if (!(BehaviorFlags & (D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_MIXED_VERTEXPROCESSING) ) )
	{
		// At least one of Hardware, Software, or Mixed must be specified on device-creation!
		DbgBreakPrint("Error: At least one of Hardware, Software, or Mixed must be specified at device-creation time!");
	}
	if (__popcnt(BehaviorFlags & (D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_MIXED_VERTEXPROCESSING) ) > 1)
	{
		// Only one of Hardware, Software, or Mixed is allowed to be specified
		DbgBreakPrint("Error: Only one of Hardware, Software, or Mixed must be specified at device-creation time!");
	}
#endif

	LPDIRECT3DDEVICE9 realDevice = NULL;
	HRESULT ret = d3d9->CreateDevice(Adapter, DeviceType, hFocusWindow, BehaviorFlags, &modifiedParams, &realDevice);
	if (FAILED(ret) || !realDevice)
	{
		*ppReturnedDeviceInterface = NULL;
		MessageBoxA(NULL, "Failed createdevice", NULL, MB_OK);
		return ret;
	}

	{
#pragma warning(push)
#pragma warning(disable:4996)
		char adapterString[32] = {0};
		if (Adapter == D3DADAPTER_DEFAULT)
			strcpy(adapterString, "D3DADAPTER_DEFAULT (0)");
		else
			sprintf(adapterString, "%u", Adapter);
		char createDeviceSettings[4096] = {0};
		sprintf(createDeviceSettings, "CreateDevice params:\n\tAdapter = %s\n\tDeviceType = %s\n\tBehaviorFlags = 0x%08X (%s)\n\tppBackBufferWidth = %u\n\tppBackBufferHeight = %u\n\tppBackBufferFormat = %s(%i)\n\tppBackBufferCount = %u\n\tppMultiSampleType = %u\n\tppMultiSampleQuality = %u\n\tppSwapEffect = %s\n\tppWindowed = %s\n\tppEnableAutoDepthStencil = %s\n\tppAutoDepthStencilFormat = %s (%i)\n\tppFlags = 0x%08X (%s)\n\tppFullScreen_RefreshRateInHz = %u\n\tppPresentationInterval = %s (%u)\n\n",
			adapterString, GetDeviceTypeString(DeviceType), BehaviorFlags, StaticGetDeviceBehaviorFlagsString(BehaviorFlags), modifiedParams.BackBufferWidth, modifiedParams.BackBufferHeight, GetBackbufferFormatString(modifiedParams.BackBufferFormat), modifiedParams.BackBufferFormat, modifiedParams.BackBufferCount, modifiedParams.MultiSampleType, modifiedParams.MultiSampleQuality, SwapEffectToString(modifiedParams.SwapEffect), modifiedParams.Windowed ? "TRUE" : "FALSE", modifiedParams.EnableAutoDepthStencil ? "TRUE" : "FALSE", GetDepthbufferFormatString(modifiedParams.AutoDepthStencilFormat), modifiedParams.AutoDepthStencilFormat, modifiedParams.Flags, StaticGetPresentFlagsString(modifiedParams.Flags), modifiedParams.FullScreen_RefreshRateInHz, GetPresentationIntervalString(modifiedParams.PresentationInterval), modifiedParams.PresentationInterval);
#pragma warning(pop)
		OutputDebugStringA(createDeviceSettings);
		MessageBoxA(NULL, createDeviceSettings, "CreateDevice success", NULL);
	}

	void* const alignedAlloc = _aligned_malloc(sizeof(IDirect3DDevice9Hook), 16);
	IDirect3DDevice9Hook* newHookDevice = new (alignedAlloc) IDirect3DDevice9Hook(realDevice, this);
	*ppReturnedDeviceInterface = newHookDevice;
	newHookDevice->InitializeState(modifiedParams, DeviceType, BehaviorFlags, hFocusWindow);

	return ret;
}

```

`Software_d3d9/IDirect3D9Hook.h`:

```h
#pragma once

#include "d3d9include.h"

#include <stddef.h> // for offsetof

#include "IDirect3DDevice9Hook.h"

class IDirect3D9Hook : public IDirect3D9
{
public:
	IDirect3D9Hook(LPDIRECT3D9 _d3d9) : d3d9(_d3d9), refCount(1)
	{
#ifdef _DEBUG
		memcpy(&Version, &d3d9->Version, (char*)&d3d9 - (char*)&Version);
#endif
	}

	inline LPDIRECT3D9 GetUnderlyingD3D9(void) const
	{
		return d3d9;
	}

	virtual ~IDirect3D9Hook()
	{
		d3d9 = NULL;
		refCount = 0;
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3D9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RegisterSoftwareDevice(THIS_ void* pInitializeFunction) override;
    virtual COM_DECLSPEC_NOTHROW UINT STDMETHODCALLTYPE GetAdapterCount(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAdapterIdentifier(THIS_ UINT Adapter,DWORD Flags,D3DADAPTER_IDENTIFIER9* pIdentifier) override;
    virtual COM_DECLSPEC_NOTHROW UINT STDMETHODCALLTYPE GetAdapterModeCount(THIS_ UINT Adapter,D3DFORMAT Format) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnumAdapterModes(THIS_ UINT Adapter,D3DFORMAT Format,UINT Mode,D3DDISPLAYMODE* pMode) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAdapterDisplayMode(THIS_ UINT Adapter,D3DDISPLAYMODE* pMode) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CheckDeviceType(THIS_ UINT Adapter,D3DDEVTYPE DevType,D3DFORMAT AdapterFormat,D3DFORMAT BackBufferFormat,BOOL bWindowed) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CheckDeviceFormat(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,DWORD Usage,D3DRESOURCETYPE RType,D3DFORMAT CheckFormat) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CheckDeviceMultiSampleType(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT SurfaceFormat,BOOL Windowed,D3DMULTISAMPLE_TYPE MultiSampleType,DWORD* pQualityLevels) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CheckDepthStencilMatch(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,D3DFORMAT RenderTargetFormat,D3DFORMAT DepthStencilFormat) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CheckDeviceFormatConversion(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT SourceFormat,D3DFORMAT TargetFormat) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDeviceCaps(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS9* pCaps) override;
    virtual COM_DECLSPEC_NOTHROW HMONITOR STDMETHODCALLTYPE GetAdapterMonitor(THIS_ UINT Adapter) override;

	virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateDevice(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, 
		DWORD BehaviorFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DDevice9** ppReturnedDeviceInterface) override;

protected:
	LPDIRECT3D9 d3d9;
	unsigned __int64 refCount;
};

```

`Software_d3d9/IDirect3DBaseTexture9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DBaseTexture9Hook.h"

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Base Texture %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DResource9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags)
{
	HRESULT ret = realObject->SetPrivateData(refguid, pData, SizeOfData, Flags);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData)
{
	HRESULT ret = realObject->GetPrivateData(refguid, pData, pSizeOfData);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::FreePrivateData(THIS_ REFGUID refguid)
{
	HRESULT ret = realObject->FreePrivateData(refguid);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::SetPriority(THIS_ DWORD PriorityNew)
{
	DWORD ret = realObject->SetPriority(PriorityNew);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::GetPriority(THIS)
{
	DWORD ret = realObject->GetPriority();
	return ret;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::PreLoad(THIS)
{
	realObject->PreLoad();
}

COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::GetType(THIS)
{
	D3DRESOURCETYPE ret = realObject->GetType();
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::SetLOD(THIS_ DWORD LODNew)
{
	DWORD ret = realObject->SetLOD(LODNew);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::GetLOD(THIS)
{
	DWORD ret = realObject->GetLOD();
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::GetLevelCount(THIS)
{
	DWORD ret = realObject->GetLevelCount();
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::SetAutoGenFilterType(THIS_ D3DTEXTUREFILTERTYPE FilterType)
{
	HRESULT ret = realObject->SetAutoGenFilterType(FilterType);
	return ret;
}

COM_DECLSPEC_NOTHROW D3DTEXTUREFILTERTYPE STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::GetAutoGenFilterType(THIS)
{
	D3DTEXTUREFILTERTYPE ret = realObject->GetAutoGenFilterType();
	return ret;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DBaseTexture9Hook::GenerateMipSubLevels(THIS)
{
	realObject->GenerateMipSubLevels();
}

```

`Software_d3d9/IDirect3DBaseTexture9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

class IDirect3DBaseTexture9Hook : public IDirect3DBaseTexture9
{
public:

	IDirect3DBaseTexture9Hook(LPDIRECT3DBASETEXTURE9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1)
	{
	}

	virtual ~IDirect3DBaseTexture9Hook()
	{
		realObject = NULL;
		parentDevice = NULL;
		refCount = 0;
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DResource9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreePrivateData(THIS_ REFGUID refguid) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetPriority(THIS_ DWORD PriorityNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetPriority(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE PreLoad(THIS) override;
    virtual COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE GetType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetLOD(THIS_ DWORD LODNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetLOD(THIS) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetLevelCount(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetAutoGenFilterType(THIS_ D3DTEXTUREFILTERTYPE FilterType) override;
    virtual COM_DECLSPEC_NOTHROW D3DTEXTUREFILTERTYPE STDMETHODCALLTYPE GetAutoGenFilterType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE GenerateMipSubLevels(THIS) override;

	inline LPDIRECT3DBASETEXTURE9 GetUnderlyingBaseTexture(void) const
	{
		return realObject;
	}

protected:
	LPDIRECT3DBASETEXTURE9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;
};

```

`Software_d3d9/IDirect3DCubeTexture9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DCubeTexture9Hook.h"

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Cube Texture %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DBaseTexture9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags)
{
	HRESULT ret = realObject->SetPrivateData(refguid, pData, SizeOfData, Flags);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData)
{
	HRESULT ret = realObject->GetPrivateData(refguid, pData, pSizeOfData);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::FreePrivateData(THIS_ REFGUID refguid)
{
	HRESULT ret = realObject->FreePrivateData(refguid);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::SetPriority(THIS_ DWORD PriorityNew)
{
	DWORD ret = realObject->SetPriority(PriorityNew);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::GetPriority(THIS)
{
	DWORD ret = realObject->GetPriority();
	return ret;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::PreLoad(THIS)
{
	realObject->PreLoad();
}

COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::GetType(THIS)
{
	D3DRESOURCETYPE ret = realObject->GetType();
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::SetLOD(THIS_ DWORD LODNew)
{
	DWORD ret = realObject->SetLOD(LODNew);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::GetLOD(THIS)
{
	DWORD ret = realObject->GetLOD();
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::GetLevelCount(THIS)
{
	DWORD ret = realObject->GetLevelCount();
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::SetAutoGenFilterType(THIS_ D3DTEXTUREFILTERTYPE FilterType)
{
	HRESULT ret = realObject->SetAutoGenFilterType(FilterType);
	return ret;
}

COM_DECLSPEC_NOTHROW D3DTEXTUREFILTERTYPE STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::GetAutoGenFilterType(THIS)
{
	D3DTEXTUREFILTERTYPE ret = realObject->GetAutoGenFilterType();
	return ret;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::GenerateMipSubLevels(THIS)
{
	realObject->GenerateMipSubLevels();

	if (!(InternalUsage & D3DUSAGE_AUTOGENMIPMAP) )
		return;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::GetLevelDesc(THIS_ UINT Level,D3DSURFACE_DESC *pDesc)
{
	HRESULT ret = realObject->GetLevelDesc(Level, pDesc);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::GetCubeMapSurface(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,IDirect3DSurface9** ppCubeMapSurface)
{
	HRESULT ret = realObject->GetCubeMapSurface(FaceType, Level, ppCubeMapSurface);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::LockRect(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags)
{
	HRESULT ret = realObject->LockRect(FaceType, Level, pLockedRect, pRect, Flags);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::UnlockRect(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level)
{
	HRESULT ret = realObject->UnlockRect(FaceType, Level);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DCubeTexture9Hook::AddDirtyRect(THIS_ D3DCUBEMAP_FACES FaceType,CONST RECT* pDirtyRect)
{
	HRESULT ret = realObject->AddDirtyRect(FaceType, pDirtyRect);
	return ret;
}

void IDirect3DCubeTexture9Hook::CreateCubeTexture(UINT _EdgeLength, UINT _Levels, DebuggableUsage _Usage, D3DFORMAT _Format, D3DPOOL _Pool)
{
	InternalEdgeLength = _EdgeLength;
	InternalLevels = _Levels;
	InternalUsage = _Usage;
	InternalFormat = _Format;
	InternalPool = _Pool;
}

```

`Software_d3d9/IDirect3DCubeTexture9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

class IDirect3DCubeTexture9Hook : public IDirect3DCubeTexture9
{
public:
	IDirect3DCubeTexture9Hook(LPDIRECT3DCUBETEXTURE9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1)
	{
#ifdef _DEBUG
		memcpy(&Name, &realObject->Name, (char*)&realObject - (char*)&Name);
#endif
	}

	virtual ~IDirect3DCubeTexture9Hook()
	{
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DBaseTexture9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreePrivateData(THIS_ REFGUID refguid) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetPriority(THIS_ DWORD PriorityNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetPriority(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE PreLoad(THIS) override;
    virtual COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE GetType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetLOD(THIS_ DWORD LODNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetLOD(THIS) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetLevelCount(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetAutoGenFilterType(THIS_ D3DTEXTUREFILTERTYPE FilterType) override;
    virtual COM_DECLSPEC_NOTHROW D3DTEXTUREFILTERTYPE STDMETHODCALLTYPE GetAutoGenFilterType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE GenerateMipSubLevels(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLevelDesc(THIS_ UINT Level,D3DSURFACE_DESC *pDesc) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCubeMapSurface(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,IDirect3DSurface9** ppCubeMapSurface) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LockRect(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UnlockRect(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AddDirtyRect(THIS_ D3DCUBEMAP_FACES FaceType,CONST RECT* pDirtyRect) override;

	inline LPDIRECT3DCUBETEXTURE9 GetUnderlyingCubeTexture(void) const
	{
		return realObject;
	}

	inline const UINT GetInternalEdgeLength() const
	{
		return InternalEdgeLength;
	}

	inline const D3DFORMAT GetInternalFormat() const
	{
		return InternalFormat;
	}

	const UINT GetInternalMipLevels() const
	{
		return InternalLevels;
	}

	const DebuggableUsage GetInternalUsage() const
	{
		return InternalUsage;
	}

	const D3DPOOL GetInternalPool() const
	{
		return InternalPool;
	}

	void CreateCubeTexture(UINT _EdgeLength, UINT _Levels, DebuggableUsage _Usage, D3DFORMAT _Format, D3DPOOL _Pool);

protected:
	LPDIRECT3DCUBETEXTURE9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

	UINT InternalEdgeLength;
	UINT InternalLevels;
	DebuggableUsage InternalUsage;
	D3DFORMAT InternalFormat;
	D3DPOOL InternalPool;
};

```

`Software_d3d9/IDirect3DDevice9Hook.cpp`:

```cpp
#pragma once

#include "GlobalToggles.h"
#include "IDirect3DDevice9Hook.h"
#include "IDirect3DIndexBuffer9Hook.h"
#include "IDirect3DVertexBuffer9Hook.h"
#include "IDirect3DVertexShader9Hook.h"
#include "IDirect3DPixelShader9Hook.h"
#include "IDirect3DVertexDeclaration9Hook.h"
#include "IDirect3DSurface9Hook.h"
#include "IDirect3DSwapChain9Hook.h"
#include "IDirect3DTexture9Hook.h"
#include "IDirect3DCubeTexture9Hook.h"
#include "IDirect3DVolumeTexture9Hook.h"
#include "IDirect3DStateBlock9Hook.h"
#include "FixedFunctionToShader.h"
#include "SemanticMappings.h"
#include "resource.h"
#include "DitherTables.h"
#include "Overlay/DebugOverlay.h"

#ifdef MULTITHREAD_SHADING
	#if PARALLEL_LIBRARY == PARALLELLIB_CONCRT
		#include <concrt.h>
		#include <ppltasks.h>
		#include <ppl.h>
	#elif PARALLEL_LIBRARY == PARALLELLIB_TBB
		#include <include/tbb/parallel_for.h>
	#endif
#endif

// Rasterizer constants:
// TODO: Fix bug in core rasterizer loop when this is tuned > 0 (ie, when subpixel precision is enabled)
static const unsigned SUBPIXEL_ACCURACY_BITS = 0u;
static const unsigned SUBPIXEL_ACCURACY_BIASMULT = 1 << SUBPIXEL_ACCURACY_BITS;
static const unsigned SUBPIXEL_ACCURACY_BIASMULT2 = 2 * SUBPIXEL_ACCURACY_BIASMULT;
static const int SUBPIXEL_MAX_VALUE = MAXINT >> SUBPIXEL_ACCURACY_BITS;
static const int SUBPIXEL_MIN_VALUE = MININT >> SUBPIXEL_ACCURACY_BITS;
static const float SUBPIXEL_MAX_VALUEF = 8191.0f;//(const float)SUBPIXEL_MAX_VALUE;
static const float SUBPIXEL_MIN_VALUEF = -8191.0f;//(const float)SUBPIXEL_MIN_VALUE;
static const float SUBPIXEL_ACCURACY_BIASMULTF = (const float)SUBPIXEL_ACCURACY_BIASMULT;
static const __m128 SUBPIXEL_ACCURACY_BIASMULT_SPLATTEDF = { SUBPIXEL_ACCURACY_BIASMULTF, SUBPIXEL_ACCURACY_BIASMULTF, SUBPIXEL_ACCURACY_BIASMULTF, SUBPIXEL_ACCURACY_BIASMULTF };
static const D3DXVECTOR4 zeroVec(0.0f, 0.0f, 0.0f, 0.0f);
static const D3DXVECTOR4 vertShaderInputRegisterDefault(0.0f, 0.0f, 0.0f, 1.0f);

static const unsigned twoVecBytes[4] = { 0x2, 0x2, 0x2, 0x2 };
static const __m128i twoVec = *(const __m128i* const)twoVecBytes;
static const unsigned intBoundsQuadAlignVecBytes[4] = { ~0x1, ~0x1, ~0x0, ~0x0 };
static const __m128i intBoundsQuadAlignVec = *(const __m128i* const)intBoundsQuadAlignVecBytes;

static const D3DXVECTOR4 staticColorWhiteOpaque(1.0f, 1.0f, 1.0f, 1.0f);
static const D3DXVECTOR4 staticColorBlackTranslucent(0.0f, 0.0f, 0.0f, 0.0f);
static const __m128 guardBandMin = { -8192.0f, -8192.0f, -8192.0f, -8192.0f };
static const __m128 guardBandMax = { 8192.0f, 8192.0f, 8192.0f, 8192.0f };

static const unsigned sevenVecBytes[4] = { 0x7, 0x7, 0x7, 0x7 };
static const __m128i sevenVec = *(const __m128i* const)sevenVecBytes;
static const unsigned x4quadOffsetBytes[4] = { 0, 1, 0, 1 };
static const __m128i x4quadOffset = *(const __m128i* const)x4quadOffsetBytes;
static const unsigned y4quadOffsetBytes[4] = { 0, 0, 1, 1 };
static const __m128i y4quadOffset = *(const __m128i* const)y4quadOffsetBytes;

static const __m128 zeroMaskVec = { 0.0f, 0.0f, 0.0f, 0.0f };
static const __m128i zeroMaskVecI = { 0 };
static const unsigned oneMaskVecBytes[4] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
static const __m128i oneMaskVec = *(const __m128i* const)oneMaskVecBytes;
static_assert(sizeof(oneMaskVecBytes) == sizeof(oneMaskVec), "Error! Unexpected vector size");

static const __m128 oneVec = { 1.0f, 1.0f, 1.0f, 1.0f };
static const __m128 maxDepth24Bit = { 16777216.0f, 16777216.0f, 16777216.0f, 16777216.0f };

#ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES
	static __int64 totalVertexShadeTicks = 0;
	static __int64 numVertexShadeTasks = 0;
#endif // #ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES

#ifdef PROFILE_AVERAGE_PIXEL_SHADE_TIMES
	static __int64 totalPixelShadeTicks = 0;
	static __int64 numPixelShadeTasks = 0;
#endif // #ifdef PROFILE_AVERAGE_PIXEL_SHADE_TIMES

extern HINSTANCE hLThisDLL;

/*static*/ LightInfo LightInfo::defaultLight;

#ifdef MULTITHREAD_SHADING
#define NUM_THREADS 16

#define NUM_JOBS_PER_PIXEL 4
static unsigned MAX_NUM_JOBS = 0;

static volatile struct _workStatus
{
	volatile long numJobs; // Read by worker threads, written by driver thread
	char cacheLinePadding[64];
	volatile long numFinishedJobs; // Read + written by worker threads, read by driver thread
	char cacheLinePadding2[64];
	volatile long currentJobID; // Read + written by worker threads
	char cacheLinePadding3[64];
	unsigned currentWorkID; // Read + written by driver thread only
} workStatus = {0};

struct _threadItem
{
	IDirect3DDevice9Hook* devHook;
	HANDLE hThread;
	VShaderEngine threadVS_2_0;
	PShaderEngine threadPS_2_0;
} threadItem [NUM_THREADS * 4 + 1] = {0};

// This is volatile and aligned because it will be used with Interlocked operations
static volatile long __declspec(align(16) ) tlsThreadNumber = 0;

// Threadpool implementation was slower than single-threaded implementation in some cases
//static TP_CALLBACK_ENVIRON mainThreadpoolCallbackEnv = {0};
//static PTP_POOL mainThreadpool = NULL;
//static PTP_CLEANUP_GROUP mainThreadpoolCleanupGroup = NULL;

static_assert(sizeof(_threadItem) > 64, "Error: False sharing may occur if thread struct is smaller than a cache line!");

struct barycentricInt2
{
	// Note that we only need the B and C barycentric coordinates here because at any time we could
	// recompute the A coordinate as A = (1.0f - B - C)
	int b, c;
};

__declspec(align(16) ) struct slist_item
{
	workerJobType jobType;
	union _jobData
	{
		struct _vertexJobData
		{
			VS_2_0_OutputRegisters* outputRegs[4];
			UINT vertexIndex[4]; // This is the SV_VertexID semantic in vs_4_0
		} vertexJobData;
#if TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
		struct _pixelJobData
		{
			const primitivePixelJobData* primitiveData;
			barycentricInt2 barycentricCoords[4];
			unsigned x[4];
			unsigned y[4];
		} pixelJobData;
#endif // #if TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS

#if TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
		struct _triangleRasterizeJobData
		{
			UINT primitiveID;
			UINT vertIndex0, vertIndex1, vertIndex2;
			union _triangleRasterizeVerticesUnion
			{
				struct _triangleRasterizeFromStream
				{
					const D3DXVECTOR4* v0;
					const D3DXVECTOR4* v1;
					const D3DXVECTOR4* v2;
				} triangleRasterizeFromStream;

				struct _triangleRasterizeFromShader
				{
					const VS_2_0_OutputRegisters* v0;
					const VS_2_0_OutputRegisters* v1;
					const VS_2_0_OutputRegisters* v2;
				} triangleRasterizeFromShader;
			} rasterVertices;
		} triangleRasterizeJobData;
#endif // #if TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
	} jobData;
};
static_assert(sizeof(slist_item) % 16 == 0, "Error, bad struct alignment!");

static slist_item* allWorkItems = NULL;
static DWORD tlsIndex = TLS_OUT_OF_INDEXES;

static inline void VertexShadeJob1(slist_item& job, _threadItem* const myPtr)
{
	SIMPLE_FUNC_SCOPE();
	const IDirect3DDevice9Hook* const devHook = myPtr->devHook;
	const drawCallVertexJobData& drawCallData = devHook->currentDrawCallData.vertexData;
	if (drawCallData.userClipPlanesEnabled)
	{
		devHook->ProcessVertexToBuffer<true>(*(drawCallData.mapping), &myPtr->threadVS_2_0, job.jobData.vertexJobData.outputRegs[0], job.jobData.vertexJobData.vertexIndex[0]);
	}
	else
	{
		devHook->ProcessVertexToBuffer<false>(*(drawCallData.mapping), &myPtr->threadVS_2_0, job.jobData.vertexJobData.outputRegs[0], job.jobData.vertexJobData.vertexIndex[0]);
	}
}

#ifdef RUN_SHADERS_IN_WARPS
static inline void VertexShadeJob4(slist_item& job, _threadItem* const myPtr)
{
	SIMPLE_FUNC_SCOPE();
	const IDirect3DDevice9Hook* const devHook = myPtr->devHook;
	const drawCallVertexJobData& drawCallData = devHook->currentDrawCallData.vertexData;
	if (drawCallData.userClipPlanesEnabled)
	{
		devHook->ProcessVertexToBuffer4<true>(*(drawCallData.mapping), &myPtr->threadVS_2_0, job.jobData.vertexJobData.outputRegs, job.jobData.vertexJobData.vertexIndex);
	}
	else
	{
		devHook->ProcessVertexToBuffer4<false>(*(drawCallData.mapping), &myPtr->threadVS_2_0, job.jobData.vertexJobData.outputRegs, job.jobData.vertexJobData.vertexIndex);
	}
}
#endif // #ifdef RUN_SHADERS_IN_WARPS

#if TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
static inline void PixelShadeJob1(const slist_item& job, _threadItem* const myPtr)
{
	const IDirect3DDevice9Hook* const devHook = myPtr->devHook;
	const drawCallPixelJobData& drawCallData = devHook->currentDrawCallData.pixelData;
	const slist_item::_jobData::_pixelJobData& pixelJobData = job.jobData.pixelJobData;
	const primitivePixelJobData* const primitiveData = pixelJobData.primitiveData;

	SIMPLE_FUNC_SCOPE_CONDITIONAL(primitiveData->primitiveID == 0 && 
		abs( (const int)(320 - pixelJobData.x[0]) ) < 5 && 
		abs( (const int)(240 - pixelJobData.y[0]) ) < 5);

	const __m128 barycentricNormalizeFactor = _mm_set1_ps(primitiveData->barycentricNormalizeFactor);
	const __m128i barycentricCoordsVector = _mm_set_epi32(0, pixelJobData.barycentricCoords[0].c, pixelJobData.barycentricCoords[0].b, 0);
	const __m128 barycentricCoordsVectorF = _mm_mul_ps(_mm_cvtepi32_ps(barycentricCoordsVector), barycentricNormalizeFactor);
	const __m128 invZ = _mm_load_ps( (const float* const)&(primitiveData->invZ) );
	const __m128 invW = _mm_load_ps( (const float* const)&(primitiveData->invW) );

	const primitivePixelJobData::_pixelShadeVertexData::_shadeFromAgnostic& verts = primitiveData->pixelShadeVertexData.shadeFromAgnostic;
	if (drawCallData.useShaderVerts)
		devHook->SetupPixel<true>(&myPtr->threadPS_2_0, drawCallData.vs_to_ps_mappings.sourceAgnosticMapping, pixelJobData.x[0], pixelJobData.y[0], 
			barycentricCoordsVectorF, drawCallData.offsetIntoVertexForOPosition_Bytes, verts.v0, verts.v1, verts.v2, invZ, invW);
	else
		devHook->SetupPixel<false>(&myPtr->threadPS_2_0, drawCallData.vs_to_ps_mappings.sourceAgnosticMapping, pixelJobData.x[0], pixelJobData.y[0], 
			barycentricCoordsVectorF, drawCallData.offsetIntoVertexForOPosition_Bytes, verts.v0, verts.v1, verts.v2, invZ, invW);
}

static inline void PixelShadeJob4(const slist_item& job, _threadItem* const myPtr)
{
	const IDirect3DDevice9Hook* const devHook = myPtr->devHook;
	const drawCallPixelJobData& drawCallData = devHook->currentDrawCallData.pixelData;
	const slist_item::_jobData::_pixelJobData& pixelJobData = job.jobData.pixelJobData;
	const primitivePixelJobData* const primitiveData = pixelJobData.primitiveData;

	SIMPLE_FUNC_SCOPE_CONDITIONAL(primitiveData->primitiveID == 0 && 
		pixelJobData.x[0] % 64 == 0 &&
		pixelJobData.y[0] % 64 == 0);

	const __m128i x4 = *(const __m128i* const)(pixelJobData.x);
	const __m128i y4 = *(const __m128i* const)(pixelJobData.y);

	const __m128 barycentricNormalizeFactor = _mm_set1_ps(primitiveData->barycentricNormalizeFactor);
	const __m128i barycentricCoordIntVal4[4] =
	{
		_mm_set_epi32(0, pixelJobData.barycentricCoords[0].c, pixelJobData.barycentricCoords[0].b, 0),
		_mm_set_epi32(0, pixelJobData.barycentricCoords[1].c, pixelJobData.barycentricCoords[1].b, 0),
		_mm_set_epi32(0, pixelJobData.barycentricCoords[2].c, pixelJobData.barycentricCoords[2].b, 0),
		_mm_set_epi32(0, pixelJobData.barycentricCoords[3].c, pixelJobData.barycentricCoords[3].b, 0),
	};
	const __m128 barycentricCoords4[4] =
	{
		_mm_mul_ps(_mm_cvtepi32_ps(barycentricCoordIntVal4[0]), barycentricNormalizeFactor),
		_mm_mul_ps(_mm_cvtepi32_ps(barycentricCoordIntVal4[1]), barycentricNormalizeFactor),
		_mm_mul_ps(_mm_cvtepi32_ps(barycentricCoordIntVal4[2]), barycentricNormalizeFactor),
		_mm_mul_ps(_mm_cvtepi32_ps(barycentricCoordIntVal4[3]), barycentricNormalizeFactor)
	};

	const __m128 invZ = _mm_load_ps( (const float* const)&(primitiveData->invZ) );
	const __m128 invW = _mm_load_ps( (const float* const)&(primitiveData->invW) );

	const primitivePixelJobData::_pixelShadeVertexData::_shadeFromAgnostic& verts = primitiveData->pixelShadeVertexData.shadeFromAgnostic;
	if (drawCallData.useShaderVerts)
		devHook->SetupPixel4<true>(&myPtr->threadPS_2_0, drawCallData.vs_to_ps_mappings.sourceAgnosticMapping, x4, y4, barycentricCoords4, 
			drawCallData.offsetIntoVertexForOPosition_Bytes, verts.v0, verts.v1, verts.v2, invZ, invW);
	else
		devHook->SetupPixel4<false>(&myPtr->threadPS_2_0, drawCallData.vs_to_ps_mappings.sourceAgnosticMapping, x4, y4, barycentricCoords4, 
			drawCallData.offsetIntoVertexForOPosition_Bytes, verts.v0, verts.v1, verts.v2, invZ, invW);
}
#endif // #if TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS

#if TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
static inline void TriangleRasterJob1(slist_item& job, _threadItem* const myPtr)
{
	const IDirect3DDevice9Hook* const devHook = myPtr->devHook;
	const drawCallTriangleRasterizeJobsData& drawCallData = devHook->currentDrawCallData.triangleRasterizeData;
	const slist_item::_jobData::_triangleRasterizeJobData& triangleRasterizeJobData = job.jobData.triangleRasterizeJobData;

	if (drawCallData.rasterizeTriangleFromShader)
	{
		const slist_item::_jobData::_triangleRasterizeJobData::_triangleRasterizeVerticesUnion::_triangleRasterizeFromShader& rasterFromShader = triangleRasterizeJobData.rasterVertices.triangleRasterizeFromShader;
		if (drawCallData.rasterizerUsesEarlyZTest)
			devHook->RasterizeTriangle<true, true>(&myPtr->threadPS_2_0, drawCallData.vStoPSMapping, rasterFromShader.v0, rasterFromShader.v1, rasterFromShader.v2,
				drawCallData.fWidth, drawCallData.fHeight, triangleRasterizeJobData.primitiveID, triangleRasterizeJobData.vertIndex0, triangleRasterizeJobData.vertIndex1, triangleRasterizeJobData.vertIndex2);
		else
			devHook->RasterizeTriangle<false, true>(&myPtr->threadPS_2_0, drawCallData.vStoPSMapping, rasterFromShader.v0, rasterFromShader.v1, rasterFromShader.v2,
				drawCallData.fWidth, drawCallData.fHeight, triangleRasterizeJobData.primitiveID, triangleRasterizeJobData.vertIndex0, triangleRasterizeJobData.vertIndex1, triangleRasterizeJobData.vertIndex2);
	}
	else
	{
		const slist_item::_jobData::_triangleRasterizeJobData::_triangleRasterizeVerticesUnion::_triangleRasterizeFromStream& rasterFromStream = triangleRasterizeJobData.rasterVertices.triangleRasterizeFromStream;
		if (drawCallData.rasterizerUsesEarlyZTest)
			devHook->RasterizeTriangle<true, false>(&myPtr->threadPS_2_0, drawCallData.vertexDeclMapping, rasterFromStream.v0, rasterFromStream.v1, rasterFromStream.v2,
				drawCallData.fWidth, drawCallData.fHeight, triangleRasterizeJobData.primitiveID, triangleRasterizeJobData.vertIndex0, triangleRasterizeJobData.vertIndex1, triangleRasterizeJobData.vertIndex2);
		else
			devHook->RasterizeTriangle<false, false>(&myPtr->threadPS_2_0, drawCallData.vertexDeclMapping, rasterFromStream.v0, rasterFromStream.v1, rasterFromStream.v2,
				drawCallData.fWidth, drawCallData.fHeight, triangleRasterizeJobData.primitiveID, triangleRasterizeJobData.vertIndex0, triangleRasterizeJobData.vertIndex1, triangleRasterizeJobData.vertIndex2);
	}
}
#endif // #if TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS

/*VOID NTAPI WorkerThreadCallback(_Inout_ PTP_CALLBACK_INSTANCE Instance, _Inout_opt_ PVOID, _Inout_ PTP_WORK Work)
{
	while (true)
	{
		__declspec(align(16) ) PSLIST_ENTRY entry = InterlockedPopEntrySList(&workQueue);
		if (entry == NULL)
		{
			return;
		}

		const long myThreadId = (InterlockedIncrement(&jobID) % NUM_THREADS);
	//#ifdef _DEBUG
		if (myThreadId >= NUM_THREADS)
		{
			DbgBreakPrint("Error: Invalid threadID!");
		}
	//#endif

		_threadItem& myThreadItem = threadItem[myThreadId];

		//slist_item* const item = (slist_item* const)Context;
		slist_item* const item = (slist_item* const)entry;
		switch (item->jobType)
		{
			default:
				DbgBreakPrint("Error: Unknown job type!");
			case vertexShadeJob:
				VertexShadeJob(*item, &myThreadItem);
				break;
			case pixelShadeJob:
				PixelShadeJob(*item, &myThreadItem);
				break;
		}

		InterlockedPushEntrySList(&completedWorkQueue, &item->itemEntry);

		//InterlockedDecrement(&jobID);
	}
}*/

static inline void WorkUntilNoMoreWork(void* const jobData)
{
	//while (true)
	{
		// Some other thread has finished all of the work, we can just return
/*		if (workStatus.currentJobID >= workStatus.numJobs)
		{
			YieldProcessor();
			return;
		}

		const long jobID = InterlockedIncrement(&workStatus.currentJobID) - 1;
		if (jobID >= workStatus.numJobs)
		{
			InterlockedDecrement(&workStatus.currentJobID);
			YieldProcessor();
			return;
		}
		if (jobID < 0)
		{
			YieldProcessor();
			return;
		}*/

		void* tlsEntry = TlsGetValue(tlsIndex);
		if (tlsEntry == NULL)
		{
			const long thisThreadNumber = InterlockedIncrement(&tlsThreadNumber) - 1;
			if (thisThreadNumber >= ARRAYSIZE(threadItem) )
			{
				__debugbreak();
			}
			_threadItem& thisThreadItem = threadItem[thisThreadNumber];
			if (!TlsSetValue(tlsIndex, &thisThreadItem) )
			{
				__debugbreak();
			}
			tlsEntry = &thisThreadItem;
		}
		_threadItem* const myPtr = (_threadItem* const)tlsEntry;

		//slist_item* const item = &(allWorkItems[jobID]);
		slist_item* const item = (slist_item* const)jobData;

		//slist_item* const item = (slist_item* const)entry;
		switch (item->jobType)
		{
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Unknown job type!");
#else
			__assume(0);
#endif
		case vertexShade1Job:
			VertexShadeJob1(*item, myPtr);
			break;
#ifdef RUN_SHADERS_IN_WARPS
		case vertexShade4Job:
			VertexShadeJob4(*item, myPtr);
			break;
#endif // #ifdef RUN_SHADERS_IN_WARPS

#if TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
		case pixelShade1Job:
			PixelShadeJob1(*item, myPtr);
			break;
#ifdef RUN_SHADERS_IN_WARPS
		case pixelShade4Job:
			PixelShadeJob4(*item, myPtr);
			break;
#endif // #ifdef RUN_SHADERS_IN_WARPS

#endif // #if TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS

#if TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
		case triangleRasterizeJob:
			TriangleRasterJob1(*item, myPtr);
			break;
#endif // #if TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
		}

		//InterlockedPushEntrySList(&completedWorkQueue, entry);
		
		// The last job to finish the last work item sets the event that we're done
		/*if (InterlockedIncrement(&workStatus.numFinishedJobs) == workStatus.numJobs)
		{
			YieldProcessor();
			return;
		}*/

		/*if (InterlockedDecrement(&numWorkItems) <= 0)
		{
			SetEvent(notifyAllJobsCompletedEvent);
		}*/
	}
}

/*static inline DWORD WINAPI WorkerThreadMain(LPVOID ptr)
{
	_threadItem* const myPtr = (_threadItem* const)ptr;
	while (true)
	{
		//WaitForSingleObject(moreWorkReadyEvent, INFINITE);

		WorkUntilNoMoreWork(myPtr);
		//Sleep(1);
	}
	return 0;
}*/

//static TP_CALLBACK_ENVIRON poolEnvironment = {0};
//static TP_CLEANUP_GROUP* cleanup = NULL;
//static TP_POOL* threadPool = NULL;
//static TP_WORK* threadWork = NULL;

/*static inline void RefreshThreadpoolWork()
{
#ifdef _DEBUG
	threadWork = NULL;
#endif
	threadWork = CreateThreadpoolWork(&WorkerThreadCallback, NULL, &poolEnvironment);
	if (!threadWork) __debugbreak();
}*/

template <const unsigned numJobsToRunSinglethreaded>
static inline void SynchronizeThreads()
{
	// WorkUntilNoMoreWork(&threadItem[NUM_THREADS]);
	//workStatus.numJobs = workStatus.currentWorkID;

	if (workStatus.numJobs == 0)
		return;

	//SetEvent(moreWorkReadyEvent);

	const long cacheNumJobs = workStatus.numJobs;
	if (cacheNumJobs <= numJobsToRunSinglethreaded) // Don't actually use multiple threads for incredibly small jobs, it's just a waste of scheduling time overall and it makes debugging more confusing than it has to be
	{
		for (long jobID = 0; jobID < cacheNumJobs; ++jobID)
		{
			WorkUntilNoMoreWork(allWorkItems + jobID);
		}
	}
	else
	{
#if PARALLEL_LIBRARY == PARALLELLIB_CONCRT
		concurrency::parallel_for( (const long)0, cacheNumJobs, [](const int jobID)
		{
			WorkUntilNoMoreWork(allWorkItems + jobID);
		});
#elif PARALLEL_LIBRARY == PARALLELLIB_TBB
		tbb::parallel_for( (const long)0, cacheNumJobs, [](const int jobID)
		{
			WorkUntilNoMoreWork(allWorkItems + jobID);
		});
#endif
	}

	//CloseThreadpoolCleanupGroupMembers(mainThreadpoolCleanupGroup, FALSE, NULL);
	//WaitForSingleObject(allJobsCompletedEvent, INFINITE);
	/*while (workStatus.numFinishedJobs != cacheNumJobs)
	{
		printf("", workStatus.numFinishedJobs, cacheNumJobs);
		__debugbreak();
		//YieldProcessor();
	}*/
	//ResetEvent(moreWorkReadyEvent);
	//ResetEvent(allJobsCompletedEvent);

	const long numJobsTotal = workStatus.numJobs;

	// The order of these assignments is important as these variables may be read by another thread
	workStatus.numJobs = 0;
	workStatus.numFinishedJobs = 0;
	workStatus.currentJobID = 0;
	workStatus.currentWorkID = 0;
}

static VOID NTAPI CleanupGroupCancelCallback(_Inout_opt_ PVOID ObjectContext, _Inout_opt_ PVOID CleanupContext)
{
	UNREFERENCED_PARAMETER(ObjectContext);
	UNREFERENCED_PARAMETER(CleanupContext);

	// Do nothing.
	// We'll probably never call this callback anyway
}

void IDirect3DDevice9Hook::InitThreadQueue()
{
	//InitializeSListHead(&completedWorkQueue);
	//InitializeSListHead(&workQueue);
	/*notifyAllJobsCompletedEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
	if (notifyAllJobsCompletedEvent == NULL)
	{
		DbgBreakPrint("Error: Unable to create worker thread notify finish event!");
		__debugbreak(); // Yup, even in Release builds
	}

	notifyJobsBeginEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
	if (notifyJobsBeginEvent == NULL)
	{
		DbgBreakPrint("Error: Unable to create worker thread notify event!");
		__debugbreak(); // Yup, even in Release builds
	}*/

	/*threadPool = CreateThreadpool(NULL);
	if (!threadPool) __debugbreak();
	SetThreadpoolThreadMaximum(threadPool, NUM_THREADS);
	if (!SetThreadpoolThreadMinimum(threadPool, NUM_THREADS) ) __debugbreak();
	InitializeThreadpoolEnvironment(&poolEnvironment);
	SetThreadpoolCallbackPool(&poolEnvironment, threadPool);
	cleanup = CreateThreadpoolCleanupGroup();
	if (!cleanup) __debugbreak();
	SetThreadpoolCallbackCleanupGroup(&poolEnvironment, cleanup, NULL);
	RefreshThreadpoolWork();*/

	/*allJobsCompletedEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
	moreWorkReadyEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
	if (!allJobsCompletedEvent || !moreWorkReadyEvent)
	{
		__debugbreak();
	}*/

	tlsIndex = TlsAlloc();
	if (tlsIndex == TLS_OUT_OF_INDEXES)
	{
		__debugbreak(); // Uhhhh, we shouldn't run out of TLS slots unless something has gone really wrong...
	}

	for (unsigned x = 0; x < ARRAYSIZE(threadItem); ++x)
	{
		threadItem[x].devHook = this;
	}
	
	/*for (unsigned x = 0; x < NUM_THREADS; ++x)
	{
		threadItem[x].hThread = CreateThread(NULL, 0, &WorkerThreadMain, &(threadItem[x]), 0, NULL);
		SetThreadDescription(threadItem[x].hThread, L"SoftwareD3D9 Worker Thread");

		if (!threadItem[x].hThread)
		{
			DbgBreakPrint("Error: Unable to create worker thread!");
			__debugbreak(); // Yup, even in Release builds
		}
	}*/

	/*mainThreadpool = CreateThreadpool(NULL);
	if (!mainThreadpool)
	{
		__debugbreak();
	}

	if (!SetThreadpoolThreadMinimum(mainThreadpool, NUM_THREADS) )
	{
		__debugbreak();
	}

	SetThreadpoolThreadMaximum(mainThreadpool, NUM_THREADS);

	InitializeThreadpoolEnvironment(&mainThreadpoolCallbackEnv);
	SetThreadpoolCallbackPool(&mainThreadpoolCallbackEnv, mainThreadpool);

	mainThreadpoolCleanupGroup = CreateThreadpoolCleanupGroup();
	if (!mainThreadpoolCleanupGroup)
	{
		__debugbreak();
	}
	SetThreadpoolCallbackCleanupGroup(&mainThreadpoolCallbackEnv, mainThreadpoolCleanupGroup, &CleanupGroupCancelCallback);*/
}

#endif // MULTITHREAD_SHADING

// Returns true if the pixel "passes" the depth test (should be written) and false if the pixel "fails" the depth test (should be discarded)
static inline const bool DepthTest(const float pixelDepth, const unsigned bufferDepth, const D3DCMPFUNC comparison, const D3DFORMAT depthFmt)
{
	unsigned quantizedPixelDepth;
	switch (depthFmt)
	{
	case D3DFMT_D15S1:
		quantizedPixelDepth = (const unsigned)(pixelDepth * 32768.0f);
		break;
	case D3DFMT_D16:
	case D3DFMT_D16_LOCKABLE:
		quantizedPixelDepth = (const unsigned)(pixelDepth * 65536.0f);
		break;
	default:
		DbgBreakPrint("Error: Unknown Depth buffer format!");
	case D3DFMT_D24FS8:
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24X8:
		quantizedPixelDepth = (const unsigned)(pixelDepth * 16777216.0f);
		break;
	case D3DFMT_D32:
	case D3DFMT_D32_LOCKABLE:
		quantizedPixelDepth = (const unsigned)(pixelDepth * 4294967296.0f);
		break;
	case D3DFMT_D32F_LOCKABLE:
		quantizedPixelDepth = *(const unsigned* const)&pixelDepth;
		break;
	}

	switch (comparison)
	{
	case D3DCMP_NEVER       :
		return false;
	case D3DCMP_LESS        :
		return quantizedPixelDepth < bufferDepth;
	case D3DCMP_EQUAL       :
		return quantizedPixelDepth == bufferDepth;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Undefined D3DCMP specified for DepthTest");
#endif
	case D3DCMP_LESSEQUAL   :
		return quantizedPixelDepth <= bufferDepth;
	case D3DCMP_GREATER     :
		return quantizedPixelDepth > bufferDepth;
	case D3DCMP_NOTEQUAL    :
		return quantizedPixelDepth != bufferDepth;
	case D3DCMP_GREATEREQUAL:
		return quantizedPixelDepth >= bufferDepth;
	case D3DCMP_ALWAYS      :
		return true;
	}
}

static inline const __m128i StencilTestNoWrite4(const __m128i stencilValues4, const D3DCMPFUNC stencilCmp, const UINT stencilRef, const DWORD stencilMask)
{
	switch (stencilCmp)
	{
	case D3DCMP_NEVER:
		return zeroMaskVecI;
	case D3DCMP_ALWAYS:
		return oneMaskVec;
	default:
		break;
	}
	const UINT maskedRef = stencilRef & stencilMask;
	const __m128i maskedQuad = _mm_loadu_si32(maskedRef);
	switch (stencilCmp)
	{
	case D3DCMP_LESS:
		return _mm_cmplt_epi32(stencilValues4, maskedQuad);
	case D3DCMP_EQUAL:
		return _mm_cmpeq_epi32(stencilValues4, maskedQuad);
	case D3DCMP_LESSEQUAL:
		return _mm_andnot_si128(_mm_cmpgt_epi32(stencilValues4, maskedQuad), oneMaskVec); // There is no _mm_cmple_epi32 so instead we'll use not _mm_cmpgt_epi32 and 0xF
	case D3DCMP_GREATER:
		return _mm_cmpgt_epi32(stencilValues4, maskedQuad);
	case D3DCMP_NOTEQUAL:
		return _mm_andnot_si128(_mm_cmpeq_epi32(stencilValues4, maskedQuad), oneMaskVec); // There is no _mm_cmpne_epi32 so instead we'll use not _mm_cmpeq_epi32 and 0xF
	case D3DCMP_GREATEREQUAL:
		return _mm_andnot_si128(_mm_cmplt_epi32(stencilValues4, maskedQuad), oneMaskVec); // There is no _mm_cmpge_epi32 so instead we'll use not _mm_cmplt_epi32 and 0xF
	default:
#ifdef _DEBUG
		__debugbreak(); // Should never be here!
		return zeroMaskVecI;
#else
		__assume(0);
#endif
	}
}

// Returns 0xFF if the pixel "passes" the depth test (should be written) and 0x00 if the pixel "fails" the depth test (should be discarded)
static const __m128 pixelDepthScaleD15 = { 32768.0f, 32768.0f, 32768.0f, 32768.0f };
static const __m128 pixelDepthScaleD16 = { 65536.0f, 65536.0f, 65536.0f, 65536.0f };
static const __m128 pixelDepthScaleD24 = { 16777216.0f, 16777216.0f, 16777216.0f, 16777216.0f };
static const __m128 pixelDepthScaleD32 = { 4294967296.0f, 4294967296.0f, 4294967296.0f, 4294967296.0f };
static inline const __m128i DepthTest4(const __m128 pixelDepth4, const __m128i bufferDepth4, const D3DCMPFUNC comparison, const D3DFORMAT depthFmt)
{
	__m128i quantizedPixelDepth4;
	switch (depthFmt)
	{
	case D3DFMT_D15S1:
	{
		const __m128 scaledDepth4 = _mm_mul_ps(pixelDepthScaleD15, pixelDepth4);
		quantizedPixelDepth4 = _mm_cvtps_epi32(scaledDepth4);
	}
		break;
	case D3DFMT_D16:
	case D3DFMT_D16_LOCKABLE:
	{
		const __m128 scaledDepth4 = _mm_mul_ps(pixelDepthScaleD16, pixelDepth4);
		quantizedPixelDepth4 = _mm_cvtps_epi32(scaledDepth4);
	}
		break;
	default:
		DbgBreakPrint("Error: Unknown Depth buffer format!");
	case D3DFMT_D24FS8:
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24X8:
	{
		const __m128 scaledDepth4 = _mm_mul_ps(pixelDepthScaleD24, pixelDepth4);
		quantizedPixelDepth4 = _mm_cvtps_epi32(scaledDepth4);
	}
		break;
	case D3DFMT_D32:
	case D3DFMT_D32_LOCKABLE:
	{
		const __m128 scaledDepth4 = _mm_mul_ps(pixelDepthScaleD32, pixelDepth4);
		quantizedPixelDepth4 = _mm_cvtps_epi32(scaledDepth4); // Technically this isn't correct and this should instead be using _mm_cvtps_epu32, but that requires AVX512 for some reason
	}
		break;
	case D3DFMT_D32F_LOCKABLE:
	{
		quantizedPixelDepth4 = *(const __m128i* const)&pixelDepth4;
	}
		break;
	}

	switch (comparison)
	{
	case D3DCMP_NEVER       :
		return zeroMaskVecI;
	case D3DCMP_LESS        :
		return _mm_cmplt_epi32(quantizedPixelDepth4, bufferDepth4);
	case D3DCMP_EQUAL       :
		return _mm_cmpeq_epi32(quantizedPixelDepth4, bufferDepth4);
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Undefined D3DCMP specified for DepthTest");
#endif
	case D3DCMP_LESSEQUAL   : // Implemented as !>
		return _mm_xor_si128(_mm_cmpgt_epi32(quantizedPixelDepth4, bufferDepth4), oneMaskVec);
	case D3DCMP_GREATER     :
		return _mm_cmpgt_epi32(quantizedPixelDepth4, bufferDepth4);
	case D3DCMP_NOTEQUAL    : // Implemented as !=
		return _mm_xor_si128(_mm_cmpeq_epi32(quantizedPixelDepth4, bufferDepth4), oneMaskVec);
	case D3DCMP_GREATEREQUAL: // Implemented as !<
		return _mm_xor_si128(_mm_cmplt_epi32(quantizedPixelDepth4, bufferDepth4), oneMaskVec);
	case D3DCMP_ALWAYS      :
		return oneMaskVec;
	}
}

// Most of these were pulled from d3dtypes.h, but some of them were pulled from d3d8.h as well
enum RETIRED_D3D_RENDERSTATES : DWORD
{
    D3DRENDERSTATE_TEXTUREHANDLE      = 1,    /* Texture handle for legacy interfaces (Texture,Texture2) */
	D3DRENDERSTATE_ANTIALIAS          = 2,    /* D3DANTIALIASMODE */
    D3DRENDERSTATE_TEXTUREADDRESS     = 3,    /* D3DTEXTUREADDRESS  */
	D3DRENDERSTATE_TEXTUREPERSPECTIVE = 4,    /* TRUE for perspective correction */
    D3DRENDERSTATE_WRAPU              = 5,    /* TRUE for wrapping in u */
    D3DRENDERSTATE_WRAPV              = 6,    /* TRUE for wrapping in v */
	D3DRENDERSTATE_LINEPATTERN        = 10,   /* D3DLINEPATTERN */
    D3DRENDERSTATE_MONOENABLE         = 11,   /* TRUE to enable mono rasterization */
    D3DRENDERSTATE_ROP2               = 12,   /* ROP2 */
    D3DRENDERSTATE_PLANEMASK          = 13,   /* DWORD physical plane mask */
    D3DRENDERSTATE_TEXTUREMAG         = 17,   /* D3DTEXTUREFILTER */
    D3DRENDERSTATE_TEXTUREMIN         = 18,   /* D3DTEXTUREFILTER */
    D3DRENDERSTATE_TEXTUREMAPBLEND    = 21,   /* D3DTEXTUREBLEND */
	D3DRENDERSTATE_ZVISIBLE           = 30,   /* TRUE to enable z checking */
    D3DRENDERSTATE_SUBPIXEL           = 31,   /* TRUE to enable subpixel correction */
    D3DRENDERSTATE_SUBPIXELX          = 32,   /* TRUE to enable correction in X only */
	D3DRENDERSTATE_STIPPLEDALPHA      = 33,   /* TRUE to enable stippled alpha (RGB device only) */
    D3DRENDERSTATE_STIPPLEENABLE      = 39,   /* TRUE to enable stippling */
#if(DIRECT3D_VERSION >= 0x0500)
    D3DRENDERSTATE_EDGEANTIALIAS      = 40,   /* TRUE to enable edge antialiasing */
    D3DRENDERSTATE_COLORKEYENABLE     = 41,   /* TRUE to enable source colorkeyed textures */
	D3DRENDERSTATE_OLDALPHABLENDENABLE = 42,
    D3DRENDERSTATE_BORDERCOLOR        = 43,   /* Border color for texturing w/border */
    D3DRENDERSTATE_TEXTUREADDRESSU    = 44,   /* Texture addressing mode for U coordinate */
    D3DRENDERSTATE_TEXTUREADDRESSV    = 45,   /* Texture addressing mode for V coordinate */
    D3DRENDERSTATE_MIPMAPLODBIAS      = 46,   /* D3DVALUE Mipmap LOD bias */
	D3DRS_ZBIAS                       = 47,   /* LONG Z bias */
    D3DRENDERSTATE_ANISOTROPY         = 49,   /* Max. anisotropy. 1 = no anisotropy */
#endif /* DIRECT3D_VERSION >= 0x0500 */
    D3DRENDERSTATE_FLUSHBATCH         = 50,   /* Explicit flush for DP batching (DX5 Only) */
#if(DIRECT3D_VERSION >= 0x0600)
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT=51, /* BOOL enable sort-independent transparency */
#endif /* DIRECT3D_VERSION >= 0x0600 */
    D3DRENDERSTATE_STIPPLEPATTERN00   = 64,   /* Stipple pattern 01...  */
    D3DRENDERSTATE_STIPPLEPATTERN01   = 65,
    D3DRENDERSTATE_STIPPLEPATTERN02   = 66,
    D3DRENDERSTATE_STIPPLEPATTERN03   = 67,
    D3DRENDERSTATE_STIPPLEPATTERN04   = 68,
    D3DRENDERSTATE_STIPPLEPATTERN05   = 69,
    D3DRENDERSTATE_STIPPLEPATTERN06   = 70,
    D3DRENDERSTATE_STIPPLEPATTERN07   = 71,
    D3DRENDERSTATE_STIPPLEPATTERN08   = 72,
    D3DRENDERSTATE_STIPPLEPATTERN09   = 73,
    D3DRENDERSTATE_STIPPLEPATTERN10   = 74,
    D3DRENDERSTATE_STIPPLEPATTERN11   = 75,
    D3DRENDERSTATE_STIPPLEPATTERN12   = 76,
    D3DRENDERSTATE_STIPPLEPATTERN13   = 77,
    D3DRENDERSTATE_STIPPLEPATTERN14   = 78,
    D3DRENDERSTATE_STIPPLEPATTERN15   = 79,
    D3DRENDERSTATE_STIPPLEPATTERN16   = 80,
    D3DRENDERSTATE_STIPPLEPATTERN17   = 81,
    D3DRENDERSTATE_STIPPLEPATTERN18   = 82,
    D3DRENDERSTATE_STIPPLEPATTERN19   = 83,
    D3DRENDERSTATE_STIPPLEPATTERN20   = 84,
    D3DRENDERSTATE_STIPPLEPATTERN21   = 85,
    D3DRENDERSTATE_STIPPLEPATTERN22   = 86,
    D3DRENDERSTATE_STIPPLEPATTERN23   = 87,
    D3DRENDERSTATE_STIPPLEPATTERN24   = 88,
    D3DRENDERSTATE_STIPPLEPATTERN25   = 89,
    D3DRENDERSTATE_STIPPLEPATTERN26   = 90,
    D3DRENDERSTATE_STIPPLEPATTERN27   = 91,
    D3DRENDERSTATE_STIPPLEPATTERN28   = 92,
    D3DRENDERSTATE_STIPPLEPATTERN29   = 93,
    D3DRENDERSTATE_STIPPLEPATTERN30   = 94,
    D3DRENDERSTATE_STIPPLEPATTERN31   = 95,
	
#if(DIRECT3D_VERSION >= 0x0700)
	D3DRENDERSTATE_EXTENTS             = 138,
	D3DRENDERSTATE_COLORKEYBLENDENABLE = 144,
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0800)
	D3DRS_SOFTWAREVERTEXPROCESSING     = 153,
	D3DRS_PATCHSEGMENTS                = 164,  // Number of segments per edge when drawing patches
#endif /* DIRECT3D_VERSION >= 0x0800 */

#if(DIRECT3D_VERSION >= 0x0500)
    D3DRENDERSTATE_FORCE_DWORD        = 0x7fffffff /* force 32-bit size enum */
#endif /* DIRECT3D_VERSION >= 0x0500 */
};

RenderStates::RenderStates() : cachedAlphaRefFloat(0.0f)
{
	// All states initially start out zeroed:
	memset(this, 0, sizeof(*this) );

	static const float zerof = 0.0f;
	static const DWORD dwordZeroF = *(const DWORD* const)&zerof;
	static const float onef = 1.0f;
	static const DWORD dwordOneF = *(const DWORD* const)&onef;
	static const float f64 = 64.0f;
	static const DWORD dword64F = *(const DWORD* const)&f64;

	// Now let's set the default values one by one. Source is: https://msdn.microsoft.com/en-us/library/windows/desktop/bb172599(v=vs.85).aspx
	renderStatesUnion.states[D3DRENDERSTATE_TEXTUREHANDLE             ] = NULL; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_ANTIALIAS                 ] = D3DANTIALIAS_NONE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_TEXTUREADDRESS            ] = D3DTADDRESS_WRAP; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_TEXTUREPERSPECTIVE        ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_WRAPU                     ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_WRAPV                     ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRS_ZENABLE                            ] = D3DZB_TRUE;
	renderStatesUnion.states[D3DRS_FILLMODE                           ] = D3DFILL_SOLID;
	renderStatesUnion.states[D3DRS_SHADEMODE                          ] = D3DSHADE_GOURAUD;
	renderStatesUnion.states[D3DRENDERSTATE_LINEPATTERN               ] = ( (0 << 16) | (0xFFFF) ); // Repeat = 0, Pattern = 1111111111111111b; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_MONOENABLE                ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_ROP2                      ] = R2_COPYPEN; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_PLANEMASK                 ] = 0x00000000; // Deprecated legacy state
	renderStatesUnion.states[D3DRS_ZWRITEENABLE                       ] = TRUE;
	renderStatesUnion.states[D3DRS_ALPHATESTENABLE                    ] = FALSE;
	renderStatesUnion.states[D3DRS_LASTPIXEL                          ] = TRUE;
	renderStatesUnion.states[D3DRENDERSTATE_TEXTUREMAG                ] = D3DFILTER_NEAREST; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_TEXTUREMIN                ] = D3DFILTER_NEAREST; // Deprecated legacy state
	renderStatesUnion.states[D3DRS_SRCBLEND                           ] = D3DBLEND_ONE;
	renderStatesUnion.states[D3DRS_DESTBLEND                          ] = D3DBLEND_ZERO;
	renderStatesUnion.states[D3DRENDERSTATE_TEXTUREMAPBLEND           ] = D3DTBLEND_MODULATE; // Deprecated legacy state
	renderStatesUnion.states[D3DRS_CULLMODE                           ] = D3DCULL_CCW;
	renderStatesUnion.states[D3DRS_ZFUNC                              ] = D3DCMP_LESSEQUAL;
	renderStatesUnion.states[D3DRS_ALPHAREF                           ] = 0x00000000;
	renderStatesUnion.states[D3DRS_ALPHAFUNC                          ] = D3DCMP_ALWAYS;
	renderStatesUnion.states[D3DRS_DITHERENABLE                       ] = FALSE;
	renderStatesUnion.states[D3DRS_ALPHABLENDENABLE                   ] = FALSE;
	renderStatesUnion.states[D3DRS_FOGENABLE                          ] = FALSE;
	renderStatesUnion.states[D3DRS_SPECULARENABLE                     ] = FALSE;
	renderStatesUnion.states[D3DRENDERSTATE_ZVISIBLE                  ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_SUBPIXEL                  ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_SUBPIXELX                 ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_STIPPLEDALPHA             ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRS_FOGCOLOR                           ] = D3DCOLOR_ARGB(0, 0, 0, 0);
	renderStatesUnion.states[D3DRS_FOGTABLEMODE                       ] = D3DFOG_NONE;
	renderStatesUnion.states[D3DRS_FOGSTART                           ] = dwordZeroF;
	renderStatesUnion.states[D3DRS_FOGEND                             ] = dwordOneF;
	renderStatesUnion.states[D3DRS_FOGDENSITY                         ] = dwordOneF;
	renderStatesUnion.states[D3DRENDERSTATE_STIPPLEENABLE             ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_EDGEANTIALIAS             ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_COLORKEYENABLE            ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_OLDALPHABLENDENABLE       ] = FALSE;
	renderStatesUnion.states[D3DRENDERSTATE_BORDERCOLOR               ] = D3DCOLOR_ARGB(0x00, 0x00, 0x00, 0x00); // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_TEXTUREADDRESSU           ] = D3DTADDRESS_WRAP; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_TEXTUREADDRESSV           ] = D3DTADDRESS_WRAP; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_MIPMAPLODBIAS             ] = dwordZeroF;
	renderStatesUnion.states[D3DRS_ZBIAS                              ] = 0; // Deprecated legacy state
	renderStatesUnion.states[D3DRS_RANGEFOGENABLE                     ] = FALSE;
	renderStatesUnion.states[D3DRENDERSTATE_ANISOTROPY                ] = 1; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_FLUSHBATCH                ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRS_STENCILENABLE                      ] = FALSE;
	renderStatesUnion.states[D3DRS_STENCILFAIL                        ] = D3DSTENCILOP_KEEP;
	renderStatesUnion.states[D3DRS_STENCILZFAIL                       ] = D3DSTENCILOP_KEEP;
	renderStatesUnion.states[D3DRS_STENCILPASS                        ] = D3DSTENCILOP_KEEP;
	renderStatesUnion.states[D3DRS_STENCILFUNC                        ] = D3DCMP_ALWAYS;
	renderStatesUnion.states[D3DRS_STENCILREF                         ] = 0x00;
	renderStatesUnion.states[D3DRS_STENCILMASK                        ] = 0xFFFFFFFF;
	renderStatesUnion.states[D3DRS_STENCILWRITEMASK                   ] = 0xFFFFFFFF;
	renderStatesUnion.states[D3DRS_TEXTUREFACTOR                      ] = D3DCOLOR_ARGB(0xFF, 0xFF, 0xFF, 0xFF);
	for (unsigned char stippleLine = 0; stippleLine < 32; ++stippleLine)
	{
		renderStatesUnion.states[D3DRENDERSTATE_STIPPLEPATTERN00 + stippleLine] = (stippleLine & 0x1) ? 0x55555555 : 0xAAAAAAAA; // Deprecated legacy states
	}
	renderStatesUnion.states[D3DRS_WRAP0                              ] = 0;
	renderStatesUnion.states[D3DRS_WRAP1                              ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP2                              ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP3                              ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP4                              ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP5                              ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP6                              ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP7                              ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_CLIPPING                           ] = TRUE;
	renderStatesUnion.states[D3DRS_LIGHTING                           ] = TRUE;
	renderStatesUnion.states[D3DRS_AMBIENT                            ] = D3DCOLOR_ARGB(0, 0, 0, 0);
	renderStatesUnion.states[D3DRS_FOGVERTEXMODE                      ] = D3DFOG_NONE;
	renderStatesUnion.states[D3DRS_COLORVERTEX                        ] = TRUE;
	renderStatesUnion.states[D3DRS_LOCALVIEWER                        ] = TRUE;
	renderStatesUnion.states[D3DRS_NORMALIZENORMALS                   ] = FALSE;
	renderStatesUnion.states[D3DRENDERSTATE_COLORKEYBLENDENABLE       ] = FALSE;
	renderStatesUnion.states[D3DRS_DIFFUSEMATERIALSOURCE              ] = D3DMCS_COLOR1;
	renderStatesUnion.states[D3DRS_SPECULARMATERIALSOURCE             ] = D3DMCS_COLOR2;
	renderStatesUnion.states[D3DRS_AMBIENTMATERIALSOURCE              ] = D3DMCS_MATERIAL;
	renderStatesUnion.states[D3DRS_EMISSIVEMATERIALSOURCE             ] = D3DMCS_MATERIAL;
	renderStatesUnion.states[D3DRS_VERTEXBLEND                        ] = D3DVBF_DISABLE;
	renderStatesUnion.states[D3DRS_CLIPPLANEENABLE                    ] = 0x00000000;
	renderStatesUnion.states[D3DRS_SOFTWAREVERTEXPROCESSING           ] = FALSE; // Deprecated legacy state
	renderStatesUnion.states[D3DRS_POINTSIZE                          ] = dwordOneF;
	renderStatesUnion.states[D3DRS_POINTSIZE_MIN                      ] = dwordOneF;
	renderStatesUnion.states[D3DRS_POINTSPRITEENABLE                  ] = FALSE;
	renderStatesUnion.states[D3DRS_POINTSCALEENABLE                   ] = FALSE;
	renderStatesUnion.states[D3DRS_POINTSCALE_A                       ] = dwordOneF;
	renderStatesUnion.states[D3DRS_POINTSCALE_B                       ] = dwordZeroF;
	renderStatesUnion.states[D3DRS_POINTSCALE_C                       ] = dwordZeroF;
	renderStatesUnion.states[D3DRS_MULTISAMPLEANTIALIAS               ] = TRUE;
	renderStatesUnion.states[D3DRS_MULTISAMPLEMASK                    ] = 0xFFFFFFFF;
	renderStatesUnion.states[D3DRS_PATCHEDGESTYLE                     ] = D3DPATCHEDGE_DISCRETE;
	renderStatesUnion.states[D3DRS_PATCHSEGMENTS                      ] = 0; // Deprecated legacy state
	renderStatesUnion.states[D3DRS_DEBUGMONITORTOKEN                  ] = D3DDMT_ENABLE;
	renderStatesUnion.states[D3DRS_POINTSIZE_MAX                      ] = dword64F;
	renderStatesUnion.states[D3DRS_INDEXEDVERTEXBLENDENABLE           ] = FALSE;
	renderStatesUnion.states[D3DRS_COLORWRITEENABLE                   ] = D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA;
	renderStatesUnion.states[D3DRS_TWEENFACTOR                        ] = dwordZeroF;
	renderStatesUnion.states[D3DRS_BLENDOP                            ] = D3DBLENDOP_ADD;
	renderStatesUnion.states[D3DRS_POSITIONDEGREE                     ] = D3DDEGREE_CUBIC;
	renderStatesUnion.states[D3DRS_NORMALDEGREE                       ] = D3DDEGREE_LINEAR;
	renderStatesUnion.states[D3DRS_SCISSORTESTENABLE                  ] = FALSE;
	renderStatesUnion.states[D3DRS_SLOPESCALEDEPTHBIAS                ] = dwordZeroF;
	renderStatesUnion.states[D3DRS_ANTIALIASEDLINEENABLE              ] = FALSE;
	renderStatesUnion.states[D3DRS_MINTESSELLATIONLEVEL               ] = dwordOneF;
	renderStatesUnion.states[D3DRS_MAXTESSELLATIONLEVEL               ] = dwordOneF;
	renderStatesUnion.states[D3DRS_ADAPTIVETESS_X                     ] = dwordZeroF;
	renderStatesUnion.states[D3DRS_ADAPTIVETESS_Y                     ] = dwordZeroF;
	renderStatesUnion.states[D3DRS_ADAPTIVETESS_Z                     ] = dwordOneF;
	renderStatesUnion.states[D3DRS_ADAPTIVETESS_W                     ] = dwordZeroF;
	renderStatesUnion.states[D3DRS_ENABLEADAPTIVETESSELLATION         ] = FALSE;
	renderStatesUnion.states[D3DRS_TWOSIDEDSTENCILMODE                ] = FALSE;
	renderStatesUnion.states[D3DRS_CCW_STENCILFAIL                    ] = D3DSTENCILOP_KEEP;
	renderStatesUnion.states[D3DRS_CCW_STENCILZFAIL                   ] = D3DSTENCILOP_KEEP;
	renderStatesUnion.states[D3DRS_CCW_STENCILPASS                    ] = D3DSTENCILOP_KEEP;
	renderStatesUnion.states[D3DRS_CCW_STENCILFUNC                    ] = D3DCMP_ALWAYS;
	renderStatesUnion.states[D3DRS_COLORWRITEENABLE1                  ] = renderStatesUnion.states[D3DRS_COLORWRITEENABLE];
	renderStatesUnion.states[D3DRS_COLORWRITEENABLE2                  ] = renderStatesUnion.states[D3DRS_COLORWRITEENABLE];
	renderStatesUnion.states[D3DRS_COLORWRITEENABLE3                  ] = renderStatesUnion.states[D3DRS_COLORWRITEENABLE];
	renderStatesUnion.states[D3DRS_BLENDFACTOR                        ] = D3DCOLOR_ARGB(0xFF, 0xFF, 0xFF, 0xFF);
	renderStatesUnion.states[D3DRS_SRGBWRITEENABLE                    ] = FALSE;
	renderStatesUnion.states[D3DRS_DEPTHBIAS                          ] = dwordZeroF;
	renderStatesUnion.states[D3DRS_WRAP8                              ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP9                              ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP10                             ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP11                             ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP12                             ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP13                             ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP14                             ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_WRAP15                             ] = renderStatesUnion.states[D3DRS_WRAP0];
	renderStatesUnion.states[D3DRS_SEPARATEALPHABLENDENABLE           ] = FALSE;
	renderStatesUnion.states[D3DRS_SRCBLENDALPHA                      ] = D3DBLEND_ONE;
	renderStatesUnion.states[D3DRS_DESTBLENDALPHA                     ] = D3DBLEND_ZERO;
	renderStatesUnion.states[D3DRS_BLENDOPALPHA                       ] = D3DBLENDOP_ADD;

	cachedAlphaRefFloat = 0.0f;
	cachedAmbient = D3DXVECTOR4(0.0f, 0.0f, 0.0f, 0.0f);
	ColorDWORDToFloat4(renderStatesUnion.states[D3DRS_BLENDFACTOR], cachedBlendFactor);
	cachedInvBlendFactor = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f) - cachedBlendFactor;
	depthBiasSplatted = _mm_set1_ps(0.0f);
	alphaRefSplatted = _mm_set1_ps(0.0f);
	simplifiedAlphaBlendMode = noAlphaBlending;
	alphaBlendNeedsDestRead = true;
}

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj) 
{
	HRESULT ret = d3d9dev->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DDevice9Hook::AddRef(THIS)
{
	ULONG ret = d3d9dev->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DDevice9Hook::Release(THIS)
{
	ULONG ret = d3d9dev->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked D3D9 Device %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DDevice9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::TestCooperativeLevel(THIS)
{
	HRESULT ret = d3d9dev->TestCooperativeLevel();
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::EvictManagedResources(THIS)
{
	HRESULT ret = d3d9dev->EvictManagedResources();
	return ret;
}

COM_DECLSPEC_NOTHROW BOOL STDMETHODCALLTYPE IDirect3DDevice9Hook::ShowCursor(THIS_ BOOL bShow)
{
#ifdef OVERRIDE_HIDE_CURSOR
	if (bShow == FALSE)
		return TRUE;
#endif
	BOOL ret = d3d9dev->ShowCursor(bShow);
	return ret;
}

void IDirect3DDevice9Hook::PreReset(void)
{
	if (currentState.currentRenderTargets[0])
	{
		currentState.currentRenderTargets[0]->GetUnderlyingSurface()->Release();
		currentState.currentRenderTargets[0]->Release();
		currentState.currentRenderTargets[0]->Release();
		currentState.currentRenderTargets[0] = NULL;
	}

	if (currentState.currentDepthStencil)
	{
		currentState.currentDepthStencil->GetUnderlyingSurface()->Release();
		currentState.currentDepthStencil->Release();
		currentState.currentDepthStencil = NULL;
	}

	implicitSwapChain->GetUnderlyingSwapChain()->Release();
	implicitSwapChain->Release();
	implicitSwapChain = NULL;

	ResetOverlay(this);
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::Reset(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters)
{
#ifdef _DEBUG
	OutputDebugStringA("IDirect3DDevice9::Reset called!\n");
#endif

	D3DPRESENT_PARAMETERS modifiedParams = *pPresentationParameters;
	ModifyPresentParameters(modifiedParams);

	PreReset();

	HRESULT ret = d3d9dev->Reset(&modifiedParams);
	if (FAILED(ret) )
	{
		char resetFail[256] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(resetFail, "HR: 0x%08X\n", ret);
#pragma warning(pop)
		MessageBoxA(NULL, resetFail, "Failed reset", MB_OK);
		return ret;
	}

	// Re-initialize the device state: 
	InitializeState(modifiedParams, initialDevType, initialCreateFlags, initialCreateFocusWindow);

	return ret;
}

#ifdef ENABLE_END_TO_SKIP_DRAWS
static DWORD lastCheckedTicks = 0x00000000;
static bool lastCheckedIsHoldingDownEnd = false;

static inline void ResetHoldingDownEndToSkip()
{
	--lastCheckedTicks;
}

// Skip this draw call if END is held down
static inline const bool IsHoldingEndToSkipDrawCalls(void)
{
	// Since GetTickCount() has a 1ms resolution (at best), this limits us to only calling this function at most once per millisecond
	const DWORD currentTime = GetTickCount();
	if (currentTime != lastCheckedTicks)
	{
		if ( (GetAsyncKeyState(VK_END) & 0x8000) )
			lastCheckedIsHoldingDownEnd = true;
		else
			lastCheckedIsHoldingDownEnd = false;

		lastCheckedTicks = currentTime;
	}

	return lastCheckedIsHoldingDownEnd;
}
#endif // #ifdef ENABLE_END_TO_SKIP_DRAWS

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::Present(THIS_ CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion)
{
	SIMPLE_FUNC_SCOPE();

#ifdef ENABLE_END_TO_SKIP_DRAWS
	ResetHoldingDownEndToSkip();
#endif // ENABLE_END_TO_SKIP_DRAWS

	HRESULT ret = implicitSwapChain->Present(pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion, 0);
	if (FAILED(ret) )
		return ret;

#ifdef SURFACE_MAGIC_COOKIE
	ValidateSurfaceMagicCookie(implicitSwapChain->GetInternalBackBuffer()->GetSurfaceBytes() );
#endif

	static LARGE_INTEGER lastPresentTime = {0};
	static long double ldFreq = 0.0;
	if (lastPresentTime.QuadPart == 0)
	{
		QueryPerformanceCounter(&lastPresentTime);
		LARGE_INTEGER freq = {0};
		QueryPerformanceFrequency(&freq);
		ldFreq = (const long double)(freq.QuadPart);
	}
	else
	{
		LARGE_INTEGER currentPresentTime = {0};
		QueryPerformanceCounter(&currentPresentTime);
		const LONGLONG timeDelta = currentPresentTime.QuadPart - lastPresentTime.QuadPart;
		const long double timeDeltaSeconds = timeDelta / ldFreq;

		{
			static DWORD lastPrintTime = 0;
			const unsigned currentTime = GetTickCount();
			if (currentTime - lastPrintTime > 33)
			{
				char buffer[64] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
				const unsigned len = sprintf(buffer, "%03.3fms per frame (%03.3fFPS)\n", timeDeltaSeconds * 1000.0f, 1.0f / timeDeltaSeconds);
#pragma warning(pop)
				DWORD numCharsWritten = 0;
				WriteConsoleA(hConsoleHandle, buffer, len, &numCharsWritten, NULL);
				lastPrintTime = currentTime;
			}
		}

		lastPresentTime = currentPresentTime;

#ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES
		{
			char buffer[128] = {0};
			const long double avgTimeSpentVertexShading_us = (totalVertexShadeTicks / (const long double)numVertexShadeTasks) / ldFreq * 1000000.0;
#pragma warning(push)
#pragma warning(disable:4996)
			sprintf(buffer, "%03.05gus average vertex shade time for %I64u vertices\n", avgTimeSpentVertexShading_us, numVertexShadeTasks);
#pragma warning(pop)
			OutputDebugStringA(buffer);

			totalVertexShadeTicks = 0;
			numVertexShadeTasks = 0;
		}
#endif // #ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES

#ifdef PROFILE_AVERAGE_PIXEL_SHADE_TIMES
		{
			char buffer[128] = {0};
			const long double avgTimeSpentPixelShading_us = (totalPixelShadeTicks / (const long double)numPixelShadeTasks) / ldFreq * 1000000.0;
#pragma warning(push)
#pragma warning(disable:4996)
			sprintf(buffer, "%03.05gus average pixel shade time for %I64u pixels\n", avgTimeSpentPixelShading_us, numPixelShadeTasks);
#pragma warning(pop)
			OutputDebugStringA(buffer);

			totalPixelShadeTicks = 0;
			numPixelShadeTasks = 0;
		}
#endif // #ifdef PROFILE_AVERAGE_PIXEL_SHADE_TIMES
	}

	frameStats.Clear();

	SIMPLE_FRAME_END_MARKER();

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::UpdateSurface(THIS_ IDirect3DSurface9* pSourceSurface, CONST RECT* pSourceRect, IDirect3DSurface9* pDestinationSurface, CONST POINT* pDestPoint)
{
	const IDirect3DSurface9Hook* const sourceHookPtr = dynamic_cast<IDirect3DSurface9Hook*>(pSourceSurface);
#ifdef _DEBUG
	if (sourceHookPtr)
#endif
		pSourceSurface = sourceHookPtr->GetUnderlyingSurface();
#ifdef _DEBUG
	else if (pSourceSurface != NULL)
	{
		DbgBreakPrint("Error: UpdateSurface called with a non-hooked surface source pointer");
	}
#endif

	IDirect3DSurface9Hook* const destHookPtr = dynamic_cast<IDirect3DSurface9Hook*>(pDestinationSurface);
#ifdef _DEBUG
	if (destHookPtr)
#endif
		pDestinationSurface = destHookPtr->GetUnderlyingSurface();
#ifdef _DEBUG
	else if (pDestinationSurface != NULL)
	{
		DbgBreakPrint("Error: UpdateSurface called with a non-hooked surface destination pointer");
	}
#endif

	HRESULT ret = d3d9dev->UpdateSurface(pSourceSurface, pSourceRect, pDestinationSurface, pDestPoint);
	if (FAILED(ret) )
		return ret;

	destHookPtr->UpdateSurfaceInternal(sourceHookPtr, pSourceRect, pDestPoint);

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::UpdateTexture(THIS_ IDirect3DBaseTexture9* pSourceTexture, IDirect3DBaseTexture9* pDestinationTexture)
{
	const IDirect3DTexture9Hook* const sourceHookPtr = dynamic_cast<IDirect3DTexture9Hook*>(pSourceTexture);
#ifdef _DEBUG
	if (sourceHookPtr)
#endif
		pSourceTexture = sourceHookPtr->GetUnderlyingTexture();
#ifdef _DEBUG
	else if (pSourceTexture != NULL)
	{
		DbgBreakPrint("Error: UpdateTexture called with a non-hooked texture source pointer");
	}
#endif

	IDirect3DTexture9Hook* const destHookPtr = dynamic_cast<IDirect3DTexture9Hook*>(pDestinationTexture);
#ifdef _DEBUG
	if (destHookPtr)
#endif
		pDestinationTexture = destHookPtr->GetUnderlyingTexture();
#ifdef _DEBUG
	else if (pDestinationTexture != NULL)
	{
		DbgBreakPrint("Error: UpdateTexture called with a non-hooked texture destination pointer");
	}
#endif

	HRESULT ret = d3d9dev->UpdateTexture(pSourceTexture, pDestinationTexture);
	if (FAILED(ret) )
		return ret;

	destHookPtr->UpdateTextureInternal(sourceHookPtr);

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::StretchRect(THIS_ IDirect3DSurface9* pSourceSurface, CONST RECT* pSourceRect, IDirect3DSurface9* pDestSurface, CONST RECT* pDestRect, D3DTEXTUREFILTERTYPE Filter)
{
	switch (Filter)
	{
	case D3DTEXF_NONE:
	case D3DTEXF_POINT:
	case D3DTEXF_LINEAR:
		break;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: StretchRect only supports NONE, POINT, and LINEAR filters");
#endif
		return D3DERR_INVALIDCALL;
	}

	if (!pSourceSurface)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Missing source surface!");
#endif
		return D3DERR_INVALIDCALL;
	}

	if (!pDestSurface)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Missing destination surface!");
#endif
		return D3DERR_INVALIDCALL;
	}

	const IDirect3DSurface9Hook* const hookSource = dynamic_cast<IDirect3DSurface9Hook*>(pSourceSurface);
	if (!hookSource)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Source surface is not hooked!");
#endif
		return D3DERR_INVALIDCALL;
	}

	IDirect3DSurface9Hook* const hookDest = dynamic_cast<IDirect3DSurface9Hook*>(pDestSurface);
	if (!hookDest)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Destination surface is not hooked!");
#endif
		return D3DERR_INVALIDCALL;
	}

	const unsigned Width = hookSource->GetInternalWidth();
	const unsigned Height = hookSource->GetInternalHeight();
	const unsigned DestWidth = hookDest->GetInternalWidth();
	const unsigned DestHeight = hookDest->GetInternalHeight();

	// Simple and common copy case of copying an entire surface over to another entire surface (D3DX9 uses this internally a lot for format conversions
	// and to save from D3DPOOL_DEFAULT to D3DPOOL_SYSMEM surfaces)
	if (!pSourceRect && !pDestRect)
	{
		D3DXVECTOR4 tempColor;
		for (unsigned y = 0; y < Height; ++y)
		{
			for (unsigned x = 0; x < Width; ++x)
			{
				hookSource->GetPixelVec<D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA, false>(x, y, tempColor);
				hookDest->SetPixelVec<D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA>(x, y, tempColor);
			}
		}
		return S_OK;
	}

	RECT srcRect = {0};
	if (pSourceRect)
		srcRect = *pSourceRect;
	else
	{
		srcRect.right = Width;
		srcRect.bottom = Height;
	}

	RECT destRect = {0};
	if (pDestRect)
		destRect = *pDestRect;
	else
	{
		destRect.right = Width;
		destRect.bottom = Height;
	}

	const int srcWidth = srcRect.right - srcRect.left;
	const int srcHeight = srcRect.bottom - srcRect.top;
	const int destWidth = destRect.right - destRect.left;
	const int destHeight = destRect.bottom - destRect.top;

	if (srcWidth <= 0 || srcHeight <= 0)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid source rect");
#endif
		return D3DERR_INVALIDCALL;
	}

	if (srcWidth > (const int)Width || srcHeight > (const int)Height)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Source rect extends outside of source surface bounds");
#endif
		return D3DERR_INVALIDCALL;
	}

	if (destWidth <= 0 || destHeight <= 0)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid dest rect");
#endif
		return D3DERR_INVALIDCALL;
	}

	if (destWidth > (const int)DestWidth || destHeight > (const int)DestHeight)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Destination rect extends outside of destination surface bounds");
#endif
		return D3DERR_INVALIDCALL;
	}

	const int copyIterationsWidth = srcWidth < destWidth ? srcWidth : destWidth;
	const int copyIterationsHeight = srcHeight < destHeight ? srcHeight : destHeight;

	D3DXVECTOR4 tempColor;
	for (int y = 0; y < copyIterationsHeight; ++y)
	{
		for (int x = 0; x < copyIterationsWidth; ++x)
		{
			hookSource->GetPixelVec<D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA, false>(srcRect.left + x, srcRect.top + y, tempColor);
			hookDest->SetPixelVec<D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA>(destRect.left + x, destRect.top + y, tempColor);
		}
	}

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::ColorFill(THIS_ IDirect3DSurface9* pSurface, CONST RECT* pRect, D3DCOLOR color)
{
	IDirect3DSurface9Hook* hookPtr = dynamic_cast<IDirect3DSurface9Hook*>(pSurface);
	if (hookPtr)
		pSurface = hookPtr->GetUnderlyingSurface();
#ifdef _DEBUG
	else if (pSurface != NULL)
	{
		DbgBreakPrint("Error: ColorFill called with a non-hooked surface pointer");
	}
#endif

	HRESULT ret = d3d9dev->ColorFill(pSurface, pRect, color);
	if (FAILED(ret) )
		return ret;

	if (hookPtr)
	{
		if (pRect)
		{
			// Convert from RECT to D3DRECT:
			D3DRECT d3dr;
			d3dr.x1 = pRect->left;
			d3dr.x2 = pRect->right;
			d3dr.y1 = pRect->top;
			d3dr.y2 = pRect->bottom;
			hookPtr->InternalColorFill(color, &d3dr);
		}
		else
		{
			hookPtr->InternalColorFill(color, NULL);
		}		
	}

	return ret;
}

// In the case of a successful render-target set, the viewport is automatically resized to the
// size of the largest set render-target:
void IDirect3DDevice9Hook::AutoResizeViewport(void)
{
	D3DVIEWPORT9 currentViewport = currentState.cachedViewport.viewport;
	currentViewport.Width = 1;
	currentViewport.Height = 1;
	for (unsigned x = 0; x < D3D_MAX_SIMULTANEOUS_RENDERTARGETS; ++x)
	{
		IDirect3DSurface9Hook* renderTarget = currentState.currentRenderTargets[x];
		if (!renderTarget)
			continue;
		D3DSURFACE_DESC desc = {};
		renderTarget->GetDesc(&desc);
		if (desc.Width > currentViewport.Width)
			currentViewport.Width = desc.Width;
		if (desc.Height > currentViewport.Height)
			currentViewport.Height = desc.Height;
	}
	SetViewport(&currentViewport);
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::BeginScene(THIS)
{
	HRESULT ret = d3d9dev->BeginScene();
	if (FAILED(ret) )
		return ret;

	if (!HasBegunScene() )
		sceneBegun = TRUE;
#ifdef _DEBUG
	else
	{
		// Each BeginScene() needs to have an EndScene() pair to match it!
		DbgBreakPrint("Error: Calling BeginScene() without first calling EndScene()");
	}
#endif

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::EndScene(THIS)
{
	HRESULT ret = d3d9dev->EndScene();
	if (FAILED(ret) )
		return ret;

	if (HasBegunScene() )
		sceneBegun = FALSE;
#ifdef _DEBUG
	else
	{
		// Every EndScene() needs to have a BeginScene() pair to match it!
		DbgBreakPrint("Error: Trying to end a scene without first beginning one. Must call BeginScene() before calling EndScene()");
	}
#endif

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::Clear(THIS_ DWORD Count, CONST D3DRECT* pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil)
{
	const unsigned validClearFlags = D3DCLEAR_STENCIL | D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER;
	if (Flags & (~validClearFlags) )
		return D3DERR_INVALIDCALL; // These are the only D3DCLEAR flags valid for this function call

	if (Flags & (D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER) )
	{
		if (!currentState.currentDepthStencil)
			return D3DERR_INVALIDCALL;

		if (Flags & D3DCLEAR_ZBUFFER)
		{
			if (Z < 0.0f)
			{
				// Z-clear value must be between 0.0f and 1.0f!
				DbgBreakPrint("Error: Clear Z-value must be between 0.0f and 1.0f");
				return D3DERR_INVALIDCALL;
			}
			if (Z > 1.0f)
			{
				// Z-clear value must be between 0.0f and 1.0f!
				DbgBreakPrint("Error: Clear Z-value must be between 0.0f and 1.0f");
				return D3DERR_INVALIDCALL;
			}
		}
		if (Flags & D3DCLEAR_STENCIL)
		{
			if (!HasStencil(currentState.currentDepthStencil->GetInternalFormat() ) )
				return D3DERR_INVALIDCALL;

			// TODO: Stencil buffer clear value range validation (should only allow between 0 and 2^n)
		}
	}

	// TODO: If Scissor Test is enabled (D3DRS_SCISSORTEST), then clip input rects against scissor rect. Why?
	// Because in D3D9 (but not 10 and up), the Clear() call *is* affected by scissor testing.
	// Source: https://docs.microsoft.com/en-us/windows/desktop/direct3d9/scissor-test

	// TODO: Clip the clear rect against the viewport rect (in the case that the viewport rect is smaller than the render target)

	if (Count > 0)
	{
		if (!pRects)
		{
			// Count must be 0 if pRects are NULL!
			DbgBreakPrint("Error: Clear() Count must be 0 if pRects are NULL");
			return D3DERR_INVALIDCALL;
		}

		for (unsigned x = 0; x < Count; ++x)
		{
			// Validate rects
		}
	}
	else
	{
		if (pRects != NULL)
		{
			// pRects must be NULL if Count is 0!
			DbgBreakPrint("Error: Clear() pRects must be NULL if Count is 0");
			return D3DERR_INVALIDCALL;
		}
	}

	if (!(Flags & (D3DCLEAR_TARGET | D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER) ) )
	{
		// At least one of: Target, Stencil, ZBuffer must be set in the Clear() call flags!
		DbgBreakPrint("Error: Clear call requires at least one of the Target, Stencil, or ZBuffer flags");
		return D3DERR_INVALIDCALL;
	}

#ifdef _DEBUG
	HRESULT ret = d3d9dev->Clear(Count, pRects, Flags, Color, Z, Stencil);
	if (FAILED(ret) )
	{
		__debugbreak(); // We must've missed an error somewhere
		return ret;
	}
#endif
	bool rectFillsWholeRenderTarget = false;
	if (Count > 0 && pRects != NULL && (Flags & D3DCLEAR_TARGET) )
	{
		unsigned char rectFillsRenderTargets = 0;
		for (unsigned x = 0; x < D3D_MAX_SIMULTANEOUS_RENDERTARGETS; ++x)
		{
			const IDirect3DSurface9Hook* const currentRT = currentState.currentRenderTargets[x];
			if (currentRT)
			{
				const int surfWidth = (const int)currentRT->GetInternalWidth();
				const int surfHeight = (const int)currentRT->GetInternalHeight();

				// Look for any one rect that encompasses the entirety of the target surface
				for (unsigned y = 0; y < Count; ++y)
				{
					const D3DRECT& thisRect = pRects[y];

					if (thisRect.x1 <= 0 && thisRect.y1 <= 0 &&
						thisRect.x2 >= surfWidth && thisRect.y2 >= surfHeight)
					{
						++rectFillsRenderTargets;
						break;
					}
				}
			}
			else
				++rectFillsRenderTargets;
		}

		if (rectFillsRenderTargets == D3D_MAX_SIMULTANEOUS_RENDERTARGETS)
			rectFillsWholeRenderTarget = true;
	}

	bool rectFillsWholeDepthStencil = false;
	if (Count > 0 && pRects != NULL && (Flags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL) ) )
	{
		if (currentState.currentDepthStencil)
		{
			const int dsWidth = currentState.currentDepthStencil->GetInternalWidth();
			const int dsHeight = currentState.currentDepthStencil->GetInternalHeight();
			// Look for any one rect that encompasses the entirety of the target depthstencil buffer
			for (unsigned y = 0; y < Count; ++y)
			{
				const D3DRECT& thisRect = pRects[y];

				if (thisRect.x1 <= 0 && thisRect.y1 <= 0 &&
					thisRect.x2 >= dsWidth && thisRect.y2 >= dsHeight)
				{
					rectFillsWholeDepthStencil = true;
					break;
				}
			}
		}
	}

	if (Flags & D3DCLEAR_TARGET)
	{
		SIMPLE_NAME_SCOPE("Clear Target");

		// Quick and simple fill the whole surface!
		if (Count == 0 || pRects == NULL || rectFillsWholeRenderTarget)
		{
			for (unsigned x = 0; x < D3D_MAX_SIMULTANEOUS_RENDERTARGETS; ++x)
			{
				IDirect3DSurface9Hook* const currentRT = currentState.currentRenderTargets[x];
				if (currentRT)
				{
					currentRT->InternalColorFill(Color);
				}
			}
		}
		else
		{
			for (unsigned x = 0; x < D3D_MAX_SIMULTANEOUS_RENDERTARGETS; ++x)
			{
				IDirect3DSurface9Hook* const currentRT = currentState.currentRenderTargets[x];
				if (currentRT)
				{
					for (unsigned y = 0; y < Count; ++y)
					{
						const D3DRECT* clearRect = pRects + y;
						currentRT->InternalColorFill(Color, clearRect);
					}
				}
			}
		}
	}

	if (Flags & D3DCLEAR_ZBUFFER)
	{
		SIMPLE_NAME_SCOPE("Clear Z Buffer");

		// Quick and simple fill the whole depth buffer!
		if (Count == 0 || pRects == NULL || rectFillsWholeDepthStencil)
		{
			if (currentState.currentDepthStencil)
			{
				currentState.currentDepthStencil->InternalDepthFill(Z);
			}
		}
		else
		{
			if (currentState.currentDepthStencil)
			{
				for (unsigned y = 0; y < Count; ++y)
				{
					const D3DRECT* clearRect = pRects + y;
					currentState.currentDepthStencil->InternalDepthFill(Z, clearRect);
				}
			}
		}
	}

	if (Flags & D3DCLEAR_STENCIL)
	{
		SIMPLE_NAME_SCOPE("Clear Stencil Buffer");

		// Quick and simple fill the whole stencil buffer!
		if (Count == 0 || pRects == NULL || rectFillsWholeDepthStencil)
		{
			if (currentState.currentDepthStencil)
			{
				currentState.currentDepthStencil->InternalStencilFill(Stencil);
			}
		}
		else
		{
			if (currentState.currentDepthStencil)
			{
				for (unsigned y = 0; y < Count; ++y)
				{
					const D3DRECT* clearRect = pRects + y;
					currentState.currentDepthStencil->InternalStencilFill(Stencil, clearRect);
				}
			}
		}
	}	

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::BeginStateBlock(THIS)
{
	if (currentlyRecordingStateBlock != NULL)
	{
		// It is not legal to call BeginStateBlock() while you are in the middle of recording another state block. Call EndStateBlock() first to stop recording before you can call BeginStateBlock() again.
		// If you do this, then the call gets dropped and nothing happens.
		return D3DERR_INVALIDCALL;
	}
	
	HRESULT ret = d3d9dev->BeginStateBlock();
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	char buffer[256];
#pragma warning(push)
#pragma warning(disable:4996)
	sprintf(buffer, "BeginStateBlock()\n");
#pragma warning(pop)
	OutputDebugStringA(buffer);
#endif

	LPDIRECT3DSTATEBLOCK9 realStateBlock = NULL;
	void* const newStateBlockMemory = _aligned_malloc(sizeof(IDirect3DStateBlock9Hook), 16);
	if (newStateBlockMemory)
	{
		const bool isCompleteStateBlock = false;
		currentlyRecordingStateBlock = new (newStateBlockMemory) IDirect3DStateBlock9Hook(realStateBlock, this, isCompleteStateBlock);
		return ret;
	}
	else
		return D3DERR_OUTOFVIDEOMEMORY;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::EndStateBlock(THIS_ IDirect3DStateBlock9** ppSB)
{
	// It is not legal to call EndStateBlock() if you have not previously called BeginStateBlock() to begin recording a state block.
	if (currentlyRecordingStateBlock == NULL)
	{
		return D3DERR_INVALIDCALL;
	}

	if (ppSB)
	{
		LPDIRECT3DSTATEBLOCK9 realStateBlock = NULL;
		HRESULT ret = d3d9dev->EndStateBlock(&realStateBlock);
		if (FAILED(ret) )
			return ret;

		currentlyRecordingStateBlock->SetRealObject(realStateBlock);
		*ppSB = currentlyRecordingStateBlock;
		currentlyRecordingStateBlock = NULL;
		return ret;
	}
	else
		return D3DERR_INVALIDCALL;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::ValidateDevice(THIS_ DWORD* pNumPasses)
{
	HRESULT ret = d3d9dev->ValidateDevice(pNumPasses);
	return ret;
}

void StreamSource::CopyForCapture(const StreamSource& rhs)
{
	memcpy(this, &rhs, sizeof(*this) );
	if (vertexBuffer)
		vertexBuffer->AddRef();
}

void DeviceState::CaptureCopyState(const DeviceState& rhs)
{
	memcpy(this, &rhs, sizeof(*this) );
	if (lightInfoMap)
	{
		lightInfoMap = new std::map<UINT, LightInfo*>;
		*lightInfoMap = *(rhs.lightInfoMap);
	}
	for (unsigned x = 0; x < MAX_ENABLED_LIGHTS; ++x)
	{
		// TODO: Fix up the active enabled lights array so that it points into the new std::map rather than the old one
	}
	currentPaletteState.CaptureCopyTexturePaletteState(rhs.currentPaletteState);
	for (unsigned x = 0; x < MAX_D3D9_STREAMS; ++x)
	{
		currentStreams[x].CopyForCapture(rhs.currentStreams[x]);
		currentStreamEnds[x].ResetEndPointers();
	}
	currentSoftUPStream.CopyForCapture(rhs.currentSoftUPStream);
	currentSoftUPStreamEnd.ResetEndPointers();

	if (currentIndexBuffer) currentIndexBuffer->AddRef();
	if (currentSoftUPIndexBuffer) currentSoftUPIndexBuffer->AddRef();
	if (currentVertexShader) currentVertexShader->AddRef();
	if (currentPixelShader) currentPixelShader->AddRef();
	for (unsigned x = 0; x < MAX_NUM_SAMPLERS; ++x)
	{
		if (currentTextures[x]) currentTextures[x]->AddRef();
		if (currentCubeTextures[x]) currentCubeTextures[x]->AddRef();
		if (currentVolumeTextures[x]) currentVolumeTextures[x]->AddRef();
	}
	for (unsigned x = 0; x < D3D_MAX_SIMULTANEOUS_RENDERTARGETS; ++x)
	{
		if (currentRenderTargets[x]) currentRenderTargets[x]->AddRef();
	}
	if (currentDepthStencil) currentDepthStencil->AddRef();
	if (currentVertexDecl) currentVertexDecl->AddRef();
}

struct int2
{
	int x;
	int y;
};

struct ubyte4
{
	unsigned char x;
	unsigned char y;
	unsigned char z;
	unsigned char w;
};
static_assert(sizeof(ubyte4) == 4, "Error!");

struct short4
{
	short x, y, z, w;
};
static_assert(sizeof(short4) == 8, "Error!");

struct ushort4
{
	unsigned short x;
	unsigned short y;
	unsigned short z;
	unsigned short w;
};
static_assert(sizeof(ushort4) == 8, "Error!");

static const unsigned udec3mask = ( (1 << 10) - 1);
static const unsigned dec3mask = ( (1 << 9) - 1);
static inline void LoadElementToRegister(D3DXVECTOR4& outRegister, const D3DDECLTYPE elemType, const void* const data)
{
	switch (elemType)
	{
	case D3DDECLTYPE_FLOAT1    : // 1D float expanded to (value, 0., 0., 1.)
	{
		const float* const fData = (const float* const)data;
		outRegister.x = *fData;
		outRegister.y = 0.0f;
		outRegister.z = 0.0f;
		outRegister.w = 1.0f;
	}
		break;
	case D3DDECLTYPE_FLOAT2    : // 2D float expanded to (value, value, 0., 1.)
	{
		const float* const fData = (const float* const)data;
		outRegister.x = fData[0];
		outRegister.y = fData[1];
		outRegister.z = 0.0f;
		outRegister.w = 1.0f;
	}
		break;
	case D3DDECLTYPE_FLOAT3    : // 3D float expanded to (value, value, value, 1.)
	{
		const float* const fData = (const float* const)data;
		outRegister.x = fData[0];
		outRegister.y = fData[1];
		outRegister.z = fData[2];
		outRegister.w = 1.0f;
	}
		break;
	case D3DDECLTYPE_FLOAT4    : // 4D float
	{
		const D3DXVECTOR4* const vecData = (const D3DXVECTOR4* const)data;
		outRegister = *vecData;
	}
		break;
	case D3DDECLTYPE_D3DCOLOR  : // 4D packed unsigned bytes mapped to 0. to 1. range; Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
	{
		const D3DCOLOR* const colorData = (const D3DCOLOR* const)data;
		ColorDWORDToFloat4(*colorData, outRegister);
	}
		break;
	case D3DDECLTYPE_UBYTE4    : // 4D unsigned byte
	{
		const ubyte4* const ubyte4Data = (const ubyte4* const)data;
		outRegister.x = (const float)ubyte4Data->x;
		outRegister.y = (const float)ubyte4Data->y;
		outRegister.z = (const float)ubyte4Data->z;
		outRegister.w = (const float)ubyte4Data->w;
	}
		break;
	case D3DDECLTYPE_SHORT2    : // 2D signed short expanded to (value, value, 0., 1.)
	{
		const short4* const short4Data = (const short4* const)data;
		outRegister.x = (const float)short4Data->x;
		outRegister.y = (const float)short4Data->y;
		outRegister.z = 0.0f;
		outRegister.w = 1.0f;
	}
		break;
	case D3DDECLTYPE_SHORT4    : // 4D signed short
	{
		const short4* const short4Data = (const short4* const)data;
		outRegister.x = (const float)short4Data->x;
		outRegister.y = (const float)short4Data->y;
		outRegister.z = (const float)short4Data->z;
		outRegister.w = (const float)short4Data->w;
	}
		break;
	case D3DDECLTYPE_UBYTE4N   : // Each of 4 bytes is normalized by dividing to 255.0 
	{
		const ubyte4* const ubyte4Data = (const ubyte4* const)data;
		outRegister.x = ubyte4Data->x / 255.0f;
		outRegister.y = ubyte4Data->y / 255.0f;
		outRegister.z = ubyte4Data->z / 255.0f;
		outRegister.w = ubyte4Data->w / 255.0f;
	}
		break;
	case D3DDECLTYPE_SHORT2N   : // 2D signed short normalized (v[0]/32767.0,v[1]/32767.0,0,1)
	{
		const short4* const short4Data = (const short4* const)data;
		outRegister.x = short4Data->x / 32767.0f;
		outRegister.y = short4Data->y / 32767.0f;
		outRegister.z = 0.0f;
		outRegister.w = 1.0f;
	}
		break;
	case D3DDECLTYPE_SHORT4N   : // 4D signed short normalized (v[0]/32767.0,v[1]/32767.0,v[2]/32767.0,v[3]/32767.0)
	{
		const short4* const short4Data = (const short4* const)data;
		outRegister.x = short4Data->x / 32767.0f;
		outRegister.y = short4Data->y / 32767.0f;
		outRegister.z = short4Data->z / 32767.0f;
		outRegister.w = short4Data->w / 32767.0f;
	}
		break;
	case D3DDECLTYPE_USHORT2N  : // 2D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,0,1)
	{
		const ushort4* const ushort4Data = (const ushort4* const)data;
		outRegister.x = ushort4Data->x / 65535.0f;
		outRegister.y = ushort4Data->y / 65535.0f;
		outRegister.z = 0.0f;
		outRegister.w = 1.0f;
	}
		break;
	case D3DDECLTYPE_USHORT4N  : // 4D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,v[2]/65535.0,v[3]/65535.0)
	{
		const ushort4* const ushort4Data = (const ushort4* const)data;
		outRegister.x = ushort4Data->x / 65535.0f;
		outRegister.y = ushort4Data->y / 65535.0f;
		outRegister.z = ushort4Data->z / 65535.0f;
		outRegister.w = ushort4Data->w / 65535.0f;
	}
		break;
	case D3DDECLTYPE_UDEC3     : // 3D unsigned 10 10 10 format expanded to (value, value, value, 1)
	{
		const unsigned* const uData = (const unsigned* const)data;
		const unsigned x = *uData & udec3mask;
		const unsigned y = (*uData >> 10) & udec3mask;
		const unsigned z = (*uData >> 20) & udec3mask;
		outRegister.x = (const float)x;
		outRegister.y = (const float)y;
		outRegister.z = (const float)z;
		outRegister.w = 1.0f;
	}
		break;
	case D3DDECLTYPE_DEC3N     : // 3D signed 10 10 10 format normalized and expanded to (v[0]/511.0, v[1]/511.0, v[2]/511.0, 1)
	{
		const unsigned* const uData = (const unsigned* const)data;
		const unsigned xData = *uData & udec3mask;
		// TODO: Test this for negative DEC3N values to make sure that this sign-math is correct:
		const int xDatai = xData > dec3mask ? -(const int)xData : (const int)xData;
		const unsigned yData = (*uData >> 10) & udec3mask;
		const int yDatai = yData > dec3mask ? -(const int)yData : (const int)yData;
		const unsigned zData = (*uData >> 20) & udec3mask;
		const int zDatai = zData > dec3mask ? -(const int)zData : (const int)zData;
		outRegister.x = xDatai / 511.0f;
		outRegister.y = yDatai / 511.0f;
		outRegister.z = zDatai / 511.0f;
		outRegister.w = 1.0f;
	}
		break;
	case D3DDECLTYPE_FLOAT16_2 : // Two 16-bit floating point values, expanded to (value, value, 0, 1)
	{
		const D3DXVECTOR2_16F* const f16Data2 = (const D3DXVECTOR2_16F* const)data;
		outRegister = D3DXVECTOR4(*f16Data2);
		outRegister.z = 0.0f;
		outRegister.w = 1.0f;
	}
		break;
	case D3DDECLTYPE_FLOAT16_4 : // Four 16-bit floating point values
	{
		const D3DXVECTOR4_16F* const f16Data4 = (const D3DXVECTOR4_16F* const)data;
		outRegister = D3DXVECTOR4(*f16Data4);
	}
		break;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Undefined vertex decl element type");
#endif
	case D3DDECLTYPE_UNUSED    : // When the type field in a decl is unused.
	{
		// Default register initialization:
		outRegister = vertShaderInputRegisterDefault;
	}
		break;
	}
}

#ifdef RUN_SHADERS_IN_WARPS
static inline void LoadElementToRegister4(D3DXVECTOR4* const (&outRegister4)[4], const D3DDECLTYPE elemType, const void** const data4)
{
	switch (elemType)
	{
	case D3DDECLTYPE_FLOAT1    : // 1D float expanded to (value, 0., 0., 1.)
	{
		const float* const * const fData4 = (const float* const * const)data4;

		outRegister4[0]->x = fData4[0][0];
		outRegister4[1]->x = fData4[1][0];
		outRegister4[2]->x = fData4[2][0];
		outRegister4[3]->x = fData4[3][0];
		outRegister4[0]->y = 0.0f;
		outRegister4[1]->y = 0.0f;
		outRegister4[2]->y = 0.0f;
		outRegister4[3]->y = 0.0f;
		outRegister4[0]->z = 0.0f;
		outRegister4[1]->z = 0.0f;
		outRegister4[2]->z = 0.0f;
		outRegister4[3]->z = 0.0f;
		outRegister4[0]->w = 1.0f;
		outRegister4[1]->w = 1.0f;
		outRegister4[2]->w = 1.0f;
		outRegister4[3]->w = 1.0f;
	}
		break;
	case D3DDECLTYPE_FLOAT2    : // 2D float expanded to (value, value, 0., 1.)
	{
		const float* const * const fData4 = (const float* const * const)data4;

		outRegister4[0]->x = fData4[0][0];
		outRegister4[1]->x = fData4[1][0];
		outRegister4[2]->x = fData4[2][0];
		outRegister4[3]->x = fData4[3][0];
		outRegister4[0]->y = fData4[0][1];
		outRegister4[1]->y = fData4[1][1];
		outRegister4[2]->y = fData4[2][1];
		outRegister4[3]->y = fData4[3][1];
		outRegister4[0]->z = 0.0f;
		outRegister4[1]->z = 0.0f;
		outRegister4[2]->z = 0.0f;
		outRegister4[3]->z = 0.0f;
		outRegister4[0]->w = 1.0f;
		outRegister4[1]->w = 1.0f;
		outRegister4[2]->w = 1.0f;
		outRegister4[3]->w = 1.0f;
	}
		break;
	case D3DDECLTYPE_FLOAT3    : // 3D float expanded to (value, value, value, 1.)
	{
		const float* const * const fData4 = (const float* const * const)data4;
		outRegister4[0]->x = fData4[0][0];
		outRegister4[1]->x = fData4[1][0];
		outRegister4[2]->x = fData4[2][0];
		outRegister4[3]->x = fData4[3][0];
		outRegister4[0]->y = fData4[0][1];
		outRegister4[1]->y = fData4[1][1];
		outRegister4[2]->y = fData4[2][1];
		outRegister4[3]->y = fData4[3][1];
		outRegister4[0]->z = fData4[0][2];
		outRegister4[1]->z = fData4[1][2];
		outRegister4[2]->z = fData4[2][2];
		outRegister4[3]->z = fData4[3][2];
		outRegister4[0]->w = 1.0f;
		outRegister4[1]->w = 1.0f;
		outRegister4[2]->w = 1.0f;
		outRegister4[3]->w = 1.0f;
	}
		break;
	case D3DDECLTYPE_FLOAT4    : // 4D float
	{
		const D3DXVECTOR4** const vecData4 = (const D3DXVECTOR4** const)data4;
		*outRegister4[0] = *vecData4[0];
		*outRegister4[1] = *vecData4[1];
		*outRegister4[2] = *vecData4[2];
		*outRegister4[3] = *vecData4[3];
	}
		break;
	case D3DDECLTYPE_D3DCOLOR  : // 4D packed unsigned bytes mapped to 0. to 1. range; Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
	{
		const D3DCOLOR** const colorData4 = (const D3DCOLOR** const)data4;
		ColorDWORDToFloat4_4(colorData4, outRegister4);
	}
		break;
	case D3DDECLTYPE_UBYTE4    : // 4D unsigned byte
	{
		const ubyte4* const * const ubyte4Data4 = (const ubyte4* const * const)data4;
		outRegister4[0]->x = (const float)ubyte4Data4[0]->x;
		outRegister4[1]->x = (const float)ubyte4Data4[1]->x;
		outRegister4[2]->x = (const float)ubyte4Data4[2]->x;
		outRegister4[3]->x = (const float)ubyte4Data4[3]->x;
		outRegister4[0]->y = (const float)ubyte4Data4[0]->y;
		outRegister4[1]->y = (const float)ubyte4Data4[1]->y;
		outRegister4[2]->y = (const float)ubyte4Data4[2]->y;
		outRegister4[3]->y = (const float)ubyte4Data4[3]->y;
		outRegister4[0]->z = (const float)ubyte4Data4[0]->z;
		outRegister4[1]->z = (const float)ubyte4Data4[1]->z;
		outRegister4[2]->z = (const float)ubyte4Data4[2]->z;
		outRegister4[3]->z = (const float)ubyte4Data4[3]->z;
		outRegister4[0]->w = (const float)ubyte4Data4[0]->w;
		outRegister4[1]->w = (const float)ubyte4Data4[1]->w;
		outRegister4[2]->w = (const float)ubyte4Data4[2]->w;
		outRegister4[3]->w = (const float)ubyte4Data4[3]->w;
	}
		break;
	case D3DDECLTYPE_SHORT2    : // 2D signed short expanded to (value, value, 0., 1.)
	{
		const short4* const * const short4Data4 = (const short4* const * const)data4;
		outRegister4[0]->x = (const float)short4Data4[0]->x;
		outRegister4[1]->x = (const float)short4Data4[1]->x;
		outRegister4[2]->x = (const float)short4Data4[2]->x;
		outRegister4[3]->x = (const float)short4Data4[3]->x;
		outRegister4[0]->y = (const float)short4Data4[0]->y;
		outRegister4[1]->y = (const float)short4Data4[1]->y;
		outRegister4[2]->y = (const float)short4Data4[2]->y;
		outRegister4[3]->y = (const float)short4Data4[3]->y;
		outRegister4[0]->z = 0.0f;
		outRegister4[1]->z = 0.0f;
		outRegister4[2]->z = 0.0f;
		outRegister4[3]->z = 0.0f;
		outRegister4[0]->w = 1.0f;
		outRegister4[1]->w = 1.0f;
		outRegister4[2]->w = 1.0f;
		outRegister4[3]->w = 1.0f;
	}
		break;
	case D3DDECLTYPE_SHORT4    : // 4D signed short
	{
		const short4* const * const short4Data4 = (const short4* const * const)data4;
		outRegister4[0]->x = (const float)short4Data4[0]->x;
		outRegister4[1]->x = (const float)short4Data4[1]->x;
		outRegister4[2]->x = (const float)short4Data4[2]->x;
		outRegister4[3]->x = (const float)short4Data4[3]->x;
		outRegister4[0]->y = (const float)short4Data4[0]->y;
		outRegister4[1]->y = (const float)short4Data4[1]->y;
		outRegister4[2]->y = (const float)short4Data4[2]->y;
		outRegister4[3]->y = (const float)short4Data4[3]->y;
		outRegister4[0]->z = (const float)short4Data4[0]->z;
		outRegister4[1]->z = (const float)short4Data4[1]->z;
		outRegister4[2]->z = (const float)short4Data4[2]->z;
		outRegister4[3]->z = (const float)short4Data4[3]->z;
		outRegister4[0]->w = (const float)short4Data4[0]->w;
		outRegister4[1]->w = (const float)short4Data4[1]->w;
		outRegister4[2]->w = (const float)short4Data4[2]->w;
		outRegister4[3]->w = (const float)short4Data4[3]->w;
	}
		break;
	case D3DDECLTYPE_UBYTE4N   : // Each of 4 bytes is normalized by dividing to 255.0 
	{
		const ubyte4* const * const ubyte4Data4 = (const ubyte4* const * const)data4;
		outRegister4[0]->x = ubyte4Data4[0]->x / 255.0f;
		outRegister4[1]->x = ubyte4Data4[1]->x / 255.0f;
		outRegister4[2]->x = ubyte4Data4[2]->x / 255.0f;
		outRegister4[3]->x = ubyte4Data4[3]->x / 255.0f;
		outRegister4[0]->y = ubyte4Data4[0]->y / 255.0f;
		outRegister4[1]->y = ubyte4Data4[1]->y / 255.0f;
		outRegister4[2]->y = ubyte4Data4[2]->y / 255.0f;
		outRegister4[3]->y = ubyte4Data4[3]->y / 255.0f;
		outRegister4[0]->z = ubyte4Data4[0]->z / 255.0f;
		outRegister4[1]->z = ubyte4Data4[1]->z / 255.0f;
		outRegister4[2]->z = ubyte4Data4[2]->z / 255.0f;
		outRegister4[3]->z = ubyte4Data4[3]->z / 255.0f;
		outRegister4[0]->w = ubyte4Data4[0]->w / 255.0f;
		outRegister4[1]->w = ubyte4Data4[1]->w / 255.0f;
		outRegister4[2]->w = ubyte4Data4[2]->w / 255.0f;
		outRegister4[3]->w = ubyte4Data4[3]->w / 255.0f;
	}
		break;
	case D3DDECLTYPE_SHORT2N   : // 2D signed short normalized (v[0]/32767.0,v[1]/32767.0,0,1)
	{
		const short4* const * const short4Data4 = (const short4* const * const)data4;
		outRegister4[0]->x = short4Data4[0]->x / 32767.0f;
		outRegister4[1]->x = short4Data4[1]->x / 32767.0f;
		outRegister4[2]->x = short4Data4[2]->x / 32767.0f;
		outRegister4[3]->x = short4Data4[3]->x / 32767.0f;
		outRegister4[0]->y = short4Data4[0]->y / 32767.0f;
		outRegister4[1]->y = short4Data4[1]->y / 32767.0f;
		outRegister4[2]->y = short4Data4[2]->y / 32767.0f;
		outRegister4[3]->y = short4Data4[3]->y / 32767.0f;
		outRegister4[0]->z = 0.0f;
		outRegister4[1]->z = 0.0f;
		outRegister4[2]->z = 0.0f;
		outRegister4[3]->z = 0.0f;
		outRegister4[0]->w = 1.0f;
		outRegister4[1]->w = 1.0f;
		outRegister4[2]->w = 1.0f;
		outRegister4[3]->w = 1.0f;
	}
		break;
	case D3DDECLTYPE_SHORT4N   : // 4D signed short normalized (v[0]/32767.0,v[1]/32767.0,v[2]/32767.0,v[3]/32767.0)
	{
		const short4* const * const short4Data4 = (const short4* const * const)data4;
		outRegister4[0]->x = short4Data4[0]->x / 32767.0f;
		outRegister4[1]->x = short4Data4[1]->x / 32767.0f;
		outRegister4[2]->x = short4Data4[2]->x / 32767.0f;
		outRegister4[3]->x = short4Data4[3]->x / 32767.0f;
		outRegister4[0]->y = short4Data4[0]->y / 32767.0f;
		outRegister4[1]->y = short4Data4[1]->y / 32767.0f;
		outRegister4[2]->y = short4Data4[2]->y / 32767.0f;
		outRegister4[3]->y = short4Data4[3]->y / 32767.0f;
		outRegister4[0]->z = short4Data4[0]->z / 32767.0f;
		outRegister4[1]->z = short4Data4[1]->z / 32767.0f;
		outRegister4[2]->z = short4Data4[2]->z / 32767.0f;
		outRegister4[3]->z = short4Data4[3]->z / 32767.0f;
		outRegister4[0]->w = short4Data4[0]->w / 32767.0f;
		outRegister4[1]->w = short4Data4[1]->w / 32767.0f;
		outRegister4[2]->w = short4Data4[2]->w / 32767.0f;
		outRegister4[3]->w = short4Data4[3]->w / 32767.0f;
	}
		break;
	case D3DDECLTYPE_USHORT2N  : // 2D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,0,1)
	{
		const ushort4* const * const ushort4Data4 = (const ushort4* const * const)data4;
		outRegister4[0]->x = ushort4Data4[0]->x / 65535.0f;
		outRegister4[1]->x = ushort4Data4[1]->x / 65535.0f;
		outRegister4[2]->x = ushort4Data4[2]->x / 65535.0f;
		outRegister4[3]->x = ushort4Data4[3]->x / 65535.0f;
		outRegister4[0]->y = ushort4Data4[0]->y / 65535.0f;
		outRegister4[1]->y = ushort4Data4[1]->y / 65535.0f;
		outRegister4[2]->y = ushort4Data4[2]->y / 65535.0f;
		outRegister4[3]->y = ushort4Data4[3]->y / 65535.0f;
		outRegister4[0]->z = 0.0f;
		outRegister4[1]->z = 0.0f;
		outRegister4[2]->z = 0.0f;
		outRegister4[3]->z = 0.0f;
		outRegister4[0]->w = 1.0f;
		outRegister4[1]->w = 1.0f;
		outRegister4[2]->w = 1.0f;
		outRegister4[3]->w = 1.0f;
	}
		break;
	case D3DDECLTYPE_USHORT4N  : // 4D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,v[2]/65535.0,v[3]/65535.0)
	{
		const ushort4* const * const ushort4Data4 = (const ushort4* const * const)data4;
		outRegister4[0]->x = ushort4Data4[0]->x / 65535.0f;
		outRegister4[1]->x = ushort4Data4[1]->x / 65535.0f;
		outRegister4[2]->x = ushort4Data4[2]->x / 65535.0f;
		outRegister4[3]->x = ushort4Data4[3]->x / 65535.0f;
		outRegister4[0]->y = ushort4Data4[0]->y / 65535.0f;
		outRegister4[1]->y = ushort4Data4[1]->y / 65535.0f;
		outRegister4[2]->y = ushort4Data4[2]->y / 65535.0f;
		outRegister4[3]->y = ushort4Data4[3]->y / 65535.0f;
		outRegister4[0]->z = ushort4Data4[0]->z / 65535.0f;
		outRegister4[1]->z = ushort4Data4[1]->z / 65535.0f;
		outRegister4[2]->z = ushort4Data4[2]->z / 65535.0f;
		outRegister4[3]->z = ushort4Data4[3]->z / 65535.0f;
		outRegister4[0]->w = ushort4Data4[0]->w / 65535.0f;
		outRegister4[1]->w = ushort4Data4[1]->w / 65535.0f;
		outRegister4[2]->w = ushort4Data4[2]->w / 65535.0f;
		outRegister4[3]->w = ushort4Data4[3]->w / 65535.0f;
	}
		break;
	case D3DDECLTYPE_UDEC3     : // 3D unsigned 10 10 10 format expanded to (value, value, value, 1)
	{
		const unsigned* const * const uData4 = (const unsigned* const * const)data4;

		const unsigned x4[4] =
		{
			(*(uData4[0]) ) & udec3mask,
			(*(uData4[1]) ) & udec3mask,
			(*(uData4[2]) ) & udec3mask,
			(*(uData4[3]) ) & udec3mask
		};

		const unsigned y4[4] =
		{
			(*(uData4[0]) >> 10) & udec3mask,
			(*(uData4[1]) >> 10) & udec3mask,
			(*(uData4[2]) >> 10) & udec3mask,
			(*(uData4[3]) >> 10) & udec3mask
		};

		const unsigned z4[4] =
		{
			(*(uData4[0]) >> 20) & udec3mask,
			(*(uData4[1]) >> 20) & udec3mask,
			(*(uData4[2]) >> 20) & udec3mask,
			(*(uData4[3]) >> 20) & udec3mask
		};

		outRegister4[0]->x = (const float)x4[0];
		outRegister4[1]->x = (const float)x4[1];
		outRegister4[2]->x = (const float)x4[2];
		outRegister4[3]->x = (const float)x4[3];
		outRegister4[0]->y = (const float)y4[0];
		outRegister4[1]->y = (const float)y4[1];
		outRegister4[2]->y = (const float)y4[2];
		outRegister4[3]->y = (const float)y4[3];
		outRegister4[0]->z = (const float)z4[0];
		outRegister4[1]->z = (const float)z4[1];
		outRegister4[2]->z = (const float)z4[2];
		outRegister4[3]->z = (const float)z4[3];
		outRegister4[0]->w = 1.0f;
		outRegister4[1]->w = 1.0f;
		outRegister4[2]->w = 1.0f;
		outRegister4[3]->w = 1.0f;
	}
		break;
	case D3DDECLTYPE_DEC3N     : // 3D signed 10 10 10 format normalized and expanded to (v[0]/511.0, v[1]/511.0, v[2]/511.0, 1)
	{
		const unsigned* const * const uData4 = (const unsigned* const * const)data4;

		const unsigned xData4[4] =
		{
			*uData4[0] & udec3mask,
			*uData4[1] & udec3mask,
			*uData4[2] & udec3mask,
			*uData4[3] & udec3mask
		};

		// TODO: Test this for negative DEC3N values to make sure that this sign-math is correct:
		const int xDatai4[4] =
		{
			xData4[0] > dec3mask ? -(const int)xData4[0] : (const int)xData4[0],
			xData4[1] > dec3mask ? -(const int)xData4[1] : (const int)xData4[1],
			xData4[2] > dec3mask ? -(const int)xData4[2] : (const int)xData4[2],
			xData4[3] > dec3mask ? -(const int)xData4[3] : (const int)xData4[3]
		};

		const unsigned yData4[4] =
		{
			(*uData4[0] >> 10) & udec3mask,
			(*uData4[1] >> 10) & udec3mask,
			(*uData4[2] >> 10) & udec3mask,
			(*uData4[3] >> 10) & udec3mask
		};

		const int yDatai4[4] = 
		{
			yData4[0] > dec3mask ? -(const int)yData4[0] : (const int)yData4[0],
			yData4[1] > dec3mask ? -(const int)yData4[1] : (const int)yData4[1],
			yData4[2] > dec3mask ? -(const int)yData4[2] : (const int)yData4[2],
			yData4[3] > dec3mask ? -(const int)yData4[3] : (const int)yData4[3]
		};

		const unsigned zData4[4] =
		{
			(*uData4[0] >> 20) & udec3mask,
			(*uData4[1] >> 20) & udec3mask,
			(*uData4[2] >> 20) & udec3mask,
			(*uData4[3] >> 20) & udec3mask
		};

		const int zDatai4[4] = 
		{
			zData4[0] > dec3mask ? -(const int)zData4[0] : (const int)zData4[0],
			zData4[1] > dec3mask ? -(const int)zData4[1] : (const int)zData4[1],
			zData4[2] > dec3mask ? -(const int)zData4[2] : (const int)zData4[2],
			zData4[3] > dec3mask ? -(const int)zData4[3] : (const int)zData4[3]
		};

		outRegister4[0]->x = xDatai4[0] / 511.0f;
		outRegister4[1]->x = xDatai4[1] / 511.0f;
		outRegister4[2]->x = xDatai4[2] / 511.0f;
		outRegister4[3]->x = xDatai4[3] / 511.0f;
		outRegister4[0]->y = yDatai4[0] / 511.0f;
		outRegister4[1]->y = yDatai4[1] / 511.0f;
		outRegister4[2]->y = yDatai4[2] / 511.0f;
		outRegister4[3]->y = yDatai4[3] / 511.0f;
		outRegister4[0]->z = zDatai4[0] / 511.0f;
		outRegister4[1]->z = zDatai4[1] / 511.0f;
		outRegister4[2]->z = zDatai4[2] / 511.0f;
		outRegister4[3]->z = zDatai4[3] / 511.0f;
		outRegister4[0]->w = 1.0f;
		outRegister4[1]->w = 1.0f;
		outRegister4[2]->w = 1.0f;
		outRegister4[3]->w = 1.0f;
	}
		break;
	case D3DDECLTYPE_FLOAT16_2 : // Two 16-bit floating point values, expanded to (value, value, 0, 1)
	{
		const D3DXVECTOR2_16F* const * const f16Data2_4 = (const D3DXVECTOR2_16F* const * const)data4;

		const D3DXVECTOR4 tempVecs[4] =
		{
			D3DXVECTOR4(*f16Data2_4[0]),
			D3DXVECTOR4(*f16Data2_4[1]),
			D3DXVECTOR4(*f16Data2_4[2]),
			D3DXVECTOR4(*f16Data2_4[3])
		};

		outRegister4[0]->x = tempVecs[0].x;
		outRegister4[1]->x = tempVecs[1].x;
		outRegister4[2]->x = tempVecs[2].x;
		outRegister4[3]->x = tempVecs[3].x;
		outRegister4[0]->y = tempVecs[0].y;
		outRegister4[1]->y = tempVecs[1].y;
		outRegister4[2]->y = tempVecs[2].y;
		outRegister4[3]->y = tempVecs[3].y;
		outRegister4[0]->z = 0.0f;
		outRegister4[1]->z = 0.0f;
		outRegister4[2]->z = 0.0f;
		outRegister4[3]->z = 0.0f;
		outRegister4[0]->w = 1.0f;
		outRegister4[1]->w = 1.0f;
		outRegister4[2]->w = 1.0f;
		outRegister4[3]->w = 1.0f;
	}
		break;
	case D3DDECLTYPE_FLOAT16_4 : // Four 16-bit floating point values
	{
		const D3DXVECTOR2_16F* const * const f16Data2_4 = (const D3DXVECTOR2_16F* const * const)data4;

		const D3DXVECTOR4 tempVecs[4] =
		{
			D3DXVECTOR4(*f16Data2_4[0]),
			D3DXVECTOR4(*f16Data2_4[1]),
			D3DXVECTOR4(*f16Data2_4[2]),
			D3DXVECTOR4(*f16Data2_4[3])
		};

		outRegister4[0]->x = tempVecs[0].x;
		outRegister4[1]->x = tempVecs[1].x;
		outRegister4[2]->x = tempVecs[2].x;
		outRegister4[3]->x = tempVecs[3].x;
		outRegister4[0]->y = tempVecs[0].y;
		outRegister4[1]->y = tempVecs[1].y;
		outRegister4[2]->y = tempVecs[2].y;
		outRegister4[3]->y = tempVecs[3].y;
		outRegister4[0]->z = tempVecs[0].z;
		outRegister4[1]->z = tempVecs[1].z;
		outRegister4[2]->z = tempVecs[2].z;
		outRegister4[3]->z = tempVecs[3].z;
		outRegister4[0]->w = tempVecs[0].w;
		outRegister4[1]->w = tempVecs[1].w;
		outRegister4[2]->w = tempVecs[2].w;
		outRegister4[3]->w = tempVecs[3].w;
	}
		break;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Undefined vertex decl element type");
#endif
	case D3DDECLTYPE_UNUSED    : // When the type field in a decl is unused.
	{
		// Default register initialization:
		*outRegister4[0] = vertShaderInputRegisterDefault;
		*outRegister4[1] = vertShaderInputRegisterDefault;
		*outRegister4[2] = vertShaderInputRegisterDefault;
		*outRegister4[3] = vertShaderInputRegisterDefault;
	}
		break;
	}
}

static inline const void* const GetDefaultInputRegisterForType(const D3DDECLTYPE elemType)
{
	switch (elemType)
	{
	default:
	case D3DDECLTYPE_UNUSED:
#ifdef _DEBUG
	{
		__debugbreak(); // Should never be here!
	}
#else
		__assume(0);
#endif
	case D3DDECLTYPE_FLOAT1://    =  0,  // 1D float expanded to (value, 0., 0., 1.)
	case D3DDECLTYPE_FLOAT2://    =  1,  // 2D float expanded to (value, value, 0., 1.)
	case D3DDECLTYPE_FLOAT3://    =  2,  // 3D float expanded to (value, value, value, 1.)
	case D3DDECLTYPE_FLOAT4://    =  3,  // 4D float
		return &vertShaderInputRegisterDefault;
	case D3DDECLTYPE_D3DCOLOR://  =  4,  // 4D packed unsigned bytes mapped to 0. to 1. range. Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
	{
		static const D3DCOLOR defaultRegisterColor = D3DCOLOR_ARGB(255, 0, 0, 0);
		return &defaultRegisterColor;
	}
	case D3DDECLTYPE_UBYTE4://    =  5,  // 4D unsigned byte
	{
		static const BYTE defaultByte4[4] = { 0, 0, 0, 1 };
		return defaultByte4;
	}
	case D3DDECLTYPE_SHORT2://    =  6,  // 2D signed short expanded to (value, value, 0., 1.)
	case D3DDECLTYPE_SHORT4://    =  7,  // 4D signed short
	{
		static const short defaultSHORT4[4] = { 0, 0, 0, 1 };
		return defaultSHORT4;
	}
	case D3DDECLTYPE_UBYTE4N://   =  8,  // Each of 4 bytes is normalized by dividing to 255.0
	{
		static const BYTE defaultUBYTE4[4] = { 0, 0, 0, 255 };
		return defaultUBYTE4;
	}
	case D3DDECLTYPE_SHORT2N://   =  9,  // 2D signed short normalized (v[0]/32767.0,v[1]/32767.0,0,1)
	case D3DDECLTYPE_SHORT4N://   = 10,  // 4D signed short normalized (v[0]/32767.0,v[1]/32767.0,v[2]/32767.0,v[3]/32767.0)
	{
		static const short defaultSHORTN4[4] = { 0, 0, 0, 32767 };
		return defaultSHORTN4;
	}
    case D3DDECLTYPE_USHORT2N://  = 11,  // 2D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,0,1)
    case D3DDECLTYPE_USHORT4N://  = 12,  // 4D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,v[2]/65535.0,v[3]/65535.0)
	{
		static const unsigned short defaultUSHORTN4[4] = { 0, 0, 0, 65535 };
		return defaultUSHORTN4;
	}
    case D3DDECLTYPE_UDEC3://     = 13,  // 3D unsigned 10 10 10 format expanded to (value, value, value, 1)
    case D3DDECLTYPE_DEC3N://     = 14,  // 3D signed 10 10 10 format normalized and expanded to (v[0]/511.0, v[1]/511.0, v[2]/511.0, 1)
	{
		static const DWORD defaultDec3 = 0x00000000;
		return &defaultDec3;
	}
    case D3DDECLTYPE_FLOAT16_2:// = 15,  // Two 16-bit floating point values, expanded to (value, value, 0, 1)
    case D3DDECLTYPE_FLOAT16_4:// = 16,  // Four 16-bit floating point values
	{
		static const D3DXVECTOR4_16F defaultHalf4(D3DXFLOAT16(0.0f), D3DXFLOAT16(0.0f), D3DXFLOAT16(0.0f), D3DXFLOAT16(1.0f) );
		return &defaultHalf4;
	}
	}
}

static inline void LoadElementToRegister4Validated(D3DXVECTOR4* const (&outRegister4)[4], const D3DDECLTYPE elemType, const void** data4, const void* const streamEndPtr)
{
	const void* const defaultInputRegisterValue = GetDefaultInputRegisterForType(elemType);
	if (data4[0] > streamEndPtr)
		data4[0] = defaultInputRegisterValue;
	if (data4[1] > streamEndPtr)
		data4[1] = defaultInputRegisterValue;
	if (data4[2] > streamEndPtr)
		data4[2] = defaultInputRegisterValue;
	if (data4[3] > streamEndPtr)
		data4[3] = defaultInputRegisterValue;

	LoadElementToRegister4(outRegister4, elemType, data4);
}
#endif // #ifdef RUN_SHADERS_IN_WARPS

void IDirect3DDevice9Hook::LoadVertexInputElement(const DebuggableD3DVERTEXELEMENT9& element, const unsigned char* const dataPtr, const unsigned registerIndex, VShaderEngine* const vertShader) const
{
	const unsigned elementSize = IDirect3DVertexDeclaration9Hook::GetElementSizeFromType(element.Type);

	// TODO: Parse vertex shader bytecode to determine mapping between inputRegisters and element usages (and usage indices)
	D3DXVECTOR4* const elementPtr = &vertShader->inputRegisters[0].v[registerIndex];

#ifdef _DEBUG
	switch (element.Usage)
	{
	case D3DDECLUSAGE_POSITIONT:
	case D3DDECLUSAGE_POSITION:
	case D3DDECLUSAGE_PSIZE:
	case D3DDECLUSAGE_BLENDWEIGHT:
	case D3DDECLUSAGE_BLENDINDICES:
	case D3DDECLUSAGE_NORMAL:
	case D3DDECLUSAGE_TEXCOORD:
	case D3DDECLUSAGE_TANGENT:
	case D3DDECLUSAGE_BINORMAL:
	case D3DDECLUSAGE_COLOR:
	case D3DDECLUSAGE_FOG:
		break;
	default:
	case D3DDECLUSAGE_TESSFACTOR: // Unsupported
	case D3DDECLUSAGE_DEPTH:
	case D3DDECLUSAGE_SAMPLE:
		DbgBreakPrint("Error: Pixel-shader only vertex element detected in vertex shader declaration"); // These should be pixel-shader only
		break;
	}
#endif

	const void* const streamEndPtr = currentState.currentStreamEnds[element.Stream].dataTypeStreamEnds[element.Type];
	if (dataPtr > streamEndPtr)
	{
		elementPtr->x = 0.0f;
		elementPtr->y = 0.0f;
		elementPtr->z = 0.0f;
		elementPtr->w = 1.0f;
		return;
	}

	// Do the actual store:
	LoadElementToRegister(*elementPtr, element.Type, dataPtr);
}

#ifdef RUN_SHADERS_IN_WARPS
void IDirect3DDevice9Hook::LoadVertexInputElement4(const DebuggableD3DVERTEXELEMENT9& element, const unsigned char* dataPtr[4], const unsigned registerIndex, VShaderEngine* const vertShader) const
{
	const unsigned elementSize = IDirect3DVertexDeclaration9Hook::GetElementSizeFromType(element.Type);
	D3DXVECTOR4* const elementPtr4[4] = 
	{
		&vertShader->inputRegisters[0].v[registerIndex],
		&vertShader->inputRegisters[1].v[registerIndex],
		&vertShader->inputRegisters[2].v[registerIndex],
		&vertShader->inputRegisters[3].v[registerIndex]
	};

#ifdef _DEBUG
	switch (element.Usage)
	{
	case D3DDECLUSAGE_POSITIONT:
	case D3DDECLUSAGE_POSITION:
	case D3DDECLUSAGE_PSIZE:
	case D3DDECLUSAGE_BLENDWEIGHT:
	case D3DDECLUSAGE_BLENDINDICES:
	case D3DDECLUSAGE_NORMAL:
	case D3DDECLUSAGE_TEXCOORD:
	case D3DDECLUSAGE_TANGENT:
	case D3DDECLUSAGE_BINORMAL:
	case D3DDECLUSAGE_COLOR:
	case D3DDECLUSAGE_FOG:
		break;
	default:
	case D3DDECLUSAGE_TESSFACTOR: // Unsupported
	case D3DDECLUSAGE_DEPTH:
	case D3DDECLUSAGE_SAMPLE:
		DbgBreakPrint("Error: Pixel-shader only vertex element detected in vertex shader declaration"); // These should be pixel-shader only
		break;
	}
#endif

	// Do the actual store:
	const void* const streamEndPtr = currentState.currentStreamEnds[element.Stream].dataTypeStreamEnds[element.Type];
	LoadElementToRegister4Validated(elementPtr4, element.Type, (const void**)dataPtr, streamEndPtr);
}
#endif // #ifdef RUN_SHADERS_IN_WARPS

/*void IDirect3DDevice9Hook::StoreVertexOutputElement(const DebuggableD3DVERTEXELEMENT9& element, unsigned char* const outputPtr, const D3DDECLUSAGE usage, const unsigned usageIndex) const
{
	const unsigned elementSize = IDirect3DVertexDeclaration9Hook::GetElementSizeFromType(element.Type);
	const void* elementPtr = NULL;
	switch (usage)
	{
	case D3DDECLUSAGE_POSITIONT:
	case D3DDECLUSAGE_POSITION:
		elementPtr = &deviceMainVShaderEngine.outputRegisters->oPos;
		break;
	case D3DDECLUSAGE_PSIZE:
		elementPtr = &deviceMainVShaderEngine.outputRegisters->oPts;
		break;
	case D3DDECLUSAGE_BLENDWEIGHT:
	case D3DDECLUSAGE_BLENDINDICES:
	case D3DDECLUSAGE_NORMAL:
	case D3DDECLUSAGE_TEXCOORD:
	case D3DDECLUSAGE_TANGENT:
	case D3DDECLUSAGE_BINORMAL:
		elementPtr = &deviceMainVShaderEngine.outputRegisters->vs_interpolated_outputs.vs_2_0_outputs.oT[usageIndex];
		break;
	case D3DDECLUSAGE_COLOR:
		elementPtr = &deviceMainVShaderEngine.outputRegisters->vs_interpolated_outputs.vs_2_0_outputs.oD[usageIndex];
		break;
	case D3DDECLUSAGE_FOG:
		elementPtr = &deviceMainVShaderEngine.outputRegisters->oFog;
		break;
	default:
	case D3DDECLUSAGE_TESSFACTOR: // Unsupported
	case D3DDECLUSAGE_DEPTH:
	case D3DDECLUSAGE_SAMPLE:
		DbgBreakPrint("Error: Pixel-shader only vertex element detected in vertex shader declaration"); // These should be pixel-shader only
		break;
	}

	// Do the actual store:
	memcpy(outputPtr, elementPtr, elementSize);
}*/

void IDirect3DDevice9Hook::ApplyViewportTransform(D3DXVECTOR4& positionT) const
{
	// For reference, see this MSDN page that describes the D3D9 Viewport Transform: https://msdn.microsoft.com/en-us/library/windows/desktop/bb206341(v=vs.85).aspx

	const float reciprocalHomogenousW = 1.0f / positionT.w;

	// Scale [-1, 1] space to [0.5, width + 0.5] space
	positionT.x = positionT.x * reciprocalHomogenousW * currentState.cachedViewport.halfWidthF + currentState.cachedViewport.halfWidthF
#ifdef ADD_D3D9_HALFPIXEL_OFFSET
		+ 0.5f
#endif
		;

	// Scale [-1, 1] space to [0.5, height + 0.5] space
	positionT.y = positionT.y * reciprocalHomogenousW * -currentState.cachedViewport.halfHeightF + currentState.cachedViewport.halfHeightF // Note, do the Y-flip here
#ifdef ADD_D3D9_HALFPIXEL_OFFSET
		+ 0.5f
#endif
		;

	// Scale from [0, 1] space to [minZ, maxZ] space
	positionT.z = positionT.z * reciprocalHomogenousW * currentState.cachedViewport.zScale + currentState.cachedViewport.viewport.MinZ;

	// Store our reciprocal homogenous W coordinate in the W coord of our output transformed vertex for later use:
	positionT.w = reciprocalHomogenousW;
}

#ifdef RUN_SHADERS_IN_WARPS
// TODO: Rewrite this using SIMD operations
void IDirect3DDevice9Hook::ApplyViewportTransform4(D3DXVECTOR4* (&positionT4)[4]) const
{
	// For reference, see this MSDN page that describes the D3D9 Viewport Transform: https://msdn.microsoft.com/en-us/library/windows/desktop/bb206341(v=vs.85).aspx
	const float reciprocalHomogenousW4[4] = 
	{
		1.0f / positionT4[0]->w,
		1.0f / positionT4[1]->w,
		1.0f / positionT4[2]->w,
		1.0f / positionT4[3]->w,
	};

	// Scale [-1, 1] space to [0.5, width + 0.5] space
	positionT4[0]->x *= reciprocalHomogenousW4[0];
	positionT4[1]->x *= reciprocalHomogenousW4[1];
	positionT4[2]->x *= reciprocalHomogenousW4[2];
	positionT4[3]->x *= reciprocalHomogenousW4[3];
	positionT4[0]->x *= currentState.cachedViewport.halfWidthF;
	positionT4[1]->x *= currentState.cachedViewport.halfWidthF;
	positionT4[2]->x *= currentState.cachedViewport.halfWidthF;
	positionT4[3]->x *= currentState.cachedViewport.halfWidthF;
	positionT4[0]->x += currentState.cachedViewport.halfWidthF;
	positionT4[1]->x += currentState.cachedViewport.halfWidthF;
	positionT4[2]->x += currentState.cachedViewport.halfWidthF;
	positionT4[3]->x += currentState.cachedViewport.halfWidthF;
#ifdef ADD_D3D9_HALFPIXEL_OFFSET
	positionT4[0]->x += 0.5f;
	positionT4[1]->x += 0.5f;
	positionT4[2]->x += 0.5f;
	positionT4[3]->x += 0.5f;
#endif

	// Scale [-1, 1] space to [0.5, height + 0.5] space
	positionT4[0]->y *= reciprocalHomogenousW4[0];
	positionT4[1]->y *= reciprocalHomogenousW4[1];
	positionT4[2]->y *= reciprocalHomogenousW4[2];
	positionT4[3]->y *= reciprocalHomogenousW4[3];
	positionT4[0]->y *= -currentState.cachedViewport.halfHeightF;
	positionT4[1]->y *= -currentState.cachedViewport.halfHeightF;
	positionT4[2]->y *= -currentState.cachedViewport.halfHeightF;
	positionT4[3]->y *= -currentState.cachedViewport.halfHeightF;
	positionT4[0]->y += currentState.cachedViewport.halfHeightF; // Note, do the Y-flip here
	positionT4[1]->y += currentState.cachedViewport.halfHeightF;
	positionT4[2]->y += currentState.cachedViewport.halfHeightF;
	positionT4[3]->y += currentState.cachedViewport.halfHeightF;
#ifdef ADD_D3D9_HALFPIXEL_OFFSET
	positionT4[0]->y += 0.5f;
	positionT4[1]->y += 0.5f;
	positionT4[2]->y += 0.5f;
	positionT4[3]->y += 0.5f;
#endif

	// Scale from [0, 1] space to [minZ, maxZ] space
	positionT4[0]->z *= reciprocalHomogenousW4[0];
	positionT4[1]->z *= reciprocalHomogenousW4[1];
	positionT4[2]->z *= reciprocalHomogenousW4[2];
	positionT4[3]->z *= reciprocalHomogenousW4[3];
	positionT4[0]->z *= currentState.cachedViewport.zScale;
	positionT4[1]->z *= currentState.cachedViewport.zScale;
	positionT4[2]->z *= currentState.cachedViewport.zScale;
	positionT4[3]->z *= currentState.cachedViewport.zScale;
	positionT4[0]->z += currentState.cachedViewport.viewport.MinZ;
	positionT4[1]->z += currentState.cachedViewport.viewport.MinZ;
	positionT4[2]->z += currentState.cachedViewport.viewport.MinZ;
	positionT4[3]->z += currentState.cachedViewport.viewport.MinZ;

	// Store our reciprocal homogenous W coordinate in the W coord of our output transformed vertex for later use:
	positionT4[0]->w = reciprocalHomogenousW4[0];
	positionT4[1]->w = reciprocalHomogenousW4[1];
	positionT4[2]->w = reciprocalHomogenousW4[2];
	positionT4[3]->w = reciprocalHomogenousW4[3];
}
#endif // #ifdef RUN_SHADERS_IN_WARPS

template <const bool anyUserClipPlanesEnabled>
void IDirect3DDevice9Hook::ComputeVertexClipCodes(const D3DXVECTOR4& vertexPosition, VS_2_0_OutputRegisters* const shadedVertex) const
{
	const float W = vertexPosition.w;
	const float negW = -W;

	// TODO: Should BOTTOM and TOP be flipped here since clipping is performed prior to the viewport
	// transform which flips the Y-axis?

	VS_2_0_OutputRegisters::vertexClipUnion vertexClipLocal = {0};

	if (vertexPosition.x < negW)
		vertexClipLocal.clipCodesCombined |= D3DCS_LEFT;
	if (vertexPosition.x > W)
		vertexClipLocal.clipCodesCombined |= D3DCS_RIGHT;
	if (vertexPosition.y < negW)
		vertexClipLocal.clipCodesCombined |= D3DCS_BOTTOM;
	if (vertexPosition.y > W)
		vertexClipLocal.clipCodesCombined |= D3DCS_TOP;
	if (vertexPosition.z < 0.0f)
		vertexClipLocal.clipCodesCombined |= D3DCS_FRONT;
	if (vertexPosition.z > W)
		vertexClipLocal.clipCodesCombined |= D3DCS_BACK;

	if (anyUserClipPlanesEnabled)
	{
		for (unsigned char userClipPlaneIndex = 0; userClipPlaneIndex < MAX_USER_CLIP_PLANES_SUPPORTED; ++userClipPlaneIndex)
		{
			if (currentState.currentRenderStates.renderStatesUnion.namedStates.clipPlaneEnable & (1 << userClipPlaneIndex) )
			{
				float planeDistance;
				dp4(planeDistance, vertexPosition, *(const D3DXVECTOR4* const)&(currentState.currentClippingPlanes[userClipPlaneIndex]) );
				const bool clipSucceed = planeDistance >= 0.0f;
				const unsigned short clipSucceedDWORD = ( (const unsigned short)clipSucceed) << (6 + userClipPlaneIndex);
				vertexClipLocal.clipCodesCombined |= clipSucceedDWORD;
			}
		}
	}

	const float rhw = 1.0f / W;
	const float clipX = vertexPosition.x * rhw;
	const float clipY = vertexPosition.y * rhw;

	if (clipX < SUBPIXEL_MIN_VALUEF)
		vertexClipLocal.clipCodesCombined |= D3DCS_GBLEFT;
	if (clipX > SUBPIXEL_MAX_VALUEF)
		vertexClipLocal.clipCodesCombined |= D3DCS_GBRIGHT;
	if (clipY < SUBPIXEL_MIN_VALUEF)
		vertexClipLocal.clipCodesCombined |= D3DCS_GBTOP;
	if (clipY > SUBPIXEL_MAX_VALUEF)
		vertexClipLocal.clipCodesCombined |= D3DCS_GBBOTTOM;

	shadedVertex->vertexClip.clipCodesCombined = vertexClipLocal.clipCodesCombined;
}

#ifdef RUN_SHADERS_IN_WARPS
template <const bool anyUserClipPlanesEnabled>
void IDirect3DDevice9Hook::ComputeVertexClipCodes4(const D3DXVECTOR4* (&vertexPosition4)[4], VS_2_0_OutputRegisters* const (&shadedVerts)[4]) const
{
	VS_2_0_OutputRegisters::vertexClipUnion vertexClipLocal4[4] = {0};

	const float W4[4] =
	{
		vertexPosition4[0]->w,
		vertexPosition4[1]->w,
		vertexPosition4[2]->w,
		vertexPosition4[3]->w
	};

	const float negW4[4] =
	{
		-W4[0],
		-W4[1],
		-W4[2],
		-W4[3]
	};

	// TODO: Should BOTTOM and TOP be flipped here since clipping is performed prior to the viewport
	// transform which flips the Y-axis?

	if (vertexPosition4[0]->x < negW4[0]) vertexClipLocal4[0].clipCodesCombined |= D3DCS_LEFT;
	if (vertexPosition4[1]->x < negW4[1]) vertexClipLocal4[1].clipCodesCombined |= D3DCS_LEFT;
	if (vertexPosition4[2]->x < negW4[2]) vertexClipLocal4[2].clipCodesCombined |= D3DCS_LEFT;
	if (vertexPosition4[3]->x < negW4[3]) vertexClipLocal4[3].clipCodesCombined |= D3DCS_LEFT;

	if (vertexPosition4[0]->x > W4[0]) vertexClipLocal4[0].clipCodesCombined |= D3DCS_RIGHT;
	if (vertexPosition4[1]->x > W4[1]) vertexClipLocal4[1].clipCodesCombined |= D3DCS_RIGHT;
	if (vertexPosition4[2]->x > W4[2]) vertexClipLocal4[2].clipCodesCombined |= D3DCS_RIGHT;
	if (vertexPosition4[3]->x > W4[3]) vertexClipLocal4[3].clipCodesCombined |= D3DCS_RIGHT;

	if (vertexPosition4[0]->y < negW4[0]) vertexClipLocal4[0].clipCodesCombined |= D3DCS_BOTTOM;
	if (vertexPosition4[1]->y < negW4[1]) vertexClipLocal4[1].clipCodesCombined |= D3DCS_BOTTOM;
	if (vertexPosition4[2]->y < negW4[2]) vertexClipLocal4[2].clipCodesCombined |= D3DCS_BOTTOM;
	if (vertexPosition4[3]->y < negW4[3]) vertexClipLocal4[3].clipCodesCombined |= D3DCS_BOTTOM;

	if (vertexPosition4[0]->y > W4[0]) vertexClipLocal4[0].clipCodesCombined |= D3DCS_TOP;
	if (vertexPosition4[1]->y > W4[1]) vertexClipLocal4[1].clipCodesCombined |= D3DCS_TOP;
	if (vertexPosition4[2]->y > W4[2]) vertexClipLocal4[2].clipCodesCombined |= D3DCS_TOP;
	if (vertexPosition4[3]->y > W4[3]) vertexClipLocal4[3].clipCodesCombined |= D3DCS_TOP;

	if (vertexPosition4[0]->z < 0.0f) vertexClipLocal4[0].clipCodesCombined |= D3DCS_FRONT;
	if (vertexPosition4[1]->z < 0.0f) vertexClipLocal4[1].clipCodesCombined |= D3DCS_FRONT;
	if (vertexPosition4[2]->z < 0.0f) vertexClipLocal4[2].clipCodesCombined |= D3DCS_FRONT;
	if (vertexPosition4[3]->z < 0.0f) vertexClipLocal4[3].clipCodesCombined |= D3DCS_FRONT;

	if (vertexPosition4[0]->z > W4[0]) vertexClipLocal4[0].clipCodesCombined |= D3DCS_BACK;
	if (vertexPosition4[1]->z > W4[1]) vertexClipLocal4[1].clipCodesCombined |= D3DCS_BACK;
	if (vertexPosition4[2]->z > W4[2]) vertexClipLocal4[2].clipCodesCombined |= D3DCS_BACK;
	if (vertexPosition4[3]->z > W4[3]) vertexClipLocal4[3].clipCodesCombined |= D3DCS_BACK;

	if (anyUserClipPlanesEnabled)
	{
		for (unsigned char userClipPlaneIndex = 0; userClipPlaneIndex < MAX_USER_CLIP_PLANES_SUPPORTED; ++userClipPlaneIndex)
		{
			if (currentState.currentRenderStates.renderStatesUnion.namedStates.clipPlaneEnable & (1 << userClipPlaneIndex) )
			{
				float planeDistance4[4];
				dp4_4(planeDistance4, vertexPosition4, *(const D3DXVECTOR4* const)&(currentState.currentClippingPlanes[userClipPlaneIndex]) );
				const bool clipSucceed4[4] = 
				{
					planeDistance4[0] >= 0.0f,
					planeDistance4[1] >= 0.0f,
					planeDistance4[2] >= 0.0f,
					planeDistance4[3] >= 0.0f
				};
				const unsigned short clipSucceedDWORD4[4] = 
				{
					(const unsigned short)( ( (const unsigned short)clipSucceed4[0]) << (6 + userClipPlaneIndex) ),
					(const unsigned short)( ( (const unsigned short)clipSucceed4[1]) << (6 + userClipPlaneIndex) ),
					(const unsigned short)( ( (const unsigned short)clipSucceed4[2]) << (6 + userClipPlaneIndex) ),
					(const unsigned short)( ( (const unsigned short)clipSucceed4[3]) << (6 + userClipPlaneIndex) )
				};

				vertexClipLocal4[0].clipCodesCombined |= clipSucceedDWORD4[0];
				vertexClipLocal4[1].clipCodesCombined |= clipSucceedDWORD4[1];
				vertexClipLocal4[2].clipCodesCombined |= clipSucceedDWORD4[2];
				vertexClipLocal4[3].clipCodesCombined |= clipSucceedDWORD4[3];
			}
		}
	}

	const float rhw4[4] =
	{
		1.0f / W4[0],
		1.0f / W4[1],
		1.0f / W4[2],
		1.0f / W4[3]
	};

	const float clipX4[4] =
	{
		vertexPosition4[0]->x * rhw4[0],
		vertexPosition4[1]->x * rhw4[1],
		vertexPosition4[2]->x * rhw4[2],
		vertexPosition4[3]->x * rhw4[3]
	};

	const float clipY4[4] =
	{
		vertexPosition4[0]->y * rhw4[0],
		vertexPosition4[1]->y * rhw4[1],
		vertexPosition4[2]->y * rhw4[2],
		vertexPosition4[3]->y * rhw4[3]
	};

	if (clipX4[0] < SUBPIXEL_MIN_VALUEF) vertexClipLocal4[0].clipCodesCombined |= D3DCS_GBLEFT;
	if (clipX4[1] < SUBPIXEL_MIN_VALUEF) vertexClipLocal4[1].clipCodesCombined |= D3DCS_GBLEFT;
	if (clipX4[2] < SUBPIXEL_MIN_VALUEF) vertexClipLocal4[2].clipCodesCombined |= D3DCS_GBLEFT;
	if (clipX4[3] < SUBPIXEL_MIN_VALUEF) vertexClipLocal4[3].clipCodesCombined |= D3DCS_GBLEFT;

	if (clipX4[0] > SUBPIXEL_MAX_VALUEF) vertexClipLocal4[0].clipCodesCombined |= D3DCS_GBRIGHT;
	if (clipX4[1] > SUBPIXEL_MAX_VALUEF) vertexClipLocal4[1].clipCodesCombined |= D3DCS_GBRIGHT;
	if (clipX4[2] > SUBPIXEL_MAX_VALUEF) vertexClipLocal4[2].clipCodesCombined |= D3DCS_GBRIGHT;
	if (clipX4[3] > SUBPIXEL_MAX_VALUEF) vertexClipLocal4[3].clipCodesCombined |= D3DCS_GBRIGHT;

	if (clipY4[0] < SUBPIXEL_MIN_VALUEF) vertexClipLocal4[0].clipCodesCombined |= D3DCS_GBTOP;
	if (clipY4[1] < SUBPIXEL_MIN_VALUEF) vertexClipLocal4[1].clipCodesCombined |= D3DCS_GBTOP;
	if (clipY4[2] < SUBPIXEL_MIN_VALUEF) vertexClipLocal4[2].clipCodesCombined |= D3DCS_GBTOP;
	if (clipY4[3] < SUBPIXEL_MIN_VALUEF) vertexClipLocal4[3].clipCodesCombined |= D3DCS_GBTOP;

	if (clipY4[0] > SUBPIXEL_MAX_VALUEF) vertexClipLocal4[0].clipCodesCombined |= D3DCS_GBBOTTOM;
	if (clipY4[1] > SUBPIXEL_MAX_VALUEF) vertexClipLocal4[1].clipCodesCombined |= D3DCS_GBBOTTOM;
	if (clipY4[2] > SUBPIXEL_MAX_VALUEF) vertexClipLocal4[2].clipCodesCombined |= D3DCS_GBBOTTOM;
	if (clipY4[3] > SUBPIXEL_MAX_VALUEF) vertexClipLocal4[3].clipCodesCombined |= D3DCS_GBBOTTOM;

	shadedVerts[0]->vertexClip.clipCodesCombined = vertexClipLocal4[0].clipCodesCombined;
	shadedVerts[1]->vertexClip.clipCodesCombined = vertexClipLocal4[1].clipCodesCombined;
	shadedVerts[2]->vertexClip.clipCodesCombined = vertexClipLocal4[2].clipCodesCombined;
	shadedVerts[3]->vertexClip.clipCodesCombined = vertexClipLocal4[3].clipCodesCombined;
}
#endif // #ifdef RUN_SHADERS_IN_WARPS

template <const bool anyUserClipPlanesEnabled>
void IDirect3DDevice9Hook::ProcessVertexToBuffer(const DeclarationSemanticMapping& mapping, VShaderEngine* const vertShader, VS_2_0_OutputRegisters* const outputVert, const unsigned vertexIndex) const
{
	// Load input vert:
	const ShaderInfo& vertexShaderInfo = currentState.currentVertexShader->GetShaderInfo();
	const unsigned numDeclaredRegisters = vertexShaderInfo.declaredRegisters.size();
	for (unsigned x = 0; x < numDeclaredRegisters; ++x)
	{
		const DeclaredRegister& thisReg = vertexShaderInfo.declaredRegisters[x];

		if (thisReg.registerType != D3DSPR_INPUT)
			continue;

		const DebuggableD3DVERTEXELEMENT9* const element = mapping.vals[thisReg.usageType][thisReg.usageIndex];
		if (!element)
		{
			D3DXVECTOR4& loadRegister = vertShader->inputRegisters[0].v[thisReg.registerIndex];
			loadRegister = vertShaderInputRegisterDefault;
			continue;
		}

		const StreamSource& thisElementStream = currentState.currentStreams[element->Stream];
		if (thisElementStream.vertexBuffer != NULL)
		{
			const BYTE* const thisStreamBuffer = thisElementStream.vertexBuffer->GetInternalDataBuffer() + thisElementStream.streamOffset;
			const unsigned char* thisStreamVertStart = thisStreamBuffer + thisElementStream.streamStride * vertexIndex;
			LoadVertexInputElement(*element, thisStreamVertStart + element->Offset, thisReg.registerIndex, vertShader);
		}
		else
		{
			vertShader->inputRegisters[0].v[thisReg.registerIndex] = vertShaderInputRegisterDefault;
		}
	}

	// Very important to reset the state machine back to its original settings!
	vertShader->Reset(&outputVert, 1);

	// Run vertex shader:
#ifndef FORCE_INTERPRETED_VERTEX_SHADER
	if (currentState.currentVertexShader->jitShaderMain)
	{
		// JIT engine:
		currentState.currentVertexShader->jitShaderMain(*vertShader);
	}
	else
#endif
	{
		// Interpreter engine:
		while (vertShader->InterpreterExecStep1() );
	}

	// Apply the viewport transform to our vertex position:
#ifdef _DEBUG
	if (SkipVertexProcessing() )
	{
		DbgBreakPrint("Error: Shouldn't be processing this vertex!");
	}
#endif

	D3DXVECTOR4& vertexPosition = currentState.currentVertexShader->GetPosition(*outputVert);
	ComputeVertexClipCodes<anyUserClipPlanesEnabled>(vertexPosition, outputVert);
	ApplyViewportTransform(vertexPosition);
}

#ifdef RUN_SHADERS_IN_WARPS
template <const bool anyUserClipPlanesEnabled>
void IDirect3DDevice9Hook::ProcessVertexToBuffer4(const DeclarationSemanticMapping& mapping, VShaderEngine* const vertShader, VS_2_0_OutputRegisters* (&outputVerts)[4], const unsigned* const vertexIndex) const
{
	// Load input vert:
	const ShaderInfo& vertexShaderInfo = currentState.currentVertexShader->GetShaderInfo();
	const unsigned numDeclaredRegisters = vertexShaderInfo.declaredRegisters.size();
	for (unsigned x = 0; x < numDeclaredRegisters; ++x)
	{
		const DeclaredRegister& thisReg = vertexShaderInfo.declaredRegisters[x];

		if (thisReg.registerType != D3DSPR_INPUT)
			continue;

		const DebuggableD3DVERTEXELEMENT9* const element = mapping.vals[thisReg.usageType][thisReg.usageIndex];
		if (!element)
		{
			vertShader->inputRegisters[0].v[thisReg.registerIndex] = vertShaderInputRegisterDefault;
			vertShader->inputRegisters[1].v[thisReg.registerIndex] = vertShaderInputRegisterDefault;
			vertShader->inputRegisters[2].v[thisReg.registerIndex] = vertShaderInputRegisterDefault;
			vertShader->inputRegisters[3].v[thisReg.registerIndex] = vertShaderInputRegisterDefault;
			continue;
		}

		const StreamSource& thisElementStream = currentState.currentStreams[element->Stream];
		if (thisElementStream.vertexBuffer != NULL)
		{
			const BYTE* const thisStreamBuffer = thisElementStream.vertexBuffer->GetInternalDataBuffer() + thisElementStream.streamOffset;
			const unsigned char* thisStreamVertStart4[4] = 
			{
				thisStreamBuffer + thisElementStream.streamStride * vertexIndex[0] + element->Offset,
				thisStreamBuffer + thisElementStream.streamStride * vertexIndex[1] + element->Offset,
				thisStreamBuffer + thisElementStream.streamStride * vertexIndex[2] + element->Offset,
				thisStreamBuffer + thisElementStream.streamStride * vertexIndex[3] + element->Offset
			};
			LoadVertexInputElement4(*element, thisStreamVertStart4, thisReg.registerIndex, vertShader);
		}
		else
		{
			vertShader->inputRegisters[0].v[thisReg.registerIndex] = vertShaderInputRegisterDefault;
			vertShader->inputRegisters[1].v[thisReg.registerIndex] = vertShaderInputRegisterDefault;
			vertShader->inputRegisters[2].v[thisReg.registerIndex] = vertShaderInputRegisterDefault;
			vertShader->inputRegisters[3].v[thisReg.registerIndex] = vertShaderInputRegisterDefault;
		}
	}

	// Very important to reset the state machine back to its original settings!
	vertShader->Reset(outputVerts, 4);

	// Run vertex shader:
#ifndef FORCE_INTERPRETED_VERTEX_SHADER
	if (currentState.currentVertexShader->jitShaderMain4)
	{
		// JIT engine:
		currentState.currentVertexShader->jitShaderMain4(*vertShader);
	}
	else
#endif
	{
		// Interpreter engine:
		while (vertShader->InterpreterExecStep4() );
	}

	// Apply the viewport transform to our vertex position:
#ifdef _DEBUG
	if (SkipVertexProcessing() )
	{
		DbgBreakPrint("Error: Shouldn't be processing this vertex!");
	}
#endif

	D3DXVECTOR4* vertexPositions[4];
	currentState.currentVertexShader->GetPosition4(outputVerts, vertexPositions);
	ComputeVertexClipCodes4<anyUserClipPlanesEnabled>( (const D3DXVECTOR4* (&)[4])(vertexPositions), outputVerts);
	ApplyViewportTransform4(vertexPositions);
}
#endif // #ifdef RUN_SHADERS_IN_WARPS

#ifdef MULTITHREAD_SHADING
template <const bool canImmediateFlushJobs>
static inline slist_item* const GetNewWorkerJob(void)
{
	slist_item* const ret = &(allWorkItems[workStatus.currentWorkID++]);

	if (workStatus.currentWorkID >= MAX_NUM_JOBS)
	{
		if (!canImmediateFlushJobs)
		{
			MessageBoxA(NULL, "Error: Exhausted job pool. Cannot create more jobs.", "Error", MB_OK);
			__debugbreak();
		}
		else
		{
			SynchronizeThreads<4>();
		}
	}

	return ret;
}

void IDirect3DDevice9Hook::CreateNewVertexShadeJob(VS_2_0_OutputRegisters* const * const outputRegs, const unsigned* const vertexIndices, const workerJobType jobWidth) const
{
#ifdef _DEBUG
	if (jobWidth >= VERTEX_SHADE_JOB_MAX)
	{
		__debugbreak();
	}
#endif
	const unsigned char numVertsPerJob = (1 << (2 * jobWidth) );

	slist_item* const newItem = GetNewWorkerJob<false>();
	newItem->jobType = jobWidth;
	slist_item::_jobData::_vertexJobData& vertexJobData = newItem->jobData.vertexJobData;
#ifdef _DEBUG
	for (unsigned char x = 0; x < ARRAYSIZE(vertexJobData.outputRegs); ++x)
		vertexJobData.outputRegs[x] = NULL;
#endif
	for (unsigned char x = 0; x < numVertsPerJob; ++x)
		vertexJobData.outputRegs[x] = outputRegs[x];

#ifdef _DEBUG
	for (unsigned char x = 0; x < ARRAYSIZE(vertexJobData.vertexIndex); ++x)
		vertexJobData.vertexIndex[x] = 0xFFFFFFFF;
#endif
	for (unsigned char x = 0; x < numVertsPerJob; ++x)
		vertexJobData.vertexIndex[x] = vertexIndices[x];

	++workStatus.numJobs;
}

#if TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
void IDirect3DDevice9Hook::CreateNewTriangleRasterJob(const UINT primitiveID, const UINT vertID0, const UINT vertID1, const UINT vertID2, const bool rasterizeFromShader, const void* const vert0, const void* const vert1, const void* const vert2) const
{
	slist_item* const newItem = GetNewWorkerJob<false>();
	newItem->jobType = triangleRasterizeJob;
	slist_item::_jobData::_triangleRasterizeJobData& triangleRasterizeJobData = newItem->jobData.triangleRasterizeJobData;

	triangleRasterizeJobData.primitiveID = primitiveID;
	triangleRasterizeJobData.vertIndex0 = vertID0;
	triangleRasterizeJobData.vertIndex1 = vertID1;
	triangleRasterizeJobData.vertIndex2 = vertID2;

	if (rasterizeFromShader)
	{
		slist_item::_jobData::_triangleRasterizeJobData::_triangleRasterizeVerticesUnion::_triangleRasterizeFromShader& rasterizeFromShaderVerts = triangleRasterizeJobData.rasterVertices.triangleRasterizeFromShader;
		rasterizeFromShaderVerts.v0 = (const VS_2_0_OutputRegisters* const)vert0;
		rasterizeFromShaderVerts.v1 = (const VS_2_0_OutputRegisters* const)vert1;
		rasterizeFromShaderVerts.v2 = (const VS_2_0_OutputRegisters* const)vert2;
	}
	else
	{
		slist_item::_jobData::_triangleRasterizeJobData::_triangleRasterizeVerticesUnion::_triangleRasterizeFromStream& rasterizeFromStreamVerts = triangleRasterizeJobData.rasterVertices.triangleRasterizeFromStream;
		rasterizeFromStreamVerts.v0 = (const D3DXVECTOR4* const)vert0;
		rasterizeFromStreamVerts.v1 = (const D3DXVECTOR4* const)vert1;
		rasterizeFromStreamVerts.v2 = (const D3DXVECTOR4* const)vert2;
	}

	++workStatus.numJobs;
}
#endif // #if TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS

#endif // #ifdef MULTITHREAD_SHADING

void IDirect3DDevice9Hook::CreateNewPixelShadeJob(const unsigned x, const unsigned y, const __m128i barycentricAdjusted, const primitivePixelJobData* const primitiveData) const
{
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
	slist_item* const newItem = GetNewWorkerJob<true>();
	newItem->jobType = pixelShade1Job;
	slist_item::_jobData::_pixelJobData& pixelJobData = newItem->jobData.pixelJobData;
#ifdef _DEBUG
	if (!primitiveData)
	{
		__debugbreak();
	}
#endif
	pixelJobData.primitiveData = primitiveData;
	pixelJobData.x[0] = x;
	pixelJobData.y[0] = y;
	pixelJobData.barycentricCoords[0].b = barycentricAdjusted.m128i_i32[1];
	pixelJobData.barycentricCoords[0].c = barycentricAdjusted.m128i_i32[2];

	++workStatus.numJobs;
#else // #if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
	const __m128 barycentricFactors = _mm_mul_ps(_mm_cvtepi32_ps(barycentricAdjusted), _mm_set1_ps(primitiveData->barycentricNormalizeFactor) );
	const __m128 invZ = _mm_load_ps( (const float* const)&(primitiveData->invZ) );

#ifdef PROFILE_AVERAGE_PIXEL_SHADE_TIMES
	LARGE_INTEGER pixelStartTime;
	QueryPerformanceCounter(&pixelStartTime);
#endif // PROFILE_AVERAGE_PIXEL_SHADE_TIMES
	if (currentDrawCallData.pixelData.useShaderVerts)
		SetupPixel<true>(&deviceMainPShaderEngine, currentDrawCallData.pixelData.vs_to_ps_mappings.sourceAgnosticMapping, 
			x, y, barycentricFactors, currentDrawCallData.pixelData.offsetIntoVertexForOPosition_Bytes, 
			primitiveData->pixelShadeVertexData.shadeFromAgnostic.v0, primitiveData->pixelShadeVertexData.shadeFromAgnostic.v1, primitiveData->pixelShadeVertexData.shadeFromAgnostic.v2, invZ);
	else
		SetupPixel<false>(&deviceMainPShaderEngine, currentDrawCallData.pixelData.vs_to_ps_mappings.sourceAgnosticMapping, 
			x, y, barycentricFactors, currentDrawCallData.pixelData.offsetIntoVertexForOPosition_Bytes, 
			primitiveData->pixelShadeVertexData.shadeFromAgnostic.v0, primitiveData->pixelShadeVertexData.shadeFromAgnostic.v1, primitiveData->pixelShadeVertexData.shadeFromAgnostic.v2, invZ);
#ifdef PROFILE_AVERAGE_PIXEL_SHADE_TIMES
	LARGE_INTEGER pixelEndTime;
	QueryPerformanceCounter(&pixelEndTime);

	totalPixelShadeTicks += (pixelEndTime.QuadPart - pixelStartTime.QuadPart);
	++numPixelShadeTasks;
#endif // PROFILE_AVERAGE_PIXEL_SHADE_TIMES

#endif // #if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
}

#ifdef RUN_SHADERS_IN_WARPS
void IDirect3DDevice9Hook::CreateNewPixelShadeJob4(const __m128i x4, const __m128i y4, const __m128i (&barycentricsAdjusted4)[4], const primitivePixelJobData* const primitiveData) const
{
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
	slist_item* const newItem = GetNewWorkerJob<true>();
	newItem->jobType = pixelShade4Job;
	slist_item::_jobData::_pixelJobData& pixelJobData = newItem->jobData.pixelJobData;
#ifdef _DEBUG
	if (!primitiveData)
	{
		__debugbreak();
	}
#endif
	pixelJobData.primitiveData = primitiveData;
	pixelJobData.x[0] = x4.m128i_i32[0];
	pixelJobData.x[1] = x4.m128i_i32[1];
	pixelJobData.x[2] = x4.m128i_i32[0];
	pixelJobData.x[3] = x4.m128i_i32[1];
	pixelJobData.y[0] = y4.m128i_i32[0];
	pixelJobData.y[1] = y4.m128i_i32[0];
	pixelJobData.y[2] = y4.m128i_i32[2];
	pixelJobData.y[3] = y4.m128i_i32[2];
	pixelJobData.barycentricCoords[0].b = barycentricsAdjusted4[0].m128i_i32[1];
	pixelJobData.barycentricCoords[0].c = barycentricsAdjusted4[0].m128i_i32[2];
	pixelJobData.barycentricCoords[1].b = barycentricsAdjusted4[1].m128i_i32[1];
	pixelJobData.barycentricCoords[1].c = barycentricsAdjusted4[1].m128i_i32[2];
	pixelJobData.barycentricCoords[2].b = barycentricsAdjusted4[2].m128i_i32[1];
	pixelJobData.barycentricCoords[2].c = barycentricsAdjusted4[2].m128i_i32[2];
	pixelJobData.barycentricCoords[3].b = barycentricsAdjusted4[3].m128i_i32[1];
	pixelJobData.barycentricCoords[3].c = barycentricsAdjusted4[3].m128i_i32[2];

	++workStatus.numJobs;
#else // #if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
	const __m128 barycentricNormalizeFactor = _mm_set1_ps(primitiveData->barycentricNormalizeFactor);
	const __m128 barycentricCoords4[4] =
	{
		_mm_mul_ps(_mm_cvtepi32_ps(barycentricsAdjusted4[0]), barycentricNormalizeFactor),
		_mm_mul_ps(_mm_cvtepi32_ps(barycentricsAdjusted4[1]), barycentricNormalizeFactor),
		_mm_mul_ps(_mm_cvtepi32_ps(barycentricsAdjusted4[2]), barycentricNormalizeFactor),
		_mm_mul_ps(_mm_cvtepi32_ps(barycentricsAdjusted4[3]), barycentricNormalizeFactor)
	};
	const __m128 invZ = _mm_load_ps( (const float* const)&(primitiveData->invZ) );

	const primitivePixelJobData::_pixelShadeVertexData::_shadeFromAgnostic& verts = primitiveData->pixelShadeVertexData.shadeFromAgnostic;
	if (currentDrawCallData.pixelData.useShaderVerts)
		SetupPixel4<true>(&deviceMainPShaderEngine, currentDrawCallData.pixelData.vs_to_ps_mappings.sourceAgnosticMapping, x4, y4, barycentricCoords4, 
			currentDrawCallData.pixelData.offsetIntoVertexForOPosition_Bytes, verts.v0, verts.v1, verts.v2, invZ);
	else
		SetupPixel4<false>(&deviceMainPShaderEngine, currentDrawCallData.pixelData.vs_to_ps_mappings.sourceAgnosticMapping, x4, y4, barycentricCoords4, 
			currentDrawCallData.pixelData.offsetIntoVertexForOPosition_Bytes, verts.v0, verts.v1, verts.v2, invZ);
#endif // #if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
}
#endif // RUN_SHADERS_IN_WARPS

template <const bool shadeFromShader>
const primitivePixelJobData* const IDirect3DDevice9Hook::GetNewPrimitiveJobData(const void* const v0, const void* const v1, const void* const v2, const float barycentricNormalizeFactor, const UINT primitiveID, const bool VFace,
	const UINT vertex0index, const UINT vertex1index, const UINT vertex2index, const __m128 p0, const __m128 p1, const __m128 p2) const
{
#ifdef _DEBUG
	if (primitiveID >= ARRAYSIZE(allPrimitiveJobData) )
	{
		__debugbreak();
	}
#endif

	primitivePixelJobData& newPrimitiveData = allPrimitiveJobData[primitiveID];

	__m128 localInvZ;
	localInvZ.m128_f32[0] = p0.m128_f32[2];
	localInvZ.m128_f32[1] = p1.m128_f32[2];
	localInvZ.m128_f32[2] = p2.m128_f32[2];

	const __m128 zeroVec = _mm_setzero_ps();
	const __m128 localZ = _mm_div_ps(oneVec, localInvZ);
	const __m128 selectMaskZ = _mm_cmpeq_ps(zeroVec, localInvZ); // Members that equal zero will be set to 0xFF, members that don't will be set to 0x00
	const __m128 localInvZSelected = _mm_blendv_ps(localZ, maxDepth24Bit, selectMaskZ);
	newPrimitiveData.invZ = D3DXVECTOR3(localInvZSelected.m128_f32[0], localInvZSelected.m128_f32[1], localInvZSelected.m128_f32[2]);

	__m128 localInvW;
	localInvW.m128_f32[0] = p0.m128_f32[3];
	localInvW.m128_f32[1] = p1.m128_f32[3];
	localInvW.m128_f32[2] = p2.m128_f32[3];
	newPrimitiveData.invW = D3DXVECTOR3(localInvW.m128_f32[0], localInvW.m128_f32[1], localInvW.m128_f32[2]);

	if (shadeFromShader)
	{
		primitivePixelJobData::_pixelShadeVertexData::_shadeFromShader& thisShadeFromShader = newPrimitiveData.pixelShadeVertexData.shadeFromShader;
		thisShadeFromShader.v0 = static_cast<const VS_2_0_OutputRegisters* const>(v0);
		thisShadeFromShader.v1 = static_cast<const VS_2_0_OutputRegisters* const>(v1);
		thisShadeFromShader.v2 = static_cast<const VS_2_0_OutputRegisters* const>(v2);
	}
	else
	{
		primitivePixelJobData::_pixelShadeVertexData::_shadeFromStream& thisShadeFromStream = newPrimitiveData.pixelShadeVertexData.shadeFromStream;
		thisShadeFromStream.v0 = static_cast<CONST BYTE* const>(v0);
		thisShadeFromStream.v1 = static_cast<CONST BYTE* const>(v1);
		thisShadeFromStream.v2 = static_cast<CONST BYTE* const>(v2);
	}
	newPrimitiveData.vertex0index = vertex0index;
	newPrimitiveData.vertex1index = vertex1index;
	newPrimitiveData.vertex2index = vertex2index;
	newPrimitiveData.barycentricNormalizeFactor = barycentricNormalizeFactor;
	newPrimitiveData.primitiveID = primitiveID;
	newPrimitiveData.VFace = VFace;

	return &newPrimitiveData;
}

struct vertJobCollector
{
	VS_2_0_OutputRegisters* outputRegs;
	UINT vertexIndex;
};

static std::vector<vertJobCollector> vertJobsToShade;

static inline const UINT GetNumVertsUsed(const D3DPRIMITIVETYPE PrimitiveType, const UINT PrimitiveCount)
{
	switch (PrimitiveType)
	{
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Unknown primitive type specified");
#else
		__assume(0);
#endif
		// Intentional fallthrough
	case D3DPT_POINTLIST    :
		return PrimitiveCount;
	case D3DPT_LINELIST     :
		return PrimitiveCount * 2;
	case D3DPT_LINESTRIP    :
		return PrimitiveCount + 1;
	case D3DPT_TRIANGLELIST :
		return PrimitiveCount * 3;
	case D3DPT_TRIANGLESTRIP:
		return PrimitiveCount + 2;
	case D3DPT_TRIANGLEFAN  :
		return PrimitiveCount + 2;
	}
}

template <const bool useVertexBuffer, const D3DFORMAT indexFormat>
void IDirect3DDevice9Hook::ProcessVerticesToBufferInner(const IDirect3DVertexDeclaration9Hook* const decl, const DeclarationSemanticMapping& mapping, const BYTE* const indexBuffer,
	const D3DPRIMITIVETYPE PrimitiveType, const INT BaseVertexIndex, const UINT MinVertexIndex, const UINT startIndex, const UINT primCount, const void* const vertStreamBytes, const unsigned short vertStreamStride) const
{
	// How many processed verts does this draw call output?
	const unsigned numOutputVerts = GetNumVertsUsed(PrimitiveType, primCount);

#ifdef _DEBUG
	if (numOutputVerts < 3)
	{
		DbgBreakPrint("Error: Not enough verts processed to make a triangle");
	}
#endif

	processedVertsUsed = 0;
	if (numOutputVerts >= processVertsAllocated)
	{
		_mm_free(processedVertexBuffer);
		processedVertexBuffer = NULL;
		processedVertexBuffer = (VS_2_0_OutputRegisters* const)_mm_malloc(numOutputVerts * sizeof(VS_2_0_OutputRegisters), 16);
		processVertsAllocated = numOutputVerts;
	}
	processedVertsUsed = numOutputVerts;

	frameStats.numVertsProcessed += numOutputVerts;

	VS_2_0_OutputRegisters* const startOutputBuffer = processedVertexBuffer;
	VS_2_0_OutputRegisters* outputBufferPtr = processedVertexBuffer;

#ifdef _DEBUG
	if ( ( ( (const size_t)outputBufferPtr) & 0xF) != 0)
	{
		__debugbreak(); // Oh noes, our registers aren't aligned and this will break SSE instructions!
	}
#endif

	vertJobsToShade.clear();

	const bool anyUserClipPlanesEnabled = currentDrawCallData.vertexData.userClipPlanesEnabled;

	unsigned short* alreadyShadedVerts16Ptr
#ifdef _DEBUG
		= NULL
#endif
		;
	unsigned* alreadyShadedVerts32Ptr
#ifdef _DEBUG
		= NULL
#endif
		;

	if (indexFormat != D3DFMT_UNKNOWN)
	{
		switch (indexFormat)
		{
		case D3DFMT_INDEX16:
		{
			alreadyShadedVerts16->clear();

			const unsigned short* const bufferShorts = (const unsigned short* const)indexBuffer;
			for (unsigned x = 0; x < numOutputVerts; ++x)
			{
				// Uhhhh, this isn't correct except for point-lists, line-lists, and triangle-lists:
				const unsigned short index = bufferShorts[x + startIndex] + BaseVertexIndex;

				if (index >= alreadyShadedVerts16->size() )
				{
					alreadyShadedVerts16->resize(index + 1, 0xFFFF);
					alreadyShadedVerts16Ptr = &alreadyShadedVerts16->front();
				}

				if (alreadyShadedVerts16Ptr[index] != 0xFFFF)
				{
					// Do fix-ups after the loop, but only shade vertices once
					++frameStats.numVertsReused;
				}
				else
				{
					vertJobCollector newJob;
					newJob.outputRegs = outputBufferPtr;
					newJob.vertexIndex = index;
					vertJobsToShade.push_back(newJob);

					alreadyShadedVerts16Ptr[index] = x;
				}

				// Increment the registers pointer
				++outputBufferPtr;
			}
		}
			break;
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Undefined index buffer format");
#else
			__assume(0);
#endif
		case D3DFMT_INDEX32:
		{
			alreadyShadedVerts32->clear();

			const unsigned* const bufferLongs = (const unsigned* const)indexBuffer;
			for (unsigned x = 0; x < numOutputVerts; ++x)
			{
				// Uhhhh, this isn't correct except for point-lists, line-lists, and triangle-lists:
				const unsigned index = bufferLongs[x + startIndex] + BaseVertexIndex;

				if (index >= alreadyShadedVerts32->size() )
				{
					alreadyShadedVerts32->resize(index + 1, 0xFFFFFFFF);
					alreadyShadedVerts32Ptr = &alreadyShadedVerts32->front();
				}

				if (alreadyShadedVerts32Ptr[index] != 0xFFFFFFFF)
				{
					// Do fix-ups after the loop, but only shade vertices once
					++frameStats.numVertsReused;
				}
				else
				{
					vertJobCollector newJob;
					newJob.outputRegs = outputBufferPtr;
					newJob.vertexIndex = index;
					vertJobsToShade.push_back(newJob);

					alreadyShadedVerts32Ptr[index] = x;
				}

				// Increment the registers pointer
				++outputBufferPtr;
			}
		}
			break;
		}
	}
	else
	{
		for (unsigned x = 0; x < numOutputVerts; ++x)
		{
			// Uhhhh, this isn't correct except for point-lists, line-lists, and triangle-lists:
			vertJobCollector newJob;
			newJob.outputRegs = outputBufferPtr;
			newJob.vertexIndex = x + BaseVertexIndex;
			vertJobsToShade.push_back(newJob);

			// Increment the registers pointer
			++outputBufferPtr;
		}
	}

	//numWorkItems = numOutputVerts;
	//InterlockedExchange(&numWorkItems, numOutputVerts);
	//PulseEvent(notifyJobsBeginEvent); // TODO: Replace PulseEvent with something safer
	/*SetEvent(notifyJobsBeginEvent);
	ResetEvent(notifyJobsBeginEvent);
	WaitForSingleObject(notifyAllJobsCompletedEvent, INFINITE);
	ResetEvent(notifyAllJobsCompletedEvent);
	if (numWorkItems != 0)
	{
		__debugbreak();
	}*/
	const unsigned numNewJobs = vertJobsToShade.size();

#ifdef RUN_SHADERS_IN_WARPS
	if (!deviceMainVShaderEngine.GetShaderInfo()->usesDynamicBranching && !deviceMainVShaderEngine.GetShaderInfo()->usesInstructionPredication)
	{
		for (unsigned x = 0; x < numNewJobs;)
		{
			const unsigned jobsRemaining = numNewJobs - x;
			/*if (jobsRemaining >= 64)
			{
				UINT vertexIndices[64];
				const vertJobCollector& thisNewJob = vertJobsToShade[x];
				for (unsigned char y = 0; y < 64; ++y)
					vertexIndices[y] = (&thisNewJob)[y].vertexIndex;
				CreateNewVertexShadeJob(thisNewJob.outputRegs, vertexIndices, vertexShade64Job);
				x += 64;
			}
			else if (jobsRemaining >= 16)
			{
				UINT vertexIndices[16];
				const vertJobCollector& thisNewJob = vertJobsToShade[x];
				for (unsigned char y = 0; y < 16; ++y)
					vertexIndices[y] = (&thisNewJob)[y].vertexIndex;
				CreateNewVertexShadeJob(thisNewJob.outputRegs, vertexIndices, vertexShade16Job);
				x += 16;
			}
			else */if (jobsRemaining >= 4)
			{
				UINT vertexIndices[4];
				VS_2_0_OutputRegisters* outputRegs[4];
				const vertJobCollector& thisNewJob = vertJobsToShade[x];
				for (unsigned char y = 0; y < 4; ++y)
				{
					vertexIndices[y] = (&thisNewJob)[y].vertexIndex;
					outputRegs[y] = (&thisNewJob)[y].outputRegs;
#ifdef _DEBUG
					if ( ( ( (const size_t)outputRegs[y]) & 0xF) != 0)
					{
						__debugbreak(); // Oh noes, our registers aren't aligned and this will break SSE instructions!
					}
#endif
				}
#ifdef MULTITHREAD_SHADING
				CreateNewVertexShadeJob(outputRegs, vertexIndices, vertexShade4Job);
#else // #ifdef MULTITHREAD_SHADING

#ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES
				LARGE_INTEGER vertexShadeStartTime;
				QueryPerformanceCounter(&vertexShadeStartTime);
#endif // #ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES

				if (anyUserClipPlanesEnabled)
					ProcessVertexToBuffer4<true>(mapping, &deviceMainVShaderEngine, outputRegs, vertexIndices);
				else
					ProcessVertexToBuffer4<false>(mapping, &deviceMainVShaderEngine, outputRegs, vertexIndices);

#ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES
				LARGE_INTEGER vertexShadeEndTime;
				QueryPerformanceCounter(&vertexShadeEndTime);

				totalVertexShadeTicks += (vertexShadeEndTime.QuadPart - vertexShadeStartTime.QuadPart);
				numVertexShadeTasks += 4;
#endif // #ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES

#endif // #ifdef MULTITHREAD_SHADING
				x += 4;
			}
			else
			{
				const vertJobCollector& thisNewJob = vertJobsToShade[x];
#ifdef MULTITHREAD_SHADING
				CreateNewVertexShadeJob(&thisNewJob.outputRegs, &thisNewJob.vertexIndex, vertexShade1Job);
#else // #ifdef MULTITHREAD_SHADING

#ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES
				LARGE_INTEGER vertexShadeStartTime;
				QueryPerformanceCounter(&vertexShadeStartTime);
#endif // #ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES

				if (anyUserClipPlanesEnabled)
					ProcessVertexToBuffer<true>(mapping, &deviceMainVShaderEngine, thisNewJob.outputRegs, thisNewJob.vertexIndex);
				else
					ProcessVertexToBuffer<false>(mapping, &deviceMainVShaderEngine, thisNewJob.outputRegs, thisNewJob.vertexIndex);

#ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES
				LARGE_INTEGER vertexShadeEndTime;
				QueryPerformanceCounter(&vertexShadeEndTime);

				totalVertexShadeTicks += (vertexShadeEndTime.QuadPart - vertexShadeStartTime.QuadPart);
				++numVertexShadeTasks;
#endif // #ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES

#endif // #ifdef MULTITHREAD_SHADING
				++x;
			}
		}
	}
	else // We don't currently support branching in our warp-jobs
#endif // #ifdef RUN_SHADERS_IN_WARPS
	{
		for (unsigned x = 0; x < numNewJobs; ++x)
		{
			const vertJobCollector& thisNewJob = vertJobsToShade[x];
#ifdef MULTITHREAD_SHADING
			CreateNewVertexShadeJob(&thisNewJob.outputRegs, &thisNewJob.vertexIndex, vertexShade1Job);
#else // #ifdef MULTITHREAD_SHADING

#ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES
			LARGE_INTEGER vertexShadeStartTime;
			QueryPerformanceCounter(&vertexShadeStartTime);
#endif // #ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES

			if (anyUserClipPlanesEnabled)
				ProcessVertexToBuffer<true>(mapping, &deviceMainVShaderEngine, thisNewJob.outputRegs, thisNewJob.vertexIndex);
			else
				ProcessVertexToBuffer<false>(mapping, &deviceMainVShaderEngine, thisNewJob.outputRegs, thisNewJob.vertexIndex);

#ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES
			LARGE_INTEGER vertexShadeEndTime;
			QueryPerformanceCounter(&vertexShadeEndTime);

			totalVertexShadeTicks += (vertexShadeEndTime.QuadPart - vertexShadeStartTime.QuadPart);
			++numVertexShadeTasks;
#endif // #ifdef PROFILE_AVERAGE_VERTEX_SHADE_TIMES

#endif // #ifdef MULTITHREAD_SHADING
		}
	}

#ifdef MULTITHREAD_SHADING
	//CloseThreadpoolCleanupGroupMembers(cleanup, FALSE, NULL);
	//RefreshThreadpoolWork();
	{
		SynchronizeThreads<4>();
	}
#endif // #ifdef MULTITHREAD_SHADING

	// This is the "fixup phase" that's necessary to populate all of the vertex copies through here
	// This avoids shading re-used vertices more than once and saves *a ton* of processing power in not reshading! :)

	// TODO: Avoiding the "fixup phase" of processvertices would save time (roughly 1/3rd of the total cost of ProcessVerticesToBufferInner), at the added complexity
	// to DrawPrimitiveUB(), which would then need to know how to walk index buffers. Doing this would also save on memory bandwidth.
	{
		if (indexFormat != D3DFMT_UNKNOWN)
		{
			switch (indexFormat)
			{
			case D3DFMT_INDEX16:
			{
				const unsigned short* const bufferShorts = (const unsigned short* const)indexBuffer;
				for (unsigned x = 0; x < numOutputVerts; ++x)
				{
					// Uhhhh, this isn't correct except for point-lists, line-lists, and triangle-lists:
					const unsigned short index = bufferShorts[x + startIndex] + BaseVertexIndex;

					if (alreadyShadedVerts16Ptr[index] != x)
					{
						startOutputBuffer[x] = startOutputBuffer[alreadyShadedVerts16Ptr[index] ];
					}
				}
			}
				break;
			default:
#ifdef _DEBUG
				DbgBreakPrint("Error: Undefined index buffer format");
#else
				__assume(0);
#endif
			case D3DFMT_INDEX32:
			{
				const unsigned* const bufferLongs = (const unsigned* const)indexBuffer;
				for (unsigned x = 0; x < numOutputVerts; ++x)
				{
					// Uhhhh, this isn't correct except for point-lists, line-lists, and triangle-lists:
					const unsigned index = bufferLongs[x + startIndex] + BaseVertexIndex;

					if (alreadyShadedVerts32Ptr[index] != x)
					{
						startOutputBuffer[x] = startOutputBuffer[alreadyShadedVerts32Ptr[index] ];
					}
				}
			}
				break;
			}
		}
	}

#ifdef DEBUG_VERTEX_OUT_POSITIONS
	for (unsigned x = 0; x < outputVerts.size(); ++x)
	{
		const D3DXVECTOR4& finalVertPos = currentState.currentVertexShader->GetPosition(outputVerts[x]);
		char buffer[256] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(buffer, "Vert %u final pos: (%f, %f, %f)\n", x, finalVertPos.x, finalVertPos.y, finalVertPos.z);
#pragma warning(pop)
		OutputDebugString(buffer);
	}
#endif
}

template <const bool useVertexBuffer, const bool useIndexBuffer>
void IDirect3DDevice9Hook::ProcessVerticesToBuffer(const IDirect3DVertexDeclaration9Hook* const decl, const DeclarationSemanticMapping& mapping, const IDirect3DIndexBuffer9Hook* const indexBuffer, 
	const D3DPRIMITIVETYPE PrimitiveType, const INT BaseVertexIndex, const UINT MinVertexIndex, const UINT startIndex, const UINT primCount, const void* const vertStreamBytes, const unsigned short vertStreamStride) const
{
	SIMPLE_FUNC_SCOPE();

	if (useIndexBuffer)
	{
		switch (indexBuffer->GetFormat() )
		{
		default:
#ifdef _DEBUG
			__debugbreak(); // Should never be here!
#else
			__assume(0);
#endif
		case D3DFMT_INDEX16:
			ProcessVerticesToBufferInner<useVertexBuffer, D3DFMT_INDEX16>(decl, mapping, indexBuffer->GetBufferBytes(), PrimitiveType, BaseVertexIndex, MinVertexIndex, startIndex, primCount, vertStreamBytes, vertStreamStride);
			break;
		case D3DFMT_INDEX32:
			ProcessVerticesToBufferInner<useVertexBuffer, D3DFMT_INDEX32>(decl, mapping, indexBuffer->GetBufferBytes(), PrimitiveType, BaseVertexIndex, MinVertexIndex, startIndex, primCount, vertStreamBytes, vertStreamStride);
			break;
		}
	}
	else
	{
		ProcessVerticesToBufferInner<useVertexBuffer, D3DFMT_UNKNOWN>(decl, mapping, NULL, PrimitiveType, BaseVertexIndex, MinVertexIndex, startIndex, primCount, vertStreamBytes, vertStreamStride);
	}
}

void IDirect3DDevice9Hook::InitVertexShader(const DeviceState& deviceState, const ShaderInfo& vertexShaderInfo) const
{
	deviceMainVShaderEngine.Init(deviceState, vertexShaderInfo, &vsDrawCallCB);

#ifdef MULTITHREAD_SHADING
	for (unsigned x = 0; x < ARRAYSIZE(threadItem); ++x)
	{
		threadItem[x].threadVS_2_0 = deviceMainVShaderEngine;
	}
#endif
}

void IDirect3DDevice9Hook::InitPixelShader(const DeviceState& deviceState, const ShaderInfo& pixelShaderInfo) const
{
	deviceMainPShaderEngine.Init(deviceState, pixelShaderInfo, &psDrawCallCB);

#ifdef MULTITHREAD_SHADING
	for (unsigned x = 0; x < ARRAYSIZE(threadItem); ++x)
	{
		threadItem[x].threadPS_2_0 = deviceMainPShaderEngine;
	}
#endif
}

COM_DECLSPEC_NOTHROW void IDirect3DDevice9Hook::SetupCurrentDrawCallVertexData(const DeclarationSemanticMapping& mapping)
{
	currentDrawCallData.vertexData.userClipPlanesEnabled = currentState.currentRenderStates.renderStatesUnion.namedStates.clipPlaneEnable > 0;
	currentDrawCallData.vertexData.mapping = &mapping;
}

COM_DECLSPEC_NOTHROW void IDirect3DDevice9Hook::SetupCurrentDrawCallPixelData(const bool useShaderVerts, const void* const vs_to_ps_mapping) const
{
	currentDrawCallData.pixelData.useShaderVerts = useShaderVerts;
	if (useShaderVerts)
	{
		currentDrawCallData.pixelData.offsetIntoVertexForOPosition_Bytes = currentState.currentVertexShader->GetOPosOffset_Bytes();
		currentDrawCallData.pixelData.vs_to_ps_mappings.vs_psMapping = static_cast<const VStoPSMapping* const>(vs_to_ps_mapping);
	}
	else
	{
		currentDrawCallData.pixelData.offsetIntoVertexForOPosition_Bytes = 0;// currentState.currentVertexDecl->GetStream0Float4PositionTOffset();
		currentDrawCallData.pixelData.vs_to_ps_mappings.vertexDeclMapping = static_cast<const DeclarationSemanticMapping* const>(vs_to_ps_mapping);
	}
}

COM_DECLSPEC_NOTHROW void IDirect3DDevice9Hook::SetupCurrentDrawCallTriangleRasterizeData(const float fWidth, const float fHeight, const bool rasterizerUsesEarlyZTest, const bool rasterizeTriangleFromShader, const void* const interpolantDeclInfo) const
{
	currentDrawCallData.triangleRasterizeData.fWidth = fWidth;
	currentDrawCallData.triangleRasterizeData.fHeight = fHeight;
	if (rasterizeTriangleFromShader)
		currentDrawCallData.triangleRasterizeData.vStoPSMapping = (const VStoPSMapping* const)interpolantDeclInfo;
	else
		currentDrawCallData.triangleRasterizeData.vertexDeclMapping = (const DeclarationSemanticMapping* const)interpolantDeclInfo;
	currentDrawCallData.triangleRasterizeData.rasterizerUsesEarlyZTest = rasterizerUsesEarlyZTest;
	currentDrawCallData.triangleRasterizeData.rasterizeTriangleFromShader = rasterizeTriangleFromShader;
}

// Counts the number of 32-bit DWORD's for each of the D3DDECLTYPE's
static unsigned char typeSize_DWORDs[MAXD3DDECLTYPE] =
{
	1 * sizeof(DWORD),// D3DDECLTYPE_FLOAT1    =  0,  // 1D float expanded to (value, 0., 0., 1.)
    2 * sizeof(DWORD),// D3DDECLTYPE_FLOAT2    =  1,  // 2D float expanded to (value, value, 0., 1.)
    3 * sizeof(DWORD),// D3DDECLTYPE_FLOAT3    =  2,  // 3D float expanded to (value, value, value, 1.)
    4 * sizeof(DWORD),// D3DDECLTYPE_FLOAT4    =  3,  // 4D float
    1 * sizeof(DWORD),// D3DDECLTYPE_D3DCOLOR  =  4,  // 4D packed unsigned bytes mapped to 0. to 1. range
									// Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
    1 * sizeof(DWORD),// D3DDECLTYPE_UBYTE4    =  5,  // 4D unsigned byte
    1 * sizeof(DWORD),// D3DDECLTYPE_SHORT2    =  6,  // 2D signed short expanded to (value, value, 0., 1.)
    2 * sizeof(DWORD),// D3DDECLTYPE_SHORT4    =  7,  // 4D signed short

	// The following types are valid only with vertex shaders >= 2.0
    1 * sizeof(DWORD),// D3DDECLTYPE_UBYTE4N   =  8,  // Each of 4 bytes is normalized by dividing to 255.0
    1 * sizeof(DWORD),// D3DDECLTYPE_SHORT2N   =  9,  // 2D signed short normalized (v[0]/32767.0,v[1]/32767.0,0,1)
    2 * sizeof(DWORD),// D3DDECLTYPE_SHORT4N   = 10,  // 4D signed short normalized (v[0]/32767.0,v[1]/32767.0,v[2]/32767.0,v[3]/32767.0)
    1 * sizeof(DWORD),// D3DDECLTYPE_USHORT2N  = 11,  // 2D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,0,1)
    2 * sizeof(DWORD),// D3DDECLTYPE_USHORT4N  = 12,  // 4D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,v[2]/65535.0,v[3]/65535.0)
    1 * sizeof(DWORD),// D3DDECLTYPE_UDEC3     = 13,  // 3D unsigned 10 10 10 format expanded to (value, value, value, 1)
    1 * sizeof(DWORD),// D3DDECLTYPE_DEC3N     = 14,  // 3D signed 10 10 10 format normalized and expanded to (v[0]/511.0, v[1]/511.0, v[2]/511.0, 1)
    1 * sizeof(DWORD),// D3DDECLTYPE_FLOAT16_2 = 15,  // Two 16-bit floating point values, expanded to (value, value, 0, 1)
    2 * sizeof(DWORD) // D3DDECLTYPE_FLOAT16_4 = 16,  // Four 16-bit floating point values
};

static inline void ComputeCachedStreamEnd(StreamDataTypeEndPointers& thisStreamEnd, const BYTE* const streamBegin, const unsigned streamLenBytes)
{
	if (streamBegin != NULL && streamLenBytes != 0)
	{
		thisStreamEnd.streamEndAbsolute = streamBegin + streamLenBytes;
		for (unsigned x = 0; x < ARRAYSIZE(thisStreamEnd.dataTypeStreamEnds); ++x)
		{
			const D3DDECLTYPE thisType = (const D3DDECLTYPE)x;
			thisStreamEnd.dataTypeStreamEnds[thisType] = thisStreamEnd.streamEndAbsolute - typeSize_DWORDs[thisType];
		}
	}
	else
	{
		thisStreamEnd.streamEndAbsolute = NULL;
		for (unsigned x = 0; x < ARRAYSIZE(thisStreamEnd.dataTypeStreamEnds); ++x)
		{
			const D3DDECLTYPE thisType = (const D3DDECLTYPE)x;
			thisStreamEnd.dataTypeStreamEnds[thisType] = NULL;
		}
	}
}

void IDirect3DDevice9Hook::RecomputeCachedStreamEndsIfDirty()
{
	SIMPLE_FUNC_SCOPE();

	if (!currentState.currentVertexDecl)
	{
		__debugbreak(); // Should never be calling this function if we don't have a vertex decl
	}

	const std::vector<DebuggableD3DVERTEXELEMENT9>& elements = currentState.currentVertexDecl->GetElementsInternal();
	const unsigned numElements = elements.size() - 1; // Minus one here because we want to ignore the D3DDECL_END element
	for (unsigned x = 0; x < numElements; ++x)
	{
		const DebuggableD3DVERTEXELEMENT9& thisElement = elements[x];
		StreamDataTypeEndPointers& thisStreamEnd = currentState.currentStreamEnds[thisElement.Stream];

		// Only recompute for dirty streams:
		if (thisStreamEnd.dirty)
		{
			const IDirect3DVertexBuffer9Hook* const currentStreamVB = currentState.currentStreams[thisElement.Stream].vertexBuffer;
			if (currentStreamVB)
				ComputeCachedStreamEnd(thisStreamEnd, currentStreamVB->GetInternalDataBuffer(), currentStreamVB->GetInternalLength_Bytes() );
			else
				ComputeCachedStreamEnd(thisStreamEnd, NULL, 0);

			// Clear the dirty flag when we have computed all of the pointers
			thisStreamEnd.dirty = false;
		}
	}
}

void IDirect3DDevice9Hook::RecomputeCachedStreamEndsForUP(const BYTE* const stream0Data, const unsigned numVertices, const USHORT vertexStride)
{
	if (!currentState.currentVertexDecl)
	{
		__debugbreak(); // Should never be calling this function if we don't have a vertex decl
	}

	ComputeCachedStreamEnd(currentState.currentStreamEnds[0], stream0Data, numVertices * vertexStride);
}

// Returns true for "should draw", or false for "should skip"
const bool IDirect3DDevice9Hook::TotalDrawCallSkipTest(void) const
{
	SIMPLE_FUNC_SCOPE();

#ifdef ENABLE_END_TO_SKIP_DRAWS
	// Skip this draw call if END is held down
	if (IsHoldingEndToSkipDrawCalls() )
		return false;
#endif // #ifdef ENABLE_END_TO_SKIP_DRAWS

	const bool DepthWriteEnabled = (currentState.currentDepthStencil != NULL) && currentState.currentRenderStates.renderStatesUnion.namedStates.zWriteEnable;
	if (DepthWriteEnabled)
	{
		if (currentState.currentRenderStates.renderStatesUnion.namedStates.zFunc == D3DCMP_NEVER)
			return false; // TODO: Check for stencil enable and stencil zFail here
	}
	else
	{
		// If we're only writing color (no depth), then early-out if we have no writemask
		if (currentState.currentRenderStates.renderStatesUnion.namedStates.colorWriteEnable == 0x00)
			return false;
	}

	if (!DepthWriteEnabled)
	{
		if (currentState.currentPixelShader != NULL)
		{
			const ShaderInfo& pixelShaderInfo = currentState.currentPixelShader->GetShaderInfo();
			bool allUnbound = true;
			for (unsigned x = 0; x < D3D_MAX_SIMULTANEOUS_RENDERTARGETS; ++x)
			{
				if (pixelShaderInfo.usedMRTMask & (1 << x) )
				{
					if (currentState.currentRenderTargets[x])
					{
						allUnbound = false;
						break;
					}
				}
			}
			if (allUnbound)
				return false;
		}
		else
		{
			if (!currentState.currentRenderTargets[0])
				return false;
		}
	}

	switch (currentState.currentRenderStates.renderStatesUnion.namedStates.cullmode)
	{
	case D3DCULL_NONE:
	case D3DCULL_CW:
	case D3DCULL_CCW:
		break;
	default:
#ifdef _DEBUG
	{
		__debugbreak();
	}
#endif
		return false; // Skip the draw call if we have an invalid cull mode set
	}

	if (currentState.currentRenderStates.renderStatesUnion.namedStates.alphaTestEnable)
	{
		switch (currentState.currentRenderStates.renderStatesUnion.namedStates.alphaFunc)
		{
		default:
#ifdef _DEBUG
		{
			__debugbreak(); // Should never be here
		}
#endif
		case D3DCMP_NEVER:
			return false;
		case D3DCMP_ALWAYS:
		case D3DCMP_EQUAL:
		case D3DCMP_NOTEQUAL:
		case D3DCMP_LESSEQUAL:
		case D3DCMP_GREATEREQUAL:
			break;
		case D3DCMP_LESS:
			if (currentState.currentRenderStates.renderStatesUnion.namedStates.alphaRef == 0x00)
				return false;
			break;
		case D3DCMP_GREATER:
			if (currentState.currentRenderStates.renderStatesUnion.namedStates.alphaRef == 0xFF)
				return false;
			break;
		}
	}

	if (currentState.currentRenderStates.renderStatesUnion.namedStates.alphaBlendEnable && !currentState.currentRenderStates.renderStatesUnion.namedStates.separateAlphaBlendEnable)
	{
		if (currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlend == D3DBLEND_ZERO && currentState.currentRenderStates.renderStatesUnion.namedStates.destBlend == D3DBLEND_ONE)
			return false;
	}

	if (currentState.currentRenderStates.renderStatesUnion.namedStates.scissorTestEnable)
	{
		const RECT& thisScissorRect = currentState.currentScissorRect.scissorRect;
		if (thisScissorRect.right <= thisScissorRect.left)
			return false;
		if (thisScissorRect.bottom <= thisScissorRect.top)
			return false;
	}

	// Skip the entire draw call if we're doing dumb stuff (like rendering a fullscreen quad that is entirely alpha-transparent while alpha blending is enabled using the fixed function pipeline. Looking at you, Morrowind.exe):
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.alphaBlendEnable && !currentState.currentPixelShader && !currentState.currentVertexShader)
	{
		if (currentState.currentRenderStates.renderStatesUnion.namedStates.lighting && 
			currentState.currentRenderStates.renderStatesUnion.namedStates.ambientMaterialSource == D3DMCS_MATERIAL && currentState.currentMaterial.Ambient.a == 0.0f &&
			currentState.currentRenderStates.renderStatesUnion.namedStates.diffuseMaterialSource == D3DMCS_MATERIAL && currentState.currentMaterial.Diffuse.a == 0.0f)
		{
			// FFPS selects vertex color for alpha channel
			if (currentState.currentStageStates[0].stageStateUnion.namedStates.alphaOp == D3DTOP_MODULATE && 
				(currentState.currentStageStates[0].stageStateUnion.namedStates.alphaArg1 == D3DTA_DIFFUSE || currentState.currentStageStates[0].stageStateUnion.namedStates.alphaArg2 == D3DTA_DIFFUSE || 
				currentState.currentStageStates[0].stageStateUnion.namedStates.alphaArg1 == D3DTA_CURRENT || currentState.currentStageStates[0].stageStateUnion.namedStates.alphaArg2 == D3DTA_CURRENT) )
				return false;
			else if (currentState.currentStageStates[0].stageStateUnion.namedStates.alphaOp == D3DTOP_SELECTARG1 && (currentState.currentStageStates[0].stageStateUnion.namedStates.alphaArg1 == D3DTA_DIFFUSE || currentState.currentStageStates[0].stageStateUnion.namedStates.alphaArg1 == D3DTA_CURRENT) )
				return false;
			else if (currentState.currentStageStates[0].stageStateUnion.namedStates.alphaOp == D3DTOP_SELECTARG2 && (currentState.currentStageStates[0].stageStateUnion.namedStates.alphaArg2 == D3DTA_DIFFUSE || currentState.currentStageStates[0].stageStateUnion.namedStates.alphaArg2 == D3DTA_CURRENT) )
				return false;
		}
	}

	return true;
}

// Returns true if the currently set pipeline can do early-Z testing, or false if it cannot (false if depth isn't enabled, or no depth buffer is bound, or a weird Z-test is set up, or the pixel shader outputs depth)
const bool IDirect3DDevice9Hook::CurrentPipelineCanEarlyZTest(void) const
{
#ifndef DISALLOW_EARLY_Z_TESTING
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.zEnable != D3DZB_FALSE)
	{
		// Currently only less and lessequal are supported. In the future, greater and greaterequal can also be supported
		if (currentState.currentRenderStates.renderStatesUnion.namedStates.zFunc == D3DCMP_LESS || 
			currentState.currentRenderStates.renderStatesUnion.namedStates.zFunc == D3DCMP_LESSEQUAL)
		{
			if (currentState.currentDepthStencil != NULL)
			{
				if (currentState.currentPixelShader == NULL)
					return true;
				else
					return !currentState.currentPixelShader->GetShaderInfo().psWritesDepth;
			}
		}
	}
#endif // #ifndef DISALLOW_EARLY_Z_TESTING
	return false;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::DrawPrimitive(THIS_ D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount)
{
	SIMPLE_FUNC_SCOPE();

	if (!currentState.currentVertexDecl)
		return D3DERR_INVALIDCALL;

	if (PrimitiveCount == 0)
		return D3DERR_INVALIDCALL;

	if (PrimitiveType > D3DPT_TRIANGLEFAN || PrimitiveType < D3DPT_POINTLIST)
		return D3DERR_INVALIDCALL;

	HRESULT ret = S_OK;

	if (!TotalDrawCallSkipTest() )
		return ret;

	bool usePassthroughVertexShader = false;
	bool usePassthroughPixelShader = false;

	if (!currentState.currentPixelShader)
	{
		usePassthroughPixelShader = true;

		IDirect3DPixelShader9Hook* FixedFunctionPixelShader = NULL;
		FixedFunctionStateToPixelShader(currentState, &FixedFunctionPixelShader, this);
		SetPixelShader(FixedFunctionPixelShader);
		SetFixedFunctionPixelShaderState(currentState, this);
	}

	RecomputeCachedStreamEndsIfDirty();

	// This is the case if we have a D3DUSAGE_POSITIONT with usageindex 0
	if (SkipVertexProcessing() )
	{
		if (CurrentPipelineCanEarlyZTest() )
			DrawPrimitiveUBPretransformedSkipVS<false, unsigned, true>(PrimitiveType, 0, 0, PrimitiveCount);
		else
			DrawPrimitiveUBPretransformedSkipVS<false, unsigned, false>(PrimitiveType, 0, 0, PrimitiveCount);

		if (usePassthroughPixelShader)
			SetPixelShader(NULL);
		return ret;
	}

	if (!currentState.currentVertexShader)
	{
		usePassthroughVertexShader = true;

		IDirect3DVertexShader9Hook* FixedFunctionVertexShader = NULL;
		FixedFunctionStateToVertexShader(currentState, &FixedFunctionVertexShader, this);
		SetVertexShader(FixedFunctionVertexShader);
		SetFixedFunctionVertexShaderState(currentState, this);
	}

	processedVertsUsed = 0;
	if (!currentState.currentVertexDecl)
	{
		DbgBreakPrint("Error: NULL vertex decl");
	}
	DeclarationSemanticMapping vertexDeclMapping;
	vertexDeclMapping.ClearSemanticMapping();
	vertexDeclMapping.ComputeMappingVS(currentState.currentVertexDecl, currentState.currentVertexShader);
	InitVertexShader(currentState, currentState.currentVertexShader->GetShaderInfo() );

	SetupCurrentDrawCallVertexData(vertexDeclMapping);

#ifdef _DEBUG
	if (currentState.currentVertexShader && !currentState.currentVertexShader->jitShaderMain)
	{
		DbgPrint("Warning: Uncached vertex shader detected");
	}
#endif

	ProcessVerticesToBuffer<true, false>(currentState.currentVertexDecl, vertexDeclMapping, NULL, PrimitiveType, 0, 0, StartVertex, PrimitiveCount, NULL, 0);

#ifdef _DEBUG
	if (currentState.currentPixelShader && !currentState.currentPixelShader->jitShaderMain)
	{
		DbgPrint("Warning: Uncached pixel shader detected");
	}
#endif

	if (CurrentPipelineCanEarlyZTest() )
		DrawPrimitiveUB<true>(PrimitiveType, PrimitiveCount);
	else
		DrawPrimitiveUB<false>(PrimitiveType, PrimitiveCount);

	if (usePassthroughVertexShader)
		SetVertexShader(NULL);
	if (usePassthroughPixelShader)
		SetPixelShader(NULL);

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::DrawIndexedPrimitive(THIS_ D3DPRIMITIVETYPE PrimitiveType, INT BaseVertexIndex, UINT MinVertexIndex, UINT NumVertices, UINT startIndex, UINT primCount)
{
	SIMPLE_FUNC_SCOPE();

	if (!currentState.currentVertexDecl)
		return D3DERR_INVALIDCALL;

	if (NumVertices == 0)
		return D3DERR_INVALIDCALL;

	if (primCount == 0)
		return D3DERR_INVALIDCALL;

	if (PrimitiveType > D3DPT_TRIANGLEFAN || PrimitiveType < D3DPT_POINTLIST)
		return D3DERR_INVALIDCALL;

	if (currentState.currentTextures[0])
	{
#ifdef WITH_SURFACE_HASHING
		const surfaceHash& currentHash = currentState.currentTextures[0]->GetUnderlyingSurfaces()[0]->GetSurfaceHash();
		if (currentHash.format == D3DFMT_DXT5 && currentHash.sizeBytes == 0x4000 && currentHash.hashVal == 0xD957D29D)
		{
			//__debugbreak();
		}
#endif
	}

	if (currentState.currentIndexBuffer == NULL)
		return D3DERR_INVALIDCALL;

	if (!TotalDrawCallSkipTest() )
		return S_OK;

	RecomputeCachedStreamEndsIfDirty();

	bool usePassthroughVertexShader = false;
	bool usePassthroughPixelShader = false;

	if (!currentState.currentPixelShader)
	{
		usePassthroughPixelShader = true;

		IDirect3DPixelShader9Hook* FixedFunctionPixelShader = NULL;
		FixedFunctionStateToPixelShader(currentState, &FixedFunctionPixelShader, this);
		SetPixelShader(FixedFunctionPixelShader);
		SetFixedFunctionPixelShaderState(currentState, this);
	}

	// This is the case if we have a D3DUSAGE_POSITIONT with usageindex 0
	if (SkipVertexProcessing() )
	{
		switch (currentState.currentIndexBuffer->GetFormat() )
		{
		case D3DFMT_INDEX16:
			if (CurrentPipelineCanEarlyZTest() )
				DrawPrimitiveUBPretransformedSkipVS<true, unsigned short, true>(PrimitiveType, BaseVertexIndex, startIndex, primCount);
			else
				DrawPrimitiveUBPretransformedSkipVS<true, unsigned short, false>(PrimitiveType, BaseVertexIndex, startIndex, primCount);
			break;
		default:
#ifdef _DEBUG
		{
			__debugbreak(); // Should never be here
		}
#endif
		case D3DFMT_INDEX32:
			if (CurrentPipelineCanEarlyZTest() )
				DrawPrimitiveUBPretransformedSkipVS<true, unsigned, true>(PrimitiveType, BaseVertexIndex, startIndex, primCount);
			else
				DrawPrimitiveUBPretransformedSkipVS<true, unsigned, false>(PrimitiveType, BaseVertexIndex, startIndex, primCount);
			break;
		}

		if (usePassthroughPixelShader)
			SetPixelShader(NULL);
		return S_OK;
	}

	if (!currentState.currentVertexShader)
	{
		usePassthroughVertexShader = true;

		IDirect3DVertexShader9Hook* FixedFunctionVertexShader = NULL;
		FixedFunctionStateToVertexShader(currentState, &FixedFunctionVertexShader, this);
		SetVertexShader(FixedFunctionVertexShader);
		SetFixedFunctionVertexShaderState(currentState, this);
	}

	HRESULT ret = S_OK;

	processedVertsUsed = 0;

	if (!currentState.currentVertexDecl)
	{
		DbgBreakPrint("Error: NULL vertex decl");
	}
	DeclarationSemanticMapping vertexDeclMapping;
	vertexDeclMapping.ClearSemanticMapping();
	vertexDeclMapping.ComputeMappingVS(currentState.currentVertexDecl, currentState.currentVertexShader);
	InitVertexShader(currentState, currentState.currentVertexShader->GetShaderInfo() );

	SetupCurrentDrawCallVertexData(vertexDeclMapping);

#ifdef _DEBUG
	if (currentState.currentVertexShader && !currentState.currentVertexShader->jitShaderMain)
	{
		DbgPrint("Warning: Uncached vertex shader detected");
	}
#endif

	ProcessVerticesToBuffer<true, true>(currentState.currentVertexDecl, vertexDeclMapping, currentState.currentIndexBuffer, PrimitiveType, BaseVertexIndex, MinVertexIndex, startIndex, primCount, NULL, 0);

#ifdef _DEBUG
	if (currentState.currentPixelShader && !currentState.currentPixelShader->jitShaderMain)
	{
		DbgPrint("Warning: Uncached pixel shader detected");
	}
#endif

	if (CurrentPipelineCanEarlyZTest() )
		DrawPrimitiveUB<true>(PrimitiveType, primCount);
	else
		DrawPrimitiveUB<false>(PrimitiveType, primCount);

	if (usePassthroughVertexShader)
		SetVertexShader(NULL);
	if (usePassthroughPixelShader)
		SetPixelShader(NULL);

	return ret;
}

static inline const int computeEdgeSidedness(const int ax, const int ay, const int bx, const int by, const int cx, const int cy)
{
	return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);
}

template <const unsigned char channelWriteMask>
void IDirect3DDevice9Hook::LoadBlend(D3DXVECTOR4& outBlend, const D3DBLEND blendMode, const D3DXVECTOR4& srcColor, const D3DXVECTOR4& dstColor) const
{
	if (channelWriteMask == 0)
		return;

	// Simple + fast mode:
	if ( (channelWriteMask & 0x7) == 0x7)
	{
		switch (blendMode)
		{
		case D3DBLEND_ZERO:
			// Do nothing. This case is handled in AlphaBlend().
			return;
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Invalid D3DBLEND type passed to blending unit");
#else
			__assume(0);
#endif
		case D3DBLEND_ONE            :
			// Do nothing. This case is handled in AlphaBlend().
			return;
		case D3DBLEND_INVSRCCOLOR2   :
#ifdef _DEBUG
			DbgBreakPrint("Error: D3DBLEND_INVSRCCOLOR2 is not yet supported!"); // Not yet supported!
#else
			__assume(0);
#endif
		case D3DBLEND_SRCCOLOR2      :
#ifdef _DEBUG
			DbgBreakPrint("Error: D3DBLEND_SRCCOLOR2 is not yet supported!"); // Not yet supported!
#else
			__assume(0);
#endif
		case D3DBLEND_SRCCOLOR       :
			outBlend = srcColor;
			return;
		case D3DBLEND_INVSRCCOLOR    :
			*(__m128* const)&outBlend = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&srcColor);
			return;
		case D3DBLEND_BOTHSRCALPHA   :
		case D3DBLEND_SRCALPHA       :
			*(__m128* const)&outBlend = _mm_load1_ps(&srcColor.w);
			return;
		case D3DBLEND_BOTHINVSRCALPHA:
		case D3DBLEND_INVSRCALPHA    :
			*(__m128* const)&outBlend = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, _mm_load1_ps(&srcColor.w) );
			return;
		case D3DBLEND_DESTALPHA      :
			*(__m128* const)&outBlend = _mm_load1_ps(&dstColor.w);
			return;
		case D3DBLEND_INVDESTALPHA   :
			*(__m128* const)&outBlend = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, _mm_load1_ps(&dstColor.w) );
			return;
		case D3DBLEND_DESTCOLOR      :
			outBlend = dstColor;
			return;
		case D3DBLEND_INVDESTCOLOR:
			*(__m128* const)&outBlend = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&dstColor);
			return;
		case D3DBLEND_SRCALPHASAT    :
		{
			// TODO: Low-priorty SIMDify this (nobody uses this blend state anyway)
			const float as = srcColor.w;
			const float invad = 1.0f - dstColor.w;
			const float f = as < invad ? as : invad;
			if (channelWriteMask & 0x1)
				outBlend.x = f;
			if (channelWriteMask & 0x2)
				outBlend.y = f;
			if (channelWriteMask & 0x4)
				outBlend.z = f;
			if (channelWriteMask & 0x8)
				outBlend.w = 1.0f;
			return;
		}
		case D3DBLEND_BLENDFACTOR    :
			outBlend = currentState.currentRenderStates.cachedBlendFactor;
			return;
		case D3DBLEND_INVBLENDFACTOR:
			outBlend = currentState.currentRenderStates.cachedInvBlendFactor;
			return;
		}
		return;
	}

	switch (blendMode)
	{
	case D3DBLEND_ZERO           :
		// Do nothing. This case is handled in AlphaBlend().
		break;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid D3DBLEND type passed to blending unit");
#else
		__assume(0);
#endif
	case D3DBLEND_ONE            :
		// Do nothing. This case is handled in AlphaBlend().
		break;
	case D3DBLEND_INVSRCCOLOR2   :
#ifdef _DEBUG
		DbgBreakPrint("Error: D3DBLEND_INVSRCCOLOR2 is not yet supported!"); // Not yet supported!
#else
		__assume(0);
#endif
	case D3DBLEND_SRCCOLOR2      :
#ifdef _DEBUG
		DbgBreakPrint("Error: D3DBLEND_SRCCOLOR2 is not yet supported!"); // Not yet supported!
#else
		__assume(0);
#endif
	case D3DBLEND_SRCCOLOR       :
		if (channelWriteMask & 0x1)
			outBlend.x = srcColor.x;
		if (channelWriteMask & 0x2)
			outBlend.y = srcColor.y;
		if (channelWriteMask & 0x4)
			outBlend.z = srcColor.z;
		if (channelWriteMask & 0x8)
			outBlend.w = srcColor.w;
		break;
	case D3DBLEND_INVSRCCOLOR    :
		if (channelWriteMask & 0x1)
			outBlend.x = 1.0f - srcColor.x;
		if (channelWriteMask & 0x2)
			outBlend.y = 1.0f - srcColor.y;
		if (channelWriteMask & 0x4)
			outBlend.z = 1.0f - srcColor.z;
		if (channelWriteMask & 0x8)
			outBlend.w = 1.0f - srcColor.w;
		break;
	case D3DBLEND_BOTHSRCALPHA   :
	case D3DBLEND_SRCALPHA       :
		if (channelWriteMask & 0x1)
			outBlend.x = srcColor.w;
		if (channelWriteMask & 0x2)
			outBlend.y = srcColor.w;
		if (channelWriteMask & 0x4)
			outBlend.z = srcColor.w;
		if (channelWriteMask & 0x8)
			outBlend.w = srcColor.w;
		break;
	case D3DBLEND_BOTHINVSRCALPHA:
	case D3DBLEND_INVSRCALPHA    :
		if (channelWriteMask & 0x1)
			outBlend.x = 1.0f - srcColor.w;
		if (channelWriteMask & 0x2)
			outBlend.y = 1.0f - srcColor.w;
		if (channelWriteMask & 0x4)
			outBlend.z = 1.0f - srcColor.w;
		if (channelWriteMask & 0x8)
			outBlend.w = 1.0f - srcColor.w;
		break;
	case D3DBLEND_DESTALPHA      :
		if (channelWriteMask & 0x1)
			outBlend.x = dstColor.w;
		if (channelWriteMask & 0x2)
			outBlend.y = dstColor.w;
		if (channelWriteMask & 0x4)
			outBlend.z = dstColor.w;
		if (channelWriteMask & 0x8)
			outBlend.w = dstColor.w;
		break;
	case D3DBLEND_INVDESTALPHA   :
		if (channelWriteMask & 0x1)
			outBlend.x = 1.0f - dstColor.w;
		if (channelWriteMask & 0x2)
			outBlend.y = 1.0f - dstColor.w;
		if (channelWriteMask & 0x4)
			outBlend.z = 1.0f - dstColor.w;
		if (channelWriteMask & 0x8)
			outBlend.w = 1.0f - dstColor.w;
		break;
	case D3DBLEND_DESTCOLOR      :
		if (channelWriteMask & 0x1)
			outBlend.x = dstColor.x;
		if (channelWriteMask & 0x2)
			outBlend.y = dstColor.y;
		if (channelWriteMask & 0x4)
			outBlend.z = dstColor.z;
		if (channelWriteMask & 0x8)
			outBlend.w = dstColor.w;
		break;
	case D3DBLEND_INVDESTCOLOR   :
		if (channelWriteMask & 0x1)
			outBlend.x = 1.0f - dstColor.x;
		if (channelWriteMask & 0x2)
			outBlend.y = 1.0f - dstColor.y;
		if (channelWriteMask & 0x4)
			outBlend.z = 1.0f - dstColor.z;
		if (channelWriteMask & 0x8)
			outBlend.w = 1.0f - dstColor.w;
		break;
	case D3DBLEND_SRCALPHASAT    :
	{
		const float as = srcColor.w;
		const float invad = 1.0f - dstColor.w;
		const float f = as < invad ? as : invad;
		if (channelWriteMask & 0x1)
			outBlend.x = f;
		if (channelWriteMask & 0x2)
			outBlend.y = f;
		if (channelWriteMask & 0x4)
			outBlend.z = f;
		if (channelWriteMask & 0x8)
			outBlend.w = 1.0f;
	}
		break;
	case D3DBLEND_BLENDFACTOR    :
		if (channelWriteMask & 0x1)
			outBlend.x = currentState.currentRenderStates.cachedBlendFactor.x;
		if (channelWriteMask & 0x2)
			outBlend.y = currentState.currentRenderStates.cachedBlendFactor.y;
		if (channelWriteMask & 0x4)
			outBlend.z = currentState.currentRenderStates.cachedBlendFactor.z;
		if (channelWriteMask & 0x8)
			outBlend.w = currentState.currentRenderStates.cachedBlendFactor.w;
		break;
	case D3DBLEND_INVBLENDFACTOR :
		if (channelWriteMask & 0x1)
			outBlend.x = currentState.currentRenderStates.cachedInvBlendFactor.x;
		if (channelWriteMask & 0x2)
			outBlend.y = currentState.currentRenderStates.cachedInvBlendFactor.y;
		if (channelWriteMask & 0x4)
			outBlend.z = currentState.currentRenderStates.cachedInvBlendFactor.z;
		if (channelWriteMask & 0x8)
			outBlend.w = currentState.currentRenderStates.cachedInvBlendFactor.w;
		break;
	}
}

template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::LoadBlend4(D3DXVECTOR4 (&outBlend)[4], const D3DBLEND blendMode, const D3DXVECTOR4 (&srcColor)[4], const D3DXVECTOR4 (&dstColor)[4]) const
{
	if (pixelWriteMask == 0x0)
	{
#ifdef _DEBUG
		__debugbreak(); // Don't call this function if you aren't going to write anything out!
#endif
		return;
	}

	// Simple + fast mode:
	if ( (channelWriteMask & 0x7) == 0x7)
	{
		switch (blendMode)
		{
		case D3DBLEND_ZERO:
			// Do nothing. This case is handled in AlphaBlend4().
			return;
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Invalid D3DBLEND type passed to blending unit");
#else
			__assume(0);
#endif
		case D3DBLEND_ONE            :
			// Do nothing. This case is handled in AlphaBlend4().
			return;
		case D3DBLEND_INVSRCCOLOR2   :
#ifdef _DEBUG
			DbgBreakPrint("Error: D3DBLEND_INVSRCCOLOR2 is not yet supported!"); // Not yet supported!
#else
			__assume(0);
#endif
		case D3DBLEND_SRCCOLOR2      :
#ifdef _DEBUG
			DbgBreakPrint("Error: D3DBLEND_SRCCOLOR2 is not yet supported!"); // Not yet supported!
#else
			__assume(0);
#endif
		case D3DBLEND_SRCCOLOR       :
			if (pixelWriteMask & 0x1) outBlend[0] = srcColor[0];
			if (pixelWriteMask & 0x2) outBlend[1] = srcColor[1];
			if (pixelWriteMask & 0x4) outBlend[2] = srcColor[2];
			if (pixelWriteMask & 0x8) outBlend[3] = srcColor[3];
			return;
		case D3DBLEND_INVSRCCOLOR    :
			if (pixelWriteMask & 0x1) *(__m128* const)&(outBlend[0]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(srcColor[0]) );
			if (pixelWriteMask & 0x2) *(__m128* const)&(outBlend[1]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(srcColor[1]) );
			if (pixelWriteMask & 0x4) *(__m128* const)&(outBlend[2]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(srcColor[2]) );
			if (pixelWriteMask & 0x8) *(__m128* const)&(outBlend[3]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(srcColor[3]) );
			return;
		case D3DBLEND_BOTHSRCALPHA   :
		case D3DBLEND_SRCALPHA       :
			if (pixelWriteMask & 0x1) *(__m128* const)&(outBlend[0]) = _mm_load1_ps(&(srcColor[0].w) );
			if (pixelWriteMask & 0x2) *(__m128* const)&(outBlend[1]) = _mm_load1_ps(&(srcColor[1].w) );
			if (pixelWriteMask & 0x4) *(__m128* const)&(outBlend[2]) = _mm_load1_ps(&(srcColor[2].w) );
			if (pixelWriteMask & 0x8) *(__m128* const)&(outBlend[3]) = _mm_load1_ps(&(srcColor[3].w) );
			return;
		case D3DBLEND_BOTHINVSRCALPHA:
		case D3DBLEND_INVSRCALPHA    :
			if (pixelWriteMask & 0x1) *(__m128* const)&(outBlend[0]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, _mm_load1_ps(&(srcColor[0].w) ) );
			if (pixelWriteMask & 0x2) *(__m128* const)&(outBlend[1]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, _mm_load1_ps(&(srcColor[1].w) ) );
			if (pixelWriteMask & 0x4) *(__m128* const)&(outBlend[2]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, _mm_load1_ps(&(srcColor[2].w) ) );
			if (pixelWriteMask & 0x8) *(__m128* const)&(outBlend[3]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, _mm_load1_ps(&(srcColor[3].w) ) );
			return;
		case D3DBLEND_DESTALPHA      :
			if (pixelWriteMask & 0x1) *(__m128* const)&(outBlend[0]) = _mm_load1_ps(&(dstColor[0].w) );
			if (pixelWriteMask & 0x2) *(__m128* const)&(outBlend[1]) = _mm_load1_ps(&(dstColor[1].w) );
			if (pixelWriteMask & 0x4) *(__m128* const)&(outBlend[2]) = _mm_load1_ps(&(dstColor[2].w) );
			if (pixelWriteMask & 0x8) *(__m128* const)&(outBlend[3]) = _mm_load1_ps(&(dstColor[3].w) );
			return;
		case D3DBLEND_INVDESTALPHA   :
			if (pixelWriteMask & 0x1) *(__m128* const)&(outBlend[0]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, _mm_load1_ps(&(dstColor[0].w) ) );
			if (pixelWriteMask & 0x2) *(__m128* const)&(outBlend[1]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, _mm_load1_ps(&(dstColor[1].w) ) );
			if (pixelWriteMask & 0x4) *(__m128* const)&(outBlend[2]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, _mm_load1_ps(&(dstColor[2].w) ) );
			if (pixelWriteMask & 0x8) *(__m128* const)&(outBlend[3]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, _mm_load1_ps(&(dstColor[3].w) ) );
			return;
		case D3DBLEND_DESTCOLOR      :
			if (pixelWriteMask & 0x1) outBlend[0] = dstColor[0];
			if (pixelWriteMask & 0x2) outBlend[1] = dstColor[1];
			if (pixelWriteMask & 0x4) outBlend[2] = dstColor[2];
			if (pixelWriteMask & 0x8) outBlend[3] = dstColor[3];
			return;
		case D3DBLEND_INVDESTCOLOR:
			if (pixelWriteMask & 0x1) *(__m128* const)&(outBlend[0]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(dstColor[0]) );
			if (pixelWriteMask & 0x2) *(__m128* const)&(outBlend[1]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(dstColor[1]) );
			if (pixelWriteMask & 0x4) *(__m128* const)&(outBlend[2]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(dstColor[2]) );
			if (pixelWriteMask & 0x8) *(__m128* const)&(outBlend[3]) = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(dstColor[3]) );
			return;
		case D3DBLEND_SRCALPHASAT    :
		{
			// TODO: Low-priorty SIMDify this (nobody uses this blend state anyway)
			for (unsigned x = 0; x < 4; ++x)
			{
				if (pixelWriteMask & (1 << x) )
				{
					const float as = srcColor[x].w;
					const float invad = 1.0f - dstColor[x].w;
					const float f = as < invad ? as : invad;
					if (channelWriteMask & 0x1)
						outBlend[x].x = f;
					if (channelWriteMask & 0x2)
						outBlend[x].y = f;
					if (channelWriteMask & 0x4)
						outBlend[x].z = f;
					if (channelWriteMask & 0x8)
						outBlend[x].w = 1.0f;
				}
			}
			return;
		}
		case D3DBLEND_BLENDFACTOR    :
		{
			const __m128 blendFactor = *(const __m128* const)&(currentState.currentRenderStates.cachedBlendFactor);
			if (pixelWriteMask & 0x1) *(__m128* const)&(outBlend[0]) = blendFactor;
			if (pixelWriteMask & 0x2) *(__m128* const)&(outBlend[1]) = blendFactor;
			if (pixelWriteMask & 0x4) *(__m128* const)&(outBlend[2]) = blendFactor;
			if (pixelWriteMask & 0x8) *(__m128* const)&(outBlend[3]) = blendFactor;
		}
			return;
		case D3DBLEND_INVBLENDFACTOR:
		{
			const __m128 invBlendFactor = *(const __m128* const)&(currentState.currentRenderStates.cachedInvBlendFactor);
			if (pixelWriteMask & 0x1) *(__m128* const)&(outBlend[0]) = invBlendFactor;
			if (pixelWriteMask & 0x2) *(__m128* const)&(outBlend[1]) = invBlendFactor;
			if (pixelWriteMask & 0x4) *(__m128* const)&(outBlend[2]) = invBlendFactor;
			if (pixelWriteMask & 0x8) *(__m128* const)&(outBlend[3]) = invBlendFactor;
		}
			return;
		}
		return;
	}

	switch (blendMode)
	{
	case D3DBLEND_ZERO           :
		// Do nothing. This case is handled in AlphaBlend4().
		break;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid D3DBLEND type passed to blending unit");
#else
		__assume(0);
#endif
	case D3DBLEND_ONE            :
		// Do nothing. This case is handled in AlphaBlend4().
		break;
	case D3DBLEND_INVSRCCOLOR2   :
#ifdef _DEBUG
		DbgBreakPrint("Error: D3DBLEND_INVSRCCOLOR2 is not yet supported!"); // Not yet supported!
#else
		__assume(0);
#endif
	case D3DBLEND_SRCCOLOR2      :
#ifdef _DEBUG
		DbgBreakPrint("Error: D3DBLEND_SRCCOLOR2 is not yet supported!"); // Not yet supported!
#else
		__assume(0);
#endif
	case D3DBLEND_SRCCOLOR       :
		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outBlend[0].x = srcColor[0].x;
			if (channelWriteMask & 0x2)	outBlend[0].y = srcColor[0].y;
			if (channelWriteMask & 0x4)	outBlend[0].z = srcColor[0].z;
			if (channelWriteMask & 0x8)	outBlend[0].w = srcColor[0].w;
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outBlend[1].x = srcColor[1].x;
			if (channelWriteMask & 0x2)	outBlend[1].y = srcColor[1].y;
			if (channelWriteMask & 0x4)	outBlend[1].z = srcColor[1].z;
			if (channelWriteMask & 0x8)	outBlend[1].w = srcColor[1].w;
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outBlend[2].x = srcColor[2].x;
			if (channelWriteMask & 0x2)	outBlend[2].y = srcColor[2].y;
			if (channelWriteMask & 0x4)	outBlend[2].z = srcColor[2].z;
			if (channelWriteMask & 0x8)	outBlend[2].w = srcColor[2].w;
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outBlend[3].x = srcColor[3].x;
			if (channelWriteMask & 0x2)	outBlend[3].y = srcColor[3].y;
			if (channelWriteMask & 0x4)	outBlend[3].z = srcColor[3].z;
			if (channelWriteMask & 0x8)	outBlend[3].w = srcColor[3].w;
		}
		break;
	case D3DBLEND_INVSRCCOLOR    :
	{
		__m128 invSrcColor4[4];
		if (pixelWriteMask & 0x1) invSrcColor4[0] = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(srcColor[0]) );
		if (pixelWriteMask & 0x2) invSrcColor4[1] = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(srcColor[1]) );
		if (pixelWriteMask & 0x4) invSrcColor4[2] = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(srcColor[2]) );
		if (pixelWriteMask & 0x8) invSrcColor4[3] = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(srcColor[3]) );

		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outBlend[0].x = invSrcColor4[0].m128_f32[0];
			if (channelWriteMask & 0x2)	outBlend[0].y = invSrcColor4[0].m128_f32[1];
			if (channelWriteMask & 0x4)	outBlend[0].z = invSrcColor4[0].m128_f32[2];
			if (channelWriteMask & 0x8)	outBlend[0].w = invSrcColor4[0].m128_f32[3];
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outBlend[1].x = invSrcColor4[1].m128_f32[0];
			if (channelWriteMask & 0x2)	outBlend[1].y = invSrcColor4[1].m128_f32[1];
			if (channelWriteMask & 0x4)	outBlend[1].z = invSrcColor4[1].m128_f32[2];
			if (channelWriteMask & 0x8)	outBlend[1].w = invSrcColor4[1].m128_f32[3];
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outBlend[2].x = invSrcColor4[2].m128_f32[0];
			if (channelWriteMask & 0x2)	outBlend[2].y = invSrcColor4[2].m128_f32[1];
			if (channelWriteMask & 0x4)	outBlend[2].z = invSrcColor4[2].m128_f32[2];
			if (channelWriteMask & 0x8)	outBlend[2].w = invSrcColor4[2].m128_f32[3];
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outBlend[3].x = invSrcColor4[3].m128_f32[0];
			if (channelWriteMask & 0x2)	outBlend[3].y = invSrcColor4[3].m128_f32[1];
			if (channelWriteMask & 0x4)	outBlend[3].z = invSrcColor4[3].m128_f32[2];
			if (channelWriteMask & 0x8)	outBlend[3].w = invSrcColor4[3].m128_f32[3];
		}
	}
		break;
	case D3DBLEND_BOTHSRCALPHA   :
	case D3DBLEND_SRCALPHA       :
	{
		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outBlend[0].x = srcColor[0].w;
			if (channelWriteMask & 0x2)	outBlend[0].y = srcColor[0].w;
			if (channelWriteMask & 0x4)	outBlend[0].z = srcColor[0].w;
			if (channelWriteMask & 0x8)	outBlend[0].w = srcColor[0].w;
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outBlend[1].x = srcColor[1].w;
			if (channelWriteMask & 0x2)	outBlend[1].y = srcColor[1].w;
			if (channelWriteMask & 0x4)	outBlend[1].z = srcColor[1].w;
			if (channelWriteMask & 0x8)	outBlend[1].w = srcColor[1].w;
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outBlend[2].x = srcColor[2].w;
			if (channelWriteMask & 0x2)	outBlend[2].y = srcColor[2].w;
			if (channelWriteMask & 0x4)	outBlend[2].z = srcColor[2].w;
			if (channelWriteMask & 0x8)	outBlend[2].w = srcColor[2].w;
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outBlend[3].x = srcColor[3].w;
			if (channelWriteMask & 0x2)	outBlend[3].y = srcColor[3].w;
			if (channelWriteMask & 0x4)	outBlend[3].z = srcColor[3].w;
			if (channelWriteMask & 0x8)	outBlend[3].w = srcColor[3].w;
		}
	}
		break;
	case D3DBLEND_BOTHINVSRCALPHA:
	case D3DBLEND_INVSRCALPHA    :
	{
		__m128 alphaVec;
		if (pixelWriteMask & 0x1) alphaVec.m128_f32[0] = srcColor[0].w;
		if (pixelWriteMask & 0x2) alphaVec.m128_f32[1] = srcColor[1].w;
		if (pixelWriteMask & 0x4) alphaVec.m128_f32[2] = srcColor[2].w;
		if (pixelWriteMask & 0x8) alphaVec.m128_f32[3] = srcColor[3].w;
		const __m128 invAlphaVec = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, alphaVec);

		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outBlend[0].x = invAlphaVec.m128_f32[0];
			if (channelWriteMask & 0x2)	outBlend[0].y = invAlphaVec.m128_f32[0];
			if (channelWriteMask & 0x4)	outBlend[0].z = invAlphaVec.m128_f32[0];
			if (channelWriteMask & 0x8)	outBlend[0].w = invAlphaVec.m128_f32[0];
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outBlend[1].x = invAlphaVec.m128_f32[1];
			if (channelWriteMask & 0x2)	outBlend[1].y = invAlphaVec.m128_f32[1];
			if (channelWriteMask & 0x4)	outBlend[1].z = invAlphaVec.m128_f32[1];
			if (channelWriteMask & 0x8)	outBlend[1].w = invAlphaVec.m128_f32[1];
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outBlend[2].x = invAlphaVec.m128_f32[2];
			if (channelWriteMask & 0x2)	outBlend[2].y = invAlphaVec.m128_f32[2];
			if (channelWriteMask & 0x4)	outBlend[2].z = invAlphaVec.m128_f32[2];
			if (channelWriteMask & 0x8)	outBlend[2].w = invAlphaVec.m128_f32[2];
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outBlend[3].x = invAlphaVec.m128_f32[3];
			if (channelWriteMask & 0x2)	outBlend[3].y = invAlphaVec.m128_f32[3];
			if (channelWriteMask & 0x4)	outBlend[3].z = invAlphaVec.m128_f32[3];
			if (channelWriteMask & 0x8)	outBlend[3].w = invAlphaVec.m128_f32[3];
		}
	}
		break;
	case D3DBLEND_DESTALPHA      :
		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outBlend[0].x = dstColor[0].w;
			if (channelWriteMask & 0x2)	outBlend[0].y = dstColor[0].w;
			if (channelWriteMask & 0x4)	outBlend[0].z = dstColor[0].w;
			if (channelWriteMask & 0x8)	outBlend[0].w = dstColor[0].w;
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outBlend[1].x = dstColor[1].w;
			if (channelWriteMask & 0x2)	outBlend[1].y = dstColor[1].w;
			if (channelWriteMask & 0x4)	outBlend[1].z = dstColor[1].w;
			if (channelWriteMask & 0x8)	outBlend[1].w = dstColor[1].w;
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outBlend[2].x = dstColor[2].w;
			if (channelWriteMask & 0x2)	outBlend[2].y = dstColor[2].w;
			if (channelWriteMask & 0x4)	outBlend[2].z = dstColor[2].w;
			if (channelWriteMask & 0x8)	outBlend[2].w = dstColor[2].w;
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outBlend[3].x = dstColor[3].w;
			if (channelWriteMask & 0x2)	outBlend[3].y = dstColor[3].w;
			if (channelWriteMask & 0x4)	outBlend[3].z = dstColor[3].w;
			if (channelWriteMask & 0x8)	outBlend[3].w = dstColor[3].w;
		}
		break;
	case D3DBLEND_INVDESTALPHA   :
	{
		__m128 alphaVec;
		if (pixelWriteMask & 0x1) alphaVec.m128_f32[0] = dstColor[0].w;
		if (pixelWriteMask & 0x2) alphaVec.m128_f32[1] = dstColor[1].w;
		if (pixelWriteMask & 0x4) alphaVec.m128_f32[2] = dstColor[2].w;
		if (pixelWriteMask & 0x8) alphaVec.m128_f32[3] = dstColor[3].w;
		const __m128 invAlphaVec = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, alphaVec);

		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outBlend[0].x = invAlphaVec.m128_f32[0];
			if (channelWriteMask & 0x2)	outBlend[0].y = invAlphaVec.m128_f32[0];
			if (channelWriteMask & 0x4)	outBlend[0].z = invAlphaVec.m128_f32[0];
			if (channelWriteMask & 0x8)	outBlend[0].w = invAlphaVec.m128_f32[0];
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outBlend[1].x = invAlphaVec.m128_f32[1];
			if (channelWriteMask & 0x2)	outBlend[1].y = invAlphaVec.m128_f32[1];
			if (channelWriteMask & 0x4)	outBlend[1].z = invAlphaVec.m128_f32[1];
			if (channelWriteMask & 0x8)	outBlend[1].w = invAlphaVec.m128_f32[1];
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outBlend[2].x = invAlphaVec.m128_f32[2];
			if (channelWriteMask & 0x2)	outBlend[2].y = invAlphaVec.m128_f32[2];
			if (channelWriteMask & 0x4)	outBlend[2].z = invAlphaVec.m128_f32[2];
			if (channelWriteMask & 0x8)	outBlend[2].w = invAlphaVec.m128_f32[2];
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outBlend[3].x = invAlphaVec.m128_f32[3];
			if (channelWriteMask & 0x2)	outBlend[3].y = invAlphaVec.m128_f32[3];
			if (channelWriteMask & 0x4)	outBlend[3].z = invAlphaVec.m128_f32[3];
			if (channelWriteMask & 0x8)	outBlend[3].w = invAlphaVec.m128_f32[3];
		}
	}
		break;
	case D3DBLEND_DESTCOLOR      :
		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outBlend[0].x = dstColor[0].x;
			if (channelWriteMask & 0x2)	outBlend[0].y = dstColor[0].y;
			if (channelWriteMask & 0x4)	outBlend[0].z = dstColor[0].z;
			if (channelWriteMask & 0x8)	outBlend[0].w = dstColor[0].w;
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outBlend[1].x = dstColor[1].x;
			if (channelWriteMask & 0x2)	outBlend[1].y = dstColor[1].y;
			if (channelWriteMask & 0x4)	outBlend[1].z = dstColor[1].z;
			if (channelWriteMask & 0x8)	outBlend[1].w = dstColor[1].w;
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outBlend[2].x = dstColor[2].x;
			if (channelWriteMask & 0x2)	outBlend[2].y = dstColor[2].y;
			if (channelWriteMask & 0x4)	outBlend[2].z = dstColor[2].z;
			if (channelWriteMask & 0x8)	outBlend[2].w = dstColor[2].w;
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outBlend[3].x = dstColor[3].x;
			if (channelWriteMask & 0x2)	outBlend[3].y = dstColor[3].y;
			if (channelWriteMask & 0x4)	outBlend[3].z = dstColor[3].z;
			if (channelWriteMask & 0x8)	outBlend[3].w = dstColor[3].w;
		}
		break;
	case D3DBLEND_INVDESTCOLOR   :
	{
		__m128 invDstColor4[4];
		if (pixelWriteMask & 0x1) invDstColor4[0] = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(dstColor[0]) );
		if (pixelWriteMask & 0x2) invDstColor4[1] = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(dstColor[1]) );
		if (pixelWriteMask & 0x4) invDstColor4[2] = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(dstColor[2]) );
		if (pixelWriteMask & 0x8) invDstColor4[3] = _mm_sub_ps(*(const __m128* const)&staticColorWhiteOpaque, *(const __m128* const)&(dstColor[3]) );

		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outBlend[0].x = invDstColor4[0].m128_f32[0];
			if (channelWriteMask & 0x2)	outBlend[0].y = invDstColor4[0].m128_f32[1];
			if (channelWriteMask & 0x4)	outBlend[0].z = invDstColor4[0].m128_f32[2];
			if (channelWriteMask & 0x8)	outBlend[0].w = invDstColor4[0].m128_f32[3];
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outBlend[1].x = invDstColor4[1].m128_f32[0];
			if (channelWriteMask & 0x2)	outBlend[1].y = invDstColor4[1].m128_f32[1];
			if (channelWriteMask & 0x4)	outBlend[1].z = invDstColor4[1].m128_f32[2];
			if (channelWriteMask & 0x8)	outBlend[1].w = invDstColor4[1].m128_f32[3];
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outBlend[2].x = invDstColor4[2].m128_f32[0];
			if (channelWriteMask & 0x2)	outBlend[2].y = invDstColor4[2].m128_f32[1];
			if (channelWriteMask & 0x4)	outBlend[2].z = invDstColor4[2].m128_f32[2];
			if (channelWriteMask & 0x8)	outBlend[2].w = invDstColor4[2].m128_f32[3];
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outBlend[3].x = invDstColor4[3].m128_f32[0];
			if (channelWriteMask & 0x2)	outBlend[3].y = invDstColor4[3].m128_f32[1];
			if (channelWriteMask & 0x4)	outBlend[3].z = invDstColor4[3].m128_f32[2];
			if (channelWriteMask & 0x8)	outBlend[3].w = invDstColor4[3].m128_f32[3];
		}
	}
		break;
	case D3DBLEND_SRCALPHASAT    :
	{
		// TODO: Low-priorty SIMDify this (nobody uses this blend state anyway)
		for (unsigned x = 0; x < 4; ++x)
		{
			if (pixelWriteMask & (1 << x) )
			{
				const float as = srcColor[x].w;
				const float invad = 1.0f - dstColor[x].w;
				const float f = as < invad ? as : invad;
				if (channelWriteMask & 0x1)
					outBlend[x].x = f;
				if (channelWriteMask & 0x2)
					outBlend[x].y = f;
				if (channelWriteMask & 0x4)
					outBlend[x].z = f;
				if (channelWriteMask & 0x8)
					outBlend[x].w = 1.0f;
			}
		}
	}
		break;
	case D3DBLEND_BLENDFACTOR    :
		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outBlend[0].x = currentState.currentRenderStates.cachedBlendFactor.x;
			if (channelWriteMask & 0x2)	outBlend[0].y = currentState.currentRenderStates.cachedBlendFactor.y;
			if (channelWriteMask & 0x4)	outBlend[0].z = currentState.currentRenderStates.cachedBlendFactor.z;
			if (channelWriteMask & 0x8)	outBlend[0].w = currentState.currentRenderStates.cachedBlendFactor.w;
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outBlend[1].x = currentState.currentRenderStates.cachedBlendFactor.x;
			if (channelWriteMask & 0x2)	outBlend[1].y = currentState.currentRenderStates.cachedBlendFactor.y;
			if (channelWriteMask & 0x4)	outBlend[1].z = currentState.currentRenderStates.cachedBlendFactor.z;
			if (channelWriteMask & 0x8)	outBlend[1].w = currentState.currentRenderStates.cachedBlendFactor.w;
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outBlend[2].x = currentState.currentRenderStates.cachedBlendFactor.x;
			if (channelWriteMask & 0x2)	outBlend[2].y = currentState.currentRenderStates.cachedBlendFactor.y;
			if (channelWriteMask & 0x4)	outBlend[2].z = currentState.currentRenderStates.cachedBlendFactor.z;
			if (channelWriteMask & 0x8)	outBlend[2].w = currentState.currentRenderStates.cachedBlendFactor.w;
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outBlend[3].x = currentState.currentRenderStates.cachedBlendFactor.x;
			if (channelWriteMask & 0x2)	outBlend[3].y = currentState.currentRenderStates.cachedBlendFactor.y;
			if (channelWriteMask & 0x4)	outBlend[3].z = currentState.currentRenderStates.cachedBlendFactor.z;
			if (channelWriteMask & 0x8)	outBlend[3].w = currentState.currentRenderStates.cachedBlendFactor.w;
		}
		break;
	case D3DBLEND_INVBLENDFACTOR :
		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outBlend[0].x = currentState.currentRenderStates.cachedInvBlendFactor.x;
			if (channelWriteMask & 0x2)	outBlend[0].y = currentState.currentRenderStates.cachedInvBlendFactor.y;
			if (channelWriteMask & 0x4)	outBlend[0].z = currentState.currentRenderStates.cachedInvBlendFactor.z;
			if (channelWriteMask & 0x8)	outBlend[0].w = currentState.currentRenderStates.cachedInvBlendFactor.w;
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outBlend[1].x = currentState.currentRenderStates.cachedInvBlendFactor.x;
			if (channelWriteMask & 0x2)	outBlend[1].y = currentState.currentRenderStates.cachedInvBlendFactor.y;
			if (channelWriteMask & 0x4)	outBlend[1].z = currentState.currentRenderStates.cachedInvBlendFactor.z;
			if (channelWriteMask & 0x8)	outBlend[1].w = currentState.currentRenderStates.cachedInvBlendFactor.w;
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outBlend[2].x = currentState.currentRenderStates.cachedInvBlendFactor.x;
			if (channelWriteMask & 0x2)	outBlend[2].y = currentState.currentRenderStates.cachedInvBlendFactor.y;
			if (channelWriteMask & 0x4)	outBlend[2].z = currentState.currentRenderStates.cachedInvBlendFactor.z;
			if (channelWriteMask & 0x8)	outBlend[2].w = currentState.currentRenderStates.cachedInvBlendFactor.w;
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outBlend[3].x = currentState.currentRenderStates.cachedInvBlendFactor.x;
			if (channelWriteMask & 0x2)	outBlend[3].y = currentState.currentRenderStates.cachedInvBlendFactor.y;
			if (channelWriteMask & 0x4)	outBlend[3].z = currentState.currentRenderStates.cachedInvBlendFactor.z;
			if (channelWriteMask & 0x8)	outBlend[3].w = currentState.currentRenderStates.cachedInvBlendFactor.w;
		}
		break;
	}
}

template <const unsigned char channelWriteMask>
void IDirect3DDevice9Hook::AlphaBlend(D3DXVECTOR4& outVec, const D3DBLENDOP blendOp, const D3DXVECTOR4& srcBlend, const D3DXVECTOR4& dstBlend, const D3DXVECTOR4& srcColor, const D3DXVECTOR4& dstColor) const
{
	__m128 combinedSrc;
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlend == D3DBLEND_ZERO)
		combinedSrc = *(const __m128* const)&zeroVec;
	else if (currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlend == D3DBLEND_ONE)
		combinedSrc = *(const __m128* const)&srcColor;
	else
		combinedSrc = _mm_mul_ps(*(const __m128* const)&srcBlend, *(const __m128* const)&srcColor);

	__m128 combinedDst;
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.destBlend == D3DBLEND_ZERO)
		combinedDst = *(const __m128* const)&zeroVec;
	else if (currentState.currentRenderStates.renderStatesUnion.namedStates.destBlend == D3DBLEND_ONE)
		combinedDst = *(const __m128* const)&dstColor;
	else
		combinedDst = _mm_mul_ps(*(const __m128* const)&dstBlend, *(const __m128* const)&dstColor);

	// Simple SIMD version
	if ( (channelWriteMask & 0x7) == 0x7)
	{
		switch (blendOp)
		{
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Invalid D3DBLENDOP passed to alpha blending unit");
#else
			__assume(0);
#endif
		case D3DBLENDOP_ADD        :
			*(__m128* const)&outVec = _mm_add_ps(combinedSrc, combinedDst);
			return;
		case D3DBLENDOP_SUBTRACT   :
			*(__m128* const)&outVec = _mm_sub_ps(combinedSrc, combinedDst);
			return;
		case D3DBLENDOP_REVSUBTRACT:
			*(__m128* const)&outVec = _mm_sub_ps(combinedDst, combinedSrc);
			return;
		case D3DBLENDOP_MIN        :
			*(__m128* const)&outVec = _mm_min_ps(combinedSrc, combinedDst);
			return;
		case D3DBLENDOP_MAX        :
			*(__m128* const)&outVec = _mm_max_ps(combinedSrc, combinedDst);
			return;
		}

		return;
	}

	switch (blendOp)
	{
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid D3DBLENDOP passed to alpha blending unit");
#else
		__assume(0);
#endif
	case D3DBLENDOP_ADD        :
	{
		const __m128 sum = _mm_add_ps(combinedSrc, combinedDst);
		if (channelWriteMask & 0x1)
			outVec.x = sum.m128_f32[0];
		if (channelWriteMask & 0x2)
			outVec.y = sum.m128_f32[1];
		if (channelWriteMask & 0x4)
			outVec.z = sum.m128_f32[2];
		if (channelWriteMask & 0x8)
			outVec.w = sum.m128_f32[3];
	}
		break;
	case D3DBLENDOP_SUBTRACT   :
	{
		const __m128 difference = _mm_sub_ps(combinedSrc, combinedDst);
		if (channelWriteMask & 0x1)
			outVec.x = difference.m128_f32[0];
		if (channelWriteMask & 0x2)
			outVec.y = difference.m128_f32[1];
		if (channelWriteMask & 0x4)
			outVec.z = difference.m128_f32[2];
		if (channelWriteMask & 0x8)
			outVec.w = difference.m128_f32[3];
	}
		break;
	case D3DBLENDOP_REVSUBTRACT:
	{
		const __m128 revDifference = _mm_sub_ps(combinedDst, combinedSrc);
		if (channelWriteMask & 0x1)
			outVec.x = revDifference.m128_f32[0];
		if (channelWriteMask & 0x2)
			outVec.y = revDifference.m128_f32[1];
		if (channelWriteMask & 0x4)
			outVec.z = revDifference.m128_f32[2];
		if (channelWriteMask & 0x8)
			outVec.w = revDifference.m128_f32[3];
	}
		break;
	case D3DBLENDOP_MIN        :
	{
		const __m128 vecMin = _mm_min_ps(combinedSrc, combinedDst);
		if (channelWriteMask & 0x1)
			outVec.x = vecMin.m128_f32[0];
		if (channelWriteMask & 0x2)
			outVec.y = vecMin.m128_f32[1];
		if (channelWriteMask & 0x4)
			outVec.z = vecMin.m128_f32[2];
		if (channelWriteMask & 0x8)
			outVec.w = vecMin.m128_f32[3];
	}
		break;
	case D3DBLENDOP_MAX        :
	{
		const __m128 vecMax = _mm_max_ps(combinedSrc, combinedDst);
		if (channelWriteMask & 0x1)
			outVec.x = vecMax.m128_f32[0];
		if (channelWriteMask & 0x2)
			outVec.y = vecMax.m128_f32[1];
		if (channelWriteMask & 0x4)
			outVec.z = vecMax.m128_f32[2];
		if (channelWriteMask & 0x8)
			outVec.w = vecMax.m128_f32[3];
	}
		break;
	}
}

template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::AlphaBlend4(D3DXVECTOR4 (&outVec)[4], const D3DBLENDOP blendOp, const D3DXVECTOR4 (&srcBlend)[4], const D3DXVECTOR4 (&dstBlend)[4], const D3DXVECTOR4 (&srcColor)[4], const D3DXVECTOR4 (&dstColor)[4]) const
{
	if (pixelWriteMask == 0x0)
	{
#ifdef _DEBUG
		__debugbreak(); // Don't call this function if you aren't going to write any pixels out!
#endif
		return;
	}

	__m128 combinedSrc[4];
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlend == D3DBLEND_ZERO)
	{
		if (pixelWriteMask & 0x1) combinedSrc[0] = *(const __m128* const)&zeroVec;
		if (pixelWriteMask & 0x2) combinedSrc[1] = *(const __m128* const)&zeroVec;
		if (pixelWriteMask & 0x4) combinedSrc[2] = *(const __m128* const)&zeroVec;
		if (pixelWriteMask & 0x8) combinedSrc[3] = *(const __m128* const)&zeroVec;
	}
	else if (currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlend == D3DBLEND_ONE)
	{
		if (pixelWriteMask & 0x1) combinedSrc[0] = *(const __m128* const)&(srcColor[0]);
		if (pixelWriteMask & 0x2) combinedSrc[1] = *(const __m128* const)&(srcColor[1]);
		if (pixelWriteMask & 0x4) combinedSrc[2] = *(const __m128* const)&(srcColor[2]);
		if (pixelWriteMask & 0x8) combinedSrc[3] = *(const __m128* const)&(srcColor[3]);
	}
	else
	{
		if (pixelWriteMask & 0x1) combinedSrc[0] = _mm_mul_ps(*(const __m128* const)&(srcBlend[0]), *(const __m128* const)&(srcColor[0]) );
		if (pixelWriteMask & 0x2) combinedSrc[1] = _mm_mul_ps(*(const __m128* const)&(srcBlend[1]), *(const __m128* const)&(srcColor[1]) );
		if (pixelWriteMask & 0x4) combinedSrc[2] = _mm_mul_ps(*(const __m128* const)&(srcBlend[2]), *(const __m128* const)&(srcColor[2]) );
		if (pixelWriteMask & 0x8) combinedSrc[3] = _mm_mul_ps(*(const __m128* const)&(srcBlend[3]), *(const __m128* const)&(srcColor[3]) );
	}

	__m128 combinedDst[4];
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.destBlend == D3DBLEND_ZERO)
	{
		if (pixelWriteMask & 0x1) combinedDst[0] = *(const __m128* const)&zeroVec;
		if (pixelWriteMask & 0x2) combinedDst[1] = *(const __m128* const)&zeroVec;
		if (pixelWriteMask & 0x4) combinedDst[2] = *(const __m128* const)&zeroVec;
		if (pixelWriteMask & 0x8) combinedDst[3] = *(const __m128* const)&zeroVec;
	}
	else if (currentState.currentRenderStates.renderStatesUnion.namedStates.destBlend == D3DBLEND_ONE)
	{
		if (pixelWriteMask & 0x1) combinedDst[0] = *(const __m128* const)&(dstColor[0]);
		if (pixelWriteMask & 0x2) combinedDst[1] = *(const __m128* const)&(dstColor[1]);
		if (pixelWriteMask & 0x4) combinedDst[2] = *(const __m128* const)&(dstColor[2]);
		if (pixelWriteMask & 0x8) combinedDst[3] = *(const __m128* const)&(dstColor[3]);
	}
	else
	{
		if (pixelWriteMask & 0x1) combinedDst[0] = _mm_mul_ps(*(const __m128* const)&(dstBlend[0]), *(const __m128* const)&(dstColor[0]) );
		if (pixelWriteMask & 0x2) combinedDst[1] = _mm_mul_ps(*(const __m128* const)&(dstBlend[1]), *(const __m128* const)&(dstColor[1]) );		
		if (pixelWriteMask & 0x4) combinedDst[2] = _mm_mul_ps(*(const __m128* const)&(dstBlend[2]), *(const __m128* const)&(dstColor[2]) );
		if (pixelWriteMask & 0x8) combinedDst[3] = _mm_mul_ps(*(const __m128* const)&(dstBlend[3]), *(const __m128* const)&(dstColor[3]) );
	}

	// Simple SIMD version
	if ( (channelWriteMask & 0x7) == 0x7)
	{
		switch (blendOp)
		{
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Invalid D3DBLENDOP passed to alpha blending unit");
#else
			__assume(0);
#endif
		case D3DBLENDOP_ADD        :
			if (pixelWriteMask & 0x1) *(__m128* const)&(outVec[0]) = _mm_add_ps(combinedSrc[0], combinedDst[0]);
			if (pixelWriteMask & 0x2) *(__m128* const)&(outVec[1]) = _mm_add_ps(combinedSrc[1], combinedDst[1]);
			if (pixelWriteMask & 0x4) *(__m128* const)&(outVec[2]) = _mm_add_ps(combinedSrc[2], combinedDst[2]);
			if (pixelWriteMask & 0x8) *(__m128* const)&(outVec[3]) = _mm_add_ps(combinedSrc[3], combinedDst[3]);
			return;
		case D3DBLENDOP_SUBTRACT   :
			if (pixelWriteMask & 0x1) *(__m128* const)&(outVec[0]) = _mm_sub_ps(combinedSrc[0], combinedDst[0]);
			if (pixelWriteMask & 0x2) *(__m128* const)&(outVec[1]) = _mm_sub_ps(combinedSrc[1], combinedDst[1]);
			if (pixelWriteMask & 0x4) *(__m128* const)&(outVec[2]) = _mm_sub_ps(combinedSrc[2], combinedDst[2]);
			if (pixelWriteMask & 0x8) *(__m128* const)&(outVec[3]) = _mm_sub_ps(combinedSrc[3], combinedDst[3]);
			return;
		case D3DBLENDOP_REVSUBTRACT:
			if (pixelWriteMask& 0x1) *(__m128* const)&(outVec[0]) = _mm_sub_ps(combinedDst[0], combinedSrc[0]);
			if (pixelWriteMask& 0x2) *(__m128* const)&(outVec[1]) = _mm_sub_ps(combinedDst[1], combinedSrc[1]);
			if (pixelWriteMask& 0x4) *(__m128* const)&(outVec[2]) = _mm_sub_ps(combinedDst[2], combinedSrc[2]);
			if (pixelWriteMask& 0x8) *(__m128* const)&(outVec[3]) = _mm_sub_ps(combinedDst[3], combinedSrc[3]);
			return;
		case D3DBLENDOP_MIN        :
			if (pixelWriteMask & 0x1) *(__m128* const)&(outVec[0]) = _mm_min_ps(combinedSrc[0], combinedDst[0]);
			if (pixelWriteMask & 0x2) *(__m128* const)&(outVec[1]) = _mm_min_ps(combinedSrc[1], combinedDst[1]);
			if (pixelWriteMask & 0x4) *(__m128* const)&(outVec[2]) = _mm_min_ps(combinedSrc[2], combinedDst[2]);
			if (pixelWriteMask & 0x8) *(__m128* const)&(outVec[3]) = _mm_min_ps(combinedSrc[3], combinedDst[3]);
			return;
		case D3DBLENDOP_MAX        :
			if (pixelWriteMask & 0x1) *(__m128* const)&(outVec[0]) = _mm_max_ps(combinedSrc[0], combinedDst[0]);
			if (pixelWriteMask & 0x2) *(__m128* const)&(outVec[1]) = _mm_max_ps(combinedSrc[1], combinedDst[1]);
			if (pixelWriteMask & 0x4) *(__m128* const)&(outVec[2]) = _mm_max_ps(combinedSrc[2], combinedDst[2]);
			if (pixelWriteMask & 0x8) *(__m128* const)&(outVec[3]) = _mm_max_ps(combinedSrc[3], combinedDst[3]);
			return;
		}

		return;
	}

	switch (blendOp)
	{
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid D3DBLENDOP passed to alpha blending unit");
#else
		__assume(0);
#endif
	case D3DBLENDOP_ADD        :
	{
		__m128 sum4[4];
		if (pixelWriteMask & 0x1) sum4[0] = _mm_add_ps(combinedSrc[0], combinedDst[0]);
		if (pixelWriteMask & 0x2) sum4[1] = _mm_add_ps(combinedSrc[1], combinedDst[1]);
		if (pixelWriteMask & 0x4) sum4[2] = _mm_add_ps(combinedSrc[2], combinedDst[2]);
		if (pixelWriteMask & 0x8) sum4[3] = _mm_add_ps(combinedSrc[3], combinedDst[3]);

		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outVec[0].x = sum4[0].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[0].y = sum4[0].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[0].z = sum4[0].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[0].w = sum4[0].m128_f32[3];
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outVec[1].x = sum4[1].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[1].y = sum4[1].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[1].z = sum4[1].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[1].w = sum4[1].m128_f32[3];
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outVec[2].x = sum4[2].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[2].y = sum4[2].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[2].z = sum4[2].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[2].w = sum4[2].m128_f32[3];
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outVec[3].x = sum4[3].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[3].y = sum4[3].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[3].z = sum4[3].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[3].w = sum4[3].m128_f32[3];
		}
	}
		break;
	case D3DBLENDOP_SUBTRACT   :
	{
		__m128 difference4[4];
		if (pixelWriteMask & 0x1) difference4[0] = _mm_sub_ps(combinedSrc[0], combinedDst[0]);
		if (pixelWriteMask & 0x2) difference4[1] = _mm_sub_ps(combinedSrc[1], combinedDst[1]);
		if (pixelWriteMask & 0x4) difference4[2] = _mm_sub_ps(combinedSrc[2], combinedDst[2]);
		if (pixelWriteMask & 0x8) difference4[3] = _mm_sub_ps(combinedSrc[3], combinedDst[3]);

		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outVec[0].x = difference4[0].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[0].y = difference4[0].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[0].z = difference4[0].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[0].w = difference4[0].m128_f32[3];
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outVec[1].x = difference4[1].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[1].y = difference4[1].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[1].z = difference4[1].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[1].w = difference4[1].m128_f32[3];
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outVec[2].x = difference4[2].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[2].y = difference4[2].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[2].z = difference4[2].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[2].w = difference4[2].m128_f32[3];
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outVec[3].x = difference4[3].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[3].y = difference4[3].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[3].z = difference4[3].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[3].w = difference4[3].m128_f32[3];
		}
	}
		break;
	case D3DBLENDOP_REVSUBTRACT:
	{
		__m128 revDifference4[4];
		if (pixelWriteMask & 0x1) revDifference4[0] = _mm_sub_ps(combinedDst[0], combinedSrc[0]);
		if (pixelWriteMask & 0x2) revDifference4[1] = _mm_sub_ps(combinedDst[1], combinedSrc[1]);
		if (pixelWriteMask & 0x4) revDifference4[2] = _mm_sub_ps(combinedDst[2], combinedSrc[2]);
		if (pixelWriteMask & 0x8) revDifference4[3] = _mm_sub_ps(combinedDst[3], combinedSrc[3]);

		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outVec[0].x = revDifference4[0].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[0].y = revDifference4[0].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[0].z = revDifference4[0].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[0].w = revDifference4[0].m128_f32[3];
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outVec[1].x = revDifference4[1].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[1].y = revDifference4[1].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[1].z = revDifference4[1].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[1].w = revDifference4[1].m128_f32[3];
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outVec[2].x = revDifference4[2].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[2].y = revDifference4[2].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[2].z = revDifference4[2].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[2].w = revDifference4[2].m128_f32[3];
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outVec[3].x = revDifference4[3].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[3].y = revDifference4[3].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[3].z = revDifference4[3].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[3].w = revDifference4[3].m128_f32[3];
		}
	}
		break;
	case D3DBLENDOP_MIN        :
	{
		__m128 minVec4[4];
		if (pixelWriteMask & 0x1) minVec4[0] = _mm_min_ps(combinedSrc[0], combinedDst[0]);
		if (pixelWriteMask & 0x2) minVec4[1] = _mm_min_ps(combinedSrc[1], combinedDst[1]);
		if (pixelWriteMask & 0x4) minVec4[2] = _mm_min_ps(combinedSrc[2], combinedDst[2]);
		if (pixelWriteMask & 0x8) minVec4[3] = _mm_min_ps(combinedSrc[3], combinedDst[3]);

		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outVec[0].x = minVec4[0].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[0].y = minVec4[0].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[0].z = minVec4[0].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[0].w = minVec4[0].m128_f32[3];
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outVec[1].x = minVec4[1].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[1].y = minVec4[1].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[1].z = minVec4[1].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[1].w = minVec4[1].m128_f32[3];
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outVec[2].x = minVec4[2].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[2].y = minVec4[2].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[2].z = minVec4[2].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[2].w = minVec4[2].m128_f32[3];
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outVec[3].x = minVec4[3].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[3].y = minVec4[3].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[3].z = minVec4[3].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[3].w = minVec4[3].m128_f32[3];
		}
	}
		break;
	case D3DBLENDOP_MAX        :
	{
		__m128 maxVec4[4];
		if (pixelWriteMask & 0x1) maxVec4[0] = _mm_max_ps(combinedSrc[0], combinedDst[0]);
		if (pixelWriteMask & 0x2) maxVec4[1] = _mm_max_ps(combinedSrc[1], combinedDst[1]);
		if (pixelWriteMask & 0x4) maxVec4[2] = _mm_max_ps(combinedSrc[2], combinedDst[2]);
		if (pixelWriteMask & 0x8) maxVec4[3] = _mm_max_ps(combinedSrc[3], combinedDst[3]);

		if (pixelWriteMask & 0x1)
		{
			if (channelWriteMask & 0x1)	outVec[0].x = maxVec4[0].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[0].y = maxVec4[0].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[0].z = maxVec4[0].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[0].w = maxVec4[0].m128_f32[3];
		}
		if (pixelWriteMask & 0x2)
		{
			if (channelWriteMask & 0x1)	outVec[1].x = maxVec4[1].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[1].y = maxVec4[1].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[1].z = maxVec4[1].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[1].w = maxVec4[1].m128_f32[3];
		}
		if (pixelWriteMask & 0x4)
		{
			if (channelWriteMask & 0x1)	outVec[2].x = maxVec4[2].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[2].y = maxVec4[2].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[2].z = maxVec4[2].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[2].w = maxVec4[2].m128_f32[3];
		}
		if (pixelWriteMask & 0x8)
		{
			if (channelWriteMask & 0x1)	outVec[3].x = maxVec4[3].m128_f32[0];
			if (channelWriteMask & 0x2)	outVec[3].y = maxVec4[3].m128_f32[1];
			if (channelWriteMask & 0x4)	outVec[3].z = maxVec4[3].m128_f32[2];
			if (channelWriteMask & 0x8)	outVec[3].w = maxVec4[3].m128_f32[3];
		}
	}
		break;
	}
}

// Apply a 4x4 dithering algorithm when writing to surfaces with lower precision than 8 bits per pixel:
static inline void DitherColor(const unsigned x, const unsigned y, D3DXVECTOR4& ditheredColor, const IDirect3DSurface9Hook* const surface)
{
	const unsigned xMod = x & 0x3;
	const unsigned yMod = y & 0x3;

	switch (surface->GetInternalFormat() )
	{
	default:
		return;
	case D3DFMT_R5G6B5               :
	case D3DFMT_A1R5G5B5             : // Don't dither the 1 bit, it won't look good
	case D3DFMT_X1R5G5B5             :
		ditheredColor.x += uniform5bit[xMod][yMod];
		ditheredColor.y += uniform6bit[xMod][yMod];
		ditheredColor.z += uniform5bit[xMod][yMod];
		break;
	case D3DFMT_A4R4G4B4             :
	case D3DFMT_A4L4                 :
		ditheredColor.x += uniform4bit[xMod][yMod];
		ditheredColor.y += uniform4bit[xMod][yMod];
		ditheredColor.z += uniform4bit[xMod][yMod];
		ditheredColor.w += uniform4bit[xMod][yMod];
		break;
	case D3DFMT_A8R3G3B2             :
		ditheredColor.x += uniform3bit[xMod][yMod];
		ditheredColor.y += uniform3bit[xMod][yMod];
		ditheredColor.z += uniform2bit[xMod][yMod];
		break;
	case D3DFMT_X4R4G4B4             :
		ditheredColor.x += uniform4bit[xMod][yMod];
		ditheredColor.y += uniform4bit[xMod][yMod];
		ditheredColor.z += uniform4bit[xMod][yMod];
		break;
	}
}

static const unsigned noAlphaMaskDWORDs[4] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000 };
static const __m128 noAlphaMask = *(const __m128* const)noAlphaMaskDWORDs;
static const unsigned and3maskDWORDs[4] = { 0x3, 0x3, 0x3, 0x3 };
static const __m128i and3mask = *(const __m128i* const)and3maskDWORDs;
// Apply a 4x4 dithering algorithm when writing to surfaces with lower precision than 8 bits per pixel:
static inline void DitherColor4(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&ditheredColor)[4], const IDirect3DSurface9Hook* const surface)
{
	const __m128i xMod4 = _mm_and_si128(x4, and3mask);
	const __m128i yMod4 = _mm_and_si128(y4, and3mask);

	const __m128i addressOffsetIndices = _mm_add_epi32(xMod4, _mm_slli_epi32(yMod4, 2) ); // Shift left by 2 (same as multiplying by 4, the array width)

	switch (surface->GetInternalFormat() )
	{
	default:
		return;
	case D3DFMT_R5G6B5               :
	case D3DFMT_A1R5G5B5             : // Don't dither the 1 bit, it won't look good
	case D3DFMT_X1R5G5B5             :
	{
		const __m128 uniform5bit4 = _mm_i32gather_ps(&uniform5bit[0][0], addressOffsetIndices, 4);
		const __m128 uniform6bit4 = _mm_i32gather_ps(&uniform6bit[0][0], addressOffsetIndices, 4);

		const __m128 blended5566[4] = 
		{
			_mm_shuffle_ps(uniform5bit4, uniform6bit4, _MM_SHUFFLE(0, 0, 0, 0) ),
			_mm_shuffle_ps(uniform5bit4, uniform6bit4, _MM_SHUFFLE(1, 1, 1, 1) ),
			_mm_shuffle_ps(uniform5bit4, uniform6bit4, _MM_SHUFFLE(2, 2, 2, 2) ),
			_mm_shuffle_ps(uniform5bit4, uniform6bit4, _MM_SHUFFLE(3, 3, 3, 3) )
		};

		const __m128 blended5655[4] = 
		{
			_mm_shuffle_ps(blended5566[0], blended5566[0], _MM_SHUFFLE(0, 2, 0, 0) ),
			_mm_shuffle_ps(blended5566[1], blended5566[1], _MM_SHUFFLE(0, 2, 0, 0) ),
			_mm_shuffle_ps(blended5566[2], blended5566[2], _MM_SHUFFLE(0, 2, 0, 0) ),
			_mm_shuffle_ps(blended5566[3], blended5566[3], _MM_SHUFFLE(0, 2, 0, 0) )
		};

		const __m128 blended5650[4] = 
		{
			_mm_and_ps(blended5655[0], noAlphaMask),
			_mm_and_ps(blended5655[1], noAlphaMask),
			_mm_and_ps(blended5655[2], noAlphaMask),
			_mm_and_ps(blended5655[3], noAlphaMask)
		};

		*(__m128* const)&(ditheredColor[0]) = _mm_add_ps(blended5650[0], *(const __m128* const)&(ditheredColor[0]) );
		*(__m128* const)&(ditheredColor[1]) = _mm_add_ps(blended5650[1], *(const __m128* const)&(ditheredColor[1]) );
		*(__m128* const)&(ditheredColor[2]) = _mm_add_ps(blended5650[2], *(const __m128* const)&(ditheredColor[2]) );
		*(__m128* const)&(ditheredColor[3]) = _mm_add_ps(blended5650[3], *(const __m128* const)&(ditheredColor[3]) );
	}
		break;
	case D3DFMT_A4R4G4B4             :
	case D3DFMT_A4L4                 :
	case D3DFMT_X4R4G4B4             :
	{
		const __m128 uniform4bit4 = _mm_i32gather_ps(&uniform4bit[0][0], addressOffsetIndices, 4);
		__m128 ditherVectors[4];
		ditherVectors[0] = _mm_shuffle_ps(uniform4bit4, uniform4bit4, _MM_SHUFFLE(0, 0, 0, 0) );
		ditherVectors[1] = _mm_shuffle_ps(uniform4bit4, uniform4bit4, _MM_SHUFFLE(1, 1, 1, 1) );
		ditherVectors[2] = _mm_shuffle_ps(uniform4bit4, uniform4bit4, _MM_SHUFFLE(2, 2, 2, 2) );
		ditherVectors[3] = _mm_shuffle_ps(uniform4bit4, uniform4bit4, _MM_SHUFFLE(3, 3, 3, 3) );

		*(__m128* const)&(ditheredColor[0]) = _mm_add_ps(ditherVectors[0], *(const __m128* const)&(ditheredColor[0]) );
		*(__m128* const)&(ditheredColor[1]) = _mm_add_ps(ditherVectors[1], *(const __m128* const)&(ditheredColor[1]) );
		*(__m128* const)&(ditheredColor[2]) = _mm_add_ps(ditherVectors[2], *(const __m128* const)&(ditheredColor[2]) );
		*(__m128* const)&(ditheredColor[3]) = _mm_add_ps(ditherVectors[3], *(const __m128* const)&(ditheredColor[3]) );
	}
		break;
	case D3DFMT_A8R3G3B2             :
	{
		const __m128 uniform3bit4 = _mm_i32gather_ps(&uniform3bit[0][0], addressOffsetIndices, 4);
		const __m128 uniform2bit4 = _mm_i32gather_ps(&uniform2bit[0][0], addressOffsetIndices, 4);

		const __m128 blended3322[4] = 
		{
			_mm_shuffle_ps(uniform3bit4, uniform2bit4, _MM_SHUFFLE(0, 0, 0, 0) ),
			_mm_shuffle_ps(uniform3bit4, uniform2bit4, _MM_SHUFFLE(1, 1, 1, 1) ),
			_mm_shuffle_ps(uniform3bit4, uniform2bit4, _MM_SHUFFLE(2, 2, 2, 2) ),
			_mm_shuffle_ps(uniform3bit4, uniform2bit4, _MM_SHUFFLE(3, 3, 3, 3) )
		};

		const __m128 blended3320[4] = 
		{
			_mm_and_ps(blended3322[0], noAlphaMask),
			_mm_and_ps(blended3322[1], noAlphaMask),
			_mm_and_ps(blended3322[2], noAlphaMask),
			_mm_and_ps(blended3322[3], noAlphaMask)
		};

		*(__m128* const)&(ditheredColor[0]) = _mm_add_ps(blended3320[0], *(const __m128* const)&(ditheredColor[0]) );
		*(__m128* const)&(ditheredColor[1]) = _mm_add_ps(blended3320[1], *(const __m128* const)&(ditheredColor[1]) );
		*(__m128* const)&(ditheredColor[2]) = _mm_add_ps(blended3320[2], *(const __m128* const)&(ditheredColor[2]) );
		*(__m128* const)&(ditheredColor[3]) = _mm_add_ps(blended3320[3], *(const __m128* const)&(ditheredColor[3]) );
	}
		break;
	}
}

template <const unsigned char channelWriteMask>
void IDirect3DDevice9Hook::ROPBlendWriteMask(IDirect3DSurface9Hook* const outSurface, const unsigned x, const unsigned y, const D3DXVECTOR4& value) const
{
	if (currentState.currentRenderStates.simplifiedAlphaBlendMode > RenderStates::noAlphaBlending)
	{
		if (currentState.currentRenderStates.simplifiedAlphaBlendMode != RenderStates::otherAlphaBlending)
			ROPBlendWriteMask_AlphaBlendTest<channelWriteMask>(outSurface, x, y, value); // Alpha blend skip / Additive blend skip test
		else
			ROPBlendWriteMask_AlphaBlend<channelWriteMask>(outSurface, x, y, value);
	}
	else // Super simple - no alpha blending at all!
	{
		ROPBlendWriteMask_NoAlphaBlend<channelWriteMask>(outSurface, x, y, value);
	}
}

template <const unsigned char channelWriteMask>
void IDirect3DDevice9Hook::ROPBlendWriteMask_AlphaBlendTest(IDirect3DSurface9Hook* const outSurface, const unsigned x, const unsigned y, const D3DXVECTOR4& value) const
{
	switch (currentState.currentRenderStates.simplifiedAlphaBlendMode)
	{
	default:
	case RenderStates::otherAlphaBlending:
	case RenderStates::noAlphaBlending:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
		return;
	case RenderStates::alphaBlending:
	{
		if (value.w == 0.0f)
			return;
	}
		break;
	case RenderStates::additiveBlending:
	{
		// TODO: SIMDify this check
		if (value.x == 0.0f && value.y == 0.0f && value.z == 0.0f)
			return;
	}
		break;
	case RenderStates::multiplicativeBlending:
	{
		// TODO: SIMDify this check
		if (value.x == 1.0f && value.y == 1.0f && value.z == 1.0f)
			return;
	}
		break;
	}

	ROPBlendWriteMask_AlphaBlend<channelWriteMask>(outSurface, x, y, value);
}

template <const unsigned char channelWriteMask>
void IDirect3DDevice9Hook::ROPBlendWriteMask_AlphaBlend(IDirect3DSurface9Hook* const outSurface, const unsigned x, const unsigned y, const D3DXVECTOR4& value) const
{
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.separateAlphaBlendEnable) // Have to run alpha blending twice for separate alpha
	{
		// Read the dest color in from the rendertarget (read can be skipped if our alpha-blending mode is set up such that we know we'll never use the read data)
		D3DXVECTOR4 dstColor, finalColor;
		if (currentState.currentRenderStates.alphaBlendNeedsDestRead)
			outSurface->GetPixelVec<channelWriteMask, false>(x, y, dstColor);

		D3DXVECTOR4 srcBlendColor, dstBlendColor;
		LoadBlend<channelWriteMask & 0x7>(srcBlendColor, currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlend, value, dstColor);
		LoadBlend<channelWriteMask & 0x7>(dstBlendColor, currentState.currentRenderStates.renderStatesUnion.namedStates.destBlend, value, dstColor);
		AlphaBlend<channelWriteMask & 0x7>(finalColor, currentState.currentRenderStates.renderStatesUnion.namedStates.blendOp, srcBlendColor, dstBlendColor, value, dstColor);

		if (channelWriteMask & 0x8)
		{
			D3DXVECTOR4 srcBlendAlpha, dstBlendAlpha, finalAlpha;
			LoadBlend<channelWriteMask & 0x8>(srcBlendAlpha, currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlendAlpha, value, dstColor);
			LoadBlend<channelWriteMask & 0x8>(dstBlendAlpha, currentState.currentRenderStates.renderStatesUnion.namedStates.destBlendAlpha, value, dstColor);
			AlphaBlend<channelWriteMask & 0x8>(finalAlpha, currentState.currentRenderStates.renderStatesUnion.namedStates.blendOpAlpha, srcBlendAlpha, dstBlendAlpha, value, dstColor);
			finalColor.w = finalAlpha.w;
		}

		if (currentState.currentRenderStates.renderStatesUnion.namedStates.ditherEnable)
			DitherColor(x, y, finalColor, outSurface);

		outSurface->SetPixelVec<channelWriteMask>(x, y, finalColor);
	}
	else // Simple alpha blending without separate alpha
	{
		// Read the dest color in from the rendertarget (read can be skipped if our alpha-blending mode is set up such that we know we'll never use the read data)
		__declspec(align(16) ) D3DXVECTOR4 dstColor;
		if (currentState.currentRenderStates.alphaBlendNeedsDestRead)
			outSurface->GetPixelVec<channelWriteMask, false>(x, y, dstColor);

		__declspec(align(16) ) D3DXVECTOR4 srcBlend;
		__declspec(align(16) ) D3DXVECTOR4 dstBlend;
		LoadBlend<channelWriteMask>(srcBlend, currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlend, value, dstColor);
		LoadBlend<channelWriteMask>(dstBlend, currentState.currentRenderStates.renderStatesUnion.namedStates.destBlend, value, dstColor);
		AlphaBlend<channelWriteMask>(dstColor, currentState.currentRenderStates.renderStatesUnion.namedStates.blendOp, srcBlend, dstBlend, value, dstColor);

		if (currentState.currentRenderStates.renderStatesUnion.namedStates.ditherEnable)
			DitherColor(x, y, dstColor, outSurface);

		outSurface->SetPixelVec<channelWriteMask>(x, y, dstColor);
	}
}

template <const unsigned char channelWriteMask>
void IDirect3DDevice9Hook::ROPBlendWriteMask_NoAlphaBlend(IDirect3DSurface9Hook* const outSurface, const unsigned x, const unsigned y, const D3DXVECTOR4& value) const
{
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.ditherEnable)
	{
		D3DXVECTOR4 ditheredColor = value;
		DitherColor(x, y, ditheredColor, outSurface);
		outSurface->SetPixelVec<channelWriteMask>(x, y, ditheredColor);
	}
	else
		outSurface->SetPixelVec<channelWriteMask>(x, y, value);
}

template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::ROPBlendWriteMask4(IDirect3DSurface9Hook* const outSurface, const __m128i x4, const __m128i y4, const PS_2_0_OutputRegisters (&outputRegisters)[4], const unsigned char RTIndex) const
{
	if (currentState.currentRenderStates.simplifiedAlphaBlendMode > RenderStates::noAlphaBlending)
	{
		if (currentState.currentRenderStates.simplifiedAlphaBlendMode != RenderStates::otherAlphaBlending)
			ROPBlendWriteMask4_AlphaBlendTest<channelWriteMask, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		else
			ROPBlendWriteMask4_AlphaBlend<channelWriteMask, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
	}
	else // Super simple - no alpha blending at all!
	{
		ROPBlendWriteMask4_NoAlphaBlend<channelWriteMask, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
	}
}

static_assert(sizeof(PS_2_0_OutputRegisters) % sizeof(float) == 0, "Error! Unexpected struct size!");
static const unsigned gatherAlphaValues4bytes[4] = { 0, sizeof(PS_2_0_OutputRegisters) / sizeof(float), 2 * sizeof(PS_2_0_OutputRegisters) / sizeof(float), 3 * sizeof(PS_2_0_OutputRegisters) / sizeof(float) };
static const __m128i gatherAlphaValues4 = *(const __m128i* const)gatherAlphaValues4bytes;
static const __m128i additiveBlendCompareByteShuffle = _mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 8, 4, 0);

template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::ROPBlendWriteMask4_AlphaBlendTest(IDirect3DSurface9Hook* const outSurface, const __m128i x4, const __m128i y4, const PS_2_0_OutputRegisters (&outputRegisters)[4], const unsigned char RTIndex) const
{
	// Alpha blend skip:
	unsigned char failAlphaBlendMask = 0x00;
	switch (currentState.currentRenderStates.simplifiedAlphaBlendMode)
	{
	default:
	case RenderStates::otherAlphaBlending:
	case RenderStates::noAlphaBlending:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
		return;
	case RenderStates::alphaBlending:
	{
		const __declspec(align(16) ) __m128 alphaValue4 = _mm_i32gather_ps(&(outputRegisters[0].oC[RTIndex].w), gatherAlphaValues4, 4);
		failAlphaBlendMask = (const unsigned char)_mm_movemask_ps(_mm_cmpeq_ps(alphaValue4, *(const __m128* const)&zeroVec) );
	}
		break;
	case RenderStates::additiveBlending:
	{
		__declspec(align(16) ) __m128i masks;
		if (pixelWriteMask & 0x1)
			masks.m128i_u32[0] = _mm_movemask_ps(_mm_cmpeq_ps(*(const __m128* const)&(outputRegisters[0].oC[RTIndex]), *(const __m128* const)&zeroVec) );
		if (pixelWriteMask & 0x2)
			masks.m128i_u32[1] = _mm_movemask_ps(_mm_cmpeq_ps(*(const __m128* const)&(outputRegisters[1].oC[RTIndex]), *(const __m128* const)&zeroVec) );
		if (pixelWriteMask & 0x4)
			masks.m128i_u32[2] = _mm_movemask_ps(_mm_cmpeq_ps(*(const __m128* const)&(outputRegisters[2].oC[RTIndex]), *(const __m128* const)&zeroVec) );
		if (pixelWriteMask & 0x8)
			masks.m128i_u32[3] = _mm_movemask_ps(_mm_cmpeq_ps(*(const __m128* const)&(outputRegisters[3].oC[RTIndex]), *(const __m128* const)&zeroVec) );

		failAlphaBlendMask = (const unsigned char)_mm_movemask_ps(_mm_castsi128_ps(_mm_cmpeq_epi32(_mm_and_si128(masks, sevenVec), sevenVec) ) );
	}
		break;
	case RenderStates::multiplicativeBlending:
	{
		__declspec(align(16) ) __m128i masks;
		if (pixelWriteMask & 0x1)
			masks.m128i_u32[0] = _mm_movemask_ps(_mm_cmpeq_ps(*(const __m128* const)&(outputRegisters[0].oC[RTIndex]), *(const __m128* const)&staticColorWhiteOpaque) );
		if (pixelWriteMask & 0x2)
			masks.m128i_u32[1] = _mm_movemask_ps(_mm_cmpeq_ps(*(const __m128* const)&(outputRegisters[1].oC[RTIndex]), *(const __m128* const)&staticColorWhiteOpaque) );
		if (pixelWriteMask & 0x4)
			masks.m128i_u32[2] = _mm_movemask_ps(_mm_cmpeq_ps(*(const __m128* const)&(outputRegisters[2].oC[RTIndex]), *(const __m128* const)&staticColorWhiteOpaque) );
		if (pixelWriteMask & 0x8)
			masks.m128i_u32[3] = _mm_movemask_ps(_mm_cmpeq_ps(*(const __m128* const)&(outputRegisters[3].oC[RTIndex]), *(const __m128* const)&staticColorWhiteOpaque) );

		failAlphaBlendMask = (const unsigned char)_mm_movemask_ps(_mm_castsi128_ps(_mm_cmpeq_epi32(_mm_and_si128(masks, sevenVec), sevenVec) ) );
	}
		break;
	}

	const unsigned char newPixelWriteMask = pixelWriteMask & (~failAlphaBlendMask);
	switch (newPixelWriteMask)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case 0x0:
		return; // No pixels left, we're done!
	case 0x1:
		ROPBlendWriteMask_AlphaBlend<channelWriteMask>(outSurface, x4.m128i_u32[0], y4.m128i_u32[0], *(const D3DXVECTOR4* const)&(outputRegisters[0].oC[RTIndex]) );
		return;
	case 0x2:
		ROPBlendWriteMask_AlphaBlend<channelWriteMask>(outSurface, x4.m128i_u32[1], y4.m128i_u32[1], *(const D3DXVECTOR4* const)&(outputRegisters[1].oC[RTIndex]) );
		return;
	case 0x4:
		ROPBlendWriteMask_AlphaBlend<channelWriteMask>(outSurface, x4.m128i_u32[2], y4.m128i_u32[2], *(const D3DXVECTOR4* const)&(outputRegisters[2].oC[RTIndex]) );
		return;
	case 0x8:
		ROPBlendWriteMask_AlphaBlend<channelWriteMask>(outSurface, x4.m128i_u32[3], y4.m128i_u32[3], *(const D3DXVECTOR4* const)&(outputRegisters[3].oC[RTIndex]) );
		return;
	case 0x3:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0x3>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	case 0x5:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0x5>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	case 0x6:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0x6>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	case 0x7:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0x7>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	case 0x9:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0x9>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	case 0xA:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0xA>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	case 0xB:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0xB>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	case 0xC:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0xC>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	case 0xD:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0xD>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	case 0xE:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0xE>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	case 0xF:
		ROPBlendWriteMask4_AlphaBlend<channelWriteMask, 0xF>(outSurface, x4, y4, outputRegisters, RTIndex);
		return;
	}
}

template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::ROPBlendWriteMask4_AlphaBlend(IDirect3DSurface9Hook* const outSurface, const __m128i x4, const __m128i y4, const PS_2_0_OutputRegisters (&outputRegisters)[4], const unsigned char RTIndex) const
{
	// TODO: This kinda sucks. We should make a version of the blend functions that can blend pixels without copying them first
	__declspec(align(16) ) D3DXVECTOR4 colorCopy[4];
	if (pixelWriteMask & 0x1) colorCopy[0] = *(const D3DXVECTOR4* const)&(outputRegisters[0].oC[RTIndex]);
	if (pixelWriteMask & 0x2) colorCopy[1] = *(const D3DXVECTOR4* const)&(outputRegisters[1].oC[RTIndex]);
	if (pixelWriteMask & 0x4) colorCopy[2] = *(const D3DXVECTOR4* const)&(outputRegisters[2].oC[RTIndex]);
	if (pixelWriteMask & 0x8) colorCopy[3] = *(const D3DXVECTOR4* const)&(outputRegisters[3].oC[RTIndex]);

	if (currentState.currentRenderStates.renderStatesUnion.namedStates.separateAlphaBlendEnable) // Have to run alpha blending twice for separate alpha
	{
		__declspec(align(16) ) D3DXVECTOR4 dstColor[4];
		__declspec(align(16) ) D3DXVECTOR4 finalColor[4];

		// Read the dest color in from the rendertarget (read can be skipped if our alpha-blending mode is set up such that we know we'll never use the read data)
		if (currentState.currentRenderStates.alphaBlendNeedsDestRead)
			outSurface->GetPixelVec4<channelWriteMask, false, pixelWriteMask>(x4, y4, dstColor);

		__declspec(align(16) ) D3DXVECTOR4 srcBlendColor[4];
		__declspec(align(16) ) D3DXVECTOR4 dstBlendColor[4];
		LoadBlend4<channelWriteMask & 0x7, pixelWriteMask>(srcBlendColor, currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlend, colorCopy, dstColor);
		LoadBlend4<channelWriteMask & 0x7, pixelWriteMask>(dstBlendColor, currentState.currentRenderStates.renderStatesUnion.namedStates.destBlend, colorCopy, dstColor);
		AlphaBlend4<channelWriteMask & 0x7, pixelWriteMask>(finalColor, currentState.currentRenderStates.renderStatesUnion.namedStates.blendOp, srcBlendColor, dstBlendColor, colorCopy, dstColor);

		if (channelWriteMask & 0x8)
		{
			__declspec(align(16) ) D3DXVECTOR4 srcBlendAlpha[4];
			__declspec(align(16) ) D3DXVECTOR4 dstBlendAlpha[4];
			__declspec(align(16) ) D3DXVECTOR4 finalAlpha[4];
			LoadBlend4<channelWriteMask & 0x8, pixelWriteMask>(srcBlendAlpha, currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlendAlpha, colorCopy, dstColor);
			LoadBlend4<channelWriteMask & 0x8, pixelWriteMask>(dstBlendAlpha, currentState.currentRenderStates.renderStatesUnion.namedStates.destBlendAlpha, colorCopy, dstColor);
			AlphaBlend4<channelWriteMask & 0x8, pixelWriteMask>(finalAlpha, currentState.currentRenderStates.renderStatesUnion.namedStates.blendOpAlpha, srcBlendAlpha, dstBlendAlpha, colorCopy, dstColor);
			if (pixelWriteMask & 0x1) finalColor[0].w = finalAlpha[0].w;
			if (pixelWriteMask & 0x2) finalColor[1].w = finalAlpha[1].w;
			if (pixelWriteMask & 0x4) finalColor[2].w = finalAlpha[2].w;
			if (pixelWriteMask & 0x8) finalColor[3].w = finalAlpha[3].w;
		}

		if (currentState.currentRenderStates.renderStatesUnion.namedStates.ditherEnable)
			DitherColor4(x4, y4, finalColor, outSurface);

		outSurface->SetPixelVec4<channelWriteMask, pixelWriteMask>(x4, y4, finalColor);
	}
	else // Simple alpha blending without separate alpha
	{
		// Read the dest color in from the rendertarget (read can be skipped if our alpha-blending mode is set up such that we know we'll never use the read data)
		__declspec(align(16) ) D3DXVECTOR4 dstColor[4];
		if (currentState.currentRenderStates.alphaBlendNeedsDestRead)
			outSurface->GetPixelVec4<channelWriteMask, false, pixelWriteMask>(x4, y4, dstColor);

		__declspec(align(16) ) D3DXVECTOR4 srcBlend[4];
		__declspec(align(16) ) D3DXVECTOR4 dstBlend[4];
		LoadBlend4<channelWriteMask, pixelWriteMask>(srcBlend, currentState.currentRenderStates.renderStatesUnion.namedStates.srcBlend, colorCopy, dstColor);
		LoadBlend4<channelWriteMask, pixelWriteMask>(dstBlend, currentState.currentRenderStates.renderStatesUnion.namedStates.destBlend, colorCopy, dstColor);
		AlphaBlend4<channelWriteMask, pixelWriteMask>(dstColor, currentState.currentRenderStates.renderStatesUnion.namedStates.blendOp, srcBlend, dstBlend, colorCopy, dstColor);

		if (currentState.currentRenderStates.renderStatesUnion.namedStates.ditherEnable)
			DitherColor4(x4, y4, dstColor, outSurface);

		outSurface->SetPixelVec4<channelWriteMask, pixelWriteMask>(x4, y4, dstColor);
	}
}

template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::ROPBlendWriteMask4_NoAlphaBlend(IDirect3DSurface9Hook* const outSurface, const __m128i x4, const __m128i y4, const PS_2_0_OutputRegisters (&outputRegisters)[4], const unsigned char RTIndex) const
{
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.ditherEnable)
	{
		__declspec(align(16) ) D3DXVECTOR4 ditheredColor[4];
		if (pixelWriteMask & 0x1) ditheredColor[0] = *(const D3DXVECTOR4* const)&(outputRegisters[0].oC[RTIndex]);
		if (pixelWriteMask & 0x2) ditheredColor[1] = *(const D3DXVECTOR4* const)&(outputRegisters[1].oC[RTIndex]);
		if (pixelWriteMask & 0x4) ditheredColor[2] = *(const D3DXVECTOR4* const)&(outputRegisters[2].oC[RTIndex]);
		if (pixelWriteMask & 0x8) ditheredColor[3] = *(const D3DXVECTOR4* const)&(outputRegisters[3].oC[RTIndex]);
		DitherColor4(x4, y4, ditheredColor, outSurface);
		outSurface->SetPixelVec4<channelWriteMask, pixelWriteMask>(x4, y4, ditheredColor);
	}
	else
	{
		// TODO: This kinda sucks. We should make a version of SetPixelVec4 that can write out pixels without copying them first
		__declspec(align(16) ) D3DXVECTOR4 colorCopy[4];
		if (pixelWriteMask & 0x1) colorCopy[0] = *(const D3DXVECTOR4* const)&(outputRegisters[0].oC[RTIndex]);
		if (pixelWriteMask & 0x2) colorCopy[1] = *(const D3DXVECTOR4* const)&(outputRegisters[1].oC[RTIndex]);
		if (pixelWriteMask & 0x4) colorCopy[2] = *(const D3DXVECTOR4* const)&(outputRegisters[2].oC[RTIndex]);
		if (pixelWriteMask & 0x8) colorCopy[3] = *(const D3DXVECTOR4* const)&(outputRegisters[3].oC[RTIndex]);
		outSurface->SetPixelVec4<channelWriteMask, pixelWriteMask>(x4, y4, colorCopy);
	}
}

void IDirect3DDevice9Hook::RenderOutput(IDirect3DSurface9Hook* const outSurface, const unsigned x, const unsigned y, const D3DXVECTOR4& value) const
{
	// Increment pixels written stat (even if write mask is 0)
	++frameStats.numPixelsWritten;

	switch (currentState.currentRenderStates.renderStatesUnion.namedStates.colorWriteEnable)
	{
	case 0:
#ifdef _DEBUG
		__debugbreak(); // Should never be here
#else
		__assume(0);
#endif
		return;
	case 1:
		ROPBlendWriteMask<1>(outSurface, x, y, value);
		break;
	case 2:
		ROPBlendWriteMask<2>(outSurface, x, y, value);
		break;
	case 3:
		ROPBlendWriteMask<3>(outSurface, x, y, value);
		break;
	case 4:
		ROPBlendWriteMask<4>(outSurface, x, y, value);
		break;
	case 5:
		ROPBlendWriteMask<5>(outSurface, x, y, value);
		break;
	case 6:
		ROPBlendWriteMask<6>(outSurface, x, y, value);
		break;
	case 7:
		ROPBlendWriteMask<7>(outSurface, x, y, value);
		break;
	case 8:
		ROPBlendWriteMask<8>(outSurface, x, y, value);
		break;
	case 9:
		ROPBlendWriteMask<9>(outSurface, x, y, value);
		break;
	case 10:
		ROPBlendWriteMask<10>(outSurface, x, y, value);
		break;
	case 11:
		ROPBlendWriteMask<11>(outSurface, x, y, value);
		break;
	case 12:
		ROPBlendWriteMask<12>(outSurface, x, y, value);
		break;
	case 13:
		ROPBlendWriteMask<13>(outSurface, x, y, value);
		break;
	case 14:
		ROPBlendWriteMask<14>(outSurface, x, y, value);
		break;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Unexpected write mask!");
#else
		__assume(0);
#endif
	case 15:
		ROPBlendWriteMask<15>(outSurface, x, y, value);
		break;
	}
}

template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::RenderOutput4(IDirect3DSurface9Hook* const outSurface, const __m128i x4, const __m128i y4, const PS_2_0_OutputRegisters (&outputRegisters)[4], const unsigned char RTIndex) const
{
	// Increment pixels written stat (even if write mask is 0)
	switch (pixelWriteMask)
	{
	default:
	case 0x0:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
		return;
	case 0x1:
	case 0x2:
	case 0x4:
	case 0x8:
		++frameStats.numPixelsWritten;
		break;
	case 0x3:
	case 0x5:
	case 0x6:
	case 0x9:
	case 0xA:
	case 0xC:
		frameStats.numPixelsWritten += 2;
		break;
	case 0x7:
	case 0xB:
	case 0xD:
	case 0xE:
		frameStats.numPixelsWritten += 3;
		break;
	case 0xF:
		frameStats.numPixelsWritten += 4;
		break;
	}

	switch (currentState.currentRenderStates.renderStatesUnion.namedStates.colorWriteEnable)
	{
	case 0:
#ifdef _DEBUG
		__debugbreak(); // Should never be here
#else
		__assume(0);
#endif
		return;
	case 1:
		ROPBlendWriteMask4<1, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 2:
		ROPBlendWriteMask4<2, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 3:
		ROPBlendWriteMask4<3, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 4:
		ROPBlendWriteMask4<4, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 5:
		ROPBlendWriteMask4<5, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 6:
		ROPBlendWriteMask4<6, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 7:
		ROPBlendWriteMask4<7, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 8:
		ROPBlendWriteMask4<8, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 9:
		ROPBlendWriteMask4<9, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 10:
		ROPBlendWriteMask4<10, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 11:
		ROPBlendWriteMask4<11, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 12:
		ROPBlendWriteMask4<12, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 13:
		ROPBlendWriteMask4<13, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	case 14:
		ROPBlendWriteMask4<14, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Unexpected write mask!");
#else
		__assume(0);
#endif
	case 15:
		ROPBlendWriteMask4<15, pixelWriteMask>(outSurface, x4, y4, outputRegisters, RTIndex);
		break;
	}
}

// Must be called before shading a pixel to reset the pixel shader state machine!
void IDirect3DDevice9Hook::PreShadePixel(const unsigned x, const unsigned y, PShaderEngine* const pixelShader) const
{
	pixelShader->Reset(x, y);
}

// Must be called before shading a pixel to reset the pixel shader state machine!
void IDirect3DDevice9Hook::PreShadePixel4(const __m128i x4, const __m128i y4, PShaderEngine* const pixelShader) const
{
	pixelShader->Reset4(x4, y4);
}

// Handles pixel setup and depth and attribute interpolation before shading the pixel
template <const bool setupFromShader>
void IDirect3DDevice9Hook::SetupPixel(PShaderEngine* const pixelEngine, const void* const shaderOrStreamMapping, const unsigned x, const unsigned y, const __m128 barycentricInterpolants, 
	const UINT offsetBytesToOPosition, const void* const v0, const void* const v1, const void* const v2, const __m128 invZ, const __m128 invW) const
{
	const float pixelDepth = InterpolatePixelDepth(barycentricInterpolants, invZ);

	// Very important to reset the state machine back to its original settings!
	PreShadePixel(x, y, pixelEngine);

	if (currentState.currentDepthStencil)
	{
		if (!StencilTestNoWrite(x, y) )
		{
			// Fail the stencil test!
			ShadePixel_FailStencil(x, y);
			return;
		}

		if (currentState.currentRenderStates.renderStatesUnion.namedStates.zEnable)
		{
			const unsigned bufferDepth = currentState.currentDepthStencil->GetRawDepth(x, y);
			if (!DepthTest(pixelDepth, bufferDepth, currentState.currentRenderStates.renderStatesUnion.namedStates.zFunc, currentState.currentDepthStencil->GetInternalFormat() ) )
			{
				// Fail the depth test!
				ShadePixel_FailDepth(x, y);
				return;
			}
			pixelEngine->outputRegisters[0].oDepth = pixelDepth;
		}
	}

	const float interpolatedPixelW = InterpolatePixelDepth(barycentricInterpolants, invW);

	// Precompute some vectors that will be used for all of attribute interpolation
	const __m128 floatBarycentricsInvW_X = _mm_permute_ps(invW, _MM_SHUFFLE(0, 0, 0, 0) );
	const __m128 floatBarycentricsInvW_Y = _mm_permute_ps(invW, _MM_SHUFFLE(1, 1, 1, 1) );
	const __m128 floatBarycentricsInvW_Z = _mm_permute_ps(invW, _MM_SHUFFLE(2, 2, 2, 2) );
	if (setupFromShader)
	{
		InterpolateShaderIntoRegisters(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, 
			*(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2,
			floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW);
	}
	else
	{
		InterpolateStreamIntoRegisters(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, 
			(const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2,
			floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW);
	}

	ShadePixel_RunShader(x, y, pixelEngine);
}

// Handles pixel quad setup and depth and attribute interpolation before shading the pixel quad
template <const bool setupFromShader>
void IDirect3DDevice9Hook::SetupPixel4(PShaderEngine* const pixelEngine, const void* const shaderOrStreamMapping, const __m128i x4, const __m128i y4, const __m128 (&barycentricInterpolants)[4], 
	const UINT offsetBytesToOPosition, const void* const v0, const void* const v1, const void* const v2, const __m128 invZ, const __m128 invW) const
{
	__m128 pixelDepth4;
	InterpolatePixelDepth4(barycentricInterpolants, invZ, pixelDepth4);

	// Very important to reset the state machine back to its original settings!
	PreShadePixel4(x4, y4, pixelEngine);

	unsigned char pixelWriteMask = 0xF;
	if (currentState.currentDepthStencil)
	{
		if (currentState.currentRenderStates.renderStatesUnion.namedStates.stencilEnable)
		{
			const D3DCMPFUNC stencilCmp = currentState.currentRenderStates.renderStatesUnion.namedStates.stencilFunc;
			__m128i stencilTestResult4;
			switch (stencilCmp)
			{
			case D3DCMP_NEVER:
				stencilTestResult4 = zeroMaskVecI;
			case D3DCMP_ALWAYS:
				stencilTestResult4 = oneMaskVec;
			default:
				const __m128i stencil4 = currentState.currentDepthStencil->GetStencil4(x4, y4);
				stencilTestResult4 = StencilTestNoWrite4(stencil4, stencilCmp, currentState.currentRenderStates.renderStatesUnion.namedStates.stencilRef, currentState.currentRenderStates.renderStatesUnion.namedStates.stencilMask);
				break;
			}

			const unsigned char stencilMaskBits = _mm_movemask_ps(_mm_cvtepi32_ps(stencilTestResult4) );
			// Question: Does stencil fail ignore the alpha test, or does the shader still run on stencilfail pixels in order to determine if they should write to the stencil buffer or not?
		}

		if (currentState.currentRenderStates.renderStatesUnion.namedStates.zEnable)
		{
			const __m128i bufferDepth4 = currentState.currentDepthStencil->GetRawDepth4(x4, y4);
			const __m128i depthTestResults = DepthTest4(pixelDepth4, bufferDepth4, currentState.currentRenderStates.renderStatesUnion.namedStates.zFunc, currentState.currentDepthStencil->GetInternalFormat() );
			const unsigned char maskBits = _mm_movemask_ps(_mm_cvtepi32_ps(depthTestResults) );
			if (maskBits == 0x0)
				return;
			pixelWriteMask = maskBits;
			pixelEngine->outputRegisters[0].oDepth = pixelDepth4.m128_f32[0];
			pixelEngine->outputRegisters[0].pixelStatus = (maskBits & 0x1) ? normalWrite : ZFail;
			pixelEngine->outputRegisters[1].oDepth = pixelDepth4.m128_f32[1];
			pixelEngine->outputRegisters[1].pixelStatus = (maskBits & 0x2) ? normalWrite : ZFail;
			pixelEngine->outputRegisters[2].oDepth = pixelDepth4.m128_f32[2];
			pixelEngine->outputRegisters[2].pixelStatus = (maskBits & 0x4) ? normalWrite : ZFail;
			pixelEngine->outputRegisters[3].oDepth = pixelDepth4.m128_f32[3];
			pixelEngine->outputRegisters[3].pixelStatus = (maskBits & 0x8) ? normalWrite : ZFail;
		}
	}

	// Precompute some vectors that will be used for all of attribute interpolation
	const __m128 floatBarycentricsInvW_X = _mm_permute_ps(invW, _MM_SHUFFLE(0, 0, 0, 0) );
	const __m128 floatBarycentricsInvW_Y = _mm_permute_ps(invW, _MM_SHUFFLE(1, 1, 1, 1) );
	const __m128 floatBarycentricsInvW_Z = _mm_permute_ps(invW, _MM_SHUFFLE(2, 2, 2, 2) );

	__m128 interpolatedPixelW4;
	InterpolatePixelDepth4(barycentricInterpolants, invW, interpolatedPixelW4);

	switch (pixelWriteMask)
	{
	case 0x1:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0x1>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0x1>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0x1>(x4, y4, pixelEngine);
		break;
	case 0x2:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0x2>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0x2>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0x2>(x4, y4, pixelEngine);
		break;
	case 0x3:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0x3>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0x3>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0x3>(x4, y4, pixelEngine);
		break;
	case 0x4:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0x4>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0x4>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0x4>(x4, y4, pixelEngine);
		break;
	case 0x5:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0x5>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0x5>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0x5>(x4, y4, pixelEngine);
		break;
	case 0x6:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0x6>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0x6>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0x6>(x4, y4, pixelEngine);
		break;
	case 0x7:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0x7>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0x7>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0x7>(x4, y4, pixelEngine);
		break;
	case 0x8:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0x8>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0x8>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0x8>(x4, y4, pixelEngine);
		break;
	case 0x9:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0x9>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0x9>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0x9>(x4, y4, pixelEngine);
		break;
	case 0xA:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0xA>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0xA>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0xA>(x4, y4, pixelEngine);
		break;
	case 0xB:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0xB>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0xB>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0xB>(x4, y4, pixelEngine);
		break;
	case 0xC:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0xC>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0xC>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0xC>(x4, y4, pixelEngine);
		break;
	case 0xD:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0xD>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0xD>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0xD>(x4, y4, pixelEngine);
		break;
	case 0xE:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0xE>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0xE>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0xE>(x4, y4, pixelEngine);
		break;
	default:
#ifdef _DEBUG
		__debugbreak(); // Should never be here!
#else
		__assume(0);
#endif
	case 0xF:
		if (setupFromShader)
			InterpolateShaderIntoRegisters4<0xF>(pixelEngine, *(const VStoPSMapping* const)shaderOrStreamMapping, *(const VS_2_0_OutputRegisters* const)v0, *(const VS_2_0_OutputRegisters* const)v1, *(const VS_2_0_OutputRegisters* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		else
			InterpolateStreamIntoRegisters4<0xF>(pixelEngine, *(const DeclarationSemanticMapping* const)shaderOrStreamMapping, (const BYTE* const)v0, (const BYTE* const)v1, (const BYTE* const)v2, 
				floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, barycentricInterpolants, interpolatedPixelW4);
		ShadePixel4_RunShader<0xF>(x4, y4, pixelEngine);
		break;
	}
}

// This is a non-perspective-correct attribute interpolation ("affine interpolation"):
static inline void InterpolateVertexAttribute(const D3DXVECTOR3& floatBarycentrics, const D3DXVECTOR4& attr0, const D3DXVECTOR4& attr1, const D3DXVECTOR4& attr2, D3DXVECTOR4& outAttr)
{
	outAttr.x = attr0.x * floatBarycentrics.x + attr1.x * floatBarycentrics.y + attr2.x * floatBarycentrics.z;
	outAttr.y = attr0.y * floatBarycentrics.x + attr1.y * floatBarycentrics.y + attr2.y * floatBarycentrics.z;
	outAttr.z = attr0.z * floatBarycentrics.x + attr1.z * floatBarycentrics.y + attr2.z * floatBarycentrics.z;
	outAttr.w = attr0.w * floatBarycentrics.x + attr1.w * floatBarycentrics.y + attr2.w * floatBarycentrics.z;
}

// This is a perspective-correct attribute interpolation:
static inline void InterpolateVertexAttribute_PerspectiveCorrect(const D3DXVECTOR4& attr0, const D3DXVECTOR4& attr1, const D3DXVECTOR4& attr2, const __m128 floatBarycentricsInvW_X, const __m128 floatBarycentricsInvW_Y, const __m128 floatBarycentricsInvW_Z, D3DXVECTOR4& outAttr, const __m128 barycentricInterpolants, const float interpolatedPixelW)
{
	const __m128* const attr0ptr = (const __m128* const)&attr0;
	const __m128* const attr1ptr = (const __m128* const)&attr1;
	const __m128* const attr2ptr = (const __m128* const)&attr2;

	// Computing p0, p1, p2, and p10, and p20 could all be done in the vertex shader if we know that the attribute will be perspective-corrected (or skipped if the attribute will be LINEAR or CONSTANT interpolated instead)
	const __m128 p0 = _mm_mul_ps(floatBarycentricsInvW_X, *attr0ptr);
	const __m128 p1 = _mm_mul_ps(floatBarycentricsInvW_Y, *attr1ptr);
	const __m128 p2 = _mm_mul_ps(floatBarycentricsInvW_Z, *attr2ptr);
	const __m128 p10 = _mm_sub_ps(p1, p0);
	const __m128 p20 = _mm_sub_ps(p2, p0);

	// Note that barycentricA is not needed. If it were needed, we could always recover it using the equation: A + B + C = 1 (or for this purpose, A = 1 - B - C)
	const __m128 barycentricB = _mm_permute_ps(barycentricInterpolants, _MM_SHUFFLE(1, 1, 1, 1) );
	const __m128 barycentricC = _mm_permute_ps(barycentricInterpolants, _MM_SHUFFLE(2, 2, 2, 2) );

	const __m128 barycentricDotProduct = _mm_add_ps(_mm_add_ps(_mm_mul_ps(p10, barycentricB), _mm_mul_ps(p20, barycentricC) ), p0);

	const __m128 pixelW_float4 = _mm_load1_ps(&interpolatedPixelW);

	__m128* const outAttrPtr = (__m128* const)&outAttr;
	*outAttrPtr = _mm_mul_ps(pixelW_float4, barycentricDotProduct);
}

// This is a perspective-correct attribute interpolation:
static inline void InterpolateVertexAttribute_PerspectiveCorrect4(const D3DXVECTOR4& attr0, const D3DXVECTOR4& attr1, const D3DXVECTOR4& attr2, 
	const __m128 invWSplatted_X, const __m128 invWSplatted_Y, const __m128 invWSplatted_Z, D3DXVECTOR4 (&outAttr4)[4], const __m128 (&barycentricInterpolants)[4], const __m128 interpolatedPixelW4)
{
	const __m128 attr0vec = *(const __m128* const)&attr0;
	const __m128 attr1vec = *(const __m128* const)&attr1;
	const __m128 attr2vec = *(const __m128* const)&attr2;

	// Computing p0, p1, p2, and p10, and p20 could all be done in the vertex shader if we know that the attribute will be perspective-corrected (or skipped if the attribute will be LINEAR or CONSTANT interpolated instead)
	const __m128 p0 = _mm_mul_ps(invWSplatted_X, attr0vec);
	const __m128 p1 = _mm_mul_ps(invWSplatted_Y, attr1vec);
	const __m128 p2 = _mm_mul_ps(invWSplatted_Z, attr2vec);
	const __m128 p10 = _mm_sub_ps(p1, p0);
	const __m128 p20 = _mm_sub_ps(p2, p0);

	const __m128 barycentricB[4] =
	{
		_mm_permute_ps(barycentricInterpolants[0], _MM_SHUFFLE(1, 1, 1, 1) ),
		_mm_permute_ps(barycentricInterpolants[1], _MM_SHUFFLE(1, 1, 1, 1) ),
		_mm_permute_ps(barycentricInterpolants[2], _MM_SHUFFLE(1, 1, 1, 1) ),
		_mm_permute_ps(barycentricInterpolants[3], _MM_SHUFFLE(1, 1, 1, 1) )
	};
	const __m128 barycentricC[4] =
	{
		_mm_permute_ps(barycentricInterpolants[0], _MM_SHUFFLE(2, 2, 2, 2) ),
		_mm_permute_ps(barycentricInterpolants[1], _MM_SHUFFLE(2, 2, 2, 2) ),
		_mm_permute_ps(barycentricInterpolants[2], _MM_SHUFFLE(2, 2, 2, 2) ),
		_mm_permute_ps(barycentricInterpolants[3], _MM_SHUFFLE(2, 2, 2, 2) )
	};

	const __m128 dotProductResult[4] =
	{
		_mm_add_ps(_mm_add_ps(_mm_mul_ps(p10, barycentricB[0]), _mm_mul_ps(p20, barycentricC[0]) ), p0),
		_mm_add_ps(_mm_add_ps(_mm_mul_ps(p10, barycentricB[1]), _mm_mul_ps(p20, barycentricC[1]) ), p0),
		_mm_add_ps(_mm_add_ps(_mm_mul_ps(p10, barycentricB[2]), _mm_mul_ps(p20, barycentricC[2]) ), p0),
		_mm_add_ps(_mm_add_ps(_mm_mul_ps(p10, barycentricB[3]), _mm_mul_ps(p20, barycentricC[3]) ), p0)
	};

	const __m128 pixelW_float4[4] = 
	{
		_mm_permute_ps(interpolatedPixelW4, _MM_SHUFFLE(0, 0, 0, 0) ),
		_mm_permute_ps(interpolatedPixelW4, _MM_SHUFFLE(1, 1, 1, 1) ),
		_mm_permute_ps(interpolatedPixelW4, _MM_SHUFFLE(2, 2, 2, 2) ),
		_mm_permute_ps(interpolatedPixelW4, _MM_SHUFFLE(3, 3, 3, 3) )
	};
	*(__m128* const)&(outAttr4[0]) = _mm_mul_ps(pixelW_float4[0], dotProductResult[0]);
	*(__m128* const)&(outAttr4[1]) = _mm_mul_ps(pixelW_float4[1], dotProductResult[1]);
	*(__m128* const)&(outAttr4[2]) = _mm_mul_ps(pixelW_float4[2], dotProductResult[2]);
	*(__m128* const)&(outAttr4[3]) = _mm_mul_ps(pixelW_float4[3], dotProductResult[3]);
}

// Handles interpolating pixel shader input registers from a vertex declaration + raw vertex stream
void IDirect3DDevice9Hook::InterpolateStreamIntoRegisters(PShaderEngine* const pixelShader, const DeclarationSemanticMapping& vertexDeclMapping, CONST BYTE* const v0, CONST BYTE* const v1, CONST BYTE* const v2, 
	const __m128 floatBarycentricsInvW_X, const __m128 floatBarycentricsInvW_Y, const __m128 floatBarycentricsInvW_Z, const __m128 barycentricInterpolants, const float interpolatedPixelW) const
{
	const ShaderInfo& pixelShaderInfo = currentState.currentPixelShader->GetShaderInfo();
	if (pixelShaderInfo.shaderMajorVersion == 1)
	{
		for (unsigned char v = 0; v < D3DMCS_COLOR2; ++v)
		{
			if (pixelShaderInfo.inputRegistersUsedBitmask & (1 << v) )
			{
				D3DXVECTOR4& interpolatedFloatValue = *(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.v[v]);

				const DebuggableD3DVERTEXELEMENT9* const foundColorValue = vertexDeclMapping.vals[D3DDECLUSAGE_COLOR][v];
				if (foundColorValue)
				{
					__declspec(align(16) ) D3DXVECTOR4 cf0;
					const D3DDECLTYPE registerLoadType = foundColorValue->Type;
					LoadElementToRegister(cf0, registerLoadType, (v0 + foundColorValue->Offset) );

					if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT)
					{
						// Color interpolator registers:
						__declspec(align(16) ) D3DXVECTOR4 cf1;
						__declspec(align(16) ) D3DXVECTOR4 cf2;
						LoadElementToRegister(cf1, registerLoadType, (v1 + foundColorValue->Offset) );
						LoadElementToRegister(cf2, registerLoadType, (v2 + foundColorValue->Offset) );

						InterpolateVertexAttribute_PerspectiveCorrect(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedFloatValue, barycentricInterpolants, interpolatedPixelW);
					}
					else
					{
						interpolatedFloatValue = cf0;
					}
				}
				else
				{
					// It seems like this is correct behavior (color usage elements that are unbound from either the VS or pretransformed vertex data are read into the PS as (1,1,1,1) whereas all other usages are (0,0,0,0) ), but I can't find documentation for this
					interpolatedFloatValue = staticColorWhiteOpaque;
				}
			}
		}
		for (unsigned char t = 0; t < 6; ++t)
		{
			if (pixelShaderInfo.inputRegistersUsedBitmask & (1 << (t + D3DMCS_COLOR2) ) )
			{
				D3DXVECTOR4& interpolatedFloatValue = *(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.t[t]);

				const DebuggableD3DVERTEXELEMENT9* const foundTexcoordValue = vertexDeclMapping.vals[D3DDECLUSAGE_TEXCOORD][t];
				if (foundTexcoordValue)
				{
					__declspec(align(16) ) D3DXVECTOR4 cf0;
					const D3DDECLTYPE registerLoadType = foundTexcoordValue->Type;
					LoadElementToRegister(cf0, registerLoadType, (v0 + foundTexcoordValue->Offset) );

					if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT)
					{
						// Texcoord interpolator registers:
						__declspec(align(16) ) D3DXVECTOR4 cf1;
						__declspec(align(16) ) D3DXVECTOR4 cf2;
						LoadElementToRegister(cf1, registerLoadType, (v1 + foundTexcoordValue->Offset) );
						LoadElementToRegister(cf2, registerLoadType, (v2 + foundTexcoordValue->Offset) );

						InterpolateVertexAttribute_PerspectiveCorrect(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedFloatValue, barycentricInterpolants, interpolatedPixelW);
					}
					else
					{
						interpolatedFloatValue = cf0;
					}
				}
				else
				{
					interpolatedFloatValue = staticColorBlackTranslucent;
				}
			}
		}
	}
	else if (pixelShaderInfo.shaderMajorVersion == 2)
	{
		const unsigned numDeclaredRegisters = pixelShaderInfo.declaredRegisters.size();
		for (unsigned x = 0; x < numDeclaredRegisters; ++x)
		{
			const DeclaredRegister& reg = pixelShaderInfo.declaredRegisters[x];
			if (reg.registerType == D3DSPR_INPUT)
			{
				// Color interpolator registers:
				D3DXVECTOR4& interpolatedFloatValue = *(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.v[reg.registerIndex]);
				const DebuggableD3DVERTEXELEMENT9* const element = vertexDeclMapping.vals[D3DDECLUSAGE_COLOR][reg.usageIndex];
				if (!element)
				{
					// It seems like this is correct behavior (color usage elements that are unbound from either the VS or pretransformed vertex data are read into the PS as (1,1,1,1) whereas all other usages are (0,0,0,0) ), but I can't find documentation for this
					if (reg.usageType == D3DDECLUSAGE_COLOR)
					{
						interpolatedFloatValue = staticColorWhiteOpaque;
					}
					else
					{
						interpolatedFloatValue = staticColorBlackTranslucent;
					}
				}
				else
				{
					__declspec(align(16) ) D3DXVECTOR4 cf0;
					const D3DDECLTYPE registerLoadType = element->Type;
					LoadElementToRegister(cf0, registerLoadType, (v0 + element->Offset) );

					// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
					if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT && reg.usageType != D3DDECLUSAGE_BLENDINDICES)
					{
						// Color interpolator registers:
						__declspec(align(16) ) D3DXVECTOR4 cf1;
						__declspec(align(16) ) D3DXVECTOR4 cf2;
						LoadElementToRegister(cf1, registerLoadType, (v1 + element->Offset) );
						LoadElementToRegister(cf2, registerLoadType, (v2 + element->Offset) );

						InterpolateVertexAttribute_PerspectiveCorrect(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedFloatValue, barycentricInterpolants, interpolatedPixelW);
					}
					else
					{
						interpolatedFloatValue = cf0;
					}
				}
			}
			else if (reg.registerType == D3DSPR_TEXTURE)
			{
				// Texcoord interpolator registers:
				const DebuggableD3DVERTEXELEMENT9* const element = vertexDeclMapping.vals[D3DDECLUSAGE_TEXCOORD][reg.usageIndex];
				D3DXVECTOR4& interpolatedFloatValue = *(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.t[reg.registerIndex]);
				if (!element)
				{
					// It seems like this is correct behavior (color usage elements that are unbound from either the VS or pretransformed vertex data are read into the PS as (1,1,1,1) whereas all other usages are (0,0,0,0) ), but I can't find documentation for this
					if (reg.usageType == D3DDECLUSAGE_COLOR)
					{
						interpolatedFloatValue = staticColorWhiteOpaque;
					}
					else
					{
						interpolatedFloatValue = staticColorBlackTranslucent;
					}
				}
				else
				{
					__declspec(align(16) ) D3DXVECTOR4 cf0;
					const D3DDECLTYPE registerLoadType = element->Type;
					LoadElementToRegister(cf0, registerLoadType, (v0 + element->Offset) );

					// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
					if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT && reg.usageType != D3DDECLUSAGE_BLENDINDICES)
					{
						// Texcoord interpolator registers:
						__declspec(align(16) ) D3DXVECTOR4 cf1;
						__declspec(align(16) ) D3DXVECTOR4 cf2;
						LoadElementToRegister(cf1, registerLoadType, (v1 + element->Offset) );
						LoadElementToRegister(cf2, registerLoadType, (v2 + element->Offset) );

						InterpolateVertexAttribute_PerspectiveCorrect(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedFloatValue, barycentricInterpolants, interpolatedPixelW);
					}
					else
					{
						interpolatedFloatValue = cf0;
					}
				}
			}
		}
	}
	else if (pixelShaderInfo.shaderMajorVersion == 3)
	{
		const unsigned numDeclaredRegisters = pixelShaderInfo.declaredRegisters.size();
		for (unsigned x = 0; x < numDeclaredRegisters; ++x)
		{
			const DeclaredRegister& reg = pixelShaderInfo.declaredRegisters[x];
			if (reg.registerType == D3DSPR_INPUT)
			{
				// Interpolator registers:
				D3DXVECTOR4& interpolatedFloatValue = *(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_3_0_inputs.t[reg.registerIndex]);
				const DebuggableD3DVERTEXELEMENT9* const element = vertexDeclMapping.vals[reg.usageType][reg.usageIndex];
				if (!element)
				{
					// It seems like this is correct behavior (color usage elements that are unbound from either the VS or pretransformed vertex data are read into the PS as (1,1,1,1) whereas all other usages are (0,0,0,0) ), but I can't find documentation for this
					if (reg.usageType == D3DDECLUSAGE_COLOR)
					{
						interpolatedFloatValue = staticColorWhiteOpaque;
					}
					else
					{
						interpolatedFloatValue = staticColorBlackTranslucent;
					}
				}
				else
				{
					__declspec(align(16) ) D3DXVECTOR4 cf0;
					const D3DDECLTYPE registerLoadType = element->Type;

					LoadElementToRegister(cf0, registerLoadType, (v0 + element->Offset) );

					// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
					if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT && reg.usageType != D3DDECLUSAGE_BLENDINDICES)
					{
						// Interpolator registers:
						__declspec(align(16) ) D3DXVECTOR4 cf1;
						__declspec(align(16) ) D3DXVECTOR4 cf2;
						LoadElementToRegister(cf1, registerLoadType, (v1 + element->Offset) );
						LoadElementToRegister(cf2, registerLoadType, (v2 + element->Offset) );

						// TODO: Implement PS_3_0 interpreters too
						InterpolateVertexAttribute_PerspectiveCorrect(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedFloatValue, barycentricInterpolants, interpolatedPixelW);
					}
					else
					{
						interpolatedFloatValue = cf0;
					}
				}
			}
		}
	}
#ifdef _DEBUG
	else
	{
		DbgBreakPrint("Error: Unknown pixel shader version specified (not 1, 2, or 3)");
	}
#endif
}

// Handles interpolating pixel shader input registers from a vertex declaration + raw vertex stream
template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::InterpolateStreamIntoRegisters4(PShaderEngine* const pixelShader, const DeclarationSemanticMapping& vertexDeclMapping, CONST BYTE* const v0, CONST BYTE* const v1, CONST BYTE* const v2, 
	const __m128 floatBarycentricsInvW_X, const __m128 floatBarycentricsInvW_Y, const __m128 floatBarycentricsInvW_Z, const __m128 (&barycentricInterpolants)[4], const __m128 interpolatedPixelW4) const
{
	const ShaderInfo& pixelShaderInfo = currentState.currentPixelShader->GetShaderInfo();
	if (pixelShaderInfo.shaderMajorVersion == 1)
	{
		for (unsigned char v = 0; v < D3DMCS_COLOR2; ++v)
		{
			if (pixelShaderInfo.inputRegistersUsedBitmask & (1 << v) )
			{
				D3DXVECTOR4* const interpolatedOutRegisterValues[4] = 
				{
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.v[v]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[1].ps_interpolated_inputs.ps_2_0_inputs.v[v]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[2].ps_interpolated_inputs.ps_2_0_inputs.v[v]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[3].ps_interpolated_inputs.ps_2_0_inputs.v[v])
				};

				const DebuggableD3DVERTEXELEMENT9* const foundColorValue = vertexDeclMapping.vals[D3DDECLUSAGE_COLOR][v];
				if (foundColorValue)
				{
					__declspec(align(16) ) D3DXVECTOR4 cf0;
					const D3DDECLTYPE registerLoadType = foundColorValue->Type;
					LoadElementToRegister(cf0, registerLoadType, (v0 + foundColorValue->Offset) );

					if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT)
					{
						// Color interpolator registers:
						__declspec(align(16) ) D3DXVECTOR4 cf1;
						__declspec(align(16) ) D3DXVECTOR4 cf2;
						LoadElementToRegister(cf1, registerLoadType, (v1 + foundColorValue->Offset) );
						LoadElementToRegister(cf2, registerLoadType, (v2 + foundColorValue->Offset) );

						D3DXVECTOR4 interpolatedValues4[4];
						InterpolateVertexAttribute_PerspectiveCorrect4(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedValues4, barycentricInterpolants, interpolatedPixelW4);
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = interpolatedValues4[0];
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = interpolatedValues4[1];
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = interpolatedValues4[2];
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = interpolatedValues4[3];
					}
					else
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = cf0;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = cf0;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = cf0;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = cf0;
					}
				}
				else
				{
					// It seems like this is correct behavior (color usage elements that are unbound from either the VS or pretransformed vertex data are read into the PS as (1,1,1,1) whereas all other usages are (0,0,0,0) ), but I can't find documentation for this
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = staticColorWhiteOpaque;
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = staticColorWhiteOpaque;
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = staticColorWhiteOpaque;
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = staticColorWhiteOpaque;
				}
			}
		}
		for (unsigned char t = 0; t < 6; ++t)
		{
			if (pixelShaderInfo.inputRegistersUsedBitmask & (1 << (t + D3DMCS_COLOR2) ) )
			{
				D3DXVECTOR4* const interpolatedOutRegisterValues[4] = 
				{
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.t[t]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[1].ps_interpolated_inputs.ps_2_0_inputs.t[t]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[2].ps_interpolated_inputs.ps_2_0_inputs.t[t]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[3].ps_interpolated_inputs.ps_2_0_inputs.t[t])
				};

				const DebuggableD3DVERTEXELEMENT9* const foundTexcoordValue = vertexDeclMapping.vals[D3DDECLUSAGE_TEXCOORD][t];
				if (foundTexcoordValue)
				{
					__declspec(align(16) ) D3DXVECTOR4 cf0;
					const D3DDECLTYPE registerLoadType = foundTexcoordValue->Type;
					LoadElementToRegister(cf0, registerLoadType, (v0 + foundTexcoordValue->Offset) );

					if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT)
					{
						// Texcoord interpolator registers:
						__declspec(align(16) ) D3DXVECTOR4 cf1;
						__declspec(align(16) ) D3DXVECTOR4 cf2;
						LoadElementToRegister(cf1, registerLoadType, (v1 + foundTexcoordValue->Offset) );
						LoadElementToRegister(cf2, registerLoadType, (v2 + foundTexcoordValue->Offset) );

						D3DXVECTOR4 interpolatedValues4[4];
						InterpolateVertexAttribute_PerspectiveCorrect4(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedValues4, barycentricInterpolants, interpolatedPixelW4);
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = interpolatedValues4[0];
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = interpolatedValues4[1];
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = interpolatedValues4[2];
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = interpolatedValues4[3];
					}
					else
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = cf0;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = cf0;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = cf0;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = cf0;
					}
				}
				else
				{
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = staticColorBlackTranslucent;
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = staticColorBlackTranslucent;
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = staticColorBlackTranslucent;
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = staticColorBlackTranslucent;
				}
			}
		}
	}
	else if (pixelShaderInfo.shaderMajorVersion == 2)
	{
		const unsigned numDeclaredRegisters = pixelShaderInfo.declaredRegisters.size();
		for (unsigned x = 0; x < numDeclaredRegisters; ++x)
		{
			const DeclaredRegister& reg = pixelShaderInfo.declaredRegisters[x];
			if (reg.registerType == D3DSPR_INPUT)
			{
				// Color interpolator registers:
				D3DXVECTOR4* const interpolatedOutRegisterValues[4] = 
				{
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.v[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[1].ps_interpolated_inputs.ps_2_0_inputs.v[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[2].ps_interpolated_inputs.ps_2_0_inputs.v[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[3].ps_interpolated_inputs.ps_2_0_inputs.v[reg.registerIndex])
				};
				const DebuggableD3DVERTEXELEMENT9* const element = vertexDeclMapping.vals[D3DDECLUSAGE_COLOR][reg.usageIndex];
				if (!element)
				{
					// It seems like this is correct behavior (color usage elements that are unbound from either the VS or pretransformed vertex data are read into the PS as (1,1,1,1) whereas all other usages are (0,0,0,0) ), but I can't find documentation for this
					if (reg.usageType == D3DDECLUSAGE_COLOR)
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = staticColorWhiteOpaque;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = staticColorWhiteOpaque;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = staticColorWhiteOpaque;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = staticColorWhiteOpaque;
					}
					else
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = staticColorBlackTranslucent;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = staticColorBlackTranslucent;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = staticColorBlackTranslucent;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = staticColorBlackTranslucent;
					}
				}
				else
				{
					__declspec(align(16) ) D3DXVECTOR4 cf0;
					const D3DDECLTYPE registerLoadType = element->Type;
					LoadElementToRegister(cf0, registerLoadType, (v0 + element->Offset) );

					// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
					if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT && reg.usageType != D3DDECLUSAGE_BLENDINDICES)
					{
						// Color interpolator registers:
						__declspec(align(16) ) D3DXVECTOR4 cf1;
						__declspec(align(16) ) D3DXVECTOR4 cf2;
						LoadElementToRegister(cf1, registerLoadType, (v1 + element->Offset) );
						LoadElementToRegister(cf2, registerLoadType, (v2 + element->Offset) );

						D3DXVECTOR4 interpolatedValues4[4];
						InterpolateVertexAttribute_PerspectiveCorrect4(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedValues4, barycentricInterpolants, interpolatedPixelW4);
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = interpolatedValues4[0];
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = interpolatedValues4[1];
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = interpolatedValues4[2];
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = interpolatedValues4[3];
					}
					else
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = cf0;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = cf0;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = cf0;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = cf0;
					}
				}
			}
			else if (reg.registerType == D3DSPR_TEXTURE)
			{
				// Texcoord interpolator registers:
				const DebuggableD3DVERTEXELEMENT9* const element = vertexDeclMapping.vals[D3DDECLUSAGE_TEXCOORD][reg.usageIndex];
				D3DXVECTOR4* const interpolatedOutRegisterValues[4] = 
				{
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[1].ps_interpolated_inputs.ps_2_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[2].ps_interpolated_inputs.ps_2_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[3].ps_interpolated_inputs.ps_2_0_inputs.t[reg.registerIndex])
				};
				if (!element)
				{
					// It seems like this is correct behavior (color usage elements that are unbound from either the VS or pretransformed vertex data are read into the PS as (1,1,1,1) whereas all other usages are (0,0,0,0) ), but I can't find documentation for this
					if (reg.usageType == D3DDECLUSAGE_COLOR)
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = staticColorWhiteOpaque;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = staticColorWhiteOpaque;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = staticColorWhiteOpaque;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = staticColorWhiteOpaque;
					}
					else
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = staticColorBlackTranslucent;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = staticColorBlackTranslucent;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = staticColorBlackTranslucent;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = staticColorBlackTranslucent;
					}
				}
				else
				{
					__declspec(align(16) ) D3DXVECTOR4 cf0;
					const D3DDECLTYPE registerLoadType = element->Type;
					LoadElementToRegister(cf0, registerLoadType, (v0 + element->Offset) );

					// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
					if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT && reg.usageType != D3DDECLUSAGE_BLENDINDICES)
					{
						// Texcoord interpolator registers:
						__declspec(align(16) ) D3DXVECTOR4 cf1;
						__declspec(align(16) ) D3DXVECTOR4 cf2;
						LoadElementToRegister(cf1, registerLoadType, (v1 + element->Offset) );
						LoadElementToRegister(cf2, registerLoadType, (v2 + element->Offset) );

						D3DXVECTOR4 interpolatedValues4[4];
						InterpolateVertexAttribute_PerspectiveCorrect4(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedValues4, barycentricInterpolants, interpolatedPixelW4);
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = interpolatedValues4[0];
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = interpolatedValues4[1];
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = interpolatedValues4[2];
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = interpolatedValues4[3];
					}
					else
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = cf0;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = cf0;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = cf0;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = cf0;
					}
				}
			}
		}
	}
	else if (pixelShaderInfo.shaderMajorVersion == 3)
	{
		const unsigned numDeclaredRegisters = pixelShaderInfo.declaredRegisters.size();
		for (unsigned x = 0; x < numDeclaredRegisters; ++x)
		{
			const DeclaredRegister& reg = pixelShaderInfo.declaredRegisters[x];
			if (reg.registerType == D3DSPR_INPUT)
			{
				// Interpolator registers:
				D3DXVECTOR4* const interpolatedOutRegisterValues[4] = 
				{
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_3_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[1].ps_interpolated_inputs.ps_3_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[2].ps_interpolated_inputs.ps_3_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[3].ps_interpolated_inputs.ps_3_0_inputs.t[reg.registerIndex])
				};
				const DebuggableD3DVERTEXELEMENT9* const element = vertexDeclMapping.vals[reg.usageType][reg.usageIndex];
				if (!element)
				{
					// It seems like this is correct behavior (color usage elements that are unbound from either the VS or pretransformed vertex data are read into the PS as (1,1,1,1) whereas all other usages are (0,0,0,0) ), but I can't find documentation for this
					if (reg.usageType == D3DDECLUSAGE_COLOR)
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = staticColorWhiteOpaque;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = staticColorWhiteOpaque;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = staticColorWhiteOpaque;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = staticColorWhiteOpaque;
					}
					else
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = staticColorBlackTranslucent;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = staticColorBlackTranslucent;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = staticColorBlackTranslucent;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = staticColorBlackTranslucent;
					}
				}
				else
				{
					__declspec(align(16) ) D3DXVECTOR4 cf0;
					const D3DDECLTYPE registerLoadType = element->Type;

					LoadElementToRegister(cf0, registerLoadType, (v0 + element->Offset) );

					// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
					if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT && reg.usageType != D3DDECLUSAGE_BLENDINDICES)
					{
						// Interpolator registers:
						__declspec(align(16) ) D3DXVECTOR4 cf1;
						__declspec(align(16) ) D3DXVECTOR4 cf2;
						LoadElementToRegister(cf1, registerLoadType, (v1 + element->Offset) );
						LoadElementToRegister(cf2, registerLoadType, (v2 + element->Offset) );

						// TODO: Implement PS_3_0 interpreters too
						D3DXVECTOR4 interpolatedValues4[4];
						InterpolateVertexAttribute_PerspectiveCorrect4(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedValues4, barycentricInterpolants, interpolatedPixelW4);
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = interpolatedValues4[0];
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = interpolatedValues4[1];
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = interpolatedValues4[2];
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = interpolatedValues4[3];
					}
					else
					{
						if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = cf0;
						if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = cf0;
						if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = cf0;
						if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = cf0;
					}
				}
			}
		}
	}
#ifdef _DEBUG
	else
	{
		DbgBreakPrint("Error: Unknown pixel shader version specified (not 1, 2, or 3)");
	}
#endif
}

const float IDirect3DDevice9Hook::InterpolatePixelDepth(__m128 barycentricInterpolants, const __m128 invZ) const
{
	__m128 deltaInvZ = _mm_sub_ps(invZ, _mm_shuffle_ps(invZ, invZ, _MM_SHUFFLE(0, 0, 0, 0) ) );
	deltaInvZ.m128_f32[0] = invZ.m128_f32[0];

	barycentricInterpolants.m128_f32[0] = 1.0f;
	const __m128 invInterpolatedDepth = _mm_dp_ps(deltaInvZ, barycentricInterpolants, 0x77);

	// Re-inverting the Z depth is technically not necessary as a [0, 1] depth buffer will functionally work the same
	// even with reciprocal depth values so long as the depth comparisons are flipped too.
	// But for the purposes of this software rasterizer and since we're sharing this function between both the per-pixel Z
	// and W calculations, we'll do this inversion to get the correct values out.
	return _mm_div_ps(oneVec, invInterpolatedDepth).m128_f32[0];
}

void IDirect3DDevice9Hook::InterpolatePixelDepth4(const __m128 (&barycentricInterpolants4)[4], const __m128 invZ, __m128& outPixelDepth4) const
{
	__m128 deltaInvZ = _mm_sub_ps(invZ, _mm_shuffle_ps(invZ, invZ, _MM_SHUFFLE(0, 0, 0, 0) ) );
	deltaInvZ.m128_f32[0] = invZ.m128_f32[0];

	__m128 barycentricInterpolantsCopy[4] =
	{
		barycentricInterpolants4[0],
		barycentricInterpolants4[1],
		barycentricInterpolants4[2],
		barycentricInterpolants4[3]
	};
	barycentricInterpolantsCopy[0].m128_f32[0] = 1.0f;
	barycentricInterpolantsCopy[1].m128_f32[0] = 1.0f;
	barycentricInterpolantsCopy[2].m128_f32[0] = 1.0f;
	barycentricInterpolantsCopy[3].m128_f32[0] = 1.0f;
	const __m128 dotProdResult0 = _mm_dp_ps(deltaInvZ, barycentricInterpolantsCopy[0], 0x77);
	const __m128 dotProdResult1 = _mm_dp_ps(deltaInvZ, barycentricInterpolantsCopy[1], 0x77);
	const __m128 dotProdResult2 = _mm_dp_ps(deltaInvZ, barycentricInterpolantsCopy[2], 0x77);
	const __m128 dotProdResult3 = _mm_dp_ps(deltaInvZ, barycentricInterpolantsCopy[3], 0x77);

	const __m128 invInterpolatedDepth4 = 
	{
		dotProdResult0.m128_f32[0],
		dotProdResult1.m128_f32[0],
		dotProdResult2.m128_f32[0],
		dotProdResult3.m128_f32[0]
	};

	// Re-inverting the Z depth is technically not necessary as a [0, 1] depth buffer will functionally work the same
	// even with reciprocal depth values so long as the depth comparisons are flipped too.
	// But for the purposes of this software rasterizer and since we're sharing this function between both the per-pixel Z
	// and W calculations, we'll do this inversion to get the correct values out.
	const __m128 pixelDepth4 = _mm_div_ps(oneVec, invInterpolatedDepth4);
	outPixelDepth4 = pixelDepth4;
}

// Handles interpolating pixel shader input registers from vertex shader output registers
// TODO: Like InterpolateStreamIntoRegisters, have this function fill with (1,1,1,1) for input color usage registers or (0,0,0,0) for other usages if the vertex shader doesn't write to the corresponding output registers
void IDirect3DDevice9Hook::InterpolateShaderIntoRegisters(PShaderEngine* const pixelShader, const VStoPSMapping& vs_psMapping, const VS_2_0_OutputRegisters& v0, const VS_2_0_OutputRegisters& v1, const VS_2_0_OutputRegisters& v2, 
	const __m128 floatBarycentricsInvW_X, const __m128 floatBarycentricsInvW_Y, const __m128 floatBarycentricsInvW_Z, const __m128 barycentricInterpolants, const float interpolatedPixelW) const
{
	const ShaderInfo& pixelShaderInfo = currentState.currentPixelShader->GetShaderInfo();
	if (pixelShaderInfo.shaderMajorVersion == 1)
	{
		// ps_1_* doesn't use input declarations, so we need to use another method to figure out which input registers we need interpolated
		for (unsigned char v = 0; v < D3DMCS_COLOR2; ++v)
		{
			if (pixelShaderInfo.inputRegistersUsedBitmask & (1 << v) )
			{
				const unsigned char vsRegisterIndex = v;
				const D3DXVECTOR4& cf0 = *(const D3DXVECTOR4* const)&(v0.vs_interpolated_outputs.vs_2_0_outputs.oD[vsRegisterIndex]);
				D3DXVECTOR4& interpolatedFloatValue = *(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.v[v]);
				if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT)
				{
					const D3DXVECTOR4& cf1 = *(const D3DXVECTOR4* const)&(v1.vs_interpolated_outputs.vs_2_0_outputs.oD[vsRegisterIndex]);
					const D3DXVECTOR4& cf2 = *(const D3DXVECTOR4* const)&(v2.vs_interpolated_outputs.vs_2_0_outputs.oD[vsRegisterIndex]);
					InterpolateVertexAttribute_PerspectiveCorrect(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedFloatValue, barycentricInterpolants, interpolatedPixelW);
				}
				else
				{
					interpolatedFloatValue = cf0;
				}
			}
		}
		for (unsigned char t = 0; t < 6; ++t)
		{
			if (pixelShaderInfo.inputRegistersUsedBitmask & (1 << (t + D3DMCS_COLOR2) ) )
			{
				const unsigned char vsRegisterIndex = t;
				const D3DXVECTOR4& cf0 = *(const D3DXVECTOR4* const)&(v0.vs_interpolated_outputs.vs_2_0_outputs.oT[vsRegisterIndex]);
				D3DXVECTOR4& interpolatedFloatValue = *(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.t[t]);
				if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT)
				{
					const D3DXVECTOR4& cf1 = *(const D3DXVECTOR4* const)&(v1.vs_interpolated_outputs.vs_2_0_outputs.oT[vsRegisterIndex]);
					const D3DXVECTOR4& cf2 = *(const D3DXVECTOR4* const)&(v2.vs_interpolated_outputs.vs_2_0_outputs.oT[vsRegisterIndex]);
					InterpolateVertexAttribute_PerspectiveCorrect(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedFloatValue, barycentricInterpolants, interpolatedPixelW);
				}
				else
				{
					interpolatedFloatValue = cf0;
				}
			}
		}
	}
	else if (pixelShaderInfo.shaderMajorVersion == 2)
	{
		const unsigned numDeclaredRegisters = pixelShaderInfo.declaredRegisters.size();
		for (unsigned x = 0; x < numDeclaredRegisters; ++x)
		{
			const DeclaredRegister& reg = pixelShaderInfo.declaredRegisters[x];
			if (reg.registerType == D3DSPR_INPUT)
			{
				// Color interpolator registers:
				const unsigned vsRegisterIndex = vs_psMapping.psInputRegistersUnion.ps_2_0_registers.colors[reg.registerIndex];
				const D3DXVECTOR4& cf0 = *(const D3DXVECTOR4* const)&(v0.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);

				D3DXVECTOR4& interpolatedFloatValue = *(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.v[reg.registerIndex]);

				// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
				if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT && reg.usageType != D3DDECLUSAGE_BLENDINDICES)
				{
					// Color interpolator registers:
					const D3DXVECTOR4& cf1 = *(const D3DXVECTOR4* const)&(v1.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
					const D3DXVECTOR4& cf2 = *(const D3DXVECTOR4* const)&(v2.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
					InterpolateVertexAttribute_PerspectiveCorrect(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedFloatValue, barycentricInterpolants, interpolatedPixelW);
				}
				else
				{
					interpolatedFloatValue = cf0;
				}
			}
			else if (reg.registerType == D3DSPR_TEXTURE)
			{
				// Texcoord interpolator registers:
				const unsigned vsRegisterIndex = vs_psMapping.psInputRegistersUnion.ps_2_0_registers.texCoords[reg.registerIndex];
				const D3DXVECTOR4& cf0 = *(const D3DXVECTOR4* const)&(v0.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
				D3DXVECTOR4& interpolatedFloatValue = *(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.t[reg.registerIndex]);

				// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
				if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT && reg.usageType != D3DDECLUSAGE_BLENDINDICES)
				{
					// Texcoord interpolator registers:
					const D3DXVECTOR4& cf1 = *(const D3DXVECTOR4* const)&(v1.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
					const D3DXVECTOR4& cf2 = *(const D3DXVECTOR4* const)&(v2.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
					InterpolateVertexAttribute_PerspectiveCorrect(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedFloatValue, barycentricInterpolants, interpolatedPixelW);
				}
				else
				{
					interpolatedFloatValue = cf0;
				}
			}
		}
	}
	else if (pixelShaderInfo.shaderMajorVersion == 3)
	{
		const unsigned numDeclaredRegisters = pixelShaderInfo.declaredRegisters.size();
		for (unsigned x = 0; x < numDeclaredRegisters; ++x)
		{
			const DeclaredRegister& reg = pixelShaderInfo.declaredRegisters[x];
			if (reg.registerType == D3DSPR_INPUT)
			{
				// Interpolator registers:
				const unsigned vsRegisterIndex = vs_psMapping.psInputRegistersUnion.ps_3_0_registers.inputs[reg.registerIndex];
				const D3DXVECTOR4& cf0 = *(const D3DXVECTOR4* const)&(v0.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
				D3DXVECTOR4& interpolatedFloatValue = *(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_3_0_inputs.t[reg.registerIndex]);

				// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
				if (reg.usageType != D3DDECLUSAGE_BLENDINDICES)
				{
					// Interpolator registers:
					const D3DXVECTOR4& cf1 = *(const D3DXVECTOR4* const)&(v1.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
					const D3DXVECTOR4& cf2 = *(const D3DXVECTOR4* const)&(v2.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);

					// TODO: Implement PS_3_0 interpreters too
					InterpolateVertexAttribute_PerspectiveCorrect(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedFloatValue, barycentricInterpolants, interpolatedPixelW);
				}
				else
				{
					interpolatedFloatValue = cf0;
				}
			}
		}
	}
#ifdef _DEBUG
	else
	{
		DbgBreakPrint("Error: Unknown pixel shader version specified (not 1, 2, or 3)");
	}
#endif
}

// Handles interpolating pixel shader input registers from vertex shader output registers
// TODO: Like InterpolateStreamIntoRegisters, have this function fill with (1,1,1,1) for input color usage registers or (0,0,0,0) for other usages if the vertex shader doesn't write to the corresponding output registers
template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::InterpolateShaderIntoRegisters4(PShaderEngine* const pixelShader, const VStoPSMapping& vs_psMapping, const VS_2_0_OutputRegisters& v0, const VS_2_0_OutputRegisters& v1, const VS_2_0_OutputRegisters& v2, 
	const __m128 floatBarycentricsInvW_X, const __m128 floatBarycentricsInvW_Y, const __m128 floatBarycentricsInvW_Z, const __m128 (&barycentricInterpolants)[4], const __m128 interpolatedPixelW4) const
{
	const ShaderInfo& pixelShaderInfo = currentState.currentPixelShader->GetShaderInfo();
	if (pixelShaderInfo.shaderMajorVersion == 1)
	{
		// ps_1_* doesn't use input declarations, so we need to use another method to figure out which input registers we need interpolated
		for (unsigned char v = 0; v < D3DMCS_COLOR2; ++v)
		{
			if (pixelShaderInfo.inputRegistersUsedBitmask & (1 << v) )
			{
				const unsigned char vsRegisterIndex = v;
				const D3DXVECTOR4& cf0 = *(const D3DXVECTOR4* const)&(v0.vs_interpolated_outputs.vs_2_0_outputs.oD[vsRegisterIndex]);
				D3DXVECTOR4* const interpolatedOutRegisterValues[4] = 
				{
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.v[v]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[1].ps_interpolated_inputs.ps_2_0_inputs.v[v]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[2].ps_interpolated_inputs.ps_2_0_inputs.v[v]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[3].ps_interpolated_inputs.ps_2_0_inputs.v[v])
				};
				if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT)
				{
					const D3DXVECTOR4& cf1 = *(const D3DXVECTOR4* const)&(v1.vs_interpolated_outputs.vs_2_0_outputs.oD[vsRegisterIndex]);
					const D3DXVECTOR4& cf2 = *(const D3DXVECTOR4* const)&(v2.vs_interpolated_outputs.vs_2_0_outputs.oD[vsRegisterIndex]);
					
					D3DXVECTOR4 interpolatedValues4[4];
					InterpolateVertexAttribute_PerspectiveCorrect4(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedValues4, barycentricInterpolants, interpolatedPixelW4);
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = interpolatedValues4[0];
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = interpolatedValues4[1];
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = interpolatedValues4[2];
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = interpolatedValues4[3];
				}
				else
				{
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = cf0;
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = cf0;
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = cf0;
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = cf0;
				}
			}
		}
		for (unsigned char t = 0; t < 6; ++t)
		{
			if (pixelShaderInfo.inputRegistersUsedBitmask & (1 << (t + D3DMCS_COLOR2) ) )
			{
				const unsigned char vsRegisterIndex = t;
				const D3DXVECTOR4& cf0 = *(const D3DXVECTOR4* const)&(v0.vs_interpolated_outputs.vs_2_0_outputs.oT[vsRegisterIndex]);
				D3DXVECTOR4* const interpolatedOutRegisterValues[4] = 
				{
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.t[t]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[1].ps_interpolated_inputs.ps_2_0_inputs.t[t]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[2].ps_interpolated_inputs.ps_2_0_inputs.t[t]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[3].ps_interpolated_inputs.ps_2_0_inputs.t[t])
				};
				if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT)
				{
					const D3DXVECTOR4& cf1 = *(const D3DXVECTOR4* const)&(v1.vs_interpolated_outputs.vs_2_0_outputs.oT[vsRegisterIndex]);
					const D3DXVECTOR4& cf2 = *(const D3DXVECTOR4* const)&(v2.vs_interpolated_outputs.vs_2_0_outputs.oT[vsRegisterIndex]);
					
					D3DXVECTOR4 interpolatedValues4[4];
					InterpolateVertexAttribute_PerspectiveCorrect4(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedValues4, barycentricInterpolants, interpolatedPixelW4);
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = interpolatedValues4[0];
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = interpolatedValues4[1];
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = interpolatedValues4[2];
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = interpolatedValues4[3];
				}
				else
				{
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = cf0;
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = cf0;
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = cf0;
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = cf0;
				}
			}
		}
	}
	else if (pixelShaderInfo.shaderMajorVersion == 2)
	{
		const unsigned numDeclaredRegisters = pixelShaderInfo.declaredRegisters.size();
		for (unsigned x = 0; x < numDeclaredRegisters; ++x)
		{
			const DeclaredRegister& reg = pixelShaderInfo.declaredRegisters[x];
			if (reg.registerType == D3DSPR_INPUT)
			{
				// Color interpolator registers:
				const unsigned vsRegisterIndex = vs_psMapping.psInputRegistersUnion.ps_2_0_registers.colors[reg.registerIndex];
				const D3DXVECTOR4& cf0 = *(const D3DXVECTOR4* const)&(v0.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);

				D3DXVECTOR4* const interpolatedOutRegisterValues[4] = 
				{
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.v[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[1].ps_interpolated_inputs.ps_2_0_inputs.v[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[2].ps_interpolated_inputs.ps_2_0_inputs.v[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[3].ps_interpolated_inputs.ps_2_0_inputs.v[reg.registerIndex])
				};

				// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
				if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT && reg.usageType != D3DDECLUSAGE_BLENDINDICES)
				{
					// Color interpolator registers:
					const D3DXVECTOR4& cf1 = *(const D3DXVECTOR4* const)&(v1.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
					const D3DXVECTOR4& cf2 = *(const D3DXVECTOR4* const)&(v2.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
					
					D3DXVECTOR4 interpolatedValues4[4];
					InterpolateVertexAttribute_PerspectiveCorrect4(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedValues4, barycentricInterpolants, interpolatedPixelW4);
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = interpolatedValues4[0];
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = interpolatedValues4[1];
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = interpolatedValues4[2];
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = interpolatedValues4[3];
				}
				else
				{
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = cf0;
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = cf0;
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = cf0;
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = cf0;
				}
			}
			else if (reg.registerType == D3DSPR_TEXTURE)
			{
				// Texcoord interpolator registers:
				const unsigned vsRegisterIndex = vs_psMapping.psInputRegistersUnion.ps_2_0_registers.texCoords[reg.registerIndex];
				const D3DXVECTOR4& cf0 = *(const D3DXVECTOR4* const)&(v0.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
				D3DXVECTOR4* const interpolatedOutRegisterValues[4] = 
				{
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[1].ps_interpolated_inputs.ps_2_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[2].ps_interpolated_inputs.ps_2_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[3].ps_interpolated_inputs.ps_2_0_inputs.t[reg.registerIndex])
				};

				// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
				if (currentState.currentRenderStates.renderStatesUnion.namedStates.shadeMode != D3DSHADE_FLAT && reg.usageType != D3DDECLUSAGE_BLENDINDICES)
				{
					// Texcoord interpolator registers:
					const D3DXVECTOR4& cf1 = *(const D3DXVECTOR4* const)&(v1.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
					const D3DXVECTOR4& cf2 = *(const D3DXVECTOR4* const)&(v2.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
					
					D3DXVECTOR4 interpolatedValues4[4];
					InterpolateVertexAttribute_PerspectiveCorrect4(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedValues4, barycentricInterpolants, interpolatedPixelW4);
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = interpolatedValues4[0];
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = interpolatedValues4[1];
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = interpolatedValues4[2];
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = interpolatedValues4[3];
				}
				else
				{
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = cf0;
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = cf0;
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = cf0;
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = cf0;
				}
			}
		}
	}
	else if (pixelShaderInfo.shaderMajorVersion == 3)
	{
		const unsigned numDeclaredRegisters = pixelShaderInfo.declaredRegisters.size();
		for (unsigned x = 0; x < numDeclaredRegisters; ++x)
		{
			const DeclaredRegister& reg = pixelShaderInfo.declaredRegisters[x];
			if (reg.registerType == D3DSPR_INPUT)
			{
				// Interpolator registers:
				const unsigned vsRegisterIndex = vs_psMapping.psInputRegistersUnion.ps_3_0_registers.inputs[reg.registerIndex];
				const D3DXVECTOR4& cf0 = *(const D3DXVECTOR4* const)&(v0.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
				D3DXVECTOR4* const interpolatedOutRegisterValues[4] = 
				{
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[0].ps_interpolated_inputs.ps_3_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[1].ps_interpolated_inputs.ps_3_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[2].ps_interpolated_inputs.ps_3_0_inputs.t[reg.registerIndex]),
					(D3DXVECTOR4* const)&(pixelShader->inputRegisters[3].ps_interpolated_inputs.ps_3_0_inputs.t[reg.registerIndex])
				};

				// TODO: Look into whether or not D3DDECLUSAGE_POSITION in pixel shaders disables perspective correction for that interpolated register or not
				if (reg.usageType != D3DDECLUSAGE_BLENDINDICES)
				{
					// Interpolator registers:
					const D3DXVECTOR4& cf1 = *(const D3DXVECTOR4* const)&(v1.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);
					const D3DXVECTOR4& cf2 = *(const D3DXVECTOR4* const)&(v2.vs_interpolated_outputs.vs_3_0_outputs.oT[vsRegisterIndex]);

					// TODO: Implement PS_3_0 interpreters too
					
					D3DXVECTOR4 interpolatedValues4[4];
					InterpolateVertexAttribute_PerspectiveCorrect4(cf0, cf1, cf2, floatBarycentricsInvW_X, floatBarycentricsInvW_Y, floatBarycentricsInvW_Z, interpolatedValues4, barycentricInterpolants, interpolatedPixelW4);
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = interpolatedValues4[0];
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = interpolatedValues4[1];
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = interpolatedValues4[2];
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = interpolatedValues4[3];
				}
				else
				{
					if (pixelWriteMask & 0x1) *interpolatedOutRegisterValues[0] = cf0;
					if (pixelWriteMask & 0x2) *interpolatedOutRegisterValues[1] = cf0;
					if (pixelWriteMask & 0x4) *interpolatedOutRegisterValues[2] = cf0;
					if (pixelWriteMask & 0x8) *interpolatedOutRegisterValues[3] = cf0;
				}
			}
		}
	}
#ifdef _DEBUG
	else
	{
		DbgBreakPrint("Error: Unknown pixel shader version specified (not 1, 2, or 3)");
	}
#endif
}

void IDirect3DDevice9Hook::ShadePixel_RunShader(const unsigned x, const unsigned y, PShaderEngine* const pixelShader) const
{
	++frameStats.numPixelsShaded;

	// Perform pixel shading:
#ifndef FORCE_INTERPRETED_PIXEL_SHADER
	if (currentState.currentPixelShader->jitShaderMain)
	{
		// Execute JIT pixel shader engine:
		currentState.currentPixelShader->jitShaderMain(*pixelShader);
	}
	else
#endif
	{
		// Execute interpreted pixel shader engine:
		pixelShader->InterpreterExecutePixel();
	}

	if (currentState.currentPixelShader->GetShaderInfo().usesTexkill)
		PostShadePixel_DiscardTest(x, y, pixelShader->outputRegisters[0]);
	else
		PostShadePixel_AlphaTest(x, y, pixelShader->outputRegisters[0]);
}

void IDirect3DDevice9Hook::PostShadePixel_DiscardTest(const unsigned x, const unsigned y, const PS_2_0_OutputRegisters& pixelShaderOutput) const
{
	if (pixelShaderOutput.pixelStatus == discard)
	{
		PostShadePixel_Discard(x, y);
		return;
	}

	// Alpha testing:
	PostShadePixel_AlphaTest(x, y, pixelShaderOutput);
}

void IDirect3DDevice9Hook::PostShadePixel_AlphaTest(const unsigned x, const unsigned y, const PS_2_0_OutputRegisters& pixelShaderOutput) const
{
	// This MSDN page says that alpha testing only happens against the alpha value from oC0: https://docs.microsoft.com/en-us/windows/desktop/direct3d9/multiple-render-targets
	if (!AlphaTest(*(const D3DXVECTOR4* const)&(pixelShaderOutput.oC[0]) ) )
	{
		PostShadePixel_FailAlphaTest(x, y);
		return;
	}

	PostShadePixel_WriteOutput(x, y, pixelShaderOutput);
}

void IDirect3DDevice9Hook::PostShadePixel_WriteOutput(const unsigned x, const unsigned y, const PS_2_0_OutputRegisters& pixelShaderOutput) const
{
	PostShadePixel_WriteOutputColor(x, y, pixelShaderOutput);

	if (currentState.currentDepthStencil)
	{
		if (currentState.currentRenderStates.renderStatesUnion.namedStates.zWriteEnable)
		{
			// TODO: Re-run depth test in the case that this pixel shader writes out a custom depth
			PostShadePixel_WriteOutputDepth(x, y, pixelShaderOutput.oDepth);
		}
			
		if (currentState.currentRenderStates.renderStatesUnion.namedStates.stencilEnable)
		{
			PostShadePixel_WriteOutputStencil(x, y);
		}
	}
}

void IDirect3DDevice9Hook::ShadePixel_FailStencil(const unsigned x, const unsigned y) const
{
	const unsigned xCoord = x >> SUBPIXEL_ACCURACY_BITS;
	const unsigned yCoord = y >> SUBPIXEL_ACCURACY_BITS;
	StencilFailOperation(xCoord, yCoord);
}

void IDirect3DDevice9Hook::ShadePixel_FailDepth(const unsigned x, const unsigned y) const
{
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.stencilEnable)
	{
		const unsigned xCoord = x >> SUBPIXEL_ACCURACY_BITS;
		const unsigned yCoord = y >> SUBPIXEL_ACCURACY_BITS;
		StencilZFailOperation(xCoord, yCoord);
	}
}

void IDirect3DDevice9Hook::PostShadePixel_FailAlphaTest(const unsigned x, const unsigned y) const
{
	UNREFERENCED_PARAMETER(x);
	UNREFERENCED_PARAMETER(y);

	++frameStats.numAlphaTestFailPixels;
}

void IDirect3DDevice9Hook::PostShadePixel_Discard(const unsigned x, const unsigned y) const
{
	UNREFERENCED_PARAMETER(x);
	UNREFERENCED_PARAMETER(y);

	++frameStats.numPixelsTexkilled;
}

void IDirect3DDevice9Hook::PostShadePixel_WriteOutputColor(const unsigned x, const unsigned y, const PS_2_0_OutputRegisters& pixelOutputColor) const
{
	const unsigned xCoord = x >> SUBPIXEL_ACCURACY_BITS;
	const unsigned yCoord = y >> SUBPIXEL_ACCURACY_BITS;
	for (unsigned char rt = 0; rt < D3D_MAX_SIMULTANEOUS_RENDERTARGETS; ++rt)
	{
		IDirect3DSurface9Hook* const currentRenderTarget = currentState.currentRenderTargets[rt];
		if (!currentRenderTarget)
			continue;

		RenderOutput(currentRenderTarget, xCoord, yCoord, *(const D3DXVECTOR4* const)&(pixelOutputColor.oC[rt]) );
	}
}

void IDirect3DDevice9Hook::PostShadePixel_WriteOutputDepth(const unsigned x, const unsigned y, const float pixelOutputDepth) const
{
	const unsigned xCoord = x >> SUBPIXEL_ACCURACY_BITS;
	const unsigned yCoord = y >> SUBPIXEL_ACCURACY_BITS;
	const float depthBias = currentState.currentRenderStates.renderStatesUnion.namedStates.depthBias;
	currentState.currentDepthStencil->SetDepth(xCoord, yCoord, pixelOutputDepth + depthBias);
}

void IDirect3DDevice9Hook::PostShadePixel_WriteOutputStencil(const unsigned x, const unsigned y) const
{
	StencilPassOperation(x, y);
}

template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::ShadePixel4_RunShader(const __m128i x4, const __m128i y4, PShaderEngine* const pixelShader) const
{
	frameStats.numPixelsShaded += 4;

	// Perform pixel shading:
	// TODO: Need to write a quad execution interpreter engine, and a quad JIT engine to replace this
	// Hack for now, need to preserve the 0th set of output registers or else they'll get clobbered by later
	// iterations of pixel shading
	__declspec(align(16) ) PS_2_0_OutputRegisters savedOutputRegs0;
	for (unsigned char z = 0; z < 4; ++z)
	{
		if (!(pixelWriteMask & (1 << z) ) )
			continue;

		if (z != 0)
			pixelShader->inputRegisters[0] = pixelShader->inputRegisters[z];

#ifndef FORCE_INTERPRETED_PIXEL_SHADER
		if (currentState.currentPixelShader->jitShaderMain)
		{
			// Execute JIT pixel shader engine:
			currentState.currentPixelShader->jitShaderMain(*pixelShader);
		}
		else
#endif
		{
			// Execute interpreted pixel shader engine:
			pixelShader->Reset(x4.m128i_u32[z], y4.m128i_u32[z]); // HACK!
			pixelShader->InterpreterExecutePixel();
		}

		if (z != 0)
			pixelShader->outputRegisters[z] = pixelShader->outputRegisters[0];
		else
			savedOutputRegs0 = pixelShader->outputRegisters[0];
	}
	if (pixelWriteMask & 0x1)
		pixelShader->outputRegisters[0] = savedOutputRegs0;

	if (currentState.currentPixelShader->GetShaderInfo().usesTexkill)
		PostShadePixel4_DiscardTest<pixelWriteMask>(x4, y4, pixelShader);
	else
		PostShadePixel4_AlphaTest<pixelWriteMask>(x4, y4, pixelShader);
}

template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::ShadePixel4_FailStencil(const __m128i x4, const __m128i y4) const
{
	for (unsigned char z = 0; z < 4; ++z)
	{
		if (pixelWriteMask & (1 << z) )
		{
			StencilFailOperation(x4.m128i_u32[z], y4.m128i_u32[z]);
		}
	}
}

template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::ShadePixel4_FailDepth(const __m128i x4, const __m128i y4) const
{
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.stencilEnable)
	{
		for (unsigned char z = 0; z < 4; ++z)
		{
			if (pixelWriteMask & (1 << z) )
			{
				StencilZFailOperation(x4.m128i_u32[z], y4.m128i_u32[z]);
			}
		}
	}
}

static_assert(sizeof(PS_2_0_OutputRegisters) % sizeof(DWORD) == 0, "Error! Unexpected size slack!");
static const unsigned outputRegisterOffsetsGatherBytes[4] = { 0, sizeof(PS_2_0_OutputRegisters) / sizeof(DWORD), sizeof(PS_2_0_OutputRegisters) * 2 / sizeof(DWORD), sizeof(PS_2_0_OutputRegisters) * 3 / sizeof(DWORD) };
static const __m128i outputRegisterOffsetsGather = *(const __m128i* const)outputRegisterOffsetsGatherBytes;

static const __m128i pixelStatusDiscardCheck4 = _mm_set1_epi32(discard);

template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::PostShadePixel4_DiscardTest(const __m128i x4, const __m128i y4, PShaderEngine* const pixelShader) const
{
	// Handle discard (texkill) here now, then call PostShadePixel4_Discard() for any discarded pixels
	const __m128i pixelStatus4 = _mm_i32gather_epi32( (const int* const)&(pixelShader->outputRegisters[0].pixelStatus), outputRegisterOffsetsGather, 4);
	const unsigned char pixelDiscardMask = pixelWriteMask & (const unsigned char)(_mm_movemask_ps(_mm_cvtepi32_ps(_mm_cmpeq_epi32(pixelStatus4, pixelStatusDiscardCheck4) ) ) );
	PostShadePixel4_Discard(pixelDiscardMask);

	const unsigned char pixelWriteMask_postDiscard = pixelWriteMask & (~pixelDiscardMask);
	switch (pixelWriteMask_postDiscard)
	{
	default:
#ifdef _DEBUG
		__debugbreak(); // Should never be here!
#else
		__assume(0);
#endif
	case 0x0:
		return; // No pixels left, we're done!
	case 0x1:
		PostShadePixel_AlphaTest(x4.m128i_u32[0], y4.m128i_u32[0], pixelShader->outputRegisters[0]);
		return;
	case 0x2:
		PostShadePixel_AlphaTest(x4.m128i_u32[1], y4.m128i_u32[1], pixelShader->outputRegisters[1]);
		return;
	case 0x4:
		PostShadePixel_AlphaTest(x4.m128i_u32[2], y4.m128i_u32[2], pixelShader->outputRegisters[2]);
		return;
	case 0x8:
		PostShadePixel_AlphaTest(x4.m128i_u32[3], y4.m128i_u32[3], pixelShader->outputRegisters[3]);
		return;
	case 0x3:
		PostShadePixel4_AlphaTest<0x3>(x4, y4, pixelShader);
		return;
	case 0x5:
		PostShadePixel4_AlphaTest<0x5>(x4, y4, pixelShader);
		return;
	case 0x6:
		PostShadePixel4_AlphaTest<0x6>(x4, y4, pixelShader);
		return;
	case 0x7:
		PostShadePixel4_AlphaTest<0x7>(x4, y4, pixelShader);
		return;
	case 0x9:
		PostShadePixel4_AlphaTest<0x9>(x4, y4, pixelShader);
		return;
	case 0xA:
		PostShadePixel4_AlphaTest<0xA>(x4, y4, pixelShader);
		return;
	case 0xB:
		PostShadePixel4_AlphaTest<0xB>(x4, y4, pixelShader);
		return;
	case 0xC:
		PostShadePixel4_AlphaTest<0xC>(x4, y4, pixelShader);
		return;
	case 0xD:
		PostShadePixel4_AlphaTest<0xD>(x4, y4, pixelShader);
		return;
	case 0xE:
		PostShadePixel4_AlphaTest<0xE>(x4, y4, pixelShader);
		return;
	case 0xF:
		PostShadePixel4_AlphaTest<0xF>(x4, y4, pixelShader);
		return;
	}
}

template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::PostShadePixel4_AlphaTest(const __m128i x4, const __m128i y4, PShaderEngine* const pixelShader) const
{
	const unsigned char postAlphaTestWriteMask = pixelWriteMask & _mm_movemask_ps(AlphaTest4<0xF>(pixelShader->outputRegisters) );
	switch (postAlphaTestWriteMask)
	{
	default:
#ifdef _DEBUG
		__debugbreak(); // Should never be here!
#else
		__assume(0);
#endif
	case 0x0:
		return; // No more pixels left, we're done!
	case 0x1:
		PostShadePixel_WriteOutput(x4.m128i_u32[0], y4.m128i_u32[0], pixelShader->outputRegisters[0]);
		return;
	case 0x2:
		PostShadePixel_WriteOutput(x4.m128i_u32[1], y4.m128i_u32[1], pixelShader->outputRegisters[1]);
		return;
	case 0x4:
		PostShadePixel_WriteOutput(x4.m128i_u32[2], y4.m128i_u32[2], pixelShader->outputRegisters[2]);
		return;
	case 0x8:
		PostShadePixel_WriteOutput(x4.m128i_u32[3], y4.m128i_u32[3], pixelShader->outputRegisters[3]);
		return;
	case 0x3:
		PostShadePixel4_WriteOutput<0x3>(x4, y4, pixelShader);
		return;
	case 0x5:
		PostShadePixel4_WriteOutput<0x5>(x4, y4, pixelShader);
		return;
	case 0x6:
		PostShadePixel4_WriteOutput<0x6>(x4, y4, pixelShader);
		return;
	case 0x7:
		PostShadePixel4_WriteOutput<0x7>(x4, y4, pixelShader);
		return;
	case 0x9:
		PostShadePixel4_WriteOutput<0x9>(x4, y4, pixelShader);
		return;
	case 0xA:
		PostShadePixel4_WriteOutput<0xA>(x4, y4, pixelShader);
		return;
	case 0xB:
		PostShadePixel4_WriteOutput<0xB>(x4, y4, pixelShader);
		return;
	case 0xC:
		PostShadePixel4_WriteOutput<0xC>(x4, y4, pixelShader);
		return;
	case 0xD:
		PostShadePixel4_WriteOutput<0xD>(x4, y4, pixelShader);
		return;
	case 0xE:
		PostShadePixel4_WriteOutput<0xE>(x4, y4, pixelShader);
		return;
	case 0xF:
		PostShadePixel4_WriteOutput<0xF>(x4, y4, pixelShader);
		return;
	}
}

template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::PostShadePixel4_WriteOutput(const __m128i x4, const __m128i y4, PShaderEngine* const pixelShader) const
{	
	PostShadePixel4_WriteOutputColor<pixelWriteMask>(x4, y4, pixelShader);

	if (currentState.currentDepthStencil)
	{
		if (currentState.currentRenderStates.renderStatesUnion.namedStates.zWriteEnable)
		{
			PostShadePixel4_WriteOutputDepth<pixelWriteMask>(x4, y4, pixelShader);
		}
			
		if (currentState.currentRenderStates.renderStatesUnion.namedStates.stencilEnable)
		{
			PostShadePixel4_WriteOutputStencil<pixelWriteMask>(x4, y4);
		}
	}
}

void IDirect3DDevice9Hook::PostShadePixel4_Discard(const unsigned char pixelDiscardMask) const
{
	switch (pixelDiscardMask)
	{
	default:
	case 0x0:
		return;
	case 0x1:
	case 0x2:
	case 0x4:
	case 0x8:
		++frameStats.numPixelsTexkilled;
		return;
	case 0x3:
	case 0x5:
	case 0x6:
	case 0x9:
	case 0xA:
	case 0xC:
		frameStats.numPixelsTexkilled += 2;
		return;
	case 0x7:
	case 0xB:
	case 0xD:
	case 0xE:
		frameStats.numPixelsTexkilled += 3;
		return;
	case 0xF:
		frameStats.numPixelsTexkilled += 4;
		return;
	}
}

void IDirect3DDevice9Hook::PostShadePixel4_FailAlphaTest(const unsigned char pixelsFailAlphaTestMask) const
{
	switch (pixelsFailAlphaTestMask)
	{
	default:
	case 0x0:
		return;
	case 0x1:
	case 0x2:
	case 0x4:
	case 0x8:
		++frameStats.numAlphaTestFailPixels;
		return;
	case 0x3:
	case 0x5:
	case 0x6:
	case 0x9:
	case 0xA:
	case 0xC:
		frameStats.numAlphaTestFailPixels += 2;
		return;
	case 0x7:
	case 0xB:
	case 0xD:
	case 0xE:
		frameStats.numAlphaTestFailPixels += 3;
		return;
	case 0xF:
		frameStats.numAlphaTestFailPixels += 4;
		return;
	}
}

template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::PostShadePixel4_WriteOutputColor(const __m128i x4, const __m128i y4, const PShaderEngine* const pixelShader) const
{
	switch (pixelWriteMask)
	{
	default:
	case 0x0:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
		return;
	case 0x1:
		PostShadePixel_WriteOutputColor(x4.m128i_u32[0], y4.m128i_u32[0], pixelShader->outputRegisters[0]);
		return;
	case 0x2:
		PostShadePixel_WriteOutputColor(x4.m128i_u32[1], y4.m128i_u32[1], pixelShader->outputRegisters[1]);
		return;
	case 0x4:
		PostShadePixel_WriteOutputColor(x4.m128i_u32[2], y4.m128i_u32[2], pixelShader->outputRegisters[2]);
		return;
	case 0x8:
		PostShadePixel_WriteOutputColor(x4.m128i_u32[3], y4.m128i_u32[3], pixelShader->outputRegisters[3]);
		return;
	case 0x3:
	case 0x5:
	case 0x6:
	case 0x7:
	case 0x9:
	case 0xA:
	case 0xB:
	case 0xC:
	case 0xD:
	case 0xE:
	case 0xF:
		break;
	}

	for (unsigned char rt = 0; rt < D3D_MAX_SIMULTANEOUS_RENDERTARGETS; ++rt)
	{
		IDirect3DSurface9Hook* const currentRenderTarget = currentState.currentRenderTargets[rt];
		if (!currentRenderTarget)
			continue;

		RenderOutput4<pixelWriteMask>(currentRenderTarget, x4, y4, pixelShader->outputRegisters, rt);
	}
}

template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::PostShadePixel4_WriteOutputDepth(const __m128i x4, const __m128i y4, const PShaderEngine* const pixelShader) const
{
	switch (pixelWriteMask)
	{
	default:
	case 0x0:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
		return;
	case 0x1:
		PostShadePixel_WriteOutputDepth(x4.m128i_u32[0], y4.m128i_u32[0], pixelShader->outputRegisters[0].oDepth);
		return;
	case 0x2:
		PostShadePixel_WriteOutputDepth(x4.m128i_u32[1], y4.m128i_u32[1], pixelShader->outputRegisters[1].oDepth);
		return;
	case 0x4:
		PostShadePixel_WriteOutputDepth(x4.m128i_u32[2], y4.m128i_u32[2], pixelShader->outputRegisters[2].oDepth);
		return;
	case 0x8:
		PostShadePixel_WriteOutputDepth(x4.m128i_u32[3], y4.m128i_u32[3], pixelShader->outputRegisters[3].oDepth);
		return;
	case 0x3:
	case 0x5:
	case 0x6:
	case 0x7:
	case 0x9:
	case 0xA:
	case 0xB:
	case 0xC:
	case 0xD:
	case 0xE:
	case 0xF:
		break;
	}

	__m128 depth4;
	if (pixelWriteMask & 0x1)
		depth4.m128_f32[0] = pixelShader->outputRegisters[0].oDepth;
	if (pixelWriteMask & 0x2)
		depth4.m128_f32[1] = pixelShader->outputRegisters[1].oDepth;
	if (pixelWriteMask & 0x4)
		depth4.m128_f32[2] = pixelShader->outputRegisters[2].oDepth;
	if (pixelWriteMask & 0x8)
		depth4.m128_f32[3] = pixelShader->outputRegisters[3].oDepth;
	depth4 = _mm_add_ps(depth4, currentState.currentRenderStates.depthBiasSplatted);
	currentState.currentDepthStencil->SetDepth4<pixelWriteMask>(x4, y4, depth4);
}

template <const unsigned char pixelWriteMask>
void IDirect3DDevice9Hook::PostShadePixel4_WriteOutputStencil(const __m128i x4, const __m128i y4) const
{
	if (pixelWriteMask == 0x0)
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return;
	}
	switch (pixelWriteMask)
	{
	default:
	case 0x0:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
		return;
	case 0x1:
		PostShadePixel_WriteOutputStencil(x4.m128i_u32[0], y4.m128i_u32[0]);
		return;
	case 0x2:
		PostShadePixel_WriteOutputStencil(x4.m128i_u32[1], y4.m128i_u32[1]);
		return;
	case 0x4:
		PostShadePixel_WriteOutputStencil(x4.m128i_u32[2], y4.m128i_u32[2]);
		return;
	case 0x8:
		PostShadePixel_WriteOutputStencil(x4.m128i_u32[3], y4.m128i_u32[3]);
		return;
	case 0x3:
	case 0x5:
	case 0x6:
	case 0x7:
	case 0x9:
	case 0xA:
	case 0xB:
	case 0xC:
	case 0xD:
	case 0xE:
	case 0xF:
		break;
	}

	// TODO: Need to write a StencilOperation4 to replace this
	for (unsigned z = 0; z < 4; ++z)
	{
		if (pixelWriteMask & (1 << z) )
			PostShadePixel_WriteOutputStencil(x4.m128i_u32[z], y4.m128i_u32[z]);
	}
}

void IDirect3DDevice9Hook::StencilOperation(const unsigned x, const unsigned y, const D3DSTENCILOP stencilOp) const
{
	const DWORD stencilWriteMask = currentState.currentRenderStates.renderStatesUnion.namedStates.stencilWriteMask;
	switch (stencilOp)
	{
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid D3DSTENCILOP specified for stenciling");
#endif
	case D3DSTENCILOP_KEEP   :
		return;
	case D3DSTENCILOP_ZERO   :
		currentState.currentDepthStencil->SetStencil(x, y, 0);
		break;
	case D3DSTENCILOP_REPLACE:
		currentState.currentDepthStencil->SetStencil(x, y, currentState.currentRenderStates.renderStatesUnion.namedStates.stencilRef & stencilWriteMask);
		break;
	case D3DSTENCILOP_INCRSAT:
	{
		DWORD currentStencil = currentState.currentDepthStencil->GetStencil(x, y);
		++currentStencil;
		const DWORD formatMask = GetStencilFormatMask(currentState.currentDepthStencil->GetInternalFormat() );
		if (currentStencil > formatMask)
			currentStencil = formatMask;
		currentState.currentDepthStencil->SetStencil(x, y, currentStencil & stencilWriteMask);
	}
		break;
	case D3DSTENCILOP_DECRSAT:
	{
		DWORD currentStencil = currentState.currentDepthStencil->GetStencil(x, y);
		if (currentStencil > 0)
			--currentStencil;
		currentState.currentDepthStencil->SetStencil(x, y, currentStencil & stencilWriteMask);
	}
		break;
	case D3DSTENCILOP_INVERT :
	{
		DWORD currentStencil = currentState.currentDepthStencil->GetStencil(x, y);
		currentStencil = ~currentStencil;
		currentState.currentDepthStencil->SetStencil(x, y, currentStencil & stencilWriteMask);
	}
		break;
	case D3DSTENCILOP_INCR   :
	{
		DWORD currentStencil = currentState.currentDepthStencil->GetStencil(x, y);
		++currentStencil;
		currentState.currentDepthStencil->SetStencil(x, y, currentStencil & stencilWriteMask);
	}
		break;
	case D3DSTENCILOP_DECR   :
	{
		DWORD currentStencil = currentState.currentDepthStencil->GetStencil(x, y);
		--currentStencil;
		currentState.currentDepthStencil->SetStencil(x, y, currentStencil & stencilWriteMask);
	}
		break;
	}
}

void IDirect3DDevice9Hook::StencilFailOperation(const unsigned x, const unsigned y) const
{
	StencilOperation(x, y, currentState.currentRenderStates.renderStatesUnion.namedStates.stencilFail);
}

void IDirect3DDevice9Hook::StencilZFailOperation(const unsigned x, const unsigned y) const
{
	StencilOperation(x, y, currentState.currentRenderStates.renderStatesUnion.namedStates.stencilZFail);
}

void IDirect3DDevice9Hook::StencilPassOperation(const unsigned x, const unsigned y) const
{
	StencilOperation(x, y, currentState.currentRenderStates.renderStatesUnion.namedStates.stencilPass);
}

/*void IDirect3DDevice9Hook::StencilFailOperation4(const __m128i x4, const __m128i y4) const
{
	StencilOperation4(x4, y4, currentState.currentRenderStates.renderStatesUnion.namedStates.stencilFail);
}

void IDirect3DDevice9Hook::StencilZFailOperation4(const __m128i x4, const __m128i y4) const
{
	StencilOperation4(x4, y4, currentState.currentRenderStates.renderStatesUnion.namedStates.stencilZFail);
}

void IDirect3DDevice9Hook::StencilPassOperation4(const __m128i x4, const __m128i y4) const
{
	StencilOperation4(x4, y4, currentState.currentRenderStates.renderStatesUnion.namedStates.stencilPass);
}*/

// true = "pass" (draw the pixel), false = "fail" (discard the pixel for all render targets and also discard depth/stencil writes for this pixel)
// This MSDN page says that alpha testing only happens against the alpha value from oC0: https://docs.microsoft.com/en-us/windows/desktop/direct3d9/multiple-render-targets
const bool IDirect3DDevice9Hook::AlphaTest(const D3DXVECTOR4& outColor) const
{
	// Alpha testing:
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.alphaTestEnable)
	{
		switch (currentState.currentRenderStates.renderStatesUnion.namedStates.alphaFunc)
		{
		case D3DCMP_NEVER       :
			return false;
		case D3DCMP_LESS        :
		{
			if (!(outColor.w < currentState.currentRenderStates.cachedAlphaRefFloat) )
				return false;
		}
			break;
		case D3DCMP_EQUAL       :
		{
			if (!(outColor.w == currentState.currentRenderStates.cachedAlphaRefFloat) )
				return false;
		}
			break;
		case D3DCMP_LESSEQUAL   :
		{
			if (!(outColor.w <= currentState.currentRenderStates.cachedAlphaRefFloat) )
				return false;
		}
			break;
		case D3DCMP_GREATER     :
		{
			if (!(outColor.w > currentState.currentRenderStates.cachedAlphaRefFloat) )
				return false;
		}
			break;
		case D3DCMP_NOTEQUAL    :
		{
			if (!(outColor.w != currentState.currentRenderStates.cachedAlphaRefFloat) )
				return false;
		}
			break;
		case D3DCMP_GREATEREQUAL:
		{
			if (!(outColor.w >= currentState.currentRenderStates.cachedAlphaRefFloat) )
				return false;
		}
			break;
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Invalid D3DCMP function passed to Alpha Test");
#else
			__assume(0);
#endif
		case D3DCMP_ALWAYS      :
			return true;
		}
	}

	return true;
}

// Returns a SSE vector mask (0xFF for "test pass" and 0x00 for "test fail")
template <const unsigned char pixelWriteMask>
const __m128 IDirect3DDevice9Hook::AlphaTest4(const PS_2_0_OutputRegisters (&outColor4)[4]) const
{
	// Alpha testing:
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.alphaTestEnable)
	{
		switch (currentState.currentRenderStates.renderStatesUnion.namedStates.alphaFunc)
		{
		case D3DCMP_NEVER       :
			return *(const __m128* const)&zeroMaskVec;
		case D3DCMP_LESS        :
		{
			__m128 alphaVec;
			if (pixelWriteMask & 0x1) alphaVec.m128_f32[0] = outColor4[0].oC[0].w;
			if (pixelWriteMask & 0x2) alphaVec.m128_f32[1] = outColor4[1].oC[0].w;
			if (pixelWriteMask & 0x4) alphaVec.m128_f32[2] = outColor4[2].oC[0].w;
			if (pixelWriteMask & 0x8) alphaVec.m128_f32[3] = outColor4[3].oC[0].w;
			return _mm_cmplt_ps(alphaVec, currentState.currentRenderStates.alphaRefSplatted);
		}
		case D3DCMP_EQUAL       :
		{
			__m128 alphaVec;
			if (pixelWriteMask & 0x1) alphaVec.m128_f32[0] = outColor4[0].oC[0].w;
			if (pixelWriteMask & 0x2) alphaVec.m128_f32[1] = outColor4[1].oC[0].w;
			if (pixelWriteMask & 0x4) alphaVec.m128_f32[2] = outColor4[2].oC[0].w;
			if (pixelWriteMask & 0x8) alphaVec.m128_f32[3] = outColor4[3].oC[0].w;
			return _mm_cmpeq_ps(alphaVec, currentState.currentRenderStates.alphaRefSplatted);
		}
		case D3DCMP_LESSEQUAL   :
		{
			__m128 alphaVec;
			if (pixelWriteMask & 0x1) alphaVec.m128_f32[0] = outColor4[0].oC[0].w;
			if (pixelWriteMask & 0x2) alphaVec.m128_f32[1] = outColor4[1].oC[0].w;
			if (pixelWriteMask & 0x4) alphaVec.m128_f32[2] = outColor4[2].oC[0].w;
			if (pixelWriteMask & 0x8) alphaVec.m128_f32[3] = outColor4[3].oC[0].w;
			return _mm_cmple_ps(alphaVec, currentState.currentRenderStates.alphaRefSplatted);
		}
		case D3DCMP_GREATER     :
		{
			__m128 alphaVec;
			if (pixelWriteMask & 0x1) alphaVec.m128_f32[0] = outColor4[0].oC[0].w;
			if (pixelWriteMask & 0x2) alphaVec.m128_f32[1] = outColor4[1].oC[0].w;
			if (pixelWriteMask & 0x4) alphaVec.m128_f32[2] = outColor4[2].oC[0].w;
			if (pixelWriteMask & 0x8) alphaVec.m128_f32[3] = outColor4[3].oC[0].w;
			return _mm_cmpgt_ps(alphaVec, currentState.currentRenderStates.alphaRefSplatted);
		}
		case D3DCMP_NOTEQUAL    :
		{
			__m128 alphaVec;
			if (pixelWriteMask & 0x1) alphaVec.m128_f32[0] = outColor4[0].oC[0].w;
			if (pixelWriteMask & 0x2) alphaVec.m128_f32[1] = outColor4[1].oC[0].w;
			if (pixelWriteMask & 0x4) alphaVec.m128_f32[2] = outColor4[2].oC[0].w;
			if (pixelWriteMask & 0x8) alphaVec.m128_f32[3] = outColor4[3].oC[0].w;
			return _mm_cmpneq_ps(alphaVec, currentState.currentRenderStates.alphaRefSplatted);
		}
		case D3DCMP_GREATEREQUAL:
		{
			__m128 alphaVec;
			if (pixelWriteMask & 0x1) alphaVec.m128_f32[0] = outColor4[0].oC[0].w;
			if (pixelWriteMask & 0x2) alphaVec.m128_f32[1] = outColor4[1].oC[0].w;
			if (pixelWriteMask & 0x4) alphaVec.m128_f32[2] = outColor4[2].oC[0].w;
			if (pixelWriteMask & 0x8) alphaVec.m128_f32[3] = outColor4[3].oC[0].w;
			return _mm_cmpge_ps(alphaVec, currentState.currentRenderStates.alphaRefSplatted);
		}
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Invalid D3DCMP function passed to Alpha Test");
#else
			__assume(0);
#endif
		case D3DCMP_ALWAYS      :
			break;
		}
	}

	return *(const __m128* const)&oneMaskVec;
}

// true = "pass" (draw the pixel), false = "fail" (discard the pixel)
const bool IDirect3DDevice9Hook::StencilTestNoWrite(const unsigned x, const unsigned y) const
{
	if (!currentState.currentRenderStates.renderStatesUnion.namedStates.stencilEnable)
		return true;

	const DWORD rawDestStencilVal = currentState.currentDepthStencil->GetStencil(x, y);
	const DWORD maskedDestStencilVal = currentState.currentRenderStates.renderStatesUnion.namedStates.stencilMask & rawDestStencilVal;

	const DWORD referenceStencilVal = currentState.currentRenderStates.renderStatesUnion.namedStates.stencilRef;
	const DWORD maskedRefStencilVal = currentState.currentRenderStates.renderStatesUnion.namedStates.stencilMask & referenceStencilVal;

	switch (currentState.currentRenderStates.renderStatesUnion.namedStates.stencilFunc)
	{
	case D3DCMP_NEVER       :
		return false;
	case D3DCMP_LESS        :
		return maskedRefStencilVal < maskedDestStencilVal;
	case D3DCMP_EQUAL       :
		return maskedRefStencilVal == maskedDestStencilVal;
	case D3DCMP_LESSEQUAL   :
		return maskedRefStencilVal <= maskedDestStencilVal;
	case D3DCMP_GREATER     :
		return maskedRefStencilVal > maskedDestStencilVal;
	case D3DCMP_NOTEQUAL    :
		return maskedRefStencilVal != maskedDestStencilVal;
	case D3DCMP_GREATEREQUAL:
		return maskedRefStencilVal >= maskedDestStencilVal;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid D3DCMP function passed to stencil test");
#endif
	case D3DCMP_ALWAYS      :
		return true;
	}
}

static inline const bool isTopLeftEdge(const int2& v0, const int2& v1)
{
	const int dx = v1.x - v0.x;
	const int dy = v1.y - v0.y;
	return ( (dy < 0) || ( (dy == 0) && (dx < 0) ) );
}

// Assumes pre-transformed vertices from a vertex declaration + raw vertex stream
void IDirect3DDevice9Hook::RasterizeLineFromStream(const DeclarationSemanticMapping& vertexDeclMapping, CONST BYTE* const v0, CONST BYTE* const v1) const
{
#ifdef ENABLE_END_TO_SKIP_DRAWS
	if (IsHoldingEndToSkipDrawCalls() )
	{
		// Skip rendering if END is held down
		return;
	}
#endif

	// Do nothing, line rasterization is not yet implemented
	UNREFERENCED_PARAMETER(v0);
	UNREFERENCED_PARAMETER(v1);
	UNREFERENCED_PARAMETER(vertexDeclMapping);
}

// Assumes pre-transformed vertex from a vertex declaration + raw vertex stream
void IDirect3DDevice9Hook::RasterizePointFromStream(const DeclarationSemanticMapping& vertexDeclMapping, CONST BYTE* const v0) const
{
#ifdef ENABLE_END_TO_SKIP_DRAWS
	if (IsHoldingEndToSkipDrawCalls() )
	{
		// Skip rendering if END is held down
		return;
	}
#endif

	// Do nothing, point rasterization is not yet implemented
	UNREFERENCED_PARAMETER(v0);
	UNREFERENCED_PARAMETER(vertexDeclMapping);
}

// Assumes pre-transformed vertices from a processed vertex shader
void IDirect3DDevice9Hook::RasterizeLineFromShader(const VStoPSMapping& vs_psMapping, const VS_2_0_OutputRegisters& v0, const VS_2_0_OutputRegisters& v1) const
{
#ifdef ENABLE_END_TO_SKIP_DRAWS
	if (IsHoldingEndToSkipDrawCalls() )
	{
		// Skip rendering if END is held down
		return;
	}
#endif

	// Do nothing, line rasterization is not yet implemented
	UNREFERENCED_PARAMETER(v0);
	UNREFERENCED_PARAMETER(v1);
	UNREFERENCED_PARAMETER(vs_psMapping);
}

// Assumes pre-transformed vertex from a processed vertex shader
void IDirect3DDevice9Hook::RasterizePointFromShader(const VStoPSMapping& vs_psMapping, const VS_2_0_OutputRegisters& v0) const
{
#ifdef ENABLE_END_TO_SKIP_DRAWS
	if (IsHoldingEndToSkipDrawCalls() )
	{
		// Skip rendering if END is held down
		return;
	}
#endif

	// Do nothing, point rasterization is not yet implemented
	UNREFERENCED_PARAMETER(v0);
	UNREFERENCED_PARAMETER(vs_psMapping);
}

template <const unsigned char integerBits, const unsigned char fractionBits, typename baseType = unsigned>
union TFixed
{
	struct _splitFormat
	{
		baseType fracPart : fractionBits;
		baseType intPart : integerBits;
	} splitFormat;

	baseType whole;

	TFixed<integerBits, fractionBits, baseType> operator+(const TFixed<integerBits, fractionBits, baseType>& other) const
	{
		TFixed<integerBits, fractionBits, baseType> ret;
		ret.whole = whole + other.whole;
		return ret;
	}

	TFixed<integerBits, fractionBits, baseType> operator-(const TFixed<integerBits, fractionBits, baseType>& other) const
	{
		TFixed<integerBits, fractionBits, baseType> ret;
		ret.whole = whole - other.whole;
		return ret;
	}

	TFixed<integerBits, fractionBits, baseType> operator*(const TFixed<integerBits, fractionBits, baseType>& other) const
	{
		TFixed<integerBits, fractionBits, baseType> ret;
		unsigned __int64 longWhole = whole;
		unsigned __int64 longOtherWhole = other.whole;
		unsigned __int64 longProduct = longWhole * longOtherWhole;
		unsigned __int64 deshiftedProduct = longProduct >> fractionBits;
		ret.whole = (const baseType)deshiftedProduct;
		return ret;
	}

	const bool operator==(const TFixed<integerBits, fractionBits, baseType>& other) const
	{
		return other.whole == whole;
	}
};

template <const unsigned char integerBits, const unsigned char fractionBits, typename baseType>
static const float ConvertFixedToFloat(TFixed<integerBits, fractionBits, baseType> fixed)
{
	float conv = 0.0f;

	baseType fracStorage = fixed.splitFormat.fracPart;
	for (unsigned x = 1; x < fractionBits; ++x)
	{
		if (fracStorage & (1 << (fractionBits - x) ) )
		{
			conv += (1.0f / (1 << x) );
		}
	}

	float intConv = (const float)(fixed.splitFormat.intPart);

	if (fixed.splitFormat.intPart & (1 << (integerBits - 1) ) )
	{
		// Negative number
		return ( (signed short)(fixed.splitFormat.intPart) + conv);
	}
	else
	{
		// Positive number
		return intConv + conv;
	}
}

template <const unsigned char integerBits, const unsigned char fractionBits, typename baseType>
static TFixed<integerBits, fractionBits, baseType> ConvertFloatToFixed(const float inFloat)
{
	const unsigned intPart = (const unsigned)inFloat;
	float fracPart = inFloat - intPart;

	TFixed<integerBits, fractionBits, baseType> ret;
	ret.whole = 0;

	ret.splitFormat.intPart = intPart;
	for (unsigned x = 0; x < fractionBits; ++x)
	{
		const float thisTestBit = 1.0f / (1 << (x + 1) );
		if (fracPart > thisTestBit)
		{
			ret.splitFormat.fracPart |= (1 << (fractionBits - (x + 1) ) );
			fracPart -= thisTestBit;
		}
	}

	return ret;
}

void NormalizeToRecipRange(const TFixed<16, 16> input, TFixed<16, 16>& outNormalizedFixed, int& normalizeFactor)
{
	if (input.splitFormat.intPart != 0)
	{
		unsigned long firstBitIndex = 0; // Starts at the LSB.
		_BitScanReverse(&firstBitIndex, input.splitFormat.intPart);
		normalizeFactor = firstBitIndex + 1;
		outNormalizedFixed.whole = input.whole >> normalizeFactor;
	}
	else if (input.whole == 0)
	{
		outNormalizedFixed.whole = -1;
		normalizeFactor = 0;
	}
	else
	{
		unsigned long firstBitIndex = 0; // Starts at the LSB, even though it scans backwards.
		_BitScanReverse(&firstBitIndex, input.splitFormat.fracPart);
		normalizeFactor = -(int)(16 - firstBitIndex - 1);
		outNormalizedFixed.whole = input.whole << -normalizeFactor;
	}
}

void UnNormalizeToRecipRange(const TFixed<16, 16> normalizedInput, TFixed<16, 16>& outRenormalized, const int normalizeFactor)
{
	if (normalizeFactor > 0)
	{
		outRenormalized.whole = normalizedInput.whole >> normalizeFactor;
	}
	else if (normalizeFactor == 0)
	{
		outRenormalized = normalizedInput;
	}
	else
	{
		outRenormalized.whole = normalizedInput.whole << -normalizeFactor;
	}
}

float FloatReciprocal(float input)
{
	const float approx0result = (48.0f / 17.0f) - (input * (32.0f / 17.0f) );
	float lastIterResult = approx0result;
	float currentIterResult;
	for (unsigned iters = 0; iters < 2; ++iters)
	{
		currentIterResult = lastIterResult * (2.0f - input * lastIterResult);
		lastIterResult = currentIterResult;
	}
	return currentIterResult;
}

static inline void TestSetMinMax(const TFixed<16, 16, unsigned>& inTestVal, signed short& minSet, signed short& maxSet)
{
	const signed short val = (signed short)(inTestVal.splitFormat.intPart);
	if (val < minSet)
		minSet = val;
	if (val > maxSet)
		maxSet = val;
}

// Newton-Raphson iteration using Q16.16 fixed-point numbers, with some help from this resource: http://www.cs.utsa.edu/~wagner/CS3343/newton/division.html
TFixed<16, 16> FixedReciprocal(TFixed<16, 16> input) // +0.xxxxxxxxdec = +0.xxxxhex, Q0.16 unsigned. Value between (0.5, 1.0)
{
	// Initial approximation is 48/17 - 32/17 * input
	TFixed<16, 16> approx0mul = ConvertFloatToFixed<16, 16, unsigned>(32.0f / 17.0f); // +1.8823529411764705882352941176471dec = +1.e1e1hex, Q1.16 unsigned

	TFixed<16, 16> approx0add = ConvertFloatToFixed<16, 16, unsigned>(48.0f / 17.0f); // +2.8235294117647058823529411764706dec = +2.d2d2hex, Q2.16 unsigned

	TFixed<16, 16> approx0mulresult = (input * approx0mul); // Q0.16 * Q1.16 = Q1.16 unsigned, value range between (0.941176 and 1.882353)

	TFixed<16, 16> approx0result = approx0add - approx0mulresult; // Q2.16 - Q1.16 = Q1.16, value range between (0.941176 and 1.882353 again)

	TFixed<16, 16> lastIterResult = approx0result;
	TFixed<16, 16> currentIterResult;

	// Each iteration computes: currentIterResult = lastIterResult * (2.0f - (input * lastIterResult) )
	// 5 iterations here is experimentally derived as being the maximum number of iterations before the result stabilizes
	for (unsigned iters = 0; iters < 5; ++iters)
	{
		TFixed<16, 16> intermedMul = input * lastIterResult; // Q0.16 * Q1.16 = Q1.16, value range for first iteration between (0.470588 and 1.882353)

		TFixed<16, 16, unsigned> fixedTwo = ConvertFloatToFixed<16, 16, unsigned>(2.0f); // Q2.16 unsigned (technically could be 2.0)
		TFixed<16, 16> intermedSubtract = fixedTwo - intermedMul; // Q2.16 - Q1.16 = Q1.16, value range for first iteration between (0.117647 and 1.529411)

		currentIterResult = lastIterResult * intermedSubtract; // Q1.16 * Q1.16 = Q1.16, value range for first iteration between (0.110727 and 2.878891) (don't worry this never actually goes over 1.9 in practice so it'll fit into a Q1.16)

		lastIterResult = currentIterResult;
	}

	return currentIterResult;
}

static inline const float BarycentricInverse(const int twiceTriangleArea)
{
	// Float version:
	//return 1.0f / twiceTriangleArea;

	// Fixed-point version:
	TFixed<16, 16> input = ConvertFloatToFixed<16, 16, unsigned>( (const float)twiceTriangleArea);
	TFixed<16, 16> normalizedInput;
	int normalizeFactor = 0;
	NormalizeToRecipRange(input, normalizedInput, normalizeFactor);
	TFixed<16, 16> recip = FixedReciprocal(normalizedInput);
	TFixed<16, 16, unsigned> output;
	UnNormalizeToRecipRange(recip, output, normalizeFactor);
	return ConvertFixedToFloat(output);
}

template <const bool rasterizerUsesEarlyZTest, const bool shadeFromShader>
void IDirect3DDevice9Hook::RasterizeTriangle(PShaderEngine* const pShaderEngine, const void* const mappingData, const void* const v0, const void* const v1, const void* const v2,
	const float fWidth, const float fHeight, const UINT primitiveID, const UINT vertex0index, const UINT vertex1index, const UINT vertex2index) const
{
	SIMPLE_FUNC_SCOPE();
	const D3DXVECTOR4& pos0 = shadeFromShader ? currentState.currentVertexShader->GetPosition(*(const VS_2_0_OutputRegisters* const)v0) : *(const D3DXVECTOR4* const)v0;
	const D3DXVECTOR4& pos1 = shadeFromShader ? currentState.currentVertexShader->GetPosition(*(const VS_2_0_OutputRegisters* const)v1) : *(const D3DXVECTOR4* const)v1;
	const D3DXVECTOR4& pos2 = shadeFromShader ? currentState.currentVertexShader->GetPosition(*(const VS_2_0_OutputRegisters* const)v2) : *(const D3DXVECTOR4* const)v2;

	const __m128 pos0vec = *(const __m128* const)&pos0;
	const __m128 pos1vec = *(const __m128* const)&pos1;
	const __m128 pos2vec = *(const __m128* const)&pos2;

	// If any of the coords of our triangle's output vertex positions are NaN, then we *must* discard the entire triangle as per the D3D spec:
	if (isnan(pos0vec.m128_f32[0]) || isnan(pos0vec.m128_f32[1]) || isnan(pos0vec.m128_f32[2]) || isnan(pos0vec.m128_f32[3]) ||
		isnan(pos1vec.m128_f32[0]) || isnan(pos1vec.m128_f32[1]) || isnan(pos1vec.m128_f32[2]) || isnan(pos1vec.m128_f32[3]) ||
		isnan(pos2vec.m128_f32[0]) || isnan(pos2vec.m128_f32[1]) || isnan(pos2vec.m128_f32[2]) || isnan(pos2vec.m128_f32[3]) )
		return;

	// If any of the coords of our triangle's output vertex positions are INF, then we *may* optionally discard the entire triangle as per the D3D spec:
	if (isinf(pos0vec.m128_f32[0]) || isinf(pos0vec.m128_f32[1]) || isinf(pos0vec.m128_f32[2]) || isinf(pos0vec.m128_f32[3]) ||
		isinf(pos1vec.m128_f32[0]) || isinf(pos1vec.m128_f32[1]) || isinf(pos1vec.m128_f32[2]) || isinf(pos1vec.m128_f32[3]) ||
		isinf(pos2vec.m128_f32[0]) || isinf(pos2vec.m128_f32[1]) || isinf(pos2vec.m128_f32[2]) || isinf(pos2vec.m128_f32[3]) )
		return;

	// Near plane culling:
	// TODO: Replace with real triangle clipping!
	const __m128 zCullVec = { pos0vec.m128_f32[2], pos1vec.m128_f32[2], pos2vec.m128_f32[2], 0.0f };
	// if (posN.z < 0.0f || posN.z > 1.0f) return;
	if (_mm_movemask_ps(_mm_or_ps(_mm_cmplt_ps(zCullVec, *(const __m128* const)&zeroVec), _mm_cmpgt_ps(zCullVec, *(const __m128* const)&staticColorWhiteOpaque) ) ) & 0x7)
		return;

	// Compute screenspace bounds for this triangle:
	__m128 topleft = _mm_min_ps(_mm_min_ps(pos0vec, pos1vec), pos2vec);
	__m128 botright = _mm_max_ps(_mm_max_ps(pos0vec, pos1vec), pos2vec);

	__m128 bounds = _mm_shuffle_ps(topleft, botright, _MM_SHUFFLE(1, 0, 1, 0) );

	// Cull triangles that intersect the guard band:
	// TODO: Replace with real triangle clipping!
	//if (_mm_movemask_ps(_mm_or_ps(_mm_cmplt_ps(bounds, guardBandMin), _mm_cmpgt_ps(bounds, guardBandMax) ) ) )
		//return;

	// Clip screenspace bounds to the screen size:
	topleft = _mm_max_ps(topleft, *(const __m128* const)&zeroVec);
	botright = _mm_min_ps(botright, _mm_set_ps(0.0f, 0.0f, fHeight, fWidth) );

	// Clip to the scissor rect, if enabled
	if (currentState.currentRenderStates.renderStatesUnion.namedStates.scissorTestEnable)
	{
		topleft = _mm_max_ps(topleft, currentState.currentScissorRect.topleftF);
		botright = _mm_min_ps(botright, currentState.currentScissorRect.botrightF);
	}

	// Clip to the depth buffer extents, if Z-testing is enabled
	const IDirect3DSurface9Hook* depthStencil;
	if (rasterizerUsesEarlyZTest)
	{
		depthStencil = currentState.currentDepthStencil;

		const __m128 depthExtents = depthStencil->GetInternalWidthHeightM2F();
		topleft = _mm_min_ps(topleft, depthExtents);
		botright = _mm_min_ps(botright, depthExtents);
	}

	bounds = _mm_shuffle_ps(topleft, botright, _MM_SHUFFLE(1, 0, 1, 0) );
	if (SUBPIXEL_ACCURACY_BIASMULT != 1)
		bounds = _mm_mul_ps(bounds, SUBPIXEL_ACCURACY_BIASMULT_SPLATTEDF);

	const __m128i intBounds = _mm_cvtps_epi32(bounds);

	// Align our triangle rasterization such that our quads line up with the render-target and depth-buffer's swizzles
	const __m128i intBoundsQuadAligned = _mm_and_si128(intBounds, intBoundsQuadAlignVec);
	const int xMin = intBoundsQuadAligned.m128i_i32[0];
	const int yMin = intBoundsQuadAligned.m128i_i32[1];
	const int xMax = intBoundsQuadAligned.m128i_i32[2];
	const int yMax = intBoundsQuadAligned.m128i_i32[3];

	// Early out on zero area triangles
	if (!(yMin <= yMax && xMin < xMax) )
		return;
	
	// Cull zero or negative-area triangles (with our default triangle winding being CW, this will also cull CCW triangles):
	const int maxNumPixels = (yMax - yMin) * (xMax - xMin);
	if (maxNumPixels < 1)
		return;

	const __m128i i0vec = (SUBPIXEL_ACCURACY_BIASMULT != 1) ? _mm_cvtps_epi32(_mm_mul_ps(pos0vec, SUBPIXEL_ACCURACY_BIASMULT_SPLATTEDF) ) : _mm_cvtps_epi32(pos0vec);
	const __m128i i1vec = (SUBPIXEL_ACCURACY_BIASMULT != 1) ? _mm_cvtps_epi32(_mm_mul_ps(pos1vec, SUBPIXEL_ACCURACY_BIASMULT_SPLATTEDF) ) : _mm_cvtps_epi32(pos1vec);
	const __m128i i2vec = (SUBPIXEL_ACCURACY_BIASMULT != 1) ? _mm_cvtps_epi32(_mm_mul_ps(pos2vec, SUBPIXEL_ACCURACY_BIASMULT_SPLATTEDF) ) : _mm_cvtps_epi32(pos2vec);
	int2 i0, i1, i2;
	i0.x = i0vec.m128i_i32[0];
	i0.y = i0vec.m128i_i32[1];
	i1.x = i1vec.m128i_i32[0];
	i1.y = i1vec.m128i_i32[1];
	i2.x = i2vec.m128i_i32[0];
	i2.y = i2vec.m128i_i32[1];

	// Cull backfacing triangles!
	const int twiceTriangleArea = computeEdgeSidedness(i0.x, i0.y, i1.x, i1.y, i2.x, i2.y);
	if (twiceTriangleArea <= 0)
		return;

	const float barycentricNormalizeFactor = 1.0f / twiceTriangleArea; // BarycentricInverse(twiceTriangleArea);
	//printf("TwiceArea: %i; Real: %f; Fixed: %f\n", twiceTriangleArea, 1.0f / twiceTriangleArea, barycentricNormalizeFactor);

	const __m128i y0011 = _mm_castps_si128(_mm_shuffle_ps(_mm_castsi128_ps(i0vec), _mm_castsi128_ps(i1vec), _MM_SHUFFLE(1, 1, 1, 1) ) ); // Shuffles to be: i0.y, i0.y, i1.y, i1.y
	const __m128i y012 = _mm_castps_si128(_mm_shuffle_ps(_mm_castsi128_ps(y0011), _mm_castsi128_ps(i2vec), _MM_SHUFFLE(0, 1, 2, 0) ) ); // Shuffles to be: i0.y, i1.y, i2.y, i2.x
	const __m128i y120 = _mm_shuffle_epi32(y012, _MM_SHUFFLE(0, 0, 2, 1) ); // Shuffles to be: i1.y, i2.y, i0.y, i0.y
	const __m128i barycentricXDelta = _mm_shuffle_epi32(_mm_sub_epi32(y012, y120), _MM_SHUFFLE(0, 0, 2, 1) ); // Shuffles to be barycentricXDelta1, barycentricXDelta2, barycentricXDelta0
	const __m128i barycentricXDelta2 = _mm_slli_epi32(barycentricXDelta, 1); // Times 2

	const __m128i x0011 = _mm_castps_si128(_mm_shuffle_ps(_mm_castsi128_ps(i0vec), _mm_castsi128_ps(i1vec), _MM_SHUFFLE(0, 0, 0, 0) ) ); // Shuffles to be: i0.x, i0.x, i1.x, i1.x
	const __m128i x012 = _mm_castps_si128(_mm_shuffle_ps(_mm_castsi128_ps(x0011), _mm_castsi128_ps(i2vec), _MM_SHUFFLE(0, 0, 2, 0) ) ); // Shuffles to be: i0.x, i1.x, i2.x, i2.x
	const __m128i x120 = _mm_shuffle_epi32(x012, _MM_SHUFFLE(0, 0, 2, 1) ); // Shuffles to be: i1.x, i2.x, i0.x, i0.x
	const __m128i barycentricYDelta = _mm_shuffle_epi32(_mm_sub_epi32(x120, x012), _MM_SHUFFLE(0, 0, 2, 1) ); // Shuffles to be barycentricYDelta1, barycentricYDelta2, barycentricYDelta0
	const __m128i barycentricYDelta2 = _mm_slli_epi32(barycentricYDelta, 1); // Times 2

	// Correct for top-left rule. Source: https://fgiesen.wordpress.com/2013/02/08/triangle-rasterization-in-practice/
	const char topleftEdgeBias0 = isTopLeftEdge(i1, i2) ? 0 : -1;
	const char topleftEdgeBias1 = isTopLeftEdge(i2, i0) ? 0 : -1;
	const char topleftEdgeBias2 = isTopLeftEdge(i0, i1) ? 0 : -1;

	const __m128i topleftEdgeBias = _mm_set_epi32(0, topleftEdgeBias2, topleftEdgeBias1, topleftEdgeBias0);

	const __m128 barycentricNormalizeFactorSplattedF = _mm_set1_ps(barycentricNormalizeFactor);
	__m128i rowReset = _mm_add_epi32(_mm_set_epi32(0, computeEdgeSidedness(i0.x, i0.y, i1.x, i1.y, xMin, yMin), computeEdgeSidedness(i2.x, i2.y, i0.x, i0.y, xMin, yMin), computeEdgeSidedness(i1.x, i1.y, i2.x, i2.y, xMin, yMin) ), topleftEdgeBias);

	__m128i earlyZTestDepthValue4;
	if (rasterizerUsesEarlyZTest)
	{
		// TODO: Don't assume less-than test for Z CMPFUNC
		float minDepthValue = pos0.z < pos1.z ? pos0.z : pos1.z;
		minDepthValue = minDepthValue < pos2.z ? minDepthValue : pos2.z;

		earlyZTestDepthValue4 = _mm_set1_epi32(depthStencil->GetRawDepthValueFromFloatDepth(minDepthValue) );
	}

	const primitivePixelJobData* const primitiveData = GetNewPrimitiveJobData<shadeFromShader>(v0, v1, v2, barycentricNormalizeFactor, primitiveID, twiceTriangleArea > 0, vertex0index, vertex1index, vertex2index,
		pos0vec, pos1vec, pos2vec);
	for (int y = yMin; y <= yMax; y += SUBPIXEL_ACCURACY_BIASMULT2)
	{
		// Reset at the next row:
		__m128i currentBarycentric[4];
		currentBarycentric[0] = rowReset;

		const __m128i y4 = _mm_add_epi32(_mm_set1_epi32(y), y4quadOffset);

		for (int x = xMin; x < xMax; x += SUBPIXEL_ACCURACY_BIASMULT2)
		{
			currentBarycentric[1] = _mm_add_epi32(currentBarycentric[0], barycentricXDelta);
			currentBarycentric[2] = _mm_add_epi32(currentBarycentric[0], barycentricYDelta);
			currentBarycentric[3] = _mm_add_epi32(currentBarycentric[2], barycentricXDelta);

			const __m128i masksVec = _mm_set_epi32(
				_mm_movemask_ps(_mm_castsi128_ps(_mm_cmpgt_epi32(currentBarycentric[3], oneMaskVec) ) ),
				_mm_movemask_ps(_mm_castsi128_ps(_mm_cmpgt_epi32(currentBarycentric[2], oneMaskVec) ) ),
				_mm_movemask_ps(_mm_castsi128_ps(_mm_cmpgt_epi32(currentBarycentric[1], oneMaskVec) ) ),
				_mm_movemask_ps(_mm_castsi128_ps(_mm_cmpgt_epi32(currentBarycentric[0], oneMaskVec) ) ) );

			// At this stage, the mask determines which pixels are inside and which are outside of our triangle
			unsigned unifiedMask4 = _mm_movemask_ps(_mm_castsi128_ps(_mm_cmpeq_epi32(_mm_and_si128(masksVec, sevenVec), sevenVec) ) );
			const __m128i x4 = _mm_add_epi32(_mm_set1_epi32(x), x4quadOffset);
			if (rasterizerUsesEarlyZTest)
			{
				if (unifiedMask4 == 0xF) // All pixels inside triangle
				{
					const __m128i depth4 = depthStencil->GetRawDepth4(x4, y4);

					// TODO: Don't assume less-than test for Z CMPFUNC
					const unsigned depthMask = _mm_movemask_ps(_mm_castsi128_ps(_mm_cmplt_epi32(earlyZTestDepthValue4, depth4) ) );
					unifiedMask4 &= depthMask;
				}
				else if  (unifiedMask4 > 0) // At least one pixel inside triangle
				{
					__m128i depth4;
					if (unifiedMask4 & 0x1)
						depth4.m128i_u32[0] = depthStencil->GetRawDepth(x4.m128i_i32[0], y4.m128i_i32[0]);
					if (unifiedMask4 & 0x2)
						depth4.m128i_u32[1] = depthStencil->GetRawDepth(x4.m128i_i32[1], y4.m128i_i32[1]);
					if (unifiedMask4 & 0x4)
						depth4.m128i_u32[2] = depthStencil->GetRawDepth(x4.m128i_i32[2], y4.m128i_i32[2]);
					if (unifiedMask4 & 0x8)
						depth4.m128i_u32[3] = depthStencil->GetRawDepth(x4.m128i_i32[3], y4.m128i_i32[3]);

					// TODO: Don't assume less-than test for Z CMPFUNC
					const unsigned depthMask = _mm_movemask_ps(_mm_castsi128_ps(_mm_cmplt_epi32(earlyZTestDepthValue4, depth4) ) );
					unifiedMask4 &= depthMask;
				}
			}

			if (unifiedMask4 == 0xF) // All pixels inside triangle and pass early-Z
			{
				const __m128i barycentricsAdjusted4[4] =
				{
					_mm_sub_epi32(currentBarycentric[0], topleftEdgeBias),
					_mm_sub_epi32(currentBarycentric[1], topleftEdgeBias), 
					_mm_sub_epi32(currentBarycentric[2], topleftEdgeBias), 
					_mm_sub_epi32(currentBarycentric[3], topleftEdgeBias)
				};
#ifdef RUN_SHADERS_IN_WARPS
				CreateNewPixelShadeJob4(x4, y4, barycentricsAdjusted4, primitiveData);
#else
				CreateNewPixelShadeJob(x4.m128i_i32[0], y4.m128i_i32[0], barycentricsAdjusted4[0], primitiveData);
				CreateNewPixelShadeJob(x4.m128i_i32[1], y4.m128i_i32[1], barycentricsAdjusted4[1], primitiveData);
				CreateNewPixelShadeJob(x4.m128i_i32[2], y4.m128i_i32[2], barycentricsAdjusted4[2], primitiveData);
				CreateNewPixelShadeJob(x4.m128i_i32[3], y4.m128i_i32[3], barycentricsAdjusted4[3], primitiveData);
#endif
			}
			else if (unifiedMask4 > 0) // At least one pixel inside triangle and pass early-Z
			{
				if (unifiedMask4 & 0x1)
				{
					const __m128i barycentricAdjusted = _mm_sub_epi32(currentBarycentric[0], topleftEdgeBias);
					CreateNewPixelShadeJob(x4.m128i_i32[0], y4.m128i_i32[0], barycentricAdjusted, primitiveData);
				}
				if (unifiedMask4 & 0x2)
				{
					const __m128i barycentricAdjusted = _mm_sub_epi32(currentBarycentric[1], topleftEdgeBias);
					CreateNewPixelShadeJob(x4.m128i_i32[1], y4.m128i_i32[1], barycentricAdjusted, primitiveData);
				}
				if (unifiedMask4 & 0x4)
				{
					const __m128i barycentricAdjusted = _mm_sub_epi32(currentBarycentric[2], topleftEdgeBias);
					CreateNewPixelShadeJob(x4.m128i_i32[2], y4.m128i_i32[2], barycentricAdjusted, primitiveData);
				}
				if (unifiedMask4 & 0x8)
				{
					const __m128i barycentricAdjusted = _mm_sub_epi32(currentBarycentric[3], topleftEdgeBias);
					CreateNewPixelShadeJob(x4.m128i_i32[3], y4.m128i_i32[3], barycentricAdjusted, primitiveData);
				}
			}
			else
			{
				// No pixels inside triangle that passed early-Z, do nothing
			}

			currentBarycentric[0] = _mm_add_epi32(currentBarycentric[0], barycentricXDelta2);
		}

		rowReset = _mm_add_epi32(rowReset, barycentricYDelta2);
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::DrawPrimitiveUP(THIS_ D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void* pVertexStreamZeroData, UINT VertexStreamZeroStride)
{
	SIMPLE_FUNC_SCOPE();

	HRESULT ret;

	if (PrimitiveCount == 0)
		return D3DERR_INVALIDCALL;

	if (!pVertexStreamZeroData)
		return D3DERR_INVALIDCALL;

	if (PrimitiveType > D3DPT_TRIANGLEFAN || PrimitiveType < D3DPT_POINTLIST)
		return D3DERR_INVALIDCALL;

	if (!currentState.currentVertexDecl)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Vertex decl is NULL");
#endif
		return D3DERR_INVALIDCALL;
	}

#ifdef _DEBUG
	if (currentState.currentPixelShader && !currentState.currentPixelShader->jitShaderMain)
	{
		DbgPrint("Warning: Uncached pixel shader detected");
	}
#endif

	if (VertexStreamZeroStride > 0xFFFF)
		return D3DERR_INVALIDCALL;

	if (!TotalDrawCallSkipTest() )
		return S_OK;

	const unsigned numInputVerts = GetNumVertsUsed(PrimitiveType, PrimitiveCount);

	const unsigned short shortVertexStreamZeroStride = (const unsigned short)VertexStreamZeroStride;
	currentState.currentSoftUPStream.vertexBuffer->SoftUPSetInternalPointer( (const BYTE* const)pVertexStreamZeroData, numInputVerts * shortVertexStreamZeroStride);
	currentState.currentSoftUPStream.streamOffset = 0;
	currentState.currentSoftUPStream.streamStride = shortVertexStreamZeroStride;
	currentState.currentSoftUPStream.streamDividerFrequency = 1;

	SwapWithCopy(currentState.currentSoftUPStream, currentState.currentStreams[0]);
	SwapWithCopy(currentState.currentSoftUPStreamEnd, currentState.currentStreamEnds[0]);

	// Recompute after the swap since this function operates on currentState.currentStreamEnds[0] expecting it to already be the currentSoftUPStreamEnd
	RecomputeCachedStreamEndsForUP( (const BYTE* const)pVertexStreamZeroData, numInputVerts, shortVertexStreamZeroStride);

	ret = DrawPrimitive(PrimitiveType, 0, PrimitiveCount);

	// Undo swap after our draw call is completed
	SwapWithCopy(currentState.currentSoftUPStreamEnd, currentState.currentStreamEnds[0]);
	SwapWithCopy(currentState.currentSoftUPStream, currentState.currentStreams[0]);

	currentState.currentSoftUPStream.vertexBuffer->SoftUPResetInternalPointer();
	currentState.currentSoftUPStream.streamStride = 0;

	// Following any IDirect3DDevice9::DrawPrimitiveUP call, the stream 0 settings, referenced by IDirect3DDevice9::GetStreamSource, are set to NULL.
	// Source: https://msdn.microsoft.com/en-us/library/windows/desktop/bb174372(v=vs.85).aspx
	if (currentState.currentStreams[0].vertexBuffer != NULL)
	{
		SetStreamSource(0, NULL, 0, 0);
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::DrawIndexedPrimitiveUP(THIS_ D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertices, UINT PrimitiveCount, CONST void* pIndexData, D3DFORMAT IndexDataFormat, CONST void* pVertexStreamZeroData, UINT VertexStreamZeroStride)
{
	SIMPLE_FUNC_SCOPE();

	HRESULT ret;
#ifdef _DEBUG
	if (currentState.currentPixelShader && !currentState.currentPixelShader->jitShaderMain)
	{
		DbgPrint("Warning: Uncached pixel shader detected");
	}
#endif

	if (PrimitiveCount == 0)
		return D3DERR_INVALIDCALL;

	if (NumVertices == 0)
		return D3DERR_INVALIDCALL;

	if (MinVertexIndex >= NumVertices)
		return D3DERR_INVALIDCALL;

	if (!pIndexData)
		return D3DERR_INVALIDCALL;

	if (IndexDataFormat < D3DFMT_INDEX16 || IndexDataFormat > D3DFMT_INDEX32)
		return D3DERR_INVALIDCALL;

	if (!pVertexStreamZeroData)
		return D3DERR_INVALIDCALL;

	if (PrimitiveType > D3DPT_TRIANGLEFAN || PrimitiveType < D3DPT_POINTLIST)
		return D3DERR_INVALIDCALL;

	if (VertexStreamZeroStride > 0xFFFF)
		return D3DERR_INVALIDCALL;

	if (!TotalDrawCallSkipTest() )
		return S_OK;

	const unsigned short shortVertexStreamZeroStride = (const unsigned short)VertexStreamZeroStride;

	currentState.currentSoftUPStream.vertexBuffer->SoftUPSetInternalPointer( (const BYTE* const)pVertexStreamZeroData, NumVertices * shortVertexStreamZeroStride);
	currentState.currentSoftUPStream.streamOffset = 0;
	currentState.currentSoftUPStream.streamStride = shortVertexStreamZeroStride;
	currentState.currentSoftUPStream.streamDividerFrequency = 1;

	currentState.currentSoftUPIndexBuffer->SoftUPSetInternalPointer(pIndexData, IndexDataFormat, PrimitiveType, PrimitiveCount);

	SwapWithCopy(currentState.currentSoftUPStream, currentState.currentStreams[0]);
	SwapWithCopy(currentState.currentSoftUPStreamEnd, currentState.currentStreamEnds[0]);
	SwapWithCopy(currentState.currentSoftUPIndexBuffer, currentState.currentIndexBuffer);

	// Recompute after the swap since this function operates on currentState.currentStreamEnds[0] expecting it to already be the currentSoftUPStreamEnd
	RecomputeCachedStreamEndsForUP( (const BYTE* const)pVertexStreamZeroData, NumVertices, shortVertexStreamZeroStride);

	ret = DrawIndexedPrimitive(PrimitiveType, 0, MinVertexIndex, NumVertices, 0, PrimitiveCount);

	// Undo swap after our draw call is completed
	SwapWithCopy(currentState.currentSoftUPIndexBuffer, currentState.currentIndexBuffer);
	SwapWithCopy(currentState.currentSoftUPStreamEnd, currentState.currentStreamEnds[0]);
	SwapWithCopy(currentState.currentSoftUPStream, currentState.currentStreams[0]);

	currentState.currentSoftUPStream.vertexBuffer->SoftUPResetInternalPointer();
	currentState.currentSoftUPStream.streamStride = 0;
	currentState.currentSoftUPIndexBuffer->SoftUPResetInternalPointer();

	// Following any IDirect3DDevice9::DrawIndexedPrimitiveUP call, the stream 0 settings, referenced by IDirect3DDevice9::GetStreamSource, are set to NULL.
	// Source: https://msdn.microsoft.com/en-us/library/windows/desktop/bb174370(v=vs.85).aspx
	if (currentState.currentStreams[0].vertexBuffer != NULL)
	{
		SetStreamSource(0, NULL, 0, 0);
	}

	// Also, the index buffer setting for IDirect3DDevice9::SetIndices is set to NULL.
	// Source: https://msdn.microsoft.com/en-us/library/windows/desktop/bb174370(v=vs.85).aspx
	if (currentState.currentIndexBuffer != NULL)
	{
		SetIndices(NULL);
	}

	return ret;
}

const bool IDirect3DDevice9Hook::ShouldCullEntireTriangle(const VS_2_0_OutputRegisters& v0, const VS_2_0_OutputRegisters& v1, const VS_2_0_OutputRegisters& v2)
{
	const unsigned short combinedOutClipCodes = v0.vertexClip.clipCodesCombined & v1.vertexClip.clipCodesCombined & v2.vertexClip.clipCodesCombined;
	return combinedOutClipCodes != 0x0000;
}

const bool IDirect3DDevice9Hook::ShouldCullEntireLine(const VS_2_0_OutputRegisters& v0, const VS_2_0_OutputRegisters& v1)
{
	const unsigned short combinedOutClipCodes = v0.vertexClip.clipCodesCombined & v1.vertexClip.clipCodesCombined;
	return combinedOutClipCodes != 0x0000;
}

const bool IDirect3DDevice9Hook::ShouldCullEntirePoint(const VS_2_0_OutputRegisters& v0)
{
	return v0.vertexClip.clipCodesCombined != 0x0000;
}

template <const bool useIndexBuffer, typename indexFormat, const bool rasterizerUsesEarlyZTest>
void IDirect3DDevice9Hook::DrawPrimitiveUBPretransformedSkipVS(const D3DPRIMITIVETYPE PrimitiveType, INT BaseVertexIndex, UINT startIndex, UINT primCount) const
{
	SIMPLE_FUNC_SCOPE();
#ifdef _DEBUG
	if (currentState.currentPixelShader && !currentState.currentPixelShader->jitShaderMain)
	{
		DbgPrint("Warning: Uncached pixel shader detected");
	}

	if (primCount == 0)
	{
		DbgBreakPrint("Error: Can't render with 0 primitives!");
	}
#endif

	DeclarationSemanticMapping vertexDeclMapping;
	vertexDeclMapping.ClearSemanticMapping();
	vertexDeclMapping.ComputeMappingPS(currentState.currentVertexDecl, currentState.currentPixelShader);
	InitPixelShader(currentState, currentState.currentPixelShader->GetShaderInfo() );

	SetupCurrentDrawCallPixelData(false, &vertexDeclMapping);

	const float fWidth = currentState.cachedViewport.fWidth;
	const float fHeight = currentState.cachedViewport.fHeight;
	SetupCurrentDrawCallTriangleRasterizeData(fWidth, fHeight, rasterizerUsesEarlyZTest, false, &vertexDeclMapping);

	const DebuggableD3DVERTEXELEMENT9* const positionT0 = currentState.currentVertexDecl->GetPositionT0Element();
	if (!positionT0)
	{
#ifdef _DEBUG
		__debugbreak(); // We should never be here...
#endif
		return;
	}
	const BYTE* const positionT0stream = currentState.currentStreams[positionT0->Stream].vertexBuffer->GetInternalDataBuffer() + currentState.currentStreams[positionT0->Stream].streamOffset + positionT0->Offset;
	const unsigned short positionT0streamStride = currentState.currentStreams[positionT0->Stream].streamStride;

	const indexFormat* indices = NULL;
	if (useIndexBuffer)
		indices = ( (const indexFormat* const)currentState.currentIndexBuffer->GetBufferBytes() ) + startIndex;

	switch (PrimitiveType)
	{
	case D3DPT_TRIANGLELIST:
	{
		for (unsigned primitiveID = 0; primitiveID < primCount; ++primitiveID)
		{
			const indexFormat i0 = useIndexBuffer ? (indices[primitiveID * 3] + BaseVertexIndex) : (primitiveID * 3);
			const indexFormat i1 = useIndexBuffer ? (indices[primitiveID * 3 + 1] + BaseVertexIndex) : (primitiveID * 3 + 1);
			const indexFormat i2 = useIndexBuffer ? (indices[primitiveID * 3 + 2] + BaseVertexIndex) : (primitiveID * 3 + 2);

			// Skip degenerate triangles
			if (useIndexBuffer)
				if (i0 == i1 || i1 == i2 || i0 == i2)
					continue;

			const BYTE* const v0 = positionT0stream + i0 * positionT0streamStride;
			const BYTE* const v1 = positionT0stream + i1 * positionT0streamStride;
			const BYTE* const v2 = positionT0stream + i2 * positionT0streamStride;
			switch (currentState.currentRenderStates.renderStatesUnion.namedStates.cullmode)
			{
			default:
#ifdef _DEBUG
			{
				__debugbreak(); // Should never be here
			}
#else
				__assume(0);
#endif
			case D3DCULL_CCW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, false, v0, v1, v2);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v1, (const D3DXVECTOR4* const)v2, fWidth, fHeight, primitiveID, i0, i1, i2);
#endif
				break;
			case D3DCULL_CW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i2, i1, false, v0, v2, v1);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v2, (const D3DXVECTOR4* const)v1, fWidth, fHeight, primitiveID, i0, i2, i1);
#endif
				break;
			case D3DCULL_NONE:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, false, v0, v1, v2);
				CreateNewTriangleRasterJob(primitiveID + primCount /*hack*/, i0, i2, i1, false, v0, v2, v1);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v1, (const D3DXVECTOR4* const)v2, fWidth, fHeight, primitiveID, i0, i1, i2);
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v2, (const D3DXVECTOR4* const)v1, fWidth, fHeight, primitiveID + primCount /*hack*/, i0, i2, i1);
#endif
				break;
			}
		}
	}
		break;
	case D3DPT_TRIANGLESTRIP:
	{
		const unsigned vertCount = primCount + 2;
		for (unsigned x = 2; x < vertCount; ++x)
		{
			const UINT primitiveID = x - 2;

			const indexFormat i2 = useIndexBuffer ? (indices[x] + BaseVertexIndex) : (primitiveID + 2);
			const indexFormat i1 = useIndexBuffer ? (indices[x - 1] + BaseVertexIndex) : (primitiveID + 1);
			const indexFormat i0 = useIndexBuffer ? (indices[primitiveID] + BaseVertexIndex) : (primitiveID);

			// Skip degenerate triangles
			if (useIndexBuffer)
				if (i0 == i1 || i1 == i2 || i0 == i2)
					continue;

			const BYTE* v2 = positionT0stream + i2 * positionT0streamStride;
			const BYTE* v1 = positionT0stream + i1 * positionT0streamStride;
			const BYTE* const v0 = positionT0stream + i0 * positionT0streamStride;
			if (x & 0x1)
				SwapWithCopy(v1, v2); // This alternating winding is necessary to keep triangles from flipping CW to CCW and back on every other triangle in the strip: https://msdn.microsoft.com/en-us/library/windows/desktop/bb206274(v=vs.85).aspx
			switch (currentState.currentRenderStates.renderStatesUnion.namedStates.cullmode)
			{
			default:
#ifdef _DEBUG
			{
				__debugbreak(); // Should never be here
			}
#else
				__assume(0);
#endif
			case D3DCULL_CCW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, false, v0, v1, v2);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v1, (const D3DXVECTOR4* const)v2, fWidth, fHeight, primitiveID, i0, i1, i2);
#endif
				break;
			case D3DCULL_CW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i2, i1, false, v0, v2, v1);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v2, (const D3DXVECTOR4* const)v1, fWidth, fHeight, primitiveID, i0, i2, i1);
#endif
				break;
			case D3DCULL_NONE:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, false, v0, v1, v2);
				CreateNewTriangleRasterJob(primitiveID + primCount /*hack*/, i0, i2, i1, false, v0, v2, v1);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v1, (const D3DXVECTOR4* const)v2, fWidth, fHeight, primitiveID, i0, i1, i2);
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v2, (const D3DXVECTOR4* const)v1, fWidth, fHeight, primitiveID + primCount /*hack*/, i0, i2, i1);
#endif
				break;
			}
		}
	}
		break;
	case D3DPT_TRIANGLEFAN:
	{
		const unsigned vertCount = primCount + 2;
		for (unsigned x = 2; x < vertCount; ++x)
		{
			const UINT primitiveID = x - 2;

			const indexFormat i2 = useIndexBuffer ? (indices[0] + BaseVertexIndex) : (0);
			const indexFormat i1 = useIndexBuffer ? (indices[x] + BaseVertexIndex) : (x);
			const indexFormat i0 = useIndexBuffer ? (indices[x - 1] + BaseVertexIndex) : (x - 1);

			// Skip degenerate triangles
			if (useIndexBuffer)
				if (i0 == i1 || i1 == i2 || i0 == i2)
					continue;

			const BYTE* const v0 = positionT0stream + i0 * positionT0streamStride;
			const BYTE* const v1 = positionT0stream + i1 * positionT0streamStride;
			const BYTE* const v2 = positionT0stream + i2 * positionT0streamStride;

			switch (currentState.currentRenderStates.renderStatesUnion.namedStates.cullmode)
			{
			default:
#ifdef _DEBUG
			{
				__debugbreak(); // Should never be here
			}
#else
				__assume(0);
#endif
			case D3DCULL_CCW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, false, v0, v1, v2);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v1, (const D3DXVECTOR4* const)v2, fWidth, fHeight, primitiveID, i0, i1, i2);
#endif
				break;
			case D3DCULL_CW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i2, i1, false, v0, v2, v1);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v2, (const D3DXVECTOR4* const)v1, fWidth, fHeight, primitiveID, i0, i2, i1);
#endif
				break;
			case D3DCULL_NONE:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, false, v0, v1, v2);
				CreateNewTriangleRasterJob(primitiveID + primCount /*TODO: Hack*/, i0, i2, i1, false, v0, v2, v1);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v1, (const D3DXVECTOR4* const)v2, fWidth, fHeight, primitiveID, i0, i1, i2);
				RasterizeTriangle<rasterizerUsesEarlyZTest, false>(&deviceMainPShaderEngine, &vertexDeclMapping, (const D3DXVECTOR4* const)v0, (const D3DXVECTOR4* const)v2, (const D3DXVECTOR4* const)v1, fWidth, fHeight, primitiveID + primCount /*TODO: Hack*/, i0, i2, i1);
#endif
				break;
			}
		}
	}
		break;
	default:
		// Not yet supported!
		DbgBreakPrint("Error: Not yet supported: Only triangles are currently supported for DrawPrimitiveUBPretransformedSkipVS");
		break;
	}

#ifdef MULTITHREAD_SHADING
	SynchronizeThreads<
#if TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
		4
#else
		1
#endif
	>();
#endif
}

template <const bool rasterizerUsesEarlyZTest>
void IDirect3DDevice9Hook::DrawPrimitiveUB(const D3DPRIMITIVETYPE PrimitiveType, const UINT PrimitiveCount) const
{
	SIMPLE_FUNC_SCOPE();
#ifdef _DEBUG
	if (currentState.currentPixelShader && !currentState.currentPixelShader->jitShaderMain)
	{
		DbgPrint("Warning: Uncached pixel shader detected");
	}

	if (processedVertsUsed == 0)
	{
		__debugbreak();
	}

	if (PrimitiveCount == 0)
	{
		DbgBreakPrint("Error: Can't render with 0 primitives!");
	}
#endif

	const VS_2_0_OutputRegisters* const processedVertsBuffer = processedVertexBuffer;

	VStoPSMapping vStoPSMapping;
	vStoPSMapping.ClearSemanticMapping();
	vStoPSMapping.ComputeMappingVSToPS(currentState.currentVertexShader, currentState.currentPixelShader);

	InitPixelShader(currentState, currentState.currentPixelShader->GetShaderInfo() );
	SetupCurrentDrawCallPixelData(true, &vStoPSMapping);

	const float fWidth = currentState.cachedViewport.fWidth;
	const float fHeight = currentState.cachedViewport.fHeight;
	SetupCurrentDrawCallTriangleRasterizeData(fWidth, fHeight, rasterizerUsesEarlyZTest, true, &vStoPSMapping);

	switch (PrimitiveType)
	{
	case D3DPT_TRIANGLELIST:
	{
#ifdef _DEBUG
		const unsigned vertCount = PrimitiveCount * 3;
		if (vertCount > processedVertsUsed)
		{
			__debugbreak();
		}
#endif
		for (unsigned primitiveID = 0; primitiveID < PrimitiveCount; ++primitiveID)
		{
			const unsigned i0 = primitiveID * 3;
			const unsigned i1 = i0 + 1;
			const unsigned i2 = i0 + 2;

			// Skip degenerate triangles
			if (i0 == i1 || i1 == i2 || i0 == i2)
				continue;

			if (ShouldCullEntireTriangle(processedVertsBuffer[i0], processedVertsBuffer[i1], processedVertsBuffer[i2]) )
				continue;

			switch (currentState.currentRenderStates.renderStatesUnion.namedStates.cullmode)
			{
			default:
#ifdef _DEBUG
			{
				__debugbreak();
			}
#else
				__assume(0);
#endif
			case D3DCULL_CCW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, true, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2]);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2], fWidth, fHeight, primitiveID, i0, i1, i2);
#endif
				break;
			case D3DCULL_CW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i2, i1, true, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1]);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1], fWidth, fHeight, primitiveID, i0, i2, i1);
#endif
				break;
			case D3DCULL_NONE:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, true, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2]);
				CreateNewTriangleRasterJob(primitiveID + PrimitiveCount /*TODO: Hack*/, i0, i2, i1, true, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1]);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2], fWidth, fHeight, primitiveID, i0, i1, i2);
				RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1], fWidth, fHeight, primitiveID + PrimitiveCount /*TODO: Hack*/, i0, i2, i1);
#endif
				break;
			}
		}
	}
		break;
	case D3DPT_TRIANGLESTRIP:
	{
		const unsigned vertCount = PrimitiveCount + 2;
#ifdef _DEBUG
		if (vertCount > processedVertsUsed)
		{
			__debugbreak();
		}
#endif
		for (unsigned x = 2; x < vertCount; ++x)
		{
			const UINT primitiveID = x - 2;

			const unsigned i2 = x;
			const unsigned i1 = x - 1;
			const unsigned i0 = primitiveID;

			// Skip degenerate triangles
			if (i0 == i1 || i1 == i2 || i0 == i2)
				continue;

			if (ShouldCullEntireTriangle(processedVertsBuffer[i0], processedVertsBuffer[i1], processedVertsBuffer[i2]) )
				continue;

			if (x & 0x1) // This alternating winding is necessary to keep triangles from flipping CW to CCW and back on every other triangle in the strip: https://msdn.microsoft.com/en-us/library/windows/desktop/bb206274(v=vs.85).aspx
			{
				switch (currentState.currentRenderStates.renderStatesUnion.namedStates.cullmode)
				{
				default:
#ifdef _DEBUG
				{
					__debugbreak();
				}
#else
				__assume(0);
#endif
				case D3DCULL_CCW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
					CreateNewTriangleRasterJob(primitiveID, i0, i2, i1, true, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1]);
#else
					RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1], fWidth, fHeight, primitiveID, i0, i2, i1);
#endif
					break;
				case D3DCULL_CW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
					CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, true, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2]);
#else
					RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2], fWidth, fHeight, primitiveID, i0, i1, i2);
#endif
					break;
				case D3DCULL_NONE:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
					CreateNewTriangleRasterJob(primitiveID, i0, i2, i1, true, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1]);
					CreateNewTriangleRasterJob(primitiveID + PrimitiveCount /*TODO: Hack*/, i0, i1, i2, true, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2]);
#else
					RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1], fWidth, fHeight, primitiveID, i0, i2, i1);
					RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2], fWidth, fHeight, primitiveID + PrimitiveCount /*TODO: Hack*/, i0, i1, i2);
#endif
					break;
				}
			}
			else
			{
				switch (currentState.currentRenderStates.renderStatesUnion.namedStates.cullmode)
				{
				default:
#ifdef _DEBUG
				{
					__debugbreak();
				}
#else
				__assume(0);
#endif
				case D3DCULL_CCW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
					CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, true, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2]);
#else
					RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2], fWidth, fHeight, primitiveID, i0, i1, i2);
#endif
					break;
				case D3DCULL_CW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
					CreateNewTriangleRasterJob(primitiveID, i0, i2, i1, true, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1]);
#else
					RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1], fWidth, fHeight, primitiveID, i0, i2, i1);
#endif
					break;
				case D3DCULL_NONE:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
					CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, true, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2]);
					CreateNewTriangleRasterJob(primitiveID + PrimitiveCount /*TODO: Hack*/, i0, i2, i1, true, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1]);
#else
					RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2], fWidth, fHeight, primitiveID, i0, i1, i2);
					RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1], fWidth, fHeight, primitiveID + PrimitiveCount /*TODO: Hack*/, i0, i2, i1);
#endif
					break;
				}
			}
		}
	}
		break;
	case D3DPT_TRIANGLEFAN:
	{
		const unsigned vertCount = PrimitiveCount + 2;
#ifdef _DEBUG
		if (vertCount > processedVertsUsed)
		{
			__debugbreak();
		}
#endif
		for (unsigned x = 2; x < vertCount; ++x)
		{
			const UINT primitiveID = x - 2;

			const unsigned i2 = 0;
			const unsigned i1 = x;
			const unsigned i0 = x - 1;

			// Skip degenerate triangles
			if (i0 == i1 || i1 == i2 || i0 == i2)
				continue;

			if (ShouldCullEntireTriangle(processedVertsBuffer[i0], processedVertsBuffer[i1], processedVertsBuffer[i2]) )
				continue;

			switch (currentState.currentRenderStates.renderStatesUnion.namedStates.cullmode)
			{
			default:
#ifdef _DEBUG
			{
				__debugbreak();
			}
#else
				__assume(0);
#endif
			case D3DCULL_CCW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, true, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2]);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2], fWidth, fHeight, primitiveID, i0, i1, i2);
#endif
				break;
			case D3DCULL_CW:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i2, i1, true, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1]);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1], fWidth, fHeight, primitiveID, i0, i2, i1);
#endif
				break;
			case D3DCULL_NONE:
#if defined(MULTITHREAD_SHADING) && TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
				CreateNewTriangleRasterJob(primitiveID, i0, i1, i2, true, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2]);
				CreateNewTriangleRasterJob(primitiveID + PrimitiveCount /*TODO: Hack*/, i0, i2, i1, true, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1]);
#else
				RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i1], &processedVertsBuffer[i2], fWidth, fHeight, primitiveID, i0, i1, i2);
				RasterizeTriangle<rasterizerUsesEarlyZTest, true>(&deviceMainPShaderEngine, &vStoPSMapping, &processedVertsBuffer[i0], &processedVertsBuffer[i2], &processedVertsBuffer[i1], fWidth, fHeight, primitiveID + PrimitiveCount /*TODO: Hack*/, i0, i2, i1);
#endif
				break;
			}
		}
	}
		break;
	case D3DPT_LINELIST:
	{
#ifdef _DEBUG
		const unsigned vertCount = PrimitiveCount * 2;
		if (vertCount > processedVertsUsed)
		{
			__debugbreak();
		}
#endif
		for (unsigned x = 0; x < PrimitiveCount; ++x)
		{
			const unsigned i0 = x * 2;
			const unsigned i1 = i0 + 1;

			RasterizeLineFromShader(vStoPSMapping, processedVertsBuffer[i0], processedVertsBuffer[i1]);
		}
	}
		break;
	case D3DPT_LINESTRIP:
	{
		const unsigned vertCount = PrimitiveCount + 1;
#ifdef _DEBUG
		if (vertCount > processedVertsUsed)
		{
			__debugbreak();
		}
#endif

		for (unsigned x = 1; x < vertCount; ++x)
		{
			const unsigned i1 = x;
			const unsigned i0 = x - 1;

			RasterizeLineFromShader(vStoPSMapping, processedVertsBuffer[i0], processedVertsBuffer[i1]);
		}
	}
		break;
	case D3DPT_POINTLIST:
	{
#ifdef _DEBUG
		const unsigned vertCount = PrimitiveCount;
		if (vertCount > processedVertsUsed)
		{
			__debugbreak();
		}
#endif

		for (unsigned x = 0; x < PrimitiveCount; ++x)
		{
			RasterizePointFromShader(vStoPSMapping, processedVertsBuffer[x]);
		}
	}
		break;
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
		break;
	}

#ifdef MULTITHREAD_SHADING
	//CloseThreadpoolCleanupGroupMembers(cleanup, FALSE, NULL);
	//RefreshThreadpoolWork();
	{
		SIMPLE_NAME_SCOPE("SynchronizeThreads");
		SynchronizeThreads<
#if TRIANGLEJOBS_OR_PIXELJOBS == PIXELJOBS
			4
#else
			1
#endif
		>();
	}
#endif
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::ProcessVertices(THIS_ UINT SrcStartIndex, UINT DestIndex, UINT VertexCount, IDirect3DVertexBuffer9* pDestBuffer, IDirect3DVertexDeclaration9* pVertexDecl, DWORD Flags)
{
#ifdef _DEBUG
	// Don't support this?
	DbgBreakPrint("Error: ProcessVertices() is not yet supported");
#endif
	const IDirect3DVertexBuffer9Hook* const hookPtr = dynamic_cast<IDirect3DVertexBuffer9Hook*>(pDestBuffer);
#ifdef _DEBUG
	if (hookPtr)
#endif
		pDestBuffer = hookPtr->GetUnderlyingVertexBuffer();
#ifdef _DEBUG
	else if (pDestBuffer != NULL)
	{
		DbgBreakPrint("Error: Destination vertex buffer is not hooked!");
	}
#endif
	HRESULT ret = d3d9dev->ProcessVertices(SrcStartIndex, DestIndex, VertexCount, pDestBuffer, pVertexDecl, Flags);

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::DrawRectPatch(THIS_ UINT Handle, CONST float* pNumSegs, CONST D3DRECTPATCH_INFO* pRectPatchInfo)
{
	// Nope! Not gonna support tessellation in D3D9
	DbgBreakPrint("Error: Tessellation is not yet supported");

	HRESULT ret = d3d9dev->DrawRectPatch(Handle, pNumSegs, pRectPatchInfo);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::DrawTriPatch(THIS_ UINT Handle, CONST float* pNumSegs, CONST D3DTRIPATCH_INFO* pTriPatchInfo)
{
	// Nope! Not gonna support tessellation in D3D9
	DbgBreakPrint("Error: Tessellation is not yet supported");

	HRESULT ret = d3d9dev->DrawTriPatch(Handle, pNumSegs, pTriPatchInfo);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::DeletePatch(THIS_ UINT Handle)
{
	// Nope! Not gonna support tessellation in D3D9
	DbgBreakPrint("Error: Tessellation is not yet supported");

	HRESULT ret = d3d9dev->DeletePatch(Handle);
	return ret;
}

const bool IDirect3DDevice9Hook::SkipVertexProcessing(void) const
{
	if (IsUsingFVF() )
	{
		return currentState.currentFVF.namedFVF.positionTypeLow == dbgD3DFVF_XYZRHW;
	}
	else
	{
		if (!currentState.currentVertexDecl)
			return true;
		return currentState.currentVertexDecl->SkipVertexProcessing();
	}
}

void IDirect3DDevice9Hook::InitializeState(const D3DPRESENT_PARAMETERS& d3dpp, const D3DDEVTYPE devType, const DWORD createFlags, const HWND focusWindow)
{
	currentPresentParams = d3dpp;

	// Init the viewport:
	currentState.cachedViewport.viewport.X = currentState.cachedViewport.viewport.Y = 0;
	currentState.cachedViewport.viewport.MinZ = 0.0f;
	currentState.cachedViewport.viewport.MaxZ = 1.0f;
	currentState.cachedViewport.viewport.Width = d3dpp.BackBufferWidth;
	currentState.cachedViewport.viewport.Height = d3dpp.BackBufferHeight;
	currentState.cachedViewport.RecomputeCache();

	// Init the scissor rect:
	currentState.currentScissorRect.scissorRect.left = currentState.currentScissorRect.scissorRect.top = 0;
	currentState.currentScissorRect.scissorRect.right = d3dpp.BackBufferWidth;
	currentState.currentScissorRect.scissorRect.bottom = d3dpp.BackBufferHeight;
	currentState.currentScissorRect.RecomputeScissorRect();

	// Very important to set these initial flags for the device:
	initialDevType = devType;
	initialCreateFlags = createFlags;
	initialCreateFocusWindow = focusWindow;
	initialCreateDeviceWindow = d3dpp.hDeviceWindow;

	// Mixed-mode vertex processing starts in hardware mode by default
	if (initialCreateFlags & (D3DCREATE_MIXED_VERTEXPROCESSING | D3DCREATE_HARDWARE_VERTEXPROCESSING) )
		currentSwvpEnabled = FALSE;
	else
		currentSwvpEnabled = TRUE;

	// Reset the implicit swap chain for this device:
	delete implicitSwapChain;
	implicitSwapChain = NULL;

	// Clear and then init the shader engines:
	deviceMainVShaderEngine.GlobalInit(&vsDrawCallCB);
	deviceMainPShaderEngine.GlobalInit(&psDrawCallCB);

#ifdef MULTITHREAD_SHADING
	for (unsigned x = 0; x < ARRAYSIZE(threadItem); ++x)
	{
		threadItem[x].threadVS_2_0.DeepCopy(deviceMainVShaderEngine);
		threadItem[x].threadPS_2_0.DeepCopy(deviceMainPShaderEngine);
	}
#endif // #ifdef MULTITHREAD_SHADING

#ifdef DUMP_TEXTURES_ON_FIRST_SET
	IDirect3DSurface9Hook::InitDumpSurfaces();
#endif

	LPDIRECT3DSWAPCHAIN9 realSwapChain = NULL;
#ifdef _DEBUG
	HRESULT swapChainHR = 
#endif
		d3d9dev->GetSwapChain(0, &realSwapChain);
#ifdef _DEBUG
	if (FAILED(swapChainHR) || !realSwapChain)
	{
		DbgBreakPrint("Error: Failed to retrieve real (unhooked) implicit swap chain");
	}
#endif

	LPDIRECT3DSURFACE9 realBackBuffer = NULL;
#ifdef _DEBUG
	HRESULT backBufferHR = 
#endif
		d3d9dev->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &realBackBuffer);
#ifdef _DEBUG
	if (FAILED(backBufferHR) || !realBackBuffer)
	{
		DbgBreakPrint("Error: Failed to retrieve real (unhooked) implicit back buffer");
	}
#endif

	IDirect3DSurface9Hook* backbufferSurfaceHook = new IDirect3DSurface9Hook(realBackBuffer, this);
	backbufferSurfaceHook->CreateDeviceImplicitSurface(d3dpp);
	backbufferSurfaceHook->AddRef();

	implicitSwapChain = new IDirect3DSwapChain9Hook(realSwapChain, this);
	implicitSwapChain->InitializeSwapChain(d3dpp, backbufferSurfaceHook);
	implicitSwapChain->AddRef();

	// Initialize all of our render targets:
	currentState.currentRenderTargets[0] = backbufferSurfaceHook;
	for (unsigned x = 1; x < D3D_MAX_SIMULTANEOUS_RENDERTARGETS; ++x)
		currentState.currentRenderTargets[x] = NULL;

	if (d3dpp.EnableAutoDepthStencil)
	{
		if (d3dpp.AutoDepthStencilFormat != D3DFMT_UNKNOWN)
		{
			LPDIRECT3DSURFACE9 realAutoDepthStencil = NULL;
#ifdef _DEBUG
			HRESULT getDepthStencilHR = 
#endif
			d3d9dev->GetDepthStencilSurface(&realAutoDepthStencil);
#ifdef _DEBUG
			if (FAILED(getDepthStencilHR) || !realAutoDepthStencil)
			{
				DbgBreakPrint("Error: Failed to retrieve real (unhooked) implicit depth-stencil surface");
			}
#endif
			IDirect3DSurface9Hook* autoDepthStencilSurfaceHook = new IDirect3DSurface9Hook(realAutoDepthStencil, this);
			autoDepthStencilSurfaceHook->CreateDeviceImplicitDepthStencil(d3dpp);
			
			currentState.currentDepthStencil = autoDepthStencilSurfaceHook;
		}
	}
	else
	{
		// The default value for this render state is D3DZB_TRUE if a depth stencil was created along with the swap chain by setting the EnableAutoDepthStencil member of the D3DPRESENT_PARAMETERS structure to TRUE, and D3DZB_FALSE otherwise.
		// Source: https://msdn.microsoft.com/en-us/library/windows/desktop/bb172599(v=vs.85).aspx
		currentState.currentRenderStates.renderStatesUnion.namedStates.zEnable = D3DZB_FALSE;
	}

#ifdef MULTITHREAD_SHADING
	MAX_NUM_JOBS = d3dpp.BackBufferWidth * d3dpp.BackBufferHeight * NUM_JOBS_PER_PIXEL;
	if (MAX_NUM_JOBS < 1024 * 1024)
		MAX_NUM_JOBS = 1024 * 1024; // We need to be able to shade 1024x1024 vertices in one draw call
	allWorkItems = (slist_item*)malloc(sizeof(slist_item) * MAX_NUM_JOBS);
	if (!allWorkItems)
	{
		__debugbreak();
	}

	// This is needed to init the threads to the proper state:
	SynchronizeThreads<1>();
#endif // MULTITHREAD_SHADING

	if (hConsoleHandle != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hConsoleHandle);
		hConsoleHandle = INVALID_HANDLE_VALUE;
	}
	hConsoleHandle = CreateFileA("CONOUT$", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
}

IDirect3DDevice9Hook::IDirect3DDevice9Hook(LPDIRECT3DDEVICE9 _d3d9dev, IDirect3D9Hook* _parentHook) : d3d9dev(_d3d9dev), parentHook(_parentHook), refCount(1), initialDevType(D3DDEVTYPE_HAL), initialCreateFlags(D3DCREATE_HARDWARE_VERTEXPROCESSING),
	enableDialogs(FALSE), sceneBegun(FALSE), implicitSwapChain(NULL), hConsoleHandle(INVALID_HANDLE_VALUE), numPixelsPassedZTest(0), initialCreateFocusWindow(NULL), initialCreateDeviceWindow(NULL),
	processedVertexBuffer(NULL), processedVertsUsed(0), processVertsAllocated(0), currentlyRecordingStateBlock(NULL), currentSwvpEnabled(FALSE)
{
#ifdef _DEBUG
	m_FirstMember = false;
#endif

	memset(&deviceCS, 0, sizeof(deviceCS) );
	InitializeCriticalSection(&deviceCS);

#ifdef _DEBUG
	memcpy(&CreationParameters, &d3d9dev->CreationParameters, (char*)&m_FirstMember - (char*)&CreationParameters);
#endif

#ifdef MULTITHREAD_SHADING
	InitThreadQueue();
#endif

#ifndef NO_CACHING_FVF_VERT_DECLS
	FVFToVertDeclCache = new std::map<DWORD, IDirect3DVertexDeclaration9Hook*>;
#endif

	alreadyShadedVerts32 = new std::vector<unsigned>();
	alreadyShadedVerts16 = new std::vector<unsigned short>();

	currentState.currentSoftUPStream.vertexBuffer = new IDirect3DVertexBuffer9Hook(NULL, this);
	currentState.currentSoftUPStream.vertexBuffer->MarkSoftBufferUP(true);

	currentState.currentSoftUPIndexBuffer = new IDirect3DIndexBuffer9Hook(NULL, this);
	currentState.currentSoftUPIndexBuffer->MarkSoftBufferUP(true);

	processedVertexBuffer = (VS_2_0_OutputRegisters* const)_mm_malloc(sizeof(VS_2_0_OutputRegisters), 16);
}

/*virtual*/ IDirect3DDevice9Hook::~IDirect3DDevice9Hook()
{
	if (currentlyRecordingStateBlock != NULL)
	{
		currentlyRecordingStateBlock->~IDirect3DStateBlock9Hook();
		_aligned_free(currentlyRecordingStateBlock);
		currentlyRecordingStateBlock = NULL;
	}

	delete currentState.currentSoftUPStream.vertexBuffer;
	currentState.currentSoftUPStream.vertexBuffer = NULL;
	delete currentState.currentSoftUPIndexBuffer;
	currentState.currentSoftUPIndexBuffer = NULL;

#ifndef NO_CACHING_FVF_VERT_DECLS
	delete FVFToVertDeclCache;
	FVFToVertDeclCache = NULL;
#endif

	delete alreadyShadedVerts32;
	alreadyShadedVerts32 = NULL;

	delete alreadyShadedVerts16;
	alreadyShadedVerts16 = NULL;

	if (processedVertexBuffer)
	{
		_mm_free(processedVertexBuffer);
		processedVertexBuffer = NULL;
	}

	DeleteCriticalSection(&deviceCS);
	memset(&deviceCS, 0, sizeof(deviceCS) );

#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
	memset(this, 0x00000000, sizeof(*this) );
#endif
}

// Returns true if the current vertex FVF or decl has a COLOR0 component, or false otherwise
const bool DeviceState::CurrentStateHasInputVertexColor0(void) const
{
	switch (declTarget)
	{
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Should never be here!");
#else
		__assume(0);
#endif
	case targetFVF:
		return currentFVF.namedFVF.hasDiffuse; // Diffuse color is always COLOR0
	case targetVertexDecl:
		if (currentVertexDecl)
			return currentVertexDecl->GetHasCOLOR0();
		return false;
	}
}

// Returns true if the current vertex FVF or decl has a COLOR1 component, or false otherwise
const bool DeviceState::CurrentStateHasInputVertexColor1(void) const
{
	switch (declTarget)
	{
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Should never be here!");
#else
		__assume(0);
#endif
	case targetFVF:
		return currentFVF.namedFVF.hasSpecular; // Specular color is always COLOR1
	case targetVertexDecl:
		if (currentVertexDecl)
			return currentVertexDecl->GetHasCOLOR1();
		return false;
	}
}

void IDirect3DDevice9Hook::ModifyPresentParameters(D3DPRESENT_PARAMETERS& modifiedParams)
{
#ifdef OVERRIDE_FORCE_WINDOWED_MODE
	modifiedParams.Windowed = TRUE; // Force Windowed mode
	modifiedParams.FullScreen_RefreshRateInHz = 0;
	//modifiedParams.BackBufferFormat = D3DFMT_UNKNOWN;
#endif // #ifdef OVERRIDE_FORCE_WINDOWED_MODE

#ifdef OVERRIDE_FORCE_NO_VSYNC
	modifiedParams.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE; // For performance, you're gonna want this enabled
#endif // #ifdef OVERRIDE_FORCE_NO_VSYNC

//#ifdef _DEBUG

	// We don't yet support multisampling
	modifiedParams.MultiSampleType = D3DMULTISAMPLE_NONE;
	modifiedParams.MultiSampleQuality = 0;
	modifiedParams.Flags &= (~D3DPRESENTFLAG_DEVICECLIP); // Remove the DEVICECLIP flag so that there aren't weird artifacts when rendering into a window that spans multiple monitors
//#endif
}

```

`Software_d3d9/IDirect3DDevice9Hook.h`:

```h
#pragma once

#include "IDirect3D9Hook.h"
#include "ShaderBase.h"
#include "VShaderEngine.h"
#include "PShaderEngine.h"
#include "DeviceState.h"
#include <vector>
#include <map>
#include <intrin.h>

#include "SimpleInstrumentedProfiler.h"

// 16 is the maximum number of vertex input streams supported by D3D9
#define MAX_D3D9_STREAMS 16u

class IDirect3D9Hook;
class IDirect3DVertexBuffer9Hook;
class IDirect3DIndexBuffer9Hook;
class IDirect3DVertexShader9Hook;
class IDirect3DPixelShader9Hook;
class IDirect3DVertexDeclaration9Hook;
class IDirect3DSurface9Hook;
class IDirect3DSwapChain9Hook;
class IDirect3DBaseTexture9Hook;
class IDirect3DTexture9Hook;
class IDirect3DCubeTexture9Hook;
class IDirect3DVolumeTexture9Hook;
class IDirect3DStateBlock9Hook;

struct DeclarationSemanticMapping;
struct VStoPSMapping;

#ifdef MULTITHREAD_SHADING
enum workerJobType
{
	vertexShade1Job = 0,

#ifdef RUN_SHADERS_IN_WARPS
	vertexShade4Job,
	//vertexShade16Job,
	//vertexShade64Job,
#endif // #ifdef RUN_SHADERS_IN_WARPS

	VERTEX_SHADE_JOB_MAX,

	pixelShade1Job,
#ifdef RUN_SHADERS_IN_WARPS
	pixelShade4Job,
	pixelShade16Job,
	pixelShade64Job,
#endif // #ifdef RUN_SHADERS_IN_WARPS

	PIXEL_SHADE_JOB_MAX,

	triangleRasterizeJob
};
#endif

struct DebuggableD3DVERTEXELEMENT9
{
	USHORT    Stream;     // Stream index
    USHORT    Offset;     // Offset in the stream in bytes
    D3DDECLTYPE Type : 8;       // Data type
    D3DDECLMETHOD    Method : 8;     // Processing method
    D3DDECLUSAGE    Usage : 8;      // Semantics
    DWORD    UsageIndex : 8; // Semantic index
};
static_assert(sizeof(D3DVERTEXELEMENT9) == sizeof(DebuggableD3DVERTEXELEMENT9), "Error!");

// A debuggable usage type for resource usages
enum DebuggableUsage : DWORD
{
	UsageNone = 0x00000000, // This is a valid usage, it is also the default usage
	UsageRENDERTARGET = D3DUSAGE_RENDERTARGET,
	UsageDEPTHSTENCIL = D3DUSAGE_DEPTHSTENCIL,
	UsageRESERVED0 = 0x00000004,
	UsageWRITEONLY = D3DUSAGE_WRITEONLY,
	UsageSOFTWAREPROCESSING = D3DUSAGE_SOFTWAREPROCESSING,
	UsageDONOTCLIP = D3DUSAGE_DONOTCLIP,
	UsagePOINTS = D3DUSAGE_POINTS,
	UsageRTPATCHES = D3DUSAGE_RTPATCHES,
	UsageNPATCHES = D3DUSAGE_NPATCHES,
	UsageDYNAMIC = D3DUSAGE_DYNAMIC,
	UsageAUTOGENMIPMAP = D3DUSAGE_AUTOGENMIPMAP,
	UsageRESTRICTEDCONTENT = D3DUSAGE_RESTRICTED_CONTENT,
	UsageRESTRICTSHAREDRESOURCEDRIVER = D3DUSAGE_RESTRICT_SHARED_RESOURCE_DRIVER,
	UsageRESTRICTSHAREDRESOURCE = D3DUSAGE_RESTRICT_SHARED_RESOURCE,
	UsageDMAP = D3DUSAGE_DMAP,
	UsageNONSECURE = D3DUSAGE_NONSECURE,
	UsageTEXTAPI = D3DUSAGE_TEXTAPI
};

static inline const bool operator!=(const D3DVIEWPORT9& lhs, const D3DVIEWPORT9& rhs)
{
	return memcmp(&lhs, &rhs, sizeof(D3DVIEWPORT9) ) != 0;
}

struct StreamSource
{
	StreamSource() : vertexBuffer(NULL), streamOffset(0), streamDividerFrequency(1), streamStride(0)
	{
	}

	// This function is used during state block captures to clone this struct (and make sure that pointer-fixups and AddRef() calls properly occur)
	void CopyForCapture(const StreamSource& rhs);

	~StreamSource()
	{
		vertexBuffer = NULL;
		streamOffset = 0;
		streamDividerFrequency = 1;
		streamStride = 0;
	}

	IDirect3DVertexBuffer9Hook* vertexBuffer;
	UINT streamOffset; // This offset is in bytes
	UINT streamDividerFrequency;
	unsigned short streamStride; // This stream stride is in bytes
};

struct StreamDataTypeEndPointers
{
	StreamDataTypeEndPointers()
	{
		ResetEndPointers();
	}

	~StreamDataTypeEndPointers()
	{
		ResetEndPointers();
	}

	inline void ResetEndPointers()
	{
		memset(this, 0, sizeof(*this) );
		dirty = true;
	}

	inline void SetDirty()
	{
#ifdef _DEBUG
		for (unsigned x = 0; x < ARRAYSIZE(dataTypeStreamEnds); ++x)
			dataTypeStreamEnds[x] = NULL;
		streamEndAbsolute = NULL;
#endif
		dirty = true;
	}

	const void* dataTypeStreamEnds[MAXD3DDECLTYPE];
	const BYTE* streamEndAbsolute;
	bool dirty; // The dirty bit can be set either by calling SetStreamSource() on this stream, or by calling SetVertexDeclarataion() with a new decl (or calling SetFVF() with a new FVF, although SetFVF internally calls SetVertexDeclaration)
};

struct TexturePaletteEntry
{
	PALETTEENTRY entries[256];
};

// Guard band clip code bitmasks
#define D3DCS_GBLEFT	0x00001000L
#define D3DCS_GBRIGHT	0x00002000L
#define D3DCS_GBTOP		0x00004000L
#define D3DCS_GBBOTTOM	0x00008000L

struct DeviceState_ShaderRegisters
{ 
	DeviceState_ShaderRegisters()
	{
		memset(this, 0, sizeof(*this) );
	}

	float4 floats[4096]; // 4096 is the maximum number of shader constants per constant buffer in D3D11 and D3D12, which acts as a nice superset of D3D9 functionality. Also we'll need at least 2048 + 64 slots available for supporting D3DRS_INDEXEDVERTEXBLENDENABLE.
	BOOL bools[16];
	int4 ints[16];
};

enum textureStageArgument : DWORD
{
	TA_DIFFUSE = D3DTA_DIFFUSE,
	TA_CURRENT = D3DTA_CURRENT,
	TA_TEXTURE = D3DTA_TEXTURE,
	TA_TFACTOR = D3DTA_TFACTOR,
	TA_SPECULAR = D3DTA_SPECULAR,
	TA_TEMP = D3DTA_TEMP,
	TA_CONSTANT = D3DTA_CONSTANT,

	TA_COMPLEMENT_DIFFUSE = D3DTA_DIFFUSE | D3DTA_COMPLEMENT,
	TA_COMPLEMENT_CURRENT = D3DTA_CURRENT | D3DTA_COMPLEMENT,
	TA_COMPLEMENT_TEXTURE = D3DTA_TEXTURE | D3DTA_COMPLEMENT,
	TA_COMPLEMENT_TFACTOR = D3DTA_TFACTOR | D3DTA_COMPLEMENT,
	TA_COMPLEMENT_SPECULAR = D3DTA_SPECULAR | D3DTA_COMPLEMENT,
	TA_COMPLEMENT_TEMP = D3DTA_TEMP | D3DTA_COMPLEMENT,
	TA_COMPLEMENT_CONSTANT = D3DTA_CONSTANT | D3DTA_COMPLEMENT,

	TA_DIFFUSE_ALPHAREPLICATE = D3DTA_DIFFUSE | D3DTA_ALPHAREPLICATE,
	TA_CURRENT_ALPHAREPLICATE = D3DTA_CURRENT | D3DTA_ALPHAREPLICATE,
	TA_TEXTURE_ALPHAREPLICATE = D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE,
	TA_TFACTOR_ALPHAREPLICATE = D3DTA_TFACTOR | D3DTA_ALPHAREPLICATE,
	TA_SPECULAR_ALPHAREPLICATE = D3DTA_SPECULAR | D3DTA_ALPHAREPLICATE,
	TA_TEMP_ALPHAREPLICATE = D3DTA_TEMP | D3DTA_ALPHAREPLICATE,
	TA_CONSTANT_ALPHAREPLICATE = D3DTA_CONSTANT | D3DTA_ALPHAREPLICATE,

	TA_COMPLEMENT_DIFFUSE_ALPHAREPLICATE = D3DTA_DIFFUSE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
	TA_COMPLEMENT_CURRENT_ALPHAREPLICATE = D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
	TA_COMPLEMENT_TEXTURE_ALPHAREPLICATE = D3DTA_TEXTURE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
	TA_COMPLEMENT_TFACTOR_ALPHAREPLICATE = D3DTA_TFACTOR | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
	TA_COMPLEMENT_SPECULAR_ALPHAREPLICATE = D3DTA_SPECULAR | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
	TA_COMPLEMENT_TEMP_ALPHAREPLICATE = D3DTA_TEMP | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
	TA_COMPLEMENT_CONSTANT_ALPHAREPLICATE = D3DTA_CONSTANT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE
};

struct TextureStageState
{
	TextureStageState()
	{
		memset(this, 0, sizeof(*this) );
		SetStageDefaults(0);
	}

	~TextureStageState()
	{
		memset(this, 0, sizeof(*this) );
		SetStageDefaults(0);
	}

	inline void SetStageDefaults(const unsigned stageNum)
	{
		// All of the invalid state indices have their values set to "0xBAADCAFE" in D3D9 under Windows 10
		static const DWORD invalidTypeValue = 0xBAADCAFE;
		for (unsigned x = 0; x < D3DTSS_CONSTANT + 1; ++x)
			stageStateUnion.state[x] = invalidTypeValue;

		if (stageNum == 0)
		{
			stageStateUnion.namedStates.colorOp = D3DTOP_MODULATE;
			stageStateUnion.namedStates.alphaOp = D3DTOP_SELECTARG1;
		}
		else
		{
			stageStateUnion.namedStates.colorOp = D3DTOP_DISABLE;
			stageStateUnion.namedStates.alphaOp = D3DTOP_DISABLE;
		}
		stageStateUnion.namedStates.colorArg1 = TA_TEXTURE;
		stageStateUnion.namedStates.colorArg2 = TA_CURRENT;
		stageStateUnion.namedStates.alphaArg1 = TA_TEXTURE;
		stageStateUnion.namedStates.alphaArg2 = TA_CURRENT;
		stageStateUnion.namedStates.bumpEnvMat00 = 0.0f;
		stageStateUnion.namedStates.bumpEnvMat01 = 0.0f;
		stageStateUnion.namedStates.bumpEnvMat10 = 0.0f;
		stageStateUnion.namedStates.bumpEnvMat11 = 0.0f;
		stageStateUnion.namedStates.texCoordIndex = D3DTSS_TCI_PASSTHRU | stageNum;
		stageStateUnion.namedStates.bumpEnvLScale = 0.0f; // Shouldn't this default to 1.0f instead?
		stageStateUnion.namedStates.bumpEnvLOffset = 0.0f;
		stageStateUnion.namedStates.textureTransformFlags = D3DTTFF_DISABLE;
		stageStateUnion.namedStates.colorArg0 = TA_CURRENT;
		stageStateUnion.namedStates.alphaArg0 = TA_CURRENT;
		stageStateUnion.namedStates.resultArg = TA_CURRENT;
		stageStateUnion.namedStates.constant = D3DCOLOR_ARGB(0, 0, 0, 0);
	}

	union _stageStateUnion
	{
		struct _namedStates
		{
			DWORD padding0; // 0
			D3DTEXTUREOP colorOp; // 1
			textureStageArgument colorArg1; // 2
			textureStageArgument colorArg2; // 3
			D3DTEXTUREOP alphaOp; // 4
			textureStageArgument alphaArg1; // 5
			textureStageArgument alphaArg2; // 6
			float bumpEnvMat00; // 7
			float bumpEnvMat01; // 8
			float bumpEnvMat10; // 9
			float bumpEnvMat11; // 10
			UINT texCoordIndex; // 11
			DWORD emptyAddress; // 12 - Used to be "D3DTSS_ADDRESS" which was of type D3DTEXTUREADDRESS in D3D7. It was a combination of ADDRESSU and ADDRESSV before they were split out - see d3d7types.h
			DWORD emptySamplerStates[9]; // 13 thru 21 (used to be where sampler state data was stored in D3D8 - see d3d8types.h)
			float bumpEnvLScale; // 22
			float bumpEnvLOffset; // 23
			D3DTEXTURETRANSFORMFLAGS textureTransformFlags; // 24
			DWORD emptyAddressW; // 25 - Used to be "D3DTSS_ADDRESSW" in D3D8 - see d3d8types.h
			textureStageArgument colorArg0; // 26
			textureStageArgument alphaArg0; // 27
			textureStageArgument resultArg; // 28
			DWORD emptyUnknown29[3]; // 29 thru 31 - Unknown what these used to be for
			D3DCOLOR constant; // 32
		} namedStates;
		DWORD state[D3DTSS_CONSTANT + 1];
	} stageStateUnion;
	static_assert(sizeof(_stageStateUnion) == sizeof(DWORD) * (D3DTSS_CONSTANT + 1), "Error: Unexpected union size!");
};

struct TexturePaletteState
{
	TexturePaletteState() : currentPaletteIndex(0xFFFF), paletteEntries(NULL)
	{
	}

	void CaptureCopyTexturePaletteState(const TexturePaletteState& rhs)
	{
		currentPaletteIndex = rhs.currentPaletteIndex;
		if (rhs.paletteEntries)
		{
			paletteEntries = new std::vector<TexturePaletteEntry>();
			*paletteEntries = *(rhs.paletteEntries);
		}
		else
			paletteEntries = NULL;
	}

	~TexturePaletteState()
	{
		currentPaletteIndex = 0xFFFF;

		if (paletteEntries)
		{
			paletteEntries->clear();
			delete paletteEntries;
			paletteEntries = NULL;
		}
	}

	unsigned short currentPaletteIndex; // This is a USHORT because the D3D9 spec says that there's a maximum of 64k texture palettes
	std::vector<TexturePaletteEntry>* paletteEntries;
};

union RGB565
{
	struct _bits565
	{
		unsigned short b : 5;
		unsigned short g : 6;
		unsigned short r : 5;
	} bits565;

	unsigned short word;
};
static_assert(sizeof(RGB565) == sizeof(unsigned short), "Error! Unexpected struct size!");

union A4R4G4B4
{
	struct _bits4444
	{
		unsigned short b : 4;
		unsigned short g : 4;
		unsigned short r : 4;
		unsigned short a : 4;
	} bits4444;

	unsigned short word;
};
static_assert(sizeof(A4R4G4B4) == sizeof(unsigned short), "Error! Unexpected struct size!");

union X4R4G4B4
{
	struct _bits4440
	{
		unsigned short b : 4;
		unsigned short g : 4;
		unsigned short r : 4;
		unsigned short x : 4;
	} bits4440;

	unsigned short word;
};
static_assert(sizeof(X4R4G4B4) == sizeof(unsigned short), "Error! Unexpected struct size!");

__declspec(align(16) ) struct Transforms
{
#define MAX_WORLD_TRANSFORMS 256

	Transforms() : wvpDirty(true)
	{
		memset(this, 0, sizeof(*this) );

		static const unsigned numTransformsTotal = sizeof(*this) / sizeof(D3DXMATRIXA16);
		for (unsigned x = 0; x < numTransformsTotal; ++x)
		{
			D3DXMatrixIdentity(&ViewTransform + x);
		}
	}

	~Transforms()
	{
		memset(this, 0, sizeof(*this) );
	}

	inline void SetViewTransform(const D3DXMATRIXA16& newView)
	{
		wvpDirty = true;
		wvDirty[0] = true;
		wvDirty[1] = true;
		wvDirty[2] = true;
		wvDirty[3] = true;
		ViewTransform = newView;
	}

	inline void SetProjectionTransform(const D3DXMATRIXA16& newProj)
	{
		wvpDirty = true;
		ProjectionTransform = newProj;
	}

	inline void SetWorldTransform(const D3DXMATRIXA16& newWorld, const unsigned char worldIndex)
	{
		if (worldIndex < 4)
		{
			if (worldIndex == 0)
				wvpDirty = true;
			wvDirty[worldIndex] = true;
		}
		WorldTransforms[worldIndex] = newWorld;
	}

	inline void SetTextureTransform(const D3DXMATRIXA16& newTexture, const unsigned char textureIndex)
	{
#ifdef _DEBUG
		if (textureIndex >= 8)
		{
			__debugbreak();
		}
#endif
		TextureTransforms[textureIndex] = newTexture;
	}

	D3DXMATRIXA16 ViewTransform;
	D3DXMATRIXA16 ProjectionTransform;
	D3DXMATRIXA16 TextureTransforms[D3DDP_MAXTEXCOORD];
	D3DXMATRIXA16 WorldTransforms[MAX_WORLD_TRANSFORMS];

	inline void ComputeWVMatrixForCache(const unsigned char wvMatrixIndex) const
	{
		D3DXMATRIXA16& cachedWV = CachedWVTransform[wvMatrixIndex];
		cachedWV = WorldTransforms[wvMatrixIndex] * ViewTransform;
		D3DXMatrixInverse(&(CachedInvWVTransform[wvMatrixIndex]), NULL, &cachedWV);
	}

	inline const D3DXMATRIXA16& GetWVPTransform() const
	{
		if (wvDirty[0])
		{
			wvDirty[0] = false;
			ComputeWVMatrixForCache(0);
		}
		if (wvpDirty)
		{
			wvpDirty = false;
			CachedWVPTransform = CachedWVTransform[0] * ProjectionTransform;
		}
		return CachedWVPTransform;
	}

	inline const D3DXMATRIXA16& GetWVTransformFromCache(const unsigned char worldTransformIndex) const
	{
#ifdef _DEBUG
		if (worldTransformIndex >= 4)
		{
			__debugbreak();
		}
#endif
		if (bool& isThisWVDirty = wvDirty[worldTransformIndex])
		{
			isThisWVDirty = false;
			ComputeWVMatrixForCache(worldTransformIndex);
		}
		return CachedWVTransform[worldTransformIndex];
	}

	inline void GetWVTransform(const unsigned char worldTransformIndex, D3DXMATRIXA16& outWVMatrix) const
	{
		if (worldTransformIndex < 4)
			outWVMatrix = GetWVTransformFromCache(worldTransformIndex);
		else
			outWVMatrix = WorldTransforms[worldTransformIndex] * ViewTransform;
	}

	inline const D3DXMATRIXA16& GetInvWVTransformFromCache(const unsigned char worldTransformIndex) const
	{
#ifdef _DEBUG
		if (worldTransformIndex >= 4)
		{
			__debugbreak();
		}
#endif
		if (bool& isThisWVDirty = wvDirty[worldTransformIndex])
		{
			isThisWVDirty = false;
			ComputeWVMatrixForCache(worldTransformIndex);
		}
		return CachedInvWVTransform[worldTransformIndex];
	}

	inline void GetInvWVTransform(const unsigned char worldTransformIndex, D3DXMATRIXA16& outInvWVMatrix) const
	{
		if (worldTransformIndex < 4)
			outInvWVMatrix = GetInvWVTransformFromCache(worldTransformIndex);
		else
			D3DXMatrixInverse(&outInvWVMatrix, NULL, &(CachedWVTransform[worldTransformIndex]) );
	}

	mutable D3DXMATRIXA16 CachedWVPTransform; // This is a cached version of worldMatrix0 * viewMatrix * projMatrix
	mutable D3DXMATRIXA16 CachedWVTransform[4];
	mutable D3DXMATRIXA16 CachedInvWVTransform[4];
	mutable bool wvpDirty;
	mutable bool wvDirty[4];
};

struct LightInfo
{
	LightInfo() : activeLightIndex(-1)
	{
		memset(&light, 0, sizeof(light) );
		light.Type = D3DLIGHT_DIRECTIONAL;
		light.Diffuse.r = light.Diffuse.g = light.Diffuse.b = 1.0f;
		light.Direction.z = 1.0f;
	}

	D3DLIGHT9 light;
	INT activeLightIndex;

	// This isn't marked const, but it is global, so please do not modify its data
	static LightInfo defaultLight;
};

struct CachedViewport
{
	CachedViewport()
	{
		memset(this, 0, sizeof(*this) );
	}

	~CachedViewport()
	{
		memset(this, 0, sizeof(*this) );
	}

	inline void RecomputeCache()
	{
		halfWidthF = viewport.Width * 0.5f;
		halfHeightF = viewport.Height * 0.5f;
		fLeft = (const float)viewport.X;
		fTop = (const float)viewport.Y;
		fWidth = (const float)(viewport.Width - 1);
		fHeight = (const float)(viewport.Height - 1);
		zScale = viewport.MaxZ - viewport.MinZ;
	}

	D3DVIEWPORT9 viewport;
	float halfWidthF;
	float halfHeightF;
	float fLeft;
	float fTop;
	float fWidth;
	float fHeight;
	float zScale;
};

struct scissorRectStruct
{
	scissorRectStruct()
	{
		memset(this, 0, sizeof(*this) );
	}

	~scissorRectStruct()
	{
		memset(this, 0, sizeof(*this) );
	}

	RECT scissorRect;
	float fleft, fright, ftop, fbottom;
	__m128 topleftF;
	__m128 botrightF;

	inline void RecomputeScissorRect()
	{
		fleft = (const float)scissorRect.left;
		fright = (const float)scissorRect.right;
		ftop = (const float)scissorRect.top;
		fbottom = (const float)scissorRect.bottom;

		topleftF = _mm_set_ps(0.0f, 0.0f, ftop, fleft);
		botrightF = _mm_set_ps(0.0f, 0.0f, fbottom, fright);
	}
};

struct DeviceState
{
	DeviceState() : currentIndexBuffer(NULL), currentVertexShader(NULL), currentPixelShader(NULL), currentVertexDecl(NULL), declTarget(targetFVF), currentDepthStencil(NULL), currentNPatchMode(0.0f)
	{
		currentFVF.rawFVF_DWORD = 0x00000000;

		memset(&currentRenderTargets, 0, sizeof(currentRenderTargets) );
		memset(&currentTextures, 0, sizeof(currentTextures) );
		memset(&currentCubeTextures, 0, sizeof(currentTextures) );
		memset(&currentVolumeTextures, 0, sizeof(currentTextures) );
		memset(&currentMaterial, 0, sizeof(currentMaterial) ); // Looks like our material gets initialized to all zeroes (as per GetMaterial() right after device creation)
		memset(&enabledLightIndices, 0, sizeof(enabledLightIndices) );

		for (unsigned x = 0; x < 8; ++x)
			currentStageStates[x].SetStageDefaults(x);

		for (unsigned x = 0; x < D3DMAXUSERCLIPPLANES; ++x)
			currentClippingPlanes[x] = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);

		lightInfoMap = new std::map<UINT, LightInfo*>();
	}

	// Used during state block captures to copy the device state over
	void CaptureCopyState(const DeviceState& rhs);

#define MAX_NUM_SAMPLERS (D3DVERTEXTEXTURESAMPLER3 + 1)
#define MAX_NUM_TEXTURE_STAGE_STATES 8

	~DeviceState()
	{
		currentIndexBuffer = NULL;
		currentVertexShader = NULL;
		currentPixelShader = NULL;
		for (unsigned x = 0; x < MAX_NUM_SAMPLERS; ++x)
		{
			currentTextures[x] = NULL;
			currentCubeTextures[x] = NULL;
			currentVolumeTextures[x] = NULL;
		}

		for (unsigned x = 0; x < ARRAYSIZE(enabledLightIndices); ++x)
			enabledLightIndices[x] = NULL;

		for (unsigned x = 0; x < ARRAYSIZE(currentRenderTargets); ++x)
			currentRenderTargets[x] = NULL;
		currentDepthStencil = NULL;

		currentNPatchMode = 0.0f;

		if (lightInfoMap)
		{
			for (std::map<UINT, LightInfo*>::iterator it = lightInfoMap->begin(); it != lightInfoMap->end(); ++it)
			{
				delete it->second;
				it->second = NULL;
			}
			delete lightInfoMap;
			lightInfoMap = NULL;
		}

		declTarget = targetFVF;
		currentVertexDecl = NULL;

		currentFVF.rawFVF_DWORD = 0x00000000;
	}

	IDirect3DIndexBuffer9Hook* currentIndexBuffer;
	IDirect3DIndexBuffer9Hook* currentSoftUPIndexBuffer;

	StreamSource currentStreams[MAX_D3D9_STREAMS]; // 16 is MaxStreams from the D3D9 Caps
	StreamDataTypeEndPointers currentStreamEnds[MAX_D3D9_STREAMS]; // 16 is MaxStreams from the D3D9 Caps
	StreamSource currentSoftUPStream;
	StreamDataTypeEndPointers currentSoftUPStreamEnd;
	IDirect3DVertexShader9Hook* currentVertexShader;
	DeviceState_ShaderRegisters vertexShaderRegisters;
	IDirect3DPixelShader9Hook* currentPixelShader;
	DeviceState_ShaderRegisters pixelShaderRegisters;
	TexturePaletteState currentPaletteState;

	// TODO: Refactor the hooks inheritance tree to make this work with baseTextures so we don't need these duplicates:
	IDirect3DTexture9Hook* currentTextures[MAX_NUM_SAMPLERS];
	IDirect3DCubeTexture9Hook* currentCubeTextures[MAX_NUM_SAMPLERS];
	IDirect3DVolumeTexture9Hook* currentVolumeTextures[MAX_NUM_SAMPLERS];
	SamplerState currentSamplerStates[MAX_NUM_SAMPLERS];
	TextureStageState currentStageStates[MAX_NUM_TEXTURE_STAGE_STATES];

	D3DXPLANE currentClippingPlanes[D3DMAXUSERCLIPPLANES];

	D3DMATERIAL9 currentMaterial;
	float currentNPatchMode;

	__declspec(align(16) ) RenderStates currentRenderStates;

	std::map<UINT, LightInfo*>* lightInfoMap;
#define MAX_ENABLED_LIGHTS 32 // CAPS only goes up to 8, but we can do better
	LightInfo* enabledLightIndices[MAX_ENABLED_LIGHTS];

	// Transforms:
	Transforms currentTransforms;

	// TODO: Initialize the first render target to the backbuffer of the implicit swap chain
	IDirect3DSurface9Hook* currentRenderTargets[D3D_MAX_SIMULTANEOUS_RENDERTARGETS];
	IDirect3DSurface9Hook* currentDepthStencil; // TODO: Initialize the depth-stencil surface to the implicitly-created depth-stencil (if any)

	// Initialized inside of InitializeState() after CreateDevice() or Reset() is called successfully
	scissorRectStruct currentScissorRect;
	CachedViewport cachedViewport;

	enum _declTarget
	{
		targetFVF = 0,
		targetVertexDecl
	} declTarget; // Are we currently in FVF-mode or in vertex-decl mode?
	IDirect3DVertexDeclaration9Hook* currentVertexDecl;
	debuggableFVF currentFVF;

	// Returns true if the current vertex FVF or decl has a COLOR0 component, or false otherwise
	const bool CurrentStateHasInputVertexColor0(void) const;

	// Returns true if the current vertex FVF or decl has a COLOR1 component, or false otherwise
	const bool CurrentStateHasInputVertexColor1(void) const;
};

struct DeviceFrameStats
{
	DeviceFrameStats()
	{
		Clear();
	}

	inline void Clear()
	{
		memset(this, 0, sizeof(*this) );
	}

	unsigned numVertsProcessed;
	unsigned numTrianglesProcessed;
	unsigned numAlphaTestFailPixels;
	unsigned numPixelsWritten;
	unsigned numPixelsShaded;
	unsigned numPixelsTexkilled;
	unsigned numVertsReused;
};

struct drawCallVertexJobData
{
	drawCallVertexJobData() : userClipPlanesEnabled(false), mapping(NULL)
	{
	}

	bool userClipPlanesEnabled; // true = any user clip planes are enabled, false = none of them are enabled
	const DeclarationSemanticMapping* mapping;
};

struct drawCallPixelJobData
{
	drawCallPixelJobData() : useShaderVerts(false), offsetIntoVertexForOPosition_Bytes(0)
	{
		vs_to_ps_mappings.vs_psMapping = NULL;
		vs_to_ps_mappings.vertexDeclMapping = NULL;
	}

	bool useShaderVerts; // true = shadeFromShaderOutputRegs, false = shadeFromStream
	UINT offsetIntoVertexForOPosition_Bytes; // The number of bytes to get to "float4 oPos" into either a fully-transformed user-provided vertex (stream) or a vertex shader output register buffer (shader)
	union
	{
		const VStoPSMapping* vs_psMapping;
		const DeclarationSemanticMapping* vertexDeclMapping;
		const void* sourceAgnosticMapping;
	} vs_to_ps_mappings;
};

__declspec(align(16) ) struct primitivePixelJobData
{
	primitivePixelJobData() : invZ(0.0f, 0.0f, 0.0f), invW(0.0f, 0.0f, 0.0f), barycentricNormalizeFactor(0.0f), primitiveID(0), VFace(true), vertex0index(0), vertex1index(0), vertex2index(0)
	{
		pixelShadeVertexData.shadeFromShader.v0 = NULL;
		pixelShadeVertexData.shadeFromShader.v1 = NULL;
		pixelShadeVertexData.shadeFromShader.v2 = NULL;

		pixelShadeVertexData.shadeFromStream.v0 = NULL;
		pixelShadeVertexData.shadeFromStream.v1 = NULL;
		pixelShadeVertexData.shadeFromStream.v2 = NULL;
	}

	// This is: float3(1.0f / v0.z, 1.0f / v1.z, 1.0f / v2.z)
	__declspec(align(16) ) D3DXVECTOR3 invZ;

	// This is: float3(1.0f / v0.w, 1.0f / v1.w, 1.0f / v2.w)
	__declspec(align(16) ) D3DXVECTOR3 invW;

	union _pixelShadeVertexData
	{
		struct _shadeFromShader
		{
			const VS_2_0_OutputRegisters* v0;
			const VS_2_0_OutputRegisters* v1;
			const VS_2_0_OutputRegisters* v2;
		} shadeFromShader;
		struct _shadeFromStream
		{
			CONST BYTE* v0;
			CONST BYTE* v1;
			CONST BYTE* v2;
		} shadeFromStream;
		struct _shadeFromAgnostic
		{
			const void* v0;
			const void* v1;
			const void* v2;
		} shadeFromAgnostic;
	} pixelShadeVertexData;
	UINT vertex0index;
	UINT vertex1index;
	UINT vertex2index;
	float barycentricNormalizeFactor;
	UINT primitiveID; // This is the ps_4_0 SV_PrimitiveID semantic for this primitive (not used in D3D9, but included here as being useful for debugging)
	// UINT instanceID; // This is the ps_4_0 SV_InstanceID semantic for this primitive (not used in D3D9)
	bool VFace; // This is the ps_3_0 VFACE semantic or the ps_4_0 SV_IsFrontFace semantic for this primitive
};

struct drawCallTriangleRasterizeJobsData
{
	float fWidth, fHeight;
	union
	{
		const DeclarationSemanticMapping* vertexDeclMapping;
		const VStoPSMapping* vStoPSMapping;
	};
	bool rasterizerUsesEarlyZTest;
	bool rasterizeTriangleFromShader; // true = from shader, false = from stream
};

struct currentDrawCallJobData
{
	drawCallVertexJobData vertexData;

	// TODO: Mutable is gross, try and find another way to do this...
	mutable drawCallPixelJobData pixelData;

	// TODO: Mutable is gross, try and find another way to do this...
	mutable drawCallTriangleRasterizeJobsData triangleRasterizeData;
};

__declspec(align(16) ) class IDirect3DDevice9Hook : public IDirect3DDevice9
{
public:

	// This always has to be the first member variable in this class (or the initial memcpy() will fail)
#ifdef _DEBUG
	bool m_FirstMember;
#endif

	IDirect3DDevice9Hook(LPDIRECT3DDEVICE9 _d3d9dev, IDirect3D9Hook* _parentHook);

	virtual ~IDirect3DDevice9Hook();

	inline LPDIRECT3DDEVICE9 GetUnderlyingDevice(void) const
	{
		return d3d9dev;
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DDevice9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TestCooperativeLevel(THIS) override;
    virtual COM_DECLSPEC_NOTHROW UINT STDMETHODCALLTYPE GetAvailableTextureMem(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvictManagedResources(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDirect3D(THIS_ IDirect3D9** ppD3D9) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDeviceCaps(THIS_ D3DCAPS9* pCaps) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDisplayMode(THIS_ UINT iSwapChain, D3DDISPLAYMODE* pMode) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCreationParameters(THIS_ D3DDEVICE_CREATION_PARAMETERS* pParameters) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCursorProperties(THIS_ UINT XHotSpot, UINT YHotSpot, IDirect3DSurface9* pCursorBitmap) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE SetCursorPosition(THIS_ int X, int Y, DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW BOOL STDMETHODCALLTYPE ShowCursor(THIS_ BOOL bShow) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateAdditionalSwapChain(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DSwapChain9** pSwapChain) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSwapChain(THIS_ UINT iSwapChain, IDirect3DSwapChain9** pSwapChain) override;
    virtual COM_DECLSPEC_NOTHROW UINT STDMETHODCALLTYPE GetNumberOfSwapChains(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Reset(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Present(THIS_ CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetBackBuffer(THIS_ UINT iSwapChain, UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRasterStatus(THIS_ UINT iSwapChain, D3DRASTER_STATUS* pRasterStatus) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetDialogBoxMode(THIS_ BOOL bEnableDialogs) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE SetGammaRamp(THIS_ UINT iSwapChain,DWORD Flags, CONST D3DGAMMARAMP* pRamp) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE GetGammaRamp(THIS_ UINT iSwapChain, D3DGAMMARAMP* pRamp) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateTexture(THIS_ UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DTexture9** ppTexture, HANDLE* pSharedHandle) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateVolumeTexture(THIS_ UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DVolumeTexture9** ppVolumeTexture, HANDLE* pSharedHandle) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateCubeTexture(THIS_ UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DCubeTexture9** ppCubeTexture, HANDLE* pSharedHandle) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateVertexBuffer(THIS_ UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, IDirect3DVertexBuffer9** ppVertexBuffer, HANDLE* pSharedHandle) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateIndexBuffer(THIS_ UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DIndexBuffer9** ppIndexBuffer, HANDLE* pSharedHandle) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateRenderTarget(THIS_ UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Lockable, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateDepthStencilSurface(THIS_ UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Discard, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdateSurface(THIS_ IDirect3DSurface9* pSourceSurface, CONST RECT* pSourceRect, IDirect3DSurface9* pDestinationSurface, CONST POINT* pDestPoint) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdateTexture(THIS_ IDirect3DBaseTexture9* pSourceTexture, IDirect3DBaseTexture9* pDestinationTexture) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRenderTargetData(THIS_ IDirect3DSurface9* pRenderTarget, IDirect3DSurface9* pDestSurface) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFrontBufferData(THIS_ UINT iSwapChain, IDirect3DSurface9* pDestSurface) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StretchRect(THIS_ IDirect3DSurface9* pSourceSurface, CONST RECT* pSourceRect, IDirect3DSurface9* pDestSurface, CONST RECT* pDestRect, D3DTEXTUREFILTERTYPE Filter) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ColorFill(THIS_ IDirect3DSurface9* pSurface, CONST RECT* pRect, D3DCOLOR color) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateOffscreenPlainSurface(THIS_ UINT Width, UINT Height, D3DFORMAT Format, D3DPOOL Pool, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRenderTarget(THIS_ DWORD RenderTargetIndex, IDirect3DSurface9* pRenderTarget) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRenderTarget(THIS_ DWORD RenderTargetIndex, IDirect3DSurface9** ppRenderTarget) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetDepthStencilSurface(THIS_ IDirect3DSurface9* pNewZStencil) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDepthStencilSurface(THIS_ IDirect3DSurface9** ppZStencilSurface) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeginScene(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EndScene(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Clear(THIS_ DWORD Count, CONST D3DRECT* pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetTransform(THIS_ D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTransform(THIS_ D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE MultiplyTransform(THIS_ D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetViewport(THIS_ CONST D3DVIEWPORT9* pViewport) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetViewport(THIS_ D3DVIEWPORT9* pViewport) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetMaterial(THIS_ CONST D3DMATERIAL9* pMaterial) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMaterial(THIS_ D3DMATERIAL9* pMaterial) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetLight(THIS_ DWORD Index, CONST D3DLIGHT9*) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLight(THIS_ DWORD Index, D3DLIGHT9*) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LightEnable(THIS_ DWORD Index, BOOL Enable) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLightEnable(THIS_ DWORD Index, BOOL* pEnable) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetClipPlane(THIS_ DWORD Index, CONST float* pPlane) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClipPlane(THIS_ DWORD Index, float* pPlane) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRenderState(THIS_ D3DRENDERSTATETYPE State, DWORD Value) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRenderState(THIS_ D3DRENDERSTATETYPE State, DWORD* pValue) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateStateBlock(THIS_ D3DSTATEBLOCKTYPE Type, IDirect3DStateBlock9** ppSB) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeginStateBlock(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EndStateBlock(THIS_ IDirect3DStateBlock9** ppSB) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetClipStatus(THIS_ CONST D3DCLIPSTATUS9* pClipStatus) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClipStatus(THIS_ D3DCLIPSTATUS9* pClipStatus) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTexture(THIS_ DWORD Stage, IDirect3DBaseTexture9** ppTexture) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetTexture(THIS_ DWORD Stage, IDirect3DBaseTexture9* pTexture) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTextureStageState(THIS_ DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD* pValue) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetTextureStageState(THIS_ DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSamplerState(THIS_ DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD* pValue) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetSamplerState(THIS_ DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD Value) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ValidateDevice(THIS_ DWORD* pNumPasses) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPaletteEntries(THIS_ UINT PaletteNumber, CONST PALETTEENTRY* pEntries) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPaletteEntries(THIS_ UINT PaletteNumber, PALETTEENTRY* pEntries) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCurrentTexturePalette(THIS_ UINT PaletteNumber) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentTexturePalette(THIS_ UINT *PaletteNumber) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetScissorRect(THIS_ CONST RECT* pRect) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetScissorRect(THIS_ RECT* pRect) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetSoftwareVertexProcessing(THIS_ BOOL bSoftware) override;
    virtual COM_DECLSPEC_NOTHROW BOOL STDMETHODCALLTYPE GetSoftwareVertexProcessing(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetNPatchMode(THIS_ float nSegments) override;
    virtual COM_DECLSPEC_NOTHROW float STDMETHODCALLTYPE GetNPatchMode(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DrawPrimitive(THIS_ D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DrawIndexedPrimitive(THIS_ D3DPRIMITIVETYPE, INT BaseVertexIndex, UINT MinVertexIndex, UINT NumVertices, UINT startIndex, UINT primCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DrawPrimitiveUP(THIS_ D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void* pVertexStreamZeroData, UINT VertexStreamZeroStride) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DrawIndexedPrimitiveUP(THIS_ D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertices, UINT PrimitiveCount, CONST void* pIndexData, D3DFORMAT IndexDataFormat, CONST void* pVertexStreamZeroData, UINT VertexStreamZeroStride) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcessVertices(THIS_ UINT SrcStartIndex, UINT DestIndex, UINT VertexCount, IDirect3DVertexBuffer9* pDestBuffer, IDirect3DVertexDeclaration9* pVertexDecl, DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateVertexDeclaration(THIS_ CONST D3DVERTEXELEMENT9* pVertexElements, IDirect3DVertexDeclaration9** ppDecl) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetVertexDeclaration(THIS_ IDirect3DVertexDeclaration9* pDecl) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVertexDeclaration(THIS_ IDirect3DVertexDeclaration9** ppDecl) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetFVF(THIS_ DWORD FVF) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFVF(THIS_ DWORD* pFVF) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateVertexShader(THIS_ CONST DWORD* pFunction, IDirect3DVertexShader9** ppShader) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetVertexShader(THIS_ IDirect3DVertexShader9* pShader) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVertexShader(THIS_ IDirect3DVertexShader9** ppShader) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetVertexShaderConstantF(THIS_ UINT StartRegister, CONST float* pConstantData, UINT Vector4fCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVertexShaderConstantF(THIS_ UINT StartRegister, float* pConstantData, UINT Vector4fCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetVertexShaderConstantI(THIS_ UINT StartRegister, CONST int* pConstantData, UINT Vector4iCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVertexShaderConstantI(THIS_ UINT StartRegister, int* pConstantData, UINT Vector4iCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetVertexShaderConstantB(THIS_ UINT StartRegister, CONST BOOL* pConstantData, UINT  BoolCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVertexShaderConstantB(THIS_ UINT StartRegister, BOOL* pConstantData, UINT BoolCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetStreamSource(THIS_ UINT StreamNumber, IDirect3DVertexBuffer9* pStreamData, UINT OffsetInBytes, UINT Stride) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStreamSource(THIS_ UINT StreamNumber, IDirect3DVertexBuffer9** ppStreamData, UINT* pOffsetInBytes, UINT* pStride) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetStreamSourceFreq(THIS_ UINT StreamNumber, UINT Setting) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStreamSourceFreq(THIS_ UINT StreamNumber, UINT* pSetting) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetIndices(THIS_ IDirect3DIndexBuffer9* pIndexData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetIndices(THIS_ IDirect3DIndexBuffer9** ppIndexData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreatePixelShader(THIS_ CONST DWORD* pFunction, IDirect3DPixelShader9** ppShader) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPixelShader(THIS_ IDirect3DPixelShader9* pShader) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPixelShader(THIS_ IDirect3DPixelShader9** ppShader) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPixelShaderConstantF(THIS_ UINT StartRegister, CONST float* pConstantData, UINT Vector4fCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPixelShaderConstantF(THIS_ UINT StartRegister, float* pConstantData, UINT Vector4fCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPixelShaderConstantI(THIS_ UINT StartRegister, CONST int* pConstantData, UINT Vector4iCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPixelShaderConstantI(THIS_ UINT StartRegister, int* pConstantData, UINT Vector4iCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPixelShaderConstantB(THIS_ UINT StartRegister, CONST BOOL* pConstantData, UINT  BoolCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPixelShaderConstantB(THIS_ UINT StartRegister, BOOL* pConstantData, UINT BoolCount) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DrawRectPatch(THIS_ UINT Handle, CONST float* pNumSegs, CONST D3DRECTPATCH_INFO* pRectPatchInfo) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DrawTriPatch(THIS_ UINT Handle, CONST float* pNumSegs, CONST D3DTRIPATCH_INFO* pTriPatchInfo) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DeletePatch(THIS_ UINT Handle) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateQuery(THIS_ D3DQUERYTYPE Type, IDirect3DQuery9** ppQuery) override;

	// This is not an official D3D9 function, even though it looks like one. It is only used internally.
	COM_DECLSPEC_NOTHROW HRESULT CreateVertexDeclarationFromFVF(THIS_ CONST D3DVERTEXELEMENT9* pVertexElements, IDirect3DVertexDeclaration9** ppDecl, const debuggableFVF FVF);

	// If indexBuffer is NULL, then synthesize an index buffer (0, 1, 2, 3, 4, etc...)
	template <const bool useVertexBuffer, const bool useIndexBuffer>
	void ProcessVerticesToBuffer(const IDirect3DVertexDeclaration9Hook* const decl, const DeclarationSemanticMapping& mapping, const IDirect3DIndexBuffer9Hook* const indexBuffer, 
		const D3DPRIMITIVETYPE PrimitiveType, const INT BaseVertexIndex, const UINT MinVertexIndex, const UINT startIndex, const UINT primCount, const void* const vertStreamBytes, const unsigned short vertStreamStride) const;

	// If indexBuffer is NULL, then synthesize an index buffer (0, 1, 2, 3, 4, etc...)
	template <const bool useVertexBuffer, const D3DFORMAT indexFormat>
	void ProcessVerticesToBufferInner(const IDirect3DVertexDeclaration9Hook* const decl, const DeclarationSemanticMapping& mapping, const BYTE* const indexBuffer,
		const D3DPRIMITIVETYPE PrimitiveType, const INT BaseVertexIndex, const UINT MinVertexIndex, const UINT startIndex, const UINT primCount, const void* const vertStreamBytes, const unsigned short vertStreamStride) const;

	// Process a single vertex:
	template <const bool anyUserClipPlanesEnabled>
	void ProcessVertexToBuffer(const DeclarationSemanticMapping& mapping, VShaderEngine* const vertShader, VS_2_0_OutputRegisters* const outputVert, const unsigned vertexIndex) const;
	void LoadVertexInputElement(const DebuggableD3DVERTEXELEMENT9& element, const unsigned char* const dataPtr, const unsigned registerIndex, VShaderEngine* const vertShader) const;

#ifdef RUN_SHADERS_IN_WARPS
	// Process a quad of vertices:
	template <const bool anyUserClipPlanesEnabled>
	void ProcessVertexToBuffer4(const DeclarationSemanticMapping& mapping, VShaderEngine* const vertShader, VS_2_0_OutputRegisters* (&outputVerts)[4], const unsigned* const vertexIndex) const;
	void LoadVertexInputElement4(const DebuggableD3DVERTEXELEMENT9& element, const unsigned char* dataPtr[4], const unsigned registerIndex, VShaderEngine* const vertShader) const;
#endif // #ifdef RUN_SHADERS_IN_WARPS

	// void StoreVertexOutputElement(const DebuggableD3DVERTEXELEMENT9& element, unsigned char* const outputPtr, const D3DDECLUSAGE usage, const unsigned usageIndex) const;

	template <const bool useIndexBuffer, typename indexFormat, const bool rasterizerUsesEarlyZTest>
	void DrawPrimitiveUBPretransformedSkipVS(const D3DPRIMITIVETYPE PrimitiveType, INT BaseVertexIndex, UINT startIndex, UINT primCount) const;

	template <const bool rasterizerUsesEarlyZTest>
	void DrawPrimitiveUB(const D3DPRIMITIVETYPE PrimitiveType, const UINT PrimitiveCount) const;

	// Returns true for "should draw", or false for "should skip"
	const bool TotalDrawCallSkipTest(void) const;

	static const bool ShouldCullEntireTriangle(const VS_2_0_OutputRegisters& v0, const VS_2_0_OutputRegisters& v1, const VS_2_0_OutputRegisters& v2) ;
	static const bool ShouldCullEntireLine(const VS_2_0_OutputRegisters& v0, const VS_2_0_OutputRegisters& v1);
	static const bool ShouldCullEntirePoint(const VS_2_0_OutputRegisters& v0);

	// True if using FVF, false if using vertex declaration
	inline const bool IsUsingFVF(void) const { return currentState.declTarget == DeviceState::targetFVF; }

	// Returns true if either the FVF or the vertex declaration denotes that it contains pretransformed vertices
	const bool SkipVertexProcessing(void) const;

	inline DeviceState& GetCurrentHookState(void) 
	{ 
		return currentState;
	}

	inline const DeviceState& GetCurrentHookState(void) const
	{ 
		return currentState;
	}

	inline const DWORD OcclusionQuery_GetNumPixelsPassedZTest(void) const
	{
		return numPixelsPassedZTest;
	}

	// Called after device creation or Reset()
	void InitializeState(const D3DPRESENT_PARAMETERS& d3dpp, const D3DDEVTYPE devType, const DWORD createFlags, const HWND focusWindow);

	// Returns true if the device is currently inside of a BeginScene()/EndScene() block
	inline const bool HasBegunScene(void) const
	{
		return sceneBegun > 0;
	}

	// In the case of a successful render-target set, the viewport is automatically resized to the
	// size of the largest set render-target:
	void AutoResizeViewport(void);

	// Returns true if the currently set pipeline can do early-Z testing, or false if it cannot (false if depth isn't enabled, or no depth buffer is bound, or the pixel shader outputs depth)
	const bool CurrentPipelineCanEarlyZTest(void) const;

	// Assumes pre-transformed vertices from a vertex declaration + raw vertex stream
	void RasterizeLineFromStream(const DeclarationSemanticMapping& vertexDeclMapping, CONST BYTE* const v0, CONST BYTE* const v1) const;

	// Assumes pre-transformed vertex from a vertex declaration + raw vertex stream
	void RasterizePointFromStream(const DeclarationSemanticMapping& vertexDeclMapping, CONST BYTE* const v0) const;

	// Assumes pre-transformed vertices (from a processed vertex shader or from a vertex declaration + pretransformed vertex stream)
	template <const bool rasterizerUsesEarlyZTest, const bool shadeFromShader>
	void RasterizeTriangle(PShaderEngine* const pShaderEngine, const void* const mappingData, const void* const v0, const void* const v1, const void* const v2,
		const float fWidth, const float fHeight, const UINT primitiveID, const UINT vertex0index, const UINT vertex1index, const UINT vertex2index) const;

	// Assumes pre-transformed vertices from a processed vertex shader
	void RasterizeLineFromShader(const VStoPSMapping& vs_psMapping, const VS_2_0_OutputRegisters& v0, const VS_2_0_OutputRegisters& v1) const;

	// Assumes pre-transformed vertex from a processed vertex shader
	void RasterizePointFromShader(const VStoPSMapping& vs_psMapping, const VS_2_0_OutputRegisters& v0) const;

	// Handles pixel setup and depth and attribute interpolation before shading the pixel
	template <const bool setupFromShader>
	void SetupPixel(PShaderEngine* const pixelEngine, const void* const shaderOrStreamMapping, const unsigned x, const unsigned y, const __m128 barycentricInterpolants, 
		const UINT offsetBytesToOPosition, const void* const v0, const void* const v1, const void* const v2, const __m128 invZ, const __m128 invW) const;

	// Handles pixel quad setup and depth and attribute interpolation before shading the pixel quad
	template <const bool setupFromShader>
	void SetupPixel4(PShaderEngine* const pixelEngine, const void* const shaderOrStreamMapping, const __m128i x4, const __m128i y4, const __m128 (&barycentricInterpolants)[4], 
		const UINT offsetBytesToOPosition, const void* const v0, const void* const v1, const void* const v2, const __m128 invZ, const __m128 invW) const;

	// Handles blending and write-masking
	void RenderOutput(IDirect3DSurface9Hook* const outSurface, const unsigned x, const unsigned y, const D3DXVECTOR4& value) const;

	// Handles blending and write-masking
	template <const unsigned char pixelWriteMask>
	void RenderOutput4(IDirect3DSurface9Hook* const outSurface, const __m128i x4, const __m128i y4, const PS_2_0_OutputRegisters (&outputRegisters)[4], const unsigned char RTIndex) const;

	// Handles blending and write-masking
	template <const unsigned char channelWriteMask>
	void ROPBlendWriteMask(IDirect3DSurface9Hook* const outSurface, const unsigned x, const unsigned y, const D3DXVECTOR4& value) const;

	template <const unsigned char channelWriteMask>
	void ROPBlendWriteMask_AlphaBlendTest(IDirect3DSurface9Hook* const outSurface, const unsigned x, const unsigned y, const D3DXVECTOR4& value) const;

	template <const unsigned char channelWriteMask>
	void ROPBlendWriteMask_AlphaBlend(IDirect3DSurface9Hook* const outSurface, const unsigned x, const unsigned y, const D3DXVECTOR4& value) const;

	template <const unsigned char channelWriteMask>
	void ROPBlendWriteMask_NoAlphaBlend(IDirect3DSurface9Hook* const outSurface, const unsigned x, const unsigned y, const D3DXVECTOR4& value) const;

	// Handles blending and write-masking
	template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
	void ROPBlendWriteMask4(IDirect3DSurface9Hook* const outSurface, const __m128i x4, const __m128i y4, const PS_2_0_OutputRegisters (&outputRegisters)[4], const unsigned char RTIndex) const;

	template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
	void ROPBlendWriteMask4_AlphaBlendTest(IDirect3DSurface9Hook* const outSurface, const __m128i x4, const __m128i y4, const PS_2_0_OutputRegisters (&outputRegisters)[4], const unsigned char RTIndex) const;

	template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
	void ROPBlendWriteMask4_AlphaBlend(IDirect3DSurface9Hook* const outSurface, const __m128i x4, const __m128i y4, const PS_2_0_OutputRegisters (&outputRegisters)[4], const unsigned char RTIndex) const;

	template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
	void ROPBlendWriteMask4_NoAlphaBlend(IDirect3DSurface9Hook* const outSurface, const __m128i x4, const __m128i y4, const PS_2_0_OutputRegisters (&outputRegisters)[4], const unsigned char RTIndex) const;

	// Handles interpolating pixel shader input registers from a vertex declaration + raw vertex stream
	void InterpolateStreamIntoRegisters(PShaderEngine* const pixelShader, const DeclarationSemanticMapping& vertexDeclMapping, CONST BYTE* const v0, CONST BYTE* const v1, CONST BYTE* const v2, 
		const __m128 floatBarycentricsInvW_X, const __m128 floatBarycentricsInvW_Y, const __m128 floatBarycentricsInvW_Z, const __m128 barycentricInterpolants, const float interpolatedPixelW) const;

	// Handles interpolating pixel shader input registers from a vertex declaration + raw vertex stream
	template <const unsigned char pixelWriteMask>
	void InterpolateStreamIntoRegisters4(PShaderEngine* const pixelShader, const DeclarationSemanticMapping& vertexDeclMapping, CONST BYTE* const v0, CONST BYTE* const v1, CONST BYTE* const v2, 
		const __m128 floatBarycentricsInvW_X, const __m128 floatBarycentricsInvW_Y, const __m128 floatBarycentricsInvW_Z, const __m128 (&barycentricInterpolants)[4], const __m128 interpolatedPixelW4) const;

	// Handles interpolating pixel shader input registers from vertex shader output registers
	void InterpolateShaderIntoRegisters(PShaderEngine* const pixelShader, const VStoPSMapping& vs_psMapping, const VS_2_0_OutputRegisters& v0, const VS_2_0_OutputRegisters& v1, const VS_2_0_OutputRegisters& v2, 
		const __m128 floatBarycentricsInvW_X, const __m128 floatBarycentricsInvW_Y, const __m128 floatBarycentricsInvW_Z, const __m128 barycentricInterpolants, const float interpolatedPixelW) const;

	// Handles interpolating pixel shader input registers from vertex shader output registers
	template <const unsigned char pixelWriteMask>
	void InterpolateShaderIntoRegisters4(PShaderEngine* const pixelShader, const VStoPSMapping& vs_psMapping, const VS_2_0_OutputRegisters& v0, const VS_2_0_OutputRegisters& v1, const VS_2_0_OutputRegisters& v2, 
		const __m128 floatBarycentricsInvW_X, const __m128 floatBarycentricsInvW_Y, const __m128 floatBarycentricsInvW_Z, const __m128 (&barycentricInterpolants)[4], const __m128 interpolatedPixelW4) const;

	const float InterpolatePixelDepth(__m128 barycentricInterpolants, const __m128 invZ) const;
	void InterpolatePixelDepth4(const __m128 (&barycentricInterpolants4)[4], const __m128 invZ, __m128& outPixelDepth4) const;

	// Must be called before shading a pixel to reset the pixel shader state machine!
	void PreShadePixel(const unsigned x, const unsigned y, PShaderEngine* const pixelShader) const;

	// Must be called before shading a pixel to reset the pixel shader state machine!
	void PreShadePixel4(const __m128i x4, const __m128i y4, PShaderEngine* const pixelShader) const;

	void ShadePixel_FailStencil(const unsigned x, const unsigned y) const;
	void ShadePixel_FailDepth(const unsigned x, const unsigned y) const;
	void ShadePixel_RunShader(const unsigned x, const unsigned y, PShaderEngine* const pixelShader) const;
	void PostShadePixel_DiscardTest(const unsigned x, const unsigned y, const PS_2_0_OutputRegisters& pixelShaderOutput) const;
	void PostShadePixel_AlphaTest(const unsigned x, const unsigned y, const PS_2_0_OutputRegisters& pixelShaderOutput) const;
	void PostShadePixel_WriteOutput(const unsigned x, const unsigned y, const PS_2_0_OutputRegisters& pixelShaderOutput) const;
	void PostShadePixel_Discard(const unsigned x, const unsigned y) const;
	void PostShadePixel_FailAlphaTest(const unsigned x, const unsigned y) const;
	void PostShadePixel_WriteOutputColor(const unsigned x, const unsigned y, const PS_2_0_OutputRegisters& pixelOutputColor) const;
	void PostShadePixel_WriteOutputDepth(const unsigned x, const unsigned y, const float pixelOutputDepth) const;
	void PostShadePixel_WriteOutputStencil(const unsigned x, const unsigned y) const;

	template <const unsigned char pixelWriteMask>
	void ShadePixel4_FailStencil(const __m128i x4, const __m128i y4) const;

	template <const unsigned char pixelWriteMask>
	void ShadePixel4_FailDepth(const __m128i x4, const __m128i y4) const;

	template <const unsigned char pixelWriteMask>
	void ShadePixel4_RunShader(const __m128i x4, const __m128i y4, PShaderEngine* const pixelShader) const;

	template <const unsigned char pixelWriteMask>
	void PostShadePixel4_DiscardTest(const __m128i x4, const __m128i y4, PShaderEngine* const pixelShader) const;

	template <const unsigned char pixelWriteMask>
	void PostShadePixel4_AlphaTest(const __m128i x4, const __m128i y4, PShaderEngine* const pixelShader) const;

	template <const unsigned char pixelWriteMask>
	void PostShadePixel4_WriteOutput(const __m128i x4, const __m128i y4, PShaderEngine* const pixelShader) const;

	void PostShadePixel4_Discard(const unsigned char pixelDiscardMask) const;

	void PostShadePixel4_FailAlphaTest(const unsigned char pixelsFailAlphaTestMask) const;

	template <const unsigned char pixelWriteMask>
	void PostShadePixel4_WriteOutputColor(const __m128i x4, const __m128i y4, const PShaderEngine* const pixelShader) const;

	template <const unsigned char pixelWriteMask>
	void PostShadePixel4_WriteOutputDepth(const __m128i x4, const __m128i y4, const PShaderEngine* const pixelShader) const;

	template <const unsigned char pixelWriteMask>
	void PostShadePixel4_WriteOutputStencil(const __m128i x4, const __m128i y4) const;

	template <const unsigned char channelWriteMask>
	void LoadBlend(D3DXVECTOR4& outBlend, const D3DBLEND blendMode, const D3DXVECTOR4& srcColor, const D3DXVECTOR4& dstColor) const;

	template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
	void LoadBlend4(D3DXVECTOR4 (&outBlend)[4], const D3DBLEND blendMode, const D3DXVECTOR4 (&srcColor)[4], const D3DXVECTOR4 (&dstColor)[4]) const;

	template <const unsigned char channelWriteMask>
	void AlphaBlend(D3DXVECTOR4& outVec, const D3DBLENDOP blendOp, const D3DXVECTOR4& srcBlend, const D3DXVECTOR4& dstBlend, const D3DXVECTOR4& srcColor, const D3DXVECTOR4& dstColor) const;

	template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
	void AlphaBlend4(D3DXVECTOR4 (&outVec)[4], const D3DBLENDOP blendOp, const D3DXVECTOR4 (&srcBlend)[4], const D3DXVECTOR4 (&dstBlend)[4], const D3DXVECTOR4 (&srcColor)[4], const D3DXVECTOR4 (&dstColor)[4]) const;

	void InitVertexShader(const DeviceState& deviceState, const ShaderInfo& vertexShaderInfo) const;
	void InitPixelShader(const DeviceState& deviceState, const ShaderInfo& pixelShaderInfo) const;

#ifdef MULTITHREAD_SHADING
	void CreateNewVertexShadeJob(VS_2_0_OutputRegisters* const * const outputRegs, const unsigned* const vertexIndices, const workerJobType jobWidth) const;

#if TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS
	void CreateNewTriangleRasterJob(const UINT primitiveID, const UINT vertID0, const UINT vertID1, const UINT vertID2, const bool rasterizeFromShader, const void* const vert0, const void* const vert1, const void* const vert2) const;
#endif // #if TRIANGLEJOBS_OR_PIXELJOBS == TRIANGLEJOBS

#endif // #ifdef MULTITHREAD_SHADING

	void CreateNewPixelShadeJob(const unsigned x, const unsigned y, const __m128i barycentricAdjusted, const primitivePixelJobData* const primitiveData) const;
#ifdef RUN_SHADERS_IN_WARPS
	void CreateNewPixelShadeJob4(const __m128i x4, const __m128i y4, const __m128i (&barycentricsAdjusted4)[4], const primitivePixelJobData* const primitiveData) const;
#endif

	// TODO: Find another way to do this other than mutable
	mutable __declspec(align(16) ) primitivePixelJobData allPrimitiveJobData[1024 * 1024];

	template <const bool shadeFromShader>
	const primitivePixelJobData* const GetNewPrimitiveJobData(const void* const v0, const void* const v1, const void* const v2, const float barycentricNormalizeFactor, const UINT primitiveID, const bool VFace,
		const UINT vertex0index, const UINT vertex1index, const UINT vertex2index, const __m128 p0, const __m128 p1, const __m128 p2) const;

	// true = "pass" (draw the pixel), false = "fail" (discard the pixel)
	const bool StencilTestNoWrite(const unsigned x, const unsigned y) const;

	// true = "pass" (draw the pixel), false = "fail" (discard the pixel)
	// This MSDN page says that alpha testing only happens against the alpha value from oC0: https://docs.microsoft.com/en-us/windows/desktop/direct3d9/multiple-render-targets
	const bool AlphaTest(const D3DXVECTOR4& outColor) const;

	// Returns a SSE vector mask (0xFF for "test pass" and 0x00 for "test fail")
	// This MSDN page says that alpha testing only happens against the alpha value from oC0: https://docs.microsoft.com/en-us/windows/desktop/direct3d9/multiple-render-targets
	template <const unsigned char pixelWriteMask>
	const __m128 AlphaTest4(const PS_2_0_OutputRegisters (&outColor4)[4]) const;

#ifdef MULTITHREAD_SHADING
	void InitThreadQueue();
#endif

	void StencilOperation(const unsigned x, const unsigned y, const D3DSTENCILOP stencilOp) const;
	void StencilFailOperation(const unsigned x, const unsigned y) const;
	void StencilZFailOperation(const unsigned x, const unsigned y) const;
	void StencilPassOperation(const unsigned x, const unsigned y) const;

	void StencilOperation4(const __m128i x4, const __m128i y4, const D3DSTENCILOP stencilOp) const;
	void StencilFailOperation4(const __m128i x4, const __m128i y4) const;
	void StencilZFailOperation4(const __m128i x4, const __m128i y4) const;
	void StencilPassOperation4(const __m128i x4, const __m128i y4) const;

	void RecomputeCachedStreamEndsIfDirty();
	void RecomputeCachedStreamEndsForUP(const BYTE* const stream0Data, const unsigned numVertices, const USHORT vertexStride);

	void PreReset(void);

	COM_DECLSPEC_NOTHROW void SetupCurrentDrawCallVertexData(const DeclarationSemanticMapping& mapping);
	COM_DECLSPEC_NOTHROW void SetupCurrentDrawCallPixelData(const bool useShaderVerts, const void* const vs_to_ps_mapping) const;
	COM_DECLSPEC_NOTHROW void SetupCurrentDrawCallTriangleRasterizeData(const float fWidth, const float fHeight, const bool rasterizerUsesEarlyZTest, const bool rasterizeTriangleFromShader, const void* const interpolantDeclInfo) const;

	void ApplyViewportTransform(D3DXVECTOR4& positionT) const;

	COM_DECLSPEC_NOTHROW static void ModifyDeviceCaps(D3DCAPS9& caps);

	template <const bool anyUserClipPlanesEnabled>
	void ComputeVertexClipCodes(const D3DXVECTOR4& vertexPosition, VS_2_0_OutputRegisters* const shadedVertex) const;

#ifdef RUN_SHADERS_IN_WARPS
	void ApplyViewportTransform4(D3DXVECTOR4* (&positionT4)[4]) const;

	template <const bool anyUserClipPlanesEnabled>
	void ComputeVertexClipCodes4(const D3DXVECTOR4* (&vertexPosition4)[4], VS_2_0_OutputRegisters* const (&shadedVerts)[4]) const;
#endif // #ifdef RUN_SHADERS_IN_WARPS

	// Called from initial device creation and from device reset to modify the present params:
	static void ModifyPresentParameters(D3DPRESENT_PARAMETERS& inOutStruct);

	// This is not an official D3D9 function, even though it looks like one. It is only used internally.
	IDirect3DVertexDeclaration9Hook* CreateVertexDeclFromFVFCode(const debuggableFVF FVF);

	mutable DeviceFrameStats frameStats;

	currentDrawCallJobData currentDrawCallData;

	inline const bool IsCurrentlyRecordingStateBlock() const
	{
		return currentlyRecordingStateBlock != NULL;
	}

	_Acquires_lock_(&deviceCS) inline void LockDeviceCS(void)
	{
		EnterCriticalSection(&deviceCS);
	}

	_Releases_lock_(&deviceCS) inline void UnlockDeviceCS(void)
	{
		LeaveCriticalSection(&deviceCS);
	}

	inline const D3DPRESENT_PARAMETERS& GetInternalPresentParams() const
	{
		return currentPresentParams;
	}

protected:
	LPDIRECT3DDEVICE9 d3d9dev;
	IDirect3D9Hook* parentHook;
	unsigned __int64 refCount;

	// Flags outside of state blocks:
	BOOL sceneBegun;

	// These flags are not modified on device-reset:
	D3DDEVTYPE initialDevType;
	DWORD initialCreateFlags;
	HWND initialCreateFocusWindow;
	HWND initialCreateDeviceWindow;
	BOOL enableDialogs;

	D3DPRESENT_PARAMETERS currentPresentParams;

	mutable __declspec(align(16) ) VShaderEngine deviceMainVShaderEngine;
	mutable __declspec(align(16) ) PShaderEngine deviceMainPShaderEngine;
	mutable __declspec(align(16) ) VS_2_0_ConstantsBuffer vsDrawCallCB;
	mutable __declspec(align(16) ) PS_2_0_ConstantsBuffer psDrawCallCB;

#ifndef NO_CACHING_FVF_VERT_DECLS
	std::map<DWORD, IDirect3DVertexDeclaration9Hook*>* FVFToVertDeclCache;
#endif // NO_CACHING_FVF_VERT_DECLS

	__declspec(align(16) ) DeviceState currentState;

	IDirect3DStateBlock9Hook* currentlyRecordingStateBlock;

	BOOL currentSwvpEnabled; // Note that this parameter is not supposed to be recorded by State Blocks (which is why it's not inside the DeviceState struct)

	// This is the implicit swap chain:
	IDirect3DSwapChain9Hook* implicitSwapChain;

	// For debug-printing efficiently
	HANDLE hConsoleHandle;

	std::vector<unsigned>* alreadyShadedVerts32;
	std::vector<unsigned short>* alreadyShadedVerts16;

	// This is the data that gets directly consumed by occlusion queries (D3DQUERYTYPE_OCCLUSION).
	// Aligned and volatile here because this variable is accessed by multiple threads using Interlocked operations
	volatile __declspec(align(16) ) DWORD numPixelsPassedZTest;

	// Saving a pointer to a persistent buffer on the device here to avoid reallocation of output vertex buffers all the time
	mutable VS_2_0_OutputRegisters* processedVertexBuffer;
	mutable unsigned processedVertsUsed;
	mutable unsigned processVertsAllocated;

	CRITICAL_SECTION deviceCS;
};

static const __m128 ColorDWORDToFloat4Divisor = { 1.0f / 255.0f, 1.0f / 255.0f, 1.0f / 255.0f, 1.0f / 255.0f };

template <const unsigned char writeMask = 0xF>
inline void ColorDWORDToFloat4(const D3DCOLOR inColor, D3DXVECTOR4& outColor)
{
	const __m128i colorbyte4 = _mm_castps_si128(_mm_load_ss( (const float* const)&inColor) );
	const __m128i coloruint4 = _mm_cvtepu8_epi32(colorbyte4);
	const __m128 colorfloat4 = _mm_cvtepi32_ps(coloruint4);
	const __m128 normalizedColorFloat4 = _mm_mul_ps(colorfloat4, ColorDWORDToFloat4Divisor);

	// Swizzle from ARGB -> RGBA
	const __m128 swizzledColorFloat4 = _mm_shuffle_ps(normalizedColorFloat4, normalizedColorFloat4, _MM_SHUFFLE(3, 0, 1, 2) );

	if (writeMask == 0xF)
	{
		*( (__m128* const)&outColor) = swizzledColorFloat4;
	}
	else
	{
		if (writeMask & 0x1)
			outColor.x = swizzledColorFloat4.m128_f32[0];
		if (writeMask & 0x2)
			outColor.y = swizzledColorFloat4.m128_f32[1];
		if (writeMask & 0x4)
			outColor.z = swizzledColorFloat4.m128_f32[2];
		if (writeMask & 0x8)
			outColor.w = swizzledColorFloat4.m128_f32[3];
	}
}

template <const unsigned char writeMask = 0xF>
inline void ColorDWORDToFloat4_4(const D3DCOLOR* const * const inColor4, D3DXVECTOR4* const outColor4[4])
{
	const __m128i colorbyte4[4] = 
	{
		_mm_castps_si128(_mm_load_ss( (const float* const)inColor4[0]) ),
		_mm_castps_si128(_mm_load_ss( (const float* const)inColor4[1]) ),
		_mm_castps_si128(_mm_load_ss( (const float* const)inColor4[2]) ),
		_mm_castps_si128(_mm_load_ss( (const float* const)inColor4[3]) )
	};

	const __m128i coloruint4[4] = 
	{
		_mm_cvtepu8_epi32(colorbyte4[0]),
		_mm_cvtepu8_epi32(colorbyte4[1]),
		_mm_cvtepu8_epi32(colorbyte4[2]),
		_mm_cvtepu8_epi32(colorbyte4[3])
	};

	const __m128 colorfloat4[4] = 
	{
		_mm_cvtepi32_ps(coloruint4[0]),
		_mm_cvtepi32_ps(coloruint4[1]),
		_mm_cvtepi32_ps(coloruint4[2]),
		_mm_cvtepi32_ps(coloruint4[3])
	};

	const __m128 normalizedColorFloat4[4] = 
	{
		_mm_mul_ps(colorfloat4[0], ColorDWORDToFloat4Divisor),
		_mm_mul_ps(colorfloat4[1], ColorDWORDToFloat4Divisor),
		_mm_mul_ps(colorfloat4[2], ColorDWORDToFloat4Divisor),
		_mm_mul_ps(colorfloat4[3], ColorDWORDToFloat4Divisor)
	};

	// Swizzle from RGBA -> ARGB
	const __m128 swizzledColorFloat4[4] =
	{
		_mm_shuffle_ps(normalizedColorFloat4[0], normalizedColorFloat4[0], _MM_SHUFFLE(3, 0, 1, 2) ),
		_mm_shuffle_ps(normalizedColorFloat4[1], normalizedColorFloat4[1], _MM_SHUFFLE(3, 0, 1, 2) ),
		_mm_shuffle_ps(normalizedColorFloat4[2], normalizedColorFloat4[2], _MM_SHUFFLE(3, 0, 1, 2) ),
		_mm_shuffle_ps(normalizedColorFloat4[3], normalizedColorFloat4[3], _MM_SHUFFLE(3, 0, 1, 2) )
	};

	if (writeMask == 0xF)
	{
		*(__m128* const)outColor4[0] = swizzledColorFloat4[0];
		*(__m128* const)outColor4[1] = swizzledColorFloat4[1];
		*(__m128* const)outColor4[2] = swizzledColorFloat4[2];
		*(__m128* const)outColor4[3] = swizzledColorFloat4[3];
	}
	else
	{
		if (writeMask & 0x1)
		{
			outColor4[0]->x = swizzledColorFloat4[0].m128_f32[0];
			outColor4[1]->x = swizzledColorFloat4[1].m128_f32[0];
			outColor4[2]->x = swizzledColorFloat4[2].m128_f32[0];
			outColor4[3]->x = swizzledColorFloat4[3].m128_f32[0];
		}
		if (writeMask & 0x2)
		{
			outColor4[0]->y = swizzledColorFloat4[0].m128_f32[1];
			outColor4[1]->y = swizzledColorFloat4[1].m128_f32[1];
			outColor4[2]->y = swizzledColorFloat4[2].m128_f32[1];
			outColor4[3]->y = swizzledColorFloat4[3].m128_f32[1];
		}
		if (writeMask & 0x4)
		{
			outColor4[0]->z = swizzledColorFloat4[0].m128_f32[2];
			outColor4[1]->z = swizzledColorFloat4[1].m128_f32[2];
			outColor4[2]->z = swizzledColorFloat4[2].m128_f32[2];
			outColor4[3]->z = swizzledColorFloat4[3].m128_f32[2];
		}
		if (writeMask & 0x8)
		{
			outColor4[0]->w = swizzledColorFloat4[0].m128_f32[3];
			outColor4[1]->w = swizzledColorFloat4[1].m128_f32[3];
			outColor4[2]->w = swizzledColorFloat4[2].m128_f32[3];
			outColor4[3]->w = swizzledColorFloat4[3].m128_f32[3];
		}
	}
}

template <const unsigned char writeMask = 0xF>
inline void ColorDWORDToFloat4_4(const D3DCOLOR (&inColor4)[4], D3DXVECTOR4 (&outColor4)[4])
{
	const __m128i inColor4vec = *(const __m128i* const)inColor4;

	const __m128i colorbyte4[4] = 
	{
		_mm_shuffle_epi32(inColor4vec, _MM_SHUFFLE(0, 0, 0, 0) ),
		_mm_shuffle_epi32(inColor4vec, _MM_SHUFFLE(1, 1, 1, 1) ),
		_mm_shuffle_epi32(inColor4vec, _MM_SHUFFLE(2, 2, 2, 2) ),
		_mm_shuffle_epi32(inColor4vec, _MM_SHUFFLE(3, 3, 3, 3) )
	};

	const __m128i coloruint4[4] = 
	{
		_mm_cvtepu8_epi32(colorbyte4[0]),
		_mm_cvtepu8_epi32(colorbyte4[1]),
		_mm_cvtepu8_epi32(colorbyte4[2]),
		_mm_cvtepu8_epi32(colorbyte4[3])
	};

	const __m128 colorfloat4[4] = 
	{
		_mm_cvtepi32_ps(coloruint4[0]),
		_mm_cvtepi32_ps(coloruint4[1]),
		_mm_cvtepi32_ps(coloruint4[2]),
		_mm_cvtepi32_ps(coloruint4[3])
	};

	const __m128 normalizedColorFloat4[4] = 
	{
		_mm_mul_ps(colorfloat4[0], ColorDWORDToFloat4Divisor),
		_mm_mul_ps(colorfloat4[1], ColorDWORDToFloat4Divisor),
		_mm_mul_ps(colorfloat4[2], ColorDWORDToFloat4Divisor),
		_mm_mul_ps(colorfloat4[3], ColorDWORDToFloat4Divisor)
	};

	// Swizzle from RGBA -> ARGB
	const __m128 swizzledColorFloat4[4] =
	{
		_mm_shuffle_ps(normalizedColorFloat4[0], normalizedColorFloat4[0], _MM_SHUFFLE(3, 0, 1, 2) ),
		_mm_shuffle_ps(normalizedColorFloat4[1], normalizedColorFloat4[1], _MM_SHUFFLE(3, 0, 1, 2) ),
		_mm_shuffle_ps(normalizedColorFloat4[2], normalizedColorFloat4[2], _MM_SHUFFLE(3, 0, 1, 2) ),
		_mm_shuffle_ps(normalizedColorFloat4[3], normalizedColorFloat4[3], _MM_SHUFFLE(3, 0, 1, 2) )
	};

	if (writeMask == 0xF)
	{
		*( (__m128* const)&(outColor4[0]) ) = swizzledColorFloat4[0];
		*( (__m128* const)&(outColor4[1]) ) = swizzledColorFloat4[1];
		*( (__m128* const)&(outColor4[2]) ) = swizzledColorFloat4[2];
		*( (__m128* const)&(outColor4[3]) ) = swizzledColorFloat4[3];
	}
	else
	{
		if (writeMask & 0x1)
		{
			outColor4[0].x = swizzledColorFloat4[0].m128_f32[0];
			outColor4[1].x = swizzledColorFloat4[1].m128_f32[0];
			outColor4[2].x = swizzledColorFloat4[2].m128_f32[0];
			outColor4[3].x = swizzledColorFloat4[3].m128_f32[0];
		}
		if (writeMask & 0x2)
		{
			outColor4[0].y = swizzledColorFloat4[0].m128_f32[1];
			outColor4[1].y = swizzledColorFloat4[1].m128_f32[1];
			outColor4[2].y = swizzledColorFloat4[2].m128_f32[1];
			outColor4[3].y = swizzledColorFloat4[3].m128_f32[1];
		}
		if (writeMask & 0x4)
		{
			outColor4[0].z = swizzledColorFloat4[0].m128_f32[2];
			outColor4[1].z = swizzledColorFloat4[1].m128_f32[2];
			outColor4[2].z = swizzledColorFloat4[2].m128_f32[2];
			outColor4[3].z = swizzledColorFloat4[3].m128_f32[2];
		}
		if (writeMask & 0x8)
		{
			outColor4[0].w = swizzledColorFloat4[0].m128_f32[3];
			outColor4[1].w = swizzledColorFloat4[1].m128_f32[3];
			outColor4[2].w = swizzledColorFloat4[2].m128_f32[3];
			outColor4[3].w = swizzledColorFloat4[3].m128_f32[3];
		}
	}
}

template <const unsigned char writeMask = 0xF>
inline void ColorDWORDToFloat4_4(const __m128i inColor4Vec, D3DXVECTOR4 (&outColor4)[4])
{
	const __m128i colorbyte4[4] = 
	{
		_mm_shuffle_epi32(inColor4Vec, _MM_SHUFFLE(0, 0, 0, 0) ),
		_mm_shuffle_epi32(inColor4Vec, _MM_SHUFFLE(1, 1, 1, 1) ),
		_mm_shuffle_epi32(inColor4Vec, _MM_SHUFFLE(2, 2, 2, 2) ),
		_mm_shuffle_epi32(inColor4Vec, _MM_SHUFFLE(3, 3, 3, 3) )
	};

	const __m128i coloruint4[4] = 
	{
		_mm_cvtepu8_epi32(colorbyte4[0]),
		_mm_cvtepu8_epi32(colorbyte4[1]),
		_mm_cvtepu8_epi32(colorbyte4[2]),
		_mm_cvtepu8_epi32(colorbyte4[3])
	};

	const __m128 colorfloat4[4] = 
	{
		_mm_cvtepi32_ps(coloruint4[0]),
		_mm_cvtepi32_ps(coloruint4[1]),
		_mm_cvtepi32_ps(coloruint4[2]),
		_mm_cvtepi32_ps(coloruint4[3])
	};

	const __m128 normalizedColorFloat4[4] = 
	{
		_mm_mul_ps(colorfloat4[0], ColorDWORDToFloat4Divisor),
		_mm_mul_ps(colorfloat4[1], ColorDWORDToFloat4Divisor),
		_mm_mul_ps(colorfloat4[2], ColorDWORDToFloat4Divisor),
		_mm_mul_ps(colorfloat4[3], ColorDWORDToFloat4Divisor)
	};

	// Swizzle from RGBA -> ARGB
	const __m128 swizzledColorFloat4[4] =
	{
		_mm_shuffle_ps(normalizedColorFloat4[0], normalizedColorFloat4[0], _MM_SHUFFLE(3, 0, 1, 2) ),
		_mm_shuffle_ps(normalizedColorFloat4[1], normalizedColorFloat4[1], _MM_SHUFFLE(3, 0, 1, 2) ),
		_mm_shuffle_ps(normalizedColorFloat4[2], normalizedColorFloat4[2], _MM_SHUFFLE(3, 0, 1, 2) ),
		_mm_shuffle_ps(normalizedColorFloat4[3], normalizedColorFloat4[3], _MM_SHUFFLE(3, 0, 1, 2) )
	};

	if (writeMask == 0xF)
	{
		*( (__m128* const)&(outColor4[0]) ) = swizzledColorFloat4[0];
		*( (__m128* const)&(outColor4[1]) ) = swizzledColorFloat4[1];
		*( (__m128* const)&(outColor4[2]) ) = swizzledColorFloat4[2];
		*( (__m128* const)&(outColor4[3]) ) = swizzledColorFloat4[3];
	}
	else
	{
		if (writeMask & 0x1)
		{
			outColor4[0].x = swizzledColorFloat4[0].m128_f32[0];
			outColor4[1].x = swizzledColorFloat4[1].m128_f32[0];
			outColor4[2].x = swizzledColorFloat4[2].m128_f32[0];
			outColor4[3].x = swizzledColorFloat4[3].m128_f32[0];
		}
		if (writeMask & 0x2)
		{
			outColor4[0].y = swizzledColorFloat4[0].m128_f32[1];
			outColor4[1].y = swizzledColorFloat4[1].m128_f32[1];
			outColor4[2].y = swizzledColorFloat4[2].m128_f32[1];
			outColor4[3].y = swizzledColorFloat4[3].m128_f32[1];
		}
		if (writeMask & 0x4)
		{
			outColor4[0].z = swizzledColorFloat4[0].m128_f32[2];
			outColor4[1].z = swizzledColorFloat4[1].m128_f32[2];
			outColor4[2].z = swizzledColorFloat4[2].m128_f32[2];
			outColor4[3].z = swizzledColorFloat4[3].m128_f32[2];
		}
		if (writeMask & 0x8)
		{
			outColor4[0].w = swizzledColorFloat4[0].m128_f32[3];
			outColor4[1].w = swizzledColorFloat4[1].m128_f32[3];
			outColor4[2].w = swizzledColorFloat4[2].m128_f32[3];
			outColor4[3].w = swizzledColorFloat4[3].m128_f32[3];
		}
	}
}

inline const D3DCOLOR Expand565To888(const RGB565 inColor)
{
	// TODO: Should alpha be 0.0f or 1.0f here?
	const float scaledR = inColor.bits565.r / 31.0f;
	const float scaledG = inColor.bits565.g / 63.0f;
	const float scaledB = inColor.bits565.b / 31.0f;
	const unsigned char r8 = (const unsigned char)(scaledR * 255.0f);
	const unsigned char g8 = (const unsigned char)(scaledG * 255.0f);
	const unsigned char b8 = (const unsigned char)(scaledB * 255.0f);
	return D3DCOLOR_ARGB(255, r8, g8, b8);
}

inline const D3DCOLOR Expand4444To8888(const A4R4G4B4 inColor)
{
	return D3DCOLOR_ARGB(inColor.bits4444.a * 17, inColor.bits4444.r * 17, 
		inColor.bits4444.g * 17, inColor.bits4444.b * 17);
}

inline const D3DCOLOR Expand4440To8888(const X4R4G4B4 inColor)
{
	// TODO: Should alpha be 0.0f or 1.0f here?
	return D3DCOLOR_ARGB(255, inColor.bits4440.r * 17, 
		inColor.bits4440.g * 17, inColor.bits4440.b * 17);
}

template <const unsigned char writeMask = 0xF>
inline void ColorA4R4G4B4ToFloat4(const A4R4G4B4 inColor, D3DXVECTOR4& outColor)
{
	const D3DCOLOR expandedColor8888 = Expand4444To8888(inColor);
	ColorDWORDToFloat4(expandedColor8888, outColor);
}

template <const unsigned char writeMask = 0xF>
inline void ColorX4R4G4B4ToFloat4(const X4R4G4B4 inColor, D3DXVECTOR4& outColor)
{
	const D3DCOLOR expandedColor8888 = Expand4440To8888(inColor);
	ColorDWORDToFloat4(expandedColor8888, outColor);
}

template <const unsigned char writeMask = 0xF>
inline void ColorRGB565ToFloat4(const RGB565 inColor, D3DXVECTOR4& outColor)
{
	const D3DCOLOR expandedColor888 = Expand565To888(inColor);
	ColorDWORDToFloat4(expandedColor888, outColor);
}

template <const unsigned char writeMask = 0xF>
inline const D3DCOLOR Float4ToD3DCOLOR(const D3DXVECTOR4& color)
{
	const unsigned r = writeMask & 0x1 ? ( (const unsigned)(color.x * 255.0f) ) : 0;
	const unsigned g = writeMask & 0x2 ? ( (const unsigned)(color.y * 255.0f) ) : 0;
	const unsigned b = writeMask & 0x4 ? ( (const unsigned)(color.z * 255.0f) ) : 0;
	const unsigned a = writeMask & 0x8 ? ( (const unsigned)(color.w * 255.0f) ) : 0;
	const D3DCOLOR ldrColor = D3DCOLOR_ARGB(a, r, g, b);
	return ldrColor;
}

static const __m128i byteEPI32VecToD3DCOLOR_PSHUFB[16] = 
{
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), // 0x0
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1), // 0x1
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1), // 0x2
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, -1), // 0x3
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8), // 0x4
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, 8), // 0x5
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8), // 0x6
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 8), // 0x7
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, -1), // 0x8
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 0, -1, -1), // 0x9
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, 4, -1), // 0xA
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 0, 4, -1), // 0xB
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, 8), // 0xC
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 0, -1, 8), // 0xD
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, 4, 8), // 0xE
	_mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 0, 4, 8) // 0xF
};
static const __m128 saturateMax = { 1.0f, 1.0f, 1.0f, 1.0f };
static const __m128 scaleMax = { 255.0f, 255.0f, 255.0f, 255.0f };
template <const unsigned char writeMask = 0xF>
inline const D3DCOLOR Float4ToD3DCOLORClamp(const D3DXVECTOR4& color)
{
	const __m128 float4color = *(const __m128* const)&color;
	
	const __m128 float4colorClamped = _mm_min_ps(float4color, saturateMax);
	const __m128 float4colorExpanded = _mm_mul_ps(float4colorClamped, scaleMax);

	const __m128i dword4color = _mm_cvtps_epi32(float4colorExpanded);

	const __m128i shuffledD3DCOLOR = _mm_shuffle_epi8(dword4color, byteEPI32VecToD3DCOLOR_PSHUFB[writeMask]);
	return shuffledD3DCOLOR.m128i_u32[0];
}

template <const unsigned char writeMask = 0xF>
inline const D3DCOLOR Float4ToX8R8G8B8Clamp(const D3DXVECTOR4& color)
{
	return Float4ToD3DCOLORClamp<writeMask & 0x7>(color);
}

template <const unsigned char channelWriteMask = 0xF, const unsigned char pixelWriteMask>
inline void Float4ToD3DCOLOR4Clamp4(const D3DXVECTOR4 (&color4)[4], const __m128i outColorAddresses4)
{
	if (pixelWriteMask == 0)
	{
#ifdef _DEBUG
		__debugbreak(); // Shouldn't be executing this code if we're not going to write anything out
#endif
		return;
	}

	const __m128 (&float4color4)[4] =
	{
		*(const __m128* const)&color4[0],
		*(const __m128* const)&color4[1],
		*(const __m128* const)&color4[2],
		*(const __m128* const)&color4[3]
	};

	const __m128 float4colorClamped4[4] = 
	{
		_mm_min_ps(float4color4[0], saturateMax),
		_mm_min_ps(float4color4[1], saturateMax),
		_mm_min_ps(float4color4[2], saturateMax),
		_mm_min_ps(float4color4[3], saturateMax)
	};

	const __m128 float4colorExpanded4[4] =
	{
		_mm_mul_ps(float4colorClamped4[0], scaleMax),
		_mm_mul_ps(float4colorClamped4[1], scaleMax),
		_mm_mul_ps(float4colorClamped4[2], scaleMax),
		_mm_mul_ps(float4colorClamped4[3], scaleMax)
	};

	const __m128i dword4color4[4] =
	{
		_mm_cvtps_epi32(float4colorExpanded4[0]),
		_mm_cvtps_epi32(float4colorExpanded4[1]),
		_mm_cvtps_epi32(float4colorExpanded4[2]),
		_mm_cvtps_epi32(float4colorExpanded4[3])
	};

	const __m128i shuffledD3DCOLOR4[4] = 
	{
		_mm_shuffle_epi8(dword4color4[0], byteEPI32VecToD3DCOLOR_PSHUFB[channelWriteMask]),
		_mm_shuffle_epi8(dword4color4[1], byteEPI32VecToD3DCOLOR_PSHUFB[channelWriteMask]),
		_mm_shuffle_epi8(dword4color4[2], byteEPI32VecToD3DCOLOR_PSHUFB[channelWriteMask]),
		_mm_shuffle_epi8(dword4color4[3], byteEPI32VecToD3DCOLOR_PSHUFB[channelWriteMask])
	};

	if (pixelWriteMask & 0x1)
		*(D3DCOLOR* const)outColorAddresses4.m128i_u32[0] = shuffledD3DCOLOR4[0].m128i_u32[0];
	if (pixelWriteMask & 0x2)
		*(D3DCOLOR* const)outColorAddresses4.m128i_u32[1] = shuffledD3DCOLOR4[1].m128i_u32[0];
	if (pixelWriteMask & 0x4)
		*(D3DCOLOR* const)outColorAddresses4.m128i_u32[2] = shuffledD3DCOLOR4[2].m128i_u32[0];
	if (pixelWriteMask & 0x8)
		*(D3DCOLOR* const)outColorAddresses4.m128i_u32[3] = shuffledD3DCOLOR4[3].m128i_u32[0];
}

template <const unsigned char channelWriteMask = 0xF, const unsigned char pixelWriteMask>
inline void Float4ToX8R8G8B8_4Clamp4(const D3DXVECTOR4 (&color4)[4], const __m128i outColorAddresses4)
{
	if (pixelWriteMask == 0)
	{
#ifdef _DEBUG
		__debugbreak(); // Shouldn't be executing this code if we're not going to write anything out
#endif
		return;
	}

	Float4ToD3DCOLOR4Clamp4<channelWriteMask & 0x7, pixelWriteMask>(color4, outColorAddresses4);
}

struct A16B16G16R16
{
	unsigned short r;
	unsigned short g;
	unsigned short b;
	unsigned short a;
};

struct A16B16G16R16F
{
	D3DXFLOAT16 r;
	D3DXFLOAT16 g;
	D3DXFLOAT16 b;
	D3DXFLOAT16 a;
};

struct A32B32G32R32F
{
	float r;
	float g;
	float b;
	float a;
};

template <const unsigned char writeMask = 0xF>
inline void Float4ToA16B16G16R16(const D3DXVECTOR4& color, A16B16G16R16& outColor)
{
	// TODO: Vectorize this
	if (writeMask & 0x1)
	{
		if (color.x > 1.0f)
			outColor.r = 0xFFFF;
		else if (color.x < 0.0f)
			outColor.r = 0x0000;
		else
			outColor.r = (const unsigned short)(color.x * 65535.0f);
	}

	if (writeMask & 0x2)
	{
		if (color.y > 1.0f)
			outColor.g = 0xFFFF;
		else if (color.y < 0.0f)
			outColor.g = 0x0000;
		else
			outColor.g = (const unsigned short)(color.y * 65535.0f);
	}

	if (writeMask & 0x4)
	{
		if (color.z > 1.0f)
			outColor.b = 0xFFFF;
		else if (color.z < 0.0f)
			outColor.b = 0x0000;
		else
			outColor.b = (const unsigned short)(color.z * 65535.0f);
	}

	if (writeMask & 0x8)
	{
		if (color.w > 1.0f)
			outColor.a = 0xFFFF;
		else if (color.w < 0.0f)
			outColor.a = 0x0000;
		else
			outColor.a = (const unsigned short)(color.w * 65535.0f);
	}
}

template <const unsigned char writeMask = 0xF, const unsigned char pixelWriteMask>
inline void Float4ToA16B16G16R16_4(const D3DXVECTOR4 (&color)[4], const __m128i outColorAddresses)
{
	if (pixelWriteMask == 0)
	{
#ifdef _DEBUG
		__debugbreak(); // Don't call this if you're not going to write anything!
#endif
		return;
	}

	// TODO: Vectorize this
	for (unsigned x = 0; x < 4; ++x)
	{
		if (pixelWriteMask & (1 << x) )
			Float4ToA16B16G16R16<writeMask>(color[x], *(A16B16G16R16* const)outColorAddresses.m128i_u32[x]);
	}
}

static const __m128 ColorA16B16G16R16ToFloat4Divisor = { 1.0f / 65535.0f, 1.0f / 65535.0f, 1.0f / 65535.0f, 1.0f / 65535.0f };

template <const unsigned char writeMask = 0xF>
inline void ColorA16B16G16R16ToFloat4(const A16B16G16R16& color, D3DXVECTOR4& outColor)
{
	__m128i colorushort4;
	colorushort4.m128i_u16[0] = color.r;
	colorushort4.m128i_u16[1] = color.g;
	colorushort4.m128i_u16[2] = color.b;
	colorushort4.m128i_u16[3] = color.a;

	const __m128i coloruint4 = _mm_cvtepu16_epi32(colorushort4);
	const __m128 colorfloat4 = _mm_cvtepi32_ps(coloruint4);
	const __m128 normalizedColorFloat4 = _mm_mul_ps(colorfloat4, ColorA16B16G16R16ToFloat4Divisor);
	if (writeMask & 0x1)
		outColor.x = normalizedColorFloat4.m128_f32[0];
	if (writeMask & 0x2)
		outColor.y = normalizedColorFloat4.m128_f32[1];
	if (writeMask & 0x4)
		outColor.z = normalizedColorFloat4.m128_f32[2];
	if (writeMask & 0x8)
		outColor.w = normalizedColorFloat4.m128_f32[3];
}

template <const unsigned char writeMask = 0xF>
inline void ColorA16B16G16R16ToFloat4_4(const A16B16G16R16 (&color4)[4], D3DXVECTOR4 (&outColor4)[4])
{
	__m128i colorushort4_4[4];
	colorushort4_4[0].m128i_u16[0] = color4[0].r;
	colorushort4_4[0].m128i_u16[1] = color4[0].g;
	colorushort4_4[0].m128i_u16[2] = color4[0].b;
	colorushort4_4[0].m128i_u16[3] = color4[0].a;
	colorushort4_4[1].m128i_u16[0] = color4[1].r;
	colorushort4_4[1].m128i_u16[1] = color4[1].g;
	colorushort4_4[1].m128i_u16[2] = color4[1].b;
	colorushort4_4[1].m128i_u16[3] = color4[1].a;
	colorushort4_4[2].m128i_u16[0] = color4[2].r;
	colorushort4_4[2].m128i_u16[1] = color4[2].g;
	colorushort4_4[2].m128i_u16[2] = color4[2].b;
	colorushort4_4[2].m128i_u16[3] = color4[2].a;
	colorushort4_4[3].m128i_u16[0] = color4[3].r;
	colorushort4_4[3].m128i_u16[1] = color4[3].g;
	colorushort4_4[3].m128i_u16[2] = color4[3].b;
	colorushort4_4[3].m128i_u16[3] = color4[3].a;

	const __m128i coloruint4_4[4] = 
	{
		_mm_cvtepu16_epi32(colorushort4_4[0]),
		_mm_cvtepu16_epi32(colorushort4_4[1]),
		_mm_cvtepu16_epi32(colorushort4_4[2]),
		_mm_cvtepu16_epi32(colorushort4_4[3])
	};

	const __m128 colorfloat4_4[4] = 
	{
		_mm_cvtepi32_ps(coloruint4_4[0]),
		_mm_cvtepi32_ps(coloruint4_4[1]),
		_mm_cvtepi32_ps(coloruint4_4[2]),
		_mm_cvtepi32_ps(coloruint4_4[3])
	};

	const __m128 normalizedColorFloat4_4[4] = 
	{
		_mm_mul_ps(colorfloat4_4[0], ColorA16B16G16R16ToFloat4Divisor),
		_mm_mul_ps(colorfloat4_4[1], ColorA16B16G16R16ToFloat4Divisor),
		_mm_mul_ps(colorfloat4_4[2], ColorA16B16G16R16ToFloat4Divisor),
		_mm_mul_ps(colorfloat4_4[3], ColorA16B16G16R16ToFloat4Divisor)
	};

	if (writeMask & 0x1)
	{
		outColor4[0].x = normalizedColorFloat4_4[0].m128_f32[0];
		outColor4[1].x = normalizedColorFloat4_4[1].m128_f32[0];
		outColor4[2].x = normalizedColorFloat4_4[2].m128_f32[0];
		outColor4[3].x = normalizedColorFloat4_4[3].m128_f32[0];
	}
	if (writeMask & 0x2)
	{
		outColor4[0].y = normalizedColorFloat4_4[0].m128_f32[1];
		outColor4[1].y = normalizedColorFloat4_4[1].m128_f32[1];
		outColor4[2].y = normalizedColorFloat4_4[2].m128_f32[1];
		outColor4[3].y = normalizedColorFloat4_4[3].m128_f32[1];
	}
	if (writeMask & 0x4)
	{
		outColor4[0].z = normalizedColorFloat4_4[0].m128_f32[2];
		outColor4[1].z = normalizedColorFloat4_4[1].m128_f32[2];
		outColor4[2].z = normalizedColorFloat4_4[2].m128_f32[2];
		outColor4[3].z = normalizedColorFloat4_4[3].m128_f32[2];
	}
	if (writeMask & 0x8)
	{
		outColor4[0].w = normalizedColorFloat4_4[0].m128_f32[3];
		outColor4[1].w = normalizedColorFloat4_4[1].m128_f32[3];
		outColor4[2].w = normalizedColorFloat4_4[2].m128_f32[3];
		outColor4[3].w = normalizedColorFloat4_4[3].m128_f32[3];
	}
}

template <const unsigned char writeMask = 0xF>
inline void Float4ToA16B16G16R16F(const D3DXVECTOR4& color, A16B16G16R16F& outColor)
{
	const __m128 float4Color = *(const __m128* const)&color;
	
	// Floating point rules specify round-to-nearest as the rounding mode for float16's: https://docs.microsoft.com/en-us/windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-float-rules
	const __m128i half4Color = _mm_cvtps_ph(float4Color, _MM_FROUND_TO_NEAREST_INT);

	if (writeMask & 0x1)
		outColor.r = *(const D3DXFLOAT16* const)&(half4Color.m128i_u16[0]);
	if (writeMask & 0x2)
		outColor.g = *(const D3DXFLOAT16* const)&(half4Color.m128i_u16[1]);
	if (writeMask & 0x4)
		outColor.b = *(const D3DXFLOAT16* const)&(half4Color.m128i_u16[2]);
	if (writeMask & 0x8)
		outColor.a = *(const D3DXFLOAT16* const)&(half4Color.m128i_u16[3]);
}

template <const unsigned char channelWriteMask = 0xF, const unsigned char pixelWriteMask = 0xF>
inline void Float4ToA16B16G16R16F4(const D3DXVECTOR4 (&color)[4], const __m128i outColorAddresses4)
{
	if (pixelWriteMask == 0)
	{
#ifdef _DEBUG
		__debugbreak(); // Don't call this function if you're not going to write anything out!
#endif
		return;
	}

	const __m128 float4Color4[4] = 
	{
		*(const __m128* const)&color[0],
		*(const __m128* const)&color[1],
		*(const __m128* const)&color[2],
		*(const __m128* const)&color[3]
	};
	
	// Floating point rules specify round-to-nearest as the rounding mode for float16's: https://docs.microsoft.com/en-us/windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-float-rules
	const __m128i half4Color4[4] = 
	{
		_mm_cvtps_ph(float4Color4[0], _MM_FROUND_TO_NEAREST_INT),
		_mm_cvtps_ph(float4Color4[1], _MM_FROUND_TO_NEAREST_INT),
		_mm_cvtps_ph(float4Color4[2], _MM_FROUND_TO_NEAREST_INT),
		_mm_cvtps_ph(float4Color4[3], _MM_FROUND_TO_NEAREST_INT)
	};

	D3DXFLOAT16* const writeAddresses[4] =
	{
		(D3DXFLOAT16* const)outColorAddresses4.m128i_u32[0],
		(D3DXFLOAT16* const)outColorAddresses4.m128i_u32[1],
		(D3DXFLOAT16* const)outColorAddresses4.m128i_u32[2],
		(D3DXFLOAT16* const)outColorAddresses4.m128i_u32[3]
	};

	if (pixelWriteMask & 0x1)
	{
		D3DXFLOAT16* const outColor = writeAddresses[0];
		if (channelWriteMask & 0x1) outColor[0] = *(const D3DXFLOAT16* const)&(half4Color4[0].m128i_u16[0]);
		if (channelWriteMask & 0x2) outColor[1] = *(const D3DXFLOAT16* const)&(half4Color4[0].m128i_u16[1]);
		if (channelWriteMask & 0x4) outColor[2] = *(const D3DXFLOAT16* const)&(half4Color4[0].m128i_u16[2]);
		if (channelWriteMask & 0x8)	outColor[3] = *(const D3DXFLOAT16* const)&(half4Color4[0].m128i_u16[3]);
	}
	if (pixelWriteMask & 0x2)
	{
		D3DXFLOAT16* const outColor = writeAddresses[1];
		if (channelWriteMask & 0x1) outColor[0] = *(const D3DXFLOAT16* const)&(half4Color4[1].m128i_u16[0]);
		if (channelWriteMask & 0x2) outColor[1] = *(const D3DXFLOAT16* const)&(half4Color4[1].m128i_u16[1]);
		if (channelWriteMask & 0x4) outColor[2] = *(const D3DXFLOAT16* const)&(half4Color4[1].m128i_u16[2]);
		if (channelWriteMask & 0x8)	outColor[3] = *(const D3DXFLOAT16* const)&(half4Color4[1].m128i_u16[3]);
	}
	if (pixelWriteMask & 0x4)
	{
		D3DXFLOAT16* const outColor = writeAddresses[2];
		if (channelWriteMask & 0x1) outColor[0] = *(const D3DXFLOAT16* const)&(half4Color4[2].m128i_u16[0]);
		if (channelWriteMask & 0x2) outColor[1] = *(const D3DXFLOAT16* const)&(half4Color4[2].m128i_u16[1]);
		if (channelWriteMask & 0x4) outColor[2] = *(const D3DXFLOAT16* const)&(half4Color4[2].m128i_u16[2]);
		if (channelWriteMask & 0x8)	outColor[3] = *(const D3DXFLOAT16* const)&(half4Color4[2].m128i_u16[3]);
	}
	if (pixelWriteMask & 0x8)
	{
		D3DXFLOAT16* const outColor = writeAddresses[3];
		if (channelWriteMask & 0x1) outColor[0] = *(const D3DXFLOAT16* const)&(half4Color4[3].m128i_u16[0]);
		if (channelWriteMask & 0x2) outColor[1] = *(const D3DXFLOAT16* const)&(half4Color4[3].m128i_u16[1]);
		if (channelWriteMask & 0x4) outColor[2] = *(const D3DXFLOAT16* const)&(half4Color4[3].m128i_u16[2]);
		if (channelWriteMask & 0x8)	outColor[3] = *(const D3DXFLOAT16* const)&(half4Color4[3].m128i_u16[3]);
	}
}

template <const unsigned char writeMask = 0xF>
inline void ColorA16B16G16R16FToFloat4(const A16B16G16R16F& color, D3DXVECTOR4& outColor)
{
	__m128i half4color;
	half4color.m128i_u16[0] = *(const unsigned short* const)&color.r;
	half4color.m128i_u16[1] = *(const unsigned short* const)&color.g;
	half4color.m128i_u16[2] = *(const unsigned short* const)&color.b;
	half4color.m128i_u16[3] = *(const unsigned short* const)&color.a;

	const __m128 float4color = _mm_cvtph_ps(half4color);
	if (writeMask & 0x1)
		outColor.x = float4color.m128_f32[0];
	if (writeMask & 0x2)
		outColor.y = float4color.m128_f32[1];
	if (writeMask & 0x4)
		outColor.z = float4color.m128_f32[2];
	if (writeMask & 0x8)
		outColor.w = float4color.m128_f32[3];
}

template <const unsigned char writeMask = 0xF>
inline void ColorA16B16G16R16FToFloat4_4(const A16B16G16R16F* const (&color4)[4], D3DXVECTOR4 (&outColor4)[4])
{
	__m128i half4color4[4];
	half4color4[0].m128i_u16[0] = *(const unsigned short* const)&color4[0]->r;
	half4color4[0].m128i_u16[1] = *(const unsigned short* const)&color4[0]->g;
	half4color4[0].m128i_u16[2] = *(const unsigned short* const)&color4[0]->b;
	half4color4[0].m128i_u16[3] = *(const unsigned short* const)&color4[0]->a;
	half4color4[1].m128i_u16[0] = *(const unsigned short* const)&color4[1]->r;
	half4color4[1].m128i_u16[1] = *(const unsigned short* const)&color4[1]->g;
	half4color4[1].m128i_u16[2] = *(const unsigned short* const)&color4[1]->b;
	half4color4[1].m128i_u16[3] = *(const unsigned short* const)&color4[1]->a;
	half4color4[2].m128i_u16[0] = *(const unsigned short* const)&color4[2]->r;
	half4color4[2].m128i_u16[1] = *(const unsigned short* const)&color4[2]->g;
	half4color4[2].m128i_u16[2] = *(const unsigned short* const)&color4[2]->b;
	half4color4[2].m128i_u16[3] = *(const unsigned short* const)&color4[2]->a;
	half4color4[3].m128i_u16[0] = *(const unsigned short* const)&color4[3]->r;
	half4color4[3].m128i_u16[1] = *(const unsigned short* const)&color4[3]->g;
	half4color4[3].m128i_u16[2] = *(const unsigned short* const)&color4[3]->b;
	half4color4[3].m128i_u16[3] = *(const unsigned short* const)&color4[3]->a;

	const __m128 float4color4[4] = 
	{
		_mm_cvtph_ps(half4color4[0]),
		_mm_cvtph_ps(half4color4[1]),
		_mm_cvtph_ps(half4color4[2]),
		_mm_cvtph_ps(half4color4[3])
	};
	if (writeMask & 0x1)
	{
		outColor4[0].x = float4color4[0].m128_f32[0];
		outColor4[1].x = float4color4[1].m128_f32[0];
		outColor4[2].x = float4color4[2].m128_f32[0];
		outColor4[3].x = float4color4[3].m128_f32[0];
	}
	if (writeMask & 0x2)
	{
		outColor4[0].y = float4color4[0].m128_f32[1];
		outColor4[1].y = float4color4[1].m128_f32[1];
		outColor4[2].y = float4color4[2].m128_f32[1];
		outColor4[3].y = float4color4[3].m128_f32[1];
	}
	if (writeMask & 0x4)
	{
		outColor4[0].z = float4color4[0].m128_f32[2];
		outColor4[1].z = float4color4[1].m128_f32[2];
		outColor4[2].z = float4color4[2].m128_f32[2];
		outColor4[3].z = float4color4[3].m128_f32[2];
	}
	if (writeMask & 0x8)
	{
		outColor4[0].w = float4color4[0].m128_f32[3];
		outColor4[1].w = float4color4[1].m128_f32[3];
		outColor4[2].w = float4color4[2].m128_f32[3];
		outColor4[3].w = float4color4[3].m128_f32[3];
	}
}

template <const unsigned char writeMask = 0xF>
inline void Float4ToA32B32G32R32F(const D3DXVECTOR4& color, A32B32G32R32F& outColor)
{
	if (writeMask == 0x0)
		return;

	if (writeMask == 0xF)
	{
		*(__m128* const)&outColor = *(const __m128* const)&color;
		return;
	}

	if (writeMask & 0x1)
		outColor.r = color.x;
	if (writeMask & 0x2)
		outColor.g = color.y;
	if (writeMask & 0x4)
		outColor.b = color.z;
	if (writeMask & 0x8)
		outColor.a = color.w;
}

template <const unsigned char channelWriteMask = 0xF, const unsigned char pixelWriteMask>
inline void Float4ToA32B32G32R32F4(const D3DXVECTOR4 (&color)[4], const __m128i outColorAddresses4)
{
	if (pixelWriteMask == 0x0)
	{
#ifdef _DEBUG
		__debugbreak(); // Don't call this function if you're not going to write anything out!
#endif
		return;
	}

	if (channelWriteMask == 0x0)
		return;

	if (channelWriteMask == 0xF)
	{
		if (pixelWriteMask & 0x1)
			*(__m128* const)(outColorAddresses4.m128i_u32[0]) = *(const __m128* const)&(color[0]);
		if (pixelWriteMask & 0x2)
			*(__m128* const)(outColorAddresses4.m128i_u32[1]) = *(const __m128* const)&(color[1]);
		if (pixelWriteMask & 0x4)
			*(__m128* const)(outColorAddresses4.m128i_u32[2]) = *(const __m128* const)&(color[2]);
		if (pixelWriteMask & 0x8)
			*(__m128* const)(outColorAddresses4.m128i_u32[3]) = *(const __m128* const)&(color[3]);
		return;
	}

	A32B32G32R32F* const outColor4[4] =
	{
		(A32B32G32R32F* const)(outColorAddresses4.m128i_u32[0]),
		(A32B32G32R32F* const)(outColorAddresses4.m128i_u32[1]),
		(A32B32G32R32F* const)(outColorAddresses4.m128i_u32[2]),
		(A32B32G32R32F* const)(outColorAddresses4.m128i_u32[3])
	};

	for (unsigned x = 0; x < 4; ++x)
	{
		if (pixelWriteMask & (1 << x) )
		{
			A32B32G32R32F& outColor = *outColor4[x];
			const D3DXVECTOR4& thisColor = color[x];
			if (channelWriteMask & 0x1)
				outColor.r = thisColor.x;
			if (channelWriteMask & 0x2)
				outColor.g = thisColor.y;
			if (channelWriteMask & 0x4)
				outColor.b = thisColor.z;
			if (channelWriteMask & 0x8)
				outColor.a = thisColor.w;
		}
	}
}

template <const unsigned char writeMask = 0xF>
inline void ColorA32B32G32R32FToFloat4(const A32B32G32R32F& color, D3DXVECTOR4& outColor)
{
	if (writeMask == 0x0)
		return;

	if (writeMask == 0xF)
	{
		*(__m128* const)&outColor = *(const __m128* const)&color;
		return;
	}

	if (writeMask & 0x1)
		outColor.x = color.r;
	if (writeMask & 0x2)
		outColor.y = color.g;
	if (writeMask & 0x4)
		outColor.z = color.b;
	if (writeMask & 0x8)
		outColor.w = color.a;
}

template <const unsigned char writeMask = 0xF>
inline void ColorA32B32G32R32FToFloat4_4(const A32B32G32R32F* const (&color4)[4], D3DXVECTOR4 (&outColor4)[4])
{
	if (writeMask & 0x1)
	{
		outColor4[0].x = color4[0]->r;
		outColor4[1].x = color4[1]->r;
		outColor4[2].x = color4[2]->r;
		outColor4[3].x = color4[3]->r;
	}
	if (writeMask & 0x2)
	{
		outColor4[0].y = color4[0]->g;
		outColor4[1].y = color4[1]->g;
		outColor4[2].y = color4[2]->g;
		outColor4[3].y = color4[3]->g;
	}
	if (writeMask & 0x4)
	{
		outColor4[0].z = color4[0]->b;
		outColor4[1].z = color4[1]->b;
		outColor4[2].z = color4[2]->b;
		outColor4[3].z = color4[3]->b;
	}
	if (writeMask & 0x8)
	{
		outColor4[0].w = color4[0]->a;
		outColor4[1].w = color4[1]->a;
		outColor4[2].w = color4[2]->a;
		outColor4[3].w = color4[3]->a;
	}
}

template <const unsigned char channelWriteMask = 0xF>
inline void Float4ToL8(const D3DXVECTOR4& color, unsigned char& outColor)
{
	if (channelWriteMask & 0x1)
	{
		outColor = (const unsigned char)(color.x * 255.0f);
	}
}

template <const unsigned char channelWriteMask = 0xF>
inline void Float4ToL8Clamp(const D3DXVECTOR4& color, unsigned char& outColor)
{
	if (channelWriteMask & 0x1)
	{
		outColor = color.x > 0.0f ? color.x <= 1.0f ? (const unsigned char)(color.x * 255.0f) : 255 : 0;
	}
}

template <const unsigned char channelWriteMask = 0xF, const unsigned char pixelWriteMask = 0xF>
inline void Float4ToL8Clamp4(const D3DXVECTOR4 (&color)[4], const __m128i outColorAddresses4)
{
	if (pixelWriteMask == 0)
	{
#ifdef _DEBUG
		__debugbreak(); // Don't call this if you don't intend to write anything out!
#endif
		return;
	}
	if ( (channelWriteMask & 0x1) != 1)
		return;

	// TODO: Properly vectorize this
	for (unsigned x = 0; x < 4; ++x)
	{
		if (pixelWriteMask & (1 << x) )
			Float4ToL8Clamp<channelWriteMask>(color[x], *(unsigned char* const)(outColorAddresses4.m128i_u32) );
	}
}

static const float inv255 = 1.0f / 255.0f;
template <const unsigned char writeMask = 0xF>
inline void L8ToFloat4(const unsigned char& color, D3DXVECTOR4& outColor)
{
	const float l8color = color * inv255;
	if (writeMask & 0x1)
		outColor.x = l8color;
	if (writeMask & 0x2)
		outColor.y = l8color;
	if (writeMask & 0x4)
		outColor.z = l8color;
	if (writeMask & 0x8)
		outColor.w = 1.0f; // L8 textures always treat the alpha channel as 1.0f: https://msdn.microsoft.com/en-us/library/windows/desktop/bb206224(v=vs.85).aspx
}

template <const unsigned char writeMask = 0xF>
inline void L8ToFloat4_4(const __m128i l8_4, D3DXVECTOR4 (&outColor4)[4])
{
	__m128 colorFloat4 = _mm_mul_ps(_mm_cvtepi32_ps(l8_4), ColorDWORDToFloat4Divisor);
	if (writeMask & 0x1)
	{
		outColor4[0].x = colorFloat4.m128_f32[0];
		outColor4[1].x = colorFloat4.m128_f32[1];
		outColor4[2].x = colorFloat4.m128_f32[2];
		outColor4[3].x = colorFloat4.m128_f32[3];
	}
	if (writeMask & 0x2)
	{
		outColor4[0].y = colorFloat4.m128_f32[0];
		outColor4[1].y = colorFloat4.m128_f32[1];
		outColor4[2].y = colorFloat4.m128_f32[2];
		outColor4[3].y = colorFloat4.m128_f32[3];
	}
	if (writeMask & 0x4)
	{
		outColor4[0].z = colorFloat4.m128_f32[0];
		outColor4[1].z = colorFloat4.m128_f32[1];
		outColor4[2].z = colorFloat4.m128_f32[2];
		outColor4[3].z = colorFloat4.m128_f32[3];
	}
	if (writeMask & 0x8)
	{
		// L8 textures always treat the alpha channel as 1.0f: https://msdn.microsoft.com/en-us/library/windows/desktop/bb206224(v=vs.85).aspx
		outColor4[0].w = 1.0f;
		outColor4[1].w = 1.0f;
		outColor4[2].w = 1.0f;
		outColor4[3].w = 1.0f;
	}
}

template <const unsigned char channelWriteMask = 0xF>
inline void Float4ToR16F(const D3DXVECTOR4& color, D3DXFLOAT16& outColor)
{
	if ( (channelWriteMask & 0x1) != 1)
		return;

	const __m128 float4Color = *(const __m128* const)&color;

	// Floating point rules specify round-to-nearest as the rounding mode for float16's: https://docs.microsoft.com/en-us/windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-float-rules
	const __m128i half4Color = _mm_cvtps_ph(float4Color, _MM_FROUND_TO_NEAREST_INT);

	if (channelWriteMask & 0x1)
		outColor = *(const D3DXFLOAT16* const)&(half4Color.m128i_u16[0]);
}

template <const unsigned char channelWriteMask = 0xF, const unsigned char pixelWriteMask = 0xF>
inline void Float4ToR16F4(const D3DXVECTOR4 (&color)[4], const __m128i outColorAddresses4)
{
	if (pixelWriteMask == 0x0)
	{
#ifdef _DEBUG
		__debugbreak(); // Should never call this function if you don't intend to write anything out!
#endif
		return;
	}

	if ( (channelWriteMask & 0x1) != 0x1)
		return;

	const __m128 float4Color4[4] = 
	{
		*(const __m128* const)&color[0],
		*(const __m128* const)&color[1],
		*(const __m128* const)&color[2],
		*(const __m128* const)&color[3]
	};

	// Shuffle from 4 vectors' .x components into one vector's .xyzw components:
	const __m128 tempShufXY = _mm_shuffle_ps(*(const __m128* const)&(color[0]), *(const __m128* const)&(color[1]), _MM_SHUFFLE(0, 0, 1, 0) ); // X and Y
	const __m128 tempShufZW = _mm_shuffle_ps(*(const __m128* const)&(color[2]), *(const __m128* const)&(color[3]), _MM_SHUFFLE(0, 0, 1, 0) ); // Z and W
	const __m128 float4Color = _mm_shuffle_ps(tempShufXY, tempShufZW, _MM_SHUFFLE(1, 0, 1, 0) ); // XYZW

	// Floating point rules specify round-to-nearest as the rounding mode for float16's: https://docs.microsoft.com/en-us/windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-float-rules
	const __m128i half4Color = _mm_cvtps_ph(float4Color, _MM_FROUND_TO_NEAREST_INT);

	D3DXFLOAT16* const outColors4[4] =
	{
		(D3DXFLOAT16* const)(outColorAddresses4.m128i_u32[0]),
		(D3DXFLOAT16* const)(outColorAddresses4.m128i_u32[1]),
		(D3DXFLOAT16* const)(outColorAddresses4.m128i_u32[2]),
		(D3DXFLOAT16* const)(outColorAddresses4.m128i_u32[3])
	};

	if (pixelWriteMask & 0x1)
		*outColors4[0] = *(const D3DXFLOAT16* const)&(half4Color.m128i_u16[0]);
	if (pixelWriteMask & 0x2)
		*outColors4[1] = *(const D3DXFLOAT16* const)&(half4Color.m128i_u16[1]);
	if (pixelWriteMask & 0x4)
		*outColors4[2] = *(const D3DXFLOAT16* const)&(half4Color.m128i_u16[2]);
	if (pixelWriteMask & 0x8)
		*outColors4[3] = *(const D3DXFLOAT16* const)&(half4Color.m128i_u16[3]);
}

template <const unsigned char writeMask = 0xF>
inline void ColorR16FToFloat4(const D3DXFLOAT16& color, D3DXVECTOR4& outColor)
{
	if (writeMask & 0x1)
	{
		__m128i colorHalf4;
		colorHalf4.m128i_u16[0] = *(const unsigned short* const)&color;
		const __m128 colorFloat4 = _mm_cvtph_ps(colorHalf4);
		outColor.x = colorFloat4.m128_f32[0];
	}
	if (writeMask & 0x2)
		outColor.y = 1.0f; // https://msdn.microsoft.com/en-us/library/windows/desktop/bb206224(v=vs.85).aspx
	if (writeMask & 0x4)
		outColor.z = 1.0f;
	if (writeMask & 0x8)
		outColor.w = 1.0f;
}

template <const unsigned char writeMask = 0xF>
inline void ColorR16FToFloat4_4(const D3DXFLOAT16 (&color4)[4], D3DXVECTOR4 (&outColor4)[4])
{
	if (writeMask & 0x1)
	{
		__m128i colorHalf4;
		colorHalf4.m128i_u16[0] = *(const unsigned short* const)&(color4[0]);
		colorHalf4.m128i_u16[1] = *(const unsigned short* const)&(color4[0]);
		colorHalf4.m128i_u16[2] = *(const unsigned short* const)&(color4[0]);
		colorHalf4.m128i_u16[3] = *(const unsigned short* const)&(color4[0]);
		const __m128 colorFloat4 = _mm_cvtph_ps(colorHalf4);

		outColor4[0].x = colorFloat4.m128_f32[0];
		outColor4[1].x = colorFloat4.m128_f32[1];
		outColor4[2].x = colorFloat4.m128_f32[2];
		outColor4[3].x = colorFloat4.m128_f32[3];
	}
	if (writeMask & 0x2)
	{
		// https://msdn.microsoft.com/en-us/library/windows/desktop/bb206224(v=vs.85).aspx
		outColor4[0].y = 1.0f;
		outColor4[1].y = 1.0f;
		outColor4[2].y = 1.0f;
		outColor4[3].y = 1.0f;
	}
	if (writeMask & 0x4)
	{
		outColor4[0].z = 1.0f;
		outColor4[1].z = 1.0f;
		outColor4[2].z = 1.0f;
		outColor4[3].z = 1.0f;
	}
	if (writeMask & 0x8)
	{
		outColor4[0].w = 1.0f;
		outColor4[1].w = 1.0f;
		outColor4[2].w = 1.0f;
		outColor4[3].w = 1.0f;
	}
}

static inline const unsigned RoundUpTo4(const unsigned num)
{
	return ( (num + 3) & ~0x3);
}

static inline const unsigned RoundUpTo8(const unsigned num)
{
	return ( (num + 7) & ~0x7);
}

static inline const unsigned RoundUpTo16(const unsigned num)
{
	return ( (num + 15) & ~0xF);
}

template <typename T>
static inline void SwapWithCopy(T& left, T& right)
{
	T copy = left;
	left = right;
	right = copy;
}

```

`Software_d3d9/IDirect3DDevice9Hook_Accessors.cpp`:

```cpp
#pragma once

#include "GlobalToggles.h"
#include "IDirect3DDevice9Hook.h"
#include "IDirect3DSwapChain9Hook.h"
#include "IDirect3DSurface9Hook.h"
#include "IDirect3DIndexBuffer9Hook.h"
#include "IDirect3DVertexBuffer9Hook.h"
#include "IDirect3DBaseTexture9Hook.h"
#include "IDirect3DTexture9Hook.h"
#include "IDirect3DCubeTexture9Hook.h"
#include "IDirect3DVolumeTexture9Hook.h"
#include "IDirect3DVertexDeclaration9Hook.h"
#include "IDirect3DVertexShader9Hook.h"
#include "IDirect3DPixelShader9Hook.h"
#include "IDirect3DStateBlock9Hook.h"

COM_DECLSPEC_NOTHROW UINT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetAvailableTextureMem(THIS)
{
	UINT ret = d3d9dev->GetAvailableTextureMem();
	// TODO: Implement this...
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetDirect3D(THIS_ IDirect3D9** ppD3D9)
{
	LPDIRECT3D9 realD3D9 = NULL;
	HRESULT ret = d3d9dev->GetDirect3D(&realD3D9);
	if (FAILED(ret) )
		return ret;

	if (!ppD3D9)
		return D3DERR_INVALIDCALL;

	// Check that the parentHook's underlying IDirect3D9* matches the realD3D9 pointer
#ifdef _DEBUG
	if (parentHook->GetUnderlyingD3D9() != realD3D9)
	{
		DbgBreakPrint("Error: Unknown IDirect3D9 interface detected on D3D9 device (not hooked)");
	}
#endif
	*ppD3D9 = parentHook;
	parentHook->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!
	return ret;
}

COM_DECLSPEC_NOTHROW /*static*/ void IDirect3DDevice9Hook::ModifyDeviceCaps(D3DCAPS9& caps)
{
	caps.VertexShaderVersion = D3DVS_VERSION(3, 0); // VS_3_0
	caps.PixelShaderVersion = D3DPS_VERSION(3, 0); // PS_3_0

	// We can only draw up to 1 million primitives per draw call
	caps.MaxPrimitiveCount = ( (1024 * 1024) - 1);

	// We can only draw up to 1 million vertices per draw call
	caps.MaxVertexIndex = ( (1024 * 1024) - 1);

	// We do not support tessellation
	caps.DevCaps &= (~(D3DDEVCAPS_NPATCHES | D3DDEVCAPS_QUINTICRTPATCHES | D3DDEVCAPS_RTPATCHES | D3DDEVCAPS_RTPATCHHANDLEZERO) );
	caps.DevCaps2 &= (~(D3DDEVCAPS2_ADAPTIVETESSRTPATCH | D3DDEVCAPS2_ADAPTIVETESSNPATCH | D3DDEVCAPS2_DMAPNPATCH | D3DDEVCAPS2_PRESAMPLEDDMAPNPATCH) );

	// So this wouldn't be very hard to implement support for, but currently we only support one output channel write mask for all render targets
	caps.PrimitiveMiscCaps &= (~D3DPMISCCAPS_INDEPENDENTWRITEMASKS);

	// We don't support convolution mono texture filtering
	caps.TextureFilterCaps &= (~D3DPTFILTERCAPS_CONVOLUTIONMONO);

	// We don't support D3DTEXF_GAUSSIANQUAD or D3DTEXF_PYRAMIDALQUAD texture filtering
	caps.TextureFilterCaps &= (~(D3DPTFILTERCAPS_MAGFPYRAMIDALQUAD | D3DPTFILTERCAPS_MAGFGAUSSIANQUAD | D3DPTFILTERCAPS_MINFPYRAMIDALQUAD | D3DPTFILTERCAPS_MINFGAUSSIANQUAD) );
	caps.CubeTextureFilterCaps &= (~(D3DPTFILTERCAPS_MAGFPYRAMIDALQUAD | D3DPTFILTERCAPS_MAGFGAUSSIANQUAD | D3DPTFILTERCAPS_MINFPYRAMIDALQUAD | D3DPTFILTERCAPS_MINFGAUSSIANQUAD) );
	caps.VolumeTextureFilterCaps &= (~(D3DPTFILTERCAPS_MAGFPYRAMIDALQUAD | D3DPTFILTERCAPS_MAGFGAUSSIANQUAD | D3DPTFILTERCAPS_MINFPYRAMIDALQUAD | D3DPTFILTERCAPS_MINFGAUSSIANQUAD) );

	// We don't support point sprites (yet)
	caps.MaxPointSize = 1.0f; // If set to 1.0f then device does not support point size control.
	caps.PrimitiveMiscCaps &= (~D3DPMISCCAPS_CLIPPLANESCALEDPOINTS); // Don't support clipping scaled point sprites (yet)
	caps.FVFCaps &= (~D3DFVFCAPS_PSIZE); // Don't support PSIZE in FVF's (yet)

	// Limit to 6 user clip-planes (see vertexClipStruct for why we can only support 6)
	caps.MaxUserClipPlanes = 6;

	// Cap the max stream stride such that it'll fit in a uint16
	if (caps.MaxStreamStride > 0xFFFF)
		caps.MaxStreamStride = 0xFFFF;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetDeviceCaps(THIS_ D3DCAPS9* pCaps)
{
	HRESULT ret = d3d9dev->GetDeviceCaps(pCaps);
	if (FAILED(ret) )
		return ret;

	if (pCaps)
	{
		ModifyDeviceCaps(*pCaps);
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetDisplayMode(THIS_ UINT iSwapChain, D3DDISPLAYMODE* pMode)
{
	if (iSwapChain == 0)
	{
		HRESULT ret = implicitSwapChain->GetDisplayMode(pMode);
		return ret;
	}
	else
	{
#ifdef _DEBUG
		// Non-implicit swap-chains not yet supported
		DbgBreakPrint("Error: Non-implicit swap chains not yet supported");
#endif
		return D3DERR_INVALIDCALL;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetCreationParameters(THIS_ D3DDEVICE_CREATION_PARAMETERS *pParameters)
{
	HRESULT ret = d3d9dev->GetCreationParameters(pParameters);
	// TODO: Implement this...
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetCursorProperties(THIS_ UINT XHotSpot, UINT YHotSpot, IDirect3DSurface9* pCursorBitmap)
{
	HRESULT ret = d3d9dev->SetCursorProperties(XHotSpot, YHotSpot, pCursorBitmap);
	return ret;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DDevice9Hook::SetCursorPosition(THIS_ int X, int Y, DWORD Flags)
{
	d3d9dev->SetCursorPosition(X, Y, Flags);
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetSwapChain(THIS_ UINT iSwapChain, IDirect3DSwapChain9** pSwapChain)
{
	LPDIRECT3DSWAPCHAIN9 realSwapChain = NULL;
	HRESULT ret = d3d9dev->GetSwapChain(iSwapChain, &realSwapChain);
	if (FAILED(ret) )
		return ret;

	if (!pSwapChain)
		return D3DERR_INVALIDCALL;

	if (iSwapChain == 0)
	{
#ifdef _DEBUG
		if (implicitSwapChain->GetUnderlyingSwapChain() != realSwapChain)
		{
			DbgBreakPrint("Error: Unknown swap chain used (not hooked)");
		}
#endif
		*pSwapChain = implicitSwapChain;
		implicitSwapChain->AddRef();
	}
	else
	{
#ifdef _DEBUG
		// TODO: Implement CreateAdditionalSwapChain()
		DbgBreakPrint("Error: Additional swap chains not yet supported");
#endif
		return D3DERR_INVALIDCALL;
	}

	return ret;
}

COM_DECLSPEC_NOTHROW UINT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetNumberOfSwapChains(THIS)
{
	UINT ret = d3d9dev->GetNumberOfSwapChains();
#ifdef _DEBUG
	if (ret != 1)
	{
		// Uhhhhhhhh, maybe they called CreateAdditionalSwapChain() and that incremented the count?
		DbgBreakPrint("Error: Additional swap chains not yet supported");
	}
#endif
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetBackBuffer(THIS_ UINT iSwapChain, UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer)
{
	if (iSwapChain == 0)
	{
		HRESULT ret = implicitSwapChain->GetBackBuffer(iBackBuffer, Type, ppBackBuffer);
		return ret;
	}
	else
	{
#ifdef _DEBUG
		// Swap chains beyond 0 are not yet supported!
		DbgBreakPrint("Error: Additional swap chains not yet supported");
#endif
		return D3DERR_INVALIDCALL;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetRasterStatus(THIS_ UINT iSwapChain, D3DRASTER_STATUS* pRasterStatus)
{
	if (iSwapChain == 0)
	{
		HRESULT ret = implicitSwapChain->GetRasterStatus(pRasterStatus);
		return ret;
	}
	else
	{
#ifdef _DEBUG
		// Swap chains beyond 0 are not yet supported!
		DbgBreakPrint("Error: Additional swap chains not yet supported");
#endif
		return D3DERR_INVALIDCALL;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetDialogBoxMode(THIS_ BOOL bEnableDialogs)
{
	HRESULT ret = d3d9dev->SetDialogBoxMode(bEnableDialogs);
	if (FAILED(ret) )
		return ret;

	// TODO: Enforce all of the conditions set forth in: https://msdn.microsoft.com/en-us/library/windows/desktop/bb174432(v=vs.85).aspx
	enableDialogs = bEnableDialogs;

	return ret;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DDevice9Hook::SetGammaRamp(THIS_ UINT iSwapChain, DWORD Flags, CONST D3DGAMMARAMP* pRamp)
{
	if (iSwapChain == 0)
	{
		// Set the gamma ramp on the actual device:
		d3d9dev->SetGammaRamp(0, Flags, pRamp);

		// Set the gamma ramp on the virtual software device too:
		implicitSwapChain->SetGammaRamp(Flags, pRamp);
	}
	else
	{
#ifdef _DEBUG
		// Swap chains beyond 0 are not yet supported!
		DbgBreakPrint("Error: Additional swap chains not yet supported");
#endif
	}
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DDevice9Hook::GetGammaRamp(THIS_ UINT iSwapChain, D3DGAMMARAMP* pRamp)
{
	if (iSwapChain == 0)
	{
		implicitSwapChain->GetGammaRamp(pRamp);
	}
	else
	{
#ifdef _DEBUG
		// Swap chains beyond 0 are not yet supported!
		DbgBreakPrint("Error: Additional swap chains not yet supported");
#endif
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetRenderTargetData(THIS_ IDirect3DSurface9* pRenderTarget, IDirect3DSurface9* pDestSurface)
{
	const IDirect3DSurface9Hook* const renderTargetHookPtr = dynamic_cast<IDirect3DSurface9Hook*>(pRenderTarget);
	if (renderTargetHookPtr)
		pRenderTarget = renderTargetHookPtr->GetUnderlyingSurface();
#ifdef _DEBUG
	else if (pRenderTarget != NULL)
	{
		DbgBreakPrint("Error: GetRenderTargetData called with a non-hooked render target pointer");
	}
#endif
	const IDirect3DSurface9Hook* const destHookPtr = dynamic_cast<IDirect3DSurface9Hook*>(pDestSurface);
	if (destHookPtr)
		pDestSurface = destHookPtr->GetUnderlyingSurface();
#ifdef _DEBUG
	else if (pDestSurface != NULL)
	{
		DbgBreakPrint("Error: GetRenderTargetData called with a non-hooked dest surface pointer");
	}
#endif
	HRESULT ret = d3d9dev->GetRenderTargetData(renderTargetHookPtr ? renderTargetHookPtr->GetUnderlyingSurface() : NULL, destHookPtr ? destHookPtr->GetUnderlyingSurface() : NULL);
	if (SUCCEEDED(ret) )
	{
		// TODO: Implement this...
	}
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetFrontBufferData(THIS_ UINT iSwapChain, IDirect3DSurface9* pDestSurface)
{
	if (iSwapChain == 0)
	{
		HRESULT ret = implicitSwapChain->GetFrontBufferData(pDestSurface);
		return ret;
	}
	else
	{
#ifdef _DEBUG
		// Non-zero swap chains not yet supported
		DbgBreakPrint("Error: Additional swap chains not yet supported!");
#endif
		return D3DERR_INVALIDCALL;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetRenderTarget(THIS_ DWORD RenderTargetIndex, IDirect3DSurface9** ppRenderTarget)
{
	LPDIRECT3DSURFACE9 realSurface = NULL;
	HRESULT ret = d3d9dev->GetRenderTarget(RenderTargetIndex, &realSurface);
	if (FAILED(ret) )
		return ret;

	if (!ppRenderTarget)
		return D3DERR_INVALIDCALL;

	if (RenderTargetIndex < D3D_MAX_SIMULTANEOUS_RENDERTARGETS)
	{
		IDirect3DSurface9Hook* const currentRenderTargetHook = currentState.currentRenderTargets[RenderTargetIndex];
		if (currentRenderTargetHook)
		{
#ifdef _DEBUG
			LPDIRECT3DSURFACE9 underlyingSurface = currentRenderTargetHook->GetUnderlyingSurface();
			if (realSurface != underlyingSurface)
			{
				DbgBreakPrint("Error: Render target underlying surface has a non-hooked surface pointer");
			}
#endif
		}

		*ppRenderTarget = currentRenderTargetHook;
		if (currentRenderTargetHook)
			currentRenderTargetHook->AddRef();
	}
#ifdef _DEBUG
	else
	{
		DbgBreakPrint("Error: Render target index is out of bounds");
	}
#endif

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetDepthStencilSurface(THIS_ IDirect3DSurface9* pNewZStencil)
{
	IDirect3DSurface9Hook* hookPtr = dynamic_cast<IDirect3DSurface9Hook*>(pNewZStencil);
	if (hookPtr)
		pNewZStencil = hookPtr->GetUnderlyingSurface();
#ifdef _DEBUG
	else if (pNewZStencil != NULL)
	{
		DbgBreakPrint("Error: SetDepthStencilSurface called with a non-hooked surface pointer");
	}
#endif
	HRESULT ret = d3d9dev->SetDepthStencilSurface(pNewZStencil);
	if (FAILED(ret) )
		return ret;

	currentState.currentDepthStencil = hookPtr;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetDepthStencilSurface(THIS_ IDirect3DSurface9** ppZStencilSurface)
{
	LPDIRECT3DSURFACE9 realSurface = NULL;
	HRESULT ret = d3d9dev->GetDepthStencilSurface(&realSurface);
	if (FAILED(ret) )
		return ret;

	if (ppZStencilSurface)
	{
		IDirect3DSurface9Hook* const currentDepthStencilHook = currentState.currentDepthStencil;
		if (currentDepthStencilHook)
		{
#ifdef _DEBUG
			LPDIRECT3DSURFACE9 underlyingSurface = currentDepthStencilHook->GetUnderlyingSurface();
			if (realSurface != underlyingSurface)
			{
				DbgBreakPrint("Error: Current depth-stencil surface has a non-hooked surface pointer");
			}
#endif
		}

		*ppZStencilSurface = currentDepthStencilHook;
		if (currentDepthStencilHook)
			currentDepthStencilHook->AddRef();
	}
#ifdef _DEBUG
	else
	{
		DbgBreakPrint("Error: GetDepthStencilSurface called with NULL pointer");
	}
#endif

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetTransform(THIS_ D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix)
{
	HRESULT ret = d3d9dev->SetTransform(State, pMatrix);
	if (FAILED(ret) )
		return ret;

	if (pMatrix)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			currentlyRecordingStateBlock->MarkSetTransformCaptured(State);
		}
		else
			targetDeviceState = &currentState;

		if (State < D3DTS_WORLD)
		{
			switch (State)
			{
			case D3DTS_VIEW:
				targetDeviceState->currentTransforms.SetViewTransform(*pMatrix);
				break;
			case D3DTS_PROJECTION:
				targetDeviceState->currentTransforms.SetProjectionTransform(*pMatrix);
				break;
			case D3DTS_TEXTURE0:
			case D3DTS_TEXTURE1:
			case D3DTS_TEXTURE2:
			case D3DTS_TEXTURE3:
			case D3DTS_TEXTURE4:
			case D3DTS_TEXTURE5:
			case D3DTS_TEXTURE6:
			case D3DTS_TEXTURE7:
				targetDeviceState->currentTransforms.SetTextureTransform(*pMatrix, (const unsigned char)(State - D3DTS_TEXTURE0) );
				break;
			default:
#ifdef _DEBUG
				// Invalid transform state enum!
				DbgBreakPrint("Error: Invalid transform state enum for SetTransform()");
#endif
				break;
			}
		}
		else if (State < D3DTS_WORLDMATRIX(MAX_WORLD_TRANSFORMS) ) // World transforms
		{
			targetDeviceState->currentTransforms.SetWorldTransform(*pMatrix, (const unsigned char)(State - D3DTS_WORLD) );
		}
#ifdef _DEBUG
		else
		{
			// Index too high, can't be valid state!
			DbgBreakPrint("Error: SetTransform state index out of bounds");
		}
#endif
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetTransform(THIS_ D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix)
{
	D3DMATRIX realMatrix = {0};
	HRESULT ret = d3d9dev->GetTransform(State, &realMatrix);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (State < D3DTS_WORLD)
	{
		switch (State)
		{
		case D3DTS_VIEW:
			if (memcmp(&currentState.currentTransforms.ViewTransform, &realMatrix, sizeof(D3DMATRIX) ) != 0)
			{
				DbgBreakPrint("Error: View matrix doesn't match internal view matrix");
			}
			break;
		case D3DTS_PROJECTION:
			if (memcmp(&currentState.currentTransforms.ProjectionTransform, &realMatrix, sizeof(D3DMATRIX) ) != 0)
			{
				DbgBreakPrint("Error: Proj matrix doesn't match internal proj matrix");
			}
			break;
		case D3DTS_TEXTURE0:
		case D3DTS_TEXTURE1:
		case D3DTS_TEXTURE2:
		case D3DTS_TEXTURE3:
		case D3DTS_TEXTURE4:
		case D3DTS_TEXTURE5:
		case D3DTS_TEXTURE6:
		case D3DTS_TEXTURE7:
			if (memcmp(&currentState.currentTransforms.TextureTransforms[State - D3DTS_TEXTURE0], &realMatrix, sizeof(D3DMATRIX) ) != 0)
			{
				DbgBreakPrint("Error: Texture matrix doesn't match internal texture matrix");
			}
			break;
		default:
			// Invalid transform state enum!
			DbgBreakPrint("Error: Invalid transform enum passed to GetTransform");
			break;
		}
	}
	else if (State < D3DTS_WORLDMATRIX(MAX_WORLD_TRANSFORMS) ) // World transforms
	{
		if (memcmp(&currentState.currentTransforms.WorldTransforms[State - D3DTS_WORLD], &realMatrix, sizeof(D3DMATRIX) ) != 0)
		{
			DbgBreakPrint("Error: World matrix doesn't match internal world matrix");
		}
	}
	else
	{
		// Index too high, can't be valid state!
		DbgBreakPrint("Error: Transform state out of bounds");
	}
#endif

	if (pMatrix)
	{
		if (State < D3DTS_WORLD)
		{
			switch (State)
			{
			case D3DTS_VIEW:
				memcpy(pMatrix, &currentState.currentTransforms.ViewTransform, sizeof(D3DMATRIX) );
				break;
			case D3DTS_PROJECTION:
				memcpy(pMatrix, &currentState.currentTransforms.ProjectionTransform, sizeof(D3DMATRIX) );
				break;
			case D3DTS_TEXTURE0:
			case D3DTS_TEXTURE1:
			case D3DTS_TEXTURE2:
			case D3DTS_TEXTURE3:
			case D3DTS_TEXTURE4:
			case D3DTS_TEXTURE5:
			case D3DTS_TEXTURE6:
			case D3DTS_TEXTURE7:
				memcpy(pMatrix, &currentState.currentTransforms.TextureTransforms[State - D3DTS_TEXTURE0], sizeof(D3DMATRIX) );
				break;
			default:
#ifdef _DEBUG
				// Invalid transform state enum!
				DbgBreakPrint("Error: Invalid transform enum passed to GetTransform");
#endif
				break;
			}
		}
		else if (State < D3DTS_WORLDMATRIX(MAX_WORLD_TRANSFORMS) ) // World transforms
		{
			memcpy(pMatrix, &currentState.currentTransforms.WorldTransforms[State - D3DTS_WORLD], sizeof(D3DMATRIX) );
		}
#ifdef _DEBUG
		else
		{
			// Index too high, can't be valid state!
			DbgBreakPrint("Error: Transform state is out of bounds");
		}
#endif
	}
	else
		return D3DERR_INVALIDCALL;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::MultiplyTransform(THIS_ D3DTRANSFORMSTATETYPE Transform, CONST D3DMATRIX* pMatrix)
{
	HRESULT ret = d3d9dev->MultiplyTransform(Transform, pMatrix);
	if (FAILED(ret) )
		return ret;

	if (pMatrix)
	{
		D3DXMATRIXA16 d3dxMatrix(*pMatrix);
		if (Transform < D3DTS_WORLD)
		{
			switch (Transform)
			{
			case D3DTS_VIEW:
				currentState.currentTransforms.ViewTransform = d3dxMatrix * currentState.currentTransforms.ViewTransform;
				break;
			case D3DTS_PROJECTION:
				currentState.currentTransforms.ProjectionTransform = d3dxMatrix * currentState.currentTransforms.ProjectionTransform;
				break;
			case D3DTS_TEXTURE0:
			case D3DTS_TEXTURE1:
			case D3DTS_TEXTURE2:
			case D3DTS_TEXTURE3:
			case D3DTS_TEXTURE4:
			case D3DTS_TEXTURE5:
			case D3DTS_TEXTURE6:
			case D3DTS_TEXTURE7:
				currentState.currentTransforms.TextureTransforms[Transform - D3DTS_TEXTURE0] = d3dxMatrix * currentState.currentTransforms.TextureTransforms[Transform - D3DTS_TEXTURE0];
				break;
			default:
#ifdef _DEBUG
				// Invalid transform state enum!
				DbgBreakPrint("Error: Invalid transform enum passed to MultiplyTransform");
#endif
				break;
			}
		}
		else if (Transform < D3DTS_WORLDMATRIX(MAX_WORLD_TRANSFORMS) ) // World transforms
		{
			currentState.currentTransforms.WorldTransforms[Transform - D3DTS_WORLD] = d3dxMatrix * currentState.currentTransforms.WorldTransforms[Transform - D3DTS_WORLD];
		}
#ifdef _DEBUG
		else
		{
			// Index too high, can't be valid state!
			DbgBreakPrint("Error: Transform state is out of bounds");
		}
#endif
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetViewport(THIS_ CONST D3DVIEWPORT9* pViewport)
{
	HRESULT ret = d3d9dev->SetViewport(pViewport);
	if (FAILED(ret) )
		return ret;

	// Real D3D9 crashes if you pass in a NULL pointer, so we can do basically whatever we want here
	if (pViewport)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetViewport>();
		}
		else
			targetDeviceState = &currentState;

		targetDeviceState->cachedViewport.viewport = *pViewport;
		targetDeviceState->cachedViewport.RecomputeCache();
	}
#ifdef _DEBUG
	else
	{
		DbgBreakPrint("Error: SetViewport called with NULL viewport pointer");
	}
#endif

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetViewport(THIS_ D3DVIEWPORT9* pViewport)
{
	D3DVIEWPORT9 localRet = {0};
	HRESULT ret = d3d9dev->GetViewport(&localRet);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (localRet != currentState.cachedViewport.viewport)
	{
		DbgBreakPrint("Error: Internal viewport doesn't match viewport");
	}
#endif

	if (!pViewport)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: GetViewport called with a NULL pointer");
#endif
		return D3DERR_INVALIDCALL;
	}
	else
		*pViewport = currentState.cachedViewport.viewport;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetMaterial(THIS_ CONST D3DMATERIAL9* pMaterial)
{
	HRESULT ret = d3d9dev->SetMaterial(pMaterial);
	if (FAILED(ret) )
		return ret;

	// D3D9 just crashes if you pass a NULL pointer pMaterial, so we can do whatever in that case
	if (pMaterial)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetMaterial>();
		}
		else
			targetDeviceState = &currentState;

		targetDeviceState->currentMaterial = *pMaterial;
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetMaterial(THIS_ D3DMATERIAL9* pMaterial)
{
	D3DMATERIAL9 realMaterial = {0};
	HRESULT ret = d3d9dev->GetMaterial(&realMaterial);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (memcmp(&realMaterial, &currentState.currentMaterial, sizeof(D3DMATERIAL9) ) != 0)
	{
		DbgBreakPrint("Error: Internal material doesn't match material");
	}
#endif

	if (pMaterial)
	{
		*pMaterial = currentState.currentMaterial;
		return ret;
	}
	else
		return D3DERR_INVALIDCALL;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetLight(THIS_ DWORD Index, CONST D3DLIGHT9* pLight)
{
	HRESULT ret = d3d9dev->SetLight(Index, pLight);
	if (FAILED(ret) )
		return ret;

	if (pLight)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			currentlyRecordingStateBlock->MarkSetLightCaptured(Index);
		}
		else
			targetDeviceState = &currentState;

		std::map<UINT, LightInfo*>::iterator it = targetDeviceState->lightInfoMap->find(Index);
		if (it == targetDeviceState->lightInfoMap->end() )
		{
			LightInfo* newLightInfo = new LightInfo;
			newLightInfo->light = *pLight;
			targetDeviceState->lightInfoMap->insert(std::make_pair(Index, newLightInfo) );
		}
		else
		{
			if (it->second != &LightInfo::defaultLight)
				it->second->light = *pLight;
			else
			{
				LightInfo* newLightInfo = new LightInfo;
				newLightInfo->light = *pLight;
				it->second = newLightInfo;
			}
		}
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetLight(THIS_ DWORD Index, D3DLIGHT9* pLight)
{
	D3DLIGHT9 realLight = {};
	HRESULT ret = d3d9dev->GetLight(Index, &realLight);
	if (FAILED(ret) )
		return ret;

	const std::map<UINT, LightInfo*>::const_iterator it = currentState.lightInfoMap->find(Index);
	if (it == currentState.lightInfoMap->end() )
	{
		return D3DERR_INVALIDCALL;
	}
	else
	{
#ifdef _DEBUG
		if (memcmp(&realLight, &it->second->light, sizeof(D3DLIGHT9) ) != 0)
		{
			DbgBreakPrint("Error: Internal light doesn't match material");
		}
#endif
		if (pLight)
		{
			*pLight = it->second->light;
			return ret;
		}
		else
			return D3DERR_INVALIDCALL;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::LightEnable(THIS_ DWORD Index, BOOL Enable)
{
	HRESULT ret = d3d9dev->LightEnable(Index, Enable);
	if (FAILED(ret) )
		return ret;

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkLightEnableCaptured(Index, Enable);
	}
	else
		targetDeviceState = &currentState;

	const std::map<UINT, LightInfo*>::const_iterator it = targetDeviceState->lightInfoMap->find(Index);
	if (it == targetDeviceState->lightInfoMap->end() )
	{
		targetDeviceState->lightInfoMap->insert(std::make_pair(Index, &LightInfo::defaultLight) );
		for (unsigned x = 0; x < MAX_ENABLED_LIGHTS; ++x)
		{
			if (!targetDeviceState->enabledLightIndices[x])
			{
				targetDeviceState->enabledLightIndices[x] = &LightInfo::defaultLight;
				return ret;
			}
		}

#ifdef _DEBUG
		// Can't enable more than MAX_ENABLED_LIGHTS lights simultaneously!
		DbgBreakPrint("Error: Can't enable more than MAX_ENABLED_LIGHTS (8) simultaneously!");
#endif

		return D3DERR_INVALIDCALL;
	}
	else
	{
		if (it->second->activeLightIndex >= 0) // Expecting an enabled light
		{
			if (Enable)
			{
#ifdef _DEBUG
				DbgBreakPrint("Warning: Enabling an already-enabled light");
#endif
				// Do nothing, light is already enabled
				return ret;
			}
			else
			{
				targetDeviceState->enabledLightIndices[it->second->activeLightIndex] = NULL;
				it->second->activeLightIndex = -1;
				return ret;
			}
		}
		else // Expecting a disabled light
		{
			if (Enable)
			{
				for (unsigned x = 0; x < MAX_ENABLED_LIGHTS; ++x)
				{
					if (targetDeviceState->enabledLightIndices[x] == NULL)
					{
						targetDeviceState->enabledLightIndices[x] = it->second;
						it->second->activeLightIndex = x;
						return ret;
					}
				}

#ifdef _DEBUG
				// Can't enable more than MAX_ENABLED_LIGHTS lights simultaneously!
				DbgBreakPrint("Error: Can't enable more than MAX_ENABLED_LIGHTS (8) simultaneously!");
#endif

				return D3DERR_INVALIDCALL;
			}
			else
			{
#ifdef _DEBUG
				OutputDebugStringA("Warning: Disabling an already-disabled light");
#endif
				// Do nothing, light is already disabled
				return ret;
			}
		}
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetLightEnable(THIS_ DWORD Index, BOOL* pEnable)
{
	BOOL realEnable = FALSE;
	HRESULT ret = d3d9dev->GetLightEnable(Index, &realEnable);
	if (FAILED(ret) )
		return ret;

	const std::map<UINT, LightInfo*>::const_iterator it = currentState.lightInfoMap->find(Index);
	if (it == currentState.lightInfoMap->end() )
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Light does not exist in light lookup. Call SetLight() first before enabling your light.");
#endif
		return D3DERR_INVALIDCALL;
	}
	else
	{
		const BOOL softwareEnable = it->second->activeLightIndex >= 0 ? TRUE : FALSE;
#ifdef _DEBUG
		if (realEnable != softwareEnable)
		{
			DbgBreakPrint("Error: Internal light enable different than light enable");
		}
#endif
		if (pEnable)
		{
			*pEnable = softwareEnable;
			return ret;
		}
		else
			return D3DERR_INVALIDCALL;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetClipPlane(THIS_ DWORD Index, CONST float* pPlane)
{
	HRESULT ret = d3d9dev->SetClipPlane(Index, pPlane);
	if (FAILED(ret) )
		return ret;

	// The real D3D9 seems to handle clip planes greater than D3DMAXUSERCLIPPLANES by allocating dynamic memory in a tree structure, however
	// most GPU's don't read clip planes beyond the first six anyway, so we don't actually need to keep track of those high-numbered clip planes for rendering.
	if (pPlane && Index < D3DMAXUSERCLIPPLANES)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetMaterial>();
		}
		else
			targetDeviceState = &currentState;

		memcpy(&(targetDeviceState->currentClippingPlanes[Index]), pPlane, sizeof(D3DXPLANE) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetClipPlane(THIS_ DWORD Index, float* pPlane)
{
	D3DXPLANE realPlane(0.0f, 0.0f, 0.0f, 0.0f);
	HRESULT ret = d3d9dev->GetClipPlane(Index, (float* const)&realPlane);
	if (FAILED(ret) )
		return ret;

	if (Index < D3DMAXUSERCLIPPLANES)
	{
#ifdef _DEBUG
		if (memcmp(&realPlane, &currentState.currentClippingPlanes[Index], sizeof(D3DXPLANE) ) != 0)
		{
			DbgBreakPrint("Error: Internal clipping plane different than clipping plane");
		}
#endif

		if (pPlane)
		{
			memcpy(pPlane, &currentState.currentClippingPlanes[Index], sizeof(D3DXPLANE) );
		}
	}
	else
	{
		if (pPlane)
		{
			memset(pPlane, 0, sizeof(D3DXPLANE) );
		}
	}

	return ret;
}

#ifdef _DEBUG
// Note that range checks (less than zero and greater than D3DRS_BLENDOPALPHA) should be performed outside of this function
static inline const bool IsRenderStateValidForD3D9(const D3DRENDERSTATETYPE State)
{
	switch (State)
	{
		case D3DRS_ZENABLE                   :
		case D3DRS_FILLMODE                  :
		case D3DRS_SHADEMODE                 :
		case D3DRS_ZWRITEENABLE              :
		case D3DRS_ALPHATESTENABLE           :
		case D3DRS_LASTPIXEL                 :
		case D3DRS_SRCBLEND                  :
		case D3DRS_DESTBLEND                 :
		case D3DRS_CULLMODE                  :
		case D3DRS_ZFUNC                     :
		case D3DRS_ALPHAREF                  :
		case D3DRS_ALPHAFUNC                 :
		case D3DRS_DITHERENABLE              :
		case D3DRS_ALPHABLENDENABLE          :
		case D3DRS_FOGENABLE                 :
		case D3DRS_SPECULARENABLE            :
		case D3DRS_FOGCOLOR                  :
		case D3DRS_FOGTABLEMODE              :
		case D3DRS_FOGSTART                  :
		case D3DRS_FOGEND                    :
		case D3DRS_FOGDENSITY                :
		case D3DRS_RANGEFOGENABLE            :
		case D3DRS_STENCILENABLE             :
		case D3DRS_STENCILFAIL               :
		case D3DRS_STENCILZFAIL              :
		case D3DRS_STENCILPASS               :
		case D3DRS_STENCILFUNC               :
		case D3DRS_STENCILREF                :
		case D3DRS_STENCILMASK               :
		case D3DRS_STENCILWRITEMASK          :
		case D3DRS_TEXTUREFACTOR             :
		case D3DRS_WRAP0                     :
		case D3DRS_WRAP1                     :
		case D3DRS_WRAP2                     :
		case D3DRS_WRAP3                     :
		case D3DRS_WRAP4                     :
		case D3DRS_WRAP5                     :
		case D3DRS_WRAP6                     :
		case D3DRS_WRAP7                     :
		case D3DRS_CLIPPING                  :
		case D3DRS_LIGHTING                  :
		case D3DRS_AMBIENT                   :
		case D3DRS_FOGVERTEXMODE             :
		case D3DRS_COLORVERTEX               :
		case D3DRS_LOCALVIEWER               :
		case D3DRS_NORMALIZENORMALS          :
		case D3DRS_DIFFUSEMATERIALSOURCE     :
		case D3DRS_SPECULARMATERIALSOURCE    :
		case D3DRS_AMBIENTMATERIALSOURCE     :
		case D3DRS_EMISSIVEMATERIALSOURCE    :
		case D3DRS_VERTEXBLEND               :
		case D3DRS_CLIPPLANEENABLE           :
		case D3DRS_POINTSIZE                 :
		case D3DRS_POINTSIZE_MIN             :
		case D3DRS_POINTSPRITEENABLE         :
		case D3DRS_POINTSCALEENABLE          :
		case D3DRS_POINTSCALE_A              :
		case D3DRS_POINTSCALE_B              :
		case D3DRS_POINTSCALE_C              :
		case D3DRS_MULTISAMPLEANTIALIAS      :
		case D3DRS_MULTISAMPLEMASK           :
		case D3DRS_PATCHEDGESTYLE            :
		case D3DRS_DEBUGMONITORTOKEN         :
		case D3DRS_POINTSIZE_MAX             :
		case D3DRS_INDEXEDVERTEXBLENDENABLE  :
		case D3DRS_COLORWRITEENABLE          :
		case D3DRS_TWEENFACTOR               :
		case D3DRS_BLENDOP                   :
		case D3DRS_POSITIONDEGREE            :
		case D3DRS_NORMALDEGREE              :
		case D3DRS_SCISSORTESTENABLE         :
		case D3DRS_SLOPESCALEDEPTHBIAS       :
		case D3DRS_ANTIALIASEDLINEENABLE     :
		case D3DRS_MINTESSELLATIONLEVEL      :
		case D3DRS_MAXTESSELLATIONLEVEL      :
		case D3DRS_ADAPTIVETESS_X            :
		case D3DRS_ADAPTIVETESS_Y            :
		case D3DRS_ADAPTIVETESS_Z            :
		case D3DRS_ADAPTIVETESS_W            :
		case D3DRS_ENABLEADAPTIVETESSELLATION :
		case D3DRS_TWOSIDEDSTENCILMODE       :
		case D3DRS_CCW_STENCILFAIL           :
		case D3DRS_CCW_STENCILZFAIL          :
		case D3DRS_CCW_STENCILPASS           :
		case D3DRS_CCW_STENCILFUNC           :
		case D3DRS_COLORWRITEENABLE1         :
		case D3DRS_COLORWRITEENABLE2         :
		case D3DRS_COLORWRITEENABLE3         :
		case D3DRS_BLENDFACTOR               :
		case D3DRS_SRGBWRITEENABLE           :
		case D3DRS_DEPTHBIAS                 :
		case D3DRS_WRAP8                     :
		case D3DRS_WRAP9                     :
		case D3DRS_WRAP10                    :
		case D3DRS_WRAP11                    :
		case D3DRS_WRAP12                    :
		case D3DRS_WRAP13                    :
		case D3DRS_WRAP14                    :
		case D3DRS_WRAP15                    :
		case D3DRS_SEPARATEALPHABLENDENABLE  :
		case D3DRS_SRCBLENDALPHA             :
		case D3DRS_DESTBLENDALPHA            :
		case D3DRS_BLENDOPALPHA              :
			return true;
		default:
			return false;
	}
}
#endif // #ifdef _DEBUG

static inline const bool DoesSrcBlendRequireDestData(const D3DBLEND srcBlend)
{
	switch (srcBlend)
	{
	default:
		return false;
	case D3DBLEND_DESTALPHA:
	case D3DBLEND_INVDESTALPHA:
	case D3DBLEND_DESTCOLOR:
	case D3DBLEND_INVDESTCOLOR:
		return true;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetRenderState(THIS_ D3DRENDERSTATETYPE State, DWORD Value)
{
	HRESULT ret = d3d9dev->SetRenderState(State, Value);
	if (FAILED(ret) )
		return ret;

	if (State < 0 || State >= MAX_NUM_RENDERSTATES)
		return D3DERR_INVALIDCALL;

	// Active state block recording redirects state writes into the state block rather than to the real device
	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkRenderStateAsCaptured(State);
	}
	else
		targetDeviceState = &currentState;
	RenderStates& targetRenderStates = targetDeviceState->currentRenderStates;
	RenderStates::_renderStatesUnion& targetRenderStatesUnion = targetRenderStates.renderStatesUnion;

#ifdef _DEBUG
	if (!IsRenderStateValidForD3D9(State) )
	{
		char buffer[256] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(buffer, "Warning: Render state enum is in bounds, but not a recognized render state and will not have any effect. This may be due to driver-specific render-states, or via people using D3D7 or D3D8 render states by accident. Render State Index: %u, Value: %u\n", State, Value);
#pragma warning(pop)
		OutputDebugStringA(buffer);
	}
#endif

	targetRenderStatesUnion.states[State] = Value;

	switch (State)
	{
	case D3DRS_ALPHAREF:
		targetRenderStates.cachedAlphaRefFloat = targetRenderStatesUnion.namedStates.alphaRef / 255.0f;
		targetRenderStates.alphaRefSplatted = _mm_set1_ps(targetRenderStates.cachedAlphaRefFloat);
		break;
	case D3DRS_AMBIENT:
		ColorDWORDToFloat4<0xF>(targetRenderStatesUnion.namedStates.ambient, targetRenderStates.cachedAmbient);
		break;
	case D3DRS_BLENDFACTOR:
		ColorDWORDToFloat4(targetRenderStatesUnion.states[D3DRS_BLENDFACTOR], targetRenderStates.cachedBlendFactor);
		targetRenderStates.cachedInvBlendFactor = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f) - targetRenderStates.cachedBlendFactor;
		break;
	case D3DRS_DEPTHBIAS:
		targetRenderStates.depthBiasSplatted = _mm_set1_ps(targetRenderStatesUnion.namedStates.depthBias);
		break;

	// Alpha blend type caching:
	case D3DRS_ALPHABLENDENABLE:
	case D3DRS_SEPARATEALPHABLENDENABLE:
	case D3DRS_SRCBLEND:
	case D3DRS_DESTBLEND:
		if (targetRenderStatesUnion.namedStates.alphaBlendEnable)
		{
			// Separate alpha blending
			if (targetRenderStatesUnion.namedStates.separateAlphaBlendEnable)
			{
				targetRenderStates.simplifiedAlphaBlendMode = RenderStates::otherAlphaBlending;
				targetRenderStates.alphaBlendNeedsDestRead = true; // TODO: Figure this out for reals rather than defaulting to this conservative "true" value
			}
			// Unified alpha blending
			else
			{
				if (targetRenderStatesUnion.namedStates.srcBlend == D3DBLEND_SRCALPHA && 
					targetRenderStatesUnion.namedStates.destBlend == D3DBLEND_INVSRCALPHA) // TODO: Check the for the less common Min/Max/Reversesubtract blend ops
				{
					targetRenderStates.simplifiedAlphaBlendMode = RenderStates::alphaBlending;
				}
				else if (targetRenderStatesUnion.namedStates.srcBlend == D3DBLEND_ONE &&
						targetRenderStatesUnion.namedStates.destBlend == D3DBLEND_ONE) // TODO: Check the for the less common Min/Max/Reversesubtract blend ops
				{
					targetRenderStates.simplifiedAlphaBlendMode = RenderStates::additiveBlending;
				}
				else if ( (targetRenderStatesUnion.namedStates.srcBlend == D3DBLEND_DESTCOLOR &&
						targetRenderStatesUnion.namedStates.destBlend == D3DBLEND_ZERO) || 
						(targetRenderStatesUnion.namedStates.srcBlend == D3DBLEND_ZERO &&
						targetRenderStatesUnion.namedStates.destBlend == D3DBLEND_SRCCOLOR) ) // TODO: Check the for the less common Min/Max/Reversesubtract blend ops
				{
					targetRenderStates.simplifiedAlphaBlendMode = RenderStates::multiplicativeBlending;
				}
				else
				{
					targetRenderStates.simplifiedAlphaBlendMode = RenderStates::otherAlphaBlending;
				}
			}

			targetRenderStates.alphaBlendNeedsDestRead = (targetRenderStatesUnion.namedStates.destBlend > D3DBLEND_ZERO)
				|| DoesSrcBlendRequireDestData(targetRenderStatesUnion.namedStates.srcBlend);
		}
		else
		{
			targetRenderStates.simplifiedAlphaBlendMode = RenderStates::noAlphaBlending;
			targetRenderStates.alphaBlendNeedsDestRead = false;
		}
		break;
	default: // All other states are fine, we don't need caching for them
		break;
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetRenderState(THIS_ D3DRENDERSTATETYPE State, DWORD* pValue)
{
	DWORD stateValue = 0x00000000;
	HRESULT ret = d3d9dev->GetRenderState(State, &stateValue);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (stateValue != currentState.currentRenderStates.renderStatesUnion.states[State])
	{
		DbgBreakPrint("Error: Internal render state different than render state");
	}

	if (IsRenderStateD3D9Deprecated(State) )
	{
		DbgBreakPrint("Warning: Render-state deprecation is supposed to cause GetRenderState() to return D3DERR_INVALIDARG, so we shouldn't make it this far");
	}
#endif

	if (State < 0 || State >= MAX_NUM_RENDERSTATES)
		return D3DERR_INVALIDCALL;

	if (!pValue)
		return D3DERR_INVALIDCALL;

#ifdef _DEBUG
	if (!IsRenderStateValidForD3D9(State) )
	{
		char buffer[256] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(buffer, "Warning: Render state enum is in bounds, but not a recognized render state and will not have any effect. This may be due to driver-specific render-states, or via people using D3D7 or D3D8 render states by accident. Render State Index: %u, Value: %u\n", State, *pValue);
#pragma warning(pop)
		OutputDebugStringA(buffer);
	}
#endif
	*pValue = currentState.currentRenderStates.renderStatesUnion.states[State];
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetClipStatus(THIS_ CONST D3DCLIPSTATUS9* pClipStatus)
{
	// Don't support this
	DbgBreakPrint("Error: SetClipStatus is unsupported");
	HRESULT ret = d3d9dev->SetClipStatus(pClipStatus);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetClipStatus(THIS_ D3DCLIPSTATUS9* pClipStatus)
{
	// Don't support this
	DbgBreakPrint("Error: GetClipStatus is unsupported");
	HRESULT ret = d3d9dev->GetClipStatus(pClipStatus);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetTexture(THIS_ DWORD Stage, IDirect3DBaseTexture9** ppTexture)
{
	if (Stage >= 16 && Stage < D3DDMAPSAMPLER)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Texture stage out of addressable bounds");
#endif
		return D3DERR_INVALIDCALL;
	}
	if (Stage >= MAX_NUM_SAMPLERS)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Texture stage out of addressable bounds");
#endif
		return D3DERR_INVALIDCALL;
	}

	LPDIRECT3DBASETEXTURE9 realTexture = NULL;
	HRESULT ret = d3d9dev->GetTexture(Stage, &realTexture);
	if (FAILED(ret) )
		return ret;

	if (!ppTexture)
		return D3DERR_INVALIDCALL;

	if (currentState.currentTextures[Stage])
	{
#ifdef _DEBUG
		if (currentState.currentTextures[Stage]->GetUnderlyingTexture() != realTexture)
		{
			DbgBreakPrint("Error: Internal texture doesn't match texture");
		}
#endif
		*ppTexture = currentState.currentTextures[Stage];
		currentState.currentTextures[Stage]->AddRef();
	}
	else if (currentState.currentCubeTextures[Stage])
	{
#ifdef _DEBUG
		if (currentState.currentCubeTextures[Stage]->GetUnderlyingCubeTexture() != realTexture)
		{
			DbgBreakPrint("Error: Internal cube texture doesn't match cube texture");
		}
#endif
		*ppTexture = currentState.currentCubeTextures[Stage];
		currentState.currentCubeTextures[Stage]->AddRef();
	}
	else if (currentState.currentVolumeTextures[Stage])
	{
#ifdef _DEBUG
		if (currentState.currentVolumeTextures[Stage]->GetUnderlyingVolumeTexture() != realTexture)
		{
			DbgBreakPrint("Error: Internal volume texture doesn't match volume texture");
		}
#endif
		*ppTexture = currentState.currentVolumeTextures[Stage];
		currentState.currentVolumeTextures[Stage]->AddRef();
	}
	else
	{
		*ppTexture = NULL;
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetTexture(THIS_ DWORD Stage, IDirect3DBaseTexture9* pTexture)
{
	if (Stage >= 16 && Stage < D3DDMAPSAMPLER)
	{
#ifdef _DEBUG
		__debugbreak(); // This ends up crashing real D3D9, so don't do it!
#endif
		return D3DERR_INVALIDCALL;
	}

	IDirect3DTexture9Hook* textureHookPtr = dynamic_cast<IDirect3DTexture9Hook*>(pTexture);
	IDirect3DCubeTexture9Hook* cubeHookPtr = dynamic_cast<IDirect3DCubeTexture9Hook*>(pTexture);
	IDirect3DVolumeTexture9Hook* volumeHookPtr = dynamic_cast<IDirect3DVolumeTexture9Hook*>(pTexture);
	const IDirect3DBaseTexture9Hook* const baseHookPtr = dynamic_cast<IDirect3DBaseTexture9Hook*>(pTexture);
	if (textureHookPtr)
		pTexture = textureHookPtr->GetUnderlyingTexture();
	else if (cubeHookPtr)
		pTexture = cubeHookPtr->GetUnderlyingCubeTexture();
	else if (volumeHookPtr)
		pTexture = volumeHookPtr->GetUnderlyingVolumeTexture();
	else if (baseHookPtr)
		pTexture = baseHookPtr->GetUnderlyingBaseTexture();
#ifdef _DEBUG
	else if (pTexture != NULL)
	{
		// Unknown texture type passed to SetTexture!
		DbgBreakPrint("Error: Unknown texture type passed to SetTexture (not a 2D texture, volume texture, or cube texture)");
	}
#endif

	HRESULT ret = d3d9dev->SetTexture(Stage, pTexture);
	if (FAILED(ret) )
		return ret;

#ifdef DUMP_TEXTURES_ON_FIRST_SET
	if (textureHookPtr)
	{
		++textureHookPtr->dumped;
		if (textureHookPtr->dumped == 16)
		{
			LPDIRECT3DSURFACE9 surf0 = NULL;
			textureHookPtr->GetSurfaceLevel(0, &surf0);
			IDirect3DSurface9Hook* surfHook = dynamic_cast<IDirect3DSurface9Hook*>(surf0);
			if (!surfHook)
			{
				DbgBreakPrint("Error: Unable to GetSurfaceLevel0 from texture");
			}
			surfHook->DumpSurfaceToDisk();
		}
	}
#endif

	if (Stage >= ARRAYSIZE(currentState.currentTextures) )
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Texture index out of bounds");
#endif
		return D3DERR_INVALIDCALL;
	}

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetTextureCaptured(Stage);
	}
	else
		targetDeviceState = &currentState;

	if (textureHookPtr)
	{
		targetDeviceState->currentTextures[Stage] = textureHookPtr;
		targetDeviceState->currentCubeTextures[Stage] = NULL;
		targetDeviceState->currentVolumeTextures[Stage] = NULL;
	}
	else if (cubeHookPtr)
	{
		targetDeviceState->currentTextures[Stage] = NULL;
		targetDeviceState->currentCubeTextures[Stage] = cubeHookPtr;
		targetDeviceState->currentVolumeTextures[Stage] = NULL;
	}
	else if (volumeHookPtr)
	{
		targetDeviceState->currentTextures[Stage] = NULL;
		targetDeviceState->currentCubeTextures[Stage] = NULL;
		targetDeviceState->currentVolumeTextures[Stage] = volumeHookPtr;
	}
	else
	{
		targetDeviceState->currentTextures[Stage] = NULL;
		targetDeviceState->currentCubeTextures[Stage] = NULL;
		targetDeviceState->currentVolumeTextures[Stage] = NULL;
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetTextureStageState(THIS_ DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD* pValue)
{
	DWORD realValue = 0x00000000;
	HRESULT ret = d3d9dev->GetTextureStageState(Stage, Type, &realValue);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (realValue != currentState.currentStageStates[Stage].stageStateUnion.state[Type])
	{
		DbgBreakPrint("Error: Internal texture stage state doesn't match texture stage state");
	}
#endif

	if (Stage >= MAX_NUM_TEXTURE_STAGE_STATES)
		return D3DERR_INVALIDCALL;

	if (Type < D3DTSS_COLOROP || Type > D3DTSS_CONSTANT)
		return D3DERR_INVALIDCALL;
	
	if (pValue)
	{
		*pValue = currentState.currentStageStates[Stage].stageStateUnion.state[Type];
		return ret;
	}
	else
		return D3DERR_INVALIDCALL;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetTextureStageState(THIS_ DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value)
{
	HRESULT ret = d3d9dev->SetTextureStageState(Stage, Type, Value);
	if (FAILED(ret) )
		return ret;

	if (Stage >= MAX_NUM_TEXTURE_STAGE_STATES)
		return D3DERR_INVALIDCALL;

	if (Type < D3DTSS_COLOROP || Type > D3DTSS_CONSTANT)
		return D3DERR_INVALIDCALL;

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetTextureStageStateCaptured(Stage, Type);
	}
	else
		targetDeviceState = &currentState;

	targetDeviceState->currentStageStates[Stage].stageStateUnion.state[Type] = Value;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetSamplerState(THIS_ DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD* pValue)
{
	DWORD outVal = 0x00000000;
	HRESULT ret = d3d9dev->GetSamplerState(Sampler, Type, &outVal);
	if (FAILED(ret) )
		return ret;

	if (Type < D3DSAMP_ADDRESSU || Type > D3DSAMP_DMAPOFFSET)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Type is out of bounds");
#endif
		return D3DERR_INVALIDCALL;
	}

#ifdef _DEBUG
	if (currentState.currentSamplerStates[Sampler].stateUnion.state[Type] != outVal)
	{
		DbgBreakPrint("Error: Internal sampler state doesn't match sampler state");
	}
#endif

	if (pValue)
	{
		*pValue = currentState.currentSamplerStates[Sampler].stateUnion.state[Type];
		return ret;
	}
	else
		return D3DERR_INVALIDCALL;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetSamplerState(THIS_ DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD Value)
{
	HRESULT ret = d3d9dev->SetSamplerState(Sampler, Type, Value);
	if (FAILED(ret) )
		return ret;

	if (Type < D3DSAMP_ADDRESSU)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Sampler state type out of bounds (0 is not a valid sampler state enum)");
#endif
		return D3DERR_INVALIDCALL;
	}
	else if (Type > D3DSAMP_DMAPOFFSET)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Sampler state type out of bounds");
#endif
		return D3DERR_INVALIDCALL;
	}

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetSamplerStateCaptured(Sampler, Type);
	}
	else
		targetDeviceState = &currentState;

	SamplerState& thisSampler = targetDeviceState->currentSamplerStates[Sampler];
	thisSampler.stateUnion.state[Type] = Value;

	if (Type == D3DSAMP_MAXMIPLEVEL)
	{
		thisSampler.cachedFloatMaxMipLevel = (const float)Value;
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetPaletteEntries(THIS_ UINT PaletteNumber, CONST PALETTEENTRY* pEntries)
{
	HRESULT ret = d3d9dev->SetPaletteEntries(PaletteNumber, pEntries);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (PaletteNumber > 65535)
	{
		// Spec says the limit is 64k on PaletteNumbers
		DbgBreakPrint("Error: Palette number out of bounds");
	}
#endif

	if (PaletteNumber >= currentState.currentPaletteState.paletteEntries->size() )
	{
		currentState.currentPaletteState.paletteEntries->resize(PaletteNumber + 1);
	}

	if (pEntries != NULL)
	{
		memcpy( (*currentState.currentPaletteState.paletteEntries)[PaletteNumber].entries, pEntries, sizeof(TexturePaletteEntry) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetPaletteEntries(THIS_ UINT PaletteNumber, PALETTEENTRY* pEntries)
{
	HRESULT ret = d3d9dev->GetPaletteEntries(PaletteNumber, pEntries);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (PaletteNumber > 65535)
	{
		// Spec says the limit is 64k on PaletteNumbers
		DbgBreakPrint("Error: Palette number out of bounds");
	}
#endif

	if (PaletteNumber >= currentState.currentPaletteState.paletteEntries->size() )
	{
		currentState.currentPaletteState.paletteEntries->resize(PaletteNumber + 1);
	}

#ifdef _DEBUG
	if (pEntries != NULL)
	{
		if (memcmp(pEntries, (*currentState.currentPaletteState.paletteEntries)[PaletteNumber].entries, sizeof(TexturePaletteEntry) ) != 0)
		{
			DbgBreakPrint("Error: Internal palette doesn't match palette");
		}
	}
#endif

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetCurrentTexturePalette(THIS_ UINT PaletteNumber)
{
	HRESULT ret = d3d9dev->SetCurrentTexturePalette(PaletteNumber);
	if (FAILED(ret) )
		return ret;

	if (PaletteNumber > 0xFFFF)
	{
#ifdef _DEBUG
		__debugbreak(); // Error: Palette index out of bounds!
#endif
		return D3DERR_INVALIDCALL;
	}

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetCurrentTexturePalette>();
	}
	else
		targetDeviceState = &currentState;

	targetDeviceState->currentPaletteState.currentPaletteIndex = (const unsigned short)PaletteNumber;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetCurrentTexturePalette(THIS_ UINT *PaletteNumber)
{
	HRESULT ret = d3d9dev->GetCurrentTexturePalette(PaletteNumber);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (PaletteNumber != NULL)
	{
		if (*PaletteNumber != currentState.currentPaletteState.currentPaletteIndex)
		{
			DbgBreakPrint("Error: Internal palette doesn't match palette");
		}
	}
#endif

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetScissorRect(THIS_ CONST RECT* pRect)
{
	HRESULT ret = d3d9dev->SetScissorRect(pRect);
	if (FAILED(ret) )
		return ret;

	// Real D3D9 crashes if you try to call SetScissorRect() with a NULL pointer, so we can do pretty much whatever we want in this case
	if (pRect != NULL)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetScissorRect>();
		}
		else
			targetDeviceState = &currentState;

		targetDeviceState->currentScissorRect.scissorRect = *pRect;
		targetDeviceState->currentScissorRect.RecomputeScissorRect();
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetScissorRect(THIS_ RECT* pRect)
{
	HRESULT ret = d3d9dev->GetScissorRect(pRect);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (pRect)
	{
		if (memcmp(pRect, &currentState.currentScissorRect.scissorRect, sizeof(RECT) ) != 0)
		{
			DbgBreakPrint("Error: Internal scissor rect doesn't match scissor rect");
		}
	}
#endif

	return ret;
}

// One interesting note about SetSoftwareVertexProcessing is that the documentation explicitly calls out that because this used to be a render-state back in the D3D8 days, in
// D3D9 this API is *not* captured by state-blocks on purpose.
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetSoftwareVertexProcessing(THIS_ BOOL bSoftware)
{
	HRESULT ret = d3d9dev->SetSoftwareVertexProcessing(bSoftware);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (initialCreateFlags & D3DCREATE_MIXED_VERTEXPROCESSING)
	{
	}
	else
	{
		// Spec says that it's illegal to call SetSoftwareVertexProcessing() on a non-mixed-mode device: https://msdn.microsoft.com/en-us/library/windows/desktop/bb174458(v=vs.85).aspx
		DbgBreakPrint("Error: Spec says that it's illegal to call SetSoftwareVertexProcessing() on a non-mixed-mode device");
	}

	// Spec says it's illegal to call SetSoftwareVertexProcessing() from within a BeginScene()/EndScene() block
	if (HasBegunScene() )
	{
		DbgBreakPrint("Error: Spec says it's illegal to call SetSoftwareVertexProcessing() from within a BeginScene()/EndScene() block");
	}
#endif

	currentSwvpEnabled = bSoftware;

	return ret;
}

COM_DECLSPEC_NOTHROW BOOL STDMETHODCALLTYPE IDirect3DDevice9Hook::GetSoftwareVertexProcessing(THIS)
{
#ifdef _DEBUG
	BOOL realRet = d3d9dev->GetSoftwareVertexProcessing();
	if (realRet != currentSwvpEnabled)
	{
		DbgBreakPrint("Error: Internal SWVP doesn't match SWVP");
	}
#endif

	return currentSwvpEnabled;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetNPatchMode(THIS_ float nSegments)
{
	HRESULT ret = d3d9dev->SetNPatchMode(nSegments);
	if (FAILED(ret) )
		return ret;

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetNPatchMode>();
	}
	else
		targetDeviceState = &currentState;

	targetDeviceState->currentNPatchMode = nSegments;

	return ret;
}

COM_DECLSPEC_NOTHROW float STDMETHODCALLTYPE IDirect3DDevice9Hook::GetNPatchMode(THIS)
{
#ifdef _DEBUG
	const float realNPatchMode = d3d9dev->GetNPatchMode();
	if (realNPatchMode != currentState.currentNPatchMode)
	{
		// Real device divergence detected!
		__debugbreak();
	}
#endif
	return currentState.currentNPatchMode;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetVertexDeclaration(THIS_ IDirect3DVertexDeclaration9* pDecl)
{
	IDirect3DVertexDeclaration9Hook* hook = dynamic_cast<IDirect3DVertexDeclaration9Hook*>(pDecl);
	if (hook)
		pDecl = hook->GetUnderlyingVertexDeclaration();
#ifdef _DEBUG
	else if (pDecl != NULL)
	{
		DbgBreakPrint("Error: Vertex declaration is not hooked");
	}
#endif

	HRESULT ret = d3d9dev->SetVertexDeclaration(pDecl);
	if (FAILED(ret) )
		return ret;

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetVertexDeclaration>();
	}
	else
		targetDeviceState = &currentState;

	if (targetDeviceState->currentVertexDecl != NULL)
	{
		// targetDeviceState->currentVertexDecl->Release();
	}

	const IDirect3DVertexDeclaration9Hook* const oldVertDecl = targetDeviceState->currentVertexDecl;
	if (oldVertDecl != hook)
	{
		// Set dirty flags on stream-ends for used streams for this new decl:
		if (hook != NULL)
		{
			const std::vector<DebuggableD3DVERTEXELEMENT9>& elements = hook->GetElementsInternal();
			const unsigned numElements = elements.size() - 1; // Minus one here because we want to ignore the D3DDECL_END element
			for (unsigned x = 0; x < numElements; ++x)
			{
				const DebuggableD3DVERTEXELEMENT9& thisElement = elements[x];
				targetDeviceState->currentStreamEnds[thisElement.Stream].SetDirty();
			}
		}
	}

	targetDeviceState->currentVertexDecl = hook;

	if (pDecl)
	{
		targetDeviceState->declTarget = DeviceState::targetVertexDecl;
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetVertexDeclaration(THIS_ IDirect3DVertexDeclaration9** ppDecl)
{
	LPDIRECT3DVERTEXDECLARATION9 realVertDecl = NULL;
	HRESULT ret = d3d9dev->GetVertexDeclaration(&realVertDecl);
	if (FAILED(ret) )
		return ret;

	if (!ppDecl)
		return D3DERR_INVALIDCALL;

#ifdef _DEBUG
	if (currentState.declTarget == DeviceState::targetFVF)
	{
		// TODO: Implement this case of a FVF auto-converted to a valid vertex decl!
		DbgBreakPrint("Error: Automatic up-conversion of FVF code to vertex declaration is not yet supported");
	}

	if ( (realVertDecl != NULL) != (currentState.currentVertexDecl != NULL) )
	{
		DbgBreakPrint("Error: Internal vertex declaration doesn't match vertex declaration (one is NULL, one is non-NULL)");
	}
	if (realVertDecl != currentState.currentVertexDecl->GetUnderlyingVertexDeclaration() )
	{
		DbgBreakPrint("Error: Internal vertex declaration doesn't match vertex declaration");
	}
#endif
	*ppDecl = currentState.currentVertexDecl;
	if (currentState.currentVertexDecl)
		currentState.currentVertexDecl->AddRef();

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetFVF(THIS_ DWORD FVF)
{
	debuggableFVF dbgFVF;
	dbgFVF.rawFVF_DWORD = FVF;

	HRESULT ret = d3d9dev->SetFVF(dbgFVF.rawFVF_DWORD);
	if (FAILED(ret) )
		return ret;

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetFVF>();
	}
	else
		targetDeviceState = &currentState;

	const DWORD oldFVF_DWORD = targetDeviceState->currentFVF.rawFVF_DWORD;
	targetDeviceState->currentFVF.rawFVF_DWORD = dbgFVF.rawFVF_DWORD;

	if (dbgFVF.rawFVF_DWORD != 0x00000000)
	{
		// Skip setting the same FVF/decl twice
		if (targetDeviceState->declTarget == DeviceState::targetFVF && oldFVF_DWORD == dbgFVF.rawFVF_DWORD)
			return ret;

		targetDeviceState->declTarget = DeviceState::targetFVF;

		// D3D9 does some weird stuff under the hood if you call SetFVF with a valid FVF-code. It needs to:
		// 1) Release any existing set vertex declarations
		// 2) Create a new implicit vertex declaration (retrievable only via GetVertexDeclaration() )
		// 3) Assign that new implicit vertex declaration
		CreateVertexDeclFromFVFCode(dbgFVF);
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetFVF(THIS_ DWORD* pFVF)
{
	if (!pFVF)
		return D3DERR_INVALIDCALL;

	*pFVF = currentState.currentFVF.rawFVF_DWORD;

#ifdef _DEBUG
	debuggableFVF dbgFVF;
	dbgFVF.rawFVF_DWORD = 0x00000000;
	HRESULT ret = d3d9dev->GetFVF(&dbgFVF.rawFVF_DWORD);
	if (FAILED(ret) )
	{
		__debugbreak(); // We missed an error case!
	}
	if (dbgFVF.rawFVF_DWORD != currentState.currentFVF.rawFVF_DWORD)
	{
		DbgBreakPrint("Error: Internal FVF doesn't match FVF");
	}
	return ret;
#else // #ifdef _DEBUG
	return S_OK;
#endif // #ifdef _DEBUG
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetVertexShader(THIS_ IDirect3DVertexShader9* pShader)
{
	IDirect3DVertexShader9Hook* hookPtr = dynamic_cast<IDirect3DVertexShader9Hook*>(pShader);
	if (hookPtr)
		pShader = hookPtr->GetUnderlyingVertexShader();
#ifdef _DEBUG
	else if (pShader != NULL)
	{
		DbgBreakPrint("Error: Vertex shader is not hooked");
	}
#endif

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetVertexShader>();
	}
	else
		targetDeviceState = &currentState;

	if (targetDeviceState->currentVertexShader != NULL)
	{
		// targetDeviceState->currentVertexShader->Release();
	}

	targetDeviceState->currentVertexShader = hookPtr;

	if (hookPtr)
	{
		if (!hookPtr->triedJit)
		{
			hookPtr->JitLoadShader();
		}
	}

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetVertexShader(THIS_ IDirect3DVertexShader9** ppShader)
{
	LPDIRECT3DVERTEXSHADER9 realShader = NULL;
	HRESULT ret = d3d9dev->GetVertexShader(&realShader);
	if (FAILED(ret) )
		return ret;

	if (!ppShader)
		return D3DERR_INVALIDCALL;

#ifdef _DEBUG
	if ( (realShader != NULL) != (currentState.currentVertexShader != NULL) )
	{
		DbgBreakPrint("Error: Internal vertex shader doesn't match vertex shader (one is non-NULL and the other is NULL)");
	}
	if (realShader != NULL)
	{
		if (realShader != currentState.currentVertexShader->GetUnderlyingVertexShader() )
		{
			DbgBreakPrint("Error: Internal vertex shader doesn't match vertex shader");
		}
	}
#endif

	*ppShader = currentState.currentVertexShader;
	if (currentState.currentVertexShader)
		currentState.currentVertexShader->AddRef();

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetVertexShaderConstantF(THIS_ UINT StartRegister, CONST float* pConstantData, UINT Vector4fCount)
{
	HRESULT ret = d3d9dev->SetVertexShaderConstantF(StartRegister, pConstantData, Vector4fCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.vertexShaderRegisters.floats) )
	{
		DbgBreakPrint("Error: Vertex shader constant index out of range");
	}
	if (StartRegister + Vector4fCount > ARRAYSIZE(currentState.vertexShaderRegisters.floats) )
	{
		DbgBreakPrint("Error: Vertex shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			const unsigned finalSetRegister = StartRegister + Vector4fCount;
			for (unsigned constantIndex = StartRegister; constantIndex < finalSetRegister; ++constantIndex)
				currentlyRecordingStateBlock->MarkSetVertexShaderConstantF(constantIndex);
		}
		else
			targetDeviceState = &currentState;

		memcpy(targetDeviceState->vertexShaderRegisters.floats + StartRegister, pConstantData, Vector4fCount * sizeof(float4) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetVertexShaderConstantF(THIS_ UINT StartRegister, float* pConstantData, UINT Vector4fCount)
{
	HRESULT ret = d3d9dev->GetVertexShaderConstantF(StartRegister, pConstantData, Vector4fCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.vertexShaderRegisters.floats) )
	{
		DbgBreakPrint("Error: Vertex shader constant index out of range");
	}
	if (StartRegister + Vector4fCount > ARRAYSIZE(currentState.vertexShaderRegisters.floats) )
	{
		DbgBreakPrint("Error: Vertex shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
#ifdef _DEBUG
		if (memcmp(currentState.vertexShaderRegisters.floats + StartRegister, pConstantData, Vector4fCount * sizeof(float4) ) != 0)
		{
			DbgBreakPrint("Error: Internal vertex shader constant doesn't match vertex shader constant");
		}
#endif
		memcpy(pConstantData, currentState.vertexShaderRegisters.floats + StartRegister, Vector4fCount * sizeof(float4) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetVertexShaderConstantI(THIS_ UINT StartRegister, CONST int* pConstantData, UINT Vector4iCount)
{
	HRESULT ret = d3d9dev->SetVertexShaderConstantI(StartRegister, pConstantData, Vector4iCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.vertexShaderRegisters.ints) )
	{
		DbgBreakPrint("Error: Vertex shader constant index out of range");
	}
	if (StartRegister + Vector4iCount > ARRAYSIZE(currentState.vertexShaderRegisters.ints) )
	{
		DbgBreakPrint("Error: Vertex shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			const unsigned finalSetRegister = StartRegister + Vector4iCount;
			for (unsigned constantIndex = StartRegister; constantIndex < finalSetRegister; ++constantIndex)
				currentlyRecordingStateBlock->MarkSetVertexShaderConstantI(constantIndex);
		}
		else
			targetDeviceState = &currentState;

		memcpy(targetDeviceState->vertexShaderRegisters.ints + StartRegister, pConstantData, Vector4iCount * sizeof(int4) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetVertexShaderConstantI(THIS_ UINT StartRegister, int* pConstantData, UINT Vector4iCount)
{
	HRESULT ret = d3d9dev->GetVertexShaderConstantI(StartRegister, pConstantData, Vector4iCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.vertexShaderRegisters.ints) )
	{
		DbgBreakPrint("Error: Vertex shader constant index out of range");
	}
	if (StartRegister + Vector4iCount > ARRAYSIZE(currentState.vertexShaderRegisters.ints) )
	{
		DbgBreakPrint("Error: Vertex shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
#ifdef _DEBUG
		if (memcmp(currentState.vertexShaderRegisters.ints + StartRegister, pConstantData, Vector4iCount * sizeof(int4) ) != 0)
		{
			DbgBreakPrint("Error: Internal vertex shader constant doesn't match vertex shader constant");
		}
#endif
		memcpy(pConstantData, currentState.vertexShaderRegisters.ints + StartRegister, Vector4iCount * sizeof(int4) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetVertexShaderConstantB(THIS_ UINT StartRegister, CONST BOOL* pConstantData, UINT BoolCount)
{
	HRESULT ret = d3d9dev->SetVertexShaderConstantB(StartRegister, pConstantData, BoolCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.vertexShaderRegisters.bools) )
	{
		DbgBreakPrint("Error: Vertex shader constant index out of range");
	}
	if (StartRegister + BoolCount > ARRAYSIZE(currentState.vertexShaderRegisters.bools) )
	{
		DbgBreakPrint("Error: Vertex shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			const unsigned finalSetRegister = StartRegister + BoolCount;
			for (unsigned constantIndex = StartRegister; constantIndex < finalSetRegister; ++constantIndex)
				currentlyRecordingStateBlock->MarkSetVertexShaderConstantB(constantIndex);
		}
		else
			targetDeviceState = &currentState;

		memcpy(targetDeviceState->vertexShaderRegisters.bools + StartRegister, pConstantData, BoolCount * sizeof(BOOL) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetVertexShaderConstantB(THIS_ UINT StartRegister, BOOL* pConstantData, UINT BoolCount)
{
	HRESULT ret = d3d9dev->GetVertexShaderConstantB(StartRegister, pConstantData, BoolCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.vertexShaderRegisters.bools) )
	{
		DbgBreakPrint("Error: Vertex shader constant index out of range");
	}
	if (StartRegister + BoolCount > ARRAYSIZE(currentState.vertexShaderRegisters.bools) )
	{
		DbgBreakPrint("Error: Vertex shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
#ifdef _DEBUG
		if (memcmp(currentState.vertexShaderRegisters.bools + StartRegister, pConstantData, BoolCount * sizeof(BOOL) ) != 0)
		{
			DbgBreakPrint("Error: Internal vertex shader constant doesn't match vertex shader constant");
		}
#endif
		memcpy(pConstantData, currentState.vertexShaderRegisters.bools + StartRegister, BoolCount * sizeof(BOOL) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetStreamSource(THIS_ UINT StreamNumber, IDirect3DVertexBuffer9* pStreamData, UINT OffsetInBytes, UINT Stride)
{
	if (StreamNumber >= MAX_D3D9_STREAMS)
		return D3DERR_INVALIDCALL;

	IDirect3DVertexBuffer9Hook* hookPtr = dynamic_cast<IDirect3DVertexBuffer9Hook*>(pStreamData);
	if (hookPtr)
		pStreamData = hookPtr->GetUnderlyingVertexBuffer();
#ifdef _DEBUG
	else if (pStreamData != NULL)
	{
		DbgBreakPrint("Error: Vertex buffer is not hooked!");
	}
#endif
	// We need to stuff our stream stride into a uint16, so we can't have larger strides than that
	if (Stride > 0xFFFF)
		return D3DERR_INVALIDCALL;

	HRESULT ret = d3d9dev->SetStreamSource(StreamNumber, pStreamData, OffsetInBytes, Stride);
	if (FAILED(ret) )
		return ret;

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetStreamSourceCaptured(StreamNumber);
	}
	else
		targetDeviceState = &currentState;

	StreamSource& thisStreamSource = targetDeviceState->currentStreams[StreamNumber];

	if (thisStreamSource.vertexBuffer != NULL)
	{
		// thisStreamSource.vertexBuffer->Release();
	}

	const IDirect3DVertexBuffer9Hook* const oldVertexBuffer = thisStreamSource.vertexBuffer;

	thisStreamSource.vertexBuffer = hookPtr;
	thisStreamSource.streamOffset = OffsetInBytes;
	thisStreamSource.streamStride = (const unsigned short)Stride;

	if (oldVertexBuffer != hookPtr)
	{
		targetDeviceState->currentStreamEnds[StreamNumber].SetDirty();
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetStreamSource(THIS_ UINT StreamNumber, IDirect3DVertexBuffer9** ppStreamData, UINT* pOffsetInBytes, UINT* pStride)
{
	if (StreamNumber >= MAX_D3D9_STREAMS)
		return D3DERR_INVALIDCALL;

	LPDIRECT3DVERTEXBUFFER9 realStream = NULL;
	HRESULT ret = d3d9dev->GetStreamSource(StreamNumber, &realStream, pOffsetInBytes, pStride);
	if (FAILED(ret) )
		return ret;

	const StreamSource& currentStream = currentState.currentStreams[StreamNumber];

#ifdef _DEBUG
	if ( (realStream != NULL) != (currentStream.vertexBuffer != NULL) )
	{
		DbgBreakPrint("Error: Internal Vertex stream source doesn't match stream source (one is non-NULL and the other is NULL)");
	}
	if (realStream != currentStream.vertexBuffer->GetUnderlyingVertexBuffer() )
	{
		DbgBreakPrint("Error: Internal Vertex stream source doesn't match stream source");
	}
	if (*pOffsetInBytes != currentStream.streamOffset)
	{
		DbgBreakPrint("Error: Internal Vertex stream source doesn't match stream source offset");
	}
	if (*pStride != currentStream.streamStride)
	{
		DbgBreakPrint("Error: Internal Vertex stream source doesn't match stream source stride");
	}
#endif
	if (ppStreamData)
	{
		*ppStreamData = currentStream.vertexBuffer;
		if (currentStream.vertexBuffer)
			currentStream.vertexBuffer->AddRef();
	}

	if (pOffsetInBytes)
		*pOffsetInBytes = currentStream.streamOffset;

	if (pStride)
		*pStride = currentStream.streamStride;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetStreamSourceFreq(THIS_ UINT StreamNumber, UINT Setting)
{
	if (StreamNumber >= MAX_D3D9_STREAMS)
		return D3DERR_INVALIDCALL;

	HRESULT ret = d3d9dev->SetStreamSourceFreq(StreamNumber, Setting);
	if (FAILED(ret) )
		return ret;

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetStreamSourceFreqCaptured(StreamNumber);
	}
	else
		targetDeviceState = &currentState;

	targetDeviceState->currentStreams[StreamNumber].streamDividerFrequency = Setting;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetStreamSourceFreq(THIS_ UINT StreamNumber, UINT* pSetting)
{
	HRESULT ret = d3d9dev->GetStreamSourceFreq(StreamNumber, pSetting);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (*pSetting != currentState.currentStreams[StreamNumber].streamDividerFrequency)
	{
		DbgBreakPrint("Error: Vertex stream source freq doesn't match stream source freq");
	}
#endif

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetIndices(THIS_ IDirect3DIndexBuffer9* pIndexData)
{
	IDirect3DIndexBuffer9Hook* hook = dynamic_cast<IDirect3DIndexBuffer9Hook*>(pIndexData);
	if (hook)
		pIndexData = hook->GetUnderlyingIndexBuffer();
#ifdef _DEBUG
	else if (pIndexData != NULL)
	{
		DbgBreakPrint("Error: Index buffer is not hooked!");
	}
#endif

	if (pIndexData == NULL)
	{
		return D3DERR_INVALIDCALL;
	}

	if (currentState.currentIndexBuffer != NULL)
	{
		// currentState.currentIndexBuffer->Release();
	}

	// Active state block recording redirects state writes into the state block rather than to the real device
	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetIndices>();
	}
	else
		targetDeviceState = &currentState;

	targetDeviceState->currentIndexBuffer = hook;

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetIndices(THIS_ IDirect3DIndexBuffer9** ppIndexData)
{
	LPDIRECT3DINDEXBUFFER9 realIndices = NULL;
	HRESULT ret = d3d9dev->GetIndices(&realIndices);
	if (FAILED(ret) )
		return ret;

	if (!ppIndexData)
		return D3DERR_INVALIDCALL;

#ifdef _DEBUG
	if ( (realIndices != NULL) != (currentState.currentIndexBuffer != NULL) )
	{
		DbgBreakPrint("Error: Internal indices don't match indices (one is non-NULL and the other is NULL)");
	}
	if (realIndices != currentState.currentIndexBuffer->GetUnderlyingIndexBuffer() )
	{
		DbgBreakPrint("Error: Internal indices don't match indices");
	}
#endif
	*ppIndexData = currentState.currentIndexBuffer;
	if (currentState.currentIndexBuffer)
		currentState.currentIndexBuffer->AddRef();

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetPixelShader(THIS_ IDirect3DPixelShader9* pShader)
{
	IDirect3DPixelShader9Hook* hookPtr = dynamic_cast<IDirect3DPixelShader9Hook*>(pShader);
	if (hookPtr)
		pShader = hookPtr->GetUnderlyingPixelShader();
#ifdef _DEBUG
	else if (pShader != NULL)
	{
		DbgBreakPrint("Error: Pixel shader is not hooked");
	}
#endif

	DeviceState* targetDeviceState;
	if (IsCurrentlyRecordingStateBlock() )
	{
		targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
		currentlyRecordingStateBlock->MarkSetCallAsCaptured<SBT_SetPixelShader>();
	}
	else
		targetDeviceState = &currentState;

	if (targetDeviceState->currentPixelShader != NULL)
	{
		// targetDeviceState->currentPixelShader->Release();
	}

	targetDeviceState->currentPixelShader = hookPtr;

	if (hookPtr)
	{
		if (!hookPtr->triedJit)
		{
			hookPtr->JitLoadShader();
		}
	}

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetPixelShader(THIS_ IDirect3DPixelShader9** ppShader)
{
	LPDIRECT3DPIXELSHADER9 realShader = NULL;
	HRESULT ret = d3d9dev->GetPixelShader(&realShader);
	if (FAILED(ret) )
		return ret;

	if (!ppShader)
		return D3DERR_INVALIDCALL;

#ifdef _DEBUG
	if ( (realShader != NULL) != (currentState.currentPixelShader != NULL) )
	{
		DbgBreakPrint("Error: Internal pixel shader doesn't match pixel shader (one is non-NULL and the other is NULL)");
	}
	if (realShader != NULL)
	{
		if (realShader != currentState.currentPixelShader->GetUnderlyingPixelShader() )
		{
			DbgBreakPrint("Error: Internal pixel shader doesn't match pixel shader");
		}
	}
#endif

	*ppShader = currentState.currentPixelShader;
	if (currentState.currentPixelShader)
		currentState.currentPixelShader->AddRef();

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetPixelShaderConstantF(THIS_ UINT StartRegister, CONST float* pConstantData, UINT Vector4fCount)
{
	HRESULT ret = d3d9dev->SetPixelShaderConstantF(StartRegister, pConstantData, Vector4fCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.pixelShaderRegisters.floats) )
	{
		DbgBreakPrint("Error: Pixel shader constant index out of range");
	}
	if (StartRegister + Vector4fCount > ARRAYSIZE(currentState.pixelShaderRegisters.floats) )
	{
		DbgBreakPrint("Error: Pixel shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			const unsigned finalSetRegister = StartRegister + Vector4fCount;
			for (unsigned constantIndex = StartRegister; constantIndex < finalSetRegister; ++constantIndex)
				currentlyRecordingStateBlock->MarkSetPixelShaderConstantF(constantIndex);
		}
		else
			targetDeviceState = &currentState;

		memcpy(targetDeviceState->pixelShaderRegisters.floats + StartRegister, pConstantData, Vector4fCount * sizeof(float4) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetPixelShaderConstantF(THIS_ UINT StartRegister, float* pConstantData, UINT Vector4fCount)
{
	HRESULT ret = d3d9dev->GetPixelShaderConstantF(StartRegister, pConstantData, Vector4fCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.pixelShaderRegisters.floats) )
	{
		DbgBreakPrint("Error: Pixel shader constant index out of range");
	}
	if (StartRegister + Vector4fCount > ARRAYSIZE(currentState.pixelShaderRegisters.floats) )
	{
		DbgBreakPrint("Error: Pixel shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
#ifdef _DEBUG
		if (memcmp(currentState.pixelShaderRegisters.floats + StartRegister, pConstantData, Vector4fCount * sizeof(float4) ) != 0)
		{
			DbgBreakPrint("Error: Internal pixel shader constant doesn't match pixel shader constant");
		}
#endif
		memcpy(pConstantData, currentState.pixelShaderRegisters.floats + StartRegister, Vector4fCount * sizeof(float4) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetPixelShaderConstantI(THIS_ UINT StartRegister, CONST int* pConstantData, UINT Vector4iCount)
{
	HRESULT ret = d3d9dev->SetPixelShaderConstantI(StartRegister, pConstantData, Vector4iCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.pixelShaderRegisters.ints) )
	{
		DbgBreakPrint("Error: Pixel shader constant index out of range");
	}
	if (StartRegister + Vector4iCount > ARRAYSIZE(currentState.pixelShaderRegisters.ints) )
	{
		DbgBreakPrint("Error: Pixel shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			const unsigned finalSetRegister = StartRegister + Vector4iCount;
			for (unsigned constantIndex = StartRegister; constantIndex < finalSetRegister; ++constantIndex)
				currentlyRecordingStateBlock->MarkSetPixelShaderConstantI(constantIndex);
		}
		else
			targetDeviceState = &currentState;

		memcpy(targetDeviceState->pixelShaderRegisters.ints + StartRegister, pConstantData, Vector4iCount * sizeof(int4) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetPixelShaderConstantI(THIS_ UINT StartRegister, int* pConstantData, UINT Vector4iCount)
{
	HRESULT ret = d3d9dev->GetPixelShaderConstantI(StartRegister, pConstantData, Vector4iCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.pixelShaderRegisters.ints) )
	{
		DbgBreakPrint("Error: Pixel shader constant index out of range");
	}
	if (StartRegister + Vector4iCount > ARRAYSIZE(currentState.pixelShaderRegisters.ints) )
	{
		DbgBreakPrint("Error: Pixel shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
#ifdef _DEBUG
		if (memcmp(currentState.pixelShaderRegisters.ints + StartRegister, pConstantData, Vector4iCount * sizeof(int4) ) != 0)
		{
			DbgBreakPrint("Error: Internal pixel shader constant doesn't match pixel shader constant");
		}
#endif
		memcpy(pConstantData, currentState.pixelShaderRegisters.ints + StartRegister, Vector4iCount * sizeof(int4) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetPixelShaderConstantB(THIS_ UINT StartRegister, CONST BOOL* pConstantData, UINT BoolCount)
{
	HRESULT ret = d3d9dev->SetPixelShaderConstantB(StartRegister, pConstantData, BoolCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.pixelShaderRegisters.bools) )
	{
		DbgBreakPrint("Error: Pixel shader constant index out of range");
	}
	if (StartRegister + BoolCount > ARRAYSIZE(currentState.pixelShaderRegisters.bools) )
	{
		DbgBreakPrint("Error: Pixel shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
		DeviceState* targetDeviceState;
		if (IsCurrentlyRecordingStateBlock() )
		{
			targetDeviceState = currentlyRecordingStateBlock->GetDeviceStateForWrite();
			const unsigned finalSetRegister = StartRegister + BoolCount;
			for (unsigned constantIndex = StartRegister; constantIndex < finalSetRegister; ++constantIndex)
				currentlyRecordingStateBlock->MarkSetPixelShaderConstantB(constantIndex);
		}
		else
			targetDeviceState = &currentState;

		memcpy(targetDeviceState->pixelShaderRegisters.bools + StartRegister, pConstantData, BoolCount * sizeof(BOOL) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::GetPixelShaderConstantB(THIS_ UINT StartRegister, BOOL* pConstantData, UINT BoolCount)
{
	HRESULT ret = d3d9dev->GetPixelShaderConstantB(StartRegister, pConstantData, BoolCount);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (StartRegister > ARRAYSIZE(currentState.pixelShaderRegisters.bools) )
	{
		DbgBreakPrint("Error: Pixel shader constant index out of range");
	}
	if (StartRegister + BoolCount > ARRAYSIZE(currentState.pixelShaderRegisters.bools) )
	{
		DbgBreakPrint("Error: Pixel shader constant range extends out of range");
	}
#endif

	if (pConstantData != NULL)
	{
#ifdef _DEBUG
		if (memcmp(currentState.pixelShaderRegisters.bools + StartRegister, pConstantData, BoolCount * sizeof(BOOL) ) != 0)
		{
			DbgBreakPrint("Error: Internal pixel shader constant doesn't match pixel shader constant");
		}
#endif
		memcpy(pConstantData, currentState.pixelShaderRegisters.bools + StartRegister, BoolCount * sizeof(BOOL) );
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::SetRenderTarget(THIS_ DWORD RenderTargetIndex, IDirect3DSurface9* pRenderTarget)
{
	IDirect3DSurface9Hook* hookPtr = dynamic_cast<IDirect3DSurface9Hook*>(pRenderTarget);
	if (hookPtr)
		pRenderTarget = hookPtr->GetUnderlyingSurface();
#ifdef _DEBUG
	else if (pRenderTarget != NULL)
	{
		DbgBreakPrint("Error: SetRenderTarget called with a non-hooked surface pointer");
	}
#endif
	HRESULT ret = d3d9dev->SetRenderTarget(RenderTargetIndex, pRenderTarget);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	// Illegal to set render target index 0 to NULL, it must always be pointing to a valid surface
	if (RenderTargetIndex == 0 && !hookPtr)
	{
		DbgBreakPrint("Error: Illegal to set render target 0 to NULL");
	}
#endif

	if (RenderTargetIndex < D3D_MAX_SIMULTANEOUS_RENDERTARGETS)
		currentState.currentRenderTargets[RenderTargetIndex] = hookPtr;
#ifdef _DEBUG
	else
	{
		DbgBreakPrint("Error: Render target index out of range");
	}
#endif

	if (hookPtr)
	{
		hookPtr->AddRef();

		// In the case of a successful render-target set, the viewport is automatically resized to the
		// size of the largest set render-target:
		AutoResizeViewport();

		// TODO: Reset the scissor rect as well
		// "IDirect3DDevice9::SetRenderTarget resets the scissor rectangle to the full render target, analogous to the viewport reset."
		// Source: https://docs.microsoft.com/en-us/windows/desktop/direct3d9/scissor-test
	}

	return ret;
}

```

`Software_d3d9/IDirect3DDevice9Hook_Creators.cpp`:

```cpp
#pragma once

#include "GlobalToggles.h"
#include "IDirect3DDevice9Hook.h"
#include "IDirect3DSurface9Hook.h"
#include "IDirect3DTexture9Hook.h"
#include "IDirect3DVolumeTexture9Hook.h"
#include "IDirect3DCubeTexture9Hook.h"
#include "IDirect3DVertexBuffer9Hook.h"
#include "IDirect3DIndexBuffer9Hook.h"
#include "IDirect3DVertexShader9Hook.h"
#include "IDirect3DPixelShader9Hook.h"
#include "IDirect3DVertexDeclaration9Hook.h"
#include "IDirect3DStateBlock9Hook.h"
#include "IDirect3DQuery9Hook.h"

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateAdditionalSwapChain(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DSwapChain9** pSwapChain)
{
	// TODO: Implement this for reals
	HRESULT ret = d3d9dev->CreateAdditionalSwapChain(pPresentationParameters, pSwapChain);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateTexture(THIS_ UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DTexture9** ppTexture, HANDLE* pSharedHandle)
{
	HRESULT ret = d3d9dev->CreateTexture(Width, Height, Levels, Usage, Format, Pool, ppTexture, pSharedHandle);
	if (FAILED(ret) )
		return ret;

	if (ppTexture)
	{
		IDirect3DTexture9Hook* hookRet = new IDirect3DTexture9Hook(*ppTexture, this);
		hookRet->CreateTexture(Width, Height, Levels, (const DebuggableUsage)Usage, Format, Pool);
		*ppTexture = hookRet;
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateVolumeTexture(THIS_ UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DVolumeTexture9** ppVolumeTexture, HANDLE* pSharedHandle)
{
	HRESULT ret = d3d9dev->CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture, pSharedHandle);
	if (FAILED(ret) )
		return ret;

	if (ppVolumeTexture)
	{
		IDirect3DVolumeTexture9Hook* hookRet = new IDirect3DVolumeTexture9Hook(*ppVolumeTexture, this);
		hookRet->CreateVolumeTexture(Width, Height, Depth, Levels, (const DebuggableUsage)Usage, Format, Pool);
		*ppVolumeTexture = hookRet;
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateCubeTexture(THIS_ UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DCubeTexture9** ppCubeTexture, HANDLE* pSharedHandle)
{
	HRESULT ret = d3d9dev->CreateCubeTexture(EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture, pSharedHandle);
	if (FAILED(ret) )
		return ret;

	if (ppCubeTexture)
	{
		IDirect3DCubeTexture9Hook* hookRet = new IDirect3DCubeTexture9Hook(*ppCubeTexture, this);
		hookRet->CreateCubeTexture(EdgeLength, Levels, (const DebuggableUsage)Usage, Format, Pool);
		*ppCubeTexture = hookRet;
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateVertexBuffer(THIS_ UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, IDirect3DVertexBuffer9** ppVertexBuffer, HANDLE* pSharedHandle)
{
	LPDIRECT3DVERTEXBUFFER9 realObject = NULL;
	HRESULT ret = d3d9dev->CreateVertexBuffer(Length, Usage, FVF, Pool, &realObject, pSharedHandle);
	if (FAILED(ret) )
		return ret;

	IDirect3DVertexBuffer9Hook* const newVertexBuffer = new IDirect3DVertexBuffer9Hook(realObject, this);
	newVertexBuffer->CreateVertexBuffer(Length, (const DebuggableUsage)Usage, FVF, Pool);
	*ppVertexBuffer = newVertexBuffer;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateIndexBuffer(THIS_ UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DIndexBuffer9** ppIndexBuffer, HANDLE* pSharedHandle)
{
	if (Length == 0)
		return D3DERR_INVALIDCALL;

	switch (Format)
	{
	case D3DFMT_INDEX16:
		if (Length < sizeof(unsigned short) )
			return D3DERR_INVALIDCALL;
		if (Length % sizeof(unsigned short) != 0)
			return D3DERR_INVALIDCALL;
		break;
	case D3DFMT_INDEX32:
		if (Length < sizeof(unsigned long) )
			return D3DERR_INVALIDCALL;
		if (Length % sizeof(unsigned long) != 0)
			return D3DERR_INVALIDCALL;
		break;
	default:
		return D3DERR_INVALIDCALL;
	}

	LPDIRECT3DINDEXBUFFER9 realObject = NULL;
	HRESULT ret = d3d9dev->CreateIndexBuffer(Length, Usage, Format, Pool, &realObject, pSharedHandle);
	if (FAILED(ret) )
		return ret;

	IDirect3DIndexBuffer9Hook* const newIndexBuffer = new IDirect3DIndexBuffer9Hook(realObject, this);
	newIndexBuffer->CreateIndexBuffer(Length, (const DebuggableUsage)Usage, Format, Pool);
	*ppIndexBuffer = newIndexBuffer;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateRenderTarget(THIS_ UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Lockable, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle)
{
	LPDIRECT3DSURFACE9 realObject = NULL;
	HRESULT ret = d3d9dev->CreateRenderTarget(Width, Height, Format, MultiSample, MultisampleQuality, Lockable, &realObject, pSharedHandle);
	if (FAILED(ret) )
		return ret;

	IDirect3DSurface9Hook* const newSurface = new IDirect3DSurface9Hook(realObject, this);
	newSurface->CreateRenderTarget(Width, Height, Format, MultiSample, MultisampleQuality, Lockable);
	*ppSurface = newSurface;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateDepthStencilSurface(THIS_ UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Discard, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle)
{
	LPDIRECT3DSURFACE9 realObject = NULL;
	HRESULT ret = d3d9dev->CreateDepthStencilSurface(Width, Height, Format, MultiSample, MultisampleQuality, Discard, &realObject, pSharedHandle);
	if (FAILED(ret) )
		return ret;

	IDirect3DSurface9Hook* const newSurface = new IDirect3DSurface9Hook(realObject, this);
	newSurface->CreateDepthStencilSurface(Width, Height, Format, MultiSample, MultisampleQuality, Discard);
	*ppSurface = newSurface;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateOffscreenPlainSurface(THIS_ UINT Width, UINT Height, D3DFORMAT Format, D3DPOOL Pool, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle)
{
	LPDIRECT3DSURFACE9 realObject = NULL;
	HRESULT ret = d3d9dev->CreateOffscreenPlainSurface(Width, Height, Format, Pool, &realObject, pSharedHandle);
	if (FAILED(ret) )
		return ret;

	if (ppSurface)
	{
		IDirect3DSurface9Hook* const newSurface = new IDirect3DSurface9Hook(realObject, this);
		newSurface->CreateOffscreenPlainSurface(Width, Height, Format, Pool);
		*ppSurface = newSurface;
		return ret;
	}
	else
	{
		realObject->Release();
		return D3DERR_INVALIDCALL;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateStateBlock(THIS_ D3DSTATEBLOCKTYPE Type, IDirect3DStateBlock9** ppSB)
{
#ifdef _DEBUG
	char buffer[256];
#pragma warning(push)
#pragma warning(disable:4996)
	sprintf(buffer, "CreateStateBlock(Type: %u)\n", Type);
#pragma warning(pop)
	OutputDebugStringA(buffer);
#endif

	if (ppSB)
	{
		LPDIRECT3DSTATEBLOCK9 realStateBlock = NULL;
		HRESULT ret = d3d9dev->CreateStateBlock(Type, &realStateBlock);
		if (FAILED(ret) )
			return ret;

		void* const newStateBlockMemory = _aligned_malloc(sizeof(IDirect3DStateBlock9Hook), 16);
		if (!newStateBlockMemory)
			return D3DERR_OUTOFVIDEOMEMORY;

		const bool isCompleteStateBlock = true;
		IDirect3DStateBlock9Hook* newStateBlock = new (newStateBlockMemory) IDirect3DStateBlock9Hook(realStateBlock, this, isCompleteStateBlock);
		newStateBlock->InitializeListAndCapture(Type);
		*ppSB = newStateBlock;
		return ret;
	}
	else
		return D3DERR_INVALIDCALL;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateVertexDeclaration(THIS_ CONST D3DVERTEXELEMENT9* pVertexElements, IDirect3DVertexDeclaration9** ppDecl)
{
	HRESULT ret = d3d9dev->CreateVertexDeclaration(pVertexElements, ppDecl);
	if (FAILED(ret) )
		return ret;

	IDirect3DVertexDeclaration9Hook* hook = new IDirect3DVertexDeclaration9Hook(*ppDecl, this);
	debuggableFVF noFVF;
	noFVF.rawFVF_DWORD = 0x00000000;
	hook->CreateVertexDeclaration( (const DebuggableD3DVERTEXELEMENT9* const)pVertexElements, noFVF);
	*ppDecl = hook;

	return ret;
}

// This is not an official D3D9 function, even though it looks like one. It is only used internally.
COM_DECLSPEC_NOTHROW HRESULT IDirect3DDevice9Hook::CreateVertexDeclarationFromFVF(THIS_ CONST D3DVERTEXELEMENT9* pVertexElements, IDirect3DVertexDeclaration9** ppDecl, const debuggableFVF FVF)
{
	HRESULT ret = d3d9dev->CreateVertexDeclaration(pVertexElements, ppDecl);
	if (FAILED(ret) )
		return ret;

	IDirect3DVertexDeclaration9Hook* hook = new IDirect3DVertexDeclaration9Hook(*ppDecl, this);
	hook->CreateVertexDeclaration( (const DebuggableD3DVERTEXELEMENT9* const)pVertexElements, FVF);
	*ppDecl = hook;

	return ret;
}

static const D3DDECLTYPE texCoordTypeLookup[4] =
{
	D3DDECLTYPE_FLOAT2,
	D3DDECLTYPE_FLOAT3,
	D3DDECLTYPE_FLOAT4,
	D3DDECLTYPE_FLOAT1
};

static const unsigned char texCoordSizeLookup[4] =
{
	sizeof(D3DXVECTOR2),
	sizeof(D3DXVECTOR3),
	sizeof(D3DXVECTOR4),
	sizeof(float)
};

// Copied this from the Windows 10 DDK header file "d3dhal.h"
// This is the rather underdocumented 0x2000 flag.
// It is a float1 channel on stream 0 with usage 0 that implies D3DDECLUSAGE_FOG.
// It is placed between the lighting attributes and the texcoords in the vertex struct.
// There's a little bit more info about it here: https://docs.microsoft.com/en-us/windows-hardware/drivers/display/clamping-fog-intensity-per-pixel
#ifndef D3DFVF_FOG
	#define D3DFVF_FOG 0x00002000L /* There is a separate fog value in the FVF vertex */
#endif

// This is not an official D3D9 function, even though it looks like one. It is only used internally.
// Most of these conversions came from this MSDN page: https://docs.microsoft.com/en-us/windows/win32/direct3d9/mapping-fvf-codes-to-a-directx-9-declaration
// The remainder of the conversions came from testing and seeing what happens.
// The test-set contained all 2^32 unique FVF codes, which should encompass all combinations of FVF codes. For all of those tested codes, the output of this function matches that of what the D3D9 runtime
// internally uses to convert FVF codes into vertex declarations.
/*
Undocumented/underdocumented D3D9 weird things:
- D3DFVF_FOG is listed as part of D3DFVF_RESERVED2 in the d3d9 headers, but it is listed in the Windows DDK as a separate FVF flag.
- If the FVF is 0x00000000 then the DrawPrimitive call gets dropped entirely for the fixed-function pipeline (although this could probably still work for the case of a vertex shader rendering a single point using shader constants for data).
- If both D3DFVF_LASTBETA_UBYTE4 and D3DFVF_LASTBETA_D3DCOLOR are set (probably not a "valid FVF", but the runtime seems to accept it anyway) then D3DFVF_LASTBETA_UBYTE4 takes precedence and D3DFVF_LASTBETA_D3DCOLOR gets ignored.
- D3DFVF_LASTBETA_UBYTE4 and D3DFVF_LASTBETA_D3DCOLOR are ignored for D3DFVF_XYZ, D3DFVF_XYZRHW, and D3DFVF_XYZW positions (they only work if one of the XYZBn positions are used).
- D3DFVF_XYZB1 with one of the LASTBETA flags produces a vertex with blend indices but no blend weights.
- D3DFVF_XYZB5 with none of the LASTBETA flags defined means that you get a "float4 blendweights0, float1 blendindices0" rather than what I would've initially thought ("float4 blendweights0, float1 blendweights1"). I guess B5 always implies indices, although I'm not sure what float indices means.
- It seems like the runtime handles D3DFVF_XYZB2 specially when it comes to the LASTBETA flags. It seems to *always* want to make the last element of type D3DDECLTYPE_UBYTE4, and then it switches between using D3DDECLTYPE_FLOAT1 and D3DDECLTYPE_D3DCOLOR for the first DWORD.
*/
IDirect3DVertexDeclaration9Hook* IDirect3DDevice9Hook::CreateVertexDeclFromFVFCode(const debuggableFVF FVF)
{
#ifndef NO_CACHING_FVF_VERT_DECLS
	const std::map<DWORD, IDirect3DVertexDeclaration9Hook*>::const_iterator it = FVFToVertDeclCache->find(FVF.rawFVF_DWORD);
	if (it != FVFToVertDeclCache->end() )
	{
		IDirect3DVertexDeclaration9Hook* const fvfVertDecl = it->second;
		SetVertexDeclaration(fvfVertDecl);
		return fvfVertDecl;
	}
#endif // NO_CACHING_FVF_VERT_DECLS

	// 24 is the worst-case number of decl elements (including the D3DDECL_END delimiter) because we could have this monsterous FVF code:
	// (D3DFVF_XYZB5 | D3DFVF_LASTBETA_D3DCOLOR | D3DFVF_LASTBETA_UBYTE4 | D3DFVF_NORMAL | D3DFVF_PSIZE | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | TEX15 | D3DFVF_FOG |
	// D3DFVF_TEXCOORDSIZE4(0) | D3DFVF_TEXCOORDSIZE4(1) | D3DFVF_TEXCOORDSIZE4(2) | D3DFVF_TEXCOORDSIZE4(3) | 
	// D3DFVF_TEXCOORDSIZE4(4) | D3DFVF_TEXCOORDSIZE4(5) | D3DFVF_TEXCOORDSIZE4(6) | D3DFVF_TEXCOORDSIZE4(7) )
	// That's 3 tokens from the "position" section (D3DFVF_XYZB5), 4 from the "attributes" section (D3DFVF_NORMAL | D3DFVF_PSIZE | D3DFVF_DIFFUSE | D3DFVF_SPECULAR), one from fog,
	// 15 tokens from the "texcoords" section (TEX8 and all of the D3DFVF_TEXCOORDSIZE4 macros), and one for the D3DDECL_END token.
	D3DVERTEXELEMENT9 elements[24] = {0};

	unsigned currentElementIndex = 0;
	unsigned short totalVertexSizeBytes = 0;
	const bool hasLastbeta = (FVF.rawFVF_DWORD & (D3DFVF_LASTBETA_D3DCOLOR | D3DFVF_LASTBETA_UBYTE4) ) != 0;
	BYTE lastBetaType;
	if (hasLastbeta)
	{
		// Check for D3DFVF_LASTBETA_UBYTE4 here first because it takes precedence over D3DFVF_LASTBETA_D3DCOLOR in the case that they are both defined at the same time
		if (FVF.namedFVF.lastBeta_UBYTE4)
		{
			lastBetaType = (const BYTE)D3DDECLTYPE_UBYTE4;
		}
		else
		{
			lastBetaType = (const BYTE)D3DDECLTYPE_D3DCOLOR;
		}
	}

	switch (FVF.rawFVF_DWORD & D3DFVF_POSITION_MASK)
	{
	case D3DFVF_XYZ:
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0};
		totalVertexSizeBytes += sizeof(D3DXVECTOR3);
	}
		break;
	case D3DFVF_XYZRHW:
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT4, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITIONT, 0};
		totalVertexSizeBytes += sizeof(D3DXVECTOR4);
	}
		break;
	case D3DFVF_XYZW:
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT4, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0};
		totalVertexSizeBytes += sizeof(D3DXVECTOR4);
	}
		break;
	case D3DFVF_XYZB1:
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0};
		totalVertexSizeBytes += sizeof(D3DXVECTOR3);

		if (hasLastbeta)
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, lastBetaType, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDINDICES, 0};
		else
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT1, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT, 0};
		totalVertexSizeBytes += sizeof(float);
	}
		break;
	case D3DFVF_XYZB2:
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0};
		totalVertexSizeBytes += sizeof(D3DXVECTOR3);

		if (hasLastbeta)
		{
			// Okay so this is undocumented and weird (and might be a bug?) but it seems like the runtime handles D3DFVF_XYZB2 specially when it comes to the LASTBETA flags. It seems to *always* want to make
			// the last element of type D3DDECLTYPE_UBYTE4, and then it switches between using D3DDECLTYPE_FLOAT1 and D3DDECLTYPE_D3DCOLOR for the first DWORD.
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, (const BYTE)(FVF.namedFVF.lastBeta_UBYTE4 ? D3DDECLTYPE_FLOAT1 : D3DDECLTYPE_D3DCOLOR), D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT, 0};
			totalVertexSizeBytes += sizeof(float);

			elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_UBYTE4, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDINDICES, 0};
			totalVertexSizeBytes += sizeof(DWORD);
		}
		else
		{
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT, 0};
			totalVertexSizeBytes += sizeof(D3DXVECTOR2);
		}
	}
		break;
	case D3DFVF_XYZB3:
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0};
		totalVertexSizeBytes += sizeof(D3DXVECTOR3);

		if (hasLastbeta)
		{
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT, 0};
			totalVertexSizeBytes += sizeof(D3DXVECTOR2);

			elements[currentElementIndex++] = {0, totalVertexSizeBytes, lastBetaType, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDINDICES, 0};
			totalVertexSizeBytes += sizeof(DWORD);
		}
		else
		{
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT, 0};
			totalVertexSizeBytes += sizeof(D3DXVECTOR3);
		}
	}
		break;
	case D3DFVF_XYZB4:
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0};
		totalVertexSizeBytes += sizeof(D3DXVECTOR3);

		if (hasLastbeta)
		{
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT, 0};
			totalVertexSizeBytes += sizeof(D3DXVECTOR3);

			elements[currentElementIndex++] = {0, totalVertexSizeBytes, lastBetaType, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDINDICES, 0};
			totalVertexSizeBytes += sizeof(DWORD);
		}
		else
		{
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT4, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT, 0};
			totalVertexSizeBytes += sizeof(D3DXVECTOR4);
		}
	}
		break;
	case D3DFVF_XYZB5:
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0};
		totalVertexSizeBytes += sizeof(D3DXVECTOR3);
		if (hasLastbeta)
		{
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT4, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT, 0};
			totalVertexSizeBytes += sizeof(D3DXVECTOR4);

			elements[currentElementIndex++] = {0, totalVertexSizeBytes, lastBetaType, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDINDICES, 0};
			totalVertexSizeBytes += sizeof(DWORD);
		}
		else
		{
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT4, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT, 0};
			totalVertexSizeBytes += sizeof(D3DXVECTOR4);

			// This is a weird thing, but D3D9 has the D3DFVF_XYZB5 case create "float1 blendindices0" for D3DFVF_XYZB5 when one of the LASTBETA flags aren't specified. We're going to
			// follow this exact behavior so that we can fully match the official D3D9 FVF to Decl conversion.
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT1, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDINDICES, 0};
			totalVertexSizeBytes += sizeof(float);
		}
	}
		break;
	}

	if (FVF.rawFVF_DWORD & D3DFVF_NORMAL)
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_NORMAL, 0};
		totalVertexSizeBytes += sizeof(D3DXVECTOR3);
	}

	if (FVF.rawFVF_DWORD & D3DFVF_PSIZE)
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT1, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_PSIZE, 0};
		totalVertexSizeBytes += sizeof(float);
	}

	if (FVF.rawFVF_DWORD & D3DFVF_DIFFUSE)
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR, 0};
		totalVertexSizeBytes += sizeof(D3DCOLOR);
	}

	if (FVF.rawFVF_DWORD & D3DFVF_SPECULAR)
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR, 1};
		totalVertexSizeBytes += sizeof(D3DCOLOR);
	}

	// The rather undocumented D3DFVF_FOG flag breaks the convention of all the other FVF flags of appearing "in order" as it actually comes *before* texcoords but *after* position and lighting attributes
	if (FVF.rawFVF_DWORD & D3DFVF_FOG)
	{
		elements[currentElementIndex++] = {0, totalVertexSizeBytes, D3DDECLTYPE_FLOAT1, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_FOG, 0};
		totalVertexSizeBytes += sizeof(float);
	}

	const unsigned numTexCoords = ( (FVF.rawFVF_DWORD & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT);
	for (BYTE x = 0; x < numTexCoords; ++x)
	{
		if (x < 8)
		{
			const unsigned texCoordTypeShift = (16 + x * 2);
			const unsigned texCoordTypeMask = 0x3 << texCoordTypeShift;
			const unsigned texCoordType = (FVF.rawFVF_DWORD & texCoordTypeMask) >> texCoordTypeShift;
			const D3DDECLTYPE texCoordTypeFormat = texCoordTypeLookup[texCoordType];
			const unsigned char texCoordTypeSize = texCoordSizeLookup[texCoordType];
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, (const BYTE)texCoordTypeFormat, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, x};
			totalVertexSizeBytes += texCoordTypeSize;
		}
		else // Since there are no more bits to read, all texcoords after TEX8 are assumed to be of "float2" format
		{
			const D3DDECLTYPE texCoordTypeFormat = D3DDECLTYPE_FLOAT2;
			const unsigned texCoordTypeSize = sizeof(D3DXVECTOR2);
			elements[currentElementIndex++] = {0, totalVertexSizeBytes, (const BYTE)texCoordTypeFormat, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, x};
			totalVertexSizeBytes += texCoordTypeSize;
		}
	}

	elements[currentElementIndex] = D3DDECL_END();

	IDirect3DVertexDeclaration9Hook* fvfVertexDecl = NULL;
	if (FAILED(CreateVertexDeclarationFromFVF(elements, (LPDIRECT3DVERTEXDECLARATION9*)&fvfVertexDecl, FVF) ) || !fvfVertexDecl)
	{
		DbgBreakPrint("Error: Failed to create vertex declaration");
	}

#ifndef NO_CACHING_FVF_VERT_DECLS
	fvfVertexDecl->AddRef();
	FVFToVertDeclCache->insert(std::make_pair(FVF.rawFVF_DWORD, fvfVertexDecl) );
#endif // NO_CACHING_FVF_VERT_DECLS

	if (FAILED(SetVertexDeclaration(fvfVertexDecl) ) )
	{
		DbgBreakPrint("Error: Failed to set vertex declaration");
	}

	return fvfVertexDecl;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateVertexShader(THIS_ CONST DWORD* pFunction, IDirect3DVertexShader9** ppShader)
{
	HRESULT ret = d3d9dev->CreateVertexShader(pFunction, ppShader);
	if (FAILED(ret) )
		return ret;

	IDirect3DVertexShader9Hook* hookObj = new IDirect3DVertexShader9Hook(*ppShader, this);
	hookObj->CreateVertexShader(pFunction);
	*ppShader = hookObj;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreatePixelShader(THIS_ CONST DWORD* pFunction, IDirect3DPixelShader9** ppShader)
{
	HRESULT ret = d3d9dev->CreatePixelShader(pFunction, ppShader);
	if (FAILED(ret) )
		return ret;

	IDirect3DPixelShader9Hook* hookObj = new IDirect3DPixelShader9Hook(*ppShader, this);
	hookObj->CreatePixelShader(pFunction);
	*ppShader = hookObj;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DDevice9Hook::CreateQuery(THIS_ D3DQUERYTYPE Type, IDirect3DQuery9** ppQuery) 
{
	HRESULT ret = d3d9dev->CreateQuery(Type, ppQuery);
	if (FAILED(ret) )
		return ret;

	// This parameter can be set to NULL to see if a query type is supported. If the query type is not supported, the method returns D3DERR_NOTAVAILABLE.
	// Source: https://msdn.microsoft.com/en-us/library/windows/desktop/bb174360(v=vs.85).aspx
	if (!ppQuery)
	{
		switch (Type)
		{
			// These are the only query types we support right now (they are also by far the most common types of queries used in D3D9):
		case D3DQUERYTYPE_EVENT:
		case D3DQUERYTYPE_OCCLUSION:
		case D3DQUERYTYPE_TIMESTAMP:
		case D3DQUERYTYPE_TIMESTAMPDISJOINT:
		case D3DQUERYTYPE_TIMESTAMPFREQ:
			break;
		default:
			return D3DERR_NOTAVAILABLE;
		}
	}
	else
	{
		IDirect3DQuery9Hook* newQuery = new IDirect3DQuery9Hook(*ppQuery, this);
		newQuery->CreateQuery(Type);
		*ppQuery = newQuery;
	}

	return ret;
}
```

`Software_d3d9/IDirect3DIndexBuffer9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DIndexBuffer9Hook.h"
#include "GlobalToggles.h"

void IDirect3DIndexBuffer9Hook::CreateIndexBuffer(UINT _Length, const DebuggableUsage _Usage, D3DFORMAT _Format, D3DPOOL _Pool)
{
	InternalLength = _Length;
	InternalUsage = _Usage;
	InternalFormat = _Format;
	InternalPool = _Pool;

	const unsigned magicDWORDBytes =
#ifdef INDEX_BUFFER_MAGIC_COOKIE
		sizeof(DWORD);
#else
		0;
#endif

#ifdef INDEX_BUFFER_ALLOC_PAGE_NOACCESS
	rawBytes.voidBytes = PageAllocWithNoAccessPage(InternalLength + magicDWORDBytes);
#else
	rawBytes.voidBytes = malloc(InternalLength + magicDWORDBytes);
#endif

#ifdef INDEX_BUFFER_MAGIC_COOKIE
	*(DWORD* const)&rawBytes.u8Bytes[InternalLength] = 'INDX';
#endif
}

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	if (realObject)
	{
		HRESULT ret = realObject->QueryInterface(riid, ppvObj);
		if (ret == NOERROR)
		{
			*ppvObj = this;
			AddRef();
		}
		return ret;
	}
	// TODO: Implement this properly
	return S_OK;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::AddRef(THIS)
{
	ULONG ret = realObject ? realObject->AddRef() : (const ULONG)(refCount + 1);
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::Release(THIS)
{
	ULONG ret = realObject ? realObject->Release() : (const ULONG)(refCount - 1);
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Index Buffer %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DResource9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	if (!ppDevice)
		return D3DERR_INVALIDCALL;

	if (realObject)
	{
		LPDIRECT3DDEVICE9 realD3D9dev = NULL;
		HRESULT ret = realObject->GetDevice(&realD3D9dev);
		if (FAILED(ret) )
		{
			*ppDevice = NULL;
			return ret;
		}

		// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
		if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
		{
			DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
		}
		parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

		*ppDevice = parentDevice;
		return ret;
	}
	else
	{
		*ppDevice = parentDevice;
		return S_OK;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags)
{
	if (realObject)
	{
		HRESULT ret = realObject->SetPrivateData(refguid, pData, SizeOfData, Flags);
		return ret;
	}
	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData)
{
	if (realObject)
	{
		HRESULT ret = realObject->GetPrivateData(refguid, pData, pSizeOfData);
		return ret;
	}
	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::FreePrivateData(THIS_ REFGUID refguid)
{
	if (realObject)
	{
		HRESULT ret = realObject->FreePrivateData(refguid);
		return ret;
	}
	return S_OK;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::SetPriority(THIS_ DWORD PriorityNew)
{
	if (realObject)
	{
		DWORD ret = realObject->SetPriority(PriorityNew);
		return ret;
	}
	return S_OK;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::GetPriority(THIS)
{
	if (realObject)
	{
		DWORD ret = realObject->GetPriority();
		return ret;
	}
	return 0;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::PreLoad(THIS)
{
	if (realObject)
		realObject->PreLoad();
}

COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::GetType(THIS)
{
	if (realObject)
	{
		D3DRESOURCETYPE ret = realObject->GetType();
#ifdef _DEBUG
		if (ret != D3DRTYPE_INDEXBUFFER)
		{
			__debugbreak(); // Uhhhhh, what's going on?
		}
#endif
		return ret;
	}
	return D3DRTYPE_INDEXBUFFER;
}

#ifdef INDEX_BUFFER_MAGIC_COOKIE
static inline void ValidateMagicCookie(const std::vector<unsigned short>& shorts, const std::vector<unsigned long>& longs, const unsigned length, const D3DFORMAT InternalFormat)
{
	switch (InternalFormat)
	{
	case D3DFMT_INDEX16:
		if (*(const DWORD* const)&shorts[length / sizeof(unsigned short)] != 'INDX')
		{
			__debugbreak();
		}
		break;
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case D3DFMT_INDEX32:
		if (longs[length / sizeof(unsigned long)] != 'INDX')
		{
			__debugbreak();
		}
		break;
	}
}
#endif // INDEX_BUFFER_MAGIC_COOKIE

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::Lock(THIS_ UINT OffsetToLock,UINT SizeToLock,void** ppbData,DWORD Flags)
{
	if (!ppbData)
		return D3DERR_INVALIDCALL;

	const DWORD validLockFlags = D3DLOCK_DISCARD | D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_NOSYSLOCK | D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE; 
	if (Flags & (~validLockFlags) )
		return D3DERR_INVALIDCALL; // These are the only D3DLOCK flags valid for this function call

	if (SizeToLock == 0 && OffsetToLock > 0)
		return D3DERR_INVALIDCALL;

	if (OffsetToLock + SizeToLock > InternalLength)
		return D3DERR_INVALIDCALL;

	if (Flags & (D3DLOCK_DISCARD | D3DLOCK_NOOVERWRITE) )
	{
		// D3D9 in Release mode ignores this error without returning a failure code
		if (!(InternalUsage & D3DUSAGE_DYNAMIC) )
			return D3DERR_INVALIDCALL;
	}

#ifdef INDEX_BUFFER_MAGIC_COOKIE
	ValidateMagicCookie(shortBytes, longBytes, InternalLength, InternalFormat);
#endif

#ifdef _DEBUG
	if (realObject)
	{
		void* tempLockPtr = NULL;
		HRESULT ret = realObject->Lock(OffsetToLock, SizeToLock, &tempLockPtr, Flags);
		if (FAILED(ret) )
		{
			__debugbreak(); // There was an error that we should have caught
			return ret;
		}
	}
#endif

#ifdef INDEX_BUFFER_ENFORCE_READONLY_WHILE_UNLOCKED
	if (IsUnlocked() )
	{
		BYTE* const pageStartAddr = (BYTE* const)(rawBytes.pointerNumber - (rawBytes.pointerNumber % 4096) );
		VirtualAlloc(pageStartAddr, InternalLength, MEM_COMMIT, PAGE_READWRITE);
	}
#endif

#ifdef INDEX_BUFFER_ENFORCE_DISCARD_ON_LOCK
	if ( (InternalUsage & D3DUSAGE_DYNAMIC) && (Flags & D3DLOCK_DISCARD) )
	{
		memset(rawBytes.u8Bytes, 0, InternalLength);
	}
#endif

	if (ppbData)
	{
		*ppbData = rawBytes.u8Bytes + OffsetToLock;
	}

	++lockCount;

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::Unlock(THIS)
{
#ifdef _DEBUG
	if (realObject)
	{
		HRESULT ret = realObject->Unlock();
		if (FAILED(ret) )
		{
			__debugbreak(); // There was an error and we should've caught it
			return ret;
		}
	}
#endif

#ifdef INDEX_BUFFER_MAGIC_COOKIE
	ValidateMagicCookie(shortBytes, longBytes, InternalLength, InternalFormat);
#endif

	--lockCount;

#ifdef INDEX_BUFFER_ENFORCE_READONLY_WHILE_UNLOCKED
	if (IsUnlocked() )
	{
		BYTE* const pageStartAddr = (BYTE* const)(rawBytes.pointerNumber - (rawBytes.pointerNumber % 4096) );
		VirtualAlloc(pageStartAddr, InternalLength, MEM_COMMIT, PAGE_READONLY);
	}
#endif

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DIndexBuffer9Hook::GetDesc(THIS_ D3DINDEXBUFFER_DESC *pDesc)
{
	if (!pDesc)
		return D3DERR_INVALIDCALL;

#ifdef _DEBUG
	if (realObject)
	{
		HRESULT ret = realObject->GetDesc(pDesc);
		if (FAILED(ret) )
		{
			__debugbreak(); // There was an error that we should have caught
			return ret;
		}

		if (pDesc->Size != InternalLength)
		{
			__debugbreak();
		}
		if (pDesc->Usage != InternalUsage)
		{
			__debugbreak();
		}
		if (pDesc->Format != InternalFormat)
		{
			__debugbreak();
		}
		if (pDesc->Pool != InternalPool)
		{
			__debugbreak();
		}
		if (pDesc->Type != D3DRTYPE_INDEXBUFFER)
		{
			__debugbreak();
		}
	}
#endif

	pDesc->Size = InternalLength;
	pDesc->Usage = InternalUsage;
	pDesc->Format = InternalFormat;
	pDesc->Pool = InternalPool;
	pDesc->Type = D3DRTYPE_INDEXBUFFER;

	return S_OK;
}

```

`Software_d3d9/IDirect3DIndexBuffer9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"
#include "IDirect3DResource9Hook.h"

class IDirect3DIndexBuffer9Hook : public IDirect3DIndexBuffer9
{
public:
	IDirect3DIndexBuffer9Hook(LPDIRECT3DINDEXBUFFER9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1),
		InternalLength(0), InternalUsage(UsageNone), InternalFormat(D3DFMT_UNKNOWN), InternalPool(D3DPOOL_DEFAULT), lockCount(0), isSoftIndexBufferUP(false)
	{
		rawBytes.voidBytes = NULL;

#ifdef _DEBUG
		if (realObject)
			memcpy(&Name, &realObject->Name, (char*)&realObject - (char*)&Name);
		else
			memset(&Name, 0x00000000, (char*)&realObject - (char*)&Name);
#endif
	}

	inline LPDIRECT3DINDEXBUFFER9 GetUnderlyingIndexBuffer(void) const
	{
		return realObject;
	}

	virtual ~IDirect3DIndexBuffer9Hook()
	{
#ifdef INDEX_BUFFER_ALLOC_PAGE_NOACCESS
		if (!isSoftIndexBufferUP)
		{
			if (rawBytes.voidBytes)
			{
				VirtualFree(rawBytes.voidBytes, 0, MEM_RELEASE);
				rawBytes.voidBytes = NULL;
			}
		}
#else
		if (isSoftIndexBufferUP)
		{
			if (rawBytes.voidBytes)
			{
				free(rawBytes.voidBytes);
				rawBytes.voidBytes = NULL;
			}
		}
#endif
		if (isSoftIndexBufferUP)
		{
			rawBytes.voidBytes = NULL;
			InternalFormat = D3DFMT_UNKNOWN;
		}

#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DResource9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreePrivateData(THIS_ REFGUID refguid) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetPriority(THIS_ DWORD PriorityNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetPriority(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE PreLoad(THIS) override;
    virtual COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE GetType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Lock(THIS_ UINT OffsetToLock,UINT SizeToLock,void** ppbData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unlock(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDesc(THIS_ D3DINDEXBUFFER_DESC *pDesc) override;

	inline const bool IsUnlocked(void) const
	{
		return lockCount == 0;
	}

	void CreateIndexBuffer(UINT _Length, const DebuggableUsage _Usage, D3DFORMAT _Format, D3DPOOL _Pool);

	inline const D3DFORMAT GetFormat(void) const
	{
		return InternalFormat;
	}

	inline const BYTE* const GetBufferBytes(void) const
	{
		return rawBytes.u8Bytes;
	}

	inline const UINT GetInternalLength(void) const
	{
		return InternalLength;
	}

	inline void MarkSoftBufferUP(const bool isSoftUPIndexBuffer)
	{
		isSoftIndexBufferUP = isSoftUPIndexBuffer;
	}

	inline void SoftUPSetInternalPointer(const void* const stream0IndicesUP, const D3DFORMAT newFormat, const D3DPRIMITIVETYPE PrimitiveType, const UINT PrimitiveCount)
	{
#ifdef _DEBUG
		if (!isSoftIndexBufferUP)
		{
			__debugbreak(); // What are you doing calling this on a regular index buffer?
		}
		if (rawBytes.voidBytes != NULL)
		{
			__debugbreak(); // Probably forgot a reset somewhere!
		}
		if (stream0IndicesUP == NULL)
		{
			__debugbreak(); // This should never happen, draw calls with NULL index data are invalid
		}
		if (newFormat < D3DFMT_INDEX16 || newFormat > D3DFMT_INDEX32)
		{
			__debugbreak(); // Invalid index format
		}
#endif
		rawBytes.voidBytes = (BYTE* const)stream0IndicesUP;
		InternalFormat = newFormat;

		unsigned indexCount;
		switch (PrimitiveType)
		{
		case D3DPT_POINTLIST:
			indexCount = PrimitiveCount;
			break;
		case D3DPT_LINELIST:
			indexCount = PrimitiveCount * 2;
			break;
		case D3DPT_LINESTRIP:
			indexCount = PrimitiveCount - 1;
			break;
		default:
#ifdef _DEBUG
			__debugbreak(); // Should never be here
#endif
		case D3DPT_TRIANGLELIST:
			indexCount = PrimitiveCount * 3;
			break;
		case D3DPT_TRIANGLESTRIP:
		case D3DPT_TRIANGLEFAN:
			indexCount = PrimitiveCount - 2;
			break;
		}

		const unsigned char singleIndexSize = (newFormat == D3DFMT_INDEX16) ? 2 : 4;
		InternalLength = indexCount * singleIndexSize;
	}

	inline void SoftUPResetInternalPointer(void)
	{
#ifdef _DEBUG
		if (!isSoftIndexBufferUP)
		{
			__debugbreak(); // What are you doing calling this on a regular index buffer?
		}
		if (rawBytes.voidBytes == NULL)
		{
			__debugbreak(); // You either did a reset twice in a row, or you forgot to set the pointer in the first place!
		}
#endif
		rawBytes.voidBytes = NULL;
		InternalFormat = D3DFMT_UNKNOWN;
		InternalLength = 0;
	}

protected:
	LPDIRECT3DINDEXBUFFER9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

public:
	UINT InternalLength;
	DebuggableUsage InternalUsage;
	D3DFORMAT InternalFormat;
	D3DPOOL InternalPool;

	long lockCount;
	bool isSoftIndexBufferUP;

	union
	{
		void* voidBytes;
		BYTE* u8Bytes;
		unsigned short* shortBytes;
		unsigned long* longBytes;
		SIZE_T pointerNumber;
	} rawBytes;
};

```

`Software_d3d9/IDirect3DPixelShader9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DPixelShader9Hook.h"
#include "ShaderBase.h"
#include "ShaderJIT.h"

static std::vector<IDirect3DPixelShader9Hook*> alivePixelShaders;

void IDirect3DPixelShader9Hook::CreatePixelShader(const DWORD* const pFunction)
{
	if (!pFunction)
		return;

	ShaderInfo tempPixelShaderInfo;
	AnalyzeShader(pFunction, tempPixelShaderInfo
#ifdef _DEBUG
		,"NonePS"
#endif
		);

	if (!tempPixelShaderInfo.isPixelShader)
	{
		// This is not a pixel shader!
		__debugbreak();
	}

	switch (tempPixelShaderInfo.shaderMajorVersion)
	{
	case 1:
	case 2:
	case 3:
		// We're good!
		break;
	default:
		// This is not a valid D3D9 shader!
		{
			__debugbreak();
		}
		break;
	}

	shaderBytecode.resize(tempPixelShaderInfo.shaderLengthDWORDs);
	memcpy(&shaderBytecode.front(), pFunction, tempPixelShaderInfo.shaderLengthDWORDs * sizeof(DWORD) );

	// Bad hack to rebase all of the pointer offsets, fix plz!
	AnalyzeShader(&shaderBytecode.front(), pixelShaderInfo
#ifdef _DEBUG
		,"NonePS"
#endif
		);

	parentDevice->LockDeviceCS();
	alivePixelShaders.push_back(this);
	parentDevice->UnlockDeviceCS();

	//JitLoadShader();
}

/*virtual*/ IDirect3DPixelShader9Hook::~IDirect3DPixelShader9Hook()
{
	parentDevice->LockDeviceCS();
	const unsigned numAliveShaders = alivePixelShaders.size();
	bool foundAndErased = false;
	for (unsigned x = 0; x < numAliveShaders; ++x)
	{
		if (alivePixelShaders[x] == this)
		{
			alivePixelShaders.erase(alivePixelShaders.begin() + x);
			foundAndErased = true;
			break;
		}
	}
#ifdef _DEBUG
	if (!foundAndErased)
	{
		__debugbreak(); // Should never be here!
	}
#endif
	parentDevice->UnlockDeviceCS();

	shaderBytecode.clear();
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
	memset(this, 0x00000000, sizeof(*this) - (sizeof(shaderBytecode) + sizeof(pixelShaderInfo) ) );
#endif
}

void IDirect3DPixelShader9Hook::JitLoadShader()
{
#ifdef FORCE_INTERPRETED_PIXEL_SHADER
	return;
#endif

	const char* const jitName = ConstructShaderJITName(pixelShaderInfo);
	char jitFilenameBuffer[MAX_PATH] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
	sprintf(jitFilenameBuffer, "%s\\%s.dll", shaderJITTempDirectory, jitName);
#pragma warning(pop)
	HMODULE hm = LoadLibraryA(jitFilenameBuffer);

#ifdef _M_X64
	static const char* const shaderMainExportName = "PixelShaderMain";
#else
	static const char* const shaderMainExportName = "@PixelShaderMain@4";
#endif

	triedJit = true;

	if (hm)
	{
		jitShaderMain = (PSEntry)GetProcAddress(hm, shaderMainExportName);
		if (!jitShaderMain)
		{
			DbgBreakPrint("Error: Cannot find PixelShaderMain in existing JIT DLL");
		}
	}
	else
	{
		if (!JITNewShader(pixelShaderInfo, jitName) )
		{
			DbgBreakPrint("Error: Failed to JIT Pixel Shader");
		}
		else
		{
			HMODULE hm2 = LoadLibraryA(jitFilenameBuffer);
			if (!hm2)
			{
				DbgBreakPrint("Error: Failed to load recently JIT'd Pixel Shader");
				return;
			}
			jitShaderMain = (PSEntry)GetProcAddress(hm2, shaderMainExportName);
			if (!jitShaderMain)
			{
				DbgBreakPrint("Error: Cannot find PixelShaderMain in newly created JIT DLL");
				return;
			}
		}
	}
}

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DPixelShader9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DPixelShader9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DPixelShader9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Pixel Shader %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DPixelShader9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DPixelShader9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DPixelShader9Hook::GetFunction(THIS_ void* pData,UINT* pSizeOfData)
{
	HRESULT ret = realObject->GetFunction(pData, pSizeOfData);
	return ret;
}

```

`Software_d3d9/IDirect3DPixelShader9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"
#include "ShaderAnalysis.h"

class PShaderEngine;

class IDirect3DPixelShader9Hook : public IDirect3DPixelShader9
{
public:
	IDirect3DPixelShader9Hook(LPDIRECT3DPIXELSHADER9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1), jitShaderMain(NULL), triedJit(false)
	{
#ifdef _DEBUG
		memcpy(&Version, &realObject->Version, (char*)&realObject - (char*)&Version);
#endif
	}

	inline LPDIRECT3DPIXELSHADER9 GetUnderlyingPixelShader(void) const
	{
		return realObject;
	}

	virtual ~IDirect3DPixelShader9Hook();

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DPixelShader9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFunction(THIS_ void* pData,UINT* pSizeOfData) override;

	void CreatePixelShader(const DWORD* const pFunction);

	inline const ShaderInfo& GetShaderInfo() const
	{
		return pixelShaderInfo;
	}

	inline ShaderInfo& GetModifyShaderInfo()
	{
		return pixelShaderInfo;
	}

	void JitLoadShader();

protected:
	LPDIRECT3DPIXELSHADER9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

public:
	typedef void (__fastcall *PSEntry)(PShaderEngine& ps);
	PSEntry jitShaderMain;

	bool triedJit;
protected:

	std::vector<DWORD> shaderBytecode;
	ShaderInfo pixelShaderInfo;
};

```

`Software_d3d9/IDirect3DQuery9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DQuery9Hook.h"

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DQuery9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DQuery9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DQuery9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Query %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DQuery9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DQuery9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW D3DQUERYTYPE STDMETHODCALLTYPE IDirect3DQuery9Hook::GetType(THIS)
{
#ifdef _DEBUG
	if (realObject->GetType() != queryType)
	{
		DbgBreakPrint("Error: Unsynchronized query types");
	}
#endif
	return queryType;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DQuery9Hook::GetDataSize(THIS)
{
	DWORD ret = 0;
	switch (queryType)
	{
	case D3DQUERYTYPE_EVENT:
		ret = sizeof(BOOL);
		break;
	case D3DQUERYTYPE_OCCLUSION:
		ret = sizeof(DWORD);
		break;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid query type specified");
#endif
	case D3DQUERYTYPE_VCACHE:
		ret = sizeof(D3DDEVINFO_VCACHE);
		break;
	case D3DQUERYTYPE_RESOURCEMANAGER:
		ret = sizeof(D3DDEVINFO_RESOURCEMANAGER);
		break;
	case D3DQUERYTYPE_VERTEXSTATS:
		ret = sizeof(D3DDEVINFO_D3DVERTEXSTATS);
		break;
	case D3DQUERYTYPE_TIMESTAMP:
		ret = sizeof(UINT64);
		break;
	case D3DQUERYTYPE_TIMESTAMPDISJOINT:
		ret = sizeof(BOOL);
		break;
	case D3DQUERYTYPE_TIMESTAMPFREQ:
		ret = sizeof(UINT64);
		break;
	case D3DQUERYTYPE_PIPELINETIMINGS:
		ret = sizeof(D3DDEVINFO_D3D9PIPELINETIMINGS);
		break;
	case D3DQUERYTYPE_INTERFACETIMINGS:
		ret = sizeof(D3DDEVINFO_D3D9INTERFACETIMINGS);
		break;
	case D3DQUERYTYPE_VERTEXTIMINGS:
		ret = sizeof(D3DDEVINFO_D3D9STAGETIMINGS);
		break;
	case D3DQUERYTYPE_PIXELTIMINGS: // Uhhhhhhhhhh, I guess this does the same thing as VERTEXTIMINGS?
		ret = sizeof(D3DDEVINFO_D3D9STAGETIMINGS);
		break;
	case D3DQUERYTYPE_BANDWIDTHTIMINGS:
		ret = sizeof(D3DDEVINFO_D3D9BANDWIDTHTIMINGS);
		break;
	case D3DQUERYTYPE_CACHEUTILIZATION:
		ret = sizeof(D3DDEVINFO_D3D9CACHEUTILIZATION);
		break;
	case D3DQUERYTYPE_MEMORYPRESSURE:
		ret = sizeof(D3DMEMORYPRESSURE);
		break;
	}

#ifdef _DEBUG
	if (ret != realObject->GetDataSize() )
	{
		DbgBreakPrint("Error: Mismatched query sizes");
	}
#endif
	return ret;
}

static inline const bool QueryTypeSupportsIssueBegin(const D3DQUERYTYPE TestType)
{
	switch (TestType)
	{
	default:
#ifdef _DEBUG
	{
		__debugbreak(); // Should never be here!
	}
#endif
	case D3DQUERYTYPE_EVENT:
	case D3DQUERYTYPE_RESOURCEMANAGER:
	case D3DQUERYTYPE_TIMESTAMP:
	case D3DQUERYTYPE_TIMESTAMPFREQ:
	case D3DQUERYTYPE_VCACHE:
	case D3DQUERYTYPE_VERTEXSTATS:
		return false;
	case D3DQUERYTYPE_OCCLUSION:
	case D3DQUERYTYPE_TIMESTAMPDISJOINT:
	case D3DQUERYTYPE_PIPELINETIMINGS:
	case D3DQUERYTYPE_INTERFACETIMINGS:
	case D3DQUERYTYPE_VERTEXTIMINGS:
	case D3DQUERYTYPE_PIXELTIMINGS:
	case D3DQUERYTYPE_BANDWIDTHTIMINGS:
	case D3DQUERYTYPE_CACHEUTILIZATION:
	case D3DQUERYTYPE_MEMORYPRESSURE:
		return true;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DQuery9Hook::Issue(THIS_ DWORD dwIssueFlags)
{
	if (dwIssueFlags > D3DISSUE_BEGIN)
	{
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid argument to IDirect3DQuery9::Issue()!");
#endif
		return D3DERR_INVALIDCALL;
	}

	if (dwIssueFlags & D3DISSUE_BEGIN)
	{
		if (!QueryTypeSupportsIssueBegin(queryType) )
		{
#ifdef _DEBUG
			DbgBreakPrint("Error: Can't call Issue(D3DISSUE_BEGIN) on this query type!");
#endif
			return D3DERR_INVALIDCALL;
		}
	}

#ifdef _DEBUG
	if (FAILED(realObject->Issue(dwIssueFlags) ) )
	{
		DbgBreakPrint("Error: Mismatched issue error code");
	}
#endif

	if (dwIssueFlags & D3DISSUE_BEGIN)
	{
		occlusionQueryStartPixelsPassed_Begin = parentDevice->OcclusionQuery_GetNumPixelsPassedZTest();
	}
	if (dwIssueFlags & D3DISSUE_END)
	{
		occlusionQueryStartPixelsPassed_End = parentDevice->OcclusionQuery_GetNumPixelsPassedZTest();
	}
	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DQuery9Hook::GetData(THIS_ void* pData, DWORD dwSize, DWORD dwGetDataFlags)
{
	// If you set dwSize to zero, you can use this method to poll the resource for the query status. pData may be NULL only if dwSize is 0.
	// The method returns S_OK if the query data is available and S_FALSE if it is not. These are considered successful return values.
	if (!pData && dwSize == 0)
	{
		return S_OK;
	}

	if (!pData)
	{
		return D3DERR_INVALIDCALL;
	}

	const DWORD requiredMinimumDataSize = GetDataSize();
	if (dwSize < requiredMinimumDataSize)
	{
		return D3DERR_INVALIDCALL;
	}

	if (dwGetDataFlags > D3DGETDATA_FLUSH)
	{
		return D3DERR_INVALIDCALL;
	}

#ifdef _DEBUG
	if (FAILED(realObject->GetData(pData, dwSize, dwGetDataFlags) ) )
	{
		DbgBreakPrint("Error: Mismatched GetData error code");
	}
#endif

	switch (queryType)
	{
	case D3DQUERYTYPE_EVENT:
	{
		BOOL* const bData = (BOOL* const)pData;
		*bData = TRUE;
		break;
	}
	case D3DQUERYTYPE_OCCLUSION:
	{
		DWORD* const dwData = (DWORD* const)pData;
		*dwData = (occlusionQueryStartPixelsPassed_End - occlusionQueryStartPixelsPassed_Begin);
		break;
	}
	case D3DQUERYTYPE_TIMESTAMP:
	{
		LARGE_INTEGER* const timestampData = (LARGE_INTEGER* const)pData;
		QueryPerformanceCounter(timestampData);
		break;
	}
	case D3DQUERYTYPE_TIMESTAMPDISJOINT:
	{
		BOOL* const timestampDisjointData = (BOOL* const)pData;
		*timestampDisjointData = FALSE; // Timestamp data is never disjoint for a purely CPU renderer because API's like QueryPerformanceCounter() will correct for changes in CPU frequency automatically.
		break;
	}
	case D3DQUERYTYPE_TIMESTAMPFREQ:
	{
		LARGE_INTEGER* const timestampFreq = (LARGE_INTEGER* const)pData;
		QueryPerformanceFrequency(timestampFreq);
		break;
	}
	case D3DQUERYTYPE_VCACHE:
	case D3DQUERYTYPE_RESOURCEMANAGER:
	case D3DQUERYTYPE_VERTEXSTATS:
	case D3DQUERYTYPE_PIPELINETIMINGS:
	case D3DQUERYTYPE_INTERFACETIMINGS:
	case D3DQUERYTYPE_VERTEXTIMINGS:
	case D3DQUERYTYPE_PIXELTIMINGS:
	case D3DQUERYTYPE_BANDWIDTHTIMINGS:
	case D3DQUERYTYPE_CACHEUTILIZATION:
	case D3DQUERYTYPE_MEMORYPRESSURE:
		break; // Not yet handled
	default:
#ifdef _DEBUG
	{
		__debugbreak(); // Should never be here
	}
#else
		__assume(0);
#endif
	}

	return S_OK;
}

void IDirect3DQuery9Hook::CreateQuery(const D3DQUERYTYPE _queryType)
{
	queryType = _queryType;

	switch (queryType)
	{
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Invalid query type specified");
#endif
	case D3DQUERYTYPE_VCACHE:
	case D3DQUERYTYPE_EVENT:
	case D3DQUERYTYPE_OCCLUSION:
	case D3DQUERYTYPE_RESOURCEMANAGER:
	case D3DQUERYTYPE_VERTEXSTATS:
	case D3DQUERYTYPE_TIMESTAMP:
	case D3DQUERYTYPE_TIMESTAMPDISJOINT:
	case D3DQUERYTYPE_TIMESTAMPFREQ:
	case D3DQUERYTYPE_PIPELINETIMINGS:
	case D3DQUERYTYPE_INTERFACETIMINGS:
	case D3DQUERYTYPE_VERTEXTIMINGS:
	case D3DQUERYTYPE_BANDWIDTHTIMINGS:
	case D3DQUERYTYPE_CACHEUTILIZATION:
	case D3DQUERYTYPE_MEMORYPRESSURE:
	case D3DQUERYTYPE_PIXELTIMINGS:
		break;
	}
}

```

`Software_d3d9/IDirect3DQuery9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

class IDirect3DQuery9Hook : public IDirect3DQuery9
{
public:
	IDirect3DQuery9Hook(LPDIRECT3DQUERY9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1), queryType( (const D3DQUERYTYPE)0),
		occlusionQueryStartPixelsPassed_Begin(0), occlusionQueryStartPixelsPassed_End(0)
	{
	}

	inline LPDIRECT3DQUERY9 GetUnderlyingQuery(void) const
	{
		return realObject;
	}

	virtual ~IDirect3DQuery9Hook()
	{
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DQuery9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW D3DQUERYTYPE STDMETHODCALLTYPE GetType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetDataSize(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Issue(THIS_ DWORD dwIssueFlags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetData(THIS_ void* pData, DWORD dwSize, DWORD dwGetDataFlags) override;

	void CreateQuery(const D3DQUERYTYPE _queryType);

protected:
	LPDIRECT3DQUERY9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

	D3DQUERYTYPE queryType;

	DWORD occlusionQueryStartPixelsPassed_Begin;
	DWORD occlusionQueryStartPixelsPassed_End;
};

```

`Software_d3d9/IDirect3DResource9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DResource9Hook.h"

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DResourceHook9::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DResourceHook9::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DResourceHook9::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Base Resource %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DResource9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DResourceHook9::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DResourceHook9::SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags)
{
	HRESULT ret = realObject->SetPrivateData(refguid, pData, SizeOfData, Flags);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DResourceHook9::GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData)
{
	HRESULT ret = realObject->GetPrivateData(refguid, pData, pSizeOfData);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DResourceHook9::FreePrivateData(THIS_ REFGUID refguid)
{
	HRESULT ret = realObject->FreePrivateData(refguid);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DResourceHook9::SetPriority(THIS_ DWORD PriorityNew)
{
	DWORD ret = realObject->SetPriority(PriorityNew);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DResourceHook9::GetPriority(THIS)
{
	DWORD ret = realObject->GetPriority();
	return ret;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DResourceHook9::PreLoad(THIS)
{
	realObject->PreLoad();
}

COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE IDirect3DResourceHook9::GetType(THIS)
{
	D3DRESOURCETYPE ret = realObject->GetType();
	return ret;
}

BYTE* const PageAllocWithNoAccessPage(const unsigned lenBytes)
{
	BYTE* voidBytes = NULL;
	BYTE* const pageAddress = (BYTE* const)VirtualAlloc(NULL, lenBytes + 4096, MEM_RESERVE, PAGE_NOACCESS);
	if (pageAddress)
	{
		if (!VirtualAlloc(pageAddress, lenBytes, MEM_COMMIT, PAGE_READWRITE) )
		{
			__debugbreak(); // Can't alloc our new surface
			VirtualFree(pageAddress, 0, MEM_RELEASE);
		}

		if (lenBytes % 4096 == 0)
			voidBytes = pageAddress;
		else
			voidBytes = pageAddress + (4096 - (lenBytes % 4096) );

		return voidBytes;
	}
	if (!voidBytes)
	{
		__debugbreak(); // Can't alloc our new surface!
	}

	return NULL;
}

```

`Software_d3d9/IDirect3DResource9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

class IDirect3DResourceHook9 : public IDirect3DResource9
{
public:

	IDirect3DResourceHook9(LPDIRECT3DRESOURCE9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1)
	{
	}

	virtual ~IDirect3DResourceHook9()
	{
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DResource9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreePrivateData(THIS_ REFGUID refguid) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetPriority(THIS_ DWORD PriorityNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetPriority(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE PreLoad(THIS) override;
    virtual COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE GetType(THIS) override;

protected:
	LPDIRECT3DRESOURCE9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;
};

BYTE* const PageAllocWithNoAccessPage(const unsigned lenBytes);

```

`Software_d3d9/IDirect3DStateBlock9Hook.cpp`:

```cpp
/*
State block notes:
IDirect3DDevice9::CreateStateBlock creates a new state block object and fills it with all of the (vertex | pixel | all) current device states.
Using IDirect3DDevice9::BeginStateBlock and ::EndStateBlock pairs also creates a new state block, but the state block returned via EndStateBlock() will only contain states set inbetween the pair of calls (and it will *not* contain any values for states not set inbetween those two calls). Any render-state changes set inside the Begin/End block do *not* make it through to the device! Instead, they are written to the recording state block.
Using IDirect3DStateBlock9::Apply applies the state data (which may be none) inside the state block to the device. 
IDirect3DStateBlock9::Capture copies the current device state into the state block, but unlike IDirect3DDevice9::CreateStateBlock(), the Capture() method only copies in state that exists in the state block (so if a render-state was not set in that state block, then that render-state won't be recorded into the state block when Capture() is called).

So implementation pseudocode might look like this:
IDirect3DDevice9::CreateStateBlock makes a new full state block with (all vertex | all pixel | all all) renderstates set to "recorded", and copies the complete device state inside of it. Once a render-state becomes "recorded" for a state block, that render state can never be reset to "not recorded".
IDirect3DDevice9::BeginStateBlock can create a new empty state block internally (with all states set to "not recorded"), and then whenever a state change occurs, that state in the internal state block becomes "recorded" and its state is copied into the state block rather than to the normal device's state. Then when ::EndStateBlock is called, the internal state block is returned to the caller.
IDirect3DStateBlock9::Apply iterates over all render-states that are marked as "recorded" and sets those on the owning IDirect3DDevice9 (the one that created it in the first place).
IDirect3DStateBlock9::Capture copies only the render-states that are marked as "recorded" from the owning IDirect3DDevice9 (the one that created it in the first place) at the time of the call to Capture(). This is a way to update the states within state blocks (although the list of "recorded" and "not recorded" states may never change after a state block is created).

Assorted verified behaviors and verified edge-cases:
BeginStateBlock(), BeginStateBlock() is disallowed without an EndStateBlock() inbetween (there can only be 0 or 1 active state-blocks per device).
Illegal calls to BeginStateBlock() while a state block is already being recorded do not result in the state block's state getting reset! The second BeginStateBlock returns without changing anything!
Similarly, EndStateBlock(), EndStateBlock() is disallowed without a BeginStateBlock() before each (you may only call EndStateBlock() when there is an actively recording state block). Doing an EndStateBlock(), EndStateBlock() pair results in the second call returning NULL.
You can apparently create empty state blocks with nothing in them that change no states.
Interestingly, calling GetRenderState() while in the process of capturing state for a state block returns the device's current state, *not* the currently-recording state block's current state.
Similarly, draw calls while in the process of capturing state for a state block seem to use the device state *before* the current state block began recording (so the process of recording states into a state block do not seem to modify the underlying device state until EndStateBlock() is called)
Calling Apply() on one state block while another is in the process of being recorded seems to be return an error code and drops the Apply() call from happening (the Apply() call during recording seems to not affect either the in-progress recording state block nor the underlying device, the call simply early-outs).
Calling Capture() on one state block while another is in the process of being recorded seems to be return an error code and drops the Capture() call from happening (the Capture() call during recording seems to not affect either the in-progress recording state block nor the underlying device, the call simply early-outs).
It seems that calling to record a state even if it's the same state that's currently set on the device still captures that state into the state block (so don't let the SetRenderState(), etc. caching logic allow state capturing to occur).

Open question notes:
Does MultiplyTransform() source its source matrix from an ongoing stateblock or have its result stored in a state block if there's a state block currently being recorded?
Does SetClipStatus() get captured?
Does SetCursorProperties() get captured?
Does SetDialogBoxMode() get captured?
Does SetGammaRamp() get captured?
Does ShowCursor() get captured?
Does SetPaletteEntries() get captured?
Does the state for SetFVF get captured in vertex/pixel/all state blocks?
If you enable or disable a light (using LightEnable) that doesn't exist in a state block and then apply that state block to a device where that light does exist, what happens?
Does the order which you re-apply saved states matter (for example, SetRenderTarget() also internally invokes SetViewport(), and SetFVF() also internally invokes SetVertexDeclaration(), so what happens if you capture both of those calls?)
Does the state for SetClipPlane() get captured in vertex/pixel/all state blocks?
Does capturing SetVertexDeclaration() then un-capture SetFVF() or vice-versa?
If a device is capturing while it performs a Draw() call with the fixed-function pipeline that internally invokes SetPixelShaderConstantF/SetVertexShaderConstantF, do those calls get captured or not captured?

Known captured API's:
* IDirect3DDevice9::LightEnable
* IDirect3DDevice9::SetClipPlane
* IDirect3DDevice9::SetCurrentTexturePalette
* IDirect3DDevice9::SetFVF
* IDirect3DDevice9::SetIndices
* IDirect3DDevice9::SetLight
* IDirect3DDevice9::SetMaterial
* IDirect3DDevice9::SetNPatchMode
* IDirect3DDevice9::SetPixelShader
* IDirect3DDevice9::SetPixelShaderConstantB
* IDirect3DDevice9::SetPixelShaderConstantF
* IDirect3DDevice9::SetPixelShaderConstantI
* IDirect3DDevice9::SetRenderState
* IDirect3DDevice9::SetSamplerState
* IDirect3DDevice9::SetScissorRect
* IDirect3DDevice9::SetStreamSource
* IDirect3DDevice9::SetStreamSourceFreq
* IDirect3DDevice9::SetTexture
* IDirect3DDevice9::SetTextureStageState
* IDirect3DDevice9::SetTransform
* IDirect3DDevice9::SetViewport
* IDirect3DDevice9::SetVertexDeclaration
* IDirect3DDevice9::SetVertexShader
* IDirect3DDevice9::SetVertexShaderConstantB
* IDirect3DDevice9::SetVertexShaderConstantF
* IDirect3DDevice9::SetVertexShaderConstantI
*/

#pragma once

#include "IDirect3DStateBlock9Hook.h"
#include "IDirect3DIndexBuffer9Hook.h"
#include "IDirect3DVertexBuffer9Hook.h"
#include "IDirect3DPixelShader9Hook.h"
#include "IDirect3DVertexShader9Hook.h"
#include "IDirect3DTexture9Hook.h"
#include "IDirect3DCubeTexture9Hook.h"
#include "IDirect3DVolumeTexture9Hook.h"
#include "IDirect3DVertexDeclaration9Hook.h"

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DStateBlock9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DStateBlock9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DStateBlock9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked State Block %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif

		// Because we are allocated via _aligned_alloc() and not from new, we need to manually handle this object's deletion rather than just calling operator delete on it:
		IDirect3DStateBlock9Hook* const thisPtr = this;
		thisPtr->~IDirect3DStateBlock9Hook();
		_aligned_free(thisPtr);
		// Make sure not to access any class members after this point, we've been deleted and freed now!
	}
	return ret;
}

/*** IDirect3DStateBlock9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DStateBlock9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DStateBlock9Hook::Capture(THIS)
{
#ifdef _DEBUG
	char buffer[256];
#pragma warning(push)
#pragma warning(disable:4996)
	sprintf(buffer, "IDirect3DStateBlock9::Capture()\n");
#pragma warning(pop)
	OutputDebugStringA(buffer);
#endif

	// It is illegal to call IDirect3DStateBlock9::Capture() while you are in the middle of recording another, different state block.
	// If you do this, then the capture is not actually applied, and the call gets dropped.
	if (parentDevice->IsCurrentlyRecordingStateBlock() )
	{
		return D3DERR_INVALIDCALL;
	}

	HRESULT ret = realObject->Capture();
	if (FAILED(ret) )
		return ret;

	const IDirect3DDevice9Hook* const constDevice = parentDevice;
	const DeviceState& currentParentDeviceState = constDevice->GetCurrentHookState();
	stateBlockState.CaptureCopyState(currentParentDeviceState);

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DStateBlock9Hook::Apply(THIS)
{
#ifdef _DEBUG
	char buffer[256];
#pragma warning(push)
#pragma warning(disable:4996)
	sprintf(buffer, "IDirect3DStateBlock9::Apply()\n");
#pragma warning(pop)
	OutputDebugStringA(buffer);
#endif

	// It is illegal to call IDirect3DStateBlock9::Apply() while you are in the middle of recording another, different state block.
	// If you do this, then the state is not actually applied, and the call gets dropped.
	if (parentDevice->IsCurrentlyRecordingStateBlock() )
	{
		return D3DERR_INVALIDCALL;
	}

	HRESULT ret = realObject->Apply();
	if (FAILED(ret) )
		return ret;

	// Set all captured states from the state block to the main device:

	// Render states:
	for (unsigned char x = 0; x < ARRAYSIZE(renderStateStateBlockTypes); ++x)
	{
		const D3DRENDERSTATETYPE typedRenderState = (const D3DRENDERSTATETYPE)x;
		const unsigned rsDwordIndex = typedRenderState / 32;
		const unsigned rsBitmask = 1 << (typedRenderState % 32);
		if (capturedStates.capturedRenderstates.captureRenderstate[rsDwordIndex] & rsBitmask)
			parentDevice->SetRenderState(typedRenderState, stateBlockState.currentRenderStates.renderStatesUnion.states[typedRenderState]);
	}

	for (unsigned char x = 0; x < D3DMAXUSERCLIPPLANES; ++x)
	{
		const unsigned cpBitmask = (1 << x);
		if (capturedStates.capturedUserClipPlanes.userClipPlanesBitmask & cpBitmask)
			parentDevice->SetClipPlane(x, &(stateBlockState.currentClippingPlanes[x].a) );
	}

	for (unsigned char x = 0; x < MAX_D3D9_STREAMS; ++x)
	{
		const unsigned streamNumberBitmask = (1 << x);
		if (capturedStates.capturedStreamSources.streamSourcesBitmask & streamNumberBitmask)
		{
			const StreamSource& thisStream = stateBlockState.currentStreams[x];
			parentDevice->SetStreamSource(x, thisStream.vertexBuffer, thisStream.streamOffset, thisStream.streamStride);
		}

		if (capturedStates.capturedStreamSourceFreq.streamSourceFreqBitmask & streamNumberBitmask)
			parentDevice->SetStreamSourceFreq(x, stateBlockState.currentStreams[x].streamDividerFrequency);
	}

	// Transforms:
	if (capturedStates.capturedTransforms.projectionCaptured)
		parentDevice->SetTransform(D3DTS_PROJECTION, &stateBlockState.currentTransforms.ProjectionTransform);
	if (capturedStates.capturedTransforms.viewCaptured)
		parentDevice->SetTransform(D3DTS_VIEW, &stateBlockState.currentTransforms.ViewTransform);
	for (unsigned char texTransformIndex = 0; texTransformIndex < D3DDP_MAXTEXCOORD; ++texTransformIndex)
	{
		const unsigned char texTransformBitmask = (1 << texTransformIndex);
		const D3DTRANSFORMSTATETYPE texTransformEnum = (const D3DTRANSFORMSTATETYPE)(D3DTS_TEXTURE0 + texTransformIndex);
		if (capturedStates.capturedTransforms.textureTransformsCaptured.textureTransformsCapturedBitmask & texTransformBitmask)
			parentDevice->SetTransform(texTransformEnum, &(stateBlockState.currentTransforms.TextureTransforms[texTransformIndex]) );
	}
	for (unsigned short worldTransformIndex = 0; worldTransformIndex < MAX_WORLD_TRANSFORMS; ++worldTransformIndex)
	{
		const unsigned worldTransformDwordIndex = worldTransformIndex / 32;
		const unsigned worldTransformBitmask = 1 << (worldTransformIndex % 32);
		const D3DTRANSFORMSTATETYPE worldTransformEnum = (const D3DTRANSFORMSTATETYPE)(D3DTS_WORLD + worldTransformIndex);
		if (capturedStates.capturedTransforms.captureWorldTransforms[worldTransformDwordIndex] & worldTransformBitmask)
			parentDevice->SetTransform(worldTransformEnum, &(stateBlockState.currentTransforms.WorldTransforms[worldTransformIndex]) );
	}

	// TODO: Do all of the other captured device state (textures, vertex decls, VB's, IB's, texture stage states, etc.)
	if (capturedStates.singleCallStatesCaptured[SBT_SetIndices])
		parentDevice->SetIndices(stateBlockState.currentIndexBuffer);

	if (capturedStates.singleCallStatesCaptured[SBT_SetMaterial])
		parentDevice->SetMaterial(&stateBlockState.currentMaterial);

	if (capturedStates.singleCallStatesCaptured[SBT_SetNPatchMode])
		parentDevice->SetNPatchMode(stateBlockState.currentNPatchMode);

	if (capturedStates.singleCallStatesCaptured[SBT_SetViewport])
		parentDevice->SetViewport(&stateBlockState.cachedViewport.viewport);

	if (capturedStates.singleCallStatesCaptured[SBT_SetFVF])
		parentDevice->SetFVF(stateBlockState.currentFVF.rawFVF_DWORD);

	// We're currently setting the vertex declaration *after* the FVF
	if (capturedStates.singleCallStatesCaptured[SBT_SetVertexDeclaration])
		parentDevice->SetVertexDeclaration(stateBlockState.currentVertexDecl);

	if (capturedStates.singleCallStatesCaptured[SBT_SetScissorRect])
		parentDevice->SetScissorRect(&stateBlockState.currentScissorRect.scissorRect);

	if (capturedStates.singleCallStatesCaptured[SBT_SetPixelShader])
		parentDevice->SetPixelShader(stateBlockState.currentPixelShader);

	if (capturedStates.singleCallStatesCaptured[SBT_SetVertexShader])
		parentDevice->SetVertexShader(stateBlockState.currentVertexShader);

	if (capturedStates.singleCallStatesCaptured[SBT_SetCurrentTexturePalette])
		parentDevice->SetCurrentTexturePalette(stateBlockState.currentPaletteState.currentPaletteIndex);

	// Testing and setting constants one at a time is not particularly efficient. It'd be better in the case of large numbers of captured constants to set them all at once.
	for (unsigned psConstantIndexF = 0; psConstantIndexF < 4096; ++psConstantIndexF)
	{
		const unsigned psConstantDwordIndex = psConstantIndexF / 32;
		const unsigned psConstantBitmask = 1 << (psConstantIndexF % 32);
		if (capturedStates.capturedPixelShaderConstants.floatsCaptured[psConstantDwordIndex] & psConstantBitmask)
			parentDevice->SetPixelShaderConstantF(psConstantIndexF, &(stateBlockState.pixelShaderRegisters.floats[psConstantIndexF].x), 1);
	}
	for (unsigned char psConstantIndexI = 0; psConstantIndexI < 16; ++psConstantIndexI)
	{
		const unsigned short psConstantBitmask = 1 << psConstantIndexI;
		if (capturedStates.capturedPixelShaderConstants.intCaptured.capturedConstantsBitmask & psConstantBitmask)
			parentDevice->SetPixelShaderConstantI(psConstantIndexI, &(stateBlockState.pixelShaderRegisters.ints[psConstantIndexI].x), 1);
	}
	for (unsigned char psConstantIndexB = 0; psConstantIndexB < 16; ++psConstantIndexB)
	{
		const unsigned short psConstantBitmask = 1 << psConstantIndexB;
		if (capturedStates.capturedPixelShaderConstants.boolCaptured.capturedConstantsBitmask & psConstantBitmask)
			parentDevice->SetPixelShaderConstantB(psConstantIndexB, &(stateBlockState.pixelShaderRegisters.bools[psConstantIndexB]), 1);
	}

	// Testing and setting constants one at a time is not particularly efficient. It'd be better in the case of large numbers of captured constants to set them all at once.
	for (unsigned vsConstantIndexF = 0; vsConstantIndexF < 4096; ++vsConstantIndexF)
	{
		const unsigned vsConstantDwordIndex = vsConstantIndexF / 32;
		const unsigned vsConstantBitmask = 1 << (vsConstantIndexF % 32);
		if (capturedStates.capturedVertexShaderConstants.floatsCaptured[vsConstantDwordIndex] & vsConstantBitmask)
			parentDevice->SetVertexShaderConstantF(vsConstantIndexF, &(stateBlockState.vertexShaderRegisters.floats[vsConstantIndexF].x), 1);
	}
	for (unsigned char vsConstantIndexI = 0; vsConstantIndexI < 16; ++vsConstantIndexI)
	{
		const unsigned short vsConstantBitmask = 1 << vsConstantIndexI;
		if (capturedStates.capturedVertexShaderConstants.intCaptured.capturedConstantsBitmask & vsConstantBitmask)
			parentDevice->SetVertexShaderConstantI(vsConstantIndexI, &(stateBlockState.vertexShaderRegisters.ints[vsConstantIndexI].x), 1);
	}
	for (unsigned char vsConstantIndexB = 0; vsConstantIndexB < 16; ++vsConstantIndexB)
	{
		const unsigned short vsConstantBitmask = 1 << vsConstantIndexB;
		if (capturedStates.capturedVertexShaderConstants.boolCaptured.capturedConstantsBitmask & vsConstantBitmask)
			parentDevice->SetVertexShaderConstantB(vsConstantIndexB, &(stateBlockState.vertexShaderRegisters.bools[vsConstantIndexB]), 1);
	}

	for (unsigned short textureIndex = 0; textureIndex < MAX_NUM_SAMPLERS; ++textureIndex)
	{
		if (textureIndex >= 16 && textureIndex < D3DDMAPSAMPLER)
			continue;

		const unsigned textureDWORD = textureIndex / 32;
		const unsigned textureBitflag = 1 << (textureIndex % 32);
		if (capturedStates.capturedTextures.captureTextures[textureDWORD] & textureBitflag)
		{
			if (stateBlockState.currentTextures[textureIndex])
				parentDevice->SetTexture(textureIndex, stateBlockState.currentTextures[textureIndex]);
			else if (stateBlockState.currentCubeTextures[textureIndex])
				parentDevice->SetTexture(textureIndex, stateBlockState.currentCubeTextures[textureIndex]);
			else if (stateBlockState.currentVolumeTextures[textureIndex])
				parentDevice->SetTexture(textureIndex, stateBlockState.currentVolumeTextures[textureIndex]);
			else
				parentDevice->SetTexture(textureIndex, NULL);
		}

		const unsigned short thisTextureSamplerCapture = capturedStates.capturedSamplerStates.samplerStates[textureIndex].samplerStateBitmask;
		if (thisTextureSamplerCapture != 0x0000)
		{
			for (unsigned char samplerTypeIndex = D3DSAMP_ADDRESSU; samplerTypeIndex <= D3DSAMP_DMAPOFFSET; ++samplerTypeIndex)
			{
				const D3DSAMPLERSTATETYPE samplerType = (const D3DSAMPLERSTATETYPE)samplerTypeIndex;
				const unsigned short samplerTypeBitmask = 1 << samplerTypeIndex;
				if (thisTextureSamplerCapture & samplerTypeBitmask)
					parentDevice->SetSamplerState(textureIndex, samplerType, stateBlockState.currentSamplerStates[textureIndex].stateUnion.state[samplerType]);
			}
		}
	}

	for (unsigned char textureStage = 0; textureStage < MAX_NUM_TEXTURE_STAGE_STATES; ++textureStage)
	{
		const capturedStateBitmask::_capturedTextureStageStates::_stageStateBits& thisCapturedStage = capturedStates.capturedTextureStageStates.capturedTextureStages[textureStage];
		const TextureStageState& stateBlockStageState = stateBlockState.currentStageStates[textureStage];
		for (unsigned stateNum = D3DTSS_COLOROP; stateNum <= D3DTSS_CONSTANT; ++stateNum)
		{
			const D3DTEXTURESTAGESTATETYPE stateType = (const D3DTEXTURESTAGESTATETYPE)stateNum;
			const unsigned stateIndex = stateNum - 1;
			const unsigned stateBitflag = 1 << stateIndex;
			if (thisCapturedStage.stageStateBitfields & stateBitflag)
				parentDevice->SetTextureStageState(textureStage, stateType, stateBlockStageState.stageStateUnion.state[stateType]);
		}
	}

	if (capturedStates.capturedLights != NULL)
	{
		for (std::map<UINT, capturedStateBitmask::lightCaptureStruct>::const_iterator lightIter = capturedStates.capturedLights->begin(); lightIter != capturedStates.capturedLights->end(); ++lightIter)
		{
			const UINT lightIndex = lightIter->first;
			const capturedStateBitmask::lightCaptureStruct& lightCaptureData = lightIter->second;

			if (lightCaptureData.captureSetLight)
			{
				const std::map<UINT, LightInfo*>::const_iterator lightInfoIter = stateBlockState.lightInfoMap->find(lightIndex);
#ifdef _DEBUG
				if (lightInfoIter == stateBlockState.lightInfoMap->end() )
				{
					__debugbreak(); // This should never happen. It indicates a mismatch between our captured data and the fact that we captured it at all.
				}
#endif
				const LightInfo* const foundLightInfo = lightInfoIter->second;
				parentDevice->SetLight(lightIndex, &(foundLightInfo->light) );
			}

			// Make sure to potentially enable/disable the light *after* we create it with SetLight first!
			if (lightCaptureData.captureLightEnable)
				parentDevice->LightEnable(lightIndex, lightCaptureData.lightEnable);
		}
	}
	
	return ret;
}

void IDirect3DStateBlock9Hook::InitializeListAndCapture(const D3DSTATEBLOCKTYPE type)
{
#ifdef _DEBUG
	if (type < D3DSBT_ALL || type > D3DSBT_VERTEXSTATE)
	{
		DbgBreakPrint("Error: Only call this function with a valid state block type");
	}
#endif
	internalStateBlockType = type;

	renderStateStateBlockType rsType;
	switch (type)
	{
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Should never be here!");
#endif
	case D3DSBT_ALL:
		rsType = SBT_ALL_State;
		break;
	case D3DSBT_PIXELSTATE:
		rsType = pixelState;
		break;
	case D3DSBT_VERTEXSTATE:
		rsType = vertexState;
		break;
	}

	// TODO: This can and should be precomputed instead of being computed at runtime:
	for (unsigned char x = 0; x < ARRAYSIZE(renderStateStateBlockTypes); ++x)
	{
		const D3DRENDERSTATETYPE typedRenderState = (const D3DRENDERSTATETYPE)x;
		if (renderStateStateBlockTypes[typedRenderState] & rsType)
		{
			const unsigned char rsDWORDIndex = (const unsigned char)(typedRenderState / 32);
			const unsigned rsBitmask = 1 << (typedRenderState % 32);

			capturedStates.capturedRenderstates.captureRenderstate[rsDWORDIndex] |= rsBitmask;
		}
	}

	// Only if all: https://docs.microsoft.com/en-us/windows/win32/direct3d9/saving-all-device-states-with-a-stateblock
	if (rsType == SBT_ALL_State)
	{
		MarkSetCallAsCaptured<SBT_SetIndices>();
		MarkSetCallAsCaptured<SBT_SetMaterial>();
		MarkSetCallAsCaptured<SBT_SetScissorRect>();
		MarkSetCallAsCaptured<SBT_SetViewport>();
		MarkSetCallAsCaptured<SBT_SetCurrentTexturePalette>();

		capturedStates.capturedUserClipPlanes.userClipPlanesBitmask = 0xFFFFFFFF;
		capturedStates.capturedStreamSources.streamSourcesBitmask = 0xFFFF; // TODO: Check that this isn't actually stored as part of vertexState. The D3D9 docs are inconsistent here and it seems weird that they mention that the frequency gets stored in vertexState, but not the rest of the stream source state?

		// Transforms:
		capturedStates.capturedTransforms.viewCaptured = true;
		capturedStates.capturedTransforms.projectionCaptured = true;
		capturedStates.capturedTransforms.textureTransformsCaptured.textureTransformsCapturedBitmask = 0xFF;
		for (unsigned char x = 0; x < ARRAYSIZE(capturedStates.capturedTransforms.captureWorldTransforms); ++x)
			capturedStates.capturedTransforms.captureWorldTransforms[x] = 0xFFFFFFFF;
	}

	// Only if all or vertex: https://docs.microsoft.com/en-us/windows/win32/direct3d9/saving-vertex-states-with-a-stateblock
	if (rsType & (vertexState) )
	{
		MarkSetCallAsCaptured<SBT_SetNPatchMode>();
		MarkSetCallAsCaptured<SBT_SetVertexShader>();
		MarkSetCallAsCaptured<SBT_SetFVF>();
		MarkSetCallAsCaptured<SBT_SetVertexDeclaration>();

		capturedStates.capturedStreamSourceFreq.streamSourceFreqBitmask = 0xFFFF;

		capturedStates.capturedVertexShaderConstants.MarkSetAllShaderConstantsCaptured();

		// The vertex pipeline gets to capture the DMAP (displacement map) texture, plus the four vertex texture fetch samplers available to the vertex shader
		// TODO: Double check that DMAP is actually supposed to get captured by D3DSBT_VERTEXSTATE state blocks because the docs are a little bit unclear about that
		for (unsigned vertexTextureIndex = D3DDMAPSAMPLER; vertexTextureIndex < MAX_NUM_SAMPLERS; ++vertexTextureIndex)
		{
			MarkSetTextureCaptured(vertexTextureIndex);

			capturedStates.capturedSamplerStates.samplerStates[vertexTextureIndex].samplerStateBitmask = 0xFFFF;
		}

		const DeviceState& parentState = parentDevice->GetCurrentHookState();
		if (parentState.lightInfoMap != NULL)
		{
			for (std::map<UINT, LightInfo*>::const_iterator it = parentState.lightInfoMap->begin(); it != parentState.lightInfoMap->end(); ++it)
			{
				if (it->second != NULL)
				{
					const UINT lightNum = it->first;
					MarkSetLightCaptured(lightNum);
				}
			}

			for (unsigned lightIndex = 0; lightIndex < ARRAYSIZE(parentState.enabledLightIndices); ++lightIndex)
			{
				if (parentState.enabledLightIndices[lightIndex] != NULL)
					MarkLightEnableCaptured(lightIndex, true);
			}
		}
	}

	// Only if all or pixel: https://docs.microsoft.com/en-us/windows/win32/direct3d9/saving-pixel-states-with-a-stateblock
	if (rsType & (pixelState) )
	{
		MarkSetCallAsCaptured<SBT_SetPixelShader>();

		// The pixel pipeline gets to capture all of the textures except for the DMAP and vertex shader samplers
		for (unsigned pixelTextureIndex = 0; pixelTextureIndex < D3DDMAPSAMPLER; ++pixelTextureIndex)
		{
			MarkSetTextureCaptured(pixelTextureIndex);

			capturedStates.capturedSamplerStates.samplerStates[pixelTextureIndex].samplerStateBitmask = 0xFFFF;
		}

		for (unsigned char stage = 0; stage < MAX_NUM_TEXTURE_STAGE_STATES; ++stage)
			capturedStates.capturedTextureStageStates.capturedTextureStages[stage].stageStateBitfields = 0xFFFFFFFF;

		capturedStates.capturedPixelShaderConstants.MarkSetAllShaderConstantsCaptured();
	}

	// Finally, capture the current device state from the owning device:
	Capture();
}

```

`Software_d3d9/IDirect3DStateBlock9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

enum StateBlockSetCallType : unsigned char
{
	SBT_SetFVF = 0,
	SBT_SetIndices,
	SBT_SetMaterial,
	SBT_SetNPatchMode,
	SBT_SetPixelShader,
	SBT_SetScissorRect,
	SBT_SetViewport,
	SBT_SetVertexDeclaration,
	SBT_SetVertexShader,
	SBT_SetCurrentTexturePalette,

	SBT_MAX
};

struct capturedStateBitmask
{
	capturedStateBitmask()
	{
		memset(this, 0, sizeof(*this) );
	}

	~capturedStateBitmask()
	{
		delete capturedLights;
		capturedLights = NULL;
	}

	// TODO: All of the other captureable device state (textures, vertex decls, VB's, IB's, texture stage states, etc.)
	struct _capturedRenderstates
	{
		unsigned captureRenderstate[0x100 / 32];
	} capturedRenderstates;

	union _capturedUserClipPlanes
	{
		DWORD userClipPlanesBitmask;

		struct
		{
			BOOL userClipPlane0 : 1; BOOL userClipPlane1 : 1; BOOL userClipPlane2 : 1; BOOL userClipPlane3 : 1;
			BOOL userClipPlane4 : 1; BOOL userClipPlane5 : 1; BOOL userClipPlane6 : 1; BOOL userClipPlane7 : 1;
			BOOL userClipPlane8 : 1; BOOL userClipPlane9 : 1; BOOL userClipPlane10 : 1; BOOL userClipPlane11 : 1;
			BOOL userClipPlane12 : 1; BOOL userClipPlane13 : 1; BOOL userClipPlane14 : 1; BOOL userClipPlane15 : 1;
			BOOL userClipPlane16 : 1; BOOL userClipPlane17 : 1; BOOL userClipPlane18 : 1; BOOL userClipPlane19 : 1;
			BOOL userClipPlane20 : 1; BOOL userClipPlane21 : 1; BOOL userClipPlane22 : 1; BOOL userClipPlane23 : 1;
			BOOL userClipPlane24 : 1; BOOL userClipPlane25 : 1; BOOL userClipPlane26 : 1; BOOL userClipPlane27 : 1;
			BOOL userClipPlane28 : 1; BOOL userClipPlane29 : 1; BOOL userClipPlane30 : 1; BOOL userClipPlane31 : 1;
		} userClipPlanesNamed;
	} capturedUserClipPlanes;
	static_assert(sizeof(capturedUserClipPlanes) == sizeof(DWORD), "Error: Unexpected union size!");

	union _capturedStreamSources
	{
		unsigned short streamSourcesBitmask;
		struct
		{
			unsigned short streamSource0 : 1; unsigned short streamSource1 : 1; unsigned short streamSource2 : 1; unsigned short streamSource3 : 1;
			unsigned short streamSource4 : 1; unsigned short streamSource5 : 1; unsigned short streamSource6 : 1; unsigned short streamSource7 : 1;
			unsigned short streamSource8 : 1; unsigned short streamSource9 : 1; unsigned short streamSource10 : 1; unsigned short streamSource11 : 1;
			unsigned short streamSource12 : 1; unsigned short streamSource13 : 1; unsigned short streamSource14 : 1; unsigned short streamSource15 : 1;
		} streamSourcesNamed;
	} capturedStreamSources;
	static_assert(sizeof(capturedStreamSources) == sizeof(unsigned short), "Error: Unexpected union size!");

	union _capturedStreamSourceFreq
	{
		unsigned short streamSourceFreqBitmask;
		struct
		{
			unsigned short streamSourceFreq0 : 1; unsigned short streamSourceFreq1 : 1; unsigned short streamSourceFreq2 : 1; unsigned short streamSourceFreq3 : 1;
			unsigned short streamSourceFreq4 : 1; unsigned short streamSourceFreq5 : 1; unsigned short streamSourceFreq6 : 1; unsigned short streamSourceFreq7 : 1;
			unsigned short streamSourceFreq8 : 1; unsigned short streamSourceFreq9 : 1; unsigned short streamSourceFreq10 : 1; unsigned short streamSourceFreq11 : 1;
			unsigned short streamSourceFreq12 : 1; unsigned short streamSourceFreq13 : 1; unsigned short streamSourceFreq14 : 1; unsigned short streamSourceFreq15 : 1;
		} streamSourceFreqsNamed;
	} capturedStreamSourceFreq;
	static_assert(sizeof(capturedStreamSourceFreq) == sizeof(unsigned short), "Error: Unexpected union size!");

	struct _capturedTransforms
	{
		bool viewCaptured;
		bool projectionCaptured;

		union 
		{
			unsigned char textureTransformsCapturedBitmask;

			struct
			{
				unsigned char textureTransform0 : 1; unsigned char textureTransform1 : 1; unsigned char textureTransform2 : 1; unsigned char textureTransform3 : 1;
				unsigned char textureTransform4 : 1; unsigned char textureTransform5 : 1; unsigned char textureTransform6 : 1; unsigned char textureTransform7 : 1;
			} textureTransformsCapturedNamed;
		} textureTransformsCaptured;
		static_assert(sizeof(textureTransformsCaptured) == sizeof(unsigned char), "Error: Unexpected union size!");

		unsigned captureWorldTransforms[MAX_WORLD_TRANSFORMS / 32];

	} capturedTransforms;

	struct capturedShaderConstants
	{
		unsigned long floatsCaptured[4096 / 32];

		union nonFloatCapturedBits
		{
			struct
			{
				unsigned short constant0 : 1; unsigned short constant1 : 1; unsigned short constant2 : 1; unsigned short constant3 : 1;
				unsigned short constant4 : 1; unsigned short constant5 : 1; unsigned short constant6 : 1; unsigned short constant7 : 1;
				unsigned short constant8 : 1; unsigned short constant9 : 1; unsigned short constant10 : 1; unsigned short constant11 : 1;
				unsigned short constant12 : 1; unsigned short constant13 : 1; unsigned short constant14 : 1; unsigned short constant15 : 1;
			} capturedConstantsNamed;

			unsigned short capturedConstantsBitmask;
		};
		static_assert(sizeof(nonFloatCapturedBits) == sizeof(unsigned short), "Error: Unexpected union size!");

		nonFloatCapturedBits intCaptured;
		nonFloatCapturedBits boolCaptured;

		inline void MarkSetShaderConstantF(const UINT constantIndex)
		{
			if (constantIndex >= 4096)
				return;

			const unsigned constantSetIndex = constantIndex / 32;
			const unsigned constantSetBitmask = (1 << (constantIndex % 32) );
			floatsCaptured[constantSetIndex] |= constantSetBitmask;
		}

		inline void MarkSetShaderConstantNonF(const UINT constantIndex, nonFloatCapturedBits& nonFCapture)
		{
			if (constantIndex >= 16)
				return;

			const unsigned short constantSetBitmask = (1 << constantIndex);
			nonFCapture.capturedConstantsBitmask |= constantSetBitmask;
		}

		inline void MarkSetShaderConstantI(const UINT constantIndex)
		{
			MarkSetShaderConstantNonF(constantIndex, intCaptured);
		}

		inline void MarkSetShaderConstantB(const UINT constantIndex)
		{
			MarkSetShaderConstantNonF(constantIndex, boolCaptured);
		}

		inline void MarkSetAllShaderConstantsCaptured()
		{
			for (unsigned x = 0; x < ARRAYSIZE(floatsCaptured); ++x)
				floatsCaptured[x] = 0xFFFFFFFF;

			intCaptured.capturedConstantsBitmask = 0xFFFF;
			boolCaptured.capturedConstantsBitmask = 0xFFFF;
		}
	};
	capturedShaderConstants capturedPixelShaderConstants;
	capturedShaderConstants capturedVertexShaderConstants;

	struct _capturedTextures
	{
		unsigned captureTextures[(MAX_NUM_SAMPLERS + 31) / 32];
	} capturedTextures;

	struct _capturedTextureStageStates
	{
		union _stageStateBits
		{
			struct
			{
				unsigned colorOp : 1;				// D3DTSS_COLOROP                = bit 0
				unsigned colorArg1 : 1;				// D3DTSS_COLORARG1              = bit 1
				unsigned colorArg2 : 1;				// D3DTSS_COLORARG2              = bit 2
				unsigned alphaOp : 1;				// D3DTSS_ALPHAOP                = bit 3
				unsigned alphaArg1 : 1;				// D3DTSS_ALPHAARG1              = bit 4
				unsigned alphaArg2 : 1;				// D3DTSS_ALPHAARG2              = bit 5
				unsigned bumpEnvMat00 : 1;			// D3DTSS_BUMPENVMAT00           = bit 6
				unsigned bumpEnvMat01 : 1;			// D3DTSS_BUMPENVMAT01           = bit 7
				unsigned bumpEnvMat10 : 1;			// D3DTSS_BUMPENVMAT10           = bit 8
				unsigned bumpEnvMat11 : 1;			// D3DTSS_BUMPENVMAT11           = bit 9
				unsigned texCoordIndex : 1;			// D3DTSS_TEXCOORDINDEX          = bit 10
				unsigned unused0 : 10;
				unsigned bumpEnvLScale : 1;			// D3DTSS_BUMPENVLSCALE          = bit 21
				unsigned bumpEnvLOffset : 1;		// D3DTSS_BUMPENVLOFFSET         = bit 22
				unsigned textureTransformFlags : 1;	// D3DTSS_TEXTURETRANSFORMFLAGS  = bit 23
				unsigned unused1 : 1;
				unsigned colorArg0 : 1;				// D3DTSS_COLORARG0              = bit 25
				unsigned alphaArg0 : 1;				// D3DTSS_ALPHAARG0              = bit 26
				unsigned resultArg : 1;				// D3DTSS_RESULTARG              = bit 27
				unsigned unused2 : 3;
				unsigned constant : 1;				// D3DTSS_CONSTANT               = bit 31
			} stageStateNamed;

			unsigned stageStateBitfields;
		};
		static_assert(sizeof(_stageStateBits) == sizeof(unsigned), "Error: Unexpected union size!");

		_stageStateBits capturedTextureStages[MAX_NUM_TEXTURE_STAGE_STATES];
	} capturedTextureStageStates;

	struct _capturedSamplerStates
	{
		union _samplerStateUnion
		{
			struct
			{
				unsigned short unused0		  : 1;//= 0
				unsigned short ADDRESSU       : 1;//= 1   D3DTEXTUREADDRESS for U coordinate
				unsigned short ADDRESSV       : 1;//= 2   D3DTEXTUREADDRESS for V coordinate
				unsigned short ADDRESSW       : 1;//= 3   D3DTEXTUREADDRESS for W coordinate
				unsigned short BORDERCOLOR    : 1;//= 4   D3DCOLOR
				unsigned short MAGFILTER      : 1;//= 5   D3DTEXTUREFILTER filter to use for magnification
				unsigned short MINFILTER      : 1;//= 6   D3DTEXTUREFILTER filter to use for minification
				unsigned short MIPFILTER      : 1;//= 7   D3DTEXTUREFILTER filter to use between mipmaps during minification
				unsigned short MIPMAPLODBIAS  : 1;//= 8   float Mipmap LOD bias
				unsigned short MAXMIPLEVEL    : 1;//= 9   DWORD 0..(n-1) LOD index of largest map to use (0 == largest)
				unsigned short MAXANISOTROPY  : 1;//= 10  DWORD maximum anisotropy
				unsigned short SRGBTEXTURE    : 1;//= 11  Default = 0 (which means Gamma 1.0, no correction required.) else correct for Gamma = 2.2
				unsigned short ELEMENTINDEX   : 1;//= 12  When multi-element texture is assigned to sampler, this indicates which element index to use.  Default = 0.
				unsigned short DMAPOFFSET     : 1;//= 13  Offset in vertices in the pre-sampled displacement map. Only valid for D3DDMAPSAMPLER sampler
			} samplerStateNamed;

			unsigned short samplerStateBitmask;
		};

		_samplerStateUnion samplerStates[MAX_NUM_SAMPLERS];
	} capturedSamplerStates;

	struct lightCaptureStruct
	{
		lightCaptureStruct() : captureLightEnable(false), lightEnable(false), captureSetLight(false)
		{
		}

		bool captureLightEnable;
		bool lightEnable;
		bool captureSetLight;
	};
	std::map<UINT, lightCaptureStruct>* capturedLights;

	bool singleCallStatesCaptured[SBT_MAX];
};

class IDirect3DStateBlock9Hook : public IDirect3DStateBlock9
{
public:
	IDirect3DStateBlock9Hook(LPDIRECT3DSTATEBLOCK9 _realObject, IDirect3DDevice9Hook* _parentDevice, const bool _isCompleteStateBlock) : realObject(_realObject), parentDevice(_parentDevice), refCount(1), internalStateBlockType( (const D3DSTATEBLOCKTYPE)0), isCompleteStateBlock(_isCompleteStateBlock)
	{
#ifdef _DEBUG
		if (realObject)
			CreationCallStack = realObject->CreationCallStack;
#endif
	}

	virtual ~IDirect3DStateBlock9Hook()
	{
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DStateBlock9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Capture(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Apply(THIS) override;

	/*** IDirect3DStateBlock9Hook methods ***/
	inline void SetRealObject(LPDIRECT3DSTATEBLOCK9 _realObject)
	{
#ifdef _DEBUG
		if (_realObject == NULL)
		{
			// SetRealObject() should never be used to NULL out the underlying state block object
			__debugbreak();
		}
		if (realObject != NULL)
		{
			// SetRealObject() should never be used to change an existing state block's underlying real state block
			__debugbreak();
		}
#endif
		realObject = _realObject;
#ifdef _DEBUG
		if (realObject)
			CreationCallStack = realObject->CreationCallStack;
#endif
	}

	inline DeviceState* const GetDeviceStateForWrite()
	{
		return &stateBlockState;
	}

	inline void MarkRenderStateAsCaptured(const D3DRENDERSTATETYPE renderState)
	{
#ifdef _DEBUG
		if (renderState > 255)
		{
			__debugbreak(); // Should never get here
		}
#endif
		const unsigned dwordIndex = renderState / 32;
		const unsigned bitMask = 1 << (renderState % 32);
		capturedStates.capturedRenderstates.captureRenderstate[dwordIndex] |= bitMask;
	}

	template <const StateBlockSetCallType callType>
	inline void MarkSetCallAsCaptured()
	{
		capturedStates.singleCallStatesCaptured[callType] = true;
	}

	inline void MarkSetClipPlaneCaptured(const DWORD clipPlaneIndex)
	{
		if (clipPlaneIndex < D3DMAXUSERCLIPPLANES)
			capturedStates.capturedUserClipPlanes.userClipPlanesBitmask |= (1 << clipPlaneIndex);
	}

	inline void MarkSetStreamSourceCaptured(const UINT streamNumber)
	{
		if (streamNumber < MAX_D3D9_STREAMS)
			capturedStates.capturedStreamSources.streamSourcesBitmask |= (1 << streamNumber);
	}

	inline void MarkSetStreamSourceFreqCaptured(const UINT streamNumber)
	{
		if (streamNumber < MAX_D3D9_STREAMS)
			capturedStates.capturedStreamSourceFreq.streamSourceFreqBitmask |= (1 << streamNumber);
	}

	inline void MarkSetTransformCaptured(const D3DTRANSFORMSTATETYPE Transform)
	{
		if (Transform < D3DTS_WORLD)
		{
			switch (Transform)
			{
			case D3DTS_VIEW:
				capturedStates.capturedTransforms.viewCaptured = true;
				break;
			case D3DTS_PROJECTION:
				capturedStates.capturedTransforms.projectionCaptured = true;
				break;
			case D3DTS_TEXTURE0:
			case D3DTS_TEXTURE1:
			case D3DTS_TEXTURE2:
			case D3DTS_TEXTURE3:
			case D3DTS_TEXTURE4:
			case D3DTS_TEXTURE5:
			case D3DTS_TEXTURE6:
			case D3DTS_TEXTURE7:
			{
				const unsigned char setBitMask = (1 << (Transform - D3DTS_TEXTURE0) );
				capturedStates.capturedTransforms.textureTransformsCaptured.textureTransformsCapturedBitmask |= setBitMask;
			}
				break;
			default:
				// Should never be here, but do nothing in this case
				break;
			}
		}
		else if (Transform < D3DTS_WORLDMATRIX(MAX_WORLD_TRANSFORMS) ) // World transforms
		{
			const unsigned worldTransformIndex = Transform - D3DTS_WORLD;
			const unsigned dwordIndex = worldTransformIndex / 32;
			const unsigned bitMask = 1 << (worldTransformIndex % 32);
			capturedStates.capturedTransforms.captureWorldTransforms[dwordIndex] |= bitMask;
		}
		else
		{
			// Should never be here, but do nothing in this case
#ifdef _DEBUG
			__debugbreak();
#endif
		}
	}

	inline void MarkSetPixelShaderConstantF(const UINT constantIndex)
	{
		capturedStates.capturedPixelShaderConstants.MarkSetShaderConstantF(constantIndex);
	}

	inline void MarkSetPixelShaderConstantI(const UINT constantIndex)
	{
		capturedStates.capturedPixelShaderConstants.MarkSetShaderConstantI(constantIndex);
	}

	inline void MarkSetPixelShaderConstantB(const UINT constantIndex)
	{
		capturedStates.capturedPixelShaderConstants.MarkSetShaderConstantB(constantIndex);
	}

	inline void MarkSetVertexShaderConstantF(const UINT constantIndex)
	{
		capturedStates.capturedVertexShaderConstants.MarkSetShaderConstantF(constantIndex);
	}

	inline void MarkSetVertexShaderConstantI(const UINT constantIndex)
	{
		capturedStates.capturedVertexShaderConstants.MarkSetShaderConstantI(constantIndex);
	}

	inline void MarkSetVertexShaderConstantB(const UINT constantIndex)
	{
		capturedStates.capturedVertexShaderConstants.MarkSetShaderConstantB(constantIndex);
	}

	inline void MarkSetTextureCaptured(const UINT textureIndex)
	{
#ifdef _DEBUG
		if (textureIndex > MAX_NUM_SAMPLERS)
		{
			__debugbreak(); // Should never get here
		}
#endif
		const unsigned dwordIndex = textureIndex / 32;
		const unsigned bitMask = 1 << (textureIndex % 32);
		capturedStates.capturedTextures.captureTextures[dwordIndex] |= bitMask;
	}

	inline void MarkSetTextureStageStateCaptured(const UINT textureStageNum, const D3DTEXTURESTAGESTATETYPE stateType)
	{
		if (textureStageNum >= D3DDP_MAXTEXCOORD)
		{
#ifdef _DEBUG
			__debugbreak(); // Should never be here
#endif
			return;
		}

		if (stateType < D3DTSS_COLOROP || stateType > D3DTSS_CONSTANT)
		{
#ifdef _DEBUG
			__debugbreak(); // Should never be here
#endif
			return;
		}

		const unsigned stateIndex = stateType - 1;
		const unsigned stateBitmask = 1 << stateIndex;
		capturedStates.capturedTextureStageStates.capturedTextureStages[textureStageNum].stageStateBitfields |= stateBitmask;
	}

	inline void MarkSetSamplerStateCaptured(const UINT SamplerNum, const D3DSAMPLERSTATETYPE type)
	{
		if (SamplerNum >= MAX_NUM_SAMPLERS)
		{
#ifdef _DEBUG
			__debugbreak(); // Should never be here
#endif
			return;
		}

		if (type < D3DSAMP_ADDRESSU || type > D3DSAMP_DMAPOFFSET)
		{
#ifdef _DEBUG
			__debugbreak(); // Should never be here
#endif
			return;
		}

		const unsigned short samplerTypeBitmask = 1 << type;
		capturedStates.capturedSamplerStates.samplerStates[SamplerNum].samplerStateBitmask |= samplerTypeBitmask;
	}

	inline void MarkLightEnableCaptured(const UINT lightNum, const bool doEnable)
	{
		if (capturedStates.capturedLights == NULL)
			capturedStates.capturedLights = new std::map<UINT, capturedStateBitmask::lightCaptureStruct>;

		std::map<UINT, capturedStateBitmask::lightCaptureStruct>::iterator findExistingLightIt = capturedStates.capturedLights->find(lightNum);
		if (findExistingLightIt == capturedStates.capturedLights->end() )
		{
			capturedStateBitmask::lightCaptureStruct newLightCapture;
			newLightCapture.captureLightEnable = true;
			newLightCapture.lightEnable = doEnable;

			capturedStates.capturedLights->insert(std::make_pair(lightNum, newLightCapture) );
		}
		else
		{
			capturedStateBitmask::lightCaptureStruct& foundLightCapture = findExistingLightIt->second;
			foundLightCapture.captureLightEnable = true;
			foundLightCapture.lightEnable = doEnable;
		}
	}

	inline void MarkSetLightCaptured(const UINT lightNum)
	{
		if (capturedStates.capturedLights == NULL)
			capturedStates.capturedLights = new std::map<UINT, capturedStateBitmask::lightCaptureStruct>;

		std::map<UINT, capturedStateBitmask::lightCaptureStruct>::iterator findExistingLightIt = capturedStates.capturedLights->find(lightNum);
		if (findExistingLightIt == capturedStates.capturedLights->end() )
		{
			capturedStateBitmask::lightCaptureStruct newLightCapture;
			newLightCapture.captureSetLight = true;

			capturedStates.capturedLights->insert(std::make_pair(lightNum, newLightCapture) );
		}
		else
		{
			capturedStateBitmask::lightCaptureStruct& foundLightCapture = findExistingLightIt->second;
			foundLightCapture.captureSetLight = true;
		}
	}

	// This is intended to be called from IDirect3DDevice9Hook::CreateStateBlock
	void InitializeListAndCapture(const D3DSTATEBLOCKTYPE type);

protected:
	LPDIRECT3DSTATEBLOCK9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

	D3DSTATEBLOCKTYPE internalStateBlockType;
	bool isCompleteStateBlock; // true if this state block was created from IDirect3DDevice9::CreateStateBlock(), or false if this state block was created from IDirect3DDevice9::BeginStateBlock() + IDirect3DDevice9::EndStateBlock()
	__declspec(align(16) ) DeviceState stateBlockState;
	__declspec(align(16) ) capturedStateBitmask capturedStates;
};

```

`Software_d3d9/IDirect3DSurface9Hook.cpp`:

```cpp
#pragma once

#include "GlobalToggles.h"
#include "IDirect3DSurface9Hook.h"

static const __m128i zeroMaskVecI = { 0 };
static const __m128 zeroVecF = { 0.0f, 0.0f, 0.0f, 0.0f };
static const __m128 oneVecF = { 1.0f, 1.0f, 1.0f, 1.0f };
static const __m128 d15divisor = { 1.0f / 32767.0f, 1.0f / 32767.0f, 1.0f / 32767.0f, 1.0f / 32767.0f };
static const __m128 d16divisor = { 1.0f / 65535.0f, 1.0f / 65535.0f, 1.0f / 65535.0f, 1.0f / 65535.0f };
static const __m128 d24divisor = { 1.0f / 16777215.0f, 1.0f / 16777215.0f, 1.0f / 16777215.0f, 1.0f / 16777215.0f };
static const __m128 d32divisor = { 1.0f / 4294967295.0f, 1.0f / 4294967295.0f, 1.0f / 4294967295.0f, 1.0f / 4294967295.0f };

static const unsigned oneInt4_DWORD[4] = { 0x1, 0x1, 0x1, 0x1 };
static const __m128i oneInt4 = *(const __m128i* const)oneInt4_DWORD;

static inline const bool IsCompressedFormat(const D3DFORMAT format)
{
	switch (format)
	{
	case D3DFMT_DXT1:
	case D3DFMT_DXT2:
	case D3DFMT_DXT3:
	case D3DFMT_DXT4:
	case D3DFMT_DXT5:
		return true;
	default:
		return false;
	}
}

#pragma pack(push)
#pragma pack(1)
struct DXT1Chunk
{
	unsigned short c0;
	unsigned short c1;
	unsigned char interpLookup4x4[4];
};
static_assert(sizeof(DXT1Chunk) == 8, "Error: Unexpected DXT1 chunk size!");

struct DXT3Chunk
{
	unsigned char alphaValues[8];
	DXT1Chunk Colors;
};
static_assert(sizeof(DXT3Chunk) == 16, "Error: Unexpected DXT3 chunk size!");

struct DXT5Chunk
{
	unsigned char alpha_c0;
	unsigned char alpha_c1;
	unsigned char alphaInterpLookup4x4[6];
	DXT1Chunk Colors;
};
static_assert(sizeof(DXT5Chunk) == 16, "Error: Unexpected DXT5 chunk size!");

#pragma pack(pop)

static inline const D3DCOLOR DXT565To888(const unsigned short color565)
{
	const unsigned short r5 = (color565 & ( (0x20 - 1) << 11) ) >> 11;
	const unsigned short g6 = (color565 & ( (0x40 - 1) << 5) ) >> 5;
	const unsigned short b5 = (color565 & (0x20 - 1) );

	const float scaledR = r5 / 31.0f;
	const float scaledG = g6 / 63.0f;
	const float scaledB = b5 / 31.0f;

	const unsigned char r8 = (const unsigned char)(scaledR * 255.0f);
	const unsigned char g8 = (const unsigned char)(scaledG * 255.0f);
	const unsigned char b8 = (const unsigned char)(scaledB * 255.0f);

	return D3DCOLOR_XRGB(r8, g8, b8);
}


/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DSurface9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
#ifdef _DEBUG
	char buffer[256] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
	sprintf(buffer, "AddRef on surface: 0x%08X; RefCount is now: %u\n", (const unsigned)this, (const unsigned)refCount);
#pragma warning(pop)
	OutputDebugStringA(buffer);
#endif
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DSurface9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Surface %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DResource9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags)
{
	HRESULT ret = realObject->SetPrivateData(refguid, pData, SizeOfData, Flags);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData)
{
	HRESULT ret = realObject->GetPrivateData(refguid, pData, pSizeOfData);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::FreePrivateData(THIS_ REFGUID refguid)
{
	HRESULT ret = realObject->FreePrivateData(refguid);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DSurface9Hook::SetPriority(THIS_ DWORD PriorityNew)
{
	DWORD ret = realObject->SetPriority(PriorityNew);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DSurface9Hook::GetPriority(THIS)
{
	DWORD ret = realObject->GetPriority();
	return ret;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DSurface9Hook::PreLoad(THIS)
{
	realObject->PreLoad();
}

COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE IDirect3DSurface9Hook::GetType(THIS)
{
	D3DRESOURCETYPE ret = realObject->GetType();
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::GetContainer(THIS_ REFIID riid,void** ppContainer)
{
	HRESULT ret = realObject->GetContainer(riid, ppContainer);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	// TODO: Validate that the surface's container pointer matches the inner object pointer of the HookParentTexture
#endif

	*ppContainer = HookParentTexturePtr;

	return ret;
}

#ifdef _DEBUG
void IDirect3DSurface9Hook::ValidateRealObjectDesc() const
{
	if (!realObject)
		return;

	D3DSURFACE_DESC desc = {};
	HRESULT ret = realObject->GetDesc(&desc);
	if (FAILED(ret) )
	{
		// We should have caught this error, but didn't for some reason
		__debugbreak();
	}

	if (desc.Width != InternalWidth)
	{
		__debugbreak();
	}
	if (desc.Height != InternalHeight)
	{
		__debugbreak();
	}
	if (desc.Format != InternalFormat)
	{
		__debugbreak();
	}
	if (desc.Pool != InternalPool)
	{
		__debugbreak();
	}
	if (desc.Usage != InternalUsage)
	{
		__debugbreak();
	}
	if (desc.Type != D3DRTYPE_SURFACE)
	{
		__debugbreak();
	}
	if (desc.MultiSampleType != InternalMultiSampleType)
	{
		__debugbreak();
	}
	if (desc.MultiSampleQuality != InternalMultiSampleQuality)
	{
		__debugbreak();
	}
}
#endif

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::GetDesc(THIS_ D3DSURFACE_DESC *pDesc)
{
	if (!pDesc)
		return D3DERR_INVALIDCALL;

#ifdef _DEBUG
	ValidateRealObjectDesc();
#endif

	pDesc->Width = InternalWidth;
	pDesc->Height = InternalHeight;
	pDesc->Format = InternalFormat;
	pDesc->Pool = InternalPool;
	pDesc->Usage = InternalUsage;
	pDesc->Type = D3DRTYPE_SURFACE;
	pDesc->MultiSampleType = InternalMultiSampleType;
	pDesc->MultiSampleQuality = InternalMultiSampleQuality;

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::LockRect(THIS_ D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags)
{
#ifdef _DEBUG
	if (!realObject)
	{
		// Should never have an invalid internal surface object
		__debugbreak();
	}

	//if (LockableRT && pRect)
	//{
		// Only for debugging UT2004, remove later!
		//__debugbreak();
	//}

	{
		char buffer[256] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(buffer, "0x%08X::LockRect(pLockedRect = 0x%08X, pRect = 0x%08X, Flags = 0x%08X)\n", (const unsigned)this, (const unsigned)pLockedRect, (const unsigned)pRect, Flags);
#pragma warning(pop)
		OutputDebugStringA(buffer);
	}

	D3DLOCKED_RECT realRect = {0};
	HRESULT ret = realObject->LockRect(&realRect, pRect, Flags);
	if (FAILED(ret) )
	{
		realObject->UnlockRect();
		return ret;
	}
	realObject->UnlockRect();
#endif

#ifdef SURFACE_MAGIC_COOKIE
	ValidateSurfaceMagicCookie(surfaceBytes);
#endif

	if (!pLockedRect)
		return D3DERR_INVALIDCALL;

	static const DWORD validLockFlags = D3DLOCK_DISCARD | D3DLOCK_DONOTWAIT | D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_NOSYSLOCK | D3DLOCK_READONLY;
	if (Flags & (~validLockFlags) )
		return D3DERR_INVALIDCALL; // These are the only D3DLOCK flags valid for this function call

	if (creationMethod == deviceImplicitDepthStencil || creationMethod == createDepthStencil)
	{
		switch (InternalFormat)
		{
		default:
			return D3DERR_INVALIDCALL;
		case D3DFMT_D16_LOCKABLE:
		case D3DFMT_D32F_LOCKABLE:
		case D3DFMT_D32_LOCKABLE:
		case D3DFMT_S8_LOCKABLE:
			break;
		}
	}

	if (InternalPool == D3DPOOL_DEFAULT)
	{
		if (Flags & D3DLOCK_READONLY)
		{
		}
		else
		{
			if (!(InternalUsage & D3DUSAGE_DYNAMIC) )
				return D3DERR_INVALIDCALL;
		}
	}

	if (InternalMultiSampleType != D3DMULTISAMPLE_NONE)
		return D3DERR_INVALIDCALL;

	if (pRect)
	{
		// It is illegal to use the D3DLOCK_DISCARD flag with a subrect: https://msdn.microsoft.com/en-us/library/windows/desktop/bb205896(v=vs.85).aspx
		if (Flags & D3DLOCK_DISCARD)
			return D3DERR_INVALIDCALL;

		// RECT validation:
		if (pRect->left < 0 || pRect->right < 0 || pRect->top < 0 || pRect->bottom < 0)
			return D3DERR_INVALIDCALL;
		if (pRect->left >= pRect->right)
			return D3DERR_INVALIDCALL;
		if (pRect->top >= pRect->bottom)
			return D3DERR_INVALIDCALL;
		if (pRect->left >= (const long)InternalWidth)
			return D3DERR_INVALIDCALL;
		if (pRect->right > (const long)InternalWidth)
			return D3DERR_INVALIDCALL;
		if (pRect->top >= (const long)InternalHeight)
			return D3DERR_INVALIDCALL;
		if (pRect->bottom > (const long)InternalHeight)
			return D3DERR_INVALIDCALL;

		D3DCOLOR* const pixels = (D3DCOLOR* const)surfaceBytesRaw;
		pLockedRect->pBits = pixels + pRect->top * InternalWidth + pRect->left;
	}
	else
	{
#ifdef SURFACE_ENFORCE_DISCARD_ON_LOCK
		if (Flags & D3DLOCK_DISCARD)
		{
			memset(surfaceBytesRaw, 0, surfaceBytesRawSize);
			if (auxSurfaceBytesRaw)
				memset(auxSurfaceBytesRaw, 0, auxSurfaceBytesRawSize);
		}
#endif

		pLockedRect->pBits = surfaceBytesRaw;
	}

	pLockedRect->Pitch = GetSurfacePitchBytes(InternalWidth, InternalFormat);

#ifdef _DEBUG
	if (pLockedRect->Pitch != realRect.Pitch)
	{
		char buffer[256] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(buffer, "Lock rect failed due to pitch misalignment. Pitch = %u, expected pitch = %u. Format = %u. Dims = %ux%u\n", realRect.Pitch, pLockedRect->Pitch, InternalFormat, InternalWidth, InternalHeight);
#pragma warning(pop)
		OutputDebugStringA(buffer);
	}

	if ( (pLockedRect->Pitch & 0x1) != 0)
	{
		// Should never get an odd pitch back
		__debugbreak();
	}

	if (!pLockedRect->pBits)
	{
		// Should never get a NULL pointer back
		__debugbreak();
	}
#endif // _DEBUG

#ifdef SURFACE_MAGIC_COOKIE
	DWORD* const magicDword = (DWORD* const)surfaceBytesRaw + (surfaceBytes.size() / sizeof(DWORD) - 1);
	*magicDword = surfaceMagicBytes;
#endif // SURFACE_MAGIC_COOKIE

	return S_OK;
}

void IDirect3DSurface9Hook::DecompressSurfaceDXT1()
{
	const DXT1Chunk* dxt1Chunks = (const DXT1Chunk* const)surfaceBytesRaw;

	D3DCOLOR* const rawPixels = (D3DCOLOR* const)auxSurfaceBytesRaw;

	for (unsigned y = 0; y < InternalHeight; y += 4)
	{
		for (unsigned x = 0; x < InternalWidth; x += 4)
		{
			const DXT1Chunk& chunk = *dxt1Chunks++;

			const D3DCOLOR c0 = DXT565To888(chunk.c0);
			const D3DCOLOR c1 = DXT565To888(chunk.c1);
			D3DCOLOR c2;
			D3DCOLOR c3;

			const unsigned r0 = (c0 & 0x00FF0000) >> 16;
			const unsigned g0 = (c0 & 0x0000FF00) >> 8;
			const unsigned b0 = (c0 & 0x000000FF);

#ifdef _DEBUG
			if (r0 > 255)
			{
				__debugbreak();
			}
			if (g0 > 255)
			{
				__debugbreak();
			}
			if (b0 > 255)
			{
				__debugbreak();
			}
#endif

			const unsigned r1 = (c1 & 0x00FF0000) >> 16;
			const unsigned g1 = (c1 & 0x0000FF00) >> 8;
			const unsigned b1 = (c1 & 0x000000FF);

#ifdef _DEBUG
			if (r1 > 255)
			{
				__debugbreak();
			}
			if (g1 > 255)
			{
				__debugbreak();
			}
			if (b1 > 255)
			{
				__debugbreak();
			}
#endif

			if (chunk.c0 > chunk.c1)
			{
				// c2 = (2/3)c0 + (1/3)c1
				const unsigned r2 = (r0 + r0 + r1 + 1) / 3;
				const unsigned g2 = (g0 + g0 + g1 + 1) / 3;
				const unsigned b2 = (b0 + b0 + b1 + 1) / 3;
#ifdef _DEBUG
				if (r2 > 255)
				{
					__debugbreak();
				}
				if (g2 > 255)
				{
					__debugbreak();
				}
				if (b2 > 255)
				{
					__debugbreak();
				}
#endif
				c2 = D3DCOLOR_XRGB(r2, g2, b2);

				// c2 = (1/3)c0 + (2/3)c1
				const unsigned r3 = (r0 + r1 + r1 + 1) / 3;
				const unsigned g3 = (g0 + g1 + g1 + 1) / 3;
				const unsigned b3 = (b0 + b1 + b1 + 1) / 3;
#ifdef _DEBUG
				if (r3 > 255)
				{
					__debugbreak();
				}
				if (g3 > 255)
				{
					__debugbreak();
				}
				if (b3 > 255)
				{
					__debugbreak();
				}
#endif
				c3 = D3DCOLOR_XRGB(r3, g3, b3);
			}
			else
			{
				// c2 = (1/2)c0 + (1/2)c1
				const unsigned r2 = (r0 + r1) / 2;
				const unsigned g2 = (g0 + g1) / 2;
				const unsigned b2 = (b0 + b1) / 2;

#ifdef _DEBUG
				if (r2 > 255)
				{
					__debugbreak();
				}
				if (g2 > 255)
				{
					__debugbreak();
				}
				if (b2 > 255)
				{
					__debugbreak();
				}
#endif

				c2 = D3DCOLOR_XRGB(r2, g2, b2);

				c3 = 0x00000000;
			}

			for (unsigned char dy = 0; dy < 4; ++dy)
			{
				for (unsigned char dx = 0; dx < 4; ++dx)
				{
					const unsigned char pixelByte = chunk.interpLookup4x4[dy];
					unsigned char pixelBits;
					switch (dx)
					{
					case 0:
						pixelBits = pixelByte & 0x3;
						break;
					case 1:
						pixelBits = (pixelByte & (0x3 << 2) ) >> 2;
						break;
					case 2:
						pixelBits = (pixelByte & (0x3 << 4) ) >> 4;
						break;
					case 3:
						pixelBits = (pixelByte & (0x3 << 6) ) >> 6;
						break;
					default:
#ifdef _DEBUG
						__debugbreak();
#else
						__assume(0);
#endif
					}

#ifdef _DEBUG
					if (pixelBits > 3)
					{
						__debugbreak();
					}
#endif
					D3DCOLOR pixelColor;
					switch (pixelBits)
					{
					case 0:
						pixelColor = c0;
						break;
					case 1:
						pixelColor = c1;
						break;
					case 2:
						pixelColor = c2;
						break;
					case 3:
						pixelColor = c3;
						break;
					default:
#ifdef _DEBUG
						__debugbreak();
#else
						__assume(0);
#endif
					}

					rawPixels[(y + dy) * InternalWidth + (x + dx)] = pixelColor;
				}
			}
		}
	}
}

static inline const DWORD DecompressDXT3Alpha(const DXT3Chunk& chunk, const unsigned dx, const unsigned dy)
{
	const unsigned char byteIndex = (dy * 4 + dx) / 2;

	unsigned char byteMask;
	if (dx & 0x1)
		byteMask = 0xF0;
	else
		byteMask = 0x0F;

	unsigned char byteShift;
	if (dx & 0x1)
		byteShift = 4;
	else
		byteShift = 0;

	const unsigned char alpha4Bit = (chunk.alphaValues[byteIndex] & byteMask) >> byteShift;

#ifdef _DEBUG
	if (alpha4Bit > 15)
	{
		__debugbreak();
	}
#endif

	const unsigned alpha = alpha4Bit * 17;
	return alpha;
}

void IDirect3DSurface9Hook::DecompressSurfaceDXT3()
{
	const DXT3Chunk* dxt3Chunks = (const DXT3Chunk* const)surfaceBytesRaw;

	D3DCOLOR* const rawPixels = (D3DCOLOR* const)auxSurfaceBytesRaw;

	for (unsigned y = 0; y < InternalHeight; y += 4)
	{
		for (unsigned x = 0; x < InternalWidth; x += 4)
		{
			const DXT3Chunk& chunk = *dxt3Chunks++;

			const D3DCOLOR c0 = DXT565To888(chunk.Colors.c0);
			const D3DCOLOR c1 = DXT565To888(chunk.Colors.c1);
			D3DCOLOR c2;
			D3DCOLOR c3;

			const unsigned r0 = (c0 & 0x00FF0000) >> 16;
			const unsigned g0 = (c0 & 0x0000FF00) >> 8;
			const unsigned b0 = (c0 & 0x000000FF);

#ifdef _DEBUG
			if (r0 > 255)
			{
				__debugbreak();
			}
			if (g0 > 255)
			{
				__debugbreak();
			}
			if (b0 > 255)
			{
				__debugbreak();
			}
#endif

			const unsigned r1 = (c1 & 0x00FF0000) >> 16;
			const unsigned g1 = (c1 & 0x0000FF00) >> 8;
			const unsigned b1 = (c1 & 0x000000FF);

#ifdef _DEBUG
			if (r1 > 255)
			{
				__debugbreak();
			}
			if (g1 > 255)
			{
				__debugbreak();
			}
			if (b1 > 255)
			{
				__debugbreak();
			}
#endif

			// c2 = (2/3)c0 + (1/3)c1
			const unsigned r2 = (r0 + r0 + r1 + 1) / 3;
			const unsigned g2 = (g0 + g0 + g1 + 1) / 3;
			const unsigned b2 = (b0 + b0 + b1 + 1) / 3;
#ifdef _DEBUG
			if (r2 > 255)
			{
				__debugbreak();
			}
			if (g2 > 255)
			{
				__debugbreak();
			}
			if (b2 > 255)
			{
				__debugbreak();
			}
#endif
			c2 = D3DCOLOR_XRGB(r2, g2, b2);

			// c3 = (1/3)c0 + (2/3)c1
			const unsigned r3 = (r0 + r1 + r1 + 1) / 3;
			const unsigned g3 = (g0 + g1 + g1 + 1) / 3;
			const unsigned b3 = (b0 + b1 + b1 + 1) / 3;
#ifdef _DEBUG
			if (r3 > 255)
			{
				__debugbreak();
			}
			if (g3 > 255)
			{
				__debugbreak();
			}
			if (b3 > 255)
			{
				__debugbreak();
			}
#endif
			c3 = D3DCOLOR_XRGB(r3, g3, b3);

			for (unsigned char dy = 0; dy < 4; ++dy)
			{
				const unsigned char pixelByte = chunk.Colors.interpLookup4x4[dy];
				for (unsigned char dx = 0; dx < 4; ++dx)
				{
					unsigned char pixelBits;
					switch (dx)
					{
					case 0:
						pixelBits = pixelByte & 0x3;
						break;
					case 1:
						pixelBits = (pixelByte >> 2) & 0x3;
						break;
					case 2:
						pixelBits = (pixelByte >> 4) & 0x3;
						break;
					case 3:
						pixelBits = (pixelByte >> 6) & 0x3;
						break;
					default:
#ifdef _DEBUG
						__debugbreak();
#else
						__assume(0);
#endif
					}

#ifdef _DEBUG
					if (pixelBits > 3)
					{
						__debugbreak();
					}
#endif
					D3DCOLOR pixelColor;
					switch (pixelBits)
					{
					case 0:
						pixelColor = c0;
						break;
					case 1:
						pixelColor = c1;
						break;
					case 2:
						pixelColor = c2;
						break;
					case 3:
						pixelColor = c3;
						break;
					default:
#ifdef _DEBUG
						__debugbreak();
#else
						__assume(0);
#endif
					}

					const DWORD alpha = DecompressDXT3Alpha(chunk, dx, dy);

					const D3DCOLOR alphaColor = D3DCOLOR_ARGB(alpha, 0, 0, 0);

					rawPixels[(y + dy) * InternalWidth + (x + dx)] = ( (pixelColor & 0x00FFFFFF) | alphaColor);
				}
			}
		}
	}
}

static inline const DWORD DecompressDXT5PixelAlpha(const DXT5Chunk& chunk, const unsigned char pixelIndex)
{
 	// The end of this read will read 16 bits into the colors section of the buffer, this is fine (it's not like it'll cause a seg-fault, and we're not using that data anyway).
	const unsigned char bitIndex = pixelIndex * 3; // Range [0...47]
#ifdef _DEBUG
	if (bitIndex > 47)
	{
		__debugbreak();
	}
#endif

	unsigned __int64 interpLookupNum = *(const unsigned __int64* const)&(chunk.alphaInterpLookup4x4);
	interpLookupNum &= ( ( (const unsigned __int64)0x7) << bitIndex);
	interpLookupNum >>= bitIndex;
	const unsigned char shortBitIndex = (const unsigned char)interpLookupNum; // Range [0...7]
#ifdef _DEBUG
	if (shortBitIndex > 7)
	{
		__debugbreak();
	}
#endif

	unsigned alpha;
	const unsigned a0 = chunk.alpha_c0;
	const unsigned a1 = chunk.alpha_c1;

	if (a0 > a1)
	{
		switch (shortBitIndex)
		{
		case 0:
			alpha = a0;
			break;
		case 1:
			alpha = a1;
			break;
		case 2:
			alpha = (6 * a0 +     a1) / 7;
			break;
		case 3:
			alpha = (5 * a0 + 2 * a1) / 7;
			break;
		case 4:
			alpha = (4 * a0 + 3 * a1) / 7;
			break;
		case 5:
			alpha = (3 * a0 + 4 * a1) / 7;
			break;
		case 6:
			alpha = (2 * a0 + 5 * a1) / 7;
			break;
		case 7:
			alpha = (    a0 + 6 * a1) / 7;
			break;
		default:
#ifdef _DEBUG
			__debugbreak();
#else
			__assume(0);
#endif
		}
	}
	else
	{
		switch (shortBitIndex)
		{
		case 0:
			alpha = a0;
			break;
		case 1:
			alpha = a1;
			break;
		case 2:
			alpha = (4 * a0 +     a1) / 5;
			break;
		case 3:
			alpha = (3 * a0 + 2 * a1) / 5;
			break;
		case 4:
			alpha = (2 * a0 + 3 * a1) / 5;
			break;
		case 5:
			alpha = (    a0 + 4 * a1) / 5;
			break;
		case 6:
			alpha = 0;
			break;
		case 7:
			alpha = 255;
			break;
		default:
#ifdef _DEBUG
			__debugbreak();
#else
			__assume(0);
#endif
		}
	}

#ifdef _DEBUG
	if (alpha > 255)
	{
		__debugbreak();
	}
#endif

	return alpha;
}

void IDirect3DSurface9Hook::DecompressSurfaceDXT5()
{
	const DXT5Chunk* dxt5Chunks = (const DXT5Chunk* const)surfaceBytesRaw;

	D3DCOLOR* const rawPixels = (D3DCOLOR* const)auxSurfaceBytesRaw;

	for (unsigned y = 0; y < InternalHeight; y += 4)
	{
		for (unsigned x = 0; x < InternalWidth; x += 4)
		{
			const DXT5Chunk& chunk = *dxt5Chunks++;

			const D3DCOLOR c0 = DXT565To888(chunk.Colors.c0);
			const D3DCOLOR c1 = DXT565To888(chunk.Colors.c1);
			D3DCOLOR c2;
			D3DCOLOR c3;

			const unsigned r0 = (c0 & 0x00FF0000) >> 16;
			const unsigned g0 = (c0 & 0x0000FF00) >> 8;
			const unsigned b0 = (c0 & 0x000000FF);

#ifdef _DEBUG
			if (r0 > 255)
			{
				__debugbreak();
			}
			if (g0 > 255)
			{
				__debugbreak();
			}
			if (b0 > 255)
			{
				__debugbreak();
			}
#endif

			const unsigned r1 = (c1 & 0x00FF0000) >> 16;
			const unsigned g1 = (c1 & 0x0000FF00) >> 8;
			const unsigned b1 = (c1 & 0x000000FF);

#ifdef _DEBUG
			if (r1 > 255)
			{
				__debugbreak();
			}
			if (g1 > 255)
			{
				__debugbreak();
			}
			if (b1 > 255)
			{
				__debugbreak();
			}
#endif

			// c2 = (2/3)c0 + (1/3)c1
			const unsigned r2 = (r0 + r0 + r1 + 1) / 3;
			const unsigned g2 = (g0 + g0 + g1 + 1) / 3;
			const unsigned b2 = (b0 + b0 + b1 + 1) / 3;
#ifdef _DEBUG
			if (r2 > 255)
			{
				__debugbreak();
			}
			if (g2 > 255)
			{
				__debugbreak();
			}
			if (b2 > 255)
			{
				__debugbreak();
			}
#endif
			c2 = D3DCOLOR_XRGB(r2, g2, b2);

			// c3 = (1/3)c0 + (2/3)c1
			const unsigned r3 = (r0 + r1 + r1 + 1) / 3;
			const unsigned g3 = (g0 + g1 + g1 + 1) / 3;
			const unsigned b3 = (b0 + b1 + b1 + 1) / 3;
#ifdef _DEBUG
			if (r3 > 255)
			{
				__debugbreak();
			}
			if (g3 > 255)
			{
				__debugbreak();
			}
			if (b3 > 255)
			{
				__debugbreak();
			}
#endif
			c3 = D3DCOLOR_XRGB(r3, g3, b3);

			for (unsigned char dy = 0; dy < 4; ++dy)
			{
				const unsigned char pixelByte = chunk.Colors.interpLookup4x4[dy];
				for (unsigned char dx = 0; dx < 4; ++dx)
				{
					unsigned char pixelBits;
					switch (dx)
					{
					case 0:
						pixelBits = pixelByte & 0x3;
						break;
					case 1:
						pixelBits = (pixelByte >> 2) & 0x3;
						break;
					case 2:
						pixelBits = (pixelByte >> 4) & 0x3;
						break;
					case 3:
						pixelBits = (pixelByte >> 6) & 0x3;
						break;
					default:
#ifdef _DEBUG
						__debugbreak();
#else
						__assume(0);
#endif
					}

#ifdef _DEBUG
					if (pixelBits > 3)
					{
						__debugbreak();
					}
#endif
					D3DCOLOR pixelColor;
					switch (pixelBits)
					{
					case 0:
						pixelColor = c0;
						break;
					case 1:
						pixelColor = c1;
						break;
					case 2:
						pixelColor = c2;
						break;
					case 3:
						pixelColor = c3;
						break;
					default:
#ifdef _DEBUG
						__debugbreak();
#else
						__assume(0);
#endif
					}

					const DWORD alpha = DecompressDXT5PixelAlpha(chunk, dy * 4 + dx);

					const D3DCOLOR alphaColor = D3DCOLOR_ARGB(alpha, 0, 0, 0);
					rawPixels[(y + dy) * InternalWidth + (x + dx)] = ( (pixelColor & 0x00FFFFFF) | alphaColor);
				}
			}
		}
	}
}

void IDirect3DSurface9Hook::DecompressSurfaceToAuxBuffer()
{
	switch (InternalFormat)
	{
	case D3DFMT_DXT1:
		DecompressSurfaceDXT1();
		break;
	case D3DFMT_DXT2:
	case D3DFMT_DXT3:
		DecompressSurfaceDXT3();
		break;
	case D3DFMT_DXT4:
	case D3DFMT_DXT5:
		DecompressSurfaceDXT5();
		break;
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
		break;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::UnlockRect(THIS)
{
#ifdef _DEBUG
	{
		char buffer[256] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(buffer, "0x%08X::UnlockRect()\n", (const unsigned)this);
#pragma warning(pop)
		OutputDebugStringA(buffer);
	}
#endif
	if (IsCompressedFormat(InternalFormat) )
	{
#ifdef SURFACE_MAGIC_COOKIE
		DWORD* const magicDword = (DWORD* const)auxSurfaceBytesRaw + (auxSurfaceBytes.size() / sizeof(DWORD) - 1);
		*magicDword = surfaceMagicBytes;
#endif
		DecompressSurfaceToAuxBuffer();
#ifdef SURFACE_MAGIC_COOKIE
		if (*magicDword != surfaceMagicBytes)
		{
			__debugbreak();
		}
#endif
	}

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif

#ifdef SURFACE_MAGIC_COOKIE
	ValidateSurfaceMagicCookie(surfaceBytes);
#endif

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::GetDC(THIS_ HDC *phdc)
{
	HRESULT ret = realObject->GetDC(phdc);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSurface9Hook::ReleaseDC(THIS_ HDC hdc)
{
	HRESULT ret = realObject->ReleaseDC(hdc);
	return ret;
}

const unsigned IDirect3DSurface9Hook::GetSurfacePitchBytes(const unsigned Width, const D3DFORMAT Format)
{
	switch (Format)
	{
	case D3DFMT_UNKNOWN:
		return 0;
	case D3DFMT_R8G8B8				 :
		return RoundUpTo4(Width * 3);
	case D3DFMT_A8R8G8B8             :
	case D3DFMT_X8R8G8B8             :
	case D3DFMT_A2B10G10R10          :
	case D3DFMT_A8B8G8R8             :
	case D3DFMT_X8B8G8R8             :
	case D3DFMT_G16R16               :
	case D3DFMT_A2R10G10B10          :
	case D3DFMT_X8L8V8U8             :
	case D3DFMT_Q8W8V8U8             :
	case D3DFMT_V16U16               :
	case D3DFMT_A2W10V10U10          :
	case D3DFMT_D32                  :
    case D3DFMT_D24S8                :
    case D3DFMT_D24X8                :
    case D3DFMT_D24X4S4              :
    case D3DFMT_D32F_LOCKABLE        :
    case D3DFMT_D24FS8               :
	case D3DFMT_D32_LOCKABLE         :
	case MAKEFOURCC('I', 'N', 'T', 'Z'):
	case D3DFMT_INDEX32              :
	case D3DFMT_G16R16F              :
	case D3DFMT_R32F                 :
	case D3DFMT_A2B10G10R10_XR_BIAS  :
		return Width * 4;
	case D3DFMT_R5G6B5               :
	case D3DFMT_X1R5G5B5             :
	case D3DFMT_A1R5G5B5             :
	case D3DFMT_A4R4G4B4             :
	case D3DFMT_A8R3G3B2             :
	case D3DFMT_X4R4G4B4             :
	case D3DFMT_A8P8                 :
	case D3DFMT_A8L8                 :
	case D3DFMT_V8U8                 :
	case D3DFMT_L6V5U5               :
	case D3DFMT_D16_LOCKABLE         :
    case D3DFMT_D15S1                :
    case D3DFMT_D16                  :
	case D3DFMT_L16                  :
    case D3DFMT_INDEX16              :
	case D3DFMT_R16F                 :
	case D3DFMT_CxV8U8               :
		return RoundUpTo4(Width * 2);
	case D3DFMT_R3G3B2               :
	case D3DFMT_A8                   :
	case D3DFMT_P8                   :
	case D3DFMT_L8                   :
	case D3DFMT_A4L4                 :
	case D3DFMT_S8_LOCKABLE          :
		return RoundUpTo4(Width);
	case D3DFMT_A16B16G16R16         :
	case D3DFMT_Q16W16V16U16         :
	case D3DFMT_A16B16G16R16F        :
	case D3DFMT_G32R32F              :
		return Width * 8;
	case D3DFMT_A32B32G32R32F        :
		return Width * 16;
    case D3DFMT_UYVY                 :
    case D3DFMT_R8G8_B8G8            :
    case D3DFMT_YUY2                 :
    case D3DFMT_G8R8_G8B8            :
		return RoundUpTo4(Width);
    case D3DFMT_DXT1                 :
	{
		const unsigned numBytes = Width * 2;
		if (numBytes < sizeof(DXT1Chunk) )
			return sizeof(DXT1Chunk) ;
		return RoundUpTo8(numBytes);
	}
    case D3DFMT_DXT2                 :
    case D3DFMT_DXT3                 :
	{
		const unsigned numBytes = Width * 4;
		if (numBytes < sizeof(DXT3Chunk) )
			return sizeof(DXT3Chunk) ;
		return RoundUpTo16(numBytes);
	}
    case D3DFMT_DXT4                 :
    case D3DFMT_DXT5                 :
	{
		const unsigned numBytes = Width * 4;
		if (numBytes < sizeof(DXT5Chunk) )
			return sizeof(DXT5Chunk) ;
		return RoundUpTo16(numBytes);
	}
	case D3DFMT_A1                   :
	{
		if (Width == 0)
			return 0;
		const unsigned numBytes = Width / 8; // One bit per pixel
		if (numBytes < 4)
			return 4;
		else
			return RoundUpTo4(numBytes);
	}
    case D3DFMT_VERTEXDATA           :
	case D3DFMT_MULTI2_ARGB8         :
	case D3DFMT_BINARYBUFFER         :
	default:
		return RoundUpTo4(Width); // Uhhhhhh...
	}
}

const unsigned IDirect3DSurface9Hook::GetSurfaceSizeBytes(const unsigned Width, const unsigned Height, const D3DFORMAT Format)
{
	switch (Format)
	{
	case D3DFMT_UNKNOWN:
		return 0;
	case D3DFMT_R8G8B8				 :
	case D3DFMT_A8R8G8B8             :
	case D3DFMT_X8R8G8B8             :
	case D3DFMT_A2B10G10R10          :
	case D3DFMT_A8B8G8R8             :
	case D3DFMT_X8B8G8R8             :
	case D3DFMT_G16R16               :
	case D3DFMT_A2R10G10B10          :
	case D3DFMT_X8L8V8U8             :
	case D3DFMT_Q8W8V8U8             :
	case D3DFMT_V16U16               :
	case D3DFMT_A2W10V10U10          :
	case D3DFMT_D32                  :
    case D3DFMT_D24S8                :
    case D3DFMT_D24X8                :
    case D3DFMT_D24X4S4              :
    case D3DFMT_D32F_LOCKABLE        :
    case D3DFMT_D24FS8               :
	case D3DFMT_D32_LOCKABLE         :
	case MAKEFOURCC('I', 'N', 'T', 'Z'):
	case D3DFMT_INDEX32              :
	case D3DFMT_G16R16F              :
	case D3DFMT_R32F                 :
	case D3DFMT_A2B10G10R10_XR_BIAS  :
	case D3DFMT_R5G6B5               :
	case D3DFMT_X1R5G5B5             :
	case D3DFMT_A1R5G5B5             :
	case D3DFMT_A4R4G4B4             :
	case D3DFMT_A8R3G3B2             :
	case D3DFMT_X4R4G4B4             :
	case D3DFMT_A8P8                 :
	case D3DFMT_A8L8                 :
	case D3DFMT_V8U8                 :
	case D3DFMT_L6V5U5               :
	case D3DFMT_D16_LOCKABLE         :
    case D3DFMT_D15S1                :
    case D3DFMT_D16                  :
	case D3DFMT_L16                  :
    case D3DFMT_INDEX16              :
	case D3DFMT_R16F                 :
	case D3DFMT_CxV8U8               :
	case D3DFMT_R3G3B2               :
	case D3DFMT_A8                   :
	case D3DFMT_P8                   :
	case D3DFMT_L8                   :
	case D3DFMT_A4L4                 :
	case D3DFMT_S8_LOCKABLE          :
	case D3DFMT_A16B16G16R16         :
	case D3DFMT_Q16W16V16U16         :
	case D3DFMT_A16B16G16R16F        :
	case D3DFMT_G32R32F              :
	case D3DFMT_A32B32G32R32F        :
    case D3DFMT_UYVY                 :
    case D3DFMT_R8G8_B8G8            :
    case D3DFMT_YUY2                 :
    case D3DFMT_G8R8_G8B8            :
	case D3DFMT_A1                   :
	case D3DFMT_VERTEXDATA           :
	case D3DFMT_MULTI2_ARGB8         :
	case D3DFMT_BINARYBUFFER         :
	default:
		return GetSurfacePitchBytes(Width, Format) * Height;
    case D3DFMT_DXT1                 :
    case D3DFMT_DXT2                 :
    case D3DFMT_DXT3                 :
    case D3DFMT_DXT4                 :
    case D3DFMT_DXT5                 :
		return GetSurfacePitchBytes(Width, Format) * RoundUpTo4(Height);
	}
}

static inline void AllocSurfaceBytes(const unsigned surfaceBytesSize, BYTE*& outAllocBytes, unsigned& outSurfaceBytesSize)
{
	void* voidBytes = NULL;
#ifdef SURFACE_ALLOC_PAGE_NOACCESS
	voidBytes = PageAllocWithNoAccessPage(surfaceBytesSize);
#else // #ifdef SURFACE_ALLOC_PAGE_NOACCESS
	voidBytes = malloc(surfaceBytesSize);
#endif // #ifdef SURFACE_ALLOC_PAGE_NOACCESS

	if (!voidBytes)
	{
		__debugbreak(); // Can't alloc our new surface!
	}

	outAllocBytes = (BYTE* const)voidBytes;
	outSurfaceBytesSize = surfaceBytesSize;
}

void IDirect3DSurface9Hook::UpdateCachedValuesOnCreate()
{
	is1x1surface = (InternalWidth == 1 && InternalHeight == 1);
	InternalWidthM1 = InternalWidth - 1;
	InternalHeightM1 = InternalHeight - 1;
	InternalWidthM1F = (const float)InternalWidthM1;
	InternalHeightM1F = (const float)InternalHeightM1;

	InternalWidthSplatted = _mm_set1_epi32(InternalWidth);
	InternalWidthSplattedF = _mm_cvtepi32_ps(InternalWidthSplatted);
	InternalHeightSplattedF = _mm_cvtepi32_ps(_mm_set1_epi32(InternalHeight) );
	InternalWidthM1SplattedF = _mm_set1_ps(InternalWidthM1F);
	InternalHeightM1SplattedF = _mm_set1_ps(InternalHeightM1F);
	InternalWidthM1Splatted = _mm_set1_epi32(InternalWidthM1);
	InternalHeightM1Splatted = _mm_set1_epi32(InternalHeightM1);
	InternalWidthHeightM1F = _mm_set_ps(0.0f, 0.0f, InternalHeightM1F, InternalWidthM1F);
	InternalWidthHeightM2F = _mm_set_ps(0.0f, 0.0f, (const float)(InternalHeightM1 - 1), (const float)(InternalWidthM1 - 1) );
}

void IDirect3DSurface9Hook::CreateOffscreenPlainSurface(UINT _Width, UINT _Height, D3DFORMAT _Format, D3DPOOL _Pool)
{
	creationMethod = createOffscreenPlain;
	InternalWidth = _Width;
	InternalHeight = _Height;
	InternalFormat = _Format;
	InternalPool = _Pool;
	LockableRT = TRUE;
	DiscardRT = FALSE;
	InternalMultiSampleType = D3DMULTISAMPLE_NONE;
	InternalMultiSampleQuality = 0;
	UpdateCachedValuesOnCreate();

	AllocSurfaceBytes(GetSurfaceSizeBytes(InternalWidth, InternalHeight, InternalFormat)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
		, surfaceBytesRaw, surfaceBytesRawSize);

	if (IsCompressedFormat(InternalFormat) )
	{
		AllocSurfaceBytes(GetSurfaceSizeBytes( (InternalWidth + 3) & ~3, (InternalHeight + 3) & ~3, D3DFMT_A8R8G8B8)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
			, auxSurfaceBytesRaw, auxSurfaceBytesRawSize);
	}

#ifdef SURFACE_MAGIC_COOKIE
	DWORD* const magicDword = (DWORD* const)surfaceBytesRaw + (surfaceBytes.size() / sizeof(DWORD) - 1);
	*magicDword = surfaceMagicBytes;
#endif // SURFACE_MAGIC_COOKIE

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif

#ifdef _DEBUG
	ValidateRealObjectDesc();
#endif
}

void IDirect3DSurface9Hook::CreateDepthStencilSurface(UINT _Width, UINT _Height, D3DFORMAT _Format, D3DMULTISAMPLE_TYPE _MultiSample, DWORD _MultisampleQuality, BOOL _Discard)
{
	creationMethod = createDepthStencil;
	InternalWidth = _Width;
	InternalHeight = _Height;
	InternalFormat = _Format;
	DiscardRT = _Discard;
	LockableRT = FALSE;
	InternalPool = D3DPOOL_DEFAULT;
	InternalMultiSampleType = _MultiSample;
	InternalMultiSampleQuality = _MultisampleQuality;
	InternalUsage = (const DebuggableUsage)(D3DUSAGE_DEPTHSTENCIL); // Important not to mark this with the D3DUSAGE_RENDERTARGET Usage because that will get a Usage-mismatch with real D3D9!
	UpdateCachedValuesOnCreate();

	AllocSurfaceBytes(GetSurfaceSizeBytes(InternalWidth, InternalHeight, InternalFormat)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
		, surfaceBytesRaw, surfaceBytesRawSize);

	if (HasStencil(InternalFormat) )
	{
		AllocSurfaceBytes(GetSurfaceSizeBytes(InternalWidth, InternalHeight, D3DFMT_S8_LOCKABLE)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
			, auxSurfaceBytesRaw, auxSurfaceBytesRawSize);
	}

#ifdef SURFACE_MAGIC_COOKIE
	DWORD* const magicDword = (DWORD* const)surfaceBytesRaw + (surfaceBytes.size() / sizeof(DWORD) - 1);
	*magicDword = surfaceMagicBytes;
#endif // SURFACE_MAGIC_COOKIE

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif

#ifdef _DEBUG
	ValidateRealObjectDesc();
#endif
}

void IDirect3DSurface9Hook::CreateRenderTarget(UINT _Width, UINT _Height, D3DFORMAT _Format, D3DMULTISAMPLE_TYPE _MultiSample, DWORD _MultisampleQuality, BOOL _Lockable)
{
	creationMethod = createRenderTarget;
	InternalWidth = _Width;
	InternalHeight = _Height;
	InternalFormat = _Format;
	LockableRT = _Lockable;
	DiscardRT = FALSE;
	InternalPool = D3DPOOL_DEFAULT;
	InternalMultiSampleType = _MultiSample;
	InternalMultiSampleQuality = _MultisampleQuality;
	InternalUsage = (const DebuggableUsage)(D3DUSAGE_RENDERTARGET);
	UpdateCachedValuesOnCreate();

	AllocSurfaceBytes(GetSurfaceSizeBytes(InternalWidth, InternalHeight, InternalFormat)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
		, surfaceBytesRaw, surfaceBytesRawSize);

	if (IsCompressedFormat(InternalFormat) )
	{
		AllocSurfaceBytes(GetSurfaceSizeBytes( (InternalWidth + 3) & ~3, (InternalHeight + 3) & ~3, D3DFMT_A8R8G8B8)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
			, auxSurfaceBytesRaw, auxSurfaceBytesRawSize);
	}

#ifdef SURFACE_MAGIC_COOKIE
	DWORD* const magicDword = (DWORD* const)surfaceBytesRaw + (surfaceBytes.size() / sizeof(DWORD) - 1);
	*magicDword = surfaceMagicBytes;
#endif // SURFACE_MAGIC_COOKIE

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif

#ifdef _DEBUG
	ValidateRealObjectDesc();
#endif
}

void IDirect3DSurface9Hook::CreateTextureImplicitSurface(UINT _Width, UINT _Height, D3DFORMAT _Format, D3DPOOL _Pool, const DebuggableUsage _Usage, UINT _Level, IDirect3DTexture9Hook* _HookParentTexturePtr)
{
	creationMethod = createTexture;
	InternalWidth = _Width;
	InternalHeight = _Height;
	InternalFormat = _Format;
	InternalPool = _Pool;
	InternalUsage = _Usage;
	InternalMultiSampleType = D3DMULTISAMPLE_NONE;
	InternalMultiSampleQuality = 0;
	TextureSurfaceLevel = _Level;
	HookParentTexturePtr = _HookParentTexturePtr;
	LockableRT = TRUE;
	if (InternalPool == D3DPOOL_DEFAULT && !(InternalUsage & D3DUSAGE_DYNAMIC) ) // Default, non-dynamic texture surfaces are non-lockable!
	{
		LockableRT = FALSE;
	}
	DiscardRT = FALSE;
	UpdateCachedValuesOnCreate();

	AllocSurfaceBytes(GetSurfaceSizeBytes(InternalWidth, InternalHeight, InternalFormat)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
		, surfaceBytesRaw, surfaceBytesRawSize);

	if (IsCompressedFormat(InternalFormat) )
	{
		AllocSurfaceBytes(GetSurfaceSizeBytes( (InternalWidth + 3) & ~3, (InternalHeight + 3) & ~3, D3DFMT_A8R8G8B8)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
			, auxSurfaceBytesRaw, auxSurfaceBytesRawSize);
	}

#ifdef SURFACE_MAGIC_COOKIE
	DWORD* const magicDword = (DWORD* const)surfaceBytesRaw + (surfaceBytes.size() / sizeof(DWORD) - 1);
	*magicDword = surfaceMagicBytes;
#endif // SURFACE_MAGIC_COOKIE

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif

#ifdef _DEBUG
	ValidateRealObjectDesc();
#endif
}

void IDirect3DSurface9Hook::CreateDeviceImplicitSurface(const D3DPRESENT_PARAMETERS& d3dpp)
{
	creationMethod = deviceImplicitBackbuffer;
	InternalWidth = d3dpp.BackBufferWidth;
	InternalHeight = d3dpp.BackBufferHeight;
	InternalFormat = d3dpp.BackBufferFormat;
	InternalPool = D3DPOOL_DEFAULT;
	InternalMultiSampleType = d3dpp.MultiSampleType;
	InternalMultiSampleQuality = d3dpp.MultiSampleQuality;
	InternalUsage = (const DebuggableUsage)(D3DUSAGE_RENDERTARGET); // The implicit backbuffer is a rendertarget
	UpdateCachedValuesOnCreate();

	if (d3dpp.Flags & D3DPRESENTFLAG_LOCKABLE_BACKBUFFER)
		LockableRT = TRUE;
	else
		LockableRT = FALSE;

	DiscardRT = FALSE;

	AllocSurfaceBytes(GetSurfaceSizeBytes(InternalWidth, InternalHeight, InternalFormat)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
		, surfaceBytesRaw, surfaceBytesRawSize);

	if (IsCompressedFormat(InternalFormat) )
	{
		AllocSurfaceBytes(GetSurfaceSizeBytes( (InternalWidth + 3) & ~3, (InternalHeight + 3) & ~3, D3DFMT_A8R8G8B8)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
			, auxSurfaceBytesRaw, auxSurfaceBytesRawSize);
	}

#ifdef SURFACE_MAGIC_COOKIE
	DWORD* const magicDword = (DWORD* const)surfaceBytesRaw + (surfaceBytes.size() / sizeof(DWORD) - 1);
	*magicDword = surfaceMagicBytes;
#endif // SURFACE_MAGIC_COOKIE

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif

#ifdef _DEBUG
	ValidateRealObjectDesc();
#endif
}

void IDirect3DSurface9Hook::CreateDeviceImplicitDepthStencil(const D3DPRESENT_PARAMETERS& d3dpp)
{
	creationMethod = deviceImplicitDepthStencil;
	InternalWidth = d3dpp.BackBufferWidth;
	InternalHeight = d3dpp.BackBufferHeight;
	InternalFormat = d3dpp.AutoDepthStencilFormat;
	InternalPool = D3DPOOL_DEFAULT;
	InternalMultiSampleType = d3dpp.MultiSampleType;
	InternalMultiSampleQuality = d3dpp.MultiSampleQuality;
	InternalUsage = (const DebuggableUsage)(D3DUSAGE_DEPTHSTENCIL); // Important not to mark this with the D3DUSAGE_RENDERTARGET Usage because that will get a Usage-mismatch with real D3D9!
	LockableRT = FALSE;
	UpdateCachedValuesOnCreate();

	if (d3dpp.Flags & D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL)
		DiscardRT = TRUE;
	else
		DiscardRT = FALSE;

	AllocSurfaceBytes(GetSurfaceSizeBytes(InternalWidth, InternalHeight, InternalFormat)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
		, surfaceBytesRaw, surfaceBytesRawSize);

	if (HasStencil(InternalFormat) )
	{
		AllocSurfaceBytes(GetSurfaceSizeBytes(InternalWidth, InternalHeight, D3DFMT_S8_LOCKABLE)
#ifdef SURFACE_MAGIC_COOKIE
		+ sizeof(DWORD)
#endif
			, auxSurfaceBytesRaw, auxSurfaceBytesRawSize);
	}

#ifdef SURFACE_MAGIC_COOKIE
	DWORD* const magicDword = (DWORD* const)surfaceBytesRaw + (surfaceBytes.size() / sizeof(DWORD) - 1);
	*magicDword = surfaceMagicBytes;
#endif // SURFACE_MAGIC_COOKIE

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif

#ifdef _DEBUG
	ValidateRealObjectDesc();
#endif
}

// Fills a rect on this surface with a color (.rgba). A NULL rectangle means to fill the entire surface.
void IDirect3DSurface9Hook::InternalColor4Fill(const D3DXVECTOR4& color, const D3DRECT* const pRect/* = NULL*/)
{
	if (!pRect)
	{
		switch (InternalFormat)
		{
		case D3DFMT_X8R8G8B8:
		case D3DFMT_A8R8G8B8:
		{
			const D3DCOLOR ldrColor = Float4ToD3DCOLORClamp(color);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(D3DCOLOR) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			D3DCOLOR* const originPtr = (D3DCOLOR* const)surfaceBytesRaw;
			const unsigned numPixels = InternalWidth * InternalHeight;
			for (unsigned x = 0; x < numPixels; ++x)
				originPtr[x] = ldrColor;
		}
			break;
		case D3DFMT_A16B16G16R16:
		{
			A16B16G16R16 writeColor;
			Float4ToA16B16G16R16(color, writeColor);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(A16B16G16R16) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			A16B16G16R16* const originPtr = (A16B16G16R16* const)surfaceBytesRaw;
			const unsigned numPixels = InternalWidth * InternalHeight;
			for (unsigned x = 0; x < numPixels; ++x)
				originPtr[x] = writeColor;
		}
			break;
		case D3DFMT_A16B16G16R16F:
		{
			A16B16G16R16F writeColor;
			Float4ToA16B16G16R16F(color, writeColor);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(A16B16G16R16F) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			A16B16G16R16F* const originPtr = (A16B16G16R16F* const)surfaceBytesRaw;
			const unsigned numPixels = InternalWidth * InternalHeight;
			for (unsigned x = 0; x < numPixels; ++x)
				originPtr[x] = writeColor;
		}
			break;
		case D3DFMT_A32B32G32R32F:
		{
			A32B32G32R32F writeColor;
			Float4ToA32B32G32R32F(color, writeColor);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(A32B32G32R32F) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			A32B32G32R32F* const originPtr = (A32B32G32R32F* const)surfaceBytesRaw;
			const unsigned numPixels = InternalWidth * InternalHeight;
			for (unsigned x = 0; x < numPixels; ++x)
				originPtr[x] = writeColor;
		}
			break;
		case D3DFMT_R16F:
		{
			D3DXFLOAT16 writeColor;
			Float4ToR16F(color, writeColor);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(D3DXFLOAT16) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			D3DXFLOAT16* const originPtr = (D3DXFLOAT16* const)surfaceBytesRaw;
			const unsigned numPixels = InternalWidth * InternalHeight;
			for (unsigned x = 0; x < numPixels; ++x)
				originPtr[x] = writeColor;
		}
			break;
		case D3DFMT_L8:
		{
			unsigned char writeColor;
			Float4ToL8Clamp(color, writeColor);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(unsigned char) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			unsigned char* const originPtr = (unsigned char* const)surfaceBytesRaw;
			const unsigned numPixels = InternalWidth * InternalHeight;
			for (unsigned x = 0; x < numPixels; ++x)
				originPtr[x] = writeColor;
		}
			break;
		default: // TODO: Add more formats. This function is used in the D3D9 Clear() call.
			// Not yet supported!
			__debugbreak();
			break;
		}
	}
	else
	{
		switch (InternalFormat)
		{
		case D3DFMT_X8R8G8B8:
		case D3DFMT_A8R8G8B8:
		{
			const D3DCOLOR ldrColor = Float4ToD3DCOLORClamp(color);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(D3DCOLOR) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			D3DCOLOR* const originPtr = (D3DCOLOR* const)surfaceBytesRaw + pRect->x1;
			const unsigned rowFillSizePixels = (pRect->x2 - pRect->x1);
			const unsigned rowFillSizeBytes = sizeof(D3DCOLOR) * rowFillSizePixels;
			for (int row = pRect->y1; row < pRect->y2; ++row)
			{
				D3DCOLOR* const topLeftPtr = originPtr + (row * InternalWidth);
				for (unsigned column = 0; column < rowFillSizePixels; ++column)
					topLeftPtr[column] = ldrColor;

				// Memset sucks, it only splats one byte, not the whole DWORD!
				//memset(topLeftPtr, ldrColor, rowFillSizeBytes);
			}
		}
			break;
		case D3DFMT_A16B16G16R16:
		{
			A16B16G16R16 writeColor;
			Float4ToA16B16G16R16(color, writeColor);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(A16B16G16R16) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			A16B16G16R16* const originPtr = (A16B16G16R16* const)surfaceBytesRaw + pRect->x1;
			const unsigned rowFillSizePixels = (pRect->x2 - pRect->x1);
			const unsigned rowFillSizeBytes = sizeof(A16B16G16R16) * rowFillSizePixels;
			for (int row = pRect->y1; row < pRect->y2; ++row)
			{
				A16B16G16R16* const topLeftPtr = originPtr + (row * InternalWidth);
				for (unsigned column = 0; column < rowFillSizePixels; ++column)
					topLeftPtr[column] = writeColor;
			}
		}
			break;
		case D3DFMT_A16B16G16R16F:
		{
			A16B16G16R16F writeColor;
			Float4ToA16B16G16R16F(color, writeColor);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(A16B16G16R16F) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			A16B16G16R16F* const originPtr = (A16B16G16R16F* const)surfaceBytesRaw + pRect->x1;
			const unsigned rowFillSizePixels = (pRect->x2 - pRect->x1);
			const unsigned rowFillSizeBytes = sizeof(A16B16G16R16F) * rowFillSizePixels;
			for (int row = pRect->y1; row < pRect->y2; ++row)
			{
				A16B16G16R16F* const topLeftPtr = originPtr + (row * InternalWidth);
				for (unsigned column = 0; column < rowFillSizePixels; ++column)
					topLeftPtr[column] = writeColor;
			}
		}
			break;
		case D3DFMT_A32B32G32R32F:
		{
			A32B32G32R32F writeColor;
			Float4ToA32B32G32R32F(color, writeColor);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(A32B32G32R32F) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			A32B32G32R32F* const originPtr = (A32B32G32R32F* const)surfaceBytesRaw + pRect->x1;
			const unsigned rowFillSizePixels = (pRect->x2 - pRect->x1);
			const unsigned rowFillSizeBytes = sizeof(A32B32G32R32F) * rowFillSizePixels;
			for (int row = pRect->y1; row < pRect->y2; ++row)
			{
				A32B32G32R32F* const topLeftPtr = originPtr + (row * InternalWidth);
				for (unsigned column = 0; column < rowFillSizePixels; ++column)
					topLeftPtr[column] = writeColor;
			}
		}
			break;
		case D3DFMT_R16F:
		{
			D3DXFLOAT16 writeColor;
			Float4ToR16F(color, writeColor);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(D3DXFLOAT16) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			D3DXFLOAT16* const originPtr = (D3DXFLOAT16* const)surfaceBytesRaw + pRect->x1;
			const unsigned rowFillSizePixels = (pRect->x2 - pRect->x1);
			const unsigned rowFillSizeBytes = sizeof(D3DXFLOAT16) * rowFillSizePixels;
			for (int row = pRect->y1; row < pRect->y2; ++row)
			{
				D3DXFLOAT16* const topLeftPtr = originPtr + (row * InternalWidth);
				for (unsigned column = 0; column < rowFillSizePixels; ++column)
					topLeftPtr[column] = writeColor;
			}
		}
			break;
		case D3DFMT_L8:
		{
			unsigned char writeColor;
			Float4ToL8Clamp(color, writeColor);
#ifdef _DEBUG
			if (surfaceBytesRawSize != sizeof(unsigned char) * InternalWidth * InternalHeight
#ifdef SURFACE_MAGIC_COOKIE
				+ sizeof(DWORD)
#endif
				)
			{
				__debugbreak();
			}
#endif
			unsigned char* const originPtr = (unsigned char* const)surfaceBytesRaw + pRect->x1;
			const unsigned rowFillSizePixels = (pRect->x2 - pRect->x1);
			const unsigned rowFillSizeBytes = sizeof(unsigned char) * rowFillSizePixels;
			for (int row = pRect->y1; row < pRect->y2; ++row)
			{
				unsigned char* const topLeftPtr = originPtr + (row * InternalWidth);
				for (unsigned column = 0; column < rowFillSizePixels; ++column)
					topLeftPtr[column] = writeColor;
			}
		}
			break;
		default: // TODO: Add more formats. This function is used in the D3D9 Clear() call.
			// Not yet supported!
			__debugbreak();
			break;
		}
	}

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif
}

// Fills a rect on this surface with a color (.rgba). A NULL rectangle means to fill the entire surface.
void IDirect3DSurface9Hook::InternalColorFill(const D3DCOLOR color, const D3DRECT* const pRect/* = NULL*/)
{
	D3DXVECTOR4 colorFloat4;
	ColorDWORDToFloat4(color, colorFloat4);

	if (pRect)
	{
		const LONG WidthM1 = InternalWidthM1;
		const LONG HeightM1 = InternalHeightM1;

		D3DRECT clippedRect;
		if (pRect->x1 < 0)
			clippedRect.x1 = 0;
		else if (pRect->x1 > WidthM1)
			clippedRect.x1 = WidthM1;
		else
			clippedRect.x1 = pRect->x1;
		if (pRect->x2 < 0)
			clippedRect.x2 = 0;
		else if (pRect->x2 > WidthM1)
			clippedRect.x2 = WidthM1;
		else
			clippedRect.x2 = pRect->x2;
		if (pRect->y1 < 0)
			clippedRect.y1 = 0;
		else if (pRect->y1 > HeightM1)
			clippedRect.y1 = HeightM1;
		else
			clippedRect.y1 = pRect->y1;
		if (pRect->y2 < 0)
			clippedRect.y2 = 0;
		else if (pRect->y2 > HeightM1)
			clippedRect.y2 = HeightM1;
		else
			clippedRect.y2 = pRect->y2;
		if (clippedRect.x2 < clippedRect.x1)
			clippedRect.x2 = clippedRect.x1;
		if (clippedRect.y2 < clippedRect.y1)
			clippedRect.y2 = clippedRect.y1;

		InternalColor4Fill(colorFloat4, &clippedRect);
	}
	else
	{
		InternalColor4Fill(colorFloat4, NULL);
	}

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif
}

// Fills a rect on this surface with a depth value. A NULL rectangle means to fill the entire surface.
void IDirect3DSurface9Hook::InternalDepthFill(const float depth, const D3DRECT* const pRect/* = NULL*/)
{
	if (pRect)
	{
		if (pRect->x1 != 0 || pRect->y1 != 0 || pRect->x2 != InternalWidth || pRect->y2 != InternalHeight)
		{
			// TODO: Fill this in. This function is used in the D3D9 Clear() call.
			__debugbreak();
			return;
		}
	}

	switch (InternalFormat)
	{
	case D3DFMT_D15S1:
	{
		unsigned short* const pixels = (unsigned short* const)surfaceBytesRaw;
		const unsigned short formatPixel = (const unsigned short)(0x7FFF * depth);
		const unsigned numPixels = InternalWidth * InternalHeight;
		for (unsigned x = 0; x < numPixels; ++x)
			pixels[x] = formatPixel;
	}
	break;
	case D3DFMT_D16:
	case D3DFMT_D16_LOCKABLE:
	{
		unsigned short* const pixels = (unsigned short* const)surfaceBytesRaw;
		const unsigned short formatPixel = (const unsigned short)(0xFFFF * depth);
		const unsigned numPixels = InternalWidth * InternalHeight;
		for (unsigned x = 0; x < numPixels; ++x)
			pixels[x] = formatPixel;
	}
		break;
	case D3DFMT_D24FS8:
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24X8:
	{
		unsigned* const pixels = (unsigned* const)surfaceBytesRaw;
		const unsigned formatPixel = (const unsigned)(0x00FFFFFF * depth);
		const unsigned numPixels = InternalWidth * InternalHeight;
		for (unsigned x = 0; x < numPixels; ++x)
			pixels[x] = formatPixel;
	}
		break;
	case D3DFMT_D32:
	case D3DFMT_D32_LOCKABLE:
	case MAKEFOURCC('I', 'N', 'T', 'Z'):
	{
		unsigned* const pixels = (unsigned * const)surfaceBytesRaw;
		const unsigned formatPixel = (const unsigned)(0xFFFFFFFF * depth);
		const unsigned numPixels = InternalWidth * InternalHeight;
		for (unsigned x = 0; x < numPixels; ++x)
			pixels[x] = formatPixel;
	}
		break;
	case D3DFMT_D32F_LOCKABLE:
	{
		float* const pixels = (float* const)surfaceBytesRaw;
		const unsigned numPixels = InternalWidth * InternalHeight;
		for (unsigned x = 0; x < numPixels; ++x)
			pixels[x] = depth;
	}
		break;
	default:
#ifdef _DEBUG
		__debugbreak(); // Error: Can't call SetDepth() on non-depth formats!
#endif
	break;
	}

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif
}

// Fills a rect on this surface with a stencil value. A NULL rectangle means to fill the entire surface.
void IDirect3DSurface9Hook::InternalStencilFill(const DWORD stencil, const D3DRECT* const pRect/* = NULL*/)
{
	if (!HasStencil(InternalFormat) )
		return;

	const DWORD stencilFormatMask = GetStencilFormatMask(InternalFormat);
	const DWORD maskedStencil = stencilFormatMask & stencil;
	const BYTE maskedStencilByte = (const BYTE)maskedStencil;

	if (!pRect)
	{
		BYTE* const stencilBuffer = auxSurfaceBytesRaw;
		memset(stencilBuffer, maskedStencilByte, InternalWidth * InternalHeight * sizeof(BYTE) );
	}
	else
	{
		BYTE* const originPtr = auxSurfaceBytesRaw + pRect->x1;
		const unsigned rowFillSizePixels = (pRect->x2 - pRect->x1);
		for (int row = pRect->y1; row < pRect->y2; ++row)
		{
			BYTE* const topLeftPtr = originPtr + (row * InternalWidth);
			for (unsigned column = 0; column < rowFillSizePixels; ++column)
				topLeftPtr[column] = maskedStencilByte;
		}
	}

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif
}

void IDirect3DSurface9Hook::SetPixel(const unsigned x, const unsigned y, const D3DCOLOR color)
{
	if (InternalFormat == D3DFMT_X8R8G8B8 || InternalFormat == D3DFMT_A8R8G8B8)
	{
		D3DCOLOR* const pixels = (D3DCOLOR* const)surfaceBytesRaw;
		D3DCOLOR& outPixel = pixels[y * InternalWidth + x];
#ifdef WITH_SURFACE_HASHING
		RecomputePartialSurfaceHash(outPixel, color);
#endif
		outPixel = color;
	}
	else
	{
		// TODO: Add support for more surface types!
		__debugbreak();
	}
}

const D3DCOLOR IDirect3DSurface9Hook::GetPixel(const unsigned x, const unsigned y) const
{
#ifdef _DEBUG
	if (InternalFormat == D3DFMT_X8R8G8B8 || InternalFormat == D3DFMT_A8R8G8B8)
	{
#endif
		const D3DCOLOR* const pixels = (const D3DCOLOR* const)surfaceBytesRaw;
		return pixels[y * InternalWidth + x];
#ifdef _DEBUG
	}
	else
	{
		__debugbreak();
	}
	return 0x00000000;
#endif
}

const A4R4G4B4 IDirect3DSurface9Hook::GetPixel4444(const unsigned x, const unsigned y) const
{
#ifdef _DEBUG
	if (InternalFormat != D3DFMT_A4R4G4B4)
	{
		__debugbreak();
	}
#endif

	const A4R4G4B4* const pixels = (const A4R4G4B4* const)surfaceBytesRaw;
	return pixels[y * InternalWidth + x];
}

const X4R4G4B4 IDirect3DSurface9Hook::GetPixel4440(const unsigned x, const unsigned y) const
{
#ifdef _DEBUG
	if (InternalFormat != D3DFMT_X4R4G4B4)
	{
		__debugbreak();
	}
#endif

	const X4R4G4B4* const pixels = (const X4R4G4B4* const)surfaceBytesRaw;
	return pixels[y * InternalWidth + x];
}

const RGB565 IDirect3DSurface9Hook::GetPixel565(const unsigned x, const unsigned y) const
{
#ifdef _DEBUG
	if (InternalFormat != D3DFMT_R5G6B5)
	{
		__debugbreak();
	}
#endif

	const RGB565* const pixels = (const RGB565* const)surfaceBytesRaw;
	return pixels[y * InternalWidth + x];
}

template void IDirect3DSurface9Hook::GetPixelVec<0, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<1, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<2, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<3, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<4, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<5, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<6, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<7, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<8, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<9, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<10, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<11, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<12, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<13, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<14, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<15, false>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<0, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<1, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<2, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<3, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<4, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<5, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<6, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<7, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<8, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<9, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<10, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<11, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<12, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<13, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<14, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::GetPixelVec<15, true>(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;

#ifdef USE_CHEAP_GAMMA_APPROXIMATION

static const float gamma2_2 = 2.2f;
template <const unsigned char writeMask>
static inline void GammaCorrectSample(D3DXVECTOR4& outColor)
{
	if (writeMask & 0x1)
		outColor.x = powf(outColor.x, gamma2_2);
	if (writeMask & 0x2)
		outColor.y = powf(outColor.y, gamma2_2);
	if (writeMask & 0x4)
		outColor.z = powf(outColor.z, gamma2_2);
}

template <const unsigned char writeMask, const unsigned char pixelWriteMask>
static inline void GammaCorrectSample4(D3DXVECTOR4 (&outColor4)[4])
{
	if (writeMask & 0x1)
	{
		if (pixelWriteMask & 0x1) outColor4[0].x = powf(outColor4[0].x, gamma2_2);
		if (pixelWriteMask & 0x2) outColor4[1].x = powf(outColor4[1].x, gamma2_2);
		if (pixelWriteMask & 0x4) outColor4[2].x = powf(outColor4[2].x, gamma2_2);
		if (pixelWriteMask & 0x8) outColor4[3].x = powf(outColor4[3].x, gamma2_2);
	}
	if (writeMask & 0x2)
	{
		if (pixelWriteMask & 0x1) outColor4[0].y = powf(outColor4[0].y, gamma2_2);
		if (pixelWriteMask & 0x2) outColor4[1].y = powf(outColor4[1].y, gamma2_2);
		if (pixelWriteMask & 0x4) outColor4[2].y = powf(outColor4[2].y, gamma2_2);
		if (pixelWriteMask & 0x8) outColor4[3].y = powf(outColor4[3].y, gamma2_2);
	}
	if (writeMask & 0x4)
	{
		if (pixelWriteMask & 0x1) outColor4[0].z = powf(outColor4[0].z, gamma2_2);
		if (pixelWriteMask & 0x2) outColor4[1].z = powf(outColor4[1].z, gamma2_2);
		if (pixelWriteMask & 0x4) outColor4[2].z = powf(outColor4[2].z, gamma2_2);
		if (pixelWriteMask & 0x8) outColor4[3].z = powf(outColor4[3].z, gamma2_2);
	}
}

#else

static const float gamma2_4 = 2.4f;
static const float inv1055 = 1.0f / 1.055f;
static const float inv1292 = 1.0f / 12.92f;
template <const unsigned char writeMask>
static inline void GammaCorrectSample(D3DXVECTOR4& outColor)
{
	if (writeMask & 0x1)
	{
		if (outColor.x > 0.04045)
			outColor.x = powf( (outColor.x + 0.055f) * inv1055, gamma2_4);
		else
			outColor.x = outColor.x * inv1292;
	}
	if (writeMask & 0x2)
	{
		if (outColor.y > 0.04045)
			outColor.y = powf( (outColor.y + 0.055f) * inv1055, gamma2_4);
		else
			outColor.y = outColor.y * inv1292;
	}
	if (writeMask & 0x4)
	{
		if (outColor.z > 0.04045)
			outColor.z = powf( (outColor.z + 0.055f) * inv1055, gamma2_4);
		else
			outColor.z = outColor.z * inv1292;
	}
}

template <const unsigned char writeMask, const unsigned char pixelWriteMask>
static inline void GammaCorrectSample4(D3DXVECTOR4 (&outColor4)[4])
{
	if (writeMask & 0x1)
	{
		if (pixelWriteMask & 0x1)
		{
			if (outColor4[0].x > 0.04045) outColor4[0].x = powf( (outColor4[0].x + 0.055f) * inv1055, gamma2_4);
			else outColor4[0].x = outColor4[0].x * inv1292;
		}
		if (pixelWriteMask & 0x2)
		{
			if (outColor4[1].x > 0.04045) outColor4[1].x = powf( (outColor4[1].x + 0.055f) * inv1055, gamma2_4);
			else outColor4[1].x = outColor4[1].x * inv1292;
		}
		if (pixelWriteMask & 0x4)
		{
			if (outColor4[2].x > 0.04045) outColor4[2].x = powf( (outColor4[2].x + 0.055f) * inv1055, gamma2_4);
			else outColor4[2].x = outColor4[2].x * inv1292;
		}
		if (pixelWriteMask & 0x8)
		{
			if (outColor4[3].x > 0.04045) outColor4[3].x = powf( (outColor4[3].x + 0.055f) * inv1055, gamma2_4);
			else outColor4[3].x = outColor4[3].x * inv1292;
		}
	}
	if (writeMask & 0x2)
	{
		if (pixelWriteMask & 0x1)
		{
			if (outColor4[0].y > 0.04045) outColor4[0].y = powf( (outColor4[0].y + 0.055f) * inv1055, gamma2_4);
			else outColor4[0].y = outColor4[0].y * inv1292;
		}
		if (pixelWriteMask & 0x2)
		{
			if (outColor4[1].y > 0.04045) outColor4[1].y = powf( (outColor4[1].y + 0.055f) * inv1055, gamma2_4);
			else outColor4[1].y = outColor4[1].y * inv1292;
		}
		if (pixelWriteMask & 0x4)
		{
			if (outColor4[2].y > 0.04045) outColor4[2].y = powf( (outColor4[2].y + 0.055f) * inv1055, gamma2_4);
			else outColor4[2].y = outColor4[2].y * inv1292;
		}
		if (pixelWriteMask & 0x8)
		{
			if (outColor4[3].y > 0.04045) outColor4[3].y = powf( (outColor4[3].y + 0.055f) * inv1055, gamma2_4);
			else outColor4[3].y = outColor4[3].y * inv1292;
		}
	}
	if (writeMask & 0x4)
	{
		if (pixelWriteMask & 0x1)
		{
			if (outColor4[0].z > 0.04045) outColor4[0].z = powf( (outColor4[0].z + 0.055f) * inv1055, gamma2_4);
			else outColor4[0].z = outColor4[0].z * inv1292;
		}
		if (pixelWriteMask & 0x2)
		{
			if (outColor4[1].z > 0.04045) outColor4[1].z = powf( (outColor4[1].z + 0.055f) * inv1055, gamma2_4);
			else outColor4[1].z = outColor4[1].z * inv1292;
		}
		if (pixelWriteMask & 0x4)
		{
			if (outColor4[2].z > 0.04045) outColor4[2].z = powf( (outColor4[2].z + 0.055f) * inv1055, gamma2_4);
			else outColor4[2].z = outColor4[2].z * inv1292;
		}
		if (pixelWriteMask & 0x8)
		{
			if (outColor4[3].z > 0.04045) outColor4[3].z = powf( (outColor4[3].z + 0.055f) * inv1055, gamma2_4);
			else outColor4[3].z = outColor4[3].z * inv1292;
		}
	}
}

#endif

template <const unsigned char writeMask, const bool sRGBSurface>
void IDirect3DSurface9Hook::GetPixelVec(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const
{
	switch (InternalFormat)
	{
	default:
#ifdef _DEBUG
		__debugbreak(); // TODO: Add support for more surface types!
#else
		__assume(0);
#endif
	case D3DFMT_X8R8G8B8:
	{
		const D3DCOLOR ldrColor = GetPixel(x, y);
		ColorDWORDToFloat4<writeMask & 0x7>(ldrColor, outColor);
		outColor.w = 1.0f;
		if (sRGBSurface)
			GammaCorrectSample<writeMask & 0x7>(outColor);
	}
		break;
	case D3DFMT_A8R8G8B8:
	{
		const D3DCOLOR ldrColor = GetPixel(x, y);
		ColorDWORDToFloat4<writeMask>(ldrColor, outColor);
		if (sRGBSurface)
			GammaCorrectSample<writeMask & 0x7>(outColor);
	}
		break;
	case D3DFMT_A4R4G4B4:
	{
		const A4R4G4B4 ldrColor = GetPixel4444(x, y);
		ColorA4R4G4B4ToFloat4<writeMask>(ldrColor, outColor);
		if (sRGBSurface)
			GammaCorrectSample<writeMask & 0x7>(outColor);
	}
		break;
	case D3DFMT_X4R4G4B4:
	{
		const X4R4G4B4 ldrColor = GetPixel4440(x, y);
		ColorX4R4G4B4ToFloat4<writeMask>(ldrColor, outColor);
		if (sRGBSurface)
			GammaCorrectSample<writeMask & 0x7>(outColor);
	}
		break;
	case D3DFMT_R5G6B5:
	{
		const RGB565 ldrColor = GetPixel565(x, y);
		ColorRGB565ToFloat4<writeMask>(ldrColor, outColor);
		if (sRGBSurface)
			GammaCorrectSample<writeMask & 0x7>(outColor);
	}
		break;
	case D3DFMT_A16B16G16R16:
	{
		const A16B16G16R16* const pixels = (const A16B16G16R16* const)surfaceBytesRaw;
		const A16B16G16R16& pixel = pixels[y * InternalWidth + x];
		ColorA16B16G16R16ToFloat4<writeMask>(pixel, outColor);
		if (sRGBSurface)
			GammaCorrectSample<writeMask & 0x7>(outColor);
	}
		break;
	case D3DFMT_A16B16G16R16F:
	{
		const A16B16G16R16F* const pixels = (const A16B16G16R16F* const)surfaceBytesRaw;
		const A16B16G16R16F& pixel = pixels[y * InternalWidth + x];
		ColorA16B16G16R16FToFloat4<writeMask>(pixel, outColor);
	}
	break;
	case D3DFMT_A32B32G32R32F:
	{
		const A32B32G32R32F* const pixels = (const A32B32G32R32F* const)surfaceBytesRaw;
		const A32B32G32R32F& pixel = pixels[y * InternalWidth + x];
		ColorA32B32G32R32FToFloat4<writeMask>(pixel, outColor);
	}
		break;
	case D3DFMT_R16F:
	{
		const D3DXFLOAT16* const pixels = (const D3DXFLOAT16* const)surfaceBytesRaw;
		const D3DXFLOAT16& pixel = pixels[y * InternalWidth + x];
		ColorR16FToFloat4<writeMask>(pixel, outColor);
	}
		break;
	case D3DFMT_L8:
	{
		const unsigned char* const pixels = (const unsigned char* const)surfaceBytesRaw;
		const unsigned char pixel = pixels[y * InternalWidth + x];
		L8ToFloat4<writeMask>(pixel, outColor);
		if (sRGBSurface)
			GammaCorrectSample<writeMask & 0x7>(outColor);
	}
	break;
	case D3DFMT_DXT1:
	case D3DFMT_DXT2:
	case D3DFMT_DXT3:
	case D3DFMT_DXT4:
	case D3DFMT_DXT5:
	{
		const D3DCOLOR* const rawPixels = (const D3DCOLOR* const)auxSurfaceBytesRaw;
		const D3DCOLOR ldrColor = rawPixels[y * InternalWidth + x];
		ColorDWORDToFloat4<writeMask>(ldrColor, outColor);
		if (sRGBSurface)
			GammaCorrectSample<writeMask & 0x7>(outColor);
	}
		break;

	}
}

template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x1, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x2, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x3, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x4, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x5, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x6, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x7, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x8, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0x9, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xA, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xB, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xC, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xD, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xE, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0x3>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0x5>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0x6>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0x7>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0x9>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0xA>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0xB>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0xC>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0xD>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0xE>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::GetPixelVec4<0xF, false, 0xF>(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;

template <const unsigned char writeMask, const bool sRGBSurface, const unsigned char pixelWriteMask/* = 0xF*/>
void IDirect3DSurface9Hook::GetPixelVec4(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const
{
	if (pixelWriteMask == 0x0)
	{
#ifdef _DEBUG
		__debugbreak(); // Don't call this function if you don't intend to actually get any pixels!
#endif
		return;
	}

	const __m128i pixelIndex = _mm_add_epi32(_mm_mullo_epi32(y4, InternalWidthSplatted), x4);
	switch (InternalFormat)
	{
	default:
#ifdef _DEBUG
		__debugbreak(); // TODO: Add support for more surface types!
#else
		__assume(0);
#endif
	case D3DFMT_X8R8G8B8:
	{
		const D3DCOLOR* const pixels = (const D3DCOLOR* const)surfaceBytesRaw;

		const __m128i ldrColor4 = _mm_i32gather_epi32( (const int* const)pixels, pixelIndex, 4);

		ColorDWORDToFloat4_4<(writeMask == 0xF) ? 0xF : (writeMask & 0x7)>(ldrColor4, outColor4);

		// Set the W components to 1.0f:
		if (pixelWriteMask & 0x1) *(__m128* const)&outColor4[0] = _mm_blend_ps(*(__m128* const)&outColor4[0], oneVecF, 1 << 3);
		if (pixelWriteMask & 0x2) *(__m128* const)&outColor4[1] = _mm_blend_ps(*(__m128* const)&outColor4[1], oneVecF, 1 << 3);
		if (pixelWriteMask & 0x4) *(__m128* const)&outColor4[2] = _mm_blend_ps(*(__m128* const)&outColor4[2], oneVecF, 1 << 3);
		if (pixelWriteMask & 0x8) *(__m128* const)&outColor4[3] = _mm_blend_ps(*(__m128* const)&outColor4[3], oneVecF, 1 << 3);

		if (sRGBSurface)
			GammaCorrectSample4<writeMask & 0x7, pixelWriteMask>(outColor4);
	}
		break;
	case D3DFMT_A8R8G8B8:
	{
		const D3DCOLOR* const pixels = (const D3DCOLOR* const)surfaceBytesRaw;
		const __m128i ldrColor4 = _mm_i32gather_epi32( (const int* const)pixels, pixelIndex, 4);
		ColorDWORDToFloat4_4<writeMask>(ldrColor4, outColor4);
		if (sRGBSurface)
			GammaCorrectSample4<writeMask & 0x7, pixelWriteMask>(outColor4);
	}
		break;
	case D3DFMT_A4R4G4B4:
	{
		const A4R4G4B4* const pixels = (const A4R4G4B4* const)surfaceBytesRaw;

		// Do our reads:
		DWORD initialRow, nextRow;
		if (pixelWriteMask & (0x1 | 0x2) )
			initialRow = *(const DWORD* const)(pixels + pixelIndex.m128i_i32[0]);
		if (pixelWriteMask & (0x4 | 0x8) )
			nextRow = *(const DWORD* const)(pixels + pixelIndex.m128i_i32[2]);

		__m128i ldrColor4;

		// Convert as needed:
		if (pixelWriteMask & 0x1)
		{
			A4R4G4B4 ldrColor;
			ldrColor.word = (const unsigned short)(initialRow & 0xFFFF);
			ldrColor4.m128i_u32[0] = Expand4444To8888(ldrColor);
		}
		if (pixelWriteMask & 0x2)
		{
			A4R4G4B4 ldrColor;
			ldrColor.word = (const unsigned short)( (initialRow >> 16) & 0xFFFF);
			ldrColor4.m128i_u32[1] = Expand4444To8888(ldrColor);
		}
		if (pixelWriteMask & 0x4)
		{
			A4R4G4B4 ldrColor;
			ldrColor.word = (const unsigned short)(nextRow & 0xFFFF);
			ldrColor4.m128i_u32[2] = Expand4444To8888(ldrColor);
		}
		if (pixelWriteMask & 0x8)
		{
			A4R4G4B4 ldrColor;
			ldrColor.word = (const unsigned short)( (nextRow >> 16) & 0xFFFF);
			ldrColor4.m128i_u32[3] = Expand4444To8888(ldrColor);
		}

		ColorDWORDToFloat4_4<writeMask>(ldrColor4, outColor4);

		if (sRGBSurface)
			GammaCorrectSample4<writeMask & 0x7, pixelWriteMask>(outColor4);
	}
		break;
	case D3DFMT_X4R4G4B4:
	{
		const X4R4G4B4* const pixels = (const X4R4G4B4* const)surfaceBytesRaw;

		// Do our reads:
		DWORD initialRow, nextRow;
		if (pixelWriteMask & (0x1 | 0x2) )
			initialRow = *(const DWORD* const)(pixels + pixelIndex.m128i_i32[0]);
		if (pixelWriteMask & (0x4 | 0x8) )
			nextRow = *(const DWORD* const)(pixels + pixelIndex.m128i_i32[2]);

		__m128i ldrColor4;

		// Convert as needed:
		if (pixelWriteMask & 0x1)
		{
			X4R4G4B4 ldrColor;
			ldrColor.word = (const unsigned short)(initialRow & 0xFFFF);
			ldrColor4.m128i_u32[0] = Expand4440To8888(ldrColor);
		}
		if (pixelWriteMask & 0x2)
		{
			X4R4G4B4 ldrColor;
			ldrColor.word = (const unsigned short)( (initialRow >> 16) & 0xFFFF);
			ldrColor4.m128i_u32[1] = Expand4440To8888(ldrColor);
		}
		if (pixelWriteMask & 0x4)
		{
			X4R4G4B4 ldrColor;
			ldrColor.word = (const unsigned short)(nextRow & 0xFFFF);
			ldrColor4.m128i_u32[2] = Expand4440To8888(ldrColor);
		}
		if (pixelWriteMask & 0x8)
		{
			X4R4G4B4 ldrColor;
			ldrColor.word = (const unsigned short)( (nextRow >> 16) & 0xFFFF);
			ldrColor4.m128i_u32[3] = Expand4440To8888(ldrColor);
		}

		ColorDWORDToFloat4_4<writeMask>(ldrColor4, outColor4);

		// Set the W components to 1.0f:
		if (pixelWriteMask & 0x1) *(__m128* const)&outColor4[0] = _mm_blend_ps(*(__m128* const)&outColor4[0], oneVecF, 1 << 3);
		if (pixelWriteMask & 0x2) *(__m128* const)&outColor4[1] = _mm_blend_ps(*(__m128* const)&outColor4[1], oneVecF, 1 << 3);
		if (pixelWriteMask & 0x4) *(__m128* const)&outColor4[2] = _mm_blend_ps(*(__m128* const)&outColor4[2], oneVecF, 1 << 3);
		if (pixelWriteMask & 0x8) *(__m128* const)&outColor4[3] = _mm_blend_ps(*(__m128* const)&outColor4[3], oneVecF, 1 << 3);

		if (sRGBSurface)
			GammaCorrectSample4<writeMask & 0x7, pixelWriteMask>(outColor4);
	}
		break;
	case D3DFMT_R5G6B5:
	{
		const RGB565* const pixels = (const RGB565* const)surfaceBytesRaw;

		// Do our reads:
		DWORD initialRow, nextRow;
		if (pixelWriteMask & (0x1 | 0x2) )
			initialRow = *(const DWORD* const)(pixels + pixelIndex.m128i_i32[0]);
		if (pixelWriteMask & (0x4 | 0x8) )
			nextRow = *(const DWORD* const)(pixels + pixelIndex.m128i_i32[2]);

		__m128i ldrColor4;

		// Convert as needed:
		if (pixelWriteMask & 0x1)
		{
			RGB565 ldrColor;
			ldrColor.word = (const unsigned short)(initialRow & 0xFFFF);
			ldrColor4.m128i_u32[0] = Expand565To888(ldrColor);
		}
		if (pixelWriteMask & 0x2)
		{
			RGB565 ldrColor;
			ldrColor.word = (const unsigned short)( (initialRow >> 16) & 0xFFFF);
			ldrColor4.m128i_u32[1] = Expand565To888(ldrColor);
		}
		if (pixelWriteMask & 0x4)
		{
			RGB565 ldrColor;
			ldrColor.word = (const unsigned short)(nextRow & 0xFFFF);
			ldrColor4.m128i_u32[2] = Expand565To888(ldrColor);
		}
		if (pixelWriteMask & 0x8)
		{
			RGB565 ldrColor;
			ldrColor.word = (const unsigned short)( (nextRow >> 16) & 0xFFFF);
			ldrColor4.m128i_u32[3] = Expand565To888(ldrColor);
		}

		ColorDWORDToFloat4_4<(writeMask == 0xF) ? 0xF : (writeMask & 0x7)>(ldrColor4, outColor4);

		// Set the W components to 1.0f:
		if (pixelWriteMask & 0x1) *(__m128* const)&outColor4[0] = _mm_blend_ps(*(__m128* const)&outColor4[0], oneVecF, 1 << 3);
		if (pixelWriteMask & 0x2) *(__m128* const)&outColor4[1] = _mm_blend_ps(*(__m128* const)&outColor4[1], oneVecF, 1 << 3);
		if (pixelWriteMask & 0x4) *(__m128* const)&outColor4[2] = _mm_blend_ps(*(__m128* const)&outColor4[2], oneVecF, 1 << 3);
		if (pixelWriteMask & 0x8) *(__m128* const)&outColor4[3] = _mm_blend_ps(*(__m128* const)&outColor4[3], oneVecF, 1 << 3);

		if (sRGBSurface)
			GammaCorrectSample4<writeMask & 0x7, pixelWriteMask>(outColor4);
	}
		break;
	case D3DFMT_A16B16G16R16:
	{
		const A16B16G16R16* const pixels = (const A16B16G16R16* const)surfaceBytesRaw;
		const A16B16G16R16 pixel4[4] = 
		{
			pixels[pixelIndex.m128i_u32[0] ],
			pixels[pixelIndex.m128i_u32[1] ],
			pixels[pixelIndex.m128i_u32[2] ],
			pixels[pixelIndex.m128i_u32[3] ]
		};

		ColorA16B16G16R16ToFloat4_4<writeMask>(pixel4, outColor4);
		if (sRGBSurface)
			GammaCorrectSample4<writeMask & 0x7, pixelWriteMask>(outColor4);
	}
		break;
	case D3DFMT_A16B16G16R16F:
	{
		const A16B16G16R16F* const pixels = (const A16B16G16R16F* const)surfaceBytesRaw;
		const A16B16G16R16F* const pixel4[4] = 
		{
			&pixels[pixelIndex.m128i_u32[0] ],
			&pixels[pixelIndex.m128i_u32[1] ],
			&pixels[pixelIndex.m128i_u32[2] ],
			&pixels[pixelIndex.m128i_u32[3] ]
		};

		ColorA16B16G16R16FToFloat4_4<writeMask>(pixel4, outColor4);
	}
	break;
	case D3DFMT_A32B32G32R32F:
	{
		const A32B32G32R32F* const pixels = (const A32B32G32R32F* const)surfaceBytesRaw;
		const A32B32G32R32F* const pixel4[4] = 
		{
			&pixels[pixelIndex.m128i_u32[0]  ],
			&pixels[pixelIndex.m128i_u32[1]  ],
			&pixels[pixelIndex.m128i_u32[2]  ],
			&pixels[pixelIndex.m128i_u32[3]  ]
		};

		ColorA32B32G32R32FToFloat4_4<writeMask>(pixel4, outColor4);
	}
		break;
	case D3DFMT_R16F:
	{
		const D3DXFLOAT16* const pixels = (const D3DXFLOAT16* const)surfaceBytesRaw;
		const D3DXFLOAT16 pixel4[4] = 
		{
			pixels[pixelIndex.m128i_u32[0] ],
			pixels[pixelIndex.m128i_u32[1] ],
			pixels[pixelIndex.m128i_u32[2] ],
			pixels[pixelIndex.m128i_u32[3] ]
		};

		ColorR16FToFloat4_4<writeMask>(pixel4, outColor4);
	}
		break;
	case D3DFMT_L8:
	{
		const unsigned char* const pixels = (const unsigned char* const)surfaceBytesRaw;
		__m128i pixelsSSE;
		if (pixelWriteMask & 0x1) pixelsSSE.m128i_u8[0] = pixels[pixelIndex.m128i_u32[0] ];
		if (pixelWriteMask & 0x2) pixelsSSE.m128i_u8[1] = pixels[pixelIndex.m128i_u32[1] ];
		if (pixelWriteMask & 0x4) pixelsSSE.m128i_u8[2] = pixels[pixelIndex.m128i_u32[2] ];
		if (pixelWriteMask & 0x8) pixelsSSE.m128i_u8[3] = pixels[pixelIndex.m128i_u32[3] ];

		L8ToFloat4_4<writeMask>(pixelsSSE, outColor4);
		if (sRGBSurface)
			GammaCorrectSample4<writeMask & 0x7, pixelWriteMask>(outColor4);
	}
	break;
	case D3DFMT_DXT1:
	case D3DFMT_DXT2:
	case D3DFMT_DXT3:
	case D3DFMT_DXT4:
	case D3DFMT_DXT5:
	{
		const D3DCOLOR* const rawPixels = (const D3DCOLOR* const)auxSurfaceBytesRaw;
		const __m128i ldrColor4 = _mm_i32gather_epi32( (const int* const)rawPixels, pixelIndex, 4);
		ColorDWORDToFloat4_4<writeMask>(ldrColor4, outColor4);
		if (sRGBSurface)
			GammaCorrectSample4<writeMask & 0x7, pixelWriteMask>(outColor4);
	}
		break;

	}
}

const float IDirect3DSurface9Hook::GetDepth(const unsigned x, const unsigned y) const
{
	switch (InternalFormat)
	{
	case D3DFMT_D15S1:
	{
		const unsigned short* const pixels = (const unsigned short* const)surfaceBytesRaw;
		const unsigned short formatPixel = pixels[y * InternalWidth + x];
		return formatPixel / 32767.0f;
	}
		break;
	case D3DFMT_D16:
	case D3DFMT_D16_LOCKABLE:
	{
		const unsigned short* const pixels = (const unsigned short* const)surfaceBytesRaw;
		const unsigned short formatPixel = pixels[y * InternalWidth + x];
		return formatPixel / 65535.0f;
	}
		break;
	case D3DFMT_D24FS8:
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24X8:
	{
		const unsigned* const pixels = (const unsigned* const)surfaceBytesRaw;
		const unsigned formatPixel = pixels[y * InternalWidth + x];
		return formatPixel / 16777215.0f;
	}
		break;
	case D3DFMT_D32:
	case D3DFMT_D32_LOCKABLE:
	case MAKEFOURCC('I', 'N', 'T', 'Z'):
	{
		const unsigned* const pixels = (const unsigned* const)surfaceBytesRaw;
		const unsigned formatPixel = pixels[y * InternalWidth + x];
		return formatPixel / 4294967295.0f;
	}
		break;
	case D3DFMT_D32F_LOCKABLE:
	{
		const float* const pixels = (const float* const)surfaceBytesRaw;
		return pixels[y * InternalWidth + x];
	}
		break;
	default:
#ifdef _DEBUG
		__debugbreak(); // Error: Can't call GetDepth() on non-depth formats!
#else
		__assume(0);
#endif
		break;
	}
	return 0.0f;
}

const __m128 IDirect3DSurface9Hook::GetDepth4(const __m128i x4, const __m128i y4) const
{
	const __m128i pixelIndex4 = _mm_add_epi32(_mm_mullo_epi32(y4, InternalWidthSplatted), x4);

	switch (InternalFormat)
	{
	case D3DFMT_D15S1:
	{
		const unsigned short* const pixels = (const unsigned short* const)surfaceBytesRaw;

		__m128i rawDepth4;
		rawDepth4.m128i_u32[0] = pixels[pixelIndex4.m128i_u32[0] ];
		rawDepth4.m128i_u32[1] = pixels[pixelIndex4.m128i_u32[1] ];
		rawDepth4.m128i_u32[2] = pixels[pixelIndex4.m128i_u32[2] ];
		rawDepth4.m128i_u32[3] = pixels[pixelIndex4.m128i_u32[3] ];

		const __m128 rawFloatDepth4 = _mm_cvtepi32_ps(rawDepth4);
		return _mm_mul_ps(rawFloatDepth4, d15divisor);
	}
	case D3DFMT_D16:
	case D3DFMT_D16_LOCKABLE:
	{
		const unsigned short* const pixels = (const unsigned short* const)surfaceBytesRaw;

		__m128i rawDepth4;
		rawDepth4.m128i_u32[0] = pixels[pixelIndex4.m128i_u32[0] ];
		rawDepth4.m128i_u32[1] = pixels[pixelIndex4.m128i_u32[1] ];
		rawDepth4.m128i_u32[2] = pixels[pixelIndex4.m128i_u32[2] ];
		rawDepth4.m128i_u32[3] = pixels[pixelIndex4.m128i_u32[3] ];

		const __m128 rawFloatDepth4 = _mm_cvtepi32_ps(rawDepth4);
		return _mm_mul_ps(rawFloatDepth4, d16divisor);
	}
	case D3DFMT_D24FS8:
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24X8:
	{
		const int* const pixels = (const int* const)surfaceBytesRaw;
		const __m128i rawDepth4 = _mm_i32gather_epi32(pixels, pixelIndex4, 4);

		const __m128 rawFloatDepth4 = _mm_cvtepi32_ps(rawDepth4);
		return _mm_mul_ps(rawFloatDepth4, d24divisor);
	}
	case D3DFMT_D32:
	case D3DFMT_D32_LOCKABLE:
	case MAKEFOURCC('I', 'N', 'T', 'Z'):
	{
		const int* const pixels = (const int* const)surfaceBytesRaw;
		const __m128i rawDepth4 = _mm_i32gather_epi32(pixels, pixelIndex4, 4);

		const __m128 rawFloatDepth4 = _mm_cvtepi32_ps(rawDepth4);
		return _mm_mul_ps(rawFloatDepth4, d32divisor);
	}
	case D3DFMT_D32F_LOCKABLE:
	{
		const float* const pixels = (const float* const)surfaceBytesRaw;
		const __m128 rawFloatDepth4 = _mm_i32gather_ps(pixels, pixelIndex4, 4);
		return rawFloatDepth4;
	}
	default:
#ifdef _DEBUG
		__debugbreak(); // Error: Can't call GetDepth() on non-depth formats!
#else
		__assume(0);
#endif
		break;
	}
	return zeroVecF;
}

const unsigned IDirect3DSurface9Hook::GetRawDepthValueFromFloatDepth(const float floatDepth) const
{
	switch (InternalFormat)
	{
	case D3DFMT_D15S1:
		return (const unsigned)(floatDepth * 32767.0f);
	case D3DFMT_D16:
	case D3DFMT_D16_LOCKABLE:
		return (const unsigned)(floatDepth * 65535.0f);
	case D3DFMT_D24FS8:
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24X8:
		return (const unsigned)(floatDepth * 16777215.0f);
	case D3DFMT_D32:
	case D3DFMT_D32_LOCKABLE:
	case MAKEFOURCC('I', 'N', 'T', 'Z'):
		return (const unsigned)(floatDepth * 4294967295.0f);
	case D3DFMT_D32F_LOCKABLE:
		return *(const unsigned* const)&floatDepth;
	default:
#ifdef _DEBUG
		__debugbreak(); // Error: Can't call GetDepth() on non-depth formats!
#else
		__assume(0);
#endif
		return 0u;
	}
}

const unsigned IDirect3DSurface9Hook::GetRawDepth(const unsigned x, const unsigned y) const
{
	switch (InternalFormat)
	{
	case D3DFMT_D15S1:
	{
		const unsigned short* const pixels = (const unsigned short* const)surfaceBytesRaw;
		const unsigned short formatPixel = pixels[y * InternalWidth + x];
		return formatPixel;
	}
		break;
	case D3DFMT_D16:
	case D3DFMT_D16_LOCKABLE:
	{
		const unsigned short* const pixels = (const unsigned short* const)surfaceBytesRaw;
		const unsigned short formatPixel = pixels[y * InternalWidth + x];
		return formatPixel;
	}
		break;
	case D3DFMT_D24FS8:
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24X8:
	{
		const unsigned* const pixels = (const unsigned* const)surfaceBytesRaw;
		const unsigned formatPixel = pixels[y * InternalWidth + x];
		return formatPixel;
	}
		break;
	case D3DFMT_D32:
	case D3DFMT_D32_LOCKABLE:
	case MAKEFOURCC('I', 'N', 'T', 'Z'):
	{
		const unsigned* const pixels = (const unsigned* const)surfaceBytesRaw;
		const unsigned formatPixel = pixels[y * InternalWidth + x];
		return formatPixel;
	}
		break;
	case D3DFMT_D32F_LOCKABLE:
	{
		const float* const pixels = (const float* const)surfaceBytesRaw;
		const unsigned* const rawPixels = (const unsigned* const)pixels;
		return rawPixels[y * InternalWidth + x];
	}
		break;
	default:
#ifdef _DEBUG
		__debugbreak(); // Error: Can't call GetDepth() on non-depth formats!
#else
		__assume(0);
#endif
		break;
	}
	return 0x00000000;
}

const __m128i IDirect3DSurface9Hook::GetRawDepth4(const __m128i x4, const __m128i y4) const
{
	const __m128i pixelIndex4 = _mm_add_epi32(_mm_mullo_epi32(y4, InternalWidthSplatted), x4);

	switch (InternalFormat)
	{
	case D3DFMT_D15S1:
	case D3DFMT_D16:
	case D3DFMT_D16_LOCKABLE:
	{
		const unsigned short* const pixels = (const unsigned short* const)surfaceBytesRaw;

		__m128i rawDepth4;
		rawDepth4.m128i_u32[0] = pixels[pixelIndex4.m128i_u32[0] ];
		rawDepth4.m128i_u32[1] = pixels[pixelIndex4.m128i_u32[1] ];
		rawDepth4.m128i_u32[2] = pixels[pixelIndex4.m128i_u32[2] ];
		rawDepth4.m128i_u32[3] = pixels[pixelIndex4.m128i_u32[3] ];
		return rawDepth4;
	}
	case D3DFMT_D24FS8:
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24X8:
	case D3DFMT_D32:
	case D3DFMT_D32_LOCKABLE:
	case D3DFMT_D32F_LOCKABLE:
	case MAKEFOURCC('I', 'N', 'T', 'Z'):
	{
		const int* const pixels = (const int* const)surfaceBytesRaw;
		const __m128i rawDepth4 = _mm_i32gather_epi32(pixels, pixelIndex4, 4);
		return rawDepth4;
	}
	default:
#ifdef _DEBUG
		__debugbreak(); // Error: Can't call GetDepth() on non-depth formats!
#else
		__assume(0);
#endif
		break;
	}
	return zeroMaskVecI;
}

void IDirect3DSurface9Hook::SetDepth(const unsigned x, const unsigned y, const float depth)
{
#ifdef _DEBUG
	if (x >= InternalWidth)
	{
		__debugbreak(); // Out of bounds depth write
	}
	if (y >= InternalHeight)
	{
		__debugbreak(); // Out of bounds depth write
	}
#endif
	switch (InternalFormat)
	{
	case D3DFMT_D15S1:
	{
		unsigned short* const pixels = (unsigned short* const)surfaceBytesRaw;
		const unsigned short formatDepth = (const unsigned short)(0x7FFF * depth);
		pixels[y * InternalWidth + x] = formatDepth;
	}
		break;
	case D3DFMT_D16:
	case D3DFMT_D16_LOCKABLE:
	{
		unsigned short* const pixels = (unsigned short* const)surfaceBytesRaw;
		const unsigned short formatDepth = (const unsigned short)(0xFFFF * depth);
		pixels[y * InternalWidth + x] = formatDepth;
	}
		break;
	case D3DFMT_D24FS8:
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24X8:
	{
		unsigned* const pixels = (unsigned* const)surfaceBytesRaw;
		const unsigned formatDepth = (const unsigned)(0x00FFFFFF * depth);
		unsigned& outPixel = pixels[y * InternalWidth + x];
		outPixel = formatDepth;
	}
		break;
	case D3DFMT_D32:
	case D3DFMT_D32_LOCKABLE:
	case MAKEFOURCC('I', 'N', 'T', 'Z'):
	{
		unsigned* const pixels = (unsigned* const)surfaceBytesRaw;
		const unsigned uDepth = (const unsigned)(depth * 0xFFFFFFFF);
		unsigned& outPixel = pixels[y * InternalWidth + x];
		outPixel = uDepth;
	}
		break;
	case D3DFMT_D32F_LOCKABLE:
	{
		float* const pixels = (float* const)surfaceBytesRaw;
		float& outPixel = pixels[y * InternalWidth + x];
		outPixel = depth;
	}
		break;
	default:
#ifdef _DEBUG
		__debugbreak(); // Error: Can't call SetDepth() on non-depth formats!
#else
		__assume(0);
#endif
		break;
	}
}

const __m128 depthScale15 = { 32767.0f, 32767.0f, 32767.0f, 32767.0f };
const __m128 depthScale16 = { 65535.0f, 65535.0f, 65535.0f, 65535.0f };
const __m128 depthScale24 = { 16777215.0f, 16777215.0f, 16777215.0f, 16777215.0f };
const __m128 depthScale32 = { 4294967295.0f, 4294967295.0f, 4294967295.0f, 4294967295.0f };

template void IDirect3DSurface9Hook::SetDepth4<0x3>(const __m128i x4, const __m128i y4, const __m128 depth4);
template void IDirect3DSurface9Hook::SetDepth4<0x5>(const __m128i x4, const __m128i y4, const __m128 depth4);
template void IDirect3DSurface9Hook::SetDepth4<0x6>(const __m128i x4, const __m128i y4, const __m128 depth4);
template void IDirect3DSurface9Hook::SetDepth4<0x7>(const __m128i x4, const __m128i y4, const __m128 depth4);
template void IDirect3DSurface9Hook::SetDepth4<0x9>(const __m128i x4, const __m128i y4, const __m128 depth4);
template void IDirect3DSurface9Hook::SetDepth4<0xA>(const __m128i x4, const __m128i y4, const __m128 depth4);
template void IDirect3DSurface9Hook::SetDepth4<0xB>(const __m128i x4, const __m128i y4, const __m128 depth4);
template void IDirect3DSurface9Hook::SetDepth4<0xC>(const __m128i x4, const __m128i y4, const __m128 depth4);
template void IDirect3DSurface9Hook::SetDepth4<0xD>(const __m128i x4, const __m128i y4, const __m128 depth4);
template void IDirect3DSurface9Hook::SetDepth4<0xE>(const __m128i x4, const __m128i y4, const __m128 depth4);
template void IDirect3DSurface9Hook::SetDepth4<0xF>(const __m128i x4, const __m128i y4, const __m128 depth4);

template <const unsigned char pixelWriteMask>
void IDirect3DSurface9Hook::SetDepth4(const __m128i x4, const __m128i y4, const __m128 depth4)
{
	switch (pixelWriteMask)
	{
	case 0x0:
	case 0x1:
	case 0x2:
	case 0x4:
	case 0x8:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	}

	__m128i pixelIndex4;
	unsigned pixelIndex1; // Only used in the 0x3 and 0xC cases

	// Note: This code will need to be updated when depth buffers, stencil buffers, and render targets are quad-swizzled
	switch (pixelWriteMask)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case 0x3: // top row two, one write
		pixelIndex1 = x4.m128i_u32[0] + y4.m128i_u32[0] * InternalWidth;
		break;
	case 0xC: // bottom row two, one write
		pixelIndex1 = x4.m128i_u32[0] + y4.m128i_u32[2] * InternalWidth;
		break;
	case 0x5: // two writes
	case 0x6: // two writes
	case 0x9: // two writes
	case 0xA: // two writes
	case 0x7: // top row two, one bottom, two writes
	case 0xB: // top row two, one bottom, two writes
	case 0xD: // top row one, bottom row two, two writes
	case 0xE: // top row one, bottom row two, two writes
	case 0xF: // top row two, bottom row two, two writes
		pixelIndex4 = _mm_add_epi32(_mm_mullo_epi32(y4, InternalWidthSplatted), x4);
		break;
	}

	// Sadly we don't have scatter instructions in AVX2, so one or two consecutive writes is the best we can do if our write-mask isn't 0xF
	switch (InternalFormat)
	{
	case D3DFMT_D15S1:
	{
		unsigned short* const pixels = (unsigned short* const)surfaceBytesRaw;

		const __m128 scaledDepth4 = _mm_mul_ps(depthScale15, depth4);
		const __m128i uDepth4 = _mm_cvtps_epi32(scaledDepth4);
		__m128i shuffledUDepth16_4;
		switch (pixelWriteMask)
		{
		default:
#ifdef _DEBUG
			__debugbreak();
#else
			__assume(0);
#endif
		case 0x5: // two writes
		case 0x6: // two writes
		case 0x9: // two writes
		case 0xA: // two writes
			break;
		case 0x3: // top row two, one write
		case 0x7: // top row two, one bottom, two writes
		case 0xB: // top row two, one bottom, two writes
		case 0xC: // bottom row two, one write
		case 0xD: // top row one, bottom row two, two writes
		case 0xE: // top row one, bottom row two, two writes
		case 0xF: // top row two, bottom row two, two writes
			shuffledUDepth16_4 = _mm_shufflelo_epi16(uDepth4, _MM_SHUFFLE(3, 2, 1, 0) ); // Shuffle (8 16-bit words) from: { X, 0, Y, 0, Z, 0, W, 0 } to { X, Y, Z, W, Z, 0, W, 0 }
			break;
		}

		if (pixelWriteMask == 0x3)
		{
			*(unsigned* const)(pixels + pixelIndex1) = shuffledUDepth16_4.m128i_u32[0];
		}
		else if ( (pixelWriteMask & 0x3) == 0x3)
		{
			*(unsigned* const)(pixels + pixelIndex4.m128i_u32[0]) = shuffledUDepth16_4.m128i_u32[0];
		}
		else
		{
			if (pixelWriteMask & 0x1) pixels[pixelIndex4.m128i_u32[0] ] = uDepth4.m128i_u32[0];
			if (pixelWriteMask & 0x2) pixels[pixelIndex4.m128i_u32[1] ] = uDepth4.m128i_u32[1];
		}

		if (pixelWriteMask == 0xC)
		{
			*(unsigned* const)(pixels + pixelIndex1) = shuffledUDepth16_4.m128i_u32[1];
		}
		else if ( (pixelWriteMask & 0xC) == 0xC)
		{
			*(unsigned* const)(pixels + pixelIndex4.m128i_u32[2]) = shuffledUDepth16_4.m128i_u32[1];
		}
		else
		{
			if (pixelWriteMask & 0x4) pixels[pixelIndex4.m128i_u32[2] ] = uDepth4.m128i_u32[2];
			if (pixelWriteMask & 0x8) pixels[pixelIndex4.m128i_u32[3] ] = uDepth4.m128i_u32[3];
		}
	}
		break;
	case D3DFMT_D16:
	case D3DFMT_D16_LOCKABLE:
	{
		unsigned short* const pixels = (unsigned short* const)surfaceBytesRaw;

		const __m128 scaledDepth4 = _mm_mul_ps(depthScale16, depth4);
		const __m128i uDepth4 = _mm_cvtps_epi32(scaledDepth4);

		__m128i shuffledUDepth16_4;
		switch (pixelWriteMask)
		{
		default:
#ifdef _DEBUG
			__debugbreak();
#else
			__assume(0);
#endif
		case 0x5: // two writes
		case 0x6: // two writes
		case 0x9: // two writes
		case 0xA: // two writes
			break;
		case 0x3: // top row two, one write
		case 0x7: // top row two, one bottom, two writes
		case 0xB: // top row two, one bottom, two writes
		case 0xC: // bottom row two, one write
		case 0xD: // top row one, bottom row two, two writes
		case 0xE: // top row one, bottom row two, two writes
		case 0xF: // top row two, bottom row two, two writes
			shuffledUDepth16_4 = _mm_shufflelo_epi16(uDepth4, _MM_SHUFFLE(3, 2, 1, 0) ); // Shuffle (8 16-bit words) from: { X, 0, Y, 0, Z, 0, W, 0 } to { X, Y, Z, W, Z, 0, W, 0 }
			break;
		}

		if (pixelWriteMask == 0x3)
		{
			*(unsigned* const)(pixels + pixelIndex1) = shuffledUDepth16_4.m128i_u32[0];
		}
		else if ( (pixelWriteMask & 0x3) == 0x3)
		{
			*(unsigned* const)(pixels + pixelIndex4.m128i_u32[0]) = shuffledUDepth16_4.m128i_u32[0];
		}
		else
		{
			if (pixelWriteMask & 0x1) pixels[pixelIndex4.m128i_u32[0] ] = uDepth4.m128i_u32[0];
			if (pixelWriteMask & 0x2) pixels[pixelIndex4.m128i_u32[1] ] = uDepth4.m128i_u32[1];
		}

		if (pixelWriteMask == 0xC)
		{
			*(unsigned* const)(pixels + pixelIndex1) = shuffledUDepth16_4.m128i_u32[1];
		}
		else if ( (pixelWriteMask & 0xC) == 0xC)
		{
			*(unsigned* const)(pixels + pixelIndex4.m128i_u32[2]) = shuffledUDepth16_4.m128i_u32[1];
		}
		else
		{
			if (pixelWriteMask & 0x4) pixels[pixelIndex4.m128i_u32[2] ] = uDepth4.m128i_u32[2];
			if (pixelWriteMask & 0x8) pixels[pixelIndex4.m128i_u32[3] ] = uDepth4.m128i_u32[3];
		}
	}
		break;
	case D3DFMT_D24FS8:
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24X8:
	{
		unsigned* const pixels = (unsigned* const)surfaceBytesRaw;

		const __m128 scaledDepth4 = _mm_mul_ps(depthScale24, depth4);
		const __m128i uDepth4 = _mm_cvtps_epi32(scaledDepth4);

		if (pixelWriteMask == 0x3)
		{
			_mm_storel_epi64( (__m128i* const)(pixels + pixelIndex1), uDepth4);
		}
		else if ( (pixelWriteMask & 0x3) == 0x3)
		{
			_mm_storel_epi64( (__m128i* const)(pixels + pixelIndex4.m128i_u32[0]), uDepth4);
		}
		else
		{
			if (pixelWriteMask & 0x1) pixels[pixelIndex4.m128i_u32[0] ] = uDepth4.m128i_u32[0];
			if (pixelWriteMask & 0x2) pixels[pixelIndex4.m128i_u32[1] ] = uDepth4.m128i_u32[1];
		}

		if (pixelWriteMask == 0xC)
		{
			_mm_storeh_pi( (__m64* const)(pixels + pixelIndex1), _mm_castsi128_ps(uDepth4) );
		}
		else if ( (pixelWriteMask & 0xC) == 0xC)
		{
			_mm_storeh_pi( (__m64* const)(pixels + pixelIndex4.m128i_u32[2]), _mm_castsi128_ps(uDepth4) );
		}
		else
		{
			if (pixelWriteMask & 0x4) pixels[pixelIndex4.m128i_u32[2] ] = uDepth4.m128i_u32[2];
			if (pixelWriteMask & 0x8) pixels[pixelIndex4.m128i_u32[3] ] = uDepth4.m128i_u32[3];
		}
	}
		break;
	case D3DFMT_D32:
	case D3DFMT_D32_LOCKABLE:
	case MAKEFOURCC('I', 'N', 'T', 'Z'):
	{
		unsigned* const pixels = (unsigned* const)surfaceBytesRaw;

		const __m128 scaledDepth4 = _mm_mul_ps(depthScale32, depth4);
		const __m128i uDepth4 = _mm_cvtps_epi32(scaledDepth4);

		if (pixelWriteMask == 0x3)
		{
			_mm_storel_epi64( (__m128i* const)(pixels + pixelIndex1), uDepth4);
		}
		else if ( (pixelWriteMask & 0x3) == 0x3)
		{
			_mm_storel_epi64( (__m128i* const)(pixels + pixelIndex4.m128i_u32[0]), uDepth4);
		}
		else
		{
			if (pixelWriteMask & 0x1) pixels[pixelIndex4.m128i_u32[0] ] = uDepth4.m128i_u32[0];
			if (pixelWriteMask & 0x2) pixels[pixelIndex4.m128i_u32[1] ] = uDepth4.m128i_u32[1];
		}

		if (pixelWriteMask == 0xC)
		{
			_mm_storeh_pi( (__m64* const)(pixels + pixelIndex1), _mm_castsi128_ps(uDepth4) );
		}
		else if ( (pixelWriteMask & 0xC) == 0xC)
		{
			_mm_storeh_pi( (__m64* const)(pixels + pixelIndex4.m128i_u32[2]), _mm_castsi128_ps(uDepth4) );
		}
		else
		{
			if (pixelWriteMask & 0x4) pixels[pixelIndex4.m128i_u32[2] ] = uDepth4.m128i_u32[2];
			if (pixelWriteMask & 0x8) pixels[pixelIndex4.m128i_u32[3] ] = uDepth4.m128i_u32[3];
		}
	}
		break;
	case D3DFMT_D32F_LOCKABLE:
	{
		float* const pixels = (float* const)surfaceBytesRaw;

		if (pixelWriteMask == 0x3)
		{
			_mm_storel_pi( (__m64* const)(pixels + pixelIndex1), depth4);
		}
		else if ( (pixelWriteMask & 0x3) == 0x3)
		{
			_mm_storel_pi( (__m64* const)(pixels + pixelIndex4.m128i_u32[0]), depth4);
		}
		else
		{
			if (pixelWriteMask & 0x1) pixels[pixelIndex4.m128i_u32[0] ] = depth4.m128_f32[0];
			if (pixelWriteMask & 0x2) pixels[pixelIndex4.m128i_u32[1] ] = depth4.m128_f32[1];
		}

		if (pixelWriteMask == 0xC)
		{
			_mm_storeh_pi( (__m64* const)(pixels + pixelIndex1), depth4);
		}
		else if ( (pixelWriteMask & 0xC) == 0xC)
		{
			_mm_storeh_pi( (__m64* const)(pixels + pixelIndex4.m128i_u32[2]), depth4);
		}
		else
		{
			if (pixelWriteMask & 0x4) pixels[pixelIndex4.m128i_u32[2] ] = depth4.m128_f32[2];
			if (pixelWriteMask & 0x8) pixels[pixelIndex4.m128i_u32[3] ] = depth4.m128_f32[3];
		}
	}
		break;
	default:
#ifdef _DEBUG
		__debugbreak(); // Error: Can't call SetDepth4() on non-depth formats!
#else
		__assume(0);
#endif
		break;
	}
}

void IDirect3DSurface9Hook::SetStencil(const unsigned x, const unsigned y, const DWORD stencil)
{
#ifdef _DEBUG
	if (x >= InternalWidth)
	{
		__debugbreak(); // Out of bounds stencil write
	}
	if (y >= InternalHeight)
	{
		__debugbreak(); // Out of bounds stencil write
	}
#endif
	const DWORD stencilMask = GetStencilFormatMask(InternalFormat);
	const DWORD maskedStencil = stencil & stencilMask;
	const BYTE maskedStencilByte = (const BYTE)maskedStencil;

	BYTE* const stencilBuffer = auxSurfaceBytesRaw;
	stencilBuffer[y * InternalWidth + x] = maskedStencilByte;

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif
}

void IDirect3DSurface9Hook::SetStencil4(const __m128i x4, const __m128i y4, const DWORD stencil4)
{
	DWORD stencilMask4 = GetStencilFormatMask(InternalFormat);
	stencilMask4 |= (stencilMask4 << 8);
	stencilMask4 |= (stencilMask4 << 16);
	const DWORD maskedStencil = stencil4 & stencilMask4;

	const __m128i pixelIndex4 = _mm_add_epi32(_mm_mullo_epi32(y4, InternalWidthSplatted), x4);

	BYTE* const stencilBuffer = auxSurfaceBytesRaw;
	stencilBuffer[pixelIndex4.m128i_u32[0] ] = (const BYTE)maskedStencil;
	stencilBuffer[pixelIndex4.m128i_u32[1] ] = (const BYTE)(maskedStencil >> 8);
	stencilBuffer[pixelIndex4.m128i_u32[2] ] = (const BYTE)(maskedStencil >> 16);
	stencilBuffer[pixelIndex4.m128i_u32[3] ] = (const BYTE)(maskedStencil >> 24);

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif
}

const DWORD IDirect3DSurface9Hook::GetStencil(const unsigned x, const unsigned y) const
{
	const BYTE* const stencilBuffer = auxSurfaceBytesRaw;
	return stencilBuffer[y * InternalWidth + x];
}

const __m128i IDirect3DSurface9Hook::GetStencil4(const __m128i x4, const __m128i y4) const
{
	const BYTE* const stencilBuffer = auxSurfaceBytesRaw;

	const __m128i byteOffsets = _mm_add_epi32(_mm_mullo_epi32(InternalWidthSplatted, y4), x4);

	__m128i stencilLookups;
	stencilLookups.m128i_u32[0] = stencilBuffer[byteOffsets.m128i_u32[0] ];
	stencilLookups.m128i_u32[1] = stencilBuffer[byteOffsets.m128i_u32[1] ];
	stencilLookups.m128i_u32[2] = stencilBuffer[byteOffsets.m128i_u32[2] ];
	stencilLookups.m128i_u32[3] = stencilBuffer[byteOffsets.m128i_u32[3] ];

	return stencilLookups;
}

// Don't define the <0> version of this function. Anybody calling it is a dummy because it doesn't write anything anyway.
template void IDirect3DSurface9Hook::SetPixelVec<1>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<2>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<3>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<4>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<5>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<6>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<7>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<8>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<9>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<10>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<11>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<12>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<13>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<14>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);
template void IDirect3DSurface9Hook::SetPixelVec<15>(const unsigned x, const unsigned y, const D3DXVECTOR4& color);

template <const unsigned char channelWriteMask>
void IDirect3DSurface9Hook::SetPixelVec(const unsigned x, const unsigned y, const D3DXVECTOR4& color)
{
#ifdef _DEBUG
	if (x >= InternalWidth)
	{
		__debugbreak(); // Out of bounds pixel write
	}
	if (y >= InternalHeight)
	{
		__debugbreak(); // Out of bounds pixel write
	}
#endif

	switch (InternalFormat)
	{
	default:
#ifdef _DEBUG
		__debugbreak(); // TODO: Add more surface formats
#else
		__assume(0);
#endif
	case D3DFMT_X8R8G8B8:
	{
		const D3DCOLOR ldrColor = Float4ToX8R8G8B8Clamp<channelWriteMask & 0x7>(color);
		SetPixel(x, y, ldrColor);
	}
		break;
	case D3DFMT_A8R8G8B8:
	{
		const D3DCOLOR ldrColor = Float4ToD3DCOLORClamp<channelWriteMask>(color);
		SetPixel(x, y, ldrColor);
	}
		break;
	case D3DFMT_A16B16G16R16:
	{
		A16B16G16R16* const pixels = (A16B16G16R16* const)surfaceBytesRaw;
		A16B16G16R16& writePixel = pixels[y * InternalWidth + x];
#ifdef WITH_SURFACE_HASHING
		RecomputePartialSurfaceHashXor(writePixel);
#endif
		Float4ToA16B16G16R16<channelWriteMask>(color, writePixel);
#ifdef WITH_SURFACE_HASHING
		RecomputePartialSurfaceHashXor(writePixel);
#endif
	}
		break;
	case D3DFMT_A16B16G16R16F:
	{
		A16B16G16R16F* const pixels = (A16B16G16R16F* const)surfaceBytesRaw;
		A16B16G16R16F& writePixel = pixels[y * InternalWidth + x];
#ifdef WITH_SURFACE_HASHING
		RecomputePartialSurfaceHashXor(writePixel);
#endif
		Float4ToA16B16G16R16F<channelWriteMask>(color, writePixel);
#ifdef WITH_SURFACE_HASHING
		RecomputePartialSurfaceHashXor(writePixel);
#endif
	}
		break;
	case D3DFMT_A32B32G32R32F:
	{
		A32B32G32R32F* const pixels = (A32B32G32R32F* const)surfaceBytesRaw;
		A32B32G32R32F& writePixel = pixels[y * InternalWidth + x];
#ifdef WITH_SURFACE_HASHING
		RecomputePartialSurfaceHashXor(writePixel);
#endif
		Float4ToA32B32G32R32F<channelWriteMask>(color, writePixel);
#ifdef WITH_SURFACE_HASHING
		RecomputePartialSurfaceHashXor(writePixel);
#endif
	}
		break;
	case D3DFMT_R16F:
	{
		D3DXFLOAT16* const pixels = (D3DXFLOAT16* const)surfaceBytesRaw;
		D3DXFLOAT16& writePixel = pixels[y * InternalWidth + x];
		Float4ToR16F<channelWriteMask>(color, writePixel);

		// Can't update the surface hash in this case...
	}
		break;
	case D3DFMT_L8:
	{
		unsigned char* const pixels = (unsigned char* const)surfaceBytesRaw;
		unsigned char& writePixel = pixels[y * InternalWidth + x];
		Float4ToL8Clamp<channelWriteMask>(color, writePixel);

		// Can't update the surface hash in this case...
	}
		break;
	}
}

// Don't define the <0> version of this function. Anybody calling it is a dummy because it doesn't write anything anyway.
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0x3>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0x5>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0x6>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0x7>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0x9>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0xA>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0xB>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0xC>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0xD>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0xE>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x1, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x2, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x3, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x4, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x5, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x6, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x7, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x8, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0x9, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xA, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xB, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xC, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xD, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xE, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);
template void IDirect3DSurface9Hook::SetPixelVec4<0xF, 0xF>(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);

template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
void IDirect3DSurface9Hook::SetPixelVec4(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4])
{
	if (channelWriteMask == 0)
	{
#ifdef _DEBUG
		__debugbreak(); // Don't call this with 0 write masks!
#endif
		return;
	}

	// See if we can drop down to non-quad operations if possible:
	switch (pixelWriteMask)
	{
	default:
	case 0x0:
#ifdef _DEBUG
		__debugbreak(); // Don't call this with 0 write masks!
#else
		__assume(0);
#endif
		return;
	case 0x1:
		SetPixelVec<channelWriteMask>(x4.m128i_u32[0], y4.m128i_u32[0], color[0]);
		return;
	case 0x2:
		SetPixelVec<channelWriteMask>(x4.m128i_u32[1], y4.m128i_u32[1], color[1]);
		return;
	case 0x4:
		SetPixelVec<channelWriteMask>(x4.m128i_u32[2], y4.m128i_u32[2], color[2]);
		return;
	case 0x8:
		SetPixelVec<channelWriteMask>(x4.m128i_u32[3], y4.m128i_u32[3], color[3]);
		return;
	case 0x3:
	case 0x5:
	case 0x6:
	case 0x7:
	case 0x9:
	case 0xA:
	case 0xB:
	case 0xC:
	case 0xD:
	case 0xE:
	case 0xF:
		break;
	}

	const __m128i pixelIndex = _mm_add_epi32(_mm_mullo_epi32(y4, InternalWidthSplatted), x4);
	switch (InternalFormat)
	{
	default:
#ifdef _DEBUG
		__debugbreak(); // TODO: Add more surface formats
#else
		__assume(0);
#endif
	case D3DFMT_X8R8G8B8:
	{
		D3DCOLOR* const pixels = (D3DCOLOR* const)surfaceBytesRaw;
#ifdef _M_X64
		if (pixelWriteMask & 0x1)
			*(pixels + pixelIndex.m128i_u32[0]) = Float4ToX8R8G8B8Clamp<channelWriteMask>(color[0]);
		if (pixelWriteMask & 0x2)
			*(pixels + pixelIndex.m128i_u32[1]) = Float4ToX8R8G8B8Clamp<channelWriteMask>(color[1]);
		if (pixelWriteMask & 0x4)
			*(pixels + pixelIndex.m128i_u32[2]) = Float4ToX8R8G8B8Clamp<channelWriteMask>(color[2]);
		if (pixelWriteMask & 0x8)
			*(pixels + pixelIndex.m128i_u32[3]) = Float4ToX8R8G8B8Clamp<channelWriteMask>(color[3]);
#else
		const __m128i pixelByteOffset4 = _mm_slli_epi32(pixelIndex, 2); // Left-shift by 2 is the same as multiply by sizeof(D3DCOLOR)
		const __m128i writeAddresses = _mm_add_epi32(_mm_set1_epi32( (const unsigned)pixels), pixelByteOffset4);
		Float4ToX8R8G8B8_4Clamp4<channelWriteMask, pixelWriteMask>(color, writeAddresses);
#endif
	}
		break;
	case D3DFMT_A8R8G8B8:
	{
		D3DCOLOR* const pixels = (D3DCOLOR* const)surfaceBytesRaw;
#ifdef _M_X64
		if (pixelWriteMask & 0x1)
			*(pixels + pixelIndex.m128i_u32[0]) = Float4ToD3DCOLORClamp<channelWriteMask>(color[0]);
		if (pixelWriteMask & 0x2)
			*(pixels + pixelIndex.m128i_u32[1]) = Float4ToD3DCOLORClamp<channelWriteMask>(color[1]);
		if (pixelWriteMask & 0x4)
			*(pixels + pixelIndex.m128i_u32[2]) = Float4ToD3DCOLORClamp<channelWriteMask>(color[2]);
		if (pixelWriteMask & 0x8)
			*(pixels + pixelIndex.m128i_u32[3]) = Float4ToD3DCOLORClamp<channelWriteMask>(color[3]);
#else
		const __m128i pixelByteOffset4 = _mm_slli_epi32(pixelIndex, 2); // Left-shift by 2 is the same as multiply by sizeof(D3DCOLOR)
		const __m128i writeAddresses = _mm_add_epi32(_mm_set1_epi32( (const unsigned)pixels), pixelByteOffset4);
		Float4ToD3DCOLOR4Clamp4<channelWriteMask, pixelWriteMask>(color, writeAddresses);
#endif
	}
		break;
	case D3DFMT_A16B16G16R16:
	{
		A16B16G16R16* const pixels = (A16B16G16R16* const)surfaceBytesRaw;
#ifdef _M_X64
		if (pixelWriteMask & 0x1)
			Float4ToA16B16G16R16<channelWriteMask>(color[0], *(pixels + pixelIndex.m128i_u32[0]));
		if (pixelWriteMask & 0x2)
			Float4ToA16B16G16R16<channelWriteMask>(color[1], *(pixels + pixelIndex.m128i_u32[1]));
		if (pixelWriteMask & 0x4)
			Float4ToA16B16G16R16<channelWriteMask>(color[2], *(pixels + pixelIndex.m128i_u32[2]));
		if (pixelWriteMask & 0x8)
			Float4ToA16B16G16R16<channelWriteMask>(color[3], *(pixels + pixelIndex.m128i_u32[3]));
#else
		const __m128i pixelByteOffset4 = _mm_slli_epi32(pixelIndex, 3); // Left-shift by 3 is the same as multiply by sizeof(A16B16G16R16)
		const __m128i writeAddresses = _mm_add_epi32(_mm_set1_epi32( (const unsigned)pixels), pixelByteOffset4);
		Float4ToA16B16G16R16_4<channelWriteMask, pixelWriteMask>(color, writeAddresses);
#endif
	}
		break;
	case D3DFMT_A16B16G16R16F:
	{
		A16B16G16R16F* const pixels = (A16B16G16R16F* const)surfaceBytesRaw;
#ifdef _M_X64
		if (pixelWriteMask & 0x1)
			Float4ToA16B16G16R16F<channelWriteMask>(color[0], *(pixels + pixelIndex.m128i_u32[0]));
		if (pixelWriteMask & 0x2)
			Float4ToA16B16G16R16F<channelWriteMask>(color[1], *(pixels + pixelIndex.m128i_u32[1]));
		if (pixelWriteMask & 0x4)
			Float4ToA16B16G16R16F<channelWriteMask>(color[2], *(pixels + pixelIndex.m128i_u32[2]));
		if (pixelWriteMask & 0x8)
			Float4ToA16B16G16R16F<channelWriteMask>(color[3], *(pixels + pixelIndex.m128i_u32[3]));
#else
		const __m128i pixelByteOffset4 = _mm_slli_epi32(pixelIndex, 3); // Left-shift by 3 is the same as multiply by sizeof(A16B16G16R16F)
		const __m128i writeAddresses = _mm_add_epi32(_mm_set1_epi32( (const unsigned)pixels), pixelByteOffset4);
		Float4ToA16B16G16R16F4<channelWriteMask, pixelWriteMask>(color, writeAddresses);
#endif
	}
		break;
	case D3DFMT_A32B32G32R32F:
	{
		A32B32G32R32F* const pixels = (A32B32G32R32F* const)surfaceBytesRaw;
#ifdef _M_X64
		if (pixelWriteMask & 0x1)
			Float4ToA32B32G32R32F<channelWriteMask>(color[0], *(pixels + pixelIndex.m128i_u32[0]));
		if (pixelWriteMask & 0x2)
			Float4ToA32B32G32R32F<channelWriteMask>(color[1], *(pixels + pixelIndex.m128i_u32[1]));
		if (pixelWriteMask & 0x4)
			Float4ToA32B32G32R32F<channelWriteMask>(color[2], *(pixels + pixelIndex.m128i_u32[2]));
		if (pixelWriteMask & 0x8)
			Float4ToA32B32G32R32F<channelWriteMask>(color[3], *(pixels + pixelIndex.m128i_u32[3]));
#else
		const __m128i pixelByteOffset4 = _mm_slli_epi32(pixelIndex, 4); // Left-shift by 4 is the same as multiply by sizeof(A32B32G32R32F)
		const __m128i writeAddresses = _mm_add_epi32(_mm_set1_epi32( (const unsigned)pixels), pixelByteOffset4);
		Float4ToA32B32G32R32F4<channelWriteMask, pixelWriteMask>(color, writeAddresses);
#endif
	}
		break;
	case D3DFMT_R16F:
	{
		D3DXFLOAT16* const pixels = (D3DXFLOAT16* const)surfaceBytesRaw;
#ifdef _M_X64
		if (pixelWriteMask & 0x1)
			Float4ToR16F<channelWriteMask>(color[0], *(pixels + pixelIndex.m128i_u32[0]));
		if (pixelWriteMask & 0x2)
			Float4ToR16F<channelWriteMask>(color[1], *(pixels + pixelIndex.m128i_u32[1]));
		if (pixelWriteMask & 0x4)
			Float4ToR16F<channelWriteMask>(color[2], *(pixels + pixelIndex.m128i_u32[2]));
		if (pixelWriteMask & 0x8)
			Float4ToR16F<channelWriteMask>(color[3], *(pixels + pixelIndex.m128i_u32[3]));
#else
		const __m128i pixelByteOffset4 = _mm_slli_epi32(pixelIndex, 1); // Left-shift by 1 is the same as multiply by sizeof(D3DXFLOAT16)
		const __m128i writeAddresses = _mm_add_epi32(_mm_set1_epi32( (const unsigned)pixels), pixelByteOffset4);
		Float4ToR16F4<channelWriteMask, pixelWriteMask>(color, writeAddresses);
#endif

		// Can't update the surface hash in this case...
	}
		break;
	case D3DFMT_L8:
	{
		unsigned char* const pixels = (unsigned char* const)surfaceBytesRaw;
#ifdef _M_X64
		if (pixelWriteMask & 0x1)
			Float4ToL8Clamp<channelWriteMask>(color[0], *(pixels + pixelIndex.m128i_u32[0]));
		if (pixelWriteMask & 0x2)
			Float4ToL8Clamp<channelWriteMask>(color[1], *(pixels + pixelIndex.m128i_u32[1]));
		if (pixelWriteMask & 0x4)
			Float4ToL8Clamp<channelWriteMask>(color[2], *(pixels + pixelIndex.m128i_u32[2]));
		if (pixelWriteMask & 0x8)
			Float4ToL8Clamp<channelWriteMask>(color[3], *(pixels + pixelIndex.m128i_u32[3]));
#else
		const __m128i writeAddresses = _mm_add_epi32(_mm_set1_epi32( (const unsigned)pixels), pixelIndex);
		Float4ToL8Clamp4<channelWriteMask, pixelWriteMask>(color, writeAddresses);
#endif

		// Can't update the surface hash in this case...
	}
		break;
	}
}

void IDirect3DSurface9Hook::UpdateSurfaceInternal(const IDirect3DSurface9Hook* const sourceSurface, const RECT* const sourceRect, const POINT* const destPoint)
{
#ifdef _DEBUG
		if (InternalFormat != sourceSurface->InternalFormat)
		{
			__debugbreak();
		}
#endif

	// Copy entire surface:
	if (!sourceRect || !destPoint)
	{
		D3DCOLOR* const pixels = (D3DCOLOR* const)surfaceBytesRaw;

#ifdef _DEBUG
		if (surfaceBytesRawSize != sourceSurface->surfaceBytesRawSize)
		{
			__debugbreak();
		}
		if (InternalWidth != sourceSurface->InternalWidth)
		{
			__debugbreak();
		}
		if (InternalHeight != sourceSurface->InternalHeight)
		{
			__debugbreak();
		}
#endif

		const D3DCOLOR* const sourcePixels = (const D3DCOLOR* const)sourceSurface->GetSurfaceBytesRaw();
		memcpy(pixels, sourcePixels, sourceSurface->GetSurfaceBytesSize() );

		if (auxSurfaceBytesRaw != NULL)
		{
			const BYTE* const auxSourceBytes = (const BYTE* const)sourceSurface->auxSurfaceBytesRaw;
			memcpy(auxSurfaceBytesRaw, auxSourceBytes, auxSurfaceBytesRawSize);
		}
	}
	else
	{
		D3DCOLOR* pixels = (D3DCOLOR* const)surfaceBytesRaw + destPoint->y * InternalWidth + destPoint->x;
		const D3DCOLOR* const sourcePixels = (const D3DCOLOR* const)sourceSurface->GetSurfaceBytesRaw();
		const unsigned rowWidth = sourceRect->right - sourceRect->left;
		for (int y = sourceRect->top; y < sourceRect->bottom; ++y)
		{
			const D3DCOLOR* const rowPixels = sourcePixels + y * sourceSurface->InternalWidth;
			for (int x = sourceRect->left; x < sourceRect->right; ++x)
			{
				const D3DCOLOR sourceColor = *(rowPixels + x);
				*pixels++ = sourceColor;
			}
			pixels -= rowWidth;
			pixels += InternalWidth;
		}

		if (auxSurfaceBytesRaw != NULL)
		{
			// TODO: Handle this case!
			__debugbreak();
		}
	}

#ifdef WITH_SURFACE_HASHING
	RecomputeSurfaceHash();
#endif
}

template <const unsigned char writeMask, const bool sRGBSurface>
void IDirect3DSurface9Hook::SampleSurfaceInternal(const float x, const float y, const D3DTEXTUREFILTERTYPE texf, D3DXVECTOR4& outColor) const
{
	// Keep the simple case simple
	if (is1x1surface)
	{
		GetPixelVec<writeMask, sRGBSurface>(0, 0, outColor);
		return;
	}

#ifdef _DEBUG
	if (x > 1.0f || x < 0.0f)
		__debugbreak();
	if (y > 1.0f || y < 0.0f)
		__debugbreak();
#endif
	float u = x * InternalWidth;
	float v = y * InternalHeight;

	const unsigned WidthM1 = InternalWidthM1;
	const unsigned HeightM1 = InternalHeightM1;

	const float maxU = InternalWidthM1F;
	const float maxV = InternalHeightM1F;

	if (u > maxU)
		u = maxU;
	if (v > maxV)
		v = maxV;

	switch (texf)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case D3DTEXF_ANISOTROPIC    : // It is legal for anisotropic filtering to fall back to using linear filtering if the device doesn't support anisotropic
	case D3DTEXF_PYRAMIDALQUAD  :
	case D3DTEXF_GAUSSIANQUAD   :
	case D3DTEXF_CONVOLUTIONMONO:
	case D3DTEXF_LINEAR         :
	{
		const int cuTopleft = (const int)u;
		const int cvTopleft = (const int)v;
		unsigned cuTopright = cuTopleft + 1;
		if (cuTopright > WidthM1)
			cuTopright = WidthM1;
		const unsigned cvTopright = cvTopleft;
		const unsigned cuBotleft = cuTopleft;
		unsigned cvBotleft = cvTopleft + 1;
		if (cvBotleft > HeightM1)
			cvBotleft = HeightM1;
		const unsigned cuBotright = cuTopright;
		const unsigned cvBotright = cvBotleft;

		__declspec(align(16) ) const __m128i x4 = _mm_set_epi32(cuBotright, cuBotleft, cuTopright, cuTopleft);
		__declspec(align(16) ) const __m128i y4 = _mm_set_epi32(cvBotright, cvBotleft, cvTopright, cvTopleft);

		__declspec(align(16) ) D3DXVECTOR4 bilinearSamples[4];
		GetPixelVec4<writeMask, sRGBSurface, 0xF>(x4, y4, bilinearSamples);

		D3DXVECTOR4 topHorizLerp, botHorizLerp;
		const float xLerp = u - cuTopleft;
		lrp<writeMask>(topHorizLerp, bilinearSamples[0], bilinearSamples[1], xLerp);
		lrp<writeMask>(botHorizLerp, bilinearSamples[2], bilinearSamples[3], xLerp);
		const float yLerp = v - cvTopleft;
		lrp<writeMask>(outColor, topHorizLerp, botHorizLerp, yLerp);

#ifdef _DEBUG
		if (xLerp > 1.0f || xLerp < 0.0f)
			__debugbreak();
		if (yLerp > 1.0f || yLerp < 0.0f)
			__debugbreak();
#endif
	}
		break;
	case D3DTEXF_NONE           :
	case D3DTEXF_POINT          :
		GetPixelVec<writeMask, sRGBSurface>( (const int)u, (const int)v, outColor);
		break;
	}
}

template <const unsigned char writeMask, const bool sRGBSurface, const unsigned pixelWriteMask>
void IDirect3DSurface9Hook::SampleSurfaceInternal4(const float (&x4)[4], const float (&y4)[4], const D3DTEXTUREFILTERTYPE texf, D3DXVECTOR4 (&outColor4)[4]) const
{
	// Keep the simple case simple
	if (is1x1surface)
	{
		D3DXVECTOR4 broadcastPixel;
		GetPixelVec<writeMask, sRGBSurface>(0, 0, broadcastPixel);

		if (pixelWriteMask & 0x1) outColor4[0] = broadcastPixel;
		if (pixelWriteMask & 0x2) outColor4[1] = broadcastPixel;
		if (pixelWriteMask & 0x4) outColor4[2] = broadcastPixel;
		if (pixelWriteMask & 0x8) outColor4[3] = broadcastPixel;
		return;
	}

	const __m128 x4vec = *(const __m128* const)x4;
	const __m128 y4vec = *(const __m128* const)y4;

	__m128 u4 = _mm_mul_ps(x4vec, InternalWidthSplattedF);
	__m128 v4 = _mm_mul_ps(y4vec, InternalHeightSplattedF);

	// if (u4 > InternalWidthM1F) u4 = InternalWidthM1F
	u4 = _mm_min_ps(u4, InternalWidthM1SplattedF);

	// if (v4 > InternalHeightM1F) u4 = InternalHeightM1F
	v4 = _mm_min_ps(v4, InternalHeightM1SplattedF);

	const __m128i u4i = _mm_cvtps_epi32(u4);
	const __m128i v4i = _mm_cvtps_epi32(v4);

	switch (texf)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case D3DTEXF_ANISOTROPIC    : // It is legal for anisotropic filtering to fall back to using linear filtering if the device doesn't support anisotropic
	case D3DTEXF_PYRAMIDALQUAD  :
	case D3DTEXF_GAUSSIANQUAD   :
	case D3DTEXF_CONVOLUTIONMONO:
	case D3DTEXF_LINEAR         :
	{
		// D3DXVECTOR4 topleft, topright, botleft, botright;
		__declspec(align(16) ) D3DXVECTOR4 topleft4[4];

		GetPixelVec4<writeMask, sRGBSurface, pixelWriteMask>(u4i, v4i, topleft4);

		const __m128i u4iRight = _mm_min_epi32(_mm_add_epi32(u4i, oneInt4), InternalWidthM1Splatted);

		__declspec(align(16) ) D3DXVECTOR4 topright4[4];
		GetPixelVec4<writeMask, sRGBSurface, pixelWriteMask>(u4iRight, v4i, topright4);

		const __m128i v4iBottom = _mm_min_epi32(_mm_add_epi32(v4i, oneInt4), InternalHeightM1Splatted);

		__declspec(align(16) ) D3DXVECTOR4 botleft4[4];
		GetPixelVec4<writeMask, sRGBSurface, pixelWriteMask>(u4i, v4iBottom, botleft4);

		__declspec(align(16) ) D3DXVECTOR4 botright4[4];
		GetPixelVec4<writeMask, sRGBSurface, pixelWriteMask>(u4iRight, v4iBottom, botright4);

		const __m128 xLerp4 = _mm_sub_ps(u4, _mm_cvtepi32_ps(u4i) );

		D3DXVECTOR4 topHorizLerp4[4];
		lrp4<writeMask, pixelWriteMask>(topHorizLerp4, xLerp4, topleft4, topright4);

		D3DXVECTOR4 botHorizLerp4[4];
		lrp4<writeMask, pixelWriteMask>(botHorizLerp4, xLerp4, botleft4, botright4);

		const __m128 yLerp4 = _mm_sub_ps(v4, _mm_cvtepi32_ps(v4i) );
		lrp4<writeMask, pixelWriteMask>(outColor4, yLerp4, topHorizLerp4, botHorizLerp4);
	}
		break;
	case D3DTEXF_NONE           :
	case D3DTEXF_POINT          :
	{
		GetPixelVec4<writeMask, sRGBSurface, pixelWriteMask>(u4i, v4i, outColor4);
	}
		break;
	}
}

template void IDirect3DSurface9Hook::SampleSurface<0>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<1>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<2>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<3>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<4>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<5>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<6>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<7>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<8>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<9>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<10>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<11>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<12>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<13>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<14>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DSurface9Hook::SampleSurface<15>(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;

template <const unsigned char writeMask>
void IDirect3DSurface9Hook::SampleSurface(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const
{
	// TODO: Appropriately use magfilter and minfilter here, instead of always using the magfilter
	if (samplerState.stateUnion.namedStates.sRGBTexture)
		SampleSurfaceInternal<writeMask, true>(x, y, samplerState.stateUnion.namedStates.magFilter, outColor);
	else
		SampleSurfaceInternal<writeMask, false>(x, y, samplerState.stateUnion.namedStates.magFilter, outColor);
}

template void IDirect3DSurface9Hook::SampleSurface4<0>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<1>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<2>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<3>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<4>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<5>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<6>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<7>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<8>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<9>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<10>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<11>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<12>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<13>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<14>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DSurface9Hook::SampleSurface4<15>(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template <const unsigned char writeMask>
void IDirect3DSurface9Hook::SampleSurface4(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const
{
	// TODO: Appropriately use magfilter and minfilter here, instead of always using the magfilter
	if (samplerState.stateUnion.namedStates.sRGBTexture)
		SampleSurfaceInternal4<writeMask, true, 0xF>(x4, y4, samplerState.stateUnion.namedStates.magFilter, outColor4);
	else
		SampleSurfaceInternal4<writeMask, false, 0xF>(x4, y4, samplerState.stateUnion.namedStates.magFilter, outColor4);
}

#define DUMP_SURF_DIR "TexDump"

void IDirect3DSurface9Hook::InitDumpSurfaces(void)
{
	CreateDirectoryA(DUMP_SURF_DIR, NULL);
}

void IDirect3DSurface9Hook::DumpSurfaceToDisk(void) const
{
	//if (InternalFormat == D3DFMT_X8R8G8B8 || InternalFormat == D3DFMT_A8R8G8B8)
	{
		char surfaceFilename[MAX_PATH] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
#ifdef WITH_SURFACE_HASHING
		if (hash.format >= 0 && hash.format <= D3DFMT_BINARYBUFFER)
			sprintf(surfaceFilename, DUMP_SURF_DIR "\\Surf0x%08X_len0x%X_fmt%u_hash0x%08X.dds", (const unsigned)this, hash.sizeBytes, hash.format, hash.hashVal);
		else
			sprintf(surfaceFilename, DUMP_SURF_DIR "\\Surf0x%08X_len0x%X_fmt%c%c%c%c_hash0x%08X.dds", (const unsigned)this, hash.sizeBytes, 
				( (const char* const)&hash.format)[0], ( (const char* const)&hash.format)[1], ( (const char* const)&hash.format)[2], ( (const char* const)&hash.format)[3],
				hash.hashVal);
#else
		sprintf(surfaceFilename, DUMP_SURF_DIR "\\Surf0x%08X.dds", (const unsigned)this);
#endif
#pragma warning(pop)
		D3DXSaveSurfaceToFileA(surfaceFilename, D3DXIFF_DDS, (LPDIRECT3DSURFACE9)this, NULL, NULL);
	}
}

#ifdef WITH_SURFACE_HASHING
void IDirect3DSurface9Hook::RecomputeSurfaceHash(void)
{
	hash.format = InternalFormat;
	hash.sizeBytes = surfaceBytes.size()
#ifdef SURFACE_MAGIC_COOKIE
		- sizeof(DWORD) // Don't count the magic sentinel value DWORD as part of the hash (this enables hash-parity with Release builds)
#endif
		;

	unsigned long hashTemp = 0x00000000;
	const unsigned long* const ulSurfaceBytesRaw = (const unsigned long* const)surfaceBytesRaw;
	for (unsigned x = 0; x < hash.sizeBytes / sizeof(unsigned long); ++x)
		hashTemp ^= ulSurfaceBytesRaw[x];

	hash.hashVal = hashTemp;
}

void IDirect3DSurface9Hook::RecomputePartialSurfaceHash(const DWORD oldValue, const DWORD newValue)
{
	// This can more cleanly be thought of as xor'ing the oldValue against the hashVal and then xor'ing the newValue against the hashVal.
	// Doing it all in one step is just faster:
	hash.hashVal ^= (oldValue ^ newValue);
}
#endif

```

`Software_d3d9/IDirect3DSurface9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

#include "IDirect3DResource9Hook.h"

#if defined(DUMP_TEXTURES_ON_FIRST_SET) || defined(COMPUTE_SURFACE_HASHES_FOR_DEBUGGING) // No need to compute surface hashes if we're never going to need them
	#define WITH_SURFACE_HASHING 1
#endif

static inline const DWORD GetStencilFormatMask(const D3DFORMAT format)
{
	switch (format)
	{
	case D3DFMT_D24X4S4:
		return 0x0F;
	case D3DFMT_D15S1:
		return 0x01;
	case D3DFMT_D24S8:
	case D3DFMT_D24FS8:
	case D3DFMT_S8_LOCKABLE:
		return 0xFF;
	default:
#ifdef _DEBUG
		__debugbreak(); // Should never be here
#else
		__assume(0);
#endif
		return 0x00;
	}
}

static inline const bool HasStencil(const D3DFORMAT format)
{
	switch (format)
	{
	case D3DFMT_D24S8:
	case D3DFMT_D24X4S4:
	case D3DFMT_D24FS8:
	case D3DFMT_D15S1:
	case D3DFMT_S8_LOCKABLE:
		return true;
	default:
		return false;
	}
}

#ifdef WITH_SURFACE_HASHING
struct surfaceHash
{
	surfaceHash() : sizeBytes(0), format(D3DFMT_UNKNOWN), hashVal(0)
	{
	}

	unsigned sizeBytes;
	D3DFORMAT format;
	unsigned long hashVal;
};
#endif

#ifdef SURFACE_MAGIC_COOKIE
static const DWORD surfaceMagicBytes = 0x13579BDF;
static inline void ValidateSurfaceMagicCookie(const std::vector<BYTE>& bytes)
{
	const DWORD* const magicDword = (const DWORD* const)(&bytes.front() ) + (bytes.size() / sizeof(DWORD) - 1);
	if (*magicDword != surfaceMagicBytes)
	{
		__debugbreak();
	}
}
#endif

__declspec(align(16) ) class IDirect3DSurface9Hook : public IDirect3DSurface9
{
public:
	IDirect3DSurface9Hook(LPDIRECT3DSURFACE9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1),
		InternalWidth(0), InternalHeight(0), TextureSurfaceLevel(0), InternalFormat(D3DFMT_UNKNOWN), InternalPool(D3DPOOL_DEFAULT), InternalUsage(UsageNone), DiscardRT(FALSE), LockableRT(FALSE), HookParentTexturePtr(NULL),
		creationMethod(unknown), surfaceBytesRaw(NULL), auxSurfaceBytesRaw(NULL), surfaceBytesRawSize(0), auxSurfaceBytesRawSize(0), InternalMultiSampleType(D3DMULTISAMPLE_NONE), InternalMultiSampleQuality(0),
		is1x1surface(false), InternalWidthM1(0), InternalHeightM1(0), InternalWidthM1F(0.0f), InternalHeightM1F(0.0f)
	{
#ifdef _DEBUG
		if (realObject)
			memcpy(&Name, &realObject->Name, (char*)&realObject - (char*)&Name);
		else
			memset(&Name, 0, (char*)&realObject - (char*)&Name);
#endif
	}

	virtual ~IDirect3DSurface9Hook()
	{
#ifdef SURFACE_ALLOC_PAGE_NOACCESS
		if (surfaceBytesRaw)
		{
			VirtualFree( (void*)( (size_t)surfaceBytesRaw & 4095), 0, MEM_RELEASE);
			surfaceBytesRaw = NULL;
		}
		if (auxSurfaceBytesRaw)
		{
			VirtualFree( (void*)( (size_t)auxSurfaceBytesRaw & 4095), 0, MEM_RELEASE);
			auxSurfaceBytesRaw = NULL;
		}
#else // #ifdef SURFACE_ALLOC_PAGE_NOACCESS
		if (surfaceBytesRaw)
		{
			free(surfaceBytesRaw);
			surfaceBytesRaw = NULL;
		}
		if (auxSurfaceBytesRaw)
		{
			free(auxSurfaceBytesRaw);
			auxSurfaceBytesRaw = NULL;
		}
#endif // #ifdef SURFACE_ALLOC_PAGE_NOACCESS

#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	void* operator new(size_t siz)
	{
		return _mm_malloc(siz, 16);
	}

	void operator delete(void* ptr)
	{
		_mm_free(ptr);
	}

	// Creation functions:
	void CreateOffscreenPlainSurface(UINT _Width, UINT _Height, D3DFORMAT _Format, D3DPOOL _Pool);
	void CreateDepthStencilSurface(UINT _Width, UINT _Height, D3DFORMAT _Format, D3DMULTISAMPLE_TYPE _MultiSample, DWORD _MultisampleQuality, BOOL _Discard);
	void CreateRenderTarget(UINT _Width, UINT _Height, D3DFORMAT _Format, D3DMULTISAMPLE_TYPE _MultiSample, DWORD _MultisampleQuality, BOOL _Lockable);
	void CreateTextureImplicitSurface(UINT _Width, UINT _Height, D3DFORMAT _Format, D3DPOOL _Pool, const DebuggableUsage _Usage, UINT _Level, IDirect3DTexture9Hook* _HookParentTexturePtr);
	void CreateDeviceImplicitSurface(const D3DPRESENT_PARAMETERS& d3dpp);
	void CreateDeviceImplicitDepthStencil(const D3DPRESENT_PARAMETERS& d3dpp);

	void UpdateCachedValuesOnCreate();

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DResource9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreePrivateData(THIS_ REFGUID refguid) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetPriority(THIS_ DWORD PriorityNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetPriority(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE PreLoad(THIS) override;
    virtual COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE GetType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetContainer(THIS_ REFIID riid,void** ppContainer) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDesc(THIS_ D3DSURFACE_DESC *pDesc) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LockRect(THIS_ D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UnlockRect(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDC(THIS_ HDC *phdc) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReleaseDC(THIS_ HDC hdc) override;

#ifdef _DEBUG
	void ValidateRealObjectDesc() const;
#endif

	static const unsigned GetSurfaceSizeBytes(const unsigned Width, const unsigned Height, const D3DFORMAT Format);
	static const unsigned GetSurfacePitchBytes(const unsigned Width, const D3DFORMAT Format);

	const BYTE* const GetSurfaceBytesRaw(void) const
	{
		return surfaceBytesRaw;
	}
	
	const unsigned GetSurfaceBytesSize(void) const
	{
		return surfaceBytesRawSize;
	}

	inline LPDIRECT3DSURFACE9 GetUnderlyingSurface(void) const
	{
		return realObject;
	}

	// Internal use only:
	// Fills a rect on this surface with a color (.rgba). A NULL rectangle means to fill the entire surface.
	void InternalColor4Fill(const D3DXVECTOR4& color, const D3DRECT* const pRect = NULL);

	// Fills a rect on this surface with a color (.rgba). A NULL rectangle means to fill the entire surface.
	void InternalColorFill(const D3DCOLOR color, const D3DRECT* const pRect = NULL);

	// Fills a rect on this surface with a depth value. A NULL rectangle means to fill the entire surface.
	void InternalDepthFill(const float depth, const D3DRECT* const pRect = NULL);

	// Fills a rect on this surface with a stencil value. A NULL rectangle means to fill the entire surface.
	void InternalStencilFill(const DWORD stencil, const D3DRECT* const pRect = NULL);

	void SetPixel(const unsigned x, const unsigned y, const D3DCOLOR color);

	template <const unsigned char writeMask>
	void SetPixelVec(const unsigned x, const unsigned y, const D3DXVECTOR4& color);

	template <const unsigned char channelWriteMask, const unsigned char pixelWriteMask>
	void SetPixelVec4(const __m128i x4, const __m128i y4, const D3DXVECTOR4 (&color)[4]);

	const D3DCOLOR GetPixel(const unsigned x, const unsigned y) const;
	const A4R4G4B4 GetPixel4444(const unsigned x, const unsigned y) const;
	const X4R4G4B4 GetPixel4440(const unsigned x, const unsigned y) const;
	const RGB565 GetPixel565(const unsigned x, const unsigned y) const;

	template <const unsigned char writeMask, const bool sRGBSurface>
	void GetPixelVec(const unsigned x, const unsigned y, D3DXVECTOR4& outColor) const;

	template <const unsigned char writeMask, const bool sRGBSurface, const unsigned char pixelWriteMask = 0xF>
	void GetPixelVec4(const __m128i x4, const __m128i y4, D3DXVECTOR4 (&outColor4)[4]) const;

	// Depth functions:
	void SetDepth(const unsigned x, const unsigned y, const float depth);

	template <const unsigned char pixelWriteMask>
	void SetDepth4(const __m128i x4, const __m128i y4, const __m128 depth4);

	const float GetDepth(const unsigned x, const unsigned y) const;
	const __m128 GetDepth4(const __m128i x4, const __m128i y4) const;

	const unsigned GetRawDepthValueFromFloatDepth(const float floatDepth) const;

	const unsigned GetRawDepth(const unsigned x, const unsigned y) const;
	const __m128i GetRawDepth4(const __m128i x4, const __m128i y4) const;

	// Stencil functions:
	void SetStencil(const unsigned x, const unsigned y, const DWORD stencil);
	void SetStencil4(const __m128i x4, const __m128i y4, const DWORD stencil4);
	const DWORD GetStencil(const unsigned x, const unsigned y) const;
	const __m128i GetStencil4(const __m128i x4, const __m128i y4) const;

	void UpdateSurfaceInternal(const IDirect3DSurface9Hook* const sourceSurface, const RECT* const sourceRect, const POINT* const destPoint);

	template <const unsigned char writeMask>
	void SampleSurface(const float x, const float y, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;

	template <const unsigned char writeMask>
	void SampleSurface4(const float (&x4)[4], const float (&y4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;

	void DecompressSurfaceDXT1();
	void DecompressSurfaceDXT3();
	void DecompressSurfaceDXT5();
	void DecompressSurfaceToAuxBuffer();

	void DumpSurfaceToDisk(void) const;
	static void InitDumpSurfaces(void);

	inline const D3DFORMAT GetInternalFormat(void) const
	{
		return InternalFormat;
	}

	inline const unsigned GetInternalWidth(void) const
	{
		return InternalWidth;
	}

	inline const unsigned GetInternalHeight(void) const
	{
		return InternalHeight;
	}

	inline const BOOL GetInternalDiscard(void) const
	{
		return DiscardRT;
	}

	inline const BOOL GetInternalLockable(void) const
	{
		return LockableRT;
	}

	inline const bool IsTexelValid(const unsigned x, const unsigned y) const
	{
		return x < InternalWidth && y < InternalHeight;
	}

#ifdef WITH_SURFACE_HASHING
	inline const surfaceHash& GetSurfaceHash(void) const
	{
		return hash;
	}

	void RecomputeSurfaceHash(void);
	void RecomputePartialSurfaceHash(const DWORD oldValue, const DWORD newValue);

	template <typename T>
	inline void RecomputePartialSurfaceHashXor(const T& value)
	{
		static_assert(sizeof(T) % sizeof(unsigned long) == 0, "Error: Unexpected pixel struct size alignment!");
		static_assert(sizeof(T) / sizeof(unsigned long) > 0, "Error: Unexpected pixel struct size!");

		const unsigned long* const ptr = (const unsigned long* const)&value;

		for (unsigned x = 0; x < sizeof(T) / sizeof(unsigned long); ++x)
			hash.hashVal ^= ptr[x];
	}
#endif

	const __m128& GetInternalWidthHeightM2F(void) const
	{
		return InternalWidthHeightM2F;
	}

protected:
	template <const unsigned char writeMask, const bool sRGBSurface>
	void SampleSurfaceInternal(const float x, const float y, const D3DTEXTUREFILTERTYPE texf, D3DXVECTOR4& outColor) const;

	template <const unsigned char writeMask, const bool sRGBSurface, const unsigned pixelWriteMask>
	void SampleSurfaceInternal4(const float (&x4)[4], const float (&y4)[4], const D3DTEXTUREFILTERTYPE texf, D3DXVECTOR4 (&outColor4)[4]) const;

	LPDIRECT3DSURFACE9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

	UINT InternalWidth;
	UINT InternalHeight;
	UINT TextureSurfaceLevel;
	D3DFORMAT InternalFormat;
	D3DPOOL InternalPool;
	DebuggableUsage InternalUsage;
	D3DMULTISAMPLE_TYPE InternalMultiSampleType;
	DWORD InternalMultiSampleQuality;

	BOOL DiscardRT;
	BOOL LockableRT;
	IDirect3DTexture9Hook* HookParentTexturePtr;

#ifdef WITH_SURFACE_HASHING
	surfaceHash hash;
#endif

	enum surfaceCreationMethod
	{
		unknown = 0,
		createOffscreenPlain,
		createDepthStencil,
		createRenderTarget,
		createTexture,
		deviceImplicitBackbuffer,
		deviceImplicitDepthStencil
	} creationMethod;

	BYTE* surfaceBytesRaw;
	BYTE* auxSurfaceBytesRaw; // Aux surface data is nly present for compressed surface types and stencil buffers
	UINT surfaceBytesRawSize;
	UINT auxSurfaceBytesRawSize;

	__declspec(align(16) ) __m128i InternalWidthSplatted; // This is in the format of (uint32[4])(InternalWidth, InternalWidth, InternalWidth, InternalWidth)
	__declspec(align(16) ) __m128 InternalWidthSplattedF; // This is in the format of (float32[4])(InternalWidth, InternalWidth, InternalWidth, InternalWidth)
	__declspec(align(16) ) __m128 InternalHeightSplattedF; // This is in the format of (float32[4])(InternalHeight, InternalHeight, InternalHeight, InternalHeight)
	UINT InternalWidthM1;
	UINT InternalHeightM1;
	float InternalWidthM1F;
	float InternalHeightM1F;
	__declspec(align(16) ) __m128 InternalWidthM1SplattedF;
	__declspec(align(16) ) __m128 InternalHeightM1SplattedF;
	__declspec(align(16) ) __m128i InternalWidthM1Splatted;
	__declspec(align(16) ) __m128i InternalHeightM1Splatted;
	__declspec(align(16) ) __m128 InternalWidthHeightM1F; // This is in the format of (float32[4])(InternalWidthM1F, InternalHeightM1F, 0.0f, 0.0f)
	__declspec(align(16) ) __m128 InternalWidthHeightM2F; // This is in the format of (float32[4])(InternalWidthM2F, InternalHeightM2F, 0.0f, 0.0f)
	bool is1x1surface;
};

```

`Software_d3d9/IDirect3DSwapChain9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DSwapChain9Hook.h"
#include "IDirect3DSurface9Hook.h"
#include "Overlay\DebugOverlay.h"

// Comment out to disable
//#define DUMP_FRAMES_TO_FILE 1

// Comment out to disable
//#define FORCE_CLEAR_REAL_BACKBUFFER 1

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSwapChain9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DSwapChain9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DSwapChain9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Swap Chain %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DSwapChain9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSwapChain9Hook::Present(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion,DWORD dwFlags)
{
	SIMPLE_FUNC_SCOPE();

	// Only allow source rects the same size as the backbuffer:
	if (pSourceRect)
	{
		if (pSourceRect->left != 0)
		{
			__debugbreak();
		}
		if (pSourceRect->top != 0)
		{
			__debugbreak();
		}
		if (pSourceRect->right != InternalPresentParameters.BackBufferWidth)
		{
			__debugbreak();
		}
		if (pSourceRect->bottom != InternalPresentParameters.BackBufferHeight)
		{
			__debugbreak();
		}
	}

	// Only allow dest rects the same size as the backbuffer:
	if (pDestRect)
	{
		if (pDestRect->left != 0)
		{
			__debugbreak();
		}
		if (pDestRect->top != 0)
		{
			__debugbreak();
		}
		if (pDestRect->right != InternalPresentParameters.BackBufferWidth)
		{
			__debugbreak();
		}
		if (pDestRect->bottom != InternalPresentParameters.BackBufferHeight)
		{
			__debugbreak();
		}
	}

	if (pSourceRect && pDestRect)
	{
		// We don't currently support disjoint source/dest rects
		if (memcmp(pSourceRect, pDestRect, sizeof(RECT) ) != 0)
		{
			__debugbreak();
		}
	}

	if (pDirtyRegion)
	{
		// Dirty Regions are not yet supported by the virtual software renderer
		__debugbreak();
	}

	UpdateOverlay(parentDevice);

	// Blit from the software backbuffer to the hardware backbuffer:
	InternalBlit();

#ifdef DUMP_FRAMES_TO_FILE
	{
		char filenameBuffer[256] = {0};
		static unsigned frameNumber = 0;
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(filenameBuffer, "frame%u.bmp", frameNumber++ % 32);
#pragma warning(pop)
		D3DXSaveSurfaceToFileA(filenameBuffer, D3DXIFF_BMP, tempBlitSurface, NULL, NULL);
	}
#endif

	HRESULT ret;
	{
		SIMPLE_NAME_SCOPE("Real Device Present");
		ret = realObject->Present(pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion, dwFlags);
	}
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSwapChain9Hook::GetFrontBufferData(THIS_ IDirect3DSurface9* pDestSurface)
{
	const IDirect3DSurface9Hook* const hookPtr = dynamic_cast<IDirect3DSurface9Hook*>(pDestSurface);
	if (hookPtr)
		pDestSurface = hookPtr->GetUnderlyingSurface();
#ifdef _DEBUG
	else if (pDestSurface != NULL)
	{
		DbgBreakPrint("Error: GetFrontBufferData called with a non-hooked surface pointer");
	}
#endif
	HRESULT ret = realObject->GetFrontBufferData(hookPtr ? hookPtr->GetUnderlyingSurface() : NULL);
	if (SUCCEEDED(ret) )
	{
		// TODO: Implement this...
	}
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSwapChain9Hook::GetBackBuffer(THIS_ UINT iBackBuffer,D3DBACKBUFFER_TYPE Type,IDirect3DSurface9** ppBackBuffer)
{
	HRESULT ret = realObject->GetBackBuffer(iBackBuffer, Type, ppBackBuffer);
	if (FAILED(ret) )
		return ret;

	if (ppBackBuffer)
	{
		if (iBackBuffer == 0 && Type == D3DBACKBUFFER_TYPE_MONO)
		{
#ifdef _DEBUG
			if (*ppBackBuffer != backBuffer->GetUnderlyingSurface() )
			{
				__debugbreak();
			}
#endif
			*ppBackBuffer = backBuffer;
			backBuffer->AddRef();
		}
		else
		{
			if (iBackBuffer != 0)
			{
				// Multiple back-buffers per swap-chain not yet supported
				__debugbreak();
			}
			else if (Type != D3DBACKBUFFER_TYPE_MONO)
			{
				// Stereo back-buffers are not supported yet!
				__debugbreak();
			}
			else
			{
				// Not sure how we got here!
				__debugbreak();
			}
		}
	}
	else
	{
		__debugbreak();
	}

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSwapChain9Hook::GetRasterStatus(THIS_ D3DRASTER_STATUS* pRasterStatus)
{
	HRESULT ret = realObject->GetRasterStatus(pRasterStatus);
	// TODO: Implement this...
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSwapChain9Hook::GetDisplayMode(THIS_ D3DDISPLAYMODE* pMode)
{
	HRESULT ret = realObject->GetDisplayMode(pMode);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (pMode)
	{
		// TODO: Implement this...
		/*if (memcmp(pMode, &InternalDisplayMode, sizeof(D3DDISPLAYMODE) ) != 0)
		{
			__debugbreak();
		}*/
	}
#endif

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSwapChain9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DSwapChain9Hook::GetPresentParameters(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters)
{
	HRESULT ret = realObject->GetPresentParameters(pPresentationParameters);
	if (FAILED(ret) )
		return ret;

#ifdef _DEBUG
	if (pPresentationParameters)
	{
		if (memcmp(pPresentationParameters, &InternalPresentParameters, sizeof(D3DPRESENT_PARAMETERS) ) != 0)
		{
			__debugbreak();
		}
	}
#endif

	return ret;
}

void IDirect3DSwapChain9Hook::InitializeSwapChain(const D3DPRESENT_PARAMETERS& _PresentParameters, IDirect3DSurface9Hook* swapChainBackBuffer)
{
	InternalPresentParameters = _PresentParameters;

	D3DDISPLAYMODE localDisplayMode = {0};
	localDisplayMode.Width = InternalPresentParameters.BackBufferWidth;
	localDisplayMode.Height = InternalPresentParameters.BackBufferHeight;

	// TODO: Don't hardcode to 60Hz
	static const unsigned defaultRefreshRate = 60;
	localDisplayMode.RefreshRate = InternalPresentParameters.Windowed ? defaultRefreshRate : InternalPresentParameters.FullScreen_RefreshRateInHz;
	localDisplayMode.Format = InternalPresentParameters.BackBufferFormat;

	InternalDisplayMode = localDisplayMode;

#ifdef _DEBUG
	if (!swapChainBackBuffer)
	{
		// We have to have a back buffer!
		__debugbreak();
	}
#endif

	backBuffer = swapChainBackBuffer;

	// Initialize our blitting surface, which is how we'll be uploading the software-rasterized backbuffers to the GPU for display
	InitBlitSurface();
}

void IDirect3DSwapChain9Hook::SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP* pRamp)
{
	UNREFERENCED_PARAMETER(Flags);

	if (pRamp)
	{
		gammaRamp = *pRamp;
	}
#ifdef _DEBUG
	else
	{
		__debugbreak();
	}
#endif
}

void IDirect3DSwapChain9Hook::GetGammaRamp(D3DGAMMARAMP* pRamp)
{
	if (pRamp)
	{
		*pRamp = gammaRamp;
	}
#ifdef _DEBUG
	else
	{
		__debugbreak();
	}
#endif
}

void IDirect3DSwapChain9Hook::InitDefaultGammaRamp(void)
{
	for (WORD x = 0; x < 256; ++x)
	{
		gammaRamp.red[x] = gammaRamp.green[x] = gammaRamp.blue[x] = x;
	}
}

void IDirect3DSwapChain9Hook::InitBlitSurface(void)
{
	LPDIRECT3DDEVICE9 rawDevice = parentDevice->GetUnderlyingDevice();
	if (FAILED(rawDevice->CreateOffscreenPlainSurface(InternalDisplayMode.Width, InternalDisplayMode.Height, InternalDisplayMode.Format, D3DPOOL_SYSTEMMEM, &tempBlitSurface, NULL) ) || !tempBlitSurface)
	{
		// This should never happen unless we are all out of memory!
		__debugbreak();
	}
}

// Blit from the software backbuffer to the hardware backbuffer:
void IDirect3DSwapChain9Hook::InternalBlit(void)
{
	SIMPLE_FUNC_SCOPE();

	LPDIRECT3DDEVICE9 rawDevice = parentDevice->GetUnderlyingDevice();
	LPDIRECT3DSURFACE9 rawBackBuffer = NULL;
	rawDevice->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &rawBackBuffer);
	D3DLOCKED_RECT d3dlr = {0};
	const BYTE* const surfaceBytesRaw = backBuffer->GetSurfaceBytesRaw();
	tempBlitSurface->LockRect(&d3dlr, NULL, 0);
#ifdef _DEBUG
	if (d3dlr.Pitch != sizeof(D3DCOLOR) * InternalDisplayMode.Width)
	{
		// Unexpected surface pitch, memcpy can't handle unaligned pitches
		__debugbreak();
	}
#endif
	
	{
		SIMPLE_NAME_SCOPE("Blit Memcpy");
		memcpy(d3dlr.pBits, surfaceBytesRaw, backBuffer->GetInternalWidth() * backBuffer->GetInternalHeight() * sizeof(D3DCOLOR) );
	}

	tempBlitSurface->UnlockRect();

#ifdef FORCE_CLEAR_REAL_BACKBUFFER
	rawDevice->SetRenderTarget(0, rawBackBuffer);
	rawDevice->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_ARGB(0, 0, 0, 0), 1.0f, 0x00000000);
#endif

	rawDevice->UpdateSurface(tempBlitSurface, NULL, rawBackBuffer, NULL);
	rawBackBuffer->Release();
	rawBackBuffer = NULL;
}

```

`Software_d3d9/IDirect3DSwapChain9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

class IDirect3DSwapChain9Hook : public IDirect3DSwapChain9
{
public:
	IDirect3DSwapChain9Hook(LPDIRECT3DSWAPCHAIN9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1), backBuffer(NULL), tempBlitSurface(NULL)
	{
#ifdef _DEBUG
		memcpy(&PresentParameters, &realObject->PresentParameters, (char*)&realObject - (char*)&PresentParameters);
#endif

		// Init the gamma ramp to its default value:
		InitDefaultGammaRamp();
	}

	virtual ~IDirect3DSwapChain9Hook()
	{
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	void InitializeSwapChain(const D3DPRESENT_PARAMETERS& _PresentParameters, IDirect3DSurface9Hook* swapChainBackBuffer);

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DSwapChain9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Present(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion,DWORD dwFlags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFrontBufferData(THIS_ IDirect3DSurface9* pDestSurface) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetBackBuffer(THIS_ UINT iBackBuffer,D3DBACKBUFFER_TYPE Type,IDirect3DSurface9** ppBackBuffer) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRasterStatus(THIS_ D3DRASTER_STATUS* pRasterStatus) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDisplayMode(THIS_ D3DDISPLAYMODE* pMode) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPresentParameters(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters) override;

	inline LPDIRECT3DSWAPCHAIN9 GetUnderlyingSwapChain(void) const
	{
		return realObject;
	}

	void SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP* pRamp);
	void GetGammaRamp(D3DGAMMARAMP* pRamp);

	void InitDefaultGammaRamp(void);

	void InitBlitSurface(void);

	const D3DDISPLAYMODE& GetInternalDisplayMode(void) const
	{
		return InternalDisplayMode;
	}

	IDirect3DSurface9Hook* const GetInternalBackBuffer(void)
	{
		return backBuffer;
	}

protected:
	LPDIRECT3DSWAPCHAIN9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

	// Blit from the software backbuffer to the hardware backbuffer:
	void InternalBlit(void);

	IDirect3DSurface9Hook* backBuffer;
	D3DPRESENT_PARAMETERS InternalPresentParameters;
	D3DDISPLAYMODE InternalDisplayMode;
	D3DGAMMARAMP gammaRamp;
	LPDIRECT3DSURFACE9 tempBlitSurface;
};

```

`Software_d3d9/IDirect3DTexture9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DTexture9Hook.h"
#include "IDirect3DSurface9Hook.h"
#include "IDirect3DDevice9Hook.h"

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG IDirect3DTexture9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG IDirect3DTexture9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Texture %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DBaseTexture9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

#ifdef _DEBUG
	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
#endif
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags)
{
	HRESULT ret = realObject->SetPrivateData(refguid, pData, SizeOfData, Flags);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData)
{
	HRESULT ret = realObject->GetPrivateData(refguid, pData, pSizeOfData);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::FreePrivateData(THIS_ REFGUID refguid)
{
	HRESULT ret = realObject->FreePrivateData(refguid);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD IDirect3DTexture9Hook::SetPriority(THIS_ DWORD PriorityNew)
{
	DWORD ret = realObject->SetPriority(PriorityNew);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD IDirect3DTexture9Hook::GetPriority(THIS)
{
	DWORD ret = realObject->GetPriority();
	return ret;
}

COM_DECLSPEC_NOTHROW void IDirect3DTexture9Hook::PreLoad(THIS)
{
	realObject->PreLoad();
}

COM_DECLSPEC_NOTHROW D3DRESOURCETYPE IDirect3DTexture9Hook::GetType(THIS)
{
#ifdef _DEBUG
	D3DRESOURCETYPE realRet = realObject->GetType();
	if (realRet != D3DRTYPE_TEXTURE)
	{
		__debugbreak();
	}
#endif
	return D3DRTYPE_TEXTURE;
}

COM_DECLSPEC_NOTHROW DWORD IDirect3DTexture9Hook::SetLOD(THIS_ DWORD LODNew)
{
	DWORD ret = realObject->SetLOD(LODNew);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD IDirect3DTexture9Hook::GetLOD(THIS)
{
	DWORD ret = realObject->GetLOD();
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD IDirect3DTexture9Hook::GetLevelCount(THIS)
{
	DWORD ret = realObject->GetLevelCount();
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::SetAutoGenFilterType(THIS_ D3DTEXTUREFILTERTYPE FilterType)
{
	HRESULT ret = realObject->SetAutoGenFilterType(FilterType);
	if (FAILED(ret) )
		return ret;

	AutoGenFilter = FilterType;

	return ret;
}

COM_DECLSPEC_NOTHROW D3DTEXTUREFILTERTYPE IDirect3DTexture9Hook::GetAutoGenFilterType(THIS)
{
#ifdef _DEBUG
	D3DTEXTUREFILTERTYPE realRet = realObject->GetAutoGenFilterType();
	if (realRet != AutoGenFilter)
	{
		__debugbreak();
	}
#endif
	return AutoGenFilter;
}

COM_DECLSPEC_NOTHROW void IDirect3DTexture9Hook::GenerateMipSubLevels(THIS)
{
	realObject->GenerateMipSubLevels();

	if (!(InternalUsage & D3DUSAGE_AUTOGENMIPMAP) )
		return;

	// TODO: Implement this
}

COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::GetLevelDesc(THIS_ UINT Level,D3DSURFACE_DESC *pDesc)
{
	//HRESULT ret = realObject->GetLevelDesc(Level, pDesc);

	if (Level >= surfaces.size() )
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return D3DERR_INVALIDCALL;
	}

	HRESULT ret = surfaces[Level]->GetDesc(pDesc);
	if (FAILED(ret) )
		return ret;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::GetSurfaceLevel(THIS_ UINT Level,IDirect3DSurface9** ppSurfaceLevel)
{
	LPDIRECT3DSURFACE9 realSurface = NULL;
	HRESULT ret = realObject->GetSurfaceLevel(Level, &realSurface);
	if (FAILED(ret) )
		return ret;

	if (InternalUsage & D3DUSAGE_AUTOGENMIPMAP)
	{
		if (Level > 0)
		{
#ifdef _DEBUG
			__debugbreak();
#endif
			return D3DERR_INVALIDCALL;
		}
	}

	if (ppSurfaceLevel)
	{
		IDirect3DSurface9Hook* const retSurface = surfaces[Level];

#ifdef _DEBUG
		if (retSurface->GetUnderlyingSurface() != realSurface)
		{
			__debugbreak();
		}
#endif

		*ppSurfaceLevel = retSurface;
		retSurface->AddRef(); // Super important to increment the ref-count here, otherwise our surfaces will get deleted out from under us!
		return ret;
	}
	else
	{
		return D3DERR_INVALIDCALL;
	}
}

COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::LockRect(THIS_ UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags)
{
	/*HRESULT ret = realObject->LockRect(Level, pLockedRect, pRect, Flags);
	if (FAILED(ret) )
		return ret;*/

	if (Level >= surfaces.size() )
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return D3DERR_INVALIDCALL;
	}

	HRESULT ret = surfaces[Level]->LockRect(pLockedRect, pRect, Flags);
	if (FAILED(ret) )
		return ret;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::UnlockRect(THIS_ UINT Level)
{
	//HRESULT ret = realObject->UnlockRect(Level);

	if (Level >= surfaces.size() )
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return D3DERR_INVALIDCALL;
	}

	HRESULT ret = surfaces[Level]->UnlockRect();
	if (FAILED(ret) )
		return ret;

	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT IDirect3DTexture9Hook::AddDirtyRect(THIS_ CONST RECT* pDirtyRect)
{
	HRESULT ret = realObject->AddDirtyRect(pDirtyRect);
	return ret;
}

static inline const unsigned GetMipLevels(unsigned Dimension)
{
	unsigned ret = 1;

	while (Dimension > 1)
	{
		Dimension >>= 1;
		++ret;
	}

	return ret;
}

static inline const unsigned GetMipLevels(const unsigned Width, const unsigned Height)
{
	if (Width > Height)
		return GetMipLevels(Width);
	else
		return GetMipLevels(Height);
}

static inline const unsigned GetMipLevels(const unsigned Width, const unsigned Height, const unsigned Depth)
{
	if (Width > Height && Width > Depth)
		return GetMipLevels(Width);
	else if (Height > Width && Height > Depth)
		return GetMipLevels(Height);
	else
		return GetMipLevels(Depth);
}

void IDirect3DTexture9Hook::CreateTexture(const UINT _Width, const UINT _Height, const UINT _Levels, const DebuggableUsage _Usage, const D3DFORMAT _Format, const D3DPOOL _Pool)
{
	InternalWidth = _Width;
	InternalHeight = _Height;
	InternalLevels = _Levels;
	InternalUsage = _Usage;
	InternalFormat = _Format;
	InternalPool = _Pool;

	const unsigned numMips = InternalLevels ? InternalLevels : GetMipLevels(InternalWidth, InternalHeight);
	UINT surfaceWidth = InternalWidth;
	UINT surfaceHeight = InternalHeight;
	for (unsigned x = 0; x < numMips; ++x)
	{
		LPDIRECT3DSURFACE9 realSurface = NULL;
		if (!(InternalUsage & D3DUSAGE_AUTOGENMIPMAP) || x == 0)
		{
			if (FAILED(realObject->GetSurfaceLevel(x, &realSurface) ) || !realSurface)
			{
				__debugbreak();
			}
		}

		IDirect3DSurface9Hook* newSurface = new IDirect3DSurface9Hook(realSurface, parentDevice);
		newSurface->CreateTextureImplicitSurface(surfaceWidth, surfaceHeight, InternalFormat, InternalPool, InternalUsage, x, this);

		surfaceWidth >>= 1;
		if (surfaceWidth == 0)
			surfaceWidth = 1;
		surfaceHeight >>= 1;
		if (surfaceHeight == 0)
			surfaceHeight = 1;

		surfaces.push_back(newSurface);
	}

	surfaceCountMinusOne = surfaces.size() - 1;
	surfaceCountMinusTwo = ( (const int)surfaceCountMinusOne) - 1; // This can be negative
	surfaceCountMinusOneF = (const float)surfaceCountMinusOne;

	surfaceLevel0 = surfaces[0];
}

const bool IDirect3DTexture9Hook::UpdateTextureInternal(const IDirect3DTexture9Hook* const sourceTexture)
{
	// In addition, this method will fail if the textures are of different formats. Source: https://msdn.microsoft.com/en-us/library/windows/desktop/bb205858(v=vs.85).aspx
	if (sourceTexture->InternalFormat != InternalFormat)
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return false;
	}

	// If the source texture has fewer levels than the destination, the method will fail. Source: https://msdn.microsoft.com/en-us/library/windows/desktop/bb205858(v=vs.85).aspx
	if (sourceTexture->surfaces.size() < surfaces.size() )
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return false;
	}

	if (InternalUsage & D3DUSAGE_AUTOGENMIPMAP)
	{
		surfaceLevel0->UpdateSurfaceInternal(sourceTexture->surfaceLevel0, NULL, NULL);
		return true;
	}
	// If pSourceTexture is an autogenerated mipmap and pDestinationTexture a non-autogenerated mipmap, UpdateTexture will fail. Source: https://msdn.microsoft.com/en-us/library/windows/desktop/bb205858(v=vs.85).aspx
	else if (sourceTexture->InternalUsage & D3DUSAGE_AUTOGENMIPMAP)
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return false;
	}

	// For now, only support copying between equal textures:
	if (sourceTexture->surfaces.size() != surfaces.size() )
	{
		__debugbreak();
	}
	if (sourceTexture->InternalWidth != InternalWidth)
	{
		__debugbreak();
	}
	if (sourceTexture->InternalHeight != InternalHeight)
	{
		__debugbreak();
	}

	const unsigned numSurfacesToCopy = surfaces.size();
	for (unsigned x = 0; x < numSurfacesToCopy; ++x)
	{
		surfaces[x]->UpdateSurfaceInternal(sourceTexture->surfaces[x], NULL, NULL);
	}

	return true;
}

template void IDirect3DTexture9Hook::SampleTextureLoD<0>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<1>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<2>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<3>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<4>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<5>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<6>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<7>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<8>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<9>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<10>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<11>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<12>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<13>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<14>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureLoD<15>(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;

template <const unsigned char writeMask>
void IDirect3DTexture9Hook::SampleTextureLoD(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const
{
	if (writeMask == 0x0)
	{
		outColor.x = outColor.y = outColor.z = outColor.w = 0.0f;
		return;
	}

	switch (samplerState.stateUnion.namedStates.addressU)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#endif
	case D3DTADDRESS_WRAP      :
		if (x > 1.0f)
			x = fmodf(x, 1.0f);
		else if (x < 0.0f)
			x = 1.0f - fmodf(fabsf(x), 1.0f);
		break;
	case D3DTADDRESS_MIRROR    :
	{
		const int ix = (const int)x;
		x = fmodf(x, 1.0f);
		if (ix & 0x1)
			x = 1.0f - x;
	}
		break;
	case D3DTADDRESS_CLAMP     :
		if (x > 1.0f)
			x = 1.0f;
		else if (x < 0.0f)
			x = 0.0f;
		break;
	case D3DTADDRESS_BORDER    :
		if (x < 0.0f || x > 1.0f)
		{
			ColorDWORDToFloat4(samplerState.stateUnion.namedStates.borderColor, outColor);
			return;
		}
		break;
	case D3DTADDRESS_MIRRORONCE:
	{
		const float f = fabsf(x);
		x = f > 1.0f ? 1.0f : f;
	}
		break;
	}

	switch (samplerState.stateUnion.namedStates.addressV)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#endif
	case D3DTADDRESS_WRAP      :
		if (y > 1.0f)
			y = fmodf(y, 1.0f);
		else if (y < 0.0f)
			y = 1.0f - fmodf(fabsf(y), 1.0f);
		break;
	case D3DTADDRESS_MIRROR    :
	{
		const int iy = (const int)y;
		y = fmodf(y, 1.0f);
		if (iy & 0x1)
			y = 1.0f - y;
	}
		break;
	case D3DTADDRESS_CLAMP     :
		if (y > 1.0f)
			y = 1.0f;
		else if (y < 0.0f)
			y = 0.0f;
		break;
	case D3DTADDRESS_BORDER    :
		if (y < 0.0f || y > 1.0f)
		{
			ColorDWORDToFloat4(samplerState.stateUnion.namedStates.borderColor, outColor);
			return;
		}
		break;
	case D3DTADDRESS_MIRRORONCE:
	{
		const float f = fabsf(y);
		y = f > 1.0f ? 1.0f : f;
	}
		break;
	}

	mip += samplerState.stateUnion.namedStates.mipMapLoDBias;

	const float maxMipLevel = samplerState.cachedFloatMaxMipLevel;

	if (mip < maxMipLevel)
		mip = maxMipLevel;

	const float minMipLevel = surfaceCountMinusOneF;

	if (mip > minMipLevel)
		mip = minMipLevel;

	if (mip < 0.0f)
		mip = 0.0f;

	if (mip == 0.0f)
	{
		surfaceLevel0->SampleSurface<writeMask>(x, y, samplerState, outColor);
	}
	else
	{
		switch (samplerState.stateUnion.namedStates.mipFilter)
		{
		default:
#ifdef _DEBUG
			__debugbreak(); // Invalid mip filter!
#endif
		case D3DTEXF_NONE           : // Mip-mapping is disabled, always read level 0 of the surface
			surfaceLevel0->SampleSurface<writeMask>(x, y, samplerState, outColor);
			break;
		case D3DTEXF_POINT          :
		{
			int mipLevel = (const int)(mip + 0.5f);
			const int maxMip = surfaceCountMinusOne;
			if (mipLevel > maxMip)
				mipLevel = maxMip;
			surfaces[mipLevel]->SampleSurface<writeMask>(x, y, samplerState, outColor);
		}
			break;
		case D3DTEXF_ANISOTROPIC    :
		case D3DTEXF_PYRAMIDALQUAD  :
		case D3DTEXF_GAUSSIANQUAD   :
		case D3DTEXF_CONVOLUTIONMONO:
#ifdef _DEBUG
			__debugbreak();
			// Use of these types with D3DSAMP_MIPFILTER is undefined!
#endif
		case D3DTEXF_LINEAR         :
		{
			const int mipLevelLow = (const int)mip;
			const float mipLerp = mip - mipLevelLow;

			if (mipLerp == 0.0f)
			{
				surfaces[mipLevelLow]->SampleSurface<writeMask>(x, y, samplerState, outColor);
			}
			else if (mipLevelLow >= surfaceCountMinusTwo)
			{
				surfaces[surfaceCountMinusOne]->SampleSurface<writeMask>(x, y, samplerState, outColor);
			}
			else
			{
				const int mipLevelHigh = mipLevelLow + 1;

				D3DXVECTOR4 lowColor, highColor;
				surfaces[mipLevelLow]->SampleSurface<writeMask>(x, y, samplerState, lowColor);
				surfaces[mipLevelHigh]->SampleSurface<writeMask>(x, y, samplerState, highColor);

				lrp<writeMask>(outColor, lowColor, highColor, mipLerp);
			}
		}
			break;
		}
	}
}

template void IDirect3DTexture9Hook::SampleTextureLoD4<0>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<1>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<2>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<3>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<4>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<5>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<6>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<7>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<8>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<9>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<10>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<11>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<12>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<13>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<14>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureLoD4<15>(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;

union borderColorUsageUnion
{
	unsigned char usingBorderColorChannel[4];
	unsigned anyUsingBorderColor;
};
static_assert(sizeof(borderColorUsageUnion) == sizeof(unsigned), "Error! Unexpected union size!");

template <const unsigned char writeMask>
void IDirect3DTexture9Hook::SampleTextureLoD4(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const
{
	if (writeMask == 0x0)
	{
		outColor4[0].x = outColor4[0].y = outColor4[0].z = outColor4[0].w = 0.0f;
		outColor4[1].x = outColor4[1].y = outColor4[1].z = outColor4[1].w = 0.0f;
		outColor4[2].x = outColor4[2].y = outColor4[2].z = outColor4[2].w = 0.0f;
		outColor4[3].x = outColor4[3].y = outColor4[3].z = outColor4[3].w = 0.0f;
		return;
	}

	borderColorUsageUnion usingBorderColor4;
	usingBorderColor4.anyUsingBorderColor = 0x00000000;

	switch (samplerState.stateUnion.namedStates.addressU)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#endif
	case D3DTADDRESS_WRAP      :
		if (x4[0] > 1.0f)
			x4[0] = fmodf(x4[0], 1.0f);
		else if (x4[0] < 0.0f)
			x4[0] = 1.0f - fmodf(fabsf(x4[0]), 1.0f);

		if (x4[1] > 1.0f)
			x4[1] = fmodf(x4[1], 1.0f);
		else if (x4[1] < 0.0f)
			x4[1] = 1.0f - fmodf(fabsf(x4[1]), 1.0f);

		if (x4[2] > 1.0f)
			x4[2] = fmodf(x4[2], 1.0f);
		else if (x4[2] < 0.0f)
			x4[2] = 1.0f - fmodf(fabsf(x4[2]), 1.0f);

		if (x4[3] > 1.0f)
			x4[3] = fmodf(x4[3], 1.0f);
		else if (x4[3] < 0.0f)
			x4[3] = 1.0f - fmodf(fabsf(x4[3]), 1.0f);
		break;
	case D3DTADDRESS_MIRROR    :
	{
		const int ix4[4] = 
		{
			(const int)x4[0],
			(const int)x4[1],
			(const int)x4[2],
			(const int)x4[3]
		};
		x4[0] = fmodf(x4[0], 1.0f);
		if (ix4[0] & 0x1)
			x4[0] = 1.0f - x4[0];

		x4[1] = fmodf(x4[1], 1.0f);
		if (ix4[1] & 0x1)
			x4[1] = 1.0f - x4[1];

		x4[2] = fmodf(x4[2], 1.0f);
		if (ix4[2] & 0x1)
			x4[2] = 1.0f - x4[2];

		x4[3] = fmodf(x4[3], 1.0f);
		if (ix4[3] & 0x1)
			x4[3] = 1.0f - x4[3];
	}
		break;
	case D3DTADDRESS_CLAMP     :
		if (x4[0] > 1.0f)
			x4[0] = 1.0f;
		else if (x4[0] < 0.0f)
			x4[0] = 0.0f;

		if (x4[1] > 1.0f)
			x4[1] = 1.0f;
		else if (x4[1] < 0.0f)
			x4[1] = 0.0f;

		if (x4[2] > 1.0f)
			x4[2] = 1.0f;
		else if (x4[2] < 0.0f)
			x4[2] = 0.0f;

		if (x4[3] > 1.0f)
			x4[3] = 1.0f;
		else if (x4[3] < 0.0f)
			x4[3] = 0.0f;
		break;
	case D3DTADDRESS_BORDER    :
		if (x4[0] < 0.0f || x4[0] > 1.0f)
		{
			ColorDWORDToFloat4(samplerState.stateUnion.namedStates.borderColor, outColor4[0]);
			usingBorderColor4.usingBorderColorChannel[0] = 0xFF;
		}
		if (x4[1] < 0.0f || x4[1] > 1.0f)
		{
			ColorDWORDToFloat4(samplerState.stateUnion.namedStates.borderColor, outColor4[1]);
			usingBorderColor4.usingBorderColorChannel[1] = 0xFF;
		}
		if (x4[2] < 0.0f || x4[2] > 1.0f)
		{
			ColorDWORDToFloat4(samplerState.stateUnion.namedStates.borderColor, outColor4[2]);
			usingBorderColor4.usingBorderColorChannel[2] = 0xFF;
		}
		if (x4[3] < 0.0f || x4[3] > 1.0f)
		{
			ColorDWORDToFloat4(samplerState.stateUnion.namedStates.borderColor, outColor4[3]);
			usingBorderColor4.usingBorderColorChannel[3] = 0xFF;
		}

		// Early out in cases where the whole pixel-quad has texcoords outside the border region:
		if (usingBorderColor4.anyUsingBorderColor == 0xFFFFFFFF)
			return;
		break;
	case D3DTADDRESS_MIRRORONCE:
	{
		const float posF[4] = 
		{
			fabsf(x4[0]),
			fabsf(x4[1]),
			fabsf(x4[2]),
			fabsf(x4[3])
		};
		x4[0] = posF[0] > 1.0f ? 1.0f : posF[0];
		x4[1] = posF[1] > 1.0f ? 1.0f : posF[1];
		x4[2] = posF[2] > 1.0f ? 1.0f : posF[2];
		x4[3] = posF[3] > 1.0f ? 1.0f : posF[3];
	}
		break;
	}

	switch (samplerState.stateUnion.namedStates.addressV)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#endif
	case D3DTADDRESS_WRAP      :
		if (y4[0] > 1.0f)
			y4[0] = fmodf(y4[0], 1.0f);
		else if (y4[0] < 0.0f)
			y4[0] = 1.0f - fmodf(fabsf(y4[0]), 1.0f);

		if (y4[1] > 1.0f)
			y4[1] = fmodf(y4[1], 1.0f);
		else if (y4[1] < 0.0f)
			y4[1] = 1.0f - fmodf(fabsf(y4[1]), 1.0f);

		if (y4[2] > 1.0f)
			y4[2] = fmodf(y4[2], 1.0f);
		else if (y4[2] < 0.0f)
			y4[2] = 1.0f - fmodf(fabsf(y4[2]), 1.0f);

		if (y4[3] > 1.0f)
			y4[3] = fmodf(y4[3], 1.0f);
		else if (y4[3] < 0.0f)
			y4[3] = 1.0f - fmodf(fabsf(y4[3]), 1.0f);
		break;
	case D3DTADDRESS_MIRROR    :
	{
		const int iy4[4] = 
		{
			(const int)y4[0],
			(const int)y4[1],
			(const int)y4[2],
			(const int)y4[3]
		};
		y4[0] = fmodf(y4[0], 1.0f);
		if (iy4[0] & 0x1)
			y4[0] = 1.0f - y4[0];

		y4[1] = fmodf(y4[1], 1.0f);
		if (iy4[1] & 0x1)
			y4[1] = 1.0f - y4[1];

		y4[2] = fmodf(y4[2], 1.0f);
		if (iy4[2] & 0x1)
			y4[2] = 1.0f - y4[2];

		y4[3] = fmodf(y4[3], 1.0f);
		if (iy4[3] & 0x1)
			y4[3] = 1.0f - y4[3];
	}
		break;
	case D3DTADDRESS_CLAMP     :
		if (y4[0] > 1.0f)
			y4[0] = 1.0f;
		else if (y4[0] < 0.0f)
			y4[0] = 0.0f;

		if (y4[1] > 1.0f)
			y4[1] = 1.0f;
		else if (y4[1] < 0.0f)
			y4[1] = 0.0f;

		if (y4[2] > 1.0f)
			y4[2] = 1.0f;
		else if (y4[2] < 0.0f)
			y4[2] = 0.0f;

		if (y4[3] > 1.0f)
			y4[3] = 1.0f;
		else if (y4[3] < 0.0f)
			y4[3] = 0.0f;
		break;
	case D3DTADDRESS_BORDER    :
		if (!usingBorderColor4.usingBorderColorChannel[0] && (y4[0] < 0.0f || y4[0] > 1.0f) )
		{
			ColorDWORDToFloat4(samplerState.stateUnion.namedStates.borderColor, outColor4[0]);
			usingBorderColor4.usingBorderColorChannel[0] = 0xFF;
		}
		if (!usingBorderColor4.usingBorderColorChannel[1] && (y4[1] < 0.0f || y4[1] > 1.0f) )
		{
			ColorDWORDToFloat4(samplerState.stateUnion.namedStates.borderColor, outColor4[1]);
			usingBorderColor4.usingBorderColorChannel[1] = 0xFF;
		}
		if (!usingBorderColor4.usingBorderColorChannel[2] && (y4[2] < 0.0f || y4[2] > 1.0f) )
		{
			ColorDWORDToFloat4(samplerState.stateUnion.namedStates.borderColor, outColor4[2]);
			usingBorderColor4.usingBorderColorChannel[2] = 0xFF;
		}
		if (!usingBorderColor4.usingBorderColorChannel[3] && (y4[3] < 0.0f || y4[3] > 1.0f) )
		{
			ColorDWORDToFloat4(samplerState.stateUnion.namedStates.borderColor, outColor4[3]);
			usingBorderColor4.usingBorderColorChannel[3] = 0xFF;
		}

		// Early out in cases where the whole pixel-quad has texcoords outside the border region:
		if (usingBorderColor4.anyUsingBorderColor == 0xFFFFFFFF)
			return;
		break;
	case D3DTADDRESS_MIRRORONCE:
	{
		const float posF[4] = 
		{
			fabsf(y4[0]),
			fabsf(y4[1]),
			fabsf(y4[2]),
			fabsf(y4[3])
		};
		y4[0] = posF[0] > 1.0f ? 1.0f : posF[0];
		y4[1] = posF[1] > 1.0f ? 1.0f : posF[1];
		y4[2] = posF[2] > 1.0f ? 1.0f : posF[2];
		y4[3] = posF[3] > 1.0f ? 1.0f : posF[3];
	}
		break;
	}

	mip4[0] += samplerState.stateUnion.namedStates.mipMapLoDBias;
	mip4[1] += samplerState.stateUnion.namedStates.mipMapLoDBias;
	mip4[2] += samplerState.stateUnion.namedStates.mipMapLoDBias;
	mip4[3] += samplerState.stateUnion.namedStates.mipMapLoDBias;

	const float maxMipLevel = samplerState.cachedFloatMaxMipLevel;

	if (mip4[0] < maxMipLevel)
		mip4[0] = maxMipLevel;
	if (mip4[1] < maxMipLevel)
		mip4[1] = maxMipLevel;
	if (mip4[2] < maxMipLevel)
		mip4[2] = maxMipLevel;
	if (mip4[3] < maxMipLevel)
		mip4[3] = maxMipLevel;

	const float minMipLevel = surfaceCountMinusOneF;

	if (mip4[0] > minMipLevel)
		mip4[0] = minMipLevel;
	if (mip4[1] > minMipLevel)
		mip4[1] = minMipLevel;
	if (mip4[2] > minMipLevel)
		mip4[2] = minMipLevel;
	if (mip4[3] > minMipLevel)
		mip4[3] = minMipLevel;

	if (mip4[0] < 0.0f)
		mip4[0] = 0.0f;
	if (mip4[1] < 0.0f)
		mip4[1] = 0.0f;
	if (mip4[2] < 0.0f)
		mip4[2] = 0.0f;
	if (mip4[3] < 0.0f)
		mip4[3] = 0.0f;

	switch (samplerState.stateUnion.namedStates.mipFilter)
	{
	default:
#ifdef _DEBUG
			__debugbreak(); // Invalid mip filter!
#endif
	case D3DTEXF_NONE           : // Mip-mapping is disabled, always read level 0 of the surface
	{
		if (usingBorderColor4.anyUsingBorderColor == 0x00000000)
		{
			surfaceLevel0->SampleSurface4<writeMask>(x4, y4, samplerState, outColor4);
		}
		else
		{
			if (!usingBorderColor4.usingBorderColorChannel[0])
				surfaceLevel0->SampleSurface<writeMask>(x4[0], y4[0], samplerState, outColor4[0]);
			if (!usingBorderColor4.usingBorderColorChannel[1])
				surfaceLevel0->SampleSurface<writeMask>(x4[1], y4[1], samplerState, outColor4[1]);
			if (!usingBorderColor4.usingBorderColorChannel[2])
				surfaceLevel0->SampleSurface<writeMask>(x4[2], y4[2], samplerState, outColor4[2]);
			if (!usingBorderColor4.usingBorderColorChannel[3])
				surfaceLevel0->SampleSurface<writeMask>(x4[3], y4[3], samplerState, outColor4[3]);
		}
	}
		break;
	case D3DTEXF_POINT          :
	{
		const int maxMip = surfaceCountMinusOne;
		int mipLevel4[4] =
		{
			(const int)(mip4[0] + 0.5f),
			(const int)(mip4[1] + 0.5f),
			(const int)(mip4[2] + 0.5f),
			(const int)(mip4[3] + 0.5f)
		};
		if (mipLevel4[0] > maxMip)
			mipLevel4[0] = maxMip;
		if (mipLevel4[1] > maxMip)
			mipLevel4[1] = maxMip;
		if (mipLevel4[2] > maxMip)
			mipLevel4[2] = maxMip;
		if (mipLevel4[3] > maxMip)
			mipLevel4[3] = maxMip;

		if ( (usingBorderColor4.anyUsingBorderColor == 0x00000000) &&
			(mipLevel4[0] == mipLevel4[1]) &&
			(mipLevel4[2] == mipLevel4[3]) &&
			(mipLevel4[0] == mipLevel4[2]) )
		{
			surfaces[mipLevel4[0] ]->SampleSurface4<writeMask>(x4, y4, samplerState, outColor4);
		}
		else
		{
			if (!usingBorderColor4.usingBorderColorChannel[0])
				surfaces[mipLevel4[0] ]->SampleSurface<writeMask>(x4[0], y4[0], samplerState, outColor4[0]);
			if (!usingBorderColor4.usingBorderColorChannel[1])
				surfaces[mipLevel4[1] ]->SampleSurface<writeMask>(x4[1], y4[1], samplerState, outColor4[1]);
			if (!usingBorderColor4.usingBorderColorChannel[2])
				surfaces[mipLevel4[2] ]->SampleSurface<writeMask>(x4[2], y4[2], samplerState, outColor4[2]);
			if (!usingBorderColor4.usingBorderColorChannel[3])
				surfaces[mipLevel4[3] ]->SampleSurface<writeMask>(x4[3], y4[3], samplerState, outColor4[3]);
		}
	}
		break;
	case D3DTEXF_ANISOTROPIC    :
	case D3DTEXF_PYRAMIDALQUAD  :
	case D3DTEXF_GAUSSIANQUAD   :
	case D3DTEXF_CONVOLUTIONMONO:
#ifdef _DEBUG
			__debugbreak();
			// Use of these types with D3DSAMP_MIPFILTER is undefined!
#endif
	case D3DTEXF_LINEAR         :
	{
		const int mipLevelLow4[4] = 
		{
			(const int)mip4[0],
			(const int)mip4[1],
			(const int)mip4[2],
			(const int)mip4[3]
		};
		const float mipLerp4[4] = 
		{
			mip4[0] - mipLevelLow4[0],
			mip4[1] - mipLevelLow4[1],
			mip4[2] - mipLevelLow4[2],
			mip4[3] - mipLevelLow4[3]
		};

		const int maxMip = (const int)surfaceCountMinusOne;
		const int maxMipLevelLow = maxMip - 1;

		// See if we can use a unified miplevel for our sample4, or if we have to do four individual samples to different miplevel surfaces:
		if (usingBorderColor4.anyUsingBorderColor == 0x00000000)
		{
			// Well this is going to be tough to vectorize...
			if ( (mipLerp4[0] == mipLerp4[1]) &&
				(mipLerp4[2] == mipLerp4[3]) &&
				(mipLerp4[0] == mipLerp4[2]) &&
				(mipLerp4[0] == 0.0f) &&
				(mipLevelLow4[0] == mipLevelLow4[1]) &&
				(mipLevelLow4[2] == mipLevelLow4[3]) &&
				(mipLevelLow4[0] == mipLevelLow4[2]) )
			{
				surfaces[mipLevelLow4[0] ]->SampleSurface4<writeMask>(x4, y4, samplerState, outColor4);
				return;
			}
			else if (mipLevelLow4[0] >= maxMipLevelLow &&
				mipLevelLow4[1] >= maxMipLevelLow && 
				mipLevelLow4[2] >= maxMipLevelLow && 
				mipLevelLow4[3] >= maxMipLevelLow)
			{
				surfaces[maxMip]->SampleSurface4<writeMask>(x4, y4, samplerState, outColor4);
				return;
			}
			else if (mipLevelLow4[0] == mipLevelLow4[1] &&
					 mipLevelLow4[2] == mipLevelLow4[3] &&
					 mipLevelLow4[0] == mipLevelLow4[2])
			{
				D3DXVECTOR4 lowColor4[4];
				surfaces[mipLevelLow4[0] ]->SampleSurface4<writeMask>(x4, y4, samplerState, lowColor4);
				D3DXVECTOR4 highColor4[4];
				surfaces[mipLevelLow4[0] + 1]->SampleSurface4<writeMask>(x4, y4, samplerState, highColor4);

				lrp<writeMask>(outColor4[0], lowColor4[0], highColor4[0], mipLerp4[0]);
				lrp<writeMask>(outColor4[1], lowColor4[1], highColor4[1], mipLerp4[1]);
				lrp<writeMask>(outColor4[2], lowColor4[2], highColor4[2], mipLerp4[2]);
				lrp<writeMask>(outColor4[3], lowColor4[3], highColor4[3], mipLerp4[3]);
				return;
			}
		}

		// Sad times, we have no choice but to do separate samples from different mip-level surfaces:
		if (!usingBorderColor4.usingBorderColorChannel[0])
		{
			if (mipLerp4[0] == 0.0f)
				surfaces[mipLevelLow4[0] ]->SampleSurface<writeMask>(x4[0], y4[0], samplerState, outColor4[0]);
			else if (mipLevelLow4[0] >= maxMipLevelLow)
				surfaces[maxMip]->SampleSurface<writeMask>(x4[0], y4[0], samplerState, outColor4[0]);
			else
			{
				D3DXVECTOR4 lowColor, highColor;
				surfaces[mipLevelLow4[0] ]->SampleSurface<writeMask>(x4[0], y4[0], samplerState, lowColor);
				surfaces[mipLevelLow4[0] + 1]->SampleSurface<writeMask>(x4[0], y4[0], samplerState, highColor);
				lrp<writeMask>(outColor4[0], lowColor, highColor, mipLerp4[0]);
			}
		}

		if (!usingBorderColor4.usingBorderColorChannel[1])
		{
			if (mipLerp4[1] == 0.0f)
				surfaces[mipLevelLow4[1] ]->SampleSurface<writeMask>(x4[1], y4[1], samplerState, outColor4[1]);
			else if (mipLevelLow4[1] >= maxMipLevelLow)
				surfaces[maxMip]->SampleSurface<writeMask>(x4[1], y4[1], samplerState, outColor4[1]);
			else
			{
				D3DXVECTOR4 lowColor, highColor;
				surfaces[mipLevelLow4[1] ]->SampleSurface<writeMask>(x4[1], y4[1], samplerState, lowColor);
				surfaces[mipLevelLow4[1] + 1]->SampleSurface<writeMask>(x4[1], y4[1], samplerState, highColor);
				lrp<writeMask>(outColor4[1], lowColor, highColor, mipLerp4[1]);
			}
		}

		if (!usingBorderColor4.usingBorderColorChannel[2])
		{
			if (mipLerp4[2] == 0.0f)
				surfaces[mipLevelLow4[2] ]->SampleSurface<writeMask>(x4[2], y4[2], samplerState, outColor4[2]);
			else if (mipLevelLow4[2] >= maxMipLevelLow)
				surfaces[maxMip]->SampleSurface<writeMask>(x4[2], y4[2], samplerState, outColor4[2]);
			else
			{
				D3DXVECTOR4 lowColor, highColor;
				surfaces[mipLevelLow4[2] ]->SampleSurface<writeMask>(x4[2], y4[2], samplerState, lowColor);
				surfaces[mipLevelLow4[2] + 1]->SampleSurface<writeMask>(x4[2], y4[2], samplerState, highColor);
				lrp<writeMask>(outColor4[2], lowColor, highColor, mipLerp4[2]);
			}
		}

		if (!usingBorderColor4.usingBorderColorChannel[3])
		{
			if (mipLerp4[3] == 0.0f)
				surfaces[mipLevelLow4[3] ]->SampleSurface<writeMask>(x4[3], y4[3], samplerState, outColor4[3]);
			else if (mipLevelLow4[3] >= maxMipLevelLow)
				surfaces[maxMip]->SampleSurface<writeMask>(x4[3], y4[3], samplerState, outColor4[3]);
			else
			{
				D3DXVECTOR4 lowColor, highColor;
				surfaces[mipLevelLow4[3] ]->SampleSurface<writeMask>(x4[3], y4[3], samplerState, lowColor);
				surfaces[mipLevelLow4[3] + 1]->SampleSurface<writeMask>(x4[3], y4[3], samplerState, highColor);
				lrp<writeMask>(outColor4[3], lowColor, highColor, mipLerp4[3]);
			}
		}
	}
		break;
	}
}

template void IDirect3DTexture9Hook::SampleTextureGrad<0>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<1>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<2>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<3>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<4>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<5>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<6>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<7>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<8>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<9>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<10>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<11>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<12>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<13>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<14>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGrad<15>(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;

static inline const float dot2(const D3DXVECTOR4& a, const D3DXVECTOR4& b)
{
	return (a.x * b.x) + (a.y * b.y);
}

template <const unsigned char writeMask>
void IDirect3DTexture9Hook::SampleTextureGrad(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const
{
	const unsigned numMipLevels = surfaces.size();
	if (numMipLevels <= 1)
		return SampleTextureLoD<writeMask>(x, y, 0.0f, samplerState, outColor);
	else
	{
		// Compute the mip-level here:
		const float deltaXSquared = dot2(texDdx, texDdx);
		const float deltaYSquared = dot2(texDdy, texDdy);
		const float maxDeltaSquared = deltaXSquared >= deltaYSquared ? deltaXSquared : deltaYSquared;
		const float mip = 0.5f * log2_lowp(maxDeltaSquared) * numMipLevels;
		return SampleTextureLoD<writeMask>(x, y, mip, samplerState, outColor);
	}
}

template void IDirect3DTexture9Hook::SampleTextureGrad4<0>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<1>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<2>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<3>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<4>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<5>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<6>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<7>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<8>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<9>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<10>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<11>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<12>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<13>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<14>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGrad4<15>(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;

static inline void dot2_4(const D3DXVECTOR4 (&a4)[4], const D3DXVECTOR4 (&b4)[4], float (&outDot4)[4])
{
	outDot4[0] = (a4[0].x * b4[0].x) + (a4[0].y * b4[0].y);
	outDot4[1] = (a4[1].x * b4[1].x) + (a4[1].y * b4[1].y);
	outDot4[2] = (a4[2].x * b4[2].x) + (a4[2].y * b4[2].y);
	outDot4[3] = (a4[3].x * b4[3].x) + (a4[3].y * b4[3].y);
}

template <const unsigned char writeMask>
void IDirect3DTexture9Hook::SampleTextureGrad4(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const
{
	const unsigned numMipLevels = surfaces.size();
	if (numMipLevels <= 1)
	{
		float zeroMip4[4] =
		{
			0.0f,
			0.0f,
			0.0f,
			0.0f
		};
		return SampleTextureLoD4<writeMask>(x4, y4, zeroMip4, samplerState, outColor4);
	}
	else
	{
		// Compute the mip-level here:
		float deltaXSquared4[4];
		float deltaYSquared4[4];
		dot2_4(texDdx4, texDdx4, deltaXSquared4);
		dot2_4(texDdy4, texDdy4, deltaYSquared4);
		float maxDeltaSquared4[4];
		maxDeltaSquared4[0] = deltaXSquared4[0] >= deltaYSquared4[0] ? deltaXSquared4[0] : deltaYSquared4[0];
		maxDeltaSquared4[1] = deltaXSquared4[1] >= deltaYSquared4[1] ? deltaXSquared4[1] : deltaYSquared4[1];
		maxDeltaSquared4[2] = deltaXSquared4[2] >= deltaYSquared4[2] ? deltaXSquared4[2] : deltaYSquared4[2];
		maxDeltaSquared4[3] = deltaXSquared4[3] >= deltaYSquared4[3] ? deltaXSquared4[3] : deltaYSquared4[3];
		const float halfNumMips = 0.5f * numMipLevels;
		float mip4[4] =
		{
			log2_lowp(maxDeltaSquared4[0]) * halfNumMips,
			log2_lowp(maxDeltaSquared4[1]) * halfNumMips,
			log2_lowp(maxDeltaSquared4[2]) * halfNumMips,
			log2_lowp(maxDeltaSquared4[3]) * halfNumMips
		};
		return SampleTextureLoD4<writeMask>(x4, y4, mip4, samplerState, outColor4);
	}
}

template void IDirect3DTexture9Hook::SampleTextureGradBias<0>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<1>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<2>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<3>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<4>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<5>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<6>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<7>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<8>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<9>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<10>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<11>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<12>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<13>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<14>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias<15>(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;

template <const unsigned char writeMask>
void IDirect3DTexture9Hook::SampleTextureGradBias(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const
{
	const unsigned numMipLevels = surfaces.size();
	if (numMipLevels <= 1)
		return SampleTextureLoD<writeMask>(x, y, mipBias, samplerState, outColor);
	else
	{
		// Compute the mip-level here:
		const float deltaXSquared = dot2(texDdx, texDdx);
		const float deltaYSquared = dot2(texDdy, texDdy);
		const float maxDeltaSquared = deltaXSquared >= deltaYSquared ? deltaXSquared : deltaYSquared;
		const float mip = 0.5f * log2_lowp(maxDeltaSquared) * numMipLevels;
		return SampleTextureLoD<writeMask>(x, y, mip + mipBias, samplerState, outColor);
	}
}

template void IDirect3DTexture9Hook::SampleTextureGradBias4<0>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<1>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<2>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<3>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<4>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<5>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<6>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<7>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<8>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<9>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<10>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<11>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<12>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<13>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<14>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;
template void IDirect3DTexture9Hook::SampleTextureGradBias4<15>(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;

template <const unsigned char writeMask>
void IDirect3DTexture9Hook::SampleTextureGradBias4(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const
{
	const unsigned numMipLevels = surfaces.size();
	if (numMipLevels <= 1)
	{
		float biasMip4[4] =
		{
			mipBias4[0],
			mipBias4[1],
			mipBias4[2],
			mipBias4[3]
		};
		return SampleTextureLoD4<writeMask>(x4, y4, biasMip4, samplerState, outColor4);
	}
	else
	{
		// Compute the mip-level here:
		float deltaXSquared4[4];
		float deltaYSquared4[4];
		dot2_4(texDdx4, texDdx4, deltaXSquared4);
		dot2_4(texDdy4, texDdy4, deltaYSquared4);
		float maxDeltaSquared4[4];
		maxDeltaSquared4[0] = deltaXSquared4[0] >= deltaYSquared4[0] ? deltaXSquared4[0] : deltaYSquared4[0];
		maxDeltaSquared4[1] = deltaXSquared4[1] >= deltaYSquared4[1] ? deltaXSquared4[1] : deltaYSquared4[1];
		maxDeltaSquared4[2] = deltaXSquared4[2] >= deltaYSquared4[2] ? deltaXSquared4[2] : deltaYSquared4[2];
		maxDeltaSquared4[3] = deltaXSquared4[3] >= deltaYSquared4[3] ? deltaXSquared4[3] : deltaYSquared4[3];
		const float halfNumMips = 0.5f * numMipLevels;
		float mip4biased[4] =
		{
			log2_lowp(maxDeltaSquared4[0]) * halfNumMips + mipBias4[0],
			log2_lowp(maxDeltaSquared4[1]) * halfNumMips + mipBias4[1],
			log2_lowp(maxDeltaSquared4[2]) * halfNumMips + mipBias4[2],
			log2_lowp(maxDeltaSquared4[3]) * halfNumMips + mipBias4[3]
		};
		return SampleTextureLoD4<writeMask>(x4, y4, mip4biased, samplerState, outColor4);
	}
}

```

`Software_d3d9/IDirect3DTexture9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"
#include "GlobalToggles.h"
struct SamplerState;

class IDirect3DTexture9Hook : public IDirect3DTexture9
{
public:
	IDirect3DTexture9Hook(LPDIRECT3DTEXTURE9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1), AutoGenFilter(D3DTEXF_LINEAR), 
		surfaceCountMinusOne(0), surfaceCountMinusTwo(0), surfaceCountMinusOneF(0.0f), surfaceLevel0(NULL)
#ifdef DUMP_TEXTURES_ON_FIRST_SET
		, dumped(0)
#endif
	{
#ifdef _DEBUG
		memcpy(&Name, &realObject->Name, (char*)&realObject - (char*)&Name);
#endif
	}

	virtual ~IDirect3DTexture9Hook()
	{
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) - sizeof(surfaces) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DBaseTexture9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreePrivateData(THIS_ REFGUID refguid) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetPriority(THIS_ DWORD PriorityNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetPriority(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE PreLoad(THIS) override;
    virtual COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE GetType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetLOD(THIS_ DWORD LODNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetLOD(THIS) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetLevelCount(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetAutoGenFilterType(THIS_ D3DTEXTUREFILTERTYPE FilterType) override;
    virtual COM_DECLSPEC_NOTHROW D3DTEXTUREFILTERTYPE STDMETHODCALLTYPE GetAutoGenFilterType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE GenerateMipSubLevels(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLevelDesc(THIS_ UINT Level,D3DSURFACE_DESC *pDesc) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSurfaceLevel(THIS_ UINT Level,IDirect3DSurface9** ppSurfaceLevel) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LockRect(THIS_ UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UnlockRect(THIS_ UINT Level) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AddDirtyRect(THIS_ CONST RECT* pDirtyRect) override;

	inline LPDIRECT3DTEXTURE9 GetUnderlyingTexture(void) const
	{
		return realObject;
	}

	inline const UINT GetInternalWidth() const
	{
		return InternalWidth;
	}

	inline const UINT GetInternalHeight() const
	{
		return InternalHeight;
	}

	inline const D3DFORMAT GetInternalFormat() const
	{
		return InternalFormat;
	}

	const UINT GetInternalMipLevels() const
	{
		return InternalLevels;
	}

	const DebuggableUsage GetInternalUsage() const
	{
		return InternalUsage;
	}

	const D3DPOOL GetInternalPool() const
	{
		return InternalPool;
	}

	void CreateTexture(const UINT _Width, const UINT _Height, const UINT _Levels, const DebuggableUsage _Usage, const D3DFORMAT _Format, const D3DPOOL _Pool);

	const bool UpdateTextureInternal(const IDirect3DTexture9Hook* const sourceTexture);

	template <const unsigned char writeMask>
	void SampleTextureLoD(float x, float y, float mip, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;

	template <const unsigned char writeMask>
	void SampleTextureGrad(float x, float y, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;

	template <const unsigned char writeMask>
	void SampleTextureGradBias(float x, float y, const float mipBias, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const SamplerState& samplerState, D3DXVECTOR4& outColor) const;

	template <const unsigned char writeMask>
	void SampleTextureLoD4(float (&x4)[4], float (&y4)[4], float (&mip4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;

	template <const unsigned char writeMask>
	void SampleTextureGrad4(float (&x4)[4], float (&y4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;

	template <const unsigned char writeMask>
	void SampleTextureGradBias4(float (&x4)[4], float (&y4)[4], const float (&mipBias4)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const SamplerState& samplerState, D3DXVECTOR4 (&outColor4)[4]) const;

#ifdef DUMP_TEXTURES_ON_FIRST_SET
	unsigned dumped;
#endif

	inline const std::vector<IDirect3DSurface9Hook*>& GetUnderlyingSurfaces(void) const
	{
		return surfaces;
	}

protected:
	LPDIRECT3DTEXTURE9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

	UINT InternalWidth;
	UINT InternalHeight;
	UINT InternalLevels;
	DebuggableUsage InternalUsage;
	D3DFORMAT InternalFormat;
	D3DPOOL InternalPool;
	D3DTEXTUREFILTERTYPE AutoGenFilter;

	UINT surfaceCountMinusOne;
	INT surfaceCountMinusTwo;
	float surfaceCountMinusOneF;

	IDirect3DSurface9Hook* surfaceLevel0;

	std::vector<IDirect3DSurface9Hook*> surfaces;
};

```

`Software_d3d9/IDirect3DVertexBuffer9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DVertexBuffer9Hook.h"
#include "IDirect3DResource9Hook.h"
#include "GlobalToggles.h"

void IDirect3DVertexBuffer9Hook::CreateVertexBuffer(UINT _Length, const DebuggableUsage _Usage, DWORD _FVF, D3DPOOL _Pool)
{
	InternalLength = _Length;
	InternalUsage = _Usage;
	InternalFVF = _FVF;
	InternalPool = _Pool;

	const unsigned magicDWORDLen =
#ifdef VERTEX_BUFFER_MAGIC_COOKIE
		sizeof(DWORD);
#else
		0;
#endif

#ifdef VERTEX_BUFFER_ALLOC_PAGE_NOACCESS
	data = PageAllocWithNoAccessPage(InternalLength + magicDWORDLen);
#else
	data = (BYTE* const)malloc(InternalLength + magicDWORDLen);
#endif
	if (!data)
	{
		__debugbreak(); // Can't alloc our vertex buffer!
	}

#ifdef VERTEX_BUFFER_MAGIC_COOKIE
	*(DWORD* const)&data[InternalLength] = 'VRTX';
#endif
}

#ifdef VERTEX_BUFFER_MAGIC_COOKIE
static inline void ValidateMagicCookie(const std::vector<unsigned char>& bytes, const unsigned length)
{
	if (*(const DWORD* const)&bytes[length] != 'VRTX')
	{
		__debugbreak();
	}
}
#endif // VERTEX_BUFFER_MAGIC_COOKIE

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	if (realObject)
	{
		HRESULT ret = realObject->QueryInterface(riid, ppvObj);
		if (ret == NOERROR)
		{
			*ppvObj = this;
			AddRef();
		}
		return ret;
	}
	// TODO: Fix this
	return S_OK;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::AddRef(THIS)
{
	ULONG ret = realObject ? realObject->AddRef() : (const ULONG)(refCount + 1);
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::Release(THIS)
{
	ULONG ret = realObject ? realObject->Release() : (const ULONG)(refCount - 1);
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Vertex Buffer %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DResource9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	if (!ppDevice)
		return D3DERR_INVALIDCALL;

	if (realObject)
	{
		LPDIRECT3DDEVICE9 realD3D9dev = NULL;
		HRESULT ret = realObject->GetDevice(&realD3D9dev);
		if (FAILED(ret) )
		{
			*ppDevice = NULL;
			return ret;
		}

		// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
		if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
		{
			DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
		}
		parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

		*ppDevice = parentDevice;
		return ret;
	}
	else
	{
		*ppDevice = parentDevice;
		return S_OK;
	}
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags)
{
	if (realObject)
	{
		HRESULT ret = realObject->SetPrivateData(refguid, pData, SizeOfData, Flags);
		return ret;
	}
	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData)
{
	if (realObject)
	{
		HRESULT ret = realObject->GetPrivateData(refguid, pData, pSizeOfData);
		return ret;
	}
	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::FreePrivateData(THIS_ REFGUID refguid)
{
	if (realObject)
	{
		HRESULT ret = realObject->FreePrivateData(refguid);
		return ret;
	}
	return S_OK;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::SetPriority(THIS_ DWORD PriorityNew)
{
	if (realObject)
	{
		DWORD ret = realObject->SetPriority(PriorityNew);
		return ret;
	}
	return 0;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::GetPriority(THIS)
{
	if (realObject)
	{
		DWORD ret = realObject->GetPriority();
		return ret;
	}
	return S_OK;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::PreLoad(THIS)
{
	if (realObject)
		realObject->PreLoad();
}

COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::GetType(THIS)
{
	if (realObject)
	{
		D3DRESOURCETYPE ret = realObject->GetType();
		if (ret != D3DRTYPE_VERTEXBUFFER)
		{
			__debugbreak(); // Huh?
		}
		return ret;
	}
	return D3DRTYPE_VERTEXBUFFER;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::Lock(THIS_ UINT OffsetToLock,UINT SizeToLock,void** ppbData,DWORD Flags)
{
	if (!ppbData)
		return D3DERR_INVALIDCALL;

	const DWORD validLockFlags = D3DLOCK_DISCARD | D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_NOSYSLOCK | D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE; 
	if (Flags & (~validLockFlags) )
		return D3DERR_INVALIDCALL; // These are the only D3DLOCK flags valid for this function call

	if (SizeToLock == 0 && OffsetToLock > 0)
		return D3DERR_INVALIDCALL;

	if (OffsetToLock + SizeToLock > InternalLength)
		return D3DERR_INVALIDCALL;

	if (Flags & (D3DLOCK_DISCARD | D3DLOCK_NOOVERWRITE) )
	{
		// D3D9 in Release mode ignores this error without returning a failure code
		if (!(InternalUsage & D3DUSAGE_DYNAMIC) )
			return D3DERR_INVALIDCALL;
	}

#ifdef VERTEX_BUFFER_MAGIC_COOKIE
	ValidateMagicCookie(data, InternalLength);
#endif

#ifdef VERTEX_BUFFER_ENFORCE_READONLY_WHILE_UNLOCKED
	if (IsUnlocked() )
	{
		BYTE* const pageStartAddr = (BYTE* const)( ( (SIZE_T)data) - ( (SIZE_T)data % 4096) );
		VirtualAlloc(pageStartAddr, InternalLength, MEM_COMMIT, PAGE_READWRITE);
	}
#endif

#ifdef VERTEX_BUFFER_ENFORCE_DISCARD_ON_LOCK
	if ( (InternalUsage & D3DUSAGE_DYNAMIC) && (Flags & D3DLOCK_DISCARD) )
	{
		memset(data, 0, InternalLength);
	}
#endif

	if (OffsetToLock == 0 && SizeToLock == 0)
		*ppbData = data;//&(data.front() );
	else
		*ppbData = /*&(data.front() )*/data + OffsetToLock;

#ifdef _DEBUG
	if (realObject)
	{
		void* tempLockPtr = NULL;
		HRESULT ret = realObject->Lock(OffsetToLock, SizeToLock, &tempLockPtr, Flags);
		if (FAILED(ret) )
		{
			// There was an error that we should've caught but didn't
			__debugbreak();
			return ret;
		}
	}
#endif

	++lockCount;

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::Unlock(THIS)
{
#ifdef _DEBUG
	if (realObject)
	{
		HRESULT ret = realObject->Unlock();
		if (FAILED(ret) )
		{
			__debugbreak(); // There was an error somewhere that we should've caught
			return ret;
		}
	}
#endif

#ifdef VERTEX_BUFFER_MAGIC_COOKIE
	ValidateMagicCookie(data, InternalLength);
#endif

	--lockCount;

#ifdef VERTEX_BUFFER_ENFORCE_READONLY_WHILE_UNLOCKED
	if (IsUnlocked() )
	{
		BYTE* const pageStartAddr = (BYTE* const)( ( (SIZE_T)data) - ( (SIZE_T)data % 4096) );
		VirtualAlloc(pageStartAddr, InternalLength, MEM_COMMIT, PAGE_READONLY);
	}
#endif

	return S_OK;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexBuffer9Hook::GetDesc(THIS_ D3DVERTEXBUFFER_DESC *pDesc)
{
	if (!pDesc)
		return D3DERR_INVALIDCALL;

#ifdef _DEBUG
	if (realObject)
	{
		HRESULT ret = realObject->GetDesc(pDesc);
		if (FAILED(ret) )
		{
			__debugbreak(); // Should've been an error but we didn't find one
			return ret;
		}

		if (pDesc->Size != InternalLength)
		{
			__debugbreak();
		}
		if (pDesc->Usage != InternalUsage)
		{
			__debugbreak();
		}
		if (pDesc->FVF != InternalFVF)
		{
			__debugbreak();
		}
		if (pDesc->Pool != InternalPool)
		{
			__debugbreak();
		}
		if (pDesc->Format != D3DFMT_VERTEXDATA)
		{
			__debugbreak();
		}
		if (pDesc->Type != D3DRTYPE_VERTEXBUFFER)
		{
			__debugbreak();
		}
	}
#endif

	pDesc->Size = InternalLength;
	pDesc->Usage = InternalUsage;
	pDesc->FVF = InternalFVF;
	pDesc->Pool = InternalPool;
	pDesc->Format = D3DFMT_VERTEXDATA;
	pDesc->Type = D3DRTYPE_VERTEXBUFFER;

	return S_OK;
}

```

`Software_d3d9/IDirect3DVertexBuffer9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

class IDirect3DVertexBuffer9Hook : public IDirect3DVertexBuffer9
{
public:
	IDirect3DVertexBuffer9Hook(LPDIRECT3DVERTEXBUFFER9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1),
		InternalLength(0), InternalUsage(UsageNone), InternalFVF(0x00000000), InternalPool(D3DPOOL_DEFAULT), lockCount(0), data(NULL), isSoftVertexBufferUP(false)
	{
#ifdef _DEBUG
		if (realObject)
			memcpy(&Name, &realObject->Name, (char*)&realObject - (char*)&Name);
		else
			memset(&Name, 0x00000000, (char*)&realObject - (char*)&Name);
#endif
	}

	inline LPDIRECT3DVERTEXBUFFER9 GetUnderlyingVertexBuffer(void) const
	{
		return realObject;
	}

	virtual ~IDirect3DVertexBuffer9Hook()
	{
#ifdef VERTEX_BUFFER_ALLOC_PAGE_NOACCESS
		if (!isSoftVertexBufferUP)
		{
			if (data)
			{
				VirtualFree(data, 0, MEM_RELEASE);
				data = NULL;
			}
		}
#else // #ifdef VERTEX_BUFFER_ALLOC_PAGE_NOACCESS
		if (!isSoftVertexBufferUP)
		{
			if (data)
			{
				free(data);
				data = NULL;
			}
		}
#endif
		if (isSoftVertexBufferUP)
			data = NULL;

#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DResource9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreePrivateData(THIS_ REFGUID refguid) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetPriority(THIS_ DWORD PriorityNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetPriority(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE PreLoad(THIS) override;
    virtual COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE GetType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Lock(THIS_ UINT OffsetToLock,UINT SizeToLock,void** ppbData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unlock(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDesc(THIS_ D3DVERTEXBUFFER_DESC *pDesc) override;

	void CreateVertexBuffer(UINT _Length, const DebuggableUsage _Usage, DWORD _FVF, D3DPOOL _Pool);

	inline void MarkSoftBufferUP(const bool isSoftUPVertexBuffer)
	{
		isSoftVertexBufferUP = isSoftUPVertexBuffer;
	}

	inline void SoftUPSetInternalPointer(const BYTE* const stream0BytesUP, const UINT BufferLengthBytes)
	{
#ifdef _DEBUG
		if (!isSoftVertexBufferUP)
		{
			__debugbreak(); // What are you doing calling this on a regular vertex buffer?
		}
		if (data != NULL)
		{
			__debugbreak(); // Probably forgot a reset somewhere!
		}
		if (stream0BytesUP == NULL)
		{
			__debugbreak(); // This should never happen, draw calls with NULL stream0UP data are invalid
		}
#endif
		data = (BYTE* const)stream0BytesUP;
		InternalLength = BufferLengthBytes;
	}

	inline void SoftUPResetInternalPointer(void)
	{
#ifdef _DEBUG
		if (!isSoftVertexBufferUP)
		{
			__debugbreak(); // What are you doing calling this on a regular vertex buffer?
		}
		if (data == NULL)
		{
			__debugbreak(); // You either did a reset twice in a row, or you forgot to set the pointer in the first place!
		}
#endif
		data = NULL;
		InternalLength = 0;
	}

	inline const BYTE* const GetInternalDataBuffer(void) const
	{
		return data;
	}

	inline const UINT GetInternalLength_Bytes(void) const
	{
		return InternalLength;
	}

	inline const DWORD GetInternalFVF(void) const
	{
		return InternalFVF;
	}

	inline const bool IsUnlocked(void) const
	{
		return lockCount == 0;
	}

protected:
	LPDIRECT3DVERTEXBUFFER9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

	UINT InternalLength;
	DebuggableUsage InternalUsage;
	DWORD InternalFVF;
	D3DPOOL InternalPool;

	long lockCount;
	bool isSoftVertexBufferUP; // If this is true, then the memory pointed to by the buffer is managed by the application and should not be modified or freed!

	BYTE* data;
};

```

`Software_d3d9/IDirect3DVertexDeclaration9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DVertexDeclaration9Hook.h"

static inline const bool operator==(const DebuggableD3DVERTEXELEMENT9& lhs, const DebuggableD3DVERTEXELEMENT9& rhs)
{
	return (lhs.Stream == rhs.Stream) && (lhs.Offset == rhs.Offset) && (lhs.Type == rhs.Type) && (lhs.Method == rhs.Method) && (lhs.Usage == rhs.Usage) && (lhs.UsageIndex == rhs.UsageIndex);
}

static inline const bool operator!=(const DebuggableD3DVERTEXELEMENT9& lhs, const DebuggableD3DVERTEXELEMENT9& rhs)
{
	return !(lhs == rhs);
}

void IDirect3DVertexDeclaration9Hook::CreateVertexDeclaration(const DebuggableD3DVERTEXELEMENT9* const pVertexElements, const debuggableFVF _vertDeclAutoCreatedFromFVF)
{
	if (!pVertexElements)
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return;
	}

	unsigned numElements = 0;
	static const DebuggableD3DVERTEXELEMENT9 endDecl = D3DDECL_END();
	while (pVertexElements[numElements++] != endDecl);

	elements.resize(numElements);
	memcpy(&elements.front(), pVertexElements, numElements * sizeof(DebuggableD3DVERTEXELEMENT9) );

	vertDeclAutoCreatedFromFVF = _vertDeclAutoCreatedFromFVF;

	// Compute skipVertexProcessing:
	skipVertexProcessing = false;
	for (unsigned x = 0; x < numElements; ++x)
	{
		if (elements[x].Usage == D3DDECLUSAGE_POSITIONT && elements[x].UsageIndex == 0)
		{
			skipVertexProcessing = true;
			foundPositionT0 = &elements[x];
			break;
		}
	}

	// Compute hasColor0 and hasColor1:
	for (unsigned x = 0; x < numElements; ++x)
	{
		const DebuggableD3DVERTEXELEMENT9& thisElement = elements[x];
		if (thisElement.Usage == D3DDECLUSAGE_COLOR)
		{
			if (thisElement.UsageIndex == 0)
				hasColor0 = true;
			else if (thisElement.UsageIndex == 1)
				hasColor1 = true;
		}
	}

	USHORT currentOffset = 0;

	{
		DebuggableD3DVERTEXELEMENT9 newElement = elements[0];
		newElement.Usage = D3DDECLUSAGE_POSITIONT;
		newElement.Type = D3DDECLTYPE_FLOAT4;
		newElement.Offset = 0;
		newElement.Stream = 0;
		vertShaderOutputElements.push_back(newElement);
		currentOffset += GetElementSizeFromType(newElement.Type);
	}

	for (unsigned x = 0; x < numElements; ++x)
	{
		const DebuggableD3DVERTEXELEMENT9& thisElement = elements[x];
		if (thisElement.Usage == D3DDECLUSAGE_POSITION || thisElement.Usage == D3DDECLUSAGE_POSITIONT)
			continue; // Skip these
		else
		{
			DebuggableD3DVERTEXELEMENT9 newElement = thisElement;
			newElement.Stream = 0;
			newElement.Offset = currentOffset;
			vertShaderOutputElements.push_back(newElement);
			currentOffset += GetElementSizeFromType(newElement.Type);
		}
	}

	vertShaderOutputElements.push_back(D3DDECL_END() );

	if (FAILED(parentDevice->GetUnderlyingDevice()->CreateVertexDeclaration( (const D3DVERTEXELEMENT9* const)&vertShaderOutputElements.front(), &vertShaderOutputDecl) ) )
	{
		__debugbreak();
	}

	ComputeVertexSizes();
}

void IDirect3DVertexDeclaration9Hook::ComputeVertexSizes()
{
	{
		UINT totalSize = 0;
		const unsigned numElements = elements.size();
		for (unsigned x = 0; x < numElements; ++x)
		{
			const DebuggableD3DVERTEXELEMENT9& thisElement = elements[x];
			if (thisElement.Type != MAXD3DDECLTYPE)
			{
				totalSize += GetElementSizeFromType(thisElement.Type);
			}
		}
		inVertexSize = totalSize;
	}

	{
		UINT totalSize = 0;
		const unsigned numElements = vertShaderOutputElements.size();
		for (unsigned x = 0; x < numElements; ++x)
		{
			const DebuggableD3DVERTEXELEMENT9& thisElement = vertShaderOutputElements[x];
			if (thisElement.Type != MAXD3DDECLTYPE)
			{
				totalSize += GetElementSizeFromType(thisElement.Type);
			}
		}
		outVertexSize = totalSize;
	}
}

const UINT IDirect3DVertexDeclaration9Hook::GetElementSizeFromType(const D3DDECLTYPE elementType)
{
	switch (elementType)
	{
	case D3DDECLTYPE_FLOAT1    :
		return sizeof(float);
	case D3DDECLTYPE_FLOAT2    :
		return 2 * sizeof(float);
	case D3DDECLTYPE_FLOAT3    :
		return 3 * sizeof(float);
	case D3DDECLTYPE_FLOAT4    :
		return 4 * sizeof(float);
	case D3DDECLTYPE_D3DCOLOR  :
		return sizeof(D3DCOLOR);		                      
	case D3DDECLTYPE_UBYTE4    :
	case D3DDECLTYPE_UBYTE4N   :
		return 4 * sizeof(BYTE);
	case D3DDECLTYPE_SHORT2    :
	case D3DDECLTYPE_SHORT2N   :
	case D3DDECLTYPE_USHORT2N  :
		return 2 * sizeof(SHORT);
	case D3DDECLTYPE_SHORT4    :
	case D3DDECLTYPE_SHORT4N   :
	case D3DDECLTYPE_USHORT4N  :
		return 4 * sizeof(SHORT);		
	case D3DDECLTYPE_UDEC3     :
	case D3DDECLTYPE_DEC3N     :
		return sizeof(DWORD);
	case D3DDECLTYPE_FLOAT16_2 :
		return 2 * sizeof(D3DXFLOAT16);
	case D3DDECLTYPE_FLOAT16_4 :
		return 4 * sizeof(D3DXFLOAT16);
	default:
	case D3DDECLTYPE_UNUSED    :
#ifdef _DEBUG
		__debugbreak();
#endif
		return 0;
	}
}

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexDeclaration9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DVertexDeclaration9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DVertexDeclaration9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Vertex Declaration %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DVertexDeclaration9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexDeclaration9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexDeclaration9Hook::GetDeclaration(THIS_ D3DVERTEXELEMENT9* pElement,UINT* pNumElements)
{
	HRESULT ret = realObject->GetDeclaration(pElement, pNumElements);
	return ret;
}

UINT IDirect3DVertexDeclaration9Hook::GetStream0Float4PositionTOffset(void) const
{
	const unsigned numOutputElements = vertShaderOutputElements.size();
	for (unsigned x = 0; x < numOutputElements; ++x)
	{
		const DebuggableD3DVERTEXELEMENT9& thisElement = vertShaderOutputElements[x];
		if (thisElement.Usage == D3DDECLUSAGE_POSITIONT && thisElement.Type == D3DDECLTYPE_FLOAT4 && thisElement.Stream == 0)
			return thisElement.Offset;
	}

	// Should never be here!
	__debugbreak();
	return 0;
}

// Returns true if vertex offset is found, otherwise returns false and then vertOffset and streamIndex are undefined
const bool IDirect3DVertexDeclaration9Hook::GetVertexOffset(unsigned& vertOffset, unsigned& streamIndex, const D3DDECLUSAGE usage, const unsigned usageIndex) const
{
	const DebuggableD3DVERTEXELEMENT9* const foundElement = GetVertexElement(usage, usageIndex);
	if (!foundElement)
	{
		vertOffset = 0;
		streamIndex = 0;
		return false;
	}
	else
	{
		vertOffset = foundElement->Offset;
		streamIndex = foundElement->Stream;
		return true;
	}
}

// Returns NULL if no such element is found
const DebuggableD3DVERTEXELEMENT9* const IDirect3DVertexDeclaration9Hook::GetVertexElement(const D3DDECLUSAGE usage, const unsigned usageIndex) const
{
	const unsigned numElements = elements.size();
	for (unsigned x = 0; x < numElements; ++x)
	{
		const DebuggableD3DVERTEXELEMENT9& thisElement = elements[x];
		if (thisElement.Usage == usage && thisElement.UsageIndex == usageIndex)
		{
			return &thisElement;
		}
	}

	return NULL;
}

// Returns NULL if no such element is found
const DebuggableD3DVERTEXELEMENT9* const IDirect3DVertexDeclaration9Hook::GetVertexElementOutput(const D3DDECLUSAGE usage, const unsigned usageIndex) const
{
	const unsigned numElements = vertShaderOutputElements.size();
	for (unsigned x = 0; x < numElements; ++x)
	{
		const DebuggableD3DVERTEXELEMENT9& thisElement = vertShaderOutputElements[x];
		if (thisElement.Usage == usage && thisElement.UsageIndex == usageIndex)
		{
			return &thisElement;
		}
	}

	return NULL;
}

```

`Software_d3d9/IDirect3DVertexDeclaration9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

class IDirect3DVertexDeclaration9Hook : public IDirect3DVertexDeclaration9
{
public:
	IDirect3DVertexDeclaration9Hook(LPDIRECT3DVERTEXDECLARATION9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1),
		inVertexSize(0), outVertexSize(0), foundPositionT0(NULL), skipVertexProcessing(false), hasColor0(false), hasColor1(false)
	{
		vertDeclAutoCreatedFromFVF.rawFVF_DWORD = 0x00000000;
#ifdef _DEBUG
		memcpy(&CreationCallStack, &realObject->CreationCallStack, (char*)&realObject - (char*)&CreationCallStack);
#endif
	}

	inline LPDIRECT3DVERTEXDECLARATION9 GetUnderlyingVertexDeclaration(void) const
	{
		return realObject;
	}

	LPDIRECT3DVERTEXDECLARATION9 GetUnderlyingPostTransformVertexDeclaration(void) const
	{
		return vertShaderOutputDecl;
	}

	virtual ~IDirect3DVertexDeclaration9Hook()
	{
		// TODO: Remove this vertex decl from the FVFToVertDeclCache when it gets fully released

#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) - (sizeof(elements) + sizeof(vertShaderOutputElements) ) );
#endif
	}

	const std::vector<DebuggableD3DVERTEXELEMENT9>& GetElementsInternal(void) const
	{
		return elements;
	}

	const std::vector<DebuggableD3DVERTEXELEMENT9>& GetOutputElementsInternal(void) const
	{
		return vertShaderOutputElements;
	}

	// Returns true if this vertex decl contains pretransformed vertices
	inline const bool SkipVertexProcessing(void) const
	{
		return skipVertexProcessing;
	}

	// This may return NULL in the case that this is not a "pre transformed" vertex decl
	inline const DebuggableD3DVERTEXELEMENT9* const GetPositionT0Element(void) const
	{
		return foundPositionT0;
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

	/*** IDirect3DVertexDeclaration9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDeclaration(THIS_ D3DVERTEXELEMENT9* pElement,UINT* pNumElements) override;

	void CreateVertexDeclaration(const DebuggableD3DVERTEXELEMENT9* const pVertexElements, const debuggableFVF _vertDeclAutoCreatedFromFVF);

	inline const UINT GetVertexSize(void) const
	{
		return inVertexSize;
	}

	inline const UINT GetPostTransformVertexSize(void) const
	{
		return outVertexSize;
	}

	static const UINT GetElementSizeFromType(const D3DDECLTYPE elementType);

	// Returns true if vertex offset is found, otherwise returns false and then vertOffset and streamIndex undefined
	const bool GetVertexOffset(unsigned& vertOffset, unsigned& streamIndex, const D3DDECLUSAGE usage, const unsigned usageIndex) const;

	// Returns NULL if no such element is found
	const DebuggableD3DVERTEXELEMENT9* const GetVertexElement(const D3DDECLUSAGE usage, const unsigned usageIndex) const;
	const DebuggableD3DVERTEXELEMENT9* const GetVertexElementOutput(const D3DDECLUSAGE usage, const unsigned usageIndex) const;

	UINT GetStream0Float4PositionTOffset(void) const;

	inline const bool GetHasCOLOR0(void) const
	{
		return hasColor0;
	}

	inline const bool GetHasCOLOR1(void) const
	{
		return hasColor1;
	}

protected:
	LPDIRECT3DVERTEXDECLARATION9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

	// This may be NULL for decl's that don't specify a POSITIONT0 element
	const DebuggableD3DVERTEXELEMENT9* foundPositionT0;

	// This is the case if someone passes in an element with POSITIONT in it
	bool skipVertexProcessing;

	// These two bools determine if the COLOR0 and COLOR1 semantics are present for this vertex decl
	bool hasColor0;
	bool hasColor1;

	debuggableFVF vertDeclAutoCreatedFromFVF;

	unsigned inVertexSize;
	unsigned outVertexSize;

	LPDIRECT3DVERTEXDECLARATION9 vertShaderOutputDecl;

	std::vector<DebuggableD3DVERTEXELEMENT9> elements;
	std::vector<DebuggableD3DVERTEXELEMENT9> vertShaderOutputElements;

	void ComputeVertexSizes();
};

```

`Software_d3d9/IDirect3DVertexShader9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DVertexShader9Hook.h"
#include "ShaderBase.h"
#include "ShaderJIT.h"

static std::vector<IDirect3DVertexShader9Hook*> aliveVertShaders;

void IDirect3DVertexShader9Hook::CreateVertexShader(const DWORD* const pFunction)
{
	if (!pFunction)
		return;

	ShaderInfo tempVertexShaderInfo;
	AnalyzeShader(pFunction, tempVertexShaderInfo
#ifdef _DEBUG
		,"NoneVS"
#endif
		);

	if (tempVertexShaderInfo.isPixelShader)
	{
		// This is not a vertex shader!
		__debugbreak();
	}

	switch (tempVertexShaderInfo.shaderMajorVersion)
	{
	case 1:
	case 2:
	case 3:
		// We're good!
		break;
	default:
		// This is not a valid D3D9 shader!
		{
			__debugbreak();
		}
		break;
	}

	shaderBytecode.resize(tempVertexShaderInfo.shaderLengthDWORDs);
	memcpy(&shaderBytecode.front(), pFunction, tempVertexShaderInfo.shaderLengthDWORDs * sizeof(DWORD) );

	// Bad hack to rebase all of the pointer offsets, fix plz!
	AnalyzeShader(&shaderBytecode.front(), vertexShaderInfo
#ifdef _DEBUG
		,"NoneVS"
#endif
		);

	if (tempVertexShaderInfo.shaderMajorVersion == 3)
	{
		const std::vector<DeclaredRegister>& declaredRegs = tempVertexShaderInfo.declaredRegisters;
		const unsigned numDeclaredRegs = declaredRegs.size();
#ifdef _DEBUG
		outPositionRegisterIndex = 0xFFFFFFFF;
#endif
		for (unsigned x = 0; x < numDeclaredRegs; ++x)
		{
			const DeclaredRegister& thisReg = declaredRegs[x];
			if (!thisReg.isOutputRegister)
				continue;
			if (thisReg.usageType == D3DDECLUSAGE_POSITION || thisReg.usageType == D3DDECLUSAGE_POSITIONT)
			{
				static const unsigned NUM_PRE_OT_REGISTERS = 3u; // This is the dedicated oPos, oFog, and oPts registers used by pre-vs_3_0 shader models
				outPositionRegisterIndex = NUM_PRE_OT_REGISTERS + thisReg.registerIndex;
				break;
			}
		}
#ifdef _DEBUG
		if (outPositionRegisterIndex == 0xFFFFFFFF)
		{
			__debugbreak(); // Output Position register not found!
		}
#endif
	}
	else
	{
		// For vertex shaders before version vs_3_0, this should always be the dedicated oPos output register
		outPositionRegisterIndex = 0;
	}

	parentDevice->LockDeviceCS();
	aliveVertShaders.push_back(this);
	parentDevice->UnlockDeviceCS();

	//JitLoadShader();
}

/*virtual*/ IDirect3DVertexShader9Hook::~IDirect3DVertexShader9Hook()
{
	parentDevice->LockDeviceCS();
	const unsigned numAliveShaders = aliveVertShaders.size();
	bool foundAndErased = false;
	for (unsigned x = 0; x < numAliveShaders; ++x)
	{
		if (aliveVertShaders[x] == this)
		{
			aliveVertShaders.erase(aliveVertShaders.begin() + x);
			foundAndErased = true;
			break;
		}
	}
#ifdef _DEBUG
	if (!foundAndErased)
	{
		__debugbreak(); // Should never be here!
	}
#endif
	parentDevice->UnlockDeviceCS();

	shaderBytecode.clear();
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
	memset(this, 0x00000000, sizeof(*this) - (sizeof(shaderBytecode) + sizeof(vertexShaderInfo) ) );
#endif
}

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexShader9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DVertexShader9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DVertexShader9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Vertex Shader %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DVertexShader9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexShader9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVertexShader9Hook::GetFunction(THIS_ void* pData,UINT* pSizeOfData)
{
	HRESULT ret = realObject->GetFunction(pData, pSizeOfData);
	return ret;
}

void IDirect3DVertexShader9Hook::JitLoadShader()
{
#ifdef FORCE_INTERPRETED_VERTEX_SHADER
	return;
#endif

	const char* const jitName = ConstructShaderJITName(vertexShaderInfo);
	char jitFilenameBuffer[MAX_PATH] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
	sprintf(jitFilenameBuffer, "%s\\%s.dll", shaderJITTempDirectory, jitName);
#pragma warning(pop)
	HMODULE hm = LoadLibraryA(jitFilenameBuffer);

	triedJit = true;

	static const char* const shaderMainExportName = "@VertexShaderMain@4";
	static const char* const shaderMainExportName4 = "@VertexShaderMain4@4";

	if (hm)
	{
		jitShaderMain = (VSEntry)GetProcAddress(hm, shaderMainExportName);
		jitShaderMain4 = (VSEntry)GetProcAddress(hm, shaderMainExportName4);
		if (!jitShaderMain)
		{
			DbgBreakPrint("Error: Cannot find VertexShaderMain in existing JIT DLL");
		} 
		else if (!jitShaderMain4)
		{
			DbgPrint("Warning: Cannot find VertexShaderMain4 in existing JIT DLL");
		}
	}
	else
	{
		if (!JITNewShader(vertexShaderInfo, jitName) )
		{
			DbgBreakPrint("Error: Failed to JIT Vertex Shader");
		}
		else
		{
			HMODULE hm2 = LoadLibraryA(jitFilenameBuffer);
			if (!hm2)
			{
				DbgBreakPrint("Error: Failed to load recently JIT'd Vertex Shader");
				return;
			}
			jitShaderMain = (VSEntry)GetProcAddress(hm2, shaderMainExportName);
			jitShaderMain4 = (VSEntry)GetProcAddress(hm2, shaderMainExportName4);
			if (!jitShaderMain)
			{
				DbgBreakPrint("Error: Cannot find VertexShaderMain in newly created JIT DLL");
				return;
			} 
			else if (!jitShaderMain4)
			{
				DbgPrint("Warning: Cannot find VertexShaderMain4 in newly created JIT DLL");
				return;
			}
		}
	}
}

```

`Software_d3d9/IDirect3DVertexShader9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"
#include "ShaderAnalysis.h"

class VShaderEngine;

class IDirect3DVertexShader9Hook : public IDirect3DVertexShader9
{
public:
	IDirect3DVertexShader9Hook(LPDIRECT3DVERTEXSHADER9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1), outPositionRegisterIndex(0), 
		jitShaderMain(NULL), jitShaderMain4(NULL), triedJit(false)
	{
#ifdef _DEBUG
		memcpy(&Version, &realObject->Version, (char*)&realObject - (char*)&Version);
#endif
	}

	inline LPDIRECT3DVERTEXSHADER9 GetUnderlyingVertexShader(void) const
	{
		return realObject;
	}

	virtual ~IDirect3DVertexShader9Hook();

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DVertexShader9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFunction(THIS_ void* pData,UINT* pSizeOfData) override;

	void CreateVertexShader(const DWORD* const pFunction);

	inline const ShaderInfo& GetShaderInfo() const
	{
		return vertexShaderInfo;
	}

	inline ShaderInfo& GetModifyShaderInfo()
	{
		return vertexShaderInfo;
	}

	inline const UINT GetOPosRegisterIndex(void) const
	{
		return outPositionRegisterIndex;
	}

	inline const UINT GetOPosOffset_Bytes(void) const
	{
		return GetOPosRegisterIndex() * sizeof(D3DXVECTOR4);
	}

	inline const D3DXVECTOR4& GetPosition(const VS_2_0_OutputRegisters& thisOutputRegisters) const
	{
		// Uhhhhhh, is this correct? Should we be checking vertex shader versions here before reaching in and grabbing a register?
		return ( (const D3DXVECTOR4* const)&thisOutputRegisters)[outPositionRegisterIndex];
	}

	inline D3DXVECTOR4& GetPosition(VS_2_0_OutputRegisters& thisOutputRegisters) const
	{
		// Uhhhhhh, is this correct? Should we be checking vertex shader versions here before reaching in and grabbing a register?
		return ( (D3DXVECTOR4* const)&thisOutputRegisters)[outPositionRegisterIndex];
	}

	inline void GetPosition4(const VS_2_0_OutputRegisters* (&thisOutputRegisters)[4], const D3DXVECTOR4* (&outPositionPtrs)[4]) const
	{
		// Uhhhhhh, is this correct? Should we be checking vertex shader versions here before reaching in and grabbing a register?
		outPositionPtrs[0] = ( (const D3DXVECTOR4* const)thisOutputRegisters[0]) + outPositionRegisterIndex;
		outPositionPtrs[1] = ( (const D3DXVECTOR4* const)thisOutputRegisters[1]) + outPositionRegisterIndex;
		outPositionPtrs[2] = ( (const D3DXVECTOR4* const)thisOutputRegisters[2]) + outPositionRegisterIndex;
		outPositionPtrs[3] = ( (const D3DXVECTOR4* const)thisOutputRegisters[3]) + outPositionRegisterIndex;
	}

	inline void GetPosition4(VS_2_0_OutputRegisters* (&thisOutputRegisters)[4], D3DXVECTOR4* (&outPositionPtrs)[4]) const
	{
		// Uhhhhhh, is this correct? Should we be checking vertex shader versions here before reaching in and grabbing a register?
		outPositionPtrs[0] = ( (D3DXVECTOR4* const)thisOutputRegisters[0]) + outPositionRegisterIndex;
		outPositionPtrs[1] = ( (D3DXVECTOR4* const)thisOutputRegisters[1]) + outPositionRegisterIndex;
		outPositionPtrs[2] = ( (D3DXVECTOR4* const)thisOutputRegisters[2]) + outPositionRegisterIndex;
		outPositionPtrs[3] = ( (D3DXVECTOR4* const)thisOutputRegisters[3]) + outPositionRegisterIndex;
	}

	void JitLoadShader();

protected:
	LPDIRECT3DVERTEXSHADER9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

public:
	typedef void (__fastcall *VSEntry)(VShaderEngine& ps);
	VSEntry jitShaderMain;
	VSEntry jitShaderMain4;

	bool triedJit;
protected:
	unsigned outPositionRegisterIndex;

	std::vector<DWORD> shaderBytecode;
	ShaderInfo vertexShaderInfo;
};

```

`Software_d3d9/IDirect3DVolume9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DVolume9Hook.h"

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolume9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DVolume9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DVolume9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Volume Surface %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}

/*** IDirect3DVolume9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolume9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolume9Hook::SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags)
{
	HRESULT ret = realObject->SetPrivateData(refguid, pData, SizeOfData, Flags);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolume9Hook::GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData)
{
	HRESULT ret = realObject->GetPrivateData(refguid, pData, pSizeOfData);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolume9Hook::FreePrivateData(THIS_ REFGUID refguid)
{
	HRESULT ret = realObject->FreePrivateData(refguid);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolume9Hook::GetContainer(THIS_ REFIID riid,void** ppContainer)
{
	HRESULT ret = realObject->GetContainer(riid, ppContainer);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolume9Hook::GetDesc(THIS_ D3DVOLUME_DESC *pDesc)
{
	HRESULT ret = realObject->GetDesc(pDesc);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolume9Hook::LockBox(THIS_ D3DLOCKED_BOX * pLockedVolume,CONST D3DBOX* pBox,DWORD Flags)
{
	HRESULT ret = realObject->LockBox(pLockedVolume, pBox, Flags);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolume9Hook::UnlockBox(THIS)
{
	HRESULT ret = realObject->UnlockBox();
	return ret;
}

```

`Software_d3d9/IDirect3DVolume9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

class IDirect3DVolume9Hook : public IDirect3DVolume9
{
public:
	IDirect3DVolume9Hook(LPDIRECT3DVOLUME9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1)
	{
#ifdef _DEBUG
		memcpy(&Name, &realObject->Name, (char*)&realObject - (char*)&Name);
#endif
	}

	virtual ~IDirect3DVolume9Hook()
	{
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DVolume9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreePrivateData(THIS_ REFGUID refguid) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetContainer(THIS_ REFIID riid,void** ppContainer) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDesc(THIS_ D3DVOLUME_DESC *pDesc) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LockBox(THIS_ D3DLOCKED_BOX * pLockedVolume,CONST D3DBOX* pBox,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UnlockBox(THIS) override;

protected:
	LPDIRECT3DVOLUME9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;
};

```

`Software_d3d9/IDirect3DVolumeTexture9Hook.cpp`:

```cpp
#pragma once

#include "IDirect3DVolumeTexture9Hook.h"

/*** IUnknown methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::QueryInterface(THIS_ REFIID riid, void** ppvObj)
{
	HRESULT ret = realObject->QueryInterface(riid, ppvObj);
	if (ret == NOERROR)
	{
		*ppvObj = this;
		AddRef();
	}
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::AddRef(THIS)
{
	ULONG ret = realObject->AddRef();
	++refCount;
	return ret;
}

COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::Release(THIS)
{
	ULONG ret = realObject->Release();
	if (--refCount == 0)
	{
#ifdef DEBUGPRINT_D3DHOOKOBJECT_FULLRELEASES
		char printBuffer[128] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
		sprintf(printBuffer, "Fully releasing hooked Volume Texture %p\n", this);
#pragma warning(pop)
		OutputDebugStringA(printBuffer);
#endif
		delete this;
	}
	return ret;
}


/*** IDirect3DBaseTexture9 methods ***/
COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::GetDevice(THIS_ IDirect3DDevice9** ppDevice)
{
	LPDIRECT3DDEVICE9 realD3D9dev = NULL;
	HRESULT ret = realObject->GetDevice(&realD3D9dev);
	if (FAILED(ret) )
	{
		*ppDevice = NULL;
		return ret;
	}

	// Check that the parentHook's underlying IDirect3DDevice9* matches the realD3D9dev pointer
	if (parentDevice->GetUnderlyingDevice() != realD3D9dev)
	{
		DbgBreakPrint("Error: Unknown d3d9 device hook detected!");
	}
	parentDevice->AddRef(); // Super important to increment the ref-count here, otherwise our parent object will get destroyed when Release() is called on it!

	*ppDevice = parentDevice;
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags)
{
	HRESULT ret = realObject->SetPrivateData(refguid, pData, SizeOfData, Flags);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData)
{
	HRESULT ret = realObject->GetPrivateData(refguid, pData, pSizeOfData);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::FreePrivateData(THIS_ REFGUID refguid)
{
	HRESULT ret = realObject->FreePrivateData(refguid);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::SetPriority(THIS_ DWORD PriorityNew)
{
	DWORD ret = realObject->SetPriority(PriorityNew);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::GetPriority(THIS)
{
	DWORD ret = realObject->GetPriority();
	return ret;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::PreLoad(THIS)
{
	realObject->PreLoad();
}

COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::GetType(THIS)
{
	D3DRESOURCETYPE ret = realObject->GetType();
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::SetLOD(THIS_ DWORD LODNew)
{
	DWORD ret = realObject->SetLOD(LODNew);
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::GetLOD(THIS)
{
	DWORD ret = realObject->GetLOD();
	return ret;
}

COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::GetLevelCount(THIS)
{
	DWORD ret = realObject->GetLevelCount();
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::SetAutoGenFilterType(THIS_ D3DTEXTUREFILTERTYPE FilterType)
{
	HRESULT ret = realObject->SetAutoGenFilterType(FilterType);
	return ret;
}

COM_DECLSPEC_NOTHROW D3DTEXTUREFILTERTYPE STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::GetAutoGenFilterType(THIS)
{
	D3DTEXTUREFILTERTYPE ret = realObject->GetAutoGenFilterType();
	return ret;
}

COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::GenerateMipSubLevels(THIS)
{
	realObject->GenerateMipSubLevels();

	if (!(InternalUsage & D3DUSAGE_AUTOGENMIPMAP) )
		return;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::GetLevelDesc(THIS_ UINT Level,D3DVOLUME_DESC *pDesc)
{
	HRESULT ret = realObject->GetLevelDesc(Level, pDesc);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::GetVolumeLevel(THIS_ UINT Level,IDirect3DVolume9** ppVolumeLevel)
{
	HRESULT ret = realObject->GetVolumeLevel(Level, ppVolumeLevel);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::LockBox(THIS_ UINT Level,D3DLOCKED_BOX* pLockedVolume,CONST D3DBOX* pBox,DWORD Flags)
{
	HRESULT ret = realObject->LockBox(Level, pLockedVolume, pBox, Flags);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::UnlockBox(THIS_ UINT Level)
{
	HRESULT ret = realObject->UnlockBox(Level);
	return ret;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IDirect3DVolumeTexture9Hook::AddDirtyBox(THIS_ CONST D3DBOX* pDirtyBox)
{
	HRESULT ret = realObject->AddDirtyBox(pDirtyBox);
	return ret;
}

void IDirect3DVolumeTexture9Hook::CreateVolumeTexture(UINT _Width, UINT _Height, UINT _Depth, UINT _Levels, DebuggableUsage _Usage, D3DFORMAT _Format, D3DPOOL _Pool)
{
	InternalWidth = _Width;
	InternalHeight = _Height;
	InternalDepth = _Depth;
	InternalLevels = _Levels;
	InternalUsage = _Usage;
	InternalFormat = _Format;
	InternalPool = _Pool;
}

```

`Software_d3d9/IDirect3DVolumeTexture9Hook.h`:

```h
#pragma once

#include "IDirect3DDevice9Hook.h"

class IDirect3DVolumeTexture9Hook : public IDirect3DVolumeTexture9
{
public:
	IDirect3DVolumeTexture9Hook(LPDIRECT3DVOLUMETEXTURE9 _realObject, IDirect3DDevice9Hook* _parentDevice) : realObject(_realObject), parentDevice(_parentDevice), refCount(1)
	{
#ifdef _DEBUG
		memcpy(&Name, &realObject->Name, (char*)&realObject - (char*)&Name);
#endif
	}

	virtual ~IDirect3DVolumeTexture9Hook()
	{
#ifdef WIPE_ON_DESTRUCT_D3DHOOKOBJECT
		memset(this, 0x00000000, sizeof(*this) );
#endif
	}

	/*** IUnknown methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, void** ppvObj) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE AddRef(THIS) override;
    virtual COM_DECLSPEC_NOTHROW ULONG STDMETHODCALLTYPE Release(THIS) override;

    /*** IDirect3DBaseTexture9 methods ***/
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDevice(THIS_ IDirect3DDevice9** ppDevice) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPrivateData(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPrivateData(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreePrivateData(THIS_ REFGUID refguid) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetPriority(THIS_ DWORD PriorityNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetPriority(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE PreLoad(THIS) override;
    virtual COM_DECLSPEC_NOTHROW D3DRESOURCETYPE STDMETHODCALLTYPE GetType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE SetLOD(THIS_ DWORD LODNew) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetLOD(THIS) override;
    virtual COM_DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE GetLevelCount(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetAutoGenFilterType(THIS_ D3DTEXTUREFILTERTYPE FilterType) override;
    virtual COM_DECLSPEC_NOTHROW D3DTEXTUREFILTERTYPE STDMETHODCALLTYPE GetAutoGenFilterType(THIS) override;
    virtual COM_DECLSPEC_NOTHROW void STDMETHODCALLTYPE GenerateMipSubLevels(THIS) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLevelDesc(THIS_ UINT Level,D3DVOLUME_DESC *pDesc) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVolumeLevel(THIS_ UINT Level,IDirect3DVolume9** ppVolumeLevel) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LockBox(THIS_ UINT Level,D3DLOCKED_BOX* pLockedVolume,CONST D3DBOX* pBox,DWORD Flags) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UnlockBox(THIS_ UINT Level) override;
    virtual COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AddDirtyBox(THIS_ CONST D3DBOX* pDirtyBox) override;

	inline LPDIRECT3DVOLUMETEXTURE9 GetUnderlyingVolumeTexture(void) const
	{
		return realObject;
	}

	inline const UINT GetInternalWidth() const
	{
		return InternalWidth;
	}

	inline const UINT GetInternalHeight() const
	{
		return InternalHeight;
	}

	inline const UINT GetInternalDepth() const
	{
		return InternalDepth;
	}

	inline const D3DFORMAT GetInternalFormat() const
	{
		return InternalFormat;
	}

	const UINT GetInternalMipLevels() const
	{
		return InternalLevels;
	}

	const DebuggableUsage GetInternalUsage() const
	{
		return InternalUsage;
	}

	const D3DPOOL GetInternalPool() const
	{
		return InternalPool;
	}

	void CreateVolumeTexture(UINT _Width, UINT _Height, UINT _Depth, UINT _Levels, DebuggableUsage _Usage, D3DFORMAT _Format, D3DPOOL _Pool);

protected:
	LPDIRECT3DVOLUMETEXTURE9 realObject;
	IDirect3DDevice9Hook* parentDevice;
	unsigned __int64 refCount;

	UINT InternalWidth;
	UINT InternalHeight;
	UINT InternalDepth;
	UINT InternalLevels;
	DebuggableUsage InternalUsage;
	D3DFORMAT InternalFormat;
	D3DPOOL InternalPool;
};

```

`Software_d3d9/Overlay/DebugOverlay.cpp`:

```cpp
#include "DebugOverlay.h"

#include "..\IDirect3DDevice9Hook.h"
#include "..\IDirect3DStateBlock9Hook.h"
#include "..\resource.h"
#include <vector>
#include <map>

extern HINSTANCE hLThisDLL;

#pragma pack(push)
#pragma pack(1)
struct tgaHeader
{
	BYTE idlength;
	BYTE colormaptype;
	BYTE datatypecode;
	USHORT origin;
	USHORT length;
	BYTE colordepth;
	SHORT x_origin;
	SHORT y_origin;
	SHORT width;
	SHORT height;
	BYTE bitsperpixel;
	char imageDescriptor[1];
};
static_assert(sizeof(tgaHeader) == 18, "Error: Unexpected header size!");
#pragma pack(pop)

static const UpdateAndDrawOverlayFunc OverlayUpdateFuncs[overlay_NUM_SCREENS] =
{
	UpdateAndDrawOverlay_WelcomeScreen, // overlay_welcomeScreen
	UpdateAndDrawOverlay_DeviceState // overlay_deviceState
};

struct perDeviceResources
{
	perDeviceResources() : fontMapTexture(NULL), stateBlock(NULL), state(overlay_uninitialized)
	{
		for (unsigned x = 0; x < overlay_NUM_SCREENS; ++x)
			perScreenState[x] = NULL;
	}

	LPDIRECT3DTEXTURE9 fontMapTexture;
	LPDIRECT3DSTATEBLOCK9 stateBlock;
	overlayState state;
	void* perScreenState[overlay_NUM_SCREENS];
};

static std::map<const IDirect3DDevice9Hook*, perDeviceResources> overlayEnabledDevicesSet;

struct vert2D
{
	D3DXVECTOR4 xyzRhw;
	D3DXVECTOR2 texCoord;
};

perDeviceResources* const GetPerDeviceResources(const IDirect3DDevice9Hook* const hookDev)
{
	std::map<const IDirect3DDevice9Hook*, perDeviceResources>::iterator findDev = overlayEnabledDevicesSet.find(hookDev);
	if (findDev == overlayEnabledDevicesSet.end() )
		return NULL;
	return &(findDev->second);
}

static inline const bool IsDeviceOverlayEnabled(const IDirect3DDevice9Hook* const hookDev)
{
	return GetPerDeviceResources(hookDev) != NULL;
}

static inline const bool CheckForOverlayEnableHotkey()
{
	return (GetAsyncKeyState(VK_SHIFT) & 0x8000) && (GetAsyncKeyState(VK_CONTROL) & 0x8000) && (GetAsyncKeyState(VK_F9) & 0x8000);
}

static inline const bool CheckForOverlayDisableHotkey()
{
	return (GetAsyncKeyState(VK_SHIFT) & 0x8000) && (GetAsyncKeyState(VK_CONTROL) & 0x8000) && (GetAsyncKeyState(VK_F8) & 0x8000);
}

static inline void InitializeOverlayResourcesForDevice(IDirect3DDevice9Hook* const hookDev, perDeviceResources& thisResources)
{
	if (thisResources.stateBlock != NULL)
	{
		thisResources.stateBlock->Release();
		thisResources.stateBlock = NULL;
	}

	if (thisResources.fontMapTexture != NULL)
	{
		thisResources.fontMapTexture->Release();
		thisResources.fontMapTexture = NULL;
	}

	if (FAILED(hookDev->CreateStateBlock(D3DSBT_ALL, &thisResources.stateBlock) ) )
	{
#ifdef _DEBUG
		__debugbreak(); // This shouldn't fail if the device is in a presentable state
#endif
		return;
	}

#pragma warning(push)
#pragma warning(disable:4302) // warning C4302: 'type cast': truncation from 'LPSTR' to 'WORD'
	HRSRC bitmapResource = FindResourceA(hLThisDLL, MAKEINTRESOURCEA(IDR_TGA1), "TGA");
#pragma warning(pop)
	if (!bitmapResource)
	{
#ifdef _DEBUG
		__debugbreak(); // This shouldn't fail if the device is in a presentable state
#endif
		return;
	}

	HGLOBAL loadedResource = LoadResource(hLThisDLL, bitmapResource);
	if (!loadedResource)
	{
#ifdef _DEBUG
		__debugbreak(); // This shouldn't fail if the device is in a presentable state
#endif
		return;
	}

	const unsigned resourceSize = SizeofResource(hLThisDLL, bitmapResource);
	if (resourceSize == 0)
	{
#ifdef _DEBUG
		__debugbreak(); // This shouldn't fail if the device is in a presentable state
#endif
		return;
	}

	const unsigned char* const resourceBytes = (const unsigned char* const)LockResource(loadedResource);
	if (!resourceBytes)
	{
#ifdef _DEBUG
		__debugbreak(); // This shouldn't fail if the device is in a presentable state
#endif
		return;
	}

	const tgaHeader* const headerPtr = (const tgaHeader* const)resourceBytes;
	if (headerPtr->width < 1 || headerPtr->height < 1 || headerPtr->bitsperpixel != 32)
	{
#ifdef _DEBUG
		__debugbreak(); // Somehow we've embedded a bad resource!
#endif
		return;
	}

	if (headerPtr->width != 256 || headerPtr->height != 256)
	{
#ifdef _DEBUG
		__debugbreak(); // This will cause huge problems when we get to font rendering, so this is bad!
#endif
		return;
	}

	if (FAILED(hookDev->CreateTexture(headerPtr->width, headerPtr->height, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &thisResources.fontMapTexture, NULL) ) )
	{
#ifdef _DEBUG
		__debugbreak(); // This shouldn't fail if the device is in a presentable state
#endif
		return;
	}

	D3DLOCKED_RECT d3dlr = {0};
	if (FAILED(thisResources.fontMapTexture->LockRect(0, &d3dlr, NULL, 0) ) )
	{
#ifdef _DEBUG
		__debugbreak(); // This shouldn't fail if the device is in a presentable state
#endif
		return;
	}

#ifdef _DEBUG
	if (d3dlr.Pitch != headerPtr->width * sizeof(D3DCOLOR) )
	{
		__debugbreak(); // Unexpected nonlinear pitch!
	}
#endif

	const D3DCOLOR* const startOfImageData = (const D3DCOLOR* const)(headerPtr->idlength + (const BYTE* const)(headerPtr + 1) );

	D3DCOLOR* const lockedTexels = (D3DCOLOR* const)d3dlr.pBits;
	for (int y = 0; y < headerPtr->height; ++y)
	{
		for (int x = 0; x < headerPtr->width; ++x)
		{
			const D3DCOLOR thisFileColor = startOfImageData[x + y * headerPtr->width];
			D3DCOLOR& lockedTexelColor = lockedTexels[x + y * headerPtr->width];

			// Color keying magenta to transparent black
			if (thisFileColor == D3DCOLOR_ARGB(255, 255, 0, 255) )
				lockedTexelColor = D3DCOLOR_ARGB(0, 0, 0, 0);
			else
				lockedTexelColor = thisFileColor;
		}
	}

	if (FAILED(thisResources.fontMapTexture->UnlockRect(0) ) )
	{
#ifdef _DEBUG
		__debugbreak(); // This shouldn't fail if the device is in a presentable state
#endif
		return;
	}

	thisResources.state = overlay_welcomeScreen;
}

static inline const bool IsOverlayStateInitialized(const perDeviceResources& thisResources)
{
	return thisResources.state >= 0;
}

void UpdateOverlay(class IDirect3DDevice9Hook* hookDev)
{
	if (!hookDev)
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return;
	}

	if (!IsDeviceOverlayEnabled(hookDev) )
	{
		if (CheckForOverlayEnableHotkey() )
		{
			overlayEnabledDevicesSet.insert(std::make_pair(hookDev, perDeviceResources() ) );
		}
		else
			return;
	}
	else
	{
		if (CheckForOverlayDisableHotkey() )
		{
			DeleteOverlay(hookDev);
			return;
		}
	}

	perDeviceResources* const thisDeviceResources = GetPerDeviceResources(hookDev);
	if (thisDeviceResources == NULL)
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return;
	}

	if (!IsOverlayStateInitialized(*thisDeviceResources) )
	{
		InitializeOverlayResourcesForDevice(hookDev, *thisDeviceResources);
		if (!IsOverlayStateInitialized(*thisDeviceResources) )
			return;
	}

	thisDeviceResources->stateBlock->Capture();

	(OverlayUpdateFuncs[thisDeviceResources->state])(hookDev);

	thisDeviceResources->stateBlock->Apply();
}

void OverlayDrawString(class IDirect3DDevice9Hook* const hookDev, const char* const str, const unsigned xLeftChars, const unsigned yTopChars, const unsigned long color /*= 0xFFFFFFFF*/)
{
	if (!hookDev)
		return;

	if (!str)
		return;

	const unsigned len = strlen(str);
	if (!len)
		return;

	D3DVIEWPORT9 viewport = {0};
	if (FAILED(hookDev->GetViewport(&viewport) ) )
		return;

	if (viewport.Width < 1 || viewport.Height < 1)
		return;

	const unsigned maxViewportLine = viewport.Height / textCharHeight;

	// Don't draw lines that are off the bottom edge of the screen, it's just a waste of draw calls!
	if (yTopChars >= maxViewportLine)
		return;

	static std::vector<vert2D> stringVerts;
	stringVerts.clear();

	static std::vector<unsigned> stringIndices;
	stringIndices.clear();

	unsigned currentRowX = xLeftChars * textCharWidth;
	unsigned currentRowY = yTopChars * textCharHeight;

	unsigned numUnprintedCharacters = 0;

	stringVerts.resize(len * 4);
	stringIndices.reserve(len * 6);
	for (unsigned x = 0; x < len; ++x)
	{
		const char thisChar = str[x];

		if (thisChar == '\n')
		{
			currentRowX = xLeftChars * textCharWidth;
			currentRowY += textCharHeight;
			++numUnprintedCharacters;
			continue;
		}
		else if (thisChar == ' ')
		{
			currentRowX += textCharWidth;
			++numUnprintedCharacters;
			continue;
		}

		const float fontMapCharX = (thisChar % 16) / 16.0f;
		const float fontMapCharY = (thisChar / 16) / 16.0f;

		const unsigned thisPrintedCharIndex = x - numUnprintedCharacters;

		for (unsigned y = 0; y < 4; ++y)
		{
			vert2D& thisVert = stringVerts[thisPrintedCharIndex * 4 + y];

			const float cornerCoordNormalizedX = (const float)(y & 0x1);
			const float cornerCoordNormalizedY = (const float)( (y >> 1) & 0x1);

			thisVert.texCoord.x = cornerCoordNormalizedX / 16.0f + fontMapCharX;
			thisVert.texCoord.y = cornerCoordNormalizedY / 16.0f + fontMapCharY;

			thisVert.xyzRhw.x = cornerCoordNormalizedX * (const float)textCharWidth + currentRowX - 0.5f;
			thisVert.xyzRhw.y = cornerCoordNormalizedY * (const float)textCharHeight + currentRowY - 0.5f;
			thisVert.xyzRhw.z = 0.0f;
			thisVert.xyzRhw.w = 1.0f;
		}

		stringIndices.push_back(thisPrintedCharIndex * 4 + 0);
		stringIndices.push_back(thisPrintedCharIndex * 4 + 1);
		stringIndices.push_back(thisPrintedCharIndex * 4 + 2);
		stringIndices.push_back(thisPrintedCharIndex * 4 + 1);
		stringIndices.push_back(thisPrintedCharIndex * 4 + 3);
		stringIndices.push_back(thisPrintedCharIndex * 4 + 2);

		currentRowX += textCharWidth;
	}

	const unsigned numPrintedCharacters = len - numUnprintedCharacters;
	if (numPrintedCharacters == 0)
		return;

	hookDev->SetRenderState(D3DRS_TEXTUREFACTOR, color);
	hookDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, numPrintedCharacters * 4, numPrintedCharacters * 2, &stringIndices.front(), D3DFMT_INDEX32, &stringVerts.front(), sizeof(vert2D) );
}

void OverlayDrawPrintString(class IDirect3DDevice9Hook* const hookDev, const unsigned xLeftChars, const unsigned yTopChars, const unsigned long color, const char* const formatStr, ...)
{
	va_list printArgs;
	va_start(printArgs, formatStr);

#pragma warning(push)
#pragma warning(disable:4996)
	char printfBuffer[4096];
	const int len = vsprintf(printfBuffer, formatStr, printArgs);
#pragma warning(pop)
	va_end(printArgs);

	if (len < 1)
		return;

	OverlayDrawString(hookDev, printfBuffer, xLeftChars, yTopChars, color);
}

void OverlaySetDeviceStateForText(class IDirect3DDevice9Hook* const hookDev)
{
	const perDeviceResources* const thisDeviceResources = GetPerDeviceResources(hookDev);
	if (thisDeviceResources == NULL)
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return;
	}

	LPDIRECT3DSURFACE9 backbufferSurf = NULL;
	D3DSURFACE_DESC backbufferDesc = {};
	hookDev->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &backbufferSurf);
	backbufferSurf->GetDesc(&backbufferDesc);
	backbufferSurf->Release();
	backbufferSurf = NULL;

	// Setup default full-screen scissor rect:
	RECT scissorRect = {0};
	scissorRect.right = backbufferDesc.Width;
	scissorRect.bottom = backbufferDesc.Height;
	hookDev->SetScissorRect(&scissorRect);

	// Setup default full-screen viewport:
	D3DVIEWPORT9 viewport = {0};
	viewport.Width = backbufferDesc.Width;
	viewport.Height = backbufferDesc.Height;
	viewport.MaxZ = 1.0f;
	hookDev->SetViewport(&viewport);

	// Setup our FVF and shaders for text rendering:
	hookDev->SetFVF(D3DFVF_XYZRHW | D3DFVF_TEX1);
	hookDev->SetPixelShader(NULL);
	hookDev->SetVertexShader(NULL);

	// Configure a bunch of renderstates back to their default values:
	hookDev->SetRenderState(D3DRS_CLIPPLANEENABLE, 0x00000000); // Disable all clipping planes
	hookDev->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA);
	hookDev->SetRenderState(D3DRS_LIGHTING, TRUE);
	hookDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_COLORVERTEX, FALSE);
	hookDev->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	hookDev->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
	hookDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_LASTPIXEL, TRUE);
	hookDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	hookDev->SetRenderState(D3DRS_DITHERENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_RANGEFOGENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_CLIPPING, TRUE);
	hookDev->SetRenderState(D3DRS_VERTEXBLEND, D3DVBF_DISABLE);
	hookDev->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_POINTSCALEENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
	hookDev->SetRenderState(D3DRS_MULTISAMPLEMASK, 0xFFFFFFFF);
	hookDev->SetRenderState(D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE);
	hookDev->SetRenderState(D3DRS_ENABLEADAPTIVETESSELLATION, FALSE);
	hookDev->SetRenderState(D3DRS_SLOPESCALEDEPTHBIAS, 0x00000000);
	hookDev->SetRenderState(D3DRS_DEPTHBIAS, 0x00000000);
	hookDev->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);

	// Configure material states:
	hookDev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL);
	hookDev->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_MATERIAL);
	hookDev->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_MATERIAL);
	hookDev->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
	hookDev->SetRenderState(D3DRS_AMBIENT, D3DCOLOR_ARGB(255, 255, 255, 255) );
	D3DMATERIAL9 textMaterial = {0};
	textMaterial.Ambient = { 1.0f, 1.0f, 1.0f, 1.0f };
	textMaterial.Diffuse = { 1.0f, 1.0f, 1.0f, 1.0f };
	textMaterial.Specular = { 1.0f, 1.0f, 1.0f, 1.0f };
	textMaterial.Emissive = { 0.0f, 0.0f, 0.0f, 0.0f };
	textMaterial.Power = 0.0f;
	hookDev->SetMaterial(&textMaterial);

	// Configure alpha-blend for alpha blending mode:
	hookDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	hookDev->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
	hookDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	hookDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	hookDev->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, FALSE);

	// Setup sampler states for text rendering:
	hookDev->SetTexture(0, thisDeviceResources->fontMapTexture);
	hookDev->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
	hookDev->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
	hookDev->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_NONE);
	hookDev->SetSamplerState(0, D3DSAMP_MAXANISOTROPY, 1);

	// Configure texture stage states for text rendering:
	hookDev->SetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_ARGB(255, 255, 255, 255) );
	hookDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
	hookDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
	hookDev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);
	hookDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	hookDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR);
	hookDev->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);
	hookDev->SetTextureStageState(0, D3DTSS_RESULTARG, D3DTA_CURRENT);
	hookDev->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
	hookDev->SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
}

void DeleteOverlay(const class IDirect3DDevice9Hook* const hookDev)
{
	std::map<const IDirect3DDevice9Hook*, perDeviceResources>::iterator foundIt = overlayEnabledDevicesSet.find(hookDev);
	if (foundIt == overlayEnabledDevicesSet.end() )
		return; // This is okay, we may have a device that never created an overlay

	foundIt->second.fontMapTexture->Release();
	foundIt->second.stateBlock->Release();
	overlayEnabledDevicesSet.erase(foundIt);
}

void ResetOverlay(const class IDirect3DDevice9Hook* const hookDev)
{
	DeleteOverlay(hookDev);
}

void SetOverlayScreenState(const class IDirect3DDevice9Hook* const hookDev, const overlayState newState)
{
	std::map<const IDirect3DDevice9Hook*, perDeviceResources>::iterator foundIt = overlayEnabledDevicesSet.find(hookDev);
	if (foundIt == overlayEnabledDevicesSet.end() )
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return; // Skip setting overlay state for uncreated overlays
	}

	foundIt->second.state = newState;
}

void SetOverlayPerScreenData(const class IDirect3DDevice9Hook* const hookDev, void* const newScreenData)
{
	std::map<const IDirect3DDevice9Hook*, perDeviceResources>::iterator foundIt = overlayEnabledDevicesSet.find(hookDev);
	if (foundIt == overlayEnabledDevicesSet.end() )
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return; // Skip setting per-screen data for uncreated overlays
	}

	perDeviceResources& thisDeviceResources = foundIt->second;
	if (IsOverlayStateInitialized(thisDeviceResources) )
	{
		thisDeviceResources.perScreenState[thisDeviceResources.state] = newScreenData;
	}
}

void* const GetOverlayPerScreenData(const class IDirect3DDevice9Hook* const hookDev)
{
	std::map<const IDirect3DDevice9Hook*, perDeviceResources>::iterator foundIt = overlayEnabledDevicesSet.find(hookDev);
	if (foundIt == overlayEnabledDevicesSet.end() )
	{
#ifdef _DEBUG
		__debugbreak();
#endif
		return NULL; // Skip setting per-screen data for uncreated overlays
	}

	const perDeviceResources& thisDeviceResources = foundIt->second;
	if (IsOverlayStateInitialized(thisDeviceResources) )
		return thisDeviceResources.perScreenState[thisDeviceResources.state];
	else
		return NULL;
}

```

`Software_d3d9/Overlay/DebugOverlay.h`:

```h
#pragma once

enum overlayState
{
	overlay_uninitialized = -1,
	overlay_welcomeScreen = 0,
	overlay_deviceState = 1,

	// This enum member must always be last
	overlay_NUM_SCREENS
};

static const unsigned textCharWidth = 12u;
static const unsigned textCharHeight = textCharWidth;

typedef void (*UpdateAndDrawOverlayFunc)(class IDirect3DDevice9Hook* const hookDev);

void UpdateOverlay(class IDirect3DDevice9Hook* const hookDev);
void DeleteOverlay(const class IDirect3DDevice9Hook* const hookDev);
void ResetOverlay(const class IDirect3DDevice9Hook* const hookDev);

void SetOverlayScreenState(const class IDirect3DDevice9Hook* const hookDev, const overlayState newState);
void SetOverlayPerScreenData(const class IDirect3DDevice9Hook* const hookDev, void* const newScreenData);
void* const GetOverlayPerScreenData(const class IDirect3DDevice9Hook* const hookDev);

void OverlaySetDeviceStateForText(class IDirect3DDevice9Hook* const hookDev);
void OverlayDrawString(class IDirect3DDevice9Hook* const hookDev, const char* const str, const unsigned xLeftChars, const unsigned yTopChars, const unsigned long color = 0xFFFFFFFF);
void OverlayDrawPrintString(class IDirect3DDevice9Hook* const hookDev, const unsigned xLeftChars, const unsigned yTopChars, const unsigned long color, const char* const formatStr, ...);

// Add screen-specific overlay functions here:
void UpdateAndDrawOverlay_WelcomeScreen(class IDirect3DDevice9Hook* const hookDev);
void UpdateAndDrawOverlay_DeviceState(class IDirect3DDevice9Hook* const hookDev);

```

`Software_d3d9/Overlay/Overlay_DeviceState.cpp`:

```cpp
#include "DebugOverlay.h"
#include "..\IDirect3DDevice9Hook.h"
#include "..\IDirect3DTexture9Hook.h"
#include "..\IDirect3DCubeTexture9Hook.h"
#include "..\IDirect3DVolumeTexture9Hook.h"
#include "..\IDirect3DSurface9Hook.h"
#include "..\IDirect3DIndexBuffer9Hook.h"
#include "..\IDirect3DVertexBuffer9Hook.h"
#include "..\IDirect3DVertexDeclaration9Hook.h"

static const D3DCOLOR stateEnabledColor = D3DCOLOR_ARGB(255, 255, 255, 255);
static const D3DCOLOR stateDisabledColor = D3DCOLOR_ARGB(255, 160, 160, 160);
static const D3DCOLOR stateEnabledWarningColor = D3DCOLOR_ARGB(255, 255, 255, 0);
static const D3DCOLOR stateDisabledWarningColor = D3DCOLOR_ARGB(255, 160, 160, 0);

enum deviceStatePage : unsigned char
{
	deviceGeneralState = 0,
	lightState,
	viewportScissorBackbufferState,
	fogState,
	inputAssemblerState,
	tessellationState,
	depthStencilState,
	outputState,
	textureStageStates,
	samplerStates,
	textureState,
	materialLightingState,
	transformsState,
	vsConstantsState,
	psConstantsState,

	MAX_NUM_STATE_PAGES // This must always be last
};

static const char* const deviceStatePageNames[] =
{
	"General",
	"Lights",
	"View/Scissor",
	"Fog",
	"IA",
	"Tess",
	"Depth-Stencil",
	"Output",
	"TexStageStates",
	"Samplers",
	"Textures",
	"Lighting/Material",
	"Transforms",
	"VS Constants",
	"PS Constants"
};
static_assert(ARRAYSIZE(deviceStatePageNames) == MAX_NUM_STATE_PAGES, "Error: Missing page name string table entries!");

typedef void (*DrawFunctionType)(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);

void DrawDeviceGeneral(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawLightState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawViewportScissorBackbufferState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawFogState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawInputAssemblerState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawTessellationState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawDepthStencilState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawOutputState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawTextureStageStates(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawSamplerStates(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawTextureState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawMaterialLightingState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawTransformsState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawVSConstantsState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);
void DrawPSConstantsState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset);

static const DrawFunctionType drawDeviceStateFunctions[] =
{
	&DrawDeviceGeneral,
	&DrawLightState,
	&DrawViewportScissorBackbufferState,
	&DrawFogState,
	&DrawInputAssemblerState,
	&DrawTessellationState,
	&DrawDepthStencilState,
	&DrawOutputState,
	&DrawTextureStageStates,
	&DrawSamplerStates,
	&DrawTextureState,
	&DrawMaterialLightingState,
	&DrawTransformsState,
	&DrawVSConstantsState,
	&DrawPSConstantsState
};
static_assert(ARRAYSIZE(drawDeviceStateFunctions) == MAX_NUM_STATE_PAGES, "Error: Missing draw function entry");

union deviceStateScreenState
{
	struct
	{
		deviceStatePage currentPage;
		unsigned short currentLine;
	} deviceStateData;

	void* genericData;
};
static_assert(sizeof(deviceStateScreenState) == sizeof(void*), "Error: Unexpected union size!");

static inline const char* const GetAbbreviatedFormatStringFromFormat(const D3DFORMAT fmt)
{
	switch (fmt)
	{
	case D3DFMT_UNKNOWN:        // = 0
		return "UNKNOWN";
	case D3DFMT_R8G8B8:              // = 20,
		return "R8G8B8";
    case D3DFMT_A8R8G8B8:            // = 21,
		return "A8R8G8B8";
    case D3DFMT_X8R8G8B8:            // = 22,
		return "X8R8G8B8";
	case D3DFMT_R5G6B5:              // = 23,
		return "R5G6B5";
    case D3DFMT_X1R5G5B5:            // = 24,
		return "X1R5G5B5";
    case D3DFMT_A1R5G5B5:            // = 25,
		return "A1R5G5B5";
    case D3DFMT_A4R4G4B4:            // = 26,
		return "A4R4G4B4";
    case D3DFMT_R3G3B2:              // = 27,
		return "R3G3B2";
    case D3DFMT_A8:                  // = 28,
		return "A8";
    case D3DFMT_A8R3G3B2:            // = 29,
		return "A8R3G3B2";
    case D3DFMT_X4R4G4B4:            // = 30,
		return "X4R4G4B4";
    case D3DFMT_A2B10G10R10:         // = 31,
		return "A2B10G10R10";
    case D3DFMT_A8B8G8R8:            // = 32,
		return "A8B8G8R8";
    case D3DFMT_X8B8G8R8:            // = 33,
		return "X8B8G8R8";
    case D3DFMT_G16R16:              // = 34,
		return "G16R16";
    case D3DFMT_A2R10G10B10:         // = 35,
		return "A2R10G10B10";
    case D3DFMT_A16B16G16R16:        // = 36,
		return "A16B16G16R16";
    case D3DFMT_A8P8:                // = 40,
		return "A8P8";
    case D3DFMT_P8:                  // = 41,
		return "P8";
    case D3DFMT_L8:                  // = 50,
		return "L8";
    case D3DFMT_A8L8:                // = 51,
		return "A8L8";
    case D3DFMT_A4L4:                // = 52,
		return "A4L4";
    case D3DFMT_V8U8:                // = 60,
		return "V8U8";
    case D3DFMT_L6V5U5:              // = 61,
		return "L6V5U5";
    case D3DFMT_X8L8V8U8:            // = 62,
		return "X8L8V8U8";
    case D3DFMT_Q8W8V8U8:            // = 63,
		return "Q8W8V8U8";
    case D3DFMT_V16U16:              // = 64,
		return "V16U16";
    case D3DFMT_A2W10V10U10:         // = 67,
		return "A2W10V10U10";
    case D3DFMT_UYVY:                // = MAKEFOURCC('U', 'Y', 'V', 'Y'),
		return "UYVY";
    case D3DFMT_R8G8_B8G8:           // = MAKEFOURCC('R', 'G', 'B', 'G'),
		return "R8G8_B8G8";
    case D3DFMT_YUY2:                // = MAKEFOURCC('Y', 'U', 'Y', '2'),
		return "YUY2";
    case D3DFMT_G8R8_G8B8:           // = MAKEFOURCC('G', 'R', 'G', 'B'),
		return "G8R8_G8B8";
    case D3DFMT_DXT1:                // = MAKEFOURCC('D', 'X', 'T', '1'),
		return "DXT1";
    case D3DFMT_DXT2:                // = MAKEFOURCC('D', 'X', 'T', '2'),
		return "DXT2";
    case D3DFMT_DXT3:                // = MAKEFOURCC('D', 'X', 'T', '3'),
		return "DXT3";
    case D3DFMT_DXT4:                // = MAKEFOURCC('D', 'X', 'T', '4'),
		return "DXT4";
    case D3DFMT_DXT5:                // = MAKEFOURCC('D', 'X', 'T', '5'),
		return "DXT5";
    case D3DFMT_D16_LOCKABLE:        // = 70,
		return "D16_LOCKABLE";
    case D3DFMT_D32:                 // = 71,
		return "D32";
    case D3DFMT_D15S1:               // = 73,
		return "D15S1";
    case D3DFMT_D24S8:               // = 75,
		return "D24S8";
    case D3DFMT_D24X8:               // = 77,
		return "D24X8";
    case D3DFMT_D24X4S4:             // = 79,
		return "D24X4S4";
    case D3DFMT_D16:                 // = 80,
		return "D16";
    case D3DFMT_D32F_LOCKABLE:       // = 82,
		return "D32F_LOCKABLE";
    case D3DFMT_D24FS8:              // = 83,
		return "D24FS8";
	case D3DFMT_D32_LOCKABLE:        // = 84,
		return "D32_LOCKABLE";
    case D3DFMT_S8_LOCKABLE:         // = 85,
		return "S8_LOCKABLE";
	case D3DFMT_L16:                 // = 81,
		return "L16";
    case D3DFMT_VERTEXDATA:          // =100,
		return "VERTEXDATA";
    case D3DFMT_INDEX16:             // =101,
		return "INDEX16";
    case D3DFMT_INDEX32:             // =102,
		return "INDEX32";
    case D3DFMT_Q16W16V16U16:        // =110,
		return "Q16W16V16U16";
    case D3DFMT_MULTI2_ARGB8:        // = MAKEFOURCC('M','E','T','1'),
		return "MULTI2_ARGB8";
    case D3DFMT_R16F:                // = 111,
		return "R16F";
    case D3DFMT_G16R16F:             // = 112,
		return "G16R16F";
    case D3DFMT_A16B16G16R16F:       // = 113,
		return "A16B16G16R16F";
    case D3DFMT_R32F:                // = 114,
		return "R32F";
    case D3DFMT_G32R32F:             // = 115,
		return "G32R32F";
    case D3DFMT_A32B32G32R32F:       // = 116,
		return "A32B32G32R32F";
    case D3DFMT_CxV8U8:              // = 117,
		return "CxV8U8";
	case D3DFMT_A1:                  // = 118,
		return "A1";
    case D3DFMT_A2B10G10R10_XR_BIAS: // = 119,
		return "A2B10G10R10_XR";
    case D3DFMT_BINARYBUFFER:        // = 199,
		return "BINARYBUFFER";
	default:
		return "D3DFMT_???";
	}
}

static const bool UpdateOverlay_DeviceState(const IDirect3DDevice9Hook* const hookDev, deviceStateScreenState& outCurrentScreenState)
{
	deviceStateScreenState currentScreenState;
	currentScreenState.genericData = GetOverlayPerScreenData(hookDev);

	if (GetAsyncKeyState(VK_HOME) & 0x1)
	{
		SetOverlayPerScreenData(hookDev, NULL);
		SetOverlayScreenState(hookDev, overlay_welcomeScreen);
		return false;
	}

	if (GetAsyncKeyState(VK_PRIOR) & 0x1)
	{
		if (currentScreenState.deviceStateData.currentPage == 0)
			currentScreenState.deviceStateData.currentPage = (const deviceStatePage)(MAX_NUM_STATE_PAGES - 1);
		else
			currentScreenState.deviceStateData.currentPage = (const deviceStatePage)(currentScreenState.deviceStateData.currentPage - 1u);
		currentScreenState.deviceStateData.currentLine = 0;
	}
	else if (GetAsyncKeyState(VK_NEXT) & 0x1)
	{
		currentScreenState.deviceStateData.currentPage = (const deviceStatePage)(currentScreenState.deviceStateData.currentPage + 1u);
		if (currentScreenState.deviceStateData.currentPage == MAX_NUM_STATE_PAGES)
			currentScreenState.deviceStateData.currentPage = (const deviceStatePage)0u;
		currentScreenState.deviceStateData.currentLine = 0;
	}

	if (GetAsyncKeyState(VK_DOWN) )
	{
		if (currentScreenState.deviceStateData.currentLine < 0xFFFF)
			++currentScreenState.deviceStateData.currentLine;
	}
	if (GetAsyncKeyState(VK_UP) )
	{
		if (currentScreenState.deviceStateData.currentLine > 0)
			--currentScreenState.deviceStateData.currentLine;
	}

	SetOverlayPerScreenData(hookDev, currentScreenState.genericData);

	outCurrentScreenState = currentScreenState;

	return true;
}

void UpdateAndDrawOverlay_DeviceState(class IDirect3DDevice9Hook* const hookDev)
{
	deviceStateScreenState currentScreenState;
	if (!UpdateOverlay_DeviceState(hookDev, currentScreenState) )
		return;

	const deviceStatePage currentDeviceStatePage = currentScreenState.deviceStateData.currentPage;

	OverlaySetDeviceStateForText(hookDev);


	// Skip drawing this header if we've scrolled down in order to save lines
	if (currentScreenState.deviceStateData.currentLine == 0)
		OverlayDrawPrintString(hookDev, 0, 0, stateEnabledColor, "Device State Page: [%s]", deviceStatePageNames[currentDeviceStatePage]);

	const IDirect3DDevice9Hook* const constDevice = hookDev;
	const DeviceState& deviceState = constDevice->GetCurrentHookState();

	(*(drawDeviceStateFunctions[currentDeviceStatePage]) )(hookDev, deviceState, currentScreenState.deviceStateData.currentLine);
}

static inline const char* const GetMultisampleTypeToString(const D3DMULTISAMPLE_TYPE multiSampleType)
{
	switch (multiSampleType)
	{
	case D3DMULTISAMPLE_NONE:
		return "None";
	case D3DMULTISAMPLE_NONMASKABLE:
		return "Nonmaskable";
	case D3DMULTISAMPLE_2_SAMPLES:
		return "2Samples";
	case D3DMULTISAMPLE_3_SAMPLES:
		return "3Samples";
	case D3DMULTISAMPLE_4_SAMPLES:
		return "4Samples";
	case D3DMULTISAMPLE_5_SAMPLES:
		return "5Samples";
	case D3DMULTISAMPLE_6_SAMPLES:
		return "6Samples";
	case D3DMULTISAMPLE_7_SAMPLES:
		return "7Samples";
	case D3DMULTISAMPLE_8_SAMPLES:
		return "8Samples";
	case D3DMULTISAMPLE_9_SAMPLES:
		return "9Samples";
	case D3DMULTISAMPLE_10_SAMPLES:
		return "10Samples";
	case D3DMULTISAMPLE_11_SAMPLES:
		return "11Samples";
	case D3DMULTISAMPLE_12_SAMPLES:
		return "12Samples";
	case D3DMULTISAMPLE_13_SAMPLES:
		return "13Samples";
	case D3DMULTISAMPLE_14_SAMPLES:
		return "14Samples";
	case D3DMULTISAMPLE_15_SAMPLES:
		return "15Samples";
	case D3DMULTISAMPLE_16_SAMPLES:
		return "16Samples";
	default:
		return "Unknown";
	}
}

static inline const char* const GetSwapEffectString(const D3DSWAPEFFECT swapEffect)
{
	switch (swapEffect)
	{
	case D3DSWAPEFFECT_DISCARD:
		return "Discard";
	case D3DSWAPEFFECT_FLIP:
		return "Flip";
	case D3DSWAPEFFECT_COPY:
		return "Copy";
	case D3DSWAPEFFECT_OVERLAY:
		return "Overlay";
	case D3DSWAPEFFECT_FLIPEX:
		return "FlipEx";
	default:
		return "Unknown";
	}
}

static inline const char* const GetPresentationIntervalString(const UINT PresentInterval)
{
	switch (PresentInterval)
	{
	case D3DPRESENT_INTERVAL_DEFAULT:
		return "DEFAULT";
	case D3DPRESENT_INTERVAL_ONE:
		return "ONE";
	case D3DPRESENT_INTERVAL_TWO:
		return "TWO";
	case D3DPRESENT_INTERVAL_THREE:
		return "THREE";
	case D3DPRESENT_INTERVAL_FOUR:
		return "FOUR";
	case D3DPRESENT_INTERVAL_IMMEDIATE:
		return "IMMEDIATE";
	default:
		return "Unknown";
	}
}

void DrawDeviceGeneral(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	const D3DPRESENT_PARAMETERS& presentParams = hookDev->GetInternalPresentParams();

	OverlayDrawPrintString(hookDev, 0, 1 - currentLineOffset, stateEnabledColor, "Backbuffer W: %u H: %u FMT: %s Count: %u", presentParams.BackBufferWidth, 
		presentParams.BackBufferHeight, 
		GetAbbreviatedFormatStringFromFormat(presentParams.BackBufferFormat), 
		presentParams.BackBufferCount);
	OverlayDrawPrintString(hookDev, 0, 2 - currentLineOffset, stateEnabledColor, "Backbuffer Multisample Type: %s Quality: %u", GetMultisampleTypeToString(presentParams.MultiSampleType), presentParams.MultiSampleQuality);

	OverlayDrawPrintString(hookDev, 0, 3 - currentLineOffset, stateEnabledColor, "SwapEffect: %s Windowed: %s", GetSwapEffectString(presentParams.SwapEffect), presentParams.Windowed ? "TRUE" : "FALSE");

	OverlayDrawPrintString(hookDev, 0, 4 - currentLineOffset, stateEnabledColor, "EnableAutoDepthStencil: %s", 
		presentParams.EnableAutoDepthStencil ? "TRUE" : "FALSE");

	OverlayDrawPrintString(hookDev, 0, 5 - currentLineOffset, stateEnabledColor, "AutoDepthStencilFormat: %s", 
		GetAbbreviatedFormatStringFromFormat(presentParams.AutoDepthStencilFormat) );

	char refreshRateBuffer[16] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
	if (presentParams.FullScreen_RefreshRateInHz > 0)
		itoa(presentParams.FullScreen_RefreshRateInHz, refreshRateBuffer, 10);
	else
		strcpy(refreshRateBuffer, "Auto (0)");
#pragma warning(pop)
	OverlayDrawPrintString(hookDev, 0, 6 - currentLineOffset, stateEnabledColor, "Refresh Rate: %s Flags: 0x%08X", 
		refreshRateBuffer,
		presentParams.Flags);

	OverlayDrawPrintString(hookDev, 0, 7 - currentLineOffset, stateEnabledColor, "Presentation Interval: %s", 
		GetPresentationIntervalString(presentParams.PresentationInterval) );
}

void DrawLightState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	const unsigned definedLights = deviceState.lightInfoMap->size();
	OverlayDrawPrintString(hookDev, 0, 1 - currentLineOffset, stateEnabledColor, "%u Lights Defined", definedLights);

	unsigned yOffsetLines = 2u;

	if (deviceState.lightInfoMap)
	{
		for (std::map<UINT, LightInfo*>::const_iterator iter = deviceState.lightInfoMap->begin(); iter != deviceState.lightInfoMap->end(); ++iter)
		{
			const LightInfo* const lightInfo = iter->second;
			if (lightInfo == NULL)
				continue;

			const char* lightTypeString;
			switch (lightInfo->light.Type)
			{
			default:
				lightTypeString = "UNK";
				break;
			case D3DLIGHT_POINT:
				lightTypeString = "PNT";
				break;
			case D3DLIGHT_DIRECTIONAL:
				lightTypeString = "DIR";
				break;
			case D3DLIGHT_SPOT:
				lightTypeString = "SPT";
				break;
			}

			const D3DCOLOR diffuse = Float4ToD3DCOLOR(*(const D3DXVECTOR4* const)&(lightInfo->light.Diffuse) );
			const D3DCOLOR ambient = Float4ToD3DCOLOR(*(const D3DXVECTOR4* const)&(lightInfo->light.Ambient) );
			const D3DCOLOR specular = Float4ToD3DCOLOR(*(const D3DXVECTOR4* const)&(lightInfo->light.Specular) );

			OverlayDrawPrintString(hookDev, 0, yOffsetLines - currentLineOffset, stateEnabledColor, "[%u] (%i) %s D:%08X A:%08X S:%08X", iter->first, lightInfo->activeLightIndex, lightTypeString, diffuse, ambient, specular);
			++yOffsetLines;
		}
	}
}

void DrawViewportScissorBackbufferState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	OverlayDrawPrintString(hookDev, 0, 1 - currentLineOffset, stateEnabledColor, "Viewport Rect --- X:%u, Y:%u, W:%u, H:%u", 
		deviceState.cachedViewport.viewport.X, 
		deviceState.cachedViewport.viewport.Y, 
		deviceState.cachedViewport.viewport.Width, 
		deviceState.cachedViewport.viewport.Height);
	OverlayDrawPrintString(hookDev, 0, 2 - currentLineOffset, stateEnabledColor, "zMin:%f, zMax:%f", 
		deviceState.cachedViewport.viewport.MinZ, 
		deviceState.cachedViewport.viewport.MaxZ);
	const BOOL scissorTestEnable = deviceState.currentRenderStates.renderStatesUnion.namedStates.scissorTestEnable;
	OverlayDrawPrintString(hookDev, 0, 3 - currentLineOffset, stateEnabledColor, "D3DRS_SCISSORTESTENABLE : %s", 
		scissorTestEnable ? "TRUE" : "FALSE");
	OverlayDrawPrintString(hookDev, 0, 4 - currentLineOffset, scissorTestEnable ? stateEnabledColor : stateDisabledColor, "Scissor Rect --- L:%i, R:%i, T:%i, B:%i", 
		deviceState.currentScissorRect.scissorRect.left,
		deviceState.currentScissorRect.scissorRect.right,
		deviceState.currentScissorRect.scissorRect.top,
		deviceState.currentScissorRect.scissorRect.bottom);

	if (deviceState.currentDepthStencil)
		OverlayDrawPrintString(hookDev, 0, 5 - currentLineOffset, stateEnabledColor, "DepthStencil Width: %u, Height: %u", deviceState.currentDepthStencil->GetInternalWidth(), deviceState.currentDepthStencil->GetInternalHeight() );
	else
		OverlayDrawString(hookDev, "DepthStencil is NULL", 0, 5 - currentLineOffset, stateEnabledColor);

	for (unsigned char rtID = 0; rtID < ARRAYSIZE(deviceState.currentRenderTargets); ++rtID)
	{
		const IDirect3DSurface9Hook* const thisRT = deviceState.currentRenderTargets[rtID];
		if (thisRT)
			OverlayDrawPrintString(hookDev, 0, (6 + rtID) - currentLineOffset, stateEnabledColor, "RT%u Width: %u, Height: %u", rtID, thisRT->GetInternalWidth(), thisRT->GetInternalHeight() );
		else
			OverlayDrawPrintString(hookDev, 0, (6 + rtID) - currentLineOffset, stateEnabledColor, "RT%u is NULL", rtID);
	}
}

static const char* const D3DFOGMODEStrings[] =
{
	"D3DFOG_NONE", // 0
	"D3DFOG_EXP", // 1
	"D3DFOG_EXP2", // 2
	"D3DFOG_LINEAR" // 3
};

static inline const char* const GetFogModeString(const D3DFOGMODE fogMode)
{
	if (fogMode > D3DFOG_LINEAR)
		return "UNKNOWN";
	else
		return D3DFOGMODEStrings[fogMode];
}

void DrawFogState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	const RenderStates::_renderStatesUnion::_namedStates& namedRenderStates = deviceState.currentRenderStates.renderStatesUnion.namedStates;
	const BOOL fogEnable = namedRenderStates.fogEnable;
	OverlayDrawPrintString(hookDev, 0, 1 - currentLineOffset, stateEnabledColor, "D3DRS_FOGENABLE : %s", 
		fogEnable ? "TRUE" : "FALSE");
	OverlayDrawPrintString(hookDev, 0, 2 - currentLineOffset, fogEnable ? stateEnabledColor : stateDisabledColor, "FogColor : 0x%08X", 
		namedRenderStates.fogColor);
	OverlayDrawString(hookDev, "FogColor Colored Text", 0, 3 - currentLineOffset, namedRenderStates.fogColor | D3DCOLOR_ARGB(0xFF, 0, 0, 0) );

	OverlayDrawPrintString(hookDev, 0, 4 - currentLineOffset, fogEnable ? stateEnabledColor : stateDisabledColor, "D3DRS_FOGTABLEMODE : %s (%u)",
		GetFogModeString(namedRenderStates.fogTableMode),
		namedRenderStates.fogTableMode);

	OverlayDrawPrintString(hookDev, 0, 5 - currentLineOffset, fogEnable ? stateEnabledColor : stateDisabledColor, "D3DRS_FOGVERTEXMODE : %s (%u)",
		GetFogModeString(namedRenderStates.fogVertexMode),
		namedRenderStates.fogVertexMode);

	OverlayDrawPrintString(hookDev, 0, 6 - currentLineOffset, fogEnable ? stateEnabledColor : stateDisabledColor, "D3DRS_RANGEFOGENABLE : %s",
		namedRenderStates.rangeFogEnable ? "TRUE" : "FALSE");

	OverlayDrawPrintString(hookDev, 0, 7 - currentLineOffset, fogEnable ? stateEnabledColor : stateDisabledColor, "D3DRS_FOGSTART : %f",
		namedRenderStates.fogStart);

	OverlayDrawPrintString(hookDev, 0, 8 - currentLineOffset, fogEnable ? stateEnabledColor : stateDisabledColor, "D3DRS_FOGEND : %f",
		namedRenderStates.fogEnd);

	OverlayDrawPrintString(hookDev, 0, 9 - currentLineOffset, fogEnable ? stateEnabledColor : stateDisabledColor, "D3DRS_FOGDENSITY : %f",
		namedRenderStates.fogDensity);

	if (namedRenderStates.fogTableMode > D3DFOG_NONE && namedRenderStates.fogVertexMode > D3DFOG_NONE)
	{
		OverlayDrawPrintString(hookDev, 0, 10 - currentLineOffset, fogEnable ? stateEnabledWarningColor : stateDisabledWarningColor, "Warning: Both Table (Pixel) Fog and Vertex Fog are enabled.\nTable (Pixel) Fog overrides Vertex Fog settings.\nSelected fog mode: %s (%u)",
			GetFogModeString(namedRenderStates.fogTableMode),
			namedRenderStates.fogTableMode);
	}
	else if (namedRenderStates.fogTableMode == D3DFOG_NONE && namedRenderStates.fogVertexMode == D3DFOG_NONE)
	{
		OverlayDrawPrintString(hookDev, 0, 10 - currentLineOffset, fogEnable ? stateEnabledColor : stateDisabledColor, "No Fog Selected. Fog disabled.\nSelected fog mode: %s (%u)",
			GetFogModeString(namedRenderStates.fogTableMode),
			namedRenderStates.fogTableMode);
	}
	else if (namedRenderStates.fogTableMode > D3DFOG_NONE)
	{
		OverlayDrawPrintString(hookDev, 0, 10 - currentLineOffset, fogEnable ? stateEnabledColor : stateDisabledColor, "Table Fog (Pixel Fog) Selected.\nSelected fog mode: %s (%u)",
			GetFogModeString(namedRenderStates.fogTableMode),
			namedRenderStates.fogTableMode);
	}
	else
	{
		OverlayDrawPrintString(hookDev, 0, 10 - currentLineOffset, fogEnable ? stateEnabledColor : stateDisabledColor, "Vertex Fog Selected.\nSelected fog mode: %s (%u)",
			GetFogModeString(namedRenderStates.fogVertexMode),
			namedRenderStates.fogVertexMode);
	}
}

static inline const char* const GetDeclTypeString(const D3DDECLTYPE type)
{
	switch (type)
	{
	case D3DDECLTYPE_FLOAT1:
		return "float1";
	case D3DDECLTYPE_FLOAT2:
		return "float2";
	case D3DDECLTYPE_FLOAT3:
		return "float3";
	case D3DDECLTYPE_FLOAT4:
		return "float4";
	case D3DDECLTYPE_D3DCOLOR:
		return "d3dcolor";
	case D3DDECLTYPE_UBYTE4:
		return "ubyte4";
	case D3DDECLTYPE_SHORT2:
		return "short2";
	case D3DDECLTYPE_SHORT4:
		return "short4";
	case D3DDECLTYPE_UBYTE4N:
		return "ubyte4n";
	case D3DDECLTYPE_SHORT2N:
		return "short2n";
	case D3DDECLTYPE_SHORT4N:
		return "short4n";
	case D3DDECLTYPE_USHORT2N:
		return "ushort2n";
	case D3DDECLTYPE_USHORT4N:
		return "ushort4n";
	case D3DDECLTYPE_UDEC3:
		return "udec3";
	case D3DDECLTYPE_DEC3N:
		return "dec3n";
	case D3DDECLTYPE_FLOAT16_2:
		return "float16_2";
	case D3DDECLTYPE_FLOAT16_4:
		return "float16_4";
	case D3DDECLTYPE_UNUSED:
		return "unused";
	default:
		return "Unknown";
	}
}

static inline const char* const GetDeclUsageString(const D3DDECLUSAGE usage)
{
	switch (usage)
	{
	case D3DDECLUSAGE_POSITION:      // = 0,
		return "POSITION";
	case D3DDECLUSAGE_BLENDWEIGHT:   // 1
		return "BLENDWEIGHT";
	case D3DDECLUSAGE_BLENDINDICES:  // 2
		return "BLENDINDICES";
	case D3DDECLUSAGE_NORMAL:        // 3
		return "NORMAL";
	case D3DDECLUSAGE_PSIZE:         // 4
		return "PSIZE";
	case D3DDECLUSAGE_TEXCOORD:      // 5
		return "TEXCOORD";
	case D3DDECLUSAGE_TANGENT:       // 6
		return "TANGENT";
	case D3DDECLUSAGE_BINORMAL:      // 7
		return "BINORMAL";
	case D3DDECLUSAGE_TESSFACTOR:    // 8
		return "TESSFACTOR";
	case D3DDECLUSAGE_POSITIONT:     // 9
		return "POSITIONT";
	case D3DDECLUSAGE_COLOR:         // 10
		return "COLOR";
	case D3DDECLUSAGE_FOG:           // 11
		return "FOG";
	case D3DDECLUSAGE_DEPTH:         // 12
		return "DEPTH";
	case D3DDECLUSAGE_SAMPLE:        // 13
		return "SAMPLE";
	default:
		return "Unknown";
	}
}

static inline const char* const GetDeclMethodString(const D3DDECLMETHOD method)
{
	switch (method)
	{
	case D3DDECLMETHOD_DEFAULT:// = 0,
		return "DEFAULT";
	case D3DDECLMETHOD_PARTIALU:// 1
		return "PARTIALU";
	case D3DDECLMETHOD_PARTIALV:// 2
		return "PARTIALV";
	case D3DDECLMETHOD_CROSSUV:// 3
		return "CROSSUV";
	case D3DDECLMETHOD_UV:// 4
		return "UV";
	case D3DDECLMETHOD_LOOKUP:// 5 
		return "LOOKUP";
	case D3DDECLMETHOD_LOOKUPPRESAMPLED:// 6
		return "LOOKUPPRESAMPLED";
	default:
		return "Unknown";
	}
}

static const D3DVERTEXELEMENT9 EndDecl = D3DDECL_END();

void DrawInputAssemblerState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	OverlayDrawString(hookDev, deviceState.declTarget == DeviceState::targetFVF ? "Currently using FVF vertex declaration" : "Currently using custom vertex declaration", 0, 1 - currentLineOffset, stateEnabledColor);
	OverlayDrawPrintString(hookDev, 0, 2 - currentLineOffset, (deviceState.declTarget == DeviceState::targetFVF) ? stateEnabledColor : stateDisabledColor, "Set FVF: 0x%08X", deviceState.currentFVF.rawFVF_DWORD);
	OverlayDrawPrintString(hookDev, 0, 3 - currentLineOffset, (deviceState.declTarget == DeviceState::targetVertexDecl) ? stateEnabledColor : stateDisabledColor, "Set Decl: 0x%08X", deviceState.currentVertexDecl);

	unsigned short lineOffset = 4;
	if (deviceState.currentVertexDecl)
	{
		const D3DCOLOR vertexDeclEnabledColor = (deviceState.declTarget == DeviceState::targetVertexDecl) ? stateEnabledColor : stateDisabledColor;
		OverlayDrawPrintString(hookDev, 0, (lineOffset++) - currentLineOffset, vertexDeclEnabledColor, "Decl vertex size: %u bytes", deviceState.currentVertexDecl->GetVertexSize() );

		const std::vector<DebuggableD3DVERTEXELEMENT9>& declElements = deviceState.currentVertexDecl->GetElementsInternal();
		const unsigned numElements = declElements.size();
		for (unsigned x = 0; x < numElements; ++x)
		{
			const DebuggableD3DVERTEXELEMENT9& thisElement = declElements[x];
			if (memcmp(&EndDecl, &thisElement, sizeof(D3DVERTEXELEMENT9) ) == 0)
				OverlayDrawString(hookDev, "{ D3DDECL_END }", 0, (lineOffset++) - currentLineOffset, vertexDeclEnabledColor);
			else
			{
				OverlayDrawPrintString(hookDev, 0, (lineOffset++) - currentLineOffset, vertexDeclEnabledColor, "{%u, %u, %s, %s, %s, %u}", 
					thisElement.Stream,
					thisElement.Offset,
					GetDeclTypeString(thisElement.Type),
					GetDeclMethodString(thisElement.Method),
					GetDeclUsageString(thisElement.Usage),
					thisElement.UsageIndex);
			}
		}
	}

	if (!deviceState.currentIndexBuffer)
		OverlayDrawString(hookDev, "Index buffer: NULL", 0, (lineOffset++) - currentLineOffset, stateEnabledColor);
	else
	{
		OverlayDrawPrintString(hookDev, 0, (lineOffset++) - currentLineOffset, stateEnabledColor, "Index buffer: 0x%08X Fmt: %s Bytes: %u", 
			deviceState.currentIndexBuffer, 
			GetAbbreviatedFormatStringFromFormat(deviceState.currentIndexBuffer->GetFormat() ),
			deviceState.currentIndexBuffer->GetInternalLength() );
	}

	for (unsigned streamID = 0; streamID < ARRAYSIZE(deviceState.currentStreams); ++streamID)
	{
		const StreamSource& thisStream = deviceState.currentStreams[streamID];
		if (!thisStream.vertexBuffer)
			OverlayDrawPrintString(hookDev, 0, (lineOffset++) - currentLineOffset, stateEnabledColor, "Stream %u: NULL Offset: %u bytes Stride: %u bytes", streamID, thisStream.streamOffset, thisStream.streamStride);
		else
		{
			OverlayDrawPrintString(hookDev, 0, (lineOffset++) - currentLineOffset, stateEnabledColor, "Stream %u: 0x%08X Offset: %u bytes Stride: %u bytes", streamID, thisStream.vertexBuffer, thisStream.streamOffset, thisStream.streamStride);
			const UINT vertexBufferLengthBytes = thisStream.vertexBuffer->GetInternalLength_Bytes();
			const UINT verticesAtCurrentStride = thisStream.streamStride ? (vertexBufferLengthBytes - thisStream.streamOffset) / thisStream.streamStride : 1;
			OverlayDrawPrintString(hookDev, 0, (lineOffset++) - currentLineOffset, stateEnabledColor, "VB 0x%08X Length: %u bytes FVF: 0x%08X %u vertices", thisStream.vertexBuffer, vertexBufferLengthBytes, thisStream.vertexBuffer->GetInternalFVF(), verticesAtCurrentStride);
		}
		
		OverlayDrawPrintString(hookDev, 0, (lineOffset++) - currentLineOffset, stateEnabledColor, "Freq: %u%s%s", thisStream.streamDividerFrequency, 
			(thisStream.streamDividerFrequency & D3DSTREAMSOURCE_INDEXEDDATA) ? " | INDEXEDDATA" : "",
			(thisStream.streamDividerFrequency & D3DSTREAMSOURCE_INSTANCEDATA) ? " | INSTANCEDATA" : "");
	}
}

static inline const char* const GetPatchEdgeStyleString(const D3DPATCHEDGESTYLE patchEdgeStyle)
{
	switch (patchEdgeStyle)
	{
	case D3DPATCHEDGE_DISCRETE:
		return "D3DPATCHEDGE_DISCRETE";
	case D3DPATCHEDGE_CONTINUOUS:
		return "D3DPATCHEDGE_CONTINUOUS";
	default:
		return "Unknown PatchEdgeStyle";
	}
}

static inline const char* const GetDegreeTypeString(const D3DDEGREETYPE degreeType)
{
	switch (degreeType)
	{
	case D3DDEGREE_LINEAR:
		return "D3DDEGREE_LINEAR";
	case D3DDEGREE_QUADRATIC:
		return "D3DDEGREE_QUADRATIC";
	case D3DDEGREE_CUBIC:
		return "D3DDEGREE_CUBIC";
	case D3DDEGREE_QUINTIC:
		return "D3DDEGREE_QUINTIC";
	default:
		return "Unknown degree type";
	}
}

void DrawTessellationState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	const RenderStates::_renderStatesUnion::_namedStates& namedRenderStates = deviceState.currentRenderStates.renderStatesUnion.namedStates;

	OverlayDrawPrintString(hookDev, 0, 1 - currentLineOffset, stateEnabledColor, "Current N-Patch Mode (segments): %f", deviceState.currentNPatchMode);
	const bool nPatchesEnabled = deviceState.currentNPatchMode >= 1.0f;
	const D3DCOLOR nPatchEnabledColor = nPatchesEnabled ? stateEnabledColor : stateDisabledColor;
	OverlayDrawString(hookDev, nPatchesEnabled ? "N-Patches Enabled" : "N-Patches Disabled", 0, 2 - currentLineOffset, nPatchEnabledColor);
	OverlayDrawPrintString(hookDev, 0, 3 - currentLineOffset, nPatchEnabledColor, "Patch Edge Style: %s", GetPatchEdgeStyleString(namedRenderStates.patchEdgeStyle) );
	OverlayDrawPrintString(hookDev, 0, 4 - currentLineOffset, nPatchEnabledColor, "Positons Degree: %s", GetDegreeTypeString(namedRenderStates.positionDegree) );
	OverlayDrawPrintString(hookDev, 0, 5 - currentLineOffset, nPatchEnabledColor, "Normals Degree: %s", GetDegreeTypeString(namedRenderStates.normalDegree) );

	OverlayDrawString(hookDev, namedRenderStates.enableAdaptiveTessellation ? "Adaptive Tessellation Enabled" : "Adaptive Tessellation Disabled", 0, 6 - currentLineOffset, stateEnabledColor);
	const D3DCOLOR adaptiveTessEnabledColor = namedRenderStates.enableAdaptiveTessellation ? stateEnabledColor : stateDisabledColor;
	OverlayDrawPrintString(hookDev, 0, 7 - currentLineOffset, adaptiveTessEnabledColor, "Adaptive Tessellation Factors:\n    (%f, %f, %f, %f)", namedRenderStates.adaptiveness_X, namedRenderStates.adaptiveness_Y, namedRenderStates.adaptiveness_Z, namedRenderStates.adaptiveness_W);
	OverlayDrawPrintString(hookDev, 0, 9 - currentLineOffset, adaptiveTessEnabledColor, "Adaptive Tessellation Min (%f) Max (%f)", namedRenderStates.minTessellationLevel, namedRenderStates.maxTessellationLevel);
}

static inline const char* const GetZBufferModeToString(const D3DZBUFFERTYPE zBufferMode)
{
	switch (zBufferMode)
	{
	case D3DZB_FALSE:
		return "FALSE";
	case D3DZB_TRUE:
		return "ZB_TRUE";
	case D3DZB_USEW:
		return "WB_TRUE";
	default:
		return "Unknown";
	}
}

static inline const char* const GetCmpFuncString(const D3DCMPFUNC cmpFunc)
{
	switch (cmpFunc)
	{
	case D3DCMP_NEVER:
		return "NEVER";
	case D3DCMP_LESS:
		return "LESS";
	case D3DCMP_EQUAL:
		return "EQUAL";
	case D3DCMP_LESSEQUAL:
		return "LESSEQUAL";
	case D3DCMP_GREATER:
		return "GREATER";
	case D3DCMP_NOTEQUAL:
		return "NOTEQUAL";
	case D3DCMP_GREATEREQUAL:
		return "GREATEREQUAL";
	case D3DCMP_ALWAYS:
		return "ALWAYS";
	default:
		return "Unknown";
	}
}

static inline const char* const GetStencilOpString(const D3DSTENCILOP stencilOp)
{
	switch (stencilOp)
	{
	case D3DSTENCILOP_KEEP:
		return "KEEP";
	case D3DSTENCILOP_ZERO:
		return "ZERO";
	case D3DSTENCILOP_REPLACE:
		return "REPLACE";
	case D3DSTENCILOP_INCRSAT:
		return "INCSAT";
	case D3DSTENCILOP_DECRSAT:
		return "DECSAT";
	case D3DSTENCILOP_INVERT:
		return "INVERT";
	case D3DSTENCILOP_INCR:
		return "INC";
	case D3DSTENCILOP_DECR:
		return "DEC";
	default:
		return "Unknown";
	}
}

void DrawDepthStencilState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	const RenderStates::_renderStatesUnion::_namedStates& namedRenderStates = deviceState.currentRenderStates.renderStatesUnion.namedStates;

	const bool depthIsEnabled = (deviceState.currentDepthStencil != NULL) && namedRenderStates.zEnable;
	const D3DCOLOR depthEnabledColor = depthIsEnabled ? stateEnabledColor : stateDisabledColor;

	if (deviceState.currentDepthStencil != NULL)
	{
		OverlayDrawPrintString(hookDev, 0, 1 - currentLineOffset, depthEnabledColor, "DepthStencil W: %u H: %u Fmt: %s", 
			deviceState.currentDepthStencil->GetInternalWidth(), 
			deviceState.currentDepthStencil->GetInternalHeight(), 
			GetAbbreviatedFormatStringFromFormat(deviceState.currentDepthStencil->GetInternalFormat() ) );
	}
	else
		OverlayDrawString(hookDev, "DepthStencil: NULL", 0, 1 - currentLineOffset, depthEnabledColor);

	OverlayDrawPrintString(hookDev, 0, 2 - currentLineOffset, depthEnabledColor, "zEnable: %s zWriteEnable: %s zFunc: %s",
		GetZBufferModeToString(namedRenderStates.zEnable),
		namedRenderStates.zWriteEnable ? "TRUE" : "FALSE",
		GetCmpFuncString(namedRenderStates.zFunc) );

	OverlayDrawPrintString(hookDev, 0, 3 - currentLineOffset, depthEnabledColor, "DepthBias: %f SlopeScaledDepthBias: %f",
		namedRenderStates.depthBias,
		namedRenderStates.slopeScaledDepthBias);

	const D3DCOLOR stencilEnabledColor = namedRenderStates.stencilEnable ? stateEnabledColor : stateDisabledColor;

	OverlayDrawPrintString(hookDev, 0, 4 - currentLineOffset, stateEnabledColor, "Stencil Enable: %s",
		namedRenderStates.stencilEnable ? "TRUE" : "FALSE");

	OverlayDrawPrintString(hookDev, 0, 5 - currentLineOffset, stencilEnabledColor, "CW Stencil Func: %s",
		GetCmpFuncString(namedRenderStates.stencilFunc) );

	OverlayDrawPrintString(hookDev, 0, 6 - currentLineOffset, stencilEnabledColor, "CWPass: %s CWFail: %s CWzFail: %s",
		GetStencilOpString(namedRenderStates.stencilPass),
		GetStencilOpString(namedRenderStates.stencilFail),
		GetStencilOpString(namedRenderStates.stencilZFail) );

	OverlayDrawPrintString(hookDev, 0, 7 - currentLineOffset, stencilEnabledColor, "Two-Sided Stencil: %s",
		namedRenderStates.twoSidedStencilMode ? "TRUE" : "FALSE");

	const D3DCOLOR twoSidedStencilEnabledColor = (namedRenderStates.stencilEnable && namedRenderStates.twoSidedStencilMode) ? stateEnabledColor : stateDisabledColor;

	OverlayDrawPrintString(hookDev, 0, 8 - currentLineOffset, twoSidedStencilEnabledColor, "CCW Stencil Func: %s",
		GetCmpFuncString(namedRenderStates.ccw_StencilFunc) );

	OverlayDrawPrintString(hookDev, 0, 9 - currentLineOffset, twoSidedStencilEnabledColor, "CCWPass: %s CCWFail: %s CCWzFail: %s",
		GetStencilOpString(namedRenderStates.ccw_StencilPass),
		GetStencilOpString(namedRenderStates.ccw_StencilFail),
		GetStencilOpString(namedRenderStates.ccw_StencilZFail) );

	OverlayDrawPrintString(hookDev, 0, 10 - currentLineOffset, stencilEnabledColor, "Stencil Ref: %u\nStencil Read Mask: 0x%08X\nStencil Write Mask: 0x%08X",
		namedRenderStates.stencilRef,
		namedRenderStates.stencilMask,
		namedRenderStates.stencilWriteMask);
}

static inline const char* const GetBlendOpString(const D3DBLENDOP blendOp)
{
	switch (blendOp)
	{
	case D3DBLENDOP_ADD:
		return "ADD";
	case D3DBLENDOP_SUBTRACT:
		return "SUBTRACT";
	case D3DBLENDOP_REVSUBTRACT:
		return "REVSUBTRACT";
	case D3DBLENDOP_MIN:
		return "MIN";
	case D3DBLENDOP_MAX:
		return "MAX";
	default:
		return "Unknown";
	}
}

static inline const char* const GetBlendString(const D3DBLEND blend)
{
	switch (blend)
	{
	case D3DBLEND_ZERO:
		return "ZERO";
	case D3DBLEND_ONE:
		return "ONE";
	case D3DBLEND_SRCCOLOR:
		return "SRCCOLOR";
	case D3DBLEND_INVSRCCOLOR:
		return "INVSRCCOLOR";
	case D3DBLEND_SRCALPHA:
		return "SRCALPHA";
	case D3DBLEND_INVSRCALPHA:
		return "INVSRCALPHA";
	case D3DBLEND_DESTALPHA:
		return "DESTALPHA";
	case D3DBLEND_INVDESTALPHA:
		return "INVDESTALPHA";
	case D3DBLEND_DESTCOLOR:
		return "DESTCOLOR";
	case D3DBLEND_INVDESTCOLOR:
		return "INVDESTCOLOR";
	case D3DBLEND_SRCALPHASAT:
		return "SRCALPHASAT";
	case D3DBLEND_BOTHSRCALPHA:
		return "BOTHSRCALPHA";
	case D3DBLEND_BOTHINVSRCALPHA:
		return "BOTHINVSRCALPHA";
	case D3DBLEND_BLENDFACTOR:
		return "BLENDFACTOR";
	case D3DBLEND_INVBLENDFACTOR:
		return "INVBLENDFACTOR";
	case D3DBLEND_SRCCOLOR2:
		return "SRCCOLOR2";
	case D3DBLEND_INVSRCCOLOR2:
		return "INVSRCCOLOR2";
	default:
		return "Unknown";
	}
}

static const char* const colorWriteStrings[] = 
{
	"None", // 0 - None
	"Red", // 1 - R
	"Green", // 2 - G
	"Red | Green",// 3 - RG
	"Blue", // 4 - B
	"Red | Blue", // 5 - RB
	"Green | Blue", // 6 - GB
	"Red | Green | Blue", // 7 - RGB
	"Alpha", // 8 - A
	"Red | Alpha", // 9 - RA
	"Green | Alpha", // 10 - GA
	"Red | Green | Alpha", // 11 - RGA
	"Blue | Alpha", // 12 - BA
	"Red | Blue | Alpha", // 13 - RBA
	"Green | Blue | Alpha", // 14 - GBA
	"Red | Green | Blue | Alpha" // 15 - RGBA
};

void DrawOutputState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	const RenderStates::_renderStatesUnion::_namedStates& namedRenderStates = deviceState.currentRenderStates.renderStatesUnion.namedStates;

	OverlayDrawPrintString(hookDev, 0, 1 - currentLineOffset, stateEnabledColor, "Alpha Blend Enable: %s", namedRenderStates.alphaBlendEnable ? "TRUE" : "FALSE");

	const D3DCOLOR alphaBlendEnableColor = namedRenderStates.alphaBlendEnable ? stateEnabledColor : stateDisabledColor;
	const D3DCOLOR separateAlphaBlendEnableColor = namedRenderStates.separateAlphaBlendEnable ? stateEnabledColor : stateDisabledColor;

	OverlayDrawPrintString(hookDev, 0, 2 - currentLineOffset, alphaBlendEnableColor, "%s %s %s", GetBlendString(namedRenderStates.srcBlend), GetBlendOpString(namedRenderStates.blendOp), GetBlendString(namedRenderStates.destBlend) );

	OverlayDrawPrintString(hookDev, 0, 3 - currentLineOffset, stateEnabledColor, "Separate Alpha Blend Enable: %s", namedRenderStates.separateAlphaBlendEnable ? "TRUE" : "FALSE");

	OverlayDrawPrintString(hookDev, 0, 4 - currentLineOffset, separateAlphaBlendEnableColor, "%s %s %s", GetBlendString(namedRenderStates.srcBlendAlpha), GetBlendOpString(namedRenderStates.blendOpAlpha), GetBlendString(namedRenderStates.destBlendAlpha) );

	OverlayDrawPrintString(hookDev, 0, 5 - currentLineOffset, stateEnabledColor, "BlendFactor: 0x%08X", namedRenderStates.blendFactor);

	OverlayDrawPrintString(hookDev, 0, 6 - currentLineOffset, stateEnabledColor, "Alpha Test Enable: %s", namedRenderStates.alphaTestEnable ? "TRUE" : "FALSE");

	OverlayDrawPrintString(hookDev, 0, 7 - currentLineOffset, namedRenderStates.alphaTestEnable ? stateEnabledColor : stateDisabledColor, "Alpha Test Reference: %u\nAlpha Test Function: %s", namedRenderStates.alphaRef, GetCmpFuncString(namedRenderStates.alphaFunc) );

	OverlayDrawPrintString(hookDev, 0, 9 - currentLineOffset, stateEnabledColor, "sRGB Write Enable: %s", namedRenderStates.sRGBWriteEnable ? "TRUE" : "FALSE");

	OverlayDrawPrintString(hookDev, 0, 10 - currentLineOffset, stateEnabledColor, "Multisample Antialias: %s", namedRenderStates.multisampleAntialias ? "TRUE" : "FALSE");

	OverlayDrawPrintString(hookDev, 0, 11 - currentLineOffset, namedRenderStates.multisampleAntialias ? stateEnabledColor : stateDisabledColor, "Multisample Mask: 0x%08X", namedRenderStates.multisampleMask);

	OverlayDrawPrintString(hookDev, 0, 12 - currentLineOffset, stateEnabledColor, "Color Write Enable 0: %s", colorWriteStrings[namedRenderStates.colorWriteEnable % 16]);
	OverlayDrawPrintString(hookDev, 0, 13 - currentLineOffset, stateEnabledColor, "Color Write Enable 1: %s", colorWriteStrings[namedRenderStates.colorWriteEnable1 % 16]);
	OverlayDrawPrintString(hookDev, 0, 14 - currentLineOffset, stateEnabledColor, "Color Write Enable 2: %s", colorWriteStrings[namedRenderStates.colorWriteEnable2 % 16]);
	OverlayDrawPrintString(hookDev, 0, 15 - currentLineOffset, stateEnabledColor, "Color Write Enable 3: %s", colorWriteStrings[namedRenderStates.colorWriteEnable3 % 16]);

	for (unsigned char rtID = 0; rtID < ARRAYSIZE(deviceState.currentRenderTargets); ++rtID)
	{
		const unsigned short lineNumber = (16 + rtID) - currentLineOffset;
		const IDirect3DSurface9Hook* const thisRT = deviceState.currentRenderTargets[rtID];
		if (thisRT != NULL)
			OverlayDrawPrintString(hookDev, 0, lineNumber, stateEnabledColor, "RT%u is: %ux%u %s %s %s", rtID, 
				thisRT->GetInternalWidth(), 
				thisRT->GetInternalHeight(), 
				GetAbbreviatedFormatStringFromFormat(thisRT->GetInternalFormat() ),
				thisRT->GetInternalDiscard() ? "DISCARD" : "NODISCARD",
				thisRT->GetInternalLockable() ? "LOCKABLE" : "NOLOCK");
		else
			OverlayDrawPrintString(hookDev, 0, lineNumber, stateEnabledColor, "RT%u is: NULL", rtID);
	}
}

static inline const char* const GetTextureOpString(const D3DTEXTUREOP textureOp)
{
	switch (textureOp)
	{
	case D3DTOP_DISABLE://              = 1,
		return "DISABLE";
	case D3DTOP_SELECTARG1://           = 2,
		return "SELECTARG1";
	case D3DTOP_SELECTARG2://           = 3,
		return "SELECTARG2";
	case D3DTOP_MODULATE://             = 4,
		return "MODULATE";
	case D3DTOP_MODULATE2X://           = 5,
		return "MODULATE2X";
	case D3DTOP_MODULATE4X://           = 6,
		return "MODULATE4X";
	case D3DTOP_ADD://                  =  7
		return "ADD";
	case D3DTOP_ADDSIGNED://            =  8
		return "ADDSIGNED";
	case D3DTOP_ADDSIGNED2X://          =  9
		return "ADDSIGNED2X";
	case D3DTOP_SUBTRACT://             = 10
		return "SUBTRACT";
	case D3DTOP_ADDSMOOTH://            = 11
		return "ADDSMOOTH";
	case D3DTOP_BLENDDIFFUSEALPHA://    = 12
		return "BLENDDIFFUSEALPHA";
	case D3DTOP_BLENDTEXTUREALPHA://    = 13
		return "BLENDTEXTUREALPHA";
	case D3DTOP_BLENDFACTORALPHA://     = 14
		return "BLENDFACTORALPHA";
	case D3DTOP_BLENDTEXTUREALPHAPM://  = 15
		return "BLENDTEXTUREALPHAPM";
	case D3DTOP_BLENDCURRENTALPHA://    = 16
		return "BLENDCURRENTALPHA";
	case D3DTOP_PREMODULATE://            = 17
		return "PREMODULATE";
	case D3DTOP_MODULATEALPHA_ADDCOLOR:// = 18
		return "MODALPHA_ADDCOLOR";
	case D3DTOP_MODULATECOLOR_ADDALPHA:// = 19
		return "MODCOLOR_ADDALPHA";
	case D3DTOP_MODULATEINVALPHA_ADDCOLOR:// = 20
		return "MODINVALPHA_ADDCOLOR";
	case D3DTOP_MODULATEINVCOLOR_ADDALPHA:// = 21
		return "MODINVCOLOR_ADDALPHA";
	case D3DTOP_BUMPENVMAP://           = 22
		return "BUMPENVMAP";
	case D3DTOP_BUMPENVMAPLUMINANCE://  = 23
		return "BUMPENVMAPLUM";
	case D3DTOP_DOTPRODUCT3://          = 24
		return "DOTPRODUCT3";
	case D3DTOP_MULTIPLYADD://          = 25
		return "MULTIPLYADD";
	case D3DTOP_LERP://                 = 26
		return "LERP";
	default:
		return "Unknown";
	}
}

static inline const char* const GetTextureArgString(const textureStageArgument textureArg)
{
	switch (textureArg)
	{
	case TA_DIFFUSE:// = D3DTA_DIFFUSE,
		return "DIFFUSE";
	case TA_CURRENT:// = D3DTA_CURRENT,
		return "CURRENT";
	case TA_TEXTURE:// = D3DTA_TEXTURE,
		return "TEXTURE";
	case TA_TFACTOR:// = D3DTA_TFACTOR,
		return "TFACTOR";
	case TA_SPECULAR:// = D3DTA_SPECULAR,
		return "SPECULAR";
	case TA_TEMP:// = D3DTA_TEMP,
		return "TEMP";
	case TA_CONSTANT:// = D3DTA_CONSTANT,
		return "CONSTANT";

	case TA_COMPLEMENT_DIFFUSE:// = D3DTA_DIFFUSE | D3DTA_COMPLEMENT,
		return "DIFFUSE|COMP";
	case TA_COMPLEMENT_CURRENT:// = D3DTA_CURRENT | D3DTA_COMPLEMENT,
		return "CURRENT|COMP";
	case TA_COMPLEMENT_TEXTURE:// = D3DTA_TEXTURE | D3DTA_COMPLEMENT,
		return "TEXTURE|COMP";
	case TA_COMPLEMENT_TFACTOR:// = D3DTA_TFACTOR | D3DTA_COMPLEMENT,
		return "TFACTOR|COMP";
	case TA_COMPLEMENT_SPECULAR:// = D3DTA_SPECULAR | D3DTA_COMPLEMENT,
		return "SPECULAR|COMP";
	case TA_COMPLEMENT_TEMP:// = D3DTA_TEMP | D3DTA_COMPLEMENT,
		return "TEMP|COMP";
	case TA_COMPLEMENT_CONSTANT:// = D3DTA_CONSTANT | D3DTA_COMPLEMENT,
		return "CONSTANT|COMP";

	case TA_DIFFUSE_ALPHAREPLICATE:// = D3DTA_DIFFUSE | D3DTA_ALPHAREPLICATE,
		return "DIFFUSE|ALPHAREP";
	case TA_CURRENT_ALPHAREPLICATE:// = D3DTA_CURRENT | D3DTA_ALPHAREPLICATE,
		return "CURRENT|ALPHAREP";
	case TA_TEXTURE_ALPHAREPLICATE:// = D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE,
		return "TEXTURE|ALPHAREP";
	case TA_TFACTOR_ALPHAREPLICATE:// = D3DTA_TFACTOR | D3DTA_ALPHAREPLICATE,
		return "TFACTOR|ALPHAREP";
	case TA_SPECULAR_ALPHAREPLICATE:// = D3DTA_SPECULAR | D3DTA_ALPHAREPLICATE,
		return "SPECULAR|ALPHAREP";
	case TA_TEMP_ALPHAREPLICATE:// = D3DTA_TEMP | D3DTA_ALPHAREPLICATE,
		return "TEMP|ALPHAREP";
	case TA_CONSTANT_ALPHAREPLICATE:// = D3DTA_CONSTANT | D3DTA_ALPHAREPLICATE,
		return "CONSTANT|ALPHAREP";

	case TA_COMPLEMENT_DIFFUSE_ALPHAREPLICATE:// = D3DTA_DIFFUSE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
		return "DIFFUSE|COMP|ALPHAREP";
	case TA_COMPLEMENT_CURRENT_ALPHAREPLICATE:// = D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
		return "CURRENT|COMP|ALPHAREP";
	case TA_COMPLEMENT_TEXTURE_ALPHAREPLICATE:// = D3DTA_TEXTURE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
		return "TEXTURE|COMP|ALPHAREP";
	case TA_COMPLEMENT_TFACTOR_ALPHAREPLICATE:// = D3DTA_TFACTOR | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
		return "TFACTOR|COMP|ALPHAREP";
	case TA_COMPLEMENT_SPECULAR_ALPHAREPLICATE:// = D3DTA_SPECULAR | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
		return "SPECULAR|COMP|ALPHAREP";
	case TA_COMPLEMENT_TEMP_ALPHAREPLICATE:// = D3DTA_TEMP | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE,
		return "TEMP|COMP|ALPHAREP";
	case TA_COMPLEMENT_CONSTANT_ALPHAREPLICATE:// = D3DTA_CONSTANT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE
		return "CONSTANT|COMP|ALPHAREP";
	default:
		return "Unknown";
	}
}

static inline const char* const GetTextureTransformFlagsString(const D3DTEXTURETRANSFORMFLAGS flags)
{
	switch (flags)
	{
	case D3DTTFF_DISABLE:
		return "DISABLE";
	case D3DTTFF_COUNT1:
		return "COUNT1";
	case D3DTTFF_COUNT2:
		return "COUNT2";
	case D3DTTFF_COUNT3:
		return "COUNT3";
	case D3DTTFF_COUNT4:
		return "COUNT4";

	case D3DTTFF_COUNT1|D3DTTFF_PROJECTED:
		return "COUNT1|PROJ";
	case D3DTTFF_COUNT2|D3DTTFF_PROJECTED:
		return "COUNT2|PROJ";
	case D3DTTFF_COUNT3|D3DTTFF_PROJECTED:
		return "COUNT3|PROJ";
	case D3DTTFF_COUNT4|D3DTTFF_PROJECTED:
		return "COUNT4|PROJ";

	default:
		return "Unknown";
	}
}

static inline const char* const GetTCIString(const UINT texcoordIndex)
{
	switch (texcoordIndex & 0xFFFF0000)
	{
	case D3DTSS_TCI_PASSTHRU://                             0x00000000
		return "PASSTHRU";
	case D3DTSS_TCI_CAMERASPACENORMAL://                    0x00010000
		return "VIEWNORMAL";
	case D3DTSS_TCI_CAMERASPACEPOSITION://                  0x00020000
		return "VIEWPOS";
	case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR://          0x00030000
		return "VIEWREFLECTION";
	case D3DTSS_TCI_SPHEREMAP://                            0x00040000
		return "SPHEREMAP";
	default:
		return "Unknown";
	}
}

void DrawTextureStageStates(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	OverlayDrawPrintString(hookDev, 0, 1 - currentLineOffset, stateEnabledColor, "TFACTOR: 0x%08X", deviceState.currentRenderStates.renderStatesUnion.namedStates.textureFactor);

	bool disableFutureStages = false;
	for (unsigned char stageNum = 0; stageNum < ARRAYSIZE(deviceState.currentStageStates); ++stageNum)
	{
		const TextureStageState& stage = deviceState.currentStageStates[stageNum];
		const TextureStageState::_stageStateUnion::_namedStates& stageStateNames = stage.stageStateUnion.namedStates;

		const unsigned short stageStartLineNumber = (stageNum * 12 + 3) - currentLineOffset;

		if (stageStateNames.colorOp == D3DTOP_DISABLE)
			disableFutureStages = true;

		const D3DCOLOR stageColor = (stageStateNames.colorOp != D3DTOP_DISABLE && !disableFutureStages) ? stateEnabledColor : stateDisabledColor;
		const D3DCOLOR stageColorAlpha = (stageStateNames.colorOp != D3DTOP_DISABLE && stageStateNames.alphaOp != D3DTOP_DISABLE && !disableFutureStages) ? stateEnabledColor : stateDisabledColor;

		OverlayDrawPrintString(hookDev, 0, stageStartLineNumber, stageColor, "Stage: %u", stageNum);

		OverlayDrawPrintString(hookDev, 0, stageStartLineNumber + 1, stageColor, "ColorOp: %s", GetTextureOpString(stageStateNames.colorOp) );

		OverlayDrawPrintString(hookDev, 0, stageStartLineNumber + 2, stageColor, "Color: Arg1: %s Arg2: %s Arg0: %s",
			GetTextureArgString(stageStateNames.colorArg1),
			GetTextureArgString(stageStateNames.colorArg2),
			GetTextureArgString(stageStateNames.colorArg0) );

		OverlayDrawPrintString(hookDev, 0, stageStartLineNumber + 3, stageColorAlpha, "AlphaOp: %s", GetTextureOpString(stageStateNames.alphaOp) );

		OverlayDrawPrintString(hookDev, 0, stageStartLineNumber + 4, stageColor, "Alpha: Arg1: %s Arg2: %s Arg0: %s",
			GetTextureArgString(stageStateNames.alphaArg1),
			GetTextureArgString(stageStateNames.alphaArg2),
			GetTextureArgString(stageStateNames.alphaArg0) );

		OverlayDrawPrintString(hookDev, 0, stageStartLineNumber + 5, stageColor, "Result: %s StageConstant: 0x%08X", GetTextureArgString(stageStateNames.resultArg), stageStateNames.constant);

		OverlayDrawPrintString(hookDev, 0, stageStartLineNumber + 6, stageColor, "TexCoordIndex: %u TexGen: %s", 
			LOWORD(stageStateNames.texCoordIndex), 
			GetTCIString(stageStateNames.texCoordIndex) );

		OverlayDrawPrintString(hookDev, 0, stageStartLineNumber + 7, stageColor, "TexTransform: %s", 
			GetTextureTransformFlagsString(stageStateNames.textureTransformFlags) );

		OverlayDrawPrintString(hookDev, 0, stageStartLineNumber + 8, stageColor, "BumpEnvMat: [%f, %f]\n"
			"            [%f, %f]",
			stageStateNames.bumpEnvMat00, stageStateNames.bumpEnvMat01,
			stageStateNames.bumpEnvMat10, stageStateNames.bumpEnvMat11);

		OverlayDrawPrintString(hookDev, 0, stageStartLineNumber + 10, stageColor, "BumpEnvLScale: %f BumpEnvLOffset: %f", stageStateNames.bumpEnvLScale, stageStateNames.bumpEnvLOffset);
	}
}

static const char* const abbreviatedAddressModes[] =
{
	"", // Zero entry
	"WRAP",
	"MIRROR",
	"CLAMP",
	"BORDER",
	"MIRROR1"
};
static inline const char* const GetAbbreviatedAddressModeString(const D3DTEXTUREADDRESS textureAddressMode)
{
	if (textureAddressMode < D3DTADDRESS_WRAP || D3DTADDRESS_MIRRORONCE > D3DTADDRESS_MIRRORONCE)
		return "UNKNOWN";
	return abbreviatedAddressModes[textureAddressMode];
}

static const char* const abbreviatedTextureFilters[] =
{
	"NONE",
	"POINT",
	"LINEAR",
	"ANISO",
	"PYRMIDQ",
	"GAUSSQ",
	"CONVMONO"
};
static inline const char* const GetAbbreviatedTextureFilterString(const D3DTEXTUREFILTERTYPE texFilter)
{
	if (texFilter > D3DTEXF_CONVOLUTIONMONO)
		return "UNKNOWN";
	return abbreviatedTextureFilters[texFilter];
}

void DrawSamplerStates(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	for (unsigned texID = 0; texID < MAX_NUM_SAMPLERS; ++texID)
	{
		// Skip all textures after 16 and before the DMAP sampler and VTEX samplers
		if (texID >= 16 && texID < D3DDMAPSAMPLER)
			continue;

		const SamplerState& currentSamplerState = deviceState.currentSamplerStates[texID];
		const SamplerState::_stateUnion::_namedStates& namedSamplerStates = currentSamplerState.stateUnion.namedStates;

		const unsigned printedLineNumber = (texID >= 16 ? texID - (D3DDMAPSAMPLER - 16) : texID) * 4;

		char textureIndexString[16];
#pragma warning(push)
#pragma warning(disable:4996)
		switch (texID)
		{
		case D3DDMAPSAMPLER:
			strcpy(textureIndexString, "DMAP");
			break;
		case D3DVERTEXTEXTURESAMPLER0:
			strcpy(textureIndexString, "VTEX0");
			break;
		case D3DVERTEXTEXTURESAMPLER1:
			strcpy(textureIndexString, "VTEX1");
			break;
		case D3DVERTEXTEXTURESAMPLER2:
			strcpy(textureIndexString, "VTEX2");
			break;
		case D3DVERTEXTEXTURESAMPLER3:
			strcpy(textureIndexString, "VTEX3");
			break;
		default:
			sprintf(textureIndexString, "Tex%u", texID);
			break;
		}
#pragma warning(pop)

		OverlayDrawPrintString(hookDev, 0, (2 + printedLineNumber) - currentLineOffset, stateEnabledColor, "%s Min%s Mag%s Mip%s U%s V%s W%s\n"
			"MaxMip:%u MaxAniso:%u sRGB:%c DMAPOffset:%u eIndex:%u\n"
			"LoDBias: %f BorderColor: 0x%08X", 
			textureIndexString, GetAbbreviatedTextureFilterString(namedSamplerStates.minFilter), GetAbbreviatedTextureFilterString(namedSamplerStates.magFilter), GetAbbreviatedTextureFilterString(namedSamplerStates.mipFilter),
			GetAbbreviatedAddressModeString(namedSamplerStates.addressU), GetAbbreviatedAddressModeString(namedSamplerStates.addressV), GetAbbreviatedAddressModeString(namedSamplerStates.addressW),
			namedSamplerStates.maxMipLevel, namedSamplerStates.maxAnisotropy, namedSamplerStates.sRGBTexture ? 'Y' : 'N', namedSamplerStates.dMapOffset, namedSamplerStates.elementIndex,
			namedSamplerStates.mipMapLoDBias, namedSamplerStates.borderColor);
	}
}

void DrawTextureState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	for (unsigned texID = 0; texID < MAX_NUM_SAMPLERS; ++texID)
	{
		// Skip all textures after 16 and before the DMAP sampler and VTEX samplers
		if (texID >= 16 && texID < D3DDMAPSAMPLER)
			continue;

		IDirect3DTexture9Hook* tex2D = deviceState.currentTextures[texID];
		IDirect3DCubeTexture9Hook* texCube = deviceState.currentCubeTextures[texID];
		IDirect3DVolumeTexture9Hook* tex3D = deviceState.currentVolumeTextures[texID];

		const unsigned printedLineNumber = texID >= 16 ? texID - (D3DDMAPSAMPLER - 16) : texID;

		char textureIndexString[16];
#pragma warning(push)
#pragma warning(disable:4996)
		switch (texID)
		{
		case D3DDMAPSAMPLER:
			strcpy(textureIndexString, "DMAP");
			break;
		case D3DVERTEXTEXTURESAMPLER0:
			strcpy(textureIndexString, "VTEX0");
			break;
		case D3DVERTEXTEXTURESAMPLER1:
			strcpy(textureIndexString, "VTEX1");
			break;
		case D3DVERTEXTEXTURESAMPLER2:
			strcpy(textureIndexString, "VTEX2");
			break;
		case D3DVERTEXTEXTURESAMPLER3:
			strcpy(textureIndexString, "VTEX3");
			break;
		default:
			sprintf(textureIndexString, "Tex%u", texID);
			break;
		}
#pragma warning(pop)

		const bool allTexturesNull = (tex2D == NULL) && (texCube == NULL) && (tex3D == NULL);
		if (allTexturesNull)
		{
			OverlayDrawPrintString(hookDev, 0, (1 + printedLineNumber) - currentLineOffset, stateEnabledColor, "%s: NULL", textureIndexString);
			continue;
		}

		const char* textureType = NULL;
		char resolutionBuffer[32] = {0};
		D3DFORMAT format = D3DFMT_UNKNOWN;
		unsigned mipLevels = 0;
		D3DPOOL pool = D3DPOOL_DEFAULT;
		DebuggableUsage usage = UsageNone;
#pragma warning(push)
#pragma warning(disable:4996)
		if (tex2D)
		{
			textureType = "2D";
			sprintf(resolutionBuffer, "%ux%u", tex2D->GetInternalWidth(), tex2D->GetInternalHeight() );
			format = tex2D->GetInternalFormat();
			mipLevels = tex2D->GetInternalMipLevels();
			usage = tex2D->GetInternalUsage();
			pool = tex2D->GetInternalPool();
		}
		else if (texCube)
		{
			textureType = "Cube";
			sprintf(resolutionBuffer, "%ux%ux6", texCube->GetInternalEdgeLength(), texCube->GetInternalEdgeLength() );
			format = texCube->GetInternalFormat();
			mipLevels = texCube->GetInternalMipLevels();
			usage = texCube->GetInternalUsage();
			pool = texCube->GetInternalPool();
		}
		else if (tex3D)
		{
			textureType = "3D";
			sprintf(resolutionBuffer, "%ux%ux%u", tex3D->GetInternalWidth(), tex3D->GetInternalHeight(), tex3D->GetInternalDepth() );
			format = tex3D->GetInternalFormat();
			mipLevels = tex3D->GetInternalMipLevels();
			usage = tex3D->GetInternalUsage();
			pool = tex3D->GetInternalPool();
		}
#pragma warning(pop)

		const char* formatString = NULL;
		formatString = GetAbbreviatedFormatStringFromFormat(format);

		const char* poolString = NULL;
		switch (pool)
		{
		case D3DPOOL_DEFAULT:
			poolString = "D";
			break;
		case D3DPOOL_MANAGED:
			poolString = "M";
			break;
		case D3DPOOL_SYSTEMMEM:
			poolString = "SM";
			break;
		case D3DPOOL_SCRATCH:
			poolString = "SC";
			break;
		default:
			poolString = "?";
			break;
		}

		OverlayDrawPrintString(hookDev, 0, (1 + printedLineNumber) - currentLineOffset, stateEnabledColor, "%s %s %s %u mip %s (%u) [%s] 0x%08X", textureIndexString, textureType, resolutionBuffer, mipLevels, formatString, format, poolString, usage);
	}
}

static inline const char* const GetMaterialSourceString(const D3DMATERIALCOLORSOURCE source)
{
	switch (source)
	{
	case D3DMCS_MATERIAL:
		return "MATERIAL";
	case D3DMCS_COLOR1:
		return "DIFFUSE";
	case D3DMCS_COLOR2:
		return "SPECULAR";
	default:
		return "Unknown";
	}
}

void DrawMaterialLightingState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	const RenderStates::_renderStatesUnion::_namedStates& namedRenderStates = deviceState.currentRenderStates.renderStatesUnion.namedStates;

	const bool lightingEnabled = namedRenderStates.lighting;
	const D3DCOLOR lightingEnabledColor = lightingEnabled ? stateEnabledColor : stateDisabledColor;

	OverlayDrawPrintString(hookDev, 0, 1 - currentLineOffset, stateEnabledColor, "Lighting Enabled: %s", lightingEnabled ? "TRUE" : "FALSE");

	OverlayDrawPrintString(hookDev, 0, 2 - currentLineOffset, lightingEnabledColor, "Diffuse Source: %s", GetMaterialSourceString(namedRenderStates.diffuseMaterialSource) );
	OverlayDrawPrintString(hookDev, 0, 3 - currentLineOffset, lightingEnabledColor, "Ambient Source: %s", GetMaterialSourceString(namedRenderStates.ambientMaterialSource) );
	OverlayDrawPrintString(hookDev, 0, 4 - currentLineOffset, lightingEnabledColor, "Specular Source: %s", GetMaterialSourceString(namedRenderStates.specularMaterialSource) );
	OverlayDrawPrintString(hookDev, 0, 5 - currentLineOffset, lightingEnabledColor, "Emissive Source: %s", GetMaterialSourceString(namedRenderStates.emissiveMaterialSource) );
	OverlayDrawPrintString(hookDev, 0, 6 - currentLineOffset, lightingEnabledColor, "Global Ambient Color: 0x%08X", namedRenderStates.ambient);
	OverlayDrawPrintString(hookDev, 0, 7 - currentLineOffset, lightingEnabledColor, "Local Viewer Enabled: %s", namedRenderStates.localViewer ? "TRUE" : "FALSE");
	OverlayDrawPrintString(hookDev, 0, 8 - currentLineOffset, lightingEnabledColor, "Specular Enabled: %s", namedRenderStates.specularEnable ? "TRUE" : "FALSE");
	OverlayDrawPrintString(hookDev, 0, 9 - currentLineOffset, lightingEnabledColor, "Color Vertex Enabled: %s", namedRenderStates.colorVertex ? "TRUE" : "FALSE");
	OverlayDrawPrintString(hookDev, 0, 10 - currentLineOffset, stateEnabledColor, "NormalizeNormals Enabled: %s", namedRenderStates.normalizeNormals ? "TRUE" : "FALSE");

	OverlayDrawPrintString(hookDev, 0, 11 - currentLineOffset, lightingEnabledColor, "Current Material:\n"
		"Diffuse RGBA: (%f, %f, %f, %f)\n"
		"Ambient RGBA: (%f, %f, %f, %f)\n"
		"Specular RGBA: (%f, %f, %f, %f)\n"
		"Emissive RGBA: (%f, %f, %f, %f)\n"
		"Power: %f",
		deviceState.currentMaterial.Diffuse.r, deviceState.currentMaterial.Diffuse.g, deviceState.currentMaterial.Diffuse.b, deviceState.currentMaterial.Diffuse.a,
		deviceState.currentMaterial.Ambient.r, deviceState.currentMaterial.Ambient.g, deviceState.currentMaterial.Ambient.b, deviceState.currentMaterial.Ambient.a,
		deviceState.currentMaterial.Specular.r, deviceState.currentMaterial.Specular.g, deviceState.currentMaterial.Specular.b, deviceState.currentMaterial.Specular.a,
		deviceState.currentMaterial.Emissive.r, deviceState.currentMaterial.Emissive.g, deviceState.currentMaterial.Emissive.b, deviceState.currentMaterial.Emissive.a,
		deviceState.currentMaterial.Power);
}

static const char* const indentSpaces = "                                ";
static inline void PrintTransform4x4(IDirect3DDevice9Hook* const hookDev, const D3DXMATRIXA16& matrix, const unsigned short currentLine, const char* const label, const int index = -1)
{
	char labelNumberAppended[64] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
	if (index >= 0)
		sprintf(labelNumberAppended, "%s%i", label, index);
	else
		sprintf(labelNumberAppended, "%s", label);
#pragma warning(pop)

	const unsigned indentLength = strlen(labelNumberAppended);
	if (indentLength >= 32)
	{
#ifdef _DEBUG
		__debugbreak(); // What the heck?
#endif
		return;
	}
	const char* const indentStr = indentSpaces + (32 - indentLength);

	OverlayDrawPrintString(hookDev, 0, currentLine, stateEnabledColor, 
		"%s: { %4.4f, %4.4f, %4.4f, %4.4f }\n"
		"%s  { %4.4f, %4.4f, %4.4f, %4.4f }\n"
		"%s  { %4.4f, %4.4f, %4.4f, %4.4f }\n"
		"%s  { %4.4f, %4.4f, %4.4f, %4.4f }",
		labelNumberAppended, matrix.m[0][0], matrix.m[0][1], matrix.m[0][2], matrix.m[0][3], 
		indentStr, matrix.m[1][0], matrix.m[1][1], matrix.m[1][2], matrix.m[1][3], 
		indentStr, matrix.m[2][0], matrix.m[2][1], matrix.m[2][2], matrix.m[2][3], 
		indentStr, matrix.m[3][0], matrix.m[3][1], matrix.m[3][2], matrix.m[3][3]);
}

void DrawTransformsState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	PrintTransform4x4(hookDev, deviceState.currentTransforms.WorldTransforms[0], 1 - currentLineOffset, "World", 0);
	PrintTransform4x4(hookDev, deviceState.currentTransforms.ViewTransform, 5 - currentLineOffset, "View", -1);
	PrintTransform4x4(hookDev, deviceState.currentTransforms.ProjectionTransform, 9 - currentLineOffset, "Proj", -1);

	for (int texID = 0; texID < ARRAYSIZE(deviceState.currentTransforms.TextureTransforms); ++texID)
	{
		const unsigned baseTexTransformLineOffset = 13 + texID * 4;
		PrintTransform4x4(hookDev, deviceState.currentTransforms.TextureTransforms[texID], baseTexTransformLineOffset - currentLineOffset, "TexMat", texID);
	}

	const unsigned baseWorldTransformLineOffset = 13 + ARRAYSIZE(deviceState.currentTransforms.TextureTransforms) * 4;
	for (int worldID = 0; worldID < ARRAYSIZE(deviceState.currentTransforms.WorldTransforms); ++worldID)
	{
		const unsigned thisWorldTransformLineOffset = baseWorldTransformLineOffset + worldID * 4;
		PrintTransform4x4(hookDev, deviceState.currentTransforms.WorldTransforms[worldID], thisWorldTransformLineOffset - currentLineOffset, "World", worldID);
	}
}

void DrawVSConstantsState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	unsigned currentLine = 1;
	for (unsigned i = 0; i < ARRAYSIZE(deviceState.vertexShaderRegisters.ints); ++i)
	{
		const int4& thisReg = deviceState.vertexShaderRegisters.ints[i];
		OverlayDrawPrintString(hookDev, 0, currentLine++ - currentLineOffset, stateEnabledColor, "i%02u: (%i, %i, %i, %i)", i, thisReg.x, thisReg.y, thisReg.z, thisReg.w);
	}

	for (unsigned b = 0; b < ARRAYSIZE(deviceState.vertexShaderRegisters.bools); ++b)
	{
		const BOOL thisReg = deviceState.vertexShaderRegisters.bools[b];
		OverlayDrawPrintString(hookDev, 0, currentLine++ - currentLineOffset, stateEnabledColor, "b%02u: (%s)", b, thisReg ? "TRUE" : "FALSE");
	}

	for (unsigned f = 0; f < ARRAYSIZE(deviceState.vertexShaderRegisters.floats); ++f)
	{
		const float4& thisReg = deviceState.vertexShaderRegisters.floats[f];
		OverlayDrawPrintString(hookDev, 0, currentLine++ - currentLineOffset, stateEnabledColor, "c%03u: (%4.5f, %4.5f, %4.5f, %4.5f)", f, thisReg.x, thisReg.y, thisReg.z, thisReg.w);
	}
}

void DrawPSConstantsState(IDirect3DDevice9Hook* const hookDev, const DeviceState& deviceState, const unsigned short currentLineOffset)
{
	unsigned currentLine = 1;
	for (unsigned i = 0; i < ARRAYSIZE(deviceState.pixelShaderRegisters.ints); ++i)
	{
		const int4& thisReg = deviceState.pixelShaderRegisters.ints[i];
		OverlayDrawPrintString(hookDev, 0, currentLine++ - currentLineOffset, stateEnabledColor, "i%02u: (%i, %i, %i, %i)", i, thisReg.x, thisReg.y, thisReg.z, thisReg.w);
	}

	for (unsigned b = 0; b < ARRAYSIZE(deviceState.pixelShaderRegisters.bools); ++b)
	{
		const BOOL thisReg = deviceState.pixelShaderRegisters.bools[b];
		OverlayDrawPrintString(hookDev, 0, currentLine++ - currentLineOffset, stateEnabledColor, "b%02u: (%s)", b, thisReg ? "TRUE" : "FALSE");
	}

	for (unsigned f = 0; f < ARRAYSIZE(deviceState.pixelShaderRegisters.floats); ++f)
	{
		const float4& thisReg = deviceState.pixelShaderRegisters.floats[f];
		OverlayDrawPrintString(hookDev, 0, currentLine++ - currentLineOffset, stateEnabledColor, "c%03u: (%4.5f, %4.5f, %4.5f, %4.5f)", f, thisReg.x, thisReg.y, thisReg.z, thisReg.w);
	}
}

```

`Software_d3d9/Overlay/Overlay_WelcomeScreen.cpp`:

```cpp
#include "DebugOverlay.h"
#include "..\IDirect3DDevice9Hook.h"

void UpdateAndDrawOverlay_WelcomeScreen(class IDirect3DDevice9Hook* const hookDev)
{
	OverlaySetDeviceStateForText(hookDev);

	OverlayDrawString(hookDev, "Welcome!\n"
		"Press Ctrl + Shift + F8 at any time to disable all\n"
		"overlays.\n"
		"\n"
		"Overlays menu:\n"
		"0: Welcome Screen\n"
		"1: Device State\n", 0, 0, D3DCOLOR_ARGB(255, 255, 255, 255) );

	if (GetAsyncKeyState('0') & 0x1)
		SetOverlayScreenState(hookDev, overlay_welcomeScreen);
	else if (GetAsyncKeyState('1') & 0x1)
		SetOverlayScreenState(hookDev, overlay_deviceState);
}

```

`Software_d3d9/PShaderEngine.cpp`:

```cpp
#pragma once

#include "PShaderEngine.h"
#include "ShaderAnalysis.h"
#include "IDirect3DDevice9Hook.h"
#include "IDirect3DPixelShader9Hook.h"
#include "IDirect3DTexture9Hook.h"

void PShaderEngine::WriteDstParameter(const DWORD rawDstBytecode, const D3DXVECTOR4& value)
{
	D3DXVECTOR4& out = ResolveDstParameter(rawDstBytecode);
	const dstParameterToken& dstParameter = *(const dstParameterToken* const)&rawDstBytecode;
	const unsigned writeMask = dstParameter.GetWriteMask();
	if (dstParameter.GetResultModifierUnshifted() & D3DSPDM_SATURATE) // Saturate
	{
		switch (writeMask)
		{
		case 0:
#ifdef _DEBUG
			DbgBreakPrint("Error: Zero write mask"); // Should never be here
#endif
			break;
		case 0x1:
			out.x = saturate(value.x);
			break;
		case 0x3:
			out.x = saturate(value.x);
			// Intentional fallthrough
		case 0x2:
			out.y = saturate(value.y);
			break;
		case 0x7:
			out.x = saturate(value.x);
			// Intentional fallthrough
		case 0x6:
			out.y = saturate(value.y);
			// Intentional fallthrough
		case 0x4:
			out.z = saturate(value.z);
			break;
		case 0x5:
			out.x = saturate(value.x);
			out.z = saturate(value.z);
			break;
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Out of range write mask");
#endif
		case 0xF: // The most common case, all bits are set!
			out.x = saturate(value.x);
			// Intentional fallthrough
		case 0xE: // 14
			out.y = saturate(value.y);
			// Intentional fallthrough
		case 0xC: // 12
			out.z = saturate(value.z);
			// Intentional fallthrough
		case 0x8:
			out.w = saturate(value.w);
			break;
		case 0x9:
			out.x = saturate(value.x);
			out.w = saturate(value.w);
			break;
		case 0xA: // 10
			out.y = saturate(value.y);
			out.w = saturate(value.w);
			break;
		case 0xB: // 11
			out.x = saturate(value.x);
			out.y = saturate(value.y);
			out.w = saturate(value.w);
			break;
		case 0xD: // 13
			out.x = saturate(value.x);
			out.z = saturate(value.z);
			out.w = saturate(value.w);
			break;
		}
	}
	else // No saturates
	{
		switch (writeMask)
		{
		case 0:
#ifdef _DEBUG
			DbgBreakPrint("Error: Zero write mask"); // Should never be here
#endif
			break;
		case 0x1:
			out.x = value.x;
			break;
		case 0x3:
			out.x = value.x;
			// Intentional fallthrough
		case 0x2:
			out.y = value.y;
			break;
		case 0x7:
			out.x = value.x;
			// Intentional fallthrough
		case 0x6:
			out.y = value.y;
			// Intentional fallthrough
		case 0x4:
			out.z = value.z;
			break;
		case 0x5:
			out.x = value.x;
			out.z = value.z;
			break;
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Out of range write mask!");
#endif
		case 0xF: // The most common case, all bits are set!
			out.x = value.x;
			// Intentional fallthrough
		case 0xE: // 14
			out.y = value.y;
			// Intentional fallthrough
		case 0xC: // 12
			out.z = value.z;
			// Intentional fallthrough
		case 0x8:
			out.w = value.w;
			break;
		case 0x9:
			out.x = value.x;
			out.w = value.w;
			break;
		case 0xA: // 10
			out.y = value.y;
			out.w = value.w;
			break;
		case 0xB: // 11
			out.x = value.x;
			out.y = value.y;
			out.w = value.w;
			break;
		case 0xD: // 13
			out.x = value.x;
			out.z = value.z;
			out.w = value.w;
			break;
		}
	}
}

D3DXVECTOR4& PShaderEngine::ResolveDstParameter(const DWORD rawDstBytecode)
{
	const dstParameterToken& dstParameter = *(const dstParameterToken* const)&rawDstBytecode;
	const unsigned index = dstParameter.GetRegisterIndex();
	switch (dstParameter.GetRegisterType() )
	{
	case D3DSPR_TEMP       :
#ifdef _DEBUG
		if (index >= ARRAYSIZE(PS_2_0_RuntimeRegisters::r) )
		{
			__debugbreak(); // Out of bounds register index
		}
#endif
		return runtimeRegisters[0].r[index];
	case D3DSPR_INPUT      :
#ifdef _DEBUG
		__debugbreak(); // input registers can't be dst registers
#endif
		return *(D3DXVECTOR4* const)&(inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.v[index]);
	case D3DSPR_CONST      :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst parameters
#endif
		return const_cast<D3DXVECTOR4&>(constantRegisters->c[index]);
	case D3DSPR_TEXTURE       : // Also known as D3DSPR_ADDR (VS)
#ifdef _DEBUG
		if (shaderInfo->shaderMajorVersion > 1)
		{
			__debugbreak(); // Input texcoord registers can't be dst parameters since ps_2_0
		}
#endif
		return *(D3DXVECTOR4* const)&(inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.t[index]);
	case D3DSPR_RASTOUT    :
	case D3DSPR_ATTROUT    :
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
	case D3DSPR_COLOROUT   :
#ifdef _DEBUG
		if (index >= ARRAYSIZE(PS_2_0_OutputRegisters::oC) )
		{
			__debugbreak(); // Out of bounds register index
		}
#endif
		return *(D3DXVECTOR4* const)&(outputRegisters[0].oC[index]);
	case D3DSPR_CONSTINT   :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst registers
#endif
		return *(D3DXVECTOR4* const)&constantRegisters->i[index];
	case D3DSPR_DEPTHOUT   :
		return *(D3DXVECTOR4* const)&outputRegisters[0].oDepth;
	case D3DSPR_SAMPLER    :
#ifdef _DEBUG
		DbgBreakPrint("Error: Sampler register cannot be destination parameter");
#endif
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
#ifdef _DEBUG
		DbgBreakPrint("Error: Constant registers beyond 1024 are not supported, also const registers can't be used as dst registers!");
#endif
	case D3DSPR_CONSTBOOL  :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst parameters
#endif
		return *(D3DXVECTOR4* const)&constantRegisters->b[index];
	case D3DSPR_LOOP       :
#ifdef _DEBUG
		DbgBreakPrint("Error: Loop register cannot be destination parameter");
#endif
	case D3DSPR_TEMPFLOAT16:
#ifdef _DEBUG
		DbgBreakPrint("Error: TempFloat16 register cannot be destination parameter");
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_MISCTYPE   : // VPOS and VFACE
#ifdef _DEBUG
		__debugbreak(); // Special input registers can't be dst parameters
#endif
		return *(&(miscRegisters[0].vPos) + index);
	case D3DSPR_LABEL      :
#ifdef _DEBUG
		DbgBreakPrint("Error: Label register cannot be destination parameter");
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_PREDICATE  :
		return *(D3DXVECTOR4* const)&runtimeRegisters[0].p0;
	default:
#ifdef _DEBUG
		{
			DbgBreakPrint("Error: Undefined destination register type");
		}
#else
			__assume(0);
#endif
	}
	return *(D3DXVECTOR4* const)NULL;
}

const float PShaderEngine::ResolveSrcReplicateSwizzle(const DWORD rawSrcBytecode, const D3DXVECTOR4& registerData) const
{
	const srcParameterToken& srcParameter = *(const srcParameterToken* const)&rawSrcBytecode;
	const float* const fRegisterData = (const float* const)&registerData;
	return fRegisterData[srcParameter.GetChannelSwizzle()];
}

const D3DXVECTOR4 PShaderEngine::ResolveSrcRegister(const DWORD rawSrcBytecode) const
{
	const srcParameterToken& srcParameter = *(const srcParameterToken* const)&rawSrcBytecode;
	const D3DXVECTOR4& sourceParam = ResolveSrcParameter(rawSrcBytecode);
	const unsigned char sourceSwizzle = srcParameter.GetSwizzle();

	D3DXVECTOR4 ret;

	if (sourceSwizzle == (D3DVS_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT) )
	{
		ret = sourceParam;
	}
	else
	{
		const float* const fltParams = &sourceParam.x;
		ret.x = fltParams[sourceSwizzle & 0x3]; // R channel
		ret.y = fltParams[(sourceSwizzle >> 2) & 0x3]; // G channel
		ret.z = fltParams[(sourceSwizzle >> 4) & 0x3]; // B channel
		ret.w = fltParams[(sourceSwizzle >> 6) & 0x3]; // A channel
	}

	switch (srcParameter.GetSourceModifiersUnshifted() )
	{
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Undefined register source modifier");
#endif
	case D3DSPSM_NONE   :
		return ret;
	case D3DSPSM_NEG    :
		ret *= -1.0f;
		break;
	case D3DSPSM_BIAS   :
		ret.x -= 0.5f;
		ret.y -= 0.5f;
		ret.z -= 0.5f;
		ret.w -= 0.5f;
		break;
	case D3DSPSM_BIASNEG:
		ret.x -= 0.5f;
		ret.y -= 0.5f;
		ret.z -= 0.5f;
		ret.w -= 0.5f;
		ret *= -1.0f;
		break;
	case D3DSPSM_SIGN   :
		ret.x -= 0.5f;
		ret.y -= 0.5f;
		ret.z -= 0.5f;
		ret.w -= 0.5f;
		ret *= 2.0f;
		break;
	case D3DSPSM_SIGNNEG:
		ret.x -= 0.5f;
		ret.y -= 0.5f;
		ret.z -= 0.5f;
		ret.w -= 0.5f;
		ret *= -2.0f;
		break;
	case D3DSPSM_COMP   :
		ret.x = 1.0f - ret.x;
		ret.y = 1.0f - ret.y;
		ret.z = 1.0f - ret.z;
		ret.w = 1.0f - ret.w;
		break;
	case D3DSPSM_X2     :
		ret *= 2.0f;
		break;
	case D3DSPSM_X2NEG  :
		ret *= -2.0f;
		break;
	case D3DSPSM_DZ     :
	{
		const float invZ = 1.0f / ret.z;
		ret.x *= invZ;
		ret.y *= invZ;
	}
		break;
	case D3DSPSM_DW     :
	{
		const float invW = 1.0f / ret.w;
		ret.x *= invW;
		ret.y *= invW;
	}
		break;
	case D3DSPSM_ABS    :
		ret.x = fabsf(ret.x);
		ret.y = fabsf(ret.y);
		ret.z = fabsf(ret.z);
		ret.w = fabsf(ret.w);
		break;
	case D3DSPSM_ABSNEG :
		ret.x = -fabsf(ret.x);
		ret.y = -fabsf(ret.y);
		ret.z = -fabsf(ret.z);
		ret.w = -fabsf(ret.w);
		break;
	case D3DSPSM_NOT    :
	{
		BOOL* const boolPtr = (BOOL* const)&ret.x;
		*boolPtr = !*boolPtr;
	}
		break;
	}

	return ret;
}

const D3DXVECTOR4& PShaderEngine::ResolveSrcParameter(const DWORD rawSrcBytecode) const
{
	const srcParameterToken& srcParameter = *(const srcParameterToken* const)&rawSrcBytecode;
	const unsigned index = srcParameter.GetRegisterIndex();
	switch (srcParameter.GetRegisterType() )
	{
	case D3DSPR_TEMP       :
		return runtimeRegisters[0].r[index];
	case D3DSPR_INPUT      :
		return *(const D3DXVECTOR4* const)&(inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.v[index]);
	case D3DSPR_CONST      :
		return constantRegisters->c[index];
	case D3DSPR_TEXTURE       : // Also known as D3DSPR_ADDR (VS)
		return *(const D3DXVECTOR4* const)&(inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.t[index]);
	case D3DSPR_RASTOUT    :
#ifdef _DEBUG
		DbgBreakPrint("Error: RASTOUT register is not a valid Source parameter");
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_ATTROUT    :
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
	case D3DSPR_COLOROUT   :
		return *(const D3DXVECTOR4* const)&(outputRegisters[0].oC[index]);
	case D3DSPR_CONSTINT   :
		return *(const D3DXVECTOR4* const)&constantRegisters->i[index];
	case D3DSPR_DEPTHOUT   :
		return *(const D3DXVECTOR4* const)&outputRegisters[0].oDepth;
	case D3DSPR_SAMPLER    :
		return *(const D3DXVECTOR4* const)&constantRegisters->s[index];
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
#ifdef _DEBUG
		DbgBreakPrint("Error: Constant indices beyond 1024 are not supported");
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_CONSTBOOL  :
		return *(const D3DXVECTOR4* const)&constantRegisters->b[index];
	case D3DSPR_LOOP       :
#ifdef _DEBUG
		DbgBreakPrint("Error: Loop register is not a valid source parameter");
#endif
	case D3DSPR_TEMPFLOAT16:
#ifdef _DEBUG
		DbgBreakPrint("Error: TempFloat16 register is not a valid source parameter");
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_MISCTYPE   : // VPOS and VFACE
		return *(&(miscRegisters[0].vPos) + index);
	case D3DSPR_LABEL      :
#ifdef _DEBUG
		DbgBreakPrint("Error: Label register is not a valid source parameter");
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_PREDICATE  :
		return *(const D3DXVECTOR4* const)&runtimeRegisters[0].p0;
	default:
#ifdef _DEBUG
		{
			DbgBreakPrint("Error: Undefined source parameter register type");
		}
#else
			__assume(0);
#endif
	}
	return *(const D3DXVECTOR4* const)NULL;
}

// Called once at device reset time
void PShaderEngine::GlobalInit(const PS_2_0_ConstantsBuffer* const _constantRegisters)
{
	memset(this, 0, sizeof(*this) );

	GlobalInitTex2DFunctionTable();

	miscRegisters[0].vFace.x = 1.0f;
	miscRegisters[1].vFace.x = 1.0f;
	miscRegisters[2].vFace.x = 1.0f;
	miscRegisters[3].vFace.x = 1.0f;

	constantRegisters = _constantRegisters;
}

void PShaderEngine::Init(const DeviceState& deviceState, const ShaderInfo& _shaderInfo, PS_2_0_ConstantsBuffer* const mutableConstantRegisters)
{
	shaderInfo = &_shaderInfo;

#ifdef _DEBUG
	if (!deviceState.currentPixelShader)
	{
		DbgBreakPrint("Error: Cannot run pixel shader with SetPixelShader(NULL)");
	}
#endif
	instructionPtr = _shaderInfo.firstInstructionToken;

	const DeviceState_ShaderRegisters& globalPixelShaderConstants = deviceState.pixelShaderRegisters;

	InitGlobalConstants(globalPixelShaderConstants, mutableConstantRegisters);

	// Local constants ("immediate constants") always take precedence over global constants: https://msdn.microsoft.com/en-us/library/windows/desktop/bb205596(v=vs.85).aspx
	InitLocalConstants(_shaderInfo, mutableConstantRegisters);

	InitSamplers(deviceState, mutableConstantRegisters);
}

void PShaderEngine::InitGlobalConstants(const DeviceState_ShaderRegisters& globalPixelShaderConstants, PS_2_0_ConstantsBuffer* const mutableConstantRegisters)
{
	memcpy(&mutableConstantRegisters->c, &globalPixelShaderConstants.floats, sizeof(D3DXVECTOR4) * ARRAYSIZE(PS_2_0_ConstantsBuffer::c) );
	memcpy(&mutableConstantRegisters->b, &globalPixelShaderConstants.bools, sizeof(BOOL) * ARRAYSIZE(PS_2_0_ConstantsBuffer::b) );
	memcpy(&mutableConstantRegisters->i, &globalPixelShaderConstants.ints, sizeof(int4) * ARRAYSIZE(PS_2_0_ConstantsBuffer::i) );
}

void PShaderEngine::InitLocalConstants(const ShaderInfo& pixelShaderInfo, PS_2_0_ConstantsBuffer* const mutableConstantRegisters)
{
	// Floats
	{
		const unsigned numFloatConsts = pixelShaderInfo.initialConstantValues.size();
		for (unsigned x = 0; x < numFloatConsts; ++x)
		{
			const InitialConstantValue& constF = pixelShaderInfo.initialConstantValues[x];
			mutableConstantRegisters->c[constF.constantRegisterIndex] = constF.initialValue;
		}
	}

	// Bools
	{
		const unsigned numBoolConsts = pixelShaderInfo.initialConstantValuesB.size();
		for (unsigned x = 0; x < numBoolConsts; ++x)
		{
			const InitialConstantValueB& constB = pixelShaderInfo.initialConstantValuesB[x];
			mutableConstantRegisters->b[constB.constantRegisterIndex] = constB.initialValue;
		}
	}

	// Ints
	{
		const unsigned numIntConsts = pixelShaderInfo.initialConstantValuesI.size();
		for (unsigned x = 0; x < numIntConsts; ++x)
		{
			const InitialConstantValueI& constI = pixelShaderInfo.initialConstantValuesI[x];
			mutableConstantRegisters->i[constI.constantRegisterIndex] = constI.initialValue;
		}
	}
}

void PShaderEngine::InitSamplers(const DeviceState& deviceState, PS_2_0_ConstantsBuffer* const mutableConstantRegisters)
{
	for (unsigned x = 0; x < ARRAYSIZE(PS_2_0_ConstantsBuffer::s); ++x)
	{
		sampler& thisSampler = mutableConstantRegisters->s[x];
		thisSampler.texture = deviceState.currentTextures[x];
		thisSampler.samplerState = deviceState.currentSamplerStates[x];
	}
}

// Called once for every pixel to reset the state of the interpreter to its default
void PShaderEngine::Reset(const unsigned x, const unsigned y)
{
	instructionPtr = shaderInfo->firstInstructionToken;

	miscRegisters[0].vPos.x = (const float)x;
	miscRegisters[0].vPos.y = (const float)y;

	outputRegisters[0].pixelStatus = normalWrite;

#ifdef _DEBUG
	// These values match the default GPR values in PIX
	for (unsigned registerIndex = 0; registerIndex < ARRAYSIZE(runtimeRegisters[0].r); ++registerIndex)
	{
		D3DXVECTOR4& vec = runtimeRegisters[0].r[registerIndex];
		vec.x = 1.0f;
		vec.y = 1.0f;
		vec.z = 1.0f;
		vec.w = 1.0f;
	}
#endif
}

// Called once for every quad of pixels to reset the state of the interpreter to its default
void PShaderEngine::Reset4(const __m128i x4, const __m128i y4)
{
	instructionPtr = shaderInfo->firstInstructionToken;

	const __m128 x4f = _mm_cvtepi32_ps(x4);
	const __m128 y4f = _mm_cvtepi32_ps(y4);

	miscRegisters[0].vPos.x = x4f.m128_f32[0];
	miscRegisters[1].vPos.x = x4f.m128_f32[1];
	miscRegisters[2].vPos.x = x4f.m128_f32[2];
	miscRegisters[3].vPos.x = x4f.m128_f32[3];
	miscRegisters[0].vPos.y = y4f.m128_f32[0];
	miscRegisters[1].vPos.y = y4f.m128_f32[1];
	miscRegisters[2].vPos.y = y4f.m128_f32[2];
	miscRegisters[3].vPos.y = y4f.m128_f32[3];

	outputRegisters[0].pixelStatus = normalWrite;
	outputRegisters[1].pixelStatus = normalWrite;
	outputRegisters[2].pixelStatus = normalWrite;
	outputRegisters[3].pixelStatus = normalWrite;

#ifdef _DEBUG
	// These values match the default GPR values in PIX
	for (unsigned pixelIndex = 0; pixelIndex < 4; ++pixelIndex)
	{
		for (unsigned registerIndex = 0; registerIndex < ARRAYSIZE(runtimeRegisters[pixelIndex].r); ++registerIndex)
		{
			D3DXVECTOR4& vec = runtimeRegisters[pixelIndex].r[registerIndex];
			vec.x = 1.0f;
			vec.y = 1.0f;
			vec.z = 1.0f;
			vec.w = 1.0f;
		}
	}
#endif
}

const shaderStatus PShaderEngine::InterpreterExecStep(void)
{
	const instructionToken rawInstructionToken = *(const instructionToken* const)instructionPtr++;
	const D3DSHADER_INSTRUCTION_OPCODE_TYPE currentOpcode = (const D3DSHADER_INSTRUCTION_OPCODE_TYPE)(rawInstructionToken.opcode);
	switch (currentOpcode)
	{
	case D3DSIO_NOP         :
		nop();
		break;
	case D3DSIO_MOV         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		WriteDstParameter(dstParam, src0);
	}
		break;
	case D3DSIO_ADD         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		add(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SUB         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		sub(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_MAD         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		mad(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_MUL         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		mul(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_RCP         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src = ResolveSrcRegister(*instructionPtr);
		const float f = ResolveSrcReplicateSwizzle(*instructionPtr++, src);
		D3DXVECTOR4 dst;
		rcp(dst, f);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_RSQ         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src = ResolveSrcRegister(*instructionPtr);
		const float f = ResolveSrcReplicateSwizzle(*instructionPtr++, src);
		D3DXVECTOR4 dst;
		rsq(dst, f);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DP3         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		dp3(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DP4         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		dp4(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_MIN         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		min(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_MAX         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		max(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SLT         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		slt(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SGE         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		sge(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_EXPP        :
	case D3DSIO_EXP         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src = ResolveSrcRegister(*instructionPtr);
		const float f = ResolveSrcReplicateSwizzle(*instructionPtr++, src);
		D3DXVECTOR4 dst;
		exp(dst, f);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_LOGP        :
	case D3DSIO_LOG         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src = ResolveSrcRegister(*instructionPtr);
		const float f = ResolveSrcReplicateSwizzle(*instructionPtr++, src);
		D3DXVECTOR4 dst;
		log(dst, f);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_LIT         : // Technically this instruction is only available to vertex shaders, but I don't see the harm in executing it if one does show up in a pixel shader for some reason
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		lit(dst, src0);
		WriteDstParameter(dstParam, dst);
	}
		break;

		// Technically this instruction is only available to vertex shaders, but I don't see the harm in executing it if one does show up in a pixel shader for some reason
	case D3DSIO_DST         : // TODO: Validate correctness of this (the docs seem incomplete and misleading)
	{
		const DWORD destParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dest;
		dst(dest, src0, src1);
		WriteDstParameter(destParam, dest);
	}
		break;
	case D3DSIO_LRP         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		lrp(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_FRC         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		frc(dst, src);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_M4x4        :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2 = *(&src1 + 1);
		const D3DXVECTOR4 src3 = *(&src1 + 2);
		const D3DXVECTOR4 src4 = *(&src1 + 3);
		D3DXVECTOR4 dst;
		m4x4(dst, src0, src1, src2, src3, src4);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_M4x3        :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2 = *(&src1 + 1);
		const D3DXVECTOR4 src3 = *(&src1 + 2);
		D3DXVECTOR4 dst;
		m4x3(dst, src0, src1, src2, src3);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_M3x4        :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2 = *(&src1 + 1);
		const D3DXVECTOR4 src3 = *(&src1 + 2);
		const D3DXVECTOR4 src4 = *(&src1 + 3);
		D3DXVECTOR4 dst;
		m3x4(dst, src0, src1, src2, src3, src4);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_M3x3        :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2 = *(&src1 + 1);
		const D3DXVECTOR4 src3 = *(&src1 + 2);
		D3DXVECTOR4 dst;
		m3x3(dst, src0, src1, src2, src3);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_M3x2        :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2 = *(&src1 + 1);
		D3DXVECTOR4 dst;
		m3x2(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_CALL        :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: CALL Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_CALLNZ      :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: CALLNZ Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_LOOP        :
	{
		const DWORD aLDst = *instructionPtr++;
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: LOOP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_RET         :
		DbgBreakPrint("Error: RET Shader function not yet implemented!"); // Not yet implemented!
		return normalCompletion;
	case D3DSIO_ENDLOOP     :
		DbgBreakPrint("Error: ENDLOOP Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_LABEL       :
	{
		// src0 contains the label index for this label
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		
		// Do nothing
	}
		break;
	case D3DSIO_DCL         :
		DbgBreakPrint("Error: DCL Should not be encountered during normal shader execution!");
		break;
	case D3DSIO_POW         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr);
		const float f0 = ResolveSrcReplicateSwizzle(*instructionPtr++, src0);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr);
		const float f1 = ResolveSrcReplicateSwizzle(*instructionPtr++, src1);
		D3DXVECTOR4 dst;
		pow(dst, f0, f1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_CRS         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		crs(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SGN         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1_unused = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2_unused = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		sgn(dst, src0, src1_unused, src2_unused);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_ABS         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		abs(dst, src0);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_NRM         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		nrm(dst, src0);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SINCOS      :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr);
		const srcParameterToken& srcParameter = *(const srcParameterToken* const)instructionPtr;
		const unsigned swizzleX = srcParameter.GetChannelSwizzleXYZW() & 0x3;
		const unsigned swizzleY = (srcParameter.GetChannelSwizzleXYZW() >> 2) & 0x3;
		const float f = ResolveSrcReplicateSwizzle(*instructionPtr++, src0);
		if (shaderInfo->shaderMajorVersion < 3) // Shader model 2 has these extra registers, but all the shader model 3+ don't have them
		{
			const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
			const D3DXVECTOR4 src2 = ResolveSrcRegister(*instructionPtr++);
		}
		D3DXVECTOR4 dst;
		if (swizzleX && swizzleY)
			sincos_sc(dst, f);
		else if (swizzleX)
			sincos_c(dst, f);
		else if (swizzleY)
			sincos_s(dst, f);
#ifdef _DEBUG
		else
		{
			// Whyyyyyyyyyyyyyyyy?
			DbgBreakPrint("Error: SINCOS function swizzle is undefined");
		}
#endif
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_REP         :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: REP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_ENDREP      :
		DbgBreakPrint("Error: ENDREP Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_IF          :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: IF Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_IFC         :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: IFC Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_ELSE        :
		DbgBreakPrint("Error: ELSE Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_ENDIF       :
		DbgBreakPrint("Error: ENDIF Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_BREAK       :
		DbgBreakPrint("Error: BREAK Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_BREAKC      :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: BREAKC Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_MOVA        : // This is a vs-only instruction
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: MOVA Instruction not available to pixel shaders!");
	}
		break;
	case D3DSIO_DEFB        :
		DbgBreakPrint("Error: DEFB Should not be encountered during normal shader execution!");
		break;
	case D3DSIO_DEFI        :
		DbgBreakPrint("Error: DEFI Should not be encountered during normal shader execution!");
		break;		
	case D3DSIO_TEXCOORD    :
	{
		const DWORD dstParam = *instructionPtr++;
		DbgBreakPrint("Error: TEXCOORD Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXKILL     :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4& dstValue = ResolveDstParameter(dstParam);
		const int4* const i4Value = (const int4* const)&dstValue;
		if ( (i4Value->x | i4Value->y | i4Value->z) < 0)
		{
			outputRegisters[0].pixelStatus = discard;
			return texkillStatus;
		}
		else
		{
			;
		}
	}
		break;
	case D3DSIO_TEX         : // Standard texture sampling with tex2D(), this is the same instruction as tex3Dproj/tex2Dproj/texldp and tex3Dbias/tex2Dbias/texldb
		// This instruction has three different source register counts (zero for ps_1_0 thru ps_1_3, one for ps_1_4, and two for shader model 2 and up)
	{
		const DWORD dstParam = *instructionPtr++;
		D3DXVECTOR4 src0;
		if (shaderInfo->shaderMajorVersion > 1 ||
			(shaderInfo->shaderMajorVersion == 1 && shaderInfo->shaderMinorVersion > 3) )
		{
			src0 = ResolveSrcRegister(*instructionPtr++);
		}
		const sampler* samplerPtr;
		if (shaderInfo->shaderMajorVersion > 1)
		{
			const D3DXVECTOR4& src1 = ResolveSrcParameter(*instructionPtr++);
			samplerPtr = (const sampler* const)&src1;
		}
		else
		{
			const dstParameterToken* const dstToken = (const dstParameterToken* const)&dstParam;

			if (shaderInfo->shaderMinorVersion < 4)
			{
				srcParameterToken newSrc0TexcoordToken;
				newSrc0TexcoordToken.internalRawToken = 0x00000000;
				newSrc0TexcoordToken.srcParameter.registerIndex = dstToken->GetRegisterIndex();
				newSrc0TexcoordToken.srcParameter.registerType_lowBits = D3DSPR_TEXTURE;
				newSrc0TexcoordToken.srcParameter.instructionParameterBit = parameterTokenMarker;
				newSrc0TexcoordToken.srcParameter.sourceSwizzle.fullSwizzle = _NoSwizzleXYZW;
				src0 = ResolveSrcRegister(newSrc0TexcoordToken.internalRawToken);
			}

			srcParameterToken newSrc1SamplerToken;
			newSrc1SamplerToken.internalRawToken = 0x00000000;
			newSrc1SamplerToken.srcParameter.registerIndex = dstToken->GetRegisterIndex();
			newSrc1SamplerToken.srcParameter.registerType_lowBits = D3DSPR_SAMPLER & 0x7;
			newSrc1SamplerToken.srcParameter.registerType_highBits = (D3DSPR_SAMPLER >> 3);
			newSrc1SamplerToken.srcParameter.instructionParameterBit = parameterTokenMarker;
			newSrc1SamplerToken.srcParameter.sourceSwizzle.fullSwizzle = _NoSwizzleXYZW;
			const D3DXVECTOR4& src1 = ResolveSrcParameter(newSrc1SamplerToken.internalRawToken);
			samplerPtr = (const sampler* const)&src1;
		}
		D3DXVECTOR4 dst;
		if (rawInstructionToken.opcodeControls == OpCtrl_TexLd_Bias) // tex2Dbias/texldb variant
		{
			// TODO: Calculate gradient on texcoords and pass along for mip-level computation
			const D3DXVECTOR4 grad_ddx_ddy(0.0f, 0.0f, 0.0f, 0.0f);
			tex2Dgrad<0xF, true>(dst, src0, grad_ddx_ddy, grad_ddx_ddy, samplerPtr);

			// TODO: src1 can have a swizzle that gets applied after the texture sample but before the write mask happens
		}
		else
		{
			if (rawInstructionToken.opcodeControls == OpCtrl_TexLd_Project) // tex2Dproj or texldp instruction variant has the texcoord divided by the texcoord.w component
			{
				const float invW = 1.0f / src0.w;
				src0.x *= invW;
				src0.y *= invW;
				src0.z *= invW;
				src0.w = 1.0f;
			}

			// TODO: Calculate gradient on texcoords and pass along for mip-level computation
			const D3DXVECTOR4 grad_ddx_ddy(0.0f, 0.0f, 0.0f, 0.0f);
			tex2Dgrad<0xF, false>(dst, src0, grad_ddx_ddy, grad_ddx_ddy, samplerPtr);

			// TODO: src1 can have a swizzle that gets applied after the texture sample but before the write mask happens
		}

		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_TEXBEM      :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXBEML     :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXBEML Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXREG2AR   :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXREG2AR Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXREG2GB   :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXREG2GB Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXM3x2PAD  :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXM3x2PAD Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXM3x2TEX  :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXM3x2TEX Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXM3x3PAD  :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXM3x3PAD Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXM3x3TEX  :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXM3x3TEX Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_RESERVED0   :
		DbgBreakPrint("Error: RESERVED0 Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_TEXM3x3SPEC :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXM3x3SPEC Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXM3x3VSPEC:
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXM3x3VSPEC Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_CND         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		cnd(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DEF         :
		DbgBreakPrint("Error: DEF Should not be encountered during normal shader execution!");
		break;
	case D3DSIO_TEXREG2RGB  :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXREG2RGB Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXDP3TEX   : // This is pretty complicated: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/texdp3tex---ps
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		srcParameterToken srcDst;
		srcDst.internalRawToken = 0x00000000;
		srcDst.srcParameter.instructionParameterBit = parameterTokenMarker;
		srcDst.srcParameter.registerIndex = dstParam.GetRegisterIndex();
		srcDst.srcParameter.registerType_lowBits = D3DSPR_TEXTURE;
		srcDst.srcParameter.sourceSwizzle.fullSwizzle = _NoSwizzleXYZW;
#ifdef _DEBUG
		if (dstParam.GetRegisterType() != D3DSPR_TEXTURE)
		{
			__debugbreak(); // Unexpected src/dst register type
		}
#endif
		const D3DXVECTOR4 texCoord = ResolveSrcRegister(srcDst.internalRawToken);

		srcParameterToken samplerSrc = srcDst;
		samplerSrc.srcParameter.registerType_lowBits = (D3DSPR_SAMPLER & 0x7);
		samplerSrc.srcParameter.registerType_highBits = ( (D3DSPR_SAMPLER >> 3) & 0x3);
		const D3DXVECTOR4& samplerTemp = ResolveSrcParameter(samplerSrc.internalRawToken);
		const sampler* const samplerPtr = (const sampler* const)&samplerTemp;

		// TODO: Calculate gradient on texcoords and pass along for mip-level computation
		const D3DXVECTOR4 grad_ddx_ddy(0.0f, 0.0f, 0.0f, 0.0f);
		float rampTexcoord;
		dp3(rampTexcoord, texCoord, src0);

		D3DXVECTOR4 tempDst;
		D3DXVECTOR4 rampTexcoord4(rampTexcoord, 0.0f, 0.0f, 0.0f);
		tex2Dgrad<0xF, false>(tempDst, rampTexcoord4, grad_ddx_ddy, grad_ddx_ddy, samplerPtr);

		WriteDstParameter(dstParam.internalRawToken, tempDst);
	}
		break;
	case D3DSIO_TEXM3x2DEPTH:
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXM3x2DEPTH Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXDP3      :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXDP3 Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXM3x3     :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: TEXM3x3 Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXDEPTH    :
	{
		const DWORD dstParam = *instructionPtr++;
		DbgBreakPrint("Error: TEXDEPTH Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_CMP         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		cmp(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_BEM         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: BEM Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_DP2ADD      :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;
		dp2add(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DSX         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;

		// Derivative is always zero for one-pixel warps (need at least a 2x2 quad warp to compute this)
		dsx(dst, src0);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DSY         :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		D3DXVECTOR4 dst;

		// Derivative is always zero for one-pixel warps (need at least a 2x2 quad warp to compute this)
		dsy(dst, src0);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_TEXLDD      : // tex2Dgrad()
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4& src1 = ResolveSrcParameter(*instructionPtr++);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src3 = ResolveSrcRegister(*instructionPtr++);
		const sampler* const samplerPtr = (const sampler* const)&src1;
		D3DXVECTOR4 dst;
		tex2Dgrad<0xF, false>(dst, src0, src2, src3, samplerPtr);

		// TODO: src1 can have a swizzle that gets applied after the texture sample but before the write mask happens

		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SETP        :
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: SETP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXLDL      : // tex2Dlod()
	{
		const DWORD dstParam = *instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		const D3DXVECTOR4& src1 = ResolveSrcParameter(*instructionPtr++);
		const sampler* const samplerPtr = (const sampler* const)&src1;
		D3DXVECTOR4 dst;
		tex2Dlod<0xF>(dst, src0, samplerPtr);

		// TODO: src1 can have a swizzle that gets applied after the texture sample but before the write mask happens

		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_BREAKP      :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(*instructionPtr++);
		DbgBreakPrint("Error: BREAKP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;		
	case D3DSIO_PHASE       :
		// Just do nothing, treat the whole shader as if it were a ps_2_0+ shader instead of a ps_1_4 shader
		break;
	case D3DSIO_COMMENT     :
	{
		const unsigned commentLengthDWORDs = (instructionPtr[-1] & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
		instructionPtr += commentLengthDWORDs; // Skip the comment block
	}
		break;
	case D3DSIO_END         :
		// We're done! We reached the end of the shader!
		outputRegisters[0].pixelStatus = normalWrite;
		return normalCompletion;
	default:
#ifdef _DEBUG
	{
		DbgBreakPrint("Error: Undefined shader opcode");
	}
#else
		__assume(0);
#endif
	}

	// Keep executing the shader
	return shouldContinueStatus;
}

void PShaderEngine::InterpreterExecutePixel(void)
{
	// Execute the shader:
	shaderStatus currentStatus = shouldContinueStatus;
	while (currentStatus == shouldContinueStatus)
	{
		currentStatus = InterpreterExecStep();
	}

	switch (currentStatus)
	{
	case shouldContinueStatus:
#ifdef _DEBUG
		DbgBreakPrint("Error: Pixel shader exited without finishing");
#endif
		return;
	case errorStatus:
#ifdef _DEBUG
		DbgBreakPrint("Error: Pixel shader exited with error");
#endif
		return;
	case texkillStatus:
		return;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Pixel shader exited with unknown status");
#endif
	case normalCompletion:
		// Do ps_1_* output register fixup (because ps_1_* outputs with register r0 instead of into one of the oC[N] registers):
		if (shaderInfo->shaderMajorVersion < 2)
		{
			outputRegisters[0].oC[0] = *(const float4* const)&runtimeRegisters[0].r[0];
		}
		return;
	}
}

```

`Software_d3d9/PShaderEngine.h`:

```h
#pragma once

#include "d3d9include.h"
#include "ShaderEngineBase.h"

class IDirect3DTexture9Hook;
struct DeviceState;
struct DeviceState_ShaderRegisters;
struct ShaderInfo;

#define MAX_NUM_PS_CONSTANTS 4096
#define MAX_NUM_PS_INPUTS 10

__declspec(align(16) ) struct PS_2_0_ConstantsBuffer
{
	D3DXVECTOR4 c[MAX_NUM_PS_CONSTANTS]; // Constant registers
	BOOL b[MAX_NUM_CONST_BOOL_REGISTERS]; // Constant boolean registers
	int4 i[MAX_NUM_CONST_INT_REGISTERS]; // Constant int registers
	sampler s[16]; // Samplers
};

__declspec(align(16) ) struct PS_2_0_InputRegisters
{
	union _ps_interpolated_inputs
	{
		struct _ps_2_0_inputs
		{
			__declspec(align(16) ) D3DCOLORVALUE v[D3DMCS_COLOR2]; // Input vertex color registers (0 = diffuse, 1 = specular)
			__declspec(align(16) ) D3DCOLORVALUE t[D3DDP_MAXTEXCOORD]; // Texcoord registers
		} ps_2_0_inputs;

		struct _ps_3_0_inputs
		{
			__declspec(align(16) ) D3DCOLORVALUE t[MAX_NUM_PS_INPUTS]; // Input interpolator registers
		} ps_3_0_inputs;
	} ps_interpolated_inputs;
};

__declspec(align(16) ) struct PS_2_0_RuntimeRegisters
{
	D3DXVECTOR4 r[MAX_NUM_TEMP_REGISTERS]; // Temporary GPR
	int4 p0; // Predicate register
	int aL; // Loop Counter Register (only exists in ps_3_0 and up)
};

enum pixelOutputStatus : unsigned // This needs to be a 32-bit enum so that we can use gather4 on it
{
	normalWrite,
	discard, // TEXKILL
	stencilFail,
	ZFail
};

__declspec(align(16) ) struct PS_2_0_OutputRegisters
{
	float4 oC[4]; // Output color registers (very important)
	float oDepth; // Output depth register
	pixelOutputStatus pixelStatus; // Was this pixel discarded or did it finish (or was it Z or Stencil-culled)?
};

__declspec(align(16) ) struct PS_2_0_MiscRegisters
{
	D3DXVECTOR4 vPos;
	D3DXVECTOR4 vFace;
};

enum shaderStatus : unsigned char
{
	shouldContinueStatus = 0,
	errorStatus = 1,
	texkillStatus = 2,
	normalCompletion = 3
};

__declspec(align(16) ) class PShaderEngine : public ShaderEngineBase
{
public:
	PShaderEngine() : constantRegisters(NULL)
	{
	}

	~PShaderEngine()
	{
		constantRegisters = NULL;
	}

	inline PShaderEngine& operator=(const PShaderEngine& rhs)
	{
		shaderInfo = rhs.shaderInfo;
		constantRegisters = rhs.constantRegisters;
		return *this;
	}

	inline void DeepCopy(const PShaderEngine& rhs)
	{
		memcpy(this, &rhs, sizeof(*this) );
	}

	// Called once for each shader instruction
	const shaderStatus InterpreterExecStep();

	// Called once at device reset time
	void GlobalInit(const PS_2_0_ConstantsBuffer* const _constantRegisters);

	// Called once at the beginning of processing a draw-call:
	void Init(const DeviceState& deviceState, const ShaderInfo& _shaderInfo, PS_2_0_ConstantsBuffer* const mutableConstantRegisters);

	// Called once for every pixel to reset the state of the interpreter to its default
	void Reset(const unsigned x, const unsigned y);

	// Called once for every quad of pixels to reset the state of the interpreter to its default
	void Reset4(const __m128i x4, const __m128i y4);

	void InterpreterExecutePixel(void);

	const PS_2_0_ConstantsBuffer* constantRegisters;
	__declspec(align(16) ) PS_2_0_InputRegisters inputRegisters[4];
	__declspec(align(16) ) PS_2_0_RuntimeRegisters runtimeRegisters[4];
	__declspec(align(16) ) PS_2_0_OutputRegisters outputRegisters[4];
	__declspec(align(16) ) PS_2_0_MiscRegisters miscRegisters[4];

	const INTRINSIC_INLINE D3DXVECTOR4& ResolveSrcAddressIfValid(const void* const addressPtr) const
	{
		if (addressPtr >= &constantRegisters->c[0] && addressPtr <= &constantRegisters->c[(MAX_NUM_PS_CONSTANTS - 1)])
			return *(const D3DXVECTOR4* const)addressPtr;
		else if (addressPtr >= &runtimeRegisters[0].r[0] && addressPtr <= &runtimeRegisters[0].r[(MAX_NUM_TEMP_REGISTERS - 1)])
			return *(const D3DXVECTOR4* const)addressPtr;
		else if (addressPtr >= &inputRegisters[0].ps_interpolated_inputs.ps_3_0_inputs.t[0] && addressPtr <= &inputRegisters[0].ps_interpolated_inputs.ps_3_0_inputs.t[MAX_NUM_PS_INPUTS - 1])
			return *(const D3DXVECTOR4* const)addressPtr;
		else
			// When reading outside of the constants buffer or the runtime registers the
			// constant (0,0,0,0) is always returned
			return ZEROVEC;
	}

	const INTRINSIC_INLINE D3DXVECTOR4& GetSrcRegisterFromAddress(const float4& baseRegister, const int addressOffset)
	{
		const float4* const targetRegister = &baseRegister + addressOffset;
		return ResolveSrcAddressIfValid(targetRegister);
	}

protected:
	void InitGlobalConstants(const DeviceState_ShaderRegisters& globalPixelShaderConstants, PS_2_0_ConstantsBuffer* const mutableConstantRegisters);
	void InitLocalConstants(const ShaderInfo& pixelShaderInfo, PS_2_0_ConstantsBuffer* const mutableConstantRegisters);
	void InitSamplers(const DeviceState& deviceState, PS_2_0_ConstantsBuffer* const mutableConstantRegisters);

	void WriteDstParameter(const DWORD rawDstBytecode, const D3DXVECTOR4& value);
	D3DXVECTOR4& ResolveDstParameter(const DWORD rawDstBytecode);
	const float ResolveSrcReplicateSwizzle(const DWORD rawSrcBytecode, const D3DXVECTOR4& registerData) const;
	const D3DXVECTOR4& ResolveSrcParameter(const DWORD rawSrcBytecode) const;
	const D3DXVECTOR4 ResolveSrcRegister(const DWORD rawSrcBytecode) const;
};

```

`Software_d3d9/SemanticMappings.cpp`:

```cpp
#pragma once

#include "SemanticMappings.h"
#include "IDirect3DVertexDeclaration9Hook.h"
#include "IDirect3DVertexShader9Hook.h"
#include "IDirect3DPixelShader9Hook.h"

// Computes a mapping between vertex streams and vertex shader inputs
void DeclarationSemanticMapping::ComputeMappingVS(const IDirect3DVertexDeclaration9Hook* const vertexDecl, const IDirect3DVertexShader9Hook* const vertexShader)
{
	const ShaderInfo& vertexShaderInfo = vertexShader->GetShaderInfo();
	const std::vector<DeclaredRegister>& declaredRegisters = vertexShaderInfo.declaredRegisters;
	const unsigned numDeclaredRegisters = declaredRegisters.size();
	for (unsigned x = 0; x < numDeclaredRegisters; ++x)
	{
		const DeclaredRegister& thisRegister = declaredRegisters[x];
		if (thisRegister.registerType == D3DSPR_INPUT)
		{
			const DebuggableD3DVERTEXELEMENT9* const element = vertexDecl->GetVertexElement(thisRegister.usageType, thisRegister.usageIndex);
			if (element)
			{
				// TODO: Make this work with multiple vertex streams
				vals[thisRegister.usageType][thisRegister.usageIndex] = element;
			}
		}
	}
}

// Computes a mapping between vertex shader outputs and the postransformed vertex declaration
void DeclarationSemanticMapping::ComputeMappingVStoPS(const IDirect3DVertexDeclaration9Hook* const vertexDecl, const IDirect3DVertexShader9Hook* const vertexShader)
{
	const ShaderInfo& vertexShaderInfo = vertexShader->GetShaderInfo();
	const std::vector<DeclaredRegister>& declaredRegisters = vertexShaderInfo.declaredRegisters;
	const unsigned numDeclaredRegisters = declaredRegisters.size();

	if (vertexShaderInfo.shaderMajorVersion == 3)
	{
		for (unsigned x = 0; x < numDeclaredRegisters; ++x)
		{
			const DeclaredRegister& thisRegister = declaredRegisters[x];
			if (thisRegister.registerType == D3DSPR_OUTPUT)
			{
				D3DDECLUSAGE outputUsage = thisRegister.usageType;
				if (outputUsage == D3DDECLUSAGE_POSITION)
					outputUsage = D3DDECLUSAGE_POSITIONT;
				const DebuggableD3DVERTEXELEMENT9* const element = vertexDecl->GetVertexElement(outputUsage, thisRegister.usageIndex);
				if (element)
				{
					// TODO: Make this work with multiple vertex streams
					vals[outputUsage][thisRegister.usageIndex] = element;
				}
#ifdef _DEBUG
				else
				{
					// Could not find usage + index in the stream! Maybe this vertex shader is bound to the wrong vertex declaration?
					OutputDebugStringA("Error: vs_3_0 Element could not be found in stream. Maybe this vertex shader is bound to the wrong pixel shader?\n");
				}
#endif
			}
		}
	}
	else if (vertexShaderInfo.shaderMajorVersion == 2)
	{
		const unsigned numWrittenRegisters = vertexShaderInfo.writtenOutputRegisters.size();
		for (unsigned x = 0; x < numWrittenRegisters; ++x)
		{
			const WrittenOutputRegister& writtenRegister = vertexShaderInfo.writtenOutputRegisters[x];
			D3DDECLUSAGE outputUsage = D3DDECLUSAGE_TEXCOORD;
			unsigned registerIndex = writtenRegister.registerIndex;
			switch (writtenRegister.registerType)
			{
			case D3DSPR_RASTOUT:
				switch (writtenRegister.registerIndex)
				{
				default:
#ifdef _DEBUG
					DbgBreakPrint("Error: Shader RASTOUT register type is undefined");
#endif
				case D3DSRO_POSITION:
					outputUsage = D3DDECLUSAGE_POSITIONT;
					registerIndex = 0;
					break;
				case D3DSRO_FOG:
					outputUsage = D3DDECLUSAGE_FOG;
					registerIndex = 0;
					break;
				case D3DSRO_POINT_SIZE:
					outputUsage = D3DDECLUSAGE_PSIZE;
					registerIndex = 0;
					break;
				}
				break;
			default:
#ifdef _DEBUG
				DbgBreakPrint("Error: Shader register type is undefined");
#endif
			case D3DSPR_ATTROUT:
				// Uhhhhhhhhhhhhh, let's just pretend we're a texcoord like everything else!
			case D3DSPR_TEXCRDOUT:
				outputUsage = D3DDECLUSAGE_TEXCOORD;
				break;
			case D3DSPR_COLOROUT:
				outputUsage = D3DDECLUSAGE_COLOR;
				break;
			case D3DSPR_DEPTHOUT:
				outputUsage = D3DDECLUSAGE_DEPTH;
				break;
			}

			const DebuggableD3DVERTEXELEMENT9* const element = vertexDecl->GetVertexElementOutput(outputUsage, writtenRegister.registerIndex);
			if (element)
			{
				vals[outputUsage][writtenRegister.registerIndex] = element;
			}
#ifdef _DEBUG
			else
			{
				// Could not find usage + index in the stream! Maybe this vertex shader is bound to the wrong vertex declaration?
				OutputDebugStringA("Error: vs_2_0 Element could not be found in stream. Maybe this vertex shader is bound to the wrong pixel shader?\n");
			}
#endif
		}
	}
#ifdef _DEBUG
	else
	{
		DbgBreakPrint("Error: Unknown pixel shader version (not 2 or 3)");
	}
#endif
}

// Computes a mapping between vertex streams and pixel shader inputs (for POSITIONT decls)
void DeclarationSemanticMapping::ComputeMappingPS(const IDirect3DVertexDeclaration9Hook* const vertexDecl, const IDirect3DPixelShader9Hook* const pixelShader)
{
	const ShaderInfo& pixelShaderInfo = pixelShader->GetShaderInfo();
	const std::vector<DeclaredRegister>& declaredRegisters = pixelShaderInfo.declaredRegisters;
	const unsigned numDeclaredRegisters = declaredRegisters.size();
	for (unsigned x = 0; x < numDeclaredRegisters; ++x)
	{
		const DeclaredRegister& thisRegister = declaredRegisters[x];
		if (pixelShaderInfo.shaderMajorVersion == 3)
		{
			if (thisRegister.registerType == D3DSPR_INPUT)
			{
				const DebuggableD3DVERTEXELEMENT9* const element = vertexDecl->GetVertexElement(thisRegister.usageType, thisRegister.usageIndex);
				if (element)
				{
					// TODO: Make this work with multiple vertex streams
					vals[thisRegister.usageType][thisRegister.usageIndex] = element;
				}
#ifdef _DEBUG
				else
				{
					// Could not find usage + index in the stream! Maybe this vertex shader is bound to the wrong vertex declaration?
					OutputDebugStringA("Error: ps_3_0 D3DSPR_INPUT element could not be found in stream. Maybe this pixel shader is bound to the wrong vertex declaration?\n");
				}
#endif
			}
		}
		else if (pixelShaderInfo.shaderMajorVersion == 2)
		{
			if (thisRegister.registerType == D3DSPR_INPUT) // color (diffuse, specular) register
			{
				const DebuggableD3DVERTEXELEMENT9* const element = vertexDecl->GetVertexElement(D3DDECLUSAGE_COLOR, thisRegister.usageIndex);
				if (element)
				{
					// TODO: Make this work with multiple vertex streams
					vals[D3DDECLUSAGE_COLOR][thisRegister.usageIndex] = element;
				}
#ifdef _DEBUG
				else
				{
					// Could not find usage + index in the stream! Maybe this vertex shader is bound to the wrong vertex declaration?
					OutputDebugStringA("Error: ps_2_0 D3DSPR_INPUT element could not be found in stream. Maybe this pixel shader is bound to the wrong vertex declaration?\n");
				}
#endif
			}
			else if (thisRegister.registerType == D3DSPR_TEXTURE) // texcoord register
			{
				const DebuggableD3DVERTEXELEMENT9* const element = vertexDecl->GetVertexElement(D3DDECLUSAGE_TEXCOORD, thisRegister.usageIndex);
				if (element)
				{
					// TODO: Make this work with multiple vertex streams
					vals[D3DDECLUSAGE_TEXCOORD][thisRegister.usageIndex] = element;
				}
#ifdef _DEBUG
				else
				{
					// Could not find usage + index in the stream! Maybe this vertex shader is bound to the wrong vertex declaration?
					OutputDebugStringA("Error: ps_2_0 D3DSPR_TEXTURE element could not be found in stream. Maybe this pixel shader is bound to the wrong vertex declaration?\n");
				}
#endif
			}
		}
#ifdef _DEBUG
		else
		{
			// Don't support ps_1_4 or anything
			DbgBreakPrint("Error: Unknown pixel shader version specified (not 2 or 3)");
		}
#endif
	}
}

void VStoPSMapping::ComputeMappingVSToPS(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps)
{
#ifdef _DEBUG
	if (!vs)
	{
		DbgBreakPrint("Error: Vertex shader is NULL");
	}
	if (!ps)
	{
		DbgBreakPrint("Error: Pixel shader is NULL");
	}
#endif

	const ShaderInfo& vsShaderInfo = vs->GetShaderInfo();
	const ShaderInfo& psShaderInfo = ps->GetShaderInfo();

	if (vsShaderInfo.shaderMajorVersion == 1 || vsShaderInfo.shaderMajorVersion == 2) // vs_1 and vs_2
	{
		if (psShaderInfo.shaderMajorVersion == 1) // ps_1
			ComputeMappingVS2ToPS1(vs, ps);
		else if (psShaderInfo.shaderMajorVersion == 2) // ps_2
			ComputeMappingVS2ToPS2(vs, ps);
		else if (psShaderInfo.shaderMajorVersion == 3) // ps_3
			ComputeMappingVS2ToPS3(vs, ps);
#ifdef _DEBUG
		else
		{
			DbgBreakPrint("Error: Pixel shader version is unknown (not 1, 2, or 3)");
		}
#endif
	}
	else if (vsShaderInfo.shaderMajorVersion == 3) // vs_3
	{
		if (psShaderInfo.shaderMajorVersion == 1) // ps_1
			ComputeMappingVS3ToPS1(vs, ps);
		if (psShaderInfo.shaderMajorVersion == 2) // ps_2
			ComputeMappingVS3ToPS2(vs, ps);
		else if (psShaderInfo.shaderMajorVersion == 3) // ps_3
			ComputeMappingVS3ToPS3(vs, ps);
#ifdef _DEBUG
		else
		{
			DbgBreakPrint("Error: Pixel shader version is unknown (not 2 or 3)");
		}
#endif
	}
#ifdef _DEBUG
	else
	{
		DbgBreakPrint("Error: Vertex shader version is unknown (not 1, 2, or 3)");
	}
#endif
}

// VS1/VS2 to PS1:
// Directly go across -> 2colors + 6texcoords
void VStoPSMapping::ComputeMappingVS2ToPS1(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps)
{
	#ifdef _DEBUG
	if (!vs)
	{
		DbgBreakPrint("Error: Vertex shader is NULL");
	}
	if (!ps)
	{
		DbgBreakPrint("Error: Pixel shader is NULL");
	}
#endif

	// ps_1_* doesn't use input declarations
	const ShaderInfo& psShaderInfo = ps->GetShaderInfo();
	for (unsigned char t = 0; t < (D3DMCS_COLOR2 + 6); ++t)
	{
		if (psShaderInfo.inputRegistersUsedBitmask & (1 << t) )
		{
			psInputRegistersUnion.ps_2_0_registers.texCoords[t] = t;
		}
	}
}

// VS1/VS2 to PS2:
// Directly go across -> 2colors + 8texcoords
void VStoPSMapping::ComputeMappingVS2ToPS2(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps)
{
#ifdef _DEBUG
	if (!vs)
	{
		DbgBreakPrint("Error: Vertex shader is NULL");
	}
	if (!ps)
	{
		DbgBreakPrint("Error: Pixel shader is NULL");
	}
#endif

	const ShaderInfo& psShaderInfo = ps->GetShaderInfo();
	const std::vector<DeclaredRegister>& declaredRegs = psShaderInfo.declaredRegisters;
	for (unsigned x = 0; x < declaredRegs.size(); ++x)
	{
		const DeclaredRegister& reg = declaredRegs[x];
		switch (reg.registerType)
		{
		case D3DSPR_INPUT: // color (diffuse, specular) register
			psInputRegistersUnion.ps_2_0_registers.colors[reg.registerIndex] = reg.usageIndex;
			break;
		case D3DSPR_TEXTURE: // texcoord register
			psInputRegistersUnion.ps_2_0_registers.texCoords[reg.registerIndex] = reg.usageIndex + D3DMCS_COLOR2;
			break;
		default:
			break;
		}
	}
}

// VS1/VS2 to PS3:
// Use semantics to map from 2colors + 8texcoords to 10 PS input registers
void VStoPSMapping::ComputeMappingVS2ToPS3(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps)
{
#ifdef _DEBUG
	if (!vs)
	{
		DbgBreakPrint("Error: Vertex shader is NULL");
	}
	if (!ps)
	{
		DbgBreakPrint("Error: Pixel shader is NULL");
	}
#endif

	const ShaderInfo& psShaderInfo = ps->GetShaderInfo();
	const std::vector<DeclaredRegister>& psDeclaredRegs = psShaderInfo.declaredRegisters;
	const unsigned numPsDeclRegs = psDeclaredRegs.size();
	for (unsigned x = 0; x < numPsDeclRegs; ++x)
	{
		const DeclaredRegister& psReg = psDeclaredRegs[x];
		if (psReg.registerType != D3DSPR_INPUT) // Interpolator register
			continue;

		switch (psReg.usageType)
		{
		case D3DDECLUSAGE_COLOR:
			psInputRegistersUnion.ps_3_0_registers.inputs[psReg.registerIndex] = psReg.usageIndex;
			break;
		default:
#ifdef _DEBUG
			DbgBreakPrint("Error: Unexpected shader register usage type for PS_2_0");
#endif
		case D3DDECLUSAGE_TEXCOORD:
			psInputRegistersUnion.ps_3_0_registers.inputs[psReg.registerIndex] = psReg.usageIndex + D3DMCS_COLOR2;
			break;
		}
	}
}

// VS3 to PS2:
// Map from 12 VS output registers to 2colors + 6texcoords (anything that isn't a color goes into texcoords)
void VStoPSMapping::ComputeMappingVS3ToPS1(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps)
{
	#ifdef _DEBUG
	if (!vs)
	{
		DbgBreakPrint("Error: Vertex shader is NULL");
	}
	if (!ps)
	{
		DbgBreakPrint("Error: Pixel shader is NULL");
	}
#endif

	const ShaderInfo& vsShaderInfo = vs->GetShaderInfo();
	const std::vector<DeclaredRegister>& vsDeclaredRegs = vsShaderInfo.declaredRegisters;
	const unsigned numVsDeclRegs = vsDeclaredRegs.size();
	const ShaderInfo& psShaderInfo = ps->GetShaderInfo();
	for (unsigned char t = 0; t < 8; ++t)
	{
		psInputRegistersUnion.ps_3_0_registers.inputs[t] = 0;
		if (psShaderInfo.inputRegistersUsedBitmask & (1 << t) )
		{
			for (unsigned y = 0; y < numVsDeclRegs; ++y)
			{
				const DeclaredRegister& vsReg = vsDeclaredRegs[y];
				if (!vsReg.isOutputRegister)
					continue;
				if (vsReg.usageType == D3DDECLUSAGE_COLOR && vsReg.usageIndex == t)
					psInputRegistersUnion.ps_3_0_registers.inputs[t] = vsReg.registerIndex;
				else if (vsReg.usageType == D3DDECLUSAGE_TEXCOORD && vsReg.usageIndex == t - D3DMCS_COLOR2)
					psInputRegistersUnion.ps_3_0_registers.inputs[t] = vsReg.registerIndex + D3DMCS_COLOR2;
			}
		}
	}
	const std::vector<DeclaredRegister>& psDeclaredRegs = psShaderInfo.declaredRegisters;
	const unsigned numPsDeclRegs = psDeclaredRegs.size();
	for (unsigned x = 0; x < numPsDeclRegs; ++x)
	{
		const DeclaredRegister& psReg = psDeclaredRegs[x];
		switch (psReg.registerType)
		{
		case D3DSPR_INPUT: // color (diffuse, specular) register
			psInputRegistersUnion.ps_2_0_registers.colors[psReg.registerIndex] = 0;
			for (unsigned y = 0; y < numVsDeclRegs; ++y)
			{
				const DeclaredRegister& vsReg = vsDeclaredRegs[y];
				if (!vsReg.isOutputRegister)
					continue;
				if (vsReg.usageType == D3DDECLUSAGE_COLOR && vsReg.usageIndex == psReg.usageIndex)
				{
					psInputRegistersUnion.ps_2_0_registers.colors[psReg.registerIndex] = vsReg.registerIndex;
					break;
				}
			}
			break;
		case D3DSPR_TEXTURE: // texcoord register
			psInputRegistersUnion.ps_2_0_registers.texCoords[psReg.registerIndex] = 0;
			for (unsigned y = 0; y < numVsDeclRegs; ++y)
			{
				const DeclaredRegister& vsReg = vsDeclaredRegs[y];
				if (!vsReg.isOutputRegister)
					continue;
				if (vsReg.usageType == D3DDECLUSAGE_TEXCOORD && vsReg.usageIndex == psReg.usageIndex)
				{
					psInputRegistersUnion.ps_2_0_registers.colors[psReg.registerIndex] = vsReg.registerIndex;
					break;
				}
			}
			break;
		default:
			break;
		}
	}
}

// VS3 to PS2:
// Use semantics to map from 12 VS output registers to 2colors + 8texcoords (anything that isn't a color goes into texcoords)
void VStoPSMapping::ComputeMappingVS3ToPS2(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps)
{
#ifdef _DEBUG
	if (!vs)
	{
		DbgBreakPrint("Error: Vertex shader is NULL");
	}
	if (!ps)
	{
		DbgBreakPrint("Error: Pixel shader is NULL");
	}
#endif

	const ShaderInfo& vsShaderInfo = vs->GetShaderInfo();
	const std::vector<DeclaredRegister>& vsDeclaredRegs = vsShaderInfo.declaredRegisters;
	const unsigned numVsDeclRegs = vsDeclaredRegs.size();
	const ShaderInfo& psShaderInfo = ps->GetShaderInfo();
	const std::vector<DeclaredRegister>& psDeclaredRegs = psShaderInfo.declaredRegisters;
	const unsigned numPsDeclRegs = psDeclaredRegs.size();
	for (unsigned x = 0; x < numPsDeclRegs; ++x)
	{
		const DeclaredRegister& psReg = psDeclaredRegs[x];
		switch (psReg.registerType)
		{
		case D3DSPR_INPUT: // color (diffuse, specular) register
			psInputRegistersUnion.ps_2_0_registers.colors[psReg.registerIndex] = 0;
			for (unsigned y = 0; y < numVsDeclRegs; ++y)
			{
				const DeclaredRegister& vsReg = vsDeclaredRegs[y];
				if (!vsReg.isOutputRegister)
					continue;
				if (vsReg.usageType == D3DDECLUSAGE_COLOR && vsReg.usageIndex == psReg.usageIndex)
				{
					psInputRegistersUnion.ps_2_0_registers.colors[psReg.registerIndex] = vsReg.registerIndex;
					break;
				}
			}
			break;
		case D3DSPR_TEXTURE: // texcoord register
			psInputRegistersUnion.ps_2_0_registers.texCoords[psReg.registerIndex] = 0;
			for (unsigned y = 0; y < numVsDeclRegs; ++y)
			{
				const DeclaredRegister& vsReg = vsDeclaredRegs[y];
				if (!vsReg.isOutputRegister)
					continue;
				if (vsReg.usageType == D3DDECLUSAGE_TEXCOORD && vsReg.usageIndex == psReg.usageIndex)
				{
					psInputRegistersUnion.ps_2_0_registers.colors[psReg.registerIndex] = vsReg.registerIndex;
					break;
				}
			}
			break;
		default:
			break;
		}
	}
}

// VS3 to PS3:
// Map across non-rasterizer VS outputs (no POSITIONT, no FOG, no PSIZE, etc.)
void VStoPSMapping::ComputeMappingVS3ToPS3(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps)
{
#ifdef _DEBUG
	if (!vs)
	{
		DbgBreakPrint("Error: Vertex shader is NULL");
	}
	if (!ps)
	{
		DbgBreakPrint("Error: Pixel shader is NULL");
	}
#endif

	const ShaderInfo& vsShaderInfo = vs->GetShaderInfo();
	const std::vector<DeclaredRegister>& vsDeclaredRegs = vsShaderInfo.declaredRegisters;
	const unsigned numVsDeclRegs = vsDeclaredRegs.size();
	const ShaderInfo& psShaderInfo = ps->GetShaderInfo();
	const std::vector<DeclaredRegister>& psDeclaredRegs = psShaderInfo.declaredRegisters;
	const unsigned numPsDeclRegs = psDeclaredRegs.size();
	for (unsigned x = 0; x < numPsDeclRegs; ++x)
	{
		const DeclaredRegister& psReg = psDeclaredRegs[x];
		if (psReg.registerType != D3DSPR_INPUT) // Interpolator register
			continue;

		// Default to mapping across all registers
		psInputRegistersUnion.ps_3_0_registers.inputs[psReg.registerIndex] = x;

		for (unsigned y = 0; y < numVsDeclRegs; ++y)
		{
			const DeclaredRegister& vsReg = vsDeclaredRegs[y];
			if (!vsReg.isOutputRegister)
				continue;
			if (vsReg.usageType == psReg.usageType && vsReg.usageIndex == psReg.usageIndex)
			{
				psInputRegistersUnion.ps_3_0_registers.inputs[psReg.registerIndex] = vsReg.registerIndex;
				break;
			}
		}
	}
}

```

`Software_d3d9/SemanticMappings.h`:

```h
#pragma once

#include "GlobalToggles.h"
#include "IDirect3DDevice9Hook.h"

// Mapping from vertex declarations and vertex streams to vertex shader inputs (or from vertex streams to pixel shader inputs for POSITIONT vert decls):
struct DeclarationSemanticMapping
{
	DeclarationSemanticMapping()
	{
		ClearSemanticMapping();
	}

	inline void ClearSemanticMapping()
	{
		for (unsigned x = 0; x <= MAXD3DDECLUSAGE; ++x)
			for (unsigned y = 0; y <= MAXD3DDECLUSAGEINDEX; ++y)
				vals[x][y] = NULL;
	}

	// Computes a mapping between vertex streams and vertex shader inputs
	void ComputeMappingVS(const IDirect3DVertexDeclaration9Hook* const vertexDecl, const IDirect3DVertexShader9Hook* const vertexShader);

	// Computes a mapping between vertex shader outputs and the postransformed vertex declaration
	void ComputeMappingVStoPS(const IDirect3DVertexDeclaration9Hook* const vertexDecl, const IDirect3DVertexShader9Hook* const vertexShader);

	// Computes a mapping between vertex streams and pixel shader inputs (for POSITIONT decls)
	void ComputeMappingPS(const IDirect3DVertexDeclaration9Hook* const vertexDecl, const IDirect3DPixelShader9Hook* const pixelShader);

	// Returns the address of the register within the input vertex stream given the usage and index in the map
	inline const D3DXVECTOR4* const GetAddress(const D3DDECLUSAGE usage, const unsigned index, const D3DXVECTOR4* const baseAddr) const
	{
		const DebuggableD3DVERTEXELEMENT9* const offsetElement = vals[usage][index];
		return baseAddr + offsetElement->Offset;
	}

	const DebuggableD3DVERTEXELEMENT9* vals[MAXD3DDECLUSAGE + 1][MAXD3DDECLUSAGEINDEX + 1];
};

// Mapping from vertex shader outputs to pixel shader inputs:
struct VStoPSMapping
{
	VStoPSMapping()
	{
		ClearSemanticMapping();
	}

	inline void ClearSemanticMapping()
	{
		memset(this, 0, sizeof(*this) );
	}

	void ComputeMappingVSToPS(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps);

	// VS1/VS2 to PS1:
	// Directly go across -> 2colors + 6texcoords
	void ComputeMappingVS2ToPS1(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps);

	// VS1/VS2 to PS2:
	// Directly go across -> 2colors + 8texcoords
	void ComputeMappingVS2ToPS2(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps);

	// VS1/VS2 to PS3:
	// Use semantics to map from 2colors + 8texcoords to 10 PS input registers
	void ComputeMappingVS2ToPS3(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps);

	// VS3 to PS2:
	// Map from 12 VS output registers to 2colors + 6texcoords (anything that isn't a color goes into texcoords)
	void ComputeMappingVS3ToPS1(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps);

	// VS3 to PS2:
	// Use semantics to map from 12 VS output registers to 2colors + 8texcoords (anything that isn't a color goes into texcoords)
	void ComputeMappingVS3ToPS2(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps);

	// VS3 to PS3:
	// Map across non-rasterizer VS outputs (no POSITIONT, no FOG, no PSIZE, etc.)
	void ComputeMappingVS3ToPS3(const IDirect3DVertexShader9Hook* const vs, const IDirect3DPixelShader9Hook* const ps);

	union _psInputRegistersUnion
	{
		struct _ps_2_0_registers
		{
			unsigned colors[D3DMCS_COLOR2]; // 2 colors
			unsigned texCoords[D3DDP_MAXTEXCOORD]; // 8 texcoords
		} ps_2_0_registers;

		struct _ps_3_0_registers
		{
			unsigned inputs[10]; // 10 pixel shader inputs
		} ps_3_0_registers;
	} psInputRegistersUnion;
};

```

`Software_d3d9/ShaderAnalysis.cpp`:

```cpp
#pragma once

#include "ShaderAnalysis.h"
#include <intrin.h> // for popcnt()

static inline void dprintf(ShaderInfo& shaderInfo, const char* const formatString, ...)
{
	char buffer[1024] = {0};

	va_list args;
	va_start(args, formatString);
#pragma warning(push)
#pragma warning(disable:4996)
	const int len = vsprintf(buffer, formatString, args);
#pragma warning(pop)
	va_end(args);

	if (len > 0)
	{
		shaderInfo.shaderDisasmText.insert(shaderInfo.shaderDisasmText.end(), buffer, buffer + len);
	}
}

void ShaderInfo::PrintShaderStatsToString(char (&outBuffer)[1024]) const
{
#pragma warning(push)
#pragma warning(disable:4996)
	sprintf(outBuffer, "Shader Version: %cs_%u_%u\n"
		"Shader Length (tokens): %u\n"
		"Instructions (ALU/TEX): %u/%u\n"
		"Temp registers used (r registers): %u/%u\n"
		"Input registers used (v registers): %u/%u\n"
		"Float constant registers used (c registers): %u\n"
		"Integer constant registers used (i registers): %u/%u\n"
		"Bool constant registers used (b registers): %u/%u\n"
		"Uses dynamic branching: %s\n"
		"Uses function calls: %s\n"
		"Uses int to float conversions: %s\n"
		"Uses TEXKILL instructions: %s\n"
		"Uses gradient instructions: %s\n"
		"Uses instruction predication: %s\n"
		"Uses scalar instruction co-issuing: %s\n"
		"Uses custom depth output: %s\n"
		"Uses vertex texture fetch (VTF): %s\n"
		"Uses multiple render targets (MRT): %s\n"
		"Has dependent texture fetches: %s\n",
		isPixelShader ? 'p' : 'v', shaderMajorVersion, shaderMinorVersion,
		shaderLengthDWORDs,
		numArithInstructions, numTexInstructions,
		numUniqueTempRegistersUsed, MAX_NUM_TEMP_REGISTERS,
		numUniqueInputRegistersUsed, isPixelShader ? ( (shaderMajorVersion < 2) ? 8 : 10) : 16,
		usedConstantsF.size(),
		usedConstantsI.size(), MAX_NUM_CONST_INT_REGISTERS,
		usedConstantsB.size(), MAX_NUM_CONST_BOOL_REGISTERS,
		usesDynamicBranching ? "TRUE" : "FALSE",
		usesFunctionCalls ? "TRUE" : "FALSE",
		usesIntToFloatConversions ? "TRUE" : "FALSE",
		usesTexkill ? "TRUE" : "FALSE",
		usesGradientInstructions ? "TRUE" : "FALSE",
		usesInstructionPredication ? "TRUE" : "FALSE",
		usesInstructionCoIssue ? "TRUE" : "FALSE",
		psWritesDepth ? "TRUE" : "FALSE",
		usesVertTextureFetch ? "TRUE" : "FALSE",
		usesMRT ? "TRUE" : "FALSE",
		hasDependentTextureFetches ? "TRUE" : "FALSE");
#pragma warning(pop)
}

// Note that ResolveDstParameter<print> also increments the bytecode stream pointer given to it
template <const bool print, const bool modifyRegister>
static inline void ResolveDstParameter(const DWORD*& bytecode, ShaderInfo& shaderInfo, unsigned long& uniqueTempRegistersUsed, outputRegisterWriteTracker& outRegisterwriteTracker)
{
	const dstParameterToken& dstParameter = *(const dstParameterToken* const)bytecode;
	const D3DSHADER_PARAM_REGISTER_TYPE registerType = dstParameter.GetRegisterType();
	unsigned index = dstParameter.GetRegisterIndex();

	const bool usesRelativeAddressing = dstParameter.GetRelativeAddressingType() == D3DSHADER_ADDRMODE_RELATIVE;

	const unsigned registerWriteMask = dstParameter.GetWriteMask();

	switch (registerType)
	{
	case D3DSPR_TEMP       :
		if (print) dprintf(shaderInfo, "r");
		uniqueTempRegistersUsed |= (1 << index);
		break;
	case D3DSPR_INPUT      :
		if (print) dprintf(shaderInfo, "v");
		break;
	case D3DSPR_CONST      :
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
		if (print) dprintf(shaderInfo, "c");
		break;
	case D3DSPR_ADDR       : // Also known as D3DSPR_TEXTURE (PS)
		if (print)
		{
			shaderInfo.isPixelShader ? dprintf(shaderInfo, "t") : dprintf(shaderInfo, "a");
		}
		break;
	case D3DSPR_RASTOUT    :
		if (modifyRegister)
			outRegisterwriteTracker.SetAddOrSkip(registerType, index, (const BYTE)registerWriteMask, dstParameter, (const instructionToken* const)(bytecode - 1), usesRelativeAddressing ? (const dstParameterToken* const)(bytecode + 1) : NULL);

		if (shaderInfo.isPixelShader)
		{
			if (print) dprintf(shaderInfo, "RASTOUT");
		}
		else
		{
			switch (index)
			{
			case D3DSRO_POSITION:
				if (print) dprintf(shaderInfo, "oPos");
				break;
			case D3DSRO_FOG:
				if (print) dprintf(shaderInfo, "oFog");
				break;
			case D3DSRO_POINT_SIZE:
				if (print) dprintf(shaderInfo, "oPSize");
				break;
			default:
				if (print) dprintf(shaderInfo, "Unknown RASTOUT index specified (%u)", index);
				break;
			}
		}
		break;
	case D3DSPR_ATTROUT    :
		if (modifyRegister)
			outRegisterwriteTracker.SetAddOrSkip(registerType, index, (const BYTE)registerWriteMask, dstParameter, (const instructionToken* const)(bytecode - 1), usesRelativeAddressing ? (const dstParameterToken* const)(bytecode + 1) : NULL);

		if (print) dprintf(shaderInfo, "ATTROUT");
		break;
	case D3DSPR_OUTPUT  : // Also known as D3DSPR_TEXCRDOUT
		if (modifyRegister)
			outRegisterwriteTracker.SetAddOrSkip(registerType, index, (const BYTE)registerWriteMask, dstParameter, (const instructionToken* const)(bytecode - 1), usesRelativeAddressing ? (const dstParameterToken* const)(bytecode + 1) : NULL);

		if (print) dprintf(shaderInfo, "o");
		break;
	case D3DSPR_CONSTINT   :
		if (print) dprintf(shaderInfo, "i");
		break;
	case D3DSPR_COLOROUT   :
		if (modifyRegister)
			outRegisterwriteTracker.SetAddOrSkip(registerType, index, (const BYTE)registerWriteMask, dstParameter, (const instructionToken* const)(bytecode - 1), usesRelativeAddressing ? (const dstParameterToken* const)(bytecode + 1) : NULL);

		if (print) dprintf(shaderInfo, "oC");
		if (shaderInfo.isPixelShader)
		{
			shaderInfo.usedMRTMask |= (1 << index);
		}
		else
		{
			// Only pixel shaders can write to the oC# registers
			shaderInfo.parsingErrorDetected = true;
		}
		break;
	case D3DSPR_DEPTHOUT   :
		if (modifyRegister)
			outRegisterwriteTracker.SetAddOrSkip(registerType, index, (const BYTE)registerWriteMask, dstParameter, (const instructionToken* const)(bytecode - 1), usesRelativeAddressing ? (const dstParameterToken* const)(bytecode + 1) : NULL);

		if (print) dprintf(shaderInfo, "oDepth");
		if (shaderInfo.isPixelShader)
			shaderInfo.psWritesDepth = true;
		break;
	case D3DSPR_SAMPLER    :
		if (print) dprintf(shaderInfo, "s");
		break;
	case D3DSPR_CONSTBOOL  :
		if (print) dprintf(shaderInfo, "b");
		break;
	case D3DSPR_LOOP       :
		if (print) dprintf(shaderInfo, "aL");
		break;
	case D3DSPR_TEMPFLOAT16:
		if (print) dprintf(shaderInfo, "r");
		break;
	case D3DSPR_MISCTYPE   :
		if (print) dprintf(shaderInfo, "MISC");
		break;
	case D3DSPR_LABEL      :
		if (print) dprintf(shaderInfo, "LABEL");
		break;
	case D3DSPR_PREDICATE  :
		if (print) dprintf(shaderInfo, "p");
		break;
	default:
#ifdef _DEBUG
		{
			DbgBreakPrint("Error: Unknown shader register");
		}
#endif
		break;
	}

	// Print register index:
	switch (registerType)
	{
	case D3DSPR_CONST	   :
		break;
	case D3DSPR_CONST2     :
		index += 2048;
		break;
	case D3DSPR_CONST3     :
		index += 4096;
		break;
	case D3DSPR_CONST4     :
		index += 6144;
		break;
	default:
		break;
	}
	if (print) dprintf(shaderInfo, "%u", index);

	const unsigned resultModifier = dstParameter.GetResultModifierUnshifted();
	if (resultModifier & D3DSPDM_SATURATE)
		if (print) dprintf(shaderInfo, "_sat");
	if (resultModifier & D3DSPDM_PARTIALPRECISION)
		if (print) dprintf(shaderInfo, "_pp");
	if (resultModifier & D3DSPDM_MSAMPCENTROID)
		if (print) dprintf(shaderInfo, "_centroid");

	if (usesRelativeAddressing)
	{
		const dstParameterToken& relativeDstParameter = *(const dstParameterToken* const)(bytecode + 1);
		if (print) dprintf(shaderInfo, "[");
		switch (relativeDstParameter.GetRegisterType() )
		{
		case D3DSPR_ADDR:
			if (print) dprintf(shaderInfo, "a");
			break;
		case D3DSPR_LOOP:
			if (print) dprintf(shaderInfo, "aL");
			break;
		default:
#ifdef _DEBUG
			__debugbreak();
#endif
			if (print) dprintf(shaderInfo, "Error: Invalid relative offset register type specified (%u)!", relativeDstParameter.GetRegisterType() );
			break;
		}
		if (print) dprintf(shaderInfo, "%u", relativeDstParameter.GetRegisterIndex() );

		const unsigned relativeRegisterWriteMask = relativeDstParameter.GetWriteMask();
		if (relativeRegisterWriteMask != 0xF) // Omit displaying ".xyzw" after every register because it gets annoying!
		{
			bool writeMaskDotApplied = false;
			if (relativeRegisterWriteMask & 0x1) // x
			{
				if (print) dprintf(shaderInfo, ".x");
				writeMaskDotApplied = true;
			}
			if (relativeRegisterWriteMask & 0x2) // y
			{
				if (!writeMaskDotApplied)
				{
					if (print) dprintf(shaderInfo, ".y");
				}
				else
				{
					if (print) dprintf(shaderInfo, "y");
				}
				writeMaskDotApplied = true;
			}
			if (relativeRegisterWriteMask & 0x4) // z
			{
				if (!writeMaskDotApplied)
				{
					if (print) dprintf(shaderInfo, ".z");
				}
				else
				{
					if (print) dprintf(shaderInfo, "z");
				}
				writeMaskDotApplied = true;
			}
			if (relativeRegisterWriteMask & 0x8) // w
			{
				if (!writeMaskDotApplied)
				{
					if (print) dprintf(shaderInfo, ".w");
				}
				else
				{
					if (print) dprintf(shaderInfo, "w");
				}
			}
		}

		if (print) dprintf(shaderInfo, "]");

		// Super important to do this or else the byte-stream gets broken after the relative addressing token!
		++bytecode;
	}

	// Handle write masks:
	if (registerWriteMask != 0xF) // Omit displaying ".xyzw" after every register because it gets annoying!
	{
		bool writeMaskDotApplied = false;
		if (registerWriteMask & 0x1) // x
		{
			if (print) dprintf(shaderInfo, ".x");
			writeMaskDotApplied = true;
		}
		if (registerWriteMask & 0x2) // y
		{
			if (!writeMaskDotApplied)
			{
				if (print) dprintf(shaderInfo, ".y");
			}
			else
			{
				if (print) dprintf(shaderInfo, "y");
			}
			writeMaskDotApplied = true;
		}
		if (registerWriteMask & 0x4) // z
		{
			if (!writeMaskDotApplied)
			{
				if (print) dprintf(shaderInfo, ".z");
			}
			else
			{
				if (print) dprintf(shaderInfo, "z");
			}
			writeMaskDotApplied = true;
		}
		if (registerWriteMask & 0x8) // w
		{
			if (!writeMaskDotApplied)
			{
				if (print) dprintf(shaderInfo, ".w");
			}
			else
			{
				if (print) dprintf(shaderInfo, "w");
			}
		}
	}

	const unsigned shiftScale = dstParameter.GetResultShiftScale();
	if (shiftScale != 0)
	{
		if (shiftScale > 0x7)
		{
			// Multiply
			if (print) dprintf(shaderInfo, "_x%u", shiftScale & 0x7);
		}
		else
		{
			// Divide
			if (print) dprintf(shaderInfo, "_d%u", shiftScale & 0x7);
		}
	}

	// Super important to do this!
	++bytecode;
}

static inline void AddIfNotPresent(std::vector<unsigned>& vals, const unsigned val)
{
	const unsigned numVals = vals.size();
	for (unsigned x = 0; x < numVals; ++x)
	{
		if (vals[x] == val)
			return;
	}

	vals.push_back(val);
}

// Note that ResolveSrcParameter<print> also increments the bytecode stream pointer given to it
template <const bool print>
static inline void ResolveSrcParameter(ShaderInfo& shaderInfo, const DWORD*& bytecode, const bool isPixelShader, unsigned long& uniqueTempRegistersUsed, unsigned short& uniqueInputRegistersUsed)
{
	const srcParameterToken& srcParameter = *(const srcParameterToken* const)bytecode;

	const D3DSHADER_PARAM_SRCMOD_TYPE sourceMod = srcParameter.GetSourceModifiersUnshifted();
	switch (sourceMod)
	{
	case D3DSPSM_NONE   :
	case D3DSPSM_BIAS   :
	case D3DSPSM_SIGN   :
	case D3DSPSM_COMP   :
	case D3DSPSM_X2     :
	case D3DSPSM_DW     :
	case D3DSPSM_DZ     :
		break;
	case D3DSPSM_NEG    :
	case D3DSPSM_BIASNEG:
	case D3DSPSM_SIGNNEG:
	case D3DSPSM_X2NEG  :
		if (print) dprintf(shaderInfo, "-");
		break;
	case D3DSPSM_ABS    :
		if (print) dprintf(shaderInfo, "abs(");
		break;
	case D3DSPSM_ABSNEG :
		if (print) dprintf(shaderInfo, "-abs(");
		break;
	case D3DSPSM_NOT    :
		if (print) dprintf(shaderInfo, "!");
		break;
	default:
		if (print) dprintf(shaderInfo, " Error: Unknown source modifier (%u) ", sourceMod >> D3DSP_SRCMOD_SHIFT);
		break;
	}

	unsigned index = srcParameter.GetRegisterIndex();

	const D3DSHADER_PARAM_REGISTER_TYPE registerType = srcParameter.GetRegisterType();
	switch (registerType)
	{
	case D3DSPR_TEMP       :
		if (print) dprintf(shaderInfo, "r");
		uniqueTempRegistersUsed |= (1 << index);
		break;
	case D3DSPR_INPUT      :
		if (print) dprintf(shaderInfo, "v");
		uniqueInputRegistersUsed |= (1 << index);
		break;
	case D3DSPR_CONST      :
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
		if (print) dprintf(shaderInfo, "c");
		break;
	case D3DSPR_ADDR       : // Also known as D3DSPR_TEXTURE (PS)
		if (print)
		{
			isPixelShader ? dprintf(shaderInfo, "t") : dprintf(shaderInfo, "a");
		}
		if (shaderInfo.isPixelShader)
		{
			if (shaderInfo.shaderMajorVersion < 3)
				uniqueInputRegistersUsed |= (1 << (index + D3DMCS_COLOR2) ); // +2 for the Diffuse and Specular color registers
			else
				uniqueInputRegistersUsed |= (1 << index);
		}
		break;
	case D3DSPR_RASTOUT    :
		if (print) dprintf(shaderInfo, "RASTOUT");
		break;
	case D3DSPR_ATTROUT    :
		if (print) dprintf(shaderInfo, "ATTROUT");
		break;
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
		if (print) dprintf(shaderInfo, "oT");
		break;
	case D3DSPR_CONSTINT   :
		if (print) dprintf(shaderInfo, "i");
		break;
	case D3DSPR_COLOROUT   :
		if (print) dprintf(shaderInfo, "oC");
		break;
	case D3DSPR_DEPTHOUT   :
		if (print) dprintf(shaderInfo, "oDepth");
		break;
	case D3DSPR_SAMPLER    :
		if (print) dprintf(shaderInfo, "s");
		break;
	case D3DSPR_CONSTBOOL  :
		if (print) dprintf(shaderInfo, "b");
		break;
	case D3DSPR_LOOP       :
		if (print) dprintf(shaderInfo, "aL");
		break;
	case D3DSPR_TEMPFLOAT16:
		if (print) dprintf(shaderInfo, "r");
		break;
	case D3DSPR_MISCTYPE   :
		if (print) dprintf(shaderInfo, "MISC");
		break;
	case D3DSPR_LABEL      :
		if (print) dprintf(shaderInfo, "LABEL");
		break;
	case D3DSPR_PREDICATE  :
		if (print) dprintf(shaderInfo, "p");
		break;
	default:
#ifdef _DEBUG
		{
			DbgBreakPrint("Error: Unknown shader register");
		}
#endif
		break;
	}

	// Print register index:
	switch (registerType)
	{
	case D3DSPR_CONST:
		break;
	case D3DSPR_CONST2     :
		index += 2048;
		break;
	case D3DSPR_CONST3     :
		index += 4096;
		break;
	case D3DSPR_CONST4     :
		index += 6144;
		break;
	default:
		break;
	}
	if (print) dprintf(shaderInfo, "%u", index);

	// Populate the "used constants" shader info:
	switch (registerType)
	{
	case D3DSPR_CONST:
	case D3DSPR_CONST2:
	case D3DSPR_CONST3:
	case D3DSPR_CONST4:
		AddIfNotPresent(shaderInfo.usedConstantsF, index);
		break;
	case D3DSPR_CONSTINT:
		AddIfNotPresent(shaderInfo.usedConstantsI, index);
		break;
	case D3DSPR_CONSTBOOL:
		AddIfNotPresent(shaderInfo.usedConstantsB, index);
		break;
	default:
		break;
	}

	switch (sourceMod)
	{
	default:
	case D3DSPSM_NONE   :
	case D3DSPSM_NOT    :
	case D3DSPSM_NEG    :
		break;
	case D3DSPSM_BIAS   :
	case D3DSPSM_BIASNEG:
		if (print) dprintf(shaderInfo, "_bias");
		break;
	case D3DSPSM_SIGN   :
	case D3DSPSM_SIGNNEG:
		if (print) dprintf(shaderInfo, "_bx2");
		break;
	case D3DSPSM_COMP   :
		if (print) dprintf(shaderInfo, "_complement");
		break;
	case D3DSPSM_X2     :
	case D3DSPSM_X2NEG  :
		if (print) dprintf(shaderInfo, "_x2");
		break;
	case D3DSPSM_DZ     :
		if (print) dprintf(shaderInfo, "_dz");
		break;
	case D3DSPSM_DW     :
		if (print) dprintf(shaderInfo, "_dw");
		break;
	case D3DSPSM_ABS    :
	case D3DSPSM_ABSNEG :
		if (print) dprintf(shaderInfo, ")");
		break;
	}

	if (srcParameter.GetRelativeAddressingType() == D3DSHADER_ADDRMODE_RELATIVE)
	{
		// Hack: If we're doing vs_1_* then the only register and only mask that can be used for relative addressing is the a0.x
		if (shaderInfo.shaderMajorVersion == 1)
		{
			if (print) dprintf(shaderInfo, "[a0.x]");

			// Do *not* advance the tokenstream in this special case!
		}
		else
		{
			const srcParameterToken& relativeSrcParameter = *(const srcParameterToken* const)(bytecode + 1);
			if (print) dprintf(shaderInfo, "[");
			const D3DSHADER_PARAM_REGISTER_TYPE relativeRegisterType = relativeSrcParameter.GetRegisterType();
			switch (relativeRegisterType)
			{
			case D3DSPR_ADDR:
				if (print) dprintf(shaderInfo, "a");
				break;
			case D3DSPR_LOOP:
				if (print) dprintf(shaderInfo, "aL");
				break;
			default:
#ifdef _DEBUG
				__debugbreak();
#endif
				if (print) dprintf(shaderInfo, "Error: Invalid relative offset register type specified (%u)!", relativeRegisterType);
				break;
			}
			if (print) dprintf(shaderInfo, "%u", relativeSrcParameter.GetRegisterIndex() );

			const unsigned channelSwizzle = relativeSrcParameter.GetChannelSwizzleXYZW();
			switch (channelSwizzle)
			{
			case D3DVS_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT: // .xyzw
				break; // Don't print .xyzw all the time
			case D3DSP_REPLICATERED >> D3DVS_SWIZZLE_SHIFT: // .x
				if (print) dprintf(shaderInfo, ".x");
				break;
			case D3DSP_REPLICATEGREEN >> D3DVS_SWIZZLE_SHIFT: // .y
				if (print) dprintf(shaderInfo, ".y");
				break;
			case D3DSP_REPLICATEBLUE >> D3DVS_SWIZZLE_SHIFT: // .z
				if (print) dprintf(shaderInfo, ".z");
				break;
			case D3DSP_REPLICATEALPHA >> D3DVS_SWIZZLE_SHIFT: // .w
				if (print) dprintf(shaderInfo, ".w");
				break;
			default:
			{
				if (print)
				{
					static const char* const channelName[4] =
					{
						"x",
						"y",
						"z",
						"w"
					};

					dprintf(shaderInfo, ".%s", channelName[channelSwizzle & 0x3]);
					dprintf(shaderInfo, "%s", channelName[(channelSwizzle >> 2) & 0x3]);
					dprintf(shaderInfo, "%s", channelName[(channelSwizzle >> 4) & 0x3]);
					dprintf(shaderInfo, "%s", channelName[(channelSwizzle >> 6) & 0x3]);
				}
			}
				break;
			}

			if (print) dprintf(shaderInfo, "]");

			// Super important to do this, otherwise the bytecode stream gets broken after the relative addressing token!
			++bytecode;
		}
	}

	const unsigned channelSwizzle = srcParameter.GetChannelSwizzleXYZW();
	switch (channelSwizzle)
	{
	case D3DVS_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT: // .xyzw
		break; // Don't print .xyzw all the time
	case D3DSP_REPLICATERED >> D3DVS_SWIZZLE_SHIFT: // .x
		if (print) dprintf(shaderInfo, ".x");
		break;
	case D3DSP_REPLICATEGREEN >> D3DVS_SWIZZLE_SHIFT: // .y
		if (print) dprintf(shaderInfo, ".y");
		break;
	case D3DSP_REPLICATEBLUE >> D3DVS_SWIZZLE_SHIFT: // .z
		if (print) dprintf(shaderInfo, ".z");
		break;
	case D3DSP_REPLICATEALPHA >> D3DVS_SWIZZLE_SHIFT: // .w
		if (print) dprintf(shaderInfo, ".w");
		break;
	default:
	{
		if (print)
		{
			static const char* const channelName[4] =
			{
				"x",
				"y",
				"z",
				"w"
			};

			dprintf(shaderInfo, ".%s", channelName[channelSwizzle & 0x3]);
			dprintf(shaderInfo, "%s", channelName[(channelSwizzle >> 2) & 0x3]);
			dprintf(shaderInfo, "%s", channelName[(channelSwizzle >> 4) & 0x3]);
			dprintf(shaderInfo, "%s", channelName[(channelSwizzle >> 6) & 0x3]);
		}
	}
		break;
	}

	// Super important to advance the bytecode stream
	++bytecode;
}

static const char* const opcodeToString[D3DSHADER_INSTRUCTION_OPCODE_TYPE::D3DSIO_BREAKP + 1] =
{
	"NOP", //D3DSIO_NOP          = 0,
    "MOV", //D3DSIO_MOV          ,
    "ADD", //D3DSIO_ADD          ,
    "SUB", //D3DSIO_SUB          ,
    "MAD", //D3DSIO_MAD          ,
    "MUL", //D3DSIO_MUL          ,
    "RCP", //D3DSIO_RCP          ,
    "RSQ", //D3DSIO_RSQ          ,
	"DP3", //D3DSIO_DP3          ,
    "DP4", //D3DSIO_DP4          ,
    "MIN", //D3DSIO_MIN          ,
    "MAX", //D3DSIO_MAX          ,
    "SLT", //D3DSIO_SLT          ,
    "SGE", //D3DSIO_SGE          ,
    "EXP", //D3DSIO_EXP          ,
    "LOG", //D3DSIO_LOG          ,
    "LIT", //D3DSIO_LIT          ,
    "DST", //D3DSIO_DST          ,
	"LRP", //D3DSIO_LRP          ,
    "FRC", //D3DSIO_FRC          ,
    "M4x4", //D3DSIO_M4x4         ,
    "M4x3", //D3DSIO_M4x3         ,
    "M3x4", //D3DSIO_M3x4         ,
    "M3x3", //D3DSIO_M3x3         ,
    "M3x2", //D3DSIO_M3x2         ,
    "CALL", //D3DSIO_CALL         ,
    "CALLNZ", //D3DSIO_CALLNZ       ,
    "LOOP", //D3DSIO_LOOP         ,
    "RET", //D3DSIO_RET          ,
    "ENDLOOP", //D3DSIO_ENDLOOP      ,
    "LABEL", //D3DSIO_LABEL        ,
    "DCL", //D3DSIO_DCL          ,
    "POW", //D3DSIO_POW          ,
    "CRS", //D3DSIO_CRS          ,
    "SGN", //D3DSIO_SGN          ,
    "ABS", //D3DSIO_ABS          ,
	"NRM", //D3DSIO_NRM          ,
    "SINCOS", //D3DSIO_SINCOS       ,
    "REP", //D3DSIO_REP          ,
    "ENDREP", //D3DSIO_ENDREP       ,
    "IF", //D3DSIO_IF           ,
    "IF_COMP", //D3DSIO_IFC          ,
    "ELSE", //D3DSIO_ELSE         ,
    "ENDIF", //D3DSIO_ENDIF        ,
    "BREAK", //D3DSIO_BREAK        ,
    "BREAK_COMP", //D3DSIO_BREAKC       ,
    "MOVA", //D3DSIO_MOVA         ,
    "DEFB", //D3DSIO_DEFB         ,
    "DEFI", //D3DSIO_DEFI         ,

	"UNK49",
	"UNK50",
	"UNK51",
	"UNK52",
	"UNK53",
	"UNK54",
	"UNK55",
	"UNK56",
	"UNK57",
	"UNK58",
	"UNK59",
	"UNK60",
	"UNK61",
	"UNK62",
	"UNK63",

    "TEXCOORD", //D3DSIO_TEXCOORD     = 64,
    "TEXKILL", //D3DSIO_TEXKILL      ,
    "TEX", //D3DSIO_TEX          ,
    "TEXBEM", //D3DSIO_TEXBEM       ,
    "TEXBEML", //D3DSIO_TEXBEML      ,
    "TEXREG2AR", //D3DSIO_TEXREG2AR    ,
    "TEXREG2GB", //D3DSIO_TEXREG2GB    ,
    "TEXM3x2PAD", //D3DSIO_TEXM3x2PAD   ,
    "TEXM3x2TEX", //D3DSIO_TEXM3x2TEX   ,
    "TEXM3x3PAD", //D3DSIO_TEXM3x3PAD   ,
    "TEXM3x3TEX", //D3DSIO_TEXM3x3TEX   ,
    "RESERVED0", //D3DSIO_RESERVED0    ,
    "TEXM3x3SPEC", //D3DSIO_TEXM3x3SPEC  ,
    "TEXM3x3VSPEC", //D3DSIO_TEXM3x3VSPEC ,
    "EXPP", //D3DSIO_EXPP         ,
    "LOGP", //D3DSIO_LOGP         ,
    "CND", //D3DSIO_CND          ,
    "DEF", //D3DSIO_DEF          ,
    "TEXREG2RGB", //D3DSIO_TEXREG2RGB   ,
    "TEXDP3TEX", //D3DSIO_TEXDP3TEX    ,
    "TEXM3x2DEPTH", //D3DSIO_TEXM3x2DEPTH ,
	"TEXDP3", //D3DSIO_TEXDP3       ,
    "TEXM3x3", //D3DSIO_TEXM3x3      ,
    "TEXDEPTH", //D3DSIO_TEXDEPTH     ,
    "CMP", //D3DSIO_CMP          ,
    "BEM", //D3DSIO_BEM          ,
    "DP2ADD", //D3DSIO_DP2ADD       ,
    "DSX", //D3DSIO_DSX          ,
    "DSY", //D3DSIO_DSY          ,
    "TEXLDD", //D3DSIO_TEXLDD       ,
    "SETP", //D3DSIO_SETP         ,
    "TEXLDL", //D3DSIO_TEXLDL       ,
    "BREAK_PRED", //D3DSIO_BREAKP       ,
};

static const char* const endOpcodes[] =
{
	"PHASE",
	"COMMENT",
	"END"
};

// Returns the opcode as a string suitable for diassembly
const char* const GetOpcodeString(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode)
{
	if (opcode <= D3DSIO_BREAKP)
		return opcodeToString[opcode];
	else if (opcode >= D3DSIO_PHASE && opcode <= D3DSIO_END)
		return endOpcodes[opcode - D3DSIO_PHASE];
	else
		return "UNKNOWN_OPCODE";
}

static const char* const opcodeToFunction[D3DSHADER_INSTRUCTION_OPCODE_TYPE::D3DSIO_BREAKP + 1] =
{
	"nop", //D3DSIO_NOP          = 0,
    "mov", //D3DSIO_MOV          ,
    "add", //D3DSIO_ADD          ,
    "sub", //D3DSIO_SUB          ,
    "mad", //D3DSIO_MAD          ,
    "mul", //D3DSIO_MUL          ,
    "rcp", //D3DSIO_RCP          ,
    "rsq", //D3DSIO_RSQ          ,
	"dp3", //D3DSIO_DP3          ,
    "dp4", //D3DSIO_DP4          ,
    "min", //D3DSIO_MIN          ,
    "max", //D3DSIO_MAX          ,
    "slt", //D3DSIO_SLT          ,
    "sge", //D3DSIO_SGE          ,
    "exp", //D3DSIO_EXP          ,
    "log", //D3DSIO_LOG          ,
    "lit", //D3DSIO_LIT          ,
    "dst", //D3DSIO_DST          ,
	"lrp", //D3DSIO_LRP          ,
    "frc", //D3DSIO_FRC          ,
    "m4x4", //D3DSIO_M4x4         ,
    "m4x3", //D3DSIO_M4x3         ,
    "m3x4", //D3DSIO_M3x4         ,
    "m3x3", //D3DSIO_M3x3         ,
    "m3x2", //D3DSIO_M3x2         ,
    "call", //D3DSIO_CALL         ,
    "callnz", //D3DSIO_CALLNZ       ,
    "loop", //D3DSIO_LOOP         ,
    "ret", //D3DSIO_RET          ,
    "endloop", //D3DSIO_ENDLOOP      ,
    "label", //D3DSIO_LABEL        ,
    "dcl", //D3DSIO_DCL          ,
    "pow", //D3DSIO_POW          ,
    "crs", //D3DSIO_CRS          ,
    "sgn", //D3DSIO_SGN          ,
    "abs", //D3DSIO_ABS          ,
	"nrm", //D3DSIO_NRM          ,
    "sincos", //D3DSIO_SINCOS       ,
    "rep", //D3DSIO_REP          ,
    "endrep", //D3DSIO_ENDREP       ,
    "iffunc", //D3DSIO_IF           ,
    "if_comp", //D3DSIO_IFC          ,
    "elsefunc", //D3DSIO_ELSE         ,
    "endif", //D3DSIO_ENDIF        ,
    "breakfunc", //D3DSIO_BREAK        ,
    "break_comp", //D3DSIO_BREAKC       ,
    "mova", //D3DSIO_MOVA         ,
    "defb", //D3DSIO_DEFB         ,
    "defi", //D3DSIO_DEFI         ,

	"unk49",
	"unk50",
	"unk51",
	"unk52",
	"unk53",
	"unk54",
	"unk55",
	"unk56",
	"unk57",
	"unk58",
	"unk59",
	"unk60",
	"unk61",
	"unk62",
	"unk63",

    "texcoord", //D3DSIO_TEXCOORD     = 64,
    "texkill", //D3DSIO_TEXKILL      ,
    "tex", //D3DSIO_TEX          ,
    "texbem", //D3DSIO_TEXBEM       ,
    "texbeml", //D3DSIO_TEXBEML      ,
    "texreg2ar", //D3DSIO_TEXREG2AR    ,
    "texreg2gb", //D3DSIO_TEXREG2GB    ,
    "texm3x2pad", //D3DSIO_TEXM3x2PAD   ,
    "texm3x2tex", //D3DSIO_TEXM3x2TEX   ,
    "texm3x3pad", //D3DSIO_TEXM3x3PAD   ,
    "texm3x3tex", //D3DSIO_TEXM3x3TEX   ,
    "reserved0", //D3DSIO_RESERVED0    ,
    "texm3x3spec", //D3DSIO_TEXM3x3SPEC  ,
    "texm3x3vspec", //D3DSIO_TEXM3x3VSPEC ,
    "exp", //D3DSIO_EXPP         ,
    "log", //D3DSIO_LOGP         ,
    "cnd", //D3DSIO_CND          ,
    "def", //D3DSIO_DEF          ,
    "texreg2rgb", //D3DSIO_TEXREG2RGB   ,
    "texdp3tex", //D3DSIO_TEXDP3TEX    ,
    "texm3x2depth", //D3DSIO_TEXM3x2DEPTH ,
	"texdp3", //D3DSIO_TEXDP3       ,
    "texm3x3", //D3DSIO_TEXM3x3      ,
    "texdepth", //D3DSIO_TEXDEPTH     ,
    "cmp", //D3DSIO_CMP          ,
    "bem", //D3DSIO_BEM          ,
    "dp2add", //D3DSIO_DP2ADD       ,
    "dsx", //D3DSIO_DSX          ,
    "dsy", //D3DSIO_DSY          ,
    "texldd", //D3DSIO_TEXLDD       ,
    "setp", //D3DSIO_SETP         ,
    "texldl", //D3DSIO_TEXLDL       ,
    "break_pred", //D3DSIO_BREAKP       ,
};

// Returns the name of the function that this opcode maps to
const char* const GetOpcodeFunctionString(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode)
{
	if (opcode <= D3DSIO_BREAKP)
		return opcodeToFunction[opcode];
	else
		return "function_not_found";
}

static const opcodeDisplayType opcodeTypes[D3DSHADER_INSTRUCTION_OPCODE_TYPE::D3DSIO_BREAKP + 1] =
{
	justOpcode, //D3DSIO_NOP          = 0,
    srcDst, //D3DSIO_MOV          ,
	srcSrcDst, //D3DSIO_ADD          ,
    srcSrcDst, //D3DSIO_SUB          ,
    srcSrcSrcDst, //D3DSIO_MAD          ,
    srcSrcDst, //D3DSIO_MUL          ,
    srcDst, //D3DSIO_RCP          ,
    srcDst, //D3DSIO_RSQ          ,
	srcSrcDst, //D3DSIO_DP3          ,
    srcSrcDst, //D3DSIO_DP4          ,
    srcSrcDst, //D3DSIO_MIN          ,
    srcSrcDst, //D3DSIO_MAX          ,
    srcSrcDst, //D3DSIO_SLT          ,
    srcSrcDst, //D3DSIO_SGE          ,
    srcDst, //D3DSIO_EXP          ,
    srcDst, //D3DSIO_LOG          ,
    srcDst, //D3DSIO_LIT          ,
    srcSrcDst, //D3DSIO_DST          ,
	srcSrcSrcDst, //D3DSIO_LRP          ,
    srcDst, //D3DSIO_FRC          ,
    srcSrcDst, //D3DSIO_M4x4         ,
    srcSrcDst, //D3DSIO_M4x3         ,
    srcSrcDst, //D3DSIO_M3x4         ,
    srcSrcDst, //D3DSIO_M3x3         ,
    srcSrcDst, //D3DSIO_M3x2         ,
    srcOnly, //D3DSIO_CALL         ,
    srcSrcOnly, //D3DSIO_CALLNZ       ,
    srcSrcOnly, //D3DSIO_LOOP         ,
    justOpcode, //D3DSIO_RET          ,
    justOpcode, //D3DSIO_ENDLOOP      ,
    customOpcode, //D3DSIO_LABEL        ,
    customOpcode, //D3DSIO_DCL          ,
    srcSrcDst, //D3DSIO_POW          ,
    srcSrcDst, //D3DSIO_CRS          ,
    srcSrcSrcDst, //D3DSIO_SGN          ,
    srcDst, //D3DSIO_ABS          ,
	srcDst, //D3DSIO_NRM          ,
    customOpcode, //D3DSIO_SINCOS       ,
    srcOnly, //D3DSIO_REP          ,
    justOpcode, //D3DSIO_ENDREP       ,
    srcOnly, //D3DSIO_IF           ,
    srcSrcOnly, //D3DSIO_IFC          ,
    justOpcode, //D3DSIO_ELSE         ,
    justOpcode, //D3DSIO_ENDIF        ,
    justOpcode, //D3DSIO_BREAK        ,
    srcSrcOnly, //D3DSIO_BREAKC       ,
    srcDst, //D3DSIO_MOVA         ,
    customOpcode, //D3DSIO_DEFB         ,
    customOpcode, //D3DSIO_DEFI         ,

	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,
	justOpcode,

    dstOnly, //D3DSIO_TEXCOORD     = 64,
    dstOnly, //D3DSIO_TEXKILL      ,
    customOpcode, //D3DSIO_TEX          ,
    srcDst, //D3DSIO_TEXBEM       ,
    srcDst, //D3DSIO_TEXBEML      ,
    srcDst, //D3DSIO_TEXREG2AR    ,
    srcDst, //D3DSIO_TEXREG2GB    ,
    srcDst, //D3DSIO_TEXM3x2PAD   ,
    srcDst, //D3DSIO_TEXM3x2TEX   ,
    srcDst, //D3DSIO_TEXM3x3PAD   ,
    srcDst, //D3DSIO_TEXM3x3TEX   ,
    justOpcode, //D3DSIO_RESERVED0    ,
    srcSrcDst, //D3DSIO_TEXM3x3SPEC  ,
    srcDst, //D3DSIO_TEXM3x3VSPEC ,
    srcDst, //D3DSIO_EXPP         ,
    srcDst, //D3DSIO_LOGP         ,
    srcSrcSrcDst, //D3DSIO_CND          ,
    customOpcode, //D3DSIO_DEF          ,
    srcDst, //D3DSIO_TEXREG2RGB   ,
    srcDst, //D3DSIO_TEXDP3TEX    ,
    srcDst, //D3DSIO_TEXM3x2DEPTH ,
	srcDst, //D3DSIO_TEXDP3       ,
    srcDst, //D3DSIO_TEXM3x3      ,
    dstOnly, //D3DSIO_TEXDEPTH     ,
    srcSrcSrcDst, //D3DSIO_CMP          ,
    srcSrcDst, //D3DSIO_BEM          ,
    srcSrcSrcDst, //D3DSIO_DP2ADD       ,
    srcDst, //D3DSIO_DSX          ,
    srcDst, //D3DSIO_DSY          ,
    srcSrcSrcSrcDst, //D3DSIO_TEXLDD       ,
    srcSrcDst, //D3DSIO_SETP         ,
    srcSrcDst, //D3DSIO_TEXLDL       ,
    srcOnly, //D3DSIO_BREAKP       ,
};

static const bool isOpcodeTexInstruction[D3DSHADER_INSTRUCTION_OPCODE_TYPE::D3DSIO_BREAKP + 1] =
{
	false, //D3DSIO_NOP          = 0,
    false, //D3DSIO_MOV          ,
	false, //D3DSIO_ADD          ,
    false, //D3DSIO_SUB          ,
    false, //D3DSIO_MAD          ,
    false, //D3DSIO_MUL          ,
    false, //D3DSIO_RCP          ,
    false, //D3DSIO_RSQ          ,
	false, //D3DSIO_DP3          ,
    false, //D3DSIO_DP4          ,
    false, //D3DSIO_MIN          ,
    false, //D3DSIO_MAX          ,
    false, //D3DSIO_SLT          ,
    false, //D3DSIO_SGE          ,
    false, //D3DSIO_EXP          ,
    false, //D3DSIO_LOG          ,
    false, //D3DSIO_LIT          ,
    false, //D3DSIO_DST          ,
	false, //D3DSIO_LRP          ,
    false, //D3DSIO_FRC          ,
    false, //D3DSIO_M4x4         ,
    false, //D3DSIO_M4x3         ,
    false, //D3DSIO_M3x4         ,
    false, //D3DSIO_M3x3         ,
    false, //D3DSIO_M3x2         ,
    false, //D3DSIO_CALL         ,
    false, //D3DSIO_CALLNZ       ,
    false, //D3DSIO_LOOP         ,
    false, //D3DSIO_RET          ,
    false, //D3DSIO_ENDLOOP      ,
    false, //D3DSIO_LABEL        ,
    false, //D3DSIO_DCL          ,
    false, //D3DSIO_POW          ,
    false, //D3DSIO_CRS          ,
    false, //D3DSIO_SGN          ,
    false, //D3DSIO_ABS          ,
	false, //D3DSIO_NRM          ,
    false, //D3DSIO_SINCOS       ,
    false, //D3DSIO_REP          ,
    false, //D3DSIO_ENDREP       ,
    false, //D3DSIO_IF           ,
    false, //D3DSIO_IFC          ,
    false, //D3DSIO_ELSE         ,
    false, //D3DSIO_ENDIF        ,
    false, //D3DSIO_BREAK        ,
    false, //D3DSIO_BREAKC       ,
    false, //D3DSIO_MOVA         ,
    false, //D3DSIO_DEFB         ,
    false, //D3DSIO_DEFI         ,

	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,

    false, //D3DSIO_TEXCOORD     = 64,
    false, //D3DSIO_TEXKILL      ,
    true, //D3DSIO_TEX          ,
    true, //D3DSIO_TEXBEM       ,
    true, //D3DSIO_TEXBEML      ,
    true, //D3DSIO_TEXREG2AR    ,
    true, //D3DSIO_TEXREG2GB    ,
    false, //D3DSIO_TEXM3x2PAD   ,
    true, //D3DSIO_TEXM3x2TEX   ,
    false, //D3DSIO_TEXM3x3PAD   ,
    true, //D3DSIO_TEXM3x3TEX   ,
    false, //D3DSIO_RESERVED0    ,
    true, //D3DSIO_TEXM3x3SPEC  ,
    true, //D3DSIO_TEXM3x3VSPEC ,
    false, //D3DSIO_EXPP         ,
    false, //D3DSIO_LOGP         ,
    false, //D3DSIO_CND          ,
    false, //D3DSIO_DEF          ,
    true, //D3DSIO_TEXREG2RGB   ,
    true, //D3DSIO_TEXDP3TEX    ,
    false, //D3DSIO_TEXM3x2DEPTH ,
	false, //D3DSIO_TEXDP3       ,
    false, //D3DSIO_TEXM3x3      ,
    false, //D3DSIO_TEXDEPTH     ,
    false, //D3DSIO_CMP          ,
    false, //D3DSIO_BEM          ,
    false, //D3DSIO_DP2ADD       ,
    false, //D3DSIO_DSX          ,
    false, //D3DSIO_DSY          ,
    true, //D3DSIO_TEXLDD       ,
    false, //D3DSIO_SETP         ,
    true, //D3DSIO_TEXLDL       ,
    false, //D3DSIO_BREAKP       ,
};

static const bool isDynamicBranchingInstruction[D3DSHADER_INSTRUCTION_OPCODE_TYPE::D3DSIO_BREAKP + 1] =
{
	false, //D3DSIO_NOP          = 0,
    false, //D3DSIO_MOV          ,
	false, //D3DSIO_ADD          ,
    false, //D3DSIO_SUB          ,
    false, //D3DSIO_MAD          ,
    false, //D3DSIO_MUL          ,
    false, //D3DSIO_RCP          ,
    false, //D3DSIO_RSQ          ,
	false, //D3DSIO_DP3          ,
    false, //D3DSIO_DP4          ,
    false, //D3DSIO_MIN          ,
    false, //D3DSIO_MAX          ,
    false, //D3DSIO_SLT          ,
    false, //D3DSIO_SGE          ,
    false, //D3DSIO_EXP          ,
    false, //D3DSIO_LOG          ,
    false, //D3DSIO_LIT          ,
    false, //D3DSIO_DST          ,
	false, //D3DSIO_LRP          ,
    false, //D3DSIO_FRC          ,
    false, //D3DSIO_M4x4         ,
    false, //D3DSIO_M4x3         ,
    false, //D3DSIO_M3x4         ,
    false, //D3DSIO_M3x3         ,
    false, //D3DSIO_M3x2         ,
    false, //D3DSIO_CALL         ,
    true, //D3DSIO_CALLNZ       ,
    false, //D3DSIO_LOOP         ,
    false, //D3DSIO_RET          ,
    false, //D3DSIO_ENDLOOP      ,
    false, //D3DSIO_LABEL        ,
    false, //D3DSIO_DCL          ,
    false, //D3DSIO_POW          ,
    false, //D3DSIO_CRS          ,
    false, //D3DSIO_SGN          ,
    false, //D3DSIO_ABS          ,
	false, //D3DSIO_NRM          ,
    false, //D3DSIO_SINCOS       ,
    false, //D3DSIO_REP          ,
    false, //D3DSIO_ENDREP       ,
    false, //D3DSIO_IF           ,
    true, //D3DSIO_IFC          ,
    false, //D3DSIO_ELSE         ,
    false, //D3DSIO_ENDIF        ,
    false, //D3DSIO_BREAK        ,
    true, //D3DSIO_BREAKC       ,
    false, //D3DSIO_MOVA         ,
    false, //D3DSIO_DEFB         ,
    false, //D3DSIO_DEFI         ,

	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,

    false, //D3DSIO_TEXCOORD     = 64,
    false, //D3DSIO_TEXKILL      ,
    false, //D3DSIO_TEX          ,
    false, //D3DSIO_TEXBEM       ,
    false, //D3DSIO_TEXBEML      ,
    false, //D3DSIO_TEXREG2AR    ,
    false, //D3DSIO_TEXREG2GB    ,
    false, //D3DSIO_TEXM3x2PAD   ,
    false, //D3DSIO_TEXM3x2TEX   ,
    false, //D3DSIO_TEXM3x3PAD   ,
    false, //D3DSIO_TEXM3x3TEX   ,
    false, //D3DSIO_RESERVED0    ,
    false, //D3DSIO_TEXM3x3SPEC  ,
    false, //D3DSIO_TEXM3x3VSPEC ,
    false, //D3DSIO_EXPP         ,
    false, //D3DSIO_LOGP         ,
    false, //D3DSIO_CND          ,
    false, //D3DSIO_DEF          ,
    false, //D3DSIO_TEXREG2RGB   ,
    false, //D3DSIO_TEXDP3TEX    ,
    false, //D3DSIO_TEXM3x2DEPTH ,
	false, //D3DSIO_TEXDP3       ,
    false, //D3DSIO_TEXM3x3      ,
    false, //D3DSIO_TEXDEPTH     ,
    false, //D3DSIO_CMP          ,
    false, //D3DSIO_BEM          ,
    false, //D3DSIO_DP2ADD       ,
    false, //D3DSIO_DSX          ,
    false, //D3DSIO_DSY          ,
    false, //D3DSIO_TEXLDD       ,
    false, //D3DSIO_SETP         ,
    false, //D3DSIO_TEXLDL       ,
    true, //D3DSIO_BREAKP       ,
};

static const int instructionTabIndents[D3DSHADER_INSTRUCTION_OPCODE_TYPE::D3DSIO_BREAKP + 1] =
{
	0, //D3DSIO_NOP          = 0,
    0, //D3DSIO_MOV          ,
	0, //D3DSIO_ADD          ,
    0, //D3DSIO_SUB          ,
    0, //D3DSIO_MAD          ,
    0, //D3DSIO_MUL          ,
    0, //D3DSIO_RCP          ,
    0, //D3DSIO_RSQ          ,
	0, //D3DSIO_DP3          ,
    0, //D3DSIO_DP4          ,
    0, //D3DSIO_MIN          ,
    0, //D3DSIO_MAX          ,
    0, //D3DSIO_SLT          ,
    0, //D3DSIO_SGE          ,
    0, //D3DSIO_EXP          ,
    0, //D3DSIO_LOG          ,
    0, //D3DSIO_LIT          ,
    0, //D3DSIO_DST          ,
	0, //D3DSIO_LRP          ,
    0, //D3DSIO_FRC          ,
    0, //D3DSIO_M4x4         ,
    0, //D3DSIO_M4x3         ,
    0, //D3DSIO_M3x4         ,
    0, //D3DSIO_M3x3         ,
    0, //D3DSIO_M3x2         ,
    0, //D3DSIO_CALL         ,
    0, //D3DSIO_CALLNZ       ,
    1, //D3DSIO_LOOP         ,
    0, //D3DSIO_RET          ,
    -1, //D3DSIO_ENDLOOP      ,
    0, //D3DSIO_LABEL        ,
    0, //D3DSIO_DCL          ,
    0, //D3DSIO_POW          ,
    0, //D3DSIO_CRS          ,
    0, //D3DSIO_SGN          ,
    0, //D3DSIO_ABS          ,
	0, //D3DSIO_NRM          ,
    0, //D3DSIO_SINCOS       ,
    1, //D3DSIO_REP          ,
    -1, //D3DSIO_ENDREP       ,
    1, //D3DSIO_IF           ,
    1, //D3DSIO_IFC          ,
    0, //D3DSIO_ELSE         ,
    -1, //D3DSIO_ENDIF        ,
    0, //D3DSIO_BREAK        ,
    0, //D3DSIO_BREAKC       ,
    0, //D3DSIO_MOVA         ,
    0, //D3DSIO_DEFB         ,
    0, //D3DSIO_DEFI         ,

	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,

    0, //D3DSIO_TEXCOORD     = 64,
    0, //D3DSIO_TEXKILL      ,
    0, //D3DSIO_TEX          ,
    0, //D3DSIO_TEXBEM       ,
    0, //D3DSIO_TEXBEML      ,
    0, //D3DSIO_TEXREG2AR    ,
    0, //D3DSIO_TEXREG2GB    ,
    0, //D3DSIO_TEXM3x2PAD   ,
    0, //D3DSIO_TEXM3x2TEX   ,
    0, //D3DSIO_TEXM3x3PAD   ,
    0, //D3DSIO_TEXM3x3TEX   ,
    0, //D3DSIO_RESERVED0    ,
    0, //D3DSIO_TEXM3x3SPEC  ,
    0, //D3DSIO_TEXM3x3VSPEC ,
    0, //D3DSIO_EXPP         ,
    0, //D3DSIO_LOGP         ,
    0, //D3DSIO_CND          ,
    0, //D3DSIO_DEF          ,
    0, //D3DSIO_TEXREG2RGB   ,
    0, //D3DSIO_TEXDP3TEX    ,
    0, //D3DSIO_TEXM3x2DEPTH ,
	0, //D3DSIO_TEXDP3       ,
    0, //D3DSIO_TEXM3x3      ,
    0, //D3DSIO_TEXDEPTH     ,
    0, //D3DSIO_CMP          ,
    0, //D3DSIO_BEM          ,
    0, //D3DSIO_DP2ADD       ,
    0, //D3DSIO_DSX          ,
    0, //D3DSIO_DSY          ,
    0, //D3DSIO_TEXLDD       ,
    0, //D3DSIO_SETP         ,
    0, //D3DSIO_TEXLDL       ,
    0, //D3DSIO_BREAKP       ,
};

const opcodeDisplayType GetOpcodeDisplayType(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode)
{
	if (opcode <= D3DSIO_DEFI)
		return opcodeTypes[opcode];
	else if (opcode >= D3DSIO_TEXCOORD && opcode <= D3DSIO_BREAKP)
		return opcodeTypes[opcode];
	else
		return customOpcode;
}

struct ShaderComment_DBUG
{
	DWORD magic; // Should always be 'DBUG'
	DWORD size; // Should always be 0x28
	DWORD unknown0; // Seems to be 0x0290 (656 in dec)
	DWORD zero0;
	DWORD one0;
	DWORD unknown1; // Seems to be 0xA4 (164 in dec)
	DWORD unknown2; // Seems to be 0x19 (25 in dec)
	DWORD unknown3; // Seems to be 0xA8 (168 in dec)
	DWORD unknown4; // Seems to be 0x04
	DWORD unknown5; // Seems to be 0x0240 (576 in dec)
	DWORD unknown6; // Seems to be 0x0170 (368 in dec)
	char filename[1];
};

struct ShaderComment_CTAB
{
	DWORD magic; // Should always be 'CTAB'
	DWORD size; // Should always be 0x1C
	DWORD unknown0; // Seems to be 0x97 (151 dec)
	signed short unknown1; // Seems to be 0xFFFE (-2 in signed int)
	unsigned short unknown2; // Seems to be 0x200 (512 in dec)
	DWORD unknown3; // Seems to be 0x3 (the number of named global constants?)
	DWORD unknown4; // Seems to be 0x1C again
	DWORD unknown5; // Seems to be 0x105 (261 dec)
	DWORD unknown6; // Seems to be 0x90 (144 dec)
	DWORD unknown7; // Seems to be 0x58 (88 dec)
	unsigned short unknown8; // Seems to be 0x2
	unsigned short unknown9; // Seems to be 0x8
	unsigned short unknown10; // Seems to be 0x100 (256 dec)
	unsigned short unknown11; // Seems to be 0x2200 (8704 dec)
	unsigned short unknown12; // Seems to be 0x6400 (25600 dec)
	unsigned short zero0;
};

static const char* const usageStrings[] =
{
	"_POSITION",
	"_BLENDWEIGHT", 
	"_BLENDINDICES",
	"_NORMAL",      
	"_PSIZE",       
	"_TEXCOORD",    
	"_TANGENT",     
	"_BINORMAL",    
	"_TESSFACTOR",  
	"_POSITIONT",   
	"_COLOR",       
	"_FOG",         
	"_DEPTH",       
	"_SAMPLE"
};

template <const bool print>
static inline const bool ParseCustomOpcode(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode, const DWORD*& shaderMemory, ShaderInfo& shaderInfo, unsigned long& uniqueTempRegistersUsed, unsigned short& uniqueInputRegistersUsed, outputRegisterWriteTracker& outRegisterwriteTracker)
{
	if (print) dprintf(shaderInfo, "%s ", GetOpcodeString(opcode) );

	switch (opcode)
	{
	case D3DSIO_LABEL:
	{
		ShaderLabel newLabel;
		const srcParameterToken& srcParameter = *(const srcParameterToken* const)shaderMemory;
		newLabel.labelIndex = srcParameter.GetRegisterIndex();
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed); // Note that ResolveSrcParameter<print> also increments the bytecode stream pointer given to it
		newLabel.firstPostLabelToken = shaderMemory;
		shaderInfo.labels.push_back(newLabel);
	}
		break;
	case D3DSIO_DCL:
	{
		const DWORD dwordToken = *shaderMemory++;
		const dstParameterToken& dstParameter = *(const dstParameterToken* const)shaderMemory++;
		const D3DSHADER_PARAM_REGISTER_TYPE registerType = dstParameter.GetRegisterType();

		const D3DDECLUSAGE usage = (const D3DDECLUSAGE)( (dwordToken & D3DSP_DCL_USAGE_MASK) >> D3DSP_DCL_USAGE_SHIFT);
		const unsigned usageIndex = (dwordToken & D3DSP_DCL_USAGEINDEX_MASK) >> D3DSP_DCL_USAGEINDEX_SHIFT;

		DeclaredRegister newRegisterDcl;
		newRegisterDcl.isOutputRegister = registerType == D3DSPR_OUTPUT;
		newRegisterDcl.registerIndex = dstParameter.GetRegisterIndex();
		newRegisterDcl.registerType = registerType;
		newRegisterDcl.writeMask = dstParameter.GetWriteMask();
		newRegisterDcl.usageType = usage;
		newRegisterDcl.usageIndex = usageIndex;
		newRegisterDcl.miscInfo.uintData = 0;

		// Decode the DWORD token depending on the type of the Dst parameter
		switch (registerType)
		{
		case D3DSPR_SAMPLER:
		{
			const D3DSAMPLER_TEXTURE_TYPE textureType = (const D3DSAMPLER_TEXTURE_TYPE)(dwordToken & D3DSP_TEXTURETYPE_MASK);
			switch (textureType)
			{
			default:
				if (print) dprintf(shaderInfo, "Unknown sampler type (%u)\n", textureType >> D3DSP_TEXTURETYPE_SHIFT);
				break;
			case D3DSTT_UNKNOWN:
				if (print) dprintf(shaderInfo, "Unknown sampler type\n");
				break;
			case D3DSTT_2D     :
				if (print) dprintf(shaderInfo, "_2d");
				break;
			case D3DSTT_CUBE   :
				if (print) dprintf(shaderInfo, "_cube");
				break;
			case D3DSTT_VOLUME :
				if (print) dprintf(shaderInfo, "_volume");
				break;
			}
			newRegisterDcl.miscInfo.textureType = textureType;
			break;
		}
		case D3DSPR_TEXTURE:
		{
			// Nothing special here!
		}
			break;

		case D3DSPR_INPUT:
		{
			if (print) dprintf(shaderInfo, "%s", usageStrings[usage]);
			if (print) dprintf(shaderInfo, "%u ", usageIndex);
		}
			break;
		case D3DSPR_OUTPUT:
		{
			const DWORD* temp = &dstParameter.internalRawToken;
			ResolveDstParameter<print, false>(temp, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		}
			break;
		case D3DSPR_MISCTYPE: // Either VPOS (0) or FACE (1)
		{
			const D3DSHADER_MISCTYPE_OFFSETS miscRegisterType = (const D3DSHADER_MISCTYPE_OFFSETS)dstParameter.GetRegisterIndex();
			switch (miscRegisterType)
			{
			case D3DSMO_POSITION:
				if (print) dprintf(shaderInfo, "_VPOS");
				break;
			case D3DSMO_FACE:
				if (print) dprintf(shaderInfo, "_FACE");
				break;
			default:
				if (print) dprintf(shaderInfo, "Error: Unknown MISC register file index (%u)", miscRegisterType);
				break;
			}

			newRegisterDcl.miscInfo.miscInputType = miscRegisterType;
		}
			break;
		default:
			break;
		}

		shaderInfo.declaredRegisters.push_back(newRegisterDcl);

		if (print) dprintf(shaderInfo, " ");

		// Print the register afterwards:
		{
			const DWORD* temp = &dstParameter.internalRawToken;
			ResolveDstParameter<print, false>(temp, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		}

		// Print the usage for this decl after that (this isn't what D3DXDisasm does, but it really helps with debugging shaders to have it shown somewhere)
		if (print)
		{
			dprintf(shaderInfo, " : %s%u", usageStrings[usage], usageIndex);
		}
	}
		break;
	case D3DSIO_SINCOS:
		ResolveDstParameter<print, true>(shaderMemory, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (shaderInfo.shaderMajorVersion < 3) // Shader model 2 has these extra registers, but all the shader model 3+ don't have them
		{
			if (print) dprintf(shaderInfo, ", ");
			ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
			if (print) dprintf(shaderInfo, ", ");
			ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		}
		break;
	case D3DSIO_DEFB:
	{
		InitialConstantValueB newConstantB;
		const dstParameterToken& dstParameter = *(const dstParameterToken* const)shaderMemory;
		newConstantB.constantRegisterIndex = dstParameter.GetRegisterIndex();
		ResolveDstParameter<print, false>(shaderMemory, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		const DWORD dwordData = *shaderMemory++;
		const BOOL bData = (const BOOL)(dwordData);
		if (bData)
		{
			if (print) dprintf(shaderInfo, ", TRUE");
			newConstantB.initialValue = TRUE;
		}
		else
		{
			if (print) dprintf(shaderInfo, ", FALSE");
			newConstantB.initialValue = FALSE;
		}

		shaderInfo.initialConstantValuesB.push_back(newConstantB);
	}
		break;
	case D3DSIO_DEFI:
	{
		InitialConstantValueI newConstantI;
		const dstParameterToken& dstParameter = *(const dstParameterToken* const)shaderMemory;
		newConstantI.constantRegisterIndex = dstParameter.GetRegisterIndex();
		ResolveDstParameter<print, false>(shaderMemory, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		const DWORD dword0 = *shaderMemory++;
		newConstantI.initialValue.x = *(const int* const)&dword0;
		const DWORD dword1 = *shaderMemory++;
		newConstantI.initialValue.y = *(const int* const)&dword1;
		const DWORD dword2 = *shaderMemory++;
		newConstantI.initialValue.z = *(const int* const)&dword2;
		const DWORD dword3 = *shaderMemory++;
		newConstantI.initialValue.w = *(const int* const)&dword3;

		if (print) dprintf(shaderInfo, ", (%i, %i, %i, %i)", newConstantI.initialValue.x, newConstantI.initialValue.y, newConstantI.initialValue.z, newConstantI.initialValue.w);

		shaderInfo.initialConstantValuesI.push_back(newConstantI);
	}
		break;
	case D3DSIO_DEF:
	{
		InitialConstantValue newConstant;
		const dstParameterToken& dstParameter = *(const dstParameterToken* const)shaderMemory;
		newConstant.constantRegisterIndex = dstParameter.GetRegisterIndex();
		ResolveDstParameter<print, false>(shaderMemory, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		const DWORD dword0 = *shaderMemory++;
		newConstant.initialValue.x = *(const float* const)&dword0;
		const DWORD dword1 = *shaderMemory++;
		newConstant.initialValue.y = *(const float* const)&dword1;
		const DWORD dword2 = *shaderMemory++;
		newConstant.initialValue.z = *(const float* const)&dword2;
		const DWORD dword3 = *shaderMemory++;
		newConstant.initialValue.w = *(const float* const)&dword3;

		if (print) dprintf(shaderInfo, ", (%f, %f, %f, %f)", newConstant.initialValue.x, newConstant.initialValue.y, newConstant.initialValue.z, newConstant.initialValue.w);

		shaderInfo.initialConstantValues.push_back(newConstant);
	}
		break;
	case D3DSIO_TEX: // TEX means a whole lot of things. It can be tex from ps_1_0 thru ps_1_3, it can be texld from ps_1_4, or it can be texld for ps_1_4 and up.
		// Depending on the opcode controls, this can either be "plain texld/tex2D" (no controls), or texldp/tex2Dproj or texldb/tex2Dbias
		// Depending on the sampler source register, this can also be either tex1D, tex2D, tex3D, or texCUBE
	{
		ResolveDstParameter<print, true>(shaderMemory, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		if (shaderInfo.shaderMajorVersion < 2)
		{
			if (shaderInfo.shaderMinorVersion < 4)
			{
				// This is the ps_1_0 thru ps_1_3 case: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/tex---ps
				// Just T dst
			}
			else
			{
				// This is the ps_1_4 case: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/texld---ps-1-4
				// tex R dst, T/R src0
				if (print) dprintf(shaderInfo, ", ");
				ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
			}
		}
		else
		{
			// This is the ps_2_0+ case: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/texld---ps-2-0
			// tex R dst, T/R/V src0, S src1
			if (print) dprintf(shaderInfo, ", ");
			ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);

			if (print) dprintf(shaderInfo, ", ");
			ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		}
	}
		break;
	case D3DSIO_PHASE:
		break;
	case D3DSIO_COMMENT:
	{
		const DWORD commentToken = shaderMemory[-1];
		const unsigned numTokensToSkip = (commentToken & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;

		ShaderComment newComment;
		newComment.commentLengthTokens = numTokensToSkip;
		newComment.commentText = (const char* const)shaderMemory;
		shaderInfo.comments.push_back(newComment);

		switch (*shaderMemory)
		{
		case 'GUBD': // DBUG
		{
			const ShaderComment_DBUG* const dbug = (const ShaderComment_DBUG* const)shaderMemory;
			if (dbug->magic == 'GUBD')
			{
				if (dbug->size == 0x28)
				{
					if (print) dprintf(shaderInfo, "Shader compiled from: \"%s\"\n", dbug->filename);
				}
				else
				{
					if (print) dprintf(shaderInfo, "Error: Unexpected DBUG struct size detected! (Got %u, expected %u)\n", dbug->size, 0x28);
				}
			}
			else
			{
				if (print) dprintf(shaderInfo, "Error: Invalid DBUG struct magic value detected!\n");
			}
		}
			break;
		case 'BATC': // CTAB
		{
			const ShaderComment_CTAB* const ctab = (const ShaderComment_CTAB* const)shaderMemory;
			if (ctab->magic == 'BATC')
			{
				; // 
			}
			else
			{
				if (print) dprintf(shaderInfo, "Error: Invalid CTAB struct magic value detected!\n");
			}
		}
			break;
		}
		
		shaderMemory += numTokensToSkip;
	}
		break;
	case D3DSIO_END:
		if (print) dprintf(shaderInfo, "\n");
		shaderInfo.shaderLengthDWORDs = shaderMemory - shaderInfo.initialBytecodeToken;
		return true;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Unknown shader opcode");
#endif
		if (print) dprintf(shaderInfo, "Unknown opcode encountered (value 0x%08X)\n", opcode);
		break;
	}

	if (print) dprintf(shaderInfo, "\n");

	return false;
}

// Returns true if this opcode is a TEX instruction, or false otherwise
const bool IsOpcodeTexInstruction(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode)
{
	if (opcode <= D3DSIO_BREAKP)
		return isOpcodeTexInstruction[opcode];
	else
		return false;
}

static inline const bool IsDynamicBranchingInstruction(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode)
{
	if (opcode <= D3DSIO_BREAKP)
		return isDynamicBranchingInstruction[opcode];
	else
		return false;
}

static inline const int GetTabIndentModifier(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode)
{
	if (opcode <= D3DSIO_BREAKP)
		return instructionTabIndents[opcode];
	else
		return 0;
}

template <const bool print>
static inline const bool ParseOpcode(const DWORD*& shaderMemory, ShaderInfo& shaderInfo, unsigned long& uniqueTempRegistersUsed, unsigned short& uniqueInputRegistersUsed, int& tabIndents, outputRegisterWriteTracker& outRegisterwriteTracker)
{
	const instructionToken rawInstructionToken = *(const instructionToken* const)shaderMemory++;
	const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode = (const D3DSHADER_INSTRUCTION_OPCODE_TYPE)(rawInstructionToken.opcode);

	const bool opcodeIsTexInstruction = IsOpcodeTexInstruction(opcode);
	unsigned* const instructionCount = &(shaderInfo.numArithInstructions);
	++instructionCount[opcodeIsTexInstruction];

	const bool opcodeIsDynamicBranchInstruction = IsDynamicBranchingInstruction(opcode);
	if (opcodeIsDynamicBranchInstruction)
		shaderInfo.usesDynamicBranching = true;

	if (opcode == D3DSIO_TEXKILL)
		shaderInfo.usesTexkill = true;

	if (rawInstructionToken.predicated)
		shaderInfo.usesInstructionPredication = true;

	if (rawInstructionToken.coIssue)
		shaderInfo.usesInstructionCoIssue = true;

	if (opcode == D3DSIO_TEXDEPTH || opcode == D3DSIO_TEXM3x2DEPTH)
		shaderInfo.psWritesDepth = true;

	switch (opcode)
	{
	case D3DSIO_CALL:
	case D3DSIO_CALLNZ:
		shaderInfo.usesFunctionCalls = true;
		break;
	default:
		break;
	}

	if (!shaderInfo.firstInstructionToken)
	{
		switch (opcode)
		{
			// Skippable instructions:
		case D3DSIO_NOP:
		case D3DSIO_DCL:
		case D3DSIO_DEF:
		case D3DSIO_PHASE:
		case D3DSIO_COMMENT:
		case D3DSIO_END:
			break;
			// First non-skippable instruction:
		default:
			shaderInfo.firstInstructionToken = shaderMemory - 1;
			break;
		}
	}

	switch (opcode)
	{
	case D3DSIO_DSX:
	case D3DSIO_DSY:
		if (!shaderInfo.isPixelShader)
			shaderInfo.parsingErrorDetected = true; // ddx and ddy are only available for pixel shaders!
		shaderInfo.usesGradientInstructions = true;
		break;
	default:
		break;
	}

	// Handle tabs:
	if (print)
	{
		for (int x = 0; x < tabIndents; ++x)
			dprintf(shaderInfo, "\t");

		tabIndents += GetTabIndentModifier(opcode);
#ifdef _DEBUG
		if (tabIndents < 0)
		{
			DbgBreakPrint("Error: Tab indents negative");
		}
#endif
	}

	if (opcode == D3DSIO_MOV)
	{
		// Handle int->float conversion checks:
		const srcParameterToken& srcParameter = *(const srcParameterToken* const)(shaderMemory + 1);
		switch (srcParameter.GetRegisterType() )
		{
		case D3DSPR_CONSTINT:
		case D3DSPR_CONSTBOOL:
			shaderInfo.usesIntToFloatConversions = true;
			break;
		default:
			break;
		}

		// Handle MRT detection:
		if (shaderInfo.isPixelShader)
		{
			const dstParameterToken& dstParameter = *(const dstParameterToken* const)shaderMemory;
			if (dstParameter.GetRegisterType() == D3DSPR_COLOROUT)
			{
				const unsigned outputRegisterIndex = dstParameter.GetRegisterIndex();
				shaderInfo.usedMRTMask |= (1 << outputRegisterIndex);
			}
		}
	}

	if (rawInstructionToken.coIssue)
		if (print) dprintf(shaderInfo, "+ CO_");

	switch (GetOpcodeDisplayType(opcode) )
	{
	case customOpcode:
		return ParseCustomOpcode<print>(opcode, shaderMemory, shaderInfo, uniqueTempRegistersUsed, uniqueInputRegistersUsed, outRegisterwriteTracker);
	case justOpcode:
		if (print) dprintf(shaderInfo, "%s\n", GetOpcodeString(opcode) );
		break;
	case srcOnly:
		if (print) dprintf(shaderInfo, "%s ", GetOpcodeString(opcode) );
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, "\n");
		break;
	case srcSrcOnly:
		if (print) dprintf(shaderInfo, "%s ", GetOpcodeString(opcode) );
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, "\n");
		break;
	case dstOnly:
		if (print) dprintf(shaderInfo, "%s ", GetOpcodeString(opcode) );
		ResolveDstParameter<print, true>(shaderMemory, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		if (print) dprintf(shaderInfo, "\n");
		break;
	case srcDst:
		if (print) dprintf(shaderInfo, "%s ", GetOpcodeString(opcode) );
		ResolveDstParameter<print, true>(shaderMemory, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, "\n");
		break;
	case srcSrcDst:
		if (print) dprintf(shaderInfo, "%s ", GetOpcodeString(opcode) );
		ResolveDstParameter<print, true>(shaderMemory, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, "\n");
		break;
	case srcSrcSrcDst:
		if (print) dprintf(shaderInfo, "%s ", GetOpcodeString(opcode) );
		ResolveDstParameter<print, true>(shaderMemory, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, "\n");
		break;
	case srcSrcSrcSrcDst: // Only ever used with D3DSIO_TEXLDD
		if (print) dprintf(shaderInfo, "%s ", GetOpcodeString(opcode) );
		ResolveDstParameter<print, true>(shaderMemory, shaderInfo, uniqueTempRegistersUsed, outRegisterwriteTracker);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, ", ");
		ResolveSrcParameter<print>(shaderInfo, shaderMemory, shaderInfo.isPixelShader, uniqueTempRegistersUsed, uniqueInputRegistersUsed);
		if (print) dprintf(shaderInfo, "\n");
		break;
	default:
		DbgBreakPrint("Error: Unknown shader parameters type");
		break;
	}
	return false;
}

template <const bool print>
static inline void ShaderAnalysisMain(const DWORD* shaderMemory, ShaderInfo& ret
#ifdef _DEBUG
	, const char* const filename
#endif
	)
{
	ret.initialBytecodeToken = shaderMemory;

	if (!shaderMemory)
	{
		ret.parsingErrorDetected = true;
		return;
	}

#ifdef DISASM_SHADER
	D3DXDisassembleShader(shaderMemory, FALSE, NULL, &ret.D3DXDisasm);
	if (ret.D3DXDisasm)
		ret.D3DXDisasmString = (const char* const)ret.D3DXDisasm->GetBufferPointer();
#endif // DISASM_SHADER

	outputRegisterWriteTracker outRegisterwriteTracker;

	const versionToken* const version = (const versionToken* const)shaderMemory;
	switch (version->pixelOrVertexShader)
	{
	case (verToken_vertexShader): // Vertex shader
		ret.isPixelShader = false;
		break;
	case (verToken_PixelShader): // Pixel shader
		ret.isPixelShader = true;
		break;
	default:
#ifdef _DEBUG
		DbgBreakPrint("Error: Shader is neither a vertex shader nor a pixel shader");
#endif
		ret.parsingErrorDetected = true;
		return;
	}

	ret.shaderMajorVersion = version->majorVersion;
	ret.shaderMinorVersion = version->minorVersion;

	if (ret.shaderMajorVersion < 1 || ret.shaderMajorVersion > 3)
	{
		ret.parsingErrorDetected = true;
#ifdef _DEBUG
		DbgBreakPrint("Error: Shader model is out of bounds for D3D9!");
#endif
		return;
	}

	if (ret.shaderMinorVersion > 4)
	{
		ret.parsingErrorDetected = true;
#ifdef _DEBUG
		DbgBreakPrint("Error: Shader model minor version greater than 4");
#endif
		return;
	}

	unsigned long uniqueTempRegistersUsed = 0x00000000;
	unsigned short uniqueInputRegistersUsed = 0x0000;

	// Move forwards one token to the first instruction/definition/declaration:
	++shaderMemory;

	int tabIndents;
	if (print)
		tabIndents = 0;

	bool doneParsing = false;
	while (!doneParsing)
	{
		doneParsing = ParseOpcode<print>(shaderMemory, ret, uniqueTempRegistersUsed, uniqueInputRegistersUsed, tabIndents, outRegisterwriteTracker);
	}

	outRegisterwriteTracker.AddOutputRegisterListingToShaderInfo(ret);

	for (unsigned x = 0; x < ret.shaderLengthDWORDs; ++x)
	{
		ret.shaderBytecodeHash = _rotl(ret.shaderBytecodeHash, 1);
		const DWORD newToken = ret.initialBytecodeToken[x];
		ret.shaderBytecodeHash ^= newToken;
	}

#ifdef DISASM_SHADER
	ret.shaderDisasmText.push_back('\0');
	ret.shaderDisasmBuffer = &ret.shaderDisasmText.front();
#endif

	ret.tempRegistersUsedBitmask = uniqueTempRegistersUsed;
	ret.numUniqueTempRegistersUsed = __popcnt(uniqueTempRegistersUsed);

	ret.inputRegistersUsedBitmask = uniqueInputRegistersUsed;
	ret.numUniqueInputRegistersUsed = (const unsigned short)(__popcnt(uniqueInputRegistersUsed) );

	if (ret.isPixelShader && ret.shaderMajorVersion == 1)
		ret.usedMRTMask |= 0x1; // ps_1_* shaders leave their color output in r0 instead of moving it into one of the oC[N] registers (which don't exist for version 1.x pixel shaders because MRT didn't exist back then)

	if (ret.numTexInstructions > 0 && !ret.isPixelShader)
		ret.usesVertTextureFetch = true;

	// It's an error for pixel shaders to not write out any color-channel data:
	if (ret.isPixelShader && ret.usedMRTMask == 0)
		ret.parsingErrorDetected = true;

	if (ret.usedMRTMask > 1)
		ret.usesMRT = true;

	return;
}

void DisasmAndAnalyzeShader(const DWORD* shaderMemory, ShaderInfo& shaderInfoOut
#ifdef _DEBUG
	, const char* const filename
#endif
	)
{
	ShaderAnalysisMain<true>(shaderMemory, shaderInfoOut
#ifdef _DEBUG
		, filename
#endif
		);

#ifdef DISASM_SHADER
	printf("%s\n", &shaderInfoOut.shaderDisasmText.front() );
#endif
}

void AnalyzeShader(const DWORD* shaderMemory, ShaderInfo& shaderInfoOut
#ifdef _DEBUG
	, const char* const filename
#endif
	)
{
	ShaderAnalysisMain<
#ifdef DISASM_SHADER
		true
#else
		false
#endif
	>(shaderMemory, shaderInfoOut
#ifdef _DEBUG
		, filename
#endif
		);
}

void outputRegisterWriteTracker::SetAddOrSkip(const D3DSHADER_PARAM_REGISTER_TYPE registerType, const unsigned registerIndex, const BYTE writeMask, const dstParameterToken& dstParameter, const instructionToken* const _writeInstruction, const dstParameterToken* const optionalRelativeRegister/* = NULL*/)
{
	outputRegisterWriteState& thisRegWriteState = writtenRegisters[registerType][registerIndex];
	if (thisRegWriteState.writeMaskFinalState == 0x00)
	{
		outputRegisterIdentifier registerIdentifier;
		registerIdentifier.outputRegisterType = (const BYTE)registerType;
		registerIdentifier.outputRegisterNumber = registerIndex;
		registerIdentifiers.push_back(registerIdentifier);
	}

	outputRegisterWriteOperation newWriteOperation;
	newWriteOperation.writeInstruction = _writeInstruction;
	newWriteOperation.registerParameterToken = &dstParameter;
	newWriteOperation.optionalRelativeAddressingDestParameterToken = optionalRelativeRegister;
	newWriteOperation.instructionSourceParameterTokens = (const srcParameterToken* const)(&dstParameter + 1);
	newWriteOperation.operationWriteMask = writeMask;
	thisRegWriteState.writeOperations.push_back(newWriteOperation);

	thisRegWriteState.writeMaskFinalState |= writeMask;
}

void outputRegisterWriteTracker::AddOutputRegisterListingToShaderInfo(ShaderInfo& outShaderInfo)
{
	const unsigned numWrittenOutputRegisters = registerIdentifiers.size();
	for (unsigned x = 0; x < numWrittenOutputRegisters; ++x)
	{
		const outputRegisterIdentifier& registerIdentifier = registerIdentifiers[x];

		outputRegisterWriteState registerWriteState = writtenRegisters[registerIdentifier.outputRegisterType][registerIdentifier.outputRegisterNumber];
		WrittenOutputRegister newRegister;
		newRegister.registerType = (const D3DSHADER_PARAM_REGISTER_TYPE)(registerIdentifier.outputRegisterType);
		newRegister.registerIndex = registerIdentifier.outputRegisterNumber;
		newRegister.componentChannelsWritten = registerWriteState.writeMaskFinalState;
		newRegister.writeOperationsHistory.swap(registerWriteState.writeOperations); // Swap is really fast!
		outShaderInfo.writtenOutputRegisters.push_back(newRegister);
	}
}

```

`Software_d3d9/ShaderAnalysis.h`:

```h
#pragma once

#include "d3d9include.h"
#include "ShaderBase.h"

#include <vector> // for std::vector

#include <stdio.h> // for printf

// Uncomment to disable
#define DISASM_SHADER 1

struct ShaderInfo;

struct InitialConstantValueBase
{
	unsigned constantRegisterIndex;
};

struct InitialConstantValue : public InitialConstantValueBase
{
	D3DXVECTOR4 initialValue;
};

struct InitialConstantValueI : public InitialConstantValueBase
{
	int4 initialValue;
};

struct InitialConstantValueB : public InitialConstantValueBase
{
	BOOL initialValue;
};

enum opcodeDisplayType
{
	justOpcode = 0,
	srcOnly,
	srcSrcOnly,
	dstOnly,
	srcDst,
	srcSrcDst,
	srcSrcSrcDst,
	srcSrcSrcSrcDst, // Only ever used with D3DSIO_TEXLDD
	customOpcode
};

// Thanks for all the documentation at: https://msdn.microsoft.com/en-us/library/windows/hardware/ff549176(v=vs.85).aspx
struct DeclaredRegister
{
	D3DSHADER_PARAM_REGISTER_TYPE registerType; // Sampler, input (from vertex decl), output, etc.
	D3DDECLUSAGE usageType; // If this is an input register for a VS, what is the usage that's coming in from the vertex declaration?
	unsigned usageIndex; // If this has a valid usage value, this is its usage index (POSITION0, COLOR2, TEXCOORD4, etc.)
	unsigned registerIndex;
	bool isOutputRegister; // true = output, false = input (output declarations are optional in SM3.0)
	unsigned char writeMask : 4; // Which channels are present on this register (x, y, z, and/or w)?
	union
	{
		D3DSAMPLER_TEXTURE_TYPE textureType; // Used only if this is a sampler
		D3DSHADER_MISCTYPE_OFFSETS miscInputType; // Used only if this is a misc. register
		D3DVS_RASTOUT_OFFSETS rasterOutType; // Used only if this is a rasterizer output register
		DWORD uintData;
	} miscInfo;
};

struct ShaderLabel
{
	unsigned labelIndex;
	const DWORD* firstPostLabelToken;
};

struct ShaderComment
{
	unsigned commentLengthTokens; // Length of the comment, in tokens (not including the comment token itself)
	const char* commentText; // Points to the beginning of the comment text
};

struct outputRegisterWriteTracker
{
	outputRegisterWriteTracker()
	{
	}

	struct outputRegisterIdentifier
	{
		BYTE outputRegisterType;
		BYTE outputRegisterNumber;
	};

	struct outputRegisterWriteOperation
	{
		outputRegisterWriteOperation() : writeInstruction(NULL), registerParameterToken(NULL), optionalRelativeAddressingDestParameterToken(NULL), instructionSourceParameterTokens(NULL), operationWriteMask(0xF)
		{
		}

		const instructionToken* writeInstruction;
		const dstParameterToken* registerParameterToken;
		const dstParameterToken* optionalRelativeAddressingDestParameterToken;
		const srcParameterToken* instructionSourceParameterTokens;
		BYTE operationWriteMask;
	};

	struct outputRegisterWriteState
	{
		outputRegisterWriteState() : writeMaskFinalState(0x00)
		{
		}

		std::vector<outputRegisterWriteOperation> writeOperations;
		BYTE writeMaskFinalState;
	};

	void SetAddOrSkip(const D3DSHADER_PARAM_REGISTER_TYPE registerType, const unsigned registerIndex, const BYTE writeMask, const dstParameterToken& dstParameter, const instructionToken* const writeInstruction, const dstParameterToken* const optionalRelativeRegister = NULL);

	void AddOutputRegisterListingToShaderInfo(ShaderInfo& outShaderInfo);

	static const unsigned MAX_SHADER_REGISTER_TYPES = D3DSPR_PREDICATE + 1;

	// 12 comes from vs_3_0 which supports 12 vertex shader output registers (o0 thru o11)
	static const unsigned MAX_SHADER_OUTPUT_REGISTERS = 12;

	outputRegisterWriteState writtenRegisters[MAX_SHADER_REGISTER_TYPES][MAX_SHADER_OUTPUT_REGISTERS];

	// This vector stores all of the output register identifiers in the order that they were found in the shader:
	std::vector<outputRegisterIdentifier> registerIdentifiers;
};

struct WrittenOutputRegister
{
	WrittenOutputRegister() : registerType(D3DSPR_TEMP), registerIndex(0), componentChannelsWritten(0x00)
	{
	}

	D3DSHADER_PARAM_REGISTER_TYPE registerType;
	unsigned registerIndex;
	BYTE componentChannelsWritten; /* For D3D8 shaders this is okay to be anything nonzero, but for D3D9 SM1.1 or SM2.0 shader validation it must be always 0xF (as it's
	illegal to not write all channels in an output register until SM3.0 when partial writes to output registers were allowed again) */

	// A history (in the order of which writes occurred in the shader) of all write operations to this shader output register
	std::vector<outputRegisterWriteTracker::outputRegisterWriteOperation> writeOperationsHistory;
};

struct ShaderInfo
{
	ShaderInfo() : parsingErrorDetected(false), isPixelShader(false), shaderMajorVersion(0), shaderMinorVersion(0), 
		shaderLengthDWORDs(0), numArithInstructions(0), numTexInstructions(0), tempRegistersUsedBitmask(0), numUniqueTempRegistersUsed(0),
		usesDynamicBranching(false), usesFunctionCalls(false), usesVertTextureFetch(false), hasDependentTextureFetches(false), usesMRT(false), firstInstructionToken(NULL),
		usesIntToFloatConversions(false), usesTexkill(false), usesGradientInstructions(false), initialBytecodeToken(NULL), usedMRTMask(0), psWritesDepth(false), 
		usesInstructionPredication(false), usesInstructionCoIssue(false), shaderBytecodeHash(0), inputRegistersUsedBitmask(0), numUniqueInputRegistersUsed(0)
#ifdef DISASM_SHADER
		, shaderDisasmBuffer(NULL), D3DXDisasm(NULL), D3DXDisasmString(NULL)
#endif
	{
		initialConstantValues.clear();
		initialConstantValuesI.clear();
		initialConstantValuesB.clear();
		usedConstantsF.clear();
		usedConstantsI.clear();
		usedConstantsB.clear();
		declaredRegisters.clear();
		writtenOutputRegisters.clear();
		labels.clear();
		comments.clear();
#ifdef DISASM_SHADER
		shaderDisasmBuffer = NULL;
		D3DXDisasmString = NULL;
		if (D3DXDisasm)
		{
			D3DXDisasm->Release();
			D3DXDisasm = NULL;
		}
		shaderDisasmText.clear();
#endif
		fixedFunctionMacroDefines.clear();
		
		initialBytecodeToken = NULL;
		firstInstructionToken = NULL;
	}

	~ShaderInfo()
	{
#ifdef DISASM_SHADER
		shaderDisasmBuffer = NULL;
		D3DXDisasmString = NULL;
		if (D3DXDisasm)
		{
			D3DXDisasm->Release();
			D3DXDisasm = NULL;
		}
		shaderDisasmText.clear();
#endif
	}

	// Disallow copying of ShaderInfos!
	ShaderInfo(const ShaderInfo&) = delete;
	ShaderInfo(ShaderInfo&&) = delete;
	void operator=(const ShaderInfo&) = delete;

	bool parsingErrorDetected; // Could not parse the entire shader - ShaderInfo may be wrong!
	bool isPixelShader; // true = pixel shader, false = vertex shader
	unsigned short shaderMajorVersion;
	unsigned short shaderMinorVersion;

#ifdef DISASM_SHADER
	const char* shaderDisasmBuffer;
	LPD3DXBUFFER D3DXDisasm;
	const char* D3DXDisasmString;
#endif

	void PrintShaderStatsToString(char (&outBuffer)[1024]) const;

	unsigned shaderLengthDWORDs; // The number of DWORD tokens (including the first version token) in the bytecode
	unsigned numArithInstructions;
	unsigned numTexInstructions; // This field must be directly after numArithInstructions for reasons
	unsigned tempRegistersUsedBitmask; // A bitmask containing which of the (up to 32) temporary registers (r#) are used in this shader
	unsigned numUniqueTempRegistersUsed; // Count of how many 1 bits are in the tempRegistersUsedBitmask
	unsigned short inputRegistersUsedBitmask; // A bitmask containing which of the (up to 16) input registers (v#) are used in this shader
	unsigned short numUniqueInputRegistersUsed; // Count of how many 1 bits are in the inputRegistersUsedBitmask
	bool usesDynamicBranching; // Specifically this refers to dynamic branching that can cause warp divergence
	bool usesFunctionCalls; // Does this shader have any function calls?
	bool usesIntToFloatConversions; // Checks to see if you're reading from integer constants into floating-point registers (this is slow)
	bool usesTexkill; // Only for pixel shaders, noted for disabling fast-Z pass
	bool usesGradientInstructions; // Only for pixel shaders
	bool usesInstructionPredication; // Whether any instructions use Predication (ie., read from the Predication register)
	bool usesInstructionCoIssue; // Whether any instructions use Co-Issuing (executing scalar alpha-channel instructions simultaneously with vector RGB-channel instructions)
	bool psWritesDepth; // Only for pixel shaders, does this pixel shader write out depth (disables fast-Z pass)

	// Only relevant for VS_3_0 shaders:
	bool usesVertTextureFetch;

	// Pointer to the start of the shader bytecode (this is going to always point to the VERSION token)
	const DWORD* initialBytecodeToken;

	// Pointer to the first instruction (after the VERSION token, and also skipping any COMMENT blocks that are immediately adjacent to it)
	const DWORD* firstInstructionToken;

	// Initial constant register values (defines)
	std::vector<InitialConstantValue> initialConstantValues;
	std::vector<InitialConstantValueI> initialConstantValuesI;
	std::vector<InitialConstantValueB> initialConstantValuesB;

	// Which constants registers are accessed during this shader (overlaps with initial constant values):
	std::vector<unsigned> usedConstantsF;
	std::vector<unsigned> usedConstantsI;
	std::vector<unsigned> usedConstantsB;

	// declared inputs and samplers
	std::vector<DeclaredRegister> declaredRegisters;

	// Which output registers are actually written to
	std::vector<WrittenOutputRegister> writtenOutputRegisters;

	// Labels (used as targets for calls):
	std::vector<ShaderLabel> labels;

	// Comments
	std::vector<ShaderComment> comments;

#ifdef DISASM_SHADER
	std::vector<char> shaderDisasmText;
#endif

	// Used with fixed-function shaders only:
	std::vector<D3DXMACRO> fixedFunctionMacroDefines;

	unsigned shaderBytecodeHash;

	// Only relevant for pixel shaders:
	unsigned char usedMRTMask; // Which render targets does this shader output to (as a bit-mask)?
	bool usesMRT; // Does this pixel shader use MRT (multiple render targets) as output?
	bool hasDependentTextureFetches; // Not yet implemented (always false)
};

void DisasmAndAnalyzeShader(const DWORD* shaderMemory, ShaderInfo& shaderInfoOut
#ifdef _DEBUG
	, const char* const filename
#endif
	);

void AnalyzeShader(const DWORD* shaderMemory, ShaderInfo& shaderInfoOut
#ifdef _DEBUG
	, const char* const filename
#endif
	);

const opcodeDisplayType GetOpcodeDisplayType(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode);

// Returns the opcode as a string suitable for diassembly
const char* const GetOpcodeString(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode);

// Returns the name of the function that this opcode maps to
const char* const GetOpcodeFunctionString(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode);

// Returns true if this opcode is a TEX instruction, or false otherwise
const bool IsOpcodeTexInstruction(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode);

```

`Software_d3d9/ShaderBase.h`:

```h
#pragma once

#include "GlobalToggles.h"
#include "DebuggableEnums.h"
#include <intrin.h> // For intrinsics

#pragma pack(push)

// The maximum number of temp (GPR or "r") registers in any shader (vs, ps, 1, 2, and 3)
#define MAX_NUM_TEMP_REGISTERS 32

// The maximum number of constant integer ("i") registers
#define MAX_NUM_CONST_INT_REGISTERS 16

// The maximum number of constant bool ("b") registers
#define MAX_NUM_CONST_BOOL_REGISTERS 16

// These defines are used for gradient instructions (ddx/ddy or dsx/dsy)
#define GRADIENT_QUAD_TOPLEFT_INDEX 0
#define GRADIENT_QUAD_TOPRIGHT_INDEX 1
#define GRADIENT_QUAD_BOTLEFT_INDEX 2
#define GRADIENT_QUAD_BOTRIGHT_INDEX 3

#define MAX_USER_CLIP_PLANES_SUPPORTED 6

// All versions of vertex shaders can use up to 16 input registers
#define VS_MAX_INPUT_REGISTERS 16

// The intention of this class is to have a float4 class with no constructor overhead. Do not add a constructor to this struct that does anything!
struct float4
{
	float x, y, z, w;
};

// The intention of this class is to have an int4 class with no constructor overhead. Do not add a constructor to this struct that does anything!
struct int4
{
	int4()
	{
	}

	int4(const int _x, const int _y, const int _z, const int _w) : x(_x), y(_y), z(_z), w(_w)
	{
	}

	int x, y, z, w;
};

enum versionTokenShaderType : unsigned short
{
	verToken_vertexShader = (D3DVS_VERSION(0, 0) >> 16),
	verToken_PixelShader = (D3DPS_VERSION(0, 0) >> 16)
};

struct versionToken
{
	unsigned char minorVersion;
	unsigned char majorVersion;
	versionTokenShaderType pixelOrVertexShader;
};
static_assert(sizeof(versionToken) == sizeof(DWORD), "Error!");

enum eOpcodeControls : unsigned char
{
	OpCtrl_Reserved0 = D3DSPC_RESERVED0,

	// These comparison opcode controls are used in the "C" conditional variants to various instructions (break_comp with D3DSIO_BREAKC, if_comp with D3DSIO_IFC, and set_comp with D3DSIO_SETP)
	OpCtrl_Compare_Greater = D3DSPC_GT,
	OpCtrl_Compare_Equals = D3DSPC_EQ,
	OpCtrl_Compare_GreaterEquals = D3DSPC_GE,
	OpCtrl_Compare_Less = D3DSPC_LT,
	OpCtrl_Compare_NotEquals = D3DSPC_NE,
	OpCtrl_Compare_LessEquals = D3DSPC_LE,
	OpCtrl_Compare_Reserved = D3DSPC_RESERVED1,

	// One or zero of these texld opcode controls are used with the the D3DSIO_TEX opcode to make it either a texld, texldp, or texldb instruction
	// Note that the values of these enums overlap with those of the comparison opcode controls
	OpCtrl_TexLd_Project = (D3DSI_TEXLD_PROJECT >> D3DSP_OPCODESPECIFICCONTROL_SHIFT),
	OpCtrl_TexLd_Bias = (D3DSI_TEXLD_BIAS >> D3DSP_OPCODESPECIFICCONTROL_SHIFT)
};

// [31] Always 0x0 (false) for instruction tokens and always 0x1 (true) for parameter tokens
enum instructionParameterMarkerBit : unsigned char
{
	instructionTokenMarker = 0x0,
	parameterTokenMarker = 0x1
};

enum relativeAddressingEnableBit : unsigned short
{
	absoluteAddressing = (D3DSHADER_ADDRMODE_ABSOLUTE >> D3DSHADER_ADDRESSMODE_SHIFT),
	relativeAddressing = (D3DSHADER_ADDRMODE_RELATIVE >> D3DSHADER_ADDRESSMODE_SHIFT)
};

// Instruction Token: https://msdn.microsoft.com/en-us/library/windows/hardware/ff567721(v=vs.85).aspx
struct instructionToken
{
	DEBUGGABLE_D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode; // [15:00] Bits 0 through 15 indicate an operation code. D3DSIO_* is an example of an operation code, where * represents the instruction.
	eOpcodeControls opcodeControls; // [23:16] Bits 16 through 23 indicate specific controls related to the operation code.
	unsigned char instructionLengthDWORDs : 4; /* [27:24] For pixel and vertex shader versions earlier than 2_0, bits 24 through 27 are reserved and set to 0x0.
										 For pixel and vertex shader versions 2_0 and later, bits 24 through 27 specify the size in DWORDs of the 
										 instruction excluding the instruction token itself (that is, the number of tokens that comprise the 
										 instruction excluding the instruction token). */
	bool predicated : 1; /* [28] For pixel and vertex shader versions earlier than 2_0, bit 28 is reserved and set to 0x0.
								  For pixel and vertex shader versions 2_0 and later, bit 28 indicates whether the instruction is predicated (that is, 
								  contains an extra predicate source token at the end of the shader code. If this 
								  bit is set to 0x1, the instruction is predicated. */
	unsigned char reservedZero : 1; // [29] Reserved. This value is set to 0x0.
	bool coIssue : 1; /* [30] For pixel shader versions earlier than 2_0, bit 30 is the co-issue bit.
							   If set to 1, execute this instruction with previous instructions; otherwise, execute separately.
							   For pixel shader version 2_0 and later and all vertex shader versions, bit 30 is reserved and set to 0x0. */
	instructionParameterMarkerBit instructionOrParameterMarkerBit : 1; // [31] Always 0x0 (false) for instruction tokens and always 0x1 (true) for parameter tokens
};
static_assert(sizeof(instructionToken) == sizeof(DWORD), "Error!");

struct parameterToken
{
	inline const unsigned GetRegisterIndex(void) const
	{
		return internalRawToken & D3DSP_REGNUM_MASK;
	}

	inline const D3DSHADER_PARAM_REGISTER_TYPE GetRegisterType(void) const
	{
		const unsigned regType1 = (internalRawToken & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT;
		const unsigned regType2 = ( (internalRawToken & D3DSP_REGTYPE_MASK2) >> D3DSP_REGTYPE_SHIFT2) ;// >> 3;
		return (const D3DSHADER_PARAM_REGISTER_TYPE)(regType1 | regType2);
	}

	inline const D3DSHADER_ADDRESSMODE_TYPE GetRelativeAddressingType(void) const
	{
		return (const D3DSHADER_ADDRESSMODE_TYPE)( (internalRawToken & D3DSHADER_ADDRESSMODE_MASK) );
	}

	union
	{
		// This is the raw DWORD token
		DWORD internalRawToken;

		struct debuggableSrcParameter
		{
			unsigned short registerIndex : 11; // [10:00] Bits 0 through 10 indicate the register number (offset in register file).
			unsigned short registerType_highBits : 2; // [12:11] Bits 11 and 12 are the fourth and fifth bits [3,4] for indicating the register type.
			relativeAddressingEnableBit relativeAddressingEnable : 1; /* [13] For a pixel shader (PS) versions earlier than 3_0, bit 13 is reserved and set to 0x0.
														 For pixel shader (PS) version 3_0 and later and all versions of vertex shader (VS),
														 bit 13 indicates whether relative addressing mode is used.
														 If set to 1, relative addressing applies.*/
			unsigned short reserved_mustBeZero : 2; // [15:14] Reserved for all versions of PS and VS. This value is set to 0x0.
			struct
			{
				union
				{
					struct
					{
						debuggableSwizzleChannel xSwizzle : 2; // [17:16] Channel X swizzle
						debuggableSwizzleChannel ySwizzle : 2; // [19:18] Channel Y swizzle
						debuggableSwizzleChannel zSwizzle : 2; // [21:20] Channel Z swizzle
						debuggableSwizzleChannel wSwizzle : 2; // [23:22] Channel W swizzle
					} channelSwizzles;

					debuggableFullSwizzle fullSwizzle; // [23:16] XYZW swizzle
				};
			} sourceSwizzle; /* [23:16] Bits 16 through 23 indicate channel swizzle.
							 All arithmetic operations are performed in four (X,Y,Z,W) parallel channels.
							 Swizzle specifies which source component participates in a channel of operation.
							 For more information about swizzle, see the latest DirectX SDK documentation. */
			debuggableSourceModifierType sourceModifier : 4; /* [27:24] Bits 24 through 27 indicate the source modifier.
															 This 4-bit value indicates the source modifier types. */
			unsigned char registerType_lowBits : 3; // [30:28] Bits 28 through 30 are the first three bits [0,1,2] for indicating the register type
			instructionParameterMarkerBit instructionParameterBit : 1; // [31] Bit 31 is 0x1. This must always be 0x1 for parameter tokens
		} srcParameter;

		struct debuggableDstParameter
		{
			unsigned short registerIndex : 11; // [10:00] Bits 0 through 10 indicate the register number (offset in register file).
			unsigned short registerType_highBits : 2; // [12:11] Bits 11 and 12 are the fourth and fifth bits [3,4] for indicating the register type.
			relativeAddressingEnableBit relativeAddressingEnable : 1; /* [13] For vertex shader (VS) version 3_0 and later,
														 bit 13 indicates whether relative addressing mode is used.
														 If set to 1, relative addressing applies.
														 For all pixel shader (PS) versions (ps_*) and vertex shader versions earlier than 3_0, bit 13 is reserved and set to 0x0. */
			unsigned short reserved_mustBeZero : 2; // [15:14] Reserved. This value is set to 0x0.
			union
			{
				struct
				{
					writeMaskType writeMask : 4;
					writeMaskType /*resultModifier*/ : 4;
				} writeMaskStruct;

				struct
				{
					resultModifierType /*writeMask*/ : 4;
					resultModifierType resultModifier : 4;
				} resultModifierStruct;

				struct
				{
					unsigned char writeMask : 4; // [19:16] Write mask.
					unsigned char resultModifier : 4; // [23:20] Bits 20 through 23 indicate the result modifier. Multiple result modifiers can be used (result modifier types can be ORed together).
				} writeMaskAndResultModiferRawStruct;
			};
			signed char resultShiftScale : 4; /* [27:24] For PS versions earlier than 2_0, bits 24 through 27 specify the result shift scale (signed shift).
												For PS version 2_0 and later and VS, these bits are reserved and set to 0x0. */
			unsigned char registerType_lowBits : 3; // [30:28] Bits 28 through 30 are the first three bits [0,1,2] for indicating the register type.
			instructionParameterMarkerBit instructionParameterBit : 1; // [31] Bit 31 is 0x1. This must always be 0x1 for parameter tokens
		} dstParameter;
	};
};
static_assert(sizeof(parameterToken) == sizeof(DWORD), "Error!");

// Source: https://msdn.microsoft.com/en-us/library/windows/hardware/ff569716(v=vs.85).aspx
struct srcParameterToken : public parameterToken
{
	inline const unsigned GetSourceModifiers(void) const
	{
		return ( (internalRawToken & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);
	}

	inline const D3DSHADER_PARAM_SRCMOD_TYPE GetSourceModifiersUnshifted(void) const
	{
		return (const D3DSHADER_PARAM_SRCMOD_TYPE)(internalRawToken & D3DSP_SRCMOD_MASK);
	}

	// Returns 0, 1, 2, or 3 to indicate an X, Y, Z, or W swizzle respectively
	inline const unsigned char GetChannelSwizzle(void) const
	{
		return (const unsigned char)( ( (internalRawToken & D3DSP_SWIZZLE_MASK) >> D3DSP_SWIZZLE_SHIFT) & 0x3);
	}

	inline const unsigned GetChannelSwizzleXYZW(void) const
	{
		return ( (internalRawToken & D3DSP_SWIZZLE_MASK) >> D3DSP_SWIZZLE_SHIFT);
	}

	inline const unsigned char GetSwizzle(void) const
	{
		return (const unsigned char)( (internalRawToken & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT);
	}
};
static_assert(sizeof(srcParameterToken) == sizeof(DWORD), "Error!");

// Source: https://msdn.microsoft.com/en-us/library/windows/hardware/ff552738(v=vs.85).aspx
struct dstParameterToken : public parameterToken
{
	inline const unsigned GetWriteMask(void) const
	{
		return (internalRawToken & D3DSP_WRITEMASK_ALL) >> 16;
	}

	inline const unsigned GetResultShiftScale(void) const
	{
		return (internalRawToken & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT;
	}

	inline const unsigned GetResultModifier(void) const
	{
		return (internalRawToken & D3DSP_DSTMOD_MASK) >> D3DSP_DSTMOD_SHIFT;
	}

	inline const unsigned GetResultModifierUnshifted(void) const
	{
		return (internalRawToken & D3DSP_DSTMOD_MASK);
	}
};
static_assert(sizeof(dstParameterToken) == sizeof(DWORD), "Error!");

#pragma pack(pop)

struct SamplerState
{
	SamplerState()
	{
		ClearSamplerStateToDefaults();
	}

	~SamplerState()
	{
		ClearSamplerStateToDefaults();
	}

	inline void ClearSamplerStateToDefaults()
	{
		static const DWORD badSamplerStateValue = 0xBAADCAFE;
		for (unsigned x = 0; x <= D3DSAMP_DMAPOFFSET; ++x)
			stateUnion.state[x] = badSamplerStateValue;

		stateUnion.namedStates.addressU = D3DTADDRESS_WRAP;
		stateUnion.namedStates.addressV = D3DTADDRESS_WRAP;
		stateUnion.namedStates.addressW = D3DTADDRESS_WRAP;
		stateUnion.namedStates.borderColor = D3DCOLOR_ARGB(0, 0, 0, 0);
		stateUnion.namedStates.magFilter = D3DTEXF_POINT;
		stateUnion.namedStates.minFilter = D3DTEXF_POINT;
		stateUnion.namedStates.mipFilter = D3DTEXF_NONE;
		stateUnion.namedStates.mipMapLoDBias = 0.0f;
		stateUnion.namedStates.maxMipLevel = 0;
		stateUnion.namedStates.maxAnisotropy = 1;
		stateUnion.namedStates.sRGBTexture = FALSE; // Not sure if this is a BOOL or a float (see variable definition for more info)
		stateUnion.namedStates.elementIndex = 0;
		stateUnion.namedStates.dMapOffset = 0;

		cachedFloatMaxMipLevel = 0.0f;
	}

	union _stateUnion
	{
		struct _namedStates
		{
			DWORD zeroState; // This is an invalid sampler state
			D3DTEXTUREADDRESS addressU;
			D3DTEXTUREADDRESS addressV;
			D3DTEXTUREADDRESS addressW;
			D3DCOLOR borderColor;
			D3DTEXTUREFILTERTYPE magFilter;
			D3DTEXTUREFILTERTYPE minFilter;
			D3DTEXTUREFILTERTYPE mipFilter;
			float mipMapLoDBias;
			DWORD maxMipLevel;
			DWORD maxAnisotropy;
			BOOL sRGBTexture; // NVidia cg docs (http://http.developer.nvidia.com/Cg/SRGBTexture.html) make this sound like a float, but D3D9 docs (https://msdn.microsoft.com/en-us/library/windows/desktop/bb172602(v=vs.85).aspx) make it sound like a BOOL. Since we're trying to emulate D3D9 here, we'll use the BOOL definition.
			DWORD elementIndex;
			DWORD dMapOffset; // "(DWORD) - Offset (in vertices) in a pre-sampled displacement map". Source: https://msdn.microsoft.com/en-us/library/windows/desktop/bb219748(v=vs.85).aspx
		} namedStates;
		DWORD state[D3DSAMP_DMAPOFFSET + 1];
	} stateUnion;
	static_assert(sizeof(_stateUnion) == sizeof(DWORD) * (D3DSAMP_DMAPOFFSET + 1), "Error: Unexpected union size!");

	float cachedFloatMaxMipLevel;
};

struct sampler
{
	SamplerState samplerState;
	class IDirect3DTexture9Hook* texture;
};

```

`Software_d3d9/ShaderEngineBase.h`:

```h
#pragma once

#include "ShaderBase.h"
#include "ShaderIntrinsicFunctions.h"

struct ShaderInfo;

static const D3DXVECTOR4 ZEROVEC(0.0f, 0.0f, 0.0f, 0.0f);

__declspec(align(16) ) class ShaderEngineBase
{
public:
	ShaderEngineBase() : instructionPtr(NULL), shaderInfo(NULL)
	{
	}

	~ShaderEngineBase()
	{
		instructionPtr = NULL;
		shaderInfo = NULL;
	}

	typedef void (__fastcall * tex2DMip0Sig)(float4& outVal, const float4& texCoord, const sampler* const samplerPtr);
	tex2DMip0Sig tex2DMip0ptrs[15];

	typedef void (__fastcall * tex2DLoDSig)(float4& outVal, const float4& texCoordAndLoD, const sampler* const samplerPtr);
	tex2DLoDSig tex2DLoDptrs[15];

	typedef void (__fastcall * tex2DGradSig)(float4& outVal, const float4& texCoord, const float4& texDdx, const float4& texDdy, const sampler* const samplerPtr);
	tex2DGradSig tex2DGradPtrs[15];

	typedef void (__fastcall * tex2DGradBiasSig)(float4& outVal, const float4& texCoord, const float4& texDdx, const float4& texDdy, const sampler* const samplerPtr);
	tex2DGradBiasSig tex2DGradBiasPtrs[15];

	void GlobalInitTex2DFunctionTable()
	{
		tex2DMip0ptrs[0] = (const tex2DMip0Sig)&tex2Dmip0<1>;
		tex2DMip0ptrs[1] = (const tex2DMip0Sig)&tex2Dmip0<2>;
		tex2DMip0ptrs[2] = (const tex2DMip0Sig)&tex2Dmip0<3>;
		tex2DMip0ptrs[3] = (const tex2DMip0Sig)&tex2Dmip0<4>;
		tex2DMip0ptrs[4] = (const tex2DMip0Sig)&tex2Dmip0<5>;
		tex2DMip0ptrs[5] = (const tex2DMip0Sig)&tex2Dmip0<6>;
		tex2DMip0ptrs[6] = (const tex2DMip0Sig)&tex2Dmip0<7>;
		tex2DMip0ptrs[7] = (const tex2DMip0Sig)&tex2Dmip0<8>;
		tex2DMip0ptrs[8] = (const tex2DMip0Sig)&tex2Dmip0<9>;
		tex2DMip0ptrs[9] = (const tex2DMip0Sig)&tex2Dmip0<10>;
		tex2DMip0ptrs[10] = (const tex2DMip0Sig)&tex2Dmip0<11>;
		tex2DMip0ptrs[11] = (const tex2DMip0Sig)&tex2Dmip0<12>;
		tex2DMip0ptrs[12] = (const tex2DMip0Sig)&tex2Dmip0<13>;
		tex2DMip0ptrs[13] = (const tex2DMip0Sig)&tex2Dmip0<14>;
		tex2DMip0ptrs[14] = (const tex2DMip0Sig)&tex2Dmip0<15>;

		tex2DLoDptrs[0] = (const tex2DLoDSig)&tex2Dlod<1>;
		tex2DLoDptrs[1] = (const tex2DLoDSig)&tex2Dlod<2>;
		tex2DLoDptrs[2] = (const tex2DLoDSig)&tex2Dlod<3>;
		tex2DLoDptrs[3] = (const tex2DLoDSig)&tex2Dlod<4>;
		tex2DLoDptrs[4] = (const tex2DLoDSig)&tex2Dlod<5>;
		tex2DLoDptrs[5] = (const tex2DLoDSig)&tex2Dlod<6>;
		tex2DLoDptrs[6] = (const tex2DLoDSig)&tex2Dlod<7>;
		tex2DLoDptrs[7] = (const tex2DLoDSig)&tex2Dlod<8>;
		tex2DLoDptrs[8] = (const tex2DLoDSig)&tex2Dlod<9>;
		tex2DLoDptrs[9] = (const tex2DLoDSig)&tex2Dlod<10>;
		tex2DLoDptrs[10] = (const tex2DLoDSig)&tex2Dlod<11>;
		tex2DLoDptrs[11] = (const tex2DLoDSig)&tex2Dlod<12>;
		tex2DLoDptrs[12] = (const tex2DLoDSig)&tex2Dlod<13>;
		tex2DLoDptrs[13] = (const tex2DLoDSig)&tex2Dlod<14>;
		tex2DLoDptrs[14] = (const tex2DLoDSig)&tex2Dlod<15>;

		tex2DGradPtrs[0] = (const tex2DGradSig)&tex2Dgrad<1, false>;
		tex2DGradPtrs[1] = (const tex2DGradSig)&tex2Dgrad<2, false>;
		tex2DGradPtrs[2] = (const tex2DGradSig)&tex2Dgrad<3, false>;
		tex2DGradPtrs[3] = (const tex2DGradSig)&tex2Dgrad<4, false>;
		tex2DGradPtrs[4] = (const tex2DGradSig)&tex2Dgrad<5, false>;
		tex2DGradPtrs[5] = (const tex2DGradSig)&tex2Dgrad<6, false>;
		tex2DGradPtrs[6] = (const tex2DGradSig)&tex2Dgrad<7, false>;
		tex2DGradPtrs[7] = (const tex2DGradSig)&tex2Dgrad<8, false>;
		tex2DGradPtrs[8] = (const tex2DGradSig)&tex2Dgrad<9, false>;
		tex2DGradPtrs[9] = (const tex2DGradSig)&tex2Dgrad<10, false>;
		tex2DGradPtrs[10] = (const tex2DGradSig)&tex2Dgrad<11, false>;
		tex2DGradPtrs[11] = (const tex2DGradSig)&tex2Dgrad<12, false>;
		tex2DGradPtrs[12] = (const tex2DGradSig)&tex2Dgrad<13, false>;
		tex2DGradPtrs[13] = (const tex2DGradSig)&tex2Dgrad<14, false>;
		tex2DGradPtrs[14] = (const tex2DGradSig)&tex2Dgrad<15, false>;

		tex2DGradBiasPtrs[0] = (const tex2DGradBiasSig)&tex2Dgrad<1, true>;
		tex2DGradBiasPtrs[1] = (const tex2DGradBiasSig)&tex2Dgrad<2, true>;
		tex2DGradBiasPtrs[2] = (const tex2DGradBiasSig)&tex2Dgrad<3, true>;
		tex2DGradBiasPtrs[3] = (const tex2DGradBiasSig)&tex2Dgrad<4, true>;
		tex2DGradBiasPtrs[4] = (const tex2DGradBiasSig)&tex2Dgrad<5, true>;
		tex2DGradBiasPtrs[5] = (const tex2DGradBiasSig)&tex2Dgrad<6, true>;
		tex2DGradBiasPtrs[6] = (const tex2DGradBiasSig)&tex2Dgrad<7, true>;
		tex2DGradBiasPtrs[7] = (const tex2DGradBiasSig)&tex2Dgrad<8, true>;
		tex2DGradBiasPtrs[8] = (const tex2DGradBiasSig)&tex2Dgrad<9, true>;
		tex2DGradBiasPtrs[9] = (const tex2DGradBiasSig)&tex2Dgrad<10, true>;
		tex2DGradBiasPtrs[10] = (const tex2DGradBiasSig)&tex2Dgrad<11, true>;
		tex2DGradBiasPtrs[11] = (const tex2DGradBiasSig)&tex2Dgrad<12, true>;
		tex2DGradBiasPtrs[12] = (const tex2DGradBiasSig)&tex2Dgrad<13, true>;
		tex2DGradBiasPtrs[13] = (const tex2DGradBiasSig)&tex2Dgrad<14, true>;
		tex2DGradBiasPtrs[14] = (const tex2DGradBiasSig)&tex2Dgrad<15, true>;
	}

	// Public accessor for ShaderInfo
	inline const ShaderInfo* const GetShaderInfo() const
	{
		return shaderInfo;
	}	

protected:
	const DWORD* instructionPtr;

	const ShaderInfo* shaderInfo;
};

```

`Software_d3d9/ShaderIntrinsicFunctions.h`:

```h
#pragma once

#ifdef _DEBUG
	#define INTRINSIC_INLINE inline
#else
	#define INTRINSIC_INLINE __forceinline
#endif

// Round-to-nearest is used when converting from floats to ints instead of C/C++'s default "round towards zero": https://msdn.microsoft.com/en-us/library/windows/desktop/bb147214(v=vs.85).aspx
static INTRINSIC_INLINE const int RoundToNearest(const float f)
{
	if (f >= 0.0f)
		return (const int)(f + 0.5f);
	else
		return (const int)(f - 0.5f);
}

#include "ShaderIntrinsicFunctions4.h"

// Absolute-value: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/abs---vs
static INTRINSIC_INLINE void abs(D3DXVECTOR4& dst, const D3DXVECTOR4& src)
{
	dst.x = fabsf(src.x);
	dst.y = fabsf(src.y);
	dst.z = fabsf(src.z);
	dst.w = fabsf(src.w);
}

// Absolute-value: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/abs---vs
static INTRINSIC_INLINE void abs(float& dst, const float src)
{
	dst = fabsf(src);
}

// Addition: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/add---vs
static INTRINSIC_INLINE void add(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.x = src0.x + src1.x;
	dst.y = src0.y + src1.y;
	dst.z = src0.z + src1.z;
	dst.w = src0.w + src1.w;
}

// Addition: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/add---vs
static INTRINSIC_INLINE void add(float& dst, const float src0, const float src1)
{
	dst = src0 + src1;
}

// Compare: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/cmp---ps
static INTRINSIC_INLINE void cmp(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const D3DXVECTOR4& src2)
{
	dst.x = src0.x >= 0.0f ? src1.x : src2.x;
	dst.y = src0.y >= 0.0f ? src1.y : src2.y;
	dst.z = src0.z >= 0.0f ? src1.z : src2.z;
	dst.w = src0.w >= 0.0f ? src1.w : src2.w;
}

// Compare: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/cmp---ps
static INTRINSIC_INLINE void cmp(float& dst, const float src0, const float src1, const float src2)
{
	dst = src0 >= 0.0f ? src1 : src2;
}

// Conditional select: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/cnd---ps
static INTRINSIC_INLINE void cnd(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const D3DXVECTOR4& src2)
{
	dst.x = src0.x > 0.5f ? src1.x : src2.x;
	dst.y = src0.y > 0.5f ? src1.y : src2.y;
	dst.z = src0.z > 0.5f ? src1.z : src2.z;
	dst.w = src0.w > 0.5f ? src1.w : src2.w;
}

// Cross-product: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/crs---vs
static INTRINSIC_INLINE void crs(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.x = src0.y * src1.z - src0.z * src1.y;
	dst.y = src0.z * src1.x - src0.x * src1.z;
	dst.z = src0.x * src1.y - src0.y * src1.x;
}

// 2-D dot product and add scalar: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp2add---ps
static INTRINSIC_INLINE void dp2add(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const D3DXVECTOR4& src2)
{
	dst.w = (src0.x * src1.x) + (src0.y * src1.y);
	dst.x = dst.y = dst.z = dst.w;
	dst.x += src2.x;
	dst.y += src2.y;
	dst.z += src2.z;
	dst.w += src2.w;
}

// 2-D dot product and add scalar: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp2add---ps
static INTRINSIC_INLINE void dp2add(float4& dst, const float4& src0, const float4& src1, const float4& src2)
{
	dst.w = (src0.x * src1.x) + (src0.y * src1.y);
	dst.x = dst.y = dst.z = dst.w;
	dst.x += src2.x;
	dst.y += src2.y;
	dst.z += src2.z;
	dst.w += src2.w;
}

// 2-D dot product and add scalar: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp2add---ps
static INTRINSIC_INLINE void dp2add1(float& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const float src2)
{
	dst = (src0.x * src1.x) + (src0.y * src1.y);
	dst += src2;
}

// dot3: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp3---vs
static INTRINSIC_INLINE void dp3(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.w = (src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z);
	dst.x = dst.y = dst.z = dst.w;
}

// dot3: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp3---vs
static INTRINSIC_INLINE void dp3(float4& dst, const float4& src0, const float4& src1)
{
	dst.w = (src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z);
	dst.x = dst.y = dst.z = dst.w;
}

// dot3: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp3---vs
static INTRINSIC_INLINE void dp3(float4& dst, const D3DXVECTOR4& src0, const float4& src1)
{
	dst.w = (src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z);
	dst.x = dst.y = dst.z = dst.w;
}

// dot3: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp3---vs
static INTRINSIC_INLINE void dp3(float4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.w = (src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z);
	dst.x = dst.y = dst.z = dst.w;
}

// dot3: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp3---vs
static INTRINSIC_INLINE void dp3(float& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst = (src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z);
}

// dot3: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp3---vs
static INTRINSIC_INLINE void dp3(float& dst, const float x0, const float y0, const float z0, const float x1, const float y1, const float z1)
{
	dst = (x0 * x1) + (y0 * y1) + (z0 * z1);
}

// dot4: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp4---ps
static INTRINSIC_INLINE void dp4(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.w = (src0.x * src1.x) + (src0.y * src1.y) + 
         (src0.z * src1.z) + (src0.w * src1.w);
	dst.x = dst.y = dst.z = dst.w;
}

// dot4: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp4---ps
static INTRINSIC_INLINE void dp4(float4& dst, const float4& src0, const float4& src1)
{
	dst.w = (src0.x * src1.x) + (src0.y * src1.y) + 
         (src0.z * src1.z) + (src0.w * src1.w);
	dst.x = dst.y = dst.z = dst.w;
}

// dot4: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp4---ps
static INTRINSIC_INLINE void dp4(float& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst = (src0.x * src1.x) + (src0.y * src1.y) + 
         (src0.z * src1.z) + (src0.w * src1.w);
}

// dot4: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp4---ps
static INTRINSIC_INLINE void dp4(float4& dst, const D3DXVECTOR4& src0, const float4& src1)
{
	dst.w = (src0.x * src1.x) + (src0.y * src1.y) + 
         (src0.z * src1.z) + (src0.w * src1.w);
	dst.x = dst.y = dst.z = dst.w;
}

// distance: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dst---vs
/*
// The source vectors are assumed to contain the values shown in the following pseudocode:
src0.x = undefined
src0.y = d * d
src0.z = d * d
src0.w = undefined
src1.x = undefined
src1.y = 1 / d
src1.z = undefined
src1.w = 1 / d

// The destination vector is assumed to look like this after the dst() function is executed:
dest.x = 1
dest.y = d
dest.z = d * d
dest.w = 1 / d
*/
static INTRINSIC_INLINE void dst(D3DXVECTOR4& dest, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dest.x = 1.0f;
	dest.y = sqrtf(src0.y);
	dest.z = src0.z;
	dest.w = src1.w;
}

// ddx/dsx: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dsx---ps
static INTRINSIC_INLINE void dsx(D3DXVECTOR4& dst, const D3DXVECTOR4& src0)
{
	UNREFERENCED_PARAMETER(src0);

	// We can't compute derivatives for just 1-pixel warps, so return zero for everything (need at least a 2x2 quad warp to compute this)
	dst.x = dst.y = dst.z = dst.w = 0.0f;
}

// ddy/dsy: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dsy---ps
static INTRINSIC_INLINE void dsy(D3DXVECTOR4& dst, const D3DXVECTOR4& src0)
{
	UNREFERENCED_PARAMETER(src0);

	// We can't compute derivatives for just 1-pixel warps, so return zero for everything (need at least a 2x2 quad warp to compute this)
	dst.x = dst.y = dst.z = dst.w = 0.0f;
}

// exp (minimum 21 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/exp---vs
// expp (minimum 10 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/expp---vs
static INTRINSIC_INLINE void exp(D3DXVECTOR4& dst, const float src_replicateSwizzleComponent)
{
	dst.x = dst.y = dst.z = dst.w = (const float)powf(2.0f, src_replicateSwizzleComponent);
}

// exp (minimum 21 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/exp---vs
// expp (minimum 10 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/expp---vs
static INTRINSIC_INLINE void exp(float& dst, const float src_replicateSwizzleComponent)
{
	dst = (const float)powf(2.0f, src_replicateSwizzleComponent);
}

// Frac: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/frc---vs
static INTRINSIC_INLINE void frc(D3DXVECTOR4& dst, const D3DXVECTOR4& src)
{
	dst.x = src.x - floorf(src.x);
	dst.y = src.y - floorf(src.y);
	dst.z = src.z - floorf(src.z);
	dst.w = src.w - floorf(src.w);
}

// Frac: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/frc---vs
static INTRINSIC_INLINE void frc(float& dst, const float src)
{
	dst = src - (const float)floor(src);
}

// lighting: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/lit---vs
/*
// The source vector is assumed to contain the values shown in the following pseudocode.
src.x = N dot L    ; The dot product between normal and direction to light (for diffuse lighting)
src.y = N dot H    ; The dot product between normal and half vector (for specular lighting)
src.z = ignored    ; This value is ignored
src.w = exponent   ; The value must be between -128.0 and 128.0 (for specular lighting)
*/
static INTRINSIC_INLINE void lit(D3DXVECTOR4& dst, const D3DXVECTOR4& src0)
{
	dst.x = 1.0f;
	dst.y = 0.0f;
	dst.z = 0.0f;
	dst.w = 1.0f;

	if (src0.x > 0.0f)
	{
		dst.y = src0.x; // This is N dot L (for diffuse lighting)

		// Do specular lighting:
		if (src0.y > 0.0f)
		{
			const float MAXPOWER = 127.9961f; // An implementation must support at least eight fraction bits in the power argument (8.8 fixed point)
			float power = src0.w;
			if (power < -MAXPOWER)
				power = -MAXPOWER;
			else if (power > MAXPOWER)
				power = MAXPOWER;
			dst.z = powf(src0.y, power);
		}
	}
}

// Log (minimum 21 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/log---vs
// Logp (minimum 10 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/logp---vs
static INTRINSIC_INLINE void log(D3DXVECTOR4& dst, const float src_replicateSwizzleComponent)
{
	const float v = fabsf(src_replicateSwizzleComponent);
	if (v != 0.0f)
	{
		dst.x = dst.y = dst.z = dst.w = log2_lowp(v);
	}
	else
	{
		dst.x = dst.y = dst.z = dst.w = -FLT_MAX;
	}
}

// Log (minimum 21 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/log---vs
// Logp (minimum 10 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/logp---vs
static INTRINSIC_INLINE void log(float& dst, const float src_replicateSwizzleComponent)
{
	const float v = fabsf(src_replicateSwizzleComponent);
	if (v != 0.0f)
	{
		dst = log2_lowp(v);
	}
	else
	{
		dst = -FLT_MAX;
	}
}

// lerp: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/lrp---vs
template <const unsigned char writeMask = 0xF>
static INTRINSIC_INLINE void lrp(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const D3DXVECTOR4& src2)
{
	const __m128 amount4 = *(const __m128* const)&src0;
	const __m128 src1vec = *(const __m128* const)&src1;
	const __m128 src2vec = *(const __m128* const)&src2;
	__m128& outVec = *(__m128* const)&dst;

	if ( (writeMask & 0x7) == 0x7)
		outVec = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec, src1vec), amount4), src1vec);
	else
	{
		const __m128 result = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec, src1vec), amount4), src1vec);
		if (writeMask & 0x1)
			dst.x = result.m128_f32[0];
		if (writeMask & 0x2)
			dst.y = result.m128_f32[1];
		if (writeMask & 0x4)
			dst.z = result.m128_f32[2];
		if (writeMask & 0x8)
			dst.w = result.m128_f32[3];
	}
}

// lerp: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/lrp---vs
template <const unsigned char writeMask = 0xF>
static INTRINSIC_INLINE void lrp(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const float amount)
{
	const __m128 amount4 = _mm_set1_ps(amount);
	const __m128 src0vec = *(const __m128* const)&src0;
	const __m128 src1vec = *(const __m128* const)&src1;
	__m128& outVec = *(__m128* const)&dst;

	if (writeMask == 0xF)
		outVec = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src1vec, src0vec), amount4), src0vec);
	else
	{
		const __m128 result = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src1vec, src0vec), amount4), src0vec);
		if (writeMask & 0x1)
			dst.x = result.m128_f32[0];
		if (writeMask & 0x2)
			dst.y = result.m128_f32[1];
		if (writeMask & 0x4)
			dst.z = result.m128_f32[2];
		if (writeMask & 0x8)
			dst.w = result.m128_f32[3];
	}
}

// lerp: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/lrp---vs
static INTRINSIC_INLINE void lrp(float& dst, const float src0, const float src1, const float src2)
{	
	dst = src0 * (src1 - src2) + src2;
}

// 3x2 matrix mult: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/m3x2---vs
static INTRINSIC_INLINE void m3x2(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const D3DXVECTOR4& src2)
{
	dst.x = (src0.x * src1.x) + (src0.x * src1.y) + (src0.x * src1.z);
	dst.y = (src0.x * src2.x) + (src0.y * src2.y) + (src0.z * src2.z);
}

// 3x3 matrix mult: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/m3x3---vs
static INTRINSIC_INLINE void m3x3(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const D3DXVECTOR4& src2, const D3DXVECTOR4& src3)
{
	dst.x = (src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z);
	dst.y = (src0.x * src2.x) + (src0.y * src2.y) + (src0.z * src2.z);
	dst.z = (src0.x * src3.x) + (src0.y * src3.y) + (src0.z * src3.z);
}

// 3x4 matrix mult: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/m3x4---vs
static INTRINSIC_INLINE void m3x4(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const D3DXVECTOR4& src2, const D3DXVECTOR4& src3, const D3DXVECTOR4& src4)
{
	dst.x = (src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z);
	dst.y = (src0.x * src2.x) + (src0.y * src2.y) + (src0.z * src2.z);
	dst.z = (src0.x * src3.x) + (src0.y * src3.y) + (src0.z * src3.z);
	dst.w = (src0.x * src4.x) + (src0.y * src4.y) + (src0.z * src4.z);
}

// 4x3 matrix mult: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/m4x3---vs
static INTRINSIC_INLINE void m4x3(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const D3DXVECTOR4& src2, const D3DXVECTOR4& src3)
{
	dst.x = (src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w);
	dst.y = (src0.x * src2.x) + (src0.y * src2.y) + (src0.z * src2.z) + (src0.w * src2.w);
	dst.z = (src0.x * src3.x) + (src0.y * src3.y) + (src0.z * src3.z) + (src0.w * src3.w);
}

// 4x4 matrix mult: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/m4x4---vs
static INTRINSIC_INLINE void m4x4(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const D3DXVECTOR4& src2, const D3DXVECTOR4& src3, const D3DXVECTOR4& src4)
{
	dst.x = (src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w);
	dst.y = (src0.x * src2.x) + (src0.y * src2.y) + (src0.z * src2.z) + (src0.w * src2.w);
	dst.z = (src0.x * src3.x) + (src0.y * src3.y) + (src0.z * src3.z) + (src0.w * src3.w);
	dst.w = (src0.x * src4.x) + (src0.y * src4.y) + (src0.z * src4.z) + (src0.w * src4.w);
}

// Multiply-add: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mad---ps
static INTRINSIC_INLINE void mad(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const D3DXVECTOR4& src2)
{
	dst.x = src0.x * src1.x + src2.x;
	dst.y = src0.y * src1.y + src2.y;
	dst.z = src0.z * src1.z + src2.z;
	dst.w = src0.w * src1.w + src2.w;
}

// Multiply-add: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mad---ps
static INTRINSIC_INLINE void mad(float& dst, const float src0, const float src1, const float src2)
{
	dst = src0 * src1 + src2;
}

// Maximum: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/max---vs
#undef max
static INTRINSIC_INLINE void max(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.x = (src0.x >= src1.x) ? src0.x : src1.x;
	dst.y = (src0.y >= src1.y) ? src0.y : src1.y;
	dst.z = (src0.z >= src1.z) ? src0.z : src1.z;
	dst.w = (src0.w >= src1.w) ? src0.w : src1.w;
}

// Maximum: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/max---vs
static INTRINSIC_INLINE void max(float& dst, const float src0, const float src1)
{
	dst = (src0 >= src1) ? src0 : src1;
}

// Minimum: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/min---vs
#undef min
static INTRINSIC_INLINE void min(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.x = (src0.x < src1.x) ? src0.x : src1.x;
	dst.y = (src0.y < src1.y) ? src0.y : src1.y;
	dst.z = (src0.z < src1.z) ? src0.z : src1.z;
	dst.w = (src0.w < src1.w) ? src0.w : src1.w;
}

// Minimum: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/min---vs
static INTRINSIC_INLINE void min(float& dst, const float src0, const float src1)
{
	dst = (src0 < src1) ? src0 : src1;
}

// Move (float to float): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mov(D3DXVECTOR4& dst, const D3DXVECTOR4& src)
{
	dst = src;
}

// Move (float to float): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mov(float& dst, const float src)
{
	dst = src;
}

// Move (float to int): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mov(int& dst, const float src)
{
	dst = RoundToNearest(src);
}

// Move (float to int): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mova(int& dst, const float src)
{
	dst = RoundToNearest(src);
}

// Move (int to float): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mov(float& dst, const int src)
{
	dst = (const float)src;
}

// Move (float to int): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mov(int4& dst, const D3DXVECTOR4& src)
{
	dst.x = RoundToNearest(src.x);
	dst.y = RoundToNearest(src.y);
	dst.z = RoundToNearest(src.z);
	dst.w = RoundToNearest(src.w);
}

// Move (float to int): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mova(int4& dst, const D3DXVECTOR4& src)
{
	dst.x = RoundToNearest(src.x);
	dst.y = RoundToNearest(src.y);
	dst.z = RoundToNearest(src.z);
	dst.w = RoundToNearest(src.w);
}

// Move (int to float): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mov(D3DXVECTOR4& dst, const int4& src)
{
	dst.x = (const float)src.x;
	dst.y = (const float)src.y;
	dst.z = (const float)src.z;
	dst.w = (const float)src.w;
}

// Multiply: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mul---vs
static INTRINSIC_INLINE void mul(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.x = src0.x * src1.x;
	dst.y = src0.y * src1.y;
	dst.z = src0.z * src1.z;
	dst.w = src0.w * src1.w;
}

// Multiply: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mul---vs
static INTRINSIC_INLINE void mul(float& dst, const float src0, const float src1)
{
	dst = src0 * src1;
}

// No-op: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/nop---vs
static INTRINSIC_INLINE void nop()
{
	;
}

// No-op: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/nop---vs
static INTRINSIC_INLINE void nop(class ShaderEngineBase&)
{
	;
}

// Normalize: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/nrm---vs
static INTRINSIC_INLINE void nrm(D3DXVECTOR4& dst, const D3DXVECTOR4& src0)
{
	float f = src0.x * src0.x + src0.y * src0.y + src0.z * src0.z;
	if (f != 0.0f)
		f = (1.0f / sqrtf(f) );
	else
		f = FLT_MAX;

	dst.x = src0.x * f;
	dst.y = src0.y * f;
	dst.z = src0.z * f;
	dst.w = src0.w * f;
}

// Normalize: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/nrm---vs
static INTRINSIC_INLINE void nrm(float4& dst, const float4& src0)
{
	float f = src0.x * src0.x + src0.y * src0.y + src0.z * src0.z;
	if (f != 0.0f)
		f = (const float)(1.0f / sqrtf(f) );
	else
		f = FLT_MAX;

	dst.x = src0.x * f;
	dst.y = src0.y * f;
	dst.z = src0.z * f;
	dst.w = src0.w * f;
}

// Normalize (xyz only): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/nrm---vs
static INTRINSIC_INLINE void nrm_xyz(D3DXVECTOR4& dst, const D3DXVECTOR4& src0)
{
	float f = src0.x * src0.x + src0.y * src0.y + src0.z * src0.z;
	if (f != 0.0f)
		f = (const float)(1.0f / sqrtf(f) );
	else
		f = FLT_MAX;

	dst.x = src0.x * f;
	dst.y = src0.y * f;
	dst.z = src0.z * f;
}

// Power (15 minimum bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/pow---vs
static INTRINSIC_INLINE void pow(D3DXVECTOR4& dst, const float src0, const float src1)
{
	dst.x = dst.y = dst.z = dst.w = powf(fabsf(src0), src1);
}

// Power (15 minimum bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/pow---vs
static INTRINSIC_INLINE void pow(float& dst, const float src0, const float src1)
{
	dst = powf(fabsf(src0), src1);
}

// Return from function or return from shader program: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/ret---ps
static INTRINSIC_INLINE void ret(void)
{
	return;
}

// Reciprocal: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/rcp---vs
static INTRINSIC_INLINE void rcp(D3DXVECTOR4& dst, const float src)
{
	float f = src;
	if(f == 0.0f)
	{
		f = FLT_MAX;
	}
	else 
	{
		f = 1.0f / f;
	}

	dst.x = dst.y = dst.z = dst.w = f;
}

// Reciprocal: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/rcp---vs
static INTRINSIC_INLINE void rcp(float& dst, const float src)
{
	float f = src;
	if(f == 0.0f)
	{
		f = FLT_MAX;
	}
	else 
	{
		f = 1.0f / f;
	}

	dst = f;
}

// Reciprocal square-root: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/rsq---vs
static INTRINSIC_INLINE void rsq(D3DXVECTOR4& dst, const float src)
{
	float f = src;
	if (f == 0.0f)
		f = FLT_MAX;
	else
	{
		f = fabsf(f);
		if (f != 1.0f)
			f = 1.0f / (float)sqrtf(f);
	}

	dst.x = dst.y = dst.z = dst.w = f;
}

// Reciprocal square-root: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/rsq---vs
static INTRINSIC_INLINE void rsq(float& dst, const float src)
{
	float f = src;
	if (f == 0.0f)
		f = FLT_MAX;
	else
	{
		f = fabsf(f);
		if (f != 1.0f)
			f = 1.0f / (float)sqrtf(f);
	}

	dst = f;
}

// Sine/cosine: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sincos---vs
static INTRINSIC_INLINE void sincos_c(D3DXVECTOR4& dst, const float src)
{
	dst.x = cosf(src);
}

// Sine/cosine: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sincos---vs
static INTRINSIC_INLINE void sincos_s(D3DXVECTOR4& dst, const float src)
{
	dst.y = sinf(src);
}

// Sine/cosine: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sincos---vs
static INTRINSIC_INLINE void sincos_sc(D3DXVECTOR4& dst, const float src)
{
	dst.x = cosf(src);
	dst.y = sinf(src);
}

// Signed Greater-than or Equal to: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sge---vs
static INTRINSIC_INLINE void sge(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.x = (src0.x >= src1.x) ? 1.0f : 0.0f;
	dst.y = (src0.y >= src1.y) ? 1.0f : 0.0f;
	dst.z = (src0.z >= src1.z) ? 1.0f : 0.0f;
	dst.w = (src0.w >= src1.w) ? 1.0f : 0.0f;
}

// Signed Greater-than or Equal to: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sge---vs
static INTRINSIC_INLINE void sge(float& dst, const float src0, const float src1)
{
	dst = (src0 >= src1) ? 1.0f : 0.0f;
}

// Sign determination function: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sgn---vs
static INTRINSIC_INLINE void sgn(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1_unused, const D3DXVECTOR4& src2_unused)
{
	UNREFERENCED_PARAMETER(src1_unused);
	UNREFERENCED_PARAMETER(src2_unused);

	dst.x = src0.x < 0 ? -1.0f : src0.x == 0.0f ? 0.0f : 1.0f;
	dst.y = src0.y < 0 ? -1.0f : src0.y == 0.0f ? 0.0f : 1.0f;
	dst.z = src0.z < 0 ? -1.0f : src0.z == 0.0f ? 0.0f : 1.0f;
	dst.w = src0.w < 0 ? -1.0f : src0.w == 0.0f ? 0.0f : 1.0f;
}

// Signed Less-than: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/slt---vs
static INTRINSIC_INLINE void slt(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.x = (src0.x < src1.x) ? 1.0f : 0.0f;
	dst.y = (src0.y < src1.y) ? 1.0f : 0.0f;
	dst.z = (src0.z < src1.z) ? 1.0f : 0.0f;
	dst.w = (src0.w < src1.w) ? 1.0f : 0.0f;
}

// Signed Less-than: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/slt---vs
static INTRINSIC_INLINE void slt(float& dst, const float src0, const float src1)
{
	dst = (src0 < src1) ? 1.0f : 0.0f;
}

// Subtract: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sub---vs
static INTRINSIC_INLINE void sub(D3DXVECTOR4& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1)
{
	dst.x = src0.x - src1.x;
	dst.y = src0.y - src1.y;
	dst.z = src0.z - src1.z;
	dst.w = src0.w - src1.w;
}

static __forceinline const float saturate(const float inputFloat)
{
	if (inputFloat > 1.0f)
		return 1.0f;
	else if (inputFloat < 0.0f)
		return 0.0f;
	return inputFloat;
}

// Texture sample functions (tex2D, tex2Dgrad, tex2Dlod):
template <const unsigned char writeMask>
void __fastcall tex2Dmip0(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);

template <const unsigned char writeMask>
void __fastcall tex2Dlod(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);

template <const unsigned char writeMask, const bool useTexCoordMipBias>
void __fastcall tex2Dgrad(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);

```

`Software_d3d9/ShaderIntrinsicFunctions4.h`:

```h
#pragma once

// Fast log2 function that trades precision for speed
inline float log2_lowp(float val)
{
	int* const exp_ptr = reinterpret_cast<int* const>(&val);
	int x = *exp_ptr;
	const int log_2 = ((x >> 23) & 0xFF) - 128;
	x &= ~(255 << 23);
	x += 127 << 23;
	*exp_ptr = x;

	val = ( (-1.0f / 3.0f) * val + 2.0f) * val - 2.0f / 3.0f;

	return val + log_2;
}

// Absolute-value: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/abs---vs
static INTRINSIC_INLINE void abs4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src)[4])
{
	dst[0].x = fabsf(src[0].x);
	dst[1].x = fabsf(src[1].x);
	dst[2].x = fabsf(src[2].x);
	dst[3].x = fabsf(src[3].x);

	dst[0].y = fabsf(src[0].y);
	dst[1].y = fabsf(src[1].y);
	dst[2].y = fabsf(src[2].y);
	dst[3].y = fabsf(src[3].y);

	dst[0].z = fabsf(src[0].z);
	dst[1].z = fabsf(src[1].z);
	dst[2].z = fabsf(src[2].z);
	dst[3].z = fabsf(src[3].z);

	dst[0].w = fabsf(src[0].w);
	dst[1].w = fabsf(src[1].w);
	dst[2].w = fabsf(src[2].w);
	dst[3].w = fabsf(src[3].w);
}

// Addition: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/add---vs
static INTRINSIC_INLINE void add4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	dst[0].x = src0[0].x + src1[0].x;
	dst[1].x = src0[1].x + src1[1].x;
	dst[2].x = src0[2].x + src1[2].x;
	dst[3].x = src0[3].x + src1[3].x;

	dst[0].y = src0[0].y + src1[0].y;
	dst[1].y = src0[1].y + src1[1].y;
	dst[2].y = src0[2].y + src1[2].y;
	dst[3].y = src0[3].y + src1[3].y;

	dst[0].z = src0[0].z + src1[0].z;
	dst[1].z = src0[1].z + src1[1].z;
	dst[2].z = src0[2].z + src1[2].z;
	dst[3].z = src0[3].z + src1[3].z;

	dst[0].w = src0[0].w + src1[0].w;
	dst[1].w = src0[1].w + src1[1].w;
	dst[2].w = src0[2].w + src1[2].w;
	dst[3].w = src0[3].w + src1[3].w;
}

// Compare: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/cmp---ps
static INTRINSIC_INLINE void cmp4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4])
{
	dst[0].x = src0[0].x >= 0.0f ? src1[0].x : src2[0].x;
	dst[1].x = src0[1].x >= 0.0f ? src1[1].x : src2[1].x;
	dst[2].x = src0[2].x >= 0.0f ? src1[2].x : src2[2].x;
	dst[3].x = src0[3].x >= 0.0f ? src1[3].x : src2[3].x;

	dst[0].y = src0[0].y >= 0.0f ? src1[0].y : src2[0].y;
	dst[1].y = src0[1].y >= 0.0f ? src1[1].y : src2[1].y;
	dst[2].y = src0[2].y >= 0.0f ? src1[2].y : src2[2].y;
	dst[3].y = src0[3].y >= 0.0f ? src1[3].y : src2[3].y;

	dst[0].z = src0[0].z >= 0.0f ? src1[0].z : src2[0].z;
	dst[1].z = src0[1].z >= 0.0f ? src1[1].z : src2[1].z;
	dst[2].z = src0[2].z >= 0.0f ? src1[2].z : src2[2].z;
	dst[3].z = src0[3].z >= 0.0f ? src1[3].z : src2[3].z;

	dst[0].w = src0[0].w >= 0.0f ? src1[0].w : src2[0].w;
	dst[1].w = src0[1].w >= 0.0f ? src1[1].w : src2[1].w;
	dst[2].w = src0[2].w >= 0.0f ? src1[2].w : src2[2].w;
	dst[3].w = src0[3].w >= 0.0f ? src1[3].w : src2[3].w;
}

// Conditional select: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/cnd---ps
static INTRINSIC_INLINE void cnd4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4])
{
	dst[0].x = src0[0].x > 0.5f ? src1[0].x : src2[0].x;
	dst[1].x = src0[1].x > 0.5f ? src1[1].x : src2[1].x;
	dst[2].x = src0[2].x > 0.5f ? src1[2].x : src2[2].x;
	dst[3].x = src0[3].x > 0.5f ? src1[3].x : src2[3].x;

	dst[0].y = src0[0].y > 0.5f ? src1[0].y : src2[0].y;
	dst[1].y = src0[1].y > 0.5f ? src1[1].y : src2[1].y;
	dst[2].y = src0[2].y > 0.5f ? src1[2].y : src2[2].y;
	dst[3].y = src0[3].y > 0.5f ? src1[3].y : src2[3].y;

	dst[0].z = src0[0].z > 0.5f ? src1[0].z : src2[0].z;
	dst[1].z = src0[1].z > 0.5f ? src1[1].z : src2[1].z;
	dst[2].z = src0[2].z > 0.5f ? src1[2].z : src2[2].z;
	dst[3].z = src0[3].z > 0.5f ? src1[3].z : src2[3].z;

	dst[0].w = src0[0].w > 0.5f ? src1[0].w : src2[0].w;
	dst[1].w = src0[1].w > 0.5f ? src1[1].w : src2[1].w;
	dst[2].w = src0[2].w > 0.5f ? src1[2].w : src2[2].w;
	dst[3].w = src0[3].w > 0.5f ? src1[3].w : src2[3].w;
}

// Cross-product: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/crs---vs
static INTRINSIC_INLINE void crs4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	dst[0].x = src0[0].y * src1[0].z - src0[0].z * src1[0].y;
	dst[1].x = src0[1].y * src1[1].z - src0[1].z * src1[1].y;
	dst[2].x = src0[2].y * src1[2].z - src0[2].z * src1[2].y;
	dst[3].x = src0[3].y * src1[3].z - src0[3].z * src1[3].y;

	dst[0].y = src0[0].z * src1[0].x - src0[0].x * src1[0].z;
	dst[1].y = src0[1].z * src1[1].x - src0[1].x * src1[1].z;
	dst[2].y = src0[2].z * src1[2].x - src0[2].x * src1[2].z;
	dst[3].y = src0[3].z * src1[3].x - src0[3].x * src1[3].z;

	dst[0].z = src0[0].x * src1[0].y - src0[0].y * src1[0].x;
	dst[1].z = src0[1].x * src1[1].y - src0[1].y * src1[1].x;
	dst[2].z = src0[2].x * src1[2].y - src0[2].y * src1[2].x;
	dst[3].z = src0[3].x * src1[3].y - src0[3].y * src1[3].x;
}

// 2-D dot product and add scalar: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp2add---ps
static INTRINSIC_INLINE void dp2add4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4])
{
	const float dp2result[4] =
	{
		(src0[0].x * src1[0].x) + (src0[0].y * src1[0].y),
		(src0[1].x * src1[1].x) + (src0[1].y * src1[1].y),
		(src0[2].x * src1[2].x) + (src0[2].y * src1[2].y),
		(src0[3].x * src1[3].x) + (src0[3].y * src1[3].y)
	};

	dst[0].x = dp2result[0] + src2[0].x;
	dst[1].x = dp2result[1] + src2[1].x;
	dst[2].x = dp2result[2] + src2[2].x;
	dst[3].x = dp2result[3] + src2[3].x;

	dst[0].y = dp2result[0] + src2[0].y;
	dst[1].y = dp2result[1] + src2[1].y;
	dst[2].y = dp2result[2] + src2[2].y;
	dst[3].y = dp2result[3] + src2[3].y;

	dst[0].z = dp2result[0] + src2[0].z;
	dst[1].z = dp2result[1] + src2[1].z;
	dst[2].z = dp2result[2] + src2[2].z;
	dst[3].z = dp2result[3] + src2[3].z;

	dst[0].w = dp2result[0] + src2[0].w;
	dst[1].w = dp2result[1] + src2[1].w;
	dst[2].w = dp2result[2] + src2[2].w;
	dst[3].w = dp2result[3] + src2[3].w;
}

// 2-D dot product and add scalar: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp2add---ps
static INTRINSIC_INLINE void dp2add1_4(float& dst, const D3DXVECTOR4& src0, const D3DXVECTOR4& src1, const float src2)
{
	dst = (src0.x * src1.x) + (src0.y * src1.y);
	dst += src2;
}

// dot3: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp3---vs
static INTRINSIC_INLINE void dp3_4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	const float f4[4] =
	{
		(src0[0].x * src1[0].x) + (src0[0].y * src1[0].y) + (src0[0].z * src1[0].z),
		(src0[1].x * src1[1].x) + (src0[1].y * src1[1].y) + (src0[1].z * src1[1].z),
		(src0[2].x * src1[2].x) + (src0[2].y * src1[2].y) + (src0[2].z * src1[2].z),
		(src0[3].x * src1[3].x) + (src0[3].y * src1[3].y) + (src0[3].z * src1[3].z)
	};

	dst[0].x = dst[0].y = dst[0].z = dst[0].w = f4[0];
	dst[1].x = dst[1].y = dst[1].z = dst[1].w = f4[1];
	dst[2].x = dst[2].y = dst[2].z = dst[2].w = f4[2];
	dst[3].x = dst[3].y = dst[3].z = dst[3].w = f4[3];
}

// dot4: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp4---ps
static INTRINSIC_INLINE void dp4_4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	const float f4[4] =
	{
		(src0[0].x * src1[0].x) + (src0[0].y * src1[0].y) + (src0[0].z * src1[0].z) + (src0[0].w * src1[0].w),
		(src0[1].x * src1[1].x) + (src0[1].y * src1[1].y) + (src0[1].z * src1[1].z) + (src0[1].w * src1[1].w),
		(src0[2].x * src1[2].x) + (src0[2].y * src1[2].y) + (src0[2].z * src1[2].z) + (src0[2].w * src1[2].w),
		(src0[3].x * src1[3].x) + (src0[3].y * src1[3].y) + (src0[3].z * src1[3].z) + (src0[3].w * src1[3].w)
	};

	dst[0].x = dst[0].y = dst[0].z = dst[0].w = f4[0];
	dst[1].x = dst[1].y = dst[1].z = dst[1].w = f4[1];
	dst[2].x = dst[2].y = dst[2].z = dst[2].w = f4[2];
	dst[3].x = dst[3].y = dst[3].z = dst[3].w = f4[3];
}

// dot4 quad against constant: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dp4---ps
static INTRINSIC_INLINE void dp4_4(float (&dst)[4], const D3DXVECTOR4* (&src0)[4], const D3DXVECTOR4& src1)
{
	dst[0] = (src0[0]->x * src1.x);
	dst[1] = (src0[1]->x * src1.x);
	dst[2] = (src0[2]->x * src1.x);
	dst[3] = (src0[3]->x * src1.x);

	dst[0] += (src0[0]->y * src1.y);
	dst[1] += (src0[1]->y * src1.y);
	dst[2] += (src0[2]->y * src1.y);
	dst[3] += (src0[3]->y * src1.y);

	dst[0] += (src0[0]->z * src1.z);
	dst[1] += (src0[1]->z * src1.z);
	dst[2] += (src0[2]->z * src1.z);
	dst[3] += (src0[3]->z * src1.z);

	dst[0] += (src0[0]->w * src1.w);
	dst[1] += (src0[1]->w * src1.w);
	dst[2] += (src0[2]->w * src1.w);
	dst[3] += (src0[3]->w * src1.w);
}

// distance: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dst---vs
/*
// The source vectors are assumed to contain the values shown in the following pseudocode:
src0.x = undefined
src0.y = d * d
src0.z = d * d
src0.w = undefined
src1.x = undefined
src1.y = 1 / d
src1.z = undefined
src1.w = 1 / d

// The destination vector is assumed to look like this after the dst() function is executed:
dest.x = 1
dest.y = d
dest.z = d * d
dest.w = 1 / d
*/
static INTRINSIC_INLINE void dst4(D3DXVECTOR4 (&dest)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	dest[0].x = 1.0f;
	dest[1].x = 1.0f;
	dest[2].x = 1.0f;
	dest[3].x = 1.0f;

	dest[0].y = sqrtf(src0[0].y);
	dest[1].y = sqrtf(src0[1].y);
	dest[2].y = sqrtf(src0[2].y);
	dest[3].y = sqrtf(src0[3].y);

	dest[0].z = src0[0].z;
	dest[1].z = src0[1].z;
	dest[2].z = src0[2].z;
	dest[3].z = src0[3].z;

	dest[0].w = src1[0].w;
	dest[1].w = src1[1].w;
	dest[2].w = src1[2].w;
	dest[3].w = src1[3].w;
}

// ddx/dsx: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dsx---ps
static INTRINSIC_INLINE void dsx(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4])
{
	const D3DXVECTOR4 ddxResultTop(src0[GRADIENT_QUAD_TOPRIGHT_INDEX].x - src0[GRADIENT_QUAD_TOPLEFT_INDEX].x,
		src0[GRADIENT_QUAD_TOPRIGHT_INDEX].y - src0[GRADIENT_QUAD_TOPLEFT_INDEX].y,
		src0[GRADIENT_QUAD_TOPRIGHT_INDEX].z - src0[GRADIENT_QUAD_TOPLEFT_INDEX].z,
		src0[GRADIENT_QUAD_TOPRIGHT_INDEX].z - src0[GRADIENT_QUAD_TOPLEFT_INDEX].w);

	dst[GRADIENT_QUAD_TOPLEFT_INDEX].x = dst[GRADIENT_QUAD_TOPRIGHT_INDEX].x = ddxResultTop.x;
	dst[GRADIENT_QUAD_TOPLEFT_INDEX].y = dst[GRADIENT_QUAD_TOPRIGHT_INDEX].y = ddxResultTop.y;
	dst[GRADIENT_QUAD_TOPLEFT_INDEX].z = dst[GRADIENT_QUAD_TOPRIGHT_INDEX].z = ddxResultTop.z;
	dst[GRADIENT_QUAD_TOPLEFT_INDEX].w = dst[GRADIENT_QUAD_TOPRIGHT_INDEX].w = ddxResultTop.w;

	const D3DXVECTOR4 ddxResultBot(src0[GRADIENT_QUAD_BOTRIGHT_INDEX].x - src0[GRADIENT_QUAD_BOTLEFT_INDEX].x,
		src0[GRADIENT_QUAD_BOTRIGHT_INDEX].y - src0[GRADIENT_QUAD_BOTLEFT_INDEX].y,
		src0[GRADIENT_QUAD_BOTRIGHT_INDEX].z - src0[GRADIENT_QUAD_BOTLEFT_INDEX].z,
		src0[GRADIENT_QUAD_BOTRIGHT_INDEX].z - src0[GRADIENT_QUAD_BOTLEFT_INDEX].w);

	dst[GRADIENT_QUAD_BOTLEFT_INDEX].x = dst[GRADIENT_QUAD_BOTRIGHT_INDEX].x = ddxResultBot.x;
	dst[GRADIENT_QUAD_BOTLEFT_INDEX].y = dst[GRADIENT_QUAD_BOTRIGHT_INDEX].y = ddxResultBot.y;
	dst[GRADIENT_QUAD_BOTLEFT_INDEX].z = dst[GRADIENT_QUAD_BOTRIGHT_INDEX].z = ddxResultBot.z;
	dst[GRADIENT_QUAD_BOTLEFT_INDEX].w = dst[GRADIENT_QUAD_BOTRIGHT_INDEX].w = ddxResultBot.w;
}

// ddy/dsy: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dsy---ps
static INTRINSIC_INLINE void dsy(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4])
{
	const D3DXVECTOR4 ddyResultLeft(src0[GRADIENT_QUAD_BOTLEFT_INDEX].x - src0[GRADIENT_QUAD_TOPLEFT_INDEX].x,
		src0[GRADIENT_QUAD_BOTLEFT_INDEX].y - src0[GRADIENT_QUAD_TOPLEFT_INDEX].y,
		src0[GRADIENT_QUAD_BOTLEFT_INDEX].z - src0[GRADIENT_QUAD_TOPLEFT_INDEX].z,
		src0[GRADIENT_QUAD_BOTLEFT_INDEX].z - src0[GRADIENT_QUAD_TOPLEFT_INDEX].w);

	dst[GRADIENT_QUAD_TOPLEFT_INDEX].x = dst[GRADIENT_QUAD_BOTLEFT_INDEX].x = ddyResultLeft.x;
	dst[GRADIENT_QUAD_TOPLEFT_INDEX].y = dst[GRADIENT_QUAD_BOTLEFT_INDEX].y = ddyResultLeft.y;
	dst[GRADIENT_QUAD_TOPLEFT_INDEX].z = dst[GRADIENT_QUAD_BOTLEFT_INDEX].z = ddyResultLeft.z;
	dst[GRADIENT_QUAD_TOPLEFT_INDEX].w = dst[GRADIENT_QUAD_BOTLEFT_INDEX].w = ddyResultLeft.w;

	const D3DXVECTOR4 ddyResultRight(src0[GRADIENT_QUAD_BOTRIGHT_INDEX].x - src0[GRADIENT_QUAD_TOPRIGHT_INDEX].x,
		src0[GRADIENT_QUAD_BOTRIGHT_INDEX].y - src0[GRADIENT_QUAD_TOPRIGHT_INDEX].y,
		src0[GRADIENT_QUAD_BOTRIGHT_INDEX].z - src0[GRADIENT_QUAD_TOPRIGHT_INDEX].z,
		src0[GRADIENT_QUAD_BOTRIGHT_INDEX].z - src0[GRADIENT_QUAD_TOPRIGHT_INDEX].w);

	dst[GRADIENT_QUAD_TOPRIGHT_INDEX].x = dst[GRADIENT_QUAD_BOTRIGHT_INDEX].x = ddyResultRight.x;
	dst[GRADIENT_QUAD_TOPRIGHT_INDEX].y = dst[GRADIENT_QUAD_BOTRIGHT_INDEX].y = ddyResultRight.y;
	dst[GRADIENT_QUAD_TOPRIGHT_INDEX].z = dst[GRADIENT_QUAD_BOTRIGHT_INDEX].z = ddyResultRight.z;
	dst[GRADIENT_QUAD_TOPRIGHT_INDEX].w = dst[GRADIENT_QUAD_BOTRIGHT_INDEX].w = ddyResultRight.w;
}

// exp (minimum 21 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/exp---vs
// expp (minimum 10 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/expp---vs
static INTRINSIC_INLINE void exp4(D3DXVECTOR4 (&dst)[4], const float (&src_replicateSwizzleComponent)[4])
{
	const float val4[4] =
	{
		powf(2.0f, src_replicateSwizzleComponent[0]),
		powf(2.0f, src_replicateSwizzleComponent[1]),
		powf(2.0f, src_replicateSwizzleComponent[2]),
		powf(2.0f, src_replicateSwizzleComponent[3])
	};
	dst[0].x = dst[0].y = dst[0].z = dst[0].w = val4[0];
	dst[1].x = dst[1].y = dst[1].z = dst[1].w = val4[1];
	dst[2].x = dst[2].y = dst[2].z = dst[2].w = val4[2];
	dst[3].x = dst[3].y = dst[3].z = dst[3].w = val4[3];
}

// Frac: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/frc---vs
static INTRINSIC_INLINE void frc4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src)[4])
{
	dst[0].x = src[0].x - floorf(src[0].x);
	dst[1].x = src[1].x - floorf(src[1].x);
	dst[2].x = src[2].x - floorf(src[2].x);
	dst[3].x = src[3].x - floorf(src[3].x);

	dst[0].y = src[0].y - floorf(src[0].y);
	dst[1].y = src[1].y - floorf(src[1].y);
	dst[2].y = src[2].y - floorf(src[2].y);
	dst[3].y = src[3].y - floorf(src[3].y);

	dst[0].z = src[0].z - floorf(src[0].z);
	dst[1].z = src[1].z - floorf(src[1].z);
	dst[2].z = src[2].z - floorf(src[2].z);
	dst[3].z = src[3].z - floorf(src[3].z);

	dst[0].w = src[0].w - floorf(src[0].w);
	dst[1].w = src[1].w - floorf(src[1].w);
	dst[2].w = src[2].w - floorf(src[2].w);
	dst[3].w = src[3].w - floorf(src[3].w);
}

// lighting: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/lit---vs
/*
// The source vector is assumed to contain the values shown in the following pseudocode.
src.x = N dot L    ; The dot product between normal and direction to light (for diffuse lighting)
src.y = N dot H    ; The dot product between normal and half vector (for specular lighting)
src.z = ignored    ; This value is ignored
src.w = exponent   ; The value must be between -128.0 and 128.0 (for specular lighting)
*/
static const D3DXVECTOR4 initLitVector4(1.0f, 0.0f, 0.0f, 1.0f);
static INTRINSIC_INLINE void lit4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4])
{
	dst[0] = dst[1] = dst[2] = dst[3] = initLitVector4;

	if (src0[0].x > 0.0f)
	{
		dst[0].y = src0[0].x; // This is N dot L (for diffuse lighting)

		// Do specular lighting:
		if (src0[0].y > 0.0f)
		{
			const float MAXPOWER = 127.9961f; // An implementation must support at least eight fraction bits in the power argument (8.8 fixed point)
			float power = src0[0].w;
			if (power < -MAXPOWER)
				power = -MAXPOWER;
			else if (power > MAXPOWER)
				power = MAXPOWER;
			dst[0].z = powf(src0[0].y, power);
		}
	}

	if (src0[1].x > 0.0f)
	{
		dst[1].y = src0[1].x; // This is N dot L (for diffuse lighting)

		// Do specular lighting:
		if (src0[1].y > 0.0f)
		{
			const float MAXPOWER = 127.9961f; // An implementation must support at least eight fraction bits in the power argument (8.8 fixed point)
			float power = src0[1].w;
			if (power < -MAXPOWER)
				power = -MAXPOWER;
			else if (power > MAXPOWER)
				power = MAXPOWER;
			dst[1].z = powf(src0[1].y, power);
		}
	}

	if (src0[2].x > 0.0f)
	{
		dst[2].y = src0[2].x; // This is N dot L (for diffuse lighting)

		// Do specular lighting:
		if (src0[2].y > 0.0f)
		{
			const float MAXPOWER = 127.9961f; // An implementation must support at least eight fraction bits in the power argument (8.8 fixed point)
			float power = src0[2].w;
			if (power < -MAXPOWER)
				power = -MAXPOWER;
			else if (power > MAXPOWER)
				power = MAXPOWER;
			dst[2].z = powf(src0[2].y, power);
		}
	}

	if (src0[3].x > 0.0f)
	{
		dst[3].y = src0[3].x; // This is N dot L (for diffuse lighting)

		// Do specular lighting:
		if (src0[3].y > 0.0f)
		{
			const float MAXPOWER = 127.9961f; // An implementation must support at least eight fraction bits in the power argument (8.8 fixed point)
			float power = src0[3].w;
			if (power < -MAXPOWER)
				power = -MAXPOWER;
			else if (power > MAXPOWER)
				power = MAXPOWER;
			dst[3].z = powf(src0[3].y, power);
		}
	}
}

// Log (minimum 21 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/log---vs
// Logp (minimum 10 bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/logp---vs
static INTRINSIC_INLINE void log4(D3DXVECTOR4 (&dst)[4], const float (&src_replicateSwizzleComponent)[4])
{
	const float v4[4] = 
	{
		fabsf(src_replicateSwizzleComponent[0]),
		fabsf(src_replicateSwizzleComponent[1]),
		fabsf(src_replicateSwizzleComponent[2]),
		fabsf(src_replicateSwizzleComponent[3])
	};

	if (v4[0] != 0.0f)
		dst[0].x = dst[0].y = dst[0].z = dst[0].w = log2_lowp(v4[0]);
	else
		dst[0].x = dst[0].y = dst[0].z = dst[0].w = -FLT_MAX;

	if (v4[1] != 0.0f)
		dst[1].x = dst[1].y = dst[1].z = dst[1].w = log2_lowp(v4[1]);
	else
		dst[1].x = dst[1].y = dst[1].z = dst[1].w = -FLT_MAX;

	if (v4[2] != 0.0f)
		dst[2].x = dst[2].y = dst[2].z = dst[2].w = log2_lowp(v4[2]);
	else
		dst[2].x = dst[2].y = dst[2].z = dst[2].w = -FLT_MAX;

	if (v4[3] != 0.0f)
		dst[3].x = dst[3].y = dst[3].z = dst[3].w = log2_lowp(v4[3]);
	else
		dst[3].x = dst[3].y = dst[3].z = dst[3].w = -FLT_MAX;
}

// lerp: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/lrp---vs
template <const unsigned char channelWriteMask = 0xF, const unsigned char pixelWriteMask = 0xF>
static INTRINSIC_INLINE void lrp4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4])
{
	__m128 amount4[4];
	if (pixelWriteMask & 0x1) amount4[0] = *(const __m128* const)&(src0[0]);
	if (pixelWriteMask & 0x2) amount4[1] = *(const __m128* const)&(src0[1]);
	if (pixelWriteMask & 0x4) amount4[2] = *(const __m128* const)&(src0[2]);
	if (pixelWriteMask & 0x8) amount4[3] = *(const __m128* const)&(src0[3]);

	__m128 src1vec[4];
	if (pixelWriteMask & 0x1) src1vec[0] = *(const __m128* const)&(src1[0]);
	if (pixelWriteMask & 0x2) src1vec[1] = *(const __m128* const)&(src1[1]);
	if (pixelWriteMask & 0x4) src1vec[2] = *(const __m128* const)&(src1[2]);
	if (pixelWriteMask & 0x8) src1vec[3] = *(const __m128* const)&(src1[3]);

	__m128 src2vec[4];
	if (pixelWriteMask & 0x1) src2vec[0] = *(const __m128* const)&(src2[0]);
	if (pixelWriteMask & 0x2) src2vec[1] = *(const __m128* const)&(src2[1]);
	if (pixelWriteMask & 0x4) src2vec[2] = *(const __m128* const)&(src2[2]);
	if (pixelWriteMask & 0x8) src2vec[3] = *(const __m128* const)&(src2[3]);

	if (channelWriteMask == 0xF)
	{
		if (pixelWriteMask & 0x1) *(__m128* const)&(dst[0]) = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[0], src1vec[0]), amount4[0]), src1vec[0]);
		if (pixelWriteMask & 0x2) *(__m128* const)&(dst[1]) = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[1], src1vec[1]), amount4[1]), src1vec[1]);
		if (pixelWriteMask & 0x4) *(__m128* const)&(dst[2]) = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[2], src1vec[2]), amount4[2]), src1vec[2]);
		if (pixelWriteMask & 0x8) *(__m128* const)&(dst[3]) = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[3], src1vec[3]), amount4[3]), src1vec[3]);
		return;
	}

	__m128 result[4];
	if (pixelWriteMask & 0x1) result[0] = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[0], src1vec[0]), amount4[0]), src1vec[0]);
	if (pixelWriteMask & 0x2) result[1] = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[1], src1vec[1]), amount4[1]), src1vec[1]);
	if (pixelWriteMask & 0x4) result[2] = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[2], src1vec[2]), amount4[2]), src1vec[2]);
	if (pixelWriteMask & 0x8) result[3] = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[3], src1vec[3]), amount4[3]), src1vec[3]);

	if (channelWriteMask & 0x1)
	{
		if (pixelWriteMask & 0x1) dst[0].x = result[0].m128_f32[0];
		if (pixelWriteMask & 0x2) dst[1].x = result[1].m128_f32[0];
		if (pixelWriteMask & 0x4) dst[2].x = result[2].m128_f32[0];
		if (pixelWriteMask & 0x8) dst[3].x = result[3].m128_f32[0];
	}
	if (channelWriteMask & 0x2)	
	{
		if (pixelWriteMask & 0x1) dst[0].y = result[0].m128_f32[1];
		if (pixelWriteMask & 0x2) dst[1].y = result[1].m128_f32[1];
		if (pixelWriteMask & 0x4) dst[2].y = result[2].m128_f32[1];
		if (pixelWriteMask & 0x8) dst[3].y = result[3].m128_f32[1];
	}
	if (channelWriteMask & 0x4)
	{
		if (pixelWriteMask & 0x1) dst[0].z = result[0].m128_f32[2];
		if (pixelWriteMask & 0x2) dst[1].z = result[1].m128_f32[2];
		if (pixelWriteMask & 0x4) dst[2].z = result[2].m128_f32[2];
		if (pixelWriteMask & 0x8) dst[3].z = result[3].m128_f32[2];
	}
	if (channelWriteMask & 0x8)
	{
		if (pixelWriteMask & 0x1) dst[0].w = result[0].m128_f32[3];
		if (pixelWriteMask & 0x2) dst[1].w = result[1].m128_f32[3];
		if (pixelWriteMask & 0x4) dst[2].w = result[2].m128_f32[3];
		if (pixelWriteMask & 0x8) dst[3].w = result[3].m128_f32[3];
	}
}

// lerp: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/lrp---vs
template <const unsigned char channelWriteMask = 0xF, const unsigned char pixelWriteMask = 0xF>
static inline void lrp4(D3DXVECTOR4 (&dst)[4], const __m128 src0, const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4])
{
	__m128 amount4[4];
	if (pixelWriteMask & 0x1) amount4[0] = _mm_shuffle_ps(src0, src0, _MM_SHUFFLE(0, 0, 0, 0) );
	if (pixelWriteMask & 0x2) amount4[1] = _mm_shuffle_ps(src0, src0, _MM_SHUFFLE(1, 1, 1, 1) );
	if (pixelWriteMask & 0x4) amount4[2] = _mm_shuffle_ps(src0, src0, _MM_SHUFFLE(2, 2, 2, 2) );
	if (pixelWriteMask & 0x8) amount4[3] = _mm_shuffle_ps(src0, src0, _MM_SHUFFLE(3, 3, 3, 3) );

	__m128 src1vec[4];
	if (pixelWriteMask & 0x1) src1vec[0] = *(const __m128* const)&(src1[0]);
	if (pixelWriteMask & 0x2) src1vec[1] = *(const __m128* const)&(src1[1]);
	if (pixelWriteMask & 0x4) src1vec[2] = *(const __m128* const)&(src1[2]);
	if (pixelWriteMask & 0x8) src1vec[3] = *(const __m128* const)&(src1[3]);

	__m128 src2vec[4];
	if (pixelWriteMask & 0x1) src2vec[0] = *(const __m128* const)&(src2[0]);
	if (pixelWriteMask & 0x2) src2vec[1] = *(const __m128* const)&(src2[1]);
	if (pixelWriteMask & 0x4) src2vec[2] = *(const __m128* const)&(src2[2]);
	if (pixelWriteMask & 0x8) src2vec[3] = *(const __m128* const)&(src2[3]);

	if (channelWriteMask == 0xF)
	{
		if (pixelWriteMask & 0x1) *(__m128* const)&(dst[0]) = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[0], src1vec[0]), amount4[0]), src1vec[0]);
		if (pixelWriteMask & 0x2) *(__m128* const)&(dst[1]) = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[1], src1vec[1]), amount4[1]), src1vec[1]);
		if (pixelWriteMask & 0x4) *(__m128* const)&(dst[2]) = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[2], src1vec[2]), amount4[2]), src1vec[2]);
		if (pixelWriteMask & 0x8) *(__m128* const)&(dst[3]) = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[3], src1vec[3]), amount4[3]), src1vec[3]);
		return;
	}

	__m128 result[4];
	if (pixelWriteMask & 0x1) result[0] = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[0], src1vec[0]), amount4[0]), src1vec[0]);
	if (pixelWriteMask & 0x2) result[1] = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[1], src1vec[1]), amount4[1]), src1vec[1]);
	if (pixelWriteMask & 0x4) result[2] = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[2], src1vec[2]), amount4[2]), src1vec[2]);
	if (pixelWriteMask & 0x8) result[3] = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(src2vec[3], src1vec[3]), amount4[3]), src1vec[3]);

	if (channelWriteMask & 0x1)
	{
		if (pixelWriteMask & 0x1) dst[0].x = result[0].m128_f32[0];
		if (pixelWriteMask & 0x2) dst[1].x = result[1].m128_f32[0];
		if (pixelWriteMask & 0x4) dst[2].x = result[2].m128_f32[0];
		if (pixelWriteMask & 0x8) dst[3].x = result[3].m128_f32[0];
	}
	if (channelWriteMask & 0x2)	
	{
		if (pixelWriteMask & 0x1) dst[0].y = result[0].m128_f32[1];
		if (pixelWriteMask & 0x2) dst[1].y = result[1].m128_f32[1];
		if (pixelWriteMask & 0x4) dst[2].y = result[2].m128_f32[1];
		if (pixelWriteMask & 0x8) dst[3].y = result[3].m128_f32[1];
	}
	if (channelWriteMask & 0x4)
	{
		if (pixelWriteMask & 0x1) dst[0].z = result[0].m128_f32[2];
		if (pixelWriteMask & 0x2) dst[1].z = result[1].m128_f32[2];
		if (pixelWriteMask & 0x4) dst[2].z = result[2].m128_f32[2];
		if (pixelWriteMask & 0x8) dst[3].z = result[3].m128_f32[2];
	}
	if (channelWriteMask & 0x8)
	{
		if (pixelWriteMask & 0x1) dst[0].w = result[0].m128_f32[3];
		if (pixelWriteMask & 0x2) dst[1].w = result[1].m128_f32[3];
		if (pixelWriteMask & 0x4) dst[2].w = result[2].m128_f32[3];
		if (pixelWriteMask & 0x8) dst[3].w = result[3].m128_f32[3];
	}
}

// 3x2 matrix mult: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/m3x2---vs
static INTRINSIC_INLINE void m3x2_4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4])
{
	dst[0].x = (src0[0].x * src1[0].x) + (src0[0].x * src1[0].y) + (src0[0].x * src1[0].z);
	dst[1].x = (src0[1].x * src1[1].x) + (src0[1].x * src1[1].y) + (src0[1].x * src1[1].z);
	dst[2].x = (src0[2].x * src1[2].x) + (src0[2].x * src1[2].y) + (src0[2].x * src1[2].z);
	dst[3].x = (src0[3].x * src1[3].x) + (src0[3].x * src1[3].y) + (src0[3].x * src1[3].z);

	dst[0].y = (src0[0].x * src2[0].x) + (src0[0].y * src2[0].y) + (src0[0].z * src2[0].z);
	dst[1].y = (src0[1].x * src2[1].x) + (src0[1].y * src2[1].y) + (src0[1].z * src2[1].z);
	dst[2].y = (src0[2].x * src2[2].x) + (src0[2].y * src2[2].y) + (src0[2].z * src2[2].z);
	dst[3].y = (src0[3].x * src2[3].x) + (src0[3].y * src2[3].y) + (src0[3].z * src2[3].z);
}

// 3x3 matrix mult: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/m3x3---vs
static INTRINSIC_INLINE void m3x3_4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4], const D3DXVECTOR4 (&src3)[4])
{
	dst[0].x = (src0[0].x * src1[0].x) + (src0[0].y * src1[0].y) + (src0[0].z * src1[0].z);
	dst[1].x = (src0[1].x * src1[1].x) + (src0[1].y * src1[1].y) + (src0[1].z * src1[1].z);
	dst[2].x = (src0[2].x * src1[2].x) + (src0[2].y * src1[2].y) + (src0[2].z * src1[2].z);
	dst[3].x = (src0[3].x * src1[3].x) + (src0[3].y * src1[3].y) + (src0[3].z * src1[3].z);

	dst[0].y = (src0[0].x * src2[0].x) + (src0[0].y * src2[0].y) + (src0[0].z * src2[0].z);
	dst[1].y = (src0[1].x * src2[1].x) + (src0[1].y * src2[1].y) + (src0[1].z * src2[1].z);
	dst[2].y = (src0[2].x * src2[2].x) + (src0[2].y * src2[2].y) + (src0[2].z * src2[2].z);
	dst[3].y = (src0[3].x * src2[3].x) + (src0[3].y * src2[3].y) + (src0[3].z * src2[3].z);

	dst[0].z = (src0[0].x * src3[0].x) + (src0[0].y * src3[0].y) + (src0[0].z * src3[0].z);
	dst[1].z = (src0[1].x * src3[1].x) + (src0[1].y * src3[1].y) + (src0[1].z * src3[1].z);
	dst[2].z = (src0[2].x * src3[2].x) + (src0[2].y * src3[2].y) + (src0[2].z * src3[2].z);
	dst[3].z = (src0[3].x * src3[3].x) + (src0[3].y * src3[3].y) + (src0[3].z * src3[3].z);
}

// 3x4 matrix mult: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/m3x4---vs
static INTRINSIC_INLINE void m3x4_4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4], const D3DXVECTOR4 (&src3)[4], const D3DXVECTOR4 (&src4)[4])
{
	dst[0].x = (src0[0].x * src1[0].x) + (src0[0].y * src1[0].y) + (src0[0].z * src1[0].z);
	dst[1].x = (src0[1].x * src1[1].x) + (src0[1].y * src1[1].y) + (src0[1].z * src1[1].z);
	dst[2].x = (src0[2].x * src1[2].x) + (src0[2].y * src1[2].y) + (src0[2].z * src1[2].z);
	dst[3].x = (src0[3].x * src1[3].x) + (src0[3].y * src1[3].y) + (src0[3].z * src1[3].z);

	dst[0].y = (src0[0].x * src2[0].x) + (src0[0].y * src2[0].y) + (src0[0].z * src2[0].z);
	dst[0].y = (src0[1].x * src2[1].x) + (src0[1].y * src2[1].y) + (src0[1].z * src2[1].z);
	dst[0].y = (src0[2].x * src2[2].x) + (src0[2].y * src2[2].y) + (src0[2].z * src2[2].z);
	dst[0].y = (src0[3].x * src2[3].x) + (src0[3].y * src2[3].y) + (src0[3].z * src2[3].z);

	dst[0].z = (src0[0].x * src3[0].x) + (src0[0].y * src3[0].y) + (src0[0].z * src3[0].z);
	dst[1].z = (src0[1].x * src3[1].x) + (src0[1].y * src3[1].y) + (src0[1].z * src3[1].z);
	dst[2].z = (src0[2].x * src3[2].x) + (src0[2].y * src3[2].y) + (src0[2].z * src3[2].z);
	dst[3].z = (src0[3].x * src3[3].x) + (src0[3].y * src3[3].y) + (src0[3].z * src3[3].z);

	dst[0].w = (src0[0].x * src4[0].x) + (src0[0].y * src4[0].y) + (src0[0].z * src4[0].z);
	dst[1].w = (src0[1].x * src4[1].x) + (src0[1].y * src4[1].y) + (src0[1].z * src4[1].z);
	dst[2].w = (src0[2].x * src4[2].x) + (src0[2].y * src4[2].y) + (src0[2].z * src4[2].z);
	dst[3].w = (src0[3].x * src4[3].x) + (src0[3].y * src4[3].y) + (src0[3].z * src4[3].z);
}

// 4x3 matrix mult: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/m4x3---vs
static INTRINSIC_INLINE void m4x3_4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4], const D3DXVECTOR4 (&src3)[4])
{
	dst[0].x = (src0[0].x * src1[0].x) + (src0[0].y * src1[0].y) + (src0[0].z * src1[0].z) + (src0[0].w * src1[0].w);
	dst[1].x = (src0[1].x * src1[1].x) + (src0[1].y * src1[1].y) + (src0[1].z * src1[1].z) + (src0[1].w * src1[1].w);
	dst[2].x = (src0[2].x * src1[2].x) + (src0[2].y * src1[2].y) + (src0[2].z * src1[2].z) + (src0[2].w * src1[2].w);
	dst[3].x = (src0[3].x * src1[3].x) + (src0[3].y * src1[3].y) + (src0[3].z * src1[3].z) + (src0[3].w * src1[3].w);

	dst[0].y = (src0[0].x * src2[0].x) + (src0[0].y * src2[0].y) + (src0[0].z * src2[0].z) + (src0[0].w * src2[0].w);
	dst[1].y = (src0[1].x * src2[1].x) + (src0[1].y * src2[1].y) + (src0[1].z * src2[1].z) + (src0[1].w * src2[1].w);
	dst[2].y = (src0[2].x * src2[2].x) + (src0[2].y * src2[2].y) + (src0[2].z * src2[2].z) + (src0[2].w * src2[2].w);
	dst[3].y = (src0[3].x * src2[3].x) + (src0[3].y * src2[3].y) + (src0[3].z * src2[3].z) + (src0[3].w * src2[3].w);

	dst[0].z = (src0[0].x * src3[0].x) + (src0[0].y * src3[0].y) + (src0[0].z * src3[0].z) + (src0[0].w * src3[0].w);
	dst[1].z = (src0[1].x * src3[1].x) + (src0[1].y * src3[1].y) + (src0[1].z * src3[1].z) + (src0[1].w * src3[1].w);
	dst[2].z = (src0[2].x * src3[2].x) + (src0[2].y * src3[2].y) + (src0[2].z * src3[2].z) + (src0[2].w * src3[2].w);
	dst[3].z = (src0[3].x * src3[3].x) + (src0[3].y * src3[3].y) + (src0[3].z * src3[3].z) + (src0[3].w * src3[3].w);
}

// 4x4 matrix mult: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/m4x4---vs
static INTRINSIC_INLINE void m4x4_4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4], const D3DXVECTOR4 (&src3)[4], const D3DXVECTOR4 (&src4)[4])
{
	dst[0].x = (src0[0].x * src1[0].x) + (src0[0].y * src1[0].y) + (src0[0].z * src1[0].z) + (src0[0].w * src1[0].w);
	dst[1].x = (src0[1].x * src1[1].x) + (src0[1].y * src1[1].y) + (src0[1].z * src1[1].z) + (src0[1].w * src1[1].w);
	dst[2].x = (src0[2].x * src1[2].x) + (src0[2].y * src1[2].y) + (src0[2].z * src1[2].z) + (src0[2].w * src1[2].w);
	dst[3].x = (src0[3].x * src1[3].x) + (src0[3].y * src1[3].y) + (src0[3].z * src1[3].z) + (src0[3].w * src1[3].w);

	dst[0].y = (src0[0].x * src2[0].x) + (src0[0].y * src2[0].y) + (src0[0].z * src2[0].z) + (src0[0].w * src2[0].w);
	dst[1].y = (src0[1].x * src2[1].x) + (src0[1].y * src2[1].y) + (src0[1].z * src2[1].z) + (src0[1].w * src2[1].w);
	dst[2].y = (src0[2].x * src2[2].x) + (src0[2].y * src2[2].y) + (src0[2].z * src2[2].z) + (src0[2].w * src2[2].w);
	dst[3].y = (src0[3].x * src2[3].x) + (src0[3].y * src2[3].y) + (src0[3].z * src2[3].z) + (src0[3].w * src2[3].w);

	dst[0].z = (src0[0].x * src3[0].x) + (src0[0].y * src3[0].y) + (src0[0].z * src3[0].z) + (src0[0].w * src3[0].w);
	dst[1].z = (src0[1].x * src3[1].x) + (src0[1].y * src3[1].y) + (src0[1].z * src3[1].z) + (src0[1].w * src3[1].w);
	dst[2].z = (src0[2].x * src3[2].x) + (src0[2].y * src3[2].y) + (src0[2].z * src3[2].z) + (src0[2].w * src3[2].w);
	dst[3].z = (src0[3].x * src3[3].x) + (src0[3].y * src3[3].y) + (src0[3].z * src3[3].z) + (src0[3].w * src3[3].w);

	dst[0].w = (src0[0].x * src4[0].x) + (src0[0].y * src4[0].y) + (src0[0].z * src4[0].z) + (src0[0].w * src4[0].w);
	dst[1].w = (src0[1].x * src4[1].x) + (src0[1].y * src4[1].y) + (src0[1].z * src4[1].z) + (src0[1].w * src4[1].w);
	dst[2].w = (src0[2].x * src4[2].x) + (src0[2].y * src4[2].y) + (src0[2].z * src4[2].z) + (src0[2].w * src4[2].w);
	dst[3].w = (src0[3].x * src4[3].x) + (src0[3].y * src4[3].y) + (src0[3].z * src4[3].z) + (src0[3].w * src4[3].w);
}

// Multiply-add: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mad---ps
static INTRINSIC_INLINE void mad4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4], const D3DXVECTOR4 (&src2)[4])
{
	dst[0].x = src0[0].x * src1[0].x + src2[0].x;
	dst[1].x = src0[1].x * src1[1].x + src2[1].x;
	dst[2].x = src0[2].x * src1[2].x + src2[2].x;
	dst[3].x = src0[3].x * src1[3].x + src2[3].x;

	dst[0].y = src0[0].y * src1[0].y + src2[0].y;
	dst[1].y = src0[1].y * src1[1].y + src2[1].y;
	dst[2].y = src0[2].y * src1[2].y + src2[2].y;
	dst[3].y = src0[3].y * src1[3].y + src2[3].y;

	dst[0].z = src0[0].z * src1[0].z + src2[0].z;
	dst[1].z = src0[1].z * src1[1].z + src2[1].z;
	dst[2].z = src0[2].z * src1[2].z + src2[2].z;
	dst[3].z = src0[3].z * src1[3].z + src2[3].z;

	dst[0].w = src0[0].w * src1[0].w + src2[0].w;
	dst[1].w = src0[1].w * src1[1].w + src2[1].w;
	dst[2].w = src0[2].w * src1[2].w + src2[2].w;
	dst[3].w = src0[3].w * src1[3].w + src2[3].w;
}

// Maximum: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/max---vs
#undef max
static INTRINSIC_INLINE void max4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	dst[0].x = (src0[0].x >= src1[0].x) ? src0[0].x : src1[0].x;
	dst[1].x = (src0[1].x >= src1[1].x) ? src0[1].x : src1[1].x;
	dst[2].x = (src0[2].x >= src1[2].x) ? src0[2].x : src1[2].x;
	dst[3].x = (src0[3].x >= src1[3].x) ? src0[3].x : src1[3].x;

	dst[0].y = (src0[0].y >= src1[0].y) ? src0[0].y : src1[0].y;
	dst[1].y = (src0[1].y >= src1[1].y) ? src0[1].y : src1[1].y;
	dst[2].y = (src0[2].y >= src1[2].y) ? src0[2].y : src1[2].y;
	dst[3].y = (src0[3].y >= src1[3].y) ? src0[3].y : src1[3].y;

	dst[0].z = (src0[0].z >= src1[0].z) ? src0[0].z : src1[0].z;
	dst[1].z = (src0[1].z >= src1[1].z) ? src0[1].z : src1[1].z;
	dst[2].z = (src0[2].z >= src1[2].z) ? src0[2].z : src1[2].z;
	dst[3].z = (src0[3].z >= src1[3].z) ? src0[3].z : src1[3].z;

	dst[0].w = (src0[0].w >= src1[0].w) ? src0[0].w : src1[0].w;
	dst[1].w = (src0[1].w >= src1[1].w) ? src0[1].w : src1[1].w;
	dst[2].w = (src0[2].w >= src1[2].w) ? src0[2].w : src1[2].w;
	dst[3].w = (src0[3].w >= src1[3].w) ? src0[3].w : src1[3].w;
}

// Minimum: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/min---vs
#undef min
static INTRINSIC_INLINE void min4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	dst[0].x = (src0[0].x < src1[0].x) ? src0[0].x : src1[0].x;
	dst[1].x = (src0[1].x < src1[1].x) ? src0[1].x : src1[1].x;
	dst[2].x = (src0[2].x < src1[2].x) ? src0[2].x : src1[2].x;
	dst[3].x = (src0[3].x < src1[3].x) ? src0[3].x : src1[3].x;

	dst[0].y = (src0[0].y < src1[0].y) ? src0[0].y : src1[0].y;
	dst[1].y = (src0[1].y < src1[1].y) ? src0[1].y : src1[1].y;
	dst[2].y = (src0[2].y < src1[2].y) ? src0[2].y : src1[2].y;
	dst[3].y = (src0[3].y < src1[3].y) ? src0[3].y : src1[3].y;

	dst[0].z = (src0[0].z < src1[0].z) ? src0[0].z : src1[0].z;
	dst[1].z = (src0[1].z < src1[1].z) ? src0[1].z : src1[1].z;
	dst[2].z = (src0[2].z < src1[2].z) ? src0[2].z : src1[2].z;
	dst[3].z = (src0[3].z < src1[3].z) ? src0[3].z : src1[3].z;

	dst[0].w = (src0[0].w < src1[0].w) ? src0[0].w : src1[0].w;
	dst[1].w = (src0[1].w < src1[1].w) ? src0[1].w : src1[1].w;
	dst[2].w = (src0[2].w < src1[2].w) ? src0[2].w : src1[2].w;
	dst[3].w = (src0[3].w < src1[3].w) ? src0[3].w : src1[3].w;
}

// Move (float to float): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mov4(D3DXVECTOR4& dst, const D3DXVECTOR4& src)
{
	dst = src;
}

// Move (float to float): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mov4(int4& dst, const D3DXVECTOR4& src)
{
	dst.x = RoundToNearest(src.x);
	dst.y = RoundToNearest(src.y);
	dst.z = RoundToNearest(src.z);
	dst.w = RoundToNearest(src.w);
}

// Move (float to float): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mova4(int4& dst, const D3DXVECTOR4& src)
{
	dst.x = RoundToNearest(src.x);
	dst.y = RoundToNearest(src.y);
	dst.z = RoundToNearest(src.z);
	dst.w = RoundToNearest(src.w);
}

// Move (float to float): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mov---vs
static INTRINSIC_INLINE void mov4(D3DXVECTOR4& dst, const int4& src)
{
	dst.x = (const float)src.x;
	dst.y = (const float)src.y;
	dst.z = (const float)src.z;
	dst.w = (const float)src.w;
}

// Multiply: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/mul---vs
static INTRINSIC_INLINE void mul4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	dst[0].x = src0[0].x * src1[0].x;
	dst[1].x = src0[1].x * src1[1].x;
	dst[2].x = src0[2].x * src1[2].x;
	dst[3].x = src0[3].x * src1[3].x;

	dst[0].y = src0[0].y * src1[0].y;
	dst[1].y = src0[1].y * src1[1].y;
	dst[2].y = src0[2].y * src1[2].y;
	dst[3].y = src0[3].y * src1[3].y;

	dst[0].z = src0[0].z * src1[0].z;
	dst[1].z = src0[1].z * src1[1].z;
	dst[2].z = src0[2].z * src1[2].z;
	dst[3].z = src0[3].z * src1[3].z;

	dst[0].w = src0[0].w * src1[0].w;
	dst[1].w = src0[1].w * src1[1].w;
	dst[2].w = src0[2].w * src1[2].w;
	dst[3].w = src0[3].w * src1[3].w;
}

// No-op: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/nop---vs
static INTRINSIC_INLINE void nop4()
{
	;
}

// No-op: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/nop---vs
static INTRINSIC_INLINE void nop4(class ShaderEngineBase&)
{
	;
}

// Normalize: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/nrm---vs
static INTRINSIC_INLINE void nrm4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4])
{
	float f4[4] =
	{
		src0[0].x * src0[0].x + src0[0].y * src0[0].y + src0[0].z * src0[0].z,
		src0[1].x * src0[1].x + src0[1].y * src0[1].y + src0[1].z * src0[1].z,
		src0[2].x * src0[2].x + src0[2].y * src0[2].y + src0[2].z * src0[2].z,
		src0[3].x * src0[3].x + src0[3].y * src0[3].y + src0[3].z * src0[3].z
	};

	if (f4[0] != 0.0f)
		f4[0] = 1.0f / sqrtf(f4[0]);
	else
		f4[0] = FLT_MAX;

	if (f4[1] != 0.0f)
		f4[1] = 1.0f / sqrtf(f4[1]);
	else
		f4[1] = FLT_MAX;

	if (f4[2] != 0.0f)
		f4[2] = 1.0f / sqrtf(f4[2]);
	else
		f4[2] = FLT_MAX;

	if (f4[3] != 0.0f)
		f4[3] = 1.0f / sqrtf(f4[3]);
	else
		f4[3] = FLT_MAX;

	dst[0].x = src0[0].x * f4[0];
	dst[1].x = src0[1].x * f4[1];
	dst[2].x = src0[2].x * f4[2];
	dst[3].x = src0[3].x * f4[3];

	dst[0].y = src0[0].y * f4[0];
	dst[1].y = src0[1].y * f4[1];
	dst[2].y = src0[2].y * f4[2];
	dst[3].y = src0[3].y * f4[3];

	dst[0].z = src0[0].z * f4[0];
	dst[1].z = src0[1].z * f4[1];
	dst[2].z = src0[2].z * f4[2];
	dst[3].z = src0[3].z * f4[3];

	dst[0].w = src0[0].w * f4[0];
	dst[1].w = src0[1].w * f4[1];
	dst[2].w = src0[2].w * f4[2];
	dst[3].w = src0[3].w * f4[3];
}

// Normalize (xyz only): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/nrm---vs
static INTRINSIC_INLINE void nrm_xyz4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4])
{
	float f4[4] =
	{
		src0[0].x * src0[0].x + src0[0].y * src0[0].y + src0[0].z * src0[0].z,
		src0[1].x * src0[1].x + src0[1].y * src0[1].y + src0[1].z * src0[1].z,
		src0[2].x * src0[2].x + src0[2].y * src0[2].y + src0[2].z * src0[2].z,
		src0[3].x * src0[3].x + src0[3].y * src0[3].y + src0[3].z * src0[3].z
	};

	if (f4[0] != 0.0f)
		f4[0] = 1.0f / sqrtf(f4[0]);
	else
		f4[0] = FLT_MAX;

	if (f4[1] != 0.0f)
		f4[1] = 1.0f / sqrtf(f4[1]);
	else
		f4[1] = FLT_MAX;

	if (f4[2] != 0.0f)
		f4[2] = 1.0f / sqrtf(f4[2]);
	else
		f4[2] = FLT_MAX;

	if (f4[3] != 0.0f)
		f4[3] = 1.0f / sqrtf(f4[3]);
	else
		f4[3] = FLT_MAX;

	dst[0].x = src0[0].x * f4[0];
	dst[1].x = src0[1].x * f4[1];
	dst[2].x = src0[2].x * f4[2];
	dst[3].x = src0[3].x * f4[3];

	dst[0].y = src0[0].y * f4[0];
	dst[1].y = src0[1].y * f4[1];
	dst[2].y = src0[2].y * f4[2];
	dst[3].y = src0[3].y * f4[3];

	dst[0].z = src0[0].z * f4[0];
	dst[1].z = src0[1].z * f4[1];
	dst[2].z = src0[2].z * f4[2];
	dst[3].z = src0[3].z * f4[3];

	// Don't modify the W component in this version of the function
}

// Power (15 minimum bits of precision): https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/pow---vs
static INTRINSIC_INLINE void pow4(D3DXVECTOR4 (&dst)[4], const float (&src0)[4], const float (&src1)[4])
{
	const float absVec[4] = 
	{
		fabsf(src0[0]),
		fabsf(src0[1]),
		fabsf(src0[2]),
		fabsf(src0[3])
	};

	dst[0].x = dst[0].y = dst[0].z = dst[0].w = powf(absVec[0], src1[0]);
	dst[1].x = dst[1].y = dst[1].z = dst[1].w = powf(absVec[1], src1[1]);
	dst[2].x = dst[2].y = dst[2].z = dst[2].w = powf(absVec[2], src1[2]);
	dst[3].x = dst[3].y = dst[3].z = dst[3].w = powf(absVec[3], src1[3]);
}

// Return from function or return from shader program: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/ret---ps
static INTRINSIC_INLINE void ret4(void)
{
	return;
}

// Reciprocal: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/rcp---vs
static INTRINSIC_INLINE void rcp4(D3DXVECTOR4 (&dst)[4], const float (&src)[4])
{
	float f4[4] = 
	{
		src[0],
		src[1],
		src[2],
		src[3]
	};

	f4[0] = f4[0] == 0.0f ? FLT_MAX : 1.0f / f4[0];
	f4[1] = f4[1] == 0.0f ? FLT_MAX : 1.0f / f4[1];
	f4[2] = f4[2] == 0.0f ? FLT_MAX : 1.0f / f4[2];
	f4[3] = f4[3] == 0.0f ? FLT_MAX : 1.0f / f4[3];

	dst[0].x = dst[0].y = dst[0].z = dst[0].w = f4[0];
	dst[1].x = dst[1].y = dst[1].z = dst[1].w = f4[1];
	dst[2].x = dst[2].y = dst[2].z = dst[2].w = f4[2];
	dst[3].x = dst[3].y = dst[3].z = dst[3].w = f4[3];
}

// Reciprocal square-root: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/rsq---vs
static INTRINSIC_INLINE void rsq4(D3DXVECTOR4 (&dst)[4], const float (&src)[4])
{
	float f4[4] = 
	{
		src[0],
		src[1],
		src[2],
		src[3]
	};

	if (f4[0] == 0.0f)
		f4[0] = FLT_MAX;
	else
	{
		f4[0] = fabsf(f4[0]);
		if (f4[0] != 1.0f)
			f4[0] = 1.0f / (float)sqrtf(f4[0]);
	}

	if (f4[1] == 0.0f)
		f4[1] = FLT_MAX;
	else
	{
		f4[1] = fabsf(f4[1]);
		if (f4[1] != 1.0f)
			f4[1] = 1.0f / (float)sqrtf(f4[1]);
	}

	if (f4[2] == 0.0f)
		f4[2] = FLT_MAX;
	else
	{
		f4[2] = fabsf(f4[2]);
		if (f4[2] != 1.0f)
			f4[2] = 1.0f / (float)sqrtf(f4[2]);
	}

	if (f4[3] == 0.0f)
		f4[3] = FLT_MAX;
	else
	{
		f4[3] = fabsf(f4[3]);
		if (f4[3] != 1.0f)
			f4[3] = 1.0f / (float)sqrtf(f4[3]);
	}

	dst[0].x = dst[0].y = dst[0].z = dst[0].w = f4[0];
	dst[1].x = dst[1].y = dst[1].z = dst[1].w = f4[1];
	dst[2].x = dst[2].y = dst[2].z = dst[2].w = f4[2];
	dst[3].x = dst[3].y = dst[3].z = dst[3].w = f4[3];
}

// Sine/cosine: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sincos---vs
static INTRINSIC_INLINE void sincos_c4(D3DXVECTOR4 (&dst)[4], const float (&src)[4])
{
	dst[0].x = cosf(src[0]);
	dst[1].x = cosf(src[1]);
	dst[2].x = cosf(src[2]);
	dst[3].x = cosf(src[3]);
}

// Sine/cosine: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sincos---vs
static INTRINSIC_INLINE void sincos_s4(D3DXVECTOR4 (&dst)[4], const float (&src)[4])
{
	dst[0].y = sinf(src[0]);
	dst[1].y = sinf(src[1]);
	dst[2].y = sinf(src[2]);
	dst[3].y = sinf(src[3]);
}

// Sine/cosine: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sincos---vs
static INTRINSIC_INLINE void sincos_sc4(D3DXVECTOR4 (&dst)[4], const float (&src)[4])
{
	dst[0].x = cosf(src[0]);
	dst[1].x = cosf(src[1]);
	dst[2].x = cosf(src[2]);
	dst[3].x = cosf(src[3]);

	dst[0].y = sinf(src[0]);
	dst[1].y = sinf(src[1]);
	dst[2].y = sinf(src[2]);
	dst[3].y = sinf(src[3]);
}

// Signed Greater-than or Equal to: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sge---vs
static INTRINSIC_INLINE void sge4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	dst[0].x = (src0[0].x >= src1[0].x) ? 1.0f : 0.0f;
	dst[1].x = (src0[1].x >= src1[1].x) ? 1.0f : 0.0f;
	dst[2].x = (src0[2].x >= src1[2].x) ? 1.0f : 0.0f;
	dst[3].x = (src0[3].x >= src1[3].x) ? 1.0f : 0.0f;

	dst[0].y = (src0[0].y >= src1[0].y) ? 1.0f : 0.0f;
	dst[1].y = (src0[1].y >= src1[1].y) ? 1.0f : 0.0f;
	dst[2].y = (src0[2].y >= src1[2].y) ? 1.0f : 0.0f;
	dst[3].y = (src0[3].y >= src1[3].y) ? 1.0f : 0.0f;

	dst[0].z = (src0[0].z >= src1[0].z) ? 1.0f : 0.0f;
	dst[1].z = (src0[1].z >= src1[1].z) ? 1.0f : 0.0f;
	dst[2].z = (src0[2].z >= src1[2].z) ? 1.0f : 0.0f;
	dst[3].z = (src0[3].z >= src1[3].z) ? 1.0f : 0.0f;

	dst[0].w = (src0[0].w >= src1[0].w) ? 1.0f : 0.0f;
	dst[1].w = (src0[1].w >= src1[1].w) ? 1.0f : 0.0f;
	dst[2].w = (src0[2].w >= src1[2].w) ? 1.0f : 0.0f;
	dst[3].w = (src0[3].w >= src1[3].w) ? 1.0f : 0.0f;
}

// Sign determination function: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sgn---vs
static INTRINSIC_INLINE void sgn4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1_unused)[4], const D3DXVECTOR4 (&src2_unused)[4])
{
	UNREFERENCED_PARAMETER(src1_unused);
	UNREFERENCED_PARAMETER(src2_unused);

	dst[0].x = src0[0].x < 0 ? -1.0f : src0[0].x == 0.0f ? 0.0f : 1.0f;
	dst[1].x = src0[1].x < 0 ? -1.0f : src0[1].x == 0.0f ? 0.0f : 1.0f;
	dst[2].x = src0[2].x < 0 ? -1.0f : src0[2].x == 0.0f ? 0.0f : 1.0f;
	dst[3].x = src0[3].x < 0 ? -1.0f : src0[3].x == 0.0f ? 0.0f : 1.0f;

	dst[0].y = src0[0].y < 0 ? -1.0f : src0[0].y == 0.0f ? 0.0f : 1.0f;
	dst[1].y = src0[1].y < 0 ? -1.0f : src0[1].y == 0.0f ? 0.0f : 1.0f;
	dst[2].y = src0[2].y < 0 ? -1.0f : src0[2].y == 0.0f ? 0.0f : 1.0f;
	dst[3].y = src0[3].y < 0 ? -1.0f : src0[3].y == 0.0f ? 0.0f : 1.0f;

	dst[0].z = src0[0].z < 0 ? -1.0f : src0[0].z == 0.0f ? 0.0f : 1.0f;
	dst[1].z = src0[1].z < 0 ? -1.0f : src0[1].z == 0.0f ? 0.0f : 1.0f;
	dst[2].z = src0[2].z < 0 ? -1.0f : src0[2].z == 0.0f ? 0.0f : 1.0f;
	dst[3].z = src0[3].z < 0 ? -1.0f : src0[3].z == 0.0f ? 0.0f : 1.0f;

	dst[0].w = src0[0].w < 0 ? -1.0f : src0[0].w == 0.0f ? 0.0f : 1.0f;
	dst[1].w = src0[1].w < 0 ? -1.0f : src0[1].w == 0.0f ? 0.0f : 1.0f;
	dst[2].w = src0[2].w < 0 ? -1.0f : src0[2].w == 0.0f ? 0.0f : 1.0f;
	dst[3].w = src0[3].w < 0 ? -1.0f : src0[3].w == 0.0f ? 0.0f : 1.0f;
}

// Signed Less-than: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/slt---vs
static INTRINSIC_INLINE void slt4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	dst[0].x = (src0[0].x < src1[0].x) ? 1.0f : 0.0f;
	dst[1].x = (src0[1].x < src1[1].x) ? 1.0f : 0.0f;
	dst[2].x = (src0[2].x < src1[2].x) ? 1.0f : 0.0f;
	dst[3].x = (src0[3].x < src1[3].x) ? 1.0f : 0.0f;

	dst[0].y = (src0[0].y < src1[0].y) ? 1.0f : 0.0f;
	dst[1].y = (src0[1].y < src1[1].y) ? 1.0f : 0.0f;
	dst[2].y = (src0[2].y < src1[2].y) ? 1.0f : 0.0f;
	dst[3].y = (src0[3].y < src1[3].y) ? 1.0f : 0.0f;

	dst[0].z = (src0[0].z < src1[0].z) ? 1.0f : 0.0f;
	dst[1].z = (src0[1].z < src1[1].z) ? 1.0f : 0.0f;
	dst[2].z = (src0[2].z < src1[2].z) ? 1.0f : 0.0f;
	dst[3].z = (src0[3].z < src1[3].z) ? 1.0f : 0.0f;

	dst[0].w = (src0[0].w < src1[0].w) ? 1.0f : 0.0f;
	dst[1].w = (src0[1].w < src1[1].w) ? 1.0f : 0.0f;
	dst[2].w = (src0[2].w < src1[2].w) ? 1.0f : 0.0f;
	dst[3].w = (src0[3].w < src1[3].w) ? 1.0f : 0.0f;
}

// Subtract: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sub---vs
static INTRINSIC_INLINE void sub4(D3DXVECTOR4 (&dst)[4], const D3DXVECTOR4 (&src0)[4], const D3DXVECTOR4 (&src1)[4])
{
	dst[0].x = src0[0].x - src1[0].x;
	dst[1].x = src0[1].x - src1[1].x;
	dst[2].x = src0[2].x - src1[2].x;
	dst[3].x = src0[3].x - src1[3].x;

	dst[0].y = src0[0].y - src1[0].y;
	dst[1].y = src0[1].y - src1[1].y;
	dst[2].y = src0[2].y - src1[2].y;
	dst[3].y = src0[3].y - src1[3].y;

	dst[0].z = src0[0].z - src1[0].z;
	dst[1].z = src0[1].z - src1[1].z;
	dst[2].z = src0[2].z - src1[2].z;
	dst[3].z = src0[3].z - src1[3].z;

	dst[0].w = src0[0].w - src1[0].w;
	dst[1].w = src0[1].w - src1[1].w;
	dst[2].w = src0[2].w - src1[2].w;
	dst[3].w = src0[3].w - src1[3].w;
}

// Texture sample functions (tex2D, tex2Dgrad, tex2Dlod):
template <const unsigned char writeMask>
void __cdecl tex2Dmip0_4(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);

template <const unsigned char writeMask>
void __cdecl tex2Dlod4(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);

template <const unsigned char writeMask, const bool useTexCoordMipBias>
void __cdecl tex2Dgrad4(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);

```

`Software_d3d9/ShaderJIT.cpp`:

```cpp
#pragma once

#include "ShaderJIT.h"
#include "IDirect3DDevice9Hook.h"
#include "resource.h"

extern HINSTANCE hLThisDLL;

#pragma warning(push)
#pragma warning(disable:4996)

void LoadPrefixFileInternal(std::vector<char>& cppfile)
{
#pragma warning(push)
#pragma warning(disable:4302) // warning C4302: 'type cast': truncation from 'LPSTR' to 'WORD'
	HRSRC cppResource = FindResourceA(hLThisDLL, MAKEINTRESOURCEA(IDR_CPP1), "CPP");
#pragma warning(pop)
	if (cppResource)
	{
		HGLOBAL loadedResource = LoadResource(hLThisDLL, cppResource);
		if (loadedResource)
		{
			const unsigned resourceSize = SizeofResource(hLThisDLL, cppResource);
			if (resourceSize > 0)
			{
				const void* const resourceBytes = LockResource(loadedResource);
				if (resourceBytes)
				{
					cppfile.resize(resourceSize);
					memcpy(&cppfile.front(), resourceBytes, resourceSize);
					return;
				}
			}
		}
	}

	__debugbreak(); // Should never be here!
}

// Not multithread-safe!
const char* const ConstructShaderJITName(const ShaderInfo& shaderInfo)
{
	static char buffer[MAX_PATH] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
	// Looks like: "ps_3_0_len114_hash0xD9FF5963d"
	sprintf(buffer, "%cs_%u_%u_len%u_hash0x%08X%c", shaderInfo.isPixelShader ? 'p' : 'v', shaderInfo.shaderMajorVersion, shaderInfo.shaderMinorVersion, shaderInfo.shaderLengthDWORDs, shaderInfo.shaderBytecodeHash, 
#ifdef _DEBUG
		'd'
#else
		'r'
#endif
		);
#pragma warning(pop)
	return buffer;
}

static inline const bool JITBATFile(const ShaderInfo& shaderInfo, const char* const shaderFilename)
{
	char batfilename[MAX_PATH] = {0};
	// Looks like: "shaderjit\ps_3_0_len114_hash0xD9FF5963d.bat"
	sprintf(batfilename, "%s\\%s.bat", shaderJITTempDirectory, shaderFilename);
	HANDLE hBatFile = CreateFileA(batfilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hBatFile == INVALID_HANDLE_VALUE)
	{
		DbgBreakPrint("Error in CreateFile");
		return false;
	}

	static std::vector<char> batfile;

	batfile.clear();

#ifdef _DEBUG
	static const char* const compileDefines = "/D \"WIN32\""
	" /D \"_DEBUG\""
	" /D \"_WINDOWS\""
	" /D \"_USRDLL\""
	" /D \"_WINDLL\"";
#else // Release
	static const char* const compileDefines = "/D \"WIN32\""
	" /D \"NDEBUG\""
	" /D \"_WINDOWS\""
	" /D \"_USRDLL\""
	" /D \"_WINDLL\"";
#endif // #ifdef _DEBUG

	// TODO: Don't hardcode these paths...
#ifdef _DEBUG
	static const char* const compileString = "cl.exe /c /I \"C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Include\" /FAcs /Fa /analyze- /W3 /Zc:wchar_t /ZI /Od /fp:precise /WX- /Zc:forScope /RTC1 /Gd /Oy- /MDd /EHsc /nologo /GS %s %s.cpp\r\n";
#else // Release
	static const char* const compileString = "cl.exe /c /I \"C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Include\" /FAcs /Fa /analyze- /W3 /Zc:wchar_t /Zi /GS- /GL /Gy /Gm- /O2 /Ob2 /fp:fast /GF /WX- /Zc:forScope /arch:AVX2 /Gd /Oy- /Oi /MT /Ot %s %s.cpp\r\n";
#endif // #ifdef _DEBUG

#ifdef _M_X64
	#define LIBPATH "/LIBPATH:\"C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Lib\\x64\""
#else
	#define LIBPATH "/LIBPATH:\"C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Lib\\x86\""
#endif

#ifdef _M_X64
	#define MACHINE_PLATFORM "/MACHINE:X64"
	#define SAFESEH_FLAG "" // SafeSEH is not supported on x64
#else
	#define MACHINE_PLATFORM "/MACHINE:X86"
	#define SAFESEH_FLAG "/SAFESEH"
#endif

	// TODO: Don't hardcode these paths...
#ifdef _DEBUG
	static const char* const linkString = "link.exe " LIBPATH " /DEBUG /DLL " MACHINE_PLATFORM " /SUBSYSTEM:WINDOWS /NOLOGO /NXCOMPAT %s.obj\r\n";
#else // Release
	static const char* const linkString = "link.exe " LIBPATH " /DEBUG /DLL " MACHINE_PLATFORM " /SUBSYSTEM:WINDOWS /NODEFAULTLIB /ENTRY:DllMain /NOLOGO /NXCOMPAT /LTCG /DLL /DYNAMICBASE \"Kernel32.lib\" \"libucrt.lib\" /OPT:REF " SAFESEH_FLAG " /INCREMENTAL:NO /OPT:ICF %s.obj\r\n";
#endif // #ifdef _DEBUG

	// Set up VS command prompt
	{
		// TODO: Don't hardcode this path...
#ifdef _M_X64
		static const char* const invokeVSDevCmd = "call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\VC\\Auxiliary\\Build\\vcvars64.bat\"\r\n";
#else
		static const char* const invokeVSDevCmd = "call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\Common7\\Tools\\VsDevCmd.bat\"\r\n";
#endif
		AppendString(batfile, invokeVSDevCmd);
	}

	// Compile
	{
		char batBuffer[1024] = {0};
		sprintf(batBuffer, compileString, compileDefines, shaderFilename);
		AppendString(batfile, batBuffer);
	}

	// Link
	{
		char batBuffer[1024] = {0};
		sprintf(batBuffer, linkString, shaderFilename);
		AppendString(batfile, batBuffer);
	}

	DWORD numBytesWritten = 0;
	if (!WriteFile(hBatFile, &(batfile.front() ), batfile.size(), &numBytesWritten, NULL) )
	{
		DbgBreakPrint("Error in WriteFile");
		return false;
	}

	if (batfile.size() != numBytesWritten)
	{
		DbgBreakPrint("Error: Num bytes written doesn't match for bat file");
		return false;
	}

	if (!CloseHandle(hBatFile) )
	{
		DbgBreakPrint("Error in CloseHandle");
		return false;
	}

	return true;
}

static inline const bool CompileLinkDLL(const ShaderInfo& shaderInfo, const char* const shaderFilename)
{
	char batfilename[MAX_PATH] = {0};
	// Looks like: "ps_3_0_len114_hash0xD9FF5963d.bat"
	sprintf(batfilename, "%s.bat", shaderFilename);

	char commandLine[MAX_PATH] = {0};
	sprintf(commandLine, "cmd.exe /C \"%s\"", batfilename);

	STARTUPINFOA si = {0};
	si.cb = sizeof(STARTUPINFOA);
	PROCESS_INFORMATION pi = {0};

	char currentDirectory[MAX_PATH] = {0};
	sprintf(currentDirectory, ".\\%s\\", shaderJITTempDirectory);

	// Either show the shadercompile window (default), or hide it
	const DWORD createProcessFlags = 
#ifdef DEBUG_SHOW_SHADERCOMPILE_WINDOW
		0x00000000
#else
		CREATE_NO_WINDOW
#endif
		;

	if (!CreateProcessA(NULL, commandLine, NULL, NULL, FALSE, createProcessFlags, NULL, currentDirectory, &si, &pi) )
	{
		DbgBreakPrint("Error in CreateProcess");
		return false;
	}

	WaitForSingleObject(pi.hProcess, INFINITE);
	DWORD processExitCode = STILL_ACTIVE;
	if (!GetExitCodeProcess(pi.hProcess, &processExitCode) )
	{
		DbgBreakPrint("Error in GetExitCodeProcess");
		return false;
	}

	if (processExitCode == STILL_ACTIVE)
	{
		DbgBreakPrint("Error: Process did not terminate yet");
		return false;
	}

	if (processExitCode == S_OK)
	{
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		return true;
	}

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	DbgBreakPrint("Error: There was an error while compiling or linking the shader JIT DLL");
	OutputDebugStringA("Failure in shader JIT for shader: ");
	OutputDebugStringA(shaderFilename);
	OutputDebugStringA("\n");

	return false;
}

const bool JITNewShader(const ShaderInfo& shaderInfo, const char* const shaderFilename)
{
	if (!CreateDirectoryA(shaderJITTempDirectory, NULL) )
	{
		switch (GetLastError() )
		{
		case ERROR_ALREADY_EXISTS:
			// This is fine
			break;
		case ERROR_PATH_NOT_FOUND:
			// This is not fine!
			DbgBreakPrint("Error in CreateDirectory");
			return false;
		}
	}

	if (!JITCPPFileInternal(shaderInfo, shaderFilename) )
	{
		return false;
	}

	if (!JITBATFile(shaderInfo, shaderFilename) )
	{
		return false;
	}

	if (!CompileLinkDLL(shaderInfo, shaderFilename) )
	{
		return false;
	}

	return true;
}

#pragma warning(pop)

```

`Software_d3d9/ShaderJIT.h`:

```h
#pragma once

#include "ShaderAnalysis.h"

static const char* const shaderEntrypointName = "ShaderMain";
static const char* const shaderJITTempDirectory = 
#ifdef _DEBUG
	"shaderjitd";
#else
	"shaderjit";
#endif

// Not multithread-safe!
const char* const ConstructShaderJITName(const ShaderInfo& shaderInfo);

const bool JITNewShader(const ShaderInfo& shaderInfo, const char* const shaderFilename);

static inline void AppendString(std::vector<char>& cppfile, const char* const str)
{
	const unsigned len = strlen(str);

	for (unsigned x = 0; x < len; ++x)
		cppfile.push_back(str[x]);
}

// Internal functions, do not call:
void LoadPrefixFileInternal(std::vector<char>& cppfile);
const bool JITCPPFileInternal(const ShaderInfo& shaderInfo, const char* const shaderFilename);

```

`Software_d3d9/ShaderJIT_HLSL_to_CPP.cpp`:

```cpp
#pragma once

#include "ShaderJIT.h"
#include "IDirect3DDevice9Hook.h"
#include "ShaderJIT_HLSL_to_CPP_Tables.h"

#pragma warning(push)
#pragma warning(disable:4996) // We use sprintf a lot in this file and don't want to keep having to manually escape every call-site, so this whole file is 4996-disabled

static const unsigned NumSourceParams[customOpcode + 1] = 
{
	0, // justOpcode,
	1, // srcOnly,
	2, // srcSrcOnly,
	0, // dstOnly,
	1, // srcDst,
	2, // srcSrcDst,
	3, // srcSrcSrcDst,
	4, // srcSrcSrcSrcDst,
	0, // customOpcode
};

template <typename T>
static inline const bool IsConstantGlobal(const unsigned constIndex, const std::vector<T>& immediateRegisters)
{
	const unsigned numImmediateRegs = immediateRegisters.size();
	for (unsigned x = 0; x < numImmediateRegs; ++x)
	{
		const InitialConstantValueBase& constValue = immediateRegisters[x];
		if (constValue.constantRegisterIndex == constIndex)
			return false;
	}

	return true;
}

static inline const unsigned GetNumSourceParams(const opcodeDisplayType opcodeType)
{
	return NumSourceParams[opcodeType];
}

static inline const bool GetOpcodeAllowChannelSplitting(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode)
{
	if (opcode <= D3DSIO_BREAKP)
		return opcodeAllowChannelSplitting[opcode];
	else
		return false;
}

static inline const bool GetOpcodeAllChannelsBroadcastSameVal(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode)
{
	if (opcode <= D3DSIO_BREAKP)
		return opcodeAllChannelsBroadcastSameVal[opcode];
	else
		return false;
}

static inline const bool GetOpcodeImplementedForJIT(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode)
{
	if (opcode <= D3DSIO_BREAKP)
		return opcodeImplementedForJIT[opcode];
	else
		switch (opcode)
		{
		default:
#ifdef _DEBUG
		{
			__debugbreak(); // Invalid opcode detected
		}
#endif
			return false;
		case D3DSIO_PHASE:
		case D3DSIO_COMMENT:
		case D3DSIO_END:
			return true;
		}
}

static const inline bool NeedTempDestCopy(const dstParameterToken& dst, const srcParameterToken& src)
{
	if (dst.GetRegisterType() == src.GetRegisterType() )
	{
		return dst.GetRegisterIndex() == src.GetRegisterIndex();
	}

	return false;
}

static const inline bool NeedTempDestCopy(const dstParameterToken& dst, const srcParameterToken& src0, const srcParameterToken& src1)
{
	return NeedTempDestCopy(dst, src0) || NeedTempDestCopy(dst, src1);
}

static const inline bool NeedTempDestCopy(const dstParameterToken& dst, const srcParameterToken& src0, const srcParameterToken& src1, const srcParameterToken& src2)
{
	return NeedTempDestCopy(dst, src0, src1) || NeedTempDestCopy(dst, src2);
}

static const inline bool NeedTempDestCopy(const dstParameterToken& dst, const srcParameterToken& src0, const srcParameterToken& src1, const srcParameterToken& src2, const srcParameterToken& src3)
{
	return NeedTempDestCopy(dst, src0, src1, src2) || NeedTempDestCopy(dst, src3);
}

// This function *does not* advance the shader bytecode stream!
static inline void ResolveSrcParameterDisasm(const ShaderInfo& shaderInfo, const DWORD* bytecode, std::vector<char>& disasmline)
{
	const srcParameterToken& srcParameter = *(const srcParameterToken* const)bytecode;

	const D3DSHADER_PARAM_SRCMOD_TYPE sourceMod = srcParameter.GetSourceModifiersUnshifted();
	switch (sourceMod)
	{
	case D3DSPSM_NONE   :
	case D3DSPSM_BIAS   :
	case D3DSPSM_SIGN   :
	case D3DSPSM_COMP   :
	case D3DSPSM_X2     :
	case D3DSPSM_DW     :
	case D3DSPSM_DZ     :
		break;
	case D3DSPSM_NEG    :
	case D3DSPSM_BIASNEG:
	case D3DSPSM_SIGNNEG:
	case D3DSPSM_X2NEG  :
		AppendString(disasmline, "-");
		break;
	case D3DSPSM_ABS    :
		AppendString(disasmline, "abs(");
		break;
	case D3DSPSM_ABSNEG :
		AppendString(disasmline, "-abs(");
		break;
	case D3DSPSM_NOT    :
		AppendString(disasmline, "!");
		break;
	default:
		DbgBreakPrint("Error: Unknown source modifier");
		break;
	}

	unsigned index = srcParameter.GetRegisterIndex();

	const D3DSHADER_PARAM_REGISTER_TYPE registerType = srcParameter.GetRegisterType();
	switch (registerType)
	{
	case D3DSPR_TEMP       :
		AppendString(disasmline, "r");
		break;
	case D3DSPR_INPUT      :
		AppendString(disasmline, "v");
		break;
	case D3DSPR_CONST      :
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
		AppendString(disasmline, "c");
		break;
	case D3DSPR_ADDR       : // Also known as D3DSPR_TEXTURE (PS)
		if (shaderInfo.isPixelShader)
		{
			if (shaderInfo.shaderMajorVersion == 3)
				AppendString(disasmline, "v"); // Texcoord
			else
				AppendString(disasmline, "t"); // Texcoord
		}
		else
		{
			AppendString(disasmline, "a"); // Address
		}
		break;
	case D3DSPR_RASTOUT    :
		switch (index)
		{
		default:
			DbgBreakPrint("Error: Unknown RASTOUT register index");
		case D3DSRO_POSITION:
			AppendString(disasmline, "oPos");
			break;
		case D3DSRO_FOG:
			AppendString(disasmline, "oFog");
			break;
		case D3DSRO_POINT_SIZE:
			AppendString(disasmline, "oPts");
			break;
		}
		break;
	case D3DSPR_ATTROUT    :
		AppendString(disasmline, "oD");
		break;
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
		AppendString(disasmline, "oT");
		break;
	case D3DSPR_CONSTINT   :
		AppendString(disasmline, "i");
		break;
	case D3DSPR_COLOROUT   :
		AppendString(disasmline, "oC");
		break;
	case D3DSPR_DEPTHOUT   :
		AppendString(disasmline, "oDepth");
		break;
	case D3DSPR_SAMPLER    :
		AppendString(disasmline, "s");
		break;
	case D3DSPR_CONSTBOOL  :
		AppendString(disasmline, "b");
		break;
	case D3DSPR_LOOP       :
		AppendString(disasmline, "aL");
		break;
	case D3DSPR_TEMPFLOAT16:
		AppendString(disasmline, "r");
		break;
	case D3DSPR_MISCTYPE   :
		switch (index)
		{
		default:
			DbgBreakPrint("Unknown MISCTYPE register");
		case D3DSMO_POSITION:
			AppendString(disasmline, "VPOS");
			break;
		case D3DSMO_FACE:
			AppendString(disasmline, "VFACE");
			break;
		}
		break;
	case D3DSPR_LABEL      :
		AppendString(disasmline, "LABEL");
		break;
	case D3DSPR_PREDICATE  :
		AppendString(disasmline, "p");
		break;
	default:
#ifdef _DEBUG
		{
			DbgBreakPrint("Error: Unknown shader register");
		}
#endif
		break;
	}

	// Print register index:
	switch (registerType)
	{
	case D3DSPR_CONST      :
		break;
	case D3DSPR_CONST2     :
		index += 2048;
		break;
	case D3DSPR_CONST3     :
		index += 4096;
		break;
	case D3DSPR_CONST4     :
		index += 6144;
		break;
	default:
		break;
	}
	char shaderIndexBuffer[16] = {0};
	sprintf(shaderIndexBuffer, "%u", index);
	AppendString(disasmline, shaderIndexBuffer);

	switch (sourceMod)
	{
	default:
	case D3DSPSM_NONE   :
	case D3DSPSM_NOT    :
	case D3DSPSM_NEG    :
		break;
	case D3DSPSM_BIAS   :
	case D3DSPSM_BIASNEG:
		AppendString(disasmline, "_bias");
		break;
	case D3DSPSM_SIGN   :
	case D3DSPSM_SIGNNEG:
		AppendString(disasmline, "_bx2");
		break;
	case D3DSPSM_COMP   :
		AppendString(disasmline, "_complement");
		break;
	case D3DSPSM_X2     :
	case D3DSPSM_X2NEG  :
		AppendString(disasmline, "_x2");
		break;
	case D3DSPSM_DZ     :
		AppendString(disasmline, "_dz");
		break;
	case D3DSPSM_DW     :
		AppendString(disasmline, "_dw");
		break;
	case D3DSPSM_ABS    :
	case D3DSPSM_ABSNEG :
		AppendString(disasmline, ")");
		break;
	}

	if (srcParameter.GetRelativeAddressingType() == D3DSHADER_ADDRMODE_RELATIVE)
	{
		DbgBreakPrint("Relative addressing not yet implemented!");

		// Super important to do this, otherwise the bytecode stream gets broken!
		++bytecode;
	}

	const unsigned channelSwizzle = srcParameter.GetChannelSwizzleXYZW();
	switch (channelSwizzle)
	{
	case D3DVS_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT: // .xyzw
		break; // Don't print .xyzw all the time
	case D3DSP_REPLICATERED >> D3DVS_SWIZZLE_SHIFT: // .x
		AppendString(disasmline, ".x");
		break;
	case D3DSP_REPLICATEGREEN >> D3DVS_SWIZZLE_SHIFT: // .y
		AppendString(disasmline, ".y");
		break;
	case D3DSP_REPLICATEBLUE >> D3DVS_SWIZZLE_SHIFT: // .z
		AppendString(disasmline, ".z");
		break;
	case D3DSP_REPLICATEALPHA >> D3DVS_SWIZZLE_SHIFT: // .w
		AppendString(disasmline, ".w");
		break;
	default:
	{
		static const char* const channelName[4] =
		{
			"x",
			"y",
			"z",
			"w"
		};

		char sourceSwizzleBuffer[8] = {0};
		sprintf(sourceSwizzleBuffer, ".%s", channelName[channelSwizzle & 0x3]);
		AppendString(disasmline, sourceSwizzleBuffer);
		sprintf(sourceSwizzleBuffer, "%s", channelName[(channelSwizzle >> 2) & 0x3]);
		AppendString(disasmline, sourceSwizzleBuffer);
		sprintf(sourceSwizzleBuffer, "%s", channelName[(channelSwizzle >> 4) & 0x3]);
		AppendString(disasmline, sourceSwizzleBuffer);
		sprintf(sourceSwizzleBuffer, "%s", channelName[(channelSwizzle >> 6) & 0x3]);
		AppendString(disasmline, sourceSwizzleBuffer);
	}
		break;
	}

	// Super important to advance the bytecode stream
	++bytecode;
}

// This function *does* advance the global shader bytecode stream
static inline void ResolveSrcParameterSimpleSwizzleNoSourceMods(const ShaderInfo& shaderInfo, const DWORD*& bytecode, std::vector<char>& jitline)
{
	const srcParameterToken& srcParameter = *(const srcParameterToken* const)bytecode;

	const D3DSHADER_PARAM_SRCMOD_TYPE sourceMod = srcParameter.GetSourceModifiersUnshifted();
	switch (sourceMod)
	{
	case D3DSPSM_NONE   :
		break;
	default:
		DbgBreakPrint("Error: Function cannot handle source modifiers");
		break;
	}

	unsigned index = srcParameter.GetRegisterIndex();

	const D3DSHADER_PARAM_REGISTER_TYPE registerType = srcParameter.GetRegisterType();
	switch (registerType)
	{
	case D3DSPR_TEMP       :
		AppendString(jitline, "r");
		break;
	case D3DSPR_INPUT      :
		AppendString(jitline, "v");
		break;
	case D3DSPR_CONST      :
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
		AppendString(jitline, "c");
		break;
	case D3DSPR_ADDR       : // Also known as D3DSPR_TEXTURE (PS)
		if (shaderInfo.isPixelShader)
		{
			if (shaderInfo.shaderMajorVersion == 3)
				AppendString(jitline, "v"); // Texcoord
			else
				AppendString(jitline, "t"); // Texcoord
		}
		else
		{
			AppendString(jitline, "a"); // Address
		}
		break;
	case D3DSPR_RASTOUT    :
		switch (index)
		{
		default:
			DbgBreakPrint("Error: Unknown RASTOUT register index");
		case D3DSRO_POSITION:
			AppendString(jitline, "oPos");
			break;
		case D3DSRO_FOG:
			AppendString(jitline, "oFog");
			break;
		case D3DSRO_POINT_SIZE:
			AppendString(jitline, "oPts");
			break;
		}
		break;
	case D3DSPR_ATTROUT    :
		AppendString(jitline, "oD");
		break;
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
		AppendString(jitline, "oT");
		break;
	case D3DSPR_CONSTINT   :
		AppendString(jitline, "i");
		break;
	case D3DSPR_COLOROUT   :
		AppendString(jitline, "oC");
		break;
	case D3DSPR_DEPTHOUT   :
		AppendString(jitline, "oDepth");
		break;
	case D3DSPR_SAMPLER    :
		AppendString(jitline, "s");
		break;
	case D3DSPR_CONSTBOOL  :
		AppendString(jitline, "b");
		break;
	case D3DSPR_LOOP       :
		AppendString(jitline, "aL");
		break;
	case D3DSPR_TEMPFLOAT16:
		AppendString(jitline, "r");
		break;
	case D3DSPR_MISCTYPE   :
		switch (index)
		{
		default:
			DbgBreakPrint("Unknown MISCTYPE register");
		case D3DSMO_POSITION:
			AppendString(jitline, "vpos");
			break;
		case D3DSMO_FACE:
			AppendString(jitline, "vface");
			break;
		}
		break;
	case D3DSPR_LABEL      :
		AppendString(jitline, "LABEL");
		break;
	case D3DSPR_PREDICATE  :
		AppendString(jitline, "p");
		break;
	default:
#ifdef _DEBUG
		{
			DbgBreakPrint("Error: Unknown shader register");
		}
#endif
		break;
	}

	// Print register index:
	switch (registerType)
	{
	case D3DSPR_CONST      :
		break;
	case D3DSPR_CONST2     :
		index += 2048;
		break;
	case D3DSPR_CONST3     :
		index += 4096;
		break;
	case D3DSPR_CONST4     :
		index += 6144;
		break;
	default:
		break;
	}
	char shaderIndexBuffer[16] = {0};
	sprintf(shaderIndexBuffer, "%u", index);
	AppendString(jitline, shaderIndexBuffer);

	if (srcParameter.GetRelativeAddressingType() == D3DSHADER_ADDRMODE_RELATIVE)
	{
		DbgBreakPrint("Relative addressing not yet implemented!");

		// Super important to do this, otherwise the bytecode stream gets broken!
		++bytecode;
	}

	const unsigned channelSwizzle = srcParameter.GetChannelSwizzleXYZW();
	switch (channelSwizzle)
	{
	case D3DVS_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT: // .xyzw
		break; // Don't print .xyzw all the time
	case D3DSP_REPLICATERED >> D3DVS_SWIZZLE_SHIFT: // .x
		AppendString(jitline, ".x");
		break;
	case D3DSP_REPLICATEGREEN >> D3DVS_SWIZZLE_SHIFT: // .y
		AppendString(jitline, ".y");
		break;
	case D3DSP_REPLICATEBLUE >> D3DVS_SWIZZLE_SHIFT: // .z
		AppendString(jitline, ".z");
		break;
	case D3DSP_REPLICATEALPHA >> D3DVS_SWIZZLE_SHIFT: // .w
		AppendString(jitline, ".w");
		break;
	default:
		DbgBreakPrint("Error: Non-trivial source register swizzle detected");
		break;
	}

	// Super important to advance the bytecode stream
	++bytecode;
}

template <const unsigned swizzleIndex>
static inline void PrintSourceRegNameAndSourceSwizzle(const srcParameterToken& sourceToken, char* const outBuffer, const ShaderInfo& shaderInfo, const srcParameterToken* const addressToken = NULL)
{
	unsigned index = sourceToken.GetRegisterIndex();

	const D3DSHADER_PARAM_REGISTER_TYPE registerType = sourceToken.GetRegisterType();
	const char* registerBaseString = NULL;
	switch (registerType)
	{
	case D3DSPR_TEMP       :
		registerBaseString = "r";
		break;
	case D3DSPR_INPUT      :
		registerBaseString = "v";
		break;
	case D3DSPR_CONST      :
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
		registerBaseString = "c";
		break;
	case D3DSPR_ADDR       : // Also known as D3DSPR_TEXTURE (PS)
		if (shaderInfo.isPixelShader)
		{
			if (shaderInfo.shaderMajorVersion == 3)
				registerBaseString = "v"; // Texcoord
			else
				registerBaseString = "t"; // Texcoord
		}
		else
		{
			registerBaseString = "a"; // Address
		}
		break;
	case D3DSPR_RASTOUT    :
		switch (index)
		{
		default:
			DbgBreakPrint("Error: Unknown RASTOUT register index");
		case D3DSRO_POSITION:
			registerBaseString = "oPos";
			break;
		case D3DSRO_FOG:
			registerBaseString = "oFog";
			break;
		case D3DSRO_POINT_SIZE:
			registerBaseString = "oPts";
			break;
		}
		break;
	case D3DSPR_ATTROUT    :
		registerBaseString = "oD";
		break;
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
		registerBaseString = "oT";
		break;
	case D3DSPR_CONSTINT   :
		registerBaseString = "i";
		break;
	case D3DSPR_COLOROUT   :
		registerBaseString = "oC";
		break;
	case D3DSPR_DEPTHOUT   :
		registerBaseString = "oDepth";
		break;
	case D3DSPR_SAMPLER    :
		registerBaseString = "s";
		break;
	case D3DSPR_CONSTBOOL  :
		registerBaseString = "b";
		break;
	case D3DSPR_LOOP       :
		registerBaseString = "aL";
		break;
	case D3DSPR_TEMPFLOAT16:
		registerBaseString = "r";
		break;
	case D3DSPR_MISCTYPE   :
		switch (index)
		{
		default:
			DbgBreakPrint("Unknown MISCTYPE register");
		case D3DSMO_POSITION:
			registerBaseString = "vpos";
			break;
		case D3DSMO_FACE:
			registerBaseString = "vface";
			break;
		}
		break;
	case D3DSPR_LABEL      :
		registerBaseString = "LABEL";
		break;
	case D3DSPR_PREDICATE  :
		registerBaseString = "p";
		break;
	default:
#ifdef _DEBUG
		{
			DbgBreakPrint("Error: Unknown shader register");
		}
#endif
		break;
	}

	// Print register index:
	switch (registerType)
	{
	case D3DSPR_CONST      :
		break;
	case D3DSPR_CONST2     :
		index += 2048;
		break;
	case D3DSPR_CONST3     :
		index += 4096;
		break;
	case D3DSPR_CONST4     :
		index += 6144;
		break;
	default:
		break;
	}

	PrintSourceSwizzle<swizzleIndex>(sourceToken, outBuffer, registerBaseString, index);

	if (addressToken)
	{
		std::string outCopy = outBuffer;
		char addressRegisterAndSwizzle[32];
		switch (addressToken->GetChannelSwizzleXYZW() )
		{
		default:
		case D3DVS_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT: // .xyzw
		case D3DSP_REPLICATERED >> D3DVS_SWIZZLE_SHIFT: // .x
			PrintSourceRegNameAndSourceSwizzle<0>(*addressToken, addressRegisterAndSwizzle, shaderInfo);
			break;
		case D3DSP_REPLICATEGREEN >> D3DVS_SWIZZLE_SHIFT: // .y
			PrintSourceRegNameAndSourceSwizzle<1>(*addressToken, addressRegisterAndSwizzle, shaderInfo);
			break;
		case D3DSP_REPLICATEBLUE >> D3DVS_SWIZZLE_SHIFT: // .z
			PrintSourceRegNameAndSourceSwizzle<2>(*addressToken, addressRegisterAndSwizzle, shaderInfo);
			break;
		case D3DSP_REPLICATEALPHA >> D3DVS_SWIZZLE_SHIFT: // .w
			PrintSourceRegNameAndSourceSwizzle<3>(*addressToken, addressRegisterAndSwizzle, shaderInfo);
			break;
		}
		sprintf(outBuffer, "vs.GetSrcRegisterFromAddress(%s, %s)", outCopy.c_str(), addressRegisterAndSwizzle);
	}
}

static inline void PrintRegisterName(const parameterToken& parameterToken, char* const outBuffer, const ShaderInfo& shaderInfo, const srcParameterToken* const addressToken = NULL)
{
	unsigned index = parameterToken.GetRegisterIndex();

	const D3DSHADER_PARAM_REGISTER_TYPE registerType = parameterToken.GetRegisterType();
	const char* registerBaseString = NULL;
	switch (registerType)
	{
	case D3DSPR_TEMP       :
		registerBaseString = "r";
		break;
	case D3DSPR_INPUT      :
		registerBaseString = "v";
		break;
	case D3DSPR_CONST      :
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
		registerBaseString = "c";
		break;
	case D3DSPR_ADDR       : // Also known as D3DSPR_TEXTURE (PS)
		if (shaderInfo.isPixelShader)
		{
			if (shaderInfo.shaderMajorVersion == 3)
				registerBaseString = "v"; // Texcoord
			else
				registerBaseString = "t"; // Texcoord
		}
		else
		{
			registerBaseString = "a"; // Address
		}
		break;
	case D3DSPR_RASTOUT    :
		switch (index)
		{
		default:
			DbgBreakPrint("Error: Unknown RASTOUT register index");
		case D3DSRO_POSITION:
			registerBaseString = "oPos";
			break;
		case D3DSRO_FOG:
			registerBaseString = "oFog";
			break;
		case D3DSRO_POINT_SIZE:
			registerBaseString = "oPts";
			break;
		}
		break;
	case D3DSPR_ATTROUT    :
		registerBaseString = "oD";
		break;
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
		registerBaseString = "oT";
		break;
	case D3DSPR_CONSTINT   :
		registerBaseString = "i";
		break;
	case D3DSPR_COLOROUT   :
		registerBaseString = "oC";
		break;
	case D3DSPR_DEPTHOUT   :
		registerBaseString = "oDepth";
		break;
	case D3DSPR_SAMPLER    :
		registerBaseString = "s";
		break;
	case D3DSPR_CONSTBOOL  :
		registerBaseString = "b";
		break;
	case D3DSPR_LOOP       :
		registerBaseString = "aL";
		break;
	case D3DSPR_TEMPFLOAT16:
		registerBaseString = "r";
		break;
	case D3DSPR_MISCTYPE   :
		switch (index)
		{
		default:
			DbgBreakPrint("Unknown MISCTYPE register");
		case D3DSMO_POSITION:
			registerBaseString = "vpos";
			break;
		case D3DSMO_FACE:
			registerBaseString = "vface";
			break;
		}
		break;
	case D3DSPR_LABEL      :
		registerBaseString = "LABEL";
		break;
	case D3DSPR_PREDICATE  :
		registerBaseString = "p";
		break;
	default:
#ifdef _DEBUG
		{
			DbgBreakPrint("Error: Unknown shader register");
		}
#endif
		break;
	}

	// Print register index:
	switch (registerType)
	{
	case D3DSPR_CONST      :
		break;
	case D3DSPR_CONST2     :
		index += 2048;
		break;
	case D3DSPR_CONST3     :
		index += 4096;
		break;
	case D3DSPR_CONST4     :
		index += 6144;
		break;
	default:
		break;
	}
	sprintf(outBuffer, "%s%u", registerBaseString, index);

	if (addressToken)
	{
		std::string outCopy = outBuffer;
		char addressRegisterAndSwizzle[32];
		switch (addressToken->GetChannelSwizzleXYZW() )
		{
		default:
		case D3DVS_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT: // .xyzw
		case D3DSP_REPLICATERED >> D3DVS_SWIZZLE_SHIFT: // .x
			PrintSourceRegNameAndSourceSwizzle<0>(*addressToken, addressRegisterAndSwizzle, shaderInfo);
			break;
		case D3DSP_REPLICATEGREEN >> D3DVS_SWIZZLE_SHIFT: // .y
			PrintSourceRegNameAndSourceSwizzle<1>(*addressToken, addressRegisterAndSwizzle, shaderInfo);
			break;
		case D3DSP_REPLICATEBLUE >> D3DVS_SWIZZLE_SHIFT: // .z
			PrintSourceRegNameAndSourceSwizzle<2>(*addressToken, addressRegisterAndSwizzle, shaderInfo);
			break;
		case D3DSP_REPLICATEALPHA >> D3DVS_SWIZZLE_SHIFT: // .w
			PrintSourceRegNameAndSourceSwizzle<3>(*addressToken, addressRegisterAndSwizzle, shaderInfo);
			break;
		}
		sprintf(outBuffer, "vs.GetSrcRegisterFromAddress(%s, %s)", outCopy.c_str(), addressRegisterAndSwizzle);
	}
}

static inline void AdvanceSrcParameter(const ShaderInfo& shaderInfo, const DWORD*& shaderMemory, const srcParameterToken*& outSrcParam, const srcParameterToken*& outAddressParam)
{
	outSrcParam = (const srcParameterToken* const)shaderMemory;
	++shaderMemory;

	// Shader relative addressing: https://msdn.microsoft.com/en-us/library/windows/hardware/ff569708(v=vs.85).aspx
	switch(outSrcParam->GetRelativeAddressingType() )
	{
	default:
	case D3DSHADER_ADDRMODE_ABSOLUTE:
		outAddressParam = NULL;
		return;
	case D3DSHADER_ADDRMODE_RELATIVE:
		if (shaderInfo.shaderMajorVersion == 1 && !shaderInfo.isPixelShader) // vs_1_1 has implicit relative addressing of a0.x (the only relative addressable register and component)
		{
			// Bit 31 is 0x1 and this is of type "Address Register" and the swizzle is an X-broadcast (*.xxxx)
			static const DWORD IMPLICIT_SRC_PARAMETER_TOKEN_A0_X = (0x80000000) | (D3DSPR_ADDR << 28);

			outAddressParam = (const srcParameterToken* const)&IMPLICIT_SRC_PARAMETER_TOKEN_A0_X;
		}
		else // Explicit relative address specified in the next DWORD token:
		{
			outAddressParam = (const srcParameterToken* const)shaderMemory;
			++shaderMemory;
		}
		break;
	}
}


static inline const bool ParseCustomOpcode(const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode, const DWORD*& shaderMemory, const ShaderInfo& shaderInfo, std::vector<char>& shaderbody)
{
	char disasm[1024] = {0};
	sprintf(disasm, "\t// %s ", GetOpcodeString(opcode) );
	AppendString(shaderbody, disasm);

	switch (opcode)
	{
	default:
		__debugbreak(); // Unhandled custom opcode detected!
		break;
	case D3DSIO_LABEL:
	{
		const srcParameterToken& srcParameter = *(const srcParameterToken* const)shaderMemory++;
		sprintf(disasm, "LABEL%u", srcParameter.GetRegisterIndex() );
	}
		break;
	case D3DSIO_DCL:
	{
		const DWORD dwordToken = *shaderMemory++;
		const dstParameterToken& destParameter = *(const dstParameterToken* const)shaderMemory++;
		UNREFERENCED_PARAMETER(destParameter);
	}
		break;
	case D3DSIO_SINCOS:
	{
		const dstParameterToken& destParameter = *(const dstParameterToken* const)shaderMemory++;
		const srcParameterToken* srcParameters[3] = {NULL};
		const srcParameterToken* srcAddrParameters[3] = {NULL};

		unsigned numSrcTokens;
		if (shaderInfo.shaderMajorVersion < 3) // Shader model 2 has these extra registers, but all the shader model 3+ don't have them
			numSrcTokens = 3;
		else
			numSrcTokens = 1;

		for (unsigned x = 0; x < numSrcTokens; ++x)
			AdvanceSrcParameter(shaderInfo, shaderMemory, srcParameters[x], srcAddrParameters[x]);

		UNREFERENCED_PARAMETER(destParameter);

		DbgBreakPrint("Error: SINCOS is not yet implemented in the JIT system!");
	}
		break;
	case D3DSIO_DEFB:
	{
		const dstParameterToken& destParameter = *(const dstParameterToken* const)shaderMemory++;
		const BOOL dword0 = *shaderMemory++;

		sprintf(disasm, "b%u = %s", destParameter.GetRegisterIndex(), dword0 ? "TRUE" : "FALSE");
		AppendString(shaderbody, disasm);
	}
		break;
	case D3DSIO_DEFI:
	{
		const dstParameterToken& destParameter = *(const dstParameterToken* const)shaderMemory++;
		const DWORD dword0 = *shaderMemory++;
		int4 iVar;
		iVar.x = *(const int* const)&dword0;
		const DWORD dword1 = *shaderMemory++;
		iVar.y = *(const int* const)&dword1;
		const DWORD dword2 = *shaderMemory++;
		iVar.z = *(const int* const)&dword2;
		const DWORD dword3 = *shaderMemory++;
		iVar.w = *(const int* const)&dword3;

		sprintf(disasm, "i%u = int4(%i, %i, %i, %i)", destParameter.GetRegisterIndex(), iVar.x, iVar.y, iVar.z, iVar.w);
		AppendString(shaderbody, disasm);
	}
		break;
	case D3DSIO_DEF:
	{
		const dstParameterToken& destParameter = *(const dstParameterToken* const)shaderMemory++;
		const DWORD dword0 = *shaderMemory++;
		float4 fVar;
		fVar.x = *(const float* const)&dword0;
		const DWORD dword1 = *shaderMemory++;
		fVar.y = *(const float* const)&dword1;
		const DWORD dword2 = *shaderMemory++;
		fVar.z = *(const float* const)&dword2;
		const DWORD dword3 = *shaderMemory++;
		fVar.w = *(const float* const)&dword3;

		sprintf(disasm, "c%u = float4(%f, %f, %f, %f)", destParameter.GetRegisterIndex(), fVar.x, fVar.y, fVar.z, fVar.w);
		AppendString(shaderbody, disasm);
	}
		break;
	case D3DSIO_TEX:
	{
		const dstParameterToken& destParameter = *(const dstParameterToken* const)shaderMemory++;
		srcParameterToken src0; // This is the texcoord source parameter
		srcParameterToken src1; // This is the sampler source parameter
		if (shaderInfo.shaderMajorVersion < 2)
		{
			if (shaderInfo.shaderMinorVersion < 4)
			{
				// This is the ps_1_0 thru ps_1_3 case: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/tex---ps
				// Just T dst

				// src0 is the texcoord source parameter:
				src0.internalRawToken = 0x00000000;
				src0.srcParameter.instructionParameterBit = parameterTokenMarker;
				src0.srcParameter.registerIndex = destParameter.GetRegisterIndex();
				src0.srcParameter.registerType_lowBits = destParameter.GetRegisterType();
				src0.srcParameter.registerType_highBits = (destParameter.GetRegisterType() >> 3);
				src0.srcParameter.sourceSwizzle.fullSwizzle = _NoSwizzleXYZW;
			}
			else
			{
				// This is the ps_1_4 case: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/texld---ps-1-4
				// tex R dst, T/R src0
				src0 = *(const srcParameterToken* const)shaderMemory++;
			}

			// src1 is the sampler source parameter:
			src1.internalRawToken = 0x00000000;
			src1.srcParameter.instructionParameterBit = parameterTokenMarker;
			src1.srcParameter.registerIndex = destParameter.GetRegisterIndex();
			src1.srcParameter.registerType_lowBits = (D3DSPR_SAMPLER & 0x7);
			src1.srcParameter.registerType_highBits = ( (D3DSPR_SAMPLER >> 3) & 0x3);
			src1.srcParameter.sourceSwizzle.fullSwizzle = _NoSwizzleXYZW;
		}
		else
		{
			// This is the shader model 2+ case: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/texld---ps-2-0
			// tex R dst, T/R/V src0, S src1
			src0 = *(const srcParameterToken* const)shaderMemory++;
			src1 = *(const srcParameterToken* const)shaderMemory++;
		}

		// TODO: Support tex2Dbias (D3DSIO_TEX), tex2Dproj (D3DSIO_TEX), tex2Dgrad (D3DSIO_TEXLDD) and tex2Dod (D3DSIO_TEXLDL) too
		char destRegisterName[8] = {0};
		char src0RegisterName[8] = {0};
		char src1RegisterName[8] = {0};
		PrintRegisterName(destParameter, destRegisterName, shaderInfo);
		PrintRegisterName(src0, src0RegisterName, shaderInfo);
		PrintRegisterName(src1, src1RegisterName, shaderInfo);

		char texStringSource[64] = {0};
		sprintf(texStringSource, "%s, %s, %s\n", destRegisterName, src0RegisterName, src1RegisterName);
		AppendString(shaderbody, texStringSource);

		const unsigned writeMask = destParameter.GetWriteMask();
		sprintf(texStringSource, "\t(*%cs.tex2DMip0ptrs[%u])", shaderInfo.isPixelShader ? 'p' : 'v', writeMask - 1);
		AppendString(shaderbody, texStringSource);

		// Technically we don't have to worry about dest register aliasing with source registers for this instruction, because the
		// texld instruction internally makes a modifiable copy of the texcoord for coord wrapping/clamping/etc. behavior
		sprintf(texStringSource, "(%s, %s, %s);\n", destRegisterName, src0RegisterName, src1RegisterName);
		AppendString(shaderbody, texStringSource);
	}
		break;
	case D3DSIO_PHASE:
		break;
	case D3DSIO_COMMENT:
	{
		const DWORD commentToken = shaderMemory[-1];
		const unsigned numTokensToSkip = (commentToken & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
		shaderMemory += numTokensToSkip;
	}
		break;
	case D3DSIO_END:
		shaderbody.push_back('\n');
		return true;
	}

	shaderbody.push_back('\n');

	return false;
}

static inline void PrintSourceModifier(const srcParameterToken& sourceParameterToken, char* const outBuffer, const char* const sourceRegName)
{
	switch (sourceParameterToken.GetSourceModifiersUnshifted() )
	{
	default:
		DbgBreakPrint("Error: Unknown source register modifier!");
	case D3DSPSM_NONE   :
		sprintf(outBuffer, "%s", sourceRegName);
		break;
	case D3DSPSM_NEG    :
		sprintf(outBuffer, "-%s", sourceRegName);
		break;
	case D3DSPSM_BIAS   :
		sprintf(outBuffer, "-0.5f + %s", sourceRegName);
		break;
	case D3DSPSM_BIASNEG:
		sprintf(outBuffer, "(-0.5f + %s) * -1.0f", sourceRegName);
		break;
	case D3DSPSM_SIGN   :
		sprintf(outBuffer, "(-0.5f + %s) * 2.0f", sourceRegName);
		break;
	case D3DSPSM_SIGNNEG:
		sprintf(outBuffer, "(-0.5f + %s) * -2.0f", sourceRegName);
		break;
	case D3DSPSM_COMP   :
		sprintf(outBuffer, "1.0f - %s", sourceRegName);
		break;
	case D3DSPSM_X2     :
		sprintf(outBuffer, "2.0f * %s", sourceRegName);
		break;
	case D3DSPSM_X2NEG  :
		sprintf(outBuffer, "-2.0f * %s", sourceRegName);
		break;
	case D3DSPSM_DZ     :
		DbgBreakPrint("Error: Source modifier not yet supported");
		break;
	case D3DSPSM_DW     :
		DbgBreakPrint("Error: Source modifier not yet supported");
		break;
	case D3DSPSM_ABS    :
		sprintf(outBuffer, "fabsf(%s)", sourceRegName);
		break;
	case D3DSPSM_ABSNEG :
		sprintf(outBuffer, "-1.0f * fabsf(%s)", sourceRegName);
		break;
	case D3DSPSM_NOT    :
		sprintf(outBuffer, "!%s", sourceRegName);
		break;
	}
}

// These strings are for disassembly only (not for shader-code)
static const char* writeMaskDisasmStrings[16] = 
{
	".0", // 0
	".x", // 1
	".y", // 2
	".xy", // 3
	".z", // 4
	".xz", // 5
	".yz", // 6
	".xyz", // 7
	".w", // 8
	".xw", // 9
	".yw", // 10
	".xyw", // 11
	".zw", // 12
	".xzw", // 13
	".yzw", // 14
	"", // 15
};

template <const unsigned swizzleIndex>
static inline void PrintSourceSwizzle(const srcParameterToken& sourceToken, char* const outBuffer, const char* const baseString, const unsigned regIndex)
{
	static const char* const swizzleChannels[4] = 
	{
		".x",
		".y",
		".z",
		".w"
	};

	const unsigned swizzleX = sourceToken.GetChannelSwizzleXYZW() & 0x3;
	const unsigned swizzleY = (sourceToken.GetChannelSwizzleXYZW() >> 2) & 0x3;
	const unsigned swizzleZ = (sourceToken.GetChannelSwizzleXYZW() >> 4) & 0x3;
	const unsigned swizzleW = (sourceToken.GetChannelSwizzleXYZW() >> 6) & 0x3;

	switch (swizzleIndex)
	{
	default:
		DbgBreakPrint("Should never be here!");
	case 0: // x
		sprintf(outBuffer, "%s%u%s", baseString, regIndex, swizzleChannels[swizzleX]);
		break;
	case 1: // y
		sprintf(outBuffer, "%s%u%s", baseString, regIndex, swizzleChannels[swizzleY]);
		break;
	case 2: // z
		sprintf(outBuffer, "%s%u%s", baseString, regIndex, swizzleChannels[swizzleZ]);
		break;
	case 3: // w
		sprintf(outBuffer, "%s%u%s", baseString, regIndex, swizzleChannels[swizzleW]);
		break;
	}
}

template <const unsigned swizzleIndex>
static inline void PrintSourceSwizzle(const srcParameterToken& sourceToken, char* const outBuffer, const char* const baseString)
{
	static const char* const swizzleChannels[4] = 
	{
		".x",
		".y",
		".z",
		".w"
	};

	const unsigned swizzleX = sourceToken.GetChannelSwizzleXYZW() & 0x3;
	const unsigned swizzleY = (sourceToken.GetChannelSwizzleXYZW() >> 2) & 0x3;
	const unsigned swizzleZ = (sourceToken.GetChannelSwizzleXYZW() >> 4) & 0x3;
	const unsigned swizzleW = (sourceToken.GetChannelSwizzleXYZW() >> 6) & 0x3;

	switch (swizzleIndex)
	{
	default:
		DbgBreakPrint("Should never be here!");
	case 0: // x
		sprintf(outBuffer, "%s%s", baseString, swizzleChannels[swizzleX]);
		break;
	case 1: // y
		sprintf(outBuffer, "%s%s", baseString, swizzleChannels[swizzleY]);
		break;
	case 2: // z
		sprintf(outBuffer, "%s%s", baseString, swizzleChannels[swizzleZ]);
		break;
	case 3: // w
		sprintf(outBuffer, "%s%s", baseString, swizzleChannels[swizzleW]);
		break;
	}
}

template <const unsigned swizzleIndex>
static inline void PrintSourceRegNameAndSourceSwizzleOrTempReg(const srcParameterToken& sourceToken, const dstParameterToken& destToken, char* const outBuffer, const ShaderInfo& shaderInfo, const srcParameterToken* const addressToken = NULL)
{
	if (NeedTempDestCopy(destToken, sourceToken) )
		PrintSourceSwizzle<swizzleIndex>(sourceToken, outBuffer, "tempDst");
	else
		PrintSourceRegNameAndSourceSwizzle<swizzleIndex>(sourceToken, outBuffer, shaderInfo, addressToken);
}
// returns true if done parsing, or false to continue parsing the shader
static inline const bool ParseOpcode(const DWORD*& shaderMemory, const ShaderInfo& shaderInfo, std::vector<char>& shaderbody, bool& usedTempDestRegister)
{
	// Increment the token pointer to the first parameter or to the next instruction (if the opcode has no parameters)
	const instructionToken rawOpcodeToken = *(const instructionToken* const)shaderMemory++;
	const D3DSHADER_INSTRUCTION_OPCODE_TYPE opcode = (const D3DSHADER_INSTRUCTION_OPCODE_TYPE)(rawOpcodeToken.opcode);

	char disasm[1024] = {0};
	char buffer[1024] = {0};

	if (!GetOpcodeImplementedForJIT(opcode) )
	{
		char notImplementedMessage[128] = {0};
		sprintf(notImplementedMessage, "\t//--- Warning: Opcode \"%s\" not yet implemented for JIT! ---\n", GetOpcodeString(opcode) );
		AppendString(shaderbody, notImplementedMessage);
	}

	if (!GetOpcodeAllowChannelSplitting(opcode) )
	{
		const opcodeDisplayType opcodeType = GetOpcodeDisplayType(opcode);
		if (opcodeType == customOpcode)
			return ParseCustomOpcode(opcode, shaderMemory, shaderInfo, shaderbody);

		sprintf(disasm, "\t// %s\n", GetOpcodeString(opcode) );
		AppendString(shaderbody, disasm);
		AppendString(shaderbody, "\t{\n");

		char destRegisterName[16] = {0};
		const dstParameterToken& destParameter = *(const dstParameterToken* const)shaderMemory++;
		const unsigned writeMask = destParameter.GetWriteMask();
		PrintRegisterName(destParameter, destRegisterName, shaderInfo);

		const srcParameterToken* srcParameters[4] = {NULL};
		const srcParameterToken* srcAddrParameters[4] = {NULL};
		const unsigned numSrcParameters = GetNumSourceParams(opcodeType);
		for (unsigned x = 0; x < numSrcParameters; ++x)
			AdvanceSrcParameter(shaderInfo, shaderMemory, srcParameters[x], srcAddrParameters[x]);

		const bool hasWriteMask = writeMask != 0xF;
		if (hasWriteMask)
		{
			AppendString(shaderbody, "\t\tfloat4 unmaskedRet;\n");
		}

		for (unsigned x = 0; x < numSrcParameters; ++x)
		{
			if (srcParameters[x]->GetChannelSwizzleXYZW() == (D3DSP_NOSWIZZLE >> D3DSP_SWIZZLE_SHIFT) )
				continue;

			sprintf(buffer, "\t\tfloat4 swizzledSource%u;\n", x);
			AppendString(shaderbody, buffer);

			char srcRegisterName[16] = {0};
			PrintRegisterName(*srcParameters[x], srcRegisterName, shaderInfo);

			PrintSourceSwizzle<0>(*srcParameters[x], disasm, srcRegisterName);
			sprintf(buffer, "\t\tswizzledSource%u.x = %s;\n", x, disasm);
			AppendString(shaderbody, buffer);

			PrintSourceSwizzle<1>(*srcParameters[x], disasm, srcRegisterName);
			sprintf(buffer, "\t\tswizzledSource%u.y = %s;\n", x, disasm);
			AppendString(shaderbody, buffer);

			PrintSourceSwizzle<2>(*srcParameters[x], disasm, srcRegisterName);
			sprintf(buffer, "\t\tswizzledSource%u.z = %s;\n", x, disasm);
			AppendString(shaderbody, buffer);

			PrintSourceSwizzle<3>(*srcParameters[x], disasm, srcRegisterName);
			sprintf(buffer, "\t\tswizzledSource%u.w = %s;\n", x, disasm);
			AppendString(shaderbody, buffer);
		}

		const char* functionStringSource = NULL;

		// TODO: Support tex2Dbias (D3DSIO_TEX), tex2Dproj (D3DSIO_TEX), tex2Dgrad (D3DSIO_TEXLDD) and tex2Dod (D3DSIO_TEXLDL) too
		if (opcode == D3DSIO_TEX)
		{
			static char texStringSource[64] = {0};
			if (shaderInfo.isPixelShader)
				sprintf(texStringSource, "(*ps.tex2DMip0ptrs[%u])", writeMask - 1);
			else
				sprintf(texStringSource, "(*vs.tex2DMip0ptrs[%u])", writeMask - 1);
			functionStringSource = texStringSource;
		}
		else
		{
			functionStringSource = GetOpcodeFunctionString(opcode);
		}

		sprintf(buffer, "\t\t%s(%s, ", functionStringSource, hasWriteMask ? "unmaskedRet" : destRegisterName);
		AppendString(shaderbody, buffer);

		for (unsigned x = 0; x < numSrcParameters; ++x)
		{
			if (x > 0)
				AppendString(shaderbody, ", ");

			if (srcParameters[x]->GetChannelSwizzleXYZW() == (D3DSP_NOSWIZZLE >> D3DSP_SWIZZLE_SHIFT) )
			{
				PrintRegisterName(*srcParameters[x], buffer, shaderInfo, srcAddrParameters[x]);
				AppendString(shaderbody, buffer);
			}
			else
			{
				sprintf(buffer, "swizzledSource%u", x);
				AppendString(shaderbody, buffer);
			}
		}

		AppendString(shaderbody, ");\n");

		if (hasWriteMask)
		{
			if (writeMask & 0x1)
			{
				sprintf(buffer, "\t\t%s.x = unmaskedRet.x;\n", destRegisterName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x2)
			{
				sprintf(buffer, "\t\t%s.y = unmaskedRet.y;\n", destRegisterName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x4)
			{
				sprintf(buffer, "\t\t%s.z = unmaskedRet.z;\n", destRegisterName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x8)
			{
				sprintf(buffer, "\t\t%s.w = unmaskedRet.w;\n", destRegisterName);
				AppendString(shaderbody, buffer);
			}
		}

		if (destParameter.GetResultModifierUnshifted() & D3DSPDM_SATURATE)
		{
			if (writeMask & 0x1)
			{
				sprintf(buffer, "\t%s.x = saturate(%s.x);\n", destRegisterName, destRegisterName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x2)
			{
				sprintf(buffer, "\t%s.y = saturate(%s.y);\n", destRegisterName, destRegisterName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x4)
			{
				sprintf(buffer, "\t%s.z = saturate(%s.z);\n", destRegisterName, destRegisterName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x8)
			{
				sprintf(buffer, "\t%s.w = saturate(%s.w);\n", destRegisterName, destRegisterName);
				AppendString(shaderbody, buffer);
			}
		}

		AppendString(shaderbody, "\t}\n\n");

		return false;
	}

	const opcodeDisplayType opcodeType = GetOpcodeDisplayType(opcode);

	unsigned numSourceRegisters;
	switch (opcodeType)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case justOpcode:
	case customOpcode:
	case dstOnly:
		numSourceRegisters = 0;
		break;
	case srcOnly:
	case srcDst:
		numSourceRegisters = 1;
		break;
	case srcSrcOnly:
	case srcSrcDst:
		numSourceRegisters = 2;
		break;
	case srcSrcSrcDst:
		numSourceRegisters = 3;
		break;
	case srcSrcSrcSrcDst:
		numSourceRegisters = 4;
		break;
	}

	switch (opcodeType)
	{
	case customOpcode:
		return ParseCustomOpcode(opcode, shaderMemory, shaderInfo, shaderbody);
	case justOpcode:
		sprintf(disasm, "\t// %s\n", GetOpcodeString(opcode) );
		AppendString(shaderbody, disasm);
		sprintf(buffer, "\t%s(%cs);\n\n", GetOpcodeFunctionString(opcode), shaderInfo.isPixelShader ? 'p' : 'v');
		AppendString(shaderbody, buffer);
		break;
	case srcOnly:
	{
		std::vector<char> sourceDisasmLine;
		ResolveSrcParameterDisasm(shaderInfo, shaderMemory, sourceDisasmLine);
		sprintf(disasm, "\t// %s %s\n", GetOpcodeString(opcode), &(sourceDisasmLine.front() ) );
		AppendString(shaderbody, disasm);
		std::vector<char> jitLine;
		ResolveSrcParameterSimpleSwizzleNoSourceMods(shaderInfo, shaderMemory, jitLine);
		sprintf(buffer, "\t%s(%cs, %s);\n\n", GetOpcodeFunctionString(opcode), shaderInfo.isPixelShader ? 'p' : 'v', &(jitLine.front() ) );
		AppendString(shaderbody, buffer);
	}
		break;
	case srcSrcOnly:
	{
		std::vector<char> sourceDisasmLine;
		std::vector<char> jitLine;
		ResolveSrcParameterDisasm(shaderInfo, shaderMemory, sourceDisasmLine);
		sourceDisasmLine.push_back(' ');
		ResolveSrcParameterSimpleSwizzleNoSourceMods(shaderInfo, shaderMemory, jitLine);
		ResolveSrcParameterDisasm(shaderInfo, shaderMemory, sourceDisasmLine);
		ResolveSrcParameterSimpleSwizzleNoSourceMods(shaderInfo, shaderMemory, jitLine);
		sprintf(disasm, "\t// %s %s\n", GetOpcodeString(opcode), &(sourceDisasmLine.front() ) );
		AppendString(shaderbody, disasm);
		sprintf(buffer, "\t%s(%cs, %s);\n\n", GetOpcodeFunctionString(opcode), shaderInfo.isPixelShader ? 'p' : 'v', &(jitLine.front() ) );
		AppendString(shaderbody, buffer);
	}
		break;
	case dstOnly:
	{
		std::vector<char> jitLine;
		const dstParameterToken& destParameter = *(const dstParameterToken* const)shaderMemory++;

		if (opcode == D3DSIO_TEXKILL)
		{
			char registerName[16] = {0};
			const unsigned registerIndex = destParameter.GetRegisterIndex();
			switch (destParameter.GetRegisterType() )
			{
			default:
				DbgBreakPrint("Error: Unexpected register type encountered for TEXKILL instruction");
			case D3DSPR_TEMP: // Temporary (GPR) register
				sprintf(registerName, "r%u", registerIndex);
				break;
			case D3DSPR_TEXTURE: // Texcoord register
				if (shaderInfo.shaderMajorVersion == 3)
					sprintf(registerName, "v%u", registerIndex);
				else
					sprintf(registerName, "t%u", registerIndex);
				break;
			}

			const unsigned writeMask = destParameter.GetWriteMask();

			sprintf(disasm, "\t// %s %s%s\n", GetOpcodeString(opcode), registerName, writeMaskDisasmStrings[writeMask]);
			AppendString(shaderbody, disasm);

			if (writeMask & 0x1) // x
			{
				sprintf(buffer, "\tif (%s.x < 0.0f)\n"
					"\t{\n"
					"\t\tps.outputRegisters[0].pixelStatus = discard;\n"
					"\t\treturn;\n"
					"\t}\n", registerName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x2) // y
			{
				sprintf(buffer, "\tif (%s.y < 0.0f)\n"
					"\t{\n"
					"\t\tps.outputRegisters[0].pixelStatus = discard;\n"
					"\t\treturn;\n"
					"\t}\n", registerName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x4) // z
			{
				sprintf(buffer, "\tif (%s.z < 0.0f)\n"
					"\t{\n"
					"\t\tps.outputRegisters[0].pixelStatus = discard;\n"
					"\t\treturn;\n"
					"\t}\n", registerName);
				AppendString(shaderbody, buffer);
			}

			AppendString(shaderbody, "\n");
		}
	}
		break;
	case srcDst:
	case srcSrcDst:
	case srcSrcSrcDst:
	case srcSrcSrcSrcDst: // Only ever used with D3DSIO_TEXLDD
	{
		char destRegisterName[16] = {0};
		char srcModifierStrings[4][32] = {0};
		char srcRegisterNames[4][32] = {0};
		/*char src0ModifierString[32] = {0};
		char src0RegisterName[16] = {0};
		char src1ModifierString[32] = {0};
		char src1RegisterName[16] = {0};
		char src2ModifierString[32] = {0};
		char src2RegisterName[16] = {0};
		char src3ModifierString[32] = {0};
		char src3RegisterName[16] = {0};*/
		const dstParameterToken& destParameter = *(const dstParameterToken* const)shaderMemory++;
		const unsigned writeMask = destParameter.GetWriteMask();
		PrintRegisterName(destParameter, destRegisterName, shaderInfo);
		const srcParameterToken* srcParameters[4] = {NULL};
		const srcParameterToken* srcAddrParameters[4] = {NULL};
		for (unsigned x = 0; x < numSourceRegisters; ++x)
			AdvanceSrcParameter(shaderInfo, shaderMemory, srcParameters[x], srcAddrParameters[x]);
		for (unsigned x = 0; x < numSourceRegisters; ++x)
			PrintRegisterName(*srcParameters[x], srcRegisterNames[x], shaderInfo);
		/*PrintRegisterName(*srcParameters[0], src0RegisterName, shaderInfo);
		PrintRegisterName(*srcParameters[1], src1RegisterName, shaderInfo);
		PrintRegisterName(*srcParameters[2], src2RegisterName, shaderInfo);
		PrintRegisterName(*srcParameters[3], src3RegisterName, shaderInfo);*/
		static const char* const disasmStrings[4] =
		{
			"\t// %s %s%s, %s\n",
			"\t// %s %s%s, %s, %s\n",
			"\t// %s %s%s, %s, %s, %s\n",
			"\t// %s %s%s, %s, %s, %s, %s\n",
		};
		//sprintf(disasm, "\t// %s %s%s, %s, %s, %s, %s\n", ShaderInfo::GetOpcodeString(opcode), destRegisterName, writeMaskDisasmStrings[writeMask], src0RegisterName, src1RegisterName, src2RegisterName, src3RegisterName);
		sprintf(disasm, disasmStrings[numSourceRegisters - 1], GetOpcodeString(opcode), destRegisterName, writeMaskDisasmStrings[writeMask], srcRegisterNames[0], srcRegisterNames[1], srcRegisterNames[2], srcRegisterNames[3]);
		AppendString(shaderbody, disasm);

		bool needsTempDestCopy = false;
		switch (numSourceRegisters)
		{
		case 1:
			if (NeedTempDestCopy(destParameter, *srcParameters[0]) )
				needsTempDestCopy = true;
			break;
		case 2:
			if (NeedTempDestCopy(destParameter, *srcParameters[0], *srcParameters[1]) )
				needsTempDestCopy = true;
			break;
		case 3:
			if (NeedTempDestCopy(destParameter, *srcParameters[0], *srcParameters[1], *srcParameters[2]) )
				needsTempDestCopy = true;
			break;
		case 4:
			if (NeedTempDestCopy(destParameter, *srcParameters[0], *srcParameters[1], *srcParameters[2], *srcParameters[3]) )
				needsTempDestCopy = true;
			break;
		}

		if (needsTempDestCopy)
		{
			if (!usedTempDestRegister)
			{
				usedTempDestRegister = true;
				AppendString(shaderbody, "\tfloat4 tempDst;\n");
			}
			sprintf(buffer, "\ttempDst = %s; // Need to save dst register as a temporary because it's aliased to a source register\n", destRegisterName);
			AppendString(shaderbody, buffer);
		}

		static const char* const writeMaskStrings[4] =
		{
			"\t%s(%s.%c, %s);\n",
			"\t%s(%s.%c, %s, %s);\n",
			"\t%s(%s.%c, %s, %s, %s);\n",
			"\t%s(%s.%c, %s, %s, %s, %s);\n",
		};

		if (writeMask & 0x1)
		{
			for (unsigned x = 0; x < numSourceRegisters; ++x)
			{
				PrintSourceRegNameAndSourceSwizzleOrTempReg<0>(*srcParameters[x], destParameter, srcRegisterNames[x], shaderInfo, srcAddrParameters[x]);
				PrintSourceModifier(*srcParameters[x], srcModifierStrings[x], srcRegisterNames[x]);
			}
			/*PrintSourceRegNameAndSourceSwizzleOrTempReg<0>(*srcParameters[0], destParameter, src0RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[0], src0ModifierString, src0RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<0>(*srcParameters[1], destParameter, src1RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[1], src1ModifierString, src1RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<0>(*srcParameters[2], destParameter, src2RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[2], src2ModifierString, src2RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<0>(*srcParameters[3], destParameter, src3RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[3], src3ModifierString, src3RegisterName);*/
			sprintf(buffer, writeMaskStrings[numSourceRegisters - 1], GetOpcodeFunctionString(opcode), destRegisterName, 'x', srcModifierStrings[0], srcModifierStrings[1], srcModifierStrings[2], srcModifierStrings[3]);
			AppendString(shaderbody, buffer);
		}
		if (writeMask & 0x2)
		{
			for (unsigned x = 0; x < numSourceRegisters; ++x)
			{
				PrintSourceRegNameAndSourceSwizzleOrTempReg<1>(*srcParameters[x], destParameter, srcRegisterNames[x], shaderInfo, srcAddrParameters[x]);
				PrintSourceModifier(*srcParameters[x], srcModifierStrings[x], srcRegisterNames[x]);
			}
			/*PrintSourceRegNameAndSourceSwizzleOrTempReg<1>(*srcParameters[0], destParameter, src0RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[0], src0ModifierString, src0RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<1>(*srcParameters[1], destParameter, src1RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[1], src1ModifierString, src1RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<1>(*srcParameters[2], destParameter, src2RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[2], src2ModifierString, src2RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<1>(*srcParameters[3], destParameter, src3RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[3], src3ModifierString, src3RegisterName);*/
			//sprintf(buffer, "\t%s(%s.y, %s, %s, %s, %s);\n", ShaderInfo::GetOpcodeFunctionString(opcode), destRegisterName, src0ModifierString, src1ModifierString, src2ModifierString, src3ModifierString);
			sprintf(buffer, writeMaskStrings[numSourceRegisters - 1], GetOpcodeFunctionString(opcode), destRegisterName, 'y', srcModifierStrings[0], srcModifierStrings[1], srcModifierStrings[2], srcModifierStrings[3]);
			AppendString(shaderbody, buffer);
		}
		if (writeMask & 0x4)
		{
			for (unsigned x = 0; x < numSourceRegisters; ++x)
			{
				PrintSourceRegNameAndSourceSwizzleOrTempReg<2>(*srcParameters[x], destParameter, srcRegisterNames[x], shaderInfo, srcAddrParameters[x]);
				PrintSourceModifier(*srcParameters[x], srcModifierStrings[x], srcRegisterNames[x]);
			}
			/*PrintSourceRegNameAndSourceSwizzleOrTempReg<2>(*srcParameters[0], destParameter, src0RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[0], src0ModifierString, src0RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<2>(*srcParameters[1], destParameter, src1RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[1], src1ModifierString, src1RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<2>(*srcParameters[2], destParameter, src2RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[2], src2ModifierString, src2RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<2>(*srcParameters[3], destParameter, src3RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[3], src3ModifierString, src3RegisterName);
			sprintf(buffer, "\t%s(%s.z, %s, %s, %s, %);\n", ShaderInfo::GetOpcodeFunctionString(opcode), destRegisterName, src0ModifierString, src1ModifierString, src2ModifierString, src3ModifierString);*/
			sprintf(buffer, writeMaskStrings[numSourceRegisters - 1], GetOpcodeFunctionString(opcode), destRegisterName, 'z', srcModifierStrings[0], srcModifierStrings[1], srcModifierStrings[2], srcModifierStrings[3]);
			AppendString(shaderbody, buffer);
		}
		if (writeMask & 0x8)
		{
			for (unsigned x = 0; x < numSourceRegisters; ++x)
			{
				PrintSourceRegNameAndSourceSwizzleOrTempReg<3>(*srcParameters[x], destParameter, srcRegisterNames[x], shaderInfo, srcAddrParameters[x]);
				PrintSourceModifier(*srcParameters[x], srcModifierStrings[x], srcRegisterNames[x]);
			}
			/*PrintSourceRegNameAndSourceSwizzleOrTempReg<3>(*srcParameters[0], destParameter, src0RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[0], src0ModifierString, src0RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<3>(*srcParameters[1], destParameter, src1RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[1], src1ModifierString, src1RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<3>(*srcParameters[2], destParameter, src2RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[2], src2ModifierString, src2RegisterName);
			PrintSourceRegNameAndSourceSwizzleOrTempReg<3>(*srcParameters[3], destParameter, src3RegisterName, shaderInfo);
			PrintSourceModifier(*srcParameters[3], src3ModifierString, src3RegisterName);
			sprintf(buffer, "\t%s(%s.w, %s, %s, %s, %s);\n", ShaderInfo::GetOpcodeFunctionString(opcode), destRegisterName, src0ModifierString, src1ModifierString, src2ModifierString, src3ModifierString);*/
			sprintf(buffer, writeMaskStrings[numSourceRegisters - 1], GetOpcodeFunctionString(opcode), destRegisterName, 'w', srcModifierStrings[0], srcModifierStrings[1], srcModifierStrings[2], srcModifierStrings[3]);
			AppendString(shaderbody, buffer);
		}

		if (destParameter.GetResultModifierUnshifted() & D3DSPDM_SATURATE)
		{
			if (writeMask & 0x1)
			{
				sprintf(buffer, "\t%s.x = saturate(%s.x);\n", destRegisterName, destRegisterName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x2)
			{
				sprintf(buffer, "\t%s.y = saturate(%s.y);\n", destRegisterName, destRegisterName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x4)
			{
				sprintf(buffer, "\t%s.z = saturate(%s.z);\n", destRegisterName, destRegisterName);
				AppendString(shaderbody, buffer);
			}
			if (writeMask & 0x8)
			{
				sprintf(buffer, "\t%s.w = saturate(%s.w);\n", destRegisterName, destRegisterName);
				AppendString(shaderbody, buffer);
			}
		}

		AppendString(shaderbody, "\n");
	}
		break;
	default:
		DbgBreakPrint("Error: Unknown shader parameters type");
	}

	return false;
}

static inline const bool ParseShaderInstructions(const ShaderInfo& shaderInfo, std::vector<char>& shaderbody)
{
	const DWORD* currentInstruction = shaderInfo.firstInstructionToken;
	bool doneParsing = false;
	bool usedTempDestRegister = false;
	while (!doneParsing)
	{
		doneParsing = ParseOpcode(currentInstruction, shaderInfo, shaderbody, usedTempDestRegister);
	}

	return true;
}

static inline const bool ShaderBodyJIT(const ShaderInfo& shaderInfo, std::vector<char>& cppfile)
{
	static std::vector<char> shaderbody;
	shaderbody.clear();

	AppendString(shaderbody, "\t// --- Begin shader body ---\n\n");

	if (!ParseShaderInstructions(shaderInfo, shaderbody) )
	{
		return false;
	}

	// ps_1_x shader fixup!
	if (shaderInfo.isPixelShader && shaderInfo.shaderMajorVersion < 2)
	{
		AppendString(shaderbody, "\n\t// ps_1_* output register fixup (because ps_1_* outputs with register r0 instead of into one of the oC[N] registers):\n");
		AppendString(shaderbody, "\tmov(oC0.x, r0.x);\n");
		AppendString(shaderbody, "\tmov(oC0.y, r0.y);\n");
		AppendString(shaderbody, "\tmov(oC0.z, r0.z);\n");
		AppendString(shaderbody, "\tmov(oC0.w, r0.w);\n\n");
	}

	AppendString(shaderbody, "\t// --- End shader body ---\n\n");

	cppfile.insert(cppfile.end(), shaderbody.begin(), shaderbody.end() );

	return true;
}

const bool JITCPPFileInternal(const ShaderInfo& shaderInfo, const char* const shaderFilename)
{
	char filename[MAX_PATH] = {0};
#pragma warning(push)
#pragma warning(disable:4996)
	// Looks like: "shaderjit\ps_3_0_len114_hash0xD9FF5963d.cpp"
	sprintf(filename, "%s\\%s.cpp", shaderJITTempDirectory, shaderFilename);
#pragma warning(pop)
	HANDLE hFile = CreateFileA(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		DbgBreakPrint("Error in CreateFile");
		return false;
	}

	static std::vector<char> cppfile;

	cppfile.clear();

	// Write prefix file
	LoadPrefixFileInternal(cppfile);

	// Append version as a comment:
	{
		char versionBuffer[32] = {0};
		sprintf(versionBuffer, "// Shader version: %cs_%u_%u\n", shaderInfo.isPixelShader ? 'p' : 'v', shaderInfo.shaderMajorVersion, shaderInfo.shaderMinorVersion);
		AppendString(cppfile, versionBuffer);
	}

	// Append version as three compile-time constants:
	{
		char versionBuffer[128] = {0};
		sprintf(versionBuffer, "static const bool IS_PIXEL_SHADER = %s;\n", shaderInfo.isPixelShader ? "true" : "false");
		AppendString(cppfile, versionBuffer);
		sprintf(versionBuffer, "static const unsigned SHADER_MAJOR_VER = %u;\n", shaderInfo.shaderMajorVersion);
		AppendString(cppfile, versionBuffer);
		sprintf(versionBuffer, "static const unsigned SHADER_MINOR_VER = %u;\n", shaderInfo.shaderMinorVersion);
		AppendString(cppfile, versionBuffer);
	}

#ifdef DISASM_SHADER
	if (shaderInfo.D3DXDisasmString != NULL)
	{
		AppendString(cppfile, "/* D3DX Disassembly:\n");
		AppendString(cppfile, shaderInfo.D3DXDisasmString);
		AppendString(cppfile, "*/\n");
	}
#endif // DISASM_SHADER

	if (!shaderInfo.fixedFunctionMacroDefines.empty() )
	{
		AppendString(cppfile, "/* Fixed function shader defines:\n\n");

		const unsigned numDefines = shaderInfo.fixedFunctionMacroDefines.size();
		for (unsigned x = 0; x < numDefines; ++x)
		{
			const D3DXMACRO& shaderDefine = shaderInfo.fixedFunctionMacroDefines[x];
			if (!shaderDefine.Name || !shaderDefine.Definition)
				break;

			AppendString(cppfile, "#define\t");
			AppendString(cppfile, shaderDefine.Name);
			AppendString(cppfile, "\t");
			AppendString(cppfile, shaderDefine.Definition);
			AppendString(cppfile, "\n");
		}

		AppendString(cppfile, "*/\n");
	}

	// Write global static constants for local constant register values
	const unsigned numFloatConsts = shaderInfo.initialConstantValues.size();
	for (unsigned x = 0; x < numFloatConsts; ++x)
	{
		const InitialConstantValue& floatConst = shaderInfo.initialConstantValues[x];
		char floatConstBuffer[128] = {0};
		sprintf(floatConstBuffer, "static const float4 c%u = {%ff, %ff, %ff, %ff};\n", floatConst.constantRegisterIndex, floatConst.initialValue.x, floatConst.initialValue.y, floatConst.initialValue.z, floatConst.initialValue.w);
		AppendString(cppfile, floatConstBuffer);
	}
	const unsigned numIntConsts = shaderInfo.initialConstantValuesI.size();
	for (unsigned x = 0; x < numIntConsts; ++x)
	{
		const InitialConstantValueI& intConst = shaderInfo.initialConstantValuesI[x];
		char intConstBuffer[128] = {0};
		sprintf(intConstBuffer, "static const int4 i%u(%i, %i, %i, %i);\n", intConst.constantRegisterIndex, intConst.initialValue.x, intConst.initialValue.y, intConst.initialValue.z, intConst.initialValue.w);
		AppendString(cppfile, intConstBuffer);
	}
	const unsigned numBoolConsts = shaderInfo.initialConstantValuesB.size();
	for (unsigned x = 0; x < numBoolConsts; ++x)
	{
		const InitialConstantValueB& boolConst = shaderInfo.initialConstantValuesB[x];
		char boolConstBuffer[128] = {0};
		sprintf(boolConstBuffer, "static const BOOL b%u = %s;\n", boolConst.constantRegisterIndex, boolConst.initialValue ? "TRUE" : "FALSE");
		AppendString(cppfile, boolConstBuffer);
	}

	// Write ShaderMain header (PSMain or VSMain)
	if (shaderInfo.isPixelShader)
		AppendString(cppfile, "__declspec(dllexport) void __fastcall PixelShaderMain(PShaderEngine& ps)\n{\n");
	else
		AppendString(cppfile, "__declspec(dllexport) void __fastcall VertexShaderMain(VShaderEngine& vs)\n{\n");

	// Paste all disassembly and shader stats in a multiline comment
	AppendString(cppfile, "\t/*\n");
	{
		char shaderStatsString[1024];
		shaderInfo.PrintShaderStatsToString(shaderStatsString);
		AppendString(cppfile, shaderStatsString);
	}
	AppendString(cppfile, shaderInfo.shaderDisasmBuffer);
	AppendString(cppfile, "\t*/\n");

	// Write shader inputs (v and t registers)
	const unsigned numDeclaredRegs = shaderInfo.declaredRegisters.size();
	for (unsigned x = 0; x < numDeclaredRegs; ++x)
	{
		const DeclaredRegister& thisReg = shaderInfo.declaredRegisters[x];
		if (thisReg.isOutputRegister)
			continue;

		char inputRegBuffer[256] = {0};

		if (shaderInfo.isPixelShader)
		{
			if (shaderInfo.shaderMajorVersion < 3)
			{
				switch (thisReg.registerType)
				{
				default:
					DbgBreakPrint("Error: Unknown register type!");
				case D3DSPR_TEXTURE:
				{
					bool textureRegCanBeConst = true;
					if (shaderInfo.shaderMajorVersion == 1 && shaderInfo.shaderMinorVersion < 4 && shaderInfo.numTexInstructions > 0)
						textureRegCanBeConst = false;
					sprintf(inputRegBuffer, "\t%sfloat4& %c%u = *(%sfloat4* const)&(ps.inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.%c[%u]);\n", 
						textureRegCanBeConst ? "const " : "", 't', thisReg.registerIndex, textureRegCanBeConst ? "const " : "", 't', thisReg.registerIndex);
				}
					break;
				case D3DSPR_SAMPLER:
					sprintf(inputRegBuffer, "\tconst sampler* const s%u = &(ps.constantRegisters->s[%u]);\n", thisReg.registerIndex, thisReg.registerIndex);
					break;
				case D3DSPR_INPUT:
					sprintf(inputRegBuffer, "\tconst float4& %c%u = *(const float4* const)&(ps.inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.%c[%u]);\n", 'v', thisReg.registerIndex, 'v', thisReg.registerIndex);
					break;
				}
			}
			else if (shaderInfo.shaderMajorVersion == 3)
			{
				switch (thisReg.registerType)
				{
				case D3DSPR_MISCTYPE:
					switch (thisReg.registerIndex)
					{
					default:
						DbgBreakPrint("Error: Unknown MISC register index!");
					case D3DSMO_POSITION:
						sprintf(inputRegBuffer, "\tconst float4& vpos%u = *(const float4* const)&(ps.miscRegisters[0].vPos);\n", thisReg.registerIndex); // Technically there's no such thing as VPOS1, VPOS2, etc., but this is for simplicity...
						break;
					case D3DSMO_FACE:
						sprintf(inputRegBuffer, "\tconst float4& vface%u = *(const float4* const)&(ps.miscRegisters[0].vFace);\n", thisReg.registerIndex);
						break;
					}
					break;
				case D3DSPR_SAMPLER:
					sprintf(inputRegBuffer, "\tconst sampler* const s%u = &(ps.constantRegisters->s[%u]);\n", thisReg.registerIndex, thisReg.registerIndex);
					break;
				default:
					DbgBreakPrint("Error: Unknown register type!");
				case D3DSPR_INPUT:
					sprintf(inputRegBuffer, "\tconst float4& v%u = *(const float4* const)&(ps.inputRegisters[0].ps_interpolated_inputs.ps_3_0_inputs.t[%u]);\n", thisReg.registerIndex, thisReg.registerIndex);
					break;
				}
			}
			else
			{
				DbgBreakPrint("Error: Unexpected pixel shader version (not 1, 2, or 3)");
			}
		}
		else
		{
			sprintf(inputRegBuffer, "\tconst float4& v%u = *(const float4* const)&(vs.inputRegisters[0].v[%u]);\n", thisReg.registerIndex, thisReg.registerIndex);
		}

		AppendString(cppfile, inputRegBuffer);
	}

	// ps_1_* shaders don't declare input texcoord registers (v and t registers), so we need to manually add these
	if (shaderInfo.isPixelShader && shaderInfo.shaderMajorVersion < 2)
	{
		bool textureRegCanBeConst = true;
		if (shaderInfo.shaderMinorVersion < 4 && shaderInfo.numTexInstructions > 0)
			textureRegCanBeConst = false;

		char textureRegBuffer[256] = {0};
		for (unsigned char v = 0; v < D3DMCS_COLOR2; ++v)
		{
			if (shaderInfo.inputRegistersUsedBitmask & (1 << v) )
			{
				sprintf(textureRegBuffer, "\tconst float4& %c%u = *(const float4* const)&(ps.inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.%c[%u]);\n", 
					'v', v, 'v', v);
				AppendString(cppfile, textureRegBuffer);
			}
		}
		for (unsigned char t = 0; t < 6; ++t)
		{
			if (shaderInfo.inputRegistersUsedBitmask & (1 << (t + D3DMCS_COLOR2) ) )
			{
				sprintf(textureRegBuffer, "\t%sfloat4& %c%u = *(%sfloat4* const)&(ps.inputRegisters[0].ps_interpolated_inputs.ps_2_0_inputs.%c[%u]);\n", 
					textureRegCanBeConst ? "const " : "", 't', t, textureRegCanBeConst ? "const " : "", 't', t);
				AppendString(cppfile, textureRegBuffer);
			}
		}
	}

	// Declare address register (vertex shaders only):
	if (!shaderInfo.isPixelShader /*TODO: Only do this if the shader uses relative addressing*/)
		AppendString(cppfile, "\tint4& a0 = (vs.runtimeRegisters[0].a);\n");

	// Declare output registers:
	if (shaderInfo.isPixelShader)
	{
		for (unsigned x = 0; x < 4; ++x)
		{
			if (shaderInfo.usedMRTMask & (1 << x) )
			{
				char tempRegBuffer[64] = {0};
				sprintf(tempRegBuffer, "\tfloat4& oC%u = *(float4* const)&(ps.outputRegisters[0].oC[%u]);\n", x, x);
				AppendString(cppfile, tempRegBuffer);
			}
		}

		if (shaderInfo.psWritesDepth)
		{
			AppendString(cppfile, "\tfloat4& oDepth = *(float4* const)&(ps.outputRegisters[0].oDepth);\n");
		}
	}
	else
	{
		const unsigned numWrittenOutputs = shaderInfo.writtenOutputRegisters.size();
		for (unsigned x = 0; x < numWrittenOutputs; ++x)
		{
			char tempRegBuffer[128] = {0};
			const WrittenOutputRegister& thisReg = shaderInfo.writtenOutputRegisters[x];
			if (shaderInfo.shaderMajorVersion < 3)
			{
				switch (thisReg.registerType)
				{
				case D3DSPR_RASTOUT  :
					switch (thisReg.registerIndex)
					{
					default:
						DbgBreakPrint("Error: Unknown vertex shader RASTOUT register index");
					case D3DSRO_POSITION:
						sprintf(tempRegBuffer, "\tfloat4& oPos%u = *(float4* const)&(vs.outputRegisters[0]->oPos);\n", thisReg.registerIndex);
						AppendString(cppfile, tempRegBuffer);
						break;
					case D3DSRO_FOG:
						sprintf(tempRegBuffer, "\tfloat4& oFog%u = *(float4* const)&(vs.outputRegisters[0]->oFog);\n", thisReg.registerIndex);
						AppendString(cppfile, tempRegBuffer);
						break;
					case D3DSRO_POINT_SIZE:
						sprintf(tempRegBuffer, "\tfloat4& oPts%u = *(float4* const)&(vs.outputRegisters[0]->oPts);\n", thisReg.registerIndex);
						AppendString(cppfile, tempRegBuffer);
						break;
					}
					break;
				case D3DSPR_ATTROUT  :
					sprintf(tempRegBuffer, "\tfloat4& oD%u = *(float4* const)&(vs.outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oD[%u]);\n", thisReg.registerIndex, thisReg.registerIndex);
					AppendString(cppfile, tempRegBuffer);
					break;
				case D3DSPR_TEXCRDOUT:
					sprintf(tempRegBuffer, "\tfloat4& oT%u = *(float4* const)&(vs.outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oT[%u]);\n", thisReg.registerIndex, thisReg.registerIndex);
					AppendString(cppfile, tempRegBuffer);
					break;
				default:
					break;
				}
			}
			else
			{
				sprintf(tempRegBuffer, "\tfloat4& oT%u = *(float4* const)&(vs.outputRegisters[0]->vs_interpolated_outputs.vs_3_0_outputs.oT[%u]);\n", thisReg.registerIndex, thisReg.registerIndex);
				AppendString(cppfile, tempRegBuffer);
			}
		}
	}

	// Declare used non-immediate float const registers
	const unsigned numUsedConstF = shaderInfo.usedConstantsF.size();
	for (unsigned x = 0; x < numUsedConstF; ++x)
	{
		const unsigned usedConstF = shaderInfo.usedConstantsF[x];
		if (IsConstantGlobal(usedConstF, shaderInfo.initialConstantValues) )
		{
			char tempRegBuffer[96] = {0};
			sprintf(tempRegBuffer, "\tconst float4& c%u = *(const float4* const)&(%cs.constantRegisters->c[%u]);\n", usedConstF, shaderInfo.isPixelShader ? 'p' : 'v', usedConstF);
			AppendString(cppfile, tempRegBuffer);
		}
	}

	// Declare used non-immediate int const registers
	const unsigned numUsedConstI = shaderInfo.usedConstantsI.size();
	for (unsigned x = 0; x < numUsedConstI; ++x)
	{
		const unsigned usedConstI = shaderInfo.usedConstantsI[x];
		if (IsConstantGlobal(usedConstI, shaderInfo.initialConstantValuesI) )
		{
			char tempRegBuffer[96] = {0};
			sprintf(tempRegBuffer, "\tconst int4& i%u = %cs.constantRegisters->i[%u];\n", usedConstI, shaderInfo.isPixelShader ? 'p' : 'v', usedConstI);
			AppendString(cppfile, tempRegBuffer);
		}
	}

	// Declare used non-immediate bool const registers
	const unsigned numUsedConstB = shaderInfo.usedConstantsB.size();
	for (unsigned x = 0; x < numUsedConstB; ++x)
	{
		const unsigned usedConstB = shaderInfo.usedConstantsB[x];
		if (IsConstantGlobal(usedConstB, shaderInfo.initialConstantValuesB) )
		{
			char tempRegBuffer[96] = {0};
			sprintf(tempRegBuffer, "\tconst BOOL& b%u = %cs.constantRegisters->b[%u];\n", usedConstB, shaderInfo.isPixelShader ? 'p' : 'v', usedConstB);
			AppendString(cppfile, tempRegBuffer);
		}
	}

	// Declare used temp. registers (r registers)
	for (unsigned i = 0; i < 32; ++i)
	{
		if (shaderInfo.tempRegistersUsedBitmask & (1 << i) )
		{
			char tempRegBuffer[32] = {0};
			sprintf(tempRegBuffer, "\tfloat4 r%u;\n", i);
			AppendString(cppfile, tempRegBuffer);
		}
	}
	
	// Actual shader JIT work goes here
	if (!ShaderBodyJIT(shaderInfo, cppfile) )
	{
		DbgBreakPrint("Error in shader JIT main process");
		return false;
	}
	
	// Append suffix (return, closing braces)
	if (shaderInfo.isPixelShader)
	{
		AppendString(cppfile, "\tps.outputRegisters[0].pixelStatus = normalWrite;\n");
	}
	AppendString(cppfile, "} // end shadermain\n"); // Close the function brace
	AppendString(cppfile, "\n} // end extern \"C\"\n"); // Close the extern "C" brace

	// Write the file
	DWORD numBytesWritten = 0;
	if (!WriteFile(hFile, &(cppfile.front() ), cppfile.size(), &numBytesWritten, NULL) )
	{
		DbgBreakPrint("Error in WriteFile");
	}

	if (cppfile.size() != numBytesWritten)
	{
		DbgBreakPrint("Error: Num bytes written doesn't match for cpp file");
	}

	if (!CloseHandle(hFile) )
	{
		DbgBreakPrint("Error in CloseHandle");
		return false;
	}

	return true;
}

#pragma warning(pop)

```

`Software_d3d9/ShaderJIT_HLSL_to_CPP_Tables.h`:

```h
#pragma once

static const bool opcodeAllowChannelSplitting[D3DSHADER_INSTRUCTION_OPCODE_TYPE::D3DSIO_BREAKP + 1] =
{
	true, //D3DSIO_NOP          = 0,
    true, //D3DSIO_MOV          ,
	true, //D3DSIO_ADD          ,
    true, //D3DSIO_SUB          ,
    true, //D3DSIO_MAD          ,
    true, //D3DSIO_MUL          ,
    true, //D3DSIO_RCP          ,
    true, //D3DSIO_RSQ          ,
	false, //D3DSIO_DP3          ,
    false, //D3DSIO_DP4          ,
    true, //D3DSIO_MIN          ,
    true, //D3DSIO_MAX          ,
    true, //D3DSIO_SLT          ,
    true, //D3DSIO_SGE          ,
    true, //D3DSIO_EXP          ,
    true, //D3DSIO_LOG          ,
    true, //D3DSIO_LIT          ,
    false, //D3DSIO_DST          ,
	true, //D3DSIO_LRP          ,
    true, //D3DSIO_FRC          ,
    false, //D3DSIO_M4x4         ,
    false, //D3DSIO_M4x3         ,
    false, //D3DSIO_M3x4         ,
    false, //D3DSIO_M3x3         ,
    false, //D3DSIO_M3x2         ,
    true, //D3DSIO_CALL         ,
    true, //D3DSIO_CALLNZ       ,
    true, //D3DSIO_LOOP         ,
    true, //D3DSIO_RET          ,
    true, //D3DSIO_ENDLOOP      ,
    true, //D3DSIO_LABEL        ,
    true, //D3DSIO_DCL          ,
    true, //D3DSIO_POW          ,
    false, //D3DSIO_CRS          ,
    true, //D3DSIO_SGN          ,
    true, //D3DSIO_ABS          ,
	false, //D3DSIO_NRM          ,
    false, //D3DSIO_SINCOS       ,
    true, //D3DSIO_REP          ,
    true, //D3DSIO_ENDREP       ,
    true, //D3DSIO_IF           ,
    true, //D3DSIO_IFC          ,
    true, //D3DSIO_ELSE         ,
    true, //D3DSIO_ENDIF        ,
    true, //D3DSIO_BREAK        ,
    true, //D3DSIO_BREAKC       ,
    true, //D3DSIO_MOVA         ,
    true, //D3DSIO_DEFB         ,
    true, //D3DSIO_DEFI         ,

	true,
	true,
	true,
	true,
	true,
	true,
	true,
	true,
	true,
	true,
	true,
	true,
	true,
	true,
	true,

    false, //D3DSIO_TEXCOORD     = 64,
    true, //D3DSIO_TEXKILL      ,
    false, //D3DSIO_TEX          ,
    false, //D3DSIO_TEXBEM       ,
    false, //D3DSIO_TEXBEML      ,
    false, //D3DSIO_TEXREG2AR    ,
    false, //D3DSIO_TEXREG2GB    ,
    false, //D3DSIO_TEXM3x2PAD   ,
    false, //D3DSIO_TEXM3x2TEX   ,
    false, //D3DSIO_TEXM3x3PAD   ,
    false, //D3DSIO_TEXM3x3TEX   ,
    true, //D3DSIO_RESERVED0    ,
    false, //D3DSIO_TEXM3x3SPEC  ,
    false, //D3DSIO_TEXM3x3VSPEC ,
    true, //D3DSIO_EXPP         ,
    true, //D3DSIO_LOGP         ,
    true, //D3DSIO_CND          ,
    true, //D3DSIO_DEF          ,
    false, //D3DSIO_TEXREG2RGB   ,
    false, //D3DSIO_TEXDP3TEX    ,
    false, //D3DSIO_TEXM3x2DEPTH ,
	false, //D3DSIO_TEXDP3       ,
    false, //D3DSIO_TEXM3x3      ,
    false, //D3DSIO_TEXDEPTH     ,
    true, //D3DSIO_CMP          ,
    true, //D3DSIO_BEM          ,
    false, //D3DSIO_DP2ADD       ,
    true, //D3DSIO_DSX          ,
    true, //D3DSIO_DSY          ,
    false, //D3DSIO_TEXLDD       ,
    true, //D3DSIO_SETP         ,
    true, //D3DSIO_TEXLDL       ,
    true, //D3DSIO_BREAKP       ,
};

static const bool opcodeAllChannelsBroadcastSameVal[D3DSHADER_INSTRUCTION_OPCODE_TYPE::D3DSIO_BREAKP + 1] =
{
	false, //D3DSIO_NOP          = 0,
    false, //D3DSIO_MOV          ,
	false, //D3DSIO_ADD          ,
    false, //D3DSIO_SUB          ,
    false, //D3DSIO_MAD          ,
    false, //D3DSIO_MUL          ,
    true, //D3DSIO_RCP          ,
    true, //D3DSIO_RSQ          ,
	true, //D3DSIO_DP3          ,
    true, //D3DSIO_DP4          ,
    false, //D3DSIO_MIN          ,
    false, //D3DSIO_MAX          ,
    false, //D3DSIO_SLT          ,
    false, //D3DSIO_SGE          ,
    false, //D3DSIO_EXP          ,
    true, //D3DSIO_LOG          ,
    false, //D3DSIO_LIT          ,
    true, //D3DSIO_DST          ,
	false, //D3DSIO_LRP          ,
    false, //D3DSIO_FRC          ,
    false, //D3DSIO_M4x4         ,
    false, //D3DSIO_M4x3         ,
    false, //D3DSIO_M3x4         ,
    false, //D3DSIO_M3x3         ,
    false, //D3DSIO_M3x2         ,
    false, //D3DSIO_CALL         ,
    false, //D3DSIO_CALLNZ       ,
    false, //D3DSIO_LOOP         ,
    false, //D3DSIO_RET          ,
    false, //D3DSIO_ENDLOOP      ,
    false, //D3DSIO_LABEL        ,
    false, //D3DSIO_DCL          ,
    true, //D3DSIO_POW          ,
    false, //D3DSIO_CRS          ,
    false, //D3DSIO_SGN          ,
    false, //D3DSIO_ABS          ,
	false, //D3DSIO_NRM          ,
    false, //D3DSIO_SINCOS       ,
    false, //D3DSIO_REP          ,
    false, //D3DSIO_ENDREP       ,
    false, //D3DSIO_IF           ,
    false, //D3DSIO_IFC          ,
    false, //D3DSIO_ELSE         ,
    false, //D3DSIO_ENDIF        ,
    false, //D3DSIO_BREAK        ,
    false, //D3DSIO_BREAKC       ,
    false, //D3DSIO_MOVA         ,
    false, //D3DSIO_DEFB         ,
    false, //D3DSIO_DEFI         ,

	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,

    false, //D3DSIO_TEXCOORD     = 64,
    false, //D3DSIO_TEXKILL      ,
    false, //D3DSIO_TEX          ,
    false, //D3DSIO_TEXBEM       ,
    false, //D3DSIO_TEXBEML      ,
    false, //D3DSIO_TEXREG2AR    ,
    false, //D3DSIO_TEXREG2GB    ,
    false, //D3DSIO_TEXM3x2PAD   ,
    false, //D3DSIO_TEXM3x2TEX   ,
    false, //D3DSIO_TEXM3x3PAD   ,
    false, //D3DSIO_TEXM3x3TEX   ,
    false, //D3DSIO_RESERVED0    ,
    false, //D3DSIO_TEXM3x3SPEC  ,
    false, //D3DSIO_TEXM3x3VSPEC ,
    true, //D3DSIO_EXPP         ,
    true, //D3DSIO_LOGP         ,
    false, //D3DSIO_CND          ,
    false, //D3DSIO_DEF          ,
    false, //D3DSIO_TEXREG2RGB   ,
    false, //D3DSIO_TEXDP3TEX    ,
    false, //D3DSIO_TEXM3x2DEPTH ,
	false, //D3DSIO_TEXDP3       ,
    false, //D3DSIO_TEXM3x3      ,
    false, //D3DSIO_TEXDEPTH     ,
    false, //D3DSIO_CMP          ,
    false, //D3DSIO_BEM          ,
    false, //D3DSIO_DP2ADD       ,
    false, //D3DSIO_DSX          ,
    false, //D3DSIO_DSY          ,
    false, //D3DSIO_TEXLDD       ,
    false, //D3DSIO_SETP         ,
    false, //D3DSIO_TEXLDL       ,
    false, //D3DSIO_BREAKP       ,
};

static const bool opcodeImplementedForJIT[D3DSHADER_INSTRUCTION_OPCODE_TYPE::D3DSIO_BREAKP + 1] =
{
	true, //D3DSIO_NOP          = 0,
    true, //D3DSIO_MOV          ,
	true, //D3DSIO_ADD          ,
    true, //D3DSIO_SUB          ,
    true, //D3DSIO_MAD          ,
    true, //D3DSIO_MUL          ,
    true, //D3DSIO_RCP          ,
    true, //D3DSIO_RSQ          ,
	true, //D3DSIO_DP3          ,
    true, //D3DSIO_DP4          ,
    true, //D3DSIO_MIN          ,
    true, //D3DSIO_MAX          ,
    true, //D3DSIO_SLT          ,
    true, //D3DSIO_SGE          ,
    true, //D3DSIO_EXP          ,
    true, //D3DSIO_LOG          ,
    true, //D3DSIO_LIT          ,
    true, //D3DSIO_DST          ,
	true, //D3DSIO_LRP          ,
    true, //D3DSIO_FRC          ,
    true, //D3DSIO_M4x4         ,
    true, //D3DSIO_M4x3         ,
    true, //D3DSIO_M3x4         ,
    true, //D3DSIO_M3x3         ,
    true, //D3DSIO_M3x2         ,
    false, //D3DSIO_CALL         ,
    false, //D3DSIO_CALLNZ       ,
    false, //D3DSIO_LOOP         ,
    false, //D3DSIO_RET          ,
    false, //D3DSIO_ENDLOOP      ,
    false, //D3DSIO_LABEL        ,
    true, //D3DSIO_DCL          ,
    true, //D3DSIO_POW          ,
    true, //D3DSIO_CRS          ,
    true, //D3DSIO_SGN          ,
    true, //D3DSIO_ABS          ,
	true, //D3DSIO_NRM          ,
    false, //D3DSIO_SINCOS       ,
    false, //D3DSIO_REP          ,
    false, //D3DSIO_ENDREP       ,
    false, //D3DSIO_IF           ,
    false, //D3DSIO_IFC          ,
    false, //D3DSIO_ELSE         ,
    false, //D3DSIO_ENDIF        ,
    false, //D3DSIO_BREAK        ,
    false, //D3DSIO_BREAKC       ,
    false, //D3DSIO_MOVA         ,
    true, //D3DSIO_DEFB         ,
    true, //D3DSIO_DEFI         ,

	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,

    false, //D3DSIO_TEXCOORD     = 64,
    true, //D3DSIO_TEXKILL      ,
    true, //D3DSIO_TEX          ,
    false, //D3DSIO_TEXBEM       ,
    false, //D3DSIO_TEXBEML      ,
    false, //D3DSIO_TEXREG2AR    ,
    false, //D3DSIO_TEXREG2GB    ,
    false, //D3DSIO_TEXM3x2PAD   ,
    false, //D3DSIO_TEXM3x2TEX   ,
    false, //D3DSIO_TEXM3x3PAD   ,
    false, //D3DSIO_TEXM3x3TEX   ,
    false, //D3DSIO_RESERVED0    ,
    false, //D3DSIO_TEXM3x3SPEC  ,
    false, //D3DSIO_TEXM3x3VSPEC ,
    true, //D3DSIO_EXPP         ,
    true, //D3DSIO_LOGP         ,
    false, //D3DSIO_CND          ,
    false, //D3DSIO_DEF          ,
    false, //D3DSIO_TEXREG2RGB   ,
    false, //D3DSIO_TEXDP3TEX    ,
    false, //D3DSIO_TEXM3x2DEPTH ,
	false, //D3DSIO_TEXDP3       ,
    false, //D3DSIO_TEXM3x3      ,
    false, //D3DSIO_TEXDEPTH     ,
    true, //D3DSIO_CMP          ,
    false, //D3DSIO_BEM          ,
    true, //D3DSIO_DP2ADD       ,
    false, //D3DSIO_DSX          ,
    false, //D3DSIO_DSY          ,
    false, //D3DSIO_TEXLDD       ,
    false, //D3DSIO_SETP         ,
    false, //D3DSIO_TEXLDL       ,
    false, //D3DSIO_BREAKP       ,
};
```

`Software_d3d9/ShaderJIT_PrefixFile.cpp`:

```cpp
#pragma once

#undef UNICODE
#undef _UNICODE
#define WIN32_LEAN_AND_MEAN

// Needed for DisableThreadLibraryCalls()
#pragma comment(lib, "Kernel32.lib")

// TODO: Don't hardcode these paths, it won't work on other people's computers as-is
#include "C:\\Users\\Tom\\Documents\\Visual Studio 2013\\Projects\\Software_d3d9\\trunk\\Software_d3d9\\VShaderEngine.h"
#include "C:\\Users\\Tom\\Documents\\Visual Studio 2013\\Projects\\Software_d3d9\\trunk\\Software_d3d9\\PShaderEngine.h"
#include "C:\\Users\\Tom\\Documents\\Visual Studio 2013\\Projects\\Software_d3d9\\trunk\\Software_d3d9\\ShaderAnalysis.h"
#include "C:\\Users\\Tom\\Documents\\Visual Studio 2013\\Projects\\Software_d3d9\\trunk\\Software_d3d9\\IDirect3DDevice9Hook.h"
#include "C:\\Users\\Tom\\Documents\\Visual Studio 2013\\Projects\\Software_d3d9\\trunk\\Software_d3d9\\IDirect3DPixelShader9Hook.h"
#include "C:\\Users\\Tom\\Documents\\Visual Studio 2013\\Projects\\Software_d3d9\\trunk\\Software_d3d9\\IDirect3DVertexShader9Hook.h"
#include "C:\\Users\\Tom\\Documents\\Visual Studio 2013\\Projects\\Software_d3d9\\trunk\\Software_d3d9\\IDirect3DTexture9Hook.h"

#pragma pack(1)

extern "C" {

// This dummy symbol is needed if we're not linking against the CRT
int _fltused = 0;

BOOL WINAPI DllMain(HINSTANCE hInst, DWORD reason, LPVOID)
{
	switch (reason)
	{
	case DLL_PROCESS_ATTACH:
		DisableThreadLibraryCalls(hInst);
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}

// ShaderMain goes here

```

`Software_d3d9/ShaderTextureFunctions.cpp`:

```cpp
#pragma once

#include "d3d9include.h"
#include "ShaderEngineBase.h"
#include "IDirect3DTexture9Hook.h"

template void __fastcall tex2Dmip0<0>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<1>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<2>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<3>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<4>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<5>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<6>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<7>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<8>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<9>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<10>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<11>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<12>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<13>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<14>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);
template void __fastcall tex2Dmip0<15>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr);

template <const unsigned char writeMask>
void __fastcall tex2Dmip0(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const sampler* const samplerPtr)
{
	if (samplerPtr->texture)
		samplerPtr->texture->SampleTextureLoD<writeMask>(texCoord.x, texCoord.y, 0.0f, samplerPtr->samplerState, outVal);
	else
	{
		// D3D9 seems to treat sampling from a NULL sampler as opaque white (this is the case in the OpenGL standard), even though
		// in D3D10 they changed this to instead return transparent black!
		outVal = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
	}
}

template void __fastcall tex2Dlod<0>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<1>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<2>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<3>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<4>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<5>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<6>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<7>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<8>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<9>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<10>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<11>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<12>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<13>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<14>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);
template void __fastcall tex2Dlod<15>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr);

template <const unsigned char writeMask>
void __fastcall tex2Dlod(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoordAndLoD, const sampler* const samplerPtr)
{
	if (samplerPtr->texture)
		samplerPtr->texture->SampleTextureLoD<writeMask>(texCoordAndLoD.x, texCoordAndLoD.y, texCoordAndLoD.w, samplerPtr->samplerState, outVal);
	else
	{
		// D3D9 seems to treat sampling from a NULL sampler as opaque white (this is the case in the OpenGL standard), even though
		// in D3D10 they changed this to instead return transparent black!
		outVal = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
	}
}

template void __fastcall tex2Dgrad<0, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<1, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<2, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<3, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<4, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<5, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<6, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<7, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<8, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<9, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<10, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<11, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<12, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<13, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<14, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<15, false>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<0, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<1, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<2, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<3, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<4, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<5, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<6, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<7, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<8, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<9, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<10, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<11, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<12, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<13, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<14, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);
template void __fastcall tex2Dgrad<15, true>(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr);

template <const unsigned char writeMask, const bool useTexCoordMipBias>
void __fastcall tex2Dgrad(D3DXVECTOR4& outVal, const D3DXVECTOR4& texCoord, const D3DXVECTOR4& texDdx, const D3DXVECTOR4& texDdy, const sampler* const samplerPtr)
{
	if (samplerPtr->texture)
	{
		if (useTexCoordMipBias)
			samplerPtr->texture->SampleTextureGradBias<writeMask>(texCoord.x, texCoord.y, texCoord.w, texDdx, texDdy, samplerPtr->samplerState, outVal);
		else
			samplerPtr->texture->SampleTextureGrad<writeMask>(texCoord.x, texCoord.y, texDdx, texDdy, samplerPtr->samplerState, outVal);
	}
	else
	{
		// D3D9 seems to treat sampling from a NULL sampler as opaque white (this is the case in the OpenGL standard), even though
		// in D3D10 they changed this to instead return transparent black!
		outVal = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
	}
}

```

`Software_d3d9/ShaderTextureFunctions4.cpp`:

```cpp
#pragma once

#include "d3d9include.h"
#include "ShaderEngineBase.h"
#include "IDirect3DTexture9Hook.h"

template void __cdecl tex2Dmip0_4<0>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<1>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<2>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<3>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<4>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<5>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<6>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<7>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<8>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<9>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<10>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<11>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<12>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<13>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<14>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dmip0_4<15>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr);

template <const unsigned char writeMask>
void __cdecl tex2Dmip0_4(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const sampler* const samplerPtr)
{
	if (samplerPtr->texture)
	{
		float x4[4] =
		{
			texCoord[0].x,
			texCoord[1].x,
			texCoord[2].x,
			texCoord[3].x
		};
		float y4[4] =
		{
			texCoord[0].y,
			texCoord[1].y,
			texCoord[2].y,
			texCoord[3].y
		};
		float zeroFloat4[4] = 
		{
			0.0f,
			0.0f,
			0.0f,
			0.0f
		};
		samplerPtr->texture->SampleTextureLoD4<writeMask>(x4, y4, zeroFloat4, samplerPtr->samplerState, outVal4);
	}
	else
	{
		// D3D9 seems to treat sampling from a NULL sampler as opaque white (this is the case in the OpenGL standard), even though
		// in D3D10 they changed this to instead return transparent black!
		outVal4[0] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
		outVal4[1] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
		outVal4[2] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
		outVal4[3] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
	}
}

template void __cdecl tex2Dlod4<0>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<1>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<2>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<3>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<4>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<5>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<6>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<7>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<8>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<9>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<10>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<11>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<12>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<13>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<14>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dlod4<15>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr);

template <const unsigned char writeMask>
void __cdecl tex2Dlod4(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoordAndLoD)[4], const sampler* const samplerPtr)
{
	if (samplerPtr->texture)
	{
		float x4[4] =
		{
			texCoordAndLoD[0].x,
			texCoordAndLoD[1].x,
			texCoordAndLoD[2].x,
			texCoordAndLoD[3].x
		};
		float y4[4] =
		{
			texCoordAndLoD[0].y,
			texCoordAndLoD[1].y,
			texCoordAndLoD[2].y,
			texCoordAndLoD[3].y
		};
		float mipFloat4[4] =
		{
			texCoordAndLoD[0].w,
			texCoordAndLoD[1].w,
			texCoordAndLoD[2].w,
			texCoordAndLoD[3].w
		};
		samplerPtr->texture->SampleTextureLoD4<writeMask>(x4, y4, mipFloat4, samplerPtr->samplerState, outVal4);
	}
	else
	{
		// D3D9 seems to treat sampling from a NULL sampler as opaque white (this is the case in the OpenGL standard), even though
		// in D3D10 they changed this to instead return transparent black!
		outVal4[0] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
		outVal4[1] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
		outVal4[2] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
		outVal4[3] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
	}
}

template void __cdecl tex2Dgrad4<0, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<1, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<2, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<3, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<4, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<5, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<6, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<7, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<8, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<9, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<10, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<11, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<12, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<13, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<14, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<15, false>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<0, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<1, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<2, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<3, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<4, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<5, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<6, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<7, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<8, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<9, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<10, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<11, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<12, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<13, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<14, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);
template void __cdecl tex2Dgrad4<15, true>(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr);

template <const unsigned char writeMask, const bool useTexCoordMipBias>
void __cdecl tex2Dgrad4(D3DXVECTOR4 (&outVal4)[4], const D3DXVECTOR4 (&texCoord)[4], const D3DXVECTOR4 (&texDdx4)[4], const D3DXVECTOR4 (&texDdy4)[4], const sampler* const samplerPtr)
{
	if (samplerPtr->texture)
	{
		float x4[4] =
		{
			texCoord[0].x,
			texCoord[1].x,
			texCoord[2].x,
			texCoord[3].x
		};
		float y4[4] =
		{
			texCoord[0].y,
			texCoord[1].y,
			texCoord[2].y,
			texCoord[3].y
		};

		if (useTexCoordMipBias)
		{
			const float mipBias4[4] =
			{
				texCoord[0].w,
				texCoord[1].w,
				texCoord[2].w,
				texCoord[3].w
			};
			samplerPtr->texture->SampleTextureGradBias4<writeMask>(x4, y4, mipBias4, texDdx4, texDdy4, samplerPtr->samplerState, outVal4);
		}
		else
			samplerPtr->texture->SampleTextureGrad4<writeMask>(x4, y4, texDdx4, texDdy4, samplerPtr->samplerState, outVal4);
	}
	else
	{
		// D3D9 seems to treat sampling from a NULL sampler as opaque white (this is the case in the OpenGL standard), even though
		// in D3D10 they changed this to instead return transparent black!
		outVal4[0] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
		outVal4[1] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
		outVal4[2] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
		outVal4[3] = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
	}
}

```

`Software_d3d9/SimpleInstrumentedProfiler.h`:

```h
#pragma once

#define ENABLE_SIMPLE_PROFILER 0

#ifdef _M_X64 // The new PIX profiler only works for x64 targets
	#define ENABLE_PIX_PROFILER 1
#endif

#if ENABLE_SIMPLE_PROFILER
	// TODO: Don't hardcode this path
	#include "C:\\Users\\Tom\\Documents\\Visual Studio 2017\\Projects\\SimpleHFileProfiler\\SimpleHFileProfiler\\SimpleProfiler.h"
#elif ENABLE_PIX_PROFILER
	#define USE_PIX 1
	// TODO: Don't hardcode this path
	#include "C:\\Users\\Tom\\Documents\\Visual Studio 2013\\Projects\\Software_d3d9\\trunk\\Software_d3d9\\WinPixEventRuntime\\pix3.h"
	#pragma comment(lib, "C:\\Users\\Tom\\Documents\\Visual Studio 2013\\Projects\\Software_d3d9\\trunk\\Software_d3d9\\WinPixEventRuntime\\WinPixEventRuntime.lib")

	#define SIMPLE_DYNAMIC_STRING_SCOPE(dynamicStringScopeName) PIXScopedEvent(PIX_COLOR_DEFAULT, dynamicStringScopeName)
	#define SIMPLE_NAME_SCOPE(scopeName) PIXScopedEvent(PIX_COLOR_DEFAULT, scopeName)
	#define SIMPLE_FUNC_SCOPE() PIXScopedEvent(PIX_COLOR_DEFAULT, __FUNCTION__)
	#define SIMPLE_FRAME_END_MARKER() PIXSetMarker(PIX_COLOR_DEFAULT, "END FRAME MARKER")
	struct PIX_CONDITIONAL_SCOPE_WRAPPER
	{
		PIX_CONDITIONAL_SCOPE_WRAPPER(const char* const scopeName, const bool _conditional) : conditional(_conditional)
		{ 
			if (conditional == true) 
			{
				PIXBeginEvent(PIX_COLOR_DEFAULT, scopeName);
			}
		}
		~PIX_CONDITIONAL_SCOPE_WRAPPER()
		{
			if (conditional == true)
			{
				PIXEndEvent();
			}
		}
	private:
		const bool conditional;
	};
	#define SIMPLE_DYNAMIC_STRING_SCOPE_CONDITIONAL(dynamicStringScopeName, conditional) PIX_CONDITIONAL_SCOPE_WRAPPER _conditionalAutoNameDynamicNameScope(dynamicStringScopeName, (conditional) )
	#define SIMPLE_NAME_SCOPE_CONDITIONAL(scopeName, conditional) PIX_CONDITIONAL_SCOPE_WRAPPER _conditionalAutoNameDynamicNameScope(scopeName, (conditional) )
	#define SIMPLE_FUNC_SCOPE_CONDITIONAL(conditional) PIX_CONDITIONAL_SCOPE_WRAPPER _conditionalAutoNameDynamicNameScope(__FUNCTION__, (conditional) )
#else
	#define SIMPLE_DYNAMIC_STRING_SCOPE(dynamicStringScopeName) dynamicStringScopeName
	#define SIMPLE_DYNAMIC_STRING_SCOPE_CONDITIONAL(dynamicStringScopeName, conditional) dynamicStringScopeName; (conditional)
	#define SIMPLE_NAME_SCOPE(scopeName) scopeName
	#define SIMPLE_NAME_SCOPE_CONDITIONAL(scopeName, conditional) scopeName; (conditional)
	#define SIMPLE_FUNC_SCOPE()
	#define SIMPLE_FUNC_SCOPE_CONDITIONAL(conditional) (conditional)
	#define SIMPLE_FRAME_END_MARKER()
#endif

```

`Software_d3d9/Software_d3d9.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FFDB895B-11C0-4996-8C2E-194D85FFFAE6}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Software_d3d9</RootNamespace>
    <ProjectName>d3d9</ProjectName>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;D3D9PROXYDLL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>Source.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;D3D9PROXYDLL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>Source.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;D3D9PROXYDLL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <StringPooling>true</StringPooling>
      <AssemblerOutput>NoListing</AssemblerOutput>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>Source.def</ModuleDefinitionFile>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;D3D9PROXYDLL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <StringPooling>true</StringPooling>
      <AssemblerOutput>NoListing</AssemblerOutput>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>Source.def</ModuleDefinitionFile>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="FixedFunctionToPixelShader.cpp" />
    <ClCompile Include="FixedFunctionToShader.cpp" />
    <ClCompile Include="FixedFunctionToVertexShader.cpp" />
    <ClCompile Include="hookd3d9.cpp" />
    <ClCompile Include="IDirect3D9Hook.cpp" />
    <ClCompile Include="IDirect3DBaseTexture9Hook.cpp" />
    <ClCompile Include="IDirect3DCubeTexture9Hook.cpp" />
    <ClCompile Include="IDirect3DDevice9Hook.cpp" />
    <ClCompile Include="IDirect3DDevice9Hook_Accessors.cpp" />
    <ClCompile Include="IDirect3DDevice9Hook_Creators.cpp" />
    <ClCompile Include="IDirect3DIndexBuffer9Hook.cpp" />
    <ClCompile Include="IDirect3DPixelShader9Hook.cpp" />
    <ClCompile Include="IDirect3DQuery9Hook.cpp" />
    <ClCompile Include="IDirect3DResource9Hook.cpp" />
    <ClCompile Include="IDirect3DStateBlock9Hook.cpp" />
    <ClCompile Include="IDirect3DSurface9Hook.cpp" />
    <ClCompile Include="IDirect3DSwapChain9Hook.cpp" />
    <ClCompile Include="IDirect3DTexture9Hook.cpp" />
    <ClCompile Include="IDirect3DVertexBuffer9Hook.cpp" />
    <ClCompile Include="IDirect3DVertexDeclaration9Hook.cpp" />
    <ClCompile Include="IDirect3DVertexShader9Hook.cpp" />
    <ClCompile Include="IDirect3DVolume9Hook.cpp" />
    <ClCompile Include="IDirect3DVolumeTexture9Hook.cpp" />
    <ClCompile Include="Overlay\DebugOverlay.cpp" />
    <ClCompile Include="Overlay\Overlay_DeviceState.cpp" />
    <ClCompile Include="Overlay\Overlay_WelcomeScreen.cpp" />
    <ClCompile Include="PShaderEngine.cpp" />
    <ClCompile Include="SemanticMappings.cpp" />
    <ClCompile Include="ShaderAnalysis.cpp" />
    <ClCompile Include="ShaderTextureFunctions.cpp" />
    <ClCompile Include="ShaderJIT.cpp" />
    <ClCompile Include="ShaderTextureFunctions4.cpp" />
    <ClCompile Include="VShaderEngine_InterpreterExec1.cpp" />
    <ClCompile Include="VShaderEngine_InterpreterExec4.cpp" />
    <None Include="FixedFuncEmu\FFPS\Include\FFPS_ApplyColorStage.fxh" />
    <None Include="FixedFuncEmu\FFPS\Include\FFPS_ArgumentSelector.fxh" />
    <None Include="FixedFuncEmu\FFPS\Include\FFPS_TexLoad.fxh" />
    <None Include="ShaderJIT_PrefixFile.cpp" />
    <ClCompile Include="ShaderJIT_HLSL_to_CPP.cpp" />
    <ClCompile Include="VShaderEngine.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Source.def" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="d3d9include.h" />
    <ClInclude Include="DebuggableEnums.h" />
    <ClInclude Include="DeviceState.h" />
    <ClInclude Include="DitherTables.h" />
    <ClInclude Include="FixedFunctionToShader.h" />
    <ClInclude Include="GlobalToggles.h" />
    <ClInclude Include="IDirect3D9Hook.h" />
    <ClInclude Include="IDirect3DBaseTexture9Hook.h" />
    <ClInclude Include="IDirect3DCubeTexture9Hook.h" />
    <ClInclude Include="IDirect3DDevice9Hook.h" />
    <ClInclude Include="IDirect3DIndexBuffer9Hook.h" />
    <ClInclude Include="IDirect3DPixelShader9Hook.h" />
    <ClInclude Include="IDirect3DQuery9Hook.h" />
    <ClInclude Include="IDirect3DResource9Hook.h" />
    <ClInclude Include="IDirect3DStateBlock9Hook.h" />
    <ClInclude Include="IDirect3DSurface9Hook.h" />
    <ClInclude Include="IDirect3DSwapChain9Hook.h" />
    <ClInclude Include="IDirect3DTexture9Hook.h" />
    <ClInclude Include="IDirect3DVertexBuffer9Hook.h" />
    <ClInclude Include="IDirect3DVertexDeclaration9Hook.h" />
    <ClInclude Include="IDirect3DVertexShader9Hook.h" />
    <ClInclude Include="IDirect3DVolume9Hook.h" />
    <ClInclude Include="IDirect3DVolumeTexture9Hook.h" />
    <ClInclude Include="Overlay\DebugOverlay.h" />
    <ClInclude Include="PShaderEngine.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="SemanticMappings.h" />
    <ClInclude Include="ShaderAnalysis.h" />
    <ClInclude Include="ShaderBase.h" />
    <ClInclude Include="ShaderEngineBase.h" />
    <ClInclude Include="ShaderIntrinsicFunctions.h" />
    <ClInclude Include="ShaderIntrinsicFunctions4.h" />
    <ClInclude Include="ShaderJIT.h" />
    <ClInclude Include="ShaderJIT_HLSL_to_CPP_Tables.h" />
    <ClInclude Include="SimpleInstrumentedProfiler.h" />
    <ClInclude Include="VShaderEngine.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="FixedFuncEmu\FFPS\Source\FixedFunctionPixelShader.hlsl">
      <FileType>Document</FileType>
    </None>
    <None Include="FixedFuncEmu\FFVS\Include\FFVS_CalculateSingleLight.fxh">
      <FileType>Document</FileType>
    </None>
    <FxCompile Include="FixedFuncEmu\FFVS\Source\FixedFunctionVertexShader.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">3.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">3.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">3.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">3.0</ShaderModel>
      <AssemblerOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AssemblyCode</AssemblerOutput>
      <AssemblerOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AssemblyCode</AssemblerOutput>
      <AssemblerOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(OutDir)%(Filename).asm</AssemblerOutputFile>
      <AssemblerOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(OutDir)%(Filename).asm</AssemblerOutputFile>
      <AssemblerOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AssemblyCode</AssemblerOutput>
      <AssemblerOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AssemblyCode</AssemblerOutput>
      <AssemblerOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(OutDir)%(Filename).asm</AssemblerOutputFile>
      <AssemblerOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(OutDir)%(Filename).asm</AssemblerOutputFile>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="d3d9.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="Overlay\FontMap.tga" />
    <Image Include="SimpleFont256x256.png" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Software_d3d9/Source.def`:

```def
LIBRARY d3d9
EXPORTS

; Export ordinal numbers taken from the Windows 10 1809 version of d3d9.dll

; Functions exported by name go here:
D3DPERF_BeginEvent=HookD3DPERF_BeginEvent @27
D3DPERF_EndEvent=HookD3DPERF_EndEvent @28
D3DPERF_GetStatus=HookD3DPERF_GetStatus @29
D3DPERF_QueryRepeatFrame=HookD3DPERF_QueryRepeatFrame @30
D3DPERF_SetMarker=HookD3DPERF_SetMarker @31
D3DPERF_SetOptions=HookD3DPERF_SetOptions @32
D3DPERF_SetRegion=HookD3DPERF_SetRegion @33
DebugSetLevel=HookDebugSetLevel @34
DebugSetMute=HookDebugSetMute @35
Direct3D9EnableMaximizedWindowedModeShim=HookDirect3D9EnableMaximizedWindowedModeShim @36
Direct3DCreate9=HookDirect3DCreate9 @37
Direct3DCreate9Ex=HookDirect3DCreate9Ex @38
Direct3DShaderValidatorCreate9=HookDirect3DShaderValidatorCreate9 @24
PSGPError=HookPSGPError @25
PSGPSampleTexture=HookPSGPSampleTexture @26

; Functions exported only by ordinal go here:

; Ordinal 16 = Direct3D9ForceHybridEnumeration
Direct3D9ForceHybridEnumeration=HookDirect3D9ForceHybridEnumeration @16

; Ordinal 17 = Direct3D9SetMaximizedWindowedModeShim
Direct3D9SetMaximizedWindowedModeShim=HookDirect3D9SetMaximizedWindowedModeShim @17

; Ordinal 18 = Direct3D9SetSwapEffectUpgradeShim
Direct3D9SetSwapEffectUpgradeShim=HookDirect3D9SetSwapEffectUpgradeShim @18

; Ordinal 19 = Direct3D9Force9On12
Direct3D9Force9On12=HookDirect3D9Force9On12 @19

; Ordinal 20 = Direct3DCreate9On12
Direct3DCreate9On12=HookDirect3DCreate9On12 @20

; Ordinal 21 = Direct3DCreate9On12Ex
Direct3DCreate9On12Ex=HookDirect3DCreate9On12Ex @21

; Ordinal 22 = Direct3D9SetMaximizedWindowHwndOverride
Direct3D9SetMaximizedWindowHwndOverride=HookDirect3D9SetMaximizedWindowHwndOverride @22

; Ordinal 23 = Direct3D9SetVendorIDLieFor9On12
Direct3D9SetVendorIDLieFor9On12=HookDirect3D9SetVendorIDLieFor9On12 @23

```

`Software_d3d9/VShaderEngine.cpp`:

```cpp
#pragma once

#include "VShaderEngine.h"
#include "IDirect3DDevice9Hook.h"
#include "IDirect3DVertexShader9Hook.h"

static const D3DXVECTOR4 negHalfVec(-0.5f, -0.5f, -0.5f, -0.5f);

template <const bool isVS3_0>
D3DXVECTOR4& VShaderEngine::ResolveDstParameterVS(const D3DSHADER_PARAM_REGISTER_TYPE registerType, const unsigned index)
{
	switch (registerType)
	{
	case D3DSPR_TEMP       :
#ifdef _DEBUG
		if (index >= ARRAYSIZE(VS_2_0_RuntimeRegisters::r) )
		{
			__debugbreak(); // Out of bounds register index!
		}
#endif
		return runtimeRegisters[0].r[index];
	case D3DSPR_INPUT      :
#ifdef _DEBUG
		__debugbreak(); // input registers can't be dst registers
#endif
		return inputRegisters[0].v[index];
	case D3DSPR_CONST      :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst registers
#endif
		return const_cast<D3DXVECTOR4&>(constantRegisters->c[index]);
	case D3DSPR_ADDR       : // Also known as D3DSPR_TEXTURE (PS)
		return *(D3DXVECTOR4* const)&runtimeRegisters[0].a;
	case D3DSPR_RASTOUT    :
#ifdef _DEBUG
		if (isVS3_0)
		{
			__debugbreak();
		}
		if (index >= 3)
		{
			__debugbreak(); // Out of bounds register index!
		}
#endif
		return (&outputRegisters[0]->oPos)[index];
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
		if (isVS3_0)
		{
#ifdef _DEBUG
			if (index >= ARRAYSIZE(VS_2_0_OutputRegisters::_vs_interpolated_outputs::_vs_3_0_outputs::oT) )
			{
				__debugbreak(); // Out of bounds register index!
			}
#endif
			return *(D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
		}
		else
		{
#ifdef _DEBUG
			if (index >= ARRAYSIZE(VS_2_0_OutputRegisters::_vs_interpolated_outputs::_vs_2_0_outputs::oT) )
			{
				__debugbreak(); // Out of bounds register index!
			}
#endif
			return *(D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oT[index];
		}
	case D3DSPR_CONSTINT   :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst registers
#endif
		return *(D3DXVECTOR4* const)&constantRegisters->i[index];
	case D3DSPR_COLOROUT   :
		if (isVS3_0)
		{
#ifdef _DEBUG
			if (index >= ARRAYSIZE(VS_2_0_OutputRegisters::_vs_interpolated_outputs::_vs_3_0_outputs::oT) )
			{
				__debugbreak(); // Out of bounds register index!
			}
#endif
			return *(D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
		}
		else
		{
#ifdef _DEBUG
			if (index >= ARRAYSIZE(VS_2_0_OutputRegisters::_vs_interpolated_outputs::_vs_2_0_outputs::oD) )
			{
				__debugbreak(); // Out of bounds register index!
			}
#endif
			return *(D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
		}
	case D3DSPR_ATTROUT    :
		if (isVS3_0)
			return outputRegisters[0]->oFog;
		else
		{
#ifdef _DEBUG
			if (index >= ARRAYSIZE(VS_2_0_OutputRegisters::_vs_interpolated_outputs::_vs_2_0_outputs::oD) )
			{
				__debugbreak(); // Out of bounds register index!
			}
#endif
			return *(D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
		}
	case D3DSPR_DEPTHOUT   :
#ifdef _DEBUG
		__debugbreak(); // Only usable by the PShader
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_SAMPLER    :
#ifdef _DEBUG
		__debugbreak(); // Sampler registers can't be dst registers - also sampler registers can't be used before vs_3_0
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst registers
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_CONSTBOOL  :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst registers
#endif
		return *(D3DXVECTOR4* const)&constantRegisters->b[index];
	case D3DSPR_LOOP       :
		return *(D3DXVECTOR4* const)&runtimeRegisters[0].aL;
	case D3DSPR_TEMPFLOAT16:
#ifdef _DEBUG
		__debugbreak();
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_MISCTYPE   :
#ifdef _DEBUG
		__debugbreak();
#endif
		return runtimeRegisters[0].r[index];
	case D3DSPR_LABEL      :
#ifdef _DEBUG
		__debugbreak(); // Labels can't be dst registers
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_PREDICATE  :
		return *(D3DXVECTOR4* const)&runtimeRegisters[0].p;
	default:
#ifdef _DEBUG
		{
			__debugbreak(); // Should never be here (invalid SPR type)
		}
#else
			__assume(0);
#endif
	}
	return *(D3DXVECTOR4* const)NULL;
}

// TODO: vs_3_0 introduced the concept of dst relative addressing (for output registers), we need to account for this somehow
void VShaderEngine::WriteDstParameter(const dstParameterToken dstParameter, const D3DXVECTOR4& value)
{
	D3DXVECTOR4& out = ResolveDstParameter(dstParameter);
	const unsigned writeMask = dstParameter.GetWriteMask();
	if (dstParameter.GetResultModifierUnshifted() & D3DSPDM_SATURATE) // Saturate
	{
		switch (writeMask)
		{
		case 0:
#ifdef _DEBUG
			__debugbreak(); // Should never be hereWriteDstParameter4
#endif
			break;
		case 0x1:
			out.x = saturate(value.x);
			break;
		case 0x3:
			out.x = saturate(value.x);
			// Intentional fallthrough
		case 0x2:
			out.y = saturate(value.y);
			break;
		case 0x7:
			out.x = saturate(value.x);
			// Intentional fallthrough
		case 0x6:
			out.y = saturate(value.y);
			// Intentional fallthrough
		case 0x4:
			out.z = saturate(value.z);
			break;
		case 0x5:
			out.x = saturate(value.x);
			out.z = saturate(value.z);
			break;
		default:
#ifdef _DEBUG
			__debugbreak();
#endif
		case 0xF: // The most common case, all bits are set!
			out.x = saturate(value.x);
			// Intentional fallthrough
		case 0xE: // 14
			out.y = saturate(value.y);
			// Intentional fallthrough
		case 0xC: // 12
			out.z = saturate(value.z);
			// Intentional fallthrough
		case 0x8:
			out.w = saturate(value.w);
			break;
		case 0x9:
			out.x = saturate(value.x);
			out.w = saturate(value.w);
			break;
		case 0xA: // 10
			out.y = saturate(value.y);
			out.w = saturate(value.w);
			break;
		case 0xB: // 11
			out.x = saturate(value.x);
			out.y = saturate(value.y);
			out.w = saturate(value.w);
			break;
		case 0xD: // 13
			out.x = saturate(value.x);
			out.z = saturate(value.z);
			out.w = saturate(value.w);
			break;
		}
	}
	else // No saturates
	{
		switch (writeMask)
		{
		case 0:
#ifdef _DEBUG
			__debugbreak(); // Should never be here
#endif
			break;
		case 0x1:
			out.x = value.x;
			break;
		case 0x3:
			out.x = value.x;
			// Intentional fallthrough
		case 0x2:
			out.y = value.y;
			break;
		case 0x7:
			out.x = value.x;
			// Intentional fallthrough
		case 0x6:
			out.y = value.y;
			// Intentional fallthrough
		case 0x4:
			out.z = value.z;
			break;
		case 0x5:
			out.x = value.x;
			out.z = value.z;
			break;
		default:
#ifdef _DEBUG
			__debugbreak();
#endif
		case 0xF: // The most common case, all bits are set!
			out.x = value.x;
			// Intentional fallthrough
		case 0xE: // 14
			out.y = value.y;
			// Intentional fallthrough
		case 0xC: // 12
			out.z = value.z;
			// Intentional fallthrough
		case 0x8:
			out.w = value.w;
			break;
		case 0x9:
			out.x = value.x;
			out.w = value.w;
			break;
		case 0xA: // 10
			out.y = value.y;
			out.w = value.w;
			break;
		case 0xB: // 11
			out.x = value.x;
			out.y = value.y;
			out.w = value.w;
			break;
		case 0xD: // 13
			out.x = value.x;
			out.z = value.z;
			out.w = value.w;
			break;
		}
	}
}

D3DXVECTOR4& VShaderEngine::ResolveDstParameter(const dstParameterToken dstParameter)
{
	const unsigned index = dstParameter.GetRegisterIndex();
	switch (shaderInfo->shaderMajorVersion)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case 1:
	case 2:
		return ResolveDstParameterVS<false>(dstParameter.GetRegisterType(), index);
	case 3:
		return ResolveDstParameterVS<true>(dstParameter.GetRegisterType(), index);
	}
}

const float VShaderEngine::ResolveSrcReplicateSwizzle(const DWORD rawSrcBytecode, const D3DXVECTOR4& registerData) const
{
	const srcParameterToken& srcParameter = *(const srcParameterToken* const)&rawSrcBytecode;
	const float* const fRegisterData = (const float* const)&registerData;
	return fRegisterData[srcParameter.GetChannelSwizzle()];
}

// Source parameter token: https://msdn.microsoft.com/en-us/library/windows/hardware/ff569716(v=vs.85).aspx
const D3DXVECTOR4 VShaderEngine::ResolveSrcRegister(const DWORD*& ptrSrcBytecode) const
{
	const DWORD rawSrcBytecode = *ptrSrcBytecode;
	const srcParameterToken& srcParameter = *(const srcParameterToken* const)&rawSrcBytecode;

	// Advance the instruction pointer (very important):
	++ptrSrcBytecode;

	const D3DXVECTOR4* sourceParamPtr = NULL;

	switch (srcParameter.GetRelativeAddressingType() )
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case D3DSHADER_ADDRMODE_ABSOLUTE:
		sourceParamPtr = &ResolveSrcParameter(srcParameter);
		break;
	case D3DSHADER_ADDRMODE_RELATIVE:
	{
		int addressOffsetRegisters = 0;

		const D3DXVECTOR4* const originalSourceParamPtr = &ResolveSrcParameter(srcParameter);

		// If SM2 or up, then relative addressing can use either the address register (a) or the loop
		// counter register (aL), so it needs another DWORD to know which to use. Otherwise (if vs_1_1) then
		// there's no extra relative addressing token and reading from a.x (the first component of the address
		// register) is assumed.
		if (shaderInfo->shaderMajorVersion > 1)
		{
			// Shader relative addressing: https://msdn.microsoft.com/en-us/library/windows/hardware/ff569708(v=vs.85).aspx
			const srcParameterToken& relativeAddressingSrcToken = *(const srcParameterToken* const)ptrSrcBytecode++;

			const int4& addressRegister = *(const int4* const)&ResolveSrcParameter(relativeAddressingSrcToken);
			const unsigned int addressRegisterSwizzle = relativeAddressingSrcToken.GetChannelSwizzleXYZW();
			switch (addressRegisterSwizzle)
			{
			default:
			case D3DSP_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT:
			case D3DSP_REPLICATERED >> D3DVS_SWIZZLE_SHIFT:
				addressOffsetRegisters = RoundToNearest(*(const float* const)&addressRegister.x);
				break;
			case D3DSP_REPLICATEGREEN >> D3DVS_SWIZZLE_SHIFT:
				addressOffsetRegisters = RoundToNearest(*(const float* const)&addressRegister.y);
				break;
			case D3DSP_REPLICATEBLUE >> D3DVS_SWIZZLE_SHIFT:
				addressOffsetRegisters = RoundToNearest(*(const float* const)&addressRegister.z);
				break;
			case D3DSP_REPLICATEALPHA >> D3DVS_SWIZZLE_SHIFT:
				addressOffsetRegisters = RoundToNearest(*(const float* const)&addressRegister.w);
				break;
			}
		}
		else
		{
			const int4& addressRegister = *(const int4* const)&ResolveSrcParameterVS<false>(D3DSPR_ADDR, 0);
			addressOffsetRegisters = RoundToNearest(*(const float* const)&addressRegister.x);
		}

		const D3DXVECTOR4* const relativeRegister = originalSourceParamPtr + addressOffsetRegisters;
		sourceParamPtr = &ResolveSrcAddressIfValid(relativeRegister);
	}

		break;
	}

	const D3DXVECTOR4& sourceParam = *sourceParamPtr;
	const unsigned char sourceSwizzle = srcParameter.GetSwizzle();

	D3DXVECTOR4 ret;

	if (sourceSwizzle == (D3DVS_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT) )
	{
		ret = sourceParam;
	}
	else
	{
		const float* const fltParams = &sourceParam.x;
		ret.x = fltParams[sourceSwizzle & 0x3]; // R channel
		ret.y = fltParams[(sourceSwizzle >> 2) & 0x3]; // G channel
		ret.z = fltParams[(sourceSwizzle >> 4) & 0x3]; // B channel
		ret.w = fltParams[(sourceSwizzle >> 6) & 0x3]; // A channel
	}

	switch (srcParameter.GetSourceModifiersUnshifted() )
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#endif
	case D3DSPSM_NONE   :
		return ret;
	case D3DSPSM_NEG    :
		ret *= -1.0f;
		break;
	case D3DSPSM_BIAS   :
		ret += negHalfVec;
		break;
	case D3DSPSM_BIASNEG:
		ret += negHalfVec;
		ret *= -1.0f;
		break;
	case D3DSPSM_SIGN   :
		ret += negHalfVec;
		ret *= 2.0f;
		break;
	case D3DSPSM_SIGNNEG:
		ret += negHalfVec;
		ret *= -2.0f;
		break;
	case D3DSPSM_COMP   :
		ret.x = 1.0f - ret.x;
		ret.y = 1.0f - ret.y;
		ret.z = 1.0f - ret.z;
		ret.w = 1.0f - ret.w;
		break;
	case D3DSPSM_X2     :
		ret *= 2.0f;
		break;
	case D3DSPSM_X2NEG  :
		ret *= -2.0f;
		break;
	case D3DSPSM_DZ     :
	{
		const float invZ = 1.0f / ret.z;
		ret.x *= invZ;
		ret.y *= invZ;
	}
		break;
	case D3DSPSM_DW     :
	{
		const float invW = 1.0f / ret.w;
		ret.x *= invW;
		ret.y *= invW;
	}
		break;
	case D3DSPSM_ABS    :
		ret.x = fabsf(ret.x);
		ret.y = fabsf(ret.y);
		ret.z = fabsf(ret.z);
		ret.w = fabsf(ret.w);
		break;
	case D3DSPSM_ABSNEG :
		ret.x = -fabsf(ret.x);
		ret.y = -fabsf(ret.y);
		ret.z = -fabsf(ret.z);
		ret.w = -fabsf(ret.w);
		break;
	case D3DSPSM_NOT    :
	{
		BOOL* const boolPtr = (BOOL* const)&ret.x;
		*boolPtr = !*boolPtr;
	}
		break;
	}

	return ret;
}

template <const bool isVS3_0>
const D3DXVECTOR4& VShaderEngine::ResolveSrcParameterVS(const D3DSHADER_PARAM_REGISTER_TYPE registerType, const unsigned index) const
{
	switch (registerType)
	{
	case D3DSPR_TEMP       :
		return runtimeRegisters[0].r[index];
	case D3DSPR_INPUT      :
		return inputRegisters[0].v[index];
	case D3DSPR_CONST      :
		return constantRegisters->c[index];
	case D3DSPR_ADDR       : // Also known as D3DSPR_TEXTURE (PS)
		return *(const D3DXVECTOR4* const)&runtimeRegisters[0].a;
	case D3DSPR_RASTOUT    :
		if (isVS3_0)
		{
#ifdef _DEBUG
			__debugbreak();
#endif
			return runtimeRegisters[0].r[0];
		}
		else
			return (&outputRegisters[0]->oPos)[index];
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
		if (isVS3_0)
			return *(const D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
		else
			return *(const D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oT[index];
	case D3DSPR_CONSTINT   :
		return *(const D3DXVECTOR4* const)&constantRegisters->i[index];
	case D3DSPR_COLOROUT   :
		if (isVS3_0)
			return *(const D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
		else
			return *(const D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
	case D3DSPR_ATTROUT    :
		if (isVS3_0)
			return outputRegisters[0]->oFog;
		else
			return *(const D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
	case D3DSPR_DEPTHOUT   :
#ifdef _DEBUG
		__debugbreak();
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_SAMPLER    :
#ifdef _DEBUG
		__debugbreak();
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
#ifdef _DEBUG
		__debugbreak();
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_CONSTBOOL  :
		return *(const D3DXVECTOR4* const)&constantRegisters->b[index];
	case D3DSPR_LOOP       :
		return *(const D3DXVECTOR4* const)&runtimeRegisters[0].aL;
	case D3DSPR_TEMPFLOAT16:
#ifdef _DEBUG
		__debugbreak();
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_MISCTYPE   :
#ifdef _DEBUG
		__debugbreak();
#endif
		return runtimeRegisters[0].r[index];
	case D3DSPR_LABEL      :
#ifdef _DEBUG
		__debugbreak(); // Uhhhhh, is this debugbreak correct? Aren't Labels allowed to be source parameters for the CALL and CALLNZ instructions?
#else
		return runtimeRegisters[0].r[0];
#endif
	case D3DSPR_PREDICATE  :
		return *(const D3DXVECTOR4* const)&runtimeRegisters[0].p;
	default:
#ifdef _DEBUG
		{
			__debugbreak();
		}
#else
			__assume(0);
#endif
	}
	return *(const D3DXVECTOR4* const)NULL;
}

const D3DXVECTOR4& VShaderEngine::ResolveSrcParameter(const srcParameterToken srcParameter) const 
{
	const unsigned index = srcParameter.GetRegisterIndex();
	switch (shaderInfo->shaderMajorVersion)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case 1:
	case 2:
		return ResolveSrcParameterVS<false>(srcParameter.GetRegisterType(), index);
	case 3:
		return ResolveSrcParameterVS<true>(srcParameter.GetRegisterType(), index);
	}
	return *(const D3DXVECTOR4* const)NULL;
}

// Called once at device reset time
void VShaderEngine::GlobalInit(const VS_2_0_ConstantsBuffer* const _constantRegisters)
{
	memset(this, 0, sizeof(*this) );

	GlobalInitTex2DFunctionTable();

	constantRegisters = _constantRegisters;
}

void VShaderEngine::Init(const DeviceState& deviceState, const ShaderInfo& _shaderInfo, VS_2_0_ConstantsBuffer* const mutableConstantRegisters)
{
	shaderInfo = &_shaderInfo;

#ifdef _DEBUG
	if (!deviceState.currentVertexShader)
	{
		__debugbreak();
	}
#endif
	instructionPtr = _shaderInfo.firstInstructionToken;

	const DeviceState_ShaderRegisters& globalVertexShaderConstants = deviceState.vertexShaderRegisters;

	InitGlobalConstants(globalVertexShaderConstants, mutableConstantRegisters);

	// Local constants ("immediate constants") always take precedence over global constants: https://msdn.microsoft.com/en-us/library/windows/desktop/bb205596(v=vs.85).aspx
	InitLocalConstants(_shaderInfo, mutableConstantRegisters);

	InitSamplers(deviceState, mutableConstantRegisters);
}

void VShaderEngine::InitGlobalConstants(const DeviceState_ShaderRegisters& globalVertexShaderConstants, VS_2_0_ConstantsBuffer* const mutableConstantRegisters)
{
	memcpy(&mutableConstantRegisters->c, &globalVertexShaderConstants.floats, sizeof(D3DXVECTOR4) * ARRAYSIZE(VS_2_0_ConstantsBuffer::c) );
	memcpy(&mutableConstantRegisters->b, &globalVertexShaderConstants.bools, sizeof(BOOL) * ARRAYSIZE(VS_2_0_ConstantsBuffer::b) );
	memcpy(&mutableConstantRegisters->i, &globalVertexShaderConstants.ints, sizeof(int4) * ARRAYSIZE(VS_2_0_ConstantsBuffer::i) );
}

void VShaderEngine::InitLocalConstants(const ShaderInfo& vertexShaderInfo, VS_2_0_ConstantsBuffer* const mutableConstantRegisters)
{
	// Floats
	{
		const unsigned numFloatConsts = vertexShaderInfo.initialConstantValues.size();
		for (unsigned x = 0; x < numFloatConsts; ++x)
		{
			const InitialConstantValue& constF = vertexShaderInfo.initialConstantValues[x];
			mutableConstantRegisters->c[constF.constantRegisterIndex] = constF.initialValue;
		}
	}

	// Bools
	{
		const unsigned numBoolConsts = vertexShaderInfo.initialConstantValuesB.size();
		for (unsigned x = 0; x < numBoolConsts; ++x)
		{
			const InitialConstantValueB& constB = vertexShaderInfo.initialConstantValuesB[x];
			mutableConstantRegisters->b[constB.constantRegisterIndex] = constB.initialValue;
		}
	}

	// Ints
	{
		const unsigned numIntConsts = vertexShaderInfo.initialConstantValuesI.size();
		for (unsigned x = 0; x < numIntConsts; ++x)
		{
			const InitialConstantValueI& constI = vertexShaderInfo.initialConstantValuesI[x];
			mutableConstantRegisters->i[constI.constantRegisterIndex] = constI.initialValue;
		}
	}
}

void VShaderEngine::InitSamplers(const DeviceState& deviceState, VS_2_0_ConstantsBuffer* const mutableConstantRegisters)
{
	for (unsigned x = 0; x < ARRAYSIZE(VS_2_0_ConstantsBuffer::s); ++x)
	{
		sampler& thisSampler = mutableConstantRegisters->s[x];
		thisSampler.texture = deviceState.currentTextures[x + D3DVERTEXTEXTURESAMPLER0];
		thisSampler.samplerState = deviceState.currentSamplerStates[x + D3DVERTEXTEXTURESAMPLER0];
	}
}

// Called once for every vertex or vertex warp to reset the state of the interpreter to its default
void VShaderEngine::Reset(VS_2_0_OutputRegisters* const * const outputVerts, const unsigned char numVerts)
{
	instructionPtr = shaderInfo->firstInstructionToken;
#ifdef _DEBUG
	for (unsigned char x = 0; x < ARRAYSIZE(outputRegisters); ++x)
		outputRegisters[x] = NULL;
#endif
	for (unsigned char x = 0; x < numVerts; ++x)
		outputRegisters[x] = outputVerts[x];
}

```

`Software_d3d9/VShaderEngine.h`:

```h
#pragma once

#include "d3d9include.h"
#include "ShaderEngineBase.h"

struct DeviceState;
struct DeviceState_ShaderRegisters;
struct ShaderInfo;

#define MAX_NUM_VS_CONSTANTS 4096

struct VS_2_0_ConstantsBuffer
{
	D3DXVECTOR4 c[MAX_NUM_VS_CONSTANTS]; // Constant registers
	BOOL b[MAX_NUM_CONST_BOOL_REGISTERS]; // Constant boolean registers
	int4 i[MAX_NUM_CONST_INT_REGISTERS]; // Constant int registers
	sampler s[4]; // Samplers
};

struct VS_2_0_InputRegisters
{
	__declspec(align(16) ) D3DXVECTOR4 v[VS_MAX_INPUT_REGISTERS]; // Input registers from vertex stream
};

struct VS_2_0_RuntimeRegisters
{
	D3DXVECTOR4 r[MAX_NUM_TEMP_REGISTERS]; // Temporary GPR
	int4 a; // Address register (one-channel register in vs_1_1 but four-channel in vs_2_0 and up). Sometimes called "a0".
	int4 p; // Predicate register
	int aL; // Loop Counter Register (only exists in vs_2_0 and up)
};

struct vertexClipStruct
{
	// Device clip planes (6 bits):
	unsigned short leftClip : 1;
	unsigned short rightClip : 1;
	unsigned short topClip : 1;
	unsigned short bottomClip : 1;
	unsigned short frontClip : 1;
	unsigned short backClip : 1;

	// User clipping planes (6 bits):
	unsigned short userClip0 : 1;
	unsigned short userClip1 : 1;
	unsigned short userClip2 : 1;
	unsigned short userClip3 : 1;
	unsigned short userClip4 : 1;
	unsigned short userClip5 : 1;

	// 2D Guard-band clip planes (4 bits):
	unsigned short GBLeftClip : 1;
	unsigned short GBRightClip : 1;
	unsigned short GBTopClip : 1;
	unsigned short GBBottomClip : 1;
};
static_assert(sizeof(vertexClipStruct) == sizeof(unsigned short), "Error!");

// Be careful about reordering elements within this struct, see outPositionRegisterIndex for more info
__declspec(align(16) ) struct VS_2_0_OutputRegisters
{
	VS_2_0_OutputRegisters()
	{
#ifdef _DEBUG
		memset(this, 0, sizeof(*this) );
#endif
	}

	__declspec(align(16) )  D3DXVECTOR4 oPos; // Output position register for pre-vs_3_0 (very important)

	// TODO: MSDN says that the fog and point-size registers are float1's, not float4's. Is this right, or does HLSL allow storing float4's in these registers?
	__declspec(align(16) )  D3DXVECTOR4 oFog; // Output fog register
	__declspec(align(16) )  D3DXVECTOR4 oPts; // Output point-size register
	union _vs_interpolated_outputs
	{
		struct _vs_2_0_outputs
		{
			__declspec(align(16) )  D3DCOLORVALUE oD[D3DMCS_COLOR2]; // Diffuse and Specular color output registers
			__declspec(align(16) )  D3DCOLORVALUE oT[D3DDP_MAXTEXCOORD]; // Output texcoord registers
		} vs_2_0_outputs;

		struct _vs_3_0_outputs
		{
			__declspec(align(16) )  D3DCOLORVALUE oT[10]; // Output texcoord registers
		} vs_3_0_outputs;
	} vs_interpolated_outputs;
	union vertexClipUnion
	{
		unsigned short clipCodesCombined;
		vertexClipStruct clipCodesNamed;
	} vertexClip;
};

__declspec(align(16) ) class VShaderEngine : public ShaderEngineBase
{
public:
	VShaderEngine() : constantRegisters(NULL)
	{
		outputRegisters[0] = NULL;
		outputRegisters[1] = NULL;
		outputRegisters[2] = NULL;
		outputRegisters[3] = NULL;
	}

	~VShaderEngine()
	{
		constantRegisters = NULL;
		for (unsigned x = 0; x < ARRAYSIZE(outputRegisters); ++x)
			outputRegisters[x] = NULL;
	}

	inline VShaderEngine& operator=(const VShaderEngine& rhs)
	{
		shaderInfo = rhs.shaderInfo;
		constantRegisters = rhs.constantRegisters;
		return *this;
	}

	inline void DeepCopy(const VShaderEngine& rhs)
	{
		memcpy(this, &rhs, sizeof(*this) );
	}

	// Called once for each shader instruction
	const bool InterpreterExecStep1();

	// Called once for each shader instruction, for 4 verts at a time
	const bool InterpreterExecStep4();

	// Called once at device reset time
	void GlobalInit(const VS_2_0_ConstantsBuffer* const _constantRegisters);

	// Called once at the beginning of processing a draw-call:
	void Init(const DeviceState& deviceState, const ShaderInfo& _shaderInfo, VS_2_0_ConstantsBuffer* const mutableConstantRegisters);

	// Called once for every vertex or vertex warp to reset the state of the interpreter to its default
	void Reset(VS_2_0_OutputRegisters* const * const outputVerts, const unsigned char numVerts);

	const VS_2_0_ConstantsBuffer* constantRegisters;
	__declspec(align(16) ) VS_2_0_InputRegisters inputRegisters[4];
	__declspec(align(16) ) VS_2_0_RuntimeRegisters runtimeRegisters[4];
	VS_2_0_OutputRegisters* outputRegisters[4];

	D3DXVECTOR4& ResolveDstParameter(const dstParameterToken dstParameter);
	void ResolveDstParameter4(const dstParameterToken dstParameter, D3DXVECTOR4* (&outDstRegisters)[4]);
	const D3DXVECTOR4& ResolveSrcParameter(const srcParameterToken srcParameter) const;
	void ResolveSrcParameter4(const srcParameterToken srcParameter, const D3DXVECTOR4* (&outSrcRegisters)[4]) const;
	const float ResolveSrcReplicateSwizzle(const DWORD rawSrcBytecode, const D3DXVECTOR4& registerData) const;
	void ResolveSrcReplicateSwizzle4(const DWORD rawSrcBytecode, const D3DXVECTOR4 (&registerData)[4], float (&outReplicateValue)[4]) const;

	INTRINSIC_INLINE const D3DXVECTOR4& ResolveSrcAddressIfValid(const void* const addressPtr) const
	{
		if (addressPtr >= &constantRegisters->c[0] && addressPtr <= &constantRegisters->c[(MAX_NUM_VS_CONSTANTS - 1)])
			return *(const D3DXVECTOR4* const)addressPtr;
		else if (addressPtr >= &runtimeRegisters[0].r[0] && addressPtr <= &runtimeRegisters[0].r[(MAX_NUM_TEMP_REGISTERS - 1)])
			return *(const D3DXVECTOR4* const)addressPtr;
		else if (addressPtr >= &inputRegisters[0].v[0] && addressPtr <= &inputRegisters[0].v[VS_MAX_INPUT_REGISTERS - 1])
			return *(const D3DXVECTOR4* const)addressPtr;
		else
			// When reading outside of the constants buffer or the runtime registers the
			// constant (0,0,0,0) is always returned
			return ZEROVEC;
	}

	INTRINSIC_INLINE void ResolveSrcAddressIfValid4(const void* const (&addressPtr4)[4], const D3DXVECTOR4* (&outSrcRegisters)[4]) const
	{
		if (addressPtr4[0] >= &constantRegisters->c[0] && addressPtr4[0] <= &constantRegisters->c[(MAX_NUM_VS_CONSTANTS - 1)])
			outSrcRegisters[0] = (const D3DXVECTOR4* const)addressPtr4[0];
		else if (addressPtr4[0] >= &runtimeRegisters[0].r[0] && addressPtr4[0] <= &runtimeRegisters[0].r[(MAX_NUM_TEMP_REGISTERS - 1)])
			outSrcRegisters[0] = (const D3DXVECTOR4* const)addressPtr4[0];
		else if (addressPtr4[0] >= &inputRegisters[0].v[0] && addressPtr4[0] <= &inputRegisters[0].v[VS_MAX_INPUT_REGISTERS - 1])
			outSrcRegisters[0] = (const D3DXVECTOR4* const)addressPtr4[0];
		else
			outSrcRegisters[0] = &ZEROVEC; // When reading outside of the constants buffer or the runtime registers the constant (0,0,0,0) is always returned

		if (addressPtr4[1] >= &constantRegisters->c[0] && addressPtr4[1] <= &constantRegisters->c[(MAX_NUM_VS_CONSTANTS - 1)])
			outSrcRegisters[1] = (const D3DXVECTOR4* const)addressPtr4[1];
		else if (addressPtr4[1] >= &runtimeRegisters[1].r[0] && addressPtr4[1] <= &runtimeRegisters[1].r[(MAX_NUM_TEMP_REGISTERS - 1)])
			outSrcRegisters[1] = (const D3DXVECTOR4* const)addressPtr4[0];
		else if (addressPtr4[1] >= &inputRegisters[1].v[0] && addressPtr4[1] <= &inputRegisters[1].v[VS_MAX_INPUT_REGISTERS - 1])
			outSrcRegisters[1] = (const D3DXVECTOR4* const)addressPtr4[1];
		else
			outSrcRegisters[1] = &ZEROVEC; // When reading outside of the constants buffer or the runtime registers the constant (0,0,0,0) is always returned

		if (addressPtr4[2] >= &constantRegisters->c[0] && addressPtr4[2] <= &constantRegisters->c[(MAX_NUM_VS_CONSTANTS - 1)])
			outSrcRegisters[2] = (const D3DXVECTOR4* const)addressPtr4[2];
		else if (addressPtr4[2] >= &runtimeRegisters[2].r[0] && addressPtr4[2] <= &runtimeRegisters[2].r[(MAX_NUM_TEMP_REGISTERS - 1)])
			outSrcRegisters[2] = (const D3DXVECTOR4* const)addressPtr4[2];
		else if (addressPtr4[2] >= &inputRegisters[2].v[0] && addressPtr4[2] <= &inputRegisters[2].v[VS_MAX_INPUT_REGISTERS - 1])
			outSrcRegisters[2] = (const D3DXVECTOR4* const)addressPtr4[2];
		else
			outSrcRegisters[2] = &ZEROVEC; // When reading outside of the constants buffer or the runtime registers the constant (0,0,0,0) is always returned

		if (addressPtr4[3] >= &constantRegisters->c[0] && addressPtr4[3] <= &constantRegisters->c[(MAX_NUM_VS_CONSTANTS - 1)])
			outSrcRegisters[3] = (const D3DXVECTOR4* const)addressPtr4[3];
		else if (addressPtr4[3] >= &runtimeRegisters[3].r[0] && addressPtr4[3] <= &runtimeRegisters[3].r[(MAX_NUM_TEMP_REGISTERS - 1)])
			outSrcRegisters[3] = (const D3DXVECTOR4* const)addressPtr4[3];
		else if (addressPtr4[3] >= &inputRegisters[3].v[0] && addressPtr4[3] <= &inputRegisters[3].v[VS_MAX_INPUT_REGISTERS - 1])
			outSrcRegisters[3] = (const D3DXVECTOR4* const)addressPtr4[3];
		else
			outSrcRegisters[3] = &ZEROVEC; // When reading outside of the constants buffer or the runtime registers the constant (0,0,0,0) is always returned
	}

	const INTRINSIC_INLINE D3DXVECTOR4& GetSrcRegisterFromAddress(const float4& baseRegister, const int addressOffset)
	{
		const float4* const targetRegister = &baseRegister + addressOffset;
		return ResolveSrcAddressIfValid(targetRegister);
	}

protected:
	void InitGlobalConstants(const DeviceState_ShaderRegisters& globalVertexShaderConstants, VS_2_0_ConstantsBuffer* const mutableConstantRegisters);
	void InitLocalConstants(const ShaderInfo& vertexShaderInfo, VS_2_0_ConstantsBuffer* const mutableConstantRegisters);
	void InitSamplers(const DeviceState& deviceState, VS_2_0_ConstantsBuffer* const mutableConstantRegisters);

	template <const bool isVS3_0>
	D3DXVECTOR4& ResolveDstParameterVS(const D3DSHADER_PARAM_REGISTER_TYPE registerType, const unsigned index);

	template <const bool isVS3_0>
	void ResolveDstParameterVS4(const D3DSHADER_PARAM_REGISTER_TYPE registerType, const unsigned index, D3DXVECTOR4* (&outDstRegisters)[4]);

	template <const bool isVS3_0>
	const D3DXVECTOR4& ResolveSrcParameterVS(const D3DSHADER_PARAM_REGISTER_TYPE registerType, const unsigned index) const;

	template <const bool isVS3_0>
	void ResolveSrcParameterVS4(const D3DSHADER_PARAM_REGISTER_TYPE registerType, const unsigned index, const D3DXVECTOR4* (&outSrcRegisters)[4]) const;

	// TODO: vs_3_0 introduced the concept of dst relative addressing (for output registers), we need to account for this somehow
	void WriteDstParameter(const dstParameterToken dstParameter, const D3DXVECTOR4& value);
	void WriteDstParameter4(const dstParameterToken dstParameter, const D3DXVECTOR4 (&value)[4]);

	const D3DXVECTOR4 ResolveSrcRegister(const DWORD*& ptrSrcBytecode) const;
	void ResolveSrcRegister4(const DWORD*& ptrSrcBytecode, D3DXVECTOR4 (&outSrcRegisters)[4]) const;
};

```

`Software_d3d9/VShaderEngine_InterpreterExec1.cpp`:

```cpp
#pragma once

#include "VShaderEngine.h"
#include "IDirect3DDevice9Hook.h"
#include "IDirect3DVertexShader9Hook.h"

const bool VShaderEngine::InterpreterExecStep1()
{
#ifdef _DEBUG
	if (!instructionPtr)
	{
		__debugbreak();
	}
#endif

	const instructionToken rawInstructionToken = *(const instructionToken* const)instructionPtr++;
	const D3DSHADER_INSTRUCTION_OPCODE_TYPE currentInstructionOpcode = (const D3DSHADER_INSTRUCTION_OPCODE_TYPE)(rawInstructionToken.opcode);
	switch (currentInstructionOpcode)
	{
	case D3DSIO_NOP         :
		nop();
		break;
	case D3DSIO_MOV         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		WriteDstParameter(dstParam, src0);
	}
		break;
	case D3DSIO_ADD         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		add(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SUB         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		sub(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_MAD         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		mad(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_MUL         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		mul(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_RCP         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD srcBytecode = *instructionPtr;
		const D3DXVECTOR4 src = ResolveSrcRegister(instructionPtr);
		const float f = ResolveSrcReplicateSwizzle(srcBytecode, src);
		D3DXVECTOR4 dst;
		rcp(dst, f);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_RSQ         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD srcBytecode = *instructionPtr;
		const D3DXVECTOR4 src = ResolveSrcRegister(instructionPtr);
		const float f = ResolveSrcReplicateSwizzle(srcBytecode, src);
		D3DXVECTOR4 dst;
		rsq(dst, f);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DP3         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		dp3(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DP4         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		dp4(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_MIN         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		min(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_MAX         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		max(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SLT         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		slt(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SGE         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		sge(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_EXPP        :
	case D3DSIO_EXP         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD srcBytecode = *instructionPtr;
		const D3DXVECTOR4 src = ResolveSrcRegister(instructionPtr);
		const float f = ResolveSrcReplicateSwizzle(srcBytecode, src);
		D3DXVECTOR4 dst;
		exp(dst, f);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_LOGP        :
	case D3DSIO_LOG         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD srcBytecode = *instructionPtr;
		const D3DXVECTOR4 src = ResolveSrcRegister(instructionPtr);
		const float f = ResolveSrcReplicateSwizzle(srcBytecode, src);
		D3DXVECTOR4 dst;
		log(dst, f);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_LIT         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		lit(dst, src0);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DST         : // TODO: Validate correctness of this (the docs seem incomplete and misleading)
	{
		const dstParameterToken destParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dest;
		dst(dest, src0, src1);
		WriteDstParameter(destParam, dest);
	}
		break;
	case D3DSIO_LRP         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		lrp(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_FRC         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		frc(dst, src);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_M4x4        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2 = *(&src1 + 1);
		const D3DXVECTOR4 src3 = *(&src1 + 2);
		const D3DXVECTOR4 src4 = *(&src1 + 3);
		D3DXVECTOR4 dst;
		m4x4(dst, src0, src1, src2, src3, src4);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_M4x3        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2 = *(&src1 + 1);
		const D3DXVECTOR4 src3 = *(&src1 + 2);
		D3DXVECTOR4 dst;
		m4x3(dst, src0, src1, src2, src3);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_M3x4        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2 = *(&src1 + 1);
		const D3DXVECTOR4 src3 = *(&src1 + 2);
		const D3DXVECTOR4 src4 = *(&src1 + 3);
		D3DXVECTOR4 dst;
		m3x4(dst, src0, src1, src2, src3, src4);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_M3x3        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2 = *(&src1 + 1);
		const D3DXVECTOR4 src3 = *(&src1 + 2);
		D3DXVECTOR4 dst;
		m3x3(dst, src0, src1, src2, src3);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_M3x2        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2 = *(&src1 + 1);
		D3DXVECTOR4 dst;
		m3x2(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_CALL        :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		DbgBreakPrint("Error: CALL Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_CALLNZ      :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		DbgBreakPrint("Error: CALLNZ Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_LOOP        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		DbgBreakPrint("Error: LOOP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_RET         :
		DbgBreakPrint("Error: RET Shader function not yet implemented!"); // Not yet implemented!
		return false;
	case D3DSIO_ENDLOOP     :
		DbgBreakPrint("Error: ENDLOOP Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_LABEL       :
	{
		// src0 contains the label index for this label
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		
		// Do nothing
	}
		break;
	case D3DSIO_DCL         :
		DbgBreakPrint("Error: DCL Should not be encountered during normal shader execution!");
		break;
	case D3DSIO_POW         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD src0Bytecode = *instructionPtr;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const float f0 = ResolveSrcReplicateSwizzle(src0Bytecode, src0);
		const DWORD src1Bytecode = *instructionPtr;
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const float f1 = ResolveSrcReplicateSwizzle(src1Bytecode, src1);
		D3DXVECTOR4 dst;
		pow(dst, f0, f1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_CRS         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		crs(dst, src0, src1);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SGN         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1_unused = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2_unused = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		sgn(dst, src0, src1_unused, src2_unused);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_ABS         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		abs(dst, src0);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_NRM         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		nrm(dst, src0);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_SINCOS      :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD src0Bytecode = *instructionPtr;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const srcParameterToken& srcParameter = *(const srcParameterToken* const)instructionPtr;
		const unsigned swizzleX = srcParameter.GetChannelSwizzleXYZW() & 0x3;
		const unsigned swizzleY = (srcParameter.GetChannelSwizzleXYZW() >> 2) & 0x3;
		const float f = ResolveSrcReplicateSwizzle(src0Bytecode, src0);
		if (shaderInfo->shaderMajorVersion < 3) // Shader model 2 has these extra registers, but all the shader model 3+ don't have them
		{
			const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
			const D3DXVECTOR4 src2 = ResolveSrcRegister(instructionPtr);
		}
		D3DXVECTOR4 dst;
		if (swizzleX && swizzleY)
			sincos_sc(dst, f);
		else if (swizzleX)
			sincos_c(dst, f);
		else if (swizzleY)
			sincos_s(dst, f);
#ifdef _DEBUG
		else
		{
			// Whyyyyyyyyyyyyyyyy?
			__debugbreak();
		}
#endif
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_REP         :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		DbgBreakPrint("Error: REP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_ENDREP      :
		DbgBreakPrint("Error: ENDREP Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_IF          :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		DbgBreakPrint("Error: IF Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_IFC         :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		DbgBreakPrint("Error: IFC Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_ELSE        :
		DbgBreakPrint("Error: ELSE Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_ENDIF       :
		DbgBreakPrint("Error: ENDIF Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_BREAK       :
		DbgBreakPrint("Error: BREAK Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_BREAKC      :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		DbgBreakPrint("Error: BREAKC Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_MOVA        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
#ifdef _DEBUG
		if (dstParam.GetRegisterType() != D3DSPR_ADDR)
		{
			__debugbreak(); // This instruction is only allowed to move into the address register (a0 register)
		}
#endif
		WriteDstParameter(dstParam, src0);
	}
		break;
	case D3DSIO_DEFB        :
		DbgBreakPrint("Error: DEFB Should not be encountered during normal shader execution!");
		break;
	case D3DSIO_DEFI        :
		DbgBreakPrint("Error: DEFI Should not be encountered during normal shader execution!");
		break;		
	case D3DSIO_TEXCOORD    :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		DbgBreakPrint("Error: TEXCOORD Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXKILL     :
		DbgBreakPrint("Error: Should never hit TEXKILL inside a vertex shader!");
		__debugbreak();
		break;
	case D3DSIO_TEXBEM      :
		DbgBreakPrint("Error: TEXBEM Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXBEML     :
		DbgBreakPrint("Error: TEXBEML Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXREG2AR   :
		DbgBreakPrint("Error: TEXREG2AR Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXREG2GB   :
		DbgBreakPrint("Error: TEXREG2GB Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x2PAD  :
		DbgBreakPrint("Error: TEXM3x2PAD Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x2TEX  :
		DbgBreakPrint("Error: TEXM3x2TEX Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x3PAD  :
		DbgBreakPrint("Error: TEXM3x3PAD Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x3TEX  :
		DbgBreakPrint("Error: TEXM3x3TEX Shader function not available in vertex shaders!");
		break;
	case D3DSIO_RESERVED0   :
		DbgBreakPrint("Error: RESERVED0 Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x3SPEC :
		DbgBreakPrint("Error: TEXM3x3SPEC Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x3VSPEC:
		DbgBreakPrint("Error: TEXM3x3VSPEC Shader function not available in vertex shaders!");
		break;
	case D3DSIO_CND         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		cnd(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DEF         :
		DbgBreakPrint("Error: DEF Should not be encountered during normal shader execution!"); // Not yet implemented!
		break;
	case D3DSIO_TEXREG2RGB  :
		DbgBreakPrint("Error: TEXREG2RGB Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXDP3TEX   :
		DbgBreakPrint("Error: TEXDP3TEX Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x2DEPTH:
		DbgBreakPrint("Error: TEXM3x2DEPTH Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXDP3      :
		DbgBreakPrint("Error: TEXDP3 Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x3     :
		DbgBreakPrint("Error: TEXM3x3 Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXDEPTH    :
		DbgBreakPrint("Error: TEXDEPTH Shader function not available in vertex shaders!");
		break;
	case D3DSIO_CMP         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		cmp(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_BEM         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		DbgBreakPrint("Error: BEM Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_DP2ADD      :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src2 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;
		dp2add(dst, src0, src1, src2);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DSX         : // Technically these derivative/gradient instructions aren't supposed to be runnable by vertex shaders, but it won't break anything if we do
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;

		// Derivative is always zero for one-vertex warps (need at least a 2x2 quad warp to compute this)
		dsx(dst, src0);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_DSY         : // Technically these derivative/gradient instructions aren't supposed to be runnable by vertex shaders, but it won't break anything if we do
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		D3DXVECTOR4 dst;

		// Derivative is always zero for one-vertex warps (need at least a 2x2 quad warp to compute this)
		dsy(dst, src0);
		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_TEXLDD      : // tex2Dgrad()
		DbgBreakPrint("Error: TEXLDD Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_SETP        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const D3DXVECTOR4 src1 = ResolveSrcRegister(instructionPtr);
		DbgBreakPrint("Error: SETP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;

		// Technically tex2D() is not allowed in vertex shaders, however I don't see anything wrong with promoting it to tex2Dlod and just letting the shader run
	case D3DSIO_TEX         : // Standard texture sampling with tex2D() for shader model 2 and up
	case D3DSIO_TEXLDL      : // tex2Dlod()
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		const srcParameterToken& src1Param = *(const srcParameterToken* const)instructionPtr++;
		const D3DXVECTOR4& src1 = ResolveSrcParameter(src1Param);
		const sampler* const samplerPtr = (const sampler* const)&src1;
		D3DXVECTOR4 dst;

		tex2Dlod<0xF>(dst, src0, samplerPtr);

		// TODO: src1 can have a swizzle that gets applied after the texture sample but before the write mask happens

		WriteDstParameter(dstParam, dst);
	}
		break;
	case D3DSIO_BREAKP      :
	{
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		DbgBreakPrint("Error: BREAKP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;		
	case D3DSIO_PHASE       :
		DbgBreakPrint("Error: Should never hit PHASE instruction in vertex shader!");
		break;
	case D3DSIO_COMMENT     :
	{
		const unsigned commentLengthDWORDs = (instructionPtr[-1] & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
		instructionPtr += commentLengthDWORDs; // Skip the comment block
	}
		break;
	case D3DSIO_END         :
		// We're done! We reached the end of the shader!
		return false;
	default:
#ifdef _DEBUG
	{
		__debugbreak();
	}
#else
		__assume(0);
#endif
	}

	return true;
}

```

`Software_d3d9/VShaderEngine_InterpreterExec4.cpp`:

```cpp
#pragma once

#include "VShaderEngine.h"
#include "IDirect3DDevice9Hook.h"
#include "IDirect3DVertexShader9Hook.h"

#ifdef RUN_SHADERS_IN_WARPS

static const D3DXVECTOR4 negHalfVec(-0.5f, -0.5f, -0.5f, -0.5f);

void VShaderEngine::ResolveSrcReplicateSwizzle4(const DWORD rawSrcBytecode, const D3DXVECTOR4 (&registerData)[4], float (&outReplicateValue)[4]) const
{
	const srcParameterToken& srcParameter = *(const srcParameterToken* const)&rawSrcBytecode;
	const float* const fRegisterData4[4] = 
	{
		&registerData[0].x,
		&registerData[1].x,
		&registerData[2].x,
		&registerData[3].x
	};
	const unsigned char replicateSwizzleChannel = srcParameter.GetChannelSwizzle();
	outReplicateValue[0] = fRegisterData4[0][replicateSwizzleChannel];
	outReplicateValue[1] = fRegisterData4[1][replicateSwizzleChannel];
	outReplicateValue[2] = fRegisterData4[2][replicateSwizzleChannel];
	outReplicateValue[3] = fRegisterData4[3][replicateSwizzleChannel];
}

// TODO: vs_3_0 introduced the concept of dst relative addressing (for output registers), we need to account for this somehow
void VShaderEngine::WriteDstParameter4(const dstParameterToken dstParameter, const D3DXVECTOR4 (&value4)[4])
{
	D3DXVECTOR4* out4[4];
	ResolveDstParameter4(dstParameter, out4);
	const unsigned writeMask = dstParameter.GetWriteMask();
	if (dstParameter.GetResultModifierUnshifted() & D3DSPDM_SATURATE) // Saturate
	{
		switch (writeMask)
		{
		case 0:
#ifdef _DEBUG
			__debugbreak(); // Should never be here
#endif
			break;
		case 0x1:
			out4[0]->x = saturate(value4[0].x);
			out4[1]->x = saturate(value4[1].x);
			out4[2]->x = saturate(value4[2].x);
			out4[3]->x = saturate(value4[3].x);
			break;
		case 0x3:
			out4[0]->x = saturate(value4[0].x);
			out4[1]->x = saturate(value4[1].x);
			out4[2]->x = saturate(value4[2].x);
			out4[3]->x = saturate(value4[3].x);
			// Intentional fallthrough
		case 0x2:
			out4[0]->y = saturate(value4[0].y);
			out4[1]->y = saturate(value4[1].y);
			out4[2]->y = saturate(value4[2].y);
			out4[3]->y = saturate(value4[3].y);
			break;
		case 0x7:
			out4[0]->x = saturate(value4[0].x);
			out4[1]->x = saturate(value4[1].x);
			out4[2]->x = saturate(value4[2].x);
			out4[3]->x = saturate(value4[3].x);
			// Intentional fallthrough
		case 0x6:
			out4[0]->y = saturate(value4[0].y);
			out4[1]->y = saturate(value4[1].y);
			out4[2]->y = saturate(value4[2].y);
			out4[3]->y = saturate(value4[3].y);
			// Intentional fallthrough
		case 0x4:
			out4[0]->z = saturate(value4[0].z);
			out4[1]->z = saturate(value4[1].z);
			out4[2]->z = saturate(value4[2].z);
			out4[3]->z = saturate(value4[3].z);
			break;
		case 0x5:
			out4[0]->x = saturate(value4[0].x);
			out4[1]->x = saturate(value4[1].x);
			out4[2]->x = saturate(value4[2].x);
			out4[3]->x = saturate(value4[3].x);
			out4[0]->z = saturate(value4[0].z);
			out4[1]->z = saturate(value4[1].z);
			out4[2]->z = saturate(value4[2].z);
			out4[3]->z = saturate(value4[3].z);
			break;
		default:
#ifdef _DEBUG
			__debugbreak();
#endif
		case 0xF: // The most common case, all bits are set!
			out4[0]->x = saturate(value4[0].x);
			out4[1]->x = saturate(value4[1].x);
			out4[2]->x = saturate(value4[2].x);
			out4[3]->x = saturate(value4[3].x);
			// Intentional fallthrough
		case 0xE: // 14
			out4[0]->y = saturate(value4[0].y);
			out4[1]->y = saturate(value4[1].y);
			out4[2]->y = saturate(value4[2].y);
			out4[3]->y = saturate(value4[3].y);
			// Intentional fallthrough
		case 0xC: // 12
			out4[0]->z = saturate(value4[0].z);
			out4[1]->z = saturate(value4[1].z);
			out4[2]->z = saturate(value4[2].z);
			out4[3]->z = saturate(value4[3].z);
			// Intentional fallthrough
		case 0x8:
			out4[0]->w = saturate(value4[0].w);
			out4[1]->w = saturate(value4[1].w);
			out4[2]->w = saturate(value4[2].w);
			out4[3]->w = saturate(value4[3].w);
			break;
		case 0x9:
			out4[0]->x = saturate(value4[0].x);
			out4[1]->x = saturate(value4[1].x);
			out4[2]->x = saturate(value4[2].x);
			out4[3]->x = saturate(value4[3].x);
			out4[0]->w = saturate(value4[0].w);
			out4[1]->w = saturate(value4[1].w);
			out4[2]->w = saturate(value4[2].w);
			out4[3]->w = saturate(value4[3].w);
			break;
		case 0xA: // 10
			out4[0]->w = saturate(value4[0].y);
			out4[1]->w = saturate(value4[1].y);
			out4[2]->w = saturate(value4[2].y);
			out4[3]->w = saturate(value4[3].y);
			break;
		case 0xB: // 11
			out4[0]->x = saturate(value4[0].x);
			out4[1]->x = saturate(value4[1].x);
			out4[2]->x = saturate(value4[2].x);
			out4[3]->x = saturate(value4[3].x);
			out4[0]->y = saturate(value4[0].y);
			out4[1]->y = saturate(value4[1].y);
			out4[2]->y = saturate(value4[2].y);
			out4[3]->y = saturate(value4[3].y);
			out4[0]->w = saturate(value4[0].w);
			out4[1]->w = saturate(value4[1].w);
			out4[2]->w = saturate(value4[2].w);
			out4[3]->w = saturate(value4[3].w);
			break;
		case 0xD: // 13
			out4[0]->x = saturate(value4[0].x);
			out4[1]->x = saturate(value4[1].x);
			out4[2]->x = saturate(value4[2].x);
			out4[3]->x = saturate(value4[3].x);
			out4[0]->z = saturate(value4[0].z);
			out4[1]->z = saturate(value4[1].z);
			out4[2]->z = saturate(value4[2].z);
			out4[3]->z = saturate(value4[3].z);
			out4[0]->w = saturate(value4[0].w);
			out4[1]->w = saturate(value4[1].w);
			out4[2]->w = saturate(value4[2].w);
			out4[3]->w = saturate(value4[3].w);
			break;
		}
	}
	else // No saturates
	{
		switch (writeMask)
		{
		case 0:
#ifdef _DEBUG
			__debugbreak(); // Should never be here
#endif
			break;
		case 0x1:
			out4[0]->x = value4[0].x;
			out4[1]->x = value4[1].x;
			out4[2]->x = value4[2].x;
			out4[3]->x = value4[3].x;
			break;
		case 0x3:
			out4[0]->x = value4[0].x;
			out4[1]->x = value4[1].x;
			out4[2]->x = value4[2].x;
			out4[3]->x = value4[3].x;
			// Intentional fallthrough
		case 0x2:
			out4[0]->y = value4[0].y;
			out4[1]->y = value4[1].y;
			out4[2]->y = value4[2].y;
			out4[3]->y = value4[3].y;
			break;
		case 0x7:
			out4[0]->x = value4[0].x;
			out4[1]->x = value4[1].x;
			out4[2]->x = value4[2].x;
			out4[3]->x = value4[3].x;
			// Intentional fallthrough
		case 0x6:
			out4[0]->y = value4[0].y;
			out4[1]->y = value4[1].y;
			out4[2]->y = value4[2].y;
			out4[3]->y = value4[3].y;
			// Intentional fallthrough
		case 0x4:
			out4[0]->z = value4[0].z;
			out4[1]->z = value4[1].z;
			out4[2]->z = value4[2].z;
			out4[3]->z = value4[3].z;
			break;
		case 0x5:
			out4[0]->x = value4[0].x;
			out4[1]->x = value4[1].x;
			out4[2]->x = value4[2].x;
			out4[3]->x = value4[3].x;
			out4[0]->z = value4[0].z;
			out4[1]->z = value4[1].z;
			out4[2]->z = value4[2].z;
			out4[3]->z = value4[3].z;
			break;
		default:
#ifdef _DEBUG
			__debugbreak();
#endif
		case 0xF: // The most common case, all bits are set!
			out4[0]->x = value4[0].x;
			out4[1]->x = value4[1].x;
			out4[2]->x = value4[2].x;
			out4[3]->x = value4[3].x;
			// Intentional fallthrough
		case 0xE: // 14
			out4[0]->y = value4[0].y;
			out4[1]->y = value4[1].y;
			out4[2]->y = value4[2].y;
			out4[3]->y = value4[3].y;
			// Intentional fallthrough
		case 0xC: // 12
			out4[0]->z = value4[0].z;
			out4[1]->z = value4[1].z;
			out4[2]->z = value4[2].z;
			out4[3]->z = value4[3].z;
			// Intentional fallthrough
		case 0x8:
			out4[0]->w = value4[0].w;
			out4[1]->w = value4[1].w;
			out4[2]->w = value4[2].w;
			out4[3]->w = value4[3].w;
			break;
		case 0x9:
			out4[0]->x = value4[0].x;
			out4[1]->x = value4[1].x;
			out4[2]->x = value4[2].x;
			out4[3]->x = value4[3].x;
			out4[0]->w = value4[0].w;
			out4[1]->w = value4[1].w;
			out4[2]->w = value4[2].w;
			out4[3]->w = value4[3].w;
			break;
		case 0xA: // 10
			out4[0]->y = value4[0].y;
			out4[1]->y = value4[1].y;
			out4[2]->y = value4[2].y;
			out4[3]->y = value4[3].y;
			out4[0]->w = value4[0].w;
			out4[1]->w = value4[1].w;
			out4[2]->w = value4[2].w;
			out4[3]->w = value4[3].w;
			break;
		case 0xB: // 11
			out4[0]->x = value4[0].x;
			out4[1]->x = value4[1].x;
			out4[2]->x = value4[2].x;
			out4[3]->x = value4[3].x;
			out4[0]->y = value4[0].y;
			out4[1]->y = value4[1].y;
			out4[2]->y = value4[2].y;
			out4[3]->y = value4[3].y;
			out4[0]->w = value4[0].w;
			out4[1]->w = value4[1].w;
			out4[2]->w = value4[2].w;
			out4[3]->w = value4[3].w;
			break;
		case 0xD: // 13
			out4[0]->x = value4[0].x;
			out4[1]->x = value4[1].x;
			out4[2]->x = value4[2].x;
			out4[3]->x = value4[3].x;
			out4[0]->z = value4[0].z;
			out4[1]->z = value4[1].z;
			out4[2]->z = value4[2].z;
			out4[3]->z = value4[3].z;
			out4[0]->w = value4[0].w;
			out4[1]->w = value4[1].w;
			out4[2]->w = value4[2].w;
			out4[3]->w = value4[3].w;
			break;
		}
	}
}

template <const bool isVS3_0>
void VShaderEngine::ResolveDstParameterVS4(const D3DSHADER_PARAM_REGISTER_TYPE registerType, const unsigned index, D3DXVECTOR4* (&outDstRegisters)[4])
{
	switch (registerType)
	{
	case D3DSPR_TEMP       :
#ifdef _DEBUG
		if (index >= ARRAYSIZE(VS_2_0_RuntimeRegisters::r) )
		{
			__debugbreak(); // Out of bounds register index!
		}
#endif
		outDstRegisters[0] = &runtimeRegisters[0].r[index];
		outDstRegisters[1] = &runtimeRegisters[1].r[index];
		outDstRegisters[2] = &runtimeRegisters[2].r[index];
		outDstRegisters[3] = &runtimeRegisters[3].r[index];
		return;
	case D3DSPR_INPUT      :
#ifdef _DEBUG
		__debugbreak(); // input registers can't be dst registers
#endif
		outDstRegisters[0] = &inputRegisters[0].v[index];
		outDstRegisters[1] = &inputRegisters[1].v[index];
		outDstRegisters[2] = &inputRegisters[2].v[index];
		outDstRegisters[3] = &inputRegisters[3].v[index];
		return;
	case D3DSPR_CONST      :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst registers
#endif
		outDstRegisters[0] = const_cast<D3DXVECTOR4* const>(&constantRegisters->c[index]);
		outDstRegisters[1] = const_cast<D3DXVECTOR4* const>(&constantRegisters->c[index]);
		outDstRegisters[2] = const_cast<D3DXVECTOR4* const>(&constantRegisters->c[index]);
		outDstRegisters[3] = const_cast<D3DXVECTOR4* const>(&constantRegisters->c[index]);
		return;
	case D3DSPR_ADDR       : // Also known as D3DSPR_TEXTURE (PS)
		outDstRegisters[0] = (D3DXVECTOR4* const)&runtimeRegisters[0].a;
		outDstRegisters[1] = (D3DXVECTOR4* const)&runtimeRegisters[1].a;
		outDstRegisters[2] = (D3DXVECTOR4* const)&runtimeRegisters[2].a;
		outDstRegisters[3] = (D3DXVECTOR4* const)&runtimeRegisters[3].a;
		return;
	case D3DSPR_RASTOUT    :
#ifdef _DEBUG
		if (index >= 3)
		{
			__debugbreak(); // Out of bounds register index!
		}
#endif
		outDstRegisters[0] = &(outputRegisters[0]->oPos) + index;
		outDstRegisters[1] = &(outputRegisters[1]->oPos) + index;
		outDstRegisters[2] = &(outputRegisters[2]->oPos) + index;
		outDstRegisters[3] = &(outputRegisters[3]->oPos) + index;
		return;
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
		if (isVS3_0)
		{
#ifdef _DEBUG
			if (index >= ARRAYSIZE(VS_2_0_OutputRegisters::_vs_interpolated_outputs::_vs_3_0_outputs::oT) )
			{
				__debugbreak(); // Out of bounds register index!
			}
#endif
			outDstRegisters[0] = (D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			outDstRegisters[1] = (D3DXVECTOR4* const)&outputRegisters[1]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			outDstRegisters[2] = (D3DXVECTOR4* const)&outputRegisters[2]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			outDstRegisters[3] = (D3DXVECTOR4* const)&outputRegisters[3]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
		}
		else
		{
#ifdef _DEBUG
			if (index >= ARRAYSIZE(VS_2_0_OutputRegisters::_vs_interpolated_outputs::_vs_2_0_outputs::oT) )
			{
				__debugbreak(); // Out of bounds register index!
			}
#endif
			outDstRegisters[0] = (D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oT[index];
			outDstRegisters[1] = (D3DXVECTOR4* const)&outputRegisters[1]->vs_interpolated_outputs.vs_2_0_outputs.oT[index];
			outDstRegisters[2] = (D3DXVECTOR4* const)&outputRegisters[2]->vs_interpolated_outputs.vs_2_0_outputs.oT[index];
			outDstRegisters[3] = (D3DXVECTOR4* const)&outputRegisters[3]->vs_interpolated_outputs.vs_2_0_outputs.oT[index];
		}
		return;
	case D3DSPR_CONSTINT   :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst registers
#endif
		outDstRegisters[0] = (D3DXVECTOR4* const)&constantRegisters->i[index];
		outDstRegisters[1] = (D3DXVECTOR4* const)&constantRegisters->i[index];
		outDstRegisters[2] = (D3DXVECTOR4* const)&constantRegisters->i[index];
		outDstRegisters[3] = (D3DXVECTOR4* const)&constantRegisters->i[index];
		return;
	case D3DSPR_COLOROUT   :
		if (isVS3_0)
		{
#ifdef _DEBUG
			if (index >= ARRAYSIZE(VS_2_0_OutputRegisters::_vs_interpolated_outputs::_vs_3_0_outputs::oT) )
			{
				__debugbreak(); // Out of bounds register index!
			}
#endif
			outDstRegisters[0] = (D3DXVECTOR4* const)&(outputRegisters[0]->vs_interpolated_outputs.vs_3_0_outputs.oT[index]);
			outDstRegisters[1] = (D3DXVECTOR4* const)&(outputRegisters[1]->vs_interpolated_outputs.vs_3_0_outputs.oT[index]);
			outDstRegisters[2] = (D3DXVECTOR4* const)&(outputRegisters[2]->vs_interpolated_outputs.vs_3_0_outputs.oT[index]);
			outDstRegisters[3] = (D3DXVECTOR4* const)&(outputRegisters[3]->vs_interpolated_outputs.vs_3_0_outputs.oT[index]);
		}
		else
		{
#ifdef _DEBUG
			if (index >= ARRAYSIZE(VS_2_0_OutputRegisters::_vs_interpolated_outputs::_vs_2_0_outputs::oD) )
			{
				__debugbreak(); // Out of bounds register index!
			}
#endif
			outDstRegisters[0] = (D3DXVECTOR4* const)&(outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oD[index]);
			outDstRegisters[1] = (D3DXVECTOR4* const)&(outputRegisters[1]->vs_interpolated_outputs.vs_2_0_outputs.oD[index]);
			outDstRegisters[2] = (D3DXVECTOR4* const)&(outputRegisters[2]->vs_interpolated_outputs.vs_2_0_outputs.oD[index]);
			outDstRegisters[3] = (D3DXVECTOR4* const)&(outputRegisters[3]->vs_interpolated_outputs.vs_2_0_outputs.oD[index]);
		}
		return;
	case D3DSPR_ATTROUT    :
		if (isVS3_0)
		{
			outDstRegisters[0] = &outputRegisters[0]->oFog;
			outDstRegisters[1] = &outputRegisters[1]->oFog;
			outDstRegisters[2] = &outputRegisters[2]->oFog;
			outDstRegisters[3] = &outputRegisters[3]->oFog;
		}
		else
		{
#ifdef _DEBUG
			if (index >= ARRAYSIZE(VS_2_0_OutputRegisters::_vs_interpolated_outputs::_vs_2_0_outputs::oD) )
			{
				__debugbreak(); // Out of bounds register index!
			}
#endif
			outDstRegisters[0] = (D3DXVECTOR4* const)&(outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oD[index]);
			outDstRegisters[1] = (D3DXVECTOR4* const)&(outputRegisters[1]->vs_interpolated_outputs.vs_2_0_outputs.oD[index]);
			outDstRegisters[2] = (D3DXVECTOR4* const)&(outputRegisters[2]->vs_interpolated_outputs.vs_2_0_outputs.oD[index]);
			outDstRegisters[3] = (D3DXVECTOR4* const)&(outputRegisters[3]->vs_interpolated_outputs.vs_2_0_outputs.oD[index]);
		}
		return;
	case D3DSPR_DEPTHOUT   :
#ifdef _DEBUG
		__debugbreak(); // This should only be used from the PShader
#else
		outDstRegisters[0] = &runtimeRegisters[0].r[0];
		outDstRegisters[1] = &runtimeRegisters[1].r[0];
		outDstRegisters[2] = &runtimeRegisters[2].r[0];
		outDstRegisters[3] = &runtimeRegisters[3].r[0];
		return;
#endif
	case D3DSPR_SAMPLER    :
#ifdef _DEBUG
		__debugbreak(); // Sampler registers can't be dst registers - also sampler registers can't be used before vs_3_0
#else
		outDstRegisters[0] = &runtimeRegisters[0].r[0];
		outDstRegisters[1] = &runtimeRegisters[1].r[0];
		outDstRegisters[2] = &runtimeRegisters[2].r[0];
		outDstRegisters[3] = &runtimeRegisters[3].r[0];
		return;
#endif
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst registers
#else
		outDstRegisters[0] = &runtimeRegisters[0].r[0];
		outDstRegisters[1] = &runtimeRegisters[1].r[0];
		outDstRegisters[2] = &runtimeRegisters[2].r[0];
		outDstRegisters[3] = &runtimeRegisters[3].r[0];
		return;
#endif
	case D3DSPR_CONSTBOOL  :
#ifdef _DEBUG
		__debugbreak(); // Const registers can't be dst registers
#endif
		outDstRegisters[0] = (D3DXVECTOR4* const)&constantRegisters->b[index];
		outDstRegisters[1] = (D3DXVECTOR4* const)&constantRegisters->b[index];
		outDstRegisters[2] = (D3DXVECTOR4* const)&constantRegisters->b[index];
		outDstRegisters[3] = (D3DXVECTOR4* const)&constantRegisters->b[index];
		return;
	case D3DSPR_LOOP       :
		outDstRegisters[0] = (D3DXVECTOR4* const)&runtimeRegisters[0].aL;
		outDstRegisters[1] = (D3DXVECTOR4* const)&runtimeRegisters[1].aL;
		outDstRegisters[2] = (D3DXVECTOR4* const)&runtimeRegisters[2].aL;
		outDstRegisters[3] = (D3DXVECTOR4* const)&runtimeRegisters[3].aL;
		return;
	case D3DSPR_TEMPFLOAT16:
#ifdef _DEBUG
		__debugbreak();
#else
		outDstRegisters[0] = &runtimeRegisters[0].r[0];
		outDstRegisters[1] = &runtimeRegisters[1].r[0];
		outDstRegisters[2] = &runtimeRegisters[2].r[0];
		outDstRegisters[3] = &runtimeRegisters[3].r[0];
		return;
#endif
	case D3DSPR_MISCTYPE   :
#ifdef _DEBUG
		__debugbreak();
#endif
		outDstRegisters[0] = &runtimeRegisters[0].r[index];
		outDstRegisters[1] = &runtimeRegisters[1].r[index];
		outDstRegisters[2] = &runtimeRegisters[2].r[index];
		outDstRegisters[3] = &runtimeRegisters[3].r[index];
		return;
	case D3DSPR_LABEL      :
#ifdef _DEBUG
		__debugbreak(); // Labels can't be dst registers
#else
		outDstRegisters[0] = &runtimeRegisters[0].r[0];
		outDstRegisters[1] = &runtimeRegisters[1].r[0];
		outDstRegisters[2] = &runtimeRegisters[2].r[0];
		outDstRegisters[3] = &runtimeRegisters[3].r[0];
		return;
#endif
	case D3DSPR_PREDICATE  :
		outDstRegisters[0] = (D3DXVECTOR4* const)&runtimeRegisters[0].p;
		outDstRegisters[1] = (D3DXVECTOR4* const)&runtimeRegisters[1].p;
		outDstRegisters[2] = (D3DXVECTOR4* const)&runtimeRegisters[2].p;
		outDstRegisters[3] = (D3DXVECTOR4* const)&runtimeRegisters[3].p;
		return;
	default:
#ifdef _DEBUG
		{
			__debugbreak(); // Should never be here (invalid SPR type)
		}
#else
			__assume(0);
#endif
	}

	{
		__debugbreak();
	}
	outDstRegisters[0] = NULL;
	outDstRegisters[1] = NULL;
	outDstRegisters[2] = NULL;
	outDstRegisters[3] = NULL;
}

void VShaderEngine::ResolveDstParameter4(const dstParameterToken dstParameter, D3DXVECTOR4* (&outDstRegisters)[4])
{
	const unsigned index = dstParameter.GetRegisterIndex();
	switch (shaderInfo->shaderMajorVersion)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case 1:
	case 2:
		ResolveDstParameterVS4<false>(dstParameter.GetRegisterType(), index, outDstRegisters);
		break;
	case 3:
		ResolveDstParameterVS4<true>(dstParameter.GetRegisterType(), index, outDstRegisters);
		break;
	}
}

template <const bool isVS3_0>
void VShaderEngine::ResolveSrcParameterVS4(const D3DSHADER_PARAM_REGISTER_TYPE registerType, const unsigned index, const D3DXVECTOR4* (&outSrcRegisters)[4]) const
{
	switch (registerType)
	{
	case D3DSPR_TEMP       :
		outSrcRegisters[0] = &runtimeRegisters[0].r[index];
		outSrcRegisters[1] = &runtimeRegisters[1].r[index];
		outSrcRegisters[2] = &runtimeRegisters[2].r[index];
		outSrcRegisters[3] = &runtimeRegisters[3].r[index];
		return;
	case D3DSPR_INPUT      :
		outSrcRegisters[0] = &inputRegisters[0].v[index];
		outSrcRegisters[1] = &inputRegisters[1].v[index];
		outSrcRegisters[2] = &inputRegisters[2].v[index];
		outSrcRegisters[3] = &inputRegisters[3].v[index];
		return;
	case D3DSPR_CONST      :
		outSrcRegisters[0] = &constantRegisters->c[index];
		outSrcRegisters[1] = &constantRegisters->c[index];
		outSrcRegisters[2] = &constantRegisters->c[index];
		outSrcRegisters[3] = &constantRegisters->c[index];
		return;
	case D3DSPR_ADDR       : // Also known as D3DSPR_TEXTURE (PS)
		outSrcRegisters[0] = (const D3DXVECTOR4* const)&runtimeRegisters[0].a;
		outSrcRegisters[1] = (const D3DXVECTOR4* const)&runtimeRegisters[1].a;
		outSrcRegisters[2] = (const D3DXVECTOR4* const)&runtimeRegisters[2].a;
		outSrcRegisters[3] = (const D3DXVECTOR4* const)&runtimeRegisters[3].a;
		return;
	case D3DSPR_RASTOUT    :
		if (isVS3_0)
		{
#ifdef _DEBUG
			__debugbreak();
#endif
			outSrcRegisters[0] = &runtimeRegisters[0].r[0];
			outSrcRegisters[1] = &runtimeRegisters[1].r[0];
			outSrcRegisters[2] = &runtimeRegisters[2].r[0];
			outSrcRegisters[3] = &runtimeRegisters[3].r[0];
			return;
		}
		else
		{
			outSrcRegisters[0] = (&outputRegisters[0]->oPos) + index;
			outSrcRegisters[1] = (&outputRegisters[1]->oPos) + index;
			outSrcRegisters[2] = (&outputRegisters[2]->oPos) + index;
			outSrcRegisters[3] = (&outputRegisters[3]->oPos) + index;
			return;
		}
	case D3DSPR_TEXCRDOUT  : // Also known as D3DSPR_OUTPUT
		if (isVS3_0)
		{
			outSrcRegisters[0] = (const D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			outSrcRegisters[1] = (const D3DXVECTOR4* const)&outputRegisters[1]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			outSrcRegisters[2] = (const D3DXVECTOR4* const)&outputRegisters[2]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			outSrcRegisters[3] = (const D3DXVECTOR4* const)&outputRegisters[3]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			return;
		}
		else
		{
			outSrcRegisters[0] = (const D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oT[index];
			outSrcRegisters[1] = (const D3DXVECTOR4* const)&outputRegisters[1]->vs_interpolated_outputs.vs_2_0_outputs.oT[index];
			outSrcRegisters[2] = (const D3DXVECTOR4* const)&outputRegisters[2]->vs_interpolated_outputs.vs_2_0_outputs.oT[index];
			outSrcRegisters[3] = (const D3DXVECTOR4* const)&outputRegisters[3]->vs_interpolated_outputs.vs_2_0_outputs.oT[index];
			return;
		}
	case D3DSPR_CONSTINT   :
		outSrcRegisters[0] = (const D3DXVECTOR4* const)&constantRegisters->i[index];
		outSrcRegisters[1] = (const D3DXVECTOR4* const)&constantRegisters->i[index];
		outSrcRegisters[2] = (const D3DXVECTOR4* const)&constantRegisters->i[index];
		outSrcRegisters[3] = (const D3DXVECTOR4* const)&constantRegisters->i[index];
		return;
	case D3DSPR_COLOROUT   :
		if (isVS3_0)
		{
			outSrcRegisters[0] = (const D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			outSrcRegisters[1] = (const D3DXVECTOR4* const)&outputRegisters[1]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			outSrcRegisters[2] = (const D3DXVECTOR4* const)&outputRegisters[2]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			outSrcRegisters[3] = (const D3DXVECTOR4* const)&outputRegisters[3]->vs_interpolated_outputs.vs_3_0_outputs.oT[index];
			return;
		}
		else
		{
			outSrcRegisters[0] = (const D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
			outSrcRegisters[1] = (const D3DXVECTOR4* const)&outputRegisters[1]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
			outSrcRegisters[2] = (const D3DXVECTOR4* const)&outputRegisters[2]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
			outSrcRegisters[3] = (const D3DXVECTOR4* const)&outputRegisters[3]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
			return;
		}
	case D3DSPR_ATTROUT    :
		if (isVS3_0)
		{
			outSrcRegisters[0] = &outputRegisters[0]->oFog;
			outSrcRegisters[1] = &outputRegisters[1]->oFog;
			outSrcRegisters[2] = &outputRegisters[2]->oFog;
			outSrcRegisters[3] = &outputRegisters[3]->oFog;
			return;
		}
		else
		{
			outSrcRegisters[0] = (const D3DXVECTOR4* const)&outputRegisters[0]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
			outSrcRegisters[1] = (const D3DXVECTOR4* const)&outputRegisters[1]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
			outSrcRegisters[2] = (const D3DXVECTOR4* const)&outputRegisters[2]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
			outSrcRegisters[3] = (const D3DXVECTOR4* const)&outputRegisters[3]->vs_interpolated_outputs.vs_2_0_outputs.oD[index];
			return;
		}
	case D3DSPR_DEPTHOUT   :
#ifdef _DEBUG
		__debugbreak();
#else
		outSrcRegisters[0] = &runtimeRegisters[0].r[0];
		outSrcRegisters[1] = &runtimeRegisters[1].r[0];
		outSrcRegisters[2] = &runtimeRegisters[2].r[0];
		outSrcRegisters[3] = &runtimeRegisters[3].r[0];
		return;
#endif
	case D3DSPR_SAMPLER    :
#ifdef _DEBUG
		__debugbreak();
#else
		outSrcRegisters[0] = &runtimeRegisters[0].r[0];
		outSrcRegisters[1] = &runtimeRegisters[1].r[0];
		outSrcRegisters[2] = &runtimeRegisters[2].r[0];
		outSrcRegisters[3] = &runtimeRegisters[3].r[0];
#endif
		return;
	case D3DSPR_CONST2     :
	case D3DSPR_CONST3     :
	case D3DSPR_CONST4     :
#ifdef _DEBUG
		__debugbreak();
#else
		outSrcRegisters[0] = &runtimeRegisters[0].r[0];
		outSrcRegisters[1] = &runtimeRegisters[1].r[0];
		outSrcRegisters[2] = &runtimeRegisters[2].r[0];
		outSrcRegisters[3] = &runtimeRegisters[3].r[0];
#endif
		return;
	case D3DSPR_CONSTBOOL  :
		outSrcRegisters[0] = (const D3DXVECTOR4* const)&constantRegisters->b[index];
		outSrcRegisters[1] = (const D3DXVECTOR4* const)&constantRegisters->b[index];
		outSrcRegisters[2] = (const D3DXVECTOR4* const)&constantRegisters->b[index];
		outSrcRegisters[3] = (const D3DXVECTOR4* const)&constantRegisters->b[index];
		return;
	case D3DSPR_LOOP       :
		outSrcRegisters[0] = (const D3DXVECTOR4* const)&runtimeRegisters[0].aL;
		outSrcRegisters[1] = (const D3DXVECTOR4* const)&runtimeRegisters[1].aL;
		outSrcRegisters[2] = (const D3DXVECTOR4* const)&runtimeRegisters[2].aL;
		outSrcRegisters[3] = (const D3DXVECTOR4* const)&runtimeRegisters[3].aL;
		return;
	case D3DSPR_TEMPFLOAT16:
#ifdef _DEBUG
		__debugbreak();
#else
		outSrcRegisters[0] = &runtimeRegisters[0].r[0];
		outSrcRegisters[1] = &runtimeRegisters[1].r[0];
		outSrcRegisters[2] = &runtimeRegisters[2].r[0];
		outSrcRegisters[3] = &runtimeRegisters[3].r[0];
#endif
		return;
	case D3DSPR_MISCTYPE   :
#ifdef _DEBUG
		__debugbreak();
#endif
		outSrcRegisters[0] = &runtimeRegisters[0].r[index];
		outSrcRegisters[1] = &runtimeRegisters[1].r[index];
		outSrcRegisters[2] = &runtimeRegisters[2].r[index];
		outSrcRegisters[3] = &runtimeRegisters[3].r[index];
		return;
	case D3DSPR_LABEL      :
#ifdef _DEBUG
		__debugbreak(); // Uhhhhh, is this debugbreak correct? Aren't Labels allowed to be source parameters for the CALL and CALLNZ instructions?
#else
		outSrcRegisters[0] = &runtimeRegisters[0].r[0];
		outSrcRegisters[1] = &runtimeRegisters[1].r[0];
		outSrcRegisters[2] = &runtimeRegisters[2].r[0];
		outSrcRegisters[3] = &runtimeRegisters[3].r[0];
#endif
		return;
	case D3DSPR_PREDICATE  :
		outSrcRegisters[0] = (const D3DXVECTOR4* const)&runtimeRegisters[0].p;
		outSrcRegisters[1] = (const D3DXVECTOR4* const)&runtimeRegisters[1].p;
		outSrcRegisters[2] = (const D3DXVECTOR4* const)&runtimeRegisters[2].p;
		outSrcRegisters[3] = (const D3DXVECTOR4* const)&runtimeRegisters[3].p;
		return;
	default:
#ifdef _DEBUG
		{
			__debugbreak();
		}
#else
			__assume(0);
#endif
	}

	{
		__debugbreak();
	}

	outSrcRegisters[0] = NULL;
	outSrcRegisters[1] = NULL;
	outSrcRegisters[2] = NULL;
	outSrcRegisters[3] = NULL;
}

void VShaderEngine::ResolveSrcParameter4(const srcParameterToken srcParameter, const D3DXVECTOR4* (&outSrcRegisters)[4]) const
{
	const unsigned index = srcParameter.GetRegisterIndex();
	switch (shaderInfo->shaderMajorVersion)
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case 1:
	case 2:
		ResolveSrcParameterVS4<false>(srcParameter.GetRegisterType(), index, outSrcRegisters);
		return;
	case 3:
		ResolveSrcParameterVS4<true>(srcParameter.GetRegisterType(), index, outSrcRegisters);
		return;
	}
}

// Source parameter token: https://msdn.microsoft.com/en-us/library/windows/hardware/ff569716(v=vs.85).aspx
void VShaderEngine::ResolveSrcRegister4(const DWORD*& ptrSrcBytecode, D3DXVECTOR4 (&outSrcRegisters)[4]) const
{
	const DWORD rawSrcBytecode = *ptrSrcBytecode;
	const srcParameterToken& srcParameter = *(const srcParameterToken* const)&rawSrcBytecode;

	// Advance the instruction pointer (very important):
	++ptrSrcBytecode;

	const D3DXVECTOR4* sourceParamPtr4[4] = { NULL };

	switch (srcParameter.GetRelativeAddressingType() )
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#else
		__assume(0);
#endif
	case D3DSHADER_ADDRMODE_ABSOLUTE:
		ResolveSrcParameter4(srcParameter, sourceParamPtr4);
		break;
	case D3DSHADER_ADDRMODE_RELATIVE:
	{
		int addressOffsetRegisters4[4] = { 0 };

		const D3DXVECTOR4* originalSourceParamPtr4[4] = { NULL };
		ResolveSrcParameter4(srcParameter, originalSourceParamPtr4);

		union
		{
			const int4* addressRegister4i[4];
			const D3DXVECTOR4* addressRegister4f[4];
		} address4;

		// If SM2 or up, then relative addressing can use either the address register (a) or the loop
		// counter register (aL), so it needs another DWORD to know which to use. Otherwise (if vs_1_1) then
		// there's no extra relative addressing token and reading from a.x (the first component of the address
		// register) is assumed.
		if (shaderInfo->shaderMajorVersion > 1)
		{
			// Shader relative addressing: https://msdn.microsoft.com/en-us/library/windows/hardware/ff569708(v=vs.85).aspx
			const srcParameterToken& relativeAddressingSrcToken = *(const srcParameterToken* const)ptrSrcBytecode++;

			ResolveSrcParameter4(relativeAddressingSrcToken, address4.addressRegister4f);

			const unsigned int addressRegisterSwizzle = relativeAddressingSrcToken.GetChannelSwizzleXYZW();
			switch (addressRegisterSwizzle)
			{
			default:
#ifdef _DEBUG
				__debugbreak(); // Not sure what kinda swizzle we have here, but it's not a replicate-swizzle...
#endif
			case D3DSP_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT: // "No swizzle" in this case means "implied .xxxx" for the address register
			case D3DSP_REPLICATERED >> D3DVS_SWIZZLE_SHIFT:
				addressOffsetRegisters4[0] = RoundToNearest(address4.addressRegister4f[0]->x);
				addressOffsetRegisters4[1] = RoundToNearest(address4.addressRegister4f[1]->x);
				addressOffsetRegisters4[2] = RoundToNearest(address4.addressRegister4f[2]->x);
				addressOffsetRegisters4[3] = RoundToNearest(address4.addressRegister4f[3]->x);
				break;
			case D3DSP_REPLICATEGREEN >> D3DVS_SWIZZLE_SHIFT:
				addressOffsetRegisters4[0] = RoundToNearest(address4.addressRegister4f[0]->y);
				addressOffsetRegisters4[1] = RoundToNearest(address4.addressRegister4f[1]->y);
				addressOffsetRegisters4[2] = RoundToNearest(address4.addressRegister4f[2]->y);
				addressOffsetRegisters4[3] = RoundToNearest(address4.addressRegister4f[3]->y);
				break;
			case D3DSP_REPLICATEBLUE >> D3DVS_SWIZZLE_SHIFT:
				addressOffsetRegisters4[0] = RoundToNearest(address4.addressRegister4f[0]->z);
				addressOffsetRegisters4[1] = RoundToNearest(address4.addressRegister4f[1]->z);
				addressOffsetRegisters4[2] = RoundToNearest(address4.addressRegister4f[2]->z);
				addressOffsetRegisters4[3] = RoundToNearest(address4.addressRegister4f[3]->z);
				break;
			case D3DSP_REPLICATEALPHA >> D3DVS_SWIZZLE_SHIFT:
				addressOffsetRegisters4[0] = RoundToNearest(address4.addressRegister4f[0]->w);
				addressOffsetRegisters4[1] = RoundToNearest(address4.addressRegister4f[1]->w);
				addressOffsetRegisters4[2] = RoundToNearest(address4.addressRegister4f[2]->w);
				addressOffsetRegisters4[3] = RoundToNearest(address4.addressRegister4f[3]->w);
				break;
			}
		}
		else // Shader model 1 case:
		{
			ResolveSrcParameterVS4<false>(D3DSPR_ADDR, 0, address4.addressRegister4f);
			addressOffsetRegisters4[0] = RoundToNearest(address4.addressRegister4f[0]->x);
			addressOffsetRegisters4[1] = RoundToNearest(address4.addressRegister4f[1]->x);
			addressOffsetRegisters4[2] = RoundToNearest(address4.addressRegister4f[2]->x);
			addressOffsetRegisters4[3] = RoundToNearest(address4.addressRegister4f[3]->x);
		}

		const void* const relativeRegister4[4] = 
		{
			originalSourceParamPtr4[0] + addressOffsetRegisters4[0],
			originalSourceParamPtr4[1] + addressOffsetRegisters4[1],
			originalSourceParamPtr4[2] + addressOffsetRegisters4[2],
			originalSourceParamPtr4[3] + addressOffsetRegisters4[3]
		};
		ResolveSrcAddressIfValid4(relativeRegister4, sourceParamPtr4);
	}

		break;
	}

	const unsigned char sourceSwizzle = srcParameter.GetSwizzle();

	D3DXVECTOR4 ret4[4];

	// Handle source swizzles (if any are present):
	if (sourceSwizzle == (D3DVS_NOSWIZZLE >> D3DVS_SWIZZLE_SHIFT) )
	{
		ret4[0] = *sourceParamPtr4[0];
		ret4[1] = *sourceParamPtr4[1];
		ret4[2] = *sourceParamPtr4[2];
		ret4[3] = *sourceParamPtr4[3];
	}
	else
	{
		const float* const fltParams4[4] = 
		{
			&sourceParamPtr4[0]->x,
			&sourceParamPtr4[1]->x,
			&sourceParamPtr4[2]->x,
			&sourceParamPtr4[3]->x
		};

		// R channel
		const unsigned char rSwizzleSelect = sourceSwizzle & 0x3;
		ret4[0].x = fltParams4[0][rSwizzleSelect];
		ret4[1].x = fltParams4[1][rSwizzleSelect];
		ret4[2].x = fltParams4[2][rSwizzleSelect];
		ret4[3].x = fltParams4[3][rSwizzleSelect];

		// G channel
		const unsigned char gSwizzleSelect = (sourceSwizzle >> 2) & 0x3;
		ret4[0].y = fltParams4[0][gSwizzleSelect];
		ret4[1].y = fltParams4[1][gSwizzleSelect];
		ret4[2].y = fltParams4[2][gSwizzleSelect];
		ret4[3].y = fltParams4[3][gSwizzleSelect];

		// B channel
		const unsigned char bSwizzleSelect = (sourceSwizzle >> 4) & 0x3;
		ret4[0].z = fltParams4[0][bSwizzleSelect];
		ret4[1].z = fltParams4[1][bSwizzleSelect];
		ret4[2].z = fltParams4[2][bSwizzleSelect];
		ret4[3].z = fltParams4[3][bSwizzleSelect];

		// A channel
		const unsigned char aSwizzleSelect = (sourceSwizzle >> 6) & 0x3;
		ret4[0].w = fltParams4[0][aSwizzleSelect];
		ret4[1].w = fltParams4[1][aSwizzleSelect];
		ret4[2].w = fltParams4[2][aSwizzleSelect];
		ret4[3].w = fltParams4[3][aSwizzleSelect];
	}

	switch (srcParameter.GetSourceModifiersUnshifted() )
	{
	default:
#ifdef _DEBUG
		__debugbreak();
#endif
	case D3DSPSM_NONE   :
		outSrcRegisters[0] = ret4[0];
		outSrcRegisters[1] = ret4[1];
		outSrcRegisters[2] = ret4[2];
		outSrcRegisters[3] = ret4[3];
		return;
	case D3DSPSM_NEG    :
		outSrcRegisters[0] = ret4[0] * -1.0f;
		outSrcRegisters[1] = ret4[1] * -1.0f;
		outSrcRegisters[2] = ret4[2] * -1.0f;
		outSrcRegisters[3] = ret4[3] * -1.0f;
		return;
	case D3DSPSM_BIAS   :
	{
		outSrcRegisters[0] = ret4[0] + negHalfVec;
		outSrcRegisters[1] = ret4[1] + negHalfVec;
		outSrcRegisters[2] = ret4[2] + negHalfVec;
		outSrcRegisters[3] = ret4[3] + negHalfVec;
	}
		return;
	case D3DSPSM_BIASNEG:
	{
		ret4[0] += negHalfVec;
		ret4[1] += negHalfVec;
		ret4[2] += negHalfVec;
		ret4[3] += negHalfVec;
		outSrcRegisters[0] = ret4[0] * -1.0f;
		outSrcRegisters[1] = ret4[1] * -1.0f;
		outSrcRegisters[2] = ret4[2] * -1.0f;
		outSrcRegisters[3] = ret4[3] * -1.0f;
	}
		return;
	case D3DSPSM_SIGN   :
	{
		ret4[0] += negHalfVec;
		ret4[1] += negHalfVec;
		ret4[2] += negHalfVec;
		ret4[3] += negHalfVec;
		outSrcRegisters[0] = ret4[0] * 2.0f;
		outSrcRegisters[1] = ret4[1] * 2.0f;
		outSrcRegisters[2] = ret4[2] * 2.0f;
		outSrcRegisters[3] = ret4[3] * 2.0f;
	}
		return;
	case D3DSPSM_SIGNNEG:
	{
		ret4[0] += negHalfVec;
		ret4[1] += negHalfVec;
		ret4[2] += negHalfVec;
		ret4[3] += negHalfVec;
		outSrcRegisters[0] = ret4[0] * -2.0f;
		outSrcRegisters[1] = ret4[1] * -2.0f;
		outSrcRegisters[2] = ret4[2] * -2.0f;
		outSrcRegisters[3] = ret4[3] * -2.0f;
	}
		return;
	case D3DSPSM_COMP   :
	{
		const D3DXVECTOR4 oneVec(1.0f, 1.0f, 1.0f, 1.0f);
		outSrcRegisters[0] = oneVec - ret4[0];
		outSrcRegisters[1] = oneVec - ret4[1];
		outSrcRegisters[2] = oneVec - ret4[2];
		outSrcRegisters[3] = oneVec - ret4[3];
	}
		return;
	case D3DSPSM_X2     :
	{
		outSrcRegisters[0] = ret4[0] * 2.0f;
		outSrcRegisters[1] = ret4[1] * 2.0f;
		outSrcRegisters[2] = ret4[2] * 2.0f;
		outSrcRegisters[3] = ret4[3] * 2.0f;
	}
		return;
	case D3DSPSM_X2NEG  :
	{
		outSrcRegisters[0] = ret4[0] * -2.0f;
		outSrcRegisters[1] = ret4[1] * -2.0f;
		outSrcRegisters[2] = ret4[2] * -2.0f;
		outSrcRegisters[3] = ret4[3] * -2.0f;
	}
		return;
	case D3DSPSM_DZ     :
	{
		const float invZ4[4] = 
		{
			1.0f / ret4[0].z,
			1.0f / ret4[1].z,
			1.0f / ret4[2].z,
			1.0f / ret4[3].z
		};

		outSrcRegisters[0].x = ret4[0].x * invZ4[0];
		outSrcRegisters[1].x = ret4[1].x * invZ4[1];
		outSrcRegisters[2].x = ret4[2].x * invZ4[2];
		outSrcRegisters[3].x = ret4[3].x * invZ4[3];

		outSrcRegisters[0].y = ret4[0].y * invZ4[0];
		outSrcRegisters[1].y = ret4[1].y * invZ4[1];
		outSrcRegisters[2].y = ret4[2].y * invZ4[2];
		outSrcRegisters[3].y = ret4[3].y * invZ4[3];

		outSrcRegisters[0].z = ret4[0].z;
		outSrcRegisters[1].z = ret4[1].z;
		outSrcRegisters[2].z = ret4[2].z;
		outSrcRegisters[3].z = ret4[3].z;

		outSrcRegisters[0].w = ret4[0].w;
		outSrcRegisters[1].w = ret4[1].w;
		outSrcRegisters[2].w = ret4[2].w;
		outSrcRegisters[3].w = ret4[3].w;
	}
		return;
	case D3DSPSM_DW     :
	{
		const float invW4[4] = 
		{
			1.0f / ret4[0].w,
			1.0f / ret4[1].w,
			1.0f / ret4[2].w,
			1.0f / ret4[3].w
		};

		outSrcRegisters[0].x = ret4[0].x * invW4[0];
		outSrcRegisters[1].x = ret4[1].x * invW4[1];
		outSrcRegisters[2].x = ret4[2].x * invW4[2];
		outSrcRegisters[3].x = ret4[3].x * invW4[3];

		outSrcRegisters[0].y = ret4[0].y * invW4[0];
		outSrcRegisters[1].y = ret4[1].y * invW4[1];
		outSrcRegisters[2].y = ret4[2].y * invW4[2];
		outSrcRegisters[3].y = ret4[3].y * invW4[3];

		outSrcRegisters[0].z = ret4[0].z;
		outSrcRegisters[1].z = ret4[1].z;
		outSrcRegisters[2].z = ret4[2].z;
		outSrcRegisters[3].z = ret4[3].z;

		outSrcRegisters[0].w = ret4[0].w;
		outSrcRegisters[1].w = ret4[1].w;
		outSrcRegisters[2].w = ret4[2].w;
		outSrcRegisters[3].w = ret4[3].w;
	}
		return;
	case D3DSPSM_ABS    :
	{
		outSrcRegisters[0].x = fabsf(ret4[0].x);
		outSrcRegisters[1].x = fabsf(ret4[1].x);
		outSrcRegisters[2].x = fabsf(ret4[2].x);
		outSrcRegisters[3].x = fabsf(ret4[3].x);

		outSrcRegisters[0].y = fabsf(ret4[0].y);
		outSrcRegisters[1].y = fabsf(ret4[1].y);
		outSrcRegisters[2].y = fabsf(ret4[2].y);
		outSrcRegisters[3].y = fabsf(ret4[3].y);

		outSrcRegisters[0].z = fabsf(ret4[0].z);
		outSrcRegisters[1].z = fabsf(ret4[1].z);
		outSrcRegisters[2].z = fabsf(ret4[2].z);
		outSrcRegisters[3].z = fabsf(ret4[3].z);

		outSrcRegisters[0].w = fabsf(ret4[0].w);
		outSrcRegisters[1].w = fabsf(ret4[1].w);
		outSrcRegisters[2].w = fabsf(ret4[2].w);
		outSrcRegisters[3].w = fabsf(ret4[3].w);
	}
		return;
	case D3DSPSM_ABSNEG :
	{
		outSrcRegisters[0].x = -fabsf(ret4[0].x);
		outSrcRegisters[1].x = -fabsf(ret4[1].x);
		outSrcRegisters[2].x = -fabsf(ret4[2].x);
		outSrcRegisters[3].x = -fabsf(ret4[3].x);

		outSrcRegisters[0].y = -fabsf(ret4[0].y);
		outSrcRegisters[1].y = -fabsf(ret4[1].y);
		outSrcRegisters[2].y = -fabsf(ret4[2].y);
		outSrcRegisters[3].y = -fabsf(ret4[3].y);

		outSrcRegisters[0].z = -fabsf(ret4[0].z);
		outSrcRegisters[1].z = -fabsf(ret4[1].z);
		outSrcRegisters[2].z = -fabsf(ret4[2].z);
		outSrcRegisters[3].z = -fabsf(ret4[3].z);

		outSrcRegisters[0].w = -fabsf(ret4[0].w);
		outSrcRegisters[1].w = -fabsf(ret4[1].w);
		outSrcRegisters[2].w = -fabsf(ret4[2].w);
		outSrcRegisters[3].w = -fabsf(ret4[3].w);
	}
		return;
	case D3DSPSM_NOT    :
	{
		BOOL* const boolPtr4[4] = 
		{
			(BOOL* const)&ret4[0].x,
			(BOOL* const)&ret4[1].x,
			(BOOL* const)&ret4[2].x,
			(BOOL* const)&ret4[3].x
		};

		*boolPtr4[0] = !*boolPtr4[0];
		*boolPtr4[1] = !*boolPtr4[1];
		*boolPtr4[2] = !*boolPtr4[2];
		*boolPtr4[3] = !*boolPtr4[3];

		outSrcRegisters[0] = ret4[0];
		outSrcRegisters[1] = ret4[1];
		outSrcRegisters[2] = ret4[2];
		outSrcRegisters[3] = ret4[3];
	}
		return;
	}
}

const bool VShaderEngine::InterpreterExecStep4()
{
#ifdef _DEBUG
	if (!instructionPtr)
	{
		__debugbreak();
	}
#endif

	const instructionToken rawInstructionToken = *(const instructionToken* const)instructionPtr++;
	const D3DSHADER_INSTRUCTION_OPCODE_TYPE currentInstructionOpcode = (const D3DSHADER_INSTRUCTION_OPCODE_TYPE)(rawInstructionToken.opcode);
	switch (currentInstructionOpcode)
	{
	case D3DSIO_NOP         :
		nop();
		break;
	case D3DSIO_MOV         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		WriteDstParameter4(dstParam, src0);
	}
		break;
	case D3DSIO_ADD         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dst[4];
		add4(dst, src0, src1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_SUB         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dst[4];
		sub4(dst, src0, src1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_MAD         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		D3DXVECTOR4 src2[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		ResolveSrcRegister4(instructionPtr, src2);
		D3DXVECTOR4 dst[4];
		mad4(dst, src0, src1, src2);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_MUL         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dst[4];
		mul4(dst, src0, src1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_RCP         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD srcBytecode = *instructionPtr;
		D3DXVECTOR4 src[4];
		ResolveSrcRegister4(instructionPtr, src);
		float f4[4];
		ResolveSrcReplicateSwizzle4(srcBytecode, src, f4);
		D3DXVECTOR4 dst[4];
		rcp4(dst, f4);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_RSQ         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD srcBytecode = *instructionPtr;
		D3DXVECTOR4 src[4];
		ResolveSrcRegister4(instructionPtr, src);
		float f4[4];
		ResolveSrcReplicateSwizzle4(srcBytecode, src, f4);
		D3DXVECTOR4 dst[4];
		rsq4(dst, f4);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_DP3         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dst[4];
		dp3_4(dst, src0, src1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_DP4         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dst[4];
		dp4_4(dst, src0, src1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_MIN         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dst[4];
		min4(dst, src0, src1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_MAX         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dst[4];
		max4(dst, src0, src1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_SLT         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dst[4];
		slt4(dst, src0, src1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_SGE         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dst[4];
		sge4(dst, src0, src1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_EXPP        :
	case D3DSIO_EXP         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD srcBytecode = *instructionPtr;
		D3DXVECTOR4 src[4];
		ResolveSrcRegister4(instructionPtr, src);
		float f4[4];
		ResolveSrcReplicateSwizzle4(srcBytecode, src, f4);
		D3DXVECTOR4 dst[4];
		exp4(dst, f4);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_LOGP        :
	case D3DSIO_LOG         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD srcBytecode = *instructionPtr;
		D3DXVECTOR4 src[4];
		ResolveSrcRegister4(instructionPtr, src);
		float f4[4];
		ResolveSrcReplicateSwizzle4(srcBytecode, src, f4);
		D3DXVECTOR4 dst[4];
		log4(dst, f4);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_LIT         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 dst[4];
		lit4(dst, src0);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_DST         : // TODO: Validate correctness of this (the docs seem incomplete and misleading)
	{
		const dstParameterToken destParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dest[4];
		dst4(dest, src0, src1);
		WriteDstParameter4(destParam, dest);
	}
		break;
	case D3DSIO_LRP         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		D3DXVECTOR4 src2[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		ResolveSrcRegister4(instructionPtr, src2);
		D3DXVECTOR4 dst[4];
		lrp4(dst, src0, src1, src2);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_FRC         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src[4];
		ResolveSrcRegister4(instructionPtr, src);
		D3DXVECTOR4 dst[4];
		frc4(dst, src);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_M4x4        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 src2[4]; // *(&src1 + 1);
		D3DXVECTOR4 src3[4]; // *(&src1 + 2);
		D3DXVECTOR4 src4[4]; // *(&src1 + 3);
		D3DXVECTOR4 dst[4];
		m4x4_4(dst, src0, src1, src2, src3, src4);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_M4x3        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 src2[4]; // *(&src1 + 1);
		D3DXVECTOR4 src3[4]; // *(&src1 + 2);
		D3DXVECTOR4 dst[4];
		m4x3_4(dst, src0, src1, src2, src3);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_M3x4        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 src2[4]; // *(&src1 + 1);
		D3DXVECTOR4 src3[4]; // *(&src1 + 2);
		D3DXVECTOR4 src4[4]; // *(&src1 + 3);
		D3DXVECTOR4 dst[4];
		m3x4_4(dst, src0, src1, src2, src3, src4);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_M3x3        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 src2[4]; // *(&src1 + 1);
		D3DXVECTOR4 src3[4]; // *(&src1 + 2);
		D3DXVECTOR4 dst[4];
		m3x3_4(dst, src0, src1, src2, src3);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_M3x2        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 src2[4]; // *(&src1 + 1);
		D3DXVECTOR4 dst[4];
		m3x2_4(dst, src0, src1, src2);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_CALL        :
	{
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		DbgBreakPrint("Error: CALL Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_CALLNZ      :
	{
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		DbgBreakPrint("Error: CALLNZ Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_LOOP        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		DbgBreakPrint("Error: LOOP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_RET         :
		DbgBreakPrint("Error: RET Shader function not yet implemented!"); // Not yet implemented!
		return false;
	case D3DSIO_ENDLOOP     :
		DbgBreakPrint("Error: ENDLOOP Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_LABEL       :
	{
		// src0 contains the label index for this label
		const D3DXVECTOR4 src0 = ResolveSrcRegister(instructionPtr);
		
		// Do nothing
	}
		break;
	case D3DSIO_DCL         :
		DbgBreakPrint("Error: DCL Should not be encountered during normal shader execution!");
		break;
	case D3DSIO_POW         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD src0Bytecode = *instructionPtr;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		float f0[4];
		ResolveSrcReplicateSwizzle4(src0Bytecode, src0, f0);
		const DWORD src1Bytecode = *instructionPtr;
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		float f1[4];
		ResolveSrcReplicateSwizzle4(src1Bytecode, src1, f1);
		D3DXVECTOR4 dst[4];
		pow4(dst, f0, f1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_CRS         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 dst[4];
		crs4(dst, src0, src1);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_SGN         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src_unused[4];
		ResolveSrcRegister4(instructionPtr, src_unused); // Skip unused src1
		ResolveSrcRegister4(instructionPtr, src_unused); // Skip unused src2
		D3DXVECTOR4 dst[4];
		sgn4(dst, src0, src_unused, src_unused);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_ABS         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 dst[4];
		abs4(dst, src0);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_NRM         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 dst[4];
		nrm4(dst, src0);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_SINCOS      :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		const DWORD src0Bytecode = *instructionPtr;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		const srcParameterToken& srcParameter = *(const srcParameterToken* const)instructionPtr;
		const unsigned swizzleX = srcParameter.GetChannelSwizzleXYZW() & 0x3;
		const unsigned swizzleY = (srcParameter.GetChannelSwizzleXYZW() >> 2) & 0x3;
		float f[4];
		ResolveSrcReplicateSwizzle4(src0Bytecode, src0, f);
		if (shaderInfo->shaderMajorVersion < 3) // Shader model 2 has these extra registers, but all the shader model 3+ don't have them
		{
			D3DXVECTOR4 src_unused[4];
			ResolveSrcRegister4(instructionPtr, src_unused); // src1 is unused, so just skip it
			ResolveSrcRegister4(instructionPtr, src_unused); // src2 is unused, so just skip it
		}
		D3DXVECTOR4 dst[4];
		if (swizzleX && swizzleY)
			sincos_sc4(dst, f);
		else if (swizzleX)
			sincos_c4(dst, f);
		else if (swizzleY)
			sincos_s4(dst, f);
#ifdef _DEBUG
		else
		{
			// Whyyyyyyyyyyyyyyyy?
			__debugbreak();
		}
#endif
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_REP         :
	{
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		DbgBreakPrint("Error: REP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_ENDREP      :
		DbgBreakPrint("Error: ENDREP Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_IF          :
	{
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		DbgBreakPrint("Error: IF Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_IFC         :
	{
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		DbgBreakPrint("Error: IFC Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_ELSE        :
		DbgBreakPrint("Error: ELSE Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_ENDIF       :
		DbgBreakPrint("Error: ENDIF Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_BREAK       :
		DbgBreakPrint("Error: BREAK Shader function not yet implemented!"); // Not yet implemented!
		break;
	case D3DSIO_BREAKC      :
	{
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		DbgBreakPrint("Error: BREAKC Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_MOVA        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
#ifdef _DEBUG
		if (dstParam.GetRegisterType() != D3DSPR_ADDR)
		{
			__debugbreak(); // This instruction is only allowed to move into the address register (a0 register)
		}
#endif
		WriteDstParameter4(dstParam, src0);
	}
		break;
	case D3DSIO_DEFB        :
		DbgBreakPrint("Error: DEFB Should not be encountered during normal shader execution!");
		break;
	case D3DSIO_DEFI        :
		DbgBreakPrint("Error: DEFI Should not be encountered during normal shader execution!");
		break;		
	case D3DSIO_TEXCOORD    :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		DbgBreakPrint("Error: TEXCOORD Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_TEXKILL     :
		DbgBreakPrint("Error: Should never hit TEXKILL inside a vertex shader!");
		__debugbreak();
		break;
	case D3DSIO_TEXBEM      :
		DbgBreakPrint("Error: TEXBEM Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXBEML     :
		DbgBreakPrint("Error: TEXBEML Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXREG2AR   :
		DbgBreakPrint("Error: TEXREG2AR Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXREG2GB   :
		DbgBreakPrint("Error: TEXREG2GB Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x2PAD  :
		DbgBreakPrint("Error: TEXM3x2PAD Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x2TEX  :
		DbgBreakPrint("Error: TEXM3x2TEX Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x3PAD  :
		DbgBreakPrint("Error: TEXM3x3PAD Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x3TEX  :
		DbgBreakPrint("Error: TEXM3x3TEX Shader function not available in vertex shaders!");
		break;
	case D3DSIO_RESERVED0   :
		DbgBreakPrint("Error: RESERVED0 Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x3SPEC :
		DbgBreakPrint("Error: TEXM3x3SPEC Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x3VSPEC:
		DbgBreakPrint("Error: TEXM3x3VSPEC Shader function not available in vertex shaders!");
		break;
	case D3DSIO_CND         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		D3DXVECTOR4 src1[4];
		D3DXVECTOR4 src2[4];
		ResolveSrcRegister4(instructionPtr, src0);
		ResolveSrcRegister4(instructionPtr, src1);
		ResolveSrcRegister4(instructionPtr, src2);
		D3DXVECTOR4 dst[4];
		cnd4(dst, src0, src1, src2);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_DEF         :
		DbgBreakPrint("Error: DEF Should not be encountered during normal shader execution!");
		break;
	case D3DSIO_TEXREG2RGB  :
		DbgBreakPrint("Error: TEXREG2RGB Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXDP3TEX   :
		DbgBreakPrint("Error: TEXDP3TEX Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x2DEPTH:
		DbgBreakPrint("Error: TEXM3x2DEPTH Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXDP3      :
		DbgBreakPrint("Error: TEXDP3 Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXM3x3     :
		DbgBreakPrint("Error: TEXM3x3 Shader function not available in vertex shaders!");
		break;
	case D3DSIO_TEXDEPTH    :
		DbgBreakPrint("Error: TEXDEPTH Shader function not available in vertex shaders!");
		break;
	case D3DSIO_CMP         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 src2[4];
		ResolveSrcRegister4(instructionPtr, src2);
		D3DXVECTOR4 dst[4];
		cmp4(dst, src0, src1, src2);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_BEM         :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		DbgBreakPrint("Error: BEM Shader function not yet implemented!"); // Not yet implemented!
	}
		break;
	case D3DSIO_DP2ADD      :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		D3DXVECTOR4 src2[4];
		ResolveSrcRegister4(instructionPtr, src2);
		D3DXVECTOR4 dst[4];
		dp2add4(dst, src0, src1, src2);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_DSX         : // Technically these derivative/gradient instructions aren't supposed to be runnable by vertex shaders, but it won't break anything if we do
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 dst[4];
		dsx(dst, src0);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_DSY         : // Technically these derivative/gradient instructions aren't supposed to be runnable by vertex shaders, but it won't break anything if we do
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 dst[4];
		dsy(dst, src0);
		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_TEXLDD      : // tex2Dgrad()
		DbgBreakPrint("Error: TEXLDD Shader function not available in vertex shader!");
		break;
	case D3DSIO_SETP        :
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		D3DXVECTOR4 src1[4];
		ResolveSrcRegister4(instructionPtr, src1);
		DbgBreakPrint("Error: SETP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;

		// Technically tex2D() is not allowed in vertex shaders, however I don't see anything wrong with promoting it to tex2Dlod and just letting the shader run
	case D3DSIO_TEX         : // Standard texture sampling with tex2D() for shader model 2 and up
	case D3DSIO_TEXLDL      : // tex2Dlod()
	{
		const dstParameterToken dstParam = *(const dstParameterToken* const)instructionPtr++;
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);

		// Since sampler registers can't be Relative Address'd, and since they come from the
		// constants table, we can do this once rather than four times for the same sampler:
		const srcParameterToken& src1Param = *(const srcParameterToken* const)instructionPtr++;
		const D3DXVECTOR4& src1 = ResolveSrcParameter(src1Param);
		const sampler* const samplerPtr = (const sampler* const)&src1;

		D3DXVECTOR4 dst[4];

		tex2Dlod4<0xF>(dst, src0, samplerPtr);

		// TODO: src1 can have a swizzle that gets applied after the texture sample but before the write mask happens

		WriteDstParameter4(dstParam, dst);
	}
		break;
	case D3DSIO_BREAKP      :
	{
		D3DXVECTOR4 src0[4];
		ResolveSrcRegister4(instructionPtr, src0);
		DbgBreakPrint("Error: BREAKP Shader function not yet implemented!"); // Not yet implemented!
	}
		break;		
	case D3DSIO_PHASE       :
		DbgBreakPrint("Error: Should never hit PHASE instruction in vertex shader!"); // Not yet implemented!
		break;
	case D3DSIO_COMMENT     :
	{
		const unsigned commentLengthDWORDs = (instructionPtr[-1] & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
		instructionPtr += commentLengthDWORDs; // Skip the comment block
	}
		break;
	case D3DSIO_END         :
		// We're done! We reached the end of the shader!
		return false;
	default:
#ifdef _DEBUG
	{
		__debugbreak();
	}
#else
		__assume(0);
#endif
	}

	return true;
}

#endif // #ifdef RUN_SHADERS_IN_WARPS

```

`Software_d3d9/d3d9.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// HLSL
//

FFPS_ApplyColorStage.fxh HLSL                    "FixedFuncEmu\\FFPS\\Include\\FFPS_ApplyColorStage.fxh"

FFPS_ArgumentSelector.fxh HLSL                    "FixedFuncEmu\\FFPS\\Include\\FFPS_ArgumentSelector.fxh"

FFPS_TexLoad.fxh HLSL                    "FixedFuncEmu\\FFPS\\Include\\FFPS_TexLoad.fxh"

IDR_HLSL_FFPS_SRC               HLSL                    "FixedFuncEmu\\FFPS\\Source\\FixedFunctionPixelShader.hlsl"

FFVS_CalculateSingleLight.fxh	HLSL					"FixedFuncEmu\\FFVS\\Include\\FFVS_CalculateSingleLight.fxh"

IDR_HLSL_FFVS_SRC				HLSL					"FixedFuncEmu\\FFVS\\Source\\FixedFunctionVertexShader.hlsl"


/////////////////////////////////////////////////////////////////////////////
//
// CPP
//

IDR_CPP1                CPP                     "ShaderJIT_PrefixFile.cpp"

/////////////////////////////////////////////////////////////////////////////
//
// TGA
//

IDR_TGA1                TGA                     "Overlay\\FontMap.tga"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Software_d3d9/d3d9include.h`:

```h
#pragma once

#ifdef _DEBUG
	#define D3D_DEBUG_INFO 1
#else
	#undef D3D_DEBUG_INFO
#endif

// warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc
#pragma warning(disable:4530)

#undef UNICODE
#undef _UNICODE
#define WIN32_LEAN_AND_MEAN
#include <d3d9.h>

// Note: For this project (implemented as a d3d9.dll hook), we do *not* want to link against d3d9.lib because it would force
// our output-generated d3d9.dll to be itself dependent on the real d3d9.dll.
// #pragma comment(lib, "d3d9.lib")

#include <d3dx9.h>
#ifdef _DEBUG
	#pragma comment(lib, "d3dx9d.lib")
#else
	#pragma comment(lib, "d3dx9.lib")
#endif

#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)

#define DbgPrint(x) OutputDebugStringA(x " (" __FILE__ ":"  TOSTRING(__LINE__) ")\n")

#ifdef _DEBUG
	#define DbgBreakPrint(x) MessageBoxA(NULL, __FILE__ ":" TOSTRING(__LINE__) "\n" x, "Error", NULL); DbgPrint(x)
#else
	#define DbgBreakPrint(x) DbgPrint(x)
#endif

```

`Software_d3d9/hookd3d9.cpp`:

```cpp
#pragma once

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#pragma pack(1)

#include "d3d9include.h"

#include "IDirect3D9Hook.h"

#ifdef INCREASE_SYSTEM_SCHEDULER_RESOLUTION
	#pragma comment(lib, "Winmm.lib")
#endif // #ifdef INCREASE_SYSTEM_SCHEDULER_RESOLUTION

HINSTANCE hLThisDLL = 0;
HINSTANCE hL = 0;

// Undocumented enum!
enum Force9On12Mode : UINT
{
	Force9On12Mode_D3D9_Default = 0, // This will create a true D3D9 device (no 9On12 layer)
	Force9On12Mode_D3D9On12 = 1, // This will create a D3D9On12 device
	Force9On12Mode_D3D9_Unknown = 2 // I am not sure what this does, but it seems to act almost exactly like Force9On12Mode_D3D9_Default (value "0")
};

#define MAX_D3D9ON12_QUEUES        2

typedef struct _D3D9ON12_ARGS
{
    BOOL Enable9On12;
    IUnknown* pD3D12Device;
    IUnknown* ppD3D12Queues[MAX_D3D9ON12_QUEUES];
    UINT NumQueues;
    UINT NodeMask;
} D3D9ON12_ARGS;

// Undocumented enum
typedef enum _D3DSVERROR_ID
{
} D3DSVERROR_ID;

typedef HRESULT (CALLBACK *IDirect3DShaderValidator9_InstructionCallback)(LPCSTR, UINT messageType, D3DSVERROR_ID messageID, UINT, LPCSTR lpMessage, LPVOID lParam);

// This is an undocumented interface returned from the exported function Direct3DShaderValidatorCreate9()
struct DECLSPEC_NOVTABLE IDirect3DShaderValidator9 : public IUnknown
{
	/*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

	/*** IDirect3DShaderValidator9 methods ***/
	STDMETHOD(Begin)(THIS_ IDirect3DShaderValidator9_InstructionCallback lpCallbackFunc, LPVOID lParam, DWORD unknown) PURE;
	STDMETHOD(Instruction)(THIS_ CONST char* unknownString, UINT unknown, const DWORD* pdwInst /*Pointer to the instruction token*/, DWORD dwCount /*The instruction length, in DWORD tokens*/) PURE;
	STDMETHOD(End)(THIS) PURE;
};

typedef int (WINAPI *D3DPERF_BeginEventType)(D3DCOLOR col, LPCWSTR wszName);
typedef int (WINAPI *D3DPERF_EndEventType)(void);
typedef DWORD (WINAPI *D3DPERF_GetStatusType)(void);
typedef BOOL (WINAPI *D3DPERF_QueryRepeatFrameType)(void);
typedef void (WINAPI *D3DPERF_SetMarkerType)(D3DCOLOR col, LPCWSTR wszName);
typedef void (WINAPI *D3DPERF_SetOptionsType)(DWORD dwOptions);
typedef void (WINAPI *D3DPERF_SetRegionType)(D3DCOLOR col, LPCWSTR wszName);
typedef void (WINAPI *DebugSetLevelType)(void);
typedef void (WINAPI *DebugSetMuteType)(void);
typedef HRESULT (WINAPI *Direct3D9EnableMaximizedWindowedModeShimType)(BOOL ShimEnable);
typedef IDirect3D9* (WINAPI *Direct3DCreate9Type)(_In_ UINT SDKVersion);
typedef HRESULT (WINAPI *Direct3DCreate9ExType)(_In_ UINT SDKVersion, _Out_ IDirect3D9Ex**);
typedef IDirect3DShaderValidator9* (WINAPI *Direct3DShaderValidatorCreate9Type)(void);
typedef void (WINAPI *PSGPErrorType)(class D3DFE_PROCESSVERTICES* verticesPtr, enum PSGPERRORID errID, UINT UnknownUInt);
typedef void (WINAPI *PSGPSampleTextureType)(class D3DFE_PROCESSVERTICES* verticesPtr, UINT UnknownUInt1, float (*const UnknownFloats1)[4], unsigned int UnknownUInt2, float (*const UnknownFloats2)[4]);
typedef void (WINAPI *Direct3D9ForceHybridEnumerationType)(_In_ BOOL ForceHybridEnumeration);
typedef void (WINAPI *Direct3D9SetMaximizedWindowedModeShimType)(_In_ BOOL unknown0, _In_ BOOL unknown1);
typedef INT (WINAPI *Direct3D9SetSwapEffectUpgradeShimType)(_In_ BOOL ShimEnable);
typedef void (WINAPI *Direct3D9Force9On12Type)(_In_ Force9On12Mode Mode);
typedef IDirect3D9* (WINAPI *Direct3DCreate9On12Type)(_In_ UINT SDKVersion, _In_ D3D9ON12_ARGS* pOverrideList, _In_ UINT NumOverrideEntries);
typedef HRESULT (WINAPI *Direct3DCreate9On12ExType)(_In_ UINT SDKVersion, _In_ D3D9ON12_ARGS* pOverrideList, UINT NumOverrideEntries, _Inout_ IDirect3D9Ex** ppOutputInterface);
typedef void (WINAPI *Direct3D9SetMaximizedWindowHwndOverrideType)(_In_ BOOL Override);
typedef void (WINAPI *Direct3D9SetVendorIDLieFor9On12Type)(_In_ BOOL VendorIDLie);

// All of these function pointer values will be pulled from the real d3d9.dll using GetProcAddress().
// Not all of these functions may exist if we are running versions of Windows older than Windows 10, so in
// those cases we'll just ignore the function calls entirely if possible.
static D3DPERF_BeginEventType Real_D3DPERF_BeginEvent = NULL;
static D3DPERF_EndEventType Real_D3DPERF_EndEvent = NULL;
static D3DPERF_GetStatusType Real_D3DPERF_GetStatus = NULL;
static D3DPERF_QueryRepeatFrameType Real_D3DPERF_QueryRepeatFrame = NULL;
static D3DPERF_SetMarkerType Real_D3DPERF_SetMarker = NULL;
static D3DPERF_SetOptionsType Real_D3DPERF_SetOptions = NULL;
static D3DPERF_SetRegionType Real_D3DPERF_SetRegion = NULL;
static DebugSetLevelType Real_DebugSetLevel = NULL;
static DebugSetMuteType Real_DebugSetMute = NULL;
static Direct3D9EnableMaximizedWindowedModeShimType Real_Direct3D9EnableMaximizedWindowedModeShim = NULL;
static Direct3DCreate9Type Real_Direct3DCreate9 = NULL;
static Direct3DCreate9ExType Real_Direct3DCreate9Ex = NULL;
static Direct3DShaderValidatorCreate9Type Real_Direct3DShaderValidatorCreate9 = NULL;
static PSGPErrorType Real_PSGPError = NULL;
static PSGPSampleTextureType Real_PSGPSampleTexture = NULL;
static Direct3D9ForceHybridEnumerationType Real_Direct3D9ForceHybridEnumeration = NULL;
static Direct3D9SetMaximizedWindowedModeShimType Real_Direct3D9SetMaximizedWindowedModeShim = NULL;
static Direct3D9SetSwapEffectUpgradeShimType Real_Direct3D9SetSwapEffectUpgradeShim = NULL;
static Direct3D9Force9On12Type Real_Direct3D9Force9On12 = NULL;
static Direct3DCreate9On12Type Real_Direct3DCreate9On12 = NULL;
static Direct3DCreate9On12ExType Real_Direct3DCreate9On12Ex = NULL;
static Direct3D9SetMaximizedWindowHwndOverrideType Real_Direct3D9SetMaximizedWindowHwndOverride = NULL;
static Direct3D9SetVendorIDLieFor9On12Type Real_Direct3D9SetVendorIDLieFor9On12 = NULL;

#ifdef _DEBUG

static unsigned char* NtSetInformationThreadFuncBytes = NULL;
static unsigned char* NtSetInformationThreadPostHook = NULL;

// Thanks to NT Internals for this one: http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtSetInformationThread.html
typedef enum _REAL_THREAD_INFORMATION_CLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger
} REAL_THREAD_INFORMATION_CLASS, *PREAL_THREAD_INFORMATION_CLASS;
typedef _Return_type_success_(return >= 0) LONG NTSTATUS;

#ifdef _M_IX86
extern "C" __declspec(naked) void __stdcall NtSetInformationThreadHook(IN HANDLE ThreadHandle, IN REAL_THREAD_INFORMATION_CLASS ThreadInformationClass, IN PVOID ThreadInformation, IN ULONG ThreadInformationLength)
{
	// Uhhhhh, have to do this because for some reason C++ thinks that our parameters are each slid down by 1 (ThreadHandle is really ThreadInformationClass and ThreadInformation is really ThreadInformationLength, etc.)
	if ( (REAL_THREAD_INFORMATION_CLASS)(int)(void*)ThreadHandle == ThreadHideFromDebugger)
	{
		__asm
		{
			xor eax, eax
			ret 10h // return 0 (NTSUCCESS)
		}
	}

	__asm
	{
		mov eax, 0x0D
		jmp [NtSetInformationThreadPostHook]
	}
}

static inline void HookIsDebuggerPresent()
{
	static unsigned char* IsDebuggerPresentFuncBytes = NULL;

	// We already hooked it!
	if (IsDebuggerPresentFuncBytes != NULL)
		return;

	// KernelBase.dll in Windows 8 and up, kernel32.dll in lower versions of Windows
	HMODULE kerneldll = LoadLibraryA("KernelBase.dll");
	if (!kerneldll)
	{
		DbgBreakPrint("Error: Cannot load KernelBase.dll!");
	}

	IsDebuggerPresentFuncBytes = (unsigned char* const)GetProcAddress(kerneldll, "IsDebuggerPresent");
	if (!IsDebuggerPresentFuncBytes)
	{
		DbgBreakPrint("Error: Cannot find KernelBase.dll!IsDebuggerPresent()");
	}

	DWORD oldprotect = 0x00000000;
	if (!VirtualProtect(IsDebuggerPresentFuncBytes, 3, PAGE_EXECUTE_READWRITE, &oldprotect) )
	{
		DbgBreakPrint("Error: Fail in VirtualProtect");
	}

	IsDebuggerPresentFuncBytes[0] = 0x33; // xor eax, eax
	IsDebuggerPresentFuncBytes[1] = 0xC0;

	IsDebuggerPresentFuncBytes[2] = 0xC3; // ret

	if (!VirtualProtect(IsDebuggerPresentFuncBytes, 3, oldprotect, &oldprotect) )
	{
		DbgBreakPrint("Error: Fail in VirtualProtect");
	}
}

static inline void HookNtSetInformationThread()
{
	// We already hooked it!
	if (NtSetInformationThreadFuncBytes != NULL)
		return;

	HMODULE ntdll = LoadLibraryA("ntdll.dll");
	if (!ntdll)
	{
		DbgBreakPrint("Error: Cannot load ntdll.dll");
	}

	NtSetInformationThreadFuncBytes = (unsigned char* const)GetProcAddress(ntdll, "NtSetInformationThread");
	if (!NtSetInformationThreadFuncBytes)
	{
		DbgBreakPrint("Error: Cannot find ntdll.dll!NtSetInformationThread()");
	}

	DWORD oldprotect = 0x00000000;
	if (!VirtualProtect(NtSetInformationThreadFuncBytes, 5, PAGE_EXECUTE_READWRITE, &oldprotect) )
	{
		DbgBreakPrint("Error: Fail in VirtualProtect");
	}

	if (NtSetInformationThreadFuncBytes[0] != 0xB8) // MOV EAX instruction
	{
		DbgBreakPrint("Error: Unknown instruction encountered");
	}
	else if ( *(const unsigned long* const)(NtSetInformationThreadFuncBytes + 1) != 0x0D) // We expect this to be "MOV EAX, 0x0D"
	{
		DbgBreakPrint("Error: Unknown instruction encountered");
	}

	// Assemble the relative JMP:
	NtSetInformationThreadFuncBytes[0] = 0xE9;
	*(unsigned* const)(NtSetInformationThreadFuncBytes + 1) = (unsigned)&NtSetInformationThreadHook - (unsigned)(unsigned* const)(NtSetInformationThreadFuncBytes + 5);

	NtSetInformationThreadPostHook = NtSetInformationThreadFuncBytes + 5;

	if (!VirtualProtect(NtSetInformationThreadFuncBytes, 5, oldprotect, &oldprotect) )
	{
		DbgBreakPrint("Error: Fail in VirtualProtect");
	}
}
#endif // #ifdef _M_IX86

void CircumventSteamAntiDebugging(void)
{
	// Having a message box here was convenient for debugging steam stuff, but it really messes up some applications to have a message box pop up during a DllMain!
	//MessageBoxA(NULL, NULL, NULL, NULL);

#ifdef _M_IX86
	HookIsDebuggerPresent();

	HookNtSetInformationThread();
#endif // #ifdef _M_IX86

	// No need to separately hook ZwSetInformationThread because ntdll aliases them to the exact same function call
	//HookZwSetInformationThread();

	// TODO: Hook other functions used to hide threads from debugger
}
#endif

// x64 on x64: "C:\Windows\System32"
// x86 on x64: "C:\Windows\SysWoW64"
// x86 on x86: "C:\Windows\System32"
static inline const char* const GetSystemDirectoryHelper()
{
	static char systemDirectoryBuffer[MAX_PATH] = {0};

	if (systemDirectoryBuffer[0] != '\0')
		return systemDirectoryBuffer;

#ifdef _M_IX86 // x86 target
	BOOL isRunningWoW64Process = FALSE;
	if (!IsWow64Process(GetCurrentProcess(), &isRunningWoW64Process) )
	{
#ifdef _DEBUG
		__debugbreak(); // Should never be here!
#endif
		return NULL;
	}

	if (isRunningWoW64Process)
	{
		if (GetSystemWow64DirectoryA(systemDirectoryBuffer, sizeof(systemDirectoryBuffer) / sizeof(systemDirectoryBuffer[0]) ) < 2)
		{
#ifdef _DEBUG
			__debugbreak(); // Should never be here!
#endif
			return NULL;
		}
		return systemDirectoryBuffer;
	}
#elif defined(_M_X64) // x64 target
#else // Other target (ARM target perhaps?)
	#error Error: Only x86 and x64 are currently supported!
#endif // #ifdef _M_IX86

	if (GetSystemDirectoryA(systemDirectoryBuffer, sizeof(systemDirectoryBuffer) / sizeof(systemDirectoryBuffer[0]) ) < 2)
	{
#ifdef _DEBUG
		__debugbreak(); // Should never be here!
#endif
		return NULL;
	}

	return systemDirectoryBuffer;
}

BOOL WINAPI DllMain(_In_ HINSTANCE hInst, _In_ DWORD reason, _In_ LPVOID /*lpvReserved*/)
{
#ifdef INCREASE_SYSTEM_SCHEDULER_RESOLUTION
	static TIMECAPS timeCaps = {0};
#endif // #ifdef INCREASE_SYSTEM_SCHEDULER_RESOLUTION

	if (reason == DLL_PROCESS_ATTACH)
	{
		hLThisDLL = hInst;

#ifdef _DEBUG
		CircumventSteamAntiDebugging();
#endif

#ifdef INCREASE_SYSTEM_SCHEDULER_RESOLUTION
		if (timeGetDevCaps(&timeCaps, sizeof(timeCaps) ) != MMSYSERR_NOERROR)
		{
			return FALSE;
		}

		timeBeginPeriod(timeCaps.wPeriodMin);
#endif // #ifdef INCREASE_SYSTEM_SCHEDULER_RESOLUTION

		char loadLibraryBuffer[MAX_PATH + 16] = {0};
#pragma warning(push)
#pragma warning(disable:4996) // warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
		strcpy(loadLibraryBuffer, GetSystemDirectoryHelper() );
		strcat(loadLibraryBuffer, "\\d3d9.dll");
#pragma warning(pop)

		hL = LoadLibraryA(loadLibraryBuffer);

		if (!hL)
			return FALSE;

		Real_D3DPERF_BeginEvent = (const D3DPERF_BeginEventType)GetProcAddress(hL, "D3DPERF_BeginEvent");
		Real_D3DPERF_EndEvent = (const D3DPERF_EndEventType)GetProcAddress(hL, "D3DPERF_EndEvent");
		Real_D3DPERF_GetStatus = (const D3DPERF_GetStatusType)GetProcAddress(hL, "D3DPERF_GetStatus");
		Real_D3DPERF_QueryRepeatFrame = (const D3DPERF_QueryRepeatFrameType)GetProcAddress(hL, "D3DPERF_QueryRepeatFrame");
		Real_D3DPERF_SetMarker = (const D3DPERF_SetMarkerType)GetProcAddress(hL, "D3DPERF_SetMarker");
		Real_D3DPERF_SetOptions = (const D3DPERF_SetOptionsType)GetProcAddress(hL, "D3DPERF_SetOptions");
		Real_D3DPERF_SetRegion = (const D3DPERF_SetRegionType)GetProcAddress(hL, "D3DPERF_SetRegion");
		Real_DebugSetLevel = (const DebugSetLevelType)GetProcAddress(hL, "DebugSetLevel");
		Real_DebugSetMute = (const DebugSetMuteType)GetProcAddress(hL, "DebugSetMute");
		Real_Direct3D9EnableMaximizedWindowedModeShim = (const Direct3D9EnableMaximizedWindowedModeShimType)GetProcAddress(hL, "Direct3D9EnableMaximizedWindowedModeShim");
		Real_Direct3DCreate9 = (const Direct3DCreate9Type)GetProcAddress(hL, "Direct3DCreate9");
		Real_Direct3DCreate9Ex = (const Direct3DCreate9ExType)GetProcAddress(hL, "Direct3DCreate9Ex");
		Real_Direct3DShaderValidatorCreate9 = (const Direct3DShaderValidatorCreate9Type)GetProcAddress(hL, "Direct3DShaderValidatorCreate9");
		Real_PSGPError = (const PSGPErrorType)GetProcAddress(hL, "PSGPError");
		Real_PSGPSampleTexture = (const PSGPSampleTextureType)GetProcAddress(hL, "PSGPSampleTexture");
		Real_Direct3D9ForceHybridEnumeration = (const Direct3D9ForceHybridEnumerationType)GetProcAddress(hL, (LPCSTR)LOWORD(16u) ); // "void Direct3D9ForceHybridEnumeration(BOOL)"
		Real_Direct3D9SetMaximizedWindowedModeShim = (const Direct3D9SetMaximizedWindowedModeShimType)GetProcAddress(hL, (LPCSTR)LOWORD(17u) ); // "void Direct3D9SetMaximizedWindowedModeShim()"
		Real_Direct3D9SetSwapEffectUpgradeShim = (const Direct3D9SetSwapEffectUpgradeShimType)GetProcAddress(hL, (LPCSTR)LOWORD(18u) ); // "void Direct3D9SetSwapEffectUpgradeShim()"
		Real_Direct3D9Force9On12 = (const Direct3D9Force9On12Type)GetProcAddress(hL, (LPCSTR)LOWORD(19u) ); // "void Direct3D9Force9On12()"
		Real_Direct3DCreate9On12 = (const Direct3DCreate9On12Type)GetProcAddress(hL, (LPCSTR)LOWORD(20u) ); // "IDirect3D9* Direct3DCreate9On12()"
		Real_Direct3DCreate9On12Ex = (const Direct3DCreate9On12ExType)GetProcAddress(hL, (LPCSTR)LOWORD(21u) ); // "HRESULT Direct3DCreate9On12Ex()"
		Real_Direct3D9SetMaximizedWindowHwndOverride = (const Direct3D9SetMaximizedWindowHwndOverrideType)GetProcAddress(hL, (LPCSTR)LOWORD(22u) ); // "void Direct3D9SetMaximizedWindowHwndOverride()"
		Real_Direct3D9SetVendorIDLieFor9On12 = (const Direct3D9SetVendorIDLieFor9On12Type)GetProcAddress(hL, (LPCSTR)LOWORD(23u) ); // "void Direct3D9SetVendorIDLieFor9On12(BOOL)"
	}

	if (reason == DLL_PROCESS_DETACH)
	{
#ifdef INCREASE_SYSTEM_SCHEDULER_RESOLUTION
		timeEndPeriod(timeCaps.wPeriodMin);
#endif // #ifdef INCREASE_SYSTEM_SCHEDULER_RESOLUTION

		FreeLibrary(hL);
	}

	return TRUE;
}

// D3DPERF_BeginEvent
extern "C" int WINAPI HookD3DPERF_BeginEvent(D3DCOLOR col, LPCWSTR wszName)
{
	int ret = (*Real_D3DPERF_BeginEvent)(col, wszName);
	return ret;
}

// D3DPERF_EndEvent
extern "C" int WINAPI HookD3DPERF_EndEvent(void)
{
	int ret = (*Real_D3DPERF_EndEvent)();
	return ret;
}

// D3DPERF_GetStatus
extern "C" DWORD WINAPI HookD3DPERF_GetStatus(void)
{
	DWORD ret = (*Real_D3DPERF_GetStatus)();
	return ret;
}

// D3DPERF_QueryRepeatFrame
extern "C" BOOL WINAPI HookD3DPERF_QueryRepeatFrame(void)
{
	BOOL ret = (*Real_D3DPERF_QueryRepeatFrame)();
	return ret;
}

// D3DPERF_SetMarker
extern "C" void WINAPI HookD3DPERF_SetMarker(D3DCOLOR col, LPCWSTR wszName)
{
	(*Real_D3DPERF_SetMarker)(col, wszName);
}

// D3DPERF_SetOptions
extern "C" void WINAPI HookD3DPERF_SetOptions(DWORD dwOptions)
{
	(*Real_D3DPERF_SetOptions)(dwOptions);
}

// D3DPERF_SetRegion
extern "C" void WINAPI HookD3DPERF_SetRegion(D3DCOLOR col, LPCWSTR wszName)
{
	(*Real_D3DPERF_SetRegion)(col, wszName);
}

// DebugSetLevel
extern "C" void WINAPI HookDebugSetLevel()
{
	(*Real_DebugSetLevel)();
}

// DebugSetMute
extern "C" void WINAPI HookDebugSetMute()
{
	(*Real_DebugSetMute)();
}

// Direct3D9EnableMaximizedWindowedModeShim
extern "C"  HRESULT WINAPI HookDirect3D9EnableMaximizedWindowedModeShim(BOOL ShimEnable)
{
	HRESULT ret = (*Real_Direct3D9EnableMaximizedWindowedModeShim)(ShimEnable);
	return ret;
}

// Direct3DCreate9
extern "C" IDirect3D9* WINAPI HookDirect3DCreate9(_In_ UINT SDKVersion)
{	
	// Pre-hook code
	IDirect3D9* ret = (*Real_Direct3DCreate9)(SDKVersion);
	// Post-hook code

	if (!ret)
	{
		return NULL;
	}

	IDirect3D9Hook* newHook = new IDirect3D9Hook(ret);
	return newHook;
}

// Direct3DCreate9Ex
extern "C" HRESULT WINAPI HookDirect3DCreate9Ex(_In_ UINT SDKVersion, _Out_ IDirect3D9Ex** ppD3D)
{
	// Pre-hook code
	HRESULT ret = (*Real_Direct3DCreate9Ex)(SDKVersion, ppD3D);
	// Post-hook code
	//MessageBoxA(NULL, "Direct3DCreate9Ex", NULL, NULL);
	return ret;
}

// Direct3DShaderValidatorCreate9
extern "C" IDirect3DShaderValidator9* WINAPI HookDirect3DShaderValidatorCreate9(void)
{
	IDirect3DShaderValidator9* ret = (*Real_Direct3DShaderValidatorCreate9)();
	return ret;
}

// PSGPError
extern "C" void __stdcall HookPSGPError(class D3DFE_PROCESSVERTICES* verticesPtr, enum PSGPERRORID errID, UINT UnknownUInt)
{
	(*Real_PSGPError)(verticesPtr, errID, UnknownUInt);
}

// PSGPSampleTexture
extern "C" void __stdcall HookPSGPSampleTexture(class D3DFE_PROCESSVERTICES* verticesPtr, UINT UnknownUInt1, float (*const UnknownFloats1)[4], unsigned int UnknownUInt2, float (*const UnknownFloats2)[4])
{
	(*Real_PSGPSampleTexture)(verticesPtr, UnknownUInt1, UnknownFloats1, UnknownUInt2, UnknownFloats2);
}

// Direct3D9ForceHybridEnumeration
extern "C" void __stdcall HookDirect3D9ForceHybridEnumeration(UINT ForceHybridEnumeration)
{
	(*Real_Direct3D9ForceHybridEnumeration)(ForceHybridEnumeration);
}

// Direct3D9SetMaximizedWindowedModeShim
extern "C" void __stdcall HookDirect3D9SetMaximizedWindowedModeShim(BOOL a, BOOL b)
{
	(*Real_Direct3D9SetMaximizedWindowedModeShim)(a, b);
}

// Direct3D9SetSwapEffectUpgradeShim
extern "C" INT __stdcall HookDirect3D9SetSwapEffectUpgradeShim(BOOL ShimEnable)
{
	INT ret = (*Real_Direct3D9SetSwapEffectUpgradeShim)(ShimEnable);
	return ret;
}

// Direct3D9Force9On12
// Sets a global value in d3d9.dll that, when set to "1", causes future calls to Direct3DCreate9 and Direct3DCreate9Ex to be internally
// turned into calls to Direct3DCreate9On12 and Direct3DCreate9On12Ex respectively, thus transparently creating D3D9On12 devices
// for the callers without any user code modifications (except for the one initial call to Direct3D9Force9on12() ).
// Note that this does not transform any existing D3D9 or D3D9Ex devices into D3D9On12/D3D9On12Ex devices, it only affects
// devices created after the force is enabled.
extern "C" void __stdcall HookDirect3D9Force9On12(_In_ Force9On12Mode Mode)
{
	(*Real_Direct3D9Force9On12)(Mode);
}

// Direct3DCreate9On12
extern "C" IDirect3D9* __stdcall HookDirect3DCreate9On12(_In_ UINT SDKVersion, _In_ D3D9ON12_ARGS* pOverrideList, _In_ UINT NumOverrideEntries)
{
	IDirect3D9* ret = (*Real_Direct3DCreate9On12)(SDKVersion, pOverrideList, NumOverrideEntries);
	return ret;
}

// Direct3DCreate9On12Ex
extern "C" HRESULT __stdcall HookDirect3DCreate9On12Ex(_In_ UINT SDKVersion, _In_ D3D9ON12_ARGS* pOverrideList, UINT NumOverrideEntries, _Inout_ IDirect3D9Ex** ppOutputInterface)
{
	HRESULT ret = (*Real_Direct3DCreate9On12Ex)(SDKVersion, pOverrideList, NumOverrideEntries, ppOutputInterface);
	return ret;
}

// Direct3D9SetMaximizedWindowHwndOverride
extern "C" void __stdcall HookDirect3D9SetMaximizedWindowHwndOverride(_In_ BOOL Override)
{
	(*Real_Direct3D9SetMaximizedWindowHwndOverride)(Override);
}

// Direct3D9SetVendorIDLieFor9On12
extern "C" void __stdcall HookDirect3D9SetVendorIDLieFor9On12(_In_ BOOL VendorIDLie)
{
	(*Real_Direct3D9SetVendorIDLieFor9On12)(VendorIDLie);
}

```

`Software_d3d9/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by d3d9.rc
//
#define IDR_CPP1                        103
#define IDR_HLSL_FFPS_SRC               107
#define IDR_HLSL_FFVS_SRC				108
#define IDR_TGA1                        109

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```