Project Path: arc_brackeen_glfm_05hs33oa

Source Tree:

```txt
arc_brackeen_glfm_05hs33oa
├── CMakeLists.txt
├── CONTRIBUTING.md
├── LICENSE
├── README.md
├── examples
│   ├── CMakeLists.txt
│   ├── anim.c
│   ├── assets
│   │   ├── shader_toy.frag
│   │   ├── shader_toy.vert
│   │   ├── simple.frag
│   │   ├── simple.vert
│   │   ├── texture.frag
│   │   └── texture.vert
│   ├── cmake
│   │   └── GLFMAppTarget.cmake
│   ├── compass.c
│   ├── deps
│   │   └── file_compat.h
│   ├── heightmap.c
│   ├── icons
│   │   ├── gen_icns.sh
│   │   ├── glfm_anim.png
│   │   ├── glfm_compass.png
│   │   ├── glfm_heightmap.png
│   │   ├── glfm_shader_toy.png
│   │   ├── glfm_test_pattern.png
│   │   ├── glfm_touch.png
│   │   ├── glfm_triangle.png
│   │   └── glfm_typing.png
│   ├── index.html.in
│   ├── shader_toy.c
│   ├── test_pattern.c
│   ├── test_pattern_renderer.h
│   ├── test_pattern_renderer.metal
│   ├── test_pattern_renderer_gles2.c
│   ├── test_pattern_renderer_metal.m
│   ├── touch.c
│   ├── triangle.c
│   └── typing.c
├── include
│   └── glfm.h
├── src
│   ├── glfm_android.c
│   ├── glfm_apple.m
│   ├── glfm_emscripten.c
│   └── glfm_internal.h
└── tests
    ├── README.md
    ├── build_all.sh
    ├── build_android.sh
    ├── build_android_examples.sh
    ├── build_apple.sh
    ├── build_apple_examples.sh
    ├── build_emscripten.sh
    ├── build_emscripten_examples.sh
    └── clang-tidy-analyze.yml

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18.0)

project(GLFM C)

option(GLFM_BUILD_EXAMPLES "Build the GLFM examples" OFF)
option(GLFM_USE_CLANG_TIDY "Use Clang Tidy when building (Android and Emscripten only)" OFF)

set(GLFM_HEADERS include/glfm.h)

if (CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
    set(GLFM_SRC src/glfm_internal.h src/glfm_emscripten.c)
    set(GLFM_COMPILE_OPTIONS -Wno-gnu-zero-variadic-macro-arguments -Wno-dollar-in-identifier-extension
        -Wno-c23-extensions -Wno-pre-c11-compat)
elseif (CMAKE_SYSTEM_NAME STREQUAL "Android")
    set(GLFM_SRC src/glfm_internal.h src/glfm_android.c)
elseif (CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    if (${CMAKE_OSX_SYSROOT} MATCHES "(MacOS)+")
        set(CMAKE_OSX_SYSROOT "iphoneos")
    endif()

    set(GLFM_SRC src/glfm_internal.h src/glfm_apple.m)
    set(GLFM_COMPILE_OPTIONS -Wno-auto-import -Wno-direct-ivar-access)
else()
    message(FATAL_ERROR "CMAKE_SYSTEM_NAME ('${CMAKE_SYSTEM_NAME}') expected to be Darwin, Emscripten, or Android")
endif()

if (GLFM_USE_CLANG_TIDY)
    # Android target: use clang-tidy from NDK.
    # Emscripten target: use clang-tidy on the host system.
    # On macOS host, try: $(brew --prefix llvm)/bin/clang-tidy
    find_program(CLANG_TIDY_EXECUTABLE clang-tidy)
    if ((NOT CLANG_TIDY_EXECUTABLE) AND (CMAKE_HOST_SYSTEM_NAME STREQUAL "Darwin"))
        execute_process(
            COMMAND brew --prefix llvm
            RESULT_VARIABLE BREW_LLVM
            OUTPUT_VARIABLE BREW_LLVM_PREFIX
            OUTPUT_STRIP_TRAILING_WHITESPACE
        )
        if (BREW_LLVM EQUAL 0 AND EXISTS "${BREW_LLVM_PREFIX}")
            set(CLANG_TIDY_EXECUTABLE "${BREW_LLVM_PREFIX}/bin/clang-tidy")
        endif()
    endif()
    if (NOT CLANG_TIDY_EXECUTABLE)
        message(WARNING "GLFM_USE_CLANG_TIDY=ON but clang-tidy not found")
    else()
        if (CMAKE_SYSTEM_NAME STREQUAL "Android")
            set(CMAKE_C_CLANG_TIDY ${CLANG_TIDY_EXECUTABLE}
                --config-file=${PROJECT_SOURCE_DIR}/tests/clang-tidy-analyze.yml)
        elseif (CMAKE_SYSTEM_NAME STREQUAL "Darwin")
            message(WARNING "GLFM_USE_CLANG_TIDY=ON but clang-tidy not functional with Xcode generator")
        elseif (CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
            set(CMAKE_C_USE_RESPONSE_FILE_FOR_INCLUDES 0)
            set(CMAKE_C_CLANG_TIDY ${CLANG_TIDY_EXECUTABLE}
                --config-file=${PROJECT_SOURCE_DIR}/tests/clang-tidy-analyze.yml
                --extra-arg=--target=wasm32
                --extra-arg=-D__EMSCRIPTEN__
                --extra-arg=-isystem${EMSCRIPTEN_ROOT_PATH}/cache/sysroot/include)
        endif()
    endif()
endif()

add_library(glfm ${GLFM_SRC} ${GLFM_HEADERS})
target_include_directories(glfm PUBLIC include)
target_include_directories(glfm PRIVATE src)

source_group(include FILES ${GLFM_HEADERS})
source_group(src FILES ${GLFM_SRC})

set_target_properties(glfm PROPERTIES C_STANDARD 11)
if (CMAKE_C_COMPILER_ID MATCHES "Clang")
    # Disable the -Wunsafe-buffer-usage warning because it reports false positives when bounds checking arrays, and
    # there appears to be no solution for C pointers.
    set_property(TARGET glfm PROPERTY COMPILE_OPTIONS -Weverything -Wwrite-strings -Wno-unknown-warning-option
        -Wno-padded -Wno-covered-switch-default -Wno-declaration-after-statement -Wno-unsafe-buffer-usage
        -Wno-missing-include-dirs
        ${GLFM_COMPILE_OPTIONS})
elseif (CMAKE_C_COMPILER_ID MATCHES "GNU")
    set_property(TARGET glfm PROPERTY COMPILE_OPTIONS -Wall -Wextra -Wpedantic -Wwrite-strings ${GLFM_COMPILE_OPTIONS})
elseif (CMAKE_C_COMPILER_ID MATCHES "MSVC")
    set_property(TARGET glfm PROPERTY COMPILE_OPTIONS /Wall ${GLFM_COMPILE_OPTIONS})
endif()

if (CMAKE_SYSTEM_NAME STREQUAL "Android")
    find_library(log-lib log)
    find_library(android-lib android)
    find_library(EGL-lib EGL)
    find_library(GLESv2-lib GLESv2)
    target_link_libraries(glfm ${log-lib} ${android-lib} ${EGL-lib} ${GLESv2-lib})
elseif (CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    target_compile_definitions(glfm PRIVATE GLES_SILENCE_DEPRECATION)
    set_target_properties(glfm PROPERTIES
        ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/GLFM.build/lib # For Archiving
        XCODE_ATTRIBUTE_SUPPORTED_PLATFORMS "iphoneos iphonesimulator appletvos appletvsimulator macosx"
        XCODE_ATTRIBUTE_IPHONEOS_DEPLOYMENT_TARGET  11.0  # Minimum supported by Xcode 14
        XCODE_ATTRIBUTE_TVOS_DEPLOYMENT_TARGET      11.0  # Minimum supported by Xcode 14
        XCODE_ATTRIBUTE_MACOSX_DEPLOYMENT_TARGET   10.13  # Minimum supported by Xcode 14
        XCODE_ATTRIBUTE_CLANG_ENABLE_MODULES         YES  # Automatically import frameworks

        # Override default warnings in Xcode because using "-Weverything" does not.
        # CMake 3.25.1, Xcode 14.2.
        XCODE_ATTRIBUTE_CLANG_WARN_ASSIGN_ENUM                            YES
        XCODE_ATTRIBUTE_CLANG_WARN_ATOMIC_IMPLICIT_SEQ_CST                YES
        XCODE_ATTRIBUTE_CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING            YES
        XCODE_ATTRIBUTE_CLANG_WARN_BOOL_CONVERSION                        YES
        XCODE_ATTRIBUTE_CLANG_WARN_COMMA                                  YES
        XCODE_ATTRIBUTE_CLANG_WARN_COMPLETION_HANDLER_MISUSE              YES
        XCODE_ATTRIBUTE_CLANG_WARN_CONSTANT_CONVERSION                    YES
        XCODE_ATTRIBUTE_CLANG_WARN_CXX0X_EXTENSIONS                       YES
        XCODE_ATTRIBUTE_CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS        YES
        XCODE_ATTRIBUTE_CLANG_WARN_DIRECT_OBJC_ISA_USAGE                  YES_ERROR
        XCODE_ATTRIBUTE_CLANG_WARN_DOCUMENTATION_COMMENTS                 YES
        XCODE_ATTRIBUTE_CLANG_WARN_EMPTY_BODY                             YES
        XCODE_ATTRIBUTE_CLANG_WARN_ENUM_CONVERSION                        YES
        XCODE_ATTRIBUTE_CLANG_WARN_FLOAT_CONVERSION                       YES
        XCODE_ATTRIBUTE_CLANG_WARN_FRAMEWORK_INCLUDE_PRIVATE_FROM_PUBLIC  YES
        XCODE_ATTRIBUTE_CLANG_WARN_IMPLICIT_FALLTHROUGH                   YES
        XCODE_ATTRIBUTE_CLANG_WARN_IMPLICIT_SIGN_CONVERSION               YES
        XCODE_ATTRIBUTE_CLANG_WARN_INFINITE_RECURSION                     YES
        XCODE_ATTRIBUTE_CLANG_WARN_INT_CONVERSION                         YES
        XCODE_ATTRIBUTE_CLANG_WARN_NON_LITERAL_NULL_CONVERSION            YES
        XCODE_ATTRIBUTE_CLANG_WARN_OBJC_EXPLICIT_OWNERSHIP_TYPE           YES
        XCODE_ATTRIBUTE_CLANG_WARN_OBJC_IMPLICIT_ATOMIC_PROPERTIES        YES
        XCODE_ATTRIBUTE_CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF              YES
        XCODE_ATTRIBUTE_CLANG_WARN_OBJC_INTERFACE_IVARS                   YES
        XCODE_ATTRIBUTE_CLANG_WARN_OBJC_LITERAL_CONVERSION                YES
        XCODE_ATTRIBUTE_CLANG_WARN_OBJC_MISSING_PROPERTY_SYNTHESIS        YES
        XCODE_ATTRIBUTE_CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK              YES
        XCODE_ATTRIBUTE_CLANG_WARN_OBJC_ROOT_CLASS                        YES_ERROR
        XCODE_ATTRIBUTE_CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER     YES
        XCODE_ATTRIBUTE_CLANG_WARN_RANGE_LOOP_ANALYSIS                    YES
        XCODE_ATTRIBUTE_CLANG_WARN_SEMICOLON_BEFORE_METHOD_BODY           YES
        XCODE_ATTRIBUTE_CLANG_WARN_STRICT_PROTOTYPES                      YES
        XCODE_ATTRIBUTE_CLANG_WARN_SUSPICIOUS_IMPLICIT_CONVERSION         YES
        XCODE_ATTRIBUTE_CLANG_WARN_SUSPICIOUS_MOVE                        YES
        XCODE_ATTRIBUTE_CLANG_WARN_UNGUARDED_AVAILABILITY                 YES_AGGRESSIVE
        XCODE_ATTRIBUTE_CLANG_WARN_UNREACHABLE_CODE                       YES
        XCODE_ATTRIBUTE_CLANG_WARN__ARC_BRIDGE_CAST_NONARC                YES
        XCODE_ATTRIBUTE_CLANG_WARN__DUPLICATE_METHOD_MATCH                YES
        XCODE_ATTRIBUTE_CLANG_WARN__EXIT_TIME_DESTRUCTORS                 YES
        XCODE_ATTRIBUTE_GCC_WARN_64_TO_32_BIT_CONVERSION                  YES_ERROR
        XCODE_ATTRIBUTE_GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS               YES
        XCODE_ATTRIBUTE_GCC_WARN_ABOUT_INVALID_OFFSETOF_MACRO             YES
        XCODE_ATTRIBUTE_GCC_WARN_ABOUT_MISSING_FIELD_INITIALIZERS         YES
        XCODE_ATTRIBUTE_GCC_WARN_ABOUT_MISSING_NEWLINE                    YES
        XCODE_ATTRIBUTE_GCC_WARN_ABOUT_MISSING_PROTOTYPES                 YES
        XCODE_ATTRIBUTE_GCC_WARN_ABOUT_POINTER_SIGNEDNESS                 YES
        XCODE_ATTRIBUTE_GCC_WARN_ABOUT_RETURN_TYPE                        YES_ERROR
        XCODE_ATTRIBUTE_GCC_WARN_ALLOW_INCOMPLETE_PROTOCOL                YES
        XCODE_ATTRIBUTE_GCC_WARN_CHECK_SWITCH_STATEMENTS                  YES
        XCODE_ATTRIBUTE_GCC_WARN_FOUR_CHARACTER_CONSTANTS                 YES
        XCODE_ATTRIBUTE_GCC_WARN_HIDDEN_VIRTUAL_FUNCTIONS                 YES
        XCODE_ATTRIBUTE_GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED          YES
        XCODE_ATTRIBUTE_GCC_WARN_MISSING_PARENTHESES                      YES
        XCODE_ATTRIBUTE_GCC_WARN_NON_VIRTUAL_DESTRUCTOR                   YES
        XCODE_ATTRIBUTE_GCC_WARN_SHADOW                                   YES
        XCODE_ATTRIBUTE_GCC_WARN_SIGN_COMPARE                             YES
        XCODE_ATTRIBUTE_GCC_WARN_STRICT_SELECTOR_MATCH                    YES
        XCODE_ATTRIBUTE_GCC_WARN_TYPECHECK_CALLS_TO_PRINTF                YES
        XCODE_ATTRIBUTE_GCC_WARN_UNDECLARED_SELECTOR                      YES
        XCODE_ATTRIBUTE_GCC_WARN_UNINITIALIZED_AUTOS                      YES_AGGRESSIVE
        XCODE_ATTRIBUTE_GCC_WARN_UNKNOWN_PRAGMAS                          YES
        XCODE_ATTRIBUTE_GCC_WARN_UNUSED_FUNCTION                          YES
        XCODE_ATTRIBUTE_GCC_WARN_UNUSED_LABEL                             YES
        XCODE_ATTRIBUTE_GCC_WARN_UNUSED_PARAMETER                         YES
        XCODE_ATTRIBUTE_GCC_WARN_UNUSED_VALUE                             YES
        XCODE_ATTRIBUTE_GCC_WARN_UNUSED_VARIABLE                          YES
    )
endif()

if (GLFM_BUILD_EXAMPLES)
    add_subdirectory(examples)
endif()

```

`CONTRIBUTING.md`:

```md
# Contributing 

Contributions are welcome. Thank you for making the effort.

If you've got code to contribute, feel free to use the scripts in the `tests` directory to make sure the code doesn't have any warnings and passes analyzer checks. Those same checks are applied when a pull request is created.

## Adding a New Feature

I'd like to keep GLFM small, and some features may not be a good fit. Feel free to create an issue or send me an email to see if your idea would work.

If you are adding a new feature, you do not have to implement it on all three platforms (iOS, Android, Emscripten), but at least two platforms would be nice.

```

`LICENSE`:

```
Copyright (c) 2024 David Brackeen

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would
   be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not
   be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
   distribution.

```

`README.md`:

```md
# GLFM
[![Build](https://github.com/brackeen/glfm/actions/workflows/build.yml/badge.svg)](https://github.com/brackeen/glfm/actions/workflows/build.yml)
[![Build Examples](https://github.com/brackeen/glfm/actions/workflows/build_examples.yml/badge.svg)](https://github.com/brackeen/glfm/actions/workflows/build_examples.yml)

GLFM is a C API for mobile app development with OpenGL ES. It is largely inspired by
[GLFW](https://github.com/glfw/glfw).

GLFM runs on iOS 9, tvOS 9, Android 4.1 (API 16), and WebGL 1.0
(via [Emscripten](https://github.com/emscripten-core/emscripten)).

Additionally, GLFM provides Metal support on iOS and tvOS.

## Features
* OpenGL ES 2, OpenGL ES 3, and Metal display setup.
* Retina / high-DPI support.
* Touch and keyboard events.
* Accelerometer, magnetometer, gyroscope, and device rotation (iOS/Android only)
* Events for application state and context loss.

### Feature Matrix
|                                                         | iOS              | tvOS            | Android | Web |
|---------------------------------------------------------|------------------|-----------------|---------|-----|
| OpenGL ES 2, OpenGL ES 3                                | ✔️               | ✔️              | ✔️     | ✔️   |
| Metal                                                   | ✔️               | ✔️              | N/A    | N/A  |
| Retina / high-DPI                                       | ✔️               | ✔️              | ✔️     | ✔️   |
| Device orientation                                      | ✔️               | N/A             | ✔️     |      |
| Touch events                                            | ✔️               | ✔️              | ✔️     | ✔️   |
| Mouse hover events                                      | ✔️<sup>1</sup>   |                 |        | ✔️   |
| Mouse wheel events                                      |                  |                 |        | ✔️   |
| Mouse cursor style                                      | ✔️<sup>1</sup>   |                 |        | ✔️   |
| Key code events                                         | ✔️<sup>2</sup>   | ✔️              | ✔️     | ✔️   |
| Key repeat events                                       |                  |                 | ✔️     | ✔️   |
| Character input events                                  | ✔️               | ✔️<sup>3</sup>  | ✔️     | ✔️   |
| Virtual keyboard                                        | ✔️               |                 | ✔️     |      |
| Virtual keyboard visibility events                      | ✔️               |                 | ✔️     |      |
| Accelerometer, magnetometer, gyroscope, device rotation | ✔️               | N/A             | ✔️     |      |
| Haptic feedback                                         | ✔️<sup>4</sup>   | N/A             | ✔️     |      |
| Clipboard                                               | ✔️               | N/A             | ✔️     | ✔️   |
| Chrome insets ("safe area")                             | ✔️<sup>5</sup>   | ✔️              | ✔️     |      |
| Chrome insets changed events                            | ✔️<sup>5</sup>   | ✔️              | ✔️     |      |
| Focus events                                            | ✔️               | ✔️              | ✔️     | ✔️   |
| Resize events                                           | ✔️               | ✔️              | ✔️     | ✔️   |
| Memory warning events                                   | ✔️               | ✔️              | ✔️     |      |
| OpenGL context loss events (surface destroyed)          | ✔️               | ✔️              | ✔️     | ✔️   |

<sub>1. iPad only. Requires iOS 13.4 or newer<br/>
2. Requires iOS/tvOS 13.4 or newer<br/>
3. Requires tvOS 13.4 or newer<br/>
4. Requires iOS 13 or newer<br/>
5. Requires iOS/tvOS 11 or newer</sub>

Additionally, there is preliminary support for macOS with OpenGL 3.2. The macOS version is useful for development
purposes, but is not release quality. There is no function to set the window size, for example.

## Non-goals
GLFM is limited in scope, and isn't designed to provide everything needed for an app. For example, GLFM doesn't provide
(and will never provide) the following:

* No image loading.
* No text rendering.
* No audio.
* No menus, UI toolkit, or scene graph.
* No integration with other mobile features like web views, maps, or game scores.

Instead, GLFM can be used with other cross-platform libraries that provide what an app needs.

## Use GLFM
A `CMakeLists.txt` file is provided for convenience, although CMake is not required.

Without CMake:
1. Add the GLFM source files (in `include` and `src`) to your project.
2. Include a `void glfmMain(GLFMDisplay *display)` function in a C/C++ file.

For release builds, define `NDEBUG` to remove superfluous logging statements. `NDEBUG` is automatically defined for
release builds in Android Studio, but not in Xcode.

## Example
This example initializes the display in `glfmMain()` and draws a triangle in `onDraw()`. A more detailed example is
available [here](examples/src/touch.c).

```C
#include "glfm.h"

static GLint program = 0;
static GLuint vertexBuffer = 0;
static GLuint vertexArray = 0;

static void onDraw(GLFMDisplay *display);
static void onSurfaceDestroyed(GLFMDisplay *display);

void glfmMain(GLFMDisplay *display) {
    glfmSetDisplayConfig(display,
                         GLFMRenderingAPIOpenGLES2,
                         GLFMColorFormatRGBA8888,
                         GLFMDepthFormatNone,
                         GLFMStencilFormatNone,
                         GLFMMultisampleNone);
    glfmSetRenderFunc(display, onDraw);
    glfmSetSurfaceDestroyedFunc(display, onSurfaceDestroyed);
}

static void onSurfaceDestroyed(GLFMDisplay *display) {
    // When the surface is destroyed, all existing GL resources are no longer valid.
    program = 0;
    vertexBuffer = 0;
    vertexArray = 0;
}

static GLuint compileShader(const GLenum type, const GLchar *shaderString, GLint shaderLength) {
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &shaderString, &shaderLength);
    glCompileShader(shader);
    return shader;
}

static void onDraw(GLFMDisplay *display) {
    if (program == 0) {
        const GLchar vertexShader[] =
            "#version 100\n"
            "attribute highp vec4 position;\n"
            "void main() {\n"
            "   gl_Position = position;\n"
            "}";

        const GLchar fragmentShader[] =
            "#version 100\n"
            "void main() {\n"
            "  gl_FragColor = vec4(0.85, 0.80, 0.75, 1.0);\n"
            "}";

        program = glCreateProgram();
        GLuint vertShader = compileShader(GL_VERTEX_SHADER, vertexShader, sizeof(vertexShader) - 1);
        GLuint fragShader = compileShader(GL_FRAGMENT_SHADER, fragmentShader, sizeof(fragmentShader) - 1);

        glAttachShader(program, vertShader);
        glAttachShader(program, fragShader);

        glLinkProgram(program);

        glDeleteShader(vertShader);
        glDeleteShader(fragShader);
    }
    if (vertexBuffer == 0) {
        const GLfloat vertices[] = {
             0.0,  0.5, 0.0,
            -0.5, -0.5, 0.0,
             0.5, -0.5, 0.0,
        };
        glGenBuffers(1, &vertexBuffer);
        glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    }

    int width, height;
    glfmGetDisplaySize(display, &width, &height);
    glViewport(0, 0, width, height);
    glClearColor(0.08f, 0.07f, 0.07f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    if (vertexArray == 0) {
        glGenVertexArrays(1, &vertexArray);
    }
    glBindVertexArray(vertexArray);
#endif

    glUseProgram(program);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glDrawArrays(GL_TRIANGLES, 0, 3);

    glfmSwapBuffers(display);
}
```
## API
See [glfm.h](include/glfm.h)

## Build the GLFM examples with Xcode

Use `cmake` to generate an Xcode project:

```Shell
cmake -D GLFM_BUILD_EXAMPLES=ON -B build/apple -G Xcode
open build/apple/GLFM.xcodeproj
```

In Xcode, switch to the `glfm_touch` target and run on a simulator or a device.

## Build the GLFM examples with Emscripten

Use `emcmake` to set environmental variables for `cmake`, then build:

```Shell
emcmake cmake -D GLFM_BUILD_EXAMPLES=ON -B build/emscripten && cmake --build build/emscripten
```

Then run locally:
```Shell
emrun build/emscripten/examples
```

Or run a specific example:
```Shell
emrun build/emscripten/examples/glfm_touch.html
```

## Build the GLFM examples with Android Studio
There is no CMake generator for Android Studio projects, but you can include `CMakeLists.txt` in a new or existing
project.

1. Select "Start a new Android Studio project".
2. Select "No Activity".
3. In "Save location", enter `[path/to/glfm]/build/android` and press "Finish".
4. In `AndroidManifest.xml`, add the main `<activity>` like so:
```XML
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <uses-feature android:glEsVersion="0x00020000" android:required="true" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true">

        <!-- Add this activity to your AndroidManifest.xml -->
        <activity android:name="android.app.NativeActivity"
                  android:exported="true"
                  android:configChanges="orientation|screenLayout|screenSize|keyboardHidden|keyboard">
            <meta-data
                android:name="android.app.lib_name"
                android:value="glfm_touch" />  <!-- glfm_triangle, glfm_touch, glfm_heightmap, glfm_typing, glfm_compass, or glfm_test_pattern -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>

</manifest>
```
5. In `app/build.gradle`, add the `externalNativeBuild` and `sourceSets.main` sections like so:
```Gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 34
    ndkVersion '23.2.8568313' // Last version to support API 16, 17, 18
    defaultConfig {
        applicationId "com.brackeen.glfmexample"
        minSdkVersion 16
        targetSdkVersion 34
        versionCode 1
        versionName "1.0"

        // Add externalNativeBuild in defaultConfig (1/2)
        externalNativeBuild {
            cmake {
                arguments "-DGLFM_BUILD_EXAMPLES=ON"
            }
        }
    }

    // Add sourceSets.main and externalNativeBuild (2/2)
    sourceSets.main {
        assets.srcDirs = ["../../../examples/assets"]
    }
    externalNativeBuild {
        cmake {
            path "../../../CMakeLists.txt"
        }
    }
    namespace 'com.brackeen.glfmexample'
}
```
6. Press "Sync Now" and "Run 'app'"

## Caveats
* OpenGL ES 3.1 and 3.2 support is only available in Android.
* GLFM is not thread-safe. All GLFM functions must be called on the main thread (that is, from `glfmMain` or from the
callback functions).

## Questions
**What IDE should I use? Why is there no desktop implementation?**
Use Xcode or Android Studio. For desktop, use [GLFW](https://github.com/glfw/glfw) with the IDE of your choice.

If you prefer not using the mobile simulators for everyday development, a good solution is to use GLFW instead, and then
later port your app to GLFM. Not all OpenGL calls will port to OpenGL ES perfectly, but for maximum OpenGL portability,
use OpenGL 3.2 Core Profile on desktop and OpenGL ES 2.0 on mobile.

**Why is the entry point `glfmMain()` and not `main()`?**

Otherwise, it wouldn't work on iOS. To initialize the Objective-C environment, the `main()` function must create an
autorelease pool and call the `UIApplicationMain()` function, which *never returns*. On iOS, GLFM doesn't call
`glfmMain()` until after the `UIApplicationDelegate` and `UIViewController` are initialized.

**Why is GLFM event-driven? Why does GLFM take over the main loop?**

Otherwise, it wouldn't work on iOS (see above) or on HTML5, which is event-driven.

```

`examples/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18.0)

link_libraries(glfm)
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/cmake")

# Common
set(GLFM_APP_ORGANIZATION_IDENTIFIER "com.brackeen")
set(GLFM_APP_VERSION "1.0")
set(GLFM_APP_VERSION_ITERATION 1)
set(GLFM_APP_TARGET_NAME_LIST "")

macro(add_target TARGET SRC_FILES)
    list(APPEND GLFM_APP_TARGET_NAME_LIST ${TARGET})
    set(GLFM_APP_TARGET_NAME ${TARGET})
    set(GLFM_APP_SRC ${SRC_FILES} ${ARGN}) # Use ARGN to allow multiple src files
    include(GLFMAppTarget)
endmacro()

# Simple examples
add_target(glfm_triangle triangle.c)
add_target(glfm_touch touch.c)
add_target(glfm_heightmap heightmap.c)
add_target(glfm_compass compass.c)
add_target(glfm_anim anim.c)

# Examples that require the assets dir
set(GLFM_APP_ASSETS_DIR ${CMAKE_CURRENT_SOURCE_DIR}/assets)
add_target(glfm_typing typing.c)
add_target(glfm_shader_toy shader_toy.c)

# Test pattern example
if (CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    set_source_files_properties(test_pattern_renderer.metal PROPERTIES LANGUAGE METAL)
    add_target(glfm_test_pattern test_pattern.c test_pattern_renderer.h test_pattern_renderer_gles2.c
        test_pattern_renderer_metal.m test_pattern_renderer.metal)
else()
    add_target(glfm_test_pattern test_pattern.c test_pattern_renderer.h test_pattern_renderer_gles2.c)
endif()

# Write index.html for Emscripten examples
if (CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
    file(COPY icons DESTINATION ${CMAKE_CURRENT_BINARY_DIR})
    file(READ index.html.in INDEX_HTML)

    foreach(GLFM_APP_TARGET_NAME ${GLFM_APP_TARGET_NAME_LIST})
        set(GLFM_APP_HTML "
    <figure>
        <a href=\"${GLFM_APP_TARGET_NAME}.html\">
            <img src=\"icons/${GLFM_APP_TARGET_NAME}.png\">
            <figcaption>${GLFM_APP_TARGET_NAME}</figcaption>
        </a>
    </figure>")

        string(REPLACE "<!-- #figure -->" "${GLFM_APP_HTML}\n<!-- #figure -->" INDEX_HTML "${INDEX_HTML}")
    endforeach()
    file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/index.html "${INDEX_HTML}")
endif()

```

`examples/anim.c`:

```c
// Animates a cube of rectangles.
// The cube can be rotated via touch, scroll wheel, or keyboard arrow keys.
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "glfm.h"

#define NUM_RECTANGLES 12
#define ANIMATION_ENABLE 1
#define ANIMATION_DURATION 16.0

typedef struct {
    GLuint program;
    GLuint vertexBuffer;
    GLuint vertexArray;
    GLuint indexBuffer;

    GLint modelLocation;
    GLint viewProjLocation;

    double lastTouchX;
    double lastTouchY;

    double angleX;
    double angleY;

    double animStartTime;
    double animPauseTime;
} AnimApp;

static bool onTouch(GLFMDisplay *display, int touch, GLFMTouchPhase phase, double x, double y) {
    if (phase == GLFMTouchPhaseHover) {
        return false;
    }
    AnimApp *app = glfmGetUserData(display);
    if (phase != GLFMTouchPhaseBegan) {
        int width, height;
        glfmGetDisplaySize(display, &width, &height);
        app->angleX += (x - app->lastTouchX) / height;
        app->angleY += (y - app->lastTouchY) / height;
    }
    app->lastTouchX = x;
    app->lastTouchY = y;
    return true;
}

static bool onKey(GLFMDisplay *display, GLFMKeyCode keyCode, GLFMKeyAction action, int modifiers) {
    bool handled = false;
    if (action == GLFMKeyActionPressed || action == GLFMKeyActionRepeated) {
        AnimApp *app = glfmGetUserData(display);
        switch (keyCode) {
            case GLFMKeyCodeArrowLeft:
                app->angleX -= 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeArrowRight:
                app->angleX += 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeArrowUp:
                app->angleY -= 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeArrowDown:
                app->angleY += 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeEscape:
                app->angleX = 0.0f;
                app->angleY = 0.0f;
                handled = true;
                break;
            default:
                break;
        }
    }
    return handled;
}

static bool onScroll(GLFMDisplay *display, double x, double y, GLFMMouseWheelDeltaType deltaType,
                     double deltaX, double deltaY, double deltaZ) {
    AnimApp *app = glfmGetUserData(display);
    int width, height;
    glfmGetDisplaySize(display, &width, &height);
    if (deltaType != GLFMMouseWheelDeltaPixel) {
        deltaX *= 20;
        deltaY *= 20;
    }
    app->angleX -= deltaX / height;
    app->angleY -= deltaY / height;
    return true;
}

static void onSurfaceDestroyed(GLFMDisplay *display) {
    // When the surface is destroyed, all existing GL resources are no longer valid.
    AnimApp *app = glfmGetUserData(display);
    app->program = 0;
    app->vertexBuffer = 0;
    app->vertexArray = 0;
    app->indexBuffer = 0;
}

static GLuint compileShader(GLenum type, const GLchar *shaderSource) {
    // Compile
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &shaderSource, NULL);
    glCompileShader(shader);

    // Check compile status
    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
    if (status == 0) {
        printf("Shader compile error\n");
        GLint logLength;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLength);
        if (logLength > 0) {
            GLchar *log = malloc(logLength);
            glGetShaderInfoLog(shader, logLength, &logLength, log);
            if (log[0] != 0) {
                printf("%s\n", log);
            }
            free(log);
        }
        glDeleteShader(shader);
        shader = 0;
    }
    return shader;
}

static void draw(AnimApp *app, int width, int height) {
    // Create shader
    if (app->program == 0) {
        const GLchar vertexShader[] =
            "#version 100\n"
            "uniform mat4 model;\n"
            "uniform mat4 viewProj;\n"
            "attribute highp vec3 a_position;\n"
            "attribute lowp vec3 a_color;\n"
            "varying lowp vec4 v_color;\n"
            "void main() {\n"
            "   gl_Position = (viewProj * model) * vec4(a_position, 1.0);\n"
            "   v_color = vec4(a_color, 1.0);\n"
            "}";

        const GLchar fragmentShader[] =
            "#version 100\n"
            "varying lowp vec4 v_color;\n"
            "void main() {\n"
            "  gl_FragColor = v_color;\n"
            "}";

        GLuint vertShader = compileShader(GL_VERTEX_SHADER, vertexShader);
        GLuint fragShader = compileShader(GL_FRAGMENT_SHADER, fragmentShader);
        if (vertShader == 0 || fragShader == 0) {
            return;
        }
        app->program = glCreateProgram();

        glAttachShader(app->program, vertShader);
        glAttachShader(app->program, fragShader);

        glBindAttribLocation(app->program, 0, "a_position");
        glBindAttribLocation(app->program, 1, "a_color");

        glLinkProgram(app->program);

        glDeleteShader(vertShader);
        glDeleteShader(fragShader);

        app->modelLocation = glGetUniformLocation(app->program, "model");
        app->viewProjLocation = glGetUniformLocation(app->program, "viewProj");
    }

    // Fill index buffer
    if (app->indexBuffer == 0) {
        GLushort indices[NUM_RECTANGLES * 6];
        for (int i = 0; i < NUM_RECTANGLES; i++) {
            indices[i * 6 + 0] = i * 4 + 0;
            indices[i * 6 + 1] = i * 4 + 3;
            indices[i * 6 + 2] = i * 4 + 2;
            indices[i * 6 + 3] = i * 4 + 0;
            indices[i * 6 + 4] = i * 4 + 2;
            indices[i * 6 + 5] = i * 4 + 1;
        }
        glGenBuffers(1, &app->indexBuffer);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, app->indexBuffer);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
    }

    // Fill vertex buffer
    GLfloat vertices[NUM_RECTANGLES * 4 * 6 * sizeof(GLfloat)];
    if (app->vertexBuffer == 0) {
        glGenBuffers(1, &app->vertexBuffer);
        glBindBuffer(GL_ARRAY_BUFFER, app->vertexBuffer);
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), NULL, GL_DYNAMIC_DRAW);
    } else {
        glBindBuffer(GL_ARRAY_BUFFER, app->vertexBuffer);
    }
#if ANIMATION_ENABLE
    const double frameTime = glfmGetTime() - app->animStartTime;
    const double p = (float)(fmod(frameTime, ANIMATION_DURATION) / ANIMATION_DURATION);
#else
    const double p = 0;
#endif
    for (int i = 0; i < NUM_RECTANGLES; i++) {
        float t = (float)i / NUM_RECTANGLES;
        float t2 = fmodf(t + p, 1.0f);
        float z = 2.0f * t2 - 1.0f;
        float a = 1.0f;
#if ANIMATION_ENABLE
        if (t2 < 1.0f / NUM_RECTANGLES) {
            a = t2 / (1.0f / NUM_RECTANGLES);
        } else if (t2 > 1.0f - 1.0f / NUM_RECTANGLES) {
            a = (1.0f - t2) / (1.0f / NUM_RECTANGLES);
        }
#endif
        float r = a * (1.0 / NUM_RECTANGLES);
        float g = a * (1.0 / NUM_RECTANGLES);
        float b = a * (1.0 / NUM_RECTANGLES);
        int offset = i * 4 * 6;

        // Top left
        vertices[offset + 0] = -1.0f;
        vertices[offset + 1] = 1.0f;
        vertices[offset + 2] = z;
        vertices[offset + 3] = r;
        vertices[offset + 4] = g;
        vertices[offset + 5] = b;

        // Top right
        vertices[offset + 6] = 1.0f;
        vertices[offset + 7] = 1.0f;
        vertices[offset + 8] = z;
        vertices[offset + 9] = r;
        vertices[offset + 10] = g;
        vertices[offset + 11] = b;

        // Bottom right
        vertices[offset + 12] = 1.0f;
        vertices[offset + 13] = -1.0f;
        vertices[offset + 14] = z;
        vertices[offset + 15] = r;
        vertices[offset + 16] = g;
        vertices[offset + 17] = b;

        // Bottom left
        vertices[offset + 18] = -1.0f;
        vertices[offset + 19] = -1.0f;
        vertices[offset + 20] = z;
        vertices[offset + 21] = r;
        vertices[offset + 22] = g;
        vertices[offset + 23] = b;
    }
    glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);

    // Upload matrices
    float scale = 1.0;
    if (width >= height) {
        scale = 1.5f;
    }
    float ratio = scale * (float)height / (float)width;
    float cx = cosf(app->angleY * -2 * M_PI);
    float sx = sinf(app->angleY * -2 * M_PI);
    float cy = cosf(app->angleX * -2 * M_PI);
    float sy = sinf(app->angleX * -2 * M_PI);
    float z = -3.0f;

    const GLfloat model[16] = {
           cy, sx*sy, cx*sy,  0.0f,
         0.0f,    cx,   -sx,  0.0f,
          -sy, sx*cy, cx*cy,  0.0f,
         0.0f,  0.0f,     z,  1.0f,
    };

    const GLfloat viewProj[16] = {
        ratio,  0.0f,  0.0f,  0.0f,
         0.0f, scale,  0.0f,  0.0f,
         0.0f,  0.0f, -1.0f, -1.0f,
         0.0f,  0.0f,  0.00,  1.0f,
    };

    glUseProgram(app->program);
    glUniformMatrix4fv(app->modelLocation, 1, GL_FALSE, model);
    glUniformMatrix4fv(app->viewProjLocation, 1, GL_FALSE, viewProj);

    // Draw background
    glViewport(0, 0, width, height);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // Draw rectangles
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE); // Additive blending
#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    if (app->vertexArray == 0) {
        glGenVertexArrays(1, &app->vertexArray);
    }
    glBindVertexArray(app->vertexArray);
#endif
    glBindBuffer(GL_ARRAY_BUFFER, app->vertexBuffer);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (void *)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (void *)(sizeof(GLfloat) * 3));

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, app->indexBuffer);
    glDrawElements(GL_TRIANGLES, NUM_RECTANGLES * 6, GL_UNSIGNED_SHORT, (void *)0);
}

static void onDraw(GLFMDisplay *display) {
    AnimApp *app = glfmGetUserData(display);
    int width, height;
    glfmGetDisplaySize(display, &width, &height);
    draw(app, width, height);
    glfmSwapBuffers(display);
}

static void onFocus(GLFMDisplay *display, bool focused) {
    AnimApp *app = glfmGetUserData(display);
    if (focused) {
        app->animStartTime += glfmGetTime() - app->animPauseTime;
    } else {
        app->animPauseTime = glfmGetTime();
    }
}

void glfmMain(GLFMDisplay *display) {
    AnimApp *app = calloc(1, sizeof(AnimApp));
    app->angleX = -0.125f;
    app->angleY = 0.0f;
    app->animStartTime = app->animPauseTime = glfmGetTime();
    glfmSetDisplayConfig(display,
                         GLFMRenderingAPIOpenGLES2,
                         GLFMColorFormatRGBA8888,
                         GLFMDepthFormatNone,
                         GLFMStencilFormatNone,
                         GLFMMultisampleNone);
    glfmSetUserData(display, app);
    glfmSetAppFocusFunc(display, onFocus);
    glfmSetSurfaceDestroyedFunc(display, onSurfaceDestroyed);
    glfmSetRenderFunc(display, onDraw);
    glfmSetTouchFunc(display, onTouch);
    glfmSetKeyFunc(display, onKey);
    glfmSetMouseWheelFunc(display, onScroll);
}

```

`examples/assets/shader_toy.frag`:

```frag
#version 100

precision highp float;

uniform vec3 iResolution;
uniform float iTime;

void mainImage(inout vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);

    fragColor = vec4(0.1 / abs(2.0 * length(uv) - 1.0) + sin(iTime) / 4.0);
}

void main() {
    vec4 fragColor = vec4(0, 0, 0, 1);
    mainImage(fragColor, gl_FragCoord.xy);
    gl_FragColor = fragColor;
}

```

`examples/assets/shader_toy.vert`:

```vert
#version 100

attribute vec2 position;

void main() {
    gl_Position = vec4(position, 0, 1);
}

```

`examples/assets/simple.frag`:

```frag
#version 100

varying lowp vec3 v_color;

void main() {
    gl_FragColor = vec4(v_color, 1.0);
}

```

`examples/assets/simple.vert`:

```vert
#version 100

attribute highp vec3 a_position;
attribute lowp vec3 a_color;

varying lowp vec3 v_color;

void main() {
    gl_Position = vec4(a_position, 1.0);
    v_color = a_color;
}

```

`examples/assets/texture.frag`:

```frag
#version 100

uniform lowp sampler2D texture0;

varying mediump vec2 texCoordFragment;

void main()
{
    gl_FragColor = texture2D(texture0, texCoordFragment);
}

```

`examples/assets/texture.vert`:

```vert
#version 100

attribute highp vec4 position;
attribute mediump vec2 texCoord;

varying mediump vec2 texCoordFragment;

void main()
{
    gl_Position = position;
    texCoordFragment = texCoord;
}

```

`examples/cmake/GLFMAppTarget.cmake`:

```cmake
#
# GLFM_APP_TARGET_NAME - App name
# GLFM_APP_ORGANIZATION_IDENTIFIER - Reverse domain name, like "com.example"
# GLFM_APP_VERSION - Version string, like "1.0"
# GLFM_APP_VERSION_ITERATION - Version code (integer)
# GLFM_APP_ASSETS_DIR - Assets directory (optional)
# GLFM_APP_SRC - Source files

if (DEFINED GLFM_APP_ASSETS_DIR)
    file(GLOB GLFM_APP_ASSETS ${GLFM_APP_ASSETS_DIR}/*)
else()
    set(GLFM_APP_ASSETS "")
endif()

source_group("Source" FILES ${GLFM_APP_SRC})

if (CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
    # HACK: Make modifications to shell_minimal.html to take up the entire browser window
    file(READ ${EMSCRIPTEN_ROOT_PATH}/src/shell_minimal.html EMSCRIPTEN_SHELL_HTML)
    string(FIND "${EMSCRIPTEN_SHELL_HTML}" "<style>" HAS_STYLE)
    if (${HAS_STYLE} EQUAL -1)
        message(WARNING "<style> not found in shell_minimal.html, copying as-is")
    else()
        string(CONCAT STYLE_REPLACEMENT "<meta name=\"viewport\" content=\"width=device-width,user-scalable=no,viewport-fit=cover\">\n"
            "    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n"
            "    <style>\n"
            "      /* GLFM: Start changes */\n"
            "      :root {\n"
            "          --glfm-chrome-top-old: constant(safe-area-inset-top);\n"
            "          --glfm-chrome-right-old: constant(safe-area-inset-right);\n"
            "          --glfm-chrome-bottom-old: constant(safe-area-inset-bottom);\n"
            "          --glfm-chrome-left-old: constant(safe-area-inset-left);\n"
            "          --glfm-chrome-top: env(safe-area-inset-top);\n"
            "          --glfm-chrome-right: env(safe-area-inset-right);\n"
            "          --glfm-chrome-bottom: env(safe-area-inset-bottom);\n"
            "          --glfm-chrome-left: env(safe-area-inset-left);\n"
            "      }\n"
            "      body, html { border: 0px none; padding: 0px; margin: 0px; width: 100%; height: 100%; overflow: hidden; position: fixed; }\n"
            "      canvas.emscripten { background: black; outline: none; width: 100%; height: 100%; }\n"
            "      .emscripten_border { width: 100%; height: 100%; border: 0px none !important;}\n"
            "      hr { display: none; }\n"
            "      /* GLFM: End changes */"
        )
        string(REPLACE "<style>" "${STYLE_REPLACEMENT}" EMSCRIPTEN_SHELL_HTML "${EMSCRIPTEN_SHELL_HTML}")
    endif()
    file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/shell.html.in "${EMSCRIPTEN_SHELL_HTML}")

    set(CMAKE_EXECUTABLE_SUFFIX ".html")
    add_executable(${GLFM_APP_TARGET_NAME} ${GLFM_APP_SRC})
    if (DEFINED GLFM_APP_ASSETS_DIR)
        set(GLFM_PRELOAD_FLAG "--preload-file ${GLFM_APP_ASSETS_DIR}@")
    else()
        set(GLFM_PRELOAD_FLAG "")
    endif()
    set_target_properties(${GLFM_APP_TARGET_NAME} PROPERTIES LINK_FLAGS "-sALLOW_MEMORY_GROWTH --shell-file ${CMAKE_CURRENT_BINARY_DIR}/shell.html.in ${GLFM_PRELOAD_FLAG}")
elseif (CMAKE_SYSTEM_NAME STREQUAL "Android")
    add_library(${GLFM_APP_TARGET_NAME} SHARED ${GLFM_APP_SRC})
    target_link_libraries(${GLFM_APP_TARGET_NAME} glfm)
elseif (CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    # If you change this section, test archiving too.
    set(CMAKE_MACOSX_BUNDLE YES)

    add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${GLFM_APP_TARGET_NAME}.icns
                       COMMAND bash -c "${CMAKE_CURRENT_SOURCE_DIR}/icons/gen_icns.sh ${GLFM_APP_TARGET_NAME} ${CMAKE_CURRENT_BINARY_DIR}"
                       DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/icons/${GLFM_APP_TARGET_NAME}.png
                       WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/icons)
    source_group("Resources" FILES ${CMAKE_CURRENT_BINARY_DIR}/${GLFM_APP_TARGET_NAME}.icns ${GLFM_APP_ASSETS})

    add_executable(${GLFM_APP_TARGET_NAME} ${GLFM_APP_SRC} ${GLFM_APP_ASSETS} ${CMAKE_CURRENT_BINARY_DIR}/${GLFM_APP_TARGET_NAME}.icns)

    set_target_properties(${GLFM_APP_TARGET_NAME} PROPERTIES
        MACOSX_BUNDLE_INFO_PLIST ${CMAKE_CURRENT_BINARY_DIR}/CMake-Info.plist.in
        XCODE_ATTRIBUTE_PRODUCT_BUNDLE_IDENTIFIER "${GLFM_APP_ORGANIZATION_IDENTIFIER}.\${PRODUCT_NAME:rfc1034identifier}"
        XCODE_ATTRIBUTE_SUPPORTED_PLATFORMS "appletvos appletvsimulator iphoneos iphonesimulator macosx"
        XCODE_ATTRIBUTE_SUPPORTS_MACCATALYST NO
        XCODE_ATTRIBUTE_SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD NO
        XCODE_ATTRIBUTE_TARGETED_DEVICE_FAMILY "1,2,3"
        XCODE_ATTRIBUTE_IPHONEOS_DEPLOYMENT_TARGET 11.0         # Minimum supported by Xcode 14
        XCODE_ATTRIBUTE_TVOS_DEPLOYMENT_TARGET 11.0             # Minimum supported by Xcode 14
        XCODE_ATTRIBUTE_MACOSX_DEPLOYMENT_TARGET 10.13          # Minimum supported by Xcode 14
        XCODE_ATTRIBUTE_CLANG_ENABLE_OBJC_ARC YES
        XCODE_ATTRIBUTE_COMBINE_HIDPI_IMAGES NO                 # For Archiving
        XCODE_ATTRIBUTE_OTHER_LDFLAGS ""                        # For Archiving
        XCODE_ATTRIBUTE_INSTALL_PATH "$(LOCAL_APPS_DIR)"        # For Archiving
        XCODE_ATTRIBUTE_SKIP_INSTALL NO                         # For Archiving
        XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY[sdk=macosx*] "-"     # For convenience
    )
    if (NOT DEFINED CMAKE_XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY)
        set_target_properties(${GLFM_APP_TARGET_NAME} PROPERTIES
            XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY "iPhone Developer")
    endif()
    set_source_files_properties(${GLFM_APP_ASSETS} LaunchScreen.storyboard ${GLFM_APP_TARGET_NAME}.icns PROPERTIES MACOSX_PACKAGE_LOCATION Resources)
    set_source_files_properties(${GLFM_APP_ASSETS} PROPERTIES XCODE_LAST_KNOWN_FILE_TYPE YES)
    target_compile_definitions(${GLFM_APP_TARGET_NAME} PRIVATE GLES_SILENCE_DEPRECATION)

    set(MACOSX_BUNDLE_SHORT_VERSION_STRING ${GLFM_APP_VERSION})
    set(MACOSX_BUNDLE_BUNDLE_VERSION ${GLFM_APP_VERSION_ITERATION})

    # LaunchScreen needed to allow any screen size. Don't overwrite.
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/LaunchScreen.storyboard)
        file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/LaunchScreen.storyboard
            "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"
            "<document type=\"com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB\" version=\"3.0\" toolsVersion=\"11134\" systemVersion=\"15F34\" targetRuntime=\"iOS.CocoaTouch\" propertyAccessControl=\"none\" useAutolayout=\"YES\" launchScreen=\"YES\" useTraitCollections=\"YES\" colorMatched=\"YES\" initialViewController=\"01J-lp-oVM\">\n"
            "    <dependencies>\n"
            "        <plugIn identifier=\"com.apple.InterfaceBuilder.IBCocoaTouchPlugin\" version=\"11106\"/>\n"
            "        <capability name=\"documents saved in the Xcode 8 format\" minToolsVersion=\"8.0\"/>\n"
            "    </dependencies>\n"
            "    <scenes>\n"
            "        <!--View Controller-->\n"
            "        <scene sceneID=\"EHf-IW-A2E\">\n"
            "            <objects>\n"
            "                <viewController id=\"01J-lp-oVM\" sceneMemberID=\"viewController\">\n"
            "                    <layoutGuides>\n"
            "                        <viewControllerLayoutGuide type=\"top\" id=\"Llm-lL-Icb\"/>\n"
            "                        <viewControllerLayoutGuide type=\"bottom\" id=\"xb3-aO-Qok\"/>\n"
            "                    </layoutGuides>\n"
            "                    <view key=\"view\" contentMode=\"scaleToFill\" id=\"Ze5-6b-2t3\">\n"
            "                        <rect key=\"frame\" x=\"0.0\" y=\"0.0\" width=\"375\" height=\"667\"/>\n"
            "                        <autoresizingMask key=\"autoresizingMask\" widthSizable=\"YES\" heightSizable=\"YES\"/>\n"
            "                        <color key=\"backgroundColor\" red=\"0\" green=\"0\" blue=\"0\" alpha=\"1\" colorSpace=\"custom\" customColorSpace=\"sRGB\"/>\n"
            "                    </view>\n"
            "                </viewController>\n"
            "                <placeholder placeholderIdentifier=\"IBFirstResponder\" id=\"iYj-Kq-Ea1\" userLabel=\"First Responder\" sceneMemberID=\"firstResponder\"/>\n"
            "            </objects>\n"
            "            <point key=\"canvasLocation\" x=\"53\" y=\"375\"/>\n"
            "        </scene>\n"
            "    </scenes>\n"
            "</document>\n"
        )
    endif()
    # In place of MacOSXBundleInfo.plist.in
    file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/CMake-Info.plist.in
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n"
        "<plist version=\"1.0\">\n"
        "<dict>\n"
        "	<key>CFBundleDevelopmentRegion</key>\n"
        "	<string>en</string>\n"
        "	<key>CFBundleExecutable</key>\n"
        "	<string>$(EXECUTABLE_NAME)</string>\n"
        "	<key>CFBundleIdentifier</key>\n"
        "	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>\n"
        "	<key>CFBundleInfoDictionaryVersion</key>\n"
        "	<string>6.0</string>\n"
        "	<key>CFBundleName</key>\n"
        "	<string>$(PRODUCT_NAME)</string>\n"
        "	<key>CFBundlePackageType</key>\n"
        "	<string>APPL</string>\n"
        "	<key>CFBundleShortVersionString</key>\n"
        "	<string>\${MACOSX_BUNDLE_SHORT_VERSION_STRING}</string>\n"
        "	<key>CFBundleVersion</key>\n"
        "	<string>\${MACOSX_BUNDLE_BUNDLE_VERSION}</string>\n"
        "	<key>LSRequiresIPhoneOS</key>\n"
        "	<true/>\n"
        "	<key>UIApplicationSceneManifest</key>\n"
        "	<dict>\n"
        "		<key>UISceneConfigurations</key>\n"
        "		<dict/>\n"
        "	</dict>\n"
        "	<key>UILaunchStoryboardName</key>\n"
        "	<string>LaunchScreen</string>\n"
        "	<key>UIRequiredDeviceCapabilities</key>\n"
        "	<array>\n"
        "		<string>armv7</string>\n"
        "		<string>opengles-2</string>\n"
        "	</array>\n"
        "	<key>UIStatusBarHidden</key>\n"
        "	<true/>\n"
        "	<key>UISupportedInterfaceOrientations</key>\n"
        "	<array>\n"
        "		<string>UIInterfaceOrientationPortrait</string>\n"
        "		<string>UIInterfaceOrientationLandscapeLeft</string>\n"
        "		<string>UIInterfaceOrientationLandscapeRight</string>\n"
        "	</array>\n"
        "	<key>UISupportedInterfaceOrientations~ipad</key>\n"
        "	<array>\n"
        "		<string>UIInterfaceOrientationPortrait</string>\n"
        "		<string>UIInterfaceOrientationPortraitUpsideDown</string>\n"
        "		<string>UIInterfaceOrientationLandscapeLeft</string>\n"
        "		<string>UIInterfaceOrientationLandscapeRight</string>\n"
        "	</array>\n"
        "	<key>CFBundleIconFile</key>\n"
        "	<string>$(EXECUTABLE_NAME).icns</string>\n"
        "</dict>\n"
        "</plist>\n"
    )
endif()

set_target_properties(${GLFM_APP_TARGET_NAME} PROPERTIES C_STANDARD 11)
target_include_directories(${GLFM_APP_TARGET_NAME} PUBLIC deps)

```

`examples/compass.c`:

```c
// Draws a compass in 3D. White is north. Requires a device with a compass/gyroscope (iOS/Android only).

#include <stdlib.h>
#include <math.h>
#include "glfm.h"
#include "file_compat.h"

#define FILE_COMPAT_ANDROID_ACTIVITY glfmGetAndroidActivity(display)

static const char *VERT_SHADER =
"#version 100\n"
"attribute highp vec3 a_position;"
"attribute lowp vec3 a_color;"
"varying lowp vec3 v_color;"
"void main() {"
"    gl_Position = vec4(a_position, 1);"
"    v_color = a_color;"
"}";

static const char *FRAG_SHADER =
"#version 100\n"
"varying lowp vec3 v_color;"
"void main() {"
"    gl_FragColor = vec4(v_color, 1);"
"}";

typedef struct {
    GLuint program;
    GLuint vertexBuffer;
    GLuint vertexArray;
    bool sensorDataReceived;
    struct {
        double m00, m01, m02;
        double m10, m11, m12;
        double m20, m21, m22;
    } rotation;
} CompassApp;

static void applyRotation(const CompassApp *app, GLfloat *x, GLfloat *y, GLfloat *z) {
    GLfloat x0 = *x;
    GLfloat y0 = *y;
    GLfloat z0 = *z;
    *x = app->rotation.m00 * x0 + app->rotation.m01 * y0 + app->rotation.m02 * z0;
    *y = app->rotation.m10 * x0 + app->rotation.m11 * y0 + app->rotation.m12 * z0;
    *z = app->rotation.m20 * x0 + app->rotation.m21 * y0 + app->rotation.m22 * z0;
}

static void drawCompass(CompassApp *app, int width, int height) {
    if (app->program == 0) {
        // Create shader
        app->program = glCreateProgram();

        GLuint vertShader = glCreateShader(GL_VERTEX_SHADER);
        GLuint fragShader = glCreateShader(GL_FRAGMENT_SHADER);
        
        glShaderSource(vertShader, 1, &VERT_SHADER, NULL);
        glShaderSource(fragShader, 1, &FRAG_SHADER, NULL);
        
        glCompileShader(vertShader);
        glCompileShader(fragShader);

        glAttachShader(app->program, vertShader);
        glAttachShader(app->program, fragShader);

        glBindAttribLocation(app->program, 0, "a_position");
        glBindAttribLocation(app->program, 1, "a_color");

        glLinkProgram(app->program);

        glDeleteShader(vertShader);
        glDeleteShader(fragShader);
    }
    
#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    if (app->vertexArray == 0) {
        glGenVertexArrays(1, &app->vertexArray);
    }
    glBindVertexArray(app->vertexArray);
#endif

    // Set up triangle attributes
    glUseProgram(app->program);
    if (app->vertexBuffer == 0) {
        glGenBuffers(1, &app->vertexBuffer);
    }
    glBindBuffer(GL_ARRAY_BUFFER, app->vertexBuffer);
    const size_t stride = sizeof(GLfloat) * 6;
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void *)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void *)(sizeof(GLfloat) * 3));
    
    // Define triangle vertices
    // (X axis points North, Z axis is vertical)
    float off = 0.4f;
    float sideLength = 0.25f;
    float x = sqrt(pow(sideLength, 2) - pow(sideLength / 2, 2)) / 2;
    float y = sideLength / 2;
    GLfloat vertices[] = {
        // x,y,z           r,g,b
        // North (white)
        off + x,  0, 0,    1.0, 1.0, 1.0,
        off - x,  y, 0,    1.0, 1.0, 1.0,
        off - x, -y, 0,    1.0, 1.0, 1.0,

        // South
        -off - x,  0, 0,   0.3, 0.3, 0.3,
        -off + x, -y, 0,   0.3, 0.3, 0.3,
        -off + x,  y, 0,   0.3, 0.3, 0.3,

        // West
         0, off + x, 0,    0.3, 0.3, 0.3,
        -y, off - x, 0,    0.3, 0.3, 0.3,
         y, off - x, 0,    0.3, 0.3, 0.3,

        // East
         0, -off - x, 0,   0.3, 0.3, 0.3,
         y, -off + x, 0,   0.3, 0.3, 0.3,
        -y, -off + x, 0,   0.3, 0.3, 0.3,
    };
    
    // Transform triangle vertices
    int vertexCount = sizeof(vertices) / stride;
    for (int i = 0; i < vertexCount; i++) {
        GLfloat *t = vertices + i * stride / sizeof(GLfloat);
        applyRotation(app, t + 0,  t + 1,  t + 2);
        if (height < width) {
            float scaleX = (float)height / width;
            t[0] *= scaleX;
        } else {
            float scaleY = (float)width / height;
            t[1] *= scaleY;
        }
    }

    // Draw triangles
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    glDrawArrays(GL_TRIANGLES, 0, vertexCount);
}

static void onDraw(GLFMDisplay *display) {
    CompassApp *app = glfmGetUserData(display);
    int width, height;
    glfmGetDisplaySize(display, &width, &height);
    glViewport(0, 0, width, height);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    if (app->sensorDataReceived) {
        drawCompass(app, width, height);
    }
    glfmSwapBuffers(display);
}

static void onSurfaceDestroyed(GLFMDisplay *display) {
    CompassApp *app = glfmGetUserData(display);
    app->program = 0;
    app->vertexBuffer = 0;
    app->vertexArray = 0;
}

static void onSensor(GLFMDisplay *display, GLFMSensorEvent event) {
    if (event.sensor == GLFMSensorRotationMatrix) {
        CompassApp *app = glfmGetUserData(display);
        app->sensorDataReceived = true;

        GLFMInterfaceOrientation orientation = glfmGetInterfaceOrientation(display);
        switch (orientation) {
            case GLFMInterfaceOrientationPortrait: default:
                app->rotation.m00 = event.matrix.m00;
                app->rotation.m01 = event.matrix.m01;
                app->rotation.m02 = event.matrix.m02;
                app->rotation.m10 = event.matrix.m10;
                app->rotation.m11 = event.matrix.m11;
                app->rotation.m12 = event.matrix.m12;
                app->rotation.m20 = event.matrix.m20;
                app->rotation.m21 = event.matrix.m21;
                app->rotation.m22 = event.matrix.m22;
                break;
            case GLFMInterfaceOrientationLandscapeLeft: // Rotate Z 90 degrees
                app->rotation.m00 = event.matrix.m10;
                app->rotation.m01 = event.matrix.m11;
                app->rotation.m02 = event.matrix.m12;
                app->rotation.m10 = -event.matrix.m00;
                app->rotation.m11 = -event.matrix.m01;
                app->rotation.m12 = -event.matrix.m02;
                app->rotation.m20 = event.matrix.m20;
                app->rotation.m21 = event.matrix.m21;
                app->rotation.m22 = event.matrix.m22;
                break;
            case GLFMInterfaceOrientationPortraitUpsideDown: // Rotate Z 180 degrees
                app->rotation.m00 = -event.matrix.m00;
                app->rotation.m01 = -event.matrix.m01;
                app->rotation.m02 = -event.matrix.m02;
                app->rotation.m10 = -event.matrix.m10;
                app->rotation.m11 = -event.matrix.m11;
                app->rotation.m12 = -event.matrix.m12;
                app->rotation.m20 = event.matrix.m20;
                app->rotation.m21 = event.matrix.m21;
                app->rotation.m22 = event.matrix.m22;
                break;
            case GLFMInterfaceOrientationLandscapeRight: // Rotate Z -90 degrees
                app->rotation.m00 = -event.matrix.m10;
                app->rotation.m01 = -event.matrix.m11;
                app->rotation.m02 = -event.matrix.m12;
                app->rotation.m10 = event.matrix.m00;
                app->rotation.m11 = event.matrix.m01;
                app->rotation.m12 = event.matrix.m02;
                app->rotation.m20 = event.matrix.m20;
                app->rotation.m21 = event.matrix.m21;
                app->rotation.m22 = event.matrix.m22;
                break;
        }
    }
}

void glfmMain(GLFMDisplay *display) {
    CompassApp *app = calloc(1, sizeof(CompassApp));

    glfmSetDisplayConfig(display,
                         GLFMRenderingAPIOpenGLES2,
                         GLFMColorFormatRGBA8888,
                         GLFMDepthFormatNone,
                         GLFMStencilFormatNone,
                         GLFMMultisampleNone);
    glfmSetUserData(display, app);
    glfmSetSurfaceDestroyedFunc(display, onSurfaceDestroyed);
    glfmSetRenderFunc(display, onDraw);
    
    if (glfmIsSensorAvailable(display, GLFMSensorRotationMatrix)) {
        // Enable sensor for the device's rotation matrix. To disable, set the callback function to NULL.
        glfmSetSensorFunc(display, GLFMSensorRotationMatrix, onSensor);
    } else {
        printf("Warning: Rotation sensor not available on this device.\n");
        // North points up
        app->sensorDataReceived = true;
        app->rotation.m00 = 0.0f;
        app->rotation.m01 = -1.0f;
        app->rotation.m02 = 0.0f;
        app->rotation.m10 = 1.0f;
        app->rotation.m11 = 0.0f;
        app->rotation.m12 = 0.0f;
        app->rotation.m20 = 0.0f;
        app->rotation.m21 = 0.0f;
        app->rotation.m22 = 1.0f;
    }
}

```

`examples/deps/file_compat.h`:

```h
// file-compat
// https://github.com/brackeen/file-compat

#ifndef FILE_COMPAT_H
#define FILE_COMPAT_H

/**
    ## Redefined Functions (Windows, Android):

    | Function            | Windows                      | Android
    |---------------------|------------------------------|------------------------------------------
    | `printf`            | Uses `OutputDebugString`     | Uses `__android_log_print`
    | `fopen`             | Uses `fopen_s`               | Uses `AAssetManager_open` if read mode
    | `fclose`            | Adds `NULL` check            | No change

    Note: `OutputDebugString` is only used if the debugger is present and no console is allocated.
    Otherwise uses `printf`.

    ## Added Functions (Windows, Linux, macOS, iOS, Android, Emscripten):

    | Function     | Description
    |--------------|--------------------------------------------------------------------------------
    | `fc_locale`  | Gets the user's preferred language (For example, "en-US").
    | `fc_resdir`  | Gets the current executable's resources directory.
    | `fc_datadir` | Gets the current executable's data directory, useful for saving preferences.
    | `fc_cachedir`| Gets the current executable's cache directory, useful for saving downloaded files.
    
    ## Usage:

    For Android, define `FILE_COMPAT_ANDROID_ACTIVITY` to be a reference to an `ANativeActivity`
    instance or to a function that returns an `ANativeActivity` instance.

        #include "file_compat.h"
        #define FILE_COMPAT_ANDROID_ACTIVITY functionThatGetsAndroidActivity()

        ANativeActivity *functionThatGetsAndroidActivity(void);

 */

#include <stdio.h>
#include <errno.h>

#if defined(_WIN32)
#  define FC_DIRECTORY_SEPARATOR '\\'
#else
#  define FC_DIRECTORY_SEPARATOR '/'
#endif

#if defined(__GNUC__)
#  define FC_UNUSED __attribute__ ((unused))
#else
#  define FC_UNUSED
#endif

/// Gets the path to the current executable's resources directory.
/// The path will have a trailing slash (or backslash on Windows).
///
/// The returned path is:
///   * Windows:            The path to the executable's directory.
///   * Linux:              The path to the executable's directory.
///   * macOS (executable): The path to the executable's directory.
///   * macOS (bundled):    The path to the bundle's resources.
///   * iOS:                The path to the bundle's resources.
///   * Android:            An empty string.
///   * Emscripten          An empty string.
///
/// - Parameters:
///   - path: The buffer to fill the path. No more than `path_max` bytes are written to the buffer,
///           including the trailing 0. If failure occurs, the path is set to an empty string.
///   - path_max: The length of the buffer. Should be `PATH_MAX`.
///
/// - Returns: 0 on success, -1 on failure.
static int fc_resdir(char *path, size_t path_max) FC_UNUSED;

/// Gets the path to the current executable's data directory. It is useful for saving preferences.
/// The path will have a trailing slash (or backslash on Windows).
///
/// The data directory is writable and unique to the executable.
///
/// The returned path is:
///  * Windows:             `%HOMEPATH%\\AppData\\Roaming\\<app_id>\\`
///  * Linux:               `~/.local/share/<app_id>/`
///  * macOS (executable):  `~/Library/Application Support/<app_id>/`
///  * macOS (bundled):     `~/Library/Application Support/<bundle_id>/`
///  * macOS (sandboxed):   `~/Library/Containers/<bundle_id>/Data/Library/Application Support/`
///  * iOS:                 Local path determined by the system (not using `app_id`).
///  * Android:             Local path from `getFilesDir` (not using `app_id`).
///  * Emscripten:          `/home/web_user/.local/share/<app_id>/`
///
/// The directory will be created if it does not exist.
///
/// On Unix-like platforms, if a subdirectory of this directory is needed, it should be created
/// with mode `0700` (octal).
///
/// On Emscripten, to persist data, the path has to be mounted and synchronized to an IDBFS
/// instance. Otherwise, the files created only exist in memory.
///
/// - Parameters:
///   - app_id: The application id, like "MyApp".
///   - path: The buffer to fill the path. No more than `path_max` bytes are written to the buffer,
///           including the trailing 0. If failure occurs, the path is set to an empty string.
///   - path_max: The length of the buffer. Should be `PATH_MAX`.
///
/// - Returns: 0 on success, -1 on failure.
static int fc_datadir(const char *app_id, char *path, size_t path_max) FC_UNUSED;

/// Gets the path to the current executable's cache directory.
/// It is useful for saving downloaded files.
/// The path will have a trailing slash (or backslash on Windows).
///
/// The cache directory is writable and unique to the executable.
///
/// The returned path is:
///  * Windows:             `%HOMEPATH%\\AppData\\Local\\<app_id>\\`
///  * Linux:               `~/.cache/<app_id>/`
///  * macOS (executable):  `~/Library/Caches/<app_id>/`
///  * macOS (bundled):     `~/Library/Caches/<bundle_id>/`
///  * macOS (sandboxed):   `~/Library/Containers/<bundle_id>/Data/Library/Caches/`
///  * iOS:                 Local path determined by the system (not using `app_id`).
///  * Android:             Local path from `getCacheDir` (not using `app_id`).
///  * Emscripten:          `/home/web_user/.cache/<app_id>/`
///
/// The directory will be created if it does not exist.
///
/// On Unix-like platforms, if a subdirectory of this directory is needed, it should be created
/// with mode `0700` (octal).
///
/// On Emscripten, to persist data, the path has to be mounted and synchronized to an IDBFS
/// instance. Otherwise, the files created only exist in memory.
///
/// - Parameters:
///   - app_id: The application id, like "MyApp".
///   - path: The buffer to fill the path. No more than `path_max` bytes are written to the buffer,
///           including the trailing 0. If failure occurs, the path is set to an empty string.
///   - path_max: The length of the buffer. Should be `PATH_MAX`.
///
/// - Returns: 0 on success, -1 on failure.
static int fc_cachedir(const char *app_id, char *path, size_t path_max) FC_UNUSED;

/// Gets the preferred user language in BCP-47 format.
///
/// Valid examples are "en", "en-US", "zh-Hans", and "zh-Hans-HK". Some platforms may return values
/// in lowercase ("en-us" instead of "en-US").
///
/// - Parameters:
///   - locale: The buffer to fill the locale. No more than `locale_max` bytes are written to the
///             buffer, including the trailing 0. If failure occurs, the locale is set to an empty
///             string.
///   - locale_max: The length of the buffer. This value must be at least 3.
///
/// - Returns: 0 on success, -1 on failure.
static int fc_locale(char *locale, size_t locale_max) FC_UNUSED;

// MARK: - Private

#if !defined(_WIN32)
#  include <limits.h> // PATH_MAX
#endif

#ifdef __cplusplus
#  define FC_STATIC_CAST(value_type) static_cast<value_type>
#  define FC_REINTERPRET_CAST(value_type) reinterpret_cast<value_type>
#else
#  define FC_STATIC_CAST(value_type) (value_type)
#  define FC_REINTERPRET_CAST(value_type) (value_type)
#endif

static void fc__locale_clean(char *locale) {
    // Convert underscore to dash ("en_US" to "en-US")
    // Remove encoding ("en-US.UTF-8" to "en-US")
    char *ch = locale;
    while (*ch != 0) {
        if (*ch == '_') {
            *ch = '-';
        } else if (*ch == '.') {
            *ch = 0;
            break;
        }
        ch++;
    }
}

#if defined(__unix__) && !defined(__ANDROID__)

#include <stdlib.h> // getenv
#include <sys/stat.h> // mkdir

/// *Unix only:* Gets a path from an environment variable, and appends `app_id` to it.
/// If the environment variable is not found, the `default_path` is used.
///
/// If `env_var` is available, the resulting path is `getenv(env_var)/app_id/`.
/// Otherwise, the resulting path is `getenv("HOME")/default_path/app_id/`.
///
/// Example: `fc__unixdir("XDG_DATA_HOME", ".local/share", "MyApp", path, path_max);`
static int fc__unixdir(const char *env_var, const char *default_path,
                       const char *app_id, char *path, size_t path_max) {
    int result = -1;
    const char *env_path = getenv(env_var);
    if (env_path && *env_path) {
        result = snprintf(path, path_max, "%s/%s/", env_path, app_id);
    } else {
        const char *home_path = getenv("HOME");
        if (home_path && *home_path) {
            result = snprintf(path, path_max, "%s/%s/%s/", home_path, default_path, app_id);
        }
    }
    if (result <= 0 || FC_STATIC_CAST(size_t)(result) >= path_max) {
        path[0] = 0;
        return -1;
    }
    char *ch = path;
    while (*(++ch)) {
        if (*ch == '/') {
            *ch = 0;
            if (mkdir(path, 0700) != 0 && errno != EEXIST) {
                path[0] = 0;
                return -1;
            }
            *ch = '/';
        }
    }
    return 0;
}

#endif // defined(__unix__)

// MARK: - Apple

#if defined(__APPLE__)

#include <TargetConditionals.h>
#include <CoreFoundation/CoreFoundation.h>
#include <objc/objc.h>
#include <objc/runtime.h>
#include <objc/message.h>
#include <objc/NSObjCRuntime.h>
#include <sys/stat.h> // mkdir
#if defined(__OBJC__) && __has_feature(objc_arc)
#  define FC_AUTORELEASEPOOL_BEGIN @autoreleasepool {
#  define FC_AUTORELEASEPOOL_END }
#else
#  define FC_MSG_SEND (FC_REINTERPRET_CAST(id (*)(id, SEL))(objc_msgSend))
#  define FC_AUTORELEASEPOOL_BEGIN { \
       id autoreleasePool = FC_MSG_SEND(FC_MSG_SEND(FC_REINTERPRET_CAST(id)(objc_getClass("NSAutoreleasePool")), \
           sel_registerName("alloc")), sel_registerName("init"));
#  define FC_AUTORELEASEPOOL_END \
       FC_MSG_SEND(autoreleasePool, sel_registerName("release")); }
#endif

#ifdef __cplusplus
extern "C"
#else
extern
#endif
id NSSearchPathForDirectoriesInDomains(NSUInteger directory, NSUInteger domainMask,
                                       BOOL expandTilde);

/// *Apple only:* Gets a path using `NSSearchPathForDirectoriesInDomains`
/// - Parameter searchPathDirectory: A `NSSearchPathDirectory`.
static int fc__appledir(NSUInteger searchPathDirectory,
                        const char *app_id, char *path, size_t path_max) {
    const NSUInteger NSUserDomainMask = 1;
    int result = -1;

#if TARGET_OS_OSX
    CFBundleRef bundle = NULL;
    int bundle_id_appended = 0;
#endif

    CFStringRef dir = NULL;
    Boolean success = NO;
    unsigned long length = 0;

    FC_AUTORELEASEPOOL_BEGIN
    CFArrayRef array =
#if __has_feature(objc_arc)
    FC_REINTERPRET_CAST(__bridge CFArrayRef)
#else
    FC_REINTERPRET_CAST(CFArrayRef)
#endif
    (NSSearchPathForDirectoriesInDomains(searchPathDirectory, NSUserDomainMask, TRUE));
    if (!array || CFArrayGetCount(array) == 0) {
        goto fc_datadir_fail;
    }
    dir = FC_REINTERPRET_CAST(CFStringRef)(CFArrayGetValueAtIndex(array, 0));
    success = CFStringGetFileSystemRepresentation(dir, path, FC_STATIC_CAST(CFIndex)(path_max) - 1);
    if (!success) {
        goto fc_datadir_fail;
    }
    length = strlen(path);
    if (length == 0 || length + 1 >= path_max) {
        goto fc_datadir_fail;
    }
    // Add trailing slash
    if (path[length - 1] != FC_DIRECTORY_SEPARATOR) {
        path[length] = FC_DIRECTORY_SEPARATOR;
        path[length + 1] = 0;
        length++;
    }
    if (mkdir(path, 0700) != 0 && errno != EEXIST) {
        goto fc_datadir_fail;
    }
    result = 0;

#if TARGET_OS_OSX
    bundle = CFBundleGetMainBundle();
    if (bundle) {
        CFStringRef bundle_id = CFBundleGetIdentifier(bundle);
        if (bundle_id) {
            if (CFStringFind(dir, bundle_id, 0).length != 0) {
                // macOS sandboxed app
                bundle_id_appended = 1;
            } else {
                // Append bundle_id (macOS bundled, non-sandboxed app)
                CFIndex bundle_id_length = CFStringGetLength(bundle_id);
                bundle_id_length = CFStringGetMaximumSizeForEncoding(bundle_id_length,
                                                                     kCFStringEncodingUTF8);
                if (bundle_id_length > 0 &&
                    length + FC_STATIC_CAST(unsigned long)(bundle_id_length) + 1 < path_max - 1 &&
                    CFStringGetCString(bundle_id, path + length, bundle_id_length,
                                       kCFStringEncodingUTF8)) {
                    path[length + FC_STATIC_CAST(unsigned long)(bundle_id_length)] = FC_DIRECTORY_SEPARATOR;
                    path[length + FC_STATIC_CAST(unsigned long)(bundle_id_length) + 1] = 0;
                    if (mkdir(path, 0700) != 0 && errno != EEXIST) {
                        result = -1;
                        goto fc_datadir_fail;
                    }
                    bundle_id_appended = 1;
                }
            }
        }
    }
    if (!bundle_id_appended) {
        // Append app_id (macOS executable)
        if (!app_id || !*app_id) {
            result = -1;
        } else {
            size_t app_id_length = strlen(app_id);
            if (length + app_id_length + 1 < path_max - 1) {
                strcpy(path + length, app_id);
                path[length + app_id_length] = FC_DIRECTORY_SEPARATOR;
                path[length + app_id_length + 1] = 0;
                if (mkdir(path, 0700) != 0 && errno != EEXIST) {
                    result = -1;
                    goto fc_datadir_fail;
                }
            } else {
                result = -1;
            }
        }
    }
#else
    (void)app_id;
#endif

fc_datadir_fail:
    if (result != 0) {
        path[0] = 0;
    }
    FC_AUTORELEASEPOOL_END
    return result;
}

static int fc_resdir(char *path, size_t path_max) {
    if (!path || path_max == 0) {
        return -1;
    }
    int result = -1;
    FC_AUTORELEASEPOOL_BEGIN
    CFBundleRef bundle = CFBundleGetMainBundle();
    if (bundle) {
        CFURLRef resourcesURL = CFBundleCopyResourcesDirectoryURL(bundle);
        if (resourcesURL) {
            Boolean success = CFURLGetFileSystemRepresentation(resourcesURL, TRUE,
                                                               FC_REINTERPRET_CAST(UInt8 *)(path),
                                                               FC_STATIC_CAST(CFIndex)(path_max) - 1);
            CFRelease(resourcesURL);
            if (success) {
                unsigned long length = strlen(path);
                if (length > 0 && length < path_max - 1) {
                    // Add trailing slash
                    if (path[length - 1] != FC_DIRECTORY_SEPARATOR) {
                        path[length] = FC_DIRECTORY_SEPARATOR;
                        path[length + 1] = 0;
                    }
                    result = 0;
                }
            }
        }
    }
    FC_AUTORELEASEPOOL_END
    if (result != 0) {
        path[0] = 0;
    }
    return result;
}

static int fc_datadir(const char *app_id, char *path, size_t path_max) {
    const NSUInteger NSApplicationSupportDirectory = 14;
    return fc__appledir(NSApplicationSupportDirectory, app_id, path, path_max);
}

static int fc_cachedir(const char *app_id, char *path, size_t path_max) {
    const NSUInteger NSCachesDirectory = 13;
    return fc__appledir(NSCachesDirectory, app_id, path, path_max);
}

static int fc_locale(char *locale, size_t locale_max) {
    if (!locale || locale_max < 3) {
        return -1;
    }
    int result = -1;
    FC_AUTORELEASEPOOL_BEGIN
    CFArrayRef languages = CFLocaleCopyPreferredLanguages();
    if (languages) {
        if (CFArrayGetCount(languages) > 0) {
            CFStringRef language = FC_REINTERPRET_CAST(CFStringRef)(CFArrayGetValueAtIndex(languages, 0));
            if (language) {
                CFIndex length = CFStringGetLength(language);
                if (length > FC_STATIC_CAST(CFIndex)(locale_max) - 1) {
                    length = FC_STATIC_CAST(CFIndex)(locale_max) - 1;
                }
                CFIndex outLength = CFStringGetBytes(language, CFRangeMake(0, length),
                                                     kCFStringEncodingUTF8, 0, FALSE,
                                                     FC_REINTERPRET_CAST(UInt8 *)(locale),
                                                     FC_STATIC_CAST(CFIndex)(locale_max) - 1, NULL);
                locale[outLength] = 0;
                result = 0;
            }
        }
        CFRelease(languages);
    }
    FC_AUTORELEASEPOOL_END
    if (result == 0) {
        fc__locale_clean(locale);
    } else {
        locale[0] = 0;
    }
    return result;
}

#endif // defined(__APPLE__)

// MARK: - Linux

#if defined(__linux__) && !defined(__ANDROID__)

#include <locale.h>
#include <string.h>
#include <unistd.h> // readlink
#include <sys/stat.h> // mkdir

static int fc_resdir(char *path, size_t path_max) {
    if (!path || path_max == 0) {
        return -1;
    }
    ssize_t length = readlink("/proc/self/exe", path, path_max - 1);
    if (length > 0 && FC_STATIC_CAST(size_t)(length) < path_max) {
        for (ssize_t i = length - 1; i > 0; i--) {
            if (path[i] == FC_DIRECTORY_SEPARATOR) {
                path[i + 1] = 0;
                return 0;
            }
        }
    }
    path[0] = 0;
    return -1;
}

static int fc_datadir(const char *app_id, char *path, size_t path_max) {
    return fc__unixdir("XDG_DATA_HOME", ".local/share", app_id, path, path_max);
}

static int fc_cachedir(const char *app_id, char *path, size_t path_max) {
    return fc__unixdir("XDG_CACHE_HOME", ".cache", app_id, path, path_max);
}

static int fc_locale(char *locale, size_t locale_max) {
    if (!locale || locale_max < 3) {
        return -1;
    }
    int result = -1;
    setlocale(LC_ALL, "");
    char *lang = setlocale(LC_ALL, NULL);
    if (lang && lang[0] != 0 && !(lang[0] == 'C' && lang[1] == 0)) {
        result = 0;
        strncpy(locale, lang, locale_max);
        locale[locale_max - 1] = 0;
    }
    if (result == 0) {
        fc__locale_clean(locale);
    } else {
        locale[0] = 0;
    }
    return result;
}

#endif // defined(__unix__)

// MARK: - Windows

#if defined(_WIN32)

#if !defined(WIN32_LEAN_AND_MEAN)
#  define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <Shlobj.h>
#pragma comment(lib, "Shell32.lib")
#pragma comment(lib, "Ole32.lib")
#include <stdlib.h> // wcstombs_s
#if !defined(PATH_MAX)
#  define PATH_MAX MAX_PATH
#endif

/// *Windows only:* Gets a path using `SHGetKnownFolderPath`, and appends `app_id` to it.
static int fc__win32dir(REFKNOWNFOLDERID folder_id,
                        const char *app_id, char *path, size_t path_max) {
    wchar_t *wpath = NULL;
    size_t count = 0; // Output count including NULL
    size_t app_id_length = strlen(app_id);
    int success = (SUCCEEDED(SHGetKnownFolderPath(folder_id, 0, NULL, &wpath)) &&
                   wcstombs_s(&count, path, path_max, wpath, path_max - 1) == 0 &&
                   count > 1 && count + app_id_length + 2 <= path_max);
    CoTaskMemFree(wpath);
    if (!success) {
        path[0] = 0;
        return -1;
    }
    if (path[count - 2] != FC_DIRECTORY_SEPARATOR) {
        path[count - 1] = FC_DIRECTORY_SEPARATOR;
        path[count] = 0;
        count++;
    }
    strcpy_s(path + count - 1, path_max - count, app_id);
    count += app_id_length;
    if (path[count - 2] != FC_DIRECTORY_SEPARATOR) {
        path[count - 1] = FC_DIRECTORY_SEPARATOR;
        path[count] = 0;
    }
    int result = SHCreateDirectoryExA(NULL, path, NULL);
    if (result == ERROR_SUCCESS || result == ERROR_ALREADY_EXISTS) {
        return 0;
    } else {
        path[0] = 0;
        return -1;
    }
}

static int fc_resdir(char *path, size_t path_max) {
    if (!path || path_max == 0) {
        return -1;
    }
    size_t length = FC_STATIC_CAST(size_t)(GetModuleFileNameA(NULL, path, FC_STATIC_CAST(DWORD)(path_max)));
    if (length > 0 && length < path_max) {
        for (size_t i = length - 1; i > 0; i--) {
            if (path[i] == FC_DIRECTORY_SEPARATOR) {
                path[i + 1] = 0;
                return 0;
            }
        }
    }
    path[0] = 0;
    return -1;
}

static int fc_datadir(const char *app_id, char *path, size_t path_max) {
#ifdef __cplusplus
    return fc__win32dir(FOLDERID_RoamingAppData, app_id, path, path_max);
#else
    return fc__win32dir(&FOLDERID_RoamingAppData, app_id, path, path_max);
#endif
}

static int fc_cachedir(const char *app_id, char *path, size_t path_max) {
#ifdef __cplusplus
    return fc__win32dir(FOLDERID_LocalAppData, app_id, path, path_max);
#else
    return fc__win32dir(&FOLDERID_LocalAppData, app_id, path, path_max);
#endif
}

static int fc_locale(char *locale, size_t locale_max) {
    if (!locale || locale_max < 3) {
        return -1;
    }
    int result = -1;
    wchar_t wlocale[LOCALE_NAME_MAX_LENGTH];
    if (GetUserDefaultLocaleName(wlocale, LOCALE_NAME_MAX_LENGTH) > 0) {
        size_t count = 0;
        if (wcstombs_s(&count, locale, locale_max, wlocale, locale_max - 1) == 0) {
            result = 0;
        }
    }
    if (result == 0) {
        fc__locale_clean(locale);
    } else {
        locale[0] = 0;
    }
    return result;
}

static inline FILE *fc__windows_fopen(const char *filename, const char *mode) {
    FILE *file = NULL;
    fopen_s(&file, filename, mode);
    return file;
}

static inline int fc__windows_fclose(FILE *stream) {
    // The Windows fclose() function will crash if stream is NULL
    if (stream) {
        return fclose(stream);
    } else {
        return 0;
    }
}

#define fopen(filename, mode) fc__windows_fopen(filename, mode)
#define fclose(file) fc__windows_fclose(file)

#if defined(_DEBUG)

// Outputs to debug window if there is no console and IsDebuggerPresent() returns true.
static int fc__printf(const char *format, ...) {
    int result;
    if (IsDebuggerPresent() && GetStdHandle(STD_OUTPUT_HANDLE) == NULL) {
        char buffer[1024];
        va_list args;
        va_start(args, format);
        result = vsprintf_s(buffer, sizeof(buffer), format, args);
        va_end(args);
        if (result >= 0) {
            OutputDebugStringA(buffer);
        }
    } else {
        va_list args;
        va_start(args, format);
        result = vprintf(format, args);
        va_end(args);
    }
    return result;
}

#define printf(format, ...) fc__printf(format, __VA_ARGS__)

#endif // _DEBUG

#endif // _WIN32

// MARK: - Android

#if defined(__ANDROID__)

#include <android/asset_manager.h>
#include <android/log.h>
#include <android/native_activity.h>
#include <jni.h>
#include <pthread.h>
#include <string.h>

static JNIEnv *fc__jnienv(JavaVM *vm);

/// *Android Only:* Gets a path from a `Context` method like `getFilesDir` or `getCacheDir`.
static int fc__android_dir(ANativeActivity *activity, const char *method_name,
                           const char *app_id, char *path, size_t path_max) {
    (void)app_id;
    if (!activity) {
        path[0] = 0;
        return -1;
    }
    int result = -1;

#ifdef __cplusplus
    JNIEnv *jniEnv = fc__jnienv(activity->vm);
    if (jniEnv->ExceptionCheck()) {
        jniEnv->ExceptionClear();
    }

    if (jniEnv->PushLocalFrame(16) == JNI_OK) {
        jclass activityClass = jniEnv->GetObjectClass(activity->clazz);
        jmethodID getDirMethod = jniEnv->GetMethodID(activityClass, method_name, "()Ljava/io/File;");
        jobject file = jniEnv->CallObjectMethod(activity->clazz, getDirMethod);
        jclass fileClass = jniEnv->FindClass("java/io/File");
        jmethodID getAbsolutePathMethod = jniEnv->GetMethodID(fileClass, "getAbsolutePath", "()Ljava/lang/String;");
        jstring valueString = reinterpret_cast<jstring>(jniEnv->CallObjectMethod(file, getAbsolutePathMethod));

        const char *nativeString = jniEnv->GetStringUTFChars(valueString, 0);
        if (nativeString) {
            result = 0;
            snprintf(path, path_max, "%s/", nativeString);
            jniEnv->ReleaseStringUTFChars(valueString, nativeString);
        }
        if (jniEnv->ExceptionCheck()) {
            jniEnv->ExceptionClear();
        }
        jniEnv->PopLocalFrame(NULL);
    }
#else
    JNIEnv *jniEnv = fc__jnienv(activity->vm);
    if ((*jniEnv)->ExceptionCheck(jniEnv)) {
        (*jniEnv)->ExceptionClear(jniEnv);
    }
    if ((*jniEnv)->PushLocalFrame(jniEnv, 16) == JNI_OK) {
        jclass activityClass = (*jniEnv)->GetObjectClass(jniEnv, activity->clazz);
        jmethodID getDirMethod = (*jniEnv)->GetMethodID(jniEnv, activityClass, method_name, "()Ljava/io/File;");
        jobject file = (*jniEnv)->CallObjectMethod(jniEnv, activity->clazz, getDirMethod);
        jclass fileClass = (*jniEnv)->FindClass(jniEnv, "java/io/File");
        jmethodID getAbsolutePathMethod = (*jniEnv)->GetMethodID(jniEnv, fileClass, "getAbsolutePath", "()Ljava/lang/String;");
        jstring valueString = (jstring)(*jniEnv)->CallObjectMethod(jniEnv, file, getAbsolutePathMethod);

        const char *nativeString = (*jniEnv)->GetStringUTFChars(jniEnv, valueString, 0);
        if (nativeString) {
            result = 0;
            snprintf(path, path_max, "%s/", nativeString);
            (*jniEnv)->ReleaseStringUTFChars(jniEnv, valueString, nativeString);
        }
        if ((*jniEnv)->ExceptionCheck(jniEnv)) {
            (*jniEnv)->ExceptionClear(jniEnv);
        }
        (*jniEnv)->PopLocalFrame(jniEnv, NULL);
    }
#endif
    if (result != 0) {
        path[0] = 0;
    }
    return result;
}

static int fc__android_locale(ANativeActivity *activity,
                              char *locale, size_t locale_max) {
    if (!locale || locale_max < 3 || !activity) {
        return -1;
    }
    int result = -1;
    // getResources().getConfiguration().locale.toString()
#ifdef __cplusplus
    JNIEnv *jniEnv = fc__jnienv(activity->vm);
    if (jniEnv->ExceptionCheck()) {
        jniEnv->ExceptionClear();
    }

    if (jniEnv->PushLocalFrame(16) == JNI_OK) {
        jclass activityClass = jniEnv->GetObjectClass(activity->clazz);
        jmethodID getResourcesMethod = jniEnv->GetMethodID(activityClass,
                "getResources", "()Landroid/content/res/Resources;");
        jobject resources = jniEnv->CallObjectMethod(activity->clazz, getResourcesMethod);
        jclass resourcesClass = jniEnv->GetObjectClass(resources);
        jmethodID getConfigurationMethod = jniEnv->GetMethodID(resourcesClass,
                "getConfiguration", "()Landroid/content/res/Configuration;");
        jobject configuration = jniEnv->CallObjectMethod(resources, getConfigurationMethod);
        jclass configurationClass = jniEnv->GetObjectClass(configuration);
        jfieldID localeField = jniEnv->GetFieldID(configurationClass, "locale", "Ljava/util/Locale;");
        jobject localeObject = jniEnv->GetObjectField(configuration, localeField);
        jclass localeClass = jniEnv->GetObjectClass(localeObject);
        jmethodID toStringMethod = jniEnv->GetMethodID(localeClass, "toString", "()Ljava/lang/String;");
        jstring valueString = reinterpret_cast<jstring>(jniEnv->CallObjectMethod(localeObject, toStringMethod));

        const char *nativeString = jniEnv->GetStringUTFChars(valueString, 0);
        if (nativeString) {
            result = 0;
            strncpy(locale, nativeString, locale_max);
            locale[locale_max - 1] = 0;
            jniEnv->ReleaseStringUTFChars(valueString, nativeString);
        }
        if (jniEnv->ExceptionCheck()) {
            jniEnv->ExceptionClear();
        }
        jniEnv->PopLocalFrame(NULL);
    }
#else
    JNIEnv *jniEnv = fc__jnienv(activity->vm);
    if ((*jniEnv)->ExceptionCheck(jniEnv)) {
        (*jniEnv)->ExceptionClear(jniEnv);
    }

    if ((*jniEnv)->PushLocalFrame(jniEnv, 16) == JNI_OK) {
        jclass activityClass = (*jniEnv)->GetObjectClass(jniEnv, activity->clazz);
        jmethodID getResourcesMethod = (*jniEnv)->GetMethodID(jniEnv, activityClass,
            "getResources", "()Landroid/content/res/Resources;");
        jobject resources = (*jniEnv)->CallObjectMethod(jniEnv, activity->clazz,
            getResourcesMethod);
        jclass resourcesClass = (*jniEnv)->GetObjectClass(jniEnv, resources);
        jmethodID getConfigurationMethod = (*jniEnv)->GetMethodID(jniEnv, resourcesClass,
            "getConfiguration", "()Landroid/content/res/Configuration;");
        jobject configuration = (*jniEnv)->CallObjectMethod(jniEnv, resources,
            getConfigurationMethod);
        jclass configurationClass = (*jniEnv)->GetObjectClass(jniEnv, configuration);
        jfieldID localeField = (*jniEnv)->GetFieldID(jniEnv, configurationClass, "locale",
            "Ljava/util/Locale;");
        jobject localeObject = (*jniEnv)->GetObjectField(jniEnv, configuration, localeField);
        jclass localeClass = (*jniEnv)->GetObjectClass(jniEnv, localeObject);
        jmethodID toStringMethod = (*jniEnv)->GetMethodID(jniEnv, localeClass, "toString",
            "()Ljava/lang/String;");
        jstring valueString = (*jniEnv)->CallObjectMethod(jniEnv, localeObject, toStringMethod);

        const char *nativeString = (*jniEnv)->GetStringUTFChars(jniEnv, valueString, 0);
        if (nativeString) {
            result = 0;
            strncpy(locale, nativeString, locale_max);
            locale[locale_max - 1] = 0;
            (*jniEnv)->ReleaseStringUTFChars(jniEnv, valueString, nativeString);
        }
        if ((*jniEnv)->ExceptionCheck(jniEnv)) {
            (*jniEnv)->ExceptionClear(jniEnv);
        }
        (*jniEnv)->PopLocalFrame(jniEnv, NULL);
    }
#endif // !defined(__cplusplus)
    if (result == 0) {
        fc__locale_clean(locale);
    } else {
        locale[0] = 0;
    }
    return result;
}

static int fc_resdir(char *path, size_t path_max) {
    if (!path || path_max == 0) {
        return -1;
    }
    path[0] = 0;
    return 0;
}

/// For Android, define `FILE_COMPAT_ANDROID_ACTIVITY` to be a reference to an `ANativeActivity`
/// instance or to a function that returns an `ANativeActivity` instance.
/// For example:
///
///     ANativeActivity *functionThatGetsAndroidActivity(void);
///     #define FILE_COMPAT_ANDROID_ACTIVITY functionThatGetsAndroidActivity()
#define fc__android_activity() FILE_COMPAT_ANDROID_ACTIVITY

#define fc_datadir(app_id, path, path_max) \
    fc__android_dir(fc__android_activity(), "getFilesDir", (app_id), (path), (path_max))

#define fc_cachedir(app_id, path, path_max) \
    fc__android_dir(fc__android_activity(), "getCacheDir", (app_id), (path), (path_max))

#define fc_locale(locale, locale_max) \
    fc__android_locale(fc__android_activity(), (locale), (locale_max))

#if !defined(_BSD_SOURCE)
FILE* funopen(const void* __cookie,
              int (*__read_fn)(void*, char*, int),
              int (*__write_fn)(void*, const char*, int),
              fpos_t (*__seek_fn)(void*, fpos_t, int),
              int (*__close_fn)(void*));
#endif // _BSD_SOURCE

static pthread_key_t fc__jnienv_key;
static pthread_once_t fc__jnienv_key_once = PTHREAD_ONCE_INIT;

static void fc__jnienv_detach(void *value) {
    if (value) {
        JavaVM *vm = FC_REINTERPRET_CAST(JavaVM *)(value);
#ifdef __cplusplus
        vm->DetachCurrentThread();
#else
        (*vm)->DetachCurrentThread(vm);
#endif
    }
}

static void fc__create_jnienv_key() {
    pthread_key_create(&fc__jnienv_key, fc__jnienv_detach);
}

static JNIEnv *fc__jnienv(JavaVM *vm) {
    JNIEnv *jniEnv = NULL;
    int setThreadLocal;
#ifdef __cplusplus
    setThreadLocal = (vm->GetEnv(FC_REINTERPRET_CAST(void **)(&jniEnv), JNI_VERSION_1_4) != JNI_OK &&
            vm->AttachCurrentThread(&jniEnv, NULL) == JNI_OK);
#else
    setThreadLocal = ((*vm)->GetEnv(vm, (void **)&jniEnv, JNI_VERSION_1_4) != JNI_OK &&
            (*vm)->AttachCurrentThread(vm, &jniEnv, NULL) == JNI_OK);
#endif
    if (setThreadLocal) {
        pthread_once(&fc__jnienv_key_once, fc__create_jnienv_key);
        pthread_setspecific(fc__jnienv_key, vm);
    }
    return jniEnv;
}

static int fc__android_read(void *cookie, char *buf, int size) {
    return AAsset_read(FC_REINTERPRET_CAST(AAsset *)(cookie), buf, FC_STATIC_CAST(size_t)(size));
}

static int fc__android_write(void *cookie, const char *buf, int size) {
    (void)cookie;
    (void)buf;
    (void)size;
    errno = EACCES;
    return -1;
}

static fpos_t fc__android_seek(void *cookie, fpos_t offset, int whence) {
    return AAsset_seek(FC_REINTERPRET_CAST(AAsset *)(cookie), offset, whence);
}

static int fc__android_close(void *cookie) {
    AAsset_close(FC_REINTERPRET_CAST(AAsset *)(cookie));
    return 0;
}

static FILE *fc__android_fopen(ANativeActivity *activity, const char *filename, const char *mode) {
    AAssetManager *assetManager = NULL;
    AAsset *asset = NULL;
    if (activity) {
        assetManager = activity->assetManager;
    }
    if (assetManager && mode && mode[0] == 'r') {
        asset = AAssetManager_open(assetManager, filename, AASSET_MODE_UNKNOWN);
    }
    if (asset) {
        return funopen(asset, fc__android_read, fc__android_write, fc__android_seek,
                       fc__android_close);
    } else {
        return fopen(filename, mode);
    }
}

#define printf(...) __android_log_print(ANDROID_LOG_INFO, "stdout", __VA_ARGS__)
#define fopen(filename, mode) fc__android_fopen(fc__android_activity(), (filename), (mode))

#endif // defined(__ANDROID__)

// MARK: - Emscripten

#if defined(__EMSCRIPTEN__)

#include <emscripten/emscripten.h>
#include <string.h>
#include <stdlib.h> // getenv
#if !defined(PATH_MAX)
#  define PATH_MAX 4096
#endif

static int fc_resdir(char *path, size_t path_max) {
    if (!path || path_max == 0) {
        return -1;
    }
    path[0] = 0;
    return 0;
}

static int fc_datadir(const char *app_id, char *path, size_t path_max) {
    return fc__unixdir("XDG_DATA_HOME", ".local/share", app_id, path, path_max);
}

static int fc_cachedir(const char *app_id, char *path, size_t path_max) {
    return fc__unixdir("XDG_CACHE_HOME", ".cache", app_id, path, path_max);
}

static int fc_locale(char *locale, size_t locale_max) {
    if (!locale || locale_max < 3) {
        return -1;
    }
    int result = -1;
    static const char *script =
        "(function() { try {"
        "var lang = navigator.language || navigator.userLanguage || navigator.browserLanguage;"
        "if (typeof lang === 'string') { return lang; } else { return ''; }"
        "} catch(err) { return ''; } }())";

    char *lang = emscripten_run_script_string(script);
    if (lang && lang[0] != 0) {
        result = 0;
        strncpy(locale, lang, locale_max);
        locale[locale_max - 1] = 0;
    }
    if (result == 0) {
        fc__locale_clean(locale);
    } else {
        locale[0] = 0;
    }
    return result;
}

#endif // defined(__EMSCRIPTEN__)

#endif // FILE_COMPAT_H

```

`examples/heightmap.c`:

```c
// Heightmap. Demonstrates use of a depth buffer.
// Rotate: Drag.
// Regenerate: Tap lower half of screen, or Spacebar.
// Switch between wireframe and triangles: Tap upper half of screen, or Tab key.
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "glfm.h"
#if defined(__EMSCRIPTEN__)
#include <emscripten/emscripten.h>
#endif

enum {
    MAP_SIDE_TILE_COUNT = (1 << 5), // Should be a power of 2 for generateHeightmap()
    MAP_SIDE_VERTEX_COUNT = MAP_SIDE_TILE_COUNT + 1,
    MAP_VERTEX_STRIDE = 6, // x, y, z, r, g, b
    MAP_INDEX_COUNT_LINES = MAP_SIDE_TILE_COUNT * MAP_SIDE_VERTEX_COUNT * 4,
    MAP_INDEX_COUNT = MAP_SIDE_TILE_COUNT * MAP_SIDE_TILE_COUNT * 6,
};

static const float MAX_HEIGHT = 1.0f;

typedef struct {
    GLuint program;
    GLuint vertexBuffer;
    GLuint vertexArray;
    GLuint indexBuffer;
    
    GLint modelLocation;
    GLint viewProjLocation;

    bool triangleMode;
    float heightmap[MAP_SIDE_VERTEX_COUNT][MAP_SIDE_VERTEX_COUNT];
    GLfloat vertices[MAP_VERTEX_STRIDE * MAP_SIDE_VERTEX_COUNT * MAP_SIDE_VERTEX_COUNT];
    GLushort indices[MAP_INDEX_COUNT];

    double touchStartTime;
    double lastTouchX;
    double lastTouchY;
    double angleX;
    double angleY;
    float offsetZ;

    bool needsRegeneration;
    bool needsRenderModeChange;
    bool needsRedraw;
} HeightmapApp;

static float randRange(float min, float max) {
#if defined(__EMSCRIPTEN__)
    float p = emscripten_random();
#else
    float p = (float)((double)arc4random() / UINT32_MAX);
#endif
    return p * (max - min) + min;
}

static void heightmapGenerateDiamondSquare(HeightmapApp *app, float range, size_t level) {
    if (level < 2) {
        return;
    }

    // Diamonds
    for (size_t z = level; z < MAP_SIDE_VERTEX_COUNT; z += level) {
        for (size_t x = level; x < MAP_SIDE_VERTEX_COUNT; x += level) {
            float a = app->heightmap[x - level][z - level];
            float b = app->heightmap[x][z - level];
            float c = app->heightmap[x - level][z];
            float d = app->heightmap[x][z];
            float avg = (a + b + c + d) / 4.0f;

            float offset = randRange(-range, range);
            app->heightmap[x - (level + 1) / 2][z - (level + 1) / 2] = avg + offset;
        }
    }

    // Edge (x == 0)
    for (size_t z = level; z < MAP_SIDE_VERTEX_COUNT; z += level) {
        float a = app->heightmap[0][z - level];
        float b = app->heightmap[level/2][z - level/2];
        float c = app->heightmap[0][z];
        float avg = (a + b + c) / 3.0f;

        float offset = randRange(-range, range);
        app->heightmap[0][z - level/2] = avg + offset;
    }

    // Edge (x == MAP_SIDE_TILE_COUNT)
    for (size_t z = level; z < MAP_SIDE_VERTEX_COUNT; z += level) {
        float a = app->heightmap[MAP_SIDE_TILE_COUNT][z - level];
        float b = app->heightmap[MAP_SIDE_TILE_COUNT - level/2][z - level/2];
        float c = app->heightmap[MAP_SIDE_TILE_COUNT][z];
        float avg = (a + b + c) / 3.0f;

        float offset = randRange(-range, range);
        app->heightmap[MAP_SIDE_TILE_COUNT][z - level/2] = avg + offset;
    }

    // Edge (z == 0)
    for (size_t x = level; x < MAP_SIDE_VERTEX_COUNT; x += level) {
        float a = app->heightmap[x - level][0];
        float b = app->heightmap[x - level/2][level/2];
        float c = app->heightmap[x][0];
        float avg = (a + b + c) / 3.0f;

        float offset = randRange(-range, range);
        app->heightmap[x - level/2][0] = avg + offset;
    }

    // Edge (z == MAP_SIDE_TILE_COUNT)
    for (size_t x = level; x < MAP_SIDE_VERTEX_COUNT; x += level) {
        float a = app->heightmap[x - level][MAP_SIDE_TILE_COUNT];
        float b = app->heightmap[x - level/2][MAP_SIDE_TILE_COUNT - level/2];
        float c = app->heightmap[x][MAP_SIDE_TILE_COUNT];
        float avg = (a + b + c) / 3.0f;

        float offset = randRange(-range, range);
        app->heightmap[x - level/2][MAP_SIDE_TILE_COUNT] = avg + offset;
    }

    // Squares (odd x)
    for (size_t z = 3 * level / 2; z < MAP_SIDE_VERTEX_COUNT; z += level) {
        for (size_t x = level; x < MAP_SIDE_VERTEX_COUNT; x += level) {
            float a = app->heightmap[x - level / 2][z - level];
            float b = app->heightmap[x - level][z - level / 2];
            float c = app->heightmap[x - level / 2][z];
            float d = app->heightmap[x][z - level / 2];
            float avg = (a + b + c + d) / 4.0f;

            float offset = randRange(-range, range);
            app->heightmap[x - level / 2][z - level / 2] = avg + offset;
        }
    }

    // Squares (even x)
    for (size_t z = level; z < MAP_SIDE_VERTEX_COUNT; z += level) {
        for (size_t x = 3 * level / 2; x < MAP_SIDE_VERTEX_COUNT; x += level) {
            float a = app->heightmap[x - level / 2][z - level];
            float b = app->heightmap[x - level][z - level / 2];
            float c = app->heightmap[x - level / 2][z];
            float d = app->heightmap[x][z - level / 2];
            float avg = (a + b + c + d) / 4.0f;

            float offset = randRange(-range, range);
            app->heightmap[x - level / 2][z - level / 2] = avg + offset;
        }
    }

    heightmapGenerateDiamondSquare(app, range / 2.0f, level / 2);
}

static void heightmapGenerate(HeightmapApp *app) {
    memset(app->heightmap, 0, sizeof(app->heightmap));

    // Corners
    float maxCorner = MAX_HEIGHT / 8;
    app->heightmap[0][0] = randRange(-maxCorner, maxCorner);
    app->heightmap[0][MAP_SIDE_TILE_COUNT] = randRange(-maxCorner, maxCorner);
    app->heightmap[MAP_SIDE_TILE_COUNT][0] = randRange(-maxCorner, maxCorner);
    app->heightmap[MAP_SIDE_TILE_COUNT][MAP_SIDE_TILE_COUNT] = randRange(-maxCorner, maxCorner);

    // Generate
    heightmapGenerateDiamondSquare(app, MAX_HEIGHT / 2, MAP_SIDE_TILE_COUNT);
}

static bool onTouch(GLFMDisplay *display, int touch, GLFMTouchPhase phase, double x, double y) {
    if (phase == GLFMTouchPhaseHover) {
        return false;
    }
    HeightmapApp *app = glfmGetUserData(display);
    if (phase == GLFMTouchPhaseBegan) {
        app->touchStartTime = glfmGetTime();
    } else {
        int width, height;
        glfmGetDisplaySize(display, &width, &height);
        app->angleX += (x - app->lastTouchX) / height;
        app->angleY += (y - app->lastTouchY) / height;

        if (phase == GLFMTouchPhaseEnded && glfmGetTime() - app->touchStartTime <= 0.2) {
            if (y > height / 2) {
                app->needsRegeneration = true;
            } else {
                app->triangleMode = !app->triangleMode;
                app->needsRenderModeChange = true;
            }
        }
    }
    app->lastTouchX = x;
    app->lastTouchY = y;
    app->needsRedraw = true;
    return true;
}

static bool onKey(GLFMDisplay *display, GLFMKeyCode keyCode, GLFMKeyAction action, int modifiers) {
    HeightmapApp *app = glfmGetUserData(display);
    bool handled = false;
    if (action == GLFMKeyActionPressed || action == GLFMKeyActionRepeated) {
        switch (keyCode) {
            case GLFMKeyCodeArrowLeft:
                app->angleX -= 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeArrowRight:
                app->angleX += 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeArrowUp:
                app->angleY -= 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeArrowDown:
                app->angleY += 0.01f;
                handled = true;
                break;
            default:
                break;
        }
    }
    if (action == GLFMKeyActionPressed) {
        switch (keyCode) {
            case GLFMKeyCodeTab:
                app->triangleMode = !app->triangleMode;
                app->needsRenderModeChange = true;
                handled = true;
                break;
            case GLFMKeyCodeSpace:
                app->needsRegeneration = true;
                handled = true;
                break;
            case GLFMKeyCodeEscape:
                app->angleX = 0.0f;
                app->angleY = 0.0f;
                app->offsetZ = 0.0f;
                handled = true;
                break;
            default:
                break;
        }
    }
    app->needsRedraw |= handled;
    return handled;
}

static bool onScroll(GLFMDisplay *display, double x, double y, GLFMMouseWheelDeltaType deltaType,
                     double deltaX, double deltaY, double deltaZ) {
    HeightmapApp *app = glfmGetUserData(display);
    int width, height;
    glfmGetDisplaySize(display, &width, &height);
    if (deltaType != GLFMMouseWheelDeltaPixel) {
        deltaX *= 20;
        deltaY *= 20;
    }
    app->angleX -= deltaX / height;
    app->offsetZ -= deltaY / 20;
    app->needsRedraw = true;
    return true;
}

static void onSurfaceCreated(GLFMDisplay *display, int width, int height) {
    GLFMRenderingAPI api = glfmGetRenderingAPI(display);
    printf("Hello from GLFM! Using OpenGL %s\n",
           api == GLFMRenderingAPIOpenGLES32 ? "ES 3.2" :
           api == GLFMRenderingAPIOpenGLES31 ? "ES 3.1" :
           api == GLFMRenderingAPIOpenGLES3 ? "ES 3.0" : "ES 2.0");
}

static void onSurfaceRefresh(GLFMDisplay *display) {
    HeightmapApp *app = glfmGetUserData(display);
    app->needsRedraw = true;
}

static void onSurfaceDestroyed(GLFMDisplay *display) {
    // When the surface is destroyed, all existing GL resources are no longer valid.
    HeightmapApp *app = glfmGetUserData(display);
    app->program = 0;
    app->vertexBuffer = 0;
    app->vertexArray = 0;
    app->indexBuffer = 0;
    printf("Goodbye\n");
}

static GLuint compileShader(GLenum type, const GLchar *shaderSource) {
    // Compile
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &shaderSource, NULL);
    glCompileShader(shader);

    // Check compile status
    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
    if (status == 0) {
        printf("Shader compile error\n");
        GLint logLength;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLength);
        if (logLength > 0) {
            GLchar *log = malloc(logLength);
            glGetShaderInfoLog(shader, logLength, &logLength, log);
            if (log[0] != 0) {
                printf("%s\n", log);
            }
            free(log);
        }
        glDeleteShader(shader);
        shader = 0;
    }
    return shader;
}

static void draw(HeightmapApp *app, int width, int height) {
    // Create shader
    if (app->program == 0) {
        const GLchar vertexShader[] =
            "#version 100\n"
            "uniform mat4 model;\n"
            "uniform mat4 viewProj;\n"
            "attribute highp vec3 a_position;\n"
            "attribute lowp vec3 a_color;\n"
            "varying lowp vec4 v_color;\n"
            "void main() {\n"
            "   gl_Position = (viewProj * model) * vec4(a_position, 1.0);\n"
            "   v_color = vec4(a_color, 1.0);\n"
            "}";

        const GLchar fragmentShader[] =
            "#version 100\n"
            "varying lowp vec4 v_color;\n"
            "void main() {\n"
            "  gl_FragColor = v_color;\n"
            "}";

        GLuint vertShader = compileShader(GL_VERTEX_SHADER, vertexShader);
        GLuint fragShader = compileShader(GL_FRAGMENT_SHADER, fragmentShader);
        if (vertShader == 0 || fragShader == 0) {
            return;
        }
        app->program = glCreateProgram();

        glAttachShader(app->program, vertShader);
        glAttachShader(app->program, fragShader);

        glBindAttribLocation(app->program, 0, "a_position");
        glBindAttribLocation(app->program, 1, "a_color");

        glLinkProgram(app->program);

        glDeleteShader(vertShader);
        glDeleteShader(fragShader);

        app->modelLocation = glGetUniformLocation(app->program, "model");
        app->viewProjLocation = glGetUniformLocation(app->program, "viewProj");
    }

    // Fill vertex and index buffers
    if (app->needsRegeneration || app->vertexBuffer == 0) {
        heightmapGenerate(app);
    }
    if (app->needsRegeneration || app->needsRenderModeChange || app->vertexBuffer == 0 || app->indexBuffer == 0) {
        // Generate vertices
        size_t i = 0;
        for (size_t z = 0; z < MAP_SIDE_VERTEX_COUNT; z++) {
            for (size_t x = 0; x < MAP_SIDE_VERTEX_COUNT; x++) {
                float y = app->heightmap[x][z];
                float color = app->triangleMode ? (y + MAX_HEIGHT) / (2.0f * MAX_HEIGHT) : 1.0f;
                app->vertices[i + 0] = 2.0f * (float)x / (float)MAP_SIDE_TILE_COUNT - 1.0f;
                app->vertices[i + 1] = y;
                app->vertices[i + 2] = 2.0f * (float)z / (float)MAP_SIDE_TILE_COUNT - 1.0f;
                app->vertices[i + 3] = color;
                app->vertices[i + 4] = color;
                app->vertices[i + 5] = color;
                i += 6;
            }
        }
        if (app->vertexBuffer == 0) {
            glGenBuffers(1, &app->vertexBuffer);
        }
        glBindBuffer(GL_ARRAY_BUFFER, app->vertexBuffer);
        glBufferData(GL_ARRAY_BUFFER, sizeof(app->vertices), app->vertices, GL_STATIC_DRAW);

        // Generate index buffer
        if (app->indexBuffer == 0) {
            glGenBuffers(1, &app->indexBuffer);
        }
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, app->indexBuffer);
        if (app->triangleMode) {
            size_t i = 0;
            for (GLuint z = 0; z < MAP_SIDE_TILE_COUNT; z++) {
                GLuint index = z * MAP_SIDE_VERTEX_COUNT;
                for (GLuint x = 0; x < MAP_SIDE_TILE_COUNT; x++) {
                    app->indices[i++] = index + 0;
                    app->indices[i++] = index + 1;
                    app->indices[i++] = index + 1 + MAP_SIDE_VERTEX_COUNT;
                    app->indices[i++] = index + 0;
                    app->indices[i++] = index + 1 + MAP_SIDE_VERTEX_COUNT;
                    app->indices[i++] = index + 0 + MAP_SIDE_VERTEX_COUNT;
                    index++;
                }
            }
            assert(i == MAP_INDEX_COUNT);
            glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(app->indices[0]) * MAP_INDEX_COUNT, app->indices, GL_STATIC_DRAW);
        } else { // line mode
            size_t i = 0;
            for (GLuint z = 0; z < MAP_SIDE_TILE_COUNT; z++) {
                GLuint index = z * MAP_SIDE_VERTEX_COUNT;
                for (GLuint x = 0; x < MAP_SIDE_TILE_COUNT; x++) {
                    app->indices[i++] = index + x;
                    app->indices[i++] = index + x + 1;
                    app->indices[i++] = index + x;
                    app->indices[i++] = index + x + MAP_SIDE_VERTEX_COUNT;
                }
                app->indices[i++] = index + MAP_SIDE_TILE_COUNT;
                app->indices[i++] = index + MAP_SIDE_TILE_COUNT + MAP_SIDE_VERTEX_COUNT;
            }
            GLuint index = MAP_SIDE_TILE_COUNT * MAP_SIDE_VERTEX_COUNT;
            for (GLuint z = 0; z < MAP_SIDE_TILE_COUNT; z++) {
                app->indices[i++] = index + z;
                app->indices[i++] = index + z + 1;
            }
            assert(i == MAP_INDEX_COUNT_LINES);
            glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(app->indices[0]) * MAP_INDEX_COUNT_LINES, app->indices, GL_STATIC_DRAW);
        }
    }
    app->needsRenderModeChange = false;
    app->needsRegeneration = false;

    // Upload matrices
    float rx, ry;
    if (height > width) {
        rx = (float)height / (float)width;
        ry = 1.0f;
    } else {
        rx = 1.0f;
        ry = (float)width / (float)height;
    }
    float cx = cosf(app->angleY * -2 * M_PI - M_PI / 4);
    float sx = sinf(app->angleY * -2 * M_PI - M_PI / 4);
    float cy = cosf(app->angleX * -2 * M_PI - M_PI / 8);
    float sy = sinf(app->angleX * -2 * M_PI - M_PI / 8);
    float z = app->offsetZ - 2.0f;

    const GLfloat model[16] = {
           cy, sx*sy, cx*sy,  0.0f,
         0.0f,    cx,   -sx,  0.0f,
          -sy, sx*cy, cx*cy,  0.0f,
         0.0f,  0.0f,     z,  1.0f,
    };

    const GLfloat viewProj[16] = {
           rx,  0.0f,  0.0f,  0.0f,
         0.0f,    ry,  0.0f,  0.0f,
         0.0f,  0.0f, -1.0f, -1.0f,
         0.0f,  0.0f,  0.00,  1.0f,
    };

    glUseProgram(app->program);
    glUniformMatrix4fv(app->modelLocation, 1, GL_FALSE, model);
    glUniformMatrix4fv(app->viewProjLocation, 1, GL_FALSE, viewProj);

    // Draw background
    glViewport(0, 0, width, height);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // Draw heightmap
    glEnable(GL_DEPTH_TEST);
#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    if (app->vertexArray == 0) {
        glGenVertexArrays(1, &app->vertexArray);
    }
    glBindVertexArray(app->vertexArray);
#endif
    glBindBuffer(GL_ARRAY_BUFFER, app->vertexBuffer);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * MAP_VERTEX_STRIDE, (void *)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * MAP_VERTEX_STRIDE, (void *)(sizeof(GLfloat) * 3));

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, app->indexBuffer);
    if (app->triangleMode) {
        glDrawElements(GL_TRIANGLES, MAP_INDEX_COUNT, GL_UNSIGNED_SHORT, (void *)0);
    } else {
        glDrawElements(GL_LINES, MAP_INDEX_COUNT_LINES, GL_UNSIGNED_SHORT, (void *)0);
    }
}

static void onDraw(GLFMDisplay *display) {
    HeightmapApp *app = glfmGetUserData(display);
    if (app->needsRedraw) {
        app->needsRedraw = false;

        int width, height;
        glfmGetDisplaySize(display, &width, &height);
        draw(app, width,  height);
        glfmSwapBuffers(display);
    }
}

void glfmMain(GLFMDisplay *display) {
    HeightmapApp *app = calloc(1, sizeof(HeightmapApp));
    glfmSetDisplayConfig(display,
                         GLFMRenderingAPIOpenGLES2,
                         GLFMColorFormatRGBA8888,
                         GLFMDepthFormat16, // For DEPTH_TEST
                         GLFMStencilFormatNone,
                         GLFMMultisampleNone);
    glfmSetUserData(display, app);
    glfmSetSurfaceCreatedFunc(display, onSurfaceCreated);
    glfmSetSurfaceRefreshFunc(display, onSurfaceRefresh);
    glfmSetSurfaceDestroyedFunc(display, onSurfaceDestroyed);
    glfmSetRenderFunc(display, onDraw);
    glfmSetTouchFunc(display, onTouch);
    glfmSetKeyFunc(display, onKey);
    glfmSetMouseWheelFunc(display, onScroll);
}

```

`examples/icons/gen_icns.sh`:

```sh
#/bin/bash
# This script generates an icns file (for iOS and macOS) from a png file.
# Requires macOS (sips and iconutil)

if [ -z "$1" || -z $2 ]; then
    echo "Usage: $0 <icon_name> <output_dir>"
    exit 1
fi

if ! [ -f "$1.png" ]; then
    echo "Error: $1.png does not exist"
    exit 2
fi

mkdir -p $1.iconset
mkdir -p $2

sips -z 16 16     $1.png --out $1.iconset/icon_16x16.png
sips -z 32 32     $1.png --out $1.iconset/icon_16x16@2x.png
sips -z 32 32     $1.png --out $1.iconset/icon_32x32.png
sips -z 64 64     $1.png --out $1.iconset/icon_32x32@2x.png
sips -z 128 128   $1.png --out $1.iconset/icon_128x128.png
sips -z 256 256   $1.png --out $1.iconset/icon_128x128@2x.png
sips -z 256 256   $1.png --out $1.iconset/icon_256x256.png
sips -z 512 512   $1.png --out $1.iconset/icon_256x256@2x.png
sips -z 512 512   $1.png --out $1.iconset/icon_512x512.png
sips -z 1024 1024 $1.png --out $1.iconset/icon_512x512@2x.png

iconutil -c icns --output $2/$1.icns $1.iconset
rm -R $1.iconset

```

`examples/index.html.in`:

```in
<!DOCTYPE html>
<!-- Template for Emscripten examples -->
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>GLFM Examples</title>
    <style type="text/css">
        body {
            background-color: #000; color: #fff; margin: 30px auto; padding: 0 10px; max-width: 640px;
            font-size: 12pt; line-height: 1.4; font-family: -apple-system, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
        }
        h1, h2, h3 { line-height: 1.2; text-align: center; }

        a:link { color: #fff; text-decoration: none; }
        a:hover { color: #66f; }
        a:visited { color: #fff; }
        a:visited:hover { color: #66f; }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, 160px);
            grid-row-gap: 40px;
            justify-content: center;
        }
        figure { margin: 0; text-align: center; }
        figure img { width: 128px; height: 128px; }
    </style>
</head>
<body>
    <h1>GLFM Examples</h1>

    <div class="grid">
<!-- #figure -->
    </div>
</body>
</html>

```

`examples/shader_toy.c`:

```c
// Draws a shader similar to shadertoy.com

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "glfm.h"
#include "file_compat.h"

#define FILE_COMPAT_ANDROID_ACTIVITY glfmGetAndroidActivity(display)

typedef struct {
    GLuint program;
    GLuint vertexBuffer;
    GLuint vertexArray;
    GLint uniformTime;
    GLint uniformResolution;
    double startTime;
    double pausedTime;
    int resolution[2];
} ShaderToyApp;

static GLuint compileShader(GLFMDisplay *display, GLenum type, const char *shaderName) {
    char fullPath[PATH_MAX];
    fc_resdir(fullPath, sizeof(fullPath));
    strncat(fullPath, shaderName, sizeof(fullPath) - strlen(fullPath) - 1);

    // Get shader string
    char *shaderString = NULL;
    FILE *shaderFile = fopen(fullPath, "rb");
    if (shaderFile) {
        fseek(shaderFile, 0, SEEK_END);
        size_t length = (size_t)ftell(shaderFile);
        fseek(shaderFile, 0, SEEK_SET);

        shaderString = malloc(length + 1);
        if (shaderString) {
            fread(shaderString, length, 1, shaderFile);
            shaderString[length] = 0;
        }
        fclose(shaderFile);
    }
    if (!shaderString) {
        printf("Couldn't read file: %s\n", fullPath);
        return 0;
    }

    // Compile
    const char *constShaderString = shaderString;
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &constShaderString, NULL);
    glCompileShader(shader);
    free(shaderString);

    // Check compile status
    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
    if (status == 0) {
        printf("Couldn't compile shader: %s\n", shaderName);
        GLint logLength;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLength);
        if (logLength > 0) {
            GLchar *log = malloc((size_t)logLength);
            glGetShaderInfoLog(shader, logLength, &logLength, log);
            if (log[0] != 0) {
                printf("Shader log: %s\n", log);
            }
            free(log);
        }
        glDeleteShader(shader);
        shader = 0;
    }
    return shader;
}

static void onSurfaceCreated(GLFMDisplay *display, int width, int height) {
    ShaderToyApp *app = glfmGetUserData(display);
    
    GLuint vertShader = compileShader(display, GL_VERTEX_SHADER, "shader_toy.vert");
    GLuint fragShader = compileShader(display, GL_FRAGMENT_SHADER, "shader_toy.frag");
    if (vertShader != 0 && fragShader != 0) {
        app->program = glCreateProgram();
        
        glAttachShader(app->program, vertShader);
        glAttachShader(app->program, fragShader);
        
        glBindAttribLocation(app->program, 0, "position");
        
        glLinkProgram(app->program);
        
        glDeleteShader(vertShader);
        glDeleteShader(fragShader);
        
        app->uniformTime = glGetUniformLocation(app->program, "iTime");
        app->uniformResolution = glGetUniformLocation(app->program, "iResolution");
    }
    
    glGenBuffers(1, &app->vertexBuffer);
    
#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    glGenVertexArrays(1, &app->vertexArray);
#endif
}

static void onSurfaceDestroyed(GLFMDisplay *display) {
    ShaderToyApp *app = glfmGetUserData(display);
    app->program = 0;
    app->vertexBuffer = 0;
    app->vertexArray = 0;
    app->resolution[0] = 0;
    app->resolution[1] = 0;
}

static void onFocus(GLFMDisplay *display, bool focused) {
    ShaderToyApp *app = glfmGetUserData(display);
    if (focused) {
        if (app->pausedTime > 0.0) {
            app->startTime += glfmGetTime() - app->pausedTime;
            app->pausedTime = 0.0;
        }
    } else {
        app->pausedTime = glfmGetTime();
    }
}

static void onDraw(GLFMDisplay *display) {
    ShaderToyApp *app = glfmGetUserData(display);
    
    int width, height;
    glfmGetDisplaySize(display, &width, &height);
    
    // Clear
    glViewport(0, 0, width, height);
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // Set iTime
    glUseProgram(app->program);
    if (app->uniformTime >= 0) {
        double time = glfmGetTime();
        if (app->startTime <= 0.0) {
            app->startTime = time;
            time = 0.0;
        } else {
            time -= app->startTime;
        }
        glUniform1f(app->uniformTime, time);
    }
    
    // Set iResolution
    if (app->uniformResolution >= 0 && (width != app->resolution[0] || height != app->resolution[1])) {
        app->resolution[0] = width;
        app->resolution[1] = height;
        glUniform3f(app->uniformResolution, (GLfloat)width, (GLfloat)height, 1.0f);
    }

    // Set vertices
    const float vertices[] = {
        -1, -1,
        +1, -1,
        -1, +1,
        +1, +1
    };
#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    glBindVertexArray(app->vertexArray);
#endif
    glBindBuffer(GL_ARRAY_BUFFER, app->vertexBuffer);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_DYNAMIC_DRAW);
    
    // Draw
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    glfmSwapBuffers(display);
}

void glfmMain(GLFMDisplay *display) {
    ShaderToyApp *app = calloc(1, sizeof(ShaderToyApp));

    glfmSetDisplayConfig(display,
                         GLFMRenderingAPIOpenGLES2,
                         GLFMColorFormatRGBA8888,
                         GLFMDepthFormatNone,
                         GLFMStencilFormatNone,
                         GLFMMultisampleNone);

    glfmSetUserData(display, app);
    glfmSetDisplayChrome(display, GLFMUserInterfaceChromeNone);
    glfmSetSurfaceCreatedFunc(display, onSurfaceCreated);
    glfmSetSurfaceDestroyedFunc(display, onSurfaceDestroyed);
    glfmSetAppFocusFunc(display, onFocus);
    glfmSetRenderFunc(display, onDraw);
}

```

`examples/test_pattern.c`:

```c
// Draws a test pattern to check if framebuffer is scaled correctly.
// Tap to modify interface chrome (navigation bar, status bar, etc)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "glfm.h"
#include "test_pattern_renderer.h"
#include "file_compat.h"

#define FILE_COMPAT_ANDROID_ACTIVITY glfmGetAndroidActivity(display)

typedef struct {
    Renderer *renderer;
    Texture texture;
    bool textureNeedsUpdate;
    bool needsRedraw;
} TestPatternApp;

static Texture createTestPatternTexture(GLFMDisplay *display, uint32_t width, uint32_t height) {
    double top, right, bottom, left;
    glfmGetDisplayChromeInsets(display, &top, &right, &bottom, &left);

    static const uint32_t maxBorderSize = 1;
    static const uint32_t borderColor = 0xff0000ff;
    static const uint32_t insetColor = 0xffff3322;

    uint32_t borderSize = maxBorderSize;
    if (borderSize * 2 > width) {
        borderSize = width / 2;
    }
    if (borderSize * 2 > height) {
        borderSize = height / 2;
    }

    TestPatternApp *app = glfmGetUserData(display);
    Texture texture = 0;
    uint32_t *data = malloc(width * height * sizeof(uint32_t));
    if (data) {
        uint32_t *out = data;
        for (uint32_t y = 0; y < height; y++) {
            for (int i = 0; i < borderSize; i++) {
                *out++ = borderColor;
            }
            if (y < borderSize || y >= height - borderSize) {
                for (uint32_t x = borderSize; x < width - borderSize; x++) {
                    *out++ = borderColor;
                }
            } else if (y < bottom || y >= height - top) {
                for (uint32_t x = borderSize; x < width - borderSize; x++) {
                    *out++ = insetColor;
                }
            } else {
                uint32_t x = borderSize;
                while (x < left) {
                    *out++ = insetColor;
                    x++;
                }
                while (x < width - right - borderSize) {
                    *out++ = ((x & 1U) == (y & 1U)) ? 0xff000000 : 0xffffffff;
                    x++;
                }

                while (x < width - borderSize) {
                    *out++ = insetColor;
                    x++;
                }
            }
            for (int i = 0; i < borderSize; i++) {
                *out++ = borderColor;
            }
        }

        texture = app->renderer->textureUpload(app->renderer, width, height, (uint8_t *)data);
        free(data);
    }
    if (texture != 0) {
        printf("Created test pattern %ix%i with insets %i, %i, %i, %i\n", width, height,
               (int)top, (int)right, (int)bottom, (int)left);
    }
    return texture;
}

static void onSurfaceCreated(GLFMDisplay *display, int width, int height) {
    TestPatternApp *app = glfmGetUserData(display);
#if defined(__APPLE__)
    if (glfmGetRenderingAPI(display) == GLFMRenderingAPIMetal) {
        app->renderer = createRendererMetal(display);
        printf("Hello from Metal!\n");
    }
#endif
    if (!app->renderer) {
        app->renderer = createRendererGLES2(display);
        printf("Hello from GLES2!\n");
    }
    app->textureNeedsUpdate = true;
    app->needsRedraw = true;
}

static void onSurfaceResized(GLFMDisplay *display, int width, int height) {
    TestPatternApp *app = glfmGetUserData(display);
    app->textureNeedsUpdate = true;
}

static void onSurfaceRefresh(GLFMDisplay *display) {
    TestPatternApp *app = glfmGetUserData(display);
    app->needsRedraw = true;
}

static void onOrientationChange(GLFMDisplay *display, GLFMInterfaceOrientation orientation) {
    TestPatternApp *app = glfmGetUserData(display);
    app->textureNeedsUpdate = true;
}

static void onInsetsChange(GLFMDisplay *display, double top, double right, double bottom, double left) {
    TestPatternApp *app = glfmGetUserData(display);
    app->textureNeedsUpdate = true;
}

static void onSurfaceDestroyed(GLFMDisplay *display) {
    // When the surface is destroyed, all existing GL resources are no longer valid.
    TestPatternApp *app = glfmGetUserData(display);
    app->renderer->textureDestroy(app->renderer, app->texture);
    app->renderer->destroy(app->renderer);
    app->renderer = NULL;
}

static bool onTouch(GLFMDisplay *display, int touch, GLFMTouchPhase phase, double x, double y) {
    if (phase == GLFMTouchPhaseBegan) {
        char *chromeString = NULL;
        GLFMUserInterfaceChrome chrome = glfmGetDisplayChrome(display);
        switch (chrome) {
            case GLFMUserInterfaceChromeNavigation:
                chromeString = "Navigation+StatusBar";
                glfmSetDisplayChrome(display, GLFMUserInterfaceChromeNavigationAndStatusBar);
                break;
            case GLFMUserInterfaceChromeNavigationAndStatusBar:
                chromeString = "None";
                glfmSetDisplayChrome(display, GLFMUserInterfaceChromeNone);
                break;
            case GLFMUserInterfaceChromeNone: default:
                chromeString = "Navigation";
                glfmSetDisplayChrome(display, GLFMUserInterfaceChromeNavigation);
                break;
        }
        glfmPerformHapticFeedback(display, GLFMHapticFeedbackLight);
        printf("Chrome set to: %s\n", chromeString);
        return true;
    } else {
        return false;
    }
}

static void onDraw(GLFMDisplay *display) {
    TestPatternApp *app = glfmGetUserData(display);
    if (!app->textureNeedsUpdate && !app->needsRedraw) {
        return;
    }
    
    int width, height;
    glfmGetDisplaySize(display, &width, &height);

    if (app->textureNeedsUpdate && app->texture != NULL_TEXTURE) {
        app->renderer->textureDestroy(app->renderer, app->texture);
        app->texture = NULL_TEXTURE;
    }
    if (app->texture == NULL_TEXTURE) {
        app->texture = createTestPatternTexture(display, width, height);
        app->textureNeedsUpdate = false;
    }

    app->renderer->drawFrameStart(app->renderer, width, height);
    
    const Vertex vertices[4] = {
        { .position = { -1, -1 }, .texCoord = { 0, 0 } },
        { .position = {  1, -1 }, .texCoord = { 1, 0 } },
        { .position = { -1,  1 }, .texCoord = { 0, 1 } },
        { .position = {  1,  1 }, .texCoord = { 1, 1 } },
    };
    
    app->renderer->drawQuad(app->renderer, app->texture, &vertices);
    app->renderer->drawFrameEnd(app->renderer);
    glfmSwapBuffers(display);
    app->needsRedraw = false;
}

void glfmMain(GLFMDisplay *display) {
    TestPatternApp *app = calloc(1, sizeof(TestPatternApp));

    GLFMRenderingAPI renderingAPI = glfmIsMetalSupported(display) ? GLFMRenderingAPIMetal : GLFMRenderingAPIOpenGLES2;
    glfmSetDisplayConfig(display,
                         renderingAPI,
                         GLFMColorFormatRGBA8888,
                         GLFMDepthFormatNone,
                         GLFMStencilFormatNone,
                         GLFMMultisampleNone);

    glfmSetUserData(display, app);
    glfmSetDisplayChrome(display, GLFMUserInterfaceChromeNavigationAndStatusBar);
    glfmSetTouchFunc(display, onTouch);
    glfmSetSurfaceCreatedFunc(display, onSurfaceCreated);
    glfmSetSurfaceResizedFunc(display, onSurfaceResized);
    glfmSetSurfaceRefreshFunc(display, onSurfaceRefresh);
    glfmSetSurfaceDestroyedFunc(display, onSurfaceDestroyed);
    glfmSetOrientationChangedFunc(display, onOrientationChange);
    glfmSetDisplayChromeInsetsChangedFunc(display, onInsetsChange);
    glfmSetRenderFunc(display, onDraw);
}

```

`examples/test_pattern_renderer.h`:

```h
#ifndef TEST_PATTERN_RENDERER_H
#define TEST_PATTERN_RENDERER_H

#include <stdint.h>
#include "glfm.h"

typedef struct Renderer Renderer;
typedef uintptr_t Texture;
#define NULL_TEXTURE (0)

typedef struct {
    float position[2];
    float texCoord[2];
} Vertex;

struct Renderer {
    Texture (*textureUpload)(Renderer *renderer, uint32_t width, uint32_t height, uint8_t *data);
    void (*textureDestroy)(Renderer *renderer, Texture texture);
    void (*drawFrameStart)(Renderer *renderer, int screenWidth, int screenHeight);
    void (*drawFrameEnd)(Renderer *renderer);
    void (*drawQuad)(Renderer *renderer, Texture texture, const Vertex (*vertices)[4]);
    void (*destroy)(Renderer *renderer);
};

Renderer *createRendererGLES2(GLFMDisplay *display);

#if defined(__APPLE__)
Renderer *createRendererMetal(GLFMDisplay *display);
#endif

#endif

```

`examples/test_pattern_renderer.metal`:

```metal
#include <metal_stdlib>

using namespace metal;

// NOTE: Same Vertex struct in test_pattern_renderer
typedef struct {
    float2 position;
    float2 texCoord;
} VertexIn;

typedef struct {
    float4 position [[position]];
    float2 texCoord;
} VertexOut;

vertex VertexOut textureVertexShader(uint index [[vertex_id]],
                                     constant VertexIn *vertices [[buffer(0)]]) {
    VertexOut out;
    out.position = float4(vertices[index].position, 0, 1);
    out.texCoord = vertices[index].texCoord;
    return out;
}

fragment half4 textureFragmentShader(VertexOut in [[stage_in]],
                                     texture2d<half> texture [[texture(0)]],
                                     sampler textureSampler [[sampler(0)]]) {
    return texture.sample(textureSampler, in.texCoord);
}

```

`examples/test_pattern_renderer_gles2.c`:

```c
#include "test_pattern_renderer.h"

#include <stdlib.h>
#include <stddef.h>
#include "file_compat.h"

#define FILE_COMPAT_ANDROID_ACTIVITY glfmGetAndroidActivity(display)

typedef struct {
    Renderer renderer;
    GLuint textureProgram;
    GLuint textureVertexBuffer;
    GLuint textureVertexArray;
} RendererGLES2;

#define impl_of(this_renderer) ((RendererGLES2 *)(void *)((uint8_t *)this_renderer - offsetof(RendererGLES2, renderer)))

static Texture textureUpload(Renderer *renderer, uint32_t width, uint32_t height, uint8_t *data) {
    GLuint textureId = 0;
    glGenTextures(1, &textureId);
    glBindTexture(GL_TEXTURE_2D, textureId);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    return textureId;
}

static void textureDestroy(Renderer *renderer, Texture texture) {
    if (texture != NULL_TEXTURE) {
        GLuint textureId = (GLuint)texture;
        glDeleteTextures(1, &textureId);
    }
}

static void drawFrameStart(Renderer *renderer, int screenWidth, int screenHeight) {
    glViewport(0, 0, screenWidth, screenHeight);
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
    glClear(GL_COLOR_BUFFER_BIT);
}

static void drawFrameEnd(Renderer *renderer) {
    // Do nothing
}

static void drawQuad(Renderer *renderer, Texture texture, const Vertex (*vertices)[4]) {
    // NOTE: This function draws one quad at a time, which is slow. Don't use in production.
    RendererGLES2 *impl = impl_of(renderer);
    glUseProgram(impl->textureProgram);

#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    glBindVertexArray(impl->textureVertexArray);
#endif

    glBindBuffer(GL_ARRAY_BUFFER, impl->textureVertexBuffer);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, position));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, texCoord));
    
    GLuint textureId = (GLuint)texture;
    glBufferData(GL_ARRAY_BUFFER, sizeof(*vertices), vertices, GL_DYNAMIC_DRAW);
    glBindTexture(GL_TEXTURE_2D, textureId);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
}

static void destroy(Renderer *renderer) {
    RendererGLES2 *impl = impl_of(renderer);
    free(impl);
}

static GLuint compileShader(GLFMDisplay *display, GLenum type, const char *shaderName) {
    char fullPath[PATH_MAX];
    fc_resdir(fullPath, sizeof(fullPath));
    strncat(fullPath, shaderName, sizeof(fullPath) - strlen(fullPath) - 1);

    // Get shader string
    char *shaderString = NULL;
    FILE *shaderFile = fopen(fullPath, "rb");
    if (shaderFile) {
        fseek(shaderFile, 0, SEEK_END);
        size_t length = (size_t)ftell(shaderFile);
        fseek(shaderFile, 0, SEEK_SET);

        shaderString = malloc(length + 1);
        if (shaderString) {
            fread(shaderString, length, 1, shaderFile);
            shaderString[length] = 0;
        }
        fclose(shaderFile);
    }
    if (!shaderString) {
        printf("Couldn't read file: %s\n", fullPath);
        return 0;
    }

    // Compile
    const char *constShaderString = shaderString;
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &constShaderString, NULL);
    glCompileShader(shader);
    free(shaderString);

    // Check compile status
    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
    if (status == 0) {
        printf("Couldn't compile shader: %s\n", shaderName);
        GLint logLength;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLength);
        if (logLength > 0) {
            GLchar *log = malloc((size_t)logLength);
            glGetShaderInfoLog(shader, logLength, &logLength, log);
            if (log[0] != 0) {
                printf("Shader log: %s\n", log);
            }
            free(log);
        }
        glDeleteShader(shader);
        shader = 0;
    }
    return shader;
}

Renderer *createRendererGLES2(GLFMDisplay *display) {
    RendererGLES2 *impl = calloc(1, sizeof(RendererGLES2));
    
    GLuint vertShader = compileShader(display, GL_VERTEX_SHADER, "texture.vert");
    GLuint fragShader = compileShader(display, GL_FRAGMENT_SHADER, "texture.frag");
    if (vertShader != 0 && fragShader != 0) {
        impl->textureProgram = glCreateProgram();
        
        glAttachShader(impl->textureProgram, vertShader);
        glAttachShader(impl->textureProgram, fragShader);
        
        glBindAttribLocation(impl->textureProgram, 0, "position");
        glBindAttribLocation(impl->textureProgram, 1, "texCoord");
        
        glLinkProgram(impl->textureProgram);
        
        glDeleteShader(vertShader);
        glDeleteShader(fragShader);
    }
    
    glGenBuffers(1, &impl->textureVertexBuffer);
    
#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    glGenVertexArrays(1, &impl->textureVertexArray);
#endif
    
    Renderer *renderer = &impl->renderer;
    renderer->textureUpload = textureUpload;
    renderer->textureDestroy = textureDestroy;
    renderer->drawFrameStart = drawFrameStart;
    renderer->drawFrameEnd = drawFrameEnd;
    renderer->drawQuad = drawQuad;
    renderer->destroy = destroy;
    return renderer;
}

```

`examples/test_pattern_renderer_metal.m`:

```m
#include "test_pattern_renderer.h"

#import <MetalKit/MetalKit.h>

#if !__has_feature(objc_arc)
#error This example requires ARC
#endif

typedef struct {
    Renderer renderer;
    MTKView *mtkView;
    id<MTLRenderPipelineState> pipelineState;
    id<MTLSamplerState> sampler;
    id<MTLCommandQueue> commandQueue;
    id<MTLCommandBuffer> commandBuffer;
    id<MTLRenderCommandEncoder> renderCommandEncoder;
    
    NSMutableDictionary<NSNumber *, id<MTLTexture>> *textures;
    Texture nextTexture;
} RendererMetal;

#define impl_of(this_renderer) ((RendererMetal *)(void *)((uint8_t *)this_renderer - offsetof(RendererMetal, renderer)))

static Texture textureUpload(Renderer *renderer, uint32_t width, uint32_t height, uint8_t *data) {
    RendererMetal *impl = impl_of(renderer);
    id<MTLDevice> device = impl->mtkView.device;
    Texture textureId = NULL_TEXTURE;
    
    MTLTextureDescriptor *textureDescriptor = [MTLTextureDescriptor new];
    textureDescriptor.pixelFormat = MTLPixelFormatRGBA8Unorm;
    textureDescriptor.width = width;
    textureDescriptor.height = height;
    
    id<MTLTexture> texture = [device newTextureWithDescriptor:textureDescriptor];
    if (texture) {
        MTLRegion region = { { 0, 0, 0 }, { width, height, 1 } };
        [texture replaceRegion:region mipmapLevel:0 withBytes:data bytesPerRow:width * 4];
        textureId = impl->nextTexture++;
        impl->textures[@(textureId)] = texture;
    }
    return textureId;
}

static void textureDestroy(Renderer *renderer, Texture texture) {
    RendererMetal *impl = impl_of(renderer);
    [impl->textures removeObjectForKey:@(texture)];
}

static void drawFrameStart(Renderer *renderer, int screenWidth, int screenHeight) {
    RendererMetal *impl = impl_of(renderer);
    MTKView *view = impl->mtkView;
    MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;
    
    if (renderPassDescriptor) {
        renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0, 0, 0, 1);
        
        id<MTLCommandBuffer> commandBuffer = [impl->commandQueue commandBuffer];
        commandBuffer.label = @"Test Pattern Command Buffer";
        
        id<MTLRenderCommandEncoder> renderCommandEncoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];
        renderCommandEncoder.label = @"Test Pattern Render Command Encoder";
        [renderCommandEncoder setViewport:(MTLViewport){ 0.0, 0.0, screenWidth, screenHeight, 0.0, 1.0 }];
        [renderCommandEncoder setRenderPipelineState:impl->pipelineState];
        [renderCommandEncoder setFragmentSamplerState:impl->sampler atIndex:0];

        impl->commandBuffer = commandBuffer;
        impl->renderCommandEncoder = renderCommandEncoder;
    }
}

static void drawFrameEnd(Renderer *renderer) {
    RendererMetal *impl = impl_of(renderer);
    MTKView *view = impl->mtkView;
    
    [impl->renderCommandEncoder endEncoding];
    [impl->commandBuffer presentDrawable:view.currentDrawable];
    [impl->commandBuffer commit];
    impl->commandBuffer = nil;
    impl->renderCommandEncoder = nil;
}

static void drawQuad(Renderer *renderer, Texture textureId, const Vertex (*vertices)[4]) {
    // NOTE: This function draws one quad at a time, which is slow. Don't use in production.
    RendererMetal *impl = impl_of(renderer);
    id<MTLDevice> device = impl->mtkView.device;
    id<MTLTexture> texture = [impl->textures objectForKey:@(textureId)];
    id<MTLBuffer> vertexBuffer = [device newBufferWithBytes:vertices length:sizeof(*vertices) options:MTLResourceCPUCacheModeWriteCombined];
    if (texture && vertexBuffer) {
        [impl->renderCommandEncoder setFragmentTexture:texture atIndex:0];
        [impl->renderCommandEncoder setVertexBuffer:vertexBuffer offset:0 atIndex:0];
        [impl->renderCommandEncoder drawPrimitives:MTLPrimitiveTypeTriangleStrip vertexStart:0 vertexCount:4];
    }
}

static void destroy(Renderer *renderer) {
    RendererMetal *impl = impl_of(renderer);
    impl->mtkView = nil;
    impl->pipelineState = nil;
    impl->sampler = nil;
    impl->textures = nil;
    impl->commandQueue = nil;
    impl->commandBuffer = nil;
    impl->renderCommandEncoder = nil;
    free(impl);
}

Renderer *createRendererMetal(GLFMDisplay *display) {
    MTKView *mtkView = (__bridge MTKView *)glfmGetMetalView(display);
    id<MTLDevice> device = mtkView.device;
    id<MTLCommandQueue> commandQueue = [device newCommandQueue];
    if (!commandQueue) {
        return NULL;
    }
    
    // Sampler
    MTLSamplerDescriptor *linearSamplerDescriptor = [MTLSamplerDescriptor new];
    linearSamplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
    linearSamplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
    id<MTLSamplerState> sampler = [device newSamplerStateWithDescriptor:linearSamplerDescriptor];
    if (!sampler) {
        return NULL;
    }
    
    // Shader
    NSError *error = nil;
    id<MTLLibrary> library = [device newDefaultLibrary];
    MTLRenderPipelineDescriptor *pipelineStateDescriptor = [MTLRenderPipelineDescriptor new];
    pipelineStateDescriptor.vertexFunction = [library newFunctionWithName:@"textureVertexShader"];
    pipelineStateDescriptor.fragmentFunction = [library newFunctionWithName:@"textureFragmentShader"];
    pipelineStateDescriptor.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
    pipelineStateDescriptor.colorAttachments[0].blendingEnabled = NO;
    id<MTLRenderPipelineState> pipelineState = [device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor error:&error];
    if (!pipelineState) {
        return NULL;
    }
    
    // Renderer
    RendererMetal *impl = calloc(1, sizeof(RendererMetal));
    impl->mtkView = mtkView;
    impl->sampler = sampler;
    impl->pipelineState = pipelineState;
    impl->commandQueue = commandQueue;
    impl->textures = [NSMutableDictionary new];
    impl->nextTexture = 1;
    
    Renderer *renderer = &impl->renderer;
    renderer->textureUpload = textureUpload;
    renderer->textureDestroy = textureDestroy;
    renderer->drawFrameStart = drawFrameStart;
    renderer->drawFrameEnd = drawFrameEnd;
    renderer->drawQuad = drawQuad;
    renderer->destroy = destroy;
    return renderer;
}

```

`examples/touch.c`:

```c
// Example app that draws a cube.
// The cube can be rotated via touch, scroll wheel, or keyboard arrow keys.
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "glfm.h"

static const size_t CUBE_VERTEX_STRIDE = sizeof(GLfloat) * 6;

static const GLfloat CUBE_VERTICES[] = {
    // x,     y,     z,      r,    g,    b
    // Top (white)
   -1.0f,  1.0f,  1.0f,   1.0f, 1.0f, 1.0f,
    1.0f,  1.0f,  1.0f,   1.0f, 1.0f, 1.0f,
    1.0f,  1.0f, -1.0f,   1.0f, 1.0f, 1.0f,
   -1.0f,  1.0f, -1.0f,   1.0f, 1.0f, 1.0f,

    // Front (gray)
   -1.0f, -1.0f,  1.0f,   0.4f, 0.4f, 0.4f,
    1.0f, -1.0f,  1.0f,   0.4f, 0.4f, 0.4f,
    1.0f,  1.0f,  1.0f,   0.4f, 0.4f, 0.4f,
   -1.0f,  1.0f,  1.0f,   0.4f, 0.4f, 0.4f,

    // Left (light gray)
   -1.0f, -1.0f, -1.0f,   0.6f, 0.6f, 0.6f,
   -1.0f, -1.0f,  1.0f,   0.6f, 0.6f, 0.6f,
   -1.0f,  1.0f,  1.0f,   0.6f, 0.6f, 0.6f,
   -1.0f,  1.0f, -1.0f,   0.6f, 0.6f, 0.6f,

    // Bottom (dark gray)
   -1.0f, -1.0f, -1.0f,   0.2f, 0.2f, 0.2f,
    1.0f, -1.0f, -1.0f,   0.2f, 0.2f, 0.2f,
    1.0f, -1.0f,  1.0f,   0.2f, 0.2f, 0.2f,
   -1.0f, -1.0f,  1.0f,   0.2f, 0.2f, 0.2f,

    // Back (gray)
    1.0f, -1.0f, -1.0f,   0.4f, 0.4f, 0.4f,
   -1.0f, -1.0f, -1.0f,   0.4f, 0.4f, 0.4f,
   -1.0f,  1.0f, -1.0f,   0.4f, 0.4f, 0.4f,
    1.0f,  1.0f, -1.0f,   0.4f, 0.4f, 0.4f,

    // Right (light gray)
    1.0f, -1.0f,  1.0f,   0.6f, 0.6f, 0.6f,
    1.0f, -1.0f, -1.0f,   0.6f, 0.6f, 0.6f,
    1.0f,  1.0f, -1.0f,   0.6f, 0.6f, 0.6f,
    1.0f,  1.0f,  1.0f,   0.6f, 0.6f, 0.6f,
};

static const GLushort CUBE_INDICES[] = {
     0,  1,  2,  0,  2,  3,
     4,  5,  6,  4,  6,  7,
     8,  9, 10,  8, 10, 11,
    12, 13, 14, 12, 14, 15,
    16, 17, 18, 16, 18, 19,
    20, 21, 22, 20, 22, 23,
};

typedef struct {
    GLuint program;
    GLuint vertexBuffer;
    GLuint vertexArray;
    GLuint indexBuffer;

    GLint modelLocation;
    GLint viewProjLocation;

    double lastTouchX;
    double lastTouchY;

    double angleX;
    double angleY;

    bool needsRedraw;
} TouchApp;

static bool onTouch(GLFMDisplay *display, int touch, GLFMTouchPhase phase, double x, double y) {
    if (phase == GLFMTouchPhaseHover) {
        return false;
    }
    TouchApp *app = glfmGetUserData(display);
    app->needsRedraw = true;
    if (phase != GLFMTouchPhaseBegan) {
        int width, height;
        glfmGetDisplaySize(display, &width, &height);
        app->angleX += (x - app->lastTouchX) / height;
        app->angleY += (y - app->lastTouchY) / height;
    }
    app->lastTouchX = x;
    app->lastTouchY = y;
    return true;
}

static bool onKey(GLFMDisplay *display, GLFMKeyCode keyCode, GLFMKeyAction action, int modifiers) {
    bool handled = false;
    if (action == GLFMKeyActionPressed || action == GLFMKeyActionRepeated) {
        TouchApp *app = glfmGetUserData(display);
        switch (keyCode) {
            case GLFMKeyCodeArrowLeft:
                app->angleX -= 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeArrowRight:
                app->angleX += 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeArrowUp:
                app->angleY -= 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeArrowDown:
                app->angleY += 0.01f;
                handled = true;
                break;
            case GLFMKeyCodeEscape:
                app->angleX = 0.0f;
                app->angleY = 0.0f;
                handled = true;
                break;
            default:
                break;
        }
        app->needsRedraw |= handled;
    }
    return handled;
}

static bool onScroll(GLFMDisplay *display, double x, double y, GLFMMouseWheelDeltaType deltaType,
                     double deltaX, double deltaY, double deltaZ) {
    TouchApp *app = glfmGetUserData(display);
    int width, height;
    glfmGetDisplaySize(display, &width, &height);
    if (deltaType != GLFMMouseWheelDeltaPixel) {
        deltaX *= 20;
        deltaY *= 20;
    }
    app->angleX -= deltaX / height;
    app->angleY -= deltaY / height;
    app->needsRedraw = true;
    return true;
}

static void onSurfaceCreated(GLFMDisplay *display, int width, int height) {
    GLFMRenderingAPI api = glfmGetRenderingAPI(display);
    printf("Hello from GLFM! Using OpenGL %s\n",
           api == GLFMRenderingAPIOpenGLES32 ? "ES 3.2" :
           api == GLFMRenderingAPIOpenGLES31 ? "ES 3.1" :
           api == GLFMRenderingAPIOpenGLES3 ? "ES 3.0" : "ES 2.0");
}

static void onSurfaceRefresh(GLFMDisplay *display) {
    TouchApp *app = glfmGetUserData(display);
    app->needsRedraw = true;
}

static void onSurfaceDestroyed(GLFMDisplay *display) {
    // When the surface is destroyed, all existing GL resources are no longer valid.
    TouchApp *app = glfmGetUserData(display);
    app->program = 0;
    app->vertexBuffer = 0;
    app->vertexArray = 0;
    app->indexBuffer = 0;
    printf("Goodbye\n");
}

static GLuint compileShader(GLenum type, const GLchar *shaderSource) {
    // Compile
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &shaderSource, NULL);
    glCompileShader(shader);

    // Check compile status
    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
    if (status == 0) {
        printf("Shader compile error\n");
        GLint logLength;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLength);
        if (logLength > 0) {
            GLchar *log = malloc(logLength);
            glGetShaderInfoLog(shader, logLength, &logLength, log);
            if (log[0] != 0) {
                printf("%s\n", log);
            }
            free(log);
        }
        glDeleteShader(shader);
        shader = 0;
    }
    return shader;
}

static void draw(TouchApp *app, int width, int height) {
    // Create shader
    if (app->program == 0) {
        const GLchar vertexShader[] =
            "#version 100\n"
            "uniform mat4 model;\n"
            "uniform mat4 viewProj;\n"
            "attribute highp vec3 a_position;\n"
            "attribute lowp vec3 a_color;\n"
            "varying lowp vec4 v_color;\n"
            "void main() {\n"
            "   gl_Position = (viewProj * model) * vec4(a_position, 1.0);\n"
            "   v_color = vec4(a_color, 1.0);\n"
            "}";

        const GLchar fragmentShader[] =
            "#version 100\n"
            "varying lowp vec4 v_color;\n"
            "void main() {\n"
            "  gl_FragColor = v_color;\n"
            "}";

        GLuint vertShader = compileShader(GL_VERTEX_SHADER, vertexShader);
        GLuint fragShader = compileShader(GL_FRAGMENT_SHADER, fragmentShader);
        if (vertShader == 0 || fragShader == 0) {
            return;
        }
        app->program = glCreateProgram();

        glAttachShader(app->program, vertShader);
        glAttachShader(app->program, fragShader);

        glBindAttribLocation(app->program, 0, "a_position");
        glBindAttribLocation(app->program, 1, "a_color");

        glLinkProgram(app->program);

        glDeleteShader(vertShader);
        glDeleteShader(fragShader);

        app->modelLocation = glGetUniformLocation(app->program, "model");
        app->viewProjLocation = glGetUniformLocation(app->program, "viewProj");
    }

    // Fill vertex and index buffers
    if (app->vertexBuffer == 0) {
        glGenBuffers(1, &app->vertexBuffer);
        glBindBuffer(GL_ARRAY_BUFFER, app->vertexBuffer);
        glBufferData(GL_ARRAY_BUFFER, sizeof(CUBE_VERTICES), CUBE_VERTICES, GL_STATIC_DRAW);
    }
    if (app->indexBuffer == 0) {
        glGenBuffers(1, &app->indexBuffer);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, app->indexBuffer);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(CUBE_INDICES), CUBE_INDICES, GL_STATIC_DRAW);
    }

    // Upload matrices
    float ratio = (float)height / (float)width;
    float cx = cosf(app->angleY * -2 * M_PI - M_PI / 4);
    float sx = sinf(app->angleY * -2 * M_PI - M_PI / 4);
    float cy = cosf(app->angleX * -2 * M_PI - M_PI / 4);
    float sy = sinf(app->angleX * -2 * M_PI - M_PI / 4);
    float z = -3.0f;

    const GLfloat model[16] = {
           cy, sx*sy, cx*sy,  0.0f,
         0.0f,    cx,   -sx,  0.0f,
          -sy, sx*cy, cx*cy,  0.0f,
         0.0f,  0.0f,     z,  1.0f,
    };

    const GLfloat viewProj[16] = {
        ratio,  0.0f,  0.0f,  0.0f,
         0.0f,  1.0f,  0.0f,  0.0f,
         0.0f,  0.0f, -1.0f, -1.0f,
         0.0f,  0.0f,  0.00,  1.0f,
    };

    glUseProgram(app->program);
    glUniformMatrix4fv(app->modelLocation, 1, GL_FALSE, model);
    glUniformMatrix4fv(app->viewProjLocation, 1, GL_FALSE, viewProj);

    // Draw background
    glViewport(0, 0, width, height);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // Draw cube
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    if (app->vertexArray == 0) {
        glGenVertexArrays(1, &app->vertexArray);
    }
    glBindVertexArray(app->vertexArray);
#endif
    glBindBuffer(GL_ARRAY_BUFFER, app->vertexBuffer);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, CUBE_VERTEX_STRIDE, (void *)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, CUBE_VERTEX_STRIDE, (void *)(sizeof(GLfloat) * 3));

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, app->indexBuffer);
    glDrawElements(GL_TRIANGLES, sizeof(CUBE_INDICES) / sizeof(CUBE_INDICES[0]), GL_UNSIGNED_SHORT, (void *)0);
}

static void onDraw(GLFMDisplay *display) {
    TouchApp *app = glfmGetUserData(display);
    if (app->needsRedraw) {
        app->needsRedraw = false;

        int width, height;
        glfmGetDisplaySize(display, &width, &height);
        draw(app, width,  height);
        glfmSwapBuffers(display);
    }
}

void glfmMain(GLFMDisplay *display) {
    TouchApp *app = calloc(1, sizeof(TouchApp));
    glfmSetDisplayConfig(display,
                         GLFMRenderingAPIOpenGLES2,
                         GLFMColorFormatRGBA8888,
                         GLFMDepthFormatNone,
                         GLFMStencilFormatNone,
                         GLFMMultisampleNone);
    glfmSetUserData(display, app);
    glfmSetSurfaceCreatedFunc(display, onSurfaceCreated);
    glfmSetSurfaceRefreshFunc(display, onSurfaceRefresh);
    glfmSetSurfaceDestroyedFunc(display, onSurfaceDestroyed);
    glfmSetRenderFunc(display, onDraw);
    glfmSetTouchFunc(display, onTouch);
    glfmSetKeyFunc(display, onKey);
    glfmSetMouseWheelFunc(display, onScroll);
}

```

`examples/triangle.c`:

```c
// Basic triangle example
#include "glfm.h"

static GLint program = 0;
static GLuint vertexBuffer = 0;
static GLuint vertexArray = 0;

static void onDraw(GLFMDisplay *display);
static void onSurfaceDestroyed(GLFMDisplay *display);

void glfmMain(GLFMDisplay *display) {
    glfmSetDisplayConfig(display,
                         GLFMRenderingAPIOpenGLES2,
                         GLFMColorFormatRGBA8888,
                         GLFMDepthFormatNone,
                         GLFMStencilFormatNone,
                         GLFMMultisampleNone);
    glfmSetRenderFunc(display, onDraw);
    glfmSetSurfaceDestroyedFunc(display, onSurfaceDestroyed);
}

static void onSurfaceDestroyed(GLFMDisplay *display) {
    // When the surface is destroyed, all existing GL resources are no longer valid.
    program = 0;
    vertexBuffer = 0;
    vertexArray = 0;
}

static GLuint compileShader(const GLenum type, const GLchar *shaderString, GLint shaderLength) {
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &shaderString, &shaderLength);
    glCompileShader(shader);
    return shader;
}

static void onDraw(GLFMDisplay *display) {
    if (program == 0) {
        const GLchar vertexShader[] =
            "#version 100\n"
            "attribute highp vec4 position;\n"
            "void main() {\n"
            "   gl_Position = position;\n"
            "}";

        const GLchar fragmentShader[] =
            "#version 100\n"
            "void main() {\n"
            "  gl_FragColor = vec4(1.00, 1.00, 1.00, 1.0);\n"
            "}";

        program = glCreateProgram();
        GLuint vertShader = compileShader(GL_VERTEX_SHADER, vertexShader, sizeof(vertexShader) - 1);
        GLuint fragShader = compileShader(GL_FRAGMENT_SHADER, fragmentShader, sizeof(fragmentShader) - 1);

        glAttachShader(program, vertShader);
        glAttachShader(program, fragShader);

        glLinkProgram(program);

        glDeleteShader(vertShader);
        glDeleteShader(fragShader);
    }
    if (vertexBuffer == 0) {
        const GLfloat vertices[] = {
             0.0,  0.5, 0.0,
            -0.5, -0.5, 0.0,
             0.5, -0.5, 0.0,
        };
        glGenBuffers(1, &vertexBuffer);
        glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    }

    int width, height;
    glfmGetDisplaySize(display, &width, &height);
    glViewport(0, 0, width, height);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    if (vertexArray == 0) {
        glGenVertexArrays(1, &vertexArray);
    }
    glBindVertexArray(vertexArray);
#endif

    glUseProgram(program);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glDrawArrays(GL_TRIANGLES, 0, 3);

    glfmSwapBuffers(display);
}

```

`examples/typing.c`:

```c
/// This example demonstrates character input, key codes, and the virtual keyboard.
/// * iOS/Android: Tap to show the virtual keyboard.
/// * Caveat: This example uses an ASCII-only font.
/// Devices with a physical keyboard:
/// * Ctrl-M to switch to KeyCode mode.
/// * Ctrl-L to clear the screen.
/// * Ctrl-X, Ctrl-C, Ctrl-V for cut, copy, paste.
/// Tips:
/// * iOS Simulator: Toggle "I/O -> Keyboard -> Connect Hardware Keyboard" to test with it both
///   enabled (physical keyboard) and disabled (virtual keyboard).
/// * Devices with a USB-C port: Connect a physical keyboard directly (no need to use Bluetooth).
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "glfm.h"
#include "file_compat.h"

#define FILE_COMPAT_ANDROID_ACTIVITY glfmGetAndroidActivity(display)

enum {
    CONSOLE_COLS = 22,
    CONSOLE_MAX_LINES = 40,
    CONSOLE_MAX_SCALE = 3,

    FONT_CHAR_FIRST = ' ',
    FONT_CHAR_COUNT = 224,
    FONT_CHAR_WIDTH = 6,
    FONT_CHAR_HEIGHT = 13,

    TEXTURE_CHARS_X = 8,
    TEXTURE_CHARS_Y = (FONT_CHAR_COUNT + TEXTURE_CHARS_X - 1) / TEXTURE_CHARS_X,
    TEXTURE_SPACING = 1, // Prevent bleeding
};

// Cozette font converted to bitmap via Image Magick
static const uint8_t FONT_DATA[FONT_CHAR_COUNT][FONT_CHAR_HEIGHT] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00 },
    { 0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x14, 0x14, 0x3E, 0x14, 0x14, 0x3E, 0x14, 0x14, 0x00, 0x00, 0x00 },
    { 0x00, 0x08, 0x1C, 0x2A, 0x0A, 0x1C, 0x28, 0x28, 0x2A, 0x1C, 0x08, 0x00, 0x00 },
    { 0x00, 0x04, 0x0A, 0x24, 0x10, 0x08, 0x04, 0x12, 0x28, 0x10, 0x00, 0x00, 0x00 },
    { 0x00, 0x08, 0x14, 0x14, 0x08, 0x2C, 0x12, 0x12, 0x12, 0x2C, 0x00, 0x00, 0x00 },
    { 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x10, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x08, 0x10, 0x00 },
    { 0x00, 0x04, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x04, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x08, 0x04, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x00 },
    { 0x00, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x02, 0x02, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x22, 0x2A, 0x2A, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x08, 0x0C, 0x0A, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x20, 0x10, 0x08, 0x04, 0x02, 0x3E, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x20, 0x18, 0x20, 0x20, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x20, 0x30, 0x28, 0x24, 0x22, 0x7E, 0x20, 0x20, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x3E, 0x02, 0x02, 0x1E, 0x20, 0x20, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x18, 0x04, 0x02, 0x1E, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x3E, 0x20, 0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x22, 0x1C, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x10, 0x0C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x08, 0x04, 0x00 },
    { 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x20, 0x10, 0x08, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x22, 0x3A, 0x2A, 0x3A, 0x02, 0x3C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1E, 0x22, 0x22, 0x1E, 0x22, 0x22, 0x22, 0x1E, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x02, 0x02, 0x02, 0x02, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x0E, 0x12, 0x22, 0x22, 0x22, 0x22, 0x12, 0x0E, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x3E, 0x02, 0x02, 0x1E, 0x02, 0x02, 0x02, 0x3E, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x3E, 0x02, 0x02, 0x1E, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x02, 0x02, 0x32, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x22, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x38, 0x20, 0x20, 0x20, 0x20, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x22, 0x12, 0x0A, 0x0E, 0x12, 0x12, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x3E, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x22, 0x36, 0x2A, 0x2A, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x22, 0x26, 0x26, 0x2A, 0x2A, 0x32, 0x32, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1E, 0x22, 0x22, 0x22, 0x1E, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x12, 0x2C, 0x20, 0x00, 0x00 },
    { 0x00, 0x00, 0x1E, 0x22, 0x22, 0x1E, 0x12, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x02, 0x1C, 0x20, 0x20, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x14, 0x14, 0x08, 0x08, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x22, 0x22, 0x22, 0x2A, 0x2A, 0x1C, 0x14, 0x14, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x22, 0x22, 0x14, 0x08, 0x08, 0x14, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x3E, 0x10, 0x08, 0x08, 0x04, 0x04, 0x02, 0x3E, 0x00, 0x00, 0x00 },
    { 0x00, 0x1C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1C, 0x00 },
    { 0x00, 0x02, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x00, 0x00 },
    { 0x00, 0x1C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x00 },
    { 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00 },
    { 0x00, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x32, 0x2C, 0x00, 0x00, 0x00 },
    { 0x00, 0x02, 0x02, 0x02, 0x1E, 0x22, 0x22, 0x22, 0x22, 0x1E, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x22, 0x02, 0x02, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x20, 0x20, 0x20, 0x3C, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x22, 0x3E, 0x02, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x38, 0x04, 0x04, 0x1E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x1C },
    { 0x00, 0x02, 0x02, 0x02, 0x1E, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x08, 0x00, 0x0C, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x10, 0x00, 0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x14, 0x08, 0x00 },
    { 0x00, 0x02, 0x02, 0x02, 0x22, 0x12, 0x0A, 0x0E, 0x12, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x0C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x18, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x16, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x1E, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x1E, 0x22, 0x22, 0x22, 0x22, 0x1E, 0x02, 0x02, 0x02 },
    { 0x00, 0x00, 0x00, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x60 },
    { 0x00, 0x00, 0x00, 0x00, 0x1E, 0x22, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x3C, 0x02, 0x1C, 0x20, 0x20, 0x1E, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x04, 0x04, 0x1E, 0x04, 0x04, 0x04, 0x04, 0x38, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x2A, 0x2A, 0x14, 0x14, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x22, 0x14, 0x08, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x1C },
    { 0x00, 0x00, 0x00, 0x00, 0x3E, 0x10, 0x08, 0x04, 0x02, 0x3E, 0x00, 0x00, 0x00 },
    { 0x00, 0x30, 0x08, 0x08, 0x08, 0x08, 0x06, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00 },
    { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00 },
    { 0x00, 0x06, 0x08, 0x08, 0x08, 0x08, 0x30, 0x08, 0x08, 0x08, 0x08, 0x06, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x2A, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00 },
    { 0x00, 0x00, 0x00, 0x08, 0x1C, 0x2A, 0x0A, 0x0A, 0x2A, 0x1C, 0x08, 0x00, 0x00 },
    { 0x00, 0x00, 0x18, 0x04, 0x04, 0x1E, 0x04, 0x04, 0x04, 0x3A, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x22, 0x1C, 0x14, 0x14, 0x1C, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x22, 0x22, 0x22, 0x14, 0x08, 0x3E, 0x08, 0x3E, 0x08, 0x00, 0x00, 0x00 },
    { 0x00, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00 },
    { 0x00, 0x1C, 0x22, 0x02, 0x0C, 0x14, 0x14, 0x18, 0x20, 0x22, 0x1C, 0x00, 0x00 },
    { 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x1C, 0x22, 0x5D, 0x45, 0x5D, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x18, 0x20, 0x38, 0x24, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x28, 0x14, 0x0A, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x1C, 0x22, 0x5D, 0x45, 0x45, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x0C, 0x12, 0x12, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x3E, 0x00, 0x00, 0x00 },
    { 0x00, 0x0C, 0x12, 0x08, 0x04, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x0E, 0x10, 0x0C, 0x10, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x24, 0x24, 0x24, 0x24, 0x2C, 0x14, 0x04, 0x02, 0x00 },
    { 0x00, 0x00, 0x3C, 0x2E, 0x2E, 0x2C, 0x28, 0x28, 0x28, 0x28, 0x28, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x0C, 0x00 },
    { 0x00, 0x04, 0x06, 0x04, 0x04, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x10, 0x28, 0x10, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x0A, 0x14, 0x28, 0x14, 0x0A, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x22, 0x12, 0x12, 0x0A, 0x08, 0x24, 0x34, 0x3A, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x22, 0x12, 0x12, 0x0A, 0x08, 0x14, 0x24, 0x12, 0x32, 0x00, 0x00, 0x00 },
    { 0x00, 0x26, 0x14, 0x12, 0x0C, 0x0E, 0x24, 0x34, 0x3A, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x08, 0x04, 0x02, 0x22, 0x1C, 0x00 },
    { 0x04, 0x08, 0x00, 0x1C, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x10, 0x08, 0x00, 0x1C, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x08, 0x14, 0x00, 0x1C, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x2C, 0x1A, 0x00, 0x1C, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x14, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x08, 0x14, 0x08, 0x00, 0x1C, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x3C, 0x0A, 0x0A, 0x3A, 0x0E, 0x0A, 0x0A, 0x3A, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x1C, 0x22, 0x02, 0x02, 0x02, 0x02, 0x22, 0x1C, 0x08, 0x08, 0x04 },
    { 0x04, 0x08, 0x00, 0x3E, 0x02, 0x02, 0x1E, 0x02, 0x02, 0x3E, 0x00, 0x00, 0x00 },
    { 0x10, 0x08, 0x00, 0x3E, 0x02, 0x02, 0x1E, 0x02, 0x02, 0x3E, 0x00, 0x00, 0x00 },
    { 0x08, 0x14, 0x00, 0x3E, 0x02, 0x02, 0x1E, 0x02, 0x02, 0x3E, 0x00, 0x00, 0x00 },
    { 0x14, 0x00, 0x3E, 0x02, 0x02, 0x1E, 0x02, 0x02, 0x02, 0x3E, 0x00, 0x00, 0x00 },
    { 0x04, 0x08, 0x00, 0x1C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00, 0x00 },
    { 0x10, 0x08, 0x00, 0x1C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00, 0x00 },
    { 0x08, 0x14, 0x00, 0x1C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00, 0x00 },
    { 0x14, 0x00, 0x1C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x1C, 0x24, 0x24, 0x2E, 0x24, 0x24, 0x1C, 0x00, 0x00, 0x00 },
    { 0x2C, 0x1A, 0x00, 0x22, 0x26, 0x26, 0x2A, 0x32, 0x32, 0x22, 0x00, 0x00, 0x00 },
    { 0x04, 0x08, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x10, 0x08, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x08, 0x14, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x2C, 0x1A, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x14, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x22, 0x14, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x20, 0x1C, 0x32, 0x32, 0x2A, 0x2A, 0x26, 0x26, 0x1C, 0x02, 0x00, 0x00 },
    { 0x04, 0x08, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x10, 0x08, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x08, 0x14, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x14, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x10, 0x08, 0x00, 0x22, 0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x02, 0x02, 0x1E, 0x22, 0x22, 0x1E, 0x02, 0x02, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x0C, 0x12, 0x12, 0x0A, 0x12, 0x22, 0x22, 0x1A, 0x00, 0x00, 0x00 },
    { 0x00, 0x04, 0x08, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x32, 0x2C, 0x00, 0x00, 0x00 },
    { 0x00, 0x10, 0x08, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x32, 0x2C, 0x00, 0x00, 0x00 },
    { 0x00, 0x08, 0x14, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x32, 0x2C, 0x00, 0x00, 0x00 },
    { 0x00, 0x2C, 0x1A, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x32, 0x2C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x14, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x32, 0x2C, 0x00, 0x00, 0x00 },
    { 0x08, 0x14, 0x08, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x32, 0x2C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x2A, 0x3A, 0x0A, 0x2A, 0x14, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x22, 0x02, 0x02, 0x22, 0x1C, 0x08, 0x10, 0x0C },
    { 0x00, 0x04, 0x08, 0x00, 0x1C, 0x22, 0x3E, 0x02, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x10, 0x08, 0x00, 0x1C, 0x22, 0x3E, 0x02, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x08, 0x14, 0x00, 0x1C, 0x22, 0x3E, 0x02, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x14, 0x00, 0x1C, 0x22, 0x3E, 0x02, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x04, 0x08, 0x00, 0x0C, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00 },
    { 0x00, 0x10, 0x08, 0x00, 0x0C, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00 },
    { 0x00, 0x08, 0x14, 0x00, 0x0C, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x14, 0x00, 0x0C, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00 },
    { 0x00, 0x2C, 0x10, 0x28, 0x20, 0x3C, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x2C, 0x1A, 0x00, 0x1E, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00 },
    { 0x00, 0x04, 0x08, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x10, 0x08, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x08, 0x14, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x2C, 0x1A, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x14, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x3E, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x00, 0x20, 0x1C, 0x32, 0x2A, 0x2A, 0x26, 0x1C, 0x02, 0x00, 0x00 },
    { 0x00, 0x04, 0x08, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x00, 0x00, 0x00 },
    { 0x00, 0x10, 0x08, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x00, 0x00, 0x00 },
    { 0x00, 0x08, 0x14, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x14, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x00, 0x00, 0x00 },
    { 0x00, 0x10, 0x08, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x1C },
    { 0x00, 0x00, 0x02, 0x02, 0x1E, 0x22, 0x22, 0x22, 0x22, 0x1E, 0x02, 0x02, 0x00 },
    { 0x00, 0x00, 0x14, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x1C },
};

typedef struct {
    GLuint program;
    GLuint vertexArray;
    GLuint positionBuffer;
    GLuint texCoordBuffer;
    GLuint indexBuffer;
    GLuint texture;

    GLfloat texCoords[CONSOLE_MAX_LINES * CONSOLE_COLS * 4 * 2];

    uint32_t console[CONSOLE_MAX_LINES][CONSOLE_COLS];
    size_t consoleLineFirst;
    size_t consoleLineCount;
    size_t consoleCol;

    size_t bottomSpacingRequested;
    size_t bottomSpacingActual;

    double cursorBlinkStartTime;
    bool focused;
    bool keyCodeMode;
} TypingApp;

// Converts the first code point from a zero-terminated UTF-8 string and returns the number of
// bytes read. Returns zero on error.
static size_t convertUTF8ToCodePoint(const char *utf8, uint32_t *codePoint) {
    const unsigned char *in = (const unsigned char *)utf8;
    if (in[0] == 0) {
        *codePoint = 0;
        return 0;
    } else if (in[0] < 0xc0) {
        *codePoint = in[0];
        return 1;
    } else if (in[1] == 0) {
        *codePoint = 0;
        return 0;
    } else if (in[0] < 0xe0) {
        *codePoint = ((in[0] & 0x1fu) << 6) | (in[1] & 0x3fu);
        return 2;
    } else if (in[2] == 0) {
        *codePoint = 0;
        return 0;
    } else if (in[0] < 0xf0) {
        *codePoint = ((in[0] & 0x0fu) << 12) | ((in[1] & 0x3fu) << 6) | (in[2] & 0x3fu);
        return 3;
    } else if (in[3] == 0) {
        *codePoint = 0;
        return 0;
    } else {
        *codePoint = ((in[0] & 0x07u) << 18) | ((in[1] & 0x3fu) << 6) | ((in[2] & 0x3fu) << 6) | (in[3] & 0x3f);
        return 4;
    }
}

// Converts a code point to UTF-8 and returns the number of bytes written.
// The string buffer must contain space for at least 4 bytes.
// If the code point is greater than 0x10FFFF, this function does nothing and returns 0.
static size_t convertCodePointToUTF8(uint32_t codePoint, char *utf8) {
    if (codePoint < 0x80) {
        utf8[0] = (char)(codePoint & 0x7fu);
        return 1;
    } else if (codePoint < 0x800) {
        utf8[0] = (char)(0xc0u | (codePoint >> 6u));
        utf8[1] = (char)(0x80u | (codePoint & 0x3fu));
        return 2;
    } else if (codePoint < 0x10000) {
        utf8[0] = (char)(0xe0u | (codePoint >> 12u));
        utf8[1] = (char)(0x80u | ((codePoint >> 6u) & 0x3fu));
        utf8[2] = (char)(0x80u | (codePoint & 0x3fu));
        return 3;
    } else if (codePoint < 0x110000) {
        utf8[0] = (char)(0xf0u | (codePoint >> 18u));
        utf8[1] = (char)(0x80u | ((codePoint >> 12u) & 0x3fu));
        utf8[2] = (char)(0x80u | ((codePoint >> 6u) & 0x3fu));
        utf8[3] = (char)(0x80u | (codePoint & 0x3fu));
        return 4;
    } else {
        return 0;
    }
}

static void consoleNewline(TypingApp *app) {
    app->cursorBlinkStartTime = glfmGetTime();
    if (app->consoleLineCount < CONSOLE_MAX_LINES) {
        app->consoleLineCount++;
    }
    app->consoleLineFirst = (app->consoleLineFirst + CONSOLE_MAX_LINES - 1) % CONSOLE_MAX_LINES;
    app->consoleCol = 0;
    memset(app->console[app->consoleLineFirst], 0, CONSOLE_COLS * sizeof(app->console[0][0]));
}

static void consoleBackspace(TypingApp *app) {
    app->cursorBlinkStartTime = glfmGetTime();
    if (app->consoleLineCount > 0) {
        if (app->consoleCol > 0) {
            app->console[app->consoleLineFirst][--app->consoleCol] = 0;
        } else if (app->consoleLineCount > 1) {
            app->consoleLineFirst = (app->consoleLineFirst + 1) % CONSOLE_MAX_LINES;
            app->consoleLineCount--;
            app->consoleCol = CONSOLE_COLS - 1;
            app->console[app->consoleLineFirst][app->consoleCol] = 0;
            while (app->consoleCol > 0 && app->console[app->consoleLineFirst][app->consoleCol - 1] == 0) {
                app->consoleCol--; // Find EOL
            }
        }
    }
}

static void consolePrint(TypingApp *app, const char *utf8) {
    app->cursorBlinkStartTime = glfmGetTime();
    if (app->consoleLineCount == 0) {
        app->consoleLineCount = 1;
        app->consoleCol = 0;
        memset(app->console[app->consoleLineFirst], 0, CONSOLE_COLS * sizeof(app->console[0][0]));
    }
    size_t bytesRead;
    uint32_t codePoint;
    while ((bytesRead = convertUTF8ToCodePoint(utf8, &codePoint)) != 0) {
        if (codePoint == '\n') {
            consoleNewline(app);
        } else {
            if (codePoint < FONT_CHAR_FIRST || codePoint >= FONT_CHAR_FIRST + FONT_CHAR_COUNT) {
                codePoint = '?';
                printf("No glyph for '%.*s'\n", (int)bytesRead, utf8);
            }
            app->console[app->consoleLineFirst][app->consoleCol++] = codePoint;
            if (app->consoleCol >= CONSOLE_COLS) {
                consoleNewline(app);
            }
        }
        utf8 += bytesRead;
    }
}

// Copies the console content to a UTF-8 string buffer and adds a trailing zero.
static void consoleCopy(TypingApp *app, char *buffer, size_t bufferSize) {
    if (bufferSize == 0) {
        return;
    }
    const char *bufferEnd = buffer + bufferSize - 4;
    for (size_t i = app->consoleLineCount; i > 0; i--) {
        if (buffer >= bufferEnd) {
            break;
        }
        size_t line = (app->consoleLineFirst + i - 1) % CONSOLE_MAX_LINES;
        for (size_t col = 0; col < CONSOLE_COLS; col++) {
            uint32_t codePoint = app->console[line][col];
            if (codePoint == 0) {
                if (col > 0 || i > 1) {
                    *buffer++ = '\n';
                }
                break;
            }
            buffer += convertCodePointToUTF8(codePoint, buffer);
            if (buffer >= bufferEnd) {
                break;
            }
        }
    }
    *buffer = '\0';
}

static void consoleClear(TypingApp *app) {
    app->consoleLineCount = 0;
    consolePrint(app, "");
}

static double consoleGetScale(const GLFMDisplay *display) {
    // Center horizontally with one column of spacing on either side. Shrink if needed.
    int width, height;
    glfmGetDisplaySize(display, &width, &height);
    double consoleWidth = FONT_CHAR_WIDTH * (CONSOLE_COLS + 2);
    double maxConsoleWidth = CONSOLE_MAX_SCALE * glfmGetDisplayScale(display) * consoleWidth;
    double scaleX = (width > maxConsoleWidth) ? maxConsoleWidth / width : 1.0;
    return scaleX * width / consoleWidth;
}

static void onKeyboardVisibilityChanged(GLFMDisplay *display, bool visible,
                                        double x, double y, double width, double height) {
    // Assume virtual keyboard is at the bottom of the screen
    double scale = consoleGetScale(display);
    double lineHeight = FONT_CHAR_HEIGHT * scale;
    TypingApp *app = glfmGetUserData(display);
    app->bottomSpacingRequested = visible ? (size_t)ceil(height / lineHeight) : 0;

    // Check bottom insets
    double bottom;
    glfmGetDisplayChromeInsets(display, NULL, NULL, &bottom, NULL);
    size_t minimumBottomSpace = 1 + (size_t)floor(bottom / lineHeight);
    if (app->bottomSpacingRequested < minimumBottomSpace) {
        app->bottomSpacingRequested = minimumBottomSpace;
    }
}

static bool onTouch(GLFMDisplay *display, int touch, GLFMTouchPhase phase, double x, double y) {
    if (phase == GLFMTouchPhaseBegan) {
        glfmSetKeyboardVisible(display, !glfmIsKeyboardVisible(display));
        return true;
    } else {
        return false;
    }
}

static void onChar(GLFMDisplay *display, const char *utf8, int modifiers) {
    TypingApp *app = glfmGetUserData(display);
    consolePrint(app, utf8);
}

static void onClipboardPasteText(GLFMDisplay *display, const char *string) {
    if (string) {
        TypingApp *app = glfmGetUserData(display);
        consolePrint(app, string);
    }
}

static bool onKey(GLFMDisplay *display, GLFMKeyCode keyCode, GLFMKeyAction action, int modifiers) {
    TypingApp *app = glfmGetUserData(display);
    if (action == GLFMKeyActionPressed) {
        if (keyCode == GLFMKeyCodeL && modifiers == GLFMKeyModifierControl) {
            consoleClear(app);
            return true;
        } else if (keyCode == GLFMKeyCodeM && modifiers == GLFMKeyModifierControl) {
            app->keyCodeMode = !app->keyCodeMode;
            if (app->consoleCol > 0) {
                consoleNewline(app);
            }
            if (app->keyCodeMode) {
                consolePrint(app, "KeyCode mode: on\n");
                glfmSetCharFunc(display, NULL);
            } else {
                consolePrint(app, "KeyCode mode: off\n");
                glfmSetCharFunc(display, onChar);
            }
            return true;
        } else if ((keyCode == GLFMKeyCodeC || keyCode == GLFMKeyCodeX) &&
                   (modifiers == GLFMKeyModifierMeta || modifiers == GLFMKeyModifierControl)) {
            char buffer[CONSOLE_COLS * CONSOLE_MAX_LINES + 1];
            consoleCopy(app, buffer, sizeof(buffer));
            bool success = glfmSetClipboardText(display, buffer);
            if (success && keyCode == GLFMKeyCodeX) {
                consoleClear(app);
            }
            return true;
        } else if (keyCode == GLFMKeyCodeV &&
                   (modifiers == GLFMKeyModifierMeta || modifiers == GLFMKeyModifierControl)) {
            glfmRequestClipboardText(display, onClipboardPasteText);
            return true;
        }
    }
    if (app->keyCodeMode) {
        char line[256];
        snprintf(line, sizeof(line), "Key 0x%x %s\n", keyCode,
                 action == GLFMKeyActionPressed ? "pressed" :
                 action == GLFMKeyActionRepeated ? "repeated" : "released");
        consolePrint(app, line);
        return true;
    } else {
        if (action == GLFMKeyActionPressed || action == GLFMKeyActionRepeated) {
            if (keyCode == GLFMKeyCodeEnter || keyCode == GLFMKeyCodeNumpadEnter) {
                consoleNewline(app);
                return true;
            } else if (keyCode == GLFMKeyCodeBackspace) {
                consoleBackspace(app);
                return true;
            }
        }
        return false;
    }
}

static GLuint compileShader(GLFMDisplay *display, GLenum type, const char *shaderName) {
    char fullPath[PATH_MAX];
    fc_resdir(fullPath, sizeof(fullPath));
    strncat(fullPath, shaderName, sizeof(fullPath) - strlen(fullPath) - 1);

    // Get shader string
    char *shaderString = NULL;
    FILE *shaderFile = fopen(fullPath, "rb");
    if (shaderFile) {
        fseek(shaderFile, 0, SEEK_END);
        long length = ftell(shaderFile);
        fseek(shaderFile, 0, SEEK_SET);

        shaderString = malloc(length + 1);
        if (shaderString) {
            fread(shaderString, length, 1, shaderFile);
            shaderString[length] = 0;
        }
        fclose(shaderFile);
    }
    if (!shaderString) {
        printf("Couldn't read file: %s\n", fullPath);
        return 0;
    }

    // Compile
    const char *constShaderString = shaderString;
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &constShaderString, NULL);
    glCompileShader(shader);
    free(shaderString);

    // Check compile status
    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
    if (status == 0) {
        printf("Couldn't compile shader: %s\n", shaderName);
        GLint logLength;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLength);
        if (logLength > 0) {
            GLchar *log = malloc(logLength);
            glGetShaderInfoLog(shader, logLength, &logLength, log);
            if (log[0] != 0) {
                printf("Shader log: %s\n", log);
            }
            free(log);
        }
        glDeleteShader(shader);
        shader = 0;
    }
    return shader;
}

static void onFocus(GLFMDisplay *display, bool focused) {
    TypingApp *app = glfmGetUserData(display);
    app->focused = focused;
    app->cursorBlinkStartTime = glfmGetTime();
}

static void onSurfaceCreatedOrResized(GLFMDisplay *display, int width, int height) {
    TypingApp *app = glfmGetUserData(display);
    double scale = consoleGetScale(display);

    // Set minimum bottom space
    {
        double bottom;
        glfmGetDisplayChromeInsets(display, NULL, NULL, &bottom, NULL);
        double lineHeight = FONT_CHAR_HEIGHT * scale;
        size_t minimumBottomSpace = 1 + (size_t)floor(bottom / lineHeight);
        if (app->bottomSpacingRequested < minimumBottomSpace) {
            app->bottomSpacingRequested = minimumBottomSpace;
        }
    }

    // Create shader
    if (app->program == 0) {
        GLuint vertShader = compileShader(display, GL_VERTEX_SHADER, "texture.vert");
        GLuint fragShader = compileShader(display, GL_FRAGMENT_SHADER, "texture.frag");
        if (vertShader == 0 || fragShader == 0) {
            return;
        }
        app->program = glCreateProgram();

        glAttachShader(app->program, vertShader);
        glAttachShader(app->program, fragShader);

        glBindAttribLocation(app->program, 0, "position");
        glBindAttribLocation(app->program, 1, "texCoord");

        glLinkProgram(app->program);

        glDeleteShader(vertShader);
        glDeleteShader(fragShader);
    }

    // Create font texture
    if (app->texture == 0) {
        GLsizei textureWidth = TEXTURE_CHARS_X * (FONT_CHAR_WIDTH + TEXTURE_SPACING);
        GLsizei textureHeight = TEXTURE_CHARS_Y * (FONT_CHAR_HEIGHT + TEXTURE_SPACING);
        size_t bpp = 4;
        size_t stride = textureWidth * bpp;
        uint8_t *textureData = malloc(stride * textureHeight);
        for (size_t glyphIndex = 0; glyphIndex < FONT_CHAR_COUNT; glyphIndex++) {
            size_t offset = ((glyphIndex % TEXTURE_CHARS_X) * (FONT_CHAR_WIDTH + TEXTURE_SPACING) * bpp +
                             (glyphIndex / TEXTURE_CHARS_X) * (FONT_CHAR_HEIGHT + TEXTURE_SPACING) * stride);
            for (GLsizei y = 0; y < FONT_CHAR_HEIGHT; y++) {
                unsigned int row = FONT_DATA[glyphIndex][FONT_CHAR_HEIGHT - y - 1];
                for (GLsizei x = 0; x < FONT_CHAR_WIDTH; x++) {
                    GLubyte b = ((row >> x) & 1);
                    textureData[offset++] = b * 0xff;
                    textureData[offset++] = b * 0xff;
                    textureData[offset++] = b * 0xff;
                    textureData[offset++] = b * 0xff;
                }
                memset(textureData + offset, 0, TEXTURE_SPACING * bpp);
                offset += stride - bpp * FONT_CHAR_WIDTH;
            }
            memset(textureData + offset, 0, (FONT_CHAR_WIDTH + TEXTURE_SPACING) * bpp);
        }

        glGenTextures(1, &app->texture);
        glBindTexture(GL_TEXTURE_2D, app->texture);
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, textureWidth, textureHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, textureData);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        free(textureData);
    }

#if defined(GL_VERSION_3_0) && GL_VERSION_3_0
    if (app->vertexArray == 0) {
        glGenVertexArrays(1, &app->vertexArray);
    }
    glBindVertexArray(app->vertexArray);
#endif

    // Create position buffer (re-layout when display size changes)
    {
        float charDX = (float)(2.0 * FONT_CHAR_WIDTH * scale / width);
        float charDY = (float)(2.0 * FONT_CHAR_HEIGHT * scale / height);
        float offsetX = (float)(-CONSOLE_COLS * FONT_CHAR_WIDTH * scale / width);
        float offsetY = -1.0f;
        size_t positionSize = sizeof(GLfloat) * 2;
        size_t positionCount = CONSOLE_MAX_LINES * CONSOLE_COLS * 4;
        GLfloat *positions = malloc(positionSize * positionCount);
        size_t i = 0;
        for (size_t line = 0; line < CONSOLE_MAX_LINES; line++) {
            float y0 = offsetY + charDY * line;
            float y1 = y0 + charDY;
            for (size_t col = 0; col < CONSOLE_COLS; col++) {
                float x0 = offsetX + charDX * col;
                float x1 = x0 + charDX;
                positions[i++] = x0; positions[i++] = y0;
                positions[i++] = x1; positions[i++] = y0;
                positions[i++] = x0; positions[i++] = y1;
                positions[i++] = x1; positions[i++] = y1;
            }
        }
        if (app->positionBuffer == 0) {
            glGenBuffers(1, &app->positionBuffer);
        }
        glBindBuffer(GL_ARRAY_BUFFER, app->positionBuffer);
        glBufferData(GL_ARRAY_BUFFER, positionSize * positionCount, positions, GL_STATIC_DRAW);
        free(positions);
    }

    // Create index buffer
    if (app->indexBuffer == 0) {
        size_t indexSize = sizeof(GLshort);
        size_t indexCount = CONSOLE_MAX_LINES * CONSOLE_COLS * 6;
        GLshort *indices = malloc(indexSize * indexCount);
        size_t i = 0;
        for (size_t line = 0; line < CONSOLE_MAX_LINES; line++) {
            for (size_t col = 0; col < CONSOLE_COLS; col++) {
                indices[i++] = 0 + col * 4 + line * (CONSOLE_COLS * 4);
                indices[i++] = 1 + col * 4 + line * (CONSOLE_COLS * 4);
                indices[i++] = 2 + col * 4 + line * (CONSOLE_COLS * 4);
                indices[i++] = 3 + col * 4 + line * (CONSOLE_COLS * 4);
                indices[i++] = 2 + col * 4 + line * (CONSOLE_COLS * 4);
                indices[i++] = 1 + col * 4 + line * (CONSOLE_COLS * 4);
            }
        }
        glGenBuffers(1, &app->indexBuffer);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, app->indexBuffer);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indexSize * indexCount, indices, GL_STATIC_DRAW);
        free(indices);
    }
}

static void onSurfaceDestroyed(GLFMDisplay *display) {
    TypingApp *app = glfmGetUserData(display);
    app->program = 0;
    app->vertexArray = 0;
    app->positionBuffer = 0;
    app->texCoordBuffer = 0;
    app->indexBuffer = 0;
    app->texture = 0;
}

static void onDraw(GLFMDisplay *display) {
    TypingApp *app = glfmGetUserData(display);
    double frameTime = glfmGetTime();

    // Animate hidden lines
    if (app->bottomSpacingActual != app->bottomSpacingRequested) {
        app->bottomSpacingActual += (app->bottomSpacingRequested > app->bottomSpacingActual) ? 1 : -1;
        app->cursorBlinkStartTime = frameTime;
    }

    // Create texCoord buffer
    size_t i = 0;
    for (size_t screenLine = 0; screenLine < CONSOLE_MAX_LINES; screenLine++) {
        for (size_t col = 0; col < CONSOLE_COLS; col++) {
            uint32_t codePoint = ' ';
            if (screenLine >= app->bottomSpacingActual) {
                size_t line = screenLine - app->bottomSpacingActual;
                if (line < app->consoleLineCount) {
                    if (line == 0 && col == app->consoleCol) {
                        const double cursorBlinkDuration = 0.5;
                        double blink = fmod(frameTime - app->cursorBlinkStartTime, cursorBlinkDuration * 2);
                        codePoint = (app->focused && blink <= cursorBlinkDuration) ? '_' : ' ';
                    } else {
                        codePoint = app->console[(app->consoleLineFirst + line) % CONSOLE_MAX_LINES][col];
                        if (codePoint < FONT_CHAR_FIRST || codePoint >= FONT_CHAR_FIRST + FONT_CHAR_COUNT) {
                            codePoint = ' ';
                        }
                    }
                }
            }
            size_t charIndex = codePoint - FONT_CHAR_FIRST;
            size_t charX = charIndex % TEXTURE_CHARS_X;
            size_t charY = charIndex / TEXTURE_CHARS_X;
            float spaceU = 1.0f / (TEXTURE_CHARS_X * (FONT_CHAR_WIDTH + TEXTURE_SPACING));
            float spaceV = 1.0f / (TEXTURE_CHARS_Y * (FONT_CHAR_HEIGHT + TEXTURE_SPACING));
            float u0 = (float)(charX + 0) / TEXTURE_CHARS_X;
            float v0 = (float)(charY + 0) / TEXTURE_CHARS_Y;
            float u1 = (float)(charX + 1) / TEXTURE_CHARS_X - spaceU;
            float v1 = (float)(charY + 1) / TEXTURE_CHARS_Y - spaceV;
            app->texCoords[i++] = u0; app->texCoords[i++] = v0;
            app->texCoords[i++] = u1; app->texCoords[i++] = v0;
            app->texCoords[i++] = u0; app->texCoords[i++] = v1;
            app->texCoords[i++] = u1; app->texCoords[i++] = v1;
        }
    }
    if (app->texCoordBuffer == 0) {
        glGenBuffers(1, &app->texCoordBuffer);
    }
    glBindBuffer(GL_ARRAY_BUFFER, app->texCoordBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(app->texCoords), app->texCoords, GL_DYNAMIC_DRAW);

    // Draw background
    int width, height;
    glfmGetDisplaySize(display, &width, &height);
    glViewport(0, 0, width, height);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // Draw text
    glUseProgram(app->program);
    glEnable(GL_BLEND);
    glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);

    glBindBuffer(GL_ARRAY_BUFFER, app->positionBuffer);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 2, (void *)0);

    glBindBuffer(GL_ARRAY_BUFFER, app->texCoordBuffer);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 2, (void *)0);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, app->indexBuffer);
    glDrawElements(GL_TRIANGLES, CONSOLE_COLS * CONSOLE_MAX_LINES * 6, GL_UNSIGNED_SHORT, (void *)0);

    // Show
    glfmSwapBuffers(display);
}

void glfmMain(GLFMDisplay *display) {
    TypingApp *app = calloc(1, sizeof(TypingApp));

    glfmSetDisplayConfig(display,
                         GLFMRenderingAPIOpenGLES2,
                         GLFMColorFormatRGBA8888,
                         GLFMDepthFormatNone,
                         GLFMStencilFormatNone,
                         GLFMMultisampleNone);
    glfmSetUserData(display, app);
    glfmSetAppFocusFunc(display, onFocus);
    glfmSetSurfaceCreatedFunc(display, onSurfaceCreatedOrResized);
    glfmSetSurfaceResizedFunc(display, onSurfaceCreatedOrResized);
    glfmSetSurfaceDestroyedFunc(display, onSurfaceDestroyed);
    glfmSetRenderFunc(display, onDraw);
    glfmSetTouchFunc(display, onTouch);
    glfmSetKeyFunc(display, onKey);
    glfmSetCharFunc(display, onChar);
    glfmSetKeyboardVisibilityChangedFunc(display, onKeyboardVisibilityChanged);

    if (glfmHasVirtualKeyboard(display)) {
        consolePrint(app, "Tap to show keyboard\n");
    } else {
        consolePrint(app, "");
    }
}

```

`include/glfm.h`:

```h
// GLFM v0.10.0
//
// GLFM is a C API for mobile app development with OpenGL ES. It is largely inspired by GLFW.
// https://github.com/brackeen/glfm

#ifndef GLFM_H
#define GLFM_H

#if !defined(__APPLE__) && !defined(__ANDROID__) && !defined(__EMSCRIPTEN__)
#  error Unsupported platform
#endif

#if defined(__APPLE__)
#  include <TargetConditionals.h>
#  if !(TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_OSX)
#    error Unsupported Apple platform
#  endif
#  if !defined(GL_SILENCE_DEPRECATION)
#    define GL_SILENCE_DEPRECATION
#  endif
#endif

// OpenGL ES includes

#if defined(GLFM_INCLUDE_ES32)
#  if defined(__ANDROID__)
#    include <GLES3/gl32.h>
#    include <GLES3/gl3ext.h>
#  else
#    error OpenGL ES 3.2 only supported on Android
#  endif
#elif defined(GLFM_INCLUDE_ES31)
#  if defined(__ANDROID__)
#    include <GLES3/gl31.h>
#    include <GLES3/gl3ext.h>
#  else
#    error OpenGL ES 3.1 only supported on Android
#  endif
#elif defined(GLFM_INCLUDE_ES3)
#  if defined(__APPLE__)
#    if TARGET_OS_OSX
#      error OpenGL ES unavailable on macOS
#    else
#      include <OpenGLES/ES3/gl.h>
#      include <OpenGLES/ES3/glext.h>
#    endif
#  elif defined(__EMSCRIPTEN__)
#    include <GLES3/gl3.h>
#    include <GLES3/gl2ext.h>
#  else
#    include <GLES3/gl3.h>
#    include <GLES3/gl3ext.h>
#  endif
#elif !defined(GLFM_INCLUDE_NONE)
#  if defined(__APPLE__)
#    if TARGET_OS_OSX
#      include <OpenGL/gl3.h>
#    else
#      include <OpenGLES/ES2/gl.h>
#      include <OpenGLES/ES2/glext.h>
#    endif
#  else
#    include <GLES2/gl2.h>
#    include <GLES2/gl2ext.h>
#  endif
#endif

#ifdef __GNUC__
#  define GLFM_DEPRECATED(message) __attribute__((deprecated(message)))
#else
#  define GLFM_DEPRECATED(message)
#endif

#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

// MARK: - Enums

typedef enum {
    GLFMRenderingAPIOpenGLES2,
    GLFMRenderingAPIOpenGLES3,
    GLFMRenderingAPIOpenGLES31,
    GLFMRenderingAPIOpenGLES32,
    GLFMRenderingAPIMetal,
} GLFMRenderingAPI;

typedef enum {
    GLFMColorFormatRGBA8888,
    GLFMColorFormatRGB565,
} GLFMColorFormat;

typedef enum {
    GLFMDepthFormatNone,
    GLFMDepthFormat16,
    GLFMDepthFormat24,
    GLFMDepthFormat32,   ///< 32-bit floating point depth in Metal, 24-bit in OpenGL.
} GLFMDepthFormat;

typedef enum {
    GLFMStencilFormatNone,
    GLFMStencilFormat8,
} GLFMStencilFormat;

typedef enum {
    GLFMMultisampleNone,
    GLFMMultisample4X,
} GLFMMultisample;

typedef enum {
    GLFMSwapBehaviorPlatformDefault,
    GLFMSwapBehaviorBufferDestroyed,
    GLFMSwapBehaviorBufferPreserved,
} GLFMSwapBehavior;

/// Defines whether system UI chrome (status bar, navigation bar) is shown.
typedef enum {
    /// Displays the app with the navigation bar.
    ///  - Android: Show the navigation bar.
    ///  - iOS: Show the home indicator.
    GLFMUserInterfaceChromeNavigation,
    /// Displays the app with both the navigation bar and the status bar.
    ///  - Android: Show the navigation bar and status bar.
    ///  - iOS: Show both the home indicator and the status bar.
    GLFMUserInterfaceChromeNavigationAndStatusBar,
    /// Displays the app without any UI chrome.
    ///  - Android 2.3: Fullscreen.
    ///  - Android 4.0 - 4.3: Navigation bar dimmed.
    ///  - Android 4.4: Fullscreen immersive mode.
    ///  - iOS: Show the home indicator dimmed.
    GLFMUserInterfaceChromeNone,
} GLFMUserInterfaceChrome;

enum {
    GLFMUserInterfaceChromeFullscreen GLFM_DEPRECATED("Replaced with GLFMUserInterfaceChromeNone") = GLFMUserInterfaceChromeNone,
};

typedef enum {
    GLFMInterfaceOrientationUnknown = 0,
    GLFMInterfaceOrientationPortrait = (1 << 0),
    GLFMInterfaceOrientationPortraitUpsideDown = (1 << 1),
    GLFMInterfaceOrientationLandscapeLeft = (1 << 2),
    GLFMInterfaceOrientationLandscapeRight = (1 << 3),
    GLFMInterfaceOrientationLandscape = (GLFMInterfaceOrientationLandscapeLeft |
                                         GLFMInterfaceOrientationLandscapeRight),
    GLFMInterfaceOrientationAll = (GLFMInterfaceOrientationPortrait |
                                   GLFMInterfaceOrientationPortraitUpsideDown |
                                   GLFMInterfaceOrientationLandscapeLeft |
                                   GLFMInterfaceOrientationLandscapeRight),
    GLFMInterfaceOrientationAllButUpsideDown = (GLFMInterfaceOrientationPortrait |
                                                GLFMInterfaceOrientationLandscapeLeft |
                                                GLFMInterfaceOrientationLandscapeRight),
} GLFMInterfaceOrientation;

/// *Deprecated:* See ``GLFMInterfaceOrientation``.
typedef enum {
    GLFMUserInterfaceOrientationAny GLFM_DEPRECATED("Replaced with GLFMInterfaceOrientationAll") = GLFMInterfaceOrientationAll,
    GLFMUserInterfaceOrientationPortrait GLFM_DEPRECATED("Replaced with GLFMInterfaceOrientationPortrait") = GLFMInterfaceOrientationPortrait,
    GLFMUserInterfaceOrientationLandscape GLFM_DEPRECATED("Replaced with GLFMInterfaceOrientationLandscape") = GLFMInterfaceOrientationLandscape,
} GLFMUserInterfaceOrientation GLFM_DEPRECATED("Replaced with GLFMInterfaceOrientation");

typedef enum {
    GLFMTouchPhaseHover,
    GLFMTouchPhaseBegan,
    GLFMTouchPhaseMoved,
    GLFMTouchPhaseEnded,
    GLFMTouchPhaseCancelled,
} GLFMTouchPhase;

typedef enum {
    GLFMMouseCursorAuto,
    GLFMMouseCursorNone,
    GLFMMouseCursorDefault,
    GLFMMouseCursorPointer,
    GLFMMouseCursorCrosshair,
    GLFMMouseCursorText,
    GLFMMouseCursorVerticalText,
} GLFMMouseCursor;

typedef enum {
    GLFMMouseWheelDeltaPixel,
    GLFMMouseWheelDeltaLine,
    GLFMMouseWheelDeltaPage
} GLFMMouseWheelDeltaType;

typedef enum {
    GLFMKeyCodeUnknown           = 0x00,

    // The key codes below have the same values as ASCII codes (uppercase)

    GLFMKeyCodeBackspace         = 0x08, ///< Backspace key ("delete" on Apple platforms).
    GLFMKeyCodeTab               = 0x09,
    GLFMKeyCodeEnter             = 0x0D, ///< Enter key ("return" on Apple platforms).
    GLFMKeyCodeEscape            = 0x1B,
    GLFMKeyCodeSpace             = 0x20,
    GLFMKeyCodeQuote             = 0x27,
    GLFMKeyCodeComma             = 0x2C,
    GLFMKeyCodeMinus             = 0x2D,
    GLFMKeyCodePeriod            = 0x2E,
    GLFMKeyCodeSlash             = 0x2F,
    GLFMKeyCode0                 = 0x30,
    GLFMKeyCode1                 = 0x31,
    GLFMKeyCode2                 = 0x32,
    GLFMKeyCode3                 = 0x33,
    GLFMKeyCode4                 = 0x34,
    GLFMKeyCode5                 = 0x35,
    GLFMKeyCode6                 = 0x36,
    GLFMKeyCode7                 = 0x37,
    GLFMKeyCode8                 = 0x38,
    GLFMKeyCode9                 = 0x39,
    GLFMKeyCodeSemicolon         = 0x3B,
    GLFMKeyCodeEqual             = 0x3D,
    GLFMKeyCodeA                 = 0x41,
    GLFMKeyCodeB                 = 0x42,
    GLFMKeyCodeC                 = 0x43,
    GLFMKeyCodeD                 = 0x44,
    GLFMKeyCodeE                 = 0x45,
    GLFMKeyCodeF                 = 0x46,
    GLFMKeyCodeG                 = 0x47,
    GLFMKeyCodeH                 = 0x48,
    GLFMKeyCodeI                 = 0x49,
    GLFMKeyCodeJ                 = 0x4A,
    GLFMKeyCodeK                 = 0x4B,
    GLFMKeyCodeL                 = 0x4C,
    GLFMKeyCodeM                 = 0x4D,
    GLFMKeyCodeN                 = 0x4E,
    GLFMKeyCodeO                 = 0x4F,
    GLFMKeyCodeP                 = 0x50,
    GLFMKeyCodeQ                 = 0x51,
    GLFMKeyCodeR                 = 0x52,
    GLFMKeyCodeS                 = 0x53,
    GLFMKeyCodeT                 = 0x54,
    GLFMKeyCodeU                 = 0x55,
    GLFMKeyCodeV                 = 0x56,
    GLFMKeyCodeW                 = 0x57,
    GLFMKeyCodeX                 = 0x58,
    GLFMKeyCodeY                 = 0x59,
    GLFMKeyCodeZ                 = 0x5A,
    GLFMKeyCodeBracketLeft       = 0x5B,
    GLFMKeyCodeBackslash         = 0x5C,
    GLFMKeyCodeBracketRight      = 0x5D,
    GLFMKeyCodeBackquote         = 0x60, ///< Backquote, AKA grave.
    GLFMKeyCodeDelete            = 0x7F, ///< Delete key ("forward delete" on Apple platforms).

    // Non-ASCII keys. These values may change in the future.

    GLFMKeyCodeCapsLock          = 0x80,
    GLFMKeyCodeShiftLeft         = 0x81,
    GLFMKeyCodeShiftRight        = 0x82,
    GLFMKeyCodeControlLeft       = 0x83,
    GLFMKeyCodeControlRight      = 0x84,
    GLFMKeyCodeAltLeft           = 0x85, ///< Left alt key (option key on Apple platforms).
    GLFMKeyCodeAltRight          = 0x86, ///< Right alt key (option key on Apple platforms).
    GLFMKeyCodeMetaLeft          = 0x87, ///< Left meta key (command key on Apple platforms).
    GLFMKeyCodeMetaRight         = 0x88, ///< Right meta key (command key on Apple platforms).
    GLFMKeyCodeMenu              = 0x89, ///< Menu key, AKA context menu.

    GLFMKeyCodeInsert            = 0x90,
    GLFMKeyCodePageUp            = 0x91,
    GLFMKeyCodePageDown          = 0x92,
    GLFMKeyCodeEnd               = 0x93,
    GLFMKeyCodeHome              = 0x94,
    GLFMKeyCodeArrowLeft         = 0x95,
    GLFMKeyCodeArrowUp           = 0x96,
    GLFMKeyCodeArrowRight        = 0x97,
    GLFMKeyCodeArrowDown         = 0x98,

    GLFMKeyCodePower             = 0x99,
    GLFMKeyCodeFunction          = 0x9A, ///< Fn key on Apple platforms.
    GLFMKeyCodePrintScreen       = 0x9B, ///< Print Screen or System Request key.
    GLFMKeyCodeScrollLock        = 0x9C,
    GLFMKeyCodePause             = 0x9D, ///< Pause/Break key.

    GLFMKeyCodeNumLock           = 0xA0, ///< NumLock key ("clear" on Apple platforms).
    GLFMKeyCodeNumpadDecimal     = 0xA1,
    GLFMKeyCodeNumpadMultiply    = 0xA2,
    GLFMKeyCodeNumpadAdd         = 0xA3,
    GLFMKeyCodeNumpadDivide      = 0xA4,
    GLFMKeyCodeNumpadEnter       = 0xA5,
    GLFMKeyCodeNumpadSubtract    = 0xA6,
    GLFMKeyCodeNumpadEqual       = 0xA7,

    GLFMKeyCodeNumpad0           = 0xB0,
    GLFMKeyCodeNumpad1           = 0xB1,
    GLFMKeyCodeNumpad2           = 0xB2,
    GLFMKeyCodeNumpad3           = 0xB3,
    GLFMKeyCodeNumpad4           = 0xB4,
    GLFMKeyCodeNumpad5           = 0xB5,
    GLFMKeyCodeNumpad6           = 0xB6,
    GLFMKeyCodeNumpad7           = 0xB7,
    GLFMKeyCodeNumpad8           = 0xB8,
    GLFMKeyCodeNumpad9           = 0xB9,

    GLFMKeyCodeF1                = 0xC1,
    GLFMKeyCodeF2                = 0xC2,
    GLFMKeyCodeF3                = 0xC3,
    GLFMKeyCodeF4                = 0xC4,
    GLFMKeyCodeF5                = 0xC5,
    GLFMKeyCodeF6                = 0xC6,
    GLFMKeyCodeF7                = 0xC7,
    GLFMKeyCodeF8                = 0xC8,
    GLFMKeyCodeF9                = 0xC9,
    GLFMKeyCodeF10               = 0xD0,
    GLFMKeyCodeF11               = 0xD1,
    GLFMKeyCodeF12               = 0xD2,
    GLFMKeyCodeF13               = 0xD3,
    GLFMKeyCodeF14               = 0xD4,
    GLFMKeyCodeF15               = 0xD5,
    GLFMKeyCodeF16               = 0xD6,
    GLFMKeyCodeF17               = 0xD7,
    GLFMKeyCodeF18               = 0xD8,
    GLFMKeyCodeF19               = 0xD9,
    GLFMKeyCodeF20               = 0xDA,
    GLFMKeyCodeF21               = 0xDB,
    GLFMKeyCodeF22               = 0xDC,
    GLFMKeyCodeF23               = 0xDD,
    GLFMKeyCodeF24               = 0xDE,

    GLFMKeyCodeNavigationBack    = 0xE0, ///< Back button on Android, menu/back button on tvOS remote.
    GLFMKeyCodeMediaSelect       = 0xE1, ///< Select button on tvOS remote.
    GLFMKeyCodeMediaPlayPause    = 0xE2, ///< Play/pause button on tvOS remote.
} GLFMKeyCode;

typedef GLFMKeyCode GLFMKey GLFM_DEPRECATED("Replaced with GLFMKeyCode");

enum {
    GLFMKeyBackspace GLFM_DEPRECATED("Replaced with GLFMKeyCodeBackspace") = GLFMKeyCodeBackspace,
    GLFMKeyTab GLFM_DEPRECATED("Replaced with GLFMKeyCodeTab") = GLFMKeyCodeTab,
    GLFMKeyEnter GLFM_DEPRECATED("Replaced with GLFMKeyCodeEnter") = GLFMKeyCodeEnter,
    GLFMKeyEscape GLFM_DEPRECATED("Replaced with GLFMKeyCodeEscape") = GLFMKeyCodeEscape,
    GLFMKeySpace GLFM_DEPRECATED("Replaced with GLFMKeyCodeSpace") = GLFMKeyCodeSpace,
    GLFMKeyPageUp GLFM_DEPRECATED("Replaced with GLFMKeyCodePageUp") = GLFMKeyCodePageUp,
    GLFMKeyPageDown GLFM_DEPRECATED("Replaced with GLFMKeyCodePageDown") = GLFMKeyCodePageDown,
    GLFMKeyEnd GLFM_DEPRECATED("Replaced with GLFMKeyCodeEnd") = GLFMKeyCodeEnd,
    GLFMKeyHome GLFM_DEPRECATED("Replaced with GLFMKeyCodeHome") = GLFMKeyCodeHome,
    GLFMKeyLeft GLFM_DEPRECATED("Replaced with GLFMKeyCodeArrowLeft") = GLFMKeyCodeArrowLeft,
    GLFMKeyUp GLFM_DEPRECATED("Replaced with GLFMKeyCodeArrowUp") = GLFMKeyCodeArrowUp,
    GLFMKeyRight GLFM_DEPRECATED("Replaced with GLFMKeyCodeArrowRight") = GLFMKeyCodeArrowRight,
    GLFMKeyDown GLFM_DEPRECATED("Replaced with GLFMKeyCodeArrowDown") = GLFMKeyCodeArrowDown,
    GLFMKeyDelete GLFM_DEPRECATED("Replaced with GLFMKeyCodeDelete") = GLFMKeyCodeDelete,
    GLFMKeyNavBack GLFM_DEPRECATED("Replaced with GLFMKeyCodeNavigationBack") = GLFMKeyCodeNavigationBack,
    GLFMKeyNavMenu GLFM_DEPRECATED("Replaced with GLFMKeyCodeMenu") = GLFMKeyCodeMenu,
    GLFMKeyNavSelect GLFM_DEPRECATED("Replaced with GLFMKeyCodeMediaSelect") = GLFMKeyCodeMediaSelect,
    GLFMKeyPlayPause GLFM_DEPRECATED("Replaced with GLFMKeyCodeMediaPlayPause") = GLFMKeyCodeMediaPlayPause,
};

typedef enum {
    GLFMKeyModifierShift    = (1 << 0), ///< Flag indicating a shift key is down.
    GLFMKeyModifierControl  = (1 << 1), ///< Flag indicating a control (ctrl) key is down.
    GLFMKeyModifierAlt      = (1 << 2), ///< Flag indicating an alt key is down (option key on Apple platforms).
    GLFMKeyModifierMeta     = (1 << 3), ///< Flag indicating a meta key is down (command key on Apple platforms).
    GLFMKeyModifierFunction = (1 << 4), ///< Flag indicating a function (fn) key is down on Apple platforms.
} GLFMKeyModifier;

enum {
    GLFMKeyModifierCtrl GLFM_DEPRECATED("Replaced with GLFMKeyModifierControl") = GLFMKeyModifierControl,
};

typedef enum {
    GLFMKeyActionPressed,
    GLFMKeyActionRepeated,
    GLFMKeyActionReleased,
} GLFMKeyAction;

/// The hardware sensor type. See ``glfmIsSensorAvailable`` and ``glfmSetSensorFunc``.
typedef enum {
    /// Accelerometer sensor.
    /// In ``GLFMSensorFunc``, the `GLFMSensorEvent` vector is the acceleration in G's.
    GLFMSensorAccelerometer,
    /// Magnetometer sensor.
    /// In ``GLFMSensorFunc``, the `GLFMSensorEvent` vector is the magnetic field in microteslas.
    GLFMSensorMagnetometer,
    /// Gyroscope sensor.
    /// In ``GLFMSensorFunc``, the `GLFMSensorEvent` vector is the rotation rate in radians/second.
    GLFMSensorGyroscope,
    /// Rotation sensor.
    /// In ``GLFMSensorFunc``, the `GLFMSensorEvent` matrix is the rotation matrix where the
    /// X axis points North and the Z axis is vertical.
    GLFMSensorRotationMatrix,
} GLFMSensor;

typedef enum {
    GLFMHapticFeedbackLight,
    GLFMHapticFeedbackMedium,
    GLFMHapticFeedbackHeavy,
} GLFMHapticFeedbackStyle;

// MARK: - Structs and function pointers

typedef struct GLFMDisplay GLFMDisplay;

/// Function pointer returned from ``glfmGetProcAddress``.
typedef void (*GLFMProc)(void);

/// Render callback function. See ``glfmSetRenderFunc``.
typedef void (*GLFMRenderFunc)(GLFMDisplay *display);

/// *Deprecated:* Use ``GLFMRenderFunc``.
typedef void (*GLFMMainLoopFunc)(GLFMDisplay *display, double frameTime)
GLFM_DEPRECATED("See glfmSetRenderFunc and glfmSwapBuffers");

/// Callback function when mouse or touch events occur. See ``glfmSetTouchFunc``.
///
/// - Parameters:
///   - touch: The touch number (zero for primary touch, 1+ for multitouch), or the mouse button number (zero for the
///            primary button, 1 for secondary, etc.).
///   - phase: The touch phase.
///   - x: The x location of the event, in pixels.
///   - y: The y location of the event, in pixels.
/// - Returns: `true` if the event was handled, `false` otherwise.
typedef bool (*GLFMTouchFunc)(GLFMDisplay *display, int touch, GLFMTouchPhase phase, double x, double y);

/// Callback function when key events occur. See ``glfmSetKeyFunc``.
///
/// For each key press, this function is called before ``GLFMCharFunc``.
///
/// - Android and tvOS: When the user presses the back button (`GLFMKeyCodeNavigationBack`), this function should return
///   `false` to allow the user to exit the app, or return `true` if the back button was handled in-app.
/// - Returns: `true` if the event was handled, `false` otherwise.
typedef bool (*GLFMKeyFunc)(GLFMDisplay *display, GLFMKeyCode keyCode, GLFMKeyAction action, int modifiers);

/// Callback function when character input events occur. See ``glfmSetCharFunc``.
///
/// - Parameters:
///   - string: A NULL-terminated UTF-8 string. The string is only valid during the callback, and should be copied if it
///             is needed after the callback returns. The string is never NULL.
///   - modifier: Deprecated and always set to 0.
typedef void (*GLFMCharFunc)(GLFMDisplay *display, const char *string, int modifiers);

/// Callback function when clipboard text is received. See ``glfmRequestClipboardText``.
///
/// - Parameters:
///   - string: A NULL-terminated UTF-8 string. The string is only valid during the callback, and should be copied if it
///             is needed after the callback returns. May be NULL if there is no text in the clipboard, or if the text
///             could not be converted to UTF-8.
typedef void (*GLFMClipboardTextFunc)(GLFMDisplay *display, const char *string);

/// Callback function when mouse wheel input events occur. See ``glfmSetMouseWheelFunc``.
/// - Parameters:
///   - x: The x location of the event, in pixels.
///   - y: The y location of the event, in pixels.
/// - Returns: `true` if the event was handled, `false` otherwise.
typedef bool (*GLFMMouseWheelFunc)(GLFMDisplay *display, double x, double y, GLFMMouseWheelDeltaType deltaType,
                                   double deltaX, double deltaY, double deltaZ);

/// Callback function when the virtual keyboard visibility changes.
/// See ``glfmSetKeyboardVisibilityChangedFunc``.
typedef void (*GLFMKeyboardVisibilityChangedFunc)(GLFMDisplay *display, bool visible, double x, double y,
                                                  double width, double height);

/// Callback function when the app interface orientation changes.
/// See ``glfmSetOrientationChangedFunc``.
typedef void (*GLFMOrientationChangedFunc)(GLFMDisplay *display, GLFMInterfaceOrientation orientation);

/// Callback function when the chrome insets ("safe area insets") changes.
/// See ``glfmSetDisplayChromeInsetsChangedFunc`` and ``glfmGetDisplayChromeInsets``.
typedef void (*GLFMDisplayChromeInsetsChangedFunc)(GLFMDisplay *display, double top, double right,
                                                   double bottom, double left);

/// Callback function when the surface could not be created.
/// See ``glfmSetSurfaceErrorFunc``.
typedef void (*GLFMSurfaceErrorFunc)(GLFMDisplay *display, const char *message);

/// Callback function when the OpenGL surface was created.
/// See ``glfmSetSurfaceCreatedFunc``.
typedef void (*GLFMSurfaceCreatedFunc)(GLFMDisplay *display, int width, int height);

/// Callback function when the OpenGL surface was resized (or rotated).
/// See ``glfmSetSurfaceResizedFunc``.
typedef void (*GLFMSurfaceResizedFunc)(GLFMDisplay *display, int width, int height);

/// Callback function to notify that the surface needs to be redrawn.
/// See ``glfmSetSurfaceRefreshFunc``.
typedef void (*GLFMSurfaceRefreshFunc)(GLFMDisplay *display);

/// Callback function when the OpenGL surface was destroyed.
/// See ``glfmSetSurfaceDestroyedFunc``.
typedef void (*GLFMSurfaceDestroyedFunc)(GLFMDisplay *display);

/// Callback function when the system receives a low memory warning.
/// See ``glfmSetMemoryWarningFunc``.
typedef void (*GLFMMemoryWarningFunc)(GLFMDisplay *display);

/// Callback function when the app loses or gains focus. See ``glfmSetAppFocusFunc``.
///
/// This function is called on startup after `glfmMain()`.
///
/// - Emscripten: This function is called when switching browser tabs and
/// before the page is unloaded.
typedef void (*GLFMAppFocusFunc)(GLFMDisplay *display, bool focused);

/// The result used in the hardware sensor callback. See ``glfmSetSensorFunc``.
///
/// The `vector` is used for all sensor types except for `GLFMSensorRotationMatrix`,
/// which uses `matrix`.
typedef struct {
    /// The sensor type
    GLFMSensor sensor;
    /// The timestamp of the event, which may not be related to wall-clock time.
    double timestamp;
    union {
        /// A three-dimensional vector.
        struct {
            double x, y, z;
        } vector;
        /// A 3x3 matrix.
        struct {
            double m00, m01, m02;
            double m10, m11, m12;
            double m20, m21, m22;
        } matrix;
    };
} GLFMSensorEvent;

/// Callback function when sensor events occur. See ``glfmSetSensorFunc``.
typedef void (*GLFMSensorFunc)(GLFMDisplay *display, GLFMSensorEvent event);

// MARK: - Functions

/// Main entry point for a GLFM app.
///
/// In this function, call ``glfmSetDisplayConfig`` and ``glfmSetRenderFunc``.
extern void glfmMain(GLFMDisplay *display);

/// Sets the requested display configuration.
///
/// This function should only be called in ``glfmMain``.
///
/// If the device does not support the preferred rendering API, the next available rendering API is used (OpenGL ES 2.0
/// if OpenGL ES 3.0 is not available, for example). Call ``glfmGetRenderingAPI`` in the ``GLFMSurfaceCreatedFunc`` to
/// check which rendering API is used.
void glfmSetDisplayConfig(GLFMDisplay *display,
                          GLFMRenderingAPI preferredAPI,
                          GLFMColorFormat colorFormat,
                          GLFMDepthFormat depthFormat,
                          GLFMStencilFormat stencilFormat,
                          GLFMMultisample multisample);

/// Sets the user data pointer.
///
/// The data is neither read nor modified. See ``glfmGetUserData``.
void glfmSetUserData(GLFMDisplay *display, void *userData);

/// Gets the user data pointer.
///
/// See ``glfmSetUserData``.
void *glfmGetUserData(const GLFMDisplay *display);

/// Swap buffers.
///
/// This function should be called at the end of the ``GLFMRenderFunc`` if any content was rendered.
///
/// - Emscripten: This function does nothing. Buffer swapping happens automatically if any OpenGL calls were made.
///
/// - Apple platforms: When using the Metal rendering API, this function does nothing. Presenting the Metal drawable
///                    must happen in application code.
void glfmSwapBuffers(GLFMDisplay *display);

/// *Deprecated:* Use ``glfmGetSupportedInterfaceOrientation``.
GLFMUserInterfaceOrientation glfmGetUserInterfaceOrientation(GLFMDisplay *display)
GLFM_DEPRECATED("Replaced with glfmGetSupportedInterfaceOrientation");

/// *Deprecated:* Use ``glfmSetSupportedInterfaceOrientation``.
void glfmSetUserInterfaceOrientation(GLFMDisplay *display, GLFMUserInterfaceOrientation supportedOrientations)
GLFM_DEPRECATED("Replaced with glfmSetSupportedInterfaceOrientation");

/// Returns the supported user interface orientations. Default is `GLFMInterfaceOrientationAll`.
///
/// Actual support may be limited by the device or platform.
GLFMInterfaceOrientation glfmGetSupportedInterfaceOrientation(const GLFMDisplay *display);

/// Sets the supported user interface orientations.
///
/// Typical values are `GLFMInterfaceOrientationAll`, `GLFMInterfaceOrientationPortrait`, or
/// `GLFMInterfaceOrientationLandscape.`
///
/// Actual support may be limited by the device or platform.
void glfmSetSupportedInterfaceOrientation(GLFMDisplay *display, GLFMInterfaceOrientation supportedOrientations);

/// Gets the current user interface orientation.
///
/// - Returns: Either `GLFMInterfaceOrientationPortrait`, `GLFMInterfaceOrientationLandscapeLeft`,
///   `GLFMInterfaceOrientationLandscapeRight`, `GLFMInterfaceOrientationPortraitUpsideDown`, or
///   `GLFMInterfaceOrientationUnknown`.
GLFMInterfaceOrientation glfmGetInterfaceOrientation(const GLFMDisplay *display);

/// Gets the display size, in pixels.
///
/// The arguments for the `width` and `height` parameters may be `NULL`.
void glfmGetDisplaySize(const GLFMDisplay *display, int *width, int *height);

/// Gets the display scale.
///
/// On Apple platforms, the value will be 1.0 for non-retina displays and 2.0 for retina. Similar values will be
/// returned for Android and Emscripten.
double glfmGetDisplayScale(const GLFMDisplay *display);

/// Gets the chrome insets, in pixels (AKA "safe area insets" in iOS).
///
/// The "insets" are the space taken on the outer edges of the display by status bars, navigation bars, and other UI
/// elements.
///
/// The arguments for the `top`, `right`, `bottom`, and `left` parameters may be `NULL`.
void glfmGetDisplayChromeInsets(const GLFMDisplay *display, double *top, double *right, double *bottom, double *left);

/// Gets the current user interface chrome (status bar and navigation bar status).
GLFMUserInterfaceChrome glfmGetDisplayChrome(const GLFMDisplay *display);

/// Sets the user interface chrome.
///
/// This may modify the chrome insets, but not immediately. Use ``glfmSetDisplayChromeInsetsChangedFunc`` to be notified
/// when insets change.
///
/// - Emscripten: To switch to fullscreen, this function must be called from an user-generated event handler.
void glfmSetDisplayChrome(GLFMDisplay *display, GLFMUserInterfaceChrome uiChrome);

/// Gets the rendering API of the display.
///
/// Defaults to `GLFMRenderingAPIOpenGLES2`.
///
/// The return value is not valid until the surface is created.
GLFMRenderingAPI glfmGetRenderingAPI(const GLFMDisplay *display);

/// Sets the swap behavior for newly created surfaces (Android only).
///
/// In order to take effect, the behavior should be set before the surface is created, preferable at the very beginning
/// of the ``glfmMain`` function.
void glfmSetSwapBehavior(GLFMDisplay *display, GLFMSwapBehavior behavior);

/// Returns the swap buffer behavior.
GLFMSwapBehavior glfmGetSwapBehavior(const GLFMDisplay *display);

/// Gets the address of the specified function.
GLFMProc glfmGetProcAddress(const char *functionName);

/// Gets whether there is currently text available in the system clipboard.
///
/// - Emscripten: Returns true if the Clipboard API is available. It is not possible to know if text is available in the
///               system clipboard until it is requested.
/// - tvOS: No clipboard API is available. Always returns false.
bool glfmHasClipboardText(const GLFMDisplay *display);

/// Requests the system clipboard text.
///
/// The `clipboardTextFunc` callback may be invoked after a delay because the clipboard text may be retrieved from the
/// network (iCloud clipboard) or may require user confirmation (web dialog) before proceeding.
///
/// The `clipboardTextFunc` callback is invoked only once.
///
/// If there was no text in the clipboard, the `clipboardTextFunc` callback is invoked with a NULL string.
///
/// - Emscripten: On some browsers, this function can only be called in an event handler, like ``GLFMTouchFunc`` or
///               ``GLFMKeyFunc``. Currently, Firefox does not support reading from the clipboard.
/// - tvOS: No clipboard API is available. The `clipboardTextFunc` callback is invoked with a NULL string.
void glfmRequestClipboardText(GLFMDisplay *display, GLFMClipboardTextFunc clipboardTextFunc);

/// Set the system clipboard text.
///
/// - tvOS: No clipboard API is available. Always returns false.
///
/// - Parameters:
///   - string: A NULL-terminated UTF-8 string.
/// - Returns: `true` on success, `false` otherwise.
bool glfmSetClipboardText(GLFMDisplay *display, const char *string);

/// Gets the value of the highest precision time available, in seconds.
///
/// The time should not be considered related to wall-clock time.
double glfmGetTime(void);

// MARK: - Callback functions

/// Sets the function to call before each frame is displayed.
///
/// This function is called at regular intervals (typically 60fps). Applications will typically render in this callback.
/// If the application rendered any content, the application should call ``glfmSwapBuffers`` before returning. If the
/// application did not render content, it should return without calling ``glfmSwapBuffers``.
GLFMRenderFunc glfmSetRenderFunc(GLFMDisplay *display, GLFMRenderFunc renderFunc);

/// *Deprecated:* Use ``glfmSetRenderFunc``.
///
/// If this function is set, ``glfmSwapBuffers`` is called after calling the `GLFMMainLoopFunc`.
GLFMMainLoopFunc glfmSetMainLoopFunc(GLFMDisplay *display, GLFMMainLoopFunc mainLoopFunc)
GLFM_DEPRECATED("See glfmSetRenderFunc and glfmSwapBuffers");

/// Sets the function to call when the surface could not be created.
///
/// For example, the browser does not support WebGL.
GLFMSurfaceErrorFunc glfmSetSurfaceErrorFunc(GLFMDisplay *display, GLFMSurfaceErrorFunc surfaceErrorFunc);

/// Sets the function to call when the surface was created.
GLFMSurfaceCreatedFunc glfmSetSurfaceCreatedFunc(GLFMDisplay *display, GLFMSurfaceCreatedFunc surfaceCreatedFunc);

/// Sets the function to call when the surface was resized (or rotated).
GLFMSurfaceResizedFunc glfmSetSurfaceResizedFunc(GLFMDisplay *display, GLFMSurfaceResizedFunc surfaceResizedFunc);

/// Sets the function to call to notify that the surface needs to be redrawn.
///
/// This callback is called when returning from the background, or when the device was rotated. The `GLFMRenderFunc`
/// is called immediately after `GLFMSurfaceRefreshFunc`.
GLFMSurfaceRefreshFunc glfmSetSurfaceRefreshFunc(GLFMDisplay *display, GLFMSurfaceRefreshFunc surfaceRefreshFunc);

/// Sets the function to call when the surface was destroyed.
///
/// The surface may be destroyed during OpenGL context loss.  All OpenGL resources should be deleted in this call.
GLFMSurfaceDestroyedFunc glfmSetSurfaceDestroyedFunc(GLFMDisplay *display,
                                                     GLFMSurfaceDestroyedFunc surfaceDestroyedFunc);

/// Sets the function to call when app interface orientation changes.
GLFMOrientationChangedFunc glfmSetOrientationChangedFunc(GLFMDisplay *display,
                                                         GLFMOrientationChangedFunc orientationChangedFunc);

/// Sets the function to call when display chrome insets ("safe area insets") changes.
/// See also ``glfmGetDisplayChromeInsets``
GLFMDisplayChromeInsetsChangedFunc
glfmSetDisplayChromeInsetsChangedFunc(GLFMDisplay *display, GLFMDisplayChromeInsetsChangedFunc chromeInsetsChangedFunc);

/// Sets the function to call when the system sends a "low memory" warning.
GLFMMemoryWarningFunc glfmSetMemoryWarningFunc(GLFMDisplay *display, GLFMMemoryWarningFunc lowMemoryFunc);

/// Sets the function to call when the app loses or gains focus (goes into the background or returns from the
/// background).
GLFMAppFocusFunc glfmSetAppFocusFunc(GLFMDisplay *display, GLFMAppFocusFunc focusFunc);

// MARK: - Input functions

/// Sets whether multitouch input is enabled. By default, multitouch is disabled.
///
/// - tvOS: This function does nothing.
void glfmSetMultitouchEnabled(GLFMDisplay *display, bool multitouchEnabled);

/// Gets whether multitouch input is enabled. By default, multitouch is disabled.
///
/// - tvOS: Always returns false.
bool glfmGetMultitouchEnabled(const GLFMDisplay *display);

/// Gets whether the display has touch capabilities.
bool glfmHasTouch(const GLFMDisplay *display);

/// Checks if a hardware sensor is available.
///
/// - Emscripten: Always returns `false`.
bool glfmIsSensorAvailable(const GLFMDisplay *display, GLFMSensor sensor);

/// Sets the mouse cursor (only on platforms with a mouse).
void glfmSetMouseCursor(GLFMDisplay *display, GLFMMouseCursor mouseCursor);

/// Gets whether a virtual onscreen keyboard can be displayed.
///
/// Returns `true` on iOS and Android, `false` on other platforms.
bool glfmHasVirtualKeyboard(const GLFMDisplay *display);

/// Requests to show or hide the onscreen virtual keyboard.
///
/// On iPad, if a hardware keyboard is attached, the virtual keyboard will not actually be shown.
///
/// - Emscripten: this function does nothing.
/// - tvOS: This function does nothing.
void glfmSetKeyboardVisible(GLFMDisplay *display, bool visible);

/// Returns `true` if the virtual keyboard is currently visible.
///
/// - Emscripten: Always returns false.
/// - tvOS: Always returns false.
bool glfmIsKeyboardVisible(const GLFMDisplay *display);

/// Sets the function to call when the virtual keyboard changes visibility or changes bounds.
GLFMKeyboardVisibilityChangedFunc
glfmSetKeyboardVisibilityChangedFunc(GLFMDisplay *display, GLFMKeyboardVisibilityChangedFunc visibilityChangedFunc);

/// Sets the function to call when a mouse or touch event occurs.
GLFMTouchFunc glfmSetTouchFunc(GLFMDisplay *display, GLFMTouchFunc touchFunc);

/// Sets the function to call when a key event occurs.
///
/// - iOS and tvOS: Key events require iOS 13.4 and tvOS 13.4. No repeated events (`GLFMKeyActionRepeated`) are sent.
///
/// - iOS and Android: Use ``glfmSetKeyboardVisible`` to show the virtual keyboard.
///
/// - Android and tvOS: When the user presses the back button (`GLFMKeyCodeNavigationBack`), the `GLFMKeyFunc` function
///                     should return `false` to allow the user to exit the app, or return `true` if the back button
///                     was handled in-app.
GLFMKeyFunc glfmSetKeyFunc(GLFMDisplay *display, GLFMKeyFunc keyFunc);

/// Sets the function to call when character input events occur.
///
/// Character events occur when a user types with a virtual keyboard on iOS and Android, or when typing with a connected
/// physical keyboard.
///
/// On iOS and Android, use ``glfmSetKeyboardVisible`` to show the virtual keyboard.
///
/// The callback function is called for key repeat events in some case, but not all. No repeat events occur in the
/// following situations:
/// * Android virtual keyboard (Except for the backspace key, which does send repeat events).
/// * iOS virtual keyboard.
/// * tvOS physical keyboard.
///
/// On Android, non-ASCII characters are not automatically received due to a limitation in the NDK. To receive them, add
/// this code in your `Activity`:
///
/// ```
/// public class MyActivity extends NativeActivity {
///
///     // Send unicode keyboard input to GLFM (using keycode value Integer.MAX_VALUE)
///     // Override
///     public boolean dispatchKeyEvent(KeyEvent event) {
///         if (event.getKeyCode() == KeyEvent.KEYCODE_UNKNOWN && event.getCharacters() != null &&
///             getWindow() != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
///             String s = event.getCharacters();
///             for (int offset = 0; offset < s.length(); ) {
///                 int codepoint = s.codePointAt(offset);
///                 getWindow().injectInputEvent(new KeyEvent(event.getDownTime(), event.getEventTime(),
///                     KeyEvent.ACTION_DOWN, Integer.MAX_VALUE, 0, 0, 0, codepoint));
///                 offset += Character.charCount(codepoint);
///             }
///             return true;
///         }
///         return super.dispatchKeyEvent(event);
///     }
/// }
/// ```
/// This code intercepts character events and re-dispatches them with the unicode values to GLFM.
GLFMCharFunc glfmSetCharFunc(GLFMDisplay *display, GLFMCharFunc charFunc);

/// Sets the function to call when the mouse wheel is moved.
///
/// Only enabled on Emscripten.
GLFMMouseWheelFunc glfmSetMouseWheelFunc(GLFMDisplay *display, GLFMMouseWheelFunc mouseWheelFunc);

/// Sets the function to call when the hardware sensor events occur for a particular sensor.
///
/// If the hardware sensor is not available, this function does nothing. See ``glfmIsSensorAvailable``.
///
/// Each ``GLFMSensor`` type can have its own ``GLFMSensorFunc``.
///
/// The hardware sensor is enabled when the `sensorFunc` is not `NULL`.
///
/// Sensor events can drain battery. To save battery, when sensor events are not needed, set the `sensorFunc` to `NULL`
/// to disable the sensor.
///
/// Sensors are automatically disabled when the app is inactive, and re-enabled when active again.
GLFMSensorFunc glfmSetSensorFunc(GLFMDisplay *display, GLFMSensor sensor, GLFMSensorFunc sensorFunc);

// MARK: - Haptics

/// Returns true if the device supports haptic feedback.
///
/// - iOS: Returns `true` if the device supports haptic feedback (iPhone 7 or newer) and the device is running iOS 13 or
///        newer.
/// - Emscripten: Always returns `false`.
bool glfmIsHapticFeedbackSupported(const GLFMDisplay *display);

/// Performs haptic feedback.
///
/// - Emscripten: This function does nothing.
void glfmPerformHapticFeedback(GLFMDisplay *display, GLFMHapticFeedbackStyle style);

// MARK: - Platform-specific functions

/// Returns `true` if this is an Apple platform that supports Metal, `false` otherwise.
bool glfmIsMetalSupported(const GLFMDisplay *display);

#if defined(__APPLE__) || defined(GLFM_EXPOSE_NATIVE_APPLE)

/// *Apple platforms only*: Returns a pointer to an `MTKView` instance, or `NULL` if Metal is not available.
///
/// This will only return a valid reference after the surface was created.
void *glfmGetMetalView(const GLFMDisplay *display);

/// *Apple platforms only*: Returns a pointer to the `UIViewController` (iOS, tvOS) or the `NSViewController` (macOS)
/// used to display content.
void *glfmGetViewController(const GLFMDisplay *display);

#endif // GLFM_EXPOSE_NATIVE_APPLE

#if defined(__ANDROID__) || defined(GLFM_EXPOSE_NATIVE_ANDROID)

#if defined(__ANDROID__)
#  include <android/native_activity.h>
#else
typedef struct ANativeActivity ANativeActivity;
#endif

ANativeActivity *glfmAndroidGetActivity(void) GLFM_DEPRECATED("Use glfmGetAndroidActivity");

/// *Android only*: Returns a pointer to the display's `ANativeActivity` instance.
///
/// The returned `ANativeActivity` may be invalidated when the surface is destroyed. If a reference to the
/// `ANativeActivity` is kept, call this function again to get an updated reference in ``GLFMSurfaceCreatedFunc`` or
/// ``GLFMAppFocusFunc``.
void *glfmGetAndroidActivity(const GLFMDisplay *display);

#endif // GLFM_EXPOSE_NATIVE_ANDROID

#ifdef __cplusplus
}
#endif

#endif // GLFM_H

```

`src/glfm_android.c`:

```c
// GLFM
// https://github.com/brackeen/glfm

#if defined(__ANDROID__)

#include "glfm.h"
#include "glfm_internal.h"

#include <EGL/egl.h>
#include <android/configuration.h>
#include <android/sensor.h>
#include <android/window.h>
#include <assert.h>
#include <dlfcn.h>
#include <pthread.h>
#include <unistd.h>

#define GLFM_LOG_LIFECYCLE_ENABLE 0

#ifdef NDEBUG
#  define GLFM_LOG(...) do { } while (0)
#  define GLFM_LOG_LIFECYCLE(...) do { } while (0)
#else
#  include <android/log.h>
#  define GLFM_LOG(...) __android_log_print(ANDROID_LOG_DEBUG, "GLFM", __VA_ARGS__)
#  if GLFM_LOG_LIFECYCLE_ENABLE
#    define GLFM_LOG_LIFECYCLE(...) __android_log_print(ANDROID_LOG_VERBOSE, "GLFM", "Lifecycle: " __VA_ARGS__)
#  else
#    define GLFM_LOG_LIFECYCLE(...) do { } while (0)
#  endif
#endif

#define GLFM_MAX_SIMULTANEOUS_TOUCHES 5
// Same update interval as iOS
#define GLFM_SENSOR_UPDATE_INTERVAL_MICROS ((int)(0.01 * 1000000))
#define GLFM_RESIZE_EVENT_MAX_WAIT_FRAMES 5

// If GLFM_HANDLE_BACK_BUTTON is 1, when the user presses the back button, the task is moved to the back. Otherwise,
// when the user presses the back button, the activity is destroyed.
#define GLFM_HANDLE_BACK_BUTTON 1

// MARK: - Platform data (global singleton)

typedef struct {
    ALooper *looper;
    pthread_t thread;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int commandPipeRead;
    int commandPipeWrite;
    bool threadRunning;

    ALooper *uiLooper;
    int uiCommandPipeRead;
    int uiCommandPipeWrite;

    ANativeWindow *window;
    AInputQueue *inputQueue;
    ARect contentRectArray[2];
    int contentRectIndex;

    ANativeWindow *pendingWindow;
    AInputQueue *pendingInputQueue;

    ANativeActivity *activity;
    AConfiguration *config;
    bool destroyRequested;

    bool multitouchEnabled;

    ARect keyboardFrame;
    bool keyboardVisible;

    bool animating;
    bool refreshRequested;
    bool swapCalled;
    bool surfaceCreatedNotified;
    double lastSwapTime;

    EGLDisplay eglDisplay;
    EGLSurface eglSurface;
    EGLConfig eglConfig;
    EGLContext eglContext;
    bool eglContextCurrent;

    int32_t width;
    int32_t height;
    double scale;
    int resizeEventWaitFrames;

    struct {
        int top, right, bottom, left;
        bool valid;
    } insets;

    GLFMDisplay *display;
    GLFMRenderingAPI renderingAPI;

    ASensorEventQueue *sensorEventQueue;
    GLFMSensorEvent sensorEvent[GLFM_NUM_SENSORS];
    bool sensorEventValid[GLFM_NUM_SENSORS];
    bool deviceSensorEnabled[GLFM_NUM_SENSORS];

    GLFMInterfaceOrientation orientation;

    JNIEnv *jniEnv;
} GLFMPlatformData;

static GLFMPlatformData *platformDataGlobal = NULL;

// MARK: - Private function declarations

static void *glfm__mainLoop(void *param);
static int glfm__looperCallback(int pipe, int events, void *userData);
static void glfm__setAllRequestedSensorsEnabled(GLFMDisplay *display, bool enable);
static void glfm__reportOrientationChangeIfNeeded(GLFMDisplay *display);
static void glfm__reportInsetsChangedIfNeeded(GLFMDisplay *display);
static bool glfm__updateSurfaceSizeIfNeeded(GLFMDisplay *display, bool force);
static float glfm__getRefreshRate(const GLFMDisplay *display);
static void glfm__getDisplayChromeInsets(const GLFMDisplay *display, int *top, int *right, int *bottom, int *left);
static void glfm__resetContentRect(GLFMPlatformData *platformData);
static void glfm__updateKeyboardVisibility(GLFMPlatformData *platformData);
static void glfm__updateUserInterfaceChrome(GLFMPlatformData *platformData);

// MARK: - JNI code

#ifdef NDEBUG
#  define glfm__printException(jni) ((void)0)
#else
#  define glfm__printException(jni) (*(jni))->ExceptionDescribe(jni)
#endif

#define glfm__wasJavaExceptionThrown(jni) \
    ((*(jni))->ExceptionCheck(jni) ? (glfm__printException(jni), (*(jni))->ExceptionClear(jni), true) : false)

#define glfm__clearJavaException(jni) \
    do { \
        if ((*(jni))->ExceptionCheck(jni)) { \
            glfm__printException(jni); \
            (*(jni))->ExceptionClear(jni); \
        } \
    } while (0)

static jmethodID glfm__getJavaMethodID(JNIEnv *jni, jobject object, const char *name, const char *sig) {
    if (!object) {
        return NULL;
    }
    jclass class = (*jni)->GetObjectClass(jni, object);
    jmethodID methodID = (*jni)->GetMethodID(jni, class, name, sig);
    (*jni)->DeleteLocalRef(jni, class);
    return glfm__wasJavaExceptionThrown(jni) ? NULL : methodID;
}

static jfieldID glfm__getJavaFieldID(JNIEnv *jni, jobject object, const char *name, const char *sig) {
    if (!object) {
        return NULL;
    }
    jclass class = (*jni)->GetObjectClass(jni, object);
    jfieldID fieldID = (*jni)->GetFieldID(jni, class, name, sig);
    (*jni)->DeleteLocalRef(jni, class);
    return glfm__wasJavaExceptionThrown(jni) ? NULL : fieldID;
}

static jmethodID glfm__getJavaStaticMethodID(JNIEnv *jni, jclass class, const char *name, const char *sig) {
    if (!class) {
        return NULL;
    }
    jmethodID methodID = (*jni)->GetStaticMethodID(jni, class, name, sig);
    return glfm__wasJavaExceptionThrown(jni) ? NULL : methodID;
}

static jfieldID glfm__getJavaStaticFieldID(JNIEnv *jni, jclass class, const char *name, const char *sig) {
    if (!class) {
        return NULL;
    }
    jfieldID fieldID = (*jni)->GetStaticFieldID(jni, class, name, sig);
    return glfm__wasJavaExceptionThrown(jni) ? NULL : fieldID;
}

#define glfm__callJavaMethod(jni, object, methodName, methodSig, returnType) \
    (*(jni))->Call##returnType##Method(jni, object, \
        glfm__getJavaMethodID(jni, object, methodName, methodSig))

#define glfm__callJavaMethodWithArgs(jni, object, methodName, methodSig, returnType, ...) \
    (*(jni))->Call##returnType##Method(jni, object, \
        glfm__getJavaMethodID(jni, object, methodName, methodSig), __VA_ARGS__)

#define glfm__callJavaStaticMethod(jni, class, methodName, methodSig, returnType) \
    (*(jni))->CallStatic##returnType##Method(jni, class, \
        glfm__getJavaStaticMethodID(jni, class, methodName, methodSig))

#define glfm__callJavaStaticMethodWithArgs(jni, class, methodName, methodSig, returnType, ...) \
    (*(jni))->CallStatic##returnType##Method(jni, class, \
        glfm__getJavaStaticMethodID(jni, class, methodName, methodSig), __VA_ARGS__)

#define glfm__getJavaField(jni, object, fieldName, fieldSig, fieldType) \
    (*(jni))->Get##fieldType##Field(jni, object, \
        glfm__getJavaFieldID(jni, object, fieldName, fieldSig))

#define glfm__getJavaStaticField(jni, class, fieldName, fieldSig, fieldType) \
    (*(jni))->GetStatic##fieldType##Field(jni, class, \
        glfm__getJavaStaticFieldID(jni, class, fieldName, fieldSig))

// MARK: - EGL

static bool glfm__eglContextInit(GLFMPlatformData *platformData) {

    // Available in eglext.h in API 18
    static const int EGL_CONTEXT_MAJOR_VERSION_KHR = 0x3098;
    static const int EGL_CONTEXT_MINOR_VERSION_KHR = 0x30FB;

    if (!platformData || !platformData->display) {
        return false;
    }

    EGLint majorVersion = 0;
    EGLint minorVersion = 0;
    bool created = false;
    if (platformData->eglContext == EGL_NO_CONTEXT) {
        // OpenGL ES 3.2
        if (platformData->display->preferredAPI >= GLFMRenderingAPIOpenGLES32) {
            majorVersion = 3;
            minorVersion = 2;
            const EGLint contextAttribList[] = { EGL_CONTEXT_MAJOR_VERSION_KHR, majorVersion,
                                                 EGL_CONTEXT_MINOR_VERSION_KHR, minorVersion,
                                                 EGL_NONE, EGL_NONE };
            platformData->eglContext = eglCreateContext(platformData->eglDisplay, platformData->eglConfig,
                                                        EGL_NO_CONTEXT, contextAttribList);
            created = platformData->eglContext != EGL_NO_CONTEXT;
        }
        // OpenGL ES 3.1
        if (!created && platformData->display->preferredAPI >= GLFMRenderingAPIOpenGLES31) {
            majorVersion = 3;
            minorVersion = 1;
            const EGLint contextAttribList[] = { EGL_CONTEXT_MAJOR_VERSION_KHR, majorVersion,
                                                 EGL_CONTEXT_MINOR_VERSION_KHR, minorVersion,
                                                 EGL_NONE, EGL_NONE };
            platformData->eglContext = eglCreateContext(platformData->eglDisplay, platformData->eglConfig,
                                                        EGL_NO_CONTEXT, contextAttribList);
            created = platformData->eglContext != EGL_NO_CONTEXT;
        }
        // OpenGL ES 3.0
        if (!created && platformData->display->preferredAPI >= GLFMRenderingAPIOpenGLES3) {
            majorVersion = 3;
            minorVersion = 0;
            const EGLint contextAttribList[] = { EGL_CONTEXT_CLIENT_VERSION, majorVersion,
                                                 EGL_NONE, EGL_NONE };
            platformData->eglContext = eglCreateContext(platformData->eglDisplay, platformData->eglConfig,
                                                        EGL_NO_CONTEXT, contextAttribList);
            created = platformData->eglContext != EGL_NO_CONTEXT;
        }
        // OpenGL ES 2.0
        if (!created) {
            majorVersion = 2;
            minorVersion = 0;
            const EGLint contextAttribList[] = { EGL_CONTEXT_CLIENT_VERSION, majorVersion,
                                                 EGL_NONE, EGL_NONE };
            platformData->eglContext = eglCreateContext(platformData->eglDisplay, platformData->eglConfig,
                                                        EGL_NO_CONTEXT, contextAttribList);
            created = platformData->eglContext != EGL_NO_CONTEXT;
        }

        if (created) {
            eglQueryContext(platformData->eglDisplay, platformData->eglContext,
                            EGL_CONTEXT_MAJOR_VERSION_KHR, &majorVersion);
            if (majorVersion >= 3) {
                // This call fails on many devices.
                // When it fails, `minorVersion` is left unchanged.
                eglQueryContext(platformData->eglDisplay, platformData->eglContext,
                                EGL_CONTEXT_MINOR_VERSION_KHR, &minorVersion);
            }
            if (majorVersion == 3 && minorVersion == 2) {
                platformData->renderingAPI = GLFMRenderingAPIOpenGLES32;
            } else if (majorVersion == 3 && minorVersion == 1) {
                platformData->renderingAPI = GLFMRenderingAPIOpenGLES31;
            } else if (majorVersion == 3) {
                platformData->renderingAPI = GLFMRenderingAPIOpenGLES3;
            } else {
                platformData->renderingAPI = GLFMRenderingAPIOpenGLES2;
            }
        }
    }

    if (!eglMakeCurrent(platformData->eglDisplay, platformData->eglSurface,
                        platformData->eglSurface, platformData->eglContext)) {
        GLFM_LOG_LIFECYCLE("eglMakeCurrent() failed");
        platformData->eglContextCurrent = false;
        return false;
    }

    GLFM_LOG_LIFECYCLE("GL Context made current");
    platformData->eglContextCurrent = true;
    if (created && !platformData->surfaceCreatedNotified) {
        platformData->surfaceCreatedNotified = true;
        if (platformData->display && platformData->display->surfaceCreatedFunc) {
            platformData->display->surfaceCreatedFunc(platformData->display, platformData->width, platformData->height);
        }
    }
    return true;
}

static void glfm__eglContextDisable(GLFMPlatformData *platformData) {
    if (platformData->eglDisplay != EGL_NO_DISPLAY) {
        eglMakeCurrent(platformData->eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    }
    platformData->eglContextCurrent = false;
}

static void glfm__eglSurfaceInit(GLFMPlatformData *platformData) {
    if (platformData->eglSurface == EGL_NO_SURFACE) {
        platformData->eglSurface = eglCreateWindowSurface(platformData->eglDisplay, platformData->eglConfig,
                                                          platformData->window, NULL);

        switch (platformData->display->swapBehavior) {
            case GLFMSwapBehaviorPlatformDefault: default:
                // Platform default, do nothing.
                break;
            case GLFMSwapBehaviorBufferPreserved:
                eglSurfaceAttrib(platformData->eglDisplay, platformData->eglSurface,
                                 EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
                break;
            case GLFMSwapBehaviorBufferDestroyed:
                eglSurfaceAttrib(platformData->eglDisplay, platformData->eglSurface,
                                 EGL_SWAP_BEHAVIOR, EGL_BUFFER_DESTROYED);
        }
    }
}

#ifndef NDEBUG

static void glfm__eglLogConfig(GLFMPlatformData *platformData, EGLConfig config) {
    GLFM_LOG("Config: %p", config);
    EGLint value = 0;
    eglGetConfigAttrib(platformData->eglDisplay, config, EGL_RENDERABLE_TYPE, &value);
    GLFM_LOG("  EGL_RENDERABLE_TYPE %i", value);
    eglGetConfigAttrib(platformData->eglDisplay, config, EGL_SURFACE_TYPE, &value);
    GLFM_LOG("  EGL_SURFACE_TYPE    %i", value);
    eglGetConfigAttrib(platformData->eglDisplay, config, EGL_RED_SIZE, &value);
    GLFM_LOG("  EGL_RED_SIZE        %i", value);
    eglGetConfigAttrib(platformData->eglDisplay, config, EGL_GREEN_SIZE, &value);
    GLFM_LOG("  EGL_GREEN_SIZE      %i", value);
    eglGetConfigAttrib(platformData->eglDisplay, config, EGL_BLUE_SIZE, &value);
    GLFM_LOG("  EGL_BLUE_SIZE       %i", value);
    eglGetConfigAttrib(platformData->eglDisplay, config, EGL_ALPHA_SIZE, &value);
    GLFM_LOG("  EGL_ALPHA_SIZE      %i", value);
    eglGetConfigAttrib(platformData->eglDisplay, config, EGL_DEPTH_SIZE, &value);
    GLFM_LOG("  EGL_DEPTH_SIZE      %i", value);
    eglGetConfigAttrib(platformData->eglDisplay, config, EGL_STENCIL_SIZE, &value);
    GLFM_LOG("  EGL_STENCIL_SIZE    %i", value);
    eglGetConfigAttrib(platformData->eglDisplay, config, EGL_SAMPLE_BUFFERS, &value);
    GLFM_LOG("  EGL_SAMPLE_BUFFERS  %i", value);
    eglGetConfigAttrib(platformData->eglDisplay, config, EGL_SAMPLES, &value);
    GLFM_LOG("  EGL_SAMPLES         %i", value);
}

#endif

static bool glfm__eglInit(GLFMPlatformData *platformData) {
    if (platformData->eglDisplay != EGL_NO_DISPLAY) {
        glfm__eglSurfaceInit(platformData);
        return glfm__eglContextInit(platformData);
    }
    int rBits, gBits, bBits, aBits;
    int depthBits, stencilBits, samples;

    switch (platformData->display->colorFormat) {
        case GLFMColorFormatRGB565:
            rBits = 5;
            gBits = 6;
            bBits = 5;
            aBits = 0;
            break;
        case GLFMColorFormatRGBA8888:
        default:
            rBits = 8;
            gBits = 8;
            bBits = 8;
            aBits = 8;
            break;
    }

    switch (platformData->display->depthFormat) {
        case GLFMDepthFormatNone:
        default:
            depthBits = 0;
            break;
        case GLFMDepthFormat16:
            depthBits = 16;
            break;
        case GLFMDepthFormat24: case GLFMDepthFormat32:
            depthBits = 24;
            break;
    }

    switch (platformData->display->stencilFormat) {
        case GLFMStencilFormatNone:
        default:
            stencilBits = 0;
            break;
        case GLFMStencilFormat8:
            stencilBits = 8;
            if (depthBits > 0) {
                // Many implementations only allow 24-bit depth with 8-bit stencil.
                depthBits = 24;
            }
            break;
    }

    samples = platformData->display->multisample == GLFMMultisample4X ? 4 : 0;

    EGLint majorVersion = 0;
    EGLint minorVersion = 0;
    EGLint format = 0;
    EGLint numConfigs = 0;

    platformData->eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
    eglInitialize(platformData->eglDisplay, &majorVersion, &minorVersion);

    while (true) {
        const EGLint attribList[] = {
            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
            EGL_RED_SIZE, rBits,
            EGL_GREEN_SIZE, gBits,
            EGL_BLUE_SIZE, bBits,
            EGL_ALPHA_SIZE, aBits,
            EGL_DEPTH_SIZE, depthBits,
            EGL_STENCIL_SIZE, stencilBits,
            EGL_SAMPLE_BUFFERS, samples > 0 ? 1 : 0,
            EGL_SAMPLES, samples > 0 ? samples : 0,
            EGL_NONE, EGL_NONE
        };
        eglChooseConfig(platformData->eglDisplay, attribList, &platformData->eglConfig,
                        1, &numConfigs);
        if (numConfigs) {
            // Found!
            //glfm__eglLogConfig(platformData, platformData->eglConfig);
            break;
        }
        if (samples > 0) {
            // Try 2x multisampling or no multisampling
            samples -= 2;
        } else if (depthBits > 8) {
            // Try 16-bit depth or 8-bit depth
            depthBits -= 8;
        } else {
            // Failure
#ifndef NDEBUG
            static bool printedConfigs = false;
            if (!printedConfigs) {
                printedConfigs = true;
                GLFM_LOG("eglChooseConfig() failed");
                EGLConfig configs[256];
                EGLint numTotalConfigs = 0;
                if (eglGetConfigs(platformData->eglDisplay, configs, 256, &numTotalConfigs)) {
                    GLFM_LOG("Num available configs: %i", numTotalConfigs);
                    for (int i = 0; i < numTotalConfigs; i++) {
                        glfm__eglLogConfig(platformData, configs[i]);
                    }
                } else {
                    GLFM_LOG("Couldn't get any EGL configs");
                }
            }
#endif

            GLFM_LOG("eglChooseConfig() failed");
            glfm__reportSurfaceError(platformData->eglDisplay, "eglChooseConfig() failed");
            eglTerminate(platformData->eglDisplay);
            platformData->eglDisplay = EGL_NO_DISPLAY;
            return false;
        }
    }

    glfm__eglSurfaceInit(platformData);

    eglQuerySurface(platformData->eglDisplay, platformData->eglSurface, EGL_WIDTH,
                    &platformData->width);
    eglQuerySurface(platformData->eglDisplay, platformData->eglSurface, EGL_HEIGHT,
                    &platformData->height);
    eglGetConfigAttrib(platformData->eglDisplay, platformData->eglConfig, EGL_NATIVE_VISUAL_ID,
                       &format);

    ANativeWindow_setBuffersGeometry(platformData->window, 0, 0, format);

    return glfm__eglContextInit(platformData);
}

static void glfm__eglSurfaceDestroy(GLFMPlatformData *platformData) {
    if (platformData->eglSurface != EGL_NO_SURFACE) {
        eglDestroySurface(platformData->eglDisplay, platformData->eglSurface);
        platformData->eglSurface = EGL_NO_SURFACE;
    }
    glfm__eglContextDisable(platformData);
}

static void glfm__eglDestroy(GLFMPlatformData *platformData) {
    if (platformData->eglDisplay != EGL_NO_DISPLAY) {
        eglMakeCurrent(platformData->eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
        if (platformData->eglContext != EGL_NO_CONTEXT) {
            eglDestroyContext(platformData->eglDisplay, platformData->eglContext);
            GLFM_LOG_LIFECYCLE("GL Context destroyed");
            if (platformData->surfaceCreatedNotified) {
                platformData->surfaceCreatedNotified = false;
                if (platformData->display && platformData->display->surfaceDestroyedFunc) {
                    platformData->display->surfaceDestroyedFunc(platformData->display);
                }
            }
        }
        if (platformData->eglSurface != EGL_NO_SURFACE) {
            eglDestroySurface(platformData->eglDisplay, platformData->eglSurface);
        }
        eglTerminate(platformData->eglDisplay);
    }
    platformData->eglDisplay = EGL_NO_DISPLAY;
    platformData->eglContext = EGL_NO_CONTEXT;
    platformData->eglSurface = EGL_NO_SURFACE;
    platformData->eglContextCurrent = false;
}

static void glfm__eglCheckError(GLFMPlatformData *platformData) {
    EGLint err = eglGetError();
    if (err == EGL_BAD_SURFACE) {
        glfm__eglSurfaceDestroy(platformData);
        glfm__eglSurfaceInit(platformData);
    } else if (err == EGL_CONTEXT_LOST || err == EGL_BAD_CONTEXT) {
        if (platformData->eglContext != EGL_NO_CONTEXT) {
            platformData->eglContext = EGL_NO_CONTEXT;
            platformData->eglContextCurrent = false;
            GLFM_LOG_LIFECYCLE("GL Context lost");
            if (platformData->surfaceCreatedNotified) {
                platformData->surfaceCreatedNotified = false;
                if (platformData->display && platformData->display->surfaceDestroyedFunc) {
                    platformData->display->surfaceDestroyedFunc(platformData->display);
                }
            }
        }
        glfm__eglContextInit(platformData);
    } else {
        glfm__eglDestroy(platformData);
        glfm__eglInit(platformData);
    }
}

static void glfm__drawFrame(GLFMPlatformData *platformData) {
    if (!platformData->eglContextCurrent) {
        // Probably a bad config (Happens on Android 2.3 emulator)
        return;
    }

    // Check for resize (or rotate)
    glfm__updateSurfaceSizeIfNeeded(platformData->display, false);

    // Tick and draw
    if (platformData->refreshRequested) {
        platformData->refreshRequested = false;
        if (platformData->display && platformData->display->surfaceRefreshFunc) {
            platformData->display->surfaceRefreshFunc(platformData->display);
        }
    }
    if (platformData->display && platformData->display->renderFunc) {
        platformData->display->renderFunc(platformData->display);
    }
}

// MARK: - ANativeActivity callbacks (UI thread)

enum {
    GLFMLooperIDCommand = 1,
    GLFMLooperIDInput = 2,
    GLFMLooperIDSensor = 3,
};

typedef enum {
    GLFMActivityCommandOnStart,
    GLFMActivityCommandOnPause,
    GLFMActivityCommandOnResume,
    GLFMActivityCommandOnStop,
    GLFMActivityCommandOnDestroy,
    GLFMActivityCommandOnWindowFocusGained,
    GLFMActivityCommandOnWindowFocusLost,
    GLFMActivityCommandOnNativeWindowCreated,
    GLFMActivityCommandOnNativeWindowResized,
    GLFMActivityCommandOnNativeWindowRedrawNeeded,
    GLFMActivityCommandOnNativeWindowDestroyed,
    GLFMActivityCommandOnInputQueueCreated,
    GLFMActivityCommandOnInputQueueDestroyed,
    GLFMActivityCommandOnContentRectChanged,
    GLFMActivityCommandOnConfigurationChanged,
    GLFMActivityCommandOnLowMemory,
} GLFMActivityCommand;

static void glfm__sendCommand(ANativeActivity *activity, GLFMActivityCommand command) {
    GLFMPlatformData *platformData = activity->instance;
    if (!platformData) {
        return;
    }
    uint8_t data = (uint8_t)command;
    if (write(platformData->commandPipeWrite, &data, sizeof(data)) != sizeof(data)) {
        GLFM_LOG("Couldn't write to pipe");
    }
}

static void glfm__activityOnStart(ANativeActivity *activity) {
    GLFMPlatformData *platformData = activity->instance;
    if (platformData && platformData->display) {
        glfm__updateUserInterfaceChrome(platformData);
    }
    glfm__sendCommand(activity, GLFMActivityCommandOnStart);
}

static void glfm__activityOnPause(ANativeActivity *activity) {
    glfm__sendCommand(activity, GLFMActivityCommandOnPause);
}

static void glfm__activityOnResume(ANativeActivity *activity) {
    glfm__sendCommand(activity, GLFMActivityCommandOnResume);
}

static void glfm__activityOnStop(ANativeActivity *activity) {
    glfm__sendCommand(activity, GLFMActivityCommandOnStop);
}

static void glfm__activityOnWindowFocusChanged(ANativeActivity *activity, int hasFocus) {
    glfm__sendCommand(activity, (hasFocus ? GLFMActivityCommandOnWindowFocusGained :
        GLFMActivityCommandOnWindowFocusLost));
}

static void glfm__activityOnConfigurationChanged(ANativeActivity *activity) {
    glfm__sendCommand(activity, GLFMActivityCommandOnConfigurationChanged);
}

static void glfm__activityOnLowMemory(ANativeActivity *activity) {
    glfm__sendCommand(activity, GLFMActivityCommandOnLowMemory);
}

static void glfm__activityOnNativeWindowResized(ANativeActivity *activity, ANativeWindow *window) {
    (void)window;
    glfm__sendCommand(activity, GLFMActivityCommandOnNativeWindowResized);
}

static void glfm__activityOnNativeWindowRedrawNeeded(ANativeActivity *activity, ANativeWindow *window) {
    (void)window;
    glfm__sendCommand(activity, GLFMActivityCommandOnNativeWindowRedrawNeeded);
}

static void glfm__activityOnNativeWindowCreated(ANativeActivity *activity, ANativeWindow *window) {
    GLFMPlatformData *platformData = activity->instance;
    pthread_mutex_lock(&platformData->mutex);
    platformData->pendingWindow = window;
    glfm__sendCommand(activity, GLFMActivityCommandOnNativeWindowCreated);
    while (platformData->window != window) {
        pthread_cond_wait(&platformData->cond, &platformData->mutex);
    }
    pthread_mutex_unlock(&platformData->mutex);
}

static void glfm__activityOnNativeWindowDestroyed(ANativeActivity *activity, ANativeWindow *window) {
    (void)window;
    glfm__sendCommand(activity, GLFMActivityCommandOnNativeWindowDestroyed);
}

static void glfm__activityOnInputQueueCreated(ANativeActivity *activity, AInputQueue *queue) {
    GLFMPlatformData *platformData = activity->instance;
    pthread_mutex_lock(&platformData->mutex);
    platformData->pendingInputQueue = queue;
    glfm__sendCommand(activity, GLFMActivityCommandOnInputQueueCreated);
    while (platformData->inputQueue != queue) {
        pthread_cond_wait(&platformData->cond, &platformData->mutex);
    }
    pthread_mutex_unlock(&platformData->mutex);
}

static void glfm__activityOnInputQueueDestroyed(ANativeActivity *activity, AInputQueue *queue) {
    (void)queue;
    glfm__sendCommand(activity, GLFMActivityCommandOnInputQueueDestroyed);
}

static void glfm__activityOnContentRectChanged(ANativeActivity *activity, const ARect *rect) {
    GLFMPlatformData *platformData = activity->instance;
    int nextContentRectIndex = platformData->contentRectIndex ^ 1;
    platformData->contentRectArray[nextContentRectIndex] = *rect;
    platformData->contentRectIndex = nextContentRectIndex;
    glfm__resetContentRect(platformData); // Reset so that onContentRectChanged acts as a global layout listener.
    glfm__sendCommand(activity, GLFMActivityCommandOnContentRectChanged);
}

static void glfm__activityOnDestroy(ANativeActivity *activity) {
    GLFMPlatformData *platformData = activity->instance;
    pthread_mutex_lock(&platformData->mutex);
    glfm__sendCommand(activity, GLFMActivityCommandOnDestroy);
    while (platformData->threadRunning) {
        pthread_cond_wait(&platformData->cond, &platformData->mutex);
    }
    pthread_mutex_unlock(&platformData->mutex);

    close(platformData->commandPipeRead);
    close(platformData->commandPipeWrite);
    pthread_cond_destroy(&platformData->cond);
    pthread_mutex_destroy(&platformData->mutex);

    close(platformData->uiCommandPipeRead);
    close(platformData->uiCommandPipeWrite);
    GLFM_LOG_LIFECYCLE("Goodbye");
}

static void *glfm__activityOnSaveInstanceState(ANativeActivity *activity, size_t *outSize) {
    (void)activity;
    *outSize = 0;
    return NULL;
}

JNIEXPORT void ANativeActivity_onCreate(ANativeActivity *activity, void *savedState, size_t savedStateSize) {
    (void)savedState;
    (void)savedStateSize;

    GLFM_LOG_LIFECYCLE("ANativeActivity_onCreate (API %i)", activity->sdkVersion);
    ALooper *looper = ALooper_forThread();
    if (!looper) {
        GLFM_LOG("No looper");
        return;
    }
    int commandPipe[2];
    int uiCommandPipe[2];
    if (pipe(commandPipe)) {
        GLFM_LOG("Couldn't create pipe");
        return;
    }
    if (pipe(uiCommandPipe)) {
        GLFM_LOG("Couldn't create UI pipe");
        return;
    }

    activity->callbacks->onStart = glfm__activityOnStart;
    activity->callbacks->onPause = glfm__activityOnPause;
    activity->callbacks->onResume = glfm__activityOnResume;
    activity->callbacks->onStop = glfm__activityOnStop;
    activity->callbacks->onDestroy = glfm__activityOnDestroy;
    activity->callbacks->onWindowFocusChanged = glfm__activityOnWindowFocusChanged;
    activity->callbacks->onNativeWindowCreated = glfm__activityOnNativeWindowCreated;
    activity->callbacks->onNativeWindowResized = glfm__activityOnNativeWindowResized;
    activity->callbacks->onNativeWindowRedrawNeeded = glfm__activityOnNativeWindowRedrawNeeded;
    activity->callbacks->onNativeWindowDestroyed = glfm__activityOnNativeWindowDestroyed;
    activity->callbacks->onInputQueueCreated = glfm__activityOnInputQueueCreated;
    activity->callbacks->onInputQueueDestroyed = glfm__activityOnInputQueueDestroyed;
    activity->callbacks->onContentRectChanged = glfm__activityOnContentRectChanged;
    activity->callbacks->onConfigurationChanged = glfm__activityOnConfigurationChanged;
    activity->callbacks->onLowMemory = glfm__activityOnLowMemory;
    activity->callbacks->onSaveInstanceState = glfm__activityOnSaveInstanceState;

    if (platformDataGlobal == NULL) {
        // ANativeActivity_onCreate can be called multiple times for the same Activity.
        // For now, use a global to prevent glfmMain() from being called multiple times.
        // This behavior may need to change in the future.
        platformDataGlobal = calloc(1, sizeof(GLFMPlatformData));
    }
    GLFMPlatformData *platformData = platformDataGlobal;

    activity->instance = platformData;
    platformData->activity = activity;
    platformData->window = NULL;
    platformData->threadRunning = false;
    platformData->destroyRequested = false;
    platformData->contentRectArray[0] = (ARect) { 0 };
    platformData->contentRectArray[1] = (ARect) { 0 };
    platformData->commandPipeRead = commandPipe[0];
    platformData->commandPipeWrite = commandPipe[1];

    pthread_mutex_init(&platformData->mutex, NULL);
    pthread_cond_init(&platformData->cond, NULL);

    // Setup UI thread callbacks
    platformData->uiLooper = looper;
    platformData->uiCommandPipeRead = uiCommandPipe[0];
    platformData->uiCommandPipeWrite = uiCommandPipe[1];
    ALooper_addFd(platformData->uiLooper, platformData->uiCommandPipeRead, ALOOPER_POLL_CALLBACK,
                  ALOOPER_EVENT_INPUT, glfm__looperCallback, platformData);

    // Start thread
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_create(&platformData->thread, &attr, glfm__mainLoop, platformData);
    pthread_attr_destroy(&attr);

    // Wait for thread to start
    pthread_mutex_lock(&platformData->mutex);
    while (!platformData->threadRunning) {
        pthread_cond_wait(&platformData->cond, &platformData->mutex);
    }
    pthread_mutex_unlock(&platformData->mutex);
    GLFM_LOG_LIFECYCLE("Returning from ANativeActivity_onCreate");
}

// MARK: - UI thread callbacks

typedef void (*GLFMUIThreadFunc)(GLFMPlatformData *platformData, void *userData);

typedef struct {
    GLFMUIThreadFunc function;
    void *userData;
} GLFMLooperMessage;

// Called from the UI thread
static int glfm__looperCallback(int pipe, int events, void *userData) {
    GLFMPlatformData *platformData = userData;
    GLFMLooperMessage message;
    assert(ALooper_forThread() == platformData->uiLooper);
    if ((events & ALOOPER_EVENT_INPUT) != 0) {
        if (read(pipe, &message, sizeof(message)) == sizeof(message)) {
            message.function(platformData, message.userData);
        }
    }
    return 1;
}

/// Queues a function to execute on the UI thread.
/// Returns true if the function was queued, false otherwise.
static bool glfm__runOnUIThread(GLFMPlatformData *platformData, GLFMUIThreadFunc function, void *userData) {
    assert(platformData->looper == ALooper_forThread());
    if (platformData->looper != ALooper_forThread() || !function) {
        return false;
    }

    GLFMLooperMessage message = { 0 };
    message.function = function;
    message.userData = userData;
    if (write(platformData->uiCommandPipeWrite, &message, sizeof(message)) != sizeof(message)) {
        // The pipe is full.
        return false;
    }
    return true;
}

// MARK: - App command callback and input callbacks

static void glfm__setAnimating(GLFMPlatformData *platformData, bool animating) {
    if (platformData->animating != animating) {
        platformData->animating = animating;
        platformData->refreshRequested = true;
        if (platformData->display && platformData->display->focusFunc) {
            platformData->display->focusFunc(platformData->display, animating);
        }
        glfm__setAllRequestedSensorsEnabled(platformData->display, animating);
    }
}

static void glfm__onAppCmd(GLFMPlatformData *platformData, GLFMActivityCommand command) {
    switch (command) {
        case GLFMActivityCommandOnNativeWindowCreated: {
            GLFM_LOG_LIFECYCLE("OnNativeWindowCreated");
            pthread_mutex_lock(&platformData->mutex);
            platformData->window = platformData->pendingWindow;
            pthread_cond_broadcast(&platformData->cond);
            pthread_mutex_unlock(&platformData->mutex);

            const bool success = glfm__eglInit(platformData);
            if (!success) {
                glfm__eglCheckError(platformData);
            }
            platformData->refreshRequested = true;
            glfm__drawFrame(platformData);
            break;
        }
        case GLFMActivityCommandOnNativeWindowResized: {
            GLFM_LOG_LIFECYCLE("OnNativeWindowResized");
            break;
        }
        case GLFMActivityCommandOnNativeWindowDestroyed: {
            GLFM_LOG_LIFECYCLE("OnNativeWindowDestroyed");
            platformData->window = NULL;
            glfm__eglSurfaceDestroy(platformData);
            glfm__setAnimating(platformData, false);
            break;
        }
        case GLFMActivityCommandOnNativeWindowRedrawNeeded: {
            GLFM_LOG_LIFECYCLE("OnNativeWindowRedrawNeeded");
            platformData->refreshRequested = true;
            break;
        }
        case GLFMActivityCommandOnWindowFocusGained: {
            GLFM_LOG_LIFECYCLE("OnWindowFocusGained");
            glfm__setAnimating(platformData, true);
            break;
        }
        case GLFMActivityCommandOnWindowFocusLost: {
            GLFM_LOG_LIFECYCLE("OnWindowFocusLost");
            if (platformData->animating) {
                platformData->refreshRequested = true;
                glfm__drawFrame(platformData);
                glfm__setAnimating(platformData, false);
            }
            break;
        }
        case GLFMActivityCommandOnContentRectChanged: {
            // NOTE: Content rect might be the same, as this is also used as a global layout listener
#if GLFM_LOG_LIFECYCLE_ENABLE
            ARect *oldRect = &platformData->contentRectArray[platformData->contentRectIndex ^ 1];
            ARect *newRect = &platformData->contentRectArray[platformData->contentRectIndex];
            GLFM_LOG_LIFECYCLE("OnContentRectChanged (from %i,%i,%i,%i to %i,%i,%i,%i)",
                               oldRect->left, oldRect->top, oldRect->right, oldRect->bottom,
                               newRect->left, newRect->top, newRect->right, newRect->bottom);
#endif

            platformData->refreshRequested = true;
            if (platformData->window) {
                bool sizedChanged = glfm__updateSurfaceSizeIfNeeded(platformData->display, true);
                if (!sizedChanged) {
                    glfm__reportOrientationChangeIfNeeded(platformData->display);
                    glfm__reportInsetsChangedIfNeeded(platformData->display);
                    glfm__updateKeyboardVisibility(platformData);
                }
            }
            break;
        }
        case GLFMActivityCommandOnLowMemory: {
            GLFM_LOG_LIFECYCLE("OnLowMemory");
            if (platformData->display && platformData->display->lowMemoryFunc) {
                platformData->display->lowMemoryFunc(platformData->display);
            }
            break;
        }
#if GLFM_LOG_LIFECYCLE_ENABLE
        case GLFMActivityCommandOnStart: {
            GLFM_LOG_LIFECYCLE("OnStart");
            break;
        }
        case GLFMActivityCommandOnResume: {
            GLFM_LOG_LIFECYCLE("OnResume");
            break;
        }
        case GLFMActivityCommandOnPause: {
            GLFM_LOG_LIFECYCLE("OnPause");
            break;
        }
        case GLFMActivityCommandOnStop: {
            GLFM_LOG_LIFECYCLE("OnStop");
            break;
        }
#else
        case GLFMActivityCommandOnStart:
        case GLFMActivityCommandOnResume:
        case GLFMActivityCommandOnPause:
        case GLFMActivityCommandOnStop:
            break;
#endif
        case GLFMActivityCommandOnDestroy: {
            GLFM_LOG_LIFECYCLE("OnDestroy");
            glfm__eglDestroy(platformData);
            glfm__setAnimating(platformData, false);
            platformData->destroyRequested = true;
            break;
        }
        case GLFMActivityCommandOnInputQueueCreated: {
            GLFM_LOG_LIFECYCLE("OnInputQueueCreated");
            pthread_mutex_lock(&platformData->mutex);
            if (platformData->inputQueue) {
                AInputQueue_detachLooper(platformData->inputQueue);
            }
            platformData->inputQueue = platformData->pendingInputQueue;
            AInputQueue_attachLooper(platformData->inputQueue, platformData->looper,
                                     GLFMLooperIDInput, NULL, NULL);
            pthread_cond_broadcast(&platformData->cond);
            pthread_mutex_unlock(&platformData->mutex);
            break;
        }
        case GLFMActivityCommandOnInputQueueDestroyed: {
            GLFM_LOG_LIFECYCLE("OnInputQueueDestroyed");
            if (platformData->inputQueue) {
                AInputQueue_detachLooper(platformData->inputQueue);
                platformData->inputQueue = NULL;
            }
            break;
        }
        case GLFMActivityCommandOnConfigurationChanged: {
            GLFM_LOG_LIFECYCLE("OnConfigurationChanged");
            AConfiguration_fromAssetManager(platformData->config, platformData->activity->assetManager);
            break;
        }
        default: {
            // Do nothing
            break;
        }
    }
}

static void glfm__unicodeToUTF8(uint32_t unicode, char utf8[5]) {
    if (unicode < 0x80) {
        utf8[0] = (char)(unicode & 0x7fu);
        utf8[1] = 0;
    } else if (unicode < 0x800) {
        utf8[0] = (char)(0xc0u | (unicode >> 6u));
        utf8[1] = (char)(0x80u | (unicode & 0x3fu));
        utf8[2] = 0;
    } else if (unicode < 0x10000) {
        utf8[0] = (char)(0xe0u | (unicode >> 12u));
        utf8[1] = (char)(0x80u | ((unicode >> 6u) & 0x3fu));
        utf8[2] = (char)(0x80u | (unicode & 0x3fu));
        utf8[3] = 0;
    } else if (unicode < 0x110000) {
        utf8[0] = (char)(0xf0u | (unicode >> 18u));
        utf8[1] = (char)(0x80u | ((unicode >> 12u) & 0x3fu));
        utf8[2] = (char)(0x80u | ((unicode >> 6u) & 0x3fu));
        utf8[3] = (char)(0x80u | (unicode & 0x3fu));
        utf8[4] = 0;
    } else {
        utf8[0] = 0;
    }
}

static uint32_t glfm__getUnicodeChar(GLFMPlatformData *platformData, jint keyCode, jint metaState) {
    JNIEnv *jni = platformData->jniEnv;
    if ((*jni)->ExceptionCheck(jni)) {
        return 0;
    }

    jclass keyEventClass = (*jni)->FindClass(jni, "android/view/KeyEvent");
    if (glfm__wasJavaExceptionThrown(jni) || !keyEventClass) {
        return 0;
    }

    jmethodID getUnicodeChar = (*jni)->GetMethodID(jni, keyEventClass, "getUnicodeChar", "(I)I");
    jmethodID eventConstructor = (*jni)->GetMethodID(jni, keyEventClass, "<init>", "(II)V");

    jobject eventObject = (*jni)->NewObject(jni, keyEventClass, eventConstructor,
                                            (jint)AKEY_EVENT_ACTION_DOWN, keyCode);
    if (glfm__wasJavaExceptionThrown(jni) || !eventObject) {
        return 0;
    }

    jint unicodeKey = (*jni)->CallIntMethod(jni, eventObject, getUnicodeChar, metaState);

    (*jni)->DeleteLocalRef(jni, eventObject);
    (*jni)->DeleteLocalRef(jni, keyEventClass);

    if (glfm__wasJavaExceptionThrown(jni)) {
        return 0;
    }
    return (uint32_t)unicodeKey;
}

/*
 * Hide the virtual keyboard if it is visible.
 *
 * Otherwise, if the current task is the root task, move the task to the back. This makes the back button have the same
 * behavior as the home button.
 *
 * Without this, when the user presses the back button, the loop in glfm__mainLoop() is exited, the OpenGL context is
 * destroyed, and the main thread is destroyed. The glfm__mainLoop() function would be called again in the same process
 * if the user returns to the app.
 *
 * With this, when the app is in the background, the app will pause in the ALooper_pollOnce() call.
 */
static bool glfm__handleBackButton(GLFMPlatformData *platformData) {
    if (!platformData || !platformData->activity) {
        return false;
    }
    JNIEnv *jni = platformData->jniEnv;
    if ((*jni)->ExceptionCheck(jni)) {
        return false;
    }

    if (platformData->keyboardVisible) {
        glfmSetKeyboardVisible(platformData->display, false);
        return true;
    }

#if GLFM_HANDLE_BACK_BUTTON
    jboolean handled = glfm__callJavaMethodWithArgs(jni, platformData->activity->clazz,
                                                    "moveTaskToBack", "(Z)Z", Boolean, false);
    return !glfm__wasJavaExceptionThrown(jni) && handled;
#else
    return false;
#endif
}

static bool glfm__onKeyEvent(GLFMPlatformData *platformData, AInputEvent *event) {
    if (!platformData || !platformData->display) {
        return false;
    }
    GLFMDisplay *display = platformData->display;
    int32_t aAction = AKeyEvent_getAction(event);
    int32_t aKeyCode = AKeyEvent_getKeyCode(event);
    int32_t aMetaState = AKeyEvent_getMetaState(event);
    if (aKeyCode == 0) {
        // aKeyCode is 0 for many non-ASCII keys from the virtual keyboard.
        return false;
    }
    if (aKeyCode == INT32_MAX) {
        // This is a special key code for GLFM where the scancode represents a unicode character.
        if (display->charFunc) {
            uint32_t unicode = (uint32_t)AKeyEvent_getScanCode(event);
            char utf8[5];
            glfm__unicodeToUTF8(unicode, utf8);
            display->charFunc(display, utf8, 0);
        }
        return true;
    }
    bool handled = false;
    if (display->keyFunc) {
        static const GLFMKeyCode AKEYCODE_MAP[] = {
                [AKEYCODE_BACK]            = GLFMKeyCodeNavigationBack,

                [AKEYCODE_0]               = GLFMKeyCode0,
                [AKEYCODE_1]               = GLFMKeyCode1,
                [AKEYCODE_2]               = GLFMKeyCode2,
                [AKEYCODE_3]               = GLFMKeyCode3,
                [AKEYCODE_4]               = GLFMKeyCode4,
                [AKEYCODE_5]               = GLFMKeyCode5,
                [AKEYCODE_6]               = GLFMKeyCode6,
                [AKEYCODE_7]               = GLFMKeyCode7,
                [AKEYCODE_8]               = GLFMKeyCode8,
                [AKEYCODE_9]               = GLFMKeyCode9,

                [AKEYCODE_DPAD_UP]         = GLFMKeyCodeArrowUp,
                [AKEYCODE_DPAD_DOWN]       = GLFMKeyCodeArrowDown,
                [AKEYCODE_DPAD_LEFT]       = GLFMKeyCodeArrowLeft,
                [AKEYCODE_DPAD_RIGHT]      = GLFMKeyCodeArrowRight,

                [AKEYCODE_POWER]           = GLFMKeyCodePower,

                [AKEYCODE_A]               = GLFMKeyCodeA,
                [AKEYCODE_B]               = GLFMKeyCodeB,
                [AKEYCODE_C]               = GLFMKeyCodeC,
                [AKEYCODE_D]               = GLFMKeyCodeD,
                [AKEYCODE_E]               = GLFMKeyCodeE,
                [AKEYCODE_F]               = GLFMKeyCodeF,
                [AKEYCODE_G]               = GLFMKeyCodeG,
                [AKEYCODE_H]               = GLFMKeyCodeH,
                [AKEYCODE_I]               = GLFMKeyCodeI,
                [AKEYCODE_J]               = GLFMKeyCodeJ,
                [AKEYCODE_K]               = GLFMKeyCodeK,
                [AKEYCODE_L]               = GLFMKeyCodeL,
                [AKEYCODE_M]               = GLFMKeyCodeM,
                [AKEYCODE_N]               = GLFMKeyCodeN,
                [AKEYCODE_O]               = GLFMKeyCodeO,
                [AKEYCODE_P]               = GLFMKeyCodeP,
                [AKEYCODE_Q]               = GLFMKeyCodeQ,
                [AKEYCODE_R]               = GLFMKeyCodeR,
                [AKEYCODE_S]               = GLFMKeyCodeS,
                [AKEYCODE_T]               = GLFMKeyCodeT,
                [AKEYCODE_U]               = GLFMKeyCodeU,
                [AKEYCODE_V]               = GLFMKeyCodeV,
                [AKEYCODE_W]               = GLFMKeyCodeW,
                [AKEYCODE_X]               = GLFMKeyCodeX,
                [AKEYCODE_Y]               = GLFMKeyCodeY,
                [AKEYCODE_Z]               = GLFMKeyCodeZ,
                [AKEYCODE_COMMA]           = GLFMKeyCodeComma,
                [AKEYCODE_PERIOD]          = GLFMKeyCodePeriod,
                [AKEYCODE_ALT_LEFT]        = GLFMKeyCodeAltLeft,
                [AKEYCODE_ALT_RIGHT]       = GLFMKeyCodeAltRight,
                [AKEYCODE_SHIFT_LEFT]      = GLFMKeyCodeShiftLeft,
                [AKEYCODE_SHIFT_RIGHT]     = GLFMKeyCodeShiftRight,
                [AKEYCODE_TAB]             = GLFMKeyCodeTab,
                [AKEYCODE_SPACE]           = GLFMKeyCodeSpace,

                [AKEYCODE_ENTER]           = GLFMKeyCodeEnter,
                [AKEYCODE_DEL]             = GLFMKeyCodeBackspace,
                [AKEYCODE_GRAVE]           = GLFMKeyCodeBackquote,
                [AKEYCODE_MINUS]           = GLFMKeyCodeMinus,
                [AKEYCODE_EQUALS]          = GLFMKeyCodeEqual,
                [AKEYCODE_LEFT_BRACKET]    = GLFMKeyCodeBracketLeft,
                [AKEYCODE_RIGHT_BRACKET]   = GLFMKeyCodeBracketRight,
                [AKEYCODE_BACKSLASH]       = GLFMKeyCodeBackslash,
                [AKEYCODE_SEMICOLON]       = GLFMKeyCodeSemicolon,
                [AKEYCODE_APOSTROPHE]      = GLFMKeyCodeQuote,
                [AKEYCODE_SLASH]           = GLFMKeyCodeSlash,

                [AKEYCODE_MENU]            = GLFMKeyCodeMenu,

                [AKEYCODE_PAGE_UP]         = GLFMKeyCodePageUp,
                [AKEYCODE_PAGE_DOWN]       = GLFMKeyCodePageDown,

                [AKEYCODE_ESCAPE]          = GLFMKeyCodeEscape,
                [AKEYCODE_FORWARD_DEL]     = GLFMKeyCodeDelete,
                [AKEYCODE_CTRL_LEFT]       = GLFMKeyCodeControlLeft,
                [AKEYCODE_CTRL_RIGHT]      = GLFMKeyCodeControlRight,
                [AKEYCODE_CAPS_LOCK]       = GLFMKeyCodeCapsLock,
                [AKEYCODE_SCROLL_LOCK]     = GLFMKeyCodeScrollLock,
                [AKEYCODE_META_LEFT]       = GLFMKeyCodeMetaLeft,
                [AKEYCODE_META_RIGHT]      = GLFMKeyCodeMetaRight,
                [AKEYCODE_FUNCTION]        = GLFMKeyCodeFunction,
                [AKEYCODE_SYSRQ]           = GLFMKeyCodePrintScreen,
                [AKEYCODE_BREAK]           = GLFMKeyCodePause,
                [AKEYCODE_MOVE_HOME]       = GLFMKeyCodeHome,
                [AKEYCODE_MOVE_END]        = GLFMKeyCodeEnd,
                [AKEYCODE_INSERT]          = GLFMKeyCodeInsert,

                [AKEYCODE_F1]              = GLFMKeyCodeF1,
                [AKEYCODE_F2]              = GLFMKeyCodeF2,
                [AKEYCODE_F3]              = GLFMKeyCodeF3,
                [AKEYCODE_F4]              = GLFMKeyCodeF4,
                [AKEYCODE_F5]              = GLFMKeyCodeF5,
                [AKEYCODE_F6]              = GLFMKeyCodeF6,
                [AKEYCODE_F7]              = GLFMKeyCodeF7,
                [AKEYCODE_F8]              = GLFMKeyCodeF8,
                [AKEYCODE_F9]              = GLFMKeyCodeF9,
                [AKEYCODE_F10]             = GLFMKeyCodeF10,
                [AKEYCODE_F11]             = GLFMKeyCodeF11,
                [AKEYCODE_F12]             = GLFMKeyCodeF12,
                [AKEYCODE_NUM_LOCK]        = GLFMKeyCodeNumLock,
                [AKEYCODE_NUMPAD_0]        = GLFMKeyCodeNumpad0,
                [AKEYCODE_NUMPAD_1]        = GLFMKeyCodeNumpad1,
                [AKEYCODE_NUMPAD_2]        = GLFMKeyCodeNumpad2,
                [AKEYCODE_NUMPAD_3]        = GLFMKeyCodeNumpad3,
                [AKEYCODE_NUMPAD_4]        = GLFMKeyCodeNumpad4,
                [AKEYCODE_NUMPAD_5]        = GLFMKeyCodeNumpad5,
                [AKEYCODE_NUMPAD_6]        = GLFMKeyCodeNumpad6,
                [AKEYCODE_NUMPAD_7]        = GLFMKeyCodeNumpad7,
                [AKEYCODE_NUMPAD_8]        = GLFMKeyCodeNumpad8,
                [AKEYCODE_NUMPAD_9]        = GLFMKeyCodeNumpad9,
                [AKEYCODE_NUMPAD_DIVIDE]   = GLFMKeyCodeNumpadDivide,
                [AKEYCODE_NUMPAD_MULTIPLY] = GLFMKeyCodeNumpadMultiply,
                [AKEYCODE_NUMPAD_SUBTRACT] = GLFMKeyCodeNumpadSubtract,
                [AKEYCODE_NUMPAD_ADD]      = GLFMKeyCodeNumpadAdd,
                [AKEYCODE_NUMPAD_DOT]      = GLFMKeyCodeNumpadDecimal,
                [AKEYCODE_NUMPAD_ENTER]    = GLFMKeyCodeNumpadEnter,
                [AKEYCODE_NUMPAD_EQUALS]   = GLFMKeyCodeNumpadEqual,
        };

        GLFMKeyCode keyCode = GLFMKeyCodeUnknown;
        if (aKeyCode >= 0 && aKeyCode < (int32_t)(sizeof(AKEYCODE_MAP) / sizeof(*AKEYCODE_MAP))) {
            keyCode = AKEYCODE_MAP[aKeyCode];
        }

        int modifiers = 0;
        if ((aMetaState & AMETA_SHIFT_ON) != 0) {
            modifiers |= GLFMKeyModifierShift;
        }
        if ((aMetaState & AMETA_CTRL_ON) != 0) {
            modifiers |= GLFMKeyModifierControl;
        }
        if ((aMetaState & AMETA_ALT_ON) != 0) {
            modifiers |= GLFMKeyModifierAlt;
        }
        if ((aMetaState & AMETA_META_ON) != 0) {
            modifiers |= GLFMKeyModifierMeta;
        }
        if ((aMetaState & AMETA_FUNCTION_ON) != 0) {
            modifiers |= GLFMKeyModifierFunction;
        }

        if (aAction == AKEY_EVENT_ACTION_UP) {
            handled = display->keyFunc(display, keyCode, GLFMKeyActionReleased, modifiers);
        } else if (aAction == AKEY_EVENT_ACTION_DOWN) {
            GLFMKeyAction keyAction;
            if (AKeyEvent_getRepeatCount(event) > 0) {
                keyAction = GLFMKeyActionRepeated;
            } else {
                keyAction = GLFMKeyActionPressed;
            }
            handled = display->keyFunc(display, keyCode, keyAction, modifiers);
        } else if (aAction == AKEY_EVENT_ACTION_MULTIPLE) {
            for (int i = AKeyEvent_getRepeatCount(event); i > 0; i--) {
                if (display->keyFunc) {
                    handled |= display->keyFunc(display, keyCode, GLFMKeyActionPressed, modifiers);
                }
                if (display->keyFunc) {
                    handled |= display->keyFunc(display, keyCode, GLFMKeyActionReleased, modifiers);
                }
            }
        }
    }

    if (!handled && aAction == AKEY_EVENT_ACTION_UP && aKeyCode == AKEYCODE_BACK) {
        handled = glfm__handleBackButton(platformData);
    }

    if (display->charFunc && (aAction == AKEY_EVENT_ACTION_DOWN || aAction == AKEY_EVENT_ACTION_MULTIPLE)) {
        uint32_t unicode = glfm__getUnicodeChar(platformData, aKeyCode, aMetaState);
        if (unicode >= ' ') {
            char utf8[5];
            glfm__unicodeToUTF8(unicode, utf8);
            if (aAction == AKEY_EVENT_ACTION_DOWN) {
                display->charFunc(display, utf8, 0);
            } else {
                for (int i = AKeyEvent_getRepeatCount(event); i > 0; i--) {
                    if (display->charFunc) {
                        display->charFunc(display, utf8, 0);
                    }
                }
            }
        }
    }
    return handled;
}

static bool glfm__onTouchEvent(GLFMPlatformData *platformData, AInputEvent *event) {
    if (!platformData || !platformData->display || !platformData->display->touchFunc) {
        return false;
    }
    GLFMDisplay *display = platformData->display;
    const int maxTouches = platformData->multitouchEnabled ? GLFM_MAX_SIMULTANEOUS_TOUCHES : 1;
    const int32_t action = AMotionEvent_getAction(event);
    const uint32_t maskedAction = (uint32_t)action & (uint32_t)AMOTION_EVENT_ACTION_MASK;

    GLFMTouchPhase phase;
    bool validAction = true;

    switch (maskedAction) {
        case AMOTION_EVENT_ACTION_DOWN:
        case AMOTION_EVENT_ACTION_POINTER_DOWN:
            phase = GLFMTouchPhaseBegan;
            break;
        case AMOTION_EVENT_ACTION_UP:
        case AMOTION_EVENT_ACTION_POINTER_UP:
        case AMOTION_EVENT_ACTION_OUTSIDE:
            phase = GLFMTouchPhaseEnded;
            break;
        case AMOTION_EVENT_ACTION_MOVE:
            phase = GLFMTouchPhaseMoved;
            break;
        case AMOTION_EVENT_ACTION_CANCEL:
            phase = GLFMTouchPhaseCancelled;
            break;
        default:
            phase = GLFMTouchPhaseCancelled;
            validAction = false;
            break;
    }
    if (validAction) {
        if (phase == GLFMTouchPhaseMoved) {
            const size_t count = AMotionEvent_getPointerCount(event);
            for (size_t i = 0; i < count; i++) {
                const int touchNumber = AMotionEvent_getPointerId(event, i);
                if (touchNumber >= 0 && touchNumber < maxTouches && display->touchFunc) {
                    double x = (double)AMotionEvent_getX(event, i);
                    double y = (double)AMotionEvent_getY(event, i);
                    display->touchFunc(display, touchNumber, phase, x, y);
                }
            }
        } else {
            const size_t index = (size_t)(((uint32_t)action &
                    (uint32_t)AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >>
                    (uint32_t)AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT);
            const int touchNumber = AMotionEvent_getPointerId(event, index);
            if (touchNumber >= 0 && touchNumber < maxTouches && display->touchFunc) {
                double x = (double)AMotionEvent_getX(event, index);
                double y = (double)AMotionEvent_getY(event, index);
                display->touchFunc(display, touchNumber, phase, x, y);
            }
        }
    }
    return true;
}

static void glfm__onInputEvent(GLFMPlatformData *platformData) {
    AInputEvent *event = NULL;
    while (AInputQueue_getEvent(platformData->inputQueue, &event) >= 0) {
        bool skipPreDispatch = (AInputEvent_getType(event) == AINPUT_EVENT_TYPE_KEY &&
                                AKeyEvent_getKeyCode(event) == AKEYCODE_BACK);

        if (!skipPreDispatch && AInputQueue_preDispatchEvent(platformData->inputQueue, event)) {
            continue;
        }

        bool handled = false;
        int32_t eventType = AInputEvent_getType(event);
        if (eventType == AINPUT_EVENT_TYPE_KEY) {
            handled = glfm__onKeyEvent(platformData, event);
        } else if (eventType == AINPUT_EVENT_TYPE_MOTION) {
            handled = glfm__onTouchEvent(platformData, event);
        }
        AInputQueue_finishEvent(platformData->inputQueue, event, (int)handled);
    }
}

static void glfm__onSensorEvent(GLFMPlatformData *platformData) {
    ASensorEvent event;
    bool sensorEventReceived[GLFM_NUM_SENSORS] = { 0 };
    while (ASensorEventQueue_getEvents(platformData->sensorEventQueue, &event, 1) > 0) {
        if (event.type == ASENSOR_TYPE_ACCELEROMETER) {
            // Convert to iOS format
            GLFMSensorEvent *sensorEvent = &platformData->sensorEvent[GLFMSensorAccelerometer];
            sensorEvent->sensor = GLFMSensorAccelerometer;
            sensorEvent->timestamp = (double)event.timestamp / 1000000000.0;
            sensorEvent->vector.x = (double)event.acceleration.x / -(double)ASENSOR_STANDARD_GRAVITY;
            sensorEvent->vector.y = (double)event.acceleration.y / -(double)ASENSOR_STANDARD_GRAVITY;
            sensorEvent->vector.z = (double)event.acceleration.z / -(double)ASENSOR_STANDARD_GRAVITY;
            sensorEventReceived[GLFMSensorAccelerometer] = true;
            platformData->sensorEventValid[GLFMSensorAccelerometer] = true;
        } else if (event.type == ASENSOR_TYPE_MAGNETIC_FIELD) {
            GLFMSensorEvent *sensorEvent = &platformData->sensorEvent[GLFMSensorMagnetometer];
            sensorEvent->sensor = GLFMSensorMagnetometer;
            sensorEvent->timestamp = (double)event.timestamp / 1000000000.0;
            sensorEvent->vector.x = (double)event.magnetic.x;
            sensorEvent->vector.y = (double)event.magnetic.y;
            sensorEvent->vector.z = (double)event.magnetic.z;
            sensorEventReceived[GLFMSensorMagnetometer] = true;
            platformData->sensorEventValid[GLFMSensorMagnetometer] = true;
        } else if (event.type == ASENSOR_TYPE_GYROSCOPE) {
            GLFMSensorEvent *sensorEvent = &platformData->sensorEvent[GLFMSensorGyroscope];
            sensorEvent->sensor = GLFMSensorGyroscope;
            sensorEvent->timestamp = (double)event.timestamp / 1000000000.0;
            sensorEvent->vector.x = (double)event.vector.x;
            sensorEvent->vector.y = (double)event.vector.y;
            sensorEvent->vector.z = (double)event.vector.z;
            sensorEventReceived[GLFMSensorGyroscope] = true;
            platformData->sensorEventValid[GLFMSensorGyroscope] = true;
        } else if (event.type == ASENSOR_TYPE_ROTATION_VECTOR) {
            const int SDK_INT = platformData->activity->sdkVersion;

            GLFMSensorEvent *sensorEvent = &platformData->sensorEvent[GLFMSensorRotationMatrix];
            sensorEvent->sensor = GLFMSensorRotationMatrix;
            sensorEvent->timestamp = (double)event.timestamp / 1000000000.0;

            // Get unit quaternion
            double qx = (double)event.vector.x;
            double qy = (double)event.vector.y;
            double qz = (double)event.vector.z;
            double qw;
            if (SDK_INT >= 18) {
                qw = (double)event.data[3];
            } else {
                qw = 1 - (qx * qx + qy * qy + qz * qz);
                qw = (qw > 0) ? sqrt(qw) : 0;
            }

            /*
             * Convert unit quaternion to rotation matrix.
             *
             * First, convert Android's reference frame to the same as iOS.
             * Android uses a reference frame where the Y axis points north,
             * and iOS uses a reference frame where the X axis points north.
             *
             * To convert the unit quaternion, pre-multiply the unit quaternion by
             * a rotation of -90 degrees around the Z axis.
             *
             * a=-90
             * q1 = cos(a/2) + 0i + 0j + sin(a/2)k
             *
             * Which is the same as:
             *
             * f = sqrt(2)/2
             * q1 = f + 0i + 0j - fk
             *
             * Multiplying two quaternions, where q2 is the original Android quaternion:
             *
             * q1q2 = (w1w2 - x1x2 - y1y2 - z1z2) +
             *        (w1x2 + x1w2 + y1z2 - z1y2)i +
             *        (w1y2 + z1x2 + y1w2 - x1z2)j +
             *        (w1z2 + x1y2 + z1w2 - y1x2)k
             *
             * Where x1 == 0, y1 == 0, z1 == -f, w1 == f:
             *
             * q1q2 = (f * (z2 + w2)) +
             *        (f * (y2 + x2))i +
             *        (f * (y2 - x2))j +
             *        (f * (z2 + w2))k
             *
             * In C:
             *
             * double f = sqrt(2)/2;
             * double qx_ = f * (qy + qx);
             * double qy_ = f * (qy - qx);
             * double qz_ = f * (qz - qw);
             * double qw_ = f * (qz + qw);
             *
             * However, since f*f == 0.5, and we don't need the converted quaternion,
             * we can remove a few multiplications.
            */
#if 0
            // Original (no conversion)
            double qxx2 = qx * qx * 2;
            double qxy2 = qx * qy * 2;
            double qxz2 = qx * qz * 2;
            double qxw2 = qx * qw * 2;
            double qyy2 = qy * qy * 2;
            double qyz2 = qy * qz * 2;
            double qyw2 = qy * qw * 2;
            double qzz2 = qz * qz * 2;
            double qzw2 = qz * qw * 2;
#else
            // Conversion to the same reference frame as iOS
            double qx_ = qy + qx;
            double qy_ = qy - qx;
            double qz_ = qz - qw;
            double qw_ = qz + qw;

            double qxx2 = qx_ * qx_;
            double qxy2 = qx_ * qy_;
            double qxz2 = qx_ * qz_;
            double qxw2 = qx_ * qw_;
            double qyy2 = qy_ * qy_;
            double qyz2 = qy_ * qz_;
            double qyw2 = qy_ * qw_;
            double qzz2 = qz_ * qz_;
            double qzw2 = qz_ * qw_;
#endif
            sensorEvent->matrix.m00 = 1 - qyy2 - qzz2;
            sensorEvent->matrix.m10 = qxy2 - qzw2;
            sensorEvent->matrix.m20 = qxz2 + qyw2;
            sensorEvent->matrix.m01 = qxy2 + qzw2;
            sensorEvent->matrix.m11 = 1 - qxx2 - qzz2;
            sensorEvent->matrix.m21 = qyz2 - qxw2;
            sensorEvent->matrix.m02 = qxz2 - qyw2;
            sensorEvent->matrix.m12 = qyz2 + qxw2;
            sensorEvent->matrix.m22 = 1 - qxx2 - qyy2;

            sensorEventReceived[GLFMSensorRotationMatrix] = true;
            platformData->sensorEventValid[GLFMSensorRotationMatrix] = true;
        }
    }

    // Send callbacks
    for (int i = 0; i < GLFM_NUM_SENSORS; i++) {
        GLFMSensorFunc sensorFunc = platformData->display->sensorFuncs[i];
        if (sensorFunc && sensorEventReceived[i]) {
            sensorFunc(platformData->display, platformData->sensorEvent[i]);
        }
    }
}

// MARK: - Thread entry point

static void *glfm__mainLoop(void *param) {
    GLFM_LOG_LIFECYCLE("glfm__mainLoop");

    // Init platform data
    GLFMPlatformData *platformData = param;
    platformData->refreshRequested = true;
    platformData->lastSwapTime = glfmGetTime();
    platformData->config = AConfiguration_new();
    AConfiguration_fromAssetManager(platformData->config, platformData->activity->assetManager);

    // Init looper
    platformData->looper = ALooper_prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS);
    ALooper_addFd(platformData->looper, platformData->commandPipeRead,
                  GLFMLooperIDCommand, ALOOPER_EVENT_INPUT, NULL, NULL);

    // Init java env
    JavaVM *jvm = platformData->activity->vm;
    (*jvm)->AttachCurrentThread(jvm, &platformData->jniEnv, NULL);

    // Get display scale
    const int ACONFIGURATION_DENSITY_ANY = 0xfffe; // Added in API 21
    const int32_t density = AConfiguration_getDensity(platformData->config);
    if (density == ACONFIGURATION_DENSITY_DEFAULT || density == ACONFIGURATION_DENSITY_NONE ||
            density == ACONFIGURATION_DENSITY_ANY || density <= 0) {
        platformData->scale = 1.0;
    } else {
        platformData->scale = density / 160.0;
    }

    // Call glfmMain() (once per instance)
    if (platformData->display == NULL) {
        GLFM_LOG_LIFECYCLE("glfmMain");
        platformData->display = calloc(1, sizeof(GLFMDisplay));
        platformData->display->platformData = platformData;
        platformData->display->supportedOrientations = GLFMInterfaceOrientationAll;
        platformData->display->swapBehavior = GLFMSwapBehaviorPlatformDefault;
        platformData->resizeEventWaitFrames = GLFM_RESIZE_EVENT_MAX_WAIT_FRAMES;
        glfmMain(platformData->display);
    }

    // Setup window params
    int32_t windowFormat;
    if (platformData->display->colorFormat == GLFMColorFormatRGB565) {
        windowFormat = WINDOW_FORMAT_RGB_565;
    } else {
        windowFormat = WINDOW_FORMAT_RGBA_8888;
    }
    bool fullscreen = platformData->display->uiChrome == GLFMUserInterfaceChromeNone;
    ANativeActivity_setWindowFormat(platformData->activity, windowFormat);
    ANativeActivity_setWindowFlags(platformData->activity,
                                   fullscreen ? AWINDOW_FLAG_FULLSCREEN : 0, AWINDOW_FLAG_FULLSCREEN);
    glfm__updateUserInterfaceChrome(platformData);
    if (platformData->activity->sdkVersion >= 28) {
        // Allow rendering in cutout areas ("safe area") in both portrait and landscape.
        // Test this code in Settings -> Developer Options -> Simulate a display with a cutout.
        static const int LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES = 0x00000001;

        JNIEnv *jni = platformData->jniEnv;
        jobject window = glfm__callJavaMethod(jni, platformData->activity->clazz, "getWindow",
                                              "()Landroid/view/Window;", Object);
        jobject attributes = glfm__callJavaMethod(jni, window, "getAttributes",
                                                  "()Landroid/view/WindowManager$LayoutParams;", Object);
        jclass clazz = (*jni)->GetObjectClass(jni, attributes);
        jfieldID layoutInDisplayCutoutMode = (*jni)->GetFieldID(jni, clazz, "layoutInDisplayCutoutMode", "I");

        (*jni)->SetIntField(jni, attributes, layoutInDisplayCutoutMode,
                LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES);
        (*jni)->DeleteLocalRef(jni, clazz);
        (*jni)->DeleteLocalRef(jni, attributes);
        (*jni)->DeleteLocalRef(jni, window);
    }

    // Get initial values for reporting changes. First insets are valid until later.
    platformData->orientation = glfmGetInterfaceOrientation(platformData->display);
    platformData->insets.valid = false;

    // Notify thread running
    pthread_mutex_lock(&platformData->mutex);
    platformData->threadRunning = true;
    pthread_cond_broadcast(&platformData->cond);
    pthread_mutex_unlock(&platformData->mutex);

    // Run the main loop
    while (!platformData->destroyRequested) {

        // Poll input
        int eventIdentifier;
        while ((eventIdentifier = ALooper_pollOnce(platformData->animating ? 0 : -1,
                                                   NULL, NULL, NULL)) > ALOOPER_POLL_TIMEOUT) {
            if (eventIdentifier == GLFMLooperIDCommand) {
                uint8_t cmd = 0;
                if (read(platformData->commandPipeRead, &cmd, sizeof(cmd)) == sizeof(cmd)) {
                    GLFMActivityCommand command = (GLFMActivityCommand)cmd;
                    glfm__onAppCmd(platformData, command);
                } else {
                    GLFM_LOG("Couldn't read from pipe");
                }
            } else if (eventIdentifier == GLFMLooperIDInput) {
                glfm__onInputEvent(platformData);
            } else if (eventIdentifier == GLFMLooperIDSensor) {
                glfm__onSensorEvent(platformData);
            }
            if (platformData->destroyRequested) {
                break;
            }
        }

        // Render
        if (platformData->animating && platformData->display) {
            platformData->swapCalled = false;
            glfm__drawFrame(platformData);
            if (!platformData->swapCalled) {
                // Sleep until next swap time (1/60 second after last swap time)
                const float refreshRate = glfm__getRefreshRate(platformData->display);
                const double sleepUntilTime = platformData->lastSwapTime + 1.0 / (double)refreshRate;
                double now = glfmGetTime();
                if (now >= sleepUntilTime) {
                    platformData->lastSwapTime = now;
                } else {
                    // Sleep until 500 microseconds before deadline
                    const double offset = 0.0005;
                    while (true) {
                        double sleepDuration = sleepUntilTime - now - offset;
                        if (sleepDuration <= 0) {
                            platformData->lastSwapTime = sleepUntilTime;
                            break;
                        }
                        useconds_t sleepDurationMicroseconds = (useconds_t) (sleepDuration * 1000000);
                        usleep(sleepDurationMicroseconds);
                        now = glfmGetTime();
                    }
                }
            }
        }
    }

    // Cleanup
    GLFM_LOG_LIFECYCLE("Destroying thread");
    if (platformData->inputQueue) {
        AInputQueue_detachLooper(platformData->inputQueue);
        platformData->inputQueue = NULL;
    }
    if (platformData->sensorEventQueue) {
        glfm__setAllRequestedSensorsEnabled(platformData->display, false);
        ASensorManager *sensorManager = ASensorManager_getInstance();
        ASensorManager_destroyEventQueue(sensorManager, platformData->sensorEventQueue);
        platformData->sensorEventQueue = NULL;
    }
    if (platformData->config) {
        AConfiguration_delete(platformData->config);
        platformData->config = NULL;
    }
    glfm__eglDestroy(platformData);
    glfm__setAnimating(platformData, false);
    (*jvm)->DetachCurrentThread(jvm);
    platformData->window = NULL;
    platformData->looper = NULL;

    // Notify thread no longer running
    pthread_mutex_lock(&platformData->mutex);
    platformData->threadRunning = false;
    pthread_cond_broadcast(&platformData->cond);
    pthread_mutex_unlock(&platformData->mutex);

    // App is destroyed, but glfm__mainLoop() can be called again in the same process.
    // Set GLFM_HANDLE_BACK_BUTTON to 0 to test this code.
    return NULL;
}

// MARK: - GLFM private functions

static jobject glfm__getDecorView(JNIEnv *jni, GLFMPlatformData *platformData) {
    if (!platformData || !platformData->activity || (*jni)->ExceptionCheck(jni)) {
        return NULL;
    }
    jobject window = glfm__callJavaMethod(jni, platformData->activity->clazz, "getWindow", "()Landroid/view/Window;",
                                          Object);
    if (glfm__wasJavaExceptionThrown(jni) || !window) {
        return NULL;
    }
    jobject decorView = glfm__callJavaMethod(jni, window, "getDecorView", "()Landroid/view/View;", Object);
    (*jni)->DeleteLocalRef(jni, window);
    return glfm__wasJavaExceptionThrown(jni) ? NULL : decorView;
}

static ARect glfm__getDecorViewRect(GLFMPlatformData *platformData, const ARect *defaultRect) {
    JNIEnv *jni = platformData->jniEnv;
    if ((*jni)->ExceptionCheck(jni)) {
        return *defaultRect;
    }

    jobject decorView = glfm__getDecorView(jni, platformData);
    if (!decorView) {
        return *defaultRect;
    }

    jintArray locationArray = (*jni)->NewIntArray(jni, 2);
    if (!locationArray) {
        (*jni)->DeleteLocalRef(jni, decorView);
        return *defaultRect;
    }

    jint location[2] = { 0 };
    glfm__callJavaMethodWithArgs(jni, decorView, "getLocationInWindow", "([I)V", Void, locationArray);
    (*jni)->GetIntArrayRegion(jni, locationArray, 0, 2, location);
    (*jni)->DeleteLocalRef(jni, locationArray);
    if ((*jni)->ExceptionCheck(jni)) {
        (*jni)->DeleteLocalRef(jni, decorView);
        return *defaultRect;
    }

    jint width = glfm__callJavaMethod(jni, decorView, "getWidth", "()I", Int);
    jint height = glfm__callJavaMethod(jni, decorView, "getHeight", "()I", Int);
    (*jni)->DeleteLocalRef(jni, decorView);
    if ((*jni)->ExceptionCheck(jni)) {
        return *defaultRect;
    }

    ARect result;
    result.left = location[0];
    result.top = location[1];
    result.right = location[0] + width;
    result.bottom = location[1] + height;
    return result;
}

static void glfm__updateUserInterfaceChromeCallback(GLFMPlatformData *platformData, void *userData) {
    (void)userData;
    glfm__updateUserInterfaceChrome(platformData);
}

// Can be called from either native thread or UI thread
static void glfm__updateUserInterfaceChrome(GLFMPlatformData *platformData) {
    static const unsigned int View_STATUS_BAR_HIDDEN = 0x00000001;
    static const unsigned int View_SYSTEM_UI_FLAG_LOW_PROFILE = 0x00000001;
    static const unsigned int View_SYSTEM_UI_FLAG_HIDE_NAVIGATION = 0x00000002;
    static const unsigned int View_SYSTEM_UI_FLAG_FULLSCREEN = 0x00000004;
    static const unsigned int View_SYSTEM_UI_FLAG_LAYOUT_STABLE = 0x00000100;
    static const unsigned int View_SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION = 0x00000200;
    static const unsigned int View_SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN = 0x00000400;
    static const unsigned int View_SYSTEM_UI_FLAG_IMMERSIVE_STICKY = 0x00001000;

    if (!platformData || !platformData->activity) {
        return;
    }
    const int SDK_INT = platformData->activity->sdkVersion;
    if (SDK_INT < 11) {
        return;
    }

    JavaVM *jvm = platformData->activity->vm;
    JNIEnv *jni = NULL;
    (*jvm)->GetEnv(jvm, (void **) &jni, JNI_VERSION_1_2);
    if (!jni || (*jni)->ExceptionCheck(jni)) {
        return;
    }

    jobject decorView = glfm__getDecorView(jni, platformData);
    if (!decorView) {
        return;
    }

    GLFMUserInterfaceChrome uiChrome = platformData->display->uiChrome;
    bool setNow = true;
    bool isUiThread = ALooper_forThread() == platformData->uiLooper;
    if (!isUiThread) {
        bool isDecorViewAttached;
        if (SDK_INT >= 19) {
            isDecorViewAttached = glfm__callJavaMethod(jni, decorView, "isAttachedToWindow", "()Z", Boolean);
        } else {
            isDecorViewAttached = glfm__callJavaMethod(jni, decorView, "getWindowToken", "()Landroid/os/IBinder;",
                                                       Object) != NULL;
        }
        if (glfm__wasJavaExceptionThrown(jni)) {
            (*jni)->DeleteLocalRef(jni, decorView);
            return;
        }
        setNow = !isDecorViewAttached;
    }

    if (!setNow) {
        // Set on the UI thread
        glfm__runOnUIThread(platformData, glfm__updateUserInterfaceChromeCallback, NULL);
    } else {
        // Set now
        if (SDK_INT >= 30) {
            jobject windowInsetsController = glfm__callJavaMethod(jni, decorView, "getWindowInsetsController",
                                                                  "()Landroid/view/WindowInsetsController;", Object);
            jclass windowInsetsTypeClass = (*jni)->FindClass(jni, "android/view/WindowInsets$Type");
            if (windowInsetsController && windowInsetsTypeClass && !glfm__wasJavaExceptionThrown(jni)) {
                static const jint WindowInsetsController_BEHAVIOR_DEFAULT = 1;
                static const jint WindowInsetsController_BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE = 2;

                const jint systemBars = glfm__callJavaStaticMethod(jni, windowInsetsTypeClass, "systemBars",
                                                                   "()I", Int);

                if (uiChrome == GLFMUserInterfaceChromeNone) {
                    glfm__callJavaMethodWithArgs(jni, windowInsetsController, "setSystemBarsBehavior", "(I)V", Void,
                                                 WindowInsetsController_BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE);
                    glfm__callJavaMethodWithArgs(jni, windowInsetsController, "hide", "(I)V", Void, systemBars);
                } else {
                    glfm__callJavaMethodWithArgs(jni, windowInsetsController, "setSystemBarsBehavior", "(I)V", Void,
                                                 WindowInsetsController_BEHAVIOR_DEFAULT);
                    if (uiChrome == GLFMUserInterfaceChromeNavigationAndStatusBar) {
                        glfm__callJavaMethodWithArgs(jni, windowInsetsController, "show", "(I)V", Void, systemBars);
                    } else if (uiChrome == GLFMUserInterfaceChromeNavigation) {
                        const jint statusBars = glfm__callJavaStaticMethod(jni, windowInsetsTypeClass, "statusBars",
                                                                           "()I", Int);
                        glfm__callJavaMethodWithArgs(jni, windowInsetsController, "hide", "(I)V", Void, statusBars);
                        glfm__callJavaMethodWithArgs(jni, windowInsetsController, "show", "(I)V", Void,
                                                     systemBars & ~statusBars);
                    }
                }

                (*jni)->DeleteLocalRef(jni, windowInsetsController);
                (*jni)->DeleteLocalRef(jni, windowInsetsTypeClass);
                glfm__clearJavaException(jni);
            }
        } else {
            unsigned int systemUiVisibility = 0;
            if (uiChrome == GLFMUserInterfaceChromeNavigationAndStatusBar) {
                systemUiVisibility = 0;
            } else if (SDK_INT >= 11 && SDK_INT < 14) {
                systemUiVisibility = View_STATUS_BAR_HIDDEN;
            } else if (SDK_INT >= 14 && SDK_INT < 19) {
                if (uiChrome == GLFMUserInterfaceChromeNavigation) {
                    systemUiVisibility = View_SYSTEM_UI_FLAG_FULLSCREEN;
                } else {
                    systemUiVisibility = (View_SYSTEM_UI_FLAG_LOW_PROFILE | View_SYSTEM_UI_FLAG_FULLSCREEN);
                }
            } else if (SDK_INT >= 19) {
                if (uiChrome == GLFMUserInterfaceChromeNavigation) {
                    systemUiVisibility = View_SYSTEM_UI_FLAG_FULLSCREEN;
                } else {
                    systemUiVisibility = (View_SYSTEM_UI_FLAG_HIDE_NAVIGATION |
                                          View_SYSTEM_UI_FLAG_FULLSCREEN |
                                          View_SYSTEM_UI_FLAG_LAYOUT_STABLE |
                                          View_SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |
                                          View_SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN |
                                          View_SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
                }
            }

            glfm__callJavaMethodWithArgs(jni, decorView, "setSystemUiVisibility", "(I)V", Void,
                                         (jint)systemUiVisibility);
            glfm__clearJavaException(jni);
        }
    }
    (*jni)->DeleteLocalRef(jni, decorView);
}

static void glfm__resetContentRect(GLFMPlatformData *platformData) {
    // Reset's NativeActivity's content rect so that onContentRectChanged acts as a OnGlobalLayoutListener. This is
    // needed to detect changes to getWindowVisibleDisplayFrame()
    // HACK: This uses undocumented fields.

    JavaVM *jvm = platformData->activity->vm;
    JNIEnv *jni = NULL;
    (*jvm)->GetEnv(jvm, (void **) &jni, JNI_VERSION_1_2);
    if (!jni || (*jni)->ExceptionCheck(jni)) {
        return;
    }

    jfieldID field = glfm__getJavaFieldID(jni, platformData->activity->clazz, "mLastContentWidth", "I");
    if (glfm__wasJavaExceptionThrown(jni) || !field) {
        return;
    }

    (*jni)->SetIntField(jni, platformData->activity->clazz, field, -1);
    glfm__clearJavaException(jni);
}

static ARect glfm__getWindowVisibleDisplayFrame(GLFMPlatformData *platformData, const ARect *defaultRect) {
    JNIEnv *jni = platformData->jniEnv;
    if ((*jni)->ExceptionCheck(jni)) {
        return *defaultRect;
    }

    jobject decorView = glfm__getDecorView(jni, platformData);
    if (!decorView) {
        return *defaultRect;
    }

    jclass javaRectClass = (*jni)->FindClass(jni, "android/graphics/Rect");
    if (glfm__wasJavaExceptionThrown(jni)) {
        return *defaultRect;
    }

    jobject javaRect = (*jni)->AllocObject(jni, javaRectClass);
    if (glfm__wasJavaExceptionThrown(jni)) {
        return *defaultRect;
    }

    glfm__callJavaMethodWithArgs(jni, decorView, "getWindowVisibleDisplayFrame",
                                 "(Landroid/graphics/Rect;)V", Void, javaRect);
    if (glfm__wasJavaExceptionThrown(jni)) {
        return *defaultRect;
    }

    ARect rect;
    rect.left = glfm__getJavaField(jni, javaRect, "left", "I", Int);
    rect.right = glfm__getJavaField(jni, javaRect, "right", "I", Int);
    rect.top = glfm__getJavaField(jni, javaRect, "top", "I", Int);
    rect.bottom = glfm__getJavaField(jni, javaRect, "bottom", "I", Int);
    (*jni)->DeleteLocalRef(jni, javaRect);
    (*jni)->DeleteLocalRef(jni, javaRectClass);
    if (glfm__wasJavaExceptionThrown(jni)) {
        return *defaultRect;
    }

    jintArray locationArray = (*jni)->NewIntArray(jni, 2);
    if (locationArray) {
        jint location[2] = { 0 };
        glfm__callJavaMethodWithArgs(jni, decorView, "getLocationOnScreen", "([I)V", Void, locationArray);
        (*jni)->GetIntArrayRegion(jni, locationArray, 0, 2, location);
        (*jni)->DeleteLocalRef(jni, locationArray);
        if (!glfm__wasJavaExceptionThrown(jni)) {
            rect.left -= location[0];
            rect.top -= location[1];
        }
    }

    (*jni)->DeleteLocalRef(jni, decorView);
    return rect;
}

static bool glfm__getSafeInsets(const GLFMDisplay *display, int *top, int *right, int *bottom, int *left) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    const int SDK_INT = platformData->activity->sdkVersion;
    if (SDK_INT < 28) { // getDisplayCutout()
        return false;
    }

    JNIEnv *jni = platformData->jniEnv;
    jobject decorView = glfm__getDecorView(jni, platformData);
    if (!decorView) {
        return false;
    }

    jobject insets = glfm__callJavaMethod(jni, decorView, "getRootWindowInsets",
                                          "()Landroid/view/WindowInsets;", Object);
    (*jni)->DeleteLocalRef(jni, decorView);
    if (!insets) {
        return false;
    }

    jobject cutouts = glfm__callJavaMethod(jni, insets, "getDisplayCutout", "()Landroid/view/DisplayCutout;", Object);
    (*jni)->DeleteLocalRef(jni, insets);
    if (!cutouts) {
        return false;
    }

    *top = glfm__callJavaMethod(jni, cutouts, "getSafeInsetTop", "()I", Int);
    *right = glfm__callJavaMethod(jni, cutouts, "getSafeInsetRight", "()I", Int);
    *bottom = glfm__callJavaMethod(jni, cutouts, "getSafeInsetBottom", "()I", Int);
    *left = glfm__callJavaMethod(jni, cutouts, "getSafeInsetLeft", "()I", Int);

    (*jni)->DeleteLocalRef(jni, cutouts);
    return true;
}

static bool glfm__getSystemWindowInsets(const GLFMDisplay *display, int *top, int *right, int *bottom, int *left) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    const int SDK_INT = platformData->activity->sdkVersion;
    if (SDK_INT < 23) { // getRootWindowInsets()
        return false;
    }

    JNIEnv *jni = platformData->jniEnv;
    jobject decorView = glfm__getDecorView(jni, platformData);
    if (!decorView) {
        return false;
    }

    jobject insets = glfm__callJavaMethod(jni, decorView, "getRootWindowInsets",
                                          "()Landroid/view/WindowInsets;", Object);
    (*jni)->DeleteLocalRef(jni, decorView);
    if (!insets) {
        return false;
    }

    *top = glfm__callJavaMethod(jni, insets, "getSystemWindowInsetTop", "()I", Int);
    *right = glfm__callJavaMethod(jni, insets, "getSystemWindowInsetRight", "()I", Int);
    *bottom = glfm__callJavaMethod(jni, insets, "getSystemWindowInsetBottom", "()I", Int);
    *left = glfm__callJavaMethod(jni, insets, "getSystemWindowInsetLeft", "()I", Int);

    (*jni)->DeleteLocalRef(jni, insets);
    return true;
}

// Calls activity.getWindow().getWindowManager().getDefaultDisplay()
static jobject glfm__getWindowDisplay(GLFMPlatformData *platformData) {
    JNIEnv *jni = platformData->jniEnv;
    jobject activity = platformData->activity->clazz;
    jobject window = glfm__callJavaMethod(jni, activity, "getWindow", "()Landroid/view/Window;", Object);
    if (glfm__wasJavaExceptionThrown(jni) || !window) {
        return NULL;
    }
    jobject windowManager = glfm__callJavaMethod(jni, window, "getWindowManager",
                                                 "()Landroid/view/WindowManager;", Object);
    (*jni)->DeleteLocalRef(jni, window);
    if (glfm__wasJavaExceptionThrown(jni) || !windowManager) {
        return NULL;
    }
    jobject windowDisplay = glfm__callJavaMethod(jni, windowManager, "getDefaultDisplay",
                                                 "()Landroid/view/Display;", Object);
    (*jni)->DeleteLocalRef(jni, windowManager);
    if (glfm__wasJavaExceptionThrown(jni)) {
        return NULL;
    }
    return windowDisplay;
}

static float glfm__getRefreshRate(const GLFMDisplay *display) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    JNIEnv *jni = platformData->jniEnv;
    float refreshRate = -1;
    jobject windowDisplay = glfm__getWindowDisplay(platformData);
    if (windowDisplay) {
        refreshRate = glfm__callJavaMethod(jni, windowDisplay, "getRefreshRate","()F", Float);
        (*jni)->DeleteLocalRef(jni, windowDisplay);
    }
    if (glfm__wasJavaExceptionThrown(jni) || refreshRate <= 0) {
        return 60;
    }
    return refreshRate;
}

static bool glfm__updateSurfaceSizeIfNeeded(GLFMDisplay *display, bool force) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    int32_t width = 0;
    int32_t height = 0;
    EGLBoolean success = true;
    success &= eglQuerySurface(platformData->eglDisplay, platformData->eglSurface, EGL_WIDTH, &width);
    success &= eglQuerySurface(platformData->eglDisplay, platformData->eglSurface, EGL_HEIGHT, &height);
    if (success && (width != platformData->width || height != platformData->height)) {
        if (force || platformData->resizeEventWaitFrames <= 0) {
            GLFM_LOG_LIFECYCLE("Resize: %i x %i", width, height);
            platformData->resizeEventWaitFrames = GLFM_RESIZE_EVENT_MAX_WAIT_FRAMES;
            platformData->refreshRequested = true;
            platformData->width = width;
            platformData->height = height;
            if (platformData->display && platformData->display->surfaceResizedFunc) {
                platformData->display->surfaceResizedFunc(platformData->display, width, height);
            }
            glfm__reportOrientationChangeIfNeeded(platformData->display);
            glfm__reportInsetsChangedIfNeeded(platformData->display);
            glfm__updateKeyboardVisibility(platformData);
            return true;
        }
        // Prefer to wait until after content rect changed, if possible
        platformData->resizeEventWaitFrames--;
    }
    return false;
}

static void glfm__getDisplayChromeInsets(const GLFMDisplay *display, int *top, int *right, int *bottom, int *left) {
    bool success;
    if (glfmGetDisplayChrome(display) == GLFMUserInterfaceChromeNone) {
        success = glfm__getSafeInsets(display, top, right, bottom, left);
    } else {
        success = glfm__getSystemWindowInsets(display, top, right, bottom, left);
    }
    if (!success) {
        GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
        const ARect *contentRect = &platformData->contentRectArray[platformData->contentRectIndex];
        ARect visibleRect = glfm__getWindowVisibleDisplayFrame(platformData, contentRect);
        // When rotating on some devices (API 16), the dimensions and visible display frame may be out of sync
        // for a moment. Report insets of 0 when this happens.
        if (visibleRect.right - visibleRect.left <= 0 || visibleRect.bottom - visibleRect.top <= 0 ||
            visibleRect.right > platformData->width || visibleRect.bottom > platformData->height) {
            *top = 0;
            *right = 0;
            *bottom = 0;
            *left = 0;
        } else {
            *top = visibleRect.top;
            *right = platformData->width - visibleRect.right;
            *bottom = platformData->height - visibleRect.bottom;
            *left = visibleRect.left;
        }
    }
}

static void glfm__reportInsetsChangedIfNeeded(GLFMDisplay *display) {
    if (!display) {
        return;
    }
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    int top, right, bottom, left;
    glfm__getDisplayChromeInsets(display, &top, &right, &bottom, &left);
    if (platformData->insets.top != top || platformData->insets.right != right ||
        platformData->insets.bottom != bottom || platformData->insets.left != left) {
        platformData->insets.top = top;
        platformData->insets.right = right;
        platformData->insets.bottom = bottom;
        platformData->insets.left = left;
        if (display->displayChromeInsetsChangedFunc && platformData->insets.valid) {
            display->displayChromeInsetsChangedFunc(display, (double)top, (double)top,
                                                    (double)bottom, (double)left);
        }
    }
    platformData->insets.valid = true;
}

static void glfm__reportOrientationChangeIfNeeded(GLFMDisplay *display) {
    if (!display) {
        return;
    }
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    GLFMInterfaceOrientation orientation = glfmGetInterfaceOrientation(display);
    if (platformData->orientation != orientation) {
        platformData->orientation = orientation;
        platformData->refreshRequested = true;
        if (display->orientationChangedFunc) {
            display->orientationChangedFunc(display, orientation);
        }
    }
}

static void glfm__setOrientation(GLFMPlatformData *platformData) {
    static const int ActivityInfo_SCREEN_ORIENTATION_SENSOR = 0x00000004;
    static const int ActivityInfo_SCREEN_ORIENTATION_SENSOR_LANDSCAPE = 0x00000006;
    static const int ActivityInfo_SCREEN_ORIENTATION_SENSOR_PORTRAIT = 0x00000007;

    if (!platformData || !platformData->activity) {
        return;
    }
    GLFMInterfaceOrientation orientations = platformData->display->supportedOrientations;
    bool portraitRequested = (
            ((uint8_t)orientations & (uint8_t)GLFMInterfaceOrientationPortrait) ||
            ((uint8_t)orientations & (uint8_t)GLFMInterfaceOrientationPortraitUpsideDown));
    bool landscapeRequested = ((uint8_t)orientations & (uint8_t)GLFMInterfaceOrientationLandscape);
    int orientation;
    if (portraitRequested && landscapeRequested) {
        orientation = ActivityInfo_SCREEN_ORIENTATION_SENSOR;
    } else if (landscapeRequested) {
        orientation = ActivityInfo_SCREEN_ORIENTATION_SENSOR_LANDSCAPE;
    } else {
        orientation = ActivityInfo_SCREEN_ORIENTATION_SENSOR_PORTRAIT;
    }

    JNIEnv *jni = platformData->jniEnv;
    if ((*jni)->ExceptionCheck(jni)) {
        return;
    }

    glfm__callJavaMethodWithArgs(jni, platformData->activity->clazz, "setRequestedOrientation", "(I)V", Void,
                                 orientation);
    glfm__clearJavaException(jni);
}

static void glfm__displayChromeUpdated(GLFMDisplay *display) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    glfm__updateUserInterfaceChrome(platformData);
}

static const ASensor *glfm__getDeviceSensor(GLFMSensor sensor) {
    ASensorManager *sensorManager = ASensorManager_getInstance();
    switch (sensor) {
        case GLFMSensorAccelerometer:
            return ASensorManager_getDefaultSensor(sensorManager, ASENSOR_TYPE_ACCELEROMETER);
        case GLFMSensorMagnetometer:
            return ASensorManager_getDefaultSensor(sensorManager, ASENSOR_TYPE_MAGNETIC_FIELD);
        case GLFMSensorGyroscope:
            return ASensorManager_getDefaultSensor(sensorManager, ASENSOR_TYPE_GYROSCOPE);
        case GLFMSensorRotationMatrix:
            return ASensorManager_getDefaultSensor(sensorManager, ASENSOR_TYPE_ROTATION_VECTOR);
        default:
            return NULL;
    }
}

static void glfm__setAllRequestedSensorsEnabled(GLFMDisplay *display, bool enabledGlobally) {
    if (!display) {
        return;
    }
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    for (int i = 0; i < GLFM_NUM_SENSORS; i++) {
        GLFMSensor sensor = (GLFMSensor)i;
        const ASensor *deviceSensor = glfm__getDeviceSensor(sensor);
        bool isNeededEnabled = display->sensorFuncs[i] != NULL;
        bool shouldEnable = enabledGlobally && isNeededEnabled;
        bool isEnabled = platformData->deviceSensorEnabled[i];
        if (!shouldEnable) {
            platformData->sensorEventValid[i] = false;
        }

        if (isEnabled == shouldEnable || deviceSensor == NULL) {
            continue;
        }
        if (platformData->sensorEventQueue == NULL) {
            ASensorManager *sensorManager = ASensorManager_getInstance();
            platformData->sensorEventQueue = ASensorManager_createEventQueue(sensorManager,
                    ALooper_forThread(), GLFMLooperIDSensor, NULL, NULL);
            if (!platformData->sensorEventQueue) {
                continue;
            }
        }
        if (shouldEnable && !isEnabled) {
            if (ASensorEventQueue_enableSensor(platformData->sensorEventQueue, deviceSensor) == 0) {
                int minDelay = ASensor_getMinDelay(deviceSensor);
                if (minDelay > 0) {
                    int delay = GLFM_SENSOR_UPDATE_INTERVAL_MICROS;
                    if (delay < minDelay) {
                        delay = minDelay;
                    }
                    ASensorEventQueue_setEventRate(platformData->sensorEventQueue, deviceSensor,
                                                   delay);
                }
                platformData->deviceSensorEnabled[i] = true;
            }
        } else if (!shouldEnable && isEnabled) {
            if (ASensorEventQueue_disableSensor(platformData->sensorEventQueue, deviceSensor) == 0) {
                platformData->deviceSensorEnabled[i] = false;
            }
        }
    }
}

static void glfm__sensorFuncUpdated(GLFMDisplay *display) {
    if (display) {
        GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
        glfm__setAllRequestedSensorsEnabled(display, platformData->animating);
    }
}

/// Gets an Android system service. The "serviceName" is a field from android.content.Context, like
/// "INPUT_METHOD_SERVICE" or "VIBRATOR_SERVICE".
///
/// The C code:
///     glfm__getSystemService(platformData, "INPUT_METHOD_SERVICE")
/// will invoke the java code:
///     activity.getSystemService(Context.INPUT_METHOD_SERVICE);
static jobject glfm__getSystemService(GLFMPlatformData *platformData, const char *serviceName) {
    JNIEnv *jni = platformData->jniEnv;
    jclass contextClass = (*jni)->FindClass(jni, "android/content/Context");
    if (glfm__wasJavaExceptionThrown(jni)) {
        return NULL;
    }

    jstring serviceNameString = glfm__getJavaStaticField(jni, contextClass, serviceName, "Ljava/lang/String;", Object);
    (*jni)->DeleteLocalRef(jni, contextClass);
    if (glfm__wasJavaExceptionThrown(jni) || !serviceNameString) {
        return NULL;
    }
    jobject service = glfm__callJavaMethodWithArgs(jni, platformData->activity->clazz, "getSystemService",
                                                   "(Ljava/lang/String;)Ljava/lang/Object;", Object, serviceNameString);
    (*jni)->DeleteLocalRef(jni, serviceNameString);
    if (glfm__wasJavaExceptionThrown(jni)) {
        return NULL;
    }
    return service;
}

static bool glfm__setKeyboardVisible(GLFMPlatformData *platformData, bool visible) {
    static const int InputMethodManager_SHOW_FORCED = 2;

    JNIEnv *jni = platformData->jniEnv;
    if ((*jni)->ExceptionCheck(jni)) {
        return false;
    }

    jobject decorView = glfm__getDecorView(jni, platformData);
    if (!decorView) {
        return false;
    }

    jobject ime = glfm__getSystemService(platformData, "INPUT_METHOD_SERVICE");
    if (!ime) {
        return false;
    }
    if (visible) {
        int flags = 0;
        if (platformData->activity->sdkVersion < 23) {
            // This flag was deprecated in API 33. It was required for older versions of Android,
            // but it kept the soft keyboard open when leaving the app. At some point, the flag was
            // no longer required (possibly for versions prior to 23.)
            flags = InputMethodManager_SHOW_FORCED;
        }
        glfm__callJavaMethodWithArgs(jni, ime, "showSoftInput", "(Landroid/view/View;I)Z", Boolean, decorView, flags);
    } else {
        jobject windowToken = glfm__callJavaMethod(jni, decorView, "getWindowToken", "()Landroid/os/IBinder;", Object);
        if (glfm__wasJavaExceptionThrown(jni) || !windowToken) {
            return false;
        }
        glfm__callJavaMethodWithArgs(jni, ime, "hideSoftInputFromWindow", "(Landroid/os/IBinder;I)Z", Boolean,
                                     windowToken, 0);
        (*jni)->DeleteLocalRef(jni, windowToken);
    }

    (*jni)->DeleteLocalRef(jni, ime);
    (*jni)->DeleteLocalRef(jni, decorView);

    return !glfm__wasJavaExceptionThrown(jni);
}

static void glfm__updateKeyboardVisibility(GLFMPlatformData *platformData) {
    if (platformData->display) {
        const ARect *contentRect = &platformData->contentRectArray[platformData->contentRectIndex];
        ARect windowRect = glfm__getDecorViewRect(platformData, contentRect);
        ARect visibleRect = glfm__getWindowVisibleDisplayFrame(platformData, &windowRect);
        ARect nonVisibleRect[4];

        // Left
        nonVisibleRect[0].left = windowRect.left;
        nonVisibleRect[0].right = visibleRect.left;
        nonVisibleRect[0].top = windowRect.top;
        nonVisibleRect[0].bottom = windowRect.bottom;

        // Right
        nonVisibleRect[1].left = visibleRect.right;
        nonVisibleRect[1].right = windowRect.right;
        nonVisibleRect[1].top = windowRect.top;
        nonVisibleRect[1].bottom = windowRect.bottom;

        // Top
        nonVisibleRect[2].left = windowRect.left;
        nonVisibleRect[2].right = windowRect.right;
        nonVisibleRect[2].top = windowRect.top;
        nonVisibleRect[2].bottom = visibleRect.top;

        // Bottom
        nonVisibleRect[3].left = windowRect.left;
        nonVisibleRect[3].right = windowRect.right;
        nonVisibleRect[3].top = visibleRect.bottom;
        nonVisibleRect[3].bottom = windowRect.bottom;

        // Find largest with minimum keyboard size
        const int minimumKeyboardSize = (int)(100 * platformData->scale);
        int largestIndex = 0;
        int largestArea = -1;
        for (int i = 0; i < 4; i++) {
            int width = nonVisibleRect[i].right - nonVisibleRect[i].left;
            int height = nonVisibleRect[i].bottom - nonVisibleRect[i].top;
            int area = width * height;
            if (width >= minimumKeyboardSize && height >= minimumKeyboardSize && area > largestArea) {
                largestIndex = i;
                largestArea = area;
            }
        }

        bool keyboardVisible = largestArea > 0;
        ARect keyboardFrame = keyboardVisible ? nonVisibleRect[largestIndex] : (ARect){ 0 };

        // Send update notification
        if (platformData->keyboardVisible != keyboardVisible ||
            platformData->keyboardFrame.left != keyboardFrame.left ||
            platformData->keyboardFrame.top != keyboardFrame.top ||
            platformData->keyboardFrame.right != keyboardFrame.right ||
            platformData->keyboardFrame.bottom != keyboardFrame.bottom) {
            if (platformData->keyboardVisible != keyboardVisible) {
                glfm__updateUserInterfaceChrome(platformData);
            }
            platformData->keyboardVisible = keyboardVisible;
            platformData->keyboardFrame = keyboardFrame;
            platformData->refreshRequested = true;
            if (platformData->display->keyboardVisibilityChangedFunc) {
                double x = keyboardFrame.left;
                double y = keyboardFrame.top;
                double width = keyboardFrame.right - keyboardFrame.left;
                double height = keyboardFrame.bottom - keyboardFrame.top;
                platformData->display->keyboardVisibilityChangedFunc(platformData->display, keyboardVisible,
                                                                     x, y, width, height);
            }
        }
    }
}

// MARK: - GLFM public functions

double glfmGetTime(void) {
    static int clockID;
    static time_t initTime;
    static bool initialized = false;

    struct timespec time;

    if (!initialized) {
        if (clock_gettime(CLOCK_MONOTONIC_RAW, &time) == 0) {
            clockID = CLOCK_MONOTONIC_RAW;
        } else if (clock_gettime(CLOCK_MONOTONIC, &time) == 0) {
            clockID = CLOCK_MONOTONIC;
        } else {
            (void)clock_gettime(CLOCK_REALTIME, &time);
            clockID = CLOCK_REALTIME;
        }
        initTime = time.tv_sec;
        initialized = true;
    } else {
        (void)clock_gettime(clockID, &time);
    }
    // Subtract by initTime to ensure that conversion to double keeps nanosecond accuracy
    return (double)(time.tv_sec - initTime) + (double)time.tv_nsec / 1e9;
}

void glfmSwapBuffers(GLFMDisplay *display) {
    if (display) {
        GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
        EGLBoolean result = eglSwapBuffers(platformData->eglDisplay, platformData->eglSurface);
        platformData->swapCalled = true;
        platformData->lastSwapTime = glfmGetTime();
        if (!result) {
            glfm__eglCheckError(platformData);
        }
    }
}

void glfmSetSupportedInterfaceOrientation(GLFMDisplay *display, GLFMInterfaceOrientation supportedOrientations) {
    if (display && display->supportedOrientations != supportedOrientations) {
        display->supportedOrientations = supportedOrientations;
        GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
        glfm__setOrientation(platformData);
    }
}

GLFMInterfaceOrientation glfmGetInterfaceOrientation(const GLFMDisplay *display) {
    enum {
        Surface_ROTATION_0 = 0,
        Surface_ROTATION_90 = 1,
        Surface_ROTATION_180 = 2,
        Surface_ROTATION_270 = 3,
    };

    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    JNIEnv *jni = platformData->jniEnv;
    jobject windowDisplay = glfm__getWindowDisplay(platformData);
    if (!windowDisplay) {
        return GLFMInterfaceOrientationUnknown;
    }
    int rotation = glfm__callJavaMethod(jni, windowDisplay, "getRotation","()I", Int);
    (*jni)->DeleteLocalRef(jni, windowDisplay);
    if (glfm__wasJavaExceptionThrown(jni)) {
        return GLFMInterfaceOrientationUnknown;
    }

    switch (rotation) {
        case Surface_ROTATION_0:
            return GLFMInterfaceOrientationPortrait;
        case Surface_ROTATION_90:
            return GLFMInterfaceOrientationLandscapeRight;
        case Surface_ROTATION_180:
            return GLFMInterfaceOrientationPortraitUpsideDown;
        case Surface_ROTATION_270:
            return GLFMInterfaceOrientationLandscapeLeft;
        default:
            return GLFMInterfaceOrientationUnknown;
    }
}

void glfmGetDisplaySize(const GLFMDisplay *display, int *width, int *height) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    if (width) *width = platformData->width;
    if (height) *height = platformData->height;
}

double glfmGetDisplayScale(const GLFMDisplay *display) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    return platformData->scale;
}

void glfmGetDisplayChromeInsets(const GLFMDisplay *display, double *top, double *right,
                                double *bottom, double *left) {
    int intTop, intRight, intBottom, intLeft;
    glfm__getDisplayChromeInsets(display, &intTop, &intRight, &intBottom, &intLeft);
    if (top) *top = (double)intTop;
    if (right) *right = (double)intRight;
    if (bottom) *bottom = (double)intBottom;
    if (left) *left = (double)intLeft;
}

GLFMRenderingAPI glfmGetRenderingAPI(const GLFMDisplay *display) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    return platformData->renderingAPI;
}

bool glfmHasTouch(const GLFMDisplay *display) {
    (void)display;
    // This will need to change, for say, TV apps
    return true;
}

void glfmSetMouseCursor(GLFMDisplay *display, GLFMMouseCursor mouseCursor) {
    (void)display;
    (void)mouseCursor;
    // Do nothing
}

void glfmSetMultitouchEnabled(GLFMDisplay *display, bool multitouchEnabled) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    platformData->multitouchEnabled = multitouchEnabled;
}

bool glfmGetMultitouchEnabled(const GLFMDisplay *display) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    return platformData->multitouchEnabled;
}

GLFMProc glfmGetProcAddress(const char *functionName) {
    GLFMProc function = eglGetProcAddress(functionName);
    if (!function) {
        static void *handle = NULL;
        if (!handle) {
            handle = dlopen(NULL, RTLD_LAZY);
        }
        function = handle ? (GLFMProc)dlsym(handle, functionName) : NULL;
    }
    return function;
}

bool glfmHasVirtualKeyboard(const GLFMDisplay *display) {
    (void)display;
    return true;
}

void glfmSetKeyboardVisible(GLFMDisplay *display, bool visible) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    if (glfm__setKeyboardVisible(platformData, visible)) {
        glfm__updateUserInterfaceChrome(platformData);
    }
}

bool glfmIsKeyboardVisible(const GLFMDisplay *display) {
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    return platformData->keyboardVisible;
}

bool glfmIsSensorAvailable(const GLFMDisplay *display, GLFMSensor sensor) {
    (void)display;
    return glfm__getDeviceSensor(sensor) != NULL;
}

bool glfmIsHapticFeedbackSupported(const GLFMDisplay *display) {
    /*
    Vibrator vibrator = (Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
    return vibrator ? vibrator.hasVibrator() : false;
    */
    if (!display) {
        return false;
    }
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    JNIEnv *jni = platformData->jniEnv;
    if ((*jni)->ExceptionCheck(jni)) {
        return false;
    }
    jobject vibratorService = glfm__getSystemService(platformData, "VIBRATOR_SERVICE");
    if (!vibratorService) {
        return false;
    }
    jboolean result = glfm__callJavaMethod(jni, vibratorService, "hasVibrator", "()Z", Boolean);
    (*jni)->DeleteLocalRef(jni, vibratorService);
    if (glfm__wasJavaExceptionThrown(jni)) {
        return false;
    }
    return result;
}

void glfmPerformHapticFeedback(GLFMDisplay *display, GLFMHapticFeedbackStyle style) {
    // decorView.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, flags);
    static const jint HapticFeedbackConstants_CONTEXT_CLICK = 6; // Light, API 23
    static const jint HapticFeedbackConstants_VIRTUAL_KEY = 1; // Medium
    static const jint HapticFeedbackConstants_LONG_PRESS = 0; // Heavy
    static const jint HapticFeedbackConstants_REJECT = 17; // Heavy, API 30
    static const jint HapticFeedbackConstants_FLAG_IGNORE_VIEW_SETTING = 0x01;
    static const jint HapticFeedbackConstants_FLAG_IGNORE_GLOBAL_SETTING = 0x02;

    if (!display) {
        return;
    }
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    JNIEnv *jni = platformData->jniEnv;
    if ((*jni)->ExceptionCheck(jni)) {
        return;
    }
    jobject decorView = glfm__getDecorView(jni, platformData);
    if (!decorView) {
        return;
    }

    const int SDK_INT = platformData->activity->sdkVersion;
    jint defaultFeedbackConstant = HapticFeedbackConstants_LONG_PRESS;
    jint feedbackConstant;
    jint feedbackFlags = (HapticFeedbackConstants_FLAG_IGNORE_VIEW_SETTING |
                          HapticFeedbackConstants_FLAG_IGNORE_GLOBAL_SETTING);
    switch (style) {
        case GLFMHapticFeedbackLight: default:
            if (SDK_INT < 23) {
                feedbackConstant = HapticFeedbackConstants_VIRTUAL_KEY;
            } else {
                feedbackConstant = HapticFeedbackConstants_CONTEXT_CLICK;
            }
            break;
        case GLFMHapticFeedbackMedium:
            feedbackConstant = HapticFeedbackConstants_VIRTUAL_KEY;
            break;
        case GLFMHapticFeedbackHeavy:
            if (SDK_INT < 30) {
                feedbackConstant = HapticFeedbackConstants_LONG_PRESS;
            } else {
                feedbackConstant = HapticFeedbackConstants_REJECT;
            }
            break;
    }

    bool performed = glfm__callJavaMethodWithArgs(jni, decorView, "performHapticFeedback", "(II)Z", Boolean,
                                                  feedbackConstant, feedbackFlags);
    if (!performed) {
        // Some devices (Samsung S8) don't support all constants
        glfm__callJavaMethodWithArgs(jni, decorView, "performHapticFeedback", "(II)Z", Boolean, defaultFeedbackConstant,
                                     feedbackFlags);
    }
    (*jni)->DeleteLocalRef(jni, decorView);
}

bool glfmHasClipboardText(const GLFMDisplay *display) {
    if (!display || !display->platformData) {
        return false;
    }
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    JNIEnv *jni = platformData->jniEnv;

    // ClipboardManager clipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);
    jobject clipboardManager = glfm__getSystemService(platformData, "CLIPBOARD_SERVICE");
    if (!clipboardManager) {
        return false;
    }

    // Invoke clipboardManager.getPrimaryClipDescription()
    jobject primaryClipDescription = glfm__callJavaMethod(jni, clipboardManager, "getPrimaryClipDescription",
                                                   "()Landroid/content/ClipDescription;", Object);
    (*jni)->DeleteLocalRef(jni, clipboardManager);
    if (glfm__wasJavaExceptionThrown(jni) || !primaryClipDescription) {
        return false;
    }

    // Invoke primaryClipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)
    jclass class = (*jni)->GetObjectClass(jni, primaryClipDescription);
    jobject mimeType = glfm__getJavaStaticField(jni, class, "MIMETYPE_TEXT_PLAIN", "Ljava/lang/String;", Object);
    (*jni)->DeleteLocalRef(jni, class);
    if (glfm__wasJavaExceptionThrown(jni) || !mimeType) {
        return false;
    }
    jboolean hasText = glfm__callJavaMethodWithArgs(jni, primaryClipDescription, "hasMimeType", "(Ljava/lang/String;)Z",
                                                    Boolean, mimeType);

    (*jni)->DeleteLocalRef(jni, primaryClipDescription);
    if (glfm__wasJavaExceptionThrown(jni)) {
        return false;
    }
    return hasText;
}

void glfmRequestClipboardText(GLFMDisplay *display, GLFMClipboardTextFunc clipboardTextFunc) {
    if (!clipboardTextFunc) {
        return;
    }

    // First check glfmHasClipboardText(), to prevent a toast from being show if there is something
    // other than text in the clipboard
    if (!display || !display->platformData || !glfmHasClipboardText(display)) {
        clipboardTextFunc(display, NULL);
        return;
    }
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    JNIEnv *jni = platformData->jniEnv;

    // ClipboardManager clipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);
    jobject clipboardManager = glfm__getSystemService(platformData, "CLIPBOARD_SERVICE");
    if (!clipboardManager) {
        clipboardTextFunc(display, NULL);
        return;
    }

    // Invoke clipboardManager.getPrimaryClip()?.getItemAt(0)?.getText()?.toString()
    // Note, there appears no reason to do this asynchronously.
    jobject clipData = glfm__callJavaMethod(jni, clipboardManager, "getPrimaryClip", "()Landroid/content/ClipData;",
                                            Object);
    (*jni)->DeleteLocalRef(jni, clipboardManager);
    if (glfm__wasJavaExceptionThrown(jni) || !clipData) {
        clipboardTextFunc(display, NULL);
        return;
    }
    jobject clipDataItem = glfm__callJavaMethodWithArgs(jni, clipData, "getItemAt",
                                                        "(I)Landroid/content/ClipData$Item;", Object, 0);
    (*jni)->DeleteLocalRef(jni, clipData);
    if (glfm__wasJavaExceptionThrown(jni) || !clipDataItem) {
        clipboardTextFunc(display, NULL);
        return;
    }
    jobject clipDataItemText = glfm__callJavaMethod(jni, clipDataItem, "getText", "()Ljava/lang/CharSequence;", Object);
    (*jni)->DeleteLocalRef(jni, clipDataItem);
    if (glfm__wasJavaExceptionThrown(jni) || !clipDataItemText) {
        clipboardTextFunc(display, NULL);
        return;
    }
    jstring javaString = glfm__callJavaMethod(jni, clipDataItemText, "toString", "()Ljava/lang/String;", Object);
    (*jni)->DeleteLocalRef(jni, clipDataItemText);
    if (glfm__wasJavaExceptionThrown(jni) || !javaString) {
        clipboardTextFunc(display, NULL);
        return;
    }

    // Convert Java string to C string
    const char *cString = (*jni)->GetStringUTFChars(jni, javaString, NULL);
    if (glfm__wasJavaExceptionThrown(jni) || !cString) {
        clipboardTextFunc(display, NULL);
        return;
    }

    // Call
    clipboardTextFunc(display, cString);

    // Cleanup
    (*jni)->ReleaseStringUTFChars(jni, javaString, cString);
    (*jni)->DeleteLocalRef(jni, javaString);
}

bool glfmSetClipboardText(GLFMDisplay *display, const char *string) {
    if (!string || !display || !display->platformData) {
        return false;
    }
    GLFMPlatformData *platformData = (GLFMPlatformData *)display->platformData;
    JNIEnv *jni = platformData->jniEnv;

    // Convert C string to java String
    jstring javaString = (*jni)->NewStringUTF(jni, string);
    if (glfm__wasJavaExceptionThrown(jni) || !javaString) {
        return false;
    }

    // Create ClipData
    // ClipData clipData = ClipData.newPlainText("simple text", javaString);
    jclass clipDataClass = (*jni)->FindClass(jni, "android/content/ClipData");
    if (glfm__wasJavaExceptionThrown(jni) || !clipDataClass) {
        (*jni)->DeleteLocalRef(jni, javaString);
        return false;
    }
    jstring label = (*jni)->NewStringUTF(jni, "simple text");
    if (glfm__wasJavaExceptionThrown(jni) || !label) {
        (*jni)->DeleteLocalRef(jni, clipDataClass);
        (*jni)->DeleteLocalRef(jni, javaString);
        return false;
    }
    jobject clipData = glfm__callJavaStaticMethodWithArgs(jni, clipDataClass, "newPlainText",
                                                          "(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Landroid/content/ClipData;",
                                                          Object, label, javaString);
    (*jni)->DeleteLocalRef(jni, clipDataClass);
    (*jni)->DeleteLocalRef(jni, javaString);
    if (glfm__wasJavaExceptionThrown(jni) || !clipData) {
        return false;
    }

    // Set the clipboard text
    // ClipboardManager clipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);
    // clipboardManager.setPrimaryClip(clipData);
    jobject clipboardManager = glfm__getSystemService(platformData, "CLIPBOARD_SERVICE");
    if (glfm__wasJavaExceptionThrown(jni) || !clipboardManager) {
        (*jni)->DeleteLocalRef(jni, clipData);
        return false;
    }
    glfm__callJavaMethodWithArgs(jni, clipboardManager, "setPrimaryClip",
                                 "(Landroid/content/ClipData;)V", Void, clipData);
    (*jni)->DeleteLocalRef(jni, clipData);
    (*jni)->DeleteLocalRef(jni, clipboardManager);

    return !glfm__wasJavaExceptionThrown(jni);
}

// MARK: - Platform-specific functions

bool glfmIsMetalSupported(const GLFMDisplay *display) {
    (void)display;
    return false;
}

ANativeActivity *glfmAndroidGetActivity(void) {
    if (!platformDataGlobal) {
        return NULL;
    }
    return platformDataGlobal->activity;
}

void *glfmGetAndroidActivity(const GLFMDisplay *display) {
    if (!display || !display->platformData) {
        return NULL;
    }
    GLFMPlatformData *platformData = display->platformData;
    return platformData->activity;
}

#endif // __ANDROID__

```

`src/glfm_apple.m`:

```m
// GLFM
// https://github.com/brackeen/glfm

#if defined(__APPLE__)

#include "glfm.h"
#include "glfm_internal.h"

#if !defined(GLFM_INCLUDE_METAL)
#  define GLFM_INCLUDE_METAL 1
#endif

#if TARGET_OS_IOS || TARGET_OS_TV
#  import <UIKit/UIKit.h>
#elif TARGET_OS_OSX
#  import <AppKit/AppKit.h>
#  import <Carbon/Carbon.h> // For kVK key codes in HIToolbox/Events.h
#  import <IOKit/hidsystem/IOLLEvent.h> // For NX_DEVICE modifier keys
#  define UIView NSView
#  define UIViewAutoresizingFlexibleWidth NSViewWidthSizable
#  define UIViewAutoresizingFlexibleHeight NSViewHeightSizable
#  define UIViewController NSViewController
#  define UIWindow NSWindow
#endif
#if TARGET_OS_IOS
#  import <CoreHaptics/CoreHaptics.h>
#  import <CoreMotion/CoreMotion.h>
#endif
#if GLFM_INCLUDE_METAL
#  import <MetalKit/MetalKit.h>
#endif

#include <dlfcn.h>

#ifdef NDEBUG
#  define GLFM_LOG(...) do { } while (0)
#else
#  define GLFM_LOG(...) NSLog(@__VA_ARGS__)
#endif

#if __has_feature(objc_arc)
#  define GLFM_AUTORELEASE(value) value
#  define GLFM_RELEASE(value) ((void)0)
#  define GLFM_WEAK __weak
#else
#  define GLFM_AUTORELEASE(value) [value autorelease]
#  define GLFM_RELEASE(value) [value release]
#  define GLFM_WEAK __unsafe_unretained
#endif

#if TARGET_OS_IOS || TARGET_OS_TV
#  define GLFM_MAX_SIMULTANEOUS_TOUCHES 10
#  ifdef NDEBUG
#    define GLFM_CHECK_GL_ERROR() ((void)0)
#  else
#    define GLFM_CHECK_GL_ERROR() do { GLenum error = glGetError(); if (error != GL_NO_ERROR) \
       GLFM_LOG("OpenGL error 0x%04x at glfm_apple.m:%i", error, __LINE__); } while(0)
#  endif
#endif

static bool glfm__isCGFloatEqual(CGFloat value1, CGFloat value2) {
#if CGFLOAT_IS_DOUBLE
    return fabs(value1 - value2) <= DBL_EPSILON;
#else
    return fabsf(value1 - value2) <= FLT_EPSILON;
#endif
}

static void glfm__getDefaultDisplaySize(const GLFMDisplay *display, double *width, double *height, double *scale);
static void glfm__getDrawableSize(double displayWidth, double displayHeight, double displayScale,
                                  int *width, int *height);

// MARK: - GLFMView protocol

@protocol GLFMView

@property(nonatomic, readonly) GLFMRenderingAPI renderingAPI;
@property(nonatomic, readonly) int drawableWidth;
@property(nonatomic, readonly) int drawableHeight;
@property(nonatomic, readonly) BOOL surfaceCreatedNotified;
@property(nonatomic, assign) BOOL animating;
@property(nonatomic, copy, nullable) void (^preRenderCallback)(void);

- (void)draw;
- (void)swapBuffers;
- (void)requestRefresh;

@end

// MARK: GLFMNullView

@interface GLFMNullView : UIView <GLFMView>

@end

@implementation GLFMNullView

@synthesize preRenderCallback = _preRenderCallback;

- (GLFMRenderingAPI)renderingAPI {
    return GLFMRenderingAPIOpenGLES2;
}

- (int)drawableWidth {
    return 0;
}

- (int)drawableHeight {
    return 0;
}

- (BOOL)animating {
    return NO;
}

- (BOOL)surfaceCreatedNotified {
    return NO;
}

- (void)setAnimating:(BOOL)animating {
    (void)animating;
}

- (void)draw {
    if (_preRenderCallback) {
        _preRenderCallback();
    }
}

- (void)swapBuffers {

}

- (void)requestRefresh {

}

- (void)dealloc {
    GLFM_RELEASE(_preRenderCallback);
#if !__has_feature(objc_arc)
    [super dealloc];
#endif
}

@end

#if GLFM_INCLUDE_METAL

// MARK: - GLFMMetalView

@interface GLFMMetalView : MTKView <GLFMView, MTKViewDelegate>

@property(nonatomic, assign) GLFMDisplay *glfmDisplay;
@property(nonatomic, assign) int drawableWidth;
@property(nonatomic, assign) int drawableHeight;
@property(nonatomic, assign) BOOL surfaceCreatedNotified;
@property(nonatomic, assign) BOOL refreshRequested;
@property(nonatomic, assign) BOOL isDrawing;

@end

#if TARGET_OS_OSX

@interface GLFMMetalView () <NSTextInputClient>

@end

#endif // TARGET_OS_OSX

@implementation GLFMMetalView

@synthesize drawableWidth, drawableHeight, surfaceCreatedNotified, refreshRequested, isDrawing;
@synthesize glfmDisplay = _glfmDisplay, preRenderCallback = _preRenderCallback;
@dynamic renderingAPI, animating;

- (instancetype)initWithFrame:(CGRect)frame contentScaleFactor:(CGFloat)contentScaleFactor
                       device:(id<MTLDevice>)device glfmDisplay:(GLFMDisplay *)glfmDisplay {
    if ((self = [super initWithFrame:frame device:device])) {
#if TARGET_OS_IOS || TARGET_OS_TV
        self.contentScaleFactor = contentScaleFactor;
#else
        self.layer.contentsScale = contentScaleFactor;
#endif
        self.delegate = self;
        self.glfmDisplay = glfmDisplay;
        self.drawableWidth = (int)self.drawableSize.width;
        self.drawableHeight = (int)self.drawableSize.height;
        [self requestRefresh];

        switch (glfmDisplay->colorFormat) {
            case GLFMColorFormatRGB565:
                if (@available(iOS 8, tvOS 8, macOS 11, *)) {
                    self.colorPixelFormat = MTLPixelFormatB5G6R5Unorm;
                } else {
                    self.colorPixelFormat = MTLPixelFormatBGRA8Unorm;
                }
                break;
            case GLFMColorFormatRGBA8888:
            default:
                self.colorPixelFormat = MTLPixelFormatBGRA8Unorm;
                break;
        }

        if (glfmDisplay->depthFormat == GLFMDepthFormatNone && glfmDisplay->stencilFormat == GLFMStencilFormatNone) {
            self.depthStencilPixelFormat = MTLPixelFormatInvalid;
        } else if (glfmDisplay->depthFormat == GLFMDepthFormatNone) {
            self.depthStencilPixelFormat = MTLPixelFormatStencil8;
        } else if (glfmDisplay->stencilFormat == GLFMStencilFormatNone) {
            if (@available(iOS 13, tvOS 13, macOS 10.12, *)) {
                if (glfmDisplay->depthFormat == GLFMDepthFormat16) {
                    self.depthStencilPixelFormat = MTLPixelFormatDepth16Unorm;
                } else {
                    self.depthStencilPixelFormat = MTLPixelFormatDepth32Float;
                }
            } else {
                self.depthStencilPixelFormat = MTLPixelFormatDepth32Float;
            }
        } else {
#if TARGET_OS_OSX
            if (@available(macOS 10.11, *)) {
                if (device.depth24Stencil8PixelFormatSupported &&
                    (glfmDisplay->depthFormat == GLFMDepthFormat16 || glfmDisplay->depthFormat == GLFMDepthFormat24)) {
                    self.depthStencilPixelFormat = MTLPixelFormatDepth24Unorm_Stencil8;
                } else {
                    self.depthStencilPixelFormat = MTLPixelFormatDepth32Float_Stencil8;
                }
            } else {
                self.depthStencilPixelFormat = MTLPixelFormatDepth32Float_Stencil8;
            }
#else
            self.depthStencilPixelFormat = MTLPixelFormatDepth32Float_Stencil8;
#endif
        }

        self.sampleCount = (glfmDisplay->multisample == GLFMMultisampleNone) ? 1 : 4;
    }
    return self;
}

- (GLFMRenderingAPI)renderingAPI {
    return GLFMRenderingAPIMetal;
}

#if TARGET_OS_OSX

- (void)viewDidChangeBackingProperties {
    [super viewDidChangeBackingProperties];
    if (self.window) {
        self.layer.contentsScale = self.window.backingScaleFactor;
    }
}

- (void)setFrameSize:(NSSize)newSize {
    // For live resizing
    [super setFrameSize:newSize];
    if (self.surfaceCreatedNotified) {
        [self requestRefresh];
        if (self.isLiveResizing) {
            [self draw];
        }
    }
}

- (void)viewWillStartLiveResize {
    self.layerContentsPlacement = NSViewLayerContentsPlacementTopLeft;
    [super viewWillStartLiveResize];
}

- (void)viewDidEndLiveResize {
    self.layerContentsPlacement = NSViewLayerContentsPlacementScaleAxesIndependently;
    [super viewDidEndLiveResize];
}

- (BOOL)isLiveResizing {
    return self.layerContentsPlacement == NSViewLayerContentsPlacementTopLeft;
}

- (BOOL)acceptsFirstResponder {
    return YES;
}

#endif // TARGET_OS_OSX

- (void)draw {
    if (!self.isDrawing) {
        [super draw];
    }
}

- (BOOL)animating {
    return !self.paused;
}

- (void)setAnimating:(BOOL)animating {
    if (self.animating != animating) {
        self.paused = !animating;
        [self requestRefresh];
    }
}

- (void)mtkView:(MTKView *)view drawableSizeWillChange:(CGSize)size {

}

- (void)drawInMTKView:(MTKView *)view {
    if (self.isDrawing) {
        return;
    }
    self.isDrawing = YES;
    int newDrawableWidth = (int)self.drawableSize.width;
    int newDrawableHeight = (int)self.drawableSize.height;
    if (!self.surfaceCreatedNotified) {
        self.surfaceCreatedNotified = YES;
        [self requestRefresh];
        self.drawableWidth = newDrawableWidth;
        self.drawableHeight = newDrawableHeight;
        if (self.glfmDisplay->surfaceCreatedFunc) {
            self.glfmDisplay->surfaceCreatedFunc(self.glfmDisplay, self.drawableWidth, self.drawableHeight);
        }
    } else if (self.drawableWidth != newDrawableWidth || self.drawableHeight != newDrawableHeight) {
        [self requestRefresh];
        self.drawableWidth = newDrawableWidth;
        self.drawableHeight = newDrawableHeight;
        if (self.glfmDisplay->surfaceResizedFunc) {
            self.glfmDisplay->surfaceResizedFunc(self.glfmDisplay, self.drawableWidth, self.drawableHeight);
        }
    }

    if (_preRenderCallback) {
        _preRenderCallback();
    }

    if (self.refreshRequested) {
        self.refreshRequested = NO;
        if (self.glfmDisplay->surfaceRefreshFunc) {
            self.glfmDisplay->surfaceRefreshFunc(self.glfmDisplay);
        }
    }

    if (self.glfmDisplay->renderFunc) {
        self.glfmDisplay->renderFunc(self.glfmDisplay);
    }

    self.isDrawing = NO;
}

- (void)swapBuffers {
    // Do nothing
}

- (void)requestRefresh {
    self.refreshRequested = YES;
}

#if TARGET_OS_IOS || TARGET_OS_TV

- (void)layoutSubviews {
    // First render as soon as safeAreaInsets are set
    if (!self.surfaceCreatedNotified) {
        [self requestRefresh];
        [self draw];
    }
}

#endif

- (void)dealloc {
    GLFM_RELEASE(_preRenderCallback);
#if !__has_feature(objc_arc)
    [super dealloc];
#endif
}

#if TARGET_OS_OSX

// MARK: NSTextInputClient
// NOTE: This code is the same in GLFMOpenGLView

- (void)insertText:(id)text replacementRange:(NSRange)replacementRange {
    // Input from the Character Palette
    if (self.glfmDisplay->charFunc) {
        NSString *string;
        if ([(NSObject *)text isKindOfClass:[NSAttributedString class]]) {
            string = ((NSAttributedString *)text).string;
        } else {
            string = text;
        }
        self.glfmDisplay->charFunc(self.glfmDisplay, string.UTF8String, 0);
    }
}

- (void)doCommandBySelector:(SEL)selector {

}

- (void)setMarkedText:(id)string selectedRange:(NSRange)selectedRange replacementRange:(NSRange)replacementRange {

}

- (void)unmarkText {

}

- (NSRange)selectedRange {
    return NSMakeRange(0, 0);
}

- (NSRange)markedRange {
    return NSMakeRange(NSNotFound, 0);
}

- (BOOL)hasMarkedText {
    return NO;
}

- (NSAttributedString *)attributedSubstringForProposedRange:(NSRange)range actualRange:(NSRangePointer)actualRange {
    return nil;
}

- (NSArray<NSAttributedStringKey> *)validAttributesForMarkedText {
    return @[];
}

- (NSRect)firstRectForCharacterRange:(NSRange)range actualRange:(NSRangePointer)actualRange {
    // This is called for positioning the Character Palette, but seems to be ignored.
    NSRect frame = self.window.frame;
    return CGRectMake(NSMidX(frame), NSMidY(frame), 0, 0);
}

- (NSUInteger)characterIndexForPoint:(NSPoint)point {
    return 0;
}

#endif // TARGET_OS_OSX

@end

#endif // GLFM_INCLUDE_METAL

#if TARGET_OS_IOS || TARGET_OS_TV

// MARK: - GLFMOpenGLESView (iOS, tvOS)

@interface GLFMOpenGLESView : UIView <GLFMView>

@property(nonatomic, assign) GLFMDisplay *glfmDisplay;
@property(nonatomic, assign) GLFMRenderingAPI renderingAPI;
@property(nonatomic, strong) CADisplayLink *displayLink;
@property(nonatomic, strong) EAGLContext *context;
@property(nonatomic, strong) NSString *colorFormat;
@property(nonatomic, assign) BOOL preserveBackbuffer;
@property(nonatomic, assign) NSUInteger depthBits;
@property(nonatomic, assign) NSUInteger stencilBits;
@property(nonatomic, assign) BOOL multisampling;
@property(nonatomic, assign) BOOL surfaceCreatedNotified;
@property(nonatomic, assign) BOOL surfaceSizeChanged;
@property(nonatomic, assign) BOOL refreshRequested;
@property(nonatomic, assign) BOOL isDrawing;

@end

@implementation GLFMOpenGLESView {
    GLint _drawableWidth;
    GLint _drawableHeight;
    GLuint _defaultFramebuffer;
    GLuint _colorRenderbuffer;
    GLuint _attachmentRenderbuffer;
    GLuint _msaaFramebuffer;
    GLuint _msaaRenderbuffer;
}

@synthesize renderingAPI, displayLink, context, colorFormat, preserveBackbuffer;
@synthesize depthBits, stencilBits, multisampling;
@synthesize surfaceCreatedNotified, surfaceSizeChanged, refreshRequested, isDrawing;
@synthesize glfmDisplay = _glfmDisplay, preRenderCallback = _preRenderCallback;
@dynamic drawableWidth, drawableHeight, animating;

+ (Class)layerClass {
    return [CAEAGLLayer class];
}

- (instancetype)initWithFrame:(CGRect)frame contentScaleFactor:(CGFloat)contentScaleFactor
                  glfmDisplay:(GLFMDisplay *)glfmDisplay {
    if ((self = [super initWithFrame:frame])) {

        self.contentScaleFactor = contentScaleFactor;
        self.glfmDisplay = glfmDisplay;
        [self requestRefresh];

        if (glfmDisplay->preferredAPI >= GLFMRenderingAPIOpenGLES3) {
            self.context = GLFM_AUTORELEASE([[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3]);
            self.renderingAPI = GLFMRenderingAPIOpenGLES3;
        }
        if (!self.context) {
            self.context = GLFM_AUTORELEASE([[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]);
            self.renderingAPI = GLFMRenderingAPIOpenGLES2;
        }

        if (!self.context) {
            GLFM_LOG("Failed to create ES context");
            glfm__reportSurfaceError(glfmDisplay, "Failed to create ES context");
            GLFM_RELEASE(self);
            return nil;
        }

        switch (glfmDisplay->colorFormat) {
            case GLFMColorFormatRGB565:
                self.colorFormat = kEAGLColorFormatRGB565;
                break;
            case GLFMColorFormatRGBA8888:
            default:
                self.colorFormat = kEAGLColorFormatRGBA8;
                break;
        }

        switch (glfmDisplay->depthFormat) {
            case GLFMDepthFormatNone:
            default:
                self.depthBits = 0;
                break;
            case GLFMDepthFormat16:
                self.depthBits = 16;
                break;
            case GLFMDepthFormat24: case GLFMDepthFormat32:
                self.depthBits = 24;
                break;
        }

        switch (glfmDisplay->stencilFormat) {
            case GLFMStencilFormatNone:
            default:
                self.stencilBits = 0;
                break;
            case GLFMStencilFormat8:
                self.stencilBits = 8;
                break;
        }

        self.multisampling = glfmDisplay->multisample != GLFMMultisampleNone;

        [self createDrawable];
    }
    return self;
}

- (void)dealloc {
    self.animating = NO;
    [self deleteDrawable];
    if ([EAGLContext currentContext] == self.context) {
        [EAGLContext setCurrentContext:nil];
    }
    self.context = nil;
    self.colorFormat = nil;
    GLFM_RELEASE(_preRenderCallback);
#if !__has_feature(objc_arc)
    [super dealloc];
#endif
}

- (int)drawableWidth {
    return (int)_drawableWidth;
}

- (int)drawableHeight {
    return (int)_drawableHeight;
}

- (BOOL)animating {
    return (self.displayLink != nil);
}

- (void)setAnimating:(BOOL)animating {
    if (self.animating != animating) {
        [self requestRefresh];
        if (!animating) {
            [self.displayLink invalidate];
            self.displayLink = nil;
        } else {
            self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(render:)];
            [self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
        }
    }
}

- (void)createDrawable {
    if (_defaultFramebuffer != 0 || !self.context) {
        return;
    }

    if (!self.colorFormat) {
        self.colorFormat = kEAGLColorFormatRGBA8;
    }

    [EAGLContext setCurrentContext:self.context];

    CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer;
    eaglLayer.opaque = YES;
    eaglLayer.drawableProperties = @{
        kEAGLDrawablePropertyRetainedBacking : @(self.preserveBackbuffer),
        kEAGLDrawablePropertyColorFormat : self.colorFormat
    };

    glGenFramebuffers(1, &_defaultFramebuffer);
    glGenRenderbuffers(1, &_colorRenderbuffer);
    glBindFramebuffer(GL_FRAMEBUFFER, _defaultFramebuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);

    // iPhone 6 Display Zoom hack - use a modified bounds so that the renderbufferStorage method
    // creates the correct size renderbuffer.
    CGRect oldBounds = eaglLayer.bounds;
    if (glfm__isCGFloatEqual(eaglLayer.contentsScale, (CGFloat)2.343750)) {
        if (glfm__isCGFloatEqual(eaglLayer.bounds.size.width, (CGFloat)320.0) &&
            glfm__isCGFloatEqual(eaglLayer.bounds.size.height, (CGFloat)568.0)) {
            eaglLayer.bounds = CGRectMake(eaglLayer.bounds.origin.x, eaglLayer.bounds.origin.y,
                                          eaglLayer.bounds.size.width, 1334 / eaglLayer.contentsScale);
        } else if (glfm__isCGFloatEqual(eaglLayer.bounds.size.width, (CGFloat)568.0) &&
                   glfm__isCGFloatEqual(eaglLayer.bounds.size.height, (CGFloat)320.0)) {
            eaglLayer.bounds = CGRectMake(eaglLayer.bounds.origin.x, eaglLayer.bounds.origin.y,
                                          1334 / eaglLayer.contentsScale, eaglLayer.bounds.size.height);
        }
    }

    if (![self.context renderbufferStorage:GL_RENDERBUFFER fromDrawable:eaglLayer]) {
        GLFM_LOG("Error: Call to renderbufferStorage failed");
    }

    eaglLayer.bounds = oldBounds;

    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderbuffer);

    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &_drawableWidth);
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &_drawableHeight);

    if (self.multisampling) {
        glGenFramebuffers(1, &_msaaFramebuffer);
        glBindFramebuffer(GL_FRAMEBUFFER, _msaaFramebuffer);

        glGenRenderbuffers(1, &_msaaRenderbuffer);
        glBindRenderbuffer(GL_RENDERBUFFER, _msaaRenderbuffer);

        GLenum internalFormat = GL_RGBA8_OES;
        if ([kEAGLColorFormatRGB565 isEqualToString:self.colorFormat]) {
            internalFormat = GL_RGB565;
        }

        glRenderbufferStorageMultisampleAPPLE(GL_RENDERBUFFER, 4, internalFormat, _drawableWidth, _drawableHeight);

        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _msaaRenderbuffer);

        GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
        if (status != GL_FRAMEBUFFER_COMPLETE) {
            GLFM_LOG("Error: Couldn't create multisample framebuffer: 0x%04x", status);
        }
    }

    if (self.depthBits > 0 || self.stencilBits > 0) {
        glGenRenderbuffers(1, &_attachmentRenderbuffer);
        glBindRenderbuffer(GL_RENDERBUFFER, _attachmentRenderbuffer);

        GLenum internalFormat;
        if (self.depthBits > 0 && self.stencilBits > 0) {
            internalFormat = GL_DEPTH24_STENCIL8_OES;
        } else if (self.depthBits >= 24) {
            internalFormat = GL_DEPTH_COMPONENT24_OES;
        } else if (self.depthBits > 0) {
            internalFormat = GL_DEPTH_COMPONENT16;
        } else {
            internalFormat = GL_STENCIL_INDEX8;
        }

        if (self.multisampling) {
            glRenderbufferStorageMultisampleAPPLE(GL_RENDERBUFFER, 4, internalFormat, _drawableWidth, _drawableHeight);
        } else {
            glRenderbufferStorage(GL_RENDERBUFFER, internalFormat, _drawableWidth, _drawableHeight);
        }

        if (self.depthBits > 0) {
            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _attachmentRenderbuffer);
        }
        if (self.stencilBits > 0) {
            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, _attachmentRenderbuffer);
        }
    }

    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE) {
        GLFM_LOG("Error: Framebuffer incomplete: 0x%04x", status);
    }

    GLFM_CHECK_GL_ERROR();
}

- (void)deleteDrawable {
    [EAGLContext setCurrentContext:self.context];
    if (_defaultFramebuffer) {
        glDeleteFramebuffers(1, &_defaultFramebuffer);
        _defaultFramebuffer = 0;
    }
    if (_colorRenderbuffer) {
        glDeleteRenderbuffers(1, &_colorRenderbuffer);
        _colorRenderbuffer = 0;
    }
    if (_attachmentRenderbuffer) {
        glDeleteRenderbuffers(1, &_attachmentRenderbuffer);
        _attachmentRenderbuffer = 0;
    }
    if (_msaaRenderbuffer) {
        glDeleteRenderbuffers(1, &_msaaRenderbuffer);
        _msaaRenderbuffer = 0;
    }
    if (_msaaFramebuffer) {
        glDeleteFramebuffers(1, &_msaaFramebuffer);
        _msaaFramebuffer = 0;
    }
}

- (void)prepareRender {
    [EAGLContext setCurrentContext:self.context];
    if (self.multisampling) {
        glBindFramebuffer(GL_FRAMEBUFFER, _msaaFramebuffer);
        glBindRenderbuffer(GL_RENDERBUFFER, _msaaRenderbuffer);
    } else {
        glBindFramebuffer(GL_FRAMEBUFFER, _defaultFramebuffer);
        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    }
    GLFM_CHECK_GL_ERROR();
}

- (void)swapBuffers {
    [EAGLContext setCurrentContext:self.context];
    if (self.multisampling) {
        glBindFramebuffer(GL_READ_FRAMEBUFFER_APPLE, _msaaFramebuffer);
        glBindFramebuffer(GL_DRAW_FRAMEBUFFER_APPLE, _defaultFramebuffer);
        glResolveMultisampleFramebufferAPPLE();
    }

    static bool checked_GL_EXT_discard_framebuffer = false;
    static bool has_GL_EXT_discard_framebuffer = false;
    if (!checked_GL_EXT_discard_framebuffer) {
        checked_GL_EXT_discard_framebuffer = true;
        const char *extensions = (const char *)glGetString(GL_EXTENSIONS);
        if (extensions) {
            has_GL_EXT_discard_framebuffer = strstr(extensions, "GL_EXT_discard_framebuffer") != NULL;
        }
    }
    if (has_GL_EXT_discard_framebuffer) {
        GLenum target = GL_FRAMEBUFFER;
        GLenum attachments[3];
        GLsizei numAttachments = 0;
        if (self.multisampling) {
            target = GL_READ_FRAMEBUFFER_APPLE;
            attachments[numAttachments++] = GL_COLOR_ATTACHMENT0;
        }
        if (self.depthBits > 0) {
            attachments[numAttachments++] = GL_DEPTH_ATTACHMENT;
        }
        if (self.stencilBits > 0) {
            attachments[numAttachments++] = GL_STENCIL_ATTACHMENT;
        }
        if (numAttachments > 0) {
            if (self.multisampling) {
                glBindFramebuffer(GL_FRAMEBUFFER, _msaaFramebuffer);
            } else {
                glBindFramebuffer(GL_FRAMEBUFFER, _defaultFramebuffer);
            }
            glDiscardFramebufferEXT(target, numAttachments, attachments);
        }
    }

    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    [self.context presentRenderbuffer:GL_RENDERBUFFER];

    GLFM_CHECK_GL_ERROR();
}

- (void)render:(CADisplayLink *)displayLink {
    if (self.isDrawing) {
        return;
    }
    self.isDrawing = YES;

    [EAGLContext setCurrentContext:self.context];

    if (!self.surfaceCreatedNotified) {
        self.surfaceCreatedNotified = YES;
        [self requestRefresh];
        if (self.glfmDisplay->surfaceCreatedFunc) {
            self.glfmDisplay->surfaceCreatedFunc(self.glfmDisplay, self.drawableWidth, self.drawableHeight);
        }
    }

    if (self.surfaceSizeChanged) {
        self.surfaceSizeChanged = NO;
        [self requestRefresh];
        if (self.glfmDisplay->surfaceResizedFunc) {
            self.glfmDisplay->surfaceResizedFunc(self.glfmDisplay, self.drawableWidth, self.drawableHeight);
        }
    }

    if (_preRenderCallback) {
        _preRenderCallback();
    }

    if (self.refreshRequested) {
        self.refreshRequested = NO;
        if (self.glfmDisplay->surfaceRefreshFunc) {
            self.glfmDisplay->surfaceRefreshFunc(self.glfmDisplay);
        }
    }
    if (self.glfmDisplay->renderFunc) {
        [self prepareRender];
        self.glfmDisplay->renderFunc(self.glfmDisplay);
    }

    self.isDrawing = NO;
}

- (void)draw {
    if (self.displayLink && !self.isDrawing) {
        [self render:self.displayLink];
    }
}

- (void)requestRefresh {
    self.refreshRequested = YES;
}

- (void)layoutSubviews {
    int newDrawableWidth;
    int newDrawableHeight;
    glfm__getDrawableSize((double)self.bounds.size.width, (double)self.bounds.size.height,
                          (double)self.contentScaleFactor, &newDrawableWidth, &newDrawableHeight);

    if (self.drawableWidth != newDrawableWidth || self.drawableHeight != newDrawableHeight) {
        [self deleteDrawable];
        [self createDrawable];
        self.surfaceSizeChanged = self.surfaceCreatedNotified;
    }

    // First render as soon as safeAreaInsets are set
    if (!self.surfaceCreatedNotified) {
        [self requestRefresh];
        [self draw];
    }
}

@end

#endif // TARGET_OS_IOS || TARGET_OS_TV

#if TARGET_OS_OSX

// MARK: - GLFMOpenGLView (macOS)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

@interface GLFMOpenGLView : NSOpenGLView <GLFMView, NSTextInputClient>

@property(nonatomic, assign) GLFMDisplay *glfmDisplay;
@property(nonatomic, assign) int drawableWidth;
@property(nonatomic, assign) int drawableHeight;
@property(nonatomic, assign) BOOL surfaceCreatedNotified;
@property(nonatomic, assign) BOOL refreshRequested;
@property(nonatomic, assign) BOOL isDrawing;

@end

@implementation GLFMOpenGLView {
    CVDisplayLinkRef _displayLink;
    dispatch_source_t _displaySource;
}

@synthesize glfmDisplay = _glfmDisplay, preRenderCallback = _preRenderCallback;
@synthesize drawableWidth, drawableHeight;
@synthesize surfaceCreatedNotified, refreshRequested, isDrawing;
@dynamic renderingAPI, animating;

- (instancetype)initWithFrame:(CGRect)frame glfmDisplay:(GLFMDisplay *)glfmDisplay {

    uint32_t colorBits = (glfmDisplay->colorFormat == GLFMColorFormatRGB565) ? 16 : 32;
    uint32_t alphaBits = (glfmDisplay->colorFormat == GLFMColorFormatRGB565) ? 0 : 8;
    uint32_t stencilBits = (glfmDisplay->stencilFormat == GLFMStencilFormat8) ? 8 : 0;
    uint32_t sampleCount = (glfmDisplay->multisample == GLFMMultisample4X) ? 4 : 1;
    uint32_t depthBits;
    switch (glfmDisplay->depthFormat) {
        case GLFMDepthFormatNone:
        default:
            depthBits = 0;
            break;
        case GLFMDepthFormat16:
            depthBits = 16;
            break;
        case GLFMDepthFormat24: case GLFMDepthFormat32:
            depthBits = 24;
            break;
    }

    // Set up attributes and create pixel format
    NSOpenGLPixelFormatAttribute attributes[32];
    size_t index = 0;
    attributes[index++] = kCGLPFASupportsAutomaticGraphicsSwitching;
    attributes[index++] = NSOpenGLPFAAccelerated;
    attributes[index++] = NSOpenGLPFAAllowOfflineRenderers;
    attributes[index++] = NSOpenGLPFAClosestPolicy;
    attributes[index++] = NSOpenGLPFADoubleBuffer;

    if (glfmDisplay->swapBehavior == GLFMSwapBehaviorBufferPreserved) {
        attributes[index++] = NSOpenGLPFABackingStore;
    } else if (glfmDisplay->swapBehavior == GLFMSwapBehaviorBufferDestroyed) {
        attributes[index++] = kCGLPFABackingVolatile;
    }

    attributes[index++] = NSOpenGLPFAOpenGLProfile;
    attributes[index++] = NSOpenGLProfileVersion3_2Core;

    attributes[index++] = NSOpenGLPFAColorSize;
    attributes[index++] = colorBits;
    if (alphaBits > 0) {
        attributes[index++] = NSOpenGLPFAAlphaSize;
        attributes[index++] = alphaBits;
    }
    if (depthBits > 0) {
        attributes[index++] = NSOpenGLPFADepthSize;
        attributes[index++] = depthBits;
    }
    if (stencilBits > 0) {
        attributes[index++] = NSOpenGLPFAStencilSize;
        attributes[index++] = stencilBits;
    }
    if (sampleCount > 1) {
        attributes[index++] = NSOpenGLPFASampleBuffers;
        attributes[index++] = 1;
        attributes[index++] = NSOpenGLPFASamples;
        attributes[index++] = sampleCount;
    }
    attributes[index] = 0;
    assert(index < sizeof(attributes) / sizeof(attributes[0]));

    NSOpenGLPixelFormat *pixelFormat = GLFM_AUTORELEASE([[NSOpenGLPixelFormat alloc] initWithAttributes:attributes]);
    if (!pixelFormat) {
        GLFM_LOG("Failed to create GL pixel format");
        glfm__reportSurfaceError(glfmDisplay, "Failed to create GL pixel format");
        return nil;
    }

    // Initialize view
    self = [super initWithFrame:frame pixelFormat:pixelFormat];
    NSOpenGLContext *openGLContext = self.openGLContext;
    CGLContextObj cglContext = openGLContext.CGLContextObj;
    CGLPixelFormatObj cglPixelFormat = self.pixelFormat.CGLPixelFormatObj;
    if (!openGLContext || !cglContext || !cglPixelFormat) {
        GLFM_LOG("Failed to create GL context");
        glfm__reportSurfaceError(glfmDisplay, "Failed to create GL context");
        GLFM_RELEASE(self);
        return nil;
    }

    GLint swapInterval = 1;
    [openGLContext setValues:&swapInterval forParameter:NSOpenGLContextParameterSwapInterval];
    self.wantsBestResolutionOpenGLSurface = YES;
    self.layerContentsPlacement = NSViewLayerContentsPlacementTopLeft;
    self.glfmDisplay = glfmDisplay;

#if 0
    // Print attributes
    {
#define printAttribute(attr) do { \
    GLint virtualScreen = [self.openGLContext currentVirtualScreen]; \
    [pixelFormat getValues:&value forAttribute:(attr) forVirtualScreen:virtualScreen]; \
    printf("  " #attr ": %i\n", value); \
} while (0)

        GLint value;
        printAttribute(NSOpenGLPFAColorSize);
        printAttribute(NSOpenGLPFAAlphaSize);
        printAttribute(NSOpenGLPFADepthSize);
        printAttribute(NSOpenGLPFAStencilSize);
        printAttribute(NSOpenGLPFASampleBuffers);
        printAttribute(NSOpenGLPFASamples);
#undef printAttribute
    }
#endif

    // Initialize display link
    GLFM_WEAK __typeof(self) weakSelf = self;
    _displaySource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());
    dispatch_source_set_event_handler(_displaySource, ^{
        [weakSelf draw];
    });
    dispatch_resume(_displaySource);
    CVDisplayLinkCreateWithActiveCGDisplays(&_displayLink);
    CVDisplayLinkSetOutputHandler(_displayLink, ^CVReturn(CVDisplayLinkRef displayLink, const CVTimeStamp *now,
                                                          const CVTimeStamp *outputTime, CVOptionFlags flags,
                                                          CVOptionFlags *flagsOut) {
        (void)displayLink;
        (void)now;
        (void)outputTime;
        (void)flags;
        (void)flagsOut;
        __typeof(self) strongSelf = weakSelf;
        if (strongSelf) {
            dispatch_source_merge_data(strongSelf->_displaySource, 1);
        }
        return kCVReturnSuccess;
    });

    CVDisplayLinkSetCurrentCGDisplayFromOpenGLContext(_displayLink, cglContext, cglPixelFormat);
    return self;
}

- (BOOL)acceptsFirstResponder {
    return YES;
}

- (void)viewDidChangeBackingProperties {
    [self requestRefresh];
    [self update];
}

- (GLFMRenderingAPI)renderingAPI {
    // TODO: Return correct API
    return GLFMRenderingAPIOpenGLES2;
}

- (BOOL)animating {
    return CVDisplayLinkIsRunning(_displayLink) == TRUE;
}

- (void)setAnimating:(BOOL)animating {
    if (self.animating != animating) {
        if (animating) {
            CVDisplayLinkStart(_displayLink);
        } else {
            CVDisplayLinkStop(_displayLink);
        }
        [self requestRefresh];
    }
}

- (void)drawRect:(NSRect)dirtyRect {
    // For live resizing
    NSRect viewRectPixels = [self convertRectToBacking:self.bounds];
    int newDrawableWidth = (int)viewRectPixels.size.width;
    int newDrawableHeight = (int)viewRectPixels.size.height;
    if (self.surfaceCreatedNotified &&
        (self.drawableWidth != newDrawableWidth || self.drawableHeight != newDrawableHeight)) {
        [self requestRefresh];
        if (self.animating) {
            CVDisplayLinkStop(_displayLink);
            [self draw];
            CVDisplayLinkStart(_displayLink);
        } else {
            [self draw];
        }
    }
}

- (void)draw {
    if (self.isDrawing) {
        return;
    }
    self.isDrawing = YES;
    NSRect viewRectPixels = [self convertRectToBacking:self.bounds];
    int newDrawableWidth = (int)viewRectPixels.size.width;
    int newDrawableHeight = (int)viewRectPixels.size.height;

    assert([NSThread isMainThread]);

    [self.openGLContext makeCurrentContext];

    if (!self.surfaceCreatedNotified) {
        self.surfaceCreatedNotified = YES;
        [self requestRefresh];
        self.drawableWidth = newDrawableWidth;
        self.drawableHeight = newDrawableHeight;
        if (self.glfmDisplay->surfaceCreatedFunc) {
            self.glfmDisplay->surfaceCreatedFunc(self.glfmDisplay, self.drawableWidth, self.drawableHeight);
        }
    } else if (self.drawableWidth != newDrawableWidth || self.drawableHeight != newDrawableHeight) {
        self.drawableWidth = newDrawableWidth;
        self.drawableHeight = newDrawableHeight;
        [self requestRefresh];
        if (self.glfmDisplay->surfaceResizedFunc) {
            self.glfmDisplay->surfaceResizedFunc(self.glfmDisplay, self.drawableWidth, self.drawableHeight);
        }
    }

    if (_preRenderCallback) {
        _preRenderCallback();
    }

    if (self.refreshRequested) {
        self.refreshRequested = NO;
        if (self.glfmDisplay->surfaceRefreshFunc) {
            self.glfmDisplay->surfaceRefreshFunc(self.glfmDisplay);
        }
    }

    if (self.glfmDisplay->renderFunc) {
        self.glfmDisplay->renderFunc(self.glfmDisplay);
    }

    self.isDrawing = NO;
}

- (void)swapBuffers {
    [self.openGLContext flushBuffer];
}

- (void)requestRefresh {
    self.refreshRequested = YES;
}

- (void)dealloc {
    self.animating = NO;
    if ([NSOpenGLContext currentContext] == self.openGLContext) {
        [NSOpenGLContext clearCurrentContext];
    }
    dispatch_source_cancel(_displaySource);
    CVDisplayLinkRelease(_displayLink);
    GLFM_RELEASE(_preRenderCallback);
#if !__has_feature(objc_arc)
    dispatch_release(_displaySource);
    [super dealloc];
#endif
}

// MARK: NSTextInputClient
// NOTE: This code is the same in GLFMMetalView

- (void)insertText:(id)text replacementRange:(NSRange)replacementRange {
    // Input from the Character Palette
    if (self.glfmDisplay->charFunc) {
        NSString *string;
        if ([(NSObject *)text isKindOfClass:[NSAttributedString class]]) {
            string = ((NSAttributedString *)text).string;
        } else {
            string = text;
        }
        self.glfmDisplay->charFunc(self.glfmDisplay, string.UTF8String, 0);
    }
}

- (void)doCommandBySelector:(SEL)selector {

}

- (void)setMarkedText:(id)string selectedRange:(NSRange)selectedRange replacementRange:(NSRange)replacementRange {

}

- (void)unmarkText {

}

- (NSRange)selectedRange {
    return NSMakeRange(0, 0);
}

- (NSRange)markedRange {
    return NSMakeRange(NSNotFound, 0);
}

- (BOOL)hasMarkedText {
    return NO;
}

- (NSAttributedString *)attributedSubstringForProposedRange:(NSRange)range actualRange:(NSRangePointer)actualRange {
    return nil;
}

- (NSArray<NSAttributedStringKey> *)validAttributesForMarkedText {
    return @[];
}

- (NSRect)firstRectForCharacterRange:(NSRange)range actualRange:(NSRangePointer)actualRange {
    // This is called for positioning the Character Palette, but seems to be ignored.
    NSRect frame = self.window.frame;
    return CGRectMake(NSMidX(frame), NSMidY(frame), 0, 0);
}

- (NSUInteger)characterIndexForPoint:(NSPoint)point {
    return 0;
}

@end

#pragma clang diagnostic pop // "-Wdeprecated-declarations"

#endif // TARGET_OS_OSX

// MARK: - GLFMWindow interface

@interface GLFMWindow : UIWindow

@property(nonatomic, assign) BOOL active;

@end

// MARK: - GLFMViewController

@interface GLFMViewController : UIViewController

@property(nonatomic, assign) GLFMDisplay *glfmDisplay;
@property(nonatomic, assign) CGRect defaultFrame;
@property(nonatomic, assign) CGFloat defaultContentScale;
#if GLFM_INCLUDE_METAL
@property(nonatomic, strong) id<MTLDevice> metalDevice;
#endif
@end

#if TARGET_OS_IOS

@interface GLFMViewController () <UIKeyInput, UITextInputTraits, UIPointerInteractionDelegate>

@property(nonatomic, assign) BOOL keyboardRequested;
@property(nonatomic, strong) UIView *noSoftKeyboardView;
@property(nonatomic, strong) CMMotionManager *motionManager;
@property(nonatomic, assign) UIInterfaceOrientation orientation;
@property(nonatomic, assign) BOOL multipleTouchEnabled;
@property(nonatomic, assign) GLFMMouseCursor mouseCursor;

@end

#endif // TARGET_OS_IOS

#if TARGET_OS_OSX

@interface GLFMViewController ()

@property(nonatomic, assign) NSEdgeInsets insets;
@property(nonatomic, strong) NSCursor *transparentCursor;
@property(nonatomic, strong) NSCursor *currentCursor;
@property(nonatomic, assign) BOOL hideMouseCursorWhileTyping;
@property(nonatomic, assign) BOOL mouseInside;
@property(nonatomic, assign) BOOL fnModifier;
@property(nonatomic, assign) UInt32 deadKeyState;
@property(nonatomic, assign) TISInputSourceRef currentKeyboard;
@property(nonatomic, assign) const UCKeyboardLayout *keyboardLayout;
@property(nonatomic, unsafe_unretained) id keyEventMonitor;
@property(nonatomic, strong) NSTextInputContext *textInputContext;

@end

#endif // TARGET_OS_OSX

@implementation GLFMViewController {
#if TARGET_OS_IOS || TARGET_OS_TV
    const void *activeTouches[GLFM_MAX_SIMULTANEOUS_TOUCHES];
#endif
}

@synthesize glfmDisplay, defaultFrame, defaultContentScale;

#if GLFM_INCLUDE_METAL
@synthesize metalDevice = _metalDevice;
#endif
#if TARGET_OS_IOS
@synthesize keyboardRequested, noSoftKeyboardView, motionManager = _motionManager, orientation;
@synthesize multipleTouchEnabled, mouseCursor;
#endif
#if TARGET_OS_OSX
@synthesize insets;
@synthesize transparentCursor, currentCursor, hideMouseCursorWhileTyping, mouseInside;
@synthesize fnModifier, deadKeyState = _deadKeyState, currentKeyboard, keyboardLayout, keyEventMonitor, textInputContext;
#endif

- (id)initWithDefaultFrame:(CGRect)frame contentScale:(CGFloat)contentScale {
    if ((self = [super init])) {
        self.glfmDisplay = calloc(1, sizeof(GLFMDisplay));
        self.glfmDisplay->platformData = (__bridge void *)self;
        self.glfmDisplay->supportedOrientations = GLFMInterfaceOrientationAll;
        self.defaultFrame = frame;
        self.defaultContentScale = contentScale;

#if TARGET_OS_IOS
        self.noSoftKeyboardView = GLFM_AUTORELEASE([UIView new]);
        self.mouseCursor = GLFMMouseCursorDefault;
#endif

#if TARGET_OS_OSX
        // Use a transparent image for the hidden cursor
        NSImage *transparentImage = [NSImage imageWithSize:NSMakeSize(16, 16) flipped:NO
                                            drawingHandler:^BOOL(NSRect dstRect) {
            NSRectFillUsingOperation(dstRect, NSCompositingOperationClear);
            return YES;
        }];
        self.transparentCursor = GLFM_AUTORELEASE([[NSCursor alloc] initWithImage:transparentImage
                                                                          hotSpot:NSZeroPoint]);
        self.currentCursor = NSCursor.arrowCursor;
        self.hideMouseCursorWhileTyping = YES;

        // Keyboard
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardChanged:) name:NSTextInputContextKeyboardSelectionDidChangeNotification object:nil];
        [self setCurrentKeyboard];

        // Send key release events when the command key is down
        GLFM_WEAK __typeof(self) weakSelf = self;
        self.keyEventMonitor = [NSEvent addLocalMonitorForEventsMatchingMask:NSEventMaskKeyUp
                                                                     handler:^NSEvent *(NSEvent *event) {
            if (event.modifierFlags & NSEventModifierFlagCommand) {
                [weakSelf.glfmViewIfLoaded.window sendEvent:event];
            }
            return event;
        }];
#else
        [self clearTouches];
#endif
    }
    return self;
}

- (void)dealloc {
    if (self.glfmViewIfLoaded.surfaceCreatedNotified && self.glfmDisplay->surfaceDestroyedFunc) {
        self.glfmDisplay->surfaceDestroyedFunc(self.glfmDisplay);
    }
    free(self.glfmDisplay);
    self.glfmViewIfLoaded.preRenderCallback = nil;
#if TARGET_OS_IOS
    self.motionManager = nil;
    self.noSoftKeyboardView = nil;
#endif
#if TARGET_OS_OSX
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    self.currentCursor = nil;
    self.transparentCursor = nil;
    if (self.currentKeyboard) {
        CFRelease(self.currentKeyboard);
        self.currentKeyboard = NULL;
    }
    [NSEvent removeMonitor:self.keyEventMonitor];
    self.keyEventMonitor = nil;
    if (@available(macOS 15, *)) {
        // Do nothing
    } else {
        // See note on [self.textInputContext activate] above.
        [self.textInputContext deactivate];
    }
    self.textInputContext = nil;
#endif
#if GLFM_INCLUDE_METAL
    self.metalDevice = nil;
#endif
#if !__has_feature(objc_arc)
    [super dealloc];
#endif
}

#if GLFM_INCLUDE_METAL

- (id<MTLDevice>)metalDevice {
    if (!_metalDevice) {
        self.metalDevice = GLFM_AUTORELEASE(MTLCreateSystemDefaultDevice());
    }
    return _metalDevice;
}

#endif

- (UIView<GLFMView> *)glfmView {
    return (UIView<GLFMView> *)self.view;
}

- (UIView<GLFMView> *)glfmViewIfLoaded {
    if (self.isViewLoaded) {
        return (UIView<GLFMView> *)self.view;
    }
    return nil;
}

- (void)loadView {
    glfmMain(self.glfmDisplay);

    UIView<GLFMView> *glfmView = nil;

#if GLFM_INCLUDE_METAL
    if (self.glfmDisplay->preferredAPI == GLFMRenderingAPIMetal && self.metalDevice) {
        glfmView = GLFM_AUTORELEASE([[GLFMMetalView alloc] initWithFrame:self.defaultFrame
                                                      contentScaleFactor:self.defaultContentScale
                                                                  device:self.metalDevice
                                                             glfmDisplay:self.glfmDisplay]);
    }
#endif
#if TARGET_OS_IOS || TARGET_OS_TV
    if (!glfmView) {
        glfmView = GLFM_AUTORELEASE([[GLFMOpenGLESView alloc] initWithFrame:self.defaultFrame
                                                         contentScaleFactor:self.defaultContentScale
                                                                glfmDisplay:self.glfmDisplay]);
    }
#endif
#if TARGET_OS_OSX
    if (!glfmView) {
        glfmView = GLFM_AUTORELEASE([[GLFMOpenGLView alloc] initWithFrame:self.defaultFrame
                                                              glfmDisplay:self.glfmDisplay]);
    }
#endif
    if (!glfmView) {
        assert(glfmView != nil);
        glfmView = GLFM_AUTORELEASE([[GLFMNullView alloc] initWithFrame:self.defaultFrame]);
    }
    GLFM_WEAK __typeof(self) weakSelf = self;
    glfmView.preRenderCallback = ^{
        [weakSelf preRenderCallback];
    };
    self.view = glfmView;
    self.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;

#if TARGET_OS_OSX
    // Get mouse-move events and cursor events
    NSTrackingAreaOptions trackingOptions = (NSTrackingMouseMoved |
                                             NSTrackingMouseEnteredAndExited |
                                             NSTrackingCursorUpdate |
                                             NSTrackingInVisibleRect |
                                             NSTrackingActiveInKeyWindow);
    [self.view addTrackingArea:GLFM_AUTORELEASE([[NSTrackingArea alloc] initWithRect:NSZeroRect options:trackingOptions
                                                                               owner:self userInfo:nil])];

    // Capture events from the Character Palette
    if ([glfmView conformsToProtocol:@protocol(NSTextInputClient)]) {
        self.textInputContext = GLFM_AUTORELEASE([[NSTextInputContext alloc]
                                                  initWithClient:(id<NSTextInputClient>)glfmView]);
        // Invoking [self.textInputContext activate] causes a log error:
        // "ViewBridge to RemoteViewService Terminated: Error Domain=com.apple.ViewBridge".
        // If macOS 15, it appears unnecessary.
        if (@available(macOS 15, *)) {
            // Do nothing
        } else {
            [self.textInputContext activate];
        }
    }

#endif
}

- (void)preRenderCallback {
#if TARGET_OS_IOS
    [self handleMotionEvents];
#endif
}

- (void)viewDidLoad {
    [super viewDidLoad];

#if TARGET_OS_IOS
    self.view.multipleTouchEnabled = self.multipleTouchEnabled;
    self.orientation = [[UIApplication sharedApplication] statusBarOrientation];

    [self setNeedsStatusBarAppearanceUpdate];

    [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(keyboardFrameWillChange:)
                                               name:UIKeyboardWillChangeFrameNotification object:self.view.window];

    [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(deviceOrientationChanged:)
                                               name:UIDeviceOrientationDidChangeNotification object:self.view.window];

    if (@available(iOS 13.4, *)) {
        UIHoverGestureRecognizer *hover = [[UIHoverGestureRecognizer alloc] initWithTarget:self
                                                                                    action:@selector(hover:)];
        [self.view addGestureRecognizer:hover];
        GLFM_RELEASE(hover);

        UIPointerInteraction *pointerInteraction = [[UIPointerInteraction alloc] initWithDelegate:self];
        [self.view addInteraction:pointerInteraction];
        GLFM_RELEASE(pointerInteraction);
    }
#endif
}

#if TARGET_OS_OSX

- (void)viewDidLayout {
    [super viewDidLayout];

    // There doesn't appear to be a notification for insets changed on macOS.
    if (@available(macOS 11, *)) {
        double top, right, bottom, left;
        glfmGetDisplayChromeInsets(self.glfmDisplay, &top, &right, &bottom, &left);
        NSEdgeInsets newInsets = NSEdgeInsetsMake((CGFloat)top, (CGFloat)left, (CGFloat)bottom, (CGFloat)right);
        if (!NSEdgeInsetsEqual(self.insets, newInsets)) {
            self.insets = newInsets;
            if (self.glfmDisplay->displayChromeInsetsChangedFunc) {
                self.glfmDisplay->displayChromeInsetsChangedFunc(self.glfmDisplay, top, right, bottom, left);
            }
        }
    }
}

#endif

#if TARGET_OS_IOS || TARGET_OS_TV

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    GLFMWindow *window = (GLFMWindow *)self.view.window;
    self.glfmView.animating = window.active;
    [self becomeFirstResponder];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    if (self.glfmDisplay->lowMemoryFunc) {
        self.glfmDisplay->lowMemoryFunc(self.glfmDisplay);
    }
}

- (void)viewSafeAreaInsetsDidChange {
    [super viewSafeAreaInsetsDidChange];
    if (self.glfmDisplay->displayChromeInsetsChangedFunc) {
        double top, right, bottom, left;
        glfmGetDisplayChromeInsets(self.glfmDisplay, &top, &right, &bottom, &left);
        self.glfmDisplay->displayChromeInsetsChangedFunc(self.glfmDisplay, top, right, bottom, left);
    }
}

#endif

#if TARGET_OS_IOS

- (UIView *)inputView {
    if (self.keyboardRequested) {
        return nil; // System keyboard
    }
    return self.noSoftKeyboardView;
}

- (BOOL)prefersStatusBarHidden {
    return self.glfmDisplay->uiChrome != GLFMUserInterfaceChromeNavigationAndStatusBar;
}

- (UIRectEdge)preferredScreenEdgesDeferringSystemGestures {
    UIRectEdge edges =  UIRectEdgeLeft | UIRectEdgeRight;
    return (self.glfmDisplay->uiChrome == GLFMUserInterfaceChromeNone ?
            (UIRectEdgeBottom | edges) : edges);
}

- (UIInterfaceOrientationMask)supportedInterfaceOrientations {
    GLFMInterfaceOrientation orientations = self.glfmDisplay->supportedOrientations;
    BOOL portraitRequested = (orientations & (GLFMInterfaceOrientationPortrait |
                                              GLFMInterfaceOrientationPortraitUpsideDown)) != 0;
    BOOL landscapeRequested = (orientations & GLFMInterfaceOrientationLandscape) != 0;
    BOOL isTablet = [[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad;
    if (portraitRequested && landscapeRequested) {
        return isTablet ? UIInterfaceOrientationMaskAll : UIInterfaceOrientationMaskAllButUpsideDown;
    }
    if (portraitRequested) {
        if (isTablet) {
            return (UIInterfaceOrientationMask)(UIInterfaceOrientationMaskPortrait |
                                                UIInterfaceOrientationMaskPortraitUpsideDown);
        }
        return UIInterfaceOrientationMaskPortrait;
    }
    return UIInterfaceOrientationMaskLandscape;
}

- (void)deviceOrientationChanged:(NSNotification *)notification {
    UIInterfaceOrientation newOrientation = [[UIApplication sharedApplication] statusBarOrientation];
    if (self.orientation != newOrientation) {
        self.orientation = newOrientation;
        [self.glfmViewIfLoaded requestRefresh];
        if (self.glfmDisplay->orientationChangedFunc) {
            self.glfmDisplay->orientationChangedFunc(self.glfmDisplay, glfmGetInterfaceOrientation(self.glfmDisplay));
        }
    }
}

- (CMMotionManager *)motionManager {
    if (!_motionManager) {
        self.motionManager = GLFM_AUTORELEASE([CMMotionManager new]);
        self.motionManager.deviceMotionUpdateInterval = 0.01;
    }
    return _motionManager;
}

- (BOOL)isMotionManagerLoaded {
    return _motionManager != nil;
}

- (void)handleMotionEvents {
    if (!self.isMotionManagerLoaded || !self.motionManager.isDeviceMotionActive) {
        return;
    }
    CMDeviceMotion *deviceMotion = self.motionManager.deviceMotion;
    if (!deviceMotion) {
        // No readings yet
        return;
    }
    GLFMSensorFunc accelerometerFunc = self.glfmDisplay->sensorFuncs[GLFMSensorAccelerometer];
    if (accelerometerFunc) {
        GLFMSensorEvent event = { 0 };
        event.sensor = GLFMSensorAccelerometer;
        event.timestamp = deviceMotion.timestamp;
        event.vector.x = deviceMotion.userAcceleration.x + deviceMotion.gravity.x;
        event.vector.y = deviceMotion.userAcceleration.y + deviceMotion.gravity.y;
        event.vector.z = deviceMotion.userAcceleration.z + deviceMotion.gravity.z;
        accelerometerFunc(self.glfmDisplay, event);
    }

    GLFMSensorFunc magnetometerFunc = self.glfmDisplay->sensorFuncs[GLFMSensorMagnetometer];
    if (magnetometerFunc) {
        GLFMSensorEvent event = { 0 };
        event.sensor = GLFMSensorMagnetometer;
        event.timestamp = deviceMotion.timestamp;
        event.vector.x = deviceMotion.magneticField.field.x;
        event.vector.y = deviceMotion.magneticField.field.y;
        event.vector.z = deviceMotion.magneticField.field.z;
        magnetometerFunc(self.glfmDisplay, event);
    }

    GLFMSensorFunc gyroscopeFunc = self.glfmDisplay->sensorFuncs[GLFMSensorGyroscope];
    if (gyroscopeFunc) {
        GLFMSensorEvent event = { 0 };
        event.sensor = GLFMSensorGyroscope;
        event.timestamp = deviceMotion.timestamp;
        event.vector.x = deviceMotion.rotationRate.x;
        event.vector.y = deviceMotion.rotationRate.y;
        event.vector.z = deviceMotion.rotationRate.z;
        gyroscopeFunc(self.glfmDisplay, event);
    }

    GLFMSensorFunc rotationFunc = self.glfmDisplay->sensorFuncs[GLFMSensorRotationMatrix];
    if (rotationFunc) {
        GLFMSensorEvent event = { 0 };
        event.sensor = GLFMSensorRotationMatrix;
        event.timestamp = deviceMotion.timestamp;
        CMRotationMatrix matrix = deviceMotion.attitude.rotationMatrix;
        event.matrix.m00 = matrix.m11; event.matrix.m01 = matrix.m12; event.matrix.m02 = matrix.m13;
        event.matrix.m10 = matrix.m21; event.matrix.m11 = matrix.m22; event.matrix.m12 = matrix.m23;
        event.matrix.m20 = matrix.m31; event.matrix.m21 = matrix.m32; event.matrix.m22 = matrix.m33;
        rotationFunc(self.glfmDisplay, event);
    }
}

- (void)updateMotionManagerActiveState {
    BOOL enable = NO;
    GLFMWindow *window = (GLFMWindow *)self.viewIfLoaded.window;
    if (window.active) {
        for (int i = 0; i < GLFM_NUM_SENSORS; i++) {
            if (self.glfmDisplay->sensorFuncs[i] != NULL) {
                enable = YES;
                break;
            }
        }
    }

    if (enable && !self.motionManager.deviceMotionActive) {
        CMAttitudeReferenceFrame referenceFrame;
        CMAttitudeReferenceFrame availableReferenceFrames = [CMMotionManager availableAttitudeReferenceFrames];
        if (availableReferenceFrames & CMAttitudeReferenceFrameXMagneticNorthZVertical) {
            referenceFrame = CMAttitudeReferenceFrameXMagneticNorthZVertical;
        } else if (availableReferenceFrames & CMAttitudeReferenceFrameXArbitraryCorrectedZVertical) {
            referenceFrame = CMAttitudeReferenceFrameXArbitraryCorrectedZVertical;
        } else {
            referenceFrame = CMAttitudeReferenceFrameXArbitraryZVertical;
        }
        [self.motionManager startDeviceMotionUpdatesUsingReferenceFrame:referenceFrame];
    } else if (!enable && self.isMotionManagerLoaded && self.motionManager.deviceMotionActive) {
        [self.motionManager stopDeviceMotionUpdates];
    }
}

#endif // TARGET_OS_IOS

#if TARGET_OS_IOS || TARGET_OS_TV

// MARK: UIResponder

- (BOOL)canBecomeFirstResponder {
    return YES;
}

- (void)clearTouches {
    for (int i = 0; i < GLFM_MAX_SIMULTANEOUS_TOUCHES; i++) {
        activeTouches[i] = NULL;
    }
}

- (void)addTouchEvent:(UITouch *)touch withType:(GLFMTouchPhase)phase {
    int firstNullIndex = -1;
    int index = -1;
    for (int i = 0; i < GLFM_MAX_SIMULTANEOUS_TOUCHES; i++) {
        if (activeTouches[i] == (__bridge const void *)touch) {
            index = i;
            break;
        }
        if (firstNullIndex == -1 && activeTouches[i] == NULL) {
            firstNullIndex = i;
        }
    }
    if (index == -1) {
        if (firstNullIndex == -1) {
            // Shouldn't happen
            return;
        }
        index = firstNullIndex;
        activeTouches[index] = (__bridge const void *)touch;
    }

    if (self.glfmDisplay->touchFunc) {
        CGPoint currLocation = [touch locationInView:self.view];
        currLocation.x *= self.view.contentScaleFactor;
        currLocation.y *= self.view.contentScaleFactor;

        self.glfmDisplay->touchFunc(self.glfmDisplay, index, phase, (double)currLocation.x, (double)currLocation.y);
    }

    if (phase == GLFMTouchPhaseEnded || phase == GLFMTouchPhaseCancelled) {
        activeTouches[index] = NULL;
    }
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
    for (UITouch *touch in touches) {
        [self addTouchEvent:touch withType:GLFMTouchPhaseBegan];
    }
}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
    for (UITouch *touch in touches) {
        [self addTouchEvent:touch withType:GLFMTouchPhaseMoved];
    }
}

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
    for (UITouch *touch in touches) {
        [self addTouchEvent:touch withType:GLFMTouchPhaseEnded];
    }
}

- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event {
    for (UITouch *touch in touches) {
        [self addTouchEvent:touch withType:GLFMTouchPhaseCancelled];
    }
}

#if TARGET_OS_IOS

- (void)hover:(UIHoverGestureRecognizer *)recognizer API_AVAILABLE(ios(13.4)) {
    if (self.glfmDisplay->touchFunc && (recognizer.state == UIGestureRecognizerStateBegan ||
                                        recognizer.state == UIGestureRecognizerStateChanged)) {
        CGPoint currLocation = [recognizer locationInView:self.view];
        currLocation.x *= self.view.contentScaleFactor;
        currLocation.y *= self.view.contentScaleFactor;

        self.glfmDisplay->touchFunc(self.glfmDisplay, 0, GLFMTouchPhaseHover,
                                    (double)currLocation.x, (double)currLocation.y);
    }
}

- (UIPointerStyle *)pointerInteraction:(UIPointerInteraction *)interaction
                        styleForRegion:(UIPointerRegion *)region API_AVAILABLE(ios(13.4)) {
    switch (self.mouseCursor) {
        case GLFMMouseCursorText:
            return [UIPointerStyle styleWithShape:[UIPointerShape beamWithPreferredLength:20 axis:UIAxisVertical]
                                  constrainedAxes:UIAxisNeither];
        case GLFMMouseCursorVerticalText:
            return [UIPointerStyle styleWithShape:[UIPointerShape beamWithPreferredLength:20 axis:UIAxisHorizontal]
                                  constrainedAxes:UIAxisNeither];
        case GLFMMouseCursorNone:
            return [UIPointerStyle hiddenPointerStyle];
        case GLFMMouseCursorCrosshair:
        case GLFMMouseCursorDefault:
        case GLFMMouseCursorAuto:
        case GLFMMouseCursorPointer:
        default:
            return nil;
    }
}

#endif

- (BOOL)handlePress:(UIPress *)press withAction:(GLFMKeyAction)action {
#if TARGET_OS_IOS
    if (!self.glfmDisplay->keyFunc) {
        return NO;
    }
#elif TARGET_OS_TV
    if (!self.glfmDisplay->keyFunc && !self.glfmDisplay->charFunc) {
        return NO;
    }
#endif

    GLFMKeyCode keyCode = GLFMKeyCodeUnknown;
    int modifierFlags = 0;
    BOOL hasKey = NO;
    BOOL isPrintable = NO;
    if (@available(iOS 13.4, tvOS 13.4, *)) {
        static const GLFMKeyCode HID_MAP[] = {
            [UIKeyboardHIDUsageKeyboardReturnOrEnter]        = GLFMKeyCodeEnter,
            [UIKeyboardHIDUsageKeyboardTab]                  = GLFMKeyCodeTab,
            [UIKeyboardHIDUsageKeyboardSpacebar]             = GLFMKeyCodeSpace,
            [UIKeyboardHIDUsageKeyboardDeleteOrBackspace]    = GLFMKeyCodeBackspace,
            [UIKeyboardHIDUsageKeyboardEscape]               = GLFMKeyCodeEscape,

            [UIKeyboardHIDUsageKeyboardCapsLock]             = GLFMKeyCodeCapsLock,
            [UIKeyboardHIDUsageKeyboardLeftGUI]              = GLFMKeyCodeMetaLeft,
            [UIKeyboardHIDUsageKeyboardLeftShift]            = GLFMKeyCodeShiftLeft,
            [UIKeyboardHIDUsageKeyboardLeftAlt]              = GLFMKeyCodeAltLeft,
            [UIKeyboardHIDUsageKeyboardLeftControl]          = GLFMKeyCodeControlLeft,
            [UIKeyboardHIDUsageKeyboardRightGUI]             = GLFMKeyCodeMetaRight,
            [UIKeyboardHIDUsageKeyboardRightShift]           = GLFMKeyCodeShiftRight,
            [UIKeyboardHIDUsageKeyboardRightAlt]             = GLFMKeyCodeAltRight,
            [UIKeyboardHIDUsageKeyboardRightControl]         = GLFMKeyCodeControlRight,
            [UIKeyboardHIDUsageKeyboardApplication]          = GLFMKeyCodeMenu,

            [UIKeyboardHIDUsageKeyboardPrintScreen]          = GLFMKeyCodePrintScreen,
            [UIKeyboardHIDUsageKeyboardScrollLock]           = GLFMKeyCodeScrollLock,
            [UIKeyboardHIDUsageKeyboardPause]                = GLFMKeyCodePause,

            [UIKeyboardHIDUsageKeyboardInsert]               = GLFMKeyCodeInsert,
            [UIKeyboardHIDUsageKeyboardHome]                 = GLFMKeyCodeHome,
            [UIKeyboardHIDUsageKeyboardPageUp]               = GLFMKeyCodePageUp,
            [UIKeyboardHIDUsageKeyboardDeleteForward]        = GLFMKeyCodeDelete,
            [UIKeyboardHIDUsageKeyboardEnd]                  = GLFMKeyCodeEnd,
            [UIKeyboardHIDUsageKeyboardPageDown]             = GLFMKeyCodePageDown,

            [UIKeyboardHIDUsageKeyboardLeftArrow]            = GLFMKeyCodeArrowLeft,
            [UIKeyboardHIDUsageKeyboardRightArrow]           = GLFMKeyCodeArrowRight,
            [UIKeyboardHIDUsageKeyboardDownArrow]            = GLFMKeyCodeArrowDown,
            [UIKeyboardHIDUsageKeyboardUpArrow]              = GLFMKeyCodeArrowUp,

            [UIKeyboardHIDUsageKeyboardEqualSign]            = GLFMKeyCodeEqual,
            [UIKeyboardHIDUsageKeyboardHyphen]               = GLFMKeyCodeMinus,
            [UIKeyboardHIDUsageKeyboardOpenBracket]          = GLFMKeyCodeBracketLeft,
            [UIKeyboardHIDUsageKeyboardCloseBracket]         = GLFMKeyCodeBracketRight,
            [UIKeyboardHIDUsageKeyboardQuote]                = GLFMKeyCodeQuote,
            [UIKeyboardHIDUsageKeyboardSemicolon]            = GLFMKeyCodeSemicolon,
            [UIKeyboardHIDUsageKeyboardBackslash]            = GLFMKeyCodeBackslash,
            [UIKeyboardHIDUsageKeyboardComma]                = GLFMKeyCodeComma,
            [UIKeyboardHIDUsageKeyboardSlash]                = GLFMKeyCodeSlash,
            [UIKeyboardHIDUsageKeyboardPeriod]               = GLFMKeyCodePeriod,
            [UIKeyboardHIDUsageKeyboardGraveAccentAndTilde]  = GLFMKeyCodeBackquote,

            [UIKeyboardHIDUsageKeyboardA]                    = GLFMKeyCodeA,
            [UIKeyboardHIDUsageKeyboardB]                    = GLFMKeyCodeB,
            [UIKeyboardHIDUsageKeyboardC]                    = GLFMKeyCodeC,
            [UIKeyboardHIDUsageKeyboardD]                    = GLFMKeyCodeD,
            [UIKeyboardHIDUsageKeyboardE]                    = GLFMKeyCodeE,
            [UIKeyboardHIDUsageKeyboardF]                    = GLFMKeyCodeF,
            [UIKeyboardHIDUsageKeyboardG]                    = GLFMKeyCodeG,
            [UIKeyboardHIDUsageKeyboardH]                    = GLFMKeyCodeH,
            [UIKeyboardHIDUsageKeyboardI]                    = GLFMKeyCodeI,
            [UIKeyboardHIDUsageKeyboardJ]                    = GLFMKeyCodeJ,
            [UIKeyboardHIDUsageKeyboardK]                    = GLFMKeyCodeK,
            [UIKeyboardHIDUsageKeyboardL]                    = GLFMKeyCodeL,
            [UIKeyboardHIDUsageKeyboardN]                    = GLFMKeyCodeN,
            [UIKeyboardHIDUsageKeyboardM]                    = GLFMKeyCodeM,
            [UIKeyboardHIDUsageKeyboardO]                    = GLFMKeyCodeO,
            [UIKeyboardHIDUsageKeyboardP]                    = GLFMKeyCodeP,
            [UIKeyboardHIDUsageKeyboardQ]                    = GLFMKeyCodeQ,
            [UIKeyboardHIDUsageKeyboardR]                    = GLFMKeyCodeR,
            [UIKeyboardHIDUsageKeyboardS]                    = GLFMKeyCodeS,
            [UIKeyboardHIDUsageKeyboardT]                    = GLFMKeyCodeT,
            [UIKeyboardHIDUsageKeyboardU]                    = GLFMKeyCodeU,
            [UIKeyboardHIDUsageKeyboardV]                    = GLFMKeyCodeV,
            [UIKeyboardHIDUsageKeyboardW]                    = GLFMKeyCodeW,
            [UIKeyboardHIDUsageKeyboardX]                    = GLFMKeyCodeX,
            [UIKeyboardHIDUsageKeyboardY]                    = GLFMKeyCodeY,
            [UIKeyboardHIDUsageKeyboardZ]                    = GLFMKeyCodeZ,
            [UIKeyboardHIDUsageKeyboard0]                    = GLFMKeyCode0,
            [UIKeyboardHIDUsageKeyboard1]                    = GLFMKeyCode1,
            [UIKeyboardHIDUsageKeyboard2]                    = GLFMKeyCode2,
            [UIKeyboardHIDUsageKeyboard3]                    = GLFMKeyCode3,
            [UIKeyboardHIDUsageKeyboard4]                    = GLFMKeyCode4,
            [UIKeyboardHIDUsageKeyboard5]                    = GLFMKeyCode5,
            [UIKeyboardHIDUsageKeyboard6]                    = GLFMKeyCode6,
            [UIKeyboardHIDUsageKeyboard7]                    = GLFMKeyCode7,
            [UIKeyboardHIDUsageKeyboard8]                    = GLFMKeyCode8,
            [UIKeyboardHIDUsageKeyboard9]                    = GLFMKeyCode9,

            [UIKeyboardHIDUsageKeyboardPower]                = GLFMKeyCodePower,

            [UIKeyboardHIDUsageKeypadNumLock]                = GLFMKeyCodeNumLock,
            [UIKeyboardHIDUsageKeypadPeriod]                 = GLFMKeyCodeNumpadDecimal,
            [UIKeyboardHIDUsageKeypadAsterisk]               = GLFMKeyCodeNumpadMultiply,
            [UIKeyboardHIDUsageKeypadPlus]                   = GLFMKeyCodeNumpadAdd,
            [UIKeyboardHIDUsageKeypadSlash]                  = GLFMKeyCodeNumpadDivide,
            [UIKeyboardHIDUsageKeypadEnter]                  = GLFMKeyCodeNumpadEnter,
            [UIKeyboardHIDUsageKeypadHyphen]                 = GLFMKeyCodeNumpadSubtract,
            [UIKeyboardHIDUsageKeypadEqualSign]              = GLFMKeyCodeNumpadEqual,
            [UIKeyboardHIDUsageKeypad0]                      = GLFMKeyCodeNumpad0,
            [UIKeyboardHIDUsageKeypad1]                      = GLFMKeyCodeNumpad1,
            [UIKeyboardHIDUsageKeypad2]                      = GLFMKeyCodeNumpad2,
            [UIKeyboardHIDUsageKeypad3]                      = GLFMKeyCodeNumpad3,
            [UIKeyboardHIDUsageKeypad4]                      = GLFMKeyCodeNumpad4,
            [UIKeyboardHIDUsageKeypad5]                      = GLFMKeyCodeNumpad5,
            [UIKeyboardHIDUsageKeypad6]                      = GLFMKeyCodeNumpad6,
            [UIKeyboardHIDUsageKeypad7]                      = GLFMKeyCodeNumpad7,
            [UIKeyboardHIDUsageKeypad8]                      = GLFMKeyCodeNumpad8,
            [UIKeyboardHIDUsageKeypad9]                      = GLFMKeyCodeNumpad9,

            [UIKeyboardHIDUsageKeyboardF1]                   = GLFMKeyCodeF1,
            [UIKeyboardHIDUsageKeyboardF2]                   = GLFMKeyCodeF2,
            [UIKeyboardHIDUsageKeyboardF3]                   = GLFMKeyCodeF3,
            [UIKeyboardHIDUsageKeyboardF4]                   = GLFMKeyCodeF4,
            [UIKeyboardHIDUsageKeyboardF5]                   = GLFMKeyCodeF5,
            [UIKeyboardHIDUsageKeyboardF6]                   = GLFMKeyCodeF6,
            [UIKeyboardHIDUsageKeyboardF7]                   = GLFMKeyCodeF7,
            [UIKeyboardHIDUsageKeyboardF8]                   = GLFMKeyCodeF8,
            [UIKeyboardHIDUsageKeyboardF9]                   = GLFMKeyCodeF9,
            [UIKeyboardHIDUsageKeyboardF10]                  = GLFMKeyCodeF10,
            [UIKeyboardHIDUsageKeyboardF11]                  = GLFMKeyCodeF11,
            [UIKeyboardHIDUsageKeyboardF12]                  = GLFMKeyCodeF12,
            [UIKeyboardHIDUsageKeyboardF13]                  = GLFMKeyCodeF13,
            [UIKeyboardHIDUsageKeyboardF14]                  = GLFMKeyCodeF14,
            [UIKeyboardHIDUsageKeyboardF15]                  = GLFMKeyCodeF15,
            [UIKeyboardHIDUsageKeyboardF16]                  = GLFMKeyCodeF16,
            [UIKeyboardHIDUsageKeyboardF17]                  = GLFMKeyCodeF17,
            [UIKeyboardHIDUsageKeyboardF18]                  = GLFMKeyCodeF18,
            [UIKeyboardHIDUsageKeyboardF19]                  = GLFMKeyCodeF19,
            [UIKeyboardHIDUsageKeyboardF20]                  = GLFMKeyCodeF20,
            [UIKeyboardHIDUsageKeyboardF21]                  = GLFMKeyCodeF21,
            [UIKeyboardHIDUsageKeyboardF22]                  = GLFMKeyCodeF22,
            [UIKeyboardHIDUsageKeyboardF23]                  = GLFMKeyCodeF23,
            [UIKeyboardHIDUsageKeyboardF24]                  = GLFMKeyCodeF24,
        };

        UIKey *key = press.key;
        if (key) {
            BOOL isControlKey = NO;
            hasKey = YES;
            if ((key.modifierFlags & UIKeyModifierShift) != 0) {
                modifierFlags |= GLFMKeyModifierShift;
            }
            if ((key.modifierFlags & UIKeyModifierControl) != 0) {
                modifierFlags |= GLFMKeyModifierControl;
                isControlKey = YES;
            }
            if ((key.modifierFlags & UIKeyModifierAlternate) != 0) {
                modifierFlags |= GLFMKeyModifierAlt;
            }
            if ((key.modifierFlags & UIKeyModifierCommand) != 0) {
                modifierFlags |= GLFMKeyModifierMeta;
                isControlKey = YES;
            }
            if (key.keyCode >= 0 && (size_t)key.keyCode < sizeof(HID_MAP) / sizeof(*HID_MAP)) {
                keyCode = HID_MAP[key.keyCode];
            }
            if (self.isFirstResponder && self.glfmDisplay->charFunc != NULL &&
                action != GLFMKeyActionReleased && !isControlKey &&
                keyCode >= GLFMKeyCodeSpace && keyCode != GLFMKeyCodeDelete) {
                NSString *chars = key.charactersIgnoringModifiers;
                isPrintable = (chars.length > 0 && [chars characterAtIndex:0] >= ' ' &&
                               ![chars hasPrefix:@"UIKeyInput"]);
            }
        }
    }

    // NOTE: iOS supports UIKeyInput, but tvOS does not. Handle them separately.

#if TARGET_OS_IOS

    if (self.isFirstResponder &&
        (keyCode == GLFMKeyCodeEnter || keyCode == GLFMKeyCodeTab || keyCode == GLFMKeyCodeBackspace)) {
        // Let UIKeyInput handle these keys via insertText and deleteBackwards (allow key repeating).
        return NO;
    }
    if (keyCode == GLFMKeyCodeUnknown && !hasKey) {
        // The tab key on the Magic Keyboard sends two UIPress events. For the second one, press.key=nil and press.type=0xcb.
        return NO;
    }
    BOOL handled = self.glfmDisplay->keyFunc(self.glfmDisplay, keyCode, action, modifierFlags);
    if (self.isFirstResponder && isPrintable && self.glfmDisplay->charFunc) {
        // Send text via insertText.
        return NO;
    }
    return handled;

#endif // TARGET_OS_IOS

#if TARGET_OS_TV

    if (keyCode == GLFMKeyCodeUnknown) {
        switch (press.type) {
            case UIPressTypeUpArrow:
                keyCode = GLFMKeyCodeArrowUp;
                break;
            case UIPressTypeDownArrow:
                keyCode = GLFMKeyCodeArrowDown;
                break;
            case UIPressTypeLeftArrow:
                keyCode = GLFMKeyCodeArrowLeft;
                break;
            case UIPressTypeRightArrow:
                keyCode = GLFMKeyCodeArrowRight;
                break;
            case UIPressTypeSelect:
                keyCode = GLFMKeyCodeMediaSelect;
                break;
            case UIPressTypeMenu:
                keyCode = GLFMKeyCodeNavigationBack;
                break;
            case UIPressTypePlayPause:
                keyCode = GLFMKeyCodeMediaPlayPause;
                break;
            case UIPressTypePageUp:
                keyCode = GLFMKeyCodePageUp;
                break;
            case UIPressTypePageDown:
                keyCode = GLFMKeyCodePageDown;
                break;
#if __TV_OS_VERSION_MAX_ALLOWED >= 180100
            case UIPressTypeTVRemoteOneTwoThree:
                // Fallthrough
            case UIPressTypeTVRemoteFourColors:
                // Fallthrough
#endif
            default:
                keyCode = GLFMKeyCodeUnknown;
                break;
        }
    }

    BOOL handled = NO;
    if (self.glfmDisplay->keyFunc) {
        handled = self.glfmDisplay->keyFunc(self.glfmDisplay, keyCode, action, modifierFlags);
    }
    if (@available(iOS 13.4, tvOS 13.4, *)) {
        if (self.isFirstResponder && hasKey && isPrintable && self.glfmDisplay->charFunc) {
            self.glfmDisplay->charFunc(self.glfmDisplay, press.key.characters.UTF8String, 0);
        }
    }
    return handled;

#endif // TARGET_OS_TV

}

// Returns set of unhandled presses
- (NSSet<UIPress *> *)handlePresses:(NSSet<UIPress *> *)presses withAction:(GLFMKeyAction)action {
    NSMutableSet<UIPress *> *unhandledPresses = nil;
    for (UIPress *press in presses) {
        BOOL handled = [self handlePress:press withAction:action];
        if (!handled) {
            if (presses.count == 1) {
                return presses; // Likely case
            }
            if (!unhandledPresses) {
                unhandledPresses = [NSMutableSet set];
            }
            [unhandledPresses addObject:press];
        }
    }
    return unhandledPresses;
}

- (void)pressesBegan:(NSSet<UIPress *> *)presses withEvent:(UIPressesEvent *)event {
    NSSet<UIPress *> *unhandledPresses = [self handlePresses:presses withAction:GLFMKeyActionPressed];
    if (unhandledPresses.count > 0) {
        [super pressesBegan:unhandledPresses withEvent:event];
    }
}

- (void)pressesChanged:(NSSet<UIPress *> *)presses withEvent:(UIPressesEvent *)event {
    [super pressesChanged:presses withEvent:event];
}

- (void)pressesEnded:(NSSet<UIPress *> *)presses withEvent:(UIPressesEvent *)event {
    NSSet<UIPress *> *unhandledPresses = [self handlePresses:presses withAction:GLFMKeyActionReleased];
    if (unhandledPresses.count > 0) {
        [super pressesEnded:unhandledPresses withEvent:event];
    }
}

- (void)pressesCancelled:(NSSet<UIPress *> *)presses withEvent:(UIPressesEvent *)event {
    NSSet<UIPress *> *unhandledPresses = [self handlePresses:presses withAction:GLFMKeyActionReleased];
    if (unhandledPresses.count > 0) {
        [super pressesCancelled:unhandledPresses withEvent:event];
    }
}

// MARK: UIKeyInput

#if TARGET_OS_IOS

- (void)keyboardFrameWillChange:(NSNotification *)notification {
    NSObject *frameBeginValue = notification.userInfo[UIKeyboardFrameBeginUserInfoKey];
    NSObject *frameEndValue = notification.userInfo[UIKeyboardFrameEndUserInfoKey];
    if ([frameBeginValue isKindOfClass:[NSValue class]] &&
        [frameEndValue isKindOfClass:[NSValue class]]) {
        CGRect keyboardFrameBegin = [(NSValue *)frameBeginValue CGRectValue];
        CGRect keyboardFrameEnd = [(NSValue *)frameEndValue CGRectValue];

        // If height is zero, the keyboard is hidden because a physical keyboard was attached.
        BOOL keyboardWasVisible = CGRectIntersectsRect(self.view.window.frame, keyboardFrameBegin);
        BOOL keyboardIsVisible = CGRectIntersectsRect(self.view.window.frame, keyboardFrameEnd);
        if (keyboardWasVisible && !keyboardIsVisible && keyboardFrameEnd.size.height > (CGFloat)0.0) {
            // User hid keyboard (iPad)
            self.keyboardRequested = NO;
        }

        [self.glfmViewIfLoaded requestRefresh];

        if (self.glfmDisplay->keyboardVisibilityChangedFunc) {
            // Convert to view coordinates
            keyboardFrameEnd = [self.view convertRect:keyboardFrameEnd fromView:nil];

            // Convert to pixels
            keyboardFrameEnd.origin.x *= self.view.contentScaleFactor;
            keyboardFrameEnd.origin.y *= self.view.contentScaleFactor;
            keyboardFrameEnd.size.width *= self.view.contentScaleFactor;
            keyboardFrameEnd.size.height *= self.view.contentScaleFactor;

            self.glfmDisplay->keyboardVisibilityChangedFunc(self.glfmDisplay, keyboardIsVisible,
                                                            (double)keyboardFrameEnd.origin.x,
                                                            (double)keyboardFrameEnd.origin.y,
                                                            (double)keyboardFrameEnd.size.width,
                                                            (double)keyboardFrameEnd.size.height);
        }
    }
}

// UITextInputTraits - disable suggestion bar
- (UITextAutocorrectionType)autocorrectionType {
    return UITextAutocorrectionTypeNo;
}

- (BOOL)hasText {
    return YES;
}

- (void)insertText:(NSString *)text {
    if ([text isEqualToString:@"\n"]) {
        if (self.glfmDisplay->keyFunc) {
            self.glfmDisplay->keyFunc(self.glfmDisplay, GLFMKeyCodeEnter, GLFMKeyActionPressed, 0);
        }
        if (self.glfmDisplay->keyFunc) {
            self.glfmDisplay->keyFunc(self.glfmDisplay, GLFMKeyCodeEnter, GLFMKeyActionReleased, 0);
        }
    } else if ([text isEqualToString:@"\t"]) {
        if (self.glfmDisplay->keyFunc) {
            self.glfmDisplay->keyFunc(self.glfmDisplay, GLFMKeyCodeTab, GLFMKeyActionPressed, 0);
        }
        if (self.glfmDisplay->keyFunc) {
            self.glfmDisplay->keyFunc(self.glfmDisplay, GLFMKeyCodeTab, GLFMKeyActionReleased, 0);
        }
    } else if (self.glfmDisplay->charFunc) {
        self.glfmDisplay->charFunc(self.glfmDisplay, text.UTF8String, 0);
    }
}

- (void)deleteBackward {
    // NOTE: This method is called for key repeat events when using a hardware keyboard, but not
    // when using the software keyboard.
    if (self.glfmDisplay->keyFunc) {
        self.glfmDisplay->keyFunc(self.glfmDisplay, GLFMKeyCodeBackspace, GLFMKeyActionPressed, 0);
    }
    if (self.glfmDisplay->keyFunc) {
        self.glfmDisplay->keyFunc(self.glfmDisplay, GLFMKeyCodeBackspace, GLFMKeyActionReleased, 0);
    }
}

#endif // TARGET_OS_IOS

- (NSArray<UIKeyCommand *> *)keyCommands {
    if (@available(iOS 13.4, tvOS 13.4, *)) {
        // Using UIPress events
        return @[];
    }
    static NSArray<UIKeyCommand *> *keyCommands = NULL;
    if (!keyCommands) {
        NSArray<NSString *> *keyInputs = @[
            UIKeyInputUpArrow, UIKeyInputDownArrow, UIKeyInputLeftArrow, UIKeyInputRightArrow,
            UIKeyInputEscape, UIKeyInputPageUp, UIKeyInputPageDown,
        ];
        NSMutableArray *mutableKeyCommands = GLFM_AUTORELEASE([NSMutableArray new]);
        [keyInputs enumerateObjectsUsingBlock:^(NSString *keyInput, NSUInteger idx, BOOL *stop) {
            (void)idx;
            (void)stop;
            [mutableKeyCommands addObject:[UIKeyCommand keyCommandWithInput:keyInput
                                                              modifierFlags:(UIKeyModifierFlags)0
                                                                     action:@selector(keyPressed:)]];
        }];
        keyCommands = [mutableKeyCommands copy];
    }
    return keyCommands;
}

- (void)keyPressed:(UIKeyCommand *)keyCommand {
    // Only invoked on iOS/tvOS 13.3 and older
    NSString *key = keyCommand.input;
    GLFMKeyCode keyCode = GLFMKeyCodeUnknown;
    if (key == UIKeyInputUpArrow) {
        keyCode = GLFMKeyCodeArrowUp;
    } else if (key == UIKeyInputDownArrow) {
        keyCode = GLFMKeyCodeArrowDown;
    } else if (key == UIKeyInputLeftArrow) {
        keyCode = GLFMKeyCodeArrowLeft;
    } else if (key == UIKeyInputRightArrow) {
        keyCode = GLFMKeyCodeArrowRight;
    } else if (key == UIKeyInputEscape) {
        keyCode = GLFMKeyCodeEscape;
    } else if (key == UIKeyInputPageUp) {
        keyCode = GLFMKeyCodePageUp;
    } else if (key == UIKeyInputPageDown) {
        keyCode = GLFMKeyCodePageDown;
    }
    if (self.glfmDisplay->keyFunc) {
        self.glfmDisplay->keyFunc(self.glfmDisplay, keyCode, GLFMKeyActionPressed, 0);
    }
    if (self.glfmDisplay->keyFunc) {
        self.glfmDisplay->keyFunc(self.glfmDisplay, keyCode, GLFMKeyActionReleased, 0);
    }
}

#endif // TARGET_OS_IOS || TARGET_OS_TV

#if TARGET_OS_OSX

// MARK: NSResponder (Mouse)

// Returns NO if location could not be determined
- (BOOL)getLocationForEvent:(NSEvent *)event outX:(double *)outX outY:(double *)outY {
    NSWindow *window = event.window;
    CGPoint locationInWindow;
    if (window) {
        locationInWindow = event.locationInWindow;
    } else {
        window = self.view.window;
        if (!window) {
            return NO;
        }
        // When event.window is nil, the locationInWindow property "contains the
        // event location in screen coordinates."
        CGPoint locationInScreen = event.locationInWindow;
        locationInWindow = [window convertPointFromScreen:locationInScreen];
    }
    CGFloat scale = window.backingScaleFactor;
    CGFloat contentHeight = window.contentLayoutRect.size.height;
    *outX = locationInWindow.x * scale;
    *outY = (contentHeight - locationInWindow.y) * scale; // Flip y

    return YES;
}

- (void)sendMouseEvent:(NSEvent *)event withType:(GLFMTouchPhase)phase {
    if (!self.glfmDisplay->touchFunc) {
        return;
    }

    double x, y;
    if (![self getLocationForEvent:event outX:&x outY:&y]) {
        return;
    }

    if (phase == GLFMTouchPhaseEnded) {
        GLFMWindow *window = (GLFMWindow *)self.glfmViewIfLoaded.window;
        if (!window.active) {
            phase = GLFMTouchPhaseCancelled;
        }
    }

    self.glfmDisplay->touchFunc(self.glfmDisplay, (int)event.buttonNumber, phase, x, y);
}

- (void)mouseMoved:(NSEvent *)event {
    [self sendMouseEvent:event withType:GLFMTouchPhaseHover];
}

- (void)mouseDown:(NSEvent *)event {
    [self sendMouseEvent:event withType:GLFMTouchPhaseBegan];
}

- (void)mouseDragged:(NSEvent *)event {
    [self sendMouseEvent:event withType:GLFMTouchPhaseMoved];
}

- (void)mouseUp:(NSEvent *)event {
    [self sendMouseEvent:event withType:GLFMTouchPhaseEnded];
}

- (void)rightMouseDown:(NSEvent *)event {
    [self sendMouseEvent:event withType:GLFMTouchPhaseBegan];
}

- (void)rightMouseDragged:(NSEvent *)event {
    [self sendMouseEvent:event withType:GLFMTouchPhaseMoved];
}

- (void)rightMouseUp:(NSEvent *)event {
    [self sendMouseEvent:event withType:GLFMTouchPhaseEnded];
}

- (void)otherMouseDown:(NSEvent *)event {
    [self sendMouseEvent:event withType:GLFMTouchPhaseBegan];
}

- (void)otherMouseDragged:(NSEvent *)event {
    [self sendMouseEvent:event withType:GLFMTouchPhaseMoved];
}

- (void)otherMouseUp:(NSEvent *)event {
    [self sendMouseEvent:event withType:GLFMTouchPhaseEnded];
}

- (void)scrollWheel:(NSEvent *)event {
    if (!self.glfmDisplay->mouseWheelFunc) {
        return;
    }

    double x, y;
    if (![self getLocationForEvent:event outX:&x outY:&y]) {
        return;
    }

    // Invert to match web browser behavior
    double deltaX = -event.scrollingDeltaX;
    double deltaY = -event.scrollingDeltaY;
    GLFMMouseWheelDeltaType deltaType = (event.hasPreciseScrollingDeltas ? GLFMMouseWheelDeltaPixel
                                         : GLFMMouseWheelDeltaLine);

    self.glfmDisplay->mouseWheelFunc(self.glfmDisplay, x, y, deltaType, deltaX, deltaY, 0.0);
}

- (void)cursorUpdate:(NSEvent *)event {
    if (event.trackingArea) {
        [self.currentCursor set];
    } else {
        [super cursorUpdate:event];
    }
}

- (void)mouseEntered:(NSEvent *)event {
    self.mouseInside = YES;
}

- (void)mouseExited:(NSEvent *)event {
    self.mouseInside = NO;
    [NSCursor.arrowCursor set];
}

// MARK: NSResponder (Keyboard)

- (void)setCurrentKeyboard {
    if (self.currentKeyboard) {
        CFRelease(self.currentKeyboard);
    }
    self.currentKeyboard = TISCopyCurrentKeyboardInputSource();
    CFDataRef layoutData = TISGetInputSourceProperty(self.currentKeyboard, kTISPropertyUnicodeKeyLayoutData);
    if (layoutData) {
        self.keyboardLayout = (const UCKeyboardLayout *)(const void *)CFDataGetBytePtr(layoutData);
    } else {
        self.keyboardLayout = NULL;
    }
}

- (void)keyboardChanged:(NSObject *)object {
    [self setCurrentKeyboard];
}

- (BOOL)sendKeyEvent:(NSEvent *)event withAction:(GLFMKeyAction)action {
    BOOL handled = NO;

    // Send key event
    if (self.glfmDisplay->keyFunc) {
        static const GLFMKeyCode VK_MAP[] = {
            [kVK_Return]                    = GLFMKeyCodeEnter,
            [kVK_Tab]                       = GLFMKeyCodeTab,
            [kVK_Space]                     = GLFMKeyCodeSpace,
            [kVK_Delete]                    = GLFMKeyCodeBackspace,
            [kVK_Escape]                    = GLFMKeyCodeEscape,
            [kVK_Command]                   = GLFMKeyCodeMetaLeft,
            [kVK_Shift]                     = GLFMKeyCodeShiftLeft,
            [kVK_CapsLock]                  = GLFMKeyCodeCapsLock,
            [kVK_Option]                    = GLFMKeyCodeAltLeft,
            [kVK_Control]                   = GLFMKeyCodeControlLeft,
            [kVK_RightCommand]              = GLFMKeyCodeMetaRight,
            [kVK_RightShift]                = GLFMKeyCodeShiftRight,
            [kVK_RightOption]               = GLFMKeyCodeAltRight,
            [kVK_RightControl]              = GLFMKeyCodeControlRight,
            [kVK_Function]                  = GLFMKeyCodeFunction,
            [kVK_Help]                      = GLFMKeyCodeInsert,
            [kVK_Home]                      = GLFMKeyCodeHome,
            [kVK_PageUp]                    = GLFMKeyCodePageUp,
            [kVK_ForwardDelete]             = GLFMKeyCodeDelete,
            [kVK_End]                       = GLFMKeyCodeEnd,
            [kVK_PageDown]                  = GLFMKeyCodePageDown,
            [kVK_LeftArrow]                 = GLFMKeyCodeArrowLeft,
            [kVK_RightArrow]                = GLFMKeyCodeArrowRight,
            [kVK_DownArrow]                 = GLFMKeyCodeArrowDown,
            [kVK_UpArrow]                   = GLFMKeyCodeArrowUp,
            [kVK_ANSI_A]                    = GLFMKeyCodeA,
            [kVK_ANSI_B]                    = GLFMKeyCodeB,
            [kVK_ANSI_C]                    = GLFMKeyCodeC,
            [kVK_ANSI_D]                    = GLFMKeyCodeD,
            [kVK_ANSI_E]                    = GLFMKeyCodeE,
            [kVK_ANSI_F]                    = GLFMKeyCodeF,
            [kVK_ANSI_G]                    = GLFMKeyCodeG,
            [kVK_ANSI_H]                    = GLFMKeyCodeH,
            [kVK_ANSI_I]                    = GLFMKeyCodeI,
            [kVK_ANSI_J]                    = GLFMKeyCodeJ,
            [kVK_ANSI_K]                    = GLFMKeyCodeK,
            [kVK_ANSI_L]                    = GLFMKeyCodeL,
            [kVK_ANSI_N]                    = GLFMKeyCodeN,
            [kVK_ANSI_M]                    = GLFMKeyCodeM,
            [kVK_ANSI_O]                    = GLFMKeyCodeO,
            [kVK_ANSI_P]                    = GLFMKeyCodeP,
            [kVK_ANSI_Q]                    = GLFMKeyCodeQ,
            [kVK_ANSI_R]                    = GLFMKeyCodeR,
            [kVK_ANSI_S]                    = GLFMKeyCodeS,
            [kVK_ANSI_T]                    = GLFMKeyCodeT,
            [kVK_ANSI_U]                    = GLFMKeyCodeU,
            [kVK_ANSI_V]                    = GLFMKeyCodeV,
            [kVK_ANSI_W]                    = GLFMKeyCodeW,
            [kVK_ANSI_X]                    = GLFMKeyCodeX,
            [kVK_ANSI_Y]                    = GLFMKeyCodeY,
            [kVK_ANSI_Z]                    = GLFMKeyCodeZ,
            [kVK_ANSI_0]                    = GLFMKeyCode0,
            [kVK_ANSI_1]                    = GLFMKeyCode1,
            [kVK_ANSI_2]                    = GLFMKeyCode2,
            [kVK_ANSI_3]                    = GLFMKeyCode3,
            [kVK_ANSI_4]                    = GLFMKeyCode4,
            [kVK_ANSI_5]                    = GLFMKeyCode5,
            [kVK_ANSI_6]                    = GLFMKeyCode6,
            [kVK_ANSI_7]                    = GLFMKeyCode7,
            [kVK_ANSI_8]                    = GLFMKeyCode8,
            [kVK_ANSI_9]                    = GLFMKeyCode9,
            [kVK_ANSI_Equal]                = GLFMKeyCodeEqual,
            [kVK_ANSI_Minus]                = GLFMKeyCodeMinus,
            [kVK_ANSI_RightBracket]         = GLFMKeyCodeBracketRight,
            [kVK_ANSI_LeftBracket]          = GLFMKeyCodeBracketLeft,
            [kVK_ANSI_Quote]                = GLFMKeyCodeQuote,
            [kVK_ANSI_Semicolon]            = GLFMKeyCodeSemicolon,
            [kVK_ANSI_Backslash]            = GLFMKeyCodeBackslash,
            [kVK_ANSI_Comma]                = GLFMKeyCodeComma,
            [kVK_ANSI_Slash]                = GLFMKeyCodeSlash,
            [kVK_ANSI_Period]               = GLFMKeyCodePeriod,
            [kVK_ANSI_Grave]                = GLFMKeyCodeBackquote,
            [kVK_ANSI_KeypadClear]          = GLFMKeyCodeNumLock,
            [kVK_ANSI_KeypadDecimal]        = GLFMKeyCodeNumpadDecimal,
            [kVK_ANSI_KeypadMultiply]       = GLFMKeyCodeNumpadMultiply,
            [kVK_ANSI_KeypadPlus]           = GLFMKeyCodeNumpadAdd,
            [kVK_ANSI_KeypadDivide]         = GLFMKeyCodeNumpadDivide,
            [kVK_ANSI_KeypadEnter]          = GLFMKeyCodeNumpadEnter,
            [kVK_ANSI_KeypadMinus]          = GLFMKeyCodeNumpadSubtract,
            [kVK_ANSI_KeypadEquals]         = GLFMKeyCodeNumpadEqual,
            [kVK_ANSI_Keypad0]              = GLFMKeyCodeNumpad0,
            [kVK_ANSI_Keypad1]              = GLFMKeyCodeNumpad1,
            [kVK_ANSI_Keypad2]              = GLFMKeyCodeNumpad2,
            [kVK_ANSI_Keypad3]              = GLFMKeyCodeNumpad3,
            [kVK_ANSI_Keypad4]              = GLFMKeyCodeNumpad4,
            [kVK_ANSI_Keypad5]              = GLFMKeyCodeNumpad5,
            [kVK_ANSI_Keypad6]              = GLFMKeyCodeNumpad6,
            [kVK_ANSI_Keypad7]              = GLFMKeyCodeNumpad7,
            [kVK_ANSI_Keypad8]              = GLFMKeyCodeNumpad8,
            [kVK_ANSI_Keypad9]              = GLFMKeyCodeNumpad9,
            [kVK_F1]                        = GLFMKeyCodeF1,
            [kVK_F2]                        = GLFMKeyCodeF2,
            [kVK_F3]                        = GLFMKeyCodeF3,
            [kVK_F4]                        = GLFMKeyCodeF4,
            [kVK_F5]                        = GLFMKeyCodeF5,
            [kVK_F6]                        = GLFMKeyCodeF6,
            [kVK_F7]                        = GLFMKeyCodeF7,
            [kVK_F8]                        = GLFMKeyCodeF8,
            [kVK_F9]                        = GLFMKeyCodeF9,
            [kVK_F10]                       = GLFMKeyCodeF10,
            [kVK_F11]                       = GLFMKeyCodeF11,
            [kVK_F12]                       = GLFMKeyCodeF12,
            [kVK_F13]                       = GLFMKeyCodeF13,
            [kVK_F14]                       = GLFMKeyCodeF14,
            [kVK_F15]                       = GLFMKeyCodeF15,
            [kVK_F16]                       = GLFMKeyCodeF16,
            [kVK_F17]                       = GLFMKeyCodeF17,
            [kVK_F18]                       = GLFMKeyCodeF18,
            [kVK_F19]                       = GLFMKeyCodeF19,
            [kVK_F20]                       = GLFMKeyCodeF20,
            [0x6e]                          = GLFMKeyCodeMenu,
        };

        GLFMKeyCode keyCode = GLFMKeyCodeUnknown;
        if (event.keyCode < sizeof(VK_MAP) / sizeof(*VK_MAP)) {
            keyCode = VK_MAP[event.keyCode];
        }

        int modifiers = 0;
        if ((event.modifierFlags & NSEventModifierFlagShift) != 0) {
            modifiers |= GLFMKeyModifierShift;
        }
        if ((event.modifierFlags & NSEventModifierFlagControl) != 0) {
            modifiers |= GLFMKeyModifierControl;
        }
        if ((event.modifierFlags & NSEventModifierFlagOption) != 0) {
            modifiers |= GLFMKeyModifierAlt;
        }
        if ((event.modifierFlags & NSEventModifierFlagCommand) != 0) {
            modifiers |= GLFMKeyModifierMeta;
        }
        if (self.fnModifier) {
            modifiers |= GLFMKeyModifierFunction;
        }

        handled = self.glfmDisplay->keyFunc(self.glfmDisplay, keyCode, action, modifiers);
    }

    // Send char event
    if (self.glfmDisplay->charFunc &&
        event.type == NSEventTypeKeyDown &&
        (event.modifierFlags & NSEventModifierFlagFunction) == 0 &&
        (event.modifierFlags & NSEventModifierFlagCommand) == 0 &&
        (event.modifierFlags & NSEventModifierFlagControl) == 0) {

        UniChar utf16[4];
        char utf8[4 * 2 + 1] = { 0 };

        // This is like `event.characters`, but considers dead key state and ignores control codes.
        // Sets `utf8` on success.
        if (self.keyboardLayout) {
            UInt32 modifierKeyState = (event.modifierFlags >> 16) & 0xFF;
            UniCharCount utf16Length = 0;
            OSStatus status = UCKeyTranslate(self.keyboardLayout, event.keyCode, kUCKeyActionDown, modifierKeyState,
                                             LMGetKbdType(), 0, &_deadKeyState, sizeof(utf16) / sizeof(*utf16),
                                             &utf16Length, utf16);
            if (status == noErr && utf16Length > 0) {
                UniChar firstChar = utf16[0];
                BOOL isControlCode = (firstChar < 0x20 ||
                                      firstChar == NSDeleteCharacter ||
                                      firstChar == NSLineSeparatorCharacter ||
                                      firstChar == NSParagraphSeparatorCharacter);
                if (!isControlCode) {
                    // Convert to UTF8
                    CFStringRef string = CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault, utf16,
                                                                            (CFIndex)utf16Length, kCFAllocatorNull);
                    CFStringGetCString(string, utf8, sizeof(utf8), kCFStringEncodingUTF8);
                    CFRelease(string);
                }
            }
        }

        if (utf8[0] != '\0') {
            if (self.hideMouseCursorWhileTyping) {
                [NSCursor setHiddenUntilMouseMoves:YES];
            }
            self.glfmDisplay->charFunc(self.glfmDisplay, utf8, 0);
        }
    }
    return handled;
}

- (void)keyDown:(NSEvent *)event {
    GLFMKeyAction action = (event.isARepeat ? GLFMKeyActionRepeated : GLFMKeyActionPressed);
    BOOL handled = [self sendKeyEvent:event withAction:action];
    if (!handled) {
        // Interpret unhandled keys. For now, only interpretation is "Esc" to exit fullscreen.
        if (event.keyCode == kVK_Escape) {
            NSWindow *window = self.glfmViewIfLoaded.window;
            if (window && (window.styleMask & NSWindowStyleMaskFullScreen) != 0) {
                [window toggleFullScreen:nil];
            }
        }
    }
}

- (void)keyUp:(NSEvent *)event {
    [self sendKeyEvent:event withAction:GLFMKeyActionReleased];
}

- (void)flagsChanged:(NSEvent *)event {
    NSEventModifierFlags modifier = 0;
    switch (event.keyCode) {
        case kVK_Command: modifier = NX_DEVICELCMDKEYMASK; break;
        case kVK_Shift: modifier = NX_DEVICELSHIFTKEYMASK; break;
        case kVK_CapsLock: modifier = NSEventModifierFlagCapsLock; break;
        case kVK_Option: modifier = NX_DEVICELALTKEYMASK; break;
        case kVK_Control: modifier = NX_DEVICELCTLKEYMASK; break;
        case kVK_RightCommand: modifier = NX_DEVICERCMDKEYMASK; break;
        case kVK_RightShift: modifier = NX_DEVICERSHIFTKEYMASK; break;
        case kVK_RightOption: modifier = NX_DEVICERALTKEYMASK; break;
        case kVK_RightControl: modifier = NX_DEVICERCTLKEYMASK; break;
        case kVK_Function: modifier = NSEventModifierFlagFunction; break;
        default: modifier = 0; break;
    }
    if (modifier != 0) {
        BOOL pressed = ((event.modifierFlags & modifier) != 0);
        if (event.keyCode == kVK_Function) {
            // The fn key cannot be determined from `modifierFlags` because the
            // `NSEventModifierFlagFunction` flag is also used for other keys, like the arrow keys.
            // So, keep track of its state.
            self.fnModifier = pressed;
        }
        GLFMKeyAction action = pressed ? GLFMKeyActionPressed : GLFMKeyActionReleased;
        [self sendKeyEvent:event withAction:action];
    }
}

- (void)clearActiveKeys {
    self.fnModifier = NO;
    self.deadKeyState = 0;
}

#endif // TARGET_OS_OSX

@end // GLFMViewController

// MARK: - GLFMWindow implementation

@implementation GLFMWindow

@synthesize active = _active;

- (void)setActive:(BOOL)active {
    if (_active != active) {
        _active = active;

#if TARGET_OS_OSX
        GLFMViewController *viewController = (GLFMViewController *)self.contentViewController;
#else
        GLFMViewController *viewController = (GLFMViewController *)self.rootViewController;
#endif
        if (viewController.glfmDisplay && viewController.glfmDisplay->focusFunc) {
            viewController.glfmDisplay->focusFunc(viewController.glfmDisplay, _active);
        }
        if (viewController.isViewLoaded) {
            if (!active) {
                // Draw once when entering the background so that a game can show "paused" state.
                [viewController.glfmView requestRefresh];
                [viewController.glfmView draw];
            }
            viewController.glfmView.animating = active;
        }
#if TARGET_OS_IOS
        if (viewController.isMotionManagerLoaded) {
            [viewController updateMotionManagerActiveState];
        }
#endif
#if TARGET_OS_IOS || TARGET_OS_TV
        [viewController clearTouches];
#endif
#if TARGET_OS_OSX
        [viewController clearActiveKeys];
#endif
    }
}

@end

#if TARGET_OS_IOS || TARGET_OS_TV

// MARK: - UISceneDelegate (iOS, tvOS)

@interface GLFMSceneDelegate : NSObject<UISceneDelegate>

@property(nonatomic, strong) GLFMWindow *window;

@end

@implementation GLFMSceneDelegate

@synthesize window;

- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session
      options:(UISceneConnectionOptions *)connectionOptions API_AVAILABLE(ios(13.0), tvos(13.0)) {
    if ([scene isKindOfClass:[UIWindowScene class]]) {
        UIWindowScene *windowScene = (UIWindowScene *)scene;
        self.window = GLFM_AUTORELEASE([[GLFMWindow alloc] initWithWindowScene:windowScene]);
        self.window.rootViewController = GLFM_AUTORELEASE([[GLFMViewController alloc]
                                                           initWithDefaultFrame:self.window.bounds
                                                           contentScale:windowScene.screen.nativeScale]);
        [self.window makeKeyAndVisible];
    }
}

- (void)sceneDidDisconnect:(UIScene *)scene API_AVAILABLE(ios(13.0), tvos(13.0)) {
    self.window.active = NO;
}

- (void)sceneDidBecomeActive:(UIScene *)scene API_AVAILABLE(ios(13.0), tvos(13.0)) {
    self.window.active = YES;
}

- (void)sceneWillResignActive:(UIScene *)scene API_AVAILABLE(ios(13.0), tvos(13.0)) {
    self.window.active = NO;
}

- (void)sceneWillEnterForeground:(UIScene *)scene API_AVAILABLE(ios(13.0), tvos(13.0)) {
    self.window.active = YES;
}

- (void)sceneDidEnterBackground:(UIScene *)scene API_AVAILABLE(ios(13.0), tvos(13.0)) {
    self.window.active = NO;
}

- (void)dealloc {
    self.window = nil;
#if !__has_feature(objc_arc)
    [super dealloc];
#endif
}

@end

// MARK: - GLFMAppDelegate (iOS, tvOS)

@interface GLFMAppDelegate : NSObject<UIApplicationDelegate>

@property(nonatomic, strong) GLFMWindow *window; // window for iOS 12 and older

@end

@implementation GLFMAppDelegate

@synthesize window;

- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary<UIApplicationLaunchOptionsKey, id> *)launchOptions {
    if (@available(iOS 13, tvOS 13, *)) {
        // Create the window in GLFMSceneDelegate
    } else {
        self.window = GLFM_AUTORELEASE([[GLFMWindow alloc] init]);
        if (self.window.bounds.size.width <= (CGFloat)0.0 || self.window.bounds.size.height <= (CGFloat)0.0) {
            // Set UIWindow frame for iOS 8.
            // On iOS 9, the UIWindow frame may be different than the UIScreen bounds for iPad's
            // Split View or Slide Over.
            self.window.frame = [[UIScreen mainScreen] bounds];
        }
        self.window.rootViewController = GLFM_AUTORELEASE([[GLFMViewController alloc]
                                                           initWithDefaultFrame:self.window.bounds
                                                           contentScale:[UIScreen mainScreen].nativeScale]);
        [self.window makeKeyAndVisible];
    }
    return YES;
}

- (UISceneConfiguration *)application:(UIApplication *)application
configurationForConnectingSceneSession:(UISceneSession *)connectingSceneSession
                              options:(UISceneConnectionOptions *)options API_AVAILABLE(ios(13.0), tvos(13.0)) {
    UISceneConfiguration *sceneConfig = GLFM_AUTORELEASE([[UISceneConfiguration alloc]
                                                          initWithName:@"GLFM Configuration"
                                                          sessionRole:connectingSceneSession.role]);
    sceneConfig.delegateClass = [GLFMSceneDelegate class];
    return sceneConfig;
}

- (void)applicationWillResignActive:(UIApplication *)application {
    self.window.active = NO;
}

- (void)applicationDidEnterBackground:(UIApplication *)application {
    self.window.active = NO;
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
    self.window.active = YES;
}

- (void)applicationDidBecomeActive:(UIApplication *)application {
    self.window.active = YES;
}

- (void)applicationWillTerminate:(UIApplication *)application {
    self.window.active = NO;
}

- (void)dealloc {
    self.window = nil;
#if !__has_feature(objc_arc)
    [super dealloc];
#endif
}

@end

#endif // TARGET_OS_IOS || TARGET_OS_TV

#if TARGET_OS_OSX

// MARK: - GLFMAppDelegate (macOS)

@interface GLFMAppDelegate : NSObject <NSApplicationDelegate, NSWindowDelegate>

@property(nonatomic, strong) GLFMWindow *window;

@end

@implementation GLFMAppDelegate

@synthesize window;

- (void)createDefaultMenuWithAppName:(NSString *)appName {
    NSMenu *appMenu = GLFM_AUTORELEASE([NSMenu new]);
    NSApp.mainMenu = GLFM_AUTORELEASE([NSMenu new]);
    NSApp.servicesMenu = GLFM_AUTORELEASE([NSMenu new]);
    NSApp.windowsMenu = GLFM_AUTORELEASE([[NSMenu alloc] initWithTitle:NSLocalizedString(@"Window", nil)]);

    // App Menu
    [NSApp.mainMenu addItemWithTitle:@"" action:nil keyEquivalent:@""].submenu = appMenu;
    [appMenu addItemWithTitle:[NSString stringWithFormat:NSLocalizedString(@"About %@", nil), appName]
                       action:@selector(orderFrontStandardAboutPanel:)
                keyEquivalent:@""];
    [appMenu addItem:[NSMenuItem separatorItem]];
    [appMenu addItemWithTitle:NSLocalizedString(@"Services", nil)
                       action:nil
                keyEquivalent:@""].submenu = NSApp.servicesMenu;
    [appMenu addItem:[NSMenuItem separatorItem]];
    [appMenu addItemWithTitle:[NSString stringWithFormat:NSLocalizedString(@"Hide %@", nil), appName]
                       action:@selector(hide:)
                keyEquivalent:@"h"];
    [appMenu addItemWithTitle:NSLocalizedString(@"Hide Others", nil)
                       action:@selector(hideOtherApplications:)
                keyEquivalent:@"h"].keyEquivalentModifierMask = NSEventModifierFlagOption | NSEventModifierFlagCommand;
    [appMenu addItemWithTitle:NSLocalizedString(@"Show All", nil)
                       action:@selector(unhideAllApplications:)
                keyEquivalent:@""];
    [appMenu addItem:[NSMenuItem separatorItem]];
    [appMenu addItemWithTitle:[NSString stringWithFormat:NSLocalizedString(@"Quit %@", nil), appName]
                       action:@selector(terminate:)
                keyEquivalent:@"q"];

    // Window Menu
    [NSApp.mainMenu addItemWithTitle:@"" action:nil keyEquivalent:@""].submenu = NSApp.windowsMenu;
    [NSApp.windowsMenu addItemWithTitle:NSLocalizedString(@"Minimize", nil)
                                 action:@selector(performMiniaturize:)
                          keyEquivalent:@"m"];
    [NSApp.windowsMenu addItemWithTitle:NSLocalizedString(@"Zoom", nil)
                                 action:@selector(performZoom:)
                          keyEquivalent:@""];
}

- (void)applicationWillFinishLaunching:(NSNotification *)notification {
    // App name (used for menu bar and window title) is "CFBundleName" or the process name.
    NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];
    NSString *appName = infoDictionary[@"CFBundleName"];
    if (!appName || appName.length == 0) {
        appName = [[NSProcessInfo processInfo] processName];
    }

    // Window style: Closable, miniaturizable, resizable.
    NSWindowStyleMask windowStyle = (NSWindowStyleMaskTitled | NSWindowStyleMaskClosable |
                                     NSWindowStyleMaskMiniaturizable | NSWindowStyleMaskResizable);

    // Create NSWindow centered on the main screen, One-half screen size.
    double width, height, scale;
    glfm__getDefaultDisplaySize(NULL, &width, &height, &scale);
    CGRect screenFrame = [NSScreen mainScreen].frame;
    CGRect contentFrame;
    contentFrame.origin.x = screenFrame.origin.x + screenFrame.size.width / 2 - width / 2;
    contentFrame.origin.y = screenFrame.origin.y + screenFrame.size.height / 2 - height / 2;
    contentFrame.size.width = width;
    contentFrame.size.height = height;
    self.window = GLFM_AUTORELEASE([[GLFMWindow alloc] initWithContentRect:contentFrame
                                                                 styleMask:windowStyle
                                                                   backing:NSBackingStoreBuffered
                                                                     defer:NO]);
    self.window.title = appName;
    //self.window.titlebarSeparatorStyle = NSTitlebarSeparatorStyleNone; // Make the topmost row of the view visible
    self.window.excludedFromWindowsMenu = YES; // Single-window app
    self.window.tabbingMode = NSWindowTabbingModeDisallowed; // No tabs
    self.window.backgroundColor = [NSColor blackColor]; // Remove background vibrancy/NSVisualEffectView
    self.window.restorable = NO;
    self.window.releasedWhenClosed = NO;
    self.window.acceptsMouseMovedEvents = YES;
    self.window.delegate = self;

    CGRect defaultFrame = [self.window contentRectForFrameRect:self.window.frame];
    defaultFrame.origin = CGPointZero;
    GLFMViewController *glfmViewController = GLFM_AUTORELEASE([[GLFMViewController alloc]
                                                               initWithDefaultFrame:defaultFrame
                                                               contentScale:(CGFloat)scale]);

    // Set the contentViewController and call glfmMain() (in loadView).
    self.window.contentViewController = glfmViewController;
    if (!self.window.contentViewController.isViewLoaded) {
        [self.window.contentViewController loadView];
    }

    // Check if window size should change (due to orientation setting)
    glfm__getDefaultDisplaySize(glfmViewController.glfmDisplay, &width, &height, &scale);
    if (!glfm__isCGFloatEqual(width, (double)contentFrame.size.width) ||
        glfm__isCGFloatEqual(height, (double)contentFrame.size.height)) {
        contentFrame.origin.x = screenFrame.origin.x + screenFrame.size.width / 2 - width / 2;
        contentFrame.origin.y = screenFrame.origin.y + screenFrame.size.height / 2 - height / 2;
        contentFrame.size.width = width;
        contentFrame.size.height = height;
#if 0
        // Useful for creating example app icons
        contentFrame.size.width = 128;
        contentFrame.size.height = 128;
        [self.window setStyleMask:NSWindowStyleMaskBorderless];
#endif
        [self.window setFrame:[self.window frameRectForContentRect:contentFrame] display:NO];
    }

    // Create default menu if one wasn't created in glfmMain()
    if (!NSApp.mainMenu) {
        [self createDefaultMenuWithAppName:appName];
    }

    // Enter fullscreen if requested
    glfm__displayChromeUpdated(glfmViewController.glfmDisplay);
}

- (BOOL)applicationSupportsSecureRestorableState:(NSApplication *) app {
    // Workaround for warning "Secure coding is automatically enabled for restorable state!"
    return YES;
}

- (void)applicationDidFinishLaunching:(NSNotification *)notification {
    // Draw first before showing the window
    GLFMViewController *glfmViewController = (GLFMViewController *)self.window.contentViewController;
    [glfmViewController.glfmViewIfLoaded draw];

    if (NSApp.activationPolicy == NSApplicationActivationPolicyRegular) {
        [self.window makeKeyWindow];
        [self.window orderFrontRegardless];
    } else {
        // Executable-only (unbundled) app
        [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];
        [self.window makeKeyWindow];
        [self.window orderFrontRegardless];
        [NSApp activateIgnoringOtherApps:YES];
    }
}

- (void)applicationWillResignActive:(NSNotification *)notification {
    self.window.active = NO;
}

- (void)applicationDidBecomeActive:(NSNotification *)notification {
    self.window.active = !self.window.miniaturized;
}

- (void)windowWillMiniaturize:(NSNotification *)notification {
    self.window.active = NO;
}

- (void)windowDidDeminiaturize:(NSNotification *)notification  {
    self.window.active = NSApp.active;
}

- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender {
    if (!self.window) {
        return NSTerminateNow;
    }
    // Terminate later in windowWillClose:
    [self.window close];
    return NSTerminateCancel;
}

- (void)windowWillEnterFullScreen:(NSNotification *)notification {
    if (self.window == notification.object) {
        GLFMViewController *glfmViewController = (GLFMViewController *)self.window.contentViewController;
        self.window.styleMask |= NSWindowStyleMaskFullScreen; // Style isn't set before notification
        glfm__displayChromeUpdated(glfmViewController.glfmDisplay);
    }
}

- (void)windowWillExitFullScreen:(NSNotification *)notification {
    if (self.window == notification.object) {
        GLFMViewController *glfmViewController = (GLFMViewController *)self.window.contentViewController;
        self.window.styleMask &= ~NSWindowStyleMaskFullScreen; // Style isn't set before notification
        glfm__displayChromeUpdated(glfmViewController.glfmDisplay);
    }
}

- (void)windowWillClose:(NSNotification *)notification {
    if (self.window == notification.object) {
        self.window.active = NO;
        self.window = nil;
        // Dispatch later, after surfaceDestroyedFunc is called
        dispatch_async(dispatch_get_main_queue(), ^{
            [NSApp terminate:nil];
        });
    }
}

- (void)dealloc {
    self.window = nil;
#if !__has_feature(objc_arc)
    [super dealloc];
#endif
}

@end

#endif // TARGET_OS_OSX

// MARK: - Main

#if TARGET_OS_IOS || TARGET_OS_TV

int main(int argc, char *argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([GLFMAppDelegate class]));
    }
}

#else

int main(int argc, const char * argv[]) {
    (void)argc;
    (void)argv;
    @autoreleasepool {
        // Create the sharedApplication instance from "NSPrincipalClass"
        NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];
        NSString *principalClassName = infoDictionary[@"NSPrincipalClass"];
        Class principalClass = NSClassFromString(principalClassName);
        if ([principalClass respondsToSelector:@selector(sharedApplication)]) {
            [principalClass sharedApplication];
        } else {
            [NSApplication sharedApplication];
        }

        // Add SIGTERM handler
        // The SIGTERM signal is received when the user selects Quit from the dock icon menu.
        // Note, this handler will not work when debugging.
        signal(SIGTERM, SIG_IGN);
        dispatch_source_t sigtermSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGTERM, 0,
                                                                 dispatch_get_main_queue());
        dispatch_source_set_event_handler(sigtermSource, ^{
            [NSApp terminate:nil];
        });
        dispatch_resume(sigtermSource);

        // Set the delegate and run
        GLFMAppDelegate *delegate = [GLFMAppDelegate new];
        [NSApp setDelegate:delegate];
        [NSApp run];
        GLFM_RELEASE(delegate);
    }
    return 0;
}

#endif // TARGET_OS_OSX

// MARK: - GLFM private functions

static void glfm__getDefaultDisplaySize(const GLFMDisplay *display,
                                        double *width, double *height, double *scale) {
#if TARGET_OS_IOS || TARGET_OS_TV
    (void)display;
    CGSize size = UIScreen.mainScreen.bounds.size;
    *width = (double)size.width;
    *height = (double)size.height;
    *scale = UIScreen.mainScreen.nativeScale;
#else
    NSScreen *screen = [NSScreen mainScreen];
    *scale = screen.backingScaleFactor;

    // Create a window half the size of the screen.
    // If portrait orientation (but not landscape) is specified, use a portrait-sized default window.
    GLFMInterfaceOrientation supportedOrientations = (!display ? GLFMInterfaceOrientationUnknown :
                                                      display->supportedOrientations);
    if (((supportedOrientations & GLFMInterfaceOrientationPortrait) != 0 ||
         (supportedOrientations & GLFMInterfaceOrientationPortraitUpsideDown) != 0) &&
        (supportedOrientations & GLFMInterfaceOrientationLandscapeLeft) == 0 &&
        (supportedOrientations & GLFMInterfaceOrientationLandscapeRight) == 0) {
        *width = screen.frame.size.height / 2;
        *height = screen.frame.size.width / 2;
    } else {
        *width = screen.frame.size.width / 2;
        *height = screen.frame.size.height / 2;
    }
#endif
}

/// Get drawable size in pixels from display dimensions in points.
static void glfm__getDrawableSize(double displayWidth, double displayHeight, double displayScale,
                                  int *width, int *height) {
    int newDrawableWidth = (int)(displayWidth * displayScale);
    int newDrawableHeight = (int)(displayHeight * displayScale);

#if TARGET_OS_IOS
    // On the iPhone 6 when "Display Zoom" is set, the size will be incorrect.
    if (glfm__isCGFloatEqual(displayScale, (CGFloat)2.343750)) {
        if (newDrawableWidth == 750 && newDrawableHeight == 1331) {
            newDrawableHeight = 1334;
        } else if (newDrawableWidth == 1331 && newDrawableHeight == 750) {
            newDrawableWidth = 1334;
        }
    }
#endif

    if (width) *width = newDrawableWidth;
    if (height) *height = newDrawableHeight;
}

static void glfm__displayChromeUpdated(GLFMDisplay *display) {
    if (display && display->platformData) {
#if TARGET_OS_IOS
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        [viewController.glfmViewIfLoaded requestRefresh];
        [viewController setNeedsStatusBarAppearanceUpdate];
        if (@available(iOS 11, *)) {
            [viewController setNeedsUpdateOfScreenEdgesDeferringSystemGestures];
        }
#elif TARGET_OS_OSX
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        NSWindow *window = viewController.glfmViewIfLoaded.window;
        if (window) {
            // This might not make sense and will probably change.
            // * GLFMUserInterfaceChromeNavigation: Full content view (title bar overlays content).
            // * GLFMUserInterfaceChromeNavigationAndStatusBar: Title bar outside content view (no overlay).
            // * GLFMUserInterfaceChromeNone: No window decor, but user can drag title bar area to move the window.
            // * GLFMUserInterfaceChromeNone when window is fullscreen: No menu bar.

            // Prevent title bar buttons from being tapped when their alpha is zero
            BOOL hideButtons = ((window.styleMask & NSWindowStyleMaskFullScreen) == 0 &&
                                display->uiChrome == GLFMUserInterfaceChromeNone);
            NSView *titleBarView = [window standardWindowButton:NSWindowCloseButton].superview;
            for (NSView *button in titleBarView.subviews) {
                if ([button isKindOfClass:[NSControl class]]) {
                    [button setHidden:hideButtons];
                }
            }

            // Hide/Show title bar
            if (@available(macOS 11, *)) {
                titleBarView = titleBarView.superview;
            }
            if (window.styleMask & NSWindowStyleMaskFullScreen) {
                titleBarView.alphaValue = (CGFloat)1.0;
                [NSMenu setMenuBarVisible:display->uiChrome != GLFMUserInterfaceChromeNone];
            } else {
                [NSMenu setMenuBarVisible:YES];
                if (display->uiChrome == GLFMUserInterfaceChromeNone) {
                    if ((window.styleMask & NSWindowStyleMaskFullSizeContentView) == 0) {
                        titleBarView.alphaValue = (CGFloat)0.0;
                    } else {
                        [[titleBarView animator] setAlphaValue:(CGFloat)0.0];
                    }
                } else {
                    [[titleBarView animator] setAlphaValue:(CGFloat)1.0];
                }

                // Enable/disable full-size content view (under the title bar)
                if (display->uiChrome == GLFMUserInterfaceChromeNavigationAndStatusBar) {
                    window.styleMask &= ~NSWindowStyleMaskFullSizeContentView;
                } else {
                    window.styleMask |= NSWindowStyleMaskFullSizeContentView;
                }
            }
        }
#endif
    }
}

static void glfm__sensorFuncUpdated(GLFMDisplay *display) {
#if TARGET_OS_IOS
    if (display) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        [viewController updateMotionManagerActiveState];
    }
#else
    (void)display;
#endif
}

// MARK: - GLFM public functions

double glfmGetTime(void) {
    return CACurrentMediaTime();
}

GLFMProc glfmGetProcAddress(const char *functionName) {
    static void *handle = NULL;
    if (!handle) {
        handle = dlopen(NULL, RTLD_LAZY);
    }
    return handle ? (GLFMProc)dlsym(handle, functionName) : NULL;
}

void glfmSwapBuffers(GLFMDisplay *display) {
    if (display && display->platformData) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        [viewController.glfmViewIfLoaded swapBuffers];
    }
}

void glfmSetSupportedInterfaceOrientation(GLFMDisplay *display, GLFMInterfaceOrientation supportedOrientations) {
    if (display) {
        if (display->supportedOrientations != supportedOrientations) {
            display->supportedOrientations = supportedOrientations;
#if TARGET_OS_IOS
            GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
            if (@available(iOS 16, *)) {
                [viewController setNeedsUpdateOfSupportedInterfaceOrientations];
            } else if (viewController.isViewLoaded && viewController.view.window) {
                // HACK: Notify that the value of supportedInterfaceOrientations has changed
                [viewController.glfmView requestRefresh];
                UIViewController *tempViewController = GLFM_AUTORELEASE([[UIViewController alloc] init]);
                tempViewController.view = GLFM_AUTORELEASE([[UIView alloc] init]);
                [viewController presentViewController:tempViewController animated:NO completion:^{
                    [viewController dismissViewControllerAnimated:NO completion:NULL];
                }];
            }
#endif
        }
    }
}

GLFMInterfaceOrientation glfmGetInterfaceOrientation(const GLFMDisplay *display) {
    (void)display;
#if TARGET_OS_IOS
    UIInterfaceOrientation orientation = [[UIApplication sharedApplication] statusBarOrientation];
    switch (orientation) {
        case UIInterfaceOrientationPortrait:
            return GLFMInterfaceOrientationPortrait;
        case UIInterfaceOrientationPortraitUpsideDown:
            return GLFMInterfaceOrientationPortraitUpsideDown;
        case UIInterfaceOrientationLandscapeLeft:
            return GLFMInterfaceOrientationLandscapeLeft;
        case UIInterfaceOrientationLandscapeRight:
            return GLFMInterfaceOrientationLandscapeRight;
        case UIInterfaceOrientationUnknown: default:
            return GLFMInterfaceOrientationUnknown;
    }
#else
    return GLFMInterfaceOrientationUnknown;
#endif
}

void glfmGetDisplaySize(const GLFMDisplay *display, int *width, int *height) {
    if (display && display->platformData) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        if (viewController.isViewLoaded) {
            if (width) *width = viewController.glfmView.drawableWidth;
            if (height) *height = viewController.glfmView.drawableHeight;
        } else {
            double displayWidth, displayHeight, displayScale;
            glfm__getDefaultDisplaySize(display, &displayWidth, &displayHeight, &displayScale);
            glfm__getDrawableSize(displayWidth, displayHeight, displayScale, width, height);
        }
    } else {
        if (width) *width = 0;
        if (height) *height = 0;
    }
}

double glfmGetDisplayScale(const GLFMDisplay *display) {
#if TARGET_OS_OSX
    NSWindow *window = nil;
    if (display && display->platformData) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        window = viewController.glfmViewIfLoaded.window;
    }
    return window ? window.backingScaleFactor : [NSScreen mainScreen].backingScaleFactor;
#else
    (void)display;
    return (double)[UIScreen mainScreen].nativeScale;
#endif
}

void glfmGetDisplayChromeInsets(const GLFMDisplay *display, double *top, double *right,
                                double *bottom, double *left) {
    if (display && display->platformData) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        if (!viewController.isViewLoaded) {
            if (top) *top = 0.0;
            if (right) *right = 0.0;
            if (bottom) *bottom = 0.0;
            if (left) *left = 0.0;
        } else if (@available(iOS 11, tvOS 11, macOS 11, *)) {
#if TARGET_OS_IOS || TARGET_OS_TV
            UIEdgeInsets insets = viewController.view.safeAreaInsets;
            if (top) *top = (double)(insets.top * viewController.view.contentScaleFactor);
            if (right) *right = (double)(insets.right * viewController.view.contentScaleFactor);
            if (bottom) *bottom = (double)(insets.bottom * viewController.view.contentScaleFactor);
            if (left) *left = (double)(insets.left * viewController.view.contentScaleFactor);
#else
            // NOTE: This has not been tested.
            // Run glfm_test_pattern fullscreen on a 2021-2022 MacBook Pro/Air with a notch.
            NSEdgeInsets insets = viewController.view.safeAreaInsets;
            if (top) *top = (double)(insets.top * viewController.view.layer.contentsScale);
            if (right) *right = (double)(insets.right * viewController.view.layer.contentsScale);
            if (bottom) *bottom = (double)(insets.bottom * viewController.view.layer.contentsScale);
            if (left) *left = (double)(insets.left * viewController.view.layer.contentsScale);
#endif
        } else {
            if (top) {
#if TARGET_OS_IOS
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
                if (![viewController prefersStatusBarHidden]) {
                    *top = (double)([UIApplication sharedApplication].statusBarFrame.size.height *
                                    viewController.view.contentScaleFactor);
                } else {
                    *top = 0.0;
                }
#pragma clang diagnostic pop
#else
                *top = 0.0;
#endif
            }
            if (right) *right = 0.0;
            if (bottom) *bottom = 0.0;
            if (left) *left = 0.0;
        }
    } else {
        if (top) *top = 0.0;
        if (right) *right = 0.0;
        if (bottom) *bottom = 0.0;
        if (left) *left = 0.0;
    }
}

GLFMRenderingAPI glfmGetRenderingAPI(const GLFMDisplay *display) {
    if (!display || !display->platformData) {
        return GLFMRenderingAPIOpenGLES2;
    }
    GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
    if (viewController.isViewLoaded) {
        return viewController.glfmView.renderingAPI;
    }
    return GLFMRenderingAPIOpenGLES2;
}

bool glfmHasTouch(const GLFMDisplay *display) {
    (void)display;
#if TARGET_OS_IOS || TARGET_OS_TV
    return true;
#else
    return false;
#endif
}

void glfmSetMouseCursor(GLFMDisplay *display, GLFMMouseCursor mouseCursor) {
#if TARGET_OS_OSX
    if (display && display->platformData) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        NSCursor *cursor;
        switch (mouseCursor) {
            case GLFMMouseCursorAuto:
            case GLFMMouseCursorDefault:
            default:
                cursor = NSCursor.arrowCursor;
                break;
            case GLFMMouseCursorPointer:
                cursor = NSCursor.pointingHandCursor;
                break;
            case GLFMMouseCursorCrosshair:
                cursor = NSCursor.crosshairCursor;
                break;
            case GLFMMouseCursorText:
                cursor = NSCursor.IBeamCursor;
                break;
            case GLFMMouseCursorVerticalText:
                cursor = NSCursor.IBeamCursorForVerticalLayout;
                break;
            case GLFMMouseCursorNone:
                cursor = viewController.transparentCursor;
                break;
        }
        if (viewController.currentCursor != cursor) {
            viewController.currentCursor = cursor;
            GLFMWindow *window = (GLFMWindow *)viewController.glfmViewIfLoaded.window;
            if (viewController.mouseInside && window.active) {
                [cursor set];
            }
        }
        [NSCursor setHiddenUntilMouseMoves:NO];
        viewController.hideMouseCursorWhileTyping = (mouseCursor == GLFMMouseCursorAuto ||
                                                     mouseCursor == GLFMMouseCursorText ||
                                                     mouseCursor == GLFMMouseCursorVerticalText);
    }
#elif TARGET_OS_IOS
    if (@available(iOS 13.4, *)) {
        if (display && display->platformData) {
            GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
            if (viewController.mouseCursor != mouseCursor) {
                viewController.mouseCursor = mouseCursor;
                NSArray<id<UIInteraction>> *interactions = viewController.viewIfLoaded.interactions;
                if (interactions) {
                    for (id<UIInteraction> interaction in interactions) {
                        if ([interaction isKindOfClass:[UIPointerInteraction class]]) {
                            UIPointerInteraction *pointerInteraction = (UIPointerInteraction *)interaction;
                            [pointerInteraction invalidate];
                        }
                    }
                }
            }
        }
    }
#else
    (void)display;
    (void)mouseCursor;
    // Do nothing
#endif
}

void glfmSetMultitouchEnabled(GLFMDisplay *display, bool multitouchEnabled) {
#if TARGET_OS_IOS
    if (display) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        viewController.multipleTouchEnabled = (BOOL)multitouchEnabled;
        viewController.glfmViewIfLoaded.multipleTouchEnabled = (BOOL)multitouchEnabled;
    }
#else
    (void)display;
    (void)multitouchEnabled;
#endif
}

bool glfmGetMultitouchEnabled(const GLFMDisplay *display) {
#if TARGET_OS_IOS
    if (!display) {
        return false;
    }
    GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
    return viewController.multipleTouchEnabled;
#else
    (void)display;
    return false;
#endif
}

bool glfmHasVirtualKeyboard(const GLFMDisplay *display) {
    (void)display;
#if TARGET_OS_IOS
    return true;
#else
    return false;
#endif
}

void glfmSetKeyboardVisible(GLFMDisplay *display, bool visible) {
#if TARGET_OS_IOS
    if (display) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        [viewController resignFirstResponder];
        viewController.keyboardRequested = visible;
        [viewController becomeFirstResponder];
    }
#else
    (void)display;
    (void)visible;
#endif
}

bool glfmIsKeyboardVisible(const GLFMDisplay *display) {
#if TARGET_OS_IOS
    if (!display) {
        return false;
    }
    GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
    return viewController.keyboardRequested;
#else
    (void)display;
    return false;
#endif
}

bool glfmIsSensorAvailable(const GLFMDisplay *display, GLFMSensor sensor) {
#if TARGET_OS_IOS
    if (display) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        switch (sensor) {
            case GLFMSensorAccelerometer:
                return (viewController.motionManager.deviceMotionAvailable &&
                        viewController.motionManager.accelerometerAvailable);
            case GLFMSensorMagnetometer:
                return (viewController.motionManager.deviceMotionAvailable &&
                        viewController.motionManager.magnetometerAvailable);
            case GLFMSensorGyroscope:
                return (viewController.motionManager.deviceMotionAvailable &&
                        viewController.motionManager.gyroAvailable);
            case GLFMSensorRotationMatrix:
                return (viewController.motionManager.deviceMotionAvailable &&
                        ([CMMotionManager availableAttitudeReferenceFrames] &
                         CMAttitudeReferenceFrameXMagneticNorthZVertical));
            default:
                return false;
        }
    }
    return false;
#else
    (void)display;
    (void)sensor;
    return false;
#endif
}

bool glfmIsHapticFeedbackSupported(const GLFMDisplay *display) {
    (void)display;
#if TARGET_OS_IOS
    if (@available(iOS 13, *)) {
        return [CHHapticEngine capabilitiesForHardware].supportsHaptics;
    }
#endif
    return false;
}

void glfmPerformHapticFeedback(GLFMDisplay *display, GLFMHapticFeedbackStyle style) {
    (void)display;
#if TARGET_OS_IOS
    if (@available(iOS 10, *)) {
        UIImpactFeedbackStyle uiStyle;
        switch (style) {
            case GLFMHapticFeedbackLight: default:
                uiStyle = UIImpactFeedbackStyleLight;
                break;
            case GLFMHapticFeedbackMedium:
                uiStyle = UIImpactFeedbackStyleMedium;
                break;
            case GLFMHapticFeedbackHeavy:
                uiStyle = UIImpactFeedbackStyleHeavy;
                break;
        }
        UIImpactFeedbackGenerator *generator = [[UIImpactFeedbackGenerator alloc] initWithStyle:uiStyle];
        [generator impactOccurred];
        GLFM_RELEASE(generator);
    }
#else
    (void)style;
#endif
}

#if TARGET_OS_TV

bool glfmHasClipboardText(const GLFMDisplay *display) {
    (void)display;
    return false;
}

void glfmRequestClipboardText(GLFMDisplay *display, GLFMClipboardTextFunc clipboardTextFunc) {
    (void)display;
    if (clipboardTextFunc) {
        clipboardTextFunc(display, NULL);
    }
}

bool glfmSetClipboardText(GLFMDisplay *display, const char *string) {
    (void)display;
    (void)string;
    return false;
}

#else

bool glfmHasClipboardText(const GLFMDisplay *display) {
    (void)display;
#if TARGET_OS_OSX
    NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
    return [pasteboard.types containsObject:NSPasteboardTypeString];
#else
    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
    return [pasteboard hasStrings];
#endif
}

void glfmRequestClipboardText(GLFMDisplay *display, GLFMClipboardTextFunc clipboardTextFunc) {
    if (!clipboardTextFunc) {
        return;
    }

    // Run in a background thread because the text may be retrieved from the network (iCloud clipboard)
    // or show a confirmation dialog on iOS.
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSString *text = nil;
        if (glfmHasClipboardText(display)) {
#if TARGET_OS_OSX
            NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
            text = [pasteboard stringForType:NSPasteboardTypeString];
#else
            UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
            text = pasteboard.string;
#endif
        }
        dispatch_async(dispatch_get_main_queue(), ^{
            clipboardTextFunc(display, text.UTF8String);
        });
    });
}

bool glfmSetClipboardText(GLFMDisplay *display, const char *string) {
    (void)display;
    @autoreleasepool {
        NSString *text = string ? [NSString stringWithUTF8String:string] : nil;
        if (!text) {
            return false;
        }
#if TARGET_OS_OSX
        NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
        [pasteboard declareTypes:@[NSPasteboardTypeString] owner:nil];
        return ([pasteboard setString:text forType:NSPasteboardTypeString] == YES);
#else
        [UIPasteboard generalPasteboard].string = text;
        return true;
#endif
    }
}

#endif // !TARGET_OS_TV

// MARK: - Apple-specific functions

bool glfmIsMetalSupported(const GLFMDisplay *display) {
#if GLFM_INCLUDE_METAL
    if (display) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        return (viewController.metalDevice != nil);
    }
#endif
    return false;
}

void *glfmGetMetalView(const GLFMDisplay *display) {
#if GLFM_INCLUDE_METAL
    if (display) {
        GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
        UIView<GLFMView> *view = viewController.glfmViewIfLoaded;
        if ([view isKindOfClass:[MTKView class]]) {
            return (__bridge void *)view;
        }
    }
#endif
    return NULL;
}

void *glfmGetViewController(const GLFMDisplay *display) {
    if (!display) {
        return NULL;
    }
    GLFMViewController *viewController = (__bridge GLFMViewController *)display->platformData;
    return (__bridge void *)viewController;
}

#endif // __APPLE__

```

`src/glfm_emscripten.c`:

```c
// GLFM
// https://github.com/brackeen/glfm

#if defined(__EMSCRIPTEN__)

#include "glfm.h"

#include <EGL/egl.h>
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#include <math.h>
#include <stdlib.h>
#include <sys/time.h>
#include <time.h>

#include "glfm_internal.h"

#ifdef NDEBUG
#  define GLFM_LOG(...) do { } while (0)
#else
#  define GLFM_LOG(...) do { printf("%.3f: ", glfmGetTime()); printf(__VA_ARGS__); printf("\n"); } while (0)
#endif

#define GLFM_MAX_ACTIVE_TOUCHES 10

// If 1, test if keyboard event arrays are sorted.
#define GLFM_TEST_KEYBOARD_EVENT_ARRAYS 0

#ifdef EM_JS_DEPS
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmissing-variable-declarations"
#pragma clang diagnostic ignored "-Wextra-semi"
EM_JS_DEPS(glfm_deps, "$stringToUTF8,$lengthBytesUTF8,$UTF8ToString");
#pragma clang diagnostic pop
#endif

typedef struct {
    long identifier;
    bool active;
} GLFMActiveTouch;

typedef struct {
    bool multitouchEnabled;
    int32_t width;
    int32_t height;
    double scale;
    GLFMRenderingAPI renderingAPI;

    bool mouseDown;
    GLFMActiveTouch activeTouches[GLFM_MAX_ACTIVE_TOUCHES];

    bool isVisible;
    bool isFocused;
    bool refreshRequested;

    GLFMInterfaceOrientation orientation;
} GLFMPlatformData;

// MARK: - GLFM private functions

#if GLFM_TEST_KEYBOARD_EVENT_ARRAYS

static bool glfm__listIsSorted(const char *list[], size_t size) {
    for (size_t i = 1; i < size; i++) {
        if (strcmp(list[i - 1], list[i]) > 0) {
            return false;
        }
    }
    return true;
}

#endif

static int glfm__sortedListSearch(const char *list[], size_t size, const char *word) {
    int left = 0;
    int right = (int)size - 1;

    while (left <= right) {
        int index = (left + right) / 2;
        int result = strcmp(list[index], word);
        if (result > 0) {
            right = index - 1;
        } else if (result < 0) {
            left = index + 1;
        } else {
            return index;
        }
    }
    return -1;
}

static void glfm__clearActiveTouches(GLFMPlatformData *platformData) {
    for (int i = 0; i < GLFM_MAX_ACTIVE_TOUCHES; i++) {
        platformData->activeTouches[i].active = false;
    }
}

static void glfm__displayChromeUpdated(GLFMDisplay *display) {
    (void)display;
}

void glfm__sensorFuncUpdated(GLFMDisplay *display) {
    (void)display;
    // TODO: Sensors
}

EMSCRIPTEN_KEEPALIVE extern
void glfm__requestClipboardTextCallback(GLFMDisplay *display,
                                        GLFMClipboardTextFunc clipboardTextFunc, const char *text);

void glfm__requestClipboardTextCallback(GLFMDisplay *display,
                                        GLFMClipboardTextFunc clipboardTextFunc, const char *text) {
    if (text && text[0] != '\0') {
        clipboardTextFunc(display, text);
    } else {
        clipboardTextFunc(display, NULL);
    }
}

// MARK: - GLFM public functions

double glfmGetTime(void) {
    return emscripten_get_now() / 1000.0;
}

void glfmSwapBuffers(GLFMDisplay *display) {
    (void)display;
    // Do nothing; swap is implicit
}

void glfmSetSupportedInterfaceOrientation(GLFMDisplay *display, GLFMInterfaceOrientation supportedOrientations) {
    if (display->supportedOrientations != supportedOrientations) {
        display->supportedOrientations = supportedOrientations;

        bool portraitRequested = (supportedOrientations & (GLFMInterfaceOrientationPortrait |
                                                           GLFMInterfaceOrientationPortraitUpsideDown));
        bool landscapeRequested = (supportedOrientations & GLFMInterfaceOrientationLandscape);
        if (portraitRequested && landscapeRequested) {
            emscripten_lock_orientation(EMSCRIPTEN_ORIENTATION_PORTRAIT_PRIMARY |
                                        EMSCRIPTEN_ORIENTATION_PORTRAIT_SECONDARY |
                                        EMSCRIPTEN_ORIENTATION_LANDSCAPE_PRIMARY |
                                        EMSCRIPTEN_ORIENTATION_LANDSCAPE_SECONDARY);
        } else if (landscapeRequested) {
            emscripten_lock_orientation(EMSCRIPTEN_ORIENTATION_LANDSCAPE_PRIMARY |
                                        EMSCRIPTEN_ORIENTATION_LANDSCAPE_SECONDARY);
        } else {
            emscripten_lock_orientation(EMSCRIPTEN_ORIENTATION_PORTRAIT_PRIMARY |
                                        EMSCRIPTEN_ORIENTATION_PORTRAIT_SECONDARY);
        }
    }
}

GLFMInterfaceOrientation glfmGetInterfaceOrientation(const GLFMDisplay *display) {
    (void)display;

    EmscriptenOrientationChangeEvent orientationStatus;
    emscripten_get_orientation_status(&orientationStatus);
    int orientation = orientationStatus.orientationIndex;
    int angle = orientationStatus.orientationAngle;

    GLFMInterfaceOrientation result = GLFMInterfaceOrientationUnknown;
    if (orientation == EMSCRIPTEN_ORIENTATION_PORTRAIT_PRIMARY) {
        result = GLFMInterfaceOrientationPortrait;
    } else if (orientation == EMSCRIPTEN_ORIENTATION_PORTRAIT_SECONDARY) {
        result = GLFMInterfaceOrientationPortraitUpsideDown;
    } else if (orientation == EMSCRIPTEN_ORIENTATION_LANDSCAPE_PRIMARY ||
               orientation == EMSCRIPTEN_ORIENTATION_LANDSCAPE_SECONDARY) {
        if (angle == 0 || angle == 90) {
            result = GLFMInterfaceOrientationLandscapeRight;
        } else if (angle == 180 || angle == 270) {
            result = GLFMInterfaceOrientationLandscapeLeft;
        }
    }
    return result;
}

void glfmGetDisplaySize(const GLFMDisplay *display, int *width, int *height) {
    GLFMPlatformData *platformData = display->platformData;
    if (width) *width = platformData->width;
    if (height) *height = platformData->height;
}

double glfmGetDisplayScale(const GLFMDisplay *display) {
    GLFMPlatformData *platformData = display->platformData;
    return platformData->scale;
}

void glfmGetDisplayChromeInsets(const GLFMDisplay *display, double *top, double *right, double *bottom, double *left) {
    GLFMPlatformData *platformData = display->platformData;
    if (top) {
        *top = platformData->scale * EM_ASM_DOUBLE_V( {
            var htmlStyles = window.getComputedStyle(document.querySelector("html"));
            return ((parseInt(htmlStyles.getPropertyValue("--glfm-chrome-top-old")) || 0) +
                    (parseInt(htmlStyles.getPropertyValue("--glfm-chrome-top")) || 0));
        } );
    }
    if (right) {
        *right = platformData->scale * EM_ASM_DOUBLE_V( {
            var htmlStyles = window.getComputedStyle(document.querySelector("html"));
            return ((parseInt(htmlStyles.getPropertyValue("--glfm-chrome-right-old")) || 0) +
                    (parseInt(htmlStyles.getPropertyValue("--glfm-chrome-right")) || 0));
        } );
    }
    if (bottom) {
        *bottom = platformData->scale * EM_ASM_DOUBLE_V( {
            var htmlStyles = window.getComputedStyle(document.querySelector("html"));
            return ((parseInt(htmlStyles.getPropertyValue("--glfm-chrome-bottom-old")) || 0) +
                    (parseInt(htmlStyles.getPropertyValue("--glfm-chrome-bottom")) || 0));
        } );
    }
    if (left) {
        *left = platformData->scale * EM_ASM_DOUBLE_V( {
            var htmlStyles = window.getComputedStyle(document.querySelector("html"));
            return ((parseInt(htmlStyles.getPropertyValue("--glfm-chrome-left-old")) || 0) +
                    (parseInt(htmlStyles.getPropertyValue("--glfm-chrome-left")) || 0));
        } );
    }
}

GLFMRenderingAPI glfmGetRenderingAPI(const GLFMDisplay *display) {
    GLFMPlatformData *platformData = display->platformData;
    return platformData->renderingAPI;
}

bool glfmHasTouch(const GLFMDisplay *display) {
    (void)display;
    return EM_ASM_INT_V({
        return (('ontouchstart' in window) || (navigator.msMaxTouchPoints > 0));
    });
}

void glfmSetMouseCursor(GLFMDisplay *display, GLFMMouseCursor mouseCursor) {
    (void)display;
    // Make sure the javascript array emCursors is referenced properly
    int emCursor = 0;
    switch (mouseCursor) {
        case GLFMMouseCursorAuto: default:
            emCursor = 0;
            break;
        case GLFMMouseCursorNone:
            emCursor = 1;
            break;
        case GLFMMouseCursorDefault:
            emCursor = 2;
            break;
        case GLFMMouseCursorPointer:
            emCursor = 3;
            break;
        case GLFMMouseCursorCrosshair:
            emCursor = 4;
            break;
        case GLFMMouseCursorText:
            emCursor = 5;
            break;
        case GLFMMouseCursorVerticalText:
            emCursor = 6;
            break;
    }
    EM_ASM_({
        var emCursors = new Array('auto', 'none', 'default', 'pointer', 'crosshair', 'text', 'vertical-text');
        Module['canvas'].style.cursor = emCursors[$0];
    }, emCursor);
}

void glfmSetMultitouchEnabled(GLFMDisplay *display, bool multitouchEnabled) {
    GLFMPlatformData *platformData = display->platformData;
    platformData->multitouchEnabled = multitouchEnabled;
}

bool glfmGetMultitouchEnabled(const GLFMDisplay *display) {
    GLFMPlatformData *platformData = display->platformData;
    return platformData->multitouchEnabled;
}

bool glfmHasVirtualKeyboard(const GLFMDisplay *display) {
    (void)display;
    return false;
}

void glfmSetKeyboardVisible(GLFMDisplay *display, bool visible) {
    (void)display;
    (void)visible;
    // Do nothing
}

bool glfmIsKeyboardVisible(const GLFMDisplay *display) {
    (void)display;
    return false;
}

GLFMProc glfmGetProcAddress(const char *functionName) {
    return eglGetProcAddress(functionName);
}

bool glfmIsSensorAvailable(const GLFMDisplay *display, GLFMSensor sensor) {
    (void)display;
    (void)sensor;
    // TODO: Sensors
    return false;
}

bool glfmIsHapticFeedbackSupported(const GLFMDisplay *display) {
    (void)display;
    return false;
}

void glfmPerformHapticFeedback(GLFMDisplay *display, GLFMHapticFeedbackStyle style) {
    (void)display;
    (void)style;
    // Do nothing
}

bool glfmHasClipboardText(const GLFMDisplay *display) {
    (void)display;
    // Currently, chrome supports navigator.userActivation, but Safari and Firefox do not.
    int result = EM_ASM_INT({
        var hasReadText = (navigator && navigator.clipboard && navigator.clipboard.readText);
        var hasUserActivation = (navigator && navigator.userActivation) ? navigator.userActivation.isActive : true;
        return (hasReadText && hasUserActivation) ? 1 : 0;
    });
    return result != 0;
}

void glfmRequestClipboardText(GLFMDisplay *display, GLFMClipboardTextFunc clipboardTextFunc) {
    if (!clipboardTextFunc) {
        return;
    }
    if (!glfmHasClipboardText(display)) {
        clipboardTextFunc(display, NULL);
        return;
    }

    EM_ASM({
        if (!navigator.clipboard || !navigator.clipboard.readText) {
            _glfm__requestClipboardTextCallback($0, $1, null);
            return;
        }
        var promise = navigator.clipboard.readText();
        if (promise === undefined) {
            _glfm__requestClipboardTextCallback($0, $1, null);
            return;
        }
        var errorCaught = false;
        promise.catch(error => {
            _glfm__requestClipboardTextCallback($0, $1, null);
            errorCaught = true;
        }).then((clipText) => {
            if (clipText === undefined || clipText.length == 0) {
                if (!errorCaught) {
                    _glfm__requestClipboardTextCallback($0, $1, null);
                }
                return;
            }
            var len = lengthBytesUTF8(clipText);
            var buffer = _malloc(len + 1);
            if (buffer) {
                stringToUTF8(clipText, buffer, len + 1);
                _glfm__requestClipboardTextCallback($0, $1, buffer);
                _free(buffer);
            } else {
                _glfm__requestClipboardTextCallback($0, $1, null);
            }
        });
    }, display, clipboardTextFunc);
}

bool glfmSetClipboardText(GLFMDisplay *display, const char *string) {
    (void)display;
    if (!string) {
        return false;
    }
    int result = EM_ASM_INT({
        if (navigator.clipboard && navigator.clipboard.writeText) {
            var text = UTF8ToString($0);
            if (text) {
                navigator.clipboard.writeText(text);
                return 1;
            }
        }
        return 0;
    }, string);
    return result == 1;
}

// MARK: - Platform-specific functions

bool glfmIsMetalSupported(const GLFMDisplay *display) {
    (void)display;
    return false;
}

// MARK: - Emscripten glue

static int glfm__getDisplayWidth(GLFMDisplay *display) {
    (void)display;
    const double width = EM_ASM_DOUBLE_V({
        var canvas = Module['canvas'];
        return canvas.width;
    });
    return (int)(round(width));
}

static int glfm__getDisplayHeight(GLFMDisplay *display) {
    (void)display;
    const double height = EM_ASM_DOUBLE_V({
        var canvas = Module['canvas'];
        return canvas.height;
    });
    return (int)(round(height));
}

static void glfm__setVisibleAndFocused(GLFMDisplay *display, bool visible, bool focused) {
    GLFMPlatformData *platformData = display->platformData;
    bool wasActive = platformData->isVisible && platformData->isFocused;
    platformData->isVisible = visible;
    platformData->isFocused = focused;
    bool isActive = platformData->isVisible && platformData->isFocused;
    if (wasActive != isActive) {
        platformData->refreshRequested = true;
        glfm__clearActiveTouches(platformData);
        if (display->focusFunc) {
            display->focusFunc(display, isActive);
        }
    }
}

static void glfm__mainLoopFunc(void *userData) {
    GLFMDisplay *display = userData;
    if (display) {
        GLFMPlatformData *platformData = display->platformData;

        // Check if canvas size has changed
        int displayChanged = EM_ASM_INT_V({
            var canvas = Module['canvas'];
            var devicePixelRatio = window.devicePixelRatio || 1;
            var width = canvas.clientWidth * devicePixelRatio;
            var height = canvas.clientHeight * devicePixelRatio;
            if (width != canvas.width || height != canvas.height) {
                canvas.width = width;
                canvas.height = height;
                return 1;
            } else {
                return 0;
            }
        });
        if (displayChanged) {
            platformData->refreshRequested = true;
            platformData->width = glfm__getDisplayWidth(display);
            platformData->height = glfm__getDisplayHeight(display);
            platformData->scale = emscripten_get_device_pixel_ratio();
            if (display->surfaceResizedFunc) {
                display->surfaceResizedFunc(display, platformData->width, platformData->height);
            }
        }

        // Tick
        if (platformData->refreshRequested) {
            platformData->refreshRequested = false;
            if (display->surfaceRefreshFunc) {
                display->surfaceRefreshFunc(display);
            }
        }
        if (display->renderFunc) {
            display->renderFunc(display);
        }
    }
}

static EM_BOOL glfm__webGLContextCallback(int eventType, const void *reserved, void *userData) {
    (void)reserved;
    GLFMDisplay *display = userData;
    GLFMPlatformData *platformData = display->platformData;
    platformData->refreshRequested = true;
    switch (eventType) {
        case EMSCRIPTEN_EVENT_WEBGLCONTEXTLOST:
            if (display->surfaceDestroyedFunc) {
                display->surfaceDestroyedFunc(display);
            }
            return 1;
        case EMSCRIPTEN_EVENT_WEBGLCONTEXTRESTORED:
            if (display->surfaceCreatedFunc) {
                display->surfaceCreatedFunc(display, platformData->width, platformData->height);
            }
            return 1;
        default:
            return 0;
    }
}

static EM_BOOL glfm__focusCallback(int eventType, const EmscriptenFocusEvent *focusEvent, void *userData) {
    (void)focusEvent;
    GLFMDisplay *display = userData;
    GLFMPlatformData *platformData = display->platformData;
    bool focused = (eventType == EMSCRIPTEN_EVENT_FOCUS || eventType == EMSCRIPTEN_EVENT_FOCUSIN);
    glfm__setVisibleAndFocused(display, platformData->isVisible, focused);
    return 1;
}

static EM_BOOL glfm__visibilityChangeCallback(int eventType, const EmscriptenVisibilityChangeEvent *event,
                                              void *userData) {
    (void)eventType;
    GLFMDisplay *display = userData;
    GLFMPlatformData *platformData = display->platformData;
    glfm__setVisibleAndFocused(display, !event->hidden, platformData->isFocused);
    return 1;
}

static const char *glfm__beforeUnloadCallback(int eventType, const void *reserved, void *userData) {
    (void)eventType;
    (void)reserved;
    GLFMDisplay *display = userData;
    glfm__setVisibleAndFocused(display, false, false);
    return NULL;
}

static EM_BOOL glfm__orientationChangeCallback(int eventType,
                                               const EmscriptenDeviceOrientationEvent *deviceOrientationEvent,
                                               void *userData) {
    (void)eventType;
    (void)deviceOrientationEvent;
    GLFMDisplay *display = userData;
    GLFMPlatformData *platformData = display->platformData;
    GLFMInterfaceOrientation orientation = glfmGetInterfaceOrientation(display);
    if (platformData->orientation != orientation) {
        platformData->orientation = orientation;
        platformData->refreshRequested = true;
        if (display->orientationChangedFunc) {
            display->orientationChangedFunc(display, orientation);
        }
    }
    return 1;
}

static EM_BOOL glfm__keyCallback(int eventType, const EmscriptenKeyboardEvent *event, void *userData) {
    GLFMDisplay *display = userData;
    EM_BOOL handled = 0;

    // Key input
    if (display->keyFunc && (eventType == EMSCRIPTEN_EVENT_KEYDOWN || eventType == EMSCRIPTEN_EVENT_KEYUP)) {
        // This list of code values is from https://www.w3.org/TR/uievents-code/
        // (Added functions keys F13-F24)
        // egrep -o '<code class="code" id="code-.*?</code>' uievents-code.html | sort | awk -F"[><]" '{print $3}' | awk 1 ORS=', '
        // This array must be sorted for binary search. See GLFM_TEST_KEYBOARD_EVENT_ARRAYS.
        // NOTE: event->keyCode is obsolete. Only event->key or event->code should be used.
        static const char *KEYBOARD_EVENT_CODES[] = {
            "AltLeft", "AltRight", "ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp", "Backquote", "Backslash",
            "Backspace", "BracketLeft", "BracketRight", "BrowserBack", "CapsLock", "Comma", "ContextMenu",
            "ControlLeft", "ControlRight", "Delete", "Digit0", "Digit1", "Digit2", "Digit3", "Digit4", "Digit5",
            "Digit6", "Digit7", "Digit8", "Digit9", "End", "Enter", "Equal", "Escape", "F1", "F10", "F11", "F12", "F13",
            "F14", "F15", "F16", "F17", "F18", "F19", "F2", "F20", "F21", "F22", "F23", "F24", "F3", "F4", "F5", "F6",
            "F7", "F8", "F9", "Fn", "Help", "Home", "Insert", "KeyA", "KeyB", "KeyC", "KeyD", "KeyE", "KeyF", "KeyG",
            "KeyH", "KeyI", "KeyJ", "KeyK", "KeyL", "KeyM", "KeyN", "KeyO", "KeyP", "KeyQ", "KeyR", "KeyS", "KeyT",
            "KeyU", "KeyV", "KeyW", "KeyX", "KeyY", "KeyZ", "MediaPlayPause", "MetaLeft", "MetaRight", "Minus",
            "NumLock", "Numpad0", "Numpad1", "Numpad2", "Numpad3", "Numpad4", "Numpad5", "Numpad6", "Numpad7",
            "Numpad8", "Numpad9", "NumpadAdd", "NumpadDecimal", "NumpadDivide", "NumpadEnter", "NumpadEqual",
            "NumpadMultiply", "NumpadSubtract", "PageDown", "PageUp", "Pause", "Period", "Power", "PrintScreen",
            "Quote", "ScrollLock", "Semicolon", "ShiftLeft", "ShiftRight", "Slash", "Space", "Tab",
        };
        static const size_t KEYBOARD_EVENT_CODES_LENGTH = sizeof(KEYBOARD_EVENT_CODES) / sizeof(*KEYBOARD_EVENT_CODES);
        static const GLFMKeyCode GLFM_KEY_CODES[] = {
            GLFMKeyCodeAltLeft, GLFMKeyCodeAltRight, GLFMKeyCodeArrowDown, GLFMKeyCodeArrowLeft,
            GLFMKeyCodeArrowRight, GLFMKeyCodeArrowUp, GLFMKeyCodeBackquote, GLFMKeyCodeBackslash,
            GLFMKeyCodeBackspace, GLFMKeyCodeBracketLeft, GLFMKeyCodeBracketRight, GLFMKeyCodeNavigationBack,
            GLFMKeyCodeCapsLock, GLFMKeyCodeComma, GLFMKeyCodeMenu, GLFMKeyCodeControlLeft, GLFMKeyCodeControlRight,
            GLFMKeyCodeDelete, GLFMKeyCode0, GLFMKeyCode1, GLFMKeyCode2, GLFMKeyCode3, GLFMKeyCode4, GLFMKeyCode5,
            GLFMKeyCode6, GLFMKeyCode7, GLFMKeyCode8, GLFMKeyCode9, GLFMKeyCodeEnd, GLFMKeyCodeEnter, GLFMKeyCodeEqual,
            GLFMKeyCodeEscape, GLFMKeyCodeF1, GLFMKeyCodeF10, GLFMKeyCodeF11, GLFMKeyCodeF12, GLFMKeyCodeF13,
            GLFMKeyCodeF14, GLFMKeyCodeF15, GLFMKeyCodeF16, GLFMKeyCodeF17, GLFMKeyCodeF18, GLFMKeyCodeF19,
            GLFMKeyCodeF2, GLFMKeyCodeF20, GLFMKeyCodeF21, GLFMKeyCodeF22, GLFMKeyCodeF23, GLFMKeyCodeF24,
            GLFMKeyCodeF3, GLFMKeyCodeF4, GLFMKeyCodeF5, GLFMKeyCodeF6, GLFMKeyCodeF7, GLFMKeyCodeF8, GLFMKeyCodeF9,
            GLFMKeyCodeFunction, GLFMKeyCodeInsert, GLFMKeyCodeHome, GLFMKeyCodeInsert, GLFMKeyCodeA, GLFMKeyCodeB,
            GLFMKeyCodeC, GLFMKeyCodeD, GLFMKeyCodeE, GLFMKeyCodeF, GLFMKeyCodeG, GLFMKeyCodeH, GLFMKeyCodeI,
            GLFMKeyCodeJ, GLFMKeyCodeK, GLFMKeyCodeL, GLFMKeyCodeM, GLFMKeyCodeN, GLFMKeyCodeO, GLFMKeyCodeP,
            GLFMKeyCodeQ, GLFMKeyCodeR, GLFMKeyCodeS, GLFMKeyCodeT, GLFMKeyCodeU, GLFMKeyCodeV, GLFMKeyCodeW,
            GLFMKeyCodeX, GLFMKeyCodeY, GLFMKeyCodeZ, GLFMKeyCodeMediaPlayPause, GLFMKeyCodeMetaLeft,
            GLFMKeyCodeMetaRight, GLFMKeyCodeMinus, GLFMKeyCodeNumLock, GLFMKeyCodeNumpad0, GLFMKeyCodeNumpad1,
            GLFMKeyCodeNumpad2, GLFMKeyCodeNumpad3, GLFMKeyCodeNumpad4, GLFMKeyCodeNumpad5, GLFMKeyCodeNumpad6,
            GLFMKeyCodeNumpad7, GLFMKeyCodeNumpad8, GLFMKeyCodeNumpad9, GLFMKeyCodeNumpadAdd, GLFMKeyCodeNumpadDecimal,
            GLFMKeyCodeNumpadDivide, GLFMKeyCodeNumpadEnter, GLFMKeyCodeNumpadEqual, GLFMKeyCodeNumpadMultiply,
            GLFMKeyCodeNumpadSubtract, GLFMKeyCodePageDown, GLFMKeyCodePageUp, GLFMKeyCodePause ,GLFMKeyCodePeriod,
            GLFMKeyCodePower, GLFMKeyCodePrintScreen, GLFMKeyCodeQuote, GLFMKeyCodeScrollLock, GLFMKeyCodeSemicolon,
            GLFMKeyCodeShiftLeft, GLFMKeyCodeShiftRight, GLFMKeyCodeSlash, GLFMKeyCodeSpace, GLFMKeyCodeTab,
        };

#if GLFM_TEST_KEYBOARD_EVENT_ARRAYS
        static bool KEYBOARD_EVENT_CODES_TESTED = false;
        if (!KEYBOARD_EVENT_CODES_TESTED) {
            KEYBOARD_EVENT_CODES_TESTED = true;
            if (glfm__listIsSorted(KEYBOARD_EVENT_CODES, KEYBOARD_EVENT_CODES_LENGTH)) {
                GLFM_LOG("Success: KEYBOARD_EVENT_CODES is sorted");
            } else {
                GLFM_LOG("Failure: KEYBOARD_EVENT_CODES is not sorted");
            }
            if (KEYBOARD_EVENT_CODES_LENGTH == sizeof(GLFM_KEY_CODES) / sizeof(*GLFM_KEY_CODES)) {
                GLFM_LOG("Success: GLFM_KEYBOARD_EVENT_CODES is the correct length");
            } else {
                GLFM_LOG("Failure: GLFM_KEYBOARD_EVENT_CODES is not the correct length");
            }
        }
#endif

        GLFMKeyAction action;
        if (eventType == EMSCRIPTEN_EVENT_KEYDOWN) {
            action = event->repeat ? GLFMKeyActionRepeated : GLFMKeyActionPressed;
        } else {
            action = GLFMKeyActionReleased;
        }

        // Modifiers
        // Note, Emscripten doesn't provide a way to get extended modifiers like the function key.
        // (See KeyboardEvent's getModifierState() function).
        // Commands like "fn-f" ("Fullscreen" on macOS) will be treated as text input.
        int modifiers = 0;
        if (event->shiftKey) {
            modifiers |= GLFMKeyModifierShift;
        }
        if (event->ctrlKey) {
            modifiers |= GLFMKeyModifierControl;
        }
        if (event->altKey) {
            modifiers |= GLFMKeyModifierAlt;
        }
        if (event->metaKey) {
            modifiers |= GLFMKeyModifierMeta;
        }

        int codeIndex = glfm__sortedListSearch(KEYBOARD_EVENT_CODES, KEYBOARD_EVENT_CODES_LENGTH, event->code);
        GLFMKeyCode keyCode = codeIndex >= 0 ? GLFM_KEY_CODES[codeIndex] : GLFMKeyCodeUnknown;
        handled = display->keyFunc(display, keyCode, action, modifiers);
    }

    // Character input
    if (display->charFunc && eventType == EMSCRIPTEN_EVENT_KEYDOWN && !event->ctrlKey && !event->metaKey) {
        // It appears the only way to detect printable character input is to check if the "key" value is
        // not one of the pre-defined key values.
        // This list of pre-defined key values is from https://www.w3.org/TR/uievents-key/
        // (Added functions keys F13-F24 and Soft5-Soft10)
        // This array must be sorted for binary search. See GLFM_TEST_KEYBOARD_EVENT_ARRAYS.
        // egrep -o '<code class="key" id="key-.*?</code>' uievents-key.html | sort | awk -F"[><]" '{print $3}' | awk 1 ORS=', '
        static const char *KEYBOARD_EVENT_KEYS[] = {
            "AVRInput", "AVRPower", "Accept", "Again", "AllCandidates", "Alphanumeric", "Alt", "AltGraph", "AppSwitch",
            "ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp", "Attn", "AudioBalanceLeft", "AudioBalanceRight",
            "AudioBassBoostDown", "AudioBassBoostToggle", "AudioBassBoostUp", "AudioFaderFront", "AudioFaderRear",
            "AudioSurroundModeNext", "AudioTrebleDown", "AudioTrebleUp", "AudioVolumeDown", "AudioVolumeMute",
            "AudioVolumeUp", "Backspace", "BrightnessDown", "BrightnessUp", "BrowserBack", "BrowserFavorites",
            "BrowserForward", "BrowserHome", "BrowserRefresh", "BrowserSearch", "BrowserStop", "Call", "Camera",
            "CameraFocus", "Cancel", "CapsLock", "ChannelDown", "ChannelUp", "Clear", "Close", "ClosedCaptionToggle",
            "CodeInput", "ColorF0Red", "ColorF1Green", "ColorF2Yellow", "ColorF3Blue", "ColorF4Grey", "ColorF5Brown",
            "Compose", "ContextMenu", "Control", "Convert", "Copy", "CrSel", "Cut", "DVR", "Dead", "Delete", "Dimmer",
            "DisplaySwap", "Eisu", "Eject", "End", "EndCall", "Enter", "EraseEof", "Escape", "ExSel", "Execute", "Exit",
            "F1", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F2",
            "F20", "F21", "F22", "F23", "F24", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FavoriteClear0",
            "FavoriteClear1", "FavoriteClear2", "FavoriteClear3", "FavoriteRecall0", "FavoriteRecall1",
            "FavoriteRecall2", "FavoriteRecall3", "FavoriteStore0", "FavoriteStore1", "FavoriteStore2",
            "FavoriteStore3", "FinalMode", "Find", "Fn", "FnLock", "GoBack", "GoHome", "GroupFirst", "GroupLast",
            "GroupNext", "GroupPrevious", "Guide", "GuideNextDay", "GuidePreviousDay", "HangulMode", "HanjaMode",
            "Hankaku", "HeadsetHook", "Help", "Hibernate", "Hiragana", "HiraganaKatakana", "Home", "Hyper", "Info",
            "Insert", "InstantReplay", "JunjaMode", "KanaMode", "KanjiMode", "Katakana", "Key11", "Key12",
            "LastNumberRedial", "LaunchApplication1", "LaunchApplication2", "LaunchCalendar", "LaunchContacts",
            "LaunchMail", "LaunchMediaPlayer", "LaunchMusicPlayer", "LaunchPhone", "LaunchScreenSaver",
            "LaunchSpreadsheet", "LaunchWebBrowser", "LaunchWebCam", "LaunchWordProcessor", "Link", "ListProgram",
            "LiveContent", "Lock", "LogOff", "MailForward", "MailReply", "MailSend", "MannerMode", "MediaApps",
            "MediaAudioTrack", "MediaClose", "MediaFastForward", "MediaLast", "MediaPause", "MediaPlay",
            "MediaPlayPause", "MediaRecord", "MediaRewind", "MediaSkipBackward", "MediaSkipForward",
            "MediaStepBackward", "MediaStepForward", "MediaStop", "MediaTopMenu", "MediaTrackNext",
            "MediaTrackPrevious", "Meta", "MicrophoneToggle", "MicrophoneVolumeDown", "MicrophoneVolumeMute",
            "MicrophoneVolumeUp", "ModeChange", "NavigateIn", "NavigateNext", "NavigateOut", "NavigatePrevious", "New",
            "NextCandidate", "NextFavoriteChannel", "NextUserProfile", "NonConvert", "Notification", "NumLock",
            "OnDemand", "Open", "PageDown", "PageUp", "Pairing", "Paste", "Pause", "PinPDown", "PinPMove", "PinPToggle",
            "PinPUp", "Play", "PlaySpeedDown", "PlaySpeedReset", "PlaySpeedUp", "Power", "PowerOff",
            "PreviousCandidate", "Print", "PrintScreen", "Process", "Props", "RandomToggle", "RcLowBattery",
            "RecordSpeedNext", "Redo", "RfBypass", "Romaji", "STBInput", "STBPower", "Save", "ScanChannelsToggle",
            "ScreenModeNext", "ScrollLock", "Select", "Settings", "Shift", "SingleCandidate",
            "Soft1", "Soft10", "Soft2", "Soft3", "Soft4", "Soft5", "Soft6", "Soft7", "Soft8", "Soft9",
            "SpeechCorrectionList", "SpeechInputToggle", "SpellCheck", "SplitScreenToggle", "Standby",
            "Subtitle", "Super", "Symbol", "SymbolLock", "TV", "TV3DMode", "TVAntennaCable", "TVAudioDescription",
            "TVAudioDescriptionMixDown", "TVAudioDescriptionMixUp", "TVContentsMenu", "TVDataService", "TVInput",
            "TVInputComponent1", "TVInputComponent2", "TVInputComposite1", "TVInputComposite2", "TVInputHDMI1",
            "TVInputHDMI2", "TVInputHDMI3", "TVInputHDMI4", "TVInputVGA1", "TVMediaContext", "TVNetwork",
            "TVNumberEntry", "TVPower", "TVRadioService", "TVSatellite", "TVSatelliteBS", "TVSatelliteCS",
            "TVSatelliteToggle", "TVTerrestrialAnalog", "TVTerrestrialDigital", "TVTimer", "Tab", "Teletext",
            "Undo", "Unidentified", "VideoModeNext", "VoiceDial", "WakeUp", "Wink", "Zenkaku", "ZenkakuHankaku",
            "ZoomIn", "ZoomOut", "ZoomToggle",
        };
        static const size_t KEYBOARD_EVENT_KEYS_LENGTH = sizeof(KEYBOARD_EVENT_KEYS) / sizeof(*KEYBOARD_EVENT_KEYS);

#if GLFM_TEST_KEYBOARD_EVENT_ARRAYS
        static bool KEYBOARD_EVENT_KEYS_TESTED = false;
        if (!KEYBOARD_EVENT_KEYS_TESTED) {
            KEYBOARD_EVENT_KEYS_TESTED = true;
            if (glfm__listIsSorted(KEYBOARD_EVENT_KEYS, KEYBOARD_EVENT_KEYS_LENGTH)) {
                GLFM_LOG("Success: KEYBOARD_EVENT_KEYS is sorted");
            } else {
                GLFM_LOG("Failure: KEYBOARD_EVENT_KEYS is not sorted");
            }
        }
#endif
        if (event->key[0] != '\0') {
            bool isSingleChar = (event->key[1] == '\0');
            bool isPredefinedKey = false;
            if (!isSingleChar) {
                isPredefinedKey = glfm__sortedListSearch(KEYBOARD_EVENT_KEYS, KEYBOARD_EVENT_KEYS_LENGTH,
                                                         event->key) >= 0;
            }
            if (isSingleChar || !isPredefinedKey) {
                display->charFunc(display, event->key, 0);
                handled = 1;
            }
        }
    }

    return handled;
}

static EM_BOOL glfm__mouseCallback(int eventType, const EmscriptenMouseEvent *event, void *userData) {
    GLFMDisplay *display = userData;
    GLFMPlatformData *platformData = display->platformData;
    if (!display->touchFunc) {
        platformData->mouseDown = false;
        return 0;
    }

    // The mouse event handler targets EMSCRIPTEN_EVENT_TARGET_WINDOW so that dragging the mouse outside the canvas can
    // be detected. If a mouse drag begins inside the canvas, the mouse release event is sent even if the mouse is
    // released outside the canvas.
    float canvasX, canvasY, canvasW, canvasH;
    EM_ASM({
        var rect = Module['canvas'].getBoundingClientRect();
        setValue($0, rect.x, "float");
        setValue($1, rect.y, "float");
        setValue($2, rect.width, "float");
        setValue($3, rect.height, "float");
    }, &canvasX, &canvasY, &canvasW, &canvasH);
    const float mouseX = (float)event->targetX - canvasX;
    const float mouseY = (float)event->targetY - canvasY;
    const bool mouseInside = mouseX >= 0 && mouseY >= 0 && mouseX < canvasW && mouseY < canvasH;
    if (!mouseInside && eventType == EMSCRIPTEN_EVENT_MOUSEDOWN) {
        // Mouse click outside canvas
        return 0;
    }
    if (!mouseInside && eventType != EMSCRIPTEN_EVENT_MOUSEDOWN && !platformData->mouseDown) {
        // Mouse hover or click outside canvas
        return 0;
    }

    GLFMTouchPhase touchPhase;
    switch (eventType) {
        case EMSCRIPTEN_EVENT_MOUSEDOWN:
            touchPhase = GLFMTouchPhaseBegan;
            platformData->mouseDown = true;
            break;

        case EMSCRIPTEN_EVENT_MOUSEMOVE:
            if (platformData->mouseDown) {
                touchPhase = GLFMTouchPhaseMoved;
            } else {
                touchPhase = GLFMTouchPhaseHover;
            }
            break;

        case EMSCRIPTEN_EVENT_MOUSEUP:
            touchPhase = GLFMTouchPhaseEnded;
            platformData->mouseDown = false;
            break;

        default:
            touchPhase = GLFMTouchPhaseCancelled;
            platformData->mouseDown = false;
            break;
    }
    bool handled = display->touchFunc(display, event->button, touchPhase,
                                      platformData->scale * (double)mouseX,
                                      platformData->scale * (double)mouseY);
    // Always return `false` when the event is `mouseDown` for iframe support. Returning `true` invokes
    // `preventDefault`, and invoking `preventDefault` on `mouseDown` events prevents `mouseMove` events outside the
    // iframe.
    return handled && eventType != EMSCRIPTEN_EVENT_MOUSEDOWN;
}

static EM_BOOL glfm__mouseWheelCallback(int eventType, const EmscriptenWheelEvent *wheelEvent, void *userData) {
    (void)eventType;
    GLFMDisplay *display = userData;
    if (!display->mouseWheelFunc) {
        return 0;
    }
    GLFMPlatformData *platformData = display->platformData;
    GLFMMouseWheelDeltaType deltaType;
    switch (wheelEvent->deltaMode) {
        case DOM_DELTA_PIXEL: default:
            deltaType = GLFMMouseWheelDeltaPixel;
            break;
        case DOM_DELTA_LINE:
            deltaType = GLFMMouseWheelDeltaLine;
            break;
        case DOM_DELTA_PAGE:
            deltaType = GLFMMouseWheelDeltaPage;
            break;
    }
    return display->mouseWheelFunc(display,
                                   platformData->scale * (double)wheelEvent->mouse.targetX,
                                   platformData->scale * (double)wheelEvent->mouse.targetY,
                                   deltaType, wheelEvent->deltaX, wheelEvent->deltaY, wheelEvent->deltaZ);
}

static int glfm__getTouchIdentifier(GLFMPlatformData *platformData, const EmscriptenTouchPoint *touch) {
    int firstNullIndex = -1;
    int index = -1;
    for (int i = 0; i < GLFM_MAX_ACTIVE_TOUCHES; i++) {
        if (platformData->activeTouches[i].identifier == touch->identifier &&
            platformData->activeTouches[i].active) {
            index = i;
            break;
        }
        if (firstNullIndex == -1 && !platformData->activeTouches[i].active) {
            firstNullIndex = i;
        }
    }
    if (index == -1) {
        if (firstNullIndex == -1) {
            // Shouldn't happen
            return -1;
        }
        index = firstNullIndex;
        platformData->activeTouches[index].identifier = touch->identifier;
        platformData->activeTouches[index].active = true;
    }
    return index;
}

static EM_BOOL glfm__touchCallback(int eventType, const EmscriptenTouchEvent *event, void *userData) {
    GLFMDisplay *display = userData;
    if (!display->touchFunc) {
        return 0;
    }
    GLFMPlatformData *platformData = display->platformData;
    GLFMTouchPhase touchPhase;
    switch (eventType) {
        case EMSCRIPTEN_EVENT_TOUCHSTART:
            touchPhase = GLFMTouchPhaseBegan;
            break;

        case EMSCRIPTEN_EVENT_TOUCHMOVE:
            touchPhase = GLFMTouchPhaseMoved;
            break;

        case EMSCRIPTEN_EVENT_TOUCHEND:
            touchPhase = GLFMTouchPhaseEnded;
            break;

        case EMSCRIPTEN_EVENT_TOUCHCANCEL:
        default:
            touchPhase = GLFMTouchPhaseCancelled;
            break;
    }

    int handled = 0;
    for (int i = 0; i < event->numTouches; i++) {
        const EmscriptenTouchPoint *touch = &event->touches[i];
        if (touch->isChanged) {
            int identifier = glfm__getTouchIdentifier(platformData, touch);
            if (identifier >= 0) {
                if ((platformData->multitouchEnabled || identifier == 0)) {
                    handled |= display->touchFunc(display, identifier, touchPhase,
                                                  platformData->scale * (double)touch->targetX,
                                                  platformData->scale * (double)touch->targetY);
                }

                if (touchPhase == GLFMTouchPhaseEnded || touchPhase == GLFMTouchPhaseCancelled) {
                    platformData->activeTouches[identifier].active = false;
                }
            }
        }
    }
    return handled;
}

// MARK: - main

int main(void) {
    GLFMDisplay *glfmDisplay = calloc(1, sizeof(GLFMDisplay));
    GLFMPlatformData *platformData = calloc(1, sizeof(GLFMPlatformData));
    glfmDisplay->platformData = platformData;
    glfmDisplay->supportedOrientations = GLFMInterfaceOrientationAll;
    platformData->orientation = glfmGetInterfaceOrientation(glfmDisplay);

    // Main entry
    glfmMain(glfmDisplay);

    // Init resizable canvas
    EM_ASM({
        var canvas = Module['canvas'];
        var devicePixelRatio = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * devicePixelRatio;
        canvas.height = canvas.clientHeight * devicePixelRatio;
    });
    platformData->width = glfm__getDisplayWidth(glfmDisplay);
    platformData->height = glfm__getDisplayHeight(glfmDisplay);
    platformData->scale = emscripten_get_device_pixel_ratio();

    // Create WebGL context
    EmscriptenWebGLContextAttributes attribs;
    emscripten_webgl_init_context_attributes(&attribs);
    attribs.alpha = glfmDisplay->colorFormat == GLFMColorFormatRGBA8888;
    attribs.depth = glfmDisplay->depthFormat != GLFMDepthFormatNone;
    attribs.stencil = glfmDisplay->stencilFormat != GLFMStencilFormatNone;
    attribs.antialias = glfmDisplay->multisample != GLFMMultisampleNone;
    attribs.premultipliedAlpha = 1;
    attribs.preserveDrawingBuffer = 0;
    attribs.powerPreference = EM_WEBGL_POWER_PREFERENCE_HIGH_PERFORMANCE;
    attribs.failIfMajorPerformanceCaveat = 0;
    attribs.enableExtensionsByDefault = 0;

    const char *webGLTarget = "#canvas";
    EMSCRIPTEN_WEBGL_CONTEXT_HANDLE contextHandle = 0;
    if (glfmDisplay->preferredAPI >= GLFMRenderingAPIOpenGLES3) {
        // OpenGL ES 3.0 / WebGL 2.0
        attribs.majorVersion = 2;
        attribs.minorVersion = 0;
        contextHandle = emscripten_webgl_create_context(webGLTarget, &attribs);
        if (contextHandle) {
            platformData->renderingAPI = GLFMRenderingAPIOpenGLES3;
        }
    }
    if (!contextHandle) {
        // OpenGL ES 2.0 / WebGL 1.0
        attribs.majorVersion = 1;
        attribs.minorVersion = 0;
        contextHandle = emscripten_webgl_create_context(webGLTarget, &attribs);
        if (contextHandle) {
            platformData->renderingAPI = GLFMRenderingAPIOpenGLES2;
        }
    }
    if (!contextHandle) {
        GLFM_LOG("Couldn't create GL context");
        glfm__reportSurfaceError(glfmDisplay, "Couldn't create GL context");
        return 0;
    }

    emscripten_webgl_make_context_current(contextHandle);

    if (glfmDisplay->surfaceCreatedFunc) {
        glfmDisplay->surfaceCreatedFunc(glfmDisplay, platformData->width, platformData->height);
    }
    glfm__setVisibleAndFocused(glfmDisplay, true, true);

    // Setup callbacks
    emscripten_set_main_loop_arg(glfm__mainLoopFunc, glfmDisplay, 0, 0);
    emscripten_set_touchstart_callback(webGLTarget, glfmDisplay, 1, glfm__touchCallback);
    emscripten_set_touchend_callback(webGLTarget, glfmDisplay, 1, glfm__touchCallback);
    emscripten_set_touchmove_callback(webGLTarget, glfmDisplay, 1, glfm__touchCallback);
    emscripten_set_touchcancel_callback(webGLTarget, glfmDisplay, 1, glfm__touchCallback);
    emscripten_set_mousedown_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, glfmDisplay, 1, glfm__mouseCallback);
    emscripten_set_mouseup_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, glfmDisplay, 1, glfm__mouseCallback);
    emscripten_set_mousemove_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, glfmDisplay, 1, glfm__mouseCallback);
    emscripten_set_wheel_callback(webGLTarget, glfmDisplay, 1, glfm__mouseWheelCallback);
    //emscripten_set_click_callback(webGLTarget, glfmDisplay, 1, glfm__mouseCallback);
    //emscripten_set_dblclick_callback(webGLTarget, glfmDisplay, 1, glfm__mouseCallback);
    emscripten_set_keypress_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, glfmDisplay, 1, glfm__keyCallback);
    emscripten_set_keydown_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, glfmDisplay, 1, glfm__keyCallback);
    emscripten_set_keyup_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, glfmDisplay, 1, glfm__keyCallback);
    emscripten_set_webglcontextlost_callback(webGLTarget, glfmDisplay, 1, glfm__webGLContextCallback);
    emscripten_set_webglcontextrestored_callback(webGLTarget, glfmDisplay, 1, glfm__webGLContextCallback);
    emscripten_set_visibilitychange_callback(glfmDisplay, 1, glfm__visibilityChangeCallback);
    emscripten_set_focus_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, glfmDisplay, 1, glfm__focusCallback);
    emscripten_set_blur_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, glfmDisplay, 1, glfm__focusCallback);
    emscripten_set_beforeunload_callback(glfmDisplay, glfm__beforeUnloadCallback);
    emscripten_set_deviceorientation_callback(glfmDisplay, 1, glfm__orientationChangeCallback);
    return 0;
}

#endif // __EMSCRIPTEN__

```

`src/glfm_internal.h`:

```h
// GLFM
// https://github.com/brackeen/glfm

#ifndef GLFM_INTERNAL_H
#define GLFM_INTERNAL_H

#include "glfm.h"
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

#define GLFM_NUM_SENSORS 4

#if defined(__GNUC__) && __STDC_VERSION__ >= 199901
#define GLFM_IGNORE_DEPRECATIONS_START \
    _Pragma("GCC diagnostic push") \
    _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#define GLFM_IGNORE_DEPRECATIONS_END \
   _Pragma("GCC diagnostic pop")
#else
#define GLFM_IGNORE_DEPRECATIONS_START
#define GLFM_IGNORE_DEPRECATIONS_END
#endif

struct GLFMDisplay {
    // Config
    GLFMRenderingAPI preferredAPI;
    GLFMColorFormat colorFormat;
    GLFMDepthFormat depthFormat;
    GLFMStencilFormat stencilFormat;
    GLFMMultisample multisample;
    GLFMInterfaceOrientation supportedOrientations;
    GLFMUserInterfaceChrome uiChrome;
    GLFMSwapBehavior swapBehavior;

    // Callbacks
    GLFM_IGNORE_DEPRECATIONS_START
    GLFMMainLoopFunc deprecatedMainLoopFunc;
    GLFM_IGNORE_DEPRECATIONS_END
    GLFMRenderFunc renderFunc;
    GLFMTouchFunc touchFunc;
    GLFMKeyFunc keyFunc;
    GLFMCharFunc charFunc;
    GLFMMouseWheelFunc mouseWheelFunc;
    GLFMSurfaceErrorFunc surfaceErrorFunc;
    GLFMSurfaceCreatedFunc surfaceCreatedFunc;
    GLFMSurfaceResizedFunc surfaceResizedFunc;
    GLFMSurfaceRefreshFunc surfaceRefreshFunc;
    GLFMSurfaceDestroyedFunc surfaceDestroyedFunc;
    GLFMKeyboardVisibilityChangedFunc keyboardVisibilityChangedFunc;
    GLFMOrientationChangedFunc orientationChangedFunc;
    GLFMDisplayChromeInsetsChangedFunc displayChromeInsetsChangedFunc;
    GLFMMemoryWarningFunc lowMemoryFunc;
    GLFMAppFocusFunc focusFunc;
    GLFMSensorFunc sensorFuncs[GLFM_NUM_SENSORS];

    // External data
    void *userData;
    void *platformData;
};

// MARK: - Notification functions

static void glfm__displayChromeUpdated(GLFMDisplay *display);
static void glfm__sensorFuncUpdated(GLFMDisplay *display);

// MARK: - Setters

GLFMSurfaceErrorFunc glfmSetSurfaceErrorFunc(GLFMDisplay *display, GLFMSurfaceErrorFunc surfaceErrorFunc) {
    GLFMSurfaceErrorFunc previous = NULL;
    if (display) {
        previous = display->surfaceErrorFunc;
        display->surfaceErrorFunc = surfaceErrorFunc;
    }
    return previous;
}

void glfmSetDisplayConfig(GLFMDisplay *display,
                          const GLFMRenderingAPI preferredAPI,
                          const GLFMColorFormat colorFormat,
                          const GLFMDepthFormat depthFormat,
                          const GLFMStencilFormat stencilFormat,
                          const GLFMMultisample multisample) {
    if (display) {
        display->preferredAPI = preferredAPI;
        display->colorFormat = colorFormat;
        display->depthFormat = depthFormat;
        display->stencilFormat = stencilFormat;
        display->multisample = multisample;
    }
}

GLFMInterfaceOrientation glfmGetSupportedInterfaceOrientation(const GLFMDisplay *display) {
    return display ? display->supportedOrientations : GLFMInterfaceOrientationAll;
}

GLFMUserInterfaceOrientation glfmGetUserInterfaceOrientation(GLFMDisplay *display) {
    return (GLFMUserInterfaceOrientation)glfmGetSupportedInterfaceOrientation(display);
}

void glfmSetUserInterfaceOrientation(GLFMDisplay *display, GLFMUserInterfaceOrientation supportedOrientations) {
    glfmSetSupportedInterfaceOrientation(display, (GLFMInterfaceOrientation)supportedOrientations);
}

void glfmSetUserData(GLFMDisplay *display, void *userData) {
    if (display) {
        display->userData = userData;
    }
}

void *glfmGetUserData(const GLFMDisplay *display) {
    return display ? display->userData : NULL;
}

GLFMUserInterfaceChrome glfmGetDisplayChrome(const GLFMDisplay *display) {
    return display ? display->uiChrome : GLFMUserInterfaceChromeNavigation;
}

void glfmSetDisplayChrome(GLFMDisplay *display, GLFMUserInterfaceChrome uiChrome) {
    if (display) {
        display->uiChrome = uiChrome;
        glfm__displayChromeUpdated(display);
    }
}

GLFMRenderFunc glfmSetRenderFunc(GLFMDisplay *display, GLFMRenderFunc renderFunc) {
    GLFMRenderFunc previous = NULL;
    if (display) {
        previous = display->renderFunc;
        display->renderFunc = renderFunc;
    }
    return previous;
}

static void glfm__deprecatedMainLoopRenderAdapter(GLFMDisplay *display) {
    if (display && display->deprecatedMainLoopFunc) {
        // Mimic the behavior of the deprecated "MainLoop" callback
        display->deprecatedMainLoopFunc(display, glfmGetTime());
        glfmSwapBuffers(display);
    }
}

GLFMMainLoopFunc glfmSetMainLoopFunc(GLFMDisplay *display, GLFMMainLoopFunc mainLoopFunc) {
    GLFMMainLoopFunc previous = NULL;
    if (display) {
        previous = display->deprecatedMainLoopFunc;
        display->deprecatedMainLoopFunc = mainLoopFunc;
        glfmSetRenderFunc(display, mainLoopFunc ? glfm__deprecatedMainLoopRenderAdapter : NULL);
    }
    return previous;
}

GLFMSurfaceCreatedFunc glfmSetSurfaceCreatedFunc(GLFMDisplay *display, GLFMSurfaceCreatedFunc surfaceCreatedFunc) {
    GLFMSurfaceCreatedFunc previous = NULL;
    if (display) {
        previous = display->surfaceCreatedFunc;
        display->surfaceCreatedFunc = surfaceCreatedFunc;
    }
    return previous;
}

GLFMSurfaceResizedFunc glfmSetSurfaceResizedFunc(GLFMDisplay *display, GLFMSurfaceResizedFunc surfaceResizedFunc) {
    GLFMSurfaceResizedFunc previous = NULL;
    if (display) {
        previous = display->surfaceResizedFunc;
        display->surfaceResizedFunc = surfaceResizedFunc;
    }
    return previous;
}

GLFMSurfaceRefreshFunc glfmSetSurfaceRefreshFunc(GLFMDisplay *display, GLFMSurfaceRefreshFunc surfaceRefreshFunc) {
    GLFMSurfaceRefreshFunc previous = NULL;
    if (display) {
        previous = display->surfaceRefreshFunc;
        display->surfaceRefreshFunc = surfaceRefreshFunc;
    }
    return previous;
}

GLFMSurfaceDestroyedFunc glfmSetSurfaceDestroyedFunc(GLFMDisplay *display,
                                                     GLFMSurfaceDestroyedFunc surfaceDestroyedFunc) {
    GLFMSurfaceDestroyedFunc previous = NULL;
    if (display) {
        previous = display->surfaceDestroyedFunc;
        display->surfaceDestroyedFunc = surfaceDestroyedFunc;
    }
    return previous;
}

GLFMKeyboardVisibilityChangedFunc glfmSetKeyboardVisibilityChangedFunc(GLFMDisplay *display,
                                                                       GLFMKeyboardVisibilityChangedFunc func) {
    GLFMKeyboardVisibilityChangedFunc previous = NULL;
    if (display) {
        previous = display->keyboardVisibilityChangedFunc;
        display->keyboardVisibilityChangedFunc = func;
    }
    return previous;
}

GLFMOrientationChangedFunc glfmSetOrientationChangedFunc(GLFMDisplay *display, GLFMOrientationChangedFunc func) {
    GLFMOrientationChangedFunc previous = NULL;
    if (display) {
        previous = display->orientationChangedFunc;
        display->orientationChangedFunc = func;
    }
    return previous;
}

GLFMDisplayChromeInsetsChangedFunc glfmSetDisplayChromeInsetsChangedFunc(GLFMDisplay *display,
                                                                         GLFMDisplayChromeInsetsChangedFunc func) {
    GLFMDisplayChromeInsetsChangedFunc previous = NULL;
    if (display) {
        previous = display->displayChromeInsetsChangedFunc;
        display->displayChromeInsetsChangedFunc = func;
    }
    return previous;
}

GLFMTouchFunc glfmSetTouchFunc(GLFMDisplay *display, GLFMTouchFunc touchFunc) {
    GLFMTouchFunc previous = NULL;
    if (display) {
        previous = display->touchFunc;
        display->touchFunc = touchFunc;
    }
    return previous;
}

GLFMKeyFunc glfmSetKeyFunc(GLFMDisplay *display, GLFMKeyFunc keyFunc) {
    GLFMKeyFunc previous = NULL;
    if (display) {
        previous = display->keyFunc;
        display->keyFunc = keyFunc;
    }
    return previous;
}

GLFMCharFunc glfmSetCharFunc(GLFMDisplay *display, GLFMCharFunc charFunc) {
    GLFMCharFunc previous = NULL;
    if (display) {
        previous = display->charFunc;
        display->charFunc = charFunc;
    }
    return previous;
}

GLFMMouseWheelFunc glfmSetMouseWheelFunc(GLFMDisplay *display, GLFMMouseWheelFunc mouseWheelFunc) {
    GLFMMouseWheelFunc previous = NULL;
    if (display) {
        previous = display->mouseWheelFunc;
        display->mouseWheelFunc = mouseWheelFunc;
    }
    return previous;
}

GLFMSensorFunc glfmSetSensorFunc(GLFMDisplay *display, GLFMSensor sensor, GLFMSensorFunc sensorFunc) {
    GLFMSensorFunc previous = NULL;
    int index = (int)sensor;
    if (display && index >= 0 && index < GLFM_NUM_SENSORS) {
        previous = display->sensorFuncs[index];
        if (sensorFunc != previous) {
            display->sensorFuncs[index] = sensorFunc;
            glfm__sensorFuncUpdated(display);
        }
    }
    return previous;
}

GLFMMemoryWarningFunc glfmSetMemoryWarningFunc(GLFMDisplay *display, GLFMMemoryWarningFunc lowMemoryFunc) {
    GLFMMemoryWarningFunc previous = NULL;
    if (display) {
        previous = display->lowMemoryFunc;
        display->lowMemoryFunc = lowMemoryFunc;
    }
    return previous;
}

GLFMAppFocusFunc glfmSetAppFocusFunc(GLFMDisplay *display, GLFMAppFocusFunc focusFunc) {
    GLFMAppFocusFunc previous = NULL;
    if (display) {
        previous = display->focusFunc;
        display->focusFunc = focusFunc;
    }
    return previous;
}

void glfmSetSwapBehavior(GLFMDisplay *display, GLFMSwapBehavior behavior) {
    if (display) {
        display->swapBehavior = behavior;
    }
}

GLFMSwapBehavior glfmGetSwapBehavior(const GLFMDisplay *display) {
    if (display) {
        return display->swapBehavior;
    }

    return GLFMSwapBehaviorPlatformDefault;
}

// MARK: - Helper functions

static void glfm__reportSurfaceError(GLFMDisplay *display, const char *errorMessage) {
    if (display->surfaceErrorFunc && errorMessage) {
        display->surfaceErrorFunc(display, errorMessage);
    }
}

#ifdef __cplusplus
}
#endif

#endif

```

`tests/README.md`:

```md
# GLFM build tests

The scripts in this directory test building GLFM and the GLFM examples. The analyzer `clang-tidy` is used if it is
available.

## Requirements

* CMake
* Emscripten SDK
* Android SDK/NDK
* Xcode and xcpretty (macOS only)
* clang-tidy (optional)

### Linux host

* Install CMake and clang-tidy with: `sudo apt install cmake clang-tidy`.

### macOS host

* Install Xcode from the App Store or from <https://developer.apple.com/download/applications/>.
* Install CMake and xcpretty: `brew install cmake xcpretty`.
* Optionally, install LLVM for clang-tidy: `brew install llvm`.
* Launch Xcode once to make sure the iOS platform is installed.

### Windows host

* Install Git and CMake: `winget install Git.Git Kitware.CMake`.
* For Emscripten, install Python and Ninja: `winget install python3 Ninja-build.Ninja`.
* For Android, if you use `sdkmanager` directly (see below), install OpenJDK: `winget install openjdk`.
* Optionally, install LLVM for clang-tidy: `winget install LLVM.LLVM`.

### Android

* Install either Android Studio or the Android command line tools from <https://developer.android.com/studio>.
* Install the NDK, either in Android Studio's SDK manager, or using command line with something like:
  ```
  sdkmanager --list | grep ndk
  sdkmanager --install "ndk;28.0.13004108"
  ```
* Set the `ANDROID_NDK_HOME` environment variable to the location of the NDK, which looks something like:
  `~/Library/Android/sdk/ndk/28.0.13004108`.

### Emscripten

Install Emscripten SDK from <https://emscripten.org/docs/getting_started/downloads.html>. Alternatively, on macOS, use
`brew install emscripten`.

The tests require that `emcmake` is in the path.

## Running

Use `./build_all.sh` to run all tests.

On Windows, use `"C:\Program Files\Git\bin\bash.exe" build_all.sh`.

If a build fails, try `./build_all.sh -v`.

## Automated tests

The [build.yml](../.github/workflows/build.yml) GitHub Action builds GLFM automatically for all target platforms and
architectures. Builds fail on compilation warnings or analyzer warnings.

The [build_examples.yml](../.github/workflows/build_examples.yml) GitHub Action builds GLFM examples automatically.
Builds fail if deprecated functions are used.


```

`tests/build_all.sh`:

```sh
#!/bin/sh
#
# Runs all tests available on this system.
#
# Android: Requires ANDROID_NDK_HOME set.
# Apple: Requires xcodebuild.
# Emscripten: Requires emcmake in the path.
#
# For verbose mode, use:
# ./build_all.sh -v

if ! type cmake > /dev/null 2>&1; then
    echo ">>> Error: cmake not found"
    exit 1
fi

while getopts "v" OPTION; do
    case $OPTION in
        v) VERBOSE=1
            ;;
        *)
            ;;
    esac
done

run_test() {
    if [ -n "$VERBOSE" ]; then
        echo ">>> $1"
        "$1"
        result=$?
        printf ">>> %s: " "$1"
    else
        # Execute in background, showing spinner
        printf "%s:  " "$1"
        "$1" > /dev/null 2>&1 &
        pid=$!
        i=0
        spin='-\|/'
        while kill -0 $pid 2>/dev/null; do
            i=$(( i % 4 + 1 ))
            printf "\b%s" "$(echo "$spin" | cut -c $i)"
            sleep .1
        done
        printf "\b"
        wait $pid
        result=$?
    fi
    if [ $result -eq 0 ]; then
        echo "Success"
    else
        echo "Failure"
    fi
}

if [ -z "${ANDROID_NDK_HOME}" ]; then
    echo "./build_android.sh: Skipped (ANDROID_NDK_HOME not set)"
else
    run_test ./build_android.sh
    run_test ./build_android_examples.sh
fi

if ! type xcodebuild > /dev/null 2>&1; then
    echo "./build_apple.sh: Skipped (xcodebuild not found)"
else
    run_test ./build_apple.sh
    run_test ./build_apple_examples.sh
fi

if ! type emcmake > /dev/null 2>&1; then
    echo "./build_emscripten.sh: Skipped (emcmake not found)"
else
    run_test ./build_emscripten.sh
    run_test ./build_emscripten_examples.sh
fi

```

`tests/build_android.sh`:

```sh
#!/bin/sh

if [ -z "${ANDROID_NDK_HOME}" ]; then
    echo "Error: ANDROID_NDK_HOME not set"
    exit 1
fi

NDK_MAJOR_VERSION=$(grep "Pkg.Revision" "$ANDROID_NDK_HOME"/source.properties | sed -e 's/Pkg.Revision = \([0-9]*\).*/\1/')
if [ "$NDK_MAJOR_VERSION" -lt 17 ]; then
    echo "Error: NDK 17 or newer required"
    exit 1
fi

WIN64_MAKE=$ANDROID_NDK_HOME/prebuilt/windows-x86_64/bin/make.exe
if [ -f "$WIN64_MAKE" ]; then
    set -- "$@" -G "Unix Makefiles" -D CMAKE_MAKE_PROGRAM="$WIN64_MAKE"
fi

for abi in "armeabi-v7a" "armeabi-v7a with NEON" "arm64-v8a" "x86" "x86_64"; do
    if [ "$abi" = "x86_64" ] && [ "$NDK_MAJOR_VERSION" -lt 19 ]; then
        # An error in NDK 18 (and older) prevents CMake from finding x86_64 libraries.
        echo ">>> Android: Skipping ABI $abi (NDK 19 or newer required)"
        continue
    fi
    echo ">>> Android: Building ABI $abi"
    rm -rf "build/android_$abi"
    cmake -S .. -B "build/android_$abi" \
        -D GLFM_USE_CLANG_TIDY=ON \
        -D CMAKE_TOOLCHAIN_FILE="$ANDROID_NDK_HOME"/build/cmake/android.toolchain.cmake \
        -D CMAKE_C_FLAGS=-Werror \
        -D CMAKE_VERBOSE_MAKEFILE=ON \
        -D ANDROID_ABI="$abi" \
        "$@" || exit $?
    cmake --build "build/android_$abi" || exit $?
done

```

`tests/build_android_examples.sh`:

```sh
#!/bin/sh

if [ -z "${ANDROID_NDK_HOME}" ]; then
    echo "Error: ANDROID_NDK_HOME not set"
    exit 1
fi

NDK_MAJOR_VERSION=$(grep "Pkg.Revision" "$ANDROID_NDK_HOME"/source.properties | sed -e 's/Pkg.Revision = \([0-9]*\).*/\1/')
if [ "$NDK_MAJOR_VERSION" -lt 17 ]; then
    echo "Error: NDK 17 or newer required"
    exit 1
fi

WIN64_MAKE=$ANDROID_NDK_HOME/prebuilt/windows-x86_64/bin/make.exe
if [ -f "$WIN64_MAKE" ]; then
    set -- "$@" -G "Unix Makefiles" -D CMAKE_MAKE_PROGRAM="$WIN64_MAKE"
fi

rm -rf build/android_examples
cmake -D GLFM_BUILD_EXAMPLES=ON \
    -D CMAKE_TOOLCHAIN_FILE="$ANDROID_NDK_HOME"/build/cmake/android.toolchain.cmake \
    -D CMAKE_C_FLAGS=-Werror=deprecated-declarations \
    -D CMAKE_VERBOSE_MAKEFILE=ON \
    "$@" \
    -S .. -B build/android_examples || exit $?
cmake --build build/android_examples || exit $?

```

`tests/build_apple.sh`:

```sh
#!/bin/sh

if ! type xcodebuild > /dev/null 2>&1; then
    echo "Error: xcodebuild not found"
    exit 1
fi
if ! type xcpretty > /dev/null 2>&1; then
    echo ">>> Skipping analyze step: xcpretty not found"
else
    has_xcpretty=1
fi

# Find clang-tidy either in the path or installed via brew
if ! clang_tidy=$(which clang-tidy 2>/dev/null || which "$(brew --prefix llvm)"/bin/clang-tidy 2>/dev/null); then
    echo ">>> Skipping analyze step: clang-tidy not found"
else
    has_clang_tidy=1
fi

export CFLAGS=-Werror

# Check failure when cmake piped to xcpretty
set -o pipefail

for objc_arc in YES NO; do
    builddir="build/apple_objc_arc_$objc_arc"

    rm -rf "$builddir"

    cmake -S .. -B "$builddir" \
        -G Xcode \
        -D CMAKE_XCODE_ATTRIBUTE_ONLY_ACTIVE_ARCH=NO \
        -D CMAKE_XCODE_ATTRIBUTE_CLANG_ENABLE_OBJC_ARC="$objc_arc" || exit $?

    for sdk in appletvos appletvsimulator iphoneos iphonesimulator macosx; do
        echo ">>> Apple: Building $sdk (OBJC_ARC=$objc_arc)"
        if [ ! "$has_xcpretty" ] || [ ! "$has_clang_tidy" ]; then
            cmake --build "$builddir" -- -sdk "$sdk" || exit $?
        else
            cmake --build "$builddir" -- -sdk "$sdk" \
                | xcpretty -r json-compilation-database --output "$builddir"/compile_commands.json || exit $?

            # Don't analyze simulators, which share code (building is included to targeting multiple archs)
            if echo "$sdk" | grep -q "simulator"; then
                continue
            fi

            echo ">>> Apple: Analyzing $sdk (OBJC_ARC=$objc_arc)"

            # Remove "ivfsstatcache" flag from compile_commands.json.
            # Current clang-tidy version (16.0.1) doesn't understand "ivfsstatcache" flag from xcodebuild 14.3.
            sed -i.bak 's/ -ivfsstatcache [^ ]* / /g' "$builddir"/compile_commands.json

            # Use compile_commands.json generated from xcpretty to run clang-tidy. This will also check header files.
            # Since GLFM for Apple has only one source file, it is easy to just specify glfm_apple.m.
            # For bigger projects, the filenames could be parsed from compile_commands.json.
            $clang_tidy --config-file=clang-tidy-analyze.yml -p "$builddir" ../src/glfm_apple.m || exit $?
        fi
    done
done

```

`tests/build_apple_examples.sh`:

```sh
#!/bin/sh

if ! type xcodebuild > /dev/null 2>&1; then
    echo "Error: xcodebuild not found"
    exit 1
fi

export CFLAGS=-Werror=deprecated-declarations

rm -rf build/apple_examples

cmake -S .. -B build/apple_examples -G Xcode \
    -D GLFM_BUILD_EXAMPLES=ON \
    -D CMAKE_XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY="" \
    -D CMAKE_XCODE_ATTRIBUTE_CODE_SIGNING_REQUIRED=NO || exit $?

for sdk in appletvos iphoneos macosx; do
    echo ">>> Apple: Building examples for $sdk"
    cmake --build build/apple_examples -- -sdk "$sdk" || exit $?
done

```

`tests/build_emscripten.sh`:

```sh
#!/bin/sh

if ! type emcmake > /dev/null 2>&1; then
    echo "Error: emcmake not found"
    exit 1
fi

export CFLAGS=-Werror

rm -rf build/emscripten
emcmake cmake -S .. -B build/emscripten \
    -D GLFM_USE_CLANG_TIDY=ON \
    -D CMAKE_VERBOSE_MAKEFILE=ON || exit $?
cmake --build build/emscripten

```

`tests/build_emscripten_examples.sh`:

```sh
#!/bin/sh

if ! type emcmake > /dev/null 2>&1; then
    echo "Error: emcmake not found"
    exit 1
fi

export CFLAGS=-Werror=deprecated-declarations

rm -rf build/emscripten_examples
emcmake cmake -S .. -B build/emscripten_examples \
    -D GLFM_BUILD_EXAMPLES=ON \
    -D CMAKE_VERBOSE_MAKEFILE=ON || exit $?
cmake --build build/emscripten_examples

```

`tests/clang-tidy-analyze.yml`:

```yml
InheritParentConfig: true
Checks: >
  clang-analyzer-*,
  clang-diagnostic-*,
  -clang-analyzer-optin.performance.Padding,
  -clang-analyzer-optin.core.EnumCastOutOfRange
HeaderFilterRegex: '.*'
WarningsAsErrors: '*'

```