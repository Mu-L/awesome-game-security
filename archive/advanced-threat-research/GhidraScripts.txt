Project Path: arc_advanced-threat-research_GhidraScripts_64vh_uc6

Source Tree:

```txt
arc_advanced-threat-research_GhidraScripts_64vh_uc6
├── Automagic.java
├── AutomaticallyCreateFunctionIdDatabases.java
├── BsimFunctionRenamer.java
├── ColouriseByComplexity.java
├── GhidrAI.java
├── GolangDynamicStringRecovery.java
├── GolangFunctionRecovery.java
├── GolangRecovery.java
├── GolangStaticStringRecovery.java
├── GolangTypeRecovery.java
├── LICENSE
├── MalpediaFlossedCheckLocal.java
├── MalpediaFlossedCheckWebApi.java
├── README.md
├── Sharem.java
└── images
    ├── bundleManager.png
    ├── displayScriptManager.png
    └── scriptManager.png

```

`Automagic.java`:

```java
//This script is meant to automate the usage of temporary FIDBs, allows you to use multiple BSim databases per file to recover functions, use file metadata recovery scripts (Golang or Nim, for example), and allows you to use a LLM to further annotate the code. Next, the script adds some graphical elements by colourising complex function calls as dark red while non-complex functions are marked as light red. 
//@author Max 'Libra' Kersten for Trellix
//@category 
//@keybinding
//@menupath
//@toolbar

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ghidra.app.plugin.core.analysis.AutoAnalysisManager;
import ghidra.app.script.GhidraScript;
import ghidra.app.services.Analyzer;
import ghidra.feature.fid.db.FidFile;
import ghidra.feature.fid.db.FidFileManager;
import ghidra.program.model.listing.Program;
import ghidra.util.SystemUtilities;
import ghidra.util.exception.CancelledException;

public class Automagic extends GhidraScript {

	/**
	 * The Function ID analyzer name, taken from Ghidra's source code
	 */
	private static final String FUNCTION_ID_ANALYZER = "Function ID";

	/**
	 * The auto analysis manager within Ghidra, used to check if one or more
	 * analyzers are still running
	 */
	private AutoAnalysisManager autoAnalysisManager;

	/**
	 * The Function ID database file manager
	 */
	private FidFileManager fidFileManager;

	@Override
	protected void run() throws Exception {
		/*
		 * Initialise variables which are used in functions later on
		 */
		autoAnalysisManager = AutoAnalysisManager.getAnalysisManager(currentProgram);
		fidFileManager = FidFileManager.getInstance();

		/*
		 * Obtain all required arguments for all scripts
		 */

		/*
		 * Example CLI input for this script:
		 * 
		 * [true/false if extra fidb databases should be used] [path/to/fidb/files]
		 * [true/false if bsim renaming should be used] [path/to/bsim.config]
		 * [true/false if an LLM should be used to rename information] [LLM AI API URL]
		 * [true/false to decide if functions need to be renamed] [true/false to decide
		 * if variables need to be renamed]
		 */
		boolean useFidb = askYesNo("Additional FIDB files", "Use additional FIDB files?");
		String fidFolderPath = askString("Location of additional FIDBs",
				"What is the folder where the additional FIDB files are located?");
		boolean useBSimRenamer = askYesNo("Use BSim?", "Use BSim to rename matches?");
		String bsimConfigPath = askString("BSim configuration file location",
				"What is the location of the BSim configuration file?");
		boolean useGhidrAI = askYesNo("GhidrAI LLM usage",
				"Use the GhidrAI script to rename functions, variables, and summarise functions?");
		String ghidraiApiUrl = askString("GhidrAI LLM API endpoint", "What is the API URL of the LLM?");
		boolean ghidraiRenameFunctions = askYesNo("Rename functions", "Rename functions based on AI suggestions?");
		boolean ghidraiRenameVariables = askYesNo("Rename variables", "Rename variables based on AI suggestions?");

		/*
		 * End of obtaining arguments for all scripts
		 */

		/*
		 * Test the validity of all script arguments, prior to making changes to the
		 * current program. Values asked via the askValues (or specific ask* functions)
		 * cannot be null, so there is no need to check for the null-state.
		 */

		File fidFolder = new File(fidFolderPath);
		if (useFidb) {
			// Check if the FID folder exists
			if (fidFolder.exists() == false) {
				throw new IOException("The provided FIDB folder does not exist: " + fidFolder.getAbsolutePath());
			}

			/*
			 * Check if the provided existing path is a folder by throwing an exception if
			 * it is a file
			 */
			if (fidFolder.isFile()) {
				throw new IOException("The provided FIDB folder is a file: " + fidFolder.getAbsolutePath());
			}
		}

		List<BSimExecutionConfig> configs = null;
		if (useBSimRenamer) {
			File bsimConfigFile = new File(bsimConfigPath);

			// Check if the BSim config file exists
			if (bsimConfigFile.exists() == false) {
				throw new IOException("The provided BSim file does not exist: " + bsimConfigPath);
			}

			/*
			 * Check if the provided existing path is a file by throwing an exception if it
			 * is a folder
			 */
			if (bsimConfigFile.isDirectory()) {
				throw new IOException("The provided BSim path is a directory: " + bsimConfigPath);
			}

			// Parse all configs from the existing BSim config file
			configs = parseBSimExecutionConfigs(bsimConfigFile);
		}

		/*
		 * Metadata analysis is the closest ground truth that is available from the
		 * lossy compilation process. Recovering names from Golang's pclntab and
		 * demangling Nim function names are included, but any type of metadata related
		 * script should be put in this section.
		 */

		/*
		 * Recover function names, types, and strings (both dynamic and static), based
		 * on the pclntab. More information can be found here:
		 * https://www.trellix.com/blogs/research/feeding-gophers-to-ghidra/
		 */
		runScriptAndWait("GolangRecovery", false);

		/*
		 * Demangle Nim function names and recover Nim strings, made by ESET's Alexandre
		 * Côté Cyr. More information on ESET's blog:
		 * https://www.welivesecurity.com/en/eset-research/introducing-nimfilt-reverse-
		 * engineering-tool-nim-compiled-binaries/
		 * 
		 * The GitHub repository with the scripts: https://github.com/eset/nimfilt
		 */
		runScriptAndWait("NimFilt", false);

		/*
		 * Load and activate all FID databases from a given folder. All newly loaded and
		 * activated FID databases are returned in a list, allowing for easy removal
		 * from the attached FID databases list later on.
		 */
		List<FidFile> additionalFids = loadAdditionalFunctionIdDatabases(fidFolder);

		// Apply FunctionID signatures from the loaded FID databases
		runAnalyzer(FUNCTION_ID_ANALYZER);

		// Run the BSim rename script for all given and previously parsed configs
		if (useBSimRenamer) {
			runBSimRenamer(configs);
		}

		// Run the GhidrAI rename and summary script
		if (useGhidrAI) {
			runGhidrAI(ghidraiApiUrl, ghidraiRenameFunctions, ghidraiRenameVariables);
		}

		/*
		 * Propagate the parameters for external functions. This is done by running
		 * Ghidra's Propagatex86ExternalParams for 32-bit programs. For 64-bit programs,
		 * the variant of Karsten Hahn (aka struppigel) is used (originally found at
		 * https://github.com/struppigel/hedgehog-tools/blob/main/ghidra_scripts/
		 * PropagateExternalParametersX64.java)
		 * 
		 * The function to get the bitness returns -1 if an error is found, which is why
		 * the if- and else-if-clauses are set to a specific number without the usage of
		 * an else-clause.
		 */
		int bitness = getBitness();
		if (bitness == 32) {
			runScriptAndWait("PropagateExternalParametersScript", false);
		} else if (bitness == 64) {
			runScriptAndWait("PropagateExternalParametersX64", false);
		}

		/*
		 * Colour function call instructions based on the complexity depth level of the
		 * called function
		 */
		runScriptAndWait("ColouriseByComplexity", false);

		// Restore original FID database selection
		restoreOriginalFunctionIdDatabaseSelection(additionalFids);
	}

	/**
	 * Prints the given message via the
	 * {@link ghidra.app.script.GhidraScript#println(String)} method, depending on
	 * the running mode and boolean.
	 * 
	 * @param message       the message to print
	 * @param printHeadless true if the message should be printed when executing
	 *                      headless, false if not
	 */
	private void log(String message, boolean printHeadless) {
		if (SystemUtilities.isInHeadlessMode()) {
			if (printHeadless == false) {
				return;
			}
		}
		println(message);
	}

	/**
	 * A wrapper for {@link #runScriptAndWait(String, String[], boolean)} to run a
	 * script without any arguments
	 * 
	 * @param scriptName      the name of the script
	 * @param throwExceptions if the execution of the script should throw
	 *                        encountered exceptions, or if they should be caught
	 * @throws Exception the exception which is thrown if the second argument is
	 *                   true
	 */
	private void runScriptAndWait(String scriptName, boolean throwExceptions) throws Exception {
		runScriptAndWait(scriptName, null, throwExceptions);
	}

	/**
	 * Runs a script and waits until its execution is complete
	 * 
	 * @param scriptName      the name of the script
	 * @param scriptArguments arguments for the script, may be <code>null</code>
	 * @param throwExceptions if the execution of the script should throw
	 *                        encountered exceptions, or if they should be caught
	 * @throws Exception
	 */
	private void runScriptAndWait(String scriptName, String[] scriptArguments, boolean throwExceptions)
			throws Exception {
		try {
			log("Running " + scriptName, true);
			runScript(scriptName, scriptArguments, getState());
			waitUntilAutoAnalysisCompletes();
			log("Finished " + scriptName, true);
		} catch (Exception ex) {
			if (throwExceptions) {
				throw ex;
			}
			printerr(ex.toString());
		}
	}

	/**
	 * Run an analyzer based on its name
	 * 
	 * @param analyzerName the name of the analyzer to run
	 * @throws InterruptedException
	 * @throws CancelledException
	 */
	private void runAnalyzer(String analyzerName) throws InterruptedException, CancelledException {
		Analyzer analyzer = autoAnalysisManager.getAnalyzer(analyzerName);
		autoAnalysisManager.scheduleOneTimeAnalysis(analyzer, currentProgram.getAddressFactory().getAddressSet());
		waitUntilAutoAnalysisCompletes();
	}

	/**
	 * Wait until no analyzers are running anymore
	 * 
	 * @throws InterruptedException
	 * @throws CancelledException
	 */
	private void waitUntilAutoAnalysisCompletes() throws InterruptedException, CancelledException {
		while (autoAnalysisManager.isAnalyzing()) {
			if (monitor.isCancelled()) {
				throw new CancelledException();
			}
			Thread.sleep(1000); // Sleep to avoid consuming extra CPU cycles in-between checks
		}
	}

	private void runGhidrAI(String apiUrl, boolean renameFunctions, boolean renameVariables) throws Exception {
		/*
		 * Required information to run GhidrAI:
		 * 
		 * - AI API URL
		 * 
		 * - Rename function based on suggestion: yes/no
		 * 
		 * - Rename variables based on suggestions: yes/no
		 */
		String[] ghidraiArgs = new String[3];
		ghidraiArgs[0] = apiUrl; // AI API URL
		ghidraiArgs[1] = "" + renameFunctions; // suggest function name
		ghidraiArgs[2] = "" + renameVariables; // rename based on suggestion
		runScriptAndWait("GhidrAI", ghidraiArgs, false);
	}

	private String replaceLastOccurrence(String original, String target, String replacement) {
		int lastIndex = original.lastIndexOf(target);
		if (lastIndex == -1) {
			return original; // Target string not found
		}
		String beforeLastOccurrence = original.substring(0, lastIndex);
		String afterLastOccurrence = original.substring(lastIndex + target.length());
		return beforeLastOccurrence + replacement + afterLastOccurrence;
	}

	private List<BSimExecutionConfig> parseBSimExecutionConfigs(File file) throws IOException {
		List<BSimExecutionConfig> configs = new ArrayList<>();
		int nonParsableLines = 0;

		List<String> lines = new ArrayList<>();
		try {
			lines = Files.readAllLines(file.toPath());
		} catch (IOException ex) {
			printerr("Failed to read the file with the referenced BSim files: " + file.getAbsolutePath());
			throw ex;
		}

		if (lines.isEmpty()) {
			throw new IOException("No lines present in the BSim config file!");
		}

		for (String line : lines) {
			if (line.startsWith("#")) {
				nonParsableLines++;
				continue;
			}
			int errorCount = 0;
			println("Parsing the following BSim config file line: " + line);

			String[] split = line.split(",");
			if (split.length < 6 || split.length > 7) {
				printerr(
						"Not all data is present within the given line, the length should be 6 or 7, whereas the length of this line is only "
								+ split.length);
				errorCount++;
			}

			String databaseUrl = split[0];
			if (databaseUrl.endsWith(".mv.db")) {
				databaseUrl = replaceLastOccurrence(databaseUrl, ".mv.db", "");
				println("Removed the .mv.db extension from the database file path: " + databaseUrl);
			}
			File database = new File(databaseUrl + ".mv.db");
			if (database.exists() == false) {
				printerr("The provided database does not exist: " + databaseUrl);
				errorCount++;
			}
			if (database.isDirectory()) {
				printerr("The provided database url is a folder: " + databaseUrl);
				errorCount++;
			}

			double lowerSimilartyBound = -1;
			try {
				lowerSimilartyBound = Double.parseDouble(split[1]);
			} catch (Exception ex) {
				printerr("The lower similarity bound is not a double: " + split[1]);
				errorCount++;
			}

			int maximumNumberOfMatches = -1;
			try {
				maximumNumberOfMatches = Integer.parseInt(split[2]);
			} catch (Exception ex) {
				printerr("The maximum number of matches is not an integer: " + split[2]);
				errorCount++;
			}

			/*
			 * Booleans parsed by Boolean.parseBoolean (and similar functions) return true
			 * for any spelling of true, and return false for anything else. This is not the
			 * check we want here, as we want to have either true or false as a value,
			 * anything else is incorrect. Thus, testing of the literal string value is what
			 * we need.
			 */
			String renameSingleMatchesString = split[3];
			boolean renameSingleMatches = false;
			if (renameSingleMatchesString.equalsIgnoreCase("true")) {
				renameSingleMatches = true;
			} else if (renameSingleMatchesString.equalsIgnoreCase("false")) {
				renameSingleMatches = false;
			} else {
				printerr("The boolean value to define if single matches should be renamed is neither true nor false: "
						+ renameSingleMatches);
				errorCount++;
			}

			String renameMultiMatchesString = split[4];
			boolean renameMultiMatches = false;
			if (renameMultiMatchesString.equalsIgnoreCase("true")) {
				renameMultiMatches = true;
			} else if (renameMultiMatchesString.equalsIgnoreCase("false")) {
				renameMultiMatches = false;
			} else {
				printerr("The boolean value to define if multi-matches should be renamed is neither true nor false: "
						+ renameMultiMatchesString);
				errorCount++;
			}

			String renameGenericMatchesString = split[5];
			boolean renameGenericMatches = false;
			if (renameGenericMatchesString.equalsIgnoreCase("true")) {
				renameGenericMatches = true;
			} else if (renameGenericMatchesString.equalsIgnoreCase("false")) {
				renameGenericMatches = false;
			} else {
				printerr("The boolean value to define if generic matches should be renamed is neither true nor false: "
						+ renameGenericMatchesString);
				errorCount++;
			}

			String customPrefix = null;
			if (split.length == 7) {
				customPrefix = split[6];
				if (customPrefix == null || customPrefix.isBlank()) {
					printerr("The required custom prefix has not been provided or is left blank while it is needed!");
					errorCount++;
				}
			}

			/*
			 * Required arguments, in order, split by a comma, should be:
			 * 
			 * - database URL, without any of the file extensions (the H2 database has two,
			 * neither should be included)
			 * 
			 * - the lower similarity bound between 0 and 1, as a double (i.e. 0.7)
			 * 
			 * - the maximum number of BSim matches per local function (i.e. 20)
			 * 
			 * - a boolean (true or false) which decides if single matches should be renamed
			 * 
			 * - a boolean (true or false) which decides if multi-matches should be renamed
			 * 
			 * - a boolean (true or false) which decides if generic matches should be
			 * renamed (if true, a 7th argument is required, otherwise it isn't)
			 * 
			 * - a String which is the prefix used when renaming generic matches
			 */

			// If there are no errors, this value should be zero
			if (errorCount == 0) {
				// Create the custom object
				BSimExecutionConfig config = new BSimExecutionConfig(databaseUrl, lowerSimilartyBound,
						maximumNumberOfMatches, renameSingleMatches, renameMultiMatches, renameGenericMatches,
						customPrefix);
				// Add the config to the list
				configs.add(config);
				// Notify the analyst
				println("Created the config object!");
			} else {
				// Print the error
				printerr("The config hasn't been parsed!");
			}
		}

		// Check if all lines have been parsed
		if ((configs.size() + nonParsableLines) == lines.size()) {
			// All lines have been parsed successfully
			return configs;
		}
		// If this is not the case, there were errors
		throw new IOException("Not all BSim configs were parsed correctly!");
	}

	private void runBSimRenamer(List<BSimExecutionConfig> configs) throws Exception {
		for (BSimExecutionConfig config : configs) {
			/*
			 * If the database does not match the current program, it is not to be used.
			 * There wont be (valid) results for the current program, and will only consume
			 * a lot of time. Using a large H2 database is never fast, but can be terribly
			 * slow if it is really large. A high(er) number of maximum matches will also
			 * increase the runtime.
			 * 
			 * This method is based on the naming scheme of the H2 databases that are
			 * linked, which is not the easiest approach, but works well as a best-effort
			 * method.
			 */
			if (bsimDatabaseMatches(config.getDatabaseUrl()) == false) {
				continue;
			}

			int size = 6;
			if (config.getPrefix() != null) {
				size = 7;
			}
			String[] bsimFunctionRenamerArgs = new String[size];
			bsimFunctionRenamerArgs[0] = config.getDatabaseUrl(); // database URL
			bsimFunctionRenamerArgs[1] = "" + config.getLowerSimilarityBound(); // lower similarity bound
			bsimFunctionRenamerArgs[2] = "" + config.getMaximumMatches(); // maximum bsim matches per local function
			bsimFunctionRenamerArgs[3] = "" + config.renameSingleMatches(); // rename single matches
			bsimFunctionRenamerArgs[4] = "" + config.renameMultiMatches(); // rename multi-matches
			bsimFunctionRenamerArgs[5] = "" + config.renameGenericMatches(); // rename generic matches
			if (size == 7) {
				bsimFunctionRenamerArgs[6] = config.getPrefix(); // the custom prefix to use
			}

			runScriptAndWait("BsimFunctionRenamer", bsimFunctionRenamerArgs, false);
		}
	}

	private boolean bsimDatabaseMatches(String databaseUrl) {
		/*
		 * TODO handle bsim files based on their file name, automatically excluding
		 * architectures which are incorrect for the given file, thus saving a lot of
		 * time when dealing with large H2 databases.
		 * 
		 * This can be done by running some extra checks:
		 * 
		 * -Check the language ID of the BSim database and the current program (keep in
		 * mind that "medium nosize" allows 32-bit and 64-bit signatures to
		 * mix-and-match
		 * 
		 * C:\Users\malwa\Desktop\bsim-signatures\bsim.rust.windows.x86_64.h2.medium-
		 * nosize
		 */

		/*
		 * Assume the database is a file which exists, as this check has been performed
		 * before
		 */
		File databaseUrlFile = new File(databaseUrl);
		BsimFileNameContainer container = convertIntoContainer(databaseUrlFile.getName());
		// Container is null if the file name format does not match
		if (container == null) {
			return true;
		}

		String executableFormat = currentProgram.getExecutableFormat(); // i.e. Portable Executable (PE)
		String cspec = currentProgram.getCompilerSpec().getCompilerSpecID().getIdAsString(); // i.e. windows
		String languageId = currentProgram.getLanguage().getLanguageID().getIdAsString(); // i.e. x86:LE:32:default

		if (container.getPlatform().equalsIgnoreCase("windows")) {
			if (executableFormat.equalsIgnoreCase("Portable Executable (PE)")
					|| cspec.equalsIgnoreCase(container.getPlatform())) {
				// Matches, continue onwards
			}
		} else if (container.getPlatform().equalsIgnoreCase("linux")) {
			if (executableFormat.equalsIgnoreCase("Executable and Linking Format (ELF)")
					|| cspec.equalsIgnoreCase(container.getPlatform())) {
				// Matches, continue onwards
			}
		} else if (container.getPlatform().equalsIgnoreCase("apple")
				|| container.getPlatform().equalsIgnoreCase("macos")) {
			if (executableFormat.equalsIgnoreCase("Mac OS X Mach-O")
					|| cspec.equalsIgnoreCase(container.getPlatform())) {
				// Matches, continue onwards
			}
		}

		String[] languageIdSplit = languageId.split(":");
		if (languageIdSplit.length == 4) {
			// TODO get uniform check for the language ID
			/*
			 * TODO ensure that the databaseSize cases with "medium-nosize" includes cross
			 * architecture options as 32-bits and 64-bits signatures are used
			 * interchangeably (to a certain extend)
			 */
			String architecture = languageIdSplit[0] + languageIdSplit[2];
		} else {
			// Cannot confirm the type, but it should have a length of 4: x86:LE:32:default
		}

		// TODO update the return value once the function is complete
		return true;
	}

	private BsimFileNameContainer convertIntoContainer(String fileName) {
		String[] split = fileName.split("\\.");
		if (split.length == 6) {
			String bsim = split[0];
			String library = split[1];
			String platform = split[2];
			String architecture = split[3];
			String databaseType = split[4];
			String databaseSize = split[5];
			return new BsimFileNameContainer(bsim, library, platform, architecture, databaseType, databaseSize);
		}
		return null;
	}

	class BsimFileNameContainer {
		private String bsim;
		private String library;
		private String platform;
		private String architecture;
		private String databaseType;
		private String databaseSize;

		public BsimFileNameContainer(String bsim, String library, String platform, String architecture,
				String databaseType, String databaseSize) {
			super();
			this.bsim = bsim;
			this.library = library;
			this.platform = platform;
			this.architecture = architecture;
			this.databaseType = databaseType;
			this.databaseSize = databaseSize;
		}

		public String getBsim() {
			return bsim;
		}

		public String getLibrary() {
			return library;
		}

		public String getPlatform() {
			return platform;
		}

		public String getArchitecture() {
			return architecture;
		}

		public String getDatabaseType() {
			return databaseType;
		}

		public String getDatabaseSize() {
			return databaseSize;
		}
	}

	/**
	 * Loads all files ending with .FIDB from the givne folder
	 * 
	 * @param folder the folder to load the function ID files from
	 * @return a list of loaded FID files
	 */
	private List<FidFile> loadAdditionalFunctionIdDatabases(File folder) {
		List<FidFile> fids = new ArrayList<>();

		for (File file : folder.listFiles()) {
			if (file.isFile() == false) {
				continue;
			}

			if (file.getName().endsWith(".fidb")) {
				int size = fidFileManager.getFidFiles().size();
				FidFile fidFile = fidFileManager.addUserFidFile(file);
				if (fidFile != null) {
					fidFile.setActive(true);
					/*
					 * Adding a valid FIDB file is always possible, even if its already known to
					 * Ghidra. Thus, a check is added to see if the total number of FIDB files has
					 * increased. If it was already known, this is not the case. If it wasn't, then
					 * it is. To avoid removing a FIDB from the already known FIDB list, the FIDB
					 * file will only be added to the list if Ghidra added a new FIDB to its known
					 * list.
					 */
					if (fidFileManager.getFidFiles().size() > size) {
						fids.add(fidFile);
						println("Added \"" + fidFile.getName() + "\" to the active loaded FunctionID databases!");
					}
				}
			}
		}

		return fids;
	}

	/**
	 * Restore the original FIDB selection. This unloads the previously loaded FIDBs
	 * @param extraFunctionIdDatabases the list of previously loaded FID files
	 */
	private void restoreOriginalFunctionIdDatabaseSelection(List<FidFile> extraFunctionIdDatabases) {
		for (FidFile fidFile : extraFunctionIdDatabases) {
			fidFileManager.removeUserFile(fidFile);
			println("Removed \"" + fidFile.getName() + "\" from the loaded FunctionID databases!");
		}
	}

	/**
	 * Gets the program's bitness
	 * 
	 * @return the bitness as an integer, or -1 if an error occurs
	 */
	private int getBitness() {
		Map<String, String> mapping = currentProgram.getMetadata();
		String bitness = mapping.get("Address Size");
		try {
			return Integer.parseInt(bitness);
		} catch (Exception ex) {
			printerr(ex.toString());
			return -1;
		}
	}

	class BSimExecutionConfig {
		private String databaseUrl;
		private double lowerSimilarityBound;
		private int maximumMatches;
		private boolean renameSingleMatches;
		private boolean renameMultiMatches;
		private boolean renameGenericMatches;
		private String prefix;

		public BSimExecutionConfig(String databaseUrl, double lowerSimilarityBound, int maximumMatches,
				boolean renameSingleMatches, boolean renameMultiMatches, boolean renameGenericMatches, String prefix) {
			this.databaseUrl = databaseUrl;
			this.lowerSimilarityBound = lowerSimilarityBound;
			this.maximumMatches = maximumMatches;
			this.renameSingleMatches = renameSingleMatches;
			this.renameMultiMatches = renameMultiMatches;
			this.renameGenericMatches = renameGenericMatches;
			this.prefix = prefix;
		}

		public String getDatabaseUrl() {
			return databaseUrl;
		}

		public void setDatabaseUrl(String databaseUrl) {
			this.databaseUrl = databaseUrl;
		}

		public double getLowerSimilarityBound() {
			return lowerSimilarityBound;
		}

		public void setLowerSimilarityBound(double lowerSimilarityBound) {
			this.lowerSimilarityBound = lowerSimilarityBound;
		}

		public int getMaximumMatches() {
			return maximumMatches;
		}

		public void setMaximumMatches(int maximumMatches) {
			this.maximumMatches = maximumMatches;
		}

		public boolean renameSingleMatches() {
			return renameSingleMatches;
		}

		public void setRenameSingleMatches(boolean renameSingleMatches) {
			this.renameSingleMatches = renameSingleMatches;
		}

		public boolean renameMultiMatches() {
			return renameMultiMatches;
		}

		public void setRenameMultiMatches(boolean renameMultiMatches) {
			this.renameMultiMatches = renameMultiMatches;
		}

		public boolean renameGenericMatches() {
			return renameGenericMatches;
		}

		public void setRenameGenericMatches(boolean renameGenericMatches) {
			this.renameGenericMatches = renameGenericMatches;
		}

		public String getPrefix() {
			return prefix;
		}

		public void setPrefix(String prefix) {
			this.prefix = prefix;
		}
	}
}
```

`AutomaticallyCreateFunctionIdDatabases.java`:

```java

//A script to headlessly create FIDB files based on all programs within the given project. Based on "CreateMultipleLibraries.java" by the Ghidra team, inspired by Threatrack's work (https://blog.threatrack.de/2019/09/20/ghidra-fid-generator/)
//@author Max 'Libra' Kersten for Trellix
//@category FunctionID
//@keybinding
//@menupath
//@toolbar
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeSet;

import ghidra.app.script.GhidraScript;
import ghidra.feature.fid.db.FidDB;
import ghidra.feature.fid.db.FidFile;
import ghidra.feature.fid.db.FidFileManager;
import ghidra.feature.fid.db.LibraryRecord;
import ghidra.feature.fid.service.FidPopulateResult;
import ghidra.feature.fid.service.FidPopulateResult.Disposition;
import ghidra.feature.fid.service.FidPopulateResultReporter;
import ghidra.feature.fid.service.FidService;
import ghidra.feature.fid.service.Location;
import ghidra.framework.model.DomainFile;
import ghidra.framework.model.DomainFolder;
import ghidra.program.database.ProgramContentHandler;
import ghidra.program.model.lang.LanguageID;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.util.Msg;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.VersionException;
import ghidra.util.task.TaskMonitor;

public class AutomaticallyCreateFunctionIdDatabases extends GhidraScript {

	/**
	 * The Function ID service to be used
	 */
	private FidService fidService;

	/**
	 * The path to the log file where all logs are written (appended) to
	 */
	private Path logFile;

	/**
	 * Logs a message to Ghidra's console and to the log file in the specified
	 * output folder
	 * 
	 * @param message the message to print and write
	 */
	private void log(String message, boolean isError) {
		/*
		 * Write the (error) message to Ghidra's console, depending on the given boolean
		 */
		if (isError) {
			printerr(message);
		} else {
			println(message);
		}

		/*
		 * Try to append data to the log file
		 */
		try {
			// Append the error tag if the message is an error
			if (isError) {
				message = "ERROR: " + message;
			}
			// Append a newline to the message
			message += "\n";
			// Write the data to the log file
			Files.write(logFile, message.getBytes(), StandardOpenOption.APPEND);
		} catch (IOException e) {
			// Ignore exceptions, the console log already contains the logged information
		}
	}

	/**
	 * The reporter class, which implements the required Ghidra report class
	 */
	class FidReporter implements FidPopulateResultReporter {
		@Override
		public void report(FidPopulateResult result) {
			// Check if a result is given, if not, simply return
			if (result == null) {
				return;
			}

			// Get the library record from the result
			LibraryRecord libraryRecord = result.getLibraryRecord();

			// Get the library family name, version, and variant
			String libraryFamilyName = libraryRecord.getLibraryFamilyName();
			String libraryVersion = libraryRecord.getLibraryVersion();
			String libraryVariant = libraryRecord.getLibraryVariant();

			// Log the obtained information
			log(libraryFamilyName + ':' + libraryVersion + ':' + libraryVariant, false);

			// Log the attempted, added, and excluded count for the generated FIDB
			log(result.getTotalAttempted() + " total functions visited", false);
			log(result.getTotalAdded() + " total functions added", false);
			log(result.getTotalExcluded() + " total functions excluded", false);

			// Log all exclusions
			log("Breakdown of exclusions:", false);
			for (Entry<Disposition, Integer> entry : result.getFailures().entrySet()) {
				if (entry.getKey() != Disposition.INCLUDED) {
					log("    " + entry.getKey() + ": " + entry.getValue(), false);
				}
			}
			// Log all unresolved symbols
			log("List of unresolved symbols:", false);
			TreeSet<String> symbols = new TreeSet<>();
			for (Location location : result.getUnresolvedSymbols()) {
				symbols.add(location.getFunctionName());
			}
			for (String symbol : symbols) {
				log("    " + symbol, false);
			}
		}
	}

	/**
	 * Parses the symbols within the given file, reading it line-by-line where each
	 * line is assumed to be a symbol
	 * 
	 * @param commonSymbolsFile the file to read
	 * @return a list of symbols to exclude when making FunctionID signatures
	 * @throws IOException
	 * @throws CancelledException
	 */
	private List<String> parseSymbols(File commonSymbolsFile) throws IOException, CancelledException {
		// Check if the common symbols file exists
		if (commonSymbolsFile.exists() == false) {
			return null;
		}

		// If it exists, read the file
		BufferedReader reader = new BufferedReader(new FileReader(commonSymbolsFile));

		// Create a new linked list to store the common symbols in
		List<String> commonSymbols = new LinkedList<>();

		// Read a single line from the file
		String line = reader.readLine();

		// Iterate over all lines
		while (line != null) {
			/*
			 * If the monitor isn't cancelled, continue, else throw an exception which
			 * causes the whole script to halt
			 */
			monitor.checkCancelled();

			// If the line of the length is not zero
			if (line.length() != 0) {
				// Add it to the list
				commonSymbols.add(line);
			}
			// Read the next line
			line = reader.readLine();
		}

		// Once the entire file has been read, close the file access
		reader.close();

		// Return all common symbols
		return commonSymbols;
	}

	/**
	 * Recursively generate a mapping for all programs within the given folder and
	 * its sub-folders
	 * 
	 * @param folder              the folder to start in
	 * @param languageIdMapping   the LanguageID mapping which is populated within
	 *                            each call
	 * @param rawLanguageIds      the raw LanguageIDs
	 * @param languageIds         the LanguageID
	 * @param compilerSpecMapping the compiler spec mapping
	 * @throws CancelledException
	 */
	private void generateLanguageIdProgramMapping(Map<String, List<DomainFile>> languageIdMapping, DomainFolder folder,
			Set<String> rawLanguageIds, Set<String> languageIds, Map<String, List<DomainFile>> compilerSpecMapping)
			throws CancelledException {
		// Iterate over all domain files within the given folder
		for (DomainFile domainFile : folder.getFiles()) {
			/*
			 * As within any longer loop, a cancel check is present to allow a user to
			 * cancel the script in a timely manner
			 */
			monitor.checkCancelled();

			/*
			 * Only if the file is of the "PROGRAM" type, it is to be used
			 */
			if (domainFile.getContentType().equals(ProgramContentHandler.PROGRAM_CONTENT_TYPE)) {
				Map<String, String> metadata = domainFile.getMetadata();

				String languageId = metadata.get("Language ID");
				if (languageId != null) {
					rawLanguageIds.add(languageId);

					/*
					 * An example of a raw language ID is "x86:LE:32:default (3.0)". Splitting by
					 * the space removes the version number, giving the language ID that is required
					 * for later use.
					 */
					String filteredLanguageId = languageId.split(" ")[0];

					languageIds.add(filteredLanguageId);

					/*
					 * Attempt to get the value from the mapping for the given key. If the result is
					 * null, no such key (nor value) is present in the mapping.
					 */
					List<DomainFile> domainFiles = languageIdMapping.get(filteredLanguageId);

					/*
					 * If the result is null, there is no key in the mapping, meaning it is new. A
					 * new list is created, and the key and value are added to the mapping.
					 */
					if (domainFiles == null) {
						domainFiles = new ArrayList<>();
						domainFiles.add(domainFile);
						languageIdMapping.put(filteredLanguageId, domainFiles);
					} else {
						/*
						 * Since the list from the mapping is not null, the key exists with a value. Add
						 * the current file to the list, and overwrite the mapping's entry with the new
						 * value for the given key.
						 */
						domainFiles.add(domainFile);
						languageIdMapping.put(filteredLanguageId, domainFiles);
					}

				}
			}
		}
		// Iterate over all folders within the given folder
		for (DomainFolder domainFolder : folder.getFolders()) {
			monitor.checkCancelled();
			generateLanguageIdProgramMapping(languageIdMapping, domainFolder, rawLanguageIds, languageIds,
					compilerSpecMapping);
		}
	}

	/**
	 * Populates an FIDB file based on the given list of programs for the given
	 * language ID, excluding the given common symbols
	 * 
	 * @param fidDb          the database to populate
	 * @param languageID     the LanguageID to match with
	 * @param programs       the programs to parse
	 * @param commonSymbols  the common symbols to exclude
	 * @param reporter       the report to use when returning results
	 * @param projectName    the project name to use within the database
	 * @param projectVersion the version to use within the database
	 * @throws CancelledException
	 */
	private void createLibraryFromPrograms(FidDB fidDb, LanguageID languageID, List<DomainFile> programs,
			List<String> commonSymbols, FidReporter reporter, String projectName, String projectVersion)
			throws CancelledException {
		/*
		 * Set the library name, version, and variant
		 */
		String libraryName = projectName;
		String libraryVersion = projectVersion;
		String libraryVariant = languageID.getIdAsString();

		// Create the message
		String message = "[" + libraryVariant + "] Generating \"" + libraryName + " (" + libraryVersion
				+ ")\" based on " + programs.size() + " files";
		// Log the message
		log(message, false);
		// Set the monitor message to inform the analyst when running via a GUI
		monitor.setMessage(message);

		try {
			// Call the FID service to create populate the new library
			FidPopulateResult result = fidService.createNewLibraryFromPrograms(fidDb, libraryName, libraryVersion,
					libraryVariant, programs, null, languageID, null, commonSymbols, TaskMonitor.DUMMY);
			// report the results via the reporter
			reporter.report(result);
		} catch (MemoryAccessException e) {
			Msg.showError(this, null, "Unexpected memory access exception", "Please notify the Ghidra team:", e);
		} catch (VersionException e) {
			Msg.showError(this, null, "Version Exception",
					"One of the programs in your domain folder cannot be upgraded: " + e.getMessage());
		} catch (IllegalStateException e) {
			Msg.showError(this, null, "Illegal State Exception", "Unknown error: " + e.getMessage());
		} catch (IOException e) {
			Msg.showError(this, null, "FidDb IOException", "Please notify the Ghidra team:", e);
		}
	}

	/**
	 * Creates a new FunctionID database file
	 * 
	 * @param fidbFile    the file to be created
	 * @param fidFileName the file name to use
	 * @return the newly created FIDB file with write permissions
	 * @throws IOException
	 * @throws VersionException
	 */
	private FidDB createFidDB(File fidbFile, String fidFileName) throws IOException, VersionException {
		// Declare the object
		FidFile fidFile = null;

		// Get the FID file manager
		FidFileManager fidFileManager = FidFileManager.getInstance();

		// Create a new database
		fidFileManager.createNewFidDatabase(fidbFile);

		// Get all user added FIDB files
		List<FidFile> fids = fidFileManager.getUserAddedFiles();

		// Iterate over all FIDB files
		for (FidFile fid : fids) {
			// If the name equals the given file name
			if (fid.getName().equalsIgnoreCase(fidFileName)) {
				// If the match is there, set the return variable and break the loop
				fidFile = fid;
				break;
			}
		}

		// If no matching file was found, something went wrong and null is returned
		if (fidFile == null) {
			return null;
		}

		// Return the FIDB file with write permissions
		return fidFile.getFidDB(true);
	}

	@Override
	protected void run() throws Exception {
		/*
		 * A note about the askSomething functions. This script is intended to be
		 * executed by Ghidra in its headless mode, since the GUI serves no purpose in
		 * this script. Any askSomething function will take an argument from the
		 * command-line interface when running headless. As such, it allows one to use
		 * the command-line interface in an easy manner, or with the help of a
		 * properties file. In this case, all askSomething functions are listed in the
		 * start of the run-method, since the command-line interface argument order
		 * matters. This is a convenient way for users to understand what arguments are
		 * to be provided when running this script headless, without going over all code
		 * within this script.
		 */

		/*
		 * Ask for the project name, which is to be used in the to-be created FIDBs
		 */
		String projectName = askString("Project name", "What is the project name?");

		/*
		 * Ask for the project version, which is to be used in the to-be created FIDBs
		 */
		String projectVersion = askString("Project version", "What is the project version?");

		/*
		 * Ask for the output folder. This will be the location where the FIDB files
		 * along with the log file will be written to.
		 */
		String outputFolder = askString("Desired output folder", "What is the desired output folder?");

		// Create a file object for the output folder
		File outputFolderFile = new File(outputFolder);

		// If the output folder does not exist, create all required folders
		if (outputFolderFile.exists() == false) {
			outputFolderFile.mkdirs();
		}

		/*
		 * Get the absolute path for the output folder, excluding a trailing folder
		 * separator
		 */
		outputFolder = outputFolderFile.getAbsolutePath();

		/*
		 * Ask if a common symbols file is to be used
		 */
		boolean useCommonSymbolsFile = askYesNo("Common symbols file usage",
				"Do you want to use a common symbols file?");

		/*
		 * The path to the symbols file, if desired
		 */
		String symbolsFilePath = null;

		/*
		 * The file object which refers to the provided path
		 */
		File commonSymbolsFile = null;

		/*
		 * The list of symbols
		 */
		List<String> symbols = null;

		/*
		 * If a common symbols file is desired, the path to said file is requested,
		 * after which a file object pointing to said location is instantiated. Lastly,
		 * the symbols are parsed, and stored in the symbols list. If the common symbols
		 * file cannot be found, the script returns early with a related error message
		 */
		if (useCommonSymbolsFile) {
			symbolsFilePath = askString("Common symbols file location",
					"What is the location of the common symbols file?");
			log("Received the following location for the common symbols file: " + symbolsFilePath, false);
			commonSymbolsFile = new File(symbolsFilePath);
			if (commonSymbolsFile.exists() == false) {
				log("Cannot find the common symbols file:" + symbolsFilePath, true);
				return;
			}
			symbols = parseSymbols(commonSymbolsFile);
		}

		/*
		 * Initialise the FunctionID service
		 */
		fidService = new FidService();

		/*
		 * Initialises the log file object
		 */
		File log = new File(outputFolder + File.separator + "log.txt");

		/*
		 * Check if the log file exists. If it does, no action is required, as data can
		 * be appended to it. If it does not, the file itself is created
		 */
		if (log.exists() == false) {
			log.createNewFile();
		}

		/*
		 * Set the log file, which is used by the log function
		 */
		logFile = log.toPath();

		/*
		 * Logging is possible from this point
		 */
		log("Received project name: " + projectName, false);
		log("Received project version: " + projectVersion, false);
		log("Received output folder path: " + outputFolder, false);
		log("Received choice with regards to the usage of a common symbols file: " + useCommonSymbolsFile, false);		

		/*
		 * Initialise a new report instance, to later report on the FIDB generation
		 * results
		 */
		FidReporter reporter = new FidReporter();

		/*
		 * Gets the root folder of the current project, allowing the recursive calls
		 * later on to start at the root node
		 */
		DomainFolder rootFolder = state.getProject().getProjectData().getRootFolder();

		/*
		 * Contains a mapping of the original compiler spec IDs for the given list of
		 * files
		 */
		Map<String, List<DomainFile>> compilerSpecMapping = new HashMap<>();

		/*
		 * Contains all language IDs without version information
		 */
		Set<String> languageIds = new HashSet<>();

		/*
		 * Contains all language IDs with version information
		 */
		Set<String> rawLanguageIds = new HashSet<>();

		/*
		 * Initialises the mapping of language IDs and their respective domain files
		 */
		Map<String, List<DomainFile>> languageIdProgramMapping = new HashMap<>();

		/*
		 * Generate a mapping, stored in a global variable, which contains unique
		 * language ID strings as a key, and a list of programs associated with said
		 * language ID as value. This mapping is used later on to make FIDBs for each
		 * language ID, with the respective files.
		 */
		generateLanguageIdProgramMapping(languageIdProgramMapping, rootFolder, rawLanguageIds, languageIds,
				compilerSpecMapping);

		/*
		 * Create a log message with all unique language IDs, including their version
		 */
		String collectLanguageIds = "Collected language IDs and their versions:\n";
		for (String id : rawLanguageIds) {
			collectLanguageIds += "\t" + id + "\n";
		}

		/*
		 * Write the message to Ghidra's console and the log file
		 */
		log(collectLanguageIds, false);

		/*
		 * Create a string which is to be logged, which contains each unique language ID
		 * and the number of files that are to be processed for said language ID
		 */
		String languageIdFileMessage = "";
		for (Map.Entry<String, List<DomainFile>> entry : languageIdProgramMapping.entrySet()) {
			String languageID = entry.getKey();
			List<DomainFile> domainFiles = entry.getValue();

			languageIdFileMessage += languageID + " contains " + domainFiles.size() + " files\n";
		}

		// Log the language ID and file summary
		log(languageIdFileMessage, false);

		/*
		 * Iterate over the language IDs without version information
		 */
		for (String id : languageIds) {
			/*
			 * Replace the colon with a dot to avoid invalid file name errors. The replace
			 * all function uses regular expressions for both arguments, meaning that the
			 * dot has to be escaped
			 */
			String fileName = id.replaceAll(":", "\\.") + ".fidb";

			/*
			 * The FIDB file name is the file name that the file will have on disk, based on
			 * the project name, project version, and the language ID
			 */
			String fidFileName = projectName.replaceAll(" ", "\\.") + "_" + projectVersion.replaceAll(" ", "\\.") + "_"
					+ fileName;

			// Create a file object for the FIDB file
			File fidbFile = new File(outputFolder + File.separator + fidFileName);

			/*
			 * The createNewFidDatabase function requires the file to NOT exist, meaning it
			 * needs to be deleted if it exists
			 */
			if (fidbFile.exists()) {
				String error = "The FIDB file already exists: " + fidbFile.getAbsolutePath();
				log(error, true);
				return;
			}

			/*
			 * Create the FIDB file
			 */
			FidDB fidDb = createFidDB(fidbFile, fidFileName);

			/*
			 * If createFidDB returns null, the file could not be found, and the execution
			 * needs to exit
			 */
			if (fidDb == null) {
				log("Cannot find any FIDB file named \"" + fidFileName + "\"", true);
				return;
			}

			/*
			 * Create a language ID object, which is used and required during the generation
			 * of the FIDB
			 */
			LanguageID languageID = new LanguageID(id);

			/*
			 * A list of all programs which fall under the given language ID, within the
			 * given Ghidra project
			 */
			List<DomainFile> programs = languageIdProgramMapping.get(id);

			/*
			 * Generate the hashes for functions for each program in the list, for the given
			 * language ID
			 */
			createLibraryFromPrograms(fidDb, languageID, programs, symbols, reporter, projectName, projectVersion);

			// Save the database, otherwise all changes will be lost
			fidDb.saveDatabase("Saving", monitor);

			// Close the FIDB
			fidDb.close();
		}
	}
}
```

`BsimFunctionRenamer.java`:

```java
//Query a BSim database and rename functions within the current program based on predefined thresholds. 
//If two or more matches are found above the threshold, the function is not renamed, but the names are added in a comment, 
//along with contextually relevant information.
//@author Max 'Libra' Kersten for Trellix, based on Ghidra's QueryFunction script
//@category Bsim
//@keybinding
//@menupath
//@toolbar

import java.net.MalformedURLException;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ghidra.app.script.GhidraScript;
import ghidra.features.base.values.GhidraValuesMap;
import ghidra.features.bsim.query.BSimClientFactory;
import ghidra.features.bsim.query.FunctionDatabase;
import ghidra.features.bsim.query.GenSignatures;
import ghidra.features.bsim.query.description.ExecutableRecord;
import ghidra.features.bsim.query.description.FunctionDescription;
import ghidra.features.bsim.query.protocol.QueryNearest;
import ghidra.features.bsim.query.protocol.ResponseNearest;
import ghidra.features.bsim.query.protocol.SimilarityNote;
import ghidra.features.bsim.query.protocol.SimilarityResult;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionIterator;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.MessageType;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;

public class BsimFunctionRenamer extends GhidraScript {

	/**
	 * The lower bound for a similarity to be considered. The value should be
	 * between 0 and 1, where 1 is an exact match. Note that a low bound with a low
	 * number of maximum matches (see {@link #MAXIMUM_BSIM_MATCHES_PER_FUNCTION}) is
	 * not really effective, since the highest matches are returned first.<br>
	 * <br>
	 * The combination of these two variables is delicate, as too many results can
	 * exhaust the available memory or result in an extremely long runtime of the
	 * script. The lower this bound is, the less trustworthy it is.
	 */
	private static double SIMILARITY_BOUND = 0.8;

	/**
	 * The maximum number of BSim matches per function. More matches consume more
	 * memory and take longer
	 */
	private static int MAXIMUM_BSIM_MATCHES_PER_FUNCTION = 20;

	/**
	 * The confidence bound is the lower bound for matches. As such, any match needs
	 * to have at least this confidence within the result.
	 */
	private static double CONFIDENCE_BOUND = 0.0;

	/**
	 * When set to <code>true</code>, functions with a single match (meaning a
	 * single match is found, or multiple matches with the exact same name in the
	 * database) are renamed to the detected function name
	 */
	private boolean RENAME_SINGLE_MATCH = false;

	/**
	 * When set to <code>true</code> and multiple matches are found for a given
	 * function, the shortest function name will be selected. If all other names
	 * contain the shortest name, it is renamed to the shortest name. If not, the
	 * function is not renamed.
	 */
	private boolean RENAME_MULTI_MATCH = false;

	/**
	 * When set to <code>true</code>, the {@link #CUSTOM_PREFIX} needs to be set,
	 * which is then used to rename generically matching functions.
	 */
	private boolean RENAME_GENERIC_MATCH = false;

	/**
	 * If {@link #RENAME_GENERIC_MATCH} is set to <code>true</code>, this value is
	 * used to prefix function names with, in order for them to be easily
	 * recognisable by analysts.
	 */
	private String CUSTOM_PREFIX = "";

	/**
	 * Creates a FunctionDatabase object based on the given URL. When using a local
	 * database, no file extension should be included within the full path to the
	 * database file!
	 * 
	 * @param databaseUrl the URL of the database to connect with
	 * @return a FunctionDatabase object to interact with the BSim database
	 * @throws IllegalArgumentException
	 * @throws MalformedURLException
	 */
	private FunctionDatabase openDatabase(String databaseUrl) throws IllegalArgumentException, MalformedURLException {
		// Create a URL object from the given string
		URL url = BSimClientFactory.deriveBSimURL(databaseUrl);
		// Create a non-async database object based on the given URL
		FunctionDatabase database = BSimClientFactory.buildClient(url, false);
		// Return the newly created database
		return database;
	}

	/**
	 * Queries the database for a single function from the current program and
	 * stores the results in the <code>matchHolders</code> list.
	 * 
	 * @param matchHolders the output list
	 * @param database     the BSim database
	 * @param gensig       the signature generation object
	 * @param function     the function from the current program to query
	 */
	private void queryDatabase(List<MatchHolder> matchHolders, FunctionDatabase database, GenSignatures gensig,
			Function function) {
		// Convert the function's casing to lower
		String lower = function.getName().toLowerCase();
		/*
		 * If the function does not start with "fun_", equals the default entry point
		 * ("entry") or is a thunk function, it is to be skipped. These functions can be
		 * skipped since they're irrelevant for the matching algorithm and would only
		 * consume resources and computation without yielding any results. As such, it
		 * is more efficient to skip them.
		 */
		if (lower.startsWith("fun_") == false || lower.equals("entry") || lower.startsWith("thunk_FUN_")
				|| function.isThunk() || function.isExternal()) {
			return;
		}

		try {
			// Set the vector factory to match the database's vector factory type
			gensig.setVectorFactory(database.getLSHVectorFactory());
			// Open the current program
			gensig.openProgram(currentProgram, null, null, null, null, null);

			// Scan the current function
			gensig.scanFunction(function);

			// Declare and initialise the query
			QueryNearest query = new QueryNearest();
			query.manage = gensig.getDescriptionManager();
			query.max = MAXIMUM_BSIM_MATCHES_PER_FUNCTION;
			query.thresh = SIMILARITY_BOUND;
			query.signifthresh = CONFIDENCE_BOUND;

			// Get the response from the database
			ResponseNearest response = query.execute(database);

			// If the response is null, print the error and return
			if (response == null) {
				println(database.getLastError().message);
				return;
			}

			// Get all results from the response
			Iterator<SimilarityResult> similarityResultIterator = response.result.iterator();

			// Iterate over all entries
			while (similarityResultIterator.hasNext()) {
				// Get the result
				SimilarityResult similarityResult = similarityResultIterator.next();
				// Get the iterator from the result
				Iterator<SimilarityNote> similarityNoteIterator = similarityResult.iterator();

				/*
				 * Declare and initialise variables used to create custom objects based on match
				 * results
				 */
				List<FunctionMatch> matches = new ArrayList<>();
				Set<String> uniqueFunctionNames = new HashSet<>();
				Map<String, String> functionNameMapping = new HashMap<>();
				Map<String, List<FunctionMatch>> matchMapping = new HashMap<>();

				// Iterate over the similarity notes
				while (similarityNoteIterator.hasNext()) {
					// Get the note
					SimilarityNote similarityNote = similarityNoteIterator.next();
					// Get the function description
					FunctionDescription functionDescription = similarityNote.getFunctionDescription();
					// Get the executable record
					ExecutableRecord executableRecord = functionDescription.getExecutableRecord();

					// Declare the required fields for local processing
					String executable = executableRecord.getNameExec();
					String functionName = functionDescription.getFunctionName();

					// Ignore matches which are unknown functions
					if (functionName.startsWith("FUN_")) {
						continue;
					}

					String architecture = executableRecord.getArchitecture();
					double similarity = similarityNote.getSimilarity();
					double significance = similarityNote.getSignificance();

					// Get the function name in lower case
					String lowerCaseFunctionName = functionName.toLowerCase();
					// Store this name within a set
					uniqueFunctionNames.add(lowerCaseFunctionName);

					// If the function name mapping does not contain the key
					if (functionNameMapping.containsKey(lowerCaseFunctionName) == false) {
						// Add the names to the mapping
						functionNameMapping.put(lowerCaseFunctionName, functionName);
					}

					// Create a function match object
					FunctionMatch match = new FunctionMatch(function.getName(), executable, functionName, architecture,
							similarity, significance);

					// Add the match to the list of matches
					matches.add(match);
				}

				/*
				 * Iterate over all unique function names from the match for a given local
				 * function
				 */
				for (String lowerCaseFunctionName : uniqueFunctionNames) {
					// Create a new list to store all function matches in
					List<FunctionMatch> localMatches = new ArrayList<>();

					// Iterate over all matches
					for (FunctionMatch match : matches) {
						// If the currently iterated function name matches the match's function name
						if (match.getFunctionName().equalsIgnoreCase(lowerCaseFunctionName)) {
							// Add it to the list
							localMatches.add(match);
						}
					}
					// Sort the list
					localMatches.sort(Comparator.comparing(FunctionMatch::getExecutable).reversed());
					// Put the name and corresponding matches in the map
					matchMapping.put(functionNameMapping.get(lowerCaseFunctionName), localMatches);
				}

				// If there are matches
				if (matches.isEmpty() == false) {
					// Sort the matches
					matches.sort(Comparator.comparing(FunctionMatch::getExecutable).reversed());
					// Create a holding object
					MatchHolder holder = new MatchHolder(function, matchMapping);
					// Add the match holder to the list
					matchHolders.add(holder);
				}
			}
		} catch (Exception ex) {
			// TODO handle exceptions
		}
	}

	@Override
	public void run() throws Exception {
		/*
		 * Define variables with the text to display in the askValues menu
		 */
		String valueDatabaseUrl = "The complete database URL (excluding extensions)";
		String valueSimilarityBound = "Lower similarity bound";
		String valueMaximumBsimMatches = "Maximum BSim matches per function";
		String valueRenameSingleMatches = "Rename single matches";
		String valueRenameMultiMatches = "Rename multi-matches";
		String valueRenameGenericMatches = "Rename generic matches with the given prefix";
		String valueCustomPrefix = "Custom prefix to rename multi-matches with (leave empty if generic matches aren't meant to be renamed)";

		// Declare and initiate the mapping
		GhidraValuesMap values = new GhidraValuesMap();

		// Provide the values and types for the askValues call
		values.defineString(valueDatabaseUrl);
		values.defineDouble(valueSimilarityBound, 0.7);
		values.defineInt(valueMaximumBsimMatches, 20);
		values.defineBoolean(valueRenameSingleMatches, true);
		values.defineBoolean(valueRenameMultiMatches, true);
		values.defineBoolean(valueRenameGenericMatches, true);
		values.defineString(valueCustomPrefix);

		// Ensure a database has been provided
		values.setValidator((valueMap, status) -> {
			if (valueMap.hasValue(valueDatabaseUrl) == false) {
				status.setStatusText("A database must be provided!", MessageType.ERROR);
				return false;
			}
			return true;
		});

		// Request all values from the user
		values = askValues("Please provide the requested values", null, values);

		// "file:/C:\\Users\malwa\bsim_databases\bsim.golang-runtimes.windows.386-amd64.h2.medium-nosize
		String databaseUrl = "file:";
		String providedDatabaseUrl = values.getString(valueDatabaseUrl);

		/*
		 * If the URL starts with a slash, it is a Unix file system, meaning the path
		 * already starts with a slash. If this is not the case, it is a Windows file
		 * system, which starts with a letter, which is then the slash needs to be
		 * prepended prior to the disk drive letter.
		 */
		if (providedDatabaseUrl.startsWith("/") == false) {
			databaseUrl += "/";
		}
		databaseUrl += providedDatabaseUrl;

		SIMILARITY_BOUND = values.getDouble(valueSimilarityBound);

		MAXIMUM_BSIM_MATCHES_PER_FUNCTION = values.getInt(valueMaximumBsimMatches);

		RENAME_SINGLE_MATCH = values.getBoolean(valueRenameSingleMatches);

		RENAME_MULTI_MATCH = values.getBoolean(valueRenameMultiMatches);

		RENAME_GENERIC_MATCH = values.getBoolean(valueRenameGenericMatches);

		if (RENAME_GENERIC_MATCH) {
			CUSTOM_PREFIX = values.getString(valueCustomPrefix);
		}

		/*
		 * A decimal format declared and instantiated here for later use allows a single
		 * instance to be reused
		 */
		DecimalFormat decimalFormat = new DecimalFormat("#.###");

		// Try to open the database
		try (FunctionDatabase database = openDatabase(databaseUrl)) {
			// If the database is not initialised, throw an error message and return early
			if (database.initialize() == false) {
				println(database.getLastError().message);
				return;
			}

			/*
			 * Declare and initiate the object to generate signatures, without the option to
			 * generate call graph information as it is not required for the purpose of this
			 * script and would only cause overhead
			 */
			GenSignatures gensig = new GenSignatures(false);

			// Declare and initialise a list of all match holders
			List<MatchHolder> matchHolders = new ArrayList<>();

			/*
			 * Declare and initialise variables used to print statistics at the end of the
			 * script's run to further inform the analyst of the results
			 */
			int functionCount = 0;
			int singleMatchRenameCount = 0;
			int multiMatchRenameCount = 0;
			int genericMatchRenameCount = 0;

			/*
			 * Iterate over all functions to get the total number of functions. Since the
			 * returned iterator by the function manager can only be iterated over once,
			 * this loop is only used to get the total number of functions
			 */
			for (@SuppressWarnings("unused")
			Function function : currentProgram.getFunctionManager().getFunctionsNoStubs(currentProgram.getMinAddress(),
					true)) {
				functionCount++;
			}

			/*
			 * Initialise the monitor on-screen with a message as to the current action, and
			 * set the maximum value to the number of functions, as each function will be
			 * queried to the given BSim database
			 */
			monitor.initialize(functionCount, "Querying the BSim database for all relevant local functions");

			// Get an iterator for all functions within the current program
			FunctionIterator functions = currentProgram.getFunctionManager()
					.getFunctionsNoStubs(currentProgram.getMinAddress(), true);

			// Iterate over each function within the current program
			for (Function function : functions) {
				/*
				 * Query the BSim database and populate the matchholders variable by appending
				 * new matches in the process
				 */
				queryDatabase(matchHolders, database, gensig, function);
				/*
				 * Checks if the script is cancelled and returns early, and increments the
				 * on-screen progress bar to inform the analyst
				 */
				monitor.increment();
			}

			/*
			 * At this stage, no further signatures have to be made, so the variable can be
			 * disposed of
			 */
			gensig.dispose();

			/*
			 * Initialise the monitor to depend on the found matches in the database, and
			 * the in-memory stored results thereof
			 */
			monitor.initialize(matchHolders.size(), "Renaming local functions based on matches");

			// Iterate over all matches
			for (MatchHolder matchHolder : matchHolders) {
				// Get the size of the current match's mapping
				int mappingSize = matchHolder.getMatchMapping().entrySet().size();

				// Iterate over the current match's mapping
				for (Map.Entry<String, List<FunctionMatch>> entry : matchHolder.getMatchMapping().entrySet()) {
					// Get the function name from the current entry
					String functionName = entry.getKey();
					// Get the matches with said function name
					List<FunctionMatch> matches = entry.getValue();

					// Declare and initialise the comment's base
					String comment = "Detected name: \"" + functionName + "\"\n";
					comment += "\nOriginal file, similarity, significance, architecture\n";

					// Iterate over each match within the match holder
					for (FunctionMatch match : matches) {
						/*
						 * Add the original file, similarity, significance, and architecture for each
						 * match
						 */
						comment += "\t" + match.getExecutable() + "\t\t" + decimalFormat.format(match.getSimilarity())
								+ "\t\t" + decimalFormat.format(match.getSignificance()) + "\t\t"
								+ match.getArchitecture() + "\n";
					}
					// Set the comment at the function within the current binary
					setComment(matchHolder.getLocalFunction(), comment, false);

					// Get the old function name
					String oldName = matchHolder.getLocalFunction().getName();

					/*
					 * If any of the rename options is selected, set the old function name in a
					 * comment at the top
					 */
					if (RENAME_SINGLE_MATCH || RENAME_MULTI_MATCH || RENAME_GENERIC_MATCH) {
						/*
						 * If the custom prefix isn't left empty and if the old name does not already
						 * start with the given custom prefix, the old name is added in the comment.
						 * Otherwise, the old name doesn't need to be added as it is already present.
						 */
						if (CUSTOM_PREFIX.isBlank() == false && oldName.startsWith(CUSTOM_PREFIX) == false) {
							comment = "Old name: " + oldName;
							setComment(matchHolder.getLocalFunction(), comment, true);
						}
					}
					/*
					 * If there is only a single match, and single matches are to be renamed
					 */
					if (mappingSize == 1 && RENAME_SINGLE_MATCH) {
						// If the old and new name are not the same (disregarding the casing)
						if (oldName.equalsIgnoreCase(functionName) == false) {
							// Rename the function
							renameFunction(matchHolder.getLocalFunction(), oldName, functionName);
							// Increment the single match rename counter
							singleMatchRenameCount++;
						}
					} else if (mappingSize >= 2) {
						/*
						 * If there are multiple matches, and a common name is to be picked if possible
						 * based on overlap in names
						 */
						if (RENAME_MULTI_MATCH) {
							// The shortest string is taken from the set
							String shortestFunctionName = getShortestString(matchHolder.getMatchMapping().keySet());
							// If all entries within the set contain said string
							if (allEntriesContain(matchHolder.getMatchMapping().keySet(), shortestFunctionName)) {
								// If the old name does not equal the shortest function name, disregarding the
								// casing
								if (oldName.equalsIgnoreCase(shortestFunctionName) == false) {
									// Rename the function
									renameFunction(matchHolder.getLocalFunction(), oldName, shortestFunctionName);
									// Increment the multi-match count
									multiMatchRenameCount++;
								}
							}
						}

						// If generic matches are enabled
						if (RENAME_GENERIC_MATCH) {
							/*
							 * If the the old name does not start with the custom prefix to set (meaning it
							 * is hasn't been renamed already)
							 */
							if (oldName.toLowerCase().startsWith(CUSTOM_PREFIX.toLowerCase()) == false) {
								// Declare the new name as the old name with the set prefix in front
								String newName = CUSTOM_PREFIX + oldName;
								// Rename the function
								renameFunction(matchHolder.getLocalFunction(), oldName, newName);
								// Increment the generic match count
								genericMatchRenameCount++;
							}
						}
					}
				}
				/*
				 * Increment the monitor to indicate one function has been handled. If the
				 * analyst cancelled the script at any point prior to the previous check it will
				 * now cancel and exit this script
				 */
				monitor.increment();
			}

			/*
			 * Print the statistics with regards to the renaming, so the analyst gets an
			 * easy overview of the effectiveness of this script's results
			 */
			println("Renamed " + singleMatchRenameCount + " single-match functions!");
			println("Renamed " + multiMatchRenameCount + " multi-match functions!");
			println("Renamed " + genericMatchRenameCount + " generic match functions!");

			println((singleMatchRenameCount + multiMatchRenameCount + genericMatchRenameCount) + "/" + functionCount
					+ " of the matching functions were renamed");
			println(matchHolders.size() + "/" + functionCount
					+ " of the functions were matched in the database, based on the given similarity threshold");
		}
	}

	/**
	 * A wrapper function to rename a function based on the given new name, mark it
	 * as a user defined new name, and print the function rename to the console.
	 * 
	 * @param function the function to rename
	 * @param oldName  the old name of the function
	 * @param newName  the new name of the function
	 * @throws DuplicateNameException
	 * @throws InvalidInputException
	 */
	private void renameFunction(Function function, String oldName, String newName)
			throws DuplicateNameException, InvalidInputException {
		// Set the function name
		function.setName(newName, SourceType.USER_DEFINED);
		/*
		 * Print the old and new function names, the later of which is clickable in the
		 * console. Note that this line of code is only reached if no exception is
		 * thrown when setting the new function name, avoiding a mismatch between the
		 * console and the renamed functions
		 */
		println("Renamed " + oldName + " to " + newName);
	}

	/**
	 * A helper function to check if all entries within the given set contain a
	 * given string, disregarding the casing. This helper function is simplistic in
	 * nature and can be altered to suit one's specific needs. In this case, the
	 * overlap in strings within the set is measured.
	 * 
	 * @param set  the set of strings to iterate over
	 * @param part the string each item within the set ought to contain,
	 *             disregarding the casing
	 * @return true if all entries match the given part (disregarding casing), false
	 *         if not
	 */
	private boolean allEntriesContain(Set<String> set, String part) {
		// Iterate over all entries in the set
		for (String s : set) {
			// Check if the entry in the set contains the part, disregarding casing
			if (s.toLowerCase().contains(part.toLowerCase()) == false) {
				// Return false if the entry does not contain the match
				return false;
			}
		}
		// Return true if all entries have been iterated without failing to find a match
		return true;
	}

	/**
	 * Helper function to get the shortest string from a set of strings
	 * 
	 * @param set the set where to obtain the shortest string from
	 * @return the shortest string found within the set
	 */
	private String getShortestString(Set<String> set) {
		// If the set object is null, or if it is empty, return null
		if (set == null || set.isEmpty()) {
			return null;
		}
		/*
		 * Declare and initialise the size variable, setting it to the maximum value it
		 * can hold, for which can be checked later
		 */
		int size = Integer.MAX_VALUE;

		// Declare and initialise an empty string
		String result = "";

		// Iterate over all entries in the set
		for (String s : set) {
			// Get the length of the current entry's length
			int length = s.length();
			/*
			 * If the length of this entry is smaller than the smallest noted size thus far,
			 * save the size and result
			 */
			if (length < size) {
				size = length;
				result = s;
			}
		}

		// Return the result once all entries have been iterated over
		return result;
	}

	/**
	 * Helper function to set a comment at a given function, with the indication if
	 * this comment should be at the top or bottom of any already existing function
	 * comment at this function
	 * 
	 * @param function  the function to set a comment at
	 * @param comment   the comment to set at the given function
	 * @param pushToTop true if the function's existing comment (if any) should be
	 *                  put below this comment, false if not
	 */
	private void setComment(Function function, String comment, boolean pushToTop) {
		// Get the old comment, which is null if no comment is present
		String oldComment = function.getComment();
		// Check for the existence of the old comment
		if (oldComment != null) {
			// If it is present, trim the comment to avoid redundant whitespace
			oldComment = oldComment.trim();
			// If the string, post trimming, is not empty nor blank (which also checks if it
			// is empty)
			if (oldComment.isEmpty() == false && oldComment.isBlank() == false) {
				// If the comment should be at the top, place it at the top
				if (pushToTop) {
					comment += "\n\n" + oldComment;
				} else { // Else put it at the bottom
					comment = oldComment += "\n\n" + comment;
				}
			}
		}

		/**
		 * Set the comment, which contains the prior comment at the correct placement
		 * with regards to the given boolean if it existed
		 */
		function.setComment(comment);
	}

	/**
	 * A class to hold a local function (from the current program) with BSim matches
	 * in a map
	 */
	class MatchHolder {

		/**
		 * The local function from the current program
		 */
		private Function localFunction;

		/**
		 * The mapping with function names and matches, compared to the local function
		 */
		private Map<String, List<FunctionMatch>> matchMapping;

		public MatchHolder(Function localFunction, Map<String, List<FunctionMatch>> matchMapping) {
			super();
			this.localFunction = localFunction;
			this.matchMapping = matchMapping;
		}

		/**
		 * Gets the local function to which the corresponding mapping belongs, based on
		 * the BSim query
		 * 
		 * @return the local function object
		 */
		public Function getLocalFunction() {
			return localFunction;
		}

		/**
		 * The mapping with matches, belonging to the function within this object
		 * 
		 * @return the mapping
		 */
		public Map<String, List<FunctionMatch>> getMatchMapping() {
			return matchMapping;
		}
	}

	class FunctionMatch {
		/**
		 * The name of the function from the current program
		 */
		private String localFunctionName;

		/**
		 * The executable from which the match originates
		 */
		private String executable;

		/**
		 * The function name of the match
		 */
		private String functionName;

		/**
		 * The LanguageID from the match
		 */
		String architecture;

		/**
		 * The similarity of the match compared to the local function
		 */
		private double similarity;

		/**
		 * The significance of the match
		 */
		private double significance;

		public FunctionMatch(String localFunctionName, String executable, String functionName, String architecture,
				double similarity, double significance) {
			super();
			this.localFunctionName = localFunctionName;
			this.executable = executable;
			this.functionName = functionName;
			this.architecture = architecture;
			this.similarity = similarity;
			this.significance = significance;
		}

		/**
		 * The name of the function in the current program
		 * 
		 * @return
		 */
		public String getLocalFunction() {
			return localFunctionName;
		}

		/**
		 * The executable from which the match originates
		 * 
		 * @return
		 */
		public String getExecutable() {
			return executable;
		}

		/**
		 * The function name from the match
		 * 
		 * @return
		 */
		public String getFunctionName() {
			return functionName;
		}

		/**
		 * The LanguageID from the match
		 * 
		 * @return
		 */
		public String getArchitecture() {
			return architecture;
		}

		/**
		 * The similarity of the function from the current program compared to the
		 * matching function
		 * 
		 * @return
		 */
		public double getSimilarity() {
			return similarity;
		}

		/**
		 * The significance of the match
		 * 
		 * @return
		 */
		public double getSignificance() {
			return significance;
		}
	}
}
```

`ColouriseByComplexity.java`:

```java
//Colourises the complexity of a function where it is called in the disassembly listing. Light red is not complex, dark red is complex.
//@author Max 'Libra' Kersten for Trellix. The graph related code has been taken from and inspired by Ghidra's base: https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/module/ComplexityDepthModularizationCmd.java#L43
//@category 
//@keybinding
//@menupath
//@toolbar

import java.awt.Color;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.script.GhidraScript;
import ghidra.app.util.viewer.listingpanel.PropertyBasedBackgroundColorModel;
import ghidra.graph.GDirectedGraph;
import ghidra.graph.GraphAlgorithms;
import ghidra.graph.GraphFactory;
import ghidra.program.database.IntRangeMap;
import ghidra.program.model.address.Address;
import ghidra.program.model.block.BasicBlockModel;
import ghidra.program.model.block.CodeBlock;
import ghidra.program.model.block.CodeBlockIterator;
import ghidra.program.model.block.CodeBlockReference;
import ghidra.program.model.block.CodeBlockReferenceIterator;
import ghidra.program.model.block.graph.CodeBlockEdge;
import ghidra.program.model.block.graph.CodeBlockVertex;
import ghidra.program.model.listing.Function;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceIterator;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.DuplicateNameException;

public class ColouriseByComplexity extends GhidraScript {

	@Override
	protected void run() throws Exception {
		// Initialise the decompiler
		DecompInterface decompiler = new DecompInterface();
		// Open the current program
		decompiler.openProgram(currentProgram);

		// Get the call graph
		GDirectedGraph<CodeBlockVertex, CodeBlockEdge> callGraph = createCallGraph();
		// Obtain the complexity depth graph
		Map<CodeBlockVertex, Integer> complexityDepth = GraphAlgorithms.getComplexityDepth(callGraph);
		// Get the list of all levels within the graph
		List<List<Function>> partition = createFunctionList(complexityDepth);

		// Remove the empty levels from the list
		partition = cleanList(partition);

		// Iterate over the levels
		for (int i = 0; partition.size() > i; i++) {
			// Get the current list (or level, if you will)
			List<Function> list = partition.get(i);

			// Iterate over the functions within the current list
			for (Function function : list) {
				// Exclude thunk and external functions
				if (function.isThunk() || function.isExternal()) {
					continue;
				}

				/*
				 * Store the number of levels as a double, required to perform arithmetics that
				 * return a double
				 */
				double size = partition.size();

				// Get the current value, incremented by one since i is zero-based
				double currentValue = i + 1;

				/*
				 * Calculate the percentage of this level is relatively to the rest all levels
				 */
				double percentage = currentValue / size;

				/*
				 * One minus the percentage, since the first entry in the partition list, has
				 * the highest complexity depth
				 */
				double red = (1 - percentage) * 255;

				// Get all references to the function
				ReferenceIterator referenceIterator = currentProgram.getReferenceManager()
						.getReferencesTo(function.getEntryPoint());

				// Iterate over all references
				for (Reference ref : referenceIterator) {
					// Create the colour
					Color color = new Color((int) red, 0, 0);
					// Set the background colour in the listing for the reference
					setBackgroundColor(ref.getFromAddress(), ref.getFromAddress(), color);
				}
			}
		}
	}

	/**
	 * Takes a list of lists and returns a list of lists where none of the lists is
	 * empty
	 * 
	 * @param list the list to clean
	 * @return the same list but without any empty lists within
	 */
	private List<List<Function>> cleanList(List<List<Function>> list) {
		List<List<Function>> output = new ArrayList<>();

		for (List<Function> item : list) {
			if (item.isEmpty()) {
				continue;
			}
			output.add(item);
		}

		return output;
	}

	// Code below is taken from the Ghidra source code

	public void setBackgroundColor(Address min, Address max, Color c) {
		IntRangeMap map = getColorRangeMap(true);
		if (map != null) {
			map.setValue(min, max, c.getRGB());
		}
	}

	private IntRangeMap getColorRangeMap(boolean create) {
		IntRangeMap map = currentProgram.getIntRangeMap(PropertyBasedBackgroundColorModel.COLOR_PROPERTY_NAME);
		if (map == null && create) {
			try {
				map = currentProgram.createIntRangeMap(PropertyBasedBackgroundColorModel.COLOR_PROPERTY_NAME);
			} catch (DuplicateNameException e) {
				// can't happen since we just checked for it!
			}
		}
		return map;
	}

	private int getMaxLevel(Map<CodeBlockVertex, Integer> levelMap) {
		int maxLevel = -1;
		for (Integer level : levelMap.values()) {
			if (level > maxLevel) {
				maxLevel = level;
			}
		}
		return maxLevel;
	}

	private Function getFunctionFromCodeBlockVertex(CodeBlockVertex vertex) {
		Address startAddress = vertex.getCodeBlock().getFirstStartAddress();
		Function function = getFunctionAt(startAddress);
		return function;
	}

	private List<List<Function>> createFunctionList(Map<CodeBlockVertex, Integer> levelMap) {
		List<List<Function>> levelList = new ArrayList<>();
		int maxLevel = getMaxLevel(levelMap);
		for (int i = 0; i <= maxLevel; i++) {
			levelList.add(new ArrayList<Function>());
		}
		for (CodeBlockVertex vertex : levelMap.keySet()) {
			int reverseLevel = maxLevel - levelMap.get(vertex);
			Function function = getFunctionFromCodeBlockVertex(vertex);
			if (function != null) {
				levelList.get(reverseLevel).add(function);
			}
		}
		return levelList;
	}

	protected GDirectedGraph<CodeBlockVertex, CodeBlockEdge> createCallGraph() throws CancelledException {

		Map<CodeBlock, CodeBlockVertex> instanceMap = new HashMap<>();
		GDirectedGraph<CodeBlockVertex, CodeBlockEdge> graph = GraphFactory.createDirectedGraph();

		CodeBlockIterator codeBlocks = new BasicBlockModel(currentProgram, true).getCodeBlocks(monitor);
		while (codeBlocks.hasNext()) {
			CodeBlock block = codeBlocks.next();

			CodeBlockVertex fromVertex = instanceMap.get(block);
			if (fromVertex == null) {
				fromVertex = new CodeBlockVertex(block);
				instanceMap.put(block, fromVertex);
				graph.addVertex(fromVertex);
			}

			// destinations section
			addEdgesForDestinations(graph, fromVertex, block, instanceMap);
		}
		return graph;
	}

	private void addEdgesForDestinations(GDirectedGraph<CodeBlockVertex, CodeBlockEdge> graph,
			CodeBlockVertex fromVertex, CodeBlock sourceBlock, Map<CodeBlock, CodeBlockVertex> instanceMap)
			throws CancelledException {

		CodeBlockReferenceIterator iterator = sourceBlock.getDestinations(monitor);
		while (iterator.hasNext()) {
			monitor.checkCancelled();

			CodeBlockReference destination = iterator.next();
			CodeBlock targetBlock = getDestinationBlock(destination);
			if (targetBlock == null) {
				continue; // no block found
			}

			CodeBlockVertex targetVertex = instanceMap.get(targetBlock);
			if (targetVertex == null) {
				targetVertex = new CodeBlockVertex(targetBlock);
				instanceMap.put(targetBlock, targetVertex);
			}

			graph.addVertex(targetVertex);
			graph.addEdge(new CodeBlockEdge(fromVertex, targetVertex));
		}
	}

	private CodeBlock getDestinationBlock(CodeBlockReference destination) throws CancelledException {

		Address targetAddress = destination.getDestinationAddress();
		CodeBlock targetBlock = new BasicBlockModel(currentProgram, true).getFirstCodeBlockContaining(targetAddress,
				monitor);
		if (targetBlock == null) {
			return null; // no code found for call; external?
		}

		return targetBlock;
	}
}
```

`GhidrAI.java`:

```java
//Gets all functions within the program and allows one to see the complexity depth of each function. The graph related code has been taken from and inspired by Ghidra's base: https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/module/ComplexityDepthModularizationCmd.java#L43
//@author Max 'Libra' Kersten for Trellix
//@category 
//@keybinding
//@menupath
//@toolbar

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.app.decompiler.DecompiledFunction;
import ghidra.app.plugin.core.analysis.AutoAnalysisManager;
import ghidra.app.script.GhidraScript;
import ghidra.graph.GDirectedGraph;
import ghidra.graph.GraphAlgorithms;
import ghidra.graph.GraphFactory;
import ghidra.program.model.address.Address;
import ghidra.program.model.block.BasicBlockModel;
import ghidra.program.model.block.CodeBlock;
import ghidra.program.model.block.CodeBlockIterator;
import ghidra.program.model.block.CodeBlockReference;
import ghidra.program.model.block.CodeBlockReferenceIterator;
import ghidra.program.model.block.graph.CodeBlockEdge;
import ghidra.program.model.block.graph.CodeBlockVertex;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Variable;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.SystemUtilities;
import ghidra.util.exception.CancelledException;

public class GhidrAI extends GhidraScript {

	/*
	 * The number of seconds the decompiler will run before timing out
	 */
	private final int DECOMPILER_TIMEOUT = 600;

	/*
	 * The number of threads via which the AI LLM provider is contacted. This
	 * decreases the wait time on the LLM as multiple functions are handled at the
	 * same time. If your LLM cannot handle multiple connections, adjust this value.
	 */
	private final int THREAD_COUNT = 10;

	/*
	 * The number of milliseconds to wait before the HTTP request times out
	 */
	private final int POST_REQUEST_TIMEOUT = 120_000;

	/*
	 * The HTTP URL to the LLM API
	 */
	private String API_URL;

	/*
	 * True if functions should be renamed, false if not. Only functions starting
	 * with FUN_ are renamed if this is true.
	 */
	private boolean RENAME_FUNCTION;

	/*
	 * True if variables within functions should be renamed
	 */
	private boolean RENAME_VARIABLES;

	/*
	 * The Google JSON handling library which is included in Ghidra, used to convert
	 * the JSON response from the LLM proxy
	 */
	private Gson gson;

	/*
	 * Ghidra's automatic analysis manager, used to check if one or more analyzers
	 * are still running
	 */
	private AutoAnalysisManager autoAnalysisManager;

	@Override
	protected void run() throws Exception {
		/*
		 * Required input:
		 * 
		 * - AI API URL
		 * 
		 * - Rename function based on suggestion: yes/no
		 * 
		 * - Rename variables based on suggestions: yes/no
		 */

		// Get all provided values
		API_URL = askString("AI API URL", "The URL where the AI's API is accessible at");
		RENAME_FUNCTION = askYesNo("", "Rename the function based on the AI's suggestion");
		RENAME_VARIABLES = askYesNo("", "Rename variables based on the AI's suggestions");

		// Create a string to provide the feedback to the user
		String inputFeedback = "Received input:\n";
		inputFeedback += "\tAI URL:                     " + API_URL + "\n";
		inputFeedback += "\tRename functions:           " + RENAME_FUNCTION + "\n";
		inputFeedback += "\tRename variables:           " + RENAME_VARIABLES;

		// Log the input feedback
		println(inputFeedback);

		// Now that all checks are done, the variables in the class are initialised
		gson = new Gson();
		autoAnalysisManager = AutoAnalysisManager.getAnalysisManager(currentProgram);
		DecompInterface decompiler = new DecompInterface();
		decompiler.openProgram(currentProgram);

		/*
		 * Notify the user of the current activity. Generating the complexity graph
		 * takes a bit, but each step is relatively small. As such, it is summarised as
		 * a single-step task to the user
		 */
		monitor.initialize(1, "Generating the complexity graph for the current program");

		// Generate the complexity graph
		GDirectedGraph<CodeBlockVertex, CodeBlockEdge> callGraph = createCallGraph();
		Map<CodeBlockVertex, Integer> complexityDepth = GraphAlgorithms.getComplexityDepth(callGraph);
		List<List<Function>> partition = createFunctionList(complexityDepth);

		// Remove the empty levels from the list
		partition = cleanAndReverseList(partition);

		int currentFunctionCount = 0;
		int totalFunctionCount = 0;
		for (List<Function> list : partition) {
			totalFunctionCount += list.size();
		}

		// Increment the monitor, marking this task as complete
		monitor.increment();

		/*
		 * To iterate over the list from start to end (rather than end to start), you
		 * need to reverse the list. This can be done using
		 * Collections.reverse(partition).
		 */

		/*
		 * Declare the executor service variable. It is instantiated per level within
		 * the partition.
		 */
		ExecutorService executor;

		/*
		 * Iterate backwards over the list, handling the functions with the least
		 * complexity depth first
		 */
		for (int i = 0; i < partition.size(); i++) {
			// Get the functions for the complexity level
			List<Function> list = partition.get(i);

			if (list.isEmpty()) {
				continue;
			}

			/*
			 * Create the monitor message, taking the potential plurality of the function
			 * count into account
			 */
			String listSize = "Iterating over " + list.size() + " function";
			if (list.size() > 1) {
				listSize += "s";
			}
			String monitorMessage = listSize + " in level " + i + "/" + partition.size();

			/*
			 * Initialise the monitor with the message. Each thread will call back to the
			 * thread safe increment method
			 */
			monitor.initialize(list.size(), monitorMessage);

			/*
			 * The number of threads is equal to the globally set maximum number of thread
			 * counts unless the size of the list is less than that.
			 */
			if (list.size() > THREAD_COUNT) {
				executor = Executors.newFixedThreadPool(THREAD_COUNT);
			} else {
				executor = Executors.newFixedThreadPool(list.size());
			}

			// Iterate over each function within this complexity level
			for (Function function : list) {
				// Exclude thunk and external functions
				if (function.isThunk() || function.isExternal()) {
					continue;
				}

				/*
				 * Set the current value for the current function, so we can keep the analyst
				 * updated based on the number of functions (as only the current and total
				 * number of levels in the graph is shown via the monitor message
				 */
				currentFunctionCount++;
				/*
				 * Create a worker to schedule in the thread pool. The worker will connect with
				 * the LLM and use the response to modify the given function based on the
				 * predefined settings with regards to renaming.
				 */
				FunctionWorker worker = new FunctionWorker(decompiler, function, totalFunctionCount,
						currentFunctionCount);
				// Schedule the worker in the executor
				executor.execute(worker);
			}

			// Shut the executor down, meaning no new workers can be added
			executor.shutdown();

			// Wait until all workers have completed their work
			while (executor.isTerminated() == false) {
				// If the user cancels the script, cancel the execution
				if (monitor.isCancelled()) {
					throw new CancelledException();
				}
				/*
				 * If the workers are running and the script isn't cancelled by the user, sleep
				 * for one second to avoid using CPU cycles and check again after the sleep
				 * finishes.
				 */
				Thread.sleep(1000);
			}
			/*
			 * Before moving on to the next level, we wait for any ongoing automatic
			 * analysis to complete
			 */
			waitUntilAutoAnalysisCompletes();
		}
	}

	/**
	 * A function to remove empty list entries from the list of lists. The functions
	 * within each list within the given list are also iterated over, excluding
	 * external and thunk functions, as these will not be handled afterwards
	 * 
	 * @param list the list which contains the levels, where each level is a list of
	 *             functions
	 * @return a list with the levels, where each level contains 1 or more
	 *         functions, and all included functions are non-thunk and non-external
	 */
	private List<List<Function>> cleanAndReverseList(List<List<Function>> list) {
		// The output variable
		List<List<Function>> output = new ArrayList<>();

		// Iterate backwards over the list
		for (int i = list.size(); i-- > 0;) {
			// Get the current level
			List<Function> level = list.get(i);
			// Skip empty levels
			if (level.isEmpty()) {
				continue;
			}
			// Create a new list of functions
			List<Function> functions = new ArrayList<>();
			// Iterate over the functions within the level
			for (Function f : level) {
				// Exclude external and thunk functions
				if (f.isExternal() || f.isThunk()) {
					continue;
				}
				// Add non-thunk and non-external functions to the list
				functions.add(f);
			}
			// Add the filtered level to the output variable
			output.add(functions);
		}

		/*
		 * Return the list with the levels, in the original order with the applied
		 * filters
		 */
		return output;
	}

	/**
	 * Prints the given message via the
	 * {@link ghidra.app.script.GhidraScript#println(String)} method, depending on
	 * the running mode and boolean.
	 * 
	 * @param message       the message to print
	 * @param printHeadless true if the message should be printed when executing
	 *                      headless, false if not
	 */
	private void log(String message, boolean printHeadless) {
		if (SystemUtilities.isInHeadlessMode()) {
			if (printHeadless == false) {
				return;
			}
		}
		println(message);
	}

	/**
	 * This method only returns once the auto analysis manager is done analyzing. If
	 * the user cancels, a cancelled exception is thrown.
	 * 
	 * @throws InterruptedException
	 * @throws CancelledException
	 */
	private void waitUntilAutoAnalysisCompletes() throws InterruptedException, CancelledException {
		while (autoAnalysisManager.isAnalyzing()) {
			if (monitor.isCancelled()) {
				throw new CancelledException();
			}
			Thread.sleep(1000); // Sleep to avoid consuming extra CPU cycles in-between checks
		}
	}

	/**
	 * A thread safe method to increment the monitor
	 */
	private synchronized void incrementMonitorThreadSafe() {
		// Does not check for cancellation
		monitor.incrementProgress();
	}

	/**
	 * A thread safe method to verify if a method's name is unique.
	 * 
	 * @param functionName The function name to verify
	 * @return true if the name is unique, false if not
	 */
	private synchronized boolean isUniqueFunctionName(String functionName) {
		for (Function function : currentProgram.getFunctionManager().getFunctionsNoStubs(currentProgram.getMinAddress(),
				true)) {
			if (function.getName().equalsIgnoreCase(functionName)) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Returns a unique function name. If the name is not unique, an underscore is
	 * appended
	 * 
	 * @param functionName the name to check
	 * @return the unique name
	 */
	private synchronized String getUniqueFunctionName(String functionName) {
		if (isUniqueFunctionName(functionName)) {
			return functionName;
		}

		functionName += "_";
		return getUniqueFunctionName(functionName);
	}

	/**
	 * The class where the threaded execution to handle a given function is handled
	 */
	private class FunctionWorker implements Runnable {

		private DecompInterface decompiler;
		private Function function;
		int totalFunctionCount;
		int currentFunctionCount;

		public FunctionWorker(DecompInterface decompiler, Function function, int totalFunctionCount,
				int currentFunctionCount) {
			this.decompiler = decompiler;
			this.function = function;
			this.totalFunctionCount = totalFunctionCount;
			this.currentFunctionCount = currentFunctionCount;
		}

		/**
		 * The run method of the thread, not to be confused with the script's main run
		 * method!
		 */
		@Override
		public void run() {
			// Decompile the given function
			DecompileResults results = decompiler.decompileFunction(function, DECOMPILER_TIMEOUT, monitor);
			// Get the decompiled function
			DecompiledFunction dFunction = results.getDecompiledFunction();
			// Get the pseudo-C representation of the decompiled function
			String code = dFunction.getC();
			// Get the plate comment, if present
			String tempComment = getPlateComment(function.getEntryPoint());
			// If the comment is non-null, it exists
			if (tempComment != null) {
				/*
				 * Remove the comment from the pseudo-C representation to avoid overloading the
				 * LLM's context window
				 */
				code = code.replace(tempComment, "");
			}

			// Get the function's variables
			Variable[] variables = function.getAllVariables();

			// Contact the LLM and store the JSON-based response
			JsonResponse response = contactLLM(code);
			// If the response is null, an error occurred
			if (response == null) {
				// Print an error if there is an error
				printerr(
						"The LLM's return value cannot be parsed as the format is invalid or the LLM did not respond at all");
				// Return from the thread
				return;
			}

			// Declare and initialize the comment
			String comment = "";

			// Store the old function name
			String oldFunctionName = function.getName();
			// Get the new function name from the LLM response
			String newFunctionName = response.getFunctionName();
			// If the new name is present and is not an empty or whitespace-only string
			if (newFunctionName != null && newFunctionName.isBlank() == false) {
				// If functions should be renamed
				if (RENAME_FUNCTION) {
					// Only rename functions with default names
					if (function.getName().toLowerCase().startsWith("fun_")) {
						try {
							// Set the new name
							function.setName(getUniqueFunctionName(newFunctionName), SourceType.IMPORTED);
							// Log the rename to non-headless instances
							log(oldFunctionName + " -> " + newFunctionName, false);
							// Add the name change to the comment
							comment += "Changed " + oldFunctionName + " into " + newFunctionName + "\n\n";
						} catch (Exception ex) {
							printerr("Function renaming failed:\n" + ex.toString());
						}
					}
				}
				/*
				 * If the function should not be renamed, or if the function name does not start
				 * with fun_, the suggested name is still added to the comment
				 */
				if (RENAME_FUNCTION == false || function.getName().toLowerCase().startsWith("fun_") == false) {
					comment += "AI suggested function name: " + newFunctionName + "\n\n";
				}
			}

			// If one or more variables are present in the function and LLM response
			if (variables.length > 0 && response.getVariableNames() != null) {
				// Set the next part of the comment
				comment += "Variables:\n";
				// Iterate over all variables
				for (Variable variable : variables) {
					// Get the old name
					String oldVariableName = variable.getName();
					// Get the new name
					String newVariableName = response.getVariableNames().get(oldVariableName);
					// If the new name is non-null and is not an empty or whitespace-only string
					if (newVariableName != null && newVariableName.isBlank() == false) {
						// If variables should be renamed
						if (RENAME_VARIABLES) {
							try {
								// Set the name
								variable.setName(newVariableName, SourceType.IMPORTED);
							} catch (Exception ex) {
								printerr("Variable renaming failed:\n" + ex.toString());
							}
						}
						// Add the renaming to the comment
						comment += "\t\tAI variable name: \"" + oldVariableName + "\" -> \"" + newVariableName + "\"\n";
					}
				}
				// Log the variables in Ghidra, when running non-headless
				log("Variables for " + function.getName() + " renamed", false);
				comment += "\n";
			}

			// Get the summary from the LLM
			String summary = response.getSummary();
			// If the summary is non-null and is not an empty or whitespace-only string
			if (summary != null && summary.isBlank() == false) {
				// Add the summary to the comment
				comment += "AI function summary: " + summary;
			}

			// If the comment is not whitespace-only or empty
			if (comment.isBlank() == false) {
				// Set the comment to the function
				setComment(function, comment, false);
				// Log the summary addition for non-headless instances
				log("Summary for " + function.getName() + " added", false);
			}

			/*
			 * This message is always logged (when running headless and non-headless) to
			 * give an indication of the progress
			 */
			log("Completed " + function.getName() + " (" + currentFunctionCount + "/" + totalFunctionCount + ")", true);
			// Increment the monitor to update the progress in a thread safe manner
			incrementMonitorThreadSafe();
		}
	}

	/**
	 * Send the HTTP POST request to LLM
	 * 
	 * @param body the body of comma separated strings to check
	 * @return the JSON response from the server
	 * @throws IOException
	 */
	private String sendPostRequest(Map<String, String> headers, String body) throws IOException {
		URL url = URI.create(API_URL).toURL();
		HttpURLConnection connection = (HttpURLConnection) url.openConnection();
		connection.setRequestMethod("POST");

		for (Map.Entry<String, String> entry : headers.entrySet()) {
			connection.setRequestProperty(entry.getKey(), entry.getValue());
		}

		connection.setConnectTimeout(POST_REQUEST_TIMEOUT);
		connection.setReadTimeout(POST_REQUEST_TIMEOUT);

		connection.setDoOutput(true);
		try (OutputStream outputStream = connection.getOutputStream()) {
			byte[] rawBody = body.getBytes("utf-8");
			outputStream.write(rawBody, 0, rawBody.length);
		}

		// TODO use response code to potentially throw an exception
		int responseCode = connection.getResponseCode();

		try (BufferedReader bufferedReader = new BufferedReader(
				new InputStreamReader(connection.getInputStream(), "utf-8"))) {
			StringBuilder response = new StringBuilder();
			String line = null;
			while ((line = bufferedReader.readLine()) != null) {
				response.append(line.trim());
			}
			return response.toString();
		}
	}

	/**
	 * Prompt the LLM by providing the pseudo-C code as the argument
	 * 
	 * @param code the function's pseudo-C code
	 * @return the LLM's JSON response
	 * @throws IOException
	 */
	public String promptLlmApi(String code) throws IOException {
		Map<String, String> headers = new HashMap<>();
		headers.put("Content-Type", "application/json");
		headers.put("Accept", "application/json");

		String prompt = "For the following decompiled code from Ghidra, suggest a new name for the function, summarise the function, and suggest new names for each of the variables in the function. State the old name of the variable and the new name. The response should be a JSON object with \"functionName\" as the key for the suggested function name, the key \"summary\" should contain the function's summary, and a nested JSON object named \"variableNames\" with the old variable names as keys, where the value of each key is the newly suggested name. The response should only the the requested JSON object, nothing else.\n\n"
				+ code;

		return sendPostRequest(headers, prompt);
	}

	/**
	 * Contact the LLM with the pseudo-C code and prompt
	 * 
	 * @param code the function's pseudo-C code
	 * @return a Java object in which the LLM's JSON response is already parsed
	 */
	private JsonResponse contactLLM(String code) {
		try {
			String response = promptLlmApi(code);

			if (response == null) {
				// return null;
			}
			JsonResponse jsonResponse = gson.fromJson(response, JsonResponse.class);
			return jsonResponse;
		} catch (IOException ex) {
			printerr(ex.toString());
			return null;
		} catch (JsonSyntaxException ex) {
			printerr(ex.toString());
			return null;
		} catch (Exception ex) {
			printerr(ex.toString());
			return null;
		}
	}

	/**
	 * Helper function to set a comment at a given function, with the indication if
	 * this comment should be at the top or bottom of any already existing function
	 * comment at this function
	 * 
	 * @param function  the function to set a comment at
	 * @param comment   the comment to set at the given function
	 * @param pushToTop true if the function's existing comment (if any) should be
	 *                  put below this comment, false if not
	 */
	private void setComment(Function function, String comment, boolean pushToTop) {
		// Get the old comment, which is null if no comment is present
		String oldComment = function.getComment();
		// Check for the existence of the old comment
		if (oldComment != null) {
			// If it is present, trim the comment to avoid redundant whitespace
			oldComment = oldComment.trim();
			// If the string, post trimming, is not empty nor blank (which also checks if it
			// is empty)
			if (oldComment.isEmpty() == false && oldComment.isBlank() == false) {
				// If the comment should be at the top, place it at the top
				if (pushToTop) {
					comment += "\n\n" + oldComment;
				} else { // Else put it at the bottom
					comment = oldComment += "\n\n" + comment;
				}
			}
		}

		/**
		 * Set the comment, which contains the prior comment at the correct placement
		 * with regards to the given boolean if it existed
		 */
		function.setComment(comment);
	}

	/**
	 * The class used to store the HTTP LLM API response in
	 */
	private class JsonResponse {
		private String functionName;
		private String summary;
		private Map<String, String> variableNames;

		@SuppressWarnings("unused")
		public JsonResponse() {

		}

		/**
		 * Gets the AI generated function name
		 * 
		 * @return the AI generated function name
		 */
		public String getFunctionName() {
			return functionName;
		}

		/**
		 * Gets the AI generated summary
		 * 
		 * @return the AI generated summary
		 */
		public String getSummary() {
			return summary;
		}

		/**
		 * Gets the mapping of the variable names (as keys) and the AI generated
		 * variable names (as a value, one for each key)
		 * 
		 * @return gets the AI generated variable names for the current variable names
		 */
		public Map<String, String> getVariableNames() {
			return variableNames;
		}
	}

	// From here onwards, the code is from the Ghidra source code

	private int getMaxLevel(Map<CodeBlockVertex, Integer> levelMap) {
		int maxLevel = -1;
		for (Integer level : levelMap.values()) {
			if (level > maxLevel) {
				maxLevel = level;
			}
		}
		return maxLevel;
	}

	private Function getFunctionFromCodeBlockVertex(CodeBlockVertex vertex) {
		Address startAddress = vertex.getCodeBlock().getFirstStartAddress();
		Function function = getFunctionAt(startAddress);
		return function;
	}

	private List<List<Function>> createFunctionList(Map<CodeBlockVertex, Integer> levelMap) {
		List<List<Function>> levelList = new ArrayList<>();
		int maxLevel = getMaxLevel(levelMap);
		for (int i = 0; i <= maxLevel; i++) {
			levelList.add(new ArrayList<Function>());
		}
		for (CodeBlockVertex vertex : levelMap.keySet()) {
			int reverseLevel = maxLevel - levelMap.get(vertex);
			Function function = getFunctionFromCodeBlockVertex(vertex);
			if (function != null) {
				levelList.get(reverseLevel).add(function);
			}
		}
		return levelList;
	}

	protected GDirectedGraph<CodeBlockVertex, CodeBlockEdge> createCallGraph() throws CancelledException {

		Map<CodeBlock, CodeBlockVertex> instanceMap = new HashMap<>();
		GDirectedGraph<CodeBlockVertex, CodeBlockEdge> graph = GraphFactory.createDirectedGraph();
		CodeBlockIterator codeBlocks = new BasicBlockModel(currentProgram, true).getCodeBlocks(monitor);
		while (codeBlocks.hasNext()) {
			CodeBlock block = codeBlocks.next();

			CodeBlockVertex fromVertex = instanceMap.get(block);
			if (fromVertex == null) {
				fromVertex = new CodeBlockVertex(block);
				instanceMap.put(block, fromVertex);
				graph.addVertex(fromVertex);
			}

			// destinations section
			addEdgesForDestinations(graph, fromVertex, block, instanceMap);
		}
		return graph;
	}

	private void addEdgesForDestinations(GDirectedGraph<CodeBlockVertex, CodeBlockEdge> graph,
			CodeBlockVertex fromVertex, CodeBlock sourceBlock, Map<CodeBlock, CodeBlockVertex> instanceMap)
			throws CancelledException {

		CodeBlockReferenceIterator iterator = sourceBlock.getDestinations(monitor);
		while (iterator.hasNext()) {
			monitor.checkCancelled();

			CodeBlockReference destination = iterator.next();
			CodeBlock targetBlock = getDestinationBlock(destination);
			if (targetBlock == null) {
				continue; // no block found
			}

			CodeBlockVertex targetVertex = instanceMap.get(targetBlock);
			if (targetVertex == null) {
				targetVertex = new CodeBlockVertex(targetBlock);
				instanceMap.put(targetBlock, targetVertex);
			}

			graph.addVertex(targetVertex);
			graph.addEdge(new CodeBlockEdge(fromVertex, targetVertex));
		}
	}

	private CodeBlock getDestinationBlock(CodeBlockReference destination) throws CancelledException {

		Address targetAddress = destination.getDestinationAddress();
		CodeBlock targetBlock = new BasicBlockModel(currentProgram, true).getFirstCodeBlockContaining(targetAddress,
				monitor);
		if (targetBlock == null) {
			return null; // no code found for call; external?
		}

		return targetBlock;
	}
}

```

`GolangDynamicStringRecovery.java`:

```java
//Finds and creates dynamically allocated strings based on the Golang stringStruct 
//@author Max 'Libra' Kersten of Trellix' Advanced Research Center, based on the work by padorka@cujoai (https://github.com/getCUJO/ThreatIntel/blob/master/Scripts/Ghidra/find_dynamic_strings.py)
//@category Golang
//@keybinding
//@menupath
//@toolbar

import java.util.ArrayList;
import java.util.List;

import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.Address;
import ghidra.program.model.lang.OperandType;
import ghidra.program.model.lang.Register;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.program.model.scalar.Scalar;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.CancelledException;

public class GolangDynamicStringRecovery extends GhidraScript {

	/**
	 * A boolean which defines if logging should be enabled. When prioritising
	 * speed, one might not be interested in getting all messages, but rather only
	 * the concluding message, along with potential error messages. As such, this
	 * boolean specifies if more logging should be enabled or disabled.</br>
	 * </br>
	 * The default value of this field is <code>true</code>.
	 */
	private static final boolean ENABLE_LOGGING = true;

	/**
	 * The size of a pointer on X86
	 */
	private static final int POINTER_SIZE_X86 = 4;

	/**
	 * The size of a pointer on X64
	 */
	private static final int POINTER_SIZE_X64 = 8;

	/**
	 * The number of recovered dynamic strings
	 */
	private static int stringCount = 0;

	@Override
	protected void run() throws Exception {
		/*
		 * Get the language ID and the program's pointer size and store those locally,
		 * as they are re-used multiple times
		 */
		String languageId = currentProgram.getLanguageID().toString();
		int pointerSize = currentProgram.getDefaultPointerSize();

		/*
		 * Based on the language ID, the dynamic strings need to be recovered
		 * differently
		 */
		if (languageId.startsWith("ARM")) { // 32-bit ARM
			resolve32BitArm();
		} else if (languageId.startsWith("AARCH64")) { // 64-bit ARM
			resolve64BitArm();
		} else if (languageId.startsWith("x86") && pointerSize == POINTER_SIZE_X86) { // x86
			resolveIntel(false);
		} else if (languageId.startsWith("x86") && pointerSize == POINTER_SIZE_X64) { // x86_64
			resolveIntel(true);
		} else { // Print an error message if the architecture is not supported
			printerr("Unsupported architecture: " + languageId);
			return;
		}

		// Print the total number of recovered strings
		println("Total number of recovered dynamic strings: " + stringCount);
	}

	/**
	 * A wrapper function for the
	 * {@link ghidra.app.script.GhidraScript#println(String)} which is only called
	 * if the {@link #ENABLE_LOGGING} is <code>true</code>. The logging that is
	 * (potentially) passing through this function, is meant as optional logging.
	 * The final conclusion, as well as the logging of any error messages, should be
	 * printed via direct calls. The easy-to-omit nature of optional messages speeds
	 * up automated analysis by limiting the number of print calls.
	 * 
	 * @param message
	 */
	private void log(String message) {
		if (ENABLE_LOGGING) {
			println(message);
		}
	}

	/**
	 * Creates an ASCII string at the given address with the given length, and
	 * returns the instruction after the given instruction
	 * 
	 * @param instruction the current instruction within the program
	 * @param address     the address of the ASCII string
	 * @param length      the length of the ASCII string
	 * @return the instruction after the instruction variable, or null if there is
	 *         no such instruction
	 */
	private Instruction createString(Instruction instruction, Address address, Integer length) {
		try {
			//Get the data' starting point
			Data checkData = getDataContaining(address);
			if (checkData != null) {
				clearListing(address);
				
			}
			// Create the ASCII string at the given address with the given length
			Data data = createAsciiString(address, length);
			// Gets the newly created string as a String object
			String ascii = (String) data.getValue();
			// Optionally print the address (clickable in Ghidra's console) along with the
			// value
			log("0x" + Long.toHexString(address.getOffset()) + " : \"" + ascii + "\"");
			// Increment the number of recovered dynamic strings
			stringCount++;
		} catch (Exception ex) {
			// Ignore exceptions
		}
		// Return the next instruction
		return getInstructionAfter(instruction);
	}

	/**
	 * This helper function returns the integer value of a scalar object. The
	 * purpose of this function is to avoid repeated casting in numerous places
	 * within the script.
	 * 
	 * @param scalar the object to get the integer value from
	 * @return the integer value of the given scalar object
	 */
	private Integer getInteger(Scalar scalar) {
		return ((Long) scalar.getValue()).intValue();
	}

	/**
	 * Gets all memory blocks which have a name equal to .text or __text (used in PE
	 * and ELF, and Mach-O files respectively), disregarding the used casing. The
	 * list can be empty, but never null.
	 * 
	 * @return all .text or __text named memory blocks (used in PE and ELF, and
	 *         Mach-O files respectively), disregarding the used casing
	 */
	private List<MemoryBlock> getTextMemoryBlocks() {
		// Declare and initialise the list
		List<MemoryBlock> blocks = new ArrayList<>();

		// Iterate over all blocks
		for (MemoryBlock block : getMemoryBlocks()) {
			// Check if the name is equal, disregarding the case
			if (block.getName().equalsIgnoreCase(".text") || block.getName().equalsIgnoreCase("__text")) {
				// If it is equal, add it to the list
				blocks.add(block);
			}
		}
		// Return the list, which might be empty
		return blocks;
	}

	/**
	 * Resolves the dynamic strings for Intel architecture based binaries. This
	 * works for both x86 and x86_64 architectures
	 * 
	 * @param is64Bit true if the given binary is 64-bit, false if not
	 */
	private void resolveIntel(boolean is64Bit) {
		// Iterate over all memory blocks
		for (MemoryBlock block : getTextMemoryBlocks()) {
			// Get the first instruction from this block
			Instruction instruction = getInstructionAt(block.getStart());

			// Loop as long as an instruction is present and valid
			while (instruction != null) {
				// Check if the script's execution is cancelled
				if (monitor.isCancelled()) {
					// Return from the recovery function, thus exiting the script's execution early
					return;
				}

				try {
					// Get the operand type at index 1, which should be an address
					int operandType = instruction.getOperandType(1);
					// Get the register at index zero
					Register register = instruction.getRegister(0);

					/*
					 * Check the first instruction of a dynamically allocated string:
					 * 
					 * LEA REG, [STRING_ADDRESS]
					 * 
					 * This is the same for x86 and x86_64, hence no bitness check
					 */
					if (instruction.getMnemonicString().equalsIgnoreCase("LEA") == false || register == null
							|| OperandType.isAddress(operandType) == false) {
						// Get the next instruction
						instruction = getInstructionAfter(instruction);
						// Skip this item in the loop
						continue;
					}

					// Get the next instruction
					Instruction instructionTwo = getInstructionAfter(instruction);

					/*
					 * Check the second instruction:
					 * 
					 * MOV [SP + ..], REG
					 * 
					 * Note that the stack pointer is either ESP or RSP, depending on the
					 * architecture (x86 or x86_64 respectively)
					 * 
					 * Also note that REG refers to the same register as the first instruction used
					 * 
					 * The is64Bit boolean is true if the used architecture is x86_64, false if it
					 * is x86
					 */
					if (instructionTwo.getMnemonicString().equalsIgnoreCase("MOV") == false
							|| instructionTwo.getRegister(1) != register) {
						if ((is64Bit == false
								&& instructionTwo.getOpObjects(0)[0].toString().equalsIgnoreCase("ESP") == false)
								|| (is64Bit == true && instructionTwo.getOpObjects(0)[0].toString()
										.equalsIgnoreCase("RSP") == false)) {
							// Get the next instruction
							instruction = getInstructionAfter(instruction);
							// Skip this item in the loop
							continue;
						}
					}

					// Get the third instruction
					Instruction instructionThree = getInstructionAfter(instructionTwo);

					/*
					 * Get the operand type (should be a scalar) at index one of the third
					 * instruction
					 */
					operandType = instructionThree.getOperandType(1);

					/*
					 * Look for the third instruction, which follows either of the following
					 * patterns, depending on the architecture:
					 * 
					 * MOV [ESP + ..], STRING_SIZE
					 * 
					 * MOV [RSP + ..], STRING_SIZE
					 * 
					 * Note that the operand type should be of the scalar type
					 * 
					 * The is64Bit boolean is true if the used architecture is x86_64, false if it
					 * is x86
					 */
					if (instructionThree.getMnemonicString().equalsIgnoreCase("MOV") == false
							|| OperandType.isScalar(operandType) == false) {
						if ((is64Bit == false
								&& instructionThree.getOpObjects(0)[0].toString().equalsIgnoreCase("ESP") == false)
								|| (is64Bit == true && instructionThree.getOpObjects(0)[0].toString()
										.equalsIgnoreCase("RSP") == false)) {
							// Get the next instruction
							instruction = getInstructionAfter(instruction);
							// Skip this item in the loop
							continue;
						}
					}

					// Get the address
					Address address = instruction.getPrimaryReference(1).getToAddress();
					/*
					 * Get the instruction's first indexed object, of which the first element (index
					 * 0) is used
					 */
					Object object = instructionThree.getOpObjects(1)[0];

					// Check if the object is of the scalar type
					if (object instanceof Scalar == false) {
						// Get the next instruction
						instruction = getInstructionAfter(instruction);
						// Skip this item in the loop
						continue;
					}

					/*
					 * This code can only be reached if the object's type is scalar, so it can
					 * safely be cast
					 */
					Scalar scalar = (Scalar) object;
					// Get the integer value of the scalar object
					Integer lengthValue = getInteger(scalar);
					/*
					 * Create a string at the given address with the given length, and increment to
					 * the next instruction
					 */
					instruction = createString(instruction, address, lengthValue);
				} catch (Exception ex) {
					// Get the next instruction
					instruction = getInstructionAfter(instruction);
					// Skip this item in the loop
					continue;
				}
			}
		}
	}

	/**
	 * Resolves the dynamic strings for 32-bit ARM architecture based binaries
	 */
	private void resolve32BitArm() {
		/*
		 * #ARM, 32-bit
		 * 
		 * #LDR REG, [STRING_ADDRESS_POINTER]
		 * 
		 * #STR REG, [SP, ..]
		 * 
		 * #MOV REG, STRING_SIZE
		 * 
		 * #STR REG, [SP, ..]
		 */
		// Iterate over all memory blocks
		for (MemoryBlock block : getTextMemoryBlocks()) {
			// Get the first instruction
			Instruction instruction = getInstructionAt(block.getStart());

			// Loop as long as an instruction is present and valid
			while (instruction != null) {
				// Check if the script's execution is cancelled
				if (monitor.isCancelled()) {
					// Return from the recovery function, thus exiting the script's execution early
					return;
				}

				try {
					// Get the operand type, which should be an address or a scalar
					int operandType = instruction.getOperandType(1);

					// Check first instruction: LDR REG, [STRING_ADDRESS_POINTER]
					if (instruction.getMnemonicString().equalsIgnoreCase("ldr") == false
							|| instruction.getRegister(0) == null || OperandType.isAddress(operandType) == false
							|| OperandType.isScalar(operandType) == false) {
						// Get the next instruction
						instruction = getInstructionAfter(instruction);
						// Skip this item in the loop
						continue;
					}

					// Get the register at index 0
					Register register = instruction.getRegister(0);
					// Get the second instruction
					Instruction instructionTwo = getInstructionAfter(instruction);

					/*
					 * Check second instruction:
					 * 
					 * STR REG, [SP + ..]
					 * 
					 * Note that the register REG should be the same as the register that was used
					 * in the first instruction
					 */
					if (instructionTwo.getMnemonicString().equalsIgnoreCase("str") == false
							|| instructionTwo.getRegister(0) != register
							|| instructionTwo.getOpObjects(1)[0].toString().equalsIgnoreCase("sp") == false) {
						// Get the next instruction
						instruction = getInstructionAfter(instruction);
						// Skip this item in the loop
						continue;
					}

					// Get the third instruction
					Instruction instructionThree = getInstructionAfter(instructionTwo);
					// Get the operand type, which should be a scalar
					operandType = instructionThree.getOperandType(1);

					// Check third instruction: MOV REG, STRING_SIZE
					if (instructionThree.getMnemonicString().equalsIgnoreCase("mov") == false
							|| instructionThree.getRegister(0) == null || OperandType.isScalar(operandType) == false) {
						// Get the next instruction
						instruction = getInstructionAfter(instruction);
						// Skip this item in the loop
						continue;
					}

					// Get the first register from the third instruction
					register = instructionThree.getRegister(0);
					// Get the first instruction
					Instruction instructionFour = getInstructionAfter(instructionThree);

					/*
					 * Check fourth instruction:
					 * 
					 * STR REG, [SP + ..]
					 * 
					 * Note that the register REG should be the same register that was used in the
					 * third instruction
					 */
					if (instructionFour.getMnemonicString().equalsIgnoreCase("str") == false
							|| instructionFour.getRegister(0) != register
							|| instructionFour.getOpObjects(1)[0].toString().equalsIgnoreCase("sp") == false) {
						// Get the next instruction
						instruction = getInstructionAfter(instruction);
						// Skip this item in the loop
						continue;
					}

					// Get the address pointer
					int addressPointer = getInt(instruction.getPrimaryReference(1).getToAddress());
					// Get the address, essentially dereferencing the pointer
					Address address = currentProgram.getAddressFactory().getAddress(Long.toHexString(addressPointer));

					// Get the second object (index 1) from the third instruction
					Object object = instructionThree.getOpObjects(1)[0];
					// Check if the object is of the scalar type
					if (object instanceof Scalar == false) {
						// Get the next instruction
						instruction = getInstructionAfter(instruction);
						// Skip this item in the loop
						continue;
					}
					/*
					 * This code is only reachable if the object is of the scalar type, so it can be
					 * cast
					 */
					Scalar scalar = (Scalar) object;
					// Get the scalar's value as an integer
					Integer length = getInteger(scalar);
					/*
					 * Create the ASCII string at the given address for the given length, along with
					 * the next instruction
					 */
					instruction = createString(instruction, address, length);
				} catch (Exception ex) {
					// Ignore exceptions
				}
			}
		}
	}

	/*
	 * Resolves the dynamic strings for 64-bit ARM architecture based binaries
	 */
	private void resolve64BitArm() {
		/*
		 * #ARM, 64-bit - version 1
		 * 
		 * #ADRP REG, [STRING_ADDRESS_START]
		 * 
		 * #ADD REG, REG, INT
		 * 
		 * #STR REG, [SP, ..]
		 * 
		 * #ORR REG, REG, STRING_SIZE
		 * 
		 * #STR REG, [SP, ..]
		 * 
		 * #ARM, 64-bit - version 2
		 *
		 * #ADRP REG, [STRING_ADDRESS_START]
		 *
		 * #ADD REG, REG, INT
		 *
		 * #STR REG, [SP, ..]
		 *
		 * #MOV REG, STRING_SIZE
		 *
		 * #STR REG, [SP, ..]
		 */

		// Iterate over all memory blocks
		for (MemoryBlock block : getTextMemoryBlocks()) {
			// Get the first instruction from this block
			Instruction instruction = getInstructionAt(block.getStart());

			// Loop as long as an instruction is present and valid
			while (instruction != null) {
				// Check if the script's execution is cancelled
				if (monitor.isCancelled()) {
					// Return from the recovery function, thus exiting the script's execution early
					return;
				}

				// Get the operand type at index 1, which should be a scalar
				int operandType = instruction.getOperandType(1);
				// Get the register at index zero
				Register register = instruction.getRegister(0);

				/*
				 * Check first instruction of a dynamically allocated string
				 * 
				 * ADRP REG, [STRING_ADDRESS_START]
				 */
				if (instruction.getMnemonicString().equalsIgnoreCase("adrp") == false
						|| instruction.getRegister(0) == null || OperandType.isAddress(operandType) == false
						|| OperandType.isScalar(operandType) == false) {
					// Get the next instruction
					instruction = getInstructionAfter(instruction);
					// Skip this item in the loop
					continue;
				}

				// Get the second instruction
				Instruction instructionTwo = getInstructionAfter(instruction);
				/*
				 * Get the operand type of the second instruction at index 2, which should be of
				 * the scalar type
				 */
				operandType = instructionTwo.getOperandType(2);

				/*
				 * Check second instruction:
				 * 
				 * ADD REG, REG, INT
				 * 
				 * Note that REG refers to the same register as the first instruction used
				 * 
				 * Also note that the operand type needs to be of the scalar type
				 */
				if (instructionTwo.getMnemonicString().equalsIgnoreCase("add") == false
						|| instructionTwo.getRegister(0) != register || OperandType.isScalar(operandType) == false) {
					// Get the next instruction
					instruction = getInstructionAfter(instruction);
					// Skip this item in the loop
					continue;
				}

				// Get the third instruction
				Instruction instructionThree = getInstructionAfter(instructionTwo);

				/*
				 * Check the third instruction:
				 * 
				 * STR REG, [SP + ..]
				 * 
				 * Note that REG refers to the same register as the first instruction used
				 */
				if (instructionThree.getMnemonicString().equalsIgnoreCase("str") == false
						|| instructionThree.getRegister(0) != register
						|| instructionThree.getOpObjects(1)[0].toString().equalsIgnoreCase("sp") == false) {
					// Get the next instruction
					instruction = getInstructionAfter(instruction);
					// Skip this item in the loop
					continue;
				}

				// Get the fourth instruction
				Instruction instructionFour = getInstructionAfter(instructionThree);
				// Get the register from the fourth instruction, at index 0
				register = instructionFour.getRegister(0);

				/*
				 * Declare several variables, which are to be initialised at a later stage,
				 * depending on the way it is loaded (version 1 or version 2)
				 */
				int length;
				Object object;
				Scalar scalar;

				/*
				 * Check fourth instruction:
				 * 
				 * Version 1: ORR REG, REG, STRING_SIZE
				 * 
				 * Version 2: MOV REG, STRING_SIZE
				 * 
				 * Note that the operand type needs to be a scalar
				 * 
				 * Also note that the register from the fourth instruction should not be null
				 */
				if (instructionFour.getMnemonicString().equalsIgnoreCase("orr") == false && register != null
						&& OperandType.isScalar(instructionFour.getOperandType(2)) == true) {
					// Get the relevant object
					object = instructionFour.getOpObjects(2)[0];
					/*
					 * The relevant object is of the scalar type, as defined within the if-statement
					 */
					scalar = (Scalar) object;
					// Get the scalar's value as an integer
					length = getInteger(scalar);
				} else if (instructionFour.getMnemonicString().equalsIgnoreCase("mov") && register != null
						&& OperandType.isScalar(instructionFour.getOperandType(1)) == true) {
					// Get the relevant object
					object = instructionFour.getOpObjects(1)[0];
					/*
					 * The relevant object is of the scalar type, as defined within the if-statement
					 */
					scalar = (Scalar) object;
					// Get the scalar's value as an integer
					length = getInteger(scalar);
				} else {
					// Get the next instruction
					instruction = getInstructionAfter(instruction);
					// Skip this item in the loop
					continue;
				}

				// Gets the fifth instruction
				Instruction instructionFive = getInstructionAfter(instructionFour);

				/*
				 * Check fifth instruction:
				 * 
				 * STR REG, [SP + ..]
				 * 
				 * Note that REG refers to the same register as the fourth instruction used
				 */
				if (instructionFive.getMnemonicString().equalsIgnoreCase("str") == false
						|| instructionFive.getRegister(0) != register
						|| instructionFive.getOpObjects(1)[0].toString().equalsIgnoreCase("sp") == false) {
					// Get the next instruction
					instruction = getInstructionAfter(instruction);
					// Skip this item in the loop
					continue;
				}
				// Get two objects
				Object objA = instruction.getOpObjects(1)[0];
				Object objB = instructionTwo.getOpObjects(2)[0];

				// Ensure that both objects are of the scalar type
				if (objA instanceof Scalar == false || objB instanceof Scalar == false) {
					// Gets the next instruction
					instruction = getInstructionAfter(instruction);
					// Skip this item in the loop
					continue;
				}

				// Cast the object to the correct type if this code is reached
				scalar = (Scalar) objA;
				// Get the scalar's value as an integer
				Integer addressPointer = getInteger(scalar);

				// Cast the object to the correct type if this code is reached
				scalar = (Scalar) objB;

				/*
				 * Get the scalar's value as an integer. Note the "+=" instead of "="
				 */
				addressPointer += getInteger(scalar);

				// Dereference the pointer
				Address address = currentProgram.getAddressFactory().getAddress(Long.toHexString(addressPointer));

				/*
				 * Create the ASCII string at the given address for the given length, along with
				 * the next instruction
				 */
				instruction = createString(instruction, address, length);
			}
		}
	}
}

```

`GolangFunctionRecovery.java`:

```java
//Finds and creates functions with their original names, in Golang based PE and ELF files. Functions which have already been found by Ghidra will be renamed if a suitable name is found.  
//@author Max 'Libra' Kersten of Trellix' Advanced Research Center, based on the work by padorka@cujoai (https://github.com/getCUJO/ThreatIntel/blob/master/Scripts/Ghidra/go_func.py) 
//@category Golang
//@keybinding
//@menupath
//@toolbar


import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOutOfBoundsException;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;

public class GolangFunctionRecovery extends GhidraScript {

	/**
	 * A boolean which defines if logging should be enabled. When prioritising
	 * speed, one might not be interested in getting all messages, but rather only
	 * the concluding message, along with potential error messages. As such, this
	 * boolean specifies if more logging should be enabled or disabled.</br>
	 * </br>
	 * The default value of this field is <code>true</code>.
	 */
	private static final boolean ENABLE_LOGGING = true;

	/**
	 * The mask to perform the logical AND with on the magic value
	 */
	private static final int MAGIC_MASK = 0xffffffff;

	/**
	 * The magic value for Golang 1.20 and above
	 * 
	 * @see <a href=
	 *      "https://github.com/golang/go/blob/master/src/debug/gosym/pclntab.go">Golang
	 *      pclntab source code</a>
	 */
	private static final int GO_120 = 0xfffffff1;

	/**
	 * The magic value for Golang 1.18
	 * 
	 * @see <a href=
	 *      "https://github.com/golang/go/blob/master/src/debug/gosym/pclntab.go">Golang
	 *      pclntab source code</a>
	 */
	private static final int GO_118 = 0xfffffff0;

	/**
	 * The magic value for Golang 1.16 through version 1.17
	 * 
	 * @see <a href=
	 *      "https://github.com/golang/go/blob/master/src/debug/gosym/pclntab.go">Golang
	 *      pclntab source code</a>
	 */
	private static final int GO_116 = 0xfffffffa;

	/**
	 * The magic value for Golang 1.2 through version 1.15
	 * 
	 * @see <a href=
	 *      "https://github.com/golang/go/blob/master/src/debug/gosym/pclntab.go">Golang
	 *      pclntab source code</a>
	 */
	private static final int GO_12 = 0xfffffffb;

	/**
	 * The default PC Quantum size (minimal instruction size), used in x86, x86_64,
	 * and WASM
	 * 
	 * @see <a href=
	 *      "https://github.com/golang/gofrontend/blob/master/libgo/goarch.sh">Golang
	 *      architecture documentation</a>
	 */
	private static final int INSTRUCTION_SIZE_ONE = 1;

	/**
	 * The PC Quantum size (minimal instruction size), used in RISCV, RISCV x64,
	 * S390, S390X, SH, and SHbe
	 * 
	 * @see <a href=
	 *      "https://github.com/golang/gofrontend/blob/master/libgo/goarch.sh">Golang
	 *      architecture documentation</a>
	 */
	private static final int INSTRUCTION_SIZE_TWO = 2;

	/**
	 * The PC Quantum size (minimal instruction size), used in ALPHA, ARM, ARMbe,
	 * M68K, MIPS, MIPSle, MIPS64p32, MIPS64p32le, MIPS64, MIPS64le, NIOS2, PPC,
	 * PPC64, PPC64le, SPARC, and SPARC64
	 * 
	 * @see <a href=
	 *      "https://github.com/golang/gofrontend/blob/master/libgo/goarch.sh">Golang
	 *      architecture documentation</a>
	 */
	private static final int INSTRUCTION_SIZE_FOUR = 4;

	/**
	 * The size of a pointer on X86
	 */
	private static final int POINTER_SIZE_X86 = 4;

	/**
	 * The size of a pointer on X64
	 */
	private static final int POINTER_SIZE_X64 = 8;

	/**
	 * The amount of functions which were recovered
	 */
	private static int functionCount = 0;

	@Override
	protected void run() throws Exception {
		// Get the executable format of the sample
		String executableFormat = currentProgram.getExecutableFormat();
		// Declare the pclntab variable
		Address pclntab;

		// Check if the executable format is a PE file
		if (executableFormat.equalsIgnoreCase("Portable Executable (PE)")) {
			// Optionally print a message to state the file type which has been detected
			log("PE file found");
			// The declaration and initialisation of potential pclntab magic values
			String[] pclntabMagicValues = { "\\xfb\\xff\\xff\\xff\\x00\\x00", "\\xfa\\xff\\xff\\xff\\x00\\x00",
					"\\xf0\\xff\\xff\\xff\\x00\\x00", "\\xf1\\xff\\xff\\xff\\x00\\x00" };
			// Get the gopclntab address by magic value
			pclntab = getGopclntabByMagicValue(pclntabMagicValues);
		} else if (executableFormat.equalsIgnoreCase("Executable and Linking Format (ELF)")) { // Check if the
																								// executable format is
																								// an ELF file
			// Optionally print a message to state the file type which has been detected
			log("ELF file found");
			// Get the gopclntab address by section name
			pclntab = getGopclntabBySectionName(".gopclntab");
		} else if (executableFormat.equalsIgnoreCase("Mac OS X Mach-O")) {
			// Optionally print a message to state the file type which has been detected
			log("Mach-O file found");
			// Get the gopclntab address by section name
			pclntab = getGopclntabBySectionName("__gopclntab");
		} else {
			/*
			 * Print an error message informing the user of the failure to find a suitable
			 * executable format
			 */
			printerr("Unspported file format: " + executableFormat);
			// Return, thus ending the script's execution
			return;
		}

		// If the pclntab could not be found, the script ends
		if (pclntab == null) {
			// Print an error message with the reason of the failure
			printerr("Cannot find the pclntab!");
			// End the script's execution
			return;
		}

		/*
		 * If execution continues, the pclntab was found. Optionally print a message to
		 * inform the user of the progress
		 */
		log(String.format("pclntab found at 0x%x!", pclntab.getOffset()));

		// Declare and initialise the pclntab magic value
		int magic = getInt(pclntab) & MAGIC_MASK;

		// Recover function names for functions in Golang version 1.20 and above
		if (magic == GO_120) {
			println("Golang 1.20 found, note that this script is experimental for this Golang version!");
			recoverFunctionNamesGo118Plus(pclntab);
		} else if (magic == GO_118) {
			// Recover function names for functions in Golang version 1.18 and above
			recoverFunctionNamesGo118Plus(pclntab);
		} else if (magic == GO_116) { // Determine if the magic value matches Golang version 1.16 and 1.17
			// Recover function names for functions in Golang versions 1.16 and 1.17
			renameFunc116(pclntab);
		} else if (magic == GO_12) {// Determine if the magic value matches Golang 1.15 through version 1.2
			/*
			 * Recover function names for functions in Golang version 1.15 through version
			 * 1.2
			 */
			recoverFunctionNamesGo12(pclntab);
		} else {
			// No matching magic value was found, of which the user is informed
			println("Unable to determine the .gopclntab magic value, so the assumption is made that it is Go 1.2 compatible");
			/*
			 * Recover function names for functions in Golang version 1.15 through version
			 * 1.2
			 */
			recoverFunctionNamesGo12(pclntab);
		}

		/*
		 * Inform the analyst of the total number of functions which has been renamed
		 * and/or created
		 */
		println("Total number of functions renamed and/or created: " + functionCount);
	}

	/**
	 * A wrapper function for the
	 * {@link ghidra.app.script.GhidraScript#println(String)} which is only called
	 * if the {@link #ENABLE_LOGGING} is <code>true</code>. The logging that is
	 * (potentially) passing through this function, is meant as optional logging.
	 * The final conclusion, as well as the logging of any error messages, should be
	 * printed via direct calls. The easy-to-omit nature of optional messages speeds
	 * up automated analysis by limiting the number of print calls.
	 * 
	 * @param message
	 */
	private void log(String message) {
		if (ENABLE_LOGGING) {
			println(message);
		}
	}

	/**
	 * Gets the gopclntab starting address based on a found magic value, if any
	 * 
	 * @param pclntabMagicValues possible magic values as byte strings written as
	 *                           strings (i.e. "\xab\xbc")
	 * @return the starting address of the gopclntab if it is found, null if it is
	 *         not found
	 * @throws MemoryAccessException
	 * @throws AddressOutOfBoundsException
	 */
	private Address getGopclntabByMagicValue(String[] pclntabMagicValues)
			throws MemoryAccessException, AddressOutOfBoundsException {
		// Iterate over all magic values
		for (String magic : pclntabMagicValues) {
			/*
			 * Look for the magic bytes within the current program, starting at the minimum
			 * address, with a maximum of 100 results
			 */
			Address[] pclntabs = findBytes(null, magic, 100);

			// Iterate over all results
			for (Address pclntab : pclntabs) {
				log("Potential pclntab found at : " + Long.toHexString(pclntab.getOffset()));
				/*
				 * Bytes have been found based on the given magic value
				 */

				// Get the instruction's size quantum
				byte instructionSizeQuantum = getByte(pclntab.add(6));
				// Get the pointer size
				byte pointerSize = getByte(pclntab.add(7));

				/*
				 * Verify if both the instruction's quantum size and pointer size match the
				 * conditions, meaning the pclntab has been found
				 */
				if ((instructionSizeQuantum != INSTRUCTION_SIZE_ONE && instructionSizeQuantum != INSTRUCTION_SIZE_TWO
						&& instructionSizeQuantum != INSTRUCTION_SIZE_FOUR) == false
						|| (pointerSize != POINTER_SIZE_X86 && pointerSize != POINTER_SIZE_X64) == false) {
					return pclntab;
				}
			}
		}
		// If no results match the criteria, null is returned
		return null;
	}

	/**
	 * Gets the gopclntab by its section name (being ".gopclntab")
	 * 
	 * @return the starting address of the ".gopclntab" section
	 */
	private Address getGopclntabBySectionName(String sectionName) {
		// Iterate over all memory blocks within the program
		for (MemoryBlock memoryBlock : getMemoryBlocks()) {
			// Check if the block's name equals (ignoring the casing) the gopclntab section
			if (memoryBlock.getName().equalsIgnoreCase(sectionName)) {
				// Return the starting address of this section if it is found
				return memoryBlock.getStart();
			}
		}
		// Return null if the section is not found
		return null;
	}

	/**
	 * Gets the length of the ascii string, from the given address until the first
	 * null byte (0x00).
	 * 
	 * @param start the address to start looking for the null byte (0x00)
	 * @return the number of characters, excluding the null byte (0x00)
	 * @throws MemoryAccessException
	 */
	private int getAsciiStringLength(Address start) throws MemoryAccessException {
		/*
		 * Declare and initialise the length variable, which is to be returned from this
		 * function
		 */
		int length = 0;

		/*
		 * Iterate until no address is available anymore, or until the while-loop is
		 * broken
		 */
		while (start != null) {
			// Get the byte at the given address
			byte b = getByte(start);
			// Check if the byte's value is null
			if (b == 0) {
				// Break the loop if it is
				break;
			}
			// If the byte isn't null, increment the length
			length++;
			// Additionally, increment the address by fetching the next
			start = start.add(1);
			// Jump to the top of the while-loop
		}

		// Return the length of the string, once the while-loop is broken
		return length;
	}

	/**
	 * Creates a new function, or renames the function if it already exists, based
	 * on the newly found name, which is obtained via the name address variable
	 * 
	 * @param functionAddress the address of the function
	 * @param nameAddress     the address of the function's new name
	 * @throws DuplicateNameException
	 * @throws InvalidInputException
	 */
	private void createOrRenameFunction(Address functionAddress, Address nameAddress)
			throws DuplicateNameException, InvalidInputException {
		// Check if the variable is instantiated
		if (nameAddress == null) {
			// Return from the function if this is the case
			return;
		}

		// Get the data at the given address
		Data functionNameData = getDataAt(nameAddress);
		// If no data resides at this address
		if (functionNameData == null) {
			try {
				int length = getAsciiStringLength(nameAddress);
				clearListing(nameAddress, nameAddress.add(length));
				// Create an ASCII string within Ghidra
				functionNameData = createAsciiString(nameAddress, length);
			} catch (Exception e) {
				// Print an error if the ASCII string creation fails
				printerr(String.format("Unable to create an ASCII string at 0x%x!", nameAddress.getOffset()));
				// Return from the function if this fails
				return;
			}
		}

		/*
		 * Get the function name by getting the data's value, which in this case is a
		 * String but needs to be cast as the getValue function returns an Object
		 */
		String functionName = (String) functionNameData.getValue();

		// If the function name is null, blank, or empty
		if (functionName == null || functionName.isBlank()) {
			// Print an error
			printerr(String.format("No function name found at 0x%s!", Long.toHexString(nameAddress.getOffset())));
			// Return from the function
			return;
		}

		// Gets the function at the given address
		Function func = getFunctionAt(functionAddress);

		// If there is a function at the given address
		if (func != null) {
			// Get the old name
			String functionNameOld = func.getName();
			// Get the new name, removing spaces
			String functionNameNew = functionName.replaceAll(" ", "").replaceAll("Â", "").replaceAll("·", "");

			/*
			 * Replacing the function with a name which already exists, throws a
			 * ghidra.util.exception.DuplicateNameException. This check avoids this
			 * exception by only replacing a function name if the old and new name are not
			 * the same.
			 */
			if (functionNameOld.equalsIgnoreCase(functionNameNew) == false) {
				// Change the function name
				try {
					func.setName(functionNameNew, SourceType.USER_DEFINED);
				} catch (DuplicateNameException ex) {
					func.setName(functionNameNew + "_", SourceType.USER_DEFINED);
				}
				// Optionally print the renamed function
				log("Function renamed from \"" + functionNameOld + "\" to \"" + functionNameNew + "\", located at 0x"
						+ Long.toHexString(functionAddress.getOffset()));
				// Increment the function count
				functionCount++;
			}
		} else {
			// If no function exists at the given address, create one
			func = createFunction(functionAddress, functionName);
			// Optionally print the function name and address
			log("Function \"" + functionName + "\" created at 0x" + Long.toHexString(functionAddress.getOffset()));
			// Increment the function count
			functionCount++;
		}
	}

	/**
	 * Recovers function names for functions in Golang version 1.15 through version
	 * 1.2
	 * 
	 * @param pclntab the start address of the pclntab
	 * @throws MemoryAccessException
	 * @throws AddressOutOfBoundsException
	 * @throws DuplicateNameException
	 * @throws InvalidInputException
	 */
	private void recoverFunctionNamesGo12(Address pclntab)
			throws MemoryAccessException, AddressOutOfBoundsException, DuplicateNameException, InvalidInputException {
		// Get the pointer size
		byte pointerSize = getByte(pclntab.add(7));
		// Declare the number of functions tab variable
		long nFunctionTab;

		// If the pointer size fits a x64 system
		if (pointerSize == POINTER_SIZE_X64) {
			// Get a long value from the given address
			nFunctionTab = getLong(pclntab.add(8));
		} else { // Assume x86, meaning 4 bytes in size
			// Get an integer value from the given address
			nFunctionTab = getInt(pclntab.add(8));
		}

		// Get the function tab address
		Address functionTab = pclntab.add(8 + pointerSize);

		// Declare a copy of the function tab, named p
		Address p = functionTab;
		// Declare the function address variable
		Address functionAddress;
		// Declare the name offset variable
		long nameOffset;

		// Iterate over the number of functions
		for (int i = 0; i < nFunctionTab; i++) {
			// Check if the script's execution is cancelled
			if (monitor.isCancelled()) {
				// Break this loop, thus exiting the script's execution early
				break;
			}

			// If the pointer size fits a x64 system
			if (pointerSize == POINTER_SIZE_X64) {
				// Get the function address
				functionAddress = currentProgram.getAddressFactory().getAddress(Long.toHexString(getLong(p)).trim());
				// Increment p with the pointer size to move it to the next usable address
				p = p.add(pointerSize);
				// Get the name offset as a long, since the architecture is x64
				nameOffset = getLong(p);
			} else { // Assume x86, meaning 4 bytes in size
				// Get the function address
				functionAddress = currentProgram.getAddressFactory().getAddress(Long.toHexString(getInt(p)));
				// Increment p with the pointer size to move it to the next usable address
				p = p.add(pointerSize);
				// Get the name offset as an integer, since the architecture is x86
				nameOffset = getInt(p);
			}

			// Increment p with the pointer size to move it to the next usable address
			p = p.add(pointerSize);

			/*
			 * Gets the name pointer, which is located directly after the function name,
			 * hence the addition of the name offset and the pointer size to move to the
			 * next usable address
			 */
			Address namePointer = pclntab.add(nameOffset + pointerSize);
			// Get the address of the name, based on the pointer, which is always 32 bits in
			// size
			Address nameAddress = pclntab.add(getInt(namePointer));
			// Address nameAddress = pclntab.add(namePointer.getOffset());

			/*
			 * Create or rename the function at the address, with the name at the given
			 * address
			 */
			createOrRenameFunction(functionAddress, nameAddress);
		}
	}

	/**
	 * Recovers function names for functions in Golang version 1.16 and version 1.17
	 * 
	 * @param pclntab the start address of the pclntab
	 * @throws MemoryAccessException
	 * @throws AddressOutOfBoundsException
	 * @throws DuplicateNameException
	 * @throws InvalidInputException
	 */
	private void renameFunc116(Address pclntab)
			throws MemoryAccessException, AddressOutOfBoundsException, DuplicateNameException, InvalidInputException {
		// Get the size of the pointer
		byte pointerSize = getByte(pclntab.add(7));

		// Declare variables, whose value will depend on the architecture
		long nFunctionTab;
		long offset;
		Address functionNameTab;

		// If the pointer's size is equal to the size of a pointer on a x64 system
		if (pointerSize == POINTER_SIZE_X64) {
			// Get the corresponding long value
			nFunctionTab = getLong(pclntab.add(8));
			// Calculate the next offset
			offset = getLong(pclntab.add(8 + 2 * pointerSize));
			// Get the function name tab's address
			functionNameTab = pclntab.add(offset);
			// Calculate the next offset
			offset = getLong(pclntab.add(8 + 6 * pointerSize));
		} else { // Assume x86, meaning 4 bytes in size
			// Get the corresponding integer value
			nFunctionTab = getInt(pclntab.add(8));
			// Calculate the next offset
			offset = getInt(pclntab.add(8 + 2 * pointerSize));
			// Get the function name tab's address
			functionNameTab = pclntab.add(offset);
			// Calculate the next offset
			offset = getInt(pclntab.add(8 + 6 * pointerSize));
		}

		// Get the address of the function tab
		Address functionTab = pclntab.add(offset);
		// Declare and initiate a copy of the function tab
		Address p = functionTab;

		// Declare several variables for later use
		Address functionAddress;
		long functionDataOffset;
		Address namePointer;
		Address nameAddress;

		// Iterate over the number of functions in the tab
		for (int i = 0; i < nFunctionTab; i++) {
			// Check if the script's execution is cancelled
			if (monitor.isCancelled()) {
				// Break this loop, thus exiting the script's execution early
				break;
			}

			// If the pointer size is one of a x64 system
			if (pointerSize == POINTER_SIZE_X64) {
				// Get the function's address
				functionAddress = currentProgram.getAddressFactory().getAddress(Long.toHexString(getLong(p)).trim());
				// Adjust the offset
				p = p.add(pointerSize);
				// Get the function data's offset
				functionDataOffset = getLong(p);
			} else { // Assume x86, meaning 4 bytes in size
				// Get the function's address
				functionAddress = currentProgram.getAddressFactory().getAddress(Long.toHexString(getInt(p)).trim());
				// Adjust the offset
				p = p.add(pointerSize);
				// Get the function data's offset
				functionDataOffset = getInt(p);
			}
			// Move p to the next address
			p = p.add(pointerSize);
			// Get the function name pointer
			namePointer = functionTab.add(functionDataOffset + pointerSize);
			// Get the address of the function name, which is always 32 bits in size
			nameAddress = functionNameTab.add(getInt(namePointer));

			/*
			 * Create or rename the function at the address, with the name at the given
			 * address
			 */
			createOrRenameFunction(functionAddress, nameAddress);
		}
	}

	/**
	 * Recovers function names for functions in Golang version 1.18 and above
	 * 
	 * @param pclntab the start address of the pclntab
	 * @throws MemoryAccessException
	 * @throws AddressOutOfBoundsException
	 * @throws DuplicateNameException
	 * @throws InvalidInputException
	 */
	private void recoverFunctionNamesGo118Plus(Address pclntab)
			throws MemoryAccessException, AddressOutOfBoundsException, DuplicateNameException, InvalidInputException {
		// Get the pointer size
		byte pointerSize = getByte(pclntab.add(7));

		// Declare several variables
		long nFunctionTab;
		long textStart;
		long offset;
		Address functionNameTab;

		// Check if the pointer size matches a x64 system's pointer size
		if (pointerSize == POINTER_SIZE_X64) {
			// Get the number of functions tab address
			nFunctionTab = getLong(pclntab.add(8));
			// Get the start of the text
			textStart = getLong(pclntab.add(8 + 2 * pointerSize));
			// Calculate the next offset
			offset = getLong(pclntab.add(8 + 3 * pointerSize));
			// Get the address of the function name tab
			functionNameTab = pclntab.add(offset);
			// Calculate the next offset
			offset = getLong(pclntab.add(8 + 7 * pointerSize));
		} else { // Assume x86, meaning 4 bytes in size
			// Get the number of functions tab address
			nFunctionTab = getInt(pclntab.add(8));
			// Get the start of the text
			textStart = getInt(pclntab.add(8 + 2 * pointerSize));
			// Calculate the next offset
			offset = getInt(pclntab.add(8 + 3 * pointerSize));
			// Get the address of the function name tab
			functionNameTab = pclntab.add(offset);
			// Calculate the next offset
			offset = getInt(pclntab.add(8 + 7 * pointerSize));
		}

		// Get the address of the function tab
		Address functionTab = pclntab.add(offset);

		// Instantiate a copy of the function tab for later use
		Address p = functionTab;

		// Define the field size within the function tab, which is always 4
		int functabFieldSize = 4;

		// Declare several variables for later use
		Address functionAddress;
		int functionDataOffset;
		Address namePointer;
		Address nameAddress;

		// Iterate over all functions
		for (int i = 0; i < nFunctionTab; i++) {
			// Check if the script's execution is cancelled
			if (monitor.isCancelled()) {
				// Break this loop, thus exiting the script's execution early
				break;
			}

			// Get the address for the current function, which is always 32 bits in size
			functionAddress = currentProgram.getAddressFactory()
					.getAddress(Long.toHexString(getInt(p) + textStart).trim());
			// Adjust p
			p = p.add(functabFieldSize);

			// Get the function data offset
			functionDataOffset = getInt(p);
			// Adjust p
			p = p.add(functabFieldSize);
			// Get the pointer to the name
			namePointer = functionTab.add(functionDataOffset + functabFieldSize);
			// Get the pointer to the address, which is always 32 bits
			nameAddress = functionNameTab.add(getInt(namePointer));

			/*
			 * Create or rename the function at the address, with the name at the given
			 * address
			 */
			createOrRenameFunction(functionAddress, nameAddress);
		}
	}
}

```

`GolangRecovery.java`:

```java
//Runs all four Golang analysis scripts, based on their names. If no such script is found, an error is printed and the next script is executed.
//@author Max 'Libra' Kersten of Trellix' Advanced Research Center
//@category Golang
//@keybinding
//@menupath
//@toolbar

import ghidra.app.script.GhidraScript;

public class GolangRecovery extends GhidraScript {

	@Override
	protected void run() throws Exception {
		runScript("GolangFunctionRecovery");
		runScript("GolangStaticStringRecovery");
		runScript("GolangDynamicStringRecovery");
		runScript("GolangTypeRecovery");
	}
}

```

`GolangStaticStringRecovery.java`:

```java
//Finds and creates statically allocated strings based on the Golang stringStruct 
//@author Max 'Libra' Kersten of Trellix' Advanced Research Center, based on the work by padorka@cujoai (https://github.com/getCUJO/ThreatIntel/blob/master/Scripts/Ghidra/find_static_strings.py)
//@category Golang
//@keybinding
//@menupath
//@toolbar

import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.IntegerDataType;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.listing.Data;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.mem.MemoryBlock;

public class GolangStaticStringRecovery extends GhidraScript {

	/**
	 * A boolean which defines if logging should be enabled. When prioritising
	 * speed, one might not be interested in getting all messages, but rather only
	 * the concluding message, along with potential error messages. As such, this
	 * boolean specifies if more logging should be enabled or disabled.</br>
	 * </br>
	 * The default value of this field is <code>true</code>.
	 */
	private static final boolean ENABLE_LOGGING = true;

	/**
	 * The size of a pointer on X64
	 */
	private static final int POINTER_SIZE_X64 = 8;

	/*
	 * #x86
	 * 
	 * #LEA REG, [STRING_ADDRESS]
	 * 
	 * #MOV [ESP + ..], REG
	 * 
	 * #MOV [ESP + ..], STRING_SIZE
	 */

	@Override
	protected void run() throws Exception {
		// Declare and initialise the number of recovered static strings
		int stringCount = 0;

		/*
		 * Store the imagebase's offset and the pointer size as they are reused multiple
		 * times
		 */
		long imageBaseOffset = currentProgram.getImageBase().getOffset();
		int pointerSize = currentProgram.getDefaultPointerSize();

		// Iterate over all memory blocks
		for (MemoryBlock block : getMemoryBlocks()) {
			/*
			 * If the block name is not .data or .rodata, it can be skipped, as static
			 * strings are only present in the data sections.
			 * 
			 * The __data and __rodata section names are used in Macho-O binaries.
			 */
			if (block.getName().equalsIgnoreCase(".data") == false
					&& block.getName().equalsIgnoreCase(".rodata") == false
					&& block.getName().equalsIgnoreCase("__data") == false
					&& block.getName().equalsIgnoreCase("__rodata") == false) {
				continue;
			}

			// Get the start of the block
			Address blockStart = block.getStart();
			// Get the end of the block
			Address blockEnd = block.getEnd();

			/*
			 * Run as long as the start is less than, or equal to the end address, thus
			 * ensuring the whole block is iterated over
			 */
			while (blockStart.compareTo(blockEnd) <= 0) {
				// Check if the script's execution is cancelled
				if (monitor.isCancelled()) {
					// Return from the run function, thus exiting the script's execution early
					return;
				}

				// Declare the string address variable
				Address stringAddress;

				// Declare and initialises the variable
				Address stringAddressPointer = blockStart;

				// Get the length address
				Address lengthAddress = blockStart.add(pointerSize);

				// Increment the start of the block
				blockStart = blockStart.add(pointerSize);

				/*
				 * The next segment of the code is within a try-catch structure. The reason for
				 * this is simple: the static string recovery strategy does not work in all
				 * cases. An exception is simply ignored, as the catch segment simply continues
				 * to the next step. Since the start of the block is compared to the end of the
				 * block, the whole section is iterated over, meaning that any error just moves
				 * over to the next piece of memory within the block.
				 */
				try {
					// Declare the length variable
					long length;

					// Check if the pointer size matches a x64 pointer's size
					if (pointerSize == POINTER_SIZE_X64) {
						// Get the long value at the given address
						length = getLong(lengthAddress);
					} else { // Assume the binary is x86
						// Get the integer value at the given address
						length = getInt(lengthAddress);
					}

					/*
					 * To avoid false positives, strings which have no length, or are longer than
					 * 100 characters, are considered incorrect and thus skipped
					 */
					if (length <= 0 || length > 100) {
						continue;
					}

					// Check if the pointer size matches a x64 pointer's size
					if (pointerSize == POINTER_SIZE_X64) {
						// Get the long at the given string address pointer
						stringAddress = currentProgram.getAddressFactory()
								.getAddress(Long.toHexString(getLong(stringAddressPointer)));
					} else {// Assume the binary is x86
						// Get the integer at the given string address pointer
						stringAddress = currentProgram.getAddressFactory()
								.getAddress(Long.toHexString(getInt(stringAddressPointer)));
					}

					/*
					 * If the address offset is less than the image base offset, the current attempt
					 * is faulty and needs to be skipped
					 */
					if (stringAddress.getOffset() < imageBaseOffset) {
						continue;
					}

					/*
					 * Check if the string is printable. If it is not, the current address needs to
					 * be skipped
					 */
					if (isPrintable(stringAddress, length) == false) {
						continue;
					}

					// Create a pointer to the string
					createData(stringAddressPointer, PointerDataType.dataType);

					// Get the length
					Data data = getDataAt(lengthAddress);

					/*
					 * If there is no data type defined at the given address, it needs to be created
					 */
					if (data == null) {
						data = createData(lengthAddress, IntegerDataType.dataType);
					}

					// Get the type of the data
					DataType dataType = data.getDataType();
					// Get the name of the data type
					String dataTypeName = dataType.getName();

					/*
					 * If the data type is an undefined type of 4 or 8 bytes in size, it is to be
					 * removed, as a new type is to be set
					 */
					if (dataTypeName.equalsIgnoreCase("undefined4") || dataTypeName.equalsIgnoreCase("undefined8")) {
						removeData(getDataAt(lengthAddress));
					}

					// Create an integer at the given address
					createData(lengthAddress, IntegerDataType.dataType);

					/*
					 * Create the ASCII string at the given address with the given length (cast to a
					 * boxed long to use the intValue function)
					 */
					Data stringData = createAsciiString(stringAddress, ((Long) length).intValue());

					// Get the string value as a string
					String string = (String) stringData.getValue();

					// Optionally pPrint the location and the string value for the user
					log("0x" + Long.toHexString(stringAddress.getOffset()) + " : \"" + string + "\"");

					// Increment the number of recovered strings
					stringCount++;
				} catch (Exception e) {
					/*
					 * Exceptions are bound to happen due to some of the what more crude approaches,
					 * but they can simply be skipped
					 */
					continue;
				}
			}
		}

		// Inform the analyst of the number of recovered strings
		println("Total number of recovered static strings: " + stringCount);
	}

	/**
	 * Checks if a string, starting at the given address with the given length, is
	 * printable. Printable in this context means that the value of each byte of the
	 * string is between 32 and 126
	 * 
	 * @param start  the address of the start of the string
	 * @param length the length of the string
	 * @return true if the complete string is printable, false if not
	 * @throws MemoryAccessException
	 */
	private boolean isPrintable(Address start, long length) throws MemoryAccessException {
		// Iterate over the complete string
		for (int i = 0; i < length; i++) {
			// Get the current byte
			byte b = getByte(start);
			// Check the byte's value
			if (b < 32 || b > 126) {
				// If any of the bytes has the wrong value, return false early
				return false;
			}
			// Increment the string's address by one
			start = start.add(1);
		}
		/*
		 * If the early return isn't hit and the complete string has been iterated over,
		 * it means the complete string is printable, thus true needs to be returned
		 */
		return true;
	}

	/**
	 * A wrapper function for the
	 * {@link ghidra.app.script.GhidraScript#println(String)} which is only called
	 * if the {@link #ENABLE_LOGGING} is <code>true</code>. The logging that is
	 * (potentially) passing through this function, is meant as optional logging.
	 * The final conclusion, as well as the logging of any error messages, should be
	 * printed via direct calls. The easy-to-omit nature of optional messages speeds
	 * up automated analysis by limiting the number of print calls.
	 * 
	 * @param message
	 */
	private void log(String message) {
		if (ENABLE_LOGGING) {
			println(message);
		}
	}
}
```

`GolangTypeRecovery.java`:

```java
//Recovers Golang types within the given binary
//@author Max 'Libra' Kersten of Trellix' Advanced Research Center, based on the work by padorka@cujoai (https://github.com/getCUJO/ThreatIntel/blob/master/Scripts/Ghidra/type_extract.py)
//@category Golang
//@keybinding
//@menupath
//@toolbar

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Data;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.program.model.symbol.Reference;

public class GolangTypeRecovery extends GhidraScript {

	/**
	 * A boolean which defines if logging should be enabled. When prioritising
	 * speed, one might not be interested in getting all messages, but rather only
	 * the concluding message, along with potential error messages. As such, this
	 * boolean specifies if more logging should be enabled or disabled.</br>
	 * </br>
	 * The default value of this field is <code>true</code>.
	 */
	private static final boolean ENABLE_LOGGING = true;

	/**
	 * The numeric value for the function kind, as defined in the Golang language
	 * specification
	 * 
	 * @see <a href="https://go.dev/src/reflect/type.go">The Golang source code for
	 *      the Type class, see the constant list under <code>type Kind uint</code>
	 *      for the complete list</a>
	 */
	private static final int KIND_FUNCTION = 0x13;

	/**
	 * The numeric value for the interface kind, as defined in the Golang language
	 * specification
	 * 
	 * @see <a href="https://go.dev/src/reflect/type.go">The Golang source code for
	 *      the Type class, see the constant list under <code>type Kind uint</code>
	 *      for the complete list</a>
	 */
	private static final int KIND_INTERFACE = 0x14;

	/**
	 * The numeric value for the pointer kind, as defined in the Golang language
	 * specification
	 * 
	 * @see <a href="https://go.dev/src/reflect/type.go">The Golang source code for
	 *      the Type class, see the constant list under <code>type Kind uint</code>
	 *      for the complete list</a>
	 */
	private static final int KIND_POINTER = 0x16;

	/**
	 * The numeric value for the struct kind, as defined in the Golang language
	 * specification
	 * 
	 * @see <a href="https://go.dev/src/reflect/type.go">The Golang source code for
	 *      the Type class, see the constant list under <code>type Kind uint</code>
	 *      for the complete list</a>
	 */
	private static final int KIND_STRUCT = 0x19;

	/**
	 * The default PC Quantum size (minimal instruction size), used in x86, x86_64,
	 * and WASM
	 * 
	 * @see <a href=
	 *      "https://github.com/golang/gofrontend/blob/master/libgo/goarch.sh">Golang
	 *      architecture documentation</a>
	 */
	private static final int INSTRUCTION_SIZE_ONE = 1;

	/**
	 * The PC Quantum size (minimal instruction size), used in RISCV, RISCV x64,
	 * S390, S390X, SH, and SHbe
	 * 
	 * @see <a href=
	 *      "https://github.com/golang/gofrontend/blob/master/libgo/goarch.sh">Golang
	 *      architecture documentation</a>
	 */
	private static final int INSTRUCTION_SIZE_TWO = 2;

	/**
	 * The PC Quantum size (minimal instruction size), used in ALPHA, ARM, ARMbe,
	 * M68K, MIPS, MIPSle, MIPS64p32, MIPS64p32le, MIPS64, MIPS64le, NIOS2, PPC,
	 * PPC64, PPC64le, SPARC, and SPARC64
	 * 
	 * @see <a href=
	 *      "https://github.com/golang/gofrontend/blob/master/libgo/goarch.sh">Golang
	 *      architecture documentation</a>
	 */
	private static final int INSTRUCTION_SIZE_FOUR = 4;

	/**
	 * The size of a pointer on X86
	 */
	private static final int POINTER_SIZE_X86 = 4;

	/**
	 * The size of a pointer on X64
	 */
	private static final int POINTER_SIZE_X64 = 8;

	/**
	 * The human readable version strings that are to be used to determine the
	 * version of a Golang binary. These will be converted to byte strings during
	 * the script's runtime, and then stored in the {@link #versions} variable. The
	 * sole purpose of this additional step is to more easily update this script
	 * when fixing bugs and/or adding support for later Golang versions.
	 */
	private static final String[] HUMAN_READABLE_VERSIONS = { "go1.20", "go1.19", "go1.18", "go1.17", "go1.16",
			"go1.15", "go1.14", "go1.13", "go1.12", "go1.11", "go1.10", "go1.9", "go1.8", "go1.7", "go1.6", "go1.5",
			"go1.4", "go1.3", "go1.2" };

	/**
	 * Byte strings of the versions in the {@link #HUMAN_READABLE_VERSIONS}
	 * variable. This variable is to be initialised during runtime.
	 */
	private String[] versions;

	/**
	 * The Golang version of the analysed binary, stored globally for later use to
	 * avoid looking for the version multiple times. This value is one of the
	 * {@link #versions}, which is more easily read in its human readable format as
	 * defined within the {@link #HUMAN_READABLE_VERSIONS}.
	 */
	private String currentVersion;

	/**
	 * The magic values for the pclntab, as found in the Golang source code. Note
	 * that version <code>1.2</code> is less than <code>1.16</code>, since the value
	 * after the dot is to be seen as an incrementing value number, not as the usual
	 * mathematical way of writing. The values in the array are for the following
	 * Golang versions, in order:
	 * 
	 * <ol>
	 * <li>Version 1.2</li>
	 * <li>Version 1.16</li>
	 * <li>Version 1.18</li>
	 * <li>Version 1.20</li>
	 * </ol>
	 * 
	 * @see <a href="https://go.dev/src/debug/gosym/pclntab.go">Golang pclntab
	 *      source code</a>
	 */
	private static String[] pclntab_magic = { "\\xfb\\xff\\xff\\xff\\x00\\x00", "\\xfa\\xff\\xff\\xff\\x00\\x00",
			"\\xf0\\xff\\xff\\xff\\x00\\x00", "\\xf1\\xff\\xff\\xff\\x00\\x00" };

	/**
	 * The size of a pointer, in bytes, within the currently loaded binary
	 */
	private int binaryPointerSize;

	/**
	 * A hash set of addresses with recovered types, used to avoid recovering the
	 * same type twice.<br>
	 * <br>
	 * The hash set is used, instead of an {@link java.util.ArrayList}, as its more
	 * efficient. Both the {@link java.util.HashSet#contains(Object)} and
	 * {@link java.util.HashSet#add(Object)} methods function in <code>O(1)</code>,
	 * in contrast to the inner workings of other types, which often work in
	 * <code>O(n)</code>.<br>
	 * <br>
	 * Testing locally shows that the time to complete the script, on a test sample
	 * which contains 3047 to-be recovered types, is nearly three times as much when
	 * using an {@link java.util.ArrayList}, compared to the
	 * {@link java.util.HashSet}. The specifics obviously depend on the used
	 * hardware, but it shows that the hash set implementation is more efficient.
	 */
	private static HashSet<Address> recoveredTypes = new HashSet<>();

	/**
	 * The script's main function. This script can be executed normally and
	 * headless.
	 */
	@Override
	protected void run() throws Exception {
		// Initialise the byte string versions, based on the human readable ones
		versions = createVersionByteStrings();

		// Declares and initialises the executable format of the current program
		String executableFormat = currentProgram.getExecutableFormat();

		/*
		 * Initialises the global variable to store the pointer size of the currently
		 * analysed binary in
		 */
		binaryPointerSize = currentProgram.getDefaultPointerSize();

		// Optionally print the executable format
		log("Executable format: " + executableFormat);

		/*
		 * Defines the address array which is to be initialised differently, depending
		 * on the file's type
		 */
		Address[] objects;

		// If the file is of the PE format
		if (executableFormat.equalsIgnoreCase("Portable Executable (PE)")) {
			// Initialise the objects array
			objects = scanPeFile();
		} else if (executableFormat.equalsIgnoreCase("Executable and Linking Format (ELF)")) { // If the file is of the
																								// ELF format
			// Initialise the objects array
			objects = scanElfFile();
		} else if (executableFormat.equalsIgnoreCase("Mac OS X Mach-O")) {
			objects = scanMachoFile();
		} else {
			// Inform the analyst of the error
			printerr("Incorrect file format: \"" + executableFormat + "\"");
			// Exit the script
			return;
		}

		/*
		 * If the objects array is null, an error occurred earlier on, of which the
		 * analyst is already informed via an earlier printerr statement. As such, this
		 * function simply needs to return early to end the script's execution.
		 */
		if (objects == null) {
			return;
		}

		// Find the Golang version within the given binary
		currentVersion = findVersion();

		// Check if a version was found
		if (currentVersion == null) {
			// Inform the analyst of the failure to find a version
			printerr("No Golang version could be found in the binary!");
			// Return early as the version is required later on
			return;
		}

		/*
		 * Regardless if the file is of the PE or ELF format, the returned addresses are
		 * the same. As such, the array can be used in the same way. To easier read the
		 * function call, read it as:
		 * 
		 * getAllTypes(typelinks, endOfTypelinks, type);
		 */
		recoverAllTypes(objects[0], objects[1], objects[2]);

		// Print the number of recovered types for the analyst
		println("Types recovered: " + recoveredTypes.size());
	}

	/**
	 * A wrapper function for the
	 * {@link ghidra.app.script.GhidraScript#println(String)} which is only called
	 * if the {@link #ENABLE_LOGGING} is <code>true</code>. The logging that is
	 * (potentially) passing through this function, is meant as optional logging.
	 * The final conclusion, as well as the logging of any error messages, should be
	 * printed via direct calls. The easy-to-omit nature of optional messages speeds
	 * up automated analysis by limiting the number of print calls.
	 * 
	 * @param message
	 */
	private void log(String message) {
		if (ENABLE_LOGGING) {
			println(message);
		}
	}

	/**
	 * Gets the value of the bytes as a little endian short
	 * 
	 * @param bytes the value to read
	 * @return the value of the bytes as a little endian short
	 */
	private short getShort(byte[] bytes) {
		// Allocate a buffer of two bytes
		ByteBuffer buffer = ByteBuffer.allocate(2);
		// Set the order
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		// Place the first byte
		buffer.put(bytes[0]);
		// Place the second byte
		buffer.put(bytes[1]);
		// Get the value as a short, in little endian format
		return buffer.getShort(0);
	}

	/**
	 * Ingests the human readable versions and converts them into byte strings. The
	 * byte strings can be used to searched for using
	 * {@link #findBytes(Address, String)} and overloads thereof.<br>
	 * <br>
	 * An example of a byte string is <code>\xfb\xff\xff\xff\x00\x00</code>.
	 * 
	 * @return the byte strings of the given versions
	 */
	private String[] createVersionByteStrings() {
		// Declare and initialise the output variable
		String[] byteStrings = new String[HUMAN_READABLE_VERSIONS.length];

		// Loop over all human readable strings
		for (int i = 0; i < HUMAN_READABLE_VERSIONS.length; i++) {
			/*
			 * Convert each human readable string into a byte string, and store it in the
			 * output variable
			 */
			byteStrings[i] = createByteString(HUMAN_READABLE_VERSIONS[i]);
		}

		// Return the newly created byte strings
		return byteStrings;
	}

	/**
	 * Returns a byte string of the given string, assuming the given input is UTF-8
	 * encoded
	 * 
	 * @param input the UTF-8 encoded string
	 * @return a byte string of the given input
	 */
	private String createByteString(String input) {
		// Get the bytes from the given input
		byte[] bytes = input.getBytes(Charset.forName("UTF-8"));
		// Declare the byte string and initialise it as an empty string
		String byteString = "";

		// Iterate over all bytes
		for (byte currentByte : bytes) {
			// Get the current byte in string form
			String byteStringByte = Integer.toHexString(currentByte);

			/*
			 * If the length of the current string is only a single character, prepend a
			 * zero to ensure two digits are present for the given byte in string form
			 */
			if (byteStringByte.length() == 1) {
				byteStringByte = "0" + byteStringByte;
			}

			/*
			 * Prepend "\x" to byte string's current byte, which is then added to the
			 * complete byte string
			 */
			byteString += "\\x" + byteStringByte;
		}
		// Return the complete byte string
		return byteString;
	}

	/**
	 * Gets the address at the given address, essentially dereferencing the given
	 * pointer
	 * 
	 * @param address the address to dereference
	 * @return the dereferenced address
	 * @throws MemoryAccessException if the given address cannot be dereferenced
	 */
	private Address getAddressAt(Address address) throws MemoryAccessException {
		return toAddr(Long.toHexString(getInt(address)));
	}

	/**
	 * Removes data at the given location, which is required to retype certain
	 * variables
	 * 
	 * @param address the address to remove the type from
	 * @param length  the length of the data to remove the typing from
	 * @throws Exception if the address is invalid or null
	 */
	private void removeData(Address address, int length) throws Exception {
		// Iterate for the given length
		for (int i = 0; i < length; i++) {
			/*
			 * Remove the data at the given address plus the offset of the length, starting
			 * at 0
			 */
			removeDataAt(address.add(i));
		}
		// Return if no exception is thrown
	}

	/**
	 * Gets the sections that match (case insensitive) the given section name
	 * 
	 * @param sectionName the section name to match, matching is case insensitive
	 * @return the starting addresses of all sections which match the given section
	 *         name
	 */
	private Address[] getSection(String sectionName) {
		// Iterate over all memory blocks
		for (MemoryBlock block : getMemoryBlocks()) {
			// If the block's name matches the given section name, case insensitive
			if (block.getName().equalsIgnoreCase(sectionName)) {
				// Get the start of the block
				Address start = block.getStart();
				// Get the end of the block
				Address end = block.getEnd();
				/*
				 * Optionally print a message for the analyst with the block's name, start
				 * address, and end address
				 */
				log(String.format("%s [start: 0x%x, end: 0x%x]", block.getName(), start.getOffset(), end.getOffset()));
				// Return the start and end addresses
				return new Address[] { start, end };
			}
		}
		// Print a message for the analyst indicating the section couldn't be found
		printerr("Section \"" + sectionName + "\" not found!");
		// Return null in the case of an error
		return null;
	}

	/**
	 * Returns the current version from any of the given versions, based on its
	 * presence in the binary. The first version that is found is used.
	 * 
	 * @return the byte string version that is found
	 */
	private String findVersion() {
		// Iterate over all versions in the global variable
		for (int i = 0; i < versions.length; i++) {
			// Declare a local variable for the currently iterated version
			String version = versions[i];

			// Find the address of the first occurrence of the current version
			Address[] addresses = findBytes(null, version, 1000);

			// Check if any results were found
			if (addresses == null || addresses.length == 0) {
				// If not, continue to the next attempt to find the version
				continue;
			}
			/*
			 * If the address is not null, inform the analyst with the human readable
			 * version, for all results
			 */
			for (Address address : addresses) {
				// Optionally print the Golang version
				log("Golang version found at 0x" + Long.toHexString(address.getOffset()) + " : "
						+ HUMAN_READABLE_VERSIONS[i]);
			}

			/*
			 * Return the current version based on the first match. This can be wrong, which
			 * is why all matches are printed to the analyst
			 */
			return version;
		}

		// Return null in the case of a failure to find the version
		return null;
	}

	/**
	 * Until and including Golang 1.16, the length offset was two bytes in size.
	 * From Golang 1.17 onwards, the length offset uses a variable length.<br>
	 * <br>
	 * For versions until and including 1.16, the second byte is used, which causes
	 * the script to potentially miss long strings.<br>
	 * <br>
	 * For versions 1.17 or later, the first byte is used, which causes the script
	 * to potentially miss long strings.
	 * 
	 * @return the length offset
	 */
	private int getLengthOffset() {
		/*
		 * Store the length of the current version byte string locally, which avoids
		 * calling the <code>length()<code> function several times
		 */
		int currentVersionLength = currentVersion.length();
		/*
		 * Get the first digit of the version (which is the one but last byte in the
		 * byte string), where the "1." part is omitted as its not required
		 */
		String firstDigit = currentVersion.substring(currentVersionLength - 6, currentVersionLength - 4);
		// Convert the value into a hexadecimal integer
		int integer = Integer.parseInt(firstDigit, 16);
		// Convert the value into a character
		char c = (char) integer;

		/*
		 * Declare and initialise the variable to store the version number in, in string
		 * format
		 */
		String versionNumberString = "" + c;

		/*
		 * Get the last digit of the version (which is the one but last byte in the byte
		 * string), where the "1." part is omitted as its not required
		 */
		String lastDigit = currentVersion.substring(currentVersionLength - 2, currentVersionLength);
		// Convert the value into a hexadecimal integer
		integer = Integer.parseInt(lastDigit, 16);
		// Convert the value into a character
		c = (char) integer;
		// Append the number
		versionNumberString = versionNumberString + c;

		// Convert the version number into an integer
		int versionNumber = Integer.parseInt(versionNumberString);

		// Compare the version to the versions of 1.17 or later
		if (versionNumber >= 17) {
			// Return one, as only one byte will be used
			return 1;
		}

		/*
		 * If none of the >= 1.17 versions matches, assume the version is lower than
		 * that, and thus the second byte is used
		 */
		return 2;
	}

	/**
	 * Looks for the pclntab within the binary, without looking for a section with
	 * the same name, but rather for a magic value within the binary
	 * 
	 * @param pclntab_magic the byte strings of pclntab magic strings to look for
	 * @return Returns an object array where the pclntab address is at index 0, and
	 *         the matching magic byte string is at index 1. The magic value can be
	 *         null!
	 * @throws MemoryAccessException if the pclntab memory cannot be accessed
	 */
	private Object[] findPclntabPE() throws MemoryAccessException {
		// Iterate over all plcntab magic byte strings
		for (String magic : pclntab_magic) {
			// Search through the program for the given byte string
			Address[] results = findBytes(null, magic, 1000);

			// Ensure the results are not null nor empty
			if (results == null || results.length == 0) {
				// If no matches are found, continue
				continue;
			}

			// Iterate over all results
			for (int i = 0; i < results.length; i++) {
				// Get the currently iterated address
				Address tempAddress = results[i];

				// If the returned value is not found
				if (tempAddress == null) {
					// Move to the next result in the address array
					continue;
				}
				// Check if the match is aligned with the pclntab structure
				if (isPclntab(tempAddress)) {
					// Optionally inform the analyst of the finding
					log("pclntab found!");
					// Return the pclntab's address and the respective magic value
					return new Object[] { tempAddress, magic };
				}
			}
		}
		// If nothing can be found, inform the analyst and then return null
		printerr("The pclntab could not be found!");
		return null;
	}

	/**
	 * Checks if the given address matches the pclntab structure pattern
	 * 
	 * @param address the address to check
	 * @return true if the structure matches, false if not
	 * @throws MemoryAccessException if the memory at the given address (and a few
	 *                               bytes more) cannot be accessed
	 */
	private boolean isPclntab(Address address) throws MemoryAccessException {
		// Get the PC Quantum Size value
		byte pcQuantum = getByte(address.add(6));
		// Get the pointer size from the binary
		byte pclntabPointerSize = getByte(address.add(7));
		// Verify the validity of the values
		if ((pcQuantum != INSTRUCTION_SIZE_ONE && pcQuantum != INSTRUCTION_SIZE_TWO
				&& pcQuantum != INSTRUCTION_SIZE_FOUR)
				|| (pclntabPointerSize != POINTER_SIZE_X86 && pclntabPointerSize != POINTER_SIZE_X64)) {
			// Return false if the conditions aren't met
			return false;
		}
		// Return true if the conditions are met
		return true;
	}

	/**
	 * Checks if the given address is the start of the module data
	 * 
	 * @param address the address to check
	 * @param magic   the magic value of the module data from the pclntab
	 * @return true if the given address is the address of the module data, false if
	 *         not
	 * @throws MemoryAccessException if the memory at the given address, and offsets
	 *                               thereof, aren't accessible for any reason
	 */
	private boolean isModuleData(Address address, String magic) throws MemoryAccessException {
		// Declare the offset
		int offset;

		/*
		 * Check if the magic value of Golang version 1.2 is in-use, as the offset
		 * differs in this case
		 */
		if (magic.equalsIgnoreCase("\\xfb\\xff\\xff\\xff\\x00\\x00")) { // Golang version 1.2 magic value
			offset = 12;
		} else {
			offset = 22;
		}

		// Get the text address based on the given address and the offset
		Address text = getAddressAt(address.add(offset * binaryPointerSize));

		// Get the memory block that corresponds with the .text section
		MemoryBlock textBlock = currentProgram.getMemory().getBlock(".text");

		/*
		 * Verify the module data by ensuring the offset from the module data matches
		 * the offset of the .text block
		 */
		if (text != null && textBlock != null && text.getOffset() == textBlock.getStart().getOffset()) {
			log("Module data found!");
			return true;
		}

		// Return false if the offset does not match, or if there is no .text section
		return false;
	}

	/**
	 * Finds the address of the module data, based on the given pclntab address and
	 * the pclntab magic value
	 * 
	 * @param pclntab the address of the pclntab
	 * @param magic   the magic value of the pclntab
	 * @return the address of the module data
	 * @throws MemoryAccessException if the pclntab, or offsets thereof, aren't
	 *                               accessible for any reason
	 */
	private Address findModuleData(Address pclntab, String magic) throws MemoryAccessException {
		// Declare the module data address
		Address moduleData;
		// Get all references to the pclntab
		Reference[] pclntabReferences = getReferencesTo(pclntab);

		// Iterate over all references
		for (Reference reference : pclntabReferences) {
			// Get the reference-making address
			moduleData = reference.getFromAddress();
			// Check if the address matches the module data structure
			if (isModuleData(moduleData, magic)) {
				// Optionally print the module data's address
				log("Module data address: " + moduleData.toString(false, true));
				// Return the address once a match is found
				return moduleData;
			}
		}

		/*
		 * If no such reference was found, a search through the whole program is to be
		 * started for the usage of the pclntab address, which is referenced in the
		 * module data. Searching only through specific sections is possible, but since
		 * this function is only called once in the beginning, and the improved accuracy
		 * outweighs the marginally extra time that is required
		 */

		/*
		 * Create a string of the inverted and hexadecimal representation of the pclntab
		 * address
		 */
		String invertedHexPclntab = Long.toHexString(Long.reverseBytes(pclntab.getOffset()));

		/*
		 * If the binary size is four, the string needs to be 8 characters long (four
		 * times two characters, meaning four time two bytes).
		 */
		if (binaryPointerSize == 4) {
			invertedHexPclntab = invertedHexPclntab.substring(0, 8);
		}
		/*
		 * If the pointer size is not four, its assumed to be eight, which is the
		 * default value of the long representation already, meaning no change has to be
		 * made
		 */
		String byteStringPclntab = "";

		// Iterate over all characters, in sets of two per iteration
		for (int i = 0; i < invertedHexPclntab.length(); i = i + 2) {
			// Create the byte in string form, which is appended to the byte string variable
			byteStringPclntab += "\\x" + invertedHexPclntab.charAt(i) + invertedHexPclntab.charAt(i + 1);
		}

		/*
		 * Get all results for the given byte string, starting at the program's
		 * beginning
		 */
		Address[] results = findBytes(null, byteStringPclntab, 1000);

		// If the results are null or empty, return early
		if (results != null && results.length > 0) {
			// Iterate over all results
			for (int i = 0; i < results.length; i++) {
				// Temporarily store the current result in the module data variable
				moduleData = results[i];

				// Check if the current address is the start of the module data structure
				if (isModuleData(moduleData, magic)) {
					// Return the value if that is the case
					return moduleData;
				}
			}
		}
		// Inform the analyst of the missing value
		printerr("The module data cannot be found!");
		// Return null if no match is found
		return null;
	}

	/**
	 * Gets the typeStart, typeEnd, typeLinks, and numberOfTypes variables based on
	 * the given module data address and the plcntab magic value.<br>
	 * <br>
	 * Returns an array of objects which contains the following types and values, in
	 * order:<br>
	 * <ol>
	 * <li>Address typeStart</li>
	 * <li>Address typeEnd</li>
	 * <li>Address typeLinks</li>
	 * <li>int numberOfTypes</li>
	 * </ol>
	 * 
	 * @param moduleData  the address of the module data
	 * @param magic       the plcntab magic value
	 * @param pointerSize the size of the pointer in bytes
	 * @return in order Address type, Address etype, Address typelinks, int ntypes
	 * @throws MemoryAccessException if the value at the module data address, or
	 *                               offsets thereof, cannot be accessed for any
	 *                               reason
	 */
	private Object[] getTypeLinks(Address moduleData, String magic) throws MemoryAccessException {
		// Declaration of the two offsets
		int offset;
		int offset2;

		// The offsets differ in Golang 1.2
		if (magic.equalsIgnoreCase("\\xfb\\xff\\xff\\xff\\x00\\x00")) { // Golang 1.2 magic value
			offset = 25;
			offset2 = 30;
		} else if (magic.equalsIgnoreCase("\\xfa\\xff\\xff\\xff\\x00\\x00")
				|| magic.equalsIgnoreCase("\\xf0\\xff\\xff\\xff\\x00\\x00")) { // Golang 1.16 and Golang 1.18
																				// respectively
			offset = 35;
			offset2 = 42;
		} else if (magic.equalsIgnoreCase("\\xf1\\xff\\xff\\xff\\x00\\x00")) { // Golang 1.20
			offset = 37;
			offset2 = 44;
		} else {
			printerr("No pclntab magic value matched, thus making the offsets unknown!");
			return null;
		}

		// Get the required values
		Address typeStart = getAddressAt(moduleData.add(offset * binaryPointerSize));
		Address typeEnd = getAddressAt(moduleData.add((offset + 1) * binaryPointerSize));
		Address typeLinks = getAddressAt(moduleData.add(offset2 * binaryPointerSize));
		int numberOfTypes = getInt(moduleData.add((offset2 + 1) * binaryPointerSize));

		// Return the values in an object array
		return new Object[] { typeStart, typeEnd, typeLinks, numberOfTypes };
	}

	/**
	 * Recover the types, based on the type's address and the type's location
	 * 
	 * @param typeAddress
	 * @param type
	 * @return
	 * @throws Exception
	 */
	private Address recoverTypes(Address typeAddress, Address type) throws Exception {
		try {
			// Check if the type is already recovered
			if (recoveredTypes.contains(typeAddress)) {
				// If the type is already recovered, optionally notify the analyst
				log(String.format("Type already recovered at  0x%x", typeAddress.getOffset()));
				// Return the type's address
				return typeAddress;
			}

			// Gets the length offset
			int lengthOffset = getLengthOffset();

			// Add the current type to the list of recovered types
			recoveredTypes.add(typeAddress);

			// Declare and initialise the temporary offset variable
			int tempOffset = 2 * binaryPointerSize + 4;
			// Declare and initialise the temporary address
			Address tempAddress = typeAddress.add(tempOffset);

			// Get the byte at the given address
			byte b = getByte(tempAddress);

			// Declare and initialise the uncommon flag
			byte tflagUncommon = (byte) (b & 0x01);

			// Get the byte for the extra star flag
			b = getByte(typeAddress.add(2 * binaryPointerSize + 4));

			// Declare and initialise the extra star far
			byte tflagExtraStar = (byte) (b & 0x02);

			// Get the byte for the kind
			b = getByte(typeAddress.add(2 * binaryPointerSize + 7));

			// Declare and initialise the kind
			byte kind = (byte) (b & 0x1F);

			// Get the type name offset
			int nameOffset = getInt(typeAddress.add(4 * binaryPointerSize + 8));

			// Get the type name length
			byte nameLength = getByte(type.add(nameOffset + lengthOffset));

			// Get the name's address
			Address nameAddress = type.add(nameOffset + lengthOffset + 1);

			// Remove the data type(s) from the given addresses
			removeData(nameAddress, nameLength);

			// Create an ASCII string at the given address with the given length
			Data name = createAsciiString(nameAddress, nameLength);

			// Declare the variable
			String nameType;

			// Get the type's name
			if (tflagExtraStar == 1) {
				nameType = ((String) name.getValue()).substring(1);
			} else {
				nameType = ((String) name.getValue());
			}

			// Optionally print the name of the type
			log("Recovered: \"" + nameType + "\"");

			// Create a label at the given address for the given name, excluding spaces
			createLabel(typeAddress, nameType.replace(" ", "_"), true);

			/*
			 * The function type (funcType) is structured as shown below. More information
			 * can be found here: https://go.dev/src/reflect/type.go
			 *
			 * struct {
			 * 
			 * funcType uncommonType
			 * 
			 * [2]*rtype // [0] is in, [1] is out
			 * 
			 * }
			 * 
			 * type funcType struct {
			 * 
			 * rtype
			 * 
			 * inCount uint16
			 * 
			 * outCount uint16 //the top bit is set if it is the last input parameter
			 * 
			 * }
			 */
			if (kind == KIND_FUNCTION) {
				byte[] bytes = getBytes(typeAddress.add(4 * binaryPointerSize + 8 + 8), 2);
				short inCount = getShort(bytes);

				byte[] outBytes = getBytes(typeAddress.add(4 * binaryPointerSize + 8 + 8 + 2), 2);
				// the top bit is set if it is the last input parameter
				int lastInput = outBytes[1] & 0x80;
				outBytes[1] = (byte) (outBytes[1] & 0x7F);
				int outCount = getShort(outBytes);

				List<String> inputs = new ArrayList<>();
				List<String> outputs = new ArrayList<>();

				for (int i = 0; i < inCount; i++) {
					Address input = getAddressAt(typeAddress.add(4 * binaryPointerSize + 8 + 8 + binaryPointerSize
							+ tflagUncommon * 16 + i * binaryPointerSize));
					recoverTypes(input, type);
					inputs.add(getSymbolAt(input).getName());
				}

				for (int i = 0; i < outCount; i++) {
					Address output = getAddressAt(typeAddress.add(4 * binaryPointerSize + 8 + 8 + binaryPointerSize
							+ tflagUncommon * 16 + inCount * binaryPointerSize + i * binaryPointerSize));
					recoverTypes(output, type);
					outputs.add(getSymbolAt(output).getName());
				}

				if (lastInput == 0x80 && inputs.size() > 0) {
					String comment = "func(";
					for (String string : inputs) {
						comment += string + ", ";
					}
					comment = comment.substring(0, comment.length() - 2);
					comment += ") (";

					for (String string : outputs) {
						comment += string + ", ";
					}
					comment = comment.substring(0, comment.length() - 2) + ")";
					setPreComment(typeAddress, comment);
				}
			}

			/*
			 * Interface type interfaceType represents an interface type.
			 * 
			 * type interfaceType struct {
			 * 
			 * rtype pkgPath name // import path methods
			 * 
			 * []imethod // sorted by hash
			 * 
			 * }
			 * 
			 * method represents a method on an interface type
			 * 
			 * type imethod struct {
			 * 
			 * name nameOff // name of method
			 * 
			 * typ typeOff // .(*FuncType) underneath
			 * 
			 * }
			 */
			if (kind == KIND_INTERFACE) {
				Address imethodField = getAddressAt(typeAddress.add(5 * binaryPointerSize + 8 + 8));
				List<String> methods = new ArrayList<>();
				int methodLength = getInt(typeAddress.add(6 * binaryPointerSize + 8 + 8));

				for (int i = 0; i < methodLength; i++) {
					int imethodNameOffset = getInt(imethodField);
					nameLength = getByte(type.add(imethodNameOffset + lengthOffset));
					nameAddress = type.add(imethodNameOffset + lengthOffset + 1);
					removeData(nameAddress, nameLength);
					name = createAsciiString(nameAddress, nameLength);
					String temp = (String) name.getValue();
					setEOLComment(imethodField, temp);
					createLabel(imethodField, temp.replace(" ", "_"), true);
					int newTypeOffset = getInt(imethodField.add(4));
					Address newType = type.add(newTypeOffset);
					recoverTypes(newType, type);
					imethodField = imethodField.add(8);
					methods.add(name.getValue() + " " + getSymbolAt(newType).getName());
					String comment = "type " + nameType + " interface{" + "\n\t" + "\n\t";
					for (int j = 0; j < methods.size(); j++) {
						comment += methods.get(j) + "\n\t";
					}
					comment += "\n" + "}";
					setPreComment(typeAddress, comment);
				}
			}

			/*
			 * Pointer type is used to represent a pointer type
			 * 
			 * type ptrType struct {
			 * 
			 * rtype
			 * 
			 * elem *rtype // pointer element (pointed at) type
			 * 
			 * 
			 * }
			 */
			if (kind == KIND_POINTER) {
				Address newAddress = toAddr(
						Integer.toHexString(getInt(typeAddress.add(4 * binaryPointerSize + 8 + 8))));
				recoverTypes(newAddress, type);
			}

			/*
			 * Struct type structType represents a struct type.
			 * 
			 * type structType struct {
			 * 
			 * rtype
			 * 
			 * pkgPath name
			 * 
			 * fields []structField // sorted by offset
			 * 
			 * }
			 * 
			 * Struct field
			 * 
			 * type structField struct {
			 * 
			 * name name // name is always non-empty
			 * 
			 * typ *rtype // type of field
			 * 
			 * offsetEmbed uintptr // byte offset of field<<1 | isEmbedded
			 * 
			 * }
			 */
			if (kind == KIND_STRUCT) {
				Address structField = getAddressAt(typeAddress.add(5 * binaryPointerSize + 8 + 8));
				List<String> fields = new ArrayList<>();
				int fieldLength = getInt(typeAddress.add(6 * binaryPointerSize + 8 + 8));
				for (int i = 0; i < fieldLength; i++) {
					Address structFieldName = getAddressAt(structField);
					Address nameLengthAddress = structFieldName.add(lengthOffset);
					nameLength = getByte(nameLengthAddress);
					nameAddress = getAddressAt(structField).add(lengthOffset + 1);
					removeData(nameAddress, nameLength);
					name = createAsciiString(nameAddress, nameLength);
					String temp = (String) name.getValue();
					setEOLComment(structField, temp);
					createLabel(structFieldName, temp.replace(" ", "_"), true);
					Address newType = getAddressAt(structField.add(binaryPointerSize));
					structField = structField.add(3 * binaryPointerSize);
					fields.add(name.getValue() + " " + getSymbolAt(newType).getName());

					String comment = "type " + nameType + " struct{" + "\n\t" + "\n\t";
					for (int j = 0; j < fields.size(); j++) {
						comment += fields.get(j) + "\n\t";
					}
					comment += "\n" + "}";

					setPreComment(typeAddress, comment);
				}
			}
		} catch (Exception ex) {
			// Ignore errors
		}
		return null;
	}

	/**
	 * Fetches the typeLinksStart, typeLinksEnd, and typeStart addresses from the
	 * binary if it is a PE file.<br>
	 * <br>
	 * Returns an array of Address objects which contains the following values, in
	 * order:<br>
	 * <ol>
	 * <li>typeLinksStart</li>
	 * <li>typeLinksEnd</li>
	 * <li>typeStart</li>
	 * </ol>
	 * 
	 * @param pclntab_magic the potential magic values for the pclntab
	 * @return the typeLinksStart, typeLinksEnd, and typeStart addresses
	 * @throws MemoryAccessException if memory within the binary, or offsets
	 *                               thereof, cannot be properly accessed
	 */
	private Address[] scanPeFile() throws MemoryAccessException {
		// Searches for the pclntab in a PE file
		Object[] pclntabArray = findPclntabPE();

		/*
		 * If the pclntab cannot be found, the analyst is informed in the called
		 * function. Simply return null in order for the script to return back to the
		 * main function, which will return early if null is encountered.
		 */
		if (pclntabArray == null) {
			return null;
		}

		// Saves the results in two variables
		Address pclntab = (Address) pclntabArray[0];
		String magic = (String) pclntabArray[1];

		// Searches for the module data
		Address moduleData = findModuleData(pclntab, magic);

		/**
		 * Similar to the missing pclntab, if the module data cannot be found, the
		 * analyst is informed in the called function, and null is to be handed to the
		 * caller which ensures execution ends early.
		 */
		if (moduleData == null) {
			return null;
		}

		// Save the results in four variables
		Object[] typeLinksArray = getTypeLinks(moduleData, magic);
		// If an error occurred earlier on, return early
		if (typeLinksArray == null) {
			return null;
		}
		Address typeStart = (Address) typeLinksArray[0];
		// Address typeEnd = (Address) typeLinksArray[1];
		Address typeLinksStart = (Address) typeLinksArray[2];
		int numberOfTypes = (int) typeLinksArray[3];

		// Calculate the end of the type links section
		Address typeLinksEnd = typeLinksStart.add(numberOfTypes * 4);

		// Return all addresses in an array
		return new Address[] { typeLinksStart, typeLinksEnd, typeStart };
	}

	/**
	 * Fetches the typeLinksStart, typeLinksEnd, and typeStart addresses from the
	 * binary if it is an ELF file.<br>
	 * <br>
	 * Returns an array of Address objects which contains the following values, in
	 * order:<br>
	 * <ol>
	 * <li>typeLinksStart</li>
	 * <li>typeLinksEnd</li>
	 * <li>typeStart</li>
	 * </ol>
	 * 
	 * @param pclntab_magic the potential magic values for the pclntab
	 * @return the typelinks start, the typelinks end (plus one byte), and type
	 *         start address
	 */
	private Address[] scanElfFile() {
		// Get the type link array
		Address[] typeLinkArray = getSection(".typelink");
		// Get the read-only data section
		Address typeStart = getSection(".rodata")[0];

		/*
		 * If either the type link or read-only sections cannot be found, the analyst is
		 * informed and null is returned by the respective function. To cut the
		 * execution short, this function simply returns null to its caller.
		 */
		if (typeLinkArray == null || typeStart == null) {
			return null;
		}

		// Store the start and end in two variables
		Address typelinksStart = typeLinkArray[0];
		Address typeLinksEnd = typeLinkArray[1];
		typeLinksEnd = typeLinksEnd.add(1);

		// Return the values in an array
		return new Address[] { typelinksStart, typeLinksEnd, typeStart };
	}

	/**
	 * Fetches the typeLinksStart, typeLinksEnd, and typeStart addresses from the
	 * binary if it is a MACH-O file.<br>
	 * <br>
	 * Returns an array of Address objects which contains the following values, in
	 * order:<br>
	 * <ol>
	 * <li>typeLinksStart</li>
	 * <li>typeLinksEnd</li>
	 * <li>typeStart</li>
	 * </ol>
	 * 
	 * @param pclntab_magic the potential magic values for the pclntab
	 * @return the typelinks start, the typelinks end (plus one byte), and type
	 *         start address
	 */
	private Address[] scanMachoFile() {
		// Get the type link array
		Address[] typeLinkArray = getSection("__typelink");
		// Get the read-only data section
		Address typeStart = getSection("__rodata")[0];

		/*
		 * If either the type link or read-only sections cannot be found, the analyst is
		 * informed and null is returned by the respective function. To cut the
		 * execution short, this function simply returns null to its caller.
		 */
		if (typeLinkArray == null || typeStart == null) {
			return null;
		}

		// Store the start and end in two variables
		Address typelinksStart = typeLinkArray[0];
		Address typeLinksEnd = typeLinkArray[1];
		typeLinksEnd = typeLinksEnd.add(1);

		// Return the values in an array
		return new Address[] { typelinksStart, typeLinksEnd, typeStart };
	}

	/**
	 * Recovers all types present within the program
	 * 
	 * @param typeLinksStart the start of the typelinks
	 * @param typeLinksEnd   the end of the typelinks plus one byte
	 * @param type           the start of the types
	 * @throws Exception if something goes wrong
	 */
	private void recoverAllTypes(Address typeLinksStart, Address typeLinksEnd, Address type) {
		// Ensure the type link is not null
		if (typeLinksStart != null) {
			// Declare and initialise a copy of the start address
			Address p = typeLinksStart;
			// Iterate until the end of the type links section is reached
			while (p.compareTo(typeLinksEnd) <= 0) {
				// Check if the script's execution is cancelled
				if (monitor.isCancelled()) {
					// Break this loop, thus exiting the script's execution early
					break;
				}

				try {
					// Get the type offset by dereferencing the address pointer
					int typeOffset = getInt(p);
					// Get the type address based on the offset
					Address typeAddress = type.add(typeOffset);
					// Recover the types for the given address
					recoverTypes(typeAddress, type);
				} catch (Exception ex) {
					// Ignore exceptions
				}
				// Increment the address, which is always 32 bits
				p = p.add(4);
			}
		}
	}
}

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2023 Musarubra US LLC

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`MalpediaFlossedCheckLocal.java`:

```java
//A script to load the Malpedia FLOSSED JSON dataset, and compare it with the strings from the current program. Strings which aren't part of the Malpedia dataset are then printed out, as these are more likely to be unique to warrant interest.
//@author Max 'Libra' Kersten for Trellix
//@category
//@keybinding
//@menupath
//@toolbar

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import ghidra.app.script.GhidraScript;
import ghidra.program.model.data.StringDataInstance;
import ghidra.program.model.listing.Data;
import ghidra.program.util.DefinedDataIterator;

public class MalpediaFlossedCheckLocal extends GhidraScript {

	/**
	 * The strings present within the current program
	 */
	private static List<String> STRINGS_FROM_CURRENT_PROGRAM;

	/**
	 * 
	 */
	private List<String> missingStrings;

	/**
	 * Defines if the case of the strings should be taken into account
	 */
	private boolean isCaseSensitive;

	/**
	 * The minimum length of a string, for it to be considered useful
	 */
	private static final int MINIMUM_STRING_LENGTH = 4;

	@Override
	protected void run() throws Exception {
		// Determine if case sensitivity is desired
		isCaseSensitive = askYesNo("Match strings case sensitive?",
				"Do you want the strings to be matched case sensitive?");

		// Obtain the JSON file's location
		File jsonFile = askFile("Select the extracted Malpedia FLOSS data set", "Select");

		// Initialise the missed strings list
		missingStrings = new ArrayList<>();

		// Get all strings from the currently open program
		STRINGS_FROM_CURRENT_PROGRAM = getStringsFromCurrentProgram(MINIMUM_STRING_LENGTH);

		// Parse the JSON file into a Java object
		MalpediaFlossed flossed = parse(jsonFile);

		// Print the about data from the JSON file
		printAbout(flossed.getAbout());

		// Get the mapping from the object
		Map<String, MalpediaFlossedString> flossedObject = flossed.getStringMapping();

		/*
		 * Create the message about the non-occurring strings, depending on the case
		 * sensitivity
		 */
		String message = "Strings not occurring in the Malpedia string set (this check is case ";
		if (isCaseSensitive == false) {
			message += "in";
		}
		message += "sensitive):";
		// Print said message
		println(message);

		/*
		 * Get a list of strings from the flossed object, since the keys are the
		 * strings. To easily iterate over the strings and to be able to fetch results,
		 * an ArrayList is used, rather than the set.
		 */
		List<String> stringKeys = new ArrayList<>(flossedObject.keySet());

		// Iterate over all strings within the current program
		for (int i = 0; i < STRINGS_FROM_CURRENT_PROGRAM.size(); i++) {
			// Get the current string
			String currentString = STRINGS_FROM_CURRENT_PROGRAM.get(i);
			// If the list of flossed strings does not contain the current string
			if (stringKeys.contains(currentString) == false) {
				// It is added to the list of missing strings
				missingStrings.add(currentString);
				// Printed for the analyst to see
				println("\t" + currentString);
			}
		}

		// If no missing strings were found, print a message related to that
		if (missingStrings.isEmpty()) {
			println("All strings of this binary occur within the Malpedia string set!");
		}

		/*
		 * If you want to print the matches for every file, and the top matches in
		 * descending order, use the commented code below.
		 */
//		Map<String, Integer> familyCountMapping = new HashMap<>();
//		for (Map.Entry<String, MalpediaFlossedString> entry : flossedObject.entrySet()) {
//			String key = entry.getKey();
//			MalpediaFlossedString value = entry.getValue();
//
//			println("Match found for \"" + key + "\"");
//			String message = "\tRelates to:\n";
//			List<String> familiesFromIds = getFamiliesByIds(flossed.getFamilyIdMapping(), value.getFamilies());
//			for (String family : familiesFromIds) {
//				message += "\t\t" + family + "\n";
//
//				if (familyCountMapping.containsKey(family)) {
//					Integer count = familyCountMapping.get(family);
//					count++;
//					familyCountMapping.put(family, count);
//				} else {
//					familyCountMapping.put(family, 1);
//				}
//			}
//			if (familiesFromIds.size() < 10) {
//				println(message);
//			}
//
//		}
//
//		Map<String, Integer> valuesDescending = familyCountMapping.entrySet().stream()
//				.sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())).collect(Collectors.toMap(
//						Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -> oldValue, LinkedHashMap::new));
//
//		for (Map.Entry<String, Integer> entry : valuesDescending.entrySet()) {
//			println(entry.getKey() + " : " + entry.getValue());
//		}
//
//		println(valuesDescending.toString());
	}

	/**
	 * This is a helper function to get all families for a given ID, as a lookup for
	 * later use.
	 * 
	 * @param familyIdMapping The family-ID mapping
	 * @param ids             a list of IDs
	 * @return all matching families to all IDs
	 */
	private List<String> getFamiliesByIds(Map<Integer, String> familyIdMapping, List<Integer> ids) {
		Set<String> families = new HashSet<>();

		for (Integer id : ids) {
			if (familyIdMapping.containsKey(id)) {
				String family = familyIdMapping.get(id);
				families.add(family);
			}
		}

		List<String> output = new ArrayList<>(families);
		output.sort(String::compareToIgnoreCase);
		return output;
	}

	/**
	 * Prints the about message of the Malpedia data set
	 * 
	 * @param about the data set in Java object form
	 */
	private void printAbout(MalpediaFlossedAbout about) {
		println("About the Malpedia Flossed JSON data set:");
		println("\tAuthor:               " + about.getAuthor());
		println("\tDated flossed:        " + about.getDateFlossed());
		println("\tDate published:       " + about.getDatePublished());
		println("\tFLOSS version:        " + about.getFlossVersion());
		println("\tProcessed strings:    " + about.getNumberOfProcessedStrings());
		println("\tReference:            " + about.getReference());
		println("\tSource:               " + about.getSource());
		println();
	}

	/**
	 * Get all defined strings from the current program. Only strings equal to, or
	 * longer than, the given minimum size are returned
	 * 
	 * @param minimumLength the minimum length of the string to be included in the
	 *                      matches
	 * @return all strings that are at least as long as the minimum length
	 */
	private List<String> getStringsFromCurrentProgram(int minimumLength) {
		// Create a set to store all strings in
		Set<String> strings = new HashSet<>();

		// Get a data iterator
		DefinedDataIterator ddi = DefinedDataIterator.definedStrings(currentProgram);
		// Iterate over the data iterator
		for (Data d : ddi) {
			// Get an instance of the currently selected data
			StringDataInstance sdi = StringDataInstance.getStringDataInstance(d);
			// Get the string value of said string
			String s = sdi.getStringValue();

			// If the string is not null nor empty
			if (s != null && s.isEmpty() == false) {
				/*
				 * If the length of the string is equal to, or larger than the predefined
				 * minimum length
				 */
				if (s.length() >= minimumLength) {
					/*
					 * If there is no casing check, convert the string to lower case, for easier
					 * checking later on
					 */
					if (isCaseSensitive == false) {
						s = s.toLowerCase();
					}
					// Add the string to the set
					strings.add(s);
				}
			}
		}

		/*
		 * Sets do not contain duplicate items by their nature, but cannot always be
		 * accessed in the same way as a list can (i.e. when sorting, given the
		 * hashset's nature).
		 * 
		 * The unique strings from the list, are stored in a newly created array list,
		 * which maintains the order. Next, they are sorted alphabetically, ignoring the
		 * casing during sorting to avoid an order where A-Za-z would occur, but rather
		 * any casing of A through Z.
		 */
		List<String> output = new ArrayList<>(strings);
		output.sort(String::compareToIgnoreCase);
		return output;
	}

	/**
	 * A parsing function, which contains a custom GSON parser to properly parse the
	 * Malpedia JSON set
	 * 
	 * @param jsonFile the Malpedia JSON file, as a Java File object
	 * @return the custom Java object with all results
	 * @throws IOException
	 */
	private MalpediaFlossed parse(File jsonFile) throws IOException {
		/*
		 * Create a custom JSON deserializer
		 */
		JsonDeserializer<MalpediaFlossed> deserializer = new JsonDeserializer<MalpediaFlossed>() {
			@Override
			public MalpediaFlossed deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
					throws JsonParseException {
				JsonObject jsonObject = json.getAsJsonObject();

				Map<Integer, String> familyToIdMapping = new HashMap<>();
				JsonObject familyToIdJson = jsonObject.get("family_to_id").getAsJsonObject();
				Set<String> familyKeySet = familyToIdJson.keySet();
				for (String family : familyKeySet) {
					Integer value = familyToIdJson.get(family).getAsInt();
					familyToIdMapping.put(value, family);
				}

				JsonObject aboutJson = jsonObject.get("about").getAsJsonObject();
				String author = aboutJson.get("author").getAsString();
				String date_flossed = aboutJson.get("date_flossed").getAsString();
				String date_published = aboutJson.get("date_published").getAsString();
				String floss_version = aboutJson.get("floss_version").getAsString();
				String info = aboutJson.get("info").getAsString();
				String license = aboutJson.get("license").getAsString();
				int num_families = aboutJson.get("num_families").getAsInt();
				int num_processed_strings = aboutJson.get("num_processed_strings").getAsInt();
				int num_samples_flossed = aboutJson.get("num_samples_flossed").getAsInt();
				int num_total_strings = aboutJson.get("num_total_strings").getAsInt();
				String reference = aboutJson.get("reference").getAsString();
				String source = aboutJson.get("source").getAsString();

				MalpediaFlossedAbout about = new MalpediaFlossedAbout(author, date_flossed, date_published,
						floss_version, info, license, num_families, num_processed_strings, num_samples_flossed,
						num_total_strings, reference, source);

				Map<String, MalpediaFlossedString> stringMap = new HashMap<>();

				JsonObject stringsJson = jsonObject.get("strings").getAsJsonObject();
				Set<String> stringKeySet = stringsJson.keySet();

				// Iterate over all strings in the JSON file
				for (String string : stringKeySet) {
					// If a string does not match the minimum length, its omitted
					if (string.length() < MINIMUM_STRING_LENGTH) {
						continue;
					}

					// Declare a variable to store a copy of the string in
					String stringCopy;
					// Check if the copy of the string should be made lower case
					if (isCaseSensitive == false) {
						stringCopy = string.toLowerCase();
					} else {
						stringCopy = string;
					}

					/*
					 * If the current program's strings does not not contain this string, it is
					 * skipped. The non-matching strings aren't required, and parsing them will
					 * result in a long runtime of the script without any advantages. It also
					 * creates an out of heap space error within Ghidra, depending on how much
					 * memory one allocated to the JVM during startup.
					 */
					if (STRINGS_FROM_CURRENT_PROGRAM.contains(stringCopy) == false) {
						continue;
					}

					JsonObject stringJsonObject = stringsJson.get("string").getAsJsonObject();

					List<String> encodings = new ArrayList<>();
					JsonArray encodingsJson = stringJsonObject.get("encodings").getAsJsonArray();
					for (int i = 0; i < encodingsJson.size(); i++) {
						String encoding = encodingsJson.get(i).getAsString();
						encodings.add(encoding);
					}

					List<String> tags = new ArrayList<>();
					JsonArray tagsJson = stringJsonObject.get("tags").getAsJsonArray();
					for (int i = 0; i < tagsJson.size(); i++) {
						String tag = tagsJson.get(i).getAsString();
						tags.add(tag);
					}

					List<Integer> families = new ArrayList<>();

					JsonArray familiesJson = stringJsonObject.get("families").getAsJsonArray();
					for (int i = 0; i < familiesJson.size(); i++) {
						Integer family = familiesJson.get(i).getAsInt();
						families.add(family);
					}

					Integer familyCount = stringJsonObject.get("family_count").getAsInt();

					List<String> methods = new ArrayList<>();

					JsonArray methodsJson = stringJsonObject.get("methods").getAsJsonArray();
					for (int i = 0; i < methodsJson.size(); i++) {
						String method = methodsJson.get(i).getAsString();
						methods.add(method);
					}

					MalpediaFlossedString stringEntry = new MalpediaFlossedString(encodings, families, familyCount,
							methods, tags);
					stringMap.put(string, stringEntry);
				}

				return new MalpediaFlossed(about, familyToIdMapping, stringMap);
			}
		};

		// Read the file and store the result in a string
		String json = Files.readString(jsonFile.toPath());

		// Initialise the GSON builder
		GsonBuilder gsonBuilder = new GsonBuilder();

		// Register the custom deserializer
		gsonBuilder.registerTypeAdapter(MalpediaFlossed.class, deserializer);

		// Create a Gson instance, with the custom adapter type
		Gson customGson = gsonBuilder.create();

		// Parse the JSON into a Java object
		return customGson.fromJson(json, MalpediaFlossed.class);
	}

	private class MalpediaFlossed {
		private MalpediaFlossedAbout about;
		private Map<Integer, String> familyIdMapping;
		private Map<String, MalpediaFlossedString> stringMapping;

		public MalpediaFlossed(MalpediaFlossedAbout about, Map<Integer, String> familyIdMapping,
				Map<String, MalpediaFlossedString> stringMapping) {
			super();
			this.about = about;
			this.familyIdMapping = familyIdMapping;
			this.stringMapping = stringMapping;
		}

		public MalpediaFlossedAbout getAbout() {
			return about;
		}

		public Map<Integer, String> getFamilyIdMapping() {
			return familyIdMapping;
		}

		public Map<String, MalpediaFlossedString> getStringMapping() {
			return stringMapping;
		}
	}

	private class MalpediaFlossedString {
		private String string;
		private List<String> encodings;
		private List<Integer> families;
		private Integer familyCount;
		private List<String> methods;
		private List<String> tags;

		public MalpediaFlossedString() {

		}

		public MalpediaFlossedString(List<String> encodings, List<Integer> families, Integer familyCount,
				List<String> methods, List<String> tags) {
			super();
			this.encodings = encodings;
			this.families = families;
			this.familyCount = familyCount;
			this.methods = methods;
			this.tags = tags;
		}

		public List<String> getEncodings() {
			return encodings;
		}

		public List<Integer> getFamilies() {
			return families;
		}

		public Integer getFamilyCount() {
			return familyCount;
		}

		public List<String> getMethods() {
			return methods;
		}

		public List<String> getTags() {
			return tags;
		}
	}

	private class MalpediaFlossedAbout {
		private String author;
		private String dateFlossed;
		private String datePublished;
		private String flossVersion;
		private String info;
		private String license;
		private int numberOfFamilies;
		private int numberOfProcessedStrings;
		private int numberOfSamplesFlossed;
		private int numberOfTotalStrings;
		private String reference;
		private String source;

		public MalpediaFlossedAbout(String author, String dateFlossed, String datePublished, String flossVersion,
				String info, String license, int numberOfFamilies, int numberOfProcessedStrings,
				int numberOfSamplesFlossed, int numberOfTotalStrings, String reference, String source) {
			super();
			this.author = author;
			this.dateFlossed = dateFlossed;
			this.datePublished = datePublished;
			this.flossVersion = flossVersion;
			this.info = info;
			this.license = license;
			this.numberOfFamilies = numberOfFamilies;
			this.numberOfProcessedStrings = numberOfProcessedStrings;
			this.numberOfSamplesFlossed = numberOfSamplesFlossed;
			this.numberOfTotalStrings = numberOfTotalStrings;
			this.reference = reference;
			this.source = source;
		}

		public String getAuthor() {
			return author;
		}

		public String getDateFlossed() {
			return dateFlossed;
		}

		public String getDatePublished() {
			return datePublished;
		}

		public String getFlossVersion() {
			return flossVersion;
		}

		public String getInfo() {
			return info;
		}

		public String getLicense() {
			return license;
		}

		public int getNumberOfFamilies() {
			return numberOfFamilies;
		}

		public int getNumberOfProcessedStrings() {
			return numberOfProcessedStrings;
		}

		public int getNumberOfSamplesFlossed() {
			return numberOfSamplesFlossed;
		}

		public int getNumberOfTotalStrings() {
			return numberOfTotalStrings;
		}

		public String getReference() {
			return reference;
		}

		public String getSource() {
			return source;
		}
	}
}

```

`MalpediaFlossedCheckWebApi.java`:

```java
//A script to query the Malpedia FLOSSED JSON dataset via the web API (hosted by Malpedia, or a local instance) and compare it with the strings from the current program. Strings which aren't part of the Malpedia dataset are then printed out, as these are more likely to be unique to warrant interest.
//@author Max 'Libra' Kersten for Trellix
//@category 
//@keybinding
//@menupath
//@toolbar

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.lang.reflect.Type;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import ghidra.app.script.GhidraScript;
import ghidra.program.model.data.StringDataInstance;
import ghidra.program.model.listing.Data;
import ghidra.program.util.DefinedDataIterator;

public class MalpediaFlossedCheckWebApi extends GhidraScript {

	/**
	 * The URL to the API. Change this if you are self hosting an instance of this
	 * service, otherwise the public Malpedia instance will be used.
	 */
	private static final String WEB_API_URL = "https://strings.malpedia.io/api/query/";

	/**
	 * The minimum length of a string, for it to be considered useful
	 */
	private int MINIMUM_STRING_LENGTH;

	@Override
	protected void run() throws Exception {
		// Get the minimum string length from the user or the CLI in headless mode
		MINIMUM_STRING_LENGTH = askInt("Minimum string length",
				"What is the minimum length of a given string to be submitted to the web service? Any value lower than four will result in the value of four.");

		// Correct the minimum string length if need be
		if (MINIMUM_STRING_LENGTH < 4) {
			println("The entered minimum string length of " + MINIMUM_STRING_LENGTH
					+ " is lower than four, and has thus been adjust to four");
			MINIMUM_STRING_LENGTH = 4;
		}

		// Get all strings from the currently open program
		List<String> stringsFromCurrentProgram = getStringsFromCurrentProgram(MINIMUM_STRING_LENGTH);

		// Parse the JSON file into a Java object
		Map<String, MalpediaFlossedString> flossed = requestAndParse(stringsFromCurrentProgram);

		// Create and print the message about the non-occurring strings
		println("Strings not occurring in the Malpedia string set (this check is case sensitive):");

		/*
		 * Get a list of strings from the flossed object, since the keys are the
		 * strings. To easily iterate over the strings and to be able to fetch results,
		 * an ArrayList is used, rather than the set.
		 */
		List<String> stringKeys = new ArrayList<>(flossed.keySet());

		/*
		 * If no matches are found, an additional message is to be printed for the
		 * analyst. This boolean defines if said message will be printed.
		 */
		boolean noMatches = true;

		// Iterate over all strings within the current program
		for (int i = 0; i < stringsFromCurrentProgram.size(); i++) {
			// Get the current string
			String currentString = stringsFromCurrentProgram.get(i);
			// If the list of flossed strings does not contain the current string
			if (stringKeys.contains(currentString) == false) {
				/*
				 * If no matches are found, set the boolean, which is used to inform the analyst
				 * later on
				 */
				noMatches = false;
				// Printed for the analyst to see
				println(currentString);
			}
		}

		// If no missing strings were found, print a message related to that
		if (noMatches) {
			println("All strings of this binary occur within the Malpedia string set!");
		}
	}

	/**
	 * Send the HTTP POST request to the web service
	 * 
	 * @param body the body of comma separated strings to check
	 * @return the JSON response from the server
	 * @throws IOException
	 */
	private String postRequest(String body) throws IOException {
		URL url = new URL(WEB_API_URL);
		HttpURLConnection connection = (HttpURLConnection) url.openConnection();
		connection.setRequestMethod("POST");
		connection.setRequestProperty("Content-Type", "application/json");
		connection.setRequestProperty("Accept", "application/json");
		connection.setDoOutput(true);

		try (OutputStream outputStream = connection.getOutputStream()) {
			byte[] rawBody = body.getBytes("utf-8");
			outputStream.write(rawBody, 0, rawBody.length);
		}

		try (BufferedReader bufferedReader = new BufferedReader(
				new InputStreamReader(connection.getInputStream(), "utf-8"))) {
			StringBuilder response = new StringBuilder();
			String line = null;
			while ((line = bufferedReader.readLine()) != null) {
				response.append(line.trim());
			}
			return response.toString();
		}
	}

	/**
	 * Creates a comma separated string of the given list
	 * 
	 * @param input the list to convert
	 * @return the converted list, in string format, where each string is
	 *         encapsulated between quotes
	 */
	private String csvFormatList(List<String> input) {
		String output = "";

		for (String string : input) {
			output += encapsulate(string) + ",";
		}
		return output.substring(0, output.length() - 1);
	}

	/**
	 * Encapsulates the given string between quotes
	 * 
	 * @param input the string to encapsulate
	 * @return the encapsulated string
	 */
	private String encapsulate(String input) {
		return "\"" + input + "\"";
	}

	/**
	 * Get all defined strings from the current program. Only strings equal to, or
	 * longer than, the given minimum size are returned
	 * 
	 * @param minimumLength the minimum length of the string to be included in the
	 *                      matches
	 * @return all strings that are at least as long as the minimum length
	 */
	private List<String> getStringsFromCurrentProgram(int minimumLength) {
		// Create a set to store all strings in
		Set<String> strings = new HashSet<>();

		// Get a data iterator
		DefinedDataIterator ddi = DefinedDataIterator.definedStrings(currentProgram);
		// Iterate over the data iterator
		for (Data d : ddi) {
			// Get an instance of the currently selected data
			StringDataInstance sdi = StringDataInstance.getStringDataInstance(d);
			// Get the string value of said string
			String s = sdi.getStringValue();

			// If the string is not null nor empty
			if (s != null && s.isEmpty() == false) {
				/*
				 * If the length of the string is equal to, or larger than the predefined
				 * minimum length
				 */
				if (s.length() >= minimumLength) {
					if (isFullyHumanReadable(s)) {
						// Add the string to the set
						strings.add(s);
					} else {
						println(s);
					}
				}
			}
		}

		/*
		 * Sets do not contain duplicate items by their nature, but cannot always be
		 * accessed in the same way as a list can (i.e. when sorting, given the
		 * hashset's nature).
		 * 
		 * The unique strings from the list, are stored in a newly created array list,
		 * which maintains the order. Next, they are sorted alphabetically, ignoring the
		 * casing during sorting to avoid an order where A-Za-z would occur, but rather
		 * any casing of A through Z.
		 */
		List<String> output = new ArrayList<>(strings);
		output.sort(String::compareToIgnoreCase);
		return output;
	}

	/**
	 * Non human readable characters will throw an error from the web server
	 * 
	 * @param input the string to check
	 * @return true if the string is fully readable, false if not
	 */
	private boolean isFullyHumanReadable(String input) {
		// Get the byte representation from the given string
		byte[] bytes = input.getBytes();

		// Iterate over all bytes
		for (byte b : bytes) {
			// Values lower than 0x20 are not human readable
			if (b < 0x20) {
				/*
				 * 0x09 is a horizontal tab
				 * 
				 * 0x0A is a line feed
				 * 
				 * 0x0D is carriage feed
				 */
				if (b != 0x09 && b != 0x0A && b != 0x0D) {
					return false;
				}
			}
			// 0xFF is an unreadable character
			if (b == 0xFF) {
				return false;
			}
		}
		return true;
	}

	/**
	 * A parsing function, which contains a custom GSON parser to properly parse the
	 * Malpedia JSON set
	 * 
	 * @param jsonFile the Malpedia JSON file, as a Java File object
	 * @return the custom Java object with all results
	 * @throws IOException
	 */
	private Map<String, MalpediaFlossedString> requestAndParse(List<String> stringsFromCurrentProgram)
			throws IOException {
		/*
		 * Create a custom JSON deserializer
		 */
		JsonDeserializer<MalpediaFlossed> deserializer = new JsonDeserializer<MalpediaFlossed>() {
			@Override
			public MalpediaFlossed deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
					throws JsonParseException {
				JsonObject jsonObject = json.getAsJsonObject();

				if (jsonObject.get("status").getAsString().equalsIgnoreCase("successful") == false) {
					printerr("Unssucessful request!");
					return null;
				}

				Map<String, MalpediaFlossedString> stringMapping = new HashMap<>();

				JsonArray data = jsonObject.get("data").getAsJsonArray();
				for (int count = 0; count < data.size(); count++) {
					JsonObject entry = data.get(count).getAsJsonObject();

					String string = entry.get("string").getAsString();

					boolean matched = entry.get("matched").getAsBoolean();

					List<String> encodings = new ArrayList<>();
					JsonElement element = entry.get("encodings");
					if (element != null) {
						JsonArray encodingsJson = element.getAsJsonArray();
						for (int i = 0; i < encodingsJson.size(); i++) {
							String encoding = encodingsJson.get(i).getAsString();
							encodings.add(encoding);
						}
					}

					List<String> tags = new ArrayList<>();
					element = entry.get("tags");
					if (element != null) {
						JsonArray tagsJson = element.getAsJsonArray();
						for (int i = 0; i < tagsJson.size(); i++) {
							String tag = tagsJson.get(i).getAsString();
							tags.add(tag);
						}
					}

					List<String> families = new ArrayList<>();

					element = entry.get("families");
					if (element != null) {
						JsonArray familiesJson = element.getAsJsonArray();
						for (int i = 0; i < familiesJson.size(); i++) {
							String family = familiesJson.get(i).getAsString();
							families.add(family);
						}
					}

					Integer familyCount = -1;
					element = entry.get("family_count");
					if (element != null) {
						familyCount = element.getAsInt();
					}

					List<String> methods = new ArrayList<>();
					element = entry.get("methods");
					if (element != null) {
						JsonArray methodsJson = element.getAsJsonArray();
						for (int i = 0; i < methodsJson.size(); i++) {
							String method = methodsJson.get(i).getAsString();
							methods.add(method);
						}
					}

					MalpediaFlossedString stringEntry = new MalpediaFlossedString(matched, encodings, families,
							familyCount, methods, tags);
					stringMapping.put(string, stringEntry);
				}

				return new MalpediaFlossed(stringMapping);
			}
		};

		// Create the request body
		String body = csvFormatList(stringsFromCurrentProgram);

		// Store the JSON response from the server
		String json = postRequest(body);

		// Initialise the GSON builder
		GsonBuilder gsonBuilder = new GsonBuilder();

		// Register the custom deserializer
		gsonBuilder.registerTypeAdapter(MalpediaFlossed.class, deserializer);

		// Create a Gson instance, with the custom adapter type
		Gson customGson = gsonBuilder.create();

		/*
		 * Parse the JSON into a Java object, and return the mapping from the wrapper
		 * object
		 */
		return customGson.fromJson(json, MalpediaFlossed.class).getData();
	}

	private class MalpediaFlossed {
		private Map<String, MalpediaFlossedString> data;

		public MalpediaFlossed(Map<String, MalpediaFlossedString> data) {
			super();
			this.data = data;
		}

		public Map<String, MalpediaFlossedString> getData() {
			return data;
		}
	}

	private class MalpediaFlossedString {
		boolean matched;
		private List<String> encodings;
		private List<String> families;
		private Integer familyCount;
		private List<String> methods;
		private List<String> tags;

		public MalpediaFlossedString() {

		}

		public MalpediaFlossedString(boolean matched, List<String> encodings, List<String> families,
				Integer familyCount, List<String> methods, List<String> tags) {
			super();
			this.matched = matched;
			this.encodings = encodings;
			this.families = families;
			this.familyCount = familyCount;
			this.methods = methods;
			this.tags = tags;
		}

		public boolean isMatched() {
			return matched;
		}

		public List<String> getEncodings() {
			return encodings;
		}

		public List<String> getFamilies() {
			return families;
		}

		public Integer getFamilyCount() {
			return familyCount;
		}

		public List<String> getMethods() {
			return methods;
		}

		public List<String> getTags() {
			return tags;
		}
	}
}
```

`README.md`:

```md
# GhidraScripts
Scripts to run within Ghidra, maintained by the Trellix ARC team.

## How to use Ghidra scripts
When Ghidra’s CodeBrowser is open, the green play button in the icon row opens the Script Manager, as can be seen in the screenshot below. Alternatively, one can open the Window tool strip menu item, and select Script Manager.

![The green play button opens the Script Manager](images/displayScriptManager.png)

Once open, one can manage the script directories with the hamburger menu in the top right corner of the Script Manager.

![The script manager, and the Manage Script Directories hamburger button](images/scriptManager.png)

Within that menu, one can click on the green plus to add a folder to the list of locations where scripts are fetched from. Once added, press the two green arrows to refresh the list.

![The bundle manager to add and/or remove folders from the places where Ghidra scripts are loaded from](images/bundleManager.png)

Once the refresh action has completed, the script should be in the list, and can be searched for using the textbox next to the filter label. To execute a script, simply double click it, or press the green play button within the Script Manager.

### Automagic
This script is used to tie multiple other scripts together in order to further automate the automatic analysis, depending its configuration. It allows the loading of additional FIDBs, the usage of multiple BSim databases along wit hthe BSim renaming script, the usage of GhidrAI, ColouriseByComplexity, and other helper scripts. You can find more about this script in this [blog](https://www.trellix.com/blogs/research/automagic-reverse-engineering/).

### GhidrAI
A script to interact with a LLM proxy and rename functions and variables and summarise functions.

### ColouriseByComplexity
This script will colourise function calls in the disassembly listing depending on their complexity. If the function is complex, the colour will be bright red. If the function is not complex, it will be dark red. The colour ranges between dark and bright red where the most complex function will be the brightest and the least complex function will be the darkest colour red.

### Golang related scripts
Simply run the scripts and observe the output in the Console Log. Error messages are indicative of what went wrong (i.e. a non supported file format, or an issue finding a specific data structure). Non-error messages are indicative of what the script has changed and updated.

### BSim function rename script
Run the script and provide all requested values. When running headless, provide the values via the CLI in the order of the menu field. The script's runtime will take a while. The database path should not include the double extension (".mv.db"), or the file will not be able to be found by Ghidra.

### FunctionID database generation script
Run this script headless and provide the requested values via the CLI. FunctionID databases are then generated, which can then be attached to Ghidra during subsequent analysis runs.

### MalpediaFlossedCheck[Local/WebApi].java
With this script, one can compare the [Malpedia FLOSSED](https://github.com/malpedia/malpedia-flossed) data set with the strings from the current program. Strings that do not occur in Malpedia's data set, are likely to be more uncommon, and likely warrant some more inspection, as they can be useful. Download and extract the [Malpedia FLOSSED](https://github.com/malpedia/malpedia-flossed) JSON file, and remember its location, as its required during the script's runtime.

There are two scripts to use, where the one named local will use the local JSON file (extracted from the ZIP archive). Given its size, and the requirement to load and parse it completely, one needs to allow the JavaVM via which Ghidra is started with more memory than it is given by default. This method is slow, yet fully local. The script named web API will query the web API service. One can host this locally (or on another machine that is privately owned), or one can use the public service which Malpedia is providing as-is.

### Sharem.java
Configure [SHAREM](https://github.com/Bw3ll/sharem/) to run [headless](https://github.com/Bw3ll/sharem/wiki/2.-Quick-Start-Analysis#configuration-file), and edit the script to contain the correct path to both Python and SHAREM's main Python file. Additionally, ensure the correct parameter for the shellcode's bitness is used, along with the correct path to the shellcode sample. Once all is configured, simply run the Ghidra script and wait until SHAREM finishes its execution. There is no progress bar for SHAREM's execution. Once it is done, the code will load the JSON file and start annotating the given offsets in Ghidra, which will be visible in the Console Log.

## Questions and/or feedback
Please open an issue in this repository with any questions and/or feedback you have, as long as it is related to the scripts within the repository.

```

`Sharem.java`:

```java
//Runs SHAREM and gets the resulting output, which is then annotated within Ghidra. This fixes dissassembly mistakes, adds context and arguments to function calls, and creates data points.
//@author Trellix (by Max ' Libra' Kersten)
//@category shellcode analysis
//@keybinding
//@menupath
//@toolbar

import java.io.File;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.util.Arrays;

import com.google.gson.Gson;

import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.ByteDataType;
import ghidra.program.model.data.DWordDataType;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.QWordDataType;
import ghidra.program.model.data.StringDataType;
import ghidra.program.model.data.WordDataType;
import ghidra.program.model.listing.Data;

public class Sharem extends GhidraScript {

	@Override
	protected void run() throws Exception {
		// The directory in which the command is executed, to be edited prior to using the script
		File workingDirectory = new File("C:\\path\\to\\sharem");
		// The command to execute within said working directory, to be edited prior to using the script
		String command = "C:\\path\\to\\python.exe main.py [architecture as in -r32 or -r64] C:\\path\\to\\shellcode.bin";

		try {
			/*
			 * Executes the given command from within the given working directory. This
			 * function only returns once the command has been executed.
			 */
			execute(workingDirectory, command);
		} catch (Exception ex) {
			// Print the error message
			printerr(ex.getMessage());
			// Return early
			return;
		}

		// Instantiate a new Gson object for later use
		Gson gson = new Gson();

		// Declare the JSON file variable, based on the working directory
		File jsonFile = new File(
				workingDirectory.getAbsolutePath() + "\\sharem\\sharem\\sharem\\logs\\default\\jsondefaultdisasm.json");

		// Read the file and store the result in a string
		String json = Files.readString(jsonFile.toPath());

		// Convert the raw JSON into a Java object
		SharemObject result = gson.fromJson(json, SharemObject.class);

		// Iterate over the objects
		for (SharemSubObject object : result.getObjects()) {
			// If a given object's comment is not null, empty, nor white space
			if (object.getComment().isBlank() == false) {
				// Get the offset in hexadecimal format
				long offset = Long.parseLong(object.getAddress().substring(2), 16);
				// Set a comment at the given offset, with the given comment
				setPreComment(toAddr(offset), object.getComment());
				// Create a string to print debug information
				String message = "Commented \"" + object.getComment() + "\" at " + object.getAddress();
				// Print the message
				println(message);
			}

			// If the type is CODE
			if (object.getBytes().equalsIgnoreCase("CODE")) {
				// Get the value of the bytes
				byte[] sharemValues = getBytesFromSharemObject(object);
				if (sharemValues == null) {
					continue;
				}
				// Get the bytes from Ghidra's listing
				byte[] ghidraValues = getBytes(toAddr(object.getAddress()), object.getSize());
				// If the values aren't equal
				if (Arrays.compare(sharemValues, ghidraValues) > 0) {
					// Clear the listing
					clearListing(toAddr(object.getAddress()));
					// Set the bytes as provided by SHAREM
					setBytes(toAddr(object.getAddress()), sharemValues);
					// Disassemble the bytes
					disassemble(toAddr(object.getAddress()));
				}
			} else if (object.getBytes().equalsIgnoreCase("DATA")) { // If the type is DATA
				if (object.getDataType().equalsIgnoreCase("String")) { // if the type is a string
					// Get the data at the given address
					Data data = getDataAt(toAddr(object.getAddress()));
					// If the data is not null
					if (data != null) {
						// Compare the length of the data and the size mentioned in the SHAREM object
						if (data.getLength() != object.getSize()) {
							// Get the end address
							Address end = toAddr(object.getAddress()).add(toAddr(object.getSize()).getOffset() - 1);
							// Get the start address
							Address start = toAddr(object.getAddress());
							// Clear the listing
							clearListing(start, end);
							// Create a string at the given address
							createAsciiString(toAddr(object.getAddress()));
						}
					} else {
						// Get the end address
						Address end = toAddr(object.getAddress()).add(toAddr(object.getSize()).getOffset() - 1);
						// Get the start address
						Address start = toAddr(object.getAddress());
						// Clear the listing
						clearListing(start, end);
						// If no data is present, simply create a string at the address
						createData(toAddr(object.getAddress()), StringDataType.dataType);
					}
				} else if (object.getDataType().equalsIgnoreCase("API Pointer")) { // If the type is a pointer
					// Get the data at the address
					Data data = getDataAt(toAddr(object.getAddress()));
					// If the data is not present
					if (data == null) {
						// Create the pointer
						createData(toAddr(object.getAddress()), PointerDataType.dataType);
					}
					// Set a comment with the instruction to provide context
					setPreComment(toAddr(object.getAddress()), object.getInstruction());
				} else if (object.getDataType().equalsIgnoreCase("DATA")) {
					// Get the data at the address
					Data data = getDataAt(toAddr(object.getAddress()));
					
					/*
					 * If the data is not null, it exists, and can thus be removed, since it will be
					 * overwritten
					 */
					if (data != null) {
						// Get the end address
						Address end = toAddr(object.getAddress()).add(toAddr(object.getSize()).getOffset() - 1);
						// Get the start address
						Address start = toAddr(object.getAddress());
						// Clear the listing
						clearListing(start, end);
					}

					// Handle different sizes with regards to data creation
					switch (object.getSize()) {
					case 1:
						createData(toAddr(object.getAddress()), ByteDataType.dataType);
						break;
					case 2:
						createData(toAddr(object.getAddress()), WordDataType.dataType);
						break;
					case 4:
						createData(toAddr(object.getAddress()), DWordDataType.dataType);
						break;
					case 8:
						createData(toAddr(object.getAddress()), QWordDataType.dataType);
						break;
					}

				}
			}
		}
	}

	/**
	 * A helper function to get the bytes from the given disassembly object's hex
	 * value field which contains the instruction in hexadecimal format
	 * 
	 * @param object the disassembly object
	 * @return the raw bytes of the given instruction, if any
	 */
	private byte[] getBytesFromSharemObject(SharemSubObject object) {
		byte[] bytes = new byte[object.getSize()];
		String[] values = object.getHex().split(" ");

		for (int i = 0; i < values.length; i++) {
			try {
				bytes[i] = (byte) Integer.parseInt(values[i], 16);
			} catch (Exception ex) {
				/*
				 * Ignore entries where the value ends with dots, as those aren't hex values.
				 * Returning null ensures the caller to omit these bytes
				 */
				return null;
			}

		}
		return bytes;
	}

	/**
	 * Determines if the current operating system is Windows.
	 *
	 * @return true if the operating system is Windows, false if it is not.
	 */
	public static boolean isWindows() {
		/*
		 * If the os.name property of the Java VM contains "windows", the system is
		 * Windows based
		 */
		if (System.getProperty("os.name").toLowerCase().contains("windows")) {
			return true;
		}
		return false;
	}

	/**
	 * A helper function to launch a new process via the system's shell
	 * 
	 * @param workingDirectory the working directory of the process
	 * @param command          the command to execute
	 * @throws Exception if anything goes wrong
	 */
	public void execute(File workingDirectory, String command) throws Exception {
		try {
			String[] processName = new String[1];
			// Check if the OS is windows
			if (isWindows()) {
				processName[0] = "cmd";
			} else { // Use the shell if the OS is not Windows
				processName[0] = "sh";
			}
			// Start a new shell
			Process p = Runtime.getRuntime().exec(processName, null, workingDirectory);
			// Get the standard input
			PrintWriter stdin = new PrintWriter(p.getOutputStream());
			// Start the command via the shell
			stdin.println(command);
			// Close the stream
			stdin.close();
			// Wait until the process terminates
			p.waitFor();
		} catch (Exception ex) {
			/*
			 * Throw an exception if anything goes wrong, which is used to notify the
			 * analyst
			 */
			throw new Exception("Error while launching SHAREM! Error:\n\n" + ex.getMessage());
		}
	}

	class SharemSubObject {

		/**
		 * The starting address within the binary where the reference to is made
		 */
		private String address;

		/**
		 * The instruction, as extracted by SHAREM
		 */
		private String instruction;

		/**
		 * The hex value of the instruction
		 */
		private String hex;

		/**
		 * The size of the object (i.e. the length of a string, or the size of an
		 * instruction)
		 */
		private String size;

		/**
		 * Is either <code>CODE</code> or <code>DATA</code>, indicating what the type of
		 * the object is
		 */
		private String bytes;

		/**
		 * Provides further information about the data type, if this object references
		 * DATA. The optional values are <code>String</code> or <code>API Pointer</code>
		 */
		private String dataType;

		/**
		 * Defines how data is accessed
		 */
		private String dataAccessed;

		/**
		 * Gets the string representation of the data (at the given address with the
		 * given length). This can be garbage when not dealing with strings (i.e.
		 * instructions)
		 */
		private String string;

		/**
		 * Gets a SHAREM made comment for this object
		 */
		private String comment;

		/**
		 * A label which contains an address, if present. Redundant field.
		 */
		private String label;

		/**
		 * Creates an instance of a single instruction/piece of data that is emitted by
		 * SHAREM.
		 * 
		 * @param address      the starting address within the binary where the
		 *                     reference to is made
		 * @param instruction  the instruction, as extracted by SHAREM
		 * @param hex          the hex value of the instruction
		 * @param size         the size of the object (i.e. the length of a string, or
		 *                     the size of an instruction)
		 * @param bytes        is either <code>CODE</code> or <code>DATA</code>,
		 *                     indicating what the type of the object is
		 * @param dataType     provides further information about the data type, if this
		 *                     object references DATA. The optional values are
		 *                     <code>String</code> or <code>API Pointer</code>
		 * @param dataAccessed defines how data is accessed
		 * @param string       gets the string representation of the data (at the given
		 *                     address with the given length). This can be garbage when
		 *                     not dealing with strings (i.e. instructions)
		 * @param comment      gets a SHAREM made comment for this object
		 * @param label        a label which contains an address, if present. Redundant
		 *                     field.
		 */
		public SharemSubObject(String address, String instruction, String hex, String size, String bytes,
				String dataType, String dataAccessed, String string, String comment, String label) {
			this.address = address;
			this.instruction = instruction;
			this.hex = hex;
			this.size = size;
			this.bytes = bytes;
			this.dataType = dataType;
			this.dataAccessed = dataAccessed;
			this.string = string;
			this.comment = comment;
			this.label = label;
		}

		/**
		 * The starting address within the binary where the reference to is made
		 * 
		 * @return the address as a string
		 */
		public String getAddress() {
			return address;
		}

		/**
		 * The instruction, as extracted by SHAREM
		 * 
		 * @return the instruction as a string
		 */
		public String getInstruction() {
			return instruction;
		}

		/**
		 * The hex value of the instruction
		 * 
		 * @return the hex value as a string (split by spaces, not denoted by "0x")
		 */
		public String getHex() {
			return hex;
		}

		/**
		 * The size of the object (i.e. the length of a string, or the size of an
		 * instruction)
		 * 
		 * @return the size as a string
		 */
		public int getSize() {
			return Integer.parseInt(size);
		}

		/**
		 * Is either <code>CODE</code> or <code>DATA</code>, indicating what the type of
		 * the object is
		 * 
		 * @return the type, as a string
		 */
		public String getBytes() {
			return bytes;
		}

		/**
		 * Provides further information about the data type, if this object references
		 * DATA. The optional values are <code>String</code> or <code>API Pointer</code>
		 * 
		 * @return the more granular type, as a string
		 */
		public String getDataType() {
			return dataType;
		}

		/**
		 * Defines how data is accessed
		 * 
		 * @return the way the data is accessed, as a string
		 */
		public String getDataAccessed() {
			return dataAccessed;
		}

		/**
		 * Gets the string representation of the data (at the given address with the
		 * given length). This can be garbage when not dealing with strings (i.e.
		 * instructions)
		 * 
		 * @return the value of the object
		 */
		public String getString() {
			return string;
		}

		/**
		 * Gets a SHAREM made comment for this object
		 * 
		 * @return the comment
		 */
		public String getComment() {
			return comment;
		}

		/**
		 * A label which contains an address, if present. Redundant field.
		 * 
		 * @return the label as a string
		 */
		public String getLabel() {
			return label;
		}
	}

	/**
	 * The JSON output from SHAREM is an array of items. For ease-of-access and
	 * ease-of-handling, a Java class is used as a wrapper around the array
	 * 
	 * @author Max 'Libra' Kersten for Trellix
	 *
	 */
	class SharemObject {

		/**
		 * The array of entries from SHAREM
		 */
		private SharemSubObject[] disassembly;

		/**
		 * Creates an instance of this wrapper object
		 * 
		 * @param disassembly the array of objects which contain the disassembly of the
		 *                    analysed shellcode
		 */
		public SharemObject(SharemSubObject[] disassembly) {
			this.disassembly = disassembly;
		}

		/**
		 * Gets the SHAREM objects
		 * 
		 * @return the SHAREM objects
		 */
		public SharemSubObject[] getObjects() {
			return disassembly;
		}
	}
}

```