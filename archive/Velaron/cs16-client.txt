Project Path: arc_Velaron_cs16-client_yl25ydkw

Source Tree:

```txt
arc_Velaron_cs16-client_yl25ydkw
├── 3rdparty
│   ├── ReGameDLL_CS
│   ├── cs16client-extras
│   │   ├── BotChatter.db
│   │   ├── BotProfile.db
│   │   ├── gfx
│   │   │   └── shell
│   │   │       ├── btn_favorite.bmp
│   │   │       ├── btn_gamepad.bmp
│   │   │       ├── btn_touch.bmp
│   │   │       ├── btn_touch_buttons.bmp
│   │   │       ├── btn_touch_editor.bmp
│   │   │       ├── btn_touch_options.bmp
│   │   │       ├── btn_touch_reset.bmp
│   │   │       ├── btn_touch_save.bmp
│   │   │       ├── btn_touch_select.bmp
│   │   │       ├── btn_unfavorite.bmp
│   │   │       ├── btn_xhair.bmp
│   │   │       ├── btns_main.bmp
│   │   │       ├── head_advanced.bmp
│   │   │       ├── head_advoptions.bmp
│   │   │       ├── head_audio.bmp
│   │   │       ├── head_config.bmp
│   │   │       ├── head_controls.bmp
│   │   │       ├── head_creategame.bmp
│   │   │       ├── head_custom.bmp
│   │   │       ├── head_customize.bmp
│   │   │       ├── head_gameopts.bmp
│   │   │       ├── head_gamepad.bmp
│   │   │       ├── head_inetgames.bmp
│   │   │       ├── head_lan.bmp
│   │   │       ├── head_load.bmp
│   │   │       ├── head_multi.bmp
│   │   │       ├── head_save.bmp
│   │   │       ├── head_saveload.bmp
│   │   │       ├── head_touch.bmp
│   │   │       ├── head_touch_buttons.bmp
│   │   │       ├── head_touch_options.bmp
│   │   │       ├── head_video.bmp
│   │   │       ├── head_vidmodes.bmp
│   │   │       ├── head_vidoptions.bmp
│   │   │       ├── head_xhair.bmp
│   │   │       ├── splash.bmp
│   │   │       └── strings.lst
│   │   ├── maps
│   │   │   ├── tr_1.bsp
│   │   │   ├── tr_1a.bsp
│   │   │   ├── tr_2.bsp
│   │   │   └── tr_3.bsp
│   │   ├── media
│   │   │   ├── launch_deny1.wav
│   │   │   ├── launch_deny2.wav
│   │   │   ├── launch_dnmenu1.wav
│   │   │   ├── launch_glow1.wav
│   │   │   ├── launch_select1.wav
│   │   │   ├── launch_select2.wav
│   │   │   └── launch_upmenu1.wav
│   │   ├── sound
│   │   │   ├── radio
│   │   │   │   └── bot
│   │   │   │       ├── a.wav
│   │   │   │       ├── a_bunch_of_them.wav
│   │   │   │       ├── aah.wav
│   │   │   │       ├── affirmative.wav
│   │   │   │       ├── ahh_negative.wav
│   │   │   │       ├── airplane.wav
│   │   │   │       ├── all_clear_here.wav
│   │   │   │       ├── all_quiet.wav
│   │   │   │       ├── alley.wav
│   │   │   │       ├── alright.wav
│   │   │   │       ├── alright2.wav
│   │   │   │       ├── alright_lets_do_this.wav
│   │   │   │       ├── and_thats_how_its_done.wav
│   │   │   │       ├── anyone_see_anything.wav
│   │   │   │       ├── anyone_see_them.wav
│   │   │   │       ├── apartment.wav
│   │   │   │       ├── apartments.wav
│   │   │   │       ├── area_clear.wav
│   │   │   │       ├── area_secure.wav
│   │   │   │       ├── atrium.wav
│   │   │   │       ├── attacking.wav
│   │   │   │       ├── attacking_enemies.wav
│   │   │   │       ├── attic.wav
│   │   │   │       ├── aw_hell.wav
│   │   │   │       ├── aww_man.wav
│   │   │   │       ├── b.wav
│   │   │   │       ├── back.wav
│   │   │   │       ├── back_alley.wav
│   │   │   │       ├── back_door.wav
│   │   │   │       ├── back_hall.wav
│   │   │   │       ├── back_room.wav
│   │   │   │       ├── back_way.wav
│   │   │   │       ├── back_yard.wav
│   │   │   │       ├── balcony.wav
│   │   │   │       ├── basement.wav
│   │   │   │       ├── bathroom.wav
│   │   │   │       ├── bathroom2.wav
│   │   │   │       ├── be_right_there.wav
│   │   │   │       ├── bedroom.wav
│   │   │   │       ├── bedroom2.wav
│   │   │   │       ├── big_office.wav
│   │   │   │       ├── bombs_on_the_ground.wav
│   │   │   │       ├── bombs_on_the_ground_here.wav
│   │   │   │       ├── bombsite.wav
│   │   │   │       ├── bombsite2.wav
│   │   │   │       ├── bombsite_secure.wav
│   │   │   │       ├── bombsite_secure_ready_for_you.wav
│   │   │   │       ├── bombsite_secured.wav
│   │   │   │       ├── bombsite_under_control.wav
│   │   │   │       ├── bridge.wav
│   │   │   │       ├── bunker.wav
│   │   │   │       ├── c.wav
│   │   │   │       ├── camping_hostages.wav
│   │   │   │       ├── clear.wav
│   │   │   │       ├── clear2.wav
│   │   │   │       ├── clear3.wav
│   │   │   │       ├── clear4.wav
│   │   │   │       ├── come_out_and_fight_like_a_man.wav
│   │   │   │       ├── come_out_wherever_you_are.wav
│   │   │   │       ├── come_to_papa.wav
│   │   │   │       ├── computer_room.wav
│   │   │   │       ├── conference_room.wav
│   │   │   │       ├── courtyard.wav
│   │   │   │       ├── cover_me.wav
│   │   │   │       ├── cover_me2.wav
│   │   │   │       ├── crates.wav
│   │   │   │       ├── crawlspace.wav
│   │   │   │       ├── ct_spawn.wav
│   │   │   │       ├── cut_it_out.wav
│   │   │   │       ├── deck.wav
│   │   │   │       ├── defusing.wav
│   │   │   │       ├── defusing_bomb.wav
│   │   │   │       ├── defusing_bomb_now.wav
│   │   │   │       ├── den.wav
│   │   │   │       ├── do_not_mess_with_me.wav
│   │   │   │       ├── dont_worry_hell_get_it.wav
│   │   │   │       ├── double_doors.wav
│   │   │   │       ├── downstairs.wav
│   │   │   │       ├── dropped_him.wav
│   │   │   │       ├── dumpster.wav
│   │   │   │       ├── elevator.wav
│   │   │   │       ├── elevator2.wav
│   │   │   │       ├── enemy_down.wav
│   │   │   │       ├── enemy_down2.wav
│   │   │   │       ├── engaging_enemies.wav
│   │   │   │       ├── entrance.wav
│   │   │   │       ├── entryway.wav
│   │   │   │       ├── family_room.wav
│   │   │   │       ├── far_side.wav
│   │   │   │       ├── fence.wav
│   │   │   │       ├── foyer.wav
│   │   │   │       ├── front.wav
│   │   │   │       ├── front_door.wav
│   │   │   │       ├── front_door2.wav
│   │   │   │       ├── front_hall.wav
│   │   │   │       ├── front_room.wav
│   │   │   │       ├── front_yard.wav
│   │   │   │       ├── garage.wav
│   │   │   │       ├── gate.wav
│   │   │   │       ├── gatehouse.wav
│   │   │   │       ├── going_to_plant_the_bomb_at_b.wav
│   │   │   │       ├── good_idea.wav
│   │   │   │       ├── good_job_team.wav
│   │   │   │       ├── good_one.wav
│   │   │   │       ├── good_one2.wav
│   │   │   │       ├── good_one_sir.wav
│   │   │   │       ├── good_one_sir2.wav
│   │   │   │       ├── good_shot.wav
│   │   │   │       ├── good_shot2.wav
│   │   │   │       ├── good_shot_commander.wav
│   │   │   │       ├── good_shot_commander2.wav
│   │   │   │       ├── got_him.wav
│   │   │   │       ├── got_the_sniper.wav
│   │   │   │       ├── got_the_sniper2.wav
│   │   │   │       ├── great.wav
│   │   │   │       ├── guardhouse.wav
│   │   │   │       ├── guarding_a.wav
│   │   │   │       ├── guarding_b.wav
│   │   │   │       ├── guarding_c.wav
│   │   │   │       ├── guarding_hostages.wav
│   │   │   │       ├── guarding_the_dropped_bomb.wav
│   │   │   │       ├── guarding_the_escape_zone.wav
│   │   │   │       ├── guarding_the_escape_zone2.wav
│   │   │   │       ├── guarding_the_hostages.wav
│   │   │   │       ├── hang_on_i_heard_something.wav
│   │   │   │       ├── hang_on_im_coming.wav
│   │   │   │       ├── he_got_away.wav
│   │   │   │       ├── he_got_away2.wav
│   │   │   │       ├── heading_to_a.wav
│   │   │   │       ├── heading_to_b.wav
│   │   │   │       ├── heading_to_c.wav
│   │   │   │       ├── heading_to_the_escape_zone.wav
│   │   │   │       ├── heading_to_the_rescue_zone.wav
│   │   │   │       ├── help.wav
│   │   │   │       ├── hes_broken.wav
│   │   │   │       ├── hes_dead.wav
│   │   │   │       ├── hes_done.wav
│   │   │   │       ├── hes_down.wav
│   │   │   │       ├── hes_got_the_bomb.wav
│   │   │   │       ├── hes_got_the_bomb2.wav
│   │   │   │       ├── hes_got_the_package.wav
│   │   │   │       ├── hey.wav
│   │   │   │       ├── hey2.wav
│   │   │   │       ├── hold_your_fire.wav
│   │   │   │       ├── hostage_down.wav
│   │   │   │       ├── hostages.wav
│   │   │   │       ├── hostages2.wav
│   │   │   │       ├── hostages_secure_ready_for_you.wav
│   │   │   │       ├── house.wav
│   │   │   │       ├── i_am_dangerous.wav
│   │   │   │       ├── i_am_on_fire.wav
│   │   │   │       ├── i_cant_see.wav
│   │   │   │       ├── i_could_use_some_help.wav
│   │   │   │       ├── i_could_use_some_help_over_here.wav
│   │   │   │       ├── i_dont_know_where_he_went.wav
│   │   │   │       ├── i_dont_think_so.wav
│   │   │   │       ├── i_got_a_covered.wav
│   │   │   │       ├── i_got_b_covered.wav
│   │   │   │       ├── i_got_c_covered.wav
│   │   │   │       ├── i_got_more_where_that_came_from.wav
│   │   │   │       ├── i_got_nothing.wav
│   │   │   │       ├── i_got_your_back.wav
│   │   │   │       ├── i_got_your_back2.wav
│   │   │   │       ├── i_have_the_hostages.wav
│   │   │   │       ├── i_hear_something.wav
│   │   │   │       ├── i_hear_them.wav
│   │   │   │       ├── i_heard_something_over_there.wav
│   │   │   │       ├── i_heard_them.wav
│   │   │   │       ├── i_lost_him.wav
│   │   │   │       ├── i_see_our_target.wav
│   │   │   │       ├── i_see_the_bomber.wav
│   │   │   │       ├── i_wasnt_worried_for_a_minute.wav
│   │   │   │       ├── ill_come_with_you.wav
│   │   │   │       ├── ill_go_too.wav
│   │   │   │       ├── ill_go_with_you.wav
│   │   │   │       ├── im_at_the_escape_zone.wav
│   │   │   │       ├── im_at_the_hostages.wav
│   │   │   │       ├── im_blind.wav
│   │   │   │       ├── im_camping_a.wav
│   │   │   │       ├── im_camping_b.wav
│   │   │   │       ├── im_camping_c.wav
│   │   │   │       ├── im_coming.wav
│   │   │   │       ├── im_going_to_camp.wav
│   │   │   │       ├── im_going_to_camp_a.wav
│   │   │   │       ├── im_going_to_camp_b.wav
│   │   │   │       ├── im_going_to_camp_c.wav
│   │   │   │       ├── im_going_to_camp_the_hostages.wav
│   │   │   │       ├── im_going_to_cover_the_escape_zone.wav
│   │   │   │       ├── im_going_to_guard_bombsite_a.wav
│   │   │   │       ├── im_going_to_guard_bombsite_b.wav
│   │   │   │       ├── im_going_to_guard_bombsite_c.wav
│   │   │   │       ├── im_going_to_guard_the_bomb.wav
│   │   │   │       ├── im_going_to_guard_the_bomb2.wav
│   │   │   │       ├── im_going_to_guard_the_hostages.wav
│   │   │   │       ├── im_going_to_guard_the_hostages2.wav
│   │   │   │       ├── im_going_to_keep_an_eye_on_the_bomb.wav
│   │   │   │       ├── im_going_to_keep_an_eye_on_the_escape.wav
│   │   │   │       ├── im_going_to_keep_an_eye_on_the_rescue.wav
│   │   │   │       ├── im_going_to_wait_here.wav
│   │   │   │       ├── im_going_to_watch_the_bomb.wav
│   │   │   │       ├── im_going_to_watch_the_escape_zone.wav
│   │   │   │       ├── im_going_to_watch_the_rescue_zone.wav
│   │   │   │       ├── im_gonna_go_plant.wav
│   │   │   │       ├── im_gonna_go_plant_the_bomb.wav
│   │   │   │       ├── im_gonna_hang_back.wav
│   │   │   │       ├── im_gonna_plant_the_bomb_at_a.wav
│   │   │   │       ├── im_gonna_plant_the_bomb_at_b.wav
│   │   │   │       ├── im_gonna_plant_the_bomb_at_c.wav
│   │   │   │       ├── im_gonna_plant_the_bomb_at_c2.wav
│   │   │   │       ├── im_in_trouble.wav
│   │   │   │       ├── im_on_your_side.wav
│   │   │   │       ├── im_pinned_down.wav
│   │   │   │       ├── im_waiting_here.wav
│   │   │   │       ├── im_with_the_hostages.wav
│   │   │   │       ├── im_with_the_hostages2.wav
│   │   │   │       ├── im_with_you.wav
│   │   │   │       ├── in_combat.wav
│   │   │   │       ├── in_combat2.wav
│   │   │   │       ├── inside.wav
│   │   │   │       ├── its_a_party.wav
│   │   │   │       ├── its_all_up_to_you_sir.wav
│   │   │   │       ├── ive_been_blinded.wav
│   │   │   │       ├── ive_got_the_bomb.wav
│   │   │   │       ├── ive_got_the_bomb_here.wav
│   │   │   │       ├── ive_got_the_hostages.wav
│   │   │   │       ├── keeping_an_eye_on_the_hostages.wav
│   │   │   │       ├── killed_him.wav
│   │   │   │       ├── kitchen.wav
│   │   │   │       ├── kitchen2.wav
│   │   │   │       ├── ladder.wav
│   │   │   │       ├── lead_on_commander.wav
│   │   │   │       ├── lead_on_sir.wav
│   │   │   │       ├── lead_the_way.wav
│   │   │   │       ├── lead_the_way_commander.wav
│   │   │   │       ├── lead_the_way_sir.wav
│   │   │   │       ├── lets_hold_up_here_for_a_minute.wav
│   │   │   │       ├── lets_wait_here.wav
│   │   │   │       ├── little_office.wav
│   │   │   │       ├── living_room.wav
│   │   │   │       ├── loading_dock.wav
│   │   │   │       ├── lobby.wav
│   │   │   │       ├── loft.wav
│   │   │   │       ├── long_hall.wav
│   │   │   │       ├── look_out_brag.wav
│   │   │   │       ├── made_him_cry.wav
│   │   │   │       ├── main_hall.wav
│   │   │   │       ├── market.wav
│   │   │   │       ├── market2.wav
│   │   │   │       ├── me_too.wav
│   │   │   │       ├── meeting_room.wav
│   │   │   │       ├── middle.wav
│   │   │   │       ├── mines.wav
│   │   │   │       ├── my_eyes.wav
│   │   │   │       ├── naa.wav
│   │   │   │       ├── need_help.wav
│   │   │   │       ├── need_help2.wav
│   │   │   │       ├── negative.wav
│   │   │   │       ├── negative2.wav
│   │   │   │       ├── neutralized.wav
│   │   │   │       ├── nice.wav
│   │   │   │       ├── nice2.wav
│   │   │   │       ├── nice_one_commander.wav
│   │   │   │       ├── nice_one_sir.wav
│   │   │   │       ├── nice_shot.wav
│   │   │   │       ├── nice_shot2.wav
│   │   │   │       ├── nice_shot_commander.wav
│   │   │   │       ├── nice_shot_commander2.wav
│   │   │   │       ├── nice_shot_sir.wav
│   │   │   │       ├── nice_work_team.wav
│   │   │   │       ├── nnno_sir.wav
│   │   │   │       ├── no.wav
│   │   │   │       ├── no2.wav
│   │   │   │       ├── no_sir.wav
│   │   │   │       ├── no_thanks.wav
│   │   │   │       ├── noo.wav
│   │   │   │       ├── nothing.wav
│   │   │   │       ├── nothing_happening_over_here.wav
│   │   │   │       ├── nothing_here.wav
│   │   │   │       ├── nothing_moving_over_here.wav
│   │   │   │       ├── office.wav
│   │   │   │       ├── oh.wav
│   │   │   │       ├── oh_boy.wav
│   │   │   │       ├── oh_boy2.wav
│   │   │   │       ├── oh_man.wav
│   │   │   │       ├── oh_my_god.wav
│   │   │   │       ├── oh_no.wav
│   │   │   │       ├── oh_no_sad.wav
│   │   │   │       ├── oh_yea.wav
│   │   │   │       ├── oh_yea2.wav
│   │   │   │       ├── ok.wav
│   │   │   │       ├── ok2.wav
│   │   │   │       ├── ok_cmdr_lets_go.wav
│   │   │   │       ├── ok_sir_lets_go.wav
│   │   │   │       ├── old_mines.wav
│   │   │   │       ├── on_my_way.wav
│   │   │   │       ├── on_my_way2.wav
│   │   │   │       ├── one_guy.wav
│   │   │   │       ├── one_guy_left.wav
│   │   │   │       ├── ouch.wav
│   │   │   │       ├── outside.wav
│   │   │   │       ├── overpass.wav
│   │   │   │       ├── ow.wav
│   │   │   │       ├── ow_its_me.wav
│   │   │   │       ├── owned.wav
│   │   │   │       ├── pain10.wav
│   │   │   │       ├── pain2.wav
│   │   │   │       ├── pain4.wav
│   │   │   │       ├── pain5.wav
│   │   │   │       ├── pain8.wav
│   │   │   │       ├── pain9.wav
│   │   │   │       ├── patio.wav
│   │   │   │       ├── planting.wav
│   │   │   │       ├── planting_at_a.wav
│   │   │   │       ├── planting_at_b.wav
│   │   │   │       ├── planting_at_c.wav
│   │   │   │       ├── planting_the_bomb.wav
│   │   │   │       ├── please_defuse_the_bomb_sir.wav
│   │   │   │       ├── porch.wav
│   │   │   │       ├── projector_room.wav
│   │   │   │       ├── ramp.wav
│   │   │   │       ├── ramp2.wav
│   │   │   │       ├── rear.wav
│   │   │   │       ├── report_in_team.wav
│   │   │   │       ├── reporting_in.wav
│   │   │   │       ├── rescue_zone.wav
│   │   │   │       ├── rescue_zone2.wav
│   │   │   │       ├── rescuing_hostages.wav
│   │   │   │       ├── returning_fire.wav
│   │   │   │       ├── roger.wav
│   │   │   │       ├── roger_that.wav
│   │   │   │       ├── roof.wav
│   │   │   │       ├── ruined_his_day.wav
│   │   │   │       ├── security_doors.wav
│   │   │   │       ├── sewers.wav
│   │   │   │       ├── sewers2.wav
│   │   │   │       ├── side.wav
│   │   │   │       ├── side_alley.wav
│   │   │   │       ├── side_door.wav
│   │   │   │       ├── side_hall.wav
│   │   │   │       ├── side_room.wav
│   │   │   │       ├── side_yard.wav
│   │   │   │       ├── sir_defuse_the_bomb.wav
│   │   │   │       ├── sniper.wav
│   │   │   │       ├── sniper2.wav
│   │   │   │       ├── sniper_down.wav
│   │   │   │       ├── sounds_like_a_plan.wav
│   │   │   │       ├── spotted_the_delivery_boy.wav
│   │   │   │       ├── stairs.wav
│   │   │   │       ├── stairwell.wav
│   │   │   │       ├── stop_it.wav
│   │   │   │       ├── storage_room.wav
│   │   │   │       ├── t_spawn.wav
│   │   │   │       ├── tag_them_and_bag_them.wav
│   │   │   │       ├── taking_fire_need_assistance2.wav
│   │   │   │       ├── taking_the_bomb_to_a.wav
│   │   │   │       ├── taking_the_bomb_to_b.wav
│   │   │   │       ├── taking_the_bomb_to_c.wav
│   │   │   │       ├── taking_the_hostages_to_safety.wav
│   │   │   │       ├── talking_to_hostages.wav
│   │   │   │       ├── target_acquired.wav
│   │   │   │       ├── target_spotted.wav
│   │   │   │       ├── that_was_a_close_one.wav
│   │   │   │       ├── that_was_it.wav
│   │   │   │       ├── that_was_the_last_guy.wav
│   │   │   │       ├── that_was_the_last_one.wav
│   │   │   │       ├── thats_not_good.wav
│   │   │   │       ├── thats_right.wav
│   │   │   │       ├── thats_the_way_this_is_done.wav
│   │   │   │       ├── the_actions_hot_here.wav
│   │   │   │       ├── the_bomb_is_down.wav
│   │   │   │       ├── the_bomb_is_on_the_ground.wav
│   │   │   │       ├── the_bombs_at_a.wav
│   │   │   │       ├── the_bombs_at_b.wav
│   │   │   │       ├── the_bombs_at_c.wav
│   │   │   │       ├── the_bombs_here.wav
│   │   │   │       ├── the_bombs_here_on_the_ground.wav
│   │   │   │       ├── the_bombs_ticking_at_a.wav
│   │   │   │       ├── the_bombs_ticking_at_b.wav
│   │   │   │       ├── the_bombs_ticking_at_c.wav
│   │   │   │       ├── the_commander_is_down.wav
│   │   │   │       ├── the_commander_is_down_repeat.wav
│   │   │   │       ├── the_hostages_are_eager.wav
│   │   │   │       ├── the_hostages_are_gone.wav
│   │   │   │       ├── the_hostages_are_ready.wav
│   │   │   │       ├── the_hostages_are_waiting.wav
│   │   │   │       ├── the_hostages_are_with_me.wav
│   │   │   │       ├── the_sniper_is_dead.wav
│   │   │   │       ├── theres_nobody_home.wav
│   │   │   │       ├── theres_not_much_time_left.wav
│   │   │   │       ├── theres_one_left.wav
│   │   │   │       ├── theres_the_bomb.wav
│   │   │   │       ├── theres_the_bomb2.wav
│   │   │   │       ├── theres_the_bomber.wav
│   │   │   │       ├── theres_too_many.wav
│   │   │   │       ├── theres_too_many_of_them.wav
│   │   │   │       ├── they_dropped_the_bomb.wav
│   │   │   │       ├── they_got_me_pinned_down_here.wav
│   │   │   │       ├── they_got_the_bomb.wav
│   │   │   │       ├── they_never_knew_what_hit_them.wav
│   │   │   │       ├── they_picked_up_the_bomb.wav
│   │   │   │       ├── they_took_the_bomb.wav
│   │   │   │       ├── they_took_the_bomb2.wav
│   │   │   │       ├── they_took_the_hostages.wav
│   │   │   │       ├── they_will_not_escape.wav
│   │   │   │       ├── they_wont_get_away.wav
│   │   │   │       ├── they_wont_get_away2.wav
│   │   │   │       ├── theyre_all_over_the_place2.wav
│   │   │   │       ├── theyre_everywhere2.wav
│   │   │   │       ├── theyre_rescuing_the_hostages.wav
│   │   │   │       ├── theyre_taking_the_hostages.wav
│   │   │   │       ├── theyre_with_the_hostages.wav
│   │   │   │       ├── theyve_got_the_hostages.wav
│   │   │   │       ├── this_is_my_house.wav
│   │   │   │       ├── three.wav
│   │   │   │       ├── three_left.wav
│   │   │   │       ├── three_of_them.wav
│   │   │   │       ├── three_to_go.wav
│   │   │   │       ├── three_to_go2.wav
│   │   │   │       ├── time_is_running_out.wav
│   │   │   │       ├── time_is_running_out2.wav
│   │   │   │       ├── too_many2.wav
│   │   │   │       ├── took_him_down.wav
│   │   │   │       ├── took_him_out.wav
│   │   │   │       ├── took_him_out2.wav
│   │   │   │       ├── took_out_the_sniper.wav
│   │   │   │       ├── tower.wav
│   │   │   │       ├── truck.wav
│   │   │   │       ├── tunnel.wav
│   │   │   │       ├── tunnel2.wav
│   │   │   │       ├── two_enemies_left.wav
│   │   │   │       ├── two_of_them.wav
│   │   │   │       ├── two_to_go.wav
│   │   │   │       ├── uh_oh.wav
│   │   │   │       ├── uh_sir_the_bomb.wav
│   │   │   │       ├── underground.wav
│   │   │   │       ├── underpass.wav
│   │   │   │       ├── upstairs.wav
│   │   │   │       ├── vault.wav
│   │   │   │       ├── vending_machines.wav
│   │   │   │       ├── vending_machines2.wav
│   │   │   │       ├── ventilation_system.wav
│   │   │   │       ├── vents.wav
│   │   │   │       ├── vents2.wav
│   │   │   │       ├── very_nice.wav
│   │   │   │       ├── villiage.wav
│   │   │   │       ├── wall.wav
│   │   │   │       ├── wasted_him.wav
│   │   │   │       ├── watch_it_theres_a_sniper.wav
│   │   │   │       ├── watching_the_escape_route.wav
│   │   │   │       ├── watching_the_escape_zone.wav
│   │   │   │       ├── watching_the_hostages.wav
│   │   │   │       ├── water.wav
│   │   │   │       ├── way_to_be_team.wav
│   │   │   │       ├── we_gotta_find_that_bomb.wav
│   │   │   │       ├── we_need_you_to_defuse_that_bomb_sir.wav
│   │   │   │       ├── we_owned_them.wav
│   │   │   │       ├── well_cover_you_while_you_defuse.wav
│   │   │   │       ├── well_cover_you_you_defuse.wav
│   │   │   │       ├── well_done.wav
│   │   │   │       ├── weve_got_the_situation.wav
│   │   │   │       ├── weve_lost_the_commander.wav
│   │   │   │       ├── what_are_you_doing.wav
│   │   │   │       ├── what_happened.wav
│   │   │   │       ├── what_have_you_done.wav
│   │   │   │       ├── where_are_the_hostages.wav
│   │   │   │       ├── where_are_they.wav
│   │   │   │       ├── where_are_you_hiding.wav
│   │   │   │       ├── where_could_they_be.wav
│   │   │   │       ├── where_is_it.wav
│   │   │   │       ├── wheres_the_bomb.wav
│   │   │   │       ├── wheres_the_bomb2.wav
│   │   │   │       ├── wheres_the_bomb3.wav
│   │   │   │       ├── whew_that_was_close.wav
│   │   │   │       ├── who_wants_some_more.wav
│   │   │   │       ├── whoa.wav
│   │   │   │       ├── whoo.wav
│   │   │   │       ├── whoo2.wav
│   │   │   │       ├── whos_the_man.wav
│   │   │   │       ├── window.wav
│   │   │   │       ├── windows.wav
│   │   │   │       ├── wine_cellar.wav
│   │   │   │       ├── yea_baby.wav
│   │   │   │       ├── yea_ok.wav
│   │   │   │       ├── yesss.wav
│   │   │   │       ├── yesss2.wav
│   │   │   │       ├── yikes.wav
│   │   │   │       └── you_heard_the_man_lets_go.wav
│   │   │   └── training
│   │   │       ├── cstrain1.wav
│   │   │       ├── cstrain10.wav
│   │   │       ├── cstrain11.wav
│   │   │       ├── cstrain12.wav
│   │   │       ├── cstrain13.wav
│   │   │       ├── cstrain14.wav
│   │   │       ├── cstrain15.wav
│   │   │       ├── cstrain16.wav
│   │   │       ├── cstrain17.wav
│   │   │       ├── cstrain18.wav
│   │   │       ├── cstrain18a.wav
│   │   │       ├── cstrain19.wav
│   │   │       ├── cstrain2.wav
│   │   │       ├── cstrain2a.wav
│   │   │       ├── cstrain3.wav
│   │   │       ├── cstrain4.wav
│   │   │       ├── cstrain5.wav
│   │   │       ├── cstrain6.wav
│   │   │       ├── cstrain7.wav
│   │   │       ├── cstrain7a.wav
│   │   │       ├── cstrain8.wav
│   │   │       ├── cstrain9.wav
│   │   │       ├── cstrain9a.wav
│   │   │       ├── cstrain9b.wav
│   │   │       └── cstrain9c.wav
│   │   ├── touch
│   │   │   ├── bots
│   │   │   │   ├── bots.cfg
│   │   │   │   ├── my_menu-2-addbot.cfg
│   │   │   │   ├── my_menu-2-settings.cfg
│   │   │   │   ├── my_menu-3-quota.cfg
│   │   │   │   ├── my_menu-3-set1.cfg
│   │   │   │   ├── my_menu-3-set2.cfg
│   │   │   │   ├── my_menu-3-set3.cfg
│   │   │   │   ├── my_menu-3-set4.cfg
│   │   │   │   ├── my_menu-3-set5.cfg
│   │   │   │   ├── my_menu-3-set6.cfg
│   │   │   │   └── right.tga
│   │   │   ├── buy.cfg
│   │   │   ├── buy_item_ct.cfg
│   │   │   ├── buy_item_t.cfg
│   │   │   ├── buy_machinegun_ct.cfg
│   │   │   ├── buy_machinegun_t.cfg
│   │   │   ├── buy_pistol_ct.cfg
│   │   │   ├── buy_pistol_t.cfg
│   │   │   ├── buy_rifle_ct.cfg
│   │   │   ├── buy_rifle_t.cfg
│   │   │   ├── buy_shotgun_ct.cfg
│   │   │   ├── buy_shotgun_t.cfg
│   │   │   ├── buy_submachinegun_ct.cfg
│   │   │   ├── buy_submachinegun_t.cfg
│   │   │   ├── chooseteam.cfg
│   │   │   ├── chooseteam_ct.cfg
│   │   │   ├── chooseteam_tr.cfg
│   │   │   ├── cmd
│   │   │   │   ├── cmd.cfg
│   │   │   │   ├── my_menu-2-connection.cfg
│   │   │   │   ├── my_menu-2-demo.cfg
│   │   │   │   ├── my_menu-2-game.cfg
│   │   │   │   ├── my_menu-2-graphic.cfg
│   │   │   │   ├── my_menu-2-server.cfg
│   │   │   │   ├── my_menu-3-console.cfg
│   │   │   │   ├── my_menu-3-crosshair.cfg
│   │   │   │   ├── my_menu-3-cvars.cfg
│   │   │   │   ├── my_menu-3-fps.cfg
│   │   │   │   ├── my_menu-3-hud.cfg
│   │   │   │   ├── my_menu-3-maps.cfg
│   │   │   │   ├── my_menu-3-model.cfg
│   │   │   │   ├── my_menu-3-numerical.cfg
│   │   │   │   ├── my_menu-3-radar.cfg
│   │   │   │   ├── my_menu-3-scoreboard.cfg
│   │   │   │   ├── my_menu-3-texture.cfg
│   │   │   │   ├── my_menu-3-voice.cfg
│   │   │   │   ├── my_menu-4-cross-size.cfg
│   │   │   │   ├── my_menu-4-cvar0.cfg
│   │   │   │   ├── my_menu-4-cvar1.cfg
│   │   │   │   ├── my_menu-4-cvar2.cfg
│   │   │   │   ├── my_menu-4-cvar3.cfg
│   │   │   │   ├── my_menu-4-cvar4.cfg
│   │   │   │   ├── my_menu-4-cvar5.cfg
│   │   │   │   ├── my_menu-4-xhair.cfg
│   │   │   │   ├── my_menu-5-cvar0-2.cfg
│   │   │   │   ├── my_menu-5-cvar2-2.cfg
│   │   │   │   ├── my_menu-5-cvar3-2.cfg
│   │   │   │   ├── my_menu-5-cvar5-2.cfg
│   │   │   │   ├── my_menu-5-voicequality.cfg
│   │   │   │   ├── my_menu-5-xhair.cfg
│   │   │   │   └── right.tga
│   │   │   ├── custom
│   │   │   │   ├── dm_menu.cfg
│   │   │   │   ├── my_menu-5-controls.cfg
│   │   │   │   └── my_menu-language.cfg
│   │   │   ├── customcmd.cfg
│   │   │   ├── gfx
│   │   │   │   ├── attack.png
│   │   │   │   ├── attack2.png
│   │   │   │   ├── botmenu.png
│   │   │   │   ├── buy.png
│   │   │   │   ├── change_team.png
│   │   │   │   ├── chat.png
│   │   │   │   ├── chat_all.png
│   │   │   │   ├── chat_team.png
│   │   │   │   ├── cmdmenu.png
│   │   │   │   ├── down.png
│   │   │   │   ├── dpad.png
│   │   │   │   ├── drop.png
│   │   │   │   ├── duck.png
│   │   │   │   ├── exit.png
│   │   │   │   ├── flaghtlight.png
│   │   │   │   ├── hud_edit.png
│   │   │   │   ├── joy.png
│   │   │   │   ├── jump.png
│   │   │   │   ├── key_0.png
│   │   │   │   ├── key_1.png
│   │   │   │   ├── key_2.png
│   │   │   │   ├── key_3.png
│   │   │   │   ├── key_4.png
│   │   │   │   ├── key_5.png
│   │   │   │   ├── key_6.png
│   │   │   │   ├── key_7.png
│   │   │   │   ├── key_8.png
│   │   │   │   ├── key_9.png
│   │   │   │   ├── left.png
│   │   │   │   ├── light.png
│   │   │   │   ├── minus.png
│   │   │   │   ├── nightvision.png
│   │   │   │   ├── plus.png
│   │   │   │   ├── radio.png
│   │   │   │   ├── radio1.png
│   │   │   │   ├── radio2.png
│   │   │   │   ├── radio3.png
│   │   │   │   ├── reload.png
│   │   │   │   ├── right.png
│   │   │   │   ├── score.png
│   │   │   │   ├── settings.png
│   │   │   │   ├── spraypaint.png
│   │   │   │   ├── use.png
│   │   │   │   ├── voicechat.png
│   │   │   │   ├── w_c4.png
│   │   │   │   ├── w_grenade.png
│   │   │   │   ├── w_knife.png
│   │   │   │   ├── w_pistol.png
│   │   │   │   ├── w_rifle.png
│   │   │   │   └── walk.png
│   │   │   ├── numerical_menu.cfg
│   │   │   ├── numerical_menu1.cfg
│   │   │   ├── numerical_menu2.cfg
│   │   │   ├── numerical_menu3.cfg
│   │   │   ├── radioa.cfg
│   │   │   ├── radiob.cfg
│   │   │   ├── radioc.cfg
│   │   │   ├── radioselector.cfg
│   │   │   ├── scoreboard.cfg
│   │   │   ├── scoreboard_classic.cfg
│   │   │   ├── scoreboard_full.cfg
│   │   │   └── scoreboard_short.cfg
│   │   ├── touch.cfg
│   │   ├── touch_default
│   │   │   └── numbers.cfg
│   │   ├── touch_presets
│   │   │   ├── phone_ahsim.cfg
│   │   │   ├── phone_poverony.cfg
│   │   │   ├── psvita.cfg
│   │   │   ├── tablet_poverony.cfg
│   │   │   └── touch_swank.cfg
│   │   └── userconfig.d
│   │       ├── touch_defalias.cfg
│   │       └── userconfig.cfg
│   ├── mainui_cpp
│   ├── miniutl
│   └── yapb
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── android
│   ├── app
│   │   ├── build.gradle
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           ├── ic_launcher-playstore.png
│   │           ├── ic_launcher_cz-playstore.png
│   │           ├── java
│   │           │   └── su
│   │           │       └── xash
│   │           │           └── cs16client
│   │           │               ├── CZeroActivity.java
│   │           │               └── MainActivity.java
│   │           └── res
│   │               ├── drawable
│   │               │   └── ic_launcher_cz_foreground.xml
│   │               ├── mipmap-anydpi-v26
│   │               │   ├── ic_launcher.xml
│   │               │   ├── ic_launcher_cz.xml
│   │               │   ├── ic_launcher_cz_round.xml
│   │               │   ├── ic_launcher_foreground.xml
│   │               │   ├── ic_launcher_monochrome.xml
│   │               │   └── ic_launcher_round.xml
│   │               ├── mipmap-hdpi
│   │               │   ├── ic_launcher.png
│   │               │   ├── ic_launcher_cz.webp
│   │               │   ├── ic_launcher_cz_round.webp
│   │               │   ├── ic_launcher_foreground.png
│   │               │   └── ic_launcher_round.png
│   │               ├── mipmap-mdpi
│   │               │   ├── ic_launcher.png
│   │               │   ├── ic_launcher_cz.webp
│   │               │   ├── ic_launcher_cz_round.webp
│   │               │   ├── ic_launcher_foreground.png
│   │               │   └── ic_launcher_round.png
│   │               ├── mipmap-xhdpi
│   │               │   ├── ic_launcher.png
│   │               │   ├── ic_launcher_cz.webp
│   │               │   ├── ic_launcher_cz_round.webp
│   │               │   ├── ic_launcher_foreground.png
│   │               │   └── ic_launcher_round.png
│   │               ├── mipmap-xxhdpi
│   │               │   ├── ic_launcher.png
│   │               │   ├── ic_launcher_cz.webp
│   │               │   ├── ic_launcher_cz_round.webp
│   │               │   ├── ic_launcher_foreground.png
│   │               │   └── ic_launcher_round.png
│   │               ├── mipmap-xxxhdpi
│   │               │   ├── ic_launcher.png
│   │               │   ├── ic_launcher_cz.webp
│   │               │   ├── ic_launcher_cz_round.webp
│   │               │   ├── ic_launcher_foreground.png
│   │               │   └── ic_launcher_round.png
│   │               └── values
│   │                   ├── ic_launcher_background.xml
│   │                   ├── ic_launcher_cz_background.xml
│   │                   └── strings.xml
│   ├── build.gradle
│   ├── gradle
│   │   └── wrapper
│   │       ├── gradle-wrapper.jar
│   │       └── gradle-wrapper.properties
│   ├── gradle.properties
│   ├── gradlew
│   ├── gradlew.bat
│   └── settings.gradle
├── cl_dll
│   ├── CMakeLists.txt
│   ├── GameStudioModelRenderer.cpp
│   ├── GameStudioModelRenderer.h
│   ├── ScenarioStatus.cpp
│   ├── SniperScope.cpp
│   ├── StudioModelRenderer.cpp
│   ├── VGUI
│   │   ├── CSProgressBar.cpp
│   │   ├── CSProgressBar.h
│   │   ├── CareerBox.cpp
│   │   ├── CareerBox.h
│   │   ├── WeaponSetLabel.h
│   │   ├── backgroundpanel.cpp
│   │   ├── basecareermenu.cpp
│   │   ├── buymenu.cpp
│   │   ├── buymouseoverpanelbutton.h
│   │   ├── buypreset_editmenu.cpp
│   │   ├── buypreset_listbox.cpp
│   │   ├── buypreset_listbox.h
│   │   ├── buypreset_mainmenu.cpp
│   │   ├── buypresetimageinfo.cpp
│   │   ├── buypresetpanel.cpp
│   │   ├── buysubmenu.cpp
│   │   ├── buysubmenu.h
│   │   ├── careermatchendmenu.cpp
│   │   ├── careerroundendmenu.cpp
│   │   ├── counterstrikeviewport.cpp
│   │   ├── counterstrikeviewport_interface.cpp
│   │   ├── creditsmenu.cpp
│   │   ├── cstrikeclassmenu.cpp
│   │   ├── cstrikeclassmenu.h
│   │   ├── cstrikeclientscoreboard.cpp
│   │   ├── cstrikespectatorgui.cpp
│   │   └── cstriketeammenu.cpp
│   ├── ammo.cpp
│   ├── ammo_secondary.cpp
│   ├── ammohistory.cpp
│   ├── ammohistory.h
│   ├── battery.cpp
│   ├── buy_preset.cpp
│   ├── buy_preset_debug.cpp
│   ├── buy_preset_weapon_info.cpp
│   ├── buy_presets.cpp
│   ├── buy_presets.h
│   ├── cdll_int.cpp
│   ├── cl_dll.dsp
│   ├── cl_util.h
│   ├── com_weapons.cpp
│   ├── cs_wpn
│   │   ├── cs_baseentity.cpp
│   │   └── cs_weapons.cpp
│   ├── death.cpp
│   ├── demo.cpp
│   ├── draw_util.cpp
│   ├── entity.cpp
│   ├── ev_common.cpp
│   ├── ev_hldm.cpp
│   ├── events
│   │   ├── ev_cs16.cpp
│   │   ├── event_ak47.cpp
│   │   ├── event_aug.cpp
│   │   ├── event_awp.cpp
│   │   ├── event_createexplo.cpp
│   │   ├── event_createsmoke.cpp
│   │   ├── event_czerods.cpp
│   │   ├── event_deagle.cpp
│   │   ├── event_decal_reset.cpp
│   │   ├── event_elite.cpp
│   │   ├── event_famas.cpp
│   │   ├── event_fiveseven.cpp
│   │   ├── event_g3sg1.cpp
│   │   ├── event_galil.cpp
│   │   ├── event_glock18.cpp
│   │   ├── event_knife.cpp
│   │   ├── event_m249.cpp
│   │   ├── event_m3.cpp
│   │   ├── event_m4a1.cpp
│   │   ├── event_mac10.cpp
│   │   ├── event_mp5n.cpp
│   │   ├── event_p228.cpp
│   │   ├── event_p90.cpp
│   │   ├── event_scout.cpp
│   │   ├── event_sg550.cpp
│   │   ├── event_sg552.cpp
│   │   ├── event_tmp.cpp
│   │   ├── event_ump45.cpp
│   │   ├── event_usp.cpp
│   │   ├── event_vehicle.cpp
│   │   └── event_xm1014.cpp
│   ├── events.cpp
│   ├── flashlight.cpp
│   ├── geiger.cpp
│   ├── health.cpp
│   ├── health.h
│   ├── hl
│   │   ├── hl_baseentity.cpp
│   │   ├── hl_events.cpp
│   │   ├── hl_objects.cpp
│   │   └── hl_weapons.cpp
│   ├── hud
│   │   ├── MOTD.cpp
│   │   ├── money.cpp
│   │   ├── nvg.cpp
│   │   ├── radar.cpp
│   │   ├── radio.cpp
│   │   ├── scenario.cpp
│   │   ├── scoreboard.cpp
│   │   ├── sniperscope.cpp
│   │   ├── spectator_gui.cpp
│   │   └── timer.cpp
│   ├── hud.cpp
│   ├── hud.h
│   ├── hud_msg.cpp
│   ├── hud_redraw.cpp
│   ├── hud_spectator.cpp
│   ├── hud_spectator.h
│   ├── hud_update.cpp
│   ├── hud_vgui2print.cpp
│   ├── in_camera.cpp
│   ├── include
│   │   ├── camera.h
│   │   ├── cl_dll.h
│   │   ├── com_weapons.h
│   │   ├── csprite.h
│   │   ├── demo.h
│   │   ├── draw_util.h
│   │   ├── ev_hldm.h
│   │   ├── events.h
│   │   ├── eventscripts.h
│   │   ├── hud
│   │   │   ├── ammo.h
│   │   │   ├── hud_iface.h
│   │   │   └── radar.h
│   │   ├── in_defs.h
│   │   ├── input.h
│   │   ├── kbutton.h
│   │   ├── math
│   │   │   ├── neon_mathfun.h
│   │   │   └── sse_mathfun.h
│   │   ├── overview.h
│   │   ├── parsemsg.h
│   │   ├── rain.h
│   │   ├── studio
│   │   │   ├── StudioModelRenderer.h
│   │   │   └── studio_util.h
│   │   ├── tf_defs.h
│   │   ├── unicode_strtools.h
│   │   ├── vgui_parser.h
│   │   ├── view.h
│   │   └── wrect.h
│   ├── input
│   │   ├── input_sdl.cpp
│   │   └── input_xash3d.cpp
│   ├── input.cpp
│   ├── inputw32.cpp
│   ├── interpolation.cpp
│   ├── menu.cpp
│   ├── message.cpp
│   ├── nightvision.cpp
│   ├── rain.cpp
│   ├── readme.txt
│   ├── saytext.cpp
│   ├── status_icons.cpp
│   ├── statusbar.cpp
│   ├── studio_util.cpp
│   ├── text_message.cpp
│   ├── train.cpp
│   ├── tri.cpp
│   ├── tri.h
│   ├── unicode_strtools.cpp
│   ├── util.cpp
│   ├── util_vector.h
│   ├── vgui_parser.cpp
│   ├── view.cpp
│   ├── z_weather.cpp
│   └── z_weather.h
├── cmake
│   └── LibraryNaming.cmake
├── common
│   ├── beamdef.h
│   ├── cl_entity.h
│   ├── com_model.h
│   ├── con_nprint.h
│   ├── const.h
│   ├── crc.h
│   ├── cvardef.h
│   ├── demo_api.h
│   ├── director_cmds.h
│   ├── dlight.h
│   ├── dll_state.h
│   ├── engine_launcher_api.h
│   ├── entity_state.h
│   ├── entity_types.h
│   ├── enums.h
│   ├── event_api.h
│   ├── event_args.h
│   ├── event_flags.h
│   ├── exefuncs.h
│   ├── gameinfo.h
│   ├── hltv.h
│   ├── in_buttons.h
│   ├── interface.cpp
│   ├── interface.h
│   ├── ivoicetweak.h
│   ├── kbutton.h
│   ├── lightstyle.h
│   ├── mathlib.h
│   ├── net_api.h
│   ├── netadr.h
│   ├── nowin.h
│   ├── particledef.h
│   ├── pmtrace.h
│   ├── port.h
│   ├── qfont.h
│   ├── r_efx.h
│   ├── r_studioint.h
│   ├── ref_params.h
│   ├── render_api.h
│   ├── screenfade.h
│   ├── studio_event.h
│   ├── triangleapi.h
│   ├── usercmd.h
│   ├── weaponinfo.h
│   ├── wrect.h
│   └── xash3d_types.h
├── dlls
│   ├── activity.h
│   ├── basemonster.h
│   ├── cbase.h
│   ├── cdll_dll.h
│   ├── effects.h
│   ├── enginecallback.h
│   ├── exportdef.h
│   ├── extdll.h
│   ├── gamerules.h
│   ├── hintmessage.h
│   ├── monsterevent.h
│   ├── monsters.h
│   ├── nodes.h
│   ├── player.h
│   ├── saverestore.h
│   ├── schedule.h
│   ├── skill.h
│   ├── soundent.h
│   ├── stdafx.h
│   ├── util.h
│   ├── vector.h
│   ├── weapons.h
│   ├── weapontype.h
│   ├── wpn_shared
│   │   ├── wpn_ak47.cpp
│   │   ├── wpn_aug.cpp
│   │   ├── wpn_awp.cpp
│   │   ├── wpn_c4.cpp
│   │   ├── wpn_deagle.cpp
│   │   ├── wpn_elite.cpp
│   │   ├── wpn_famas.cpp
│   │   ├── wpn_fiveseven.cpp
│   │   ├── wpn_flashbang.cpp
│   │   ├── wpn_g3sg1.cpp
│   │   ├── wpn_galil.cpp
│   │   ├── wpn_glock18.cpp
│   │   ├── wpn_hegrenade.cpp
│   │   ├── wpn_knife.cpp
│   │   ├── wpn_m249.cpp
│   │   ├── wpn_m3.cpp
│   │   ├── wpn_m4a1.cpp
│   │   ├── wpn_mac10.cpp
│   │   ├── wpn_mp5navy.cpp
│   │   ├── wpn_p228.cpp
│   │   ├── wpn_p90.cpp
│   │   ├── wpn_scout.cpp
│   │   ├── wpn_sg550.cpp
│   │   ├── wpn_sg552.cpp
│   │   ├── wpn_smokegrenade.cpp
│   │   ├── wpn_tmp.cpp
│   │   ├── wpn_ump45.cpp
│   │   ├── wpn_usp.cpp
│   │   └── wpn_xm1014.cpp
│   └── wpn_shared.h
├── engine
│   ├── APIProxy.h
│   ├── Sequence.h
│   ├── anorms.h
│   ├── archtypes.h
│   ├── cdll_int.h
│   ├── custom.h
│   ├── customentity.h
│   ├── edict.h
│   ├── eiface.h
│   ├── keydefs.h
│   ├── menu_int.h
│   ├── mobility_int.h
│   ├── progdefs.h
│   ├── progs.h
│   ├── shake.h
│   └── studio.h
├── game_shared
│   ├── bitvec.h
│   ├── voice_banmgr.cpp
│   ├── voice_banmgr.h
│   ├── voice_common.h
│   ├── voice_gamemgr.cpp
│   ├── voice_gamemgr.h
│   ├── voice_status.cpp
│   ├── voice_status.h
│   ├── voice_status_hud.cpp
│   └── voice_status_hud.h
├── pm_shared
│   ├── pm_debug.cpp
│   ├── pm_debug.h
│   ├── pm_defs.h
│   ├── pm_info.h
│   ├── pm_materials.h
│   ├── pm_math.cpp
│   ├── pm_math.h
│   ├── pm_movevars.h
│   ├── pm_shared.cpp
│   └── pm_shared.h
├── public
│   ├── build.h
│   ├── cl_dll
│   │   └── IGameClientExports.h
│   ├── steam
│   │   └── steamtypes.h
│   ├── tier1
│   │   ├── UtlMemory.h
│   │   └── UtlVector.h
│   ├── utflib.cpp
│   └── utflib.h
├── scripts
│   ├── pack_extras.py
│   ├── psvita_generate_configs.sh
│   ├── psvita_sdk.sh
│   └── yapb_graph_dl.py
└── toolchains
    └── i386-linux-gnu.cmake

```

`3rdparty/cs16client-extras/BotChatter.db`:

```db
//----------------------------------------------------------------------------
// BotChatter.db
// Author: Michael S. Booth, Turtle Rock Studios (www.turtlerockstudios.com)
//
// This database defines "Places" (phrases that describe a location in the world)
// and "Chatter" (phrases used for everything else) the bots use to talk via their radio.
// 
// Phrases (ie: either Place or Chatter) can contain any number of wav filenames that
// contain voice recordings saying something appropriate for that phrase's concept.
// For instance, the Chatter entry for "Affirmative" contains several wav files saying
// things that mean "yes", such as "affirmative", "yes sir", "roger that", and so on.
//
// Some phrases have a "Radio" line. This maps that phrase to a Standard Radio event and
// is used when the player has restricted the bots to only using Standard Radio messages.
// In that case, that radio message will be played instead of the normal phrase.
//
// The keyword "Important" flags that phrase as being "mission critical", and means it
// will be spoken if the player has set the bots to "minimal" chatter.
//
// "Count" and "Place" qualifiers mean that any subsequent wav files will only be selected
// if the bot is referring to the given Count or Place.
//
//
// VOICE ACTOR NOTES:
// Unless otherwise stated, these phrases should be spoken in a terse, matter-of-fact manner.
// The bots will utter "batches" of phrases to communicate the situation. For example, if a bot
// discovers many enemies near the bridge, and one of them is carrying the bomb, he will say
// something like:
//   "Bridge" ... "There's the bomber" ... "Need help!"  
//
//
// ***NOTE: Total filename length must be less than 64!
//


//
// Places must be first in this database
//

Place BombsiteA
	radio\bot\a.wav
End

Place BombsiteB
	radio\bot\b.wav
End

Place BombsiteC
	radio\bot\c.wav
End

Place Hostages
	radio\bot\hostages.wav
End

Place HostageRescueZone
	radio\bot\rescue_zone.wav
	radio\bot\rescue_zone2.wav
End

Place VipRescueZone
	radio\bot\rescue_zone.wav
	radio\bot\rescue_zone2.wav
End

Place CTSpawn
	radio\bot\ct_spawn.wav
End

Place TSpawn
	radio\bot\t_spawn.wav
End


Place Bridge
	radio\bot\bridge.wav
End

Place Middle
	radio\bot\middle.wav
End

Place House
	radio\bot\house.wav
End

Place Apartment
	radio\bot\apartment.wav
End

Place Apartments
	radio\bot\apartments.wav
End

Place Market
	radio\bot\market.wav
	radio\bot\market2.wav
End

Place Sewers
	radio\bot\sewers.wav
	radio\bot\sewers2.wav
End

Place Tunnel
	radio\bot\tunnel.wav
	radio\bot\tunnel2.wav
End

Place Ducts
	radio\bot\vents.wav
	radio\bot\vents2.wav
	radio\bot\ventilation_system.wav
End

Place Village
	radio\bot\villiage.wav
End

Place Roof
	radio\bot\roof.wav
End

Place Upstairs
	radio\bot\upstairs.wav
End

Place Downstairs
	radio\bot\downstairs.wav
End

Place Basement
	radio\bot\basement.wav
End

Place Crawlspace
	radio\bot\crawlspace.wav
End

Place Kitchen
	radio\bot\kitchen.wav
	radio\bot\kitchen2.wav
End

Place Inside
	radio\bot\inside.wav
End

Place Outside
	radio\bot\outside.wav
End

Place Tower
	radio\bot\tower.wav
End

Place WineCellar
	radio\bot\wine_cellar.wav
End

Place Garage
	radio\bot\garage.wav
End

Place Courtyard
	radio\bot\courtyard.wav
End

Place Water
	radio\bot\water.wav
End

Place FrontDoor
	radio\bot\front_door.wav
	radio\bot\front_door2.wav
End

Place BackDoor
	radio\bot\back_door.wav
End

Place SideDoor
	radio\bot\side_door.wav
End

Place BackWay
	radio\bot\back_way.wav
End

Place FrontYard
	radio\bot\front_yard.wav
End

Place BackYard
	radio\bot\back_yard.wav
End

Place SideYard
	radio\bot\side_yard.wav
End

Place Lobby
	radio\bot\lobby.wav
End

Place Vault
	radio\bot\vault.wav
End

Place Elevator
	radio\bot\elevator.wav
	radio\bot\elevator2.wav
End

Place DoubleDoors
	radio\bot\double_doors.wav
End

Place SecurityDoors
	radio\bot\security_doors.wav
End

Place LongHall
	radio\bot\long_hall.wav
End

Place SideHall
	radio\bot\side_hall.wav
End

Place FrontHall
	radio\bot\front_hall.wav
End

Place BackHall
	radio\bot\back_hall.wav
End

Place MainHall
	radio\bot\main_hall.wav
End

Place FarSide
	radio\bot\far_side.wav
End

Place Windows
	radio\bot\windows.wav
End

Place Window
	radio\bot\window.wav
End

Place Attic
	radio\bot\attic.wav
End

Place StorageRoom
	radio\bot\storage_room.wav
End

Place ProjectorRoom
	radio\bot\projector_room.wav
End

Place MeetingRoom
	radio\bot\meeting_room.wav
End

Place ConferenceRoom
	radio\bot\conference_room.wav
End

Place ComputerRoom
	radio\bot\computer_room.wav
End

Place BigOffice
	radio\bot\big_office.wav
End

Place LittleOffice
	radio\bot\little_office.wav
End

Place Dumpster
	radio\bot\dumpster.wav
End

Place Airplane
	radio\bot\airplane.wav
End

Place Underground
	radio\bot\underground.wav
End

Place Bunker
	radio\bot\bunker.wav
End

Place Mines
	radio\bot\mines.wav
	radio\bot\old_mines.wav
End

Place Front
	radio\bot\front.wav
End

Place Back
	radio\bot\back.wav
End

Place Rear
	radio\bot\rear.wav
End

Place Side
	radio\bot\side.wav
End

Place Ramp
	radio\bot\ramp.wav
	radio\bot\ramp2.wav
End

Place Underpass
	radio\bot\underpass.wav
End

Place Overpass
	radio\bot\overpass.wav
End

Place Stairs
	radio\bot\stairs.wav
End

Place Ladder
	radio\bot\ladder.wav
End

Place Gate
	radio\bot\gate.wav
End

Place GateHouse
	radio\bot\gatehouse.wav
End

Place LoadingDock
	radio\bot\loading_dock.wav
End

Place GuardHouse
	radio\bot\guardhouse.wav
End

Place Entrance
	radio\bot\entrance.wav
End

Place VendingMachines
	radio\bot\vending_machines.wav
	radio\bot\vending_machines2.wav
End

Place Loft
	radio\bot\loft.wav
End

Place Balcony
	radio\bot\balcony.wav
End

Place Alley
	radio\bot\alley.wav
End

Place BackAlley
	radio\bot\back_alley.wav
End

Place SideAlley
	radio\bot\side_alley.wav
End

Place FrontRoom
	radio\bot\front_room.wav
End

Place BackRoom
	radio\bot\back_room.wav
End

Place SideRoom
	radio\bot\side_room.wav
End

Place Crates
	radio\bot\crates.wav
End

Place Truck
	radio\bot\truck.wav
End

Place Bedroom
	radio\bot\bedroom.wav
	radio\bot\bedroom2.wav
End

Place FamilyRoom
	radio\bot\family_room.wav
End

Place Bathroom
	radio\bot\bathroom.wav
	radio\bot\bathroom2.wav
End

Place LivingRoom
	radio\bot\living_room.wav
End

Place Den
	radio\bot\den.wav
End

Place Office
	radio\bot\office.wav
End

Place Atrium
	radio\bot\atrium.wav
End

Place Entryway
	radio\bot\entryway.wav
End

Place Foyer
	radio\bot\foyer.wav
End

Place Stairwell
	radio\bot\stairwell.wav
End

Place Fence
	radio\bot\fence.wav
End

Place Deck
	radio\bot\deck.wav
End

Place Porch
	radio\bot\porch.wav
End

Place Patio
	radio\bot\patio.wav
End

Place Wall
	radio\bot\wall.wav
End



//-----------------------------------------------------------------------------------------
//
// Chatter phrases follow
//

// one or more enemies have just been sighted for the first time
Chatter EnemySpotted
	Radio EVENT_RADIO_ENEMY_SPOTTED

	Count 1
		radio\bot\one_guy.wav

	Count 2
		radio\bot\two_of_them.wav

	Count 3
		radio\bot\three.wav
		radio\bot\three_of_them.wav

	Count Many
		// VOICE NOTE: The bot is scared here - there are a lot of enemies!
		radio\bot\a_bunch_of_them.wav
		radio\bot\theyre_all_over_the_place2.wav
		radio\bot\theyre_everywhere2.wav
		radio\bot\theres_too_many_of_them.wav
		radio\bot\theres_too_many.wav
		radio\bot\too_many2.wav
		radio\bot\the_actions_hot_here.wav 
		radio\bot\its_a_party.wav 
End

// the bot has recently seen an enemy die
Chatter EnemyDown
	Radio EVENT_RADIO_ENEMY_DOWN

	radio\bot\enemy_down.wav 
	radio\bot\enemy_down2.wav 
End

// the bot says this when asked to "report in" while he is fighting enemies
Chatter InCombat
	Radio EVENT_RADIO_ENEMY_SPOTTED

	radio\bot\attacking.wav 
	radio\bot\attacking_enemies.wav 
	radio\bot\engaging_enemies.wav 
	radio\bot\in_combat.wav 
	radio\bot\in_combat2.wav 
	radio\bot\returning_fire.wav 
End

// the bot has been asked to "report in" and sees nothing interesting in his area
Chatter Clear
	Radio EVENT_RADIO_SECTOR_CLEAR

	radio\bot\clear.wav 
	radio\bot\clear2.wav 
	radio\bot\clear3.wav 
	radio\bot\clear4.wav 
	radio\bot\area_clear.wav 
	radio\bot\all_clear_here.wav 
	radio\bot\nothing_moving_over_here.wav 
	radio\bot\all_quiet.wav 
	radio\bot\nothing_happening_over_here.wav 
	radio\bot\i_got_nothing.wav 
	radio\bot\nothing.wav 
	radio\bot\nothing_here.wav 
	radio\bot\theres_nobody_home.wav 
End

// the bot hasn't seen anything in a long time and is asking his teammates to report in
Chatter RequestReport
	Radio EVENT_RADIO_REPORT_IN_TEAM

	radio\bot\report_in_team.wav 
	radio\bot\anyone_see_them.wav 
	radio\bot\anyone_see_anything.wav 
	radio\bot\where_are_they.wav 
	radio\bot\where_could_they_be.wav 
End

// the bot has killed the enemy has was fighting
Chatter KilledMyEnemy
	Radio EVENT_RADIO_ENEMY_DOWN

	radio\bot\hes_dead.wav 
	radio\bot\hes_down.wav 
	radio\bot\got_him.wav 
	radio\bot\dropped_him.wav 
	radio\bot\killed_him.wav 
	radio\bot\ruined_his_day.wav 
	radio\bot\wasted_him.wav 
	radio\bot\took_him_out.wav 
	radio\bot\took_him_out2.wav 
	radio\bot\took_him_down.wav 
	radio\bot\made_him_cry.wav 
	radio\bot\hes_broken.wav 
	radio\bot\hes_done.wav 
End

// the bot was chasing after his enemy and lost track of him
// VOICE NOTE: Minor frustration/disappointment/exasperation here
Chatter LostEnemy
	radio\bot\he_got_away.wav 
	radio\bot\he_got_away2.wav 
	radio\bot\i_dont_know_where_he_went.wav 
	radio\bot\i_lost_him.wav 
End

// the bot is telling his team that the last enemy has been killed
// VOICE NOTE: Happy/smugness/satisfaction
Chatter NoEnemiesLeft
	radio\bot\that_was_it.wav
	radio\bot\that_was_the_last_one.wav
	radio\bot\that_was_the_last_guy.wav
End

// the bot is telling his team there is one enemy left
// VOICE NOTE: Anticipation
Chatter OneEnemyLeft
	radio\bot\one_guy_left.wav
	radio\bot\theres_one_left.wav
End

// the bot is telling his team there are two enemies left
Chatter TwoEnemiesLeft
	radio\bot\two_enemies_left.wav 
	radio\bot\two_to_go.wav 
End

// the bot is telling his team there are three enemies left
Chatter ThreeEnemiesLeft
	radio\bot\three_left.wav 
	radio\bot\three_to_go.wav 
	radio\bot\three_to_go2.wav 
End

// the bot is in trouble and is asking for help
// VOICE NOTE: he's trying to keep it together, but he is mortally frightened
Chatter Help
	Radio EVENT_RADIO_TAKING_FIRE

	radio\bot\taking_fire_need_assistance2.wav 
	radio\bot\i_could_use_some_help.wav 
	radio\bot\i_could_use_some_help_over_here.wav 
	radio\bot\help.wav 
	radio\bot\need_help.wav 
	radio\bot\need_help2.wav 
	radio\bot\im_in_trouble.wav 
End

// the bot is agreeing with the last radio command
Chatter Affirmative
	Radio EVENT_RADIO_AFFIRMATIVE

	Important

	radio\bot\affirmative.wav 
	radio\bot\roger.wav 
	radio\bot\roger_that.wav 
End

// the bot has declined the last radio command
Chatter Negative
	Radio EVENT_RADIO_NEGATIVE

	Important

	radio\bot\ahh_negative.wav 
	radio\bot\negative.wav 
	radio\bot\negative2.wav 
	radio\bot\no.wav
	radio\bot\nnno_sir.wav
	radio\bot\no_sir.wav
End

//-----------------------------------------------------------------------------------------
//
// Bomb defuse scenario chatter
//

// the (CT) bot has checked a bombsite and not found the bomb - he tells his teammates that site is clear
Chatter BombsiteClear
	Radio EVENT_RADIO_SECTOR_CLEAR

	Important

	radio\bot\clear.wav 
	radio\bot\clear2.wav 
	radio\bot\clear3.wav 
	radio\bot\area_clear.wav 
	radio\bot\nothing.wav 
	radio\bot\nothing_here.wav 
End

// the (CT) bot has begun defusing the bomb
Chatter DefusingBomb
	Radio EVENT_RADIO_COVER_ME

	Important

	radio\bot\defusing.wav 
	radio\bot\defusing_bomb.wav 
	radio\bot\defusing_bomb_now.wav
End

// the (CT) bot is announcing his intention to guard the dropped bomb
Chatter GoingToGuardLooseBomb
	radio\bot\im_going_to_guard_the_bomb.wav
	radio\bot\im_going_to_guard_the_bomb2.wav
	radio\bot\im_going_to_keep_an_eye_on_the_bomb.wav
	radio\bot\im_going_to_watch_the_bomb.wav
End

// the (CT) bot it telling his team that he is guarding the dropped bomb
Chatter GuardingLooseBomb
	Radio EVENT_RADIO_IN_POSITION

	Important

	radio\bot\guarding_the_dropped_bomb.wav
	radio\bot\ive_got_the_bomb.wav
	radio\bot\ive_got_the_bomb_here.wav
	radio\bot\the_bombs_here.wav
	radio\bot\the_bombs_here_on_the_ground.wav
End

// the (Terrorist) bot is planting the bomb
Chatter PlantingBomb
	Radio EVENT_RADIO_COVER_ME

	Important

	// for maps with no places, and also to be occasionally vague about where we're planting
	Place ANY
		radio\bot\planting_the_bomb.wav
		radio\bot\planting.wav

	Place BombsiteA
		radio\bot\planting_at_a.wav

	Place BombsiteB
		radio\bot\planting_at_b.wav

	Place BombsiteC
		radio\bot\planting_at_c.wav
End

// the (Terrorist) bot is announcing his intention to plant the bomb at a specific bomb site
Chatter GoingToPlantBomb
	Radio EVENT_RADIO_FOLLOW_ME

	Important

	// for maps with no places, and to be vague occasionally
	Place ANY
		radio\bot\im_gonna_go_plant.wav
		radio\bot\im_gonna_go_plant_the_bomb.wav

	Place BombsiteA
		radio\bot\im_gonna_plant_the_bomb_at_a.wav
		radio\bot\taking_the_bomb_to_a.wav

	Place BombsiteB
		radio\bot\going_to_plant_the_bomb_at_b.wav
		radio\bot\im_gonna_plant_the_bomb_at_b.wav
		radio\bot\taking_the_bomb_to_b.wav

	Place BombsiteC
		radio\bot\im_gonna_plant_the_bomb_at_c.wav
		radio\bot\im_gonna_plant_the_bomb_at_c2.wav
		radio\bot\taking_the_bomb_to_c.wav
End

// the (CT) bot has spotted the bomb carrier
// VOICE NOTE: Intensity/determination/anger
Chatter SpottedBomber
	Radio EVENT_RADIO_ENEMY_SPOTTED

	Important

	radio\bot\i_see_the_bomber.wav
	radio\bot\theres_the_bomber.wav
	radio\bot\hes_got_the_bomb.wav
	radio\bot\hes_got_the_bomb2.wav
	radio\bot\hes_got_the_package.wav
	radio\bot\spotted_the_delivery_boy.wav
End

// the bot has spotted a dropped bomb on the ground
Chatter SpottedLooseBomb
	Important

	radio\bot\bombs_on_the_ground.wav
	radio\bot\bombs_on_the_ground_here.wav
	radio\bot\the_bomb_is_down.wav
	radio\bot\the_bomb_is_on_the_ground.wav
	radio\bot\they_dropped_the_bomb.wav
End

// the (CT) bot heard a Terrorist pick up the dropped bomb
// VOICE NOTE: Anxiety/urgency
Chatter TheyPickedUpTheBomb
	Important

	radio\bot\they_took_the_bomb.wav
	radio\bot\they_took_the_bomb2.wav
	radio\bot\they_got_the_bomb.wav
	radio\bot\they_picked_up_the_bomb.wav
End

// the (CT) bot has found the location of the ticking bomb
Chatter PlantedBombPlace
	Radio EVENT_RADIO_NEED_BACKUP

	Important

	// for maps with no places
	Place UNDEFINED
		radio\bot\theres_the_bomb.wav
		radio\bot\theres_the_bomb2.wav

	Place BombsiteA
		radio\bot\the_bombs_at_a.wav
		//radio\bot\they_planted_at_a.wav		(can't use these, because T's respond with this as well)
		radio\bot\the_bombs_ticking_at_a.wav

	Place BombsiteB
		radio\bot\the_bombs_at_b.wav
		//radio\bot\they_planted_at_b.wav
		radio\bot\the_bombs_ticking_at_b.wav

	Place BombsiteC
		radio\bot\the_bombs_at_c.wav
		//radio\bot\they_planted_at_c.wav
		radio\bot\the_bombs_ticking_at_c.wav
End

// the bot is asking his teammates where the bomb is
Chatter WhereIsTheBomb
	Important

	radio\bot\wheres_the_bomb.wav
	radio\bot\wheres_the_bomb2.wav
	radio\bot\wheres_the_bomb3.wav
	radio\bot\where_is_it.wav
End

// the (CT) bot is announcing his intention to guard a bombsite
Chatter GoingToDefendBombsite
	Important

	// for maps with no places, or we're just being vague
	Place ANY
		radio\bot\im_going_to_camp.wav

	Place BombsiteA
		radio\bot\im_going_to_guard_bombsite_a.wav
		radio\bot\im_going_to_camp_a.wav

	Place BombsiteB
		radio\bot\im_going_to_guard_bombsite_b.wav
		radio\bot\im_going_to_camp_b.wav

	Place BombsiteC
		radio\bot\im_going_to_guard_bombsite_c.wav
		radio\bot\im_going_to_camp_c.wav
End

// the (CT) bot is announcing that he is currently guarding a bombsite
Chatter DefendingBombsite
	Important

	// for maps with no places
	Place UNDEFINED
		radio\bot\bombsite.wav
		radio\bot\bombsite2.wav

	Place BombsiteA
		radio\bot\i_got_a_covered.wav
		radio\bot\guarding_a.wav
		radio\bot\im_camping_a.wav
		radio\bot\heading_to_a.wav

	Place BombsiteB
		radio\bot\i_got_b_covered.wav
		radio\bot\guarding_b.wav
		radio\bot\im_camping_b.wav
		radio\bot\heading_to_b.wav

	Place BombsiteC
		radio\bot\i_got_c_covered.wav
		radio\bot\guarding_c.wav
		radio\bot\im_camping_c.wav
		radio\bot\heading_to_c.wav
End

// the (CT) bot is announcing that the bombsite is secure and ready for someone to defuse the bomb
Chatter BombsiteSecure
	Radio EVENT_RADIO_SECTOR_CLEAR

	Important

	radio\bot\bombsite_secure.wav
	radio\bot\bombsite_secured.wav
	radio\bot\bombsite_under_control.wav
	radio\bot\weve_got_the_situation.wav
End

// the (CT) bot is encouraging the player to defuse the bomb
Chatter WaitingForHumanToDefuseBomb
	radio\bot\its_all_up_to_you_sir.wav
	radio\bot\bombsite_secure_ready_for_you.wav
	radio\bot\well_cover_you_while_you_defuse.wav
	radio\bot\well_cover_you_you_defuse.wav
End

// the (CT) bot is anxiously encouraging the player to defuse the bomb
// VOICE NOTE: Very nervous/anxious/worried
Chatter WaitingForHumanToDefuseBombPanic
	radio\bot\we_need_you_to_defuse_that_bomb_sir.wav
	radio\bot\dont_worry_hell_get_it.wav
	radio\bot\please_defuse_the_bomb_sir.wav
	radio\bot\sir_defuse_the_bomb.wav
	radio\bot\time_is_running_out.wav
	radio\bot\time_is_running_out2.wav
	radio\bot\uh_sir_the_bomb.wav
End

// when the bomb was defused with less than 2 seconds left
// VOICE NOTE: Relief/happy
Chatter BarelyDefused
	radio\bot\i_wasnt_worried_for_a_minute.wav
	radio\bot\that_was_a_close_one.wav
	radio\bot\well_done.wav
	radio\bot\whew_that_was_close.wav
End


//-----------------------------------------------------------------------------------------
//
// Hostage Rescue chatter
//

// the (Terrorist) bot is announcing his intention to guard the hostages
Chatter GoingToGuardHostages
	Important

	radio\bot\camping_hostages.wav
	radio\bot\im_going_to_camp_the_hostages.wav
	radio\bot\im_going_to_guard_the_hostages.wav
	radio\bot\im_going_to_guard_the_hostages2.wav
End

// the (Terrorist) bot is currently guarding some hostages
Chatter GuardingHostages
	Important

	radio\bot\keeping_an_eye_on_the_hostages.wav
	radio\bot\guarding_the_hostages.wav
	radio\bot\guarding_hostages.wav
	radio\bot\watching_the_hostages.wav
	radio\bot\im_with_the_hostages.wav
	radio\bot\im_with_the_hostages2.wav
	radio\bot\im_at_the_hostages.wav
End

// the (Terrorist) bot is announcing his intetion to guard an escape zone
Chatter GoingToGuardHostageEscapeZone
	Important

	radio\bot\im_going_to_cover_the_escape_zone.wav
	radio\bot\im_going_to_watch_the_escape_zone.wav
	radio\bot\im_going_to_keep_an_eye_on_the_escape.wav
	radio\bot\heading_to_the_escape_zone.wav
	radio\bot\heading_to_the_rescue_zone.wav
	radio\bot\im_going_to_keep_an_eye_on_the_rescue.wav
	radio\bot\im_going_to_watch_the_rescue_zone.wav
End

// the (Terrorist) bot is currently guarding an escape zone
Chatter GuardingHostageEscapeZone
	Important

	radio\bot\watching_the_escape_route.wav
	radio\bot\im_at_the_escape_zone.wav
	radio\bot\watching_the_escape_zone.wav
	radio\bot\guarding_the_escape_zone.wav
	radio\bot\guarding_the_escape_zone2.wav
End

// the (Terrorist) bot is telling his friends that the CT's are taking the hostages right now
// VOICE NOTE: Anxiety/frustration/anger
Chatter HostagesBeingTaken
	Radio EVENT_RADIO_NEED_BACKUP

	Important

	radio\bot\theyre_with_the_hostages.wav
	radio\bot\theyre_taking_the_hostages.wav
	radio\bot\theyre_rescuing_the_hostages.wav
	radio\bot\hostages2.wav
End

// the (Terrorist) bot has just discovered that the hostages are gone
// VOICE NOTE: Anxiety/frustration/anger
Chatter HostagesTaken
	Important

	radio\bot\they_took_the_hostages.wav
	radio\bot\theyve_got_the_hostages.wav
	radio\bot\the_hostages_are_gone.wav
End

// the (CT) bot is announcing that he is talking to the hostages
Chatter TalkingToHostages
	Important

	radio\bot\talking_to_hostages.wav
	radio\bot\rescuing_hostages.wav
End

// the (CT) bot is annoucing that he has the hostages and is taking them to the escape zone
Chatter EscortingHostages
	Important

	radio\bot\the_hostages_are_with_me.wav
	radio\bot\taking_the_hostages_to_safety.wav
	radio\bot\ive_got_the_hostages.wav
	radio\bot\i_have_the_hostages.wav
End

// the (CT) bot is guarding the hostages and is encouraging the human player to come rescue them
Chatter WaitingForHumanToRescueHostages
	Radio EVENT_RADIO_SECTOR_CLEAR

	Important

	radio\bot\the_hostages_are_waiting.wav
	radio\bot\hostages_secure_ready_for_you.wav
	radio\bot\the_hostages_are_eager.wav
	radio\bot\the_hostages_are_ready.wav
	radio\bot\weve_got_the_situation.wav
End


//-----------------------------------------------------------------------------------------
//
// VIP Scenario chatter
//

// the (Terrorist) bot has spotted the VIP
// VOICE NOTE: Intensity/anger/determination
Chatter SpottedVIP
	Radio EVENT_RADIO_ENEMY_SPOTTED

	Important

	radio\bot\i_see_our_target.wav
	radio\bot\target_spotted.wav
	radio\bot\target_acquired.wav
End

// the (Terrorist) bot is announcing his intention to guard an escape zone
Chatter GoingToGuardVIPEscapeZone
	Important

	radio\bot\im_going_to_cover_the_escape_zone.wav
	radio\bot\im_going_to_watch_the_escape_zone.wav
	radio\bot\im_going_to_keep_an_eye_on_the_escape.wav
	radio\bot\heading_to_the_escape_zone.wav
End

// the (Terrorist) bot is guarding an escape zone
Chatter GuardingVIPEscapeZone
	Important

	radio\bot\watching_the_escape_route.wav
	radio\bot\im_at_the_escape_zone.wav
	radio\bot\watching_the_escape_zone.wav
	radio\bot\guarding_the_escape_zone.wav
	radio\bot\guarding_the_escape_zone2.wav
End


//-----------------------------------------------------------------------------------------

// the bot was saying something and died in mid-sentance
// VOICE NOTE: death cry
Chatter Pain
	radio\bot\pain2.wav
	radio\bot\pain4.wav
	radio\bot\pain5.wav
	radio\bot\pain8.wav
	radio\bot\pain9.wav
	radio\bot\pain10.wav
End

// the bot is congratulating his team for winning the round
Chatter WonRound
	radio\bot\good_job_team.wav
	radio\bot\nice_work_team.wav
	radio\bot\way_to_be_team.wav
	radio\bot\well_done.wav
End

// the bot is celebrating because his team crushed the enemies very quickly
// VOICE NOTE: Hoots and hollers of excitement, bragging, boasting, etc
Chatter WonRoundQuickly
	radio\bot\i_am_dangerous.wav
	radio\bot\do_not_mess_with_me.wav
	radio\bot\we_owned_them.wav
	radio\bot\they_never_knew_what_hit_them.wav
	radio\bot\thats_the_way_this_is_done.wav
	radio\bot\and_thats_how_its_done.wav
	radio\bot\owned.wav
	radio\bot\yesss.wav
	radio\bot\yesss2.wav
	radio\bot\yea_baby.wav
	radio\bot\whoo.wav
	radio\bot\whoo2.wav
	radio\bot\oh_yea.wav
	radio\bot\oh_yea2.wav
End

// the bot won the round and is the last player alive
// VOICE NOTE: Bragging, boasting, etc
Chatter LastManStanding
	radio\bot\i_am_dangerous.wav
	radio\bot\do_not_mess_with_me.wav
	radio\bot\this_is_my_house.wav
End

// the bot emits a short, exicited noise because he did something especially good
// VOICE NOTE: Hoots and hollers of excitement
Chatter ThrillEmote
	radio\bot\yesss.wav
	radio\bot\yesss2.wav
	radio\bot\yea_baby.wav
	radio\bot\whoo.wav
	radio\bot\whoo2.wav
	radio\bot\oh_yea.wav
	radio\bot\oh_yea2.wav
End

// the bot is afraid (usually because he is outnumbered by enemies)
// VOICE NOTE: Worry/anxiety/fear
Chatter ScaredEmote
	radio\bot\whoa.wav
	radio\bot\uh_oh.wav
	radio\bot\oh_no.wav
	radio\bot\yikes.wav
	radio\bot\oh.wav
	radio\bot\oh_boy.wav
	radio\bot\oh_boy2.wav
	radio\bot\aah.wav
End

// the bot is agreeing with a plan someone else announced
Chatter AgreeWithPlan
	Important

	radio\bot\me_too.wav
	radio\bot\ill_come_with_you.wav
	radio\bot\ill_go_with_you.wav
	radio\bot\ill_go_too.wav
	radio\bot\i_got_your_back.wav
	radio\bot\i_got_your_back2.wav
	radio\bot\im_with_you.wav
	radio\bot\sounds_like_a_plan.wav
	radio\bot\good_idea.wav
End

// the bot is telling a friend that he will "cover them" and watch their back
Chatter CoveringFriend
	Radio EVENT_RADIO_AFFIRMATIVE

	Important

	radio\bot\i_got_your_back.wav
	radio\bot\i_got_your_back2.wav
	radio\bot\im_with_you.wav
End

// the bot is responding to someone's request for help
// VOICE NOTE: Confident/assuring
Chatter OnMyWay
	Radio EVENT_RADIO_AFFIRMATIVE

	Important

	radio\bot\on_my_way.wav
	radio\bot\on_my_way2.wav
	radio\bot\im_coming.wav
	radio\bot\hang_on_im_coming.wav
	radio\bot\be_right_there.wav
End

// the bot has decided to hide for a little while, instead of seeking out the enemy
// VOICE NOTE: Anxiety/worry/cowardice
Chatter WaitingHere
	radio\bot\lets_wait_here.wav
	radio\bot\lets_hold_up_here_for_a_minute.wav
	radio\bot\im_gonna_hang_back.wav
	radio\bot\im_going_to_wait_here.wav
	radio\bot\im_waiting_here.wav
End

// the bot has been in combat for a long time, and can't get away
// VOICE NOTE: Anxiety/worry/fear
Chatter PinnedDown
	Radio EVENT_RADIO_NEED_BACKUP

	radio\bot\they_got_me_pinned_down_here.wav
	radio\bot\im_pinned_down.wav
End

// the bot heard an enemy noise
// VOICE NOTE: Said as an undertone/afterthought
Chatter HeardNoise
	radio\bot\i_hear_them.wav
	radio\bot\hang_on_i_heard_something.wav
	radio\bot\i_hear_something.wav
	radio\bot\i_heard_them.wav
	radio\bot\i_heard_something_over_there.wav
End

// the bot has been blinded by a Flashbang Grenade
// VOICE NOTE: Surprise/shock/fear/anxiety
Chatter Blinded
	radio\bot\ive_been_blinded.wav
	radio\bot\my_eyes.wav
	radio\bot\i_cant_see.wav
	radio\bot\im_blind.wav
End

// the bot is congratulating a friend on a well placed shot
// VOICE NOTE: upbeat/supportive/impressed
Chatter NiceShot
	radio\bot\good_one.wav
	radio\bot\good_one2.wav
	radio\bot\nice_shot.wav
	radio\bot\nice_shot2.wav
	radio\bot\good_shot.wav
	radio\bot\good_shot2.wav
	radio\bot\nice.wav
	radio\bot\nice2.wav
	radio\bot\very_nice.wav
End

// the bot is congratulating a human player on a well placed shot
// VOICE NOTE: upbeat/supportive/impressed
Chatter NiceShotSir
	radio\bot\good_one_sir.wav
	radio\bot\good_one_sir2.wav
	radio\bot\nice_shot_sir.wav
	radio\bot\nice_one_sir.wav
End

// the bot is congratulating the "commander" in the solo game
// VOICE NOTE: upbeat/supportive/impressed
Chatter NiceShotCommander
	radio\bot\nice_shot_commander.wav
	radio\bot\nice_shot_commander2.wav
	radio\bot\good_shot_commander.wav
	radio\bot\good_shot_commander2.wav
	radio\bot\nice_one_commander.wav
	radio\bot\good_one_sir.wav
	radio\bot\good_one_sir2.wav
	radio\bot\nice_shot_sir.wav
	radio\bot\nice_one_sir.wav
End

// when the player dies in the solo game
// VOICE NOTE: Intense/worry/anxiety
Chatter CommanderDown
	Radio EVENT_RADIO_REGROUP_TEAM

	Important

	radio\bot\the_commander_is_down_repeat.wav
	radio\bot\the_commander_is_down.wav
	radio\bot\weve_lost_the_commander.wav
End

// the bot has decided to follow a human player
Chatter FollowingSir
	Radio EVENT_RADIO_AFFIRMATIVE

	Important

	radio\bot\lead_on_sir.wav
	radio\bot\lead_the_way_sir.wav
	radio\bot\lead_the_way.wav
	radio\bot\ok_sir_lets_go.wav
End

// the bot has decided to follow the human player in the solo game
Chatter FollowingCommander
	Radio EVENT_RADIO_AFFIRMATIVE

	Important

	radio\bot\lead_on_sir.wav
	radio\bot\lead_the_way_sir.wav
	radio\bot\lead_the_way.wav
	radio\bot\ok_sir_lets_go.wav
	radio\bot\lead_on_commander.wav
	radio\bot\lead_the_way_commander.wav
	radio\bot\ok_cmdr_lets_go.wav
End

// the bot is expressing its shock that a friend has killed another friend (friendly fire)
// VOICE NOTE: Grief/sadness/worry/astonishment
Chatter KilledFriend
	radio\bot\what_happened.wav
	radio\bot\noo.wav
	radio\bot\oh_my_god.wav
	radio\bot\oh_man.wav
	radio\bot\oh_no_sad.wav
	radio\bot\what_have_you_done.wav
End

// the bot is crying out because he was injured by friendly fire
// VOICE NOTE: Pain/anger/frustration
Chatter FriendlyFire
	Important

	radio\bot\cut_it_out.wav
	radio\bot\what_are_you_doing.wav
	radio\bot\stop_it.wav
	radio\bot\ow_its_me.wav
	radio\bot\ow.wav
	radio\bot\ouch.wav
	radio\bot\im_on_your_side.wav
	radio\bot\hold_your_fire.wav
	radio\bot\hey.wav
	radio\bot\hey2.wav
	radio\bot\ouch.wav
	radio\bot\ouch.wav
	radio\bot\ouch.wav
End



//---------------------------------------------------------------------------------------
//
// The items below are not used (yet)
//

Chatter PepTalk
	radio\bot\alright_lets_do_this.wav
	radio\bot\tag_them_and_bag_them.wav
	radio\bot\you_heard_the_man_lets_go.wav
End

Chatter OnARollBrag
	radio\bot\i_got_more_where_that_came_from.wav
	radio\bot\who_wants_some_more.wav
	radio\bot\i_am_on_fire.wav
	radio\bot\look_out_brag.wav
	radio\bot\thats_right.wav
	radio\bot\whos_the_man.wav
End

Chatter TauntCamper
	radio\bot\come_out_wherever_you_are.wav
	radio\bot\where_are_you_hiding.wav
	radio\bot\come_out_and_fight_like_a_man.wav
	radio\bot\come_to_papa.wav
End

Chatter PreventEscapeBrag
	radio\bot\they_wont_get_away.wav
	radio\bot\they_wont_get_away2.wav
	radio\bot\they_will_not_escape.wav
End

Chatter SniperWarning
	radio\bot\sniper.wav
	radio\bot\sniper2.wav
	radio\bot\watch_it_theres_a_sniper.wav
End

Chatter SniperKilled
	radio\bot\got_the_sniper.wav
	radio\bot\got_the_sniper2.wav
	radio\bot\sniper_down.wav
	radio\bot\took_out_the_sniper.wav
	radio\bot\the_sniper_is_dead.wav
End

// we saw enemies, but now they're all dead
Chatter ClearedArea
	radio\bot\area_secure.wav 
	radio\bot\neutralized.wav 
End

Chatter Agree
	radio\bot\ok.wav
	radio\bot\ok2.wav
	radio\bot\alright.wav
	radio\bot\alright2.wav
	radio\bot\yea_ok.wav
End

Chatter Disagree
	radio\bot\no2.wav
	radio\bot\i_dont_think_so.wav
	radio\bot\naa.wav
	radio\bot\no_thanks.wav
End

Chatter CoverMe
	radio\bot\cover_me.wav 
	radio\bot\cover_me2.wav 
End

Chatter FrustrationEmote
	radio\bot\aw_hell.wav
	radio\bot\great.wav
	radio\bot\aww_man.wav
	radio\bot\thats_not_good.wav
End

Chatter FollowingFriend
	radio\bot\ill_come_with_you.wav
	radio\bot\ill_go_with_you.wav
	radio\bot\ill_go_too.wav
	radio\bot\i_got_your_back.wav
	radio\bot\i_got_your_back2.wav
	radio\bot\im_with_you.wav
End

Chatter ReportingIn
	radio\bot\reporting_in.wav 
End

Chatter BombTickingDown
	radio\bot\we_gotta_find_that_bomb.wav
	radio\bot\time_is_running_out.wav
	radio\bot\theres_not_much_time_left.wav
End

Chatter HostageDown
	radio\bot\hostage_down.wav
End

Chatter RequestHostageLocation
	radio\bot\where_are_the_hostages.wav
End

Chatter MeToo
	radio\bot\me_too.wav
End



```

`3rdparty/cs16client-extras/BotProfile.db`:

```db
//----------------------------------------------------------------------------
// BotProfile.db
// Author: Michael S. Booth, Turtle Rock Studios (www.turtlerockstudios.com)
//
// This database defines bot "personalities". 
// Feel free to edit it and define your own bots.
//


//----------------------------------------------------------------------------

//
// All profiles begin with this data and overwrite their own
//
Default
	Skill = 50
	Aggression = 50
	ReactionTime = 0.3
	AttackDelay = 0
	Teamwork = 75
	WeaponPreference = none
	Cost = 0
	Difficulty = NORMAL
	VoicePitch = 100
	Skin = 0
End

//----------------------------------------------------------------------------

//
// These templates inherit from Default and override with their values
// The name of the template defines a type that is used by individual bot profiles
//

// weapon preference templates
Template Rifle
	WeaponPreference = m4a1
	WeaponPreference = ak47
	WeaponPreference = famas
	WeaponPreference = galil
	WeaponPreference = mp5
End

Template RifleT
	WeaponPreference = ak47
	WeaponPreference = m4a1
	WeaponPreference = galil
	WeaponPreference = famas
	WeaponPreference = mp5
End

Template Punch
	WeaponPreference = aug
	WeaponPreference = sg552
	WeaponPreference = famas
	WeaponPreference = galil
	WeaponPreference = mp5
End

Template PunchT
	WeaponPreference = aug
	WeaponPreference = sg552
	WeaponPreference = famas
	WeaponPreference = galil
	WeaponPreference = mp5
End

Template Sniper
	WeaponPreference = awp
	WeaponPreference = sg550
	WeaponPreference = g3sg1
	WeaponPreference = scout
	WeaponPreference = famas
	WeaponPreference = galil
	WeaponPreference = mp5
End

Template Power
	WeaponPreference = m249
	WeaponPreference = xm1014
	WeaponPreference = m3
	WeaponPreference = famas
	WeaponPreference = galil
	WeaponPreference = mp5
End

Template Shotgun
	WeaponPreference = xm1014
	WeaponPreference = m3
	WeaponPreference = famas
	WeaponPreference = galil
	WeaponPreference = mp5
End

Template Shield
	WeaponPreference = shield
	WeaponPreference = m4a1			// in case shield is disallowed
	WeaponPreference = ak47
	WeaponPreference = famas
	WeaponPreference = galil
	WeaponPreference = mp5
End

Template Spray
	WeaponPreference = p90
	WeaponPreference = tmp
	WeaponPreference = mac10
	WeaponPreference = mp5
End


// skill templates
Template Elite
	Skill = 100
	Aggression = 100
	ReactionTime = 0.2
	Cost = 4
	Difficulty = EXPERT
	VoicePitch = 85
End

Template Expert
	Skill = 90
	Aggression = 90
	ReactionTime = 0.2
	Cost = 4
	Difficulty = EXPERT
	VoicePitch = 88
End

Template VeryHard
	Skill = 80
	Aggression = 80
	ReactionTime = 0.25
	Cost = 3
	Difficulty = HARD
	VoicePitch = 92
End

Template Hard
	Skill = 75
	Aggression = 75
	ReactionTime = 0.25
	Cost = 3
	Difficulty = HARD
	VoicePitch = 94
End

Template Tough
	Skill = 60
	Aggression = 60
	ReactionTime = 0.3
	AttackDelay = 0.35
	Cost = 2
	Difficulty = NORMAL+HARD
	VoicePitch = 96
End

Template Normal
	Skill = 50
	Aggression = 50
	ReactionTime = 0.4
	AttackDelay = 0.7
	Cost = 2
	Difficulty = NORMAL
End

Template Fair
	Skill = 25
	Aggression = 30
	ReactionTime = 0.4
	AttackDelay = 1.0
	Cost = 1
	Difficulty = EASY+NORMAL
	VoicePitch = 105
End

Template Easy
	Skill = 0
	Aggression = 20
	ReactionTime = 0.5
	AttackDelay = 1.5
	Cost = 1
	Difficulty = EASY
	VoicePitch = 110
End

//----------------------------------------------------------------------------
//
// These are the individual bot profiles, which inherit first from 
// Default and then the specified Template(s), in order
//

Elite+Rifle Cliffe
	Skin = 1
	VoicePitch = 95
End

Elite+Spray Minh
	Skin = 2
	VoicePitch = 105
End

Elite+Shotgun Crusher
	Skin = 4
	VoicePitch = 84
End

Elite+Punch Pheonix
	Skin = 4
	VoicePitch = 110
End

Elite+Power Rock
	Skin = 2
	VoicePitch = 80
End

Elite+PunchT Shark
	Skin = 4
	VoicePitch = 90
End

Elite+Rifle Wolf
	Skin = 2
	VoicePitch = 98
End

Elite+RifleT Gunner
	Skin = 1
	VoicePitch = 96
End

Elite+Sniper Zed
	Skin = 3
	VoicePitch = 105
End

Elite+RifleT Steel
	Skin = 1
	VoicePitch = 84
End

Elite+PunchT Stone
	Skin = 4
	VoicePitch = 86
End


//----------------------------------------

Expert+RifleT Arnold
	VoicePitch = 85
End

Expert+Rifle Brett
	VoicePitch = 100
End

Expert+Punch Kurt
	VoicePitch = 95
End

Expert+Sniper Kyle
	Cost = 5
	VoicePitch = 115
End

Expert+Shotgun Moe
	VoicePitch = 87
End

Expert+Rifle Quade
	VoicePitch = 91
End

Expert+Rifle Quintin
	VoicePitch = 101
End

Expert Ringo
	VoicePitch = 112
End

Expert+PunchT Rip
	VoicePitch = 99
End

Expert+Rifle Zach
	VoicePitch = 100
End

//----------------------------------------

VeryHard+Power Cory
	Skin = 1
	VoicePitch = 110
End

VeryHard+Sniper Quinn
	Skin = 3
	VoicePitch = 93
End

VeryHard+Rifle Seth
	Skin = 2
	VoicePitch = 100
End

VeryHard+RifleT Vinny
	Skin = 4
	VoicePitch = 86
End


//----------------------------------------

Hard+Rifle Chad
	Skin = 1
	VoicePitch = 95
End

Hard+RifleT Chet
	Skin = 2
	VoicePitch = 90
End

Hard+Spray Gabe
	Skin = 4
	VoicePitch = 102
End

Hard+Shotgun Hank
	Skin = 1
	VoicePitch = 98
End

Hard+RifleT Ivan
	Skin = 2
	VoicePitch = 96
End

Hard+Punch Jim
	Skin = 4
	VoicePitch = 103
End

Hard+PunchT Joe
	Skin = 1
	VoicePitch = 105
End

Hard+Rifle John
	Skin = 2
	VoicePitch = 97
End

Hard+Rifle Tony
	Skin = 4
	VoicePitch = 84
End

Hard+PunchT Tyler
	Skin = 1
	VoicePitch = 90
End

Hard+Rifle Victor
	Skin = 2
	VoicePitch = 98
End

Hard+Sniper Vladimir
	Skin = 3
	VoicePitch = 110
End

Hard+Spray Zane
	Skin = 4
	VoicePitch = 103
End

Hard+Rifle Zim
	Skin = 2
	VoicePitch = 110
End

//----------------------------------------

Tough+Sniper Adrian
	Skin = 3
	VoicePitch = 120
End

Tough+Rifle Brad
	Skin = 1
	VoicePitch = 100
End

Tough+Rifle Connor
	Skin = 2
	VoicePitch = 104
End

Tough+RifleT Dave
	Skin = 4
	VoicePitch = 98
End

Tough Dan
	Skin = 1
	VoicePitch = 100
End

Tough+Rifle Derek
	Skin = 2
	VoicePitch = 102
End

Tough+Shotgun Don
	Skin = 4
	VoicePitch = 95
End

Tough+Rifle Eric
	Skin = 1
	VoicePitch = 95
End

Tough+RifleT Erik
	Skin = 2
	VoicePitch = 110
End

Tough+Rifle Finn
	Skin = 4
	VoicePitch = 112
End

Tough Jeff
	Skin = 1
	VoicePitch = 90
End

Tough+Rifle Kevin
	Skin = 2
	VoicePitch = 115
End

Tough+RifleT Reed
	Skin = 4
	VoicePitch = 107
End

Tough+Rifle Rick
	Skin = 2
	VoicePitch = 102
End

Tough Ted
	Skin = 1
	VoicePitch = 98
End

Tough+Rifle Troy
	Skin = 2
	VoicePitch = 100
End

Tough+RifleT Wade
	Skin = 4
	VoicePitch = 95
End

Tough+Rifle Wayne
	Skin = 1
	VoicePitch = 86
End

Tough+RifleT Xander
	Skin = 2
	VoicePitch = 100
End

Tough+Rifle Xavier
	Skin = 4
	VoicePitch = 95
End

//----------------------------------------

Normal+Rifle Adam
	Skin = 1
	VoicePitch = 105
End

Normal+PunchT Andy
	Skin = 2
	VoicePitch = 90
End

Normal Chris
	Skin = 3
	VoicePitch = 100
End

Normal Colin
	Skin = 4
	VoicePitch = 107
End

Normal+Shield Dennis
	Skin = 1
	VoicePitch = 104
End

Normal Doug
	Skin = 2
	VoicePitch = 110
End

Normal Gary
	Skin = 3
	VoicePitch = 95
End

Normal Grant
	Skin = 4
	VoicePitch = 112
End

Normal Greg
	Skin = 1
	VoicePitch = 111
End

Normal+Sniper Ian
	Skin = 3
	VoicePitch = 115
End

Normal Jerry
	Skin = 4
	VoicePitch = 112
End

Normal Jon
	Skin = 1
	VoicePitch = 96
End

Normal Keith
	Skin = 2
	VoicePitch = 98
End

Normal Mark
	Skin = 4
	VoicePitch = 110
End

Normal Matt
	Skin = 1
	VoicePitch = 95
End

Normal+RifleT Mike
	Skin = 2
	VoicePitch = 100
End

Normal Nate
	Skin = 4
	VoicePitch = 99
End

Normal Paul
	Skin = 3
	VoicePitch = 98
End

Normal Scott
	Skin = 1
	VoicePitch = 105
End

Normal Steve
	Skin = 2
	VoicePitch = 115
End

Normal Tom
	Skin = 3
	VoicePitch = 110
End

Normal Yahn
	Skin = 4
	VoicePitch = 92
End

//----------------------------------------

Fair Alfred
	VoicePitch = 110
End

Fair Bill
	VoicePitch = 100
End

Fair Brandon
	VoicePitch = 99
End

Fair+Spray Calvin
	VoicePitch = 120
End

Fair Dean
	VoicePitch = 111
End

Fair Dustin
	VoicePitch = 98
End

Fair Ethan
	VoicePitch = 112
End

Fair Harold
	VoicePitch = 90
End

Fair Henry
	VoicePitch = 120
End

Fair Irving
	VoicePitch = 118
End

Fair Jason
	VoicePitch = 116
End

Fair Josh
	VoicePitch = 114
End

Fair Martin
	VoicePitch = 110
End

Fair Nick
	VoicePitch = 98
End

Fair Norm
	VoicePitch = 92
End

Fair Orin
	VoicePitch = 113
End

Fair Pat
	VoicePitch = 114
End

Fair Perry
	VoicePitch = 115
End

Fair Ron
	VoicePitch = 100
End

Fair Shawn
	VoicePitch = 102
End

Fair Tim
	VoicePitch = 98
End

Fair Will
	VoicePitch = 96
End

Fair Wyatt
	VoicePitch = 94
End

//----------------------------------------

Easy Albert
	VoicePitch = 100
End

Easy Allen
	VoicePitch = 110
End

Easy Bert
	VoicePitch = 120
End

Easy Bob
	VoicePitch = 99
End

Easy Cecil
	VoicePitch = 120
End

Easy Clarence
	VoicePitch = 125
End

Easy Elliot
	VoicePitch = 110
End

Easy Elmer
	VoicePitch = 100
End

Easy Ernie
	VoicePitch = 112
End

Easy Eugene
	VoicePitch = 121
End

Easy Fergus
	VoicePitch = 99
End

Easy Ferris
	VoicePitch = 119
End

Easy Frank
	VoicePitch = 118
End

Easy Frasier
	VoicePitch = 117
End

Easy Fred
	VoicePitch = 116
End

Easy George
	VoicePitch = 115
End

Easy Graham
	VoicePitch = 114
End

Easy Harvey
	VoicePitch = 112
End

Easy Irwin
	VoicePitch = 111
End

Easy Lester
	VoicePitch = 110
End

Easy Marvin
	VoicePitch = 109
End

Easy Neil
	VoicePitch = 108
End

Easy Niles
	VoicePitch = 122
End

Easy Oliver
	VoicePitch = 120
End

Easy Opie
	VoicePitch = 125
End

Easy Toby
	VoicePitch = 92
End

Easy Ulric
	VoicePitch = 100
End

Easy Ulysses
	VoicePitch = 102
End

Easy Uri
	VoicePitch = 104
End

Easy Waldo
	VoicePitch = 108
End

Easy Wally
	VoicePitch = 95
End

Easy Walt
	VoicePitch = 100
End

Easy Wesley
	VoicePitch = 120
End

Easy Yanni
	VoicePitch = 112
End

Easy Yogi
	VoicePitch = 99
End

Easy Yuri
	VoicePitch = 110
End

```

`3rdparty/cs16client-extras/gfx/shell/strings.lst`:

```lst
189	" "
190	"Learn how to play Counter-Strike, be prepared for the real battles."
191	"Load to a saved place in the training mission."
192	"Save your place in the training mission, or load a past save."
193	"Change Counter-Strike's video, audio, and control settings."
194	"Read Half-Life's readme.txt."
196	"Quit Counter-Strike."
198	"Get online and play Counter-Strike with others from around the world."
323	"Disable graphic visuals. If this is turned on, Counter-Strike will not be playable."
324	"Download the latest version of Half-Life: Counter-Strike."
398	"If the server allows it, this option will help you aim at enemies."
391	"Check this box and enter password to disable visuals inappropriate for younger players and multiplayer.  Anyone wishing to change this setting will need to use this password. IMPORTANT NOTE:  If this is turned on, Counter-Strike will not be playable."
400	"Read the official Counter-Strike Manual, learn how to play."
402	"cstrike\manual\manual.htm"
416	"Visit Counter-Strike.net"
417	"www.counter-strike.net"
426	"Get the latest updates, official news, and see the entire CS Network!"
503	"Disabled."
530	"Play/download other mods, or go back to Half-Life."
```

`3rdparty/cs16client-extras/touch.cfg`:

```cfg
//=======================================================================
//	Copyright SDLash3D team & XashXT group 2016 ©
//			touchscreen config
//=======================================================================

touch_config_file "touch_profiles/phone_ahsim.cfg"

// touch cvars

// _move sensitivity settings
touch_forwardzone "0.124444"
touch_sidezone "0.070000"

// _look sensitivity settings
touch_pitch "50.000000"
touch_yaw "50.000000"

// grid settings
touch_grid_count "50"
touch_grid_enable "1"

// global overstroke (width, r, g, b, a)
touch_set_stroke 1 156 77 20 200

// highlight when pressed
touch_highlight_r "1.000000"
touch_highlight_g "0.500000"
touch_highlight_b "1.000000"
touch_highlight_a "1.000000"

// _joy and _dpad options
touch_dpad_radius "1.000000"
touch_joy_radius "1.000000"

// how much slowdown when Precise Look button pressed
touch_precise_amount "0.500000"

// enable/disable move indicator
touch_move_indicator "3"

// reset menu state when execing config
touch_setclientonly 0

// touch buttons
touch_removeall
touch_addbutton "move" "" "_move" 0.000000 0.106667 0.500000 0.995556 255 255 255 150 0
touch_addbutton "look" "" "_look" 0.500000 0.106667 1.000000 0.995556 255 255 255 150 0
touch_addbutton "jump" "touch/gfx/jump" "+jump" 0.900000 0.142222 1.000000 0.320000 255 255 255 150 0 1
touch_addbutton "walk" "touch/gfx/walk" "+speed" 0.080000 0.782222 0.180000 0.960000 255 255 255 150 0 1
touch_addbutton "score" "touch/gfx/score" "scoreboard" 0.920000 0.000000 1.000000 0.142222 255 255 255 150 0 1
touch_addbutton "attack2" "touch/gfx/attack2" "+attack2" 0.780000 0.177778 0.860000 0.320000 255 255 255 150 0 1
touch_addbutton "use" "touch/gfx/use" "+use" 0.920000 0.355556 1.000000 0.497778 255 255 255 150 0 1
touch_addbutton "reload" "touch/gfx/reload" "+reload" 0.000000 0.533333 0.100000 0.711111 255 255 255 150 0 1
touch_addbutton "say" "touch/gfx/chat_all" "touch_hide say;touch_hide say2;messagemode" 0.080000 0.248889 0.140000 0.355556 255 255 255 150 1 1
touch_addbutton "say2" "touch/gfx/chat_team" "touch_hide say;touch_hide say2;messagemode2" 0.160000 0.248889 0.220000 0.355556 255 255 255 150 1 1
touch_addbutton "change_team" "touch/gfx/change_team" "chooseteam" 0.000000 0.817778 0.060000 0.924444 255 255 255 150 0 1
touch_addbutton "flight" "touch/gfx/flaghtlight" "impulse 100" 0.740000 0.000000 0.800000 0.106667 255 255 255 150 1 1
touch_addbutton "plus_nvg" "touch/gfx/plus" "nvgadjustup" 0.700000 0.106667 0.760000 0.213333 255 255 255 150 1 1
touch_addbutton "minus_nvg" "touch/gfx/minus" "nvgadjustdown" 0.620000 0.106667 0.680000 0.213333 255 255 255 150 1 1
touch_addbutton "nightvision" "touch/gfx/nightvision" "nightvision;toggle_plusminus" 0.660000 0.000000 0.720000 0.106667 255 255 255 150 1 1
touch_addbutton "w1" "touch/gfx/w_rifle" "slot1" 0.100000 0.000000 0.160000 0.106667 255 255 255 150 0 1
touch_addbutton "w2" "touch/gfx/w_pistol" "slot2" 0.180000 0.000000 0.240000 0.106667 255 255 255 150 0 1
touch_addbutton "w3" "touch/gfx/w_knife" "slot3" 0.260000 0.000000 0.320000 0.106667 255 255 255 150 0 1
touch_addbutton "w4" "touch/gfx/w_grenade" "slot4" 0.100000 0.142222 0.160000 0.248889 255 255 255 150 0 1
touch_addbutton "w5" "touch/gfx/w_c4" "slot5" 0.180000 0.142222 0.240000 0.248889 255 255 255 150 0 1
touch_addbutton "buy" "touch/gfx/buy" "buy" 0.460000 0.853333 0.540000 0.995556 255 255 255 150 0 1
touch_addbutton "drop" "touch/gfx/drop" "drop" 0.380000 0.000000 0.440000 0.106667 255 255 255 150 0 1
touch_addbutton "light" "touch/gfx/light" "toggle_light" 0.580000 0.000000 0.640000 0.106667 255 255 255 150 0 1
touch_addbutton "cancelselect" "touch/gfx/exit" "cancelselect" 0.480000 0.142222 0.540000 0.248889 255 255 255 150 1 1
touch_addbutton "invprev" "touch/gfx/left" "invprev" 0.000000 0.711111 0.060000 0.817778 255 255 255 150 1 1
touch_addbutton "invnext" "touch/gfx/right" "invnext" 0.060000 0.711111 0.120000 0.817778 255 255 255 150 1 1
touch_addbutton "radio" "touch/gfx/radio" "showvguimenu 38" 0.000000 0.391111 0.060000 0.497778 255 255 255 150 0 1
touch_addbutton "touch_edit" "touch/gfx/settings" "touch_enableedit" 0.460000 0.000000 0.540000 0.142222 255 255 255 150 0 1
touch_addbutton "spraypaint" "touch/gfx/spraypaint" "impulse 201" 0.820000 0.000000 0.880000 0.106667 255 255 255 150 0 1
touch_addbutton "attack" "touch/gfx/attack" "+attack" 0.780000 0.391111 0.900000 0.604444 255 255 255 150 0 1
touch_addbutton "duck" "touch/gfx/duck" "+duck" 0.900000 0.711111 1.000000 0.888889 255 255 255 150 512 1
touch_addbutton "chat" "touch/gfx/chat" "toggle_chat" 0.000000 0.248889 0.060000 0.355556 255 255 255 150 1 1
touch_addbutton "duck_sw" "touch/gfx/duck" "crouchtoggle" 0.800000 0.711111 0.900000 0.888889 255 255 255 150 1 1
touch_addbutton "show_numbers" "touch_default/show_weapons" "exec touch_default/numbers.cfg" 0.460000 0.711111 0.540000 0.853333 255 255 255 150 1 1
touch_addbutton "cmd" "touch/gfx/cmdmenu" "exec touch/cmd/cmd" 0.360000 0.142222 0.420000 0.248889 255 255 255 150 0 1
touch_addbutton "bots" "touch/gfx/botmenu" "exec touch/bots/bots" 0.280000 0.142222 0.340000 0.248889 255 255 255 150 0 1

```

`3rdparty/cs16client-extras/touch/bots/bots.cfg`:

```cfg
_reset_menu
cmd_scripting 1
set menu_root_path "touch/bots"
set _menu_file_name "bots.cfg"
alias build_menu "exec touch/customcmd"
alias build_language "exec touch/custom/my_menu-language"
set _menu_id my_menu-1-bots
set _menu_level 1
set _menu_min 3
set _menu_max 9

build_language

set _menu_type_3 1
set _menu_txt_3 "Add bot"
set _menu_cmd_3 "exec touch/bots/my_menu-2-addbot"
set _menu_icn_3 "touch/bots/right.tga"

set _menu_type_4 1
set _menu_txt_4 "Settings"
set _menu_cmd_4 "exec touch/bots/my_menu-2-settings"
set _menu_icn_4 "touch/bots/right.tga"

set _menu_type_5 1
set _menu_txt_5 "Kill all bots"
if $yb_freeze_bots  >= 0
:set _menu_cmd_5 "bot_kill;yb kill";else
:set _menu_cmd_5 "bot_kill"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "Remove all bots"
if $yb_freeze_bots  >= 0
:set _menu_cmd_6 "bot_kick;yb removebots";else
:set _menh_cmd_6 "bot_kick"
set _menu_icn_6 ""

set _menu_type_7 2
set _menu_txt_7 "Stop bots"
set _menu_cmd_7 "bot_stop"
set _menu_f7 $bot_stop

set _menu_type_8 1
if $yb_freeze_bots  >= 0
:set _menu_txt_8 "Open YaPB menu"
:set _menu_cmd_8 "_erase_frame; yb menu"
:set _menu_icn_8 "touch/bots/right.tga"
else
:set _menu_txt_8 "$_menu_txt_exit"
:set _menu_cmd_8 "_erase_frame"
:set _menu_icn_8 ""

if $yb_freeze_bots  >= 0
:set _menu_type_9 1
:set _menu_txt_9 "$_menu_txt_exit"
:set _menu_cmd_9 "_erase_frame"
:set _menu_icn_9 ""
else
:set _menu_type_9 0

build_menu

if $enable_controls = 1;:touch_setclientonly 0;else;:touch_setclientonly 1
exec touch/custom/my_menu-5-controls.cfg

alias ybmenu "_erase_frame; yb menu"
if $bot_allow_shield >= 0
:echo
else
:ybmenu

```

`3rdparty/cs16client-extras/touch/bots/my_menu-2-addbot.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/bots"
set _menu_id my_menu-2-addbot
set _menu_level 2
set _menu_min 3
set _menu_max 6

set _menu_type_3 1
set _menu_txt_3 "Add several by quota"
set _menu_cmd_3 "exec touch/bots/my_menu-3-quota"
set _menu_icn_3 "touch/bots/right.tga"

set _menu_type_4 1
set _menu_txt_4 "Add random"
set _menu_cmd_4 "bot_add"
set _menu_icn_4 ""

set _menu_type_5 1
set _menu_txt_5 "Add Terrorist"
set _menu_cmd_5 "bot_add_t"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "Add Counter-Terrorist"
set _menu_cmd_6 "bot_add_ct"
set _menu_icn_6 ""

build_menu

```

`3rdparty/cs16client-extras/touch/bots/my_menu-2-settings.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/bots"
set _menu_id my_menu-2-settings
set _menu_level 2
set _menu_min 3
set _menu_max 9

set _menu_type_3 1
set _menu_txt_3 "Weapon settings"
set _menu_cmd_3 "exec touch/bots/my_menu-3-set1"
set _menu_icn_3 "touch/bots/right.tga"

set _menu_type_4 1
set _menu_txt_4 "Weapon modes"
set _menu_cmd_4 "exec touch/bots/my_menu-3-set2"
set _menu_icn_4 "touch/bots/right.tga"

set _menu_type_5 1
set _menu_txt_5 "Difficulty"
set _menu_cmd_5 "exec touch/bots/my_menu-3-set3"
set _menu_icn_5 "touch/bots/right.tga"

set _menu_type_6 1
set _menu_txt_6 "Chatter"
set _menu_cmd_6 "exec touch/bots/my_menu-3-set4"
set _menu_icn_6 "touch/bots/right.tga"

set _menu_type_7 1
set _menu_txt_7 "Behavior"
set _menu_cmd_7 "exec touch/bots/my_menu-3-set5"
set _menu_icn_7 "touch/bots/right.tga"

set _menu_type_8 1
set _menu_txt_8 "Quota mode"
set _menu_cmd_8 "exec touch/bots/my_menu-3-set6"
set _menu_icn_8 "touch/bots/right.tga"

set _menu_type_9 3
set _menu_txt_9 "Name prefix"
set _menu_cmd_9 "bot_prefix"
set _menu_f9 $bot_prefix

build_menu

```

`3rdparty/cs16client-extras/touch/bots/my_menu-3-quota.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/bots"
set _menu_id my_menu-3-quota
set _menu_level 3
set _menu_min 3
set _menu_max 8

set _menu_type_3 1
set _menu_txt_3 "Add bots by quota"
set _menu_cmd_3 "bot_quota $bot_quota_value"
set _menu_icn_3 ""

set _menu_type_4 3
set _menu_txt_4 "Bot quota"
set _menu_cmd_4 "bot_quota_value"
set _menu_f4 $bot_quota_value

set _menu_type_5 1
set _menu_txt_5 "Bots join any team"
set _menu_cmd_5 "bot_join_team any"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "Bots join Terrorists"
set _menu_cmd_6 "bot_join_team t"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "Bots join Counter-Terrorists"
set _menu_cmd_7 "bot_join_team ct"
set _menu_icn_7 ""

set _menu_type_8 2
set _menu_txt_8 "Bots join; after player"
set _menu_cmd_8 "bot_join_after_player"
set _menu_f8 $bot_join_after_player

build_menu

if $bot_join_team = any;:touch_setcolor _menu_S5_my_menu-3-quota 156 77 20 180
if $bot_join_team = t;:touch_setcolor _menu_S6_my_menu-3-quota 156 77 20 180
if $bot_join_team = ct;:touch_setcolor _menu_S7_my_menu-3-quota 156 77 20 180

```

`3rdparty/cs16client-extras/touch/bots/my_menu-3-set1.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/bots"
set _menu_id my_menu-3-set1
set _menu_level 3
set _menu_min 3
set _menu_max 10

set _menu_type_3 2
set _menu_txt_3 "Pistols"
set _menu_cmd_3 "bot_allow_pistols"
set _menu_f3 $bot_allow_pistols

set _menu_type_4 2
set _menu_txt_4 "Shotguns"
set _menu_cmd_4 "bot_allow_shotguns"
set _menu_f4 $bot_allow_shotguns

set _menu_type_5 2
set _menu_txt_5 "Submachine; guns"
set _menu_cmd_5 "bot_allow_sub_machine_guns"
set _menu_f5 $bot_allow_sub_machine_guns

set _menu_type_6 2
set _menu_txt_6 "Rifles"
set _menu_cmd_6 "bot_allow_rifles"
set _menu_f6 $bot_allow_rifles

set _menu_type_7 2
set _menu_txt_7 "Sniper; rifles"
set _menu_cmd_7 "bot_allow_snipers"
set _menu_f7 $bot_allow_snipers

set _menu_type_8 2
set _menu_txt_8 "Machine guns"
set _menu_cmd_8 "bot_allow_machine_guns"
set _menu_f8 $bot_allow_machine_guns

set _menu_type_9 2
set _menu_txt_9 "Grenades"
set _menu_cmd_9 "bot_allow_grenades"
set _menu_f9 $bot_allow_grenades

set _menu_type_10 2
set _menu_txt_10 "Shield"
set _menu_cmd_10 "bot_allow_shield"
set _menu_f10 $bot_allow_shield

build_menu

```

`3rdparty/cs16client-extras/touch/bots/my_menu-3-set2.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/bots"
set _menu_id my_menu-3-set2
set _menu_level 3
set _menu_min 4
set _menu_max 7

set _menu_type_4 1
set _menu_txt_4 "Knives only"
set _menu_cmd_4 "bot_knives_only"
set _menu_icn_4 ""

set _menu_type_5 1
set _menu_txt_5 "Pistols only"
set _menu_cmd_5 "bot_pistols_only"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "Snipers only"
set _menu_cmd_6 "bot_snipers_only"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "All weapons"
set _menu_cmd_7 "bot_all_weapons"
set _menu_icn_7 ""

build_menu

```

`3rdparty/cs16client-extras/touch/bots/my_menu-3-set3.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/bots"
set _menu_id my_menu-3-set3
set _menu_level 3
set _menu_min 5
set _menu_max 8

set _menu_type_5 1
set _menu_txt_5 "Easy"
set _menu_cmd_5 "bot_difficulty 0"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "Normal"
set _menu_cmd_6 "bot_difficulty 1"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "Hard"
set _menu_cmd_7 "bot_difficulty 2"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Very Hard"
set _menu_cmd_8 "bot_difficulty 3"
set _menu_icn_8 ""

build_menu

if $bot_difficulty = 0;:touch_setcolor _menu_S5_my_menu-3-set3 156 77 20 180
if $bot_difficulty = 1;:touch_setcolor _menu_S6_my_menu-3-set3 156 77 20 180
if $bot_difficulty = 2;:touch_setcolor _menu_S7_my_menu-3-set3 156 77 20 180
if $bot_difficulty = 3;:touch_setcolor _menu_S8_my_menu-3-set3 156 77 20 180

```

`3rdparty/cs16client-extras/touch/bots/my_menu-3-set4.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/bots"
set _menu_id my_menu-3-set4
set _menu_level 3
set _menu_min 6
set _menu_max 9

set _menu_type_6 1
set _menu_txt_6 "Normal"
set _menu_cmd_6 "bot_chatter normal"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "Minimal"
set _menu_cmd_7 "bot_chatter minimal"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Radio Only"
set _menu_cmd_8 "bot_chatter radio"
set _menu_icn_8 ""

set _menu_type_9 1
set _menu_txt_9 "Disabled"
set _menu_cmd_9 "bot_chatter off"
set _menu_icn_9 ""

build_menu

if $bot_chatter = normal;:touch_setcolor _menu_S6_my_menu-3-set4 156 77 20 180
if $bot_chatter = minimal;:touch_setcolor _menu_S7_my_menu-3-set4 156 77 20 180
if $bot_chatter = radio;:touch_setcolor _menu_S8_my_menu-3-set4 156 77 20 180
if $bot_chatter = off;:touch_setcolor _menu_S9_my_menu-3-set4 156 77 20 180

```

`3rdparty/cs16client-extras/touch/bots/my_menu-3-set5.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/bots"
set _menu_id my_menu-3-set5
set _menu_level 3
set _menu_min 7
set _menu_max 10

set _menu_type_7 2
set _menu_txt_7 "Bots make; room for; players"
set _menu_cmd_7 "bot_auto_vacate"
set _menu_f7 $bot_auto_vacate

set _menu_type_8 2
set _menu_txt_8 "Bots defer; to human; objectives"
set _menu_cmd_8 "bot_defer_to_human"
set _menu_f8 $bot_defer_to_human

set _menu_type_9 2
set _menu_txt_9 "Allow rogues"
set _menu_cmd_9 "bot_allow_rogues"
set _menu_f9 $bot_allow_rogues

set _menu_type_10 2
set _menu_txt_10 "Walk only"
set _menu_cmd_10 "bot_walk"
set _menu_f10 $bot_walk

build_menu

```

`3rdparty/cs16client-extras/touch/bots/my_menu-3-set6.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/bots"
set _menu_id my_menu-3-set6
set _menu_level 3
set _menu_min 8
set _menu_max 10

set _menu_type_8 1
set _menu_txt_8 "Normal"
set _menu_cmd_8 "bot_quota_mode normal"
set _menu_icn_8 ""

set _menu_type_9 1
set _menu_txt_9 "Fill"
set _menu_cmd_9 "bot_quota_mode fill"
set _menu_icn_9 ""

set _menu_type_10 1
set _menu_txt_10 "Match"
set _menu_cmd_10 "bot_quota_mode match"
set _menu_icn_10 ""

build_menu

if $bot_quota_mode = normal;:touch_setcolor _menu_S8_my_menu-3-set6 156 77 20 180
if $bot_quota_mode = fill;:touch_setcolor _menu_S9_my_menu-3-set6 156 77 20 180
if $bot_quota_mode = match;:touch_setcolor _menu_S0_my_menu-3-set6 156 77 20 180

```

`3rdparty/cs16client-extras/touch/buy.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY MENU" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

touch_addbutton "_menu_txt_title" "#SHOP BY CATEGORY" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "+menu_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 PISTOLS" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "+menu_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 SHOTGUNS" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "+menu_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 SMG" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "+menu_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 RIFLES" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
touch_addbutton "_menu_slot5" "*white" "+menu_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
touch_addbutton "_menu_txt_slot5" "#5 MACHINE GUNS" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
touch_addbutton "_menu_slot6" "*white" "+menu_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
touch_addbutton "_menu_txt_slot6" "#6 PRIMARY AMMO" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
touch_addbutton "_menu_slot7" "*white" "+menu_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
touch_addbutton "_menu_txt_slot7" "#7 SECONDARY AMMO" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
touch_addbutton "_menu_slot8" "*white" "+menu_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
touch_addbutton "_menu_txt_slot8" "#8 EQUIPMENT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4
touch_addbutton "_menu_seperator" "*white" "" 0.374000 0.213333 0.376000 0.924444 0 0 0 150 260
touch_addbutton "_menu_autobuy" "*white" "+menu_autobuy" 0.390000 0.213333 0.610000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_autobuy" "#A AUTO-BUY" "" 0.400000 0.231111 0.610000 0.266667 255 174 0 255 4
touch_addbutton "_menu_rebuy" "*white" "+menu_rebuy" 0.390000 0.284444 0.610000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_rebuy" "#R RE-BUY PREVIOUS" "" 0.400000 0.302222 0.610000 0.337778 255 174 0 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy.cfg"

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"

alias +menu_slot1 "_click; touch_setcolor _menu_slot1 255 174 0 150"
alias -menu_slot1 "touch_setcolor _menu_slot1 0 0 0 150; _erase_frame; showvguimenu 29"

alias +menu_slot2 "_click; touch_setcolor _menu_slot2 255 174 0 150"
alias -menu_slot2 "touch_setcolor _menu_slot2 0 0 0 150; _erase_frame; showvguimenu 30"

alias +menu_slot3 "_click; touch_setcolor _menu_slot3 255 174 0 150"
alias -menu_slot3 "touch_setcolor _menu_slot3 0 0 0 150; _erase_frame; showvguimenu 32"

alias +menu_slot4 "_click; touch_setcolor _menu_slot4 255 174 0 150"
alias -menu_slot4 "touch_setcolor _menu_slot4 0 0 0 150; _erase_frame; showvguimenu 31"

alias +menu_slot5 "_click; touch_setcolor _menu_slot5 255 174 0 150"
alias -menu_slot5 "touch_setcolor _menu_slot5 0 0 0 150; _erase_frame; showvguimenu 33"

alias +menu_slot6 "_click; touch_setcolor _menu_slot6 255 174 0 150"
alias -menu_slot6 "touch_setcolor _menu_slot6 0 0 0 150; primammo; _erase_frame"

alias +menu_slot7 "_click; touch_setcolor _menu_slot7 255 174 0 150"
alias -menu_slot7 "touch_setcolor _menu_slot7 0 0 0 150; secammo; _erase_frame"

alias +menu_slot8 "_click; touch_setcolor _menu_slot8 255 174 0 150"
alias -menu_slot8 "touch_setcolor _menu_slot8 0 0 0 150; _erase_frame; showvguimenu 34"

alias +menu_autobuy "_click; touch_setcolor _menu_autobuy 255 174 0 150"
alias -menu_autobuy "touch_setcolor _menu_autobuy 0 0 0 150; autobuy; _erase_frame"

alias +menu_rebuy "_click; touch_setcolor _menu_rebuy 255 174 0 150"
alias -menu_rebuy "touch_setcolor _menu_rebuy 0 0 0 150; rebuy; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_item_ct.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY EQUIPMENT" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 KEVLAR" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 KEVLAR+HELMET" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 FLASHBANG" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 HE GRENADE" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
touch_addbutton "_menu_txt_slot5" "#5 SMOKE GRENADE" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
if $cscl_mapprefix == "de_"
:touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
:touch_addbutton "_menu_txt_slot6" "#6 DEFUSAL KIT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
else
:touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6_noconfirm" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
:touch_addbutton "_menu_txt_slot6" "#6 DEFUSAL KIT" "" 0.150000 0.586667 0.360000 0.622222 129 85 0 255 4
touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
touch_addbutton "_menu_txt_slot7" "#7 NIGHTVISION" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
touch_addbutton "_menu_txt_slot8" "#8 TACTICAL SHIELD" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "650"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
set _menu_money_item2 "1000"; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
set _menu_money_item3 "200"; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
set _menu_money_item4 "300"; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
set _menu_money_item5 "300"; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
set _menu_money_item6 "200"; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
set _menu_money_item7 "1250"; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
set _menu_money_item8 "2200"; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/kevlar.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/kevlar_helmet.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class3" "gfx/vgui/flashbang.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class4" "gfx/vgui/hegrenade.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class5" "gfx/vgui/smokegrenade.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class6" "gfx/vgui/defuser.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class7" "gfx/vgui/nightvision.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class8" "gfx/vgui/shield.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1" "#PRICE;DESCRIPTION" "" 0.390000 0.551111 0.560000 0.853333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_data2" "#TITLE;SUBTITLE" "" 0.390000 0.551111 0.560000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1" "#: \$$_menu_money_item1;: A Kevlar vest that protects ; against projectiles" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2" "#: \$$_menu_money_item2;: A kevlar vest and a ballistic ; helmet which both protect ; against projectiles." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3" "#: \$$_menu_money_item3;: Makes a loud noise and ; blinding flash when thrown ; at enemy (pull pin first). ; Useful for causing distractions ; before entering an area." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4" "#: \$$_menu_money_item4;: A high-explosive device. Pull ; the pin, release the spoon ; and throw." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5" "#: \$$_menu_money_item5;: A diversionary device that ; can be used to provide ; temporary cover for moving ; from place to place." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6" "#: \$$_menu_money_item6;: A bomb defusal kit used to ; speed up the bomb defusal ; process." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc7" "#: \$$_menu_money_item7;: Nightvision goggles which ; allow the user to see more ; effectively in dark areas." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc8" "#: \$$_menu_money_item8;: Barrier-type shield for ; street tactics and ; intervention." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_item_ct.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed vest"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc2; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed vesthelm"
alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc3; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed flash"
alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc4; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed hegren"
alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc5; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed sgren"
alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc6; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed defuser"
alias _menu_select_slot6_noconfirm "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc6"
alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc7; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed nvgs"
alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc8; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed shield"

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_item_t.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY EQUIPMENT" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 KEVLAR" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 KEVLAR+HELMET" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 FLASHBANG" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 HE GRENADE" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
touch_addbutton "_menu_txt_slot5" "#5 SMOKE GRENADE" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
touch_addbutton "_menu_txt_slot6" "#6 NIGHTVISION" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "650"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
set _menu_money_item2 "1000"; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
set _menu_money_item3 "200"; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
set _menu_money_item4 "300"; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
set _menu_money_item5 "300"; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
set _menu_money_item6 "1250"; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/kevlar.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/kevlar_helmet.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class3" "gfx/vgui/flashbang.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class4" "gfx/vgui/hegrenade.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class5" "gfx/vgui/smokegrenade.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class6" "gfx/vgui/nightvision.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1" "#PRICE;DESCRIPTION" "" 0.390000 0.551111 0.560000 0.853333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_data2" "#TITLE;SUBTITLE" "" 0.390000 0.551111 0.560000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1" "#: \$$_menu_money_item1;: A Kevlar vest that protects ; against projectiles" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2" "#: \$$_menu_money_item2;: A kevlar vest and a ballistic ; helmet which both protect ; against projectiles." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3" "#: \$$_menu_money_item3;: Makes a loud noise and ; blinding flash when thrown ; at enemy (pull pin first). ; Useful for causing distractions ; before entering an area." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4" "#: \$$_menu_money_item4;: A high-explosive device. Pull ; the pin, release the spoon ; and throw." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5" "#: \$$_menu_money_item5;: A diversionary device that ; can be used to provide ; temporary cover for moving ; from place to place." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6" "#: \$$_menu_money_item6;: Nightvision goggles which ; allow the user to see more ; effectively in dark areas." "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7" "" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8" "" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_item_t.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed vest"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc2; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed vesthelm"
alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc3; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed flash"
alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc4; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed hegren"
alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc5; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed sgren"
alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc6; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed nvgs"
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc7; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc8; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_machinegun_ct.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY MACHINE GUNS (PRIMARY WEAPON)" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 M249" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
//touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
//touch_addbutton "_menu_txt_slot2" "#2 SLOT" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
//touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
//touch_addbutton "_menu_txt_slot3" "#3 SLOT" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
//touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
//touch_addbutton "_menu_txt_slot4" "#4 SLOT" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
//touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
//touch_addbutton "_menu_txt_slot5" "#5 SLOT" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
//touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
//touch_addbutton "_menu_txt_slot6" "#6 SLOT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "5750"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
//set _menu_money_item2 ""; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
//set _menu_money_item3 ""; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
//set _menu_money_item4 ""; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
//set _menu_money_item5 ""; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
//set _menu_money_item6 ""; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/m249.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class2" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class3" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class4" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class5" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class6" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_6" "#WEIGHT (LOADED)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_data2_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_6" "#WEIGHT (EMPTY)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc1_1" "#: \$$_menu_money_item1" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_2" "#: BELGIUM" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_3" "#: 5.56 PARABELLUM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_4" "#: 100 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_5" "#: 600 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_6" "#: 6KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_7" "#: 4 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_8" "#: 3000 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_9" "#: 1600 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc2_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc3_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc4_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc5_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc6_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc7_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc8_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_machinegun_ct.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc1_*; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed m249"
//alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc2_*; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc3_*; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc4_*; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc5_*; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc6_*; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc7_*; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc8_*; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_machinegun_t.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY MACHINE GUNS (PRIMARY WEAPON)" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 M249" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
//touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
//touch_addbutton "_menu_txt_slot2" "#2 SLOT" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
//touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
//touch_addbutton "_menu_txt_slot3" "#3 SLOT" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
//touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
//touch_addbutton "_menu_txt_slot4" "#4 SLOT" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
//touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
//touch_addbutton "_menu_txt_slot5" "#5 SLOT" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
//touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
//touch_addbutton "_menu_txt_slot6" "#6 SLOT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "5750"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
//set _menu_money_item2 ""; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
//set _menu_money_item3 ""; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
//set _menu_money_item4 ""; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
//set _menu_money_item5 ""; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
//set _menu_money_item6 ""; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/m249.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class2" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class3" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class4" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class5" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class6" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_6" "#WEIGHT (LOADED)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_data2_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_6" "#WEIGHT (EMPTY)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc1_1" "#: \$$_menu_money_item1" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_2" "#: BELGIUM" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_3" "#: 5.56 PARABELLUM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_4" "#: 100 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_5" "#: 600 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_6" "#: 6KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_7" "#: 4 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_8" "#: 3000 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_9" "#: 1600 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc2_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc3_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc4_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc5_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc6_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc7_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc8_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_machinegun_ct.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc1_*; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed m249"
//alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc2_*; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc3_*; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc4_*; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc5_*; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc6_*; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc7_*; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc8_*; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_pistol_ct.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY PISTOLS (SECONDARY WEAPON)" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 9X19MM SIDEARM" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 K&M .45 TACTICAL" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 228 COMPACT" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 NIGHT HAWK .50C" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
touch_addbutton "_menu_txt_slot5" "#5 ES FIVE-SEVEN" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
//touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
//touch_addbutton "_menu_txt_slot6" "#6 SLOT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "400"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
set _menu_money_item2 "500"; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
set _menu_money_item3 "600"; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
set _menu_money_item4 "650"; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
set _menu_money_item5 "750"; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
//set _menu_money_item6 ""; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/glock18.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/usp45.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class3" "gfx/vgui/p228.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class4" "gfx/vgui/deserteagle.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class5" "gfx/vgui/fiveseven.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class6" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_6" "#WEIGHT (LOADED)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_data2_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_6" "#WEIGHT (EMPTY)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc1_1" "#: \$$_menu_money_item1" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_2" "#: AUSTRIA" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_3" "#: 9MM PARABELLUM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_4" "#: 20 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_6" "#: 0.9KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_7" "#: 8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_8" "#: 1132 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_9" "#: 475 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc2_1" "#: \$$_menu_money_item2" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_2" "#: GERMANY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_3" "#: .45 ACP" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_4" "#: 12 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_6" "#: 1KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_7" "#: 15.2 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_8" "#: 886 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_9" "#: 553 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc3_1" "#: \$$_menu_money_item3" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_2" "#: SWITZERLAND/GERMANY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_3" "#: .357 SIG" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_4" "#: 13 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_6" "#: 1.03KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_7" "#: 8.1 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_8" "#: 1400 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_9" "#: 600 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc4_1" "#: \$$_menu_money_item4" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_2" "#: ISRAEL" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_3" "#: .50 ACTION EXPRESS" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_4" "#: 7 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_6" "#: 1.8KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_7" "#: 19.4 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_8" "#: 1380 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_9" "#: 1650 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc5_1" "#: \$$_menu_money_item5" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_2" "#: BELGIUM" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_3" "#: 5.7 X 28MM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_4" "#: 20 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_6" "#: 0.618KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_7" "#: 2 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_8" "#: 2345 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_9" "#: 465 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc6_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc7_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc8_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_pistol_ct.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc1_*; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed glock"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc2_*; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed usp"
alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc3_*; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed p228"
alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc4_*; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed deagle"
alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc5_*; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed fiveseven"
//alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc6_*; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc7_*; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc8_*; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_pistol_t.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY PISTOLS (SECONDARY WEAPON)" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 9X19MM SIDEARM" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 K&M .45 TACTICAL" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 228 COMPACT" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 NIGHT HAWK .50C" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
touch_addbutton "_menu_txt_slot5" "#5 .40 DUAL ELITES" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
//touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
//touch_addbutton "_menu_txt_slot6" "#6 SLOT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "400"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
set _menu_money_item2 "500"; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
set _menu_money_item3 "600"; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
set _menu_money_item4 "650"; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
set _menu_money_item5 "800"; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
//set _menu_money_item6 ""; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/glock18.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/usp45.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class3" "gfx/vgui/p228.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class4" "gfx/vgui/deserteagle.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class5" "gfx/vgui/elites.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class6" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_txt_data1" "#PRICE;COUNTRY OF ORIGIN;CALIBER;CLIP CAPACITY;RATE OF FIRE;WEIGHT (LOADED);PROJECTILE WEIGHT;MUZZLE VELOCITY;MUZZLE ENERGY" "" 0.390000 0.551111 0.560000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2" "#PRICE;COUNTRY OF ORIGIN;CALIBER;CLIP CAPACITY;RATE OF FIRE;WEIGHT (EMPTY);PROJECTILE WEIGHT;MUZZLE VELOCITY;MUZZLE ENERGY" "" 0.390000 0.551111 0.560000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1" "#: \$$_menu_money_item1;: AUSTRIA;: 9MM PARABELLUM;: 20 ROUNDS;: N/A;: 0.9KG;: 8 GRAMS;: 1132 FEET/SECOND;: 475 JOULES" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2" "#: \$$_menu_money_item2;: GERMANY;: .45 ACP;: 12 ROUNDS;: N/A;: 1KG;: 15.2 GRAMS;: 886 FEET/SECOND;: 553 JOULES" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3" "#: \$$_menu_money_item3;: SWITZERLAND/GERMANY;: .357 SIG;: 13 ROUNDS;: N/A;: 1.03KG;: 8.1 GRAMS;: 1400 FEET/SECOND;: 600 JOULES" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4" "#: \$$_menu_money_item4;: ISRAEL;: .50 ACTION EXPRESS;: 7 ROUNDS;: N/A;: 1.8KG;: 19.4 GRAMS;: 1380 FEET/SECOND;: 1650 JOULES" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5" "#: \$$_menu_money_item5;: ITALY;: .40 S&&W;: 15 ROUNDS;: N/A;: 1.15KG;: 8 GRAMS;: 1280 FEET/SECOND;: 606 JOULES" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6" "#: \$$_menu_money_item6;" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7" "#: \$$_menu_money_item7;" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8" "#: \$$_menu_money_item8;" "" 0.560000 0.551111 0.840000 0.853333 240 180 24 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_6" "#WEIGHT (LOADED)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_data2_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_6" "#WEIGHT (EMPTY)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc1_1" "#: \$$_menu_money_item1" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_2" "#: AUSTRIA" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_3" "#: 9MM PARABELLUM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_4" "#: 20 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_6" "#: 0.9KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_7" "#: 8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_8" "#: 1132 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_9" "#: 475 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc2_1" "#: \$$_menu_money_item2" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_2" "#: GERMANY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_3" "#: .45 ACP" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_4" "#: 12 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_6" "#: 1KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_7" "#: 15.2 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_8" "#: 886 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_9" "#: 553 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc3_1" "#: \$$_menu_money_item3" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_2" "#: SWITZERLAND/GERMANY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_3" "#: .357 SIG" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_4" "#: 13 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_6" "#: 1.03KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_7" "#: 8.1 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_8" "#: 1400 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_9" "#: 600 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc4_1" "#: \$$_menu_money_item4" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_2" "#: ISRAEL" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_3" "#: .50 ACTION EXPRESS" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_4" "#: 7 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_6" "#: 1.8KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_7" "#: 19.4 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_8" "#: 1380 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_9" "#: 1650 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc5_1" "#: \$$_menu_money_item5" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_2" "#: ITALY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_3" "#: .40 S&&W" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_4" "#: 15 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_6" "#: 0.618KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_7" "#: 8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_8" "#: 1280 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_9" "#: 606 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc6_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc7_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc8_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_pistol_t.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed glock"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data2; touch_show _menu_frame_txt_desc2; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed usp"
alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc3; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed p228"
alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc4; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed deagle"
alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc5; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed elites"
//alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc6; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc7; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1; touch_show _menu_frame_txt_desc8; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_rifle_ct.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY RIFLES (PRIMARY WEAPON)" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 CLARION 5.56" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 SCHMIDT SCOUT" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 MAVERICK M4A1 CARBINE" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 BULLPUP" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
touch_addbutton "_menu_txt_slot5" "#5 ES KRIEG 550 COMMANDO" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
touch_addbutton "_menu_txt_slot6" "#6 MAGNUM SNIPER RIFLE" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "2250"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
set _menu_money_item2 "2750"; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
set _menu_money_item3 "3100"; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
set _menu_money_item4 "3500"; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
set _menu_money_item5 "4200"; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
set _menu_money_item6 "4750"; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/famas.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/scout.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class3" "gfx/vgui/m4a1.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class4" "gfx/vgui/aug.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class5" "gfx/vgui/sg550.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class6" "gfx/vgui/awp.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_6" "#WEIGHT (LOADED)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_data2_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_6" "#WEIGHT (EMPTY)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc1_1" "#: \$$_menu_money_item1" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_2" "#: FRANCE" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_3" "#: 5.56 NATO" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_4" "#: 25 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_5" "#: 1100 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_6" "#: 3.40KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_7" "#: 4 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_8" "#: 2212 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_9" "#: 1712 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc2_1" "#: \$$_menu_money_item2" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_2" "#: AUSTRIA" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_3" "#: 7.62 NATO" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_4" "#: 10 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_6" "#: 3.3KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_7" "#: 8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_8" "#: 2800 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_9" "#: 2200 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc3_1" "#: \$$_menu_money_item3" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_2" "#: UNITED STATES OF AMERICA" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_3" "#: 5.56 NATO" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_4" "#: 30 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_5" "#: 685 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_6" "#: 3.22KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_7" "#: 4 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_8" "#: 2900 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_9" "#: 1570 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc4_1" "#: \$$_menu_money_item4" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_2" "#: AUSTRIA" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_3" "#: 5.56 NATO" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_4" "#: 30 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_5" "#: 727 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_6" "#: 4.09KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_7" "#: 4 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_8" "#: 2900 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_9" "#: 1570 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc5_1" "#: \$$_menu_money_item5" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_2" "#: SWITZERLAND" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_3" "#: 5.56 NATO" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_4" "#: 30 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_6" "#: 7.02KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_7" "#: 4 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_8" "#: 3100 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_9" "#: 1650 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc6_1" "#: \$$_menu_money_item6" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_2" "#: UNITED KINGDOM" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_3" "#: .338 LAPUA MAGNUM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_4" "#: 10 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_6" "#: 6KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_7" "#: 16.2 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_8" "#: 3000 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_9" "#: 7000 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc7_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc8_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_rifle_ct.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc1_*; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed famas"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc2_*; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed scout"
alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc3_*; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed m4a1"
alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc4_*; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed aug"
alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc5_*; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed sg550"
alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc6_*; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed awp"
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc7_*; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc8_*; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_rifle_t.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY RIFLES (PRIMARY WEAPON)" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 IDF DEFENDER" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 CV-47" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 SCHMIDT SCOUT" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 KRIEG 552" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
touch_addbutton "_menu_txt_slot5" "#5 MAGNUM SNIPER RIFLE" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
touch_addbutton "_menu_txt_slot6" "#6 D3/AU-1" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "2000"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
set _menu_money_item2 "2500"; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
set _menu_money_item3 "2750"; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
set _menu_money_item4 "3500"; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
set _menu_money_item5 "4750"; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
set _menu_money_item6 "5000"; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/galil.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/ak47.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class3" "gfx/vgui/scout.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class4" "gfx/vgui/sg552.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class5" "gfx/vgui/awp.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class6" "gfx/vgui/g3sg1.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_6" "#WEIGHT (LOADED)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_data2_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_6" "#WEIGHT (EMPTY)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc1_1" "#: \$$_menu_money_item1" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_2" "#: ISRAEL" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_3" "#: .308" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_4" "#: 35 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_5" "#: 675 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_6" "#: 4.35KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_7" "#: 4 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_8" "#: 2013 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_9" "#: 1712 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc2_1" "#: \$$_menu_money_item2" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_2" "#: RUSSIA" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_3" "#: 7.62 NATO" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_4" "#: 30 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_5" "#: 600 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_6" "#: 4.79KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_7" "#: 7.9 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_8" "#: 2329 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_9" "#: 1992 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc3_1" "#: \$$_menu_money_item3" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_2" "#: AUSTRIA" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_3" "#: 7.62 NATO" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_4" "#: 10 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_6" "#: 3.3KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_7" "#: 8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_8" "#: 2800 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_9" "#: 2200 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc4_1" "#: \$$_menu_money_item4" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_2" "#: SWITZERLAND" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_3" "#: 5.56 NATO" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_4" "#: 30 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_5" "#: 727 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_6" "#: 3.1KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_7" "#: 4 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_8" "#: 2900 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_9" "#: 1570 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc5_1" "#: \$$_menu_money_item5" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_2" "#: UNITED KINGDOM" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_3" "#: .338 LAPUA MAGNUM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_4" "#: 10 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_6" "#: 6KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_7" "#: 16.2 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_8" "#: 3000 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc5_9" "#: 7000 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc6_1" "#: \$$_menu_money_item6" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_2" "#: GERMANY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_3" "#: 7.62 NATO" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_4" "#: 20 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_6" "#: 4.41KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_7" "#: 8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_8" "#: 2800 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc6_9" "#: 2200 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc7_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc8_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_rifle_t.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc1_*; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed galil"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc2_*; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed ak47"
alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc3_*; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed scout"
alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc4_*; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed sg552"
alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc5_*; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed awp"
alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc6_*; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed g3sg1"
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc7_*; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc8_*; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_shotgun_ct.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY SHOTGUNS (PRIMARY WEAPON)" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 LEONE 12 GAUGE SUPER" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 LEONE YG1265 AUTO SHOTGUN" "" 0.150000 0.302222 0.370000 0.337778 255 174 0 255 4
//touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
//touch_addbutton "_menu_txt_slot3" "#3 SLOT" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
//touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
//touch_addbutton "_menu_txt_slot4" "#4 SLOT" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
//touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
//touch_addbutton "_menu_txt_slot5" "#5 SLOT" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
//touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
//touch_addbutton "_menu_txt_slot6" "#6 SLOT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "1700"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
set _menu_money_item2 "3000"; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
//set _menu_money_item3 ""; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
//set _menu_money_item4 ""; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
//set _menu_money_item5 ""; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
//set _menu_money_item6 ""; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/m3.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/xm1014.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class3" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class4" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class5" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class6" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_6" "#WEIGHT (LOADED)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_data2_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_6" "#WEIGHT (EMPTY)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc1_1" "#: \$$_menu_money_item1" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_2" "#: ITALY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_3" "#: 12 GAUGE" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_4" "#: 8 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_6" "#: 3.5KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_7" "#: 3.8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_8" "#: 1250 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_9" "#: 2429 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc2_1" "#: \$$_menu_money_item2" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_2" "#: ITALY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_3" "#: 12 GAUGE" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_4" "#: 7 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_5" "#: 400 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_6" "#: 4KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_7" "#: 3.8 GRAMS/PELLET" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_8" "#: 1250 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_9" "#: 2429 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc3_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc4_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc5_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc6_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc7_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc8_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_shotgun_ct.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc1_*; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed m3"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc2_*; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed xm1014"
//alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc3_*; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc4_*; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc5_*; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc6_*; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc7_*; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc8_*; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_shotgun_t.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY SHOTGUNS (PRIMARY WEAPON)" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 LEONE 12 GAUGE SUPER" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 LEONE YG1265 AUTO SHOTGUN" "" 0.150000 0.302222 0.370000 0.337778 255 174 0 255 4
//touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
//touch_addbutton "_menu_txt_slot3" "#3 SLOT" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
//touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
//touch_addbutton "_menu_txt_slot4" "#4 SLOT" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
//touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
//touch_addbutton "_menu_txt_slot5" "#5 SLOT" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
//touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
//touch_addbutton "_menu_txt_slot6" "#6 SLOT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "1700"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
set _menu_money_item2 "3000"; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
//set _menu_money_item3 ""; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
//set _menu_money_item4 ""; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
//set _menu_money_item5 ""; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
//set _menu_money_item6 ""; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/m3.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/xm1014.tga" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class3" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class4" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class5" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class6" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.285333 0.810000 0.479111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_6" "#WEIGHT (LOADED)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_data2_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_6" "#WEIGHT (EMPTY)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc1_1" "#: \$$_menu_money_item1" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_2" "#: ITALY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_3" "#: 12 GAUGE" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_4" "#: 8 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_5" "#: N/A" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_6" "#: 3.5KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_7" "#: 3.8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_8" "#: 1250 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_9" "#: 2429 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc2_1" "#: \$$_menu_money_item2" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_2" "#: ITALY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_3" "#: 12 GAUGE" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_4" "#: 7 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_5" "#: 400 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_6" "#: 4KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_7" "#: 3.8 GRAMS/PELLET" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_8" "#: 1250 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_9" "#: 2429 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc3_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc3_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc4_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc4_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc5_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc6_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc7_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc8_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_shotgun_ct.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc1_*; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed m3"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc2_*; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed xm1014"
//alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc3_*; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc4_*; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc5_*; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc6_*; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc7_*; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc8_*; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_submachinegun_ct.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY SUBMACHINE GUNS (PRIMARY WEAPON)" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 SCHMIDT MACHINE PISTOL" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 K&M SUB-MACHINE GUN" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 K&M UMP45" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 ES C90" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
//touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
//touch_addbutton "_menu_txt_slot5" "#5 SLOT" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
//touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
//touch_addbutton "_menu_txt_slot6" "#6 SLOT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "1250"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
set _menu_money_item2 "1500"; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
set _menu_money_item3 "1700"; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
set _menu_money_item4 "2350"; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
//set _menu_money_item5 ""; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
//set _menu_money_item6 ""; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/tmp.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/mp5.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class3" "gfx/vgui/ump45.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class4" "gfx/vgui/p90.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class5" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class6" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_6" "#WEIGHT (LOADED)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_data2_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_6" "#WEIGHT (EMPTY)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc1_1" "#: \$$_menu_money_item1" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_2" "#: AUSTRIA" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_3" "#: 9MM PARABELLUM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_4" "#: 30 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_5" "#: 857 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_6" "#: 1.3KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_7" "#: 8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_8" "#: 1280 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_9" "#: 606 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc2_1" "#: \$$_menu_money_item2" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_2" "#: GERMANY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_3" "#: 9MM PARABELLUM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_4" "#: 30 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_5" "#: 800 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_6" "#: 3.42KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_7" "#: 8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_8" "#: 1132 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_9" "#: 637 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc3_1" "#: \$$_menu_money_item3" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_2" "#: GERMANY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_3" "#: .45 ACP" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_4" "#: 25 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_5" "#: 600 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_6" "#: 2.27KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_7" "#: 15.2 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_8" "#: 1005 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_9" "#: 625 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc4_1" "#: \$$_menu_money_item4" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_2" "#: BELGIUM" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_3" "#: 5.7 x 28MM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_4" "#: 50 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_5" "#: 900 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_6" "#: 3KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_7" "#: 2 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_8" "#: 2345 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_9" "#: 465 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc5_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc6_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc7_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc8_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_submachinegun_ct.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc1_*; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed tmp"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc2_*; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed mp5"
alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc3_*; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed ump45"
alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc4_*; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed p90"
//alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc5_*; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc6_*; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc7_*; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc8_*; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/buy_submachinegun_t.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#BUY SUBMACHINE GUNS (PRIMARY WEAPON)" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 INGRAM MAC-10" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 K&M SUB-MACHINE GUN" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 K&M UMP45" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 ES C90" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
//touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
//touch_addbutton "_menu_txt_slot5" "#5 SLOT" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
//touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
//touch_addbutton "_menu_txt_slot6" "#6 SLOT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "_menu_select_slot7" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "_menu_select_slot8" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4

set _menu_money_item1 "1400"; if $cscl_currentmoney < $_menu_money_item1;: touch_setcolor _menu_txt_slot1 129 85 0 255
set _menu_money_item2 "1500"; if $cscl_currentmoney < $_menu_money_item2;: touch_setcolor _menu_txt_slot2 129 85 0 255
set _menu_money_item3 "1700"; if $cscl_currentmoney < $_menu_money_item3;: touch_setcolor _menu_txt_slot3 129 85 0 255
set _menu_money_item4 "2350"; if $cscl_currentmoney < $_menu_money_item4;: touch_setcolor _menu_txt_slot4 129 85 0 255
//set _menu_money_item5 ""; if $cscl_currentmoney < $_menu_money_item5;: touch_setcolor _menu_txt_slot5 129 85 0 255
//set _menu_money_item6 ""; if $cscl_currentmoney < $_menu_money_item6;: touch_setcolor _menu_txt_slot6 129 85 0 255
//set _menu_money_item7 ""; if $cscl_currentmoney < $_menu_money_item7;: touch_setcolor _menu_txt_slot7 129 85 0 255
//set _menu_money_item8 ""; if $cscl_currentmoney < $_menu_money_item8;: touch_setcolor _menu_txt_slot8 129 85 0 255

touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/mac10.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/mp5.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class3" "gfx/vgui/ump45.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class4" "gfx/vgui/p90.tga" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class5" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class6" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class7" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4
//touch_addbutton "_menu_frame_icn_class8" "" "" 0.430000 0.215333 0.810000 0.549111 255 255 255 255 4

touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.62 0.871111 0.84 0.924444 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#BUY THE ITEM" "" 0.63 0.888889 0.84 0.924444 255 174 0 255 4

touch_addbutton "_menu_frame_txt_data1_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_6" "#WEIGHT (LOADED)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data1_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_data2_1" "#PRICE" "" 0.39 0.551111 0.56 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_2" "#COUNTRY OF ORIGIN" "" 0.39 0.586667 0.56 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_3" "#CALIBER" "" 0.39 0.622222 0.56 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_4" "#CLIP CAPACITY" "" 0.39 0.657778 0.56 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_5" "#RATE OF FIRE" "" 0.39 0.693333 0.56 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_6" "#WEIGHT (EMPTY)" "" 0.39 0.728889 0.56 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_7" "#PROJECTILE WEIGHT" "" 0.39 0.764444 0.56 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_8" "#MUZZLE VELOCITY" "" 0.39 0.8 0.56 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_data2_9" "#MUZZLE ENERGY" "" 0.39 0.835556 0.56 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc1_1" "#: \$$_menu_money_item1" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_2" "#: UNITED STATES OF AMERICA" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_3" "#: .45 ACP" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_4" "#: 30 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_5" "#: 857 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_6" "#: 3.82 KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_7" "#: 15.2 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_8" "#: 919 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc1_9" "#: 584 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc2_1" "#: \$$_menu_money_item2" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_2" "#: GERMANY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_3" "#: 9MM PARABELLUM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_4" "#: 30 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_5" "#: 800 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_6" "#: 3.42KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_7" "#: 8 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_8" "#: 1132 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc2_9" "#: 637 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc3_1" "#: \$$_menu_money_item3" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_2" "#: GERMANY" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_3" "#: .45 ACP" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_4" "#: 25 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_5" "#: 600 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_6" "#: 2.27KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_7" "#: 15.2 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_8" "#: 1005 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc3_9" "#: 625 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_frame_txt_desc4_1" "#: \$$_menu_money_item4" "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_2" "#: BELGIUM" "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_3" "#: 5.7 x 28MM" "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_4" "#: 50 ROUNDS" "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_5" "#: 900 RPM" "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_6" "#: 3KG" "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_7" "#: 2 GRAMS" "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_8" "#: 2345 FEET/SECOND" "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
touch_addbutton "_menu_frame_txt_desc4_9" "#: 465 JOULES" "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc5_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc5_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc6_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc6_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc7_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc7_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

//touch_addbutton "_menu_frame_txt_desc8_1" "#: " "" 0.56 0.551111 0.84 0.586667 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_2" "#: " "" 0.56 0.586667 0.84 0.622222 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_3" "#: " "" 0.56 0.622222 0.84 0.657778 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_4" "#: " "" 0.56 0.657778 0.84 0.693333 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_5" "#: " "" 0.56 0.693333 0.84 0.728889 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_6" "#: " "" 0.56 0.728889 0.84 0.764444 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_7" "#: " "" 0.56 0.764444 0.84 0.8 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_8" "#: " "" 0.56 0.8 0.84 0.835556 240 180 24 255 4
//touch_addbutton "_menu_frame_txt_desc8_9" "#: " "" 0.56 0.835556 0.84 0.871111 240 180 24 255 4

touch_addbutton "_menu_txt_money" "#YOU HAVE \$$cscl_currentmoney" "_menu_refresh" 0.170000 0.106667 0.890000 0.160000 255 174 0 255 4
alias _menu_refresh "exec touch/buy_submachinegun_t.cfg"

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_data*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

//alias +menu_slot0 "touch_setcolor _menu_slot0 255 174 0 150"
//alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150"
//alias _menu_select_slot1 "_menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; if $cscl_currentmoney>=0;:_menu_show_confirm ; alias _menu_confirmed joinclass 1"

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame"
if $buymenu_stayon >= 1;:alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; _erase_frame; buy"

alias _menu_confirmed ""
alias _menu_show_confirm "touch_show _menu_confirm*"

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc1_*; if $cscl_currentmoney >= $_menu_money_item1;:_menu_show_confirm ; alias _menu_confirmed mac10"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_data2_*; touch_show _menu_frame_txt_desc2_*; if $cscl_currentmoney >= $_menu_money_item2;:_menu_show_confirm ; alias _menu_confirmed mp5"
alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc3_*; if $cscl_currentmoney >= $_menu_money_item3;:_menu_show_confirm ; alias _menu_confirmed ump45"
alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc4_*; if $cscl_currentmoney >= $_menu_money_item4;:_menu_show_confirm ; alias _menu_confirmed p90"
//alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc5_*; if $cscl_currentmoney >= $_menu_money_item5;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc6_*; if $cscl_currentmoney >= $_menu_money_item6;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot7 "_click; _menu_none; touch_setcolor _menu_slot7 255 174 0 150; touch_show _menu_frame_icn_class7; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc7_*; if $cscl_currentmoney >= $_menu_money_item7;:_menu_show_confirm ; alias _menu_confirmed "
//alias _menu_select_slot8 "_click; _menu_none; touch_setcolor _menu_slot8 255 174 0 150; touch_show _menu_frame_icn_class8; touch_show _menu_frame_txt_data1_*; touch_show _menu_frame_txt_desc8_*; if $cscl_currentmoney >= $_menu_money_item8;:_menu_show_confirm ; alias _menu_confirmed "

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/chooseteam.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150
set scenario_defined 0

alias _erase_frame "touch_removebutton _menu_*; _menu_off; hidescoreboard2; slot10"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
//touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
touch_addbutton "_menu_bg_body1" "*black" "" 0.100000 0.165000 0.390000 0.924444 0 0 0 150 6
touch_addbutton "_menu_bg_body2" "*black" "" 0.390000 0.835556 0.860000 0.924444 0 0 0 150 6
touch_addbutton "_menu_bg_body3" "*black" "" 0.860000 0.165000 0.900000 0.924444 0 0 0 150 6
touch_addbutton "_menu_bg_body4" "*black" "" 0.390000 0.165000 0.860000 0.213333 0 0 0 150 6
if $menu_bg_fill >= 1
:touch_removebutton _menu_bg_*
:touch_addbutton _menu_bg_body1 *black "" 0 0 0.390000 1 0 0 0 150 6
:touch_addbutton _menu_bg_body2 *black "" 0.390000 0.835556 0.860000 1 0 0 0 150 6
:touch_addbutton _menu_bg_body3 *black "" 0.860000 0 1 1 0 0 0 150 6
:touch_addbutton _menu_bg_body4 *black "" 0.390000 0 0.860000 0.213333 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "_menu_vip" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#SELECT TEAM" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "+menu_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 TERRORIST FORCES" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "+menu_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 CT FORCES" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "+menu_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 BECOME VIP" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
//touch_addbutton "_menu_slot4" "*white" "" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
//touch_addbutton "_menu_txt_slot4" "#4 SLOT" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
touch_addbutton "_menu_slot5" "*white" "+menu_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
touch_addbutton "_menu_txt_slot5" "#5 AUTO ASSIGN" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
touch_addbutton "_menu_slot6" "*white" "+menu_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
touch_addbutton "_menu_txt_slot6" "#6 SPECTATE" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
touch_addbutton "_menu_slot9" "*white" "+menu_slot9" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
touch_addbutton "_menu_txt_slot9" "#9 SHOW SCOREBOARD" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4
touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.860000 0.835556 0 0 0 200 260

if $cscl_mapprefix == as_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#VIP Assassination scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#Terrorists:;The Terrorists must eliminate the VIP before he reaches the;extraction point." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc2" "#Counter-Terrorists:;Escort the VIP to the extraction point, eliminating Terrorist forces;along the way." "" 0.400000 0.444444 0.850000 0.551111 255 174 0 255 4

if $cscl_mapprefix == cs_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#Hostage Rescue scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#Terrorists:;Prevent hostages from being rescued by Сounter-Terrorist forces." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc2" "#Counter-Terrorists:;Escort the hostages to the rescue zone." "" 0.400000 0.444444 0.850000 0.551111 255 174 0 255 4

if $cscl_mapprefix == de_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#Bomb Plant/Defuse scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#Terrorists:;A terrorist carrying C4 must blow up one of the payloads or;strategic objects." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc2" "#Counter-Terrorists:;Prevent Terrorists from blowing up payloads or strategic objects." "" 0.400000 0.444444 0.850000 0.551111 255 174 0 255 4

if $cscl_mapprefix == es_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#Terrorist Escape scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#Terrorists:;Find places with equipment and use it for defense during your;escape." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc2" "#Counter-Terrorists:;Do not let the Terrorists escape." "" 0.400000 0.444444 0.850000 0.551111 255 174 0 255 4

if $cscl_mapprefix == csde_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#Hostage Rescue and Bomb Plant/Defuse scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#Terrorists:;Destroy one of the payloads or strategic objects and don't let the;Counter-Terrorists rescue the hostages." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc2" "#Counter-Terrorists:;Rescue the hostages and prevent the terrorists from blowing up;any objects." "" 0.400000 0.444444 0.850000 0.551111 255 174 0 255 4

if $cscl_mapprefix == fy_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#Fight Yard scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#Pick up weapons from the ground or look for the buy zone and;kill each other." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4

if $cscl_mapprefix == he_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#Grenade Wars scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#You have to blow each other up with high explosive grenades." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4

if $cscl_mapprefix == awp_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#Sniper Wars scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#You have to kill enemies with a sniper rifle." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4

if $cscl_mapprefix == ka_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#Knife Arena scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#You have to kill enemies with a knife." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4

if $cscl_mapprefix == 1hp_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#1 Health Point scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#You need to kill enemies with a knife with one health point." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4

if $cscl_mapprefix == 35hp_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#35 Health Points scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#You need to kill enemies with a knife with 35 health points." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4

if $cscl_mapprefix == aim_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#Aim Training scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#On this map, you can train your aim on a specific type of weapon." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4

if $cscl_mapprefix == dm_
:scenario_defined 1
:touch_addbutton "_menu_frame_txt_title" "#Deathmatch scenario." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc1" "#The objective is simple - kill each other to death.;No additional tasks are provided." "" 0.400000 0.284444 0.850000 0.426667 255 174 0 255 4

if $scenario_defined != 1
:touch_addbutton "_menu_frame_txt_title" "#The map scenario is undefined." "" 0.400000 0.231111 0.850000 0.817778 255 174 0 255 4

alias +menu_slot0 "_click; touch_setcolor _menu_slot0 255 174 0 150"
alias -menu_slot0 "touch_setcolor _menu_slot0 0 0 0 150; slot10; _erase_frame"

alias +menu_slot1 "_click; touch_setcolor _menu_slot1 255 174 0 150"
alias -menu_slot1 "touch_setcolor _menu_slot1 0 0 0 150; jointeam 1; wait; wait; _erase_frame"

alias +menu_slot2 "_click; touch_setcolor _menu_slot2 255 174 0 150"
alias -menu_slot2 "touch_setcolor _menu_slot2 0 0 0 150; jointeam 2; wait; wait; _erase_frame"

alias +menu_slot3 "_click; touch_setcolor _menu_slot3 255 174 0 150"
alias -menu_slot3 "touch_setcolor _menu_slot3 0 0 0 150; jointeam 3; wait; wait; _erase_frame"

alias +menu_slot5 "_click; touch_setcolor _menu_slot5 255 174 0 150"
alias -menu_slot5 "touch_setcolor _menu_slot5 0 0 0 150; jointeam 5; wait; wait; _erase_frame"

alias +menu_slot6 "_click; touch_setcolor _menu_slot6 255 174 0 150"
alias -menu_slot6 "touch_setcolor _menu_slot6 0 0 0 150; jointeam 6; wait; wait; _erase_frame"

alias +menu_slot9 "_click; touch_setcolor _menu_slot9 255 174 0 150"
alias -menu_slot9 "touch_setcolor _menu_slot9 0 0 0 150; _menu_scores"

alias _menu_vip "_menu_vip_show"
alias _menu_vip_show "alias _menu_vip _menu_vip_hide; touch_show _menu_*slot3"
alias _menu_vip_hide "alias _menu_vip _menu_vip_show; touch_hide _menu_*slot3"

alias _menu_scores "_menu_scores_show"
alias _menu_scores_show "teammenu_showscores 1; alias _menu_scores _menu_scores_hide; touch_settexture _menu_txt_slot9 \"#9 HIDE SCOREBOARD\"; touch_setcolor _menu_frame 0 0 0 0; touch_hide _menu_frame_*; showscoreboard2 0.390000 0.860000 0.213333 0.835556 0 0 0 200"
alias _menu_scores_hide "teammenu_showscores 0; alias _menu_scores _menu_scores_show; touch_settexture _menu_txt_slot9 \"#9 SHOW SCOREBOARD\"; touch_setcolor _menu_frame 0 0 0 200; touch_show _menu_frame_*; hidescoreboard2"

if $cscl_mapprefix == as_
:_menu_vip_show
else
:_menu_vip_hide

if $teammenu_showscores >= 1
:_menu_scores_show

```

`3rdparty/cs16client-extras/touch/chooseteam_ct.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#CHOOSE A CLASS" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 SEAL TEAM 6" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 GSG-9" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 SAS" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 GIGN" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
if $gamedir == "czero"
:touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
:touch_addbutton "_menu_txt_slot5" "#5 SPETSNAZ" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
:touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
:touch_addbutton "_menu_txt_slot6" "#6 AUTO-SELECT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
else
:touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
:touch_addbutton "_menu_txt_slot5" "#5 AUTO-SELECT" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
//touch_addbutton "_menu_slot6" "*white" "" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
//touch_addbutton "_menu_txt_slot6" "#6 SPECTATE" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
//touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4
touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/urban.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/gsg9.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class3" "gfx/vgui/sas.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class4" "gfx/vgui/gign.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
if $gamedir == "czero"
:touch_addbutton "_menu_frame_icn_class5" "gfx/vgui/spetsnaz.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
:touch_addbutton "_menu_frame_icn_class6" "gfx/vgui/ct_random.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
else
:touch_addbutton "_menu_frame_icn_class5" "gfx/vgui/ct_random.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_txt_desc1" "#ST-6 (to be known later as DEVGRU) was founded in 1980 under ;the command of Lieutenant-Commander Richard Marcincko. ;ST-6 was placed on permanent alert to respond to terrorist;attacks against American targets worldwide." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
touch_addbutton "_menu_frame_txt_desc2" "#GSG-9 was born out of the tragic events that led to the death ;of several Israeli athletes during the 1972 Olympic games ;in Munich, Germany." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
touch_addbutton "_menu_frame_txt_desc3" "#The world-renowned British SAS was founded in the Second ;World War by a man named David Stirling. Their role during;WW2 involved gathering intelligence behind enemy lines and;executing sabotage strikes and assassinations against key targets." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
touch_addbutton "_menu_frame_txt_desc4" "#France's elite Counter-Terrorist unit, the GIGN, was designed;to be a fast response force that could decisively react to any;large-scale terrorist incident. Consisting of no more than 100;men, the GIGN has earned its reputation." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
if $gamedir == "czero"
:touch_addbutton "_menu_frame_txt_desc5" "#The primary missions of the Russian SPETSNAZ are:;acquiring intelligence on major economic and military;installations and either destroying them or putting them out;of action, organizing sabotage and acts of subversion," "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc5a" "#;;;;carrying out punitive operations against rebels, forming and;training insurgent detachments, etc." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc6" "#Auto-Select randomly selects a character model." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
else
:touch_addbutton "_menu_frame_txt_desc5" "#Auto-Select randomly selects a character model." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.620000 0.853333 0.840000 0.906667 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#CONFIRM THE SELECTION" "" 0.630000 0.871111 0.840000 0.906667 255 174 0 255 4

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

alias _menu_confirmed ""

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; touch_show _menu_confirm*; alias _menu_confirmed joinclass 1"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_desc2; touch_show _menu_confirm*; alias _menu_confirmed joinclass 2"
alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_desc3; touch_show _menu_confirm*; alias _menu_confirmed joinclass 3"
alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_desc4; touch_show _menu_confirm*; alias _menu_confirmed joinclass 4"
alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_desc5; touch_show _menu_frame_txt_desc5a; touch_show _menu_confirm*; alias _menu_confirmed joinclass 5"
alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_desc6; touch_show _menu_confirm*; alias _menu_confirmed joinclass 6"

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/chooseteam_tr.cfg`:

```cfg
// Coded by Alprnn357
touch_setclientonly 1
cmd_scripting 1
touch_set_stroke 1 255 174 0 150

alias _erase_frame "touch_removebutton _menu_*; _menu_off"
alias _menu_off "touch_setclientonly 0"
alias _click "play media/launch_select1.wav; vibrate 30"

touch_addbutton "_menu_bg_crn4" "gfx/vgui/round_corner_se.tga" "" 0.880000 0.924444 0.900000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_crn2" "gfx/vgui/round_corner_ne.tga" "" 0.880000 0.035556 0.900000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn1" "gfx/vgui/round_corner_nw.tga" "" 0.100000 0.035556 0.120000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_crn3" "gfx/vgui/round_corner_sw.tga" "" 0.100000 0.924444 0.120000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_top1" "*black" "" 0.120000 0.035556 0.880000 0.071111 0 0 0 150 6
touch_addbutton "_menu_bg_top2" "*black" "" 0.100000 0.071111 0.900000 0.160000 0 0 0 150 6
touch_addbutton "_menu_bg_bottom" "*black" "" 0.120000 0.924444 0.880000 0.960000 0 0 0 150 6
touch_addbutton "_menu_bg_body" "*black" "" 0.100000 0.165000 0.900000 0.924444 0 0 0 150 6
if $menu_bg_fill >= 1;:touch_removebutton _menu_bg_*;:touch_addbutton _menu_bg_body *black "" 0 0 1 1 0 0 0 150 6
touch_addbutton "_menu_bg_icn_logo" "gfx/vgui/cs_logo.tga" "" 0.110000 0.053333 0.160000 0.142222 255 174 0 255 6
touch_addbutton "_menu_bg_txt_logo" "#CHOOSE A CLASS" "" 0.170000 0.071111 0.890000 0.142222 255 174 0 255 6

//touch_addbutton "_menu_txt_title" "#THE TITLE" "" 0.140000 0.177778 0.860000 0.213333 255 174 0 255 4
touch_addbutton "_menu_slot1" "*white" "_menu_select_slot1" 0.140000 0.213333 0.360000 0.266667 0 0 0 150 260
touch_addbutton "_menu_txt_slot1" "#1 PHOENIX CONNEXION" "" 0.150000 0.231111 0.360000 0.266667 255 174 0 255 4
touch_addbutton "_menu_slot2" "*white" "_menu_select_slot2" 0.140000 0.284444 0.360000 0.337778 0 0 0 150 260
touch_addbutton "_menu_txt_slot2" "#2 ELITE CREW" "" 0.150000 0.302222 0.360000 0.337778 255 174 0 255 4
touch_addbutton "_menu_slot3" "*white" "_menu_select_slot3" 0.140000 0.355556 0.360000 0.408889 0 0 0 150 260
touch_addbutton "_menu_txt_slot3" "#3 ARCTIC AVENGERS" "" 0.150000 0.373333 0.360000 0.408889 255 174 0 255 4
touch_addbutton "_menu_slot4" "*white" "_menu_select_slot4" 0.140000 0.426667 0.360000 0.480000 0 0 0 150 260
touch_addbutton "_menu_txt_slot4" "#4 GUERILLA WARFARE" "" 0.150000 0.444444 0.360000 0.480000 255 174 0 255 4
if $gamedir == "czero"
:touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
:touch_addbutton "_menu_txt_slot5" "#5 MIDWEST MILITIA" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
:touch_addbutton "_menu_slot6" "*white" "_menu_select_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
:touch_addbutton "_menu_txt_slot6" "#6 AUTO-SELECT" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
else
:touch_addbutton "_menu_slot5" "*white" "_menu_select_slot5" 0.140000 0.497778 0.360000 0.551111 0 0 0 150 260
:touch_addbutton "_menu_txt_slot5" "#5 AUTO-SELECT" "" 0.150000 0.515556 0.360000 0.551111 255 174 0 255 4
//touch_addbutton "_menu_slot6" "*white" "+menu_slot6" 0.140000 0.568889 0.360000 0.622222 0 0 0 150 260
//touch_addbutton "_menu_txt_slot6" "#6 SPECTATE" "" 0.150000 0.586667 0.360000 0.622222 255 174 0 255 4
//touch_addbutton "_menu_slot7" "*white" "" 0.140000 0.640000 0.360000 0.693333 0 0 0 150 260
//touch_addbutton "_menu_txt_slot7" "#7 SLOT" "" 0.150000 0.657778 0.360000 0.693333 255 174 0 255 4
//touch_addbutton "_menu_slot8" "*white" "" 0.140000 0.711111 0.360000 0.764444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot8" "#8 SLOT" "" 0.150000 0.728889 0.360000 0.764444 255 174 0 255 4
//touch_addbutton "_menu_slot9" "*white" "" 0.140000 0.782222 0.360000 0.835556 0 0 0 150 260
//touch_addbutton "_menu_txt_slot9" "#9 SLOT" "" 0.150000 0.800000 0.360000 0.835556 255 174 0 255 4
//touch_addbutton "_menu_slot0" "*white" "+menu_slot0" 0.14 0.871111 0.36 0.924444 0 0 0 150 260
//touch_addbutton "_menu_txt_slot0" "#0 CANCEL" "" 0.15 0.888889 0.36 0.924444 255 174 0 255 4
touch_addbutton "_menu_frame" "*white" "" 0.390000 0.213333 0.840000 0.551111 0 0 0 150 260
touch_addbutton "_menu_frame_icn_class1" "gfx/vgui/terror.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class2" "gfx/vgui/leet.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class3" "gfx/vgui/arctic.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_icn_class4" "gfx/vgui/guerilla.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
if $gamedir == "czero"
:touch_addbutton "_menu_frame_icn_class5" "gfx/vgui/militia.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
:touch_addbutton "_menu_frame_icn_class6" "gfx/vgui/t_random.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
else
:touch_addbutton "_menu_frame_icn_class5" "gfx/vgui/t_random.tga" "" 0.480000 0.215333 0.750000 0.549111 255 255 255 255 4
touch_addbutton "_menu_frame_txt_desc1" "#Having established a reputation for killing anyone that gets;in their way, the Phoenix Faction is one of the most feared;terrorist groups in Eastern Europe. Formed shortly after the;breakup of the USSR." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
touch_addbutton "_menu_frame_txt_desc2" "#Middle Eastern fundamentalist group bent on world domination;and various other evil deeds." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
touch_addbutton "_menu_frame_txt_desc3" "#Swedish terrorist faction founded in 1977. Famous for their ;bombing of the Canadian embassy in 1990." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
touch_addbutton "_menu_frame_txt_desc4" "#A terrorist faction founded in the Middle East, this group has;a reputation for ruthlessness. Their disgust for the American;lifestyle was demonstrated in their 1982 bombing of a school;bus full of Rock and Roll musicians." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
if $gamedir == "czero"
:touch_addbutton "_menu_frame_txt_desc5" "#The Midwest Militia is a right-wing extremist movement;consisting of formal and informal armed paramilitary groups.;This anti-government group was founded in 1993 after the;standoff in Waco, Texas." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
:touch_addbutton "_menu_frame_txt_desc6" "#Auto-Select randomly selects a character model." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
else
:touch_addbutton "_menu_frame_txt_desc5" "#Auto-Select randomly selects a character model." "" 0.390000 0.568889 0.840000 0.835556 255 174 0 255 4
touch_addbutton "_menu_confirm" "*white" "+menu_confirm" 0.620000 0.853333 0.840000 0.906667 0 0 0 150 260
touch_addbutton "_menu_confirm_txt" "#CONFIRM THE SELECTION" "" 0.630000 0.871111 0.840000 0.906667 255 174 0 255 4

alias _menu_none "touch_setcolor _menu_slot* 0 0 0 150; touch_hide _menu_frame_icn_class*; touch_hide _menu_frame_txt_desc*; touch_hide _menu_confirm*"
_menu_none

alias _menu_confirmed ""

alias _menu_select_slot1 "_click; _menu_none; touch_setcolor _menu_slot1 255 174 0 150; touch_show _menu_frame_icn_class1; touch_show _menu_frame_txt_desc1; touch_show _menu_confirm*; alias _menu_confirmed joinclass 1"
alias _menu_select_slot2 "_click; _menu_none; touch_setcolor _menu_slot2 255 174 0 150; touch_show _menu_frame_icn_class2; touch_show _menu_frame_txt_desc2; touch_show _menu_confirm*; alias _menu_confirmed joinclass 2"
alias _menu_select_slot3 "_click; _menu_none; touch_setcolor _menu_slot3 255 174 0 150; touch_show _menu_frame_icn_class3; touch_show _menu_frame_txt_desc3; touch_show _menu_confirm*; alias _menu_confirmed joinclass 3"
alias _menu_select_slot4 "_click; _menu_none; touch_setcolor _menu_slot4 255 174 0 150; touch_show _menu_frame_icn_class4; touch_show _menu_frame_txt_desc4; touch_show _menu_confirm*; alias _menu_confirmed joinclass 4"
alias _menu_select_slot5 "_click; _menu_none; touch_setcolor _menu_slot5 255 174 0 150; touch_show _menu_frame_icn_class5; touch_show _menu_frame_txt_desc5; touch_show _menu_confirm*; alias _menu_confirmed joinclass 5"
alias _menu_select_slot6 "_click; _menu_none; touch_setcolor _menu_slot6 255 174 0 150; touch_show _menu_frame_icn_class6; touch_show _menu_frame_txt_desc6; touch_show _menu_confirm*; alias _menu_confirmed joinclass 6"

alias +menu_confirm "_click; touch_setcolor _menu_confirm 255 174 0 150"
alias -menu_confirm "touch_setcolor _menu_confirm 0 0 0 150; _menu_confirmed; wait; wait; _erase_frame"

```

`3rdparty/cs16client-extras/touch/cmd/cmd.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
_reset_menu
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_file_name "cmd.cfg"
alias build_menu "exec touch/customcmd"
alias build_language "exec touch/custom/my_menu-language"
set _menu_id my_menu-1-cmd
set _menu_level 1
set _menu_min 3
set _menu_max 8

build_language

set _menu_type_3 1
set _menu_txt_3 "Game Settings"
set _menu_cmd_3 "exec $menu_root_path/my_menu-2-game"
set _menu_icn_3 "touch/cmd/right.tga"

set _menu_type_4 1
set _menu_txt_4 "Graphics"
set _menu_cmd_4 "exec $menu_root_path/my_menu-2-graphic"
set _menu_icn_4 "touch/cmd/right.tga"

set _menu_type_5 1
set _menu_txt_5 "Server Settings"
set _menu_cmd_5 "exec $menu_root_path/my_menu-2-server"
set _menu_icn_5 "touch/cmd/right.tga"

set _menu_type_6 1
set _menu_txt_6 "Connection"
set _menu_cmd_6 "exec $menu_root_path/my_menu-2-connection"
set _menu_icn_6 "touch/cmd/right.tga"

set _menu_type_7 1
set _menu_txt_7 "Record Demo"
set _menu_cmd_7 "exec $menu_root_path/my_menu-2-demo"
set _menu_icn_7 "touch/cmd/right.tga"

set _menu_type_8 1
set _menu_txt_8 "$_menu_txt_exit"
set _menu_cmd_8 "_erase_frame"
set _menu_icn_8 ""

build_menu

if $enable_controls = 1;:touch_setclientonly 0;else;:touch_setclientonly 1
exec touch/custom/my_menu-5-controls.cfg

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-2-connection.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-2-connection
set _menu_level 2
set _menu_min 6
set _menu_max 10

set _menu_type_6 3
set _menu_txt_6 "Rate"
set _menu_cmd_6 "rate"
set _menu_f6 $rate

set _menu_type_7 3
set _menu_txt_7 "Update Rate"
set _menu_cmd_7 "cl_updaterate"
set _menu_f7 $cl_updaterate

set _menu_type_8 3
set _menu_txt_8 "Command Rate"
set _menu_cmd_8 "cl_cmdrate"
set _menu_f8 $cl_cmdrate

set _menu_type_9 2
set _menu_txt_9 "Net Speeds"
set _menu_cmd_9 "net_speeds"
set _menu_f9 $net_speeds

set _menu_type_10 2
set _menu_txt_10 "Net Graph"
set _menu_cmd_10 "net_graph"
set _menu_f10 $net_graph

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-2-demo.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-2-demo
set _menu_level 2
set _menu_min 7
set _menu_max 9

set _menu_type_7 1
set _menu_txt_7 "Start recording"
set _menu_cmd_7 "messagemode record; _erase_frame"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Stop recording"
set _menu_cmd_8 "stop; _erase_frame"
set _menu_icn_8 ""

set _menu_type_9 1
set _menu_txt_9 "Play demo"
set _menu_cmd_9 "messagemode playdemo; _erase_frame"
set _menu_icn_9 ""

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-2-game.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-2-game
set _menu_level 2
set _menu_min 3
set _menu_max 9

set _menu_type_3 1
set _menu_txt_3 "HUD"
set _menu_cmd_3 "exec $menu_root_path/my_menu-3-hud"
set _menu_icn_3 "touch/cmd/right.tga"

set _menu_type_4 1
set _menu_txt_4 "Scoreboard"
set _menu_cmd_4 "exec $menu_root_path/my_menu-3-scoreboard"
set _menu_icn_4 "touch/cmd/right.tga"

set _menu_type_5 1
set _menu_txt_5 "Console"
set _menu_cmd_5 "exec $menu_root_path/my_menu-3-console"
set _menu_icn_5 "touch/cmd/right.tga"

set _menu_type_6 1
set _menu_txt_6 "Numerical menu"
set _menu_cmd_6 "exec $menu_root_path/my_menu-3-numerical"
set _menu_icn_6 "touch/cmd/right.tga"

set _menu_type_7 1
set _menu_txt_7 "Radar"
set _menu_cmd_7 "exec $menu_root_path/my_menu-3-radar"
set _menu_icn_7 "touch/cmd/right.tga"

set _menu_type_8 1
set _menu_txt_8 "Crosshair"
set _menu_cmd_8 "exec $menu_root_path/my_menu-3-crosshair"
set _menu_icn_8 "touch/cmd/right.tga"

set _menu_type_9 1
set _menu_txt_9 "Voice"
set _menu_cmd_9 "exec $menu_root_path/my_menu-3-voice"
set _menu_icn_9 "touch/cmd/right.tga"

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-2-graphic.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-2-graphic
set _menu_level 2
set _menu_min 4
set _menu_max 10

set _menu_type_4 1
set _menu_txt_4 "Texture Quality"
set _menu_cmd_4 "exec $menu_root_path/my_menu-3-texture"
set _menu_icn_4 "touch/cmd/right.tga"

set _menu_type_5 1
set _menu_txt_5 "Models"
set _menu_cmd_5 "exec $menu_root_path/my_menu-3-model"
set _menu_icn_5 "touch/cmd/right.tga"

set _menu_type_6 1
set _menu_txt_6 "FPS Counter"
set _menu_cmd_6 "exec $menu_root_path/my_menu-3-fps"
set _menu_icn_6 "touch/cmd/right.tga"

set _menu_type_7 3
set _menu_txt_7 "Max FPS"
set _menu_cmd_7 "fps_max"
set _menu_f7 $fps_max

set _menu_type_8 3
set _menu_txt_8 "Max decals"
set _menu_cmd_8 "r_decals"
set _menu_f8 $r_decals

set _menu_type_9 2
set _menu_txt_9 "Weather"
set _menu_cmd_9 "cl_weather"
set _menu_f9 $cl_weather

set _menu_type_10 2
set _menu_txt_10 "Shadows"
set _menu_cmd_10 "cl_shadows"
set _menu_f10 $cl_shadows

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-2-server.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-2-server
set _menu_level 2
set _menu_min 5
set _menu_max 10

set _menu_type_5 1
set _menu_txt_5 "Maps"
set _menu_cmd_5 "exec $menu_root_path/my_menu-3-maps"
set _menu_icn_5 "touch/cmd/right.tga"

set _menu_type_6 1
set _menu_txt_6 "CVars"
set _menu_cmd_6 "exec $menu_root_path/my_menu-3-cvars"
set _menu_icn_6 "touch/cmd/right.tga"

set _menu_type_7 1
set _menu_txt_7 "Restart"
set _menu_cmd_7 "_erase_frame; restart"
set _menu_icn_7 ""

set _menu_type_8 3
set _menu_txt_8 "Restart; in ... seconds"
set _menu_cmd_8 "sv_restartround"
set _menu_f8 $sv_restartround

set _menu_type_9 1
set _menu_txt_9 "Reconnect"
set _menu_cmd_9 "_erase_frame; reconnect"
set _menu_icn_9 ""

set _menu_type_10 1
set _menu_txt_10 "Disconnect"
set _menu_cmd_10 "_erase_frame; disconnect"
set _menu_icn_10 ""

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-console.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-console
set _menu_level 3
set _menu_min 4
set _menu_max 10

set _menu_type_4 3
set _menu_txt_4 "Text color"
set _menu_cmd_4 "con_color"
set _menu_f4 $con_color

set _menu_type_5 3
set _menu_txt_5 "Notify time"
set _menu_cmd_5 "con_notifytime"
set _menu_f5 $con_notifytime

set _menu_type_6 3
set _menu_txt_6 "Charset"
set _menu_cmd_6 "con_charset"
set _menu_f6 $con_charset

set _menu_type_7 3
set _menu_txt_7 "Font number"
set _menu_cmd_7 "con_fontnum"
set _menu_f7 $con_fontnum

set _menu_type_8 3
set _menu_txt_8 "Font texture; scale"
set _menu_cmd_8 "con_fontscale"
set _menu_f8 $con_fontscale

set _menu_type_9 3
set _menu_txt_9 "Font render"
set _menu_cmd_9 "con_fontrender"
set _menu_f9 $con_fontrender

set _menu_type_10 3
set _menu_txt_10 "Font size"
set _menu_cmd_10 "con_fontsize"
set _menu_f10 $con_fontsize

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-crosshair.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-crosshair
set _menu_level 3
set _menu_min 6
set _menu_max 10

set _menu_type_6 3
set _menu_txt_6 "Color"
set _menu_cmd_6 "cl_crosshair_color"
set _menu_f6 $cl_crosshair_color

set _menu_type_7 1
set _menu_txt_7 "Size"
set _menu_cmd_7 "exec $menu_root_path/my_menu-4-cross-size"
set _menu_icn_7 "touch/cmd/right.tga"

set _menu_type_8 2
set _menu_txt_8 "Dynamic"
set _menu_cmd_8 "cl_dynamiccrosshair"
set _menu_f8 $cl_dynamiccrosshair

set _menu_type_9 2
set _menu_txt_9 "Transparent"
set _menu_cmd_9 "cl_crosshair_translucent"
set _menu_f9 $cl_crosshair_translucent

set _menu_type_10 1
set _menu_txt_10 "Advanced crosshair"
set _menu_cmd_10 "exec $menu_root_path/my_menu-4-xhair"
set _menu_icn_10 "touch/cmd/right.tga"

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-cvars.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-cvars
set _menu_level 3
set _menu_min 5
set _menu_max 10

set _menu_type_5 1
set _menu_txt_5 "Log CVars"
set _menu_cmd_5 "exec $menu_root_path/my_menu-4-cvar0"
set _menu_icn_5 "touch/cmd/right.tga"

set _menu_type_6 1
set _menu_txt_6 "Server CVars"
set _menu_cmd_6 "exec $menu_root_path/my_menu-4-cvar1"
set _menu_icn_6 "touch/cmd/right.tga"

set _menu_type_7 1
set _menu_txt_7 "Team CVars"
set _menu_cmd_7 "exec $menu_root_path/my_menu-4-cvar2"
set _menu_icn_7 "touch/cmd/right.tga"

set _menu_type_8 1
set _menu_txt_8 "Game CVars"
set _menu_cmd_8 "exec $menu_root_path/my_menu-4-cvar3"
set _menu_icn_8 "touch/cmd/right.tga"

set _menu_type_9 1
set _menu_txt_9 "Map CVars"
set _menu_cmd_9 "exec $menu_root_path/my_menu-4-cvar4"
set _menu_icn_9 "touch/cmd/right.tga"

set _menu_type_10 1
set _menu_txt_10 "Other CVars"
set _menu_cmd_10 "exec $menu_root_path/my_menu-4-cvar5"
set _menu_icn_10 "touch/cmd/right.tga"

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-fps.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-fps
set _menu_level 3
set _menu_min 6
set _menu_max 8

set _menu_type_6 1
set _menu_txt_6 "Hide"
set _menu_cmd_6 "cl_showfps 0"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "Show"
set _menu_cmd_7 "cl_showfps 1"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Show detailed"
set _menu_cmd_8 "cl_showfps 2"
set _menu_icn_8 ""

build_menu

if $cl_showfps = 0;:touch_setcolor _menu_S6_my_menu-3-fps 156 77 20 180
if $cl_showfps = 1;:touch_setcolor _menu_S7_my_menu-3-fps 156 77 20 180
if $cl_showfps = 2;:touch_setcolor _menu_S8_my_menu-3-fps 156 77 20 180

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-hud.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-hud
set _menu_level 3
set _menu_min 3
set _menu_max 9

set _menu_type_3 2
set _menu_txt_3 "Draw HUD"
set _menu_cmd_3 "hud_draw"
set _menu_f3 $hud_draw

set _menu_type_4 2
set _menu_txt_4 "Fast weapon; switch"
set _menu_cmd_4 "hud_fastswitch"
set _menu_f4 $hud_fastswitch

set _menu_type_5 2
set _menu_txt_5 "Saytext"
set _menu_cmd_5 "hud_saytext"
set _menu_f5 $hud_saytext

set _menu_type_6 2
set _menu_txt_6 "Textmode"
set _menu_cmd_6 "hud_textmode"
set _menu_f6 $hud_textmode

set _menu_type_7 2
set _menu_txt_7 "Center player; information"
set _menu_cmd_7 "hud_centerid"
set _menu_f7 $hud_centerid

set _menu_type_8 3
set _menu_txt_8 "HUD Scale; (restart to apply)"
set _menu_cmd_8 "hud_scale"
set _menu_f8 $hud_scale

set _menu_type_9 3
set _menu_txt_9 "HUD Color"
set _menu_cmd_9 "hud_color"
set _menu_f9 $hud_color

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-maps.cfg`:

```cfg
//=======================================================================
// TOUCH RADIO MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-maps
set _menu_level 3
set _menu_min 3
set _menu_max 9

set _menu_type_3 1
set _menu_txt_3 "de_dust2"
set _menu_cmd_3 "changelevel de_dust2"
set _menu_icn_3 ""

set _menu_type_4 1
set _menu_txt_4 "de_inferno"
set _menu_cmd_4 "changelevel de_inferno"
set _menu_icn_4 ""

set _menu_type_5 1
set _menu_txt_5 "de_mirage"
set _menu_cmd_5 "changelevel de_mirage"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "de_nuke"
set _menu_cmd_6 "changelevel de_nuke"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "de_train"
set _menu_cmd_7 "changelevel de_train"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Change map to ..."
set _menu_cmd_8 "messagemode changelevel"
set _menu_icn_8 ""

set _menu_type_9 1
set _menu_txt_9 "Show full maps list"
set _menu_cmd_9 "maps *;wait;toggleconsole"
set _menu_icn_9 ""

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-model.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-model
set _menu_level 3
set _menu_min 5
set _menu_max 6

set _menu_type_5 2
set _menu_txt_5 "Himodels"
set _menu_cmd_5 "cl_himodels"
set _menu_f5 $cl_himodels

set _menu_type_6 2
set _menu_txt_6 "Minmodels"
set _menu_cmd_6 "cl_minmodels"
set _menu_f6 $cl_minmodels

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-numerical.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-numerical
set _menu_level 3
set _menu_min 6
set _menu_max 10

set _menu_type_6 1
set _menu_txt_6 "Disabled"
set _menu_cmd_6 "numericalmenu 0"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "Center"
set _menu_cmd_7 "numericalmenu 1"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Bottom; 2 lines"
set _menu_cmd_8 "numericalmenu 2"
set _menu_icn_8 ""

set _menu_type_9 1
set _menu_txt_9 "Bottom; 1 line"
set _menu_cmd_9 "numericalmenu 3"
set _menu_icn_9 ""

set _menu_type_10 2
set _menu_txt_10 "Hide other; buttons"
set _menu_cmd_10 "numericalmenu_clientonly"
set _menu_f10 $numericalmenu_clientonly

build_menu

if $numericalmenu = 0;:touch_setcolor _menu_S6_my_menu-3-numerical 156 77 20 180
if $numericalmenu = 1;:touch_setcolor _menu_S7_my_menu-3-numerical 156 77 20 180
if $numericalmenu = 2;:touch_setcolor _menu_S8_my_menu-3-numerical 156 77 20 180
if $numericalmenu = 3;:touch_setcolor _menu_S9_my_menu-3-numerical 156 77 20 180


```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-radar.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-radar
set _menu_level 3
set _menu_min 7
set _menu_max 9

set _menu_type_7 1
set _menu_txt_7 "Hide"
set _menu_cmd_7 "hideradar"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Show"
set _menu_cmd_8 "drawradar"
set _menu_icn_8 ""

set _menu_type_9 2
set _menu_txt_9 "Solid"
set _menu_cmd_9 "cl_radartype"
set _menu_f9 $cl_radartype

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-scoreboard.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-scoreboard
set _menu_level 3
set _menu_min 4
set _menu_max 6

set _menu_type_4 1
set _menu_txt_4 "Short"
set _menu_cmd_4 "checkscoreboard 2"
set _menu_icn_4 ""

set _menu_type_5 1
set _menu_txt_5 "Full"
set _menu_cmd_5 "checkscoreboard 1"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "Classic"
set _menu_cmd_6 "checkscoreboard 3"
set _menu_icn_6 ""

build_menu

if $checkscoreboard = 2;:touch_setcolor _menu_S4_my_menu-3-scoreboard 156 77 20 180
if $checkscoreboard = 1;:touch_setcolor _menu_S5_my_menu-3-scoreboard 156 77 20 180
if $checkscoreboard = 3;:touch_setcolor _menu_S6_my_menu-3-scoreboard 156 77 20 180

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-texture.cfg`:

```cfg
//=======================================================================
// TOUCH COMMAND MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-texture
set _menu_level 3
set _menu_min 4
set _menu_max 6

set _menu_type_4 1
set _menu_txt_4 "Low"
set _menu_cmd_4 "gl_texture_nearest 1"
set _menu_icn_4 ""

set _menu_type_5 1
set _menu_txt_5 "Normal"
set _menu_cmd_5 "gl_texture_nearest 0"
set _menu_icn_5 ""

set _menu_type_6 2
set _menu_txt_6 "Detail; textures"
set _menu_cmd_6 "r_detailtextures"
set _menu_f6 $r_detailtextures

build_menu

if $gl_texture_nearest = 0;:touch_setcolor _menu_S4_my_menu-3-texture 156 77 20 180
if $gl_texture_nearest = 1;:touch_setcolor _menu_S5_my_menu-3-texture 156 77 20 180

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-3-voice.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-3-voice
set _menu_level 3
set _menu_min 5
set _menu_max 10

set _menu_type_5 2
set _menu_txt_5 "Enable voice; chat"
set _menu_cmd_5 "voice_enable"
set _menu_f5 $voice_enable

set _menu_type_6 2
set _menu_txt_6 "Loopback to; the speaker"
set _menu_cmd_6 "voice_loopback"
set _menu_f6 $voice_loopback

set _menu_type_7 2
set _menu_txt_7 "Input from; .wav file"
set _menu_cmd_7 "voice_inputfromfile"
set _menu_f7 $voice_inputfromfile

set _menu_type_8 3
set _menu_txt_8 "Volume scale"
set _menu_cmd_8 "voice_scale"
set _menu_f8 $voice_scale

set _menu_type_9 3
set _menu_txt_9 "Voice gain; (maximum)"
set _menu_cmd_9 "voice_maxgain"
set _menu_f9 $voice_maxgain

set _menu_type_10 3
set _menu_txt_10 "Voice gain; (average)"
set _menu_cmd_10 "voice_avggain"
set _menu_f10 $voice_avggain

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-4-cross-size.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-4-cross-size
set _menu_level 4
set _menu_min 7
set _menu_max 10

set _menu_type_7 1
set _menu_txt_7 "Auto"
set _menu_cmd_7 "cl_crosshair_size auto"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Small"
set _menu_cmd_8 "cl_crosshair_size small"
set _menu_icn_8 ""

set _menu_type_9 1
set _menu_txt_9 "Medium"
set _menu_cmd_9 "cl_crosshair_size medium"
set _menu_icn_9 ""

set _menu_type_10 1
set _menu_txt_10 "Large"
set _menu_cmd_10 "cl_crosshair_size large"
set _menu_icn_10 ""

build_menu

if $cl_crosshair_size = auto;:touch_setcolor _menu_S7_my_menu-4-cross-size 156 77 20 180
if $cl_crosshair_size = small;:touch_setcolor _menu_S8_my_menu-4-cross-size 156 77 20 180
if $cl_crosshair_size = medium;:touch_setcolor _menu_S9_my_menu-4-cross-size 156 77 20 180
if $cl_crosshair_size = large;:touch_setcolor _menu_S0_my_menu-4-cross-size 156 77 20 180

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-4-cvar0.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-4-cvar0
set _menu_level 4
set _menu_min 5
set _menu_max 8

set _menu_type_5 1
set _menu_txt_5 "Log detail"
set _menu_cmd_5 "exec $menu_root_path/my_menu-5-cvar0-2"
set _menu_icn_5 "touch/cmd/right.tga"

set _menu_type_6 2
set _menu_txt_6 "Log file"
set _menu_cmd_6 "mp_logfile"
set _menu_f6 $mp_logfile

set _menu_type_7 2
set _menu_txt_7 "Log echo"
set _menu_cmd_7 "mp_logecho"
set _menu_f7 $mp_logecho

set _menu_type_8 2
set _menu_txt_8 "Log messages"
set _menu_cmd_8 "mp_logmessages"
set _menu_f8 $mp_logmessages

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-4-cvar1.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-4-cvar1
set _menu_level 4
set _menu_min 3
set _menu_max 10

set _menu_type_3 3
set _menu_txt_3 "Server name"
set _menu_cmd_3 "hostname"
set _menu_f3 $hostname

set _menu_type_4 3
set _menu_txt_4 "Max players"
set _menu_cmd_4 "maxplayers"
set _menu_f4 $maxplayers

set _menu_type_5 3
set _menu_txt_5 "Default map"
set _menu_cmd_5 "defaultmap"
set _menu_f5 $defaultmap

set _menu_type_6 2
set _menu_txt_6 "Cheats"
set _menu_cmd_6 "sv_cheats"
set _menu_f6 $sv_cheats

set _menu_type_7 2
set _menu_txt_7 "Entity Tools"
set _menu_cmd_7 "sv_enttools_enable"
set _menu_f7 $sv_enttools_enable

set _menu_type_8 2
set _menu_txt_8 "Air move"
set _menu_cmd_8 "sv_airmove"
set _menu_f8 $sv_airmove

set _menu_type_9 2
set _menu_txt_9 "Enable voice; (server)"
set _menu_cmd_9 "sv_voiceenable"
set _menu_f9 $sv_voiceenable

set _menu_type_10 1
set _menu_txt_10 "Voice quality level; (server)"
set _menu_cmd_10 "exec $menu_root_path/my_menu-5-voicequality"
set _menu_icn_10 "touch/cmd/right.tga"

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-4-cvar2.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-4-cvar2
set _menu_level 4
set _menu_min 1
set _menu_max 10

set _menu_type_1 2
set _menu_txt_1 "Allow; spectators"
set _menu_cmd_1 "allow_spectators"
set _menu_f1 $allow_spectators

set _menu_type_2 1
set _menu_txt_2 "Players can join team"
set _menu_cmd_2 "exec $menu_root_path/my_menu-5-cvar2-2"
set _menu_icn_2 "touch/cmd/right.tga"

set _menu_type_3 2
set _menu_txt_3 "Friendly fire"
set _menu_cmd_3 "mp_friendlyfire"
set _menu_f3 $mp_friendlyfire

set _menu_type_4 3
set _menu_txt_4 "Team limit"
set _menu_cmd_4 "mp_limitteams"
set _menu_f4 $mp_limitteams

set _menu_type_5 2
set _menu_txt_5 "Auto balance"
set _menu_cmd_5 "mp_autoteambalance"
set _menu_f5 $mp_autoteambalance

set _menu_type_6 2
set _menu_txt_6 "Auto kick"
set _menu_cmd_6 "mp_autokick"
set _menu_f6 $mp_autokick

set _menu_type_7 3
set _menu_txt_7 "Auto kick; timeout"
set _menu_cmd_7 "mp_autokick_timeout"
set _menu_f7 $mp_autokick_timeout

set _menu_type_8 3
set _menu_txt_8 "Kick percent"
set _menu_cmd_8 "mp_kickpercent"
set _menu_f8 $mp_kickpercent

set _menu_type_9 2
set _menu_txt_9 "Force respawn"
set _menu_cmd_9 "mp_forcerespawn"
set _menu_f9 $mp_forcerespawn

set _menu_type_10 2
set _menu_txt_10 "Free For All"
set _menu_cmd_10 "mp_freeforall"
set _menu_f10 $mp_freeforall

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-4-cvar3.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-4-cvar3
set _menu_level 4
set _menu_min 1
set _menu_max 10

set _menu_type_1 3
set _menu_txt_1 "Max rounds"
set _menu_cmd_1 "mp_maxrounds"
set _menu_f1 $mp_maxrounds

set _menu_type_2 3
set _menu_txt_2 "Round restart; delay"
set _menu_cmd_2 "mp_round_restart_delay"
set _menu_f2 $mp_round_restart_delay

set _menu_type_3 2
set _menu_txt_3 "Infinite; rounds"
set _menu_cmd_3 "mp_round_infinite"
set _menu_f3 $mp_round_infinite

set _menu_type_4 3
set _menu_txt_4 "Round over"
set _menu_cmd_4 "mp_roundover"
set _menu_f4 $mp_roundover

set _menu_type_5 3
set _menu_txt_5 "Round time"
set _menu_cmd_5 "mp_roundtime"
set _menu_f5 $mp_roundtime

set _menu_type_6 3
set _menu_txt_6 "Buy time"
set _menu_cmd_6 "mp_buytime"
set _menu_f6 $mp_buytime

set _menu_type_7 3
set _menu_txt_7 "C4 timer"
set _menu_cmd_7 "mp_c4timer"
set _menu_f7 $mp_c4timer

set _menu_type_8 3
set _menu_txt_8 "Freeze time"
set _menu_cmd_8 "mp_freezetime"
set _menu_f8 $mp_freezetime

set _menu_type_9 3
set _menu_txt_9 "Max money"
set _menu_cmd_9 "mp_maxmoney"
set _menu_f9 $mp_maxmoney

set _menu_type_10 3
set _menu_txt_10 "Start money"
set _menu_cmd_10 "mp_startmoney"
set _menu_f10 $mp_startmoney

build_menu

exec $menu_root_path/my_menu-5-cvar3-2

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-4-cvar4.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-4-cvar4
set _menu_level 4
set _menu_min 4
set _menu_max 10

set _menu_type_4 2
set _menu_txt_4 "Kill in a; filled spawn"
set _menu_cmd_4 "mp_kill_filled_spawn"
set _menu_f4 $mp_kill_filled_spawn

set _menu_type_5 2
set _menu_txt_5 "Legacy bomb; target touch"
set _menu_cmd_5 "mp_legacy_bombtarget_touch"
set _menu_f5 $mp_legacy_bombtarget_touch

set _menu_type_6 2
set _menu_txt_6 "Footsteps"
set _menu_cmd_6 "mp_footsteps"
set _menu_f6 $mp_footsteps

set _menu_type_7 2
set _menu_txt_7 "Hurtable; hostages"
set _menu_cmd_7 "mp_hostage_hurtable"
set _menu_f7 $mp_hostage_hurtable

set _menu_type_8 3
set _menu_txt_8 "Hostage; penalty"
set _menu_cmd_8 "mp_hostagepenalty"
set _menu_f8 $mp_hostagepenalty

set _menu_type_9 3
set _menu_txt_9 "Item stay time"
set _menu_cmd_9 "mp_item_staytime"
set _menu_f9 $mp_item_staytime

set _menu_type_10 2
set _menu_txt_10 "Flashlight"
set _menu_cmd_10 "mp_flashlight"
set _menu_f10 $mp_flashlight

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-4-cvar5.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-4-cvar5
set _menu_level 4
set _menu_min 1
set _menu_max 10

set _menu_type_1 3
set _menu_txt_1 "Map vote ratio"
set _menu_cmd_1 "mp_mapvoteratio"
set _menu_f1 $mp_mapvoteratio

set _menu_type_2 3
set _menu_txt_2 "Decals"
set _menu_cmd_2 "mp_decals"
set _menu_f2 $mp_decals

set _menu_type_3 3
set _menu_txt_3 "Decal frequency"
set _menu_cmd_3 "decalfrequency"
set _menu_f3 $decalfrequency

set _menu_type_4 2
set _menu_txt_4 "Pausable"
set _menu_cmd_4 "pausable"
set _menu_f4 $pausable

set _menu_type_5 2
set _menu_txt_5 "Old bomb; defused sound"
set _menu_cmd_5 "mp_old_bomb_defused_sound"
set _menu_f5 $mp_old_bomb_defused_sound

set _menu_type_6 1
set _menu_txt_6 "Player ID in status bar"
set _menu_cmd_6 "exec $menu_root_path/my_menu-5-cvar5-2"
set _menu_icn_6 "touch/cmd/right.tga"

set _menu_type_7 2
set _menu_txt_7 "Consistency"
set _menu_cmd_7 "mp_consistency"
set _menu_f7 $mp_consistency

set _menu_type_8 2
set _menu_txt_8 "Fade to black"
set _menu_cmd_8 "mp_fadetoblack"
set _menu_f8 $mp_fadetoblack

set _menu_type_9 2
set _menu_txt_9 "Show radio; icon"
set _menu_cmd_9 "mp_show_radioicon"
set _menu_f9 $mp_show_radioicon

set _menu_type_10 2
set _menu_txt_10 "Punish; team killers"
set _menu_cmd_10 "mp_tkpunish"
set _menu_f10 $mp_tkpunish

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-4-xhair.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-4-xhair
set _menu_level 4
set _menu_min 1
set _menu_max 10

set _menu_type_1 2
set _menu_txt_1 "Enable"
set _menu_cmd_1 "xhair_enable"
set _menu_f1 $xhair_enable

set _menu_type_2 2
set _menu_txt_2 "Enable; dynamic; move"
set _menu_cmd_2 "xhair_dynamic_move"
set _menu_f2 $xhair_dynamic_move

set _menu_type_3 2
set _menu_txt_3 "T-Shape"
set _menu_cmd_3 "xhair_t"
set _menu_f3 $xhair_t

set _menu_type_4 2
set _menu_txt_4 "Additive"
set _menu_cmd_4 "xhair_additive"
set _menu_f4 $xhair_additive

set _menu_type_5 2
set _menu_txt_5 "Gap uses; weapon value"
set _menu_cmd_5 "xhair_gap_useweaponvalue"
set _menu_f5 $xhair_gap_useweaponvalue

set _menu_type_6 2
set _menu_txt_6 "Dot"
set _menu_cmd_6 "xhair_dot"
set _menu_f6 $xhair_dot

set _menu_type_7 3
set _menu_txt_7 "Color"
set _menu_cmd_7 "xhair_color"
set _menu_f7 $xhair_color

set _menu_type_8 3
set _menu_txt_8 "Gap"
set _menu_cmd_8 "xhair_gap"
set _menu_f8 $xhair_gap

set _menu_type_9 3
set _menu_txt_9 "Padding"
set _menu_cmd_9 "xhair_pad"
set _menu_f9 $xhair_pad

set _menu_type_10 1
set _menu_txt_10 "Open More"
set _menu_cmd_10 "exec $menu_root_path/my_menu-5-xhair"
set _menu_icn_10 "touch/cmd/right.tga"

build_menu

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-5-cvar0-2.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-5-cvar0-2
set _menu_level 5
set _menu_min 5
set _menu_max 8

set _menu_type_5 1
set _menu_txt_5 "Log no attacks"
set _menu_cmd_5 "mp_logdetail 0"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "Log enemy attacks"
set _menu_cmd_6 "mp_logdetail 1"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "Log teammate attacks"
set _menu_cmd_7 "mp_logdetail 2"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Log enemy and; teammate attacks"
set _menu_cmd_8 "mp_logdetail 3"
set _menu_icn_8 ""

build_menu

if $mp_logdetail = 0;:touch_setcolor _menu_S5_my_menu-5-cvar0-2 156 77 20 180
if $mp_logdetail = 1;:touch_setcolor _menu_S6_my_menu-5-cvar0-2 156 77 20 180
if $mp_logdetail = 2;:touch_setcolor _menu_S7_my_menu-5-cvar0-2 156 77 20 180
if $mp_logdetail = 3;:touch_setcolor _menu_S8_my_menu-5-cvar0-2 156 77 20 180


```

`3rdparty/cs16client-extras/touch/cmd/my_menu-5-cvar2-2.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-5-cvar2-2
set _menu_level 5
set _menu_min 2
set _menu_max 4

set _menu_type_2 1
set _menu_txt_2 "Any"
set _menu_cmd_2 "humans_join_team any"
set _menu_icn_2 ""

set _menu_type_3 1
set _menu_txt_3 "Terrorist"
set _menu_cmd_3 "humans_join_team t"
set _menu_icn_3 ""

set _menu_type_4 1
set _menu_txt_4 "Counter-Terrorist"
set _menu_cmd_4 "humans_join_team ct"
set _menu_icn_4 ""

build_menu

if $humans_join_team = any;:touch_setcolor _menu_S2_my_menu-5-cvar2-2 156 77 20 180
if $humans_join_team = t;:touch_setcolor _menu_S3_my_menu-5-cvar2-2 156 77 20 180
if $humans_join_team = ct;:touch_setcolor _menu_S4_my_menu-5-cvar2-2 156 77 20 180



```

`3rdparty/cs16client-extras/touch/cmd/my_menu-5-cvar3-2.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-5-cvar3-2
set _menu_level 5
set _menu_min 1
set _menu_max 4

set _menu_type_1 3
set _menu_txt_1 "Time limit"
set _menu_cmd_1 "mp_timelimit"
set _menu_f1 $mp_timelimit

set _menu_type_2 3
set _menu_txt_2 "Win limit"
set _menu_cmd_2 "mp_winlimit"
set _menu_f2 $mp_winlimit

set _menu_type_3 3
set _menu_txt_3 "Frag limit"
set _menu_cmd_3 "mp_fraglimit"
set _menu_f3 $mp_fraglimit

set _menu_type_4 3
set _menu_txt_4 "Chat time"
set _menu_cmd_4 "mp_chattime"
set _menu_f4 $mp_chattime

build_menu
```

`3rdparty/cs16client-extras/touch/cmd/my_menu-5-cvar5-2.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-5-cvar5-2
set _menu_level 5
set _menu_min 6
set _menu_max 8

set _menu_type_6 1
set _menu_txt_6 "Show for everyone"
set _menu_cmd_6 "mp_playerid 0"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "Show only for teammates; and hostages"
set _menu_cmd_7 "mp_playerid 1"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Don't show"
set _menu_cmd_8 "mp_playerid 2"
set _menu_icn_8 ""

build_menu

if $mp_playerid = 0;:touch_setcolor _menu_S6_my_menu-5-cvar5-2 156 77 20 180
if $mp_playerid = 1;:touch_setcolor _menu_S7_my_menu-5-cvar5-2 156 77 20 180
if $mp_playerid = 2;:touch_setcolor _menu_S8_my_menu-5-cvar5-2 156 77 20 180


```

`3rdparty/cs16client-extras/touch/cmd/my_menu-5-voicequality.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-5-voicequality
set _menu_level 5
set _menu_min 5
set _menu_max 10

set _menu_type_5 1
set _menu_txt_5 "Higher"
set _menu_cmd_5 "sv_voicequality 5"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "High"
set _menu_cmd_6 "sv_voicequality 4"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "Normal"
set _menu_cmd_7 "sv_voicequality 3"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Low"
set _menu_cmd_8 "sv_voicequality 2"
set _menu_icn_8 ""

set _menu_type_9 1
set _menu_txt_9 "Lower"
set _menu_cmd_9 "sv_voicequality 1"
set _menu_icn_9 ""

set _menu_type_10 1
set _menu_txt_10 "Worst"
set _menu_cmd_10 "sv_voicequality 0"
set _menu_icn_10 ""

build_menu

if $sv_voicequality = 0;:touch_setcolor _menu_S0_my_menu-5-voicequality 156 77 20 180
if $sv_voicequality = 1;:touch_setcolor _menu_S9_my_menu-5-voicequality 156 77 20 180
if $sv_voicequality = 2;:touch_setcolor _menu_S8_my_menu-5-voicequality 156 77 20 180
if $sv_voicequality = 3;:touch_setcolor _menu_S7_my_menu-5-voicequality 156 77 20 180
if $sv_voicequality = 4;:touch_setcolor _menu_S6_my_menu-5-voicequality 156 77 20 180
if $sv_voicequality = 5;:touch_setcolor _menu_S5_my_menu-5-voicequality 156 77 20 180

```

`3rdparty/cs16client-extras/touch/cmd/my_menu-5-xhair.cfg`:

```cfg
cmd_scripting 1
set menu_root_path "touch/cmd"
set _menu_id my_menu-5-xhair
set _menu_level 5
set _menu_min 8
set _menu_max 10

set _menu_type_8 3
set _menu_txt_8 "Size"
set _menu_cmd_8 "xhair_size"
set _menu_f8 $xhair_size

set _menu_type_9 3
set _menu_txt_9 "Thickness"
set _menu_cmd_9 "xhair_thick"
set _menu_f9 $xhair_thick

set _menu_type_10 3
set _menu_txt_10 "Dynamic Scaling"
set _menu_cmd_10 "xhair_dynamic_scale"
set _menu_f10 $xhair_dynamic_scale

build_menu

```

`3rdparty/cs16client-extras/touch/custom/dm_menu.cfg`:

```cfg
// * Auto generated file

touch_setclientonly 1

// global overstroke (width, r, g, b, a)
touch_set_stroke 1 240 140 0 200

// Background & buttons
touch_addbutton "_menu_bg" "*white" "" 0.03 0.193611 0.965 0.831386 0 0 0 80 260
touch_addbutton "_menu_bg2" "*white" "" 0.095 0.0569444 0.965 0.182222 0 0 0 80 260
touch_addbutton "_menu_bg3" "*white" "" 0.03 0.0569444 0.09 0.182222 0 0 0 80 260

//touch_addbutton "_menu_button_bg0" "*white" "" 0.04 0.3075 0.215 0.82 0 0 0 80 260
//touch_addbutton "_menu_button_bg1" "*white" "" 0.04 0.205 0.215 0.296111 0 0 0 80 260
touch_addbutton "_menu_button_bg2" "*white" "ak47;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg2 140 140 0 80" 0.22 0.205 0.4 0.296111 0 0 0 80 260
touch_addbutton "_menu_button_bg3" "*white" "m4a1;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg3 140 140 0 80" 0.22 0.3075 0.4 0.398611 0 0 0 80 260
touch_addbutton "_menu_button_bg4" "*white" "awp;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg4 140 140 0 80" 0.22 0.41 0.4 0.501111 0 0 0 80 260
touch_addbutton "_menu_button_bg5" "*white" "galil;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg5 140 140 0 80" 0.22 0.5125 0.4 0.603611 0 0 0 80 260
touch_addbutton "_menu_button_bg6" "*white" "aug;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg6 140 140 0 80" 0.22 0.615 0.4 0.706111 0 0 0 80 260
touch_addbutton "_menu_button_bg7" "*white" "famas;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg7 140 140 0 80" 0.22 0.728889 0.4 0.82 0 0 0 80 260
touch_addbutton "_menu_button_bg8" "*white" "p90;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg8 140 140 0 80" 0.405 0.205 0.585 0.296111 0 0 0 80 260
touch_addbutton "_menu_button_bg9" "*white" "mp5;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg9 140 140 0 80" 0.405 0.3075 0.585 0.398611 0 0 0 80 260
touch_addbutton "_menu_button_bg10" "*white" "mac10;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg10 140 140 0 80" 0.405 0.41 0.585 0.501111 0 0 0 80 260
touch_addbutton "_menu_button_bg11" "*white" "m3;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg11 140 140 0 80" 0.405 0.5125 0.585 0.603611 0 0 0 80 260
touch_addbutton "_menu_button_bg12" "*white" "xm1014;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg12 140 140 0 80" 0.405 0.615 0.585 0.706111 0 0 0 80 260
touch_addbutton "_menu_button_bg13" "*white" "scout;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg13 140 140 0 80" 0.405 0.728889 0.585 0.82 0 0 0 80 260
touch_addbutton "_menu_button_bg14" "*white" "ump45;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg14 140 140 0 80" 0.59 0.205 0.77 0.296111 0 0 0 80 260
touch_addbutton "_menu_button_bg15" "*white" "tmp;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg15 140 140 0 80" 0.59 0.3075 0.77 0.398611 0 0 0 80 260
touch_addbutton "_menu_button_bg16" "*white" "sg550;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg16 140 140 0 80" 0.59 0.41 0.77 0.501111 0 0 0 80 260
touch_addbutton "_menu_button_bg17" "*white" "g3sg1;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg17 140 140 0 80" 0.59 0.5125 0.77 0.603611 0 0 0 80 260
touch_addbutton "_menu_button_bg18" "*white" "m249;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg18 140 140 0 80" 0.59 0.615 0.77 0.706111 0 0 0 80 260
touch_addbutton "_menu_button_bg19" "*white" "sg552;primammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg19 140 140 0 80" 0.59 0.728889 0.77 0.82 0 0 0 80 260
touch_addbutton "_menu_button_bg20" "*white" "deagle;secammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg20 140 140 0 80" 0.775 0.205 0.955 0.296111 0 0 0 80 260
touch_addbutton "_menu_button_bg21" "*white" "elite;secammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg21 140 140 0 80" 0.775 0.3075 0.955 0.398611 0 0 0 80 260
touch_addbutton "_menu_button_bg22" "*white" "glock18;secammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg22 140 140 0 80" 0.775 0.41 0.955 0.501111 0 0 0 80 260
touch_addbutton "_menu_button_bg23" "*white" "fiveseven;secammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg23 140 140 0 80" 0.775 0.5125 0.955 0.603611 0 0 0 80 260
touch_addbutton "_menu_button_bg24" "*white" "p228;secammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg24 140 140 0 80" 0.775 0.615 0.955 0.706111 0 0 0 80 260
touch_addbutton "_menu_button_bg25" "*white" "usp;secammo ;touch_setcolor _menu_button_bg* 0 0 0 80 ;touch_setcolor _menu_button_bg25 140 140 0 80" 0.775 0.728889 0.955 0.82 0 0 0 80 260
//touch_addbutton "_menu_button_bg26" "*white" "" 0.04 0.41 0.215 0.501111 0 0 0 80 260
//touch_addbutton "_menu_button_bg27" "*white" "" 0.04 0.5125 0.215 0.603611 0 0 0 80 260
//touch_addbutton "_menu_button_bg28" "*white" "" 0.04 0.615 0.215 0.706111 0 0 0 80 260
//touch_addbutton "_menu_button_bg29" "*white" "" 0.04 0.728889 0.215 0.82 0 0 0 80 260
//touch_addbutton "_menu_button_bg30" "*white" "" 0.04 0.3075 0.215 0.82 0 0 0 80 260

touch_addbutton "_menu_button1" "*white" "touch_removebutton _menu_* ;touch_setclientonly 0" 0.03 0.842775 0.24 0.968053 0 0 0 80 260
touch_addbutton "_menu_button2" "*white" "" 0.245 0.842775 0.455 0.968053 0 0 0 80 73
touch_addbutton "_menu_button3" "*white" "" 0.54 0.842776 0.75 0.968054 0 0 0 80 73
touch_addbutton "_menu_button4" "*white" "" 0.755 0.842776 0.965 0.968054 0 0 0 80 73

// Icons
touch_addbutton "_menu_icon" "gfx/vgui/CS_logo" "" 0.03 0.0569444 0.09 0.182222 240 140 0 255 78
touch_addbutton "_menu_bg_icon" "gfx/vgui/ak47" "" 0.315 0.205 0.4 0.296111 255 255 255 255 78
touch_addbutton "_menu_bg_icon2" "gfx/vgui/m4a1" "" 0.315 0.3075 0.4 0.398611 255 255 255 255 78
touch_addbutton "_menu_bg_icon3" "gfx/vgui/awp" "" 0.315 0.41 0.4 0.501111 255 255 255 255 78
touch_addbutton "_menu_bg_icon4" "gfx/vgui/galil" "" 0.315 0.5125 0.4 0.603611 255 255 255 255 78
touch_addbutton "_menu_bg_icon5" "gfx/vgui/aug" "" 0.315 0.615 0.4 0.706111 255 255 255 255 78
touch_addbutton "_menu_bg_icon6" "gfx/vgui/famas" "" 0.315 0.728889 0.4 0.82 255 255 255 255 78
touch_addbutton "_menu_bg_icon7" "gfx/vgui/p90" "" 0.5 0.205 0.585 0.296111 255 255 255 255 78
touch_addbutton "_menu_bg_icon8" "gfx/vgui/mp5.tga" "" 0.5 0.3075 0.585 0.398611 255 255 255 255 78
touch_addbutton "_menu_bg_icon9" "gfx/vgui/mac10" "" 0.5 0.41 0.585 0.501111 255 255 255 255 78
touch_addbutton "_menu_bg_icon10" "gfx/vgui/m3" "" 0.5 0.5125 0.585 0.603611 255 255 255 255 78
touch_addbutton "_menu_bg_icon11" "gfx/vgui/xm1014" "" 0.5 0.615 0.585 0.706111 255 255 255 255 78
touch_addbutton "_menu_bg_icon12" "gfx/vgui/scout" "" 0.5 0.728889 0.585 0.82 255 255 255 255 78
touch_addbutton "_menu_bg_icon13" "gfx/vgui/ump45" "" 0.685 0.205 0.77 0.296111 255 255 255 255 78
touch_addbutton "_menu_bg_icon14" "gfx/vgui/tmp" "" 0.685 0.3075 0.77 0.398611 255 255 255 255 78
touch_addbutton "_menu_bg_icon15" "gfx/vgui/sg550" "" 0.685 0.41 0.77 0.501111 255 255 255 255 78
touch_addbutton "_menu_bg_icon16" "gfx/vgui/g3sg1" "" 0.685 0.5125 0.77 0.603611 255 255 255 255 78
touch_addbutton "_menu_bg_icon17" "gfx/vgui/m249" "" 0.685 0.615 0.77 0.706111 255 255 255 255 78
touch_addbutton "_menu_bg_icon18" "gfx/vgui/sg552" "" 0.685 0.728889 0.77 0.82 255 255 255 255 78
touch_addbutton "_menu_bg_icon19" "gfx/vgui/deserteagle" "" 0.87 0.205 0.955 0.296111 255 255 255 255 78
touch_addbutton "_menu_bg_icon20" "gfx/vgui/elites" "" 0.87 0.3075 0.955 0.398611 255 255 255 255 78
touch_addbutton "_menu_bg_icon21" "gfx/vgui/glock18" "" 0.87 0.41 0.955 0.501111 255 255 255 255 78
touch_addbutton "_menu_bg_icon22" "gfx/vgui/fiveseven" "" 0.87 0.5125 0.955 0.603611 255 255 255 255 78
touch_addbutton "_menu_bg_icon23" "gfx/vgui/p228" "" 0.87 0.615 0.955 0.706111 255 255 255 255 78
touch_addbutton "_menu_bg_icon24" "gfx/vgui/usp45" "" 0.87 0.728889 0.955 0.82 255 255 255 255 78
//touch_addbutton "_menu_bg_icon1-25" "*" "" 0.13 0.3075 0.215 0.398611 255 255 255 255 78
//touch_addbutton "_menu_bg_icon26" "*" "" 0.13 0.41 0.215 0.501111 255 255 255 255 78
//touch_addbutton "_menu_bg_icon27" "*" "" 0.13 0.5125 0.215 0.603611 255 255 255 255 78
//touch_addbutton "_menu_bg_icon28" "*" "" 0.13 0.615 0.215 0.706111 255 255 255 255 78
//touch_addbutton "_menu_bg_icon29" "*" "" 0.13 0.728889 0.215 0.82 255 255 255 255 78
//touch_addbutton "_menu_bg_icon0-1" "*" "" 0.13 0.205 0.215 0.296111 255 255 255 255 78

// Text
//touch_addbutton "_menu_text_bg0-1" "# TEXT" "" 0.05 0.227778 0.14 0.284722 240 140 0 255 78
touch_addbutton "_menu_text_bg" "# DM  | SELECT WEAPON" "" 0.44 0.1025 0.95 0.170833 240 140 0 255 78
//touch_addbutton "_menu_text_bg1" "# TEXT" "" 0.055 0.227778 0.21 0.284722 240 140 0 255 73
touch_addbutton "_menu_text_exit" "# CLOSE" "" 0.11 0.888333 0.235 0.945278 240 140 0 255 78
//touch_addbutton "_menu_text_button1" "# TEXT" "" 0.32 0.888333 0.445 0.945278 240 140 0 255 73
//touch_addbutton "_menu_text_button2" "# TEXT" "" 0.62 0.888333 0.745 0.945278 240 140 0 255 73
//touch_addbutton "_menu_text_button3" "# TEXT" "" 0.835 0.888333 0.96 0.945278 240 140 0 255 73
touch_addbutton "_menu_bg_text1" "# AK47" "" 0.23 0.227778 0.32 0.284722 240 140 0 255 78
touch_addbutton "_menu_bg_text2" "# M4A1" "" 0.23 0.330278 0.32 0.387222 240 140 0 255 78
touch_addbutton "_menu_bg_text3" "# AWP" "" 0.23 0.432778 0.32 0.489722 240 140 0 255 78
touch_addbutton "_menu_bg_text4" "# GALIL" "" 0.23 0.535278 0.32 0.592222 240 140 0 255 78
touch_addbutton "_menu_bg_text5" "# AUG" "" 0.23 0.637778 0.32 0.694722 240 140 0 255 78
touch_addbutton "_menu_bg_text6" "# FAMAS" "" 0.23 0.751667 0.32 0.808611 240 140 0 255 78
touch_addbutton "_menu_bg_text7" "# P90" "" 0.415 0.227778 0.505 0.284722 240 140 0 255 78
touch_addbutton "_menu_bg_text8" "# MP5" "" 0.415 0.330278 0.505 0.387222 240 140 0 255 78
touch_addbutton "_menu_bg_text9" "# MAC" "" 0.415 0.432778 0.505 0.489722 240 140 0 255 78
touch_addbutton "_menu_bg_text10" "# M3" "" 0.415 0.535278 0.505 0.592222 240 140 0 255 78
touch_addbutton "_menu_bg_text11" "# XM1014" "" 0.415 0.637778 0.505 0.694722 240 140 0 255 78
touch_addbutton "_menu_bg_text12" "# SCOUT" "" 0.415 0.751667 0.505 0.808611 240 140 0 255 78
touch_addbutton "_menu_bg_text13" "# UMP" "" 0.6 0.227778 0.69 0.284722 240 140 0 255 78
touch_addbutton "_menu_bg_text14" "# TMP" "" 0.6 0.330278 0.69 0.387222 240 140 0 255 78
touch_addbutton "_menu_bg_text15" "# SG550" "" 0.6 0.432778 0.69 0.489722 240 140 0 255 78
touch_addbutton "_menu_bg_text16" "# G3SG1" "" 0.6 0.535278 0.69 0.592222 240 140 0 255 78
touch_addbutton "_menu_bg_text17" "# M249" "" 0.6 0.637778 0.69 0.694722 240 140 0 255 78
touch_addbutton "_menu_bg_text18" "# SG552" "" 0.6 0.751667 0.69 0.808611 240 140 0 255 78
touch_addbutton "_menu_bg_text19" "# DEAGLE" "" 0.785 0.227778 0.875 0.284722 240 140 0 255 78
touch_addbutton "_menu_bg_text20" "# ELITES" "" 0.785 0.330278 0.875 0.387222 240 140 0 255 78
touch_addbutton "_menu_bg_text21" "# GLOCK18" "" 0.785 0.432778 0.875 0.489722 240 140 0 255 78
touch_addbutton "_menu_bg_text22" "# FIVESEVEN" "" 0.785 0.535278 0.875 0.592222 240 140 0 255 78
touch_addbutton "_menu_bg_text23" "# P228" "" 0.785 0.637778 0.875 0.694722 240 140 0 255 78
touch_addbutton "_menu_bg_text24" "# USP" "" 0.785 0.751667 0.875 0.808611 240 140 0 255 78
//touch_addbutton "_menu_bg_text25" "# TEXT" "" 0.05 0.330278 0.14 0.387222 240 140 0 255 78
//touch_addbutton "_menu_bg_text26" "# TEXT" "" 0.05 0.432778 0.14 0.489722 240 140 0 255 78
//touch_addbutton "_menu_bg_text27" "# TEXT" "" 0.05 0.535278 0.14 0.592222 240 140 0 255 78
//touch_addbutton "_menu_bg_text28" "# TEXT" "" 0.05 0.637778 0.14 0.694722 240 140 0 255 78
//touch_addbutton "_menu_bg_text29" "# TEXT" "" 0.05 0.751667 0.14 0.808611 240 140 0 255 78

```

`3rdparty/cs16client-extras/touch/custom/my_menu-5-controls.cfg`:

```cfg
//=======================================================================
// TOUCH RADIO MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set _menu_f1 $enable_controls
set _menu_id my_menu-5-controls

touch_addbutton "_menu_S1_$_menu_id" "*white" "" 0.8 0.9 0.9 1 0 0 0 180 260
touch_addbutton "_menu_on1_$_menu_id" "*white" "_click_cnd; enable_controls 1; exec $menu_root_path/$_menu_file_name; touch_setcolor _menu_on1_$_menu_id 156 77 20 180; touch_setcolor _menu_off1_$_menu_id 0 0 0 180" 0.9 0.9 0.95 1 0 0 0 180 260
touch_addbutton "_menu_off1_$_menu_id" "*white" "_click_cnd; enable_controls 0; exec $menu_root_path/$_menu_file_name; touch_setcolor _menu_on1_$_menu_id 0 0 0 180; touch_setcolor _menu_off1_$_menu_id 156 77 20 180" 0.95 0.9 1 1 0 0 0 180 260
touch_addbutton "_menu_t1_$_menu_id" "# $_menu_txt_controls" "" 0.8 0.925 0.9 1 255 174 0 255 4
touch_addbutton "_menu_t1on_$_menu_id" "#  $_menu_txt_on" "" 0.9 0.925 0.95 1 255 174 0 255 4
touch_addbutton "_menu_t1off_$_menu_id" "#  $_menu_txt_off" "" 0.95 0.925 1 1 255 174 0 255 4
if $_menu_f1 = 1
:touch_setcolor "_menu_on1_$_menu_id" 156 77 20 180
else
:touch_setcolor "_menu_off1_$_menu_id" 156 77 20 180

```

`3rdparty/cs16client-extras/touch/custom/my_menu-language.cfg`:

```cfg
cmd_scripting 1
if $ui_language = english	// English
:set _menu_txt_on "ON"
:set _menu_txt_off "OFF"
:set _menu_txt_controls "Enable; controls"
:set _menu_txt_exit "Exit"
if $ui_language = russian	// Russian
:cl_charset "utf-8"		// Fix utf-8 text problem
:set _menu_txt_on "Вкл"
:set _menu_txt_off "Выкл"
:set _menu_txt_controls "Включить; управление"
:set _menu_txt_exit "Выход"

echo "^3Debug:^7UI Language ^1$ui_language^7 loaded"

```

`3rdparty/cs16client-extras/touch/customcmd.cfg`:

```cfg
// 		Founder of customcmd guy named as 'ahsim' not mine, i just re-write and delete sh1t from code.		//
//		by /w_sh1t - github.com/wh1tesh1t/		//

//		Setup customcmd
cmd_scripting 1
if $touch_setclientonly = 1;:touch_setclientonly 0;:touch_setclientonly 1 // Fix. Disable and Enable touch_setclientonly when value=1

//	Language
if $ui_language = english	// English
:set _menu_txt_on "ON"
:set _menu_txt_off "OFF"
:set _menu_txt_controls "Enable; controls"
:set _menu_txt_exit "Exit"
if $ui_language = russian	// Russian
:cl_charset "utf-8"		// Fix utf-8 text problem
:set _menu_txt_on "Вкл"
:set _menu_txt_off "Выкл"
:set _menu_txt_controls "Включить; управление"
:set _menu_txt_exit "Выход"

//	Cvars
if "$touch_move_indicator > 0";:set touch_indicator_value "$touch_move_indicator";:set touch_move_indicator 0
set _menu_stroke 1 156 77 20 200 ;touch_set_stroke $_menu_stroke
set _menu_sel_bg "156 77 20 180"
set _menu_bg "0 0 0 180"
set _menu_text_color "255 174 0 255"
set _menu_bg_texture "*white"
set _menu_fade_enable 1
set _menu_click_cnd media/launch_select1.wav
set _menu_click_cnd_back media/launch_upmenu1.wav
set _menu_vibrate_value 30
//	Alias commands
alias _erase_frame "touch_removebutton _menu_*; touch_setclientonly 0; set touch_move_indicator $touch_indicator_value; unalias _erase_frame"
alias _reset_menu "touch_removebutton _menu_*; touch_setclientonly 0"
alias _click_cnd "play $_menu_click_cnd ; vibrate $_menu_vibrate_value"
alias _click_cnd_back "play $_menu_click_cnd_back ; vibrate $_menu_vibrate_value"
alias _closemenu_2 "touch_removebutton _menu_*_my_menu-2-*; touch_removebutton _menu_*_my_menu-3-*; touch_removebutton _menu_*_my_menu-4-*; touch_removebutton _menu_*_my_menu-5-*;alias _closemenu_2 \"\""
alias _closemenu_3 "touch_removebutton _menu_*_my_menu-3-*; touch_removebutton _menu_*_my_menu-4-*; touch_removebutton _menu_*_my_menu-5-*; alias _closemenu_3 \"\""
alias _closemenu_4 "touch_removebutton _menu_*_my_menu-4-*; touch_removebutton _menu_*_my_menu-5-*; alias _closemenu_4 \"\""
alias _closemenu_5 "touch_removebutton _menu_*_my_menu-5-*; alias _closemenu_5 \"\""
//	Movement buttons
if $menu_move_enable >= 1 // Enable/Disable _menu_move when value=1 or higher
:touch_addbutton "_menu_move" "" "_move" 0 0.1 0.5 1 0 0 0 0 6
if $menu_look_enable >= 1 // Enable/Disable _menu_look when value=1 or higher
:touch_addbutton "_menu_look" "" "_look" 0.5 0 1 1 0 0 0 0 6
//	Coordinates and closemenu for each level
if $_menu_level = 1
:set _menu_x1 0 ;:set _menu_x2 0.2 ;:set _menu_xon1 0.1 ;:set _menu_xon2 0.15 ;:set _menu_xset 0.13 ;:set _menu_ix1 0.17
if $_menu_level = 2
:set _menu_x1 0.2 ;:set _menu_x2 0.4 ;:set _menu_xon1 0.3 ;:set _menu_xon2 0.35 ;:set _menu_xset 0.33 ;:set _menu_ix1 0.37
:_closemenu_2
if $_menu_level = 3
:set _menu_x1 0.4 ;:set _menu_x2 0.6 ;:set _menu_xon1 0.5 ;:set _menu_xon2 0.55 ;:set _menu_xset 0.53 ;:set _menu_ix1 0.57
:_closemenu_3
if $_menu_level = 4
:set _menu_x1 0.6 ;:set _menu_x2 0.8 ;:set _menu_xon1 0.7 ;:set _menu_xon2 0.75 ;:set _menu_xset 0.73 ;:set _menu_ix1 0.77
:_closemenu_4
if $_menu_level = 5
:set _menu_x1 0.8 ;:set _menu_x2 1 ;:set _menu_xon1 0.9 ;:set _menu_xon2 0.95 ;:set _menu_xset 0.93 ;:set _menu_ix1 0.97
:_closemenu_5
//	Refresh button
touch_addbutton "_menu_refresh" "$_menu_bg_texture" "_click_cnd; touch_show _menu*; touch_hide _menu_refresh*; exec $menu_root_path/$_menu_id" 0 0 1 1 $_menu_bg 5
//		Building buttons
if $_menu_min <= 1;:if $_menu_max >= 1;::if $_menu_type_1 = 1
:::touch_addbutton "_menu_S1_$_menu_id" "$_menu_bg_texture" "_click_cnd; touch_setcolor _menu_S*_$_menu_id $_menu_bg; touch_setcolor _menu_S1_$_menu_id $_menu_sel_bg;$_menu_cmd_1" $_menu_x1 0 $_menu_x2 0.1 $_menu_bg 260
:::touch_addbutton "_menu_t1_$_menu_id" "# $_menu_txt_1" "" $_menu_x1 0.025 $_menu_x2 0.1 $_menu_text_color 4
:::touch_addbutton "_menu_i1_$_menu_id" "$_menu_icn_1" "" $_menu_ix1 0.025 $_menu_x2 0.065 $_menu_text_color 4
::if $_menu_type_1 = 2
:::touch_addbutton "_menu_S1_$_menu_id" "$_menu_bg_texture" "" $_menu_x1 0 $_menu_xon1 0.1 $_menu_bg 260
:::touch_addbutton "_menu_on1_$_menu_id" "$_menu_bg_texture" "_click_cnd; $_menu_cmd_1 1; touch_setcolor _menu_on1_$_menu_id $_menu_sel_bg; touch_setcolor _menu_off1_$_menu_id $_menu_bg" $_menu_xon1 0 $_menu_xon2 0.1 $_menu_bg 260
:::touch_addbutton "_menu_off1_$_menu_id" "$_menu_bg_texture" "_click_cnd; $_menu_cmd_1 0; touch_setcolor _menu_on1_$_menu_id $_menu_bg; touch_setcolor _menu_off1_$_menu_id $_menu_sel_bg" $_menu_xon2 0 $_menu_x2 0.1 $_menu_bg 260
:::touch_addbutton "_menu_t1_$_menu_id" "# $_menu_txt_1" "" $_menu_x1 0.025 $_menu_xon1 0.1 $_menu_text_color 4
:::touch_addbutton "_menu_t1on_$_menu_id" "#  $_menu_txt_on" "" $_menu_xon1 0.025 $_menu_xon2 0.1 $_menu_text_color 4
:::touch_addbutton "_menu_t1off_$_menu_id" "#  $_menu_txt_off" "" $_menu_xon2 0.025 $_menu_x2 0.1 $_menu_text_color 4
:::if $_menu_f1 = 1
::::touch_setcolor "_menu_on1_$_menu_id" $_menu_sel_bg
:::else
::::touch_setcolor "_menu_off1_$_menu_id" $_menu_sel_bg
::if $_menu_type_1 = 3
:::touch_addbutton "_menu_S1_$_menu_id" "$_menu_bg_texture" "_click_cnd;messagemode $_menu_cmd_1; touch_hide _menu*; touch_show _menu_refresh" $_menu_x1 0 $_menu_x2 0.1 $_menu_bg 260
:::touch_addbutton "_menu_C1_$_menu_id" "$_menu_bg_texture" "" $_menu_xset 0 $_menu_x2 0.1 0 0 0 0 260
:::touch_addbutton "_menu_t1_$_menu_id" "# $_menu_txt_1" "" $_menu_x1 0.025 $_menu_xset 0.1 $_menu_text_color 4
:::touch_addbutton "_menu_U1_$_menu_id" "# $_menu_f1" "" $_menu_xset 0.025 $_menu_x2 0.1 $_menu_text_color 4
::if $_menu_type_1 = 4
:::touch_addbutton "_menu_i1_$_menu_id" "$_menu_icn_1" "_click_cnd;$_menu_cmd_1" $_menu_x1 0 $_menu_x2 0.3 255 255 255 180 260
:::touch_addbutton "_menu_t1_$_menu_id" "# $_menu_txt_1" "" $_menu_x1 0 $_menu_x2 0.1 $_menu_text_color 4
:::_menu_icn_1 ""
::if $_menu_type_1 = 5
:::touch_addbutton "_menu_t1_$_menu_id" "# $_menu_txt_1" "" $_menu_x1 0.025 $_menu_x2 0.1 $_menu_text_color 4

if $_menu_min <= 2;:if $_menu_max >= 2;::if $_menu_type_2 = 1
:::touch_addbutton "_menu_S2_$_menu_id" "$_menu_bg_texture" "_click_cnd; touch_setcolor _menu_S*_$_menu_id $_menu_bg; touch_setcolor _menu_S2_$_menu_id $_menu_sel_bg;$_menu_cmd_2" $_menu_x1 0.1 $_menu_x2 0.2 $_menu_bg 260
:::touch_addbutton "_menu_t2_$_menu_id" "# $_menu_txt_2" "" $_menu_x1 0.125 $_menu_x2 0.2 $_menu_text_color 4
:::touch_addbutton "_menu_i2_$_menu_id" "$_menu_icn_2" "" $_menu_ix1 0.125 $_menu_x2 0.165 $_menu_text_color 4
::if $_menu_type_2 = 2
:::touch_addbutton "_menu_S2_$_menu_id" "$_menu_bg_texture" "" $_menu_x1 0.1 $_menu_xon1 0.2 $_menu_bg 260
:::touch_addbutton "_menu_on2_$_menu_id" "$_menu_bg_texture" "_click_cnd; $_menu_cmd_2 1; touch_setcolor _menu_on2_$_menu_id $_menu_sel_bg; touch_setcolor _menu_off2_$_menu_id $_menu_bg" $_menu_xon1 0.1 $_menu_xon2 0.2 $_menu_bg 260
:::touch_addbutton "_menu_off2_$_menu_id" "$_menu_bg_texture" "_click_cnd; $_menu_cmd_2 0; touch_setcolor _menu_on2_$_menu_id $_menu_bg; touch_setcolor _menu_off2_$_menu_id $_menu_sel_bg" $_menu_xon2 0.1 $_menu_x2 0.2 $_menu_bg 260
:::touch_addbutton "_menu_t2_$_menu_id" "# $_menu_txt_2" "" $_menu_x1 0.125 $_menu_xon1 0.2 $_menu_text_color 4
:::touch_addbutton "_menu_t2on_$_menu_id" "#  $_menu_txt_on" "" $_menu_xon1 0.125 $_menu_xon2 0.2 $_menu_text_color 4
:::touch_addbutton "_menu_t2off_$_menu_id" "#  $_menu_txt_off" "" $_menu_xon2 0.125 $_menu_x2 0.2 $_menu_text_color 4
:::if $_menu_f2 = 1
::::touch_setcolor "_menu_on2_$_menu_id" $_menu_sel_bg
:::else
::::touch_setcolor "_menu_off2_$_menu_id" $_menu_sel_bg
::if $_menu_type_2 = 3
:::touch_addbutton "_menu_S2_$_menu_id" "$_menu_bg_texture" "_click_cnd;messagemode $_menu_cmd_2; touch_hide _menu*; touch_show _menu_refresh" $_menu_x1 0.1 $_menu_x2 0.2 $_menu_bg 260
:::touch_addbutton "_menu_C2_$_menu_id" "$_menu_bg_texture" "" $_menu_xset 0.1 $_menu_x2 0.2 0 0 0 0 260
:::touch_addbutton "_menu_t2_$_menu_id" "# $_menu_txt_2" "" $_menu_x1 0.125 $_menu_xset 0.2 $_menu_text_color 4
:::touch_addbutton "_menu_U2_$_menu_id" "# $_menu_f2" "" $_menu_xset 0.125 $_menu_x2 0.2 $_menu_text_color 4
::if $_menu_type_2 = 4
:::touch_addbutton "_menu_i2_$_menu_id" "$_menu_icn_2" "_click_cnd;$_menu_cmd_2" $_menu_x1 0.1 $_menu_x2 0.4 255 255 255 180 260
:::touch_addbutton "_menu_t2_$_menu_id" "# $_menu_txt_2" "" $_menu_x1 0.1 $_menu_x2 0.2 $_menu_text_color 4
:::_menu_icn_2 ""
::if $_menu_type_2 = 5
:::touch_addbutton "_menu_t2_$_menu_id" "# $_menu_txt_2" "" $_menu_x1 0.125 $_menu_x2 0.2 $_menu_text_color 4

if $_menu_min <= 3;:if $_menu_max >= 3;::if $_menu_type_3 = 1
:::touch_addbutton "_menu_S3_$_menu_id" "$_menu_bg_texture" "_click_cnd; touch_setcolor _menu_S*_$_menu_id $_menu_bg; touch_setcolor _menu_S3_$_menu_id $_menu_sel_bg;$_menu_cmd_3" $_menu_x1 0.2 $_menu_x2 0.3 $_menu_bg 260
:::touch_addbutton "_menu_t3_$_menu_id" "# $_menu_txt_3" "" $_menu_x1 0.225 $_menu_x2 0.3 $_menu_text_color 4
:::touch_addbutton "_menu_i3_$_menu_id" "$_menu_icn_3" "" $_menu_ix1 0.225 $_menu_x2 0.265 $_menu_text_color 4
::if $_menu_type_3 = 2
:::touch_addbutton "_menu_S3_$_menu_id" "$_menu_bg_texture" "" $_menu_x1 0.2 $_menu_xon1 0.3 $_menu_bg 260
:::touch_addbutton "_menu_on3_$_menu_id" "$_menu_bg_texture" "_click_cnd; $_menu_cmd_3 1; touch_setcolor _menu_on3_$_menu_id $_menu_sel_bg; touch_setcolor _menu_off3_$_menu_id $_menu_bg" $_menu_xon1 0.2 $_menu_xon2 0.3 $_menu_bg 260
:::touch_addbutton "_menu_off3_$_menu_id" "$_menu_bg_texture" "_click_cnd; $_menu_cmd_3 0; touch_setcolor _menu_on3_$_menu_id $_menu_bg; touch_setcolor _menu_off3_$_menu_id $_menu_sel_bg" $_menu_xon2 0.2 $_menu_x2 0.3 $_menu_bg 260
:::touch_addbutton "_menu_t3_$_menu_id" "# $_menu_txt_3" "" $_menu_x1 0.225 $_menu_xon1 0.3 $_menu_text_color 4
:::touch_addbutton "_menu_t3on_$_menu_id" "#  $_menu_txt_on" "" $_menu_xon1 0.225 $_menu_xon2 0.3 $_menu_text_color 4
:::touch_addbutton "_menu_t3off_$_menu_id" "#  $_menu_txt_off" "" $_menu_xon2 0.225 $_menu_x2 0.3 $_menu_text_color 4
:::if $_menu_f3 = 1
::::touch_setcolor "_menu_on3_$_menu_id" $_menu_sel_bg
:::else
::::touch_setcolor "_menu_off3_$_menu_id" $_menu_sel_bg
::if $_menu_type_3 = 3
:::touch_addbutton "_menu_S3_$_menu_id" "$_menu_bg_texture" "_click_cnd;messagemode $_menu_cmd_3; touch_hide _menu*; touch_show _menu_refresh" $_menu_x1 0.2 $_menu_x2 0.3 $_menu_bg 260
:::touch_addbutton "_menu_C3_$_menu_id" "$_menu_bg_texture" "" $_menu_xset 0.2 $_menu_x2 0.3 0 0 0 0 260
:::touch_addbutton "_menu_t3_$_menu_id" "# $_menu_txt_3" "" $_menu_x1 0.225 $_menu_xset 0.3 $_menu_text_color 4
:::touch_addbutton "_menu_U3_$_menu_id" "# $_menu_f3" "" $_menu_xset 0.225 $_menu_x2 0.3 $_menu_text_color 4
::if $_menu_type_3 = 4
:::touch_addbutton "_menu_i3_$_menu_id" "$_menu_icn_3" "_click_cnd;$_menu_cmd_3" $_menu_x1 0.2 $_menu_x2 0.5 255 255 255 180 260
:::touch_addbutton "_menu_t3_$_menu_id" "# $_menu_txt_3" "" $_menu_x1 0.2 $_menu_x2 0.3 $_menu_text_color 4
:::_menu_icn_3 ""
::if $_menu_type_3 = 5
:::touch_addbutton "_menu_t3_$_menu_id" "# $_menu_txt_3" "" $_menu_x1 0.225 $_menu_x2 0.3 $_menu_text_color 4

if $_menu_min <= 4;:if $_menu_max >= 4;::if $_menu_type_4 = 1
:::touch_addbutton "_menu_S4_$_menu_id" "$_menu_bg_texture" "_click_cnd; touch_setcolor _menu_S*_$_menu_id $_menu_bg; touch_setcolor _menu_S4_$_menu_id $_menu_sel_bg;$_menu_cmd_4" $_menu_x1 0.3 $_menu_x2 0.4 $_menu_bg 260
:::touch_addbutton "_menu_t4_$_menu_id" "# $_menu_txt_4" "" $_menu_x1 0.325 $_menu_x2 0.4 $_menu_text_color 4
:::touch_addbutton "_menu_i4_$_menu_id" "$_menu_icn_4" "" $_menu_ix1 0.325 $_menu_x2 0.365 $_menu_text_color 4
::if $_menu_type_4 = 2
:::touch_addbutton "_menu_S4_$_menu_id" "$_menu_bg_texture" "" $_menu_x1 0.3 $_menu_xon1 0.4 $_menu_bg 260
:::touch_addbutton "_menu_on4_$_menu_id" "$_menu_bg_texture" "_click_cnd; $_menu_cmd_4 1; touch_setcolor _menu_on4_$_menu_id $_menu_sel_bg; touch_setcolor _menu_off4_$_menu_id $_menu_bg" $_menu_xon1 0.3 $_menu_xon2 0.4 $_menu_bg 260
:::touch_addbutton "_menu_off4_$_menu_id" "$_menu_bg_texture" "_click_cnd; $_menu_cmd_4 0; touch_setcolor _menu_on4_$_menu_id $_menu_bg; touch_setcolor _menu_off4_$_menu_id $_menu_sel_bg" $_menu_xon2 0.3 $_menu_x2 0.4 $_menu_bg 260
:::touch_addbutton "_menu_t4_$_menu_id" "# $_menu_txt_4" "" $_menu_x1 0.325 $_menu_xon2 0.4 $_menu_text_color 4
:::touch_addbutton "_menu_t4on_$_menu_id" "#  $_menu_txt_on" "" $_menu_xon1 0.325 $_menu_xon2 0.4 $_menu_text_color 4
:::touch_addbutton "_menu_t4off_$_menu_id" "#  $_menu_txt_off" "" $_menu_xon2 0.325 $_menu_x2 0.4 $_menu_text_color 4
:::if $_menu_f4 = 1
::::touch_setcolor "_menu_on4_$_menu_id" $_menu_sel_bg
:::else
::::touch_setcolor "_menu_off4_$_menu_id" $_menu_sel_bg
::if $_menu_type_4 = 3
:::touch_addbutton "_menu_S4_$_menu_id" "$_menu_bg_texture" "_click_cnd;messagemode $_menu_cmd_4; touch_hide _menu*; touch_show _menu_refresh" $_menu_x1 0.3 $_menu_x2 0.4 $_menu_bg 260
:::touch_addbutton "_menu_C4_$_menu_id" "$_menu_bg_texture" "" $_menu_xset 0.3 $_menu_x2 0.4 0 0 0 0 260
:::touch_addbutton "_menu_t4_$_menu_id" "# $_menu_txt_4" "" $_menu_x1 0.325 $_menu_xset 0.4 $_menu_text_color 4
:::touch_addbutton "_menu_U4_$_menu_id" "# $_menu_f4" "" $_menu_xset 0.325 $_menu_x2 0.4 $_menu_text_color 4
::if $_menu_type_4 = 4
:::touch_addbutton "_menu_i4_$_menu_id" "$_menu_icn_4" "_click_cnd;$_menu_cmd_4" $_menu_x1 0.3 $_menu_x2 0.6 255 255 255 180 260
:::touch_addbutton "_menu_t4_$_menu_id" "# $_menu_txt_4" "" $_menu_x1 0.3 $_menu_x2 0.4 $_menu_text_color 4
:::_menu_icn_4 ""
::if $_menu_type_4 = 5
:::touch_addbutton "_menu_t4_$_menu_id" "# $_menu_txt_4" "" $_menu_x1 0.325 $_menu_x2 0.4 $_menu_text_color 4

if $_menu_min <= 5;:if $_menu_max >= 5;::if $_menu_type_5 = 1
:::touch_addbutton "_menu_S5_$_menu_id" "$_menu_bg_texture" "_click_cnd; touch_setcolor _menu_S*_$_menu_id $_menu_bg; touch_setcolor _menu_S5_$_menu_id $_menu_sel_bg;$_menu_cmd_5" $_menu_x1 0.4 $_menu_x2 0.5 $_menu_bg 260
:::touch_addbutton "_menu_t5_$_menu_id" "# $_menu_txt_5" "" $_menu_x1 0.425 $_menu_x2 0.5 $_menu_text_color 4
:::touch_addbutton "_menu_i5_$_menu_id" "$_menu_icn_5" "" $_menu_ix1 0.425 $_menu_x2 0.465 $_menu_text_color 4
::if $_menu_type_5 = 2
:::touch_addbutton "_menu_S5_$_menu_id" "$_menu_bg_texture" "" $_menu_x1 0.4 $_menu_xon1 0.5 $_menu_bg 260
:::touch_addbutton "_menu_on5_$_menu_id" "$_menu_bg_texture" "_click_cnd; $_menu_cmd_5 1; touch_setcolor _menu_on5_$_menu_id $_menu_sel_bg; touch_setcolor _menu_off5_$_menu_id $_menu_bg" $_menu_xon1 0.4 $_menu_xon2 0.5 $_menu_bg 260
:::touch_addbutton "_menu_off5_$_menu_id" "$_menu_bg_texture" "_click_cnd; $_menu_cmd_5 0; touch_setcolor _menu_on5_$_menu_id $_menu_bg; touch_setcolor _menu_off5_$_menu_id $_menu_sel_bg" $_menu_xon2 0.4 $_menu_x2 0.5 $_menu_bg 260
:::touch_addbutton "_menu_t5_$_menu_id" "# $_menu_txt_5" "" $_menu_x1 0.425 $_menu_xon2 0.5 $_menu_text_color 4
:::touch_addbutton "_menu_t5on_$_menu_id" "#  $_menu_txt_on" "" $_menu_xon1 0.425 $_menu_xon2 0.5 $_menu_text_color 4
:::touch_addbutton "_menu_t5off_$_menu_id" "#  $_menu_txt_off" "" $_menu_xon2 0.425 $_menu_x2 0.5 $_menu_text_color 4
:::if $_menu_f5 = 1
::::touch_setcolor "_menu_on5_$_menu_id" $_menu_sel_bg
:::else
::::touch_setcolor "_menu_off5_$_menu_id" $_menu_sel_bg
::if $_menu_type_5 = 3
:::touch_addbutton "_menu_S5_$_menu_id" "$_menu_bg_texture" "_click_cnd;messagemode $_menu_cmd_5; touch_hide _menu*; touch_show _menu_refresh" $_menu_x1 0.4 $_menu_x2 0.5 $_menu_bg 260
:::touch_addbutton "_menu_C5_$_menu_id" "$_menu_bg_texture" "" $_menu_xset 0.4 $_menu_x2 0.5 0 0 0 0 260
:::touch_addbutton "_menu_t5_$_menu_id" "# $_menu_txt_5" "" $_menu_x1 0.425 $_menu_xset 0.5 $_menu_text_color 4
:::touch_addbutton "_menu_U5_$_menu_id" "# $_menu_f5" "" $_menu_xset 0.425 $_menu_x2 0.5 $_menu_text_color 4
::if $_menu_type_5 = 4
:::touch_addbutton "_menu_i5_$_menu_id" "$_menu_icn_5" "_click_cnd;$_menu_cmd_1" $_menu_x1 0.4 $_menu_x2 0.7 255 255 255 180 260
:::touch_addbutton "_menu_t5_$_menu_id" "# $_menu_txt_5" "" $_menu_x1 0.4 $_menu_x2 0.5 $_menu_text_color 4
:::_menu_icn_5 ""
::if $_menu_type_5 = 5
:::touch_addbutton "_menu_t5_$_menu_id" "# $_menu_txt_5" "" $_menu_x1 0.425 $_menu_x2 0.5 $_menu_text_color 4

if $_menu_min <= 6;:if $_menu_max >= 6;::if $_menu_type_6 = 1
:::touch_addbutton "_menu_S6_$_menu_id" "*white" "_click_cnd; touch_setcolor _menu_S*_$_menu_id $_menu_bg; touch_setcolor _menu_S6_$_menu_id $_menu_sel_bg;$_menu_cmd_6" $_menu_x1 0.5 $_menu_x2 0.6 $_menu_bg 260
:::touch_addbutton "_menu_t6_$_menu_id" "# $_menu_txt_6" "" $_menu_x1 0.525 $_menu_x2 0.6 $_menu_text_color 4
:::touch_addbutton "_menu_i6_$_menu_id" "$_menu_icn_6" "" $_menu_ix1 0.525 $_menu_x2 0.565 $_menu_text_color 4
::if $_menu_type_6 = 2
:::touch_addbutton "_menu_S6_$_menu_id" "*white" "" $_menu_x1 0.5 $_menu_xon1 0.6 $_menu_bg 260
:::touch_addbutton "_menu_on6_$_menu_id" "*white" "_click_cnd; $_menu_cmd_6 1; touch_setcolor _menu_on6_$_menu_id $_menu_sel_bg; touch_setcolor _menu_off6_$_menu_id $_menu_bg" $_menu_xon1 0.5 $_menu_xon2 0.6 $_menu_bg 260
:::touch_addbutton "_menu_off6_$_menu_id" "*white" "_click_cnd; $_menu_cmd_6 0; touch_setcolor _menu_on6_$_menu_id $_menu_bg; touch_setcolor _menu_off6_$_menu_id $_menu_sel_bg" $_menu_xon2 0.5 $_menu_x2 0.6 $_menu_bg 260
:::touch_addbutton "_menu_t6_$_menu_id" "# $_menu_txt_6" "" $_menu_x1 0.525 $_menu_xon2 0.6 $_menu_text_color 4
:::touch_addbutton "_menu_t6on_$_menu_id" "#  $_menu_txt_on" "" $_menu_xon1 0.525 $_menu_xon2 0.6 $_menu_text_color 4
:::touch_addbutton "_menu_t6off_$_menu_id" "#  $_menu_txt_off" "" $_menu_xon2 0.525 $_menu_x2 0.6 $_menu_text_color 4
:::if $_menu_f6 = 1
::::touch_setcolor "_menu_on6_$_menu_id" $_menu_sel_bg
:::else
::::touch_setcolor "_menu_off6_$_menu_id" $_menu_sel_bg
::if $_menu_type_6 = 3
:::touch_addbutton "_menu_S6_$_menu_id" "*white" "_click_cnd;messagemode $_menu_cmd_6; touch_hide _menu*; touch_show _menu_refresh" $_menu_x1 0.5 $_menu_x2 0.6 $_menu_bg 260
:::touch_addbutton "_menu_C6_$_menu_id" "*white" "" $_menu_xset 0.5 $_menu_x2 0.6 0 0 0 0 260
:::touch_addbutton "_menu_t6_$_menu_id" "# $_menu_txt_6" "" $_menu_x1 0.525 $_menu_xset 0.6 $_menu_text_color 4
:::touch_addbutton "_menu_U6_$_menu_id" "# $_menu_f6" "" $_menu_xset 0.525 $_menu_x2 0.6 $_menu_text_color 4
::if $_menu_type_6 = 4
:::touch_addbutton "_menu_i6_$_menu_id" "$_menu_icn_6" "_click_cnd;$_menu_cmd_6" $_menu_x1 0.5 $_menu_x2 0.8 255 255 255 180 260
:::touch_addbutton "_menu_t6_$_menu_id" "# $_menu_txt_6" "" $_menu_x1 0.5 $_menu_x2 0.6 $_menu_text_color 4
:::_menu_icn_6 ""
::if $_menu_type_6 = 5
:::touch_addbutton "_menu_t6_$_menu_id" "# $_menu_txt_6" "" $_menu_x1 0.525 $_menu_x2 0.6 $_menu_text_color 4

if $_menu_min <= 7;:if $_menu_max >= 7;::if $_menu_type_7 = 1
:::touch_addbutton "_menu_S7_$_menu_id" "*white" "_click_cnd; touch_setcolor _menu_S*_$_menu_id $_menu_bg; touch_setcolor _menu_S7_$_menu_id $_menu_sel_bg;$_menu_cmd_7" $_menu_x1 0.6 $_menu_x2 0.7 $_menu_bg 260
:::touch_addbutton "_menu_t7_$_menu_id" "# $_menu_txt_7" "" $_menu_x1 0.625 $_menu_x2 0.7 $_menu_text_color 4
:::touch_addbutton "_menu_i7_$_menu_id" "$_menu_icn_7" "" $_menu_ix1 0.625 $_menu_x2 0.665 $_menu_text_color 4
::if $_menu_type_7 = 2
:::touch_addbutton "_menu_S7_$_menu_id" "*white" "" $_menu_x1 0.6 $_menu_xon1 0.7 $_menu_bg 260
:::touch_addbutton "_menu_on7_$_menu_id" "*white" "_click_cnd; $_menu_cmd_7 1; touch_setcolor _menu_on7_$_menu_id $_menu_sel_bg; touch_setcolor _menu_off7_$_menu_id $_menu_bg" $_menu_xon1 0.6 $_menu_xon2 0.7 $_menu_bg 260
:::touch_addbutton "_menu_off7_$_menu_id" "*white" "_click_cnd; $_menu_cmd_7 0; touch_setcolor _menu_on7_$_menu_id $_menu_bg; touch_setcolor _menu_off7_$_menu_id $_menu_sel_bg" $_menu_xon2 0.6 $_menu_x2 0.7 $_menu_bg 260
:::touch_addbutton "_menu_t7_$_menu_id" "# $_menu_txt_7" "" $_menu_x1 0.625 $_menu_xon2 0.7 $_menu_text_color 4
:::touch_addbutton "_menu_t7on_$_menu_id" "#  $_menu_txt_on" "" $_menu_xon1 0.625 $_menu_xon2 0.7 $_menu_text_color 4
:::touch_addbutton "_menu_t7off_$_menu_id" "#  $_menu_txt_off" "" $_menu_xon2 0.625 $_menu_x2 0.7 $_menu_text_color 4
:::if $_menu_f7 = 1
::::touch_setcolor "_menu_on7_$_menu_id" $_menu_sel_bg
:::else
::::touch_setcolor "_menu_off7_$_menu_id" $_menu_sel_bg
::if $_menu_type_7 = 3
:::touch_addbutton "_menu_S7_$_menu_id" "*white" "_click_cnd;messagemode $_menu_cmd_7; touch_hide _menu*; touch_show _menu_refresh" $_menu_x1 0.6 $_menu_x2 0.7 $_menu_bg 260
:::touch_addbutton "_menu_C7_$_menu_id" "*white" "" $_menu_xset 0.6 $_menu_x2 0.7 0 0 0 0 260
:::touch_addbutton "_menu_t7_$_menu_id" "# $_menu_txt_7" "" $_menu_x1 0.625 $_menu_xset 0.7 $_menu_text_color 4
:::touch_addbutton "_menu_U7_$_menu_id" "# $_menu_f7" "" $_menu_xset 0.625 $_menu_x2 0.7 $_menu_text_color 4
::if $_menu_type_7 = 4
:::touch_addbutton "_menu_i7_$_menu_id" "$_menu_icn_7" "_click_cnd;$_menu_cmd_7" $_menu_x1 0.6 $_menu_x2 0.9 255 255 255 180 260
:::touch_addbutton "_menu_t7_$_menu_id" "# $_menu_txt_7" "" $_menu_x1 0.6 $_menu_x2 0.7 $_menu_text_color 4
:::_menu_icn_7 ""
::if $_menu_type_7 = 5
:::touch_addbutton "_menu_t7_$_menu_id" "# $_menu_txt_7" "" $_menu_x1 0.625 $_menu_x2 0.7 $_menu_text_color 4

if $_menu_min <= 8;:if $_menu_max >= 8;::if $_menu_type_8 = 1
:::touch_addbutton "_menu_S8_$_menu_id" "*white" "_click_cnd; touch_setcolor _menu_S*_$_menu_id $_menu_bg; touch_setcolor _menu_S8_$_menu_id $_menu_sel_bg;$_menu_cmd_8" $_menu_x1 0.7 $_menu_x2 0.8 $_menu_bg 260
:::touch_addbutton "_menu_t8_$_menu_id" "# $_menu_txt_8" "" $_menu_x1 0.725 $_menu_x2 0.8 $_menu_text_color 4
:::touch_addbutton "_menu_i8_$_menu_id" "$_menu_icn_8" "" $_menu_ix1 0.725 $_menu_x2 0.765 $_menu_text_color 4
::if $_menu_type_8 = 2
:::touch_addbutton "_menu_S8_$_menu_id" "*white" "" $_menu_x1 0.7 $_menu_xon1 0.8 $_menu_bg 260
:::touch_addbutton "_menu_on8_$_menu_id" "*white" "_click_cnd; $_menu_cmd_8 1; touch_setcolor _menu_on8_$_menu_id $_menu_sel_bg; touch_setcolor _menu_off8_$_menu_id $_menu_bg" $_menu_xon1 0.7 $_menu_xon2 0.8 $_menu_bg 260
:::touch_addbutton "_menu_off8_$_menu_id" "*white" "_click_cnd; $_menu_cmd_8 0; touch_setcolor _menu_on8_$_menu_id $_menu_bg; touch_setcolor _menu_off8_$_menu_id $_menu_sel_bg" $_menu_xon2 0.7 $_menu_x2 0.8 $_menu_bg 260
:::touch_addbutton "_menu_t8_$_menu_id" "# $_menu_txt_8" "" $_menu_x1 0.725 $_menu_xon2 0.8 $_menu_text_color 4
:::touch_addbutton "_menu_t8on_$_menu_id" "#  $_menu_txt_on" "" $_menu_xon1 0.725 $_menu_xon2 0.8 $_menu_text_color 4
:::touch_addbutton "_menu_t8off_$_menu_id" "#  $_menu_txt_off" "" $_menu_xon2 0.725 $_menu_x2 0.8 $_menu_text_color 4
:::if $_menu_f8 = 1
::::touch_setcolor "_menu_on8_$_menu_id" $_menu_sel_bg
:::else
::::touch_setcolor "_menu_off8_$_menu_id" $_menu_sel_bg
::if $_menu_type_8 = 3
:::touch_addbutton "_menu_S8_$_menu_id" "*white" "_click_cnd;messagemode $_menu_cmd_8; touch_hide _menu*; touch_show _menu_refresh" $_menu_x1 0.7 $_menu_x2 0.8 $_menu_bg 260
:::touch_addbutton "_menu_C8_$_menu_id" "*white" "" $_menu_xset 0.7 $_menu_x2 0.8 0 0 0 0 260
:::touch_addbutton "_menu_t8_$_menu_id" "# $_menu_txt_8" "" $_menu_x1 0.725 $_menu_xset 0.8 $_menu_text_color 4
:::touch_addbutton "_menu_U8_$_menu_id" "# $_menu_f8" "" $_menu_xset 0.725 $_menu_x2 0.8 $_menu_text_color 4
::if $_menu_type_8 = 4
:::touch_addbutton "_menu_i8_$_menu_id" "$_menu_icn_8" "_click_cnd;$_menu_cmd_8" $_menu_x1 0.7 $_menu_x2 1 255 255 255 180 260
:::touch_addbutton "_menu_t8_$_menu_id" "# $_menu_txt_8" "" $_menu_x1 0.7 $_menu_x2 0.8 $_menu_text_color 4
:::_menu_icn_8 ""
::if $_menu_type_8 = 5
:::touch_addbutton "_menu_t8_$_menu_id" "# $_menu_txt_8" "" $_menu_x1 0.725 $_menu_x2 0.8 $_menu_text_color 4

if $_menu_min <= 9;:if $_menu_max >= 9;::if $_menu_type_9 = 1
:::touch_addbutton "_menu_S9_$_menu_id" "*white" "_click_cnd; touch_setcolor _menu_S*_$_menu_id $_menu_bg; touch_setcolor _menu_S9_$_menu_id $_menu_sel_bg;$_menu_cmd_9" $_menu_x1 0.8 $_menu_x2 0.9 $_menu_bg 260
:::touch_addbutton "_menu_t9_$_menu_id" "# $_menu_txt_9" "" $_menu_x1 0.825 $_menu_x2 0.9 $_menu_text_color 4
:::touch_addbutton "_menu_i9_$_menu_id" "$_menu_icn_9" "" $_menu_ix1 0.825 $_menu_x2 0.865 $_menu_text_color 4
::if $_menu_type_9 = 2
:::touch_addbutton "_menu_S9_$_menu_id" "*white" "" $_menu_x1 0.8 $_menu_xon1 0.9 $_menu_bg 260
:::touch_addbutton "_menu_on9_$_menu_id" "*white" "_click_cnd; $_menu_cmd_9 1; touch_setcolor _menu_on9_$_menu_id $_menu_sel_bg; touch_setcolor _menu_off9_$_menu_id $_menu_bg" $_menu_xon1 0.8 $_menu_xon2 0.9 $_menu_bg 260
:::touch_addbutton "_menu_off9_$_menu_id" "*white" "_click_cnd; $_menu_cmd_9 0; touch_setcolor _menu_on9_$_menu_id $_menu_bg; touch_setcolor _menu_off9_$_menu_id $_menu_sel_bg" $_menu_xon2 0.8 $_menu_x2 0.9 $_menu_bg 260
:::touch_addbutton "_menu_t9_$_menu_id" "# $_menu_txt_9" "" $_menu_x1 0.825 $_menu_xon2 0.9 $_menu_text_color 4
:::touch_addbutton "_menu_t9on_$_menu_id" "#  $_menu_txt_on" "" $_menu_xon1 0.825 $_menu_xon2 0.9 $_menu_text_color 4
:::touch_addbutton "_menu_t9off_$_menu_id" "#  $_menu_txt_off" "" $_menu_xon2 0.825 $_menu_x2 0.9 $_menu_text_color 4
:::if $_menu_f9 = 1
::::touch_setcolor "_menu_on9_$_menu_id" $_menu_sel_bg
:::else
::::touch_setcolor "_menu_off9_$_menu_id" $_menu_sel_bg
::if $_menu_type_9 = 3
:::touch_addbutton "_menu_S9_$_menu_id" "*white" "_click_cnd;messagemode $_menu_cmd_9; touch_hide _menu*; touch_show _menu_refresh" $_menu_x1 0.8 $_menu_x2 0.9 $_menu_bg 260
:::touch_addbutton "_menu_C9_$_menu_id" "*white" "" $_menu_xset 0.8 $_menu_x2 0.9 0 0 0 0 260
:::touch_addbutton "_menu_t9_$_menu_id" "# $_menu_txt_9" "" $_menu_x1 0.825 $_menu_xset 0.9 $_menu_text_color 4
:::touch_addbutton "_menu_U9_$_menu_id" "# $_menu_f9" "" $_menu_xset 0.825 $_menu_x2 0.9 $_menu_text_color 4
::if $_menu_type_9 = 4
:::touch_addbutton "_menu_i9_$_menu_id" "$_menu_icn_9" "_click_cnd;$_menu_cmd_9" $_menu_x1 0.8 $_menu_x2 1 255 255 255 180 260
:::touch_addbutton "_menu_t9_$_menu_id" "# $_menu_txt_9" "" $_menu_x1 0.8 $_menu_x2 0.9 $_menu_text_color 4
:::_menu_icn_9 ""
::if $_menu_type_9 = 5
:::touch_addbutton "_menu_t9_$_menu_id" "# $_menu_txt_9" "" $_menu_x1 0.825 $_menu_x2 0.9 $_menu_text_color 4

if $_menu_min <= 10;:if $_menu_max >= 10;::if $_menu_type_10 = 1
:::touch_addbutton "_menu_S0_$_menu_id" "*white" "_click_cnd; touch_setcolor _menu_S*_$_menu_id $_menu_bg; touch_setcolor _menu_S0_$_menu_id $_menu_sel_bg;$_menu_cmd_10" $_menu_x1 0.9 $_menu_x2 1 $_menu_bg 260
:::touch_addbutton "_menu_t0_$_menu_id" "# $_menu_txt_10" "" $_menu_x1 0.925 $_menu_x2 1.0 $_menu_text_color 4
:::touch_addbutton "_menu_i0_$_menu_id" "$_menu_icn_10" "" $_menu_ix1 0.925 $_menu_x2 0.965 $_menu_text_color 4
::if $_menu_type_10 = 2
:::touch_addbutton "_menu_S0_$_menu_id" "*white" "" $_menu_x1 0.9 $_menu_xon1 1 $_menu_bg 260
:::touch_addbutton "_menu_on0_$_menu_id" "*white" "_click_cnd; $_menu_cmd_10 1; touch_setcolor _menu_on0_$_menu_id $_menu_sel_bg; touch_setcolor _menu_off0_$_menu_id $_menu_bg" $_menu_xon1 0.9 $_menu_xon2 1 $_menu_bg 260
:::touch_addbutton "_menu_off0_$_menu_id" "*white" "_click_cnd; $_menu_cmd_10 0; touch_setcolor _menu_on0_$_menu_id $_menu_bg; touch_setcolor _menu_off0_$_menu_id $_menu_sel_bg" $_menu_xon2 0.9 $_menu_x2 1 $_menu_bg 260
:::touch_addbutton "_menu_t0_$_menu_id" "# $_menu_txt_10" "" $_menu_x1 0.925 $_menu_xon1 1 $_menu_text_color 4
:::touch_addbutton "_menu_t0on_$_menu_id" "#  $_menu_txt_on" "" $_menu_xon1 0.925 $_menu_xon2 1 $_menu_text_color 4
:::touch_addbutton "_menu_t0off_$_menu_id" "#  $_menu_txt_off" "" $_menu_xon2 0.925 $_menu_x2 1 $_menu_text_color 4
:::if $_menu_f10 = 1
::::touch_setcolor "_menu_on0_$_menu_id" $_menu_sel_bg
:::else
::::touch_setcolor "_menu_off0_$_menu_id" $_menu_sel_bg
::if $_menu_type_10 = 3
:::touch_addbutton "_menu_S0_$_menu_id" "*white" "_click_cnd;messagemode $_menu_cmd_10; touch_hide _menu*; touch_show _menu_refresh" $_menu_x1 0.9 $_menu_x2 1 $_menu_bg 260
:::touch_addbutton "_menu_C0_$_menu_id" "*white" "" $_menu_xset 0.9 $_menu_x2 1 0 0 0 0 260
:::touch_addbutton "_menu_t0_$_menu_id" "# $_menu_txt_10" "" $_menu_x1 0.925 $_menu_xset 1 $_menu_text_color 4
:::touch_addbutton "_menu_U0_$_menu_id" "# $_menu_f10" "" $_menu_xset 0.925 $_menu_x2 1 $_menu_text_color 4
::if $_menu_type_10 = 4
:::touch_addbutton "_menu_i0_$_menu_id" "$_menu_icn_10" "_click_cnd;$_menu_cmd_10" $_menu_x1 0.9 $_menu_x2 1 255 255 255 180 260
:::touch_addbutton "_menu_t0_$_menu_id" "# $_menu_txt_10" "" $_menu_x1 0.9 $_menu_x2 1.0 $_menu_text_color 4
:::_menu_icn_10 ""
::if $_menu_type_10 = 5
:::touch_addbutton "_menu_t0_$_menu_id" "# $_menu_txt_10" "" $_menu_x1 0.925 $_menu_x2 1.0 $_menu_text_color 4

if $_menu_fade_enable = 1;:set _menu_fade_time 5 1 0 ;:touch_fade _menu_*_$_menu_id $_menu_fade_time

```

`3rdparty/cs16client-extras/touch/numerical_menu.cfg`:

```cfg
cmd_scripting 1

if $numericalmenu = 1
:exec touch/numerical_menu1
if $numericalmenu = 2
:exec touch/numerical_menu2
if $numericalmenu = 3
:exec touch/numerical_menu3

```

`3rdparty/cs16client-extras/touch/numerical_menu1.cfg`:

```cfg
if $numericalmenu_clientonly = 1
:alias _erase_frame "touch_removebutton _menu_*; unalias _erase_frame; touch_setclientonly 0"
:touch_setclientonly 1
else
:alias _erase_frame "touch_removebutton _menu_*; unalias _erase_frame"

touch_addbutton "_menu_slot1" "touch/gfx/key_1" "slot1; _erase_frame" 0.360000 0.142222 0.460000 0.320000 255 255 255 150 6
touch_addbutton "_menu_slot2" "touch/gfx/key_2" "slot2; _erase_frame" 0.460000 0.142222 0.560000 0.320000 255 255 255 150 6
touch_addbutton "_menu_slot3" "touch/gfx/key_3" "slot3; _erase_frame" 0.560000 0.142222 0.660000 0.320000 255 255 255 150 6
touch_addbutton "_menu_slot4" "touch/gfx/key_4" "slot4; _erase_frame" 0.360000 0.320000 0.460000 0.497778 255 255 255 150 6
touch_addbutton "_menu_slot5" "touch/gfx/key_5" "slot5; _erase_frame" 0.460000 0.320000 0.560000 0.497778 255 255 255 150 6
touch_addbutton "_menu_slot6" "touch/gfx/key_6" "slot6; _erase_frame" 0.560000 0.320000 0.660000 0.497778 255 255 255 150 6
touch_addbutton "_menu_slot7" "touch/gfx/key_7" "slot7; _erase_frame" 0.360000 0.497778 0.460000 0.675556 255 255 255 150 6
touch_addbutton "_menu_slot8" "touch/gfx/key_8" "slot8; _erase_frame" 0.460000 0.497778 0.560000 0.675556 255 255 255 150 6
touch_addbutton "_menu_slot9" "touch/gfx/key_9" "slot9; _erase_frame" 0.560000 0.497778 0.660000 0.675556 255 255 255 150 6
touch_addbutton "_menu_slot10" "touch/gfx/key_0" "slot10; _erase_frame" 0.460000 0.675556 0.560000 0.853333 255 255 255 150 6

```

`3rdparty/cs16client-extras/touch/numerical_menu2.cfg`:

```cfg
if $numericalmenu_clientonly = 1
:alias _erase_frame "touch_removebutton _menu_*; unalias _erase_frame; touch_setclientonly 0"
:touch_setclientonly 1
else
:alias _erase_frame "touch_removebutton _menu_*; unalias _erase_frame"

touch_addbutton "_menu_slot1" "touch/gfx/key_1" "slot1; _erase_frame" 0.060000 0.711111 0.140000 0.853333 255 255 255 150 6
touch_addbutton "_menu_slot2" "touch/gfx/key_2" "slot2; _erase_frame" 0.140000 0.711111 0.220000 0.853333 255 255 255 150 6
touch_addbutton "_menu_slot3" "touch/gfx/key_3" "slot3; _erase_frame" 0.220000 0.711111 0.300000 0.853333 255 255 255 150 6
touch_addbutton "_menu_slot4" "touch/gfx/key_4" "slot4; _erase_frame" 0.300000 0.711111 0.380000 0.853333 255 255 255 150 6
touch_addbutton "_menu_slot5" "touch/gfx/key_5" "slot5; _erase_frame" 0.380000 0.711111 0.460000 0.853333 255 255 255 150 6
touch_addbutton "_menu_slot6" "touch/gfx/key_6" "slot6; _erase_frame" 0.060000 0.853333 0.140000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot7" "touch/gfx/key_7" "slot7; _erase_frame" 0.140000 0.853333 0.220000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot8" "touch/gfx/key_8" "slot8; _erase_frame" 0.220000 0.853333 0.300000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot9" "touch/gfx/key_9" "slot9; _erase_frame" 0.300000 0.853333 0.380000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot10" "touch/gfx/key_0" "slot10; _erase_frame" 0.380000 0.853333 0.460000 0.995556 255 255 255 150 6

```

`3rdparty/cs16client-extras/touch/numerical_menu3.cfg`:

```cfg
if $numericalmenu_clientonly = 1
:alias _erase_frame "touch_removebutton _menu_*; unalias _erase_frame; touch_setclientonly 0"
:touch_setclientonly 1
else
:alias _erase_frame "touch_removebutton _menu_*; unalias _erase_frame"

touch_addbutton "_menu_slot1" "touch/gfx/key_1" "slot1; _erase_frame" 0.060000 0.853333 0.140000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot2" "touch/gfx/key_2" "slot2; _erase_frame" 0.140000 0.853333 0.220000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot3" "touch/gfx/key_3" "slot3; _erase_frame" 0.220000 0.853333 0.300000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot4" "touch/gfx/key_4" "slot4; _erase_frame" 0.300000 0.853333 0.380000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot5" "touch/gfx/key_5" "slot5; _erase_frame" 0.380000 0.853333 0.460000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot6" "touch/gfx/key_6" "slot6; _erase_frame" 0.540000 0.853333 0.620000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot7" "touch/gfx/key_7" "slot7; _erase_frame" 0.620000 0.853333 0.700000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot8" "touch/gfx/key_8" "slot8; _erase_frame" 0.700000 0.853333 0.780000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot9" "touch/gfx/key_9" "slot9; _erase_frame" 0.780000 0.853333 0.860000 0.995556 255 255 255 150 6
touch_addbutton "_menu_slot10" "touch/gfx/key_0" "slot10; _erase_frame" 0.860000 0.853333 0.940000 0.995556 255 255 255 150 6

```

`3rdparty/cs16client-extras/touch/radioa.cfg`:

```cfg
//=======================================================================
// TOUCH RADIO MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch"
alias build_menu "exec touch/customcmd"
set _menu_id my_menu-2-radioa
set _menu_level 2
set _menu_min 2
set _menu_max 7

set _menu_type_2 1
set _menu_txt_2 "Cover Me"
set _menu_cmd_2 "slot1; _erase_frame"
set _menu_icn_2 ""

set _menu_type_3 1
set _menu_txt_3 "You Take the Point"
set _menu_cmd_3 "slot2; _erase_frame"
set _menu_icn_3 ""

set _menu_type_4 1
set _menu_txt_4 "Hold This Position"
set _menu_cmd_4 "slot3; _erase_frame"
set _menu_icn_4 ""

set _menu_type_5 1
set _menu_txt_5 "Regroup Team"
set _menu_cmd_5 "slot4; _erase_frame"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "Follow Me"
set _menu_cmd_6 "slot5; _erase_frame"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "Taking Fire,;Need Assistance"
set _menu_cmd_7 "slot6; _erase_frame"
set _menu_icn_7 ""

build_menu

```

`3rdparty/cs16client-extras/touch/radiob.cfg`:

```cfg
//=======================================================================
// TOUCH RADIO MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch"
alias build_menu "exec touch/customcmd"
set _menu_id my_menu-2-radiob
set _menu_level 2
set _menu_min 2
set _menu_max 7

set _menu_type_2 1
set _menu_txt_2 "Go, go, go"
set _menu_cmd_2 "slot1; _erase_frame"
set _menu_icn_2 ""

set _menu_type_3 1
set _menu_txt_3 "Fall Back"
set _menu_cmd_3 "slot2; _erase_frame"
set _menu_icn_3 ""

set _menu_type_4 1
set _menu_txt_4 "Stick Together Team"
set _menu_cmd_4 "slot3; _erase_frame"
set _menu_icn_4 ""

set _menu_type_5 1
set _menu_txt_5 "Get in Position"
set _menu_cmd_5 "slot4; _erase_frame"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "Storm the Front"
set _menu_cmd_6 "slot5; _erase_frame"
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "Report In"
set _menu_cmd_7 "slot6; _erase_frame"
set _menu_icn_7 ""

build_menu

```

`3rdparty/cs16client-extras/touch/radioc.cfg`:

```cfg
//=======================================================================
// TOUCH RADIO MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch"
alias build_menu "exec touch/customcmd"
set _menu_id my_menu-2-radioc
set _menu_level 2
set _menu_min 2
set _menu_max 10

set _menu_type_2 1
set _menu_txt_2 "Affirmative/Roger"
set _menu_cmd_2 "slot1; _erase_frame"
set _menu_icn_2 ""

set _menu_type_3 1
set _menu_txt_3 "Enemy Spotted"
set _menu_cmd_3 "slot2; _erase_frame"
set _menu_icn_3 ""

set _menu_type_4 1
set _menu_txt_4 "Need Backup"
set _menu_cmd_4 "slot3; _erase_frame"
set _menu_icn_4 ""

set _menu_type_5 1
set _menu_txt_5 "Sector Clear"
set _menu_cmd_5 "slot4; _erase_frame"
set _menu_icn_5 ""

set _menu_type_6 1
set _menu_txt_6 "I'm in Position"
set _menu_cmd_6 "slot5; _erase_frame"
set _menu_icn_7 ""

set _menu_type_7 1
set _menu_txt_7 "Reporting In"
set _menu_cmd_7 "slot6; _erase_frame"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "It's gonna Blow!"
set _menu_cmd_8 "slot7; _erase_frame"
set _menu_icn_8 ""

set _menu_type_9 1
set _menu_txt_9 "Negative"
set _menu_cmd_9 "slot8; _erase_frame"
set _menu_icn_9 ""

set _menu_type_10 1
set _menu_txt_10 "Enemy Down"
set _menu_cmd_10 "slot9; _erase_frame"
set _menu_icn_10 ""

build_menu

```

`3rdparty/cs16client-extras/touch/radioselector.cfg`:

```cfg
//=======================================================================
// TOUCH RADIO MENU
// Copyright (c) 2016 Mikhail Stepanov aka ahsim
//=======================================================================
cmd_scripting 1
set menu_root_path "touch"
set _menu_file_name "radioselector.cfg"
alias build_menu "exec touch/customcmd"
set _menu_id radioselector
set _menu_level 1
set _menu_min 3
set _menu_max 8

set _menu_type_3 1
set _menu_txt_3 "Radio commands"
set _menu_cmd_3 "radio1; if $_extended_menus = 0;:_erase_frame"
set _menu_icn_3 "touch/cmd/right.tga"

set _menu_type_4 1
set _menu_txt_4 "Group radio commands"
set _menu_cmd_4 "radio2; if $_extended_menus = 0;:_erase_frame"
set _menu_icn_4 "touch/cmd/right.tga"

set _menu_type_5 1
set _menu_txt_5 "Radio responses/reports"
set _menu_cmd_5 "radio3; if $_extended_menus = 0;:_erase_frame"
set _menu_icn_5 "touch/cmd/right.tga"

set _menu_type_6 5
set _menu_txt_6 ""
set _menu_cmd_6 ""
set _menu_icn_6 ""

set _menu_type_7 1
set _menu_txt_7 "All chat"
set _menu_cmd_7 "messagemode; _erase_frame"
set _menu_icn_7 ""

set _menu_type_8 1
set _menu_txt_8 "Team chat"
set _menu_cmd_8 "messagemode2; _erase_frame"
set _menu_icn_8 ""

build_menu

if $enable_controls = 1;:touch_setclientonly 0;else;:touch_setclientonly 1
exec touch/custom/my_menu-5-controls.cfg

touch_addbutton "_menu_slot2_my_menu" "*white" "" 0 0.1 0.2 0.2 156 77 20 180 260
touch_addbutton "_menu_txt2_my_menu" "#RADIO" "" 0.01 0.135 0.2 0.2 255 174 0 255 4
touch_addbutton "_menu_slot4_my_menu" "*white" "" 0 0.5 0.2 0.6 156 77 20 180 260
touch_addbutton "_menu_txt4_my_menu" "#CHAT" "" 0.01 0.535 0.2 0.6 255 174 0 255 4
touch_addbutton "_menu_slot10" "*white" "_click_cnd_back; _erase_frame" 0 0.8 0.2 0.9 120 60 12 180 260
touch_addbutton "_menu_txt_slot10" "#EXIT" "" 0.01 0.835 0.2 0.9 255 174 0 255 4

```

`3rdparty/cs16client-extras/touch/scoreboard.cfg`:

```cfg
//=======================================================================
//      Copyright (c) 2016 Poverennov Sergey aka SergioPoverony
//=======================================================================

cmd_scripting 1

if $checkscoreboard = 1
:exec touch/scoreboard_full.cfg
if $checkscoreboard = 2
:exec touch/scoreboard_short.cfg
if $checkscoreboard = 3
:exec touch/scoreboard_classic.cfg

```

`3rdparty/cs16client-extras/touch/scoreboard_classic.cfg`:

```cfg
touch_setclientonly 1
+showscores
alias hidescore "touch_removebutton _menu_*; -showscores; touch_setclientonly 0"
touch_addbutton "_menu_score_exit" "" "hidescore" 0.000000 0.000000 1.000000 1.00000000 255 255 255 255 6

```

`3rdparty/cs16client-extras/touch/scoreboard_full.cfg`:

```cfg
//=======================================================================
//      Copyright (c) 2016 Poverennov Sergey aka SergioPoverony
//=======================================================================

touch_setclientonly 1
showscoreboard2 0.04 0.9608 0.068 0.937 0 0 0 186
alias hidescore "touch_removebutton _menu*; hidescoreboard2; touch_setclientonly 0"
touch_addbutton "_menu_corner1" "gfx/vgui/round_corner_ne.tga" "" 0.960000 0.034043 0.980000 0.068085 255 255 255 186 6
touch_addbutton "_menu_corner2" "gfx/vgui/round_corner_sw.tga" "" 0.020000 0.936170 0.040000 0.970213 255 255 255 186 6
touch_addbutton "_menu_corner3" "gfx/vgui/round_corner_se.tga" "" 0.960000 0.936170 0.980000 0.970213 255 255 255 186 6
touch_addbutton "_menu_corner6" "gfx/vgui/round_corner_nw.tga" "" 0.020000 0.034043 0.040000 0.068085 255 255 255 186 6
touch_addbutton "_menu_corner4" "*black" "" 0.040000 0.034043 0.960000 0.068085 255 255 255 186 6
touch_addbutton "_menu_corner5" "*black" "" 0.040000 0.936170 0.960000 0.970213 255 255 255 186 6
touch_addbutton "_menu_corner7" "*black" "" 0.960000 0.068085 0.980000 0.936170 255 255 255 186 6
touch_addbutton "_menu_corner8" "*black" "" 0.020000 0.068085 0.040000 0.936170 255 255 255 186 6
touch_addbutton "_menu_score_exit" "" "hidescore" 0.000000 0.000000 1.000000 1.00000000 255 255 255 255 6


```

`3rdparty/cs16client-extras/touch/scoreboard_short.cfg`:

```cfg
//=======================================================================
//      Copyright (c) 2016 Poverennov Sergey aka SergioPoverony
//=======================================================================

touch_setclientonly 1
showscoreboard2 0.18 0.85 0.0680 0.937 0 0 0 186
alias hidescore "touch_removebutton _menu*; hidescoreboard2; touch_setclientonly 0"
touch_addbutton "_menu_corner7" "*black" "" 0.850000 0.068085 0.870000 0.936170 255 255 255 186 6
touch_addbutton "_menu_corner8" "*black" "" 0.160000 0.068085 0.180000 0.936170 255 255 255 186 6
touch_addbutton "_menu_corner4" "*black" "" 0.180000 0.034043 0.850000 0.068085 255 255 255 186 6
touch_addbutton "_menu_corner5" "*black" "" 0.180000 0.936170 0.850000 0.970213 255 255 255 186 6
touch_addbutton "_menu_corner3" "gfx/vgui/round_corner_se.tga" "" 0.850000 0.936170 0.870000 0.970213 255 255 255 186 6
touch_addbutton "_menu_corner2" "gfx/vgui/round_corner_sw.tga" "" 0.160000 0.936170 0.180000 0.970213 255 255 255 186 6
touch_addbutton "_menu_corner1" "gfx/vgui/round_corner_ne.tga" "" 0.850000 0.034043 0.870000 0.068085 255 255 255 186 6
touch_addbutton "_menu_corner6" "gfx/vgui/round_corner_nw.tga" "" 0.160000 0.034043 0.180000 0.068085 255 255 255 186 6
touch_addbutton "_menu_score_exit" "" "hidescore" 0.000000 0.000000 1.000000 1.00000000 255 255 255 255 6

```

`3rdparty/cs16client-extras/touch_default/numbers.cfg`:

```cfg
touch_hide show_numbers
alias _numbers_clean "touch_removebutton _numbers_*;touch_show show_numbers;unalias _numbers_clean"
touch_addbutton "_numbers_slot1" "touch/gfx/key_1" "slot1" 0.020000 0.845443 0.100000 0.980713 255 255 255 200 6 1
touch_addbutton "_numbers_slot2" "touch/gfx/key_2" "slot2" 0.100000 0.845443 0.180000 0.980713 255 255 255 200 6 1
touch_addbutton "_numbers_slot3" "touch/gfx/key_3" "slot3" 0.180000 0.845443 0.260000 0.980713 255 255 255 200 6 1
touch_addbutton "_numbers_slot4" "touch/gfx/key_4" "slot4" 0.260000 0.845443 0.340000 0.980713 255 255 255 200 6 1
touch_addbutton "_numbers_slot5" "touch/gfx/key_5" "slot5" 0.340000 0.845443 0.420000 0.980713 255 255 255 200 6 1
touch_addbutton "_numbers_slot6" "touch/gfx/key_6" "slot6" 0.560000 0.845443 0.640000 0.980713 255 255 255 200 6 1
touch_addbutton "_numbers_slot7" "touch/gfx/key_7" "slot7" 0.640000 0.845443 0.720000 0.980713 255 255 255 200 6 1
touch_addbutton "_numbers_slot8" "touch/gfx/key_8" "slot8" 0.720000 0.845443 0.800000 0.980713 255 255 255 200 6 1
touch_addbutton "_numbers_slot9" "touch/gfx/key_9" "slot9" 0.800000 0.845443 0.880000 0.980713 255 255 255 200 6 1
touch_addbutton "_numbers_slot10" "touch/gfx/key_0" "slot10" 0.880000 0.845443 0.960000 0.980713 255 255 255 200 6 1
touch_addbutton "_numbers_hide" "touch_default/next_weap" "_numbers_clean" 0.440000 0.879260 0.520000 1 255 255 255 200 6 1

```

`3rdparty/cs16client-extras/touch_presets/phone_ahsim.cfg`:

```cfg
//=======================================================================
//	Copyright SDLash3D team & XashXT group 2016 ©
//			touchscreen config
//=======================================================================

touch_config_file "touch_profiles/phone_ahsim.cfg"

// touch cvars

// _move sensitivity settings
touch_forwardzone "0.124444"
touch_sidezone "0.070000"

// _look sensitivity settings
touch_pitch "50.000000"
touch_yaw "50.000000"

// grid settings
touch_grid_count "50"
touch_grid_enable "1"

// global overstroke (width, r, g, b, a)
touch_set_stroke 1 156 77 20 200

// highlight when pressed
touch_highlight_r "1.000000"
touch_highlight_g "0.500000"
touch_highlight_b "1.000000"
touch_highlight_a "1.000000"

// _joy and _dpad options
touch_dpad_radius "1.000000"
touch_joy_radius "1.000000"

// how much slowdown when Precise Look button pressed
touch_precise_amount "0.500000"

// enable/disable move indicator
touch_move_indicator "3"

// reset menu state when execing config
touch_setclientonly 0

// touch buttons
touch_removeall
touch_addbutton "move" "" "_move" 0.000000 0.106667 0.500000 0.995556 255 255 255 150 0
touch_addbutton "look" "" "_look" 0.500000 0.106667 1.000000 0.995556 255 255 255 150 0
touch_addbutton "jump" "touch/gfx/jump" "+jump" 0.900000 0.142222 1.000000 0.320000 255 255 255 150 0 1
touch_addbutton "walk" "touch/gfx/walk" "+speed" 0.080000 0.782222 0.180000 0.960000 255 255 255 150 0 1
touch_addbutton "score" "touch/gfx/score" "scoreboard" 0.920000 0.000000 1.000000 0.142222 255 255 255 150 0 1
touch_addbutton "attack2" "touch/gfx/attack2" "+attack2" 0.780000 0.177778 0.860000 0.320000 255 255 255 150 0 1
touch_addbutton "use" "touch/gfx/use" "+use" 0.920000 0.355556 1.000000 0.497778 255 255 255 150 0 1
touch_addbutton "reload" "touch/gfx/reload" "+reload" 0.000000 0.533333 0.100000 0.711111 255 255 255 150 0 1
touch_addbutton "say" "touch/gfx/chat_all" "touch_hide say;touch_hide say2;messagemode" 0.080000 0.248889 0.140000 0.355556 255 255 255 150 1 1
touch_addbutton "say2" "touch/gfx/chat_team" "touch_hide say;touch_hide say2;messagemode2" 0.160000 0.248889 0.220000 0.355556 255 255 255 150 1 1
touch_addbutton "change_team" "touch/gfx/change_team" "chooseteam" 0.000000 0.817778 0.060000 0.924444 255 255 255 150 0 1
touch_addbutton "flight" "touch/gfx/flaghtlight" "impulse 100" 0.740000 0.000000 0.800000 0.106667 255 255 255 150 1 1
touch_addbutton "plus_nvg" "touch/gfx/plus" "nvgadjustup" 0.700000 0.106667 0.760000 0.213333 255 255 255 150 1 1
touch_addbutton "minus_nvg" "touch/gfx/minus" "nvgadjustdown" 0.620000 0.106667 0.680000 0.213333 255 255 255 150 1 1
touch_addbutton "nightvision" "touch/gfx/nightvision" "nightvision;toggle_plusminus" 0.660000 0.000000 0.720000 0.106667 255 255 255 150 1 1
touch_addbutton "w1" "touch/gfx/w_rifle" "slot1" 0.100000 0.000000 0.160000 0.106667 255 255 255 150 0 1
touch_addbutton "w2" "touch/gfx/w_pistol" "slot2" 0.180000 0.000000 0.240000 0.106667 255 255 255 150 0 1
touch_addbutton "w3" "touch/gfx/w_knife" "slot3" 0.260000 0.000000 0.320000 0.106667 255 255 255 150 0 1
touch_addbutton "w4" "touch/gfx/w_grenade" "slot4" 0.100000 0.142222 0.160000 0.248889 255 255 255 150 0 1
touch_addbutton "w5" "touch/gfx/w_c4" "slot5" 0.180000 0.142222 0.240000 0.248889 255 255 255 150 0 1
touch_addbutton "buy" "touch/gfx/buy" "buy" 0.460000 0.853333 0.540000 0.995556 255 255 255 150 0 1
touch_addbutton "drop" "touch/gfx/drop" "drop" 0.380000 0.000000 0.440000 0.106667 255 255 255 150 0 1
touch_addbutton "light" "touch/gfx/light" "toggle_light" 0.580000 0.000000 0.640000 0.106667 255 255 255 150 0 1
touch_addbutton "cancelselect" "touch/gfx/exit" "cancelselect" 0.480000 0.142222 0.540000 0.248889 255 255 255 150 1 1
touch_addbutton "invprev" "touch/gfx/left" "invprev" 0.000000 0.711111 0.060000 0.817778 255 255 255 150 1 1
touch_addbutton "invnext" "touch/gfx/right" "invnext" 0.060000 0.711111 0.120000 0.817778 255 255 255 150 1 1
touch_addbutton "radio" "touch/gfx/radio" "showvguimenu 38" 0.000000 0.391111 0.060000 0.497778 255 255 255 150 0 1
touch_addbutton "touch_edit" "touch/gfx/settings" "touch_enableedit" 0.460000 0.000000 0.540000 0.142222 255 255 255 150 0 1
touch_addbutton "spraypaint" "touch/gfx/spraypaint" "impulse 201" 0.820000 0.000000 0.880000 0.106667 255 255 255 150 0 1
touch_addbutton "attack" "touch/gfx/attack" "+attack" 0.780000 0.391111 0.900000 0.604444 255 255 255 150 0 1
touch_addbutton "duck" "touch/gfx/duck" "+duck" 0.900000 0.711111 1.000000 0.888889 255 255 255 150 512 1
touch_addbutton "chat" "touch/gfx/chat" "toggle_chat" 0.000000 0.248889 0.060000 0.355556 255 255 255 150 1 1
touch_addbutton "duck_sw" "touch/gfx/duck" "crouchtoggle" 0.800000 0.711111 0.900000 0.888889 255 255 255 150 1 1
touch_addbutton "show_numbers" "touch_default/show_weapons" "exec touch_default/numbers.cfg" 0.460000 0.711111 0.540000 0.853333 255 255 255 150 1 1
touch_addbutton "cmd" "touch/gfx/cmdmenu" "exec touch/cmd/cmd" 0.360000 0.142222 0.420000 0.248889 255 255 255 150 0 1
touch_addbutton "bots" "touch/gfx/botmenu" "exec touch/bots/bots" 0.280000 0.142222 0.340000 0.248889 255 255 255 150 0 1

```

`3rdparty/cs16client-extras/touch_presets/phone_poverony.cfg`:

```cfg
//=======================================================================
//	Copyright SDLash3D team & XashXT group 2016 ©
//			touchscreen preset
//=======================================================================

touch_config_file "touch_profiles/sergiopoverony_selected.cfg"

// touch cvars

// _move sensitivity settings
touch_forwardzone "0.080000"
touch_sidezone "0.040000"

// _look sensitivity settings
touch_pitch "20.000000"
touch_yaw "50.000000"

// grid settings
touch_grid_count "100"
touch_grid_enable "1"

// global overstroke (width, r, g, b, a)
touch_set_stroke 2 90 90 90 200

// highlight when pressed
touch_highlight_r "1.000000"
touch_highlight_g "1.000000"
touch_highlight_b "1.000000"
touch_highlight_a "1.000000"

// _joy and _dpad options
touch_dpad_radius "1.000000"
touch_joy_radius "1.000000"

// how much slowdown when Precise Look button pressed
touch_precise_amount "0.500000"

// enable/disable move indicator
touch_move_indicator "0"

// reset menu state when execing config
touch_setclientonly 0

// touch buttons
touch_removeall
touch_addbutton "move" "" "_move" 0.000000 0.160000 0.470000 0.995556 255 255 255 100 0 1
touch_addbutton "look" "" "_look" 0.460000 0.035556 1.000000 0.995556 255 255 255 100 0 1
touch_addbutton "nightvision" "touch/gfx/nightvision" "nightvision;toggle_plusminus" 0.360000 0.711111 0.440000 0.853333 255 255 255 100 1 1
touch_addbutton "minus_nvg" "touch/gfx/minus" "nvgadjustdown" 0.340000 0.622222 0.400000 0.728889 255 255 255 100 1 1
touch_addbutton "plus_nvg" "touch/gfx/plus" "nvgadjustup" 0.400000 0.622222 0.460000 0.728889 255 255 255 100 1 1
touch_addbutton "jump" "touch/gfx/jump" "+jump" 0.900000 0.817778 1.000000 0.995556 255 255 255 100 0 1
touch_addbutton "w4" "touch/gfx/w_grenade" "slot4" 0.840000 0.000000 0.920000 0.142222 255 255 255 100 0 1
touch_addbutton "w3" "touch/gfx/w_knife" "slot3" 0.920000 0.000000 1.000000 0.142222 255 255 255 100 0 1
touch_addbutton "w2" "touch/gfx/w_pistol" "slot2" 0.760000 0.000000 0.840000 0.142222 255 255 255 100 0 1
touch_addbutton "w1" "touch/gfx/w_rifle" "slot1" 0.680000 0.000000 0.760000 0.142222 255 255 255 100 0 1
touch_addbutton "w5" "touch/gfx/w_c4" "slot5" 0.600000 0.000000 0.680000 0.142222 255 255 255 100 0 1
touch_addbutton "attack2" "touch/gfx/attack2" "+attack2" 0.890000 0.480000 1.000000 0.675556 255 255 255 100 0 1
touch_addbutton "duck" "touch/gfx/duck" "+duck" 0.000000 0.817778 0.100000 0.995556 255 255 255 100 512 1
touch_addbutton "joy" "touch/gfx/joy" "_joy" 0.130000 0.586667 0.220000 0.746667 255 255 255 100 1 1
touch_addbutton "dpad" "touch/gfx/dpad" "_dpad" 0.070000 0.480000 0.280000 0.853333 255 255 255 100 0 1
touch_addbutton "light" "touch/gfx/light" "toggle_light" 0.360000 0.853333 0.440000 0.995556 255 255 255 100 0 1
touch_addbutton "score" "touch/gfx/score" "scoreboard" 0.520000 0.853333 0.600000 0.995556 255 255 255 100 0 1
touch_addbutton "reload" "touch/gfx/reload" "+reload" 0.620000 0.640000 0.730000 0.835556 255 255 255 100 0 1
touch_addbutton "buy" "touch/gfx/buy" "buy" 0.670000 0.835556 0.750000 0.977778 255 255 255 100 0 1
touch_addbutton "bots" "touch/gfx/botmenu" "exec touch/bots/bots" 0.190000 0.000000 0.270000 0.142222 255 255 255 100 1 1
touch_addbutton "cmd" "touch/gfx/cmdmenu" "exec touch/cmd/cmd" 0.110000 0.000000 0.190000 0.142222 255 255 255 100 1 1
touch_addbutton "touch_edit" "touch/gfx/settings" "touch_enableedit" 0.270000 0.000000 0.350000 0.142222 255 255 255 100 1 1
touch_addbutton "use" "touch/gfx/use" "+use" 0.680000 0.515556 0.760000 0.657778 255 255 255 100 0 1
touch_addbutton "exit" "touch/gfx/exit" "cancelselect" 0.350000 0.000000 0.430000 0.142222 255 255 255 100 1 1
touch_addbutton "change_team" "touch/gfx/change_team" "chooseteam" 0.430000 0.000000 0.510000 0.142222 255 255 255 100 1 1
touch_addbutton "down" "touch/gfx/left" "toggle_down" 0.520000 0.000000 0.600000 0.142222 255 255 255 100 0 1
touch_addbutton "radio" "touch/gfx/radio" "showvguimenu 38" 0.000000 0.160000 0.100000 0.337778 255 255 255 100 0 1
touch_addbutton "spraypaint" "touch/gfx/spraypaint" "impulse 201" 0.100000 0.177778 0.180000 0.320000 255 255 255 100 0 1
touch_addbutton "invprev" "touch/gfx/left" "invprev" 0.180000 0.177778 0.260000 0.320000 255 255 255 100 1 1
touch_addbutton "invnext" "touch/gfx/right" "invnext" 0.260000 0.177778 0.340000 0.320000 255 255 255 100 1 1
touch_addbutton "walk" "touch/gfx/walk" "+speed" 0.000000 0.355556 0.100000 0.533333 255 255 255 100 0 1
touch_addbutton "duck_sw" "touch/gfx/duck" "crouchtoggle" 0.260000 0.817778 0.360000 0.995556 255 255 255 100 0 1
touch_addbutton "attack" "touch/gfx/attack" "+attack" 0.730000 0.586667 0.910000 0.906667 255 255 255 100 0 1
touch_addbutton "drop" "touch/gfx/drop" "drop" 0.440000 0.711111 0.520000 0.853333 255 255 255 100 0 1
touch_addbutton "show_numbers" "touch_default/show_weapons" "exec touch_default/numbers.cfg" 0.440000 0.853333 0.520000 0.995556 255 255 255 100 0 1
touch_addbutton "flight" "touch/gfx/flaghtlight" "impulse 100" 0.920000 0.142222 1.000000 0.284444 255 255 255 100 1 1

// round button coordinates to grid
touch_roundall

```

`3rdparty/cs16client-extras/touch_presets/psvita.cfg`:

```cfg
//=======================================================================
//	Generated by Xash3D FWGS (3679, 43364ec, master, psvita-armv7hf)
//			touchscreen config
//=======================================================================

touch_config_file "touch_presets/psvita.cfg"

// touch cvars

// sensitivity settings
touch_pitch "60"
touch_yaw "60"
touch_forwardzone "0.124444"
touch_sidezone "0.07"
touch_nonlinear_look "0"
touch_pow_factor "1.3"
touch_pow_mult "400"
touch_exp_mult "0"

// grid settings
touch_grid_count "50"
touch_grid_enable "1"

// global overstroke (width, r, g, b, a)
touch_set_stroke 1 255 174 0 150

// highlight when pressed
touch_highlight_r "1"
touch_highlight_g "0.5"
touch_highlight_b "1"
touch_highlight_a "1"

// _joy and _dpad options
touch_dpad_radius "1"
touch_joy_radius "1"

// how much slowdown when Precise Look button pressed
touch_precise_amount "0.5"

// enable/disable move indicator
touch_move_indicator "0"

// reset menu state when execing config
touch_setclientonly 0

// touch buttons
touch_removeall
touch_aspectratio 0.566667
touch_addbutton "look" "" "_look" 0.5 0.105882 1 0.988235 255 255 255 150 0
touch_addbutton "score" "touch/gfx/score" "scoreboard" 0.92 0 1 0.141176 255 255 255 150 0
touch_addbutton "say" "touch/gfx/chat_all" "touch_hide say;touch_hide say2;messagemode" 0.08 0.248889 0.14 0.354771 255 255 255 150 1
touch_addbutton "say2" "touch/gfx/chat_team" "touch_hide say;touch_hide say2;messagemode2" 0.16 0.248889 0.22 0.354771 255 255 255 150 1
touch_addbutton "flight" "touch/gfx/flaghtlight" "impulse 100" 0.74 0 0.8 0.105882 255 255 255 150 1
touch_addbutton "plus_nvg" "touch/gfx/plus" "nvgadjustup" 0.7 0.106667 0.76 0.212549 255 255 255 150 1
touch_addbutton "minus_nvg" "touch/gfx/minus" "nvgadjustdown" 0.62 0.106667 0.68 0.212549 255 255 255 150 1
touch_addbutton "nightvision" "touch/gfx/nightvision" "nightvision;toggle_plusminus" 0.66 0 0.72 0.105882 255 255 255 150 1
touch_addbutton "drop" "touch/gfx/drop" "drop" 0.38 0 0.44 0.105882 255 255 255 150 0
touch_addbutton "light" "touch/gfx/light" "toggle_light" 0.58 0 0.64 0.105882 255 255 255 150 0
touch_addbutton "radio" "touch/gfx/radio" "showvguimenu 38" 0 0.391111 0.06 0.496993 255 255 255 150 0
touch_addbutton "spraypaint" "touch/gfx/spraypaint" "impulse 201" 0.82 0 0.88 0.105882 255 255 255 150 0
touch_addbutton "chat" "touch/gfx/chat" "toggle_chat" 0 0.248889 0.06 0.354771 255 255 255 150 0
touch_addbutton "w1" "touch/gfx/w_rifle" "slot1" 0.14 0 0.2 0.105882 255 255 255 150 0
touch_addbutton "w2" "touch/gfx/w_pistol" "slot2" 0.22 0 0.28 0.105882 255 255 255 150 0
touch_addbutton "w3" "touch/gfx/w_knife" "slot3" 0.3 0 0.36 0.105882 255 255 255 150 0
touch_addbutton "duck_sw" "touch/gfx/duck" "crouchtoggle" 0.34 0.811772 0.44 0.988242 255 255 255 150 0
touch_addbutton "touch_edit" "touch/gfx/settings" "touch_enableedit" 0.46 0 0.54 0.141176 255 255 255 150 0
touch_addbutton "voicechat" "touch/gfx/voicechat" "+voicerecord" 0.86 0.105882 0.92 0.211765 255 255 255 150 0
touch_addbutton "show_numbers" "touch_default/show_weapons" "exec touch_default/numbers.cfg" 0.46 0.811765 0.54 0.952941 255 255 255 150 0
touch_addbutton "cancelselect" "touch/gfx/exit" "cancelselect" 0.48 0.141176 0.54 0.247059 255 255 255 150 1
touch_addbutton "buy" "touch/gfx/buy" "buy" 0.56 0.847059 0.64 0.988235 255 255 255 150 0
touch_addbutton "w4" "touch/gfx/w_grenade" "slot4" 0.14 0.141176 0.2 0.247059 255 255 255 150 0
touch_addbutton "w5" "touch/gfx/w_c4" "slot5" 0.22 0.141176 0.28 0.247059 255 255 255 150 0
touch_addbutton "bots" "touch/gfx/botmenu" "exec touch/bots/bots" 0.3 0.141176 0.36 0.247059 255 255 255 150 0
touch_addbutton "cmd" "touch/gfx/cmdmenu" "exec touch/cmd/cmd" 0.38 0.141176 0.44 0.247059 255 255 255 150 0

```

`3rdparty/cs16client-extras/touch_presets/tablet_poverony.cfg`:

```cfg
//=======================================================================
//	Copyright SDLash3D team & XashXT group 2016 ©
//			touchscreen config
//=======================================================================

touch_config_file "touch_profiles/tablet_poverony.cfg"

// touch cvars

// _move sensitivity settings
touch_forwardzone "0.080000"
touch_sidezone "0.040000"

// _look sensitivity settings
touch_pitch "50.000000"
touch_yaw "50.000000"

// grid settings
touch_grid_count "100"
touch_grid_enable "1"

// global overstroke (width, r, g, b, a)
touch_set_stroke 2 90 90 90 200

// highlight when pressed
touch_highlight_r "1.000000"
touch_highlight_g "1.000000"
touch_highlight_b "1.000000"
touch_highlight_a "1.000000"

// _joy and _dpad options
touch_dpad_radius "1.000000"
touch_joy_radius "3.000000"

// how much slowdown when Precise Look button pressed
touch_precise_amount "0.500000"

// enable/disable move indicator
touch_move_indicator "2"

// reset menu state when execing config
touch_setclientonly 0

// touch buttons
touch_removeall
touch_addbutton "move" "" "_move" 0.000000 0.444444 0.460000 0.995556 255 255 255 150 0
touch_addbutton "look" "" "_look" 0.470000 0.248889 1.000000 0.604444 255 255 255 150 0
touch_addbutton "joy" "touch/gfx/joy" "_joy" 0.290000 0.187234 0.410000 0.391489 255 255 255 150 1 1
touch_addbutton "dpad" "touch/gfx/dpad" "_dpad" 0.170000 0.187234 0.290000 0.391489 255 255 255 150 1 1
touch_addbutton "invprev" "touch/gfx/left" "invprev" 0.000000 0.323404 0.080000 0.459574 255 255 255 150 1 1
touch_addbutton "invnext" "touch/gfx/right" "invnext" 0.080000 0.323404 0.160000 0.459574 255 255 255 150 1 1
touch_addbutton "radio" "touch/gfx/radio" "showvguimenu 38" 0.000000 0.187234 0.080000 0.323404 255 255 255 150 0 1
touch_addbutton "reload" "touch/gfx/reload" "+reload" 0.680000 0.680851 0.760000 0.817021 255 255 255 150 0 1
touch_addbutton "use" "touch/gfx/use" "+use" 0.700000 0.544681 0.780000 0.680851 255 255 255 150 0 1
touch_addbutton "spraypaint" "touch/gfx/spraypaint" "impulse 201" 0.700000 0.817021 0.780000 0.953192 255 255 255 150 0 1
touch_addbutton "drop" "touch/gfx/drop" "drop" 0.780000 0.868085 0.860000 1.004255 255 255 255 150 0 1
touch_addbutton "jump" "touch/gfx/jump" "+jump" 0.880000 0.800000 0.980000 0.970213 255 255 255 150 0 1
touch_addbutton "attack" "touch/gfx/attack" "+attack" 0.760000 0.612766 0.910000 0.868085 255 255 255 150 0 1
touch_addbutton "attack2" "touch/gfx/attack2" "+attack2" 0.900000 0.578723 1.000000 0.748936 255 255 255 150 0 1
touch_addbutton "w5" "touch/gfx/w_c4" "slot5" 0.760000 0.102128 0.840000 0.238298 255 255 255 150 0 1
touch_addbutton "w1" "touch/gfx/w_rifle" "slot1" 0.780000 0.238298 0.860000 0.374468 255 255 255 150 0 1
touch_addbutton "w2" "touch/gfx/w_pistol" "slot2" 0.840000 0.136170 0.920000 0.272340 255 255 255 150 0 1
touch_addbutton "w4" "touch/gfx/w_grenade" "slot4" 0.880000 0.017021 0.960000 0.153191 255 255 255 150 0 1
touch_addbutton "w3" "touch/gfx/w_knife" "slot3" 0.920000 0.136170 1.000000 0.272340 255 255 255 150 0 1
touch_addbutton "flight" "touch/gfx/flaghtlight" "impulse 100" 0.280000 0.851064 0.360000 0.987234 255 255 255 150 1 1
touch_addbutton "light" "touch/gfx/light" "toggle_light" 0.360000 0.851064 0.440000 0.987234 255 255 255 150 0 1
touch_addbutton "buy" "touch/gfx/buy" "buy" 0.440000 0.851064 0.520000 0.987234 255 255 255 150 0 1
touch_addbutton "score" "touch/gfx/score" "scoreboard" 0.520000 0.851064 0.600000 0.987234 255 255 255 150 0 1
touch_addbutton "nightvision" "touch/gfx/nightvision" "nightvision;toggle_plusminus" 0.360000 0.714894 0.440000 0.851064 255 255 255 150 1 1
touch_addbutton "minus_nvg" "touch/gfx/minus" "nvgadjustdown" 0.340000 0.629787 0.400000 0.731915 255 255 255 150 1 1
touch_addbutton "plus_nvg" "touch/gfx/plus" "nvgadjustup" 0.400000 0.629787 0.460000 0.731915 255 255 255 150 1 1
touch_addbutton "show_numbers" "touch_default/show_weapons" "exec touch_default/numbers.cfg" 0.440000 0.714894 0.520000 0.851064 255 255 255 150 1 1
touch_addbutton "duck" "touch/gfx/duck" "+duck" 0.000000 0.817021 0.100000 0.987234 255 255 255 150 512 1
touch_addbutton "duck_sw" "touch/gfx/duck" "crouchtoggle" 0.100000 0.817021 0.200000 0.987234 255 255 255 150 1 1
touch_addbutton "change_team" "touch/gfx/change_team" "chooseteam" 0.540000 0.000000 0.620000 0.136170 255 255 255 150 0 1
touch_addbutton "exit" "touch/gfx/exit" "cancelselect" 0.460000 0.000000 0.540000 0.136170 255 255 255 150 0 1
touch_addbutton "touch_edit" "touch/gfx/settings" "touch_enableedit" 0.380000 0.000000 0.460000 0.136170 255 255 255 150 0 1
touch_addbutton "cmd" "touch/gfx/cmdmenu" "exec touch/cmd/cmd" 0.100000 0.248889 0.200000 0.426667 255 255 255 150 1 1
touch_addbutton "radio" "touch/gfx/radio" "showvguimenu 38" 0.000000 0.248889 0.100000 0.426667 255 255 255 150 0 1
touch_addbutton "walk" "touch/gfx/walk" "+speed" 0.000000 0.640000 0.100000 0.817778 255 255 255 150 0 1

```

`3rdparty/cs16client-extras/touch_presets/touch_swank.cfg`:

```cfg
//=======================================================================
//	Copyright SDLash3D team & XashXT group 2016 ©
//			touchscreen config
//=======================================================================

touch_config_file "touch_profiles/touch_swank.cfg"

// touch cvars

// _move sensitivity settings
touch_forwardzone "0.124444"
touch_sidezone "0.066667"

// _look sensitivity settings
touch_pitch "162.000000"
touch_yaw "162.000000"

// grid settings
touch_grid_count "60"
touch_grid_enable "1"

// global overstroke (width, r, g, b, a)
touch_set_stroke 1 156 77 20 200

// highlight when pressed
touch_highlight_r "122.000000"
touch_highlight_g "122.000000"
touch_highlight_b "122.000000"
touch_highlight_a "180.000000"

// _joy and _dpad options
touch_dpad_radius "1.000000"
touch_joy_radius "1.000000"

// how much slowdown when Precise Look button pressed
touch_precise_amount "0.550000"

// enable/disable move indicator
touch_move_indicator "3"

// reset menu state when execing config
touch_setclientonly 0

// touch buttons
touch_removeall
touch_addbutton "move" "" "_move" 0.000000 0.166667 0.416667 1.000000 255 255 255 130 0
touch_addbutton "look" "" "_look" 0.416667 0.000000 1.000000 1.000000 255 255 255 130 0
touch_addbutton "buy" "touch/gfx/buy" "buy" 0.316667 0.861111 0.400000 1.000000 255 255 255 130 0 1
touch_addbutton "score" "touch/gfx/score" "scoreboard" 0.400000 0.861111 0.483333 1.000000 255 255 255 130 0 1
touch_addbutton "w2" "touch/gfx/w_pistol" "slot2" 0.833333 0.111111 0.916667 0.250000 255 255 255 130 0 1
touch_addbutton "w1" "touch/gfx/w_rifle" "slot1" 0.750000 0.111111 0.833333 0.250000 255 255 255 130 0 1
touch_addbutton "w3" "touch/gfx/w_knife" "slot3" 0.850000 0.000000 0.916667 0.111111 255 255 255 130 0 1
touch_addbutton "w4" "touch/gfx/w_grenade" "slot4" 0.783333 0.000000 0.850000 0.111111 255 255 255 130 0 1
touch_addbutton "w5" "touch/gfx/w_c4" "slot5" 0.716667 0.000000 0.783333 0.111111 255 255 255 130 0 1
touch_addbutton "reload" "touch/gfx/reload" "+reload" 0.916667 0.083333 1.000000 0.222222 255 255 255 130 0 1
touch_addbutton "jump" "touch/gfx/jump" "+jump" 0.900000 0.222222 1.000000 0.388889 255 255 255 130 0 1
touch_addbutton "use" "touch/gfx/use" "+use" 0.900000 0.388889 1.000000 0.555556 255 255 255 130 0 1
touch_addbutton "attack2" "touch/gfx/attack2" "+attack2" 0.800000 0.250000 0.900000 0.416667 255 255 255 130 0 1
touch_addbutton "touch_edit" "touch/gfx/settings" "touch_enableedit" 0.450000 0.000000 0.533333 0.138889 255 255 255 130 0 1
touch_addbutton "cmd" "touch/gfx/cmdmenu" "exec touch/cmd/cmd" 0.383333 0.000000 0.450000 0.111111 255 255 255 130 0 1
touch_addbutton "bots" "touch/gfx/botmenu" "exec touch/bots/bots" 0.316667 0.000000 0.383333 0.111111 255 255 255 130 0 1
touch_addbutton "spraypaint" "touch/gfx/spraypaint" "impulse 201" 0.600000 0.000000 0.666667 0.111111 255 255 255 130 0 1
touch_addbutton "nightvision" "touch/gfx/nightvision" "nightvision" 0.533333 0.111111 0.600000 0.222222 255 255 255 130 1 1
touch_addbutton "flight" "touch/gfx/flaghtlight" "impulse 100" 0.600000 0.111111 0.666667 0.222222 255 255 255 130 1 1
touch_addbutton "radio" "touch/gfx/radio" "showvguimenu 38" 0.250000 0.000000 0.316667 0.111111 255 255 255 130 0 1
touch_addbutton "change_team" "touch/gfx/change_team" "chooseteam" 0.183333 0.000000 0.250000 0.111111 255 255 255 130 0 1
touch_addbutton "duck" "touch/gfx/duck" "+duck" 0.900000 0.833333 1.000000 1.000000 255 255 255 130 0 1
touch_addbutton "attack" "touch/gfx/attack" "+attack" 0.783333 0.416667 0.900000 0.611111 255 255 255 130 512 1
touch_addbutton "duck_sw" "touch/gfx/duck" "crouchtoggle" 0.800000 0.833333 0.900000 1.000000 255 255 255 130 1 1
touch_addbutton "light" "touch/gfx/light" "toggle_light" 0.533333 0.000000 0.600000 0.111111 255 255 255 130 0 1
touch_addbutton "show_numbers" "touch_default/show_weapons" "exec touch_default/numbers.cfg" 0.466667 0.722222 0.550000 0.861111 255 255 255 130 1 1
touch_addbutton "drop" "touch/gfx/drop" "drop" 0.050000 0.277778 0.133333 0.416667 255 255 255 130 0 1

```

`3rdparty/cs16client-extras/userconfig.d/touch_defalias.cfg`:

```cfg
//==============================================================================================
//  Copyright (c) 2016 Poverennov Sergey aka SergioPoverony and Mikhail Stepanov aka ahsim
//==============================================================================================

cmd_scripting 1

// TOGGLE CROUCH or STAY
alias crouchtoggle "crouchdown"
alias crouchdown "+duck; alias crouchtoggle crouchup"
alias crouchup "-duck; alias crouchtoggle crouchdown"

// TOGGLE MESSAGES
alias toggle_chat show_say
alias show_say "touch_show say*;alias toggle_chat hide_say"
alias hide_say "touch_hide say*;alias toggle_chat show_say"

// TOGGLE LIGHT
alias toggle_light show_light
alias show_light "touch_show flight; touch_show nightvision; alias toggle_light hide_light"
alias hide_light "touch_hide flight; touch_hide nightvision; touch_hide plus_nvg; touch_hide minus_nvg; alias toggle_light show_light"

// TOGGLE PLUS/MINUS
alias toggle_plusminus show_plusminus
alias show_plusminus "touch_show plus_nvg; touch_show minus_nvg;alias toggle_plusminus hide_plusminus"
alias hide_plusminus "touch_hide plus_nvg; touch_hide minus_nvg;alias toggle_plusminus show_plusminus"

alias toggle_down show_down
alias show_down "touch_show cmd; touch_show change_team; touch_show bots; touch_show touch_edit; touch_show exit; alias toggle_down hide_down"
alias hide_down "touch_hide cmd ;touch_hide change_team; touch_hide bots; touch_hide touch_edit; touch_hide exit; alias toggle_down show_down"

// SCOREBOARD
alias scoreboard "exec touch/scoreboard.cfg"

// SET CVARS FOR MENU
set enable_controls "0"
set bot_quota_value "9"

```

`3rdparty/cs16client-extras/userconfig.d/userconfig.cfg`:

```cfg
// Default cvars
cl_nopred 0
cl_lc 1
cl_lw 1
cl_charset utf-8
hud_utf8 1
```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(cs16-client)

set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}/cmake/")

include(LibraryNaming)
# include(ExternalProject)

# for extras packaging
find_package(Python COMPONENTS Interpreter REQUIRED)

if (Python_FOUND)
	message(STATUS "Python interpreter found: ${Python_EXECUTABLE}")
else()
	message(FATAL_ERROR "Python not found. Please install Python.")
endif()

option(BUILD_CLIENT "Build client library." ON)
option(BUILD_MAINUI "Build menu library." ON)
option(BUILD_SERVER "Build server library." ON)

set(GAME_DIR "cstrike" CACHE STRING "Game directory name.")
set(CLIENT_INSTALL_DIR "cl_dlls" CACHE STRING "Client library location.")
set(SERVER_INSTALL_DIR "dlls" CACHE STRING "Server library location.")

# if(MSVC AND CMAKE_BUILD_TYPE STREQUAL "Debug")
# 	add_compile_options(/fsanitize=address)
# 	add_link_options(/fsanitize=address)
# endif()

if(VITA)
	message(STATUS "Building for PS Vita")
	add_compile_options(-fno-use-cxa-atexit)
endif()

if(BUILD_CLIENT)
	add_subdirectory(cl_dll)
endif()

# if(CMAKE_BUILD_TYPE STREQUAL "Debug")
# 	set(MESON_BUILD_TYPE debug)
# elseif(CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
# 	set(MESON_BUILD_TYPE debugoptimized)
# else()
# 	set(MESON_BUILD_TYPE release)
# endif()

if(BUILD_SERVER)
	# ExternalProject_Add(
	# 	yapb
	# 	SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/3rdparty/yapb
	# 	CONFIGURE_COMMAND meson setup --buildtype ${MESON_BUILD_TYPE} build
	# 	BUILD_COMMAND meson compile -C build
	# 	BUILD_ALWAYS 1
	# 	BUILD_IN_SOURCE 1
	# 	INSTALL_COMMAND meson install -C build --destdir ${CMAKE_INSTALL_PREFIX}
	# )
	add_subdirectory(3rdparty/yapb)
	set_target_postfix(yapb)

	set(XASH_COMPAT ON CACHE BOOL "" FORCE)
	add_subdirectory(3rdparty/ReGameDLL_CS)
endif()

if(BUILD_MAINUI)
#	set(CS16CLIENT ON)
	# set(XASH_SDK ../../)
	add_subdirectory(3rdparty/mainui_cpp)
endif()

set(GRAPHS_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/graphs")

execute_process(
	COMMAND ${Python_EXECUTABLE}
	${CMAKE_CURRENT_SOURCE_DIR}/scripts/yapb_graph_dl.py
	${GRAPHS_OUTPUT}/addons/yapb/data/graph
)

set(EXTRAS_DIR "${CMAKE_CURRENT_SOURCE_DIR}/3rdparty/cs16client-extras")
set(YAPB_DIR "${CMAKE_CURRENT_SOURCE_DIR}/3rdparty/yapb/cfg")

if(ANDROID)
	set(EXTRAS_OUTPUT "${CMAKE_CURRENT_SOURCE_DIR}/android/app/src/main/assets")

	file(GLOB EXTRAS_FILES "${EXTRAS_DIR}/*")
	file(GLOB YAPB_FILES "${YAPB_DIR}/*" "${GRAPHS_OUTPUT}/*")

	file(REMOVE_RECURSE ${EXTRAS_OUTPUT})
	file(
		COPY ${EXTRAS_FILES} ${YAPB_FILES}
		DESTINATION ${EXTRAS_OUTPUT}
	)
else()
	set(EXTRAS_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/extras.pk3")

	execute_process(
		COMMAND ${Python_EXECUTABLE}
		${CMAKE_CURRENT_SOURCE_DIR}/scripts/pack_extras.py
		${EXTRAS_OUTPUT}
		${EXTRAS_DIR}
		${YAPB_DIR}
		${GRAPHS_OUTPUT}
	)

	add_custom_target(generate_extras ALL
		DEPENDS ${GRAPHS_OUTPUT} ${EXTRAS_OUTPUT}
	)

	install(
		FILES "${EXTRAS_OUTPUT}"
		DESTINATION ${GAME_DIR}
	)
endif()

if(VITA)
	install(
		FILES
		"${CMAKE_CURRENT_BINARY_DIR}/config.cfg"
		"${CMAKE_CURRENT_BINARY_DIR}/video.cfg"
		"${CMAKE_CURRENT_BINARY_DIR}/opengl.cfg"
		DESTINATION "${GAME_DIR}/"
	)

	install(
		FILES
		"${CMAKE_CURRENT_BINARY_DIR}/kb_def.lst"
		DESTINATION "${GAME_DIR}/gfx/shell"
	)
endif()

if(WIN32)
	set(CPACK_GENERATOR "ZIP")
	set(CPACK_PACKAGE_FILE_NAME "CS16Client-${CMAKE_SYSTEM_NAME}-${CMAKE_CXX_COMPILER_ARCHITECTURE_ID}")
elseif(VITA)
	set(CPACK_GENERATOR "ZIP")
	set(CPACK_PACKAGE_FILE_NAME "CS16Client-PSVita")
elseif(APPLE)
	set(CPACK_GENERATOR "ZIP")
	set(CPACK_PACKAGE_FILE_NAME "CS16Client-macOS-${CMAKE_SYSTEM_PROCESSOR}")
else()
	set(CPACK_GENERATOR "TGZ")
	set(CPACK_PACKAGE_FILE_NAME "CS16Client-${CMAKE_SYSTEM_NAME}-${CMAKE_SYSTEM_PROCESSOR}")
endif()

set(CPACK_INCLUDE_TOPLEVEL_DIRECTORY OFF)

include(CPack)
```

`CMakePresets.json`:

```json
{
  "version": 3,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 21,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "win32-debug-amd64",
      "displayName": "Windows Debug - amd64",
      "generator": "Ninja",
      "architecture": {
        "value": "x64",
        "strategy": "external"
      },
      "binaryDir": "${sourceDir}/build",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_C_COMPILER": "cl",
        "CMAKE_CXX_COMPILER": "cl"
      },
      "vendor": {
        "microsoft.com/VisualStudioSettings/CMake/1.0": {
          "hostOS": [
            "Windows"
          ]
        }
      }
    },
    {
      "name": "win32-debug-x86",
      "inherits": "win32-debug-amd64",
      "displayName": "Windows Debug - x86",
      "architecture": {
        "value": "x86",
        "strategy": "external"
      }
    },
    {
      "name": "win32-release-amd64",
      "inherits": "win32-debug-amd64",
      "displayName": "Windows Release - amd64",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release"
      }
    },
    {
      "name": "win32-release-x86",
      "inherits": "win32-debug-x86",
      "displayName": "Windows Release - x86",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release"
      }
    },
    {
      "name": "linux-release-amd64",
      "displayName": "Linux Release - amd64",
      "generator": "Ninja",
      "architecture": {
        "value": "x64",
        "strategy": "external"
      },
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release"
      },
      "binaryDir": "${sourceDir}/build"
    },
    {
      "name": "linux-release-i386",
      "inherits": "linux-release-amd64",
      "displayName": "Linux Release - i386",
      "architecture": {
        "value": "x86",
        "strategy": "external"
      },
      "toolchainFile": "${sourceDir}/toolchains/i386-linux-gnu.cmake"
    },
    {
      "name": "psvita-debug",
      "displayName": "PS Vita - Debug",
      "generator": "Unix Makefiles",
      "toolchainFile": "$env{VITASDK}/share/vita.toolchain.cmake",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "BUILD_SERVER": "OFF",
        "MAINUI_USE_STB": "ON",
        "CMAKE_PROJECT_cs16-client_INCLUDE": "$env{VITASDK}/share/vrtld_shim.cmake"
      },
      "binaryDir": "${sourceDir}/build"
    },
    {
      "name": "psvita-release",
      "displayName": "PS Vita - Release",
      "generator": "Unix Makefiles",
      "toolchainFile": "$env{VITASDK}/share/vita.toolchain.cmake",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "BUILD_SERVER": "OFF",
        "MAINUI_USE_STB": "ON",
        "CMAKE_PROJECT_cs16-client_INCLUDE": "$env{VITASDK}/share/vrtld_shim.cmake"
      },
      "binaryDir": "${sourceDir}/build"
    },
    {
      "name": "linux-ci-amd64",
      "inherits": "linux-release-amd64",
      "displayName": "Linux CI - amd64",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "RelWithDebInfo"
      }
    },
    {
      "name": "linux-ci-i386",
      "inherits": "linux-release-i386",
      "displayName": "Linux CI - i386",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "RelWithDebInfo"
      }
    },
    {
      "name": "win32-ci-amd64",
      "inherits": "win32-debug-amd64",
      "displayName": "Windows CI - amd64",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "RelWithDebInfo"
      }
    },
    {
      "name": "win32-ci-x86",
      "inherits": "win32-debug-x86",
      "displayName": "Windows CI - x86",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "RelWithDebInfo"
      }
    },
    {
      "name": "macos-ci-x86_64",
      "displayName": "macOS CI - x86_64",
      "generator": "Ninja",
      "architecture": {
        "value": "x64",
        "strategy": "external"
      },
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "RelWithDebInfo",
        "CMAKE_C_COMPILER": "gcc",
        "CMAKE_CXX_COMPILER": "g++",
        "CMAKE_CXX_STANDARD": "11",
        "CMAKE_CXX_STANDARD_REQUIRED": "ON"
      },
      "binaryDir": "${sourceDir}/build"
    },
    {
      "name": "macos-ci-arm64",
      "inherits": "macos-ci-x86_64",
      "displayName": "macOS CI - arm64",
      "architecture": {
        "value": "arm64",
        "strategy": "external"
      }
    }
  ]
}
```

`LICENSE`:

```
CS16Client LICENSE
==================

Copyright (C) 2015-2016 Flying With Gauss

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.


Half Life 1 SDK LICENSE
======================

Half Life 1 SDK Copyright(C) Valve Corp.  

THIS DOCUMENT DESCRIBES A CONTRACT BETWEEN YOU AND VALVE CORPORATION (?Valve?).  PLEASE READ IT BEFORE DOWNLOADING OR USING THE HALF LIFE 1 SDK (?SDK?). BY DOWNLOADING AND/OR USING THE SOURCE ENGINE SDK YOU ACCEPT THIS LICENSE. IF YOU DO NOT AGREE TO THE TERMS OF THIS LICENSE PLEASE DON?T DOWNLOAD OR USE THE SDK.

You may, free of charge, download and use the SDK to develop a modified Valve game running on the Source engine.  You may distribute your modified Valve game in source and object code form, but only for free. Terms of use for Valve games are found in the Steam Subscriber Agreement located here: http://store.steampowered.com/subscriber_agreement/ 

You may copy, modify, and distribute the SDK and any modifications you make to the SDK in source and object code form, but only for free.  Any distribution of this SDK must include this license.txt and third_party_licenses.txt.  
 
Any distribution of the SDK or a substantial portion of the SDK must include the above copyright notice and the following: 

DISCLAIMER OF WARRANTIES.  THE SOURCE SDK AND ANY OTHER MATERIAL DOWNLOADED BY LICENSEE IS PROVIDED ?AS IS?.  VALVE AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES WITH RESPECT TO THE SDK, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, TITLE AND FITNESS FOR A PARTICULAR PURPOSE.  

LIMITATION OF LIABILITY.  IN NO EVENT SHALL VALVE OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THE ENGINE AND/OR THE SDK, EVEN IF VALVE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  
 
 
If you would like to use the SDK for a commercial purpose, please contact Valve at sourceengine@valvesoftware.com.

```

`README.md`:

```md
# CS16Client [![Build Status](https://github.com/Velaron/cs16-client/actions/workflows/build.yml/badge.svg)](https://github.com/Velaron/cs16-client/actions) <img align="right" width="128" height="128" src="https://github.com/Velaron/cs16-client/raw/main/android/app/src/main/ic_launcher-playstore.png" alt="CS16Client" />
Reverse-engineered Counter Strike 1.6 client, designed for mobile platforms and other officially non-supported platforms.

## Donate
[![Boosty.to](https://img.shields.io/badge/Boosty-F15F2C?logo=boosty&logoColor=fff&style=for-the-badge)](https://boosty.to/velaron)

[Support me](https://boosty.to/velaron) on Boosty.to, if you like my work and would like to support further development goals, like reverse-engineering other great mods.

Important contributors:
* [a1batross](https://github.com/a1batross), initial project creator and maintainer.
* [jeefo](https://github.com/jeefo), the creator of [YaPB](https://github.com/yapb/yapb).
* The people behind [ReGameDLL_CS](https://github.com/rehlds/ReGameDLL_CS) project.
* [Vladislav4KZ](https://github.com/Vladislav4KZ), bug-tester and maintainer.
* [SNMetamorph](https://github.com/SNMetamorph), author of the PSVita port.
* [Alprnn357](https://github.com/Alprnn357), touch menus maintainer.
* [wh1tesh1t](https://github.com/wh1tesh1t), [pwd491](https://github.com/pwd491), [Elinsrc](https://github.com/Elinsrc), [xiaodo1337](https://github.com/xiaodo1337), [nekonomicon](https://github.com/nekonomicon), [lewa-j](https://github.com/lewa-j) and others for minor contributions.

## Download
You can download a build at the `Releases` section, or use these links for common platforms:
* [Android](https://github.com/Velaron/cs16-client/releases/download/continuous/CS16Client-Android.apk)
* [Linux](https://github.com/Velaron/cs16-client/releases/download/continuous/CS16Client-Linux-i386.tar.gz)
* [Windows](https://github.com/Velaron/cs16-client/releases/download/continuous/CS16Client-Windows-X86.zip)
* [PS Vita](https://github.com/Velaron/cs16-client/releases/download/continuous/CS16Client-PSVita.zip)
* [macOS (arm64)](https://github.com/Velaron/cs16-client/releases/download/continuous/CS16Client-macOS-arm64.zip) - not tested
* [macOS (x86_64)](https://github.com/Velaron/cs16-client/releases/download/continuous/CS16Client-macOS-x86_64.zip) - not tested

[Other platforms...](https://github.com/Velaron/cs16-client/releases/tag/continuous)

## Installation
To run CS16Client you need the [latest developer build of Xash3D FWGS](https://github.com/FWGS/xash3d-fwgs/releases/tag/continuous).
You have to own the [game on Steam](https://store.steampowered.com/app/10/CounterStrike//) and copy `valve` and `cstrike` folders into your Xash3D FWGS directory.
After that, just install the APK and run.

## Configuration (CVars)
| CVar                     | Default       | Min | Max | Description                                                                                 |
|--------------------------|---------------|-----|-----|---------------------------------------------------------------------------------------------|
| hud_color                | "255 160 0"   | -   | -   | HUD color in RGB.                                                                           |
| cl_quakeguns             | 0             | 0   | 1   | Draw centered weapons.                                                                      |
| cl_weaponlag             | 0             | 0.0 | -   | Enable weapon lag/sway.                                                                     |
| xhair_additive           | 0             | 0   | 1   | Makes the crosshair additive.                                                               |
| xhair_color              | "0 255 0 255" | -   | -   | Crosshair's color (RGBA).                                                                   |
| xhair_dot                | 0             | 0   | 1   | Enables crosshair dot.                                                                      |
| xhair_dynamic_move       | 1             | 0   | 1   | Jumping, crouching and moving will affect the dynamic crosshair (like cl_dynamiccrosshair). |
| xhair_dynamic_scale      | 0             | 0   | -   | Scale of the dynamic crosshair movement.                                                    |
| xhair_gap_useweaponvalue | 0             | 0   | 1   | Makes the crosshair gap scale depend on the active weapon.                                  |
| xhair_enable             | 0             | 0   | 1   | Enables enhanced crosshair.                                                                 |
| xhair_gap                | 0             | 0   | 15  | Space between crosshair's lines.                                                            |
| xhair_pad                | 0             | 0   | -   | Border around crosshair.                                                                    |
| xhair_size               | 4             | 0   | -   | Crosshair size.                                                                             |
| xhair_t                  | 0             | 0   | 1   | Enables T-shaped crosshair.                                                                 |
| xhair_thick              | 0             | 0   | -   | Crosshair thickness.                                                                        |

## Building
Clone the source code:
```shell
git clone https://github.com/Velaron/cs16-client --recursive
```

### Using CMakePresets.json
```shell
cmake --preset <preset-name>
cmake --build build
cmake --install build --prefix <path-to-your-installation>
```

### Windows
```shell
cmake -A Win32 -S . -B build
cmake --build build --config Release
cmake --install build --prefix <path-to-your-installation>
```
### Linux and macOS
```shell
cmake -S . -B build
cmake --build build --config Release
cmake --install build --prefix <path-to-your-installation>
```
### Android
```shell
cd android
./gradlew assembleRelease
```

```

`android/app/build.gradle`:

```gradle
import java.time.LocalDateTime
import java.time.Month
import java.time.temporal.ChronoUnit

apply plugin: "com.android.application"

android {
	namespace = "su.xash.cs16client"
	ndkVersion = "28.2.13676358"
	compileSdk = 36

	defaultConfig {
		applicationId = "su.xash.cs16client"
		versionName = "1.35-" + getGitHash()
		versionCode = getBuildNum()
		minSdk = 21
		targetSdk = 36
	}

	compileOptions {
		sourceCompatibility = JavaVersion.VERSION_11
		targetCompatibility = JavaVersion.VERSION_11
	}

	externalNativeBuild {
		cmake {
			version = "3.22.1"
			path file("../../CMakeLists.txt")
		}
	}

	lint {
		abortOnError = false
	}

	packaging {
		jniLibs {
			keepDebugSymbols.add("**/*.so")
			useLegacyPackaging = true
		}
	}

	signingConfigs {
		debug {}

		continuous {
			if (System.getenv('KEYSTORE_FILE_PATH') != null) {
				storeFile = file(System.getenv('KEYSTORE_FILE_PATH'))
				storePassword = System.getenv('KEYSTORE_PASSWORD')
				keyAlias = System.getenv('KEY_ALIAS')
				keyPassword = System.getenv('KEY_PASSWORD')
			}
		}
	}

	buildTypes {
		debug {
			debuggable = true
			applicationIdSuffix = ".test"

			proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.txt"
		}

		release {
			minifyEnabled = true
			shrinkResources = true

			proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.txt"
		}

		create("continuous") {
			initWith(getByName("release"))
			applicationIdSuffix = ".test"
			signingConfig = signingConfigs.continuous
		}
	}

	flavorDimensions += "version"

	productFlavors {
		create("googlePlay") {
			dimension = "version"
			applicationId = "in.celest.xash3d.cs16client"
			buildConfigField("Boolean", "IS_GOOGLE_PLAY_BUILD", "true")
		}

		create("git") {
			dimension = "version"
			buildConfigField("Boolean", "IS_GOOGLE_PLAY_BUILD", "false")
		}
	}

	buildFeatures {
		buildConfig = true
	}
}

static def getBuildNum() {
	LocalDateTime now = LocalDateTime.now()
	LocalDateTime releaseDate = LocalDateTime.of(2015, Month.OCTOBER, 29, 0, 0, 0)
	int qBuildNum = releaseDate.until(now, ChronoUnit.DAYS)
	int minuteOfDay = now.getHour() * 60 + now.getMinute()
	return qBuildNum * 10000 + minuteOfDay
}

def getGitHash() {
	Process process = new ProcessBuilder("git", "rev-parse", "--short", "HEAD")
			.directory(project.rootDir)
			.redirectErrorStream(true)
			.start()
	InputStreamReader inputStreamReader = new InputStreamReader(process.getInputStream())
	BufferedReader bufferedReader = new BufferedReader(inputStreamReader)

	return bufferedReader.getText().trim()
}
```

`android/app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:forceQueryable="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher"
        tools:targetApi="r">

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

            <intent-filter>
                <action android:name="su.xash.engine.MOD" />
            </intent-filter>
        </activity>

		<activity
			android:name=".CZeroActivity"
			android:icon="@mipmap/ic_launcher_cz"
			android:label="CSCZClient"
			android:roundIcon="@mipmap/ic_launcher_cz"
			android:exported="true">
			<intent-filter>
				<action android:name="android.intent.action.MAIN" />

				<category android:name="android.intent.category.LAUNCHER" />
			</intent-filter>

			<intent-filter>
				<action android:name="su.xash.engine.MOD" />
			</intent-filter>
		</activity>
    </application>

    <queries>
        <package android:name="su.xash.engine" />
        <package android:name="su.xash.engine.test" />
    </queries>
</manifest>
```

`android/app/src/main/java/su/xash/cs16client/CZeroActivity.java`:

```java
package su.xash.cs16client;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;

public class CZeroActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String pkg = "su.xash.engine.test";

        try {
            getPackageManager().getPackageInfo(pkg, 0);
        } catch (PackageManager.NameNotFoundException e) {
            try {
                pkg = "su.xash.engine";
                getPackageManager().getPackageInfo(pkg, 0);
            } catch (PackageManager.NameNotFoundException ex) {
                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/FWGS/xash3d-fwgs/releases/tag/continuous")).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK));
                finish();
                return;
            }
        }

        startActivity(new Intent().setComponent(new ComponentName(pkg, "su.xash.engine.XashActivity"))
                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)
                .putExtra("gamedir", "czero")
                .putExtra("gamelibdir", getApplicationInfo().nativeLibraryDir)
                .putExtra("argv", "-dev 2 -log -dll @yapb")
                .putExtra("package", getPackageName()));
        finish();
    }
}

```

`android/app/src/main/java/su/xash/cs16client/MainActivity.java`:

```java
package su.xash.cs16client;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String pkg = "su.xash.engine.test";

        try {
            getPackageManager().getPackageInfo(pkg, 0);
        } catch (PackageManager.NameNotFoundException e) {
            try {
                pkg = "su.xash.engine";
                getPackageManager().getPackageInfo(pkg, 0);
            } catch (PackageManager.NameNotFoundException ex) {
                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/FWGS/xash3d-fwgs/releases/tag/continuous")).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK));
                finish();
                return;
            }
        }

        startActivity(new Intent().setComponent(new ComponentName(pkg, "su.xash.engine.XashActivity"))
                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)
                .putExtra("gamedir", "cstrike")
                .putExtra("gamelibdir", getApplicationInfo().nativeLibraryDir)
                .putExtra("argv", "-dev 2 -log -dll @yapb")
                .putExtra("package", getPackageName()));
        finish();
    }
}

```

`android/app/src/main/res/drawable/ic_launcher_cz_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="432"
    android:viewportHeight="432">
  <group android:scaleX="0.99"
      android:scaleY="0.99"
      android:translateX="6.12"
      android:translateY="2.16">
    <path
        android:pathData="M282.5,151.1v-6.7h-3v3.2h-6.9v-3h-1.8v2.6h-6.7v-4.2h-1.4v-0.8h-1.2v2.4h-1.4v1.2h-8.3v-1.4h-7.6v-2.8h-4v1.4h-7.2c-0.5,0.6 -1,1.1 -1.4,1.6 -0.7,0.9 -1.3,1.9 -1.8,2.8h-4l-4.1,-0.7 -0.2,1.6c0.4,-3.3 0.7,-5.5 0.5,-5.7 -0.9,-1.6 1.7,-4.6 2.1,-5.1l2.2,-3.6 -2.3,-4.9c-3.7,-7.9 -9.2,-12.2 -14.5,-11.3 -5.4,1 -6.8,1.6 -10.5,4.9 -3,2.8 -4.1,4.7 -5,8.8 -0.6,2.9 -0.8,6 -0.4,6.9 0.4,1.1 0,1.7 -0.9,1.7s-4.6,3.9 -8.5,8.6l-6.9,8.5 -1.2,9.2c-1.2,8.4 -5.1,29 -6.7,34.4 -0.4,1.4 -0.2,2.3 0.5,2.3s0.9,1.3 0.5,3.7c-0.3,2.1 0,5.1 0.5,6.6 0.9,2.2 0.6,4.4 -1.5,11.5 -1.4,4.8 -4.5,15.6 -6.7,23.9 -3.9,14 -4.4,15.4 -7,16.4 -3.5,1.5 -11.8,10.6 -14.4,15.8l-2,4.1 2.1,7.1c1.8,6.1 2.7,7.6 5.7,9.6s4.3,2.3 7.8,1.7c5.2,-0.8 6.9,-3.9 5.2,-9.5 -0.6,-2 -1.1,-3.9 -1.1,-4.3s3.1,-0.6 6.9,-0.6c6.3,0 7,-0.2 7.7,-2.3 0.4,-1.2 2.5,-6 4.6,-10.6 2.2,-4.6 4.6,-10.7 5.3,-13.5 2.2,-8.2 11.7,-30.6 13,-30.6 2.3,0 6.4,4.1 11.9,11.8 3,4.2 7.5,9.7 10,12.1 2.6,2.6 4.8,5.7 5.1,7.5 0.4,1.7 2.2,9.4 4.2,17.1 2.2,9.1 3.3,15.2 2.9,17.5 -0.7,4.7 2.7,9.6 9.9,13.9 5.2,3.2 6,3.3 10.3,2.5 6.3,-1.2 6.5,-3.4 1.4,-12.3 -3.6,-6.2 -4.1,-7.9 -4.7,-15.8 -0.3,-4.8 -1.3,-11.6 -2.1,-15 -0.8,-3.5 -1.4,-8.2 -1.3,-10.5 0,-3.6 -0.6,-5.4 -4.2,-10.8 -2.3,-3.6 -5.8,-8.3 -7.6,-10.6 -3.7,-4.6 -4.1,-6.8 -1.6,-8.3 1.6,-0.8 1.6,-1.2 -0.2,-4.6 -1.1,-2 -4.2,-6.2 -6.8,-9.3 -2.7,-3.1 -5.6,-7 -6.5,-8.5 -1.3,-2.1 -2.2,-2.7 -3.9,-2.2 -2.2,0.5 -2.3,0.2 -2.3,-4.4s0.4,-5.1 2,-5.6c2.2,-0.7 2.8,-2.6 3.2,-9.5l0.3,-4.5s0.4,-2.5 0.9,-6.2v1c-0.1,0 4.2,0 4.2,0q0,0.2 0,0l10.9,0.8c0.9,-0.4 1.8,-0.9 2.6,-1.4 1.8,-0.9 3.2,-2 4.4,-3 0.1,-0.1 0.4,-0.3 0.8,-0.4 0.4,0 0.7,-0.3 0.8,-0.4 1.6,-1.6 2.7,-2.7 3.4,-3.3s1.1,-1 1.4,-1 0.4,0 0.6,0.1h1.4c0.8,0 1.5,-0.1 2.1,-0.1s1.1,-0.2 1.7,-0.3c0.6,0 1.1,-0.3 1.6,-0.4l1.8,-3.2c0.3,-0.4 0.5,-0.7 0.6,-0.8 0.3,-0.2 0.5,0 0.6,0.8 0.3,1.1 0.8,3.1 1.7,5.9 0.9,2.8 2.5,6 4.7,9.6l4.2,-2c-1.5,-2.5 -2.7,-5 -3.6,-7.2 -1,-1.9 -1.7,-3.8 -2.2,-5.8s-0.7,-3.6 -0.4,-4.6c0.4,0 0.9,0 1.4,-0.2 0.4,-0.2 0.9,-0.3 1.4,-0.5 0.6,-0.2 1.1,-0.4 1.6,-0.7 0.9,-0.5 1.5,-1.4 1.8,-2.4 0.2,-0.6 0.2,-1.1 0.2,-1.6h20.5v-4.2h-5.2,0.1ZM240.4,156.3c-0.8,0.8 -1.8,1.5 -3,2 -1.5,0.7 -2.6,1.1 -3.5,1.5s-1.6,0.6 -2.3,0.7c-0.8,0.3 -1.4,0.8 -1.9,1.5 -0.5,0.8 -1,1.1 -1.7,1.1h0.2c-0.3,0.2 -0.8,0.2 -1.5,0.2s-1.4,0 -2.1,0.2c-0.9,0 -0.4,-6 0.3,-6.4 0.6,-0.3 1.1,-0.6 1.8,-0.9s1.3,-0.6 2,-0.9 1.7,-0.4 3,-0.3h4.2c1.5,0.2 3.3,0.2 5.3,0.2 -0.1,0.3 -0.4,0.6 -0.8,1h0Z"
        android:fillColor="#152036"/>
  </group>
</vector>

```

`android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
    <monochrome android:drawable="@mipmap/ic_launcher_monochrome"/>
</adaptive-icon>
```

`android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_cz.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_cz_background"/>
    <foreground android:drawable="@drawable/ic_launcher_cz_foreground"/>
</adaptive-icon>
```

`android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_cz_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_cz_background"/>
    <foreground android:drawable="@drawable/ic_launcher_cz_foreground"/>
</adaptive-icon>
```

`android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="432dp"
    android:height="432dp"
    android:viewportWidth="432"
    android:viewportHeight="432">
  <path
      android:pathData="M282.5,151.1v-6.7h-3v3.2h-6.9v-3h-1.8v2.6h-6.7v-4.2h-1.4v-0.8h-1.2v2.4h-1.4v1.2h-8.3v-1.4h-7.6v-2.8h-4v1.4h-7.2c-0.5,0.6 -1,1.1 -1.4,1.6 -0.7,0.9 -1.3,1.9 -1.8,2.8h-4l-4.1,-0.7 -0.2,1.6c0.4,-3.3 0.7,-5.5 0.5,-5.7 -0.9,-1.6 1.7,-4.6 2.1,-5.1l2.2,-3.6 -2.3,-4.9c-3.7,-7.9 -9.2,-12.2 -14.5,-11.3 -5.4,1 -6.8,1.6 -10.5,4.9 -3,2.8 -4.1,4.7 -5,8.8 -0.6,2.9 -0.8,6 -0.4,6.9 0.4,1.1 0,1.7 -0.9,1.7s-4.6,3.9 -8.5,8.6l-6.9,8.5 -1.2,9.2c-1.2,8.4 -5.1,29 -6.7,34.4 -0.4,1.4 -0.2,2.3 0.5,2.3s0.9,1.3 0.5,3.7c-0.3,2.1 0,5.1 0.5,6.6 0.9,2.2 0.6,4.4 -1.5,11.5 -1.4,4.8 -4.5,15.6 -6.7,23.9 -3.9,14 -4.4,15.4 -7,16.4 -3.5,1.5 -11.8,10.6 -14.4,15.8l-2,4.1 2.1,7.1c1.8,6.1 2.7,7.6 5.7,9.6s4.3,2.3 7.8,1.7c5.2,-0.8 6.9,-3.9 5.2,-9.5 -0.6,-2 -1.1,-3.9 -1.1,-4.3s3.1,-0.6 6.9,-0.6c6.3,0 7,-0.2 7.7,-2.3 0.4,-1.2 2.5,-6 4.6,-10.6 2.2,-4.6 4.6,-10.7 5.3,-13.5 2.2,-8.2 11.7,-30.6 13,-30.6 2.3,0 6.4,4.1 11.9,11.8 3,4.2 7.5,9.7 10,12.1 2.6,2.6 4.8,5.7 5.1,7.5 0.4,1.7 2.2,9.4 4.2,17.1 2.2,9.1 3.3,15.2 2.9,17.5 -0.7,4.7 2.7,9.6 9.9,13.9 5.2,3.2 6,3.3 10.3,2.5 6.3,-1.2 6.5,-3.4 1.4,-12.3 -3.6,-6.2 -4.1,-7.9 -4.7,-15.8 -0.3,-4.8 -1.3,-11.6 -2.1,-15 -0.8,-3.5 -1.4,-8.2 -1.3,-10.5 0,-3.6 -0.6,-5.4 -4.2,-10.8 -2.3,-3.6 -5.8,-8.3 -7.6,-10.6 -3.7,-4.6 -4.1,-6.8 -1.6,-8.3 1.6,-0.8 1.6,-1.2 -0.2,-4.6 -1.1,-2 -4.2,-6.2 -6.8,-9.3 -2.7,-3.1 -5.6,-7 -6.5,-8.5 -1.3,-2.1 -2.2,-2.7 -3.9,-2.2 -2.2,0.5 -2.3,0.2 -2.3,-4.4s0.4,-5.1 2,-5.6c2.2,-0.7 2.8,-2.6 3.2,-9.5l0.3,-4.5s0.4,-2.5 0.9,-6.2v1c-0.1,0 4.2,0 4.2,0q0,0.2 0,0l10.9,0.8c0.9,-0.4 1.8,-0.9 2.6,-1.4 1.8,-0.9 3.2,-2 4.4,-3 0.1,-0.1 0.4,-0.3 0.8,-0.4 0.4,0 0.7,-0.3 0.8,-0.4 1.6,-1.6 2.7,-2.7 3.4,-3.3s1.1,-1 1.4,-1 0.4,0 0.6,0.1h1.4c0.8,0 1.5,-0.1 2.1,-0.1s1.1,-0.2 1.7,-0.3c0.6,0 1.1,-0.3 1.6,-0.4l1.8,-3.2c0.3,-0.4 0.5,-0.7 0.6,-0.8 0.3,-0.2 0.5,0 0.6,0.8 0.3,1.1 0.8,3.1 1.7,5.9 0.9,2.8 2.5,6 4.7,9.6l4.2,-2c-1.5,-2.5 -2.7,-5 -3.6,-7.2 -1,-1.9 -1.7,-3.8 -2.2,-5.8s-0.7,-3.6 -0.4,-4.6c0.4,0 0.9,0 1.4,-0.2 0.4,-0.2 0.9,-0.3 1.4,-0.5 0.6,-0.2 1.1,-0.4 1.6,-0.7 0.9,-0.5 1.5,-1.4 1.8,-2.4 0.2,-0.6 0.2,-1.1 0.2,-1.6h20.5v-4.2h-5.2,0.1ZM240.4,156.3c-0.8,0.8 -1.8,1.5 -3,2 -1.5,0.7 -2.6,1.1 -3.5,1.5s-1.6,0.6 -2.3,0.7c-0.8,0.3 -1.4,0.8 -1.9,1.5 -0.5,0.8 -1,1.1 -1.7,1.1h0.2c-0.3,0.2 -0.8,0.2 -1.5,0.2s-1.4,0 -2.1,0.2c-0.9,0 -0.4,-6 0.3,-6.4 0.6,-0.3 1.1,-0.6 1.8,-0.9s1.3,-0.6 2,-0.9 1.7,-0.4 3,-0.3h4.2c1.5,0.2 3.3,0.2 5.3,0.2 -0.1,0.3 -0.4,0.6 -0.8,1h0Z"
      android:fillColor="#152036"/>
</vector>

```

`android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_monochrome.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="432dp"
    android:height="432dp"
    android:viewportWidth="432"
    android:viewportHeight="432">
  <path
      android:fillColor="#FF000000"
      android:pathData="M282.5,151.1v-6.7h-3v3.2h-6.9v-3h-1.8v2.6h-6.7v-4.2h-1.4v-0.8h-1.2v2.4h-1.4v1.2h-8.3v-1.4h-7.6v-2.8h-4v1.4h-7.2c-0.5,0.6 -1,1.1 -1.4,1.6 -0.7,0.9 -1.3,1.9 -1.8,2.8h-4l-4.1,-0.7 -0.2,1.6c0.4,-3.3 0.7,-5.5 0.5,-5.7 -0.9,-1.6 1.7,-4.6 2.1,-5.1l2.2,-3.6 -2.3,-4.9c-3.7,-7.9 -9.2,-12.2 -14.5,-11.3 -5.4,1 -6.8,1.6 -10.5,4.9 -3,2.8 -4.1,4.7 -5,8.8 -0.6,2.9 -0.8,6 -0.4,6.9 0.4,1.1 0,1.7 -0.9,1.7s-4.6,3.9 -8.5,8.6l-6.9,8.5 -1.2,9.2c-1.2,8.4 -5.1,29 -6.7,34.4 -0.4,1.4 -0.2,2.3 0.5,2.3s0.9,1.3 0.5,3.7c-0.3,2.1 0,5.1 0.5,6.6 0.9,2.2 0.6,4.4 -1.5,11.5 -1.4,4.8 -4.5,15.6 -6.7,23.9 -3.9,14 -4.4,15.4 -7,16.4 -3.5,1.5 -11.8,10.6 -14.4,15.8l-2,4.1 2.1,7.1c1.8,6.1 2.7,7.6 5.7,9.6s4.3,2.3 7.8,1.7c5.2,-0.8 6.9,-3.9 5.2,-9.5 -0.6,-2 -1.1,-3.9 -1.1,-4.3s3.1,-0.6 6.9,-0.6c6.3,0 7,-0.2 7.7,-2.3 0.4,-1.2 2.5,-6 4.6,-10.6 2.2,-4.6 4.6,-10.7 5.3,-13.5 2.2,-8.2 11.7,-30.6 13,-30.6 2.3,0 6.4,4.1 11.9,11.8 3,4.2 7.5,9.7 10,12.1 2.6,2.6 4.8,5.7 5.1,7.5 0.4,1.7 2.2,9.4 4.2,17.1 2.2,9.1 3.3,15.2 2.9,17.5 -0.7,4.7 2.7,9.6 9.9,13.9 5.2,3.2 6,3.3 10.3,2.5 6.3,-1.2 6.5,-3.4 1.4,-12.3 -3.6,-6.2 -4.1,-7.9 -4.7,-15.8 -0.3,-4.8 -1.3,-11.6 -2.1,-15 -0.8,-3.5 -1.4,-8.2 -1.3,-10.5 0,-3.6 -0.6,-5.4 -4.2,-10.8 -2.3,-3.6 -5.8,-8.3 -7.6,-10.6 -3.7,-4.6 -4.1,-6.8 -1.6,-8.3 1.6,-0.8 1.6,-1.2 -0.2,-4.6 -1.1,-2 -4.2,-6.2 -6.8,-9.3 -2.7,-3.1 -5.6,-7 -6.5,-8.5 -1.3,-2.1 -2.2,-2.7 -3.9,-2.2 -2.2,0.5 -2.3,0.2 -2.3,-4.4s0.4,-5.1 2,-5.6c2.2,-0.7 2.8,-2.6 3.2,-9.5l0.3,-4.5s0.4,-2.5 0.9,-6.2v1c-0.1,0 4.2,0 4.2,0 0,0.2 0,0.2 0,0l10.9,0.8c0.9,-0.4 1.8,-0.9 2.6,-1.4 1.8,-0.9 3.2,-2 4.4,-3 0.1,-0.1 0.4,-0.3 0.8,-0.4 0.4,0 0.7,-0.3 0.8,-0.4 1.6,-1.6 2.7,-2.7 3.4,-3.3 0.7,-0.6 1.1,-1 1.4,-1 0.3,0 0.4,0 0.6,0.1 0.2,0 0.6,0 1.4,0 0.8,0 1.5,-0.1 2.1,-0.1 0.6,0 1.1,-0.2 1.7,-0.3 0.6,0 1.1,-0.3 1.6,-0.4l1.8,-3.2c0.3,-0.4 0.5,-0.7 0.6,-0.8 0.3,-0.2 0.5,0 0.6,0.8 0.3,1.1 0.8,3.1 1.7,5.9 0.9,2.8 2.5,6 4.7,9.6l4.2,-2c-1.5,-2.5 -2.7,-5 -3.6,-7.2 -1,-1.9 -1.7,-3.8 -2.2,-5.8s-0.7,-3.6 -0.4,-4.6c0.4,0 0.9,0 1.4,-0.2 0.4,-0.2 0.9,-0.3 1.4,-0.5 0.6,-0.2 1.1,-0.4 1.6,-0.7 0.9,-0.5 1.5,-1.4 1.8,-2.4 0.2,-0.6 0.2,-1.1 0.2,-1.6h20.5v-4.2h-5.2ZM240.4,156.3c-0.8,0.8 -1.8,1.5 -3,2 -1.5,0.7 -2.6,1.1 -3.5,1.5 -0.9,0.4 -1.6,0.6 -2.3,0.7 -0.8,0.3 -1.4,0.8 -1.9,1.5 -0.5,0.8 -1,1.1 -1.7,1.1h0.2c-0.3,0.2 -0.8,0.2 -1.5,0.2s-1.4,0 -2.1,0.2c-0.9,0 -0.4,-6 0.3,-6.4 0.6,-0.3 1.1,-0.6 1.8,-0.9s1.3,-0.6 2,-0.9 1.7,-0.4 3,-0.3c1.3,0 2.7,0 4.2,0 1.5,0.2 3.3,0.2 5.3,0.2 -0.1,0.3 -0.4,0.6 -0.8,1Z"/>
</vector>

```

`android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
    <monochrome android:drawable="@mipmap/ic_launcher_monochrome"/>
</adaptive-icon>
```

`android/app/src/main/res/values/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#EEEEEE</color>
</resources>
```

`android/app/src/main/res/values/ic_launcher_cz_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_cz_background">#FFFA71</color>
</resources>
```

`android/app/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">CS16Client</string>
</resources>
```

`android/build.gradle`:

```gradle
buildscript {
	repositories {
		mavenCentral()
		google()
	}

	dependencies {
		classpath 'com.android.tools.build:gradle:8.12.0'
    }
}

allprojects {
	repositories {
		mavenCentral()
		google()
	}
}

```

`android/gradle.properties`:

```properties
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
# Default value: -Xmx10248m -XX:MaxPermSize=256m
org.gradle.jvmargs=-Xmx2048m -XX:MaxMetaspaceSize=384m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# android.useDeprecatedNdk=true
android.enableJetifier=true
android.useAndroidX=true
```

`android/gradle/wrapper/gradle-wrapper.properties`:

```properties
#Thu Oct 26 16:18:24 EEST 2023
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`android/gradlew`:

```
#!/usr/bin/env bash

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn ( ) {
    echo "$*"
}

die ( ) {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
esac

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
function splitJvmOpts() {
    JVM_OPTS=("$@")
}
eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"

exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"

```

`android/gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windowz variants

if not "%OS%" == "Windows_NT" goto win9xME_args
if "%@eval[2+2]" == "4" goto 4NT_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*
goto execute

:4NT_args
@rem Get arguments from the 4NT Shell from JP Software
set CMD_LINE_ARGS=%$

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`android/settings.gradle`:

```gradle
include ':app'

rootProject.name = 'CS16Client'
```

`cl_dll/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(client)

set(CLIENT_LIB client)

file(GLOB CS_CLIENT_SRC "*.cpp")
file(GLOB CS_EV_SRC "events/*.cpp")
file(GLOB CS_WPN_SRC "cs_wpn/*.cpp")
file(GLOB CS_WPNSH_SRC "../dlls/wpn_shared/*.cpp")
file(GLOB CS_HUD_SRC "hud/*.cpp")
file(GLOB CS_STUDIO_SRC "studio/*.cpp")
file(GLOB CS_INPUT_SRC "input/*.cpp")
file(GLOB CS_PM_SRC "../pm_shared/*.cpp")
file(GLOB CS_GAMSH_SRC "../game_shared/*.cpp")
file(GLOB MINIUTL_SRC "../3rdparty/mainui_cpp/miniutl/*.cpp")

list(REMOVE_ITEM CS_CLIENT_SRC "${CMAKE_CURRENT_SOURCE_DIR}/ev_hldm.cpp")
list(REMOVE_ITEM CS_INPUT_SRC "${CMAKE_CURRENT_SOURCE_DIR}/input/input_sdl.cpp")
list(REMOVE_ITEM CS_CLIENT_SRC "${CMAKE_CURRENT_SOURCE_DIR}/inputw32.cpp")
list(REMOVE_ITEM CS_WPN_SRC "${CMAKE_CURRENT_SOURCE_DIR}/cs_wpn/cs_baseentity.cpp")
list(APPEND CS_CLIENT_SRC ../common/interface.cpp)
list(APPEND CS_CLIENT_SRC ../public/utflib.cpp)

list(APPEND CS_CLIENT_SRC ${CS_EV_SRC})
list(APPEND CS_CLIENT_SRC ${CS_WPN_SRC})
list(APPEND CS_CLIENT_SRC ${CS_WPNSH_SRC})
list(APPEND CS_CLIENT_SRC ${CS_HUD_SRC})
list(APPEND CS_CLIENT_SRC ${CS_STUDIO_SRC})
list(APPEND CS_CLIENT_SRC ${CS_PM_SRC})
list(APPEND CS_CLIENT_SRC ${CS_INPUT_SRC})
list(APPEND CS_CLIENT_SRC ${CS_GAMSH_SRC})
list(APPEND CS_CLIENT_SRC ${MINIUTL_SRC})

include_directories(
	include
	include/hud
	include/studio
	include/math
	../cl_dll
	../common
	../engine
	../pm_shared
	../dlls
	../game_shared
	../public/
	../public/cl_dll
	../3rdparty/mainui_cpp
	../3rdparty/mainui_cpp/controls
	../3rdparty/mainui_cpp/menus
	../3rdparty/mainui_cpp/miniutl)

add_definitions(-DCLIENT_WEAPONS -DCLIENT_DLL -DSTDINT_H=<cstdint>)

if(NOT MSVC)
	add_definitions(-DLINUX -D_LINUX)
	add_definitions(-Dstricmp=strcasecmp -D_strnicmp=strncasecmp -Dstrnicmp=strncasecmp -fms-extensions)
else()
	add_definitions(-D_CRT_SECURE_NO_WARNINGS -D_CRT_NONSTDC_NO_DEPRECATE)
endif()

add_library(${CLIENT_LIB} SHARED ${CS_CLIENT_SRC})

set_target_postfix(${CLIENT_LIB})

install(TARGETS ${CLIENT_LIB}
	DESTINATION "${GAME_DIR}/${CLIENT_INSTALL_DIR}/"
	PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE
	    GROUP_READ GROUP_EXECUTE
		WORLD_READ WORLD_EXECUTE)

# Install PDB file on Windows
if(MSVC)
	install(FILES $<TARGET_PDB_FILE:${CLIENT_LIB}>
		DESTINATION "${GAME_DIR}/${CLIENT_INSTALL_DIR}/" OPTIONAL)
endif()
```

`cl_dll/GameStudioModelRenderer.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Big thanks to Chicken Fortress developers
// for this code.
#include <assert.h>
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "com_model.h"
#include "studio.h"
#include "entity_state.h"
#include "cl_entity.h"
#include "dlight.h"
#include "triangleapi.h"

#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <math.h>

#include "studio_util.h"
#include "r_studioint.h"

#include "StudioModelRenderer.h"
#include "GameStudioModelRenderer.h"
#include "pm_defs.h"
#include "camera.h"
#include "eventscripts.h"

#define ANIM_WALK_SEQUENCE 3
#define ANIM_JUMP_SEQUENCE 6
#define ANIM_SWIM_1 8
#define ANIM_SWIM_2 9
#define ANIM_FIRST_DEATH_SEQUENCE 101
#define ANIM_LAST_DEATH_SEQUENCE 159
#define ANIM_FIRST_EMOTION_SEQUENCE 198
#define ANIM_LAST_EMOTION_SEQUENCE 207

CGameStudioModelRenderer g_StudioRenderer;

int g_rseq;
int g_gaitseq;
vec3_t g_clorg;
vec3_t g_clang;

void CounterStrike_GetSequence(int *seq, int *gaitseq)
{
	*seq = g_rseq;
	*gaitseq = g_gaitseq;
}

void CounterStrike_GetOrientation(float *o, float *a)
{
	VectorCopy(g_clorg, o);
	VectorCopy(g_clang, a);
}

float g_flStartScaleTime;
int iPrevRenderState;
int iRenderStateChanged;

engine_studio_api_t IEngineStudio;

static client_anim_state_t g_state;
static client_anim_state_t g_clientstate;

CGameStudioModelRenderer::CGameStudioModelRenderer(void)
{
	m_bLocal = false;
}

mstudioanim_t *CGameStudioModelRenderer::LookupAnimation(mstudioseqdesc_t *pseqdesc, int index)
{
	mstudioanim_t *panim = NULL;

	panim = StudioGetAnim(m_pRenderModel, pseqdesc);

	if (index < 0)
		return panim;

	if (index > (pseqdesc->numblends - 1))
		return panim;

	panim += index * m_pStudioHeader->numbones;
	return panim;
}

void CGameStudioModelRenderer::StudioSetupBones(void)
{
	int i;
	double f;

	mstudiobone_t *pbones;
	mstudioseqdesc_t *pseqdesc;
	mstudioanim_t *panim;

	static float pos[MAXSTUDIOBONES][3];
	static vec4_t q[MAXSTUDIOBONES];
	float bonematrix[3][4];

	static float pos2[MAXSTUDIOBONES][3];
	static vec4_t q2[MAXSTUDIOBONES];
	static float pos3[MAXSTUDIOBONES][3];
	static vec4_t q3[MAXSTUDIOBONES];
	static float pos4[MAXSTUDIOBONES][3];
	static vec4_t q4[MAXSTUDIOBONES];

	if (!m_pCurrentEntity->player)
	{
		CStudioModelRenderer::StudioSetupBones();
		return;
	}

	if (m_pCurrentEntity->curstate.sequence >= m_pStudioHeader->numseq)
		m_pCurrentEntity->curstate.sequence = 0;

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;
	panim = StudioGetAnim(m_pRenderModel, pseqdesc);

	f = StudioEstimateFrame(pseqdesc);

	if (m_pPlayerInfo->gaitsequence == ANIM_WALK_SEQUENCE)
	{
		if (m_pCurrentEntity->curstate.blending[0] <= 26)
		{
			m_pCurrentEntity->curstate.blending[0] = 0;
			m_pCurrentEntity->latched.prevseqblending[0] = m_pCurrentEntity->curstate.blending[0];
		}
		else
		{
			m_pCurrentEntity->curstate.blending[0] -= 26;
			m_pCurrentEntity->latched.prevseqblending[0] = m_pCurrentEntity->curstate.blending[0];
		}
	}

	if (pseqdesc->numblends == 9)
	{
		float s = m_pCurrentEntity->curstate.blending[0];
		float t = m_pCurrentEntity->curstate.blending[1];

		if (s <= 127.0)
		{
			s = (s * 2.0);

			if (t <= 127.0)
			{
				t = (t * 2.0);

				StudioCalcRotations(pos, q, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 1);
				StudioCalcRotations(pos2, q2, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 3);
				StudioCalcRotations(pos3, q3, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 4);
				StudioCalcRotations(pos4, q4, pseqdesc, panim, f);
			}
			else
			{
				t = 2.0 * (t - 127.0);

				panim = LookupAnimation(pseqdesc, 3);
				StudioCalcRotations(pos, q, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 4);
				StudioCalcRotations(pos2, q2, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 6);
				StudioCalcRotations(pos3, q3, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 7);
				StudioCalcRotations(pos4, q4, pseqdesc, panim, f);
			}
		}
		else
		{
			s = 2.0 * (s - 127.0);

			if (t <= 127.0)
			{
				t = (t * 2.0);

				panim = LookupAnimation(pseqdesc, 1);
				StudioCalcRotations(pos, q, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 2);
				StudioCalcRotations(pos2, q2, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 4);
				StudioCalcRotations(pos3, q3, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 5);
				StudioCalcRotations(pos4, q4, pseqdesc, panim, f);
			}
			else
			{
				t = 2.0 * (t - 127.0);

				panim = LookupAnimation(pseqdesc, 4);
				StudioCalcRotations(pos, q, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 5);
				StudioCalcRotations(pos2, q2, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 7);
				StudioCalcRotations(pos3, q3, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 8);
				StudioCalcRotations(pos4, q4, pseqdesc, panim, f);
			}
		}

		s /= 255.0;
		t /= 255.0;

		StudioSlerpBones(q, pos, q2, pos2, s);
		StudioSlerpBones(q3, pos3, q4, pos4, s);
		StudioSlerpBones(q, pos, q3, pos3, t);
	}
	else
	{
		StudioCalcRotations(pos, q, pseqdesc, panim, f);
	}

	if (m_fDoInterp && m_pCurrentEntity->latched.sequencetime && (m_pCurrentEntity->latched.sequencetime + 0.2 > m_clTime) && (m_pCurrentEntity->latched.prevsequence < m_pStudioHeader->numseq))
	{
		static float pos1b[MAXSTUDIOBONES][3];
		static vec4_t q1b[MAXSTUDIOBONES];
		float s = m_pCurrentEntity->latched.prevseqblending[0];
		float t = m_pCurrentEntity->latched.prevseqblending[1];

		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->latched.prevsequence;
		panim = StudioGetAnim(m_pRenderModel, pseqdesc);

		if (pseqdesc->numblends == 9)
		{
			if (s <= 127.0)
			{
				s = (s * 2.0);

				if (t <= 127.0)
				{
					t = (t * 2.0);

					StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 1);
					StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 3);
					StudioCalcRotations(pos3, q3, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 4);
					StudioCalcRotations(pos4, q4, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
				}
				else
				{
					t = 2.0 * (t - 127.0);

					panim = LookupAnimation(pseqdesc, 3);
					StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 4);
					StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 6);
					StudioCalcRotations(pos3, q3, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 7);
					StudioCalcRotations(pos4, q4, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
				}
			}
			else
			{
				s = 2.0 * (s - 127.0);

				if (t <= 127.0)
				{
					t = (t * 2.0);

					panim = LookupAnimation(pseqdesc, 1);
					StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 2);
					StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 4);
					StudioCalcRotations(pos3, q3, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 5);
					StudioCalcRotations(pos4, q4, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
				}
				else
				{
					t = 2.0 * (t - 127.0);

					panim = LookupAnimation(pseqdesc, 4);
					StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 5);
					StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 7);
					StudioCalcRotations(pos3, q3, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 8);
					StudioCalcRotations(pos4, q4, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
				}
			}

			s /= 255.0;
			t /= 255.0;

			StudioSlerpBones(q1b, pos1b, q2, pos2, s);
			StudioSlerpBones(q3, pos3, q4, pos4, s);
			StudioSlerpBones(q1b, pos1b, q3, pos3, t);
		}
		else
		{
			StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
		}

		s = 1.0 - (m_clTime - m_pCurrentEntity->latched.sequencetime) / 0.2;
		StudioSlerpBones(q, pos, q1b, pos1b, s);
	}
	else
	{
		m_pCurrentEntity->latched.prevframe = f;
	}

	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	if (m_pPlayerInfo && (m_pCurrentEntity->curstate.sequence < ANIM_FIRST_DEATH_SEQUENCE || m_pCurrentEntity->curstate.sequence > ANIM_LAST_DEATH_SEQUENCE) && (m_pCurrentEntity->curstate.sequence < ANIM_FIRST_EMOTION_SEQUENCE || m_pCurrentEntity->curstate.sequence > ANIM_LAST_EMOTION_SEQUENCE) && m_pCurrentEntity->curstate.sequence != ANIM_SWIM_1 && m_pCurrentEntity->curstate.sequence != ANIM_SWIM_2)
	{
		int copy = 1;

		if (m_pPlayerInfo->gaitsequence >= m_pStudioHeader->numseq)
			m_pPlayerInfo->gaitsequence = 0;

		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex ) + m_pPlayerInfo->gaitsequence;

		panim = StudioGetAnim(m_pRenderModel, pseqdesc);
		StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pPlayerInfo->gaitframe);

		for (i = 0; i < m_pStudioHeader->numbones; i++)
		{
			if (!strcmp(pbones[i].name, "Bip01 Spine"))
				copy = 0;
			else if (!strcmp(pbones[pbones[i].parent].name, "Bip01 Pelvis"))
				copy = 1;

			if (copy)
			{
				memcpy(pos[i], pos2[i], sizeof(pos[i]));
				memcpy(q[i], q2[i], sizeof(q[i]));
			}
		}
	}

	for (i = 0; i < m_pStudioHeader->numbones; i++)
	{
		QuaternionMatrix(q[i], bonematrix);

		bonematrix[0][3] = pos[i][0];
		bonematrix[1][3] = pos[i][1];
		bonematrix[2][3] = pos[i][2];

		if (pbones[i].parent == -1)
		{
			if (IEngineStudio.IsHardware())
			{
				ConcatTransforms((*m_protationmatrix), bonematrix, (*m_pbonetransform)[i]);
				MatrixCopy((*m_pbonetransform)[i], (*m_plighttransform)[i]);
			}
			else
			{
				ConcatTransforms((*m_paliastransform), bonematrix, (*m_pbonetransform)[i]);
				ConcatTransforms((*m_protationmatrix), bonematrix, (*m_plighttransform)[i]);
			}

			StudioFxTransform(m_pCurrentEntity, (*m_pbonetransform)[i]);
		}
		else
		{
			ConcatTransforms((*m_pbonetransform)[pbones[i].parent], bonematrix, (*m_pbonetransform)[i]);
			ConcatTransforms((*m_plighttransform)[pbones[i].parent], bonematrix, (*m_plighttransform)[i]);
		}
	}
}

void CGameStudioModelRenderer::StudioEstimateGait(entity_state_t *pplayer)
{
	float dt;
	vec3_t est_velocity;

	dt = (m_clTime - m_clOldTime);
	dt = max(0.0, dt);
	dt = min(1.0, dt);

	if (dt == 0 || m_pPlayerInfo->renderframe == m_nFrameCount)
	{
		m_flGaitMovement = 0;
		return;
	}

	if (m_fGaitEstimation)
	{
		VectorSubtract(m_pCurrentEntity->origin, m_pPlayerInfo->prevgaitorigin, est_velocity);
		VectorCopy(m_pCurrentEntity->origin, m_pPlayerInfo->prevgaitorigin);
		m_flGaitMovement = est_velocity.Length();

		if (dt <= 0 || m_flGaitMovement / dt < 5)
		{
			m_flGaitMovement = 0;
			est_velocity[0] = 0;
			est_velocity[1] = 0;
		}
	}
	else
	{
		VectorCopy(pplayer->velocity, est_velocity);
		m_flGaitMovement = est_velocity.Length() * dt;
	}

	if (est_velocity[1] == 0 && est_velocity[0] == 0)
	{
		float flYawDiff = m_pCurrentEntity->angles[YAW] - m_pPlayerInfo->gaityaw;
		flYawDiff = flYawDiff - (int)(flYawDiff / 360) * 360;

		if (flYawDiff > 180)
			flYawDiff -= 360;

		if (flYawDiff < -180)
			flYawDiff += 360;

		if (dt < 0.25)
			flYawDiff *= dt * 4;
		else
			flYawDiff *= dt;

		m_pPlayerInfo->gaityaw += flYawDiff;
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw - (int)(m_pPlayerInfo->gaityaw / 360) * 360;

		m_flGaitMovement = 0;
	}
	else
	{
		m_pPlayerInfo->gaityaw = (atan2(est_velocity[1], est_velocity[0]) * 180 / M_PI);

		if (m_pPlayerInfo->gaityaw > 180)
			m_pPlayerInfo->gaityaw = 180;

		if (m_pPlayerInfo->gaityaw < -180)
			m_pPlayerInfo->gaityaw = -180;
	}
}

void CGameStudioModelRenderer::StudioPlayerBlend(mstudioseqdesc_t *pseqdesc, int *pBlend, float *pPitch)
{
	float range = 45.0;

	*pBlend = (*pPitch * 3);

	if (*pBlend <= -range)
		*pBlend = 255;
	else if (*pBlend >= range)
		*pBlend = 0;
	else
		*pBlend = 255 * (range - *pBlend) / (2 * range);

	*pPitch = 0;
}

void CGameStudioModelRenderer::CalculatePitchBlend(entity_state_t *pplayer)
{
	mstudioseqdesc_t *pseqdesc;
	int iBlend;

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;

	StudioPlayerBlend(pseqdesc, &iBlend, &m_pCurrentEntity->angles[PITCH]);

	m_pCurrentEntity->latched.prevangles[PITCH] = m_pCurrentEntity->angles[PITCH];
	m_pCurrentEntity->curstate.blending[1] = iBlend;
	m_pCurrentEntity->latched.prevblending[1] = m_pCurrentEntity->curstate.blending[1];
	m_pCurrentEntity->latched.prevseqblending[1] = m_pCurrentEntity->curstate.blending[1];
}

void CGameStudioModelRenderer::CalculateYawBlend(entity_state_t *pplayer)
{
	float flYaw;

	StudioEstimateGait(pplayer);

	flYaw = m_pCurrentEntity->angles[YAW] - m_pPlayerInfo->gaityaw;
	flYaw = fmod(flYaw, 360.0f);

	if (flYaw < -180)
		flYaw = flYaw + 360;
	else if (flYaw > 180)
		flYaw = flYaw - 360;

	float maxyaw = 120.0;

	if (flYaw > maxyaw)
	{
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw - 180;
		m_flGaitMovement = -m_flGaitMovement;
		flYaw = flYaw - 180;
	}
	else if (flYaw < -maxyaw)
	{
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw + 180;
		m_flGaitMovement = -m_flGaitMovement;
		flYaw = flYaw + 180;
	}

	float blend_yaw = (flYaw / 90.0) * 128.0 + 127.0;

	blend_yaw = 255.0 - bound( 0.0, blend_yaw, 255.0 );

	m_pCurrentEntity->curstate.blending[0] = (int)(blend_yaw);
	m_pCurrentEntity->latched.prevblending[0] = m_pCurrentEntity->curstate.blending[0];
	m_pCurrentEntity->latched.prevseqblending[0] = m_pCurrentEntity->curstate.blending[0];

	m_pCurrentEntity->angles[YAW] = m_pPlayerInfo->gaityaw;

	if (m_pCurrentEntity->angles[YAW] < -0)
		m_pCurrentEntity->angles[YAW] += 360;

	m_pCurrentEntity->latched.prevangles[YAW] = m_pCurrentEntity->angles[YAW];
}

void CGameStudioModelRenderer::StudioProcessGait(entity_state_t *pplayer)
{
	mstudioseqdesc_t *pseqdesc;

	CalculateYawBlend(pplayer);
	CalculatePitchBlend(pplayer);


	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + pplayer->gaitsequence;

	if (pseqdesc->linearmovement[0] > 0)
		m_pPlayerInfo->gaitframe += (m_flGaitMovement / pseqdesc->linearmovement[0]) * pseqdesc->numframes;
	else
	{
		float dt = bound( 0.0, (m_clTime - m_clOldTime), 1.0 );
		m_pPlayerInfo->gaitframe += pseqdesc->fps * dt * m_pCurrentEntity->curstate.framerate;
	}

	m_pPlayerInfo->gaitframe = m_pPlayerInfo->gaitframe - (int)(m_pPlayerInfo->gaitframe / pseqdesc->numframes) * pseqdesc->numframes;

	if (m_pPlayerInfo->gaitframe < 0)
		m_pPlayerInfo->gaitframe += pseqdesc->numframes;
}

void CGameStudioModelRenderer::SavePlayerState(entity_state_t *pplayer)
{
	client_anim_state_t *st;
	cl_entity_t *ent = IEngineStudio.GetCurrentEntity();

	if (!ent)
		return;

	st = &g_state;

	st->angles = ent->curstate.angles;
	st->origin = ent->curstate.origin;

	st->realangles = ent->angles;

	st->sequence = ent->curstate.sequence;
	st->gaitsequence = pplayer->gaitsequence;
	st->animtime = ent->curstate.animtime;
	st->frame = ent->curstate.frame;
	st->framerate = ent->curstate.framerate;

	memcpy(st->blending, ent->curstate.blending, 2);
	memcpy(st->controller, ent->curstate.controller, 4);

	st->lv = ent->latched;
}

void GetSequenceInfo(void *pmodel, client_anim_state_t *pev, float *pflFrameRate, float *pflGroundSpeed)
{
	studiohdr_t *pstudiohdr;
	pstudiohdr = (studiohdr_t *)pmodel;

	if (!pstudiohdr)
		return;

	mstudioseqdesc_t *pseqdesc;

	if (pev->sequence >= pstudiohdr->numseq)
	{
		*pflFrameRate = 0.0;
		*pflGroundSpeed = 0.0;
		return;
	}

	pseqdesc = (mstudioseqdesc_t *)((byte *)pstudiohdr + pstudiohdr->seqindex) + (int)pev->sequence;

	if (pseqdesc->numframes > 1)
	{
		*pflFrameRate = 256 * pseqdesc->fps / (pseqdesc->numframes - 1);
		*pflGroundSpeed = sqrt(pseqdesc->linearmovement[0] * pseqdesc->linearmovement[0] + pseqdesc->linearmovement[1] * pseqdesc->linearmovement[1] + pseqdesc->linearmovement[2] * pseqdesc->linearmovement[2]);
		*pflGroundSpeed = *pflGroundSpeed * pseqdesc->fps / (pseqdesc->numframes - 1);
	}
	else
	{
		*pflFrameRate = 256.0;
		*pflGroundSpeed = 0.0;
	}
}

int GetSequenceFlags(void *pmodel, client_anim_state_t *pev)
{
	studiohdr_t *pstudiohdr;
	pstudiohdr = (studiohdr_t *)pmodel;

	if (!pstudiohdr || pev->sequence >= pstudiohdr->numseq)
		return 0;

	mstudioseqdesc_t *pseqdesc;
	pseqdesc = (mstudioseqdesc_t *)((byte *)pstudiohdr + pstudiohdr->seqindex) + (int)pev->sequence;

	return pseqdesc->flags;
}

float StudioFrameAdvance(client_anim_state_t *st, float framerate, float flInterval)
{
	if (flInterval == 0.0)
	{
		flInterval = (gEngfuncs.GetClientTime() - st->animtime);

		if (flInterval <= 0.001)
		{
			st->animtime = gEngfuncs.GetClientTime();
			return 0.0;
		}
	}

	if (!st->animtime)
		flInterval = 0.0;

	st->frame += flInterval * framerate * st->framerate;
	st->animtime = gEngfuncs.GetClientTime();

	if (st->frame < 0.0 || st->frame >= 256.0)
	{
		if (st->m_fSequenceLoops)
			st->frame -= (int)(st->frame / 256.0) * 256.0;
		else
			st->frame = (st->frame < 0.0) ? 0 : 255;

		st->m_fSequenceFinished = TRUE;
	}

	return flInterval;
}

void CGameStudioModelRenderer::SetupClientAnimation(entity_state_t *pplayer)
{
	static double oldtime;
	double curtime, dt;

	client_anim_state_t *st;
	float fr, gs;

	cl_entity_t *ent = IEngineStudio.GetCurrentEntity();

	if (!ent)
		return;

	curtime = gEngfuncs.GetClientTime();
	dt = bound( 0.0, (curtime - oldtime), 1.0 );

	oldtime = curtime;
	st = &g_clientstate;

	st->framerate = 1.0;

	int oldseq = st->sequence;
	CounterStrike_GetSequence(&st->sequence, &st->gaitsequence);
	CounterStrike_GetOrientation((float *)&st->origin, (float *)&st->angles);
	VectorCopy(st->angles, st->realangles);

	if (st->sequence != oldseq)
	{
		st->frame = 0.0;
		st->lv.prevsequence = oldseq;
		st->lv.sequencetime = st->animtime;

		memcpy(st->lv.prevseqblending, st->blending, 2);
		memcpy(st->lv.prevcontroller, st->controller, 4);
	}

	void *pmodel = (studiohdr_t *)IEngineStudio.Mod_Extradata(ent->model);

	if( !pmodel )
		return;


	GetSequenceInfo(pmodel, st, &fr, &gs);
	st->m_fSequenceLoops = ((GetSequenceFlags(pmodel, st) & STUDIO_LOOPING) != 0);
	StudioFrameAdvance(st, fr, dt);

	ent->angles = st->realangles;

	ent->curstate.angles = st->angles;
	ent->curstate.origin = st->origin;

	ent->curstate.sequence = st->sequence;
	pplayer->gaitsequence = st->gaitsequence;
	ent->curstate.animtime = st->animtime;
	ent->curstate.frame = st->frame;
	ent->curstate.framerate = st->framerate;

	memcpy(ent->curstate.blending, st->blending, 2);
	memcpy(ent->curstate.controller, st->controller, 4);

	ent->latched = st->lv;
}

void CGameStudioModelRenderer::RestorePlayerState(entity_state_t *pplayer)
{
	client_anim_state_t *st;
	cl_entity_t *ent = IEngineStudio.GetCurrentEntity();

	if (!ent)
		return;

	st = &g_clientstate;

	st->angles = ent->curstate.angles;
	st->origin = ent->curstate.origin;

	st->realangles = ent->angles;

	st->sequence = ent->curstate.sequence;
	st->gaitsequence = pplayer->gaitsequence;
	st->animtime = ent->curstate.animtime;
	st->frame = ent->curstate.frame;
	st->framerate = ent->curstate.framerate;

	memcpy(st->blending, ent->curstate.blending, 2);
	memcpy(st->controller, ent->curstate.controller, 4);

	st->lv = ent->latched;

	st = &g_state;

	ent->angles = st->realangles;

	ent->curstate.angles = st->angles;
	ent->curstate.origin = st->origin;

	ent->curstate.sequence = st->sequence;
	pplayer->gaitsequence = st->gaitsequence;
	ent->curstate.animtime = st->animtime;
	ent->curstate.frame = st->frame;
	ent->curstate.framerate = st->framerate;

	memcpy(ent->curstate.blending, st->blending, 2);
	memcpy(ent->curstate.controller, st->controller, 4);

	ent->latched = st->lv;
}

int CGameStudioModelRenderer::StudioDrawPlayer(int flags, entity_state_t *pplayer)
{
	int iret = 0;
	bool isLocalPlayer = false;

	m_pplayer = pplayer;

	if (m_bLocal && IEngineStudio.GetCurrentEntity() == gEngfuncs.GetLocalPlayer())
		isLocalPlayer = true;

	if (isLocalPlayer)
	{
		SavePlayerState(pplayer);
		SetupClientAnimation(pplayer);
	}

	iret = _StudioDrawPlayer(flags, pplayer);

	if (isLocalPlayer)
		RestorePlayerState(pplayer);

	if( m_pCvarShadows->value != 0.0f )
	{
		Vector chestpos;

		for( int i = 0; i < m_nCachedBones; i++ )
		{
			if( !strcmp(m_nCachedBoneNames[i], "Bip01 Spine3") )
			{
				chestpos.x = m_rgCachedBoneTransform[i][0][3];
				chestpos.y = m_rgCachedBoneTransform[i][1][3];
				chestpos.z = m_rgCachedBoneTransform[i][2][3];
				StudioDrawShadow(chestpos, 20.0f);
				break;
			}
		}
	}

	m_pplayer = NULL;

	return iret;
}

bool WeaponHasAttachments(entity_state_t *pplayer)
{
	studiohdr_t *modelheader = NULL;
	model_t *pweaponmodel;

	if (!pplayer)
		return false;

	pweaponmodel = IEngineStudio.GetModelByIndex(pplayer->weaponmodel);
	modelheader = (studiohdr_t *)IEngineStudio.Mod_Extradata(pweaponmodel);

	if( !modelheader )
		return false;

	return (modelheader->numattachments != 0);
}

int CGameStudioModelRenderer::_StudioDrawPlayer(int flags, entity_state_t *pplayer)
{
	m_pCurrentEntity = IEngineStudio.GetCurrentEntity();

	IEngineStudio.GetTimes(&m_nFrameCount, &m_clTime, &m_clOldTime);
	IEngineStudio.GetViewInfo(m_vRenderOrigin, m_vUp, m_vRight, m_vNormal);
	IEngineStudio.GetAliasScale(&m_fSoftwareXScale, &m_fSoftwareYScale);

	m_nPlayerIndex = pplayer->number - 1;

	if (m_nPlayerIndex < 0 || m_nPlayerIndex >= gEngfuncs.GetMaxClients())
		return 0;

	/*m_pRenderModel = IEngineStudio.SetupPlayerModel(m_nPlayerIndex);

	if (m_pRenderModel == NULL)
		return 0;*/

	extra_player_info_t *pExtra = g_PlayerExtraInfo + pplayer->number;

	if( gHUD.cl_minmodels && gHUD.cl_minmodels->value )
	{
		int team = pExtra->teamnumber;
		if( team == TEAM_TERRORIST )
		{
			// set leet if model isn't valid
			int modelIdx = gHUD.cl_min_t && BIsValidTModelIndex(gHUD.cl_min_t->value) ? gHUD.cl_min_t->value : 1;

			m_pRenderModel = gEngfuncs.CL_LoadModel( sPlayerModelFiles[ modelIdx ], NULL );
		}
		else if( team == TEAM_CT )
		{
			if( pExtra->vip )
				m_pRenderModel = gEngfuncs.CL_LoadModel( sPlayerModelFiles[3], NULL );
			else
			{
				// set gign, if model isn't valud
				int modelIdx = gHUD.cl_min_ct && BIsValidCTModelIndex(gHUD.cl_min_ct->value) ? gHUD.cl_min_ct->value : 2;

				m_pRenderModel = gEngfuncs.CL_LoadModel( sPlayerModelFiles[ modelIdx ], NULL );
			}
		}
	}
	else
	{
		m_pRenderModel = IEngineStudio.SetupPlayerModel( m_nPlayerIndex );
	}

	if( !m_pRenderModel )
	{
		return 0;
	}

	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata(m_pRenderModel);

	if( !m_pStudioHeader )
		return 0;

	IEngineStudio.StudioSetHeader(m_pStudioHeader);
	IEngineStudio.SetRenderModel(m_pRenderModel);

	if (m_pCurrentEntity->curstate.sequence >= m_pStudioHeader->numseq)
		m_pCurrentEntity->curstate.sequence = 0;

	if (pplayer->sequence >= m_pStudioHeader->numseq)
		pplayer->sequence = 0;

	if (m_pCurrentEntity->curstate.gaitsequence >= m_pStudioHeader->numseq)
		m_pCurrentEntity->curstate.gaitsequence = 0;

	if (pplayer->gaitsequence >= m_pStudioHeader->numseq)
		pplayer->gaitsequence = 0;

	if (pplayer->gaitsequence)
	{
		vec3_t orig_angles(m_pCurrentEntity->angles);
		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

		StudioProcessGait(pplayer);

		m_pPlayerInfo->gaitsequence = pplayer->gaitsequence;
		m_pPlayerInfo = NULL;

		StudioSetUpTransform(0);
		m_pCurrentEntity->angles = orig_angles;
	}
	else
	{
		m_pCurrentEntity->curstate.controller[0] = 127;
		m_pCurrentEntity->curstate.controller[1] = 127;
		m_pCurrentEntity->curstate.controller[2] = 127;
		m_pCurrentEntity->curstate.controller[3] = 127;
		m_pCurrentEntity->latched.prevcontroller[0] = m_pCurrentEntity->curstate.controller[0];
		m_pCurrentEntity->latched.prevcontroller[1] = m_pCurrentEntity->curstate.controller[1];
		m_pCurrentEntity->latched.prevcontroller[2] = m_pCurrentEntity->curstate.controller[2];
		m_pCurrentEntity->latched.prevcontroller[3] = m_pCurrentEntity->curstate.controller[3];

		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

		CalculatePitchBlend(pplayer);
		CalculateYawBlend(pplayer);

		m_pPlayerInfo->gaitsequence = 0;
		StudioSetUpTransform(0);
	}

	if (flags & STUDIO_RENDER)
	{
		(*m_pModelsDrawn)++;
		(*m_pStudioModelCount)++;

		if (m_pStudioHeader->numbodyparts == 0)
			return 1;
	}

	m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

	StudioSetupBones();
	StudioSaveBones();

	m_pPlayerInfo->renderframe = m_nFrameCount;
	m_pPlayerInfo = NULL;

	if (flags & STUDIO_EVENTS && (!(flags & STUDIO_RENDER) || !pplayer->weaponmodel || !WeaponHasAttachments(pplayer)))
	{
		StudioCalcAttachments();
		IEngineStudio.StudioClientEvents();

		if (m_pCurrentEntity->index > 0)
		{
			cl_entity_t *ent = gEngfuncs.GetEntityByIndex(m_pCurrentEntity->index);
			memcpy(ent->attachment, m_pCurrentEntity->attachment, sizeof(vec3_t) * 4);
		}
	}

	if (flags & STUDIO_RENDER)
	{
		alight_t lighting;
		vec3_t dir;

		lighting.plightvec = dir;

		IEngineStudio.StudioDynamicLight(m_pCurrentEntity, &lighting);
		IEngineStudio.StudioEntityLight(&lighting);
		IEngineStudio.StudioSetupLighting(&lighting);

		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);
		m_nTopColor = m_pPlayerInfo->topcolor;

		if (m_nTopColor < 0)
			m_nTopColor = 0;

		if (m_nTopColor > 360)
			m_nTopColor = 360;

		m_nBottomColor = m_pPlayerInfo->bottomcolor;

		if (m_nBottomColor < 0)
			m_nBottomColor = 0;

		if (m_nBottomColor > 360)
			m_nBottomColor = 360;

		IEngineStudio.StudioSetRemapColors(m_nTopColor, m_nBottomColor);

		StudioRenderModel(dir);
		m_pPlayerInfo = NULL;

		if (pplayer->weaponmodel)
		{
			studiohdr_t *saveheader = m_pStudioHeader;
			cl_entity_t saveent = *m_pCurrentEntity;

			model_t *pweaponmodel = IEngineStudio.GetModelByIndex(pplayer->weaponmodel);

			m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata(pweaponmodel);
			if( !m_pStudioHeader )
				return 0;

			IEngineStudio.StudioSetHeader(m_pStudioHeader);

			StudioMergeBones(pweaponmodel);

			IEngineStudio.StudioSetupLighting(&lighting);

			StudioRenderModel(dir);

			StudioCalcAttachments();

			if (m_pCurrentEntity->index > 0)
				memcpy(saveent.attachment, m_pCurrentEntity->attachment, sizeof(vec3_t) * m_pStudioHeader->numattachments);

			*m_pCurrentEntity = saveent;
			m_pStudioHeader = saveheader;
			IEngineStudio.StudioSetHeader(m_pStudioHeader);

			if (flags & STUDIO_EVENTS)
				IEngineStudio.StudioClientEvents();
		}
	}

	return 1;
}


void CGameStudioModelRenderer::StudioFxTransform(cl_entity_t *ent, float transform[3][4])
{
	switch (ent->curstate.renderfx)
	{
	case kRenderFxDistort:
	case kRenderFxHologram:
	{
		if (Com_RandomLong(0, 49) == 0)
		{
			int axis = Com_RandomLong(0, 1);

			if (axis == 1)
				axis = 2;

			VectorScale( transform[axis], gEngfuncs.pfnRandomFloat( 1, 1.484 ), transform[axis] );
		}
		else if (Com_RandomLong(0, 49) == 0)
		{
			float offset;

			offset = gEngfuncs.pfnRandomFloat(-10, 10);
			transform[Com_RandomLong(0, 2)][3] += offset;
		}

		break;
	}

	case kRenderFxExplode:
	{
		if (iRenderStateChanged)
		{
			g_flStartScaleTime = m_clTime;
			iRenderStateChanged = FALSE;
		}

		float flTimeDelta = m_clTime - g_flStartScaleTime;

		if (flTimeDelta > 0)
		{
			float flScale = 0.001;

			if (flTimeDelta <= 2.0)
				flScale = 1.0 - (flTimeDelta / 2.0);

			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
					transform[i][j] *= flScale;
			}
		}

		break;
	}
	}
}

void R_StudioInit(void)
{
	g_StudioRenderer.Init();
}

int R_StudioDrawPlayer(int flags, entity_state_t *pplayer)
{
#ifndef NDEBUG
	if( g_StudioRenderer.m_pCvarDebug->value >= 8 )
	{
			cl_entity_t *pCurrentEntity = IEngineStudio.GetCurrentEntity();
			int ret = 0;

			if( pCurrentEntity )
			{
					cvar_t *drawEntites = g_StudioRenderer.m_pCvarDrawEntities;
					g_StudioRenderer.m_pCvarDebug->value -= 8;
					g_StudioRenderer.m_pCvarDrawEntities = g_StudioRenderer.m_pCvarDebug;

					// first draw interpolated
					ret = g_StudioRenderer.StudioDrawPlayer( flags, pplayer );

					// then draw non-interpolated
					/*{
						Vector saveOrigin = pCurrentEntity->origin;
						int savefx = pCurrentEntity->curstate.renderfx;
						int saveamt = pCurrentEntity->curstate.renderamt;
						color24 savecolor = pCurrentEntity->curstate.rendercolor;

						pCurrentEntity->curstate.renderfx = kRenderFxGlowShell;
						pCurrentEntity->curstate.rendercolor.r = 0;
						pCurrentEntity->curstate.rendercolor.g = 0;
						pCurrentEntity->curstate.rendercolor.b = 255;
						pCurrentEntity->curstate.renderamt = 255;
						pCurrentEntity->origin = pCurrentEntity->curstate.origin;

						g_StudioRenderer.StudioDrawPlayer( flags, pplayer );
						pCurrentEntity->origin = saveOrigin;
						pCurrentEntity->curstate.renderfx = savefx;
						pCurrentEntity->curstate.renderamt   = saveamt;
						pCurrentEntity->curstate.rendercolor = savecolor;
					}

					// then draw non-interpolated
					{
						Vector saveOrigin = pCurrentEntity->origin;
						int savefx = pCurrentEntity->curstate.renderfx;
						int saveamt = pCurrentEntity->curstate.renderamt;
						color24 savecolor = pCurrentEntity->curstate.rendercolor;

						pCurrentEntity->curstate.renderfx = kRenderFxGlowShell;
						pCurrentEntity->curstate.rendercolor.r = 255;
						pCurrentEntity->curstate.rendercolor.g = 0;
						pCurrentEntity->curstate.rendercolor.b = 0;
						pCurrentEntity->curstate.renderamt = 255;
						pCurrentEntity->origin = pCurrentEntity->prevstate.origin;

						g_StudioRenderer.StudioDrawPlayer( flags, pplayer );
						pCurrentEntity->origin = saveOrigin;
						pCurrentEntity->curstate.renderfx    = savefx;
						pCurrentEntity->curstate.renderamt   = saveamt;
						pCurrentEntity->curstate.rendercolor = savecolor;
					}*/


					g_StudioRenderer.m_pCvarDrawEntities = drawEntites;
					g_StudioRenderer.m_pCvarDebug->value += 8;
			}

			return ret;
	}
	else
#endif
	return g_StudioRenderer.StudioDrawPlayer(flags, pplayer);
}

int R_StudioDrawModel(int flags)
{
	return g_StudioRenderer.StudioDrawModel(flags);
}
// The simple drawing interface we'll pass back to the engine
r_studio_interface_t studio =
{
	STUDIO_INTERFACE_VERSION,
	R_StudioDrawModel,
	R_StudioDrawPlayer,
};

/*
====================
HUD_GetStudioModelInterface
Export this function for the engine to use the studio renderer class to render objects.
====================
*/
int DLLEXPORT HUD_GetStudioModelInterface( int version, struct r_studio_interface_s **ppinterface, struct engine_studio_api_s *pstudio )
{
	if ( version != STUDIO_INTERFACE_VERSION )
		return 0;

	// Point the engine to our callbacks
	*ppinterface = &studio;

	// Copy in engine helper functions
	IEngineStudio = *pstudio;

	// Initialize local variables, etc.
	R_StudioInit();

	// Success
	return 1;
}


```

`cl_dll/GameStudioModelRenderer.h`:

```h

/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Big thanks to Chicken Fortress developers
// for this code.

#pragma once
#if !defined (GAMESTUDIOMODELRENDERER_H)
#define GAMESTUDIOMODELRENDERER_H

#include "studio.h"
#include "StudioModelRenderer.h"

enum BoneIndex
{
	BONE_HEAD,
	BONE_PELVIS,
	BONE_SPINE1,
	BONE_SPINE2,
	BONE_SPINE3,
	BONE_MAX,
};

struct client_anim_state_t
{
	vec3_t origin;
	vec3_t angles;

	vec3_t realangles;

	float animtime;
	float frame;
	int sequence;
	int gaitsequence;
	float framerate;

	int m_fSequenceLoops;
	int m_fSequenceFinished;

	byte controller[4];
	byte blending[2];

	latchedvars_t lv;
};

class CGameStudioModelRenderer : public CStudioModelRenderer
{
public:
	CGameStudioModelRenderer(void);

public:
	virtual void StudioSetupBones(void);
	virtual void StudioEstimateGait(entity_state_t *pplayer);
	virtual void StudioProcessGait(entity_state_t *pplayer);
	virtual int StudioDrawPlayer(int flags, entity_state_t *pplayer);
	virtual int _StudioDrawPlayer(int flags, entity_state_t *pplayer);
	virtual void StudioFxTransform(cl_entity_t *ent, float transform[3][4]);
	virtual void StudioPlayerBlend(mstudioseqdesc_t *pseqdesc, int *pBlend, float *pPitch);
	virtual void CalculateYawBlend(entity_state_t *pplayer);
	virtual void CalculatePitchBlend(entity_state_t *pplayer);

private:
	void SavePlayerState(entity_state_t *pplayer);
	void SetupClientAnimation(entity_state_t *pplayer);
	void RestorePlayerState(entity_state_t *pplayer);
	mstudioanim_t* LookupAnimation(mstudioseqdesc_t *pseqdesc, int index);

private:
	int m_nPlayerGaitSequences[MAX_CLIENTS];
	bool m_bLocal;
};

extern CGameStudioModelRenderer g_StudioRenderer;
extern int g_rseq;
extern int g_gaitseq;
extern Vector g_clorg;
extern Vector g_clang;

#endif

```

`cl_dll/StudioModelRenderer.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Big thanks to Chicken Fortress developers
// for this code.
#include <assert.h>
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "com_model.h"
#include "studio.h"
#include "entity_state.h"
#include "cl_entity.h"
#include "dlight.h"
#include "triangleapi.h"

#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <math.h>

#include "studio_util.h"
#include "r_studioint.h"

#include "StudioModelRenderer.h"
#include "GameStudioModelRenderer.h"

#include "event_api.h"
#include "pm_defs.h"

#include "com_weapons.h"

extern CGameStudioModelRenderer g_StudioRenderer;
extern engine_studio_api_t IEngineStudio;
typedef struct pmtrace_s pmtrace_t;

void CStudioModelRenderer::Init(void)
{
	m_pCvarHiModels = IEngineStudio.GetCvar("cl_himodels");
	m_pCvarDeveloper = IEngineStudio.GetCvar("developer");
	m_pCvarDrawEntities = IEngineStudio.GetCvar("r_drawentities");
	m_pCvarShadows = CVAR_CREATE("cl_shadows", "1", FCVAR_ARCHIVE );
#ifndef NDEBUG
	m_pCvarDebug = CVAR_CREATE( "r_smr_debug", "0", 0 );
#endif
	m_pChromeSprite = IEngineStudio.GetChromeSprite();

	IEngineStudio.GetModelCounters(&m_pStudioModelCount, &m_pModelsDrawn);

	m_pbonetransform = (float (*)[MAXSTUDIOBONES][3][4])IEngineStudio.StudioGetBoneTransform();
	m_plighttransform = (float (*)[MAXSTUDIOBONES][3][4])IEngineStudio.StudioGetLightTransform();
	m_paliastransform = (float (*)[3][4])IEngineStudio.StudioGetAliasTransform();
	m_protationmatrix = (float (*)[3][4])IEngineStudio.StudioGetRotationMatrix();
}

CStudioModelRenderer::CStudioModelRenderer(void)
{
	m_fDoInterp = 1;
	m_fGaitEstimation = 1;
	m_pCurrentEntity = NULL;
	m_pCvarHiModels = NULL;
	m_pCvarDeveloper = NULL;
	m_pCvarDrawEntities = NULL;
	m_pChromeSprite = NULL;
	m_pStudioModelCount = NULL;
	m_pModelsDrawn = NULL;
	m_protationmatrix = NULL;
	m_paliastransform = NULL;
	m_pbonetransform = NULL;
	m_plighttransform = NULL;
	m_pStudioHeader = NULL;
	m_pBodyPart = NULL;
	m_pSubModel = NULL;
	m_pPlayerInfo = NULL;
	m_pRenderModel = NULL;
	m_iShadowSprite = 0;
}

CStudioModelRenderer::~CStudioModelRenderer(void)
{
}

void CStudioModelRenderer::StudioCalcBoneAdj(float dadt, float *adj, const byte *pcontroller1, const byte *pcontroller2, byte mouthopen)
{
	int i, j;
	float value;
	mstudiobonecontroller_t *pbonecontroller;

	pbonecontroller = (mstudiobonecontroller_t *)((byte *)m_pStudioHeader + m_pStudioHeader->bonecontrollerindex);

	for (j = 0; j < m_pStudioHeader->numbonecontrollers; j++)
	{
		i = pbonecontroller[j].index;

		if (i <= 3)
		{
			if (pbonecontroller[j].type & STUDIO_RLOOP)
			{
				if (abs(pcontroller1[i] - pcontroller2[i]) > 128)
				{
					int a, b;
					a = (pcontroller1[j] + 128) % 256;
					b = (pcontroller2[j] + 128) % 256;
					value = ((a * dadt) + (b * (1 - dadt)) - 128) * (360.0 / 256.0) + pbonecontroller[j].start;
				}
				else
				{
					value = ((pcontroller1[i] * dadt + (pcontroller2[i]) * (1.0 - dadt))) * (360.0 / 256.0) + pbonecontroller[j].start;
				}
			}
			else
			{
				value = (pcontroller1[i] * dadt + pcontroller2[i] * (1.0 - dadt)) / 255.0;

				if (value < 0)
					value = 0;

				if (value > 1.0)
					value = 1.0;

				value = (1.0 - value) * pbonecontroller[j].start + value * pbonecontroller[j].end;
			}
		}
		else
		{
			value = mouthopen / 64.0;

			if (value > 1.0)
				value = 1.0;

			value = (1.0 - value) * pbonecontroller[j].start + value * pbonecontroller[j].end;
		}

		switch (pbonecontroller[j].type & STUDIO_TYPES)
		{
			case STUDIO_XR:
			case STUDIO_YR:
			case STUDIO_ZR:
			{
				adj[j] = value * (M_PI / 180.0);
				break;
			}
			case STUDIO_X:
			case STUDIO_Y:
			case STUDIO_Z:
			{
				adj[j] = value;
				break;
			}
		}
	}
}

void CStudioModelRenderer::StudioCalcBoneQuaterion(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *q)
{
	int j, k;
	vec4_t q1, q2;
	vec3_t angle1, angle2;
	mstudioanimvalue_t *panimvalue;

	for (j = 0; j < 3; j++)
	{
		if (panim->offset[j + 3] == 0)
		{
			angle2[j] = angle1[j] = pbone->value[j + 3];
		}
		else
		{
			panimvalue = (mstudioanimvalue_t *)((byte *)panim + panim->offset[j + 3]);
			k = frame;

			if (panimvalue->num.total < panimvalue->num.valid)
				k = 0;

			while (panimvalue->num.total <= k)
			{
				k -= panimvalue->num.total;
				panimvalue += panimvalue->num.valid + 1;

				if (panimvalue->num.total < panimvalue->num.valid)
					k = 0;
			}

			if (panimvalue->num.valid > k)
			{
				angle1[j] = panimvalue[k + 1].value;

				if (panimvalue->num.valid > k + 1)
				{
					angle2[j] = panimvalue[k + 2].value;
				}
				else
				{
					if (panimvalue->num.total > k + 1)
						angle2[j] = angle1[j];
					else
						angle2[j] = panimvalue[panimvalue->num.valid + 2].value;
				}
			}
			else
			{
				angle1[j] = panimvalue[panimvalue->num.valid].value;

				if (panimvalue->num.total > k + 1)
					angle2[j] = angle1[j];
				else
					angle2[j] = panimvalue[panimvalue->num.valid + 2].value;
			}

			angle1[j] = pbone->value[j + 3] + angle1[j] * pbone->scale[j + 3];
			angle2[j] = pbone->value[j + 3] + angle2[j] * pbone->scale[j + 3];
		}

		if (pbone->bonecontroller[j + 3] != -1)
		{
			angle1[j] += adj[pbone->bonecontroller[j + 3]];
			angle2[j] += adj[pbone->bonecontroller[j + 3]];
		}
	}

	if (!VectorCompare(angle1, angle2))
	{
		AngleQuaternion(angle1, q1);
		AngleQuaternion(angle2, q2);
		QuaternionSlerp(q1, q2, s, q);
	}
	else
	{
		AngleQuaternion(angle1, q);
	}
}

void CStudioModelRenderer::StudioCalcBonePosition(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *pos)
{
	int j, k;
	mstudioanimvalue_t *panimvalue;

	for (j = 0; j < 3; j++)
	{
		pos[j] = pbone->value[j];

		if (panim->offset[j] != 0)
		{
			panimvalue = (mstudioanimvalue_t *)((byte *)panim + panim->offset[j]);
			k = frame;

			if (panimvalue->num.total < panimvalue->num.valid)
				k = 0;

			while (panimvalue->num.total <= k)
			{
				k -= panimvalue->num.total;
				panimvalue += panimvalue->num.valid + 1;

				if (panimvalue->num.total < panimvalue->num.valid)
					k = 0;
			}

			if (panimvalue->num.valid > k)
			{
				if (panimvalue->num.valid > k + 1)
					pos[j] += (panimvalue[k + 1].value * (1.0 - s) + s * panimvalue[k + 2].value) * pbone->scale[j];
				else
					pos[j] += panimvalue[k + 1].value * pbone->scale[j];
			}
			else
			{
				if (panimvalue->num.total <= k + 1)
					pos[j] += (panimvalue[panimvalue->num.valid].value * (1.0 - s) + s * panimvalue[panimvalue->num.valid + 2].value) * pbone->scale[j];
				else
					pos[j] += panimvalue[panimvalue->num.valid].value * pbone->scale[j];
			}
		}

		if (pbone->bonecontroller[j] != -1 && adj)
			pos[j] += adj[pbone->bonecontroller[j]];
	}
}

void CStudioModelRenderer::StudioSlerpBones(vec4_t q1[], float pos1[][3], vec4_t q2[], float pos2[][3], float s)
{
	int i;
	vec4_t q3;
	float s1;

	if (s < 0)
		s = 0;
	else if (s > 1.0)
		s = 1.0;

	s1 = 1.0 - s;

	for (i = 0; i < m_pStudioHeader->numbones; i++)
	{
		QuaternionSlerp(q1[i], q2[i], s, q3);

		q1[i][0] = q3[0];
		q1[i][1] = q3[1];
		q1[i][2] = q3[2];
		q1[i][3] = q3[3];
		pos1[i][0] = pos1[i][0] * s1 + pos2[i][0] * s;
		pos1[i][1] = pos1[i][1] * s1 + pos2[i][1] * s;
		pos1[i][2] = pos1[i][2] * s1 + pos2[i][2] * s;
	}
}

mstudioanim_t *CStudioModelRenderer::StudioGetAnim(model_t *pSubModel, mstudioseqdesc_t *pseqdesc)
{
	mstudioseqgroup_t *pseqgroup;
	cache_user_t *paSequences;

	pseqgroup = (mstudioseqgroup_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqgroupindex) + pseqdesc->seqgroup;

	if (pseqdesc->seqgroup == 0)
		return (mstudioanim_t *)((byte *)m_pStudioHeader + pseqdesc->animindex);

	paSequences = (cache_user_t *)pSubModel->submodels;

	if (paSequences == NULL)
	{
		paSequences = (cache_user_t *)IEngineStudio.Mem_Calloc(16, sizeof(cache_user_t));
		pSubModel->submodels = (dmodel_t *)paSequences;
	}

	if (!IEngineStudio.Cache_Check((struct cache_user_s *)&(paSequences[pseqdesc->seqgroup])))
	{
		gEngfuncs.Con_DPrintf("loading %s\n", pseqgroup->name);
		IEngineStudio.LoadCacheFile(pseqgroup->name, (struct cache_user_s *)&paSequences[pseqdesc->seqgroup]);
	}

	return (mstudioanim_t *)((byte *)paSequences[pseqdesc->seqgroup].data + pseqdesc->animindex);
}

void CStudioModelRenderer::StudioPlayerBlend(mstudioseqdesc_t *pseqdesc, int *pBlend, float *pPitch)
{
	*pBlend = (*pPitch * 3);

	if (*pBlend < pseqdesc->blendstart[0])
	{
		*pPitch -= pseqdesc->blendstart[0] / 3.0;
		*pBlend = 0;
	}
	else if (*pBlend > pseqdesc->blendend[0])
	{
		*pPitch -= pseqdesc->blendend[0] / 3.0;
		*pBlend = 255;
	}
	else
	{
		if (pseqdesc->blendend[0] - pseqdesc->blendstart[0] < 0.1)
			*pBlend = 127;
		else
			*pBlend = 255 * (*pBlend - pseqdesc->blendstart[0]) / (pseqdesc->blendend[0] - pseqdesc->blendstart[0]);

		*pPitch = 0;
	}
}

void CStudioModelRenderer::StudioSetUpTransform(int trivial_accept)
{
	int i;
	vec3_t angles;
	vec3_t modelpos;

	VectorCopy(m_pCurrentEntity->origin, modelpos);

	angles[ROLL] = m_pCurrentEntity->curstate.angles[ROLL];
	angles[PITCH] = m_pCurrentEntity->curstate.angles[PITCH];
	angles[YAW] = m_pCurrentEntity->curstate.angles[YAW];

	if (m_pCurrentEntity->curstate.movetype != MOVETYPE_NONE)
	{
		VectorCopy(m_pCurrentEntity->angles, angles);
	}

	angles[PITCH] = -angles[PITCH];
	AngleMatrix(angles, (*m_protationmatrix));

	if (!IEngineStudio.IsHardware())
	{
		static float viewmatrix[3][4];

		VectorCopy(m_vRight, viewmatrix[0]);
		VectorCopy(m_vUp, viewmatrix[1]);
		VectorInverse(viewmatrix[1]);
		VectorCopy(m_vNormal, viewmatrix[2]);

		(*m_protationmatrix)[0][3] = modelpos[0] - m_vRenderOrigin[0];
		(*m_protationmatrix)[1][3] = modelpos[1] - m_vRenderOrigin[1];
		(*m_protationmatrix)[2][3] = modelpos[2] - m_vRenderOrigin[2];

		ConcatTransforms(viewmatrix, (*m_protationmatrix), (*m_paliastransform));

		if (trivial_accept)
		{
			for (i = 0; i < 4; i++)
			{
				(*m_paliastransform)[0][i] *= m_fSoftwareXScale * (1.0 / (ZISCALE * 0x10000));
				(*m_paliastransform)[1][i] *= m_fSoftwareYScale * (1.0 / (ZISCALE * 0x10000));
				(*m_paliastransform)[2][i] *= 1.0 / (ZISCALE * 0x10000);
			}
		}
	}

	(*m_protationmatrix)[0][3] = modelpos[0];
	(*m_protationmatrix)[1][3] = modelpos[1];
	(*m_protationmatrix)[2][3] = modelpos[2];
}

float CStudioModelRenderer::StudioEstimateInterpolant(void)
{
	float dadt = 1.0;

	if (m_fDoInterp && (m_pCurrentEntity->curstate.animtime >= m_pCurrentEntity->latched.prevanimtime + 0.01))
	{
		dadt = (m_clTime - m_pCurrentEntity->curstate.animtime) / 0.1;

		if (dadt > 2.0)
			dadt = 2.0;
	}

	return dadt;
}

void CStudioModelRenderer::StudioCalcRotations(float pos[][3], vec4_t *q, mstudioseqdesc_t *pseqdesc, mstudioanim_t *panim, float f)
{
	int i;
	int frame;
	mstudiobone_t *pbone;

	float s;
	float adj[MAXSTUDIOCONTROLLERS];
	float dadt;

	if (f > pseqdesc->numframes - 1)
		f = 0;
	else if (f < -0.01)
		f = -0.01;

	frame = (int)f;
	dadt = StudioEstimateInterpolant();
	s = (f - frame);

	pbone = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	StudioCalcBoneAdj(dadt, adj, m_pCurrentEntity->curstate.controller, m_pCurrentEntity->latched.prevcontroller, m_pCurrentEntity->mouth.mouthopen);

	for (i = 0; i < m_pStudioHeader->numbones; i++, pbone++, panim++)
	{
		StudioCalcBoneQuaterion(frame, s, pbone, panim, adj, q[i]);
		StudioCalcBonePosition(frame, s, pbone, panim, adj, pos[i]);
	}

	if (pseqdesc->motiontype & STUDIO_X)
		pos[pseqdesc->motionbone][0] = 0.0;

	if (pseqdesc->motiontype & STUDIO_Y)
		pos[pseqdesc->motionbone][1] = 0.0;

	if (pseqdesc->motiontype & STUDIO_Z)
		pos[pseqdesc->motionbone][2] = 0.0;

	s = 0 * ((1.0 - (f - (int)(f))) / (pseqdesc->numframes)) * m_pCurrentEntity->curstate.framerate;

	if (pseqdesc->motiontype & STUDIO_LX)
		pos[pseqdesc->motionbone][0] += s * pseqdesc->linearmovement[0];

	if (pseqdesc->motiontype & STUDIO_LY)
		pos[pseqdesc->motionbone][1] += s * pseqdesc->linearmovement[1];

	if (pseqdesc->motiontype & STUDIO_LZ)
		pos[pseqdesc->motionbone][2] += s * pseqdesc->linearmovement[2];
}

void CStudioModelRenderer::StudioFxTransform(cl_entity_t *ent, float transform[3][4])
{
	switch (ent->curstate.renderfx)
	{
		case kRenderFxDistort:
		case kRenderFxHologram:
		{
			if (Com_RandomLong(0, 49) == 0)
			{
				int axis = Com_RandomLong(0, 1);

				if (axis == 1)
					axis = 2;

				VectorScale( transform[axis], gEngfuncs.pfnRandomFloat(1,1.484), transform[axis] );
			}
			else if (Com_RandomLong(0, 49) == 0)
			{
				float offset;
				int axis = Com_RandomLong(0, 1);

				if (axis == 1)
					axis = 2;

				offset = gEngfuncs.pfnRandomFloat(-10, 10);
				transform[Com_RandomLong(0, 2)][3] += offset;
			}

			break;
		}

		case kRenderFxExplode:
		{
			float scale;

			scale = 1.0 + (m_clTime - ent->curstate.animtime) * 10.0;

			if (scale > 2)
				scale = 2;

			transform[0][1] *= scale;
			transform[1][1] *= scale;
			transform[2][1] *= scale;
			break;
		}
	}
}

float CStudioModelRenderer::StudioEstimateFrame(mstudioseqdesc_t *pseqdesc)
{
	double dfdt, f;

	if (m_fDoInterp)
	{
		if (m_clTime < m_pCurrentEntity->curstate.animtime)
			dfdt = 0;
		else
			dfdt = (m_clTime - m_pCurrentEntity->curstate.animtime) * m_pCurrentEntity->curstate.framerate * pseqdesc->fps;
	}
	else
		dfdt = 0;

	if (pseqdesc->numframes <= 1)
		f = 0;
	else
		f = (m_pCurrentEntity->curstate.frame * (pseqdesc->numframes - 1)) / 256.0;

	f += dfdt;

	if (pseqdesc->flags & STUDIO_LOOPING)
	{
		if (pseqdesc->numframes > 1)
			f -= (int)(f / (pseqdesc->numframes - 1)) * (pseqdesc->numframes - 1);

		if (f < 0)
			f += (pseqdesc->numframes - 1);
	}
	else
	{
		if (f >= pseqdesc->numframes - 1.001)
			f = pseqdesc->numframes - 1.001;

		if (f < 0.0)
			f = 0.0;
	}

	return f;
}

void CStudioModelRenderer::StudioSetupBones(void)
{
	int i;
	double f;

	mstudiobone_t *pbones;
	mstudioseqdesc_t *pseqdesc;
	mstudioanim_t *panim;

	static float pos[MAXSTUDIOBONES][3];
	static vec4_t q[MAXSTUDIOBONES];
	float bonematrix[3][4];

	static float pos2[MAXSTUDIOBONES][3];
	static vec4_t q2[MAXSTUDIOBONES];
	static float pos3[MAXSTUDIOBONES][3];
	static vec4_t q3[MAXSTUDIOBONES];
	static float pos4[MAXSTUDIOBONES][3];
	static vec4_t q4[MAXSTUDIOBONES];

	if( m_pCurrentEntity->curstate.sequence >= m_pStudioHeader->numseq
		|| m_pCurrentEntity->curstate.sequence < 0 )
		m_pCurrentEntity->curstate.sequence = 0;

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;

	f = StudioEstimateFrame(pseqdesc);
	panim = StudioGetAnim(m_pRenderModel, pseqdesc);

	StudioCalcRotations(pos, q, pseqdesc, panim, f);

	if (pseqdesc->numblends > 1)
	{
		float s;
		float dadt;

		panim += m_pStudioHeader->numbones;
		StudioCalcRotations(pos2, q2, pseqdesc, panim, f);

		dadt = StudioEstimateInterpolant();
		s = (m_pCurrentEntity->curstate.blending[0] * dadt + m_pCurrentEntity->latched.prevblending[0] * (1.0 - dadt)) / 255.0;

		StudioSlerpBones(q, pos, q2, pos2, s);

		if (pseqdesc->numblends == 4)
		{
			panim += m_pStudioHeader->numbones;
			StudioCalcRotations(pos3, q3, pseqdesc, panim, f);

			panim += m_pStudioHeader->numbones;
			StudioCalcRotations(pos4, q4, pseqdesc, panim, f);

			s = (m_pCurrentEntity->curstate.blending[0] * dadt + m_pCurrentEntity->latched.prevblending[0] * (1.0 - dadt)) / 255.0;
			StudioSlerpBones(q3, pos3, q4, pos4, s);

			s = (m_pCurrentEntity->curstate.blending[1] * dadt + m_pCurrentEntity->latched.prevblending[1] * (1.0 - dadt)) / 255.0;
			StudioSlerpBones(q, pos, q3, pos3, s);
		}
	}

	if (m_fDoInterp && m_pCurrentEntity->latched.sequencetime && (m_pCurrentEntity->latched.sequencetime + 0.2 > m_clTime) && (m_pCurrentEntity->latched.prevsequence < m_pStudioHeader->numseq))
	{
		static float pos1b[MAXSTUDIOBONES][3];
		static vec4_t q1b[MAXSTUDIOBONES];
		float s;

		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->latched.prevsequence;
		panim = StudioGetAnim(m_pRenderModel, pseqdesc);

		StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);

		if (pseqdesc->numblends > 1)
		{
			panim += m_pStudioHeader->numbones;
			StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);

			s = (m_pCurrentEntity->latched.prevseqblending[0]) / 255.0;
			StudioSlerpBones(q1b, pos1b, q2, pos2, s);

			if (pseqdesc->numblends == 4)
			{
				panim += m_pStudioHeader->numbones;
				StudioCalcRotations(pos3, q3, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);

				panim += m_pStudioHeader->numbones;
				StudioCalcRotations(pos4, q4, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);

				s = (m_pCurrentEntity->latched.prevseqblending[0]) / 255.0;
				StudioSlerpBones(q3, pos3, q4, pos4, s);

				s = (m_pCurrentEntity->latched.prevseqblending[1]) / 255.0;
				StudioSlerpBones(q1b, pos1b, q3, pos3, s);
			}
		}

		s = 1.0 - (m_clTime - m_pCurrentEntity->latched.sequencetime) / 0.2;
		StudioSlerpBones(q, pos, q1b, pos1b, s);
	}
	else
	{
		m_pCurrentEntity->latched.prevframe = f;
	}

	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	if (m_pPlayerInfo && m_pPlayerInfo->gaitsequence != 0)
	{
		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pPlayerInfo->gaitsequence;

		panim = StudioGetAnim(m_pRenderModel, pseqdesc);
		StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pPlayerInfo->gaitframe);

		for (i = 0; i < m_pStudioHeader->numbones; i++)
		{
			if (strcmp(pbones[i].name, "Bip01 Spine") == 0)
				break;

			memcpy(pos[i], pos2[i], sizeof( pos[i]));
			memcpy(q[i], q2[i], sizeof( q[i]));
		}
	}

	bool bIsViewModel = gEngfuncs.GetViewModel() == m_pCurrentEntity;

	for (i = 0; i < m_pStudioHeader->numbones; i++)
	{
		QuaternionMatrix(q[i], bonematrix);

		bonematrix[0][3] = pos[i][0];
		bonematrix[1][3] = pos[i][1];
		bonematrix[2][3] = pos[i][2];

		if (pbones[i].parent == -1)
		{
			if (IEngineStudio.IsHardware())
			{
				// i know this looks HORRIBLE but I'm too lazy to simplify this right now
				if( gHUD.cl_righthand && gHUD.cl_righthand->value > 0.0f && bIsViewModel && !g_bHoldingShield || gHUD.GetGameType() == GAME_CZERO && bIsViewModel && g_bHoldingShield )
				{
					bonematrix[1][0] = -bonematrix[1][0];
					bonematrix[1][1] = -bonematrix[1][1];
					bonematrix[1][2] = -bonematrix[1][2];
					bonematrix[1][3] = -bonematrix[1][3];
				}

				ConcatTransforms((*m_protationmatrix), bonematrix, (*m_pbonetransform)[i]);
				MatrixCopy((*m_pbonetransform)[i], (*m_plighttransform)[i]);
			}
			else
			{
				ConcatTransforms((*m_paliastransform), bonematrix, (*m_pbonetransform)[i]);
				ConcatTransforms((*m_protationmatrix), bonematrix, (*m_plighttransform)[i]);
			}

			StudioFxTransform(m_pCurrentEntity, (*m_pbonetransform)[i]);
		}
		else
		{
			ConcatTransforms((*m_pbonetransform)[pbones[i].parent], bonematrix, (*m_pbonetransform)[i]);
			ConcatTransforms((*m_plighttransform)[pbones[i].parent], bonematrix, (*m_plighttransform)[i]);
		}
	}
}

void CStudioModelRenderer::StudioSaveBones(void)
{
	int i;

	mstudiobone_t *pbones;
	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	m_nCachedBones = m_pStudioHeader->numbones;

	for (i = 0; i < m_pStudioHeader->numbones; i++)
	{
		strncpy(m_nCachedBoneNames[i], pbones[i].name, 32);
		MatrixCopy((*m_pbonetransform)[i], m_rgCachedBoneTransform[i]);
		MatrixCopy((*m_plighttransform)[i], m_rgCachedLightTransform[i]);
	}

}

void CStudioModelRenderer::StudioMergeBones(model_t *pSubModel)
{
	int i, j;
	double f;

	mstudiobone_t *pbones;
	mstudioseqdesc_t *pseqdesc;
	mstudioanim_t *panim;

	static float pos[MAXSTUDIOBONES][3];
	float bonematrix[3][4];
	static vec4_t q[MAXSTUDIOBONES];

	if( !m_pStudioHeader || !m_pCurrentEntity )
		return;

	if (m_pCurrentEntity->curstate.sequence >= m_pStudioHeader->numseq)
		m_pCurrentEntity->curstate.sequence = 0;

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;

	f = StudioEstimateFrame(pseqdesc);

	/*if (m_pCurrentEntity->latched.prevframe > f)
	{
	}*/

	panim = StudioGetAnim(pSubModel, pseqdesc);
	StudioCalcRotations(pos, q, pseqdesc, panim, f);

	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	for (i = 0; i < m_pStudioHeader->numbones; i++)
	{
		for (j = 0; j < m_nCachedBones; j++)
		{
			if (stricmp(pbones[i].name, m_nCachedBoneNames[j]) == 0)
			{
				MatrixCopy(m_rgCachedBoneTransform[j], (*m_pbonetransform)[i]);
				MatrixCopy(m_rgCachedLightTransform[j], (*m_plighttransform)[i]);
				break;
			}
		}

		if (j >= m_nCachedBones)
		{
			QuaternionMatrix(q[i], bonematrix);

			bonematrix[0][3] = pos[i][0];
			bonematrix[1][3] = pos[i][1];
			bonematrix[2][3] = pos[i][2];

			if (pbones[i].parent == -1)
			{
				if (IEngineStudio.IsHardware())
				{
					ConcatTransforms((*m_protationmatrix), bonematrix, (*m_pbonetransform)[i]);
					MatrixCopy((*m_pbonetransform)[i], (*m_plighttransform)[i]);
				}
				else
				{
					ConcatTransforms((*m_paliastransform), bonematrix, (*m_pbonetransform)[i]);
					ConcatTransforms((*m_protationmatrix), bonematrix, (*m_plighttransform)[i]);
				}

				StudioFxTransform(m_pCurrentEntity, (*m_pbonetransform)[i]);
			}
			else
			{
				ConcatTransforms((*m_pbonetransform)[pbones[i].parent], bonematrix, (*m_pbonetransform)[i]);
				ConcatTransforms((*m_plighttransform)[pbones[i].parent], bonematrix, (*m_plighttransform)[i]);
			}
		}
	}
}

int CStudioModelRenderer::StudioDrawModel(int flags)
{
	bool bChangedRightHand = false;
	int iRightHandValue;

	m_pCurrentEntity = IEngineStudio.GetCurrentEntity();

	if( g_bHoldingKnife && m_pCurrentEntity == gEngfuncs.GetViewModel() && (flags & STUDIO_RENDER) )
	{
		// Condition Zero knife viewmodel is left-handed by default, so we need to flip it too
		const char *pchGameDir = gEngfuncs.pfnGetGameDirectory();
		if( pchGameDir && stricmp( pchGameDir, "czero" ) != 0 )
		{
			bChangedRightHand = true;

			iRightHandValue = gHUD.cl_righthand->value;

			gHUD.cl_righthand->value = !gHUD.cl_righthand->value;
		}
	}

	IEngineStudio.GetTimes(&m_nFrameCount, &m_clTime, &m_clOldTime);
	IEngineStudio.GetViewInfo(m_vRenderOrigin, m_vUp, m_vRight, m_vNormal);
	IEngineStudio.GetAliasScale(&m_fSoftwareXScale, &m_fSoftwareYScale);

	if (m_pCurrentEntity->curstate.renderfx == kRenderFxDeadPlayer)
	{
		entity_state_t deadplayer;

		int result;
		int save_interp;

		if (m_pCurrentEntity->curstate.renderamt <= 0 || m_pCurrentEntity->curstate.renderamt > gEngfuncs.GetMaxClients())
			return 0;

		deadplayer = *(IEngineStudio.GetPlayerState(m_pCurrentEntity->curstate.renderamt - 1));

		deadplayer.number = m_pCurrentEntity->curstate.renderamt;
		deadplayer.weaponmodel = 0;
		deadplayer.gaitsequence = 0;

		deadplayer.movetype = MOVETYPE_NONE;
		VectorCopy(m_pCurrentEntity->curstate.angles, deadplayer.angles);
		VectorCopy(m_pCurrentEntity->curstate.origin, deadplayer.origin);

		save_interp = m_fDoInterp;
		m_fDoInterp = 0;

		result = StudioDrawPlayer(flags, &deadplayer);

		m_fDoInterp = save_interp;
		return result;
	}

	m_pRenderModel = m_pCurrentEntity->model;
	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata(m_pRenderModel);

	IEngineStudio.StudioSetHeader(m_pStudioHeader);
	IEngineStudio.SetRenderModel(m_pRenderModel);

	StudioSetUpTransform(0);

	if (flags & STUDIO_RENDER)
	{
		if (!IEngineStudio.StudioCheckBBox())
			return 0;

		(*m_pModelsDrawn)++;
		(*m_pStudioModelCount)++;

		if (m_pStudioHeader->numbodyparts == 0)
			return 1;
	}

	if (m_pCurrentEntity->curstate.movetype == MOVETYPE_FOLLOW)
		StudioMergeBones(m_pRenderModel);
	else
		StudioSetupBones();

	StudioSaveBones();

	if (flags & STUDIO_EVENTS)
	{
		StudioCalcAttachments();
		IEngineStudio.StudioClientEvents();

		if (m_pCurrentEntity->index > 0)
		{
			cl_entity_t *ent = gEngfuncs.GetEntityByIndex(m_pCurrentEntity->index);
			memcpy(ent->attachment, m_pCurrentEntity->attachment, sizeof(vec3_t) * 4);
		}
	}

	if (flags & STUDIO_RENDER)
	{
		alight_t lighting;
		vec3_t dir;
		lighting.plightvec = dir;

		IEngineStudio.StudioDynamicLight(m_pCurrentEntity, &lighting);

		IEngineStudio.StudioEntityLight(&lighting);
		IEngineStudio.StudioSetupLighting(&lighting);

		m_nTopColor = m_pCurrentEntity->curstate.colormap & 0xFF;
		m_nBottomColor = (m_pCurrentEntity->curstate.colormap & 0xFF00) >> 8;

		IEngineStudio.StudioSetRemapColors(m_nTopColor, m_nBottomColor);

		StudioRenderModel(dir);
	}

	if( bChangedRightHand )
	{
		gHUD.cl_righthand->value = iRightHandValue;
	}

	return 1;
}

void CStudioModelRenderer::StudioEstimateGait(entity_state_t *pplayer)
{
	float dt;
	vec3_t est_velocity;

	dt = (m_clTime - m_clOldTime);

	if (dt < 0)
		dt = 0;
	else if (dt > 1.0)
		dt = 1;

	if (dt == 0 || m_pPlayerInfo->renderframe == m_nFrameCount)
	{
		m_flGaitMovement = 0;
		return;
	}

	if (m_fGaitEstimation)
	{
		VectorSubtract(m_pCurrentEntity->origin, m_pPlayerInfo->prevgaitorigin, est_velocity);
		VectorCopy(m_pCurrentEntity->origin, m_pPlayerInfo->prevgaitorigin);
		m_flGaitMovement = est_velocity.Length();

		if (dt <= 0 || m_flGaitMovement / dt < 5)
		{
			m_flGaitMovement = 0;
			est_velocity[0] = 0;
			est_velocity[1] = 0;
		}
	}
	else
	{
		VectorCopy(pplayer->velocity, est_velocity);
		m_flGaitMovement = est_velocity.Length() * dt;
	}

	if (est_velocity[1] == 0 && est_velocity[0] == 0)
	{
		float flYawDiff = m_pCurrentEntity->angles[YAW] - m_pPlayerInfo->gaityaw;
		flYawDiff = flYawDiff - (int)(flYawDiff / 360) * 360;

		if (flYawDiff > 180)
			flYawDiff -= 360;
		if (flYawDiff < -180)
			flYawDiff += 360;

		if (dt < 0.25)
			flYawDiff *= dt * 4;
		else
			flYawDiff *= dt;

		m_pPlayerInfo->gaityaw += flYawDiff;
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw - (int)(m_pPlayerInfo->gaityaw / 360) * 360;
		m_flGaitMovement = 0;
	}
	else
	{
		m_pPlayerInfo->gaityaw = (atan2(est_velocity[1], est_velocity[0]) * 180 / M_PI);

		if (m_pPlayerInfo->gaityaw > 180)
			m_pPlayerInfo->gaityaw = 180;

		if (m_pPlayerInfo->gaityaw < -180)
			m_pPlayerInfo->gaityaw = -180;
	}
}

void CStudioModelRenderer::StudioProcessGait(entity_state_t *pplayer)
{
	mstudioseqdesc_t *pseqdesc;
	float dt;
	int iBlend;
	float flYaw;

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;

	StudioPlayerBlend(pseqdesc, &iBlend, &m_pCurrentEntity->angles[PITCH]);

	m_pCurrentEntity->latched.prevangles[PITCH] = m_pCurrentEntity->angles[PITCH];
	m_pCurrentEntity->curstate.blending[0] = iBlend;
	m_pCurrentEntity->latched.prevblending[0] = m_pCurrentEntity->curstate.blending[0];
	m_pCurrentEntity->latched.prevseqblending[0] = m_pCurrentEntity->curstate.blending[0];

	dt = (m_clTime - m_clOldTime);

	if (dt < 0)
		dt = 0;
	else if (dt > 1.0)
		dt = 1;

	StudioEstimateGait(pplayer);

	flYaw = m_pCurrentEntity->angles[YAW] - m_pPlayerInfo->gaityaw;
	flYaw = flYaw - (int)(flYaw / 360) * 360;

	if (flYaw < -180)
		flYaw = flYaw + 360;

	if (flYaw > 180)
		flYaw = flYaw - 360;

	if (flYaw > 120)
	{
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw - 180;
		m_flGaitMovement = -m_flGaitMovement;
		flYaw = flYaw - 180;
	}
	else if (flYaw < -120)
	{
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw + 180;
		m_flGaitMovement = -m_flGaitMovement;
		flYaw = flYaw + 180;
	}

	m_pCurrentEntity->curstate.controller[0] = ((flYaw / 4.0) + 30) / (60.0 / 255.0);
	m_pCurrentEntity->curstate.controller[1] = ((flYaw / 4.0) + 30) / (60.0 / 255.0);
	m_pCurrentEntity->curstate.controller[2] = ((flYaw / 4.0) + 30) / (60.0 / 255.0);
	m_pCurrentEntity->curstate.controller[3] = ((flYaw / 4.0) + 30) / (60.0 / 255.0);
	m_pCurrentEntity->latched.prevcontroller[0] = m_pCurrentEntity->curstate.controller[0];
	m_pCurrentEntity->latched.prevcontroller[1] = m_pCurrentEntity->curstate.controller[1];
	m_pCurrentEntity->latched.prevcontroller[2] = m_pCurrentEntity->curstate.controller[2];
	m_pCurrentEntity->latched.prevcontroller[3] = m_pCurrentEntity->curstate.controller[3];

	m_pCurrentEntity->angles[YAW] = m_pPlayerInfo->gaityaw;

	if (m_pCurrentEntity->angles[YAW] < -0)
		m_pCurrentEntity->angles[YAW] += 360;

	m_pCurrentEntity->latched.prevangles[YAW] = m_pCurrentEntity->angles[YAW];

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + pplayer->gaitsequence;

	if (pseqdesc->linearmovement[0] > 0)
		m_pPlayerInfo->gaitframe += (m_flGaitMovement / pseqdesc->linearmovement[0]) * pseqdesc->numframes;
	else
		m_pPlayerInfo->gaitframe += pseqdesc->fps * dt;

	m_pPlayerInfo->gaitframe = m_pPlayerInfo->gaitframe - (int)(m_pPlayerInfo->gaitframe / pseqdesc->numframes) * pseqdesc->numframes;

	if (m_pPlayerInfo->gaitframe < 0)
		m_pPlayerInfo->gaitframe += pseqdesc->numframes;
}

int CStudioModelRenderer::StudioDrawPlayer(int flags, entity_state_t *pplayer)
{
	m_pCurrentEntity = IEngineStudio.GetCurrentEntity();

	IEngineStudio.GetTimes(&m_nFrameCount, &m_clTime, &m_clOldTime);
	IEngineStudio.GetViewInfo(m_vRenderOrigin, m_vUp, m_vRight, m_vNormal);
	IEngineStudio.GetAliasScale(&m_fSoftwareXScale, &m_fSoftwareYScale);

	m_nPlayerIndex = pplayer->number - 1;

	if (m_nPlayerIndex < 0 || m_nPlayerIndex >= gEngfuncs.GetMaxClients())
		return 0;

	m_pRenderModel = IEngineStudio.SetupPlayerModel(m_nPlayerIndex);

	if (m_pRenderModel == NULL)
		return 0;

	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata(m_pRenderModel);

	IEngineStudio.StudioSetHeader(m_pStudioHeader);
	IEngineStudio.SetRenderModel(m_pRenderModel);

	if (pplayer->gaitsequence)
	{
		vec3_t orig_angles;
		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

		VectorCopy(m_pCurrentEntity->angles, orig_angles);

		StudioProcessGait(pplayer);

		m_pPlayerInfo->gaitsequence = pplayer->gaitsequence;
		m_pPlayerInfo = NULL;

		StudioSetUpTransform(0);
		VectorCopy(orig_angles, m_pCurrentEntity->angles);
	}
	else
	{
		m_pCurrentEntity->curstate.controller[0] = 127;
		m_pCurrentEntity->curstate.controller[1] = 127;
		m_pCurrentEntity->curstate.controller[2] = 127;
		m_pCurrentEntity->curstate.controller[3] = 127;
		m_pCurrentEntity->latched.prevcontroller[0] = m_pCurrentEntity->curstate.controller[0];
		m_pCurrentEntity->latched.prevcontroller[1] = m_pCurrentEntity->curstate.controller[1];
		m_pCurrentEntity->latched.prevcontroller[2] = m_pCurrentEntity->curstate.controller[2];
		m_pCurrentEntity->latched.prevcontroller[3] = m_pCurrentEntity->curstate.controller[3];

		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);
		m_pPlayerInfo->gaitsequence = 0;

		StudioSetUpTransform(0);
	}

	if (flags & STUDIO_RENDER)
	{
		if (!IEngineStudio.StudioCheckBBox())
			return 0;

		(*m_pModelsDrawn)++;
		(*m_pStudioModelCount)++;

		if (m_pStudioHeader->numbodyparts == 0)
			return 1;
	}

	m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

	StudioSetupBones();
	StudioSaveBones();

	m_pPlayerInfo->renderframe = m_nFrameCount;
	m_pPlayerInfo = NULL;

	if (flags & STUDIO_EVENTS)
	{
		StudioCalcAttachments();
		IEngineStudio.StudioClientEvents();

		if (m_pCurrentEntity->index > 0)
		{
			cl_entity_t *ent = gEngfuncs.GetEntityByIndex(m_pCurrentEntity->index);
			memcpy(ent->attachment, m_pCurrentEntity->attachment, sizeof(vec3_t) * 4);
		}
	}

	if (flags & STUDIO_RENDER)
	{
		if (m_pCvarHiModels->value && m_pRenderModel != m_pCurrentEntity->model)
			m_pCurrentEntity->curstate.body = 255;

		if (!(m_pCvarDeveloper->value == 0 && gEngfuncs.GetMaxClients() == 1) && (m_pRenderModel == m_pCurrentEntity->model))
			m_pCurrentEntity->curstate.body = 1;

		alight_t lighting;
		vec3_t dir;
		lighting.plightvec = dir;

		IEngineStudio.StudioDynamicLight(m_pCurrentEntity, &lighting);
		IEngineStudio.StudioEntityLight(&lighting);
		IEngineStudio.StudioSetupLighting(&lighting);

		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

		m_nTopColor = m_pPlayerInfo->topcolor;

		if (m_nTopColor < 0)
			m_nTopColor = 0;

		if (m_nTopColor > 360)
			m_nTopColor = 360;

		m_nBottomColor = m_pPlayerInfo->bottomcolor;

		if (m_nBottomColor < 0)
			m_nBottomColor = 0;

		if (m_nBottomColor > 360)
			m_nBottomColor = 360;

		IEngineStudio.StudioSetRemapColors(m_nTopColor, m_nBottomColor);

		StudioRenderModel(dir);
		m_pPlayerInfo = NULL;

		if (pplayer->weaponmodel)
		{
			cl_entity_t saveent = *m_pCurrentEntity;
			model_t *pweaponmodel = IEngineStudio.GetModelByIndex(pplayer->weaponmodel);

			m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata(pweaponmodel);
			IEngineStudio.StudioSetHeader(m_pStudioHeader);

			StudioMergeBones(pweaponmodel);

			IEngineStudio.StudioSetupLighting(&lighting);

			StudioRenderModel(dir);

			StudioCalcAttachments();

			*m_pCurrentEntity = saveent;
		}
	}

	return 1;
}

void CStudioModelRenderer::StudioCalcAttachments(void)
{
	int i;
	mstudioattachment_t *pattachment;

	if (m_pStudioHeader->numattachments > 4)
		gEngfuncs.Con_DPrintf("Too many attachments on %s\n", m_pCurrentEntity->model->name);

	pattachment = (mstudioattachment_t *)((byte *)m_pStudioHeader + m_pStudioHeader->attachmentindex);

	for (i = 0; i < m_pStudioHeader->numattachments; i++)
		VectorTransform(pattachment[i].org, (*m_plighttransform)[pattachment[i].bone], m_pCurrentEntity->attachment[i]);
}

void CStudioModelRenderer::StudioRenderModel(float *lightdir)
{
	IEngineStudio.SetChromeOrigin();

	int iSaveRenderMode =  m_pCurrentEntity->curstate.rendermode;
	int iSaveRenderFx = m_pCurrentEntity->curstate.renderfx;
	int iSaveRenderAmt = m_pCurrentEntity->curstate.renderamt;


	IEngineStudio.SetForceFaceFlags(0);
	StudioRenderFinal();

	if (iSaveRenderFx == kRenderFxGlowShell)
	{
		m_pCurrentEntity->curstate.renderfx = kRenderFxGlowShell;

		gEngfuncs.pTriAPI->SpriteTexture(m_pChromeSprite, 0);

		IEngineStudio.SetForceFaceFlags(STUDIO_NF_CHROME);
		StudioRenderFinal();
	}


	m_pCurrentEntity->curstate.rendermode = iSaveRenderMode;
	m_pCurrentEntity->curstate.renderfx = iSaveRenderFx;
	m_pCurrentEntity->curstate.renderamt = iSaveRenderAmt;
}

void CStudioModelRenderer::StudioRenderFinal_Software(void)
{
	int i;

	IEngineStudio.SetupRenderer(0);

	/*if (m_pCvarDrawEntities->value == 2)
	{
		IEngineStudio.StudioDrawBones();
	}
	else if (m_pCvarDrawEntities->value == 3)
	{
		IEngineStudio.StudioDrawHulls();
	}
	else*/
	{
		for (i = 0; i < m_pStudioHeader->numbodyparts; i++)
		{
			IEngineStudio.StudioSetupModel(i, (void **)&m_pBodyPart, (void **)&m_pSubModel);
			IEngineStudio.StudioDrawPoints();
		}
	}

	/*if (m_pCvarDrawEntities->value == 4)
	{
		gEngfuncs.pTriAPI->RenderMode(kRenderTransAdd);
		IEngineStudio.StudioDrawHulls();
		gEngfuncs.pTriAPI->RenderMode(kRenderNormal);
	}

	if (m_pCvarDrawEntities->value == 5)
		IEngineStudio.StudioDrawAbsBBox();*/

	IEngineStudio.RestoreRenderer();
}

int twice;

void CStudioModelRenderer::StudioRenderFinal_Hardware(void)
{
	int i;
	int rendermode;

	rendermode = IEngineStudio.GetForceFaceFlags() ? kRenderTransAdd : m_pCurrentEntity->curstate.rendermode;
	IEngineStudio.SetupRenderer(rendermode);

	/*if (m_pCvarDrawEntities->value == 2)
	{
		IEngineStudio.StudioDrawBones();
	}
	else if (m_pCvarDrawEntities->value == 3)
	{
		IEngineStudio.StudioDrawHulls();
	}
	else*/
	{
		for (i = 0; i < m_pStudioHeader->numbodyparts; i++)
		{
			IEngineStudio.StudioSetupModel(i, (void **)&m_pBodyPart, (void **)&m_pSubModel);

			if (m_fDoInterp)
				m_pCurrentEntity->trivial_accept = 0;

			IEngineStudio.GL_SetRenderMode(rendermode);
			IEngineStudio.StudioSetRenderamt(m_pCurrentEntity->curstate.renderamt);
			IEngineStudio.StudioDrawPoints();
		}
	}

	/*if (m_pCvarDrawEntities->value == 4)
	{
		gEngfuncs.pTriAPI->RenderMode(kRenderTransAdd);
		IEngineStudio.StudioDrawHulls();
		gEngfuncs.pTriAPI->RenderMode(kRenderNormal);
	}*/

	//if (m_pCvarDrawEntities->value == 5)
	//	IEngineStudio.StudioDrawAbsBBox();

	IEngineStudio.RestoreRenderer();
}

void CStudioModelRenderer::StudioRenderFinal(void)
{
	if (IEngineStudio.IsHardware())
		StudioRenderFinal_Hardware();
	else
		StudioRenderFinal_Software();
}

void CStudioModelRenderer::StudioSetShadowSprite(int idx)
{
	m_iShadowSprite = idx;
}

void CStudioModelRenderer::StudioDrawShadow( Vector origin, float scale )
{
	Vector endPoint = origin;
	Vector p1, p2, p3, p4;
	pmtrace_t pmtrace;

	endPoint.z -= 150.0f;

	gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );
	gEngfuncs.pEventAPI->EV_PushPMStates( );
		gEngfuncs.pEventAPI->EV_SetSolidPlayers( -1 );
		gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
		gEngfuncs.pEventAPI->EV_PlayerTrace( origin, endPoint, PM_STUDIO_IGNORE | PM_GLASS_IGNORE, -1, &pmtrace );
	gEngfuncs.pEventAPI->EV_PopPMStates( );

	// don't allow shadow if player in solid area
	if( pmtrace.startsolid )
		return;

	// don't allow shadow if doesn't hit anything
	if( pmtrace.fraction >= 1.0f )
		return;

	pmtrace.plane.normal = pmtrace.plane.normal.Normalize( );

	// don't allow shadow on too lean planes
	if( pmtrace.plane.normal.z <= 0.7 )
		return;

	pmtrace.plane.normal = pmtrace.plane.normal * scale * ( 1.0 - pmtrace.fraction );


	// add 2.0f to Z, for avoid Z-fighting
	p1.x = pmtrace.endpos.x - pmtrace.plane.normal.z;
	p1.y = pmtrace.endpos.y + pmtrace.plane.normal.z;
	p1.z = pmtrace.endpos.z + 2.0f + pmtrace.plane.normal.x - pmtrace.plane.normal.y;

	p2.x = pmtrace.endpos.x + pmtrace.plane.normal.z;
	p2.y = pmtrace.endpos.y + pmtrace.plane.normal.z;
	p2.z = pmtrace.endpos.z + 2.0f - pmtrace.plane.normal.x - pmtrace.plane.normal.y;

	p3.x = pmtrace.endpos.x + pmtrace.plane.normal.z;
	p3.y = pmtrace.endpos.y - pmtrace.plane.normal.z;
	p3.z = pmtrace.endpos.z + 2.0f - pmtrace.plane.normal.x + pmtrace.plane.normal.y;

	p4.x = pmtrace.endpos.x - pmtrace.plane.normal.z;
	p4.y = pmtrace.endpos.y - pmtrace.plane.normal.z;
	p4.z = pmtrace.endpos.z + 2.0f + pmtrace.plane.normal.x + pmtrace.plane.normal.y;

	IEngineStudio.StudioRenderShadow( m_iShadowSprite, p1, p2, p3, p4 );
}

```

`cl_dll/ammo.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Ammo.cpp
//
// implementation of CHudAmmo class
//

#include "hud.h"
#include "cvardef.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "pm_shared.h"

#include <string.h>
#include <stdio.h>

#include "ammohistory.h"
#include "eventscripts.h"
#include "com_weapons.h"
#include "draw_util.h"
#include "triangleapi.h"
#include "weapontype.h"

#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

WEAPON *gpActiveSel;	// NULL means off, 1 means just the menu bar, otherwise
						// this points to the active weapon menu item
WEAPON *gpLastSel;		// Last weapon menu selection 

client_sprite_t *GetSpriteList(client_sprite_t *pList, const char *psz, int iRes, int iCount);

WeaponsResource gWR;

int g_weaponselect = 0;
int g_weaponselect_frames = 0;
int g_iShotsFired;

void WeaponsResource :: LoadAllWeaponSprites( void )
{
	for( int i = 0; i < MAX_WEAPONS; i++ )
	{
		if ( rgWeapons[i].iId )
			LoadWeaponSprites( &rgWeapons[i] );
	}
}

int WeaponsResource :: CountAmmo( int iId ) 
{ 
	if ( iId < 0 )
		return 0;

	return riAmmo[iId];
}

int WeaponsResource :: HasAmmo( WEAPON *p )
{
	if ( !p )
		return FALSE;

	// weapons with no max ammo can always be selected
	if ( p->iMax1 == -1 )
		return TRUE;

	return (p->iAmmoType == -1) || p->iClip > 0 || CountAmmo(p->iAmmoType) 
		|| CountAmmo(p->iAmmo2Type) || ( p->iFlags & WEAPON_FLAGS_SELECTONEMPTY );
}


void WeaponsResource :: LoadWeaponSprites( WEAPON *pWeapon )
{
	int i, iRes = gHUD.GetSpriteRes();

	char sz[256];

	if ( !pWeapon )
		return;

	memset( &pWeapon->rcActive, 0, sizeof(wrect_t) );
	memset( &pWeapon->rcInactive, 0, sizeof(wrect_t) );
	memset( &pWeapon->rcAmmo, 0, sizeof(wrect_t) );
	memset( &pWeapon->rcAmmo2, 0, sizeof(wrect_t) );
	pWeapon->hInactive = 0;
	pWeapon->hActive = 0;
	pWeapon->hAmmo = 0;
	pWeapon->hAmmo2 = 0;

	snprintf(sz, sizeof(sz), "sprites/%s.txt", pWeapon->szName);
	client_sprite_t *pList = SPR_GetList(sz, &i);

	if (!pList)
		return;

	client_sprite_t *p;
	
	p = GetSpriteList( pList, "crosshair", iRes, i );
	if (p)
	{
		snprintf(sz, sizeof(sz), "sprites/%s.spr", p->szSprite);
		pWeapon->hCrosshair = SPR_Load(sz);
		pWeapon->rcCrosshair = p->rc;
	}
	else
		pWeapon->hCrosshair = 0;

	p = GetSpriteList(pList, "autoaim", iRes, i);
	if (p)
	{
		snprintf(sz, sizeof(sz), "sprites/%s.spr", p->szSprite);
		pWeapon->hAutoaim = SPR_Load(sz);
		pWeapon->rcAutoaim = p->rc;
	}
	else
		pWeapon->hAutoaim = 0;

	p = GetSpriteList( pList, "zoom", iRes, i );
	if (p)
	{
		snprintf(sz, sizeof(sz), "sprites/%s.spr", p->szSprite);
		pWeapon->hZoomedCrosshair = SPR_Load(sz);
		pWeapon->rcZoomedCrosshair = p->rc;
	}
	else
	{
		pWeapon->hZoomedCrosshair = pWeapon->hCrosshair; //default to non-zoomed crosshair
		pWeapon->rcZoomedCrosshair = pWeapon->rcCrosshair;
	}

	p = GetSpriteList(pList, "zoom_autoaim", iRes, i);
	if (p)
	{
		snprintf(sz, sizeof(sz), "sprites/%s.spr", p->szSprite);
		pWeapon->hZoomedAutoaim = SPR_Load(sz);
		pWeapon->rcZoomedAutoaim = p->rc;
	}
	else
	{
		pWeapon->hZoomedAutoaim = pWeapon->hZoomedCrosshair;  //default to zoomed crosshair
		pWeapon->rcZoomedAutoaim = pWeapon->rcZoomedCrosshair;
	}

	p = GetSpriteList(pList, "weapon", iRes, i);
	if (p)
	{
		snprintf(sz, sizeof(sz), "sprites/%s.spr", p->szSprite);
		pWeapon->hInactive = SPR_Load(sz);
		pWeapon->rcInactive = p->rc;

		gHR.iHistoryGap = max( gHR.iHistoryGap, pWeapon->rcActive.Height() );
	}
	else
		pWeapon->hInactive = 0;

	p = GetSpriteList(pList, "weapon_s", iRes, i);
	if (p)
	{
		snprintf(sz, sizeof(sz), "sprites/%s.spr", p->szSprite);
		pWeapon->hActive = SPR_Load(sz);
		pWeapon->rcActive = p->rc;
	}
	else
		pWeapon->hActive = 0;

	p = GetSpriteList(pList, "ammo", iRes, i);
	if (p)
	{
		snprintf(sz, sizeof(sz), "sprites/%s.spr", p->szSprite);
		pWeapon->hAmmo = SPR_Load(sz);
		pWeapon->rcAmmo = p->rc;

		gHR.iHistoryGap = max( gHR.iHistoryGap, pWeapon->rcActive.Height() );
	}
	else
		pWeapon->hAmmo = 0;

	p = GetSpriteList(pList, "ammo2", iRes, i);
	if (p)
	{
		snprintf(sz, sizeof(sz), "sprites/%s.spr", p->szSprite);
		pWeapon->hAmmo2 = SPR_Load(sz);
		pWeapon->rcAmmo2 = p->rc;

		gHR.iHistoryGap = max( gHR.iHistoryGap, pWeapon->rcActive.Height() );
	}
	else
		pWeapon->hAmmo2 = 0;

}

// Returns the first weapon for a given slot.
WEAPON *WeaponsResource :: GetFirstPos( int iSlot )
{
	WEAPON *pret = NULL;

	for (int i = 0; i < MAX_WEAPON_POSITIONS; i++)
	{
		if ( rgSlots[iSlot][i] /*&& HasAmmo( rgSlots[iSlot][i] )*/ )
		{
			pret = rgSlots[iSlot][i];
			break;
		}
	}

	return pret;
}


WEAPON* WeaponsResource :: GetNextActivePos( int iSlot, int iSlotPos )
{
	if ( iSlotPos >= MAX_WEAPON_POSITIONS || iSlot >= MAX_WEAPON_SLOTS )
		return NULL;

	WEAPON *p = gWR.rgSlots[ iSlot ][ iSlotPos+1 ];
	
	if ( !p || !gWR.HasAmmo(p) )
		return GetNextActivePos( iSlot, iSlotPos + 1 );

	return p;
}


int giBucketHeight, giBucketWidth, giABHeight, giABWidth; // Ammo Bar width and height

HSPRITE ghsprBuckets;					// Sprite for top row of weapons menu

// width of ammo fonts
#define AMMO_SMALL_WIDTH 10
#define AMMO_LARGE_WIDTH 20

#define HISTORY_DRAW_TIME	"5"

int CHudAmmo::Init(void)
{
	gHUD.AddHudElem(this);

	HOOK_MESSAGE(gHUD.m_Ammo, CurWeapon);
	HOOK_MESSAGE(gHUD.m_Ammo, WeaponList);
	HOOK_MESSAGE(gHUD.m_Ammo, AmmoPickup);
	HOOK_MESSAGE(gHUD.m_Ammo, WeapPickup);
	HOOK_MESSAGE(gHUD.m_Ammo, ItemPickup);
	HOOK_MESSAGE(gHUD.m_Ammo, HideWeapon);
	HOOK_MESSAGE(gHUD.m_Ammo, AmmoX);
	HOOK_MESSAGE(gHUD.m_Ammo, Crosshair);
	HOOK_MESSAGE(gHUD.m_Ammo, Brass);

	HOOK_COMMAND(gHUD.m_Ammo, "slot1", Slot1);
	HOOK_COMMAND(gHUD.m_Ammo, "slot2", Slot2);
	HOOK_COMMAND(gHUD.m_Ammo, "slot3", Slot3);
	HOOK_COMMAND(gHUD.m_Ammo, "slot4", Slot4);
	HOOK_COMMAND(gHUD.m_Ammo, "slot5", Slot5);
	HOOK_COMMAND(gHUD.m_Ammo, "slot6", Slot6);
	HOOK_COMMAND(gHUD.m_Ammo, "slot7", Slot7);
	HOOK_COMMAND(gHUD.m_Ammo, "slot8", Slot8);
	HOOK_COMMAND(gHUD.m_Ammo, "slot9", Slot9);
	HOOK_COMMAND(gHUD.m_Ammo, "slot10", Slot10);
	HOOK_COMMAND(gHUD.m_Ammo, "cancelselect", Close);
	HOOK_COMMAND(gHUD.m_Ammo, "invnext", NextWeapon);
	HOOK_COMMAND(gHUD.m_Ammo, "invprev", PrevWeapon);
	HOOK_COMMAND(gHUD.m_Ammo, "adjust_crosshair", Adjust_Crosshair);
	HOOK_COMMAND(gHUD.m_Ammo, "rebuy", Rebuy);
	HOOK_COMMAND(gHUD.m_Ammo, "autobuy", Autobuy);

	Reset();

	m_pHud_DrawHistory_Time = CVAR_CREATE( "hud_drawhistory_time", HISTORY_DRAW_TIME, 0 );
	m_pHud_FastSwitch = CVAR_CREATE( "hud_fastswitch", "0", FCVAR_ARCHIVE );		// controls whether or not weapons can be selected in one keypress
	// CVAR_CREATE( "cl_observercrosshair", "1", 0 );
	m_pClCrosshairColor = (convar_t*)CVAR_CREATE( "cl_crosshair_color", "50 250 50", FCVAR_ARCHIVE );
	m_pClCrosshairTranslucent = (convar_t*)CVAR_CREATE( "cl_crosshair_translucent", "1", FCVAR_ARCHIVE );
	m_pClCrosshairSize = (convar_t*)CVAR_CREATE( "cl_crosshair_size", "auto", FCVAR_ARCHIVE );
	m_pClDynamicCrosshair = CVAR_CREATE("cl_dynamiccrosshair", "1", FCVAR_ARCHIVE);

	m_hStaticSpr = 0;

	m_iFlags = HUD_DRAW | HUD_THINK; //!!!
	m_R = 50;
	m_G = 250;
	m_B = 50;
	m_iAlpha = 200;

	m_cvarB = m_cvarR = m_cvarG = -1;
	m_iCurrentCrosshair = 0;
	m_bAdditive = true;
	m_iCrosshairScaleBase = -1;
	m_bDrawCrosshair = true;

	gWR.Init();
	gHR.Init();

	xhair_enable = CVAR_CREATE( "xhair_enable", "0", FCVAR_ARCHIVE );
	xhair_gap = CVAR_CREATE( "xhair_gap", "0", FCVAR_ARCHIVE );
	xhair_size = CVAR_CREATE( "xhair_size", "4", FCVAR_ARCHIVE );
	xhair_thick = CVAR_CREATE( "xhair_thick", "0", FCVAR_ARCHIVE );
	xhair_pad = CVAR_CREATE( "xhair_pad", "0", FCVAR_ARCHIVE );
	xhair_dot = CVAR_CREATE( "xhair_dot", "0", FCVAR_ARCHIVE );
	xhair_t = CVAR_CREATE( "xhair_t", "0", FCVAR_ARCHIVE );
	xhair_dynamic_scale = CVAR_CREATE( "xhair_dynamic_scale", "0", FCVAR_ARCHIVE );
	xhair_gap_useweaponvalue = CVAR_CREATE( "xhair_gap_useweaponvalue", "0", FCVAR_ARCHIVE );
	xhair_dynamic_move = CVAR_CREATE( "xhair_dynamic_move", "1", FCVAR_ARCHIVE );

	xhair_color = CVAR_CREATE( "xhair_color", "0 255 0 255", FCVAR_ARCHIVE );
	xhair_additive = CVAR_CREATE( "xhair_additive", "0", FCVAR_ARCHIVE );

	return 1;
}

void CHudAmmo::Reset(void)
{
	m_fFade = 0;

	gpActiveSel = NULL;
	gHUD.m_iHideHUDDisplay = 0;

	gWR.Reset();
	gHR.Reset();

	//	VidInit();

}

int CHudAmmo::VidInit(void)
{
	// Load sprites for buckets (top row of weapon menu)
	m_HUD_bucket0 = gHUD.GetSpriteIndex( "bucket1" );
	m_HUD_selection = gHUD.GetSpriteIndex( "selection" );

	ghsprBuckets = gHUD.GetSprite(m_HUD_bucket0);
	giBucketWidth = gHUD.GetSpriteRect(m_HUD_bucket0).Width();
	giBucketHeight = gHUD.GetSpriteRect(m_HUD_bucket0).Height();

	gHR.iHistoryGap = max( gHR.iHistoryGap, giBucketHeight);

	// If we've already loaded weapons, let's get new sprites
	gWR.LoadAllWeaponSprites();

	giABWidth = 20;
	giABHeight = 4;

	return 1;
}

//
// Think:
//  Used for selection of weapon menu item.
//
void CHudAmmo::Think(void)
{
	if ( gHUD.m_fPlayerDead )
		return;

	if ( gHUD.m_iWeaponBits != gWR.iOldWeaponBits )
	{
		gWR.iOldWeaponBits = gHUD.m_iWeaponBits;

		for (int i = 0; i < MAX_WEAPONS-1; i++ )
		{
			WEAPON *p = gWR.GetWeapon(i);

			if ( p )
			{
				if ( gHUD.m_iWeaponBits & ( 1 << p->iId ) )
				{
					gWR.PickupWeapon( p );
				}
				else
				{
					if( gHUD.GetGameType() != GAME_CZERODS )
						gWR.DropWeapon( p );
				}
			}
		}
	}

	if (!gpActiveSel)
		return;

	// has the player selected one?
	if (gHUD.m_iKeyBits & IN_ATTACK)
	{
		if (gpActiveSel != (WEAPON *)1)
		{
			ServerCmd(gpActiveSel->szName);
			g_weaponselect = gpActiveSel->iId;
			g_weaponselect_frames = 3;
		}

		gpLastSel = gpActiveSel;
		gpActiveSel = NULL;
		gHUD.m_iKeyBits &= ~IN_ATTACK;

		PlaySound("common/wpn_select.wav", 1);
	}

}

//
// Helper function to return a Ammo pointer from id
//

HSPRITE* WeaponsResource :: GetAmmoPicFromWeapon( int iAmmoId, wrect_t& rect )
{
	for ( int i = 0; i < MAX_WEAPONS; i++ )
	{
		if ( rgWeapons[i].iAmmoType == iAmmoId )
		{
			rect = rgWeapons[i].rcAmmo;
			return &rgWeapons[i].hAmmo;
		}
		else if ( rgWeapons[i].iAmmo2Type == iAmmoId )
		{
			rect = rgWeapons[i].rcAmmo2;
			return &rgWeapons[i].hAmmo2;
		}
	}

	return NULL;
}


// Menu Selection Code

void WeaponsResource :: SelectSlot( int iSlot, int fAdvance, int iDirection )
{
	if ( gHUD.m_Menu.m_fMenuDisplayed && (fAdvance == FALSE) && (iDirection == 1) )	
	{ // menu is overriding slot use commands
		gHUD.m_Menu.SelectMenuItem( iSlot + 1 );  // slots are one off the key numbers
		return;
	}

	if ( iSlot > MAX_WEAPON_SLOTS )
		return;

	if ( gHUD.m_fPlayerDead || gHUD.m_iHideHUDDisplay & ( HIDEHUD_WEAPONS | HIDEHUD_ALL ) )
		return;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return;

	if ( ! ( gHUD.m_iWeaponBits & ~(1<<(WEAPON_SUIT)) ))
		return;

	WEAPON *p = NULL;
	bool fastSwitch = gHUD.m_Ammo.m_pHud_FastSwitch->value != 0.0f;

	if ( (gpActiveSel == NULL) || (gpActiveSel == (WEAPON *)1) || (iSlot != gpActiveSel->iSlot) )
	{
		PlaySound( "common/wpn_hudon.wav", 1 );
		p = GetFirstPos( iSlot );

		if ( p && fastSwitch ) // check for fast weapon switch mode
		{
			// if fast weapon switch is on, then weapons can be selected in a single keypress
			// but only if there is only one item in the bucket
			WEAPON *p2 = GetNextActivePos( p->iSlot, p->iSlotPos );
			if ( !p2 )
			{	// only one active item in bucket, so change directly to weapon
				ServerCmd( p->szName );
				g_weaponselect = p->iId;
				return;
			}
		}
	}
	else
	{
		PlaySound("common/wpn_moveselect.wav", 1);
		if ( gpActiveSel )
			p = GetNextActivePos( gpActiveSel->iSlot, gpActiveSel->iSlotPos );
		if ( !p )
			p = GetFirstPos( iSlot );
	}

	
	if ( !p )  // no selection found
	{
		// just display the weapon list, unless fastswitch is on just ignore it
		if ( !fastSwitch )
			gpActiveSel = (WEAPON *)1;
		else
			gpActiveSel = NULL;
	}
	else 
		gpActiveSel = p;
}

//------------------------------------------------------------------------
// Message Handlers
//------------------------------------------------------------------------

//
// AmmoX  -- Update the count of a known type of ammo
// 
int CHudAmmo::MsgFunc_AmmoX(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	int iIndex = reader.ReadByte();
	int iCount = reader.ReadByte();

	gWR.SetAmmo( iIndex, abs(iCount) );

	return 1;
}

int CHudAmmo::MsgFunc_AmmoPickup( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	int iIndex = reader.ReadByte();
	int iCount = reader.ReadByte();

	// Add ammo to the history
	gHR.AddToHistory( HISTSLOT_AMMO, iIndex, abs(iCount) );

	return 1;
}

int CHudAmmo::MsgFunc_WeapPickup( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	int iIndex = reader.ReadByte();

	// Add the weapon to the history
	gHR.AddToHistory( HISTSLOT_WEAP, iIndex );

	if( gHUD.GetGameType() == GAME_CZERODS )
	{
		gWR.PickupWeapon( iIndex );
	}

	return 1;
}

int CHudAmmo::MsgFunc_ItemPickup( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	const char *szName = reader.ReadString();

	// Add the weapon to the history
	gHR.AddToHistory( HISTSLOT_ITEM, szName );

	return 1;
}


int CHudAmmo::MsgFunc_HideWeapon( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	
	gHUD.m_iHideHUDDisplay = reader.ReadByte();

	if (gEngfuncs.IsSpectateOnly())
		return 1;

	if ( gHUD.m_iHideHUDDisplay & ( HIDEHUD_WEAPONS | HIDEHUD_FLASHLIGHT | HIDEHUD_ALL ) )
	{
		gpActiveSel = NULL;
		HideCrosshair();
	}

	return 1;
}

// 
//  CurWeapon: Update hud state with the current weapon and clip count. Ammo
//  counts are updated with AmmoX. Server assures that the Weapon ammo type 
//  numbers match a real ammo type.
//
int CHudAmmo::MsgFunc_CurWeapon(const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int iState = reader.ReadByte();
	int iId = reader.ReadChar();
	int iClip = reader.ReadChar();

	if ( iId < 1 )
	{
		HideCrosshair();
		return 0;
	}

	if ( g_iUser1 != OBS_IN_EYE )
	{
		// Is player dead???
		if ((iId == -1) && (iClip == -1))
		{
			gHUD.m_fPlayerDead = TRUE;
			gpActiveSel = NULL;
			return 1;
		}
		gHUD.m_fPlayerDead = FALSE;
	}

	WEAPON *pWeapon = gWR.GetWeapon( iId );

	if ( !pWeapon )
		return 0;

	if ( iClip < -1 )
		pWeapon->iClip = abs(iClip);
	else
		pWeapon->iClip = iClip;


	if ( iState == 0 )	// we're not the current weapon, so update no more
		return 1;

	m_pWeapon = pWeapon;

	m_fFade = 200.0f; //!!!

	return 1;
}

//
// WeaponList -- Tells the hud about a new weapon type.
//
int CHudAmmo::MsgFunc_WeaponList(const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	
	WEAPON Weapon;

	strncpy( Weapon.szName, reader.ReadString(), MAX_WEAPON_NAME );
	Weapon.szName[MAX_WEAPON_NAME-1] = 0;
	Weapon.iAmmoType = (int)reader.ReadChar();
	
	Weapon.iMax1 = reader.ReadByte();
	if (Weapon.iMax1 == 255)
		Weapon.iMax1 = -1;

	Weapon.iAmmo2Type = reader.ReadChar();
	Weapon.iMax2 = reader.ReadByte();
	if (Weapon.iMax2 == 255)
		Weapon.iMax2 = -1;

	Weapon.iSlot = reader.ReadChar();
	Weapon.iSlotPos = reader.ReadChar();
	Weapon.iId = reader.ReadChar();
	Weapon.iFlags = reader.ReadByte();
	Weapon.iClip = 0;

	gWR.AddWeapon( &Weapon );

	return 1;

}

int CHudAmmo::MsgFunc_Crosshair(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	if( reader.ReadByte() > 0)
	{
		m_bDrawCrosshair = true;
	}
	else
	{
		m_bDrawCrosshair = false;
	}
   return 0;
}

int CHudAmmo::MsgFunc_Brass( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	reader.ReadByte(); // unused!

	Vector origin, velocity;
	origin.x = reader.ReadCoord();
	origin.y = reader.ReadCoord();
	origin.z = reader.ReadCoord();
	reader.ReadCoord(); // unused!
	reader.ReadCoord(); // unused!
	reader.ReadCoord(); // unused!
	velocity.x = reader.ReadCoord();
	velocity.y = reader.ReadCoord();
	velocity.z = reader.ReadCoord();

	float Rotation = M_PI * reader.ReadAngle() / 180.0f;
	int ModelIndex = reader.ReadShort();
	int BounceSoundType = reader.ReadByte();
	int Life = reader.ReadByte();
	int Client = reader.ReadByte();

	float sin, cos, x, y;
	sin = fabs(Rotation);
	cos = fabs(Rotation);

	if( gHUD.cl_righthand->value != 0.0f && EV_IsLocal( Client ) )
	{
		velocity.x += sin * -120.0;
		velocity.y += cos * 120.0;
		x = 9.0 * sin;
		y = -9.0 * cos;
	}
	else
	{
		x = -9.0 * sin;
		y = 9.0 * cos;
	}

	origin.x += x;
	origin.y += y;
	EV_EjectBrass( origin, velocity, Rotation, ModelIndex, BounceSoundType, Life );
	return 1;
}

//------------------------------------------------------------------------
// Command Handlers
//------------------------------------------------------------------------
// Slot button pressed
void CHudAmmo::SlotInput( int iSlot )
{
	gWR.SelectSlot(iSlot, FALSE, 1);
}

void CHudAmmo::UserCmd_Slot1(void)
{
	SlotInput( 0 );
}

void CHudAmmo::UserCmd_Slot2(void)
{
	SlotInput( 1 );
}

void CHudAmmo::UserCmd_Slot3(void)
{
	SlotInput( 2 );
}

void CHudAmmo::UserCmd_Slot4(void)
{
	SlotInput( 3 );
}

void CHudAmmo::UserCmd_Slot5(void)
{
	SlotInput( 4 );
}

void CHudAmmo::UserCmd_Slot6(void)
{
	SlotInput( 5 );
}

void CHudAmmo::UserCmd_Slot7(void)
{
	SlotInput( 6 );
}

void CHudAmmo::UserCmd_Slot8(void)
{
	SlotInput( 7 );
}

void CHudAmmo::UserCmd_Slot9(void)
{
	SlotInput( 8 );
}

void CHudAmmo::UserCmd_Slot10(void)
{
	SlotInput( 9 );
}

void CHudAmmo::UserCmd_Adjust_Crosshair()
{
	int newCrosshair;
	int oldCrosshair = m_iCurrentCrosshair;

	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		newCrosshair = (oldCrosshair + 1) % 5;
	}
	else
	{
		const char *arg = gEngfuncs.Cmd_Argv(1);
		newCrosshair = atoi(arg) % 10;
	}

	m_iCurrentCrosshair = newCrosshair;
	if ( newCrosshair <= 9 )
	{
		switch ( newCrosshair )
		{
		case 0:
		case 5:
			m_R = 50;
			m_G = 250;
			m_B = 50;
			break;
		case 1:
		case 6:
			m_R = 250;
			m_G = 50;
			m_B = 50;
			break;
		case 2:
		case 7:
			m_R = 50;
			m_G = 50;
			m_B = 250;
			break;
		case 3:
		case 8:
			m_R = 250;
			m_G = 250;
			m_B = 50;
			break;
		case 4:
		case 9:
			m_R = 50;
			m_G = 250;
			m_B = 250;
			break;
		}
		m_bAdditive = newCrosshair < 5 ? true: false;
	}
	else
	{
		m_R = 50;
		m_G = 250;
		m_B = 50;
		m_bAdditive = 1;
	}

	char s[16];
	sprintf(s, "%d %d %d", m_R, m_G, m_B);
	gEngfuncs.Cvar_Set("cl_crosshair_color", s);
	gEngfuncs.Cvar_Set("cl_crosshair_translucent", (char*)(m_bAdditive ? "1" : "0"));
}


void CHudAmmo::UserCmd_Close(void)
{
	if (gpActiveSel)
	{
		gpLastSel = gpActiveSel;
		gpActiveSel = NULL;
		PlaySound("common/wpn_hudoff.wav", 1);
	}
	else
		ClientCmd("escape");
}


// Selects the next item in the weapon menu
void CHudAmmo::UserCmd_NextWeapon(void)
{
	if ( gHUD.m_fPlayerDead || (gHUD.m_iHideHUDDisplay & (HIDEHUD_WEAPONS | HIDEHUD_ALL)) )
		return;

	if ( !gpActiveSel || gpActiveSel == (WEAPON*)1 )
		gpActiveSel = m_pWeapon;

	int pos = 0;
	int slot = 0;
	if ( gpActiveSel )
	{
		pos = gpActiveSel->iSlotPos + 1;
		slot = gpActiveSel->iSlot;
	}

	for ( int loop = 0; loop <= 1; loop++ )
	{
		for ( ; slot < MAX_WEAPON_SLOTS; slot++ )
		{
			for ( ; pos < MAX_WEAPON_POSITIONS; pos++ )
			{
				WEAPON *wsp = gWR.GetWeaponSlot( slot, pos );

				if ( wsp /*&& gWR.HasAmmo(wsp)*/ )
				{
					gpActiveSel = wsp;
					return;
				}
			}

			pos = 0;
		}

		slot = 0;  // start looking from the first slot again
	}

	gpActiveSel = NULL;
}

// Selects the previous item in the menu
void CHudAmmo::UserCmd_PrevWeapon(void)
{
	if ( gHUD.m_fPlayerDead || (gHUD.m_iHideHUDDisplay & (HIDEHUD_WEAPONS | HIDEHUD_ALL)) )
		return;

	if ( !gpActiveSel || gpActiveSel == (WEAPON*)1 )
		gpActiveSel = m_pWeapon;

	int pos = MAX_WEAPON_POSITIONS-1;
	int slot = MAX_WEAPON_SLOTS-1;
	if ( gpActiveSel )
	{
		pos = gpActiveSel->iSlotPos - 1;
		slot = gpActiveSel->iSlot;
	}
	
	for ( int loop = 0; loop <= 1; loop++ )
	{
		for ( ; slot >= 0; slot-- )
		{
			for ( ; pos >= 0; pos-- )
			{
				WEAPON *wsp = gWR.GetWeaponSlot( slot, pos );

				if ( wsp /*&& gWR.HasAmmo(wsp)*/ )
				{
					gpActiveSel = wsp;
					return;
				}
			}

			pos = MAX_WEAPON_POSITIONS-1;
		}
		
		slot = MAX_WEAPON_SLOTS-1;
	}

	gpActiveSel = NULL;
}

void CHudAmmo::UserCmd_Autobuy()
{
	char *afile = (char*)gEngfuncs.COM_LoadFile("autobuy.txt", 5, NULL);
	char *pfile = afile;
	char token[1024];
	char szCmd[1024];
	int remaining = 1023;

	if( !pfile )
	{
		ConsolePrint( "Can't open autobuy.txt file.\n" );
		return;
	}

	strcpy(szCmd, "cl_setautobuy");
	remaining -= sizeof( "cl_setautobuy" );

	while((pfile = gEngfuncs.COM_ParseFile( pfile, token )))
	{
		// append space first
		strncat(szCmd, " ", remaining);
		strncat(szCmd, token, remaining - 1);

		remaining -= strlen( token ) - 1;
	}

	gEngfuncs.pfnServerCmd( szCmd );
	gEngfuncs.COM_FreeFile( afile );
}

void CHudAmmo::UserCmd_Rebuy()
{
	char *afile = (char*)gEngfuncs.COM_LoadFile("rebuy.txt", 5, NULL);
	char *pfile = afile;
	char token[1024];
	char szCmd[1024];
	int lastCh;
	int remaining = 1023;

	if( !pfile )
	{
		ConsolePrint( "Can't open rebuy.txt file.\n" );
		return;
	}

	// start with \"
	strcpy(szCmd, "cl_setrebuy \"" );
	remaining -= sizeof( "cl_setrebuy \"" );

	while((pfile = gEngfuncs.COM_ParseFile( pfile, token )))
	{
		strncat(szCmd, token, remaining );
		remaining -= strlen( token );

		// append space after token
		strncat(szCmd, " ", remaining );
		remaining--;
	}
	// replace last space with ", before terminator
	lastCh = strlen(szCmd);
	szCmd[lastCh] = '\"';

	gEngfuncs.pfnServerCmd( szCmd );
	gEngfuncs.COM_FreeFile( afile );
}


//-------------------------------------------------------------------------
// Drawing code
//-------------------------------------------------------------------------

int CHudAmmo::Draw(float flTime)
{
	int a, x, y, r, g, b;
	int AmmoWidth;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return 1;

	// place it here, so pretty dynamic crosshair will work even in spectator!
	if( gHUD.m_iFOV > 40 )
	{
		HideCrosshair(); // hide static

		// draw a dynamic crosshair
		DrawCrosshair();
	}
	else
	{
		if( m_pWeapon )
		{
			SetCrosshair(m_pWeapon->hZoomedCrosshair, m_pWeapon->rcZoomedCrosshair, 255, 255, 255);

			DrawSpriteCrosshair();
		}
	}

	if ( (gHUD.m_iHideHUDDisplay & ( HIDEHUD_WEAPONS | HIDEHUD_ALL )) )
		return 1;

	// Draw Weapon Menu
	DrawWList(flTime);

	// Draw ammo pickup history
	gHR.DrawAmmoHistory( flTime );

	if (!m_pWeapon)
		return 0;

	WEAPON *pw = m_pWeapon; // shorthand

	// SPR_Draw Ammo
	if ((pw->iAmmoType < 0) && (pw->iAmmo2Type < 0))
		return 0;

	int iFlags = DHN_DRAWZERO; // draw 0 values

	AmmoWidth = gHUD.GetSpriteRect(gHUD.m_HUD_number_0).Width();

	a = (int) max( MIN_ALPHA, m_fFade );

	if (m_fFade > 0)
		m_fFade -= (gHUD.m_flTimeDelta * 20);

	DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );

	DrawUtils::ScaleColors(r, g, b, a );

	// Does this weapon have a clip?
	y = ScreenHeight - gHUD.m_iFontHeight - gHUD.m_iFontHeight/2;

	// Does weapon have any ammo at all?
	if (m_pWeapon->iAmmoType > 0)
	{
		int iIconWidth = m_pWeapon->rcAmmo.Width();
		
		if (pw->iClip >= 0)
		{
			// room for the number and the '|' and the current ammo
			
			x = ScreenWidth - (8 * AmmoWidth) - iIconWidth;
			x = DrawUtils::DrawHudNumber(x, y, iFlags | DHN_3DIGITS, pw->iClip, r, g, b);

			int iBarWidth =  AmmoWidth/10;

			x += AmmoWidth/2;

			DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );

			// draw the | bar
			FillRGBA(x, y, iBarWidth, gHUD.m_iFontHeight, r, g, b, a);

			x += iBarWidth + AmmoWidth/2;;

			// GL Seems to need this
			DrawUtils::ScaleColors(r, g, b, a );
			x = DrawUtils::DrawHudNumber(x, y, iFlags | DHN_3DIGITS, gWR.CountAmmo(pw->iAmmoType), r, g, b);


		}
		else
		{
			// SPR_Draw a bullets only line
			x = ScreenWidth - 4 * AmmoWidth - iIconWidth;
			x = DrawUtils::DrawHudNumber(x, y, iFlags | DHN_3DIGITS, gWR.CountAmmo(pw->iAmmoType), r, g, b);
		}

		// Draw the ammo Icon
		int iOffset = (m_pWeapon->rcAmmo.Height())/8;
		SPR_Set(m_pWeapon->hAmmo, r, g, b);
		SPR_DrawAdditive(0, x, y - iOffset, &m_pWeapon->rcAmmo);
	}

	// Does weapon have seconday ammo?
	if (pw->iAmmo2Type > 0) 
	{
		int iIconWidth = m_pWeapon->rcAmmo2.Width();

		// Do we have secondary ammo?
		if ((pw->iAmmo2Type != 0) && (gWR.CountAmmo(pw->iAmmo2Type) > 0))
		{
			y -= gHUD.m_iFontHeight + gHUD.m_iFontHeight/4;
			x = ScreenWidth - 4 * AmmoWidth - iIconWidth;
			x = DrawUtils::DrawHudNumber(x, y, iFlags|DHN_3DIGITS, gWR.CountAmmo(pw->iAmmo2Type), r, g, b);

			// Draw the ammo Icon
			SPR_Set(m_pWeapon->hAmmo2, r, g, b);
			int iOffset = (m_pWeapon->rcAmmo2.Height())/8;
			SPR_DrawAdditive(0, x, y - iOffset, &m_pWeapon->rcAmmo2);
		}
	}

	return 1;
}

void CHudAmmo::DrawSpriteCrosshair()
{
	int x, y;

	if( !m_hStaticSpr )
		return;

	gEngfuncs.pfnSPR_Set( m_hStaticSpr, m_staticRgba.r, m_staticRgba.g, m_staticRgba.b );

	x = ( ScreenWidth - m_rcStaticRc.Width() ) / 2;
	y = ( ScreenHeight - m_rcStaticRc.Height() ) / 2;

	// gEngfuncs.pfnSPR_Draw( 0, x, y, &m_rcStaticRc );
	gEngfuncs.pfnSPR_DrawHoles( 0, x, y, &m_rcStaticRc );
}

#define WEST_XPOS (ScreenWidth / 2 - flCrosshairDistance - iLength + 1)
#define EAST_XPOS (flCrosshairDistance + ScreenWidth / 2)
#define EAST_WEST_YPOS (ScreenHeight / 2)

#define NORTH_YPOS (ScreenHeight / 2 - flCrosshairDistance - iLength + 1)
#define SOUTH_YPOS (ScreenHeight / 2 + flCrosshairDistance)
#define NORTH_SOUTH_XPOS (ScreenWidth / 2)

#define WEST_XPOS_R (TrueWidth / 2 - flCrosshairDistance - iLength + 1)
#define EAST_XPOS_R (flCrosshairDistance + TrueWidth / 2)
#define EAST_WEST_YPOS_R (TrueHeight / 2)

#define NORTH_YPOS_R (TrueHeight / 2 - flCrosshairDistance - iLength + 1)
#define SOUTH_YPOS_R (TrueHeight / 2 + flCrosshairDistance)
#define NORTH_SOUTH_XPOS_R (TrueWidth / 2)

int Distances[30][2] =
{
{ 8, 3 }, // 0
{ 4, 3 }, // 1
{ 5, 3 }, // 2
{ 8, 3 }, // 3
{ 9, 4 }, // 4
{ 6, 3 }, // 5
{ 9, 3 }, // 6
{ 3, 3 }, // 7
{ 8, 3 }, // 8
{ 4, 3 }, // 9
{ 8, 3 }, // 10
{ 6, 3 }, // 11
{ 5, 3 }, // 12
{ 4, 3 }, // 13
{ 4, 3 }, // 14
{ 8, 3 }, // 15
{ 8, 3 }, // 16
{ 8, 3 }, // 17
{ 6, 3 }, // 18
{ 6, 3 }, // 19
{ 8, 6 }, // 20
{ 4, 3 }, // 21
{ 7, 3 }, // 22
{ 6, 4 }, // 23
{ 8, 3 }, // 24
{ 8, 3 }, // 25
{ 5, 3 }, // 26
{ 4, 4 }, // 27
{ 7, 3 }, // 28
{ 7, 3 }, // 29
};

enum
{
	ACCURACY_NONE = 0,
	ACCURACY_JUMP = ( 1 << 0 ),
	ACCURACY_RUN = ( 1 << 1 ),
	// ACCURACY_DUCK = (1 << 2),
	ACCURACY_INACCURATE = ( 1 << 3 ),
	ACCURACY_VERY_INACCURATE = ( 1 << 4 )
};

int CHudAmmo::GetWeaponAccuracyFlags( int weaponId )
{
	int xhairWeaponFlags = g_iWeaponFlags;

	switch ( weaponId )
	{
	case WEAPON_P228:
	case WEAPON_FIVESEVEN:
	case WEAPON_DEAGLE:
		return ( ACCURACY_DUCK | ACCURACY_RUN | ACCURACY_JUMP );

	case WEAPON_MAC10:
	case WEAPON_UMP45:
	case WEAPON_MP5N:
	case WEAPON_TMP:
		return ACCURACY_JUMP;

	case WEAPON_AUG:
	case WEAPON_GALIL:
	case WEAPON_M249:
	case WEAPON_SG552:
	case WEAPON_AK47:
	case WEAPON_P90:
		return ( ACCURACY_RUN | ACCURACY_JUMP );

	case WEAPON_FAMAS:
		return ( xhairWeaponFlags & 16 ) ? ( ACCURACY_VERY_INACCURATE | ACCURACY_RUN | ACCURACY_JUMP ) : ( ACCURACY_RUN | ACCURACY_JUMP );

	case WEAPON_USP:
		return ( xhairWeaponFlags & 1 ) ? ( ACCURACY_INACCURATE | ACCURACY_DUCK | ACCURACY_RUN | ACCURACY_JUMP ) : ( ACCURACY_DUCK | ACCURACY_RUN | ACCURACY_JUMP );

	case WEAPON_GLOCK18:
		return ( xhairWeaponFlags & 2 ) ? ( ACCURACY_VERY_INACCURATE | ACCURACY_DUCK | ACCURACY_RUN | ACCURACY_JUMP ) : ( ACCURACY_DUCK | ACCURACY_RUN | ACCURACY_JUMP );

	case WEAPON_M4A1:
		return ( xhairWeaponFlags & 4 ) ? ( ACCURACY_INACCURATE | ACCURACY_RUN | ACCURACY_JUMP ) : ( ACCURACY_RUN | ACCURACY_JUMP );
	}

	return ACCURACY_NONE;
}

#define MAX_XHAIR_GAP 15

int CHudAmmo::ScaleForRes( float value, int height )
{
	/* "default" resolution is 640x480 */
	return rint( value * ( (float)height / 480.0f ) );
}

float CHudAmmo::GetCrosshairGap( int weaponId )
{
	static float xhairGap;
	static int lastShotsFired;
	static float xhairPrevTime;
	float minGap, deltaGap;

	int xhairPlayerFlags = g_iPlayerFlags;
	float xhairPlayerSpeed = g_flPlayerSpeed;
	float clientTime = gEngfuncs.GetClientTime();
	int xhairShotsFired = g_iShotsFired;

	switch ( weaponId )
	{
	case WEAPON_P228:
	case WEAPON_HEGRENADE:
	case WEAPON_SMOKEGRENADE:
	case WEAPON_FIVESEVEN:
	case WEAPON_USP:
	case WEAPON_GLOCK18:
	case WEAPON_AWP:
	case WEAPON_FLASHBANG:
	case WEAPON_DEAGLE:
		minGap = 8;
		deltaGap = 3;
		break;

	case WEAPON_SCOUT:
	case WEAPON_SG550:
	case WEAPON_SG552:
		minGap = 5;
		deltaGap = 3;
		break;

	case WEAPON_XM1014:
		minGap = 9;
		deltaGap = 4;
		break;

	case WEAPON_C4:
	case WEAPON_UMP45:
	case WEAPON_M249:
		minGap = 6;
		deltaGap = 3;
		break;

	case WEAPON_MAC10:
		minGap = 9;
		deltaGap = 3;
		break;

	case WEAPON_AUG:
		minGap = 3;
		deltaGap = 3;
		break;

	case WEAPON_MP5N:
		minGap = 6;
		deltaGap = 2;
		break;

	case WEAPON_M3:
		minGap = 8;
		deltaGap = 6;
		break;

	case WEAPON_TMP:
	case WEAPON_KNIFE:
	case WEAPON_P90:
		minGap = 7;
		deltaGap = 3;
		break;

	case WEAPON_G3SG1:
		minGap = 6;
		deltaGap = 4;
		break;

	case WEAPON_AK47:
		minGap = 4;
		deltaGap = 4;
		break;

	default:
		minGap = 4;
		deltaGap = 3;
		break;
	}

	if ( !xhair_gap_useweaponvalue->value )
		minGap = 4;

	float baseMinGap = minGap;
	float absMinGap = baseMinGap * 0.5f;

	int flags = GetWeaponAccuracyFlags( weaponId );
	if ( xhair_dynamic_move->value && flags )
	{
		if ( !( xhairPlayerFlags & FL_ONGROUND ) && ( flags & ACCURACY_AIR ) )
		{
			minGap *= 2.0f;
		}
		else if ( ( xhairPlayerFlags & FL_DUCKING ) && ( flags & ACCURACY_DUCK ) )
		{
			minGap *= 0.5f;
		}
		else
		{
			float runLimit;

			switch ( weaponId )
			{
			case WEAPON_AUG:
			case WEAPON_GALIL:
			case WEAPON_FAMAS:
			case WEAPON_M249:
			case WEAPON_M4A1:
			case WEAPON_SG552:
			case WEAPON_AK47:
				runLimit = 140;
				break;

			case WEAPON_P90:
				runLimit = 170;
				break;

			default:
				runLimit = 0;
				break;
			}

			if ( xhairPlayerSpeed > runLimit && ( flags & ACCURACY_RUN ) )
				minGap *= 1.5f;
		}

		if ( flags & ACCURACY_INACCURATE )
			minGap *= 1.4f;

		if ( flags & ACCURACY_VERY_INACCURATE )
			minGap *= 1.4f;

		minGap = baseMinGap + ( minGap - baseMinGap ) * xhair_dynamic_scale->value;
		minGap = max( minGap, absMinGap );
	}

	if ( xhairPrevTime > clientTime )
	{
		// client restart
		xhairPrevTime = clientTime;
	}

	float deltaTime = clientTime - xhairPrevTime;
	xhairPrevTime = clientTime;

	if ( xhairShotsFired <= lastShotsFired )
	{
		// decay the crosshair as if we were always running at 100 fps
		xhairGap -= ( 100 * deltaTime ) * ( 0.013f * xhairGap + 0.1f );
	}
	else
	{
		xhairGap += deltaGap * xhair_dynamic_scale->value;
		xhairGap = min( xhairGap, MAX_XHAIR_GAP );
	}

	if ( xhairShotsFired > 600 )
		xhairShotsFired = 1;

	lastShotsFired = xhairShotsFired;

	xhairGap = max( xhairGap, minGap );

	return xhairGap + xhair_gap->value;
}

void CHudAmmo::DrawCrosshairSection( int _x0, int _y0, int _x1, int _y1 )
{
	float x0 = (float)_x0;
	float y0 = (float)_y0;
	float x1 = (float)_x1;
	float y1 = (float)_y1;
	int color[4] = { 0, 255, 0, 255 };

	// float top_left[2] = { x0, y0 };
	// float top_right[2] = { x1, y0 };
	// float bottom_right[2] = { x1, y1 };
	// float bottom_left[2] = { x0, y1 };

	if ( sscanf( xhair_color->string, "%d %d %d %d", &color[0], &color[1], &color[2], &color[3] ) == 4 )
	{
		color[0] = bound( 0, color[0], 255 );
		color[1] = bound( 0, color[1], 255 );
		color[2] = bound( 0, color[2], 255 );
		color[3] = bound( 0, color[3], 255 );
	}
	gEngfuncs.pTriAPI->Color4f( color[0] / 255.0f, color[1] / 255.0f, color[2] / 255.0f, color[3] / 255.0f );
	// gEngfuncs.pTriAPI->Brightness( 1.0f );

	DrawUtils::Draw2DQuad( x0, y0, x1, y1 );
}

void CHudAmmo::DrawCrosshairPadding( int _pad, int _x0, int _y0, int _x1, int _y1 )
{
	float pad = (float)_pad;
	float x0 = (float)_x0;
	float y0 = (float)_y0;
	float x1 = (float)_x1;
	float y1 = (float)_y1;
	int alpha = 255;

	// float out_top_left[2] = { x0 - pad, y0 - pad };
	// float out_top_right[2] = { x1 + pad, y0 - pad };
	// float out_bottom_right[2] = { x1 + pad, y1 + pad };
	// float out_bottom_left[2] = { x0 - pad, y1 + pad };
	// float in_top_left[2] = { x0, y0 };
	// float in_top_right[2] = { x1, y0 };
	// float in_bottom_right[2] = { x1, y1 };
	// float in_bottom_left[2] = { x0, y1 };

	if ( sscanf( xhair_color->string, "%*d %*d %*d %d", &alpha ) == 1 )
	{
		alpha = bound( 0, alpha, 255 );
	}
	gEngfuncs.pTriAPI->Color4f( 0, 0, 0, alpha / 255.0f );
	// gEngfuncs.pTriAPI->Brightness( 1.0f );

	DrawUtils::Draw2DQuad( x0 - pad, y0 - pad, x1 + pad, y0 ); // top part
	DrawUtils::Draw2DQuad( x0 - pad, y1, x1 + pad, y1 + pad ); // bottom part
	DrawUtils::Draw2DQuad( x0 - pad, y0, x0, y1 );             // left part
	DrawUtils::Draw2DQuad( x1, y0, x1 + pad, y1 );             // right part
}

void CHudAmmo::DrawCrosshair( int weaponId )
{
	int center_x, center_y;
	int gap, length, thickness;
	int y0, y1, x0, x1;
	wrect_t inner;
	wrect_t outer;

	/* calculate the coordinates */
	center_x = ( ScreenWidth / 2 ) * gHUD.m_flScale;
	center_y = ( ScreenHeight / 2 ) * gHUD.m_flScale;

	gap = ScaleForRes( GetCrosshairGap( weaponId ), ScreenHeight * gHUD.m_flScale );
	length = ScaleForRes( xhair_size->value, ScreenHeight * gHUD.m_flScale );
	thickness = ScaleForRes( xhair_thick->value, ScreenHeight * gHUD.m_flScale );
	thickness = max( 1, thickness );

	inner.left = ( center_x - gap - thickness / 2 );
	inner.right = ( inner.left + 2 * gap + thickness );
	inner.top = ( center_y - gap - thickness / 2 );
	inner.bottom = ( inner.top + 2 * gap + thickness );

	outer.left = ( inner.left - length );
	outer.right = ( inner.right + length );
	outer.top = ( inner.top - length );
	outer.bottom = ( inner.bottom + length );

	y0 = ( center_y - thickness / 2 );
	x0 = ( center_x - thickness / 2 );
	y1 = ( y0 + thickness );
	x1 = ( x0 + thickness );

	gEngfuncs.pTriAPI->Brightness( 1.0f );
	gEngfuncs.pTriAPI->CullFace( TRI_NONE );

	gRenderAPI.GL_SelectTexture( 0 );
	gRenderAPI.GL_Bind( 0, gHUD.m_WhiteTex );

	if ( xhair_additive->value )
		gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
	else
		gEngfuncs.pTriAPI->RenderMode( kRenderTransAlpha );

	if ( xhair_dot->value )
		DrawCrosshairSection( x0, y0, x1, y1 );

	if ( !xhair_t->value )
		DrawCrosshairSection( x0, outer.top, x1, inner.top );

	DrawCrosshairSection( x0, inner.bottom, x1, outer.bottom );
	DrawCrosshairSection( outer.left, y0, inner.left, y1 );
	DrawCrosshairSection( inner.right, y0, outer.right, y1 );

	if ( xhair_additive->value )
		gEngfuncs.pTriAPI->RenderMode( kRenderTransAlpha );

	/* draw padding if wanted */
	if ( xhair_pad->value )
	{
		/* don't scale this */
		int pad = (int)xhair_pad->value;

		if ( xhair_dot->value )
			DrawCrosshairPadding( pad, x0, y0, x1, y1 );

		if ( !xhair_t->value )
			DrawCrosshairPadding( pad, x0, outer.top, x1, inner.top );

		DrawCrosshairPadding( pad, x0, inner.bottom, x1, outer.bottom );
		DrawCrosshairPadding( pad, outer.left, y0, inner.left, y1 );
		DrawCrosshairPadding( pad, inner.right, y0, outer.right, y1 );
	}
}

void CHudAmmo::DrawCrosshair()
{
	int flags, iDeltaDistance, iDistance, iLength, weaponid;
	float flCrosshairDistance;

	if ( !m_pWeapon )
		return;

	weaponid = m_pWeapon->iId;

	if ( weaponid == WEAPON_AWP
	     || weaponid == WEAPON_SCOUT
	     || weaponid == WEAPON_SG550
	     || weaponid == WEAPON_G3SG1 )
		return;

	if ( g_iWeaponFlags & WPNSTATE_SHIELD_DRAWN )
		return;

	if ( weaponid <= 30 )
	{
		iDistance = Distances[weaponid - 1][0];
		iDeltaDistance = Distances[weaponid - 1][1];
	}
	else
	{
		iDistance = 4;
		iDeltaDistance = 3;
	}

	flags = GetWeaponAccuracyFlags( weaponid );
	if ( flags && m_pClDynamicCrosshair->value && !( gHUD.m_iHideHUDDisplay & 1 ) )
	{
		if ( g_iPlayerFlags & FL_ONGROUND || !( flags & ACCURACY_AIR ) )
		{
			if ( ( g_iPlayerFlags & FL_DUCKING ) && ( flags & ACCURACY_DUCK ) )
			{
				iDistance *= 0.5;
			}
			else
			{
				int iWeaponSpeed = 0;

				switch ( weaponid )
				{
				case WEAPON_P90: // p90
					iWeaponSpeed = 170;
					break;
				case WEAPON_AUG:   // aug
				case WEAPON_GALIL: // galil
				case WEAPON_FAMAS: // famas
				case WEAPON_M249:  // m249
				case WEAPON_M4A1:  // m4a1
				case WEAPON_SG552: // sg552
				case WEAPON_AK47:  // ak47
					iWeaponSpeed = 140;
					break;
				}

				if ( ( flags & ACCURACY_SPEED ) && ( g_flPlayerSpeed >= iWeaponSpeed ) )
					iDistance *= 1.5;
			}
		}
		else
		{
			iDistance *= 2;
		}
		if ( flags & ACCURACY_MULTIPLY_BY_14 )
			iDistance *= 1.4;
		if ( flags & ACCURACY_MULTIPLY_BY_14_2 )
			iDistance *= 1.4;
	}

	if ( m_iAmmoLastCheck >= g_iShotsFired )
	{
		m_flCrosshairDistance -= ( m_flCrosshairDistance * 0.013 + 0.1 );
		m_iAlpha += 2;
	}
	else
	{
		m_flCrosshairDistance = min( m_flCrosshairDistance + iDeltaDistance, 15.0f );
		m_iAlpha = max( m_iAlpha - 40, 120 );
	}

	if ( g_iShotsFired > 600 )
		g_iShotsFired = 1;

	CalcCrosshairColor();
	CalcCrosshairDrawMode();
	CalculateCrosshairSize();

	m_iAmmoLastCheck = g_iShotsFired;
	m_flCrosshairDistance = max( m_flCrosshairDistance, iDistance );
	iLength = ( m_flCrosshairDistance - iDistance ) * 0.5 + 5;

	if ( m_iAlpha > 255 )
		m_iAlpha = 255;

	if ( ScreenWidth != m_iCrosshairScaleBase )
	{
		flCrosshairDistance = ScreenWidth * m_flCrosshairDistance / m_iCrosshairScaleBase;
		iLength = ScreenWidth * iLength / m_iCrosshairScaleBase;
	}
	else
	{
		flCrosshairDistance = m_flCrosshairDistance;
	}

	// drawing
	if ( g_iXash && xhair_enable->value )
	{
		DrawCrosshair( weaponid );
		return;
	}

	if ( m_bAdditive )
	{
		FillRGBA( WEST_XPOS, EAST_WEST_YPOS, iLength, 1, m_R, m_G, m_B, m_iAlpha );
		FillRGBA( EAST_XPOS, EAST_WEST_YPOS, iLength, 1, m_R, m_G, m_B, m_iAlpha );
		FillRGBA( NORTH_SOUTH_XPOS, NORTH_YPOS, 1, iLength, m_R, m_G, m_B, m_iAlpha );
		FillRGBA( NORTH_SOUTH_XPOS, SOUTH_YPOS, 1, iLength, m_R, m_G, m_B, m_iAlpha );
	}
	else
	{
		FillRGBABlend( WEST_XPOS, EAST_WEST_YPOS, iLength, 1, m_R, m_G, m_B, m_iAlpha );
		FillRGBABlend( EAST_XPOS, EAST_WEST_YPOS, iLength, 1, m_R, m_G, m_B, m_iAlpha );
		FillRGBABlend( NORTH_SOUTH_XPOS, NORTH_YPOS, 1, iLength, m_R, m_G, m_B, m_iAlpha );
		FillRGBABlend( NORTH_SOUTH_XPOS, SOUTH_YPOS, 1, iLength, m_R, m_G, m_B, m_iAlpha );
	}
}

void CHudAmmo::CalculateCrosshairSize()
{
	int size;

	size = strtol( m_pClCrosshairSize->string, NULL, 10 );

	if( size > 3 )
	{
		size = -1;
	}
	else if( size == 0 && strcmp( "0", m_pClCrosshairSize->string ))
	{
		size = -1;
	}
	
	if( !stricmp( m_pClCrosshairSize->string, "auto" ))
	{
		size = 0;
	}
	else if( !stricmp( m_pClCrosshairSize->string, "small" ))
	{
		size = 1;
	}
	else if( !stricmp( m_pClCrosshairSize->string, "medium" ))
	{
		size = 2;
	}
	else if( !stricmp( m_pClCrosshairSize->string, "large" ))
	{
		size = 3;
	}

	switch( size )
	{
	case -1:
		gEngfuncs.Con_Printf( "usage: cl_crosshair_size <auto|small|medium|large>\n" );
        break;
	case 0:
		if( gHUD.m_scrinfo.iWidth > 640 )
		{
			if( gHUD.m_scrinfo.iWidth < 1024 )
				m_iCrosshairScaleBase = 800;
			else
				m_iCrosshairScaleBase = 640;
		}
		break;
	case 1:
		m_iCrosshairScaleBase = 1024;
		break;
	case 2:
		m_iCrosshairScaleBase = 800;
		break;
	case 3:
	default:
		m_iCrosshairScaleBase = 640;
		break;
	}
}

void CHudAmmo::CalcCrosshairDrawMode()
{
	static float prevDrawMode = -1;
	float drawMode = m_pClCrosshairTranslucent->value;
	
	if( gHUD.m_NVG.m_iFlags )
	{
		m_bAdditive = 0;
		return;
	}

	if( drawMode == prevDrawMode )
		return;
	
	if ( drawMode == 0.0f )
	{
		m_bAdditive = 0;
	}
	else if ( drawMode == 1.0f )
	{
		m_bAdditive = 1;
	}
	else
	{
		gEngfuncs.Con_Printf("usage: cl_crosshair_translucent <1|0>\n");
		gEngfuncs.Cvar_Set("cl_crosshair_translucent", "1");
	}
	
	prevDrawMode = drawMode;
}

void CHudAmmo::CalcCrosshairColor()
{
	static char prevColors[64] = { 0 };
	const char *colors = m_pClCrosshairColor->string;

	if( gHUD.m_NVG.m_iFlags )
	{
		m_R = 250;
		m_G = 50;
		m_B = 50;
		return;
	}

	if( strncmp( prevColors, colors, 64 ) )
	{
		strncpy( prevColors, colors, 64 );
		prevColors[63] = 0;
	
		sscanf( colors, "%d %d %d", &m_cvarR, &m_cvarG, &m_cvarB);

		m_R = m_cvarR = bound( 0, m_cvarR, 255 );
		m_G = m_cvarG = bound( 0, m_cvarG, 255 );
		m_B = m_cvarB = bound( 0, m_cvarB, 255 );
	}
	else
	{
		m_R = m_cvarR;
		m_G = m_cvarG;
		m_B = m_cvarB;
	}
}

//
// Draws the ammo bar on the hud
//
int DrawBar(int x, int y, int width, int height, float f)
{
	int r, g, b;

	f = bound( 0, f, 1 );
	
	if (f)
	{
		int w = f * width;

		// Always show at least one pixel if we have ammo.
		if (w <= 0)
			w = 1;
		DrawUtils::UnpackRGB(r, g, b, RGB_GREENISH);
		FillRGBA(x, y, w, height, r, g, b, 255);
		x += w;
		width -= w;
	}

	DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );

	FillRGBA(x, y, width, height, r, g, b, 128);

	return (x + width);
}



void DrawAmmoBar(WEAPON *p, int x, int y, int width, int height)
{
	if ( !p )
		return;
	
	if (p->iAmmoType != -1)
	{
		if (!gWR.CountAmmo(p->iAmmoType))
			return;

		float f = (float)gWR.CountAmmo(p->iAmmoType)/(float)p->iMax1;
		
		x = DrawBar(x, y, width, height, f);


		// Do we have secondary ammo too?

		if (p->iAmmo2Type != -1)
		{
			f = (float)gWR.CountAmmo(p->iAmmo2Type)/(float)p->iMax2;

			x += 5; //!!!

			DrawBar(x, y, width, height, f);
		}
	}
}




//
// Draw Weapon Menu
//
int CHudAmmo::DrawWList(float flTime)
{
	int r,g,b,x,y,a,i;

	if ( !gpActiveSel )
		return 0;

	int iActiveSlot;

	if ( gpActiveSel == (WEAPON *)1 )
		iActiveSlot = -1;	// current slot has no weapons
	else 
		iActiveSlot = gpActiveSel->iSlot;

	x = gHUD.m_Radar.m_hRadar.rect.right + 10; //!!!
	y = 10; //!!!
	

	// Ensure that there are available choices in the active slot
	if ( iActiveSlot > 0 )
	{
		if ( !gWR.GetFirstPos( iActiveSlot ) )
		{
			gpActiveSel = (WEAPON *)1;
			iActiveSlot = -1;
		}
	}
		
	// Draw top line
	for ( i = 0; i < MAX_WEAPON_SLOTS; i++ )
	{
		int iWidth;

		DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
	
		if ( iActiveSlot == i )
			a = 255;
		else
			a = 192;

		DrawUtils::ScaleColors(r, g, b, 255);
		SPR_Set(gHUD.GetSprite(m_HUD_bucket0 + i), r, g, b );

		// make active slot wide enough to accommodate gun pictures
		if ( i == iActiveSlot )
		{
			WEAPON *p = gWR.GetFirstPos(iActiveSlot);
			if ( p )
				iWidth = p->rcActive.Width();
			else
				iWidth = giBucketWidth;
		}
		else
			iWidth = giBucketWidth;

		SPR_DrawAdditive(0, x, y, &gHUD.GetSpriteRect(m_HUD_bucket0 + i));
		
		x += iWidth + 5;
	}


	a = 128; //!!!
	x = gHUD.m_Radar.m_hRadar.rect.right + 10; //!!!;

	// Draw all of the buckets
	for (i = 0; i < MAX_WEAPON_SLOTS; i++)
	{
		y = giBucketHeight + 10;

		// If this is the active slot, draw the bigger pictures,
		// otherwise just draw boxes
		if ( i == iActiveSlot )
		{
			WEAPON *p = gWR.GetFirstPos( i );
			int iWidth = giBucketWidth;
			if ( p )
				iWidth = p->rcActive.Width();

			for ( int iPos = 0; iPos < MAX_WEAPON_POSITIONS; iPos++ )
			{
				p = gWR.GetWeaponSlot( i, iPos );

				if ( !p || !p->iId )
					continue;

			
				// if active, then we must have ammo.
				if ( gWR.HasAmmo(p) )
				{
					DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
					DrawUtils::ScaleColors(r, g, b, 192);
				}
				else
				{
					DrawUtils::UnpackRGB(r,g,b, RGB_REDISH);
					DrawUtils::ScaleColors(r, g, b, 128);
				}


				if ( gpActiveSel == p )
				{
					SPR_Set(p->hActive, r, g, b );
					SPR_DrawAdditive(0, x, y, &p->rcActive);

					SPR_Set(gHUD.GetSprite(m_HUD_selection), r, g, b );
					SPR_DrawAdditive(0, x, y, &gHUD.GetSpriteRect(m_HUD_selection));
				}
				else
				{
					// Draw Weapon if Red if no ammo
					SPR_Set( p->hInactive, r, g, b );
					SPR_DrawAdditive( 0, x, y, &p->rcInactive );
				}

				// Draw Ammo Bar

				DrawAmmoBar(p, x + giABWidth/2, y, giABWidth, giABHeight);
				
				y += p->rcActive.Height() + 5;
			}

			x += iWidth + 5;

		}
		else
		{
			// Draw Row of weapons.

			DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );

			for ( int iPos = 0; iPos < MAX_WEAPON_POSITIONS; iPos++ )
			{
				WEAPON *p = gWR.GetWeaponSlot( i, iPos );
				
				if ( !p || !p->iId )
					continue;

				if ( gWR.HasAmmo(p) )
				{
					DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
					a = 128;
				}
				else
				{
					DrawUtils::UnpackRGB(r,g,b, RGB_REDISH);
					a = 96;
				}

				FillRGBA( x, y, giBucketWidth, giBucketHeight, r, g, b, a );

				y += giBucketHeight + 5;
			}

			x += giBucketWidth + 5;
		}
	}	

	return 1;

}


/*
=================================
	GetSpriteList

Finds and returns the matching 
sprite name 'psz' and resolution 'iRes'
in the given sprite list 'pList'
iCount is the number of items in the pList
=================================
*/
client_sprite_t *GetSpriteList(client_sprite_t *pList, const char *psz, int iRes, int iCount)
{
	if (!pList)
		return NULL;

	int i = iCount;
	client_sprite_t *p = pList;

	while(i--)
	{
		if ((!strcmp(psz, p->szName)) && (p->iRes == iRes))
			return p;
		p++;
	}

	return NULL;
}

/*
=================
SetCrosshair

=================
*/
void CHudAmmo::SetCrosshair(HSPRITE hSpr, wrect_t rect, int r, int g, int b)
{
	m_hStaticSpr = hSpr;
	m_rcStaticRc = rect;
	m_staticRgba.r = r;
	m_staticRgba.g = g;
	m_staticRgba.b = b;
	m_staticRgba.a = 255;
}

void CHudAmmo::HideCrosshair()
{
	m_hStaticSpr = 0;
}


```

`cl_dll/ammo_secondary.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// ammo_secondary.cpp
//
// implementation of CHudAmmoSecondary class
//

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "draw_util.h"

int CHudAmmoSecondary :: Init( void )
{
	HOOK_MESSAGE( gHUD.m_AmmoSecondary, SecAmmoVal );
	HOOK_MESSAGE( gHUD.m_AmmoSecondary, SecAmmoIcon );

	gHUD.AddHudElem(this);
	m_HUD_ammoicon = 0;

	for ( int i = 0; i < MAX_SEC_AMMO_VALUES; i++ )
		m_iAmmoAmounts[i] = -1;  // -1 means don't draw this value

	Reset();

	return 1;
}

void CHudAmmoSecondary :: Reset( void )
{
	m_fFade = 0;
}

int CHudAmmoSecondary :: VidInit( void )
{
	return 1;
}

int CHudAmmoSecondary :: Draw(float flTime)
{
	if ( (gHUD.m_iHideHUDDisplay & ( HIDEHUD_WEAPONS | HIDEHUD_ALL )) )
		return 1;

	// draw secondary ammo icons above normal ammo readout
	int a, x, y, r, g, b, AmmoWidth;
	DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
	a = (int) max( MIN_ALPHA, m_fFade );
	if (m_fFade > 0)
		m_fFade -= (gHUD.m_flTimeDelta * 20);  // slowly lower alpha to fade out icons
	DrawUtils::ScaleColors( r, g, b, a );

	AmmoWidth = gHUD.GetSpriteRect(gHUD.m_HUD_number_0).Width();

	y = ScreenHeight - (gHUD.m_iFontHeight*4);  // this is one font height higher than the weapon ammo values
	x = ScreenWidth - AmmoWidth;

	if ( m_HUD_ammoicon )
	{
		// Draw the ammo icon
		x -= (gHUD.GetSpriteRect(m_HUD_ammoicon).Width());
		y += (gHUD.GetSpriteRect(m_HUD_ammoicon).Height());

		SPR_Set( gHUD.GetSprite(m_HUD_ammoicon), r, g, b );
		SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect(m_HUD_ammoicon) );
	}
	else
	{  // move the cursor by the '0' char instead, since we don't have an icon to work with
		x -= AmmoWidth;
		y += (gHUD.GetSpriteRect(gHUD.m_HUD_number_0).Height());
	}

	// draw the ammo counts, in reverse order, from right to left
	for ( int i = MAX_SEC_AMMO_VALUES-1; i >= 0; i-- )
	{
		if ( m_iAmmoAmounts[i] < 0 )
			continue; // negative ammo amounts imply that they shouldn't be drawn

		// half a char gap between the ammo number and the previous pic
		x -= (AmmoWidth / 2);

		// draw the number, right-aligned
		x -= (DrawUtils::GetNumWidth( m_iAmmoAmounts[i], DHN_DRAWZERO ) * AmmoWidth);
		DrawUtils::DrawHudNumber( x, y, DHN_DRAWZERO, m_iAmmoAmounts[i], r, g, b );

		if ( i != 0 )
		{
			// draw the divider bar
			x -= (AmmoWidth / 2);
			FillRGBA(x, y, (AmmoWidth/10), gHUD.m_iFontHeight, r, g, b, a);
		}
	}

	return 1;
}

// Message handler for Secondary Ammo Value
// accepts one value:
//		string:  sprite name
int CHudAmmoSecondary :: MsgFunc_SecAmmoIcon( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	m_HUD_ammoicon = gHUD.GetSpriteIndex( reader.ReadString() );

	return 1;
}

// Message handler for Secondary Ammo Icon
// Sets an ammo value
// takes two values:
//		byte:  ammo index
//		byte:  ammo value
int CHudAmmoSecondary :: MsgFunc_SecAmmoVal( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int index = reader.ReadByte();
	if ( index < 0 || index >= MAX_SEC_AMMO_VALUES )
		return 1;

	m_iAmmoAmounts[index] = reader.ReadByte();
	m_iFlags |= HUD_DRAW;

	// check to see if there is anything left to draw
	int count = 0;
	for ( int i = 0; i < MAX_SEC_AMMO_VALUES; i++ )
	{
		count += max( 0, m_iAmmoAmounts[i] );
	}

	if ( count == 0 ) 
	{	// the ammo fields are all empty, so turn off this hud area
		m_iFlags &= ~HUD_DRAW;
		return 1;
	}

	// make the icons light up
	m_fFade = 200.0f;

	return 1;
}



```

`cl_dll/ammohistory.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  ammohistory.cpp
//


#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>

#include "ammohistory.h"
#include "draw_util.h"

HistoryResource gHR;

#define AMMO_PICKUP_GAP (gHR.iHistoryGap+5)
#define AMMO_PICKUP_PICK_HEIGHT		(gHUD.m_iFontHeight * 3 + (gHR.iHistoryGap * 2))
#define AMMO_PICKUP_HEIGHT_MAX		(ScreenHeight - 100)

#define MAX_ITEM_NAME	32
int HISTORY_DRAW_TIME = 5;

// keep a list of items
struct ITEM_INFO
{
	char szName[MAX_ITEM_NAME];
	HSPRITE spr;
	wrect_t rect;
};

void HistoryResource :: AddToHistory( int iType, int iId, int iCount )
{
	if ( iType == HISTSLOT_AMMO && !iCount )
		return;  // no amount, so don't add

	if ( (((AMMO_PICKUP_GAP * iCurrentHistorySlot) + AMMO_PICKUP_PICK_HEIGHT) > AMMO_PICKUP_HEIGHT_MAX) || (iCurrentHistorySlot >= MAX_HISTORY) )
	{	// the pic would have to be drawn too high
		// so start from the bottom
		iCurrentHistorySlot = 0;
	}
	
	HIST_ITEM *freeslot = &rgAmmoHistory[iCurrentHistorySlot++];  // default to just writing to the first slot
	HISTORY_DRAW_TIME = gHUD.m_Ammo.m_pHud_DrawHistory_Time->value;

	freeslot->type = iType;
	freeslot->iId = iId;
	freeslot->iCount = iCount;
	freeslot->DisplayTime = gHUD.m_flTime + HISTORY_DRAW_TIME;
}

void HistoryResource :: AddToHistory( int iType, const char *szName, int iCount )
{
	if ( iType != HISTSLOT_ITEM )
		return;

	if ( (((AMMO_PICKUP_GAP * iCurrentHistorySlot) + AMMO_PICKUP_PICK_HEIGHT) > AMMO_PICKUP_HEIGHT_MAX) || (iCurrentHistorySlot >= MAX_HISTORY) )
	{	// the pic would have to be drawn too high
		// so start from the bottom
		iCurrentHistorySlot = 0;
	}

	HIST_ITEM *freeslot = &rgAmmoHistory[iCurrentHistorySlot++];  // default to just writing to the first slot

	// I am really unhappy with all the code in this file
	// I am too, -- a1batross

	int i = gHUD.GetSpriteIndex( szName );
	if ( i == -1 )
		return;  // unknown sprite name, don't add it to history

	freeslot->iId = i;
	freeslot->type = iType;
	freeslot->iCount = iCount;

	HISTORY_DRAW_TIME = gHUD.m_Ammo.m_pHud_DrawHistory_Time->value;
	freeslot->DisplayTime = gHUD.m_flTime + HISTORY_DRAW_TIME;
}


void HistoryResource :: CheckClearHistory( void )
{
	for ( int i = 0; i < MAX_HISTORY; i++ )
	{
		if ( rgAmmoHistory[i].type )
			return;
	}

	iCurrentHistorySlot = 0;
}

//
// Draw Ammo pickup history
//
int HistoryResource :: DrawAmmoHistory( float flTime )
{
	for ( int i = 0; i < MAX_HISTORY; i++ )
	{
		if ( rgAmmoHistory[i].type )
		{
			rgAmmoHistory[i].DisplayTime = min( rgAmmoHistory[i].DisplayTime, gHUD.m_flTime + HISTORY_DRAW_TIME );

			if ( rgAmmoHistory[i].DisplayTime <= flTime )
			{  // pic drawing time has expired
				memset( &rgAmmoHistory[i], 0, sizeof(HIST_ITEM) );
				CheckClearHistory();
			}
			else if ( rgAmmoHistory[i].type == HISTSLOT_AMMO )
			{
				wrect_t rcPic;
				HSPRITE *spr = gWR.GetAmmoPicFromWeapon( rgAmmoHistory[i].iId, rcPic );

				int r, g, b;
				DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
				float scale = (rgAmmoHistory[i].DisplayTime - flTime) * 80;
				DrawUtils::ScaleColors(r, g, b, min(scale, 255) );

				// Draw the pic
				int ypos = ScreenHeight - (AMMO_PICKUP_PICK_HEIGHT + (AMMO_PICKUP_GAP * i));
				int xpos = ScreenWidth - 24;
				if ( spr && *spr )    // weapon isn't loaded yet so just don't draw the pic
				{ // the dll has to make sure it has sent info the weapons you need
					SPR_Set( *spr, r, g, b );
					SPR_DrawAdditive( 0, xpos, ypos, &rcPic );
				}

				// Draw the number
				DrawUtils::DrawHudNumberString( xpos - 10, ypos, xpos - 100, rgAmmoHistory[i].iCount, r, g, b );
			}
			else if ( rgAmmoHistory[i].type == HISTSLOT_WEAP )
			{
				WEAPON *weap = gWR.GetWeapon( rgAmmoHistory[i].iId );

				if ( !weap )
					continue;  // we don't know about the weapon yet, so don't draw anything

				int r, g, b;
				DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );

				if ( !gWR.HasAmmo( weap ) )
					DrawUtils::UnpackRGB(r,g,b, RGB_REDISH);	// if the weapon doesn't have ammo, display it as red

				float scale = (rgAmmoHistory[i].DisplayTime - flTime) * 80;
				DrawUtils::ScaleColors(r, g, b, min(scale, 255) );

				int ypos = ScreenHeight - (AMMO_PICKUP_PICK_HEIGHT + (AMMO_PICKUP_GAP * i));
				int xpos = ScreenWidth - (weap->rcInactive.Width());
				SPR_Set( weap->hInactive, r, g, b );
				SPR_DrawAdditive( 0, xpos, ypos, &weap->rcInactive );
			}
			else if ( rgAmmoHistory[i].type == HISTSLOT_ITEM )
			{
				int r, g, b;

				if ( !rgAmmoHistory[i].iId )
					continue;  // sprite not loaded

				wrect_t rect = gHUD.GetSpriteRect( rgAmmoHistory[i].iId );

				DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
				float scale = (rgAmmoHistory[i].DisplayTime - flTime) * 80;
				DrawUtils::ScaleColors(r, g, b, min(scale, 255) );

				int ypos = ScreenHeight - (AMMO_PICKUP_PICK_HEIGHT + (AMMO_PICKUP_GAP * i));
				int xpos = ScreenWidth - (rect.Width()) - 10;

				SPR_Set( gHUD.GetSprite( rgAmmoHistory[i].iId ), r, g, b );
				SPR_DrawAdditive( 0, xpos, ypos, &rect );
			}
		}
	}


	return 1;
}



```

`cl_dll/ammohistory.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// ammohistory.h
//
#pragma once
// this is the max number of items in each bucket
#define MAX_WEAPON_POSITIONS		22

class WeaponsResource
{
private:
	// Information about weapons & ammo
	WEAPON		rgWeapons[MAX_WEAPONS];	// Weapons Array

	// counts of weapons * ammo
	WEAPON*		rgSlots[MAX_WEAPON_SLOTS+1][MAX_WEAPON_POSITIONS+1];	// The slots currently in use by weapons.  The value is a pointer to the weapon;  if it's NULL, no weapon is there
	int			riAmmo[MAX_AMMO_TYPES];							// count of each ammo type

public:
	void Init( void )
	{
		memset( rgWeapons, 0, sizeof rgWeapons );
		Reset();
	}

	void Reset( void )
	{
		iOldWeaponBits = 0;
		memset( rgSlots, 0, sizeof rgSlots );
		memset( riAmmo, 0, sizeof riAmmo );
	}

///// WEAPON /////
	int			iOldWeaponBits;

	WEAPON *GetWeapon( int iId ) { return &rgWeapons[iId]; }
	void AddWeapon( WEAPON *wp ) 
	{ 
		rgWeapons[ wp->iId ] = *wp;	
		LoadWeaponSprites( &rgWeapons[ wp->iId ] );
	}

	void PickupWeapon( WEAPON *wp )
	{
		rgSlots[ wp->iSlot ][ wp->iSlotPos ] = wp;
	}

	void PickupWeapon( int idx )
	{
		WEAPON *wp = &rgWeapons[ idx ];
		PickupWeapon( wp );
	}

	void DropWeapon( WEAPON *wp )
	{
		rgSlots[ wp->iSlot ][ wp->iSlotPos ] = NULL;
	}

	void DropAllWeapons( void )
	{
		for ( int i = 0; i < MAX_WEAPONS; i++ )
		{
			if ( rgWeapons[i].iId )
				DropWeapon( &rgWeapons[i] );
		}
	}

	WEAPON* GetWeaponSlot( int slot, int pos ) { return rgSlots[slot][pos]; }

	void LoadWeaponSprites( WEAPON* wp );
	void LoadAllWeaponSprites( void );
	WEAPON* GetFirstPos( int iSlot );
	void SelectSlot( int iSlot, int fAdvance, int iDirection );
	WEAPON* GetNextActivePos( int iSlot, int iSlotPos );

	int HasAmmo( WEAPON *p );

///// AMMO /////
	AMMO GetAmmo( int iId ) { return iId; }

	void SetAmmo( int iId, int iCount ) { riAmmo[ iId ] = iCount;	}

	int CountAmmo( int iId );

	HSPRITE* GetAmmoPicFromWeapon( int iAmmoId, wrect_t& rect );
};

extern WeaponsResource gWR;


#define MAX_HISTORY 12
enum {
	HISTSLOT_EMPTY,
	HISTSLOT_AMMO,
	HISTSLOT_WEAP,
	HISTSLOT_ITEM,
};

class HistoryResource
{
private:
	struct HIST_ITEM {
		int type;
		float DisplayTime;  // the time at which this item should be removed from the history
		int iCount;
		int iId;
	};

	HIST_ITEM rgAmmoHistory[MAX_HISTORY];

public:

	void Init( void )
	{
		Reset();
	}

	void Reset( void )
	{
		memset( rgAmmoHistory, 0, sizeof rgAmmoHistory );
	}

	int iHistoryGap;
	int iCurrentHistorySlot;

	void AddToHistory( int iType, int iId, int iCount = 0 );
	void AddToHistory( int iType, const char *szName, int iCount = 0 );

	void CheckClearHistory( void );
	int DrawAmmoHistory( float flTime );
};

extern HistoryResource gHR;




```

`cl_dll/battery.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// battery.cpp
//
// implementation of CHudBattery class
//

#include "hud.h"
#include "parsemsg.h"
#include "cl_util.h"
#include "draw_util.h"

int CHudBattery::Init( void )
{
	m_iBat = 0;
	m_fFade = 0;
	m_iFlags = 0;
	m_enArmorType = Vest;

	HOOK_MESSAGE( gHUD.m_Battery, Battery );
	HOOK_MESSAGE( gHUD.m_Battery, ArmorType );
	gHUD.AddHudElem( this );

	return 1;
}

int CHudBattery::VidInit( void )
{
	m_hEmpty[Vest].SetSpriteByName("suit_empty");
	m_hFull[Vest].SetSpriteByName("suit_full");
	m_hEmpty[VestHelm].SetSpriteByName("suithelmet_empty");
	m_hFull[VestHelm].SetSpriteByName("suithelmet_full");

	m_iHeight = m_hFull[Vest].rect.Height();
	m_fFade = 0;

	return 1;
}


int CHudBattery:: MsgFunc_Battery(const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	m_iFlags |= HUD_DRAW;
	int x = reader.ReadShort();

	if( x != m_iBat )
	{
		m_fFade = FADE_TIME;
		m_iBat = x;
		if( m_iBat < 0 )
			m_enArmorType = Vest;
	}

	return 1;
}

int CHudBattery::Draw( float flTime )
{
	if( gHUD.m_iHideHUDDisplay & HIDEHUD_HEALTH )
		return 1;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return 1;

	int r, g, b, x, y, a;
	wrect_t rc;

	rc = m_hEmpty[m_enArmorType].rect;

	// battery can go from 0 to 100 so * 0.01 goes from 0 to 1
	rc.top += m_iHeight * ((float)( 100 - ( min( 100, m_iBat ))) * 0.01f );

	DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );

	// Has health changed? Flash the health #
	if( m_fFade )
	{
		if( m_fFade > FADE_TIME )
			m_fFade = FADE_TIME;

		m_fFade -= (gHUD.m_flTimeDelta * 20);

		if( m_fFade <= 0 )
		{
			m_fFade = 0;
		}

		// Fade the health number back to dim
		a = MIN_ALPHA +  (m_fFade / FADE_TIME) * 128;
	}
	else
	{
		a = MIN_ALPHA;
	}

	DrawUtils::ScaleColors( r, g, b, a );
	
	y = ScreenHeight - gHUD.m_iFontHeight - gHUD.m_iFontHeight / 2;
	x = ScreenWidth / 5;

	// make sure we have the right sprite handles
	SPR_Set( m_hFull[m_enArmorType].spr, r, g, b );
	SPR_DrawAdditive( 0, x, y, &m_hFull[m_enArmorType].rect );

	if( rc.bottom > rc.top )
	{
		SPR_Set( m_hEmpty[m_enArmorType].spr, r, g, b );
		SPR_DrawAdditive( 0, x, y + (rc.top - m_hEmpty[m_enArmorType].rect.top), &rc );
	}

	x += (m_hEmpty[m_enArmorType].rect.Width());
	x = DrawUtils::DrawHudNumber( x, y, DHN_3DIGITS|DHN_DRAWZERO, m_iBat, r, g, b );

	return 1;
}

int CHudBattery::MsgFunc_ArmorType(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	m_enArmorType = (armortype_t)reader.ReadByte();

	return 1;
}

```

`cl_dll/cdll_int.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cdll_int.c
//
// this implementation handles the linking of the engine to the DLL
//

#include "hud.h"
#include "cl_util.h"
#include "netadr.h"
#include "pmtrace.h"

#include "pm_shared.h"

#include <string.h>
#include "interface.h" // not used here
#include "render_api.h"
#include "mobility_int.h"
#include "vgui_parser.h"

cl_enginefunc_t		gEngfuncs  = { };
render_api_t		gRenderAPI = { };
mobile_engfuncs_t	gMobileAPI = { };
CHud gHUD;
int g_iXash = 0; // indicates a buildnum
int g_iMobileAPIVersion = 0;

void InitInput (void);
void Game_HookEvents( void );
void IN_Commands( void );
void Input_Shutdown (void);

/*
========================== 
    Initialize

Called when the DLL is first loaded.
==========================
*/
int DLLEXPORT Initialize( cl_enginefunc_t *pEnginefuncs, int iVersion )
{
	if (iVersion != CLDLL_INTERFACE_VERSION)
		return 0;

	gEngfuncs = *pEnginefuncs;

	sscanf( CVAR_GET_STRING( "host_ver" ), "%d", &g_iXash );

	Game_HookEvents();

	return 1;
}


/*
=============
HUD_Shutdown

=============
*/
void DLLEXPORT HUD_Shutdown( void )
{
	gHUD.Shutdown();
	Input_Shutdown();
	Localize_Free();
}


/*
================================
HUD_GetHullBounds

  Engine calls this to enumerate player collision hulls, for prediction.  Return 0 if the hullnumber doesn't exist.
================================
*/
int DLLEXPORT HUD_GetHullBounds( int hullnumber, float *mins, float *maxs )
{
	int iret = 0;

	switch ( hullnumber )
	{
	case 0:				// Normal player
		Vector(-16, -16, -36).CopyToArray(mins);
		Vector(16, 16, 36).CopyToArray(maxs);
		iret = 1;
		break;
	case 1:				// Crouched player
		Vector(-16, -16, -18).CopyToArray(mins);
		Vector(16, 16, 18).CopyToArray(maxs);
		iret = 1;
		break;
	case 2:				// Point based hull
		Vector(0, 0, 0).CopyToArray(mins);
		Vector(0, 0, 0).CopyToArray(maxs);
		iret = 1;
		break;
	}

	return iret;
}

/*
================================
HUD_ConnectionlessPacket

 Return 1 if the packet is valid.  Set response_buffer_size if you want to send a response packet.  Incoming, it holds the max
  size of the response_buffer, so you must zero it out if you choose not to respond.
================================
*/
int	DLLEXPORT HUD_ConnectionlessPacket( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size )
{
	// Parse stuff from args
	// int max_buffer_size = *response_buffer_size;

	// Zero it out since we aren't going to respond.
	// If we wanted to response, we'd write data into response_buffer
	*response_buffer_size = 0;

	// Since we don't listen for anything here, just respond that it's a bogus message
	// If we didn't reject the message, we'd return 1 for success instead.
	return 0;
}

void DLLEXPORT HUD_PlayerMoveInit( struct playermove_s *ppmove )
{
	PM_Init( ppmove );
}

char DLLEXPORT HUD_PlayerMoveTexture( char *name )
{
	return PM_FindTextureType( name );
}

void DLLEXPORT HUD_PlayerMove( struct playermove_s *ppmove, int server )
{
	PM_Move( ppmove, server );
}

#ifdef _CS16CLIENT_ENABLE_GSRC_SUPPORT
/*
=================
HUD_GetRect

VGui stub
=================
*/
int *HUD_GetRect( void )
{
	static int extent[4];

	extent[0] = gEngfuncs.GetWindowCenterX() - ScreenWidth / 2;
	extent[1] = gEngfuncs.GetWindowCenterY() - ScreenHeight / 2;
	extent[2] = gEngfuncs.GetWindowCenterX() + ScreenWidth / 2;
	extent[3] = gEngfuncs.GetWindowCenterY() + ScreenHeight / 2;

	return extent;
}
#endif

/*
==========================
	HUD_VidInit

Called when the game initializes
and whenever the vid_mode is changed
so the HUD can reinitialize itself.
==========================
*/

bool isLoaded = false;

int DLLEXPORT HUD_VidInit( void )
{
	gHUD.VidInit();

	isLoaded = true;

	//VGui_Startup();

	return 1;
}

/*
==========================
	HUD_Init

Called whenever the client connects
to a server.  Reinitializes all 
the hud variables.
==========================
*/

void DLLEXPORT HUD_Init( void )
{
	InitInput();
	gHUD.Init();
	//Scheme_Init();
}


/*
==========================
	HUD_Redraw

called every screen frame to
redraw the HUD.
===========================
*/

int DLLEXPORT HUD_Redraw( float time, int intermission )
{
	gHUD.Redraw( time, intermission );

	return 1;
}


/*
==========================
	HUD_UpdateClientData

called every time shared client
dll/engine data gets changed,
and gives the cdll a chance
to modify the data.

returns 1 if anything has been changed, 0 otherwise.
==========================
*/

int DLLEXPORT HUD_UpdateClientData(client_data_t *pcldata, float flTime )
{
	IN_Commands();

	return gHUD.UpdateClientData(pcldata, flTime );
}

/*
==========================
	HUD_Reset

Called at start and end of demos to restore to "non"HUD state.
==========================
*/

void DLLEXPORT HUD_Reset( void )
{
	gHUD.VidInit();
}

/*
==========================
HUD_Frame

Called by engine every frame that client .dll is loaded
==========================
*/

void DLLEXPORT HUD_Frame( double time )
{
#ifdef _CS16CLIENT_ENABLE_GSRC_SUPPORT
	gEngfuncs.VGui_ViewportPaintBackground(HUD_GetRect());
#endif

	GetClientVoice()->Frame( time );
}


/*
==========================
HUD_VoiceStatus

Called when a player starts or stops talking.
==========================
*/

void DLLEXPORT HUD_VoiceStatus(int entindex, qboolean bTalking)
{
	// gHUD.m_Radio.Voice( entindex, bTalking );

	if ( entindex >= 0 && entindex < gEngfuncs.GetMaxClients() )
	{
		if ( bTalking )
		{
			g_PlayerExtraInfo[entindex].radarflashtime = gHUD.m_flTime;
			g_PlayerExtraInfo[entindex].radarflashes = 99999;
		}
		else
		{
			g_PlayerExtraInfo[entindex].radarflashtime = -1.0f;
			g_PlayerExtraInfo[entindex].radarflashes = 0;
		}
	}

	GetClientVoice()->UpdateSpeakerStatus( entindex, bTalking );
}

/*
==========================
HUD_DirectorEvent

Called when a director event message was received
==========================
*/

void DLLEXPORT HUD_DirectorMessage( int iSize, void *pbuf )
{
	 gHUD.m_Spectator.DirectorMessage( iSize, pbuf );
}

/*
==========================
HUD_GetRenderInterface

Called when Xash3D sends render api to us
==========================
*/

int DLLEXPORT HUD_GetRenderInterface( int version, render_api_t *renderfuncs, render_interface_t *callback )
{
	if( version != CL_RENDER_INTERFACE_VERSION )
		return false;

	gRenderAPI = *renderfuncs;

	// we didn't send callbacks to engine, because we don't use it
	// *callback = renderInterface;

	// we have here a Host_Error, so check Xash for version
	if( g_iXash < MIN_XASH_VERSION )
	{
		gRenderAPI.Host_Error("Xash3D version check failed!\nPlease update your Xash3D!\n");
	}

	return true;
}

/*
========================
HUD_MobilityInterface
========================
*/
int DLLEXPORT HUD_MobilityInterface( mobile_engfuncs_t *mobileapi )
{
	if( mobileapi->version != MOBILITY_API_VERSION )
	{
		gEngfuncs.Con_Printf("Client Error: Mobile API version mismatch. Got: %i, want: %i\n",
			mobileapi->version, MOBILITY_API_VERSION);

		gRenderAPI.Host_Error("Xash3D Android version check failed!\nPlease update your Xash3D Android!\n");
		return 1;
	}

	g_iMobileAPIVersion = MOBILITY_API_VERSION;
	gMobileAPI = *mobileapi;

#define TOUCH_ADDDEFAULT (*gMobileAPI.pfnTouchAddDefaultButton)

	gMobileAPI.pfnTouchResetDefaultButtons();
	unsigned char color[] = { 255, 255, 255, 150 };
	TOUCH_ADDDEFAULT( "move", "", "_move", 0.000000, 0.444444, 0.460000, 0.995556, color, 0, 0.673353, 0 );
	TOUCH_ADDDEFAULT( "look", "", "_look", 0.470000, 0.248889, 1.000000, 0.604444, color, 0, 0.377044, 0 );
	TOUCH_ADDDEFAULT( "joy", "touch/gfx/joy", "_joy", 0.290000, 0.187234, 0.410000, 0.400745, color, 0, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "dpad", "touch/gfx/dpad", "_dpad", 0.170000, 0.187234, 0.290000, 0.400745, color, 0, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "invprev", "touch/gfx/left", "invprev", 0.000000, 0.323404, 0.080000, 0.465745, color, 2, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "invnext", "touch/gfx/right", "invnext", 0.080000, 0.323404, 0.160000, 0.465745, color, 2, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "reload", "touch/gfx/reload", "+reload", 0.680000, 0.680851, 0.760000, 0.823192, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "use", "touch/gfx/use", "+use", 0.700000, 0.544681, 0.780000, 0.687022, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "spraypaint", "touch/gfx/spraypaint", "impulse 201", 0.700000, 0.817021, 0.780000, 0.959362, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "drop", "touch/gfx/drop", "drop", 0.780000, 0.868085, 0.860000, 1.010426, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "jump", "touch/gfx/jump", "+jump", 0.880000, 0.800000, 0.980000, 0.977926, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "attack", "touch/gfx/attack", "+attack", 0.760000, 0.612766, 0.910000, 0.879655, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "attack2", "touch/gfx/attack2", "+attack2", 0.900000, 0.578723, 1.000000, 0.756649, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "w5", "touch/gfx/w_c4", "slot5", 0.760000, 0.102128, 0.840000, 0.244469, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "w1", "touch/gfx/w_rifle", "slot1", 0.780000, 0.238298, 0.860000, 0.380639, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "w2", "touch/gfx/w_pistol", "slot2", 0.840000, 0.136170, 0.920000, 0.278511, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "w4", "touch/gfx/w_grenade", "slot4", 0.880000, 0.017021, 0.960000, 0.159362, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "w3", "touch/gfx/w_knife", "slot3", 0.920000, 0.136170, 1.000000, 0.278511, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "flight", "touch/gfx/flaghtlight", "impulse 100", 0.280000, 0.851064, 0.360000, 0.993405, color, 2, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "light", "touch/gfx/light", "toggle_light", 0.360000, 0.851064, 0.440000, 0.993405, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "buy", "touch/gfx/buy", "buy", 0.440000, 0.851064, 0.520000, 0.993405, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "score", "touch/gfx/score", "scoreboard", 0.520000, 0.851064, 0.600000, 0.993405, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "nightvision", "touch/gfx/nightvision", "nightvision;toggle_plusminus", 0.360000, 0.714894, 0.440000, 0.857235, color, 2, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "minus_nvg", "touch/gfx/minus", "nvgadjustdown", 0.340000, 0.629787, 0.400000, 0.736543, color, 2, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "plus_nvg", "touch/gfx/plus", "nvgadjustup", 0.400000, 0.629787, 0.460000, 0.736543, color, 2, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "numbers", "touch_default/show_weapons", "exec touch_default/numbers.cfg", 0.440000, 0.714894, 0.520000, 0.857235, color, 2, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "duck", "touch/gfx/duck", "+duck", 0.000000, 0.817021, 0.100000, 0.994947, color, 2, 1.000000, 512 );
	TOUCH_ADDDEFAULT( "duck_sw", "touch/gfx/duck", "crouchtoggle", 0.100000, 0.817021, 0.200000, 0.994947, color, 2, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "change_team", "touch/gfx/change_team", "chooseteam", 0.540000, 0.000000, 0.620000, 0.142341, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "exit", "touch/gfx/exit", "cancelselect", 0.460000, 0.000000, 0.540000, 0.142341, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "touch_edit", "touch/gfx/settings", "touch_enableedit", 0.380000, 0.000000, 0.460000, 0.142341, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "cmd", "touch/gfx/cmdmenu", "exec touch/cmd/cmd", 0.100000, 0.248889, 0.200000, 0.426815, color, 2, 1.000000, 1 );
	TOUCH_ADDDEFAULT( "radio", "touch/gfx/radio", "showvguimenu 38", 0.000000, 0.248889, 0.100000, 0.426815, color, 2, 1.000000, 0 );
	TOUCH_ADDDEFAULT( "walk", "touch/gfx/walk", "+speed", 0.000000, 0.640000, 0.100000, 0.817926, color, 2, 1.000000, 0 );

	return 0;
}

extern "C" void DLLEXPORT HUD_ChatInputPosition( int *x, int *y )
{
}

extern "C" int DLLEXPORT HUD_GetPlayerTeam(int iplayer)
{
	// original seems to return team_id, but I'm not sure it's even set somewhere
	if ( iplayer <= MAX_PLAYERS )
		return g_PlayerExtraInfo[iplayer].teamnumber;
	return 0;
}

#include "APIProxy.h"

cldll_func_dst_t *g_pcldstAddrs;

extern "C" void DLLEXPORT F(void *pv)
{
	cldll_func_t *pcldll_func = (cldll_func_t *)pv;

	// Hack!
	g_pcldstAddrs = ((cldll_func_dst_t *)pcldll_func->pHudVidInitFunc);

	cldll_func_t cldll_func =
	{
	Initialize,
	HUD_Init,
	HUD_VidInit,
	HUD_Redraw,
	HUD_UpdateClientData,
	HUD_Reset,
	HUD_PlayerMove,
	HUD_PlayerMoveInit,
	HUD_PlayerMoveTexture,
	IN_ActivateMouse,
	IN_DeactivateMouse,
	IN_MouseEvent,
	IN_ClearStates,
	IN_Accumulate,
	CL_CreateMove,
	CL_IsThirdPerson,
	CL_CameraOffset,
	KB_Find,
	CAM_Think,
	V_CalcRefdef,
	HUD_AddEntity,
	HUD_CreateEntities,
	HUD_DrawNormalTriangles,
	HUD_DrawTransparentTriangles,
	HUD_StudioEvent,
	HUD_PostRunCmd,
	HUD_Shutdown,
	HUD_TxferLocalOverrides,
	HUD_ProcessPlayerState,
	HUD_TxferPredictionData,
	Demo_ReadBuffer,
	HUD_ConnectionlessPacket,
	HUD_GetHullBounds,
	HUD_Frame,
	HUD_Key_Event,
	HUD_TempEntUpdate,
	HUD_GetUserEntity,
	HUD_VoiceStatus,
	HUD_DirectorMessage,
	HUD_GetStudioModelInterface,
	HUD_ChatInputPosition,
	HUD_GetPlayerTeam,
	NULL
	};

	*pcldll_func = cldll_func;
}

#include "cl_dll/IGameClientExports.h"

//-----------------------------------------------------------------------------
// Purpose: Exports functions that are used by the gameUI for UI dialogs
//-----------------------------------------------------------------------------
class CClientExports : public IGameClientExports
{
public:
	// returns the name of the server the user is connected to, if any
	virtual const char *GetServerHostName()
	{
		return gHUD.m_szServerName;
	}

	// ingame voice manipulation
	virtual bool IsPlayerGameVoiceMuted( int playerIndex )
	{
		if ( GetClientVoice() )
			return GetClientVoice()->IsPlayerBlocked( playerIndex );

		return false;
	}

	virtual void MutePlayerGameVoice( int playerIndex )
	{
		if ( GetClientVoice() )
		{
			GetClientVoice()->SetPlayerBlockedState( playerIndex, true );
		}
	}

	virtual void UnmutePlayerGameVoice( int playerIndex )
	{
		if ( GetClientVoice() )
		{
			GetClientVoice()->SetPlayerBlockedState( playerIndex, false );
		}
	}
};

EXPOSE_SINGLE_INTERFACE(CClientExports, IGameClientExports, GAMECLIENTEXPORTS_INTERFACE_VERSION)


```

`cl_dll/cl_dll.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="cl_dll" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102

CFG=cl_dll - Win32 Release
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "cl_dll.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "cl_dll.mak" CFG="cl_dll - Win32 Release"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "cl_dll - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE "cl_dll - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
MTL=midl.exe
RSC=rc.exe

!IF  "$(CFG)" == "cl_dll - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir ".\Release"
# PROP BASE Intermediate_Dir ".\Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir ".\Release"
# PROP Intermediate_Dir ".\Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /c
# ADD CPP /nologo /MT /W3 /GX /Zi /O2 /I "..\utils\vgui\include" /I "..\engine" /I "..\common" /I "..\pm_shared" /I "..\dlls" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "CLIENT_DLL" /D "CLIENT_WEAPONS" /YX /FD /c
# ADD BASE MTL /nologo /D "NDEBUG" /win32
# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x409 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib winmm.lib ../utils/vgui/lib/win32_vc6/vgui.lib wsock32.lib /nologo /subsystem:windows /dll /map /machine:I386 /out:".\Release\client.dll"

!ELSEIF  "$(CFG)" == "cl_dll - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir ".\Debug"
# PROP BASE Intermediate_Dir ".\Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir ".\Debug"
# PROP Intermediate_Dir ".\Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /c
# ADD CPP /nologo /G5 /MTd /W3 /Gm /GR /GX /ZI /Od /I "..\dlls" /I "..\common" /I "..\pm_shared" /I "..\engine" /I "..\utils\vgui\include" /I "..\game_shared" /D "_DEBUG" /D "_MBCS" /D "WIN32" /D "_WINDOWS" /D "CLIENT_DLL" /D "CLIENT_WEAPONS" /FR /YX /FD /c
# ADD BASE MTL /nologo /D "_DEBUG" /win32
# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x409 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386
# ADD LINK32 oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib winmm.lib ../utils/vgui/lib/win32_vc6/vgui.lib wsock32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:".\Debug\client.dll"

!ENDIF 

# Begin Target

# Name "cl_dll - Win32 Release"
# Name "cl_dll - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat;for;f90"
# Begin Group "hl"

# PROP Default_Filter "*.CPP"
# Begin Source File

SOURCE=..\dlls\crossbow.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\crowbar.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\egon.cpp
# End Source File
# Begin Source File

SOURCE=.\ev_hldm.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\gauss.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\handgrenade.cpp
# End Source File
# Begin Source File

SOURCE=.\hl\hl_baseentity.cpp
# End Source File
# Begin Source File

SOURCE=.\hl\hl_events.cpp
# End Source File
# Begin Source File

SOURCE=.\hl\hl_objects.cpp
# End Source File
# Begin Source File

SOURCE=.\hl\hl_weapons.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\wpn_shared\hl_wpn_glock.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\hornetgun.cpp
# End Source File
# Begin Source File

SOURCE=..\common\interface.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\mp5.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\python.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\rpg.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\satchel.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\shotgun.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\squeakgrenade.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\tripmine.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_scrollbar2.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_slider2.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\voice_banmgr.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\voice_status.cpp
# End Source File
# End Group
# Begin Source File

SOURCE=.\ammo.cpp
# End Source File
# Begin Source File

SOURCE=.\ammo_secondary.cpp
# End Source File
# Begin Source File

SOURCE=.\ammohistory.cpp
# End Source File
# Begin Source File

SOURCE=.\battery.cpp
# End Source File
# Begin Source File

SOURCE=.\cdll_int.cpp
# End Source File
# Begin Source File

SOURCE=.\com_weapons.cpp
# End Source File
# Begin Source File

SOURCE=.\death.cpp
# End Source File
# Begin Source File

SOURCE=.\demo.cpp
# End Source File
# Begin Source File

SOURCE=.\entity.cpp
# End Source File
# Begin Source File

SOURCE=.\ev_common.cpp
# End Source File
# Begin Source File

SOURCE=.\events.cpp
# End Source File
# Begin Source File

SOURCE=.\flashlight.cpp
# End Source File
# Begin Source File

SOURCE=.\GameStudioModelRenderer.cpp
# End Source File
# Begin Source File

SOURCE=.\geiger.cpp
# End Source File
# Begin Source File

SOURCE=.\health.cpp
# End Source File
# Begin Source File

SOURCE=.\hud.cpp
# End Source File
# Begin Source File

SOURCE=.\hud_msg.cpp
# End Source File
# Begin Source File

SOURCE=.\hud_redraw.cpp
# End Source File
# Begin Source File

SOURCE=.\hud_servers.cpp
# End Source File
# Begin Source File

SOURCE=.\hud_spectator.cpp
# End Source File
# Begin Source File

SOURCE=.\hud_update.cpp
# End Source File
# Begin Source File

SOURCE=.\in_camera.cpp
# End Source File
# Begin Source File

SOURCE=.\input.cpp
# End Source File
# Begin Source File

SOURCE=.\inputw32.cpp
# End Source File
# Begin Source File

SOURCE=.\menu.cpp
# End Source File
# Begin Source File

SOURCE=.\message.cpp
# End Source File
# Begin Source File

SOURCE=.\overview.cpp
# PROP Exclude_From_Build 1
# End Source File
# Begin Source File

SOURCE=.\parsemsg.cpp
# End Source File
# Begin Source File

SOURCE=.\parsemsg.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_debug.c
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_math.c
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_shared.c
# End Source File
# Begin Source File

SOURCE=.\saytext.cpp
# End Source File
# Begin Source File

SOURCE=.\status_icons.cpp
# End Source File
# Begin Source File

SOURCE=.\statusbar.cpp
# End Source File
# Begin Source File

SOURCE=.\studio_util.cpp
# End Source File
# Begin Source File

SOURCE=.\StudioModelRenderer.cpp
# End Source File
# Begin Source File

SOURCE=.\text_message.cpp
# End Source File
# Begin Source File

SOURCE=.\train.cpp
# End Source File
# Begin Source File

SOURCE=.\tri.cpp
# End Source File
# Begin Source File

SOURCE=.\util.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_checkbutton2.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_ClassMenu.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_ConsolePanel.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_ControlConfigPanel.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_CustomObjects.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_grid.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_helpers.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_int.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_listbox.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_loadtga.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_MOTDWindow.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_SchemeManager.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_ScorePanel.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_ServerBrowser.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_SpectatorPanel.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_TeamFortressViewport.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_teammenu.cpp
# End Source File
# Begin Source File

SOURCE=.\view.cpp
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl;fi;fd"
# Begin Source File

SOURCE=.\ammo.h
# End Source File
# Begin Source File

SOURCE=.\ammohistory.h
# End Source File
# Begin Source File

SOURCE=.\camera.h
# End Source File
# Begin Source File

SOURCE=.\cl_dll.h
# End Source File
# Begin Source File

SOURCE=.\com_weapons.h
# End Source File
# Begin Source File

SOURCE=.\demo.h
# End Source File
# Begin Source File

SOURCE=.\ev_hldm.h
# End Source File
# Begin Source File

SOURCE=.\eventscripts.h
# End Source File
# Begin Source File

SOURCE=.\GameStudioModelRenderer.h
# End Source File
# Begin Source File

SOURCE=.\health.h
# End Source File
# Begin Source File

SOURCE=.\hud.h
# End Source File
# Begin Source File

SOURCE=.\hud_iface.h
# End Source File
# Begin Source File

SOURCE=.\hud_servers.h
# End Source File
# Begin Source File

SOURCE=.\hud_servers_priv.h
# End Source File
# Begin Source File

SOURCE=.\hud_spectator.h
# End Source File
# Begin Source File

SOURCE=.\in_defs.h
# End Source File
# Begin Source File

SOURCE=..\common\itrackeruser.h
# End Source File
# Begin Source File

SOURCE=.\kbutton.h
# End Source File
# Begin Source File

SOURCE=.\overview.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_debug.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_defs.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_info.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_materials.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_movevars.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_shared.h
# End Source File
# Begin Source File

SOURCE=.\studio_util.h
# End Source File
# Begin Source File

SOURCE=.\StudioModelRenderer.h
# End Source File
# Begin Source File

SOURCE=.\util.h
# End Source File
# Begin Source File

SOURCE=.\util_vector.h
# End Source File
# Begin Source File

SOURCE=.\vgui_ConsolePanel.h
# End Source File
# Begin Source File

SOURCE=.\vgui_ControlConfigPanel.h
# End Source File
# Begin Source File

SOURCE=.\vgui_int.h
# End Source File
# Begin Source File

SOURCE=.\vgui_SchemeManager.h
# End Source File
# Begin Source File

SOURCE=.\vgui_ScorePanel.h
# End Source File
# Begin Source File

SOURCE=.\vgui_ServerBrowser.h
# End Source File
# Begin Source File

SOURCE=.\vgui_SpectatorPanel.h
# End Source File
# Begin Source File

SOURCE=.\vgui_TeamFortressViewport.h
# End Source File
# Begin Source File

SOURCE=.\view.h
# End Source File
# Begin Source File

SOURCE=..\game_shared\voice_banmgr.h
# End Source File
# Begin Source File

SOURCE=..\game_shared\voice_status.h
# End Source File
# Begin Source File

SOURCE=..\game_shared\voice_vgui_tweakdlg.h
# End Source File
# Begin Source File

SOURCE=.\wrect.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`cl_dll/cl_util.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// cl_util.h
//
#pragma once
#include "cvardef.h"
#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

extern cvar_t *hud_textmode;

#ifdef _MSC_VER
#pragma warning(disable : 4244) // 'argument': conversion from 'float' to 'int', possible loss of data
#pragma warning(disable : 4101) // unreferenced local variable
#endif

// Macros to hook function calls into the HUD object
#define HOOK_MESSAGE_FUNC(name, func) gEngfuncs.pfnHookUserMsg(name, [](const char *pszName, int iSize, void *pbuf) \
{\
	return func(pszName, iSize, pbuf);\
})
#define HOOK_MESSAGE(obj, name) HOOK_MESSAGE_FUNC( #name, obj.MsgFunc_##name )

#define HOOK_COMMAND_FUNC(str, func, ...) gEngfuncs.pfnAddCommand( str, [](void) { func(__VA_ARGS__); })
#define HOOK_COMMAND(obj, str, func) HOOK_COMMAND_FUNC( str, obj.UserCmd_##func, )

inline float CVAR_GET_FLOAT( const char *x ) {	return gEngfuncs.pfnGetCvarFloat( (char*)x ); }
inline char* CVAR_GET_STRING( const char *x ) {	return gEngfuncs.pfnGetCvarString( (char*)x ); }
inline struct cvar_s *CVAR_CREATE( const char *cv, const char *val, const int flags ) {	return gEngfuncs.pfnRegisterVariable( (char*)cv, (char*)val, flags ); }

#define SPR_Load (*gEngfuncs.pfnSPR_Load)
#define SPR_Set (*gEngfuncs.pfnSPR_Set)
#define SPR_Frames (*gEngfuncs.pfnSPR_Frames)
#define SPR_GetList (*gEngfuncs.pfnSPR_GetList)

// SPR_Draw  draws a the current sprite as solid
#define SPR_Draw (*gEngfuncs.pfnSPR_Draw)
// SPR_DrawHoles  draws the current sprites,  with color index255 not drawn (transparent)
#define SPR_DrawHoles (*gEngfuncs.pfnSPR_DrawHoles)
// SPR_DrawAdditive  adds the sprites RGB values to the background  (additive transulency)
#define SPR_DrawAdditive (*gEngfuncs.pfnSPR_DrawAdditive)

// SPR_EnableScissor  sets a clipping rect for HUD sprites.  (0,0) is the top-left hand corner of the screen.
#define SPR_EnableScissor (*gEngfuncs.pfnSPR_EnableScissor)
// SPR_DisableScissor  disables the clipping rect
#define SPR_DisableScissor (*gEngfuncs.pfnSPR_DisableScissor)
//
#define FillRGBA (*gEngfuncs.pfnFillRGBA)
#define FillRGBABlend (*gEngfuncs.pfnFillRGBABlend)


// ScreenHeight returns the height of the screen, in pixels
#define ScreenHeight (gHUD.m_scrinfo.iHeight)
// ScreenWidth returns the width of the screen, in pixels
#define ScreenWidth (gHUD.m_scrinfo.iWidth)

#define TrueHeight (gHUD.m_truescrinfo.iHeight)
#define TrueWidth (gHUD.m_truescrinfo.iWidth)

// Use this to set any co-ords in 640x480 space
#define XRES(x)		((int)(float(x)  * ((float)ScreenWidth / 640.0f) + 0.5f))
#define YRES(y)		((int)(float(y)  * ((float)ScreenHeight / 480.0f) + 0.5f))

// use this to project world coordinates to screen coordinates
#define XPROJECT(x)	( (1.0f+(x))*ScreenWidth*0.5f )
#define YPROJECT(y) ( (1.0f-(y))*ScreenHeight*0.5f )

#define GetScreenInfo (*gEngfuncs.pfnGetScreenInfo)
#define ServerCmd (*gEngfuncs.pfnServerCmd)
#define ClientCmd (*gEngfuncs.pfnClientCmd)
#define FilteredClientCmd (*gEngfuncs.pfnFilteredClientCmd)
#define AngleVectors (*gEngfuncs.pfnAngleVectors)
#define Com_RandomLong (*gEngfuncs.pfnRandomLong)
#define Com_RandomFloat (*gEngfuncs.pfnRandomFloat)

extern float color[3]; // hud.cpp


// Gets the height & width of a sprite,  at the specified frame
inline int SPR_Height( HSPRITE x, int f = 0 )
{
	return gEngfuncs.pfnSPR_Height(x, f);
}
inline int SPR_Width( HSPRITE x, int f = 0 )
{
	return gEngfuncs.pfnSPR_Width(x, f);
}

inline client_textmessage_t *TextMessageGet( const char *pName )
{
	return gEngfuncs.pfnTextMessageGet( pName );
}

inline void ConsolePrint( const char *string )
{
	gEngfuncs.pfnConsolePrint( string );
}

inline void CenterPrint( const char *string )
{
	gEngfuncs.pfnCenterPrint( string );
}

// returns the players name of entity no.
#define GetPlayerInfo (*gEngfuncs.pfnGetPlayerInfo)

// sound functions
inline void PlaySound( const char *szSound, float vol ) { gEngfuncs.pfnPlaySoundByName( szSound, vol ); }
inline void PlaySound( int iSound, float vol ) { gEngfuncs.pfnPlaySoundByIndex( iSound, vol ); }

#define max(a, b)  (((a) > (b)) ? (a) : (b))
#define min(a, b)  (((a) < (b)) ? (a) : (b))
#if !defined(__APPLE__) && !defined(_WIN32)
#define fabs(x)	   ((x) > 0 ? (x) : 0 - (x))
#endif
#define DotProduct(x,y) ((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
#define VectorSubtract(a,b,c) {(c)[0]=(a)[0]-(b)[0];(c)[1]=(a)[1]-(b)[1];(c)[2]=(a)[2]-(b)[2];}
#define VectorAdd(a,b,c) {(c)[0]=(a)[0]+(b)[0];(c)[1]=(a)[1]+(b)[1];(c)[2]=(a)[2]+(b)[2];}
#define VectorCopy(a,b) {(b)[0]=(a)[0];(b)[1]=(a)[1];(b)[2]=(a)[2];}
inline void VectorClear(float *a) { a[0]=0.0;a[1]=0.0;a[2]=0.0;}
#define DotProduct(x,y) ((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
#define VectorLength(a) ( sqrt( DotProduct( a, a )))
#define VectorMA(a, scale, b, c) ((c)[0] = (a)[0] + (scale) * (b)[0],(c)[1] = (a)[1] + (scale) * (b)[1],(c)[2] = (a)[2] + (scale) * (b)[2])
#define VectorScale(in, scale, out) ((out)[0] = (in)[0] * (scale),(out)[1] = (in)[1] * (scale),(out)[2] = (in)[2] * (scale))
float VectorNormalize (float *v);
#define VectorInverse(x) ((x)[0] = -(x)[0], (x)[1] = -(x)[1], (x)[2] = -(x)[2])

extern float vec3_origin[3];

#ifdef _MSC_VER
// disable 'possible loss of data converting float to int' warning message
#pragma warning( disable: 4244 )
// disable 'truncation from 'const double' to 'float' warning message
#pragma warning( disable: 4305 )
#endif

float *GetClientColor( int clientIndex );
inline HSPRITE LoadSprite(const char *pszName)
{
	char sz[256];
	snprintf(sz, 256, pszName, 640);

	return SPR_Load(sz);
}

extern vec3_t g_ColorRed, g_ColorBlue, g_ColorYellow, g_ColorGrey, g_ColorGreen;

inline void GetTeamColor( int &r, int &g, int &b, int teamIndex )
{
	r = 255;
	g = 255;
	b = 255;
	switch( teamIndex )
	{
	case TEAM_TERRORIST:
		r *= g_ColorRed[0];
		g *= g_ColorRed[1];
		b *= g_ColorRed[2];
		break;
	case TEAM_CT:
		r *= g_ColorBlue[0];
		g *= g_ColorBlue[1];
		b *= g_ColorBlue[2];
		break;
	case TEAM_SPECTATOR:
	case TEAM_UNASSIGNED:
		r *= g_ColorYellow[0];
		g *= g_ColorYellow[1];
		b *= g_ColorYellow[2];
		break;
	default:
		r *= g_ColorGrey[0];
		g *= g_ColorGrey[1];
		b *= g_ColorGrey[2];
		break;
	}
}

#define bound( min, num, max ) ((num) >= (min) ? ((num) < (max) ? (num) : (max)) : (min))
#define RAD2DEG( x )	((float)(x) * (float)(180.f / M_PI))
#define DEG2RAD( x )	((float)(x) * (float)(M_PI / 180.f))

enum
{
	GAME_CSTRIKE = 0, // 1.6
	GAME_CZERO = 1,   // czero
	GAME_CZERODS = 2  // ritual czero
};

```

`cl_dll/com_weapons.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Com_Weapons.cpp
// Shared weapons common/shared functions
#include <stdarg.h>
#include "hud.h"
#include "cl_util.h"
#include "com_weapons.h"

#include "const.h"
#include "entity_state.h"
#include "r_efx.h"

// g_runfuncs is true if this is the first time we've "predicated" a particular movement/firing
//  command.  If it is 1, then we should play events/sounds etc., otherwise, we just will be
//  updating state info, but not firing events
int	g_runfuncs = 0;

// During our weapon prediction processing, we'll need to reference some data that is part of
//  the final state passed into the postthink functionality.  We'll set this pointer and then
//  reset it to NULL as appropriate
struct local_state_s *g_finalstate = NULL;

/*
====================
COM_Log

Log debug messages to file ( appends )
====================
*/
void COM_Log( char *pszFile, char *fmt, ...)
{
	va_list		argptr;
	char		string[1024];
	FILE *fp;
	const char *pfilename;
	
	if ( !pszFile )
	{
		pfilename = "c:\\hllog.txt";
	}
	else
	{
		pfilename = pszFile;
	}

	va_start (argptr,fmt);
	vsprintf (string, fmt,argptr);
	va_end (argptr);

	fp = fopen( pfilename, "a+t");
	if (fp)
	{
		fprintf(fp, "%s", string);
		fclose(fp);
	}
}

// remember the current animation for the view model, in case we get out of sync with
//  server.
static int g_currentanim;
static int g_currentweapon;

/*
=====================
HUD_SendWeaponAnim

Change weapon model animation
=====================
*/
void HUD_SendWeaponAnim( int iAnim, int iWeaponId, int iBody, int iForce )
{
	if( g_runfuncs || iForce )
	{
		g_currentanim = iAnim;
		g_currentweapon = iWeaponId;

		// Tell animation system new info
		gEngfuncs.pfnWeaponAnim( iAnim, iBody );
	}
}

/*
=====================
HUD_GetWeaponAnim

Retrieve current predicted weapon animation
=====================
*/
int HUD_GetWeaponAnim( void )
{
	return g_currentanim;
}

/*
=====================
HUD_GetWeapon

Retrieve current predicted weapon id
=====================
*/
int HUD_GetWeapon( void )
{
	return g_currentweapon;
}

/*
=====================
HUD_PlaySound

Play a sound, if we are seeing this command for the first time
=====================
*/
void HUD_PlaySound( char *sound, float volume )
{
	if ( !g_runfuncs || !g_finalstate )
		return;

	gEngfuncs.pfnPlaySoundByNameAtLocation( sound, volume, (float *)&g_finalstate->playerstate.origin );
}

/*
=====================
HUD_PlaybackEvent

Directly queue up an event on the client
=====================
*/
void HUD_PlaybackEvent( int flags, const edict_t *pInvoker, unsigned short eventindex, float delay,
	float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 )
{
	if ( !g_runfuncs || !g_finalstate )
	     return;

	Vector org;
	Vector ang;

	// Weapon prediction events are assumed to occur at the player's origin
	org	= g_finalstate->playerstate.origin;
	ang	= v_angles;
	gEngfuncs.pfnPlaybackEvent( flags, pInvoker, eventindex, delay, org, ang,
								fparam1, fparam2,
								iparam1, iparam2,
								bparam1, bparam2 );
}

/*
=====================
UTIL_WeaponTimeBase

Always 0.0 on client, even if not predicting weapons ( won't get called
 in that case )
=====================
*/
/*
moved in util.h

float UTIL_WeaponTimeBase( void )
{
	return 0.0;
}
*/

static unsigned int glSeed = 0; 

unsigned int seed_table[ 256 ] =
{
	28985, 27138, 26457, 9451, 17764, 10909, 28790, 8716, 6361, 4853, 17798, 21977, 19643, 20662, 10834, 20103,
	27067, 28634, 18623, 25849, 8576, 26234, 23887, 18228, 32587, 4836, 3306, 1811, 3035, 24559, 18399, 315,
	26766, 907, 24102, 12370, 9674, 2972, 10472, 16492, 22683, 11529, 27968, 30406, 13213, 2319, 23620, 16823,
	10013, 23772, 21567, 1251, 19579, 20313, 18241, 30130, 8402, 20807, 27354, 7169, 21211, 17293, 5410, 19223,
	10255, 22480, 27388, 9946, 15628, 24389, 17308, 2370, 9530, 31683, 25927, 23567, 11694, 26397, 32602, 15031,
	18255, 17582, 1422, 28835, 23607, 12597, 20602, 10138, 5212, 1252, 10074, 23166, 19823, 31667, 5902, 24630,
	18948, 14330, 14950, 8939, 23540, 21311, 22428, 22391, 3583, 29004, 30498, 18714, 4278, 2437, 22430, 3439,
	28313, 23161, 25396, 13471, 19324, 15287, 2563, 18901, 13103, 16867, 9714, 14322, 15197, 26889, 19372, 26241,
	31925, 14640, 11497, 8941, 10056, 6451, 28656, 10737, 13874, 17356, 8281, 25937, 1661, 4850, 7448, 12744,
	21826, 5477, 10167, 16705, 26897, 8839, 30947, 27978, 27283, 24685, 32298, 3525, 12398, 28726, 9475, 10208,
	617, 13467, 22287, 2376, 6097, 26312, 2974, 9114, 21787, 28010, 4725, 15387, 3274, 10762, 31695, 17320,
	18324, 12441, 16801, 27376, 22464, 7500, 5666, 18144, 15314, 31914, 31627, 6495, 5226, 31203, 2331, 4668,
	12650, 18275, 351, 7268, 31319, 30119, 7600, 2905, 13826, 11343, 13053, 15583, 30055, 31093, 5067, 761,
	9685, 11070, 21369, 27155, 3663, 26542, 20169, 12161, 15411, 30401, 7580, 31784, 8985, 29367, 20989, 14203,
	29694, 21167, 10337, 1706, 28578, 887, 3373, 19477, 14382, 675, 7033, 15111, 26138, 12252, 30996, 21409,
	25678, 18555, 13256, 23316, 22407, 16727, 991, 9236, 5373, 29402, 6117, 15241, 27715, 19291, 19888, 19847
};

unsigned int U_Random( void ) 
{ 
	glSeed *= 69069; 
	glSeed += seed_table[ glSeed & 0xff ];
 
	return ( ++glSeed & 0x0fffffff ); 
} 

void U_Srand( unsigned int seed )
{
	glSeed = seed_table[ seed & 0xff ];
}

/*
=====================
UTIL_SharedRandomLong
=====================
*/
int UTIL_SharedRandomLong( unsigned int seed, int low, int high )
{
	unsigned int range;

	U_Srand( (int)seed + low + high );

	range = high - low + 1;
	if ( !(range - 1) )
	{
		return low;
	}
	else
	{
		int offset;
		int rnum;

		rnum = U_Random();

		offset = rnum % range;

		return (low + offset);
	}
}

/*
=====================
UTIL_SharedRandomFloat
=====================
*/
float UTIL_SharedRandomFloat( unsigned int seed, float low, float high )
{
	//
	unsigned int range;

	U_Srand( (int)seed + *(int *)&low + *(int *)&high );

	U_Random();
	U_Random();

	range = high - low;
	if ( !range )
	{
		return low;
	}
	else
	{
		int tensixrand;
		float offset;

		tensixrand = U_Random() & 65535;

		offset = (float)tensixrand / 65536.0;

		return (low + offset * range );
	}
}

```

`cl_dll/cs_wpn/cs_baseentity.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

/*
==========================
This file contains "stubs" of class member implementations so that we can predict certain
 weapons client side.  From time to time you might find that you need to implement part of the
 these functions.  If so, cut it from here, paste it in hl_weapons.cpp or somewhere else and
 add in the functionality you need.
==========================
*/
#include    "port.h"
#include	"extdll.h"
#include	"util.h"
#include	"cbase.h"
#include	"player.h"
#include	"weapons.h"
#include	"nodes.h"
#include	"soundent.h"
#include	"skill.h"

// Globals used by game logic
const Vector g_vecZero = Vector( 0, 0, 0 );
int gmsgWeapPickup = 0;
enginefuncs_t g_engfuncs;
globalvars_t  *gpGlobals;
ItemInfo CBasePlayerItem::ItemInfoArray[MAX_WEAPONS];


```

`cl_dll/cs_wpn/cs_weapons.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "port.h"

#include "wrect.h"
#include "cl_dll.h"
#include "cl_util.h"
#include "hud.h"

#include "extdll.h"
#include "util.h"
#include "cbase.h"
#include "monsters.h"

#define PLAYER_H
#include "weapons.h"
#undef PLAYER_H

#include "nodes.h"
#include "player.h"

#include "usercmd.h"
#include "entity_state.h"
#include "demo_api.h"
#include "pm_defs.h"
#include "event_api.h"
#include "r_efx.h"

#include "hud_iface.h"
#include "com_weapons.h"
#include "demo.h"

#include "cl_entity.h"

#include "pm_shared.h"
#include "GameStudioModelRenderer.h"
#include "ammohistory.h"
#ifndef min
#define min(a,b)  (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b)  (((a) > (b)) ? (a) : (b))
#endif

// Globals used by game logic
const Vector g_vecZero = Vector( 0, 0, 0 );
enginefuncs_t g_engfuncs;
globalvars_t  *gpGlobals;
ItemInfo CBasePlayerItem::ItemInfoArray[MAX_WEAPONS];

// Pool of client side entities/entvars_t
static entvars_t	ev[ 32 ];
static int			num_ents = 0;

// The entity we'll use to represent the local client
static CBasePlayer	player;

// Local version of game .dll global variables ( time, etc. )
static globalvars_t	Globals = { };

static CBasePlayerWeapon *g_pWpns[ 32 ];


// CS Weapon placeholder entities
static CAK47 g_AK47;
static CAUG g_AUG;
static CAWP g_AWP;
static CC4 g_C4;
static CDEAGLE g_DEAGLE;
static CELITE g_ELITE;
static CFamas g_Famas;
static CFiveSeven g_FiveSeven;
static CFlashbang g_Flashbang;
static CG3SG1 g_G3SG1;
static CGalil g_Galil;
static CGLOCK18 g_GLOCK18;
static CHEGrenade g_HEGrenade;
static CKnife g_Knife;
static CM249 g_M249;
static CM3 g_M3;
static CM4A1 g_M4A1;
static CMAC10 g_MAC10;
static CMP5N g_MP5N;
static CP228 g_P228;
static CP90 g_P90;
static CSCOUT g_SCOUT;
static CSG550 g_SG550;
static CSG552 g_SG552;
static CSmokeGrenade g_SmokeGrenade;
static CTMP g_TMP;
static CUMP45 g_UMP45;
static CUSP g_USP;
static CXM1014 g_XM1014;

int    g_iWeaponFlags;
bool   g_bInBombZone;
int    g_iFreezeTimeOver;
bool   g_bHoldingShield;
bool   g_bHoldingKnife;
float  g_flPlayerSpeed;
int    g_iPlayerFlags;
Vector g_vPlayerVelocity;
int    g_iWaterLevel;

/*
======================
AlertMessage

Print debug messages to console
======================
*/
void AlertMessage( ALERT_TYPE atype, const char *szFmt, ... )
{
	va_list		argptr;
	static char	string[1024];

	va_start (argptr, szFmt);
	vsprintf (string, szFmt,argptr);
	va_end (argptr);

	gEngfuncs.Con_Printf( "cl:  " );
	gEngfuncs.Con_Printf( string );
}

/*
=====================
HUD_PrepEntity

Links the raw entity to an entvars_s holder.  If a player is passed in as the owner, then
we set up the m_pPlayer field.
=====================
*/
edict_t *EHANDLE::Get(void)
{
	if (!m_pent)
		return NULL;

	if (m_pent->serialnumber != m_serialnumber)
		return NULL;

	return m_pent;
}

edict_t *EHANDLE::Set(edict_t *pent)
{
	m_pent = pent;

	if (pent)
		m_serialnumber = m_pent->serialnumber;

	return pent;
}

EHANDLE::operator CBaseEntity *(void)
{
	return (CBaseEntity *)GET_PRIVATE(Get());
}

CBaseEntity *EHANDLE::operator = (CBaseEntity *pEntity)
{
	if (pEntity)
	{
		m_pent = ENT(pEntity->pev);

		if (m_pent)
			m_serialnumber = m_pent->serialnumber;
	}
	else
	{
		m_pent = NULL;
		m_serialnumber = 0;
	}

	return pEntity;
}

EHANDLE::operator int(void)
{
	return Get() != NULL;
}

CBaseEntity *EHANDLE::operator ->(void)
{
	return (CBaseEntity *)GET_PRIVATE(Get());
}

void HUD_PrepEntity( CBaseEntity *pEntity )
{
	memset( &ev[ num_ents ], 0, sizeof( entvars_t ) );
	pEntity->pev = &ev[ num_ents++ ];

	pEntity->Precache();
	pEntity->Spawn();
}


void HUD_PrepEntity( CBasePlayerWeapon *pEntity, CBasePlayer *pWeaponOwner )
{
	ItemInfo info = {};

	memset( &ev[ num_ents ], 0, sizeof( entvars_t ) );
	pEntity->pev = &ev[ num_ents++ ];

	pEntity->Precache();
	pEntity->Spawn();
	pEntity->m_pPlayer = pWeaponOwner;
	pEntity->GetItemInfo( &info );

	g_pWpns[ info.iId ] = pEntity;
	CBasePlayerItem::ItemInfoArray[ info.iId ] = info;
}

/*
=====================
CBaseEntity :: Killed

If weapons code "kills" an entity, just set its effects to EF_NODRAW
=====================
*/
void CBaseEntity :: Killed( entvars_t *pevAttacker, int iGib )
{
	pev->effects |= EF_NODRAW;
}

/*
=====================
CBasePlayerWeapon :: DefaultReload
=====================
*/
BOOL CBasePlayerWeapon :: DefaultReload( int iClipSize, int iAnim, float fDelay, int body )
{
	if( !m_pPlayer->m_pActiveItem )
		return FALSE;

	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		return FALSE;

	int j = min(iClipSize - m_iClip, player.m_rgAmmo[m_iPrimaryAmmoType]);

	if (j == 0)
		return FALSE;

	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + fDelay;

	//!!UNDONE -- reload sound goes here !!!
	SendWeaponAnim( iAnim, UseDecrement() );

	m_fInReload = TRUE;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + fDelay + 0.5f;
	return TRUE;
}

/*
=====================
CBasePlayerWeapon :: CanDeploy
=====================
*/
BOOL CBasePlayerWeapon :: CanDeploy( void )
{
	return TRUE;
}
/*
=====================
CBasePlayer :: HasShield

=====================
*/
bool CBasePlayer::HasShield()
{
	return g_bHoldingShield;
}

/*
=====================
CBasePlayerWeapon::HasSecondaryAttack()

=====================
*/
bool CBasePlayerWeapon::HasSecondaryAttack()
{
	if (m_pPlayer->HasShield())
	{
		return true;
	}

	switch (m_iId)
	{
	case WEAPON_AK47:
	case WEAPON_XM1014:
	case WEAPON_MAC10:
	case WEAPON_ELITE:
	case WEAPON_FIVESEVEN:
	case WEAPON_MP5N:
	case WEAPON_M249:
	case WEAPON_M3:
	case WEAPON_TMP:
	case WEAPON_DEAGLE:
	case WEAPON_P228:
	case WEAPON_P90:
	case WEAPON_C4:
	case WEAPON_GALIL:
		return false;
	default:
		break;
	}

	return true;
}

void CBasePlayerWeapon::FireRemaining(int &shotsFired, float &shootTime, BOOL isGlock18)
{
	m_iClip--;

	if (m_iClip < 0)
	{
		m_iClip = 0;
		shotsFired = 3;
		shootTime = 0;
		return;
	}

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir;

	if (isGlock18)
	{
		vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, 0.05, 8192, 1, BULLET_PLAYER_9MM, 18, 0.9, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);
		PLAYBACK_EVENT_FULL(FEV_NOTHOST, ENT(m_pPlayer->pev), m_usFireGlock18, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 10000), (int)(m_pPlayer->pev->punchangle.y * 10000), m_iClip == 0, FALSE);
		m_pPlayer->ammo_9mm--;
	}
	else
	{
		vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, m_fBurstSpread, 8192, 2, BULLET_PLAYER_556MM, 30, 0.96, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);
		PLAYBACK_EVENT_FULL(FEV_NOTHOST, ENT(m_pPlayer->pev), m_usFireFamas, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 10000000), (int)(m_pPlayer->pev->punchangle.y * 10000000), FALSE, FALSE);
		m_pPlayer->ammo_556nato--;
	}

	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;

	if (++shotsFired != 3)
		shootTime = gpGlobals->time + 0.1;
	else
		shootTime = 0;
}

bool CBasePlayerWeapon::ShieldSecondaryFire(int iUpAnim, int iDownAnim)
{
	if (!m_pPlayer->HasShield())
		return false;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(iDownAnim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgun");
		m_fMaxSpeed = 250.0f;
		m_pPlayer->m_bShieldDrawn = false;
	}
	else
	{
		m_iWeaponState |= WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(iUpAnim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shielded");
		m_fMaxSpeed = 180.0f;
		m_pPlayer->m_bShieldDrawn = true;
	}

	m_flNextSecondaryAttack = 0.4f;
	m_flNextPrimaryAttack = 0.4f;
	m_flTimeWeaponIdle = 0.6f;

	return true;
}

void CBasePlayerWeapon::KickBack(float up_base, float lateral_base, float up_modifier, float lateral_modifier, float up_max, float lateral_max, int direction_change)
{

}

void CBasePlayerWeapon::SetPlayerShieldAnim(void)
{
	if (!m_pPlayer->HasShield())
		return;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		strcpy(m_pPlayer->m_szAnimExtention, "shield");
	}
	else
	{
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgun");
	}
}

void CBasePlayerWeapon::ResetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield())
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		{
			strcpy(m_pPlayer->m_szAnimExtention, "shieldgun");
		}
	}
}

/*
=====================
CBasePlayerWeapon :: DefaultDeploy

=====================
*/
BOOL CBasePlayerWeapon :: DefaultDeploy( const char *szViewModel, const char *szWeaponModel, int iAnim, const char *szAnimExt, int skiplocal )
{
	if ( !CanDeploy() )
		return FALSE;

	gEngfuncs.CL_LoadModel( szViewModel, &m_pPlayer->pev->viewmodel );

	SendWeaponAnim( iAnim, skiplocal );

	m_pPlayer->m_flNextAttack = 0.75f;
	m_flTimeWeaponIdle = 1.5f;
	return TRUE;
}

/*
=====================
CBasePlayerWeapon :: PlayEmptySound

=====================
*/
BOOL CBasePlayerWeapon :: PlayEmptySound( void )
{
#if 0
	if (m_iPlayEmptySound)
	{
		switch (m_iId)
		{
		case WEAPON_USP:
		case WEAPON_GLOCK18:
		case WEAPON_P228:
		case WEAPON_DEAGLE:
		case WEAPON_ELITE:
		case WEAPON_FIVESEVEN:
			HUD_PlaySound("weapons/dryfire_pistol.wav", 0.8);
			break;
		default:
			HUD_PlaySound("weapons/dryfire_rifle.wav",  0.8);
			break;
		}
	}
#endif
	return 0;
}

/*
=====================
CBasePlayerWeapon :: ResetEmptySound

=====================
*/
void CBasePlayerWeapon :: ResetEmptySound( void )
{
	m_iPlayEmptySound = 1;
}

/*
=====================
CBasePlayerWeapon::Holster

Put away weapon
=====================
*/
void CBasePlayerWeapon::Holster( int skiplocal /* = 0 */ )
{
	m_fInReload = FALSE; // cancel any reload in progress.
	m_pPlayer->pev->viewmodel = 0;
}

/*
=====================
CBasePlayerWeapon::SendWeaponAnim

Animate weapon model
=====================
*/
void CBasePlayerWeapon::SendWeaponAnim( int iAnim, int skiplocal )
{
	//gEngfuncs.Con_DPrintf( "Predict::SendWeaponAnim( %i )\n", iAnim );

	m_pPlayer->pev->weaponanim = iAnim;
	HUD_SendWeaponAnim( iAnim, m_iId, 0, 0 );
}

void CBasePlayerWeapon::RetireWeapon()
{
	// TODO: Implement
	// UTIL_GetNextBestWeapon( m_pPlayer, this );
}

Vector CBaseEntity::FireBullets3 ( Vector vecSrc, Vector vecDirShooting, float flSpread, float flDistance, int iPenetration, int iBulletType, int iDamage, float flRangeModifier, entvars_t *pevAttacker, bool bPistol, int shared_rand )
{
	float x, y, z;

	if ( pevAttacker )
	{
		x = UTIL_SharedRandomFloat(shared_rand, -0.5, 0.5) + UTIL_SharedRandomFloat(shared_rand + 1, -0.5, 0.5);
		y = UTIL_SharedRandomFloat(shared_rand + 2, -0.5, 0.5) + UTIL_SharedRandomFloat(shared_rand + 3, -0.5, 0.5);
	}
	else
	{
		do
		{
			x = RANDOM_FLOAT(-0.5, 0.5) + RANDOM_FLOAT(-0.5, 0.5);
			y = RANDOM_FLOAT(-0.5, 0.5) + RANDOM_FLOAT(-0.5, 0.5);
			z = x * x + y * y;
		}
		while (z > 1);
	}

	return Vector(x * flSpread, y * flSpread, 0.0f);
}
/*
=====================
CBasePlayerWeapon::ItemPostFrame

Handles weapon firing, reloading, etc.
=====================
*/
void CBasePlayerWeapon::ItemPostFrame( void )
{
	int button = m_pPlayer->pev->button;

	if (!HasSecondaryAttack())
		button &= ~IN_ATTACK2;

	if (m_flGlock18Shoot != 0)
	{
		m_iClip--;
		if( m_iClip < 0 )
		{
			m_iClip = m_iGlock18ShotsFired = 0;
		}
		FireRemaining(m_iGlock18ShotsFired, m_flGlock18Shoot, TRUE);
	}
	else if (gpGlobals->time > m_flFamasShoot && m_flFamasShoot != 0)
	{
		m_iClip--;
		if( m_iClip < 0 )
		{
			m_iClip = m_iFamasShotsFired = 0;
		}
		FireRemaining(m_iFamasShotsFired, m_flFamasShoot, FALSE);
	}

	if (m_flNextPrimaryAttack <= UTIL_WeaponTimeBase() )
	{
		if (m_pPlayer->m_bResumeZoom)
		{
			m_pPlayer->pev->fov = m_pPlayer->m_iFOV = m_pPlayer->m_iLastZoom;

			if (m_pPlayer->m_iFOV == m_pPlayer->m_iLastZoom)
			{
				m_pPlayer->m_bResumeZoom = false;
				// viewmodel hide is implemented elsewhere
			}
		}
	}

	if ( m_pPlayer->HasShield() )
	{
		if (m_fInReload && m_pPlayer->pev->button & IN_ATTACK2)
		{
			SecondaryAttack();
			m_pPlayer->pev->button &= ~IN_ATTACK2;
			m_fInReload = FALSE;
			m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase();
		}
	}

	if ((m_fInReload) && m_pPlayer->m_flNextAttack <= UTIL_WeaponTimeBase())
	{
		int j = min(iMaxClip() - m_iClip, m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]);

		m_iClip += j;
		m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] -= j;
		m_fInReload = FALSE;
	}

	if ((button & IN_ATTACK2) && m_flNextSecondaryAttack <= UTIL_WeaponTimeBase())
	{
		if (pszAmmo2() && !m_pPlayer->m_rgAmmo[m_iSecondaryAmmoType])
			m_fFireOnEmpty = TRUE;

		SecondaryAttack();
		m_pPlayer->pev->button &= ~IN_ATTACK2;
	}
	else if ((m_pPlayer->pev->button & IN_ATTACK) && m_flNextPrimaryAttack <= UTIL_WeaponTimeBase())
	{
		if ((!m_iClip && pszAmmo1()) || (iMaxClip() == WEAPON_NOCLIP && !m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]))
			m_fFireOnEmpty = TRUE;

		if (m_pPlayer->m_bCanShoot == true)
			PrimaryAttack();
	}
	else if (m_pPlayer->pev->button & IN_RELOAD && iMaxClip() != WEAPON_NOCLIP && !m_fInReload)
	{
		if (m_flNextPrimaryAttack < UTIL_WeaponTimeBase())
		{
			if (m_flFamasShoot == 0 && m_flGlock18Shoot == 0)
			{
				if (!(m_iWeaponState & WPNSTATE_SHIELD_DRAWN))
					Reload();
			}
		}
	}
	else if (!(button & (IN_ATTACK | IN_ATTACK2)))
	{
		if (m_bDelayFire == true)
		{
			m_bDelayFire = false;

			if (m_iShotsFired > 15)
				m_iShotsFired = 15;

			m_flDecreaseShotsFired = gpGlobals->time + 0.4;
		}

		m_fFireOnEmpty = FALSE;

		if (m_iId != WEAPON_USP && m_iId != WEAPON_GLOCK18 && m_iId != WEAPON_P228 && m_iId != WEAPON_DEAGLE && m_iId != WEAPON_ELITE && m_iId != WEAPON_FIVESEVEN)
		{
			if (m_iShotsFired > 0)
			{
				if (gpGlobals->time > m_flDecreaseShotsFired)
				{
					m_iShotsFired--;
					m_flDecreaseShotsFired = gpGlobals->time + 0.0225;
				}
			}
		}
		else
			m_iShotsFired = 0;


		if (!(m_iWeaponState & WPNSTATE_SHIELD_DRAWN))
		{

			if (m_iClip == 0 && !(iFlags() & ITEM_FLAG_NOAUTORELOAD)
					&& m_flNextPrimaryAttack < UTIL_WeaponTimeBase())
			{
				if (m_flFamasShoot == 0 && m_flGlock18Shoot == 0)
				{
					Reload();
					return;
				}
			}
		}

		WeaponIdle();
		return;
	}
}

float CBasePlayerWeapon::GetNextAttackDelay(float delay)
{
	float flNextAttack = UTIL_WeaponTimeBase() + delay;
	return flNextAttack;
}

/*
=====================
CBasePlayer::SelectLastItem

=====================
*/
void CBasePlayer::SelectLastItem(void)
{
	if (!m_pLastItem)
	{
		return;
	}

	if ( m_pActiveItem && !m_pActiveItem->CanHolster() )
	{
		return;
	}

	if (m_pActiveItem)
		m_pActiveItem->Holster( );

	CBasePlayerItem *pTemp = m_pActiveItem;
	m_pActiveItem = m_pLastItem;
	m_pLastItem = pTemp;
	m_pActiveItem->Deploy( );
}

/*
=====================
CBasePlayer::Killed

=====================
*/
void CBasePlayer::Killed( entvars_t *pevAttacker, int iGib )
{
	// Holster weapon immediately, to allow it to cleanup
	if ( m_pActiveItem )
		 m_pActiveItem->Holster( );
}

/*
=====================
CBasePlayer::Spawn

=====================
*/
void CBasePlayer::Spawn( void )
{
	if (m_pActiveItem)
		m_pActiveItem->Deploy( );
}

Vector CBasePlayer::GetGunPosition()
{
	Vector origin = pev->origin;
	Vector view_ofs;

	gEngfuncs.pEventAPI->EV_LocalPlayerViewheight(view_ofs);

	return origin + view_ofs;
}

/*
=====================
UTIL_TraceLine

Don't actually trace, but act like the trace didn't hit anything.
=====================
*/
void UTIL_TraceLine( const Vector &vecStart, const Vector &vecEnd, IGNORE_MONSTERS igmon, edict_t *pentIgnore, TraceResult *ptr )
{
	memset( ptr, 0, sizeof( *ptr ) );
#if 0
	static float flLastFraction = 1.0f;

	if( g_runfuncs )
	{
		Vector vStart = vecStart, vEnd = vecEnd;
		pmtrace_t pmtrace;

		gEngfuncs.pEventAPI->EV_SetTraceHull( 0 );
		gEngfuncs.pEventAPI->EV_PlayerTrace( vStart, vEnd, 0, -1, &pmtrace );
		flLastFraction = ptr->flFraction = pmtrace.fraction;
		ptr->vecEndPos = pmtrace.endpos;
	}
	else
	{
		ptr->flFraction = flLastFraction;
	}
#else
	ptr->flFraction = 1.0f;
#endif
}

char UTIL_TextureHit(TraceResult *ptr, Vector vecSrc, Vector vecEnd)
{
	char chTextureType;
	float rgfl1[3], rgfl2[3];
	const char *pTextureName;
	char szbuffer[64];
	CBaseEntity *pEntity;

	if( ptr->pHit == NULL )
		return CHAR_TEX_FLESH;

	pEntity = CBaseEntity::Instance(ptr->pHit);

	if (pEntity && pEntity->Classify() != CLASS_NONE && pEntity->Classify() != CLASS_MACHINE)
		return CHAR_TEX_FLESH;

	vecSrc.CopyToArray(rgfl1);
	vecEnd.CopyToArray(rgfl2);

	if (pEntity)
		pTextureName = TRACE_TEXTURE(ENT(pEntity->pev), rgfl1, rgfl2);
	else
		pTextureName = TRACE_TEXTURE(ENT(0), rgfl1, rgfl2);

	if (pTextureName)
	{
		if (*pTextureName == '-' || *pTextureName == '+')
			pTextureName += 2;

		if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')
			pTextureName++;

		strncpy(szbuffer, pTextureName, sizeof(szbuffer));
		szbuffer[CBTEXTURENAMEMAX - 1] = 0;
		chTextureType = PM_FindTextureType(szbuffer);
	}
	else
		chTextureType = 0;

	return chTextureType;
}

CBasePlayer *UTIL_PlayerByIndex(int playerIndex)
{
#if 0
	CBaseEntity *pPlayer = NULL;

	if (playerIndex > 0 && playerIndex <= gpGlobals->maxClients)
	{
		edict_t *pPlayerEdict = INDEXENT(playerIndex);

		if (pPlayerEdict && !pPlayerEdict->free)
			pPlayer = CBaseEntity::Instance(pPlayerEdict);
	}

	return pPlayer;
#else
	return &player;
#endif
}

void Broadcast( const char *msg, int pitch ); // hud/radio
void CBasePlayer::Radio(const char *msg_id, const char *msg_verbose, int pitch, bool showIcon)
{
	Broadcast( msg_id, pitch );
}

void UTIL_MakeVectors( const Vector &vec )
{
	gEngfuncs.pfnAngleVectors( vec, gpGlobals->v_forward, gpGlobals->v_right, gpGlobals->v_up );
}

/*
=====================
HUD_InitClientWeapons

Set up weapons, player and functions needed to run weapons code client-side.
=====================
*/
void HUD_InitClientWeapons( void )
{
	static int initialized = 0;
	if ( initialized )
		return;

	initialized = 1;

	// Set up pointer ( dummy object )
	gpGlobals = &Globals;

	// Fill in current time ( probably not needed )
	gpGlobals->time = gEngfuncs.GetClientTime();

	// Fake functions
	//g_engfuncs.pfnSetClientMaxspeed = HUD_SetMaxSpeed;

	// Handled locally
	g_engfuncs.pfnPlaybackEvent		= HUD_PlaybackEvent;
	g_engfuncs.pfnAlertMessage		= AlertMessage;

	// Pass through to engine
	g_engfuncs.pfnPrecacheEvent		= gEngfuncs.pfnPrecacheEvent;
	g_engfuncs.pfnRandomFloat		= gEngfuncs.pfnRandomFloat;
	g_engfuncs.pfnRandomLong		= gEngfuncs.pfnRandomLong;

	// Allocate a slot for the local player
	HUD_PrepEntity( &player	);

	// Allocate slot(s) for each weapon that we are going to be predicting
	if( gHUD.GetGameType() != GAME_CZERODS )
	{
		HUD_PrepEntity( &g_P228, &player);
		HUD_PrepEntity( &g_SCOUT, &player);
		HUD_PrepEntity( &g_HEGrenade, &player);
		HUD_PrepEntity( &g_XM1014, &player);
		HUD_PrepEntity( &g_C4, &player);
		HUD_PrepEntity( &g_MAC10, &player);
		HUD_PrepEntity( &g_AUG, &player);
		HUD_PrepEntity( &g_SmokeGrenade, &player);
		HUD_PrepEntity( &g_ELITE, &player);
		HUD_PrepEntity( &g_FiveSeven, &player);
		HUD_PrepEntity( &g_UMP45, &player);
		HUD_PrepEntity( &g_SG550, &player);
		HUD_PrepEntity( &g_Galil, &player);
		HUD_PrepEntity( &g_Famas, &player);
		HUD_PrepEntity( &g_USP, &player);
		HUD_PrepEntity( &g_GLOCK18, &player);
		HUD_PrepEntity( &g_AWP, &player);
		HUD_PrepEntity( &g_MP5N, &player);
		HUD_PrepEntity( &g_M249, &player);
		HUD_PrepEntity( &g_M4A1, &player);
		HUD_PrepEntity( &g_M3, &player );
		HUD_PrepEntity( &g_TMP, &player);
		HUD_PrepEntity( &g_G3SG1, &player);
		HUD_PrepEntity( &g_Flashbang, &player);
		HUD_PrepEntity( &g_DEAGLE, &player);
		HUD_PrepEntity( &g_SG552, &player);
		HUD_PrepEntity( &g_AK47, &player);
		HUD_PrepEntity( &g_Knife, &player);
		HUD_PrepEntity( &g_P90, &player );
	}
}


int GetWeaponAccuracyFlags( int weaponid )
{
	int result = 0;

	if( weaponid <= WEAPON_P90 )
	{
		switch( weaponid )
		{
		case WEAPON_AUG:
		case WEAPON_GALIL:
		case WEAPON_M249:
		case WEAPON_SG552:
		case WEAPON_AK47:
		case WEAPON_P90:
			result = ACCURACY_AIR | ACCURACY_SPEED;
			break;
		case WEAPON_P228:
		case WEAPON_FIVESEVEN:
		case WEAPON_DEAGLE:
			result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_DUCK;
			break;
		case WEAPON_GLOCK18:
			if( g_iWeaponFlags & WPNSTATE_GLOCK18_BURST_MODE)
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_DUCK;
			}
			else
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_DUCK | ACCURACY_MULTIPLY_BY_14_2;
			}
			break;
		case WEAPON_MAC10:
		case WEAPON_UMP45:
		case WEAPON_MP5N:
		case WEAPON_TMP:
			result = ACCURACY_AIR;
			break;
		case WEAPON_M4A1:
			if(g_iWeaponFlags & WPNSTATE_USP_SILENCED)
			{
				result = ACCURACY_AIR | ACCURACY_SPEED;
			}
			else
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_MULTIPLY_BY_14;
			}
			break;
		case WEAPON_FAMAS:
			if(g_iWeaponFlags & WPNSTATE_FAMAS_BURST_MODE)
			{
				result = ACCURACY_AIR | ACCURACY_SPEED;
			}
			else
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | (1<<4);
			}
			break;
		case WEAPON_USP:
			if(g_iWeaponFlags & WPNSTATE_USP_SILENCED)
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_DUCK;
			}
			else
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_DUCK | ACCURACY_MULTIPLY_BY_14;
			}
			break;
		}
	}

	return result;
}

/*
=====================
HUD_WeaponsPostThink

Run Weapon firing code on client
=====================
*/
void HUD_WeaponsPostThink( local_state_s *from, local_state_s *to, usercmd_t *cmd, double time, unsigned int random_seed )
{
	int i;
	int buttonsChanged;
	CBasePlayerWeapon *pWeapon = NULL;
	static int lasthealth;
	int flags;

	HUD_InitClientWeapons();

	// Get current clock
	gpGlobals->time = time;

	// Fill in data based on selected weapon
	switch ( from->client.m_iId )
	{
		case WEAPON_P228:
			pWeapon = &g_P228;
			break;

		case WEAPON_SCOUT:
			pWeapon = &g_SCOUT;
			break;

		case WEAPON_HEGRENADE:
			pWeapon = &g_HEGrenade;
			break;

		case WEAPON_XM1014:
			pWeapon = &g_XM1014;
			break;

		case WEAPON_C4:
			pWeapon = &g_C4;
			break;

		case WEAPON_MAC10:
			pWeapon = &g_MAC10;
			break;

		case WEAPON_AUG:
			pWeapon = &g_AUG;
			break;

		case WEAPON_SMOKEGRENADE:
			pWeapon = &g_SmokeGrenade;
			break;

		case WEAPON_ELITE:
			pWeapon = &g_ELITE;
			break;

		case WEAPON_FIVESEVEN:
			pWeapon = &g_FiveSeven;
			break;

		case WEAPON_UMP45:
			pWeapon = &g_UMP45;
			break;

		case WEAPON_SG550:
			pWeapon = &g_SG550;
			break;

		case WEAPON_GALIL:
			pWeapon = &g_Galil;
			break;

		case WEAPON_FAMAS:
			pWeapon = &g_Famas;
			break;

		case WEAPON_USP:
			pWeapon = &g_USP;
			break;

		case WEAPON_GLOCK18:
			pWeapon = &g_GLOCK18;
			break;

		case WEAPON_AWP:
			pWeapon = &g_AWP;
			break;

		case WEAPON_MP5N:
			pWeapon = &g_MP5N;
			break;

		case WEAPON_M249:
			pWeapon = &g_M249;
			break;

		case WEAPON_M3:
			pWeapon = &g_M3;
			break;

		case WEAPON_M4A1:
			pWeapon = &g_M4A1;
			break;

		case WEAPON_TMP:
			pWeapon = &g_TMP;
			break;

		case WEAPON_G3SG1:
			pWeapon = &g_G3SG1;
			break;

		case WEAPON_FLASHBANG:
			pWeapon = &g_Flashbang;
			break;

		case WEAPON_DEAGLE:
			pWeapon = &g_DEAGLE;
			break;

		case WEAPON_SG552:
			pWeapon = &g_SG552;
			break;

		case WEAPON_AK47:
			pWeapon = &g_AK47;
			break;

		case WEAPON_KNIFE:
			pWeapon = &g_Knife;
			break;

		case WEAPON_P90:
			pWeapon = &g_P90;
			break;

		/*case WEAPON_NONE:
			break;

		case WEAPON_GLOCK:
		default:
			gEngfuncs.Con_Printf("VALVEWHY: Unknown Weapon %i is active.\n", from->client.m_iId );
			break;*/
	}

	// Store pointer to our destination entity_state_t so we can get our origin, etc. from it
	//  for setting up events on the client
	g_finalstate = to;

	// If we are running events/etc. go ahead and see if we
	//  managed to die between last frame and this one
	// If so, run the appropriate player killed or spawn function
	if ( g_runfuncs )
	{
		if ( to->client.health <= 0 && lasthealth > 0 )
			player.Killed( NULL, 0 );
		else if ( to->client.health > 0 && lasthealth <= 0 )
			player.Spawn();

		lasthealth = to->client.health;
	}

	// We are not predicting the current weapon, just bow out here.
	if ( !pWeapon )
		return;

	for ( i = 0; i < MAX_WEAPONS; i++ )
	{
		CBasePlayerWeapon *pCurrent = g_pWpns[ i ];
		if ( !pCurrent )
			continue;

		weapon_data_t *pfrom = from->weapondata + i;

		pCurrent->m_fInReload			= pfrom->m_fInReload;
		pCurrent->m_fInSpecialReload	= pfrom->m_fInSpecialReload;
		pCurrent->m_iClip				= pfrom->m_iClip;
		pCurrent->m_flNextPrimaryAttack	= pfrom->m_flNextPrimaryAttack;
		pCurrent->m_flNextSecondaryAttack = pfrom->m_flNextSecondaryAttack;
		pCurrent->m_flTimeWeaponIdle	= pfrom->m_flTimeWeaponIdle;
		pCurrent->m_flStartThrow		= pfrom->fuser2;
		pCurrent->m_flReleaseThrow		= pfrom->fuser3;
		pCurrent->m_iSwing				= pfrom->iuser1;
		pCurrent->m_iWeaponState		= pfrom->m_iWeaponState;
		pCurrent->m_flLastFire			= pfrom->m_fAimedDamage;
		pCurrent->m_iShotsFired			= pfrom->m_fInZoom;
	}

	if( from->client.vuser4.x < 0 || from->client.vuser4.x > MAX_AMMO_TYPES )
		pWeapon->m_iPrimaryAmmoType = 0;
	else
	{
		pWeapon->m_iPrimaryAmmoType = (int)from->client.vuser4.x;
		player.m_rgAmmo[ pWeapon->m_iPrimaryAmmoType ]  = (int)from->client.vuser4.y;
	}


	g_iWeaponFlags = pWeapon->m_iWeaponState;

	// For random weapon events, use this seed to seed random # generator
	player.random_seed = random_seed;

	// Get old buttons from previous state.
	player.m_afButtonLast = from->playerstate.oldbuttons;

	// Which buttsons chave changed
	buttonsChanged = (player.m_afButtonLast ^ cmd->buttons);	// These buttons have changed this frame

	// Debounced button codes for pressed/released
	// The changed ones still down are "pressed"
	player.m_afButtonPressed =  buttonsChanged & cmd->buttons;
	// The ones not down are "released"
	player.m_afButtonReleased = buttonsChanged & (~cmd->buttons);
	player.pev->v_angle = cmd->viewangles;
	player.pev->origin = from->client.origin;

	// Set player variables that weapons code might check/alter
	player.pev->button = cmd->buttons;

	player.pev->velocity = from->client.velocity;

	player.pev->deadflag   = from->client.deadflag;
	player.pev->waterlevel = from->client.waterlevel;
	player.pev->maxspeed   = from->client.maxspeed;
	player.pev->punchangle = from->client.punchangle;
	player.pev->fov        = from->client.fov;
	player.pev->weaponanim = from->client.weaponanim;
	player.pev->viewmodel  = from->client.viewmodel;
	player.m_flNextAttack  = from->client.m_flNextAttack;

	g_iPlayerFlags    = player.pev->flags = from->client.flags;
	g_vPlayerVelocity = player.pev->velocity;
	g_flPlayerSpeed	  = player.pev->velocity.Length();
	g_iWaterLevel     = player.pev->waterlevel;

	//Stores all our ammo info, so the client side weapons can use them.
	player.ammo_9mm			= from->client.ammo_nails;
	player.ammo_556nato		= from->client.ammo_cells;
	player.ammo_buckshot	= from->client.ammo_shells;
	player.ammo_556natobox	= from->client.ammo_rockets;
	player.ammo_762nato		= (int)from->client.vuser2.x;
	player.ammo_45acp		= (int)from->client.vuser2.y;
	player.ammo_50ae		= (int)from->client.vuser2.z;
	player.ammo_338mag		= (int)from->client.vuser3.x;
	player.ammo_57mm		= (int)from->client.vuser3.y;
	player.ammo_357sig		= (int)from->client.vuser3.z;

	cl_entity_t *pplayer = gEngfuncs.GetLocalPlayer();
	if( pplayer )
	{
		player.pev->origin = from->client.origin;
		player.pev->angles	= pplayer->angles;
		player.pev->v_angle = v_angles;
	}

	flags = from->client.iuser3;
	g_bHoldingKnife		= pWeapon->m_iId == WEAPON_KNIFE;
	player.m_bCanShoot	= (flags & PLAYER_CAN_SHOOT) != 0;
	g_iFreezeTimeOver	= !(flags & PLAYER_FREEZE_TIME_OVER);
	g_bInBombZone		= (flags & PLAYER_IN_BOMB_ZONE) != 0;

	// validate if we can hold shield with specified weapon
	switch( from->client.m_iId )
	{
	case WEAPON_KNIFE:
	case WEAPON_GLOCK18:
	case WEAPON_USP:
	case WEAPON_P228:
	case WEAPON_DEAGLE:
	case WEAPON_FIVESEVEN:
	case WEAPON_HEGRENADE:
	case WEAPON_FLASHBANG:
	case WEAPON_SMOKEGRENADE:
		g_bHoldingShield	= (flags & PLAYER_HOLDING_SHIELD) != 0;
		break;
	default:
		g_bHoldingShield = false;
		break;
	}

	// Point to current weapon object
	if ( from->client.m_iId )
		player.m_pActiveItem = pWeapon;

	// Don't go firing anything if we have died.
	// Or if we don't have a weapon model deployed
	if ( ( player.pev->deadflag != ( DEAD_DISCARDBODY + 1 ) ) &&
		 !CL_IsDead() && player.pev->viewmodel && !g_iUser1 )
	{
		if( g_bHoldingKnife && pWeapon->m_iClientWeaponState &&
				player.pev->button & IN_FORWARD )
			player.m_flNextAttack = 0;
		else if( player.m_flNextAttack <= 0 )
		{
			pWeapon->ItemPostFrame();
		}
	}

	// Assume that we are not going to switch weapons
	to->client.m_iId					= from->client.m_iId;

	// Now see if we issued a changeweapon command ( and we're not dead )
	if ( cmd->weaponselect && ( player.pev->deadflag != ( DEAD_DISCARDBODY + 1 ) ) )
	{
		// Switched to a different weapon?
		if ( from->weapondata[ cmd->weaponselect ].m_iId == cmd->weaponselect )
		{
			CBasePlayerWeapon *pNew = g_pWpns[ cmd->weaponselect ];
			if ( pNew && ( pNew != pWeapon ) )
			{
				// Put away old weapon
				if (player.m_pActiveItem)
					player.m_pActiveItem->Holster( );

				player.m_pLastItem = player.m_pActiveItem;
				player.m_pActiveItem = pNew;

				// Deploy new weapon
				if (player.m_pActiveItem)
				{
					player.m_pActiveItem->Deploy( );
				}

				// Update weapon id so we can predict things correctly.
				to->client.m_iId = cmd->weaponselect;
			}
		}
	}

	// Copy in results of prediction code
	to->client.viewmodel				= player.pev->viewmodel;
	to->client.fov						= player.pev->fov;
	to->client.weaponanim				= player.pev->weaponanim;
	to->client.m_flNextAttack			= player.m_flNextAttack;
	to->client.maxspeed					= player.pev->maxspeed;
	to->client.punchangle				= player.pev->punchangle;


	to->client.ammo_nails = player.ammo_9mm;
	to->client.ammo_cells = player.ammo_556nato;
	to->client.ammo_shells = player.ammo_buckshot;
	to->client.ammo_rockets = player.ammo_556natobox;
	to->client.vuser2.x = player.ammo_762nato;
	to->client.vuser2.y = player.ammo_45acp;
	to->client.vuser2.z = player.ammo_50ae;
	to->client.vuser3.x = player.ammo_338mag;
	to->client.vuser3.y = player.ammo_57mm;
	to->client.vuser3.z = player.ammo_357sig;
	to->client.iuser3 = flags;




	// Make sure that weapon animation matches what the game .dll is telling us
	//  over the wire ( fixes some animation glitches )
	if ( g_runfuncs && ( HUD_GetWeaponAnim() != to->client.weaponanim ) )
		// Force a fixed anim down to viewmodel
		HUD_SendWeaponAnim( to->client.weaponanim, to->client.m_iId, 2, 1 );

	if (pWeapon->m_iPrimaryAmmoType < MAX_AMMO_TYPES)
	{
		to->client.vuser4.x = pWeapon->m_iPrimaryAmmoType;
		to->client.vuser4.y = player.m_rgAmmo[ pWeapon->m_iPrimaryAmmoType ];
	}
	else
	{
		to->client.vuser4.x = -1.0;
		to->client.vuser4.y = 0;
	}

	for ( i = 0; i < MAX_WEAPONS; i++ )
	{
		CBasePlayerWeapon *pCurrent = g_pWpns[ i ];

		weapon_data_t *pto = to->weapondata + i;

		if ( !pCurrent )
		{
			memset( pto, 0, sizeof( weapon_data_t ) );
			continue;
		}

		pto->m_iClip					= pCurrent->m_iClip;

		pto->m_flNextPrimaryAttack		= pCurrent->m_flNextPrimaryAttack;
		pto->m_flNextSecondaryAttack	= pCurrent->m_flNextSecondaryAttack;
		pto->m_flTimeWeaponIdle			= pCurrent->m_flTimeWeaponIdle;

		pto->m_fInReload				= pCurrent->m_fInReload;
		pto->m_fInSpecialReload			= pCurrent->m_fInSpecialReload;
		pto->m_flNextReload				= pCurrent->m_flNextReload;
		pto->fuser2						= pCurrent->m_flStartThrow;
		pto->fuser3						= pCurrent->m_flReleaseThrow;
		pto->iuser1						= pCurrent->m_iSwing;
		pto->m_iWeaponState				= pCurrent->m_iWeaponState;
		pto->m_fInZoom					= pCurrent->m_iShotsFired;
		pto->m_fAimedDamage				= pCurrent->m_flLastFire;

		// Decrement weapon counters, server does this at same time ( during post think, after doing everything else )
		pto->m_flNextReload				-= cmd->msec / 1000.0f;
		pto->m_fNextAimBonus			-= cmd->msec / 1000.0f;
		pto->m_flNextPrimaryAttack		-= cmd->msec / 1000.0f;
		pto->m_flNextSecondaryAttack	-= cmd->msec / 1000.0f;
		pto->m_flTimeWeaponIdle			-= cmd->msec / 1000.0f;


		if( pto->m_flPumpTime != -9999.0f )
		{
			pto->m_flPumpTime -= cmd->msec / 1000.0f;
			if( pto->m_flPumpTime < -1.0f )
				pto->m_flPumpTime = 1.0f;
		}

		if ( pto->m_fNextAimBonus < -1.0 )
		{
			pto->m_fNextAimBonus = -1.0;
		}

		if ( pto->m_flNextPrimaryAttack < -1.0 )
		{
			pto->m_flNextPrimaryAttack = -1.0;
		}

		if ( pto->m_flNextSecondaryAttack < -0.001 )
		{
			pto->m_flNextSecondaryAttack = -0.001;
		}

		if ( pto->m_flTimeWeaponIdle < -0.001 )
		{
			pto->m_flTimeWeaponIdle = -0.001;
		}

		if ( pto->m_flNextReload < -0.001 )
		{
			pto->m_flNextReload = -0.001;
		}

		/*if ( pto->fuser1 < -0.001 )
		{
			pto->fuser1 = -0.001;
		}*/
	}

	// m_flNextAttack is now part of the weapons, but is part of the player instead
	to->client.m_flNextAttack -= cmd->msec / 1000.0f;
	if ( to->client.m_flNextAttack < -0.001 )
	{
		to->client.m_flNextAttack = -0.001;
	}

	// Wipe it so we can't use it after this frame
	g_finalstate = NULL;
}

/*
=====================
HUD_PostRunCmd

Client calls this during prediction, after it has moved the player and updated any info changed into to->
time is the current client clock based on prediction
cmd is the command that caused the movement, etc
runfuncs is 1 if this is the first time we've predicted this command.  If so, sounds and effects should play, otherwise, they should
be ignored
=====================
*/
void DLLEXPORT HUD_PostRunCmd( local_state_t *from, local_state_t *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed )
{
	g_runfuncs = runfuncs;

	HUD_WeaponsPostThink( from, to, cmd, time, random_seed );
	to->client.fov = g_lastFOV;

	if ( g_runfuncs )
	{
		g_gaitseq	= to->playerstate.gaitsequence;
		g_rseq		= to->playerstate.sequence;
		g_clang		= cmd->viewangles;
		g_clorg		= to->playerstate.origin;
	}
}

```

`cl_dll/death.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// death notice
//
#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>
#include "draw_util.h"

float color[3];

struct DeathNoticeItem {
	char szKiller[MAX_PLAYER_NAME_LENGTH*2];
	char szVictim[MAX_PLAYER_NAME_LENGTH*2];
	int iId;	// the index number of the associated sprite
	bool bSuicide;
	bool bTeamKill;
	bool bNonPlayerKill;
	float flDisplayTime;
	float *KillerColor;
	float *VictimColor;
	int iHeadShotId;
};

#define MAX_DEATHNOTICES	4
static int DEATHNOTICE_DISPLAY_TIME = 6;

#define DEATHNOTICE_TOP		32

DeathNoticeItem rgDeathNoticeList[ MAX_DEATHNOTICES + 1 ];

int CHudDeathNotice :: Init( void )
{
	gHUD.AddHudElem( this );

	HOOK_MESSAGE( gHUD.m_DeathNotice, DeathMsg );

	hud_deathnotice_time = CVAR_CREATE( "hud_deathnotice_time", "6", FCVAR_ARCHIVE );
	m_iFlags = 0;

	return 1;
}


void CHudDeathNotice :: InitHUDData( void )
{
	memset( rgDeathNoticeList, 0, sizeof(rgDeathNoticeList) );
}


int CHudDeathNotice :: VidInit( void )
{
	m_HUD_d_skull = gHUD.GetSpriteIndex( "d_skull" );
	m_HUD_d_headshot = gHUD.GetSpriteIndex("d_headshot");

	return 1;
}

int CHudDeathNotice :: Draw( float flTime )
{
	int x, y, r, g, b, i;

	for( i = 0; i < MAX_DEATHNOTICES; i++ )
	{
		if ( rgDeathNoticeList[i].iId == 0 )
			break;  // we've gone through them all

		if ( rgDeathNoticeList[i].flDisplayTime < flTime )
		{ // display time has expired
			// remove the current item from the list
			memmove( &rgDeathNoticeList[i], &rgDeathNoticeList[i+1], sizeof(DeathNoticeItem) * (MAX_DEATHNOTICES - i) );
			i--;  // continue on the next item;  stop the counter getting incremented
			continue;
		}

		rgDeathNoticeList[i].flDisplayTime = min( rgDeathNoticeList[i].flDisplayTime, flTime + DEATHNOTICE_DISPLAY_TIME );

		// Hide when scoreboard drawing. It will break triapi
		//if ( gViewPort && gViewPort->AllowedToPrintText() )
		//if ( !gHUD.m_iNoConsolePrint )
		{
			// Draw the death notice
			if( !g_iUser1 )
			{
				y = YRES(DEATHNOTICE_TOP) + 2 + (20 * i);  //!!!
			}
			else
			{
				y = ScreenHeight / 5 + 2 + (20 * i);
			}

			int id = (rgDeathNoticeList[i].iId == -1) ? m_HUD_d_skull : rgDeathNoticeList[i].iId;
			x = ScreenWidth - DrawUtils::ConsoleStringLen(rgDeathNoticeList[i].szVictim) - (gHUD.GetSpriteRect(id).Width());
			if( rgDeathNoticeList[i].iHeadShotId )
				x -= gHUD.GetSpriteRect(m_HUD_d_headshot).Width();

			if ( !rgDeathNoticeList[i].bSuicide )
			{
				x -= (5 + DrawUtils::ConsoleStringLen( rgDeathNoticeList[i].szKiller ) );

				// Draw killers name
				if ( rgDeathNoticeList[i].KillerColor )
					DrawUtils::SetConsoleTextColor( rgDeathNoticeList[i].KillerColor[0], rgDeathNoticeList[i].KillerColor[1], rgDeathNoticeList[i].KillerColor[2] );
				x = 5 + DrawUtils::DrawConsoleString( x, y, rgDeathNoticeList[i].szKiller );
			}

			r = 255;  g = 80;	b = 0;
			if ( rgDeathNoticeList[i].bTeamKill )
			{
				r = 10;	g = 240; b = 10;  // display it in sickly green
			}

			// Draw death weapon
			SPR_Set( gHUD.GetSprite(id), r, g, b );
			SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect(id) );

			x += (gHUD.GetSpriteRect(id).Width());

			if( rgDeathNoticeList[i].iHeadShotId)
			{
				SPR_Set( gHUD.GetSprite(m_HUD_d_headshot), r, g, b );
				SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect(m_HUD_d_headshot));
				x += (gHUD.GetSpriteRect(m_HUD_d_headshot).Width());
			}

			// Draw victims name (if it was a player that was killed)
			if (!rgDeathNoticeList[i].bNonPlayerKill)
			{
				if ( rgDeathNoticeList[i].VictimColor )
					DrawUtils::SetConsoleTextColor( rgDeathNoticeList[i].VictimColor[0], rgDeathNoticeList[i].VictimColor[1], rgDeathNoticeList[i].VictimColor[2] );
				x = DrawUtils::DrawConsoleString( x, y, rgDeathNoticeList[i].szVictim );
			}
		}
	}

	if( i == 0 )
		m_iFlags &= ~HUD_DRAW; // disable hud item

	return 1;
}

// This message handler may be better off elsewhere
int CHudDeathNotice :: MsgFunc_DeathMsg( const char *pszName, int iSize, void *pbuf )
{
	m_iFlags |= HUD_DRAW;

	BufferReader reader( pszName, pbuf, iSize );

	int killer = reader.ReadByte();
	int victim = reader.ReadByte();
	int headshot = reader.ReadByte();

	char killedwith[32];
	strncpy( killedwith, "d_", sizeof(killedwith) );
	strncat( killedwith, reader.ReadString(), sizeof( killedwith ) - 2 );

	//if (gViewPort)
	//	gViewPort->DeathMsg( killer, victim );
	gHUD.m_Scoreboard.DeathMsg( killer, victim );

	gHUD.m_Spectator.DeathMessage(victim);
	int i;
	for ( i = 0; i < MAX_DEATHNOTICES; i++ )
	{
		if ( rgDeathNoticeList[i].iId == 0 )
			break;
	}
	if ( i == MAX_DEATHNOTICES )
	{ // move the rest of the list forward to make room for this item
		memmove( rgDeathNoticeList, rgDeathNoticeList+1, sizeof(DeathNoticeItem) * MAX_DEATHNOTICES );
		i = MAX_DEATHNOTICES - 1;
	}

	//if (gViewPort)
		//gViewPort->GetAllPlayersInfo();
	gHUD.m_Scoreboard.GetAllPlayersInfo();

	// Get the Killer's name
	const char *killer_name = g_PlayerInfoList[ killer ].name;
	if ( !killer_name )
	{
		killer_name = "";
		rgDeathNoticeList[i].szKiller[0] = 0;
	}
	else
	{
		rgDeathNoticeList[i].KillerColor = GetClientColor( killer );
		strncpy( rgDeathNoticeList[i].szKiller, killer_name, MAX_PLAYER_NAME_LENGTH );
		rgDeathNoticeList[i].szKiller[MAX_PLAYER_NAME_LENGTH-1] = 0;
	}

	// Get the Victim's name
	const char *victim_name = NULL;
	// If victim is -1, the killer killed a specific, non-player object (like a sentrygun)
	if ( ((char)victim) != -1 )
		victim_name = g_PlayerInfoList[ victim ].name;
	if ( !victim_name )
	{
		victim_name = "";
		rgDeathNoticeList[i].szVictim[0] = 0;
	}
	else
	{
		rgDeathNoticeList[i].VictimColor = GetClientColor( victim );
		strncpy( rgDeathNoticeList[i].szVictim, victim_name, MAX_PLAYER_NAME_LENGTH );
		rgDeathNoticeList[i].szVictim[MAX_PLAYER_NAME_LENGTH-1] = 0;
	}

	// Is it a non-player object kill?
	if ( ((char)victim) == -1 )
	{
		rgDeathNoticeList[i].bNonPlayerKill = true;

		// Store the object's name in the Victim slot (skip the d_ bit)
		strncpy( rgDeathNoticeList[i].szVictim, killedwith+2, sizeof(killedwith) );
	}
	else
	{
		if ( killer == victim || killer == 0 )
			rgDeathNoticeList[i].bSuicide = true;

		if ( !strncmp( killedwith, "d_teammate", sizeof(killedwith)  ) )
			rgDeathNoticeList[i].bTeamKill = true;
	}

	rgDeathNoticeList[i].iHeadShotId = headshot;

	// Find the sprite in the list
	int spr = gHUD.GetSpriteIndex( killedwith );

	rgDeathNoticeList[i].iId = spr;

	rgDeathNoticeList[i].flDisplayTime = gHUD.m_flTime + hud_deathnotice_time->value;


	if (rgDeathNoticeList[i].bNonPlayerKill)
	{
		ConsolePrint( rgDeathNoticeList[i].szKiller );
		ConsolePrint( " killed a " );
		ConsolePrint( rgDeathNoticeList[i].szVictim );
		ConsolePrint( "\n" );
	}
	else
	{
		// record the death notice in the console
		if ( rgDeathNoticeList[i].bSuicide )
		{
			ConsolePrint( rgDeathNoticeList[i].szVictim );

			if ( !strncmp( killedwith, "d_world", sizeof(killedwith)  ) )
			{
				ConsolePrint( " died" );
			}
			else
			{
				ConsolePrint( " killed self" );
			}
		}
		else if ( rgDeathNoticeList[i].bTeamKill )
		{
			ConsolePrint( rgDeathNoticeList[i].szKiller );
			ConsolePrint( " killed his teammate " );
			ConsolePrint( rgDeathNoticeList[i].szVictim );
		}
		else
		{
			if( headshot )
				ConsolePrint( "*** ");
			ConsolePrint( rgDeathNoticeList[i].szKiller );
			ConsolePrint( " killed " );
			ConsolePrint( rgDeathNoticeList[i].szVictim );
		}

		if ( *killedwith && (*killedwith > 13 ) && strncmp( killedwith, "d_world", sizeof(killedwith) ) && !rgDeathNoticeList[i].bTeamKill )
		{
			if ( headshot )
				ConsolePrint(" with a headshot from ");
			else
				ConsolePrint(" with ");

			ConsolePrint( killedwith+2 ); // skip over the "d_" part
		}

		if( headshot ) ConsolePrint( " ***");
		ConsolePrint( "\n" );
	}

	return 1;
}





```

`cl_dll/demo.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#include "hud.h"
#include "cl_util.h"
#include "demo.h"
#include "demo_api.h"
#include <memory.h>

int g_demosniper = 0;
int g_demosniperdamage = 0;
float g_demosniperorg[3];
float g_demosniperangles[3];
float g_demozoom;

// FIXME:  There should be buffer helper functions to avoid all of the *(int *)& crap.

/*
=====================
Demo_WriteBuffer

Write some data to the demo stream
=====================
*/
void Demo_WriteBuffer( int type, int size, unsigned char *buffer )
{
	int pos = 0;
	unsigned char buf[ 32 * 1024 ];
	*( int * )&buf[pos] = type;
	pos+=sizeof( int );

	memcpy( &buf[pos], buffer, size );

	// Write full buffer out
	gEngfuncs.pDemoAPI->WriteBuffer( size + sizeof( int ), buf );
}

/*
=====================
Demo_ReadBuffer

Engine wants us to parse some data from the demo stream
=====================
*/
void DLLEXPORT Demo_ReadBuffer( int size, unsigned char *buffer )
{
	int type;
	int i = 0;

	type = *( int * )buffer;
	i += sizeof( int );
	switch ( type )
	{
	case TYPE_SNIPERDOT:
		g_demosniper = *(int * )&buffer[ i ];
		i += sizeof( int );
		
		if ( g_demosniper )
		{
			g_demosniperdamage = *( int * )&buffer[ i ];
			i += sizeof( int );

			g_demosniperangles[ 0 ] = *(float *)&buffer[i];
			i += sizeof( float );
			g_demosniperangles[ 1 ] = *(float *)&buffer[i];
			i += sizeof( float );
			g_demosniperangles[ 2 ] = *(float *)&buffer[i];
			i += sizeof( float );
			g_demosniperorg[ 0 ] = *(float *)&buffer[i];
			i += sizeof( float );
			g_demosniperorg[ 1 ] = *(float *)&buffer[i];
			i += sizeof( float );
			g_demosniperorg[ 2 ] = *(float *)&buffer[i];
			i += sizeof( float );
		}
		break;
	case TYPE_ZOOM:
		g_demozoom = *(float * )&buffer[ i ];
		i += sizeof( float );
		break;
	default:
		gEngfuncs.Con_DPrintf( "Unknown demo buffer type, skipping.\n" );
		break;
	}
}

```

`cl_dll/draw_util.cpp`:

```cpp
/*
draw_util.cpp - Draw Utils
Copyright (C) 2016 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/

#include "hud.h"
#include "cl_util.h"
#include "draw_util.h"
#include "triangleapi.h"
#include <string.h>
#include <ctype.h>
#include "utflib.h"

float DrawUtils::color[3];

#define IsColorString( p )	( p && *( p ) == '^' && *(( p ) + 1) && *(( p ) + 1) >= '0' && *(( p ) + 1 ) <= '9' )
#define ColorIndex( c )	((( c ) - '0' ) & 7 )

// console color typeing
byte g_color_table[][4] =
{
{100, 100, 100, 255},	// should be black, but hud font is additive, so printing black characters is impossible
{255,   0,   0, 255},	// red
{  0, 255,   0, 255},	// green
{255, 255,   0, 255},	// yellow
{  0,   0, 255, 255},	// blue
{  0, 255, 255, 255},	// cyan
{255,   0, 255, 255},	// magenta
{240, 180,  24, 255},	// default color (can be changed by user)
};

int g_codepage = 0;
qboolean g_accept_utf8;

cvar_t *con_charset;
cvar_t *cl_charset;

/*
============================
Con_UtfProcessChar

Convert utf char to current font's single-byte encoding
============================
*/
int Con_UtfProcessCharForce( int in )
{
	// TODO: get rid of global state where possible
	static utfstate_t state = { 0 };

	uint32_t ch = Q_DecodeUTF8( &state, in );

	if( g_codepage == 1251 )
		return Q_UnicodeToCP1251( ch );
	if( g_codepage == 1252 )
		return Q_UnicodeToCP1252( ch );

	return '?'; // not implemented yet
}

int Con_UtfProcessChar( int in )
{
	if( !g_accept_utf8 ) // incoming character is not a UTF-8 sequence
		return in;

	// otherwise, decode it and convert to selected codepage
	return Con_UtfProcessCharForce( in );
}

int DrawUtils::DrawHudString( int xpos, int ypos, int iMaxX, const char *str, int r, int g, int b, float scale, bool drawing )
{
	int first_xpos = xpos;
	char *szIt = (char *)str;

	Con_UtfProcessChar( 0 );

	// draw the string until we hit the null character or a newline character
	for ( ; *szIt != 0 && *szIt != '\n'; szIt++ )
	{
		if ( *szIt == '\\' && *( szIt + 1 ) != '\n' && *( szIt + 1 ) != 0 )
		{
			// an escape character

			switch ( *( ++szIt ) )
			{
			case 'y':
				UnpackRGB( r, g, b, RGB_YELLOWISH );
				continue;
			case 'r':
				UnpackRGB( r, g, b, RGB_REDISH );
				continue;
			case 'w':
				UnpackRGB( r, g, b, RGB_WHITE );
				continue;
			case 'd':
				UnpackRGB( r, g, b, RGB_GRAY );
				continue;
			case 'R':
				//if ( drawing )
					//return xpos;
				//return DrawHudStringReverse( iMaxX, ypos, first_xpos, ++szIt, r, g, b, scale, true ); // set 'drawing' to true, to stop when '\R' is catched
				xpos = iMaxX - gHUD.GetCharWidth( 'M' ) * 10;
				++szIt;
			}
		}
		else if( IsColorString( szIt ) )
		{
			szIt++;
			if( gHUD.hud_colored->value )
			{
				r = g_color_table[ColorIndex( *szIt )][0];
				g = g_color_table[ColorIndex( *szIt )][1];
				b = g_color_table[ColorIndex( *szIt )][2];
			}
			continue;
		}

		int uch = Con_UtfProcessChar( (unsigned char)*szIt );

		//if ( !uch )
			//continue;

		int next = xpos + gHUD.GetCharWidth( uch ); // variable-width fonts look cool

		if ( next > iMaxX )
			return xpos;

		xpos += TextMessageDrawChar( xpos, ypos, ( unsigned char )*szIt, r, g, b, scale );
	}

	return xpos;
}


int DrawUtils::DrawHudStringReverse( int xpos, int ypos, int iMinX, const char *szString, int r, int g, int b, float scale, bool drawing )
{
	int first_xpos = xpos;

	// iterate through the string in reverse
	for ( signed int i = strlen( szString ); i >= 0; i-- )
	{
		if ( i > 1 )
		{
			if( szString[i - 1] == '\\' )
			{
				// an escape character

				switch ( szString[i] )
				{
				case 'y':
					UnpackRGB( r, g, b, RGB_YELLOWISH );
					break;
				case 'r':
					UnpackRGB( r, g, b, RGB_REDISH );
					break;
				case 'w':
					UnpackRGB( r, g, b, RGB_WHITE );
					break;
				case 'R':
					if ( drawing )
						return xpos;

					return DrawHudString( iMinX, ypos, first_xpos, &szString[i - 1], r, g, b, scale, true ); // set 'drawing' to true, to stop when '\R' is catched
				case 'd':
					UnpackRGB( r, g, b, RGB_GRAY );
					break;
				}
				continue;
			}
			else if( IsColorString( szString - 1 ) )
			{
				if( gHUD.hud_colored->value )
				{
					r = g_color_table[ColorIndex( *szString )][0];
					g = g_color_table[ColorIndex( *szString )][1];
					b = g_color_table[ColorIndex( *szString )][2];
				}
				i--;
				continue;
			}
		}

		int uch = Con_UtfProcessChar( (unsigned char)szString[i] );

		/*if ( !uch )
			continue;*/

		int next = xpos - gHUD.GetCharWidth( uch ); // variable-width fonts look cool

		if ( next < iMinX )
			return xpos;

		xpos = next;

		TextMessageDrawChar( xpos, ypos, (unsigned char)szString[i], r, g, b );
	}

	return xpos;
}

int DrawUtils::DrawHudNumber( int x, int y, int iFlags, int iNumber, int r, int g, int b )
{
	int iWidth = gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ).Width();
	int k;

	if ( iNumber > 0 )
	{
		// SPR_Draw 100's
		if ( iNumber >= 100 )
		{
			k = iNumber / 100;
			SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 + k ), r, g, b );
			SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 + k ) );
			x += iWidth;
		}
		else if ( iFlags & ( DHN_3DIGITS ) )
		{
			//SPR_DrawAdditive( 0, x, y, &rc );
			x += iWidth;
		}

		// SPR_Draw 10's
		if ( iNumber >= 10 )
		{
			k = ( iNumber % 100 ) / 10;
			SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 + k ), r, g, b );
			SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 + k ) );
			x += iWidth;
		}
		else if ( iFlags & ( DHN_3DIGITS | DHN_2DIGITS ) )
		{
			//SPR_DrawAdditive( 0, x, y, &rc );
			x += iWidth;
		}

		// SPR_Draw ones
		k = iNumber % 10;
		SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 + k ), r, g, b );
		SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 + k ) );
		x += iWidth;
	}
	else if ( iFlags & DHN_DRAWZERO )
	{
		SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 ), r, g, b );

		// SPR_Draw 100's
		if ( iFlags & ( DHN_3DIGITS ) )
		{
			//SPR_DrawAdditive( 0, x, y, &rc );
			x += iWidth;
		}

		if ( iFlags & ( DHN_3DIGITS | DHN_2DIGITS ) )
		{
			//SPR_DrawAdditive( 0, x, y, &rc );
			x += iWidth;
		}

		// SPR_Draw ones

		SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ) );
		x += iWidth;
	}

	return x;
}

int DrawUtils::DrawHudNumber2( int x, int y, bool DrawZero, int iDigits, int iNumber, int r, int g, int b )
{
	int iWidth = gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ).Width();
	x += ( iDigits - 1 ) * iWidth;

	int ResX = x + iWidth;
	do
	{
		int k = iNumber % 10;
		iNumber /= 10;
		SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 + k ), r, g, b );
		SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 + k ) );
		x -= iWidth;
		iDigits--;
	} while ( iNumber > 0 || ( iDigits > 0 && DrawZero ) );

	return ResX;
}

int DrawUtils::DrawHudNumber2( int x, int y, int iNumber, int r, int g, int b )
{
	int iWidth = gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ).Width();

	int iDigits = 0;
	int temp    = iNumber;
	do
	{
		iDigits++;
		temp /= 10;
	} while ( temp > 0 );

	x += ( iDigits - 1 ) * iWidth;

	int ResX = x + iWidth;
	do
	{
		int k = iNumber % 10;
		iNumber /= 10;
		SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 + k ), r, g, b );
		SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 + k ) );
		x -= iWidth;
	} while ( iNumber > 0 );

	return ResX;
}

void DrawUtils::Draw2DQuad( float x1, float y1, float x2, float y2 )
{
	// REMOVE WHEN NANOGL BUG WILL BE FIXED
	gEngfuncs.pTriAPI->Begin( TRI_QUADS );
	// REMOVE WHEN NANOGL BUG WILL BE FIXED

	gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
	gEngfuncs.pTriAPI->Vertex3f( x1, y1, 0 );

	gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
	gEngfuncs.pTriAPI->Vertex3f( x1, y2, 0 );

	gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
	gEngfuncs.pTriAPI->Vertex3f( x2, y2, 0 );

	gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
	gEngfuncs.pTriAPI->Vertex3f( x2, y1, 0 );

	// REMOVE WHEN NANOGL BUG WILL BE FIXED
	gEngfuncs.pTriAPI->End( );
	// REMOVE WHEN NANOGL BUG WILL BE FIXED

}

int DrawUtils::HudStringLen( const char *szIt, float scale )
{
	int l;

	Con_UtfProcessChar( 0 );

	// count length until we hit the null character or a newline character
	for ( l = 0; *szIt != 0 && *szIt != '\n'; szIt++ )
	{
		if( szIt[0] == '\\' && szIt[1] != '\n' &&
			(szIt[1] == 'y' || szIt[1] == 'w' || szIt[1] == 'd' || szIt[1] == 'R') ) // not sure is reversing handled correctly
		{
			szIt++;
			continue;
		}

		if( szIt[0] == '^' && isdigit( szIt[1] ) ) // suck down, unreadable nicknames. Check even if hud_colored is off
		{
			szIt++;
			continue;
		}

		int uch = Con_UtfProcessChar( (unsigned char)*szIt );

		if ( !uch )
			continue;

		l += gHUD.GetCharWidth( uch );
	}

	return l;
}

```

`cl_dll/entity.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// Client side entity management functions

#include <memory.h>

#include "hud.h"
#include "pm_defs.h"
#include "pmtrace.h"
#include "pm_shared.h"
#include "cl_util.h"
#include "const.h"
#include "entity_types.h"
#include "studio_event.h" // def. of mstudioevent_t
#include "r_efx.h"
#include "event_api.h"
#include "com_model.h"
#include "view.h"
#include "eventscripts.h"
#include "com_weapons.h"
#include "ev_hldm.h"

extern vec3_t v_origin;

int iOnTrain[MAX_PLAYERS];

/*
========================
HUD_AddEntity
	Return 0 to filter entity from visible list for rendering
========================
*/
int DLLEXPORT HUD_AddEntity( int type, struct cl_entity_s *ent, const char *modelname )
{
	switch ( type )
	{
	case ET_NORMAL:
	case ET_PLAYER:
		if( ent->player && iOnTrain[ent->index] )
		{
			VectorCopy(ent->curstate.origin, ent->origin);
			VectorCopy(ent->curstate.angles, ent->angles);
		}
		break;
	case ET_BEAM:
	case ET_TEMPENTITY:
	case ET_FRAGMENTED:
	default:
		break;
	}
	// each frame every entity passes this function, so the overview hooks it to filter the overview entities
	// in spectator mode:
	// each frame every entity passes this function, so the overview hooks 
	// it to filter the overview entities

	if ( g_iUser1 )
	{
		gHUD.m_Spectator.AddOverviewEntity( type, ent, modelname );

		if ( (	g_iUser1 == OBS_IN_EYE || gHUD.m_Spectator.m_pip->value == INSET_IN_EYE ) &&
				ent->index == g_iUser2 )
			return 0;	// don't draw the player we are following in eye

	}

	return 1;
}

/*
=========================
HUD_TxferLocalOverrides

The server sends us our origin with extra precision as part of the clientdata structure, not during the normal
playerstate update in entity_state_t.  In order for these overrides to eventually get to the appropriate playerstate
structure, we need to copy them into the state structure at this point.
=========================
*/
void DLLEXPORT HUD_TxferLocalOverrides( struct entity_state_s *state, const struct clientdata_s *client )
{
	VectorCopy( client->origin, state->origin );

	// Spectator
	state->iuser1 = client->iuser1;
	state->iuser2 = client->iuser2;

	// Duck prevention
	state->iuser3 = client->iuser3;

	// Fire prevention
	state->iuser4 = client->iuser4;
}

/*
=========================
HUD_ProcessPlayerState

We have received entity_state_t for this player over the network.  We need to copy appropriate fields to the
playerstate structure
=========================
*/
void DLLEXPORT HUD_ProcessPlayerState( struct entity_state_s *dst, const struct entity_state_s *src )
{
	// Copy in network data
	VectorCopy( src->origin, dst->origin );
	VectorCopy( src->angles, dst->angles );

	VectorCopy( src->velocity, dst->velocity );

	dst->frame					= src->frame;
	dst->modelindex				= src->modelindex;
	dst->skin					= src->skin;
	dst->effects				= src->effects;
	dst->weaponmodel			= src->weaponmodel;
	dst->movetype				= src->movetype;
	dst->sequence				= src->sequence;
	dst->animtime				= src->animtime;
	
	dst->solid					= src->solid;
	
	dst->rendermode				= src->rendermode;
	dst->renderamt				= src->renderamt;	
	dst->rendercolor.r			= src->rendercolor.r;
	dst->rendercolor.g			= src->rendercolor.g;
	dst->rendercolor.b			= src->rendercolor.b;
	dst->renderfx				= src->renderfx;

	dst->framerate				= src->framerate;
	dst->body					= src->body;

	memcpy( &dst->controller[0], &src->controller[0], 4 * sizeof( byte ) );
	memcpy( &dst->blending[0], &src->blending[0], 2 * sizeof( byte ) );

	VectorCopy( src->basevelocity, dst->basevelocity );

	dst->friction				= src->friction;
	dst->gravity				= src->gravity;
	dst->gaitsequence			= src->gaitsequence;
	dst->spectator				= src->spectator;
	dst->usehull				= src->usehull;
	dst->playerclass			= src->playerclass;
	dst->team					= src->team;
	dst->colormap				= src->colormap;

	// Save off some data so other areas of the Client DLL can get to it
	cl_entity_t *player = gEngfuncs.GetLocalPlayer();	// Get the local player's index
	if( dst->number == player->index )
	{
		g_iTeamNumber = g_PlayerExtraInfo[dst->number].teamnumber;

		dst->iuser1 = g_iUser1 = src->iuser1;
		dst->iuser2 = g_iUser2 = src->iuser2;
		dst->iuser3 = g_iUser3 = src->iuser3;
	}
	dst->fuser2					= src->fuser2;
	if( src->number > 0 && src->number < MAX_PLAYERS )
	{
		iOnTrain[src->number]		= src->iuser4;
	}
}

/*
=========================
HUD_TxferPredictionData

Because we can predict an arbitrary number of frames before the server responds with an update, we need to be able to copy client side prediction data in
 from the state that the server ack'd receiving, which can be anywhere along the predicted frame path ( i.e., we could predict 20 frames into the future and the server ack's
 up through 10 of those frames, so we need to copy persistent client-side only state from the 10th predicted frame to the slot the server
 update is occupying.
=========================
*/
void DLLEXPORT HUD_TxferPredictionData ( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd )
{
	ps->oldbuttons = pps->oldbuttons;
	ps->flFallVelocity = pps->flFallVelocity;
	ps->iStepLeft = pps->iStepLeft;
	ps->playerclass	= pps->playerclass;
	ps->iuser4 = pps->iuser4;

	pcd->viewmodel = ppcd->viewmodel;
	pcd->m_iId = ppcd->m_iId;
	pcd->ammo_shells = ppcd->ammo_shells;
	pcd->ammo_nails	= ppcd->ammo_nails;
	pcd->ammo_cells	= ppcd->ammo_cells;
	pcd->ammo_rockets = ppcd->ammo_rockets;
	pcd->m_flNextAttack	= ppcd->m_flNextAttack;
	pcd->fov = ppcd->fov;
	pcd->weaponanim = ppcd->weaponanim;
	pcd->tfstate = ppcd->tfstate;
	pcd->maxspeed = ppcd->maxspeed;
	pcd->deadflag = ppcd->deadflag;
	if( gEngfuncs.IsSpectateOnly() )
	{
		pcd->iuser1 = g_iUser1;	// observer mode
		pcd->iuser2 = g_iUser2; // first target
		pcd->iuser3 = g_iUser3; // second target
	}
	else
	{
		pcd->iuser1	= ppcd->iuser1;
		pcd->iuser2	= ppcd->iuser2;
		pcd->iuser3 = ppcd->iuser3;
	}
	pcd->iuser4 = ppcd->iuser4;
	pcd->fuser2	= ppcd->fuser2;
	pcd->fuser3	= ppcd->fuser3;
	pcd->vuser2 = ppcd->vuser2;
	pcd->vuser3 = ppcd->vuser3;
	pcd->vuser4 = ppcd->vuser4;

	memcpy( wd, pwd, sizeof( weapon_data_t ) * 32 );
}

/*
=========================
HUD_CreateEntities
	
Gives us a chance to add additional entities to the render this frame
=========================
*/
void DLLEXPORT HUD_CreateEntities( void )
{
	// Add in any game specific objects

	GetClientVoiceHud()->CreateEntities();
}

/*
==============
CL_MuzzleFlash

Do muzzleflash
==============
*/
// TODO: Broken!
#define MAX_MUZZLEFLASH 4
void CL_MuzzleFlash( cl_entity_t *entity, vec3_t pos, int type )
{
	const char *muzzleflash;

	TEMPENTITY	*pTemp;
	int		index, frameCount;
	float		scale;

	extern int g_weaponselect_frames;
	if( g_weaponselect_frames )
		return;

	index = bound( 0, type % 5, MAX_MUZZLEFLASH - 1 );
	scale = (type / 10) * 0.1f;
	if( scale == 0.0f ) scale = 0.5f;

	switch( index )
	{
	case 0:
		muzzleflash = "sprites/muzzleflash1.spr";
		break;
	case 1:
		muzzleflash = "sprites/muzzleflash2.spr";
		break;
	case 2:
		muzzleflash = "sprites/muzzleflash3.spr";
		break;
	case 3:
		muzzleflash = "sprites/muzzleflash.spr";
		break;
	}

	model_t *model = gEngfuncs.CL_LoadModel( muzzleflash, 0 );
	if( !model ) return;

	frameCount = model->numframes;

	// must set position for right culling on render
	pTemp = gEngfuncs.pEfxAPI->CL_TempEntAllocHigh( pos, model );
	if( !pTemp ) return;
	pTemp->entity.curstate.rendermode = kRenderTransAdd;
	pTemp->entity.curstate.renderamt = 255;
	pTemp->entity.curstate.framerate = 10;
	pTemp->entity.curstate.renderfx = 0;
	pTemp->die = gEngfuncs.GetClientTime() + gHUD.m_flTimeDelta * 1.5f; // die at next frame
	pTemp->entity.curstate.frame = Com_RandomLong( 0, frameCount - 1 );
	pTemp->flags |= FTENT_SPRANIMATE|FTENT_SPRANIMATELOOP;
	pTemp->frameMax = frameCount - 1;

	if( index == 0 )
	{
		// Rifle flash
		pTemp->entity.curstate.scale = scale * Com_RandomFloat( 0.5f, 0.6f );
		pTemp->entity.angles[2] = 90 * Com_RandomLong( 0, 3 );
	}
	else
	{
		pTemp->entity.curstate.scale = scale;
		pTemp->entity.angles[2] = Com_RandomLong( 0, 359 );
	}

	if( gHUD.cl_gunsmoke->value && EV_IsLocal( entity->index ))
	{
		Vector smoke_origin = pos;
		Vector forward;

		AngleVectors( v_angles, forward, NULL, NULL );

		float scale = pTemp->entity.curstate.scale;

		TEMPENTITY *te;
		if( index == 1 )
		{
			te = EV_CS16Client_CreateSmoke( SMOKE_PISTOL, smoke_origin, forward, 0,  scale, 7,7,7, false, g_vPlayerVelocity );
			if( te ) te->entity.angles[2] = pTemp->entity.angles[2];
			te = EV_CS16Client_CreateSmoke( SMOKE_PISTOL, smoke_origin, forward, 20, scale + 0.1, 10,10,10, false, g_vPlayerVelocity );
			if( te ) te->entity.angles[2] = pTemp->entity.angles[2];
			te = EV_CS16Client_CreateSmoke( SMOKE_PISTOL, smoke_origin, forward, 40, scale, 13,13,13, false, g_vPlayerVelocity );
			if( te ) te->entity.angles[2] = pTemp->entity.angles[2];
		}
		else
		{
			te = EV_CS16Client_CreateSmoke( SMOKE_RIFLE, smoke_origin, forward, 3, scale, 20, 20, 20, false, g_vPlayerVelocity );

			if( te ) te->entity.angles[2] = pTemp->entity.angles[2];
		}
	}
}

/*
=========================
HUD_StudioEvent

The entity's studio model description indicated an event was
fired during this frame, handle the event by it's tag ( e.g., muzzleflash, sound )
=========================
*/
void DLLEXPORT HUD_StudioEvent( const struct mstudioevent_s *event, struct cl_entity_s *entity )
{
// #define CL_MuzzleFlash( x, y, z ) gEngfuncs.pEfxAPI->R_MuzzleFlash( y, z )
	switch( event->event )
	{
	case 5001:
		gEngfuncs.pEfxAPI->R_MuzzleFlash( (float *)&entity->attachment[0], atoi( event->options) );
		// CL_MuzzleFlash( entity, (float *)&entity->attachment[0], atoi( event->options) );
		break;
	case 5011:
		gEngfuncs.pEfxAPI->R_MuzzleFlash( (float *)&entity->attachment[1], atoi( event->options) );
		// CL_MuzzleFlash( entity, (float *)&entity->attachment[1], atoi( event->options) );
		break;
	case 5021:
		gEngfuncs.pEfxAPI->R_MuzzleFlash( (float *)&entity->attachment[2], atoi( event->options) );
		// CL_MuzzleFlash( entity, (float *)&entity->attachment[2], atoi( event->options) );
		break;
	case 5031:
		gEngfuncs.pEfxAPI->R_MuzzleFlash( (float *)&entity->attachment[3], atoi( event->options) );
		// CL_MuzzleFlash( entity, (float *)&entity->attachment[3], atoi( event->options) );
		break;
	case 5002:
		gEngfuncs.pEfxAPI->R_SparkEffect( (float *)&entity->attachment[0], atoi( event->options), -100, 100 );
		break;
	// Client side sound
	case 5004:		
		if( entity == gEngfuncs.GetLocalPlayer() ||
			entity == gEngfuncs.GetViewModel() )
		{
			gEngfuncs.pfnPlaySoundByName( (char *)event->options, 1.0 );
		}
		else
		{
			gEngfuncs.pfnPlaySoundByNameAtLocation( (char *)event->options, 1.0, (float *)&entity->attachment[0] );
		}
		break;
	default:
		break;
	}
}

/*
=================
CL_UpdateTEnts

Simulation and cleanup of temporary entities
=================
*/
void DLLEXPORT HUD_TempEntUpdate (
	double frametime,   // Simulation time
	double client_time, // Absolute time on client
	double cl_gravity,  // True gravity on client
	TEMPENTITY **ppTempEntFree,   // List of freed temporary ents
	TEMPENTITY **ppTempEntActive, // List 
	int		( *Callback_AddVisibleEntity )( cl_entity_t *pEntity ),
	void	( *Callback_TempEntPlaySound )( TEMPENTITY *pTemp, float damp ) )
{
	static int gTempEntFrame = 0;
	int			i;
	TEMPENTITY	*pTemp, *pnext, *pprev;
	float		gravity, gravitySlow, life, fastFreq;

	// g_flGravity = cl_gravity;

/*
	if ( g_pParticleMan )
		g_pParticleMan->SetVariables( cl_gravity, vAngles );
*/

	// Nothing to simulate
	if ( !*ppTempEntActive )		
		return;

	// in order to have tents collide with players, we have to run the player prediction code so
	// that the client has the player list. We run this code once when we detect any COLLIDEALL 
	// tent, then set this BOOL to true so the code doesn't get run again if there's more than
	// one COLLIDEALL ent for this update. (often are).
	gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );

	// Store off the old count
	gEngfuncs.pEventAPI->EV_PushPMStates();

	// Now add in all of the players.
	gEngfuncs.pEventAPI->EV_SetSolidPlayers ( -1 );	

	// !!!BUGBUG	-- This needs to be time based
	gTempEntFrame = (gTempEntFrame+1) & 31;

	pTemp = *ppTempEntActive;

	// !!! Don't simulate while paused....  This is sort of a hack, revisit.
	if ( frametime <= 0.0 )
	{
		while ( pTemp )
		{
			if ( !(pTemp->flags & FTENT_NOMODEL ) )
			{
				Callback_AddVisibleEntity( &pTemp->entity );
			}
			pTemp = pTemp->next;
		}
		goto finish;
	}

	pprev = NULL;
	fastFreq = client_time * 5.5;
	gravity = -frametime * cl_gravity;
	gravitySlow = gravity * 0.5;

	while ( pTemp )
	{
		int active;

		active = 1;

		life = pTemp->die - client_time;
		pnext = pTemp->next;
		if ( life < 0 )
		{
			if ( pTemp->flags & FTENT_FADEOUT )
			{
				if (pTemp->entity.curstate.rendermode == kRenderNormal)
					pTemp->entity.curstate.rendermode = kRenderTransTexture;
				pTemp->entity.curstate.renderamt = pTemp->entity.baseline.renderamt * ( 1 + life * pTemp->fadeSpeed );
				if ( pTemp->entity.curstate.renderamt <= 0 )
					active = 0;

			}
			else 
				active = 0;
		}
		if ( !active )		// Kill it
		{
			pTemp->next = *ppTempEntFree;
			*ppTempEntFree = pTemp;
			if ( !pprev )	// Deleting at head of list
				*ppTempEntActive = pnext;
			else
				pprev->next = pnext;
		}
		else
		{
			pprev = pTemp;
			
			VectorCopy( pTemp->entity.origin, pTemp->entity.prevstate.origin );

			if ( pTemp->flags & FTENT_SPARKSHOWER )
			{
				// Adjust speed if it's time
				// Scale is next think time
				if ( client_time > pTemp->entity.baseline.scale )
				{
					// Show Sparks
					gEngfuncs.pEfxAPI->R_SparkEffect( pTemp->entity.origin, 8, -200, 200 );

					// Reduce life
					pTemp->entity.baseline.framerate -= 0.1;

					if ( pTemp->entity.baseline.framerate <= 0.0 )
					{
						pTemp->die = client_time;
					}
					else
					{
						// So it will die no matter what
						pTemp->die = client_time + 0.5;

						// Next think
						pTemp->entity.baseline.scale = client_time + 0.1;
					}
				}
			}
			else if ( pTemp->flags & FTENT_PLYRATTACHMENT )
			{
				cl_entity_t *pClient;

				pClient = gEngfuncs.GetEntityByIndex( pTemp->clientIndex );

				VectorAdd( pClient->origin, pTemp->tentOffset, pTemp->entity.origin );
			}
			else if ( pTemp->flags & FTENT_SINEWAVE )
			{
				pTemp->x += pTemp->entity.baseline.origin[0] * frametime;
				pTemp->y += pTemp->entity.baseline.origin[1] * frametime;

				pTemp->entity.origin[0] = pTemp->x + sin( pTemp->entity.baseline.origin[2] + client_time * pTemp->entity.prevstate.frame ) * (10*pTemp->entity.curstate.framerate);
				pTemp->entity.origin[1] = pTemp->y + sin( pTemp->entity.baseline.origin[2] + fastFreq + 0.7 ) * (8*pTemp->entity.curstate.framerate);
				pTemp->entity.origin[2] += pTemp->entity.baseline.origin[2] * frametime;
			}
			else if ( pTemp->flags & FTENT_SPIRAL )
			{
				/*
				float s, c;
				s = sin( pTemp->entity.baseline.origin[2] + fastFreq );
				c = cos( pTemp->entity.baseline.origin[2] + fastFreq );
				*/

				pTemp->entity.origin[0] += pTemp->entity.baseline.origin[0] * frametime + 8 * sin( client_time * 20 + (long long)(void*)pTemp );
				pTemp->entity.origin[1] += pTemp->entity.baseline.origin[1] * frametime + 4 * sin( client_time * 30 + (long long)(void*)pTemp );
				pTemp->entity.origin[2] += pTemp->entity.baseline.origin[2] * frametime;
			}
			
			else 
			{
				for ( i = 0; i < 3; i++ ) 
					pTemp->entity.origin[i] += pTemp->entity.baseline.origin[i] * frametime;
			}
			
			if ( pTemp->flags & FTENT_SPRANIMATE )
			{
				pTemp->entity.curstate.frame += frametime * pTemp->entity.curstate.framerate;
				if ( pTemp->entity.curstate.frame >= pTemp->frameMax )
				{
					pTemp->entity.curstate.frame = pTemp->entity.curstate.frame - (int)(pTemp->entity.curstate.frame);

					if ( pTemp->flags & 0x100000 )
					{
						pTemp = pnext;
						continue;
					}

					if ( !(pTemp->flags & FTENT_SPRANIMATELOOP) )
					{
						// this animating sprite isn't set to loop, so destroy it.
						pTemp->die = client_time;
						pTemp = pnext;
						continue;
					}
				}
			}
			else if ( pTemp->flags & FTENT_SPRCYCLE )
			{
				pTemp->entity.curstate.frame += frametime * 10;
				if ( pTemp->entity.curstate.frame >= pTemp->frameMax )
				{
					pTemp->entity.curstate.frame = pTemp->entity.curstate.frame - (int)(pTemp->entity.curstate.frame);
				}
			}
// Experiment
#if 0
			if ( pTemp->flags & FTENT_SCALE )
				pTemp->entity.curstate.framerate += 20.0 * (frametime / pTemp->entity.curstate.framerate);
#endif

			if ( pTemp->flags & FTENT_ROTATE )
			{
				pTemp->entity.angles[0] += pTemp->entity.baseline.angles[0] * frametime;
				pTemp->entity.angles[1] += pTemp->entity.baseline.angles[1] * frametime;
				pTemp->entity.angles[2] += pTemp->entity.baseline.angles[2] * frametime;

				VectorCopy( pTemp->entity.angles, pTemp->entity.latched.prevangles );
			}

			if ( pTemp->flags & (FTENT_COLLIDEALL | FTENT_COLLIDEWORLD) && !( pTemp->flags & FTENT_BODYGRAVITY ))
			{
				vec3_t	traceNormal;
				float	traceFraction = 1;

				if ( pTemp->flags & FTENT_COLLIDEALL )
				{
					pmtrace_t pmtrace;
					physent_t *pe;
				
					gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );

					gEngfuncs.pEventAPI->EV_PlayerTrace( pTemp->entity.prevstate.origin, pTemp->entity.origin, PM_STUDIO_BOX, -1, &pmtrace );

					if ( pmtrace.fraction != 1 )
					{
						pe = gEngfuncs.pEventAPI->EV_GetPhysent( pmtrace.ent );

						if ( !pmtrace.ent || ( pe->info != pTemp->clientIndex ) )
						{
							traceFraction = pmtrace.fraction;
							VectorCopy( pmtrace.plane.normal, traceNormal );

							if ( pTemp->hitcallback )
							{
								(*pTemp->hitcallback)( pTemp, &pmtrace );
							}
						}
					}
				}
				else if ( pTemp->flags & FTENT_COLLIDEWORLD )
				{
					pmtrace_t pmtrace;
					Vector *p_vEndPos;
					
					gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );

					if ( pTemp->flags & FTENT_BODYTRACE )
					{
						Vector vVel, vEndPos;

						VectorCopy( pTemp->entity.baseline.velocity, vVel );
						VectorNormalize( vVel );
						VectorMA( pTemp->entity.baseline.velocity, 36.0f, vVel, vEndPos );
						p_vEndPos = &vEndPos;
					}
					else
					{
						p_vEndPos = &pTemp->entity.origin;
					}

					gEngfuncs.pEventAPI->EV_PlayerTrace( pTemp->entity.prevstate.origin, *p_vEndPos, PM_STUDIO_BOX | PM_WORLD_ONLY, -1, &pmtrace );

					if ( pmtrace.fraction != 1 )
					{
						traceFraction = pmtrace.fraction;
						VectorCopy( pmtrace.plane.normal, traceNormal );

						if ( pTemp->flags & FTENT_SPARKSHOWER )
						{
							// Chop spark speeds a bit more
							//
							VectorScale( pTemp->entity.baseline.origin, 0.6, pTemp->entity.baseline.origin );

							if ( pTemp->entity.baseline.origin.Length() < 10 )
							{
								pTemp->entity.baseline.framerate = 0.0;								
							}
						}

						if ( pTemp->hitcallback )
						{
							(*pTemp->hitcallback)( pTemp, &pmtrace );
						}
					}
				}
				
				if ( traceFraction != 1 )	// Decent collision now, and damping works
				{
					float  proj, damp;

					// Place at contact point
					VectorMA( pTemp->entity.prevstate.origin, traceFraction*frametime, pTemp->entity.baseline.origin, pTemp->entity.origin );
					// Damp velocity
					damp = pTemp->bounceFactor;
					if ( pTemp->flags & (FTENT_GRAVITY|FTENT_SLOWGRAVITY) )
					{
						damp *= 0.5;
						if ( traceNormal[2] > 0.9 )		// Hit floor?
						{
							if ( pTemp->entity.baseline.origin[2] <= 0 && pTemp->entity.baseline.origin[2] >= gravity*3 )
							{
								damp = 0;		// Stop
								pTemp->flags &= ~(FTENT_ROTATE|FTENT_GRAVITY|FTENT_SLOWGRAVITY|FTENT_COLLIDEWORLD|FTENT_SMOKETRAIL);
								pTemp->entity.angles[0] = 0;
								pTemp->entity.angles[2] = 0;
							}
						}
					}

					if (pTemp->hitSound)
					{
						Callback_TempEntPlaySound(pTemp, damp);
					}

					if (pTemp->flags & FTENT_COLLIDEKILL)
					{
						// die on impact
						pTemp->flags &= ~FTENT_FADEOUT;	
						pTemp->die = client_time;			
					}
					else
					{
						// Reflect velocity
						if ( damp != 0 )
						{
							proj = DotProduct( pTemp->entity.baseline.origin, traceNormal );
							VectorMA( pTemp->entity.baseline.origin, -proj*2, traceNormal, pTemp->entity.baseline.origin );
							// Reflect rotation (fake)

							pTemp->entity.angles[1] = -pTemp->entity.angles[1];
						}
						
						if ( damp != 1 )
						{

							VectorScale( pTemp->entity.baseline.origin, damp, pTemp->entity.baseline.origin );

							if ( !( pTemp->flags & FTENT_BODYTRACE ))
								VectorScale( pTemp->entity.angles, 0.9f, pTemp->entity.angles );
						}
					}
				}
			}


			if ( (pTemp->flags & FTENT_FLICKER) && gTempEntFrame == pTemp->entity.curstate.effects )
			{
				dlight_t *dl = gEngfuncs.pEfxAPI->CL_AllocDlight (0);
				VectorCopy (pTemp->entity.origin, dl->origin);
				dl->radius = 60;
				dl->color.r = 255;
				dl->color.g = 120;
				dl->color.b = 0;
				dl->die = client_time + 0.01;
			}

			if ( pTemp->flags & FTENT_SMOKETRAIL )
			{
				gEngfuncs.pEfxAPI->R_RocketTrail (pTemp->entity.prevstate.origin, pTemp->entity.origin, 1);
			}

			if ( !( pTemp->flags & FTENT_BODYGRAVITY ))
			{
				if ( pTemp->flags & FTENT_GRAVITY )
					pTemp->entity.baseline.origin[2] += gravity;
				else if ( pTemp->flags & FTENT_SLOWGRAVITY )
					pTemp->entity.baseline.origin[2] += gravitySlow;
			}

			if ( pTemp->flags & FTENT_CLIENTCUSTOM )
			{
				if ( pTemp->callback )
				{
					( *pTemp->callback )( pTemp, frametime, client_time );
				}
			}

			// Cull to PVS (not frustum cull, just PVS)
			if ( !(pTemp->flags & FTENT_NOMODEL ) )
			{
				if ( !Callback_AddVisibleEntity( &pTemp->entity ) )
				{
					if ( !(pTemp->flags & FTENT_PERSIST) ) 
					{
						pTemp->die = client_time;		// If we can't draw it this frame, just dump it.
						pTemp->flags &= ~FTENT_FADEOUT;	// Don't fade out, just die
					}
				}
			}
		}
		pTemp = pnext;
	}

finish:
	// Restore state info
	gEngfuncs.pEventAPI->EV_PopPMStates();
}

/*
=================
HUD_GetUserEntity

If you specify negative numbers for beam start and end point entities, then
  the engine will call back into this function requesting a pointer to a cl_entity_t 
  object that describes the entity to attach the beam onto.

Indices must start at 1, not zero.
=================
*/
cl_entity_t DLLEXPORT *HUD_GetUserEntity( int index )
{
	return NULL;
}


```

`cl_dll/ev_common.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// shared event functions
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"

#include "r_efx.h"

#include "eventscripts.h"
#include "event_api.h"
#include "pm_shared.h"
#include "events.h"

int g_iRShell, g_iPShell, g_iShotgunShell;

/*
======================
Game_HookEvents

Associate script file name with callback functions.  Callback's must be extern "C" so
 the engine doesn't get confused about name mangling stuff.  Note that the format is
 always the same.  Of course, a clever mod team could actually embed parameters, behavior
 into the actual .sc files and create a .sc file parser and hook their functionality through
 that.. i.e., a scripting system.

That was what we were going to do, but we ran out of time...oh well.
======================
*/
void Game_HookEvents( void )
{
	HOOK_EVENT( ak47, FireAK47 );
	HOOK_EVENT( aug, FireAUG );
	HOOK_EVENT( awp, FireAWP );
	HOOK_EVENT( createexplo, CreateExplo );
	HOOK_EVENT( createsmoke, CreateSmoke );
	HOOK_EVENT( deagle, FireDEAGLE );
	HOOK_EVENT( decal_reset, DecalReset );
	HOOK_EVENT( elite_left, FireEliteLeft );
	HOOK_EVENT( elite_right, FireEliteRight );
	HOOK_EVENT( famas, FireFAMAS );
	HOOK_EVENT( fiveseven, Fire57 );
	HOOK_EVENT( g3sg1, FireG3SG1 );
	HOOK_EVENT( galil, FireGALIL );
	HOOK_EVENT( glock18, Fireglock18 );
	HOOK_EVENT( knife, Knife );
	HOOK_EVENT( m249, FireM249 );
	HOOK_EVENT( m3, FireM3 );
	HOOK_EVENT( m4a1, FireM4A1 );
	HOOK_EVENT( mac10, FireMAC10 );
	HOOK_EVENT( mp5n, FireMP5 );
	HOOK_EVENT( p228, FireP228 );
	HOOK_EVENT( p90, FireP90 );
	HOOK_EVENT( scout, FireScout );
	HOOK_EVENT( sg550, FireSG550 );
	HOOK_EVENT( sg552, FireSG552 );
	HOOK_EVENT( tmp, FireTMP );
	HOOK_EVENT( ump45, FireUMP45 );
	HOOK_EVENT( usp, FireUSP );
	HOOK_EVENT( vehicle, Vehicle );
	HOOK_EVENT( xm1014, FireXM1014 );

	if( !stricmp( gEngfuncs.pfnGetGameDirectory(), "czeror" ) )
	{
		HOOK_EVENT( m60, FireM60 );
		HOOK_EVENT( camera, FireCamera );
		HOOK_EVENT( fiberopticcamera, FireFiberOpticCamera );
		HOOK_EVENT( shieldgun, FireShieldGun );
		HOOK_EVENT( blowtorchholster, HolsterBlowtorch );
		HOOK_EVENT( blowtorchidle, IdleBlowtorch );
		HOOK_EVENT( blowtorch, FireBlowtorch );
		HOOK_EVENT( laws, FireLaws );
		HOOK_EVENT( briefcase, FireBriefcase );
		HOOK_EVENT( medkit, FireMedkit );
		HOOK_EVENT( syringe, FireSyringe );
		HOOK_EVENT( radio, FireRadio );
		HOOK_EVENT( zipline, FireZipline );
		HOOK_EVENT( create_glass, CreateGlass );
		HOOK_EVENT( explosion, GrenadeExplosion );
	}
}

/*
=================
EV_GetGunPosition

Figure out the height of the gun
=================
*/
void EV_GetGunPosition( event_args_t *args, Vector &pos, const Vector &origin )
{
	int idx;
	Vector view_ofs(0, 0, 0);

	idx = args->entindex;

	if ( EV_IsPlayer( idx ) )
	{
		// in spec mode use entity viewheigh, not own
		if ( EV_IsLocal( idx ) && !IS_FIRSTPERSON_SPEC )
		{
			// Grab predicted result for local player
			gEngfuncs.pEventAPI->EV_LocalPlayerViewheight( view_ofs );
		}
		else if ( args->ducking == 1 )
		{
			view_ofs[2] = VEC_DUCK_VIEW;
		}
	}
	else
	{
		view_ofs[2] = DEFAULT_VIEWHEIGHT;
	}

	pos = origin + view_ofs;
}

/*
=================
EV_GetDefaultShellInfo

Determine where to eject shells from
=================
*/
void EV_GetDefaultShellInfo( event_args_t *args, float *origin, float *velocity, float *ShellVelocity, float *ShellOrigin, float *forward, float *right, float *up, float forwardScale, float upScale, float rightScale, bool bReverseDirection )
{
	int idx = args->entindex;

	vec3_t view_ofs = { 0, 0, DEFAULT_VIEWHEIGHT };
	if ( EV_IsPlayer( idx ) )
	{
		if ( EV_IsLocal( idx ) )
		{
			gEngfuncs.pEventAPI->EV_LocalPlayerViewheight( view_ofs );
		}
		else if ( args->ducking == 1 )
		{
			view_ofs[2] = VEC_DUCK_VIEW;
		}
	}

	float fR = gEngfuncs.pfnRandomFloat( 50, 70 );
	float fU = gEngfuncs.pfnRandomFloat( 75, 175 );
	float fF = gEngfuncs.pfnRandomFloat( 25, 250 );
	float fDirection = rightScale > 0.0f ? -1.0f : 1.0f;

	for ( int i = 0; i < 3; i++ )
	{
		if( bReverseDirection )
		{
			ShellVelocity[i] = velocity[i] * 0.5f - right[i] * fR * fDirection + up[i] * fU + forward[i] * fF;
		}
		else
		{
			ShellVelocity[i] = velocity[i] * 0.5f + right[i] * fR * fDirection + up[i] * fU + forward[i] * fF;
		}
		ShellOrigin[i]   = velocity[i] * 0.1f + origin[i] + view_ofs[i] +
				upScale * up[i] + forwardScale * forward[i] + rightScale * right[i];
	}
}

```

`cl_dll/ev_hldm.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"
#include "entity_types.h"
#include "usercmd.h"
#include "pm_defs.h"
#include "pm_materials.h"

#include "eventscripts.h"
#include "ev_hldm.h"

#include "r_efx.h"
#include "event_api.h"
#include "event_args.h"
#include "in_defs.h"

#include <string.h>

#include "r_studioint.h"
#include "com_model.h"

extern engine_studio_api_t IEngineStudio;

static int tracerCount[ 32 ];

extern "C" char PM_FindTextureType( char *name );

void V_PunchAxis( int axis, float punch );
void VectorAngles( const float *forward, float *angles );

extern cvar_t *cl_lw;

extern "C"
{

// HLDM
void EV_FireGlock1( struct event_args_s *args  );
void EV_FireGlock2( struct event_args_s *args  );
void EV_FireShotGunSingle( struct event_args_s *args  );
void EV_FireShotGunDouble( struct event_args_s *args  );
void EV_FireMP5( struct event_args_s *args  );
void EV_FireMP52( struct event_args_s *args  );
void EV_FirePython( struct event_args_s *args  );
void EV_FireGauss( struct event_args_s *args  );
void EV_SpinGauss( struct event_args_s *args  );
void EV_Crowbar( struct event_args_s *args  );
void EV_FireCrossbow( struct event_args_s *args  );
void EV_FireCrossbow2( struct event_args_s *args  );
void EV_FireRpg( struct event_args_s *args  );
void EV_EgonFire( struct event_args_s *args  );
void EV_EgonStop( struct event_args_s *args  );
void EV_HornetGunFire( struct event_args_s *args  );
void EV_TripmineFire( struct event_args_s *args  );
void EV_SnarkFire( struct event_args_s *args  );
void EV_Dummy( struct event_args_s *args );

void EV_TrainPitchAdjust( struct event_args_s *args );
}

#define VECTOR_CONE_1DEGREES Vector( 0.00873, 0.00873, 0.00873 )
#define VECTOR_CONE_2DEGREES Vector( 0.01745, 0.01745, 0.01745 )
#define VECTOR_CONE_3DEGREES Vector( 0.02618, 0.02618, 0.02618 )
#define VECTOR_CONE_4DEGREES Vector( 0.03490, 0.03490, 0.03490 )
#define VECTOR_CONE_5DEGREES Vector( 0.04362, 0.04362, 0.04362 )
#define VECTOR_CONE_6DEGREES Vector( 0.05234, 0.05234, 0.05234 )
#define VECTOR_CONE_7DEGREES Vector( 0.06105, 0.06105, 0.06105 )	
#define VECTOR_CONE_8DEGREES Vector( 0.06976, 0.06976, 0.06976 )
#define VECTOR_CONE_9DEGREES Vector( 0.07846, 0.07846, 0.07846 )
#define VECTOR_CONE_10DEGREES Vector( 0.08716, 0.08716, 0.08716 )
#define VECTOR_CONE_15DEGREES Vector( 0.13053, 0.13053, 0.13053 )
#define VECTOR_CONE_20DEGREES Vector( 0.17365, 0.17365, 0.17365 )

// play a strike sound based on the texture that was hit by the attack traceline.  VecSrc/VecEnd are the
// original traceline endpoints used by the attacker, iBulletType is the type of bullet that hit the texture.
// returns volume of strike instrument (crowbar) to play
float EV_HLDM_PlayTextureSound( int idx, pmtrace_t *ptr, float *vecSrc, float *vecEnd, int iBulletType )
{
	// hit the world, try to play sound based on texture material type
	char chTextureType = CHAR_TEX_CONCRETE;
	float fvol;
	float fvolbar;
	char *rgsz[4];
	int cnt;
	float fattn = ATTN_NORM;
	int entity;
	char *pTextureName;
	char texname[ 64 ];
	char szbuffer[ 64 ];

	entity = gEngfuncs.pEventAPI->EV_IndexFromTrace( ptr );

	// FIXME check if playtexture sounds movevar is set
	//

	chTextureType = 0;

	// Player
	if ( entity >= 1 && entity <= gEngfuncs.GetMaxClients() )
	{
		// hit body
		chTextureType = CHAR_TEX_FLESH;
	}
	else if ( entity == 0 )
	{
		// get texture from entity or world (world is ent(0))
		pTextureName = (char *)gEngfuncs.pEventAPI->EV_TraceTexture( ptr->ent, vecSrc, vecEnd );
		
		if ( pTextureName )
		{
			strcpy( texname, pTextureName );
			pTextureName = texname;

			// strip leading '-0' or '+0~' or '{' or '!'
			if (*pTextureName == '-' || *pTextureName == '+')
			{
				pTextureName += 2;
			}

			if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')
			{
				pTextureName++;
			}
			
			// '}}'
			strcpy( szbuffer, pTextureName );
			szbuffer[ CBTEXTURENAMEMAX - 1 ] = 0;
				
			// get texture type
			chTextureType = PM_FindTextureType( szbuffer );	
		}
	}
	
	switch (chTextureType)
	{
	default:
	case CHAR_TEX_CONCRETE: fvol = 0.9;	fvolbar = 0.6;
		rgsz[0] = "player/pl_step1.wav";
		rgsz[1] = "player/pl_step2.wav";
		cnt = 2;
		break;
	case CHAR_TEX_METAL: fvol = 0.9; fvolbar = 0.3;
		rgsz[0] = "player/pl_metal1.wav";
		rgsz[1] = "player/pl_metal2.wav";
		cnt = 2;
		break;
	case CHAR_TEX_DIRT:	fvol = 0.9; fvolbar = 0.1;
		rgsz[0] = "player/pl_dirt1.wav";
		rgsz[1] = "player/pl_dirt2.wav";
		rgsz[2] = "player/pl_dirt3.wav";
		cnt = 3;
		break;
	case CHAR_TEX_VENT:	fvol = 0.5; fvolbar = 0.3;
		rgsz[0] = "player/pl_duct1.wav";
		rgsz[1] = "player/pl_duct1.wav";
		cnt = 2;
		break;
	case CHAR_TEX_GRATE: fvol = 0.9; fvolbar = 0.5;
		rgsz[0] = "player/pl_grate1.wav";
		rgsz[1] = "player/pl_grate4.wav";
		cnt = 2;
		break;
	case CHAR_TEX_TILE:	fvol = 0.8; fvolbar = 0.2;
		rgsz[0] = "player/pl_tile1.wav";
		rgsz[1] = "player/pl_tile3.wav";
		rgsz[2] = "player/pl_tile2.wav";
		rgsz[3] = "player/pl_tile4.wav";
		cnt = 4;
		break;
	case CHAR_TEX_SLOSH: fvol = 0.9; fvolbar = 0.0;
		rgsz[0] = "player/pl_slosh1.wav";
		rgsz[1] = "player/pl_slosh3.wav";
		rgsz[2] = "player/pl_slosh2.wav";
		rgsz[3] = "player/pl_slosh4.wav";
		cnt = 4;
		break;
	case CHAR_TEX_WOOD: fvol = 0.9; fvolbar = 0.2;
		rgsz[0] = "debris/wood1.wav";
		rgsz[1] = "debris/wood2.wav";
		rgsz[2] = "debris/wood3.wav";
		cnt = 3;
		break;
	case CHAR_TEX_GLASS:
	case CHAR_TEX_COMPUTER:
		fvol = 0.8; fvolbar = 0.2;
		rgsz[0] = "debris/glass1.wav";
		rgsz[1] = "debris/glass2.wav";
		rgsz[2] = "debris/glass3.wav";
		cnt = 3;
		break;
	case CHAR_TEX_FLESH:
		if (iBulletType == BULLET_PLAYER_CROWBAR)
			return 0.0; // crowbar already makes this sound
		fvol = 1.0;	fvolbar = 0.2;
		rgsz[0] = "weapons/bullet_hit1.wav";
		rgsz[1] = "weapons/bullet_hit2.wav";
		fattn = 1.0;
		cnt = 2;
		break;
	}

	// play material hit sound
	gEngfuncs.pEventAPI->EV_PlaySound( 0, ptr->endpos, CHAN_STATIC, rgsz[gEngfuncs.pfnRandomLong(0,cnt-1)], fvol, fattn, 0, 96 + gEngfuncs.pfnRandomLong(0,0xf) );
	return fvolbar;
}

char *EV_HLDM_DamageDecal( physent_t *pe )
{
	static char decalname[ 32 ];
	int idx;

	if ( pe->classnumber == 1 )
	{
		idx = gEngfuncs.pfnRandomLong( 0, 2 );
		sprintf( decalname, "{break%i", idx + 1 );
	}
	else if ( pe->rendermode != kRenderNormal )
	{
		sprintf( decalname, "{bproof1" );
	}
	else
	{
		idx = gEngfuncs.pfnRandomLong( 0, 4 );
		sprintf( decalname, "{shot%i", idx + 1 );
	}
	return decalname;
}

void EV_HLDM_GunshotDecalTrace( pmtrace_t *pTrace, char *decalName )
{
	int iRand;
	physent_t *pe;

	gEngfuncs.pEfxAPI->R_BulletImpactParticles( pTrace->endpos );

	iRand = gEngfuncs.pfnRandomLong(0,0x7FFF);
	if ( iRand < (0x7fff/2) )// not every bullet makes a sound.
	{
		switch( iRand % 5)
		{
		case 0:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric1.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
		case 1:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric2.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
		case 2:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric3.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
		case 3:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric4.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
		case 4:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric5.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
		}
	}

	pe = gEngfuncs.pEventAPI->EV_GetPhysent( pTrace->ent );

	// Only decal brush models such as the world etc.
	if (  decalName && decalName[0] && pe && ( pe->solid == SOLID_BSP || pe->movetype == MOVETYPE_PUSHSTEP ) )
	{
		if ( CVAR_GET_FLOAT( "r_decals" ) )
		{
			gEngfuncs.pEfxAPI->R_DecalShoot( 
				gEngfuncs.pEfxAPI->Draw_DecalIndex( gEngfuncs.pEfxAPI->Draw_DecalIndexFromName( decalName ) ), 
				gEngfuncs.pEventAPI->EV_IndexFromTrace( pTrace ), 0, pTrace->endpos, 0 );
		}
	}
}

void EV_HLDM_DecalGunshot( pmtrace_t *pTrace, int iBulletType )
{
	physent_t *pe;

	pe = gEngfuncs.pEventAPI->EV_GetPhysent( pTrace->ent );

	if ( pe && pe->solid == SOLID_BSP )
	{
		switch( iBulletType )
		{
		case BULLET_PLAYER_9MM:
		case BULLET_MONSTER_9MM:
		case BULLET_PLAYER_MP5:
		case BULLET_MONSTER_MP5:
		case BULLET_PLAYER_BUCKSHOT:
		case BULLET_PLAYER_357:
		default:
			// smoke and decal
			EV_HLDM_GunshotDecalTrace( pTrace, EV_HLDM_DamageDecal( pe ) );
			break;
		}
	}
}

int EV_HLDM_CheckTracer( int idx, float *vecSrc, float *end, float *forward, float *right, int iBulletType, int iTracerFreq, int *tracerCount )
{
	int tracer = 0;
	int i;
	qboolean player = idx >= 1 && idx <= gEngfuncs.GetMaxClients() ? true : false;

	if ( iTracerFreq != 0 && ( (*tracerCount)++ % iTracerFreq) == 0 )
	{
		vec3_t vecTracerSrc;

		if ( player )
		{
			vec3_t offset( 0, 0, -4 );

			// adjust tracer position for player
			for ( i = 0; i < 3; i++ )
			{
				vecTracerSrc[ i ] = vecSrc[ i ] + offset[ i ] + right[ i ] * 2 + forward[ i ] * 16;
			}
		}
		else
		{
			VectorCopy( vecSrc, vecTracerSrc );
		}
		
		if ( iTracerFreq != 1 )		// guns that always trace also always decal
			tracer = 1;

		switch( iBulletType )
		{
		case BULLET_PLAYER_MP5:
		case BULLET_MONSTER_MP5:
		case BULLET_MONSTER_9MM:
		case BULLET_MONSTER_12MM:
		default:
			EV_CreateTracer( vecTracerSrc, end );
			break;
		}
	}

	return tracer;
}


/*
================
FireBullets

Go to the trouble of combining multiple pellets into a single damage call.
================
*/
void EV_HLDM_FireBullets( int idx, float *forward, float *right, float *up, int cShots, float *vecSrc, float *vecDirShooting, float flDistance, int iBulletType, int iTracerFreq, int *tracerCount, float flSpreadX, float flSpreadY )
{
	int i;
	pmtrace_t tr;
	int iShot;
	int tracer;
	
	for ( iShot = 1; iShot <= cShots; iShot++ )	
	{
		vec3_t vecDir, vecEnd;
			
		float x, y, z;
		//We randomize for the Shotgun.
		if ( iBulletType == BULLET_PLAYER_BUCKSHOT )
		{
			do {
				x = gEngfuncs.pfnRandomFloat(-0.5,0.5) + gEngfuncs.pfnRandomFloat(-0.5,0.5);
				y = gEngfuncs.pfnRandomFloat(-0.5,0.5) + gEngfuncs.pfnRandomFloat(-0.5,0.5);
				z = x*x+y*y;
			} while (z > 1);

			for ( i = 0 ; i < 3; i++ )
			{
				vecDir[i] = vecDirShooting[i] + x * flSpreadX * right[ i ] + y * flSpreadY * up [ i ];
				vecEnd[i] = vecSrc[ i ] + flDistance * vecDir[ i ];
			}
		}//But other guns already have their spread randomized in the synched spread.
		else
		{

			for ( i = 0 ; i < 3; i++ )
			{
				vecDir[i] = vecDirShooting[i] + flSpreadX * right[ i ] + flSpreadY * up [ i ];
				vecEnd[i] = vecSrc[ i ] + flDistance * vecDir[ i ];
			}
		}

		gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );
	
		// Store off the old count
		gEngfuncs.pEventAPI->EV_PushPMStates();
	
		// Now add in all of the players.
		gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	

		gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
		gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc, vecEnd, PM_STUDIO_BOX, -1, &tr );

		tracer = EV_HLDM_CheckTracer( idx, vecSrc, tr.endpos, forward, right, iBulletType, iTracerFreq, tracerCount );

		// do damage, paint decals
		if ( tr.fraction != 1.0 )
		{
			switch(iBulletType)
			{
			default:
			case BULLET_PLAYER_9MM:		
				
				EV_HLDM_PlayTextureSound( idx, &tr, vecSrc, vecEnd, iBulletType );
				EV_HLDM_DecalGunshot( &tr, iBulletType );
			
					break;
			case BULLET_PLAYER_MP5:		
				
				if ( !tracer )
				{
					EV_HLDM_PlayTextureSound( idx, &tr, vecSrc, vecEnd, iBulletType );
					EV_HLDM_DecalGunshot( &tr, iBulletType );
				}
				break;
			case BULLET_PLAYER_BUCKSHOT:
				
				EV_HLDM_DecalGunshot( &tr, iBulletType );
			
				break;
			case BULLET_PLAYER_357:
				
				EV_HLDM_PlayTextureSound( idx, &tr, vecSrc, vecEnd, iBulletType );
				EV_HLDM_DecalGunshot( &tr, iBulletType );
				
				break;

			}
		}

		gEngfuncs.pEventAPI->EV_PopPMStates();
	}
}

//======================
//	    GLOCK START
//======================
void EV_FireGlock1( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	int empty;

	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t up, right, forward;
	
	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	empty = args->bparam1;
	AngleVectors( angles, forward, right, up );

	shell = gEngfuncs.pEventAPI->EV_FindModelIndex ("models/shell.mdl");// brass shell

	if ( EV_IsLocal( idx ) )
	{
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( empty ? GLOCK_SHOOT_EMPTY : GLOCK_SHOOT, 2 );

		V_PunchAxis( 0, -2.0 );
	}

	EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20, -12, 4 );

	EV_EjectBrass ( ShellOrigin, ShellVelocity, angles[ YAW ], shell, TE_BOUNCE_SHELL ); 

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/pl_gun3.wav", gEngfuncs.pfnRandomFloat(0.92, 1.0), ATTN_NORM, 0, 98 + gEngfuncs.pfnRandomLong( 0, 3 ) );

	EV_GetGunPosition( args, vecSrc, origin );
	
	VectorCopy( forward, vecAiming );

	EV_HLDM_FireBullets( idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_9MM, 0, 0, args->fparam1, args->fparam2 );
}

void EV_FireGlock2( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t vecSpread;
	vec3_t up, right, forward;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	AngleVectors( angles, forward, right, up );

	shell = gEngfuncs.pEventAPI->EV_FindModelIndex ("models/shell.mdl");// brass shell

	if ( EV_IsLocal( idx ) )
	{
		// Add muzzle flash to current weapon model
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( GLOCK_SHOOT, 2 );

		V_PunchAxis( 0, -2.0 );
	}

	EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20, -12, 4 );

	EV_EjectBrass ( ShellOrigin, ShellVelocity, angles[ YAW ], shell, TE_BOUNCE_SHELL ); 

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/pl_gun3.wav", gEngfuncs.pfnRandomFloat(0.92, 1.0), ATTN_NORM, 0, 98 + gEngfuncs.pfnRandomLong( 0, 3 ) );

	EV_GetGunPosition( args, vecSrc, origin );
	
	VectorCopy( forward, vecAiming );

	EV_HLDM_FireBullets( idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_9MM, 0, &tracerCount[idx-1], args->fparam1, args->fparam2 );
	
}
//======================
//	   GLOCK END
//======================

//======================
//	  SHOTGUN START
//======================
void EV_FireShotGunDouble( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;

	int j;
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t vecSpread;
	vec3_t up, right, forward;
	float flSpread = 0.01;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	AngleVectors( angles, forward, right, up );

	shell = gEngfuncs.pEventAPI->EV_FindModelIndex ("models/shotgunshell.mdl");// brass shell

	if ( EV_IsLocal( idx ) )
	{
		// Add muzzle flash to current weapon model
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( SHOTGUN_FIRE2, 2 );
		V_PunchAxis( 0, -10.0 );
	}

	for ( j = 0; j < 2; j++ )
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32, -12, 6 );

		EV_EjectBrass ( ShellOrigin, ShellVelocity, angles[ YAW ], shell, TE_BOUNCE_SHOTSHELL ); 
	}

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/dbarrel1.wav", gEngfuncs.pfnRandomFloat(0.98, 1.0), ATTN_NORM, 0, 85 + gEngfuncs.pfnRandomLong( 0, 0x1f ) );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );

	if ( gEngfuncs.GetMaxClients() > 1 )
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 8, vecSrc, vecAiming, 2048, BULLET_PLAYER_BUCKSHOT, 0, &tracerCount[idx-1], 0.17365, 0.04362 );
	}
	else
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 12, vecSrc, vecAiming, 2048, BULLET_PLAYER_BUCKSHOT, 0, &tracerCount[idx-1], 0.08716, 0.08716 );
	}
}

void EV_FireShotGunSingle( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t vecSpread;
	vec3_t up, right, forward;
	float flSpread = 0.01;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	AngleVectors( angles, forward, right, up );

	shell = gEngfuncs.pEventAPI->EV_FindModelIndex ("models/shotgunshell.mdl");// brass shell

	if ( EV_IsLocal( idx ) )
	{
		// Add muzzle flash to current weapon model
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( SHOTGUN_FIRE, 2 );

		V_PunchAxis( 0, -5.0 );
	}

	EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32, -12, 6 );

	EV_EjectBrass ( ShellOrigin, ShellVelocity, angles[ YAW ], shell, TE_BOUNCE_SHOTSHELL ); 

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/sbarrel1.wav", gEngfuncs.pfnRandomFloat(0.95, 1.0), ATTN_NORM, 0, 93 + gEngfuncs.pfnRandomLong( 0, 0x1f ) );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );

	if ( gEngfuncs.GetMaxClients() > 1 )
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 4, vecSrc, vecAiming, 2048, BULLET_PLAYER_BUCKSHOT, 0, &tracerCount[idx-1], 0.08716, 0.04362 );
	}
	else
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 6, vecSrc, vecAiming, 2048, BULLET_PLAYER_BUCKSHOT, 0, &tracerCount[idx-1], 0.08716, 0.08716 );
	}
}
//======================
//	   SHOTGUN END
//======================

//======================
//	    MP5 START
//======================
void EV_FireMP5( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;

	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t up, right, forward;
	float flSpread = 0.01;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	AngleVectors( angles, forward, right, up );

	shell = gEngfuncs.pEventAPI->EV_FindModelIndex ("models/shell.mdl");// brass shell
	
	if ( EV_IsLocal( idx ) )
	{
		// Add muzzle flash to current weapon model
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( MP5_FIRE1 + gEngfuncs.pfnRandomLong(0,2), 2 );

		V_PunchAxis( 0, gEngfuncs.pfnRandomFloat( -2, 2 ) );
	}

	EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20, -12, 4 );

	EV_EjectBrass ( ShellOrigin, ShellVelocity, angles[ YAW ], shell, TE_BOUNCE_SHELL ); 

	switch( gEngfuncs.pfnRandomLong( 0, 1 ) )
	{
	case 0:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/hks1.wav", 1, ATTN_NORM, 0, 94 + gEngfuncs.pfnRandomLong( 0, 0xf ) );
		break;
	case 1:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/hks2.wav", 1, ATTN_NORM, 0, 94 + gEngfuncs.pfnRandomLong( 0, 0xf ) );
		break;
	}

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );

	if ( gEngfuncs.GetMaxClients() > 1 )
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_MP5, 2, &tracerCount[idx-1], args->fparam1, args->fparam2 );
	}
	else
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_MP5, 2, &tracerCount[idx-1], args->fparam1, args->fparam2 );
	}
}

// We only predict the animation and sound
// The grenade is still launched from the server.
void EV_FireMP52( event_args_t *args )
{
	int idx;
	vec3_t origin;
	
	idx = args->entindex;
	VectorCopy( args->origin, origin );

	if ( EV_IsLocal( idx ) )
	{
		gEngfuncs.pEventAPI->EV_WeaponAnimation( MP5_LAUNCH, 2 );
		V_PunchAxis( 0, -10 );
	}
	
	switch( gEngfuncs.pfnRandomLong( 0, 1 ) )
	{
	case 0:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/glauncher.wav", 1, ATTN_NORM, 0, 94 + gEngfuncs.pfnRandomLong( 0, 0xf ) );
		break;
	case 1:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/glauncher2.wav", 1, ATTN_NORM, 0, 94 + gEngfuncs.pfnRandomLong( 0, 0xf ) );
		break;
	}
}
//======================
//		 MP5 END
//======================

//======================
//	   PHYTON START 
//	     ( .357 )
//======================
void EV_FirePython( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;

	vec3_t vecSrc, vecAiming;
	vec3_t up, right, forward;
	float flSpread = 0.01;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		// Python uses different body in multiplayer versus single player
		int multiplayer = gEngfuncs.GetMaxClients() == 1 ? 0 : 1;

		// Add muzzle flash to current weapon model
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( PYTHON_FIRE1, multiplayer ? 1 : 0 );

		V_PunchAxis( 0, -10.0 );
	}

	switch( gEngfuncs.pfnRandomLong( 0, 1 ) )
	{
	case 0:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/357_shot1.wav", gEngfuncs.pfnRandomFloat(0.8, 0.9), ATTN_NORM, 0, PITCH_NORM );
		break;
	case 1:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/357_shot2.wav", gEngfuncs.pfnRandomFloat(0.8, 0.9), ATTN_NORM, 0, PITCH_NORM );
		break;
	}

	EV_GetGunPosition( args, vecSrc, origin );
	
	VectorCopy( forward, vecAiming );

	EV_HLDM_FireBullets( idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_357, 0, 0, args->fparam1, args->fparam2 );
}
//======================
//	    PHYTON END 
//	     ( .357 )
//======================

//======================
//	   GAUSS START 
//======================
#define SND_CHANGE_PITCH	(1<<7)		// duplicated in protocol.h change sound pitch

void EV_SpinGauss( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	int iSoundState = 0;

	int pitch;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	pitch = args->iparam1;

	iSoundState = args->bparam1 ? SND_CHANGE_PITCH : 0;

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "ambience/pulsemachine.wav", 1.0, ATTN_NORM, iSoundState, pitch );
}

/*
==============================
EV_StopPreviousGauss

==============================
*/
void EV_StopPreviousGauss( int idx )
{
	// Make sure we don't have a gauss spin event in the queue for this guy
	gEngfuncs.pEventAPI->EV_KillEvents( idx, "events/gaussspin.sc" );
	gEngfuncs.pEventAPI->EV_StopSound( idx, CHAN_WEAPON, "ambience/pulsemachine.wav" );
}

extern float g_flApplyVel;

void EV_FireGauss( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	float flDamage = args->fparam1;
	int primaryfire = args->bparam1;

	int m_fPrimaryFire = args->bparam1;
	int m_iWeaponVolume = GAUSS_PRIMARY_FIRE_VOLUME;
	vec3_t vecSrc;
	vec3_t vecDest;
	edict_t		*pentIgnore;
	pmtrace_t tr, beam_tr;
	float flMaxFrac = 1.0;
	int	nTotal = 0;
	int fHasPunched = 0;
	int fFirstBeam = 1;
	int	nMaxHits = 10;
	physent_t *pEntity;
	int m_iBeam, m_iGlow, m_iBalls;
	vec3_t up, right, forward;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	if ( args->bparam2 )
	{
		EV_StopPreviousGauss( idx );
		return;
	}

//	Con_Printf( "Firing gauss with %f\n", flDamage );
	EV_GetGunPosition( args, vecSrc, origin );

	m_iBeam = gEngfuncs.pEventAPI->EV_FindModelIndex( "sprites/smoke.spr" );
	m_iBalls = m_iGlow = gEngfuncs.pEventAPI->EV_FindModelIndex( "sprites/hotglow.spr" );
	
	AngleVectors( angles, forward, right, up );

	VectorMA( vecSrc, 8192, forward, vecDest );

	if ( EV_IsLocal( idx ) )
	{
		V_PunchAxis( 0, -2.0 );
		gEngfuncs.pEventAPI->EV_WeaponAnimation( GAUSS_FIRE2, 2 );

		if ( m_fPrimaryFire == false )
			 g_flApplyVel = flDamage;	
			 
	}

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/gauss2.wav", 0.5 + flDamage * (1.0 / 400.0), ATTN_NORM, 0, 85 + gEngfuncs.pfnRandomLong( 0, 0x1f ) );

	while (flDamage > 10 && nMaxHits > 0)
	{
		nMaxHits--;

		gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );
		
		// Store off the old count
		gEngfuncs.pEventAPI->EV_PushPMStates();
	
		// Now add in all of the players.
		gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	

		gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
		gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc, vecDest, PM_STUDIO_BOX, -1, &tr );

		gEngfuncs.pEventAPI->EV_PopPMStates();

		if ( tr.allsolid )
			break;

		if (fFirstBeam)
		{
			if ( EV_IsLocal( idx ) )
			{
				// Add muzzle flash to current weapon model
				EV_MuzzleFlash();
			}
			fFirstBeam = 0;

			gEngfuncs.pEfxAPI->R_BeamEntPoint( 
				idx | 0x1000,
				tr.endpos,
				m_iBeam,
				0.1,
				m_fPrimaryFire ? 1.0 : 2.5,
				0.0,
				m_fPrimaryFire ? 128.0 : flDamage,
				0,
				0,
				0,
				m_fPrimaryFire ? 255 : 255,
				m_fPrimaryFire ? 128 : 255,
				m_fPrimaryFire ? 0 : 255
			);
		}
		else
		{
			gEngfuncs.pEfxAPI->R_BeamPoints( vecSrc,
				tr.endpos,
				m_iBeam,
				0.1,
				m_fPrimaryFire ? 1.0 : 2.5,
				0.0,
				m_fPrimaryFire ? 128.0 : flDamage,
				0,
				0,
				0,
				m_fPrimaryFire ? 255 : 255,
				m_fPrimaryFire ? 128 : 255,
				m_fPrimaryFire ? 0 : 255
			);
		}

		pEntity = gEngfuncs.pEventAPI->EV_GetPhysent( tr.ent );
		if ( pEntity == NULL )
			break;

		if ( pEntity->solid == SOLID_BSP )
		{
			float n;

			pentIgnore = NULL;

			n = -DotProduct( tr.plane.normal, forward );

			if (n < 0.5) // 60 degrees	
			{
				// ALERT( at_console, "reflect %f\n", n );
				// reflect
				vec3_t r;
			
				VectorMA( forward, 2.0 * n, tr.plane.normal, r );

				flMaxFrac = flMaxFrac - tr.fraction;
				
				VectorCopy( r, forward );

				VectorMA( tr.endpos, 8.0, forward, vecSrc );
				VectorMA( vecSrc, 8192.0, forward, vecDest );

				gEngfuncs.pEfxAPI->R_TempSprite( tr.endpos, vec3_origin, 0.2, m_iGlow, kRenderGlow, kRenderFxNoDissipation, flDamage * n / 255.0, flDamage * n * 0.5 * 0.1, FTENT_FADEOUT );

				vec3_t fwd;
				VectorAdd( tr.endpos, tr.plane.normal, fwd );

				gEngfuncs.pEfxAPI->R_Sprite_Trail( TE_SPRITETRAIL, tr.endpos, fwd, m_iBalls, 3, 0.1, gEngfuncs.pfnRandomFloat( 10, 20 ) / 100.0, 100,
									255, 100 );

				// lose energy
				if ( n == 0 )
				{
					n = 0.1;
				}
				
				flDamage = flDamage * (1 - n);

			}
			else
			{
				// tunnel
				EV_HLDM_DecalGunshot( &tr, BULLET_MONSTER_12MM );

				gEngfuncs.pEfxAPI->R_TempSprite( tr.endpos, vec3_origin, 1.0, m_iGlow, kRenderGlow, kRenderFxNoDissipation, flDamage / 255.0, 6.0, FTENT_FADEOUT );

				// limit it to one hole punch
				if (fHasPunched)
				{
					break;
				}
				fHasPunched = 1;
				
				// try punching through wall if secondary attack (primary is incapable of breaking through)
				if ( !m_fPrimaryFire )
				{
					vec3_t start;

					VectorMA( tr.endpos, 8.0, forward, start );

					// Store off the old count
					gEngfuncs.pEventAPI->EV_PushPMStates();
						
					// Now add in all of the players.
					gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );

					gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
					gEngfuncs.pEventAPI->EV_PlayerTrace( start, vecDest, PM_STUDIO_BOX, -1, &beam_tr );

					if ( !beam_tr.allsolid )
					{
						vec3_t delta;
						float n;

						// trace backwards to find exit point

						gEngfuncs.pEventAPI->EV_PlayerTrace( beam_tr.endpos, tr.endpos, PM_STUDIO_BOX, -1, &beam_tr );

						VectorSubtract( beam_tr.endpos, tr.endpos, delta );
						
						n = Length( delta );

						if (n < flDamage)
						{
							if (n == 0)
								n = 1;
							flDamage -= n;

							// absorption balls
							{
								vec3_t fwd;
								VectorSubtract( tr.endpos, forward, fwd );
								gEngfuncs.pEfxAPI->R_Sprite_Trail( TE_SPRITETRAIL, tr.endpos, fwd, m_iBalls, 3, 0.1, gEngfuncs.pfnRandomFloat( 10, 20 ) / 100.0, 100,
									255, 100 );
							}

	//////////////////////////////////// WHAT TO DO HERE
							// CSoundEnt::InsertSound ( bits_SOUND_COMBAT, pev->origin, NORMAL_EXPLOSION_VOLUME, 3.0 );

							EV_HLDM_DecalGunshot( &beam_tr, BULLET_MONSTER_12MM );
							
							gEngfuncs.pEfxAPI->R_TempSprite( beam_tr.endpos, vec3_origin, 0.1, m_iGlow, kRenderGlow, kRenderFxNoDissipation, flDamage / 255.0, 6.0, FTENT_FADEOUT );
			
							// balls
							{
								vec3_t fwd;
								VectorSubtract( beam_tr.endpos, forward, fwd );
								gEngfuncs.pEfxAPI->R_Sprite_Trail( TE_SPRITETRAIL, beam_tr.endpos, fwd, m_iBalls, (int)(flDamage * 0.3), 0.1, gEngfuncs.pfnRandomFloat( 10, 20 ) / 100.0, 200,
									255, 40 );
							}
							
							VectorAdd( beam_tr.endpos, forward, vecSrc );
						}
					}
					else
					{
						flDamage = 0;
					}

					gEngfuncs.pEventAPI->EV_PopPMStates();
				}
				else
				{
					if ( m_fPrimaryFire )
					{
						// slug doesn't punch through ever with primary 
						// fire, so leave a little glowy bit and make some balls
						gEngfuncs.pEfxAPI->R_TempSprite( tr.endpos, vec3_origin, 0.2, m_iGlow, kRenderGlow, kRenderFxNoDissipation, 200.0 / 255.0, 0.3, FTENT_FADEOUT );
			
						{
							vec3_t fwd;
							VectorAdd( tr.endpos, tr.plane.normal, fwd );
							gEngfuncs.pEfxAPI->R_Sprite_Trail( TE_SPRITETRAIL, tr.endpos, fwd, m_iBalls, 8, 0.6, gEngfuncs.pfnRandomFloat( 10, 20 ) / 100.0, 100,
								255, 200 );
						}
					}

					flDamage = 0;
				}
			}
		}
		else
		{
			VectorAdd( tr.endpos, forward, vecSrc );
		}
	}
}
//======================
//	   GAUSS END 
//======================

//======================
//	   CROWBAR START
//======================

enum crowbar_e {
	CROWBAR_IDLE = 0,
	CROWBAR_DRAW,
	CROWBAR_HOLSTER,
	CROWBAR_ATTACK1HIT,
	CROWBAR_ATTACK1MISS,
	CROWBAR_ATTACK2MISS,
	CROWBAR_ATTACK2HIT,
	CROWBAR_ATTACK3MISS,
	CROWBAR_ATTACK3HIT
};

int g_iSwing;

//Only predict the miss sounds, hit sounds are still played 
//server side, so players don't get the wrong idea.
void EV_Crowbar( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	
	//Play Swing sound
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/cbar_miss1.wav", 1, ATTN_NORM, 0, PITCH_NORM); 

	if ( EV_IsLocal( idx ) )
	{
		gEngfuncs.pEventAPI->EV_WeaponAnimation( CROWBAR_ATTACK1MISS, 1 );

		switch( (g_iSwing++) % 3 )
		{
			case 0:
				gEngfuncs.pEventAPI->EV_WeaponAnimation ( CROWBAR_ATTACK1MISS, 1 ); break;
			case 1:
				gEngfuncs.pEventAPI->EV_WeaponAnimation ( CROWBAR_ATTACK2MISS, 1 ); break;
			case 2:
				gEngfuncs.pEventAPI->EV_WeaponAnimation ( CROWBAR_ATTACK3MISS, 1 ); break;
		}
	}
}
//======================
//	   CROWBAR END 
//======================

//======================
//	  CROSSBOW START
//======================
enum crossbow_e {
	CROSSBOW_IDLE1 = 0,	// full
	CROSSBOW_IDLE2,		// empty
	CROSSBOW_FIDGET1,	// full
	CROSSBOW_FIDGET2,	// empty
	CROSSBOW_FIRE1,		// full
	CROSSBOW_FIRE2,		// reload
	CROSSBOW_FIRE3,		// empty
	CROSSBOW_RELOAD,	// from empty
	CROSSBOW_DRAW1,		// full
	CROSSBOW_DRAW2,		// empty
	CROSSBOW_HOLSTER1,	// full
	CROSSBOW_HOLSTER2,	// empty
};

//=====================
// EV_BoltCallback
// This function is used to correct the origin and angles 
// of the bolt, so it looks like it's stuck on the wall.
//=====================
void EV_BoltCallback ( struct tempent_s *ent, float frametime, float currenttime )
{
	ent->entity.origin = ent->entity.baseline.vuser1;
	ent->entity.angles = ent->entity.baseline.vuser2;
}

void EV_FireCrossbow2( event_args_t *args )
{
	vec3_t vecSrc, vecEnd;
	vec3_t up, right, forward;
	pmtrace_t tr;

	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );

	VectorCopy( args->velocity, velocity );
	
	AngleVectors( angles, forward, right, up );

	EV_GetGunPosition( args, vecSrc, origin );

	VectorMA( vecSrc, 8192, forward, vecEnd );

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/xbow_fire1.wav", 1, ATTN_NORM, 0, 93 + gEngfuncs.pfnRandomLong(0,0xF) );
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_ITEM, "weapons/xbow_reload1.wav", gEngfuncs.pfnRandomFloat(0.95, 1.0), ATTN_NORM, 0, 93 + gEngfuncs.pfnRandomLong(0,0xF) );

	if ( EV_IsLocal( idx ) )
	{
		if ( args->iparam1 )
			gEngfuncs.pEventAPI->EV_WeaponAnimation( CROSSBOW_FIRE1, 1 );
		else if ( args->iparam2 )
			gEngfuncs.pEventAPI->EV_WeaponAnimation( CROSSBOW_FIRE3, 1 );
	}

	// Store off the old count
	gEngfuncs.pEventAPI->EV_PushPMStates();

	// Now add in all of the players.
	gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	
	gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
	gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc, vecEnd, PM_STUDIO_BOX, -1, &tr );
	
	//We hit something
	if ( tr.fraction < 1.0 )
	{
		physent_t *pe = gEngfuncs.pEventAPI->EV_GetPhysent( tr.ent ); 

		//Not the world, let's assume we hit something organic ( dog, cat, uncle joe, etc ).
		if ( pe->solid != SOLID_BSP )
		{
			switch( gEngfuncs.pfnRandomLong(0,1) )
			{
			case 0:
				gEngfuncs.pEventAPI->EV_PlaySound( idx, tr.endpos, CHAN_BODY, "weapons/xbow_hitbod1.wav", 1, ATTN_NORM, 0, PITCH_NORM ); break;
			case 1:
				gEngfuncs.pEventAPI->EV_PlaySound( idx, tr.endpos, CHAN_BODY, "weapons/xbow_hitbod2.wav", 1, ATTN_NORM, 0, PITCH_NORM ); break;
			}
		}
		//Stick to world but don't stick to glass, it might break and leave the bolt floating. It can still stick to other non-transparent breakables though.
		else if ( pe->rendermode == kRenderNormal ) 
		{
			gEngfuncs.pEventAPI->EV_PlaySound( 0, tr.endpos, CHAN_BODY, "weapons/xbow_hit1.wav", gEngfuncs.pfnRandomFloat(0.95, 1.0), ATTN_NORM, 0, PITCH_NORM );
		
			//Not underwater, do some sparks...
			if ( gEngfuncs.PM_PointContents( tr.endpos, NULL ) != CONTENTS_WATER)
				 gEngfuncs.pEfxAPI->R_SparkShower( tr.endpos );

			vec3_t vBoltAngles;
			int iModelIndex = gEngfuncs.pEventAPI->EV_FindModelIndex( "models/crossbow_bolt.mdl" );

			VectorAngles( forward, vBoltAngles );

			TEMPENTITY *bolt = gEngfuncs.pEfxAPI->R_TempModel( tr.endpos - forward * 10, Vector( 0, 0, 0), vBoltAngles , 5, iModelIndex, TE_BOUNCE_NULL );
			
			if ( bolt )
			{
				bolt->flags |= ( FTENT_CLIENTCUSTOM ); //So it calls the callback function.
				bolt->entity.baseline.vuser1 = tr.endpos - forward * 10; // Pull out a little bit
				bolt->entity.baseline.vuser2 = vBoltAngles; //Look forward!
				bolt->callback = EV_BoltCallback; //So we can set the angles and origin back. (Stick the bolt to the wall)
			}
		}
	}

	gEngfuncs.pEventAPI->EV_PopPMStates();
}

//TODO: Fully predict the fliying bolt.
void EV_FireCrossbow( event_args_t *args )
{
	int idx;
	vec3_t origin;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/xbow_fire1.wav", 1, ATTN_NORM, 0, 93 + gEngfuncs.pfnRandomLong(0,0xF) );
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_ITEM, "weapons/xbow_reload1.wav", gEngfuncs.pfnRandomFloat(0.95, 1.0), ATTN_NORM, 0, 93 + gEngfuncs.pfnRandomLong(0,0xF) );

	//Only play the weapon anims if I shot it. 
	if ( EV_IsLocal( idx ) )
	{
		if ( args->iparam1 )
			gEngfuncs.pEventAPI->EV_WeaponAnimation( CROSSBOW_FIRE1, 1 );
		else if ( args->iparam2 )
			gEngfuncs.pEventAPI->EV_WeaponAnimation( CROSSBOW_FIRE3, 1 );

		V_PunchAxis( 0, -2.0 );
	}
}
//======================
//	   CROSSBOW END 
//======================

//======================
//	    RPG START 
//======================
enum rpg_e {
	RPG_IDLE = 0,
	RPG_FIDGET,
	RPG_RELOAD,		// to reload
	RPG_FIRE2,		// to empty
	RPG_HOLSTER1,	// loaded
	RPG_DRAW1,		// loaded
	RPG_HOLSTER2,	// unloaded
	RPG_DRAW_UL,	// unloaded
	RPG_IDLE_UL,	// unloaded idle
	RPG_FIDGET_UL,	// unloaded fidget
};

void EV_FireRpg( event_args_t *args )
{
	int idx;
	vec3_t origin;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/rocketfire1.wav", 0.9, ATTN_NORM, 0, PITCH_NORM );
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_ITEM, "weapons/glauncher.wav", 0.7, ATTN_NORM, 0, PITCH_NORM );

	//Only play the weapon anims if I shot it. 
	if ( EV_IsLocal( idx ) )
	{
		gEngfuncs.pEventAPI->EV_WeaponAnimation( RPG_FIRE2, 1 );
	
		V_PunchAxis( 0, -5.0 );
	}
}
//======================
//	     RPG END 
//======================

//======================
//	    EGON END 
//======================
enum egon_e {
	EGON_IDLE1 = 0,
	EGON_FIDGET1,
	EGON_ALTFIREON,
	EGON_ALTFIRECYCLE,
	EGON_ALTFIREOFF,
	EGON_FIRE1,
	EGON_FIRE2,
	EGON_FIRE3,
	EGON_FIRE4,
	EGON_DRAW,
	EGON_HOLSTER
};

int g_fireAnims1[] = { EGON_FIRE1, EGON_FIRE2, EGON_FIRE3, EGON_FIRE4 };
int g_fireAnims2[] = { EGON_ALTFIRECYCLE };

enum EGON_FIRESTATE { FIRE_OFF, FIRE_CHARGE };
enum EGON_FIREMODE { FIRE_NARROW, FIRE_WIDE};

#define	EGON_PRIMARY_VOLUME		450
#define EGON_BEAM_SPRITE		"sprites/xbeam1.spr"
#define EGON_FLARE_SPRITE		"sprites/XSpark1.spr"
#define EGON_SOUND_OFF			"weapons/egon_off1.wav"
#define EGON_SOUND_RUN			"weapons/egon_run3.wav"
#define EGON_SOUND_STARTUP		"weapons/egon_windup2.wav"

#define ARRAYSIZE(p)		(sizeof(p)/sizeof(p[0]))

BEAM *pBeam;
BEAM *pBeam2;

void EV_EgonFire( event_args_t *args )
{
	int idx, iFireState, iFireMode;
	vec3_t origin;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	iFireState = args->iparam1;
	iFireMode = args->iparam2;
	int iStartup = args->bparam1;


	if ( iStartup )
	{
		if ( iFireMode == FIRE_WIDE )
			gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, EGON_SOUND_STARTUP, 0.98, ATTN_NORM, 0, 125 );
		else
			gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, EGON_SOUND_STARTUP, 0.9, ATTN_NORM, 0, 100 );
	}
	else
	{
		if ( iFireMode == FIRE_WIDE )
			gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_STATIC, EGON_SOUND_RUN, 0.98, ATTN_NORM, 0, 125 );
		else
			gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_STATIC, EGON_SOUND_RUN, 0.9, ATTN_NORM, 0, 100 );
	}

	//Only play the weapon anims if I shot it.
	if ( EV_IsLocal( idx ) )
		gEngfuncs.pEventAPI->EV_WeaponAnimation ( g_fireAnims1[ gEngfuncs.pfnRandomLong( 0, 3 ) ], 1 );

	if ( iStartup == 1 && EV_IsLocal( idx ) && !pBeam && !pBeam2 && cl_lw->value ) //Adrian: Added the cl_lw check for those lital people that hate weapon prediction.
	{
		vec3_t vecSrc, vecEnd, origin, angles, forward, right, up;
		pmtrace_t tr;

		cl_entity_t *pl = gEngfuncs.GetEntityByIndex( idx );

		if ( pl )
		{
			VectorCopy( gHUD.m_vecAngles, angles );
			
			AngleVectors( angles, forward, right, up );

			EV_GetGunPosition( args, vecSrc, pl->origin );

			VectorMA( vecSrc, 2048, forward, vecEnd );

			gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );	
				
			// Store off the old count
			gEngfuncs.pEventAPI->EV_PushPMStates();
			
			// Now add in all of the players.
			gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	

			gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
			gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc, vecEnd, PM_STUDIO_BOX, -1, &tr );

			gEngfuncs.pEventAPI->EV_PopPMStates();

			int iBeamModelIndex = gEngfuncs.pEventAPI->EV_FindModelIndex( EGON_BEAM_SPRITE );

			float r = 50.0f;
			float g = 50.0f;
			float b = 125.0f;

			if ( IEngineStudio.IsHardware() )
			{
				r /= 100.0f;
				g /= 100.0f;
			}
				
		
			pBeam = gEngfuncs.pEfxAPI->R_BeamEntPoint ( idx | 0x1000, tr.endpos, iBeamModelIndex, 99999, 3.5, 0.2, 0.7, 55, 0, 0, r, g, b );

			if ( pBeam )
				 pBeam->flags |= ( FBEAM_SINENOISE );
 
			pBeam2 = gEngfuncs.pEfxAPI->R_BeamEntPoint ( idx | 0x1000, tr.endpos, iBeamModelIndex, 99999, 5.0, 0.08, 0.7, 25, 0, 0, r, g, b );
		}
	}
}

void EV_EgonStop( event_args_t *args )
{
	int idx;
	vec3_t origin;

	idx = args->entindex;
	VectorCopy ( args->origin, origin );

	gEngfuncs.pEventAPI->EV_StopSound( idx, CHAN_STATIC, EGON_SOUND_RUN );
	
	if ( args->iparam1 )
		 gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, EGON_SOUND_OFF, 0.98, ATTN_NORM, 0, 100 );

	if ( EV_IsLocal( idx ) ) 
	{
		if ( pBeam )
		{
			pBeam->die = 0.0;
			pBeam = NULL;
		}
			
		
		if ( pBeam2 )
		{
			pBeam2->die = 0.0;
			pBeam2 = NULL;
		}
	}
}
//======================
//	    EGON END 
//======================

//======================
//	   HORNET START
//======================
enum hgun_e {
	HGUN_IDLE1 = 0,
	HGUN_FIDGETSWAY,
	HGUN_FIDGETSHAKE,
	HGUN_DOWN,
	HGUN_UP,
	HGUN_SHOOT
};

void EV_HornetGunFire( event_args_t *args )
{
	int idx, iFireMode;
	vec3_t origin, angles, vecSrc, forward, right, up;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	iFireMode = args->iparam1;

	//Only play the weapon anims if I shot it.
	if ( EV_IsLocal( idx ) )
	{
		V_PunchAxis( 0, gEngfuncs.pfnRandomLong ( 0, 2 ) );
		gEngfuncs.pEventAPI->EV_WeaponAnimation ( HGUN_SHOOT, 1 );
	}

	switch ( gEngfuncs.pfnRandomLong ( 0 , 2 ) )
	{
		case 0:	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "agrunt/ag_fire1.wav", 1, ATTN_NORM, 0, 100 );	break;
		case 1:	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "agrunt/ag_fire2.wav", 1, ATTN_NORM, 0, 100 );	break;
		case 2:	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "agrunt/ag_fire3.wav", 1, ATTN_NORM, 0, 100 );	break;
	}
}
//======================
//	   HORNET END
//======================

//======================
//	   TRIPMINE START
//======================
enum tripmine_e {
	TRIPMINE_IDLE1 = 0,
	TRIPMINE_IDLE2,
	TRIPMINE_ARM1,
	TRIPMINE_ARM2,
	TRIPMINE_FIDGET,
	TRIPMINE_HOLSTER,
	TRIPMINE_DRAW,
	TRIPMINE_WORLD,
	TRIPMINE_GROUND,
};

//We only check if it's possible to put a trip mine
//and if it is, then we play the animation. Server still places it.
void EV_TripmineFire( event_args_t *args )
{
	int idx;
	vec3_t vecSrc, angles, view_ofs, forward;
	pmtrace_t tr;

	idx = args->entindex;
	VectorCopy( args->origin, vecSrc );
	VectorCopy( args->angles, angles );

	AngleVectors ( angles, forward, NULL, NULL );
		
	if ( !EV_IsLocal ( idx ) )
		return;

	// Grab predicted result for local player
	gEngfuncs.pEventAPI->EV_LocalPlayerViewheight( view_ofs );

	vecSrc = vecSrc + view_ofs;

	// Store off the old count
	gEngfuncs.pEventAPI->EV_PushPMStates();

	// Now add in all of the players.
	gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	
	gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
	gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc, vecSrc + forward * 128, PM_NORMAL, -1, &tr );

	//Hit something solid
	if ( tr.fraction < 1.0 )
		 gEngfuncs.pEventAPI->EV_WeaponAnimation ( TRIPMINE_DRAW, 0 );
	
	gEngfuncs.pEventAPI->EV_PopPMStates();
}
//======================
//	   TRIPMINE END
//======================

//======================
//	   SQUEAK START
//======================
enum squeak_e {
	SQUEAK_IDLE1 = 0,
	SQUEAK_FIDGETFIT,
	SQUEAK_FIDGETNIP,
	SQUEAK_DOWN,
	SQUEAK_UP,
	SQUEAK_THROW
};

#define VEC_HULL_MIN		Vector(-16, -16, -36)
#define VEC_DUCK_HULL_MIN	Vector(-16, -16, -18 )

void EV_SnarkFire( event_args_t *args )
{
	int idx;
	vec3_t vecSrc, angles, view_ofs, forward;
	pmtrace_t tr;

	idx = args->entindex;
	VectorCopy( args->origin, vecSrc );
	VectorCopy( args->angles, angles );

	AngleVectors ( angles, forward, NULL, NULL );
		
	if ( !EV_IsLocal ( idx ) )
		return;
	
	if ( args->ducking )
		vecSrc = vecSrc - ( VEC_HULL_MIN - VEC_DUCK_HULL_MIN );
	
	// Store off the old count
	gEngfuncs.pEventAPI->EV_PushPMStates();

	// Now add in all of the players.
	gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	
	gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
	gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc + forward * 20, vecSrc + forward * 64, PM_NORMAL, -1, &tr );

	//Find space to drop the thing.
	if ( tr.allsolid == 0 && tr.startsolid == 0 && tr.fraction > 0.25 )
		 gEngfuncs.pEventAPI->EV_WeaponAnimation ( SQUEAK_THROW, 0 );
	
	gEngfuncs.pEventAPI->EV_PopPMStates();
}
//======================
//	   SQUEAK END
//======================

void EV_TrainPitchAdjust( event_args_t *args )
{
	int idx;
	vec3_t origin;

	unsigned short us_params;
	int noise;
	float m_flVolume;
	int pitch;
	int stop;
	
	char sz[ 256 ];

	idx = args->entindex;
	
	VectorCopy( args->origin, origin );

	us_params = (unsigned short)args->iparam1;
	stop	  = args->bparam1;

	m_flVolume	= (float)(us_params & 0x003f)/40.0;
	noise		= (int)(((us_params) >> 12 ) & 0x0007);
	pitch		= (int)( 10.0 * (float)( ( us_params >> 6 ) & 0x003f ) );

	switch ( noise )
	{
	case 1: strcpy( sz, "plats/ttrain1.wav"); break;
	case 2: strcpy( sz, "plats/ttrain2.wav"); break;
	case 3: strcpy( sz, "plats/ttrain3.wav"); break; 
	case 4: strcpy( sz, "plats/ttrain4.wav"); break;
	case 5: strcpy( sz, "plats/ttrain6.wav"); break;
	case 6: strcpy( sz, "plats/ttrain7.wav"); break;
	default:
		// no sound
		strcpy( sz, "" );
		return;
	}

	if ( stop )
	{
		gEngfuncs.pEventAPI->EV_StopSound( idx, CHAN_STATIC, sz );
	}
	else
	{
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_STATIC, sz, m_flVolume, ATTN_NORM, SND_CHANGE_PITCH, pitch );
	}
}

int EV_TFC_IsAllyTeam( int iTeam1, int iTeam2 )
{
	return 0;
}

void EV_Dummy( struct event_args_s *args )
{
	gEngfuncs.pEventAPI->EV_WeaponAnimation( 1, 1 );
	return;
}


```

`cl_dll/events/ev_cs16.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"
#include "entity_types.h"
#include "usercmd.h"
#include "pm_defs.h"
#include "pm_materials.h"

#include "eventscripts.h"
#include "ev_hldm.h"

#include "r_efx.h"
#include "triangleapi.h"
#include "event_api.h"
#include "event_args.h"
#include "in_defs.h"

#include <string.h>

#include "r_studioint.h"
#include "com_model.h"

#include <assert.h>

#include "pm_shared.h"
#include "com_weapons.h"
#include "draw_util.h"

extern float g_flRoundTime;

char EV_HLDM_PlayTextureSound( int idx, pmtrace_t *ptr, const Vector &vecSrc, const Vector &vecEnd, int iBulletType, bool& isSky )
{
	// hit the world, try to play sound based on texture material type
	char chTextureType = CHAR_TEX_CONCRETE;
	float fvol;
	const char *rgsz[6];
	int cnt;
	float fattn = ATTN_NORM;
	int entity;
	char *pTextureName;
	char texname[ 64 ];
	char szbuffer[ 64 ];

	entity = gEngfuncs.pEventAPI->EV_IndexFromTrace( ptr );

	// FIXME check if playtexture sounds movevar is set
	//

	chTextureType = 0;
	isSky = false;

	// Player
	if ( entity >= 1 && entity <= gEngfuncs.GetMaxClients() )
	{
		// hit body
		chTextureType = CHAR_TEX_FLESH;
	}
	else if ( entity == 0 )
	{
		// get texture from entity or world (world is ent(0))
		pTextureName = (char *)gEngfuncs.pEventAPI->EV_TraceTexture( ptr->ent, vecSrc, vecEnd );

		if ( pTextureName )
		{
			strncpy( texname, pTextureName, sizeof( texname ) );
			texname[ sizeof( texname ) - 1 ] = 0;
			pTextureName = texname;

			if( !strcmp( pTextureName, "sky" ) )
			{
				isSky = true;
			}
			// strip leading '-0' or '+0~' or '{' or '!'
			else if (*pTextureName == '-' || *pTextureName == '+')
			{
				pTextureName += 2;
			}
			else if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')
			{
				pTextureName++;
			}

			// '}}'
			strncpy( szbuffer, pTextureName, sizeof(szbuffer) );
			szbuffer[ CBTEXTURENAMEMAX - 1 ] = 0;

			// get texture type
			chTextureType = PM_FindTextureType( szbuffer );
		}
	}

	switch (chTextureType)
	{
	default:
	case CHAR_TEX_CONCRETE:
	{
		fvol = 0.9;
		rgsz[0] = "player/pl_step1.wav";
		rgsz[1] = "player/pl_step2.wav";
		cnt = 2;
		break;
	}
	case CHAR_TEX_METAL:
	{
		fvol = 0.9;
		rgsz[0] = "player/pl_metal1.wav";
		rgsz[1] = "player/pl_metal2.wav";
		cnt = 2;
		break;
	}
	case CHAR_TEX_DIRT:
	{
		fvol = 0.9;
		rgsz[0] = "player/pl_dirt1.wav";
		rgsz[1] = "player/pl_dirt2.wav";
		rgsz[2] = "player/pl_dirt3.wav";
		cnt = 3;
		break;
	}
	case CHAR_TEX_VENT:
	{
		fvol = 0.5;
		rgsz[0] = "player/pl_duct1.wav";
		rgsz[1] = "player/pl_duct1.wav";
		cnt = 2;
		break;
	}
	case CHAR_TEX_GRATE:
	{
		fvol = 0.9;
		rgsz[0] = "player/pl_grate1.wav";
		rgsz[1] = "player/pl_grate4.wav";
		cnt = 2;
		break;
	}
	case CHAR_TEX_TILE:
	{
		fvol = 0.8;
		rgsz[0] = "player/pl_tile1.wav";
		rgsz[1] = "player/pl_tile3.wav";
		rgsz[2] = "player/pl_tile2.wav";
		rgsz[3] = "player/pl_tile4.wav";
		cnt = 4;
		break;
	}
	case CHAR_TEX_SLOSH:
	{
		fvol = 0.9;
		rgsz[0] = "player/pl_slosh1.wav";
		rgsz[1] = "player/pl_slosh3.wav";
		rgsz[2] = "player/pl_slosh2.wav";
		rgsz[3] = "player/pl_slosh4.wav";
		cnt = 4;
		break;
	}
	case CHAR_TEX_SNOW:
	{
		fvol = 0.7;
		rgsz[0] = "player/pl_snow1.wav";
		rgsz[1] = "player/pl_snow2.wav";
		rgsz[2] = "player/pl_snow3.wav";
		rgsz[3] = "player/pl_snow4.wav";
		rgsz[4] = "player/pl_snow5.wav";
		rgsz[5] = "player/pl_snow6.wav";
		cnt = 6;
		break;
	}
	case CHAR_TEX_WOOD:
	{
		fvol = 0.9;
		rgsz[0] = "debris/wood1.wav";
		rgsz[1] = "debris/wood2.wav";
		rgsz[2] = "debris/wood3.wav";
		cnt = 3;
		break;
	}
	case CHAR_TEX_GLASS:
	case CHAR_TEX_COMPUTER:
	{
		fvol = 0.8;
		rgsz[0] = "debris/glass1.wav";
		rgsz[1] = "debris/glass2.wav";
		rgsz[2] = "debris/glass3.wav";
		cnt = 3;
		break;
	}
	case CHAR_TEX_FLESH:
	{
		fvol = 1.0;
		rgsz[0] = "weapons/bullet_hit1.wav";
		rgsz[1] = "weapons/bullet_hit2.wav";
		fattn = 1.0;
		cnt = 2;
		break;
	}
	}

	// play material hit sound
	gEngfuncs.pEventAPI->EV_PlaySound( 0, ptr->endpos, CHAN_STATIC, rgsz[Com_RandomLong(0,cnt-1)], fvol, fattn, 0, 96 + Com_RandomLong(0,0xf) );

	return chTextureType;
}

char *EV_HLDM_DamageDecal( physent_t *pe )
{
	static char decalname[ 32 ];
	int idx;

	if ( pe->classnumber == 1 )
	{
		idx = Com_RandomLong( 0, 2 );
		sprintf( decalname, "{break%i", idx + 1 );
	}
	else if ( pe->rendermode != kRenderNormal )
	{
		sprintf( decalname, "{bproof1" );
	}
	else
	{
		idx = Com_RandomLong( 0, 4 );
		sprintf( decalname, "{shot%i", idx + 1 );
	}
	return decalname;
}

void EV_HLDM_GunshotDecalTrace( pmtrace_t *pTrace, char *decalName, char chTextureType )
{
	int iRand;
	physent_t *pe;

	gEngfuncs.pEfxAPI->R_BulletImpactParticles( pTrace->endpos );


	iRand = Com_RandomLong(0,0x7FFF);
	if ( iRand < (0x7fff/2) )// not every bullet makes a sound.
	{
		if( chTextureType == CHAR_TEX_VENT || chTextureType == CHAR_TEX_METAL )
		{
			switch( iRand % 2 )
			{
			case 0: gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric_metal-1.wav", 1.0f, ATTN_NORM, 0, PITCH_NORM); break;
			case 1: gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric_metal-2.wav", 1.0f, ATTN_NORM, 0, PITCH_NORM); break;
			}
		}
		else
		{
			switch( iRand % 7)
			{
			case 0:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric1.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
			case 1:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric2.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
			case 2:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric3.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
			case 3:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric4.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
			case 4:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric5.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
			case 5: gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric_conc-1.wav", 1.0f, ATTN_NORM, 0, PITCH_NORM); break;
			case 6: gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric_conc-2.wav", 1.0f, ATTN_NORM, 0, PITCH_NORM); break;
			}
		}

	}

	pe = gEngfuncs.pEventAPI->EV_GetPhysent( pTrace->ent );

	// Only decal brush models such as the world etc.
	if (  decalName && decalName[0] && pe && ( pe->solid == SOLID_BSP || pe->movetype == MOVETYPE_PUSHSTEP ) )
	{
		if ( CVAR_GET_FLOAT( "r_decals" ) )
		{
			gEngfuncs.pEfxAPI->R_DecalShoot(
						gEngfuncs.pEfxAPI->Draw_DecalIndex( gEngfuncs.pEfxAPI->Draw_DecalIndexFromName( decalName ) ),
						gEngfuncs.pEventAPI->EV_IndexFromTrace( pTrace ), 0, pTrace->endpos, 0 );

		}
	}
}


void EV_WallPuff_Wind( struct tempent_s *te, float frametime, float currenttime )
{
	static bool xWindDirection = true;
	static bool yWindDirection = true;
	static float xWindMagnitude;
	static float yWindMagnitude;

	if ( te->entity.curstate.frame > 7.0 )
	{
		te->entity.baseline.origin.x = 0.97 * te->entity.baseline.origin.x;
		te->entity.baseline.origin.y = 0.97 * te->entity.baseline.origin.y;
		te->entity.baseline.origin.z = 0.97 * te->entity.baseline.origin.z + 0.7;
		if ( te->entity.baseline.origin.z > 70.0 )
			te->entity.baseline.origin.z = 70.0;
	}

	if ( te->entity.curstate.frame > 6.0 )
	{
		xWindMagnitude += 0.075;
		if ( xWindMagnitude > 5.0 )
			xWindMagnitude = 5.0;

		yWindMagnitude += 0.075;
		if ( yWindMagnitude > 5.0 )
			yWindMagnitude = 5.0;

		te->entity.baseline.origin.x += xWindMagnitude * ( xWindDirection ? 1 : -1 );
		te->entity.baseline.origin.y += yWindMagnitude * ( yWindDirection ? 1 : -1 );

		if ( !Com_RandomLong(0, 10) && yWindMagnitude > 3.0 )
		{
			yWindMagnitude = 0;
			yWindDirection = !yWindDirection;
		}
		if ( !Com_RandomLong(0, 10) && xWindMagnitude > 3.0 )
		{
			xWindMagnitude = 0;
			xWindDirection = !xWindDirection;
		}
	}
}

void EV_SmokeRise( struct tempent_s *te, float frametime, float currenttime )
{
	if ( te->entity.curstate.frame > 7.0 )
	{
		te->entity.baseline.origin = 0.97f * te->entity.baseline.origin;
		te->entity.baseline.origin.z += 0.7f;

		if( te->entity.baseline.origin.z > 70.0f )
			te->entity.baseline.origin.z = 70.0f;
	}
}

void EV_HugWalls(TEMPENTITY *te, pmtrace_s *ptr)
{
	float len = te->entity.baseline.origin.Length();
	Vector norm;

	if( len == 0.0f )
		norm.x = norm.y = norm.z = 0.0f;
	else
		norm = te->entity.baseline.origin / len;

	Vector v2 = CrossProduct( ptr->plane.normal, CrossProduct( ptr->plane.normal, norm ) );

	len = min( len * 1.5, 3000.0f );

	te->entity.baseline.origin.x = v2.z * len;
	te->entity.baseline.origin.y = v2.y * len;
	te->entity.baseline.origin.z = v2.x * len;
}

struct
{
	int count;
	const char *files[4];
} g_SmokeSprites[] =
{
	{
		4,
		{
			"sprites/wall_puff1.spr",
			"sprites/wall_puff2.spr",
			"sprites/wall_puff3.spr",
			"sprites/wall_puff4.spr"
		}
	},
	{
		3,
		{
			"sprites/rifle_smoke1.spr",
			"sprites/rifle_smoke2.spr",
			"sprites/rifle_smoke3.spr"
		}
	},
	{
		2,
		{
			"sprites/pistol_smoke1.spr",
			"sprites/pistol_smoke2.spr"
		}
	},
	{
		4,
		{
			"sprites/black_smoke1.spr",
			"sprites/black_smoke2.spr",
			"sprites/black_smoke3.spr",
			"sprites/black_smoke4.spr"
		}
	}
};

TEMPENTITY *EV_CS16Client_CreateSmoke( ESmoke type, Vector origin, Vector dir,
	int speed, float scale, int r, int g, int b , bool wind, Vector velocity, int framerate , int teflags )
{
	TEMPENTITY *te;
	const char *path;

	assert( type <= SMOKE_BLACK );

	int rand = Com_RandomLong( 0, g_SmokeSprites[type].count - 1 );
	path = g_SmokeSprites[type].files[rand];

	te = gEngfuncs.pEfxAPI->R_DefaultSprite( origin, gEngfuncs.pEventAPI->EV_FindModelIndex( path ), framerate );

	if( te )
	{
		if( wind )
			te->callback = EV_WallPuff_Wind;
		else
			te->callback = EV_SmokeRise;
		te->hitcallback = EV_HugWalls;
		te->flags |= teflags | FTENT_CLIENTCUSTOM;
		te->entity.curstate.rendermode = kRenderTransAdd;
		te->entity.curstate.rendercolor.r = r;
		te->entity.curstate.rendercolor.g = g;
		te->entity.curstate.rendercolor.b = b;
		te->entity.curstate.renderamt = Com_RandomLong( 100, 180 );
		te->entity.curstate.scale = scale;
		te->entity.baseline.origin = speed * dir;

		if( type != SMOKE_WALLPUFF && velocity.IsNull() )
		{
			velocity = g_vPlayerVelocity;
		}

		if( !velocity.IsNull() )
		{
			velocity.x *= 0.5;
			velocity.y *= 0.5;
			velocity.z *= 0.9;
			te->entity.baseline.origin = te->entity.baseline.origin + velocity;
		}
	}

	return te;
}

void EV_HLDM_DecalGunshot(pmtrace_t *pTrace, int iBulletType, float scale, int r, int g, int b, bool bCreateWallPuff, bool bCreateSparks, char cTextureType, bool isSky)
{
	physent_t *pe;

	if( isSky )
		return; // don't try to draw decals, spawn wall puff on skybox?

	pe = gEngfuncs.pEventAPI->EV_GetPhysent( pTrace->ent );

	if ( pe && pe->solid == SOLID_BSP )
	{
		EV_HLDM_GunshotDecalTrace( pTrace, EV_HLDM_DamageDecal( pe ), cTextureType );

		// create sparks
		if( gHUD.cl_weapon_sparks->value && bCreateSparks )
		{
			Vector dir = pTrace->plane.normal;

			dir.x = dir.x * dir.x * gEngfuncs.pfnRandomFloat( 4.0f, 12.0f );
			dir.y = dir.y * dir.y * gEngfuncs.pfnRandomFloat( 4.0f, 12.0f );
			dir.z = dir.z * dir.z * gEngfuncs.pfnRandomFloat( 4.0f, 12.0f );

			gEngfuncs.pEfxAPI->R_StreakSplash( pTrace->endpos, dir, 4, Com_RandomLong( 5, 7 ), dir.z, -75.0f, 75.0f );
		}

		// create wallpuff
		if( gHUD.cl_weapon_wallpuff->value && bCreateWallPuff )
		{
			EV_CS16Client_CreateSmoke( SMOKE_WALLPUFF, pTrace->endpos, pTrace->plane.normal, 25, 0.5, r, g, b, true );
		}
	}
}

/*
============
EV_DescribeBulletTypeParameters

Sets iPenetrationPower and flPenetrationDistance.
If iBulletType is unknown, calls assert() and sets these two vars to 0
============
*/
void EV_DescribeBulletTypeParameters(int iBulletType, int &iPenetrationPower, float &flPenetrationDistance)
{
	switch (iBulletType)
	{
	case BULLET_PLAYER_9MM:
	{
		iPenetrationPower = 21;
		flPenetrationDistance = 800;
		break;
	}

	case BULLET_PLAYER_45ACP:
	{
		iPenetrationPower = 15;
		flPenetrationDistance = 500;
		break;
	}

	case BULLET_PLAYER_50AE:
	{
		iPenetrationPower = 30;
		flPenetrationDistance = 1000;
		break;
	}

	case BULLET_PLAYER_762MM:
	{
		iPenetrationPower = 39;
		flPenetrationDistance = 5000;
		break;
	}

	case BULLET_PLAYER_556MM:
	{
		iPenetrationPower = 35;
		flPenetrationDistance = 4000;
		break;
	}

	case BULLET_PLAYER_338MAG:
	{
		iPenetrationPower = 45;
		flPenetrationDistance = 8000;
		break;
	}

	case BULLET_PLAYER_57MM:
	{
		iPenetrationPower = 30;
		flPenetrationDistance = 2000;
		break;
	}

	case BULLET_PLAYER_357SIG:
	{
		iPenetrationPower = 25;
		flPenetrationDistance = 800;
		break;
	}

	default:
	{
		iPenetrationPower = 0;
		flPenetrationDistance = 0;
		break;
	}
	}
}



/*
================
EV_HLDM_FireBullets

Go to the trouble of combining multiple pellets into a single damage call.
================
*/
void EV_HLDM_FireBullets(int idx,
						 float *forward, float *right, float *up,
						 int cShots,
						 float *vecSrc, float *vecDirShooting, float *vecSpread,
						 float flDistance, int iBulletType, int iPenetration)
{
	int i;
	pmtrace_t tr;
	int iShot;
	int iPenetrationPower;
	float flPenetrationDistance;
	bool isSky;

	EV_DescribeBulletTypeParameters( iBulletType, iPenetrationPower, flPenetrationDistance );

	for ( iShot = 1; iShot <= cShots; iShot++ )
	{
		Vector vecShotSrc = vecSrc;
		int iShotPenetration = iPenetration;
		Vector vecDir, vecEnd;

		if ( iBulletType == BULLET_PLAYER_BUCKSHOT )
		{
			//We randomize for the Shotgun.
			float x, y, z;
			do {
				x = gEngfuncs.pfnRandomFloat(-0.5,0.5) + gEngfuncs.pfnRandomFloat(-0.5,0.5);
				y = gEngfuncs.pfnRandomFloat(-0.5,0.5) + gEngfuncs.pfnRandomFloat(-0.5,0.5);
				z = x*x+y*y;
			} while (z > 1);

			for ( i = 0 ; i < 3; i++ )
			{
				vecDir[i] = vecDirShooting[i] + x * vecSpread[0] * right[ i ] + y * vecSpread[1] * up [ i ];
				vecEnd[i] = vecShotSrc[ i ] + flDistance * vecDir[ i ];
			}
		}
		else //But other guns already have their spread randomized in the synched spread.
		{
			for ( i = 0 ; i < 3; i++ )
			{
				vecDir[i] = vecDirShooting[i] + vecSpread[0] * right[ i ] + vecSpread[1] * up [ i ];
				vecEnd[i] = vecShotSrc[ i ] + flDistance * vecDir[ i ];
			}
		}

		gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );

		// Store off the old count
		gEngfuncs.pEventAPI->EV_PushPMStates();

		// Now add in all of the players.
		gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );

		while (iShotPenetration != 0)
		{
			if( gEngfuncs.PM_PointContents( vecShotSrc, NULL ) == CONTENTS_SOLID )
				break;

			gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );

			gEngfuncs.pEventAPI->EV_PlayerTrace( vecShotSrc, vecEnd, 0, -1, &tr );

			float flCurrentDistance = tr.fraction * flDistance;

			if( flCurrentDistance == 0.0f )
			{
				break;
			}

			if ( flCurrentDistance > flPenetrationDistance )
				iShotPenetration = 0;
			else iShotPenetration--;

			char cTextureType = EV_HLDM_PlayTextureSound(idx, &tr, vecShotSrc, vecEnd, iBulletType, isSky );
			bool bSparks = true;
			int r_smoke, g_smoke, b_smoke;
			r_smoke = g_smoke = b_smoke = 40;

			switch (cTextureType)
			{
			case CHAR_TEX_METAL:
				iPenetrationPower *= 0.15;
				break;
			case CHAR_TEX_CONCRETE:
				r_smoke = g_smoke = b_smoke = 65;
				iPenetrationPower *= 0.25;
				break;
			case CHAR_TEX_VENT:
			case CHAR_TEX_GRATE:
				iPenetrationPower *= 0.5;
				break;
			case CHAR_TEX_TILE:
				iPenetrationPower *= 0.65;
				break;
			case CHAR_TEX_COMPUTER:
				iPenetrationPower *= 0.4;
				break;
			case CHAR_TEX_WOOD:
				bSparks = false;
				r_smoke = 75;
				g_smoke = 42;
				b_smoke = 15;
				break;
			}

			// do damage, paint decals
			EV_HLDM_DecalGunshot( &tr, iBulletType, 0, r_smoke, g_smoke, b_smoke, true, bSparks, cTextureType, isSky );

			if(/* iBulletType == BULLET_PLAYER_BUCKSHOT ||*/ iShotPenetration <= 0 )
			{
				break;
			}

			flDistance = (flDistance - flCurrentDistance) * 0.5;
			VectorMA( tr.endpos, iPenetration, vecDir, vecShotSrc );
			VectorMA( vecShotSrc, flDistance, vecDir, vecEnd );

			// trace back, so we will have a decal on the other side of solid area
			pmtrace_t trOriginal;

			if( gEngfuncs.PM_PointContents( vecShotSrc, NULL ) != CONTENTS_SOLID )
			{
				gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
				gEngfuncs.pEventAPI->EV_PlayerTrace(vecShotSrc, vecSrc, 0, -1, &trOriginal);
				if( !trOriginal.startsolid )
					EV_HLDM_DecalGunshot( &trOriginal, iBulletType, 0, r_smoke, g_smoke, b_smoke, true, bSparks, cTextureType, isSky );
			}
		}
		gEngfuncs.pEventAPI->EV_PopPMStates();
	}

}

void EV_CS16Client_KillEveryRound( TEMPENTITY *te, float frametime, float current_time )
{
	if( !g_flRoundTime && current_time > g_flRoundTime )
	{
		// Mark it die on next TempEntUpdate
		te->die = 0.0f;
		// Set null renderamt, so it will be invisible now
		// Also it will die immediately, if FTEMP_FADEOUT was set
		te->entity.curstate.renderamt = 0;
	}
}

void RemoveBody( TEMPENTITY *te, float frametime, float current_time )
{
	if ( current_time >= gEngfuncs.pfnGetCvarFloat("cl_corpsestay") + te->entity.curstate.fuser2 + 5.0f )
		te->entity.origin.z = te->entity.origin.z - 5.0f * frametime;
}

void HitBody( TEMPENTITY *ent, pmtrace_s *ptr )
{
	if ( ptr->plane.normal.z > 0.0f )
    	ent->flags |= FTENT_BODYGRAVITY;
}

TEMPENTITY *g_DeadPlayerModels[64];

void CreateCorpse(Vector vOrigin, Vector vAngles, const char *pModel, float flAnimTime, int iSequence, int iBody)
{
	int modelIdx = gEngfuncs.pEventAPI->EV_FindModelIndex(pModel);
	Vector null(0, 0, 0);
	TEMPENTITY *model = gEngfuncs.pEfxAPI->R_TempModel( vOrigin, null, vAngles, 100.0f, modelIdx, 0 );

	if( model )
	{
		model->flags = (FTENT_CLIENTCUSTOM|FTENT_PERSIST|FTENT_SPRANIMATE|FTENT_FADEOUT|FTENT_COLLIDEWORLD|FTENT_BODYTRACE);
		model->frameMax = 255.0f;
		model->entity.curstate.framerate = 1.0f;
		model->entity.curstate.animtime = flAnimTime;
		model->entity.curstate.frame = 0.0f;
		model->entity.curstate.fuser1 = gHUD.m_flTime + 1.0f;
		model->entity.curstate.sequence = iSequence;
		model->entity.curstate.body = iBody;
		model->entity.baseline.renderamt = 255;
		model->entity.curstate.renderamt = 255;
		model->entity.curstate.fuser2 = gHUD.m_flTime + gEngfuncs.pfnGetCvarFloat("cl_corpsestay");
		model->callback = RemoveBody;
		model->hitcallback = HitBody;
		model->bounceFactor = 0.0f;
		model->die = gEngfuncs.GetClientTime() + gEngfuncs.pfnGetCvarFloat("cl_corpsestay") + 9.0f;
		//model->entity.curstate.renderfx = kRenderFxDeadPlayer;
		//model->entity.curstate.fuser4 = gHUD.m_flTime;

		for ( int i = 0; i < 64; i++ )
		{
			if ( !g_DeadPlayerModels[i] )
			{
				g_DeadPlayerModels[i] = model;
				break;
			}
		}
	}
}

```

`cl_dll/events/event_ak47.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"

static const char *SOUNDS_NAME[] =
{
	"weapons/ak47-1.wav",
	"weapons/ak47-2.wav"
};

void EV_FireAK47( event_args_t *args )
{
	vec3_t ShellVelocity, ShellOrigin;
	Vector vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2] );
	Vector velocity( args->velocity );
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( args->entindex ) )
	{
		++g_iShotsFired;
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(AK47_SHOOT1, AK47_SHOOT3), 2);
		EV_MuzzleFlash();
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );

	Vector vSpread( args->fparam1, args->fparam2, 0.0f );
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_762MM,
		2 );
}

```

`cl_dll/events/event_aug.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"

static const char *SOUNDS_NAME = "weapons/aug-1.wav";

void EV_FireAUG( struct event_args_s *args )
{
	vec3_t ShellVelocity, ShellOrigin;
	Vector vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2] );
	Vector velocity( args->velocity );
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(AUG_SHOOT1, AUG_SHOOT3), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_awp.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/awp1.wav";

void EV_FireAWP( event_args_t *args )
{
	Vector vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( Com_RandomLong(AWP_SHOOT, AWP_SHOOT3), 2 );
	}

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_338MAG,
		3 );
}

```

`cl_dll/events/event_createexplo.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

// TODO: Implement. Used in CS:CZDS
void EV_CreateExplo(event_args_s *args)
{
	gEngfuncs.Con_DPrintf("^3EXPUROSION !!!111");
}

```

`cl_dll/events/event_createsmoke.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

#include "com_model.h"

#define SMOKE_CLOUDS 20

void EV_CreateSmoke(event_args_s *args)
{
	TEMPENTITY *pTemp;

	if( !args->bparam2 ) //first explosion
	{
		const model_t *pGasModel = gEngfuncs.GetSpritePointer(gHUD.m_hGasPuff);

		for( int i = 0; i < SMOKE_CLOUDS; i++ )
		{
			// randomize smoke cloud position
			Vector org = args->origin;
			if( i != 0 )
			{
				org.x += Com_RandomFloat(-100.0f, 100.0f);
				org.y += Com_RandomFloat(-100.0f, 100.0f);
			}
			org.z += 30; 

			pTemp = gEngfuncs.pEfxAPI->CL_TempEntAllocNoModel( org );
			if( pTemp )
			{
				// don't die when animation is ended
				pTemp->flags |= (FTENT_SPRANIMATELOOP | FTENT_COLLIDEWORLD | FTENT_CLIENTCUSTOM);
				pTemp->flags &= ~(FTENT_NOMODEL);
				pTemp->die = gEngfuncs.GetClientTime() + 30.0f;
				pTemp->callback = [](struct tempent_s *te, float frametime, float currenttime) -> void
				{
					if( te->entity.curstate.renderamt > 0 && currenttime >= te->entity.curstate.fuser3 )
					{
						te->entity.curstate.renderamt = 255.0f - (currenttime - te->entity.curstate.fuser3) * te->entity.baseline.renderamt ;
						if( te->entity.curstate.renderamt < 0 ) te->entity.curstate.renderamt = 0;
					}
					EV_CS16Client_KillEveryRound( te, frametime, currenttime );
				};

				// !!! Setup model !!!
				pTemp->entity.model = (struct model_s*)pGasModel;
				pTemp->frameMax = max( 0, pGasModel->numframes - 1 );

				pTemp->entity.curstate.fuser3 = gEngfuncs.GetClientTime() + 15.0f; // start fading after 15 sec
				pTemp->entity.curstate.fuser4 = gEngfuncs.GetClientTime(); // entity creation time

				pTemp->entity.curstate.renderamt = 255;
				pTemp->entity.curstate.rendermode = kRenderTransTexture;
				pTemp->entity.curstate.rendercolor.r = Com_RandomLong(210, 230);
				pTemp->entity.curstate.rendercolor.g = Com_RandomLong(210, 230);
				pTemp->entity.curstate.rendercolor.b = Com_RandomLong(210, 230);
				pTemp->entity.curstate.scale = 5.0f;

				// make it move slowly
				pTemp->entity.baseline.origin.x = Com_RandomLong(-5, 5);
				pTemp->entity.baseline.origin.y = Com_RandomLong(-5, 5);
				pTemp->entity.baseline.renderamt = 18;

				if( i == 0 )
				{
					gHUD.m_Spectator.AddOverviewEntityToList( gHUD.m_hGasPuff, &pTemp->entity, 14.0f );
				}
			}
		}
	}
	else // second and other
	{
		int g = gEngfuncs.pfnRandomLong(155, 175);

		Vector dir( args->fparam1, args->fparam2, 0.0f );
		Vector vel( 0.0f, 0.0f, 0.0f );

		EV_CS16Client_CreateSmoke( SMOKE_BLACK, args->origin, dir, args->iparam1 / 100, 1.0f, g, g, g, true, vel, 25 );
	}
}

```

`cl_dll/events/event_czerods.cpp`:

```cpp
// This is an open source non-commercial project. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

void EV_FireM60( event_args_t *args )
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(1,2), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -10.0, -13.0, true);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -10.0, 13.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( "weapons/m60-1.wav" );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;

	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_762MM,
		2 );
}

void EV_FireCamera( event_args_t *args )
{
	int idx = args->entindex;
	Vector origin = args->origin;

	if( EV_IsLocal( idx ) )
		gEngfuncs.pEventAPI->EV_WeaponAnimation( 1, 2 );

	PLAY_EVENT_SOUND( "weapons/camera-1.wav" );
}
void EV_FireFiberOpticCamera( event_args_t *args )
{
	ConsolePrint( "FIRE FIBER OPTIC CAMERA !!! !!! !!!\n");
}
void EV_FireShieldGun( event_args_t *args )
{

}

int g_iBlowTorchFiring = 0;
void EV_HolsterBlowtorch( event_args_t *args )
{
	g_iBlowTorchFiring = 0;
}
void EV_IdleBlowtorch( event_args_t *args )
{
	g_iBlowTorchFiring = 1;
}

void EV_FireBlowtorch( event_args_t *args )
{
	int idx = args->entindex;
	Vector origin = args->origin;
	Vector angles(
		args->iparam1 / 10000000.0f + args->angles[0],
		args->iparam2 / 10000000.0f + args->angles[1],
		args->angles[2] );

	Vector forward, right, up;
	Vector vecSrc;

	AngleVectors( angles, forward, right, up );

	EV_GetGunPosition( args, vecSrc, origin );

	if ( EV_IsLocal(idx) )
	  gEngfuncs.pEventAPI->EV_WeaponAnimation(1, 2);

	g_iBlowTorchFiring = 2;

	Vector vSpread( args->fparam1, args->fparam2, 0.0f );

	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, forward,
		vSpread, 36.0, BULLET_PLAYER_BLOWTORCH,
		2 );

}
void EV_FireLaws( event_args_t *args )
{

}
void EV_FireBriefcase( event_args_t *args )
{
	int idx = args->entindex;
	Vector origin = args->origin;

	if( EV_IsLocal( idx ) )
		gEngfuncs.pEventAPI->EV_WeaponAnimation( 3, 2 );

	PLAY_EVENT_SOUND( "weapons/briefcase_use.wav" );
}
void EV_FireMedkit( event_args_t *args )
{
	int idx = args->entindex;
	Vector origin = args->origin;

	if( EV_IsLocal( idx ) )
		gEngfuncs.pEventAPI->EV_WeaponAnimation( 2, 2 );

	PLAY_EVENT_SOUND( "weapons/blowtorch-1.wav" );

}
void EV_FireSyringe( event_args_t *args )
{
	int idx = args->entindex;
	Vector origin = args->origin;

	if( EV_IsLocal( idx ) )
		gEngfuncs.pEventAPI->EV_WeaponAnimation( 2, 2 );

	PLAY_EVENT_SOUND( "weapons/syringe_use.wav" );

}
void EV_FireRadio( event_args_t *args )
{
	int idx = args->entindex;
	Vector origin = args->origin;

	if( EV_IsLocal( idx ) )
		gEngfuncs.pEventAPI->EV_WeaponAnimation( 1, 2 );

	PLAY_EVENT_SOUND( "weapons/radio_activate.wav" );
}
void EV_FireZipline( event_args_t *args )
{
	if ( EV_IsLocal(args->entindex) )
	  gEngfuncs.pEventAPI->EV_WeaponAnimation(3, 2);
}
void EV_CreateGlass( event_args_t *args )
{

}
void EV_GrenadeExplosion( event_args_t *args )
{

}

```

`cl_dll/events/event_deagle.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME[] =
{
	"weapons/deagle-1.wav",
	"weapons/deagle-2.wav"
};

void EV_FireDEAGLE( event_args_t *args )
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	vec3_t vecSrc;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
	);
	Vector velocity( args->velocity );
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		if( !args->bparam1 )
		{
			gEngfuncs.pEventAPI->EV_WeaponAnimation( Com_RandomLong(DEAGLE_SHOOT1, DEAGLE_SHOOT2), 2 );
		}
		else
		{
			gEngfuncs.pEventAPI->EV_WeaponAnimation( DEAGLE_SHOOT_EMPTY, 2 );
		}
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -11.0, -16.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -11.0, 16.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	Vector vSpread( args->fparam1, args->fparam2, 0.0f );
	
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, forward,
		vSpread, 8192.0, BULLET_PLAYER_50AE,
		2 );
}

```

`cl_dll/events/event_decal_reset.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include <math.h>
#include "events.h"

// HACKHACK: This is very unreliable way to get round time
float g_flRoundTime = 0.0f;

extern TEMPENTITY *g_DeadPlayerModels[64];

void EV_DecalReset(event_args_s *args)
{
	int decalnum = (int)(gEngfuncs.pfnGetCvarFloat("r_decals"));

	for( int i = 0; i < decalnum; i++ )
		gEngfuncs.pEfxAPI->R_DecalRemoveAll( i );
	
	g_flRoundTime = gEngfuncs.GetClientTime();
	
	if ( g_DeadPlayerModels )
	{
		for ( int i = 0; i < 64; i++ )
		{
			if ( g_DeadPlayerModels[i] )
			{
				g_DeadPlayerModels[i]->die = 0.0f;
				g_DeadPlayerModels[i] = NULL;
			}
		}
	}
}

```

`cl_dll/events/event_elite.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/elite_fire.wav";

// false is left
// true is right
void EV_FireElite( event_args_s *args, bool isRight )
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;

	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles( args->angles );
	Vector velocity( args->velocity );
	Vector forward, right, up;
	int		sequence;
	float flTimeDiff = args->fparam1;
	int iBulletsLeft = args->iparam2;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();

		if( !iBulletsLeft ) sequence = ELITE_SHOOTLEFTLAST;
		else if( flTimeDiff >= 0.5 ) sequence = ELITE_SHOOTLEFT5;
		else if( flTimeDiff >= 0.4 ) sequence = ELITE_SHOOTLEFT4;
		else if( flTimeDiff >= 0.3 ) sequence = ELITE_SHOOTLEFT3;
		else if( flTimeDiff >= 0.2 ) sequence = ELITE_SHOOTLEFT2;
		else sequence = ELITE_SHOOTLEFT1;

		if( isRight )
		{
			sequence += (ELITE_SHOOTRIGHT1 - ELITE_SHOOTLEFT1);

			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -11.0, -16.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -11.0, 16.0, 0);
		}

		gEngfuncs.pEventAPI->EV_WeaponAnimation(sequence, 2);
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}
	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam2;
	vSpread.y = args->iparam1 / 100.0f;

	if( isRight )
	{
		vecSrc = vecSrc + right * 5;
	}
	else
	{
		vecSrc = vecSrc - right * 5;
	}

	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_9MM,
		2 );
}

void EV_FireEliteLeft(event_args_s *args)
{
	EV_FireElite( args, false );
}

void EV_FireEliteRight( event_args_s *args )
{
	EV_FireElite( args, true );
}

```

`cl_dll/events/event_famas.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME[] =
{
	"weapons/famas-1.wav", "weapons/famas-2.wav"
};

void EV_FireFAMAS( event_args_t *args )
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 10000000.0f + args->angles[0],
		args->iparam2 / 10000000.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(FAMAS_SHOOT1,FAMAS_SHOOT3), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;

	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_fiveseven.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/fiveseven-1.wav";


void EV_Fire57(event_args_t *args)
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		if( !args->bparam1 )
		{
			gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(FIVESEVEN_SHOOT1, FIVESEVEN_SHOOT2), 2);
		}
		else
		{
			gEngfuncs.pEventAPI->EV_WeaponAnimation(FIVESEVEN_SHOOT_EMPTY, 2);
		}

		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_57MM,
		2 );
}

```

`cl_dll/events/event_g3sg1.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/g3sg1-1.wav";

void EV_FireG3SG1(event_args_s *args)
{
	vec3_t ShellVelocity, ShellOrigin;
	Vector vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( args->entindex ) )
	{
		++g_iShotsFired;
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(G3SG1_SHOOT, G3SG1_SHOOT2), 2);
		EV_MuzzleFlash();
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_762MM,
		2 );
}

```

`cl_dll/events/event_galil.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME[] =
{
	"weapons/galil-1.wav", "weapons/galil-2.wav"
};


void EV_FireGALIL( event_args_t *args )
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;
	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 10000000.0f + args->angles[0],
		args->iparam2 / 10000000.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;


	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(GALIL_SHOOT1 + Com_RandomLong(0,2), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong( 0, 1 )] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;

	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_glock18.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"

bool g_bGlockBurstMode = false;

static const char *SOUNDS_NAME[] =
{
	"weapons/glock18-1.wav", "weapons/glock18-2.wav"
};

void EV_Fireglock18( event_args_t *args )
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;

	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		int seq;
		bool isBurst = (g_iWeaponFlags & WPNSTATE_GLOCK18_BURST_MODE) != 0 || g_bGlockBurstMode;
		if( !args->bparam1 )
		{
			if( g_bHoldingShield )
			{
				seq = Com_RandomLong(GLOCK18_SHIELD_SHOOT, GLOCK18_SHIELD_SHOOT2);
			}
			else
			{
				seq = isBurst? GLOCK18_SHOOT : GLOCK18_SHOOT3;
			}
		}
		else
		{
			if( g_bHoldingShield )
				seq = GLOCK18_SHIELD_SHOOT_EMPTY;
			else
				seq = GLOCK18_SHOOT_EMPTY;
		}
		gEngfuncs.pEventAPI->EV_WeaponAnimation(seq, 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( ((g_iWeaponFlags & WPNSTATE_GLOCK18_BURST_MODE) != 0 || g_bGlockBurstMode )
						&& !g_bHoldingShield ? SOUNDS_NAME[0] : SOUNDS_NAME[1] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 4096.0, BULLET_PLAYER_9MM,
		2 );
}

```

`cl_dll/events/event_knife.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/knife_miss1.wav";

void EV_Knife( struct event_args_s *args )
{
	int    idx = args->entindex;
	Vector origin( args->origin );

	if( EV_IsLocal( idx ))
		gEngfuncs.pEventAPI->EV_WeaponAnimation( args->iparam1, 2 );

	//Play Swing sound
	PLAY_EVENT_SOUND( SOUNDS_NAME );
}

```

`cl_dll/events/event_m249.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME[] =
{
	 "weapons/m249-1.wav", "weapons/m249-2.wav"
};

void EV_FireM249(event_args_s *args)
{
	vec3_t ShellVelocity, ShellOrigin;
	Vector vecSrc, vecAiming;

	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( args->entindex ) )
	{
		++g_iShotsFired;
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(M249_SHOOT1, M249_SHOOT2), 2);
		EV_MuzzleFlash();
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -10.0, -13.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -10.0, 13.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_m3.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"

static const char *SOUNDS_NAME = "weapons/m3-1.wav";

void EV_FireM3( event_args_t *args )
{
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(M3_FIRE1, M3_FIRE2), 2);
	}

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = 0.0725;
	vSpread.y = 0.0725;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		9, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_BUCKSHOT,
		1 );
}

```

`cl_dll/events/event_m4a1.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME[] =
{
	"weapons/m4a1-1.wav",
	"weapons/m4a1_unsil-1.wav",
	"weapons/m4a1_unsil-2.wav"
};

// bparam1: 1 if silenced, 0 if unsilenced
void EV_FireM4A1( event_args_t *args )
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;
	int    sequence, idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		if( args->bparam1 )
		{
			sequence = Com_RandomLong( M4A1_SHOOT1, M4A1_SHOOT3 );
		}
		else
		{
			sequence = Com_RandomLong( M4A1_UNSIL_SHOOT1, M4A1_UNSIL_SHOOT3 );
		}
		gEngfuncs.pEventAPI->EV_WeaponAnimation(sequence, 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( args->bparam1 ? SOUNDS_NAME[0] : SOUNDS_NAME[Com_RandomLong( 1, 2 )]);

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_mac10.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/mac10-1.wav";

void EV_FireMAC10(event_args_s *args)
{
	vec3_t ShellVelocity, ShellOrigin;
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( args->entindex ) )
	{
		++g_iShotsFired;
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(MAC10_SHOOT1, MAC10_SHOOT3), 2);
		EV_MuzzleFlash();
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32.0, -9.0, -11.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32.0, -9.0, 11.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_45ACP,
		2 );
}

```

`cl_dll/events/event_mp5n.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME[] =
{
	"weapons/mp5-1.wav",
	"weapons/mp5-2.wav"
};

void EV_FireMP5( event_args_t *args )
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(MP5N_SHOOT1 + Com_RandomLong(0,2), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -10.0, -11.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -10.0, 11.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_9MM,
		2 );
}

```

`cl_dll/events/event_p228.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/p228-1.wav";

void EV_FireP228(event_args_s *args)
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		int seq;
		if( !args->bparam1 )
		{
			if( g_bHoldingShield )
				seq = Com_RandomLong(P228_SHIELD_SHOOT1, P228_SHIELD_SHOOT2);
			else
				seq = Com_RandomLong(P228_SHOOT1, P228_SHOOT3);
		}
		else
		{
			seq = g_bHoldingShield ? (int)P228_SHIELD_SHOOT_EMPTY : (int)P228_SHOOT_EMPTY;
		}
		gEngfuncs.pEventAPI->EV_WeaponAnimation(seq, 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);
	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_357SIG,
		2 );
}

```

`cl_dll/events/event_p90.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/p90-1.wav";

void EV_FireP90(event_args_s *args)
{
	vec3_t ShellVelocity, ShellOrigin;
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( args->entindex ) )
	{
		++g_iShotsFired;
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(P90_SHOOT1, P90_SHOOT3), 2);
		EV_MuzzleFlash();
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -16.0, -22.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -16.0, 22.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_57MM,
		2 );
}

```

`cl_dll/events/event_scout.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum scout_e
{
	SCOUT_IDLE,
	SCOUT_SHOOT,
	SCOUT_SHOOT2,
	SCOUT_RELOAD,
	SCOUT_DRAW
};

static const char *SOUNDS_NAME = "weapons/scout_fire-1.wav";

void EV_FireScout(event_args_s *args)
{
	Vector vecSrc, vecAiming;

	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( Com_RandomLong(SCOUT_SHOOT, SCOUT_SHOOT2), 2 );
	}

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1 / 1000.0f;
	vSpread.y = args->fparam2 / 1000.0f;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_762MM,
		2 );
}

```

`cl_dll/events/event_sg550.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/sg550-1.wav";

void EV_FireSG550(event_args_s *args)
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( Com_RandomLong(SG550_SHOOT, SG550_SHOOT2), 2 );
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );


	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_sg552.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME[] =
{
	"weapons/sg552-1.wav", "weapons/sg552-2.wav"
};

void EV_FireSG552( event_args_t *args )
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(SG552_SHOOT1, SG552_SHOOT3), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);
	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_tmp.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME[] =
{
	"weapons/tmp-1.wav", "weapons/tmp-2.wav"
};

void EV_FireTMP(event_args_s *args)
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(TMP_SHOOT1, TMP_SHOOT3), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32.0, -6.0, -11.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32.0, -6.0, 11.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);
	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong( 0, 1 )] );
	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_9MM,
		2 );
}

```

`cl_dll/events/event_ump45.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/ump45-1.wav";

void EV_FireUMP45(event_args_s *args)
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(UMP45_SHOOT1, UMP45_SHOOT3), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 34.0, -10.0, -11.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 34.0, -10.0, 11.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);
	PLAY_EVENT_SOUND( SOUNDS_NAME );
	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_45ACP,
		2 );
}

```

`cl_dll/events/event_usp.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"

static const char *SOUNDS_NAME[] =
{
	"weapons/usp1.wav",
	"weapons/usp2.wav",
	"weapons/usp_unsil-1.wav",
};
void EV_FireUSP( event_args_t *args )
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;

	bool silencer_on = !args->bparam2;
	bool empty		 = args->bparam1;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		int seq;
		if( g_bHoldingShield )
		{
			if( !empty )
				seq = Com_RandomLong(USP_SHIELD_SHOOT1, USP_SHIELD_SHOOT2);
			else seq = USP_SHIELD_SHOOT_EMPTY;
		}
		else if ( silencer_on )
		{
			if( !empty )
				seq = Com_RandomLong(USP_UNSIL_SHOOT1, USP_UNSIL_SHOOT3);
			else seq = USP_UNSIL_SHOOT_EMPTY;
		}
		else
		{
			EV_MuzzleFlash();
			if( !empty )
				seq = Com_RandomLong(USP_SHOOT1, USP_SHOOT3);
			else seq = USP_SHOOT_EMPTY;
		}

		gEngfuncs.pEventAPI->EV_WeaponAnimation(seq, 2);


		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( silencer_on? SOUNDS_NAME[2] : SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_45ACP,
		2 );
}

```

`cl_dll/events/event_vehicle.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

#include <string.h>

static const char *SOUNDS_NAME[] =
{
	"plats/vehicle1.wav",
	"plats/vehicle2.wav",
	"plats/vehicle3.wav",
	"plats/vehicle4.wav",
	"plats/vehicle6.wav",
	"plats/vehicle7.wav"
};

static const char *SOUNDS_NAME_TRAIN[] =
{
	"plats/ttrain1.wav",
	"plats/ttrain2.wav",
	"plats/ttrain3.wav",
	"plats/ttrain4.wav",
	"plats/ttrain6.wav",
	"plats/ttrain7.wav"
};


void EV_Vehicle(event_args_s *args)
{
	Vector origin(args->origin);
	int idx = args->entindex;
	unsigned short us_params = (unsigned short)args->iparam1;
	int stop	  = args->bparam1;
	float m_flVolume	= (float)(us_params & 0x003f)/40.0;
	int noise		= (int)(((us_params) >> 12 ) & 0x0007);
	int pitch		= (int)( 10.0 * (float)( ( us_params >> 6 ) & 0x003f ) );


	if( noise < 0 || noise > 5 )
		return;

	if ( stop )
	{
		gEngfuncs.pEventAPI->EV_StopSound( idx, CHAN_STATIC, SOUNDS_NAME[noise] );
	}
	else
	{
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_STATIC, SOUNDS_NAME[noise], m_flVolume, ATTN_NORM, 0, pitch );
	}
}


void EV_TrainPitchAdjust( event_args_t *args )
{
	Vector origin(args->origin);
	int idx = args->entindex;
	unsigned short us_params = (unsigned short)args->iparam1;
	int stop	  = args->bparam1;
	float m_flVolume	= (float)(us_params & 0x003f)/40.0;
	int noise		= (int)(((us_params) >> 12 ) & 0x0007);
	int pitch		= (int)( 10.0 * (float)( ( us_params >> 6 ) & 0x003f ) );

	if( noise < 0 || noise > 5 )
		return;

	if ( stop )
	{
		gEngfuncs.pEventAPI->EV_StopSound( idx, CHAN_STATIC, SOUNDS_NAME_TRAIN[noise] );
	}
	else
	{
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_STATIC, SOUNDS_NAME_TRAIN[noise], m_flVolume, ATTN_NORM, 0, pitch );
	}
}

```

`cl_dll/events/event_xm1014.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
#include "wpn_shared.h"


static const char *SOUNDS_NAME = "weapons/xm1014-1.wav";

void EV_FireXM1014(event_args_s *args)
{
	Vector ShellVelocity;
	Vector ShellOrigin;
	Vector vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(XM1014_FIRE1, XM1014_FIRE2), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 22.0, -9.0, -11.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 22.0, -9.0, 11.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iShotgunShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = 0.0725;
	vSpread.y = 0.0725;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		6, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_BUCKSHOT,
		1 );
}

```

`cl_dll/flashlight.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// flashlight.cpp
//
// implementation of CHudFlashlight class
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>

#include "draw_util.h"

#define BAT_NAME "sprites/%d_Flashlight.spr"

int CHudFlashlight::Init(void)
{
	m_fFade = 0;
	m_fOn = 0;

	HOOK_MESSAGE(gHUD.m_Flash, Flashlight);
	HOOK_MESSAGE(gHUD.m_Flash, FlashBat);

	m_iFlags |= HUD_DRAW;

	gHUD.AddHudElem(this);

	return 1;
}

void CHudFlashlight::Reset(void)
{
	m_fFade = 0;
	m_fOn = 0;
}

int CHudFlashlight::VidInit(void)
{
	m_hSprite1.SetSpriteByName("flash_empty");
	m_hSprite2.SetSpriteByName("flash_full");
	m_hBeam.SetSpriteByName("flash_beam");
	m_iWidth = m_hSprite1.rect.Width();

	return 1;
}

int CHudFlashlight:: MsgFunc_FlashBat(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	int x = reader.ReadByte();
	m_iBat = x;
	m_flBat = ((float)x)/100.0;

	return 1;
}

int CHudFlashlight:: MsgFunc_Flashlight(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	m_fOn = reader.ReadByte();
	int x = reader.ReadByte();
	m_iBat = x;
	m_flBat = ((float)x)/100.0;

	return 1;
}

int CHudFlashlight::Draw(float flTime)
{
	if ( gHUD.m_iHideHUDDisplay & ( HIDEHUD_FLASHLIGHT | HIDEHUD_ALL ) )
		return 1;

	int r, g, b, x, y, a;
	wrect_t rc;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return 1;

	if (m_fOn)
		a = 225;
	else
		a = MIN_ALPHA;

	if (m_flBat < 0.20)
		DrawUtils::UnpackRGB(r,g,b, RGB_REDISH);
	else
		DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );

	DrawUtils::ScaleColors(r, g, b, a);

	y = (m_hSprite1.rect.Height())/2;
	x = ScreenWidth - m_iWidth - m_iWidth/2 ;

	// Draw the flashlight casing
	SPR_Set(m_hSprite1.spr, r, g, b );
	SPR_DrawAdditive( 0,  x, y, &m_hSprite1.rect);

	if ( m_fOn )
	{  // draw the flashlight beam
		x = ScreenWidth - m_iWidth/2;

		SPR_Set( m_hBeam.spr, r, g, b );
		SPR_DrawAdditive( 0, x, y, &m_hBeam.rect );
	}

	// draw the flashlight energy level
	x = ScreenWidth - m_iWidth - m_iWidth/2 ;
	int iOffset = m_iWidth * (1.0 - m_flBat);
	if (iOffset < m_iWidth)
	{
		rc = m_hSprite2.rect;
		rc.left += iOffset;

		SPR_Set(m_hSprite2.spr, r, g, b );
		SPR_DrawAdditive( 0, x + iOffset, y, &rc);
	}


	return 1;
}

```

`cl_dll/geiger.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Geiger.cpp
//
// implementation of CHudAmmo class
//

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <time.h>
#include <stdio.h>

#include "parsemsg.h"

int CHudGeiger::Init(void)
{
	HOOK_MESSAGE( gHUD.m_Geiger, Geiger );

	m_iGeigerRange = 0;
	m_iFlags = 0;

	gHUD.AddHudElem(this);

	srand( (unsigned)time( NULL ) );

	return 1;
}

int CHudGeiger::VidInit(void)
{
	return 1;
}

int CHudGeiger::MsgFunc_Geiger(const char *pszName,  int iSize, void *pbuf)
{

	BufferReader reader( pszName, pbuf, iSize );

	// update geiger data
	m_iGeigerRange = reader.ReadByte() << 2;

	if( m_iGeigerRange < 0 || m_iGeigerRange > 1000 )
		m_iFlags &= ~HUD_DRAW;
	else
		m_iFlags |= HUD_DRAW;

	return 1;
}

int CHudGeiger::Draw (float flTime)
{
	int pct, i;
	float flvol;
	
	if (m_iGeigerRange < 1000 && m_iGeigerRange > 0)
	{
		// peicewise linear is better than continuous formula for this
		if (m_iGeigerRange > 800)
		{
			pct = 0;			//Con_Printf ( "range > 800\n");
			i = 0;
		}
		else if (m_iGeigerRange > 600)
		{
			pct = 2;
			//flvol = 0.4;		//Con_Printf ( "range > 600\n");
			i = 2;
		}
		else if (m_iGeigerRange > 500)
		{
			pct = 4;
			//flvol = 0.5;		//Con_Printf ( "range > 500\n");
			i = 2;
		}
		else if (m_iGeigerRange > 400)
		{
			pct = 8;
			//flvol = 0.6;		//Con_Printf ( "range > 400\n");
			i = 3;
		}
		else if (m_iGeigerRange > 300)
		{
			pct = 8;
			//flvol = 0.7;		//Con_Printf ( "range > 300\n");
			i = 3;
		}
		else if (m_iGeigerRange > 200)
		{
			pct = 28;
			//flvol = 0.78;		//Con_Printf ( "range > 200\n");
			i = 3;
		}
		else if (m_iGeigerRange > 150)
		{
			pct = 40;
			//flvol = 0.80;		//Con_Printf ( "range > 150\n");
			i = 3;
		}
		else if (m_iGeigerRange > 100)
		{
			pct = 60;
			//flvol = 0.85;		//Con_Printf ( "range > 100\n");
			i = 3;
		}
		else if (m_iGeigerRange > 75)
		{
			pct = 80;
			//flvol = 0.9;		//Con_Printf ( "range > 75\n");
			//gflGeigerDelay = cl.time + GEIGERDELAY * 0.75;
			i = 3;
		}
		else if (m_iGeigerRange > 50)
		{
			pct = 90;
			//flvol = 0.95;		//Con_Printf ( "range > 50\n");
			i = 2;
		}
		else
		{
			pct = 95;
			//flvol = 1.0;		//Con_Printf ( "range < 50\n");
			i = 2;
		}

		flvol = Com_RandomFloat(0.25, 25);

		if( pct && (rand() & 127) < pct )
		{
			//S_StartDynamicSound (-1, 0, rgsfx[rand() % i], r_origin, flvol, 1.0, 0, 100);	
			char sz[256];
			
			int j = rand() & 1;
			if( i > 2 )
				j += rand() & 1;

			sprintf( sz, "player/geiger%d.wav", j + 1 );
			PlaySound( sz, flvol );
			
		}
	}

	return 1;
}

```

`cl_dll/health.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Health.cpp
//
// implementation of CHudHealth class
//

#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include <string.h>
#include "eventscripts.h"

#include "draw_util.h"

#include "ev_hldm.h"
#include "com_weapons.h"

#define PAIN_NAME "sprites/%d_pain.spr"
#define DAMAGE_NAME "sprites/%d_dmg.spr"
#define EPSILON 0.4f

int giDmgHeight, giDmgWidth;

int giDmgFlags[NUM_DMG_TYPES] = 
{
	DMG_POISON,
	DMG_ACID,
	DMG_FREEZE|DMG_SLOWFREEZE,
	DMG_DROWN,
	DMG_BURN|DMG_SLOWBURN,
	DMG_NERVEGAS,
	DMG_RADIATION,
	DMG_SHOCK,
	DMG_CALTROP,
	DMG_TRANQ,
	DMG_CONCUSS,
	DMG_HALLUC
};

enum
{
	ATK_FRONT = 0,
	ATK_RIGHT,
	ATK_REAR,
	ATK_LEFT
};

int CHudHealth::Init(void)
{
	HOOK_MESSAGE(gHUD.m_Health, Health);
	HOOK_MESSAGE(gHUD.m_Health, Damage);
	HOOK_MESSAGE(gHUD.m_Health, ScoreAttrib);
	HOOK_MESSAGE(gHUD.m_Health, ClCorpse);
	HOOK_MESSAGE( gHUD.m_Health, HealthInfo );
	HOOK_MESSAGE( gHUD.m_Health, Account );

	m_iHealth = 100;
	m_fFade = 0;
	m_iFlags = 0;
	m_bitsDamage = 0;
	giDmgHeight = 0;
	giDmgWidth = 0;

	for( int i = 0; i < 4; i++ )
		m_fAttack[i] = 0;

	memset(m_dmg, 0, sizeof(DAMAGE_IMAGE) * NUM_DMG_TYPES);

	CVAR_CREATE("cl_corpsestay", "600", FCVAR_ARCHIVE);
	gHUD.AddHudElem(this);
	return 1;
}

void CHudHealth::Reset( void )
{
	// make sure the pain compass is cleared when the player respawns
	for( int i = 0; i < 4; i++ )
		m_fAttack[i] = 0;


	// force all the flashing damage icons to expire
	m_bitsDamage = 0;
	for ( int i = 0; i < NUM_DMG_TYPES; i++ )
	{
		m_dmg[i].fExpire = 0;
	}
}

int CHudHealth::VidInit(void)
{
	m_hSprite = LoadSprite(PAIN_NAME);

	m_vAttackPos[ATK_FRONT].x = ScreenWidth  / 2.0 - SPR_Width ( m_hSprite, 0 ) / 2.0;
	m_vAttackPos[ATK_FRONT].y = ScreenHeight / 2.0 - SPR_Height( m_hSprite, 0 ) * 3;

	m_vAttackPos[ATK_RIGHT].x = ScreenWidth  / 2.0 + SPR_Width ( m_hSprite, 1 ) * 2;
	m_vAttackPos[ATK_RIGHT].y = ScreenHeight / 2.0 - SPR_Height( m_hSprite, 1 ) / 2.0;

	m_vAttackPos[ATK_REAR ].x = ScreenWidth  / 2.0 - SPR_Width ( m_hSprite, 2 ) / 2.0;
	m_vAttackPos[ATK_REAR ].y = ScreenHeight / 2.0 + SPR_Height( m_hSprite, 2 ) * 2;

	m_vAttackPos[ATK_LEFT ].x = ScreenWidth  / 2.0 - SPR_Width ( m_hSprite, 3 ) * 3;
	m_vAttackPos[ATK_LEFT ].y = ScreenHeight / 2.0 - SPR_Height( m_hSprite, 3 ) / 2.0;


	m_HUD_dmg_bio = gHUD.GetSpriteIndex( "dmg_bio" ) + 1;
	m_HUD_cross = gHUD.GetSpriteIndex( "cross" );

	giDmgHeight = gHUD.GetSpriteRect(m_HUD_dmg_bio).Width();
	giDmgWidth = gHUD.GetSpriteRect(m_HUD_dmg_bio).Height();

	return 1;
}

int CHudHealth:: MsgFunc_Health(const char *pszName,  int iSize, void *pbuf )
{
	// TODO: update local health data
	BufferReader reader( pszName, pbuf, iSize );
	int x = reader.ReadByte();

	m_iFlags |= HUD_DRAW;

	// Only update the fade if we've changed health
	if (x != m_iHealth)
	{
		m_fFade = FADE_TIME;
		m_iHealth = x;
	}

	return 1;
}


int CHudHealth:: MsgFunc_Damage(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int armor = reader.ReadByte();	// armor
	int damageTaken = reader.ReadByte();	// health
	long bitsDamage = reader.ReadLong(); // damage bits

	vec3_t vecFrom;

	for ( int i = 0 ; i < 3 ; i++)
		vecFrom[i] = reader.ReadCoord();

	UpdateTiles(gHUD.m_flTime, bitsDamage);

	// Actually took damage?
	if ( damageTaken > 0 || armor > 0 )
	{
		CalcDamageDirection(vecFrom);
		if( g_iXash )
		{
			float time = damageTaken * 4.0f + armor * 2.0f;

			if( time > 200.0f ) time = 200.0f;
			gMobileAPI.pfnVibrate( time, 0 );
		}
	}
	return 1;
}

int CHudHealth:: MsgFunc_ScoreAttrib(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int index = reader.ReadByte();
	unsigned char flags = reader.ReadByte();
	g_PlayerExtraInfo[index].dead   = !!(flags & PLAYER_DEAD);
	g_PlayerExtraInfo[index].has_c4 = !!(flags & PLAYER_HAS_C4);
	g_PlayerExtraInfo[index].vip    = !!(flags & PLAYER_VIP);
	g_PlayerExtraInfo[index].has_defuse_kit = !!(flags & PLAYER_HAS_DEFUSER);
	return 1;
}
// Returns back a color from the
// Green <-> Yellow <-> Red ramp
void CHudHealth::GetPainColor( int &r, int &g, int &b, int &a )
{
#if 0
	int iHealth = m_iHealth;

	if (iHealth > 25)
		iHealth -= 25;
	else if ( iHealth < 0 )
		iHealth = 0;
	g = iHealth * 255 / 100;
	r = 255 - g;
	b = 0;
#else
	if( m_iHealth <= 15 )
	{
		a = 255; // If health is getting low, make it bright red
	}
	else
	{
		// Has health changed? Flash the health #
		if (m_fFade)
		{
			m_fFade -= (gHUD.m_flTimeDelta * 20);

			if (m_fFade <= 0)
			{
				m_fFade = 0;
				a = MIN_ALPHA;
			}
			else
			{
				// Fade the health number back to dim
				a = MIN_ALPHA +  (m_fFade/FADE_TIME) * 128;
			}
		}
		else
		{
			a = MIN_ALPHA;
		}
	}

	if (m_iHealth > 25)
	{
		DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
	}
	else
	{
		r = 250;
		g = 0;
		b = 0;
	}
#endif 
}


int CHudHealth::Draw(float flTime)
{
	if( !(gHUD.m_iHideHUDDisplay & HIDEHUD_HEALTH ) && !gEngfuncs.IsSpectateOnly() )
	{
		DrawHealthBar( flTime );
		DrawDamage( flTime );
		DrawPain( flTime );
	}

	return 1;
}

void CHudHealth::DrawHealthBar( float flTime )
{
	int r, g, b;
	int a = 0, x, y;
	int HealthWidth;

	GetPainColor( r, g, b, a );
	DrawUtils::ScaleColors(r, g, b, a );

	// Only draw health if we have the suit.
	if (gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)))
	{
		HealthWidth = gHUD.GetSpriteRect(gHUD.m_HUD_number_0).Width();
		int CrossWidth = gHUD.GetSpriteRect(m_HUD_cross).Width();

		y = ScreenHeight - gHUD.m_iFontHeight - gHUD.m_iFontHeight / 2;
		x = CrossWidth /2;

		SPR_Set(gHUD.GetSprite(m_HUD_cross), r, g, b);
		SPR_DrawAdditive(0, x, y, &gHUD.GetSpriteRect(m_HUD_cross));

		x = CrossWidth + HealthWidth / 2;

		x = DrawUtils::DrawHudNumber(x, y, DHN_3DIGITS | DHN_DRAWZERO, m_iHealth, r, g, b);
	}
}

void CHudHealth::CalcDamageDirection( Vector vecFrom )
{
	Vector	forward, right, up;
	float	side, front, flDistToTarget;

	if( vecFrom.IsNull() )
	{
		for( int i = 0; i < 4; i++ )
			m_fAttack[i] = 0;
		return;
	}

	vecFrom = vecFrom - gHUD.m_vecOrigin;
	flDistToTarget = vecFrom.Length();
	vecFrom = vecFrom.Normalize();
	AngleVectors (gHUD.m_vecAngles, forward, right, up);

	front = DotProduct (vecFrom, right);
	side = DotProduct (vecFrom, forward);

	if (flDistToTarget <= 50)
	{
		for( int i = 0; i < 4; i++ )
			m_fAttack[i] = 1;
	}
	else
	{
		if (side > EPSILON)
			m_fAttack[0] = max(m_fAttack[0], side);
		if (side < -EPSILON)
			m_fAttack[1] = max(m_fAttack[1], 0 - side );
		if (front > EPSILON)
			m_fAttack[2] = max(m_fAttack[2], front);
		if (front < -EPSILON)
			m_fAttack[3] = max(m_fAttack[3], 0 - front );
	}
}

void CHudHealth::DrawPain(float flTime)
{
	if (m_fAttack[0] == 0 &&
		m_fAttack[1] == 0 &&
		m_fAttack[2] == 0 &&
		m_fAttack[3] == 0)
		return;

	float a, fFade = gHUD.m_flTimeDelta * 2;

	for( int i = 0; i < 4; i++ )
	{
		if( m_fAttack[i] > EPSILON )
		{
			/*GetPainColor(r, g, b);
			shade = a * max( m_fAttack[i], 0.5 );
			DrawUtils::ScaleColors(r, g, b, shade);*/

			a = max( m_fAttack[i], 0.5 );

			SPR_Set( m_hSprite, 255 * a, 255 * a, 255 * a);
			SPR_DrawAdditive( i, m_vAttackPos[i].x, m_vAttackPos[i].y, NULL );
			m_fAttack[i] = max( 0, m_fAttack[i] - fFade );
		}
		else
			m_fAttack[i] = 0;
	}
}

void CHudHealth::DrawDamage(float flTime)
{
	int r, g, b, a;

	if (!m_bitsDamage)
		return;

	DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );

	a = (int)( fabs(sin(flTime*2)) * 256.0);

	DrawUtils::ScaleColors(r, g, b, a);
	int i;
	// Draw all the items
	for (i = 0; i < NUM_DMG_TYPES; i++)
	{
		if (m_bitsDamage & giDmgFlags[i])
		{
			DAMAGE_IMAGE *pdmg = &m_dmg[i];
			SPR_Set(gHUD.GetSprite(m_HUD_dmg_bio + i), r, g, b );
			SPR_DrawAdditive(0, pdmg->x, pdmg->y, &gHUD.GetSpriteRect(m_HUD_dmg_bio + i));
		}
	}


	// check for bits that should be expired
	for ( i = 0; i < NUM_DMG_TYPES; i++ )
	{
		DAMAGE_IMAGE *pdmg = &m_dmg[i];

		if ( m_bitsDamage & giDmgFlags[i] )
		{
			pdmg->fExpire = min( flTime + DMG_IMAGE_LIFE, pdmg->fExpire );

			if ( pdmg->fExpire <= flTime		// when the time has expired
				 && a < 40 )						// and the flash is at the low point of the cycle
			{
				pdmg->fExpire = 0;

				int y = pdmg->y;
				pdmg->x = pdmg->y = 0;

				// move everyone above down
				for (int j = 0; j < NUM_DMG_TYPES; j++)
				{
					pdmg = &m_dmg[j];
					if ((pdmg->y) && (pdmg->y < y))
						pdmg->y += giDmgHeight;

				}

				m_bitsDamage &= ~giDmgFlags[i];  // clear the bits
			}
		}
	}
}


void CHudHealth::UpdateTiles(float flTime, long bitsDamage)
{	
	DAMAGE_IMAGE *pdmg;

	// Which types are new?
	long bitsOn = ~m_bitsDamage & bitsDamage;
	
	for (int i = 0; i < NUM_DMG_TYPES; i++)
	{
		pdmg = &m_dmg[i];

		// Is this one already on?
		if (m_bitsDamage & giDmgFlags[i])
		{
			pdmg->fExpire = flTime + DMG_IMAGE_LIFE; // extend the duration
			if (!pdmg->fBaseline)
				pdmg->fBaseline = flTime;
		}

		// Are we just turning it on?
		if (bitsOn & giDmgFlags[i])
		{
			// put this one at the bottom
			pdmg->x = giDmgWidth/8;
			pdmg->y = ScreenHeight - giDmgHeight * 2;
			pdmg->fExpire=flTime + DMG_IMAGE_LIFE;
			
			// move everyone else up
			for (int j = 0; j < NUM_DMG_TYPES; j++)
			{
				if (j == i)
					continue;

				pdmg = &m_dmg[j];
				if (pdmg->y)
					pdmg->y -= giDmgHeight;

			}
			pdmg = &m_dmg[i];
		}
	}

	// damage bits are only turned on here;  they are turned off when the draw time has expired (in DrawDamage())
	m_bitsDamage |= bitsDamage;
}


int CHudHealth :: MsgFunc_ClCorpse(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader(pbuf, iSize);
	char *pModel, szModel[64];
	Vector origin, angles;
	float delay;
	int seq, classID, teamID, playerID;

	pModel		= reader.ReadString();
	origin.x	= reader.ReadLong() / 128.0f;
	origin.y	= reader.ReadLong() / 128.0f;
	origin.z	= reader.ReadLong() / 128.0f;
	angles		= reader.ReadCoordVector();
	delay		= gEngfuncs.GetClientTime() + (reader.ReadLong() / 100.0f);
	seq			= reader.ReadByte();
	classID		= reader.ReadByte();
	teamID		= reader.ReadByte();
	playerID	= reader.ReadByte();

	if( !gHUD.cl_minmodels->value )
	{
		if( !strstr(pModel, "models/") )
			snprintf( szModel, sizeof(szModel), "models/player/%s/%s.mdl", pModel, pModel );
		else
			strncpy( szModel, pModel, sizeof( szModel ));
	}
	else
	{
		int modelidx;
		if( teamID == TEAM_TERRORIST ) // terrorists
		{
			modelidx = gHUD.cl_min_t->value;
			if( !BIsValidTModelIndex(modelidx) )
				modelidx = PLAYERMODEL_LEET;
		}
		else if( teamID == TEAM_CT ) // ct
		{
			if( g_PlayerExtraInfo[playerID].vip )
				modelidx = PLAYERMODEL_VIP;
			else if( !BIsValidCTModelIndex( gHUD.cl_min_ct->value ))
				modelidx = PLAYERMODEL_GIGN;
			else modelidx = gHUD.cl_min_ct->value;
		}
		else modelidx = PLAYERMODEL_PLAYER;

		strncpy( szModel, sPlayerModelFiles[modelidx], sizeof( szModel ) );
	}
	CreateCorpse( origin, angles, szModel, delay, seq, classID );
	return 0;
}

/*
============
CL_IsDead

Returns 1 if health is <= 0
============
*/
bool CL_IsDead()
{
	if( gHUD.m_Health.m_iHealth <= 0 )
		return true;
	return false;
}

int CHudHealth::MsgFunc_HealthInfo( const char *pszName, int iSize, void *buf )
{
	BufferReader reader( pszName, buf, iSize );

	int idx = reader.ReadByte();
	int health = reader.ReadLong();

	if ( idx < MAX_PLAYERS )
		g_PlayerExtraInfo[idx].sb_health = health;

	return 1;
}

int CHudHealth::MsgFunc_Account( const char *pszName, int iSize, void *buf )
{
	BufferReader reader( pszName, buf, iSize );

	int idx = reader.ReadByte();
	int account = reader.ReadLong();

	if ( idx < MAX_PLAYERS )
		g_PlayerExtraInfo[idx].sb_account = account;

	return 1;
}

```

`cl_dll/health.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#pragma once
#define DMG_IMAGE_LIFE		2	// seconds that image is up

#define DMG_IMAGE_POISON	0
#define DMG_IMAGE_ACID		1
#define DMG_IMAGE_COLD		2
#define DMG_IMAGE_DROWN		3
#define DMG_IMAGE_BURN		4
#define DMG_IMAGE_NERVE		5
#define DMG_IMAGE_RAD		6
#define DMG_IMAGE_SHOCK		7
//tf defines
#define DMG_IMAGE_CALTROP	8
#define DMG_IMAGE_TRANQ		9
#define DMG_IMAGE_CONCUSS	10
#define DMG_IMAGE_HALLUC	11
#define NUM_DMG_TYPES		12
// instant damage

#ifndef DMG_CRUSH
#define DMG_GENERIC			0			// generic damage was done
#define DMG_CRUSH			(1 << 0)	// crushed by falling or moving object
#define DMG_BULLET			(1 << 1)	// shot
#define DMG_SLASH			(1 << 2)	// cut, clawed, stabbed
#define DMG_BURN			(1 << 3)	// heat burned
#define DMG_FREEZE			(1 << 4)	// frozen
#define DMG_FALL			(1 << 5)	// fell too far
#define DMG_BLAST			(1 << 6)	// explosive blast damage
#define DMG_CLUB			(1 << 7)	// crowbar, punch, headbutt
#define DMG_SHOCK			(1 << 8)	// electric shock
#define DMG_SONIC			(1 << 9)	// sound pulse shockwave
#define DMG_ENERGYBEAM		(1 << 10)	// laser or other high energy beam 
#define DMG_NEVERGIB		(1 << 12)	// with this bit OR'd in, no damage type will be able to gib victims upon death
#define DMG_ALWAYSGIB		(1 << 13)	// with this bit OR'd in, any damage type can be made to gib victims upon death.


// time-based damage
//mask off TF-specific stuff too
#define DMG_TIMEBASED		(~(0xff003fff))	// mask for time-based damage


#define DMG_DROWN			(1 << 14)	// Drowning
#define DMG_FIRSTTIMEBASED  DMG_DROWN

#define DMG_PARALYZE		(1 << 15)	// slows affected creature down
#define DMG_NERVEGAS		(1 << 16)	// nerve toxins, very bad
#define DMG_POISON			(1 << 17)	// blood poisioning
#define DMG_RADIATION		(1 << 18)	// radiation exposure
#define DMG_DROWNRECOVER	(1 << 19)	// drowning recovery
#define DMG_ACID			(1 << 20)	// toxic chemicals or acid burns
#define DMG_SLOWBURN		(1 << 21)	// in an oven
#define DMG_SLOWFREEZE		(1 << 22)	// in a subzero freezer
#define DMG_MORTAR			(1 << 23)	// Hit by air raid (done to distinguish grenade from mortar)

#endif
//TF ADDITIONS
#define DMG_IGNITE			(1 << 24)	// Players hit by this begin to burn
#define DMG_RADIUS_MAX		(1 << 25)	// Radius damage with this flag doesn't decrease over distance
#define DMG_RADIUS_QUAKE	(1 << 26)	// Radius damage is done like Quake. 1/2 damage at 1/2 radius.
#define DMG_IGNOREARMOR		(1 << 27)	// Damage ignores target's armor
#define DMG_AIMED			(1 << 28)   // Does Hit location damage
#define DMG_WALLPIERCING	(1 << 29)	// Blast Damages ents through walls

#define DMG_CALTROP				(1<<30)
#define DMG_HALLUC				(1<<31)

// TF Healing Additions for TakeHealth
#define DMG_IGNORE_MAXHEALTH	DMG_IGNITE
// TF Redefines since we never use the originals
#define DMG_NAIL				DMG_SLASH
#define DMG_NOT_SELF			DMG_FREEZE


#define DMG_TRANQ				DMG_MORTAR
#define DMG_CONCUSS				DMG_SONIC


struct DAMAGE_IMAGE
{
	float fExpire;
	float fBaseline;
	int	x, y;
};
	
//
//-----------------------------------------------------
//
class CHudHealth: public CHudBase
{
public:
	virtual int Init( void );
	virtual int VidInit( void );
	virtual int Draw(float fTime);
	virtual void Reset( void );

	int MsgFunc_Health(const char *pszName,  int iSize, void *pbuf);
	int MsgFunc_Damage(const char *pszName,  int iSize, void *pbuf);
	int MsgFunc_ScoreAttrib(const char *pszName,  int iSize, void *pbuf);
	int MsgFunc_ClCorpse(const char *pszName,  int iSize, void *pbuf);
	int MsgFunc_HealthInfo( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_Account( const char *pszName, int iSize, void *pbuf );

	int m_iHealth;
	int m_HUD_dmg_bio;
	int m_HUD_cross;
	//float m_fAttackFront, m_fAttackRear, m_fAttackLeft, m_fAttackRight;
	float m_fAttack[4];
	void GetPainColor(int &r, int &g, int &b , int &a);
	float m_fFade;

	int m_iPlayerLastPointedAt;
private:
	void DrawPain( float fTime );
	void DrawDamage( float fTime );
	void DrawHealthBar( float flTime );
	void CalcDamageDirection( Vector vecFrom );
	void UpdateTiles( float fTime, long bits );

	HSPRITE m_hSprite;
	HSPRITE m_hDamage;
	Vector2D m_vAttackPos[4];
	DAMAGE_IMAGE m_dmg[NUM_DMG_TYPES];
	float m_flTimeFlash;
	int	m_bitsDamage;
	cvar_t *cl_radartype;
};

```

`cl_dll/hud.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// hud.cpp
//
// implementation of CHud class
//

#include <new>

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <stdio.h>
#include <assert.h>
#include "parsemsg.h"

#include "demo.h"
#include "demo_api.h"
#include "vgui_parser.h"
#include "rain.h"

#include "camera.h"

#include "draw_util.h"

#if _WIN32
#define strncasecmp _strnicmp
#endif

cvar_t *cl_fog_r;
cvar_t *cl_fog_g;
cvar_t *cl_fog_b;
cvar_t *cl_fog_density;

extern client_sprite_t *GetSpriteList(client_sprite_t *pList, const char *psz, int iRes, int iCount);

// Team Colors
int iNumberOfTeamColors = 3;
int iTeamColors[3][3] =
{
	{ 204, 204, 204 }, // Spectators
	{ 255, 64, 64 }, // CT's
	{ 153, 204, 255 }  // T's
};

class CCStrikeVoiceStatusHelper : public IVoiceStatusHelper
{
public:
	virtual void GetPlayerTextColor( int entindex, int color[3] )
	{
		color[0] = color[1] = color[2] = 255;

		if ( entindex < MAX_PLAYERS )
		{
			int iTeam = g_PlayerExtraInfo[entindex].teamnumber;

			if ( iTeam < 0 )
			{
				iTeam = 0;
			}

			iTeam = iTeam % iNumberOfTeamColors;

			color[0] = iTeamColors[iTeam][0];
			color[1] = iTeamColors[iTeam][1];
			color[2] = iTeamColors[iTeam][2];
		}
	}

	virtual void UpdateCursorState()
	{
		// gViewPort->UpdateCursorState();
	}

	virtual int GetAckIconHeight()
	{
		return gHUD.m_iFontHeight * 3 + 6;
	}

	virtual bool CanShowSpeakerLabels()
	{
		return !gHUD.m_Scoreboard.m_bForceDraw && !gHUD.m_Scoreboard.m_bShowscoresHeld;
	}
};
static CCStrikeVoiceStatusHelper g_VoiceStatusHelper;

wrect_t nullrc = { 0, 0, 0, 0 };
float g_lastFOV = 0.0;
const char *sPlayerModelFiles[12] =
{
	"models/player.mdl",
	"models/player/leet/leet.mdl", // t
	"models/player/gign/gign.mdl", // ct
	"models/player/vip/vip.mdl", //ct
	"models/player/gsg9/gsg9.mdl", // ct
	"models/player/guerilla/guerilla.mdl", // t
	"models/player/arctic/arctic.mdl", // t
	"models/player/sas/sas.mdl", // ct
	"models/player/terror/terror.mdl", // t
	"models/player/urban/urban.mdl", // ct
	"models/player/spetsnaz/spetsnaz.mdl", // ct
	"models/player/militia/militia.mdl" // t
};

void __CmdFunc_InputCommandSpecial()
{
#ifdef _CS16CLIENT_ALLOW_SPECIAL_SCRIPTING
	gEngfuncs.pfnClientCmd("_special");
#endif
}

void __CmdFunc_GunSmoke()
{
	if( gHUD.cl_gunsmoke->value )
		gEngfuncs.Cvar_SetValue( "cl_gunsmoke", 0 );
	else
		gEngfuncs.Cvar_SetValue( "cl_gunsmoke", 1 );
}

/*
============
COM_FileBase
============
*/
// Extracts the base name of a file (no path, no extension, assumes '/' as path separator)
void COM_FileBase ( const char *in, char *out)
{
	int len, start, end;

	len = strlen( in );

	// scan backward for '.'
	end = len - 1;
	while ( end && in[end] != '.' && in[end] != '/' && in[end] != '\\' )
		end--;

	if ( in[end] != '.' )		// no '.', copy to end
		end = len-1;
	else
		end--;					// Found ',', copy to left of '.'


	// Scan backward for '/'
	start = len-1;
	while ( start >= 0 && in[start] != '/' && in[start] != '\\' )
		start--;

	if ( in[start] != '/' && in[start] != '\\' )
		start = 0;
	else
		start++;

	// Length of new sting
	len = end - start + 1;

	// Copy partial string
	strncpy( out, &in[start], len );
	// Terminate it
	out[len] = 0;
}

/*
=================
HUD_IsGame

=================
*/
int HUD_IsGame( const char *game )
{
	const char *gamedir;
	char gd[ 1024 ];

	gamedir = gEngfuncs.pfnGetGameDirectory();
	if ( gamedir && gamedir[0] )
	{
		COM_FileBase( gamedir, gd );
		if ( !stricmp( gd, game ) )
			return 1;
	}
	return 0;
}

#define XASH_GENERATE_BUILDNUM

#if defined(XASH_GENERATE_BUILDNUM)
static const char *date = __DATE__;
static const char *mon[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
static char mond[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
#endif

char *Q_buildnum( void )
{
// do not touch this! Only author of Xash3D can increase buildnumbers!
// Xash3D SDL: HAHAHA! I TOUCHED THIS!
	int m = 0, d = 0, y = 0;
	static int b = 0;
	static char buildnum[16];

	if( b != 0 )
		return buildnum;

	for( m = 0; m < 11; m++ )
	{
		if( !strncasecmp( &date[0], mon[m], 3 ))
			break;
		d += mond[m];
	}

	d += atoi( &date[4] ) - 1;
	y = atoi( &date[7] ) - 1900;
	b = d + (int)((y - 1) * 365.25f );

	if((( y % 4 ) == 0 ) && m > 1 )
	{
		b += 1;
	}
	//b -= 38752; // Feb 13 2007
	b -= 41940; // Oct 29 2015.
	// Happy birthday, cs16client! :)

	snprintf( buildnum, sizeof(buildnum), "%i", b );

	return buildnum;
}

int __MsgFunc_ADStop( const char *name, int size, void *buf ) { return 1; }
int __MsgFunc_ItemStatus( const char *name, int size, void *buf ) { return 1; }
// int __MsgFunc_ReqState( const char *name, int size, void *buf ) { return 1; }
int __MsgFunc_ForceCam( const char *name, int size, void *buf ) { return 1; }
int __MsgFunc_Spectator( const char *name, int size, void *buf ) { return 1; }

#ifdef __ANDROID__
bool evdev_open = false;
void __CmdFunc_MouseSucksOpen( void ) { evdev_open = true; }
void __CmdFunc_MouseSucksClose( void ) { evdev_open = false; }
#endif


// This is called every time the DLL is loaded
void CHud :: Init( void )
{
	SetGameType(); // call it first, so we will know gamedir at very early stage

	HOOK_COMMAND_FUNC( "special", __CmdFunc_InputCommandSpecial, );
	HOOK_COMMAND_FUNC( "gunsmoke", __CmdFunc_GunSmoke, );

#ifdef __ANDROID__
	HOOK_COMMAND_FUNC( "evdev_mouseopen", __CmdFunc_MouseSucksOpen );
	HOOK_COMMAND_FUNC( "evdev_mouseclose", __CmdFunc_MouseSucksClose );
#endif
	
	HOOK_MESSAGE( gHUD, Logo );
	HOOK_MESSAGE( gHUD, ResetHUD );
	HOOK_MESSAGE( gHUD, GameMode );
	HOOK_MESSAGE( gHUD, InitHUD );
	HOOK_MESSAGE( gHUD, ViewMode );
	HOOK_MESSAGE( gHUD, SetFOV );
	HOOK_MESSAGE( gHUD, Concuss );
	HOOK_MESSAGE( gHUD, ServerName );
	HOOK_MESSAGE( gHUD, ShadowIdx );

	gEngfuncs.pfnHookUserMsg( "ADStop", __MsgFunc_ADStop );
	gEngfuncs.pfnHookUserMsg( "ItemStatus", __MsgFunc_ItemStatus );
	// gEngfuncs.pfnHookUserMsg( "ReqState", __MsgFunc_ReqState );
	gEngfuncs.pfnHookUserMsg( "ForceCam", __MsgFunc_ForceCam );
	gEngfuncs.pfnHookUserMsg( "Spectator", __MsgFunc_Spectator );

	HOOK_MESSAGE( gHUD, Fog );


	CVAR_CREATE( "_vgui_menus", "1", FCVAR_ARCHIVE | FCVAR_USERINFO );
	CVAR_CREATE( "_cl_autowepswitch", "1", FCVAR_ARCHIVE | FCVAR_USERINFO );
	CVAR_CREATE( "_ah", "0", FCVAR_ARCHIVE | FCVAR_USERINFO );

	// TODO remove hack later
	CVAR_CREATE( "numericalmenu", "1", FCVAR_ARCHIVE );
	CVAR_CREATE( "numericalmenu_clientonly", "1", FCVAR_ARCHIVE );
	CVAR_CREATE( "checkscoreboard", "1", FCVAR_ARCHIVE );
	cscl_currentmap = CVAR_CREATE( "cscl_currentmap", "", 0 );
	cscl_mapprefix = CVAR_CREATE( "cscl_mapprefix", "", 0 );
	cscl_currentmoney = CVAR_CREATE( "cscl_currentmoney", "0", 0 );
	CVAR_CREATE( "teammenu_showscores", "0", FCVAR_ARCHIVE );
	CVAR_CREATE( "menu_bg_fill", "0", FCVAR_ARCHIVE );
	CVAR_CREATE( "buymenu_stayon", "0", FCVAR_ARCHIVE );

	hud_textmode = CVAR_CREATE( "hud_textmode", "0", FCVAR_ARCHIVE );
	hud_colored  = CVAR_CREATE( "hud_colored", "0", FCVAR_ARCHIVE );
	cl_righthand = CVAR_CREATE( "cl_righthand", "1", FCVAR_ARCHIVE );
	cl_weather   = CVAR_CREATE( "cl_weather", "1", FCVAR_ARCHIVE );
	cl_minmodels = CVAR_CREATE( "cl_minmodels", "0", FCVAR_ARCHIVE );
	cl_min_t     = CVAR_CREATE( "cl_min_t", "1", FCVAR_ARCHIVE );
	cl_min_ct    = CVAR_CREATE( "cl_min_ct", "2", FCVAR_ARCHIVE );
	default_fov  = CVAR_CREATE( "default_fov", "90", 0 );
	m_pCvarDraw  = CVAR_CREATE( "hud_draw", "1", FCVAR_ARCHIVE );
	fastsprites  = CVAR_CREATE( "fastsprites", "0", FCVAR_ARCHIVE );
	cl_gunsmoke  = CVAR_CREATE( "cl_gunsmoke", "0", FCVAR_ARCHIVE );
	cl_weapon_sparks = CVAR_CREATE( "cl_weapon_sparks", "1", FCVAR_ARCHIVE );
	cl_weapon_wallpuff = CVAR_CREATE( "cl_weapon_wallpuff", "1", FCVAR_ARCHIVE );
	zoom_sens_ratio = CVAR_CREATE( "zoom_sensitivity_ratio", "1.2", 0 );

	cl_charset = gEngfuncs.pfnGetCvarPointer( "cl_charset" );
	con_charset = gEngfuncs.pfnGetCvarPointer( "con_charset" );

	cl_viewbob = CVAR_CREATE( "cl_viewbob", "1", FCVAR_ARCHIVE );

	m_pShowHealth = CVAR_CREATE( "scoreboard_showhealth", "1", FCVAR_ARCHIVE );
	m_pShowMoney = CVAR_CREATE( "scoreboard_showmoney", "1", FCVAR_ARCHIVE );

	// The cvar was taken from the OpenAG client
	m_pCvarColor = CVAR_CREATE( "hud_color", "255 160 0", FCVAR_ARCHIVE );

	if ( gEngfuncs.pfnGetCvarFloat( "developer" ) > 0.0f )
	{
		cl_fog_density = CVAR_CREATE( "cl_fog_density", "0", 0 );
		cl_fog_r = CVAR_CREATE( "cl_fog_r", "0", 0 );
		cl_fog_g = CVAR_CREATE( "cl_fog_g", "0", 0 );
		cl_fog_b = CVAR_CREATE( "cl_fog_b", "0", 0 );
	}

	CVAR_CREATE( "cscl_ver", Q_buildnum(), 1<<14 | FCVAR_USERINFO ); // init and userinfo

	m_iLogo = 0;
	m_iFOV = 0;

	m_pSpriteList = NULL;

	// Clear any old HUD list
	for( HUDLIST *pList = m_pHudList; pList; pList = m_pHudList )
	{
		m_pHudList = m_pHudList->pNext;
		delete pList;
	}
	m_pHudList = NULL;

	// In case we get messages before the first update -- time will be valid
	m_flTime = 1.0;
	m_iNoConsolePrint = 0;
	m_szServerName[0] = 0;



	Localize_Init();

	// fullscreen overlays
	m_SniperScope.Init();
	m_NVG.Init();

	// Spectator GUI is not need in singleplayer czeror
	if( GetGameType() != GAME_CZERODS )
		m_SpectatorGui.Init();

	// Game HUD things
	m_Ammo.Init();
	m_Health.Init();
	m_Radio.Init();
	m_Timer.Init();
	m_Money.Init();
	m_AmmoSecondary.Init();
	m_Train.Init();
	m_Battery.Init();
	m_StatusIcons.Init();
	m_Radar.Init();
	m_Scenario.Init();

	// chat, death notice, status bars and other
	m_SayText.Init();
	m_Spectator.Init();
	m_Geiger.Init();
	m_Flash.Init();
	m_Message.Init();
	m_StatusBar.Init();
	m_DeathNotice.Init();
	m_TextMessage.Init();
	m_MOTD.Init();

	// all things that have own background and must be drawn last
	m_ProgressBar.Init();
	m_Menu.Init();
	m_Scoreboard.Init();

	GetClientVoice()->Init( &g_VoiceStatusHelper );

	InitRain();

	//ServersInit();

	gEngfuncs.Con_Printf( "%s: ^2CS16Client^7 ver. %s initialized.\n", __FUNCTION__, CVAR_GET_STRING( "cscl_ver" ) );

	MsgFunc_ResetHUD(0, 0, NULL );
}

// CHud destructor
// cleans up memory allocated for m_rg* arrays
CHud :: ~CHud()
{
	delete [] m_rghSprites;
	delete [] m_rgrcRects;
	delete [] m_rgszSpriteNames;

	// Clear any old HUD list
	for( HUDLIST *pList = m_pHudList; pList; pList = m_pHudList )
	{
		m_pHudList = m_pHudList->pNext;
		delete pList;
	}
	m_pHudList = NULL;
}

void CHud :: VidInit( void )
{
	static bool firstinit = true;
	m_scrinfo.iSize = sizeof( m_scrinfo );
	GetScreenInfo( &m_scrinfo );

	m_truescrinfo.iWidth = CVAR_GET_FLOAT("width");
	m_truescrinfo.iHeight = CVAR_GET_FLOAT("height");

	// ----------
	// Load Sprites
	// ---------
	//	m_hsprFont = LoadSprite("sprites/%d_font.spr");
	
	m_hsprLogo = 0;

	m_flScale = (float)TrueWidth / (float)ScreenWidth;

	m_iRes = 640;

	// Only load this once
	if( !m_pSpriteList )
	{
		// we need to load the hud.txt, and all sprites within
		m_pSpriteList = SPR_GetList("sprites/hud.txt", &m_iSpriteCountAllRes);

		if( m_pSpriteList )
		{
			// count the number of sprites of the appropriate res
			m_iSpriteCount = 0;
			client_sprite_t *p = m_pSpriteList;
			for ( int j = 0; j < m_iSpriteCountAllRes; j++ )
			{
				if ( p->iRes == m_iRes )
					m_iSpriteCount++;
				p++;
			}

			// allocated memory for sprite handle arrays
			m_rghSprites      = new(std::nothrow) HSPRITE[m_iSpriteCount];
			m_rgrcRects       = new(std::nothrow) wrect_t[m_iSpriteCount];
			m_rgszSpriteNames = new(std::nothrow) char[m_iSpriteCount * MAX_SPRITE_NAME_LENGTH];;

			if( !m_rghSprites || !m_rgrcRects || !m_rgszSpriteNames )
			{
				gEngfuncs.pfnConsolePrint("CHud::VidInit(): Cannot allocate memory");
				if( g_iXash )
					gRenderAPI.Host_Error("CHud::VidInit(): Cannot allocate memory");
			}

			p = m_pSpriteList;
			for ( int index = 0, j = 0; j < m_iSpriteCountAllRes; j++ )
			{
				if ( p->iRes == m_iRes )
				{
					char sz[256];
					sprintf(sz, "sprites/%s.spr", p->szSprite);
					m_rghSprites[index] = SPR_Load(sz);
					m_rgrcRects[index] = p->rc;
					strncpy( &m_rgszSpriteNames[index * MAX_SPRITE_NAME_LENGTH], p->szName, MAX_SPRITE_NAME_LENGTH );

					index++;
				}

				p++;
			}
		}
	}
	else
	{
		// we have already have loaded the sprite reference from hud.txt, but
		// we need to make sure all the sprites have been loaded (we've gone through a transition, or loaded a save game)
		client_sprite_t *p = m_pSpriteList;
		int index = 0;
		for ( int j = 0; j < m_iSpriteCountAllRes; j++ )
		{
			if ( p->iRes == m_iRes )
			{
				char sz[256];
				sprintf( sz, "sprites/%s.spr", p->szSprite );
				m_rghSprites[index] = SPR_Load(sz);
				index++;
			}

			p++;
		}
	}

	// assumption: number_1, number_2, etc, are all listed and loaded sequentially
	m_HUD_number_0 = GetSpriteIndex( "number_0" );

	if( m_HUD_number_0 == -1 && g_iXash )
	{
		gRenderAPI.Host_Error( "Failed to get number_0 sprite index. Check your game data!" );
		return;
	}

	if( g_iXash )
	{
		// get internal texture
		m_WhiteTex = gRenderAPI.GL_LoadTexture( "*white", NULL, 0, 0 );
	}

	m_iFontWidth  = GetSpriteRect(m_HUD_number_0).Width();
	m_iFontHeight = GetSpriteRect(m_HUD_number_0).Height();

	m_hGasPuff = SPR_Load("sprites/gas_puff_01.spr");

	for( HUDLIST *pList = m_pHudList; pList; pList = pList->pNext )
		pList->p->VidInit();

#if 0
	if( firstinit && gEngfuncs.CheckParm( "-firsttime", NULL ) )
	{
		ConsolePrint( "firstrun\n" );

		ClientCmd( "exec touch_presets/phone_ahsim" );
		gEngfuncs.Cvar_Set( "touch_config_file", "touch_presets/phone_ahsim.cfg" );
	}
#endif

	firstinit = false;
}

void CHud::Shutdown( void )
{
	for( HUDLIST *pList = m_pHudList; pList; pList = pList->pNext )
	{
		pList->p->Shutdown();
	}
}

int CHud::MsgFunc_Logo(const char *pszName,  int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	// update Train data
	m_iLogo = reader.ReadByte();

	return 1;
}

void CHud::SetGameType()
{
	if( HUD_IsGame( "czeror" ) )
		m_iGameType = GAME_CZERODS;
	else if( HUD_IsGame( "czero" ))
		m_iGameType = GAME_CZERO;
	else m_iGameType = GAME_CSTRIKE;
}

/*
=====================
HUD_GetFOV

Returns last FOV
=====================
*/
float HUD_GetFOV( void )
{
	if ( gEngfuncs.pDemoAPI->IsRecording() )
	{
		// Write it
		unsigned char buf[ sizeof(float) ];

		// Active
		*( float * )&buf = g_lastFOV;

		Demo_WriteBuffer( TYPE_ZOOM, sizeof(float), buf );
	}

	if ( gEngfuncs.pDemoAPI->IsPlayingback() )
	{
		g_lastFOV = g_demozoom;
	}
	return g_lastFOV;
}

int CHud::MsgFunc_SetFOV(const char *pszName,  int iSize, void *pbuf)
{
	//Weapon prediction already takes care of changing the fog. ( g_lastFOV ).
#if 0 // VALVEWHY: original client checks for "tfc" here.
	if ( cl_lw && cl_lw->value )
		return 1;
#endif

	BufferReader reader( pszName, pbuf, iSize );

	int newfov = reader.ReadByte();
	int def_fov = default_fov->value;

	g_lastFOV = newfov;
	m_iFOV = newfov ? newfov : def_fov;

	// the clients fov is actually set in the client data update section of the hud

	if ( m_iFOV == def_fov ) // reset to saved sensitivity
		m_flMouseSensitivity = 0;
	else // set a new sensitivity that is proportional to the change from the FOV default
		m_flMouseSensitivity = sensitivity->value * ((float)newfov / (float)def_fov) * zoom_sens_ratio->value;

	return 1;
}

void CHud::AddHudElem(CHudBase *phudelem)
{
	assert( phudelem );

	HUDLIST *pdl, *ptemp;

	pdl = new(std::nothrow) HUDLIST;
	if( !pdl )
	{
		ConsolePrint( "Cannot allocate memory!\n" );
		return;
	}

	pdl->p = phudelem;
	pdl->pNext = NULL;

	if (!m_pHudList)
	{
		m_pHudList = pdl;
		return;
	}

	// find last
	for( ptemp = m_pHudList; ptemp->pNext; ptemp = ptemp->pNext );

	ptemp->pNext = pdl;
}

```

`cl_dll/hud.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//			
//  hud.h
//
// class CHud declaration
//
// CHud handles the message, calculation, and drawing the HUD
//
#pragma once

#define RGB_YELLOWISH 0x00FFA000 //255,160,0
#define RGB_REDISH 0x00FF1010 //255,16,16
#define RGB_GREENISH 0x0000A000 //0,160,0
#define RGB_WHITE 0x00FFFFFF
#define RGB_GRAY 0x00808080

#include <assert.h>
#include <string.h>

#include "wrect.h"
#include "cl_dll.h"
#include "ammo.h"

#include "csprite.h"
#include "cvardef.h"

#define MIN_ALPHA	 100	
#define	HUDELEM_ACTIVE	1
#define CHudMsgFunc(x) int MsgFunc_##x(const char *pszName, int iSize, void *buf)
#define CHudUserCmd(x) void UserCmd_##x()

class RGBA
{
public:
	unsigned char r, g, b, a;
};

enum 
{ 
	MAX_PLAYERS = 64,
	MAX_TEAMS = 64,
	MAX_TEAM_NAME = 16,
	MAX_LOCATION_NAME = 32
};

#define MAX_HOSTAGES 24

#define PLAYERMODEL_PLAYER	0
#define PLAYERMODEL_LEET	1
#define PLAYERMODEL_GIGN	2
#define PLAYERMODEL_VIP		3
extern const char *sPlayerModelFiles[];
extern wrect_t nullrc;

class CClientSprite;

inline bool BIsValidTModelIndex( int i )
{
	if ( i == 1 || i == 5 || i == 6 || i == 8 || i == 11 )
		return true;
	else
		return false;
}

inline bool BIsValidCTModelIndex( int i )
{
	if ( i == 7 || i == 2 || i == 10 || i == 4 || i == 9)
		return true;
	else
		return false;
}

#define HUD_DRAW         (1 << 0)
#define HUD_THINK        (1 << 1)
#define HUD_ACTIVE       (HUD_DRAW | HUD_THINK)
#define HUD_INTERMISSION (1 << 2)

#define MAX_PLAYER_NAME_LENGTH		32

#define	MAX_MOTD_LENGTH				1536

extern cvar_t *cl_fog_r;
extern cvar_t *cl_fog_g;
extern cvar_t *cl_fog_b;
extern cvar_t *cl_fog_density;

struct FogParameters {
	float color[3];
	float density;
	bool affectsSkyBox;
};

extern FogParameters g_FogParameters;

//
//-----------------------------------------------------
//
class CHudBase
{
public:
	int	  m_iFlags; // active, moving,
	virtual		~CHudBase() {}
	virtual int Init( void ) {return 0;}
	virtual int VidInit( void ) {return 0;}
	virtual int Draw(float flTime) {return 0;}
	virtual void Think(void) {return;}
	virtual void Reset(void) {return;}
	virtual void InitHUDData( void ) {}		// called every time a server is connected to
	virtual void Shutdown( void ) {}

};

struct HUDLIST {
	CHudBase	*p;
	HUDLIST		*pNext;
};



//
//-----------------------------------------------------
//
#include "voice_status.h"
#include "hud_spectator.h"


//
//-----------------------------------------------------
//
class CHudAmmo: public CHudBase
{
	friend class WeaponsResource;
	friend class HistoryResource;

public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	void Think(void);
	void Reset(void);
	void SetCrosshair( HSPRITE hSpr, wrect_t rect, int r, int g, int b );
	void HideCrosshair();

	// replace engine's buggy crosshair
	void DrawSpriteCrosshair();

	// dynamic crosshair
	void DrawCrosshair();
	void CalculateCrosshairSize();
	void CalcCrosshairDrawMode();
	void CalcCrosshairColor();

	static int ScaleForRes( float value, int height );
	float GetCrosshairGap( int weaponId );
	void DrawCrosshair( int weaponId );
	static int GetWeaponAccuracyFlags( int weaponId );
	void DrawCrosshairSection( int _x0, int _y0, int _x1, int _y1 );
	void DrawCrosshairPadding( int _pad, int _x0, int _y0, int _x1, int _y1 );

	int DrawWList(float flTime);
	CHudMsgFunc(CurWeapon);
	CHudMsgFunc(WeaponList);
	CHudMsgFunc(AmmoX);
	CHudMsgFunc(AmmoPickup);
	CHudMsgFunc(WeapPickup);
	CHudMsgFunc(ItemPickup);
	CHudMsgFunc(HideWeapon);
	CHudMsgFunc(Crosshair);
	CHudMsgFunc(Brass);


	void SlotInput( int iSlot );
	CHudUserCmd(Slot1);
	CHudUserCmd(Slot2);
	CHudUserCmd(Slot3);
	CHudUserCmd(Slot4);
	CHudUserCmd(Slot5);
	CHudUserCmd(Slot6);
	CHudUserCmd(Slot7);
	CHudUserCmd(Slot8);
	CHudUserCmd(Slot9);
	CHudUserCmd(Slot10);
	CHudUserCmd(Close);
	CHudUserCmd(NextWeapon);
	CHudUserCmd(PrevWeapon);
	CHudUserCmd(Adjust_Crosshair);
	CHudUserCmd(Rebuy);
	CHudUserCmd(Autobuy);

private:
	float m_fFade;
	RGBA  m_rgba;
	WEAPON *m_pWeapon;
	int	m_HUD_bucket0;
	int m_HUD_selection;

	int m_iAlpha;
	int m_R, m_G, m_B;
	int m_cvarR, m_cvarG, m_cvarB;
	int m_iCurrentCrosshair;
	int m_iCrosshairScaleBase;
	float m_flCrosshairDistance;
	bool m_bAdditive;
	bool m_bObserverCrosshair ;
	bool m_bDrawCrosshair;
	int m_iAmmoLastCheck;

	convar_t *m_pClCrosshairColor;
	convar_t *m_pClCrosshairTranslucent;
	convar_t *m_pClCrosshairSize;
	cvar_t *m_pClDynamicCrosshair;
	cvar_t *m_pHud_FastSwitch;
	cvar_t *m_pHud_DrawHistory_Time;

	// replace buggy engine's crosshair
	HSPRITE m_hStaticSpr;
	wrect_t m_rcStaticRc;
	RGBA m_staticRgba;

	cvar_t *xhair_enable;

	cvar_t *xhair_gap;
	cvar_t *xhair_size;
	cvar_t *xhair_thick;
	cvar_t *xhair_pad;
	cvar_t *xhair_dot;
	cvar_t *xhair_t;
	cvar_t *xhair_dynamic_scale;
	cvar_t *xhair_gap_useweaponvalue;
	cvar_t *xhair_dynamic_move;

	cvar_t *xhair_color;
	cvar_t *xhair_additive;

	cvar_t *cl_crosshair_color;
	cvar_t *cl_crosshair_translucent;
	cvar_t *hud_draw;
};

//
//-----------------------------------------------------
//

class CHudAmmoSecondary: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	void Reset( void );
	int Draw(float flTime);

	CHudMsgFunc(SecAmmoVal);
	CHudMsgFunc(SecAmmoIcon);

private:
	enum {
		MAX_SEC_AMMO_VALUES = 4
	};

	int m_HUD_ammoicon; // sprite indices
	int m_iAmmoAmounts[MAX_SEC_AMMO_VALUES];
	float m_fFade;
};


#include "health.h"
#include "radar.h"

#define FADE_TIME 100


//
//-----------------------------------------------------
//
class CHudGeiger: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	CHudMsgFunc(Geiger);
	
private:
	int m_iGeigerRange;

};

//
//-----------------------------------------------------
//
class CHudTrain: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	CHudMsgFunc(Train);

private:
	HSPRITE m_hSprite;
	int m_iPos;

};

//
//-----------------------------------------------------
//
//  MOTD in cs16 must render HTML, so it disabled
//

class CHudMOTD : public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Reset( void );

	CHudMsgFunc(MOTD);
	void Scroll( int dir );
	void Scroll( float amount );
	float scroll;
	bool m_bShow;
	cvar_t *cl_hide_motd;

protected:
	static int MOTD_DISPLAY_TIME;
	char m_szMOTD[ MAX_MOTD_LENGTH ];
	
	int m_iLines;
	int m_iMaxLength;
	bool ignoreThisMotd;
};


class CHudScoreboard: public CHudBase
{
	friend class CHudSpectatorGui;
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );

	int DrawScoreboard( float flTime );
	int DrawTeams( float listslot );
	int DrawPlayers( float listslot, int nameoffset = 0, const char *team = NULL ); // returns the ypos where it finishes drawing

	void DeathMsg( int killer, int victim );
	void SetScoreboardDefaults( void );
	void GetAllPlayersInfo( void );

	bool ShouldDrawScoreboard() const;

	CHudUserCmd(ShowScores);
	CHudUserCmd(HideScores);
	CHudUserCmd(ShowScoreboard2);
	CHudUserCmd(HideScoreboard2);

	CHudMsgFunc(ScoreInfo);
	CHudMsgFunc(TeamInfo);
	CHudMsgFunc(TeamScore);
	CHudMsgFunc(TeamNames);

	int m_iPlayerNum;
	int m_iNumTeams;

	bool m_bForceDraw; // if called by showscoreboard2
	bool m_bShowscoresHeld;

private:
	int m_iLastKilledBy;
	int m_fLastKillTime;
	RGBA m_colors;
	bool m_bDrawStroke;
	cvar_t *cl_showpacketloss;
	cvar_t *cl_showplayerversion;
};

//
//-----------------------------------------------------
//
class CHudStatusBar : public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Reset( void );
	void ParseStatusString( int line_num );

	CHudMsgFunc(StatusText);
	CHudMsgFunc(StatusValue);

protected:
	enum {
		MAX_STATUSTEXT_LENGTH = 128,
		MAX_STATUSBAR_VALUES = 8,
		MAX_STATUSBAR_LINES = 1
	};

	char m_szStatusText[MAX_STATUSBAR_LINES][MAX_STATUSTEXT_LENGTH];  // a text string describing how the status bar is to be drawn
	char m_szStatusBar[MAX_STATUSBAR_LINES][MAX_STATUSTEXT_LENGTH];	// the constructed bar that is drawn
	int m_iStatusValues[MAX_STATUSBAR_VALUES];  // an array of values for use in the status bar

	int m_bReparseString; // set to TRUE whenever the m_szStatusBar needs to be recalculated

	// an array of colors...one color for each line
	float *m_pflNameColors[MAX_STATUSBAR_LINES];

	cvar_t *hud_centerid;
};

struct extra_player_info_t 
{
	short frags;
	short deaths;
	short team_id;
	qboolean has_c4;
	qboolean vip;
	Vector origin;

	// radar stuff...
	// float radarflash;
	// qboolean radarflashon;
	// int radarflashes;
	int radarflashes;
	float radarflashtime;
	float radarflashtimedelta;
	bool nextflash;

	short playerclass;
	short teamnumber;
	char teamname[MAX_TEAM_NAME];
	bool dead;
	float showhealth;
	int health;
	bool talking;
	char location[MAX_LOCATION_NAME];
	int sb_health;
	int sb_account;
	qboolean has_defuse_kit;
};

struct team_info_t 
{
	char name[MAX_TEAM_NAME];
	short frags;
	short deaths;
	short ownteam;
	short players;
	int already_drawn;
	int scores_overriden;
	int sumping;
	int teamnumber;
};

struct hostage_info_t
{
	vec3_t origin;
	float radarflashtimedelta;
	float radarflashtime;
	bool dead;
	bool nextflash;
	int radarflashes;
};

extern hud_player_info_t	g_PlayerInfoList[MAX_PLAYERS+1];	   // player info from the engine
extern extra_player_info_t  g_PlayerExtraInfo[MAX_PLAYERS+1];   // additional player info sent directly to the client dll
extern team_info_t			g_TeamInfo[MAX_TEAMS+1];
extern hostage_info_t		g_HostageInfo[MAX_HOSTAGES+1];
extern int					g_IsSpectator[MAX_PLAYERS+1];


//
//-----------------------------------------------------
//
class CHudDeathNotice : public CHudBase
{
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );
	CHudMsgFunc(DeathMsg);

private:
	int m_HUD_d_skull;  // sprite index of skull icon
	int m_HUD_d_headshot;
	cvar_t *hud_deathnotice_time;
};

//
//-----------------------------------------------------
//
class CHudMenu : public CHudBase
{
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	void Reset( void );
	int Draw( float flTime );

	CHudMsgFunc(ShowMenu);
	CHudMsgFunc(BuyClose);
	CHudMsgFunc(VGUIMenu);
	// server sends false when spectating is not allowed, and true when allowed
	CHudMsgFunc(AllowSpec);

	CHudUserCmd(OldStyleMenuClose);
	CHudUserCmd(OldStyleMenuOpen);
	CHudUserCmd(ShowVGUIMenu);

	void ShowVGUIMenu( int menuType ); // cs16client extension

	void SelectMenuItem( int menu_item );

	int m_fMenuDisplayed;
	bool m_bAllowSpec;
	cvar_t *_extended_menus;
	int m_bitsValidSlots;
	float m_flShutoffTime;
	int m_fWaitingForMore;

};

//
//-----------------------------------------------------
//
class CHudSayText : public CHudBase
{
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );
	CHudMsgFunc(SayText);
	void SayTextPrint( const char *pszBuf, int iBufSize, int clientIndex = -1 );
	void SayTextPrint( char szBuf[3][256] );
	void EnsureTextFitsInOneLineAndWrapIfHaveTo( int line );
	friend class CHudSpectator;

private:

	struct cvar_s *	m_HUD_saytext;
	struct cvar_s *	m_HUD_saytext_time;
};

//
//-----------------------------------------------------
//
class CHudBattery: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	CHudMsgFunc(Battery);
	CHudMsgFunc(ArmorType);
	
private:
	enum armortype_t {
		Vest = 0,
		VestHelm
	} m_enArmorType;

	CClientSprite m_hEmpty[VestHelm + 1];
	CClientSprite m_hFull[VestHelm + 1];
	int	  m_iBat;
	float m_fFade;
	int	  m_iHeight;		// width of the battery innards
};


//
//-----------------------------------------------------
//
class CHudFlashlight: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	void Reset( void );
	CHudMsgFunc(Flashlight);
	CHudMsgFunc(FlashBat);
	
private:
	CClientSprite m_hSprite1;
	CClientSprite m_hSprite2;
	CClientSprite m_hBeam;
	float m_flBat;
	int	  m_iBat;
	int	  m_fOn;
	float m_fFade;
	int	  m_iWidth;		// width of the battery innards
};

//
//-----------------------------------------------------
//
const int maxHUDMessages = 16;
struct message_parms_t
{
	client_textmessage_t	*pMessage;
	float	time;
	int x, y;
	int	totalWidth, totalHeight;
	int width;
	int lines;
	int lineLength;
	int length;
	int r, g, b;
	int text;
	int fadeBlend;
	float charTime;
	float fadeTime;
};

//
//-----------------------------------------------------
//

class CHudTextMessage: public CHudBase
{
public:
	int Init( void );
	static char *LocaliseTextString( const char *msg, char *dst_buffer, int buffer_size );
	static char *BufferedLocaliseTextString( const char *msg );
	static char *LookupString( char *msg_name, int *msg_dest = NULL );
	CHudMsgFunc(TextMsg);
};

//
//-----------------------------------------------------
//

class CHudMessage: public CHudBase
{
public:
	friend class CHudTextMessage;
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	CHudMsgFunc(HudText);
	CHudMsgFunc(GameTitle);
	CHudMsgFunc(HudTextArgs);
	CHudMsgFunc(HudTextPro);

	float FadeBlend( float fadein, float fadeout, float hold, float localTime );
	int	XPosition( float x, int width, int lineWidth );
	int YPosition( float y, int height );

	void MessageAdd( const char *pName, float time );
	void MessageAdd(client_textmessage_t * newMessage );
	void MessageDrawScan( client_textmessage_t *pMessage, float time );
	void MessageScanStart( void );
	void MessageScanNextChar( void );
	void Reset( void );

	client_textmessage_t *AllocMessage( const char *text = NULL, client_textmessage_t *copyFrom = NULL );

private:
	client_textmessage_t		*m_pMessages[maxHUDMessages];
	float						m_startTime[maxHUDMessages];
	message_parms_t				m_parms;
	float						m_gameTitleTime;
	client_textmessage_t		*m_pGameTitle;

	int m_HUD_title_life;
	int m_HUD_title_half;
};

//
//-----------------------------------------------------
//
#define MAX_SPRITE_NAME_LENGTH	24

class CHudStatusIcons: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	void Reset( void );
	int Draw(float flTime);
	CHudMsgFunc(StatusIcon);

	enum {
		MAX_ICONSPRITENAME_LENGTH = MAX_SPRITE_NAME_LENGTH,
		MAX_ICONSPRITES = 4,
	};

	
	//had to make these public so CHud could access them (to enable concussion icon)
	//could use a friend declaration instead...
	void EnableIcon( const char *pszIconName, unsigned char red, unsigned char green, unsigned char blue );
	void DisableIcon( const char *pszIconName );

	friend class CHudScoreboard;

private:

	typedef struct
	{
		char szSpriteName[MAX_ICONSPRITENAME_LENGTH];
		HSPRITE spr;
		wrect_t rc;
		unsigned char r, g, b;
		unsigned char secR, secG, secB;
		float flTimeToChange;
	} icon_sprite_t;

	icon_sprite_t m_IconList[MAX_ICONSPRITES];
};


//
//-----------------------------------------------------
//
#define MONEY_YPOS ScreenHeight - 3 * gHUD.m_iFontHeight

class CHudMoney : public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	CHudMsgFunc(Money);
	CHudMsgFunc(BlinkAcct);

private:
	int m_iMoneyCount;
	int m_iDelta;
	int m_iBlinkAmt;
	float m_fBlinkTime;
	float m_fFade;
	CClientSprite m_hDollar;
	CClientSprite m_hPlus;
	CClientSprite m_hMinus;
};
//
//-----------------------------------------------------
//
class CHudRadio: public CHudBase
{
public:
	int Init( void );
	void Voice(int entindex, bool bTalking );
	// play a sentence from a radio
	// [byte] unknown (always 1)
	// [string] sentence name
	// [short] unknown. (always 100, it's a volume?)
	CHudMsgFunc(SendAudio);
	CHudMsgFunc(ReloadSound);
	CHudMsgFunc(BotVoice);
};

//
//-----------------------------------------------------
//
class CHudTimer: public CHudBase
{
	friend class CHudSpectatorGui;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float fTime);
	// set up the timer.
	// [short]
	CHudMsgFunc(RoundTime);
	// show the timer
	// [empty]
	CHudMsgFunc(ShowTimer);

	int m_right;
private:
	int m_HUD_timer;
	int m_iTime;
	float m_fStartTime;
	bool m_bPanicColorChange;
	float m_flPanicTime;
};
//
//-----------------------------------------------------
//
class CHudProgressBar: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Reset( void );

	// start progress bar
	// [short] Duration
	CHudMsgFunc(BarTime);

	// [short] Duration
	// [short] percent
	CHudMsgFunc(BarTime2);
	CHudMsgFunc(BotProgress);

private:
	int m_iDuration;
	float m_fPercent;
	float m_fStartTime;
	char m_szHeader[256];
	const char *m_szLocalizedHeader;
};

//
//-----------------------------------------------------
//
// class for drawing sniper scope
class CHudSniperScope: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Shutdown( void );

private:
	float left, right, centerx, centery;
	int m_iScopeArc[4];
};

//
//-----------------------------------------------------
//

class CHudNVG: public CHudBase
{
public:
	int Init( void );
	int Draw( float flTime );
	void Reset( void );
	CHudMsgFunc(NVGToggle);

	CHudUserCmd(NVGAdjustUp);
	CHudUserCmd(NVGAdjustDown);
private:
	int m_iAlpha;
	cvar_t *cl_fancy_nvg;
	dlight_t *m_pLight;
};

//
//-----------------------------------------------------
//

class CHudScenario : public CHudBase
{
public:
	int Init();
	int VidInit();
	int Draw(float flTime);
	void Reset();

	CHudMsgFunc(Scenario);
private:
	CClientSprite m_sprite;
	int m_iAlpha;
	int m_iFlashAlpha;
	float m_fFlashRate;
	float m_fNextFlash;
};

//
//-----------------------------------------------------
//

class CHudSpectatorGui: public CHudBase
{
public:
	int Init();
	int VidInit();
	int Draw( float flTime );
	void InitHUDData();
	void Reset();
	void Shutdown();

	CHudMsgFunc( SpecHealth );
	CHudMsgFunc( SpecHealth2 );

	CHudUserCmd( ToggleSpectatorMenu );
	CHudUserCmd( ToggleSpectatorMenuOptions );
	CHudUserCmd( ToggleSpectatorMenuOptionsSettings );
	CHudUserCmd( ToggleSpectatorMenuSpectateOptions );

	void CalcAllNeededData( );

	bool m_bBombPlanted;

private:	
	// szMapName is 64 bytes only. Removing "maps/" and ".bsp" gived me this result
	class Labels
	{
	public:
		short m_iTerrorists;
		short m_iCounterTerrorists;
		char m_szTimer[64];
		char m_szMap[64];
		char m_szNameAndHealth[80];
	} label;
	int m_hTimerTexture;
	int m_hChecked;
	int m_hArrowDown;
	int m_hArrowUp;
	int m_hArrowLeft;
	int m_hArrowRight;

	enum {
		ROOT_MENU = (1<<0),
		MENU_OPTIONS = (1<<1),
		MENU_OPTIONS_SETTINGS = (1<<2),
		MENU_SPEC_OPTIONS = (1<<3)
	};
	byte m_menuFlags;
};

//
//-----------------------------------------------------
//

class CHud
{
public:
	CHud() : m_pHudList(NULL), m_iSpriteCount(0), m_iRes(640)  {}
	~CHud();			// destructor, frees allocated memory // thanks, Captain Obvious

	void Init( void );
	void VidInit( void );
	void Think( void );
	void Shutdown( void );
	int Redraw( float flTime, int intermission );
	int UpdateClientData( client_data_t *cdata, float time );
	void AddHudElem(CHudBase *p);

	inline float GetSensitivity() { return m_flMouseSensitivity; }
	inline HSPRITE GetSprite( int index )
	{
		assert( index >= -1 && index <= m_iSpriteCount );

		return (index >= 0) ? m_rghSprites[index] : 0;
	}

	inline wrect_t& GetSpriteRect( int index )
	{
		assert( index >= -1 && index <= m_iSpriteCount );

		return (index >= 0) ? m_rgrcRects[index]: nullrc;
	}

	// GetSpriteIndex()
	// searches through the sprite list loaded from hud.txt for a name matching SpriteName
	// returns an index into the gHUD.m_rghSprites[] array
	// returns -1 if sprite not found
	inline int GetSpriteIndex( const char *SpriteName )
	{
		// look through the loaded sprite name list for SpriteName
		for ( int i = 0; i < m_iSpriteCount; i++ )
		{
			if ( strncmp( SpriteName, m_rgszSpriteNames + (i * MAX_SPRITE_NAME_LENGTH), MAX_SPRITE_NAME_LENGTH ) == 0 )
				return i;
		}

		gEngfuncs.Con_Printf( "GetSpriteIndex: %s sprite not found\n", SpriteName );
		return -1; // invalid sprite
	}

	inline short GetCharWidth ( unsigned char ch )
	{
		return m_scrinfo.charWidths[ ch ];
	}

	inline int GetCharHeight( )
	{
		return m_scrinfo.iCharHeight;
	}

	inline int GetGameType( )
	{
		return m_iGameType;
	}

	inline int GetSpriteRes()
	{
		return m_iRes;
	}


	float   m_flTime;      // the current client time
	float   m_fOldTime;    // the time at which the HUD was last redrawn
	double  m_flTimeDelta; // the difference between flTime and fOldTime
	float   m_flScale;     // hud_scale->value
	Vector	m_vecOrigin;
	Vector	m_vecAngles;
	int		m_iKeyBits;
	int		m_iHideHUDDisplay;
	int		m_iFOV;
	int		m_Teamplay;
	cvar_t *m_pCvarDraw;
	cvar_t *fastsprites;
	cvar_t *cl_nopred;
	cvar_t *cl_weapon_wallpuff;
	cvar_t *cl_weapon_sparks;
	cvar_t *cl_lw;
	cvar_t *cl_righthand;
	cvar_t *cl_weather;
	cvar_t *cl_minmodels;
	cvar_t *cl_min_t;
	cvar_t *cl_min_ct;
	cvar_t *cl_gunsmoke;
	cvar_t *hud_textmode;
	cvar_t *hud_colored;
	cvar_t *cscl_currentmoney;
	cvar_t *cscl_currentmap;
	cvar_t *cscl_mapprefix;
	cvar_t *cl_viewbob;

	cvar_t* m_pCvarColor;
	unsigned long m_iDefaultHUDColor;
	void UpdateDefaultHUDColor();

	HSPRITE m_hGasPuff;

	int m_iFontHeight, m_iFontWidth;
	CHudAmmo        m_Ammo;
	CHudHealth      m_Health;
	CHudSpectator   m_Spectator;
	CHudGeiger      m_Geiger;
	CHudBattery	    m_Battery;
	CHudTrain       m_Train;
	CHudFlashlight  m_Flash;
	CHudMessage     m_Message;
	CHudStatusBar   m_StatusBar;
	CHudDeathNotice m_DeathNotice;
	CHudSayText     m_SayText;
	CHudMenu        m_Menu;
	CHudAmmoSecondary m_AmmoSecondary;
	CHudTextMessage m_TextMessage;
	CHudStatusIcons m_StatusIcons;
	CHudScoreboard  m_Scoreboard;
	CHudMOTD        m_MOTD;
	CHudMoney       m_Money;
	CHudTimer       m_Timer;
	CHudRadio       m_Radio;
	CHudProgressBar m_ProgressBar;
	CHudSniperScope m_SniperScope;
	CHudNVG         m_NVG;
	CHudRadar       m_Radar;
	CHudSpectatorGui m_SpectatorGui;
	CHudScenario	m_Scenario;

	// user messages
	CHudMsgFunc(Damage);
	CHudMsgFunc(GameMode);
	CHudMsgFunc(Logo);
	CHudMsgFunc(ResetHUD);
	CHudMsgFunc(InitHUD);
	CHudMsgFunc(ViewMode);
	CHudMsgFunc(SetFOV);
	CHudMsgFunc(Concuss);
	CHudMsgFunc(ShadowIdx);
	CHudMsgFunc(ServerName);

	CHudMsgFunc(Fog);

	// Screen information
	SCREENINFO	m_scrinfo;
	// As Xash3D can fake m_scrinfo for hud scailing
	// we will use a real screen parameters
	SCREENINFO  m_truescrinfo;

	int	m_iWeaponBits;
	int	m_fPlayerDead;
	int m_iIntermission;
	int m_iNoConsolePrint;

	// sprite indexes
	int m_HUD_number_0;

	char m_szServerName[64];

	int m_WhiteTex;

	cvar_t *m_pShowHealth;
	cvar_t *m_pShowMoney;

private:
	void SetGameType();

	HUDLIST	*m_pHudList;
	HSPRITE	m_hsprLogo;
	int	m_iLogo;
	client_sprite_t	*m_pSpriteList;
	int	m_iSpriteCount;
	int	m_iSpriteCountAllRes;
	float m_flMouseSensitivity;
	int	m_iConcussionEffect;
	int	m_iForceCamera;
	int m_iForceChaseCam;
	int m_iFadeToBlack;
	int m_iGameType;
	int	m_iRes;

	// the memory for these arrays are allocated in the first call to CHud::VidInit(), when the hud.txt and associated sprites are loaded.
	// freed in ~CHud()
	HSPRITE *m_rghSprites;	/*[HUD_SPRITE_COUNT]*/			// the sprites loaded from hud.txt
	wrect_t *m_rgrcRects;	/*[HUD_SPRITE_COUNT]*/
	char *m_rgszSpriteNames; /*[HUD_SPRITE_COUNT][MAX_SPRITE_NAME_LENGTH]*/

	cvar_t *hud_draw;
	cvar_t *default_fov;
	cvar_t *zoom_sens_ratio;
};

extern CHud gHUD;
extern cvar_t *sensitivity;

extern int g_iTeamNumber;
extern int g_iUser1;
extern int g_iUser2;
extern int g_iUser3;

```

`cl_dll/hud/MOTD.cpp`:

```cpp
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// MOTD.cpp
//
// for displaying a server-sent message of the day
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "kbutton.h"
#include "triangleapi.h"
#include <string.h>
#include <stdio.h>
#include "draw_util.h"
#include "build.h"

#if XASH_WIN32 == 1 || XASH_PSVITA == 1
#define strcasestr strstr
#endif

int CHudMOTD :: Init( void )
{
	gHUD.AddHudElem( this );

	HOOK_MESSAGE( gHUD.m_MOTD, MOTD );

	cl_hide_motd = CVAR_CREATE("cl_hide_motd", "0", FCVAR_ARCHIVE); // hide motd
	Reset();

	return 1;
}

int CHudMOTD :: VidInit( void )
{
	// Load sprites here
	return 1;
}

void CHudMOTD :: Reset( void )
{
	m_iFlags &= ~HUD_DRAW;  // start out inactive
	m_szMOTD[0] = 0;
	m_iLines = 0;
	m_bShow = false;
	ignoreThisMotd = false;
}

#define LINE_HEIGHT  13
#define ROW_GAP  13
#define ROW_RANGE_MIN 30
#define ROW_RANGE_MAX ( ScreenHeight - 100 )
int CHudMOTD :: Draw( float fTime )
{
	gHUD.m_iNoConsolePrint &= ~( 1 << 1 );
	if( !m_bShow )
		return 1;

	if( cl_hide_motd->value )
	{
		Reset();
		return 1;
	}

	gHUD.m_iNoConsolePrint |= 1 << 1;
	// find the top of where the MOTD should be drawn,  so the whole thing is centered in the screen
	int ypos = (ScreenHeight - LINE_HEIGHT * m_iLines)/2; // shift it up slightly
	char *ch = m_szMOTD;
	int xpos = (ScreenWidth - gHUD.GetCharWidth( 'M' ) * m_iMaxLength) / 2;
	if( xpos < 30 ) xpos = 30;
	int xmax = xpos + gHUD.GetCharWidth( 'M' ) * m_iMaxLength;
	int height = LINE_HEIGHT * m_iLines;
	int ypos_r=ypos;
	if( height > ROW_RANGE_MAX )
	{
		ypos = ROW_RANGE_MIN + 7 + scroll;
		if( ypos  > ROW_RANGE_MIN + 4 )
			scroll-= (ypos - ( ROW_RANGE_MIN + 4))/3.0;
		if( ypos + height < ROW_RANGE_MAX )
			scroll+= (ROW_RANGE_MAX - (ypos + height))/ 3.0;
		ypos_r = ROW_RANGE_MIN;
		height = ROW_RANGE_MAX;
	}
	if( xmax > ScreenWidth - 30 ) xmax = ScreenWidth - 30;
	char *next_line;
	DrawUtils::DrawRectangle(xpos-5, ypos_r - 5, xmax - xpos+10, height + 10);
	while ( *ch )
	{
		int line_length = 0;  // count the length of the current line
		for ( next_line = ch; *next_line != '\n' && *next_line != 0; next_line++ )
			line_length += gHUD.GetCharWidth( (unsigned char)*next_line );
		char *top = next_line;
		if ( *top == '\n' )
			*top = 0;
		else
			top = NULL;

		// find where to start drawing the line
		if( (ypos > ROW_RANGE_MIN) && (ypos + LINE_HEIGHT <= ypos_r + height) )
			DrawUtils::DrawHudString( xpos, ypos, xmax, ch, 255, 180, 0 );

		ypos += LINE_HEIGHT;

		if ( top )  // restore 
			*top = '\n';
		ch = next_line;
		if ( *ch == '\n' )
			ch++;

		if ( ypos > (ScreenHeight - 20) )
			break;  // don't let it draw too low
	}
	
	return 1;
}

int CHudMOTD :: MsgFunc_MOTD( const char *pszName, int iSize, void *pbuf )
{
	if( cl_hide_motd->value )
		return 1;

	if ( m_iFlags & HUD_DRAW )
	{
		Reset(); // clear the current MOTD in prep for this one
	}

	if( ignoreThisMotd )
		return 1;

	BufferReader reader( pszName, pbuf, iSize );

	int is_finished = reader.ReadByte();
	strcat( m_szMOTD, reader.ReadString() );

	// we still don't support html tags in motd :(
	if( strcasestr( m_szMOTD, "<!DOCTYPE HTML>" ) )
	{
		Reset();
		ignoreThisMotd = true;
	}

	if ( is_finished )
	{
		int length = 0;
		
		m_iMaxLength = 0;
		m_iFlags |= HUD_DRAW;


		for ( char *sz = m_szMOTD; *sz != 0; sz++ )  // count the number of lines in the MOTD
		{
			if ( *sz == '\n' )
			{
				m_iLines++;
				if( length > m_iMaxLength )
				{
					m_iMaxLength = length;
					length = 0;
				}
			}
			length++;
		}
		
		m_iLines++;
		if( length > m_iMaxLength )
		{
			m_iMaxLength = length;
			length = 0;
		}
		m_bShow = true;
	}

	return 1;
}

```

`cl_dll/hud/money.cpp`:

```cpp
/*
money.cpp -- Money HUD Widget
Copyright (C) 2015-2016 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/


#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include <string.h>
#include "vgui_parser.h"
#include "draw_util.h"

int CHudMoney::Init( )
{
	HOOK_MESSAGE( gHUD.m_Money, Money );
	HOOK_MESSAGE( gHUD.m_Money, BlinkAcct );
	gHUD.AddHudElem(this);
	m_fFade = 0;
	m_iFlags = 0;
	return 1;
}

int CHudMoney::VidInit()
{
	m_hDollar.SetSpriteByName("dollar");
	m_hMinus.SetSpriteByName("minus");
	m_hPlus.SetSpriteByName("plus");

	return 1;
}

int CHudMoney::Draw(float flTime)
{
	if(( gHUD.m_iHideHUDDisplay & ( HIDEHUD_HEALTH ) ))
		return 1;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT))))
		return 1;

	int r, g, b, alphaBalance;
	m_fFade -= gHUD.m_flTimeDelta;
	if( m_fFade < 0)
	{
		m_fFade = 0.0f;
		m_iDelta = 0;
	}
	float interpolate = ( 5 - m_fFade ) / 5;

	int iDollarWidth = m_hDollar.rect.Width();

	int x = ScreenWidth - iDollarWidth * 7;
	int y = MONEY_YPOS;

	if( m_iBlinkAmt )
	{
		m_fBlinkTime += gHUD.m_flTimeDelta;
		DrawUtils::UnpackRGB( r, g, b, m_fBlinkTime > 0.5f? RGB_REDISH : gHUD.m_iDefaultHUDColor );

		if( m_fBlinkTime > 1.0f )
		{
			m_fBlinkTime = 0.0f;
			--m_iBlinkAmt;
		}
	}
	else
	{
		if( m_iDelta != 0 )
		{
			int iDeltaR, iDeltaG, iDeltaB;
			int iDollarHeight = m_hDollar.rect.Height();
			int iDeltaAlpha = 255 - interpolate * (255);

			DrawUtils::UnpackRGB  (iDeltaR, iDeltaG, iDeltaB, m_iDelta < 0 ? RGB_REDISH : RGB_GREENISH);
			DrawUtils::ScaleColors(iDeltaR, iDeltaG, iDeltaB, iDeltaAlpha);

			if( m_iDelta > 0 )
			{
				r = interpolate * ((gHUD.m_iDefaultHUDColor & 0xFF0000) >> 16);
				g = (RGB_GREENISH & 0xFF00) >> 8;
				b = (RGB_GREENISH & 0xFF);

				// draw delta
				SPR_Set(m_hPlus.spr, iDeltaR, iDeltaG, iDeltaB );
				SPR_DrawAdditive(0, x, y - iDollarHeight * 1.5, &m_hPlus.rect );
			}
			else if( m_iDelta < 0)
			{
				r = (RGB_REDISH & 0xFF0000) >> 16;
				g = ((RGB_REDISH & 0xFF00) >> 8) + interpolate * (((gHUD.m_iDefaultHUDColor & 0xFF00) >> 8) - ((RGB_REDISH & 0xFF00) >> 8));
				b = (RGB_REDISH & 0xFF) - interpolate * (RGB_REDISH & 0xFF);

				SPR_Set(m_hMinus.spr, iDeltaR, iDeltaG, iDeltaB );
				SPR_DrawAdditive(0, x, y - iDollarHeight * 1.5, &m_hMinus.rect );
			}

			DrawUtils::DrawHudNumber2( x + iDollarWidth, y - iDollarHeight * 1.5 , false, 5,
									   m_iDelta < 0 ? -m_iDelta : m_iDelta,
									   iDeltaR, iDeltaG, iDeltaB);
			FillRGBA(x + iDollarWidth / 4, y - iDollarHeight * 1.5 + gHUD.m_iFontHeight / 4, 2, 2, iDeltaR, iDeltaG, iDeltaB, iDeltaAlpha );
		}
		else DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
	}

	alphaBalance = 255 - interpolate * (255 - MIN_ALPHA);


	DrawUtils::ScaleColors( r, g, b, alphaBalance );

	SPR_Set(m_hDollar.spr, r, g, b);
	SPR_DrawAdditive(0, x, y, &m_hDollar.rect);

	DrawUtils::DrawHudNumber2( x + iDollarWidth, y, false, 5, m_iMoneyCount, r, g, b );
	FillRGBA(x + iDollarWidth / 4, y + gHUD.m_iFontHeight / 4, 2, 2, r, g, b, alphaBalance );
	return 1;
}

int CHudMoney::MsgFunc_Money(const char *pszName, int iSize, void *pbuf)
{
	BufferReader buf( pszName, pbuf, iSize );
	int iOldCount = m_iMoneyCount;
	m_iMoneyCount = buf.ReadLong();
	gEngfuncs.Cvar_SetValue( gHUD.cscl_currentmoney->name, m_iMoneyCount );
	m_iDelta = m_iMoneyCount - iOldCount;
	m_fFade = 5.0f; //fade for 5 seconds
	m_iFlags |= HUD_DRAW;
	return 1;
}

int CHudMoney::MsgFunc_BlinkAcct(const char *pszName, int iSize, void *pbuf)
{
	BufferReader buf( pszName, pbuf, iSize );

	m_iBlinkAmt = buf.ReadByte();
	m_fBlinkTime = 0;
	return 1;
}

```

`cl_dll/hud/nvg.cpp`:

```cpp
/*
nvg.cpp - Night Vision Googles
Copyright (C) 2015-2016 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.

*/

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "r_efx.h"
#include "dlight.h"

int CHudNVG::Init()
{
	HOOK_MESSAGE( gHUD.m_NVG, NVGToggle);
	HOOK_COMMAND( gHUD.m_NVG,"+nvgadjust", NVGAdjustUp);
	HOOK_COMMAND( gHUD.m_NVG, "-nvgadjust", NVGAdjustDown);
	HOOK_COMMAND( gHUD.m_NVG, "nvgadjustup", NVGAdjustUp);
	HOOK_COMMAND( gHUD.m_NVG,"nvgadjustdown", NVGAdjustDown);

	cl_fancy_nvg = CVAR_CREATE( "cl_fancy_nvg", "0", FCVAR_ARCHIVE );

	gHUD.AddHudElem(this);
	m_iFlags = 0;
	m_iAlpha = 110; // 220 is max, 30 is min

   return 0;
}


int CHudNVG::Draw(float flTime)
{
	if( gEngfuncs.IsSpectateOnly() )
	{
		return 1;
	}

	gEngfuncs.pfnFillRGBABlend(0, 0, ScreenWidth, ScreenHeight, 50, 225, 50, m_iAlpha);

	// draw a dynamic light on player's origin
	if( cl_fancy_nvg->value )
	{
		// recreate new dlight every frame

		dlight_t *dl = gEngfuncs.pEfxAPI->CL_AllocDlight ( 0 );
		dl->origin = gHUD.m_vecOrigin;
		dl->radius = Com_RandomLong( 750, 800 );
		dl->die = flTime + 0.1f;
		dl->color.r = 50;
		dl->color.g = 255;
		dl->color.b = 50;
	}
	else
	{
		// recreate if died
		if( !m_pLight || m_pLight->die < flTime )
		{
			m_pLight = gEngfuncs.pEfxAPI->CL_AllocDlight( 0 );

			// I hope no one is crazy so much to keep NVG for 9999 seconds
			m_pLight->die = flTime + 9999.0f;
			m_pLight->color.r = 50;
			m_pLight->color.g = 255;
			m_pLight->color.b = 50;
		}

		// just update origin
		if( m_pLight )
		{
			m_pLight->origin = gHUD.m_vecOrigin;
			m_pLight->radius = Com_RandomLong( 750, 800 );
		}
	}
	return 1;
}

void CHudNVG::Reset( void )
{
	m_iFlags = 0;

	if( m_pLight )
	{
		m_pLight->die = 0; // engine will remove this immediately

		m_pLight = NULL; // it's safe to set it 0 now
	}
}

int CHudNVG::MsgFunc_NVGToggle(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	m_iFlags = reader.ReadByte() ? HUD_DRAW : 0;

	if( m_pLight )
	{
		m_pLight->die = 0; // engine will remove this immediately

		m_pLight = NULL; // it's safe to set it 0 now
	}
	return 1;
}

void CHudNVG::UserCmd_NVGAdjustUp()
{
	m_iAlpha = m_iAlpha + 20;
	m_iAlpha = min( 220, m_iAlpha );
}

void CHudNVG::UserCmd_NVGAdjustDown()
{
	m_iAlpha = m_iAlpha - 20;
	m_iAlpha = max( 30, m_iAlpha );
}

```

`cl_dll/hud/radar.cpp`:

```cpp
/*
radar.cpp - Radar
Copyright (C) 2016 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "draw_util.h"
#include "triangleapi.h"
#include "vgui_parser.h"
#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

static byte	r_RadarCross[8][8] =
{
{1,1,0,0,0,0,1,1},
{1,1,1,0,0,1,1,1},
{0,1,1,1,1,1,1,0},
{0,0,1,1,1,1,0,0},
{0,0,1,1,1,1,0,0},
{0,1,1,1,1,1,1,0},
{1,1,1,0,0,1,1,1},
{1,1,0,0,0,0,1,1}
};

static byte	r_RadarT[8][8] =
{
{1,1,1,1,1,1,1,1},
{1,1,1,1,1,1,1,1},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0}
};

static byte	r_RadarFlippedT[8][8] =
{
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{1,1,1,1,1,1,1,1},
{1,1,1,1,1,1,1,1}
};

#define BLOCK_SIZE_MAX 1024

static byte	data2D[BLOCK_SIZE_MAX*4];	// intermediate texbuffer

int CHudRadar::Init()
{
	HOOK_MESSAGE( gHUD.m_Radar, Radar );
	HOOK_COMMAND( gHUD.m_Radar, "drawradar", ShowRadar );
	HOOK_COMMAND( gHUD.m_Radar, "hideradar", HideRadar );
	HOOK_MESSAGE( gHUD.m_Radar, HostageK );
	HOOK_MESSAGE( gHUD.m_Radar, HostagePos );
	HOOK_MESSAGE( gHUD.m_Radar, BombDrop );
	HOOK_MESSAGE( gHUD.m_Radar, BombPickup );
	HOOK_MESSAGE( gHUD.m_Radar, Location );

	m_iFlags = HUD_DRAW;

	cl_radartype = CVAR_CREATE( "cl_radartype", "0", FCVAR_ARCHIVE );

	bTexturesInitialized = bUseRenderAPI = false;

	gHUD.AddHudElem( this );
	return 1;
}

void CHudRadar::Reset()
{
	// make radar don't draw old players after new map
	for( int i = 0; i < 34; i++ )
	{
		g_PlayerExtraInfo[i].radarflashes = 0;

		if( i <= MAX_HOSTAGES ) g_HostageInfo[i].radarflashes = 0;
	}
}

static void Radar_InitBitmap( int w, int h, byte *buf )
{
	for( int x = 0; x < w; x++ )
	{
		for( int y = 0; y < h; y++ )
		{
			data2D[(y * 8 + x) * 4 + 0] = 255;
			data2D[(y * 8 + x) * 4 + 1] = 255;
			data2D[(y * 8 + x) * 4 + 2] = 255;
			data2D[(y * 8 + x) * 4 + 3] = buf[y*h + x]  * 255;
		}
	}
}

int CHudRadar::InitBuiltinTextures( void )
{
	texFlags_t defFlags = (texFlags_t)(TF_NOMIPMAP |TF_NEAREST | TF_CLAMP | TF_HAS_ALPHA);

	if( bTexturesInitialized )
		return 1;

	const struct
	{
		const char	*name;
		byte	*buf;
		int		*texnum;
		int		w, h;
		void	(*init)( int w, int h, byte *buf );
	}
	textures[] =
	{
	{ "radarT",		   (byte*)r_RadarT,        &hT,	       8, 8, Radar_InitBitmap },
	{ "radarcross",    (byte*)r_RadarCross,    &hCross,    8, 8, Radar_InitBitmap },
	{ "radarflippedT", (byte*)r_RadarFlippedT, &hFlippedT, 8, 8, Radar_InitBitmap }
	};
	size_t	i, num_builtin_textures = sizeof( textures ) / sizeof( textures[0] );

	for( i = 0; i < num_builtin_textures; i++ )
	{
		textures[i].init( textures[i].w, textures[i].h, textures[i].buf );
		*textures[i].texnum = gRenderAPI.GL_CreateTexture( textures[i].name, textures[i].w, textures[i].h, data2D, defFlags );
		if( *textures[i].texnum == 0 )
		{
			// it's maybe safer to leave texture render uninitialized and use classic fillrgba
			for( size_t j = 0; j < i; j++ )
			{
				gRenderAPI.GL_FreeTexture( *textures[j].texnum );
			}
			return 0;
		}
	}

	bTexturesInitialized = true;

	return 1;
}

void CHudRadar::Shutdown( void )
{
	// GL_FreeTexture( hDot ); engine inner texture
	if( bTexturesInitialized )
	{
		gRenderAPI.GL_FreeTexture( hT );
		gRenderAPI.GL_FreeTexture( hFlippedT );
		gRenderAPI.GL_FreeTexture( hCross );
	}
}

void CHudRadar::InitHUDData( void )
{
	UserCmd_ShowRadar();
	Reset();
}

int CHudRadar::VidInit(void)
{
	bUseRenderAPI = g_iXash && InitBuiltinTextures();

	m_hRadar.SetSpriteByName( "radar" );
	m_hRadarOpaque.SetSpriteByName( "radaropaque" );
	iMaxRadius = (m_hRadar.rect.Width()) / 2.0f;
	return 1;
}

void CHudRadar::UserCmd_HideRadar()
{
	m_iFlags &= ~HUD_DRAW;
}

void CHudRadar::UserCmd_ShowRadar()
{
	m_iFlags |= HUD_DRAW;
}

int CHudRadar::MsgFunc_Radar(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int index = reader.ReadByte();
	g_PlayerExtraInfo[index].origin.x = reader.ReadCoord();
	g_PlayerExtraInfo[index].origin.y = reader.ReadCoord();
	g_PlayerExtraInfo[index].origin.z = reader.ReadCoord();
	return 1;
}

bool CHudRadar::FlashTime( float flTime, extra_player_info_t *pplayer )
{
	// radar flashing
	if( pplayer->radarflashes )
	{
		if( flTime > pplayer->radarflashtime )
		{
			pplayer->nextflash = !pplayer->nextflash;
			pplayer->radarflashtime += pplayer->radarflashtimedelta;
			pplayer->radarflashes--;
		}
	}
	else
	{
		return true;
	}

	return pplayer->nextflash;
}

bool CHudRadar::HostageFlashTime( float flTime, hostage_info_t *pplayer )
{
	// radar flashing
	if( pplayer->radarflashes )
	{
		if( flTime > pplayer->radarflashtime )
		{
			pplayer->nextflash = !pplayer->nextflash;
			pplayer->radarflashtime += pplayer->radarflashtimedelta;
			pplayer->radarflashes--;
		}
	}
	else
	{
		return false; // non-flashing hostage must be never drawn on radar!
	}

	return pplayer->nextflash;
}

void CHudRadar::DrawZAxis( Vector pos, int r, int g, int b, int a )
{
	const float diff = 128;

	if( pos.z > -diff && pos.z < diff )
	{
		DrawRadarDot( pos.x, pos.y, r, g, b, a );
	}
	else if( pos.z <= -diff )
	{
		// higher than player
		DrawT( pos.x, pos.y, r, g, b, a );
	}
	else
	{
		// lower than player
		DrawFlippedT( pos.x, pos.y, r, g, b, a );
	}
}

int CHudRadar::Draw(float flTime)
{
	if ( (gHUD.m_iHideHUDDisplay & HIDEHUD_HEALTH) ||
		 gEngfuncs.IsSpectateOnly() ||
		 !(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT))) ||
		 gHUD.m_fPlayerDead )
		return 1;

	int iTeamNumber = g_PlayerExtraInfo[ gHUD.m_Scoreboard.m_iPlayerNum ].teamnumber;
	int r, g, b;

	if( cl_radartype->value )
	{
		SPR_Set(m_hRadarOpaque.spr, 200, 200, 200);
		SPR_DrawHoles(0, 0, 0, &m_hRadarOpaque.rect);
	}
	else
	{
		SPR_Set( m_hRadar.spr, 25, 75, 25 );
		SPR_DrawAdditive( 0, 0, 0, &m_hRadarOpaque.rect );
	}

	if( bUseRenderAPI )
	{
		gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
		gEngfuncs.pTriAPI->CullFace( TRI_NONE );
		gEngfuncs.pTriAPI->Brightness( 1 );
	}

	for(int i = 0; i < 33; i++)
	{
		// skip local player and dead players
		if( i == gHUD.m_Scoreboard.m_iPlayerNum || g_PlayerExtraInfo[i].dead )
			continue;

		// skip non-teammates
		if( g_PlayerExtraInfo[i].teamnumber != iTeamNumber )
			continue;

		// decide should player draw at this time. For flashing.
		// Always true for non-flashing players
		if( !FlashTime( flTime, &g_PlayerExtraInfo[i]) )
			continue;

		// player with C4 or VIP must be red
		if( g_PlayerExtraInfo[i].has_c4 || g_PlayerExtraInfo[i].vip )
		{
			DrawUtils::UnpackRGB( r, g, b, RGB_REDISH );
		}
		else
		{
			// white
			DrawUtils::UnpackRGB( r, g, b, RGB_WHITE );
		}

		// calc radar position
		Vector pos = WorldToRadar(gHUD.m_vecOrigin, g_PlayerExtraInfo[i].origin, gHUD.m_vecAngles);

		DrawZAxis( pos, r, g, b, 255 );
	}

	// Terrorist specific code( C4 Bomb )
	if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
	{
		if ( !g_PlayerExtraInfo[33].dead &&
			 g_PlayerExtraInfo[33].radarflashes &&
			 FlashTime( flTime, &g_PlayerExtraInfo[33] ))
		{
			Vector pos = WorldToRadar(gHUD.m_vecOrigin, g_PlayerExtraInfo[33].origin, gHUD.m_vecAngles);
			if( g_PlayerExtraInfo[33].playerclass ) // bomb planted
			{
				DrawCross( pos.x, pos.y, 255, 0, 0, 255 );
			}
			else
			{
				DrawZAxis( pos, 255, 0, 0, 255 );
			}
		}
	}
	// Counter-Terrorist specific code( hostages )
	else if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_CT )
	{
		// draw hostages for CT
		for( int i = 0; i < MAX_HOSTAGES; i++ )
		{
			if( !HostageFlashTime( flTime, g_HostageInfo + i ) )
			{
				continue;
			}

			Vector pos = WorldToRadar(gHUD.m_vecOrigin, g_HostageInfo[i].origin, gHUD.m_vecAngles);
			if( g_HostageInfo[i].dead )
			{
				DrawZAxis( pos, 255, 0, 0, 255 );
			}
			else
			{
				DrawZAxis( pos, 4, 25, 110, 255 );
			}
		}
	}

	if( gHUD.GetGameType() == GAME_CZERO )
		DrawPlayerLocation( ( m_hRadarOpaque.rect.Height() ) + 10 );

	return 0;
}

void CHudRadar::DrawPlayerLocation( int y )
{
	const char *szLocation = g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].location;
	if( szLocation[0] )
	{
		// Localize the location string
		const char *szLocalizedLocation = Localize( szLocation );

		int x = (m_hRadarOpaque.rect.Width()) / 2;
		int len = DrawUtils::ConsoleStringLen( szLocalizedLocation );

		x = x - len / 2;

		DrawUtils::DrawConsoleString( x, y, szLocalizedLocation );
	}
}

inline void CHudRadar::DrawColoredTexture( int x, int y, int size, byte r, byte g, byte b, byte a, int texHandle )
{
	gRenderAPI.GL_Bind( 0, texHandle );

	// gEngfuncs.pTriAPI->Begin( TRI_QUADS );

	gEngfuncs.pTriAPI->Color4ub( r, g, b, a );
	DrawUtils::Draw2DQuad( (iMaxRadius + x - size * 2) * gHUD.m_flScale,
						   (iMaxRadius + y - size * 2) * gHUD.m_flScale,
						   (iMaxRadius + x + size * 2) * gHUD.m_flScale,
						   (iMaxRadius + y + size * 2) * gHUD.m_flScale);
	
	// gEngfuncs.pTriAPI->End();
}


void CHudRadar::DrawRadarDot( int x, int y, int r, int g, int b, int a )
{
	const int size = 1;
	if( bUseRenderAPI )
	{
		DrawColoredTexture( x, y, size, r, g, b, a, gHUD.m_WhiteTex );
	}
	else
	{
		FillRGBA(iMaxRadius + x - size*2, iMaxRadius + y - size*2, size*4, size*4, r, g, b, a);
	}
}


void CHudRadar::DrawCross( int x, int y, int r, int g, int b, int a )
{
	const int size = 2;
	if( bUseRenderAPI )
	{
		DrawColoredTexture( x, y, size, r, g, b, a, hCross );
	}
	else
	{
		FillRGBA(iMaxRadius + x, iMaxRadius + y, size, size, r, g, b, a);
		FillRGBA(iMaxRadius + x - size, iMaxRadius + y - size, size, size, r, g, b, a);
		FillRGBA(iMaxRadius + x - size, iMaxRadius + y + size, size, size, r, g, b, a);
		FillRGBA(iMaxRadius + x + size, iMaxRadius + y - size, size, size, r, g, b, a);
		FillRGBA(iMaxRadius + x + size, iMaxRadius + y + size, size, size, r, g, b, a);
	}
}

void CHudRadar::DrawT( int x, int y, int r, int g, int b, int a )
{
	const int size = 2;

	if( bUseRenderAPI )
	{
		DrawColoredTexture( x, y, size, r, g, b, a, hT );
	}
	else
	{
		FillRGBA( iMaxRadius + x - size, iMaxRadius + y - size, size * 3, size, r, g, b, a);
		FillRGBA( iMaxRadius + x, iMaxRadius + y, size, size * 2, r, g, b, a);
	}
}

void CHudRadar::DrawFlippedT( int x, int y, int r, int g, int b, int a )
{
	const int size = 2;
	if( bUseRenderAPI )
	{
		DrawColoredTexture( x, y, size, r, g, b, a, hFlippedT );
	}
	else
	{
		FillRGBA( iMaxRadius + x, iMaxRadius + y - size, size, size*2, r, g, b, a);
		FillRGBA( iMaxRadius + x - size, iMaxRadius + y + size, size*3, size, r, g, b, a);
	}
}


Vector CHudRadar::WorldToRadar(const Vector vPlayerOrigin, const Vector vObjectOrigin, const Vector vAngles  )
{
	Vector2D diff = vObjectOrigin.Make2D() - vPlayerOrigin.Make2D();
	const float RADAR_SCALE = 32.0f;

	// Supply epsilon values to avoid divide-by-zero
	if( diff.x == 0 )
		diff.x = 0.00001f;
	if( diff.y == 0 )
		diff.y = 0.00001f;

	float flOffset = DEG2RAD( vAngles.y - RAD2DEG( atan2( diff.y, diff.x ) ) );

	// this magic 32.0f just scales position on radar
	float iRadius = min( diff.Length() / RADAR_SCALE, iMaxRadius );

	// transform origin difference to radar source
	Vector ret( (float)(iRadius * sin(flOffset)),
				(float)(iRadius * -cos(flOffset)),
				(float)(vPlayerOrigin.z - vObjectOrigin.z) );

	return ret;
}

int CHudRadar::MsgFunc_BombDrop(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	g_PlayerExtraInfo[33].origin.x = reader.ReadCoord();
	g_PlayerExtraInfo[33].origin.y = reader.ReadCoord();
	g_PlayerExtraInfo[33].origin.z = reader.ReadCoord();

	g_PlayerExtraInfo[33].radarflashes = 99999;
	g_PlayerExtraInfo[33].radarflashtime = gHUD.m_flTime;
	g_PlayerExtraInfo[33].radarflashtimedelta = 0.5f;
	strncpy(g_PlayerExtraInfo[33].teamname, "TERRORIST", MAX_TEAM_NAME);
	g_PlayerExtraInfo[33].dead = false;
	g_PlayerExtraInfo[33].nextflash = true;

	int Flag = reader.ReadByte();
	g_PlayerExtraInfo[33].playerclass = Flag;

	if( Flag ) // bomb planted
	{
		gHUD.m_SpectatorGui.m_bBombPlanted = 0;
		gHUD.m_Timer.m_iFlags = 0;
	}
	return 1;
}

int CHudRadar::MsgFunc_BombPickup(const char *pszName, int iSize, void *pbuf)
{
	g_PlayerExtraInfo[33].radarflashes = false;
	g_PlayerExtraInfo[33].dead = true;

	return 1;
}

int CHudRadar::MsgFunc_HostagePos(const char *pszName, int iSize, void *pbuf)
{

	BufferReader reader( pszName, pbuf, iSize );
	int Flag = reader.ReadByte();
	int idx = reader.ReadByte();
	if( idx <= MAX_HOSTAGES )
	{
		g_HostageInfo[idx].origin.x = reader.ReadCoord();
		g_HostageInfo[idx].origin.y = reader.ReadCoord();
		g_HostageInfo[idx].origin.z = reader.ReadCoord();
		g_HostageInfo[idx].dead = false;

		if( Flag == 1 ) // first message about this hostage, start flashing
		{
			g_HostageInfo[idx].radarflashes = 99999;
			g_HostageInfo[idx].radarflashtime = gHUD.m_flTime;
			g_HostageInfo[idx].radarflashtimedelta = 0.5f;
		}
	}

	return 1;
}

int CHudRadar::MsgFunc_HostageK(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );
	int idx = reader.ReadByte();
	if ( idx <= MAX_HOSTAGES )
	{
		g_HostageInfo[idx].dead = true;
		g_HostageInfo[idx].radarflashtime = gHUD.m_flTime;
		g_HostageInfo[idx].radarflashes = 15;
		g_HostageInfo[idx].radarflashtimedelta = 0.1f;
	}

	return 1;
}

int CHudRadar::MsgFunc_Location(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	int player = reader.ReadByte();
	if( player <= MAX_PLAYERS )
	{
		const char *location = reader.ReadString();

		strncpy( g_PlayerExtraInfo[player].location, location, sizeof( g_PlayerExtraInfo[player].location ) );
		g_PlayerExtraInfo[player].location[31] = 0;

		GetClientVoiceHud()->UpdateLocation( player, g_PlayerExtraInfo[player].location );
	}
	return 0;
}

```

`cl_dll/hud/radio.cpp`:

```cpp
/*
radio.cpp -- Radio HUD implementation
Copyright (C) 2015-2016 a1batross
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/
#include "hud.h"
#include "parsemsg.h"
#include "cl_util.h"
#include "r_efx.h"
#include "event_api.h"
#include "com_model.h"
#include <string.h>

int CHudRadio::Init( )
{
	HOOK_MESSAGE( gHUD.m_Radio, SendAudio );
	HOOK_MESSAGE( gHUD.m_Radio, ReloadSound );
	HOOK_MESSAGE( gHUD.m_Radio, BotVoice );
	gHUD.AddHudElem( this );
	m_iFlags = 0;
	return 1;
}


void Broadcast( const char *msg, int pitch )
{
	if ( msg[0] == '%' && msg[1] == '!' )
		gEngfuncs.pfnPlaySoundVoiceByName( &msg[1], 1.0f, pitch );
	else
		gEngfuncs.pfnPlaySoundVoiceByName( msg, 1.0f, pitch );
}

int CHudRadio::MsgFunc_SendAudio( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int SenderID = reader.ReadByte( );
	char *sentence = reader.ReadString( );
	int pitch = reader.ReadShort( );

	Broadcast( sentence, pitch );

	if( SenderID <= MAX_PLAYERS )
	{
		g_PlayerExtraInfo[SenderID].radarflashes = 22;
		g_PlayerExtraInfo[SenderID].radarflashtime = gHUD.m_flTime;
		g_PlayerExtraInfo[SenderID].radarflashtimedelta = 0.5f;
	}
	return 1;
}

int CHudRadio::MsgFunc_ReloadSound( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int vol = reader.ReadByte( );
	if ( reader.ReadByte( ) )
	{
		gEngfuncs.pfnPlaySoundByName( "weapons/generic_reload.wav", vol / 255.0f );
	}
	else
	{
		gEngfuncs.pfnPlaySoundByName( "weapons/generic_shot_reload.wav", vol / 255.0f );
	}
	return 1;
}


static void VoiceIconCallback(struct tempent_s *ent, float frametime, float currenttime)
{
	int entIndex = ent->clientIndex;
	if( !g_PlayerExtraInfo[entIndex].talking )
	{
		g_PlayerExtraInfo[entIndex].talking = false;
		ent->die = 0.0f;
	}
}

void CHudRadio::Voice(int entindex, bool bTalking)
{
	extra_player_info_t *pplayer;
	TEMPENTITY *temp;
	int spr;

	if( entindex < 0 || entindex > MAX_PLAYERS - 1) // bomb can't talk!
		return;

	pplayer = g_PlayerExtraInfo + entindex;

	if( bTalking == pplayer->talking )
		return; // user is talking already

	if( !bTalking && pplayer->talking )
	{
		pplayer->talking = false;
		return; // stop talking
	}

	spr = gEngfuncs.pEventAPI->EV_FindModelIndex( "sprites/voiceicon.spr" );
	if( !spr ) return;

	temp = gEngfuncs.pEfxAPI->R_DefaultSprite( vec3_origin, spr, 0 );
	if( !temp ) return;

	pplayer->talking = true; // sprite is created

	temp->flags = FTENT_SPRANIMATELOOP | FTENT_CLIENTCUSTOM | FTENT_PLYRATTACHMENT;
	temp->tentOffset.z = 40;
	temp->clientIndex = entindex;
	temp->callback = VoiceIconCallback;
	temp->entity.curstate.scale = 0.60f;
	temp->entity.curstate.rendermode = kRenderTransAdd;
	temp->die = gHUD.m_flTime + 60.0f; // 60 seconds must be enough?
}

int CHudRadio::MsgFunc_BotVoice( const char *pszName, int iSize, void *buf )
{
	BufferReader reader( pszName, buf, iSize );

	int enable   = reader.ReadByte();
	int entIndex = reader.ReadByte();

	HUD_VoiceStatus( entIndex, enable );

	// Voice( entIndex, enable );

	return 1;
}

```

`cl_dll/hud/scenario.cpp`:

```cpp
// This is an open source non-commercial project. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com
/*
scenario.cpp -- CSCZ Scenario HUD implementation
Copyright (C) 2017 a1batross
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/

#include "hud.h"
#include "parsemsg.h"
#include "cl_util.h"
#include "r_efx.h"
#include "event_api.h"
#include "com_model.h"
#include "draw_util.h"
#include <string.h>

int CHudScenario::Init( )
{
	HOOK_MESSAGE( gHUD.m_Scenario, Scenario );
	m_iFlags = 0;
	gHUD.AddHudElem( this );

	return 0;
}

int CHudScenario::VidInit( )
{
	return 0;
}

void CHudScenario::Reset()
{
	m_sprite.spr = 0;
}

int CHudScenario::Draw(float flTime)
{
	if( gHUD.m_iHideHUDDisplay & HIDEHUD_HEALTH || g_iUser1 || gEngfuncs.IsSpectateOnly() || !m_sprite.spr )
		return 1;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return 1;

	int r, g, b;
	int x, y;
	DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );

	if( m_fFlashRate != 0.0f && m_fNextFlash < flTime )
	{
		m_iAlpha = m_iFlashAlpha;
		m_fNextFlash = flTime + m_fFlashRate;
	}

	if ( m_iAlpha > MIN_ALPHA ) m_iAlpha -= 20;
	else m_iAlpha = MIN_ALPHA;

	DrawUtils::ScaleColors( r, g, b, m_iAlpha );

	x = gHUD.m_Timer.m_right + gHUD.m_iFontWidth * 1.5;
	y = ScreenHeight - 1.5 * gHUD.m_iFontHeight - ( m_sprite.rect.Height() - gHUD.m_iFontHeight ) / 2 ;

	SPR_Set( m_sprite.spr, r, g, b );
	SPR_DrawAdditive( 0, x, y, &m_sprite.rect );
	return 1;
}

int CHudScenario::MsgFunc_Scenario(const char *pszName, int iSize, void *buf)
{
	BufferReader reader( pszName, buf, iSize );

	bool active = reader.ReadByte();
	if( !active )
	{
		m_iFlags = 0;
		return 1;
	}

	m_iFlags = HUD_DRAW;

	const char *spriteName = reader.ReadString();
	m_sprite.SetSpriteByName( spriteName );

	m_iFlashAlpha = reader.ReadByte();
	m_fFlashRate = reader.ReadShort() * 0.01;
	m_fNextFlash = reader.ReadShort() * 0.01 + gHUD.m_flTime;

	return 1;
}

```

`cl_dll/hud/scoreboard.cpp`:

```cpp
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Scoreboard.cpp
//
// implementation of CHudScoreboard class
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "triangleapi.h"
#include "com_weapons.h"
#include "cdll_dll.h"

#include <string.h>
#include <stdio.h>
#include "draw_util.h"
#include "vgui_parser.h"
#include <ctype.h>

hud_player_info_t   g_PlayerInfoList[MAX_PLAYERS+1]; // player info from the engine
extra_player_info_t	g_PlayerExtraInfo[MAX_PLAYERS+1]; // additional player info sent directly to the client dll
team_info_t         g_TeamInfo[MAX_TEAMS+1];
hostage_info_t      g_HostageInfo[MAX_HOSTAGES+1];
int g_iUser1;
int g_iUser2;
int g_iUser3;
int g_iTeamNumber;


// X positions

int xstart, xend;
int ystart, yend;

enum
{
	COL_NAME = 0,
	COL_ATTRIB,
	COL_HP,
	COL_MONEY,
	COL_KILLS,
	COL_DEATHS,
	COL_PING,
	TOTAL_COLUMNS
};

static struct Column
{
	int start, end;
	const char *name;

	Column() :
	    start( 0 ), end( 0 ), name( nullptr ) { }

	Column( int s, const char *n = nullptr, bool reverse = true )
	{
		name = n;
		end = 0;
		start = 0;

		if ( reverse )
		{
			start = s;
			if ( n )
				end = start - DrawUtils::HudStringLen( n );
		}
		else
		{
			start = s;
			if ( n )
				end = start + DrawUtils::HudStringLen( n );
		}
	}
} g_Columns[TOTAL_COLUMNS];

//#include "vgui_TeamFortressViewport.h"

int CHudScoreboard :: Init( void )
{
	gHUD.AddHudElem( this );

	// Hook messages & commands here
	HOOK_COMMAND( gHUD.m_Scoreboard, "+showscores", ShowScores );
	HOOK_COMMAND( gHUD.m_Scoreboard, "-showscores", HideScores );
	HOOK_COMMAND( gHUD.m_Scoreboard, "showscoreboard2", ShowScoreboard2 );
	HOOK_COMMAND( gHUD.m_Scoreboard, "hidescoreboard2", HideScoreboard2 );

	HOOK_MESSAGE( gHUD.m_Scoreboard, ScoreInfo );
	HOOK_MESSAGE( gHUD.m_Scoreboard, TeamScore );
	HOOK_MESSAGE( gHUD.m_Scoreboard, TeamInfo );

	InitHUDData();

	cl_showpacketloss = CVAR_CREATE( "cl_showpacketloss", "0", FCVAR_ARCHIVE );
	cl_showplayerversion = CVAR_CREATE( "cl_showplayerversion", "0", 0 );

	return 1;
}


int CHudScoreboard :: VidInit( void )
{
	xstart = ScreenWidth * 0.125f;
	xend = ScreenWidth - xstart;
	ystart = 100;
	yend = ScreenHeight - ystart;
	m_bForceDraw = false;

	// Load sprites here
	return 1;
}

void CHudScoreboard :: InitHUDData( void )
{
	memset( g_PlayerExtraInfo, 0, sizeof g_PlayerExtraInfo );
	m_iLastKilledBy = 0;
	m_fLastKillTime = 0;
	m_iPlayerNum = 0;
	m_iNumTeams = 0;
	memset( g_TeamInfo, 0, sizeof g_TeamInfo );

	for ( int i = 1; i <= MAX_PLAYERS; i++ )
	{
		g_PlayerExtraInfo[i].sb_health = -1;
		g_PlayerExtraInfo[i].sb_account = -1;
	}

	m_iFlags &= ~HUD_DRAW;  // starts out inactive

	m_iFlags |= HUD_INTERMISSION; // is always drawn during an intermission
}

bool CHudScoreboard :: ShouldDrawScoreboard() const
{
	if( m_bForceDraw )
		return true;

	if( m_bShowscoresHeld || gHUD.m_Health.m_iHealth <= 0 || gHUD.m_iIntermission )
		return true;

	return false;
}

// Y positions
#define ROW_GAP  15

int CHudScoreboard :: Draw( float flTime )
{
	if( !ShouldDrawScoreboard( ))
		return 1;

	if( !m_bForceDraw )
	{
		xstart     = 0.125f * ScreenWidth;
		xend       = ScreenWidth - xstart;
		ystart     = 90;
		yend       = ScreenHeight - ystart;
		m_colors.r = 0;
		m_colors.g = 0;
		m_colors.b = 0;
		m_colors.a = 153;
		m_bDrawStroke = true;
	}

	return DrawScoreboard(flTime);
}

int CHudScoreboard :: DrawScoreboard( float fTime )
{
	GetAllPlayersInfo();
	char ServerName[90];

//	Packetloss removed on Kelly 'shipping nazi' Bailey's orders
//	if ( cl_showpacketloss && cl_showpacketloss->value && ( ScreenWidth >= 400 ) )
//	{
//		can_show_packetloss = 1;
//	}

	// just sort the list on the fly
	// list is sorted first by frags, then by deaths
	float list_slot = 0;

	// calculate columns sizes
	g_Columns[COL_PING] = Column( xend - 15, Localize( "#PlayerPing" ) );
	g_Columns[COL_DEATHS] = Column( g_Columns[COL_PING].end - 10, Localize( "#PlayerDeath" ) );
	g_Columns[COL_KILLS] = Column( g_Columns[COL_DEATHS].end - 10, Localize( "#PlayerScore" ) );
	g_Columns[COL_MONEY] = Column( g_Columns[COL_KILLS].end - 10, Localize( "#Cstrike_ACCOUNT" ) );
	g_Columns[COL_MONEY].end = g_Columns[COL_MONEY].start - DrawUtils::HudStringLen( "$16000" );
	g_Columns[COL_HP] = Column( g_Columns[COL_MONEY].end - 10, Localize( "#Cstrike_HEALTH" ) );
	g_Columns[COL_HP].end = g_Columns[COL_HP].start - DrawUtils::HudStringLen( "100" );
	g_Columns[COL_ATTRIB] = Column( g_Columns[COL_HP].end - 10 );
	g_Columns[COL_ATTRIB].end = g_Columns[COL_ATTRIB].start - DrawUtils::HudStringLen( "#Cstrike_DEFUSE_KIT" );
	g_Columns[COL_NAME] = Column( xstart + 15, nullptr, false );
	g_Columns[COL_NAME].end = g_Columns[COL_ATTRIB].end - 10;

	// print the heading line

	DrawUtils::DrawRectangle(xstart, ystart, xend - xstart, yend - ystart,
		m_colors.r, m_colors.g, m_colors.b, m_colors.a, m_bDrawStroke);

	int ypos = ystart + (list_slot * ROW_GAP) + 5;

	if( gHUD.m_szServerName[0] )
		// snprintf( ServerName, 80, "%s", (char*)(gHUD.m_Teamplay ? "TEAMS" : "PLAYERS"), gHUD.m_szServerName );
		strncpy( ServerName, gHUD.m_szServerName, 80 );
	else
		strncpy( ServerName, gHUD.m_Teamplay ? "TEAMS" : "PLAYERS", 80 );

	DrawUtils::DrawHudString( g_Columns[COL_NAME].start, ypos, g_Columns[COL_NAME].end, ServerName, 255, 140, 0 );
	DrawUtils::DrawHudStringReverse( g_Columns[COL_HP].start, ypos, g_Columns[COL_HP].end, g_Columns[COL_HP].name, 255, 140, 0 );
	DrawUtils::DrawHudStringReverse( g_Columns[COL_MONEY].start, ypos, g_Columns[COL_MONEY].end, g_Columns[COL_MONEY].name, 255, 140, 0 );
	DrawUtils::DrawHudStringReverse( g_Columns[COL_KILLS].start, ypos, g_Columns[COL_KILLS].end, g_Columns[COL_KILLS].name, 255, 140, 0 );
	DrawUtils::DrawHudStringReverse( g_Columns[COL_DEATHS].start, ypos, g_Columns[COL_DEATHS].end, g_Columns[COL_DEATHS].name, 255, 140, 0 );
	DrawUtils::DrawHudStringReverse( g_Columns[COL_PING].start, ypos, g_Columns[COL_PING].end, g_Columns[COL_PING].name, 255, 140, 0 );

	list_slot += 2;
	ypos = ystart + (list_slot * ROW_GAP);
	FillRGBA( xstart, ypos, xend - xstart, 1, 255, 140, 0, 255);  // draw the separator line

	list_slot += 0.8;

	if ( gHUD.m_Teamplay )
	{
		DrawTeams( list_slot );
	}
	else
	{
		// it's not teamplay,  so just draw a simple player list
		DrawPlayers( list_slot );
	}
	return 1;
}

int CHudScoreboard :: DrawTeams( float list_slot )
{
	int j;
	int ypos = ystart + (list_slot * ROW_GAP) + 5;

	// clear out team scores
	for ( int i = 1; i <= m_iNumTeams; i++ )
	{
		if ( !g_TeamInfo[i].scores_overriden )
			g_TeamInfo[i].frags = g_TeamInfo[i].deaths = 0;
		g_TeamInfo[i].sumping = 0;
		g_TeamInfo[i].players = 0;
		g_TeamInfo[i].already_drawn = FALSE;
	}

	// recalc the team scores, then draw them
	for ( int i = 1; i < MAX_PLAYERS; i++ )
	{
		if ( !g_PlayerInfoList[i].name || !g_PlayerInfoList[i].name[0] )
			continue; // empty player slot, skip

		if ( g_PlayerExtraInfo[i].teamname[0] == 0 )
			continue; // skip over players who are not in a team

		// find what team this player is in
		for ( j = 1; j <= m_iNumTeams; j++ )
		{
			if ( !stricmp( g_PlayerExtraInfo[i].teamname, g_TeamInfo[j].name ) )
				break;
		}

		if ( j > m_iNumTeams )  // player is not in a team, skip to the next guy
			continue;

		if ( !g_TeamInfo[j].scores_overriden )
		{
			g_TeamInfo[j].frags += g_PlayerExtraInfo[i].frags;
			g_TeamInfo[j].deaths += g_PlayerExtraInfo[i].deaths;
		}

		g_TeamInfo[j].sumping += g_PlayerInfoList[i].ping;

		if ( g_PlayerInfoList[i].thisplayer )
			g_TeamInfo[j].ownteam = TRUE;
		else
			g_TeamInfo[j].ownteam = FALSE;

		g_TeamInfo[j].players++;
	}

	// Draw the teams
	int iSpectatorPos = -1;

	while( true )
	{
		int highest_frags = -99999; int lowest_deaths = 99999;
		int best_team = 0;

		for ( int i = 1; i <= m_iNumTeams; i++ )
		{
			// don't draw team without players
			if ( g_TeamInfo[i].players <= 0 )
				continue;

			if (!strnicmp(g_TeamInfo[i].name, "SPECTATOR", MAX_TEAM_NAME))
			{
				iSpectatorPos = i;
				continue;
			}

			if ( !g_TeamInfo[i].already_drawn && g_TeamInfo[i].frags >= highest_frags )
			{
				if ( g_TeamInfo[i].frags > highest_frags || g_TeamInfo[i].deaths < lowest_deaths )
				{
					best_team = i;
					lowest_deaths = g_TeamInfo[i].deaths;
					highest_frags = g_TeamInfo[i].frags;
				}
			}
		}

		// draw the best team on the scoreboard
		if ( !best_team )
		{
			// if spectators is found and still not drawn
			if( iSpectatorPos != -1 && g_TeamInfo[iSpectatorPos].already_drawn == FALSE )
				best_team = iSpectatorPos;
			else break;
		}
		// draw out the best team
		team_info_t *team_info = &g_TeamInfo[best_team];

		// don't draw team without players
		if ( team_info->players <= 0 )
			continue;

		ypos = ystart + (list_slot * ROW_GAP);

		// check we haven't drawn too far down
		if ( ypos > yend )  // don't draw to close to the lower border
			break;

		int r, g, b;
		char teamName[64];

		char numPlayers[16];
		sprintf( numPlayers, "%d", team_info->players );

		char fmtString[32];
		const char *fmtStringName = team_info->players == 1 ? "#Cstrike_ScoreBoard_Player" : "#Cstrike_ScoreBoard_Players";
		strncpy( fmtString, Localize( fmtStringName ), sizeof( fmtString ) );

		if ( !strcmp( fmtString, fmtStringName ) )
			strncpy( fmtString, team_info->players == 1 ? "%s    -   %s player" : "%s    -   %s players", sizeof( fmtString ) );
		else
			Localize_StripIndices( fmtString );

		GetTeamColor( r, g, b, team_info->teamnumber );
		switch ( team_info->teamnumber )
		{
		case TEAM_TERRORIST:
			snprintf( teamName, sizeof( teamName ), fmtString, Localize( "#Cstrike_ScoreBoard_Ter" ), numPlayers );
			DrawUtils::DrawHudNumberString( g_Columns[COL_KILLS].start, ypos, g_Columns[COL_KILLS].end, team_info->frags, r, g, b );
			break;
		case TEAM_CT:
			snprintf( teamName, sizeof( teamName ), fmtString, Localize( "#Cstrike_ScoreBoard_CT" ), numPlayers );
			DrawUtils::DrawHudNumberString( g_Columns[COL_KILLS].start, ypos, g_Columns[COL_KILLS].end, team_info->frags, r, g, b );
			break;
		case TEAM_SPECTATOR:
		case TEAM_UNASSIGNED:
			strncpy( teamName, Localize( "#Spectators" ), sizeof( teamName ) );
			break;
		}

		DrawUtils::DrawHudString( g_Columns[COL_NAME].start, ypos, g_Columns[COL_NAME].end, teamName, r, g, b );
		DrawUtils::DrawHudNumberString( g_Columns[COL_PING].start, ypos, g_Columns[COL_PING].end, team_info->sumping / team_info->players, r, g, b );

		team_info->already_drawn = TRUE;  // set the already_drawn to be TRUE, so this team won't get drawn again

		// draw underline
		list_slot += 1.2f;
		FillRGBA( xstart, ystart + (list_slot * ROW_GAP), xend - xstart, 1, r, g, b, 255);

		list_slot += 0.4f;
		// draw all the players that belong to this team, indented slightly
		list_slot = DrawPlayers( list_slot, 10, team_info->name );
	}

	// draw all the players who are not in a team
	list_slot += 4.0f;
	DrawPlayers( list_slot, 0, "" );

	return 1;
}

// returns the ypos where it finishes drawing
int CHudScoreboard :: DrawPlayers( float list_slot, int nameoffset, const char *team )
{
	// draw the players, in order,  and restricted to team if set
	while ( 1 )
	{
		// Find the top ranking player
		int highest_frags = -99999;	int lowest_deaths = 99999;
		int best_player = 0;

		for ( int i = 1; i < MAX_PLAYERS; i++ )
		{
			if ( g_PlayerInfoList[i].name && g_PlayerExtraInfo[i].frags >= highest_frags )
			{
				if ( !(team && stricmp(g_PlayerExtraInfo[i].teamname, team)) )  // make sure it is the specified team
				{
					extra_player_info_t *pl_info = &g_PlayerExtraInfo[i];
					if ( pl_info->frags > highest_frags || pl_info->deaths < lowest_deaths )
					{
						best_player = i;
						lowest_deaths = pl_info->deaths;
						highest_frags = pl_info->frags;
					}
				}
			}
		}

		if ( !best_player )
			break;

		// draw out the best player
		hud_player_info_t *pl_info = &g_PlayerInfoList[best_player];

		int ypos = ystart + (list_slot * ROW_GAP);

		// check we haven't drawn too far down
		if ( ypos > yend )  // don't draw to close to the lower border
			break;

		int r = 255, g = 255, b = 255;
		float *colors = GetClientColor( best_player );
		r *= colors[0];
		g *= colors[1];
		b *= colors[2];

		if(pl_info->thisplayer) // hey, it's me!
		{
			FillRGBABlend( xstart, ypos, xend - xstart, ROW_GAP, 255, 255, 255, 15 );
		}

		DrawUtils::DrawHudString( g_Columns[COL_NAME].start + nameoffset, ypos, g_Columns[COL_NAME].start + 350, pl_info->name, r, g, b );

		if( cl_showplayerversion->value == 0.0f )
		{
			if( team && stricmp( team, "SPECTATOR" ))
			{
				// draw bomb( if player have the bomb )
				if( g_PlayerExtraInfo[best_player].dead )
					DrawUtils::DrawHudStringReverse( g_Columns[COL_ATTRIB].start, ypos, g_Columns[COL_ATTRIB].end, Localize( "#Cstrike_DEAD" ), r, g, b );
				else if( g_PlayerExtraInfo[best_player].has_c4 )
					DrawUtils::DrawHudStringReverse( g_Columns[COL_ATTRIB].start, ypos, g_Columns[COL_ATTRIB].end, Localize( "#Cstrike_BOMB" ), r, g, b );
				else if( g_PlayerExtraInfo[best_player].vip )
					DrawUtils::DrawHudStringReverse( g_Columns[COL_ATTRIB].start, ypos, g_Columns[COL_ATTRIB].end, Localize( "#Cstrike_VIP" ),  r, g, b );
				else if (g_PlayerExtraInfo[best_player].has_defuse_kit )
					DrawUtils::DrawHudStringReverse( g_Columns[COL_ATTRIB].start, ypos, g_Columns[COL_ATTRIB].end, Localize( "#Cstrike_DEFUSE_KIT" ),  r, g, b );
			}
		}
		else
		{
			DrawUtils::DrawHudStringReverse( g_Columns[COL_ATTRIB].start, ypos, g_Columns[COL_ATTRIB].end, gEngfuncs.PlayerInfo_ValueForKey( best_player, "cscl_ver" ),  r, g, b );
		}

		if ( g_PlayerExtraInfo[best_player].sb_health >= 0 && !g_PlayerExtraInfo[best_player].dead )
		{
			if ( gHUD.m_pShowHealth->value )
			{
				static char buf[64];
				sprintf( buf, "%d", g_PlayerExtraInfo[best_player].sb_health );
				DrawUtils::DrawHudStringReverse( g_Columns[COL_HP].start, ypos, g_Columns[COL_HP].end, buf, r, g, b );
			}
		}

		if ( g_PlayerExtraInfo[best_player].sb_account >= 0 )
		{
			if ( gHUD.m_pShowMoney->value )
			{
				static char buf[64];
				sprintf( buf, "$%d", g_PlayerExtraInfo[best_player].sb_account );
				DrawUtils::DrawHudStringReverse( g_Columns[COL_MONEY].start, ypos, g_Columns[COL_MONEY].end, buf, r, g, b );
			}
		}

		// draw kills (right to left)
		if( team && stricmp( team, "SPECTATOR" ) )
		{
			DrawUtils::DrawHudNumberString( g_Columns[COL_KILLS].start, ypos, g_Columns[COL_KILLS].end, g_PlayerExtraInfo[best_player].frags, r, g, b );

			// draw deaths
			DrawUtils::DrawHudNumberString( g_Columns[COL_DEATHS].start, ypos, g_Columns[COL_DEATHS].end, g_PlayerExtraInfo[best_player].deaths, r, g, b );
		}

		// draw ping & packetloss
		const char *value;
		if( pl_info->ping <= 5  // must be 0, until Xash's bug not fixed
			&& ( value = gEngfuncs.PlayerInfo_ValueForKey( best_player, "*bot" ) )
			&& atoi( value ) > 0 )
		{
			DrawUtils::DrawHudStringReverse( g_Columns[COL_PING].start, ypos, g_Columns[COL_PING].end, "BOT", r, g, b );
		}
		else
		{
			static char buf[64];
			sprintf( buf, "%d", pl_info->ping );
			DrawUtils::DrawHudStringReverse( g_Columns[COL_PING].start, ypos, g_Columns[COL_PING].end, buf, r, g, b );
		}

		pl_info->name = NULL;  // set the name to be NULL, so this client won't get drawn again
		list_slot++;
	}

	list_slot += 2.0f;

	return list_slot;
}


void CHudScoreboard :: GetAllPlayersInfo( void )
{
	for ( int i = 1; i < MAX_PLAYERS; i++ )
	{
		GetPlayerInfo( i, &g_PlayerInfoList[i] );

		if ( g_PlayerInfoList[i].thisplayer )
			m_iPlayerNum = i;  // !!!HACK: this should be initialized elsewhere... maybe gotten from the engine
	}
}

int CHudScoreboard :: MsgFunc_ScoreInfo( const char *pszName, int iSize, void *pbuf )
{
	m_iFlags |= HUD_DRAW;

	BufferReader reader( pszName, pbuf, iSize );
	short cl = reader.ReadByte();
	short frags = reader.ReadShort();
	short deaths = reader.ReadShort();
	short playerclass = reader.ReadShort();
	short teamnumber = reader.ReadShort();

	if ( cl > 0 && cl <= MAX_PLAYERS )
	{
		g_PlayerExtraInfo[cl].frags = frags;
		g_PlayerExtraInfo[cl].deaths = deaths;
		g_PlayerExtraInfo[cl].playerclass = playerclass;
		g_PlayerExtraInfo[cl].teamnumber = teamnumber;

		//gViewPort->UpdateOnPlayerInfo();
	}

	return 1;
}

// Message handler for TeamInfo message
// accepts two values:
//		byte: client number
//		string: client team name
int CHudScoreboard :: MsgFunc_TeamInfo( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	short cl = reader.ReadByte();
	int teamNumber = 0;

	if ( cl > 0 && cl <= MAX_PLAYERS )
	{
		// set the players team
		char teamName[MAX_TEAM_NAME];
		strncpy( teamName, reader.ReadString(), MAX_TEAM_NAME );
		teamName[MAX_TEAM_NAME-1] = 0;

		if( !strcmp( teamName, "TERRORIST") )
			teamNumber = TEAM_TERRORIST;
		else if( !strcmp( teamName, "CT") )
			teamNumber = TEAM_CT;
		else if( !strcmp( teamName, "SPECTATOR" ) || !strcmp( teamName, "UNASSIGNED" ) )
		{
			teamNumber = TEAM_SPECTATOR;
			strncpy( teamName, "SPECTATOR", MAX_TEAM_NAME );
		}
		// just in case
		else teamNumber = TEAM_UNASSIGNED;

		strncpy( g_PlayerExtraInfo[cl].teamname, teamName, MAX_TEAM_NAME );
		g_PlayerExtraInfo[cl].teamnumber = teamNumber;
	}

	// rebuild the list of teams

	// clear out player counts from teams
	for ( int i = 1; i <= m_iNumTeams; i++ )
	{
		g_TeamInfo[i].players = 0;
	}

	// rebuild the team list
	GetAllPlayersInfo();
	m_iNumTeams = 0;

	for ( int i = 1; i < MAX_PLAYERS; i++ )
	{
		int j;
		//if ( g_PlayerInfoList[i].name == NULL )
		//	continue;

		if ( g_PlayerExtraInfo[i].teamname[0] == 0 )
			continue; // skip over players who are not in a team

		// is this player in an existing team?
		for ( j = 1; j <= m_iNumTeams; j++ )
		{
			if ( g_TeamInfo[j].name[0] == '\0' )
				break;

			if ( !stricmp( g_PlayerExtraInfo[i].teamname, g_TeamInfo[j].name ) )
				break;
		}

		if ( j > m_iNumTeams )
		{
			// they aren't in a listed team, so make a new one
			for ( j = 1; j <= m_iNumTeams; j++ )
			{
				if ( g_TeamInfo[j].name[0] == '\0' )
					break;
			}


			m_iNumTeams = max( j, m_iNumTeams );

			strncpy( g_TeamInfo[j].name, g_PlayerExtraInfo[i].teamname, MAX_TEAM_NAME );
			g_TeamInfo[j].teamnumber = g_PlayerExtraInfo[i].teamnumber;
			g_TeamInfo[j].players = 0;
		}

		g_TeamInfo[j].players++;
	}

	// clear out any empty teams
	for ( int i = 1; i <= m_iNumTeams; i++ )
	{
		if ( g_TeamInfo[i].players < 1 )
			memset( &g_TeamInfo[i], 0, sizeof(team_info_t) );
	}

	return 1;
}

// Message handler for TeamScore message
// accepts three values:
//		string: team name
//		short: teams kills
//		short: teams deaths
// if this message is never received, then scores will simply be the combined totals of the players.
int CHudScoreboard :: MsgFunc_TeamScore( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	char *TeamName = reader.ReadString();
	int i;

	// find the team matching the name
	for ( i = 0; i < m_iNumTeams; i++ )
	{
		if ( !stricmp( TeamName, g_TeamInfo[i].name ) )
			break;
	}
	if ( i > m_iNumTeams )
	{
		reader.Flush();
		return 1;
	}

	// use this new score data instead of combined player scores
	g_TeamInfo[i].scores_overriden = TRUE;
	g_TeamInfo[i].frags = reader.ReadShort();
	// g_TeamInfo[i].deaths = reader.ReadShort();

	return 1;
}

void CHudScoreboard :: DeathMsg( int killer, int victim )
{
	// if we were the one killed,  or the world killed us, set the scoreboard to indicate suicide
	if ( victim == m_iPlayerNum || killer == 0 )
	{
		m_iLastKilledBy = killer ? killer : m_iPlayerNum;
		m_fLastKillTime = gHUD.m_flTime + 10;	// display who we were killed by for 10 seconds

		if ( killer == m_iPlayerNum )
			m_iLastKilledBy = m_iPlayerNum;
	}
}



void CHudScoreboard :: UserCmd_ShowScores( void )
{
	m_bForceDraw = false;
	m_bShowscoresHeld = true;
}

void CHudScoreboard :: UserCmd_HideScores( void )
{
	m_bForceDraw = m_bShowscoresHeld = false;
}


void CHudScoreboard	:: UserCmd_ShowScoreboard2()
{
	if( gEngfuncs.Cmd_Argc() != 9 )
	{
		ConsolePrint("showscoreboard2 <xstart> <xend> <ystart> <yend> <r> <g> <b> <a>");
	}

	xstart     = atof(gEngfuncs.Cmd_Argv(1)) * ScreenWidth;
	xend       = atof(gEngfuncs.Cmd_Argv(2)) * ScreenWidth;
	ystart     = atof(gEngfuncs.Cmd_Argv(3)) * ScreenHeight;
	yend       = atof(gEngfuncs.Cmd_Argv(4)) * ScreenHeight;
	m_colors.r = atoi(gEngfuncs.Cmd_Argv(5));
	m_colors.b = atoi(gEngfuncs.Cmd_Argv(6));
	m_colors.b = atoi(gEngfuncs.Cmd_Argv(7));
	m_colors.a = atoi(gEngfuncs.Cmd_Argv(8));
	m_bDrawStroke = false;
	m_bForceDraw = true;
}

void CHudScoreboard :: UserCmd_HideScoreboard2()
{
	m_bForceDraw = m_bShowscoresHeld = false; // and disable it
}

```

`cl_dll/hud/sniperscope.cpp`:

```cpp
/*
hud_overlays.cpp - HUD Overlays
Copyright (C) 2015-2016 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.

*/

#include "hud.h"
#include "triangleapi.h"
#include "r_efx.h"
#include "cl_util.h"

#include "draw_util.h"

int CHudSniperScope::Init()
{
	if( g_iXash )
		gHUD.AddHudElem(this);

	m_iFlags = HUD_DRAW;
	m_iScopeArc[0] = m_iScopeArc[1] =m_iScopeArc[2] = m_iScopeArc[3]  = 0;
	return 1;
}

int CHudSniperScope::VidInit()
{
	if( g_iXash == 0 )
	{
		ConsolePrint("^3No Xash Found Warning^7: CHudSniperScope is disabled!\n");
		m_iFlags = 0;
		return 0;
	}

	m_iScopeArc[0] = gRenderAPI.GL_LoadTexture("sprites/scope_arc_nw.tga", NULL, 0, TF_NEAREST|TF_NOMIPMAP|TF_CLAMP);
	m_iScopeArc[1] = gRenderAPI.GL_LoadTexture("sprites/scope_arc_ne.tga", NULL, 0, TF_NEAREST|TF_NOMIPMAP|TF_CLAMP);
	m_iScopeArc[2] = gRenderAPI.GL_LoadTexture("sprites/scope_arc.tga",    NULL, 0, TF_NEAREST|TF_NOMIPMAP|TF_CLAMP);
	m_iScopeArc[3] = gRenderAPI.GL_LoadTexture("sprites/scope_arc_sw.tga", NULL, 0, TF_NEAREST|TF_NOMIPMAP|TF_CLAMP);

	if( !m_iScopeArc[0] || !m_iScopeArc[1] || !m_iScopeArc[2] || !m_iScopeArc[3] )
	{
		gRenderAPI.Host_Error( "^3Error^7: Cannot load Sniper Scope arcs. Check sprites/scope_arc*.tga files\n" );
	}
	
	left = (TrueWidth - TrueHeight)/2.0;
	right = left + TrueHeight;
	centerx = TrueWidth/2.0;
	centery = TrueHeight/2.0;
	return 1;
}

inline void DrawTexture( int tex, float x1, float y1, float x2, float y2 )
{
	gRenderAPI.GL_Bind( 0, tex );
	//gEngfuncs.pTriAPI->Begin( TRI_QUADS );
	DrawUtils::Draw2DQuad( x1, y1, x2, y2 );
	//gEngfuncs.pTriAPI->End();
}

int CHudSniperScope::Draw(float flTime)
{
	if(gHUD.m_iFOV > 40)
		return 1;

	gEngfuncs.pTriAPI->RenderMode(kRenderTransColor);
	gEngfuncs.pTriAPI->Brightness(1.0);
	gEngfuncs.pTriAPI->Color4ub(0, 0, 0, 255);
	gEngfuncs.pTriAPI->CullFace(TRI_NONE);

	gRenderAPI.GL_SelectTexture(0);

	DrawTexture( m_iScopeArc[0], left, 0, centerx, centery );
	DrawTexture( m_iScopeArc[1], centerx, 0, right, centery );
	DrawTexture( m_iScopeArc[2], centerx, centery, right, TrueHeight );
	DrawTexture( m_iScopeArc[3], left, centery, centerx, TrueHeight );

	gRenderAPI.GL_Bind( 0, gHUD.m_WhiteTex );
	// gEngfuncs.pTriAPI->Begin( TRI_QUADS );
		DrawUtils::Draw2DQuad( 0, 0, left + 2, TrueHeight );
		DrawUtils::Draw2DQuad( right, 0, right + ( TrueWidth - right ), TrueHeight );
	
	// default crosshair pixel perfect lines
		DrawUtils::Draw2DQuad( left, centery + 1, right, centery + 2 );
		DrawUtils::Draw2DQuad( centerx - 1, 0, centerx, TrueHeight );
	// gEngfuncs.pTriAPI->End();

	return 0;
}

void CHudSniperScope::Shutdown()
{
	for( int i = 0; i < 4; i++ )
		gRenderAPI.GL_FreeTexture( m_iScopeArc[i] );
}

```

`cl_dll/hud/spectator_gui.cpp`:

```cpp
/*
spectator_gui.cpp - HUD Overlays
Copyright (C) 2015 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/

#include <string.h>

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include "vgui_parser.h"
#include "triangleapi.h"
#include "draw_util.h"

/*
 * We will draw all elements inside a box. It's size 16x10.
 */

#define XPOS( x ) ( (x) / 16.0f )
#define YPOS( y ) ( (y) / 10.0f  )

#define INT_XPOS(x) int(XPOS(x) * ScreenWidth)
#define INT_YPOS(y) int(YPOS(y) * ScreenHeight)

int CHudSpectatorGui::Init()
{
	if( !g_iXash )
		return 1;

	HOOK_MESSAGE( gHUD.m_SpectatorGui, SpecHealth );
	HOOK_MESSAGE( gHUD.m_SpectatorGui, SpecHealth2 );

	HOOK_COMMAND( gHUD.m_SpectatorGui, "_spec_toggle_menu", ToggleSpectatorMenu );
	HOOK_COMMAND( gHUD.m_SpectatorGui, "_spec_toggle_menu_options", ToggleSpectatorMenuOptions );
	// close
	// help
	// settings
	// pip
	// autodirector
	// showscores

	HOOK_COMMAND( gHUD.m_SpectatorGui, "_spec_toggle_menu_options_settings", ToggleSpectatorMenuOptionsSettings );
	// settings
	// // chat msgs
	// // show status
	// // view cone
	// // player names

	HOOK_COMMAND( gHUD.m_SpectatorGui, "_spec_toggle_menu_spectate_options", ToggleSpectatorMenuSpectateOptions );
	// chase map overview
	// free map overview
	// first person
	// free look
	// free chase camera
	// locked chase camera

	HOOK_COMMAND_FUNC( "_spec_find_next_player_reverse", gHUD.m_Spectator.FindNextPlayer, true );
	HOOK_COMMAND_FUNC( "_spec_find_next_player", gHUD.m_Spectator.FindNextPlayer, false );

	gHUD.AddHudElem(this);
	m_iFlags = HUD_DRAW;
	m_menuFlags = 0;
	m_hTimerTexture = 0;
	return 1;
}

int CHudSpectatorGui::VidInit()
{
	if( !g_iXash )
	{
		ConsolePrint("Warning: CHudSpectatorGui is disabled! Dude, are you running me on old GoldSrc?\n");
		m_iFlags = 0;
		return 0;
	}

	m_hTimerTexture = gRenderAPI.GL_LoadTexture("gfx/vgui/timer.tga", NULL, 0, TF_NEAREST |TF_NOMIPMAP|TF_CLAMP );
	m_hChecked     = gRenderAPI.GL_LoadTexture("gfx/vgui/640_checked.tga", NULL, 0, TF_NEAREST | TF_NOMIPMAP | TF_CLAMP );
	m_hArrowDown   = gRenderAPI.GL_LoadTexture("gfx/vgui/1920_arrowdown.tga", NULL, 0, TF_NEAREST | TF_NOMIPMAP | TF_CLAMP );
	m_hArrowUp     = gRenderAPI.GL_LoadTexture("gfx/vgui/1920_arrowup.tga", NULL, 0, TF_NEAREST | TF_NOMIPMAP | TF_CLAMP );
	m_hArrowLeft   = gRenderAPI.GL_LoadTexture("gfx/vgui/1920_arrowleft.tga", NULL, 0, TF_NEAREST | TF_NOMIPMAP | TF_CLAMP );
	m_hArrowRight  = gRenderAPI.GL_LoadTexture("gfx/vgui/1920_arrowright.tga", NULL, 0, TF_NEAREST | TF_NOMIPMAP | TF_CLAMP );
	return 1;
}

void CHudSpectatorGui::Shutdown()
{
	gRenderAPI.GL_FreeTexture( m_hTimerTexture );
	gRenderAPI.GL_FreeTexture( m_hChecked );
	gRenderAPI.GL_FreeTexture( m_hArrowDown );
	gRenderAPI.GL_FreeTexture( m_hArrowUp );
	gRenderAPI.GL_FreeTexture( m_hArrowLeft );
	gRenderAPI.GL_FreeTexture( m_hArrowRight );
}

inline void DrawButtonWithText( int x1, int y1, int wide, int tall, const char *sz, int r, int g, int b, bool highlight = false )
{
	DrawUtils::DrawRectangle(x1, y1, wide, tall);

	if ( highlight )
	{
		FillRGBABlend(x1, y1, wide, tall, r, g, b, 48);
	}

	DrawUtils::DrawHudString(x1 + INT_XPOS(0.5), y1 + tall*0.5 - gHUD.GetCharHeight() * 0.5, x1 + wide, sz,
							 r, g, b );
}

// Unified icon drawing helper. align: -1 = left, 0 = center, 1 = right
static void DrawIconOnButton( int x1, int y1, int wide, int tall, int hTex, int align = -1, int r = 255, int g = 255, int b = 255, float alpha = 1.0f, int pad = 15 )
{
	if( !hTex )
		return;

	gRenderAPI.GL_SelectTexture( 0 );
	gRenderAPI.GL_Bind( 0, hTex );
	gEngfuncs.pTriAPI->RenderMode( kRenderTransAlpha );
	gEngfuncs.pTriAPI->Color4f( r / 255.0f, g / 255.0f, b / 255.0f, alpha );

	int uploadW = (int)gRenderAPI.RenderGetParm( PARM_TEX_WIDTH, hTex );
	int uploadH = (int)gRenderAPI.RenderGetParm( PARM_TEX_HEIGHT, hTex );


	// compute quad position in pixels
	float quadX = x1;
	float quadY = y1 + ( tall - uploadH ) / 2.0f;

	if( align == -1 ) // left
		quadX = x1 + pad; // small padding from left
	else if( align == 0 ) // center
		quadX = x1 + ( wide - uploadW ) * 0.5f;
	else if( align == 1 ) // right
		quadX = x1 + wide - uploadW - pad; // small padding from right

	DrawUtils::Draw2DQuad( quadX * gHUD.m_flScale,
						   quadY * gHUD.m_flScale,
						   (quadX + (float)uploadW) * gHUD.m_flScale,
						   (quadY + (float)uploadH) * gHUD.m_flScale );
}

int CHudSpectatorGui::Draw( float flTime )
{
	if( !g_iUser1 )
	{
		if( m_menuFlags & ROOT_MENU )
		{
			UserCmd_ToggleSpectatorMenu(); // this will remove any submenus;
			m_menuFlags = 0;
		}
		return 1;
	}

	// function name says it
	CalcAllNeededData( );

	int r = 255, g = 140, b = 0;

	// at first, draw these silly black bars
	int startpos = 0;
	if( gHUD.m_Spectator.m_pip->value != INSET_OFF ) // pip adjust
	{
		startpos = XRES(gHUD.m_Spectator.m_OverviewData.insetWindowWidth) + XRES(gHUD.m_Spectator.m_OverviewData.insetWindowX);
		startpos *= ScreenWidth / TrueWidth; // hud_scale adjust
	}
	FillRGBABlend(startpos, 0, ScreenWidth - startpos, INT_YPOS(2), 0, 0, 0, 153);
	FillRGBABlend(0, ScreenHeight - INT_YPOS(2), ScreenWidth, INT_YPOS(2), 0, 0, 0, 153);

	if ( gHUD.m_Spectator.m_drawstatus && gHUD.m_Spectator.m_drawstatus->value )
	{
		// divider
		{
			int divX = INT_XPOS(12.5);
			int divTop = INT_YPOS(2) * 0.25;
			int divBottom = INT_YPOS(2) * 0.5 + gHUD.GetCharHeight();
			int divH = divBottom - divTop;
			if (divH < gHUD.GetCharHeight()) divH = gHUD.GetCharHeight();

			int pad = (gHUD.GetCharHeight() * 2) / 3;
			if (pad < 1) pad = 1;

			int drawTop = divTop - pad;
			if (drawTop < 0) drawTop = 0;
			int drawH = divH + pad * 2;
			if (drawTop + drawH > ScreenHeight) drawH = ScreenHeight - drawTop;

			FillRGBABlend(divX, drawTop, 1, drawH, r, g, b, 255);
		}

		{ // mapname. extradata
			DrawUtils::DrawHudString( INT_XPOS(12.5) + 10, INT_YPOS(2) * 0.25, ScreenWidth, label.m_szMap, r, g, b );

			if( !m_bBombPlanted ) // timer remaining
			{
				if( m_hTimerTexture )
				{
					gRenderAPI.GL_SelectTexture( 0 );
					gRenderAPI.GL_Bind(0, m_hTimerTexture);
					gEngfuncs.pTriAPI->RenderMode( kRenderTransAlpha );
					gEngfuncs.pTriAPI->Color4f( 1.0f, 1.0f, 1.0f, 1.0f );

					float quadX = INT_XPOS(12.5) + 10;
					float quadY = INT_YPOS(2) * 0.5f;
					int uploadW = (int)gRenderAPI.RenderGetParm( PARM_TEX_WIDTH, m_hTimerTexture );
					int uploadH = (int)gRenderAPI.RenderGetParm( PARM_TEX_HEIGHT, m_hTimerTexture );

					// gEngfuncs.pTriAPI->Begin( TRI_QUADS );
					DrawUtils::Draw2DQuad( quadX * gHUD.m_flScale,
										quadY * gHUD.m_flScale,
										(quadX + (float)uploadW) * gHUD.m_flScale,
										(quadY + (float)uploadH) * gHUD.m_flScale );
					// gEngfuncs.pTriAPI->End();
				}
				DrawUtils::DrawHudString( INT_XPOS(12.5) + gHUD.GetCharHeight() * 1.5 + gHUD.GetCharWidth('M') , INT_YPOS(2) * 0.5, ScreenWidth,
										label.m_szTimer, r, g, b );
			}
		}


		{ // draw team here
			int iLen = DrawUtils::HudStringLen("Counter-Terrorists:" );

			DrawUtils::DrawHudString( INT_XPOS(12.5) - iLen - 50 , INT_YPOS(2) * 0.25, INT_XPOS(12.5) - 50, "Counter-Terrorists:", r, g, b );
			DrawUtils::DrawHudString( INT_XPOS(12.5) - iLen - 50, INT_YPOS(2) * 0.5, INT_XPOS(12.5) - 50, "Terrorists:", r, g, b );
			// count
			DrawUtils::DrawHudNumberString( INT_XPOS(12.5) - 10, INT_YPOS(2) * 0.25, INT_XPOS(12.5) - 50, label.m_iCounterTerrorists, r, g, b );
			DrawUtils::DrawHudNumberString( INT_XPOS(12.5) - 10, INT_YPOS(2) * 0.5,  INT_XPOS(12.5) - 50, label.m_iTerrorists,        r, g, b );
		}
	}

	if( m_menuFlags & ROOT_MENU )
	{
		// draw the root menu

		// options
		{
			// highlight when opened
			if( m_menuFlags & MENU_OPTIONS )
				DrawButtonWithText(INT_XPOS(0.5),  INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1), "Options", r, g, b, true);
			else
				DrawButtonWithText(INT_XPOS(0.5),  INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1), "Options", r, g, b );
			// arrow on right part of button: down when closed, up when open
			if( m_menuFlags & MENU_OPTIONS )
				DrawIconOnButton( INT_XPOS(0.5), INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1), m_hArrowUp, 1, r, g, b );
			else
				DrawIconOnButton( INT_XPOS(0.5), INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1), m_hArrowDown, 1, r, g, b );
		}

		DrawUtils::DrawRectangle(INT_XPOS(5), INT_YPOS(8.5), INT_XPOS(1), INT_YPOS(1));
		DrawIconOnButton( INT_XPOS(5), INT_YPOS(8.5), INT_XPOS(1), INT_YPOS(1), m_hArrowLeft, 0, r, g, b );

		DrawUtils::DrawRectangle(INT_XPOS(6), INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1));
		// name will be drawn later

		DrawUtils::DrawRectangle(INT_XPOS(10), INT_YPOS(8.5), INT_XPOS(1), INT_YPOS(1));
		DrawIconOnButton( INT_XPOS(10), INT_YPOS(8.5), INT_XPOS(1), INT_YPOS(1), m_hArrowRight, 0, r, g, b );

		// spectate options
		{
			// highlight when opened
			if( m_menuFlags & MENU_SPEC_OPTIONS )
				DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1), "Spectate Options", r, g, b, true);
			else
				DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1), "Spectate Options", r, g, b );
			// arrow on right part of button: down when closed, up when open
			if( m_menuFlags & MENU_SPEC_OPTIONS )
				DrawIconOnButton( INT_XPOS(11.5), INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1), m_hArrowUp, 1, r, g, b );
			else
				DrawIconOnButton( INT_XPOS(11.5), INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1), m_hArrowDown, 1, r, g, b );
		}

		if( m_menuFlags & MENU_OPTIONS )
		{
			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(2.5), INT_XPOS(4), INT_YPOS(1), "Close", r, g, b );
			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(3.5), INT_XPOS(4), INT_YPOS(1), "Help", r, g, b );
			
			// settings
			{
				// highlight when opened
				if( m_menuFlags & MENU_OPTIONS_SETTINGS )
					DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(4.5), INT_XPOS(4), INT_YPOS(1), "Settings", r, g, b, true );
				else
					DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(4.5), INT_XPOS(4), INT_YPOS(1), "Settings", r, g, b );

				DrawIconOnButton( INT_XPOS(0.5), INT_YPOS(4.5), INT_XPOS(4), INT_YPOS(1), m_hArrowRight, 1, r, g, b );
			}

			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(5.5), INT_XPOS(4), INT_YPOS(1), "Picture-in-Picture", r, g, b );
			if( gHUD.m_Spectator.m_pip && gHUD.m_Spectator.m_pip->value != INSET_OFF )
				DrawIconOnButton( INT_XPOS(0.5), INT_YPOS(5.5), INT_XPOS(4), INT_YPOS(1), m_hChecked, -1, r, g, b );

			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(6.5), INT_XPOS(4), INT_YPOS(1), "Autodirector", r, g, b );
			if( gHUD.m_Spectator.m_autoDirector && gHUD.m_Spectator.m_autoDirector->value )
				DrawIconOnButton( INT_XPOS(0.5), INT_YPOS(6.5), INT_XPOS(4), INT_YPOS(1), m_hChecked, -1, r, g, b );

			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(7.5), INT_XPOS(4), INT_YPOS(1), "Show scores", r, g, b );
			if( gHUD.m_Scoreboard.m_bForceDraw || gHUD.m_Scoreboard.m_bShowscoresHeld )
				DrawIconOnButton( INT_XPOS(0.5), INT_YPOS(7.5), INT_XPOS(4), INT_YPOS(1), m_hChecked, -1, r, g, b );

			if( m_menuFlags & MENU_OPTIONS_SETTINGS )
			{
				DrawButtonWithText(INT_XPOS(4.5), INT_YPOS(4.5), INT_XPOS(4), INT_YPOS(1), "Chat messages", r, g, b );
				if( gHUD.m_Spectator.m_HUD_saytext && gHUD.m_Spectator.m_HUD_saytext->value )
					DrawIconOnButton( INT_XPOS(4.5), INT_YPOS(4.5), INT_XPOS(4), INT_YPOS(1), m_hChecked, -1, r, g, b );

				DrawButtonWithText(INT_XPOS(4.5), INT_YPOS(5.5), INT_XPOS(4), INT_YPOS(1), "Show status", r, g, b );
				if( gHUD.m_Spectator.m_drawstatus && gHUD.m_Spectator.m_drawstatus->value )
					DrawIconOnButton( INT_XPOS(4.5), INT_YPOS(5.5), INT_XPOS(4), INT_YPOS(1), m_hChecked, -1, r, g, b );

				DrawButtonWithText(INT_XPOS(4.5), INT_YPOS(6.5), INT_XPOS(4), INT_YPOS(1), "View cone", r, g, b );
				if( gHUD.m_Spectator.m_drawcone && gHUD.m_Spectator.m_drawcone->value )
					DrawIconOnButton( INT_XPOS(4.5), INT_YPOS(6.5), INT_XPOS(4), INT_YPOS(1), m_hChecked, -1, r, g, b );

				DrawButtonWithText(INT_XPOS(4.5), INT_YPOS(7.5), INT_XPOS(4), INT_YPOS(1), "Player names", r, g, b );
				if( gHUD.m_Spectator.m_drawnames && gHUD.m_Spectator.m_drawnames->value )
					DrawIconOnButton( INT_XPOS(4.5), INT_YPOS(7.5), INT_XPOS(4), INT_YPOS(1), m_hChecked, -1, r, g, b );
			}
		}

		if( m_menuFlags & MENU_SPEC_OPTIONS )
		{
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(2.5), INT_XPOS(4), INT_YPOS(1), "Chase Map Overview", r, g, b );
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(3.5), INT_XPOS(4), INT_YPOS(1), "Free Map Overview", r, g, b );
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(4.5), INT_XPOS(4), INT_YPOS(1), "First Person", r, g, b );
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(5.5), INT_XPOS(4), INT_YPOS(1), "Free look", r, g, b );
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(6.5), INT_XPOS(4), INT_YPOS(1), "Free Chase Camera", r, g, b );
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(7.5), INT_XPOS(4), INT_YPOS(1), "Locked Chase Camera", r, g, b );
		}
	}

	//if( !label.m_szNameAndHealth[0] )
	//{
		int iLen = DrawUtils::HudStringLen( label.m_szNameAndHealth );
		GetTeamColor( r, g, b, g_PlayerExtraInfo[ g_iUser2 ].teamnumber );
		DrawUtils::DrawHudString( ScreenWidth * 0.5 - iLen * 0.5, INT_YPOS(9) - gHUD.GetCharHeight() * 0.5 , ScreenWidth,
								  label.m_szNameAndHealth, r, g, b );
	//}

	return 1;
}

void CHudSpectatorGui::CalcAllNeededData( )
{
	// mapname
	if( !label.m_szMap[0] )
	{
		static char szMapNameStripped[55];
		const char *szMapName = gEngfuncs.pfnGetLevelName(); //  "maps/%s.bsp"
		strncpy( szMapNameStripped, szMapName + 5, sizeof( szMapNameStripped ) );
		szMapNameStripped[strlen(szMapNameStripped) - 4] = '\0';
		snprintf( label.m_szMap, sizeof( label.m_szMap ), "Map: %s", szMapNameStripped );
	}

	// team
	/*label.m_iTerrorists        = 0;
	label.m_iCounterTerrorists = 0;
	for( int i = 0; i < MAX_PLAYERS; i++ )
	{
		if( g_PlayerExtraInfo[i].dead )
			continue; // show remaining

		switch( g_PlayerExtraInfo[i].teamnumber )
		{
		case TEAM_CT:
			label.m_iCounterTerrorists++;
		case TEAM_TERRORIST:
			label.m_iTerrorists++;
		}
	}*/

	label.m_iCounterTerrorists = 0;
	label.m_iTerrorists = 0;
	for( int i = 1; i <= gHUD.m_Scoreboard.m_iNumTeams; i++ )
	{
		switch( g_TeamInfo[i].teamnumber )
		{
		case TEAM_CT:
			label.m_iCounterTerrorists = g_TeamInfo[i].frags;
			break;
		case TEAM_TERRORIST:
			label.m_iTerrorists = g_TeamInfo[i].frags;
			break;
		}
	}

	// timer
	// time must be positive
	if( !m_bBombPlanted )
	{
		int iMinutes = max( 0, (int)( gHUD.m_Timer.m_iTime + gHUD.m_Timer.m_fStartTime - gHUD.m_flTime ) / 60);
		int iSeconds = max( 0, (int)( gHUD.m_Timer.m_iTime + gHUD.m_Timer.m_fStartTime - gHUD.m_flTime ) - (iMinutes * 60));

		sprintf( label.m_szTimer, "%i:%02i", iMinutes, iSeconds );
	}

	// player name
	if( g_iUser2 > 0 && g_iUser2 < MAX_PLAYERS )
	{
		hud_player_info_t sInfo;
		GetPlayerInfo( g_iUser2, &sInfo );

		snprintf( label.m_szNameAndHealth, sizeof( label.m_szNameAndHealth ),
				  "%s (%i)",  sInfo.name, g_PlayerExtraInfo[g_iUser2].health );
	}
	else label.m_szNameAndHealth[0] = '\0';
}

void CHudSpectatorGui::InitHUDData()
{
	m_bBombPlanted = false;
	label.m_szMap[0] = '\0';
}

void CHudSpectatorGui::Reset()
{
	m_bBombPlanted = false;
	if( m_menuFlags & ROOT_MENU )
	{
		UserCmd_ToggleSpectatorMenu(); // this will remove any submenus;
		m_menuFlags = 0;
	}
}

int CHudSpectatorGui::MsgFunc_SpecHealth(const char *pszName, int iSize, void *buf)
{
	BufferReader reader( pszName, buf, iSize );

	int health = reader.ReadByte();

	g_PlayerExtraInfo[g_iUser2].health = health;
	gHUD.m_Health.m_iPlayerLastPointedAt = g_iUser2;

	return 1;
}

int CHudSpectatorGui::MsgFunc_SpecHealth2(const char *pszName, int iSize, void *buf)
{
	BufferReader reader( pszName, buf, iSize );

	int health = reader.ReadByte();
	int client = reader.ReadByte();

	g_PlayerExtraInfo[client].health = health;
	gHUD.m_Health.m_iPlayerLastPointedAt = g_iUser2;

	return 1;
}

#define PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y(x, y) XPOS(x), YPOS(y), XPOS(x + 4.0f), YPOS(y + 1.0f)

void CHudSpectatorGui::UserCmd_ToggleSpectatorMenu()
{
	static byte color[4] = {0, 0, 0, 0};

	if( !g_iMobileAPIVersion )
		return;

	gMobileAPI.pfnTouchSetClientOnly( !(m_menuFlags & ROOT_MENU) );

	if( !(m_menuFlags & ROOT_MENU) )
	{
		m_menuFlags |= ROOT_MENU;

		gMobileAPI.pfnTouchAddClientButton( "_spec_menu_options", "*white", "_spec_toggle_menu_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 8.5f ), color, 0, 1.0f, 0 );

		gMobileAPI.pfnTouchAddClientButton( "_spec_menu_find_next_player_reverse", "*white", "_spec_find_next_player_reverse",
			XPOS(5.0f), YPOS(8.5f), XPOS(6.0f), YPOS(9.5f), color, 0, 1.0f, 0 );

		gMobileAPI.pfnTouchAddClientButton( "_spec_menu_find_next_player", "*white", "_spec_find_next_player",
			XPOS(10.0f),YPOS(8.5f), XPOS(11.0f),YPOS(9.5f), color, 0, 1.0f, 0 );

		gMobileAPI.pfnTouchAddClientButton( "_spec_menu_spectate_options", "*white", "_spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 8.5f ),color, 0, 1.0f, 0 );
	}
	else
	{
		m_menuFlags &= ~ROOT_MENU;
		m_menuFlags &= ~MENU_OPTIONS;
		m_menuFlags &= ~MENU_OPTIONS_SETTINGS;
		m_menuFlags &= ~MENU_SPEC_OPTIONS;
		gMobileAPI.pfnTouchRemoveButton( "_spec_*" );
	}
}

void CHudSpectatorGui::UserCmd_ToggleSpectatorMenuOptions()
{
	static byte color[4] = {0, 0, 0, 0};

	if( !(m_menuFlags & ROOT_MENU) || !g_iMobileAPIVersion )
		return;

	if( !(m_menuFlags & MENU_OPTIONS) )
	{
		m_menuFlags |= MENU_OPTIONS;
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_close", "*white", "_spec_toggle_menu",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 2.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_help", "*white", "spec_help; _spec_toggle_menu_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 3.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_settings", "*white", "_spec_toggle_menu_options_settings",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 4.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_pip", "*white", "spec_pip t; _spec_toggle_menu_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 5.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_ad", "*white", "spec_autodirector t; _spec_toggle_menu_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 6.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_showscores", "*white", "_spec_toggle_menu_options; scoreboard",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 7.5f ), color, 0, 1.0f, 0 );
	}
	else
	{
		m_menuFlags &= ~MENU_OPTIONS;
		m_menuFlags &= ~MENU_OPTIONS_SETTINGS;
		gMobileAPI.pfnTouchRemoveButton( "_spec_opt_*" );
	}
}

void CHudSpectatorGui::UserCmd_ToggleSpectatorMenuOptionsSettings()
{
	static byte color[4] = {0, 0, 0, 0};

	if( !(m_menuFlags & ROOT_MENU) || !g_iMobileAPIVersion )
		return;

	if( !(m_menuFlags & MENU_OPTIONS_SETTINGS) )
	{
		m_menuFlags |= MENU_OPTIONS_SETTINGS;
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_chat_msgs", "*white", "hud_saytext t; _spec_toggle_menu_options_settings",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 4.5f, 4.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_set_status", "*white", "spec_drawstatus t; _spec_toggle_menu_options_settings",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 4.5f, 5.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_draw_cones", "*white", "spec_drawcone t; _spec_toggle_menu_options_settings",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 4.5f, 6.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_draw_names", "*white", "spec_drawnames t; _spec_toggle_menu_options_settings",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 4.5f, 7.5f ), color, 0, 1.0f, 0 );
	}
	else
	{
		m_menuFlags &= ~MENU_OPTIONS_SETTINGS;
		gMobileAPI.pfnTouchRemoveButton( "_spec_opt_set_*" );
	}
}

void CHudSpectatorGui::UserCmd_ToggleSpectatorMenuSpectateOptions()
{
	static byte color[4] = {0, 0, 0, 0};

	if( !(m_menuFlags & ROOT_MENU) || !g_iMobileAPIVersion )
		return;

	if( !(m_menuFlags & MENU_SPEC_OPTIONS) )
	{
		m_menuFlags |= MENU_SPEC_OPTIONS;
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_6", "*white", "spec_mode 6; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 2.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_5", "*white", "spec_mode 5; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 3.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_4", "*white", "spec_mode 4; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 4.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_3", "*white", "spec_mode 3; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 5.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_2", "*white", "spec_mode 2; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 6.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_1", "*white", "spec_mode 1; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 7.5f ), color, 0, 1.0f, 0 );
	}
	else
	{
		m_menuFlags &= ~MENU_SPEC_OPTIONS;
		gMobileAPI.pfnTouchRemoveButton( "_spec_spec_*" );
	}
}

```

`cl_dll/hud/timer.cpp`:

```cpp
/*
timer.cpp -- HUD timer, progress bars, etc
Copyright (C) 2015-2016 a1batross
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/

#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "vgui_parser.h"
#include <string.h>
#include "draw_util.h"

int CHudTimer::Init()
{
	HOOK_MESSAGE( gHUD.m_Timer, RoundTime );
	HOOK_MESSAGE( gHUD.m_Timer, ShowTimer );
	m_iFlags = 0;
	m_bPanicColorChange = false;
	gHUD.AddHudElem(this);
	return 1;
}

int CHudTimer::VidInit()
{
	m_HUD_timer = gHUD.GetSpriteIndex( "stopwatch" );
	return 1;
}

int CHudTimer::Draw( float fTime )
{
	if ( ( gHUD.m_iHideHUDDisplay & HIDEHUD_HEALTH ) )
		return 1;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return 1;
	int r, g, b;
	// time must be positive
	int minutes = max( 0, (int)( m_iTime + m_fStartTime - gHUD.m_flTime ) / 60);
	int seconds = max( 0, (int)( m_iTime + m_fStartTime - gHUD.m_flTime ) - (minutes * 60));

	if( minutes * 60 + seconds > 20 )
	{
		DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
	}
	else
	{
		m_flPanicTime += gHUD.m_flTimeDelta;
		// add 0.1 sec, so it's not flicker fast
		if( m_flPanicTime > ((float)seconds / 40.0f) + 0.1f)
		{
			m_flPanicTime = 0;
			m_bPanicColorChange = !m_bPanicColorChange;
		}
		DrawUtils::UnpackRGB( r, g, b, m_bPanicColorChange ? gHUD.m_iDefaultHUDColor : RGB_REDISH );
	}

	DrawUtils::ScaleColors( r, g, b, MIN_ALPHA );

	int iWatchWidth = gHUD.GetSpriteRect(m_HUD_timer).Width();
	int iDigitWidth = gHUD.GetSpriteRect(gHUD.m_HUD_number_0).Width();
	int iColonWidth = iDigitWidth / 2;

	// Always reserve space for 2 digits for minutes to keep layout consistent
	int totalWidth = iWatchWidth + 2 * iDigitWidth + iColonWidth + 2 * iDigitWidth;

	int x = (ScreenWidth - totalWidth) / 2;
	int y = ScreenHeight - 1.5 * gHUD.m_iFontHeight;

	SPR_Set(gHUD.GetSprite(m_HUD_timer), r, g, b);
	SPR_DrawAdditive(0, x, y, &gHUD.GetSpriteRect(m_HUD_timer));
	x += iWatchWidth;

	if (minutes < 10)
		// Shift x to the right by one digit width to reserve space for the leading zero, then draw 1 digit without the leading zero
		x = DrawUtils::DrawHudNumber2(x + iDigitWidth, y, false, 1, minutes, r, g, b);
	else
		// Draw 2 digits, including the leading zero if needed
		x = DrawUtils::DrawHudNumber2(x, y, true, 2, minutes, r, g, b);

	// Draw colon (":")
	FillRGBA(x + iColonWidth / 2, y + gHUD.m_iFontHeight / 4, 2, 2, r, g, b, 100);
	FillRGBA(x + iColonWidth / 2, y + gHUD.m_iFontHeight - gHUD.m_iFontHeight / 4, 2, 2, r, g, b, 100);
	x += iColonWidth;

	m_right = DrawUtils::DrawHudNumber2(x, y, true, 2, seconds, r, g, b);

	return 1;
}

int CHudTimer::MsgFunc_RoundTime(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );
	m_iTime = reader.ReadShort();
	m_fStartTime = gHUD.m_flTime;
	m_iFlags = HUD_DRAW;
	return 1;
}

int CHudTimer::MsgFunc_ShowTimer(const char *pszName, int iSize, void *pbuf)
{
	m_iFlags = HUD_DRAW;
	return 1;
}

#define UPDATE_BOTPROGRESS 0
#define CREATE_BOTPROGRESS 1
#define REMOVE_BOTPROGRESS 2

int CHudProgressBar::Init()
{
	HOOK_MESSAGE( gHUD.m_ProgressBar, BarTime );
	HOOK_MESSAGE( gHUD.m_ProgressBar, BarTime2 );
	HOOK_MESSAGE( gHUD.m_ProgressBar, BotProgress );
	Reset( );
	gHUD.AddHudElem(this);
	return 1;
}

int CHudProgressBar::VidInit()
{
	return 1;
}

void CHudProgressBar::Reset( void )
{
	m_iFlags = 0;
	m_szLocalizedHeader = NULL;
	m_szHeader[0] = '\0';
	m_fStartTime = m_fPercent = 0.0f;
}

int CHudProgressBar::Draw( float flTime )
{
	// allow only 0.0..1.0
	if( (m_fPercent < 0.0f) || (m_fPercent > 1.0f) )
	{
		m_iFlags = 0;
		m_fPercent = 0.0f;
		return 1;
	}

	if( m_szLocalizedHeader && m_szLocalizedHeader[0] )
	{
		int r, g, b;
		DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
		DrawUtils::DrawHudString( ScreenWidth / 4, ScreenHeight / 2, ScreenWidth, (char*)m_szLocalizedHeader, r, g, b );

		DrawUtils::DrawRectangle( ScreenWidth/ 4, ScreenHeight / 2 + gHUD.GetCharHeight(), ScreenWidth/2, ScreenHeight/30 );
		FillRGBA( ScreenWidth/4+2, ScreenHeight/2 + gHUD.GetCharHeight() + 2, m_fPercent * (ScreenWidth/2-4), ScreenHeight/30-4, 255, 140, 0, 255 );
		return 1;
	}

	// prevent SIGFPE
	if( m_iDuration != 0.0f )
	{
		m_fPercent = ((flTime - m_fStartTime) / m_iDuration);
	}
	else
	{
		m_fPercent = 0.0f;
		m_iFlags = 0;
		return 1;
	}

	DrawUtils::DrawRectangle( ScreenWidth/4, ScreenHeight*2/3, ScreenWidth/2, 10 );
	FillRGBA( ScreenWidth/4+2, ScreenHeight*2/3+2, m_fPercent * (ScreenWidth/2-4), 6, 255, 140, 0, 255 );

	return 1;
}

int CHudProgressBar::MsgFunc_BarTime(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	m_iDuration = reader.ReadShort();
	m_fPercent = 0.0f;

	m_fStartTime = gHUD.m_flTime;

	m_iFlags = HUD_DRAW;
	return 1;
}

int CHudProgressBar::MsgFunc_BarTime2(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	m_iDuration = reader.ReadShort();
	m_fPercent = m_iDuration * (float)reader.ReadShort() / 100.0f;

	m_fStartTime = gHUD.m_flTime;

	m_iFlags = HUD_DRAW;
	return 1;
}

int CHudProgressBar::MsgFunc_BotProgress(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );
	m_iDuration = 0.0f; // don't update our progress bar
	m_iFlags = HUD_DRAW;

	float fNewPercent;
	int flag = reader.ReadByte();
	switch( flag )
	{
	case UPDATE_BOTPROGRESS:
	case CREATE_BOTPROGRESS:
		fNewPercent = (float)reader.ReadByte() / 100.0f;
		// cs behavior:
		// just don't decrease percent values
		if( m_fPercent < fNewPercent )
		{
			m_fPercent = fNewPercent;
		}
		strncpy(m_szHeader, reader.ReadString(), sizeof(m_szHeader));
		m_szHeader[sizeof(m_szHeader)-1] = 0;

		if( m_szHeader[0] == '#' )
			m_szLocalizedHeader = Localize(m_szHeader + 1);
		else
			m_szLocalizedHeader = m_szHeader;
		break;
	case REMOVE_BOTPROGRESS:
	default:
		m_fPercent = 0.0f;
		m_szHeader[0] = '\0';
		m_iFlags = 0;
		m_szLocalizedHeader = NULL;
		break;
	}

	return 1;
}

```

`cl_dll/hud_msg.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  hud_msg.cpp
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "r_efx.h"
#include "rain.h"
#include "com_model.h"
#include "studio.h"
#include "studio_util.h"
#include "StudioModelRenderer.h"
#include "GameStudioModelRenderer.h"
#include "com_weapons.h"

#include <cstring>

#include "events.h"

#define MAX_CLIENTS 32

extern float g_flRoundTime;

/// USER-DEFINED SERVER MESSAGE HANDLERS

int CHud :: MsgFunc_ResetHUD(const char *pszName, int iSize, void *pbuf )
{
	// clear all hud data
	HUDLIST *pList = m_pHudList;

	while ( pList )
	{
		if ( pList->p )
			pList->p->Reset();
		pList = pList->pNext;
	}

	// reset sensitivity
	m_flMouseSensitivity = 0;

	// reset concussion effect
	m_iConcussionEffect = 0;

	char szMapPrefix[64] = { 0 };
	char szMapName[64] = { 0 };
	const char *szFullMapName = gEngfuncs.pfnGetLevelName();
	if ( szFullMapName && szFullMapName[0] )
	{
		strncpy( szMapName, szFullMapName + 5, sizeof( szMapName ) );
		szMapName[strlen( szMapName ) - 4] = '\0';

		int i = 0;
		while ( szMapName[i] != '_' && szMapName[i] != '\0' && i < sizeof( szMapPrefix ) - 1 )
		{
			szMapPrefix[i] = szMapName[i];
			i++;
		}
		szMapPrefix[i] = '_';
		szMapPrefix[i + 1] = '\0';
	}
	gEngfuncs.Cvar_Set( gHUD.cscl_currentmap->name, szMapName );
	gEngfuncs.Cvar_Set( gHUD.cscl_mapprefix->name, szMapPrefix );

	// reinitialize models. We assume that server already precached all models.
	// NOTE: we're doing this in ResetHUD instead of InitHUD because it's not being
	// sent in demos, as it's not part of the signon packet and it's not sent with
	// fullupdate. Doing this in InitHUD essentially caches invalid model indices
	g_iRShell       = gEngfuncs.pEventAPI->EV_FindModelIndex( "models/rshell.mdl" );
	g_iPShell       = gEngfuncs.pEventAPI->EV_FindModelIndex( "models/pshell.mdl" );
	g_iShotgunShell = gEngfuncs.pEventAPI->EV_FindModelIndex( "models/shotgunshell.mdl" );
	
	return 1;
}

void CAM_ToFirstPerson(void);

int CHud :: MsgFunc_ViewMode( const char *pszName, int iSize, void *pbuf )
{
	CAM_ToFirstPerson();
	return 1;
}

int CHud :: MsgFunc_InitHUD( const char *pszName, int iSize, void *pbuf )
{
	// prepare all hud data
	HUDLIST *pList = m_pHudList;

	while (pList)
	{
		if ( pList->p )
			pList->p->InitHUDData();
		pList = pList->pNext;
	}

	g_iFreezeTimeOver = 0;

	g_FogParameters.density = 0.0f;
	g_FogParameters.affectsSkyBox = 0;
	g_FogParameters.color[0] = 0.0f;
	g_FogParameters.color[1] = 0.0f;
	g_FogParameters.color[2] = 0.0f;

	if( cl_fog_density )
		gEngfuncs.Cvar_SetValue( cl_fog_density->name, 0.0f );
	
	if( cl_fog_r )
		gEngfuncs.Cvar_SetValue( cl_fog_r->name, g_FogParameters.color[0] );
	
	if( cl_fog_g )
		gEngfuncs.Cvar_SetValue( cl_fog_g->name, g_FogParameters.color[1] );
	
	if( cl_fog_b )
		gEngfuncs.Cvar_SetValue( cl_fog_b->name, g_FogParameters.color[2] );

	memset( g_PlayerExtraInfo, 0, sizeof(g_PlayerExtraInfo) );

	ResetRain();

	// reset round time
	g_flRoundTime   = 0.0f;

	return 1;
}


int CHud :: MsgFunc_GameMode(const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	m_Teamplay = reader.ReadByte();

	return 1;
}

int CHud :: MsgFunc_Concuss( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	m_iConcussionEffect = reader.ReadByte();
	if (m_iConcussionEffect)
		this->m_StatusIcons.EnableIcon("dmg_concuss",255,160,0);
	else
		this->m_StatusIcons.DisableIcon("dmg_concuss");
	return 1;
}

int CHud::MsgFunc_ShadowIdx(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	int idx = reader.ReadLong();
	g_StudioRenderer.StudioSetShadowSprite(idx);
	return 1;
}

int CHud::MsgFunc_ServerName( const char *name, int size, void *buf )
{
	BufferReader reader( name, buf, size );
	strncpy( gHUD.m_szServerName, reader.ReadString(), 64 );
	gHUD.m_szServerName[63] = 0;
	return 1;
}

int CHud::MsgFunc_Fog( const char *pszName, int iSize, void *pbuf )
{
	//int flags;

	memset( &g_FogParameters, 0, sizeof(FogParameters));

	BufferReader reader( pszName, pbuf, iSize );

	g_FogParameters.affectsSkyBox = false;
	g_FogParameters.color[0] = reader.ReadByte();
	g_FogParameters.color[1] = reader.ReadByte();
	g_FogParameters.color[2] = reader.ReadByte();

	union
	{
		float f;
		char b[4];
	} density;

	density.b[0] = reader.ReadByte();
	density.b[1] = reader.ReadByte();
	density.b[2] = reader.ReadByte();
	density.b[3] = reader.ReadByte();

	g_FogParameters.density = density.f;

	if( cl_fog_density )
		gEngfuncs.Cvar_SetValue( cl_fog_density->name, g_FogParameters.density );
	
	if( cl_fog_r )
		gEngfuncs.Cvar_SetValue( cl_fog_r->name, g_FogParameters.color[0] );
	
	if( cl_fog_g )
		gEngfuncs.Cvar_SetValue( cl_fog_g->name, g_FogParameters.color[1] );
	
	if( cl_fog_b )
		gEngfuncs.Cvar_SetValue( cl_fog_b->name, g_FogParameters.color[2] );
	
	return 1;
}

```

`cl_dll/hud_redraw.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// hud_redraw.cpp
//
#include <math.h>
#include "hud.h"
#include "cl_util.h"
#include "triangleapi.h"

#include <string.h>

#include "draw_util.h"

#define MAX_LOGO_FRAMES 56

int grgLogoFrame[MAX_LOGO_FRAMES] = 
{
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 13, 13, 13, 13, 13, 12, 11, 10, 9, 8, 14, 15,
	16, 17, 18, 19, 20, 20, 20, 20, 20, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 
	29, 29, 29, 29, 29, 28, 27, 26, 25, 24, 30, 31 
};


extern int g_iVisibleMouse;

float HUD_GetFOV( void );

// Think
void CHud::Think(void)
{
	int newfov;

	extern int g_weaponselect_frames;
	if( g_weaponselect_frames )
		g_weaponselect_frames--;

	for( HUDLIST *pList = m_pHudList; pList; pList = pList->pNext )
	{
		if( pList->p->m_iFlags & HUD_THINK )
			pList->p->Think();
	}

	newfov = HUD_GetFOV();
	m_iFOV = newfov ? newfov : default_fov->value;

	// the clients fov is actually set in the client data update section of the hud

	// Set a new sensitivity
	if ( m_iFOV == default_fov->value )
	{  
		// reset to saved sensitivity
		m_flMouseSensitivity = 0;
	}
	else
	{  
		// set a new sensitivity that is proportional to the change from the FOV default
		m_flMouseSensitivity = sensitivity->value * ((float)newfov / (float)default_fov->value) * zoom_sens_ratio->value;
	}

	// think about default fov
	if ( m_iFOV == 0 )
	{  // only let players adjust up in fov,  and only if they are not overriden by something else
		m_iFOV = max( default_fov->value, 90 );
	}

}

// Redraw
// step through the local data,  placing the appropriate graphics & text as appropriate
// returns 1 if they've changed, 0 otherwise
int CHud :: Redraw( float flTime, int intermission )
{
	m_fOldTime = m_flTime;	// save time of previous redraw
	m_flTime = flTime;
	m_flTimeDelta = (double)m_flTime - m_fOldTime;
	static int m_flShotTime = 0;

	// Clock was reset, reset delta
	if ( m_flTimeDelta < 0 )
		m_flTimeDelta = 0;

	if (m_flShotTime && m_flShotTime < flTime)
	{
		gEngfuncs.pfnClientCmd("snapshot\n");
		m_flShotTime = 0;
	}

	m_iIntermission = intermission;

	UpdateDefaultHUDColor();

	if ( m_pCvarDraw->value && (intermission || !(m_iHideHUDDisplay & HIDEHUD_ALL) ) )
	{
		for( HUDLIST *pList = m_pHudList; pList; pList = pList->pNext )
		{
			if( pList->p->m_iFlags & HUD_DRAW )
			{
				if( intermission && !(pList->p->m_iFlags & HUD_INTERMISSION) )
					continue; // skip no-intermission during intermission

				pList->p->Draw( flTime );
			}
		}
	}

	// are we in demo mode? do we need to draw the logo in the top corner?
	if (m_iLogo)
	{
		int x, y, i;

		if (m_hsprLogo == 0)
			m_hsprLogo = LoadSprite("sprites/%d_logo.spr");

		SPR_Set(m_hsprLogo, 250, 250, 250 );
		
		x = SPR_Width(m_hsprLogo, 0);
		x = ScreenWidth - x;
		y = SPR_Height(m_hsprLogo, 0)/2;

		// Draw the logo at 20 fps
		int iFrame = (int)(flTime * 20) % MAX_LOGO_FRAMES;
		i = grgLogoFrame[iFrame] - 1;

		SPR_DrawAdditive(i, x, y, NULL);
	}

	// update codepage parameters
	if( !stricmp( con_charset->string, "cp1251" ))
	{
		g_codepage = 1251;
	}
	else if( !stricmp( con_charset->string, "cp1252" ))
	{
		g_codepage = 1252;
	}
	else
	{
		g_codepage = 0;
	}

	g_accept_utf8 = !stricmp( cl_charset->string, "utf-8" );

	return 1;
}

void CHud::UpdateDefaultHUDColor()
{
	int r, g, b;

	if (sscanf(m_pCvarColor->string, "%d %d %d", &r, &g, &b) == 3) {
		r = max(r, 0);
		g = max(g, 0);
		b = max(b, 0);

		r = min(r, 255);
		g = min(g, 255);
		b = min(b, 255);

		m_iDefaultHUDColor = (r << 16) | (g << 8) | b;
	} else {
		m_iDefaultHUDColor = RGB_YELLOWISH;
	}
}

```

`cl_dll/hud_spectator.cpp`:

```cpp
//========= Copyright В© 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include "cl_entity.h"
#include "triangleapi.h"
#include "hltv.h"

#include "pm_shared.h"
#include "pm_defs.h"
#include "pmtrace.h"
#include "parsemsg.h"
#include "entity_types.h"

// these are included for the math functions
#include "com_model.h"
#include "demo_api.h"
#include "event_api.h"
#include "studio_util.h"
#include "screenfade.h"
#include "draw_util.h"

#ifdef _MSC_VER
#pragma warning(disable: 4244)
#endif

extern int		iJumpSpectator;
extern float	vJumpOrigin[3];
extern float	vJumpAngles[3];


extern void V_GetInEyePos(int entity, float * origin, float * angles );
extern void V_ResetChaseCam();
extern void V_GetChasePos(int target, float * cl_angles, float * origin, float * angles);
extern float * GetClientColor( int clientIndex );

extern vec3_t v_origin;		// last view origin
extern vec3_t v_angles;		// last view angle
extern vec3_t v_cl_angles;	// last client/mouse angle
extern vec3_t v_sim_org;	// last sim origin

void SpectatorMode(void)
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_mode <Main Mode> [<Inset Mode>]\n" );
		return;
	}

	// SetModes() will decide if command is executed on server or local
	if ( gEngfuncs.Cmd_Argc() == 2 )
		gHUD.m_Spectator.SetModes( atoi( gEngfuncs.Cmd_Argv(1) ), -1 );
	else if ( gEngfuncs.Cmd_Argc() == 3 )
		gHUD.m_Spectator.SetModes( atoi( gEngfuncs.Cmd_Argv(1) ), atoi( gEngfuncs.Cmd_Argv(2) )  );
}

void SpectatorSpray(void)
{
	vec3_t forward;

	if ( !gEngfuncs.IsSpectateOnly() )
		return;

	AngleVectors(v_angles,forward,NULL,NULL);
	VectorScale(forward, 128, forward);
	VectorAdd(forward, v_origin, forward);
	pmtrace_t * trace = gEngfuncs.PM_TraceLine( v_origin, forward, PM_TRACELINE_PHYSENTSONLY, 2, -1 );
	if ( trace->fraction != 1.0 )
	{
		char string[128];
		sprintf(string, "drc_spray %.2f %.2f %.2f %i",
				trace->endpos[0], trace->endpos[1], trace->endpos[2], trace->ent );
		gEngfuncs.pfnServerCmd(string);
	}

}
void SpectatorHelp(void)
{
	char *text = CHudTextMessage::BufferedLocaliseTextString( "#Spec_Help_Text" );

	if ( text )
	{
		int len = DrawUtils::ConsoleStringLen( text );

		DrawUtils::DrawConsoleString( (ScreenWidth - len) / 2, ScreenHeight / 3, text );
	}
}

void SpectatorMenu( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_menu <0|1>\n" );
		return;
	}
	const char *name = "spec_menu_internal";
	char *arg = gEngfuncs.Cmd_Argv(1);

	if( arg[0] == 't' && arg[1] == '\0' )
		gEngfuncs.Cvar_SetValue( name, !gEngfuncs.pfnGetCvarFloat(name) );
	else
		gEngfuncs.Cvar_Set( name, gEngfuncs.Cmd_Argv(1) );
}

void SpecDrawNames( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_drawnames <0|1>\n" );
		return;
	}
	const char *name = "spec_drawnames_internal";
	char *arg = gEngfuncs.Cmd_Argv(1);

	if( arg[0] == 't' && arg[1] == '\0' )
		gEngfuncs.Cvar_SetValue( name, !gEngfuncs.pfnGetCvarFloat(name) );
	else
		gEngfuncs.Cvar_Set( name, gEngfuncs.Cmd_Argv(1) );}

void SpecDrawCone( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_drawcone <0|1>\n" );
		return;
	}

	const char *name = "spec_drawcone_internal";
	char *arg = gEngfuncs.Cmd_Argv(1);
	if( arg[0] == 't' && arg[1] == '\0' )
		gEngfuncs.Cvar_SetValue( name, !gEngfuncs.pfnGetCvarFloat(name) );
	else
		gEngfuncs.Cvar_Set( name, gEngfuncs.Cmd_Argv(1) );
}
void SpecDrawStatus( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_drawstatus <0|1>\n" );
		return;
	}

	const char *name = "spec_drawstatus_internal";
	char *arg = gEngfuncs.Cmd_Argv(1);
	if( arg[0] == 't' && arg[1] == '\0' )
		gEngfuncs.Cvar_SetValue( name, !gEngfuncs.pfnGetCvarFloat(name) );
	else
		gEngfuncs.Cvar_Set( name, gEngfuncs.Cmd_Argv(1) );
}

void SpecAutoDirector( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_autodirector <0|1>\n" );
		return;
	}

	const char *name = "spec_autodirector_internal";
	char *arg = gEngfuncs.Cmd_Argv(1);

	if( arg[0] == 't' && arg[1] == '\0' )
		gEngfuncs.Cvar_SetValue( name, !gEngfuncs.pfnGetCvarFloat(name) );
	else
		gEngfuncs.Cvar_Set( name, gEngfuncs.Cmd_Argv(1) );
}

void SpecPip( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_pip <0|1>\n" );
		return;
	}

	const char *name = "spec_pip_internal";
	char *arg = gEngfuncs.Cmd_Argv(1);

	if( arg[0] == 't' && arg[1] == '\0' )
	{
		if ( gHUD.m_Spectator.m_pip && (int)gHUD.m_Spectator.m_pip->value != INSET_OFF )
		{
			gHUD.m_Spectator.SetModes( -1, INSET_OFF );
		}
		else
		{
			// ensure overview data and map sprite are loaded before enabling PiP
			gHUD.m_Spectator.ParseOverviewFile();
			gHUD.m_Spectator.LoadMapSprites();

			// if map overview is open in fullscreen, show Locked Chase Cam in inset (player chase)
			int insetMode = INSET_MAP_FREE;
			if ( g_iUser1 == OBS_MAP_FREE || g_iUser1 == OBS_MAP_CHASE )
				insetMode = INSET_CHASE_LOCKED;
			gHUD.m_Spectator.SetModes( -1, insetMode );
		}
	}
	else
	{
		gEngfuncs.Cvar_Set( name, gEngfuncs.Cmd_Argv(1) );
	}
}

void HudSayText( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  hud_saytext <0|1>\n" );
		return;
	}

	const char *name = "hud_saytext_internal";
	char *arg = gEngfuncs.Cmd_Argv(1);

	if( arg[0] == 't' && arg[1] == '\0' )
		gEngfuncs.Cvar_SetValue( name, !gEngfuncs.pfnGetCvarFloat(name) );
	else
		gEngfuncs.Cvar_Set( name, gEngfuncs.Cmd_Argv(1) );
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
int CHudSpectator::Init()
{
	gHUD.AddHudElem(this);

	m_iFlags |= HUD_DRAW | HUD_THINK;
	m_flNextObserverInput = 0.0f;
	m_zoomDelta	= 0.0f;
	m_moveDelta = 0.0f;
	m_chatEnabled = (gHUD.m_SayText.m_HUD_saytext->value!=0);
	iJumpSpectator	= 0;

	memset( &m_OverviewData, 0, sizeof(m_OverviewData));
	memset( &m_OverviewEntities, 0, sizeof(m_OverviewEntities));
	m_lastPrimaryObject = m_lastSecondaryObject = 0;

	gEngfuncs.pfnAddCommand ("spec_mode", SpectatorMode );
	gEngfuncs.pfnAddCommand ("spec_decal", SpectatorSpray );
	gEngfuncs.pfnAddCommand ("spec_help", SpectatorHelp );
	gEngfuncs.pfnAddCommand ("spec_menu", SpectatorMenu );
	gEngfuncs.pfnAddCommand ("spec_drawnames", SpecDrawNames );
	gEngfuncs.pfnAddCommand ("spec_drawcone", SpecDrawCone );
	gEngfuncs.pfnAddCommand ("spec_drawstatus", SpecDrawStatus );
	gEngfuncs.pfnAddCommand ("hud_saytext", HudSayText );
	gEngfuncs.pfnAddCommand ("spec_autodirector", SpecAutoDirector );
	gEngfuncs.pfnAddCommand ("spec_pip", SpecPip );

	m_drawnames		= gEngfuncs.pfnRegisterVariable("spec_drawnames_internal","1",0);
	m_drawcone		= gEngfuncs.pfnRegisterVariable("spec_drawcone_internal","1",0);
	m_drawstatus	= gEngfuncs.pfnRegisterVariable("spec_drawstatus_internal","1",0);
	m_autoDirector	= gEngfuncs.pfnRegisterVariable("spec_autodirector_internal","1",0);
	m_HUD_saytext 	= gEngfuncs.pfnRegisterVariable("hud_saytext_internal","1",0);
	m_pip			= gEngfuncs.pfnRegisterVariable("spec_pip_internal","1",0);
	m_lastAutoDirector = 0.0f;
	
	if ( !m_drawnames || !m_drawcone || !m_drawstatus || !m_autoDirector || !m_pip )
	{
		gEngfuncs.Con_Printf("ERROR! Couldn't register all spectator variables.\n");
		return 0;
	}

	return 1;
}


//-----------------------------------------------------------------------------
// UTIL_StringToVector originally from ..\dlls\util.cpp, slightly changed
//-----------------------------------------------------------------------------

void UTIL_StringToVector( float * pVector, const char *pString )
{
	char *pstr, *pfront, tempString[128];
	int	j;

	strncpy( tempString, pString, sizeof( tempString ) );
	tempString[ sizeof( tempString ) - 1 ] = '\0';
	pstr = pfront = tempString;
	
	for ( j = 0; j < 3; j++ )
	{
		pVector[j] = atof( pfront );
		
		while ( *pstr && *pstr != ' ' )
			pstr++;
		if (!*pstr)
			break;
		pstr++;
		pfront = pstr;
	}

	if (j < 2)
	{
		for (j = j+1;j < 3; j++)
			pVector[j] = 0;
	}
}

int UTIL_FindEntityInMap( const char * name, float * origin, float * angle)
{
	int				n,found = 0;
	char			keyname[256];
	char			token[1024];

	cl_entity_t *	pEnt = gEngfuncs.GetEntityByIndex( 0 );	// get world model

	if ( !pEnt ) return 0;

	if ( !pEnt->model )	return 0;

	char * data = pEnt->model->entities;

	while (data)
	{
		data = gEngfuncs.COM_ParseFile(data, token);
		
		if ( (token[0] == '}') ||  (token[0]==0) )
			break;

		if (!data)
		{
			gEngfuncs.Con_DPrintf("UTIL_FindEntityInMap: EOF without closing brace\n");
			return 0;
		}

		if (token[0] != '{')
		{
			gEngfuncs.Con_DPrintf("UTIL_FindEntityInMap: expected {\n");
			return 0;
		}

		// we parse the first { now parse entities properties
		
		while ( 1 )
		{
			// parse key
			data = gEngfuncs.COM_ParseFile(data, token);
			if (token[0] == '}')
				break; // finish parsing this entity

			if (!data)
			{
				gEngfuncs.Con_DPrintf("UTIL_FindEntityInMap: EOF without closing brace\n");
				return 0;
			}
			
			strncpy (keyname, token, sizeof(keyname));
			keyname[sizeof(keyname)-1]=0;

			// another hack to fix keynames with trailing spaces
			n = strlen(keyname);
			while (n && keyname[n-1] == ' ')
			{
				keyname[n-1] = 0;
				n--;
			}
			
			// parse value
			data = gEngfuncs.COM_ParseFile(data, token);
			if (!data)
			{
				gEngfuncs.Con_DPrintf("UTIL_FindEntityInMap: EOF without closing brace\n");
				return 0;
			};

			if (token[0] == '}')
			{
				gEngfuncs.Con_DPrintf("UTIL_FindEntityInMap: closing brace without data");
				return 0;
			}

			if (!strcmp(keyname,"classname"))
			{
				if (!strcmp(token, name ))
				{
					found = 1;	// thats our entity
				}
			};

			if( !strcmp( keyname, "angle" ) )
			{
				float y = atof( token );
				
				if (y >= 0)
				{
					angle[0] = 0.0f;
					angle[1] = y;
				}
				else if ((int)y == -1)
				{
					angle[0] = -90.0f;
					angle[1] =   0.0f;;
				}
				else
				{
					angle[0] = 90.0f;
					angle[1] =  0.0f;
				}

				angle[2] =  0.0f;
			}

			if( !strcmp( keyname, "angles" ) )
			{
				UTIL_StringToVector(angle, token);
			}
			
			if (!strcmp(keyname,"origin"))
			{
				UTIL_StringToVector(origin, token);

			};

		} // while (1)

		if (found)
			return 1;

	}

	return 0;	// we search all entities, but didn't found the correct

}

//-----------------------------------------------------------------------------
// SetSpectatorStartPosition(): 
// Get valid map position and 'beam' spectator to this position
//-----------------------------------------------------------------------------

void CHudSpectator::SetSpectatorStartPosition()
{
	// search for info_player start
	if ( UTIL_FindEntityInMap( "trigger_camera",  m_cameraOrigin, m_cameraAngles ) )
		iJumpSpectator = 1;

	else if ( UTIL_FindEntityInMap( "info_player_start",  m_cameraOrigin, m_cameraAngles ) )
		iJumpSpectator = 1;

	else if ( UTIL_FindEntityInMap( "info_player_deathmatch",  m_cameraOrigin, m_cameraAngles ) )
		iJumpSpectator = 1;

	else if ( UTIL_FindEntityInMap( "info_player_coop",  m_cameraOrigin, m_cameraAngles ) )
		iJumpSpectator = 1;
	else
	{
      static const Vector &nullvec = Vector (0.0, 0.0, 0.0);
		// jump to 0,0,0 if no better position was found
		VectorCopy(nullvec, m_cameraOrigin);
		VectorCopy(nullvec, m_cameraAngles);
	}
	
	VectorCopy(m_cameraOrigin, vJumpOrigin);
	VectorCopy(m_cameraAngles, vJumpAngles);

	iJumpSpectator = 1;	// jump anyway
}

//-----------------------------------------------------------------------------
// Purpose: Loads new icons
//-----------------------------------------------------------------------------
int CHudSpectator::VidInit()
{
	m_hsprPlayer		= SPR_Load("sprites/iplayer.spr");
	m_hsprPlayerBlue	= SPR_Load("sprites/iplayerblue.spr");
	m_hsprPlayerRed		= SPR_Load("sprites/iplayerred.spr");
	m_hsprPlayerDead	= SPR_Load("sprites/iplayerdead.spr");
	m_hsprPlayerVIP		= SPR_Load("sprites/iplayervip.spr");
	m_hsprPlayerC4		= SPR_Load("sprites/iplayerc4.spr");
	m_hsprUnkownMap		= SPR_Load("sprites/tile.spr");
	m_hsprBeam			= SPR_Load("sprites/laserbeam.spr");
	m_hsprCamera		= SPR_Load("sprites/camera.spr");
	m_hsprBomb			= SPR_Load("sprites/ic4.spr");
	m_hsprBackpack		= SPR_Load("sprites/ibackpack.spr");
	m_hsprHostage		= SPR_Load("sprites/ihostage.spr");
	
	return 1;
}

//-----------------------------------------------------------------------------
// Purpose: 
// Input  : flTime - 
//			intermission - 
//-----------------------------------------------------------------------------
int CHudSpectator::Draw(float flTime)
{
	int lx;

	char string[256];
	float * color;

	// draw only in spectator mode
	if ( !g_iUser1  )
		return 0;

	if ( m_lastAutoDirector != m_autoDirector->value )
	{
		m_lastAutoDirector = m_autoDirector->value;
		char cmd[64];
		snprintf(cmd, sizeof(cmd), "spec_set_ad %f", m_autoDirector->value);
		gEngfuncs.pfnClientCmd(cmd);
		if ( m_lastAutoDirector == 0.0 )
		{
			if ( g_iUser1 == OBS_CHASE_LOCKED )
			{
				SetModes(OBS_CHASE_FREE, INSET_OFF);
			}
		}
		else if ( g_iUser1 == OBS_CHASE_FREE )
		{
			SetModes(OBS_CHASE_LOCKED, INSET_OFF);
		}
	}

	// if user pressed zoom, aplly changes
	if ( (m_zoomDelta != 0.0f) && (	g_iUser1 == OBS_MAP_FREE ) )
	{
		m_mapZoom += m_zoomDelta;

		if ( m_mapZoom > 3.0f )
			m_mapZoom = 3.0f;

		if ( m_mapZoom < 0.5f )
			m_mapZoom = 0.5f;
	}

	// if user moves in map mode, change map origin
	if ( (m_moveDelta != 0.0f) && (g_iUser1 != OBS_ROAMING) )
	{
		vec3_t	right;
		AngleVectors(v_angles, NULL, right, NULL);
		VectorNormalize(right);
		VectorScale(right, m_moveDelta, right );

		VectorAdd( m_mapOrigin, right, m_mapOrigin )

	}
	
	// Only draw the icon names only if map mode is in Main Mode
	if ( g_iUser1 < OBS_MAP_FREE  )
		return 1;
	
	if ( !m_drawnames->value )
		return 1;
	
	// make sure we have player info
	//gViewPort->GetAllPlayersInfo();
	gHUD.m_Scoreboard.GetAllPlayersInfo();

	// loop through all the players and draw additional infos to their sprites on the map
	for (int i = 0; i < MAX_PLAYERS; i++)
	{

		if ( m_vPlayerPos[i][2]<0 )	// marked as invisible ?
			continue;

		// can player exist without name?
		if( !g_PlayerInfoList[i+1].name )
			continue;
		
		// check if name would be in inset window
		if ( m_pip->value != INSET_OFF )
		{
			if (	m_vPlayerPos[i][0] > XRES( m_OverviewData.insetWindowX ) &&
					m_vPlayerPos[i][1] > YRES( m_OverviewData.insetWindowY ) &&
					m_vPlayerPos[i][0] < XRES( m_OverviewData.insetWindowX + m_OverviewData.insetWindowWidth ) &&
					m_vPlayerPos[i][1] < YRES( m_OverviewData.insetWindowY + m_OverviewData.insetWindowHeight)
					) continue;
		}

		color = GetClientColor( i+1 ); // ???

		// draw the players name and health underneath
		sprintf(string, "%s", g_PlayerInfoList[i+1].name );
		
		lx = strlen(string)*3; // 3 is avg. character length :)

		DrawUtils::SetConsoleTextColor( color[0], color[1], color[2] );
		DrawUtils::DrawConsoleString( m_vPlayerPos[i][0]-lx,m_vPlayerPos[i][1], string);
		
	}


	// Only draw the overview if Map Mode is selected for this view
	if ( m_iDrawCycle == 0 &&  ( (g_iUser1 != OBS_MAP_FREE) && (g_iUser1 != OBS_MAP_CHASE) ) )
		return 1;

	if ( m_iDrawCycle == 1 && m_pip->value < INSET_MAP_FREE )
		return 1;

	return 1;
}


void CHudSpectator::DirectorMessage( int iSize, void *pbuf )
{
	float	value;
	char *	string;

	BufferReader reader( "DRCMsg", pbuf, iSize );

	int cmd = reader.ReadByte();

	switch ( cmd )	// director command byte
	{
	case DRC_CMD_START	:
		// now we have to do some things clientside, since the proxy doesn't know our mod
		g_iTeamNumber = 0;

		// fake a InitHUD & ResetHUD message
		gHUD.MsgFunc_InitHUD(NULL,0, NULL);
		gHUD.MsgFunc_ResetHUD(NULL, 0, NULL);

		break;

	case DRC_CMD_EVENT	:
		m_lastPrimaryObject		=	reader.ReadWord();
		m_lastSecondaryObject	=	reader.ReadWord();
		m_iObserverFlags		=	reader.ReadLong();

		if ( m_autoDirector->value )
		{
			if ( (g_iUser2 != m_lastPrimaryObject) || (g_iUser3 != m_lastSecondaryObject) )
				V_ResetChaseCam();

			g_iUser2 = m_lastPrimaryObject;
			g_iUser3 = m_lastSecondaryObject;
		}

		// gEngfuncs.Con_Printf("Director Camera: %i %i\n", firstObject, secondObject);
		break;

	case DRC_CMD_MODE  :
		if ( m_autoDirector->value )
		{
			SetModes( reader.ReadByte(), -1 );
		}
		break;

	case DRC_CMD_CAMERA	:
		if ( m_autoDirector->value )
		{
			vJumpOrigin[0] = reader.ReadCoord();	// position
			vJumpOrigin[1] = reader.ReadCoord();
			vJumpOrigin[2] = reader.ReadCoord();

			vJumpAngles[0] = reader.ReadCoord();	// view angle
			vJumpAngles[1] = reader.ReadCoord();
			vJumpAngles[2] = reader.ReadCoord();

			gEngfuncs.SetViewAngles( vJumpAngles );

			iJumpSpectator = 1;
		}
		break;

	case DRC_CMD_MESSAGE:
	{
		client_textmessage_t * msg = &m_HUDMessages[m_lastHudMessage];

		msg->effect = reader.ReadByte();		// effect

		int r, g, b;

		DrawUtils::UnpackRGB( r, g, b, reader.ReadLong() );		// color
		msg->r2 = msg->r1 = bound( 0, r, 255 );
		msg->g2 = msg->g1 = bound( 0, g, 255 );
		msg->b2 = msg->b1 = bound( 0, b, 255 );
		msg->a2 = msg->a1 = 0xFF;	// not transparent

		msg->x = reader.ReadFloat();	// x pos
		msg->y = reader.ReadFloat();	// y pos

		msg->fadein		= reader.ReadFloat();	// fadein
		msg->fadeout	= reader.ReadFloat();	// fadeout
		msg->holdtime	= reader.ReadFloat();	// holdtime
		msg->fxtime		= reader.ReadFloat();	// fxtime;

		strncpy( m_HUDMessageText[m_lastHudMessage], reader.ReadString(), 128 );
		m_HUDMessageText[m_lastHudMessage][127]=0;	// text

		msg->pMessage = m_HUDMessageText[m_lastHudMessage];
		msg->pName	  = "HUD_MESSAGE";

		gHUD.m_Message.MessageAdd( msg );

		m_lastHudMessage++;
		m_lastHudMessage %= MAX_SPEC_HUD_MESSAGES;

	}

		break;

	case DRC_CMD_SOUND :
		string = reader.ReadString();
		value =  reader.ReadFloat();

		// gEngfuncs.Con_Printf("DRC_CMD_FX_SOUND: %s %.2f\n", string, value );
		gEngfuncs.pEventAPI->EV_PlaySound(0, v_origin, CHAN_BODY, string, value, ATTN_NORM, 0, PITCH_NORM );

		break;

	case DRC_CMD_TIMESCALE	:
		value = reader.ReadFloat();
		break;



	case DRC_CMD_STATUS:
		reader.ReadLong(); // total number of spectator slots
		m_iSpectatorNumber = reader.ReadLong(); // total number of spectator
		reader.ReadWord(); // total number of relay proxies

		//gViewPort->UpdateSpectatorPanel();
		break;

	case DRC_CMD_BANNER:
		// gEngfuncs.Con_DPrintf("GUI: Banner %s\n",reader.ReadString() ); // name of banner tga eg gfx/temp/7454562234563475.tga
		//gViewPort->m_pSpectatorPanel->m_TopBanner->LoadImage( reader.ReadString() );
		//gViewPort->UpdateSpectatorPanel();
		break;

		/*case DRC_CMD_FADE:
							break;*/

	case DRC_CMD_STUFFTEXT:
		FilteredClientCmd( reader.ReadString() );
		break;
	default			:	gEngfuncs.Con_DPrintf("CHudSpectator::DirectorMessage: unknown command %i.\n", cmd );
	}
}

void CHudSpectator::FindNextPlayer(bool bReverse)
{
	// MOD AUTHORS: Modify the logic of this function if you want to restrict the observer to watching
	//				only a subset of the players. e.g. Make it check the target's team.

	int		iStart;
	cl_entity_t * pEnt = NULL;

	// if we are NOT in HLTV mode, spectator targets are set on server
	if ( !gEngfuncs.IsSpectateOnly() )
	{
		char cmdstring[32];
		// forward command to server
		sprintf(cmdstring,"follownext %i",bReverse?1:0);
		gEngfuncs.pfnServerCmd(cmdstring);
		return;
	}
	
	if ( g_iUser2 )
		iStart = g_iUser2;
	else
		iStart = 1;

	g_iUser2 = 0;

	int	    iCurrent = iStart;

	int iDir = bReverse ? -1 : 1;

	// make sure we have player info
	//gViewPort->GetAllPlayersInfo();
	gHUD.m_Scoreboard.GetAllPlayersInfo();

	do
	{
		iCurrent += iDir;

		// Loop through the clients
		if (iCurrent > MAX_PLAYERS)
			iCurrent = 1;
		if (iCurrent < 1)
			iCurrent = MAX_PLAYERS;

		pEnt = gEngfuncs.GetEntityByIndex( iCurrent );

		if ( !IsActivePlayer( pEnt ) )
			continue;

		// MOD AUTHORS: Add checks on target here.

		g_iUser2 = iCurrent;
		break;

	} while ( iCurrent != iStart );

	// Did we find a target?
	if ( !g_iUser2 )
	{
		gEngfuncs.Con_DPrintf( "No observer targets.\n" );
		// take save camera position
		VectorCopy(m_cameraOrigin, vJumpOrigin);
		VectorCopy(m_cameraAngles, vJumpAngles);
	}
	else
	{
		// use new entity position for roaming
		VectorCopy ( pEnt->origin, vJumpOrigin );
		VectorCopy ( pEnt->angles, vJumpAngles );
	}
	iJumpSpectator = 1;
}

void CHudSpectator::HandleButtonsDown( int ButtonPressed )
{
	double time = gEngfuncs.GetClientTime();

	int newMainMode		= g_iUser1;
	int newInsetMode	= m_pip->value;

	// gEngfuncs.Con_Printf(" HandleButtons:%i\n", ButtonPressed );
	//	if ( !gViewPort )

	//Not in intermission.
	if ( gHUD.m_iIntermission )
		return;

	if ( !g_iUser1 )
		return; // don't do anything if not in spectator mode

	// don't handle buttons during normal demo playback
	if ( gEngfuncs.pDemoAPI->IsPlayingback() && !gEngfuncs.IsSpectateOnly() )
		return;
	// Slow down mouse clicks.
	if ( m_flNextObserverInput > time )
		return;

	// enable spectator screen
	if ( ButtonPressed & IN_DUCK )
	{
		gHUD.m_SpectatorGui.UserCmd_ToggleSpectatorMenu();
	}

	//  'Use' changes inset window mode
	if ( ButtonPressed & IN_USE )
	{
		newInsetMode = ToggleInset(true);
	}

	// if not in HLTV mode, buttons are handled server side
	if ( gEngfuncs.IsSpectateOnly() )
	{
		// changing target or chase mode not in overviewmode without inset window

		// Jump changes main window modes
		if ( ButtonPressed & IN_JUMP )
		{
			if ( g_iUser1 == OBS_CHASE_LOCKED )
				newMainMode = OBS_CHASE_FREE;

			else if ( g_iUser1 == OBS_CHASE_FREE )
				newMainMode = OBS_IN_EYE;

			else if ( g_iUser1 == OBS_IN_EYE )
				newMainMode = OBS_ROAMING;

			else if ( g_iUser1 == OBS_ROAMING )
				newMainMode = OBS_MAP_FREE;

			else if ( g_iUser1 == OBS_MAP_FREE )
				newMainMode = OBS_MAP_CHASE;

			else
				newMainMode = OBS_CHASE_FREE;	// don't use OBS_CHASE_LOCKED anymore
		}

		// Attack moves to the next player
		if ( ButtonPressed & (IN_ATTACK | IN_ATTACK2) )
		{
			FindNextPlayer( (ButtonPressed & IN_ATTACK2) ? true:false );

			if ( g_iUser1 == OBS_ROAMING )
			{
				gEngfuncs.SetViewAngles( vJumpAngles );
				iJumpSpectator = 1;
				gHUD.m_Health.m_iPlayerLastPointedAt = g_iUser2;
				g_PlayerExtraInfo[g_iUser2].showhealth = gHUD.m_flTime + 3.0f;
			}
			// lease directed mode if player want to see another player
			m_autoDirector->value = 0.0f;
		}
	}

	SetModes(newMainMode, newInsetMode);

	if ( g_iUser1 == OBS_MAP_FREE )
	{
		if ( ButtonPressed & IN_FORWARD )
			m_zoomDelta =  0.01f;

		if ( ButtonPressed & IN_BACK )
			m_zoomDelta = -0.01f;
		
		if ( ButtonPressed & IN_MOVELEFT )
			m_moveDelta = -12.0f;

		if ( ButtonPressed & IN_MOVERIGHT )
			m_moveDelta =  12.0f;
	}

	m_flNextObserverInput = time + 0.2;
}

void CHudSpectator::HandleButtonsUp( int ButtonPressed )
{
	//if ( !gViewPort )
	//return;

	//	if ( !gViewPort->m_pSpectatorPanel->isVisible() )
	//	return; // don't do anything if not in spectator mode

	if ( ButtonPressed & (IN_FORWARD | IN_BACK) )
		m_zoomDelta = 0.0f;
	
	if ( ButtonPressed & (IN_MOVELEFT | IN_MOVERIGHT) )
		m_moveDelta = 0.0f;
}

void CHudSpectator::SetModes(int iNewMainMode, int iNewInsetMode)
{
	// if value == -1 keep old value
	if ( iNewMainMode == -1 )
		iNewMainMode = g_iUser1;

	if ( iNewInsetMode == -1 )
		iNewInsetMode = m_pip->value;

	// inset mode is handled only clients side
	m_pip->value = iNewInsetMode;
	
	if ( iNewMainMode < OBS_CHASE_LOCKED || iNewMainMode > OBS_MAP_CHASE )
	{
		gEngfuncs.Con_Printf("Invalid spectator mode.\n");
		return;
	}
	
	// main modes ettings will override inset window settings
	if ( iNewMainMode != g_iUser1 )
	{
		// if we are NOT in HLTV mode, main spectator mode is set on server
		if ( !gEngfuncs.IsSpectateOnly() )
		{
			char cmdstring[32];
			// forward command to server
			sprintf(cmdstring,"specmode %i",iNewMainMode );
			gEngfuncs.pfnServerCmd(cmdstring);
			return;
		}

		if ( !g_iUser2 && (iNewMainMode != OBS_ROAMING ) )	// make sure we have a target
		{
			// choose last Director object if still available
			if ( IsActivePlayer( gEngfuncs.GetEntityByIndex( m_lastPrimaryObject ) ) )
			{
				g_iUser2 = m_lastPrimaryObject;
				g_iUser3 = m_lastSecondaryObject;
			}
			else
				FindNextPlayer(false); // find any target
		}

		switch ( iNewMainMode )
		{
		case OBS_CHASE_LOCKED:	g_iUser1 = OBS_CHASE_LOCKED;
			break;

		case OBS_CHASE_FREE :	g_iUser1 = OBS_CHASE_FREE;
			break;

		case OBS_ROAMING	:	// jump to current vJumpOrigin/angle
			g_iUser1 = OBS_ROAMING;
			if ( g_iUser2 )
			{
				V_GetChasePos( g_iUser2, v_cl_angles, vJumpOrigin, vJumpAngles );
				gEngfuncs.SetViewAngles( vJumpAngles );
				iJumpSpectator = 1;
			}
			break;

		case OBS_IN_EYE		:	g_iUser1 = OBS_IN_EYE;
			break;

		case OBS_MAP_FREE	:	g_iUser1 = OBS_MAP_FREE;
			// reset user values
			m_mapZoom = m_OverviewData.zoom;
			m_mapOrigin = m_OverviewData.origin;
			break;

		case OBS_MAP_CHASE	:	g_iUser1 = OBS_MAP_CHASE;
			// reset user values
			m_mapZoom = m_OverviewData.zoom;
			m_mapOrigin = m_OverviewData.origin;
			break;
		}

		char string[128];
		sprintf(string, "#Spec_Mode%d", g_iUser1 );
		sprintf(string, "%c%s", HUD_PRINTCENTER, CHudTextMessage::BufferedLocaliseTextString( string ));
		gHUD.m_TextMessage.MsgFunc_TextMsg(NULL, strlen(string)+1, string );
	}

	//gViewPort->UpdateSpectatorPanel();

}

bool CHudSpectator::IsActivePlayer(cl_entity_t * ent)
{
	return ( ent &&
			 ent->player &&
			 ent->curstate.solid != SOLID_NOT &&
			ent != gEngfuncs.GetLocalPlayer() &&
			g_PlayerInfoList[ent->index].name != NULL
			);
}


bool CHudSpectator::ParseOverviewFile( )
{
	char filename[255];
	char levelname[255];
	char token[1024];
	float height;

	char *pfile  = NULL;

	memset( &m_OverviewData, 0, sizeof(m_OverviewData));

	// fill in standrd values
	m_OverviewData.insetWindowX = 4;	// upper left corner
	m_OverviewData.insetWindowY = 4;
	m_OverviewData.insetWindowHeight = 180;
	m_OverviewData.insetWindowWidth = 240;
	m_OverviewData.origin[0] = 0.0f;
	m_OverviewData.origin[1] = 0.0f;
	m_OverviewData.origin[2] = 0.0f;
	m_OverviewData.zoom	= 1.0f;
	m_OverviewData.layers = 0;
	m_OverviewData.layersHeights[0] = 0.0f;
	strncpy( m_OverviewData.map, gEngfuncs.pfnGetLevelName(), sizeof(m_OverviewData.map) );

	if ( strlen( m_OverviewData.map ) == 0 )
		return false; // not active yet

	strncpy(levelname, m_OverviewData.map + 5, sizeof( levelname ));
	levelname[strlen(levelname)-4] = 0;
	
	snprintf(filename, sizeof( filename ), "overviews/%s.txt", levelname );

	pfile = (char *)gEngfuncs.COM_LoadFile( filename, 5, NULL);

	if (!pfile)
	{
		gEngfuncs.Con_Printf("Couldn't open file %s. Using default values for overiew mode.\n", filename );
		return false;
	}
	
	
	while (true)
	{
		pfile = gEngfuncs.COM_ParseFile(pfile, token);

		if (!pfile)
			break;

		if ( !stricmp( token, "global" ) )
		{
			// parse the global data
			pfile = gEngfuncs.COM_ParseFile(pfile, token);
			if ( stricmp( token, "{" ) )
			{
				gEngfuncs.Con_Printf("Error parsing overview file %s. (expected { )\n", filename );
				return false;
			}

			pfile = gEngfuncs.COM_ParseFile(pfile,token);

			while (stricmp( token, "}") )
			{
				if ( !stricmp( token, "zoom" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.zoom = atof( token );
				}
				else if ( !stricmp( token, "origin" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile, token);
					m_OverviewData.origin[0] = atof( token );
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.origin[1] = atof( token );
					pfile = gEngfuncs.COM_ParseFile(pfile, token);
					m_OverviewData.origin[2] = atof( token );
				}
				else if ( !stricmp( token, "rotated" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.rotated = atoi( token );
				}
				else if ( !stricmp( token, "inset" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.insetWindowX = atof( token );
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.insetWindowY = atof( token );
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.insetWindowWidth = atof( token );
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.insetWindowHeight = atof( token );

				}
				else
				{
					gEngfuncs.Con_Printf("Error parsing overview file %s. (%s unknown)\n", filename, token );
					return false;
				}

				pfile = gEngfuncs.COM_ParseFile(pfile,token); // parse next token

			}
		}
		else if ( !stricmp( token, "layer" ) )
		{
			// parse a layer data

			if ( m_OverviewData.layers == OVERVIEW_MAX_LAYERS )
			{
				gEngfuncs.Con_Printf("Error parsing overview file %s. ( too many layers )\n", filename );
				return false;
			}

			pfile = gEngfuncs.COM_ParseFile(pfile,token);


			if ( stricmp( token, "{" ) )
			{
				gEngfuncs.Con_Printf("Error parsing overview file %s. (expected { )\n", filename );
				return false;
			}

			pfile = gEngfuncs.COM_ParseFile(pfile,token);

			while (stricmp( token, "}") )
			{
				if ( !stricmp( token, "image" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					strncpy(m_OverviewData.layersImages[ m_OverviewData.layers ], token, 255);
					m_OverviewData.layersImages[ m_OverviewData.layers ][254] = 0;
					
				}
				else if ( !stricmp( token, "height" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					height = atof(token);
					m_OverviewData.layersHeights[ m_OverviewData.layers ] = height;
				}
				else
				{
					gEngfuncs.Con_Printf("Error parsing overview file %s. (%s unknown)\n", filename, token );
					return false;
				}

				pfile = gEngfuncs.COM_ParseFile(pfile,token); // parse next token
			}

			m_OverviewData.layers++;

		}
	}

	gEngfuncs.COM_FreeFile( pfile );

	m_mapZoom = m_OverviewData.zoom;
	m_mapOrigin = m_OverviewData.origin;

	return true;

}

void CHudSpectator::LoadMapSprites()
{
	// right now only support for one map layer
	if (m_OverviewData.layers > 0 )
	{
		m_MapSprite = gEngfuncs.LoadMapSprite( m_OverviewData.layersImages[0] );
	}
	else
		m_MapSprite = NULL; // the standard "unknown map" sprite will be used instead
}

// 1 = s, 2 = t, 3 = 2048
static const int st_to_vec[6][3] =
{
{  3, -1,  2 },
{ -3,  1,  2 },
{  1,  3,  2 },
{ -1, -3,  2 },
{ -2, -1,  3 },  // 0 degrees yaw, look straight up
{  2, -1, -3 }   // look straight down
};

void MakeSkyVec( float s, float t, int axis )
{
	int	j, k, farclip;
	vec3_t	v, b;

	farclip = 4096;

	b[0] = s * (farclip >> 1);
	b[1] = t * (farclip >> 1);
	b[2] = (farclip >> 1);

	for( j = 0; j < 3; j++ )
	{
		k = st_to_vec[axis][j];
		v[j] = (k < 0) ? -b[-k-1] : b[k-1];
		// v[j] += RI.cullorigin[j];
	}

	// avoid bilerp seam
	s = (s + 1.0f) * 0.5f;
	t = (t + 1.0f) * 0.5f;

	if( s < 1.0f / 512.0f )
		s = 1.0f / 512.0f;
	else if( s > 511.0f / 512.0f )
		s = 511.0f / 512.0f;
	if( t < 1.0f / 512.0f )
		t = 1.0f / 512.0f;
	else if( t > 511.0f / 512.0f )
		t = 511.0f / 512.0f;

	t = 1.0f - t;

	gEngfuncs.pTriAPI->TexCoord2f( s, t );
	gEngfuncs.pTriAPI->Vertex3fv( v );
}

void CHudSpectator::DrawOverviewLayer()
{
	float screenaspect, xs, ys, xStep, yStep, x,y,z;
	int ix,iy,i,xTiles,yTiles,frame;
	model_t *   dummySprite = (struct model_s *)gEngfuncs.GetSpritePointer( m_hsprUnkownMap);

	if ( m_MapSprite )
	{
		i = m_MapSprite->numframes / (4*3);
		i = sqrt(i);
		xTiles = i*4;
		yTiles = i*3;
	}
	else
	{
		xTiles = 8;
		yTiles = 6;
	}

	screenaspect = 4.0f/3.0f;


	xs = m_OverviewData.origin[0];
	ys = m_OverviewData.origin[1];
	z  = ( 90.0f - v_angles[0] ) / 90.0f;
	z *= m_OverviewData.layersHeights[0]; // gOverviewData.z_min - 32;

	// i = r_overviewTexture + ( layer*OVERVIEW_X_TILES*OVERVIEW_Y_TILES );
	/*gEngfuncs.pTriAPI->RenderMode( kRenderNormal );
	gEngfuncs.pTriAPI->CullFace( TRI_NONE );
	gEngfuncs.pTriAPI->Color4f( 0, 0, 0, 1.0f );
	gEngfuncs.pTriAPI->Begin( TRI_QUADS );

	float		skyMins[2][6];
	float		skyMaxs[2][6];

	for( i = 0; i < 6; i++ )
	{
		// GL_Bind( XASH_TEXTURE0, tr.skyboxTextures[r_skyTexOrder[i]] );

		skyMins[0][i] = skyMins[1][i] = -1.0f;
		skyMaxs[0][i] = skyMaxs[1][i] = 1.0f;

		gEngfuncs.pTriAPI->Begin( TRI_QUADS );
		MakeSkyVec( skyMins[0][i], skyMins[1][i], i );
		MakeSkyVec( skyMins[0][i], skyMaxs[1][i], i );
		MakeSkyVec( skyMaxs[0][i], skyMaxs[1][i], i );
		MakeSkyVec( skyMaxs[0][i], skyMins[1][i], i );
		gEngfuncs.pTriAPI->End();
	}*/

	gEngfuncs.pTriAPI->RenderMode( kRenderTransTexture );
	gEngfuncs.pTriAPI->CullFace( TRI_NONE );	
	gEngfuncs.pTriAPI->Color4f( 1.0, 1.0, 1.0, 1.0 );
	frame = 0;	

	// rotated view ?
	if ( m_OverviewData.rotated )
	{
		xStep = (2*4096.0f / m_OverviewData.zoom ) / xTiles;
		yStep = -(2*4096.0f / (m_OverviewData.zoom* screenaspect) ) / yTiles;

		y = ys + (4096.0f / (m_OverviewData.zoom * screenaspect));

		for (iy = 0; iy < yTiles; iy++)
		{
			x = xs - (4096.0f / (m_OverviewData.zoom));

			for (ix = 0; ix < xTiles; ix++)
			{
				if ( m_MapSprite )
					gEngfuncs.pTriAPI->SpriteTexture( m_MapSprite, frame );
				else
					gEngfuncs.pTriAPI->SpriteTexture( dummySprite, 0 );

				gEngfuncs.pTriAPI->Begin( TRI_QUADS );
				gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
				gEngfuncs.pTriAPI->Vertex3f (x, y, z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
				gEngfuncs.pTriAPI->Vertex3f (x+xStep ,y,  z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
				gEngfuncs.pTriAPI->Vertex3f (x+xStep, y+yStep, z);

				gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
				gEngfuncs.pTriAPI->Vertex3f (x, y+yStep, z);
				gEngfuncs.pTriAPI->End();

				frame++;
				x+= xStep;
			}

			y+=yStep;
		}
	}
	else
	{
		xStep = -(2*4096.0f / m_OverviewData.zoom ) / xTiles;
		yStep = -(2*4096.0f / (m_OverviewData.zoom* screenaspect) ) / yTiles;


		x = xs + (4096.0f / (m_OverviewData.zoom * screenaspect ));

		
		
		for (ix = 0; ix < yTiles; ix++)
		{
			
			y = ys + (4096.0f / (m_OverviewData.zoom));

			for (iy = 0; iy < xTiles; iy++)
			{
				if ( m_MapSprite )
					gEngfuncs.pTriAPI->SpriteTexture( m_MapSprite, frame );
				else
					gEngfuncs.pTriAPI->SpriteTexture( dummySprite, 0 );

				gEngfuncs.pTriAPI->Begin( TRI_QUADS );
				gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
				gEngfuncs.pTriAPI->Vertex3f (x, y, z);

				gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
				gEngfuncs.pTriAPI->Vertex3f (x+xStep ,y,  z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
				gEngfuncs.pTriAPI->Vertex3f (x+xStep, y+yStep, z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
				gEngfuncs.pTriAPI->Vertex3f (x, y+yStep, z);
				gEngfuncs.pTriAPI->End();

				frame++;
				
				y+=yStep;
			}

			x+= xStep;
			
		}
	}
}

void CHudSpectator::DrawOverviewEntities()
{
	int				i,ir,ig,ib;
	struct model_s *hSpriteModel;
	vec3_t			origin, angles, point, forward, right, left, up, world, screen, offset;
	float			x,y,z, r,g,b, sizeScale = 4.0f;
	cl_entity_t *	ent;
	float rmatrix[3][4];	// transformation matrix
	
	float			zScale = (90.0f - v_angles[0] ) / 90.0f;


	z = m_OverviewData.layersHeights[0] * zScale;
	// get yellow/brown HUD color
	DrawUtils::UnpackRGB( ir, ig, ib, gHUD.m_iDefaultHUDColor );
	r = (float)ir/255.0f;
	g = (float)ig/255.0f;
	b = (float)ib/255.0f;
	
	gEngfuncs.pTriAPI->CullFace( TRI_NONE );

	for (i=0; i < MAX_PLAYERS; i++ )
		m_vPlayerPos[i][2] = -1;	// mark as invisible

	// draw all players
	for (i=0 ; i < MAX_OVERVIEW_ENTITIES ; i++)
	{
		if ( !m_OverviewEntities[i].hSprite )
			continue;

		hSpriteModel = (struct model_s *)gEngfuncs.GetSpritePointer( m_OverviewEntities[i].hSprite );
		ent = m_OverviewEntities[i].entity;
		
		gEngfuncs.pTriAPI->SpriteTexture( hSpriteModel, 0 );
		gEngfuncs.pTriAPI->RenderMode( kRenderTransTexture );

		// see R_DrawSpriteModel
		// draws players sprite

		AngleVectors(ent->angles, right, up, NULL );

		VectorCopy(ent->origin,origin);

		gEngfuncs.pTriAPI->Begin( TRI_QUADS );

		gEngfuncs.pTriAPI->Color4f( 1.0, 1.0, 1.0, 1.0 );

		gEngfuncs.pTriAPI->TexCoord2f (1, 0);
		VectorMA (origin,  16.0f * sizeScale, up, point);
		VectorMA (point,   16.0f * sizeScale, right, point);
		point[2] *= zScale;
		gEngfuncs.pTriAPI->Vertex3fv (point);

		gEngfuncs.pTriAPI->TexCoord2f (0, 0);

		VectorMA (origin,  16.0f * sizeScale, up, point);
		VectorMA (point,  -16.0f * sizeScale, right, point);
		point[2] *= zScale;
		gEngfuncs.pTriAPI->Vertex3fv (point);

		gEngfuncs.pTriAPI->TexCoord2f (0,1);
		VectorMA (origin, -16.0f * sizeScale, up, point);
		VectorMA (point,  -16.0f * sizeScale, right, point);
		point[2] *= zScale;
		gEngfuncs.pTriAPI->Vertex3fv (point);

		gEngfuncs.pTriAPI->TexCoord2f (1,1);
		VectorMA (origin, -16.0f * sizeScale, up, point);
		VectorMA (point,   16.0f * sizeScale, right, point);
		point[2] *= zScale;
		gEngfuncs.pTriAPI->Vertex3fv (point);

		gEngfuncs.pTriAPI->End ();


		if ( !ent->player)
			continue;
		// draw line under player icons
		origin[2] *= zScale;

		gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );

		hSpriteModel = (struct model_s *)gEngfuncs.GetSpritePointer( m_hsprBeam );
		gEngfuncs.pTriAPI->SpriteTexture( hSpriteModel, 0 );

		gEngfuncs.pTriAPI->Color4f(r, g, b, 0.3);

		gEngfuncs.pTriAPI->Begin ( TRI_QUADS );
		gEngfuncs.pTriAPI->TexCoord2f (1, 0);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]+4, origin[1]+4, origin[2]-zScale);
		gEngfuncs.pTriAPI->TexCoord2f (0, 0);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]-4, origin[1]-4, origin[2]-zScale);
		gEngfuncs.pTriAPI->TexCoord2f (0, 1);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]-4, origin[1]-4,z);
		gEngfuncs.pTriAPI->TexCoord2f (1, 1);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]+4, origin[1]+4,z);
		gEngfuncs.pTriAPI->End ();

		gEngfuncs.pTriAPI->Begin ( TRI_QUADS );
		gEngfuncs.pTriAPI->TexCoord2f (1, 0);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]-4, origin[1]+4, origin[2]-zScale);
		gEngfuncs.pTriAPI->TexCoord2f (0, 0);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]+4, origin[1]-4, origin[2]-zScale);
		gEngfuncs.pTriAPI->TexCoord2f (0, 1);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]+4, origin[1]-4,z);
		gEngfuncs.pTriAPI->TexCoord2f (1, 1);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]-4, origin[1]+4,z);
		gEngfuncs.pTriAPI->End ();

		// calculate screen position for name and infromation in hud::draw()
		if ( gEngfuncs.pTriAPI->WorldToScreen(origin,screen) )
			continue;	// object is behind viewer

		screen[0] = XPROJECT(screen[0]);
		screen[1] = YPROJECT(screen[1]);
		screen[2] = 0.0f;

		// calculate some offset under the icon
		origin[0]+=32.0f;
		origin[1]+=32.0f;

		gEngfuncs.pTriAPI->WorldToScreen(origin,offset);

		offset[0] = XPROJECT(offset[0]);
		offset[1] = YPROJECT(offset[1]);
		offset[2] = 0.0f;

		VectorSubtract(offset, screen, offset );

		int playerNum = ent->index - 1;

		m_vPlayerPos[playerNum][0] = screen[0];
		m_vPlayerPos[playerNum][1] = screen[1] + offset.Length();
		m_vPlayerPos[playerNum][2] = 1;	// mark player as visible
	}

	if ( !m_pip->value || !m_drawcone->value )
		return;

	// get current camera position and angle

	if ( m_pip->value == INSET_IN_EYE || g_iUser1 == OBS_IN_EYE )
	{
		V_GetInEyePos( g_iUser2, origin, angles );
	}
	else if ( m_pip->value == INSET_CHASE_FREE  || g_iUser1 == OBS_CHASE_FREE )
	{
		V_GetChasePos( g_iUser2, v_cl_angles, origin, angles );
	}
	else if ( g_iUser1 == OBS_ROAMING )
	{
		VectorCopy( v_sim_org, origin );
		VectorCopy( v_cl_angles, angles );
	}
	else
		V_GetChasePos( g_iUser2, NULL, origin, angles );

	
	// draw camera sprite

	x = origin[0];
	y = origin[1];
	z = origin[2];

	angles[0] = 0; // always show horizontal camera sprite

	hSpriteModel = (struct model_s *)gEngfuncs.GetSpritePointer( m_hsprCamera );
	gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
	gEngfuncs.pTriAPI->SpriteTexture( hSpriteModel, 0 );
	
	
	gEngfuncs.pTriAPI->Color4f( r, g, b, 1.0 );

	AngleVectors(angles, forward, NULL, NULL );
	VectorScale (forward, 512.0f, forward);
	
	offset[0] =  0.0f;
	offset[1] = 45.0f;
	offset[2] =  0.0f;

	AngleMatrix(offset, rmatrix );
	VectorTransform(forward, rmatrix , right );

	offset[1]= -45.0f;
	AngleMatrix(offset, rmatrix );
	VectorTransform(forward, rmatrix , left );

	gEngfuncs.pTriAPI->Begin (TRI_TRIANGLES);
	gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
	gEngfuncs.pTriAPI->Vertex3f (x+right[0], y+right[1], (z+right[2]) * zScale);

	gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
	gEngfuncs.pTriAPI->Vertex3f (x, y, z  * zScale);

	gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
	gEngfuncs.pTriAPI->Vertex3f (x+left[0], y+left[1], (z+left[2]) * zScale);
	gEngfuncs.pTriAPI->End ();

}



void CHudSpectator::DrawOverview()
{
	static bool glClearForce = false;
	static float old_glClearValue;

	// draw only in sepctator mode
	if ( !g_iUser1 || (m_iDrawCycle == 0 &&  ( (g_iUser1 != OBS_MAP_FREE) && (g_iUser1 != OBS_MAP_CHASE) )) || (m_iDrawCycle == 1 && m_pip->value < INSET_MAP_FREE) )
	{
		// fix non clearing background for overview
		if( glClearForce )
		{
			gEngfuncs.Cvar_SetValue("gl_clear", old_glClearValue );
			glClearForce = false;
		}
		return;
	}

	// fix non clearing background for overview
	if( !glClearForce )
	{
		old_glClearValue = CVAR_GET_FLOAT("gl_clear");
		gEngfuncs.Cvar_Set("gl_clear", "1");
		glClearForce = true;
	}

	DrawOverviewLayer();
	DrawOverviewEntities();
	CheckOverviewEntities();
}
void CHudSpectator::CheckOverviewEntities()
{
	double time = gEngfuncs.GetClientTime();

	// removes old entities from list
	for ( int i = 0; i< MAX_OVERVIEW_ENTITIES; i++ )
	{
		// remove entity from list if it is too old
		if ( m_OverviewEntities[i].killTime < time )
		{
			memset( &m_OverviewEntities[i], 0, sizeof (overviewEntity_t) );
		}
	}
}

bool CHudSpectator::AddOverviewEntity( int type, struct cl_entity_s *ent, const char *modelname)
{
	HSPRITE	hSprite = 0;
	double  duration = -1.0f;	// duration -1 means show it only this frame;

	if ( !ent )
		return false;

	if ( type == ET_PLAYER )
	{
		if ( ent->curstate.solid != SOLID_NOT)
		{
			switch ( g_PlayerExtraInfo[ent->index].teamnumber )
			{
			// blue and red teams are swapped in CS and TFC
			case TEAM_TERRORIST: hSprite = m_hsprPlayerRed; break;
			case TEAM_CT: hSprite = m_hsprPlayerBlue; break;
			default: hSprite = m_hsprPlayer; break;
			}

			if( g_PlayerExtraInfo[ent->index].has_c4 )
				hSprite = m_hsprPlayerC4;
			else if( g_PlayerExtraInfo[ent->index].vip )
				hSprite = m_hsprPlayerVIP;

			return AddOverviewEntityToList(hSprite, ent, gEngfuncs.GetClientTime() + duration );
		}
		else
			return false;	// it's an spectator
	}
	/*else if (type == ET_NORMAL)
	{
		return false;
	}
	else
	{
		else return false;
	}*/

	if( !stricmp( modelname, "models/w_c4.mdl" ))
		hSprite = m_hsprBomb;
	else if( !stricmp( modelname, "models/w_backpack.mdl" ))
		hSprite = m_hsprBackpack;
	else if( strstr( modelname, "models/hostage") || strstr( modelname, "models/scientist"))
		hSprite = m_hsprHostage;
	else return false;

	return AddOverviewEntityToList(hSprite, ent, gEngfuncs.GetClientTime() + duration );
}

void CHudSpectator::DeathMessage(int victim)
{
	// find out where the victim is
	cl_entity_t *pl = gEngfuncs.GetEntityByIndex(victim);

	if (pl && pl->player)
		AddOverviewEntityToList(m_hsprPlayerDead, pl, gEngfuncs.GetClientTime() + 2.0f );
}

bool CHudSpectator::AddOverviewEntityToList(HSPRITE sprite, cl_entity_t *ent, double killTime)
{
	for ( int i = 0; i< MAX_OVERVIEW_ENTITIES; i++ )
	{
		// find empty entity slot
		if ( m_OverviewEntities[i].entity == NULL)
		{
			m_OverviewEntities[i].entity = ent;
			m_OverviewEntities[i].hSprite = sprite;
			m_OverviewEntities[i].killTime = killTime;
			return true;
		}
	}

	return false;	// maximum overview entities reached
}
void CHudSpectator::CheckSettings()
{
	// disallow same inset mode as main mode:

	m_pip->value = (int)m_pip->value;
	
	if ( ( g_iUser1 < OBS_MAP_FREE ) && ( m_pip->value == INSET_CHASE_FREE || m_pip->value == INSET_IN_EYE ) )
	{
		// otherwise both would show in World picures
		m_pip->value = INSET_MAP_FREE;
	}

	if ( ( g_iUser1 >= OBS_MAP_FREE ) && ( m_pip->value >= INSET_MAP_FREE ) )
	{
		// both would show map views
		m_pip->value = INSET_CHASE_FREE;
	}

	// disble in intermission screen
	if ( gHUD.m_iIntermission )
		m_pip->value = INSET_OFF;

	// check chat mode
	if ( m_chatEnabled != (gHUD.m_SayText.m_HUD_saytext->value!=0) )
	{
		// hud_saytext changed
		m_chatEnabled = (gHUD.m_SayText.m_HUD_saytext->value!=0);

		if ( gEngfuncs.IsSpectateOnly() )
		{
			// tell proxy our new chat mode
			char chatcmd[32];
			sprintf(chatcmd, "ignoremsg %i", m_chatEnabled?0:1 );
			gEngfuncs.pfnServerCmd(chatcmd);
		}
	}

	// if we are a real player on server don't allow inset window
	// in First Person mode since this is our restricted forcecamera mode 2
	// team number 3 = SPECTATOR see player.h

	if ( ( (g_iTeamNumber == 1) || (g_iTeamNumber == 2)) && (g_iUser1 == OBS_IN_EYE) )
		m_pip->value = INSET_OFF;

	// draw small border around inset view, adjust upper black bar
	//	gViewPort->m_pSpectatorPanel->EnableInsetView( m_pip->value != INSET_OFF );
}

int CHudSpectator::ToggleInset(bool allowOff)
{
	int newInsetMode = (int)m_pip->value + 1;

	if ( g_iUser1 < OBS_MAP_FREE )
	{
		if ( newInsetMode > INSET_MAP_CHASE )
		{
			if (allowOff)
				newInsetMode = INSET_OFF;
			else
				newInsetMode = INSET_MAP_FREE;
		}

		if ( newInsetMode == INSET_CHASE_FREE )
			newInsetMode = INSET_MAP_FREE;
	}
	else
	{
		if ( newInsetMode > INSET_IN_EYE )
		{
			if (allowOff)
				newInsetMode = INSET_OFF;
			else
				newInsetMode = INSET_CHASE_FREE;
		}
	}

	return newInsetMode;
}
void CHudSpectator::Reset()
{
	// Reset HUD
	if ( strcmp( m_OverviewData.map, gEngfuncs.pfnGetLevelName() ) )
	{
		// update level overview if level changed
		ParseOverviewFile();
		LoadMapSprites();
	}

	memset( &m_OverviewEntities, 0, sizeof(m_OverviewEntities));

	SetSpectatorStartPosition();
}

void CHudSpectator::InitHUDData()
{
	m_lastPrimaryObject = m_lastSecondaryObject = 0;
	m_flNextObserverInput = 0.0f;
	m_lastHudMessage = 0;
	m_iSpectatorNumber = 0;
	iJumpSpectator	= 0;
	g_iUser1 = g_iUser2 = 0;

	memset( &m_OverviewData, 0, sizeof(m_OverviewData));
	memset( &m_OverviewEntities, 0, sizeof(m_OverviewEntities));

	if ( gEngfuncs.IsSpectateOnly() || gEngfuncs.pDemoAPI->IsPlayingback() )
		m_autoDirector->value = 1.0f;
	else
		m_autoDirector->value = 0.0f;

	Reset();

	SetModes( OBS_CHASE_FREE, INSET_OFF );

	g_iUser2 = 0; // fake not target until first camera command

	// reset HUD FOV
	gHUD.m_iFOV =  CVAR_GET_FLOAT("default_fov");
}

int CHudSpectator::MsgFunc_Spectator(const char *pszName, int iSize, void *buf)
{
	return 1;
}

int CHudSpectator::MsgFunc_ADStop(const char *pszName, int iSize, void *buf)
{
	m_autoDirector->value = 0;
	return 1;
}

```

`cl_dll/hud_spectator.h`:

```h
//========= Copyright ? 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose:
//
// $NoKeywords: $
//=============================================================================
#pragma once
#ifndef SPECTATOR_H
#define SPECTATOR_H

#include "cl_entity.h"
#include "hud.h"


#define INSET_OFF				0
#define INSET_CHASE_LOCKED		1
#define	INSET_CHASE_FREE		2
#define	INSET_IN_EYE			3
#define	INSET_MAP_FREE			4
#define	INSET_MAP_CHASE			5

#define MAX_SPEC_HUD_MESSAGES	8



#define OVERVIEW_TILE_SIZE		256		// don't change this
#define OVERVIEW_MAX_LAYERS		1

//-----------------------------------------------------------------------------
// Purpose: Handles the drawing of the spectator stuff (camera & top-down map and all the things on it )
//-----------------------------------------------------------------------------

typedef struct overviewInfo_s {
	char		map[64];	// cl.levelname or empty
	vec3_t		origin;		// center of map
	float		zoom;		// zoom of map images
	int			layers;		// how may layers do we have
	float		layersHeights[OVERVIEW_MAX_LAYERS];
	char		layersImages[OVERVIEW_MAX_LAYERS][255];
	qboolean	rotated;	// are map images rotated (90 degrees) ?

	int			insetWindowX;
	int			insetWindowY;
	int			insetWindowHeight;
	int			insetWindowWidth;
} overviewInfo_t;

typedef struct overviewEntity_s {

	HSPRITE					hSprite;
	struct cl_entity_s *	entity;
	double					killTime;
} overviewEntity_t;

#define	 MAX_OVERVIEW_ENTITIES		128

class CHudSpectator : public CHudBase
{
public:
	void Reset();

	int  ToggleInset(bool allowOff);
	void CheckSettings();
	void InitHUDData( void );
	bool AddOverviewEntityToList( HSPRITE sprite, cl_entity_t * ent, double killTime);
	void DeathMessage(int victim);
	bool AddOverviewEntity( int type, struct cl_entity_s *ent, const char *modelname );
	void CheckOverviewEntities();
	void DrawOverview();
	void DrawOverviewEntities();
	void GetMapPosition( float * returnvec );
	void DrawOverviewLayer();
	void LoadMapSprites();
	bool ParseOverviewFile();
	bool IsActivePlayer(cl_entity_t * ent);
	void SetModes(int iMainMode, int iInsetMode);
	void HandleButtonsDown(int ButtonPressed);
	void HandleButtonsUp(int ButtonPressed);
	void FindNextPlayer( bool bReverse );
	void DirectorMessage( int iSize, void *pbuf );
	void SetSpectatorStartPosition();
	CHudMsgFunc(Spectator);
	CHudMsgFunc(ADStop);
	int Init();
	int VidInit();

	int Draw(float flTime);

	int m_iDrawCycle;
	client_textmessage_t m_HUDMessages[MAX_SPEC_HUD_MESSAGES];
	char				m_HUDMessageText[MAX_SPEC_HUD_MESSAGES][128];
	int					m_lastHudMessage;
	overviewInfo_t		m_OverviewData;
	overviewEntity_t	m_OverviewEntities[MAX_OVERVIEW_ENTITIES];
	int					m_iObserverFlags;
	int					m_iSpectatorNumber;

	float				m_mapZoom;		// zoom the user currently uses
	vec3_t				m_mapOrigin;	// origin where user rotates around
	cvar_t *			m_drawnames;
	cvar_t *			m_drawcone;
	cvar_t *			m_drawstatus;
	cvar_t *			m_HUD_saytext;
	cvar_t *			m_autoDirector;
	float				m_lastAutoDirector;
	cvar_t *			m_pip;


	qboolean			m_chatEnabled;

	vec3_t				m_cameraOrigin;	// a help camera
	vec3_t				m_cameraAngles;	// and it's angles


private:
	vec3_t		m_vPlayerPos[MAX_PLAYERS];
	HSPRITE		m_hsprPlayerC4;
	HSPRITE		m_hsprPlayerVIP;
	HSPRITE		m_hsprHostage;
	HSPRITE		m_hsprBackpack;
	HSPRITE		m_hsprBomb;
	HSPRITE		m_hsprPlayerBlue;
	HSPRITE		m_hsprPlayerRed;
	HSPRITE		m_hsprPlayer;
	HSPRITE		m_hsprCamera;
	HSPRITE		m_hsprPlayerDead;
	HSPRITE		m_hsprViewcone;
	HSPRITE		m_hsprUnkownMap;
	HSPRITE		m_hsprBeam;

	wrect_t		m_crosshairRect;

	struct model_s * m_MapSprite;	// each layer image is saved in one sprite, where each tile is a sprite frame
	float		m_flNextObserverInput;
	float		m_zoomDelta;
	float		m_moveDelta;
	int			m_lastPrimaryObject;
	int			m_lastSecondaryObject;
};

#endif // SPECTATOR_H

```

`cl_dll/hud_update.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  hud_update.cpp
//

#include <math.h>
#include "hud.h"
#include "cl_util.h"
#include <stdlib.h>
#include <memory.h>

int CL_ButtonBits( int );
void CL_ResetButtonBits( int bits );

extern float v_idlescale;
extern void HUD_SetCmdBits( int bits );

int CHud::UpdateClientData(client_data_t *cdata, float time)
{
	m_vecOrigin = cdata->origin;
	m_vecAngles = cdata->viewangles;

	m_iKeyBits = CL_ButtonBits( 0 );
	m_iWeaponBits = cdata->iWeaponBits;

	Think();

	cdata->fov = m_iFOV;
	
	v_idlescale = m_iConcussionEffect;

	CL_ResetButtonBits( m_iKeyBits );

	// return 1 if in anything in the client_data struct has been changed, 0 otherwise
	return 1;
}



```

`cl_dll/in_camera.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include "hud.h"
#include "cl_util.h"
#include "camera.h"
#include "kbutton.h"
#include "cvardef.h"
#include "usercmd.h"
#include "const.h"
#include "camera.h"
#include "in_defs.h"
#ifdef _WIN32
#include "port.h"
#endif
float CL_KeyState (kbutton_t *key);

extern cl_enginefunc_t gEngfuncs;

//-------------------------------------------------- Constants

#define CAM_DIST_DELTA 1.0
#define CAM_ANGLE_DELTA 2.5
#define CAM_ANGLE_SPEED 2.5
#define CAM_MIN_DIST 30.0
#define CAM_ANGLE_MOVE .5
#define MAX_ANGLE_DIFF 10.0
#define PITCH_MAX 90.0
#define PITCH_MIN 0
#define YAW_MAX  135.0
#define YAW_MIN	 -135.0

enum ECAM_Command
{
	CAM_COMMAND_NONE = 0,
	CAM_COMMAND_TOTHIRDPERSON = 1,
	CAM_COMMAND_TOFIRSTPERSON = 2
};

//-------------------------------------------------- Global Variables

cvar_t	*cam_command;
cvar_t	*cam_snapto;
cvar_t	*cam_idealyaw;
cvar_t	*cam_idealpitch;
cvar_t	*cam_idealdist;
cvar_t	*cam_contain;

cvar_t	*c_maxpitch;
cvar_t	*c_minpitch;
cvar_t	*c_maxyaw;
cvar_t	*c_minyaw;
cvar_t	*c_maxdistance;
cvar_t	*c_mindistance;

// pitch, yaw, dist
vec3_t cam_ofs;

// In third person
int cam_thirdperson;
int cam_mousemove; //true if we are moving the cam with the mouse, False if not
int iMouseInUse=0;
int cam_distancemove;
extern int mouse_x, mouse_y;  //used to determine what the current x and y values are
int cam_old_mouse_x, cam_old_mouse_y; //holds the last ticks mouse movement
POINT		cam_mouse;
//-------------------------------------------------- Local Variables

static kbutton_t cam_pitchup, cam_pitchdown, cam_yawleft, cam_yawright;
static kbutton_t cam_in, cam_out;

//-------------------------------------------------- Prototypes

void CAM_ToThirdPerson(void);
void CAM_ToFirstPerson(void);
void CAM_StartDistance(void);
void CAM_EndDistance(void);


//-------------------------------------------------- Local Functions

float MoveToward( float cur, float goal, float maxspeed )
{
	if( cur != goal )
	{
		if( fabs( cur - goal ) > 180.0 )
		{
			if( cur < goal )
				cur += 360.0;
			else
				cur -= 360.0;
		}

		if( cur < goal )
		{
			if( cur < goal - 1.0 )
				cur += ( goal - cur ) / 4.0;
			else
				cur = goal;
		}
		else
		{
			if( cur > goal + 1.0 )
				cur -= ( cur - goal ) / 4.0;
			else
				cur = goal;
		}
	}


	// bring cur back into range
	if( cur < 0 )
		cur += 360.0;
	else if( cur >= 360 )
		cur -= 360;

	return cur;
}


//-------------------------------------------------- Global Functions

struct moveclip_t
{
	vec3_t		boxmins, boxmaxs;// enclose the test object along entire move
	float		*mins, *maxs;	// size of the moving object
	vec3_t		mins2, maxs2;	// size when clipping against mosnters
	float		*start, *end;
	trace_t		trace;
	int			type;
	edict_t		*passedict;
	qboolean	monsterclip;
};

void DLLEXPORT CAM_Think( void )
{
	vec3_t origin;
	vec3_t ext, pnt, camForward, camRight, camUp;
	moveclip_t	clip;
	float dist;
	vec3_t camAngles;
	float flSensitivity;
	vec3_t viewangles;

	switch( (int) cam_command->value )
	{
		case CAM_COMMAND_TOTHIRDPERSON:
			CAM_ToThirdPerson();
			break;

		case CAM_COMMAND_TOFIRSTPERSON:
			CAM_ToFirstPerson();
			break;

		case CAM_COMMAND_NONE:
		default:
			break;
	}

	if( !cam_thirdperson )
		return;
	
	camAngles[ PITCH ] = cam_idealpitch->value;
	camAngles[ YAW ] = cam_idealyaw->value;
	dist = cam_idealdist->value;
	//
	//movement of the camera with the mouse
	//
	if (cam_mousemove)
	{
	    //get windows cursor position
		GetCursorPos (&cam_mouse);
		//check for X delta values and adjust accordingly
		//eventually adjust YAW based on amount of movement
	  //don't do any movement of the cam using YAW/PITCH if we are zooming in/out the camera	
	  if (!cam_distancemove)
	  {
		
		//keep the camera within certain limits around the player (ie avoid certain bad viewing angles)  
		if (cam_mouse.x>gEngfuncs.GetWindowCenterX())
		{
			//if ((camAngles[YAW]>=225.0)||(camAngles[YAW]<135.0))
			if (camAngles[YAW]<c_maxyaw->value)
			{
				camAngles[ YAW ] += (CAM_ANGLE_MOVE)*((cam_mouse.x-gEngfuncs.GetWindowCenterX())/2);
			}
			if (camAngles[YAW]>c_maxyaw->value)
			{
				
				camAngles[YAW]=c_maxyaw->value;
			}
		}
		else if (cam_mouse.x<gEngfuncs.GetWindowCenterX())
		{
			//if ((camAngles[YAW]<=135.0)||(camAngles[YAW]>225.0))
			if (camAngles[YAW]>c_minyaw->value)
			{
			   camAngles[ YAW ] -= (CAM_ANGLE_MOVE)* ((gEngfuncs.GetWindowCenterX()-cam_mouse.x)/2);
			   	
			}
			if (camAngles[YAW]<c_minyaw->value)
			{
				camAngles[YAW]=c_minyaw->value;
				
			}
		}

		//check for y delta values and adjust accordingly
		//eventually adjust PITCH based on amount of movement
		//also make sure camera is within bounds
		if (cam_mouse.y>gEngfuncs.GetWindowCenterY())
		{
			if(camAngles[PITCH]<c_maxpitch->value)
			{
			    camAngles[PITCH] +=(CAM_ANGLE_MOVE)* ((cam_mouse.y-gEngfuncs.GetWindowCenterY())/2);
			}
			if (camAngles[PITCH]>c_maxpitch->value)
			{
				camAngles[PITCH]=c_maxpitch->value;
			}
		}
		else if (cam_mouse.y<gEngfuncs.GetWindowCenterY())
		{
			if (camAngles[PITCH]>c_minpitch->value)
			{
			   camAngles[PITCH] -= (CAM_ANGLE_MOVE)*((gEngfuncs.GetWindowCenterY()-cam_mouse.y)/2);
			}
			if (camAngles[PITCH]<c_minpitch->value)
			{
				camAngles[PITCH]=c_minpitch->value;
			}
		}

		//set old mouse coordinates to current mouse coordinates
		//since we are done with the mouse

		if ( ( flSensitivity = gHUD.GetSensitivity() ) != 0 )
		{
			cam_old_mouse_x=cam_mouse.x*flSensitivity;
			cam_old_mouse_y=cam_mouse.y*flSensitivity;
		}
		else
		{
			cam_old_mouse_x=cam_mouse.x;
			cam_old_mouse_y=cam_mouse.y;
		}
		SetCursorPos (gEngfuncs.GetWindowCenterX(), gEngfuncs.GetWindowCenterY());
	  }
	}

	//Nathan code here
	if( CL_KeyState( &cam_pitchup ) )
		camAngles[ PITCH ] += CAM_ANGLE_DELTA;
	else if( CL_KeyState( &cam_pitchdown ) )
		camAngles[ PITCH ] -= CAM_ANGLE_DELTA;

	if( CL_KeyState( &cam_yawleft ) )
		camAngles[ YAW ] -= CAM_ANGLE_DELTA;
	else if( CL_KeyState( &cam_yawright ) )
		camAngles[ YAW ] += CAM_ANGLE_DELTA;

	if( CL_KeyState( &cam_in ) )
	{
		dist -= CAM_DIST_DELTA;
		if( dist < CAM_MIN_DIST )
		{
			// If we go back into first person, reset the angle
			camAngles[ PITCH ] = 0;
			camAngles[ YAW ] = 0;
			dist = CAM_MIN_DIST;
		}

	}
	else if( CL_KeyState( &cam_out ) )
		dist += CAM_DIST_DELTA;

	if (cam_distancemove)
	{
		if (cam_mouse.y>gEngfuncs.GetWindowCenterY())
		{
			if(dist<c_maxdistance->value)
			{
				dist +=CAM_DIST_DELTA * ((cam_mouse.y-gEngfuncs.GetWindowCenterY())/2.0);
			}
			if (dist>c_maxdistance->value)
			{
				dist=c_maxdistance->value;
			}
		}
		else if (cam_mouse.y<gEngfuncs.GetWindowCenterY())
		{
			if (dist>c_mindistance->value)
			{
			   dist -= (CAM_DIST_DELTA)*((gEngfuncs.GetWindowCenterY()-cam_mouse.y)/2.0);
			}
			if (dist<c_mindistance->value)
			{
				dist=c_mindistance->value;
			}
		}
		//set old mouse coordinates to current mouse coordinates
		//since we are done with the mouse
		cam_old_mouse_x=cam_mouse.x*gHUD.GetSensitivity();
		cam_old_mouse_y=cam_mouse.y*gHUD.GetSensitivity();
		SetCursorPos (gEngfuncs.GetWindowCenterX(), gEngfuncs.GetWindowCenterY());
	}
	// update ideal
	cam_idealpitch->value = camAngles[ PITCH ];
	cam_idealyaw->value = camAngles[ YAW ];
	cam_idealdist->value = dist;

	// Move towards ideal
	VectorCopy( cam_ofs, camAngles );

	gEngfuncs.GetViewAngles( (float *)viewangles );

	if( cam_snapto->value )
	{
		camAngles[ YAW ] = cam_idealyaw->value + viewangles[ YAW ];
		camAngles[ PITCH ] = cam_idealpitch->value + viewangles[ PITCH ];
		camAngles[ 2 ] = cam_idealdist->value;
	}
	else
	{
		if( camAngles[ YAW ] - viewangles[ YAW ] != cam_idealyaw->value )
			camAngles[ YAW ] = MoveToward( camAngles[ YAW ], cam_idealyaw->value + viewangles[ YAW ], CAM_ANGLE_SPEED );

		if( camAngles[ PITCH ] - viewangles[ PITCH ] != cam_idealpitch->value )
			camAngles[ PITCH ] = MoveToward( camAngles[ PITCH ], cam_idealpitch->value + viewangles[ PITCH ], CAM_ANGLE_SPEED );

		if( fabs( camAngles[ 2 ] - cam_idealdist->value ) < 2.0 )
			camAngles[ 2 ] = cam_idealdist->value;
		else
			camAngles[ 2 ] += ( cam_idealdist->value - camAngles[ 2 ] ) / 4.0;
	}
	cam_ofs[ 0 ] = camAngles[ 0 ];
	cam_ofs[ 1 ] = camAngles[ 1 ];
	cam_ofs[ 2 ] = dist;
}

extern void KeyDown (kbutton_t *b);	// HACK
extern void KeyUp (kbutton_t *b);	// HACK

void CAM_PitchUpDown(void) { KeyDown( &cam_pitchup ); }
void CAM_PitchUpUp(void) { KeyUp( &cam_pitchup ); }
void CAM_PitchDownDown(void) { KeyDown( &cam_pitchdown ); }
void CAM_PitchDownUp(void) { KeyUp( &cam_pitchdown ); }
void CAM_YawLeftDown(void) { KeyDown( &cam_yawleft ); }
void CAM_YawLeftUp(void) { KeyUp( &cam_yawleft ); }
void CAM_YawRightDown(void) { KeyDown( &cam_yawright ); }
void CAM_YawRightUp(void) { KeyUp( &cam_yawright ); }
void CAM_InDown(void) { KeyDown( &cam_in ); }
void CAM_InUp(void) { KeyUp( &cam_in ); }
void CAM_OutDown(void) { KeyDown( &cam_out ); }
void CAM_OutUp(void) { KeyUp( &cam_out ); }

void CAM_ToThirdPerson(void)
{ 
	vec3_t viewangles;

#if !defined( _DEBUG )
	if ( gEngfuncs.GetMaxClients() > 1 )
	{
		// no thirdperson in multiplayer.
		return;
	}
#endif

	gEngfuncs.GetViewAngles( (float *)viewangles );

	if( !cam_thirdperson )
	{
		cam_thirdperson = 1; 
		
		cam_ofs[ YAW ] = viewangles[ YAW ]; 
		cam_ofs[ PITCH ] = viewangles[ PITCH ]; 
		cam_ofs[ 2 ] = CAM_MIN_DIST; 
	}

	gEngfuncs.Cvar_SetValue( "cam_command", 0 );
}

void CAM_ToFirstPerson(void) 
{ 
	cam_thirdperson = 0;
	
	gEngfuncs.Cvar_SetValue( "cam_command", 0 );
}

void CAM_ToggleSnapto( void )
{ 
	gEngfuncs.Cvar_SetValue( "cam_snapto", cam_snapto->value ? 0.0 : 1.0 );
	//cam_snapto->value = !cam_snapto->value;
}

void CAM_Init( void )
{
	gEngfuncs.pfnAddCommand( "+campitchup", CAM_PitchUpDown );
	gEngfuncs.pfnAddCommand( "-campitchup", CAM_PitchUpUp );
	gEngfuncs.pfnAddCommand( "+campitchdown", CAM_PitchDownDown );
	gEngfuncs.pfnAddCommand( "-campitchdown", CAM_PitchDownUp );
	gEngfuncs.pfnAddCommand( "+camyawleft", CAM_YawLeftDown );
	gEngfuncs.pfnAddCommand( "-camyawleft", CAM_YawLeftUp );
	gEngfuncs.pfnAddCommand( "+camyawright", CAM_YawRightDown );
	gEngfuncs.pfnAddCommand( "-camyawright", CAM_YawRightUp );
	gEngfuncs.pfnAddCommand( "+camin", CAM_InDown );
	gEngfuncs.pfnAddCommand( "-camin", CAM_InUp );
	gEngfuncs.pfnAddCommand( "+camout", CAM_OutDown );
	gEngfuncs.pfnAddCommand( "-camout", CAM_OutUp );
	gEngfuncs.pfnAddCommand( "thirdperson", CAM_ToThirdPerson );
	gEngfuncs.pfnAddCommand( "firstperson", CAM_ToFirstPerson );
	gEngfuncs.pfnAddCommand( "+cammousemove",CAM_StartMouseMove);
	gEngfuncs.pfnAddCommand( "-cammousemove",CAM_EndMouseMove);
	gEngfuncs.pfnAddCommand( "+camdistance", CAM_StartDistance );
	gEngfuncs.pfnAddCommand( "-camdistance", CAM_EndDistance );
	gEngfuncs.pfnAddCommand( "snapto", CAM_ToggleSnapto );

	cam_command				= gEngfuncs.pfnRegisterVariable ( "cam_command", "0", 0 );	 // tells camera to go to thirdperson
	cam_snapto				= gEngfuncs.pfnRegisterVariable ( "cam_snapto", "0", 0 );	 // snap to thirdperson view
	cam_idealyaw			= gEngfuncs.pfnRegisterVariable ( "cam_idealyaw", "90", 0 );	 // thirdperson yaw
	cam_idealpitch			= gEngfuncs.pfnRegisterVariable ( "cam_idealpitch", "0", 0 );	 // thirperson pitch
	cam_idealdist			= gEngfuncs.pfnRegisterVariable ( "cam_idealdist", "64", 0 );	 // thirdperson distance
	cam_contain				= gEngfuncs.pfnRegisterVariable ( "cam_contain", "0", 0 );	// contain camera to world

	c_maxpitch				= gEngfuncs.pfnRegisterVariable ( "c_maxpitch", "90.0", 0 );
	c_minpitch				= gEngfuncs.pfnRegisterVariable ( "c_minpitch", "0.0", 0 );
	c_maxyaw				= gEngfuncs.pfnRegisterVariable ( "c_maxyaw",   "135.0", 0 );
	c_minyaw				= gEngfuncs.pfnRegisterVariable ( "c_minyaw",   "-135.0", 0 );
	c_maxdistance			= gEngfuncs.pfnRegisterVariable ( "c_maxdistance",   "200.0", 0 );
	c_mindistance			= gEngfuncs.pfnRegisterVariable ( "c_mindistance",   "30.0", 0 );
}

void CAM_ClearStates( void )
{
	vec3_t viewangles;

	gEngfuncs.GetViewAngles( (float *)viewangles );

	cam_pitchup.state = 0;
	cam_pitchdown.state = 0;
	cam_yawleft.state = 0;
	cam_yawright.state = 0;
	cam_in.state = 0;
	cam_out.state = 0;

	cam_thirdperson = 0;
	cam_command->value = 0;
	cam_mousemove=0;

	cam_snapto->value = 0;
	cam_distancemove = 0;

	cam_ofs[ 0 ] = 0.0;
	cam_ofs[ 1 ] = 0.0;
	cam_ofs[ 2 ] = CAM_MIN_DIST;

	cam_idealpitch->value = viewangles[ PITCH ];
	cam_idealyaw->value = viewangles[ YAW ];
	cam_idealdist->value = CAM_MIN_DIST;
}

void CAM_StartMouseMove(void)
{
	float flSensitivity;
		
	//only move the cam with mouse if we are in third person.
	if (cam_thirdperson)
	{
		//set appropriate flags and initialize the old mouse position
		//variables for mouse camera movement
		if (!cam_mousemove)
		{
			cam_mousemove=1;
			iMouseInUse=1;
			GetCursorPos (&cam_mouse);

			if ( ( flSensitivity = gHUD.GetSensitivity() ) != 0 )
			{
				cam_old_mouse_x=cam_mouse.x*flSensitivity;
				cam_old_mouse_y=cam_mouse.y*flSensitivity;
			}
			else
			{
				cam_old_mouse_x=cam_mouse.x;
				cam_old_mouse_y=cam_mouse.y;
			}
		}
	}
	//we are not in 3rd person view..therefore do not allow camera movement
	else
	{   
		cam_mousemove=0;
		iMouseInUse=0;
	}
}

//the key has been released for camera movement
//tell the engine that mouse camera movement is off
void CAM_EndMouseMove(void)
{
   cam_mousemove=0;
   iMouseInUse=0;
}


//----------------------------------------------------------
//routines to start the process of moving the cam in or out 
//using the mouse
//----------------------------------------------------------
void CAM_StartDistance(void)
{
	//only move the cam with mouse if we are in third person.
	if (cam_thirdperson)
	{
	  //set appropriate flags and initialize the old mouse position
	  //variables for mouse camera movement
	  if (!cam_distancemove)
	  {
		  cam_distancemove=1;
		  cam_mousemove=1;
		  iMouseInUse=1;
		  GetCursorPos (&cam_mouse);
		  cam_old_mouse_x=cam_mouse.x*gHUD.GetSensitivity();
		  cam_old_mouse_y=cam_mouse.y*gHUD.GetSensitivity();
	  }
	}
	//we are not in 3rd person view..therefore do not allow camera movement
	else
	{   
		cam_distancemove=0;
		cam_mousemove=0;
		iMouseInUse=0;
	}
}

//the key has been released for camera movement
//tell the engine that mouse camera movement is off
void CAM_EndDistance(void)
{
   cam_distancemove=0;
   cam_mousemove=0;
   iMouseInUse=0;
}

int DLLEXPORT CL_IsThirdPerson( void )
{
	return (cam_thirdperson ? 1 : 0) || (g_iUser1 && gEngfuncs.GetLocalPlayer() && (g_iUser2 == gEngfuncs.GetLocalPlayer()->index) );
}

void DLLEXPORT CL_CameraOffset( float *ofs )
{
	VectorCopy( cam_ofs, ofs );
}

```

`cl_dll/include/camera.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// Camera.h  --  defines and such for a 3rd person camera
// NOTE: must include quakedef.h first
#pragma once
#ifndef _CAMERA_H_
#define _CAMEA_H_

// pitch, yaw, dist
extern vec3_t cam_ofs;
// Using third person camera
extern int cam_thirdperson;

void CAM_Init( void );
void CAM_ClearStates( void );
void CAM_StartMouseMove(void);
void CAM_EndMouseMove(void);

#endif		// _CAMERA_H_

```

`cl_dll/include/cl_dll.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cl_dll.h
//

// 4-23-98  JOHN
#pragma once
#ifndef CL_DLL_H
#define CL_DLL_H
//
//  This DLL is linked by the client when they first initialize.
// This DLL is responsible for the following tasks:
//		- Loading the HUD graphics upon initialization
//		- Drawing the HUD graphics every frame
//		- Handling the custum HUD-update packets
//
typedef unsigned char byte;
typedef unsigned short word;
typedef float vec_t;
typedef int (*pfnUserMsgHook)(const char *pszName, int iSize, void *pbuf);

#define MIN_XASH_VERSION 3137

#include <stdint.h>

#include "util_vector.h"

#include "../engine/cdll_int.h"
#include "../dlls/cdll_dll.h"

#include "exportdef.h"

#include "render_api.h"
#include "mobility_int.h"

extern "C"
{
int        DLLEXPORT Initialize( cl_enginefunc_t *pEnginefuncs, int iVersion );
int        DLLEXPORT HUD_VidInit( void );
void       DLLEXPORT HUD_Init( void );
int        DLLEXPORT HUD_Redraw( float flTime, int intermission );
int        DLLEXPORT HUD_UpdateClientData( client_data_t *cdata, float flTime );
void       DLLEXPORT HUD_Reset( void );
void       DLLEXPORT HUD_PlayerMove( struct playermove_s *ppmove, int server );
void       DLLEXPORT HUD_PlayerMoveInit( struct playermove_s *ppmove );
char       DLLEXPORT HUD_PlayerMoveTexture( char *name );
int        DLLEXPORT HUD_ConnectionlessPacket( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );
int        DLLEXPORT HUD_GetHullBounds( int hullnumber, float *mins, float *maxs );
void       DLLEXPORT HUD_Frame( double time );
void       DLLEXPORT HUD_VoiceStatus( int entindex, qboolean bTalking );
void       DLLEXPORT HUD_DirectorMessage( int iSize, void *pbuf );
int        DLLEXPORT HUD_GetRenderInterface( int version, render_api_t *renderfuncs, render_interface_t *callback );
int        DLLEXPORT HUD_MobilityInterface( mobile_engfuncs_t *mobileapi );
void       DLLEXPORT HUD_PostRunCmd( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
int        DLLEXPORT HUD_AddEntity( int type, struct cl_entity_s *ent, const char *modelname );
void       DLLEXPORT HUD_CreateEntities( void );
void       DLLEXPORT HUD_StudioEvent(const struct mstudioevent_s *event, cl_entity_s *entity );
void       DLLEXPORT HUD_TxferLocalOverrides( struct entity_state_s *state, const struct clientdata_s *client );
void       DLLEXPORT HUD_ProcessPlayerState( struct entity_state_s *dst, const struct entity_state_s *src );
void       DLLEXPORT HUD_TxferPredictionData( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd );
void       DLLEXPORT HUD_TempEntUpdate( double frametime, double client_time, double cl_gravity, struct tempent_s **ppTempEntFree, struct tempent_s **ppTempEntActive, int ( *Callback_AddVisibleEntity )( struct cl_entity_s *pEntity ), void ( *Callback_TempEntPlaySound )( struct tempent_s *pTemp, float damp ) );
void       DLLEXPORT HUD_Shutdown( void );
int        DLLEXPORT HUD_Key_Event( int eventcode, int keynum, const char *pszCurrentBinding );
int        DLLEXPORT HUD_GetStudioModelInterface( int version, struct r_studio_interface_s **ppinterface, struct engine_studio_api_s *pstudio );
void       DLLEXPORT HUD_DrawNormalTriangles( void );
void       DLLEXPORT HUD_DrawTransparentTriangles( void );
void       DLLEXPORT CAM_Think( void );
int        DLLEXPORT CL_IsThirdPerson( void );
void       DLLEXPORT CL_CameraOffset( float *ofs );
void       DLLEXPORT CL_CreateMove( float frametime, struct usercmd_s *cmd, int active );
void       DLLEXPORT IN_ActivateMouse( void );
void       DLLEXPORT IN_DeactivateMouse( void );
void       DLLEXPORT IN_MouseEvent( int mstate );
void       DLLEXPORT IN_Accumulate( void );
void       DLLEXPORT IN_ClearStates( void );
void       DLLEXPORT V_CalcRefdef( struct ref_params_s *pparams );
void       DLLEXPORT Demo_ReadBuffer( int size, unsigned char *buffer );
struct cl_entity_s DLLEXPORT *HUD_GetUserEntity( int index );
struct kbutton_s   DLLEXPORT *KB_Find( const char *name );

void       DLLEXPORT IN_ClientMoveEvent( float forwardmove, float sidemove );
void       DLLEXPORT IN_ClientLookEvent( float relyaw, float relpitch );
}


extern cl_enginefunc_t gEngfuncs;
extern render_api_t gRenderAPI;
extern mobile_engfuncs_t gMobileAPI;
extern int g_iXash; // indicates buildnum
extern int g_iMobileAPIVersion; // indicates version. 0 if no mobile API
#endif // CL_DLL_H

```

`cl_dll/include/com_weapons.h`:

```h
//========= Copyright пїЅ 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
// com_weapons.h
// Shared weapons common function prototypes
#if !defined( COM_WEAPONSH )
#define COM_WEAPONSH


#include "hud_iface.h"
#include "weapontype.h"
#define PLAYER_CAN_SHOOT (1 << 0)
#define PLAYER_FREEZE_TIME_OVER ( 1 << 1 )
#define PLAYER_IN_BOMB_ZONE (1 << 2)
#define PLAYER_HOLDING_SHIELD (1 << 3)

#define CROSSHAIR_
#define ACCURACY_AIR (1 << 0) // accuracy depends on FL_ONGROUND
#define ACCURACY_SPEED (1 << 1)
#define ACCURACY_DUCK (1 << 2) // more accurate when ducking
#define ACCURACY_MULTIPLY_BY_14 (1 << 3) // accuracy multiply to 1.4
#define ACCURACY_MULTIPLY_BY_14_2 (1 << 4) // accuracy multiply to 1.4

extern "C"
{
	void _DLLEXPORT HUD_PostRunCmd( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
}

bool			CL_IsDead();

float			UTIL_SharedRandomFloat( unsigned int seed, float low, float high );
int				UTIL_SharedRandomLong( unsigned int seed, int low, int high );

int				HUD_GetWeaponAnim( void );
void			HUD_SendWeaponAnim(int iAnim, int iWeaponId, int iBody, int iForce = 0 );
int				HUD_GetWeapon( void );
void			HUD_PlaySound( char *sound, float volume );
void			HUD_PlaybackEvent( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
//void			HUD_SetMaxSpeed( const struct edict_s *ed, float speed );
int				GetWeaponAccuracyFlags( int weaponid );

extern cvar_t *cl_lw;

extern int g_runfuncs;
extern vec3_t v_angles;
extern float g_lastFOV;
extern int g_iWeaponFlags;
extern bool g_bInBombZone;
extern int g_iFreezeTimeOver;
extern bool g_bHoldingShield;
extern bool g_bHoldingKnife;
extern int g_iPlayerFlags;
extern float g_flPlayerSpeed;
extern Vector g_vPlayerVelocity;
extern struct local_state_s *g_curstate;
extern struct local_state_s *g_finalstate;
extern int g_iShotsFired;

#endif

```

`cl_dll/include/csprite.h`:

```h

/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#pragma once
#ifndef CSPRITE_H
#define CSPRITE_H

// defined in util.cpp
HSPRITE HUD_GetSprite( int index );
wrect_t HUD_GetSpriteRect( int index );
int HUD_GetSpriteIndexByName( const char *sz );

class CClientSprite {
public:
	inline CClientSprite(const char *sprName)
	{
		SetSpriteByName(sprName);
	}
	inline CClientSprite()
	{
		spr = 0;
		index = 0;
		rect.bottom = rect.left = rect.right = rect.top = 0;
	}

	inline void SetSpriteByName( const char *sprName )
	{
		index = HUD_GetSpriteIndexByName(sprName);
		spr	= HUD_GetSprite(index);
		rect = HUD_GetSpriteRect(index);
	}

	int index;
	HSPRITE spr;
	wrect_t rect;
};

#endif 

```

`cl_dll/include/demo.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined( DEMOH )
#define DEMOH

// Types of demo messages we can write/parse
enum
{
	TYPE_SNIPERDOT = 0,
	TYPE_ZOOM
};

void Demo_WriteBuffer( int type, int size, unsigned char *buffer );

extern int g_demosniper;
extern int g_demosniperdamage;
extern float g_demosniperorg[3];
extern float g_demosniperangles[3];
extern float g_demozoom;

#endif
```

`cl_dll/include/draw_util.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#pragma once
#ifndef DRAW_UTIL_H
#define DRAW_UTIL_H
// Drawing primitives

#define DHN_DRAWZERO 1
#define DHN_2DIGITS  2
#define DHN_3DIGITS  4

extern int g_codepage;
extern qboolean g_accept_utf8;

extern cvar_t *con_charset;
extern cvar_t *cl_charset;


int Con_UtfProcessChar( int in );
int Con_UtfProcessCharForce( int in );

class DrawUtils
{
public:
	static int DrawHudNumber(int x, int y, int iFlags, int iNumber,
						 int r, int g, int b );

	static int DrawHudNumber2( int x, int y, bool DrawZero, int iDigits, int iNumber,
						   int r, int g, int b);

	static int DrawHudNumber2( int x, int y, int iNumber,
						   int r, int g, int b);

	static int DrawHudString(int x, int y, int iMaxX, const char *szString,
						 int r, int g, int b, float scale = 0.0f, bool drawing = false );

	static int DrawHudStringReverse( int xpos, int ypos, int iMinX, const char *szString,
								 int r, int g, int b, float scale = 0.0f, bool drawing = false );

	static inline int DrawHudNumberString( int xpos, int ypos, int iMinX, int iNumber,
								int r, int g, int b, float scale = 0.0f )
	{
		char szString[16];
		snprintf( szString, sizeof(szString), "%d", iNumber );
		return DrawHudStringReverse( xpos, ypos, iMinX, szString, r, g, b, scale );
	}

	static int HudStringLen( const char *szIt, float scale = 1 );

	// legacy shit came with Valve
	static inline int GetNumWidth(int iNumber, int iFlags)
	{
		if ( iFlags & ( DHN_3DIGITS ) )
			return 3;

		if ( iFlags & ( DHN_2DIGITS ) )
			return 2;

		if ( iNumber <= 0 )
			return iFlags & DHN_DRAWZERO ? 1 : 0;

		if ( iNumber < 10 )
			return 1;

		if ( iNumber < 100 )
			return 2;

		return 3;
	}

	static inline int DrawConsoleString(int x, int y, const char *string)
	{
		if ( gHUD.hud_textmode->value )
		{
			int ret  = DrawHudString( x, y, 9999, (char *)string, color[0] * 255, color[1] * 255, color[2] * 255 );
			color[0] = color[1] = color[2] = 1.0f;
			return ret;
		}
		else
			return gEngfuncs.pfnDrawConsoleString( x, y, (char *)string );
	}

	static inline void SetConsoleTextColor( float r, float g, float b )
	{
		if ( gHUD.hud_textmode->value )
			color[0] = r, color[1] = g, color[2] = b;
		else
			gEngfuncs.pfnDrawSetTextColor( r, g, b );
	}

	static inline void SetConsoleTextColor( unsigned char r, unsigned char g, unsigned char b )
	{
		if ( gHUD.hud_textmode->value )
			color[0] = r / 255.0f, color[1] = g / 255.0f, color[2] = b / 255.0f;
		else
			gEngfuncs.pfnDrawSetTextColor( r / 255.0f, g / 255.0f, b / 255.0f );
	}

	static inline int ConsoleStringLen(  const char *szIt )
	{
		if ( gHUD.hud_textmode->value )
		{
			return HudStringLen( (char *)szIt );
		}
		else
		{
			int _width;
			int _height;

			gEngfuncs.pfnDrawConsoleStringLen( szIt, &_width, &_height );
			return _width;
		}
	}

	static inline void ConsoleStringSize( const char *szIt, int *width, int *height )
	{
		if ( gHUD.hud_textmode->value )
			*height = 13, *width = HudStringLen( (char *)szIt );
		else
			gEngfuncs.pfnDrawConsoleStringLen( szIt, width, height );
	}

	static inline int TextMessageDrawChar( int x, int y, int number, int r, int g, int b, float scale = 0.0f )
	{
		int ret;
		if( scale && g_iMobileAPIVersion )
			ret = gMobileAPI.pfnDrawScaledCharacter( x, y, number, r, g, b, scale ) / gHUD.m_flScale;
		else
			ret = gEngfuncs.pfnDrawCharacter( x, y, number, r, g, b );
		return ret;
	}

	static inline void UnpackRGB( int &r, int &g, int &b, const unsigned long ulRGB )
	{
		r = (ulRGB & 0xFF0000) >>16;
		g = (ulRGB & 0xFF00) >> 8;
		b = ulRGB & 0xFF;
	}

	static inline void ScaleColors( int &r, int &g, int &b, const int a )
	{
		r *= a / 255.0f;
		g *= a / 255.0f;
		b *= a / 255.0f;
	}

	static inline void DrawRectangle( int x, int y, int wide, int tall,
						   int r = 0, int g = 0, int b = 0, int a = 153,
						   bool drawStroke = true )
	{
		FillRGBABlend( x, y, wide, tall, r, g, b, a );
		if ( drawStroke )
		{
			// TODO: remove this hardcoded hardcore
			FillRGBA( x + 1,        y,            wide - 1, 1,        255, 140, 0, 255 );
			FillRGBA( x,            y,            1,        tall - 1, 255, 140, 0, 255 );
			FillRGBA( x + wide - 1, y + 1,        1,        tall - 1, 255, 140, 0, 255 );
			FillRGBA( x,            y + tall - 1, wide - 1, 1,        255, 140, 0, 255 );
		}
	}

	static void Draw2DQuad( float x1, float y1, float x2, float y2 );
	static void DrawStretchPic( float x, float y, float w, float h,
								float s1 = 0, float t1 = 0, float s2 = 1, float t2 = 1);


private:
	// console string color
	static float color[3];
};

#endif // DRAW_UTIL_H

```

`cl_dll/include/ev_hldm.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined ( EV_HLDMH )
#define EV_HLDMH

enum ESmoke
{
	SMOKE_WALLPUFF = 0,
	SMOKE_RIFLE,
	SMOKE_PISTOL,
	SMOKE_BLACK
};

void EV_HLDM_GunshotDecalTrace(pmtrace_t *pTrace, char *decalName , char chTextureType);
void EV_HLDM_DecalGunshot(pmtrace_t *pTrace, int iBulletType, float scale, int r, int g, int b, bool bCreateSparks, char cTextureType, bool isSky);
void EV_HLDM_FireBullets(int idx,
						 float *forward, float *right, float *up,
						 int cShots,
						 float *vecSrc, float *vecDirShooting, float *vecSpread,
						 float flDistance, int iBulletType, int iPenetration);
void EV_CS16Client_KillEveryRound( struct tempent_s *te, float frametime, float currenttime );
struct tempent_s *EV_CS16Client_CreateSmoke( ESmoke type, Vector origin, Vector dir, int speed, float scale, int r, int g, int b , bool wind, Vector velocity = Vector(0, 0, 0), int framerate = 35, int teflags = FTENT_COLLIDEALL );
#endif // EV_HLDMH

```

`cl_dll/include/events.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#pragma once
#ifndef EVENTS_H
#define EVENTS_H

#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"

#include "r_efx.h"

#include "eventscripts.h"
#include "event_api.h"
#include "pm_defs.h"
#include "ev_hldm.h"
#include "com_weapons.h"

#ifndef PITCH
// MOVEMENT INFO
// up / down
#define	PITCH	0
// left / right
#define	YAW		1
// fall over
#define	ROLL	2
#endif

#define DECLARE_EVENT( x ) void EV_##x( struct event_args_s *args )
#define HOOK_EVENT( x, y ) gEngfuncs.pfnHookEvent( "events/" #x ".sc", EV_##y )

#define PLAY_EVENT_SOUND( x ) gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, (x), VOL_NORM, ATTN_NORM, 0, 94 + gEngfuncs.pfnRandomLong( 0, 15 ) )


// enable it until fix isn't applied in Xash3D
//#define _CS16CLIENT_FIX_EVENT_ORIGIN

extern int g_iPShell;
extern int g_iRShell;
extern int g_iShotgunShell;

extern "C"
{
DECLARE_EVENT(FireAK47);
DECLARE_EVENT(FireAUG);
DECLARE_EVENT(FireAWP);
DECLARE_EVENT(CreateExplo);
DECLARE_EVENT(CreateSmoke);
DECLARE_EVENT(FireDEAGLE);
DECLARE_EVENT(DecalReset);
DECLARE_EVENT(FireEliteLeft);
DECLARE_EVENT(FireEliteRight);
DECLARE_EVENT(FireFAMAS);
DECLARE_EVENT(Fire57);
DECLARE_EVENT(FireG3SG1);
DECLARE_EVENT(FireGALIL);
DECLARE_EVENT(Fireglock18);
DECLARE_EVENT(Knife);
DECLARE_EVENT(FireM249);
DECLARE_EVENT(FireM3);
DECLARE_EVENT(FireM4A1);
DECLARE_EVENT(FireMAC10);
DECLARE_EVENT(FireMP5);
DECLARE_EVENT(FireP228);
DECLARE_EVENT(FireP90);
DECLARE_EVENT(FireScout);
DECLARE_EVENT(FireSG550);
DECLARE_EVENT(FireSG552);
DECLARE_EVENT(FireTMP);
DECLARE_EVENT(FireUMP45);
DECLARE_EVENT(FireUSP);
DECLARE_EVENT(Vehicle);
DECLARE_EVENT(FireXM1014);
DECLARE_EVENT(TrainPitchAdjust);

// CZERODS START
DECLARE_EVENT( FireM60 );
DECLARE_EVENT( FireCamera );
DECLARE_EVENT( FireFiberOpticCamera );
DECLARE_EVENT( FireShieldGun );
DECLARE_EVENT( HolsterBlowtorch );
DECLARE_EVENT( IdleBlowtorch );
DECLARE_EVENT( FireBlowtorch );
DECLARE_EVENT( FireLaws );
DECLARE_EVENT( FireBriefcase );
DECLARE_EVENT( FireMedkit );
DECLARE_EVENT( FireSyringe );
DECLARE_EVENT( FireRadio );
DECLARE_EVENT( FireZipline );
DECLARE_EVENT( CreateGlass );
DECLARE_EVENT( GrenadeExplosion );
// CZERODS END
}

void Game_HookEvents( void );

#endif

```

`cl_dll/include/eventscripts.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
// eventscripts.h
#if !defined ( EVENTSCRIPTSH )
#define EVENTSCRIPTSH

#include "pmtrace.h"
#include "pm_shared.h"
#include "event_api.h"
#include "r_efx.h"

// defaults for clientinfo messages
#define	DEFAULT_VIEWHEIGHT	17
#define VEC_DUCK_VIEW 12

#define FTENT_FADEOUT			0x00000080

#define DMG_GENERIC			0			// generic damage was done
#define DMG_CRUSH			(1 << 0)	// crushed by falling or moving object
#define DMG_BULLET			(1 << 1)	// shot
#define DMG_SLASH			(1 << 2)	// cut, clawed, stabbed
#define DMG_BURN			(1 << 3)	// heat burned
#define DMG_FREEZE			(1 << 4)	// frozen
#define DMG_FALL			(1 << 5)	// fell too far
#define DMG_BLAST			(1 << 6)	// explosive blast damage
#define DMG_CLUB			(1 << 7)	// crowbar, punch, headbutt
#define DMG_SHOCK			(1 << 8)	// electric shock
#define DMG_SONIC			(1 << 9)	// sound pulse shockwave
#define DMG_ENERGYBEAM		(1 << 10)	// laser or other high energy beam 
#define DMG_NEVERGIB		(1 << 12)	// with this bit OR'd in, no damage type will be able to gib victims upon death
#define DMG_ALWAYSGIB		(1 << 13)	// with this bit OR'd in, any damage type can be made to gib victims upon death.

// time-based damage
//mask off TF-specific stuff too
#define DMG_TIMEBASED		(~(0xff003fff))	// mask for time-based damage

#define DMG_DROWN			(1 << 14)	// Drowning
#define DMG_FIRSTTIMEBASED  DMG_DROWN

#define DMG_PARALYZE		(1 << 15)	// slows affected creature down
#define DMG_NERVEGAS		(1 << 16)	// nerve toxins, very bad
#define DMG_POISON			(1 << 17)	// blood poisioning
#define DMG_RADIATION		(1 << 18)	// radiation exposure
#define DMG_DROWNRECOVER	(1 << 19)	// drowning recovery
#define DMG_ACID			(1 << 20)	// toxic chemicals or acid burns
#define DMG_SLOWBURN		(1 << 21)	// in an oven
#define DMG_SLOWFREEZE		(1 << 22)	// in a subzero freezer
#define DMG_MORTAR			(1 << 23)	// Hit by air raid (done to distinguish grenade from mortar)

//TF ADDITIONS
#define DMG_IGNITE			(1 << 24)	// Players hit by this begin to burn
#define DMG_RADIUS_MAX		(1 << 25)	// Radius damage with this flag doesn't decrease over distance
#define DMG_RADIUS_QUAKE	(1 << 26)	// Radius damage is done like Quake. 1/2 damage at 1/2 radius.
#define DMG_IGNOREARMOR		(1 << 27)	// Damage ignores target's armor
#define DMG_AIMED			(1 << 28)   // Does Hit location damage
#define DMG_WALLPIERCING	(1 << 29)	// Blast Damages ents through walls

#define DMG_CALTROP				(1<<30)
#define DMG_HALLUC				(1<<31)

#define IS_FIRSTPERSON_SPEC ( g_iUser1 == OBS_IN_EYE || (g_iUser1 && (gHUD.m_Spectator.m_pip->value == INSET_IN_EYE)) )

// Some of these are HL/TFC specific?
void EV_GetGunPosition( struct event_args_s *args, Vector &pos, const Vector &origin );
void EV_GetDefaultShellInfo( struct event_args_s *args, float *origin, float *velocity, float *ShellVelocity, float *ShellOrigin, float *forward, float *right, float *up, float forwardScale, float upScale, float rightScale, bool bReverseDirection = false );
void CreateCorpse(Vector vOrigin, Vector vAngles, const char *pModel, float flAnimTime, int iSequence, int iBody);


// Very simple and little functions that can be inlined

/*
=================
EV_MuzzleFlash

Flag weapon/view model for muzzle flash
=================
*/
inline void EV_MuzzleFlash( void )
{
	// Add muzzle flash to current weapon model
	cl_entity_t *ent = gEngfuncs.GetViewModel();
	if ( !ent )
		return;

	// Or in the muzzle flash
	ent->curstate.effects |= EF_MUZZLEFLASH;
}

/*
=================
EV_IsPlayer

Is the entity's index in the player range?
=================
*/
inline bool EV_IsPlayer( int idx )
{
	if ( idx >= 1 && idx <= gEngfuncs.GetMaxClients() )
		return true;

	return false;
}


/*
=================
EV_IsLocal

Is the entity == the local player
=================
*/
inline bool EV_IsLocal( int idx )
{
	// check if we are in some way in first person spec mode
	if ( IS_FIRSTPERSON_SPEC  )
		return (g_iUser2 == idx);
	else
		return gEngfuncs.pEventAPI->EV_IsLocal( idx - 1 ) ? true : false;
}

/*
=================
EV_EjectBrass

Bullet shell casings
=================
*/
inline void EV_EjectBrass( float *origin, float *velocity, float rotation, int model, int soundtype, float life = 2.5f )
{
	Vector angles(0.0f, 0.0f, rotation);
	gEngfuncs.pEfxAPI->R_TempModel( origin, velocity, angles, life, model, soundtype );
}


#endif // EVENTSCRIPTS_H

```

`cl_dll/include/hud/ammo.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#pragma once
#ifndef __AMMO_H__
#define __AMMO_H__

#define MAX_WEAPON_NAME 128


#define WEAPON_FLAGS_SELECTONEMPTY	1

#define WEAPON_IS_ONTARGET 0x40

struct WEAPON
{
	char	szName[MAX_WEAPON_NAME];
	int		iAmmoType;
	int		iAmmo2Type;
	int		iMax1;
	int		iMax2;
	int		iSlot;
	int		iSlotPos;
	int		iFlags;
	int		iId;
	int		iClip;

	int		iCount;		// # of itesm in plist

	HSPRITE hActive;
	wrect_t rcActive;
	HSPRITE hInactive;
	wrect_t rcInactive;
	HSPRITE	hAmmo;
	wrect_t rcAmmo;
	HSPRITE hAmmo2;
	wrect_t rcAmmo2;
	HSPRITE hCrosshair;
	wrect_t rcCrosshair;
	HSPRITE hAutoaim;
	wrect_t rcAutoaim;
	HSPRITE hZoomedCrosshair;
	wrect_t rcZoomedCrosshair;
	HSPRITE hZoomedAutoaim;
	wrect_t rcZoomedAutoaim;
};

typedef int AMMO;


#endif
```

`cl_dll/include/hud/hud_iface.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined( HUD_IFACEH )
#define HUD_IFACEH

#include "exportdef.h"

typedef int (*pfnUserMsgHook)(const char *pszName, int iSize, void *pbuf);
#include "wrect.h"
#include "../engine/cdll_int.h"
extern cl_enginefunc_t gEngfuncs;

#endif

```

`cl_dll/include/hud/radar.h`:

```h
/*
radar.h
Copyright (C) 2015 a1batross
*/
#pragma once
#ifndef RADAR_H
#define RADAR_H

class CClientSprite;

class CHudRadar: public CHudBase
{
public:
	virtual int Init();
	virtual int VidInit();
	virtual int Draw( float flTime );
	virtual void InitHUDData();
	virtual void Reset();
	virtual void Shutdown();

	int MsgFunc_Radar(const char *pszName,  int iSize, void *pbuf);

	void UserCmd_ShowRadar();
	void UserCmd_HideRadar();
	CClientSprite m_hRadar;
	CClientSprite m_hRadarOpaque;

	int MsgFunc_BombDrop(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_BombPickup(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_HostagePos(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_HostageK(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_Location(const char *pszName, int iSize, void *pbuf);
private:

	cvar_t *cl_radartype;

	int InitBuiltinTextures();
	void DrawPlayerLocation(int y);
	void DrawRadarDot(int x, int y, int r, int g, int b, int a);
	void DrawCross(int x, int y, int r, int g, int b, int a );

	// Call DrawT, DrawFlippedT or DrawRadarDot considering z value
	inline void DrawZAxis( Vector pos, int r, int g, int b, int a );

	void DrawT( int x, int y, int r, int g, int b, int a );
	void DrawFlippedT( int x, int y, int r, int g, int b, int a );
	bool HostageFlashTime( float flTime, struct hostage_info_t *pplayer );
	bool FlashTime( float flTime, struct extra_player_info_t *pplayer );
	Vector WorldToRadar(const Vector vPlayerOrigin, const Vector vObjectOrigin, const Vector vAngles );
	inline void DrawColoredTexture( int x, int y, int size, byte r, byte g, byte b, byte a, int texHandle );

	bool bUseRenderAPI, bTexturesInitialized;
	int hCross, hT, hFlippedT;
	int iMaxRadius;
};

#endif // RADAR_H

```

`cl_dll/include/in_defs.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined( IN_DEFSH )
#define IN_DEFSH

// up / down
#define	PITCH	0
// left / right
#define	YAW		1
// fall over
#define	ROLL	2 

#ifdef _WIN32
#define HSPRITE WINAPI_HSPRITE
#include <windows.h>
#undef HSPRITE
#else
#ifndef PORT_H
typedef struct point_s{
	int x;
	int y;
} POINT;
#endif
#define GetCursorPos(x)
#define SetCursorPos(x,y)
#endif

#endif

```

`cl_dll/include/input.h`:

```h
#pragma once
#ifndef INPUT_H
#define INPUT_H

extern kbutton_t	in_strafe;
extern kbutton_t	in_mlook;
extern kbutton_t	in_speed;
extern kbutton_t	in_jlook;
extern kbutton_t	in_forward;
extern kbutton_t	in_back;
extern kbutton_t	in_moveleft;
extern kbutton_t	in_moveright;

extern cvar_t	*m_pitch;
extern cvar_t	*m_yaw;
extern cvar_t	*m_forward;
extern cvar_t	*m_side;

extern cvar_t *lookstrafe;
extern cvar_t *lookspring;
extern cvar_t *cl_pitchdown;
extern cvar_t *cl_pitchup;
extern cvar_t *cl_yawspeed;
extern cvar_t *cl_sidespeed;
extern cvar_t *cl_forwardspeed;
extern cvar_t *cl_pitchspeed;
extern cvar_t *cl_movespeedkey;

#endif // INPUT_H

```

`cl_dll/include/kbutton.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined( KBUTTONH )
#define KBUTTONH

typedef struct kbutton_s
{
	int		down[2];		// key nums holding it down
	int		state;			// low bit is down state
} kbutton_t;

#endif // !KBUTTONH
```

`cl_dll/include/math/neon_mathfun.h`:

```h
/* NEON implementation of sin, cos, exp and log

   Inspired by Intel Approximate Math library, and based on the
   corresponding algorithms of the cephes math library
*/

/* Copyright (C) 2011  Julien Pommier

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  (this is the zlib license)
*/

#include <arm_neon.h>

typedef float32x4_t v4sf;  // vector of 4 float
typedef uint32x4_t v4su;  // vector of 4 uint32
typedef int32x4_t v4si;  // vector of 4 uint32

#define c_inv_mant_mask ~0x7f800000u
#define c_cephes_SQRTHF 0.707106781186547524
#define c_cephes_log_p0 7.0376836292E-2
#define c_cephes_log_p1 - 1.1514610310E-1
#define c_cephes_log_p2 1.1676998740E-1
#define c_cephes_log_p3 - 1.2420140846E-1
#define c_cephes_log_p4 + 1.4249322787E-1
#define c_cephes_log_p5 - 1.6668057665E-1
#define c_cephes_log_p6 + 2.0000714765E-1
#define c_cephes_log_p7 - 2.4999993993E-1
#define c_cephes_log_p8 + 3.3333331174E-1
#define c_cephes_log_q1 -2.12194440e-4
#define c_cephes_log_q2 0.693359375

/* natural logarithm computed for 4 simultaneous float 
   return NaN for x <= 0
*/
v4sf log_ps(v4sf x) {
  v4sf one = vdupq_n_f32(1);

  x = vmaxq_f32(x, vdupq_n_f32(0)); /* force flush to zero on denormal values */
  v4su invalid_mask = vcleq_f32(x, vdupq_n_f32(0));

  v4si ux = vreinterpretq_s32_f32(x);
  
  v4si emm0 = vshrq_n_s32(ux, 23);

  /* keep only the fractional part */
  ux = vandq_s32(ux, vdupq_n_s32(c_inv_mant_mask));
  ux = vorrq_s32(ux, vreinterpretq_s32_f32(vdupq_n_f32(0.5f)));
  x = vreinterpretq_f32_s32(ux);

  emm0 = vsubq_s32(emm0, vdupq_n_s32(0x7f));
  v4sf e = vcvtq_f32_s32(emm0);

  e = vaddq_f32(e, one);

  /* part2: 
     if( x < SQRTHF ) {
       e -= 1;
       x = x + x - 1.0;
     } else { x = x - 1.0; }
  */
  v4su mask = vcltq_f32(x, vdupq_n_f32(c_cephes_SQRTHF));
  v4sf tmp = vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(x), mask));
  x = vsubq_f32(x, one);
  e = vsubq_f32(e, vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(one), mask)));
  x = vaddq_f32(x, tmp);

  v4sf z = vmulq_f32(x,x);

  v4sf y = vdupq_n_f32(c_cephes_log_p0);
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p1));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p2));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p3));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p4));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p5));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p6));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p7));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p8));
  y = vmulq_f32(y, x);

  y = vmulq_f32(y, z);
  

  tmp = vmulq_f32(e, vdupq_n_f32(c_cephes_log_q1));
  y = vaddq_f32(y, tmp);


  tmp = vmulq_f32(z, vdupq_n_f32(0.5f));
  y = vsubq_f32(y, tmp);

  tmp = vmulq_f32(e, vdupq_n_f32(c_cephes_log_q2));
  x = vaddq_f32(x, y);
  x = vaddq_f32(x, tmp);
  x = vreinterpretq_f32_u32(vorrq_u32(vreinterpretq_u32_f32(x), invalid_mask)); // negative arg will be NAN
  return x;
}

#define c_exp_hi 88.3762626647949f
#define c_exp_lo -88.3762626647949f

#define c_cephes_LOG2EF 1.44269504088896341
#define c_cephes_exp_C1 0.693359375
#define c_cephes_exp_C2 -2.12194440e-4

#define c_cephes_exp_p0 1.9875691500E-4
#define c_cephes_exp_p1 1.3981999507E-3
#define c_cephes_exp_p2 8.3334519073E-3
#define c_cephes_exp_p3 4.1665795894E-2
#define c_cephes_exp_p4 1.6666665459E-1
#define c_cephes_exp_p5 5.0000001201E-1

/* exp() computed for 4 float at once */
v4sf exp_ps(v4sf x) {
  v4sf tmp, fx;

  v4sf one = vdupq_n_f32(1);
  x = vminq_f32(x, vdupq_n_f32(c_exp_hi));
  x = vmaxq_f32(x, vdupq_n_f32(c_exp_lo));

  /* express exp(x) as exp(g + n*log(2)) */
  fx = vmlaq_f32(vdupq_n_f32(0.5f), x, vdupq_n_f32(c_cephes_LOG2EF));

  /* perform a floorf */
  tmp = vcvtq_f32_s32(vcvtq_s32_f32(fx));

  /* if greater, subtract 1 */
  v4su mask = vcgtq_f32(tmp, fx);    
  mask = vandq_u32(mask, vreinterpretq_u32_f32(one));


  fx = vsubq_f32(tmp, vreinterpretq_f32_u32(mask));

  tmp = vmulq_f32(fx, vdupq_n_f32(c_cephes_exp_C1));
  v4sf z = vmulq_f32(fx, vdupq_n_f32(c_cephes_exp_C2));
  x = vsubq_f32(x, tmp);
  x = vsubq_f32(x, z);

  static const float cephes_exp_p[6] = { c_cephes_exp_p0, c_cephes_exp_p1, c_cephes_exp_p2, c_cephes_exp_p3, c_cephes_exp_p4, c_cephes_exp_p5 };
  v4sf y = vld1q_dup_f32(cephes_exp_p+0);
  v4sf c1 = vld1q_dup_f32(cephes_exp_p+1); 
  v4sf c2 = vld1q_dup_f32(cephes_exp_p+2); 
  v4sf c3 = vld1q_dup_f32(cephes_exp_p+3); 
  v4sf c4 = vld1q_dup_f32(cephes_exp_p+4); 
  v4sf c5 = vld1q_dup_f32(cephes_exp_p+5);

  y = vmulq_f32(y, x);
  z = vmulq_f32(x,x);
  y = vaddq_f32(y, c1);
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, c2);
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, c3);
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, c4);
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, c5);
  
  y = vmulq_f32(y, z);
  y = vaddq_f32(y, x);
  y = vaddq_f32(y, one);

  /* build 2^n */
  int32x4_t mm;
  mm = vcvtq_s32_f32(fx);
  mm = vaddq_s32(mm, vdupq_n_s32(0x7f));
  mm = vshlq_n_s32(mm, 23);
  v4sf pow2n = vreinterpretq_f32_s32(mm);

  y = vmulq_f32(y, pow2n);
  return y;
}

#define c_minus_cephes_DP1 -0.78515625
#define c_minus_cephes_DP2 -2.4187564849853515625e-4
#define c_minus_cephes_DP3 -3.77489497744594108e-8
#define c_sincof_p0 -1.9515295891E-4
#define c_sincof_p1  8.3321608736E-3
#define c_sincof_p2 -1.6666654611E-1
#define c_coscof_p0  2.443315711809948E-005
#define c_coscof_p1 -1.388731625493765E-003
#define c_coscof_p2  4.166664568298827E-002
#define c_cephes_FOPI 1.27323954473516 // 4 / M_PI

/* evaluation of 4 sines & cosines at once.

   The code is the exact rewriting of the cephes sinf function.
   Precision is excellent as long as x < 8192 (I did not bother to
   take into account the special handling they have for greater values
   -- it does not return garbage for arguments over 8192, though, but
   the extra precision is missing).

   Note that it is such that sinf((float)M_PI) = 8.74e-8, which is the
   surprising but correct result.

   Note also that when you compute sin(x), cos(x) is available at
   almost no extra price so both sin_ps and cos_ps make use of
   sincos_ps..
  */
void sincos_ps(v4sf x, v4sf *ysin, v4sf *ycos) { // any x
  v4sf xmm1, xmm2, xmm3, y;

  v4su emm2;
  
  v4su sign_mask_sin, sign_mask_cos;
  sign_mask_sin = vcltq_f32(x, vdupq_n_f32(0));
  x = vabsq_f32(x);

  /* scale by 4/Pi */
  y = vmulq_f32(x, vdupq_n_f32(c_cephes_FOPI));

  /* store the integer part of y in mm0 */
  emm2 = vcvtq_u32_f32(y);
  /* j=(j+1) & (~1) (see the cephes sources) */
  emm2 = vaddq_u32(emm2, vdupq_n_u32(1));
  emm2 = vandq_u32(emm2, vdupq_n_u32(~1));
  y = vcvtq_f32_u32(emm2);

  /* get the polynom selection mask 
     there is one polynom for 0 <= x <= Pi/4
     and another one for Pi/4<x<=Pi/2

     Both branches will be computed.
  */
  v4su poly_mask = vtstq_u32(emm2, vdupq_n_u32(2));
  
  /* The magic pass: "Extended precision modular arithmetic" 
     x = ((x - y * DP1) - y * DP2) - y * DP3; */
  xmm1 = vmulq_n_f32(y, c_minus_cephes_DP1);
  xmm2 = vmulq_n_f32(y, c_minus_cephes_DP2);
  xmm3 = vmulq_n_f32(y, c_minus_cephes_DP3);
  x = vaddq_f32(x, xmm1);
  x = vaddq_f32(x, xmm2);
  x = vaddq_f32(x, xmm3);

  sign_mask_sin = veorq_u32(sign_mask_sin, vtstq_u32(emm2, vdupq_n_u32(4)));
  sign_mask_cos = vtstq_u32(vsubq_u32(emm2, vdupq_n_u32(2)), vdupq_n_u32(4));

  /* Evaluate the first polynom  (0 <= x <= Pi/4) in y1, 
     and the second polynom      (Pi/4 <= x <= 0) in y2 */
  v4sf z = vmulq_f32(x,x);
  v4sf y1, y2;

  y1 = vmulq_n_f32(z, c_coscof_p0);
  y2 = vmulq_n_f32(z, c_sincof_p0);
  y1 = vaddq_f32(y1, vdupq_n_f32(c_coscof_p1));
  y2 = vaddq_f32(y2, vdupq_n_f32(c_sincof_p1));
  y1 = vmulq_f32(y1, z);
  y2 = vmulq_f32(y2, z);
  y1 = vaddq_f32(y1, vdupq_n_f32(c_coscof_p2));
  y2 = vaddq_f32(y2, vdupq_n_f32(c_sincof_p2));
  y1 = vmulq_f32(y1, z);
  y2 = vmulq_f32(y2, z);
  y1 = vmulq_f32(y1, z);
  y2 = vmulq_f32(y2, x);
  y1 = vsubq_f32(y1, vmulq_f32(z, vdupq_n_f32(0.5f)));
  y2 = vaddq_f32(y2, x);
  y1 = vaddq_f32(y1, vdupq_n_f32(1));

  /* select the correct result from the two polynoms */  
  v4sf ys = vbslq_f32(poly_mask, y1, y2);
  v4sf yc = vbslq_f32(poly_mask, y2, y1);
  *ysin = vbslq_f32(sign_mask_sin, vnegq_f32(ys), ys);
  *ycos = vbslq_f32(sign_mask_cos, yc, vnegq_f32(yc));
}

v4sf sin_ps(v4sf x) {
  v4sf ysin, ycos; 
  sincos_ps(x, &ysin, &ycos); 
  return ysin;
}

v4sf cos_ps(v4sf x) {
  v4sf ysin, ycos; 
  sincos_ps(x, &ysin, &ycos); 
  return ycos;
}



```

`cl_dll/include/math/sse_mathfun.h`:

```h
/* SIMD (SSE1+MMX or SSE2) implementation of sin, cos, exp and log

   Inspired by Intel Approximate Math library, and based on the
   corresponding algorithms of the cephes math library

   The default is to use the SSE1 version. If you define USE_SSE2 the
   the SSE2 intrinsics will be used in place of the MMX intrinsics. Do
   not expect any significant performance improvement with SSE2.
*/

/* Copyright (C) 2007  Julien Pommier

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  (this is the zlib license)
*/

#include <xmmintrin.h>

/* yes I know, the top of this file is quite ugly */

#ifdef _MSC_VER /* visual c++ */
# define ALIGN16_BEG __declspec(align(16))
# define ALIGN16_END 
#else /* gcc or icc */
# define ALIGN16_BEG
# define ALIGN16_END __attribute__((aligned(16)))
#endif

/* __m128 is ugly to write */
typedef __m128 v4sf;  // vector of 4 float (sse1)

#ifdef USE_SSE2
# include <emmintrin.h>
typedef __m128i v4si; // vector of 4 int (sse2)
#else
typedef __m64 v2si;   // vector of 2 int (mmx)
#endif

/* declare some SSE constants -- why can't I figure a better way to do that? */
#define _PS_CONST(Name, Val)                                            \
  static const ALIGN16_BEG float _ps_##Name[4] ALIGN16_END = { Val, Val, Val, Val }
#define _PI32_CONST(Name, Val)                                            \
  static const ALIGN16_BEG int _pi32_##Name[4] ALIGN16_END = { Val, Val, Val, Val }
#define _PS_CONST_TYPE(Name, Type, Val)                                 \
  static const ALIGN16_BEG Type _ps_##Name[4] ALIGN16_END = { Val, Val, Val, Val }

_PS_CONST(1  , 1.0f);
_PS_CONST(0p5, 0.5f);
/* the smallest non denormalized float number */
_PS_CONST_TYPE(min_norm_pos, int, 0x00800000);
_PS_CONST_TYPE(mant_mask, int, 0x7f800000);
_PS_CONST_TYPE(inv_mant_mask, int, ~0x7f800000);

_PS_CONST_TYPE(sign_mask, int, (int)0x80000000);
_PS_CONST_TYPE(inv_sign_mask, int, ~0x80000000);

_PI32_CONST(1, 1);
_PI32_CONST(inv1, ~1);
_PI32_CONST(2, 2);
_PI32_CONST(4, 4);
_PI32_CONST(0x7f, 0x7f);

_PS_CONST(cephes_SQRTHF, 0.707106781186547524);
_PS_CONST(cephes_log_p0, 7.0376836292E-2);
_PS_CONST(cephes_log_p1, - 1.1514610310E-1);
_PS_CONST(cephes_log_p2, 1.1676998740E-1);
_PS_CONST(cephes_log_p3, - 1.2420140846E-1);
_PS_CONST(cephes_log_p4, + 1.4249322787E-1);
_PS_CONST(cephes_log_p5, - 1.6668057665E-1);
_PS_CONST(cephes_log_p6, + 2.0000714765E-1);
_PS_CONST(cephes_log_p7, - 2.4999993993E-1);
_PS_CONST(cephes_log_p8, + 3.3333331174E-1);
_PS_CONST(cephes_log_q1, -2.12194440e-4);
_PS_CONST(cephes_log_q2, 0.693359375);

#ifndef USE_SSE2
typedef union xmm_mm_union {
  __m128 xmm;
  __m64 mm[2];
} xmm_mm_union;

#define COPY_XMM_TO_MM(xmm_, mm0_, mm1_) {          \
    xmm_mm_union u; u.xmm = xmm_;                   \
    mm0_ = u.mm[0];                                 \
    mm1_ = u.mm[1];                                 \
}

#define COPY_MM_TO_XMM(mm0_, mm1_, xmm_) {                         \
    xmm_mm_union u; u.mm[0]=mm0_; u.mm[1]=mm1_; xmm_ = u.xmm;      \
  }

#endif // USE_SSE2

/* natural logarithm computed for 4 simultaneous float 
   return NaN for x <= 0
*/
v4sf log_ps(v4sf x) {
#ifdef USE_SSE2
  v4si emm0;
#else
  v2si mm0, mm1;
#endif
  v4sf one = *(v4sf*)_ps_1;

  v4sf invalid_mask = _mm_cmple_ps(x, _mm_setzero_ps());

  x = _mm_max_ps(x, *(v4sf*)_ps_min_norm_pos);  /* cut off denormalized stuff */

#ifndef USE_SSE2
  /* part 1: x = frexpf(x, &e); */
  COPY_XMM_TO_MM(x, mm0, mm1);
  mm0 = _mm_srli_pi32(mm0, 23);
  mm1 = _mm_srli_pi32(mm1, 23);
#else
  emm0 = _mm_srli_epi32(_mm_castps_si128(x), 23);
#endif
  /* keep only the fractional part */
  x = _mm_and_ps(x, *(v4sf*)_ps_inv_mant_mask);
  x = _mm_or_ps(x, *(v4sf*)_ps_0p5);

#ifndef USE_SSE2
  /* now e=mm0:mm1 contain the really base-2 exponent */
  mm0 = _mm_sub_pi32(mm0, *(v2si*)_pi32_0x7f);
  mm1 = _mm_sub_pi32(mm1, *(v2si*)_pi32_0x7f);
  v4sf e = _mm_cvtpi32x2_ps(mm0, mm1);
  _mm_empty(); /* bye bye mmx */
#else
  emm0 = _mm_sub_epi32(emm0, *(v4si*)_pi32_0x7f);
  v4sf e = _mm_cvtepi32_ps(emm0);
#endif

  e = _mm_add_ps(e, one);

  /* part2: 
     if( x < SQRTHF ) {
       e -= 1;
       x = x + x - 1.0;
     } else { x = x - 1.0; }
  */
  v4sf mask = _mm_cmplt_ps(x, *(v4sf*)_ps_cephes_SQRTHF);
  v4sf tmp = _mm_and_ps(x, mask);
  x = _mm_sub_ps(x, one);
  e = _mm_sub_ps(e, _mm_and_ps(one, mask));
  x = _mm_add_ps(x, tmp);


  v4sf z = _mm_mul_ps(x,x);

  v4sf y = *(v4sf*)_ps_cephes_log_p0;
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p1);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p2);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p3);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p4);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p5);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p6);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p7);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p8);
  y = _mm_mul_ps(y, x);

  y = _mm_mul_ps(y, z);
  

  tmp = _mm_mul_ps(e, *(v4sf*)_ps_cephes_log_q1);
  y = _mm_add_ps(y, tmp);


  tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
  y = _mm_sub_ps(y, tmp);

  tmp = _mm_mul_ps(e, *(v4sf*)_ps_cephes_log_q2);
  x = _mm_add_ps(x, y);
  x = _mm_add_ps(x, tmp);
  x = _mm_or_ps(x, invalid_mask); // negative arg will be NAN
  return x;
}

_PS_CONST(exp_hi,	88.3762626647949f);
_PS_CONST(exp_lo,	-88.3762626647949f);

_PS_CONST(cephes_LOG2EF, 1.44269504088896341);
_PS_CONST(cephes_exp_C1, 0.693359375);
_PS_CONST(cephes_exp_C2, -2.12194440e-4);

_PS_CONST(cephes_exp_p0, 1.9875691500E-4);
_PS_CONST(cephes_exp_p1, 1.3981999507E-3);
_PS_CONST(cephes_exp_p2, 8.3334519073E-3);
_PS_CONST(cephes_exp_p3, 4.1665795894E-2);
_PS_CONST(cephes_exp_p4, 1.6666665459E-1);
_PS_CONST(cephes_exp_p5, 5.0000001201E-1);

v4sf exp_ps(v4sf x) {
  v4sf tmp = _mm_setzero_ps(), fx;
#ifdef USE_SSE2
  v4si emm0;
#else
  v2si mm0, mm1;
#endif
  v4sf one = *(v4sf*)_ps_1;

  x = _mm_min_ps(x, *(v4sf*)_ps_exp_hi);
  x = _mm_max_ps(x, *(v4sf*)_ps_exp_lo);

  /* express exp(x) as exp(g + n*log(2)) */
  fx = _mm_mul_ps(x, *(v4sf*)_ps_cephes_LOG2EF);
  fx = _mm_add_ps(fx, *(v4sf*)_ps_0p5);

  /* how to perform a floorf with SSE: just below */
#ifndef USE_SSE2
  /* step 1 : cast to int */
  tmp = _mm_movehl_ps(tmp, fx);
  mm0 = _mm_cvttps_pi32(fx);
  mm1 = _mm_cvttps_pi32(tmp);
  /* step 2 : cast back to float */
  tmp = _mm_cvtpi32x2_ps(mm0, mm1);
#else
  emm0 = _mm_cvttps_epi32(fx);
  tmp  = _mm_cvtepi32_ps(emm0);
#endif
  /* if greater, subtract 1 */
  v4sf mask = _mm_cmpgt_ps(tmp, fx);    
  mask = _mm_and_ps(mask, one);
  fx = _mm_sub_ps(tmp, mask);

  tmp = _mm_mul_ps(fx, *(v4sf*)_ps_cephes_exp_C1);
  v4sf z = _mm_mul_ps(fx, *(v4sf*)_ps_cephes_exp_C2);
  x = _mm_sub_ps(x, tmp);
  x = _mm_sub_ps(x, z);

  z = _mm_mul_ps(x,x);
  
  v4sf y = *(v4sf*)_ps_cephes_exp_p0;
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_exp_p1);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_exp_p2);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_exp_p3);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_exp_p4);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_exp_p5);
  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, x);
  y = _mm_add_ps(y, one);

  /* build 2^n */
#ifndef USE_SSE2
  z = _mm_movehl_ps(z, fx);
  mm0 = _mm_cvttps_pi32(fx);
  mm1 = _mm_cvttps_pi32(z);
  mm0 = _mm_add_pi32(mm0, *(v2si*)_pi32_0x7f);
  mm1 = _mm_add_pi32(mm1, *(v2si*)_pi32_0x7f);
  mm0 = _mm_slli_pi32(mm0, 23); 
  mm1 = _mm_slli_pi32(mm1, 23);
  
  v4sf pow2n; 
  COPY_MM_TO_XMM(mm0, mm1, pow2n);
  _mm_empty();
#else
  emm0 = _mm_cvttps_epi32(fx);
  emm0 = _mm_add_epi32(emm0, *(v4si*)_pi32_0x7f);
  emm0 = _mm_slli_epi32(emm0, 23);
  v4sf pow2n = _mm_castsi128_ps(emm0);
#endif
  y = _mm_mul_ps(y, pow2n);
  return y;
}

_PS_CONST(minus_cephes_DP1, -0.78515625);
_PS_CONST(minus_cephes_DP2, -2.4187564849853515625e-4);
_PS_CONST(minus_cephes_DP3, -3.77489497744594108e-8);
_PS_CONST(sincof_p0, -1.9515295891E-4);
_PS_CONST(sincof_p1,  8.3321608736E-3);
_PS_CONST(sincof_p2, -1.6666654611E-1);
_PS_CONST(coscof_p0,  2.443315711809948E-005);
_PS_CONST(coscof_p1, -1.388731625493765E-003);
_PS_CONST(coscof_p2,  4.166664568298827E-002);
_PS_CONST(cephes_FOPI, 1.27323954473516); // 4 / M_PI


/* evaluation of 4 sines at onces, using only SSE1+MMX intrinsics so
   it runs also on old athlons XPs and the pentium III of your grand
   mother.

   The code is the exact rewriting of the cephes sinf function.
   Precision is excellent as long as x < 8192 (I did not bother to
   take into account the special handling they have for greater values
   -- it does not return garbage for arguments over 8192, though, but
   the extra precision is missing).

   Note that it is such that sinf((float)M_PI) = 8.74e-8, which is the
   surprising but correct result.

   Performance is also surprisingly good, 1.33 times faster than the
   macos vsinf SSE2 function, and 1.5 times faster than the
   __vrs4_sinf of amd's ACML (which is only available in 64 bits). Not
   too bad for an SSE1 function (with no special tuning) !
   However the latter libraries probably have a much better handling of NaN,
   Inf, denormalized and other special arguments..

   On my core 1 duo, the execution of this function takes approximately 95 cycles.

   From what I have observed on the experiments with Intel AMath lib, switching to an
   SSE2 version would improve the perf by only 10%.

   Since it is based on SSE intrinsics, it has to be compiled at -O2 to
   deliver full speed.
*/
v4sf sin_ps(v4sf x) { // any x
  v4sf xmm1, xmm2 = _mm_setzero_ps(), xmm3, sign_bit, y;

#ifdef USE_SSE2
  v4si emm0, emm2;
#else
  v2si mm0, mm1, mm2, mm3;
#endif
  sign_bit = x;
  /* take the absolute value */
  x = _mm_and_ps(x, *(v4sf*)_ps_inv_sign_mask);
  /* extract the sign bit (upper one) */
  sign_bit = _mm_and_ps(sign_bit, *(v4sf*)_ps_sign_mask);
  
  /* scale by 4/Pi */
  y = _mm_mul_ps(x, *(v4sf*)_ps_cephes_FOPI);

#ifdef USE_SSE2
  /* store the integer part of y in mm0 */
  emm2 = _mm_cvttps_epi32(y);
  /* j=(j+1) & (~1) (see the cephes sources) */
  emm2 = _mm_add_epi32(emm2, *(v4si*)_pi32_1);
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_inv1);
  y = _mm_cvtepi32_ps(emm2);

  /* get the swap sign flag */
  emm0 = _mm_and_si128(emm2, *(v4si*)_pi32_4);
  emm0 = _mm_slli_epi32(emm0, 29);
  /* get the polynom selection mask 
     there is one polynom for 0 <= x <= Pi/4
     and another one for Pi/4<x<=Pi/2

     Both branches will be computed.
  */
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_2);
  emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());
  
  v4sf swap_sign_bit = _mm_castsi128_ps(emm0);
  v4sf poly_mask = _mm_castsi128_ps(emm2);
  sign_bit = _mm_xor_ps(sign_bit, swap_sign_bit);
  
#else
  /* store the integer part of y in mm0:mm1 */
  xmm2 = _mm_movehl_ps(xmm2, y);
  mm2 = _mm_cvttps_pi32(y);
  mm3 = _mm_cvttps_pi32(xmm2);
  /* j=(j+1) & (~1) (see the cephes sources) */
  mm2 = _mm_add_pi32(mm2, *(v2si*)_pi32_1);
  mm3 = _mm_add_pi32(mm3, *(v2si*)_pi32_1);
  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_inv1);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_inv1);
  y = _mm_cvtpi32x2_ps(mm2, mm3);
  /* get the swap sign flag */
  mm0 = _mm_and_si64(mm2, *(v2si*)_pi32_4);
  mm1 = _mm_and_si64(mm3, *(v2si*)_pi32_4);
  mm0 = _mm_slli_pi32(mm0, 29);
  mm1 = _mm_slli_pi32(mm1, 29);
  /* get the polynom selection mask */
  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_2);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_2);
  mm2 = _mm_cmpeq_pi32(mm2, _mm_setzero_si64());
  mm3 = _mm_cmpeq_pi32(mm3, _mm_setzero_si64());
  v4sf swap_sign_bit, poly_mask;
  COPY_MM_TO_XMM(mm0, mm1, swap_sign_bit);
  COPY_MM_TO_XMM(mm2, mm3, poly_mask);
  sign_bit = _mm_xor_ps(sign_bit, swap_sign_bit);
  _mm_empty(); /* good-bye mmx */
#endif
  
  /* The magic pass: "Extended precision modular arithmetic" 
     x = ((x - y * DP1) - y * DP2) - y * DP3; */
  xmm1 = *(v4sf*)_ps_minus_cephes_DP1;
  xmm2 = *(v4sf*)_ps_minus_cephes_DP2;
  xmm3 = *(v4sf*)_ps_minus_cephes_DP3;
  xmm1 = _mm_mul_ps(y, xmm1);
  xmm2 = _mm_mul_ps(y, xmm2);
  xmm3 = _mm_mul_ps(y, xmm3);
  x = _mm_add_ps(x, xmm1);
  x = _mm_add_ps(x, xmm2);
  x = _mm_add_ps(x, xmm3);

  /* Evaluate the first polynom  (0 <= x <= Pi/4) */
  y = *(v4sf*)_ps_coscof_p0;
  v4sf z = _mm_mul_ps(x,x);

  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p1);
  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p2);
  y = _mm_mul_ps(y, z);
  y = _mm_mul_ps(y, z);
  v4sf tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
  y = _mm_sub_ps(y, tmp);
  y = _mm_add_ps(y, *(v4sf*)_ps_1);
  
  /* Evaluate the second polynom  (Pi/4 <= x <= 0) */

  v4sf y2 = *(v4sf*)_ps_sincof_p0;
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p1);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p2);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_mul_ps(y2, x);
  y2 = _mm_add_ps(y2, x);

  /* select the correct result from the two polynoms */  
  xmm3 = poly_mask;
  y2 = _mm_and_ps(xmm3, y2); //, xmm3);
  y = _mm_andnot_ps(xmm3, y);
  y = _mm_add_ps(y,y2);
  /* update the sign */
  y = _mm_xor_ps(y, sign_bit);
  return y;
}

/* almost the same as sin_ps */
v4sf cos_ps(v4sf x) { // any x
  v4sf xmm1, xmm2 = _mm_setzero_ps(), xmm3, y;
#ifdef USE_SSE2
  v4si emm0, emm2;
#else
  v2si mm0, mm1, mm2, mm3;
#endif
  /* take the absolute value */
  x = _mm_and_ps(x, *(v4sf*)_ps_inv_sign_mask);
  
  /* scale by 4/Pi */
  y = _mm_mul_ps(x, *(v4sf*)_ps_cephes_FOPI);
  
#ifdef USE_SSE2
  /* store the integer part of y in mm0 */
  emm2 = _mm_cvttps_epi32(y);
  /* j=(j+1) & (~1) (see the cephes sources) */
  emm2 = _mm_add_epi32(emm2, *(v4si*)_pi32_1);
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_inv1);
  y = _mm_cvtepi32_ps(emm2);

  emm2 = _mm_sub_epi32(emm2, *(v4si*)_pi32_2);
  
  /* get the swap sign flag */
  emm0 = _mm_andnot_si128(emm2, *(v4si*)_pi32_4);
  emm0 = _mm_slli_epi32(emm0, 29);
  /* get the polynom selection mask */
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_2);
  emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());
  
  v4sf sign_bit = _mm_castsi128_ps(emm0);
  v4sf poly_mask = _mm_castsi128_ps(emm2);
#else
  /* store the integer part of y in mm0:mm1 */
  xmm2 = _mm_movehl_ps(xmm2, y);
  mm2 = _mm_cvttps_pi32(y);
  mm3 = _mm_cvttps_pi32(xmm2);

  /* j=(j+1) & (~1) (see the cephes sources) */
  mm2 = _mm_add_pi32(mm2, *(v2si*)_pi32_1);
  mm3 = _mm_add_pi32(mm3, *(v2si*)_pi32_1);
  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_inv1);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_inv1);

  y = _mm_cvtpi32x2_ps(mm2, mm3);


  mm2 = _mm_sub_pi32(mm2, *(v2si*)_pi32_2);
  mm3 = _mm_sub_pi32(mm3, *(v2si*)_pi32_2);

  /* get the swap sign flag in mm0:mm1 and the 
     polynom selection mask in mm2:mm3 */

  mm0 = _mm_andnot_si64(mm2, *(v2si*)_pi32_4);
  mm1 = _mm_andnot_si64(mm3, *(v2si*)_pi32_4);
  mm0 = _mm_slli_pi32(mm0, 29);
  mm1 = _mm_slli_pi32(mm1, 29);

  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_2);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_2);

  mm2 = _mm_cmpeq_pi32(mm2, _mm_setzero_si64());
  mm3 = _mm_cmpeq_pi32(mm3, _mm_setzero_si64());

  v4sf sign_bit, poly_mask;
  COPY_MM_TO_XMM(mm0, mm1, sign_bit);
  COPY_MM_TO_XMM(mm2, mm3, poly_mask);
  _mm_empty(); /* good-bye mmx */
#endif
  /* The magic pass: "Extended precision modular arithmetic" 
     x = ((x - y * DP1) - y * DP2) - y * DP3; */
  xmm1 = *(v4sf*)_ps_minus_cephes_DP1;
  xmm2 = *(v4sf*)_ps_minus_cephes_DP2;
  xmm3 = *(v4sf*)_ps_minus_cephes_DP3;
  xmm1 = _mm_mul_ps(y, xmm1);
  xmm2 = _mm_mul_ps(y, xmm2);
  xmm3 = _mm_mul_ps(y, xmm3);
  x = _mm_add_ps(x, xmm1);
  x = _mm_add_ps(x, xmm2);
  x = _mm_add_ps(x, xmm3);
  
  /* Evaluate the first polynom  (0 <= x <= Pi/4) */
  y = *(v4sf*)_ps_coscof_p0;
  v4sf z = _mm_mul_ps(x,x);

  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p1);
  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p2);
  y = _mm_mul_ps(y, z);
  y = _mm_mul_ps(y, z);
  v4sf tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
  y = _mm_sub_ps(y, tmp);
  y = _mm_add_ps(y, *(v4sf*)_ps_1);
  
  /* Evaluate the second polynom  (Pi/4 <= x <= 0) */

  v4sf y2 = *(v4sf*)_ps_sincof_p0;
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p1);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p2);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_mul_ps(y2, x);
  y2 = _mm_add_ps(y2, x);

  /* select the correct result from the two polynoms */  
  xmm3 = poly_mask;
  y2 = _mm_and_ps(xmm3, y2); //, xmm3);
  y = _mm_andnot_ps(xmm3, y);
  y = _mm_add_ps(y,y2);
  /* update the sign */
  y = _mm_xor_ps(y, sign_bit);

  return y;
}

/* since sin_ps and cos_ps are almost identical, sincos_ps could replace both of them..
   it is almost as fast, and gives you a free cosine with your sine */
void sincos_ps(v4sf x, v4sf *s, v4sf *c) {
  v4sf xmm1, xmm2, xmm3 = _mm_setzero_ps(), sign_bit_sin, y;
#ifdef USE_SSE2
  v4si emm0, emm2, emm4;
#else
  v2si mm0, mm1, mm2, mm3, mm4, mm5;
#endif
  sign_bit_sin = x;
  /* take the absolute value */
  x = _mm_and_ps(x, *(v4sf*)_ps_inv_sign_mask);
  /* extract the sign bit (upper one) */
  sign_bit_sin = _mm_and_ps(sign_bit_sin, *(v4sf*)_ps_sign_mask);
  
  /* scale by 4/Pi */
  y = _mm_mul_ps(x, *(v4sf*)_ps_cephes_FOPI);
    
#ifdef USE_SSE2
  /* store the integer part of y in emm2 */
  emm2 = _mm_cvttps_epi32(y);

  /* j=(j+1) & (~1) (see the cephes sources) */
  emm2 = _mm_add_epi32(emm2, *(v4si*)_pi32_1);
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_inv1);
  y = _mm_cvtepi32_ps(emm2);

  emm4 = emm2;

  /* get the swap sign flag for the sine */
  emm0 = _mm_and_si128(emm2, *(v4si*)_pi32_4);
  emm0 = _mm_slli_epi32(emm0, 29);
  v4sf swap_sign_bit_sin = _mm_castsi128_ps(emm0);

  /* get the polynom selection mask for the sine*/
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_2);
  emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());
  v4sf poly_mask = _mm_castsi128_ps(emm2);
#else
  /* store the integer part of y in mm2:mm3 */
  xmm3 = _mm_movehl_ps(xmm3, y);
  mm2 = _mm_cvttps_pi32(y);
  mm3 = _mm_cvttps_pi32(xmm3);

  /* j=(j+1) & (~1) (see the cephes sources) */
  mm2 = _mm_add_pi32(mm2, *(v2si*)_pi32_1);
  mm3 = _mm_add_pi32(mm3, *(v2si*)_pi32_1);
  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_inv1);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_inv1);

  y = _mm_cvtpi32x2_ps(mm2, mm3);

  mm4 = mm2;
  mm5 = mm3;

  /* get the swap sign flag for the sine */
  mm0 = _mm_and_si64(mm2, *(v2si*)_pi32_4);
  mm1 = _mm_and_si64(mm3, *(v2si*)_pi32_4);
  mm0 = _mm_slli_pi32(mm0, 29);
  mm1 = _mm_slli_pi32(mm1, 29);
  v4sf swap_sign_bit_sin;
  COPY_MM_TO_XMM(mm0, mm1, swap_sign_bit_sin);

  /* get the polynom selection mask for the sine */

  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_2);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_2);
  mm2 = _mm_cmpeq_pi32(mm2, _mm_setzero_si64());
  mm3 = _mm_cmpeq_pi32(mm3, _mm_setzero_si64());
  v4sf poly_mask;
  COPY_MM_TO_XMM(mm2, mm3, poly_mask);
#endif

  /* The magic pass: "Extended precision modular arithmetic" 
     x = ((x - y * DP1) - y * DP2) - y * DP3; */
  xmm1 = *(v4sf*)_ps_minus_cephes_DP1;
  xmm2 = *(v4sf*)_ps_minus_cephes_DP2;
  xmm3 = *(v4sf*)_ps_minus_cephes_DP3;
  xmm1 = _mm_mul_ps(y, xmm1);
  xmm2 = _mm_mul_ps(y, xmm2);
  xmm3 = _mm_mul_ps(y, xmm3);
  x = _mm_add_ps(x, xmm1);
  x = _mm_add_ps(x, xmm2);
  x = _mm_add_ps(x, xmm3);

#ifdef USE_SSE2
  emm4 = _mm_sub_epi32(emm4, *(v4si*)_pi32_2);
  emm4 = _mm_andnot_si128(emm4, *(v4si*)_pi32_4);
  emm4 = _mm_slli_epi32(emm4, 29);
  v4sf sign_bit_cos = _mm_castsi128_ps(emm4);
#else
  /* get the sign flag for the cosine */
  mm4 = _mm_sub_pi32(mm4, *(v2si*)_pi32_2);
  mm5 = _mm_sub_pi32(mm5, *(v2si*)_pi32_2);
  mm4 = _mm_andnot_si64(mm4, *(v2si*)_pi32_4);
  mm5 = _mm_andnot_si64(mm5, *(v2si*)_pi32_4);
  mm4 = _mm_slli_pi32(mm4, 29);
  mm5 = _mm_slli_pi32(mm5, 29);
  v4sf sign_bit_cos;
  COPY_MM_TO_XMM(mm4, mm5, sign_bit_cos);
  _mm_empty(); /* good-bye mmx */
#endif

  sign_bit_sin = _mm_xor_ps(sign_bit_sin, swap_sign_bit_sin);

  
  /* Evaluate the first polynom  (0 <= x <= Pi/4) */
  v4sf z = _mm_mul_ps(x,x);
  y = *(v4sf*)_ps_coscof_p0;

  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p1);
  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p2);
  y = _mm_mul_ps(y, z);
  y = _mm_mul_ps(y, z);
  v4sf tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
  y = _mm_sub_ps(y, tmp);
  y = _mm_add_ps(y, *(v4sf*)_ps_1);
  
  /* Evaluate the second polynom  (Pi/4 <= x <= 0) */

  v4sf y2 = *(v4sf*)_ps_sincof_p0;
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p1);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p2);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_mul_ps(y2, x);
  y2 = _mm_add_ps(y2, x);

  /* select the correct result from the two polynoms */  
  xmm3 = poly_mask;
  v4sf ysin2 = _mm_and_ps(xmm3, y2);
  v4sf ysin1 = _mm_andnot_ps(xmm3, y);
  y2 = _mm_sub_ps(y2,ysin2);
  y = _mm_sub_ps(y, ysin1);

  xmm1 = _mm_add_ps(ysin1,ysin2);
  xmm2 = _mm_add_ps(y,y2);
 
  /* update the sign */
  *s = _mm_xor_ps(xmm1, sign_bit_sin);
  *c = _mm_xor_ps(xmm2, sign_bit_cos);
}


```

`cl_dll/include/overview.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#ifndef OVERVIEW_H
#define OVERVIEW_H


//-----------------------------------------------------------------------------
// Purpose: Handles the drawing of the top-down map and all the things on it
//-----------------------------------------------------------------------------
class CHudOverview : public CHudBase
{
public:
	int Init();
	int VidInit();

	int Draw(float flTime);
	void InitHUDData( void );

private:
	HSPRITE m_hsprPlayer;
	HSPRITE m_hsprViewcone;
};


#endif // OVERVIEW_H

```

`cl_dll/include/parsemsg.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  parsemsg.h
//
#pragma once
#define ASSERT( x )

#include <stdint.h>

class BufferReader
{
public:
	BufferReader( const char *name, void *buf, int size ) :
		m_szMsgName( name ), m_pBuf( (uint8_t*)buf ), m_iSize( size ), m_iRead( 0 ), m_bBad( false ) {}
	BufferReader( void *buf, int size ) : BufferReader( "not set", buf, size ) {}

#ifdef _DEBUG
	inline ~BufferReader( void );
#endif

	void Flush( void );
	bool Bad( void ) { return m_bBad; }
	bool Eof( void ) { return m_iRead >= m_iSize - 1; }

	bool Valid( void ) { return !Bad() && !Eof(); }

	template<typename T> T Read( void );

	int8_t ReadChar( void );
	uint8_t ReadByte( void );
	int16_t ReadShort( void );
	int16_t ReadWord( void );
	int32_t ReadLong( void ); // no mistake here, we assume that long is 32 bit.
	char *ReadString( void );
	float ReadFloat( void );
	float ReadCoord( void );
	float ReadAngle( void );
	float ReadHiResAngle( void );
	Vector ReadCoordVector( void );

private:
	const char *m_szMsgName;
	uint8_t *m_pBuf;
	size_t   m_iSize;
	size_t   m_iRead;
	bool     m_bBad;
};

inline void BufferReader::Flush( void )
{
	m_iRead = m_iSize - 1;
}

template<typename T>
inline T BufferReader::Read( void )
{
	if( m_bBad )
		return -1;

	// don't go out of bounds
	if( m_iRead + sizeof( T ) > m_iSize )
	{
		m_bBad = true;

		// may occur, but safe
		//gEngfuncs.Con_DPrintf( "BufferReader(%s): buffer overrun. Expected %i\n", m_szMsgName, m_iSize );
		return -1;
	}

	if( sizeof( T ) == 1 )
		return m_pBuf[m_iRead++];

	// T t = *(T*)(m_pBuf + m_iRead);
	T t;
	memcpy( &t, m_pBuf + m_iRead, sizeof( T ) );
	m_iRead += sizeof( T );

	return t;
}


template<>
inline char* BufferReader::Read( void )
{
	static char string[2048];

	if( m_bBad )
		return (char*)""; // do not return NULL, may break strcpy's

	size_t l;
	for( l = 0; l < sizeof(string) - 1; l++)
	{
		if( m_iRead > m_iSize )
			break;

		int8_t c = ReadChar();
		if( c == -1 || c == 0 )
			break;

		string[l] = c;
	}

	string[l] = 0;

	return string;

}

template<>
inline float BufferReader::Read( void )
{
	union
	{
		unsigned char b[4];
		float f;
	} tr;

	if( m_bBad )
		return -1.0f;

	if( m_iRead + 4 > m_iSize )
	{
		m_bBad = true;
		return -1.0f;
	}

	for( int i = 0; i < 4; i++ )
		tr.b[i] = m_pBuf[m_iRead + i];

	m_iRead += 4;

	return tr.f;
}

inline int8_t BufferReader::ReadChar( void )
{
	return Read<int8_t>();
}

inline uint8_t BufferReader::ReadByte( void )
{
	return Read<uint8_t>();
}

inline int16_t BufferReader::ReadShort( void )
{
	return Read<int16_t>();
}

inline int16_t BufferReader::ReadWord( void )
{
	return ReadShort();
}

inline int32_t BufferReader::ReadLong( void )
{
	return Read<int32_t>();
}

inline char *BufferReader::ReadString( void )
{
	return Read<char*>();
}

inline float BufferReader::ReadFloat( void )
{
	return Read<float>();
}

inline float BufferReader::ReadCoord( void )
{
	return ReadShort() * 0.125f;
}

inline Vector BufferReader::ReadCoordVector( void )
{
	Vector v;
	v.x = ReadCoord();
	v.y = ReadCoord();
	v.z = ReadCoord();

	return v;
}

inline float BufferReader::ReadAngle( void )
{
	return ReadChar() * 360.0f / 256.0f;
}

inline float BufferReader::ReadHiResAngle( void )
{
	return ReadShort() * 360.0f / 65536.0f;
}

#ifdef _DEBUG
BufferReader::~BufferReader()
{
	//if( m_iRead < m_iSize - 1 )
	//	gEngfuncs.Con_DPrintf( "BufferReader(%s): destroyed before reaching end. Expected %i, read %i\n", m_szMsgName, m_iSize, m_iRead );
}
#endif

```

`cl_dll/include/rain.h`:

```h
/***
*
*	Copyright (c) 1996-2004, Shambler Team. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Shambler Team.  All other use, distribution, or modification is prohibited
*   without written permission from Shambler Team.
*
****/
/*
====== rain.h ========================================================
*/
#pragma once
#ifndef __RAIN_H__
#define __RAIN_H__

void ProcessRain( void );
void ProcessFXObjects( void );
void ResetRain( void );
void InitRain( void );
void DrawRain( void );
void DrawFXObjects( void );

#endif

```

`cl_dll/include/studio/StudioModelRenderer.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Big thanks to Chicken Fortress developers
// for this code.
#pragma once
#ifndef STUDIOMODELRENDERER_H
#define STUDIOMODELRENDERER_H

#include "studio.h"
#include "com_model.h"

class CStudioModelRenderer
{
public:
	CStudioModelRenderer(void);
	virtual ~CStudioModelRenderer(void);

public:
	virtual void Init(void);
	virtual int StudioDrawModel(int flags);
	virtual int StudioDrawPlayer(int flags, struct entity_state_s *pplayer);

public:
	virtual mstudioanim_t *StudioGetAnim(model_t *pSubModel, mstudioseqdesc_t *pseqdesc);
	virtual void StudioSetUpTransform(int trivial_accept);
	virtual void StudioSetupBones(void);
	virtual void StudioCalcAttachments(void);
	virtual void StudioSaveBones(void);
	virtual void StudioMergeBones(model_t *pSubModel);
	virtual float StudioEstimateInterpolant(void);
	virtual float StudioEstimateFrame(mstudioseqdesc_t *pseqdesc);
	virtual void StudioFxTransform(cl_entity_t *ent, float transform[3][4]);
	virtual void StudioSlerpBones(vec4_t q1[], float pos1[][3], vec4_t q2[], float pos2[][3], float s);
	virtual void StudioCalcBoneAdj(float dadt, float *adj, const byte *pcontroller1, const byte *pcontroller2, byte mouthopen);
	virtual void StudioCalcBoneQuaterion(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *q);
	virtual void StudioCalcBonePosition(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *pos);
	virtual void StudioCalcRotations(float pos[][3], vec4_t *q, mstudioseqdesc_t *pseqdesc, mstudioanim_t *panim, float f);
	virtual void StudioRenderModel(float *lightdir);
	virtual void StudioRenderFinal(void);
	virtual void StudioRenderFinal_Software(void);
	virtual void StudioRenderFinal_Hardware(void);
	virtual void StudioPlayerBlend(mstudioseqdesc_t *pseqdesc, int *pBlend, float *pPitch);
	virtual void StudioEstimateGait(entity_state_t *pplayer);
	virtual void StudioProcessGait(entity_state_t *pplayer);
	virtual void StudioSetShadowSprite(int idx);
	void StudioDrawShadow(Vector origin, float scale);


public:
	double m_clTime;
	double m_clOldTime;
	int m_fDoInterp;
	int m_iShadowSprite;
	int m_fGaitEstimation;
	int m_nFrameCount;
	cvar_t *m_pCvarHiModels;
	cvar_t *m_pCvarDeveloper;
	cvar_t *m_pCvarDrawEntities;
	cvar_t *m_pCvarShadows;
	cvar_t *m_pCvarDebug;
	cl_entity_t *m_pCurrentEntity;
	model_t *m_pRenderModel;
	player_info_t *m_pPlayerInfo;
	int m_nPlayerIndex;
	float m_flGaitMovement;
	studiohdr_t *m_pStudioHeader;
	mstudiobodyparts_t *m_pBodyPart;
	mstudiomodel_t *m_pSubModel;
	int m_nTopColor;
	int m_nBottomColor;
	model_t *m_pChromeSprite;
	int m_nCachedBones;
	char m_nCachedBoneNames[MAXSTUDIOBONES][32];
	float m_rgCachedBoneTransform[MAXSTUDIOBONES][3][4];
	float m_rgCachedLightTransform[MAXSTUDIOBONES][3][4];
	float m_fSoftwareXScale, m_fSoftwareYScale;
	float m_vUp[3];
	float m_vRight[3];
	float m_vNormal[3];
	float m_vRenderOrigin[3];
	int *m_pStudioModelCount;
	int *m_pModelsDrawn;
	float (*m_protationmatrix)[3][4];
	float (*m_paliastransform)[3][4];
	float (*m_pbonetransform)[MAXSTUDIOBONES][3][4];
	float (*m_plighttransform)[MAXSTUDIOBONES][3][4];
	entity_state_t *m_pplayer;
};

#endif

```

`cl_dll/include/studio/studio_util.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined( STUDIO_UTIL_H )
#define STUDIO_UTIL_H


#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

#ifndef PITCH
// MOVEMENT INFO
// up / down
#define	PITCH	0
// left / right
#define	YAW		1
// fall over
#define	ROLL	2
#endif

#define FDotProduct( a, b ) (fabs((a[0])*(b[0])) + fabs((a[1])*(b[1])) + fabs((a[2])*(b[2])))

void	AngleMatrix (const float *angles, float (*matrix)[4] );
int		VectorCompare (const float *v1, const float *v2);
void	CrossProduct (const float *v1, const float *v2, float *cross);
void	VectorTransform( const float *in1, float ( *in2 )[4], float *out );
void	ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4]);
#define MatrixCopy( in, out ) memcpy( ( out ), ( in ), sizeof( float ) * 3 * 4 );
void	QuaternionMatrix( vec4_t quaternion, float (*matrix)[4] );
void	QuaternionSlerp( vec4_t p, vec4_t q, float t, vec4_t qt );
void	AngleQuaternion( float *angles, vec4_t quaternion );

#endif // STUDIO_UTIL_H

```

`cl_dll/include/tf_defs.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
****/

#ifndef __TF_DEFS_H
#define __TF_DEFS_H

//===========================================================================
// OLD OPTIONS.QC
//===========================================================================
#define DEFAULT_AUTOZOOM		 FALSE
#define WEINER_SNIPER                           // autoaiming for sniper rifle
#define FLAME_MAXWORLDNUM        20             // maximum number of flames in the world. DO NOT PUT BELOW 20.

//#define MAX_WORLD_PIPEBOMBS      15             // This is divided between teams - this is the most you should have on a net server
#define MAX_PLAYER_PIPEBOMBS	 8				// maximum number of pipebombs any 1 player can have active
#define MAX_PLAYER_AMMOBOXES  3				// maximum number of ammoboxes any 1 player can have active

//#define MAX_WORLD_FLARES         9              // This is the total number of flares allowed in the world at one time
//#define MAX_WORLD_AMMOBOXES      20             // This is divided between teams - this is the most you should have on a net server
#define GR_TYPE_MIRV_NO          4              // Number of Mirvs a Mirv Grenade breaks into
#define GR_TYPE_NAPALM_NO        8              // Number of flames napalm grenade breaks into (unused if net server)
#define MEDIKIT_IS_BIOWEAPON					// Medikit acts as a bioweapon against enemies

#define TEAM_HELP_RATE   60     // used only if teamplay bit 64 (help team with lower score) is set.  
								// 60 is a mild setting, and won't make too much difference
								// increasing it _decreases_ the amount of help the losing team gets
								// Minimum setting is 1, which would really help the losing team

#define DISPLAY_CLASS_HELP			TRUE            // Change this to #OFF if you don't want the class help to 
													// appear whenever a player connects
#define NEVER_TEAMFRAGS				FALSE			// teamfrags options always off 
#define ALWAYS_TEAMFRAGS			FALSE			// teamfrags options always on 
#define CHECK_SPEEDS				TRUE            // makes sure players aren't moving too fast
#define SNIPER_RIFLE_RELOAD_TIME    1.5				// seconds

#define MAPBRIEFING_MAXTEXTLENGTH	512
#define PLAYER_PUSH_VELOCITY			 50			// Players push teammates if they're moving under this speed

// Debug Options
//#define MAP_DEBUG                     // Debug for Map code. I suggest running in a hi-res
										// mode and/or piping the output from the server to a file.
#ifdef MAP_DEBUG
	#define MDEBUG(x) x
#else
	#define MDEBUG(x)
#endif
//#define VERBOSE                       // Verbose Debugging on/off

//===========================================================================
// OLD QUAKE Defs
//===========================================================================
// items
#define IT_AXE					4096 
#define IT_SHOTGUN				1 
#define IT_SUPER_SHOTGUN		2 
#define IT_NAILGUN				4 
#define IT_SUPER_NAILGUN		8 
#define IT_GRENADE_LAUNCHER		16 
#define IT_ROCKET_LAUNCHER		32 
#define IT_LIGHTNING			64 
#define IT_EXTRA_WEAPON			128 

#define IT_SHELLS				256 
#define IT_NAILS				512 
#define IT_ROCKETS				1024 
#define IT_CELLS				2048 

#define IT_ARMOR1				8192 
#define IT_ARMOR2				16384 
#define IT_ARMOR3				32768 
#define IT_SUPERHEALTH			65536 

#define IT_KEY1					131072 
#define IT_KEY2					262144 

#define IT_INVISIBILITY			524288 
#define IT_INVULNERABILITY		1048576 
#define IT_SUIT					2097152
#define IT_QUAD					4194304 
#define IT_HOOK					8388608

#define IT_KEY3					16777216	// Stomp invisibility
#define IT_KEY4					33554432	// Stomp invulnerability

//===========================================================================
// TEAMFORTRESS Defs
//===========================================================================
// TeamFortress State Flags
#define TFSTATE_GRENPRIMED		1 	// Whether the player has a primed grenade
#define TFSTATE_RELOADING		2 	// Whether the player is reloading
#define TFSTATE_ALTKILL			4  	// #TRUE if killed with a weapon not in self.weapon: NOT USED ANYMORE
#define TFSTATE_RANDOMPC		8   // Whether Playerclass is random, new one each respawn
#define TFSTATE_INFECTED		16 	// set when player is infected by the bioweapon
#define TFSTATE_INVINCIBLE		32 	// Player has permanent Invincibility (Usually by GoalItem)
#define TFSTATE_INVISIBLE		64 	// Player has permanent Invisibility (Usually by GoalItem)
#define TFSTATE_QUAD			128 // Player has permanent Quad Damage (Usually by GoalItem)
#define TFSTATE_RADSUIT			256 // Player has permanent Radsuit (Usually by GoalItem)
#define TFSTATE_BURNING			512 // Is on fire
#define TFSTATE_GRENTHROWING	1024  // is throwing a grenade
#define TFSTATE_AIMING			2048  // is using the laser sight
#define TFSTATE_ZOOMOFF			4096  // doesn't want the FOV changed when zooming
#define TFSTATE_RESPAWN_READY	8192  // is waiting for respawn, and has pressed fire
#define TFSTATE_HALLUCINATING  16384  // set when player is hallucinating
#define TFSTATE_TRANQUILISED   32768  // set when player is tranquilised
#define TFSTATE_CANT_MOVE	   65536  // set when player is setting a detpack
#define TFSTATE_RESET_FLAMETIME 131072 // set when the player has to have his flames increased in health

// Defines used by TF_T_Damage (see combat.qc)
#define TF_TD_IGNOREARMOUR	1  // Bypasses the armour of the target
#define TF_TD_NOTTEAM		2  // Doesn't damage a team member (indicates direct fire weapon)
#define TF_TD_NOTSELF		4  // Doesn't damage self

#define TF_TD_OTHER			0  // Ignore armorclass
#define TF_TD_SHOT			1  // Bullet damage
#define TF_TD_NAIL			2  // Nail damage
#define TF_TD_EXPLOSION		4  // Explosion damage
#define TF_TD_ELECTRICITY	8  // Electric damage
#define TF_TD_FIRE			16  // Fire damage
#define TF_TD_NOSOUND		256 // Special damage. Makes no sound/painframe, etc

/*==================================================*/
/* Toggleable Game Settings							*/
/*==================================================*/
#define TF_RESPAWNDELAY1	5 	// seconds of waiting before player can respawn
#define TF_RESPAWNDELAY2	10 	// seconds of waiting before player can respawn
#define TF_RESPAWNDELAY3	20 	// seconds of waiting before player can respawn

#define TEAMPLAY_NORMAL			 1			
#define TEAMPLAY_HALFDIRECT		 2
#define TEAMPLAY_NODIRECT		 4
#define TEAMPLAY_HALFEXPLOSIVE	 8
#define TEAMPLAY_NOEXPLOSIVE	 16
#define TEAMPLAY_LESSPLAYERSHELP 32
#define TEAMPLAY_LESSSCOREHELP	 64
#define TEAMPLAY_HALFDIRECTARMOR 128
#define TEAMPLAY_NODIRECTARMOR 	 256
#define TEAMPLAY_HALFEXPARMOR	 512
#define TEAMPLAY_NOEXPARMOR		 1024
#define TEAMPLAY_HALFDIRMIRROR	 2048
#define TEAMPLAY_FULLDIRMIRROR	 4096
#define TEAMPLAY_HALFEXPMIRROR	 8192
#define TEAMPLAY_FULLEXPMIRROR	 16384

#define TEAMPLAY_TEAMDAMAGE		(TEAMPLAY_NODIRECT | TEAMPLAY_HALFDIRECT | TEAMPLAY_HALFEXPLOSIVE | TEAMPLAY_NOEXPLOSIVE)
// FortressMap stuff
#define TEAM1_CIVILIANS 1	
#define TEAM2_CIVILIANS 2
#define TEAM3_CIVILIANS 4	
#define TEAM4_CIVILIANS 8	

// Defines for the playerclass
#define PC_UNDEFINED	0 

#define PC_SCOUT		1 
#define PC_SNIPER		2 
#define PC_SOLDIER		3 
#define PC_DEMOMAN		4 
#define PC_MEDIC		5 
#define PC_HVYWEAP		6 
#define PC_PYRO			7
#define PC_SPY			8
#define PC_ENGINEER		9

// Insert new class definitions here

// PC_RANDOM _MUST_ be the third last class
#define PC_RANDOM		10 		// Random playerclass
#define PC_CIVILIAN		11		// Civilians are a special class. They cannot
								// be chosen by players, only enforced by maps
#define PC_LASTCLASS	12 		// Use this as the high-boundary for any loops
								// through the playerclass.

#define SENTRY_COLOR	10		// will be in the PC_RANDOM slot for team colors

// These are just for the scanner
#define SCAN_SENTRY		13
#define SCAN_GOALITEM	14

// Values returned by CheckArea
enum
{
	CAREA_CLEAR,
	CAREA_BLOCKED,
	CAREA_NOBUILD
};

/*==================================================*/
/* Impulse Defines		                        	*/
/*==================================================*/
// Alias check to see whether they already have the aliases
#define TF_ALIAS_CHECK		13 

// CTF Support Impulses
#define HOOK_IMP1		22
#define FLAG_INFO		23
#define HOOK_IMP2		39

// Axe
#define AXE_IMP			40

// Camera Impulse
#define TF_CAM_TARGET			50
#define TF_CAM_ZOOM				51
#define TF_CAM_ANGLE			52
#define TF_CAM_VEC				53
#define TF_CAM_PROJECTILE		54
#define TF_CAM_PROJECTILE_Z		55
#define TF_CAM_REVANGLE			56
#define TF_CAM_OFFSET			57
#define TF_CAM_DROP				58	
#define TF_CAM_FADETOBLACK		59
#define TF_CAM_FADEFROMBLACK	60
#define TF_CAM_FADETOWHITE		61
#define TF_CAM_FADEFROMWHITE	62

// Last Weapon impulse
#define TF_LAST_WEAPON			69

// Status Bar Resolution Settings.  Same as CTF to maintain ease of use.
#define TF_STATUSBAR_RES_START	71
#define TF_STATUSBAR_RES_END	81

// Clan Messages
#define TF_MESSAGE_1			82
#define TF_MESSAGE_2			83
#define TF_MESSAGE_3			84
#define TF_MESSAGE_4			85
#define TF_MESSAGE_5			86

#define TF_CHANGE_CLASS			99	// Bring up the Class Change menu

// Added to PC_??? to get impulse to use if this clashes with your 
// own impulses, just change this value, not the PC_??
#define TF_CHANGEPC			100 
// The next few impulses are all the class selections
//PC_SCOUT		101 
//PC_SNIPER		102 
//PC_SOLDIER	103 
//PC_DEMOMAN	104 
//PC_MEDIC		105 
//PC_HVYWEAP	106 
//PC_PYRO		107 
//PC_RANDOM		108
//PC_CIVILIAN	109  // Cannot be used
//PC_SPY		110
//PC_ENGINEER	111

// Help impulses
#define TF_DISPLAYLOCATION  118
#define TF_STATUS_QUERY		119

#define TF_HELP_MAP			131

// Information impulses
#define TF_INVENTORY		135
#define TF_SHOWTF			136 
#define TF_SHOWLEGALCLASSES	137

// Team Impulses
#define TF_TEAM_1			140   // Join Team 1
#define TF_TEAM_2			141   // Join Team 2
#define TF_TEAM_3			142   // Join Team 3
#define TF_TEAM_4			143   // Join Team 4
#define TF_TEAM_CLASSES		144   // Impulse to display team classes
#define TF_TEAM_SCORES		145   // Impulse to display team scores
#define TF_TEAM_LIST		146   // Impulse to display the players in each team.

// Grenade Impulses
#define TF_GRENADE_1		150   // Prime grenade type 1
#define TF_GRENADE_2		151   // Prime grenade type 2
#define TF_GRENADE_T		152   // Throw primed grenade

// Impulses for new items
//#define TF_SCAN				159		// Scanner Pre-Impulse
#define TF_AUTO_SCAN		159		// Scanner On/Off
#define TF_SCAN_ENEMY		160		// Impulses to toggle scanning of enemies
#define TF_SCAN_FRIENDLY	161		// Impulses to toggle scanning of friendlies 
//#define TF_SCAN_10			162		// Scan using 10 enery (1 cell)
#define TF_SCAN_SOUND		162		// Scanner sounds on/off
#define TF_SCAN_30			163		// Scan using 30 energy (2 cells)
#define TF_SCAN_100			164		// Scan using 100 energy (5 cells)
#define TF_DETPACK_5		165		// Detpack set to 5 seconds
#define TF_DETPACK_20		166		// Detpack set to 20 seconds
#define TF_DETPACK_50		167		// Detpack set to 50 seconds
#define TF_DETPACK			168		// Detpack Pre-Impulse
#define TF_DETPACK_STOP		169		// Impulse to stop setting detpack
#define TF_PB_DETONATE		170		// Detonate Pipebombs

// Special skill
#define TF_SPECIAL_SKILL	171

// Ammo Drop impulse
#define TF_DROP_AMMO        172

// Reload impulse
#define TF_RELOAD			173

// auto-zoom toggle
#define TF_AUTOZOOM			174

// drop/pass commands
#define TF_DROPKEY			175

// Select Medikit		
#define TF_MEDIKIT			176

// Spy Impulses
#define TF_SPY_SPY			177		// On net, go invisible, on LAN, change skin/color
#define TF_SPY_DIE			178		// Feign Death

// Engineer Impulses
#define TF_ENGINEER_BUILD	179
#define TF_ENGINEER_SANDBAG	180

// Medic
#define TF_MEDIC_HELPME		181

// Status bar
#define TF_STATUSBAR_ON		182
#define TF_STATUSBAR_OFF	183

// Discard impulse
#define TF_DISCARD 	  		184

// ID Player impulse
#define TF_ID	 	  		185

// Clan Battle impulses
#define TF_SHOWIDS			186

// More Engineer Impulses
#define TF_ENGINEER_DETDISP 187
#define TF_ENGINEER_DETSENT 188

// Admin Commands
#define TF_ADMIN_DEAL_CYCLE		189
#define TF_ADMIN_KICK			190
#define TF_ADMIN_BAN			191
#define TF_ADMIN_COUNTPLAYERS	192
#define TF_ADMIN_CEASEFIRE		193

// Drop Goal Items
#define TF_DROPGOALITEMS 		194

// More Admin Commands
#define TF_ADMIN_NEXT			195

// More Engineer Impulses
#define TF_ENGINEER_DETEXIT 	196
#define TF_ENGINEER_DETENTRANCE	197

// Yet MORE Admin Commands
#define TF_ADMIN_LISTIPS		198

// Silent Spy Feign
#define TF_SPY_SILENTDIE		199


/*==================================================*/
/* Defines for the ENGINEER's Building ability		*/
/*==================================================*/
// Ammo costs
#define AMMO_COST_SHELLS		2		// Metal needed to make 1 shell
#define AMMO_COST_NAILS			1
#define AMMO_COST_ROCKETS		2
#define AMMO_COST_CELLS			2

// Building types
#define BUILD_DISPENSER				1
#define BUILD_SENTRYGUN				2
#define BUILD_MORTAR				3
#define BUILD_TELEPORTER_ENTRANCE	4
#define BUILD_TELEPORTER_EXIT		5

// Building metal costs
#define BUILD_COST_DISPENSER	100		// Metal needed to built 
#define BUILD_COST_SENTRYGUN	130		
#define BUILD_COST_MORTAR		150		
#define BUILD_COST_TELEPORTER	125		

#define BUILD_COST_SANDBAG		20		// Built with a separate alias

// Building times
#define BUILD_TIME_DISPENSER	2		// seconds to build
#define BUILD_TIME_SENTRYGUN	5		
#define BUILD_TIME_MORTAR		5		
#define BUILD_TIME_TELEPORTER	4		

// Building health levels
#define BUILD_HEALTH_DISPENSER	150		// Health of the building
#define BUILD_HEALTH_SENTRYGUN	150		
#define BUILD_HEALTH_MORTAR		200		
#define BUILD_HEALTH_TELEPORTER 80

// Dispenser's maximum carrying capability
#define BUILD_DISPENSER_MAX_SHELLS  400
#define BUILD_DISPENSER_MAX_NAILS   600
#define BUILD_DISPENSER_MAX_ROCKETS 300
#define BUILD_DISPENSER_MAX_CELLS   400
#define BUILD_DISPENSER_MAX_ARMOR   500

// Build state sent down to client
#define BS_BUILDING			(1<<0)
#define BS_HAS_DISPENSER	(1<<1)
#define BS_HAS_SENTRYGUN	(1<<2)
#define BS_CANB_DISPENSER	(1<<3)
#define BS_CANB_SENTRYGUN	(1<<4)
/*==================================================*/
/* Ammo quantities for dropping & dispenser use		*/
/*==================================================*/
#define DROP_SHELLS   20
#define DROP_NAILS    20
#define DROP_ROCKETS  10
#define DROP_CELLS    10
#define DROP_ARMOR	  40

/*==================================================*/
/* Team Defines				            			*/
/*==================================================*/
#define TM_MAX_NO	4 			// Max number of teams. Simply changing this value isn't enough.
								// A new global to hold new team colors is needed, and more flags
								// in the spawnpoint spawnflags may need to be used.
								// Basically, don't change this unless you know what you're doing :)

/*==================================================*/
/* New Weapon Defines		                        */
/*==================================================*/
#define WEAP_HOOK				1
#define WEAP_BIOWEAPON			2
#define WEAP_MEDIKIT			4
#define WEAP_SPANNER			8
#define WEAP_AXE				16
#define WEAP_SNIPER_RIFLE		32
#define WEAP_AUTO_RIFLE			64
#define WEAP_SHOTGUN			128
#define WEAP_SUPER_SHOTGUN		256
#define WEAP_NAILGUN			512
#define WEAP_SUPER_NAILGUN		1024
#define WEAP_GRENADE_LAUNCHER	2048
#define WEAP_FLAMETHROWER		4096
#define WEAP_ROCKET_LAUNCHER	8192
#define WEAP_INCENDIARY			16384
#define WEAP_ASSAULT_CANNON		32768
#define WEAP_LIGHTNING			65536
#define WEAP_DETPACK			131072
#define WEAP_TRANQ				262144
#define WEAP_LASER				524288
// still room for 12 more weapons
// but we can remove some by giving the weapons
// a weapon mode (like the rifle)

// HL-compatible weapon numbers
#define WEAPON_HOOK				1
#define WEAPON_BIOWEAPON		(WEAPON_HOOK+1)
#define WEAPON_MEDIKIT			(WEAPON_HOOK+2)
#define WEAPON_SPANNER			(WEAPON_HOOK+3)
#define WEAPON_AXE				(WEAPON_HOOK+4)
#define WEAPON_SNIPER_RIFLE		(WEAPON_HOOK+5)
#define WEAPON_AUTO_RIFLE		(WEAPON_HOOK+6)
#define WEAPON_TF_SHOTGUN		(WEAPON_HOOK+7)
#define WEAPON_SUPER_SHOTGUN	(WEAPON_HOOK+8)
#define WEAPON_NAILGUN			(WEAPON_HOOK+9)
#define WEAPON_SUPER_NAILGUN	(WEAPON_HOOK+10)
#define WEAPON_GRENADE_LAUNCHER	(WEAPON_HOOK+11)
#define WEAPON_FLAMETHROWER		(WEAPON_HOOK+12)
#define WEAPON_ROCKET_LAUNCHER	(WEAPON_HOOK+13)
#define WEAPON_INCENDIARY		(WEAPON_HOOK+14)
#define WEAPON_ASSAULT_CANNON	(WEAPON_HOOK+16)
#define WEAPON_LIGHTNING		(WEAPON_HOOK+17)
#define WEAPON_DETPACK			(WEAPON_HOOK+18)
#define WEAPON_TRANQ			(WEAPON_HOOK+19)
#define WEAPON_LASER			(WEAPON_HOOK+20)
#define WEAPON_PIPEBOMB_LAUNCHER (WEAPON_HOOK+21)
#define WEAPON_KNIFE			(WEAPON_HOOK+22)
#define WEAPON_BENCHMARK		(WEAPON_HOOK+23)

/*==================================================*/
/* New Weapon Related Defines		                */
/*==================================================*/
// shots per reload 
#define RE_SHOTGUN			8
#define RE_SUPER_SHOTGUN	16 // 8 shots
#define RE_GRENADE_LAUNCHER	6 
#define RE_ROCKET_LAUNCHER	4 

// reload times
#define RE_SHOTGUN_TIME				2 
#define RE_SUPER_SHOTGUN_TIME		3 
#define RE_GRENADE_LAUNCHER_TIME	4 
#define RE_ROCKET_LAUNCHER_TIME		5 

// Maximum velocity you can move and fire the Sniper Rifle
#define WEAP_SNIPER_RIFLE_MAX_MOVE	50 

// Medikit
#define WEAP_MEDIKIT_HEAL	200  // Amount medikit heals per hit
#define WEAP_MEDIKIT_OVERHEAL 50 // Amount of superhealth over max_health the medikit will dispense

// Spanner
#define WEAP_SPANNER_REPAIR 10

// Detpack
#define WEAP_DETPACK_DISARMTIME		3   	// Time it takes to disarm a Detpack
#define WEAP_DETPACK_SETTIME		3   	// Time it takes to set a Detpack
#define WEAP_DETPACK_SIZE			700	 	// Explosion Size
#define WEAP_DETPACK_GOAL_SIZE		1500 	// Explosion Size for goal triggering
#define WEAP_DETPACK_BITS_NO		12  	// Bits that detpack explodes into

// Tranquiliser Gun
#define TRANQ_TIME			15

// Grenades
#define GR_PRIMETIME		3
#define GR_CALTROP_PRIME	0.5
#define GR_TYPE_NONE		0 
#define GR_TYPE_NORMAL		1 
#define GR_TYPE_CONCUSSION	2 
#define GR_TYPE_NAIL		3 
#define GR_TYPE_MIRV		4 
#define GR_TYPE_NAPALM		5 
//#define GR_TYPE_FLARE		6 
#define GR_TYPE_GAS			7
#define GR_TYPE_EMP			8
#define GR_TYPE_CALTROP		9
//#define GR_TYPE_FLASH		10

// Defines for WeaponMode
#define GL_NORMAL	0 
#define GL_PIPEBOMB	1

// Defines for OLD Concussion Grenade
#define GR_OLD_CONCUSS_TIME		5 
#define GR_OLD_CONCUSS_DEC		20 

// Defines for Concussion Grenade
#define GR_CONCUSS_TIME		0.25 
#define GR_CONCUSS_DEC		10
#define MEDIUM_PING			150
#define HIGH_PING			200

// Defines for the Gas Grenade
#define GR_HALLU_TIME		0.3
#define GR_OLD_HALLU_TIME	0.5
#define GR_HALLU_DEC		2.5

// Defines for the BioInfection
#define BIO_JUMP_RADIUS 128		// The distance the bioinfection can jump between players

/*==================================================*/
/* New Items			                        	*/
/*==================================================*/
#define NIT_SCANNER				1 

#define NIT_SILVER_DOOR_OPENED 	#IT_KEY1	// 131072 
#define NIT_GOLD_DOOR_OPENED 	#IT_KEY2	// 262144

/*==================================================*/
/* New Item Flags		                        	*/
/*==================================================*/
#define NIT_SCANNER_ENEMY		1 	// Detect enemies
#define NIT_SCANNER_FRIENDLY	2 	// Detect friendlies (team members)
#define NIT_SCANNER_SOUND		4 	// Motion detection. Only report moving entities.

/*==================================================*/
/* New Item Related Defines		                    */
/*==================================================*/
#define NIT_SCANNER_POWER			25	// The amount of power spent on a scan with the scanner
										// is multiplied by this to get the scanrange.
#define NIT_SCANNER_MAXCELL			50 	// The maximum number of cells than can be used in one scan
#define NIT_SCANNER_MIN_MOVEMENT	50 	// The minimum velocity an entity must have to be detected
										// by scanners that only detect movement

/*==================================================*/
/* Variables used for New Weapons and Reloading     */
/*==================================================*/
// Armor Classes : Bitfields. Use the "armorclass" of armor for the Armor Type.
#define AT_SAVESHOT			1   // Kevlar  	 : Reduces bullet damage by 15%
#define AT_SAVENAIL			2   // Wood :) 	 : Reduces nail damage by 15%
#define AT_SAVEEXPLOSION	4  	// Blast   	 : Reduces explosion damage by 15%
#define AT_SAVEELECTRICITY	8 	// Shock	 : Reduces electricity damage by 15%
#define AT_SAVEFIRE			16 	// Asbestos	 : Reduces fire damage by 15%

/*==========================================================================*/
/* TEAMFORTRESS CLASS DETAILS												*/
/*==========================================================================*/
// Class Details for SCOUT
#define PC_SCOUT_SKIN				4 		// Skin for this class when Classkin is on.
#define PC_SCOUT_MAXHEALTH			75 		// Maximum Health Level
#define PC_SCOUT_MAXSPEED			400		// Maximum movement speed
#define PC_SCOUT_MAXSTRAFESPEED		400		// Maximum strafing movement speed
#define PC_SCOUT_MAXARMOR			50 		// Maximum Armor Level, of any armor class
#define PC_SCOUT_INITARMOR			25 		// Armor level when respawned
#define PC_SCOUT_MAXARMORTYPE		0.3		// Maximum level of Armor absorption
#define PC_SCOUT_INITARMORTYPE		0.3		// Absorption Level of armor when respawned
#define PC_SCOUT_ARMORCLASSES		3 		// #AT_SAVESHOT | #AT_SAVENAIL   		<-Armor Classes allowed for this class
#define PC_SCOUT_INITARMORCLASS		0 		// Armorclass worn when respawned
#define PC_SCOUT_WEAPONS			WEAP_AXE | WEAP_SHOTGUN | WEAP_NAILGUN
#define PC_SCOUT_MAXAMMO_SHOT		50 		// Maximum amount of shot ammo this class can carry
#define PC_SCOUT_MAXAMMO_NAIL		200		// Maximum amount of nail ammo this class can carry
#define PC_SCOUT_MAXAMMO_CELL		100		// Maximum amount of cell ammo this class can carry
#define PC_SCOUT_MAXAMMO_ROCKET		25 		// Maximum amount of rocket ammo this class can carry
#define PC_SCOUT_INITAMMO_SHOT		25 		// Amount of shot ammo this class has when respawned
#define PC_SCOUT_INITAMMO_NAIL		100		// Amount of nail ammo this class has when respawned
#define PC_SCOUT_INITAMMO_CELL		50 		// Amount of cell ammo this class has when respawned
#define PC_SCOUT_INITAMMO_ROCKET	0 		// Amount of rocket ammo this class has when respawned
#define PC_SCOUT_GRENADE_TYPE_1		GR_TYPE_CALTROP			 //    <- 1st Type of Grenade this class has
#define PC_SCOUT_GRENADE_TYPE_2		GR_TYPE_CONCUSSION      //    <- 2nd Type of Grenade this class has
#define PC_SCOUT_GRENADE_INIT_1		2 		// Number of grenades of Type 1 this class has when respawned
#define PC_SCOUT_GRENADE_INIT_2		3 		// Number of grenades of Type 2 this class has when respawned
#define PC_SCOUT_TF_ITEMS			NIT_SCANNER  // <- TeamFortress Items this class has

#define PC_SCOUT_MOTION_MIN_I		0.5 	// < Short range
#define PC_SCOUT_MOTION_MIN_MOVE	50 		// Minimum vlen of player velocity to be picked up by motion detector
#define PC_SCOUT_SCAN_TIME			2		// # of seconds between each scan pulse
#define PC_SCOUT_SCAN_RANGE			100		// Default scanner range
#define PC_SCOUT_SCAN_COST			2		// Default scanner cell usage per scan

// Class Details for SNIPER
#define PC_SNIPER_SKIN				5 
#define PC_SNIPER_MAXHEALTH			90 
#define PC_SNIPER_MAXSPEED			300 		
#define PC_SNIPER_MAXSTRAFESPEED	300 
#define PC_SNIPER_MAXARMOR			50 
#define PC_SNIPER_INITARMOR			0 
#define PC_SNIPER_MAXARMORTYPE		0.3 
#define PC_SNIPER_INITARMORTYPE		0.3 
#define PC_SNIPER_ARMORCLASSES		3 		// #AT_SAVESHOT | #AT_SAVENAIL
#define PC_SNIPER_INITARMORCLASS	0 
#define PC_SNIPER_WEAPONS			WEAP_SNIPER_RIFLE | WEAP_AUTO_RIFLE | WEAP_AXE | WEAP_NAILGUN
#define PC_SNIPER_MAXAMMO_SHOT		75 
#define PC_SNIPER_MAXAMMO_NAIL		100 
#define PC_SNIPER_MAXAMMO_CELL		50 
#define PC_SNIPER_MAXAMMO_ROCKET	25 
#define PC_SNIPER_INITAMMO_SHOT		60 
#define PC_SNIPER_INITAMMO_NAIL		50 
#define PC_SNIPER_INITAMMO_CELL		0 
#define PC_SNIPER_INITAMMO_ROCKET	0 
#define PC_SNIPER_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_SNIPER_GRENADE_TYPE_2	GR_TYPE_NONE
#define PC_SNIPER_GRENADE_INIT_1	2 	 
#define PC_SNIPER_GRENADE_INIT_2	0
#define PC_SNIPER_TF_ITEMS			0 

// Class Details for SOLDIER
#define PC_SOLDIER_SKIN				6 			
#define PC_SOLDIER_MAXHEALTH		100	 
#define PC_SOLDIER_MAXSPEED			240 
#define PC_SOLDIER_MAXSTRAFESPEED	240 
#define PC_SOLDIER_MAXARMOR			200 
#define PC_SOLDIER_INITARMOR		100 
#define PC_SOLDIER_MAXARMORTYPE		0.8 
#define PC_SOLDIER_INITARMORTYPE	0.8 
#define PC_SOLDIER_ARMORCLASSES		31 		// ALL
#define PC_SOLDIER_INITARMORCLASS	0 
#define PC_SOLDIER_WEAPONS		 	WEAP_AXE | WEAP_SHOTGUN | WEAP_SUPER_SHOTGUN | WEAP_ROCKET_LAUNCHER
#define PC_SOLDIER_MAXAMMO_SHOT		100 
#define PC_SOLDIER_MAXAMMO_NAIL		100 
#define PC_SOLDIER_MAXAMMO_CELL		50 
#define PC_SOLDIER_MAXAMMO_ROCKET	50 
#define PC_SOLDIER_INITAMMO_SHOT	50 
#define PC_SOLDIER_INITAMMO_NAIL	0 
#define PC_SOLDIER_INITAMMO_CELL	0 
#define PC_SOLDIER_INITAMMO_ROCKET	10 
#define PC_SOLDIER_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_SOLDIER_GRENADE_TYPE_2	GR_TYPE_NAIL
#define PC_SOLDIER_GRENADE_INIT_1	2
#define PC_SOLDIER_GRENADE_INIT_2	1 	 
#define PC_SOLDIER_TF_ITEMS			0 

#define MAX_NAIL_GRENS				2	// Can only have 2 Nail grens active
#define MAX_NAPALM_GRENS			2	// Can only have 2 Napalm grens active
#define MAX_GAS_GRENS				2	// Can only have 2 Gas grenades active
#define MAX_MIRV_GRENS				2	// Can only have 2 Mirv's
#define MAX_CONCUSSION_GRENS		3
#define MAX_CALTROP_CANS			3

// Class Details for DEMOLITION MAN
#define PC_DEMOMAN_SKIN				1 
#define PC_DEMOMAN_MAXHEALTH		90 
#define PC_DEMOMAN_MAXSPEED			280 		
#define PC_DEMOMAN_MAXSTRAFESPEED	280 
#define PC_DEMOMAN_MAXARMOR			120 
#define PC_DEMOMAN_INITARMOR		50 
#define PC_DEMOMAN_MAXARMORTYPE		0.6 
#define PC_DEMOMAN_INITARMORTYPE	0.6 
#define PC_DEMOMAN_ARMORCLASSES		31 		// ALL
#define PC_DEMOMAN_INITARMORCLASS	0 		
#define PC_DEMOMAN_WEAPONS			WEAP_AXE | WEAP_SHOTGUN | WEAP_GRENADE_LAUNCHER | WEAP_DETPACK
#define PC_DEMOMAN_MAXAMMO_SHOT		75 
#define PC_DEMOMAN_MAXAMMO_NAIL		50 
#define PC_DEMOMAN_MAXAMMO_CELL		50 
#define PC_DEMOMAN_MAXAMMO_ROCKET	50 
#define PC_DEMOMAN_MAXAMMO_DETPACK	1 
#define PC_DEMOMAN_INITAMMO_SHOT	30 
#define PC_DEMOMAN_INITAMMO_NAIL	0 
#define PC_DEMOMAN_INITAMMO_CELL	0 
#define PC_DEMOMAN_INITAMMO_ROCKET	20 
#define PC_DEMOMAN_INITAMMO_DETPACK	1 
#define PC_DEMOMAN_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_DEMOMAN_GRENADE_TYPE_2	GR_TYPE_MIRV
#define PC_DEMOMAN_GRENADE_INIT_1	2
#define PC_DEMOMAN_GRENADE_INIT_2	2 	 
#define PC_DEMOMAN_TF_ITEMS			0 

// Class Details for COMBAT MEDIC
#define PC_MEDIC_SKIN				3 
#define PC_MEDIC_MAXHEALTH			90 
#define PC_MEDIC_MAXSPEED			320 
#define PC_MEDIC_MAXSTRAFESPEED		320 
#define PC_MEDIC_MAXARMOR			100
#define PC_MEDIC_INITARMOR			50 
#define PC_MEDIC_MAXARMORTYPE		0.6 
#define PC_MEDIC_INITARMORTYPE		0.3 
#define PC_MEDIC_ARMORCLASSES		11 		// ALL except EXPLOSION
#define PC_MEDIC_INITARMORCLASS		0 
#define PC_MEDIC_WEAPONS			WEAP_BIOWEAPON | WEAP_MEDIKIT | WEAP_SHOTGUN | WEAP_SUPER_SHOTGUN | WEAP_SUPER_NAILGUN
#define PC_MEDIC_MAXAMMO_SHOT		75 
#define PC_MEDIC_MAXAMMO_NAIL		150 
#define PC_MEDIC_MAXAMMO_CELL		50 
#define PC_MEDIC_MAXAMMO_ROCKET		25 
#define PC_MEDIC_MAXAMMO_MEDIKIT	100 
#define PC_MEDIC_INITAMMO_SHOT		50 
#define PC_MEDIC_INITAMMO_NAIL		50 
#define PC_MEDIC_INITAMMO_CELL		0 
#define PC_MEDIC_INITAMMO_ROCKET	0 
#define PC_MEDIC_INITAMMO_MEDIKIT	50 
#define PC_MEDIC_GRENADE_TYPE_1		GR_TYPE_NORMAL
#define PC_MEDIC_GRENADE_TYPE_2		GR_TYPE_CONCUSSION
#define PC_MEDIC_GRENADE_INIT_1		2
#define PC_MEDIC_GRENADE_INIT_2		2 	 
#define PC_MEDIC_TF_ITEMS			0 
#define PC_MEDIC_REGEN_TIME			3   // Number of seconds between each regen.
#define PC_MEDIC_REGEN_AMOUNT		2 	// Amount of health regenerated each regen.

// Class Details for HVYWEAP
#define PC_HVYWEAP_SKIN				2 
#define PC_HVYWEAP_MAXHEALTH		100 
#define PC_HVYWEAP_MAXSPEED			230		
#define PC_HVYWEAP_MAXSTRAFESPEED	230
#define PC_HVYWEAP_MAXARMOR			300 
#define PC_HVYWEAP_INITARMOR		150 
#define PC_HVYWEAP_MAXARMORTYPE		0.8 
#define PC_HVYWEAP_INITARMORTYPE	0.8 
#define PC_HVYWEAP_ARMORCLASSES		31 			// ALL
#define PC_HVYWEAP_INITARMORCLASS	0 		
#define PC_HVYWEAP_WEAPONS			WEAP_ASSAULT_CANNON | WEAP_AXE | WEAP_SHOTGUN | WEAP_SUPER_SHOTGUN
#define PC_HVYWEAP_MAXAMMO_SHOT		200 
#define PC_HVYWEAP_MAXAMMO_NAIL		200 
#define PC_HVYWEAP_MAXAMMO_CELL		50 
#define PC_HVYWEAP_MAXAMMO_ROCKET	25 
#define PC_HVYWEAP_INITAMMO_SHOT	200 
#define PC_HVYWEAP_INITAMMO_NAIL	0 
#define PC_HVYWEAP_INITAMMO_CELL	30 
#define PC_HVYWEAP_INITAMMO_ROCKET	0 
#define PC_HVYWEAP_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_HVYWEAP_GRENADE_TYPE_2	GR_TYPE_MIRV
#define PC_HVYWEAP_GRENADE_INIT_1	2
#define PC_HVYWEAP_GRENADE_INIT_2	1 	 
#define PC_HVYWEAP_TF_ITEMS			0 
#define PC_HVYWEAP_CELL_USAGE		7	// Amount of cells spent to power up assault cannon



// Class Details for PYRO
#define PC_PYRO_SKIN			21 
#define PC_PYRO_MAXHEALTH		100 
#define PC_PYRO_MAXSPEED		300 
#define PC_PYRO_MAXSTRAFESPEED	300
#define PC_PYRO_MAXARMOR		150 
#define PC_PYRO_INITARMOR		50 
#define PC_PYRO_MAXARMORTYPE	0.6 
#define PC_PYRO_INITARMORTYPE	0.6 
#define PC_PYRO_ARMORCLASSES	27 		// ALL except EXPLOSION
#define PC_PYRO_INITARMORCLASS	16  	// #AT_SAVEFIRE
#define PC_PYRO_WEAPONS			WEAP_INCENDIARY | WEAP_FLAMETHROWER | WEAP_AXE | WEAP_SHOTGUN
#define PC_PYRO_MAXAMMO_SHOT	40 
#define PC_PYRO_MAXAMMO_NAIL	50 
#define PC_PYRO_MAXAMMO_CELL	200 
#define PC_PYRO_MAXAMMO_ROCKET	20 
#define PC_PYRO_INITAMMO_SHOT	20 
#define PC_PYRO_INITAMMO_NAIL	0 
#define PC_PYRO_INITAMMO_CELL	120 
#define PC_PYRO_INITAMMO_ROCKET	5 
#define PC_PYRO_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_PYRO_GRENADE_TYPE_2	GR_TYPE_NAPALM
#define PC_PYRO_GRENADE_INIT_1	2
#define PC_PYRO_GRENADE_INIT_2	4 	 
#define PC_PYRO_TF_ITEMS		0
#define PC_PYRO_ROCKET_USAGE	3	// Number of rockets per incendiary cannon shot

// Class Details for SPY
#define PC_SPY_SKIN				22 
#define PC_SPY_MAXHEALTH		90 
#define PC_SPY_MAXSPEED			300 
#define PC_SPY_MAXSTRAFESPEED	300 
#define PC_SPY_MAXARMOR			100 
#define PC_SPY_INITARMOR		25 
#define PC_SPY_MAXARMORTYPE		0.6		// Was 0.3 
#define PC_SPY_INITARMORTYPE	0.6		// Was 0.3
#define PC_SPY_ARMORCLASSES		27 		// ALL except EXPLOSION
#define PC_SPY_INITARMORCLASS	0  
#define PC_SPY_WEAPONS			WEAP_AXE | WEAP_TRANQ | WEAP_SUPER_SHOTGUN | WEAP_NAILGUN
#define PC_SPY_MAXAMMO_SHOT		40 
#define PC_SPY_MAXAMMO_NAIL		100 
#define PC_SPY_MAXAMMO_CELL		30 
#define PC_SPY_MAXAMMO_ROCKET	15 
#define PC_SPY_INITAMMO_SHOT	40 
#define PC_SPY_INITAMMO_NAIL	50 
#define PC_SPY_INITAMMO_CELL	10 
#define PC_SPY_INITAMMO_ROCKET	0 
#define PC_SPY_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_SPY_GRENADE_TYPE_2	GR_TYPE_GAS
#define PC_SPY_GRENADE_INIT_1	2 	 
#define PC_SPY_GRENADE_INIT_2	2 	 
#define PC_SPY_TF_ITEMS			0 
#define PC_SPY_CELL_REGEN_TIME		5	
#define PC_SPY_CELL_REGEN_AMOUNT	1
#define PC_SPY_CELL_USAGE			3	// Amount of cells spent while invisible
#define PC_SPY_GO_UNDERCOVER_TIME	4	// Time it takes to go undercover

// Class Details for ENGINEER
#define PC_ENGINEER_SKIN			22 		// Not used anymore
#define PC_ENGINEER_MAXHEALTH		80 
#define PC_ENGINEER_MAXSPEED		300 
#define PC_ENGINEER_MAXSTRAFESPEED	300
#define PC_ENGINEER_MAXARMOR		50
#define PC_ENGINEER_INITARMOR		25 
#define PC_ENGINEER_MAXARMORTYPE	0.6 
#define PC_ENGINEER_INITARMORTYPE	0.3 
#define PC_ENGINEER_ARMORCLASSES	31 		// ALL
#define PC_ENGINEER_INITARMORCLASS	0  
#define PC_ENGINEER_WEAPONS			WEAP_SPANNER | WEAP_LASER | WEAP_SUPER_SHOTGUN
#define PC_ENGINEER_MAXAMMO_SHOT	50
#define PC_ENGINEER_MAXAMMO_NAIL	50 
#define PC_ENGINEER_MAXAMMO_CELL	200		// synonymous with metal 
#define PC_ENGINEER_MAXAMMO_ROCKET	30 
#define PC_ENGINEER_INITAMMO_SHOT	20 
#define PC_ENGINEER_INITAMMO_NAIL	25 
#define PC_ENGINEER_INITAMMO_CELL	100 	// synonymous with metal 
#define PC_ENGINEER_INITAMMO_ROCKET	0 
#define PC_ENGINEER_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_ENGINEER_GRENADE_TYPE_2	GR_TYPE_EMP
#define PC_ENGINEER_GRENADE_INIT_1	2 	 
#define PC_ENGINEER_GRENADE_INIT_2	2 	 
#define PC_ENGINEER_TF_ITEMS		0 

// Class Details for CIVILIAN
#define PC_CIVILIAN_SKIN			22 
#define PC_CIVILIAN_MAXHEALTH		50
#define PC_CIVILIAN_MAXSPEED		240
#define PC_CIVILIAN_MAXSTRAFESPEED	240
#define PC_CIVILIAN_MAXARMOR		0
#define PC_CIVILIAN_INITARMOR		0 
#define PC_CIVILIAN_MAXARMORTYPE	0
#define PC_CIVILIAN_INITARMORTYPE	0 
#define PC_CIVILIAN_ARMORCLASSES	0 		
#define PC_CIVILIAN_INITARMORCLASS	0
#define PC_CIVILIAN_WEAPONS			WEAP_AXE
#define PC_CIVILIAN_MAXAMMO_SHOT	0
#define PC_CIVILIAN_MAXAMMO_NAIL	0 
#define PC_CIVILIAN_MAXAMMO_CELL	0 
#define PC_CIVILIAN_MAXAMMO_ROCKET	0 
#define PC_CIVILIAN_INITAMMO_SHOT	0 
#define PC_CIVILIAN_INITAMMO_NAIL	0 
#define PC_CIVILIAN_INITAMMO_CELL	0 
#define PC_CIVILIAN_INITAMMO_ROCKET	0 
#define PC_CIVILIAN_GRENADE_TYPE_1	0
#define PC_CIVILIAN_GRENADE_TYPE_2	0
#define PC_CIVILIAN_GRENADE_INIT_1	0 	 
#define PC_CIVILIAN_GRENADE_INIT_2	0 	 
#define PC_CIVILIAN_TF_ITEMS		0 


/*==========================================================================*/
/* TEAMFORTRESS GOALS														*/
/*==========================================================================*/
// For all these defines, see the tfortmap.txt that came with the zip
// for complete descriptions.
// Defines for Goal Activation types : goal_activation (in goals)
#define TFGA_TOUCH			1  // Activated when touched
#define TFGA_TOUCH_DETPACK	2  // Activated when touched by a detpack explosion
#define TFGA_REVERSE_AP		4  // Activated when AP details are _not_ met
#define TFGA_SPANNER		8  // Activated when hit by an engineer's spanner
#define TFGA_DROPTOGROUND	2048 // Drop to Ground when spawning

// Defines for Goal Effects types : goal_effect
#define TFGE_AP				  1  // AP is affected. Default.
#define TFGE_AP_TEAM		  2  // All of the AP's team.
#define TFGE_NOT_AP_TEAM	  4  // All except AP's team.
#define TFGE_NOT_AP			  8  // All except AP.
#define TFGE_WALL			  16 // If set, walls stop the Radius effects
#define TFGE_SAME_ENVIRONMENT 32 // If set, players in a different environment to the Goal are not affected
#define TFGE_TIMER_CHECK_AP	  64 // If set, Timer Goals check their critera for all players fitting their effects

// Defines for Goal Result types : goal_result
#define TFGR_SINGLE				1  // Goal can only be activated once
#define TFGR_ADD_BONUSES		2 	// Any Goals activated by this one give their bonuses
#define TFGR_ENDGAME			4 	// Goal fires Intermission, displays scores, and ends level
#define TFGR_NO_ITEM_RESULTS	8	// GoalItems given by this Goal don't do results
#define TFGR_REMOVE_DISGUISE	16 // Prevent/Remove undercover from any Spy
#define TFGR_FORCE_RESPAWN		32 // Forces the player to teleport to a respawn point
#define TFGR_DESTROY_BUILDINGS	64 // Destroys this player's buildings, if anys

// Defines for Goal Group Result types : goal_group
// None!
// But I'm leaving this variable in there, since it's fairly likely
// that some will show up sometime.

// Defines for Goal Item types, : goal_activation (in items)
#define TFGI_GLOW			1   // Players carrying this GoalItem will glow
#define TFGI_SLOW			2   // Players carrying this GoalItem will move at half-speed
#define TFGI_DROP			4   // Players dying with this item will drop it
#define TFGI_RETURN_DROP	8   // Return if a player with it dies
#define TFGI_RETURN_GOAL	16  // Return if a player with it has it removed by a goal's activation
#define TFGI_RETURN_REMOVE	32  // Return if it is removed by TFGI_REMOVE
#define TFGI_REVERSE_AP		64  // Only pickup if the player _doesn't_ match AP Details
#define TFGI_REMOVE			128 // Remove if left untouched for 2 minutes after being dropped
#define TFGI_KEEP			256 // Players keep this item even when they die
#define TFGI_ITEMGLOWS		512	// Item glows when on the ground
#define TFGI_DONTREMOVERES	1024 // Don't remove results when the item is removed
#define TFGI_DROPTOGROUND	2048 // Drop To Ground when spawning
#define TFGI_CANBEDROPPED	4096 // Can be voluntarily dropped by players
#define TFGI_SOLID			8192 // Is solid... blocks bullets, etc

// Defines for methods of GoalItem returning
#define GI_RET_DROP_DEAD 	0		// Dropped by a dead player
#define GI_RET_DROP_LIVING 	1		// Dropped by a living player
#define GI_RET_GOAL			2		// Returned by a Goal
#define GI_RET_TIME			3		// Returned due to timeout

// Defines for TeamSpawnpoints : goal_activation (in teamspawns)
#define TFSP_MULTIPLEITEMS	1  // Give out the GoalItem multiple times
#define TFSP_MULTIPLEMSGS	2  // Display the message multiple times

// Defines for TeamSpawnpoints : goal_effects (in teamspawns)
#define TFSP_REMOVESELF		1  // Remove itself after being spawned on

// Defines for Goal States
#define TFGS_ACTIVE		1 
#define TFGS_INACTIVE	2 
#define TFGS_REMOVED	3 
#define TFGS_DELAYED	4

// Defines for GoalItem Removing from Player Methods
#define GI_DROP_PLAYERDEATH	  0		// Dropped by a dying player
#define GI_DROP_REMOVEGOAL	  1		// Removed by a Goal
#define GI_DROP_PLAYERDROP	  2		// Dropped by a player

// Legal Playerclass Handling
#define TF_ILL_SCOUT 		1
#define TF_ILL_SNIPER		2
#define TF_ILL_SOLDIER		4
#define TF_ILL_DEMOMAN		8
#define TF_ILL_MEDIC		16
#define TF_ILL_HVYWEP		32
#define TF_ILL_PYRO			64
#define TF_ILL_RANDOMPC		128
#define TF_ILL_SPY			256
#define TF_ILL_ENGINEER		512

// Addition classes
#define CLASS_TFGOAL					128
#define CLASS_TFGOAL_TIMER			129
#define CLASS_TFGOAL_ITEM			130
#define CLASS_TFSPAWN				   131

/*==========================================================================*/
/* Flamethrower																*/
/*==========================================================================*/
#define FLAME_PLYRMAXTIME	5.0 // lifetime in seconds of a flame on a player
#define FLAME_MAXBURNTIME	8  	// lifetime in seconds of a flame on the world (big ones)
#define NAPALM_MAXBURNTIME	20 	// lifetime in seconds of flame from a napalm grenade
#define FLAME_MAXPLYRFLAMES	4 	// maximum number of flames on a player
#define FLAME_NUMLIGHTS		1 	// maximum number of light flame 
#define FLAME_BURNRATIO		0.3 // the chance of a flame not 'sticking'
#define GR_TYPE_FLAMES_NO	15 	// number of flames spawned when a grenade explode
#define FLAME_DAMAGE_TIME	1	// Interval between damage burns from flames
#define FLAME_EFFECT_TIME	0.2	// frequency at which we display flame effects.
#define FLAME_THINK_TIME	0.1	// Seconds between times the flame checks burn
#define PER_FLAME_DAMAGE	2	// Damage taken per second per flame by burning players

/*==================================================*/
/* CTF Support defines 								*/
/*==================================================*/
#define CTF_FLAG1 		1
#define CTF_FLAG2 		2
#define CTF_DROPOFF1 	3
#define CTF_DROPOFF2 	4
#define CTF_SCORE1   	5
#define CTF_SCORE2   	6

//.float	hook_out;

/*==================================================*/
/* Camera defines	 								*/
/*==================================================*/
/*
float live_camera;
.float camdist;
.vector camangle;
.entity camera_list;
*/

/*==================================================*/
/* QuakeWorld defines 								*/
/*==================================================*/
/*
float already_chosen_map;

// grappling hook variables
.entity	hook;	
.float	on_hook;
.float  fire_held_down;// flag - TRUE if player is still holding down the
                       // fire button after throwing a hook.
*/
/*==================================================*/
/* Server Settings								    */
/*==================================================*/
// Admin modes
#define ADMIN_MODE_NONE	0
#define ADMIN_MODE_DEAL	1

/*==================================================*/
/* Death Message defines							*/
/*==================================================*/
#define DMSG_SHOTGUN			1
#define DMSG_SSHOTGUN			2
#define DMSG_NAILGUN			3
#define DMSG_SNAILGUN			4
#define DMSG_GRENADEL			5
#define DMSG_ROCKETL			6
#define DMSG_LIGHTNING			7
#define DMSG_GREN_HAND			8
#define DMSG_GREN_NAIL			9
#define DMSG_GREN_MIRV			10
#define DMSG_GREN_PIPE			11
#define DMSG_DETPACK			12
#define DMSG_BIOWEAPON			13
#define DMSG_BIOWEAPON_ATT		14
#define DMSG_FLAME				15
#define DMSG_DETPACK_DIS		16
#define DMSG_AXE				17
#define DMSG_SNIPERRIFLE		18
#define DMSG_AUTORIFLE			19
#define DMSG_ASSAULTCANNON		20
#define DMSG_HOOK				21
#define DMSG_BACKSTAB			22
#define DMSG_MEDIKIT			23
#define DMSG_GREN_GAS			24
#define DMSG_TRANQ				25
#define DMSG_LASERBOLT			26
#define DMSG_SENTRYGUN_BULLET 	27
#define DMSG_SNIPERLEGSHOT		28
#define DMSG_SNIPERHEADSHOT		29
#define DMSG_GREN_EMP			30
#define DMSG_GREN_EMP_AMMO		31
#define DMSG_SPANNER			32
#define DMSG_INCENDIARY			33
#define DMSG_SENTRYGUN_ROCKET	34
#define DMSG_GREN_FLASH			35
#define DMSG_TRIGGER			36
#define DMSG_MIRROR				37
#define DMSG_SENTRYDEATH		38
#define DMSG_DISPENSERDEATH		39
#define DMSG_GREN_AIRPIPE		40
#define DMSG_CALTROP			41

/*==================================================*/
// TOGGLEFLAGS
/*==================================================*/
// Some of the toggleflags aren't used anymore, but the bits are still
// there to provide compatibility with old maps
#define TFLAG_CLASS_PERSIST			(1 << 0)  		// Persistent Classes Bit
#define TFLAG_CHEATCHECK			(1 << 1) 		// Cheatchecking Bit
#define TFLAG_RESPAWNDELAY			(1 << 2) 		// RespawnDelay bit
//#define TFLAG_UN					(1 << 3)		// NOT USED ANYMORE
#define TFLAG_OLD_GRENS				(1 << 3)		// Use old concussion grenade and flash grenade
#define TFLAG_UN2					(1 << 4)		// NOT USED ANYMORE
#define TFLAG_UN3					(1 << 5)		// NOT USED ANYMORE
#define TFLAG_UN4					(1 << 6)		// NOT USED ANYMORE: Was Autoteam. CVAR tfc_autoteam used now.
#define TFLAG_TEAMFRAGS				(1 << 7)		// Individual Frags, or Frags = TeamScore
#define TFLAG_FIRSTENTRY			(1 << 8)		// Used to determine the first time toggleflags is set
													// In a map. Cannot be toggled by players.
#define TFLAG_SPYINVIS				(1 << 9)		// Spy invisible only
#define TFLAG_GRAPPLE				(1 << 10)	// Grapple on/off
//#define TFLAG_FULLTEAMSCORE		(1 << 11)  	// Each Team's score is TeamScore + Frags
#define TFLAG_FLAGEMULATION			(1 << 12)  	// Flag emulation on for old TF maps
#define TFLAG_USE_STANDARD			(1 << 13)  	// Use the TF War standard for Flag emulation

#define TFLAG_FRAGSCORING			(1 << 14)	// Use frag scoring only

/*======================*/
//      Menu stuff      //
/*======================*/

#define MENU_DEFAULT				1
#define MENU_TEAM 					2
#define MENU_CLASS 					3
#define MENU_MAPBRIEFING			4
#define MENU_INTRO 					5
#define MENU_CLASSHELP				6
#define MENU_CLASSHELP2 			7
#define MENU_REPEATHELP 			8

#define MENU_SPECHELP				9


#define MENU_SPY					12
#define MENU_SPY_SKIN				13
#define MENU_SPY_COLOR				14
#define MENU_ENGINEER				15
#define MENU_ENGINEER_FIX_DISPENSER	16
#define MENU_ENGINEER_FIX_SENTRYGUN	17
#define MENU_ENGINEER_FIX_MORTAR	18
#define MENU_DISPENSER				19
#define MENU_CLASS_CHANGE			20
#define MENU_TEAM_CHANGE			21

#define MENU_REFRESH_RATE 			25

#define MENU_VOICETWEAK				50

//============================
// Timer Types
#define TF_TIMER_ANY				0
#define TF_TIMER_CONCUSSION			1
#define TF_TIMER_INFECTION			2
#define TF_TIMER_HALLUCINATION		3
#define TF_TIMER_TRANQUILISATION	4
#define TF_TIMER_ROTHEALTH			5
#define TF_TIMER_REGENERATION		6
#define TF_TIMER_GRENPRIME			7
#define TF_TIMER_CELLREGENERATION	8
#define TF_TIMER_DETPACKSET			9
#define TF_TIMER_DETPACKDISARM		10
#define TF_TIMER_BUILD				11
#define TF_TIMER_CHECKBUILDDISTANCE 12
#define TF_TIMER_DISGUISE			13
#define TF_TIMER_DISPENSERREFILL	14

// Non Player timers
#define TF_TIMER_RETURNITEM			100
#define TF_TIMER_DELAYEDGOAL		101
#define TF_TIMER_ENDROUND			102

//============================
// Teamscore printing
#define TS_PRINT_SHORT				1
#define TS_PRINT_LONG				2
#define TS_PRINT_LONG_TO_ALL		3

#ifndef TF_DEFS_ONLY

typedef struct
{
	int topColor;
	int bottomColor;
} team_color_t;


/*==================================================*/
/* GLOBAL VARIABLES									*/
/*==================================================*/
// FortressMap stuff
extern float number_of_teams;	// number of teams supported by the map
extern int   illegalclasses[5];	// Illegal playerclasses for all teams
extern int   civilianteams;		// Bitfield holding Civilian teams
extern Vector  rgbcolors[5];		 // RGB colors for each of the 4 teams

extern team_color_t teamcolors[5][PC_LASTCLASS]; // Colors for each of the 4 teams

extern int   teamscores[5];		// Goal Score of each team
extern int	 g_iOrderedTeams[5]; // Teams ordered into order of winners->losers
extern int	 teamfrags[5];		// Total Frags for each team
extern int   teamlives[5];		// Number of lives each team's players have
extern int   teammaxplayers[5];	// Max number of players allowed in each team
extern float teamadvantage[5];	// only used if the teamplay equalisation bits are set
								// stores the damage ratio players take/give
extern int   teamallies[5];		// Keeps track of which teams are allied
extern string_t	team_names[5];

extern BOOL  CTF_Map;
extern BOOL  birthday;
extern BOOL  christmas;

extern float num_world_flames;

// Clan Battle stuff
extern float clan_scores_dumped;
extern float cb_prematch_time;
extern float fOldPrematch;
extern float fOldCeaseFire;
extern float cb_ceasefire_time;
extern float last_id;
extern float spy_off;
extern float old_grens;		
extern float flagem_checked;
extern float flNextEqualisationCalc;
extern BOOL  cease_fire;
extern BOOL  no_cease_fire_text;
extern BOOL  initial_cease_fire;
extern BOOL  last_cease_fire;
// Autokick stuff
extern float autokick_kills;

extern float deathmsg;		// Global, which is set before every T_Damage, to indicate
							// the death message that should be used.

extern char *sTeamSpawnNames[];
extern char *sClassNames[];
extern char *sNewClassModelFiles[];
extern char *sOldClassModelFiles[];
extern char *sClassModels[];
extern char *sClassCfgs[];
extern char *sGrenadeNames[];
extern string_t	team_menu_string;	

extern int toggleflags;					// toggleable flags

extern CBaseEntity* g_pLastSpawns[5];
extern BOOL g_bFirstClient;

extern float g_fNextPrematchAlert;

typedef struct
{
	int			ip;
	edict_t	*pEdict;
} ip_storage_t;

extern ip_storage_t g_IpStorage[32];

class CGhost;
/*==========================================================================*/
BOOL ClassIsRestricted(float tno, int pc);
char* GetTeamName(int tno);
int TeamFortress_GetNoPlayers();
void DestroyBuilding(CBaseEntity *eng, char *bld);
void teamsprint( int tno, CBaseEntity *ignore, int msg_dest, const char *st, const char *param1 = NULL, const char *param2 = NULL, const char *param3 = NULL );
float anglemod( float v );

// Team Funcs
BOOL TeamFortress_TeamIsCivilian(float tno);
void TeamFortress_TeamShowScores(BOOL bLong, CBasePlayer *pPlayer);
BOOL TeamFortress_TeamPutPlayerInTeam();
void TeamFortress_TeamSetColor(int tno);
void TeamFortress_TeamIncreaseScore(int tno, int scoretoadd);
int TeamFortress_TeamGetScoreFrags(int tno);
int TeamFortress_TeamGetNoPlayers(int tno);
float TeamEqualiseDamage(CBaseEntity *targ, CBaseEntity *attacker, float damage);
BOOL IsSpawnPointValid( Vector &pos );
BOOL TeamFortress_SortTeams( void );
void DumpClanScores( void );
void CalculateTeamEqualiser();

// mapscript funcs
void ParseTFServerSettings();
void ParseTFMapSettings();
CBaseEntity* Finditem(int ino);
CBaseEntity* Findgoal(int gno);
CBaseEntity* Findteamspawn(int gno);
void RemoveGoal(CBaseEntity *Goal);
void tfgoalitem_GiveToPlayer(CBaseEntity *Item, CBasePlayer *AP, CBaseEntity *Goal);
void dremove( CBaseEntity *te );
void tfgoalitem_RemoveFromPlayer(CBaseEntity *Item, CBasePlayer *AP, int iMethod);
void tfgoalitem_drop(CBaseEntity *Item, BOOL PAlive, CBasePlayer *P);
void DisplayItemStatus(CBaseEntity *Goal, CBasePlayer *Player, CBaseEntity *Item);
void tfgoalitem_checkgoalreturn(CBaseEntity *Item);
void DoGoalWork(CBaseEntity *Goal, CBasePlayer *AP);
void DoResults(CBaseEntity *Goal, CBasePlayer *AP, BOOL bAddBonuses);
void DoGroupWork(CBaseEntity *Goal, CBasePlayer *AP);
// hooks into the mapscript for all entities
BOOL ActivateDoResults(CBaseEntity *Goal, CBasePlayer *AP, CBaseEntity *ActivatingGoal);
BOOL ActivationSucceeded(CBaseEntity *Goal, CBasePlayer *AP, CBaseEntity *ActivatingGoal);

// prematch & ceasefire
void Display_Prematch();
void Check_Ceasefire();

// admin
void KickPlayer( CBaseEntity *pTarget );
void BanPlayer( CBaseEntity *pTarget );
CGhost *FindGhost( int iGhostID );
int GetBattleID( edict_t *pEntity );

extern cvar_t	tfc_spam_penalty1;// the initial gag penalty for a spammer (seconds)
extern cvar_t	tfc_spam_penalty2;// incremental gag penalty (seconds) for each time gagged spammer continues to speak.
extern cvar_t	tfc_spam_limit; // at this many points, gag the spammer
extern cvar_t	tfc_clanbattle, tfc_clanbattle_prematch, tfc_prematch, tfc_clanbattle_ceasefire, tfc_balance_teams, tfc_balance_scores;
extern cvar_t   tfc_clanbattle_locked, tfc_birthday, tfc_autokick_kills, tfc_fragscoring, tfc_autokick_time, tfc_adminpwd;
extern cvar_t	weaponstay, footsteps, flashlight, aimcrosshair, falldamage, teamplay;
extern cvar_t	allow_spectators;

/*==========================================================================*/
class CTFFlame : public CBaseMonster
{
public:
	void	Spawn( void );
	void	Precache( void );
	void	EXPORT FlameThink( void );
	static  CTFFlame *FlameSpawn( CBaseEntity *pOwner, CBaseEntity *pTarget );
	void	FlameDestroy( void );

	float	m_flNextDamageTime;
};

/*==========================================================================*/
// MAPSCRIPT CLASSES
class CTFGoal : public CBaseAnimating
{
public:
	void	Spawn( void );
	void	StartGoal( void );
	void	EXPORT PlaceGoal( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int		Classify ( void ) { return	CLASS_TFGOAL; }

	void	SetObjectCollisionBox( void );
};
 
class CTFGoalItem : public CTFGoal
{
public:
	void	Spawn( void );
	void	StartItem( void );
	void	EXPORT PlaceItem( void );
	int		Classify ( void ) { return	CLASS_TFGOAL_ITEM; }

	float	m_flDroppedAt;
};

class CTFTimerGoal : public CTFGoal
{
public:
	void	Spawn( void );
	int		Classify ( void ) { return	CLASS_TFGOAL_TIMER; }
};

class CTFSpawn : public CBaseEntity
{
public:
	void	Spawn( void );
	void	Activate( void );
	int		Classify ( void ) { return	CLASS_TFSPAWN; }
	BOOL	CheckTeam( int iTeamNo );

	EHANDLE m_pTeamCheck;
};

class CTFDetect : public CBaseEntity
{
public:
	void	Spawn( void );
	int		Classify ( void ) { return	CLASS_TFGOAL; }
};

class CTelefragDeath : public CBaseEntity
{
public:
	void		Spawn( void );
	void		EXPORT	DeathTouch( CBaseEntity *pOther );
};

class CTeamCheck : public CBaseDelay
{
public:
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	BOOL TeamMatches( int iTeam );
};

class CTeamSet : public CBaseDelay
{
public:
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};

#endif // TF_DEFS_ONLY
#endif // __TF_DEFS_H



```

`cl_dll/include/unicode_strtools.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#pragma once
#ifndef UNICODE_STR_TOOLS_H
#define UNICODE_STR_TOOLS_H


#ifdef _WIN32

typedef wchar_t uchar16;
typedef unsigned int uchar32;

#else

typedef unsigned short uchar16;
typedef unsigned int uchar32;

#endif // _WIN32

enum EStringConvertErrorPolicy
{
	_STRINGCONVERTFLAG_SKIP = 1,
	_STRINGCONVERTFLAG_FAIL = 2,
	_STRINGCONVERTFLAG_ASSERT = 4,

	STRINGCONVERT_REPLACE = 0,
	STRINGCONVERT_SKIP = 1,
	STRINGCONVERT_FAIL = 2,

	STRINGCONVERT_ASSERT_REPLACE = 4,
	STRINGCONVERT_ASSERT_SKIP = 5,
	STRINGCONVERT_ASSERT_FAIL = 6,
};

bool Q_IsValidUChar32(uchar32 uVal);
int Q_UTF32ToUChar32(const uchar32 *pUTF32, uchar32 &uVal, bool &bErr);
int Q_UChar32ToUTF32Len(uchar32 uVal);
int Q_UChar32ToUTF32(uchar32 uVal, uchar32 *pUTF32);
int Q_UChar32ToUTF8Len(uchar32 uVal);
int Q_UChar32ToUTF16Len(uchar32 uVal);
int Q_UChar32ToUTF16(uchar32 uVal, uchar16 *pUTF16Out);
int Q_UChar32ToUTF8(uchar32 uVal, char *pUTF8Out);
int Q_UTF16ToUChar32(const uchar16 *pUTF16, uchar32 &uValueOut, bool &bErrorOut);
int Q_UTF8ToUTF16(const char *pUTF8, uchar16 *pUTF16, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF8ToUTF32(const char *pUTF8, uchar32 *pUTF32, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF16ToUTF8(const uchar16 *pUTF16, char *pUTF8, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF16ToUTF32(const uchar16 *pUTF16, uchar32 *pUTF32, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF32ToUTF8(const uchar32 *pUTF32, char *pUTF8, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF32ToUTF16(const uchar32 *pUTF32, uchar16 *pUTF16, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF8ToUChar32(const char *pUTF8_, uchar32 &uValueOut, bool &bErrorOut);
qboolean Q_UnicodeValidate(const char *pUTF8);
int Q_UnicodeLength(const char *pUTF8);
char *Q_UnicodeAdvance(char *pUTF8, int nChars);
//bool Q_IsMeanSpaceW(uchar16 wch);
bool Q_IsDeprecatedW(uchar16 wch);
uchar16 *StripUnprintableWorker(uchar16 *pwch, bool *pbStrippedAny);
qboolean Q_StripUnprintableAndSpace(char *pch);
qboolean V_UTF8ToUChar32(const char *pUTF8_, uchar32 *uValueOut);
int Q_UnicodeRepair(char *pUTF8);
wchar_t *Q_AdvanceSpace (wchar_t *start);
wchar_t *Q_ReadUToken (wchar_t *start, wchar_t *token, int tokenBufferSize, bool &quoted);

#endif // UNICODE_STR_TOOLS_H

```

`cl_dll/include/vgui_parser.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#pragma once
#ifndef VGUI_PARSER_H
#define VGUI_PARSER_H

#define MAX_TOLOCALIZE_STRING_SIZE 256
#define MAX_LOCALIZEDSTRING_SIZE 2048

void Localize_Init( );
void Localize_Free( );

const char* Localize( const char* string );
void StripEndNewlineFromString( char *str );

void Localize_StripIndices( char *s );
#endif

```

`cl_dll/include/view.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined ( VIEWH )
#define VIEWH 

void V_StartPitchDrift( void );
void V_StopPitchDrift( void );

#endif // !VIEWH
```

`cl_dll/include/wrect.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#pragma once
#if !defined( WRECTH )
#define WRECTH

typedef struct rect_s
{
	int	left;
	int right;
	int top;
	int bottom;

#ifdef __cplusplus
	int Width()
	{
		return right - left;
	}

	int Height()
	{
		return bottom - top;
	}
#endif
} wrect_t;

#endif

```

`cl_dll/input.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// cl.input.c  -- builds an intended movement command to send to the server

//xxxxxx Move bob and pitch drifting code here and other stuff from view if needed

// Quake is a trademark of Id Software, Inc., (c) 1996 Id Software, Inc. All
// rights reserved.
#include "hud.h"
#include "cl_util.h"
#include "camera.h"
#include "kbutton.h"
#include "cvardef.h"
#include "usercmd.h"
#include "const.h"
#include "camera.h"
#include "in_defs.h"
#include "view.h"
#include <string.h>
#include <ctype.h>

#include "vgui_parser.h"
#include "com_weapons.h"

extern int g_weaponselect;
extern cl_enginefunc_t gEngfuncs;

// Defined in pm_math.c
float anglemod( float a );

void IN_Init (void);
void IN_Move ( float frametime, usercmd_t *cmd);
void IN_Shutdown( void );
void V_Init( void );
void VectorAngles( const float *forward, float *angles );
int CL_ButtonBits( int );

// xxx need client dll function to get and clear impuse
extern cvar_t *in_joystick;

int	in_impulse	= 0;
int	in_cancel	= 0;

cvar_t	*m_pitch;
cvar_t	*m_yaw;
cvar_t	*m_forward;
cvar_t	*m_side;

cvar_t	*lookstrafe;
cvar_t	*lookspring;
cvar_t	*cl_pitchup;
cvar_t	*cl_pitchdown;
cvar_t	*cl_upspeed;
cvar_t	*cl_forwardspeed;
cvar_t	*cl_backspeed;
cvar_t	*cl_sidespeed;
cvar_t	*cl_movespeedkey;
cvar_t	*cl_yawspeed;
cvar_t	*cl_pitchspeed;
cvar_t	*cl_anglespeedkey;
cvar_t	*cl_vsmoothing;
/*
===============================================================================

KEY BUTTONS

Continuous button event tracking is complicated by the fact that two different
input sources (say, mouse button 1 and the control key) can both press the
same button, but the button should only be released when both of the
pressing key have been released.

When a key event issues a button command (+forward, +attack, etc), it appends
its key number as a parameter to the command so it can be matched up with
the release.

state bit 0 is the current state of the key
state bit 1 is edge triggered on the up to down transition
state bit 2 is edge triggered on the down to up transition

===============================================================================
*/


kbutton_t	in_mlook;
kbutton_t	in_klook;
kbutton_t	in_jlook;
kbutton_t	in_left;
kbutton_t	in_right;
kbutton_t	in_forward;
kbutton_t	in_back;
kbutton_t	in_lookup;
kbutton_t	in_lookdown;
kbutton_t	in_moveleft;
kbutton_t	in_moveright;
kbutton_t	in_strafe;
kbutton_t	in_speed;
kbutton_t	in_use;
kbutton_t	in_jump;
kbutton_t	in_attack;
kbutton_t	in_attack2;
kbutton_t	in_up;
kbutton_t	in_down;
kbutton_t	in_duck;
kbutton_t	in_reload;
kbutton_t	in_alt1;
kbutton_t	in_score;
kbutton_t	in_break;
kbutton_t	in_graph;  // Display the netgraph

struct kblist_t
{
	kblist_t *next;
	kbutton_t *pkey;
	char name[32];
};

kblist_t *g_kbkeys = NULL;

/*
============
KB_ConvertString

Removes references to +use and replaces them with the keyname in the output string.  If
 a binding is unfound, then the original text is retained.
NOTE:  Only works for text with +word in it.
============
*/
int KB_ConvertString( char *in, char **ppout )
{
	char sz[ 4096 ];
	char binding[ 64 ];
	char *p;
	char *pOut;
	char *pEnd;
	const char *pBinding;

	if ( !ppout )
		return 0;

	*ppout = NULL;
	p = in;
	pOut = sz;
	while ( *p )
	{
		if ( *p == '+' )
		{
			pEnd = binding;
			while ( *p && ( isalnum( *p ) || ( pEnd == binding ) ) && ( ( pEnd - binding ) < 63 ) )
			{
				*pEnd++ = *p++;
			}

			*pEnd =  '\0';

			pBinding = NULL;
			if ( strlen( binding + 1 ) > 0 )
			{
				// See if there is a binding for binding?
				pBinding = gEngfuncs.Key_LookupBinding( binding + 1 );
			}

			if ( pBinding )
			{
				*pOut++ = '[';
				pEnd = (char *)pBinding;
			}
			else
			{
				pEnd = binding;
			}

			while ( *pEnd )
			{
				*pOut++ = *pEnd++;
			}

			if ( pBinding )
			{
				*pOut++ = ']';
			}
		}
		else
		{
			*pOut++ = *p++;
		}
	}

	*pOut = '\0';

	pOut = ( char * )malloc( strlen( sz ) + 1 );
	strcpy( pOut, sz );
	*ppout = pOut;

	return 1;
}

/*
============
KB_Find

Allows the engine to get a kbutton_t directly ( so it can check +mlook state, etc ) for saving out to .cfg files
============
*/
struct kbutton_s DLLEXPORT *KB_Find( const char *name )
{
	kblist_t *p;
	p = g_kbkeys;
	while ( p )
	{
		if ( !stricmp( name, p->name ) )
			return p->pkey;

		p = p->next;
	}
	return NULL;
}

/*
============
KB_Add

Add a kbutton_t * to the list of pointers the engine can retrieve via KB_Find
============
*/
void KB_Add( const char *name, kbutton_t *pkb )
{
	kblist_t *p;	
	kbutton_t *kb;

	kb = KB_Find( name );
	
	if ( kb )
		return;

	p = ( kblist_t * )malloc( sizeof( kblist_t ) );
	memset( p, 0, sizeof( *p ) );

	strcpy( p->name, name );
	p->pkey = pkb;

	p->next = g_kbkeys;
	g_kbkeys = p;
}

/*
============
KB_Init

Add kbutton_t definitions that the engine can query if needed
============
*/
void KB_Init( void )
{
	g_kbkeys = NULL;

	KB_Add( "in_graph", &in_graph );
	KB_Add( "in_mlook", &in_mlook );
	KB_Add( "in_jlook", &in_jlook );
}

/*
============
KB_Shutdown

Clear kblist
============
*/
void KB_Shutdown( void )
{
	kblist_t *p, *n;
	p = g_kbkeys;
	while ( p )
	{
		n = p->next;
		free( p );
		p = n;
	}
	g_kbkeys = NULL;
}

/*
============
KeyDown
============
*/
void KeyDown (kbutton_t *b)
{
	int		k;
	char	*c;

	c = gEngfuncs.Cmd_Argv(1);
	if (c[0])
		k = atoi(c);
	else
		k = -1;		// typed manually at the console for continuous down

	if (k == b->down[0] || k == b->down[1])
		return;		// repeating key
	
	if (!b->down[0])
		b->down[0] = k;
	else if (!b->down[1])
		b->down[1] = k;
	else
	{
		gEngfuncs.Con_DPrintf ("Three keys down for a button '%c' '%c' '%c'!\n", b->down[0], b->down[1], c);
		return;
	}
	
	if (b->state & 1)
		return;		// still down
	b->state |= 1 + 2;	// down + impulse down
}

/*
============
KeyUp
============
*/
void KeyUp (kbutton_t *b)
{
	int		k;
	char	*c;
	
	c = gEngfuncs.Cmd_Argv(1);
	if (c[0])
		k = atoi(c);
	else
	{ // typed manually at the console, assume for unsticking, so clear all
		b->down[0] = b->down[1] = 0;
		b->state = 4;	// impulse up
		return;
	}

	if (b->down[0] == k)
		b->down[0] = 0;
	else if (b->down[1] == k)
		b->down[1] = 0;
	else
		return;		// key up without coresponding down (menu pass through)
	if (b->down[0] || b->down[1])
	{
		//Con_Printf ("Keys down for button: '%c' '%c' '%c' (%d,%d,%d)!\n", b->down[0], b->down[1], c, b->down[0], b->down[1], c);
		return;		// some other key is still holding it down
	}

	if (!(b->state & 1))
		return;		// still up (this should not happen)

	b->state &= ~1;		// now up
	b->state |= 4; 		// impulse up
}

/*
============
HUD_Key_Event

Return 1 to allow engine to process the key, otherwise, act on it as needed
============
*/
int DLLEXPORT HUD_Key_Event( int down, int keynum, const char *pszCurrentBinding )
{
	return 1;
}

void IN_BreakDown( void ) { KeyDown( &in_break );}
void IN_BreakUp( void ) { KeyUp( &in_break ); }
void IN_KLookDown (void) {KeyDown(&in_klook);}
void IN_KLookUp (void) {KeyUp(&in_klook);}
void IN_JLookDown (void) {KeyDown(&in_jlook);}
void IN_JLookUp (void) {KeyUp(&in_jlook);}
void IN_MLookDown (void) {KeyDown(&in_mlook);}
void IN_UpDown(void) {KeyDown(&in_up);}
void IN_UpUp(void) {KeyUp(&in_up);}
void IN_DownDown(void) {KeyDown(&in_down);}
void IN_DownUp(void) {KeyUp(&in_down);}
void IN_LeftDown(void) {KeyDown(&in_left);}
void IN_LeftUp(void) {KeyUp(&in_left);}
void IN_RightDown(void) {KeyDown(&in_right);}
void IN_RightUp(void) {KeyUp(&in_right);}

void IN_ForwardDown(void)
{
	KeyDown(&in_forward);
	gHUD.m_Spectator.HandleButtonsDown( IN_FORWARD );
}

void IN_ForwardUp(void)
{
	KeyUp(&in_forward);
	gHUD.m_Spectator.HandleButtonsUp( IN_FORWARD );
}

void IN_BackDown(void)
{
	KeyDown(&in_back);
	gHUD.m_Spectator.HandleButtonsDown( IN_BACK );
}

void IN_BackUp(void)
{
	KeyUp(&in_back);
	gHUD.m_Spectator.HandleButtonsUp( IN_BACK );
}
void IN_LookupDown(void) {KeyDown(&in_lookup);}
void IN_LookupUp(void) {KeyUp(&in_lookup);}
void IN_LookdownDown(void) {KeyDown(&in_lookdown);}
void IN_LookdownUp(void) {KeyUp(&in_lookdown);}
void IN_MoveleftDown(void)
{
	KeyDown(&in_moveleft);
	gHUD.m_Spectator.HandleButtonsDown( IN_MOVELEFT );
}

void IN_MoveleftUp(void)
{
	KeyUp(&in_moveleft);
	gHUD.m_Spectator.HandleButtonsUp( IN_MOVELEFT );
}

void IN_MoverightDown(void)
{
	KeyDown(&in_moveright);
	gHUD.m_Spectator.HandleButtonsDown( IN_MOVERIGHT );
}

void IN_MoverightUp(void)
{
	KeyUp(&in_moveright);
	gHUD.m_Spectator.HandleButtonsUp( IN_MOVERIGHT );
}
void IN_SpeedDown(void) {KeyDown(&in_speed);}
void IN_SpeedUp(void) {KeyUp(&in_speed);}
void IN_StrafeDown(void) {KeyDown(&in_strafe);}
void IN_StrafeUp(void) {KeyUp(&in_strafe);}

// needs capture by hud/vgui also
extern void __CmdFunc_InputPlayerSpecial(void);

void IN_Attack2Down(void) 
{
	KeyDown(&in_attack2);

	gHUD.m_Spectator.HandleButtonsDown( IN_ATTACK2 );
}

void IN_Attack2Up(void) {KeyUp(&in_attack2);}
void IN_UseDown (void)
{
	KeyDown(&in_use);
	gHUD.m_Spectator.HandleButtonsDown( IN_USE );
}
void IN_UseUp (void) {KeyUp(&in_use);}
void IN_JumpDown (void)
{
	KeyDown(&in_jump);
	gHUD.m_Spectator.HandleButtonsDown( IN_JUMP );

}
void IN_JumpUp (void) {KeyUp(&in_jump);}
void IN_DuckDown(void)
{
	KeyDown(&in_duck);
	gHUD.m_Spectator.HandleButtonsDown( IN_DUCK );

}
void IN_DuckUp(void) {KeyUp(&in_duck);}
void IN_ReloadDown(void) {KeyDown(&in_reload);}
void IN_ReloadUp(void) {KeyUp(&in_reload);}
void IN_Alt1Down(void) {KeyDown(&in_alt1);}
void IN_Alt1Up(void) {KeyUp(&in_alt1);}
void IN_GraphDown(void) {KeyDown(&in_graph);}
void IN_GraphUp(void) {KeyUp(&in_graph);}

void IN_AttackDown(void)
{
	KeyDown( &in_attack );
	gHUD.m_Spectator.HandleButtonsDown( IN_ATTACK );
}

void IN_AttackUp(void)
{
	KeyUp( &in_attack );
	in_cancel = 0;
}

// Special handling
void IN_Cancel(void)
{
	in_cancel = 1;
}

void IN_Impulse (void)
{
	in_impulse = atoi( gEngfuncs.Cmd_Argv(1) );
}

void IN_ScoreDown(void)
{
	KeyDown(&in_score);
}

void IN_ScoreUp(void)
{
	KeyUp(&in_score);
}

void IN_MLookUp (void)
{
	KeyUp( &in_mlook );
#if 0
	if ( !( in_mlook.state & 1 ) && lookspring->value )
	{
		V_StartPitchDrift();
	}
#endif
}

/*
===============
CL_KeyState

Returns 0.25 if a key was pressed and released during the frame,
0.5 if it was pressed and held
0 if held then released, and
1.0 if held for the entire time
===============
*/
float CL_KeyState (kbutton_t *key)
{
	float		val = 0.0;
	int			impulsedown, impulseup, down;
	
	impulsedown = key->state & 2;
	impulseup	= key->state & 4;
	down		= key->state & 1;
	
	if ( impulsedown && !impulseup )
	{
		// pressed and held this frame?
		val = down ? 0.5 : 0.0;
	}

	if ( impulseup && !impulsedown )
	{
		// released this frame?
		// val = down ? 0.0 : 0.0;
		val = 0.0;
	}

	if ( !impulsedown && !impulseup )
	{
		// held the entire frame?
		val = down ? 1.0 : 0.0;
	}

	if ( impulsedown && impulseup )
	{
		if ( down )
		{
			// released and re-pressed this frame
			val = 0.75;	
		}
		else
		{
			// pressed and released this frame
			val = 0.25;	
		}
	}

	// clear impulses
	key->state &= 1;		
	return val;
}

/*
================
CL_AdjustAngles

Moves the local angle positions
================
*/
void CL_AdjustAngles ( float frametime, float *viewangles )
{
	float	speed;
	float	up, down;
	
	if (in_speed.state & 1)
	{
		speed = frametime * cl_anglespeedkey->value;
	}
	else
	{
		speed = frametime;
	}

	if (!(in_strafe.state & 1))
	{
		viewangles[YAW] -= speed*cl_yawspeed->value*CL_KeyState (&in_right);
		viewangles[YAW] += speed*cl_yawspeed->value*CL_KeyState (&in_left);
		viewangles[YAW] = anglemod(viewangles[YAW]);
	}
	if (in_klook.state & 1)
	{
		//V_StopPitchDrift ();
		viewangles[PITCH] -= speed*cl_pitchspeed->value * CL_KeyState (&in_forward);
		viewangles[PITCH] += speed*cl_pitchspeed->value * CL_KeyState (&in_back);
	}
	
	up = CL_KeyState (&in_lookup);
	down = CL_KeyState(&in_lookdown);
	
	viewangles[PITCH] -= speed*cl_pitchspeed->value * up;
	viewangles[PITCH] += speed*cl_pitchspeed->value * down;
#if 0
	if (up || down)
		V_StopPitchDrift ();
#endif
	if (viewangles[PITCH] > cl_pitchdown->value)
		viewangles[PITCH] = cl_pitchdown->value;
	if (viewangles[PITCH] < -cl_pitchup->value)
		viewangles[PITCH] = -cl_pitchup->value;

	if (viewangles[ROLL] > 50)
		viewangles[ROLL] = 50;
	if (viewangles[ROLL] < -50)
		viewangles[ROLL] = -50;
}

/*
================
CL_CreateMove

Send the intended movement message to the server
if active == 1 then we are 1) not playing back demos ( where our commands are ignored ) and
2 ) we have finished signing on to server
================
*/
void DLLEXPORT CL_CreateMove ( float frametime, struct usercmd_s *cmd, int active )
{	
	float spd;
	vec3_t viewangles;
	static vec3_t oldangles;

	if ( active )
	{
		//memset( viewangles, 0, sizeof( vec3_t ) );
		//viewangles[ 0 ] = viewangles[ 1 ] = viewangles[ 2 ] = 0.0;
		gEngfuncs.GetViewAngles( (float *)viewangles );

		CL_AdjustAngles ( frametime, viewangles );

		memset (cmd, 0, sizeof(*cmd));
		
		gEngfuncs.SetViewAngles( (float *)viewangles );

		if ( in_strafe.state & 1 )
		{
			cmd->sidemove += cl_sidespeed->value * CL_KeyState (&in_right);
			cmd->sidemove -= cl_sidespeed->value * CL_KeyState (&in_left);
		}

		cmd->sidemove += cl_sidespeed->value * CL_KeyState (&in_moveright);
		cmd->sidemove -= cl_sidespeed->value * CL_KeyState (&in_moveleft);

		cmd->upmove += cl_upspeed->value * CL_KeyState (&in_up);
		cmd->upmove -= cl_upspeed->value * CL_KeyState (&in_down);

		if ( !(in_klook.state & 1 ) )
		{	
			if(gHUD.m_MOTD.m_bShow)
			{
				gHUD.m_MOTD.scroll -= CL_KeyState (&in_forward);
				gHUD.m_MOTD.scroll += CL_KeyState (&in_back);
			}
			else
			{
				cmd->forwardmove += cl_forwardspeed->value * CL_KeyState (&in_forward);
				cmd->forwardmove -= cl_backspeed->value * CL_KeyState (&in_back);
			}
		}	

		// adjust for speed key
		if ( in_speed.state & 1 )
		{
			cmd->forwardmove *= cl_movespeedkey->value;
			cmd->sidemove *= cl_movespeedkey->value;
			cmd->upmove *= cl_movespeedkey->value;
		}

		// clip to maxspeed
		spd = gEngfuncs.GetClientMaxspeed();
		if ( spd != 0.0 )
		{
			// scale the 3 speeds so that the total velocity is not > cl.maxspeed
			float fmov = sqrt( (cmd->forwardmove*cmd->forwardmove) + (cmd->sidemove*cmd->sidemove) + (cmd->upmove*cmd->upmove) );

			if ( fmov > spd )
			{
				float fratio = spd / fmov;
				cmd->forwardmove *= fratio;
				cmd->sidemove *= fratio;
				cmd->upmove *= fratio;
			}
		}

		// Allow mice and other controllers to add their inputs
		IN_Move ( frametime, cmd );
	}

	cmd->impulse = in_impulse;
	in_impulse = 0;

	cmd->weaponselect = g_weaponselect;
	g_weaponselect = 0;
	//
	// set button and flag bits
	//
	cmd->buttons = CL_ButtonBits( 1 );

	// If they're in a modal dialog, ignore the attack button.
	if ( GetClientVoice()->IsInSquelchMode() )
		cmd->buttons &= ~IN_ATTACK;

	// Using joystick?
	if ( in_joystick->value )
	{
		if ( cmd->forwardmove > 0 )
		{
			cmd->buttons |= IN_FORWARD;
		}
		else if ( cmd->forwardmove < 0 )
		{
			cmd->buttons |= IN_BACK;
		}
	}

	gEngfuncs.GetViewAngles( (float *)viewangles );
	// Set current view angles.

	if ( CL_IsDead() )
	{
		VectorCopy( oldangles, cmd->viewangles );
	}
	else
	{
		VectorCopy( viewangles, cmd->viewangles );
		VectorCopy( viewangles, oldangles );
	}

}

/*
============
CL_ButtonBits

Returns appropriate button info for keyboard and mouse state
Set bResetState to 1 to clear old state info
============
*/
int CL_ButtonBits( int bResetState )
{
	int bits = 0;

	if ( in_attack.state & 3 )
	{
		if(gHUD.m_MOTD.m_bShow)
			gHUD.m_MOTD.Reset();
		else
			bits |= IN_ATTACK;
	}
	
	if (in_duck.state & 3)
	{
		bits |= IN_DUCK;
	}
 
	if (in_jump.state & 3)
	{
		bits |= IN_JUMP;
	}

	if ( in_forward.state & 3 )
	{
		bits |= IN_FORWARD;
	}
	
	if (in_back.state & 3)
	{
		bits |= IN_BACK;
	}

	if (in_use.state & 3)
	{
		bits |= IN_USE;
	}

	if (in_cancel)
	{
		bits |= IN_CANCEL;
	}

	if ( in_left.state & 3 )
	{
		bits |= IN_LEFT;
	}
	
	if (in_right.state & 3)
	{
		bits |= IN_RIGHT;
	}
	
	if ( in_moveleft.state & 3 )
	{
		bits |= IN_MOVELEFT;
	}
	
	if (in_moveright.state & 3)
	{
		bits |= IN_MOVERIGHT;
	}

	if (in_attack2.state & 3)
	{
		bits |= IN_ATTACK2;
	}

	if (in_reload.state & 3)
	{
		bits |= IN_RELOAD;
	}

	if (in_alt1.state & 3)
	{
		bits |= IN_ALT1;
	}

	if ( in_score.state & 3 )
	{
		bits |= IN_SCORE;
	}

	// Dead or in intermission? Shore scoreboard, too
	if( gHUD.m_Scoreboard.ShouldDrawScoreboard( ))
	{
		bits |= IN_SCORE;
	}

	if ( bResetState )
	{
		in_attack.state &= ~2;
		in_duck.state &= ~2;
		in_jump.state &= ~2;
		in_forward.state &= ~2;
		in_back.state &= ~2;
		in_use.state &= ~2;
		in_left.state &= ~2;
		in_right.state &= ~2;
		in_moveleft.state &= ~2;
		in_moveright.state &= ~2;
		in_attack2.state &= ~2;
		in_reload.state &= ~2;
		in_alt1.state &= ~2;
		in_score.state &= ~2;
	}

	return bits;
}

/*
============
CL_ResetButtonBits

============
*/
void CL_ResetButtonBits( int bits )
{
	int bitsNew = CL_ButtonBits( 0 ) ^ bits;

	// Has the attack button been changed
	if ( bitsNew & IN_ATTACK )
	{
		// Was it pressed? or let go?
		if ( bits & IN_ATTACK )
		{
			KeyDown( &in_attack );
		}
		else
		{
			// totally clear state
			in_attack.state &= ~7;
		}
	}
}

/*
============
InitInput
============
*/
void InitInput (void)
{
	gEngfuncs.pfnAddCommand ("+moveup",IN_UpDown);
	gEngfuncs.pfnAddCommand ("-moveup",IN_UpUp);
	gEngfuncs.pfnAddCommand ("+movedown",IN_DownDown);
	gEngfuncs.pfnAddCommand ("-movedown",IN_DownUp);
	gEngfuncs.pfnAddCommand ("+left",IN_LeftDown);
	gEngfuncs.pfnAddCommand ("-left",IN_LeftUp);
	gEngfuncs.pfnAddCommand ("+right",IN_RightDown);
	gEngfuncs.pfnAddCommand ("-right",IN_RightUp);
	gEngfuncs.pfnAddCommand ("+forward",IN_ForwardDown);
	gEngfuncs.pfnAddCommand ("-forward",IN_ForwardUp);
	gEngfuncs.pfnAddCommand ("+back",IN_BackDown);
	gEngfuncs.pfnAddCommand ("-back",IN_BackUp);
	gEngfuncs.pfnAddCommand ("+lookup", IN_LookupDown);
	gEngfuncs.pfnAddCommand ("-lookup", IN_LookupUp);
	gEngfuncs.pfnAddCommand ("+lookdown", IN_LookdownDown);
	gEngfuncs.pfnAddCommand ("-lookdown", IN_LookdownUp);
	gEngfuncs.pfnAddCommand ("+strafe", IN_StrafeDown);
	gEngfuncs.pfnAddCommand ("-strafe", IN_StrafeUp);
	gEngfuncs.pfnAddCommand ("+moveleft", IN_MoveleftDown);
	gEngfuncs.pfnAddCommand ("-moveleft", IN_MoveleftUp);
	gEngfuncs.pfnAddCommand ("+moveright", IN_MoverightDown);
	gEngfuncs.pfnAddCommand ("-moveright", IN_MoverightUp);
	gEngfuncs.pfnAddCommand ("+speed", IN_SpeedDown);
	gEngfuncs.pfnAddCommand ("-speed", IN_SpeedUp);
	gEngfuncs.pfnAddCommand ("+attack", IN_AttackDown);
	gEngfuncs.pfnAddCommand ("-attack", IN_AttackUp);
	gEngfuncs.pfnAddCommand ("+attack2", IN_Attack2Down);
	gEngfuncs.pfnAddCommand ("-attack2", IN_Attack2Up);
	gEngfuncs.pfnAddCommand ("+use", IN_UseDown);
	gEngfuncs.pfnAddCommand ("-use", IN_UseUp);
	gEngfuncs.pfnAddCommand ("+jump", IN_JumpDown);
	gEngfuncs.pfnAddCommand ("-jump", IN_JumpUp);
	gEngfuncs.pfnAddCommand ("impulse", IN_Impulse);
	gEngfuncs.pfnAddCommand ("+klook", IN_KLookDown);
	gEngfuncs.pfnAddCommand ("-klook", IN_KLookUp);
	gEngfuncs.pfnAddCommand ("+mlook", IN_MLookDown);
	gEngfuncs.pfnAddCommand ("-mlook", IN_MLookUp);
	gEngfuncs.pfnAddCommand ("+jlook", IN_JLookDown);
	gEngfuncs.pfnAddCommand ("-jlook", IN_JLookUp);
	gEngfuncs.pfnAddCommand ("+duck", IN_DuckDown);
	gEngfuncs.pfnAddCommand ("-duck", IN_DuckUp);
	gEngfuncs.pfnAddCommand ("+reload", IN_ReloadDown);
	gEngfuncs.pfnAddCommand ("-reload", IN_ReloadUp);
	gEngfuncs.pfnAddCommand ("+alt1", IN_Alt1Down);
	gEngfuncs.pfnAddCommand ("-alt1", IN_Alt1Up);
	gEngfuncs.pfnAddCommand ("+score", IN_ScoreDown);
	gEngfuncs.pfnAddCommand ("-score", IN_ScoreUp);
	gEngfuncs.pfnAddCommand ("+graph", IN_GraphDown);
	gEngfuncs.pfnAddCommand ("-graph", IN_GraphUp);
	gEngfuncs.pfnAddCommand ("+break",IN_BreakDown);
	gEngfuncs.pfnAddCommand ("-break",IN_BreakUp);

	lookstrafe			= gEngfuncs.pfnRegisterVariable ( "lookstrafe", "0", FCVAR_ARCHIVE );
	lookspring			= gEngfuncs.pfnRegisterVariable ( "lookspring", "0", FCVAR_ARCHIVE );
	cl_anglespeedkey	= gEngfuncs.pfnRegisterVariable ( "cl_anglespeedkey", "0.67", 0 );
	cl_yawspeed			= gEngfuncs.pfnRegisterVariable ( "cl_yawspeed", "210", 0 );
	cl_pitchspeed		= gEngfuncs.pfnRegisterVariable ( "cl_pitchspeed", "225", 0 );
	cl_upspeed			= gEngfuncs.pfnRegisterVariable ( "cl_upspeed", "320", 0 );
	cl_forwardspeed		= gEngfuncs.pfnRegisterVariable ( "cl_forwardspeed", "400", FCVAR_ARCHIVE );
	cl_backspeed		= gEngfuncs.pfnRegisterVariable ( "cl_backspeed", "400", FCVAR_ARCHIVE );
	cl_sidespeed		= gEngfuncs.pfnRegisterVariable ( "cl_sidespeed", "400", 0 );
	cl_movespeedkey		= gEngfuncs.pfnRegisterVariable ( "cl_movespeedkey", "0.52", 0 );
	cl_pitchup			= gEngfuncs.pfnRegisterVariable ( "cl_pitchup", "89", 0 );
	cl_pitchdown		= gEngfuncs.pfnRegisterVariable ( "cl_pitchdown", "89", 0 );

	cl_vsmoothing		= gEngfuncs.pfnRegisterVariable ( "cl_vsmoothing", "0.05", FCVAR_ARCHIVE );

	m_pitch			    = gEngfuncs.pfnRegisterVariable ( "m_pitch","0.022", FCVAR_ARCHIVE );
	m_yaw				= gEngfuncs.pfnRegisterVariable ( "m_yaw","0.022", FCVAR_ARCHIVE );
	m_forward			= gEngfuncs.pfnRegisterVariable ( "m_forward","1", FCVAR_ARCHIVE );
	m_side				= gEngfuncs.pfnRegisterVariable ( "m_side","0.8", FCVAR_ARCHIVE );

	// Initialize third person camera controls.
	CAM_Init();
	// Initialize inputs
	IN_Init();
	// Initialize keyboard
	KB_Init();
	// Initialize view system
	V_Init();
}

/*
============
Input_Shutdown
============
*/
void Input_Shutdown (void)
{
	IN_Shutdown();
	KB_Shutdown();
}

```

`cl_dll/input/input_sdl.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// in_win.c -- windows 95 mouse and joystick code
// 02/21/97 JCB Added extended DirectInput code to support external controllers.

#include "port.h"

#include "hud.h"
#include "cl_util.h"
#include "camera.h"
#include "kbutton.h"
#include "cvardef.h"
#include "usercmd.h"
#include "const.h"
#include "camera.h"
#include "in_defs.h"
#include "../engine/keydefs.h"
#include "view.h"
#include "input.h"

#include <SDL2/SDL_mouse.h>
#include <SDL2/SDL_gamecontroller.h>

#define MOUSE_BUTTON_COUNT 5

// Set this to 1 to show mouse cursor.  Experimental
int	g_iVisibleMouse = 0;

extern int iMouseInUse;


// mouse variables
cvar_t		*m_filter;
cvar_t		*sensitivity;

// Custom mouse acceleration (0 disable, 1 to enable, 2 enable with separate yaw/pitch rescale)
static cvar_t *m_customaccel;
//Formula: mousesensitivity = ( rawmousedelta^m_customaccel_exponent ) * m_customaccel_scale + sensitivity
// If mode is 2, then x and y sensitivity are scaled by m_pitch and m_yaw respectively.
// Custom mouse acceleration value.
static cvar_t *m_customaccel_scale;
//Max mouse move scale factor, 0 for no limit
static cvar_t *m_customaccel_max;
//Mouse move is raised to this power before being scaled by scale factor
static cvar_t *m_customaccel_exponent;

int			mouse_buttons;
int			mouse_oldbuttonstate;
POINT		current_pos;
int			old_mouse_x, old_mouse_y, mx_accum, my_accum;
float		mouse_x, mouse_y;

static int	mouseactive = 0;
int			mouseinitialized;

// joystick defines and variables
// where should defines be moved?
#define JOY_ABSOLUTE_AXIS	0x00000000		// control like a joystick
#define JOY_RELATIVE_AXIS	0x00000010		// control like a mouse, spinner, trackball
#define	JOY_MAX_AXES		6				// X, Y, Z, R, U, V
#define JOY_AXIS_X			0
#define JOY_AXIS_Y			1
#define JOY_AXIS_Z			2
#define JOY_AXIS_R			3
#define JOY_AXIS_U			4
#define JOY_AXIS_V			5

enum _ControlList
{
	AxisNada = 0,
	AxisForward,
	AxisLook,
	AxisSide,
	AxisTurn
};



DWORD	dwAxisMap[ JOY_MAX_AXES ];
DWORD	dwControlMap[ JOY_MAX_AXES ];
int	pdwRawValue[ JOY_MAX_AXES ];
DWORD		joy_oldbuttonstate, joy_oldpovstate;

int			joy_id;
DWORD		joy_numbuttons;

SDL_GameController *s_pJoystick = NULL;

// none of these cvars are saved over a session
// this means that advanced controller configuration needs to be executed
// each time.  this avoids any problems with getting back to a default usage
// or when changing from one controller to another.  this way at least something
// works.
cvar_t	*in_joystick;
cvar_t	*joy_name;
cvar_t	*joy_advanced;
cvar_t	*joy_advaxisx;
cvar_t	*joy_advaxisy;
cvar_t	*joy_advaxisz;
cvar_t	*joy_advaxisr;
cvar_t	*joy_advaxisu;
cvar_t	*joy_advaxisv;
cvar_t	*joy_forwardthreshold;
cvar_t	*joy_sidethreshold;
cvar_t	*joy_pitchthreshold;
cvar_t	*joy_yawthreshold;
cvar_t	*joy_forwardsensitivity;
cvar_t	*joy_sidesensitivity;
cvar_t	*joy_pitchsensitivity;
cvar_t	*joy_yawsensitivity;
cvar_t	*joy_wwhack1;
cvar_t	*joy_wwhack2;

int			joy_avail, joy_advancedinit, joy_haspov;

#ifdef _WIN32
DWORD	s_hMouseThreadId = 0;
HANDLE	s_hMouseThread = 0;
HANDLE	s_hMouseQuitEvent = 0;
HANDLE	s_hMouseDoneQuitEvent = 0;
#endif

/*
===========
Force_CenterView_f
===========
*/
void Force_CenterView_f (void)
{
	vec3_t viewangles;

	if (!iMouseInUse)
	{
		gEngfuncs.GetViewAngles( (float *)viewangles );
	    viewangles[PITCH] = 0;
		gEngfuncs.SetViewAngles( (float *)viewangles );
	}
}

#ifdef _WIN32
long s_mouseDeltaX = 0;
long s_mouseDeltaY = 0;
POINT		old_mouse_pos;

long ThreadInterlockedExchange( long *pDest, long value )
{
	return InterlockedExchange( pDest, value );
}


DWORD WINAPI MousePos_ThreadFunction( LPVOID p )
{
	s_hMouseDoneQuitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	while ( 1 )
	{
		if ( WaitForSingleObject( s_hMouseQuitEvent, (int)m_mousethread_sleep->value ) == WAIT_OBJECT_0 )
		{
			return 0;
		}

		if ( mouseactive )
		{
			POINT		mouse_pos;
			GetCursorPos(&mouse_pos);

			volatile int mx = mouse_pos.x - old_mouse_pos.x + s_mouseDeltaX;
			volatile int my = mouse_pos.y - old_mouse_pos.y + s_mouseDeltaY;
 
			ThreadInterlockedExchange( &old_mouse_pos.x, mouse_pos.x );
			ThreadInterlockedExchange( &old_mouse_pos.y, mouse_pos.y );

			ThreadInterlockedExchange( &s_mouseDeltaX, mx );
			ThreadInterlockedExchange( &s_mouseDeltaY, my );
		}
	}

	SetEvent( s_hMouseDoneQuitEvent );

	return 0;
}
#endif

/*
===========
IN_ActivateMouse
===========
*/
void DLLEXPORT IN_ActivateMouse (void)
{
	if (mouseinitialized)
	{
#ifdef _WIN32
		if (mouseparmsvalid)
			restore_spi = SystemParametersInfo (SPI_SETMOUSE, 0, newmouseparms, 0);

#endif
		mouseactive = 1;
	}
}


/*
===========
IN_DeactivateMouse
===========
*/
void DLLEXPORT IN_DeactivateMouse (void)
{
	if (mouseinitialized)
	{
#ifdef _WIN32
		if (restore_spi)
			SystemParametersInfo (SPI_SETMOUSE, 0, originalmouseparms, 0);

#endif

		mouseactive = 0;
	}
}

/*
===========
IN_StartupMouse
===========
*/
void IN_StartupMouse (void)
{
	if ( gEngfuncs.CheckParm ("-nomouse", NULL ) ) 
		return; 

	mouseinitialized = 1;
#ifdef _WIN32
	mouseparmsvalid = SystemParametersInfo (SPI_GETMOUSE, 0, originalmouseparms, 0);

	if (mouseparmsvalid)
	{
		if ( gEngfuncs.CheckParm ("-noforcemspd", NULL ) ) 
			newmouseparms[2] = originalmouseparms[2];

		if ( gEngfuncs.CheckParm ("-noforcemaccel", NULL ) ) 
		{
			newmouseparms[0] = originalmouseparms[0];
			newmouseparms[1] = originalmouseparms[1];
		}

		if ( gEngfuncs.CheckParm ("-noforcemparms", NULL ) ) 
		{
			newmouseparms[0] = originalmouseparms[0];
			newmouseparms[1] = originalmouseparms[1];
			newmouseparms[2] = originalmouseparms[2];
		}
	}
#endif
	
	mouse_buttons = MOUSE_BUTTON_COUNT;
}

/*
===========
IN_Shutdown
===========
*/
void IN_Shutdown (void)
{
	IN_DeactivateMouse ();

#ifdef _WIN32
	if ( s_hMouseQuitEvent )
	{
		SetEvent( s_hMouseQuitEvent );
		WaitForSingleObject( s_hMouseDoneQuitEvent, 100 );
	}
	
	if ( s_hMouseThread )
	{
		TerminateThread( s_hMouseThread, 0 );
		CloseHandle( s_hMouseThread );
		s_hMouseThread = (HANDLE)0;
	}
	
	if ( s_hMouseQuitEvent )
	{
		CloseHandle( s_hMouseQuitEvent );
		s_hMouseQuitEvent = (HANDLE)0;
	}
	
	
	if ( s_hMouseDoneQuitEvent )
	{
		CloseHandle( s_hMouseDoneQuitEvent );
		s_hMouseDoneQuitEvent = (HANDLE)0;
	}
#endif
}

/*
===========
IN_GetMousePos

Ask for mouse position from engine
===========
*/
void IN_GetMousePos( int *mx, int *my )
{
	gEngfuncs.GetMousePosition( mx, my );
}

/*
===========
IN_ResetMouse

FIXME: Call through to engine?
===========
*/
void IN_ResetMouse( void )
{
	// no work to do in SDL
}

/*
===========
IN_MouseEvent
===========
*/
void DLLEXPORT IN_MouseEvent (int mstate)
{
	int		i;

	if ( iMouseInUse || g_iVisibleMouse )
		return;

	// perform button actions
	for (i=0 ; i<mouse_buttons ; i++)
	{
		if ( (mstate & (1<<i)) &&
			!(mouse_oldbuttonstate & (1<<i)) )
		{
			gEngfuncs.Key_Event (K_MOUSE1 + i, 1);
		}

		if ( !(mstate & (1<<i)) &&
			(mouse_oldbuttonstate & (1<<i)) )
		{
			gEngfuncs.Key_Event (K_MOUSE1 + i, 0);
		}
	}	
	
	mouse_oldbuttonstate = mstate;
}

//-----------------------------------------------------------------------------
// Purpose: Allows modulation of mouse scaling/senstivity value and application
//  of custom algorithms.
// Input  : *x - 
//			*y - 
//-----------------------------------------------------------------------------
void IN_ScaleMouse( float *x, float *y )
{
	float mx = *x;
	float my = *y;

	// This is the default sensitivity
	float mouse_senstivity = ( gHUD.GetSensitivity() != 0 ) ? gHUD.GetSensitivity() : sensitivity->value;

	// Using special accleration values
	if ( m_customaccel->value != 0 ) 
	{ 
		float raw_mouse_movement_distance = sqrt( mx * mx + my * my );
		float acceleration_scale = m_customaccel_scale->value;
		float accelerated_sensitivity_max = m_customaccel_max->value;
		float accelerated_sensitivity_exponent = m_customaccel_exponent->value;
		float accelerated_sensitivity = ( (float)pow( raw_mouse_movement_distance, accelerated_sensitivity_exponent ) * acceleration_scale + mouse_senstivity );

		if ( accelerated_sensitivity_max > 0.0001f && 
			accelerated_sensitivity > accelerated_sensitivity_max )
		{
			accelerated_sensitivity = accelerated_sensitivity_max;
		}

		*x *= accelerated_sensitivity; 
		*y *= accelerated_sensitivity; 

		// Further re-scale by yaw and pitch magnitude if user requests alternate mode 2
		// This means that they will need to up their value for m_customaccel_scale greatly (>40x) since m_pitch/yaw default
		//  to 0.022
		if ( m_customaccel->value == 2 )
		{ 
			*x *= m_yaw->value; 
			*y *= m_pitch->value; 
		} 
	}
	else
	{ 
		// Just apply the default
		*x *= mouse_senstivity;
		*y *= mouse_senstivity;
	}
}

/*
===========
IN_MouseMove
===========
*/
void IN_MouseMove ( float frametime, usercmd_t *cmd)
{
	int		mx, my;
	vec3_t viewangles;

	gEngfuncs.GetViewAngles( (float *)viewangles );

	//jjb - this disbles normal mouse control if the user is trying to 
	//      move the camera, or if the mouse cursor is visible or if we're in intermission
	if ( !iMouseInUse && !gHUD.m_iIntermission && !g_iVisibleMouse )
	{
		int deltaX, deltaY;
#ifdef _WIN32
		if ( !m_bRawInput )
		{
			if ( m_bMouseThread )
			{
				ThreadInterlockedExchange( &current_pos.x, s_mouseDeltaX );
				ThreadInterlockedExchange( &current_pos.y, s_mouseDeltaY );
				ThreadInterlockedExchange( &s_mouseDeltaX, 0 );
				ThreadInterlockedExchange( &s_mouseDeltaY, 0 );
			}
			else
			{
				GetCursorPos (&current_pos);
			}
		}
		else
#endif
		{
			SDL_GetRelativeMouseState( &deltaX, &deltaY );
			current_pos.x = deltaX;
			current_pos.y = deltaY;	
		}
		
#ifdef _WIN32
		if ( !m_bRawInput )
		{
			if ( m_bMouseThread )
			{
				mx = current_pos.x;
				my = current_pos.y;
			}
			else
			{
				mx = current_pos.x - gEngfuncs.GetWindowCenterX() + mx_accum;
				my = current_pos.y - gEngfuncs.GetWindowCenterY() + my_accum;
			}
		}
		else
#endif
		{
			mx = deltaX + mx_accum;
			my = deltaY + my_accum;
		}
		
		mx_accum = 0;
		my_accum = 0;

		if (m_filter && m_filter->value)
		{
			mouse_x = (mx + old_mouse_x) * 0.5;
			mouse_y = (my + old_mouse_y) * 0.5;
		}
		else
		{
			mouse_x = mx;
			mouse_y = my;
		}

		old_mouse_x = mx;
		old_mouse_y = my;

		// Apply custom mouse scaling/acceleration
		IN_ScaleMouse( &mouse_x, &mouse_y );

		// add mouse X/Y movement to cmd
		if ( (in_strafe.state & 1) || (lookstrafe->value && (in_mlook.state & 1) ))
			cmd->sidemove += m_side->value * mouse_x;
		else
			viewangles[YAW] -= m_yaw->value * mouse_x;

		if ( (in_mlook.state & 1) && !(in_strafe.state & 1))
		{
			viewangles[PITCH] += m_pitch->value * mouse_y;
			if (viewangles[PITCH] > cl_pitchdown->value)
				viewangles[PITCH] = cl_pitchdown->value;
			if (viewangles[PITCH] < -cl_pitchup->value)
				viewangles[PITCH] = -cl_pitchup->value;
		}
		else
		{
			if ((in_strafe.state & 1) && gEngfuncs.IsNoClipping() )
			{
				cmd->upmove -= m_forward->value * mouse_y;
			}
			else
			{
				cmd->forwardmove -= m_forward->value * mouse_y;
			}
		}

		// if the mouse has moved, force it to the center, so there's room to move
		if ( mx || my )
		{
			IN_ResetMouse();
		}
	}

	gEngfuncs.SetViewAngles( (float *)viewangles );

/*
//#define TRACE_TEST
#if defined( TRACE_TEST )
	{
		int mx, my;
		void V_Move( int mx, int my );
		IN_GetMousePos( &mx, &my );
		V_Move( mx, my );
	}
#endif
*/
}

/*
===========
IN_Accumulate
===========
*/
void DLLEXPORT IN_Accumulate (void)
{
	//only accumulate mouse if we are not moving the camera with the mouse
	if ( !iMouseInUse && !g_iVisibleMouse)
	{
	    if (mouseactive)
	    {
#ifdef _WIN32
			if ( !m_bRawInput )
			{
				if ( !m_bMouseThread )
				{
					GetCursorPos (&current_pos);
					
					mx_accum += current_pos.x - gEngfuncs.GetWindowCenterX();
					my_accum += current_pos.y - gEngfuncs.GetWindowCenterY();
				}
			}
			else
#endif
			{
				int deltaX, deltaY;
				SDL_GetRelativeMouseState( &deltaX, &deltaY );
				mx_accum += deltaX;
				my_accum += deltaY;	
			}
			// force the mouse to the center, so there's room to move
			IN_ResetMouse();
			
		}
	}

}

/*
===================
IN_ClearStates
===================
*/
void DLLEXPORT IN_ClearStates (void)
{
	if ( !mouseactive )
		return;

	mx_accum = 0;
	my_accum = 0;
	mouse_oldbuttonstate = 0;
}

/* 
=============== 
IN_StartupJoystick 
=============== 
*/  
void IN_StartupJoystick (void) 
{ 
	// abort startup if user requests no joystick
	if ( gEngfuncs.CheckParm ("-nojoy", NULL ) ) 
		return; 
 
 	// assume no joystick
	joy_avail = 0; 

	int nJoysticks = SDL_NumJoysticks();
	if ( nJoysticks > 0 )
	{
		for ( int i = 0; i < nJoysticks; i++ )
		{
			if ( SDL_IsGameController( i ) )
			{
				s_pJoystick = SDL_GameControllerOpen( i );
				if ( s_pJoystick )
				{
					//save the joystick's number of buttons and POV status
					joy_numbuttons = SDL_CONTROLLER_BUTTON_MAX;
					joy_haspov = 0;
					
					// old button and POV states default to no buttons pressed
					joy_oldbuttonstate = joy_oldpovstate = 0;
					
					// mark the joystick as available and advanced initialization not completed
					// this is needed as cvars are not available during initialization
					gEngfuncs.Con_Printf ("joystick found\n\n", SDL_GameControllerName(s_pJoystick)); 
					joy_avail = 1; 
					joy_advancedinit = 0;
					break;
				}

			}
		}
	}
	else
	{
		gEngfuncs.Con_DPrintf ("joystick not found -- driver not present\n\n");
	}
	
}


int RawValuePointer (int axis)
{
	switch (axis)
	{
		default:
		case JOY_AXIS_X:
			return SDL_GameControllerGetAxis( s_pJoystick, SDL_CONTROLLER_AXIS_LEFTX );
		case JOY_AXIS_Y:
			return SDL_GameControllerGetAxis( s_pJoystick, SDL_CONTROLLER_AXIS_LEFTY );
		case JOY_AXIS_Z:
			return SDL_GameControllerGetAxis( s_pJoystick, SDL_CONTROLLER_AXIS_RIGHTX );
		case JOY_AXIS_R:
			return SDL_GameControllerGetAxis( s_pJoystick, SDL_CONTROLLER_AXIS_RIGHTY );
		
	}
}

/*
===========
Joy_AdvancedUpdate_f
===========
*/
void Joy_AdvancedUpdate_f (void)
{

	// called once by IN_ReadJoystick and by user whenever an update is needed
	// cvars are now available
	int	i;
	DWORD dwTemp;

	// initialize all the maps
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		dwAxisMap[i] = AxisNada;
		dwControlMap[i] = JOY_ABSOLUTE_AXIS;
		pdwRawValue[i] = RawValuePointer(i);
	}

	if( joy_advanced->value == 0.0)
	{
		// default joystick initialization
		// 2 axes only with joystick control
		dwAxisMap[JOY_AXIS_X] = AxisTurn;
		// dwControlMap[JOY_AXIS_X] = JOY_ABSOLUTE_AXIS;
		dwAxisMap[JOY_AXIS_Y] = AxisForward;
		// dwControlMap[JOY_AXIS_Y] = JOY_ABSOLUTE_AXIS;
	}
	else
	{
		if ( strcmp ( joy_name->string, "joystick") != 0 )
		{
			// notify user of advanced controller
			gEngfuncs.Con_Printf ("\n%s configured\n\n", joy_name->string);
		}

		// advanced initialization here
		// data supplied by user via joy_axisn cvars
		dwTemp = (DWORD) joy_advaxisx->value;
		dwAxisMap[JOY_AXIS_X] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_X] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisy->value;
		dwAxisMap[JOY_AXIS_Y] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_Y] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisz->value;
		dwAxisMap[JOY_AXIS_Z] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_Z] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisr->value;
		dwAxisMap[JOY_AXIS_R] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_R] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisu->value;
		dwAxisMap[JOY_AXIS_U] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_U] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisv->value;
		dwAxisMap[JOY_AXIS_V] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_V] = dwTemp & JOY_RELATIVE_AXIS;
	}
}


/*
===========
IN_Commands
===========
*/
void IN_Commands (void)
{
	int		i, key_index;

	if (!joy_avail)
	{
		return;
	}

	DWORD	buttonstate, povstate;
	
	// loop through the joystick buttons
	// key a joystick event or auxiliary event for higher number buttons for each state change
	buttonstate = 0;
	for ( i = 0; i < SDL_CONTROLLER_BUTTON_MAX; i++ )
	{
		if ( SDL_GameControllerGetButton( s_pJoystick, (SDL_GameControllerButton)i ) )
		{
			buttonstate |= 1<<i;
		}
	}
	
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		pdwRawValue[i] = RawValuePointer(i);
	}

	for (i=0 ; i < (int)joy_numbuttons ; i++)
	{
		if ( (buttonstate & (1<<i)) && !(joy_oldbuttonstate & (1<<i)) )
		{
			key_index = (i < 4) ? K_JOY1 : K_AUX1;
			gEngfuncs.Key_Event (key_index + i, 1);
		}

		if ( !(buttonstate & (1<<i)) && (joy_oldbuttonstate & (1<<i)) )
		{
			key_index = (i < 4) ? K_JOY1 : K_AUX1;
			gEngfuncs.Key_Event (key_index + i, 0);
		}
	}
	joy_oldbuttonstate = buttonstate;

	if (joy_haspov)
	{
		// convert POV information into 4 bits of state information
		// this avoids any potential problems related to moving from one
		// direction to another without going through the center position
		povstate = 0;
		// determine which bits have changed and key an auxiliary event for each change
		for (i=0 ; i < 4 ; i++)
		{
			if ( (povstate & (1<<i)) && !(joy_oldpovstate & (1<<i)) )
			{
				gEngfuncs.Key_Event (K_AUX29 + i, 1);
			}

			if ( !(povstate & (1<<i)) && (joy_oldpovstate & (1<<i)) )
			{
				gEngfuncs.Key_Event (K_AUX29 + i, 0);
			}
		}
		joy_oldpovstate = povstate;
	}
}


/* 
=============== 
IN_ReadJoystick
=============== 
*/  
int IN_ReadJoystick (void)
{
	SDL_JoystickUpdate();
	return 1;
}


/*
===========
IN_JoyMove
===========
*/
void IN_JoyMove ( float frametime, usercmd_t *cmd )
{
	float	speed, aspeed;
	float	fAxisValue, fTemp;
	int		i;
	vec3_t viewangles;

	gEngfuncs.GetViewAngles( (float *)viewangles );


	// complete initialization if first time in
	// this is needed as cvars are not available at initialization time
	if( joy_advancedinit != 1 )
	{
		Joy_AdvancedUpdate_f();
		joy_advancedinit = 1;
	}

	// verify joystick is available and that the user wants to use it
	if (!joy_avail || !in_joystick->value)
	{
		return; 
	}
 
	// collect the joystick data, if possible
	if (IN_ReadJoystick () != 1)
	{
		return;
	}

	if (in_speed.state & 1)
		speed = cl_movespeedkey->value;
	else
		speed = 1;

	aspeed = speed * frametime;

	// loop through the axes
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		// get the floating point zero-centered, potentially-inverted data for the current axis
		fAxisValue = (float)pdwRawValue[i];

		if (joy_wwhack2->value != 0.0)
		{
			if (dwAxisMap[i] == AxisTurn)
			{
				// this is a special formula for the Logitech WingMan Warrior
				// y=ax^b; where a = 300 and b = 1.3
				// also x values are in increments of 800 (so this is factored out)
				// then bounds check result to level out excessively high spin rates
				fTemp = 300.0 * pow(abs(fAxisValue) / 800.0, 1.3);
				if (fTemp > 14000.0)
					fTemp = 14000.0;
				// restore direction information
				fAxisValue = (fAxisValue > 0.0) ? fTemp : -fTemp;
			}
		}

		// convert range from -32768..32767 to -1..1 
		fAxisValue /= 32768.0;

		switch (dwAxisMap[i])
		{
		case AxisForward:
			if ((joy_advanced->value == 0.0) && (in_jlook.state & 1))
			{
				// user wants forward control to become look control
				if (fabs(fAxisValue) > joy_pitchthreshold->value)
				{		
					// if mouse invert is on, invert the joystick pitch value
					// only absolute control support here (joy_advanced is 0)
					if (m_pitch->value < 0.0)
					{
						viewangles[PITCH] -= (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
					else
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
				}
			}
			else
			{
				// user wants forward control to be forward control
				if (fabs(fAxisValue) > joy_forwardthreshold->value)
				{
					cmd->forwardmove += (fAxisValue * joy_forwardsensitivity->value) * speed * cl_forwardspeed->value;
				}
			}
			break;

		case AxisSide:
			if (fabs(fAxisValue) > joy_sidethreshold->value)
			{
				cmd->sidemove += (fAxisValue * joy_sidesensitivity->value) * speed * cl_sidespeed->value;
			}
			break;

		case AxisTurn:
			if ((in_strafe.state & 1) || (lookstrafe->value && (in_jlook.state & 1)))
			{
				// user wants turn control to become side control
				if (fabs(fAxisValue) > joy_sidethreshold->value)
				{
					cmd->sidemove -= (fAxisValue * joy_sidesensitivity->value) * speed * cl_sidespeed->value;
				}
			}
			else
			{
				// user wants turn control to be turn control
				if (fabs(fAxisValue) > joy_yawthreshold->value)
				{
					if(dwControlMap[i] == JOY_ABSOLUTE_AXIS)
					{
						viewangles[YAW] += (fAxisValue * joy_yawsensitivity->value) * aspeed * cl_yawspeed->value;
					}
					else
					{
						viewangles[YAW] += (fAxisValue * joy_yawsensitivity->value) * speed * 180.0;
					}

				}
			}
			break;

		case AxisLook:
			if (in_jlook.state & 1)
			{
				if (fabs(fAxisValue) > joy_pitchthreshold->value)
				{
					// pitch movement detected and pitch movement desired by user
					if(dwControlMap[i] == JOY_ABSOLUTE_AXIS)
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
					else
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * speed * 180.0;
					}
				}
			}
			break;

		default:
			break;
		}
	}

	// bounds check pitch
	if (viewangles[PITCH] > cl_pitchdown->value)
		viewangles[PITCH] = cl_pitchdown->value;
	if (viewangles[PITCH] < -cl_pitchup->value)
		viewangles[PITCH] = -cl_pitchup->value;

	gEngfuncs.SetViewAngles( (float *)viewangles );
}

/*
===========
IN_Move
===========
*/
void IN_Move ( float frametime, usercmd_t *cmd)
{
	if ( !iMouseInUse && mouseactive )
	{
		IN_MouseMove ( frametime, cmd);
	}

	IN_JoyMove ( frametime, cmd);
}

/*
===========
IN_Init
===========
*/
void IN_Init (void)
{
	m_filter				= gEngfuncs.pfnRegisterVariable ( "m_filter","0", FCVAR_ARCHIVE );
	sensitivity				= gEngfuncs.pfnRegisterVariable ( "sensitivity","3", FCVAR_ARCHIVE ); // user mouse sensitivity setting.

	in_joystick				= gEngfuncs.pfnRegisterVariable ( "joystick","0", FCVAR_ARCHIVE );
	joy_name				= gEngfuncs.pfnRegisterVariable ( "joyname", "joystick", 0 );
	joy_advanced			= gEngfuncs.pfnRegisterVariable ( "joyadvanced", "0", 0 );
	joy_advaxisx			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisx", "0", 0 );
	joy_advaxisy			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisy", "0", 0 );
	joy_advaxisz			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisz", "0", 0 );
	joy_advaxisr			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisr", "0", 0 );
	joy_advaxisu			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisu", "0", 0 );
	joy_advaxisv			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisv", "0", 0 );
	joy_forwardthreshold	= gEngfuncs.pfnRegisterVariable ( "joyforwardthreshold", "0.15", 0 );
	joy_sidethreshold		= gEngfuncs.pfnRegisterVariable ( "joysidethreshold", "0.15", 0 );
	joy_pitchthreshold		= gEngfuncs.pfnRegisterVariable ( "joypitchthreshold", "0.15", 0 );
	joy_yawthreshold		= gEngfuncs.pfnRegisterVariable ( "joyyawthreshold", "0.15", 0 );
	joy_forwardsensitivity	= gEngfuncs.pfnRegisterVariable ( "joyforwardsensitivity", "-1.0", 0 );
	joy_sidesensitivity		= gEngfuncs.pfnRegisterVariable ( "joysidesensitivity", "-1.0", 0 );
	joy_pitchsensitivity	= gEngfuncs.pfnRegisterVariable ( "joypitchsensitivity", "1.0", 0 );
	joy_yawsensitivity		= gEngfuncs.pfnRegisterVariable ( "joyyawsensitivity", "-1.0", 0 );
	joy_wwhack1				= gEngfuncs.pfnRegisterVariable ( "joywwhack1", "0.0", 0 );
	joy_wwhack2				= gEngfuncs.pfnRegisterVariable ( "joywwhack2", "0.0", 0 );

	m_customaccel			= gEngfuncs.pfnRegisterVariable ( "m_customaccel", "0", FCVAR_ARCHIVE );
	m_customaccel_scale		= gEngfuncs.pfnRegisterVariable ( "m_customaccel_scale", "0.04", FCVAR_ARCHIVE );
	m_customaccel_max		= gEngfuncs.pfnRegisterVariable ( "m_customaccel_max", "0", FCVAR_ARCHIVE );
	m_customaccel_exponent	= gEngfuncs.pfnRegisterVariable ( "m_customaccel_exponent", "1", FCVAR_ARCHIVE );

#ifdef _WIN32
	m_bRawInput				= CVAR_GET_FLOAT( "m_rawinput" ) > 0;
	m_bMouseThread			= gEngfuncs.CheckParm ("-mousethread", NULL ) != NULL;
	m_mousethread_sleep			= gEngfuncs.pfnRegisterVariable ( "m_mousethread_sleep", "10", FCVAR_ARCHIVE );

	if ( !m_bRawInput && m_bMouseThread && m_mousethread_sleep ) 
	{
		s_mouseDeltaX = s_mouseDeltaY = 0;
		
		s_hMouseQuitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
		if ( s_hMouseQuitEvent )
		{
			s_hMouseThread = CreateThread( NULL, 0, MousePos_ThreadFunction, NULL, 0, &s_hMouseThreadId );
		}
	}
#endif

	gEngfuncs.pfnAddCommand ("force_centerview", Force_CenterView_f);
	gEngfuncs.pfnAddCommand ("joyadvancedupdate", Joy_AdvancedUpdate_f);

	IN_StartupMouse ();
	IN_StartupJoystick ();
}

```

`cl_dll/input/input_xash3d.cpp`:

```cpp
#include "hud.h"
#include "usercmd.h"
#include "cvardef.h"
#include "kbutton.h"
#include "keydefs.h"
#include "input.h"

#define	PITCH	0
#define	YAW		1
#define	ROLL	2 

cvar_t	*cl_laddermode;
cvar_t	*sensitivity;
cvar_t	*in_joystick;
cvar_t	*evdev_grab;


float ac_forwardmove;
float ac_sidemove;
int ac_movecount;
float rel_yaw;
float rel_pitch;
bool bMouseInUse = false;

extern Vector dead_viewangles;
extern bool evdev_open;

#define F 1U<<0	// Forward
#define B 1U<<1	// Back
#define L 1U<<2	// Left
#define R 1U<<3	// Right
#define T 1U<<4	// Forward stop
#define S 1U<<5	// Side stop

#define BUTTON_DOWN		1
#define IMPULSE_DOWN	2
#define IMPULSE_UP		4

bool CL_IsDead();

void IN_ToggleButtons( float forwardmove, float sidemove )
{
	static unsigned int moveflags = T | S;

	if( forwardmove )
		moveflags &= ~T;
	else
	{
		//if( in_forward.state || in_back.state ) gEngfuncs.Con_Printf("Buttons pressed f%d b%d\n", in_forward.state, in_back.state);
		if( !( moveflags & T ) )
		{
			//IN_ForwardUp();
			//IN_BackUp();
			//gEngfuncs.Con_Printf("Reset forwardmove state f%d b%d\n", in_forward.state, in_back.state);
			in_forward.state &= ~BUTTON_DOWN;
			in_back.state &= ~BUTTON_DOWN;
			moveflags |= T;
		}
	}
	if( sidemove )
		moveflags &= ~S;
	else
	{
		//gEngfuncs.Con_Printf("l%d r%d\n", in_moveleft.state, in_moveright.state);
		//if( in_moveleft.state || in_moveright.state ) gEngfuncs.Con_Printf("Buttons pressed l%d r%d\n", in_moveleft.state, in_moveright.state);
		if( !( moveflags & S ) )
		{
			//IN_MoverightUp();
			//IN_MoveleftUp();
			//gEngfuncs.Con_Printf("Reset sidemove state f%d b%d\n", in_moveleft.state, in_moveright.state);
			in_moveleft.state &= ~BUTTON_DOWN;
			in_moveright.state &= ~BUTTON_DOWN;
			moveflags |= S;
		}
	}

	if ( forwardmove > 0.7 && !( moveflags & F ))
	{
		moveflags |= F;
		in_forward.state |= BUTTON_DOWN;
	}
	if ( forwardmove < 0.7 && ( moveflags & F ))
	{
		moveflags &= ~F;
		in_forward.state &= ~BUTTON_DOWN;
	}
	if ( forwardmove < -0.7 && !( moveflags & B ))
	{
		moveflags |= B;
		in_back.state |= BUTTON_DOWN;
	}
	if ( forwardmove > -0.7 && ( moveflags & B ))
	{
		moveflags &= ~B;
		in_back.state &= ~BUTTON_DOWN;
	}
	if ( sidemove > 0.9 && !( moveflags & R ))
	{
		moveflags |= R;
		in_moveright.state |= BUTTON_DOWN;
	}
	if ( sidemove < 0.9 && ( moveflags & R ))
	{
		moveflags &= ~R;
		in_moveright.state &= ~BUTTON_DOWN;
	}
	if ( sidemove < -0.9 && !( moveflags & L ))
	{
		moveflags |= L;
		in_moveleft.state |= BUTTON_DOWN;
	}
	if ( sidemove > -0.9 && ( moveflags & L ))
	{
		moveflags &= ~L;
		in_moveleft.state &= ~BUTTON_DOWN;
	}

}

void IN_ClientMoveEvent( float forwardmove, float sidemove )
{
	//gEngfuncs.Con_Printf("IN_MoveEvent\n");

	ac_forwardmove += forwardmove;
	ac_sidemove += sidemove;
	ac_movecount++;
}

void IN_ClientLookEvent( float relyaw, float relpitch )
{
	rel_yaw += relyaw;
	rel_pitch += relpitch;
}

// Rotate camera and add move values to usercmd
void IN_Move( float frametime, usercmd_t *cmd )
{
	Vector viewangles;
	bool bLadder = false;

	if( gHUD.m_iIntermission )
		return; // we can't move during intermission


	if( cl_laddermode->value != 2 )
	{
		cl_entity_t *pplayer = gEngfuncs.GetLocalPlayer();
		if( pplayer )
			bLadder = pplayer->curstate.movetype == MOVETYPE_FLY;
	}
	//if(ac_forwardmove || ac_sidemove)
	//gEngfuncs.Con_Printf("Move: %f %f %f %f\n", ac_forwardmove, ac_sidemove, rel_pitch, rel_yaw);
#if 0
	if( in_mlook.state & 1 )
	{
		V_StopPitchDrift();
	}
#endif

	if( CL_IsDead( ) )
	{
		viewangles = dead_viewangles; // HACKHACK: see below
	}
	else
	{
		gEngfuncs.GetViewAngles( viewangles );
	}

	if( gHUD.GetSensitivity() != 0 )
	{
		rel_yaw *= gHUD.GetSensitivity();
		rel_pitch *= gHUD.GetSensitivity();
	}
	else
	{
		rel_yaw *= sensitivity->value;
		rel_pitch *= sensitivity->value;
	}
	if(gHUD.m_MOTD.cl_hide_motd->value == 0.0f && gHUD.m_MOTD.m_bShow)
	{
		gHUD.m_MOTD.scroll += rel_pitch;
	}
	else
	{
		viewangles[PITCH] += rel_pitch;
		viewangles[YAW] += rel_yaw;
		if( bLadder )
		{
			if( ( cl_laddermode->value == 1 ) )
				viewangles[YAW] -= ac_sidemove * 5;
			ac_sidemove = 0;
		}
	}
	if (viewangles[PITCH] > cl_pitchdown->value)
		viewangles[PITCH] = cl_pitchdown->value;
	if (viewangles[PITCH] < -cl_pitchup->value)
		viewangles[PITCH] = -cl_pitchup->value;


	if( !CL_IsDead( ) )
	{
		gEngfuncs.SetViewAngles( viewangles );
	}

	dead_viewangles = viewangles;
	
	if( ac_movecount )
	{
		IN_ToggleButtons( ac_forwardmove / ac_movecount, ac_sidemove / ac_movecount );
		if( ac_forwardmove ) cmd->forwardmove  = ac_forwardmove * cl_forwardspeed->value / ac_movecount;
		if( ac_sidemove ) cmd->sidemove  = ac_sidemove * cl_sidespeed->value / ac_movecount;
		if (in_speed.state & 1)
		{
			cmd->forwardmove *= cl_movespeedkey->value;
			cmd->sidemove *= cl_movespeedkey->value;
		}
	}
	
	ac_sidemove = ac_forwardmove = rel_pitch = rel_yaw = 0;
	ac_movecount = 0;
}

void DLLEXPORT IN_MouseEvent( int mstate )
{
	static int mouse_oldbuttonstate;
	// perform button actions
	for( int i = 0; i < 5; i++ )
	{
		if(( mstate & (1 << i)) && !( mouse_oldbuttonstate & (1 << i)))
		{
			gEngfuncs.Key_Event( K_MOUSE1 + i, 1 );
		}

		if( !( mstate & (1 << i)) && ( mouse_oldbuttonstate & (1 << i)))
		{
			gEngfuncs.Key_Event( K_MOUSE1 + i, 0 );
		}
	}	
	
	mouse_oldbuttonstate = mstate;
	bMouseInUse = true;
}

// Stubs

void DLLEXPORT IN_ClearStates ( void )
{
	//gEngfuncs.Con_Printf("IN_ClearStates\n");
}

void  DLLEXPORT IN_ActivateMouse ( void )
{
	//gEngfuncs.Con_Printf("IN_ActivateMouse\n");
}

void DLLEXPORT  IN_DeactivateMouse ( void )
{
	//gEngfuncs.Con_Printf("IN_DeactivateMouse\n");
}

void DLLEXPORT IN_Accumulate ( void )
{
	//gEngfuncs.Con_Printf("IN_Accumulate\n");
}

void IN_Commands ( void )
{
	//gEngfuncs.Con_Printf("IN_Commands\n");
}

void IN_Shutdown ( void )
{
}
// Register cvars and reset data
void IN_Init( void )
{
	sensitivity = gEngfuncs.pfnRegisterVariable ( "sensitivity", "3", FCVAR_ARCHIVE );
	in_joystick = gEngfuncs.pfnRegisterVariable ( "joystick", "0", FCVAR_ARCHIVE );
	cl_laddermode = gEngfuncs.pfnRegisterVariable ( "cl_laddermode", "2", FCVAR_ARCHIVE );
	evdev_grab = gEngfuncs.pfnGetCvarPointer("evdev_grab");

	ac_forwardmove = ac_sidemove = rel_yaw = rel_pitch = 0;
}

```

`cl_dll/inputw32.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// in_win.c -- windows 95 mouse and joystick code
// 02/21/97 JCB Added extended DirectInput code to support external controllers.

#include "hud.h"
#include "cl_util.h"
#include "camera.h"
#include "kbutton.h"
#include "cvardef.h"
#include "usercmd.h"
#include "const.h"
#include "camera.h"
#include "in_defs.h"
#include "../engine/keydefs.h"
#include "view.h"
#include "port.h"

#define MOUSE_BUTTON_COUNT 5

// Set this to 1 to show mouse cursor.  Experimental
int	g_iVisibleMouse = 0;

extern "C" 
{
	void DLLEXPORT IN_ActivateMouse( void );
	void DLLEXPORT IN_DeactivateMouse( void );
	void DLLEXPORT IN_MouseEvent (int mstate);
	void DLLEXPORT IN_Accumulate (void);
	void DLLEXPORT IN_ClearStates (void);
}

extern cl_enginefunc_t gEngfuncs;

extern int iMouseInUse;

extern kbutton_t	in_strafe;
extern kbutton_t	in_mlook;
extern kbutton_t	in_speed;
extern kbutton_t	in_jlook;

extern cvar_t	*m_pitch;
extern cvar_t	*m_yaw;
extern cvar_t	*m_forward;
extern cvar_t	*m_side;

extern cvar_t *lookstrafe;
extern cvar_t *lookspring;
extern cvar_t *cl_pitchdown;
extern cvar_t *cl_pitchup;
extern cvar_t *cl_yawspeed;
extern cvar_t *cl_sidespeed;
extern cvar_t *cl_forwardspeed;
extern cvar_t *cl_pitchspeed;
extern cvar_t *cl_movespeedkey;

// mouse variables
cvar_t		*m_filter;
cvar_t		*sensitivity;

int			mouse_buttons;
int			mouse_oldbuttonstate;
POINT		current_pos;
int			mouse_x, mouse_y, old_mouse_x, old_mouse_y, mx_accum, my_accum;

static int	restore_spi;
static int	originalmouseparms[3], newmouseparms[3] = {0, 0, 1};
static int	mouseactive;
int			mouseinitialized;
static int	mouseparmsvalid;
static int	mouseshowtoggle = 1;

// joystick defines and variables
// where should defines be moved?
#define JOY_ABSOLUTE_AXIS	0x00000000		// control like a joystick
#define JOY_RELATIVE_AXIS	0x00000010		// control like a mouse, spinner, trackball
#define	JOY_MAX_AXES		6				// X, Y, Z, R, U, V
#define JOY_AXIS_X			0
#define JOY_AXIS_Y			1
#define JOY_AXIS_Z			2
#define JOY_AXIS_R			3
#define JOY_AXIS_U			4
#define JOY_AXIS_V			5

enum _ControlList
{
	AxisNada = 0,
	AxisForward,
	AxisLook,
	AxisSide,
	AxisTurn
};

DWORD dwAxisFlags[JOY_MAX_AXES] =
{
	JOY_RETURNX,
	JOY_RETURNY,
	JOY_RETURNZ,
	JOY_RETURNR,
	JOY_RETURNU,
	JOY_RETURNV
};

DWORD	dwAxisMap[ JOY_MAX_AXES ];
DWORD	dwControlMap[ JOY_MAX_AXES ];
PDWORD	pdwRawValue[ JOY_MAX_AXES ];

// none of these cvars are saved over a session
// this means that advanced controller configuration needs to be executed
// each time.  this avoids any problems with getting back to a default usage
// or when changing from one controller to another.  this way at least something
// works.
cvar_t	*in_joystick;
cvar_t	*joy_name;
cvar_t	*joy_advanced;
cvar_t	*joy_advaxisx;
cvar_t	*joy_advaxisy;
cvar_t	*joy_advaxisz;
cvar_t	*joy_advaxisr;
cvar_t	*joy_advaxisu;
cvar_t	*joy_advaxisv;
cvar_t	*joy_forwardthreshold;
cvar_t	*joy_sidethreshold;
cvar_t	*joy_pitchthreshold;
cvar_t	*joy_yawthreshold;
cvar_t	*joy_forwardsensitivity;
cvar_t	*joy_sidesensitivity;
cvar_t	*joy_pitchsensitivity;
cvar_t	*joy_yawsensitivity;
cvar_t	*joy_wwhack1;
cvar_t	*joy_wwhack2;

int			joy_avail, joy_advancedinit, joy_haspov;
DWORD		joy_oldbuttonstate, joy_oldpovstate;

int			joy_id;
DWORD		joy_flags;
DWORD		joy_numbuttons;

static JOYINFOEX	ji;

/*
===========
Force_CenterView_f
===========
*/
void Force_CenterView_f (void)
{
	vec3_t viewangles;

	if (!iMouseInUse)
	{
		gEngfuncs.GetViewAngles( (float *)viewangles );
	    viewangles[PITCH] = 0;
		gEngfuncs.SetViewAngles( (float *)viewangles );
	}
}

/*
===========
IN_ActivateMouse
===========
*/
void DLLEXPORT IN_ActivateMouse (void)
{
	if (mouseinitialized)
	{
		if (mouseparmsvalid)
			restore_spi = SystemParametersInfo (SPI_SETMOUSE, 0, newmouseparms, 0);
		mouseactive = 1;
	}
}

/*
===========
IN_DeactivateMouse
===========
*/
void DLLEXPORT IN_DeactivateMouse (void)
{
	if (mouseinitialized)
	{
		if (restore_spi)
			SystemParametersInfo (SPI_SETMOUSE, 0, originalmouseparms, 0);

		mouseactive = 0;
	}
}

/*
===========
IN_StartupMouse
===========
*/
void IN_StartupMouse (void)
{
	if ( gEngfuncs.CheckParm ("-nomouse", NULL ) ) 
		return; 

	mouseinitialized = 1;
	mouseparmsvalid = SystemParametersInfo (SPI_GETMOUSE, 0, originalmouseparms, 0);

	if (mouseparmsvalid)
	{
		if ( gEngfuncs.CheckParm ("-noforcemspd", NULL ) ) 
			newmouseparms[2] = originalmouseparms[2];

		if ( gEngfuncs.CheckParm ("-noforcemaccel", NULL ) ) 
		{
			newmouseparms[0] = originalmouseparms[0];
			newmouseparms[1] = originalmouseparms[1];
		}

		if ( gEngfuncs.CheckParm ("-noforcemparms", NULL ) ) 
		{
			newmouseparms[0] = originalmouseparms[0];
			newmouseparms[1] = originalmouseparms[1];
			newmouseparms[2] = originalmouseparms[2];
		}
	}

	mouse_buttons = MOUSE_BUTTON_COUNT;
}

/*
===========
IN_Shutdown
===========
*/
void IN_Shutdown (void)
{
	IN_DeactivateMouse ();
}

/*
===========
IN_GetMousePos

Ask for mouse position from engine
===========
*/
void IN_GetMousePos( int *mx, int *my )
{
	gEngfuncs.GetMousePosition( mx, my );
}

/*
===========
IN_ResetMouse

FIXME: Call through to engine?
===========
*/
void IN_ResetMouse( void )
{
	SetCursorPos ( gEngfuncs.GetWindowCenterX(), gEngfuncs.GetWindowCenterY() );	
}

/*
===========
IN_MouseEvent
===========
*/
void DLLEXPORT IN_MouseEvent (int mstate)
{
	int		i;

	if ( iMouseInUse || g_iVisibleMouse )
		return;

	// perform button actions
	for (i=0 ; i<mouse_buttons ; i++)
	{
		if ( (mstate & (1<<i)) &&
			!(mouse_oldbuttonstate & (1<<i)) )
		{
			gEngfuncs.Key_Event (K_MOUSE1 + i, 1);
		}

		if ( !(mstate & (1<<i)) &&
			(mouse_oldbuttonstate & (1<<i)) )
		{
			gEngfuncs.Key_Event (K_MOUSE1 + i, 0);
		}
	}	
	
	mouse_oldbuttonstate = mstate;
}

/*
===========
IN_MouseMove
===========
*/
void IN_MouseMove ( float frametime, usercmd_t *cmd)
{
	int		mx, my;
	vec3_t viewangles;

	gEngfuncs.GetViewAngles( (float *)viewangles );

#if 0
	if ( in_mlook.state & 1)
	{
		V_StopPitchDrift ();
	}
#endif

	//jjb - this disbles normal mouse control if the user is trying to 
	//      move the camera, or if the mouse cursor is visible or if we're in intermission
	if ( !iMouseInUse && !g_iVisibleMouse && !gHUD.m_iIntermission )
	{
		GetCursorPos (&current_pos);

		mx = current_pos.x - gEngfuncs.GetWindowCenterX() + mx_accum;
		my = current_pos.y - gEngfuncs.GetWindowCenterY() + my_accum;

		mx_accum = 0;
		my_accum = 0;

		if (m_filter->value)
		{
			mouse_x = (mx + old_mouse_x) * 0.5;
			mouse_y = (my + old_mouse_y) * 0.5;
		}
		else
		{
			mouse_x = mx;
			mouse_y = my;
		}

		old_mouse_x = mx;
		old_mouse_y = my;

		if ( gHUD.GetSensitivity() != 0 )
		{
			mouse_x *= gHUD.GetSensitivity();
			mouse_y *= gHUD.GetSensitivity();
		}
		else
		{
			mouse_x *= sensitivity->value;
			mouse_y *= sensitivity->value;
		}

		// add mouse X/Y movement to cmd
		if ( (in_strafe.state & 1) || (lookstrafe->value && (in_mlook.state & 1) ))
			cmd->sidemove += m_side->value * mouse_x;
		else
			viewangles[YAW] -= m_yaw->value * mouse_x;

		if ( (in_mlook.state & 1) && !(in_strafe.state & 1))
		{
			viewangles[PITCH] += m_pitch->value * mouse_y;
			if (viewangles[PITCH] > cl_pitchdown->value)
				viewangles[PITCH] = cl_pitchdown->value;
			if (viewangles[PITCH] < -cl_pitchup->value)
				viewangles[PITCH] = -cl_pitchup->value;
		}
		else
		{
			if ((in_strafe.state & 1) && gEngfuncs.IsNoClipping() )
			{
				cmd->upmove -= m_forward->value * mouse_y;
			}
			else
			{
				cmd->forwardmove -= m_forward->value * mouse_y;
			}
		}

		// if the mouse has moved, force it to the center, so there's room to move
		if ( mx || my )
		{
			IN_ResetMouse();
		}
	}

	gEngfuncs.SetViewAngles( (float *)viewangles );

/*
//#define TRACE_TEST
#if defined( TRACE_TEST )
	{
		int mx, my;
		void V_Move( int mx, int my );
		IN_GetMousePos( &mx, &my );
		V_Move( mx, my );
	}
#endif
*/
}

/*
===========
IN_Accumulate
===========
*/
void DLLEXPORT IN_Accumulate (void)
{
	//only accumulate mouse if we are not moving the camera with the mouse
	if ( !iMouseInUse && !g_iVisibleMouse )
	{
	    if (mouseactive)
	    {
			GetCursorPos (&current_pos);

			mx_accum += current_pos.x - gEngfuncs.GetWindowCenterX();
			my_accum += current_pos.y - gEngfuncs.GetWindowCenterY();

			// force the mouse to the center, so there's room to move
			IN_ResetMouse();
		}
	}

}

/*
===================
IN_ClearStates
===================
*/
void DLLEXPORT IN_ClearStates (void)
{
	if ( !mouseactive )
		return;

	mx_accum = 0;
	my_accum = 0;
	mouse_oldbuttonstate = 0;
}

/* 
=============== 
IN_StartupJoystick 
=============== 
*/  
void IN_StartupJoystick (void) 
{ 
	int			numdevs;
	JOYCAPS		jc;
	MMRESULT	mmr;
 
 	// assume no joystick
	joy_avail = 0; 

	// abort startup if user requests no joystick
	if ( gEngfuncs.CheckParm ("-nojoy", NULL ) ) 
		return; 
 
	// verify joystick driver is present
	if ((numdevs = joyGetNumDevs ()) == 0)
	{
		gEngfuncs.Con_DPrintf ("joystick not found -- driver not present\n\n");
		return;
	}

	// cycle through the joystick ids for the first valid one
	for (joy_id=0 ; joy_id<numdevs ; joy_id++)
	{
		memset (&ji, 0, sizeof(ji));
		ji.dwSize = sizeof(ji);
		ji.dwFlags = JOY_RETURNCENTERED;

		if ((mmr = joyGetPosEx (joy_id, &ji)) == JOYERR_NOERROR)
			break;
	} 

	// abort startup if we didn't find a valid joystick
	if (mmr != JOYERR_NOERROR)
	{
		gEngfuncs.Con_DPrintf ("joystick not found -- no valid joysticks (%x)\n\n", mmr);
		return;
	}

	// get the capabilities of the selected joystick
	// abort startup if command fails
	memset (&jc, 0, sizeof(jc));
	if ((mmr = joyGetDevCaps (joy_id, &jc, sizeof(jc))) != JOYERR_NOERROR)
	{
		gEngfuncs.Con_DPrintf ("joystick not found -- invalid joystick capabilities (%x)\n\n", mmr); 
		return;
	}

	// save the joystick's number of buttons and POV status
	joy_numbuttons = jc.wNumButtons;
	joy_haspov = jc.wCaps & JOYCAPS_HASPOV;

	// old button and POV states default to no buttons pressed
	joy_oldbuttonstate = joy_oldpovstate = 0;

	// mark the joystick as available and advanced initialization not completed
	// this is needed as cvars are not available during initialization
	gEngfuncs.Con_Printf ("joystick found\n\n", mmr); 
	joy_avail = 1; 
	joy_advancedinit = 0;
}


/*
===========
RawValuePointer
===========
*/
PDWORD RawValuePointer (int axis)
{
	switch (axis)
	{
	case JOY_AXIS_X:
		return &ji.dwXpos;
	case JOY_AXIS_Y:
		return &ji.dwYpos;
	case JOY_AXIS_Z:
		return &ji.dwZpos;
	case JOY_AXIS_R:
		return &ji.dwRpos;
	case JOY_AXIS_U:
		return &ji.dwUpos;
	case JOY_AXIS_V:
		return &ji.dwVpos;
	}
	// FIX: need to do some kind of error
	return &ji.dwXpos;
}


/*
===========
Joy_AdvancedUpdate_f
===========
*/
void Joy_AdvancedUpdate_f (void)
{

	// called once by IN_ReadJoystick and by user whenever an update is needed
	// cvars are now available
	int	i;
	DWORD dwTemp;

	// initialize all the maps
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		dwAxisMap[i] = AxisNada;
		dwControlMap[i] = JOY_ABSOLUTE_AXIS;
		pdwRawValue[i] = RawValuePointer(i);
	}

	if( joy_advanced->value == 0.0)
	{
		// default joystick initialization
		// 2 axes only with joystick control
		dwAxisMap[JOY_AXIS_X] = AxisTurn;
		// dwControlMap[JOY_AXIS_X] = JOY_ABSOLUTE_AXIS;
		dwAxisMap[JOY_AXIS_Y] = AxisForward;
		// dwControlMap[JOY_AXIS_Y] = JOY_ABSOLUTE_AXIS;
	}
	else
	{
		if ( strcmp ( joy_name->string, "joystick") != 0 )
		{
			// notify user of advanced controller
			gEngfuncs.Con_Printf ("\n%s configured\n\n", joy_name->string);
		}

		// advanced initialization here
		// data supplied by user via joy_axisn cvars
		dwTemp = (DWORD) joy_advaxisx->value;
		dwAxisMap[JOY_AXIS_X] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_X] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisy->value;
		dwAxisMap[JOY_AXIS_Y] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_Y] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisz->value;
		dwAxisMap[JOY_AXIS_Z] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_Z] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisr->value;
		dwAxisMap[JOY_AXIS_R] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_R] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisu->value;
		dwAxisMap[JOY_AXIS_U] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_U] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisv->value;
		dwAxisMap[JOY_AXIS_V] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_V] = dwTemp & JOY_RELATIVE_AXIS;
	}

	// compute the axes to collect from DirectInput
	joy_flags = JOY_RETURNCENTERED | JOY_RETURNBUTTONS | JOY_RETURNPOV;
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		if (dwAxisMap[i] != AxisNada)
		{
			joy_flags |= dwAxisFlags[i];
		}
	}
}


/*
===========
IN_Commands
===========
*/
void IN_Commands (void)
{
	int		i, key_index;
	DWORD	buttonstate, povstate;

	if (!joy_avail)
	{
		return;
	}

	
	// loop through the joystick buttons
	// key a joystick event or auxiliary event for higher number buttons for each state change
	buttonstate = ji.dwButtons;
	for (i=0 ; i < (int)joy_numbuttons ; i++)
	{
		if ( (buttonstate & (1<<i)) && !(joy_oldbuttonstate & (1<<i)) )
		{
			key_index = (i < 4) ? K_JOY1 : K_AUX1;
			gEngfuncs.Key_Event (key_index + i, 1);
		}

		if ( !(buttonstate & (1<<i)) && (joy_oldbuttonstate & (1<<i)) )
		{
			key_index = (i < 4) ? K_JOY1 : K_AUX1;
			gEngfuncs.Key_Event (key_index + i, 0);
		}
	}
	joy_oldbuttonstate = buttonstate;

	if (joy_haspov)
	{
		// convert POV information into 4 bits of state information
		// this avoids any potential problems related to moving from one
		// direction to another without going through the center position
		povstate = 0;
		if(ji.dwPOV != JOY_POVCENTERED)
		{
			if (ji.dwPOV == JOY_POVFORWARD)
				povstate |= 0x01;
			if (ji.dwPOV == JOY_POVRIGHT)
				povstate |= 0x02;
			if (ji.dwPOV == JOY_POVBACKWARD)
				povstate |= 0x04;
			if (ji.dwPOV == JOY_POVLEFT)
				povstate |= 0x08;
		}
		// determine which bits have changed and key an auxiliary event for each change
		for (i=0 ; i < 4 ; i++)
		{
			if ( (povstate & (1<<i)) && !(joy_oldpovstate & (1<<i)) )
			{
				gEngfuncs.Key_Event (K_AUX29 + i, 1);
			}

			if ( !(povstate & (1<<i)) && (joy_oldpovstate & (1<<i)) )
			{
				gEngfuncs.Key_Event (K_AUX29 + i, 0);
			}
		}
		joy_oldpovstate = povstate;
	}
}


/* 
=============== 
IN_ReadJoystick
=============== 
*/  
int IN_ReadJoystick (void)
{

	memset (&ji, 0, sizeof(ji));
	ji.dwSize = sizeof(ji);
	ji.dwFlags = joy_flags;

	if (joyGetPosEx (joy_id, &ji) == JOYERR_NOERROR)
	{
		// this is a hack -- there is a bug in the Logitech WingMan Warrior DirectInput Driver
		// rather than having 32768 be the zero point, they have the zero point at 32668
		// go figure -- anyway, now we get the full resolution out of the device
		if (joy_wwhack1->value != 0.0)
		{
			ji.dwUpos += 100;
		}
		return 1;
	}
	else
	{
		// read error occurred
		// turning off the joystick seems too harsh for 1 read error,\
		// but what should be done?
		// Con_Printf ("IN_ReadJoystick: no response\n");
		// joy_avail = 0;
		return 0;
	}
}


/*
===========
IN_JoyMove
===========
*/
void IN_JoyMove ( float frametime, usercmd_t *cmd )
{
	float	speed, aspeed;
	float	fAxisValue, fTemp;
	int		i;
	vec3_t viewangles;

	gEngfuncs.GetViewAngles( (float *)viewangles );


	// complete initialization if first time in
	// this is needed as cvars are not available at initialization time
	if( joy_advancedinit != 1 )
	{
		Joy_AdvancedUpdate_f();
		joy_advancedinit = 1;
	}

	// verify joystick is available and that the user wants to use it
	if (!joy_avail || !in_joystick->value)
	{
		return; 
	}
 
	// collect the joystick data, if possible
	if (IN_ReadJoystick () != 1)
	{
		return;
	}

	if (in_speed.state & 1)
		speed = cl_movespeedkey->value;
	else
		speed = 1;

	aspeed = speed * frametime;

	// loop through the axes
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		// get the floating point zero-centered, potentially-inverted data for the current axis
		fAxisValue = (float) *pdwRawValue[i];
		// move centerpoint to zero
		fAxisValue -= 32768.0;

		if (joy_wwhack2->value != 0.0)
		{
			if (dwAxisMap[i] == AxisTurn)
			{
				// this is a special formula for the Logitech WingMan Warrior
				// y=ax^b; where a = 300 and b = 1.3
				// also x values are in increments of 800 (so this is factored out)
				// then bounds check result to level out excessively high spin rates
				fTemp = 300.0 * powf(fabs(fAxisValue) / 800.0, 1.3);
				if (fTemp > 14000.0)
					fTemp = 14000.0;
				// restore direction information
				fAxisValue = (fAxisValue > 0.0) ? fTemp : -fTemp;
			}
		}

		// convert range from -32768..32767 to -1..1 
		fAxisValue /= 32768.0;

		switch (dwAxisMap[i])
		{
		case AxisForward:
			if ((joy_advanced->value == 0.0) && (in_jlook.state & 1))
			{
				// user wants forward control to become look control
				if (fabs(fAxisValue) > joy_pitchthreshold->value)
				{		
					// if mouse invert is on, invert the joystick pitch value
					// only absolute control support here (joy_advanced is 0)
					if (m_pitch->value < 0.0)
					{
						viewangles[PITCH] -= (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
					else
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
#if 0
					V_StopPitchDrift();
#endif
				}
#if 0
				else
				{
					// no pitch movement
					// disable pitch return-to-center unless requested by user
					// *** this code can be removed when the lookspring bug is fixed
					// *** the bug always has the lookspring feature on
					if(lookspring->value == 0.0)
					{
						V_StopPitchDrift();
					}
				}
#endif
			}
			else
			{
				// user wants forward control to be forward control
				if (fabs(fAxisValue) > joy_forwardthreshold->value)
				{
					cmd->forwardmove += (fAxisValue * joy_forwardsensitivity->value) * speed * cl_forwardspeed->value;
				}
			}
			break;

		case AxisSide:
			if (fabs(fAxisValue) > joy_sidethreshold->value)
			{
				cmd->sidemove += (fAxisValue * joy_sidesensitivity->value) * speed * cl_sidespeed->value;
			}
			break;

		case AxisTurn:
			if ((in_strafe.state & 1) || (lookstrafe->value && (in_jlook.state & 1)))
			{
				// user wants turn control to become side control
				if (fabs(fAxisValue) > joy_sidethreshold->value)
				{
					cmd->sidemove -= (fAxisValue * joy_sidesensitivity->value) * speed * cl_sidespeed->value;
				}
			}
			else
			{
				// user wants turn control to be turn control
				if (fabs(fAxisValue) > joy_yawthreshold->value)
				{
					if(dwControlMap[i] == JOY_ABSOLUTE_AXIS)
					{
						viewangles[YAW] += (fAxisValue * joy_yawsensitivity->value) * aspeed * cl_yawspeed->value;
					}
					else
					{
						viewangles[YAW] += (fAxisValue * joy_yawsensitivity->value) * speed * 180.0;
					}

				}
			}
			break;

		case AxisLook:
			if (in_jlook.state & 1)
			{
				if (fabs(fAxisValue) > joy_pitchthreshold->value)
				{
					// pitch movement detected and pitch movement desired by user
					if(dwControlMap[i] == JOY_ABSOLUTE_AXIS)
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
					else
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * speed * 180.0;
					}
#if 0
					V_StopPitchDrift();
#endif
				}
#if 0
				else
				{
					// no pitch movement
					// disable pitch return-to-center unless requested by user
					// *** this code can be removed when the lookspring bug is fixed
					// *** the bug always has the lookspring feature on
					if( lookspring->value == 0.0 )
					{
						V_StopPitchDrift();
					}
				}
#endif
			}
			break;

		default:
			break;
		}
	}

	// bounds check pitch
	if (viewangles[PITCH] > cl_pitchdown->value)
		viewangles[PITCH] = cl_pitchdown->value;
	if (viewangles[PITCH] < -cl_pitchup->value)
		viewangles[PITCH] = -cl_pitchup->value;

	gEngfuncs.SetViewAngles( (float *)viewangles );

}

/*
===========
IN_Move
===========
*/
void IN_Move ( float frametime, usercmd_t *cmd)
{
	if ( !iMouseInUse && mouseactive )
	{
		IN_MouseMove ( frametime, cmd);
	}

	IN_JoyMove ( frametime, cmd);
}

/*
===========
IN_Init
===========
*/
void IN_Init (void)
{
	m_filter				= gEngfuncs.pfnRegisterVariable ( "m_filter","0", FCVAR_ARCHIVE );
	sensitivity				= gEngfuncs.pfnRegisterVariable ( "sensitivity","3", FCVAR_ARCHIVE ); // user mouse sensitivity setting.

	in_joystick				= gEngfuncs.pfnRegisterVariable ( "joystick","0", FCVAR_ARCHIVE );
	joy_name				= gEngfuncs.pfnRegisterVariable ( "joyname", "joystick", 0 );
	joy_advanced			= gEngfuncs.pfnRegisterVariable ( "joyadvanced", "0", 0 );
	joy_advaxisx			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisx", "0", 0 );
	joy_advaxisy			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisy", "0", 0 );
	joy_advaxisz			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisz", "0", 0 );
	joy_advaxisr			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisr", "0", 0 );
	joy_advaxisu			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisu", "0", 0 );
	joy_advaxisv			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisv", "0", 0 );
	joy_forwardthreshold	= gEngfuncs.pfnRegisterVariable ( "joyforwardthreshold", "0.15", 0 );
	joy_sidethreshold		= gEngfuncs.pfnRegisterVariable ( "joysidethreshold", "0.15", 0 );
	joy_pitchthreshold		= gEngfuncs.pfnRegisterVariable ( "joypitchthreshold", "0.15", 0 );
	joy_yawthreshold		= gEngfuncs.pfnRegisterVariable ( "joyyawthreshold", "0.15", 0 );
	joy_forwardsensitivity	= gEngfuncs.pfnRegisterVariable ( "joyforwardsensitivity", "-1.0", 0 );
	joy_sidesensitivity		= gEngfuncs.pfnRegisterVariable ( "joysidesensitivity", "-1.0", 0 );
	joy_pitchsensitivity	= gEngfuncs.pfnRegisterVariable ( "joypitchsensitivity", "1.0", 0 );
	joy_yawsensitivity		= gEngfuncs.pfnRegisterVariable ( "joyyawsensitivity", "-1.0", 0 );
	joy_wwhack1				= gEngfuncs.pfnRegisterVariable ( "joywwhack1", "0.0", 0 );
	joy_wwhack2				= gEngfuncs.pfnRegisterVariable ( "joywwhack2", "0.0", 0 );

	gEngfuncs.pfnAddCommand ("force_centerview", Force_CenterView_f);
	gEngfuncs.pfnAddCommand ("joyadvancedupdate", Joy_AdvancedUpdate_f);

	IN_StartupMouse ();
	IN_StartupJoystick ();
}
```

`cl_dll/menu.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// menu.cpp
//
// generic menu handler
//
#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>
#include "draw_util.h"

//#include "vgui_TeamFortressViewport.h"

#define MAX_MENU_STRING	512

char g_szMenuString[MAX_MENU_STRING];
char g_szPrelocalisedMenuString[MAX_MENU_STRING];

int KB_ConvertString( char *in, char **ppout );

void Touch_CloseMenu()
{
	gMobileAPI.pfnTouchRemoveButton( "_menu_*" );
	gMobileAPI.pfnTouchSetClientOnly( 0 );
}

int CHudMenu :: Init( void )
{
	gHUD.AddHudElem( this );

	HOOK_MESSAGE( gHUD.m_Menu, ShowMenu );
	HOOK_MESSAGE( gHUD.m_Menu, VGUIMenu );
	HOOK_MESSAGE( gHUD.m_Menu, BuyClose );
	HOOK_MESSAGE( gHUD.m_Menu, AllowSpec );
	HOOK_COMMAND( gHUD.m_Menu, "client_buy_open", OldStyleMenuOpen );
	HOOK_COMMAND( gHUD.m_Menu, "client_buy_close", OldStyleMenuClose );
	HOOK_COMMAND( gHUD.m_Menu, "showvguimenu", ShowVGUIMenu );

	_extended_menus = CVAR_CREATE("_extended_menus", "1", FCVAR_ARCHIVE);

	InitHUDData();

	m_bAllowSpec = true; // by default, spectating is allowed

	return 1;
}

void CHudMenu :: InitHUDData( void )
{
	m_fMenuDisplayed = 0;
	m_bitsValidSlots = 0;
	Reset();
}

void CHudMenu :: Reset( void )
{
	g_szPrelocalisedMenuString[0] = 0;
	m_fWaitingForMore = FALSE;
}

int CHudMenu :: VidInit( void )
{
	return 1;
}

int CHudMenu :: Draw( float flTime )
{
	// check for if menu is set to disappear
	if ( m_flShutoffTime > 0 )
	{
		if ( m_flShutoffTime <= gHUD.m_flTime )
		{  // times up, shutoff
			UserCmd_OldStyleMenuClose();
			return 1;
		}
	}

	// don't draw the menu if the scoreboard is being shown
	//if ( gViewPort && gViewPort->IsScoreBoardVisible() )
		//return 1;

	// draw the menu, along the left-hand side of the screen

	// count the number of newlines
	int nlc = 0;
	int i;
	for ( i = 0; i < MAX_MENU_STRING && g_szMenuString[i] != '\0'; i++ )
	{
		if ( g_szMenuString[i] == '\n' )
			nlc++;
	}

	// center it
	int y = (ScreenHeight/2) - ((nlc/2)*12) - 40; // make sure it is above the say text
	int x = 20;

	i = 0;
	while ( i < MAX_MENU_STRING && g_szMenuString[i] != '\0' )
	{
		DrawUtils::DrawHudString( x, y, 320, g_szMenuString + i, 255, 255, 255 );
		y += 24;

		while ( i < MAX_MENU_STRING && g_szMenuString[i] != '\0' && g_szMenuString[i] != '\n' )
			i++;
		if ( g_szMenuString[i] == '\n' )
			i++;
	}
	
	return 1;
}

// selects an item from the menu
void CHudMenu :: SelectMenuItem( int menu_item )
{
	// if menu_item is in a valid slot,  send a menuselect command to the server
	if ( (menu_item > 0) && (m_bitsValidSlots & (1 << (menu_item-1))) )
	{
		char szbuf[32];
		sprintf( szbuf, "menuselect %d\n", menu_item );
		ClientCmd( szbuf );

		UserCmd_OldStyleMenuClose();
	}
}


// Message handler for ShowMenu message
// takes four values:
//		short: a bitfield of keys that are valid input
//		char : the duration, in seconds, the menu should stay up. -1 means is stays until something is chosen.
//		byte : a boolean, TRUE if there is more string yet to be received before displaying the menu, FALSE if it's the last string
//		string: menu string to display
// if this message is never received, then scores will simply be the combined totals of the players.
int CHudMenu :: MsgFunc_ShowMenu( const char *pszName, int iSize, void *pbuf )
{
	char *temp = NULL, *menustring;

	BufferReader reader( pszName, pbuf, iSize );

	m_bitsValidSlots = reader.ReadShort();
	int DisplayTime = reader.ReadChar();
	int NeedMore = reader.ReadByte();

	if ( DisplayTime > 0 )
		m_flShutoffTime = DisplayTime + gHUD.m_flTime;
	else
		m_flShutoffTime = -1;

	if ( !m_bitsValidSlots )
	{
		UserCmd_OldStyleMenuClose(); // no valid slots means that the menu should be turned off
		return 1;
	}

	menustring = reader.ReadString();

	// menu will be replaced by scripted touch config
	// so execute it and exit
	if( _extended_menus->value != 0.0f )
	{
		if( !strncmp(menustring, "#Radio", 6 ) )
		{
			if( menustring[6] == 'A' )
			{
				ShowVGUIMenu(MENU_RADIOA); return 1;
			}
			else if( menustring[6] == 'B' )
			{
				ShowVGUIMenu(MENU_RADIOB); return 1;
			}
			else if( menustring[6] == 'C' )
			{
				ShowVGUIMenu(MENU_RADIOC); return 1;
			}
			else ShowVGUIMenu( MENU_NUMERICAL_MENU ); // we just show touch screen numbers
		}
		else ShowVGUIMenu(MENU_NUMERICAL_MENU);
	}
	else ShowVGUIMenu(MENU_NUMERICAL_MENU);

	if ( !m_fWaitingForMore ) // this is the start of a new menu
	{
		strncpy( g_szPrelocalisedMenuString, menustring, MAX_MENU_STRING - 1 );
	}
	else
	{  // append to the current menu string
		strncat( g_szPrelocalisedMenuString, menustring, MAX_MENU_STRING - strlen(g_szPrelocalisedMenuString) - 1 );
	}
	g_szPrelocalisedMenuString[MAX_MENU_STRING-1] = 0;  // ensure null termination (strncat/strncpy does not)

	if ( !NeedMore )
	{  // we have the whole string, so we can localise it now
		strncpy( g_szMenuString, gHUD.m_TextMessage.BufferedLocaliseTextString( g_szPrelocalisedMenuString ), MAX_MENU_STRING );
		g_szMenuString[MAX_MENU_STRING-1] = 0;
		// Swap in characters
		if ( KB_ConvertString( g_szMenuString, &temp ) )
		{
			strncpy( g_szMenuString, temp, MAX_MENU_STRING );
			g_szMenuString[MAX_MENU_STRING-1] = 0;
			free( temp );
		}
	}

	m_fMenuDisplayed = 1;
	m_iFlags |= HUD_DRAW;

	m_fWaitingForMore = NeedMore;

	return 1;
}

int CHudMenu::MsgFunc_VGUIMenu( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int menuType = reader.ReadByte();
	m_bitsValidSlots = reader.ReadShort(); // is ignored

	ShowVGUIMenu(menuType);
	return 1;
}

int CHudMenu::MsgFunc_BuyClose(const char *pszName, int iSize, void *pbuf)
{
	Touch_CloseMenu();

	return 1;
}

int CHudMenu::MsgFunc_AllowSpec(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	m_bAllowSpec = (bool)reader.ReadByte();

	return 1;
}

void CHudMenu::UserCmd_OldStyleMenuOpen()
{
	m_flShutoffTime = -1; // stay open until user will not close it
	strncpy( g_szMenuString, gHUD.m_TextMessage.BufferedLocaliseTextString("Buy"), MAX_MENU_STRING );
	g_szMenuString[MAX_MENU_STRING-1] = 0;
}

void CHudMenu::UserCmd_OldStyleMenuClose()
{
	m_fMenuDisplayed = 0; // no valid slots means that the menu should be turned off
	m_iFlags &= ~HUD_DRAW;

	Touch_CloseMenu();
}

// lol, no real VGUI here
// it's really good only for touchscreen

void CHudMenu::ShowVGUIMenu( int menuType )
{
	const char *szCmd;

	switch(menuType)
	{
	case MENU_TEAM:
		szCmd = "exec touch/chooseteam.cfg";
		break;
	case MENU_CLASS_T:
		szCmd = "exec touch/chooseteam_tr.cfg";
		break;
	case MENU_CLASS_CT:
		szCmd = "exec touch/chooseteam_ct.cfg";
		break;
	case MENU_BUY:
		szCmd = "exec touch/buy.cfg";
		break;
	case MENU_BUY_PISTOL:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_pistol_t.cfg";
		else szCmd = "exec touch/buy_pistol_ct.cfg";
		break;
	case MENU_BUY_SHOTGUN:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_shotgun_t.cfg";
		else szCmd = "exec touch/buy_shotgun_ct.cfg";
		break;
	case MENU_BUY_RIFLE:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_rifle_t.cfg";
		else szCmd ="exec touch/buy_rifle_ct.cfg";
		break;
	case MENU_BUY_SUBMACHINEGUN:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_submachinegun_t.cfg";
		else szCmd = "exec touch/buy_submachinegun_ct.cfg";
		break;
	case MENU_BUY_MACHINEGUN:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_machinegun_t.cfg";
		else szCmd = "exec touch/buy_machinegun_ct.cfg";
		break;
	case MENU_BUY_ITEM:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_item_t.cfg";
		else szCmd = "exec touch/buy_item_ct.cfg";
		break;
	case MENU_RADIOA:
		szCmd = "exec touch/radioa.cfg";
		break;
	case MENU_RADIOB:
		szCmd = "exec touch/radiob.cfg";
		break;
	case MENU_RADIOC:
		szCmd = "exec touch/radioc.cfg";
		break;
	case MENU_RADIOSELECTOR:
		szCmd = "exec touch/radioselector.cfg";
		break;
	case MENU_BUY_CSDM:
		szCmd = "exec touch/custom/dm_menu.cfg";
		break;
	case MENU_NUMERICAL_MENU:
#ifdef __ANDROID__
		szCmd = "exec touch/numerical_menu.cfg";
		break;
#else
		return;
#endif
	default:
		UserCmd_OldStyleMenuClose();
		return;
	}

	m_fMenuDisplayed = 1;
	ClientCmd(szCmd);
}

void CHudMenu::UserCmd_ShowVGUIMenu()
{
	if( gEngfuncs.Cmd_Argc() < 2 )
	{
		ConsolePrint("usage: showvguimenu <menuType>\n");
		return;
	}

	int menuType = atoi(gEngfuncs.Cmd_Argv(1));
	ShowVGUIMenu(menuType);
}

```

`cl_dll/message.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Message.cpp
//
// implementation of CHudMessage class
//

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "vgui_parser.h"
#include "draw_util.h"


int CHudMessage::Init(void)
{
	HOOK_MESSAGE( gHUD.m_Message, HudText );
	HOOK_MESSAGE( gHUD.m_Message, GameTitle );
	HOOK_MESSAGE( gHUD.m_Message, HudTextPro );
	HOOK_MESSAGE( gHUD.m_Message, HudTextArgs );

	gHUD.AddHudElem(this);
	Reset();

	return 1;
}

int CHudMessage::VidInit( void )
{
	m_HUD_title_half = gHUD.GetSpriteIndex( "title_half" );
	m_HUD_title_life = gHUD.GetSpriteIndex( "title_life" );

	return 1;
}


void CHudMessage::Reset( void )
{
 	memset( m_pMessages, 0, sizeof( m_pMessages[0] ) * maxHUDMessages );
	memset( m_startTime, 0, sizeof( m_startTime[0] ) * maxHUDMessages );
	
	m_gameTitleTime = 0;
	m_pGameTitle = NULL;
}


float CHudMessage::FadeBlend( float fadein, float fadeout, float hold, float localTime )
{
	float fadeTime = fadein + hold;
	float fadeBlend;

	if ( localTime < 0 )
		return 0;

	if ( localTime < fadein )
	{
		fadeBlend = 1 - ((fadein - localTime) / fadein);
	}
	else if ( localTime > fadeTime )
	{
		if ( fadeout > 0 )
			fadeBlend = 1 - ((localTime - fadeTime) / fadeout);
		else
			fadeBlend = 0;
	}
	else
		fadeBlend = 1;

	return fadeBlend;
}


int	CHudMessage::XPosition( float x, int width, int totalWidth )
{
	int xPos;

	if ( x == -1 )
	{
		xPos = (ScreenWidth - width) / 2;
	}
	else
	{
		if ( x < 0 )
			xPos = (1.0 + x) * ScreenWidth - totalWidth;	// Alight right
		else
			xPos = x * ScreenWidth;
	}

	if ( xPos + width > ScreenWidth )
		xPos = ScreenWidth - width;
	else if ( xPos < 0 )
		xPos = 0;

	return xPos;
}


int CHudMessage::YPosition( float y, int height )
{
	int yPos;

	if ( y == -1 )	// Centered?
		yPos = (ScreenHeight - height) * 0.5;
	else
	{
		// Alight bottom?
		if ( y < 0 )
			yPos = (1.0 + y) * ScreenHeight - height;	// Alight bottom
		else // align top
			yPos = y * ScreenHeight;
	}

	if ( yPos + height > ScreenHeight )
		yPos = ScreenHeight - height;
	else if ( yPos < 0 )
		yPos = 0;

	return yPos;
}


void CHudMessage::MessageScanNextChar( void )
{
	int srcRed = m_parms.pMessage->r1;
	int srcGreen = m_parms.pMessage->g1;
	int srcBlue = m_parms.pMessage->b1;
	int destRed, destGreen, destBlue, blend;
	destRed = destGreen = destBlue = blend = 0;

	switch( m_parms.pMessage->effect )
	{
	// Fade-in / Fade-out
	case 0:
	case 1:
		destRed = destGreen = destBlue = 0;
		blend = m_parms.fadeBlend;
		break;

	case 2:
		m_parms.charTime += m_parms.pMessage->fadein;
		if ( m_parms.charTime > m_parms.time )
		{
			srcRed = srcGreen = srcBlue = 0;
			blend = 0;	// pure source
		}
		else
		{
			float deltaTime = m_parms.time - m_parms.charTime;

			destRed = destGreen = destBlue = 0;
			if ( m_parms.time > m_parms.fadeTime )
			{
				blend = m_parms.fadeBlend;
			}
			else if ( deltaTime > m_parms.pMessage->fxtime )
				blend = 0;	// pure dest
			else
			{
				destRed = m_parms.pMessage->r2;
				destGreen = m_parms.pMessage->g2;
				destBlue = m_parms.pMessage->b2;
				blend = 255 - (deltaTime * (1.0/m_parms.pMessage->fxtime) * 255.0 + 0.5);
			}
		}
		break;
	}
	if ( blend > 255 )
		blend = 255;
	else if ( blend < 0 )
		blend = 0;

	m_parms.r = ((srcRed * (255-blend)) + (destRed * blend)) >> 8;
	m_parms.g = ((srcGreen * (255-blend)) + (destGreen * blend)) >> 8;
	m_parms.b = ((srcBlue * (255-blend)) + (destBlue * blend)) >> 8;

	if ( m_parms.pMessage->effect == 1 && m_parms.charTime != 0 )
	{
		if ( m_parms.x >= 0 && m_parms.y >= 0 && (m_parms.x + gHUD.GetCharWidth( m_parms.text )) <= ScreenWidth )
			DrawUtils::TextMessageDrawChar( m_parms.x, m_parms.y, m_parms.text, m_parms.pMessage->r2, m_parms.pMessage->g2, m_parms.pMessage->b2 );
	}
}


void CHudMessage::MessageScanStart( void )
{
	switch( m_parms.pMessage->effect )
	{
	// Fade-in / out with flicker
	case 1:
	case 0:
		m_parms.fadeTime = m_parms.pMessage->fadein + m_parms.pMessage->holdtime;
		

		if ( m_parms.time < m_parms.pMessage->fadein )
		{
			m_parms.fadeBlend = ((m_parms.pMessage->fadein - m_parms.time) * (1.0/m_parms.pMessage->fadein) * 255);
		}
		else if ( m_parms.time > m_parms.fadeTime )
		{
			if ( m_parms.pMessage->fadeout > 0 )
				m_parms.fadeBlend = (((m_parms.time - m_parms.fadeTime) / m_parms.pMessage->fadeout) * 255);
			else
				m_parms.fadeBlend = 255; // Pure dest (off)
		}
		else
			m_parms.fadeBlend = 0;	// Pure source (on)
		m_parms.charTime = 0;

		if ( m_parms.pMessage->effect == 1 && (rand()%100) < 10 )
			m_parms.charTime = 1;
		break;

	case 2:
		m_parms.fadeTime = (m_parms.pMessage->fadein * m_parms.length) + m_parms.pMessage->holdtime;
		
		if ( m_parms.time > m_parms.fadeTime && m_parms.pMessage->fadeout > 0 )
			m_parms.fadeBlend = (((m_parms.time - m_parms.fadeTime) / m_parms.pMessage->fadeout) * 255);
		else
			m_parms.fadeBlend = 0;
		break;
	}
}


void CHudMessage::MessageDrawScan( client_textmessage_t *pMessage, float time )
{
	int i, j, length, width;
	const char *pText;
	unsigned char line[80];

	pText = pMessage->pMessage;
	// Count lines
	m_parms.lines = 1;
	m_parms.time = time;
	m_parms.pMessage = pMessage;
	length = 0;
	width = 0;
	m_parms.totalWidth = 0;
	Con_UtfProcessChar( 0 );
	while ( *pText )
	{
		if ( *pText == '\n' )
		{
			m_parms.lines++;
			if ( width > m_parms.totalWidth )
				m_parms.totalWidth = width;
			width = 0;
		}
		else
		{
			int uch = Con_UtfProcessChar( (unsigned char)*pText );

			if ( !uch )
			{
				pText++;
				continue;
			}
			width += gHUD.GetCharWidth( uch );
		}
		pText++;
		length++;
	}
	m_parms.length = length;
	m_parms.totalHeight = (m_parms.lines * gHUD.GetCharHeight());


	m_parms.y = YPosition( pMessage->y, m_parms.totalHeight );
	pText = pMessage->pMessage;

	m_parms.charTime = 0;

	MessageScanStart();

	for ( i = 0; i < m_parms.lines; i++ )
	{
		m_parms.lineLength = 0;
		m_parms.width = 0;
		while ( *pText && *pText != '\n' && m_parms.lineLength < sizeof (line) - 1)
		{
			unsigned char c = *pText;
			line[m_parms.lineLength] = c;
			m_parms.lineLength++;
			int uch = Con_UtfProcessChar( c );

			if ( !uch )
			{
				pText++;
				continue;
			}
			m_parms.width += gHUD.GetCharWidth( uch );
			pText++;
		}
		pText++;		// Skip LF
		line[m_parms.lineLength] = 0;

		m_parms.x = XPosition( pMessage->x, m_parms.width, m_parms.totalWidth );

		for ( j = 0; j < m_parms.lineLength; j++ )
		{
			m_parms.text = line[j];
			int next = m_parms.x + gHUD.GetCharWidth( m_parms.text );
			MessageScanNextChar();
			
			if ( m_parms.x >= 0 && m_parms.y >= 0 && next <= ScreenWidth )
				m_parms.x += DrawUtils::TextMessageDrawChar( m_parms.x, m_parms.y, m_parms.text, m_parms.r, m_parms.g, m_parms.b );
		}

		m_parms.y += gHUD.GetCharHeight();
	}
}


int CHudMessage::Draw( float fTime )
{
	int i, drawn;
	client_textmessage_t *pMessage;
	float endTime;

	drawn = 0;

	if ( m_gameTitleTime > 0 )
	{
		float localTime = gHUD.m_flTime - m_gameTitleTime;
		float brightness;

		// Maybe timer isn't set yet
		if ( m_gameTitleTime > gHUD.m_flTime )
			m_gameTitleTime = gHUD.m_flTime;

		if ( localTime > (m_pGameTitle->fadein + m_pGameTitle->holdtime + m_pGameTitle->fadeout) )
			m_gameTitleTime = 0;
		else
		{
			brightness = FadeBlend( m_pGameTitle->fadein, m_pGameTitle->fadeout, m_pGameTitle->holdtime, localTime );

			int halfWidth = gHUD.GetSpriteRect(m_HUD_title_half).Width();
			int fullWidth = halfWidth + gHUD.GetSpriteRect(m_HUD_title_life).Width();
			int fullHeight = gHUD.GetSpriteRect(m_HUD_title_half).Height();

			int x = XPosition( m_pGameTitle->x, fullWidth, fullWidth );
			int y = YPosition( m_pGameTitle->y, fullHeight );


			SPR_Set( gHUD.GetSprite(m_HUD_title_half), brightness * m_pGameTitle->r1, brightness * m_pGameTitle->g1, brightness * m_pGameTitle->b1 );
			SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect(m_HUD_title_half) );

			SPR_Set( gHUD.GetSprite(m_HUD_title_life), brightness * m_pGameTitle->r1, brightness * m_pGameTitle->g1, brightness * m_pGameTitle->b1 );
			SPR_DrawAdditive( 0, x + halfWidth, y, &gHUD.GetSpriteRect(m_HUD_title_life) );

			drawn = 1;
		}
	}
	// Fixup level transitions
	for ( i = 0; i < maxHUDMessages; i++ )
	{
		// Assume m_parms.time contains last time
		if ( m_pMessages[i] )
		{
			pMessage = m_pMessages[i];
			if ( m_startTime[i] > gHUD.m_flTime )
				m_startTime[i] = gHUD.m_flTime + m_parms.time - m_startTime[i] + 0.2;	// Server takes 0.2 seconds to spawn, adjust for this
		}
	}

	for ( i = 0; i < maxHUDMessages; i++ )
	{
		if ( m_pMessages[i] )
		{
			pMessage = m_pMessages[i];

			// This is when the message is over
			switch( pMessage->effect )
			{
			// TODO: HACK to prevent crashing
			default:
			case 0:
			case 1:
				endTime = m_startTime[i] + pMessage->fadein + pMessage->fadeout + pMessage->holdtime;
				break;
			
			// Fade in is per character in scanning messages
			case 2:
				endTime = m_startTime[i] + (pMessage->fadein * strlen( pMessage->pMessage )) + pMessage->fadeout + pMessage->holdtime;
				break;
			}

			if ( fTime <= endTime )
			{
				float messageTime = fTime - m_startTime[i];

				// Draw the message
				// effect 0 is fade in/fade out
				// effect 1 is flickery credits
				// effect 2 is write out (training room)
				MessageDrawScan( pMessage, messageTime );

				drawn++;
			}
			else
			{
				// The message is over
				if( !strcmp( m_pMessages[i]->pName, "Custom" ) )
				{
					delete[] m_pMessages[i]->pMessage;
				}
				m_pMessages[i] = NULL;
			}
		}
	}

	// Remember the time -- to fix up level transitions
	m_parms.time = gHUD.m_flTime;
	// Don't call until we get another message
	if ( !drawn )
		m_iFlags &= ~HUD_DRAW;

	return 1;
}


void CHudMessage::MessageAdd( const char *pName, float time )
{
	int i,j;
	client_textmessage_t *tempMessage;

	for ( i = 0; i < maxHUDMessages; i++ )
	{
		if ( !m_pMessages[i] )
		{
			// Trim off a leading # if it's there
			if ( pName[0] == '#' ) 
				tempMessage = TextMessageGet( pName+1 );
			else
				tempMessage = TextMessageGet( pName );

			client_textmessage_t *message;
			if( tempMessage )
			{
				if( tempMessage->pMessage[0] == '#' )
				{
					message = AllocMessage( CHudTextMessage::BufferedLocaliseTextString( tempMessage->pMessage ), tempMessage );
				}
				else if( !strcmp( tempMessage->pName, "Custom" ) ) // Hey, it's mine way of detecting allocated message
				{
					message = AllocMessage( tempMessage->pMessage, tempMessage );
				}
				else
				{
					message = tempMessage;
				}
			}
			else
			{
				if( pName[0] == '#' )
				{
					pName = Localize( pName + 1 );
				}

				// If we couldnt find it in the titles.txt, just create it
				message = AllocMessage( pName );

				message->effect = 2;
				message->r1 = message->g1 = message->b1 = message->a1 = 100;
				message->r2 = 240;
				message->g2 = 110;
				message->b2 = 0;
				message->a2 = 0;
				message->x = -1;		// Centered
				message->y = 0.7;
				message->fadein = 0.01;
				message->fadeout = 1.5;
				message->fxtime = 0.25;
				message->holdtime = 5;
			}

			// safety check - don't add empty messages
            if ( !message->pMessage || message->pMessage[0] == '\0' ) 
            {
                // clean up custom messages
                if ( !strcmp(message->pName, "Custom") ) 
                {
                    delete[] message->pMessage;
                }
                return; // bail out if message is empty
            }

			for ( j = 0; j < maxHUDMessages; j++ )
			{
				if ( m_pMessages[j] )
				{
					// is this message already in the list
					if ( !strcmp( message->pMessage, m_pMessages[j]->pMessage ) )
					{
						if( !strcmp( message->pName, "Custom" ) )
						{
							delete[] message->pMessage;
						}
						return;
					}

					// get rid of any other messages in same location (only one displays at a time)
					if ( fabs( message->y - m_pMessages[j]->y ) < 0.0001 && fabs( message->x - m_pMessages[j]->x ) < 0.0001 )
					{
						if( !strcmp( m_pMessages[j]->pName, "Custom" ) )
						{
							delete[] m_pMessages[j]->pMessage;
						}
						m_pMessages[j] = NULL;
					}
				}
			}

			m_pMessages[i] = message;
			m_startTime[i] = time;
			return;
		}
	}
}


int CHudMessage::MsgFunc_HudText( const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	char *pString = reader.ReadString();

	MessageAdd( pString, gHUD.m_flTime );
	// Remember the time -- to fix up level transitions
	m_parms.time = gHUD.m_flTime;

	// Turn on drawing
	m_iFlags |= HUD_DRAW;

	return 1;
}


int CHudMessage::MsgFunc_GameTitle( const char *pszName,  int iSize, void *pbuf )
{
	m_pGameTitle = TextMessageGet( "GAMETITLE" );
	if ( m_pGameTitle != NULL )
	{
		m_gameTitleTime = gHUD.m_flTime;

		// Turn on drawing
		m_iFlags |= HUD_DRAW;
	}

	return 1;
}

void CHudMessage::MessageAdd(client_textmessage_t * newMessage )
{
	client_textmessage_t *message;

	m_parms.time = gHUD.m_flTime;

	// Turn on drawing
	m_iFlags |= HUD_DRAW;

	if( !strcmp( newMessage->pName, "Custom" ) ) // Hey, it's mine way of detecting allocated message
	{
		message = AllocMessage( newMessage->pMessage, newMessage );
	}
	else
	{
		message = newMessage;
	}

	for ( int i = 0; i < maxHUDMessages; i++ )
	{
		if ( !m_pMessages[i] )
		{
			m_pMessages[i] = message;
			m_startTime[i] = gHUD.m_flTime;
			return;
		}
	}

}


int CHudMessage::MsgFunc_HudTextPro( const char *pszName, int iSize, void *pbuf )
{
	const char *sz;
	int hint;
	BufferReader reader( pszName, pbuf, iSize );
	sz = reader.ReadString();
	hint = reader.ReadByte();

	MessageAdd(sz, gHUD.m_flTime/*, hint, Newfont*/); // TODO

	// Remember the time -- to fix up level transitions
	m_parms.time = gHUD.m_flTime;

	// Turn on drawing
	m_iFlags |= HUD_DRAW;
	return 1;
}

int CHudMessage::MsgFunc_HudTextArgs( const char *pszName, int iSize, void *pbuf )
{
	/*BufferReader reader( pszName, pbuf, iSize );

	const char *sz = reader.ReadString();
	int hint = reader.ReadByte();

	MessageAdd(sz, gHUD.m_flTime, hint, Newfont); // TODO

	// Remember the time -- to fix up level transitions
	m_parms.time = gHUD.m_flTime;

	// Turn on drawing
	if ( !(m_iFlags & HUD_ACTIVE) )
		m_iFlags |= HUD_ACTIVE;*/

	return 1;
}

client_textmessage_t *CHudMessage::AllocMessage( const char *text, client_textmessage_t *copyFrom )
{
	const int MAX_CUSTOM_MESSAGES = 16;
	const int MAX_CUSTOM_MESSAGES_MASK = (MAX_CUSTOM_MESSAGES-1);
	static client_textmessage_t	g_pCustomMessage[MAX_CUSTOM_MESSAGES] = { };
	static int g_iCustomMessageMod = 0;

	client_textmessage_t *ret = &g_pCustomMessage[g_iCustomMessageMod];
	g_iCustomMessageMod = (g_iCustomMessageMod + 1) & MAX_CUSTOM_MESSAGES_MASK;

	if( copyFrom )
	{
		*ret = *copyFrom;
	}

	if( text )
	{
		int len = strlen( text );
		char *szCustomText = new char[len];
		strcpy( szCustomText, text );

		ret->pName = "Custom";
		ret->pMessage = szCustomText;
	}

	return ret;
}

```

`cl_dll/rain.cpp`:

```cpp
/***
*
*	Copyright (c) 2005, BUzer.
*	
*	Used with permission for Spirit of Half-Life 1.5
*
****/
/*
====== rain.cpp ========================================================
*/

#include <memory.h>
#include "hud.h"
#include "pm_math.h"
#include "cl_util.h"
#include "const.h"
#include "entity_types.h"
#include "cdll_int.h"
#include "pm_defs.h"
#include "event_api.h"

#include "rain.h"
#include "r_efx.h"
#include "con_nprint.h"
#include "triangleapi.h"
#include "parsemsg.h"

#undef fabs
#include <new>

#include "com_model.h"

#define DRIPSPEED    900		// speed of raindrips (pixel per secs)
#define SNOWSPEED    200		// speed of snowflakes
#define SNOWFADEDIST 80

#define MAXDRIPS 2000	// max raindrops
#define MAXFX    3000	// max effects

#define DRIP_SPRITE_HALFHEIGHT 64
#define DRIP_SPRITE_HALFWIDTH  1
#define SNOW_SPRITE_HALFSIZE   3

// radius water rings
#define MAXRINGHALFSIZE	25

struct
{
	Vector2D wind;
	Vector2D rand;

	float    distFromPlayer;
	float    globalHeight;

	int      dripsPerSecond;
	int	     weatherMode;	// 0 - snow, 1 - rain
	int      weatherValue;

	float    curtime;    // current time
	float    oldtime;    // last time we have updated drips
	float    timedelta;  // difference between old time and current time
	float    nextspawntime;  // when the next drip should be spawned

	int dripcounter;
	int fxcounter;
	float heightFromPlayer;

	HSPRITE hsprRain;
	HSPRITE hsprSnow;
	HSPRITE hsprRipple;
} Rain;

bool Rain_Initialized = false;

enum
{
	NO_LANDING = 0,
	DEFAULT_LANDING,
	WATER_LANDING
};

struct cl_drip_t
{
	Vector		origin;
	float		birthTime;
	float		minHeight;	// minimal height to kill raindrop
	float		alpha;

	Vector2D    Delta; // side speed
	int         land;

	cl_drip_t*		p_Next;		// next drip in chain
	cl_drip_t*		p_Prev;		// previous drip in chain
} FirstChainDrip;

struct cl_rainfx_t
{
	Vector		origin;
	float		birthTime;
	float		life;
	float		alpha;

	int type;

	cl_rainfx_t*		p_Next;		// next fx in chain
	cl_rainfx_t*		p_Prev;		// previous fx in chain
} FirstChainFX;


#ifdef _DEBUG
cvar_t *debug_rain = NULL;
#endif


/*
=================================
WaterLandingEffect
=================================
*/
void LandingEffect( cl_drip_t *drip )
{
	if( drip->land == NO_LANDING )
		return;

	if (Rain.fxcounter >= MAXFX)
	{
		//gEngfuncs.Con_Printf( "Rain error: FX limit overflow!\n" );
		return;
	}

	cl_rainfx_t *newFX = new(std::nothrow) cl_rainfx_t;
	if( !newFX )
	{
		gEngfuncs.Con_Printf( "Rain error: failed to allocate FX object!\n");
		return;
	}

	newFX->alpha = gEngfuncs.pfnRandomFloat(0.6, 0.9);
	newFX->origin = drip->origin;
	newFX->origin.z = drip->minHeight; // correct position
	newFX->birthTime = Rain.curtime;
	newFX->life = gEngfuncs.pfnRandomFloat(0.7, 1);
	newFX->type = drip->land;

	// add to first place in chain
	newFX->p_Next = FirstChainFX.p_Next;
	newFX->p_Prev = &FirstChainFX;
	if (newFX->p_Next != NULL)
		newFX->p_Next->p_Prev = newFX;
	FirstChainFX.p_Next = newFX;

	Rain.fxcounter++;
}
/*
=================================
ProcessRain

Must think every frame.
=================================
*/
void ProcessRain( void )
{
	int speed = Rain.weatherMode ? SNOWSPEED : DRIPSPEED;

	Rain.oldtime = Rain.curtime; // save old time
	Rain.curtime = gEngfuncs.GetClientTime();
	Rain.timedelta = Rain.curtime - Rain.oldtime;

	if( gHUD.cl_weather->value > 3.0f )
		gEngfuncs.Cvar_Set( "cl_weather", "3" );

	Rain.weatherValue = gHUD.cl_weather->value;

	if( Rain.dripsPerSecond == 0 || !Rain.weatherValue )
		return; // disabled

	// first frame
	if( Rain.oldtime == 0 || ( Rain.dripsPerSecond == 0 && FirstChainDrip.p_Next == NULL ) )
	{
		// fix first frame bug with nextspawntime
		Rain.nextspawntime = Rain.curtime;
		return;
	}

	if( !Rain.timedelta )
		return; // not in pause

	int spawnDrips = (Rain.dripsPerSecond + (Rain.weatherValue - 1) * 150);
	double timeBetweenDrips = 1.0 / (double)(spawnDrips);

#ifdef _DEBUG
	// save debug info
	float debug_lifetime = 0;
	int debug_howmany = 0;
	int debug_attempted = 0;
	int debug_dropped = 0;
#endif

	for( cl_drip_t *curDrip = FirstChainDrip.p_Next, *nextDrip = NULL;
		 curDrip;
		 curDrip = nextDrip ) // go through list
	{
		nextDrip = curDrip->p_Next; // save pointer to next drip

		curDrip->origin.x += Rain.timedelta * curDrip->Delta.x;
		curDrip->origin.y += Rain.timedelta * curDrip->Delta.y;
		curDrip->origin.z -= Rain.timedelta * speed;

		// remove drip if its origin lower than minHeight
		if (curDrip->origin.z < curDrip->minHeight)
		{
			LandingEffect( curDrip );
#ifdef _DEBUG
			if( debug_rain->value )
			{
				debug_lifetime += ( Rain.curtime - curDrip->birthTime );
				debug_howmany++;
			}
#endif

			curDrip->p_Prev->p_Next = curDrip->p_Next; // link chain
			if( nextDrip != NULL )
				nextDrip->p_Prev = curDrip->p_Prev;
			delete curDrip;

			Rain.dripcounter--;
		}
	}

	int maxDelta = speed * Rain.timedelta; // maximum height randomize distance
	float falltime = (Rain.globalHeight + 4096) / speed;

	for( ; Rain.nextspawntime < Rain.curtime; Rain.nextspawntime += timeBetweenDrips )
	{
#ifdef _DEBUG
		if( debug_rain->value )
			debug_attempted++;
#endif
				
		if( Rain.dripcounter < spawnDrips ) // check for overflow
		{
			float deathHeight;
			Vector vecStart, vecEnd, vecStartStart;
			Vector2D Delta( Rain.wind.x + gEngfuncs.pfnRandomFloat( Rain.rand.x * -1, Rain.rand.x ),
							Rain.wind.y + gEngfuncs.pfnRandomFloat( Rain.rand.y * -1, Rain.rand.y ));
			pmtrace_t pmtrace, pmtrace2;

			vecStart.x = gEngfuncs.pfnRandomFloat( gHUD.m_vecOrigin.x - Rain.distFromPlayer, gHUD.m_vecOrigin.x + Rain.distFromPlayer );
			vecStart.y = gEngfuncs.pfnRandomFloat( gHUD.m_vecOrigin.y - Rain.distFromPlayer, gHUD.m_vecOrigin.y + Rain.distFromPlayer );
			vecStart.z = gHUD.m_vecOrigin.z + Rain.heightFromPlayer;

			// find a point at bottom of map
			vecEnd.x = falltime * Delta.x;
			vecEnd.y = falltime * Delta.y;
			vecEnd.z = -4096;

			if( gEngfuncs.PM_PointContents( vecStart, NULL ) == CONTENTS_SOLID )
			{
#ifdef _DEBUG
				if( debug_rain->value )
					debug_dropped++;
#endif
				continue; // drip cannot be placed
			}

			gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
			gEngfuncs.pEventAPI->EV_PlayerTrace( vecStart, vecEnd, PM_WORLD_ONLY, -1, &pmtrace );

			if( pmtrace.startsolid )
			{
#ifdef _DEBUG
				if( debug_rain->value )
					debug_dropped++;
#endif
				continue; // drip cannot be placed
			}

			vecStartStart = vecStart;
			vecStartStart.z = 999999;

			// second trace. Check that player have a real sky above him
			const char *s = gEngfuncs.pEventAPI->EV_TraceTexture( pmtrace.ent, vecStart, vecStartStart );
			if( !s || strcmp( s, "sky" ) )
			{
#ifdef _DEBUG
				if( debug_rain->value )
					debug_dropped++;
#endif
				continue;
			}
			
			// falling to water?
			int contents = gEngfuncs.PM_PointContents( pmtrace.endpos, NULL );
			if( contents == CONTENTS_WATER )
			{
				int waterEntity = gEngfuncs.PM_WaterEntity( pmtrace.endpos );
				if( waterEntity > 0 )
				{
					cl_entity_t *pwater = gEngfuncs.GetEntityByIndex( waterEntity );
					if( pwater && ( pwater->model != NULL ) )
					{
						deathHeight = pwater->curstate.maxs[2];
					}
					else
					{
						gEngfuncs.Con_Printf("Rain error: can't get water entity\n");
						continue;
					}
				}
				else
				{
					gEngfuncs.Con_Printf("Rain error: water is not func_water entity\n");
					continue;
				}
			}
			else
			{
				deathHeight = pmtrace.endpos[2];
			}

			// just in case..
			if (deathHeight > vecStart[2])
			{
				gEngfuncs.Con_Printf("Rain error: can't create drip in water\n");
				continue;
			}

			cl_drip_t *newClDrip = new(std::nothrow) cl_drip_t;
			if( !newClDrip )
			{
				Rain.dripsPerSecond = 0; // disable rain
				gEngfuncs.Con_Printf( "Rain error: failed to allocate object!\n");
				return;
			}
			
			vecStart[2] -= gEngfuncs.pfnRandomFloat( 0, maxDelta ); // randomize a bit
			
			newClDrip->alpha     = gEngfuncs.pfnRandomFloat( 0.12, 0.2 );
			newClDrip->origin    = vecStart;
			newClDrip->Delta     = Delta;
			newClDrip->birthTime = Rain.curtime; // store time when it was spawned
			newClDrip->minHeight = deathHeight;

			if( contents == CONTENTS_WATER )
			{
				newClDrip->land = WATER_LANDING;
			}
			else
			{
				newClDrip->land = NO_LANDING;
			}
			/*else if( pmtrace->fraction < 1.0f && pmtrace->plane.normal.z > 0.71 && !pmtrace->inopen)
			{
				newClDrip->land = DEFAULT_LANDING;
			}
			else
			{
				newClDrip->land = NO_LANDING;
			}*/

			// add to first place in chain
			newClDrip->p_Next = FirstChainDrip.p_Next;
			newClDrip->p_Prev = &FirstChainDrip;
			if (newClDrip->p_Next != NULL)
				newClDrip->p_Next->p_Prev = newClDrip;
			FirstChainDrip.p_Next = newClDrip;

			Rain.dripcounter++;
		}
		else
		{
			//gEngfuncs.Con_Printf( "Rain error: Drip limit overflow!\n" );
			return;
		}
	}

#ifdef _DEBUG
	if( debug_rain->value ) // print debug info
	{
		con_nprint_t info =
		{
			1,
			0.5f,
			{1.0f, 0.6f, 0.0f }
		};
		gEngfuncs.Con_NXPrintf( &info, "Rain info: Drips exist: %i\n", Rain.dripcounter );

		info.index = 2;
		gEngfuncs.Con_NXPrintf( &info, "Rain info: FX's exist: %i\n", Rain.fxcounter );

		info.index = 3;
		gEngfuncs.Con_NXPrintf( &info, "Rain info: Attempted/Dropped: %i, %i\n", debug_attempted, debug_dropped);
		if( debug_howmany )
		{
			float ave = debug_lifetime / (float)debug_howmany;

			info.index = 4;
			gEngfuncs.Con_NXPrintf( &info, "Rain info: Average drip life time: %f\n", ave);
		}
	}
#endif
}

/*
=================================
ProcessFXObjects

Remove all fx objects with out time to live
Call every frame before ProcessRain
=================================
*/
void ProcessFXObjects( void )
{
	for( cl_rainfx_t *curFX = FirstChainFX.p_Next, *nextFX = NULL;
		 curFX;
		 curFX = nextFX )
	{
		nextFX = curFX->p_Next; // save pointer to next

		// delete current?
		if( curFX->birthTime + curFX->life < Rain.curtime )
		{
			curFX->p_Prev->p_Next = curFX->p_Next; // link chain
			if( nextFX )
				nextFX->p_Prev = curFX->p_Prev;

			delete curFX;
			Rain.fxcounter--;
		}
	}
}

/*
=================================
ResetRain

clear memory, delete all objects
=================================
*/
void ResetRain( void )
{
	// delete all drips
	for( cl_drip_t *curDrip = FirstChainDrip.p_Next; curDrip;
		 curDrip = FirstChainDrip.p_Next, Rain.dripcounter-- )
	{
		FirstChainDrip.p_Next = curDrip->p_Next;
		delete curDrip;
	}

	// delete all FX objects
	for( cl_rainfx_t *curFX = FirstChainFX.p_Next; curFX;
		 curFX = FirstChainFX.p_Next, Rain.fxcounter-- )
	{
		FirstChainFX.p_Next = curFX->p_Next;
		delete curFX;
	}

	InitRain();
	return;
}


int __MsgFunc_ReceiveW(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize);

	int iWeatherType = reader.ReadByte();

	if( iWeatherType == 0 )
	{
		ResetRain();
		return 1;
	}

	Rain.distFromPlayer = 500;
	Rain.dripsPerSecond = 500;
	Rain.wind.x = Rain.wind.y = 30;
	Rain.rand.x = Rain.rand.y = 0;
	Rain.weatherMode = iWeatherType - 1;
	Rain.globalHeight = 100;
	Rain.heightFromPlayer = 100;

	return 1;
}

/*
=================================
InitRain
initialze system
=================================
*/
void InitRain( void )
{
	memset( &Rain, 0, sizeof(Rain) );
	memset( &FirstChainDrip, 0, sizeof( cl_drip_t ));
	memset( &FirstChainFX, 0, sizeof( cl_rainfx_t ));

#ifdef _DEBUG
	if( !debug_rain )
		debug_rain = CVAR_CREATE( "Rain.debug", "0", 0 );
#endif

	Rain.hsprRain = SPR_Load("sprites/effects/rain.spr");
	Rain.hsprSnow = SPR_Load("sprites/effects/snowflake.spr");
	Rain.hsprRipple = SPR_Load("sprites/effects/ripple.spr");

	if( !Rain_Initialized )
	{
		HOOK_MESSAGE_FUNC( "ReceiveW", __MsgFunc_ReceiveW );

		Rain_Initialized = Rain.hsprRain && Rain.hsprSnow && Rain.hsprRipple;
	}
}


void SetPoint( float x, float y, float z, float (*matrix)[4])
{
	Vector point( x, y, z ), result;

	VectorTransform( point, matrix, result );

	gEngfuncs.pTriAPI->Vertex3fv( result );
}



/*
=================================
DrawRain

draw raindrips and snowflakes
=================================
*/
void DrawRain( void )
{
	if (FirstChainDrip.p_Next == NULL)
		return; // no drips to draw

	cl_entity_t *player = gEngfuncs.GetLocalPlayer();

	if( Rain.weatherMode == 0 ) // draw rain
	{
		const model_s *pTexture = gEngfuncs.GetSpritePointer( Rain.hsprRain );
		if( !pTexture )
			return;

		gEngfuncs.pTriAPI->SpriteTexture( (struct model_s *)pTexture, 0 );
		gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
		gEngfuncs.pTriAPI->CullFace( TRI_NONE );

		for( cl_drip_t *Drip = FirstChainDrip.p_Next; Drip; Drip = Drip->p_Next )
		{
			Vector2D toPlayer, shift(Drip->Delta * DRIP_SPRITE_HALFHEIGHT / DRIPSPEED);
			toPlayer.x = (player->origin.x - Drip->origin.x) * DRIP_SPRITE_HALFWIDTH;
			toPlayer.y = (player->origin.y - Drip->origin.y) * DRIP_SPRITE_HALFWIDTH;
			toPlayer = toPlayer.Normalize();

			// --- draw triangle --------------------------
			gEngfuncs.pTriAPI->Color4f( 1.0, 1.0, 1.0, Drip->alpha );
			gEngfuncs.pTriAPI->Begin( TRI_TRIANGLES );

				gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
				gEngfuncs.pTriAPI->Vertex3f( Drip->origin.x-toPlayer.y - shift.x,
						Drip->origin.y + toPlayer.x - shift.y,
						Drip->origin.z + DRIP_SPRITE_HALFHEIGHT );

				gEngfuncs.pTriAPI->TexCoord2f( 0.5, 1 );
				gEngfuncs.pTriAPI->Vertex3f( Drip->origin.x + shift.x,
						Drip->origin.y + shift.y,
						Drip->origin.z - DRIP_SPRITE_HALFHEIGHT );

				gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
				gEngfuncs.pTriAPI->Vertex3f( Drip->origin.x+toPlayer.y - shift.x,
						Drip->origin.y - toPlayer.x - shift.y,
						Drip->origin.z + DRIP_SPRITE_HALFHEIGHT);

			gEngfuncs.pTriAPI->End();
			// --- draw triangle end ----------------------
		}
	}

	else	// draw snow
	{
		const model_s *pTexture = gEngfuncs.GetSpritePointer( Rain.hsprSnow );
		if( !pTexture )
			return;

		float visibleHeight = Rain.globalHeight - SNOWFADEDIST;
		vec3_t normal;
		float  matrix[3][4];

		gEngfuncs.GetViewAngles( normal );
		AngleMatrix (normal, matrix);	// calc view matrix

		gEngfuncs.pTriAPI->SpriteTexture( (struct model_s *)pTexture, 0 );
		gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
		gEngfuncs.pTriAPI->CullFace( TRI_NONE );


		for( cl_drip_t *Drip = FirstChainDrip.p_Next; Drip; Drip = Drip->p_Next )
		{
			matrix[0][3] = Drip->origin.x; // write origin to matrix
			matrix[1][3] = Drip->origin.y;
			matrix[2][3] = Drip->origin.z;

			// apply start fading effect
			float alpha = (Drip->origin.z <= visibleHeight) ?
							  Drip->alpha :
							  (((gHUD.m_vecOrigin.z + Rain.heightFromPlayer) - Drip->origin.z) / (float)SNOWFADEDIST) * Drip->alpha;

			// --- draw quad --------------------------
			gEngfuncs.pTriAPI->Color4f( 1.0, 1.0, 1.0, alpha );
			gEngfuncs.pTriAPI->Begin( TRI_QUADS );

				gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
				SetPoint(0, SNOW_SPRITE_HALFSIZE, SNOW_SPRITE_HALFSIZE, matrix);

				gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
				SetPoint(0, SNOW_SPRITE_HALFSIZE, -SNOW_SPRITE_HALFSIZE, matrix);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
				SetPoint(0, -SNOW_SPRITE_HALFSIZE, -SNOW_SPRITE_HALFSIZE, matrix);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
				SetPoint(0, -SNOW_SPRITE_HALFSIZE, SNOW_SPRITE_HALFSIZE, matrix);

			gEngfuncs.pTriAPI->End();
			// --- draw quad end ----------------------
		}
	}
}

/*
=================================
DrawFXObjects
=================================
*/
void DrawFXObjects( void )
{

	if( !FirstChainFX.p_Next )
		return;

	const model_s *pTexture = gEngfuncs.GetSpritePointer( Rain.hsprRipple );
	gEngfuncs.pTriAPI->SpriteTexture( (struct model_s *)pTexture, 0 );
	gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
	gEngfuncs.pTriAPI->CullFace( TRI_NONE );

	// go through objects list
	for( cl_rainfx_t *curFX = FirstChainFX.p_Next; curFX; curFX = curFX->p_Next )
	{
		switch( curFX->type )
		{
		case WATER_LANDING:
		{
			// fadeout
			float alpha = ((curFX->birthTime + curFX->life - Rain.curtime) / curFX->life) * curFX->alpha;
			float size = (Rain.curtime - curFX->birthTime) * MAXRINGHALFSIZE;

			// --- draw quad --------------------------
			gEngfuncs.pTriAPI->Color4f( 1.0, 1.0, 1.0, alpha );
			gEngfuncs.pTriAPI->Begin( TRI_QUADS );

				gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
				gEngfuncs.pTriAPI->Vertex3f(curFX->origin.x - size, curFX->origin.y - size, curFX->origin.z);

				gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
				gEngfuncs.pTriAPI->Vertex3f(curFX->origin.x - size, curFX->origin.y + size, curFX->origin.z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
				gEngfuncs.pTriAPI->Vertex3f(curFX->origin.x + size, curFX->origin.y + size, curFX->origin.z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
				gEngfuncs.pTriAPI->Vertex3f(curFX->origin.x + size, curFX->origin.y - size, curFX->origin.z);

			gEngfuncs.pTriAPI->End();
			// --- draw quad end ----------------------
		}
		}
	}
}

```

`cl_dll/readme.txt`:

```txt
  client dll readme.txt
-------------------------

This file details the structure of the half-life client dll,  and
how it communicates with the half-life game engine.


Engine callback functions:

Drawing functions:
	HSPRITE SPR_Load( char *picname );
		Loads a sprite into memory, and returns a handle to it.

	int  SPR_Frames( HSPRITE sprite );
		Returns the number of frames stored in the specified sprite.

	int  SPR_Height( HSPRITE x, int frame )
		Returns the height, in pixels, of a sprite at the specified frame.  
		Returns 0 is the frame number or the sprite handle is invalid.

	int  SPR_Width( HSPRITE x, int f )
		Returns the width, in pixels, of a sprite at the specified frame.  
		Returns 0 is the frame number or the sprite handle is invalid.

	int  SPR_Set( HSPRITE sprite, int r, int g, int b );
		Prepares a sprite about to be drawn.  RBG color values are applied to the sprite at this time.


	void  SPR_Draw( int frame, int x, int y );
		Precondition:  SPR_Set has already been called for a sprite.
		Draws the currently active sprite to the screen,  at position (x,y), where (0,0) is
		the top left-hand corner of the screen.


	void  SPR_DrawHoles( int frame, int x, int y );
		Precondition:  SPR_Set has already been called for a sprite.
		Draws the currently active sprite to the screen.  Color index #255 is treated as transparent.

	void  SPR_DrawAdditive( int frame, int x, int y );
		Precondition:  SPR_Set has already been called for a sprite.
		Draws the currently active sprite to the screen,  adding it's color values to the background.

	void  SPR_EnableScissor( int x, int y, int width, int height );
		Creates a clipping rectangle.  No pixels will be drawn outside the specified area.  Will
		stay in effect until either the next frame,  or SPR_DisableScissor is called.

	void  SPR_DisableScissor( void );
		Disables the effect of an SPR_EnableScissor call.

	int	 IsHighRes( void );
		returns 1 if the res mode is 640x480 or higher;  0 otherwise.

	int	 ScreenWidth( void );
		returns the screen width, in pixels.

	int	 ScreenHeight( void );
		returns the screen height, in pixels.

// Sound functions
	void PlaySound( char *szSound, int volume )
		plays the sound 'szSound' at the specified volume.  Loads the sound if it hasn't been cached.
		If it can't find the sound,  it displays an error message and plays no sound.

	void PlaySound( int iSound, int volume )
		Precondition:  iSound has been precached.
		Plays the sound, from the precache list.


// Communication functions
	void  SendClientCmd( char *szCmdString );
		sends a command to the server,  just as if the client had typed the szCmdString at the console.

	char *GetPlayerName( int entity_number );
		returns a pointer to a string, that contains the name of the specified client.  
		Returns NULL if the entity_number is not a client.
		

	DECLARE_MESSAGE(),  HOOK_MESSAGE()
		These two macros bind the message sending between the entity DLL and the client DLL to
		the CHud object.

		HOOK_MESSAGE( message_name )
			 This is used inside CHud::Init().  It calls into the engine to hook that message
			 from the incoming message stream.
			 Precondition:  There must be a function of name UserMsg_message_name declared
			 for CHud.  Eg,  CHud::UserMsg_Health() must be declared if you want to 
			 use HOOK_MESSAGE( Health );

		DECLARE_MESSAGE( message_name )
			For each HOOK_MESSAGE you must have an equivalent DECLARE_MESSAGE.  This creates
			a function which passes the hooked messages into the CHud object.


	HOOK_COMMAND(),  DECLARE_COMMAND()
		These two functions declare and hook console commands into the client dll.
		
		HOOK_COMMAND( char *command, command_name )
			Whenever the user types the 'command' at the console,  the function 'command_name'
			will be called.
			Precondition: There must be a function of the name UserCmd_command_name declared
			for CHud. Eg,  CHud::UserMsg_ShowScores() must be declared if you want to
			use HOOK_COMMAND( "+showscores", ShowScores );

		DECLARE_COMMAND( command_name )
			For each HOOK_COMMAND you must have an equivalent DECLARE_COMMAND.  This creates
			a function which passes the hooked commands into the CHud object.
		

```

`cl_dll/saytext.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// saytext.cpp
//
// implementation of CHudSayText class
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include "vgui_parser.h"
#include "draw_util.h"
#include "com_weapons.h"
//#include "vgui_TeamFortressViewport.h"

extern float *GetClientColor( int clientIndex );

#define MAX_LINES	5
#define MAX_CHARS_PER_LINE	1024  /* it can be less than this, depending on char size */

// allow 20 pixels on either side of the text
#define MAX_LINE_WIDTH  ( ScreenWidth - 40 )
#define LINE_START  10

static char g_szLineBuffer[ MAX_LINES + 1 ][ MAX_CHARS_PER_LINE ];
static float *g_pflNameColors[ MAX_LINES + 1 ];
static int g_iNameLengths[ MAX_LINES + 1 ];
static float flScrollTime = 0;  // the time at which the lines next scroll up

static int Y_START = 0;
static int line_height = 0;

int CHudSayText :: Init( void )
{
	gHUD.AddHudElem( this );

	HOOK_MESSAGE( gHUD.m_SayText, SayText );

	InitHUDData();

	m_HUD_saytext =			gEngfuncs.pfnRegisterVariable( "hud_saytext_internal", "1", 0 );
	m_HUD_saytext_time =	gEngfuncs.pfnRegisterVariable( "hud_saytext_time", "5", 0 );

	m_iFlags |= HUD_INTERMISSION; // is always drawn during an intermission

	return 1;
}


void CHudSayText :: InitHUDData( void )
{
	memset( g_szLineBuffer, 0, sizeof g_szLineBuffer );
	memset( g_pflNameColors, 0, sizeof g_pflNameColors );
	memset( g_iNameLengths, 0, sizeof g_iNameLengths );
}

int CHudSayText :: VidInit( void )
{
	return 1;
}


int ScrollTextUp( void )
{
	g_szLineBuffer[MAX_LINES][0] = 0;
	memmove( g_szLineBuffer[0], g_szLineBuffer[1], sizeof(g_szLineBuffer) - sizeof(g_szLineBuffer[0]) ); // overwrite the first line // -V512
	memmove( &g_pflNameColors[0], &g_pflNameColors[1], sizeof(g_pflNameColors) - sizeof(g_pflNameColors[0]) );
	memmove( &g_iNameLengths[0], &g_iNameLengths[1], sizeof(g_iNameLengths) - sizeof(g_iNameLengths[0]) );
	g_szLineBuffer[MAX_LINES-1][0] = 0;

	if ( g_szLineBuffer[0][0] == ' ' ) // also scroll up following lines
	{
		g_szLineBuffer[0][0] = 2;
		return 1 + ScrollTextUp();
	}

	return 1;
}

int CHudSayText :: Draw( float flTime )
{
	int y = Y_START;

	//if ( ( gViewPort && gViewPort->AllowedToPrintText() == FALSE) || !m_HUD_saytext->value )
	if ( !m_HUD_saytext->value )
		return 1;

	// make sure the scrolltime is within reasonable bounds,  to guard against the clock being reset
	flScrollTime = min( flScrollTime, flTime + m_HUD_saytext_time->value );

	// make sure the scrolltime is within reasonable bounds,  to guard against the clock being reset
	flScrollTime = min( flScrollTime, flTime + m_HUD_saytext_time->value );

	if ( flScrollTime <= flTime )
	{
		if ( *g_szLineBuffer[0] )
		{
			flScrollTime = flTime + m_HUD_saytext_time->value;
			// push the console up
			ScrollTextUp();
		}
		else
		{ // buffer is empty,  just disable drawing of this section
			m_iFlags &= ~HUD_DRAW;
		}
	}
	
	for (int i = 0; i < MAX_LINES; i++)
	{
		if (!g_szLineBuffer[i][0]) // skip empty string
			continue;

		int current_x = LINE_START;
		const char* text = g_szLineBuffer[i];
		size_t length = strlen(text);

		// default color if not set
		DrawUtils::SetConsoleTextColor(g_ColorYellow[0], g_ColorYellow[1], g_ColorYellow[2]);

		// buffer for accumulating characters of the same color
		char color_buffer[256] = {0};
		size_t buffer_pos = 0;

		for (size_t c = 0; c < length; c++)
		{
			// color code parse
			// '\x01' - normal (yellow); '\0x03' - teamcolor (R GREY B); '\x04' - green
			if (text[c] == '\x01' || text[c] == '\x03' || text[c] == '\x04')
			{
				// if there are characters in the buffer, we draw them with the current color
				if (buffer_pos > 0)
				{
					color_buffer[buffer_pos] = '\x00';
					current_x = DrawUtils::DrawConsoleString(current_x, y, color_buffer);
					buffer_pos = 0;
				}

				// switch to color code
				char color_code = text[c];
				switch (color_code)
				{
					case '\x01': // yellow normal
						DrawUtils::SetConsoleTextColor(g_ColorYellow[0], g_ColorYellow[1], g_ColorYellow[2]);
						break;
					case '\x03': // team color
						if (g_pflNameColors[i])
						{
							DrawUtils::SetConsoleTextColor(g_pflNameColors[i][0], g_pflNameColors[i][1], g_pflNameColors[i][2]);
						}
						break;
					case '\x04': // green
						DrawUtils::SetConsoleTextColor(g_ColorGreen[0], g_ColorGreen[1], g_ColorGreen[2]);
						break;
				}
				continue;
			}

			// add char to buf
			if (buffer_pos < sizeof(color_buffer) - 1)
			{
				color_buffer[buffer_pos++] = text[c];
			}
		}

		// draw the remaining characters
		if (buffer_pos > 0)
		{
			color_buffer[buffer_pos] = '\x00';
			DrawUtils::DrawConsoleString(current_x, y, color_buffer);
		}

		y += line_height;
	}
	
	return 1;
}

struct
{
	const char key[32];
	const char value[64];
	int numArgs;
	bool allowDead;
	bool replaceFirstArgToName;
	bool swap;
} sayTextFmt[] =
{
	{
		"#Cstrike_Chat_CT",
		"\x03(Counter-Terrorist) %s : \x01%s",
		2, true, true, false
	},
	{
		"#Cstrike_Chat_T",
		"\x03(Terrorist) %s : \x01%s",
		2, true, true, false
	},
	{
		"#Cstrike_Chat_CT_Dead",
		"\x03*DEAD*(Counter-Terrorist) %s : \x01%s",
		2, false, true, false
	},
	{
		"#Cstrike_Chat_T_Dead",
		"\x03*DEAD*(Terrorist) %s : \x01%s",
		2, false, true, false
	},
	{
		"#Cstrike_Chat_Spec",
		"\x03(Spectator) %s : \x03%s",
		2, false, true, false
	},
	{
		"#Cstrike_Chat_All",
		"\x03%s : \x01%s",
		2, true, true, false
	},
	{
		"#Cstrike_Chat_AllDead",
		"\x03*DEAD* %s: \x01%s",
		2, false, true, false
	},
	{
		"#Cstrike_Chat_AllSpec",
		"\x03*SPEC* %s: \x03%s",
		2, false, true, false
	},
	{
		"#Cstrike_Name_Change",
		"\x03* %s changed name to %s",
		2, true, false, false
	},
	{
		"#Cstrike_Chat_T_Loc",
		"\x03*(Terrorist) %s @ %s : \x01%s",
		3, true, true, true
	},
	{
		"#Cstrike_Chat_CT_Loc",
		"\x03*(Counter-Terrorist) %s @ %s : \x01%s",
		3, true, true, true
	},
	{
		"#Spec_PlayerItem",
		"%s",
		1, true, false, false,
	},
};

int CHudSayText :: MsgFunc_SayText( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	int client_index, argc, numArgs;		// the client who spoke the message
	char *arg, *fmt, *argv[3] = {};
	const char *fmt_tran = nullptr;
	bool allowDead, replaceFirstArgToName, swap;
	int len;

	client_index = reader.ReadByte();

	// find all arguments
	arg = reader.ReadString();
	len = strlen( arg );
	fmt = new char[len+1];
	strcpy(fmt, arg);

	for( argc = 0; argc < 3; argc++ )
	{
		arg = reader.ReadString();
		if( !arg[0] && !reader.Valid() )
			break;

		len = strlen( arg );
		argv[argc] = new char[len+1];
		strncpy( argv[argc], arg, len );
		argv[argc][len] = 0;
	}

	// see if argv[0] is translatable
	if( fmt[0] == '#' )
	{
		for( int i = 0; i < sizeof( sayTextFmt ) / sizeof( sayTextFmt[0] ); i++ )
		{
			if( !strcmp( fmt, sayTextFmt[i].key ))
			{
				fmt_tran = (char*)sayTextFmt[i].value;
				allowDead = sayTextFmt[i].allowDead;
				numArgs = sayTextFmt[i].numArgs;

				// VALVEWHY: Second argument may be null string, but not on name changing.
				replaceFirstArgToName = sayTextFmt[i].replaceFirstArgToName;

				// VALVEWHY #2: location is last argument, so swap
				swap = sayTextFmt[i].swap;
				break;
			}
		}
	}

	// no translations
	if( !fmt_tran )
	{
		fmt_tran = fmt;
		numArgs = argc;
		allowDead = true;
		replaceFirstArgToName = false;
		swap = false;
	}

	// If text is sent from dead player or spectator
	// don't draw it, until local player isn't specator or dead.
	if( !allowDead && !CL_IsDead() && !g_iUser1 )
	{
		delete[] fmt;

		for( int i = 0; i < 3; i++ )
			if( argv[i] ) delete argv[i];

		return 1;
	}

	if( replaceFirstArgToName )
	{
		GetPlayerInfo( client_index, &g_PlayerInfoList[client_index] );
		delete[] argv[0];

		argv[0] = g_PlayerInfoList[client_index].name;
	}

	char dst[1024];

	switch( numArgs )
	{
	case 3:
		if( swap )
			snprintf( dst, sizeof( dst ), fmt_tran, argv[0], argv[2], argv[1] );
		else
			snprintf( dst, sizeof( dst ), fmt_tran, argv[0], argv[1], argv[2] );
		break;
	case 2:
		snprintf( dst, sizeof( dst ), fmt_tran, argv[0], argv[1] );
		break;
	case 1:
		snprintf( dst, sizeof( dst ), fmt_tran, argv[0] );
		break;
	case 0:
		strncpy( dst, fmt_tran, sizeof( dst ) );
		dst[sizeof(dst)-1] = 0;
		break;
	}
	
	SayTextPrint( dst, strlen(dst), client_index );

	delete[] fmt;

	for( int i = 0; i < argc; i++ )
	{
		// skip second argument if it was replaced by name
		if( i == 0 && replaceFirstArgToName )
			continue;

		if( argv[i] )
			delete[] argv[i];
	}

	return 1;
}

void CHudSayText :: SayTextPrint( const char *pszBuf, int iBufSize, int clientIndex )
{
	// find an empty string slot
	int i;
	for ( i = 0; i < MAX_LINES; i++ )
	{
		if ( ! *g_szLineBuffer[i] )
			break;
	}
	if ( i == MAX_LINES )
	{
		// force scroll buffer up
		ScrollTextUp();
		i = MAX_LINES - 1;
	}

	g_iNameLengths[i] = 0;
	g_pflNameColors[i] = NULL;

#if 1
	// if it's a say message, search for the players name in the string
	if ( clientIndex > 0 )
	{
		GetPlayerInfo( clientIndex, &g_PlayerInfoList[clientIndex] );
		const char *pName = g_PlayerInfoList[clientIndex].name;
		g_pflNameColors[i] = GetClientColor( clientIndex );

		if ( pName )
		{
			const char *nameInString = strstr( pszBuf, pName );

			if ( nameInString )
			{
				g_iNameLengths[i] = strlen( pName ) + (nameInString - pszBuf);
			}
		}
	}
#endif


	strncpy( g_szLineBuffer[i], pszBuf, max(iBufSize -1, MAX_CHARS_PER_LINE-1) );

	// make sure the text fits in one line
	EnsureTextFitsInOneLineAndWrapIfHaveTo( i );

	// Set scroll time
	if ( i == 0 )
	{
		flScrollTime = gHUD.m_flTime + m_HUD_saytext_time->value;
	}

	m_iFlags |= HUD_DRAW;
	PlaySound( "misc/talk.wav", 1 );

	if( !g_iUser1 )
	{
		Y_START = ScreenHeight - 60;
	}
	else
	{
		Y_START = ScreenHeight * 4 / 5;
	}
	Y_START -= (line_height * (MAX_LINES+1));

}

void CHudSayText :: EnsureTextFitsInOneLineAndWrapIfHaveTo( int line )
{
	int line_width = 0;
	DrawUtils::ConsoleStringSize(g_szLineBuffer[line], &line_width, &line_height );

	if ( (line_width + LINE_START) > MAX_LINE_WIDTH )
	{ // string is too long to fit on line
		// scan the string until we find what word is too long,  and wrap the end of the sentence after the word
		int length = LINE_START;
		int tmp_len = 0;
		char *last_break = NULL;
		for ( char *x = g_szLineBuffer[line]; *x != 0; x++ )
		{
			// check for a color change, if so skip past it
			if ( x[0] == '/' && x[1] == '(' )
			{
				x += 2;
				// skip forward until past mode specifier
				while ( *x != 0 && *x != ')' )
					x++;

				if ( *x != 0 )
					x++;

				if ( *x == 0 )
					break;
			}

			char buf[2];
			buf[1] = 0;

			if ( *x == ' ' && x != g_szLineBuffer[line] )  // store each line break,  except for the very first character
				last_break = x;

			buf[0] = *x;  // get the length of the current character
			DrawUtils::ConsoleStringSize( buf, &tmp_len, &line_height );
			length += tmp_len;

			if ( length > MAX_LINE_WIDTH )
			{  // needs to be broken up
				if ( !last_break )
					last_break = x-1;

				x = last_break;

				// find an empty string slot
				int j;
				do 
				{
					for ( j = 0; j < MAX_LINES; j++ )
					{
						if ( ! *g_szLineBuffer[j] )
							break;
					}
					if ( j == MAX_LINES )
					{
						// need to make more room to display text, scroll stuff up then fix the pointers
						int linesmoved = ScrollTextUp();
						line -= linesmoved;
						last_break = last_break - (sizeof(g_szLineBuffer[0]) * linesmoved);
					}
				}
				while ( j == MAX_LINES );

				// copy remaining string into next buffer,  making sure it starts with a space character
				if ( (char)*last_break == (char)' ' )
				{
					int linelen = strlen(g_szLineBuffer[j]);
					int remaininglen = strlen(last_break);

					if ( (linelen - remaininglen) <= MAX_CHARS_PER_LINE )
						strcat( g_szLineBuffer[j], last_break );
				}
				else
				{
					if ( (strlen(g_szLineBuffer[j]) - strlen(last_break) - 2) < MAX_CHARS_PER_LINE )
					{
						strcat( g_szLineBuffer[j], " " );
						strcat( g_szLineBuffer[j], last_break );
					}
				}

				*last_break = 0; // cut off the last string

				EnsureTextFitsInOneLineAndWrapIfHaveTo( j );
				break;
			}
		}
	}
}

```

`cl_dll/status_icons.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// status_icons.cpp
//
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "event_api.h"
#include "com_weapons.h"

int CHudStatusIcons::Init( void )
{
	HOOK_MESSAGE( gHUD.m_StatusIcons, StatusIcon );

	gHUD.AddHudElem( this );

	Reset();

	return 1;
}

int CHudStatusIcons::VidInit( void )
{
	return 1;
}

void CHudStatusIcons::Reset( void )
{
	memset( m_IconList, 0, sizeof m_IconList );
	m_iFlags &= ~HUD_DRAW;
}

// Draw status icons along the left-hand side of the screen
int CHudStatusIcons::Draw( float flTime )
{
	if (gEngfuncs.IsSpectateOnly())
		return 1;
	// find starting position to draw from, along right-hand side of screen
	int x = 5;
	int y = ScreenHeight / 2;

	// loop through icon list, and draw any valid icons drawing up from the middle of screen
	for ( int i = 0; i < MAX_ICONSPRITES; i++ )
	{
		if ( m_IconList[i].spr )
		{
			y -= ( m_IconList[i].rc.Height() ) + 5;
			
			if( g_bInBombZone && !strcmp(m_IconList[i].szSpriteName, "c4") && ((int)(flTime * 10) % 2))
				SPR_Set( m_IconList[i].spr, 255, 16, 16 );
			else SPR_Set( m_IconList[i].spr, m_IconList[i].r, m_IconList[i].g, m_IconList[i].b );
			SPR_DrawAdditive( 0, x, y, &m_IconList[i].rc );
		}
	}
	
	return 1;
}

// Message handler for StatusIcon message
// accepts five values:
//		byte   : TRUE = ENABLE icon, FALSE = DISABLE icon
//		string : the sprite name to display
//		byte   : red
//		byte   : green
//		byte   : blue
int CHudStatusIcons::MsgFunc_StatusIcon( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int ShouldEnable = reader.ReadByte();
	char *pszIconName = reader.ReadString();

	if ( ShouldEnable )
	{
		int r = reader.ReadByte();
		int g = reader.ReadByte();
		int b = reader.ReadByte();
		EnableIcon( pszIconName, r, g, b );
		m_iFlags |= HUD_DRAW;
	}
	else
	{
		DisableIcon( pszIconName );
	}

	return 1;
}

// add the icon to the icon list, and set it's drawing color
void CHudStatusIcons::EnableIcon( const char *pszIconName, unsigned char red, unsigned char green, unsigned char blue )
{
	// check to see if the sprite is in the current list
	int i;
	for ( i = 0; i < MAX_ICONSPRITES; i++ )
	{
		if ( !stricmp( m_IconList[i].szSpriteName, pszIconName ) )
			break;
	}

	if ( i == MAX_ICONSPRITES )
	{
		// icon not in list, so find an empty slot to add to
		for ( i = 0; i < MAX_ICONSPRITES; i++ )
		{
			if ( !m_IconList[i].spr )
				break;
		}
	}

	// if we've run out of space in the list, overwrite the first icon
	if ( i == MAX_ICONSPRITES )
	{
		i = 0;
	}

	// Load the sprite and add it to the list
	// the sprite must be listed in hud.txt
	int spr_index = gHUD.GetSpriteIndex( pszIconName );
	m_IconList[i].spr = gHUD.GetSprite( spr_index );
	m_IconList[i].rc = gHUD.GetSpriteRect( spr_index );
	m_IconList[i].r = red;
	m_IconList[i].g = green;
	m_IconList[i].b = blue;
	strncpy( m_IconList[i].szSpriteName, pszIconName, MAX_ICONSPRITENAME_LENGTH );
	m_IconList[i].szSpriteName[MAX_ICONSPRITENAME_LENGTH-1]=0;
}

void CHudStatusIcons::DisableIcon( const char *pszIconName )
{
	// find the sprite is in the current list
	for ( int i = 0; i < MAX_ICONSPRITES; i++ )
	{
		if ( !stricmp( m_IconList[i].szSpriteName, pszIconName ) )
		{
			// clear the item from the list
			memset( &m_IconList[i], 0, sizeof( icon_sprite_t ) );
			return;
		}
	}
}

```

`cl_dll/statusbar.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// statusbar.cpp
//
// generic text status bar, set by game dll
// runs across bottom of screen
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>
#include "draw_util.h"

#define STATUSBAR_ID_LINE		0

inline void InsertTextMsg( char *szDst, size_t sLen, const char *szMsgName)
{
	client_textmessage_t *msg = TextMessageGet(szMsgName);
	if( msg )
	{
		strncpy( szDst, msg->pMessage, sLen );
	}
	else strncpy( szDst, szMsgName, sLen );
	szDst[sLen-1] = 0;
}

int CHudStatusBar :: Init( void )
{
	gHUD.AddHudElem( this );

	HOOK_MESSAGE( gHUD.m_StatusBar, StatusText );
	HOOK_MESSAGE( gHUD.m_StatusBar, StatusValue );

	Reset();

	hud_centerid = CVAR_CREATE( "hud_centerid", "0", FCVAR_ARCHIVE );

	return 1;
}

int CHudStatusBar :: VidInit( void )
{
	// Load sprites here

	return 1;
}

void CHudStatusBar :: Reset( void )
{
	int i = 0;

	m_iFlags &= ~HUD_DRAW;  // start out inactive
	for ( i = 0; i < MAX_STATUSBAR_LINES; i++ )
		m_szStatusText[i][0] = 0;
	memset( m_iStatusValues, 0, sizeof m_iStatusValues );

	m_iStatusValues[0] = 1;  // 0 is the special index, which always returns true

	for ( i = 0; i < MAX_PLAYERS; i++ )
		g_PlayerExtraInfo[i].showhealth = 0.0f;

	// reset our colors for the status bar lines (yellow is default)
	for ( i = 0; i < MAX_STATUSBAR_LINES; i++ )
		m_pflNameColors[i] = g_ColorYellow;
}

void CHudStatusBar :: ParseStatusString( int line_num )
{
	// localise string first
	char szBuffer[MAX_STATUSTEXT_LENGTH];
	memset( szBuffer, 0, sizeof szBuffer );
	gHUD.m_TextMessage.LocaliseTextString( m_szStatusText[line_num], szBuffer, MAX_STATUSTEXT_LENGTH );

	// parse m_szStatusText & m_iStatusValues into m_szStatusBar
	memset( m_szStatusBar[line_num], 0, MAX_STATUSTEXT_LENGTH );
	char *src = szBuffer;
	char *dst = m_szStatusBar[line_num];

	char *src_start = src, *dst_start = dst;

	while ( *src != 0 )
	{
		while ( *src == '\n' )
			src++;  // skip over any newlines

		if ( ((src - src_start) >= MAX_STATUSTEXT_LENGTH) || ((dst - dst_start) >= MAX_STATUSTEXT_LENGTH) )
			break;

		int index = atoi( src );
		// should we draw this line?
		if ( (index >= 0 && index < MAX_STATUSBAR_VALUES) && (m_iStatusValues[index] != 0) )
		{  // parse this line and append result to the status bar
			while ( *src >= '0' && *src <= '9' )
				src++;

			if ( *src == '\n' || *src == 0 )
				continue; // no more left in this text line

			// copy the text, char by char, until we hit a % or a \n
			while ( *src != '\n' && *src != 0 )
			{
				if ( *src != '%' )
				{  // just copy the character
					*dst = *src;
					dst++, src++;
				}
				else
				{
					// get the descriptor
					char valtype = *(++src); // move over %

					// if it's a %, draw a % sign
					if ( valtype == '%' )
					{
						*dst = valtype;
						dst++, src++;
						continue;
					}

					// move over descriptor, then get and move over the index
					index = atoi( ++src ); 
					while ( *src >= '0' && *src <= '9' )
						src++;

					if ( index >= 0 && index < MAX_STATUSBAR_VALUES )
					{
						int indexval = m_iStatusValues[index];

						// get the string to substitute in place of the %XX
						char szRepString[MAX_PLAYER_NAME_LENGTH];
						switch ( valtype )
						{
						case 'p':  // player name
							GetPlayerInfo( indexval, &g_PlayerInfoList[indexval] );
							if ( g_PlayerInfoList[indexval].name != NULL )
							{
								strncpy( szRepString, g_PlayerInfoList[indexval].name, MAX_PLAYER_NAME_LENGTH );
								gHUD.m_Health.m_iPlayerLastPointedAt = indexval;
								m_pflNameColors[line_num] = GetClientColor( indexval );
							}
							else
							{
								strncpy( szRepString, "******", MAX_PLAYER_NAME_LENGTH );
							}

							break;
						case 'i':  // number
							g_PlayerExtraInfo[gHUD.m_Health.m_iPlayerLastPointedAt].health = indexval;
							g_PlayerExtraInfo[gHUD.m_Health.m_iPlayerLastPointedAt].showhealth = gHUD.m_flTime + 5.0f;
							sprintf( szRepString, "%d", indexval );
							break;
						case 'h':  // health
							InsertTextMsg(szRepString, MAX_PLAYER_NAME_LENGTH, "Health");
							break;
						case 'c':
							if( indexval == 1 )
							{
								InsertTextMsg(szRepString, MAX_PLAYER_NAME_LENGTH, "Friend");
							}
							else if( indexval == 2 )
							{
								InsertTextMsg(szRepString, MAX_PLAYER_NAME_LENGTH, "Enemy");
							}
							else if( indexval == 3 )
							{
								InsertTextMsg(szRepString, MAX_PLAYER_NAME_LENGTH, "Hostage");
							}
							else szRepString[0] = 0;
							break;
						default:
							szRepString[0] = 0;
						}

						for ( char *cp = szRepString; *cp != 0 && ((dst - dst_start) < MAX_STATUSTEXT_LENGTH); cp++, dst++ )
							*dst = *cp;
					}
				}
			}
		}
		else
		{
			// skip to next line of text
			while ( *src != 0 && *src != '\n' )
				src++;
		}
	}
}

int CHudStatusBar :: Draw( float fTime )
{
	bool empty = true;

	if ( m_bReparseString )
	{
		for ( int i = 0; i < MAX_STATUSBAR_LINES; i++ )
		{
			m_pflNameColors[i] = g_ColorYellow;
			ParseStatusString( i );
		}
		m_bReparseString = FALSE;
	}

	if( g_iUser1 > 0 )
	{
		// this is a spectator, so don't draw any statusbars
		return 0;
	}

	int Y_START = ScreenHeight - YRES(32 + 4);

	// Draw the status bar lines
	for ( int i = 0; i < MAX_STATUSBAR_LINES; i++ )
	{
		if( !m_szStatusBar[i][0] )
			continue;
		else empty = false;

		int TextHeight, TextWidth;
		DrawUtils::ConsoleStringSize( m_szStatusBar[i], &TextWidth, &TextHeight );

		int x = 4;
		int y = Y_START - ( 4 + TextHeight * i ); // draw along bottom of screen

		// let user set status ID bar centering
		if ( i == STATUSBAR_ID_LINE && hud_centerid->value != 0.0f )
		{
			x = max( 0, max(2, (ScreenWidth - TextWidth)) / 2 );
			y = (ScreenHeight / 2) + (TextHeight * hud_centerid->value );
		}

		if ( m_pflNameColors[i] )
			DrawUtils::SetConsoleTextColor( m_pflNameColors[i][0], m_pflNameColors[i][1], m_pflNameColors[i][2] );

		DrawUtils::DrawConsoleString( x, y, m_szStatusBar[i] );
	}

	if( empty )
	{
		m_iFlags &= ~HUD_DRAW;
	}

	return 1;
}

// Message handler for StatusText message
// accepts two values:
//		byte: line number of status bar text 
//		string: status bar text
// this string describes how the status bar should be drawn
// a semi-regular expression:
// ( slotnum ([a..z] [%pX] [%iX])*)*
// where slotnum is an index into the Value table (see below)
// if slotnum is 0, the string is always drawn
// if StatusValue[slotnum] != 0, the following string is drawn, up to the next newline - otherwise the text is skipped up to next newline
// %pX, where X is an integer, will substitute a player name here, getting the player index from StatusValue[X]
// %iX, where X is an integer, will substitute a number here, getting the number from StatusValue[X]
int CHudStatusBar :: MsgFunc_StatusText( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int line = reader.ReadByte();

	if ( line < 0 || line >= MAX_STATUSBAR_LINES )
		return 1;

	strncpy( m_szStatusText[line], reader.ReadString(), MAX_STATUSTEXT_LENGTH );
	m_szStatusText[line][MAX_STATUSTEXT_LENGTH-1] = 0;  // ensure it's null terminated ( strncpy() won't null terminate if read string too long)

	m_iFlags |= HUD_DRAW;  // we have status text, so turn on the status bar

	m_bReparseString = TRUE;

	return 1;
}

// Message handler for StatusText message
// accepts two values:
//		byte: index into the status value array
//		short: value to store
int CHudStatusBar :: MsgFunc_StatusValue( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int index = reader.ReadByte();
	if ( index < 1 || index >= MAX_STATUSBAR_VALUES )
		return 1; // index out of range

	m_iStatusValues[index] = reader.ReadShort();
	m_iFlags |= HUD_DRAW;  // we have status text, so turn on the status bar

	m_bReparseString = TRUE;
	
	return 1;
}

```

`cl_dll/studio_util.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include <memory.h>
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "com_model.h"
#include "studio_util.h"

#ifdef VECTORIZE_SINCOS

// Test shown that this is not so effictively
#if defined(__SSE__) || defined(_M_IX86_FP)
#if defined(__SSE2__) || defined(_M_IX86_FP)
  #define USE_SSE2
 #endif
#include "sse_mathfun.h"
#endif


#if defined(__ARM_NEON__) || defined(__NEON__)
	#include "neon_mathfun.h"
#endif


void SinCosFastVector(float r1, float r2, float r3, float r4,
					  float *s0, float *s1, float *s2, float *s3,
					  float *c0, float *c1, float *c2, float *c3)
{
	v4sf rad_vector = {r1, r2, r3, r4};
	v4sf sin_vector, cos_vector;

	sincos_ps(rad_vector, &sin_vector, &cos_vector);

	*s0 = sin_vector[0];
	if(s1) *s1 = sin_vector[1];
	if(s2) *s2 = sin_vector[2];
	if(s3) *s3 = sin_vector[3];

	*c0 = cos_vector[0];
	if(s1) *c1 = cos_vector[1];
	if(s2) *c2 = cos_vector[2];
	if(s3) *c3 = cos_vector[3];
}
#endif


/*
====================
CrossProduct

====================
*/
/*
void CrossProduct (const float *v1, const float *v2, float *cross)
{
	cross[0] = v1[1]*v2[2] - v1[2]*v2[1];
	cross[1] = v1[2]*v2[0] - v1[0]*v2[2];
	cross[2] = v1[0]*v2[1] - v1[1]*v2[0];
}
*/
/*
================
ConcatTransforms

================
*/
void ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4])
{
	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] + in1[0][2] * in2[2][0];
	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] + in1[0][2] * in2[2][1];
	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +	in1[0][2] * in2[2][2];
	out[0][3] = in1[0][0] * in2[0][3] + in1[0][1] * in2[1][3] +	in1[0][2] * in2[2][3] + in1[0][3];
	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +	in1[1][2] * in2[2][0];
	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +	in1[1][2] * in2[2][1];
	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +	in1[1][2] * in2[2][2];
	out[1][3] = in1[1][0] * in2[0][3] + in1[1][1] * in2[1][3] +	in1[1][2] * in2[2][3] + in1[1][3];
	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +	in1[2][2] * in2[2][0];
	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +	in1[2][2] * in2[2][1];
	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +	in1[2][2] * in2[2][2];
	out[2][3] = in1[2][0] * in2[0][3] + in1[2][1] * in2[1][3] +	in1[2][2] * in2[2][3] + in1[2][3];
}

// angles index are not the same as ROLL, PITCH, YAW

/*
====================
AngleQuaternion

====================
*/
void AngleQuaternion( float *angles, vec4_t quaternion )
{
	float		sr, sp, sy, cr, cp, cy;

#ifdef VECTORIZE_SINCOS
	SinCosFastVector( angles[2] * 0.5,
					  angles[1] * 0.5,
					  angles[0] * 0.5, 0,
					  &sy, &sp, &sr, NULL,
					  &cy, &cp, &cr, NULL);
#else
	float		angle;

	// FIXME: rescale the inputs to 1/2 angle
	angle = angles[2] * 0.5;
	sy = sin(angle);
	cy = cos(angle);
	angle = angles[1] * 0.5;
	sp = sin(angle);
	cp = cos(angle);
	angle = angles[0] * 0.5;
	sr = sin(angle);
	cr = cos(angle);
#endif

	quaternion[0] = sr * cp * cy - cr * sp * sy; // X
	quaternion[1] = cr * sp * cy + sr * cp * sy; // Y
	quaternion[2] = cr * cp * sy - sr * sp * cy; // Z
	quaternion[3] = cr * cp * cy + sr * sp * sy; // W
}

/*
====================
QuaternionSlerp

====================
*/
void QuaternionSlerp( vec4_t p, vec4_t q, float t, vec4_t qt )
{
	int i;
	float	omega, cosom, sinom, sclp, sclq;

	// decide if one of the quaternions is backwards
	float a = 0;
	float b = 0;

	for (i = 0; i < 4; i++)
	{
		a += (p[i]-q[i])*(p[i]-q[i]);
		b += (p[i]+q[i])*(p[i]+q[i]);
	}
	if (a > b)
	{
		for (i = 0; i < 4; i++)
		{
			q[i] = -q[i];
		}
	}

	cosom = p[0]*q[0] + p[1]*q[1] + p[2]*q[2] + p[3]*q[3];

	if ((1.0 + cosom) > 0.000001)
	{
		if ((1.0 - cosom) > 0.000001)
		{
			omega = acos( cosom );
			sinom = sin( omega );
			sclp = sin( (1.0 - t)*omega) / sinom;
			sclq = sin( t*omega ) / sinom;
		}
		else
		{
			sclp = 1.0 - t;
			sclq = t;
		}
		for (i = 0; i < 4; i++) {
			qt[i] = sclp * p[i] + sclq * q[i];
		}
	}
	else
	{
		qt[0] = -q[1];
		qt[1] = q[0];
		qt[2] = -q[3];
		qt[3] = q[2];
		sclp = sin( (1.0 - t) * (0.5 * M_PI));
		sclq = sin( t * (0.5 * M_PI));
		for (i = 0; i < 3; i++)
		{
			qt[i] = sclp * p[i] + sclq * qt[i];
		}
	}
}

/*
====================
QuaternionMatrix

====================
*/
void QuaternionMatrix( vec4_t quaternion, float (*matrix)[4] )
{
	matrix[0][0] = 1.0 - 2.0 * quaternion[1] * quaternion[1] - 2.0 * quaternion[2] * quaternion[2];
	matrix[1][0] = 2.0 * quaternion[0] * quaternion[1] + 2.0 * quaternion[3] * quaternion[2];
	matrix[2][0] = 2.0 * quaternion[0] * quaternion[2] - 2.0 * quaternion[3] * quaternion[1];

	matrix[0][1] = 2.0 * quaternion[0] * quaternion[1] - 2.0 * quaternion[3] * quaternion[2];
	matrix[1][1] = 1.0 - 2.0 * quaternion[0] * quaternion[0] - 2.0 * quaternion[2] * quaternion[2];
	matrix[2][1] = 2.0 * quaternion[1] * quaternion[2] + 2.0 * quaternion[3] * quaternion[0];

	matrix[0][2] = 2.0 * quaternion[0] * quaternion[2] + 2.0 * quaternion[3] * quaternion[1];
	matrix[1][2] = 2.0 * quaternion[1] * quaternion[2] - 2.0 * quaternion[3] * quaternion[0];
	matrix[2][2] = 1.0 - 2.0 * quaternion[0] * quaternion[0] - 2.0 * quaternion[1] * quaternion[1];
}

```

`cl_dll/text_message.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// text_message.cpp
//
// implementation of CHudTextMessage class
//
// this class routes messages through titles.txt for localisation
//

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "vgui_parser.h"
#include "ctype.h"
#include "draw_util.h"

int CHudTextMessage::Init(void)
{
	HOOK_MESSAGE( gHUD.m_TextMessage, TextMsg );

	gHUD.AddHudElem( this );
	m_iFlags = 0;

	return 1;
}

// Searches through the string for any msg names (indicated by a '#')
// any found are looked up in titles.txt and the new message substituted
// the new value is pushed into dst_buffer
char *CHudTextMessage::LocaliseTextString( const char *msg, char *dst_buffer, int buffer_size )
{
	int len = buffer_size;
	char *dst = dst_buffer;
	for ( char *src = (char*)msg; *src != 0 && buffer_size > 0; buffer_size-- )
	{
		if ( *src == '#' )
		{
			// cut msg name out of string
			static char word_buf[255];
			char *wdst = word_buf, *word_start = src;
			for ( ++src ; (*src >= 'A' && *src <= 'z') || (*src >= '0' && *src <= '9'); wdst++, src++ )
			{
				*wdst = *src;
			}
			*wdst = 0;

			// lookup msg name in titles.txt
			client_textmessage_t *clmsg = TextMessageGet( word_buf );
			if ( !clmsg || !(clmsg->pMessage) )
			{
				// look also in vgui2 translations
				const char *str = Localize( word_buf );
				if( str )
				{
					strncpy(dst, str, buffer_size);
					buffer_size = 0;
					continue;
				}
				else
				{
					src = word_start;
					*dst = *src;
					dst++, src++;
					continue;
				}
			}

			if(clmsg->pMessage[0] == '#')
			{
				strncpy(dst, Localize(clmsg->pMessage+1), buffer_size);
				buffer_size = 0;
			}
			else
			{
				// copy string into message over the msg name
				for ( char *wsrc = (char*)clmsg->pMessage; *wsrc != 0; wsrc++, dst++ )
				{
					*dst = *wsrc;
				}
				*dst = 0;
			}
		}
		else
		{
			*dst = *src;
			dst++, src++;
			*dst = 0;
		}
	}

	dst_buffer[len-1] = 0; // ensure null termination
	return dst_buffer;
}

// As above, but with a local static buffer
char *CHudTextMessage::BufferedLocaliseTextString( const char *msg )
{
	static char dst_buffer[1024];
	LocaliseTextString( msg, dst_buffer, 1024 );
	return dst_buffer;
}

// Simplified version of LocaliseTextString;  assumes string is only one word
char *CHudTextMessage::LookupString( char *msg, int *msg_dest )
{
	if ( !msg )
		return (char*)"";

	// '#' character indicates this is a reference to a string in titles.txt, and not the string itself
	if ( msg[0] == '#' ) 
	{
		// this is a message name, so look up the real message
		client_textmessage_t *clmsg = TextMessageGet( msg+1 );

		if ( !clmsg || !(clmsg->pMessage) )
			return (char*)msg; // lookup failed, so return the original string
				
		if ( msg_dest )
		{
			// check to see if titles.txt info overrides msg destination
			// if clmsg->effect is less than 0, then clmsg->effect holds -1 * message_destination
			if ( clmsg->effect < 0 )  // 
				*msg_dest = -clmsg->effect;
		}

		if( clmsg->pMessage[0] == '#')
			return (char *)Localize( clmsg->pMessage + 1);

		return (char*)clmsg->pMessage;
	}
	else
	{  // nothing special about this message, so just return the same string
		return (char*)msg;
	}
}

void StripEndNewlineFromString( char *str )
{
	int s = strlen( str ) - 1;
	if ( str[s] == '\n' || str[s] == '\r' )
		str[s] = 0;
}

// converts all '\r' characters to '\n', so that the engine can deal with the properly
// returns a pointer to str
char* ConvertCRtoNL( char *str )
{
	for ( char *ch = str; *ch != 0; ch++ )
		if ( *ch == '\r' )
			*ch = '\n';
	return str;
}

// Message handler for text messages
// displays a string, looking them up from the titles.txt file, which can be localised
// parameters:
//   byte:   message direction  ( HUD_PRINTCONSOLE, HUD_PRINTNOTIFY, HUD_PRINTCENTER, HUD_PRINTTALK )
//   string: message
// optional parameters:
//   string: message parameter 1
//   string: message parameter 2
//   string: message parameter 3
//   string: message parameter 4
// any string that starts with the character '#' is a message name, and is used to look up the real message in titles.txt
// the next (optional) one to four strings are parameters for that string (which can also be message names if they begin with '#')
#define MAX_TEXTMSG_STRING 512
int CHudTextMessage::MsgFunc_TextMsg( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int msg_dest = reader.ReadByte();
	int clientIdx = -1;

	static char szBuf[6][MAX_TEXTMSG_STRING];
	char *msg_text = LookupString( reader.ReadString(), &msg_dest );
	msg_text = strncpy( szBuf[0], msg_text, MAX_TEXTMSG_STRING );
	szBuf[0][MAX_TEXTMSG_STRING - 1] = 0;

	// keep reading strings and using C format strings for substituting the strings into the localised text string
	for( int i = 1; i <= 4; i++ )
	{
		char *raw = reader.ReadString();
		
		// Don't replace the second format argument (player name)
		char *str = (i == 2) ? raw : LookupString( raw );
		const char *localized = (i == 2) ? str : Localize( str );

		strncpy( szBuf[i], localized, MAX_TEXTMSG_STRING );
		szBuf[i][MAX_TEXTMSG_STRING-1] = 0;

		// these strings are meant for substitution into the main strings, so cull the automatic end newlines
		StripEndNewlineFromString( szBuf[i] );
	}

	char *psz = szBuf[5];

	// Remove numbers after %s.
	// VALVEWHY?
	Localize_StripIndices( msg_text );

	switch ( msg_dest )
	{
	case HUD_PRINTCENTER:
	{
		snprintf( psz, MAX_TEXTMSG_STRING, msg_text, szBuf[1], szBuf[2], szBuf[3], szBuf[4] );

		ConvertCRtoNL( psz );

		int len = DrawUtils::ConsoleStringLen( psz );

		DrawUtils::DrawConsoleString( (ScreenWidth - len) / 2, ScreenHeight / 3, psz );

		CenterPrint( psz );
		break;
	}
	case HUD_PRINTNOTIFY:
		psz[0] = 1;  // mark this message to go into the notify buffer
		snprintf( psz+1, MAX_TEXTMSG_STRING - 1, msg_text, szBuf[1], szBuf[2], szBuf[3], szBuf[4] );
		ConsolePrint( ConvertCRtoNL( psz ) );
		break;

	case HUD_PRINTTALK:
		psz[0] = 2; // mark, so SayTextPrint will color it
		snprintf( psz+1, MAX_TEXTMSG_STRING-1, msg_text, szBuf[1], szBuf[2], szBuf[3], szBuf[4] );
		gHUD.m_SayText.SayTextPrint( ConvertCRtoNL( psz ), 128 );
		break;

	case HUD_PRINTCONSOLE:
		snprintf( psz, MAX_TEXTMSG_STRING, msg_text, szBuf[1], szBuf[2], szBuf[3], szBuf[4] );
		ConsolePrint( ConvertCRtoNL( psz ) );
		break;

	case HUD_PRINTRADIO:
		psz[0] = 2;
		Localize_StripIndices( szBuf[1] );
		snprintf( psz + 1, MAX_TEXTMSG_STRING-1, szBuf[1], szBuf[2], szBuf[3], szBuf[4] );

		clientIdx = atoi( szBuf[0] );
		gHUD.m_SayText.SayTextPrint( ConvertCRtoNL( psz ), 128, clientIdx );
		break;
	}

	return 1;
}

```

`cl_dll/train.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Train.cpp
//
// implementation of CHudAmmo class
//

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "draw_util.h"

int CHudTrain::Init(void)
{
	HOOK_MESSAGE( gHUD.m_Train, Train );

	m_iPos = 0;
	m_iFlags = 0;
	gHUD.AddHudElem(this);

	return 1;
}

int CHudTrain::VidInit(void)
{
	m_hSprite = 0;

	return 1;
}

int CHudTrain::Draw(float fTime)
{
	if ( !m_hSprite )
		m_hSprite = LoadSprite("sprites/%d_train.spr");

	if (m_iPos)
	{
		int r, g, b, x, y;

		DrawUtils::UnpackRGB( r, g, b, gHUD.m_iDefaultHUDColor );
		SPR_Set(m_hSprite, r, g, b );

		// This should show up to the right and part way up the armor number
		y = ScreenHeight - SPR_Height(m_hSprite,0) - gHUD.m_iFontHeight;
		x = ScreenWidth/3 + SPR_Width(m_hSprite,0)/4;

		SPR_DrawAdditive( m_iPos - 1,  x, y, NULL);

	}

	return 1;
}


int CHudTrain::MsgFunc_Train(const char *pszName,  int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	// update Train data
	m_iPos = reader.ReadByte();

	if (m_iPos)
		m_iFlags |= HUD_DRAW;
	else
		m_iFlags &= ~HUD_DRAW;

	return 1;
}

```

`cl_dll/tri.cpp`:

```cpp
//========= Copyright ? 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose:
//
// $NoKeywords: $
//=============================================================================

// Triangle rendering, if any
#include "hud.h"
#include "cl_util.h"

// Triangle rendering apis are in gEngfuncs.pTriAPI
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"
#include "triangleapi.h"
#include "rain.h"

extern int g_iWaterLevel;

FogParameters g_FogParameters;

void RenderFog()
{
	FogParameters fog;

	fog = g_FogParameters;

	if( cl_fog_density )
		fog.density = cl_fog_density->value;

	if( cl_fog_r )
		fog.color[0] = cl_fog_r->value;

	if( cl_fog_g )
		fog.color[1] = cl_fog_g->value;

	if( cl_fog_b )
		fog.color[2] = cl_fog_b->value;
	
	gEngfuncs.pTriAPI->FogParams( fog.density, fog.affectsSkyBox );
	gEngfuncs.pTriAPI->Fog( fog.color, 100.0f, 2000.0f, g_iWaterLevel <= 1 ? fog.density > 0.0f : 0 );
}

/*
=================
HUD_DrawNormalTriangles

Non-transparent triangles-- add them here
=================
*/
void DLLEXPORT HUD_DrawNormalTriangles( void )
{
	gHUD.m_Spectator.DrawOverview();
}

/*
=================
HUD_DrawTransparentTriangles

Render any triangles with transparent rendermode needs here
=================
*/
extern bool Rain_Initialized;
void DLLEXPORT HUD_DrawTransparentTriangles( void )
{
	RenderFog();

	if( Rain_Initialized )
	{
		ProcessFXObjects();
		ProcessRain();
		DrawRain();
		DrawFXObjects();
	}
}

```

`cl_dll/unicode_strtools.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include <extdll.h>
#include "unicode_strtools.h"
#ifndef _MSC_VER
#include <wctype.h>
#endif

/* <f2fc1> ../engine/unicode_strtools.cpp:23 */
//-----------------------------------------------------------------------------
// Purpose: determine if a uchar32 represents a valid Unicode code point
//-----------------------------------------------------------------------------
bool Q_IsValidUChar32(uchar32 uVal)
{
	// Values > 0x10FFFF are explicitly invalid; ditto for UTF-16 surrogate halves,
	// values ending in FFFE or FFFF, or values in the 0x00FDD0-0x00FDEF reserved range
	return (uVal < 0x110000u) && ((uVal - 0x00D800u) > 0x7FFu) && ((uVal & 0xFFFFu) < 0xFFFEu) && ((uVal - 0x00FDD0u) > 0x1Fu);
}

/* <f38f8> ../engine/unicode_strtools.cpp:50 */
int Q_UTF32ToUChar32(const uchar32 *pUTF32, uchar32 &uVal, bool &bErr)
{
	if (Q_IsValidUChar32(pUTF32[0]))
	{
		uVal = pUTF32[0];
		bErr = false;
		return 1;
	}
	else if (pUTF32[0] - 55296 >= 0x400 || (pUTF32[1] - 56320) >= 0x400)
	{
		uVal = 63;
		bErr = true;
		return 1;
	}
	else
	{
		uVal = pUTF32[1] + ((uchar32)(pUTF32[0] - 55287) << 10);
		if (Q_IsValidUChar32(uVal))
		{
			bErr = false;
		}
		else
		{
			uVal = 63;
			bErr = true;
		}
		return 2;
	}
}

/* <f2fab> ../engine/unicode_strtools.cpp:57 */
int Q_UChar32ToUTF32Len(uchar32 uVal)
{
	return (uVal > 0xFFFF) ? 2 : 1;
}

/* <f330f> ../engine/unicode_strtools.cpp:62 */
int Q_UChar32ToUTF32(uchar32 uVal, uchar32 *pUTF32)
{
	if (uVal <= 0xFFFF)
	{
		pUTF32[0] = uVal;
		return 1;
	}
	else
	{
		pUTF32[1] = (uVal & 0x3FF) | 0xDC00;
		pUTF32[0] = ((uVal - 0x10000) >> 10) | 0xD800;
		return 2;
	}
}

/* <f4344> ../engine/unicode_strtools.cpp:70 */
template<
	typename T_IN,
	typename T_OUT,
	bool UNK,
	qboolean(*IN_TO_UCHAR32)(const T_IN *pUTF8, uchar32 &uValueOut, bool &bErrorOut),
	int(UCHAR32_TO_OUT_LEN)(uchar32 uVal),
	int(UCHAR32_TO_OUT)(uchar32 uVal, T_OUT *pUTF8Out)
>
int Q_UnicodeConvertT(const T_IN *pIn, T_OUT *pOut, int nOutBytes, EStringConvertErrorPolicy ePolicy)
{
	int nOut = 0;
	if (pOut)
	{
		int nMaxOut = nOutBytes / sizeof(T_OUT) - 1;
		if (nMaxOut <= 0)
			return 0;

		while (*pIn)
		{
			bool bErr;
			uchar32 uVal;
			pIn += IN_TO_UCHAR32(pIn, uVal, bErr);
			int nOutElems = UCHAR32_TO_OUT_LEN(uVal);
			if (nOutElems + nOut > nMaxOut)
				break;
			nOut += UCHAR32_TO_OUT(uVal, &pOut[nOut]);
			if (bErr)
			{
				if (ePolicy & STRINGCONVERT_SKIP)
				{
					nOut -= nOutElems;
				}
				else if (ePolicy & STRINGCONVERT_FAIL)
				{
					pOut[0] = 0;
					return 0;
				}

			}
		}

		pOut[nOut] = 0;
	}
	else
	{
		while (*pIn)
		{
			bool bErr;
			uchar32 uVal;
			pIn += IN_TO_UCHAR32(pIn, uVal, bErr);
			int nOutElems = UCHAR32_TO_OUT_LEN(uVal);
			if (bErr)
			{
				if (ePolicy & STRINGCONVERT_SKIP)
				{
					nOut -= nOutElems;
				}
				else if (ePolicy & STRINGCONVERT_FAIL)
				{
					// pOut[0] = 0; //FIXME: pOut is always null there
					//TODO: V522 Dereferencing of the null pointer 'pOut' might take place.

					return 0;
				}

			}
		}
	}
	return (nOut + 1) * sizeof(T_OUT);
}

/* <f2fe5> ../engine/unicode_strtools.cpp:137 */
int Q_UChar32ToUTF8Len(uchar32 uVal)
{
	if (uVal <= 0x7F)
		return 1;

	if (uVal > 0x7FF)
		return (uVal > 0xFFFF) + 3;
	else
		return 2;
}

/* <f3030> ../engine/unicode_strtools.cpp:152 */
int Q_UChar32ToUTF16Len(uchar32 uVal)
{
	return (uVal > 0xFFFF) ? 2 : 1;
}

/* <f3002> ../engine/unicode_strtools.cpp:163 */
int Q_UChar32ToUTF16(uchar32 uVal, uchar16 *pUTF16Out)
{
	if (uVal <= 0xFFFF)
	{
		pUTF16Out[0] = uVal;
		return 1;
	}
	else
	{
		pUTF16Out[1] = (uVal & 0x3FF) | 0xDC00;
		pUTF16Out[0] = ((uVal - 0x10000) >> 10) | 0xD800;
		return 2;
	}
}

/* <f3192> ../engine/unicode_strtools.cpp:180 */
int Q_UChar32ToUTF8(uchar32 uVal, char *pUTF8Out)
{
	if (uVal <= 0x7F)
	{
		*pUTF8Out = uVal;
		return 1;
	}
	else if (uVal <= 0x7FF)
	{
		*pUTF8Out = (uVal >> 6) | 0xC0;
		pUTF8Out[1] = (uVal & 0x3F) | 0x80;
		return 2;
	}
	else if (uVal <= 0xFFFF)
	{
		*pUTF8Out = (uVal >> 12) | 0xE0;
		pUTF8Out[2] = (uVal & 0x3F) | 0x80;
		pUTF8Out[1] = ((uVal >> 6) & 0x3F) | 0x80;
		return 3;
	}
	else
	{
		*pUTF8Out = ((uVal >> 18) & 7) | 0xF0;
		pUTF8Out[1] = ((uVal >> 12) & 0x3F) | 0x80;
		pUTF8Out[3] = (uVal & 0x3F) | 0x80;
		pUTF8Out[2] = ((uVal >> 6) & 0x3F) | 0x80;
		return 4;
	}
}

/* <f32b4> ../engine/unicode_strtools.cpp:209 */
int Q_UTF16ToUChar32(const uchar16 *pUTF16, uchar32 &uValueOut, bool &bErrorOut)
{
	if (Q_IsValidUChar32(pUTF16[0]))
	{
		uValueOut = pUTF16[0];
		bErrorOut = false;
		return 1;
	}
	else if (pUTF16[0] - 55296 >= 0x400 || (pUTF16[1] - 56320) >= 0x400)
	{
		uValueOut = 63;
		bErrorOut = true;
		return 1;
	}
	else
	{
		uValueOut = pUTF16[1] + ((uchar32)(pUTF16[0] - 55287) << 10);
		if (Q_IsValidUChar32(uValueOut))
		{
			bErrorOut = false;
		}
		else
		{
			uValueOut = 63;
			bErrorOut = true;
		}
		return 2;
	}
}

/* <f4468> ../engine/unicode_strtools.cpp:246 */
int Q_UTF8ToUTF16(const char *pUTF8, uchar16 *pUTF16, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<char, uchar16, true, Q_UTF8ToUChar32, Q_UChar32ToUTF16Len, Q_UChar32ToUTF16>(pUTF8, pUTF16, cubDestSizeInBytes, ePolicy);
}

/* <f3822> ../engine/unicode_strtools.cpp:254 */
int Q_UTF8ToUTF32(const char *pUTF8, uchar32 *pUTF32, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<char, uchar32, true, Q_UTF8ToUChar32, Q_UChar32ToUTF32Len, Q_UChar32ToUTF32>(pUTF8, pUTF32, cubDestSizeInBytes, ePolicy);
}

/* <f3d09> ../engine/unicode_strtools.cpp:262 */
int Q_UTF16ToUTF8(const uchar16 *pUTF16, char *pUTF8, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<uchar16, char, true, Q_UTF16ToUChar32, Q_UChar32ToUTF8Len, Q_UChar32ToUTF8>(pUTF16, pUTF8, cubDestSizeInBytes, ePolicy);
}

/* <f3f0d> ../engine/unicode_strtools.cpp:270 */
int Q_UTF16ToUTF32(const uchar16 *pUTF16, uchar32 *pUTF32, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<uchar16, uchar32, true, Q_UTF16ToUChar32, Q_UChar32ToUTF32Len, Q_UChar32ToUTF32>(pUTF16, pUTF32, cubDestSizeInBytes, ePolicy);
}

/* <f38aa> ../engine/unicode_strtools.cpp:278 */
int Q_UTF32ToUTF8(const uchar32 *pUTF32, char *pUTF8, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<uchar32, char, true, Q_UTF32ToUChar32, Q_UChar32ToUTF8Len, Q_UChar32ToUTF8>(pUTF32, pUTF8, cubDestSizeInBytes, ePolicy);
}

/* <f404a> ../engine/unicode_strtools.cpp:286 */
int Q_UTF32ToUTF16(const uchar32 *pUTF32, uchar16 *pUTF16, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<uchar32, uchar16, true, Q_UTF32ToUChar32, Q_UChar32ToUTF16Len, Q_UChar32ToUTF16>(pUTF32, pUTF16, cubDestSizeInBytes, ePolicy);
}

/* <f4251> ../engine/unicode_strtools.cpp:346 */
// Decode one character from a UTF-8 encoded string. Treats 6-byte CESU-8 sequences
// as a single character, as if they were a correctly-encoded 4-byte UTF-8 sequence.
int Q_UTF8ToUChar32(const char *pUTF8_, uchar32 &uValueOut, bool &bErrorOut)
{
	const byte *pUTF8 = (const byte *)pUTF8_;

	int nBytes = 1;
	uint32 uValue = pUTF8[0];
	uint32 uMinValue = 0;

	// 0....... single byte
	if (uValue < 0x80)
		goto decodeFinishedNoCheck;

	// Expecting at least a two-byte sequence with 0xC0 <= first <= 0xF7 (110...... and 11110...)
	if ((uValue - 0xC0u) > 0x37u || (pUTF8[1] & 0xC0) != 0x80)
		goto decodeError;

	uValue = (uValue << 6) - (0xC0 << 6) + pUTF8[1] - 0x80;
	nBytes = 2;
	uMinValue = 0x80;

	// 110..... two-byte lead byte
	if (!(uValue & (0x20 << 6)))
		goto decodeFinished;

	// Expecting at least a three-byte sequence
	if ((pUTF8[2] & 0xC0) != 0x80)
		goto decodeError;

	uValue = (uValue << 6) - (0x20 << 12) + pUTF8[2] - 0x80;
	nBytes = 3;
	uMinValue = 0x800;

	// 1110.... three-byte lead byte
	if (!(uValue & (0x10 << 12)))
		goto decodeFinishedMaybeCESU8;

	// Expecting a four-byte sequence, longest permissible in UTF-8
	if ((pUTF8[3] & 0xC0) != 0x80)
		goto decodeError;

	uValue = (uValue << 6) - (0x10 << 18) + pUTF8[3] - 0x80;
	nBytes = 4;
	uMinValue = 0x10000;

	// 11110... four-byte lead byte. fall through to finished.

decodeFinished:
	if (uValue >= uMinValue && Q_IsValidUChar32(uValue))
	{
decodeFinishedNoCheck:
		uValueOut = uValue;
		bErrorOut = false;
		return nBytes;
	}
decodeError:
	uValueOut = '?';
	bErrorOut = true;
	return nBytes;

decodeFinishedMaybeCESU8:
	// Do we have a full UTF-16 surrogate pair that's been UTF-8 encoded afterwards?
	// That is, do we have 0xD800-0xDBFF followed by 0xDC00-0xDFFF? If so, decode it all.
	if ((uValue - 0xD800u) < 0x400u && pUTF8[3] == 0xED && (byte)(pUTF8[4] - 0xB0) < 0x10 && (pUTF8[5] & 0xC0) == 0x80)
	{
		uValue = 0x10000 + ((uValue - 0xD800u) << 10) + ((byte)(pUTF8[4] - 0xB0) << 6) + pUTF8[5] - 0x80;
		nBytes = 6;
		uMinValue = 0x10000;
	}
	goto decodeFinished;
}

/* <f45fd> ../engine/unicode_strtools.cpp:423 */
//-----------------------------------------------------------------------------
// Purpose: Returns false if UTF-8 string contains invalid sequences.
//-----------------------------------------------------------------------------
qboolean Q_UnicodeValidate(const char *pUTF8)
{
	bool bError = false;
	while (*pUTF8)
	{
		uchar32 uVal;
		// Our UTF-8 decoder silently fixes up 6-byte CESU-8 (improperly re-encoded UTF-16) sequences.
		// However, these are technically not valid UTF-8. So if we eat 6 bytes at once, it's an error.
		int nCharSize = Q_UTF8ToUChar32(pUTF8, uVal, bError);
		if (bError || nCharSize == 6)
			return false;
		pUTF8 += nCharSize;
	}
	return true;
}

/* <f4665> ../engine/unicode_strtools.cpp:442 */
int Q_UnicodeLength(const char *pUTF8)
{
	int nChars = 0;

	while (*pUTF8)
	{
		bool bError;
		uchar32 uVal;

		pUTF8 += Q_UTF8ToUChar32(pUTF8, uVal, bError);

		++nChars;
	}

	return nChars;
}

/* <f46d1> ../engine/unicode_strtools.cpp:459 */
char *Q_UnicodeAdvance(char *pUTF8, int nChars)
{
	uchar32 uVal = 0;
	bool bError = false;

	while (nChars > 0 && *pUTF8)
	{
		pUTF8 += Q_UTF8ToUChar32(pUTF8, uVal, bError);
		--nChars;
	}

	return pUTF8;
}

wchar_t *Q_AdvanceSpace (wchar_t *start)
{
   while (*start != 0 && iswspace (*start))
      start++;

   return start;
}

wchar_t *Q_ReadUToken (wchar_t *start, wchar_t *token, int tokenBufferSize, bool &quoted)
{
   // skip over any whitespace
   start = Q_AdvanceSpace (start);
   quoted = false;
   *token = 0;

   if (!*start)
   {
      return start;
   }

   // check to see if it's a quoted string
   if (*start == '\"')
   {
      quoted = true;
      // copy out the string until we hit an end quote
      start++;
      int count = 0;
      while (*start && *start != '\"' && count < tokenBufferSize - 1)
      {
         // check for special characters
         if (*start == '\\' && *(start + 1) == 'n')
         {
            start++;
            *token = '\n';
         }
         else if (*start == '\\' && *(start + 1) == '\"')
         {
            start++;
            *token = '\"';
         }
         else
         {
            *token = *start;
         }

         start++;
         token++;
         count++;
      }

      if (*start == '\"')
      {
         start++;
      }
   }
   else
   {
      // copy out the string until we hit a whitespace
      int count = 0;
      while (*start && !iswspace (*start) && count < tokenBufferSize - 1)
      {
         // no checking for special characters if it's not a quoted string
         *token = *start;

         start++;
         token++;
         count++;
      }
   }

   *token = 0;
   return start;
}

/* <f4737> ../engine/unicode_strtools.cpp:479 */
//-----------------------------------------------------------------------------
// Purpose: returns true if a wide character is a "mean" space; that is,
//			if it is technically a space or punctuation, but causes disruptive
//			behavior when used in names, web pages, chat windows, etc.
//
//			characters in this set are removed from the beginning and/or end of strings
//			by Q_AggressiveStripPrecedingAndTrailingWhitespaceW() 
//-----------------------------------------------------------------------------
bool Q_IsMeanSpaceW(uchar32 wch)
{
	bool bIsMean = false;

	switch (wch)
	{
	case 0x0082:	// BREAK PERMITTED HERE
	case 0x0083:	// NO BREAK PERMITTED HERE
	case 0x00A0:	// NO-BREAK SPACE
	case 0x034F:	// COMBINING GRAPHEME JOINER
	case 0x2000:	// EN QUAD
	case 0x2001:	// EM QUAD
	case 0x2002:	// EN SPACE
	case 0x2003:	// EM SPACE
	case 0x2004:	// THICK SPACE
	case 0x2005:	// MID SPACE
	case 0x2006:	// SIX SPACE
	case 0x2007:	// figure space
	case 0x2008:	// PUNCTUATION SPACE
	case 0x2009:	// THIN SPACE
	case 0x200A:	// HAIR SPACE
	case 0x200B:	// ZERO-WIDTH SPACE
	case 0x200C:	// ZERO-WIDTH NON-JOINER
	case 0x200D:	// ZERO WIDTH JOINER
	case 0x2028:	// LINE SEPARATOR
	case 0x2029:	// PARAGRAPH SEPARATOR
	case 0x202F:	// NARROW NO-BREAK SPACE
	case 0x2060:	// word joiner
	case 0xFEFF:	// ZERO-WIDTH NO BREAK SPACE
	case 0xFFFC:	// OBJECT REPLACEMENT CHARACTER
		bIsMean = true;
		break;
	}

	return bIsMean;
}

/* <f37f5> ../engine/unicode_strtools.cpp:566 */
bool Q_IsDeprecatedW(uchar16 wch)
{
	bool bIsDeprecated = false;

	switch (wch)
	{
	case 0x202A:
	case 0x202B:
	case 0x202C:
	case 0x202D:
	case 0x202E:
	case 0x206A:
	case 0x206B:
	case 0x206C:
	case 0x206D:
	case 0x206E:
	case 0x206F:
		bIsDeprecated = true;
		break;
	}

	return bIsDeprecated;
}

/* <f47bc> ../engine/unicode_strtools.cpp:600 */
//-----------------------------------------------------------------------------
// Purpose: strips trailing whitespace; returns pointer inside string just past
// any leading whitespace.
//
// bAggresive = true causes this function to also check for "mean" spaces,
// which we don't want in persona names or chat strings as they're disruptive
// to the user experience.
//-----------------------------------------------------------------------------
static uchar16 *StripWhitespaceWorker(uchar16 *pwch, int cchLength, bool *pbStrippedWhitespace)
{
	// walk backwards from the end of the string, killing any whitespace
	*pbStrippedWhitespace = false;

	uchar16 *pwchEnd = pwch + cchLength;
	while (--pwchEnd >= pwch)
	{
		if (!iswspace(*pwchEnd) && !Q_IsMeanSpaceW(*pwchEnd))
			break;

		*pwchEnd = 0;
		*pbStrippedWhitespace = true;
	}

	// walk forward in the string
	while (pwch < pwchEnd)
	{
		if (!iswspace(*pwch))
			break;

		*pbStrippedWhitespace = true;
		pwch++;
	}

	return pwch;
}

/* <f3860> ../engine/unicode_strtools.cpp:653 */
uchar16 *StripUnprintableWorker(uchar16 *pwch, bool *pbStrippedAny)
{
	uchar16 *pwchSource = pwch;
	uchar16 *pwchDest = pwch;
	*pbStrippedAny = 0;

	while (*pwchSource)
	{
		uchar16 cc = *pwchSource;
		if (*pwchSource >= 0x20u && !Q_IsDeprecatedW(cc) && cc != 0x2026)
		{
			*pwchDest = cc;
			++pwchDest;
		}
		++pwchSource;
	}

	*pwchDest = 0;
	*pbStrippedAny = pwchSource != pwchDest;
	return pwch;
}

/* <f4800> ../engine/unicode_strtools.cpp:691 */
qboolean Q_StripUnprintableAndSpace(char *pch)
{
	bool bStrippedAny;
	bool bStrippedWhitespace;
	int cch = strlen(pch);
	int cubDest = (cch + 1) * sizeof(uchar16);
	uchar16 *pwch_alloced = (uchar16 *)malloc(cubDest);
	bStrippedAny = false;
	bStrippedWhitespace = false;

	// TODO: here is using Q_UTF8ToUTF32 by DWARF
	int cwch = (unsigned int)Q_UTF8ToUTF16(pch, (uchar16 *)pwch_alloced, cubDest, _STRINGCONVERTFLAG_ASSERT) >> 1;
	uchar16 *pwch = StripUnprintableWorker(pwch_alloced, &bStrippedAny);
	pwch = StripWhitespaceWorker(pwch, cwch - 1, &bStrippedWhitespace);
	if (bStrippedWhitespace || bStrippedAny)
	{
		// TODO: here is using Q_UTF32ToUTF8 by DWARF
		Q_UTF16ToUTF8(pwch, pch, cch, STRINGCONVERT_ASSERT_REPLACE);
	}

	free(pwch_alloced);
	return bStrippedAny;
}

/* <f4a0d> ../engine/unicode_strtools.cpp:717 */
qboolean V_UTF8ToUChar32(const char *pUTF8_, uchar32 *uValueOut)
{
	bool bError = false;
	Q_UTF8ToUChar32(pUTF8_, *uValueOut, bError);
	return bError;
}

/* <f4a63> ../engine/unicode_strtools.cpp:724 */
int Q_UnicodeRepair(char *pUTF8)
{
	return Q_UnicodeConvertT<char, char, true, Q_UTF8ToUChar32, Q_UChar32ToUTF8Len, Q_UChar32ToUTF8>(pUTF8, pUTF8, 65535, STRINGCONVERT_SKIP);
}

```

`cl_dll/util.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// util.cpp
//
// implementation of class-less helper functions
//

#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#include "hud.h"
#include "cl_util.h"
#include <string.h>

#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

//vec3_t vec3_origin( 0, 0, 0 );

//double sqrt(double x);

float rsqrt( float number )
{
	int	i;
	float	x, y;

	if( number == 0.0f )
		return 0.0f;

	x = number * 0.5f;
	i = *(int *)&number;	// evil floating point bit level hacking
	i = 0x5f3759df - (i >> 1);	// what the fuck?
	y = *(float *)&i;
	y = y * (1.5f - (x * y * y));	// first iteration

	return y;
}

int HUD_GetSpriteIndexByName( const char *sz )
{
	return gHUD.GetSpriteIndex(sz);
}

HSPRITE HUD_GetSprite( int index )
{
	return gHUD.GetSprite(index);
}

wrect_t HUD_GetSpriteRect( int index )
{
	return gHUD.GetSpriteRect( index );
}

vec3_t g_ColorBlue	= { 0.6, 0.8, 1.0 };
vec3_t g_ColorRed	= { 1.0, 0.25, 0.25 };
vec3_t g_ColorGreen	= { 0.0, 1.0, 0.0 };
vec3_t g_ColorYellow= { 1.0, 0.7, 0.0 };
vec3_t g_ColorGrey	= { 0.8, 0.8, 0.8 };

float *GetClientColor( int clientIndex )
{
	switch ( g_PlayerExtraInfo[clientIndex].teamnumber )
	{
	case TEAM_CT:         return g_ColorBlue;
	case TEAM_TERRORIST:  return g_ColorRed;
	case TEAM_UNASSIGNED:
	case TEAM_SPECTATOR:  return g_ColorGrey;
	case 4:		          return g_ColorGreen;
	default:              return g_ColorGrey;
	}
}

```

`cl_dll/util_vector.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//  Vector.h
// A subset of the extdll.h in the project HL Entity DLL
//
#pragma once
#ifndef VECTOR_H
#define VECTOR_H

// Misc C-runtime library headers
#include "stdio.h"
#include "stdlib.h"
#include "math.h"

float rsqrt( float x );

// Header file containing definition of globalvars_t and entvars_t
typedef int	func_t;					//
typedef int	string_t;				// from engine's pr_comp.h;
typedef float vec_t;				// needed before including progdefs.h

//=========================================================
// 2DVector - used for many pathfinding and many other 
// operations that are treated as planar rather than 3d.
//=========================================================
class Vector2D
{
public:
	inline Vector2D(void)									{ }
	inline Vector2D(float X, float Y)						{ x = X; y = Y; }
	inline Vector2D operator+(const Vector2D& v)	const	{ return Vector2D(x+v.x, y+v.y);	}
	inline Vector2D operator-(const Vector2D& v)	const	{ return Vector2D(x-v.x, y-v.y);	}
	inline Vector2D operator*(float fl)				const	{ return Vector2D(x*fl, y*fl);	}
	inline Vector2D operator/(float fl)				const	{ return Vector2D(x/fl, y/fl);	}
	
	inline float Length(void)						const	{ return (float)sqrt(x*x + y*y );		}

	inline Vector2D Normalize ( void ) const
	{
		float flLen = rsqrt( x * x + y * y );
		if ( flLen == 0 ) return Vector2D( 0.0f, 0.0f );
		else return Vector2D( x * flLen, y * flLen );
	}

	vec_t	x, y;
};

inline float DotProduct(const Vector2D& a, const Vector2D& b) { return( a.x*b.x + a.y*b.y ); }
inline Vector2D operator*(float fl, const Vector2D& v)	{ return v * fl; }

//=========================================================
// 3D Vector
//=========================================================
class Vector						// same data-layout as engine's vec3_t,
{								//		which is a vec_t[3]
public:
	// Construction/destruction
	inline Vector(void)								{ }
	inline Vector(float X, float Y, float Z)		{ x = X; y = Y; z = Z;						}
	inline Vector(double X, double Y, double Z)		{ x = (float)X; y = (float)Y; z = (float)Z;	}
	inline Vector(int X, int Y, int Z)				{ x = (float)X; y = (float)Y; z = (float)Z;	}
	inline Vector(const Vector& v)					{ x = v.x; y = v.y; z = v.z;				} 
	inline Vector(float rgfl[3])					{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];	}

	// Operators
	inline Vector operator-(void) const				{ return Vector(-x,-y,-z);				}
	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	}
	inline int operator!=(const Vector& v) const	{ return !(*this==v);					}
	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	}
	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	}
	inline Vector operator*(float fl) const			{ return Vector(x*fl, y*fl, z*fl);		}
	inline Vector operator/(float fl) const			{ return Vector(x/fl, y/fl, z/fl);		}
	
	// Methods
	inline void CopyToArray(float* rgfl) const		{ rgfl[0] = x, rgfl[1] = y, rgfl[2] = z; }
	inline float Length(void) const					{ return (float)sqrt(x*x + y*y + z*z); }
	operator float *()								{ return &x; } // Vectors will now automatically convert to float * when needed
	operator const float *() const					{ return &x; } // Vectors will now automatically convert to float * when needed
	inline Vector Normalize(void) const
	{
		/*float flLen = Length();
		if (flLen == 0) return Vector(0,0,1); // ????
		flLen = 1 / flLen;*/

		float flLen = rsqrt( x * x + y * y + z * z );
		if( flLen == 0.0f ) return Vector( 0, 0, 1 ); // ????
		return Vector(x * flLen, y * flLen, z * flLen);
	}

	inline Vector NormalizeLength( float &len ) const
	{
		len = Length();
		if( len == 0.0f ) return Vector( 0, 0, 1 );

		return Vector( x / len, y / len, z / len );
	}

	inline Vector2D Make2D ( void ) const
	{
		return Vector2D( x, y );
	}
	inline float Length2D(void) const					{ return (float)sqrt(x*x + y*y); }
	inline bool IsNull(void) const { return !x && !y && !z; }

	// Members
	vec_t x, y, z;
};
inline Vector operator*(float fl, const Vector& v)	{ return v * fl; }
inline float DotProduct(const Vector& a, const Vector& b) { return(a.x*b.x+a.y*b.y+a.z*b.z); }
inline Vector CrossProduct(const Vector& a, const Vector& b) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

#define vec3_t Vector
#endif // VECTOR_H

```

`cl_dll/vgui_parser.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#include "port.h"

#include <string.h>
#include "wrect.h" // need for cl_dll.h
#include "cl_dll.h"
#include "vgui_parser.h"
#include "unicode_strtools.h"

#include "errno.h"
#include <ctype.h>

#include "interface.h"

// evil pasta hacks
#define uint64 uint64_bruh
#define int64 int64_bruh
#include "miniutl.h"
#include "utlhashmap.h"
#undef uint64
#undef int64

static CUtlHashMap<const char *, const char *> hashed_cmds;

char *StringCopy( const char *input )
{
	if( !input ) return NULL;

	char *out = new char[strlen( input ) + 1];
	strcpy( out, input );

	return out;
}

const char *Localize( const char *szStr )
{
	if( szStr )
	{
		char *str = strdup( szStr );
		char *p = str;

		StripEndNewlineFromString( str );

		if( *p == '#' )
			p++;

		int i = hashed_cmds.Find( p );

		free( str );

		if( i != hashed_cmds.InvalidIndex() )
			return hashed_cmds[i];
	}

	return szStr;
}

static void Dictionary_Insert( const char *key, const char *value )
{
	int i = hashed_cmds.Find( key );

	// don't allow dupes, delete older strings
	if( i != hashed_cmds.InvalidIndex() )
	{
		const char *old = hashed_cmds[i];

		hashed_cmds[i] = StringCopy( value );

		delete[] old;
	}
	else
	{
		const char *first = StringCopy( key );
		const char *second = StringCopy( value );

		hashed_cmds.Insert( first, second );
	}
}

static void Localize_AddToDictionary( const char *name, const char *lang )
{
	char filename[64], token[4096];
	char *pfile, *afile = nullptr, *pFileBuf;
	int i = 0, len;
	bool isUtf16 = false;

	snprintf( filename, sizeof( filename ), "resource/%s_%s.txt", name, lang );

	pFileBuf = reinterpret_cast<char*>( gEngfuncs.COM_LoadFile( filename, 5, &len ));

	if( !pFileBuf )
	{
		gEngfuncs.Con_Printf( "Localize_AddToDict( %s ): couldn't open file. Some strings will not be localized!.\n", filename );
		return;
	}

	// support only utf-16le
	if( pFileBuf[0] == '\xFF' && pFileBuf[1] == '\xFE' )
	{
		if( len > 3 && !pFileBuf[2] && !pFileBuf[3] )
		{
			gEngfuncs.Con_Printf( "Localize_AddToDict( %s ): couldn't parse file. UTF-32 little endian isn't supported\n", filename );
			goto error;
		}
		isUtf16 = true;
	}
	else if( pFileBuf[0] == '\xFE' && pFileBuf[1] == '\xFF' )
	{
		gEngfuncs.Con_Printf( "Localize_AddToDict( %s ): couldn't parse file. UTF-16/UTF-32 big endian isn't supported\n", filename );
		goto error;
	}

	if( isUtf16 )
	{
		int ansiLength = len + 1;
		uchar16 *autf16 = new uchar16[len/2 + 1];

		memcpy( autf16, pFileBuf + 2, len - 1 );
		autf16[len/2-1] = 0; //null terminator

		afile = new char[ansiLength]; // save original pointer, so we can free it later

		Q_UTF16ToUTF8( autf16, afile, ansiLength, STRINGCONVERT_ASSERT_REPLACE );

		delete[] autf16;
	}
	else
	{
		afile = pFileBuf;

		// strip UTF-8 BOM
		if( afile[0] == '\xEF' && afile[1] == '\xBB' && afile[2] == '\xBF')
			afile += 3;
	}

	pfile = afile;

	pfile = gEngfuncs.COM_ParseFile( pfile, token );

	if( stricmp( token, "lang" ))
	{
		gEngfuncs.Con_Printf( "Localize_AddToDict( %s ): invalid header, got %s", filename, token );
		goto error;
	}

	pfile = gEngfuncs.COM_ParseFile( pfile, token );

	if( strcmp( token, "{" ))
	{
		gEngfuncs.Con_Printf( "Localize_AddToDict( %s ): want {, got %s", filename, token );
		goto error;
	}

	pfile = gEngfuncs.COM_ParseFile( pfile, token );

	if( stricmp( token, "Language" ))
	{
		gEngfuncs.Con_Printf( "Localize_AddToDict( %s ): want Language, got %s", filename, token );
		goto error;
	}

	// skip language actual name
	pfile = gEngfuncs.COM_ParseFile( pfile, token );

	pfile = gEngfuncs.COM_ParseFile( pfile, token );

	if( stricmp( token, "Tokens" ))
	{
		gEngfuncs.Con_Printf( "Localize_AddToDict( %s ): want Tokens, got %s", filename, token );
		goto error;
	}

	pfile = gEngfuncs.COM_ParseFile( pfile, token );

	if( strcmp( token, "{" ))
	{
		gEngfuncs.Con_Printf( "Localize_AddToDict( %s ): want { after Tokens, got %s", filename, token );
		goto error;
	}

	while( (pfile = gEngfuncs.COM_ParseFile( pfile, token )))
	{
		if( !strcmp( token, "}" ))
			break;

		char szLocString[4096];
		pfile = gEngfuncs.COM_ParseFile( pfile, szLocString );

		if( !strcmp( szLocString, "}" ))
			break;

		if( pfile )
		{
			// Con_DPrintf("New token: %s %s\n", token, szLocString );
			Dictionary_Insert( token, szLocString );
			i++;
		}
	}

error:
	if( isUtf16 && afile )
		delete[] afile;

	gEngfuncs.COM_FreeFile( pFileBuf );
}

static void Localize_InitLanguage( const char *language )
{
	const char *gamedir = gEngfuncs.pfnGetGameDirectory();

	// if gamedir isn't gameui, then load standard gameui strings
	if( strcmp( gamedir, "gameui" ))
		Localize_AddToDictionary( "gameui", language );

	// if gamedir isn't valve, then load standard HL1 strings
	if( strcmp( gamedir, "valve" ))
		Localize_AddToDictionary( "valve",  language );

	// if gamedir isn't mainui, then load standard mainui strings
	if( strcmp( gamedir, "mainui" ))
		Localize_AddToDictionary( "mainui", language );

	// if gamedir is czero, also load cstrike strings
	if ( strcmp( gamedir, "czero" ) == 0 )
		Localize_AddToDictionary( "cstrike", language );
	
	// mod strings override default ones
	Localize_AddToDictionary( gamedir,  language );
}

void Localize_Init( void )
{
	gEngfuncs.pfnClientCmd( "exec mainui.cfg\n" );

	hashed_cmds.Purge();

	// always load default language translation
	Localize_InitLanguage( "english" );

	const char *language = gEngfuncs.pfnGetCvarString( "ui_language" );

	if( language[0] && strcmp( language, "english" ))
		Localize_InitLanguage( language );
}

void Localize_Free( void )
{
	FOR_EACH_HASHMAP( hashed_cmds, i )
	{
		const char *first = hashed_cmds.Key( i );
		const char *second = hashed_cmds.Element( i );

		delete[] (char*)first;
		delete[] (char*)second;
	}

	hashed_cmds.Purge();
}

void Localize_StripIndices( char *s )
{
	if ( strlen( s ) >= 3 )
	{
		for ( size_t i = 0; i < strlen( s ) - 2; i++ )
		{
			if ( s[i] == '%' && s[i + 1] == 's' && isdigit( s[i + 2] ) )
			{
				char *first = &s[i + 2];
				char *second = &s[i + 3];

				size_t len = strlen( second );

				memmove( first, second, strlen( second ) );
				first[len] = '\0'; // one character has been removed and string moved, set null terminator
			}
		}
	}
}
```

`cl_dll/view.cpp`:

```cpp
//========= Copyright ? 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose:
//
// $NoKeywords: $
//=============================================================================

// view/refresh setup functions

#include <string.h>

#include "hud.h"
#include "pm_math.h"
#include "cl_util.h"
#include "cvardef.h"
#include "usercmd.h"
#include "const.h"

#include "entity_state.h"
#include "cl_entity.h"
#include "ref_params.h"
#include "in_defs.h" // PITCH YAW ROLL
#include "pm_movevars.h"
#include "pm_shared.h"
#include "pm_defs.h"
#include "pm_debug.h"
#include "event_api.h"
#include "pmtrace.h"
#include "screenfade.h"
#include "shake.h"
#include "hltv.h"
#include "r_studioint.h"
#include "com_model.h"
#include "kbutton.h"
#include "input.h"
#include "com_weapons.h"

#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

extern float	vJumpOrigin[3];
extern float	vJumpAngles[3];


extern engine_studio_api_t IEngineStudio;

/*
The view is allowed to move slightly from it's true position for bobbing,
but if it exceeds 8 pixels linear distance (spherical, not box), the list of
entities sent from the server may not include everything in the pvs, especially
when crossing a water boudnary.
*/

extern cvar_t	*cl_forwardspeed;
extern cvar_t	*chase_active;
extern cvar_t	*scr_ofsx, *scr_ofsy, *scr_ofsz;
extern cvar_t	*cl_vsmoothing;

#define	CAM_MODE_RELAX		1
#define CAM_MODE_FOCUS		2

vec3_t v_origin, v_angles, v_cl_angles, v_sim_org, v_lastAngles, ev_punchangle;
Vector dead_viewangles( 0, 0, 0 ); // fake viewangles, for fixing
float  v_frametime, v_lastDistance;
float  v_cameraRelaxAngle	= 5.0f;
float  v_cameraFocusAngle	= 35.0f;
int	   v_cameraMode = CAM_MODE_FOCUS;
bool   v_resetCamera = 1;

cvar_t	*scr_ofsx;
cvar_t	*scr_ofsy;
cvar_t	*scr_ofsz;

cvar_t	*v_centermove;
cvar_t	*v_centerspeed;

cvar_t	*cl_bobcycle;
cvar_t	*cl_bob;
cvar_t	*cl_bobup;
cvar_t	*cl_waterdist;
cvar_t	*cl_chasedist;
cvar_t	*cl_weaponlag;
cvar_t	*cl_quakeguns;

// These cvars are not registered (so users can't cheat), so set the ->value field directly
// Register these cvars in V_Init() if needed for easy tweaking
cvar_t	v_iyaw_cycle		= {"v_iyaw_cycle", "2", 0, 2, NULL};
cvar_t	v_iroll_cycle		= {"v_iroll_cycle", "0.5", 0, 0.5, NULL};
cvar_t	v_ipitch_cycle		= {"v_ipitch_cycle", "1", 0, 1, NULL};
cvar_t	v_iyaw_level		= {"v_iyaw_level", "0.3", 0, 0.3, NULL};
cvar_t	v_iroll_level		= {"v_iroll_level", "0.1", 0, 0.1, NULL};
cvar_t	v_ipitch_level		= {"v_ipitch_level", "0.3", 0, 0.3, NULL};

float	v_idlescale;  // used by TFC for concussion grenade effect

//=============================================================================
/*
void V_NormalizeAngles( float *angles )
{
	int i;
	// Normalize angles
	for ( i = 0; i < 3; i++ )
	{
		if ( angles[i] > 180.0 )
		{
			angles[i] -= 360.0;
		}
		else if ( angles[i] < -180.0 )
		{
			angles[i] += 360.0;
		}
	}
}
*/
/*
===================
V_InterpolateAngles

Interpolate Euler angles.
FIXME:  Use Quaternions to avoid discontinuities
Frac is 0.0 to 1.0 ( i.e., should probably be clamped, but doesn't have to be )
===================
*/
/*
void V_InterpolateAngles( float *start, float *end, float *output, float frac )
{
	int i;
	float ang1, ang2;
	float d;

	V_NormalizeAngles( start );
	V_NormalizeAngles( end );

	for ( i = 0 ; i < 3 ; i++ )
	{
		ang1 = start[i];
		ang2 = end[i];

		d = ang2 - ang1;
		if ( d > 180 )
		{
			d -= 360;
		}
		else if ( d < -180 )
		{
			d += 360;
		}

		output[i] = ang1 + d * frac;
	}

	V_NormalizeAngles( output );
} */

// Quakeworld bob code, this fixes jitters in the mutliplayer since the clock (pparams->time) isn't quite linear
float V_CalcBob ( struct ref_params_s *pparams )
{
	static	double	bobtime;
	static float	bob;
	float	cycle;
	static float	lasttime;
	vec3_t	vel;


	if ( pparams->onground == -1 ||
		 pparams->time == lasttime )
	{
		// just use old value
		return bob;
	}

	lasttime = pparams->time;

	bobtime += pparams->frametime;
	cycle = bobtime - (int)( bobtime / cl_bobcycle->value ) * cl_bobcycle->value;
	cycle /= cl_bobcycle->value;

	if ( cycle < cl_bobup->value )
	{
		cycle = M_PI * cycle / cl_bobup->value;
	}
	else
	{
		cycle = M_PI + M_PI * ( cycle - cl_bobup->value )/( 1.0 - cl_bobup->value );
	}

	// bob is proportional to simulated velocity in the xy plane
	// (don't count Z, or jumping messes it up)
	VectorCopy( pparams->simvel, vel );
	vel[2] = 0;

	bob = sqrt( vel[0] * vel[0] + vel[1] * vel[1] ) * cl_bob->value;
	bob = bob * 0.3 + bob * 0.7 * sin(cycle);
	bob = min( bob, 4.0f );
	bob = max( bob, -7.0f );
	return bob;

}

/*
===============
V_CalcRoll
Used by view and sv_user
===============
*/
float V_CalcRoll (vec3_t angles, vec3_t velocity, float rollangle, float rollspeed )
{
	float   sign;
	float   side;
	float   value;
	vec3_t  forward, right, up;

	AngleVectors ( angles, forward, right, up );

	side = DotProduct (velocity, right);
	sign = side < 0 ? -1 : 1;
	side = fabs( side );

	value = rollangle;
	if (side < rollspeed)
	{
		side = side * value / rollspeed;
	}
	else
	{
		side = value;
	}
	return side * sign;
}
#if 0
typedef struct pitchdrift_s
{
	float		pitchvel;
	int			nodrift;
	float		driftmove;
	double		laststop;
} pitchdrift_t;

static pitchdrift_t pd;

void V_StartPitchDrift( void )
{
	if ( pd.laststop == gEngfuncs.GetClientTime() )
	{
		return;		// something else is keeping it from drifting
	}

	if ( pd.nodrift || !pd.pitchvel )
	{
		pd.pitchvel = v_centerspeed->value;
		pd.nodrift = 0;
		pd.driftmove = 0;
	}
}

void V_StopPitchDrift ( void )
{
	pd.laststop = gEngfuncs.GetClientTime();
	pd.nodrift = 1;
	pd.pitchvel = 0;
}

/*
===============
V_DriftPitch

Moves the client pitch angle towards idealpitch sent by the server.

If the user is adjusting pitch manually, either with lookup/lookdown,
mlook and mouse, or klook and keyboard, pitch drifting is constantly stopped.
===============
*/
void V_DriftPitch ( struct ref_params_s *pparams )
{
	float		delta, move;

	if ( gEngfuncs.IsNoClipping() || !pparams->onground || pparams->demoplayback || pparams->spectator )
	{
		pd.driftmove = 0;
		pd.pitchvel = 0;
		return;
	}

	// don't count small mouse motion
	if (pd.nodrift)
	{
		if ( fabs( pparams->cmd->forwardmove ) < cl_forwardspeed->value )
			pd.driftmove = 0;
		else
			pd.driftmove += pparams->frametime;

		if ( pd.driftmove > v_centermove->value)
		{
			V_StartPitchDrift ();
		}
		return;
	}

	delta = pparams->idealpitch - pparams->cl_viewangles[PITCH];

	if (!delta)
	{
		pd.pitchvel = 0;
		return;
	}

	move = pparams->frametime * pd.pitchvel;
	pd.pitchvel += pparams->frametime * v_centerspeed->value;

	if (delta > 0)
	{
		if (move > delta)
		{
			pd.pitchvel = 0;
			move = delta;
		}
		pparams->cl_viewangles[PITCH] += move;
	}
	else if (delta < 0)
	{
		if (move > -delta)
		{
			pd.pitchvel = 0;
			move = -delta;
		}
		pparams->cl_viewangles[PITCH] -= move;
	}
}
#endif
/*
==============================================================================
						VIEW RENDERING
==============================================================================
*/

/*
=============
V_DropPunchAngle

=============
*/
void V_DropPunchAngle ( float frametime, float *ev_punchangle )
{
	float	len;

	len = VectorNormalize ( ev_punchangle );
	len -= (10.0 + len * 0.5) * frametime;
	len = max( len, 0.0 );
	VectorScale ( ev_punchangle, len, ev_punchangle );
}


/*
==================
V_CalcGunAngle
==================
*/
void V_CalcGunAngle ( struct ref_params_s *pparams )
{
	cl_entity_t *viewent;

	viewent = gEngfuncs.GetViewModel();
	if ( !viewent )
		return;

	viewent->angles[YAW]   =  pparams->viewangles[YAW]   + pparams->crosshairangle[YAW];
	viewent->angles[PITCH] = -pparams->viewangles[PITCH] + pparams->crosshairangle[PITCH] * 0.25;
	viewent->angles[ROLL]  -= v_idlescale * sin(pparams->time*v_iroll_cycle.value) * v_iroll_level.value;

	// don't apply all of the v_ipitch to prevent normally unseen parts of viewmodel from coming into view.
	viewent->angles[PITCH] -= v_idlescale * sin(pparams->time*v_ipitch_cycle.value) * (v_ipitch_level.value * 0.5);
	viewent->angles[YAW]   -= v_idlescale * sin(pparams->time*v_iyaw_cycle.value) * v_iyaw_level.value;

	if ( !( gHUD.cl_viewbob && gHUD.cl_viewbob->value ) )
	{
		VectorCopy( viewent->angles, viewent->curstate.angles );
		VectorCopy( viewent->angles, viewent->latched.prevangles );
	}
}

/*
==============
V_AddIdle

Idle swaying
==============
*/
void V_AddIdle ( struct ref_params_s *pparams )
{
	pparams->viewangles[ROLL]  += v_idlescale * sin(pparams->time * v_iroll_cycle.value) * v_iroll_level.value;
	pparams->viewangles[PITCH] += v_idlescale * sin(pparams->time * v_ipitch_cycle.value) * v_ipitch_level.value;
	pparams->viewangles[YAW]   += v_idlescale * sin(pparams->time * v_iyaw_cycle.value) * v_iyaw_level.value;
}


/*
==============
V_CalcViewRoll

Roll is induced by movement and damage
==============
*/
void V_CalcViewRoll ( struct ref_params_s *pparams )
{
	float		side;
	cl_entity_t *viewentity;

	viewentity = gEngfuncs.GetEntityByIndex( pparams->viewentity );
	if ( !viewentity )
		return;

	side = V_CalcRoll ( viewentity->angles, pparams->simvel, pparams->movevars->rollangle, pparams->movevars->rollspeed );

	pparams->viewangles[ROLL] += side;

	if ( pparams->health <= 0 && ( pparams->viewheight[2] != 0 ) )
	{
		// only roll the view if the player is dead and the viewheight[2] is nonzero
		// this is so deadcam in multiplayer will work.
		pparams->viewangles[ROLL] = 80;	// dead view angle
		return;
	}
}

void V_SmoothInterpolateAngles( float * startAngle, float * endAngle, float * finalAngle, float degreesPerSec )
{
	float absd,frac,d,threshold;

	NormalizeAngles( startAngle );
	NormalizeAngles( endAngle );

	for ( int i = 0 ; i < 3 ; i++ )
	{
		d = endAngle[i] - startAngle[i];

		if ( d > 180.0f )
		{
			d -= 360.0f;
		}
		else if ( d < -180.0f )
		{
			d += 360.0f;
		}

		absd = fabs(d);

		if ( absd > 0.01f )
		{
			frac = degreesPerSec * v_frametime;

			threshold= degreesPerSec / 4;

			if ( absd < threshold )
			{
				float h = absd / threshold;
				h *= h;
				frac*= h;  // slow down last degrees
			}

			if ( frac >  absd )
			{
				finalAngle[i] = endAngle[i];
			}
			else
			{
				if ( d>0)
					finalAngle[i] = startAngle[i] + frac;
				else
					finalAngle[i] = startAngle[i] - frac;
			}
		}
		else
		{
			finalAngle[i] = endAngle[i];
		}

	}

	NormalizeAngles( finalAngle );
}


/*
==================
V_CalcIntermissionRefdef

==================
*/
void V_CalcIntermissionRefdef ( struct ref_params_s *pparams )
{
	cl_entity_t	*view;
	float		old;

	// view is the weapon model (only visible from inside body)
	view = gEngfuncs.GetViewModel();

	VectorCopy ( pparams->simorg, pparams->vieworg );
	VectorCopy ( pparams->cl_viewangles, pparams->viewangles );

	view->model = NULL;

	// allways idle in intermission
	old = v_idlescale;
	v_idlescale = 1;

	V_AddIdle ( pparams );

	if ( gEngfuncs.IsSpectateOnly() )
	{
		// in HLTV we must go to 'intermission' position by ourself
		VectorCopy( gHUD.m_Spectator.m_cameraOrigin, pparams->vieworg );
		VectorCopy( gHUD.m_Spectator.m_cameraAngles, pparams->viewangles );
	}

	v_idlescale = old;

	v_cl_angles = pparams->cl_viewangles;
	v_origin = pparams->vieworg;
	v_angles = pparams->viewangles;
}

#define ORIGIN_BACKUP 64
#define ORIGIN_MASK ( ORIGIN_BACKUP - 1 )

struct viewinterp_t
{
	Vector Origins[ ORIGIN_BACKUP ];
	float OriginTime[ ORIGIN_BACKUP ];

	Vector Angles[ ORIGIN_BACKUP ];
	float AngleTime[ ORIGIN_BACKUP ];

	int CurrentOrigin;
	int CurrentAngle;
};

float GetGunOffset( cl_entity_t *e )
{
	int id = HUD_GetWeapon();

	switch( id )
	{
	case WEAPON_GLOCK18:
		return -4.55f;
	case WEAPON_USP:
		return -4.64f;
	case WEAPON_P228:
		return -4.65f;
	case WEAPON_DEAGLE:
		return -4.71f;
	case WEAPON_FIVESEVEN:
		return -4.84f;
	case WEAPON_M3:
		return -5.03f;
	case WEAPON_XM1014:
		return -5.82f;
	case WEAPON_MAC10:
		return -5.05f;
	case WEAPON_TMP:
		return -6.47f;
	case WEAPON_MP5N:
		return -5.53f;
	case WEAPON_UMP45:
		return -5.53f;
	case WEAPON_P90:
		return -4.32f;
	case WEAPON_SCOUT:
		return -5.14f;
	case WEAPON_AWP:
		return -6.02f;
	case WEAPON_FAMAS:
		return -4.84f;
	case WEAPON_AUG:
		return -6.02f;
	case WEAPON_M4A1:
		return -7.0f; //-6.47f;
	case WEAPON_SG550:
		return -7.11f;
	case WEAPON_AK47:
		return -6.79f;
	case WEAPON_G3SG1:
		return -6.19f;
	case WEAPON_SG552:
		return -5.27f;
	case WEAPON_GALIL:
		return -4.78f;
	case WEAPON_M249:
		return -5.13f;
	}
	return 0;
}

void V_CalcQuakeGuns()
{
#if 1
	cl_entity_s * vm = gEngfuncs.GetViewModel();

	if(!cl_quakeguns->value)
		return;
	
	if(!vm)
		return;

	float gunoffsetr = GetGunOffset(vm);
	if(gunoffsetr == 0)
		return;

	float* org = vm->origin;

	vec3_t forward, right, up;

	gEngfuncs.pfnAngleVectors(v_angles, forward, right, up);

	org[0] += forward[0] + up[0] + right[0]*gunoffsetr;
	org[1] += forward[1] + up[1] + right[1]*gunoffsetr;
	org[2] += forward[2] + up[2] + right[2]*gunoffsetr;
#endif
}


//==========================
// V_CalcViewModelLag
//==========================
void V_CalcViewModelLag( ref_params_t *pparams, Vector &origin, Vector &angles )
{
	static Vector m_vecLastFacing;

	if( cl_weaponlag->value <= 0.0f )
		return;

	// Calculate our drift
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if( pparams->frametime != 0.0f )	// not in paused
	{
		Vector vDifference = forward - m_vecLastFacing;

		float flSpeed = 5.0f;

		// If we start to lag too far behind, we'll increase the "catch up" speed.
		// Solves the problem with fast cl_yawspeed, m_yaw or joysticks rotating quickly.
		// The old code would slam lastfacing with origin causing the viewmodel to pop to a new position
		float flDiff = vDifference.Length();
		if( flDiff > cl_weaponlag->value )
			flSpeed *= flDiff / cl_weaponlag->value;

		// FIXME:  Needs to be predictable?
		m_vecLastFacing = m_vecLastFacing + vDifference * ( flSpeed * pparams->frametime );
		// Make sure it doesn't grow out of control!!!
		m_vecLastFacing = m_vecLastFacing.Normalize();
		origin = origin + flSpeed * -vDifference;
	}

	// this just breaks centered weapons on pitch changing
	if( !cl_quakeguns->value )
	{
		AngleVectors( v_angles, forward, right, up );

		float pitch = v_angles[PITCH];

		if( pitch > 180.0f )
			pitch -= 360.0f;
		else if( pitch < -180.0f )
			pitch += 360.0f;

		pitch = -pitch;

		// FIXME: These are the old settings that caused too many exposed polys on some models
		origin = origin + forward * ( pitch * 0.035f )
						+ right   * ( pitch * 0.03f  )
						+ up      * ( pitch * 0.02f  );

	}
}

/*
==================
V_CalcRefdef

==================
*/
void V_CalcNormalRefdef ( struct ref_params_s *pparams )
{
	cl_entity_t		*ent, *view;
	int				i;
	vec3_t			angles;
	float			bob, waterOffset;
	static viewinterp_t		ViewInterp;

	static float oldz = 0;
	static float lasttime;

	vec3_t camAngles, camForward, camRight, camUp;
	cl_entity_t *pwater;

	if ( gEngfuncs.IsSpectateOnly() )
	{
		ent = gEngfuncs.GetEntityByIndex( g_iUser2 );
	}
	else
	{
		// ent is the player model ( visible when out of body )
		ent = gEngfuncs.GetLocalPlayer();
	}

	// view is the weapon model (only visible from inside body)
	view = gEngfuncs.GetViewModel();

	// transform the view offset by the model's matrix to get the offset from
	// model origin for the view
	bob = V_CalcBob ( pparams );

	// refresh position
	VectorCopy ( pparams->simorg, pparams->vieworg );
	pparams->vieworg[2] += ( bob );
	VectorAdd( pparams->vieworg, pparams->viewheight, pparams->vieworg );

	if( pparams->health <= 0 )
	{
		VectorCopy( dead_viewangles, pparams->viewangles );
	}
	else
	{
		VectorCopy ( pparams->cl_viewangles, pparams->viewangles );
	}

	gEngfuncs.V_CalcShake();
	gEngfuncs.V_ApplyShake( pparams->vieworg, pparams->viewangles, 1.0 );

	// never let view origin sit exactly on a node line, because a water plane can
	// disappear when viewed with the eye exactly on it.
	// FIXME, we send origin at 1/128 now, change this?
	// the server protocol only specifies to 1/16 pixel, so add 1/32 in each axis

	pparams->vieworg[0] += 1.0/32;
	pparams->vieworg[1] += 1.0/32;
	pparams->vieworg[2] += 1.0/32;

	// Check for problems around water, move the viewer artificially if necessary
	// -- this prevents drawing errors in GL due to waves

	waterOffset = 0;
	if ( pparams->waterlevel >= 2 )
	{
		int		i, contents, waterDist, waterEntity;
		vec3_t	point;
		waterDist = cl_waterdist->value;

		if ( pparams->hardware )
		{
			waterEntity = gEngfuncs.PM_WaterEntity( pparams->simorg );
			if ( waterEntity >= 0 && waterEntity < pparams->max_entities )
			{
				pwater = gEngfuncs.GetEntityByIndex( waterEntity );
				if ( pwater && ( pwater->model != NULL ) )
				{
					waterDist += ( pwater->curstate.scale * 16 );	// Add in wave height
				}
			}
		}
		else
		{
			waterEntity = 0;	// Don't need this in software
		}

		VectorCopy( pparams->vieworg, point );

		// Eyes are above water, make sure we're above the waves
		if ( pparams->waterlevel == 2 )
		{
			point[2] -= waterDist;
			for ( i = 0; i < waterDist; i++ )
			{
				contents = gEngfuncs.PM_PointContents( point, NULL );
				if ( contents > CONTENTS_WATER )
					break;
				point[2] += 1;
			}
			waterOffset = (point[2] + waterDist) - pparams->vieworg[2];
		}
		else
		{
			// eyes are under water.  Make sure we're far enough under
			point[2] += waterDist;

			for ( i = 0; i < waterDist; i++ )
			{
				contents = gEngfuncs.PM_PointContents( point, NULL );
				if ( contents <= CONTENTS_WATER )
					break;
				point[2] -= 1;
			}
			waterOffset = (point[2] - waterDist) - pparams->vieworg[2];
		}
	}

	pparams->vieworg[2] += waterOffset;

	V_CalcViewRoll ( pparams );

	V_AddIdle ( pparams );

	// offsets
	if( pparams->health <= 0 )
	{
		VectorCopy( dead_viewangles, angles );
	}
	else
	{
		VectorCopy( pparams->cl_viewangles, angles );
	}

	AngleVectors ( angles, pparams->forward, pparams->right, pparams->up );

	// don't allow cheats in multiplayer
	if ( pparams->maxclients <= 1 )
	{
		for ( i=0 ; i<3 ; i++ )
		{
			pparams->vieworg[i] += scr_ofsx->value*pparams->forward[i] + scr_ofsy->value*pparams->right[i] + scr_ofsz->value*pparams->up[i];
		}
	}

	// Treating cam_ofs[2] as the distance
	/*if( CL_IsThirdPerson() )
	{
		vec3_t ofs;

		ofs[0] = ofs[1] = ofs[2] = 0.0;

		CL_CameraOffset( (float *)&ofs );

		VectorCopy( ofs, camAngles );
		camAngles[ ROLL ]	= 0;

		AngleVectors( camAngles, camForward, camRight, camUp );

		for ( i = 0; i < 3; i++ )
		{
			pparams->vieworg[ i ] += -ofs[2] * camForward[ i ];
		}
	}*/

	// Give gun our viewangles
	if( pparams->health <= 0 )
	{
		VectorCopy( dead_viewangles, view->angles );
	}
	else
	{
		VectorCopy ( pparams->cl_viewangles, view->angles );
	}

	// set up gun position
	V_CalcGunAngle ( pparams );

	// Use predicted origin as view origin.
	VectorCopy ( pparams->simorg, view->origin );
	view->origin[2] += ( waterOffset );
	VectorAdd( view->origin, pparams->viewheight, view->origin );

	// Let the viewmodel shake at about 10% of the amplitude
	gEngfuncs.V_ApplyShake( view->origin, view->angles, 0.9 );

	for ( i = 0; i < 3; i++ )
	{
		view->origin[ i ] += bob * 0.4 * pparams->forward[ i ];
	}
	view->origin[2] += bob;

	// throw in a little tilt.
	view->angles[YAW]   -= bob * 0.5;
	view->angles[ROLL]  -= bob * 1;
	view->angles[PITCH] -= bob * 0.3;

	// pushing the view origin down off of the same X/Z plane as the ent's origin will give the
	// gun a very nice 'shifting' effect when the player looks up/down. If there is a problem
	// with view model distortion, this may be a cause. (SJB).
	view->origin[2] -= 1;

	// fudge position around to keep amount of weapon visible
	// roughly equal with different FOV
	if (pparams->viewsize == 110)
	{
		view->origin[2] += 1;
	}
	else if (pparams->viewsize == 100)
	{
		view->origin[2] += 2;
	}
	else if (pparams->viewsize == 90)
	{
		view->origin[2] += 1;
	}
	else if (pparams->viewsize == 80)
	{
		view->origin[2] += 0.5;
	}

	// Don't allow viewmodel, if we are in sniper scope
	if( gHUD.m_iFOV <= 40 )
		view->model = NULL;

	// Add in the punchangle, if any
	pparams->viewangles = pparams->viewangles + pparams->punchangle;

#if 0
	// Include client side punch, too
	VectorAdd ( pparams->viewangles, (float *)&ev_punchangle, pparams->viewangles);

	V_DropPunchAngle ( pparams->frametime, (float *)&ev_punchangle );
#endif
	// smooth out stair step ups
#if 1
	if ( !pparams->smoothing && pparams->onground && pparams->simorg[2] - oldz > 0)
	{
		float steptime;

		steptime = pparams->time - lasttime;
		if (steptime < 0)
			//FIXME		I_Error ("steptime < 0");
			steptime = 0;

		oldz += steptime * 150;
		if (oldz > pparams->simorg[2])
			oldz = pparams->simorg[2];
		if (pparams->simorg[2] - oldz > 18)
			oldz = pparams->simorg[2]- 18;
		pparams->vieworg[2] += oldz - pparams->simorg[2];
		view->origin[2] += oldz - pparams->simorg[2];
	}
	else
	{
		oldz = pparams->simorg[2];
	}
#endif

	static Vector lastorg;
	Vector delta;

	delta = pparams->simorg - lastorg;

	if( delta.x || delta.y || delta.z )
	{
		ViewInterp.Origins[ ViewInterp.CurrentOrigin & ORIGIN_MASK ] = pparams->simorg;
		ViewInterp.OriginTime[ ViewInterp.CurrentOrigin & ORIGIN_MASK ] = pparams->time;
		ViewInterp.CurrentOrigin++;

		lastorg = pparams->simorg;
	}

	V_CalcQuakeGuns();
	V_CalcViewModelLag( pparams, view->origin, view->angles );

	// Smooth out whole view in multiplayer when on trains, lifts
	if ( cl_vsmoothing && cl_vsmoothing->value && ( pparams->smoothing && ( pparams->maxclients > 1 ) ) )
	{
		int foundidx;
		int i;
		float t;

		if ( cl_vsmoothing->value < 0.0 )
			gEngfuncs.Cvar_SetValue( "cl_vsmoothing", 0.0 );

		t = pparams->time - cl_vsmoothing->value;

		for ( i = 1; i < ORIGIN_MASK; i++ )
		{
			foundidx = ViewInterp.CurrentOrigin - 1 - i;
			if ( ViewInterp.OriginTime[ foundidx & ORIGIN_MASK ] <= t )
				break;
		}

		if ( i < ORIGIN_MASK && ViewInterp.OriginTime[ foundidx & ORIGIN_MASK ] != 0.0 )
		{
			// Interpolate
			vec3_t delta;
			double frac;
			double dt;
			vec3_t neworg;

			dt = ViewInterp.OriginTime[ (foundidx + 1) & ORIGIN_MASK ] - ViewInterp.OriginTime[ foundidx & ORIGIN_MASK ];
			if ( dt > 0.0 )
			{
				frac = ( t - ViewInterp.OriginTime[ foundidx & ORIGIN_MASK] ) / dt;
				frac = min( 1.0, frac );
				VectorSubtract( ViewInterp.Origins[ ( foundidx + 1 ) & ORIGIN_MASK ], ViewInterp.Origins[ foundidx & ORIGIN_MASK ], delta );
				VectorMA( ViewInterp.Origins[ foundidx & ORIGIN_MASK ], frac, delta, neworg );

				// Don't interpolate large changes
				if ( Length( delta ) < 64 )
				{
					VectorSubtract( neworg, pparams->simorg, delta );

					VectorAdd( pparams->simorg, delta, pparams->simorg );
					VectorAdd( pparams->vieworg, delta, pparams->vieworg );
					VectorAdd( view->origin, delta, view->origin );

				}
			}
		}
	}


	// Store off v_angles before munging for third person
	v_angles = pparams->viewangles;
	v_lastAngles = pparams->viewangles;
	//	v_cl_angles = pparams->cl_viewangles;	// keep old user mouse angles !
	if ( CL_IsThirdPerson() )
	{
		VectorCopy( camAngles, pparams->viewangles);
		float pitch = camAngles[ 0 ];

		// Normalize angles
		if ( pitch > 180 )
			pitch -= 360.0;
		else if ( pitch < -180 )
			pitch += 360;

		// Player pitch is inverted
		pitch /= -3.0;

		// Slam local player's pitch value
		ent->angles[ 0 ] = pitch;
		ent->curstate.angles[ 0 ] = pitch;
		ent->prevstate.angles[ 0 ] = pitch;
		ent->latched.prevangles[ 0 ] = pitch;
	}

	// override all previous settings if the viewent isn't the client
	if ( pparams->viewentity > pparams->maxclients )
	{
		cl_entity_t *viewentity;
		viewentity = gEngfuncs.GetEntityByIndex( pparams->viewentity );
		if ( viewentity )
		{
			VectorCopy( viewentity->origin, pparams->vieworg );
			VectorCopy( viewentity->angles, pparams->viewangles );

			// Store off overridden viewangles
			v_angles = pparams->viewangles;
		}
	}

	if ( gHUD.cl_viewbob && gHUD.cl_viewbob->value )
	{
		VectorCopy( view->origin, view->curstate.origin );
		VectorCopy( view->origin, view->latched.prevorigin );
		VectorCopy( view->angles, view->curstate.angles );
		VectorCopy( view->angles, view->latched.prevangles );
	}

	lasttime = pparams->time;

	v_origin = pparams->vieworg;
}

// Get the origin of the Observer based around the target's position and angles
void V_GetChaseOrigin( float * angles, float * origin, float distance, float * returnvec )
{
	Vector vecStart, vecEnd;
	pmtrace_t *trace;
	int maxLoops = 8;

	Vector forward, right, up;

	// trace back from the target using the player's view angles
	AngleVectors( angles, forward, right, up );
	forward = -forward;

	vecStart = origin;
	vecEnd = vecStart + forward * distance;

	int ignoreent = -1;	// first, ignore no entity
	cl_entity_t *ent = NULL;

	while( maxLoops > 0 )
	{
		trace = gEngfuncs.PM_TraceLine( vecStart, vecEnd, PM_TRACELINE_PHYSENTSONLY, 2, ignoreent );

		if( trace->ent <= 0 )
			break; // we hit the world or nothing, stop trace

		ent = gEngfuncs.GetEntityByIndex( PM_GetPhysEntInfo( trace->ent ));
		if( ent == NULL ) break;

		// hit non-player solid BSP, stop here
		if( ent->curstate.solid == SOLID_BSP && !ent->player )
			break;

		// if close enought to end pos, stop, otherwise continue trace
		if( trace->fraction < 1.0f )
		{
			break;
		}
		else
		{
			ignoreent = trace->ent;	// ignore last hit entity
			vecStart = trace->endpos;
		}
		maxLoops--;
	}

	VectorMA( trace->endpos, 8, trace->plane.normal, returnvec );
	v_lastDistance = (trace->endpos - Vector(origin)).Length();	// real distance without offset
}

void V_GetDeathCam(cl_entity_t * ent1, cl_entity_t * ent2, float * angle, float * origin)
{
	float newAngle[3];
	float newOrigin[3];
	static vec3_t nonDestructedOrigin;
	float distance = 168.0f;

	v_lastDistance += v_frametime * 96.0f;	// move unit per seconds back

	if ( v_resetCamera )
		v_lastDistance = 64.0f;

	if ( distance > v_lastDistance )
		distance = v_lastDistance;

	if (ent1->origin.x == 0 && ent1->origin.y == 0 && ent1->origin.z == 0)
		nonDestructedOrigin.CopyToArray(newOrigin);
	else
	{
		nonDestructedOrigin = ent1->origin;
		VectorCopy(ent1->origin, newOrigin);
	}

	if ( ent1->player )
		newOrigin[2]+= 17; // head level of living player

	// get new angle towards second target
	if ( ent2 )
	{
		VectorSubtract(ent2->origin, nonDestructedOrigin, newAngle);
		VectorAngles( newAngle, newAngle );
		newAngle[0] = -newAngle[0];
	}
	else
	{
		// if no second target is given, look down to dead player
		newAngle[0] = 90.0f;
		newAngle[1] = 0.0f;
		newAngle[2] = 0;
	}

	// and smooth view
	V_SmoothInterpolateAngles( v_lastAngles, newAngle, angle, 120.0f );

	V_GetChaseOrigin( angle, newOrigin, distance, origin );

	VectorCopy(angle, v_lastAngles);
}

void V_GetSingleTargetCam(cl_entity_t * ent1, float * angle, float * origin)
{
	float newAngle[3]; float newOrigin[3];

	int flags 	   = gHUD.m_Spectator.m_iObserverFlags;

	// see is target is a dead player
	bool deadPlayer = ent1->player && (ent1->curstate.solid == SOLID_NOT);

	float dfactor   = ( flags & DRC_FLAG_DRAMATIC )? -1.0f : 1.0f;

	float distance = 112.0f + ( 16.0f * dfactor ); // get close if dramatic;

	// go away in final scenes or if player just died
	if ( flags & DRC_FLAG_FINAL )
		distance*=2.0f;
	else if ( deadPlayer )
		distance*=1.5f;

	// let v_lastDistance float smoothly away
	v_lastDistance+= v_frametime * 32.0f;	// move unit per seconds back

	if ( distance > v_lastDistance )
		distance = v_lastDistance;

	VectorCopy(ent1->origin, newOrigin);

	if ( ent1->player )
	{
		if ( deadPlayer )
			newOrigin[2]+= 2;	//laying on ground
		else
			newOrigin[2]+= 17; // head level of living player

	}
	else
		newOrigin[2]+= 8;	// object, tricky, must be above bomb in CS

	// we have no second target, choose view direction based on
	// show front of primary target
	VectorCopy(ent1->angles, newAngle);

	// show dead players from front, normal players back
	if ( flags & DRC_FLAG_FACEPLAYER )
		newAngle[1]+= 180.0f;


	newAngle[0]+= 12.5f * dfactor; // lower angle if dramatic

	// if final scene (bomb), show from real high pos
	if ( flags & DRC_FLAG_FINAL )
		newAngle[0] = 22.5f;

	// choose side of object/player
	if ( flags & DRC_FLAG_SIDE )
		newAngle[1]+=22.5f;
	else
		newAngle[1]-=22.5f;

	V_SmoothInterpolateAngles( v_lastAngles, newAngle, angle, 120.0f );

	// HACK, if player is dead don't clip against his dead body, can't check this
	V_GetChaseOrigin( angle, newOrigin, distance, origin );
}

float MaxAngleBetweenAngles(  float * a1, float * a2 )
{
	float d, maxd = 0.0f;

	NormalizeAngles( a1 );
	NormalizeAngles( a2 );

	for ( int i = 0 ; i < 3 ; i++ )
	{
		d = a2[i] - a1[i];
		if ( d > 180 )
		{
			d -= 360;
		}
		else if ( d < -180 )
		{
			d += 360;
		}

		d = fabs(d);

		if ( d > maxd )
			maxd=d;
	}

	return maxd;
}

void V_GetDoubleTargetsCam(cl_entity_t	 * ent1, cl_entity_t * ent2,float * angle, float * origin)
{
	float newAngle[3]; float newOrigin[3]; float tempVec[3];

	int flags 	   = gHUD.m_Spectator.m_iObserverFlags;

	float dfactor   = ( flags & DRC_FLAG_DRAMATIC )? -1.0f : 1.0f;

	float distance = 112.0f + ( 16.0f * dfactor ); // get close if dramatic;

	// go away in final scenes or if player just died
	if ( flags & DRC_FLAG_FINAL )
		distance*=2.0f;

	// let v_lastDistance float smoothly away
	v_lastDistance+= v_frametime * 32.0f;	// move unit per seconds back

	if ( distance > v_lastDistance )
		distance = v_lastDistance;

	VectorCopy(ent1->origin, newOrigin);

	if ( ent1->player )
		newOrigin[2]+= 17; // head level of living player
	else
		newOrigin[2]+= 8;	// object, tricky, must be above bomb in CS

	// get new angle towards second target
	VectorSubtract( ent2->origin, ent1->origin, newAngle );

	VectorAngles( newAngle, newAngle );
	newAngle[0] = -newAngle[0];

	// set angle different in Dramtaic scenes
	newAngle[0]+= 12.5f * dfactor; // lower angle if dramatic

	if ( flags & DRC_FLAG_SIDE )
		newAngle[1]+=22.5f;
	else
		newAngle[1]-=22.5f;

	float d = MaxAngleBetweenAngles( v_lastAngles, newAngle );

	if ( ( d < v_cameraFocusAngle) && ( v_cameraMode == CAM_MODE_RELAX ) )
	{
		// difference is to small and we are in relax camera mode, keep viewangles
		VectorCopy(v_lastAngles, newAngle );
	}
	else if ( (d < v_cameraRelaxAngle) && (v_cameraMode == CAM_MODE_FOCUS) )
	{
		// we catched up with our target, relax again
		v_cameraMode = CAM_MODE_RELAX;
	}
	else
	{
		// target move too far away, focus camera again
		v_cameraMode = CAM_MODE_FOCUS;
	}

	// and smooth view, if not a scene cut
	if ( v_resetCamera || (v_cameraMode == CAM_MODE_RELAX) )
	{
		VectorCopy( newAngle, angle );
	}
	else
	{
		V_SmoothInterpolateAngles( v_lastAngles, newAngle, angle, 180.0f );
	}

	V_GetChaseOrigin( newAngle, newOrigin, distance, origin );

	// move position up, if very close at target
	if ( v_lastDistance < 64.0f )
		origin[2]+= 16.0f*( 1.0f - (v_lastDistance / 64.0f ) );

	// calculate angle to second target
	VectorSubtract( ent2->origin, origin, tempVec );
	VectorAngles( tempVec, tempVec );
	tempVec[0] = -tempVec[0];

	/* take middle between two viewangles
	InterpolateAngles( newAngle, tempVec, newAngle, 0.5f); */



}

void V_GetDirectedChasePosition(cl_entity_t	 * ent1, cl_entity_t * ent2,float * angle, float * origin)
{

	if ( v_resetCamera )
	{
		v_lastDistance = 4096.0f;
		// v_cameraMode = CAM_MODE_FOCUS;
	}

	if ( ( ent2 == (cl_entity_t*)0xFFFFFFFF ) || ( ent1->player && (ent1->curstate.solid == SOLID_NOT) ) )
	{
		// we have no second target or player just died
		V_GetSingleTargetCam(ent1, angle, origin);
	}
	else if ( ent2 )
	{
		// keep both target in view
		V_GetDoubleTargetsCam( ent1, ent2, angle, origin );
	}
	else
	{
		// second target disappeard somehow (dead)

		// keep last good viewangle
		float newOrigin[3];

		int flags 	   = gHUD.m_Spectator.m_iObserverFlags;

		float dfactor   = ( flags & DRC_FLAG_DRAMATIC )? -1.0f : 1.0f;

		float distance = 112.0f + ( 16.0f * dfactor ); // get close if dramatic;

		// go away in final scenes or if player just died
		if ( flags & DRC_FLAG_FINAL )
			distance*=2.0f;

		// let v_lastDistance float smoothly away
		v_lastDistance+= v_frametime * 32.0f;	// move unit per seconds back

		if ( distance > v_lastDistance )
			distance = v_lastDistance;

		VectorCopy(ent1->origin, newOrigin);

		if ( ent1->player )
			newOrigin[2]+= 17; // head level of living player
		else
			newOrigin[2]+= 8;	// object, tricky, must be above bomb in CS

		V_GetChaseOrigin( angle, newOrigin, distance, origin );
	}

	VectorCopy(angle, v_lastAngles);
}

void V_GetChasePos(int target, float * cl_angles, float * origin, float * angles)
{
	cl_entity_t	 *	ent = NULL;
	cl_entity_t *local = gEngfuncs.GetLocalPlayer();

	if ( target )
	{
		ent = gEngfuncs.GetEntityByIndex( target );
	}

	if (!ent)
	{
		// just copy a save in-map position
		VectorCopy ( vJumpAngles, angles );
		VectorCopy ( vJumpOrigin, origin );
		return;
	}


	if( ent->index == local->index )
	{
		if ( g_iUser3 && g_iUser3 != 1 )
			V_GetDeathCam( ent, gEngfuncs.GetEntityByIndex( g_iUser3 ),
						   angles, origin );
		else
			V_GetDeathCam( ent, NULL,
						   angles, origin );
	}
	else if ( gHUD.m_Spectator.m_autoDirector->value )
	{
		if ( g_iUser3 && g_iUser3 != 1 )
			V_GetDirectedChasePosition( ent, gEngfuncs.GetEntityByIndex( g_iUser3 ),
										angles, origin );
		else
			V_GetDirectedChasePosition( ent, (cl_entity_t*)0xFFFFFFFF,
										angles, origin );
	}
	else
	{
		if ( cl_angles == NULL )	// no mouse angles given, use entity angles ( locked mode )
		{
			VectorCopy ( ent->angles, angles);
			angles[0]*=-1;
		}
		else
			VectorCopy ( cl_angles, angles);


		VectorCopy ( ent->origin, origin);

		origin[2]+= 28; // DEFAULT_VIEWHEIGHT - some offset

		V_GetChaseOrigin( angles, origin, cl_chasedist->value, origin );
	}

	v_resetCamera = false;
}

void V_ResetChaseCam()
{
	v_resetCamera = true;
}


void V_GetInEyePos(int target, float * origin, float * angles )
{
	if ( !target)
	{
		// just copy a save in-map position
		VectorCopy ( vJumpAngles, angles );
		VectorCopy ( vJumpOrigin, origin );
		return;
	};


	cl_entity_t	 * ent = gEngfuncs.GetEntityByIndex( target );

	if ( !ent )
		return;

	VectorCopy ( ent->origin, origin );
	VectorCopy ( ent->angles, angles );

	angles[PITCH]*=-3.0f;	// see CL_ProcessEntityUpdate()

	if ( ent->curstate.solid == SOLID_NOT )
	{
		angles[ROLL] = 80;	// dead view angle
		origin[2]+= -8 ; // PM_DEAD_VIEWHEIGHT
	}
	else if (ent->curstate.usehull == 1 )
		origin[2]+= 12; // VEC_DUCK_VIEW;
	else
		// exacty eye position can't be calculated since it depends on
		// client values like cl_bobcycle, this offset matches the default values
		origin[2]+= 28; // DEFAULT_VIEWHEIGHT
}

void V_GetMapFreePosition( float * cl_angles, float * origin, float * angles )
{
	vec3_t forward;
	vec3_t zScaledTarget;

	VectorCopy(cl_angles, angles);

	// modify angles since we don't wanna see map's bottom
	angles[0] = 51.25f + 38.75f*(angles[0]/90.0f);

	zScaledTarget[0] = gHUD.m_Spectator.m_mapOrigin[0];
	zScaledTarget[1] = gHUD.m_Spectator.m_mapOrigin[1];
	zScaledTarget[2] = gHUD.m_Spectator.m_mapOrigin[2] * (( 90.0f - angles[0] ) / 90.0f );


	AngleVectors(angles, forward, NULL, NULL);

	VectorNormalize(forward);

	VectorMA(zScaledTarget, -( 4096.0f / gHUD.m_Spectator.m_mapZoom ), forward , origin);
}

void V_GetMapChasePosition(int target, float * cl_angles, float * origin, float * angles)
{
	vec3_t forward;

	if ( target )
	{
		cl_entity_t	 *	ent = gEngfuncs.GetEntityByIndex( target );

		if ( gHUD.m_Spectator.m_autoDirector->value )
		{
			// this is done to get the angles made by director mode
			V_GetChasePos(target, cl_angles, origin, angles);
			VectorCopy(ent->origin, origin);

			// keep fix chase angle horizontal
			angles[0] = 45.0f;
		}
		else
		{
			VectorCopy(cl_angles, angles);
			VectorCopy(ent->origin, origin);

			// modify angles since we don't wanna see map's bottom
			angles[0] = 51.25f + 38.75f*(angles[0]/90.0f);
		}
	}
	else
	{
		// keep out roaming position, but modify angles
		VectorCopy(cl_angles, angles);
		angles[0] = 51.25f + 38.75f*(angles[0]/90.0f);
	}

	origin[2] *= (( 90.0f - angles[0] ) / 90.0f );
	angles[2] = 0.0f;	// don't roll angle (if chased player is dead)

	AngleVectors(angles, forward, NULL, NULL);

	VectorNormalize(forward);

	VectorMA(origin, -1536, forward, origin);
}

int V_FindViewModelByWeaponModel( int iWeaponIndex )
{
	model_t *pWeaponModel = IEngineStudio.GetModelByIndex( iWeaponIndex );
	if ( pWeaponModel )
	{
		static char szViewModelName[MAX_MODEL_NAME];
		strncpy( szViewModelName, pWeaponModel->name, sizeof( szViewModelName ) );

		char *szSub = strstr( szViewModelName, "/p_" );
		if( szSub )
		{
			// szSub pointer is a part of szViewModelName
			szSub[1] = 'v';
			return gEngfuncs.pEventAPI->EV_FindModelIndex(szViewModelName);
		}
		return 0;
	}
	else
		return 0;

}


/*
==================
V_CalcSpectatorRefdef

==================
*/
void V_CalcSpectatorRefdef ( struct ref_params_s * pparams )
{
	static vec3_t			velocity ( 0.0f, 0.0f, 0.0f);

	static int lastWeaponModelIndex = 0;
	static int lastViewModelIndex = 0;

	cl_entity_t	 * ent = gEngfuncs.GetEntityByIndex( g_iUser2 );

	pparams->onlyClientDraw = false;

	// refresh position
	VectorCopy ( pparams->simorg, v_sim_org );

	// get old values
	VectorCopy ( pparams->cl_viewangles, v_cl_angles );
	VectorCopy ( pparams->viewangles, v_angles );
	VectorCopy ( pparams->vieworg, v_origin );

	if ( ( g_iUser1 == OBS_IN_EYE || gHUD.m_Spectator.m_pip->value == INSET_IN_EYE ) && ent )
	{
		// calculate player velocity
		float timeDiff = ent->curstate.msg_time - ent->prevstate.msg_time;

		if ( timeDiff > 0 )
		{
			vec3_t distance;
			VectorSubtract(ent->prevstate.origin, ent->curstate.origin, distance);
			VectorScale(distance, 1/timeDiff, distance );

			velocity[0] = velocity[0]*0.9f + distance[0]*0.1f;
			velocity[1] = velocity[1]*0.9f + distance[1]*0.1f;
			velocity[2] = velocity[2]*0.9f + distance[2]*0.1f;

			VectorCopy(velocity, pparams->simvel);
		}

		// predict missing client data and set weapon model ( in HLTV mode or inset in eye mode )
		if ( gEngfuncs.IsSpectateOnly() )
		{
			V_GetInEyePos( g_iUser2, pparams->simorg, pparams->cl_viewangles );

			pparams->health = 1;

			cl_entity_t	*gunModel = gEngfuncs.GetViewModel();

			if ( lastWeaponModelIndex != ent->curstate.weaponmodel )
			{
				// weapon model changed

				lastWeaponModelIndex = ent->curstate.weaponmodel;
				lastViewModelIndex = V_FindViewModelByWeaponModel( lastWeaponModelIndex );
				if ( lastViewModelIndex )
				{
					gEngfuncs.pfnWeaponAnim(0,0);	// reset weapon animation
				}
				else
				{
					// model not found
					gunModel->model = NULL;	// disable weapon model
					lastWeaponModelIndex = lastViewModelIndex = 0;
				}
			}

			if ( lastViewModelIndex )
			{
				gunModel->model = IEngineStudio.GetModelByIndex( lastViewModelIndex );
				gunModel->curstate.modelindex = lastViewModelIndex;
				gunModel->curstate.frame = 0;
				gunModel->curstate.colormap = 0;
				gunModel->index = g_iUser2;
			}
			else
			{
				gunModel->model = NULL;	// disable weaopn model
			}
		}
		else
		{
			// only get viewangles from entity
			VectorCopy ( ent->angles, pparams->cl_viewangles );
			pparams->cl_viewangles[PITCH]*=-3.0f;	// see CL_ProcessEntityUpdate()
		}
	}

	v_frametime = pparams->frametime;

	if ( pparams->nextView == 0 )
	{
		// first renderer cycle, full screen

		switch ( g_iUser1 )
		{
		case OBS_CHASE_LOCKED:
			V_GetChasePos( g_iUser2, NULL, v_origin, v_angles );
			break;

		case OBS_CHASE_FREE:
			V_GetChasePos( g_iUser2, v_cl_angles, v_origin, v_angles );
			break;

		case OBS_ROAMING:
			VectorCopy (v_cl_angles, v_angles);
			VectorCopy (v_sim_org, v_origin);
			break;

		case OBS_IN_EYE:
			V_CalcNormalRefdef ( pparams );
			break;

		case OBS_MAP_FREE:
			pparams->onlyClientDraw = true;
			V_GetMapFreePosition( v_cl_angles, v_origin, v_angles );
			break;

		case OBS_MAP_CHASE:
			pparams->onlyClientDraw = true;
			V_GetMapChasePosition( g_iUser2, v_cl_angles, v_origin, v_angles );
			break;
		}

		if ( gHUD.m_Spectator.m_pip->value )
			pparams->nextView = 1;	// force a second renderer view

		gHUD.m_Spectator.m_iDrawCycle = 0;

	}
	else
	{
		// second renderer cycle, inset window

		// set inset parameters
		pparams->viewport[0] = XRES(gHUD.m_Spectator.m_OverviewData.insetWindowX);	// change viewport to inset window
		pparams->viewport[1] = YRES(gHUD.m_Spectator.m_OverviewData.insetWindowY);
		pparams->viewport[2] = XRES(gHUD.m_Spectator.m_OverviewData.insetWindowWidth);
		pparams->viewport[3] = YRES(gHUD.m_Spectator.m_OverviewData.insetWindowHeight);
		pparams->nextView	 = 0;	// on further view

		// override some settings in certain modes
		switch ( (int)gHUD.m_Spectator.m_pip->value )
		{
		case INSET_CHASE_LOCKED:
			V_GetChasePos( g_iUser2, NULL, v_origin, v_angles );
			break;
		
		case INSET_CHASE_FREE:
			V_GetChasePos( g_iUser2, v_cl_angles, v_origin, v_angles );
			break;

		case INSET_IN_EYE:
			V_CalcNormalRefdef ( pparams );
			break;

		case INSET_MAP_FREE:
			pparams->onlyClientDraw = true;
			V_GetMapFreePosition( v_cl_angles, v_origin, v_angles );
			break;

		case INSET_MAP_CHASE:
			pparams->onlyClientDraw = true;

			if ( g_iUser1 == OBS_ROAMING )
				V_GetMapChasePosition( 0, v_cl_angles, v_origin, v_angles );
			else
				V_GetMapChasePosition( g_iUser2, v_cl_angles, v_origin, v_angles );

			break;
		}

		gHUD.m_Spectator.m_iDrawCycle = 1;
	}

	// write back new values into pparams
	VectorCopy ( v_cl_angles, pparams->cl_viewangles );
	VectorCopy ( v_angles, pparams->viewangles )
	VectorCopy ( v_origin, pparams->vieworg );
}

void V_CalcThirdPersonRefdef( ref_params_t *pparams )
{
	static float lasttime, oldz = 0;

	pparams->vieworg = pparams->simorg;
	pparams->vieworg = pparams->vieworg + pparams->viewheight;
	pparams->viewangles = pparams->cl_viewangles + pparams->punchangle + ev_punchangle;

	v_angles = pparams->viewangles;
	v_lastAngles = pparams->viewangles;

	// never let view origin sit exactly on a node line, because a water plane can
	// disappear when viewed with the eye exactly on it.
	// FIXME, we send origin at 1/128 now, change this?
	// the server protocol only specifies to 1/16 pixel, so add 1/32 in each axis
	pparams->vieworg[0] += 1.0f / 32;
	pparams->vieworg[1] += 1.0f / 32;
	pparams->vieworg[2] += 1.0f / 32;

	// this is smooth stair climbing in thirdperson mode but not affected for client model :(
	if( !pparams->smoothing && pparams->onground && pparams->simorg[2] - oldz > 0.0f )
	{
		float steptime;

		steptime = pparams->time - lasttime;
		if( steptime < 0 ) steptime = 0;

		oldz += steptime * 150.0f;

		if( oldz > pparams->simorg[2] )
			oldz = pparams->simorg[2];
		if( pparams->simorg[2] - oldz > pparams->movevars->stepsize )
			oldz = pparams->simorg[2] - pparams->movevars->stepsize;

		pparams->vieworg[2] += oldz - pparams->simorg[2];
	}
	else
	{
		oldz = pparams->simorg[2];
	}

	lasttime = pparams->time;

	vec3_t ofs, camAngles, camForward, camRight, camUp;

	ofs[0] = ofs[1] = ofs[2] = 0.0;

	CL_CameraOffset( (float *)&ofs );

	VectorCopy( ofs, camAngles );
	camAngles[ ROLL ]	= 0;

	AngleVectors( camAngles, camForward, camRight, camUp );

	for ( int i = 0; i < 3; i++ )
	{
		pparams->vieworg[ i ] += -ofs[2] * camForward[ i ];
	}

	VectorCopy( camAngles, pparams->viewangles);

	V_GetChaseOrigin( pparams->viewangles, pparams->vieworg, cl_chasedist->value, pparams->vieworg );

	float pitch = pparams->viewangles[PITCH];

	// normalize angles
	if( pitch > 180.0f )
		pitch -= 360.0f;
	else if( pitch < -180.0f )
		pitch += 360.0f;

	// player pitch is inverted
	pitch /= -3.0;

	cl_entity_t *ent = gEngfuncs.GetLocalPlayer();

	// slam local player's pitch value
	ent->angles[PITCH] = pitch;
	ent->curstate.angles[PITCH] = pitch;
	ent->prevstate.angles[PITCH] = pitch;
	ent->latched.prevangles[PITCH] = pitch;
}

void DLLEXPORT V_CalcRefdef( struct ref_params_s *pparams )
{
	// intermission / finale rendering
	if ( pparams->intermission )
	{
		V_CalcIntermissionRefdef ( pparams );
	}
	else if ( g_iUser1 )	// g_iUser true if in spectator mode
	{
		V_CalcSpectatorRefdef ( pparams );
	}
	else if ( CL_IsThirdPerson() )
	{
		V_CalcThirdPersonRefdef ( pparams );
	}
	else
	{
		V_CalcNormalRefdef ( pparams );
	}
}

/*
=============
V_Init
=============
*/
void V_Init (void)
{
	//gEngfuncs.pfnAddCommand ("centerview", V_StartPitchDrift );

	scr_ofsx			= gEngfuncs.pfnRegisterVariable( "scr_ofsx","0", 0 );
	scr_ofsy			= gEngfuncs.pfnRegisterVariable( "scr_ofsy","0", 0 );
	scr_ofsz			= gEngfuncs.pfnRegisterVariable( "scr_ofsz","0", 0 );

	v_centermove		= gEngfuncs.pfnRegisterVariable( "v_centermove", "0.15", 0 );
	v_centerspeed		= gEngfuncs.pfnRegisterVariable( "v_centerspeed","500", 0 );

	cl_bobcycle			= gEngfuncs.pfnRegisterVariable( "cl_bobcycle","0.8", 0 );// best default for my experimental gun wag (sjb)
	cl_bob				= gEngfuncs.pfnRegisterVariable( "cl_bob","0.01", FCVAR_ARCHIVE );// best default for my experimental gun wag (sjb)
	cl_bobup			= gEngfuncs.pfnRegisterVariable( "cl_bobup","0.5", 0 );
	cl_waterdist		= gEngfuncs.pfnRegisterVariable( "cl_waterdist","4", 0 );
	cl_chasedist		= gEngfuncs.pfnRegisterVariable( "cl_chasedist","112", 0 );

	cl_quakeguns		= gEngfuncs.pfnRegisterVariable( "cl_quakeguns", "0", FCVAR_ARCHIVE );
	cl_weaponlag		= gEngfuncs.pfnRegisterVariable( "cl_weaponlag", "0", FCVAR_ARCHIVE );
}

```

`cmake/LibraryNaming.cmake`:

```cmake
include_guard(GLOBAL)
include(CheckSymbolExists)

macro(check_build_target symbol)
	check_symbol_exists(${symbol} "build.h" ${symbol})
endmacro()

macro(check_group_build_target symbol group)
	if(NOT ${group})
		check_build_target(${symbol})
		if(${symbol})
			set(${group} TRUE)
		endif()
	else()
		set(${symbol} FALSE)
	endif()
endmacro()

# So there is a problem:
# 1. Total number of these symbols only grows, as we support more and more ports
# 2. CMake don't have a way to check symbols in parallel (similar to Waf's multicheck)
# 3. MSVC is incredibly slow at everything (startup, parsing, generating error)

# Solution: group these symbols and set variable if one of them was found
# this way we can reorder to reorder them by most common configurations
# but we can't generate this list anymore! ... OR IS IT ???

# Well, after reordering positions in engine's buildenums.h, we can partially autogenerate this list!
# echo "check_build_target(XASH_64BIT)"
# grep "#define PLATFORM" buildenums.h     | cut -d' ' -f 2 | cut -d_ -f 2- | awk '{ print "check_group_build_target(XASH_" $1 " XASH_PLATFORM)" }'
# grep "#define ARCHITECTURE" buildenums.h | cut -d' ' -f 2 | cut -d_ -f 2- | awk '{ print "check_group_build_target(XASH_" $1 " XASH_ARCHITECTURE)"
# grep "#define ENDIAN" buildenums.h  | cut -d' ' -f 2 | cut -d_ -f 2- | awk '{ print "check_group_build_target(XASH_" $1 "_ENDIAN XASH_ENDIANNESS)"}'
# echo "if(XASH_ARM)"
# grep '^#undef XASH' build.h | grep "XASH_ARM[v_]" |  awk '{ print "check_build_target(" $2 ")"}'
# echo "endif()"
# echo "if(XASH_RISCV)"
# grep '^#undef XASH' build.h | grep "XASH_RISCV_" |  awk '{ print "check_build_target(" $2 ")"}'
# echo "endif()"

# NOTE: Android must have priority over Linux to work correctly, as Android matches both Linux and it's own macros!

set(CMAKE_REQUIRED_INCLUDES "${PROJECT_SOURCE_DIR}/public/")
check_build_target(XASH_64BIT)
check_group_build_target(XASH_WIN32 XASH_PLATFORM)
check_group_build_target(XASH_ANDROID XASH_PLATFORM)
check_group_build_target(XASH_LINUX XASH_PLATFORM)
check_group_build_target(XASH_FREEBSD XASH_PLATFORM)
check_group_build_target(XASH_APPLE XASH_PLATFORM)
check_group_build_target(XASH_NETBSD XASH_PLATFORM)
check_group_build_target(XASH_OPENBSD XASH_PLATFORM)
check_group_build_target(XASH_EMSCRIPTEN XASH_PLATFORM)
check_group_build_target(XASH_DOS4GW XASH_PLATFORM)
check_group_build_target(XASH_HAIKU XASH_PLATFORM)
check_group_build_target(XASH_SERENITY XASH_PLATFORM)
check_group_build_target(XASH_IRIX XASH_PLATFORM)
check_group_build_target(XASH_NSWITCH XASH_PLATFORM)
check_group_build_target(XASH_PSVITA XASH_PLATFORM)
check_group_build_target(XASH_WASI XASH_PLATFORM)
check_group_build_target(XASH_SUNOS XASH_PLATFORM)
check_group_build_target(XASH_X86 XASH_ARCHITECTURE)
check_group_build_target(XASH_AMD64 XASH_ARCHITECTURE)
check_group_build_target(XASH_ARM XASH_ARCHITECTURE)
check_group_build_target(XASH_MIPS XASH_ARCHITECTURE)
check_group_build_target(XASH_PPC XASH_ARCHITECTURE)
check_group_build_target(XASH_JS XASH_ARCHITECTURE)
check_group_build_target(XASH_WASM XASH_ARCHITECTURE)
check_group_build_target(XASH_E2K XASH_ARCHITECTURE)
check_group_build_target(XASH_RISCV XASH_ARCHITECTURE)
check_group_build_target(XASH_LITTLE_ENDIAN XASH_ENDIANNESS)
check_group_build_target(XASH_BIG_ENDIAN XASH_ENDIANNESS)
if(XASH_ARM)
check_build_target(XASH_ARM_HARDFP)
check_build_target(XASH_ARM_SOFTFP)
check_build_target(XASH_ARMv4)
check_build_target(XASH_ARMv5)
check_build_target(XASH_ARMv6)
check_build_target(XASH_ARMv7)
check_build_target(XASH_ARMv8)
endif()
if(XASH_RISCV)
check_build_target(XASH_RISCV_DOUBLEFP)
check_build_target(XASH_RISCV_SINGLEFP)
check_build_target(XASH_RISCV_SOFTFP)
endif()
if(XASH_ANDROID)
check_build_target(XASH_TERMUX)
endif()
unset(CMAKE_REQUIRED_INCLUDES)

# engine/common/build.c
if(XASH_ANDROID)
	set(BUILDOS "android")
elseif(XASH_WIN32 OR XASH_LINUX OR XASH_APPLE)
	set(BUILDOS "") # no prefix for default OS
elseif(XASH_FREEBSD)
	set(BUILDOS "freebsd")
elseif(XASH_NETBSD)
	set(BUILDOS "netbsd")
elseif(XASH_OPENBSD)
	set(BUILDOS "openbsd")
elseif(XASH_EMSCRIPTEN)
	set(BUILDOS "emscripten")
elseif(XASH_DOS4GW)
	set(BUILDOS "DOS4GW")
elseif(XASH_HAIKU)
	set(BUILDOS "haiku")
elseif(XASH_SERENITY)
	set(BUILDOS "serenityos")
elseif(XASH_NSWITCH)
	set(BUILDOS "nswitch")
elseif(XASH_PSVITA)
	set(BUILDOS "psvita")
elseif(XASH_IRIX)
	set(BUILDOS "irix")
elseif(XASH_WASI)
	set(BUILDOS "wasi")
elseif(XASH_SUNOS)
	set(BUILDOS "sunos")
else()
	message(SEND_ERROR "Place your operating system name here! If this is a mistake, try to fix conditions above and report a bug")
endif()

if(XASH_AMD64)
	set(BUILDARCH "amd64")
elseif(XASH_X86)
	if(XASH_WIN32 OR XASH_LINUX OR XASH_APPLE)
		set(BUILDARCH "") # no prefix for default OS
	else()
		set(BUILDARCH "i386")
	endif()
elseif(XASH_ARM AND XASH_64BIT)
	set(BUILDARCH "arm64")
elseif(XASH_ARM)
	set(BUILDARCH "armv")
	if(XASH_ARMv8)
		set(BUILDARCH "${BUILDARCH}8_32")
	elseif(XASH_ARMv7)
		set(BUILDARCH "${BUILDARCH}7")
	elseif(XASH_ARMv6)
		set(BUILDARCH "${BUILDARCH}6")
	elseif(XASH_ARMv5)
		set(BUILDARCH "${BUILDARCH}5")
	elseif(XASH_ARMv4)
		set(BUILDARCH "${BUILDARCH}4")
	else()
		message(SEND_ERROR "Unknown ARM")
	endif()

	if(XASH_ARM_HARDFP)
		set(BUILDARCH "${BUILDARCH}hf")
	else()
		set(BUILDARCH "${BUILDARCH}l")
	endif()
elseif(XASH_MIPS)
	set(BUILDARCH "mips")
	if(XASH_64BIT)
		set(BUILDARCH "${BUILDARCH}64")
	endif()

	if(XASH_LITTLE_ENDIAN)
		set(BUILDARCH "${BUILDARCH}el")
	endif()
elseif(XASH_RISCV)
	set(BUILDARCH "riscv")
	if(XASH_64BIT)
		set(BUILDARCH "${BUILDARCH}64")
	else()
		set(BUILDARCH "${BUILDARCH}32")
	endif()

	if(XASH_RISCV_DOUBLEFP)
		set(BUILDARCH "${BUILDARCH}d")
	elseif(XASH_RISCV_SINGLEFP)
		set(BUILDARCH "${BUILDARCH}f")
	endif()
elseif(XASH_JS)
	set(BUILDARCH "javascript")
elseif(XASH_E2K)
	set(BUILDARCH "e2k")
elseif(XASH_PPC)
	set(BUILDARCH "ppc")
	if(XASH_64BIT)
		set(BUILDARCH "${BUILDARCH}64")
	endif()

	if(XASH_LITTLE_ENDIAN)
		set(BUILDARCH "${BUILDARCH}el")
	endif()
elseif(XASH_WASM)
	if(XASH_64BIT)
		set(BUILDARCH "wasm64")
	else()
		set(BUILDARCH "wasm32")
	endif()
else()
	message(SEND_ERROR "Place your architecture name here! If this is a mistake, try to fix conditions above and report a bug")
endif()

if(BUILDOS AND BUILDARCH)
	set(POSTFIX "_${BUILDOS}_${BUILDARCH}")
elseif(BUILDARCH)
	set(POSTFIX "_${BUILDARCH}")
else()
	set(POSTFIX "")
endif()

message(STATUS "Library postfix: " ${POSTFIX})

macro(set_target_postfix target)
	set_target_properties(${target} PROPERTIES OUTPUT_NAME "${target}${POSTFIX}")
	if(NOT ANDROID)
		set_target_properties(${target} PROPERTIES PREFIX "")
	endif()
endmacro()

macro(set_target_postfix_with_name target name)
	set_target_properties(${target} PROPERTIES OUTPUT_NAME "${name}${POSTFIX}")
	if(NOT ANDROID)
		set_target_properties(${target} PROPERTIES PREFIX "")
	endif()
endmacro()


```

`common/beamdef.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( BEAMDEFH )
#define BEAMDEFH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#define FBEAM_STARTENTITY		0x00000001
#define FBEAM_ENDENTITY			0x00000002
#define FBEAM_FADEIN			0x00000004
#define FBEAM_FADEOUT			0x00000008
#define FBEAM_SINENOISE			0x00000010
#define FBEAM_SOLID				0x00000020
#define FBEAM_SHADEIN			0x00000040
#define FBEAM_SHADEOUT			0x00000080
#define FBEAM_STARTVISIBLE		0x10000000		// Has this client actually seen this beam's start entity yet?
#define FBEAM_ENDVISIBLE		0x20000000		// Has this client actually seen this beam's end entity yet?
#define FBEAM_ISACTIVE			0x40000000
#define FBEAM_FOREVER			0x80000000

typedef struct beam_s BEAM;
struct beam_s
{
	BEAM		*next;
	int			type;
	int			flags;
	vec3_t		source;
	vec3_t		target;
	vec3_t		delta;
	float		t;		// 0 .. 1 over lifetime of beam
	float		freq;
	float		die;
	float		width;
	float		amplitude;
	float		r, g, b;
	float		brightness;
	float		speed;
	float		frameRate;
	float		frame;
	int			segments;
	int			startEntity;
	int			endEntity;
	int			modelIndex;
	int			frameCount;
	struct model_s		*pFollowModel;
	struct particle_s	*particles;
};

#endif

```

`common/cl_entity.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// cl_entity.h
#if !defined( CL_ENTITYH )
#define CL_ENTITYH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct efrag_s
{
	struct mleaf_s		*leaf;
	struct efrag_s		*leafnext;
	struct cl_entity_s	*entity;
	struct efrag_s		*entnext;
} efrag_t;

typedef struct
{
	byte					mouthopen;		// 0 = mouth closed, 255 = mouth agape
	byte					sndcount;		// counter for running average
	int						sndavg;			// running average
} mouth_t;

typedef struct
{
	float					prevanimtime;  
	float					sequencetime;
	byte					prevseqblending[2];
	vec3_t					prevorigin;
	vec3_t					prevangles;

	int						prevsequence;
	float					prevframe;

	byte					prevcontroller[4];
	byte					prevblending[2];
} latchedvars_t;

typedef struct
{
	// Time stamp for this movement
	float					animtime;

	vec3_t					origin;
	vec3_t					angles;
} position_history_t;

typedef struct cl_entity_s cl_entity_t;

#define HISTORY_MAX		64  // Must be power of 2
#define HISTORY_MASK	( HISTORY_MAX - 1 )


#if !defined( ENTITY_STATEH )
#include "entity_state.h"
#endif

#if !defined( PROGS_H )
#include "progs.h"
#endif

struct cl_entity_s
{
	int						index;      // Index into cl_entities ( should match actual slot, but not necessarily )

	qboolean				player;     // True if this entity is a "player"
	
	entity_state_t			baseline;   // The original state from which to delta during an uncompressed message
	entity_state_t			prevstate;  // The state information from the penultimate message received from the server
	entity_state_t			curstate;   // The state information from the last message received from server

	int						current_position;  // Last received history update index
	position_history_t		ph[ HISTORY_MAX ];   // History of position and angle updates for this player

	mouth_t					mouth;			// For synchronizing mouth movements.

	latchedvars_t			latched;		// Variables used by studio model rendering routines

	// Information based on interplocation, extrapolation, prediction, or just copied from last msg received.
	//
	float					lastmove;

	// Actual render position and angles
	vec3_t					origin;
	vec3_t					angles;

	// Attachment points
	vec3_t					attachment[4];

	// Other entity local information
	int						trivial_accept;

	struct model_s			*model;			// cl.model_precache[ curstate.modelindes ];  all visible entities have a model
	struct efrag_s			*efrag;			// linked list of efrags
	struct mnode_s			*topnode;		// for bmodels, first world node that splits bmodel, or NULL if not split

	float					syncbase;		// for client-side animations -- used by obsolete alias animation system, remove?
	int						visframe;		// last frame this entity was found in an active leaf
	colorVec				cvFloorColor;
};

#endif // !CL_ENTITYH

```

`common/com_model.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// com_model.h
#if !defined( COM_MODEL_H )
#define COM_MODEL_H
#if defined( _WIN32 )
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#define STUDIO_RENDER 1
#define STUDIO_EVENTS 2

#define MAX_CLIENTS			32
#define	MAX_EDICTS			900

#define MAX_MODEL_NAME		64
#define MAX_MAP_HULLS		4
#define	MIPLEVELS			4
#define	NUM_AMBIENTS		4		// automatic ambient sounds
#define	MAXLIGHTMAPS		4
#define	PLANE_ANYZ			5

#define ALIAS_Z_CLIP_PLANE	5

// flags in finalvert_t.flags
#define ALIAS_LEFT_CLIP				0x0001
#define ALIAS_TOP_CLIP				0x0002
#define ALIAS_RIGHT_CLIP			0x0004
#define ALIAS_BOTTOM_CLIP			0x0008
#define ALIAS_Z_CLIP				0x0010
#define ALIAS_ONSEAM				0x0020
#define ALIAS_XY_CLIP_MASK			0x000F

#define	ZISCALE	((float)0x8000)

#define CACHE_SIZE	32		// used to align key data structures

typedef enum
{
	mod_brush, 
	mod_sprite, 
	mod_alias, 
	mod_studio
} modtype_t;

// must match definition in modelgen.h
#ifndef SYNCTYPE_T
#define SYNCTYPE_T

typedef enum
{
	ST_SYNC=0,
	ST_RAND
} synctype_t;

#endif

typedef struct
{
	float		mins[3], maxs[3];
	float		origin[3];
	int			headnode[MAX_MAP_HULLS];
	int			visleafs;		// not including the solid leaf 0
	int			firstface, numfaces;
} dmodel_t;

// plane_t structure
typedef struct mplane_s
{
	vec3_t	normal;			// surface normal
	float	dist;			// closest appoach to origin
	byte	type;			// for texture axis selection and fast side tests
	byte	signbits;		// signx + signy<<1 + signz<<1
	byte	pad[2];
} mplane_t;

typedef struct
{
	vec3_t		position;
} mvertex_t;

typedef struct
{
	unsigned short	v[2];
	unsigned int	cachededgeoffset;
} medge_t;

typedef struct texture_s
{
	char		name[16];
	unsigned	width, height;
	int			anim_total;				// total tenths in sequence ( 0 = no)
	int			anim_min, anim_max;		// time for this frame min <=time< max
	struct texture_s *anim_next;		// in the animation sequence
	struct texture_s *alternate_anims;	// bmodels in frame 1 use these
	unsigned	offsets[MIPLEVELS];		// four mip maps stored
	unsigned	paloffset;
} texture_t;

typedef struct
{
	float		vecs[2][4];		// [s/t] unit vectors in world space. 
								// [i][3] is the s/t offset relative to the origin.
								// s or t = dot(3Dpoint,vecs[i])+vecs[i][3]
	float		mipadjust;		// ?? mipmap limits for very small surfaces
	texture_t	*texture;
	int			flags;			// sky or slime, no lightmap or 256 subdivision
} mtexinfo_t;

typedef struct mnode_s
{
// common with leaf
	int			contents;		// 0, to differentiate from leafs
	int			visframe;		// node needs to be traversed if current
	
	short		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// node specific
	mplane_t	*plane;
	struct mnode_s	*children[2];	

	unsigned short		firstsurface;
	unsigned short		numsurfaces;
} mnode_t;

typedef struct msurface_s	msurface_t;
typedef struct decal_s		decal_t;

// JAY: Compress this as much as possible
struct decal_s
{
	decal_t		*pnext;			// linked list for each surface
	msurface_t	*psurface;		// Surface id for persistence / unlinking
	short		dx;				// Offsets into surface texture (in texture coordinates, so we don't need floats)
	short		dy;
	short		texture;		// Decal texture
	byte		scale;			// Pixel scale
	byte		flags;			// Decal flags

	short		entityIndex;	// Entity this is attached to
};

typedef struct mleaf_s
{
// common with node
	int			contents;		// wil be a negative contents number
	int			visframe;		// node needs to be traversed if current

	short		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// leaf specific
	byte		*compressed_vis;
	struct efrag_s	*efrags;

	msurface_t	**firstmarksurface;
	int			nummarksurfaces;
	int			key;			// BSP sequence number for leaf's contents
	byte		ambient_sound_level[NUM_AMBIENTS];
} mleaf_t;

struct msurface_s
{
	int			visframe;		// should be drawn when node is crossed

	int			dlightframe;	// last frame the surface was checked by an animated light
	int			dlightbits;		// dynamically generated. Indicates if the surface illumination 
								// is modified by an animated light.

	mplane_t	*plane;			// pointer to shared plane			
	int			flags;			// see SURF_ #defines

	int			firstedge;	// look up in model->surfedges[], negative numbers
	int			numedges;	// are backwards edges
	
// surface generation data
	struct surfcache_s	*cachespots[MIPLEVELS];

	short		texturemins[2]; // smallest s/t position on the surface.
	short		extents[2];		// ?? s/t texture size, 1..256 for all non-sky surfaces

	mtexinfo_t	*texinfo;		
	
// lighting info
	byte		styles[MAXLIGHTMAPS]; // index into d_lightstylevalue[] for animated lights 
									  // no one surface can be effected by more than 4 
									  // animated lights.
	color24		*samples;
	
	decal_t		*pdecals;
};

typedef struct
{
	int			planenum;
	short		children[2];	// negative numbers are contents
} dclipnode_t;

typedef struct hull_s
{
	dclipnode_t	*clipnodes;
	mplane_t	*planes;
	int			firstclipnode;
	int			lastclipnode;
	vec3_t		clip_mins;
	vec3_t		clip_maxs;
} hull_t;

#if !defined( CACHE_USER ) && !defined( QUAKEDEF_H )
#define CACHE_USER
typedef struct cache_user_s
{
	void	*data;
} cache_user_t;
#endif

typedef struct model_s
{
	char		name[ MAX_MODEL_NAME ];
	qboolean	needload;		// bmodels and sprites don't cache normally

	modtype_t	type;
	int			numframes;
	synctype_t	synctype;
	
	int			flags;

//
// volume occupied by the model
//		
	vec3_t		mins, maxs;
	float		radius;

//
// brush model
//
	int			firstmodelsurface, nummodelsurfaces;

	int			numsubmodels;
	dmodel_t	*submodels;

	int			numplanes;
	mplane_t	*planes;

	int			numleafs;		// number of visible leafs, not counting 0
	struct mleaf_s		*leafs;

	int			numvertexes;
	mvertex_t	*vertexes;

	int			numedges;
	medge_t		*edges;

	int			numnodes;
	mnode_t		*nodes;

	int			numtexinfo;
	mtexinfo_t	*texinfo;

	int			numsurfaces;
	msurface_t	*surfaces;

	int			numsurfedges;
	int			*surfedges;

	int			numclipnodes;
	dclipnode_t	*clipnodes;

	int			nummarksurfaces;
	msurface_t	**marksurfaces;

	hull_t		hulls[MAX_MAP_HULLS];

	int			numtextures;
	texture_t	**textures;

	byte		*visdata;

	color24		*lightdata;

	char		*entities;

//
// additional model data
//
	cache_user_t	cache;		// only access through Mod_Extradata

} model_t;

typedef vec_t vec4_t[4];

typedef struct alight_s
{
	int			ambientlight;	// clip at 128
	int			shadelight;		// clip at 192 - ambientlight
	vec3_t		color;
	float		*plightvec;
} alight_t;

typedef struct auxvert_s
{
	float	fv[3];		// viewspace x, y
} auxvert_t;

#include "custom.h"

#define	MAX_INFO_STRING			256
#define	MAX_SCOREBOARDNAME		32
typedef struct player_info_s
{
	// User id on server
	int		userid;

	// User info string
	char	userinfo[ MAX_INFO_STRING ];

	// Name
	char	name[ MAX_SCOREBOARDNAME ];

	// Spectator or not, unused
	int		spectator;

	int		ping;
	int		packet_loss;

	// skin information
	char	model[MAX_QPATH];
	int		topcolor;
	int		bottomcolor;

	// last frame rendered
	int		renderframe;	

	// Gait frame estimation
	int		gaitsequence;
	float	gaitframe;
	float	gaityaw;
	vec3_t	prevgaitorigin;

	customization_t customdata;
} player_info_t;

#endif // #define COM_MODEL_H

```

`common/con_nprint.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( CON_NPRINTH )
#define CON_NPRINTH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct con_nprint_s
{
	int		index;			// Row #
	float	time_to_live;	// # of seconds before it disappears
	float	color[ 3 ];		// RGB colors ( 0.0 -> 1.0 scale )
} con_nprint_t;

#endif

```

`common/const.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CONST_H
#define CONST_H
//
// Constants shared by the engine and dlls
// This header file included by engine files and DLL files.
// Most came from server.h

// edict->flags
#define FL_FLY		(1<<0)	// Changes the SV_Movestep() behavior to not need to be on ground
#define FL_SWIM		(1<<1)	// Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)
#define FL_CONVEYOR		(1<<2)
#define FL_CLIENT		(1<<3)
#define FL_INWATER		(1<<4)
#define FL_MONSTER		(1<<5)
#define FL_GODMODE		(1<<6)
#define FL_NOTARGET		(1<<7)
#define FL_SKIPLOCALHOST	(1<<8)	// Don't send entity to local host, it's predicting this entity itself
#define FL_ONGROUND		(1<<9)	// At rest / on the ground
#define FL_PARTIALGROUND	(1<<10)	// not all corners are valid
#define FL_WATERJUMP	(1<<11)	// player jumping out of water
#define FL_FROZEN		(1<<12)	// Player is frozen for 3rd person camera
#define FL_FAKECLIENT	(1<<13)	// JAC: fake client, simulated server side; don't send network messages to them
#define FL_DUCKING		(1<<14)	// Player flag -- Player is fully crouched
#define FL_FLOAT		(1<<15)	// Apply floating force to this entity when in water
#define FL_GRAPHED		(1<<16)	// worldgraph has this ent listed as something that blocks a connection

// UNDONE: Do we need these?
#define FL_IMMUNE_WATER	(1<<17)
#define FL_IMMUNE_SLIME	(1<<18)
#define FL_IMMUNE_LAVA	(1<<19)

#define FL_PROXY		(1<<20)	// This is a spectator proxy
#define FL_ALWAYSTHINK	(1<<21)	// Brush model flag -- call think every frame regardless of nextthink - ltime (for constantly changing velocity/path)
#define FL_BASEVELOCITY	(1<<22)	// Base velocity has been applied this frame (used to convert base velocity into momentum)
#define FL_MONSTERCLIP	(1<<23)	// Only collide in with monsters who have FL_MONSTERCLIP set
#define FL_ONTRAIN		(1<<24)	// Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_WORLDBRUSH	(1<<25)	// Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)
#define FL_SPECTATOR	(1<<26)	// This client is a spectator, don't run touch functions, etc.
#define FL_CUSTOMENTITY	(1<<29)	// This is a custom entity
#define FL_KILLME		(1<<30)	// This entity is marked for death -- This allows the engine to kill ents at the appropriate time
#define FL_DORMANT		(1<<31)	// Entity is dormant, no updates to client

// Goes into globalvars_t.trace_flags
#define FTRACE_SIMPLEBOX		(1<<0)	// Traceline with a simple box
#define FTRACE_IGNORE_GLASS		(1<<1)	// traceline will be ignored entities with rendermode != kRenderNormal

// walkmove modes
#define WALKMOVE_NORMAL		0	// normal walkmove
#define WALKMOVE_WORLDONLY		1	// doesn't hit ANY entities, no matter what the solid type
#define WALKMOVE_CHECKONLY		2	// move, but don't touch triggers

// edict->movetype values
#define MOVETYPE_NONE		0	// never moves
//#define	MOVETYPE_ANGLENOCLIP	1
//#define	MOVETYPE_ANGLECLIP		2
#define MOVETYPE_WALK		3	// Player only - moving on the ground
#define MOVETYPE_STEP		4	// gravity, special edge handling -- monsters use this
#define MOVETYPE_FLY		5	// No gravity, but still collides with stuff
#define MOVETYPE_TOSS		6	// gravity/collisions
#define MOVETYPE_PUSH		7	// no clip to world, push and crush
#define MOVETYPE_NOCLIP		8	// No gravity, no collisions, still do velocity/avelocity
#define MOVETYPE_FLYMISSILE		9	// extra size to monsters
#define MOVETYPE_BOUNCE		10	// Just like Toss, but reflect velocity when contacting surfaces
#define MOVETYPE_BOUNCEMISSILE	11	// bounce w/o gravity
#define MOVETYPE_FOLLOW		12	// track movement of aiment
#define MOVETYPE_PUSHSTEP		13	// BSP model that needs physics/world collisions (uses nearest hull for world collision)
#define MOVETYPE_COMPOUND		14	// glue two entities together (simple movewith)

// edict->solid values
// NOTE: Some movetypes will cause collisions independent of SOLID_NOT/SOLID_TRIGGER when the entity moves
// SOLID only effects OTHER entities colliding with this one when they move - UGH!
#define SOLID_NOT			0	// no interaction with other objects
#define SOLID_TRIGGER		1	// touch on edge, but not blocking
#define SOLID_BBOX			2	// touch on edge, block
#define SOLID_SLIDEBOX		3	// touch on edge, but not an onground
#define SOLID_BSP			4	// bsp clip, touch on edge, block
#define SOLID_CUSTOM		5	// call external callbacks for tracing

// edict->deadflag values
#define DEAD_NO			0 	// alive
#define DEAD_DYING			1 	// playing death animation or still falling off of a ledge waiting to hit ground
#define DEAD_DEAD			2 	// dead. lying still.
#define DEAD_RESPAWNABLE		3
#define DEAD_DISCARDBODY		4

#define DAMAGE_NO			0
#define DAMAGE_YES			1
#define DAMAGE_AIM			2

// entity effects
#define EF_BRIGHTFIELD		1	// swirling cloud of particles
#define EF_MUZZLEFLASH		2	// single frame ELIGHT on entity attachment 0
#define EF_BRIGHTLIGHT		4	// DLIGHT centered at entity origin
#define EF_DIMLIGHT			8	// player flashlight
#define EF_INVLIGHT			16	// get lighting from ceiling
#define EF_NOINTERP			32	// don't interpolate the next frame
#define EF_LIGHT			64	// rocket flare glow sprite
#define EF_NODRAW			128	// don't draw entity



#define EF_NOREFLECT		(1<<24)	// Entity won't reflecting in mirrors
#define EF_REFLECTONLY		(1<<25)	// Entity will be drawing only in mirrors
#define EF_NOWATERCSG		(1<<26)	// Do not remove sides for func_water entity
#define EF_FULLBRIGHT		(1<<27)	// Just get fullbright
#define EF_NOSHADOW			(1<<28)	// ignore shadow for this entity
#define EF_MERGE_VISIBILITY		(1<<29)	// this entity allowed to merge vis (e.g. env_sky or portal camera)
#define EF_REQUEST_PHS		(1<<30)	// This entity requested phs bitvector instead of pvsbitvector in AddToFullPack calls
// g-cont. one reserved bit here for me

// entity flags
#define EFLAG_SLERP			1	// do studio interpolation of this entity
		
//
// temp entity events
//
#define	TE_BEAMPOINTS		0	// beam effect between two points
// coord coord coord (start position) 
// coord coord coord (end position) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_BEAMENTPOINT		1	// beam effect between point and entity
// short (start entity) 
// coord coord coord (end position) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_GUNSHOT		2	// particle effect plus ricochet sound
// coord coord coord (position) 

#define	TE_EXPLOSION		3	// additive sprite, 2 dynamic lights, flickering particles, explosion sound, move vertically 8 pps
// coord coord coord (position) 
// short (sprite index)
// byte (scale in 0.1's)
// byte (framerate)
// byte (flags)
//
// The Explosion effect has some flags to control performance/aesthetic features:
#define TE_EXPLFLAG_NONE		0	// all flags clear makes default Half-Life explosion
#define TE_EXPLFLAG_NOADDITIVE	1	// sprite will be drawn opaque (ensure that the sprite you send is a non-additive sprite)
#define TE_EXPLFLAG_NODLIGHTS		2	// do not render dynamic lights
#define TE_EXPLFLAG_NOSOUND		4	// do not play client explosion sound
#define TE_EXPLFLAG_NOPARTICLES	8	// do not draw particles
#define TE_EXPLFLAG_DRAWALPHA		16	// sprite will be drawn alpha
#define TE_EXPLFLAG_ROTATE		32	// rotate the sprite randomly

#define	TE_TAREXPLOSION		4	// Quake1 "tarbaby" explosion with sound
// coord coord coord (position) 

#define	TE_SMOKE			5	// alphablend sprite, move vertically 30 pps
// coord coord coord (position) 
// short (sprite index)
// byte (scale in 0.1's)
// byte (framerate)

#define	TE_TRACER			6	// tracer effect from point to point
// coord, coord, coord (start) 
// coord, coord, coord (end)

#define	TE_LIGHTNING		7	// TE_BEAMPOINTS with simplified parameters
// coord, coord, coord (start) 
// coord, coord, coord (end) 
// byte (life in 0.1's) 
// byte (width in 0.1's) 
// byte (amplitude in 0.01's)
// short (sprite model index)

#define	TE_BEAMENTS		8		
// short (start entity) 
// short (end entity) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_SPARKS			9	// 8 random tracers with gravity, ricochet sprite
// coord coord coord (position) 

#define	TE_LAVASPLASH		10	// Quake1 lava splash
// coord coord coord (position) 

#define	TE_TELEPORT		11	// Quake1 teleport splash
// coord coord coord (position) 

#define TE_EXPLOSION2		12	// Quake1 colormaped (base palette) particle explosion with sound
// coord coord coord (position) 
// byte (starting color)
// byte (num colors)

#define TE_BSPDECAL			13	// Decal from the .BSP file 
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// short (texture index of precached decal texture name)
// short (entity index)
// [optional - only included if previous short is non-zero (not the world)] short (index of model of above entity)

#define TE_IMPLOSION		14	// tracers moving toward a point
// coord, coord, coord (position)
// byte (radius)
// byte (count)
// byte (life in 0.1's) 

#define TE_SPRITETRAIL		15	// line of moving glow sprites with gravity, fadeout, and collisions
// coord, coord, coord (start) 
// coord, coord, coord (end) 
// short (sprite index)
// byte (count)
// byte (life in 0.1's) 
// byte (scale in 0.1's) 
// byte (velocity along vector in 10's)
// byte (randomness of velocity in 10's)

#define TE_BEAM			16	// obsolete

#define TE_SPRITE			17	// additive sprite, plays 1 cycle
// coord, coord, coord (position) 
// short (sprite index) 
// byte (scale in 0.1's) 
// byte (brightness)

#define TE_BEAMSPRITE		18	// A beam with a sprite at the end
// coord, coord, coord (start position) 
// coord, coord, coord (end position) 
// short (beam sprite index) 
// short (end sprite index) 

#define TE_BEAMTORUS		19	// screen aligned beam ring, expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMDISK			20	// disk that expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMCYLINDER		21	// cylinder that expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMFOLLOW		22	// create a line of decaying beam segments until entity stops moving
// short (entity:attachment to follow)
// short (sprite index)
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte,byte,byte (color)
// byte (brightness)

#define TE_GLOWSPRITE		23		
// coord, coord, coord (pos) short (model index) byte (scale / 10)

#define TE_BEAMRING			24	// connect a beam ring to two entities
// short (start entity) 
// short (end entity) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_STREAK_SPLASH	25		// oriented shower of tracers
// coord coord coord (start position) 
// coord coord coord (direction vector) 
// byte (color)
// short (count)
// short (base speed)
// short (random velocity)

#define TE_BEAMHOSE			26	// obsolete

#define TE_DLIGHT			27	// dynamic light, effect world, minor entity effect
// coord, coord, coord (pos) 
// byte (radius in 10's) 
// byte byte byte (color)
// byte (life in 10's)
// byte (decay rate in 10's)

#define TE_ELIGHT			28	// point entity light, no world effect
// short (entity:attachment to follow)
// coord coord coord (initial position) 
// coord (radius)
// byte byte byte (color)
// byte (life in 0.1's)
// coord (decay rate)

#define TE_TEXTMESSAGE		29
// short 1.2.13 x (-1 = center)
// short 1.2.13 y (-1 = center)
// byte Effect 0 = fade in/fade out
// 1 is flickery credits
// 2 is write out (training room)
// 4 bytes r,g,b,a color1	(text color)
// 4 bytes r,g,b,a color2	(effect color)
// ushort 8.8 fadein time
// ushort 8.8  fadeout time
// ushort 8.8 hold time
// optional ushort 8.8 fxtime	(time the highlight lags behing the leading text in effect 2)
// string text message		(512 chars max sz string)
#define TE_LINE			30
// coord, coord, coord	startpos
// coord, coord, coord	endpos
// short life in 0.1 s
// 3 bytes r, g, b

#define TE_BOX			31
// coord, coord, coord	boxmins
// coord, coord, coord	boxmaxs
// short life in 0.1 s
// 3 bytes r, g, b

#define TE_KILLBEAM			99	// kill all beams attached to entity
// short (entity)

#define TE_LARGEFUNNEL		100
// coord coord coord (funnel position)
// short (sprite index) 
// short (flags) 

#define	TE_BLOODSTREAM		101	// particle spray
// coord coord coord (start position)
// coord coord coord (spray vector)
// byte (color)
// byte (speed)

#define	TE_SHOWLINE		102	// line of particles every 5 units, dies in 30 seconds
// coord coord coord (start position)
// coord coord coord (end position)

#define TE_BLOOD			103	// particle spray
// coord coord coord (start position)
// coord coord coord (spray vector)
// byte (color)
// byte (speed)

#define TE_DECAL			104	// Decal applied to a brush entity (not the world)
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name)
// short (entity index)

#define TE_FIZZ			105	// create alpha sprites inside of entity, float upwards
// short (entity)
// short (sprite index)
// byte (density)

#define TE_MODEL			106	// create a moving model that bounces and makes a sound when it hits
// coord, coord, coord (position) 
// coord, coord, coord (velocity)
// angle (initial yaw)
// short (model index)
// byte (bounce sound type)
// byte (life in 0.1's)

#define TE_EXPLODEMODEL		107	// spherical shower of models, picks from set
// coord, coord, coord (origin)
// coord (velocity)
// short (model index)
// short (count)
// byte (life in 0.1's)

#define TE_BREAKMODEL		108	// box of models or sprites
// coord, coord, coord (position)
// coord, coord, coord (size)
// coord, coord, coord (velocity)
// byte (random velocity in 10's)
// short (sprite or model index)
// byte (count)
// byte (life in 0.1 secs)
// byte (flags)

#define TE_GUNSHOTDECAL		109	// decal and ricochet sound
// coord, coord, coord (position)
// short (entity index???)
// byte (decal???)

#define TE_SPRITE_SPRAY		110	// spay of alpha sprites
// coord, coord, coord (position)
// coord, coord, coord (velocity)
// short (sprite index)
// byte (count)
// byte (speed)
// byte (noise)

#define TE_ARMOR_RICOCHET		111	// quick spark sprite, client ricochet sound. 
// coord, coord, coord (position)
// byte (scale in 0.1's)

#define TE_PLAYERDECAL		112	// ???
// byte (playerindex)
// coord, coord, coord (position)
// short (entity???)
// byte (decal number???)
// [optional] short (model index???)

#define TE_BUBBLES			113	// create alpha sprites inside of box, float upwards
// coord, coord, coord (min start position)
// coord, coord, coord (max start position)
// coord (float height)
// short (model index)
// byte (count)
// coord (speed)

#define TE_BUBBLETRAIL		114	// create alpha sprites along a line, float upwards
// coord, coord, coord (min start position)
// coord, coord, coord (max start position)
// coord (float height)
// short (model index)
// byte (count)
// coord (speed)

#define TE_BLOODSPRITE		115	// spray of opaque sprite1's that fall, single sprite2 for 1..2 secs (this is a high-priority tent)
// coord, coord, coord (position)
// short (sprite1 index)
// short (sprite2 index)
// byte (color)
// byte (scale)

#define TE_WORLDDECAL		116	// Decal applied to the world brush
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name)

#define TE_WORLDDECALHIGH		117	// Decal (with texture index > 256) applied to world brush
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name - 256)

#define TE_DECALHIGH		118	// Same as TE_DECAL, but the texture index was greater than 256
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name - 256)
// short (entity index)

#define TE_PROJECTILE		119	// Makes a projectile (like a nail) (this is a high-priority tent)
// coord, coord, coord (position)
// coord, coord, coord (velocity)
// short (modelindex)
// byte (life)
// byte (owner)  projectile won't collide with owner (if owner == 0, projectile will hit any client).

#define TE_SPRAY			120	// Throws a shower of sprites or models
// coord, coord, coord (position)
// coord, coord, coord (direction)
// short (modelindex)
// byte (count)
// byte (speed)
// byte (noise)
// byte (rendermode)

#define TE_PLAYERSPRITES		121	// sprites emit from a player's bounding box (ONLY use for players!)
// byte (playernum)
// short (sprite modelindex)
// byte (count)
// byte (variance) (0 = no variance in size) (10 = 10% variance in size)

#define TE_PARTICLEBURST		122	// very similar to lavasplash.
// coord (origin)
// short (radius)
// byte (particle color)
// byte (duration * 10) (will be randomized a bit)

#define TE_FIREFIELD		123	// makes a field of fire.
// coord (origin)
// short (radius) (fire is made in a square around origin. -radius, -radius to radius, radius)
// short (modelindex)
// byte (count)
// byte (flags)
// byte (duration (in seconds) * 10) (will be randomized a bit)
//
// to keep network traffic low, this message has associated flags that fit into a byte:
#define TEFIRE_FLAG_ALLFLOAT	1 // all sprites will drift upwards as they animate
#define TEFIRE_FLAG_SOMEFLOAT	2 // some of the sprites will drift upwards. (50% chance)
#define TEFIRE_FLAG_LOOP	4 // if set, sprite plays at 15 fps, otherwise plays at whatever rate stretches the animation over the sprite's duration.
#define TEFIRE_FLAG_ALPHA	8 // if set, sprite is rendered alpha blended at 50% else, opaque
#define TEFIRE_FLAG_PLANAR	16 // if set, all fire sprites have same initial Z instead of randomly filling a cube. 

#define TE_PLAYERATTACHMENT		124	// attaches a TENT to a player (this is a high-priority tent)
// byte (entity index of player)
// coord (vertical offset) ( attachment origin.z = player origin.z + vertical offset )
// short (model index)
// short (life * 10 );

#define TE_KILLPLAYERATTACHMENTS	125	// will expire all TENTS attached to a player.
// byte (entity index of player)

#define TE_MULTIGUNSHOT		126	// much more compact shotgun message
// This message is used to make a client approximate a 'spray' of gunfire.
// Any weapon that fires more than one bullet per frame and fires in a bit of a spread is
// a good candidate for MULTIGUNSHOT use. (shotguns)
//
// NOTE: This effect makes the client do traces for each bullet, these client traces ignore
// entities that have studio models.Traces are 4096 long.
//
// coord (origin)
// coord (origin)
// coord (origin)
// coord (direction)
// coord (direction)
// coord (direction)
// coord (x noise * 100)
// coord (y noise * 100)
// byte (count)
// byte (bullethole decal texture index)

#define TE_USERTRACER		127	// larger message than the standard tracer, but allows some customization.
// coord (origin)
// coord (origin)
// coord (origin)
// coord (velocity)
// coord (velocity)
// coord (velocity)
// byte ( life * 10 )
// byte ( color ) this is an index into an array of color vectors in the engine. (0 - )
// byte ( length * 10 )

#define MSG_BROADCAST		0	// unreliable to all
#define MSG_ONE			1	// reliable to one (msg_entity)
#define MSG_ALL			2	// reliable to all
#define MSG_INIT			3	// write to the init string
#define MSG_PVS			4	// Ents in PVS of org
#define MSG_PAS			5	// Ents in PAS of org
#define MSG_PVS_R			6	// Reliable to PVS
#define MSG_PAS_R			7	// Reliable to PAS
#define MSG_ONE_UNRELIABLE		8	// Send to one client, but don't put in reliable stream, put in unreliable datagram ( could be dropped )
#define MSG_SPEC			9	// Sends to all spectator proxies

// contents of a spot in the world
#define CONTENTS_EMPTY		-1
#define CONTENTS_SOLID		-2
#define CONTENTS_WATER		-3
#define CONTENTS_SLIME		-4
#define CONTENTS_LAVA		-5
#define CONTENTS_SKY		-6
// These additional contents constants are defined in bspfile.h
#define CONTENTS_ORIGIN		-7	// removed at csg time
#define CONTENTS_CLIP		-8	// changed to contents_solid
#define CONTENTS_CURRENT_0		-9
#define CONTENTS_CURRENT_90		-10
#define CONTENTS_CURRENT_180		-11
#define CONTENTS_CURRENT_270		-12
#define CONTENTS_CURRENT_UP		-13
#define CONTENTS_CURRENT_DOWN		-14
#define CONTENTS_TRANSLUCENT		-15

#define CONTENTS_LADDER		-16

#define CONTENT_FLYFIELD		-17
#define CONTENT_GRAVITY_FLYFIELD	-18
#define CONTENT_FOG			-19

#define CONTENT_EMPTY		-1
#define CONTENT_SOLID		-2
#define CONTENT_WATER		-3
#define CONTENT_SLIME		-4
#define CONTENT_LAVA		-5
#define CONTENT_SKY			-6

// channels
#define CHAN_AUTO			0
#define CHAN_WEAPON			1
#define CHAN_VOICE			2
#define CHAN_ITEM			3
#define CHAN_BODY			4
#define CHAN_STREAM			5	// allocate stream channel from the static or dynamic area
#define CHAN_STATIC			6	// allocate channel from the static area 
#define CHAN_NETWORKVOICE_BASE	7	// voice data coming across the network
#define CHAN_NETWORKVOICE_END		500	// network voice data reserves slots (CHAN_NETWORKVOICE_BASE through CHAN_NETWORKVOICE_END).

// attenuation values
#define ATTN_NONE			0
#define ATTN_NORM			(float)0.8
#define ATTN_IDLE			(float)2
#define ATTN_STATIC			(float)1.25 

// pitch values
#define PITCH_NORM			100	// non-pitch shifted
#define PITCH_LOW			95	// other values are possible - 0-255, where 255 is very high
#define PITCH_HIGH			120

// volume values
#define VOL_NORM			1.0

// plats
#define PLAT_LOW_TRIGGER		1

// Trains
#define SF_TRAIN_WAIT_RETRIGGER	1
#define SF_TRAIN_START_ON		4	// Train is initially moving
#define SF_TRAIN_PASSABLE		8	// Train is not solid -- used to make water trains

// buttons
#define IN_ATTACK			(1<<0)
#define IN_JUMP			(1<<1)
#define IN_DUCK			(1<<2)
#define IN_FORWARD			(1<<3)
#define IN_BACK			(1<<4)
#define IN_USE			(1<<5)
#define IN_CANCEL			(1<<6)
#define IN_LEFT			(1<<7)
#define IN_RIGHT			(1<<8)
#define IN_MOVELEFT			(1<<9)
#define IN_MOVERIGHT		(1<<10)
#define IN_ATTACK2			(1<<11)
#define IN_RUN			(1<<12)
#define IN_RELOAD			(1<<13)
#define IN_ALT1			(1<<14)
#define IN_SCORE			(1<<15)   // Used by client.dll for when scoreboard is held down

// Break Model Defines
#define BREAK_TYPEMASK		0x4F
#define BREAK_GLASS			0x01
#define BREAK_METAL			0x02
#define BREAK_FLESH			0x04
#define BREAK_WOOD			0x08
#define BREAK_SMOKE			0x10
#define BREAK_TRANS			0x20
#define BREAK_CONCRETE		0x40
#define BREAK_2			0x80

// Colliding temp entity sounds
#define BOUNCE_GLASS		BREAK_GLASS
#define BOUNCE_METAL		BREAK_METAL
#define BOUNCE_FLESH		BREAK_FLESH
#define BOUNCE_WOOD			BREAK_WOOD
#define BOUNCE_SHRAP		0x10
#define BOUNCE_SHELL		0x20
#define BOUNCE_CONCRETE		BREAK_CONCRETE
#define BOUNCE_SHOTSHELL		0x80

// Temp entity bounce sound types
#define TE_BOUNCE_NULL		0
#define TE_BOUNCE_SHELL		1
#define TE_BOUNCE_SHOTSHELL		2

// Rendering constants
enum 
{	
	kRenderNormal,		// src
	kRenderTransColor,		// c*a+dest*(1-a)
	kRenderTransTexture,	// src*a+dest*(1-a)
	kRenderGlow,		// src*a+dest -- No Z buffer checks
	kRenderTransAlpha,		// src*srca+dest*(1-srca)
	kRenderTransAdd,		// src*a+dest
	kRenderWorldGlow		// Same as kRenderGlow but not fixed size in screen space
};

enum 
{	
	kRenderFxNone = 0, 
	kRenderFxPulseSlow, 
	kRenderFxPulseFast, 
	kRenderFxPulseSlowWide, 
	kRenderFxPulseFastWide, 
	kRenderFxFadeSlow, 
	kRenderFxFadeFast, 
	kRenderFxSolidSlow, 
	kRenderFxSolidFast, 	   
	kRenderFxStrobeSlow, 
	kRenderFxStrobeFast, 
	kRenderFxStrobeFaster, 
	kRenderFxFlickerSlow, 
	kRenderFxFlickerFast,
	kRenderFxNoDissipation,
	kRenderFxDistort,			// Distort/scale/translate flicker
	kRenderFxHologram,			// kRenderFxDistort + distance fade
	kRenderFxDeadPlayer,		// kRenderAmt is the player index
	kRenderFxExplode,			// Scale up really big!
	kRenderFxGlowShell,			// Glowing Shell
	kRenderFxClampMinScale		// Keep this sprite from getting very small (SPRITES only!)
};

typedef int		func_t;
typedef int		string_t;

typedef unsigned char	byte;
typedef unsigned short	word;

#undef true
#undef false

#ifndef __cplusplus
typedef enum { false, true }	qboolean;
#else 
typedef int qboolean;
#endif

typedef struct
{
	byte	r, g, b;
} color24;

typedef struct
{
	unsigned	r, g, b, a;
} colorVec;

typedef struct link_s
{
	struct link_s	*prev, *next;
} link_t;

typedef struct edict_s edict_t;

typedef struct
{
	vec3_t	normal;
	float	dist;
} plane_t;

typedef struct
{
	qboolean	allsolid;		// if true, plane is not valid
	qboolean	startsolid;	// if true, the initial point was in a solid area
	qboolean	inopen, inwater;
	float	fraction;		// time completed, 1.0 = didn't hit anything
	vec3_t	endpos;		// final position
	plane_t	plane;		// surface normal at impact
	edict_t	*ent;		// entity the surface is on
	int	hitgroup;		// 0 == generic, non zero is specific body part
} trace_t;

#endif//CONST_H

```

`common/crc.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
/* crc.h */
#ifndef CRC_H
#define CRC_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// MD5 Hash
typedef struct
{
	unsigned int buf[4];
    unsigned int bits[2];
    unsigned char in[64];
} MD5Context_t;


typedef unsigned long CRC32_t;
void CRC32_Init(CRC32_t *pulCRC);
CRC32_t CRC32_Final(CRC32_t pulCRC);
void CRC32_ProcessBuffer(CRC32_t *pulCRC, void *p, int len);
void CRC32_ProcessByte(CRC32_t *pulCRC, unsigned char ch);
int CRC_File(CRC32_t *crcvalue, char *pszFileName);

unsigned char COM_BlockSequenceCRCByte (unsigned char *base, int length, int sequence);

void MD5Init(MD5Context_t *context);
void MD5Update(MD5Context_t *context, unsigned char const *buf,
               unsigned int len);
void MD5Final(unsigned char digest[16], MD5Context_t *context);
void Transform(unsigned int buf[4], unsigned int const in[16]);

int MD5_Hash_File(unsigned char digest[16], char *pszFileName, int bUsefopen, int bSeed, unsigned int seed[4]);
char *MD5_Print(unsigned char hash[16]);
int MD5_Hash_CachedFile(unsigned char digest[16], unsigned char *pCache, int nFileSize, int bSeed, unsigned int seed[4]);

int CRC_MapFile(CRC32_t *crcvalue, char *pszFileName);

#endif

```

`common/cvardef.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CVARDEF_H
#define CVARDEF_H

#define	FCVAR_ARCHIVE		(1<<0)	// set to cause it to be saved to vars.rc
#define	FCVAR_USERINFO		(1<<1)	// changes the client's info string
#define	FCVAR_SERVER		(1<<2)	// notifies players when changed
#define FCVAR_EXTDLL		(1<<3)	// defined by external DLL
#define FCVAR_CLIENTDLL     (1<<4)  // defined by the client dll
#define FCVAR_PROTECTED     (1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY        (1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define FCVAR_PRINTABLEONLY (1<<7)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
#define FCVAR_UNLOGGED		(1<<8)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log

typedef struct cvar_s
{
	const char	*name;
	const char	*string;
	int		flags;
	float	value;
	struct cvar_s *next;
} cvar_t;


typedef int qboolean;

// WARNING: Private structure from Xash3D Engine. Use with caution
typedef struct convar_s
{
	// this part shared with cvar_t
	char		*name;
	char		*string;
	int		flags;
	float		value;
	struct convar_s	*next;

	// this part unique for convar_t
	int		integer;		// atoi( string )
	qboolean		modified;		// set each time the cvar is changed
	char		*reset_string;	// cvar_restart will reset to this value
	char		*latched_string;	// for CVAR_LATCH vars
	char		*description;	// variable descrition info
} convar_t;
#endif

```

`common/demo_api.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( DEMO_APIH )
#define DEMO_APIH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct demo_api_s
{
	int		( *IsRecording )	( void );
	int		( *IsPlayingback )	( void );
	int		( *IsTimeDemo )		( void );
	void	( *WriteBuffer )	( int size, unsigned char *buffer );
} demo_api_t;

extern demo_api_t demoapi;

#endif

```

`common/director_cmds.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// director_cmds.h
// sub commands for svc_director

#define DRC_ACTIVE				0	// tells client that he's an spectator and will get director command
#define DRC_STATUS				1	// send status infos about proxy 
#define DRC_CAMERA				2	// set the actual director camera position
#define DRC_EVENT				3	// informs the dircetor about ann important game event


#define DRC_FLAG_PRIO_MASK		0x0F	//	priorities between 0 and 15 (15 most important)
#define DRC_FLAG_SIDE			(1<<4)	
#define DRC_FLAG_DRAMATIC		(1<<5)



// commands of the director API function CallDirectorProc(...)

#define DRCAPI_NOP					0	// no operation
#define DRCAPI_ACTIVE				1	// de/acivates director mode in engine
#define DRCAPI_STATUS				2   // request proxy information
#define DRCAPI_SETCAM				3	// set camera n to given position and angle
#define DRCAPI_GETCAM				4	// request camera n position and angle
#define DRCAPI_DIRPLAY				5	// set director time and play with normal speed
#define DRCAPI_DIRFREEZE			6	// freeze directo at this time
#define DRCAPI_SETVIEWMODE			7	// overview or 4 cameras 
#define DRCAPI_SETOVERVIEWPARAMS	8	// sets parameter for overview mode
#define DRCAPI_SETFOCUS				9	// set the camera which has the input focus
#define DRCAPI_GETTARGETS			10	// queries engine for player list
#define DRCAPI_SETVIEWPOINTS		11	// gives engine all waypoints



```

`common/dlight.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( DLIGHTH )
#define DLIGHTH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct dlight_s
{
	vec3_t	origin;
	float	radius;
	color24	color;
	float	die;				// stop lighting after this time
	float	decay;				// drop this each second
	float	minlight;			// don't add when contributing less
	int		key;
	qboolean	dark;			// subtracts light instead of adding
} dlight_t;

#endif

```

`common/dll_state.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

//DLL State Flags

#define DLL_INACTIVE 0		// no dll
#define DLL_ACTIVE   1		// dll is running
#define DLL_PAUSED   2		// dll is paused
#define DLL_CLOSE    3		// closing down dll
#define DLL_TRANS    4 		// Level Transition

// DLL Pause reasons

#define DLL_NORMAL        0   // User hit Esc or something.
#define DLL_QUIT          4   // Quit now
#define DLL_RESTART       6   // Switch to launcher for linux, does a quit but returns 1

// DLL Substate info ( not relevant )
#define ENG_NORMAL         (1<<0)

```

`common/engine_launcher_api.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// engine/launcher interface
#if !defined( ENGINE_LAUNCHER_APIH )
#define ENGINE_LAUNCHER_APIH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

//typedef void ( *xcommand_t ) ( void );

#define RENDERTYPE_UNDEFINED	0
#define RENDERTYPE_SOFTWARE		1
#define RENDERTYPE_HARDWARE		2

#define ENGINE_LAUNCHER_API_VERSION 1

typedef struct engine_api_s
{
	int		version;
	int		rendertype;
	int		size;

	// Functions
	int		( *GetEngineState )				( void );
	void	( *Cbuf_AddText )				( char *text ); // append cmd at end of buf
	void	( *Cbuf_InsertText )			( char *text ); // insert cmd at start of buf
	void	( *Cmd_AddCommand )				( char *cmd_name, void ( *funcname )( void ) );
	int		( *Cmd_Argc )					( void );
	char	*( *Cmd_Args )					( void );
	char	*( *Cmd_Argv )					( int arg );
	void	( *Con_Printf )					( char *, ... );
	void	( *Con_SafePrintf )				( char *, ... );
	void	( *Cvar_Set )					( char *var_name, char *value );
	void	( *Cvar_SetValue )				( char *var_name, float value );
	int		( *Cvar_VariableInt )			( char *var_name );
	char	*( *Cvar_VariableString )		( char *var_name );
	float	( *Cvar_VariableValue )			( char *var_name );
	void	( *ForceReloadProfile )			( void );
	int		( *GetGameInfo )				( struct GameInfo_s *pGI, char *pszChannel );
	void	( *GameSetBackground )			( int bBack );
	void	( *GameSetState )				( int iState );
	void	( *GameSetSubState )			( int iState );
	int		( *GetPauseState )				( void );
	int		( *Host_Frame )					( float time, int iState, int *stateInfo );
	void	( *Host_GetHostInfo )			( float *fps, int *nActive, int *nSpectators, int *nMaxPlayers, char *pszMap );
	void	( *Host_Shutdown )				( void );
	int		( *Game_Init )					( char *lpCmdLine, unsigned char *pMem, int iSize, struct exefuncs_s *pef, void *, int );
	void	( *IN_ActivateMouse )			( void );
	void	( *IN_ClearStates )				( void );
	void	( *IN_DeactivateMouse )			( void );
	void	( *IN_MouseEvent )				( int mstate );
	void	( *Keyboard_ReturnToGame )		( void );
	void	( *Key_ClearStates )			( void );
	void	( *Key_Event )					( int key, int down );
	int		( *LoadGame )					( const char *pszSlot );
	void	( *S_BlockSound )				( void );
	void	( *S_ClearBuffer )				( void );
	void	( *S_GetDSPointer )				( struct IDirectSound **lpDS, struct IDirectSoundBuffer **lpDSBuf );
	void 	*( *S_GetWAVPointer )			( void );
	void	( *S_UnblockSound )				( void );
	int		( *SaveGame )					( const char *pszSlot, const char *pszComment );
	void	( *SetAuth )					( void *pobj );
	void	( *SetMessagePumpDisableMode )	( int bMode );
	void	( *SetPauseState )				( int bPause );
	void	( *SetStartupMode )				( int bMode );
	void	( *SNDDMA_Shutdown )			( void );
	void	( *Snd_AcquireBuffer )			( void );
	void	( *Snd_ReleaseBuffer )			( void );
	void	( *StoreProfile )				( void );
	double	( *Sys_FloatTime )				( void );
	void	( *VID_UpdateWindowVars )		( void *prc, int x, int y );
	void	( *VID_UpdateVID )				( struct viddef_s *pvid );

	// VGUI interfaces
	void	( *VGui_CallEngineSurfaceProc )	( void* hwnd, unsigned int msg, unsigned int wparam, long lparam );

	// notifications that the launcher is taking/giving focus to the engine
	void    ( *EngineTakingFocus )			( void );
	void    ( *LauncherTakingFocus )		( void );

#ifdef _WIN32
	// Only filled in by rendertype RENDERTYPE_HARDWARE
	void	( *GL_Init )					( void );
	int		( *GL_SetMode )					( HWND hwndGame, HDC *pmaindc, HGLRC *pbaseRC, int fD3D, const char *p, const char *pszCmdLine );
	void	( *GL_Shutdown )				( HWND hwnd, HDC hdc, HGLRC hglrc );

	void	( *QGL_D3DShared )				( struct tagD3DGlobals *d3dGShared );

	int		( WINAPI *glSwapBuffers )		( HDC dc );
	void	( *DirectorProc ) ( unsigned int cmd, void * params );
#else
	// NOT USED IN LINUX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	void	( *GL_Init )					( void );
	void	( *GL_SetMode )					( void );
	void	( *GL_Shutdown )				( void );
	void	( *QGL_D3DShared )				( void );
	void	( *glSwapBuffers )				( void );
	void	( *DirectorProc )				( void );
	// LINUX
#endif

} engine_api_t;

#endif // ENGINE_LAUNCHER_APIH

```

`common/entity_state.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( ENTITY_STATEH )
#define ENTITY_STATEH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// For entityType below
#define ENTITY_NORMAL		(1<<0)
#define ENTITY_BEAM			(1<<1)

// Entity state is used for the baseline and for delta compression of a packet of 
//  entities that is sent to a client.
typedef struct entity_state_s entity_state_t;

struct entity_state_s
{
// Fields which are filled in by routines outside of delta compression
	int			entityType;
	// Index into cl_entities array for this entity.
	int			number;      
	float		msg_time;

	// Message number last time the player/entity state was updated.
	int			messagenum;		

	// Fields which can be transitted and reconstructed over the network stream
	vec3_t		origin;
	vec3_t		angles;

	int			modelindex;
	int			sequence;
	float		frame;
	int			colormap;
	short		skin;
	short		solid;
	int			effects;
	float		scale;

	byte		eflags;
	
	// Render information
	int			rendermode;
	int			renderamt;
	color24		rendercolor;
	int			renderfx;

	int			movetype;
	float		animtime;
	float		framerate;
	int			body;
	byte		controller[4];
	byte		blending[4];
	vec3_t		velocity;

	// Send bbox down to client for use during prediction.
	vec3_t		mins;    
	vec3_t		maxs;

	int			aiment;
	// If owned by a player, the index of that player ( for projectiles ).
	int			owner; 

	// Friction, for prediction.
	float		friction;       
	// Gravity multiplier
	float		gravity;		

// PLAYER SPECIFIC
	int			team;
	int			playerclass;
	int			health;
	qboolean	spectator;  
	int         weaponmodel;
	int			gaitsequence;
	// If standing on conveyor, e.g.
	vec3_t		basevelocity;   
	// Use the crouched hull, or the regular player hull.
	int			usehull;		
	// Latched buttons last time state updated.
	int			oldbuttons;     
	// -1 = in air, else pmove entity number
	int			onground;		
	int			iStepLeft;
	// How fast we are falling
	float		flFallVelocity;  

	float		fov;
	int			weaponanim;

	// Parametric movement overrides
	vec3_t				startpos;
	vec3_t				endpos;
	float				impacttime;
	float				starttime;

	// For mods
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
};

#include "pm_info.h"

typedef struct clientdata_s
{
	vec3_t				origin;
	vec3_t				velocity;

	int					viewmodel;
	vec3_t				punchangle;
	int					flags;
	int					waterlevel;
	int					watertype;
	vec3_t				view_ofs;
	float				health;

	int					bInDuck;

	int					weapons; // remove?
	
	int					flTimeStepSound;
	int					flDuckTime;
	int					flSwimTime;
	int					waterjumptime;

	float				maxspeed;

	float				fov;
	int					weaponanim;

	int					m_iId;
	int					ammo_shells;
	int					ammo_nails;
	int					ammo_cells;
	int					ammo_rockets;
	float				m_flNextAttack;
	
	int					tfstate;

	int					pushmsec;

	int					deadflag;

	char				physinfo[ MAX_PHYSINFO_STRING ];

	// For mods
	int					iuser1;
	int					iuser2;
	int					iuser3;
	int					iuser4;
	float				fuser1;
	float				fuser2;
	float				fuser3;
	float				fuser4;
	vec3_t				vuser1;
	vec3_t				vuser2;
	vec3_t				vuser3;
	vec3_t				vuser4;
} clientdata_t;

#include "weaponinfo.h"

typedef struct local_state_s
{
	entity_state_t playerstate;
	clientdata_t   client;
	weapon_data_t  weapondata[ 32 ];
} local_state_t;

#endif // !ENTITY_STATEH

```

`common/entity_types.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// entity_types.h
#if !defined( ENTITY_TYPESH )
#define ENTITY_TYPESH

#define ET_NORMAL		0
#define ET_PLAYER		1
#define ET_TEMPENTITY	2
#define ET_BEAM			3
// BMODEL or SPRITE that was split across BSP nodes
#define ET_FRAGMENTED	4

#endif // !ENTITY_TYPESH

```

`common/enums.h`:

```h
/***
 *
 *	Copyright (c) 2009, Valve LLC. All rights reserved.
 *	
 *	This product contains software technology licensed from Id 
 *	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
 *	All Rights Reserved.
 *
 *   Use, distribution, and modification of this source code and/or resulting
 *   object code is restricted to non-commercial enhancements to products from
 *   Valve LLC.  All other use, distribution, or modification is prohibited
 *   without written permission from Valve LLC.
 *
 ****/

#ifndef ENUMS_H
#define ENUMS_H

typedef enum netsrc_s
	{
		NS_CLIENT,
		NS_SERVER,
		NS_MULTICAST	// xxxMO
	} netsrc_t;
	
#endif


```

`common/event_api.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( EVENT_APIH )
#define EVENT_APIH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#define EVENT_API_VERSION 1

typedef struct event_api_s
{
	int		version;
	void	( *EV_PlaySound ) ( int ent, float *origin, int channel, const char *sample, float volume, float attenuation, int fFlags, int pitch );
	void	( *EV_StopSound ) ( int ent, int channel, const char *sample );
	int		( *EV_FindModelIndex )( const char *pmodel );
	int		( *EV_IsLocal ) ( int playernum );
	int		( *EV_LocalPlayerDucking ) ( void );
	void	( *EV_LocalPlayerViewheight ) ( float * );
	void	( *EV_LocalPlayerBounds ) ( int hull, float *mins, float *maxs );
	int		( *EV_IndexFromTrace) ( struct pmtrace_s *pTrace );
	struct physent_s *( *EV_GetPhysent ) ( int idx );
	void	( *EV_SetUpPlayerPrediction ) ( int dopred, int bIncludeLocalClient );
	void	( *EV_PushPMStates ) ( void );
	void	( *EV_PopPMStates ) ( void );
	void	( *EV_SetSolidPlayers ) (int playernum);
	void	( *EV_SetTraceHull ) ( int hull );
	void	( *EV_PlayerTrace ) ( float *start, float *end, int traceFlags, int ignore_pe, struct pmtrace_s *tr );
	void	( *EV_WeaponAnimation ) ( int sequence, int body );
	unsigned short ( *EV_PrecacheEvent ) ( int type, const char* psz );
	void	( *EV_PlaybackEvent ) ( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	const char *( *EV_TraceTexture ) ( int ground, const float *vstart, const float *vend );
	void	( *EV_StopAllSounds ) ( int entnum, int entchannel );
	void    ( *EV_KillEvents ) ( int entnum, const char *eventname );
} event_api_t;

extern event_api_t eventapi;

#endif

```

`common/event_args.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( EVENT_ARGSH )
#define EVENT_ARGSH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// Event was invoked with stated origin
#define FEVENT_ORIGIN	( 1<<0 )

// Event was invoked with stated angles
#define FEVENT_ANGLES	( 1<<1 )

typedef struct event_args_s
{
	int		flags;

	// Transmitted
	int		entindex;

	float	origin[3];
	float	angles[3];
	float	velocity[3];

	int		ducking;

	float	fparam1;
	float	fparam2;

	int		iparam1;
	int		iparam2;

	int		bparam1;
	int		bparam2;
} event_args_t;

#endif

```

`common/event_flags.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( EVENT_FLAGSH )
#define EVENT_FLAGSH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// Skip local host for event send.
#define FEV_NOTHOST		(1<<0)    

// Send the event reliably.  You must specify the origin and angles and use
// PLAYBACK_EVENT_FULL for this to work correctly on the server for anything
// that depends on the event origin/angles.  I.e., the origin/angles are not
// taken from the invoking edict for reliable events.
#define FEV_RELIABLE	(1<<1)	 

// Don't restrict to PAS/PVS, send this event to _everybody_ on the server ( useful for stopping CHAN_STATIC
//  sounds started by client event when client is not in PVS anymore ( hwguy in TFC e.g. ).
#define FEV_GLOBAL		(1<<2)

// If this client already has one of these events in its queue, just update the event instead of sending it as a duplicate
//
#define FEV_UPDATE		(1<<3)

// Only send to entity specified as the invoker
#define	FEV_HOSTONLY	(1<<4)

// Only send if the event was created on the server.
#define FEV_SERVER		(1<<5)

// Only issue event client side ( from shared code )
#define FEV_CLIENT		(1<<6)

#endif

```

`common/exefuncs.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// exefuncs.h
#ifndef EXEFUNCS_H
#define EXEFUNCS_H

// Engine hands this to DLLs for functionality callbacks
typedef struct exefuncs_s
{
	int			fMMX;
	int			iCPUMhz;
	void		(*unused1)(void);
	void		(*unused2)(void);
	void		(*unused3)(void);
	void		(*unused4)(void);
	void		(*VID_ForceLockState)(int lk);
	int			(*VID_ForceUnlockedAndReturnState)(void);
	void		(*unused5)(void);
	void		(*unused6)(void);
	void		(*unused7)(void);
	void		(*unused8)(void);
	void		(*unused9)(void);
	void		(*unused10)(void);
	void		(*unused11)(void);
	void		(*unused12)(void);
	void		(*unused13)(void);
	void		(*unused14)(void);
	void		(*unused15)(void);
	void        (*ErrorMessage)(int nLevel, const char *pszErrorMessage);
	void		(*unused16)(void);
	void        (*Sys_Printf)(char *fmt, ...);
	void		(*unused17)(void);
	void		(*unused18)(void);
	void		(*unused19)(void);
	void		(*unused20)(void);
	void		(*unused21)(void);
	void		(*unused22)(void);
	void		(*unused23)(void);
	void		(*unused24)(void);
	void		(*unused25)(void);
	void		(*unused26)(void);
	void		(*unused27)(void);
} exefuncs_t;

#endif

```

`common/gameinfo.h`:

```h
/*
gameinfo.h - current game info
Copyright (C) 2010 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef GAMEINFO_H
#define GAMEINFO_H

#define GFL_NOMODELS	(1<<0)
#define GFL_NOSKILLS	(1<<1)
#define GFL_RENDER_PICBUTTON_TEXT   (1<<2)

/*
========================================================================

GAMEINFO stuff

internal shared gameinfo structure (readonly for engine parts)
========================================================================
*/
typedef struct
{
	// filesystem info
	char		gamefolder[64];	// used for change game '-game x'
	char		startmap[64];	// map to start singleplayer game
	char		trainmap[64];	// map to start hazard course (if specified)
	char		title[64];	// Game Main Title
	char		version[14];	// game version (optional)
	short		flags;		// game flags

	// about mod info
	char		game_url[256];	// link to a developer's site
	char		update_url[256];	// link to updates page
	char		type[64];		// single, toolkit, multiplayer etc
	char		date[64];
	char		size[64];		// displayed mod size

	int		gamemode;
} GAMEINFO;

#endif//GAMEINFO_H

```

`common/hltv.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// hltv.h
// all shared consts between server, clients and proxy

#ifndef HLTV_H
#define HLTV_H

#define TYPE_CLIENT				0	// client is a normal HL client (default)
#define TYPE_PROXY				1	// client is another proxy
#define TYPE_COMMENTATOR		3	// client is a commentator
#define TYPE_DEMO				4	// client is a demo file
// sub commands of svc_hltv:
#define HLTV_ACTIVE				0	// tells client that he's an spectator and will get director commands
#define HLTV_STATUS				1	// send status infos about proxy 
#define HLTV_LISTEN				2	// tell client to listen to a multicast stream

// sub commands of svc_director:
#define DRC_CMD_NONE				0	// NULL director command
#define DRC_CMD_START				1	// start director mode
#define DRC_CMD_EVENT				2	// informs about director command
#define DRC_CMD_MODE				3	// switches camera modes
#define DRC_CMD_CAMERA				4	// sets camera registers
#define DRC_CMD_TIMESCALE			5	// sets time scale
#define DRC_CMD_MESSAGE				6	// send HUD centerprint
#define DRC_CMD_SOUND				7	// plays a particular sound
#define DRC_CMD_STATUS				8	// status info about broadcast
#define DRC_CMD_BANNER				9	// banner file name for HLTV gui
#define	DRC_CMD_FADE				10	// send screen fade command
#define DRC_CMD_SHAKE				11	// send screen shake command
#define DRC_CMD_STUFFTEXT			12	// like the normal svc_stufftext but as director command

#define DRC_CMD_LAST				12



// HLTV_EVENT event flags
#define DRC_FLAG_PRIO_MASK		0x0F	// priorities between 0 and 15 (15 most important)
#define DRC_FLAG_SIDE			(1<<4)	// 
#define DRC_FLAG_DRAMATIC		(1<<5)	// is a dramatic scene
#define DRC_FLAG_SLOWMOTION		(1<<6)  // would look good in SloMo
#define DRC_FLAG_FACEPLAYER		(1<<7)  // player is doning something (reload/defuse bomb etc)
#define DRC_FLAG_INTRO			(1<<8)	// is a introduction scene
#define DRC_FLAG_FINAL			(1<<9)	// is a final scene
#define DRC_FLAG_NO_RANDOM		(1<<10)	// don't randomize event data


#define MAX_DIRECTOR_CMD_PARAMETERS		4
#define MAX_DIRECTOR_CMD_STRING			128


#endif // HLTV_H

```

`common/in_buttons.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef IN_BUTTONS_H
#define IN_BUTTONS_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif


#ifndef CONST_H
#define IN_ATTACK	(1 << 0)
#define IN_JUMP		(1 << 1)
#define IN_DUCK		(1 << 2)
#define IN_FORWARD	(1 << 3)
#define IN_BACK		(1 << 4)
#define IN_USE		(1 << 5)
#define IN_CANCEL	(1 << 6)
#define IN_LEFT		(1 << 7)
#define IN_RIGHT	(1 << 8)
#define IN_MOVELEFT	(1 << 9)
#define IN_MOVERIGHT (1 << 10)
#define IN_ATTACK2	(1 << 11)
#define IN_RUN      (1 << 12)
#define IN_RELOAD	(1 << 13)
#define IN_ALT1		(1 << 14)
#define IN_SCORE	(1 << 15)   // Used by client.dll for when scoreboard is held down
#endif

#endif // IN_BUTTONS_H

```

`common/interface.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "interface.h"

#if XASH_PSVITA == 1
#include <unistd.h>
#define VRTLD_LIBDL_COMPAT
#include <vrtld.h>
#elif XASH_APPLE == 1
#include <dlfcn.h>
#include <unistd.h>
#endif

#if !defined( _WIN32 )
// Linux doesn't have this function so this emulates its functionality
//
//
void *GetModuleHandle( const char *name )
{
	void *handle;

	if ( name == NULL )
	{
		// hmm, how can this be handled under linux....
		// is it even needed?
		return NULL;
	}

	if ( ( handle = dlopen( name, RTLD_NOW ) ) == NULL )
	{
		//printf("Error:%s\n",dlerror());
		// couldn't open this file
		return NULL;
	}

	// read "man dlopen" for details
	// in short dlopen() inc a ref count
	// so dec the ref count by performing the close
	dlclose( handle );
	return handle;
}
#endif

// ------------------------------------------------------------------------------------ //
// InterfaceReg.
// ------------------------------------------------------------------------------------ //
InterfaceReg *InterfaceReg::s_pInterfaceRegs = NULL;

InterfaceReg::InterfaceReg( InstantiateInterfaceFn fn, const char *pName ) :
    m_pName( pName )
{
	m_CreateFn = fn;
	m_pNext = s_pInterfaceRegs;
	s_pInterfaceRegs = this;
}

// ------------------------------------------------------------------------------------ //
// CreateInterface.
// ------------------------------------------------------------------------------------ //
EXPORT_FUNCTION IBaseInterface *CreateInterface( const char *pName, int *pReturnCode )
{
	InterfaceReg *pCur;

	for ( pCur = InterfaceReg::s_pInterfaceRegs; pCur; pCur = pCur->m_pNext )
	{
		if ( strcmp( pCur->m_pName, pName ) == 0 )
		{
			if ( pReturnCode )
			{
				*pReturnCode = IFACE_OK;
			}
			return pCur->m_CreateFn();
		}
	}

	if ( pReturnCode )
	{
		*pReturnCode = IFACE_FAILED;
	}
	return NULL;
}

#ifdef LINUX
static IBaseInterface *CreateInterfaceLocal( const char *pName, int *pReturnCode )
{
	InterfaceReg *pCur;

	for ( pCur = InterfaceReg::s_pInterfaceRegs; pCur; pCur = pCur->m_pNext )
	{
		if ( strcmp( pCur->m_pName, pName ) == 0 )
		{
			if ( pReturnCode )
			{
				*pReturnCode = IFACE_OK;
			}
			return pCur->m_CreateFn();
		}
	}

	if ( pReturnCode )
	{
		*pReturnCode = IFACE_FAILED;
	}
	return NULL;
}
#endif

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

//-----------------------------------------------------------------------------
// Purpose: returns a pointer to a function, given a module
// Input  : pModuleName - module name
//			*pName - proc name
//-----------------------------------------------------------------------------
//static hlds_run wants to use this function
static void *Sys_GetProcAddress( const char *pModuleName, const char *pName )
{
	return GetProcAddress( GetModuleHandle( pModuleName ), pName );
}

//-----------------------------------------------------------------------------
// Purpose: returns a pointer to a function, given a module
// Input  : pModuleName - module name
//			*pName - proc name
//-----------------------------------------------------------------------------
// hlds_run wants to use this function
void *Sys_GetProcAddress( void *pModuleHandle, const char *pName )
{
#if defined( _WIN32 )
	return GetProcAddress( (HINSTANCE)pModuleHandle, pName );
#else
	return GetProcAddress( pModuleHandle, pName );
#endif
}

//-----------------------------------------------------------------------------
// Purpose: Loads a DLL/component from disk and returns a handle to it
// Input  : *pModuleName - filename of the component
// Output : opaque handle to the module (hides system dependency)
//-----------------------------------------------------------------------------
CSysModule *Sys_LoadModule( const char *pModuleName )
{
#if defined( _WIN32 )
	HMODULE hDLL = LoadLibrary( pModuleName );
#else
	HMODULE hDLL = NULL;
	char szAbsoluteModuleName[1024];
	szAbsoluteModuleName[0] = 0;
	if ( pModuleName[0] != '/' )
	{
		char szCwd[1024];
		char szAbsoluteModuleName[1024];

		getcwd( szCwd, sizeof( szCwd ) );
		if ( szCwd[strlen( szCwd ) - 1] == '/' )
			szCwd[strlen( szCwd ) - 1] = 0;

		_snprintf( szAbsoluteModuleName, sizeof( szAbsoluteModuleName ), "%s/%s", szCwd, pModuleName );

		hDLL = dlopen( szAbsoluteModuleName, RTLD_NOW );
	}
	else
	{
		_snprintf( szAbsoluteModuleName, sizeof( szAbsoluteModuleName ), "%s", pModuleName );
		hDLL = dlopen( pModuleName, RTLD_NOW );
	}
#endif

	if ( !hDLL )
	{
		char str[512];
#if defined( _WIN32 )
		_snprintf( str, sizeof( str ), "%s.dll", pModuleName );
		hDLL = LoadLibrary( str );
#elif defined( __APPLE__ )
		printf( "Error:%s\n", dlerror() );
		_snprintf( str, sizeof( str ), "%s.dylib", szAbsoluteModuleName );
		hDLL = dlopen( str, RTLD_NOW );
#else
		printf( "Error:%s\n", dlerror() );
		_snprintf( str, sizeof( str ), "%s.so", szAbsoluteModuleName );
		hDLL = dlopen( str, RTLD_NOW );
#endif
	}

	return reinterpret_cast<CSysModule *>( hDLL );
}

//-----------------------------------------------------------------------------
// Purpose: Unloads a DLL/component from
// Input  : *pModuleName - filename of the component
// Output : opaque handle to the module (hides system dependency)
//-----------------------------------------------------------------------------
void Sys_UnloadModule( CSysModule *pModule )
{
	if ( !pModule )
		return;

	HMODULE hDLL = reinterpret_cast<HMODULE>( pModule );
#if defined( _WIN32 )
	FreeLibrary( hDLL );
#else
	dlclose( (void *)hDLL );
#endif
}

//-----------------------------------------------------------------------------
// Purpose: returns a pointer to a function, given a module
// Input  : module - windows HMODULE from Sys_LoadModule()
//			*pName - proc name
// Output : factory for this module
//-----------------------------------------------------------------------------
CreateInterfaceFn Sys_GetFactory( CSysModule *pModule )
{
	if ( !pModule )
		return NULL;

	HMODULE hDLL = reinterpret_cast<HMODULE>( pModule );
#if defined( _WIN32 )
	return reinterpret_cast<CreateInterfaceFn>( GetProcAddress( hDLL, CREATEINTERFACE_PROCNAME ) );
#else
	// Linux gives this error:
	//../public/interface.cpp: In function `IBaseInterface *(*Sys_GetFactory
	//(CSysModule *)) (const char *, int *)':
	//../public/interface.cpp:154: ISO C++ forbids casting between
	//pointer-to-function and pointer-to-object
	//
	// so lets get around it :)
	return (CreateInterfaceFn)( GetProcAddress( hDLL, CREATEINTERFACE_PROCNAME ) );
#endif
}

//-----------------------------------------------------------------------------
// Purpose: returns the instance of this module
// Output : interface_instance_t
//-----------------------------------------------------------------------------
CreateInterfaceFn Sys_GetFactoryThis( void )
{
#ifdef LINUX
	return CreateInterfaceLocal;
#else
	return CreateInterface;
#endif
}

//-----------------------------------------------------------------------------
// Purpose: returns the instance of the named module
// Input  : *pModuleName - name of the module
// Output : interface_instance_t - instance of that module
//-----------------------------------------------------------------------------
CreateInterfaceFn Sys_GetFactory( const char *pModuleName )
{
#if defined( _WIN32 )
	return static_cast<CreateInterfaceFn>( Sys_GetProcAddress( pModuleName, CREATEINTERFACE_PROCNAME ) );
#else
	// Linux gives this error:
	//../public/interface.cpp: In function `IBaseInterface *(*Sys_GetFactory
	//(const char *)) (const char *, int *)':
	//../public/interface.cpp:186: invalid static_cast from type `void *' to
	//type `IBaseInterface *(*) (const char *, int *)'
	//
	// so lets use the old style cast.
	return (CreateInterfaceFn)( Sys_GetProcAddress( pModuleName, CREATEINTERFACE_PROCNAME ) );
#endif
}
```

`common/interface.h`:

```h

// This header defines the interface convention used in the valve engine.
// To make an interface and expose it:
//    1. Derive from IBaseInterface.
//    2. The interface must be ALL pure virtuals, and have no data members.
//    3. Define a name for it.
//    4. In its implementation file, use EXPOSE_INTERFACE or EXPOSE_SINGLE_INTERFACE.

// Versioning
// There are two versioning cases that are handled by this:
// 1. You add functions to the end of an interface, so it is binary compatible with the previous interface. In this case,
//    you need two EXPOSE_INTERFACEs: one to expose your class as the old interface and one to expose it as the new interface.
// 2. You update an interface so it's not compatible anymore (but you still want to be able to expose the old interface
//    for legacy code). In this case, you need to make a new version name for your new interface, and make a wrapper interface and
//    expose it for the old interface.

//#if _MSC_VER >= 1300  // VC7
//#include "tier1/interface.h"
//#else

#ifndef __INTERFACE_H__
#define __INTERFACE_H__

#include "build.h"

#if XASH_LINUX == 1
#include <dlfcn.h> // dlopen,dlclose, et al
#include <unistd.h>
#endif

#if !defined( _WIN32 )
#define HMODULE        void *
#define GetProcAddress dlsym
#define _snprintf snprintf
#endif

void *Sys_GetProcAddress( void *pModuleHandle, const char *pName );

// All interfaces derive from this.
class IBaseInterface
{
public:
	virtual ~IBaseInterface() { }
};

#define CREATEINTERFACE_PROCNAME "CreateInterface"
typedef IBaseInterface *( *CreateInterfaceFn )( const char *pName, int *pReturnCode );

typedef IBaseInterface *( *InstantiateInterfaceFn )();

// Used internally to register classes.
class InterfaceReg
{
public:
	InterfaceReg( InstantiateInterfaceFn fn, const char *pName );

public:
	InstantiateInterfaceFn m_CreateFn;
	const char *m_pName;

	InterfaceReg *m_pNext; // For the global list.
	static InterfaceReg *s_pInterfaceRegs;
};

// Use this to expose an interface that can have multiple instances.
// e.g.:
// EXPOSE_INTERFACE( CInterfaceImp, IInterface, "MyInterface001" )
// This will expose a class called CInterfaceImp that implements IInterface (a pure class)
// clients can receive a pointer to this class by calling CreateInterface( "MyInterface001" )
//
// In practice, the shared header file defines the interface (IInterface) and version name ("MyInterface001")
// so that each component can use these names/vtables to communicate
//
// A single class can support multiple interfaces through multiple inheritance
//
// Use this if you want to write the factory function.
#define EXPOSE_INTERFACE_FN( functionName, interfaceName, versionName ) \
	static InterfaceReg __g_Create##className##_reg( functionName, versionName );

#define EXPOSE_INTERFACE( className, interfaceName, versionName )                                       \
	static IBaseInterface *__Create##className##_interface() { return (interfaceName *)new className; } \
	static InterfaceReg __g_Create##className##_reg( __Create##className##_interface, versionName );

// Use this to expose a singleton interface with a global variable you've created.
#define EXPOSE_SINGLE_INTERFACE_GLOBALVAR( className, interfaceName, versionName, globalVarName )                        \
	static IBaseInterface *__Create##className##interfaceName##_interface() { return (IBaseInterface *)&globalVarName; } \
	static InterfaceReg __g_Create##className##interfaceName##_reg( __Create##className##interfaceName##_interface, versionName );

// Use this to expose a singleton interface. This creates the global variable for you automatically.
#define EXPOSE_SINGLE_INTERFACE( className, interfaceName, versionName ) \
	static className __g_##className##_singleton;                        \
	EXPOSE_SINGLE_INTERFACE_GLOBALVAR( className, interfaceName, versionName, __g_##className##_singleton )

#ifdef _WIN32
#define EXPORT_FUNCTION __declspec( dllexport )
#else
	#define EXPORT_FUNCTION __attribute__((visibility("default")))
#endif

// This function is automatically exported and allows you to access any interfaces exposed with the above macros.
// if pReturnCode is set, it will return one of the following values
// extend this for other error conditions/code
enum
{
	IFACE_OK = 0,
	IFACE_FAILED
};

extern "C"
{
	EXPORT_FUNCTION IBaseInterface* CreateInterface(const char *pName, int *pReturnCode);
}

extern CreateInterfaceFn Sys_GetFactoryThis( void );

//-----------------------------------------------------------------------------
// UNDONE: This is obsolete, use the module load/unload/get instead!!!
//-----------------------------------------------------------------------------
extern CreateInterfaceFn Sys_GetFactory( const char *pModuleName );

// load/unload components
class CSysModule;

//-----------------------------------------------------------------------------
// Load & Unload should be called in exactly one place for each module
// The factory for that module should be passed on to dependent components for
// proper versioning.
//-----------------------------------------------------------------------------
extern CSysModule *Sys_LoadModule( const char *pModuleName );
extern void Sys_UnloadModule( CSysModule *pModule );

extern CreateInterfaceFn Sys_GetFactory( CSysModule *pModule );

#endif // __INTERFACE_H__
```

`common/ivoicetweak.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef IVOICETWEAK_H
#define IVOICETWEAK_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// These provide access to the voice controls.
typedef enum
{
	MicrophoneVolume=0,			// values 0-1.
	OtherSpeakerScale			// values 0-1. Scales how loud other players are.
} VoiceTweakControl;


typedef struct IVoiceTweak_s
{
	// These turn voice tweak mode on and off. While in voice tweak mode, the user's voice is echoed back
	// without sending to the server. 
	int				(*StartVoiceTweakMode)();	// Returns 0 on error.
	void			(*EndVoiceTweakMode)();
	
	// Get/set control values.
	void			(*SetControlFloat)(VoiceTweakControl iControl, float value);
	float			(*GetControlFloat)(VoiceTweakControl iControl);
} IVoiceTweak;


#endif // IVOICETWEAK_H

```

`common/kbutton.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#pragma once
#if !defined( KBUTTONH )
#define KBUTTONH

typedef struct kbutton_s
{
	int		down[2];		// key nums holding it down
	int		state;			// low bit is down state
} kbutton_t;

#endif // !KBUTTONH

```

`common/lightstyle.h`:

```h
/*
lightstyle.h - lighstyle description
Copyright (C) 2011 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef LIGHTSTYLE_H
#define LIGHTSTYLE_H

typedef struct
{
	char		pattern[256];
	float		map[256];
	int		length;
	float		value;
	qboolean		interp;		// allow to interpolate this lightstyle
	float		time;		// local time warranties that new style begins from the start, not mid or end of the sequence
} lightstyle_t;

#endif//LIGHTSTYLE_H
```

`common/mathlib.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// mathlib.h

typedef float vec_t;
typedef vec_t vec3_t[3];
typedef vec_t vec4_t[4];	// x,y,z,w
typedef vec_t vec5_t[5];

typedef short vec_s_t;
typedef vec_s_t vec3s_t[3];
typedef vec_s_t vec4s_t[4];	// x,y,z,w
typedef vec_s_t vec5s_t[5];

typedef	int	fixed4_t;
typedef	int	fixed8_t;
typedef	int	fixed16_t;

#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

struct mplane_s;

extern float vec3_origin[3];
extern	int nanmask;

#define	IS_NAN(x) (((*(int *)&x)&nanmask)==nanmask)

#ifndef VECTOR_H
	#define DotProduct(x,y) ((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
#endif

#define VectorSubtract(a,b,c) {(c)[0]=(a)[0]-(b)[0];(c)[1]=(a)[1]-(b)[1];(c)[2]=(a)[2]-(b)[2];}
#define VectorAdd(a,b,c) {(c)[0]=(a)[0]+(b)[0];(c)[1]=(a)[1]+(b)[1];(c)[2]=(a)[2]+(b)[2];}
#define VectorCopy(a,b) {(b)[0]=(a)[0];(b)[1]=(a)[1];(b)[2]=(a)[2];}
#define VectorClear(a) {(a)[0]=0.0;(a)[1]=0.0;(a)[2]=0.0;}

void VectorMA (const vec3_t veca, float scale, const vec3_t vecb, vec3_t vecc);

vec_t _DotProduct (vec3_t v1, vec3_t v2);
void _VectorSubtract (vec3_t veca, vec3_t vecb, vec3_t out);
void _VectorAdd (vec3_t veca, vec3_t vecb, vec3_t out);
void _VectorCopy (vec3_t in, vec3_t out);

int VectorCompare (const vec_t *v1, const vec_t *v2);
float Length (const vec_t *v);
void CrossProduct (const vec_t *v1, const vec_t *v2, vec_t *cross);
float VectorNormalize (vec_t *v);		// returns vector length
void VectorInverse (vec3_t v);
void VectorScale (const vec3_t in, vec_t scale, vec3_t out);
int Q_log2(int val);

void R_ConcatRotations (float in1[3][3], float in2[3][3], float out[3][3]);
void R_ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4]);

// Here are some "manual" INLINE routines for doing floating point to integer conversions
extern short new_cw, old_cw;

typedef union DLONG {
	int		i[2];
	double	d;
	float	f;
	} DLONG;

extern DLONG	dlong;

#if defined(_MSC_VER) && !defined(_WIN64)
void __inline set_fpu_cw(void)
{
_asm	
	{		wait
			fnstcw	old_cw
			wait
			mov		ax, word ptr old_cw
			or		ah, 0xc
			mov		word ptr new_cw,ax
			fldcw	new_cw
	}
}

int __inline quick_ftol(float f)
{
	_asm {
		// Assumes that we are already in chop mode, and only need a 32-bit int
		fld		DWORD PTR f
		fistp	DWORD PTR dlong
	}
	return dlong.i[0];
}

void __inline restore_fpu_cw(void)
{
	_asm	fldcw	old_cw
}
#else
#define set_fpu_cw() /* */
#define quick_ftol(f) ftol(f)
#define restore_fpu_cw() /* */
#endif

void FloorDivMod (double numer, double denom, int *quotient,
		int *rem);
fixed16_t Invert24To16(fixed16_t val);
int GreatestCommonDivisor (int i1, int i2);

void AngleVectors (const vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
void AngleVectorsTranspose (const vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
#define AngleIVectors	AngleVectorsTranspose

void AngleMatrix (const vec_t *angles, float (*matrix)[4] );
void AngleIMatrix (const vec3_t angles, float (*matrix)[4] );
void VectorTransform(const vec_t *in1, float (*in2)[4], vec_t *out);

void NormalizeAngles( vec_t *angles );
void InterpolateAngles( vec3_t start, vec3_t end, vec3_t output, float frac );
float AngleBetweenVectors( const vec3_t v1, const vec3_t v2 );


void VectorMatrix( vec3_t forward, vec3_t right, vec3_t up);
void VectorAngles( const vec_t *forward, vec_t *angles );

int InvertMatrix( const float * m, float *out );

int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, struct mplane_s *plane);
float anglemod(float a);

// up / down
#define	PITCH	0
// left / right
#define	YAW		1
// fall over
#define	ROLL	2


#define BOX_ON_PLANE_SIDE(emins, emaxs, p)	\
	(((p)->type < 3)?						\
	(										\
		((p)->dist <= (emins)[(p)->type])?	\
			1								\
		:									\
		(									\
			((p)->dist >= (emaxs)[(p)->type])?\
				2							\
			:								\
				3							\
		)									\
	)										\
	:										\
		BoxOnPlaneSide( (emins), (emaxs), (p)))

```

`common/net_api.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined( NET_APIH )
#define NET_APIH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#if !defined ( NETADRH )
#include "netadr.h"
#endif

#define NETAPI_REQUEST_SERVERLIST	( 0 )  // Doesn't need a remote address
#define NETAPI_REQUEST_PING			( 1 )
#define NETAPI_REQUEST_RULES		( 2 )
#define NETAPI_REQUEST_PLAYERS		( 3 )
#define NETAPI_REQUEST_DETAILS		( 4 )

// Set this flag for things like broadcast requests, etc. where the engine should not
//  kill the request hook after receiving the first response
#define FNETAPI_MULTIPLE_RESPONSE ( 1<<0 )

typedef void ( *net_api_response_func_t ) ( struct net_response_s *response );

#define NET_SUCCESS						( 0 )
#define NET_ERROR_TIMEOUT				( 1<<0 )
#define NET_ERROR_PROTO_UNSUPPORTED		( 1<<1 )
#define NET_ERROR_UNDEFINED				( 1<<2 )

typedef struct net_adrlist_s
{
	struct net_adrlist_s	*next;
	netadr_t				remote_address;
} net_adrlist_t;

typedef struct net_response_s
{
	// NET_SUCCESS or an error code
	int			error;

	// Context ID
	int			context;
	// Type
	int			type;

	// Server that is responding to the request
	netadr_t	remote_address;

	// Response RTT ping time
	double		ping;
	// Key/Value pair string ( separated by backlash \ characters )
	// WARNING:  You must copy this buffer in the callback function, because it is freed
	//  by the engine right after the call!!!!
	// ALSO:  For NETAPI_REQUEST_SERVERLIST requests, this will be a pointer to a linked list of net_adrlist_t's
	void		*response;
} net_response_t;

typedef struct net_status_s
{
		// Connected to remote server?  1 == yes, 0 otherwise
	int			connected; 
	// Client's IP address
	netadr_t	local_address;
	// Address of remote server
	netadr_t	remote_address;
	// Packet Loss ( as a percentage )
	int			packet_loss;
	// Latency, in seconds ( multiply by 1000.0 to get milliseconds )
	double		latency;
	// Connection time, in seconds
	double		connection_time;
	// Rate setting ( for incoming data )
	double		rate;
} net_status_t;

typedef struct net_api_s
{
	// APIs
	void		( *InitNetworking )( void );
	void		( *Status ) ( struct net_status_s *status );
	void		( *SendRequest) ( int context, int request, int flags, double timeout, struct netadr_s *remote_address, net_api_response_func_t response );
	void		( *CancelRequest ) ( int context );
	void		( *CancelAllRequests ) ( void );
	char		*( *AdrToString ) ( struct netadr_s *a );
	int			( *CompareAdr ) ( struct netadr_s *a, struct netadr_s *b );
	int			( *StringToAdr ) ( char *s, struct netadr_s *a );
	const char *( *ValueForKey ) ( const char *s, const char *key );
	void		( *RemoveKey ) ( char *s, const char *key );
	void		( *SetValueForKey ) (char *s, const char *key, const char *value, int maxsize );
} net_api_t;

extern net_api_t netapi;

#endif // NET_APIH

```

`common/netadr.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// netadr.h
#ifndef NETADR_H
#define NETADR_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef enum
{
	NA_UNUSED,
	NA_LOOPBACK,
	NA_BROADCAST,
	NA_IP,
	NA_IPX,
	NA_BROADCAST_IPX
} netadrtype_t;

typedef struct netadr_s
{
	netadrtype_t	type;
	unsigned char	ip[4];
	unsigned char	ipx[10];
	unsigned short	port;
} netadr_t;

#endif // NETADR_H

```

`common/nowin.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef INC_NOWIN_H
#define INC_NOWIN_H
#ifndef _WIN32

#include <unistd.h>

#endif //!_WIN32
#endif //INC_NOWIN_H

```

`common/particledef.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PARTICLEDEFH )
#define PARTICLEDEFH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef enum {
	pt_static, 
	pt_grav,
	pt_slowgrav,
	pt_fire,
	pt_explode,
	pt_explode2,
	pt_blob,
	pt_blob2,
	pt_vox_slowgrav,
	pt_vox_grav,
	pt_clientcustom   // Must have callback function specified
} ptype_t;

// !!! if this is changed, it must be changed in d_ifacea.h too !!!
typedef struct particle_s
{
// driver-usable fields
	vec3_t		org;
	short		color;
	short		packedColor;
// drivers never touch the following fields
	struct particle_s	*next;
	vec3_t		vel;
	float		ramp;
	float		die;
	ptype_t		type;
	void		(*deathfunc)( struct particle_s *particle );

	// for pt_clientcusttom, we'll call this function each frame
	void		(*callback)( struct particle_s *particle, float frametime );
	
	// For deathfunc, etc.
	unsigned char context;
} particle_t;

#endif

```

`common/pmtrace.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PMTRACEH )
#define PMTRACEH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct
{
	vec3_t	normal;
	float	dist;
} pmplane_t;

typedef struct pmtrace_s pmtrace_t;

struct pmtrace_s
{
	qboolean	allsolid;	      // if true, plane is not valid
	qboolean	startsolid;	      // if true, the initial point was in a solid area
	qboolean	inopen, inwater;  // End point is in empty space or in water
	float		fraction;		  // time completed, 1.0 = didn't hit anything
	vec3_t		endpos;			  // final position
	pmplane_t	plane;		      // surface normal at impact
	int			ent;			  // entity at impact
	vec3_t      deltavelocity;    // Change in player's velocity caused by impact.  
								  // Only run on server.
	int         hitgroup;
};

#endif

```

`common/port.h`:

```h
/*
port.h -- Portability Layer for Windows types
Copyright (C) 2015 Alibek Omarov

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#pragma once
#ifndef PORT_H
#define PORT_H

#include "build.h"

#ifdef XASH_VGUI
	#if !(defined(__i386__) || defined(_X86_) || defined(_WIN32))
	#error "VGUI is exists only for x86. You must disable VGUI flag or build Xash3D for x86 target."
    #endif
#endif

#ifndef _WIN32
	#if XASH_LINUX == 1
	#include <limits.h>
	#include <dlfcn.h>
	#endif

    #ifdef __APPLE__
		#include <sys/syslimits.h>
		#define OS_LIB_EXT "dylib"
    #else
		#ifdef __linux__
			#include <linux/limits.h>
		#endif
		#define OS_LIB_EXT "so"
    #endif

    #ifdef __ANDROID__
		#define XASH_THREADS
		#ifdef LOAD_HARDFP
			#define MENUDLL "libmenu_hardfp.so"
			#define CLIENTDLL "libclient_hardfp.so"
			#define SERVERDLL "libserver_hardfp.so"
		#else
			#define MENUDLL "libmenu.so"
			#define CLIENTDLL "libclient.so"
			#define SERVERDLL "libserver.so"
		#endif
		#define GAMEPATH "/sdcard/xash"
    #else
		#define MENUDLL "libxashmenu." OS_LIB_EXT
		#define CLIENTDLL "client." OS_LIB_EXT
		#ifdef PANDORA
			#define SERVERDLL "hl." OS_LIB_EXT
			#define LIBPATH "."
			#define GAMEPATH "."
		#endif
    #endif

	#define VGUI_SUPPORT_DLL "libvgui_support." OS_LIB_EXT

	#define TRUE	    1
	#define FALSE	    0

    // Windows-specific
    #define _stdcall
    #define __stdcall
    #define __cdecl
	#define _inline	    static inline
    #define O_BINARY    0		//In Linux O_BINARY didn't exist

    // Windows functions to Linux equivalent
	#define _mkdir( x )					mkdir( x, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH )
	#define LoadLibrary( x )			dlopen( x, RTLD_NOW )
	#define GetProcAddress( x, y )		dlsym( x, y )
	#define SetCurrentDirectory( x )	(!chdir( x ))
	#define FreeLibrary( x )			dlclose( x )
	#define MAKEWORD(a,b)				((short int)(((unsigned char)(a))|(((short int)((unsigned char)(b)))<<8)))
	#define max(a, b)  (((a) > (b)) ? (a) : (b))
	#define min(a, b)  (((a) < (b)) ? (a) : (b))
	#define tell(a)						lseek(a, 0, SEEK_CUR)

    typedef unsigned char   BYTE;
    typedef unsigned char   byte;
    typedef short int	    WORD;
    typedef unsigned int    DWORD;
    typedef long int	    LONG;
    typedef unsigned long int   ULONG;
    typedef long	    WPARAM;
    typedef unsigned int    LPARAM;

    typedef void* HANDLE;
    typedef void* HMODULE;
    typedef void* HINSTANCE;

    typedef char* LPSTR;

    typedef struct tagPOINT
    {
	int x, y;
    } POINT;
#else
	#define strcasecmp _stricmp
	#define strncasecmp _strnicmp
	#define open _open
	#define read _read

	// shut-up compiler warnings
	#pragma warning(disable : 4244)	// MIPS
	#pragma warning(disable : 4018)	// signed/unsigned mismatch
	#pragma warning(disable : 4305)	// truncation from const double to float
	#pragma warning(disable : 4115)	// named type definition in parentheses
	#pragma warning(disable : 4100)	// unreferenced formal parameter
	#pragma warning(disable : 4127)	// conditional expression is constant
	#pragma warning(disable : 4057)	// differs in indirection to slightly different base types
	#pragma warning(disable : 4201)	// nonstandard extension used
	#pragma warning(disable : 4706)	// assignment within conditional expression
	#pragma warning(disable : 4054)	// type cast' : from function pointer
	#pragma warning(disable : 4310)	// cast truncates constant value
	#pragma warning(disable : 4244) // 'argument': conversion from 'float' to 'int', possible loss of data

	#define HSPRITE WINAPI_HSPRITE
	#include <windows.h>
	#undef HSPRITE

    #define OS_LIB_EXT "dll"
    #define MENUDLL "menu." OS_LIB_EXT
    #define CLIENTDLL "client." OS_LIB_EXT
	#define VGUI_SUPPORT_DLL "../vgui_support." OS_LIB_EXT
#endif

#endif

```

`common/qfont.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( QFONTH )
#define QFONTH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// Font stuff

#define NUM_GLYPHS 256

typedef struct
{
	short startoffset;
	short charwidth;
} charinfo;

typedef struct qfont_s
{
	int 		width, height;
	int			rowcount;
	int			rowheight;
	charinfo	fontinfo[ NUM_GLYPHS ];
	byte 		data[4];
} qfont_t;

#endif // qfont.h

```

`common/r_efx.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( R_EFXH )
#define R_EFXH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// particle_t
#if !defined( PARTICLEDEFH )  
#include "particledef.h"
#endif

// BEAM
#if !defined( BEAMDEFH )
#include "beamdef.h"
#endif

// dlight_t
#if !defined ( DLIGHTH )
#include "dlight.h"
#endif

// cl_entity_t
#if !defined( CL_ENTITYH )
#include "cl_entity.h"
#endif

/*
// FOR REFERENCE, These are the built-in tracer colors.  Note, color 4 is the one
//  that uses the tracerred/tracergreen/tracerblue and traceralpha cvar settings
color24 gTracerColors[] =
{
	{ 255, 255, 255 },		// White
	{ 255, 0, 0 },			// Red
	{ 0, 255, 0 },			// Green
	{ 0, 0, 255 },			// Blue
	{ 0, 0, 0 },			// Tracer default, filled in from cvars, etc.
	{ 255, 167, 17 },		// Yellow-orange sparks
	{ 255, 130, 90 },		// Yellowish streaks (garg)
	{ 55, 60, 144 },		// Blue egon streak
	{ 255, 130, 90 },		// More Yellowish streaks (garg)
	{ 255, 140, 90 },		// More Yellowish streaks (garg)
	{ 200, 130, 90 },		// More red streaks (garg)
	{ 255, 120, 70 },		// Darker red streaks (garg)
};
*/

// Temporary entity array
#define TENTPRIORITY_LOW	0
#define TENTPRIORITY_HIGH	1

// TEMPENTITY flags
#define	FTENT_NONE				0x00000000
#define	FTENT_SINEWAVE			0x00000001
#define	FTENT_GRAVITY			0x00000002
#define FTENT_ROTATE			0x00000004
#define	FTENT_SLOWGRAVITY		0x00000008
#define FTENT_SMOKETRAIL		0x00000010
#define FTENT_COLLIDEWORLD		0x00000020
#define FTENT_FLICKER			0x00000040
#define FTENT_FADEOUT			0x00000080
#define FTENT_SPRANIMATE		0x00000100
#define FTENT_HITSOUND			0x00000200
#define FTENT_SPIRAL			0x00000400
#define FTENT_SPRCYCLE			0x00000800
#define FTENT_COLLIDEALL		0x00001000 // will collide with world and slideboxes
#define FTENT_PERSIST			0x00002000 // tent is not removed when unable to draw 
#define FTENT_COLLIDEKILL		0x00004000 // tent is removed upon collision with anything
#define FTENT_PLYRATTACHMENT	0x00008000 // tent is attached to a player (owner)
#define FTENT_SPRANIMATELOOP	0x00010000 // animating sprite doesn't die when last frame is displayed
#define FTENT_SPARKSHOWER		0x00020000
#define FTENT_NOMODEL			0x00040000 // Doesn't have a model, never try to draw ( it just triggers other things )
#define FTENT_CLIENTCUSTOM		0x00080000 // Must specify callback.  Callback function is responsible for killing tempent and updating fields ( unless other flags specify how to do things )
#define FTENT_BODYTRACE			0x00100000
#define FTENT_BODYGRAVITY		0x00200000

typedef struct tempent_s	TEMPENTITY;
typedef struct tempent_s
{
	int			flags;
	float		die;
	float		frameMax;
	float		x;
	float		y;
	float		z;
	float		fadeSpeed;
	float		bounceFactor;
	int			hitSound;
	void		( *hitcallback )	( struct tempent_s *ent, struct pmtrace_s *ptr );
	void		( *callback )		( struct tempent_s *ent, float frametime, float currenttime );
	TEMPENTITY	*next;
	int			priority;
	short		clientIndex;	// if attached, this is the index of the client to stick to
								// if COLLIDEALL, this is the index of the client to ignore
								// TENTS with FTENT_PLYRATTACHMENT MUST set the clientindex! 

	vec3_t		tentOffset;		// if attached, client origin + tentOffset = tent origin.
	cl_entity_t	entity;

	// baseline.origin		- velocity
	// baseline.renderamt	- starting fadeout intensity
	// baseline.angles		- angle velocity
} TEMPENTITY;

typedef struct efx_api_s efx_api_t;

struct efx_api_s
{
	particle_t  *( *R_AllocParticle )			( void ( *callback ) ( struct particle_s *particle, float frametime ) );
	void		( *R_BlobExplosion )			( float * org );
	void		( *R_Blood )					( float * org, float * dir, int pcolor, int speed );
	void		( *R_BloodSprite )				( float * org, int colorindex, int modelIndex, int modelIndex2, float size );
	void		( *R_BloodStream )				( float * org, float * dir, int pcolor, int speed );
	void		( *R_BreakModel )				( float *pos, float *size, float *dir, float random, float life, int count, int modelIndex, char flags );
	void		( *R_Bubbles )					( float * mins, float * maxs, float height, int modelIndex, int count, float speed );
	void		( *R_BubbleTrail )				( float * start, float * end, float height, int modelIndex, int count, float speed );
	void		( *R_BulletImpactParticles )	( float * pos );
	void		( *R_EntityParticles )			( struct cl_entity_s *ent );
	void		( *R_Explosion )				( float *pos, int model, float scale, float framerate, int flags );
	void		( *R_FizzEffect )				( struct cl_entity_s *pent, int modelIndex, int density );
	void		( *R_FireField ) 				( float * org, int radius, int modelIndex, int count, int flags, float life );
	void		( *R_FlickerParticles )			( float * org );
	void		( *R_FunnelSprite )				( float *org, int modelIndex, int reverse );
	void		( *R_Implosion )				( float * end, float radius, int count, float life );
	void		( *R_LargeFunnel )				( float * org, int reverse );
	void		( *R_LavaSplash )				( float * org );
	void		( *R_MultiGunshot )				( float * org, float * dir, float * noise, int count, int decalCount, int *decalIndices );
	void		( *R_MuzzleFlash )				( float *pos1, int type );
	void		( *R_ParticleBox )				( float *mins, float *maxs, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_ParticleBurst )			( float * pos, int size, int color, float life );
	void		( *R_ParticleExplosion )		( float * org );
	void		( *R_ParticleExplosion2 )		( float * org, int colorStart, int colorLength );
	void		( *R_ParticleLine )				( float * start, float *end, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_PlayerSprites )			( int client, int modelIndex, int count, int size );
	void		( *R_Projectile )				( float * origin, float * velocity, int modelIndex, int life, int owner, void (*hitcallback)( struct tempent_s *ent, struct pmtrace_s *ptr ) );
	void		( *R_RicochetSound )			( float * pos );
	void		( *R_RicochetSprite )			( float *pos, struct model_s *pmodel, float duration, float scale );
	void		( *R_RocketFlare )				( float *pos );
	void		( *R_RocketTrail )				( float * start, float * end, int type );
	void		( *R_RunParticleEffect )		( float * org, float * dir, int color, int count );
	void		( *R_ShowLine )					( float * start, float * end );
	void		( *R_SparkEffect )				( float *pos, int count, int velocityMin, int velocityMax );
	void		( *R_SparkShower )				( float *pos );
	void		( *R_SparkStreaks )				( float * pos, int count, int velocityMin, int velocityMax );
	void		( *R_Spray )					( float * pos, float * dir, int modelIndex, int count, int speed, int spread, int rendermode );
	void		( *R_Sprite_Explode )			( TEMPENTITY *pTemp, float scale, int flags );
	void		( *R_Sprite_Smoke )				( TEMPENTITY *pTemp, float scale );
	void		( *R_Sprite_Spray )				( float * pos, float * dir, int modelIndex, int count, int speed, int iRand );
	void		( *R_Sprite_Trail )				( int type, float * start, float * end, int modelIndex, int count, float life, float size, float amplitude, int renderamt, float speed );
	void		( *R_Sprite_WallPuff )			( TEMPENTITY *pTemp, float scale );
	void		( *R_StreakSplash )				( float * pos, float * dir, int color, int count, float speed, int velocityMin, int velocityMax );
	void		( *R_TracerEffect )				( float * start, float * end );
	void		( *R_UserTracerParticle )		( float * org, float * vel, float life, int colorIndex, float length, unsigned char deathcontext, void ( *deathfunc)( struct particle_s *particle ) );
	particle_t *( *R_TracerParticles )			( float * org, float * vel, float life );
	void		( *R_TeleportSplash )			( float * org );
	void		( *R_TempSphereModel )			( float *pos, float speed, float life, int count, int modelIndex );
	TEMPENTITY	*( *R_TempModel )				( float *pos, float *dir, float *angles, float life, int modelIndex, int soundtype );
	TEMPENTITY	*( *R_DefaultSprite )			( float *pos, int spriteIndex, float framerate );
	TEMPENTITY	*( *R_TempSprite )				( float *pos, float *dir, float scale, int modelIndex, int rendermode, int renderfx, float a, float life, int flags );
	int			( *Draw_DecalIndex )			( int id );
	int			( *Draw_DecalIndexFromName )	( char *name );
	void		( *R_DecalShoot )				( int textureIndex, int entity, int modelIndex, float * position, int flags );
	void		( *R_AttachTentToPlayer )		( int client, int modelIndex, float zoffset, float life );
	void		( *R_KillAttachedTents )		( int client );
	BEAM		*( *R_BeamCirclePoints )		( int type, float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEntPoint )			( int startEnt, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEnts )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamFollow )				( int startEnt, int modelIndex, float life, float width, float r, float g, float b, float brightness );
	void		( *R_BeamKill )					( int deadEntity );
	BEAM		*( *R_BeamLightning )			( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed );
	BEAM		*( *R_BeamPoints )				( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamRing )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	dlight_t	*( *CL_AllocDlight )			( int key );
	dlight_t	*( *CL_AllocElight )			( int key );
	TEMPENTITY	*( *CL_TempEntAlloc )			( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TempEntAllocNoModel )	( float * org );
	TEMPENTITY	*( *CL_TempEntAllocHigh )		( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TentEntAllocCustom )		( float *origin, struct model_s *model, int high, void ( *callback ) ( struct tempent_s *ent, float frametime, float currenttime ) );
	void		( *R_GetPackedColor )			( short *packed, short color );
	short		( *R_LookupColor )				( unsigned char r, unsigned char g, unsigned char b );
	void		( *R_DecalRemoveAll )			( int textureIndex ); //textureIndex points to the decal index in the array, not the actual texture index.
};

extern efx_api_t efx;

#endif

```

`common/r_studioint.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined( R_STUDIOINT_H )
#define R_STUDIOINT_H
#if defined( _WIN32 )
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#define STUDIO_INTERFACE_VERSION 1

typedef struct engine_studio_api_s
{
	// Allocate number*size bytes and zero it
	void			*( *Mem_Calloc )				( int number, size_t size );
	// Check to see if pointer is in the cache
	void			*( *Cache_Check )				( struct cache_user_s *c );
	// Load file into cache ( can be swapped out on demand )
	void			( *LoadCacheFile )				( char *path, struct cache_user_s *cu );
	// Retrieve model pointer for the named model
	struct model_s	*( *Mod_ForName )				( const char *name, int crash_if_missing );
	// Retrieve pointer to studio model data block from a model
	void			*( *Mod_Extradata )				( struct model_s *mod );
	// Retrieve indexed model from client side model precache list
	struct model_s	*( *GetModelByIndex )			( int index );
	// Get entity that is set for rendering
	struct cl_entity_s * ( *GetCurrentEntity )		( void );
	// Get referenced player_info_t
	struct player_info_s *( *PlayerInfo )			( int index );
	// Get most recently received player state data from network system
	struct entity_state_s *( *GetPlayerState )		( int index );
	// Get viewentity
	struct cl_entity_s * ( *GetViewEntity )			( void );
	// Get current frame count, and last two timestampes on client
	void			( *GetTimes )					( int *framecount, double *current, double *old );
	// Get a pointer to a cvar by name
	struct cvar_s	*( *GetCvar )					( const char *name );
	// Get current render origin and view vectors ( up, right and vpn )
	void			( *GetViewInfo )				( float *origin, float *upv, float *rightv, float *vpnv );
	// Get sprite model used for applying chrome effect
	struct model_s	*( *GetChromeSprite )			( void );
	// Get model counters so we can incement instrumentation
	void			( *GetModelCounters )			( int **s, int **a );
	// Get software scaling coefficients
	void			( *GetAliasScale )				( float *x, float *y );

	// Get bone, light, alias, and rotation matrices
	float			****( *StudioGetBoneTransform ) ( void );
	float			****( *StudioGetLightTransform )( void );
	float			***( *StudioGetAliasTransform ) ( void );
	float			***( *StudioGetRotationMatrix ) ( void );

	// Set up body part, and get submodel pointers
	void			( *StudioSetupModel )			( int bodypart, void **ppbodypart, void **ppsubmodel );
	// Check if entity's bbox is in the view frustum
	int				( *StudioCheckBBox )			( void );
	// Apply lighting effects to model
	void			( *StudioDynamicLight )			( struct cl_entity_s *ent, struct alight_s *plight );
	void			( *StudioEntityLight )			( struct alight_s *plight );
	void			( *StudioSetupLighting )		( struct alight_s *plighting );

	// Draw mesh vertices
	void			( *StudioDrawPoints )			( void );

	// Draw hulls around bones
	void			( *StudioDrawHulls )			( void );
	// Draw bbox around studio models
	void			( *StudioDrawAbsBBox )			( void );
	// Draws bones
	void			( *StudioDrawBones )			( void );
	// Loads in appropriate texture for model
	void			( *StudioSetupSkin )			( void *ptexturehdr, int index );
	// Sets up for remapped colors
	void			( *StudioSetRemapColors )		( int top, int bottom );
	// Set's player model and returns model pointer
	struct model_s	*( *SetupPlayerModel )			( int index );
	// Fires any events embedded in animation
	void			( *StudioClientEvents )			( void );
	// Retrieve/set forced render effects flags
	int				( *GetForceFaceFlags )			( void );
	void			( *SetForceFaceFlags )			( int flags );
	// Tell engine the value of the studio model header
	void			( *StudioSetHeader )			( void *header );
	// Tell engine which model_t * is being renderered
	void			( *SetRenderModel )				( struct model_s *model );

	// Final state setup and restore for rendering
	void			( *SetupRenderer )				( int rendermode );
	void			( *RestoreRenderer )			( void );

	// Set render origin for applying chrome effect
	void			( *SetChromeOrigin )			( void );

	// True if using D3D/OpenGL
	int				( *IsHardware )					( void );
	
	// Only called by hardware interface
	void			( *GL_StudioDrawShadow )		( void );
	void			( *GL_SetRenderMode )			( int mode );

	void		( *StudioSetRenderamt )( int iRenderamt );
	void		( *StudioSetCullState )( int iCull );
	void		( *StudioRenderShadow )( int iSprite, float *p1, float *p2, float *p3, float *p4 );
} engine_studio_api_t;

typedef struct server_studio_api_s
{
	// Allocate number*size bytes and zero it
	void			*( *Mem_Calloc )				( int number, size_t size );
	// Check to see if pointer is in the cache
	void			*( *Cache_Check )				( struct cache_user_s *c );
	// Load file into cache ( can be swapped out on demand )
	void			( *LoadCacheFile )				( char *path, struct cache_user_s *cu );
	// Retrieve pointer to studio model data block from a model
	void			*( *Mod_Extradata )				( struct model_s *mod );
} server_studio_api_t;


// client blending
typedef struct r_studio_interface_s
{
	int				version;
	int				( *StudioDrawModel	)			( int flags );
	int				( *StudioDrawPlayer	)			( int flags, struct entity_state_s *pplayer );
} r_studio_interface_t;

extern r_studio_interface_t *pStudioAPI;

// server blending
#define SV_BLENDING_INTERFACE_VERSION 1

typedef struct sv_blending_interface_s
{
	int	version;

	void	( *SV_StudioSetupBones )( struct model_s *pModel, 
					float frame,
					int sequence,
					const vec3_t angles,
					const vec3_t origin,
					const byte *pcontroller,
					const byte *pblending,
					int iBone,
					const edict_t *pEdict );
} sv_blending_interface_t;

#endif // R_STUDIOINT_H

```

`common/ref_params.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#ifndef REF_PARAMS_H
#define REF_PARAMS_H

typedef struct ref_params_s
{
	// output
	vec3_t		vieworg;
	vec3_t		viewangles;

	vec3_t		forward;
	vec3_t		right;
	vec3_t		up;

	// Client frametime;
	float		frametime;
	// Client time
	float		time;

	// Misc
	int		intermission;
	int		paused;
	int		spectator;
	int		onground;
	int		waterlevel;

	vec3_t		simvel;
	vec3_t		simorg;

	vec3_t		viewheight;
	float		idealpitch;

	vec3_t		cl_viewangles;
	int		health;
	vec3_t		crosshairangle;
	float		viewsize;

	vec3_t		punchangle;
	int		maxclients;
	int		viewentity;
	int		playernum;
	int		max_entities;
	int		demoplayback;
	int		hardware;
	int		smoothing;

	// Last issued usercmd
	struct usercmd_s	*cmd;

	// Movevars
	struct movevars_s	*movevars;

	int		viewport[4];	// the viewport coordinates x, y, width, height
	int		nextView;		// the renderer calls ClientDLL_CalcRefdef() and Renderview
					// so long in cycles until this value is 0 (multiple views)
	int		onlyClientDraw;	// if !=0 nothing is drawn by the engine except clientDraw functions
} ref_params_t;

// same as ref_params but for overview mode
typedef struct ref_overview_s
{
	vec3_t		origin;
	qboolean		rotated;

	float		xLeft;
	float		xRight;
	float		yTop;
	float		yBottom;
	float		zFar;
	float		zNear;
	float		flZoom;
} ref_overview_t;

// ref_viewpass_t->flags
#define RF_DRAW_WORLD	(1<<0)		// pass should draw the world (otherwise it's player menu model)
#define RF_DRAW_CUBEMAP	(1<<1)		// special 6x pass to render cubemap\skybox sides
#define RF_DRAW_OVERVIEW	(1<<2)		// overview mode is active
#define RF_ONLY_CLIENTDRAW	(1<<3)		// nothing is drawn by the engine except clientDraw functions

// intermediate struct for viewpass (or just a single frame)
typedef struct ref_viewpass_s
{
	int		viewport[4];	// size of new viewport
	vec3_t		vieworigin;	// view origin
	vec3_t		viewangles;	// view angles
	int		viewentity;	// entitynum (P2: Savior uses this)
	float		fov_x, fov_y;	// vertical & horizontal FOV
	int		flags;		// if !=0 nothing is drawn by the engine except clientDraw functions
} ref_viewpass_t;

#endif//REF_PARAMS_H
```

`common/render_api.h`:

```h
/*
render_api.h - Xash3D extension for client interface
Copyright (C) 2011 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef RENDER_API_H
#define RENDER_API_H

#include "lightstyle.h"
#include "dlight.h"

#define CL_RENDER_INTERFACE_VERSION	37	// Xash3D 1.0
#define MAX_STUDIO_DECALS		4096	// + unused space of BSP decals

// render info parms
#define PARM_TEX_WIDTH	1	// all parms with prefix 'TEX_' receive arg as texnum
#define PARM_TEX_HEIGHT	2	// otherwise it's not used
#define PARM_TEX_SRC_WIDTH	3
#define PARM_TEX_SRC_HEIGHT	4
#define PARM_TEX_SKYBOX	5	// second arg as skybox ordering num
#define PARM_TEX_SKYTEXNUM	6	// skytexturenum for quake sky
#define PARM_TEX_LIGHTMAP	7	// second arg as number 0 - 128
#define PARM_TEX_TARGET	8
#define PARM_TEX_TEXNUM	9
#define PARM_TEX_FLAGS	10
#define PARM_TEX_DEPTH	11	// 3D texture depth or 2D array num layers
//reserved
#define PARM_TEX_GLFORMAT	13	// get a texture GL-format
#define PARM_TEX_ENCODE	14	// custom encoding for DXT image
#define PARM_TEX_MIPCOUNT	15	// count of mipmaps (0 - autogenerated, 1 - disabled of mipmapping)
#define PARM_BSP2_SUPPORTED	16	// tell custom renderer what engine is support BSP2 in this build
#define PARM_SKY_SPHERE	17	// sky is quake sphere ?
#define PARAM_GAMEPAUSED	18	// game is paused
#define PARM_MAP_HAS_DELUXE	19	// map has deluxedata
#define PARM_MAX_ENTITIES	20
#define PARM_WIDESCREEN	21
#define PARM_FULLSCREEN	22
#define PARM_SCREEN_WIDTH	23
#define PARM_SCREEN_HEIGHT	24
#define PARM_CLIENT_INGAME	25
#define PARM_FEATURES	26	// same as movevars->features
#define PARM_ACTIVE_TMU	27	// for debug
#define PARM_LIGHTSTYLEVALUE	28	// second arg is stylenum
#define PARM_MAX_IMAGE_UNITS	29
#define PARM_CLIENT_ACTIVE	30
#define PARM_REBUILD_GAMMA	31	// if true lightmaps rebuilding for gamma change
#define PARM_DEDICATED_SERVER	32
#define PARM_SURF_SAMPLESIZE	33	// lightmap resolution per face (second arg interpret as facenumber)
#define PARM_GL_CONTEXT_TYPE	34	// opengl or opengles
#define PARM_GLES_WRAPPER	35	//
#define PARM_STENCIL_ACTIVE	36
#define PARM_WATER_ALPHA	37
#define PARM_TEX_MEMORY	38	// returns total memory of uploaded texture in bytes
#define PARM_DELUXEDATA	39	// nasty hack, convert int to pointer
#define PARM_SHADOWDATA	40	// nasty hack, convert int to pointer

// skybox ordering
enum
{
	SKYBOX_RIGHT	= 0,
	SKYBOX_BACK,
	SKYBOX_LEFT,
	SKYBOX_FORWARD,
	SKYBOX_UP,
	SKYBOX_DOWN,
};

typedef enum
{
	TF_COLORMAP	= 0,		// just for tabulate source
	TF_NEAREST	= (1<<0),		// disable texfilter
	TF_KEEP_SOURCE	= (1<<1),		// some images keep source
	TF_NOFLIP_TGA	= (1<<2),		// Steam background completely ignore tga attribute 0x20
	TF_EXPAND_SOURCE	= (1<<3),		// Don't keep source as 8-bit expand to RGBA
// reserved
	TF_RECTANGLE	= (1<<5),		// this is GL_TEXTURE_RECTANGLE
	TF_CUBEMAP	= (1<<6),		// it's cubemap texture
	TF_DEPTHMAP	= (1<<7),		// custom texture filter used
	TF_QUAKEPAL	= (1<<8),		// image has an quake1 palette
	TF_LUMINANCE	= (1<<9),		// force image to grayscale
	TF_SKYSIDE	= (1<<10),	// this is a part of skybox
	TF_CLAMP		= (1<<11),	// clamp texcoords to [0..1] range
	TF_NOMIPMAP	= (1<<12),	// don't build mips for this image
	TF_HAS_LUMA	= (1<<13),	// sets by GL_UploadTexture
	TF_MAKELUMA	= (1<<14),	// create luma from quake texture (only q1 textures contain luma-pixels)
	TF_NORMALMAP	= (1<<15),	// is a normalmap
	TF_HAS_ALPHA	= (1<<16),	// image has alpha (used only for GL_CreateTexture)
	TF_FORCE_COLOR	= (1<<17),	// force upload monochrome textures as RGB (detail textures)
	TF_UPDATE		= (1<<18),	// allow to update already loaded texture
	TF_BORDER		= (1<<19),	// zero clamp for projected textures
	TF_TEXTURE_3D	= (1<<20),	// this is GL_TEXTURE_3D
	TF_ATLAS_PAGE	= (1<<21),	// bit who indicate lightmap page or deluxemap page
	TF_ALPHACONTRAST	= (1<<22),	// special texture mode for A2C
// reserved
// reserved
	TF_IMG_UPLOADED	= (1<<25),	// this is set for first time when called glTexImage, otherwise it will be call glTexSubImage
	TF_ARB_FLOAT	= (1<<26),	// float textures
	TF_NOCOMPARE	= (1<<27),	// disable comparing for depth textures
	TF_ARB_16BIT	= (1<<28),	// keep image as 16-bit (not 24)
	TF_MULTISAMPLE	= (1<<29)	// multisampling texture
} texFlags_t;

typedef enum
{
	CONTEXT_TYPE_GL = 0, // compatibility profile
	CONTEXT_TYPE_GLES_1_X,
	CONTEXT_TYPE_GLES_2_X,
	CONTEXT_TYPE_GL_CORE
} gl_context_type_t;

typedef enum
{
	GLES_WRAPPER_NONE = 0,		// native GL
	GLES_WRAPPER_NANOGL,		// used on GLES platforms
	GLES_WRAPPER_WES,		// used on GLES platforms
	GLES_WRAPPER_GL4ES,		// used on GLES platforms
} gles_wrapper_t;

// 30 bytes here
typedef struct modelstate_s
{
	short		sequence;
	short		frame;		// 10 bits multiple by 4, should be enough
	byte		blending[2];
	byte		controller[4];
	byte		poseparam[16];
	byte		body;
	byte		skin;
	short		scale;		// model scale (multiplied by 16)
} modelstate_t;

typedef struct decallist_s
{
	vec3_t		position;
	char		name[64];
	short		entityIndex;
	byte		depth;
	byte		flags;
	float		scale;

	// this is the surface plane that we hit so that
	// we can move certain decals across
	// transitions if they hit similar geometry
	vec3_t		impactPlaneNormal;

	modelstate_t	studio_state;	// studio decals only
} decallist_t;

struct ref_viewpass_s;

typedef struct render_api_s
{
	// Get renderer info (doesn't changes engine state at all)
	intptr_t	(*RenderGetParm)( int parm, int arg );	// generic
	void		(*GetDetailScaleForTexture)( int texture, float *xScale, float *yScale );
	void		(*GetExtraParmsForTexture)( int texture, byte *red, byte *green, byte *blue, byte *alpha );
	lightstyle_t*	(*GetLightStyle)( int number );
	dlight_t*		(*GetDynamicLight)( int number );
	dlight_t*		(*GetEntityLight)( int number );
	byte		(*LightToTexGamma)( byte color );	// software gamma support
	float		(*GetFrameTime)( void );

	// Set renderer info (tell engine about changes)
	void		(*R_SetCurrentEntity)( struct cl_entity_s *ent ); // tell engine about both currententity and currentmodel
	void		(*R_SetCurrentModel)( struct model_s *mod );	// change currentmodel but leave currententity unchanged
	int		(*R_FatPVS)( const float *org, float radius, byte *visbuffer, qboolean merge, qboolean fullvis );
	void		(*R_StoreEfrags)( struct efrag_s **ppefrag, int framecount );// store efrags for static entities

	// Texture tools
	int		(*GL_FindTexture)( const char *name );
	const char*	(*GL_TextureName)( unsigned int texnum );
	const byte*	(*GL_TextureData)( unsigned int texnum ); // may be NULL
	int		(*GL_LoadTexture)( const char *name, const byte *buf, size_t size, int flags );
	int		(*GL_CreateTexture)( const char *name, int width, int height, const void *buffer, texFlags_t flags );
	int		(*GL_LoadTextureArray)( const char **names, int flags );
	int		(*GL_CreateTextureArray)( const char *name, int width, int height, int depth, const void *buffer, texFlags_t flags );
	void		(*GL_FreeTexture)( unsigned int texnum );

	// Decals manipulating (draw & remove)
	void		(*DrawSingleDecal)( struct decal_s *pDecal, struct msurface_s *fa );
	float		*(*R_DecalSetupVerts)( struct decal_s *pDecal, struct msurface_s *surf, int texture, int *outCount );
	void		(*R_EntityRemoveDecals)( struct model_s *mod ); // remove all the decals from specified entity (BSP only)

	// AVIkit support
	void		*(*AVI_LoadVideo)( const char *filename, qboolean load_audio );
	int		(*AVI_GetVideoInfo)( void *Avi, int *xres, int *yres, float *duration ); // a1ba: changed longs to int
	int		(*AVI_GetVideoFrameNumber)( void *Avi, float time );
	byte		*(*AVI_GetVideoFrame)( void *Avi, int frame );
	void		(*AVI_UploadRawFrame)( int texture, int cols, int rows, int width, int height, const byte *data );
	void		(*AVI_FreeVideo)( void *Avi );
	int		(*AVI_IsActive)( void *Avi );
	void		(*AVI_StreamSound)( void *Avi, int entnum, float fvol, float attn, float synctime );
	void		(*AVI_Reserved0)( void );	// for potential interface expansion without broken compatibility
	void		(*AVI_Reserved1)( void );

	// glState related calls (must use this instead of normal gl-calls to prevent de-synchornize local states between engine and the client)
	void		(*GL_Bind)( int tmu, unsigned int texnum );
	void		(*GL_SelectTexture)( int tmu );
	void		(*GL_LoadTextureMatrix)( const float *glmatrix );
	void		(*GL_TexMatrixIdentity)( void );
	void		(*GL_CleanUpTextureUnits)( int last );	// pass 0 for clear all the texture units
	void		(*GL_TexGen)( unsigned int coord, unsigned int mode );
	void		(*GL_TextureTarget)( unsigned int target ); // change texture unit mode without bind texture
	void		(*GL_TexCoordArrayMode)( unsigned int texmode );
	void*		(*GL_GetProcAddress)( const char *name );
	void		(*GL_UpdateTexSize)( int texnum, int width, int height, int depth ); // recalc statistics
	void		(*GL_Reserved0)( void );	// for potential interface expansion without broken compatibility
	void		(*GL_Reserved1)( void );

	// Misc renderer functions
	void		(*GL_DrawParticles)( const struct ref_viewpass_s *rvp, qboolean trans_pass, float frametime );
	void		(*EnvShot)( const float *vieworg, const char *name, qboolean skyshot, int shotsize ); // store skybox into gfx\env folder
	int		(*SPR_LoadExt)( const char *szPicName, unsigned int texFlags ); // extended version of SPR_Load
	colorVec		(*LightVec)( const float *start, const float *end, float *lightspot, float *lightvec );
	struct mstudiotex_s *( *StudioGetTexture )( struct cl_entity_s *e );
	const struct ref_overview_s *( *GetOverviewParms )( void );
	const char	*( *GetFileByIndex )( int fileindex );
	int		(*pfnSaveFile)( const char *filename, const void *data, int len );
	void		(*R_Reserved0)( void );

	// static allocations
	void		*(*pfnMemAlloc)( size_t cb, const char *filename, const int fileline );
	void		(*pfnMemFree)( void *mem, const char *filename, const int fileline );

 	// engine utils (not related with render API but placed here)
	char		**(*pfnGetFilesList)( const char *pattern, int *numFiles, int gamedironly );
	unsigned int	(*pfnFileBufferCRC32)( const void *buffer, const int length );
	int		(*COM_CompareFileTime)( const char *filename1, const char *filename2, int *iCompare );
	void		(*Host_Error)( const char *error, ... ); // cause Host Error
	void*		( *pfnGetModel )( int modelindex );
	float		(*pfnTime)( void );				// Sys_DoubleTime
	void		(*Cvar_Set)( const char *name, const char *value );
	void		(*S_FadeMusicVolume)( float fadePercent );	// fade background track (0-100 percents)
	// a1ba: changed long to int
	void		(*SetRandomSeed)( int lSeed );		// set custom seed for RANDOM_FLOAT\RANDOM_LONG for predictable random
	// ONLY ADD NEW FUNCTIONS TO THE END OF THIS STRUCT.  INTERFACE VERSION IS FROZEN AT 37
} render_api_t;

// render callbacks
typedef struct render_interface_s
{
	int		version;
	// passed through R_RenderFrame (0 - use engine renderer, 1 - use custom client renderer)
	int		(*GL_RenderFrame)( const struct ref_viewpass_s *rvp );
	// build all the lightmaps on new level or when gamma is changed
	void		(*GL_BuildLightmaps)( void );
	// setup map bounds for ortho-projection when we in dev_overview mode
	void		(*GL_OrthoBounds)( const float *mins, const float *maxs );
	// prepare studio decals for save
	int		(*R_CreateStudioDecalList)( decallist_t *pList, int count );
	// clear decals by engine request (e.g. for demo recording or vid_restart)
	void		(*R_ClearStudioDecals)( void );
	// grab r_speeds message
	qboolean	(*R_SpeedsMessage)( char *out, size_t size );
	// alloc or destroy model custom data
	void		(*Mod_ProcessUserData)( struct model_s *mod, qboolean create, const byte *buffer );
	// alloc or destroy entity custom data
	void		(*R_ProcessEntData)( qboolean allocate );
	// get visdata for current frame from custom renderer
	byte*		(*Mod_GetCurrentVis)( void );
	// tell the renderer what new map is started
	void		(*R_NewMap)( void );
	// clear the render entities before each frame
	void		(*R_ClearScene)( void );
	// shuffle previous & next states for lerping
	void		(*CL_UpdateLatchedVars)( struct cl_entity_s *e, qboolean reset );
} render_interface_t;

#endif//RENDER_API_H
```

`common/screenfade.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined( SCREENFADEH )
#define SCREENFADEH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct screenfade_s
{
	float		fadeSpeed;		// How fast to fade (tics / second) (+ fade in, - fade out)
	float		fadeEnd;		// When the fading hits maximum
	float		fadeTotalEnd;	// Total End Time of the fade (used for FFADE_OUT)
	float		fadeReset;		// When to reset to not fading (for fadeout and hold)
	byte		fader, fadeg, fadeb, fadealpha;	// Fade color
	int			fadeFlags;		// Fading flags
} screenfade_t;

#endif // !SCREENFADEH

```

`common/studio_event.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( STUDIO_EVENTH )
#define STUDIO_EVENTH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct mstudioevent_s
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;

#endif // STUDIO_EVENTH

```

`common/triangleapi.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( TRIANGLEAPIH )
#define TRIANGLEAPIH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef enum 
{
	TRI_FRONT = 0,
	TRI_NONE = 1,
} TRICULLSTYLE;

#define TRI_API_VERSION		1

#define TRI_TRIANGLES		0
#define TRI_TRIANGLE_FAN	1
#define TRI_QUADS			2
#define TRI_POLYGON			3
#define TRI_LINES			4	
#define TRI_TRIANGLE_STRIP	5
#define TRI_QUAD_STRIP		6
#define TRI_POINTS			7 // Xash3D added

typedef struct triangleapi_s
{
	int			version;

	void		( *RenderMode )( int mode );
	void		( *Begin )( int primitiveCode );
	void		( *End ) ( void );

	void		( *Color4f ) ( float r, float g, float b, float a );
	void		( *Color4ub ) ( unsigned char r, unsigned char g, unsigned char b, unsigned char a );
	void		( *TexCoord2f ) ( float u, float v );
	void		( *Vertex3fv ) ( float *worldPnt );
	void		( *Vertex3f ) ( float x, float y, float z );
	void		( *Brightness ) ( float brightness );
	void		( *CullFace ) ( TRICULLSTYLE style );
	int			( *SpriteTexture ) ( struct model_s *pSpriteModel, int frame );
	int			( *WorldToScreen ) ( float *world, float *screen );  // Returns 1 if it's z clipped
	void		( *Fog ) ( float flFogColor[3], float flStart, float flEnd, int bOn ); //Works just like GL_FOG, flFogColor is r/g/b.
	void		( *ScreenToWorld ) ( float *screen, float *world  ); 
	void	(*GetMatrix)( const int pname, float *matrix );
	int	(*BoxInPVS)( float *mins, float *maxs );
	void	(*LightAtPoint)( float *pos, float *value );
	void	(*Color4fRendermode)( float r, float g, float b, float a, int rendermode );
	void	(*FogParams)( float flDensity, int iFogSkybox );


} triangleapi_t;

#endif // !TRIANGLEAPIH

```

`common/usercmd.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef USERCMD_H
#define USERCMD_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct usercmd_s
{
	short	lerp_msec;      // Interpolation time on client
	byte	msec;           // Duration in ms of command
	vec3_t	viewangles;     // Command view angles.

// intended velocities
	float	forwardmove;    // Forward velocity.
	float	sidemove;       // Sideways velocity.
	float	upmove;         // Upward velocity.
	byte	lightlevel;     // Light level at spot where we are standing.
	unsigned short  buttons;  // Attack buttons
	byte    impulse;          // Impulse command issued.
	byte	weaponselect;	// Current weapon id

// Experimental player impact stuff.
	int		impact_index;
	vec3_t	impact_position;
} usercmd_t;

#endif // USERCMD_H

```

`common/weaponinfo.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( WEAPONINFOH )
#define WEAPONINFOH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// Info about weapons player might have in his/her possession
typedef struct weapon_data_s
{
	int			m_iId;
	int			m_iClip;

	float		m_flNextPrimaryAttack;
	float		m_flNextSecondaryAttack;
	float		m_flTimeWeaponIdle;

	int			m_fInReload;
	int			m_fInSpecialReload;
	float		m_flNextReload;
	float		m_flPumpTime;
	float		m_fReloadTime;

	float		m_fAimedDamage;
	float		m_fNextAimBonus;
	int			m_fInZoom;
	int			m_iWeaponState;

	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
} weapon_data_t;

#endif

```

`common/wrect.h`:

```h
/*
wrect.h - rectangle definition
Copyright (C) 2010 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef WRECT_H
#define WRECT_H

typedef struct wrect_s
{
	int	left, right, top, bottom;
} wrect_t;

#endif//WRECT_H
```

`common/xash3d_types.h`:

```h
// basic typedefs
#ifndef XASH_TYPES_H
#define XASH_TYPES_H

#include "build.h"

#if XASH_IRIX
#include <port.h>
#endif

#if XASH_WIN32
#include <wchar.h> // off_t
#endif // _WIN32

#include <sys/types.h> // off_t
#include STDINT_H
#include <assert.h>

typedef uint8_t  byte;
typedef float    vec_t;
typedef vec_t    vec2_t[2];
typedef vec_t    vec3_t[3];
typedef vec_t    vec4_t[4];
typedef vec_t    quat_t[4];
typedef byte     rgba_t[4];	// unsigned byte colorpack
typedef byte     rgb_t[3];		// unsigned byte colorpack
typedef vec_t    matrix3x4[3][4];
typedef vec_t    matrix4x4[4][4];
typedef uint32_t poolhandle_t;

#undef true
#undef false

// true and false are keywords in C++ and C23
#if !__cplusplus &&  __STDC_VERSION__ < 202311L
enum { false, true };
#endif
typedef int qboolean;

#define MAX_STRING    256  // generic string
#define MAX_VA_STRING 1024 // compatibility macro
#define MAX_SYSPATH   1024 // system filepath
#define MAX_MODS      512  // environment games that engine can keep visible

#define BIT( n )		( 1U << ( n ))
#define BIT64( n )		( 1ULL << ( n ))
#define SetBits( iBitVector, bits )	((iBitVector) = (iBitVector) | (bits))
#define ClearBits( iBitVector, bits )	((iBitVector) = (iBitVector) & ~(bits))
#define FBitSet( iBitVector, bit )	((iBitVector) & (bit))

#ifndef __cplusplus
#ifdef NULL
#undef NULL
#endif

#define NULL		((void *)0)
#endif

// color strings
#define IsColorString( p )	( p && *( p ) == '^' && *(( p ) + 1) && *(( p ) + 1) >= '0' && *(( p ) + 1 ) <= '9' )
#define ColorIndex( c )	((( c ) - '0' ) & 7 )

#if defined( __GNUC__ )
	#if defined( __i386__ )
		#define EXPORT         __attribute__(( visibility( "default" ), force_align_arg_pointer ))
		#define GAME_EXPORT    __attribute__(( force_align_arg_pointer ))
	#else
		#define EXPORT         __attribute__(( visibility ( "default" )))
		#define GAME_EXPORT
	#endif

	#define MALLOC __attribute__(( malloc ))

	// added in GCC 11
	#if __GNUC__ >= 11
		// might want to set noclone due to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=116893
		// but it's easier to not force mismatched-dealloc to error yet
		#define MALLOC_LIKE( x, y ) __attribute__(( malloc( x, y )))
	#else
		#define MALLOC_LIKE( x, y ) MALLOC
	#endif
	#define NORETURN           __attribute__(( noreturn ))
	#define NONNULL            __attribute__(( nonnull ))
	#define RETURNS_NONNULL    __attribute__(( returns_nonnull ))
	#if __clang__
		#define PFN_RETURNS_NONNULL // clang has bugged returns_nonnull for functions pointers, it's ignored and generates a warning about objective-c? O_o
	#else
		#define PFN_RETURNS_NONNULL RETURNS_NONNULL
	#endif
	#define FORMAT_CHECK( x )  __attribute__(( format( printf, x, x + 1 )))
	#define ALLOC_CHECK( x )   __attribute__(( alloc_size( x )))
	#define NO_ASAN            __attribute__(( no_sanitize( "address" )))
	#define WARN_UNUSED_RESULT __attribute__(( warn_unused_result ))
	#define RENAME_SYMBOL( x ) asm( x )
#else
	#if defined( _MSC_VER )
		#define EXPORT         __declspec( dllexport )
		#define NO_ASAN        __declspec( no_sanitize_address )
	#else
		#define EXPORT
		#define NO_ASAN
	#endif
	#define GAME_EXPORT
	#define NORETURN
	#define NONNULL
	#define RETURNS_NONNULL
	#define PFN_RETURNS_NONNULL
	#define FORMAT_CHECK( x )
	#define ALLOC_CHECK( x )
	#define RENAME_SYMBOL( x )
	#define MALLOC
	#define MALLOC_LIKE( x, y )
	#define WARN_UNUSED_RESULT
#endif

#if defined( __has_feature )
	#if __has_feature( address_sanitizer )
		#define USE_ASAN 1
	#endif // __has_feature
#endif // defined( __has_feature )

#if !defined( USE_ASAN ) && defined( __SANITIZE_ADDRESS__ )
#define USE_ASAN 1
#endif

#if __GNUC__ >= 3
	#define unlikely( x )     __builtin_expect( x, 0 )
	#define likely( x )       __builtin_expect( x, 1 )
#elif defined( __has_builtin )
	#if __has_builtin( __builtin_expect ) // this must be after defined() check
		#define unlikely( x )     __builtin_expect( x, 0 )
		#define likely( x )       __builtin_expect( x, 1 )
	#endif
#endif

#if !defined( unlikely ) || !defined( likely )
	#define unlikely( x ) ( x )
	#define likely( x )   ( x )
#endif

#if __STDC_VERSION__ >= 202311L || __cplusplus >= 201103L // C23 or C++ static_assert is a keyword
	#define STATIC_ASSERT_( ignore, x, y ) static_assert( x, y )
	#define STATIC_ASSERT  static_assert
#elif __STDC_VERSION__ >= 201112L // in C11 it's _Static_assert
	#define STATIC_ASSERT_( ignore, x, y ) _Static_assert( x, y )
	#define STATIC_ASSERT  _Static_assert
#else
	#define STATIC_ASSERT_( id, x, y ) extern int id[( x ) ? 1 : -1]
	// need these to correctly expand the line macro
	#define STATIC_ASSERT_3( line, x, y ) STATIC_ASSERT_( static_assert_ ## line, x, y )
	#define STATIC_ASSERT_2( line, x, y ) STATIC_ASSERT_3( line, x, y )
	#define STATIC_ASSERT( x, y ) STATIC_ASSERT_2( __LINE__, x, y )
#endif

// at least, statically check size of some public structures
#if XASH_64BIT
#define STATIC_CHECK_SIZEOF( type, size32, size64 ) \
	STATIC_ASSERT( sizeof( type ) == size64, #type " unexpected size" )
#else
#define STATIC_CHECK_SIZEOF( type, size32, size64 ) \
	STATIC_ASSERT( sizeof( type ) == size32, #type " unexpected size" )
#endif

#if !defined( __cplusplus ) && __STDC_VERSION__ >= 199101L // not C++ and C99 or newer
	#define XASH_RESTRICT restrict
#elif _MSC_VER || __GNUC__ || __clang__ // compiler-specific extensions
	#define XASH_RESTRICT __restrict
#else
	#define XASH_RESTRICT // nothing
#endif

#ifdef XASH_BIG_ENDIAN
#define LittleLong(x) (((int)(((x)&255)<<24)) + ((int)((((x)>>8)&255)<<16)) + ((int)(((x)>>16)&255)<<8) + (((x) >> 24)&255))
#define LittleLongSW(x) (x = LittleLong(x) )
#define LittleShort(x) ((short)( (((short)(x) >> 8) & 255) + (((short)(x) & 255) << 8)))
#define LittleShortSW(x) (x = LittleShort(x) )
_inline float LittleFloat( float f )
{
	union
	{
		float f;
		unsigned char b[4];
	} dat1, dat2;

	dat1.f = f;
	dat2.b[0] = dat1.b[3];
	dat2.b[1] = dat1.b[2];
	dat2.b[2] = dat1.b[1];
	dat2.b[3] = dat1.b[0];

	return dat2.f;
}
#else
#define LittleLong(x) (x)
#define LittleLongSW(x)
#define LittleShort(x) (x)
#define LittleShortSW(x)
#define LittleFloat(x) (x)
#endif


typedef unsigned int dword;
typedef unsigned int uint;
typedef char         string[MAX_STRING];
typedef off_t        fs_offset_t;
#if XASH_WIN32
typedef int          fs_size_t; // return type of _read, _write funcs
#else /* !XASH_WIN32 */
typedef ssize_t      fs_size_t;
#endif /* !XASH_WIN32 */

typedef void *(*pfnCreateInterface_t)( const char *, int * );

// config strings are a general means of communication from
// the server to all connected clients.
// each config string can be at most CS_SIZE characters.
#if XASH_LOW_MEMORY == 0
#define MAX_QPATH		64	// max length of a game pathname
#elif XASH_LOW_MEMORY == 2
#define MAX_QPATH		32 // should be enough for singleplayer
#elif XASH_LOW_MEMORY == 1
#define MAX_QPATH 48
#endif
#define MAX_OSPATH		260	// max length of a filesystem pathname
#define CS_SIZE		64	// size of one config string
#define CS_TIME		16	// size of time string

#endif // XASH_TYPES_H
```

`dlls/activity.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef ACTIVITY_H
#define ACTIVITY_H

typedef enum
{
	ACT_RESET,
	ACT_IDLE,
	ACT_GUARD,
	ACT_WALK,
	ACT_RUN,
	ACT_FLY,
	ACT_SWIM,
	ACT_HOP,
	ACT_LEAP,
	ACT_FALL,
	ACT_LAND,
	ACT_STRAFE_LEFT,
	ACT_STRAFE_RIGHT,
	ACT_ROLL_LEFT,
	ACT_ROLL_RIGHT,
	ACT_TURN_LEFT,
	ACT_TURN_RIGHT,
	ACT_CROUCH,
	ACT_CROUCHIDLE,
	ACT_STAND,
	ACT_USE,
	ACT_SIGNAL1,
	ACT_SIGNAL2,
	ACT_SIGNAL3,
	ACT_TWITCH,
	ACT_COWER,
	ACT_SMALL_FLINCH,
	ACT_BIG_FLINCH,
	ACT_RANGE_ATTACK1,
	ACT_RANGE_ATTACK2,
	ACT_MELEE_ATTACK1,
	ACT_MELEE_ATTACK2,
	ACT_RELOAD,
	ACT_ARM,
	ACT_DISARM,
	ACT_EAT,
	ACT_DIESIMPLE,
	ACT_DIEBACKWARD,
	ACT_DIEFORWARD,
	ACT_DIEVIOLENT,
	ACT_BARNACLE_HIT,
	ACT_BARNACLE_PULL,
	ACT_BARNACLE_CHOMP,
	ACT_BARNACLE_CHEW,
	ACT_SLEEP,
	ACT_INSPECT_FLOOR,
	ACT_INSPECT_WALL,
	ACT_IDLE_ANGRY,
	ACT_WALK_HURT,
	ACT_RUN_HURT,
	ACT_HOVER,
	ACT_GLIDE,
	ACT_FLY_LEFT,
	ACT_FLY_RIGHT,
	ACT_DETECT_SCENT,
	ACT_SNIFF,
	ACT_BITE,
	ACT_THREAT_DISPLAY,
	ACT_FEAR_DISPLAY,
	ACT_EXCITED,
	ACT_SPECIAL_ATTACK1,
	ACT_SPECIAL_ATTACK2,
	ACT_COMBAT_IDLE,
	ACT_WALK_SCARED,
	ACT_RUN_SCARED,
	ACT_VICTORY_DANCE,
	ACT_DIE_HEADSHOT,
	ACT_DIE_CHESTSHOT,
	ACT_DIE_GUTSHOT,
	ACT_DIE_BACKSHOT,
	ACT_FLINCH_HEAD,
	ACT_FLINCH_CHEST,
	ACT_FLINCH_STOMACH,
	ACT_FLINCH_LEFTARM,
	ACT_FLINCH_RIGHTARM,
	ACT_FLINCH_LEFTLEG,
	ACT_FLINCH_RIGHTLEG,
	ACT_FLINCH,
	ACT_LARGE_FLINCH,
	ACT_HOLDBOMB,
	ACT_IDLE_FIDGET,
	ACT_IDLE_SCARED,
	ACT_IDLE_SCARED_FIDGET,
	ACT_FOLLOW_IDLE,
	ACT_FOLLOW_IDLE_FIDGET,
	ACT_FOLLOW_IDLE_SCARED,
	ACT_FOLLOW_IDLE_SCARED_FIDGET,
	ACT_CROUCH_IDLE,
	ACT_CROUCH_IDLE_FIDGET,
	ACT_CROUCH_IDLE_SCARED,
	ACT_CROUCH_IDLE_SCARED_FIDGET,
	ACT_CROUCH_WALK,
	ACT_CROUCH_WALK_SCARED,
	ACT_CROUCH_DIE,
	ACT_WALK_BACK,
	ACT_IDLE_SNEAKY,
	ACT_IDLE_SNEAKY_FIDGET,
	ACT_WALK_SNEAKY,
	ACT_WAVE,
	ACT_YES,
	ACT_NO
}
Activity;

typedef struct
{
	int type;
	char *name;
}
activity_map_t;

extern activity_map_t activity_map[];
#endif
```

`dlls/basemonster.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef BASEMONSTER_H
#define BASEMONSTER_H

class CBaseMonster : public CBaseToggle
{
public:
	virtual void KeyValue(KeyValueData *pkvd) { }
	virtual float ChangeYaw(int speed) { return 0; }
	virtual BOOL HasHumanGibs(void) { return FALSE; }
	virtual BOOL HasAlienGibs(void) { return FALSE; }
	virtual void FadeMonster(void) { }
	virtual void GibMonster(void) { }
	virtual Activity GetDeathActivity(void) { return ACT_DIE_HEADSHOT; }
	virtual void BecomeDead(void) { }
	virtual BOOL ShouldFadeOnDeath(void) { return FALSE; }
	virtual int IRelationship(CBaseEntity *pTarget) { return 0; }
	virtual int TakeHealth(float flHealth, int bitsDamageType) { return 0; }
	virtual int TakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType) { return 0; }
	virtual void Killed(entvars_t *pevAttacker, int iGib) { }
	virtual void PainSound(void) { return; }
	virtual void ResetMaxSpeed(void) {}
	virtual void ReportAIState(void) { }
	virtual void MonsterInitDead(void) { }
	virtual void Look(int iDistance) { }
	virtual CBaseEntity *BestVisibleEnemy(void) { return NULL; }
	virtual BOOL FInViewCone(CBaseEntity *pEntity) { return FALSE; }
	virtual BOOL FInViewCone(Vector *pOrigin) { return FALSE; }
	virtual int BloodColor(void) { return m_bloodColor; }
	virtual BOOL IsAlive(void) { return (pev->deadflag != DEAD_DEAD); }

public:
	void MakeIdealYaw(Vector vecTarget);
	Activity GetSmallFlinchActivity(void);
	BOOL ShouldGibMonster(int iGib);
	void CallGibMonster(void);
	BOOL FCheckAITrigger(void);
	int DeadTakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType);
	float DamageForce(float damage);
	void RadiusDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int iClassIgnore, int bitsDamageType);
	void RadiusDamage(Vector vecSrc, entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int iClassIgnore, int bitsDamageType);
	void EXPORT CorpseFallThink(void);
	CBaseEntity *CheckTraceHullAttack(float flDist, int iDamage, int iDmgType);
	void TraceAttack(entvars_t *pevAttacker, float flDamage, const Vector &vecDir, TraceResult *ptr, int bitsDamageType) {}
	void MakeDamageBloodDecal(int cCount, float flNoise, TraceResult *ptr, const Vector &vecDir);
	void BloodSplat(const Vector &vecPos, const Vector &vecDir, int hitgroup, int iDamage);

public:
	inline void SetConditions(int iConditions) { m_afConditions |= iConditions; }
	inline void ClearConditions(int iConditions) { m_afConditions &= ~iConditions; }
	inline BOOL HasConditions(int iConditions) { if (m_afConditions & iConditions) return TRUE; return FALSE; }
	inline BOOL HasAllConditions(int iConditions) { if ((m_afConditions & iConditions) == iConditions) return TRUE; return FALSE; }
	inline void Remember(int iMemory) { m_afMemory |= iMemory; }
	inline void Forget(int iMemory) { m_afMemory &= ~iMemory; }
	inline BOOL HasMemory(int iMemory) { if (m_afMemory & iMemory) return TRUE; return FALSE; }
	inline BOOL HasAllMemories(int iMemory) { if ((m_afMemory & iMemory) == iMemory) return TRUE; return FALSE; }
	inline void StopAnimation(void) { pev->framerate = 0; }

public:
	Activity m_Activity;
	Activity m_IdealActivity;
	int m_LastHitGroup;
	int m_bitsDamageType;
	BYTE m_rgbTimeBasedDamage[CDMG_TIMEBASED];
	MONSTERSTATE m_MonsterState;
	MONSTERSTATE m_IdealMonsterState;
	int m_afConditions;
	int m_afMemory;
	float m_flNextAttack;
	EHANDLE m_hEnemy;
	EHANDLE m_hTargetEnt;
	float m_flFieldOfView;
	int m_bloodColor;
	Vector m_HackedGunPos;
	Vector m_vecEnemyLKP;
};
#endif

```

`dlls/cbase.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#define FCAP_CUSTOMSAVE 0x00000001
#define FCAP_ACROSS_TRANSITION 0x00000002
#define FCAP_MUST_SPAWN 0x00000004
#define FCAP_DONT_SAVE 0x80000000
#define FCAP_IMPULSE_USE 0x00000008
#define FCAP_CONTINUOUS_USE 0x00000010
#define FCAP_ONOFF_USE 0x00000020
#define FCAP_DIRECTIONAL_USE 0x00000040
#define FCAP_MASTER 0x00000080
#define FCAP_FORCE_TRANSITION 0x00000080
#include "port.h"

#include "saverestore.h"
#include "schedule.h"

#ifndef MONSTEREVENT_H
#include "monsterevent.h"
#endif

#include <tier1/UtlVector.h>

#undef CREATE_NAMED_ENTITY
#undef REMOVE_ENTITY

edict_t *CREATE_NAMED_ENTITY(int iClass);
void REMOVE_ENTITY(edict_t *e);
void CONSOLE_ECHO(char *pszMsg, ...);
void CONSOLE_ECHO_LOGGED(char *pszMsg, ...);

#include "exportdef.h"

extern "C" EXPORT int GetEntityAPI(DLL_FUNCTIONS *pFunctionTable, int interfaceVersion);
extern "C" EXPORT int GetEntityAPI2(DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion);
extern "C" EXPORT int GetNewDLLFunctions(NEW_DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion);

typedef enum
{
	CLASSNAME
}
hash_types_e;

typedef struct hash_item_s
{
	entvars_t *pev;
	struct hash_item_s *next;
	struct hash_item_s *lastHash;
	int pevIndex;
}
hash_item_t;

extern CUtlVector<hash_item_t> stringsHashTable;

int CaseInsensitiveHash(const char *string, int iBounds);
void EmptyEntityHashTable(void);
void AddEntityHashValue(struct entvars_s *pev, const char *value, hash_types_e fieldType);
void RemoveEntityHashValue(struct entvars_s *pev, const char *value, hash_types_e fieldType);
void printEntities(void);
void loopPerformance(void);
#ifdef CLIENT_DLL
void Broadcast( const char*, int );
#endif


extern int DispatchSpawn(edict_t *pent);
extern void DispatchKeyValue(edict_t *pentKeyvalue, KeyValueData *pkvd);
extern void DispatchTouch(edict_t *pentTouched, edict_t *pentOther);
extern void DispatchUse(edict_t *pentUsed, edict_t *pentOther);
extern void DispatchThink(edict_t *pent);
extern void DispatchBlocked(edict_t *pentBlocked, edict_t *pentOther);
extern void DispatchSave(edict_t *pent, SAVERESTOREDATA *pSaveData);
extern int DispatchRestore(edict_t *pent, SAVERESTOREDATA *pSaveData, int globalEntity);
extern void DispatchObjectCollsionBox(edict_t *pent);
extern void SaveWriteFields(SAVERESTOREDATA *pSaveData, const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount);
extern void SaveReadFields(SAVERESTOREDATA *pSaveData, const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount);
extern void SaveGlobalState(SAVERESTOREDATA *pSaveData);
extern void RestoreGlobalState(SAVERESTOREDATA *pSaveData);
extern void ResetGlobalState(void);

typedef enum
{
	USE_OFF,
	USE_ON,
	USE_SET,
	USE_TOGGLE
}
USE_TYPE;

extern void FireTargets(const char *targetName, CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);

typedef void (CBaseEntity::*BASEPTR)(void);
typedef void (CBaseEntity::*ENTITYFUNCPTR)(CBaseEntity *pOther);
typedef void (CBaseEntity::*USEPTR)(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);

#define CLASS_NONE 0
#define CLASS_MACHINE 1
#define CLASS_PLAYER 2
#define CLASS_HUMAN_PASSIVE 3
#define CLASS_HUMAN_MILITARY 4
#define CLASS_ALIEN_MILITARY 5
#define CLASS_ALIEN_PASSIVE 6
#define CLASS_ALIEN_MONSTER 7
#define CLASS_ALIEN_PREY 8
#define CLASS_ALIEN_PREDATOR 9
#define CLASS_INSECT 10
#define CLASS_PLAYER_ALLY 11
#define CLASS_PLAYER_BIOWEAPON 12
#define CLASS_ALIEN_BIOWEAPON 13
#define CLASS_VEHICLE 14
#define CLASS_BARNACLE 99

class CBaseEntity;
class CBaseMonster;
class CBasePlayerItem;
class CSquadMonster;

#define SF_NORESPAWN (1<<30)

class EHANDLE
{
public:
	edict_t *Get(void);
	edict_t *Set(edict_t *pent);

	operator int ();
	operator CBaseEntity *();

	CBaseEntity *operator = (CBaseEntity *pEntity);
	CBaseEntity *operator ->();

private:
	edict_t *m_pent;
	int m_serialnumber;
};

class CBaseEntity
{
public:
	virtual void Spawn(void) {}
	virtual void Precache(void) {}
	virtual void Restart(void) {}
	virtual void KeyValue(KeyValueData *pkvd) { pkvd->fHandled = FALSE; }
	virtual int Save(CSave &save) { return 1; }
	virtual int Restore(CRestore &restore) { return 1; }
	virtual int ObjectCaps(void) { return FCAP_ACROSS_TRANSITION; }
	virtual void Activate(void) {}
	virtual void SetObjectCollisionBox(void) {}
	virtual int Classify(void) { return CLASS_NONE; }
	virtual void DeathNotice(entvars_t *pevChild) {}
	virtual void TraceAttack(entvars_t *pevAttacker, float flDamage, const Vector &vecDir, TraceResult *ptr, int bitsDamageType) { }
	virtual int TakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType) { return 1; }
	virtual int TakeHealth(float flHealth, int bitsDamageType) { return 1; }
	virtual void Killed(entvars_t *pevAttacker, int iGib);
	virtual int BloodColor(void) { return DONT_BLEED; }
	virtual void TraceBleed(float flDamage, Vector vecDir, TraceResult *ptr, int bitsDamageType) { }
	virtual BOOL IsTriggered(CBaseEntity *pActivator) { return TRUE; }
	virtual CBaseMonster *MyMonsterPointer(void) { return NULL; }
	virtual CSquadMonster *MySquadMonsterPointer(void) { return NULL; }
	virtual int GetToggleState(void) { return TS_AT_TOP; }
	virtual void AddPoints(int score, BOOL bAllowNegativeScore) {}
	virtual void AddPointsToTeam(int score, BOOL bAllowNegativeScore) {}
	virtual BOOL AddPlayerItem(CBasePlayerItem *pItem) { return 0; }
	virtual BOOL RemovePlayerItem(CBasePlayerItem *pItem) { return 0; }
	virtual int GiveAmmo(int iAmount, char *szName, int iMax) { return -1; }
	virtual float GetDelay(void) { return 0; }
	virtual int IsMoving(void) { return pev->velocity != g_vecZero; }
	virtual void OverrideReset(void) {}
	virtual int DamageDecal(int bitsDamageType) { return -1; }
	virtual void SetToggleState(int state) {}
	virtual void StartSneaking(void) {}
	virtual void StopSneaking(void) {}
	virtual BOOL OnControls(entvars_t *onpev) { return FALSE; }
	virtual BOOL IsSneaking(void) { return FALSE; }
	virtual BOOL IsAlive(void) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }
	virtual BOOL IsBSPModel(void) { return pev->solid == SOLID_BSP || pev->movetype == MOVETYPE_PUSHSTEP; }
	virtual BOOL ReflectGauss(void) { return IsBSPModel() && !pev->takedamage; }
	virtual BOOL HasTarget(string_t targetname) { return FStrEq(STRING(targetname), STRING(pev->targetname)); }
	virtual BOOL IsInWorld(void) { return TRUE; }
	virtual BOOL IsPlayer(void) { return FALSE; }
	virtual BOOL IsNetClient(void) { return FALSE; }
	virtual const char *TeamID(void) { return ""; }
	virtual CBaseEntity *GetNextTarget(void) { return 0; }
	virtual void Think(void) { if (m_pfnThink) (this->*m_pfnThink)(); }
	virtual void Touch(CBaseEntity *pOther) { if (m_pfnTouch) (this->*m_pfnTouch)(pOther); }
	virtual void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value) { if (m_pfnUse) (this->*m_pfnUse)(pActivator, pCaller, useType, value); }
	virtual void Blocked(CBaseEntity *pOther) { if (m_pfnBlocked) (this->*m_pfnBlocked)(pOther); }
	virtual CBaseEntity *Respawn(void) { return NULL; }
	virtual void UpdateOwner(void) {}
	virtual BOOL FBecomeProne(void) { return FALSE; }
	virtual Vector Center(void) { return (pev->absmax + pev->absmin) * 0.5; }
	virtual Vector EyePosition(void) { return pev->origin + pev->view_ofs; }
	virtual Vector EarPosition(void) { return pev->origin + pev->view_ofs; }
	virtual Vector BodyTarget(const Vector &posSrc) { return Center(); }
	virtual int Illumination(void) { return GETENTITYILLUM(ENT(pev)); }
	virtual BOOL FVisible(CBaseEntity *pEntity) { return FALSE; }
	virtual BOOL FVisible(const Vector &vecOrigin) { return FALSE; }

public:
	void EXPORT SUB_Remove(void) { }
	void EXPORT SUB_DoNothing(void);
	void EXPORT SUB_StartFadeOut(void);
	void EXPORT SUB_FadeOut(void);
	void EXPORT SUB_CallUseToggle(void) { Use(this, this, USE_TOGGLE, 0); }
	void SUB_UseTargets(CBaseEntity *pActivator, USE_TYPE useType, float value);

public:
	void UpdateOnRemove(void);
	int ShouldToggle(USE_TYPE useType, BOOL currentState) { return 0; }
	void FireBullets(ULONG cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread, float flDistance, int iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t *pevAttacker = NULL);
	Vector FireBullets3(Vector vecSrc, Vector vecDirShooting, float flSpread, float flDistance, int iPenetration, int iBulletType, int iDamage, float flRangeModifier, entvars_t *pevAttacker, bool bPistol, int shared_rand = 0);
	int Intersects(CBaseEntity *pOther) { return 0; }
	void MakeDormant(void) { }
	int IsDormant(void) { return 0; }
	BOOL IsLockedByMaster(void) { return FALSE; }

public:
	static CBaseEntity *Instance(edict_t *pent) { return (CBaseEntity *)GET_PRIVATE(pent ? pent : ENT(0)); }
	static CBaseEntity *Instance(entvars_t *instpev) { return Instance(ENT(instpev)); }
	static CBaseEntity *Instance(int inst_eoffset) { return Instance(ENT(inst_eoffset)); }

	CBaseMonster *GetMonsterPointer(entvars_t *pevMonster)
	{
		CBaseEntity *pEntity = Instance(pevMonster);

		if (pEntity)
			return pEntity->MyMonsterPointer();

		return NULL;
	}

	CBaseMonster *GetMonsterPointer(edict_t *pentMonster)
	{
		CBaseEntity *pEntity = Instance(pentMonster);

		if (pEntity)
			return pEntity->MyMonsterPointer();

		return NULL;
	}

#if defined(_DEBUG) && !defined(CLIENT_DLL)
	void FunctionCheck(void *pFunction, const char *name)
	{
		if (pFunction && !NAME_FOR_FUNCTION((unsigned long)(pFunction)))
		{ 
			ALERT(at_error, "No EXPORT: %s:%s (%08lx)\n", STRING(pev->classname), name, (unsigned long)pFunction);
			UTIL_LogPrintf("No EXPORT: %s:%s (%08lx)\n", STRING(pev->classname), name, (unsigned long)pFunction);
		}
		else
		{
			if (pFunction)
				UTIL_LogPrintf("Has EXPORT: %s:%s (%08lx)\n", STRING(pev->classname), name, (unsigned long)pFunction);
		}
	}

	BASEPTR ThinkSet(BASEPTR func, const char *name)
	{
		m_pfnThink = func;
		FunctionCheck((void *)*((int *)((char *)this + (offsetof(CBaseEntity, m_pfnThink)))), name);
		return func;
	}

	ENTITYFUNCPTR TouchSet(ENTITYFUNCPTR func, const char *name)
	{
		m_pfnTouch = func;
		FunctionCheck((void *)*((int *)((char *)this + (offsetof(CBaseEntity, m_pfnTouch)))), name);
		return func;
	}

	USEPTR UseSet(USEPTR func, const char *name)
	{
		m_pfnUse = func;
		FunctionCheck((void *)*((int *)((char *)this + (offsetof(CBaseEntity, m_pfnUse)))), name);
		return func;
	}

	ENTITYFUNCPTR BlockedSet(ENTITYFUNCPTR func, const char *name)
	{
		m_pfnBlocked = func;
		FunctionCheck((void *)*((int *)((char *)this + (offsetof(CBaseEntity, m_pfnBlocked)))), name);
		return func;
	}
#endif

	static CBaseEntity *Create(char *szName, const Vector &vecOrigin, const Vector &vecAngles, edict_t *pentOwner = NULL) { return NULL; }

	edict_t *edict(void) { return ENT(pev); }
	EOFFSET eoffset(void) { return OFFSET(pev); }
	int entindex(void) { return ENTINDEX(edict()); }

public:
	void *operator new(size_t stAllocateBlock, entvars_t *newpev) { return ALLOC_PRIVATE(ENT(newpev), stAllocateBlock); }

#if defined(_MSC_VER) && _MSC_VER >= 1200
	void operator delete(void *pMem, entvars_t *pev) { pev->flags |= FL_KILLME; }
#endif

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	entvars_t *pev;
	CBaseEntity *m_pGoalEnt;
	CBaseEntity *m_pLink;
	void (CBaseEntity::*m_pfnThink)(void);
	void (CBaseEntity::*m_pfnTouch)(CBaseEntity *pOther);
	void (CBaseEntity::*m_pfnUse)(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	void (CBaseEntity::*m_pfnBlocked)(CBaseEntity *pOther);
	int current_ammo;
	int currentammo;
	int maxammo_buckshot;
	int ammo_buckshot;
	int maxammo_9mm;
	int ammo_9mm;
	int maxammo_556nato;
	int ammo_556nato;
	int maxammo_556natobox;
	int ammo_556natobox;
	int maxammo_762nato;
	int ammo_762nato;
	int maxammo_45acp;
	int ammo_45acp;
	int maxammo_50ae;
	int ammo_50ae;
	int maxammo_338mag;
	int ammo_338mag;
	int maxammo_57mm;
	int ammo_57mm;
	int maxammo_357sig;
	int ammo_357sig;
	float m_flStartThrow;
	float m_flReleaseThrow;
	int m_iSwing;
	bool has_disconnected;
};

#if defined(_DEBUG) && !defined(CLIENT_DLL)
#define SetThink(a) ThinkSet(static_cast <void (CBaseEntity::*)(void)>(a), (char*)#a)
#define SetTouch(a) TouchSet(static_cast <void (CBaseEntity::*)(CBaseEntity *)>(a), #a)
#define SetUse(a) UseSet(static_cast <void (CBaseEntity::*)(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value)>(a), #a)
#define SetBlocked(a) BlockedSet(static_cast <void (CBaseEntity::*)(CBaseEntity *)>(a), #a)
#else
#define SetThink(a) m_pfnThink = static_cast<void (CBaseEntity::*)(void)>(a)
#define SetTouch(a) m_pfnTouch = static_cast<void (CBaseEntity::*)(CBaseEntity *)>(a)
#define SetUse(a) m_pfnUse = static_cast<void (CBaseEntity::*)(CBaseEntity *, CBaseEntity *, USE_TYPE, float)>(a)
#define SetBlocked(a) m_pfnBlocked = static_cast<void (CBaseEntity::*)(CBaseEntity *)>(a)
#endif

class CPointEntity : public CBaseEntity
{
public:
	void Spawn(void);
	int ObjectCaps(void) { return CBaseEntity::ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }
};

typedef struct locksounds
{
	string_t sLockedSound;
	string_t sLockedSentence;
	string_t sUnlockedSound;
	string_t sUnlockedSentence;
	int iLockedSentence;
	int iUnlockedSentence;
	float flwaitSound;
	float flwaitSentence;
	BYTE bEOFLocked;
	BYTE bEOFUnlocked;
}
locksound_t;

void PlayLockSounds(entvars_t *pev, locksound_t *pls, int flocked, int fbutton);

#define MAX_MULTI_TARGETS 16
#define MS_MAX_TARGETS 32

class CMultiSource : public CPointEntity
{
public:
	void Spawn(void);
	void KeyValue(KeyValueData *pkvd);
	void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	int ObjectCaps(void) { return (CPointEntity::ObjectCaps() | FCAP_MASTER); }
	BOOL IsTriggered(CBaseEntity *pActivator);
	int Save(CSave &save);
	int Restore(CRestore &restore);

public:
	void EXPORT Register(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	EHANDLE m_rgEntities[MS_MAX_TARGETS];
	int m_rgTriggered[MS_MAX_TARGETS];
	int m_iTotal;
	string_t m_globalstate;
};

class CBaseDelay : public CBaseEntity
{
public:
	void KeyValue(KeyValueData *pkvd) { }
	int Save(CSave &save) { return 1; }
	int Restore(CRestore &restore) { return 1; }

public:
	void SUB_UseTargets(CBaseEntity *pActivator, USE_TYPE useType, float value);

public:
	void EXPORT DelayThink(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	float m_flDelay;
	int m_iszKillTarget;
};

class CBaseAnimating : public CBaseDelay
{
public:
	virtual int Save(CSave &save) { return 1; }
	virtual int Restore(CRestore &restore) { return 1; }
	virtual void HandleAnimEvent(MonsterEvent_t *pEvent) {}

public:
	float StudioFrameAdvance(float flInterval = 0);
	int GetSequenceFlags(void);
	int LookupActivity(int activity) { return 0; }
	int LookupActivityHeaviest(int activity) { return 0; }
	int LookupSequence(const char *label) { return 0; }
	void ResetSequenceInfo(void) { }
	void DispatchAnimEvents(float flFutureInterval = 0.1) { }
	float SetBoneController(int iController, float flValue) { return 0; }
	void InitBoneControllers(void) { }
	float SetBlending(int iBlender, float flValue) { return 0; }
	void GetBonePosition(int iBone, Vector &origin, Vector &angles) { }
	void GetAutomovement(Vector &origin, Vector &angles, float flInterval = 0.1) { }
	int FindTransition(int iEndingSequence, int iGoalSequence, int *piDir) { return -1; }
	void GetAttachment(int iAttachment, Vector &origin, Vector &angles) { }
	void SetBodygroup(int iGroup, int iValue) {}
	int GetBodygroup(int iGroup) { return 0; }
	int ExtractBbox(int sequence, float *mins, float *maxs) { return 0; }
	void SetSequenceBox(void) { }

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	float m_flFrameRate;
	float m_flGroundSpeed;
	float m_flLastEventCheck;
	BOOL m_fSequenceFinished;
	BOOL m_fSequenceLoops;
};

#define SF_ITEM_USE_ONLY 256

class CBaseToggle : public CBaseAnimating
{
public:
	void KeyValue(KeyValueData *pkvd) { }
	int Save(CSave &save) { return 1; }
	int Restore(CRestore &restore) { return 1; }
	int GetToggleState(void) { return m_toggle_state; }
	float GetDelay(void) { return m_flWait; }

public:
	void LinearMove(Vector vecDest, float flSpeed);
	void EXPORT LinearMoveDone(void);
	void AngularMove(Vector vecDestAngle, float flSpeed);
	void EXPORT AngularMoveDone(void);
	BOOL IsLockedByMaster(void);

public:
	static float AxisValue(int flags, const Vector &angles);
	static void AxisDir(entvars_t *pev);
	static float AxisDelta(int flags, const Vector &angle1, const Vector &angle2);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	TOGGLE_STATE m_toggle_state;
	float m_flActivateFinished;
	float m_flMoveDistance;
	float m_flWait;
	float m_flLip;
	float m_flTWidth;
	float m_flTLength;
	Vector m_vecPosition1;
	Vector m_vecPosition2;
	Vector m_vecAngle1;
	Vector m_vecAngle2;
	int m_cTriggersLeft;
	float m_flHeight;
	EHANDLE m_hActivator;
	void (CBaseToggle::*m_pfnCallWhenMoveDone)(void);
	Vector m_vecFinalDest;
	Vector m_vecFinalAngle;
	int m_bitsDamageInflict;
	string_t m_sMaster;
};

#define SetMoveDone(a) m_pfnCallWhenMoveDone = static_cast<void (CBaseToggle::*)(void)>(a)

#define GIB_HEALTH_VALUE -30

#define ROUTE_SIZE 8
#define MAX_OLD_ENEMIES 4

#define bits_CAP_DUCK (1<<0)
#define bits_CAP_JUMP (1<<1)
#define bits_CAP_STRAFE (1<<2)
#define bits_CAP_SQUAD (1<<3)
#define bits_CAP_SWIM (1<<4)
#define bits_CAP_CLIMB (1<<5)
#define bits_CAP_USE (1<<6)
#define bits_CAP_HEAR (1<<7)
#define bits_CAP_AUTO_DOORS (1<<8)
#define bits_CAP_OPEN_DOORS (1<<9)
#define bits_CAP_TURN_HEAD (1<<10)
#define bits_CAP_RANGE_ATTACK1 (1<<11)
#define bits_CAP_RANGE_ATTACK2 (1<<12)
#define bits_CAP_MELEE_ATTACK1 (1<<13)
#define bits_CAP_MELEE_ATTACK2 (1<<14)
#define bits_CAP_FLY (1<<15)
#define bits_CAP_DOORS_GROUP (bits_CAP_USE | bits_CAP_AUTO_DOORS | bits_CAP_OPEN_DOORS)

#define DMG_GENERIC 0
#ifndef DMG_CRUSH
#define DMG_CRUSH (1<<0)
#define DMG_BULLET (1<<1)
#define DMG_SLASH (1<<2)
#define DMG_BURN (1<<3)
#define DMG_FREEZE (1<<4)
#define DMG_FALL (1<<5)
#define DMG_BLAST (1<<6)
#define DMG_CLUB (1<<7)
#define DMG_SHOCK (1<<8)
#define DMG_SONIC (1<<9)
#define DMG_ENERGYBEAM (1<<10)
#define DMG_NEVERGIB (1<<12)
#define DMG_ALWAYSGIB (1<<13)
#define DMG_DROWN (1<<14)
#define DMG_TIMEBASED (~(0x3FFF))

#define DMG_PARALYZE (1<<15)
#define DMG_NERVEGAS (1<<16)
#define DMG_POISON (1<<17)
#define DMG_RADIATION (1<<18)
#define DMG_DROWNRECOVER (1<<19)
#define DMG_ACID (1<<20)
#define DMG_SLOWBURN (1<<21)
#define DMG_SLOWFREEZE (1<<22)
#define DMG_MORTAR (1<<23)
#endif
#define DMG_EXPLOSION (1<<24)
#define DMG_GIB_CORPSE (DMG_CRUSH | DMG_FALL | DMG_BLAST | DMG_SONIC | DMG_CLUB)
#define DMG_SHOWNHUD (DMG_POISON | DMG_ACID | DMG_FREEZE | DMG_SLOWFREEZE | DMG_DROWN | DMG_BURN | DMG_SLOWBURN | DMG_NERVEGAS | DMG_RADIATION | DMG_SHOCK)

#define PARALYZE_DURATION 2
#define PARALYZE_DAMAGE 1.0

#define NERVEGAS_DURATION 2
#define NERVEGAS_DAMAGE 5.0

#define POISON_DURATION 5
#define POISON_DAMAGE 2.0

#define RADIATION_DURATION 2
#define RADIATION_DAMAGE 1.0

#define ACID_DURATION 2
#define ACID_DAMAGE 5.0

#define SLOWBURN_DURATION 2
#define SLOWBURN_DAMAGE 1.0

#define SLOWFREEZE_DURATION 2
#define SLOWFREEZE_DAMAGE 1.0

#define itbd_Paralyze 0
#define itbd_NerveGas 1
#define itbd_Poison 2
#define itbd_Radiation 3
#define itbd_DrownRecover 4
#define itbd_Acid 5
#define itbd_SlowBurn 6
#define itbd_SlowFreeze 7
#define CDMG_TIMEBASED 8

#define GIB_NORMAL 0
#define GIB_NEVER 1
#define GIB_ALWAYS 2

class CBaseMonster;
class CCineMonster;
class CSound;

#include "basemonster.h"

char *ButtonSound(int sound);

class CBaseButton : public CBaseToggle
{
public:
	void Spawn(void);
	void Precache(void);
	void KeyValue(KeyValueData* pkvd);
	int ObjectCaps(void) { return (CBaseToggle:: ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | (pev->takedamage ? 0 : FCAP_IMPULSE_USE); }
	int TakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType);
	int Save(CSave &save);
	int Restore(CRestore &restore);

public:
	void RotSpawn(void);
	void ButtonActivate(void);
	void SparkSoundCache(void);

	void EXPORT ButtonShot(void);
	void EXPORT ButtonTouch(CBaseEntity *pOther);
	void EXPORT ButtonSpark(void);
	void EXPORT TriggerAndWait(void);
	void EXPORT ButtonReturn(void);
	void EXPORT ButtonBackHome(void);
	void EXPORT ButtonUse(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	enum BUTTON_CODE { BUTTON_NOTHING, BUTTON_ACTIVATE, BUTTON_RETURN };
	BUTTON_CODE ButtonResponseToTouch(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	BOOL m_fStayPushed;
	BOOL m_fRotating;
	string_t m_strChangeTarget;
	locksound_t m_ls;
	BYTE m_bLockedSound;
	BYTE m_bLockedSentence;
	BYTE m_bUnlockedSound;
	BYTE m_bUnlockedSentence;
	int m_sounds;
};

template <class T> T *GetClassPtr(T *a)
{
	entvars_t *pev = (entvars_t *)a;

	if (pev == NULL)
		pev = VARS(CREATE_ENTITY());

	a = (T *)GET_PRIVATE(ENT(pev));

	if (a == NULL)
	{
		a = new(pev) T;
		a->pev = pev;
	}

	return a;
}

class CWorld : public CBaseEntity
{
public:
	void Spawn(void);
	void Precache(void);
	void KeyValue(KeyValueData *pkvd);
};

class CClientFog : public CBaseEntity
{
public:
	void Spawn(void);
	void KeyValue(KeyValueData *pkvd);

public:
	int m_iStartDist, m_iEndDist;
	float m_fDensity;
};

```

`dlls/cdll_dll.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CDLL_DLL_H
#define CDLL_DLL_H

#define MAX_WEAPONS 32
#define MAX_WEAPON_SLOTS 5
#define MAX_ITEM_TYPES 6
#define MAX_ITEMS 4

#define DEFAULT_FOV			90		// the default field of view

#define HIDEHUD_WEAPONS (1<<0)
#define HIDEHUD_FLASHLIGHT (1<<1)
#define HIDEHUD_ALL (1<<2)
#define HIDEHUD_HEALTH (1<<3)
#define HIDEHUD_TIMER (1<<4)
#define HIDEHUD_MONEY (1<<5)
#define HIDEHUD_CROSSHAIR (1<<6)

#define MAX_AMMO_TYPES 32
#define MAX_AMMO_SLOTS 32

#define HUD_PRINTNOTIFY 1
#define HUD_PRINTCONSOLE 2
#define HUD_PRINTTALK 3
#define HUD_PRINTCENTER 4
#define HUD_PRINTRADIO 5


#define SCORE_STATUS_DEAD (1<<0)
#define SCORE_STATUS_BOMB (1<<1)
#define SCORE_STATUS_VIP (1<<2)

#define STATUSICON_HIDE 0
#define STATUSICON_SHOW 1
#define STATUSICON_FLASH 2

#define TEAM_UNASSIGNED 0
#define TEAM_TERRORIST 1
#define TEAM_CT 2
#define TEAM_SPECTATOR 3

#define CLASS_UNASSIGNED 0
#define CLASS_URBAN 1
#define CLASS_TERROR 2
#define CLASS_LEET 3
#define CLASS_ARCTIC 4
#define CLASS_GSG9 5
#define CLASS_GIGN 6
#define CLASS_SAS 7
#define CLASS_GUERILLA 8
#define CLASS_VIP 9
#define CLASS_MILITIA 10
#define CLASS_SPETSNAZ 11

#define MENU_KEY_1 (1<<0)
#define MENU_KEY_2 (1<<1)
#define MENU_KEY_3 (1<<2)
#define MENU_KEY_4 (1<<3)
#define MENU_KEY_5 (1<<4)
#define MENU_KEY_6 (1<<5)
#define MENU_KEY_7 (1<<6)
#define MENU_KEY_8 (1<<7)
#define MENU_KEY_9 (1<<8)
#define MENU_KEY_0 (1<<9)

#define MENU_TEAM 2
#define MENU_MAPBRIEFING 4
#define MENU_CLASS_T 26
#define MENU_CLASS_CT 27
#define MENU_BUY 28
#define MENU_BUY_PISTOL 29
#define MENU_BUY_SHOTGUN 30
#define MENU_BUY_RIFLE 31
#define MENU_BUY_SUBMACHINEGUN 32
#define MENU_BUY_MACHINEGUN 33
#define MENU_BUY_ITEM 34
// -- cs16client extension start -- //
#define MENU_RADIOA 35
#define MENU_RADIOB 36
#define MENU_RADIOC 37
#define MENU_RADIOSELECTOR 38
#define MENU_BUY_CSDM 39
#define MENU_NUMERICAL_MENU -1
// -- cs16client extension end -- //


#define IUSER3_CANSHOOT (1<<0)
#define IUSER3_FREEZETIMEOVER (1<<1)
#define IUSER3_INBOMBZONE (1<<2)
#define IUSER3_HOLDINGSHIELD (1<<3)

#define ITEMSTATE_HASNIGHTVISION (1<<0)
#define ITEMSTATE_HASDEFUSER (1<<1)

#define PLAYER_DEAD (1<<0)
#define PLAYER_HAS_C4 (1<<1)
#define PLAYER_VIP (1<<2)
#define PLAYER_HAS_DEFUSER (1<<3)

#define WEAPON_SUIT 31
#endif

```

`dlls/effects.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef EFFECTS_H
#define EFFECTS_H

#define SF_BEAM_STARTON 0x0001
#define SF_BEAM_TOGGLE 0x0002
#define SF_BEAM_RANDOM 0x0004
#define SF_BEAM_RING 0x0008
#define SF_BEAM_SPARKSTART 0x0010
#define SF_BEAM_SPARKEND 0x0020
#define SF_BEAM_DECALS 0x0040
#define SF_BEAM_SHADEIN 0x0080
#define SF_BEAM_SHADEOUT 0x0100
#define SF_BEAM_TEMPORARY 0x8000

#define SF_SPRITE_STARTON 0x0001
#define SF_SPRITE_ONCE 0x0002
#define SF_SPRITE_TEMPORARY 0x8000

class CSprite : public CPointEntity
{
public:
	void Spawn(void);
	void Restart(void);
	void Precache(void);

	int ObjectCaps(void)
	{
		int flags = 0;

		if (pev->spawnflags & SF_SPRITE_TEMPORARY)
			flags = FCAP_DONT_SAVE;

		return (CBaseEntity::ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | flags;
	}

	void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	void Animate(float frames);
	void Expand(float scaleSpeed, float fadeSpeed);
	void SpriteInit(const char *pSpriteName, const Vector &origin);

	inline void SetAttachment(edict_t *pEntity, int attachment)
	{
		if (pEntity)
		{
			pev->skin = ENTINDEX(pEntity);
			pev->body = attachment;
			pev->aiment = pEntity;
			pev->movetype = MOVETYPE_FOLLOW;
		}
	}
	void TurnOff(void);
	void TurnOn(void);

public:
	inline float Frames(void){ return m_maxFrame; }

	inline void SetTransparency(int rendermode, int r, int g, int b, int a, int fx)
	{
		pev->rendermode = rendermode;
		pev->rendercolor.x = r;
		pev->rendercolor.y = g;
		pev->rendercolor.z = b;
		pev->renderamt = a;
		pev->renderfx = fx;
	}
	inline void SetTexture(int spriteIndex) { pev->modelindex = spriteIndex; }
	inline void SetScale(float scale) { pev->scale = scale; }
	inline void SetColor(int r, int g, int b) { pev->rendercolor.x = r; pev->rendercolor.y = g; pev->rendercolor.z = b; }
	inline void SetBrightness(int brightness){ pev->renderamt = brightness; }

	inline void AnimateAndDie(float framerate)
	{
		SetThink(&CSprite::AnimateUntilDead);
		pev->framerate = framerate;
		pev->dmgtime = gpGlobals->time + (m_maxFrame / framerate);
		pev->nextthink = gpGlobals->time;
	}

public:
	void EXPORT AnimateThink(void);
	void EXPORT ExpandThink(void);
	void EXPORT AnimateUntilDead(void);

	virtual int Save(CSave &save);
	virtual int Restore(CRestore &restore);
	static TYPEDESCRIPTION m_SaveData[];
	static CSprite *SpriteCreate(const char *pSpriteName, const Vector &origin, BOOL animate);

private:
	float m_lastTime;
	float m_maxFrame;
};

class CBeam : public CBaseEntity
{
public:
	void Spawn(void);
	void Precache(void);

	int ObjectCaps(void)
	{
		int flags = 0;

		if (pev->spawnflags & SF_BEAM_TEMPORARY)
			flags = FCAP_DONT_SAVE;

		return (CBaseEntity::ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | flags;
	}

public:
	inline void SetType(int type) { pev->rendermode = (pev->rendermode & 0xF0) | (type & 0x0F); }
	inline void SetFlags(int flags) { pev->rendermode = (pev->rendermode & 0x0F) | (flags & 0xF0); }
	inline void SetStartPos(const Vector &pos) { pev->origin = pos; }
	inline void SetEndPos(const Vector &pos){ pev->angles = pos; }

	void SetStartEntity(int entityIndex);
	void SetEndEntity(int entityIndex);

	inline void SetStartAttachment(int attachment) { pev->sequence = (pev->sequence & 0x0FFF) | ((attachment & 0xF) << 12); }
	inline void SetEndAttachment(int attachment) { pev->skin = (pev->skin & 0x0FFF) | ((attachment & 0xF) << 12); }
	inline void SetTexture(int spriteIndex) { pev->modelindex = spriteIndex; }
	inline void SetWidth(int width) { pev->scale = width; }
	inline void SetNoise(int amplitude) { pev->body = amplitude; }
	inline void SetColor(int r, int g, int b) { pev->rendercolor.x = r; pev->rendercolor.y = g; pev->rendercolor.z = b; }
	inline void SetBrightness(int brightness) { pev->renderamt = brightness; }
	inline void SetFrame(float frame) { pev->frame = frame; }
	inline void SetScrollRate(int speed){ pev->animtime = speed; }

public:
	inline int GetType(void) { return pev->rendermode & 0x0F; }
	inline int GetFlags(void) { return pev->rendermode & 0xF0; }
	inline int GetStartEntity(void) { return pev->sequence & 0xFFF; }
	inline int GetEndEntity(void) { return pev->skin & 0xFFF; }
	const Vector &GetStartPos(void);
	const Vector &GetEndPos(void);

public:
	Vector Center(void){ return (GetStartPos() + GetEndPos()) * 0.5; }

public:
	inline int GetTexture(void) { return pev->modelindex; }
	inline int GetWidth(void) { return (int)(pev->scale); }
	inline int GetNoise(void) { return pev->body; }
	inline int GetBrightness(void) { return (int)(pev->renderamt); }
	inline int GetFrame(void) { return (int)(pev->frame); }
	inline int GetScrollRate(void){ return (int)(pev->animtime); }

public:
	void EXPORT TriggerTouch(CBaseEntity *pOther);
	void RelinkBeam(void);
	void DoSparks(const Vector &start, const Vector &end);
	CBaseEntity *RandomTargetname(const char *szName);
	void BeamDamage(TraceResult *ptr);
	void BeamInit(const char *pSpriteName, int width);
	void PointsInit(const Vector &start, const Vector &end);
	void PointEntInit(const Vector &start, int endIndex);
	void EntsInit(int startIndex, int endIndex);
	void HoseInit(const Vector &start, const Vector &direction);

public:
	static CBeam *BeamCreate(const char *pSpriteName, int width);

public:
	inline void LiveForTime(float time){ SetThink(&CBaseEntity::SUB_Remove); pev->nextthink = gpGlobals->time + time; }

	inline void BeamDamageInstant(TraceResult *ptr, float damage)
	{
		pev->dmg = damage;
		pev->dmgtime = gpGlobals->time - 1;
		BeamDamage(ptr);
	}
};

#define SF_MESSAGE_ONCE 0x0001
#define SF_MESSAGE_ALL 0x0002

class CLaser : public CBeam
{
public:
	void Spawn(void);
	void Precache(void);
	void KeyValue(KeyValueData *pkvd);
	void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	int Save(CSave &save);
	int Restore(CRestore &restore);

public:
	void TurnOn(void);
	void TurnOff(void);
	int IsOn(void);

public:
	void FireAtPoint(TraceResult &point);
	void EXPORT StrikeThink(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	CSprite *m_pSprite;
	int m_iszSpriteName;
	Vector m_firePosition;
};

#endif
```

`dlls/enginecallback.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef ENGINECALLBACK_H
#define ENGINECALLBACK_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#include "event_flags.h"

// Must be provided by user of this code
extern enginefuncs_t g_engfuncs;

// The actual engine callbacks
#define GETPLAYERUSERID (*g_engfuncs.pfnGetPlayerUserId)
#define PRECACHE_GENERIC	(*g_engfuncs.pfnPrecacheGeneric)
#ifdef CLIENT_DLL
inline int PRECACHE_MODEL( const char *s ) { return 0; }
inline int PRECACHE_SOUND( const char *s ) { return 0; }
#define SET_MODEL(x, y)
#else
#define PRECACHE_MODEL	(*g_engfuncs.pfnPrecacheModel)
#define PRECACHE_SOUND	(*g_engfuncs.pfnPrecacheSound)
#define SET_MODEL		(*g_engfuncs.pfnSetModel)
#endif
#define MODEL_INDEX		(*g_engfuncs.pfnModelIndex)
#define MODEL_FRAMES	(*g_engfuncs.pfnModelFrames)
#define SET_SIZE		(*g_engfuncs.pfnSetSize)
#define CHANGE_LEVEL	(*g_engfuncs.pfnChangeLevel)
#define GET_SPAWN_PARMS	(*g_engfuncs.pfnGetSpawnParms)
#define SAVE_SPAWN_PARMS (*g_engfuncs.pfnSaveSpawnParms)
#define VEC_TO_YAW		(*g_engfuncs.pfnVecToYaw)
#define VEC_TO_ANGLES	(*g_engfuncs.pfnVecToAngles)
#define MOVE_TO_ORIGIN  (*g_engfuncs.pfnMoveToOrigin)
#define oldCHANGE_YAW		(*g_engfuncs.pfnChangeYaw)
#define CHANGE_PITCH	(*g_engfuncs.pfnChangePitch)
#define MAKE_VECTORS	(*g_engfuncs.pfnMakeVectors)
#define CREATE_ENTITY	(*g_engfuncs.pfnCreateEntity)
#define REMOVE_ENTITY	(*g_engfuncs.pfnRemoveEntity)
#define CREATE_NAMED_ENTITY		(*g_engfuncs.pfnCreateNamedEntity)
#define MAKE_STATIC		(*g_engfuncs.pfnMakeStatic)
#define ENT_IS_ON_FLOOR	(*g_engfuncs.pfnEntIsOnFloor)
#define DROP_TO_FLOOR	(*g_engfuncs.pfnDropToFloor)
#define WALK_MOVE		(*g_engfuncs.pfnWalkMove)
#define SET_ORIGIN		(*g_engfuncs.pfnSetOrigin)
#define EMIT_SOUND_DYN2 (*g_engfuncs.pfnEmitSound)
#define BUILD_SOUND_MSG (*g_engfuncs.pfnBuildSoundMsg)
#define TRACE_LINE		(*g_engfuncs.pfnTraceLine)
#define TRACE_TOSS		(*g_engfuncs.pfnTraceToss)
#define TRACE_MONSTER_HULL		(*g_engfuncs.pfnTraceMonsterHull)
#define TRACE_HULL		(*g_engfuncs.pfnTraceHull)
#define GET_AIM_VECTOR	(*g_engfuncs.pfnGetAimVector)
#define SERVER_COMMAND	(*g_engfuncs.pfnServerCommand)
#define SERVER_EXECUTE2	(*g_engfuncs.pfnServerExecute)//SERVER_EXECUTE already present in windows winspool.h
#define CLIENT_COMMAND	(*g_engfuncs.pfnClientCommand)
#define PARTICLE_EFFECT	(*g_engfuncs.pfnParticleEffect)
#define LIGHT_STYLE		(*g_engfuncs.pfnLightStyle)
#define DECAL_INDEX		(*g_engfuncs.pfnDecalIndex)
#define POINT_CONTENTS	(*g_engfuncs.pfnPointContents)
#define CRC32_INIT           (*g_engfuncs.pfnCRC32_Init)
#define CRC32_PROCESS_BUFFER (*g_engfuncs.pfnCRC32_ProcessBuffer)
#define CRC32_PROCESS_BYTE   (*g_engfuncs.pfnCRC32_ProcessByte)
#define CRC32_FINAL          (*g_engfuncs.pfnCRC32_Final)
#define RANDOM_LONG		(*g_engfuncs.pfnRandomLong)
#define RANDOM_FLOAT	(*g_engfuncs.pfnRandomFloat)
#define GETPLAYERAUTHID	(*g_engfuncs.pfnGetPlayerAuthId)
#define GAME_TIME		(*g_engfuncs.pfnTime)

inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {
	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);
}
#define MESSAGE_END		(*g_engfuncs.pfnMessageEnd)
#define WRITE_BYTE		(*g_engfuncs.pfnWriteByte)
#define WRITE_CHAR		(*g_engfuncs.pfnWriteChar)
#define WRITE_SHORT		(*g_engfuncs.pfnWriteShort)
#define WRITE_LONG		(*g_engfuncs.pfnWriteLong)
#define WRITE_ANGLE		(*g_engfuncs.pfnWriteAngle)
#define WRITE_COORD		(*g_engfuncs.pfnWriteCoord)
#define WRITE_STRING	(*g_engfuncs.pfnWriteString)
#define WRITE_ENTITY	(*g_engfuncs.pfnWriteEntity)
#define CVAR_REGISTER	(*g_engfuncs.pfnCVarRegister)
#define CVAR_GET_FLOAT	(*g_engfuncs.pfnCVarGetFloat)
#define CVAR_GET_STRING	(*g_engfuncs.pfnCVarGetString)
#define CVAR_SET_FLOAT	(*g_engfuncs.pfnCVarSetFloat)
#define CVAR_SET_STRING	(*g_engfuncs.pfnCVarSetString)
#define CVAR_GET_POINTER (*g_engfuncs.pfnCVarGetPointer)
#define ALERT			(*g_engfuncs.pfnAlertMessage)
#define ENGINE_FPRINTF	(*g_engfuncs.pfnEngineFprintf)
#define ALLOC_PRIVATE	(*g_engfuncs.pfnPvAllocEntPrivateData)
inline void *GET_PRIVATE( edict_t *pent )
{
	if ( pent )
		return pent->pvPrivateData;
	return NULL;
}

#define FREE_PRIVATE	(*g_engfuncs.pfnFreeEntPrivateData)
//#define STRING			(*g_engfuncs.pfnSzFromIndex)
#define ALLOC_STRING	(*g_engfuncs.pfnAllocString)
#define FIND_ENTITY_BY_STRING	(*g_engfuncs.pfnFindEntityByString)
#define GETENTITYILLUM	(*g_engfuncs.pfnGetEntityIllum)
#define FIND_ENTITY_IN_SPHERE		(*g_engfuncs.pfnFindEntityInSphere)
#define FIND_CLIENT_IN_PVS			(*g_engfuncs.pfnFindClientInPVS)
#define EMIT_AMBIENT_SOUND			(*g_engfuncs.pfnEmitAmbientSound)
#define GET_MODEL_PTR				(*g_engfuncs.pfnGetModelPtr)
#define REG_USER_MSG				(*g_engfuncs.pfnRegUserMsg)
#define GET_BONE_POSITION			(*g_engfuncs.pfnGetBonePosition)
#define FUNCTION_FROM_NAME			(*g_engfuncs.pfnFunctionFromName)
#define NAME_FOR_FUNCTION			(*g_engfuncs.pfnNameForFunction)
#define TRACE_TEXTURE				(*g_engfuncs.pfnTraceTexture)
#define CLIENT_PRINTF				(*g_engfuncs.pfnClientPrintf)
#define CMD_ARGS					(*g_engfuncs.pfnCmd_Args)
#define CMD_ARGC					(*g_engfuncs.pfnCmd_Argc)
#define CMD_ARGV					(*g_engfuncs.pfnCmd_Argv)
#define GET_ATTACHMENT			(*g_engfuncs.pfnGetAttachment)
#define SET_VIEW				(*g_engfuncs.pfnSetView)
#define SET_CROSSHAIRANGLE		(*g_engfuncs.pfnCrosshairAngle)
#define LOAD_FILE_FOR_ME		(*g_engfuncs.pfnLoadFileForMe)
#define FREE_FILE				(*g_engfuncs.pfnFreeFile)
#define COMPARE_FILE_TIME		(*g_engfuncs.pfnCompareFileTime)
#define GET_GAME_DIR			(*g_engfuncs.pfnGetGameDir)
#define IS_MAP_VALID			(*g_engfuncs.pfnIsMapValid)
#define NUMBER_OF_ENTITIES		(*g_engfuncs.pfnNumberOfEntities)
#define IS_DEDICATED_SERVER		(*g_engfuncs.pfnIsDedicatedServer)

#define PRECACHE_EVENT			(*g_engfuncs.pfnPrecacheEvent)
#define PLAYBACK_EVENT_FULL		(*g_engfuncs.pfnPlaybackEvent)

#define ENGINE_SET_PVS			(*g_engfuncs.pfnSetFatPVS)
#define ENGINE_SET_PAS			(*g_engfuncs.pfnSetFatPAS)

#define ENGINE_CHECK_VISIBILITY (*g_engfuncs.pfnCheckVisibility)

#define DELTA_SET				( *g_engfuncs.pfnDeltaSetField )
#define DELTA_UNSET				( *g_engfuncs.pfnDeltaUnsetField )
#define DELTA_ADDENCODER		( *g_engfuncs.pfnDeltaAddEncoder )
#define ENGINE_CURRENT_PLAYER   ( *g_engfuncs.pfnGetCurrentPlayer )

#define	ENGINE_CANSKIP			( *g_engfuncs.pfnCanSkipPlayer )

#define DELTA_FINDFIELD			( *g_engfuncs.pfnDeltaFindField )
#define DELTA_SETBYINDEX		( *g_engfuncs.pfnDeltaSetFieldByIndex )
#define DELTA_UNSETBYINDEX		( *g_engfuncs.pfnDeltaUnsetFieldByIndex )

#define ENGINE_GETPHYSINFO		( *g_engfuncs.pfnGetPhysicsInfoString )

#define ENGINE_SETGROUPMASK		( *g_engfuncs.pfnSetGroupMask )

#define ENGINE_INSTANCE_BASELINE ( *g_engfuncs.pfnCreateInstancedBaseline )

#define ENGINE_FORCE_UNMODIFIED	( *g_engfuncs.pfnForceUnmodified )

#define PLAYER_CNX_STATS		( *g_engfuncs.pfnGetPlayerStats )
#define CREATE_FAKE_CLIENT  ( *g_engfuncs.pfnCreateFakeClient )
#define GET_USERINFO   ( *g_engfuncs.pfnGetInfoKeyBuffer )
#define SET_KEY_VALUE   ( *g_engfuncs.pfnSetKeyValue )
#define SET_CLIENT_KEY_VALUE ( *g_engfuncs.pfnSetClientKeyValue )
#define GET_INFO_BUFFER   (*g_engfuncs.pfnGetInfoKeyBuffer)
#define GET_KEY_VALUE   (*g_engfuncs.pfnInfoKeyValue)
#endif		//ENGINECALLBACK_H

```

`dlls/exportdef.h`:

```h
#ifndef EXPORTDEF_H
#define EXPORTDEF_H
#if defined _WIN32 || defined __CYGWIN__
	#ifdef __GNUC__
		#define EXPORT __attribute__ ((dllexport))
	#else
		#define EXPORT __declspec(dllexport) // Note: actually gcc seems to also supports this syntax.
	#endif
#else
  #if __GNUC__ >= 4
	#define EXPORT __attribute__ ((visibility ("default")))
   #else
	#define EXPORT
  #endif
#endif
#define DLLEXPORT EXPORT
#define _DLLEXPORT EXPORT
#endif // EXPORTDEF_H

```

`dlls/extdll.h`:

```h
/***
*
*	Copyright (c) 1996-2001, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef EXTDLL_H
#define EXTDLL_H

//
// Global header file for extension DLLs
//

// Allow "DEBUG" in addition to default "_DEBUG"
#ifdef _DEBUG
#define DEBUG 1
#endif

#ifdef _MSC_VER
// Silence certain warnings
#pragma warning(disable : 4244)		// int or float down-conversion
#pragma warning(disable : 4305)		// int or float data truncation
#pragma warning(disable : 4201)		// nameless struct/union
#pragma warning(disable : 4514)		// unreferenced inline function removed
#pragma warning(disable : 4100)		// unreferenced formal parameter
#endif

#include "archtypes.h"     // DAL

// Prevent tons of unused windows definitions
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#define NOWINRES
#define NOSERVICE
#define NOMCX
#define NOIME
#include "windows.h"
#else // _WIN32
typedef unsigned char BYTE;
typedef int BOOL;
#define MAX_PATH PATH_MAX
#include <limits.h>
#include <stdarg.h>
#include <string.h> // memset 

#define _vsnprintf(a,b,c,d) vsnprintf(a,b,c,d)
#endif //_WIN32

// Misc C-runtime library headers
#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#ifndef min
#define min(a,b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef max
#define max(a,b)  (((a) > (b)) ? (a) : (b))
#endif

// Header file containing definition of globalvars_t and entvars_t
//typedef unsigned int func_t;					//
//typedef unsigned int string_t;				// from engine's pr_comp.h;
typedef float vec_t;				// needed before including progdefs.h

// Vector class
#include "vector.h"

// Defining it as a (bogus) struct helps enforce type-checking
#define vec3_t Vector

// Shared engine/DLL constants
#include "const.h"
#include "progdefs.h"
#include "edict.h"

// Shared header describing protocol between engine and DLLs
#include "eiface.h"

// Shared header between the client DLL and the game DLLs
#include "cdll_dll.h"

#endif //EXTDLL_H

```

`dlls/gamerules.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

class CBasePlayerItem;
class CBasePlayer;
class CItem;
class CBasePlayerAmmo;

#define MAX_MOTD_CHUNK 60
#define MAX_MOTD_LENGTH 1536

#define STARTMONEY_MAX 32000
#define STARTMONEY_MIN 800
enum
{
	GR_NONE = 0,
	GR_WEAPON_RESPAWN_YES,
	GR_WEAPON_RESPAWN_NO,
	GR_AMMO_RESPAWN_YES,
	GR_AMMO_RESPAWN_NO,
	GR_ITEM_RESPAWN_YES,
	GR_ITEM_RESPAWN_NO,
	GR_PLR_DROP_GUN_ALL,
	GR_PLR_DROP_GUN_ACTIVE,
	GR_PLR_DROP_GUN_NO,
	GR_PLR_DROP_AMMO_ALL,
	GR_PLR_DROP_AMMO_ACTIVE,
	GR_PLR_DROP_AMMO_NO
};

enum
{
	GR_NOTTEAMMATE = 0,
	GR_TEAMMATE,
	GR_ENEMY,
	GR_ALLY,
	GR_NEUTRAL
};

class CGameRules
{
public:
	virtual void RefreshSkillData(void);
	virtual void Think(void) = 0;
	virtual BOOL IsAllowedToSpawn(CBaseEntity *pEntity) = 0;
	virtual BOOL FAllowFlashlight(void) = 0;
	virtual BOOL FShouldSwitchWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon) = 0;
	virtual BOOL GetNextBestWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon) = 0;
	virtual BOOL IsMultiplayer(void) = 0;
	virtual BOOL IsDeathmatch(void) = 0;
	virtual BOOL IsTeamplay(void) { return FALSE; }
	virtual BOOL IsCoOp(void) = 0;
	virtual const char *GetGameDescription(void) { return "Counter-Strike"; }
	virtual BOOL ClientConnected(edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[128]) = 0;
	virtual void InitHUD(CBasePlayer *pl) = 0;
	virtual void ClientDisconnected(edict_t *pClient) = 0;
	virtual void UpdateGameMode(CBasePlayer *pPlayer) {}
	virtual float FlPlayerFallDamage(CBasePlayer *pPlayer) = 0;
	virtual BOOL FPlayerCanTakeDamage(CBasePlayer *pPlayer, CBaseEntity *pAttacker) { return TRUE; }
	virtual BOOL ShouldAutoAim(CBasePlayer *pPlayer, edict_t *target) { return TRUE; }
	virtual void PlayerSpawn(CBasePlayer *pPlayer) = 0;
	virtual void PlayerThink(CBasePlayer *pPlayer) = 0;
	virtual BOOL FPlayerCanRespawn(CBasePlayer *pPlayer) = 0;
	virtual float FlPlayerSpawnTime(CBasePlayer *pPlayer) = 0;
	virtual edict_t *GetPlayerSpawnSpot(CBasePlayer *pPlayer);
	virtual BOOL AllowAutoTargetCrosshair(void) { return TRUE; }
	virtual BOOL ClientCommand_DeadOrAlive(CBasePlayer *pPlayer, const char *pcmd) { return FALSE; }
	virtual BOOL ClientCommand(CBasePlayer *pPlayer, const char *pcmd) { return FALSE; }
	virtual void ClientUserInfoChanged(CBasePlayer *pPlayer, char *infobuffer) {}
	virtual int IPointsForKill(CBasePlayer *pAttacker, CBasePlayer *pKilled) = 0;
	virtual void PlayerKilled(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor) = 0;
	virtual void DeathNotice(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor) = 0;
	virtual BOOL CanHavePlayerItem(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual void PlayerGotWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon) = 0;
	virtual int WeaponShouldRespawn(CBasePlayerItem *pWeapon) = 0;
	virtual float FlWeaponRespawnTime(CBasePlayerItem *pWeapon) = 0;
	virtual float FlWeaponTryRespawn(CBasePlayerItem *pWeapon) = 0;
	virtual Vector VecWeaponRespawnSpot(CBasePlayerItem *pWeapon) = 0;
	virtual BOOL CanHaveItem(CBasePlayer *pPlayer, CItem *pItem) = 0;
	virtual void PlayerGotItem(CBasePlayer *pPlayer, CItem *pItem) = 0;
	virtual int ItemShouldRespawn(CItem *pItem) = 0;
	virtual float FlItemRespawnTime(CItem *pItem) = 0;
	virtual Vector VecItemRespawnSpot(CItem *pItem) = 0;
	virtual BOOL CanHaveAmmo(CBasePlayer *pPlayer, const char *pszAmmoName, int iMaxCarry);
	virtual void PlayerGotAmmo(CBasePlayer *pPlayer, char *szName, int iCount) = 0;
	virtual int AmmoShouldRespawn(CBasePlayerAmmo *pAmmo) = 0;
	virtual float FlAmmoRespawnTime(CBasePlayerAmmo *pAmmo) = 0;
	virtual Vector VecAmmoRespawnSpot(CBasePlayerAmmo *pAmmo) = 0;
	virtual float FlHealthChargerRechargeTime(void) = 0;
	virtual float FlHEVChargerRechargeTime(void) { return 0; }
	virtual int DeadPlayerWeapons(CBasePlayer *pPlayer) = 0;
	virtual int DeadPlayerAmmo(CBasePlayer *pPlayer) = 0;
	virtual const char *GetTeamID(CBaseEntity *pEntity) = 0;
	virtual int PlayerRelationship(CBaseEntity *pPlayer, CBaseEntity *pTarget) = 0;
	virtual int GetTeamIndex(const char *pTeamName) { return -1; }
	virtual const char *GetIndexedTeamName(int teamIndex) { return ""; }
	virtual BOOL IsValidTeam(const char *pTeamName) { return TRUE; }
	virtual void ChangePlayerTeam(CBasePlayer *pPlayer, const char *pTeamName, BOOL bKill, BOOL bGib) {}
	virtual const char *SetDefaultPlayerTeam(CBasePlayer *pPlayer) { return ""; }
	virtual BOOL PlayTextureSounds(void) { return TRUE; }
	virtual BOOL FAllowMonsters(void) = 0;
	virtual void EndMultiplayerGame(void) {}
	virtual BOOL IsFreezePeriod(void) { return m_bFreezePeriod; }
	virtual void ServerDeactivate(void) {}
	virtual void CheckMapConditions(void) {}

public:
	BOOL m_bFreezePeriod;
	BOOL m_bBombDropped;
};

extern char *GetTeam(int teamNo);
extern void Broadcast(const char *sentence, int pitch = 100 );
extern CGameRules *InstallGameRules(void);

class CHalfLifeRules : public CGameRules
{
public:
	CHalfLifeRules(void);

public:
	virtual void Think(void);
	virtual BOOL IsAllowedToSpawn(CBaseEntity *pEntity);
	virtual BOOL FAllowFlashlight(void) { return TRUE; }
	virtual BOOL FShouldSwitchWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual BOOL GetNextBestWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon);
	virtual BOOL IsMultiplayer(void);
	virtual BOOL IsDeathmatch(void);
	virtual BOOL IsCoOp(void);
	virtual BOOL ClientConnected(edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[128]);
	virtual void InitHUD(CBasePlayer *pl);
	virtual void ClientDisconnected(edict_t *pClient);
	virtual float FlPlayerFallDamage(CBasePlayer *pPlayer);
	virtual void PlayerSpawn(CBasePlayer *pPlayer);
	virtual void PlayerThink(CBasePlayer *pPlayer);
	virtual BOOL FPlayerCanRespawn(CBasePlayer *pPlayer);
	virtual float FlPlayerSpawnTime(CBasePlayer *pPlayer);
	virtual edict_t *GetPlayerSpawnSpot(CBasePlayer *pPlayer);
	virtual BOOL AllowAutoTargetCrosshair(void);
	virtual int IPointsForKill(CBasePlayer *pAttacker, CBasePlayer *pKilled);
	virtual void PlayerKilled(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor);
	virtual void DeathNotice(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor);
	virtual void PlayerGotWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual int WeaponShouldRespawn(CBasePlayerItem *pWeapon);
	virtual float FlWeaponRespawnTime(CBasePlayerItem *pWeapon);
	virtual float FlWeaponTryRespawn(CBasePlayerItem *pWeapon);
	virtual Vector VecWeaponRespawnSpot(CBasePlayerItem *pWeapon);
	virtual BOOL CanHaveItem(CBasePlayer *pPlayer, CItem *pItem);
	virtual void PlayerGotItem(CBasePlayer *pPlayer, CItem *pItem);
	virtual int ItemShouldRespawn(CItem *pItem);
	virtual float FlItemRespawnTime(CItem *pItem);
	virtual Vector VecItemRespawnSpot(CItem *pItem);
	virtual void PlayerGotAmmo(CBasePlayer *pPlayer, char *szName, int iCount);
	virtual int AmmoShouldRespawn(CBasePlayerAmmo *pAmmo);
	virtual float FlAmmoRespawnTime(CBasePlayerAmmo *pAmmo);
	virtual Vector VecAmmoRespawnSpot(CBasePlayerAmmo *pAmmo);
	virtual float FlHealthChargerRechargeTime(void);
	virtual int DeadPlayerWeapons(CBasePlayer *pPlayer);
	virtual int DeadPlayerAmmo(CBasePlayer *pPlayer);
	virtual BOOL FAllowMonsters(void);
	virtual const char *GetTeamID(CBaseEntity *pEntity) { return ""; }
	virtual int PlayerRelationship(CBaseEntity *pPlayer, CBaseEntity *pTarget);
};

#define MAX_MAPS 100
#define MAX_VIPQUEUES 5

enum
{
	WINSTATUS_CT = 1,
	WINSTATUS_TERRORIST,
	WINSTATUS_DRAW
};

#define Target_Bombed 1
#define VIP_Escaped 2
#define VIP_Assassinated 3
#define Terrorists_Escaped 4
#define CTs_PreventEscape 5
#define Escaping_Terrorists_Neutralized 6
#define Bomb_Defused 7
#define CTs_Win 8
#define Terrorists_Win 9
#define Round_Draw 10
#define All_Hostages_Rescued 11
#define Target_Saved 12
#define Hostages_Not_Rescued 13
#define Terrorists_Not_Escaped 14
#define VIP_Not_Escaped 15
#define Game_Commencing 16

#include "voice_gamemgr.h"

class CHalfLifeMultiplay : public CGameRules
{
public:
	CHalfLifeMultiplay(void);

public:
	virtual void Think(void);
	virtual void RefreshSkillData(void);
	virtual BOOL IsAllowedToSpawn(CBaseEntity *pEntity);
	virtual BOOL FAllowFlashlight(void);
	virtual BOOL FShouldSwitchWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual BOOL GetNextBestWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon);
	virtual BOOL IsMultiplayer(void);
	virtual BOOL IsDeathmatch(void);
	virtual BOOL IsCoOp(void);
	virtual BOOL ClientConnected(edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[128]);
	virtual void InitHUD(CBasePlayer *pl);
	virtual void ClientDisconnected(edict_t *pClient);
	virtual void UpdateGameMode(CBasePlayer *pPlayer);
	virtual float FlPlayerFallDamage(CBasePlayer *pPlayer);
	virtual BOOL FPlayerCanTakeDamage(CBasePlayer *pPlayer, CBaseEntity *pAttacker);
	virtual void PlayerSpawn(CBasePlayer *pPlayer);
	virtual void PlayerThink(CBasePlayer *pPlayer);
	virtual BOOL FPlayerCanRespawn(CBasePlayer *pPlayer);
	virtual float FlPlayerSpawnTime(CBasePlayer *pPlayer);
	virtual edict_t *GetPlayerSpawnSpot(CBasePlayer *pPlayer);
	virtual BOOL AllowAutoTargetCrosshair(void);
	virtual BOOL ClientCommand_DeadOrAlive(CBasePlayer *pPlayer, const char *pcmd);
	virtual BOOL ClientCommand(CBasePlayer *pPlayer, const char *pcmd);
	virtual void ClientUserInfoChanged(CBasePlayer *pPlayer, char *infobuffer);
	virtual int IPointsForKill(CBasePlayer *pAttacker, CBasePlayer *pKilled);
	virtual void PlayerKilled(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor);
	virtual void DeathNotice(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor);
	virtual BOOL CanHavePlayerItem(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual void PlayerGotWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual int WeaponShouldRespawn(CBasePlayerItem *pWeapon);
	virtual float FlWeaponRespawnTime(CBasePlayerItem *pWeapon);
	virtual float FlWeaponTryRespawn(CBasePlayerItem *pWeapon);
	virtual Vector VecWeaponRespawnSpot(CBasePlayerItem *pWeapon);
	virtual BOOL CanHaveItem(CBasePlayer *pPlayer, CItem *pItem);
	virtual void PlayerGotItem(CBasePlayer *pPlayer, CItem *pItem);
	virtual int ItemShouldRespawn(CItem *pItem);
	virtual float FlItemRespawnTime(CItem *pItem);
	virtual Vector VecItemRespawnSpot(CItem *pItem);
	virtual void PlayerGotAmmo(CBasePlayer *pPlayer, char *szName, int iCount);
	virtual int AmmoShouldRespawn(CBasePlayerAmmo *pAmmo);
	virtual float FlAmmoRespawnTime(CBasePlayerAmmo *pAmmo);
	virtual Vector VecAmmoRespawnSpot(CBasePlayerAmmo *pAmmo);
	virtual float FlHealthChargerRechargeTime(void);
	virtual float FlHEVChargerRechargeTime(void);
	virtual int DeadPlayerWeapons(CBasePlayer *pPlayer);
	virtual int DeadPlayerAmmo(CBasePlayer *pPlayer);
	virtual const char *GetTeamID(CBaseEntity *pEntity) { return ""; }
	virtual int PlayerRelationship(CBaseEntity *pPlayer, CBaseEntity *pTarget);
	virtual BOOL PlayTextureSounds(void) { return FALSE; }
	virtual BOOL FAllowMonsters(void);
	virtual void EndMultiplayerGame(void) { GoToIntermission(); }
	virtual void CheckMapConditions(void);
	virtual void ServerDeactivate(void);
	virtual void CleanUpMap(void);
	virtual void RestartRound(void);
	virtual void CheckWinConditions(void);
	virtual void RemoveGuns(void);
	virtual void GiveC4(void);
	virtual void ChangeLevel(void);
	virtual void GoToIntermission(void);
	virtual void SetRestartServerAtRoundEnd();
	virtual BOOL ShouldRestart();
public:
	void SendMOTDToClient(edict_t *client);
	void InitializePlayerCounts(int &NumAliveTerrorist, int &NumAliveCT, int &NumDeadTerrorist, int &NumDeadCT);
	BOOL NeededPlayersCheck(BOOL &bNeededPlayers);
	BOOL VIPRoundEndCheck(BOOL bNeededPlayers);
	BOOL PrisonRoundEndCheck(int NumAliveTerrorist, int NumAliveCT, int NumDeadTerrorist, int NumDeadCT, BOOL bNeededPlayers);
	BOOL BombRoundEndCheck(BOOL bNeededPlayers);
	BOOL TeamExterminationCheck(int NumAliveTerrorist, int NumAliveCT, int NumDeadTerrorist, int NumDeadCT, BOOL bNeededPlayers);
	BOOL HostageRescueRoundEndCheck(BOOL bNeededPlayers);
	void BalanceTeams(void);
	BOOL IsThereABomber(void);
	BOOL IsThereABomb(void);
	BOOL TeamFull(int team_id);
	BOOL TeamStacked(int newTeam_id, int curTeam_id);
	void StackVIPQueue(void);
	void CheckVIPQueue(void);
	BOOL IsVIPQueueEmpty(void);
	BOOL AddToVIPQueue(CBasePlayer *pPlayer);
	void ResetCurrentVIP(void);
	void PickNextVIP(void);
	void CheckFreezePeriodExpired(void);
	void CheckRoundTimeExpired(void);
	void CheckLevelInitialized(void);
	void CheckRestartRound(void);
	BOOL CheckTimeLimit(void);
	BOOL CheckMaxRounds(void);
	BOOL CheckGameOver(void);
	BOOL CheckWinLimit(void);
	void CheckAllowSpecator(void);
	void CheckGameCvar(void);
	void DisplayMaps(CBasePlayer *pPlayer, int mapId);
	void ResetAllMapVotes(void);
	void ProcessMapVote(CBasePlayer *pPlayer, int mapId);
	void UpdateTeamScores(void);
	void SwapAllPlayers(void);
	void TerminateRound(float tmDelay, int iWinStatus);
	void QueueCareerRoundEndMenu(float tmDelay, int iWinStatus);
	float TimeRemaining(void) { return m_iRoundTimeSecs - gpGlobals->time + m_fRoundCount; }
	BOOL HasRoundTimeExpired(void);
	BOOL IsBombPlanted(void);
	void MarkLivingPlayersOnTeamAsNotReceivingMoneyNextRound(int team);
	void CareerRestart(void);
	BOOL IsCareer(void) { return FALSE; }

public:
	CVoiceGameMgr m_VoiceGameMgr;
	float m_fTeamCount;
	float m_flCheckWinConditions;
	float m_fRoundCount;
	int m_iRoundTime;
	int m_iRoundTimeSecs;
	int m_iIntroRoundTime;
	float m_fIntroRoundCount;
	int m_iAccountTerrorist;
	int m_iAccountCT;
	int m_iNumTerrorist;
	int m_iNumCT;
	int m_iNumSpawnableTerrorist;
	int m_iNumSpawnableCT;
	int m_iSpawnPointCount_Terrorist;
	int m_iSpawnPointCount_CT;
	int m_iHostagesRescued;
	int m_iHostagesTouched;
	int m_iRoundWinStatus;
	short m_iNumCTWins;
	short m_iNumTerroristWins;
	bool m_bTargetBombed;
	bool m_bBombDefused;
	bool m_bMapHasBombTarget;
	bool m_bMapHasBombZone;
	bool m_bMapHasBuyZone;
	bool m_bMapHasRescueZone;
	bool m_bMapHasEscapeZone;
	int m_iMapHasVIPSafetyZone;
	int m_bMapHasCameras;
	int m_iC4Timer;
	int m_iC4Guy;
	int m_iLoserBonus;
	int m_iNumConsecutiveCTLoses;
	int m_iNumConsecutiveTerroristLoses;
	float m_fMaxIdlePeriod;
	int m_iLimitTeams;
	bool m_bLevelInitialized;
	bool m_bRoundTerminating;
	bool m_bCompleteReset;
	float m_flRequiredEscapeRatio;
	int m_iNumEscapers;
	int m_iHaveEscaped;
	bool m_bCTCantBuy;
	bool m_bTCantBuy;
	float m_flBombRadius;
	int m_iConsecutiveVIP;
	int m_iTotalGunCount;
	int m_iTotalGrenadeCount;
	int m_iTotalArmourCount;
	int m_iUnBalancedRounds;
	int m_iNumEscapeRounds;
	int m_iMapVotes[MAX_MAPS];
	int m_iLastPick;
	int m_iMaxMapTime;
	int m_iMaxRounds;
	int m_iTotalRoundsPlayed;
	int m_iMaxRoundsWon;
	int m_iStoredSpectValue;
	float m_flForceCameraValue;
	float m_flForceChaseCamValue;
	float m_flFadeToBlackValue;
	CBasePlayer *m_pVIP;
	CBasePlayer *VIPQueue[MAX_VIPQUEUES];
	float m_flIntermissionEndTime;
	float m_flIntermissionStartTime;
	int m_iEndIntermissionButtonHit;
	float m_tmNextPeriodicThink;
	bool m_bFirstConnected;
	bool m_bInCareerGame;
	float m_fCareerRoundMenuTime;
	int m_iCareerMatchWins;
	int m_iRoundWinDifference;
	float m_fCareerMatchMenuTime;
	bool m_bSkipSpawn;
	BOOL m_bShouldRestart;
};

extern DLL_GLOBAL CHalfLifeMultiplay *g_pGameRules;

```

`dlls/hintmessage.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include <tier1/UtlVector.h>

class CHintMessage
{
public:
	CHintMessage(const char *hintString, bool isHint, CUtlVector<const char *> *args, float duration);
	~CHintMessage(void);

public:
	float GetDuration(void) const { return m_duration; }
	void Send(CBaseEntity *client);
	bool IsEquivalent(const char *hintString, CUtlVector<const char *> *args) const;

private:
	const char *m_hintString;
	CUtlVector<char *> m_args;
	float m_duration;
	bool m_isHint;
};

class CHintMessageQueue
{
public:
	void Reset(void);
	void Update(CBaseEntity *player);
	bool AddMessage(const char *message, float duration, bool isHint, CUtlVector<const char *> *args);
	bool IsEmpty(void) { return m_messages.Count() == 0; }

private:
	float m_tmMessageEnd;
	CUtlVector<CHintMessage *> m_messages;
};

```

`dlls/monsterevent.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef MONSTEREVENT_H
#define MONSTEREVENT_H

typedef struct
{
	int event;
	char *options;
}
MonsterEvent_t;

#define EVENT_SPECIFIC 0
#define EVENT_SCRIPTED 1000
#define EVENT_SHARED 2000
#define EVENT_CLIENT 5000

#define MONSTER_EVENT_BODYDROP_LIGHT 2001
#define MONSTER_EVENT_BODYDROP_HEAVY 2002
#define MONSTER_EVENT_SWISHSOUND 2010

#endif
```

`dlls/monsters.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef MONSTERS_H
#include "skill.h"
#define MONSTERS_H

typedef enum
{
	HITGROUP_GENERIC,
	HITGROUP_HEAD,
	HITGROUP_CHEST,
	HITGROUP_STOMACH,
	HITGROUP_LEFTARM,
	HITGROUP_RIGHTARM,
	HITGROUP_LEFTLEG,
	HITGROUP_RIGHTLEG,
	HITGROUP_SHIELD,
	NUM_HITGROUPS
}
HitBoxGroup;

#define SF_MONSTER_WAIT_TILL_SEEN 1
#define SF_MONSTER_GAG 2
#define SF_MONSTER_HITMONSTERCLIP 4
#define SF_MONSTER_PRISONER 16
#define SF_MONSTER_WAIT_FOR_SCRIPT 128
#define SF_MONSTER_PREDISASTER 256
#define SF_MONSTER_FADECORPSE 512
#define SF_MONSTER_FALL_TO_GROUND 0x80000000
#define SF_MONSTER_TURRET_AUTOACTIVATE 32
#define SF_MONSTER_TURRET_STARTINACTIVE 64

extern void UTIL_MoveToOrigin(edict_t *pent, const Vector &vecGoal, float flDist, int iMoveType);
Vector VecCheckToss(entvars_t *pev, const Vector &vecSpot1, Vector vecSpot2, float flGravityAdj = 1);
Vector VecCheckThrow(entvars_t *pev, const Vector &vecSpot1, Vector vecSpot2, float flSpeed, float flGravityAdj = 1);

extern DLL_GLOBAL Vector g_vecAttackDir;
extern DLL_GLOBAL CONSTANT float g_flMeleeRange;
extern DLL_GLOBAL CONSTANT float g_flMediumRange;
extern DLL_GLOBAL CONSTANT float g_flLongRange;

extern void EjectBrass(const Vector &vecOrigin, const Vector &vecLeft, const Vector &vecVelocity, float rotation, int model, int soundtype, int entityIndex);
extern void EjectBrass2(const Vector &vecOrigin, const Vector &vecVelocity, float rotation, int model, int soundtype, entvars_t *pev);
extern void ExplodeModel(const Vector &vecOrigin, float speed, int model, int count);

BOOL FBoxVisible(entvars_t *pevLooker, entvars_t *pevTarget);
BOOL FBoxVisible(entvars_t *pevLooker, entvars_t *pevTarget, Vector &vecTargetOrigin, float flSize = 0);

#define R_AL -2
#define R_FR -1
#define R_NO 0
#define R_DL 1
#define R_HT 2
#define R_NM 3

#define bits_MEMORY_KILLED (1<<7)

class CGib : public CBaseEntity
{
public:
	void Spawn(const char *szGibModel); // -V762
	int ObjectCaps(void) { return (CBaseEntity::ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_DONT_SAVE; }

public:
	void EXPORT BounceGibTouch(CBaseEntity *pOther);
	void EXPORT StickyGibTouch(CBaseEntity *pOther);
	void EXPORT WaitTillLand(void);
	void LimitVelocity(void);

public:
	static void SpawnHeadGib(entvars_t *pevVictim);
	static void SpawnRandomGibs(entvars_t *pevVictim, int cGibs, int human);
	static void SpawnStickyGibs(entvars_t *pevVictim, Vector vecOrigin, int cGibs);

public:
	int m_bloodColor;
	int m_cBloodDecals;
	int m_material;
	float m_lifeTime;
};

#endif

```

`dlls/nodes.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef NODES_H
#define NODES_H

#define bits_NODE_GROUP_REALM 1

class CLink
{
public:
	entvars_t *m_pLinkEnt;
};

class CGraph
{
public:
	BOOL m_fGraphPresent;
	BOOL m_fGraphPointersSet;
	int m_cLinks;
	CLink *m_pLinkPool;

public:
	void InitGraph(void);
	int AllocNodes(void);
	int CheckNODFile(char *szMapName);
	int FLoadGraph(char *szMapName);
	int FSetGraphPointers(void);
	void ShowNodeConnections(int iNode);
	int FindNearestNode(const Vector &vecOrigin, CBaseEntity *pEntity);
	int FindNearestNode(const Vector &vecOrigin, int afNodeTypes);
};

extern CGraph WorldGraph;
#endif
```

`dlls/player.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef PLAYER_H
#define PLAYER_H

#include "pm_materials.h"
#include "hintmessage.h"
#include "weapons.h"

#define MAX_PLAYER_NAME_LENGTH 32
#define MAX_AUTOBUY_LENGTH 256
#define MAX_REBUY_LENGTH 256
#define MAX_LACTION_LENGTH 32

#define PLAYER_FATAL_FALL_SPEED (float)1100
#define PLAYER_MAX_SAFE_FALL_SPEED (float)500
#define DAMAGE_FOR_FALL_SPEED (float)100.0 / (PLAYER_FATAL_FALL_SPEED - PLAYER_MAX_SAFE_FALL_SPEED)
#define PLAYER_MIN_BOUNCE_SPEED (float)350
#define PLAYER_FALL_PUNCH_THRESHOLD (float)250.0

#define PFLAG_ONLADDER (1<<0)
#define PFLAG_ONSWING (1<<0)
#define PFLAG_ONTRAIN (1<<1)
#define PFLAG_ONBARNACLE (1<<2)
#define PFLAG_DUCKING (1<<3)
#define PFLAG_USING (1<<4)
#define PFLAG_OBSERVER (1<<5)

#define TRAIN_ACTIVE 0x80
#define TRAIN_NEW 0xc0
#define TRAIN_OFF 0x00
#define TRAIN_NEUTRAL 0x01
#define TRAIN_SLOW 0x02
#define TRAIN_MEDIUM 0x03
#define TRAIN_FAST 0x04
#define TRAIN_BACK 0x05

#define DHF_ROUND_STARTED (1<<1)
#define DHF_HOSTAGE_SEEN_FAR (1<<2)
#define DHF_HOSTAGE_SEEN_NEAR (1<<3)
#define DHF_HOSTAGE_USED (1<<4)
#define DHF_HOSTAGE_INJURED (1<<5)
#define DHF_HOSTAGE_KILLED (1<<6)
#define DHF_FRIEND_SEEN (1<<7)
#define DHF_ENEMY_SEEN (1<<8)
#define DHF_FRIEND_INJURED (1<<9)
#define DHF_FRIEND_KILLED (1<<10)
#define DHF_ENEMY_KILLED (1<<11)
#define DHF_BOMB_RETRIEVED (1<<12)
#define DHF_AMMO_EXHAUSTED (1<<15)
#define DHF_IN_TARGET_ZONE (1<<16)
#define DHF_IN_RESCUE_ZONE (1<<17)
#define DHF_IN_ESCAPE_ZONE (1<<18)
#define DHF_IN_VIPSAFETY_ZONE (1<<19)
#define DHF_NIGHTVISION (1<<20)
#define DHF_HOSTAGE_CTMOVE (1<<21)
#define	DHF_SPEC_DUCK (1<<22)

#define DHM_ROUND_CLEAR (DHF_ROUND_STARTED | DHF_HOSTAGE_KILLED | DHF_FRIEND_KILLED | DHF_BOMB_RETRIEVED)
#define DHM_CONNECT_CLEAR (DHF_HOSTAGE_SEEN_FAR | DHF_HOSTAGE_SEEN_NEAR | DHF_HOSTAGE_USED | DHF_HOSTAGE_INJURED | DHF_FRIEND_SEEN | DHF_ENEMY_SEEN | DHF_FRIEND_INJURED | DHF_ENEMY_KILLED | DHF_AMMO_EXHAUSTED | DHF_IN_TARGET_ZONE | DHF_IN_RESCUE_ZONE | DHF_IN_ESCAPE_ZONE | DHF_IN_VIPSAFETY_ZONE | DHF_HOSTAGE_CTMOVE | DHF_SPEC_DUCK)

#define SIGNAL_BUY (1<<0)
#define SIGNAL_BOMB (1<<1)
#define SIGNAL_RESCUE (1<<2)
#define SIGNAL_ESCAPE (1<<3)
#define SIGNAL_VIPSAFETY (1<<4)

class CUnifiedSignals
{
public:
	CUnifiedSignals(void)
	{
		m_flSignal = 0;
		m_flState = 0;
	}

public:
	void Update(void)
	{
		m_flState = m_flSignal;
		m_flSignal = 0;
	}

	void Signal(int flags) { m_flSignal |= flags; }
	int GetSignal(void) { return m_flSignal; }
	int GetState(void) { return m_flState; }

private:
	int m_flSignal;
	int m_flState;
};

#define IGNOREMSG_NONE 0
#define IGNOREMSG_ENEMY 1
#define IGNOREMSG_TEAM 2

#define CSUITPLAYLIST 4

#define SUIT_GROUP TRUE
#define SUIT_SENTENCE FALSE

#define SUIT_REPEAT_OK 0
#define SUIT_NEXT_IN_30SEC 30
#define SUIT_NEXT_IN_1MIN 60
#define SUIT_NEXT_IN_5MIN 300
#define SUIT_NEXT_IN_10MIN 600
#define SUIT_NEXT_IN_30MIN 1800
#define SUIT_NEXT_IN_1HOUR 3600

#define CSUITNOREPEAT 32

#define SOUND_FLASHLIGHT_ON "items/flashlight1.wav"
#define SOUND_FLASHLIGHT_OFF "items/flashlight1.wav"

#define TEAM_NAME_LENGTH 16

typedef enum
{
	PLAYER_IDLE,
	PLAYER_WALK,
	PLAYER_JUMP,
	PLAYER_SUPERJUMP,
	PLAYER_DIE,
	PLAYER_ATTACK1,
	PLAYER_ATTACK2,
	PLAYER_FLINCH,
	PLAYER_LARGE_FLINCH,
	PLAYER_RELOAD,
	PLAYER_HOLDBOMB
}
PLAYER_ANIM;

typedef enum
{
	Menu_OFF,
	Menu_ChooseTeam,
	Menu_IGChooseTeam,
	Menu_ChooseAppearance,
	Menu_Buy,
	Menu_BuyPistol,
	Menu_BuyRifle,
	Menu_BuyMachineGun,
	Menu_BuyShotgun,
	Menu_BuySubMachineGun,
	Menu_BuyItem,
	Menu_Radio1,
	Menu_Radio2,
	Menu_Radio3,
	Menu_ClientBuy
}
Menu;

typedef enum
{
	MODEL_UNASSIGNED,
	MODEL_URBAN,
	MODEL_TERROR,
	MODEL_LEET,
	MODEL_ARCTIC,
	MODEL_GSG9,
	MODEL_GIGN,
	MODEL_SAS,
	MODEL_GUERILLA,
	MODEL_VIP,
	MODEL_MILITIA,
	MODEL_SPETSNAZ
}
ModelName;

typedef enum
{
	JOINED,
	SHOWLTEXT,
	READINGLTEXT,
	SHOWTEAMSELECT,
	PICKINGTEAM,
	GETINTOGAME
}
JoinState;

typedef struct
{
	int m_primaryWeapon;
	int m_primaryAmmo;
	int m_secondaryWeapon;
	int m_secondaryAmmo;
	int m_heGrenade;
	int m_flashbang;
	int m_smokeGrenade;
	BOOL m_defuser;
	BOOL m_nightVision;
	int m_armor;
}
RebuyStruct;

typedef enum
{
	THROW_NONE,
	THROW_FORWARD,
	THROW_BACKWARD,
	THROW_HITVEL,
	THROW_BOMB,
	THROW_GRENADE,
	THROW_HITVEL_MINUS_AIRVEL
}
ThrowDirection;

#define MAX_ID_RANGE 2048
#define MAX_SPECTATOR_ID_RANGE 8192
#define SBAR_STRING_SIZE 128

#define SBAR_TARGETTYPE_TEAMMATE 1
#define SBAR_TARGETTYPE_ENEMY 2
#define SBAR_TARGETTYPE_HOSTAGE 3

enum sbar_data
{
	SBAR_ID_TARGETTYPE = 1,
	SBAR_ID_TARGETNAME,
	SBAR_ID_TARGETHEALTH,
	SBAR_END
};

typedef enum
{
	SILENT,
	CALM,
	INTENSE
}
MusicState;

#define CHAT_INTERVAL 1.0

class CBasePlayer : public CBaseMonster
{
public:
	virtual void Spawn(void);
	virtual void Precache(void) { }
	virtual void Restart(void) { }
	virtual int Save(CSave &save) { return 1; }
	virtual int Restore(CRestore &restore) { return 1; }
	virtual int ObjectCaps(void) { return CBaseMonster::ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }
	virtual int Classify(void) { return 0; }
	virtual void TraceAttack(entvars_t *pevAttacker, float flDamage, const Vector &vecDir, TraceResult *ptr, int bitsDamageType) { }
	virtual int TakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType) { return 0; }
	virtual int TakeHealth(float flHealth, int bitsDamageType) { return 0; }
	virtual void Killed(entvars_t *pevAttacker, int iGib);
	virtual void AddPoints(int score, BOOL bAllowNegativeScore) {}
	virtual void AddPointsToTeam(int score, BOOL bAllowNegativeScore) {}
	virtual BOOL AddPlayerItem(CBasePlayerItem *pItem) { return false; }
	virtual BOOL RemovePlayerItem(CBasePlayerItem *pItem) { return false; }
	virtual int GiveAmmo(int iAmount, char *szName, int iMax){ return 0; }
	virtual void StartSneaking(void) { m_tSneaking = gpGlobals->time - 1; }
	virtual void StopSneaking(void) { m_tSneaking = gpGlobals->time + 30; }
	virtual BOOL IsSneaking(void) { return m_tSneaking <= gpGlobals->time; }
	virtual BOOL IsAlive(void) { return pev->deadflag == DEAD_NO && pev->health > 0; }
	virtual BOOL IsPlayer(void) { return TRUE; }
	virtual BOOL IsNetClient(void) { return TRUE; }
	virtual const char *TeamID(void) { return NULL; }
	virtual BOOL FBecomeProne(void) { return TRUE; }
	virtual Vector BodyTarget(const Vector &posSrc) { return Center() + pev->view_ofs * RANDOM_FLOAT(0.5, 1.1); }
	virtual int Illumination(void) { return 0; }
	virtual BOOL ShouldFadeOnDeath(void) { return FALSE; }
	virtual void ResetMaxSpeed(void) {  }
	virtual void Jump(void) { }
	virtual void Duck(void) { }
	virtual void PreThink(void) { }
	virtual void PostThink(void) { }
	virtual Vector GetGunPosition(void);
	virtual BOOL IsBot(void) { return FALSE; }
	virtual void UpdateClientData(void) { }
	virtual void ImpulseCommands(void) { }
	virtual void RoundRespawn(void) { }
	virtual Vector GetAutoaimVector(float flDelta) { return g_vecZero; }
	virtual void Blind(float flUntilTime, float flHoldTime, float flFadeTime, int iAlpha) { }
	virtual void OnTouchingWeapon(CBasePlayerWeapon *pWeapon) {}

public:
	void Pain(int hitgroup, bool hitkevlar);
	void RenewItems(void);
	void PackDeadPlayerItems(void);
	void RemoveAllItems(BOOL removeSuit);
	void SwitchTeam(void);
	BOOL SwitchWeapon(CBasePlayerItem *pWeapon);
	BOOL IsOnLadder(void);
	BOOL FlashlightIsOn(void);
	void FlashlightTurnOn(void);
	void FlashlightTurnOff(void);
	void UpdatePlayerSound(void);
	void DeathSound(void);
	void SetAnimation(PLAYER_ANIM playerAnim);
	void SetWeaponAnimType(const char *szExtention);
	void CheatImpulseCommands(int iImpulse);
	void StartDeathCam(void);
	void StartObserver(const Vector &vecPosition, const Vector &vecViewAngle);
	CBaseEntity *Observer_IsValidTarget(int iTarget, bool bOnlyTeam);
	void Observer_FindNextPlayer(bool bReverse, char *name = NULL);
	void Observer_HandleButtons(void);
	void Observer_SetMode(int iMode);
	void Observer_CheckTarget(void);
	void Observer_CheckProperties(void);
	int IsObserver(void) { return pev->iuser1; }
	bool IsObservingPlayer(CBasePlayer *pTarget);
	void SetObserverAutoDirector(bool bState);
	BOOL CanSwitchObserverModes(void);
	void DropPlayerItem(const char *pszItemName);
	void ThrowPrimary(void);
	void ThrowWeapon(char *pszWeaponName);
	BOOL HasPlayerItem(CBasePlayerItem *pCheckItem);
	BOOL HasNamedPlayerItem(const char *pszItemName);
	BOOL HasWeapons(void);
	void SelectPrevItem(int iItem);
	void SelectNextItem(int iItem);
	void SelectLastItem(void);
	void SelectItem(const char *pstr);
	void ItemPreFrame(void);
	void ItemPostFrame(void);
	void GiveNamedItem(const char *szName);
	void EnableControl(BOOL fControl);
	void SendAmmoUpdate(void);
	void SendFOV(int iFOV);
	void SendHostagePos(void);
	void SendHostageIcons(void);
	void SendWeatherInfo(void);
	void WaterMove(void);
	void EXPORT PlayerDeathThink(void);
	void PlayerUse(void);
	void CheckSuitUpdate(void);
	void SetSuitUpdate(const char *name, int fgroup, int iNoRepeat);
	void UpdateGeigerCounter(void);
	void CheckTimeBasedDamage(void);
	void BarnacleVictimBitten(entvars_t *pevBarnacle);
	void BarnacleVictimReleased(void);
	static int GetAmmoIndex(const char *psz);
	int AmmoInventory(int iAmmoIndex);
	void ResetAutoaim(void);
	Vector AutoaimDeflection(Vector &vecSrc, float flDist, float flDelta);
	void ForceClientDllUpdate(void);
	void SetCustomDecalFrames(int nFrames);
	int GetCustomDecalFrames(void);
	void TabulateAmmo(void);
	void SetProgressBarTime(int iTime);
	void SetProgressBarTime2(int iTime, float flLastTime);
	void SetPlayerModel(BOOL HasC4);
	void SetNewPlayerModel(const char *model);
	void CheckPowerups(entvars_t *pev);
	void SmartRadio(void);
	void Radio(const char *msg_id, const char *msg_verbose, int pitch = 100, bool showIcon = true);
	void GiveDefaultItems(void);
	void SetBombIcon(BOOL bFlash);
	void SetScoreAttrib(CBasePlayer *dest);
	void SetScoreboardAttributes(CBasePlayer *pPlayer = NULL);
	BOOL IsBombGuy(void);
	BOOL ShouldDoLargeFlinch(int nHitGroup, int nGunType);
	BOOL IsArmored(int nHitGroup);
	bool HintMessage(const char *pMessage, BOOL bDisplayIfDead = FALSE, BOOL bOverrideClientSettings = FALSE);
	void AddAccount(int amount, bool bTrackChange = true);
	void SyncRoundTimer(void);
	void MenuPrint(const char *text);
	void ResetMenu(void);
	void MakeVIP(void);
	void JoiningThink(void);
	void ResetStamina(void);
	void Disappear(void);
	void RemoveLevelText(void);
	void MoveToNextIntroCamera(void);
	void SpawnClientSideCorpse(void);
	void SetPrefsFromUserinfo(char *infobuffer);
	void HostageUsed(void);
	bool CanPlayerBuy(bool display);
	void StudioEstimateGait(void);
	void CalculatePitchBlend(void);
	void CalculateYawBlend(void);
	void StudioProcessGait(void);
	void HandleSignals(void);
	void EnterEscapeZone(void);
	void LeaveEscapeZone(void);
	void EnterVIPSafetyZone(void);
	void LeaveVIPSafetyZone(void);
	void InitStatusBar(void);
	void UpdateStatusBar(void);
	bool IsHittingShield(const Vector &vecDirection, TraceResult *ptr);
	bool IsReloading(void);
	bool IsThrowingGrenade(void);
	void StopReload(void);
	void DrawnShiled(void);
	bool HasShield(void);
	void UpdateShieldCrosshair(bool bShieldDrawn);
	void DropShield(bool bDeploy);
	void GiveShield(bool bRetire);
	bool IsProtectedByShield(void);
	void RemoveShield(void);
	void UpdateLocation(bool bForceUpdate);
	void ClientCommand(const char *arg0, const char *arg1 = NULL, const char *arg2 = NULL, const char *arg3 = NULL);
	void ClearAutoBuyData(void);
	void AddAutoBuyData(const char *string);
	void InitRebuyData(const char *string);
	void AutoBuy(void);
	bool ShouldExecuteAutoBuyCommand(const AutoBuyInfoStruct *commandInfo, bool boughtPrimary, bool boughtSecondary);
	AutoBuyInfoStruct *GetAutoBuyCommandInfo(const char *command);
	void PrioritizeAutoBuyString(char *autobuyString, const char *priorityString);
	void ParseAutoBuyString(const char *string, bool &boughtPrimary, bool &boughtSecondary);
	void PostAutoBuyCommandProcessing(const AutoBuyInfoStruct *commandInfo, bool &boughtPrimary, bool &boughtSecondary);
	void BuildRebuyStruct(void);
	void Rebuy(void);
	void RebuyPrimaryWeapon(void);
	void RebuyPrimaryAmmo(void);
	void RebuySecondaryWeapon(void);
	void RebuySecondaryAmmo(void);
	void RebuyHEGrenade(void);
	void RebuyFlashbang(void);
	void RebuySmokeGrenade(void);
	void RebuyDefuser(void);
	void RebuyNightVision(void);
	void RebuyArmor(void);

public:
	static TYPEDESCRIPTION m_playerSaveData[];

public:
	int random_seed;
	unsigned short m_usPlayerBleed;
	EHANDLE m_hObserverTarget;
	float m_flNextObserverInput;
	int m_iObserverWeapon;
	int m_iObserverC4State;
	bool m_bObserverHasDefuser;
	int m_iObserverLastMode;
	float m_flFlinchTime;
	float m_flAnimTime;
	bool m_bHighDamage;
	float m_flVelocityModifier;
	int m_iLastZoom;
	bool m_bResumeZoom;
	float m_flEjectBrass;
	int m_iKevlar;
	bool m_bNotKilled;
	int m_iTeam;
	int m_iAccount;
	bool m_bHasPrimary;
	float m_flDeathThrowTime;
	int m_iThrowDirection;
	float m_flLastTalk;
	bool m_bJustConnected;
	bool m_bContextHelp;
	JoinState m_iJoiningState;
	CBaseEntity *m_pIntroCamera;
	float m_fIntroCamTime;
	float m_fLastMovement;
	bool m_bMissionBriefing;
	bool m_bTeamChanged;
	int m_iModelName;
	int m_iTeamKills;
	int m_iIgnoreGlobalChat;
	bool m_bHasNightVision;
	bool m_bNightVisionOn;
	Vector m_vRecentPath[20];
	float m_flIdleCheckTime;
	float m_flRadioTime;
	int m_iRadioMessages;
	bool m_bIgnoreRadio;
	bool m_bHasC4;
	bool m_bHasDefuser;
	bool m_bKilledByBomb;
	Vector m_vBlastVector;
	bool m_bKilledByGrenade;
	CHintMessageQueue m_hintMessageQueue;
	int m_flDisplayHistory;
	int m_iMenu;
	int m_iChaseTarget;
	CBaseEntity *m_pChaseTarget;
	BOOL m_fCamSwitch;
	bool m_bEscaped;
	bool m_bIsVIP;
	float m_tmNextRadarUpdate;
	Vector m_vLastOrigin;
	int m_iCurrentKickVote;
	float m_flNextVoteTime;
	bool m_bJustKilledTeammate;
	int m_iHostagesKilled;
	int m_iMapVote;
	bool m_bCanShoot;
	float m_flLastFired;
	float m_flLastAttackedTeammate;
	bool m_bHeadshotKilled;
	bool m_bPunishedForTK;
	bool m_bReceivesNoMoneyNextRound;
	int m_iTimeCheckAllowed;
	bool m_bHasChangedName;
	char m_szNewName[MAX_PLAYER_NAME_LENGTH];
	bool m_bIsDefusing;
	float m_tmHandleSignals;
	CUnifiedSignals m_signals;
	edict_t *m_pentCurBombTarget;
	int m_iPlayerSound;
	int m_iTargetVolume;
	int m_iWeaponVolume;
	int m_iExtraSoundTypes;
	int m_iWeaponFlash;
	float m_flStopExtraSoundTime;
	float m_flFlashLightTime;
	int m_iFlashBattery;
	int m_afButtonLast;
	int m_afButtonPressed;
	int m_afButtonReleased;
	edict_t *m_pentSndLast;
	float m_flSndRoomtype;
	float m_flSndRange;
	float m_flFallVelocity;
	int m_rgItems[MAX_ITEMS];
	int m_fNewAmmo;
	unsigned int m_afPhysicsFlags;
	float m_fNextSuicideTime;
	float m_flTimeStepSound;
	float m_flTimeWeaponIdle;
	float m_flSwimTime;
	float m_flDuckTime;
	float m_flWallJumpTime;
	float m_flSuitUpdate;
	int m_rgSuitPlayList[CSUITPLAYLIST];
	int m_iSuitPlayNext;
	int m_rgiSuitNoRepeat[CSUITNOREPEAT];
	float m_rgflSuitNoRepeatTime[CSUITNOREPEAT];
	int m_lastDamageAmount;
	float m_tbdPrev;
	float m_flgeigerRange;
	float m_flgeigerDelay;
	int m_igeigerRangePrev;
	int m_iStepLeft;
	char m_szTextureName[CBTEXTURENAMEMAX];
	char m_chTextureType;
	int m_idrowndmg;
	int m_idrownrestored;
	int m_bitsHUDDamage;
	BOOL m_fInitHUD;
	BOOL m_fGameHUDInitialized;
	int m_iTrain;
	BOOL m_fWeapon;
	EHANDLE m_pTank;
	float m_fDeadTime;
	BOOL m_fNoPlayerSound;
	BOOL m_fLongJump;
	float m_tSneaking;
	int m_iUpdateTime;
	int m_iClientHealth;
	int m_iClientBattery;
	int m_iHideHUD;
	int m_iClientHideHUD;
	int m_iFOV;
	int m_iClientFOV;
	int m_iNumSpawns;
	CBaseEntity *m_pObserver;
	CBasePlayerItem *m_rgpPlayerItems[MAX_ITEM_TYPES];
	CBasePlayerItem *m_pActiveItem;
	CBasePlayerItem *m_pClientActiveItem;
	CBasePlayerItem *m_pLastItem;
	int m_rgAmmo[MAX_AMMO_SLOTS];
	int m_rgAmmoLast[MAX_AMMO_SLOTS];
	Vector m_vecAutoAim;
	BOOL m_fOnTarget;
	int m_iDeaths;
	int m_izSBarState[SBAR_END];
	float m_flNextSBarUpdateTime;
	float m_flStatusBarDisappearDelay;
	char m_SbarString0[SBAR_STRING_SIZE];
	int m_lastx, m_lasty;
	int m_nCustomSprayFrames;
	float m_flNextDecalTime;
	char m_szTeamName[TEAM_NAME_LENGTH];
	int m_modelIndexPlayer;
	char m_szAnimExtention[32];
	int m_iGaitsequence;
	float m_flGaitframe;
	float m_flGaityaw;
	vec3_t m_prevgaitorigin;
	float m_flPitch;
	float m_flYaw;
	float m_flGaitMovement;
	int m_iAutoWepSwitch;
	bool m_bVGUIMenus;
	bool m_bShowHints;
	bool m_bShieldDrawn;
	bool m_bOwnsShield;
	bool m_bWasFollowing;
	float m_flNextFollowTime;
	float m_flYawModifier;
	float m_blindUntilTime;
	float m_blindStartTime;
	float m_blindHoldTime;
	float m_blindFadeTime;
	float m_blindAlpha;
	float m_allowAutoFollowTime;
	char m_autoBuyString[MAX_AUTOBUY_LENGTH];
	char *m_rebuyString;
	RebuyStruct m_rebuyStruct;
	bool m_bIsInRebuy;
	float m_flLastUpdateTime;
	char m_lastLocation[MAX_LACTION_LENGTH];
	int m_progressStart;
	int m_progressEnd;
	bool m_bObserverAutoDirector;
	bool m_canSwitchObserverModes;
	float m_heartBeatTime;
	int m_intenseTimestamp;
	int m_silentTimestamp;
	MusicState m_musicState;
	int m_flLastCommandTime[8];
};

#define AUTOAIM_2DEGREES 0.0348994967025
#define AUTOAIM_5DEGREES 0.08715574274766
#define AUTOAIM_8DEGREES 0.1391731009601
#define AUTOAIM_10DEGREES 0.1736481776669

extern int gmsgHudText;
extern int gmsgShowMenu;
extern int gmsgVGUIMenu;
extern int gmsgScenarioIcon;
extern int gmsgBombDrop;

extern BOOL gInitHUD;

void SendItemStatus(CBasePlayer *pPlayer);

extern bool UseBotArgs;
extern const char *BotArgs[4];

#endif

```

`dlls/saverestore.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef SAVERESTORE_H
#define SAVERESTORE_H

class CBaseEntity;

class CSaveRestoreBuffer
{
public:
	CSaveRestoreBuffer(void);
	CSaveRestoreBuffer(SAVERESTOREDATA *pdata);
	virtual ~CSaveRestoreBuffer(void);

public:
	int EntityIndex(entvars_t *pevLookup);
	int EntityIndex(edict_t *pentLookup);
	int EntityIndex(EOFFSET eoLookup);
	int EntityIndex(CBaseEntity *pEntity);
	int EntityFlags(int entityIndex, int flags) { return EntityFlagsSet(entityIndex, 0); }
	int EntityFlagsSet(int entityIndex, int flags);
	edict_t *EntityFromIndex(int entityIndex);
	unsigned short TokenHash(const char *pszToken);

protected:
	SAVERESTOREDATA *m_pdata;
	void BufferRewind(int size);
	unsigned int HashString(const char *pszToken);

private:
	void operator = (CSaveRestoreBuffer &);
	CSaveRestoreBuffer(const CSaveRestoreBuffer &);
};

class CSave : public CSaveRestoreBuffer
{
public:
	CSave(SAVERESTOREDATA *pdata): CSaveRestoreBuffer(pdata) {};

public:
	void WriteShort(const char *pname, const short *value, int count);
	void WriteInt(const char *pname, const int *value, int count);
	void WriteFloat(const char *pname, const float *value, int count);
	void WriteTime(const char *pname, const float *value, int count);
	void WriteData(const char *pname, int size, const char *pdata);
	void WriteString(const char *pname, const char *pstring);
	void WriteString(const char *pname, const int *stringId, int count);
	void WriteVector(const char *pname, const Vector &value);
	void WriteVector(const char *pname, const float *value, int count);
	void WritePositionVector(const char *pname, const Vector &value);
	void WritePositionVector(const char *pname, const float *value, int count);
	void WriteFunction(const char *pname, const int *value, int count);
	int WriteEntVars(const char *pname, entvars_t *pev);
	int WriteFields(const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount);

private:
	int DataEmpty(const char *pdata, int size);
	void BufferField(const char *pname, int size, const char *pdata);
	void BufferString(char *pdata, int len);
	void BufferData(const char *pdata, int size);
	void BufferHeader(const char *pname, int size);
};

typedef struct
{
	unsigned short size;
	unsigned short token;
	char *pData;
}
HEADER;

class CRestore : public CSaveRestoreBuffer
{
public:
	CRestore(SAVERESTOREDATA *pdata): CSaveRestoreBuffer(pdata), m_global(0), m_precache(TRUE) {}

public:
	int ReadEntVars(const char *pname, entvars_t *pev);
	int ReadFields(const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount);
	int ReadField(void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount, int startField, int size, char *pName, void *pData);
	int ReadInt(void);
	short ReadShort(void);
	int ReadNamedInt(const char *pName);
	char *ReadNamedString(const char *pName);
	int Empty(void) { return (!m_pdata) || ((m_pdata->pCurrentData - m_pdata->pBaseData) >= m_pdata->bufferSize); }
	inline void SetGlobalMode(int global) { m_global = global; }
	void PrecacheMode(BOOL mode){ m_precache = mode; }

private:
	char *BufferPointer(void);
	void BufferReadBytes(char *pOutput, int size);
	void BufferSkipBytes(int bytes);
	int BufferSkipZString(void);
	int BufferCheckZString(const char *string);
	void BufferReadHeader(HEADER *pheader);

private:
	int m_global;
	BOOL m_precache;
};

#define MAX_ENTITYARRAY 64

#define IMPLEMENT_SAVERESTORE(derivedClass,baseClass) \
	int derivedClass::Save(CSave &save)\
{\
	if (!baseClass::Save(save))\
	return 0;\
	return save.WriteFields(#derivedClass, this, m_SaveData, ARRAYSIZE(m_SaveData));\
}\
	int derivedClass::Restore(CRestore &restore)\
{\
	if (!baseClass::Restore(restore))\
	return 0;\
	return restore.ReadFields(#derivedClass, this, m_SaveData, ARRAYSIZE(m_SaveData));\
}

typedef enum { GLOBAL_OFF = 0, GLOBAL_ON = 1, GLOBAL_DEAD = 2 } GLOBALESTATE;
typedef struct globalentity_s globalentity_t;

struct globalentity_s
{
	char name[64];
	char levelName[32];
	GLOBALESTATE state;
	globalentity_t *pNext;
};

class CGlobalState
{
public:
	CGlobalState(void);

public:
	void Reset(void);
	void ClearStates(void);
	void EntityAdd(string_t globalname, string_t mapName, GLOBALESTATE state);
	void EntitySetState(string_t globalname, GLOBALESTATE state);
	void EntityUpdate(string_t globalname, string_t mapname);
	const globalentity_t *EntityFromTable(string_t globalname);
	GLOBALESTATE EntityGetState(string_t globalname);
	int EntityInTable(string_t globalname) { return (Find(globalname) != NULL) ? 1 : 0; }
	int Save(CSave &save);
	int Restore(CRestore &restore);
	void DumpGlobals(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

private:
	globalentity_t *Find(string_t globalname);
	globalentity_t *m_pList;
	int m_listCount;

private:
	void operator = (CGlobalState &);
	CGlobalState(const CGlobalState &);
};

extern CGlobalState gGlobalState;
#endif
```

`dlls/schedule.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef SCHEDULE_H
#define SCHEDULE_H

#define bits_COND_SEE_HATE (1<<1)
#define bits_COND_SEE_FEAR (1<<2)
#define bits_COND_SEE_DISLIKE (1<<3)
#define bits_COND_SEE_ENEMY (1<<4)
#define bits_COND_LIGHT_DAMAGE (1<<8)
#define bits_COND_HEAVY_DAMAGE (1<<9)
#define bits_COND_SEE_CLIENT (1<<21)
#define bits_COND_SEE_NEMESIS (1<<22)

#endif
```

`dlls/skill.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

struct skilldata_t
{
	int iSkillLevel;
	float agruntHealth;
	float agruntDmgPunch;
	float apacheHealth;
	float barneyHealth;
	float bigmommaHealthFactor;
	float bigmommaDmgSlash;
	float bigmommaDmgBlast;
	float bigmommaRadiusBlast;
	float bullsquidHealth;
	float bullsquidDmgBite;
	float bullsquidDmgWhip;
	float bullsquidDmgSpit;
	float gargantuaHealth;
	float gargantuaDmgSlash;
	float gargantuaDmgFire;
	float gargantuaDmgStomp;
	float hassassinHealth;
	float headcrabHealth;
	float headcrabDmgBite;
	float hgruntHealth;
	float hgruntDmgKick;
	float hgruntShotgunPellets;
	float hgruntGrenadeSpeed;
	float houndeyeHealth;
	float houndeyeDmgBlast;
	float slaveHealth;
	float slaveDmgClaw;
	float slaveDmgClawrake;
	float slaveDmgZap;
	float ichthyosaurHealth;
	float ichthyosaurDmgShake;
	float leechHealth;
	float leechDmgBite;
	float controllerHealth;
	float controllerDmgZap;
	float controllerSpeedBall;
	float controllerDmgBall;
	float nihilanthHealth;
	float nihilanthZap;
	float scientistHealth;
	float snarkHealth;
	float snarkDmgBite;
	float snarkDmgPop;
	float zombieHealth;
	float zombieDmgOneSlash;
	float zombieDmgBothSlash;
	float turretHealth;
	float miniturretHealth;
	float sentryHealth;
	float plrDmgCrowbar;
	float plrDmg9MM;
	float plrDmg357;
	float plrDmgMP5;
	float plrDmgM203Grenade;
	float plrDmgBuckshot;
	float plrDmgCrossbowClient;
	float plrDmgCrossbowMonster;
	float plrDmgRPG;
	float plrDmgGauss;
	float plrDmgEgonNarrow;
	float plrDmgEgonWide;
	float plrDmgHornet;
	float plrDmgHandGrenade;
	float plrDmgSatchel;
	float plrDmgTripmine;
	float monDmg9MM;
	float monDmgMP5;
	float monDmg12MM;
	float monDmgHornet;
	float suitchargerCapacity;
	float batteryCapacity;
	float healthchargerCapacity;
	float healthkitCapacity;
	float scientistHeal;
	float monHead;
	float monChest;
	float monStomach;
	float monLeg;
	float monArm;
	float plrHead;
	float plrChest;
	float plrStomach;
	float plrLeg;
	float plrArm;
};

extern DLL_GLOBAL skilldata_t gSkillData;
float GetSkillCvar(char *pName);
extern DLL_GLOBAL int g_iSkillLevel;

#define SKILL_EASY 1
#define SKILL_MEDIUM 2
#define SKILL_HARD 3
```

`dlls/soundent.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#define MAX_WORLD_SOUNDS 64

#define bits_SOUND_NONE 0
#define bits_SOUND_COMBAT (1<<0)
#define bits_SOUND_WORLD (1<<1)
#define bits_SOUND_PLAYER (1<< 2)
#define bits_SOUND_CARCASS (1<< 3)
#define bits_SOUND_MEAT (1<< 4)
#define bits_SOUND_DANGER (1<< 5)
#define bits_SOUND_GARBAGE (1<< 6)

#define bits_ALL_SOUNDS 0xFFFFFFFF

#define SOUNDLIST_EMPTY	-1

#define SOUNDLISTTYPE_FREE 1
#define SOUNDLISTTYPE_ACTIVE 2

#define SOUND_NEVER_EXPIRE -1

class CSound
{
public:
	void Clear(void);
	void Reset(void);

public:
	Vector m_vecOrigin;
	int m_iType;
	int m_iVolume;
	float m_flExpireTime;
	int m_iNext;
	int m_iNextAudible;

public:
	BOOL FIsSound(void);
	BOOL FIsScent(void);
};

class CSoundEnt : public CBaseEntity 
{
public:
	void Precache(void);
	void Spawn(void);
	void Think(void);
	void Initialize(void);
	int ObjectCaps(void) { return FCAP_DONT_SAVE; }

public:
	static void InsertSound(int iType, const Vector &vecOrigin, int iVolume, float flDuration);
	static void FreeSound(int iSound, int iPrevious);
	static int ActiveList(void);
	static int FreeList(void);
	static CSound *SoundPointerForIndex(int iIndex);
	static int ClientSoundIndex(edict_t *pClient);

public:
	BOOL IsEmpty(void) { return m_iActiveSound == SOUNDLIST_EMPTY; }
	int ISoundsInList(int iListType);
	int IAllocSound(void);

public:
	int m_iFreeSound;
	int m_iActiveSound;
	int m_cLastActiveSounds;
	BOOL m_fShowReport;

private:
	CSound m_SoundPool[MAX_WORLD_SOUNDS];
};
```

`dlls/stdafx.h`:

```h
#ifndef stdafx_h__
#define stdafx_h__

#include "port.h"
#include "extdll.h"
#include "util.h"

#endif // stdafx_h__

```

`dlls/util.h`:

```h
#ifndef util_h__
#define util_h__

/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "port.h"
#include <string.h>
#ifndef ACTIVITY_H
#include "activity.h"
#endif

#ifndef ENGINECALLBACK_H
#include "enginecallback.h"
#endif

#include <tier1/UtlVector.h>

inline void MESSAGE_BEGIN(int msg_dest, int msg_type, const float *pOrigin, entvars_t *ent);
extern globalvars_t *gpGlobals;

#define STRING(offset) reinterpret_cast<const char *>(gpGlobals->pStringBase + (uintp)offset)
#define MAKE_STRING(str) (reinterpret_cast<uintp>(str) - reinterpret_cast<uintp>(STRING(0)))

inline edict_t *FIND_ENTITY_BY_CLASSNAME(edict_t *entStart, const char *pszName)
{
	return FIND_ENTITY_BY_STRING(entStart, "classname", pszName);
}

inline edict_t *FIND_ENTITY_BY_TARGETNAME(edict_t *entStart, const char *pszName)
{
	return FIND_ENTITY_BY_STRING(entStart, "targetname", pszName);
}

inline edict_t *FIND_ENTITY_BY_TARGET(edict_t *entStart, const char *pszName)
{
	return FIND_ENTITY_BY_STRING(entStart, "target", pszName);
}

#define WRITEKEY_INT(pf, szKeyName, iKeyValue) ENGINE_FPRINTF(pf, "\"%s\" \"%d\"\n", szKeyName, iKeyValue)
#define WRITEKEY_FLOAT(pf, szKeyName, flKeyValue) ENGINE_FPRINTF(pf, "\"%s\" \"%f\"\n", szKeyName, flKeyValue)
#define WRITEKEY_STRING(pf, szKeyName, szKeyValue) ENGINE_FPRINTF(pf, "\"%s\" \"%s\"\n", szKeyName, szKeyValue)
#define WRITEKEY_VECTOR(pf, szKeyName, flX, flY, flZ) ENGINE_FPRINTF(pf, "\"%s\" \"%f %f %f\"\n", szKeyName, flX, flY, flZ)

#define SetBits(flBitVector, bits) ((flBitVector) = (int)(flBitVector) | (bits))
#define ClearBits(flBitVector, bits) ((flBitVector) = (int)(flBitVector) & ~(bits))
#define FBitSet(flBitVector, bit) ((int)(flBitVector) & (bit))

#define FILE_GLOBAL static
#define DLL_GLOBAL
#define CONSTANT

typedef int EOFFSET;
typedef int BOOL;

#define M_PI 3.14159265358979323846

#define DECLARE_GLOBAL_METHOD(MethodName) extern void DLLEXPORT MethodName(void)
#define GLOBAL_METHOD(funcname) void DLLEXPORT funcname(void)

#ifdef CLIENT_DLL
#define LINK_ENTITY_TO_CLASS( x, y )
#elif defined(_WIN32)
#define LINK_ENTITY_TO_CLASS(mapClassName, DLLClassName) \
	extern "C" EXPORT void mapClassName(entvars_t *pev); \
	void mapClassName(entvars_t *pev) { GetClassPtr((DLLClassName *)pev); }
#else
#define LINK_ENTITY_TO_CLASS(mapClassName,DLLClassName) extern "C" void mapClassName(entvars_t *pev); void mapClassName(entvars_t *pev) { GetClassPtr((DLLClassName *)pev); }
#endif

#if defined(DEBUG) && !defined(CLIENT_DLL)
	extern edict_t *DBG_EntOfVars(const entvars_t *pev);
	inline edict_t *ENT(const entvars_t *pev) { return DBG_EntOfVars(pev); }
#else
	inline edict_t *ENT(const entvars_t *pev) { return pev->pContainingEntity; }
#endif
inline edict_t *ENT(edict_t *pent) { return pent; }
inline edict_t *ENT(EOFFSET eoffset) { return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }
inline EOFFSET OFFSET(EOFFSET eoffset) { return eoffset; }
inline EOFFSET OFFSET(const edict_t *pent)
{
#if _DEBUG
	if (!pent)
		ALERT(at_error, "Bad ent in OFFSET()\n");
#endif
	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent);
}

inline EOFFSET OFFSET(entvars_t *pev)
{
#if _DEBUG
	if (!pev)
		ALERT(at_error, "Bad pev in OFFSET()\n");
#endif
	return OFFSET(ENT(pev));
}
inline entvars_t *VARS(entvars_t *pev) { return pev; }

inline entvars_t *VARS(edict_t *pent)
{
	if (!pent)
		return NULL;

	return &pent->v;
}

inline entvars_t *VARS(EOFFSET eoffset) { return VARS(ENT(eoffset)); }
inline int ENTINDEX(edict_t *pEdict) { return (*g_engfuncs.pfnIndexOfEdict)(pEdict); }
inline edict_t *INDEXENT(int iEdictNum) { return (*g_engfuncs.pfnPEntityOfEntIndex)(iEdictNum); }

inline void MESSAGE_BEGIN(int msg_dest, int msg_type, const float *pOrigin, entvars_t *ent) { (*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ENT(ent)); }

#define eoNullEntity 0
inline BOOL FNullEnt(EOFFSET eoffset) { return eoffset == 0; }
inline BOOL FNullEnt(const edict_t *pent) { return pent == NULL || FNullEnt(OFFSET(pent)); }
inline BOOL FNullEnt(entvars_t *pev) { return pev == NULL || FNullEnt(OFFSET(pev)); }

#define iStringNull 0
inline BOOL FStringNull(int iString) { return iString == iStringNull; }

#define cchMapNameMost 32

#define VIEW_FIELD_FULL (float)-1
#define VIEW_FIELD_WIDE (float)-0.7
#define VIEW_FIELD_NARROW (float)0.7
#define VIEW_FIELD_ULTRA_NARROW (float)0.9

#define DONT_BLEED -1
#define BLOOD_COLOR_RED (BYTE)247
#define BLOOD_COLOR_YELLOW (BYTE)195
#define BLOOD_COLOR_GREEN BLOOD_COLOR_YELLOW

typedef enum
{
	MONSTERSTATE_NONE = 0,
	MONSTERSTATE_IDLE,
	MONSTERSTATE_COMBAT,
	MONSTERSTATE_ALERT,
	MONSTERSTATE_HUNT,
	MONSTERSTATE_PRONE,
	MONSTERSTATE_SCRIPT,
	MONSTERSTATE_PLAYDEAD,
	MONSTERSTATE_DEAD
}
MONSTERSTATE;

typedef enum
{
	TS_AT_TOP,
	TS_AT_BOTTOM,
	TS_GOING_UP,
	TS_GOING_DOWN
}
TOGGLE_STATE;

inline BOOL FStrEq(const char *sz1, const char *sz2) { return (!strcmp(sz1, sz2)); }
inline BOOL FClassnameIs(edict_t *pent, const char *szClassname) { return FStrEq(STRING(VARS(pent)->classname), szClassname); }
inline BOOL FClassnameIs(entvars_t *pev, const char *szClassname) { return FStrEq(STRING(pev->classname), szClassname); }

class CBaseEntity;
class CBasePlayer;

extern void UTIL_SetSize(entvars_t *pev, const Vector &vecMin, const Vector &vecMax);
extern float UTIL_VecToYaw(const Vector &vec);
extern Vector UTIL_VecToAngles(const Vector &vec);
extern float UTIL_AngleMod(float a);
extern float UTIL_AngleDiff(float destAngle, float srcAngle);

extern CBaseEntity *UTIL_FindEntityInSphere(CBaseEntity *pStartEntity, const Vector &vecCenter, float flRadius);
extern CBaseEntity *UTIL_FindEntityByString_Old(CBaseEntity *pStartEntity, const char *szKeyword, const char *szValue);
extern CBaseEntity *UTIL_FindEntityByString(CBaseEntity *pStartEntity, const char *szKeyword, const char *szValue);
#ifndef CLIENT_DLL
extern CBaseEntity *UTIL_FindEntityByClassname(CBaseEntity *pStartEntity, const char *szName);
#else
inline CBaseEntity *UTIL_FindEntityByClassname(CBaseEntity *, const char* ) { return NULL; }
#endif
extern CBaseEntity *UTIL_FindEntityByTargetname(CBaseEntity *pStartEntity, const char *szName);
extern CBaseEntity *UTIL_FindEntityGeneric(const char *szName, Vector &vecSrc, float flRadius);
extern CBasePlayer *UTIL_PlayerByIndex(int playerIndex);

#define UTIL_EntitiesInPVS(pent) (*g_engfuncs.pfnEntitiesInPVS)(pent)

extern void UTIL_MakeVectors(const Vector &vecAngles);
extern int UTIL_MonstersInSphere(CBaseEntity **pList, int listMax, const Vector &center, float radius);
extern int UTIL_EntitiesInBox(CBaseEntity **pList, int listMax, const Vector &mins, const Vector &maxs, int flagMask);
inline void UTIL_MakeVectorsPrivate(const Vector &vecAngles, float *p_vForward, float *p_vRight, float *p_vUp) { g_engfuncs.pfnAngleVectors(vecAngles, p_vForward, p_vRight, p_vUp); }
extern void UTIL_MakeAimVectors(const Vector &vecAngles);
extern void UTIL_MakeInvVectors(const Vector &vec, globalvars_t *pgv);

extern void UTIL_SetOrigin(entvars_t *pev, const Vector &vecOrigin);
extern void UTIL_EmitAmbientSound(edict_t *entity, const Vector &vecOrigin, const char *samp, float vol, float attenuation, int fFlags, int pitch);
extern void UTIL_ParticleEffect(const Vector &vecOrigin, const Vector &vecDirection, ULONG ulColor, ULONG ulCount);
extern void UTIL_ScreenShake(const Vector &center, float amplitude, float frequency, float duration, float radius);
extern void UTIL_ScreenShakeAll(const Vector &center, float amplitude, float frequency, float duration);
extern void UTIL_ShowMessageArgs(const char *pString, CBaseEntity *pPlayer, CUtlVector<char *> *args, bool isHint);
extern void UTIL_ShowMessage(const char *pString, CBaseEntity *pPlayer);
extern void UTIL_ShowMessageAll(const char *pString);
extern void UTIL_ScreenFadeAll(const Vector &color, float fadeTime, float holdTime, int alpha, int flags);
extern void UTIL_ScreenFade(CBaseEntity *pEntity, const Vector &color, float fadeTime, float fadeHold, int alpha, int flags);

typedef enum { ignore_monsters = 1, dont_ignore_monsters = 0, missile = 2 } IGNORE_MONSTERS;
typedef enum { ignore_glass = 1, dont_ignore_glass = 0 } IGNORE_GLASS;
extern void UTIL_TraceLine(const Vector &vecStart, const Vector &vecEnd, IGNORE_MONSTERS igmon, edict_t *pentIgnore, TraceResult *ptr);
extern void UTIL_TraceLine(const Vector &vecStart, const Vector &vecEnd, IGNORE_MONSTERS igmon, IGNORE_GLASS ignoreGlass, edict_t *pentIgnore, TraceResult *ptr);
typedef enum { point_hull = 0, human_hull = 1, large_hull = 2, head_hull = 3 } HULL_TYPE;
#ifndef CLIENT_DLL
extern void UTIL_TraceHull(const Vector &vecStart, const Vector &vecEnd, IGNORE_MONSTERS igmon, int hullNumber, edict_t *pentIgnore, TraceResult *ptr);
#else
inline void UTIL_TraceHull(const Vector &vecStart, const Vector &vecEnd, IGNORE_MONSTERS igmon, int hullNumber, edict_t *pentIgnore, TraceResult *ptr) {}
#endif
extern TraceResult UTIL_GetGlobalTrace(void);
extern void UTIL_TraceModel(const Vector &vecStart, const Vector &vecEnd, int hullNumber, edict_t *pentModel, TraceResult *ptr);
extern Vector UTIL_GetAimVector(edict_t *pent, float flSpeed);
extern int UTIL_PointContents(const Vector &vec);

extern int UTIL_IsMasterTriggered(string_t sMaster, CBaseEntity *pActivator);
extern void UTIL_BloodStream(const Vector &origin, const Vector &direction, int color, int amount);
extern void UTIL_BloodDrips(const Vector &origin, const Vector &direction, int color, int amount);
extern Vector UTIL_RandomBloodVector(void);
extern BOOL UTIL_ShouldShowBlood(int bloodColor);
extern void UTIL_BloodDecalTrace(TraceResult *pTrace, int bloodColor);
extern void UTIL_DecalTrace(TraceResult *pTrace, int decalNumber);
extern void UTIL_PlayerDecalTrace(TraceResult *pTrace, int playernum, int decalNumber, BOOL bIsCustom);
extern void UTIL_GunshotDecalTrace(TraceResult *pTrace, int decalNumber);
extern void UTIL_Sparks(const Vector &position);
extern void UTIL_Ricochet(const Vector &position, float scale);
extern void UTIL_StringToVector(float *pVector, const char *pString);
extern void UTIL_StringToIntArray(int *pVector, int count, const char *pString);
extern Vector UTIL_ClampVectorToBox(const Vector &input, const Vector &clampSize);
extern float UTIL_Approach(float target, float value, float speed);
extern float UTIL_ApproachAngle(float target, float value, float speed);
extern float UTIL_AngleDistance(float next, float cur);
extern char *UTIL_VarArgs(char *format, ...);
extern void UTIL_Remove(CBaseEntity *pEntity);
extern BOOL UTIL_IsValidEntity(edict_t *pent);
extern BOOL UTIL_TeamsMatch(const char *pTeamName1, const char *pTeamName2);
extern float UTIL_SplineFraction(float value, float scale);
extern float UTIL_WaterLevel(const Vector &position, float minz, float maxz);
extern void UTIL_Bubbles(Vector mins, Vector maxs, int count);
extern void UTIL_BubbleTrail(Vector from, Vector to, int count);
extern void UTIL_PrecacheOther(const char *szClassname);
extern void UTIL_ClientPrintAll(int msg_dest, const char *msg_name, const char *param1 = NULL, const char *param2 = NULL, const char *param3 = NULL, const char *param4 = NULL);

inline void UTIL_CenterPrintAll(const char *msg_name, const char *param1 = NULL, const char *param2 = NULL, const char *param3 = NULL, const char *param4 = NULL)
{
	UTIL_ClientPrintAll(HUD_PRINTCENTER, msg_name, param1, param2, param3, param4);
}

class CBasePlayerItem;
class CBasePlayer;

extern BOOL UTIL_GetNextBestWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon);
#ifndef CLIENT_DLL
extern void ClientPrint(entvars_t *client, int msg_dest, const char *msg_name, const char *param1 = NULL, const char *param2 = NULL, const char *param3 = NULL, const char *param4 = NULL);
#else
inline void ClientPrint(entvars_t *client, int msg_dest, const char *msg_name, const char *param1 = NULL, const char *param2 = NULL, const char *param3 = NULL, const char *param4 = NULL) { }
#endif
extern void UTIL_SayText(const char *pText, CBaseEntity *pEntity);
extern void UTIL_SayTextAll(const char *pText, CBaseEntity *pEntity);

typedef struct hudtextparms_s
{
	float x;
	float y;
	int effect;
	byte r1, g1, b1, a1;
	byte r2, g2, b2, a2;
	float fadeinTime;
	float fadeoutTime;
	float holdTime;
	float fxTime;
	int channel;
}
hudtextparms_t;

extern void UTIL_HudMessageAll(const hudtextparms_t &textparms, const char *pMessage);
extern void UTIL_HudMessage(CBaseEntity *pEntity, const hudtextparms_t &textparms, const char *pMessage);

extern char *UTIL_dtos1(int d);
extern char *UTIL_dtos2(int d);
extern char *UTIL_dtos3(int d);
extern char *UTIL_dtos4(int d);
extern void UTIL_LogPrintf(const char *fmt, ...);
extern float UTIL_DotPoints(const Vector &vecSrc, const Vector &vecCheck, const Vector &vecDir);
extern void UTIL_StripToken(const char *pKey, char *pDest);
extern char UTIL_TextureHit(TraceResult *ptrHit, Vector vecSrc, Vector vecEnd);
extern bool UTIL_IsGame(const char *gameName);
extern float UTIL_GetPlayerGaitYaw(int playerIndex);
extern int UTIL_HumansInGame(bool ignoreSpectators);

extern void SetMovedir(entvars_t *pev);
extern Vector VecBModelOrigin(entvars_t *pevBModel);
extern int BuildChangeList(LEVELLIST *pLevelList, int maxList);

#ifdef DEBUG
void DBG_AssertFunction(BOOL fExpr, const char *szExpr, const char *szFile, int szLine, const char *szMessage);
#define ASSERT(f) DBG_AssertFunction(f, #f, __FILE__, __LINE__, NULL)
#define ASSERTSZ(f, sz)	DBG_AssertFunction(f, #f, __FILE__, __LINE__, sz)
#else
#define ASSERT(f)
#define ASSERTSZ(f, sz)
#endif

extern DLL_GLOBAL const Vector g_vecZero;

#define LANGUAGE_ENGLISH 0
#define LANGUAGE_GERMAN 1
#define LANGUAGE_FRENCH 2
#define LANGUAGE_BRITISH 3

extern DLL_GLOBAL int g_Language;

#define AMBIENT_SOUND_STATIC 0
#define AMBIENT_SOUND_EVERYWHERE 1
#define AMBIENT_SOUND_SMALLRADIUS 2
#define AMBIENT_SOUND_MEDIUMRADIUS 4
#define AMBIENT_SOUND_LARGERADIUS 8
#define AMBIENT_SOUND_START_SILENT 16
#define AMBIENT_SOUND_NOT_LOOPING 32

#define SPEAKER_START_SILENT 1

#define SND_SPAWNING (1<<8)
#define SND_STOP (1<<5)
#define SND_CHANGE_VOL (1<<6)
#define SND_CHANGE_PITCH (1<<7)

#define LFO_SQUARE 1
#define LFO_TRIANGLE 2
#define LFO_RANDOM 3

#define SF_BRUSH_ROTATE_Y_AXIS 0
#define SF_BRUSH_ROTATE_INSTANT 1
#define SF_BRUSH_ROTATE_BACKWARDS 2
#define SF_BRUSH_ROTATE_Z_AXIS 4
#define SF_BRUSH_ROTATE_X_AXIS 8
#define SF_PENDULUM_AUTO_RETURN 16
#define SF_PENDULUM_PASSABLE 32

#define SF_BRUSH_ROTATE_SMALLRADIUS 128
#define SF_BRUSH_ROTATE_MEDIUMRADIUS 256
#define SF_BRUSH_ROTATE_LARGERADIUS 512

#define PUSH_BLOCK_ONLY_X 1
#define PUSH_BLOCK_ONLY_Y 2

#define VEC_HULL_MIN Vector(-16, -16, -36)
#define VEC_HULL_MAX Vector(16, 16, 36)
#define VEC_HUMAN_HULL_MIN Vector(-16, -16, 0)
#define VEC_HUMAN_HULL_MAX Vector(16, 16, 72)
#define VEC_HUMAN_HULL_DUCK Vector(16, 16, 36)

#define VEC_VIEW Vector(0, 0, 17)

#define VEC_DUCK_HULL_MIN Vector(-16, -16, -18)
#define VEC_DUCK_HULL_MAX Vector(16, 16, 32)
#define VEC_DUCK_VIEW Vector(0, 0, 12)

#define SVC_TEMPENTITY 23
#define SVC_INTERMISSION 30
#define SVC_CDTRACK 32
#define SVC_WEAPONANIM 35
#define SVC_ROOMTYPE 37
#define SVC_DIRECTOR 51

#define SF_TRIGGER_ALLOWMONSTERS 1
#define SF_TRIGGER_NOCLIENTS 2
#define SF_TRIGGER_PUSHABLES 4

#define SF_BREAK_TRIGGER_ONLY 1
#define SF_BREAK_TOUCH 2
#define SF_BREAK_PRESSURE 4
#define SF_BREAK_CROWBAR 256

#define SF_PUSH_BREAKABLE 128

#define SF_LIGHT_START_OFF 1

#define SPAWNFLAG_NOMESSAGE 1
#define SPAWNFLAG_NOTOUCH 1
#define SPAWNFLAG_DROIDONLY 4

#define SPAWNFLAG_USEONLY 1

#define TELE_PLAYER_ONLY 1
#define TELE_SILENT 2

#define SF_TRIG_PUSH_ONCE 1

#define CBSENTENCENAME_MAX 16
#define CVOXFILESENTENCEMAX 1536

extern char gszallsentencenames[CVOXFILESENTENCEMAX][CBSENTENCENAME_MAX];
extern int gcallsentences;

int USENTENCEG_Pick(int isentenceg, char *szfound);
int USENTENCEG_PickSequential(int isentenceg, char *szfound, int ipick, int freset);
void USENTENCEG_InitLRU(unsigned char *plru, int count);

void SENTENCEG_Init(void);
void SENTENCEG_Stop(edict_t *entity, int isentenceg, int ipick);
int SENTENCEG_PlayRndI(edict_t *entity, int isentenceg, float volume, float attenuation, int flags, int pitch);
int SENTENCEG_PlayRndSz(edict_t *entity, const char *szrootname, float volume, float attenuation, int flags, int pitch);
int SENTENCEG_PlaySequentialSz(edict_t *entity, const char *szrootname, float volume, float attenuation, int flags, int pitch, int ipick, int freset);
int SENTENCEG_GetIndex(const char *szrootname);
int SENTENCEG_Lookup(const char *sample, char *sentencenum);

void TEXTURETYPE_Init(void);
char TEXTURETYPE_Find(char *name);
float TEXTURETYPE_PlaySound(TraceResult *ptr, Vector vecSrc, Vector vecEnd, int iBulletType);

#ifndef CLIENT_WEAPONS
void EMIT_SOUND_DYN(edict_t *entity, int channel, const char *sample, float volume, float attenuation, int flags, int pitch);
#else
inline void EMIT_SOUND_DYN(edict_t *entity, int channel, const char *sample, float volume, float attenuation, int flags, int pitch) { }
#endif

inline void EMIT_SOUND(edict_t *entity, int channel, const char *sample, float volume, float attenuation)
{
	EMIT_SOUND_DYN(entity, channel, sample, volume, attenuation, 0, PITCH_NORM);
}

inline void STOP_SOUND(edict_t *entity, int channel, const char *sample)
{
	EMIT_SOUND_DYN(entity, channel, sample, 0, 0, SND_STOP, PITCH_NORM);
}

void EMIT_SOUND_SUIT(edict_t *entity, const char *sample);
void EMIT_GROUPID_SUIT(edict_t *entity, int isentenceg);
void EMIT_GROUPNAME_SUIT(edict_t *entity, const char *groupname);

#define PRECACHE_SOUND_ARRAY(a) \
{ for (int i = 0; i < (int)(ARRAYSIZE(a)); i++) PRECACHE_SOUND((char *) a [i]); }

#define EMIT_SOUND_ARRAY_DYN(chan, array) \
	EMIT_SOUND_DYN(ENT(pev), chan, array[RANDOM_LONG(0,A RRAYSIZE(array) - 1)], 1, ATTN_NORM, 0, RANDOM_LONG(95, 105));

#define RANDOM_SOUND_ARRAY(array) (array)[RANDOM_LONG(0, ARRAYSIZE((array)) - 1)]

#define PLAYBACK_EVENT(flags, who, index) PLAYBACK_EVENT_FULL(flags, who, index, 0, (float *)&g_vecZero, (float *)&g_vecZero, 0.0, 0.0, 0, 0, 0, 0);
#define PLAYBACK_EVENT_DELAY(flags, who, index, delay) PLAYBACK_EVENT_FULL(flags, who, index, delay, (float *)&g_vecZero, (float *)&g_vecZero, 0.0, 0.0, 0, 0, 0, 0);

#define GROUP_OP_AND 0
#define GROUP_OP_NAND 1

extern int g_groupmask;
extern int g_groupop;

class UTIL_GroupTrace
{
public:
	UTIL_GroupTrace(int groupmask, int op);
	~UTIL_GroupTrace(void);

private:
	int m_oldgroupmask, m_oldgroupop;
};

void UTIL_SetGroupTrace(int groupmask, int op);
void UTIL_UnsetGroupTrace(void);

int UTIL_SharedRandomLong(unsigned int seed, int low, int high);
float UTIL_SharedRandomFloat(unsigned int seed, float low, float high);

#ifndef CLIENT_WEAPONS
float UTIL_WeaponTimeBase(void);
#else
inline float UTIL_WeaponTimeBase( void ) { return 0; }
#endif
#endif // util_h__

```

`dlls/vector.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification ofthissource code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef VECTOR_H
#define VECTOR_H

//=========================================================
// 2DVector - used for many pathfinding and many other 
// operations that are treated as planar rather than 3d.
//=========================================================
class Vector2D
{
public:
	inline Vector2D(void): x(0.0), y(0.0)							{ }
	inline Vector2D(float X, float Y): x(0.0), y(0.0)				{ x = X; y = Y; }
	inline Vector2D operator+(const Vector2D& v)	const	{ return Vector2D(x+v.x, y+v.y);}
	inline Vector2D operator-(const Vector2D& v)	const	{ return Vector2D(x-v.x, y-v.y);}
	inline Vector2D operator*(float fl)				const	{ return Vector2D(x*fl, y*fl);}
	inline Vector2D operator/(float fl)				const	{ return Vector2D(x/fl, y/fl);}
	
	inline float Length(void)						const	{ return sqrt(x*x + y*y);	}

	inline Vector2D Normalize (void) const
	{

		float flLen = Length();
		if (flLen == 0)
		{
			return Vector2D( 0, 0);
		}
		else
		{
			flLen = 1 / flLen;
			return Vector2D( x * flLen, y * flLen );
		}
	}

	vec_t	x, y;
};

inline float DotProduct(const Vector2D& a, const Vector2D& b) { return( a.x*b.x + a.y*b.y); }
inline Vector2D operator*(float fl, const Vector2D& v)	{ return v * fl; }

//=========================================================
// 3D Vector
//=========================================================
class Vector // same data-layout as engine's vec3_t,
{							//		which is a vec_t[3]
public:
	// Construction/destruction
	inline Vector(void): x(0.0), y(0.0), z(0.0)					{ }
	inline Vector(float X, float Y, float Z): x(0.0), y(0.0), z(0.0)	{ x = X; y = Y; z = Z;			}
	//inline Vector(double X, double Y, double Z)		{ x = (float)X; y = (float)Y; z = (float)Z;}
	//inline Vector(int X, int Y, int Z)				{ x = (float)X; y = (float)Y; z = (float)Z;}
	inline Vector(const Vector& v): x(0.0), y(0.0), z(0.0)		{ x = v.x; y = v.y; z = v.z;			} 
	inline Vector(float rgfl[3]): x(0.0), y(0.0), z(0.0)		{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];}

	// Operators
	inline Vector operator-(void) const				{ return Vector(-x,-y,-z);			}
	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;}
	inline int operator!=(const Vector& v) const	{ return !(*this==v);				}
	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);}
	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);}
	inline Vector operator*(float fl) const			{ return Vector(x*fl, y*fl, z*fl);	}
	inline Vector operator/(float fl) const			{ return Vector(x/fl, y/fl, z/fl);	}
	
	// Methods
	inline void CopyToArray(float* rgfl) const		{ rgfl[0] = x, rgfl[1] = y, rgfl[2] = z; }
	inline float Length(void) const					{ return sqrt(x*x + y*y + z*z); }
	operator float *()								{ return &x; } // Vectors will now automatically convert to float * when needed
	operator const float *() const					{ return &x; } // Vectors will now automatically convert to float * when needed
	inline Vector Normalize(void) const
	{
		float flLen = Length();
		if (flLen == 0) return Vector(0,0,1); // ????
		flLen = 1 / flLen;
		return Vector(x * flLen, y * flLen, z * flLen);
	}

	inline Vector2D Make2D (void) const
	{
		Vector2D	Vec2;

		Vec2.x = x;
		Vec2.y = y;

		return Vec2;
	}
	inline float Length2D(void) const					{ return sqrt(x*x + y*y); }

	// Members
	vec_t x, y, z;
};
inline Vector operator*(float fl, const Vector& v)	{ return v * fl; }
inline float DotProduct(const Vector& a, const Vector& b) { return(a.x*b.x+a.y*b.y+a.z*b.z); }
inline Vector CrossProduct(const Vector& a, const Vector& b) { return Vector(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }


#endif

```

`dlls/weapons.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef WEAPONS_H
#define WEAPONS_H

#include "effects.h"

class CBasePlayer;
extern int gmsgWeapPickup;
extern int gmsgReloadSound;

class CGrenade : public CBaseMonster
{
public:
	void Spawn(void);
	int Save(CSave &save);
	int Restore(CRestore &restore);
	virtual void BounceSound(void);
	int ObjectCaps(void) { return m_bIsC4 != false ? FCAP_CONTINUOUS_USE : 0; }
	int BloodColor(void) { return DONT_BLEED; }
	void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	void Killed(entvars_t *pevAttacker, int iGib);

public:
	typedef enum { SATCHEL_DETONATE = 0, SATCHEL_RELEASE } SATCHELCODE;

public:
#ifndef CLIENT_DLL
	static CGrenade *ShootTimed(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time);
	static CGrenade *ShootTimed2(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time, int iTeam, unsigned short usEvent);
	static CGrenade *ShootContact(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity);
	static CGrenade *ShootSmokeGrenade(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time, unsigned short usEvent);
	static CGrenade *ShootSatchelCharge(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity);
#else
	static CGrenade *ShootTimed(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time) { return NULL; }
	static CGrenade *ShootTimed2(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time, int iTeam, unsigned short usEvent) { return NULL; }
	static CGrenade *ShootContact(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity) { return NULL; }
	static CGrenade *ShootSmokeGrenade(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time, unsigned short usEvent) { return NULL; }
	static CGrenade *ShootSatchelCharge(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity) { return NULL; }
#endif
	static void UseSatchelCharges(entvars_t *pevOwner, SATCHELCODE code);

public:
	void Explode(Vector vecSrc, Vector vecAim);
	void Explode(TraceResult *pTrace, int bitsDamageType);
	void Explode2(TraceResult *pTrace, int bitsDamageType);
	void Explode3(TraceResult *pTrace, int bitsDamageType);
	void EXPORT Smoke(void);
	void EXPORT SG_Smoke(void);
	void EXPORT Smoke2(void);
	void EXPORT Smoke3_A(void);
	void EXPORT Smoke3_B(void);
	void EXPORT Smoke3_C(void);
	void EXPORT BounceTouch(CBaseEntity *pOther);
	void EXPORT SlideTouch(CBaseEntity *pOther);
	void EXPORT ExplodeTouch(CBaseEntity *pOther);
	void EXPORT DangerSoundThink(void);
	void EXPORT PreDetonate(void);
	void EXPORT Detonate(void);
	void EXPORT SG_Detonate(void);
	void EXPORT Detonate2(void);
	void EXPORT Detonate3(void);
	void EXPORT DetonateUse(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	void EXPORT TumbleThink(void);
	void EXPORT SG_TumbleThink(void);
	void EXPORT C4Think(void);
	void EXPORT C4Touch(CBaseEntity *pOther) {}

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	bool m_bStartDefuse;
	bool m_bIsC4;
	EHANDLE m_pBombDefuser;
	float m_flDefuseCountDown;
	float m_flC4Blow;
	float m_flNextFreqInterval;
	float m_flNextBeep;
	float m_flNextFreq;
	char *m_sBeepName;
	float m_fAttenu;
	float m_flNextBlink;
	float m_fNextDefuse;
	bool m_bJustBlew;
	int m_iTeam;
	int m_iCurWave;
	edict_t *m_pentCurBombTarget;
	int m_SGSmoke;
	int m_angle;
	unsigned short m_usEvent;
	bool m_bLightSmoke;
	bool m_bDetonated;
	Vector m_vSmokeDetonate;
	int m_iBounceCount;
	BOOL m_fRegisteredSound;
};

#define ITEM_HEALTHKIT 1
#define ITEM_ANTIDOTE 2
#define ITEM_SECURITY 3
#define ITEM_BATTERY 4

#define WEAPON_ALLWEAPONS (~(1 << WEAPON_SUIT))
#define WEAPON_SUIT 31
#define MAX_WEAPONS 32

#define MAX_NORMAL_BATTERY 100

#define WEAPON_NOCLIP -1

#define _9MM_MAX_CARRY MAX_AMMO_9MM
#define BUCKSHOT_MAX_CARRY MAX_AMMO_BUCKSHOT
#define _556NATO_MAX_CARRY MAX_AMMO_556NATO
#define _556NATOBOX_MAX_CARRY MAX_AMMO_556NATOBOX
#define _762NATO_MAX_CARRY MAX_AMMO_762NATO
#define _45ACP_MAX_CARRY MAX_AMMO_45ACP
#define _50AE_MAX_CARRY MAX_AMMO_50AE
#define _338MAGNUM_MAX_CARRY MAX_AMMO_338MAGNUM
#define _57MM_MAX_CARRY MAX_AMMO_57MM
#define _357SIG_MAX_CARRY MAX_AMMO_357SIG

#define HEGRENADE_MAX_CARRY 1
#define FLASHBANG_MAX_CARRY 2
#define SMOKEGRENADE_MAX_CARRY 1
#define C4_MAX_CARRY 1


#define ITEM_FLAG_SELECTONEMPTY 1
#define ITEM_FLAG_NOAUTORELOAD 2
#define ITEM_FLAG_NOAUTOSWITCHEMPTY 4
#define ITEM_FLAG_LIMITINWORLD 8
#define ITEM_FLAG_EXHAUSTIBLE 16

#define WPNSLOT_PRIMARY 1
#define WPNSLOT_SECONDARY 2
#define WPNSLOT_KNIFE 3
#define WPNSLOT_GRENADE 4
#define WPNSLOT_C4 5

#define WEAPON_IS_ONTARGET 0x40

typedef struct
{
	int iSlot;
	int iPosition;
	const char *pszAmmo1;
	int iMaxAmmo1;
	const char *pszAmmo2;
	int iMaxAmmo2;
	const char *pszName;
	int iMaxClip;
	int iId;
	int iFlags;
	int iWeight;
}
ItemInfo;

typedef struct
{
	const char *pszName;
	int iId;
}
AmmoInfo;

class CBasePlayerItem : public CBaseAnimating
{
public:
	virtual int Save(CSave &save) { return 1; }
	virtual int Restore(CRestore &restore) { return 1; }
	virtual void SetObjectCollisionBox(void) { }
	virtual int AddToPlayer(CBasePlayer *pPlayer) { return false; }
	virtual int AddDuplicate(CBasePlayerItem *pItem) { return FALSE; }
	virtual int GetItemInfo(ItemInfo *p) { return 0; }
	virtual BOOL CanDeploy(void) { return TRUE; }
	virtual BOOL CanDrop(void) { return TRUE; }
	virtual BOOL Deploy(void) { return TRUE; }
	virtual BOOL IsWeapon(void) { return FALSE; }
	virtual BOOL CanHolster(void) { return TRUE; }
	virtual void Holster(int skiplocal = 0) {}
	virtual void UpdateItemInfo(void) {}
	virtual void ItemPreFrame(void) {}
	virtual void ItemPostFrame(void) {}
	virtual void Drop(void) {}
	virtual void Kill(void) {}
	virtual void AttachToPlayer(CBasePlayer *pPlayer) {}
	virtual int PrimaryAmmoIndex(void) { return -1; }
	virtual int SecondaryAmmoIndex(void) { return -1; }
	virtual int UpdateClientData(CBasePlayer *pPlayer) { return 0; }
	virtual CBasePlayerItem *GetWeaponPtr(void) { return NULL; }
	virtual float GetMaxSpeed(void) { return 260; }
	virtual int iItemSlot(void) { return 0; }

public:
	void EXPORT DestroyItem(void) {}
	void EXPORT DefaultTouch(CBaseEntity *pOther) {}
	void EXPORT FallThink(void) {}
	void EXPORT Materialize(void) {}
	void EXPORT AttemptToMaterialize(void) {}
	CBaseEntity *Respawn(void) { return this; }
	void FallInit(void) { }
	void CheckRespawn(void) {}

public:
	static TYPEDESCRIPTION m_SaveData[];
	static ItemInfo ItemInfoArray[MAX_WEAPONS];
	static AmmoInfo AmmoInfoArray[MAX_AMMO_SLOTS];

public:
	CBasePlayer *m_pPlayer;
	CBasePlayerItem *m_pNext;
	int m_iId;

public:
	int iItemPosition(void) { return ItemInfoArray[m_iId].iPosition; }
	const char *pszAmmo1(void) { return ItemInfoArray[m_iId].pszAmmo1; }
	int iMaxAmmo1(void) { return ItemInfoArray[m_iId].iMaxAmmo1; }
	const char *pszAmmo2(void) { return ItemInfoArray[m_iId].pszAmmo2; }
	int iMaxAmmo2(void) { return ItemInfoArray[m_iId].iMaxAmmo2; }
	const char *pszName(void) { return ItemInfoArray[m_iId].pszName; }
	int iMaxClip(void) { return ItemInfoArray[m_iId].iMaxClip; }
	int iWeight(void) { return ItemInfoArray[m_iId].iWeight; }
	int iFlags(void) { return ItemInfoArray[m_iId].iFlags; }
};

class CBasePlayerWeapon : public CBasePlayerItem
{
public:
	virtual int Save(CSave &save) { return 1; }
	virtual int Restore(CRestore &restore) { return 1; }
	virtual int AddToPlayer(CBasePlayer *pPlayer) { return 0; }
	virtual int AddDuplicate(CBasePlayerItem *pItem) { return 0; }
	virtual int ExtractAmmo(CBasePlayerWeapon *pWeapon) { return 0; }
	virtual int ExtractClipAmmo(CBasePlayerWeapon *pWeapon) { return 0; }
	virtual int AddWeapon(void) { ExtractAmmo(this); return TRUE; }
	virtual void UpdateItemInfo(void) {}
	virtual BOOL PlayEmptySound(void);
	virtual void ResetEmptySound(void);
	virtual void SendWeaponAnim(int iAnim, int skiplocal = 0);
	virtual BOOL CanDeploy(void);
	virtual BOOL IsWeapon(void) { return TRUE; }
	virtual BOOL IsUseable(void) { return true; }
	virtual void ItemPostFrame(void);
	virtual void PrimaryAttack(void) {}
	virtual void SecondaryAttack(void) {}
	virtual void Reload(void) {}
	virtual void WeaponIdle(void) {}
	virtual int UpdateClientData(CBasePlayer *pPlayer) { return 0; }
	virtual void RetireWeapon(void);
	virtual BOOL ShouldWeaponIdle(void) { return FALSE; }
	virtual void Holster(int skiplocal = 0);
	virtual BOOL UseDecrement(void) { return FALSE; }
	virtual CBasePlayerItem *GetWeaponPtr(void) { return (CBasePlayerItem *)this; }

public:
	BOOL DefaultDeploy(const char *szViewModel, const char *szWeaponModel, int iAnim, const char *szAnimExt, int skiplocal = 0);
	int DefaultReload(int iClipSize, int iAnim, float fDelay, int body = 0);
	void ReloadSound(void);
	BOOL AddPrimaryAmmo(int iCount, char *szName, int iMaxClip, int iMaxCarry) { return true; }
	BOOL AddSecondaryAmmo(int iCount, char *szName, int iMaxCarry) { return true; }
	int PrimaryAmmoIndex(void) { return -1; }
	int SecondaryAmmoIndex(void) { return -1; }
	void EjectBrassLate(void);
	void KickBack(float up_base, float lateral_base, float up_modifier, float lateral_modifier, float up_max, float lateral_max, int direction_change);
	void FireRemaining(int &shotsFired, float &shootTime, BOOL isGlock18);
	void SetPlayerShieldAnim(void);
	void ResetPlayerShieldAnim(void);
	bool ShieldSecondaryFire(int up_anim, int down_anim);
	bool HasSecondaryAttack(void);
	float GetNextAttackDelay(float delay);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	int m_iPlayEmptySound;
	int m_fFireOnEmpty;
	float m_flNextPrimaryAttack;
	float m_flNextSecondaryAttack;
	float m_flTimeWeaponIdle;
	int m_iPrimaryAmmoType;
	int m_iSecondaryAmmoType;
	int m_iClip;
	int m_iClientClip;
	int m_iClientWeaponState;
	int m_fInReload;
	int m_fInSpecialReload;
	int m_iDefaultAmmo;
	int m_iShellId;
	int m_fMaxSpeed;
	bool m_bDelayFire;
	int m_iDirection;
	bool m_bSecondarySilencerOn;
	float m_flAccuracy;
	float m_flLastFire;
	int m_iShotsFired;
	Vector m_vVecAiming;
	string_t model_name;
	float m_flGlock18Shoot;
	int m_iGlock18ShotsFired;
	float m_flFamasShoot;
	int m_iFamasShotsFired;
	float m_fBurstSpread;
	int m_iWeaponState;
	float m_flNextReload;
	float m_flDecreaseShotsFired;
	unsigned short m_usFireGlock18;
	unsigned short m_usFireFamas;
};

class CBasePlayerAmmo : public CBaseEntity
{
public:
	virtual void Spawn(void){}
	virtual BOOL AddAmmo(CBaseEntity *pOther) { return TRUE; }

public:
	void EXPORT Materialize(void) { }
	void EXPORT DefaultTouch(CBaseEntity *pOther) { }
	CBaseEntity *Respawn(void) { return this; }
};

extern DLL_GLOBAL short g_sModelIndexLaser;
extern DLL_GLOBAL const char *g_pModelNameLaser;
extern DLL_GLOBAL short g_sModelIndexLaserDot;
extern DLL_GLOBAL short g_sModelIndexFireball;
extern DLL_GLOBAL short g_sModelIndexFireball2;
extern DLL_GLOBAL short g_sModelIndexFireball3;
extern DLL_GLOBAL short g_sModelIndexFireball4;
extern DLL_GLOBAL short g_sModelIndexSmoke;
extern DLL_GLOBAL short g_sModelIndexSmokePuff;
extern DLL_GLOBAL short g_sModelIndexWExplosion;
extern DLL_GLOBAL short g_sModelIndexBubbles;
extern DLL_GLOBAL short g_sModelIndexBloodDrop;
extern DLL_GLOBAL short g_sModelIndexBloodSpray;
extern DLL_GLOBAL short g_sModelIndexRadio;
extern DLL_GLOBAL short g_sModelIndexCTGhost;
extern DLL_GLOBAL short g_sModelIndexTGhost;
extern DLL_GLOBAL short g_sModelIndexC4Glow;

#ifndef CLIENT_WEAPONS
extern void ClearMultiDamage(void);
extern void ApplyMultiDamage(entvars_t *pevInflictor, entvars_t *pevAttacker);
extern void AddMultiDamage(entvars_t *pevInflictor, CBaseEntity *pEntity, float flDamage, int bitsDamageType);
extern void DecalGunshot(TraceResult *pTrace, int iBulletType, bool ClientOnly, entvars_t *pShooter, bool bHitMetal);
extern void SpawnBlood(Vector vecSpot, int bloodColor, float flDamage);
extern int DamageDecal(CBaseEntity *pEntity, int bitsDamageType);
extern void RadiusFlash(Vector vecSrc, entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage);
extern void RadiusDamage(Vector vecSrc, entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, float flRadius, int iClassIgnore, int bitsDamageType);
#else
inline void ClearMultiDamage(void) { }
inline void ApplyMultiDamage(entvars_t *pevInflictor, entvars_t *pevAttacker) { }
inline void DecalGunshot(TraceResult *pTrace, int iBulletType, bool ClientOnly, entvars_t *pShooter, bool bHitMetal) { }
#endif
typedef struct
{
	CBaseEntity *pEntity;
	float amount;
	int type;
}
MULTIDAMAGE;

extern MULTIDAMAGE gMultiDamage;

#define LOUD_GUN_VOLUME 1000
#define NORMAL_GUN_VOLUME 600
#define QUIET_GUN_VOLUME 200

#define BRIGHT_GUN_FLASH 512
#define NORMAL_GUN_FLASH 256
#define DIM_GUN_FLASH 128

#define BIG_EXPLOSION_VOLUME 2048
#define NORMAL_EXPLOSION_VOLUME 1024
#define SMALL_EXPLOSION_VOLUME 512

#define WEAPON_ACTIVITY_VOLUME 64

#define VECTOR_CONE_1DEGREES Vector(0.00873, 0.00873, 0.00873)
#define VECTOR_CONE_2DEGREES Vector(0.01745, 0.01745, 0.01745)
#define VECTOR_CONE_3DEGREES Vector(0.02618, 0.02618, 0.02618)
#define VECTOR_CONE_4DEGREES Vector(0.03490, 0.03490, 0.03490)
#define VECTOR_CONE_5DEGREES Vector(0.04362, 0.04362, 0.04362)
#define VECTOR_CONE_6DEGREES Vector(0.05234, 0.05234, 0.05234)
#define VECTOR_CONE_7DEGREES Vector(0.06105, 0.06105, 0.06105)
#define VECTOR_CONE_8DEGREES Vector(0.06976, 0.06976, 0.06976)
#define VECTOR_CONE_9DEGREES Vector(0.07846, 0.07846, 0.07846)
#define VECTOR_CONE_10DEGREES Vector(0.08716, 0.08716, 0.08716)
#define VECTOR_CONE_15DEGREES Vector(0.13053, 0.13053, 0.13053)
#define VECTOR_CONE_20DEGREES Vector(0.17365, 0.17365, 0.17365)

class CWeaponBox : public CBaseEntity
{
public:
	void Spawn(void);
	void Precache(void);
	void KeyValue(KeyValueData *pkvd);
	int Save(CSave &save);
	int Restore(CRestore &restore);
	void Touch(CBaseEntity *pOther);
	void SetObjectCollisionBox(void);

public:
	BOOL IsEmpty(void);
	int GiveAmmo(int iCount, char *szName, int iMax, int *pIndex = NULL); // -V762
	void EXPORT Kill(void);
	BOOL HasWeapon(CBasePlayerItem *pCheckItem);
	BOOL PackWeapon(CBasePlayerItem *pWeapon);
	BOOL PackAmmo(int iszName, int iCount);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	CBasePlayerItem *m_rgpPlayerItems[MAX_ITEM_TYPES];
	int m_rgiszAmmo[MAX_AMMO_SLOTS];
	int m_rgAmmo[MAX_AMMO_SLOTS];
	int m_cAmmoTypes;
};

class CWShield : public CBaseEntity
{
public:
	void Spawn(void);
	void EXPORT Touch(CBaseEntity *pOther);
	void SetCantBePickedUpByUser(CBaseEntity *pEntity, float time);

public:
	EHANDLE m_hEntToIgnoreTouchesFrom;
	float m_flTimeToIgnoreTouches;
};

#ifdef PLAYER_H

class CAK47 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 221; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void AK47Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireAK47;
};

class CAUG : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 240; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	void AUGFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireAug;
};

class CAWP : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void);
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void AWPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireAWP;
};

// for usermsg BombDrop
#define BOMB_FLAG_DROPPED	0 // if the bomb was dropped due to voluntary dropping or death/disconnect
#define BOMB_FLAG_PLANTED	1 // if the bomb has been planted will also trigger the round timer to hide will also show where the dropped bomb on the Terrorist team's radar.

class CC4 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	void KeyValue(KeyValueData *pkvd);
	void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	void Holster(int skiplocal);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_C4; }
	void PrimaryAttack(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	bool m_bStartedArming;
	bool m_bBombPlacedAnimation;
	float m_fArmedTime;
	bool m_bHasShield;
};

class CDEAGLE : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void DEAGLEFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireDeagle;
};

class CELITE : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void ELITEFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireELITE_LEFT;
	unsigned short m_usFireELITE_RIGHT;
};

class CFamas : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 240; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void FamasFire(float flSpread, float flCycleTime, BOOL fUseAutoAim, BOOL bFireBurst);

private:
	int m_iShell;
	int iShellOn;
};

class CFiveSeven : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void FiveSevenFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireFiveSeven;
};

class CFlashbang : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL CanDeploy(void);
	BOOL CanDrop(void) { return FALSE; }
	BOOL Deploy(void);
	void Holster(int skiplocal);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_GRENADE; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void WeaponIdle(void);
	void SetPlayerShieldAnim(void);
	void ResetPlayerShieldAnim(void);
	bool ShieldSecondaryFire(int up_anim, int down_anim);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}
};

class CG3SG1 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void);
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void G3SG1Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireG3SG1;
};

class CGalil : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 240; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void GalilFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireGalil;
};

class CGLOCK18 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void GLOCK18Fire(float flSpread, float flCycleTime, BOOL fUseBurstMode);

private:
	int m_iShell;
	bool m_bBurstFire;
};

class CHEGrenade : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL CanDeploy(void);
	BOOL CanDrop(void) { return FALSE; }
	BOOL Deploy(void);
	BOOL CanHolster(void);
	void Holster(int skiplocal);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_GRENADE; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void WeaponIdle(void);
	void SetPlayerShieldAnim(void);
	void ResetPlayerShieldAnim(void);
	bool ShieldSecondaryFire(int up_anim, int down_anim);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	unsigned short m_usCreateExplosion;
};

class CKnife : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL CanDrop(void) { return FALSE; }
	BOOL Deploy(void);
	void Holster(int skiplocal);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_KNIFE; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void SetPlayerShieldAnim(void);
	void ResetPlayerShieldAnim(void);
	bool ShieldSecondaryFire(int up_anim, int down_anim);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	void WeaponAnimation(int iAnimation);
	void EXPORT SwingAgain(void);
	void EXPORT Smack(void);
	int Swing(int fFirst);
	int Stab(int fFirst);

private:
	//int m_iSwing; //Already exists in CBaseDelay
	TraceResult m_trHit;
	unsigned short m_usKnife;
};

class CM249 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 220; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void M249Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireM249;
};

class CM3 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 230; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	int m_iShell;
	float m_flPumpTime;
	unsigned short m_usFireM3;
};

class CM4A1 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 230; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void M4A1Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireM4A1;
};

class CMAC10 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void MAC10Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireMAC10;
};

class CMP5N : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void MP5NFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireMP5N;
};

class CP228 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void P228Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireP228;
};

class CP90 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 245; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void P90Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireP90;
};

class CSCOUT : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void);
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void SCOUTFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireScout;
};

class CSG550 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void);
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void SG550Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireSG550;
};

class CSG552 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void);
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	void SG552Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireSG552;
};

class CSmokeGrenade : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL CanDeploy(void);
	BOOL CanDrop(void) { return FALSE; }
	BOOL Deploy(void);
	void Holster(int skiplocal);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_GRENADE; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void WeaponIdle(void);
	void SetPlayerShieldAnim(void);
	void ResetPlayerShieldAnim(void);
	bool ShieldSecondaryFire(int up_anim, int down_anim);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	unsigned short m_usCreateSmoke;
};

class CTMP : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void TMPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireTMP;
};

class CUMP45 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void UMP45Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireUMP45;
};

class CUSP : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void USPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireUSP;
};

class CXM1014 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 240; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	int m_iShell;
	float m_flPumpTime;
	unsigned short m_usFireXM1014;
};

#endif

#define ARMOURY_MP5NAVY 0
#define ARMOURY_TMP 1
#define ARMOURY_P90 2
#define ARMOURY_MAC10 3
#define ARMOURY_AK47 4
#define ARMOURY_SG552 5
#define ARMOURY_M4A1 6
#define ARMOURY_AUG 7
#define ARMOURY_SCOUT 8
#define ARMOURY_G3SG1 9
#define ARMOURY_AWP 10
#define ARMOURY_M3 11
#define ARMOURY_XM1014 12
#define ARMOURY_M249 13
#define ARMOURY_FLASHBANG 14
#define ARMOURY_HEGRENADE 15
#define ARMOURY_KEVLAR 16
#define ARMOURY_ASSAULT 17
#define ARMOURY_SMOKEGRENADE 18

class CArmoury : public CBaseEntity
{
public:
	void Spawn(void);
	void Precache(void);
	void Restart(void);
	void KeyValue(KeyValueData *pkvd);

public:
	void EXPORT ArmouryTouch(CBaseEntity *pOther);

public:
	int m_iItem;
	int m_iCount;
	int m_iInitialCount;
	bool m_bAlreadyCounted;
};

#include "wpn_shared.h"
#include "weapontype.h"

#endif

```

`dlls/weapontype.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef WEAPONTYPE_H
#define WEAPONTYPE_H
#ifdef _WIN32
#pragma once
#endif

enum WeaponIdType
{
	WEAPON_NONE,
	WEAPON_P228,
	WEAPON_GLOCK,
	WEAPON_SCOUT,
	WEAPON_HEGRENADE,
	WEAPON_XM1014,
	WEAPON_C4,
	WEAPON_MAC10,
	WEAPON_AUG,
	WEAPON_SMOKEGRENADE,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_UMP45,
	WEAPON_SG550,
	WEAPON_GALIL,
	WEAPON_FAMAS,
	WEAPON_USP,
	WEAPON_GLOCK18,
	WEAPON_AWP,
	WEAPON_MP5N,
	WEAPON_M249,
	WEAPON_M3,
	WEAPON_M4A1,
	WEAPON_TMP,
	WEAPON_G3SG1,
	WEAPON_FLASHBANG,
	WEAPON_DEAGLE,
	WEAPON_SG552,
	WEAPON_AK47,
	WEAPON_KNIFE,
	WEAPON_P90,
	WEAPON_SHIELDGUN = 99
};

enum AutoBuyClassType
{
	AUTOBUYCLASS_NONE		= 0,
	AUTOBUYCLASS_PRIMARY		= (1 << 0),
	AUTOBUYCLASS_SECONDARY		= (1 << 1),
	AUTOBUYCLASS_AMMO		= (1 << 2),
	AUTOBUYCLASS_ARMOR		= (1 << 3),
	AUTOBUYCLASS_DEFUSER		= (1 << 4),
	AUTOBUYCLASS_PISTOL		= (1 << 5),
	AUTOBUYCLASS_SMG		= (1 << 6),
	AUTOBUYCLASS_RIFLE		= (1 << 7),
	AUTOBUYCLASS_SNIPERRIFLE	= (1 << 8),
	AUTOBUYCLASS_SHOTGUN		= (1 << 9),
	AUTOBUYCLASS_MACHINEGUN		= (1 << 10),
	AUTOBUYCLASS_GRENADE		= (1 << 11),
	AUTOBUYCLASS_NIGHTVISION	= (1 << 12),
	AUTOBUYCLASS_SHIELD		= (1 << 13),
};

enum AmmoCostType
{
	AMMO_338MAG_PRICE	= 125,
	AMMO_357SIG_PRICE	= 50,
	AMMO_45ACP_PRICE	= 25,
	AMMO_50AE_PRICE		= 40,
	AMMO_556MM_PRICE	= 60,
	AMMO_57MM_PRICE		= 50,
	AMMO_762MM_PRICE	= 80,
	AMMO_9MM_PRICE		= 20,
	AMMO_BUCKSHOT_PRICE	= 65,
};

enum WeaponCostType
{
	AK47_PRICE	= 2500,
	AWP_PRICE	= 4750,
	DEAGLE_PRICE	= 650,
	G3SG1_PRICE	= 5000,
	SG550_PRICE	= 4200,
	GLOCK18_PRICE	= 400,
	M249_PRICE	= 5750,
	M3_PRICE	= 1700,
	M4A1_PRICE	= 3100,
	AUG_PRICE	= 3500,
	MP5NAVY_PRICE	= 1500,
	P228_PRICE	= 600,
	P90_PRICE	= 2350,
	UMP45_PRICE	= 1700,
	MAC10_PRICE	= 1400,
	SCOUT_PRICE	= 2750,
	SG552_PRICE	= 3500,
	TMP_PRICE	= 1250,
	USP_PRICE	= 500,
	ELITE_PRICE	= 800,
	FIVESEVEN_PRICE	= 750,
	XM1014_PRICE	= 3000,
	GALIL_PRICE	= 2000,
	FAMAS_PRICE	= 2250,
	SHIELDGUN_PRICE	= 2200,
};

enum WeaponState
{
	WPNSTATE_USP_SILENCED		= (1 << 0),
	WPNSTATE_GLOCK18_BURST_MODE	= (1 << 1),
	WPNSTATE_M4A1_SILENCED		= (1 << 2),
	WPNSTATE_ELITE_LEFT		= (1 << 3),
	WPNSTATE_FAMAS_BURST_MODE	= (1 << 4),
	WPNSTATE_SHIELD_DRAWN		= (1 << 5),
};

// custom enum
// the default amount of ammo that comes with each gun when it spawns
enum ClipGiveDefault
{
	P228_DEFAULT_GIVE		= 13,
	GLOCK18_DEFAULT_GIVE		= 20,
	SCOUT_DEFAULT_GIVE		= 10,
	HEGRENADE_DEFAULT_GIVE		= 1,
	XM1014_DEFAULT_GIVE		= 7,
	C4_DEFAULT_GIVE			= 1,
	MAC10_DEFAULT_GIVE		= 30,
	AUG_DEFAULT_GIVE		= 30,
	SMOKEGRENADE_DEFAULT_GIVE	= 1,
	ELITE_DEFAULT_GIVE		= 30,
	FIVESEVEN_DEFAULT_GIVE		= 20,
	UMP45_DEFAULT_GIVE		= 25,
	SG550_DEFAULT_GIVE		= 30,
	GALIL_DEFAULT_GIVE		= 35,
	FAMAS_DEFAULT_GIVE		= 25,
	USP_DEFAULT_GIVE		= 12,
	AWP_DEFAULT_GIVE		= 10,
	MP5NAVY_DEFAULT_GIVE		= 30,
	M249_DEFAULT_GIVE		= 100,
	M3_DEFAULT_GIVE			= 8,
	M4A1_DEFAULT_GIVE		= 30,
	TMP_DEFAULT_GIVE		= 30,
	G3SG1_DEFAULT_GIVE		= 20,
	FLASHBANG_DEFAULT_GIVE		= 1,
	DEAGLE_DEFAULT_GIVE		= 7,
	SG552_DEFAULT_GIVE		= 30,
	AK47_DEFAULT_GIVE		= 30,
	/*KNIFE_DEFAULT_GIVE		= 1,*/
	P90_DEFAULT_GIVE		= 50,
};

enum ClipSizeType
{
	P228_MAX_CLIP		= 13,
	GLOCK18_MAX_CLIP	= 20,
	SCOUT_MAX_CLIP		= 10,
	XM1014_MAX_CLIP		= 7,
	MAC10_MAX_CLIP		= 30,
	AUG_MAX_CLIP		= 30,
	ELITE_MAX_CLIP		= 30,
	FIVESEVEN_MAX_CLIP	= 20,
	UMP45_MAX_CLIP		= 25,
	SG550_MAX_CLIP		= 30,
	GALIL_MAX_CLIP		= 35,
	FAMAS_MAX_CLIP		= 25,
	USP_MAX_CLIP		= 12,
	AWP_MAX_CLIP		= 10,
	MP5N_MAX_CLIP		= 30,
	M249_MAX_CLIP		= 100,
	M3_MAX_CLIP		= 8,
	M4A1_MAX_CLIP		= 30,
	TMP_MAX_CLIP		= 30,
	G3SG1_MAX_CLIP		= 20,
	DEAGLE_MAX_CLIP		= 7,
	SG552_MAX_CLIP		= 30,
	AK47_MAX_CLIP		= 30,
	P90_MAX_CLIP		= 50,
};

enum WeightWeapon
{
	P228_WEIGHT		= 5,
	GLOCK18_WEIGHT		= 5,
	SCOUT_WEIGHT		= 30,
	HEGRENADE_WEIGHT	= 2,
	XM1014_WEIGHT		= 20,
	C4_WEIGHT		= 3,
	MAC10_WEIGHT		= 25,
	AUG_WEIGHT		= 25,
	SMOKEGRENADE_WEIGHT	= 1,
	ELITE_WEIGHT		= 5,
	FIVESEVEN_WEIGHT	= 5,
	UMP45_WEIGHT		= 25,
	SG550_WEIGHT		= 20,
	GALIL_WEIGHT		= 25,
	FAMAS_WEIGHT		= 75,
	USP_WEIGHT		= 5,
	AWP_WEIGHT		= 30,
	MP5NAVY_WEIGHT		= 25,
	M249_WEIGHT		= 25,
	M3_WEIGHT		= 20,
	M4A1_WEIGHT		= 25,
	TMP_WEIGHT		= 25,
	G3SG1_WEIGHT		= 20,
	FLASHBANG_WEIGHT	= 1,
	DEAGLE_WEIGHT		= 7,
	SG552_WEIGHT		= 25,
	AK47_WEIGHT		= 25,
	P90_WEIGHT		= 26,
	KNIFE_WEIGHT		= 0,
};

enum MaxAmmoType
{
	MAX_AMMO_BUCKSHOT	= 32,
	MAX_AMMO_9MM		= 120,
	MAX_AMMO_556NATO	= 90,
	MAX_AMMO_556NATOBOX	= 200,
	MAX_AMMO_762NATO	= 90,
	MAX_AMMO_45ACP		= 100,
	MAX_AMMO_50AE		= 35,
	MAX_AMMO_338MAGNUM	= 30,
	MAX_AMMO_57MM		= 100,
	MAX_AMMO_357SIG		= 52,

	// custom
	MAX_AMMO_SMOKEGRENADE	= 1,
	MAX_AMMO_HEGRENADE	= 1,
	MAX_AMMO_FLASHBANG	= 2,
};

enum AmmoType
{
	AMMO_NONE,
	AMMO_338MAGNUM,
	AMMO_762NATO,
	AMMO_556NATOBOX,
	AMMO_556NATO,
	AMMO_BUCKSHOT,
	AMMO_45ACP,
	AMMO_57MM,
	AMMO_50AE,
	AMMO_357SIG,
	AMMO_9MM,
	AMMO_FLASHBANG,
	AMMO_HEGRENADE,
	AMMO_SMOKEGRENADE,
	AMMO_C4,

	AMMO_MAX_TYPES
};

enum WeaponClassType
{
	WEAPONCLASS_NONE,
	WEAPONCLASS_KNIFE,
	WEAPONCLASS_PISTOL,
	WEAPONCLASS_GRENADE,
	WEAPONCLASS_SUBMACHINEGUN,
	WEAPONCLASS_SHOTGUN,
	WEAPONCLASS_MACHINEGUN,
	WEAPONCLASS_RIFLE,
	WEAPONCLASS_SNIPERRIFLE,
	WEAPONCLASS_MAX,
};

enum AmmoBuyAmount
{
	AMMO_338MAG_BUY		= 10,
	AMMO_357SIG_BUY		= 13,
	AMMO_45ACP_BUY		= 12,
	AMMO_50AE_BUY		= 7,
	AMMO_556NATO_BUY	= 30,
	AMMO_556NATOBOX_BUY	= 30,
	AMMO_57MM_BUY		= 50,
	AMMO_762NATO_BUY	= 30,
	AMMO_9MM_BUY		= 30,
	AMMO_BUCKSHOT_BUY	= 8,
};

enum ItemCostType
{
	ASSAULTSUIT_PRICE	= 1000,
	FLASHBANG_PRICE		= 200,
	HEGRENADE_PRICE		= 300,
	SMOKEGRENADE_PRICE	= 300,
	KEVLAR_PRICE		= 650,
	HELMET_PRICE		= 350,
	NVG_PRICE		= 1250,
	DEFUSEKIT_PRICE		= 200,
};

enum shieldgun_e
{
	SHIELDGUN_IDLE,
	SHIELDGUN_SHOOT1,
	SHIELDGUN_SHOOT2,
	SHIELDGUN_SHOOT_EMPTY,
	SHIELDGUN_RELOAD,
	SHIELDGUN_DRAW,
	SHIELDGUN_DRAWN_IDLE,
	SHIELDGUN_UP,
	SHIELDGUN_DOWN,
};

// custom
enum shieldgren_e
{
	SHIELDREN_IDLE = 4,
	SHIELDREN_UP,
	SHIELDREN_DOWN
};

enum InventorySlotType
{
	NONE_SLOT,
	PRIMARY_WEAPON_SLOT,
	PISTOL_SLOT,
	KNIFE_SLOT,
	GRENADE_SLOT,
	C4_SLOT,
};
 
enum Bullet
{
	BULLET_NONE,
	BULLET_PLAYER_9MM,
	BULLET_PLAYER_MP5,
	BULLET_PLAYER_357,
	BULLET_PLAYER_BUCKSHOT,
	BULLET_PLAYER_CROWBAR,
	BULLET_MONSTER_9MM,
	BULLET_MONSTER_MP5,
	BULLET_MONSTER_12MM,
	BULLET_PLAYER_45ACP,
	BULLET_PLAYER_338MAG,
	BULLET_PLAYER_762MM,
	BULLET_PLAYER_556MM,
	BULLET_PLAYER_50AE,
	BULLET_PLAYER_57MM,
	BULLET_PLAYER_357SIG,

	// CSCZDS
	BULLET_PLAYER_BLOWTORCH
};

struct WeaponStruct
{
	int m_type;
	int m_price;
	int m_side;
	int m_slot;
	int m_ammoPrice;
};

struct AutoBuyInfoStruct
{
	AutoBuyClassType m_class;
	char *m_command;
	char *m_classname;
};

struct WeaponAliasInfo
{
	char *alias;
	WeaponIdType id;
};

struct WeaponBuyAliasInfo
{
	char *alias;
	WeaponIdType id;
	char *failName;
};

struct WeaponClassAliasInfo
{
	char *alias;
	WeaponClassType id;
};

struct WeaponInfoStruct
{
	int id;
	int cost;
	int clipCost;
	int buyClipSize;
	int gunClipSize;
	int maxRounds;
	AmmoType ammoType;
	char *entityName;

	// custom
	const char *ammoName;
};

struct WeaponSlotInfo
{
	WeaponIdType id;
	InventorySlotType slot;
	const char *weaponName;
};

extern AutoBuyInfoStruct g_autoBuyInfo[35];
extern WeaponStruct g_weaponStruct[MAX_WEAPONS];

// WeaponType
WeaponIdType AliasToWeaponID(const char *alias);
const char *BuyAliasToWeaponID(const char *alias, WeaponIdType &id);
const char *WeaponIDToAlias(int id);
WeaponClassType AliasToWeaponClass(const char *alias);
WeaponClassType WeaponIDToWeaponClass(int id);
bool IsPrimaryWeapon(int id);
bool IsSecondaryWeapon(int id);
bool CanBuyWeaponByMaptype(int playerTeam, WeaponIdType weaponID, bool useAssasinationRestrictions);
void WeaponInfoReset();

WeaponInfoStruct* GetWeaponInfo(int weaponID);
WeaponInfoStruct* GetWeaponInfo(const char* weaponName);

WeaponSlotInfo* GetWeaponSlot(WeaponIdType weaponID);
WeaponSlotInfo* GetWeaponSlot(const char* weaponName);

#endif // WEAPONTYPE_H

```

`dlls/wpn_shared.h`:

```h
#pragma once

//AK47
#define AK47_MAX_SPEED			221
#define AK47_DAMAGE			36
#define AK47_RANGE_MODIFER		0.98
#define AK47_RELOAD_TIME		2.45

enum ak47_e
{
	AK47_IDLE1,
	AK47_RELOAD,
	AK47_DRAW,
	AK47_SHOOT1,
	AK47_SHOOT2,
	AK47_SHOOT3
};



//AUG
#define AUG_MAX_SPEED			240
#define AUG_DAMAGE			32
#define AUG_RANGE_MODIFER		0.96
#define AUG_RELOAD_TIME			3.3

enum aug_e
{
	AUG_IDLE1,
	AUG_RELOAD,
	AUG_DRAW,
	AUG_SHOOT1,
	AUG_SHOOT2,
	AUG_SHOOT3
};



//AWP
#define AWP_MAX_SPEED		210
#define AWP_MAX_SPEED_ZOOM	150
#define AWP_DAMAGE		115
#define AWP_RANGE_MODIFER	0.99
#define AWP_RELOAD_TIME		2.5

enum awp_e
{
	AWP_IDLE,
	AWP_SHOOT,
	AWP_SHOOT2,
	AWP_SHOOT3,
	AWP_RELOAD,
	AWP_DRAW,
};



//C4
#define C4_MAX_AMMO		1
#define C4_MAX_SPEED		250.0
#define C4_ARMING_ON_TIME	3.0

enum c4_e
{
	C4_IDLE1,
	C4_DRAW,
	C4_DROP,
	C4_ARM
};



//Deagle
#define DEAGLE_MAX_SPEED	250
#define DEAGLE_DAMAGE		54
#define DEAGLE_RANGE_MODIFER	0.81
#define DEAGLE_RELOAD_TIME	2.2

enum deagle_e
{
	DEAGLE_IDLE1,
	DEAGLE_SHOOT1,
	DEAGLE_SHOOT2,
	DEAGLE_SHOOT_EMPTY,
	DEAGLE_RELOAD,
	DEAGLE_DRAW
};



//Elites
#define ELITE_MAX_SPEED		250
#define ELITE_RELOAD_TIME	4.5
#define ELITE_DAMAGE		36
#define ELITE_RANGE_MODIFER	0.75

enum elite_e
{
	ELITE_IDLE,
	ELITE_IDLE_LEFTEMPTY,
	ELITE_SHOOTLEFT1,
	ELITE_SHOOTLEFT2,
	ELITE_SHOOTLEFT3,
	ELITE_SHOOTLEFT4,
	ELITE_SHOOTLEFT5,
	ELITE_SHOOTLEFTLAST,
	ELITE_SHOOTRIGHT1,
	ELITE_SHOOTRIGHT2,
	ELITE_SHOOTRIGHT3,
	ELITE_SHOOTRIGHT4,
	ELITE_SHOOTRIGHT5,
	ELITE_SHOOTRIGHTLAST,
	ELITE_RELOAD,
	ELITE_DRAW
};



//Famas
#define FAMAS_MAX_SPEED		240
#define FAMAS_RELOAD_TIME	3.3
#define FAMAS_DAMAGE		30
#define FAMAS_DAMAGE_BURST	34
#define FAMAS_RANGE_MODIFER	0.96

enum famas_e
{
	FAMAS_IDLE1,
	FAMAS_RELOAD,
	FAMAS_DRAW,
	FAMAS_SHOOT1,
	FAMAS_SHOOT2,
	FAMAS_SHOOT3
};



//Fiveseven
#define FIVESEVEN_MAX_SPEED		250
#define FIVESEVEN_DAMAGE		20
#define FIVESEVEN_RANGE_MODIFER		0.885
#define FIVESEVEN_RELOAD_TIME		2.7

enum fiveseven_e
{
	FIVESEVEN_IDLE,
	FIVESEVEN_SHOOT1,
	FIVESEVEN_SHOOT2,
	FIVESEVEN_SHOOT_EMPTY,
	FIVESEVEN_RELOAD,
	FIVESEVEN_DRAW
};



//Flashbang
#define FLASHBANG_MAX_SPEED		250
#define FLASHBANG_MAX_SPEED_SHIELD	180

enum flashbang_e
{
	FLASHBANG_IDLE,
	FLASHBANG_PULLPIN,
	FLASHBANG_THROW,
	FLASHBANG_DRAW
};



//g3sg1
#define G3SG1_MAX_SPEED		210
#define G3SG1_MAX_SPEED_ZOOM	150
#define G3SG1_DAMAGE		80
#define G3SG1_RANGE_MODIFER	0.98
#define G3SG1_RELOAD_TIME	3.5

enum g3sg1_e
{
	G3SG1_IDLE,
	G3SG1_SHOOT,
	G3SG1_SHOOT2,
	G3SG1_RELOAD,
	G3SG1_DRAW
};



//galil
#define GALIL_MAX_SPEED			240
#define GALIL_DAMAGE			30
#define GALIL_RANGE_MODIFER		0.98
#define GALIL_RELOAD_TIME		2.45

enum galil_e
{
	GALIL_IDLE1,
	GALIL_RELOAD,
	GALIL_DRAW,
	GALIL_SHOOT1,
	GALIL_SHOOT2,
	GALIL_SHOOT3
};



//glock18
#define GLOCK18_MAX_SPEED		250
#define GLOCK18_DAMAGE			25
#define GLOCK18_RANGE_MODIFER		0.75
#define GLOCK18_RELOAD_TIME		2.2

enum glock18_e
{
	GLOCK18_IDLE1,
	GLOCK18_IDLE2,
	GLOCK18_IDLE3,
	GLOCK18_SHOOT,
	GLOCK18_SHOOT2,
	GLOCK18_SHOOT3,
	GLOCK18_SHOOT_EMPTY,
	GLOCK18_RELOAD,
	GLOCK18_DRAW,
	GLOCK18_HOLSTER,
	GLOCK18_ADD_SILENCER,
	GLOCK18_DRAW2,
	GLOCK18_RELOAD2
};

enum glock18_shield_e
{
	GLOCK18_SHIELD_IDLE1,
	GLOCK18_SHIELD_SHOOT,
	GLOCK18_SHIELD_SHOOT2,
	GLOCK18_SHIELD_SHOOT_EMPTY,
	GLOCK18_SHIELD_RELOAD,
	GLOCK18_SHIELD_DRAW,
	GLOCK18_SHIELD_IDLE,
	GLOCK18_SHIELD_UP,
	GLOCK18_SHIELD_DOWN
};



//hegrenade
#define HEGRENADE_MAX_SPEED		250
#define HEGRENADE_MAX_SPEED_SHIELD	180

enum hegrenade_e
{
	HEGRENADE_IDLE,
	HEGRENADE_PULLPIN,
	HEGRENADE_THROW,
	HEGRENADE_DRAW
};



//knife
#define KNIFE_BODYHIT_VOLUME		128
#define KNIFE_WALLHIT_VOLUME		512
#define KNIFE_MAX_SPEED			250
#define KNIFE_MAX_SPEED_SHIELD		180

enum knife_e
{
	KNIFE_IDLE,
	KNIFE_ATTACK1HIT,
	KNIFE_ATTACK2HIT,
	KNIFE_DRAW,
	KNIFE_STABHIT,
	KNIFE_STABMISS,
	KNIFE_MIDATTACK1HIT,
	KNIFE_MIDATTACK2HIT
};

enum knife_shield_e
{
	KNIFE_SHIELD_IDLE,
	KNIFE_SHIELD_SLASH,
	KNIFE_SHIELD_ATTACKHIT,
	KNIFE_SHIELD_DRAW,
	KNIFE_SHIELD_UPIDLE,
	KNIFE_SHIELD_UP,
	KNIFE_SHIELD_DOWN
};



//m3
#define M3_MAX_SPEED		230
#define M3_CONE_VECTOR		Vector(0.0675, 0.0675, 0.0)	// special shotgun spreads

enum m3_e
{
	M3_IDLE,
	M3_FIRE1,
	M3_FIRE2,
	M3_RELOAD,
	M3_PUMP,
	M3_START_RELOAD,
	M3_DRAW,
	M3_HOLSTER
};



//m4a1
#define M4A1_MAX_SPEED		230
#define M4A1_DAMAGE		32
#define M4A1_DAMAGE_SIL		33
#define M4A1_RANGE_MODIFER      0.97
#define M4A1_RANGE_MODIFER_SIL  0.95
#define M4A1_RELOAD_TIME	3.05

enum m4a1_e
{
	M4A1_IDLE,
	M4A1_SHOOT1,
	M4A1_SHOOT2,
	M4A1_SHOOT3,
	M4A1_RELOAD,
	M4A1_DRAW,
	M4A1_ATTACH_SILENCER,
	M4A1_UNSIL_IDLE,
	M4A1_UNSIL_SHOOT1,
	M4A1_UNSIL_SHOOT2,
	M4A1_UNSIL_SHOOT3,
	M4A1_UNSIL_RELOAD,
	M4A1_UNSIL_DRAW,
	M4A1_DETACH_SILENCER
};



//m249
#define M249_MAX_SPEED			220
#define M249_DAMAGE			32
#define M249_RANGE_MODIFER		0.97
#define M249_RELOAD_TIME		4.7

enum m249_e
{
	M249_IDLE1,
	M249_SHOOT1,
	M249_SHOOT2,
	M249_RELOAD,
	M249_DRAW
};



//mac10
#define MAC10_MAX_SPEED			250
#define MAC10_DAMAGE			29
#define MAC10_RANGE_MODIFER		0.82
#define MAC10_RELOAD_TIME		3.15

enum mac10_e
{
	MAC10_IDLE1,
	MAC10_RELOAD,
	MAC10_DRAW,
	MAC10_SHOOT1,
	MAC10_SHOOT2,
	MAC10_SHOOT3
};



//mp5navy
#define MP5N_MAX_SPEED			250
#define MP5N_DAMAGE			26
#define MP5N_RANGE_MODIFER		0.84
#define MP5N_RELOAD_TIME		2.63

enum mp5n_e
{
	MP5N_IDLE1,
	MP5N_RELOAD,
	MP5N_DRAW,
	MP5N_SHOOT1,
	MP5N_SHOOT2,
	MP5N_SHOOT3
};



//p90
#define P90_MAX_SPEED		245
#define P90_DAMAGE		21
#define P90_RANGE_MODIFER	0.885
#define P90_RELOAD_TIME		3.4

enum p90_e
{
	P90_IDLE1,
	P90_RELOAD,
	P90_DRAW,
	P90_SHOOT1,
	P90_SHOOT2,
	P90_SHOOT3
};



//p228
#define P228_MAX_SPEED		250
#define P228_DAMAGE		32
#define P228_RANGE_MODIFER	0.8
#define P228_RELOAD_TIME	2.7

enum p228_e
{
	P228_IDLE,
	P228_SHOOT1,
	P228_SHOOT2,
	P228_SHOOT3,
	P228_SHOOT_EMPTY,
	P228_RELOAD,
	P228_DRAW
};

enum p228_shield_e
{
	P228_SHIELD_IDLE,
	P228_SHIELD_SHOOT1,
	P228_SHIELD_SHOOT2,
	P228_SHIELD_SHOOT_EMPTY,
	P228_SHIELD_RELOAD,
	P228_SHIELD_DRAW,
	P228_SHIELD_IDLE_UP,
	P228_SHIELD_UP,
	P228_SHIELD_DOWN
};



//scout
#define SCOUT_MAX_SPEED			260
#define SCOUT_MAX_SPEED_ZOOM		220
#define SCOUT_DAMAGE			75
#define SCOUT_RANGE_MODIFER		0.98
#define SCOUT_RELOAD_TIME		2

enum scout_e
{
	SCOUT_IDLE,
	SCOUT_SHOOT,
	SCOUT_SHOOT2,
	SCOUT_RELOAD,
	SCOUT_DRAW
};



//sg550
#define SG550_MAX_SPEED			210
#define SG550_MAX_SPEED_ZOOM		150
#define SG550_DAMAGE			70
#define SG550_RANGE_MODIFER		0.98
#define SG550_RELOAD_TIME		3.35

enum sg550_e
{
	SG550_IDLE,
	SG550_SHOOT,
	SG550_SHOOT2,
	SG550_RELOAD,
	SG550_DRAW
};



//sg552
#define SG552_MAX_SPEED			235
#define SG552_MAX_SPEED_ZOOM		200
#define SG552_DAMAGE			33
#define SG552_RANGE_MODIFER		0.955
#define SG552_RELOAD_TIME		3

enum sg552_e
{
	SG552_IDLE1,
	SG552_RELOAD,
	SG552_DRAW,
	SG552_SHOOT1,
	SG552_SHOOT2,
	SG552_SHOOT3
};



//smokegrenade
#define SMOKEGRENADE_MAX_SPEED		250
#define SMOKEGRENADE_MAX_SPEED_SHIELD	180

enum smokegrenade_e
{
	SMOKEGRENADE_IDLE,
	SMOKEGRENADE_PINPULL,
	SMOKEGRENADE_THROW,
	SMOKEGRENADE_DRAW
};



//tmp
#define TMP_MAX_SPEED			250
#define TMP_DAMAGE			20
#define TMP_RANGE_MODIFER		0.85
#define TMP_RELOAD_TIME			2.12

enum tmp_e
{
	TMP_IDLE1,
	TMP_RELOAD,
	TMP_DRAW,
	TMP_SHOOT1,
	TMP_SHOOT2,
	TMP_SHOOT3
};



//ump45
#define UMP45_MAX_SPEED			250
#define UMP45_DAMAGE			30
#define UMP45_RANGE_MODIFER		0.82
#define UMP45_RELOAD_TIME		3.5

enum ump45_e
{
	UMP45_IDLE1,
	UMP45_RELOAD,
	UMP45_DRAW,
	UMP45_SHOOT1,
	UMP45_SHOOT2,
	UMP45_SHOOT3
};



//tmp
#define USP_MAX_SPEED		250
#define USP_DAMAGE		34
#define USP_DAMAGE_SIL		30
#define USP_RANGE_MODIFER	0.79
#define USP_RELOAD_TIME		2.7

enum usp_e
{
	USP_IDLE,
	USP_SHOOT1,
	USP_SHOOT2,
	USP_SHOOT3,
	USP_SHOOT_EMPTY,
	USP_RELOAD,
	USP_DRAW,
	USP_ATTACH_SILENCER,
	USP_UNSIL_IDLE,
	USP_UNSIL_SHOOT1,
	USP_UNSIL_SHOOT2,
	USP_UNSIL_SHOOT3,
	USP_UNSIL_SHOOT_EMPTY,
	USP_UNSIL_RELOAD,
	USP_UNSIL_DRAW,
	USP_DETACH_SILENCER
};

enum usp_shield_e
{
	USP_SHIELD_IDLE,
	USP_SHIELD_SHOOT1,
	USP_SHIELD_SHOOT2,
	USP_SHIELD_SHOOT_EMPTY,
	USP_SHIELD_RELOAD,
	USP_SHIELD_DRAW,
	USP_SHIELD_UP_IDLE,
	USP_SHIELD_UP,
	USP_SHIELD_DOWN
};



//xm1014
#define XM1014_MAX_SPEED	240
#define XM1014_CONE_VECTOR	Vector(0.0725, 0.0725, 0.0)	// special shotgun spreads

enum xm1014_e
{
	XM1014_IDLE,
	XM1014_FIRE1,
	XM1014_FIRE2,
	XM1014_RELOAD,
	XM1014_PUMP,
	XM1014_START_RELOAD,
	XM1014_DRAW
};

```

`dlls/wpn_shared/wpn_ak47.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_ak47, CAK47)

void CAK47::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_ak47");

	Precache();

	m_iId = WEAPON_AK47;
	SET_MODEL(edict(), "models/w_ak47.mdl");

	m_iDefaultAmmo = AK47_DEFAULT_GIVE;
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;

	FallInit();
}

void CAK47::Precache(void)
{
	PRECACHE_MODEL("models/v_ak47.mdl");
	PRECACHE_MODEL("models/w_ak47.mdl");

	PRECACHE_SOUND("weapons/ak47-1.wav");
	PRECACHE_SOUND("weapons/ak47-2.wav");
	PRECACHE_SOUND("weapons/ak47_clipout.wav");
	PRECACHE_SOUND("weapons/ak47_clipin.wav");
	PRECACHE_SOUND("weapons/ak47_boltpull.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireAK47 = PRECACHE_EVENT(1, "events/ak47.sc");
}

int CAK47::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "762Nato";
	p->iMaxAmmo1 = MAX_AMMO_762NATO;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = AK47_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 1;
	p->iId = m_iId = WEAPON_AK47;
	p->iFlags = 0;
	p->iWeight = AK47_WEIGHT;

	return 1;
}

BOOL CAK47::Deploy(void)
{
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;
	iShellOn = 1;

	return DefaultDeploy("models/v_ak47.mdl", "models/p_ak47.mdl", AK47_DRAW, "ak47", UseDecrement() != FALSE);
}

void CAK47::PrimaryAttack(void)
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		AK47Fire(0.04 + (0.4 * m_flAccuracy), 0.0955, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
	{
		AK47Fire(0.04 + (0.07 * m_flAccuracy), 0.0955, FALSE);
	}
	else
	{
		AK47Fire(0.0275 * m_flAccuracy, 0.0955, FALSE);
	}
}

void CAK47::AK47Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 200) + 0.35f;

	if (m_flAccuracy > 1.25f)
		m_flAccuracy = 1.25f;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 2, BULLET_PLAYER_762MM,
		AK47_DAMAGE, AK47_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireAK47, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.9f;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(1.5, 0.45, 0.225, 0.05, 6.5, 2.5, 7);
	}
	else if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(2.0, 1.0, 0.5, 0.35, 9.0, 6.0, 5);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.9, 0.35, 0.15, 0.025, 5.5, 1.5, 9);
	}
	else
	{
		KickBack(1.0, 0.375, 0.175, 0.0375, 5.75, 1.75, 8);
	}
}

void CAK47::Reload(void)
{
	if (m_pPlayer->ammo_762nato <= 0)
		return;

	if (DefaultReload(iMaxClip(), AK47_RELOAD, AK47_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2f;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CAK47::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle <= UTIL_WeaponTimeBase())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
		SendWeaponAnim(AK47_IDLE1, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_aug.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_aug, CAUG)

void CAUG::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_aug");

	Precache();

	m_iId = WEAPON_AUG;
	SET_MODEL(edict(), "models/w_aug.mdl");

	m_iDefaultAmmo = AUG_DEFAULT_GIVE;
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;

	FallInit();
}

void CAUG::Precache(void)
{
	PRECACHE_MODEL("models/v_aug.mdl");
	PRECACHE_MODEL("models/w_aug.mdl");

	PRECACHE_SOUND("weapons/aug-1.wav");
	PRECACHE_SOUND("weapons/aug_clipout.wav");
	PRECACHE_SOUND("weapons/aug_clipin.wav");
	PRECACHE_SOUND("weapons/aug_boltpull.wav");
	PRECACHE_SOUND("weapons/aug_boltslap.wav");
	PRECACHE_SOUND("weapons/aug_forearm.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireAug = PRECACHE_EVENT(1, "events/aug.sc");
}

int CAUG::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = MAX_AMMO_556NATO;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = AUG_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 14;
	p->iId = m_iId = WEAPON_AUG;
	p->iFlags = 0;
	p->iWeight = AUG_WEIGHT;

	return 1;
}

BOOL CAUG::Deploy(void)
{
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;
	iShellOn = 1;

	return DefaultDeploy("models/v_aug.mdl", "models/p_aug.mdl", AUG_DRAW, "carbine", UseDecrement() != FALSE);
}

void CAUG::SecondaryAttack(void)
{
	if (m_pPlayer->m_iFOV == DEFAULT_FOV)
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 55;
	else
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 90;

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3f;
}

void CAUG::PrimaryAttack(void)
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		AUGFire(0.035 + (0.4 * m_flAccuracy), 0.0825, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
	{
		AUGFire(0.035 + (0.07 * m_flAccuracy), 0.0825, FALSE);
	}
	else if (m_pPlayer->pev->fov == DEFAULT_FOV)
	{
		AUGFire(0.02 * m_flAccuracy, 0.0825, FALSE);
	}
	else
	{
		AUGFire(0.02 * m_flAccuracy, 0.135, FALSE);
	}
}

void CAUG::AUGFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 215) + 0.3f;

	if (m_flAccuracy > 1.0f)
		m_flAccuracy = 1.0f;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 2, BULLET_PLAYER_556MM,
		AUG_DAMAGE, AUG_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireAug, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.9f;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(1.0, 0.45, 0.275, 0.05, 4.0, 2.5, 7);
	}
	else if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(1.25, 0.45, 0.22, 0.18, 5.5, 4.0, 5);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.575, 0.325, 0.2, 0.011, 3.25, 2.0, 8);
	}
	else
	{
		KickBack(0.625, 0.375, 0.25, 0.0125, 3.5, 2.25, 8);
	}
}

void CAUG::Reload(void)
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(iMaxClip(), AUG_RELOAD, AUG_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		if (m_pPlayer->m_iFOV != DEFAULT_FOV)
		{
			SecondaryAttack();
		}

		m_flAccuracy = 0;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CAUG::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
	SendWeaponAnim(AUG_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_awp.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_awp, CAWP)

void CAWP::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_awp");

	Precache();

	m_iId = WEAPON_AWP;
	SET_MODEL(ENT(pev), "models/w_awp.mdl");

	m_iDefaultAmmo = AWP_DEFAULT_GIVE;
	FallInit();
}

void CAWP::Precache(void)
{
	PRECACHE_MODEL("models/v_awp.mdl");
	PRECACHE_MODEL("models/w_awp.mdl");

	PRECACHE_SOUND("weapons/awp1.wav");
	PRECACHE_SOUND("weapons/boltpull1.wav");
	PRECACHE_SOUND("weapons/boltup.wav");
	PRECACHE_SOUND("weapons/boltdown.wav");
	PRECACHE_SOUND("weapons/zoom.wav");
	PRECACHE_SOUND("weapons/awp_deploy.wav");
	PRECACHE_SOUND("weapons/awp_clipin.wav");
	PRECACHE_SOUND("weapons/awp_clipout.wav");

	m_iShell = PRECACHE_MODEL("models/rshell_big.mdl");
	m_iShellId = m_iShell;
	m_usFireAWP = PRECACHE_EVENT(1, "events/awp.sc");
}

int CAWP::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "338Magnum";
	p->iMaxAmmo1 = MAX_AMMO_338MAGNUM;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = AWP_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 2;
	p->iId = m_iId = WEAPON_AWP;
	p->iFlags = 0;
	p->iWeight = AWP_WEIGHT;

	return 1;
}

BOOL CAWP::Deploy(void)
{
	if (DefaultDeploy("models/v_awp.mdl", "models/p_awp.mdl", AWP_DRAW, "rifle", UseDecrement() != FALSE))
	{
		m_pPlayer->m_flNextAttack = GetNextAttackDelay(1.45);
		m_flNextPrimaryAttack = m_pPlayer->m_flNextAttack;
		m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.0f;

		return TRUE;
	}

	return FALSE;
}

void CAWP::SecondaryAttack(void)
{
	switch (m_pPlayer->m_iFOV)
	{
	case 90: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 40; break;
	case 40: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 10; break;
	default: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 90; break;
	}

#ifndef CLIENT_DLL
	if (TheBots != NULL)
	{
		TheBots->OnEvent(EVENT_WEAPON_ZOOMED, m_pPlayer);
	}
#endif

	m_pPlayer->ResetMaxSpeed();
	EMIT_SOUND(m_pPlayer->edict(), CHAN_ITEM, "weapons/zoom.wav", 0.2, 2.4);

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CAWP::PrimaryAttack(void)
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		AWPFire(0.85, 1.45, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
	{
		AWPFire(0.25, 1.45, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 10)
	{
		AWPFire(0.1, 1.45, FALSE);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		AWPFire(0.0, 1.45, FALSE);
	}
	else
	{
		AWPFire(0.001, 1.45, FALSE);
	}
}

void CAWP::AWPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	if (m_pPlayer->pev->fov != DEFAULT_FOV)
	{
		m_pPlayer->m_bResumeZoom = true;
		m_pPlayer->m_iLastZoom = m_pPlayer->m_iFOV;

		// reset a fov
		m_pPlayer->m_iFOV = DEFAULT_FOV;
		m_pPlayer->pev->fov = DEFAULT_FOV;
	}
	// If we are not zoomed in, the bullet diverts more.
	else
	{
		flSpread += 0.08f;
	}

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_flEjectBrass = gpGlobals->time + 0.55f;
	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = NORMAL_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 3, BULLET_PLAYER_338MAG, AWP_DAMAGE, AWP_RANGE_MODIFER, m_pPlayer->pev, true, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireAWP, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.x * 100), FALSE, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;
	m_pPlayer->pev->punchangle.x -= 2.0f;
}

void CAWP::Reload(void)
{
	if (m_pPlayer->ammo_338mag <= 0)
		return;

	if (DefaultReload(iMaxClip(), AWP_RELOAD, AWP_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		if (m_pPlayer->pev->fov != DEFAULT_FOV)
		{
			m_pPlayer->m_iFOV = 10;
			m_pPlayer->pev->fov = 10;

			SecondaryAttack();
		}
	}
}

void CAWP::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle <= UTIL_WeaponTimeBase() && m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60.0f;
		SendWeaponAnim(AWP_IDLE, UseDecrement() != FALSE);
	}
}

float CAWP::GetMaxSpeed(void)
{
	if (m_pPlayer->m_iFOV == DEFAULT_FOV)
		return AWP_MAX_SPEED;

	// Slower speed when zoomed in.
	return AWP_MAX_SPEED_ZOOM;
}

```

`dlls/wpn_shared/wpn_c4.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"
#include "hltv.h"
#include "gamerules.h"

//#define C4MADNESS
#ifdef CLIENT_WEAPONS
extern bool g_bInBombZone;
#endif

LINK_ENTITY_TO_CLASS(weapon_c4, CC4)

void CC4::Spawn(void)
{
	SET_MODEL(ENT(pev), "models/w_backpack.mdl");

	pev->frame = 0;
	pev->body = 3;
	pev->sequence = 0;
	pev->framerate = 0;

	m_iId = WEAPON_C4;
	m_iDefaultAmmo = C4_DEFAULT_GIVE;
	m_bStartedArming = false;
	m_fArmedTime = 0;

	if (!FStringNull(pev->targetname))
	{
		pev->effects |= EF_NODRAW;
		DROP_TO_FLOOR(edict());
		return;
	}

	FallInit();
	SetThink(&CBasePlayerItem::FallThink);
	pev->nextthink = UTIL_WeaponTimeBase() + 0.1f;
}

void CC4::Precache(void)
{
	PRECACHE_MODEL("models/v_c4.mdl");
	PRECACHE_MODEL("models/w_backpack.mdl");

	PRECACHE_SOUND("weapons/c4_click.wav");
}

int CC4::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "C4";
	p->iMaxAmmo1 = C4_MAX_AMMO;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = WEAPON_NOCLIP;
	p->iSlot = 4;
	p->iPosition = 3;
	p->iId = m_iId = WEAPON_C4;
	p->iWeight = C4_WEIGHT;
	p->iFlags = ITEM_FLAG_LIMITINWORLD | ITEM_FLAG_EXHAUSTIBLE;

	return 1;
}

BOOL CC4::Deploy(void)
{
	pev->body = 0;

	m_bStartedArming = false;
	m_fArmedTime = 0;

	if (m_pPlayer->HasShield())
	{
		m_bHasShield = true;
		m_pPlayer->pev->gamestate = 1;
	}

	return DefaultDeploy("models/v_c4.mdl", "models/p_c4.mdl", C4_DRAW, "c4", UseDecrement() != FALSE);
}

void CC4::Holster(int skiplocal)
{
	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.5f;
	m_bStartedArming = false;	// stop arming sequence

	if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		m_pPlayer->pev->weapons &= ~(1 << WEAPON_C4);
		DestroyItem();
	}

	if (m_bHasShield)
	{
		m_pPlayer->pev->gamestate = 0;
		m_bHasShield = false;
	}
}

void CC4::PrimaryAttack(void)
{
	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		return;

	int inBombZone = (m_pPlayer->m_signals.GetState() & SIGNAL_BOMB) == SIGNAL_BOMB;
	int onGround = (m_pPlayer->pev->flags & FL_ONGROUND) == FL_ONGROUND;
	bool bPlaceBomb = (onGround && inBombZone);

	if (!m_bStartedArming)
	{
		if (!inBombZone)
		{
			ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#C4_Plant_At_Bomb_Spot");
			m_flNextPrimaryAttack = GetNextAttackDelay(1.0);
			return;
		}

		if (!onGround)
		{
			ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#C4_Plant_Must_Be_On_Ground");
			m_flNextPrimaryAttack = GetNextAttackDelay(1.0);
			return;
		}

		m_bStartedArming = true;
		m_bBombPlacedAnimation = false;
		m_fArmedTime = gpGlobals->time + C4_ARMING_ON_TIME;

		// player "arming bomb" animation
		SendWeaponAnim(C4_ARM, UseDecrement() != FALSE);

#ifndef CLIENT_DLL
		// freeze the player in place while planting
		SET_CLIENT_MAXSPEED(m_pPlayer->edict(), 1.0);
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
		m_pPlayer->SetProgressBarTime(C4_ARMING_ON_TIME);
#endif
	}
	else
	{
		if (bPlaceBomb)
		{
#ifndef CLIENT_DLL
			CBaseEntity *pEntity = NULL;
			CBasePlayer *pTempPlayer = NULL;
#endif

			if (m_fArmedTime <= gpGlobals->time)
			{
				if (m_bStartedArming)
				{
					m_bStartedArming = false;
					m_fArmedTime = 0;

					Broadcast("BOMBPL");
					m_pPlayer->m_bHasC4 = false;

#ifndef CLIENT_DLL
					if (pev->speed != 0 && CSGameRules())
					{
						CSGameRules()->m_iC4Timer = int(pev->speed);
					}
#endif

#ifndef CLIENT_DLL
					CGrenade *pBomb = CGrenade::ShootSatchelCharge(m_pPlayer->pev, m_pPlayer->pev->origin, Vector(0, 0, 0));

					MESSAGE_BEGIN(MSG_SPEC, SVC_DIRECTOR);
						WRITE_BYTE(9);
						WRITE_BYTE(DRC_CMD_EVENT);
						WRITE_SHORT(m_pPlayer->entindex());
						WRITE_SHORT(0);
						WRITE_LONG(DRC_FLAG_FACEPLAYER | 11);
					MESSAGE_END();

					MESSAGE_BEGIN(MSG_ALL, gmsgBombDrop);
						WRITE_COORD(pBomb->pev->origin.x);
						WRITE_COORD(pBomb->pev->origin.y);
						WRITE_COORD(pBomb->pev->origin.z);
						WRITE_BYTE(BOMB_FLAG_PLANTED);
					MESSAGE_END();

					UTIL_ClientPrintAll(HUD_PRINTCENTER, "#Bomb_Planted");

					if (TheBots)
					{
						TheBots->OnEvent(EVENT_BOMB_PLANTED, m_pPlayer, pBomb);
					}

					if (TheCareerTasks && CSGameRules()->IsCareer() && !m_pPlayer->IsBot())
					{
						TheCareerTasks->HandleEvent(EVENT_BOMB_PLANTED, m_pPlayer);
					}
					UTIL_LogPrintf("\"%s<%i><%s><TERRORIST>\" triggered \"Planted_The_Bomb\"\n",
						STRING(m_pPlayer->pev->netname),
						GETPLAYERUSERID(m_pPlayer->edict()),
						GETPLAYERAUTHID(m_pPlayer->edict()));


					g_pGameRules->m_bBombDropped = FALSE;
#endif

					// Play the plant sound.
					EMIT_SOUND(edict(), CHAN_WEAPON, "weapons/c4_plant.wav", VOL_NORM, ATTN_NORM);

					// hide the backpack in Terrorist's models.
					m_pPlayer->pev->body = 0;

					// release the player from being frozen
					m_pPlayer->ResetMaxSpeed();

#ifndef CLIENT_DLL
					// No more c4!
					m_pPlayer->SetBombIcon(FALSE);
#endif
					if (--m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
					{
						RetireWeapon();
						return;
					}
				}
			}
			else
			{
				if (m_fArmedTime - 0.75f <= gpGlobals->time && !m_bBombPlacedAnimation)
				{
					// call the c4 Placement animation
					m_bBombPlacedAnimation = true;
					SendWeaponAnim(C4_DROP, UseDecrement() != FALSE);

#ifndef CLIENT_DLL
					// player "place" animation
					m_pPlayer->SetAnimation(PLAYER_HOLDBOMB);
#endif
				}
			}
		}
		else
		{
			if (inBombZone)
				ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#C4_Plant_Must_Be_On_Ground");
			else
				ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#C4_Arming_Cancelled");

			m_bStartedArming = false;
			m_flNextPrimaryAttack = GetNextAttackDelay(1.5);

			// release the player from being frozen, we've somehow left the bomb zone
			m_pPlayer->ResetMaxSpeed();
#ifndef CLIENT_DLL
			m_pPlayer->SetProgressBarTime(0);
			m_pPlayer->SetAnimation(PLAYER_HOLDBOMB);
#endif
			// this means the placement animation is canceled
			if (m_bBombPlacedAnimation)
				SendWeaponAnim(C4_DRAW, UseDecrement() != FALSE);
			else
				SendWeaponAnim(C4_IDLE1, UseDecrement() != FALSE);

			return;
		}
	}

	m_flNextPrimaryAttack = GetNextAttackDelay(0.3);
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
}

void CC4::WeaponIdle(void)
{
	if (m_bStartedArming)
	{
		// if the player releases the attack button cancel the arming sequence
		m_bStartedArming = false;

		// release the player from being frozen
		m_pPlayer->ResetMaxSpeed();

		m_flNextPrimaryAttack = GetNextAttackDelay(1.0);
#ifndef CLIENT_DLL
		m_pPlayer->SetProgressBarTime(0);
#endif
		// this means the placement animation is canceled
		if (m_bBombPlacedAnimation)
			SendWeaponAnim(C4_DRAW, UseDecrement() != FALSE);
		else
			SendWeaponAnim(C4_IDLE1, UseDecrement() != FALSE);
	}

	if (m_flTimeWeaponIdle <= UTIL_WeaponTimeBase())
	{
		if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		{
			RetireWeapon();
			return;
		}

		SendWeaponAnim(C4_DRAW, UseDecrement() != FALSE);
		SendWeaponAnim(C4_IDLE1, UseDecrement() != FALSE);
	}
}

void CC4::KeyValue(KeyValueData *pkvd)
{
	if (FStrEq(pkvd->szKeyName, "detonatedelay"))
	{
		pev->speed = atof(pkvd->szValue);
		pkvd->fHandled = TRUE;
	}
	else if (FStrEq(pkvd->szKeyName, "detonatetarget"))
	{
		pev->noise1 = ALLOC_STRING(pkvd->szValue);
		pkvd->fHandled = TRUE;
	}
	else if (FStrEq(pkvd->szKeyName, "defusetarget"))
	{
		pev->target = ALLOC_STRING(pkvd->szValue);
		pkvd->fHandled = TRUE;
	}
	else
	{
		CBaseEntity::KeyValue(pkvd);
	}
}

void CC4::Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value)
{
	if (m_pPlayer)
		return;

	CBasePlayer *pPlayer = UTIL_PlayerByIndex(1);
	if (pPlayer)
	{
		edict_t *m_pentOldCurBombTarget = pPlayer->m_pentCurBombTarget;
		pPlayer->m_pentCurBombTarget = NULL;

#ifndef CLIENT_DLL
		if (pev->speed != 0 && CSGameRules())
		{
			CSGameRules()->m_iC4Timer = int(pev->speed);
		}
#endif

		EMIT_SOUND(edict(), CHAN_WEAPON, "weapons/c4_plant.wav", VOL_NORM, ATTN_NORM);

		CGrenade::ShootSatchelCharge(m_pPlayer->pev, m_pPlayer->pev->origin, Vector(0, 0, 0));

		CGrenade *pC4 = NULL;
		while ((pC4 = (CGrenade *)UTIL_FindEntityByClassname(pC4, "grenade")))
		{
			if (pC4->m_bIsC4 && pC4->m_flNextFreq == gpGlobals->time)
			{
				pC4->pev->target = pev->target;
				pC4->pev->noise1 = pev->noise1;
				break;
			}
		}

		pPlayer->m_pentCurBombTarget = m_pentOldCurBombTarget;
		SUB_Remove();
	}
}

```

`dlls/wpn_shared/wpn_deagle.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_deagle, CDEAGLE)

void CDEAGLE::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_deagle");

	Precache();

	m_iId = WEAPON_DEAGLE;
	SET_MODEL(edict(), "models/w_deagle.mdl");

	m_iDefaultAmmo = DEAGLE_DEFAULT_GIVE;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_fMaxSpeed = DEAGLE_MAX_SPEED;
	m_flAccuracy = 0.9f;

	FallInit();
}

void CDEAGLE::Precache(void)
{
	PRECACHE_MODEL("models/v_deagle.mdl");
	PRECACHE_MODEL("models/shield/v_shield_deagle.mdl");
	PRECACHE_MODEL("models/w_deagle.mdl");

	PRECACHE_SOUND("weapons/deagle-1.wav");
	PRECACHE_SOUND("weapons/deagle-2.wav");
	PRECACHE_SOUND("weapons/de_clipout.wav");
	PRECACHE_SOUND("weapons/de_clipin.wav");
	PRECACHE_SOUND("weapons/de_deploy.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireDeagle = PRECACHE_EVENT(1, "events/deagle.sc");
}

int CDEAGLE::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "50AE";
	p->iMaxAmmo1 = MAX_AMMO_50AE;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = DEAGLE_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 1;
	p->iId = m_iId = WEAPON_DEAGLE;
	p->iFlags = 0;
	p->iWeight = DEAGLE_WEIGHT;

	return 1;
}

BOOL CDEAGLE::Deploy(void)
{
	m_flAccuracy = 0.9f;
	m_fMaxSpeed = DEAGLE_MAX_SPEED;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield())
		return DefaultDeploy("models/shield/v_shield_deagle.mdl", "models/shield/p_shield_deagle.mdl", DEAGLE_DRAW, "shieldgun", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_deagle.mdl", "models/p_deagle.mdl", DEAGLE_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CDEAGLE::PrimaryAttack(void)
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		DEAGLEFire(1.5 * (1 - m_flAccuracy), 0.3, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		DEAGLEFire(0.25 * (1 - m_flAccuracy), 0.3, FALSE);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		DEAGLEFire(0.115 * (1 - m_flAccuracy), 0.3, FALSE);
	}
	else
	{
		DEAGLEFire(0.13 * (1 - m_flAccuracy), 0.3, FALSE);
	}
}

void CDEAGLE::SecondaryAttack(void)
{
	ShieldSecondaryFire(SHIELDGUN_UP, SHIELDGUN_DOWN);
}

void CDEAGLE::DEAGLEFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	flCycleTime -= 0.075f;

	if (++m_iShotsFired > 1)
	{
		return;
	}

	if (m_flLastFire != 0.0)
	{
		m_flAccuracy -= (0.4f - (gpGlobals->time - m_flLastFire)) * 0.35f;

		if (m_flAccuracy > 0.9f)
		{
			m_flAccuracy = 0.9f;
		}
		else if (m_flAccuracy < 0.55f)
		{
			m_flAccuracy = 0.55f;
		}
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	SetPlayerShieldAnim();

#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = NORMAL_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 4096, 2, BULLET_PLAYER_50AE, DEAGLE_DAMAGE, DEAGLE_RANGE_MODIFER, m_pPlayer->pev, true, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireDeagle, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), m_iClip == 0, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, FALSE);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.8f;
	m_pPlayer->pev->punchangle.x -= 2;
	ResetPlayerShieldAnim();
}

void CDEAGLE::Reload(void)
{
	if (m_pPlayer->ammo_50ae <= 0)
		return;

	if (DefaultReload(iMaxClip(), DEAGLE_RELOAD, DEAGLE_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.9f;
	}
}

void CDEAGLE::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle <= UTIL_WeaponTimeBase())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;

		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		{
			SendWeaponAnim(SHIELDGUN_DRAWN_IDLE, UseDecrement() != FALSE);
		}
	}
}

```

`dlls/wpn_shared/wpn_elite.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_elite, CELITE)

void CELITE::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_elite");

	Precache();

	m_iId = WEAPON_ELITE;
	SET_MODEL(edict(), "models/w_elite.mdl");

	m_iDefaultAmmo = ELITE_DEFAULT_GIVE;
	m_flAccuracy = 0.88f;

	FallInit();
}

void CELITE::Precache(void)
{
	PRECACHE_MODEL("models/v_elite.mdl");
	PRECACHE_MODEL("models/w_elite.mdl");

	PRECACHE_SOUND("weapons/elite_fire.wav");
	PRECACHE_SOUND("weapons/elite_reloadstart.wav");
	PRECACHE_SOUND("weapons/elite_leftclipin.wav");
	PRECACHE_SOUND("weapons/elite_clipout.wav");
	PRECACHE_SOUND("weapons/elite_sliderelease.wav");
	PRECACHE_SOUND("weapons/elite_rightclipin.wav");
	PRECACHE_SOUND("weapons/elite_deploy.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");

	m_usFireELITE_LEFT = PRECACHE_EVENT(1, "events/elite_left.sc");
	m_usFireELITE_RIGHT = PRECACHE_EVENT(1, "events/elite_right.sc");
}

int CELITE::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "9mm";
	p->iMaxAmmo1 = MAX_AMMO_9MM;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = ELITE_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 5;
	p->iId = m_iId = WEAPON_ELITE;
	p->iFlags = 0;
	p->iWeight = ELITE_WEIGHT;

	return 1;
}

BOOL CELITE::Deploy(void)
{
	m_flAccuracy = 0.88f;

	if (!(m_iClip & 1))
	{
		m_iWeaponState |= WPNSTATE_ELITE_LEFT;
	}

	return DefaultDeploy("models/v_elite.mdl", "models/p_elite.mdl", ELITE_DRAW, "dualpistols", UseDecrement() != FALSE);
}

void CELITE::PrimaryAttack(void)
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		ELITEFire(1.3 * (1 - m_flAccuracy), 0.2, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		ELITEFire(0.175 * (1 - m_flAccuracy), 0.2, FALSE);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		ELITEFire(0.08 * (1 - m_flAccuracy), 0.2, FALSE);
	}
	else
	{
		ELITEFire(0.1 * (1 - m_flAccuracy), 0.2, FALSE);
	}
}

void CELITE::ELITEFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	float flTimeDiff;
	int flag;
	Vector vecAiming;
	Vector vecSrc;
	Vector vecDir;

#ifdef REGAMEDLL_FIXES
	flCycleTime -= 0.078f;
#else
	flCycleTime -= 0.125f;
#endif

	if (++m_iShotsFired > 1)
	{
		return;
	}

	flTimeDiff = gpGlobals->time - m_flLastFire;

	if (m_flLastFire)
	{
		m_flAccuracy -= (0.325f - flTimeDiff) * 0.275f;

		if (m_flAccuracy > 0.88f)
		{
			m_flAccuracy = 0.88f;
		}
		else if (m_flAccuracy < 0.55f)
		{
			m_flAccuracy = 0.55f;
		}
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

	--m_iClip;
	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	if (m_iWeaponState & WPNSTATE_ELITE_LEFT)
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		m_iWeaponState &= ~WPNSTATE_ELITE_LEFT;

		vecDir = m_pPlayer->FireBullets3(vecSrc - gpGlobals->v_right * 5, vecAiming, flSpread,
			8192, BULLET_PLAYER_9MM, 1, ELITE_DAMAGE, ELITE_RANGE_MODIFER, m_pPlayer->pev, true, m_pPlayer->random_seed);

		PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireELITE_LEFT, 0, (float *)&g_vecZero, (float *)&g_vecZero, flTimeDiff, vecDir.x,
			int(vecDir.y * 100), m_iClip, FALSE, FALSE);
	}
	else
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_ATTACK2);
#endif
		m_iWeaponState |= WPNSTATE_ELITE_LEFT;

		vecDir = m_pPlayer->FireBullets3(vecSrc + gpGlobals->v_right * 5, vecAiming, flSpread,
			8192, BULLET_PLAYER_9MM, 1, ELITE_DAMAGE, ELITE_RANGE_MODIFER, m_pPlayer->pev, true, m_pPlayer->random_seed);

		PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireELITE_RIGHT, 0, (float *)&g_vecZero, (float *)&g_vecZero, flTimeDiff, vecDir.x,
			int(vecDir.y * 100), m_iClip, FALSE, FALSE);
	}

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;
	m_pPlayer->pev->punchangle.x -= 2.0f;
}

void CELITE::Reload(void)
{
	if (m_pPlayer->ammo_9mm <= 0)
		return;

	if (DefaultReload(iMaxClip(), ELITE_RELOAD, ELITE_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.88f;
	}
}

void CELITE::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle <= UTIL_WeaponTimeBase())
	{
		if (m_iClip)
		{
			int iAnim = (m_iClip == 1) ? ELITE_IDLE_LEFTEMPTY : ELITE_IDLE;
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60.0f;
			SendWeaponAnim(iAnim, UseDecrement() != FALSE);
		}
	}
}

```

`dlls/wpn_shared/wpn_famas.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_famas, CFamas)

void CFamas::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_famas");

	Precache();

	m_iId = WEAPON_FAMAS;
	SET_MODEL(ENT(pev), "models/w_famas.mdl");

	m_iDefaultAmmo = FAMAS_DEFAULT_GIVE;
	m_iFamasShotsFired = 0;
	m_flFamasShoot = 0;

	FallInit();
}

void CFamas::Precache(void)
{
	PRECACHE_MODEL("models/v_famas.mdl");
	PRECACHE_MODEL("models/w_famas.mdl");

	PRECACHE_SOUND("weapons/famas-1.wav");
	PRECACHE_SOUND("weapons/famas-2.wav");
	PRECACHE_SOUND("weapons/famas_clipout.wav");
	PRECACHE_SOUND("weapons/famas_clipin.wav");
	PRECACHE_SOUND("weapons/famas_boltpull.wav");
	PRECACHE_SOUND("weapons/famas_boltslap.wav");
	PRECACHE_SOUND("weapons/famas_forearm.wav");
	PRECACHE_SOUND("weapons/famas-burst.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireFamas = PRECACHE_EVENT(1, "events/famas.sc");
}

int CFamas::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = MAX_AMMO_556NATO;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = FAMAS_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 18;
	p->iId = m_iId = WEAPON_FAMAS;
	p->iFlags = 0;
	p->iWeight = FAMAS_WEIGHT;

	return 1;
}

BOOL CFamas::Deploy(void)
{
	m_iShotsFired = 0;
	m_iFamasShotsFired = 0;
	m_flFamasShoot = 0;
	m_flAccuracy = 0.2f;

	iShellOn = 1;

	return DefaultDeploy("models/v_famas.mdl", "models/p_famas.mdl", FAMAS_DRAW, "carbine", UseDecrement() != FALSE);
}

void CFamas::SecondaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_FAMAS_BURST_MODE)
	{
		ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#Switch_To_FullAuto");
		m_iWeaponState &= ~WPNSTATE_FAMAS_BURST_MODE;
	}
	else
	{
		ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#Switch_To_BurstFire");
		m_iWeaponState |= WPNSTATE_FAMAS_BURST_MODE;
	}

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3f;
}

void CFamas::PrimaryAttack(void)
{
	if (m_pPlayer->pev->waterlevel == 3)
	{
		PlayEmptySound();
		m_flNextPrimaryAttack = GetNextAttackDelay(0.15);
		return;
	}

	bool bFireBurst = (m_iWeaponState & WPNSTATE_FAMAS_BURST_MODE) == WPNSTATE_FAMAS_BURST_MODE;

	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		FamasFire(0.030 + 0.3 * m_flAccuracy, 0.0825, FALSE, bFireBurst);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
	{
		FamasFire(0.030 + 0.07 * m_flAccuracy, 0.0825, FALSE, bFireBurst);
	}
	else
	{
		FamasFire(0.02 * m_flAccuracy, 0.0825, FALSE, bFireBurst);
	}
}

void CFamas::FamasFire(float flSpread, float flCycleTime, BOOL fUseAutoAim, BOOL bFireBurst)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	if (bFireBurst)
	{
		m_iFamasShotsFired = 0;
		flCycleTime = 0.55f;
	}
	else
	{
		flSpread += 0.01f;
	}

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = (m_iShotsFired * m_iShotsFired * m_iShotsFired / 215) + 0.3f;

	if (m_flAccuracy > 1.0f)
		m_flAccuracy = 1.0f;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 2, BULLET_PLAYER_556MM,
		bFireBurst ? FAMAS_DAMAGE_BURST : FAMAS_DAMAGE, FAMAS_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireFamas, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 10000000), int(m_pPlayer->pev->punchangle.y * 10000000), FALSE, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.1f;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(1.0, 0.45, 0.275, 0.05, 4.0, 2.5, 7);
	}
	else if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(1.25, 0.45, 0.22, 0.18, 5.5, 4.0, 5);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.575, 0.325, 0.2, 0.011, 3.25, 2.0, 8);
	}
	else
	{
		KickBack(0.625, 0.375, 0.25, 0.0125, 3.5, 2.25, 8);
	}

	if (bFireBurst)
	{
		++m_iFamasShotsFired;
		m_fBurstSpread = flSpread;
		m_flFamasShoot = gpGlobals->time + 0.05f;
	}
}

void CFamas::Reload(void)
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(iMaxClip(), FAMAS_RELOAD, FAMAS_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		if (m_pPlayer->m_iFOV != DEFAULT_FOV)
		{
			SecondaryAttack();
		}

		m_flAccuracy = 0;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CFamas::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle <= UTIL_WeaponTimeBase())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
		SendWeaponAnim(FAMAS_IDLE1, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_fiveseven.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_fiveseven, CFiveSeven)

void CFiveSeven::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_fiveseven");

	Precache();

	m_iId = WEAPON_FIVESEVEN;
	SET_MODEL(edict(), "models/w_fiveseven.mdl");

	m_iDefaultAmmo = FIVESEVEN_DEFAULT_GIVE;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_flAccuracy = 0.92f;

	FallInit();
}

void CFiveSeven::Precache(void)
{
	PRECACHE_MODEL("models/v_fiveseven.mdl");
	PRECACHE_MODEL("models/w_fiveseven.mdl");
	PRECACHE_MODEL("models/shield/v_shield_fiveseven.mdl");

	PRECACHE_SOUND("weapons/fiveseven-1.wav");
	PRECACHE_SOUND("weapons/fiveseven_clipout.wav");
	PRECACHE_SOUND("weapons/fiveseven_clipin.wav");
	PRECACHE_SOUND("weapons/fiveseven_sliderelease.wav");
	PRECACHE_SOUND("weapons/fiveseven_slidepull.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireFiveSeven = PRECACHE_EVENT(1, "events/fiveseven.sc");
}

int CFiveSeven::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "57mm";
	p->iMaxAmmo1 = MAX_AMMO_57MM;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = FIVESEVEN_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 6;
	p->iId = m_iId = WEAPON_FIVESEVEN;
	p->iFlags = 0;
	p->iWeight = FIVESEVEN_WEIGHT;

	return 1;
}

BOOL CFiveSeven::Deploy(void)
{
	m_flAccuracy = 0.92f;
	m_fMaxSpeed = FIVESEVEN_MAX_SPEED;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield())
		return DefaultDeploy("models/shield/v_shield_fiveseven.mdl", "models/shield/p_shield_fiveseven.mdl", FIVESEVEN_DRAW, "shieldgun", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_fiveseven.mdl", "models/p_fiveseven.mdl", FIVESEVEN_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CFiveSeven::PrimaryAttack(void)
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		FiveSevenFire(1.5 * (1 - m_flAccuracy), 0.2, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		FiveSevenFire(0.255 * (1 - m_flAccuracy), 0.2, FALSE);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		FiveSevenFire(0.075 * (1 - m_flAccuracy), 0.2, FALSE);
	}
	else
	{
		FiveSevenFire(0.15 * (1 - m_flAccuracy), 0.2, FALSE);
	}
}

void CFiveSeven::SecondaryAttack(void)
{
	ShieldSecondaryFire(SHIELDGUN_UP, SHIELDGUN_DOWN);
}

void CFiveSeven::FiveSevenFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	flCycleTime -= 0.05;

	if (++m_iShotsFired > 1)
	{
		return;
	}

	if (m_flLastFire != 0.0f)
	{
		m_flAccuracy -= (0.275f - (gpGlobals->time - m_flLastFire)) * 0.25f;

		if (m_flAccuracy > 0.92f)
		{
			m_flAccuracy = 0.92f;
		}
		else if (m_flAccuracy < 0.725f)
		{
			m_flAccuracy = 0.725f;
		}
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	SetPlayerShieldAnim();

#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 4096, 1, BULLET_PLAYER_57MM, FIVESEVEN_DAMAGE, FIVESEVEN_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireFiveSeven, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), m_iClip == 0, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, FALSE);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;
	m_pPlayer->pev->punchangle.x -= 2.0f;
	ResetPlayerShieldAnim();
}

void CFiveSeven::Reload(void)
{
	if (m_pPlayer->ammo_57mm <= 0)
		return;

	if (DefaultReload(iMaxClip(), FIVESEVEN_RELOAD, FIVESEVEN_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.92f;
	}
}

void CFiveSeven::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	if (m_pPlayer->HasShield())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;

		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		{
			SendWeaponAnim(SHIELDGUN_DRAWN_IDLE, UseDecrement() != FALSE);
		}
	}
	else if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 3.0625f;
		SendWeaponAnim(FIVESEVEN_IDLE, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_flashbang.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_flashbang, CFlashbang)

void CFlashbang::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_flashbang");

	Precache();

	m_iId = WEAPON_FLASHBANG;
	SET_MODEL(edict(), "models/w_flashbang.mdl");

	pev->dmg = 4;

	m_iDefaultAmmo = FLASHBANG_DEFAULT_GIVE;
	m_flStartThrow = 0;
	m_flReleaseThrow = -1.0f;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	// get ready to fall down.
	FallInit();
}

void CFlashbang::Precache(void)
{
	PRECACHE_MODEL("models/v_flashbang.mdl");
	PRECACHE_MODEL("models/shield/v_shield_flashbang.mdl");

	PRECACHE_SOUND("weapons/flashbang-1.wav");
	PRECACHE_SOUND("weapons/flashbang-2.wav");
	PRECACHE_SOUND("weapons/pinpull.wav");
}

int CFlashbang::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "Flashbang";

	p->iMaxAmmo1 = MAX_AMMO_FLASHBANG;
	p->iMaxClip = WEAPON_NOCLIP;

	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iSlot = 3;
	p->iPosition = 2;
	p->iId = m_iId = WEAPON_FLASHBANG;
	p->iWeight = FLASHBANG_WEIGHT;
	p->iFlags = ITEM_FLAG_LIMITINWORLD | ITEM_FLAG_EXHAUSTIBLE;

	return 1;
}

BOOL CFlashbang::Deploy(void)
{
	m_flReleaseThrow = -1.0f;
	m_fMaxSpeed = FLASHBANG_MAX_SPEED;

	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield())
		return DefaultDeploy("models/shield/v_shield_flashbang.mdl", "models/shield/p_shield_flashbang.mdl", FLASHBANG_DRAW, "shieldgren", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_flashbang.mdl", "models/p_flashbang.mdl", FLASHBANG_DRAW, "grenade", UseDecrement() != FALSE);
}

void CFlashbang::Holster(int skiplocal)
{
	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.5f;

	if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		m_pPlayer->pev->weapons &= ~(1 << WEAPON_FLASHBANG);
		DestroyItem();
	}

	m_flStartThrow = 0;
	m_flReleaseThrow = -1.0f;
}

void CFlashbang::PrimaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		return;
	}

	if (!m_flStartThrow && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] > 0)
	{
		m_flReleaseThrow = 0;
		m_flStartThrow = gpGlobals->time;

		SendWeaponAnim(FLASHBANG_PULLPIN, UseDecrement() != FALSE);
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.5f;
	}}

void CFlashbang::SetPlayerShieldAnim(void)
{
	if (!m_pPlayer->HasShield())
		return;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		strcpy(m_pPlayer->m_szAnimExtention, "shield");
	else
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
}

void CFlashbang::ResetPlayerShieldAnim(void)
{
	if (!m_pPlayer->HasShield())
		return;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
	}
}

bool CFlashbang::ShieldSecondaryFire(int iUpAnim, int iDownAnim)
{
	if (!m_pPlayer->HasShield() || m_flStartThrow > 0)
	{
		return false;
	}

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(iDownAnim, UseDecrement() != FALSE);

		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");

		m_fMaxSpeed = FLASHBANG_MAX_SPEED;
		m_pPlayer->m_bShieldDrawn = false;
	}
	else
	{
		m_iWeaponState |= WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(iUpAnim, UseDecrement() != FALSE);

		strcpy(m_pPlayer->m_szAnimExtention, "shielded");

		m_fMaxSpeed = FLASHBANG_MAX_SPEED_SHIELD;
		m_pPlayer->m_bShieldDrawn = true;
	}

#ifndef CLIENT_DLL
	m_pPlayer->UpdateShieldCrosshair((m_iWeaponState & WPNSTATE_SHIELD_DRAWN) != WPNSTATE_SHIELD_DRAWN);
#endif
	m_pPlayer->ResetMaxSpeed();

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.4f;
	m_flNextPrimaryAttack = GetNextAttackDelay(0.4);
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.6f;

	return true;
}

void CFlashbang::SecondaryAttack(void)
{
	ShieldSecondaryFire(SHIELDGUN_DRAW, SHIELDGUN_DRAWN_IDLE);
}

void CFlashbang::WeaponIdle(void)
{
	if (m_flReleaseThrow == 0 && m_flStartThrow != 0.0f)
		m_flReleaseThrow = gpGlobals->time;

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_flStartThrow)
	{
		m_pPlayer->Radio("%!MRAD_FIREINHOLE", "#Fire_in_the_hole");

		Vector angThrow = m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle;

		if (angThrow.x < 0)
			angThrow.x = -10 + angThrow.x * ((90 - 10) / 90.0);
		else
			angThrow.x = -10 + angThrow.x * ((90 + 10) / 90.0);

		float flVel = (90.0f - angThrow.x) * 6.0f;

		if (flVel > 750.0f)
			flVel = 750.0f;

		UTIL_MakeVectors(angThrow);

		Vector vecSrc = m_pPlayer->pev->origin + m_pPlayer->pev->view_ofs + gpGlobals->v_forward * 16;
		Vector vecThrow = gpGlobals->v_forward * flVel + m_pPlayer->pev->velocity;

		CGrenade::ShootTimed(m_pPlayer->pev, vecSrc, vecThrow, 1.5);

		SendWeaponAnim(FLASHBANG_THROW, UseDecrement() != FALSE);
		SetPlayerShieldAnim();

		// player "shoot" animation
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

		m_flStartThrow = 0;
		m_flNextPrimaryAttack = GetNextAttackDelay(0.5);
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.75f;

		if (--m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		{
			// just threw last grenade
			// set attack times in the future, and weapon idle in the future so we can see the whole throw
			// animation, weapon idle will automatically retire the weapon for us.
			// ensure that the animation can finish playing
			m_flTimeWeaponIdle = m_flNextSecondaryAttack = m_flNextPrimaryAttack = GetNextAttackDelay(0.5);
		}

		ResetPlayerShieldAnim();
	}
	else if (m_flReleaseThrow > 0)
	{
		// we've finished the throw, restart.
		m_flStartThrow = 0;
		RetireWeapon();
	}
	else if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		int iAnim;
		float flRand = RANDOM_FLOAT(0, 1);

		if (m_pPlayer->HasShield())
		{
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;

			if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			{
				SendWeaponAnim(SHIELDREN_IDLE, UseDecrement() != FALSE);
			}
		}
		else
		{
			if (flRand <= 0.75)
			{
				iAnim = FLASHBANG_IDLE;

				// how long till we do this again.
				m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
			}
			else
			{
			#ifdef REGAMEDLL_FIXES
				iAnim = FLASHBANG_IDLE;
			#else
				// TODO: This is a bug?
				iAnim = *(int *)&flRand;
			#endif
				m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 75.0f / 30.0f;
			}

			SendWeaponAnim(iAnim, UseDecrement() != FALSE);
		}
	}
}

BOOL CFlashbang::CanDeploy(void)
{
	return m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] != 0;
}

```

`dlls/wpn_shared/wpn_g3sg1.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_g3sg1, CG3SG1)

void CG3SG1::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_g3sg1");

	Precache();

	m_iId = WEAPON_G3SG1;
	SET_MODEL(edict(), "models/w_g3sg1.mdl");

	m_iDefaultAmmo = G3SG1_DEFAULT_GIVE;
	m_flLastFire = 0;

	FallInit();
}

void CG3SG1::Precache(void)
{
	PRECACHE_MODEL("models/v_g3sg1.mdl");
	PRECACHE_MODEL("models/w_g3sg1.mdl");

	PRECACHE_SOUND("weapons/g3sg1-1.wav");
	PRECACHE_SOUND("weapons/g3sg1_slide.wav");
	PRECACHE_SOUND("weapons/g3sg1_clipin.wav");
	PRECACHE_SOUND("weapons/g3sg1_clipout.wav");
	PRECACHE_SOUND("weapons/zoom.wav");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireG3SG1 = PRECACHE_EVENT(1, "events/g3sg1.sc");
}

int CG3SG1::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "762Nato";
	p->iMaxAmmo1 = MAX_AMMO_762NATO;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = G3SG1_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 3;
	p->iId = m_iId = WEAPON_G3SG1;
	p->iFlags = 0;
	p->iWeight = G3SG1_WEIGHT;

	return 1;
}

BOOL CG3SG1::Deploy(void)
{
	m_flAccuracy = 0.2f;
	return DefaultDeploy("models/v_g3sg1.mdl", "models/p_g3sg1.mdl", G3SG1_DRAW, "mp5", UseDecrement() != FALSE);
}

void CG3SG1::SecondaryAttack(void)
{
	switch (m_pPlayer->m_iFOV)
	{
	case 90: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 40; break;
	case 40: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 15; break;
	default: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 90; break;
	}

	m_pPlayer->ResetMaxSpeed();

#ifndef CLIENT_DLL
	if (TheBots != NULL)
	{
		TheBots->OnEvent(EVENT_WEAPON_ZOOMED, m_pPlayer);
	}
#endif

	EMIT_SOUND(m_pPlayer->edict(), CHAN_ITEM, "weapons/zoom.wav", 0.2, 2.4);
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3f;
}

void CG3SG1::PrimaryAttack(void)
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		G3SG1Fire(0.45, 0.25, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		G3SG1Fire(0.15, 0.25, FALSE);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		G3SG1Fire(0.035, 0.25, FALSE);
	}
	else
	{
		G3SG1Fire(0.055, 0.25, FALSE);
	}
}

void CG3SG1::G3SG1Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	if (m_pPlayer->pev->fov == DEFAULT_FOV)
	{
		flSpread += 0.025f;
	}

	if (m_flLastFire)
	{
		m_flAccuracy = (gpGlobals->time - m_flLastFire) * 0.3f + 0.55f;

		if (m_flAccuracy > 0.98f)
		{
			m_flAccuracy = 0.98f;
		}
	}
	else
	{
		m_flAccuracy = 0.98f;
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = NORMAL_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, (1 - m_flAccuracy) * flSpread, 8192, 3, BULLET_PLAYER_762MM, G3SG1_DAMAGE, G3SG1_RANGE_MODIFER, m_pPlayer->pev, true, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireG3SG1, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.x * 100), FALSE, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.8f;

	m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomFloat(m_pPlayer->random_seed + 4, 0.75, 1.75) + m_pPlayer->pev->punchangle.x * 0.25f;
	m_pPlayer->pev->punchangle.y += UTIL_SharedRandomFloat(m_pPlayer->random_seed + 5, -0.75, 0.75);
}

void CG3SG1::Reload(void)
{
	if (m_pPlayer->ammo_762nato <= 0)
		return;

	if (DefaultReload(iMaxClip(), G3SG1_RELOAD, G3SG1_RELOAD_TIME))
	{
		m_flAccuracy = 0.2f;
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		if (m_pPlayer->pev->fov != DEFAULT_FOV)
		{
			m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 15;
			SecondaryAttack();
		}
	}
}

void CG3SG1::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle <= UTIL_WeaponTimeBase())
	{
		if (m_iClip)
		{
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60.0f;
			SendWeaponAnim(G3SG1_IDLE, UseDecrement() != FALSE);
		}
	}
}

float CG3SG1::GetMaxSpeed(void)
{
	return (m_pPlayer->m_iFOV == DEFAULT_FOV) ? G3SG1_MAX_SPEED : G3SG1_MAX_SPEED_ZOOM;
}

```

`dlls/wpn_shared/wpn_galil.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"


LINK_ENTITY_TO_CLASS(weapon_galil, CGalil)

void CGalil::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_galil");

	Precache();

	m_iId = WEAPON_GALIL;
	SET_MODEL(edict(), "models/w_galil.mdl");

	m_iDefaultAmmo = GALIL_DEFAULT_GIVE;

	FallInit();
}

void CGalil::Precache(void)
{
	PRECACHE_MODEL("models/v_galil.mdl");
	PRECACHE_MODEL("models/w_galil.mdl");

	PRECACHE_SOUND("weapons/galil-1.wav");
	PRECACHE_SOUND("weapons/galil-2.wav");
	PRECACHE_SOUND("weapons/galil_clipout.wav");
	PRECACHE_SOUND("weapons/galil_clipin.wav");
	PRECACHE_SOUND("weapons/galil_boltpull.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireGalil = PRECACHE_EVENT(1, "events/galil.sc");
}

int CGalil::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = MAX_AMMO_556NATO;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = GALIL_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 17;
	p->iId = m_iId = WEAPON_GALIL;
	p->iFlags = 0;
	p->iWeight = GALIL_WEIGHT;

	return 1;
}

BOOL CGalil::Deploy(void)
{
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;
	iShellOn = 1;

	return DefaultDeploy("models/v_galil.mdl", "models/p_galil.mdl", GALIL_DRAW, "ak47", UseDecrement() != FALSE);
}

void CGalil::PrimaryAttack(void)
{
	if (m_pPlayer->pev->waterlevel == 3)
	{
		PlayEmptySound();
		m_flNextPrimaryAttack = GetNextAttackDelay(0.15);
		return;
	}

	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		GalilFire(0.04 + (0.3 * m_flAccuracy), 0.0875, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
	{
		GalilFire(0.04 + (0.07 * m_flAccuracy), 0.0875, FALSE);
	}
	else
	{
		GalilFire(0.0375 * m_flAccuracy, 0.0875, FALSE);
	}
}

void CGalil::GalilFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 200) + 0.35f;

	if (m_flAccuracy > 1.25f)
		m_flAccuracy = 1.25f;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 2, BULLET_PLAYER_556MM,
		GALIL_DAMAGE, GALIL_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireGalil, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 10000000), int(m_pPlayer->pev->punchangle.y * 10000000), FALSE, FALSE);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.28f;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(1.0, 0.45, 0.28, 0.045, 3.75, 3.0, 7);
	}
	else if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(1.2, 0.5, 0.23, 0.15, 5.5, 3.5, 6);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.6, 0.3, 0.2, 0.0125, 3.25, 2.0, 7);
	}
	else
	{
		KickBack(0.65, 0.35, 0.25, 0.015, 3.5, 2.25, 7);
	}
}

void CGalil::Reload(void)
{
	// to prevent reload if not enough ammo
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(iMaxClip(), GALIL_RELOAD, GALIL_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2f;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CGalil::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle <= UTIL_WeaponTimeBase())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
		SendWeaponAnim(GALIL_IDLE1, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_glock18.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

#ifdef CLIENT_WEAPONS
extern bool g_bGlockBurstMode;
#endif

LINK_ENTITY_TO_CLASS(weapon_glock18, CGLOCK18)

void CGLOCK18::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_glock18");

	Precache();

	m_iId = WEAPON_GLOCK18;
	SET_MODEL(edict(), "models/w_glock18.mdl");

	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_iDefaultAmmo = GLOCK18_DEFAULT_GIVE;
	m_bBurstFire = false;

	m_iGlock18ShotsFired = 0;
	m_flGlock18Shoot = 0;
	m_flAccuracy = 0.9f;

	FallInit();
}

void CGLOCK18::Precache(void)
{
	PRECACHE_MODEL("models/v_glock18.mdl");
	PRECACHE_MODEL("models/w_glock18.mdl");
	PRECACHE_MODEL("models/shield/v_shield_glock18.mdl");

	PRECACHE_SOUND("weapons/glock18-1.wav");
	PRECACHE_SOUND("weapons/glock18-2.wav");
	PRECACHE_SOUND("weapons/clipout1.wav");
	PRECACHE_SOUND("weapons/clipin1.wav");
	PRECACHE_SOUND("weapons/sliderelease1.wav");
	PRECACHE_SOUND("weapons/slideback1.wav");
	PRECACHE_SOUND("weapons/357_cock1.wav");
	PRECACHE_SOUND("weapons/de_clipin.wav");
	PRECACHE_SOUND("weapons/de_clipout.wav");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireGlock18 = PRECACHE_EVENT(1, "events/glock18.sc");
}

int CGLOCK18::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "9mm";
	p->iMaxAmmo1 = MAX_AMMO_9MM;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = GLOCK18_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 2;
	p->iId = m_iId = WEAPON_GLOCK18;
	p->iFlags = 0;
	p->iWeight = GLOCK18_WEIGHT;

	return 1;
}

BOOL CGLOCK18::Deploy(void)
{
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	m_bBurstFire = false;
	m_iGlock18ShotsFired = 0;
	m_flGlock18Shoot = 0;
	m_flAccuracy = 0.9f;
	m_fMaxSpeed = GLOCK18_MAX_SPEED;

	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield())
	{
		m_iWeaponState &= ~WPNSTATE_GLOCK18_BURST_MODE;
		return DefaultDeploy("models/shield/v_shield_glock18.mdl", "models/shield/p_shield_glock18.mdl", GLOCK18_SHIELD_DRAW, "shieldgun", UseDecrement() != FALSE);
	}
	else if (RANDOM_LONG(0, 1))
	{
		return DefaultDeploy("models/v_glock18.mdl", "models/p_glock18.mdl", GLOCK18_DRAW, "onehanded", UseDecrement() != FALSE);
	}

	return DefaultDeploy("models/v_glock18.mdl", "models/p_glock18.mdl", GLOCK18_DRAW2, "onehanded", UseDecrement() != FALSE);
}

void CGLOCK18::SecondaryAttack(void)
{
	if (ShieldSecondaryFire(GLOCK18_SHIELD_UP, GLOCK18_SHIELD_DOWN))
	{
		return;
	}

	if (m_iWeaponState & WPNSTATE_GLOCK18_BURST_MODE)
	{
		ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#Switch_To_SemiAuto");
		m_iWeaponState &= ~WPNSTATE_GLOCK18_BURST_MODE;
	}
	else
	{
		ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#Switch_To_BurstFire");
		m_iWeaponState |= WPNSTATE_GLOCK18_BURST_MODE;
	}

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3f;
}

void CGLOCK18::PrimaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_GLOCK18_BURST_MODE)
	{
		if (!(m_pPlayer->pev->flags & FL_ONGROUND))
		{
			GLOCK18Fire(1.2 * (1 - m_flAccuracy), 0.5, TRUE);
		}
		else if (m_pPlayer->pev->velocity.Length2D() > 0)
		{
			GLOCK18Fire(0.185 * (1 - m_flAccuracy), 0.5, TRUE);
		}
		else if (m_pPlayer->pev->flags & FL_DUCKING)
		{
			GLOCK18Fire(0.095 * (1 - m_flAccuracy), 0.5, TRUE);
		}
		else
		{
			GLOCK18Fire(0.3 * (1 - m_flAccuracy), 0.5, TRUE);
		}
	}
	else
	{
		if (!(m_pPlayer->pev->flags & FL_ONGROUND))
		{
			GLOCK18Fire(1.0 * (1 - m_flAccuracy), 0.2, FALSE);
		}
		else if (m_pPlayer->pev->velocity.Length2D() > 0)
		{
			GLOCK18Fire(0.165 * (1 - m_flAccuracy), 0.2, FALSE);
		}
		else if (m_pPlayer->pev->flags & FL_DUCKING)
		{
			GLOCK18Fire(0.075 * (1 - m_flAccuracy), 0.2, FALSE);
		}
		else
		{
			GLOCK18Fire(0.1 * (1 - m_flAccuracy), 0.2, FALSE);
		}
	}
}

void CGLOCK18::GLOCK18Fire(float flSpread, float flCycleTime, BOOL bFireBurst)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	if (bFireBurst)
	{
		m_iGlock18ShotsFired = 0;
	}
	else
	{
		if (++m_iShotsFired > 1)
		{
			return;
		}

		flCycleTime -= 0.05f;
	}

	if (m_flLastFire)
	{
		// Mark the time of this shot and determine the accuracy modifier based on the last shot fired...
		m_flAccuracy -= (0.325f - (gpGlobals->time - m_flLastFire)) * 0.275f;

		if (m_flAccuracy > 0.9f)
		{
			m_flAccuracy = 0.9f;
		}
		else if (m_flAccuracy < 0.6f)
		{
			m_flAccuracy = 0.6f;
		}
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;

#ifndef CLIENT_DLL
	// player "shoot" animation
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	// non-silenced
	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = NORMAL_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 1, BULLET_PLAYER_9MM, GLOCK18_DAMAGE, GLOCK18_RANGE_MODIFER, m_pPlayer->pev, true, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireGlock18, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), m_iClip == 0, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		// HEV suit - indicate out of ammo condition
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, FALSE);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.5f;

	if (bFireBurst)
	{
		// Fire off the next two rounds
		++m_iGlock18ShotsFired;
		m_flGlock18Shoot = gpGlobals->time + 0.1f;
	}

	ResetPlayerShieldAnim();
}

void CGLOCK18::Reload(void)
{
	int iResult;
	if (m_pPlayer->ammo_9mm <= 0)
		return;

	if (m_pPlayer->HasShield())
		iResult = GLOCK18_SHIELD_RELOAD;
	else if (RANDOM_LONG(0, 1))
		iResult = GLOCK18_RELOAD;
	else
		iResult = GLOCK18_RELOAD2;

	if (DefaultReload(iMaxClip(), iResult, GLOCK18_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.9;
	}
}

void CGLOCK18::WeaponIdle(void)
{
	int iAnim;
	float flRand;

	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	if (m_pPlayer->HasShield())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;

		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		{
			SendWeaponAnim(GLOCK18_SHIELD_IDLE, UseDecrement() != FALSE);
		}
	}
	// only idle if the slid isn't back
	else if (m_iClip)
	{
		flRand = RANDOM_FLOAT(0, 1);

		if (flRand <= 0.3f)
		{
			iAnim = GLOCK18_IDLE3;
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 3.0625f;
		}
		else if (flRand <= 0.6f)
		{
			iAnim = GLOCK18_IDLE1;
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 3.75f;
		}
		else
		{
			iAnim = GLOCK18_IDLE2;
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.5f;
		}

		SendWeaponAnim(iAnim, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_hegrenade.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_hegrenade, CHEGrenade)

void CHEGrenade::Spawn(void)
{
	Precache();

	m_iId = WEAPON_HEGRENADE;
	SET_MODEL(edict(), "models/w_hegrenade.mdl");

	pev->dmg = 4;

	m_iDefaultAmmo = HEGRENADE_DEFAULT_GIVE;
	m_flStartThrow = 0;
	m_flReleaseThrow = -1.0f;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	// get ready to fall down.
	FallInit();
}

void CHEGrenade::Precache(void)
{
	PRECACHE_MODEL("models/v_hegrenade.mdl");
	PRECACHE_MODEL("models/shield/v_shield_hegrenade.mdl");

	PRECACHE_SOUND("weapons/hegrenade-1.wav");
	PRECACHE_SOUND("weapons/hegrenade-2.wav");
	PRECACHE_SOUND("weapons/he_bounce-1.wav");
	PRECACHE_SOUND("weapons/pinpull.wav");

	m_usCreateExplosion = PRECACHE_EVENT(1, "events/createexplo.sc");
}

int CHEGrenade::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "HEGrenade";

	p->iMaxAmmo1 = MAX_AMMO_HEGRENADE;
	p->iMaxClip = WEAPON_NOCLIP;

	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iSlot = 3;
	p->iPosition = 1;
	p->iId = m_iId = WEAPON_HEGRENADE;
	p->iWeight = HEGRENADE_WEIGHT;
	p->iFlags = ITEM_FLAG_LIMITINWORLD | ITEM_FLAG_EXHAUSTIBLE;

	return 1;}

BOOL CHEGrenade::Deploy(void)
{
	m_flReleaseThrow = -1.0f;
	m_fMaxSpeed = HEGRENADE_MAX_SPEED;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield())
		return DefaultDeploy("models/shield/v_shield_hegrenade.mdl", "models/shield/p_shield_hegrenade.mdl", HEGRENADE_DRAW, "shieldgren", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_hegrenade.mdl", "models/p_hegrenade.mdl", HEGRENADE_DRAW, "grenade", UseDecrement() != FALSE);
}

BOOL CHEGrenade::CanHolster(void)
{
	return m_flStartThrow == 0;
}

void CHEGrenade::Holster(int skiplocal)
{
	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.5f;

	if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		m_pPlayer->pev->weapons &= ~(1 << WEAPON_HEGRENADE);
		DestroyItem();
	}

	m_flStartThrow = 0;
	m_flReleaseThrow = -1.0f;
}

void CHEGrenade::PrimaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		return;
	}

	if (!m_flStartThrow && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] > 0)
	{
		m_flReleaseThrow = 0;
		m_flStartThrow = gpGlobals->time;

		SendWeaponAnim(HEGRENADE_PULLPIN, UseDecrement() != FALSE);
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.5f;
	}
}

void CHEGrenade::SetPlayerShieldAnim(void)
{
	if (!m_pPlayer->HasShield())
		return;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		strcpy(m_pPlayer->m_szAnimExtention, "shield");
	else
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
}

void CHEGrenade::ResetPlayerShieldAnim(void)
{
	if (!m_pPlayer->HasShield())
		return;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
	}
}

bool CHEGrenade::ShieldSecondaryFire(int iUpAnim, int iDownAnim)
{
	if (!m_pPlayer->HasShield() || m_flStartThrow > 0)
	{
		return false;
	}

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(iDownAnim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");

		m_fMaxSpeed = HEGRENADE_MAX_SPEED;
		m_pPlayer->m_bShieldDrawn = false;
	}
	else
	{
		m_iWeaponState |= WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(iUpAnim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shielded");

		m_fMaxSpeed = HEGRENADE_MAX_SPEED_SHIELD;
		m_pPlayer->m_bShieldDrawn = true;
	}

#ifndef CLIENT_DLL
	m_pPlayer->UpdateShieldCrosshair((m_iWeaponState & WPNSTATE_SHIELD_DRAWN) != WPNSTATE_SHIELD_DRAWN);
#endif
	m_pPlayer->ResetMaxSpeed();

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.4f;
	m_flNextPrimaryAttack = GetNextAttackDelay(0.4);
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.6f;

	return true;
}

void CHEGrenade::SecondaryAttack(void)
{
	ShieldSecondaryFire(SHIELDGUN_DRAW, SHIELDGUN_DRAWN_IDLE);
}

void CHEGrenade::WeaponIdle(void)
{
	if (m_flReleaseThrow == 0 && m_flStartThrow != 0.0f)
		m_flReleaseThrow = gpGlobals->time;

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_flStartThrow)
	{
		m_pPlayer->Radio("%!MRAD_FIREINHOLE", "#Fire_in_the_hole");

		Vector angThrow = m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle;

		if (angThrow.x < 0)
			angThrow.x = -10 + angThrow.x * ((90 - 10) / 90.0);
		else
			angThrow.x = -10 + angThrow.x * ((90 + 10) / 90.0);

		float flVel = (90.0f - angThrow.x) * 6.0f;

		if (flVel > 750.0f)
			flVel = 750.0f;

		UTIL_MakeVectors(angThrow);

		Vector vecSrc = m_pPlayer->pev->origin + m_pPlayer->pev->view_ofs + gpGlobals->v_forward * 16;
		Vector vecThrow = gpGlobals->v_forward * flVel + m_pPlayer->pev->velocity;

		CGrenade::ShootTimed2(m_pPlayer->pev, vecSrc, vecThrow, 1.5, m_pPlayer->m_iTeam, m_usCreateExplosion);

		SendWeaponAnim(HEGRENADE_THROW, UseDecrement() != FALSE);
		SetPlayerShieldAnim();

#ifndef CLIENT_DLL
		// player "shoot" animation
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		m_flStartThrow = 0;
		m_flNextPrimaryAttack = GetNextAttackDelay(0.5);
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.75f;

		if (--m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		{
			// just threw last grenade
			// set attack times in the future, and weapon idle in the future so we can see the whole throw
			// animation, weapon idle will automatically retire the weapon for us.
			// ensure that the animation can finish playing
			m_flTimeWeaponIdle = m_flNextSecondaryAttack = m_flNextPrimaryAttack = GetNextAttackDelay(0.5);
		}

		ResetPlayerShieldAnim();
	}
	else if (m_flReleaseThrow > 0)
	{
		// we've finished the throw, restart.
		m_flStartThrow = 0;

		if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
		{
			SendWeaponAnim(HEGRENADE_DRAW, UseDecrement() != FALSE);
		}
		else
		{
			RetireWeapon();
			return;
		}

		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
		m_flReleaseThrow = -1.0f;
	}
	else if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		if (m_pPlayer->HasShield())
		{
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;

			if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			{
				SendWeaponAnim(SHIELDREN_IDLE, UseDecrement() != FALSE);
			}
		}
		else
		{
			SendWeaponAnim(HEGRENADE_IDLE, UseDecrement() != FALSE);

			// how long till we do this again.
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
		}
	}
}

BOOL CHEGrenade::CanDeploy(void)
{
	return m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] != 0;
}

```

`dlls/wpn_shared/wpn_knife.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

#define KNIFE_BODYHIT_VOLUME 128
#define KNIFE_WALLHIT_VOLUME 512

LINK_ENTITY_TO_CLASS(weapon_knife, CKnife)

void CKnife::Spawn()
{
	Precache();

	m_iId = WEAPON_KNIFE;
	SET_MODEL(edict(), "models/w_knife.mdl");

	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_iClip = WEAPON_NOCLIP;

	FallInit();
}

void CKnife::Precache()
{
	PRECACHE_MODEL("models/v_knife.mdl");
	PRECACHE_MODEL("models/shield/v_shield_knife.mdl");
	PRECACHE_MODEL("models/w_knife.mdl");

	PRECACHE_SOUND("weapons/knife_deploy1.wav");
	PRECACHE_SOUND("weapons/knife_hit1.wav");
	PRECACHE_SOUND("weapons/knife_hit2.wav");
	PRECACHE_SOUND("weapons/knife_hit3.wav");
	PRECACHE_SOUND("weapons/knife_hit4.wav");
	PRECACHE_SOUND("weapons/knife_slash1.wav");
	PRECACHE_SOUND("weapons/knife_slash2.wav");
	PRECACHE_SOUND("weapons/knife_stab.wav");
	PRECACHE_SOUND("weapons/knife_hitwall1.wav");

	m_usKnife = PRECACHE_EVENT(1, "events/knife.sc");
}

int CKnife::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = NULL;
	p->iMaxAmmo1 = -1;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = WEAPON_NOCLIP;
	p->iSlot = 2;
	p->iPosition = 1;
	p->iId = WEAPON_KNIFE;

	// TODO: it is not being used
	//p->iFlags = 0;

	p->iWeight = KNIFE_WEIGHT;

	return 1;
}

BOOL CKnife::Deploy()
{
	EMIT_SOUND(m_pPlayer->edict(), CHAN_ITEM, "weapons/knife_deploy1.wav", 0.3, 2.4);

	m_iSwing = 0;
	m_fMaxSpeed = KNIFE_MAX_SPEED;

	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield())
	{
		return DefaultDeploy("models/shield/v_shield_knife.mdl", "models/shield/p_shield_knife.mdl", KNIFE_SHIELD_DRAW, "shieldknife", UseDecrement() != FALSE);
	}
	else
		return DefaultDeploy("models/v_knife.mdl", "models/p_knife.mdl", KNIFE_DRAW, "knife", UseDecrement() != FALSE);
}

void CKnife::Holster(int skiplocal)
{
	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.5f;
}

void CKnife::WeaponAnimation(int iAnimation)
{
	int flag;

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usKnife,
		0.0, (float *)&g_vecZero, (float *)&g_vecZero,
		0.0,
		0.0,
		iAnimation, 2, 3, 4);
}

void FindHullIntersection(const Vector &vecSrc, TraceResult &tr, float *mins, float *maxs, edict_t *pEntity)
{
	int i, j, k;
	float distance;
	float *minmaxs[2] = { mins, maxs };
	TraceResult tmpTrace;
	Vector vecHullEnd = tr.vecEndPos;
	Vector vecEnd;

	distance = 1e6f;

	vecHullEnd = vecSrc + ((vecHullEnd - vecSrc) * 2);
	UTIL_TraceLine(vecSrc, vecHullEnd, dont_ignore_monsters, pEntity, &tmpTrace);

	if (tmpTrace.flFraction < 1.0f)
	{
		tr = tmpTrace;
		return;
	}

	for (i = 0; i < 2; ++i)
	{
		for (j = 0; j < 2; ++j)
		{
			for (k = 0; k < 2; ++k)
			{
				vecEnd.x = vecHullEnd.x + minmaxs[i][0];
				vecEnd.y = vecHullEnd.y + minmaxs[j][1];
				vecEnd.z = vecHullEnd.z + minmaxs[k][2];

				UTIL_TraceLine(vecSrc, vecEnd, dont_ignore_monsters, pEntity, &tmpTrace);

				if (tmpTrace.flFraction < 1.0f)
				{
					float thisDistance = (tmpTrace.vecEndPos - vecSrc).Length();

					if (thisDistance < distance)
					{
						tr = tmpTrace;
						distance = thisDistance;
					}
				}
			}
		}
	}
}

void CKnife::PrimaryAttack()
{
	Swing(TRUE);
}

void CKnife::SetPlayerShieldAnim()
{
	if (!m_pPlayer->HasShield())
		return;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		strcpy(m_pPlayer->m_szAnimExtention, "shield");
	}
	else
	{
		strcpy(m_pPlayer->m_szAnimExtention, "shieldknife");
	}
}

void CKnife::ResetPlayerShieldAnim()
{
	if (!m_pPlayer->HasShield())
		return;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		strcpy(m_pPlayer->m_szAnimExtention, "shieldknife");
	}
}

bool CKnife::ShieldSecondaryFire(int iUpAnim, int iDownAnim)
{
	if (!m_pPlayer->HasShield())
	{
		return false;
	}

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

		SendWeaponAnim(iDownAnim, UseDecrement() != FALSE);

		strcpy(m_pPlayer->m_szAnimExtention, "shieldknife");

		m_fMaxSpeed = KNIFE_MAX_SPEED;
		m_pPlayer->m_bShieldDrawn = false;
	}
	else
	{
		m_iWeaponState |= WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(iUpAnim, UseDecrement() != FALSE);

		strcpy(m_pPlayer->m_szAnimExtention, "shielded");

		m_fMaxSpeed = KNIFE_MAX_SPEED_SHIELD;
		m_pPlayer->m_bShieldDrawn = true;
	}

#ifndef CLIENT_DLL
	m_pPlayer->UpdateShieldCrosshair((m_iWeaponState & WPNSTATE_SHIELD_DRAWN) != WPNSTATE_SHIELD_DRAWN);
#endif
	m_pPlayer->ResetMaxSpeed();

	m_flNextPrimaryAttack = GetNextAttackDelay(0.4);
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.4f;
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.6f;

	return true;
}

void CKnife::SecondaryAttack()
{
	if (!ShieldSecondaryFire(KNIFE_SHIELD_UP, KNIFE_SHIELD_DOWN))
	{
		Stab(TRUE);
		pev->nextthink = UTIL_WeaponTimeBase() + 0.35f;
	}
}

void CKnife::Smack()
{
	DecalGunshot(&m_trHit, BULLET_PLAYER_CROWBAR, false, m_pPlayer->pev, false);
}

void CKnife::SwingAgain()
{
	Swing(FALSE);
}

void CKnife::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_pPlayer->m_bShieldDrawn)
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;

	// only idle if the slid isn't back
	SendWeaponAnim(KNIFE_IDLE, UseDecrement() != FALSE);
}

int CKnife::Swing(int fFirst)
{
	int fDidHit = FALSE;
	TraceResult tr;
	Vector vecSrc, vecEnd;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle);

	vecSrc = m_pPlayer->GetGunPosition();
	vecEnd = vecSrc + gpGlobals->v_forward * 48.0f;

	UTIL_TraceLine(vecSrc, vecEnd, dont_ignore_monsters, m_pPlayer->edict(), &tr);

	if (tr.flFraction >= 1.0f)
	{
		UTIL_TraceHull(vecSrc, vecEnd, dont_ignore_monsters, head_hull, m_pPlayer->edict(), &tr);

		if (tr.flFraction < 1.0f)
		{
			// Calculate the point of intersection of the line (or hull) and the object we hit
			// This is and approximation of the "best" intersection
			CBaseEntity *pHit = CBaseEntity::Instance(tr.pHit);

			if (!pHit || pHit->IsBSPModel())
			{
				FindHullIntersection(vecSrc, tr, VEC_DUCK_HULL_MIN, VEC_DUCK_HULL_MAX, m_pPlayer->edict());
			}

			// This is the point on the actual surface (the hull could have hit space)
			vecEnd = tr.vecEndPos;
		}
	}

	if (tr.flFraction >= 1.0f)
	{
		if (fFirst)
		{
			if (!m_pPlayer->HasShield())
			{
				switch ((m_iSwing++) % 2)
				{
				case 0: SendWeaponAnim(KNIFE_MIDATTACK1HIT, UseDecrement() != FALSE); break;
				case 1: SendWeaponAnim(KNIFE_MIDATTACK2HIT, UseDecrement() != FALSE); break;
				}

				// miss
				m_flNextPrimaryAttack = GetNextAttackDelay(0.35);
				m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.5f;
			}
			else
			{
				SendWeaponAnim(KNIFE_SHIELD_ATTACKHIT, UseDecrement() != FALSE);

				m_flNextPrimaryAttack = GetNextAttackDelay(1.0);
				m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.2f;
			}

			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;

			// play wiff or swish sound
			if (RANDOM_LONG(0, 1))
				EMIT_SOUND_DYN(m_pPlayer->edict(), CHAN_WEAPON, "weapons/knife_slash1.wav", VOL_NORM, ATTN_NORM, 0, 94);
			else
				EMIT_SOUND_DYN(m_pPlayer->edict(), CHAN_WEAPON, "weapons/knife_slash2.wav", VOL_NORM, ATTN_NORM, 0, 94);

#ifndef CLIENT_DLL
			// player "shoot" animation
			m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		}
	}
	else
	{
		// hit
		fDidHit = TRUE;

		if (!m_pPlayer->HasShield())
		{
			switch ((m_iSwing++) % 2)
			{
			case 0: SendWeaponAnim(KNIFE_MIDATTACK1HIT, UseDecrement() != FALSE); break;
			case 1: SendWeaponAnim(KNIFE_MIDATTACK2HIT, UseDecrement() != FALSE); break;
			}

			m_flNextPrimaryAttack = GetNextAttackDelay(0.4);
			m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.5f;
		}
		else
		{
			SendWeaponAnim(KNIFE_SHIELD_ATTACKHIT, UseDecrement() != FALSE);

			m_flNextPrimaryAttack = GetNextAttackDelay(1.0);
			m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.2f;
		}

		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;

		// play thwack, smack, or dong sound
		float flVol = 1.0f;
		int fHitWorld = TRUE;

		CBaseEntity *pEntity = CBaseEntity::Instance(tr.pHit);
		SetPlayerShieldAnim();

#ifndef CLIENT_DLL
		// player "shoot" animation
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		ClearMultiDamage();

		if (m_flNextPrimaryAttack + 0.4f < UTIL_WeaponTimeBase())
			pEntity->TraceAttack(m_pPlayer->pev, 20, gpGlobals->v_forward, &tr, (DMG_NEVERGIB | DMG_BULLET));
		else
			pEntity->TraceAttack(m_pPlayer->pev, 15, gpGlobals->v_forward, &tr, (DMG_NEVERGIB | DMG_BULLET));

		ApplyMultiDamage(m_pPlayer->pev, m_pPlayer->pev);

#ifndef REGAMEDLL_FIXES
		if (pEntity != NULL)	// -V595
#endif
		{
			if (pEntity->Classify() != CLASS_NONE && pEntity->Classify() != CLASS_MACHINE)
			{
				// play thwack or smack sound
				switch (RANDOM_LONG(0, 3))
				{
				case 0: EMIT_SOUND(m_pPlayer->edict(), CHAN_WEAPON, "weapons/knife_hit1.wav", VOL_NORM, ATTN_NORM); break;
				case 1: EMIT_SOUND(m_pPlayer->edict(), CHAN_WEAPON, "weapons/knife_hit2.wav", VOL_NORM, ATTN_NORM); break;
				case 2: EMIT_SOUND(m_pPlayer->edict(), CHAN_WEAPON, "weapons/knife_hit3.wav", VOL_NORM, ATTN_NORM); break;
				case 3: EMIT_SOUND(m_pPlayer->edict(), CHAN_WEAPON, "weapons/knife_hit4.wav", VOL_NORM, ATTN_NORM); break;
				}

				m_pPlayer->m_iWeaponVolume = KNIFE_BODYHIT_VOLUME;

				if (!pEntity->IsAlive())
					return TRUE;
				else
					flVol = 0.1f;

				fHitWorld = FALSE;
			}
		}

		// play texture hit sound
		// UNDONE: Calculate the correct point of intersection when we hit with the hull instead of the line

		if (fHitWorld)
		{
#ifndef CLIENT_DLL
			float fvolbar = TEXTURETYPE_PlaySound(&tr, vecSrc, vecSrc + (vecEnd - vecSrc) * 2, BULLET_PLAYER_CROWBAR);
			//fvolbar = 1.0;
#endif

			if (RANDOM_LONG(0, 1) > 1)
			{
				fHitWorld = FALSE;
			}
		}

		if (!fHitWorld)
		{
			// delay the decal a bit
			m_trHit = tr;
			SetThink(&CKnife::Smack);

			pev->nextthink = UTIL_WeaponTimeBase() + 0.2f;
			m_pPlayer->m_iWeaponVolume = int(flVol * KNIFE_WALLHIT_VOLUME);

			ResetPlayerShieldAnim();
		}
		else
		{
			// also play knife strike
			EMIT_SOUND_DYN(m_pPlayer->edict(), CHAN_ITEM, "weapons/knife_hitwall1.wav", VOL_NORM, ATTN_NORM, 0, RANDOM_LONG(0, 3) + 98);
		}
	}

	return fDidHit;
}

int CKnife::Stab(int fFirst)
{
	int fDidHit = FALSE;
	TraceResult tr;
	Vector vecSrc, vecEnd;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle);

	vecSrc = m_pPlayer->GetGunPosition();
	vecEnd = vecSrc + gpGlobals->v_forward * 32.0f;

	UTIL_TraceLine(vecSrc, vecEnd, dont_ignore_monsters, m_pPlayer->edict(), &tr);

	if (tr.flFraction >= 1.0f)
	{
		UTIL_TraceHull(vecSrc, vecEnd, dont_ignore_monsters, head_hull, m_pPlayer->edict(), &tr);

		if (tr.flFraction < 1.0f)
		{
			// Calculate the point of intersection of the line (or hull) and the object we hit
			// This is and approximation of the "best" intersection
			CBaseEntity *pHit = CBaseEntity::Instance(tr.pHit);

			if (!pHit || pHit->IsBSPModel())
			{
				FindHullIntersection(vecSrc, tr, VEC_DUCK_HULL_MIN, VEC_DUCK_HULL_MAX, m_pPlayer->edict());
			}

			// This is the point on the actual surface (the hull could have hit space)
			vecEnd = tr.vecEndPos;
		}
	}

	if (tr.flFraction >= 1.0f)
	{
		if (fFirst)
		{
			SendWeaponAnim(KNIFE_STABMISS, UseDecrement() != FALSE);

			m_flNextPrimaryAttack = GetNextAttackDelay(1.0);
			m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.0f;

			// play wiff or swish sound
			if (RANDOM_LONG(0, 1))
				EMIT_SOUND_DYN(m_pPlayer->edict(), CHAN_WEAPON, "weapons/knife_slash1.wav", VOL_NORM, ATTN_NORM, 0, 94);
			else
				EMIT_SOUND_DYN(m_pPlayer->edict(), CHAN_WEAPON, "weapons/knife_slash2.wav", VOL_NORM, ATTN_NORM, 0, 94);

#ifndef CLIENT_DLL
			// player "shoot" animation
			m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		}
	}
	else
	{
		// hit
		fDidHit = TRUE;

		SendWeaponAnim(KNIFE_STABHIT, UseDecrement() != FALSE);

		m_flNextPrimaryAttack = GetNextAttackDelay(1.1);
		m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.1f;

		// play thwack, smack, or dong sound
		float flVol = 1.0f;
		int fHitWorld = TRUE;

		CBaseEntity *pEntity = CBaseEntity::Instance(tr.pHit);

#ifndef CLIENT_DLL
		// player "shoot" animation
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

		float flDamage = 65.0f;

		if (pEntity != NULL && pEntity->IsPlayer())
		{
			Vector2D vec2LOS;
			float flDot;
			Vector vMyForward = gpGlobals->v_forward;

			UTIL_MakeVectors(pEntity->pev->angles);

			vec2LOS = vMyForward.Make2D();
			vec2LOS = vec2LOS.Normalize();

			flDot = DotProduct(vec2LOS, gpGlobals->v_forward.Make2D());

			//Triple the damage if we are stabbing them in the back.
			if (flDot > 0.80f)
			{
				flDamage *= 3.0f;
			}
		}

		UTIL_MakeVectors(m_pPlayer->pev->v_angle);
		ClearMultiDamage();

		pEntity->TraceAttack(m_pPlayer->pev, flDamage, gpGlobals->v_forward, &tr, (DMG_NEVERGIB | DMG_BULLET));
		ApplyMultiDamage(m_pPlayer->pev, m_pPlayer->pev);

#ifndef REGAMEDLL_FIXES
		if (pEntity != NULL)	// -V595
#endif
		{
			if (pEntity->Classify() != CLASS_NONE && pEntity->Classify() != CLASS_MACHINE)
			{
				EMIT_SOUND(m_pPlayer->edict(), CHAN_WEAPON, "weapons/knife_stab.wav", VOL_NORM, ATTN_NORM);
				m_pPlayer->m_iWeaponVolume = KNIFE_BODYHIT_VOLUME;

				if (!pEntity->IsAlive())
					return TRUE;
				else
					flVol = 0.1f;

				fHitWorld = FALSE;
			}
		}

		// play texture hit sound
		// UNDONE: Calculate the correct point of intersection when we hit with the hull instead of the line

		if (fHitWorld)
		{
#ifndef CLIENT_DLL
			float fvolbar = TEXTURETYPE_PlaySound(&tr, vecSrc, vecSrc + (vecEnd - vecSrc) * 2, BULLET_PLAYER_CROWBAR);
			//fvolbar = 1.0;
#endif

			if (RANDOM_LONG(0, 1) > 1)
			{
				fHitWorld = FALSE;
			}
		}

		if (!fHitWorld)
		{
			// delay the decal a bit
			m_trHit = tr;
			m_pPlayer->m_iWeaponVolume = int(flVol * KNIFE_WALLHIT_VOLUME);

			SetThink(&CKnife::Smack);
			pev->nextthink = UTIL_WeaponTimeBase() + 0.2f;

			ResetPlayerShieldAnim();
		}
		else
		{
			// also play knife strike
			EMIT_SOUND_DYN(m_pPlayer->edict(), CHAN_ITEM, "weapons/knife_hitwall1.wav", VOL_NORM, ATTN_NORM, 0, RANDOM_LONG(0, 3) + 98);
		}
	}

	return fDidHit;
}

```

`dlls/wpn_shared/wpn_m249.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_m249, CM249)

void CM249::Spawn()
{
	pev->classname = MAKE_STRING("weapon_m249");

	Precache();

	m_iId = WEAPON_M249;
	SET_MODEL(edict(), "models/w_m249.mdl");

	m_iDefaultAmmo = M249_DEFAULT_GIVE;
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;

	FallInit();
}

void CM249::Precache()
{
	PRECACHE_MODEL("models/v_m249.mdl");
	PRECACHE_MODEL("models/w_m249.mdl");

	PRECACHE_SOUND("weapons/m249-1.wav");
	PRECACHE_SOUND("weapons/m249-2.wav");
	PRECACHE_SOUND("weapons/m249_boxout.wav");
	PRECACHE_SOUND("weapons/m249_boxin.wav");
	PRECACHE_SOUND("weapons/m249_chain.wav");
	PRECACHE_SOUND("weapons/m249_coverup.wav");
	PRECACHE_SOUND("weapons/m249_coverdown.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireM249 = PRECACHE_EVENT(1, "events/m249.sc");
}

int CM249::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556NatoBox";
	p->iMaxAmmo1 = MAX_AMMO_556NATOBOX;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = M249_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 4;
	p->iId = m_iId = WEAPON_M249;
	p->iFlags = 0;
	p->iWeight = M249_WEIGHT;

	return 1;
}

BOOL CM249::Deploy()
{
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;
	iShellOn = 1;

	return DefaultDeploy("models/v_m249.mdl", "models/p_m249.mdl", M249_DRAW, "m249", UseDecrement() != FALSE);
}

void CM249::PrimaryAttack()
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		M249Fire(0.045 + (0.5 * m_flAccuracy), 0.1, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
	{
		M249Fire(0.045 + (0.095 * m_flAccuracy), 0.1, FALSE);
	}
	else
	{
		M249Fire(0.03 * m_flAccuracy, 0.1, FALSE);
	}
}

void CM249::M249Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 175) + 0.4f;

	if (m_flAccuracy > 0.9f)
		m_flAccuracy = 0.9f;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 2, BULLET_PLAYER_556MM,
		M249_DAMAGE, M249_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireM249, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.6f;

	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(1.8, 0.65, 0.45, 0.125, 5.0, 3.5, 8);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(1.1, 0.5, 0.3, 0.06, 4.0, 3.0, 8);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.75, 0.325, 0.25, 0.025, 3.5, 2.5, 9);
	}
	else
	{
		KickBack(0.8, 0.35, 0.3, 0.03, 3.75, 3.0, 9);
	}
}

void CM249::Reload()
{
#ifdef REGAMEDLL_FIXES
	// to prevent reload if not enough ammo
	if (m_pPlayer->ammo_556natobox <= 0)
		return;
#endif

	if (DefaultReload(iMaxClip(), M249_RELOAD, M249_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2f;
		m_bDelayFire = false;
		m_iShotsFired = 0;
	}
}

void CM249::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
	SendWeaponAnim(M249_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_m3.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_m3, CM3)

void CM3::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_m3");

	Precache();

	m_iId = WEAPON_M3;
	SET_MODEL(edict(), "models/w_m3.mdl");

	m_iDefaultAmmo = M3_DEFAULT_GIVE;

	FallInit();
}

void CM3::Precache()
{
	PRECACHE_MODEL("models/v_m3.mdl");
	PRECACHE_MODEL("models/w_m3.mdl");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/shotgunshell.mdl");

	PRECACHE_SOUND("weapons/m3-1.wav");
	PRECACHE_SOUND("weapons/m3_insertshell.wav");
	PRECACHE_SOUND("weapons/m3_pump.wav");
	PRECACHE_SOUND("weapons/reload1.wav");
	PRECACHE_SOUND("weapons/reload3.wav");

	m_usFireM3 = PRECACHE_EVENT(1, "events/m3.sc");
}

int CM3::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "buckshot";
	p->iMaxAmmo1 = MAX_AMMO_BUCKSHOT;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = M3_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 5;
	p->iId = m_iId = WEAPON_M3;
	p->iFlags = 0;
	p->iWeight = M3_WEIGHT;

	return 1;
}

BOOL CM3::Deploy()
{
	return DefaultDeploy("models/v_m3.mdl", "models/p_m3.mdl", M3_DRAW, "shotgun", UseDecrement() != FALSE);
}

void CM3::PrimaryAttack()
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	// don't fire underwater
	if (m_pPlayer->pev->waterlevel == 3)
	{
		PlayEmptySound();
		m_flNextPrimaryAttack = GetNextAttackDelay(0.15);
		return;
	}

	if (m_iClip <= 0)
	{
		Reload();

		if (!m_iClip)
		{
			PlayEmptySound();
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		m_flNextPrimaryAttack = GetNextAttackDelay(1);
		return;
	}

	m_pPlayer->m_iWeaponVolume = LOUD_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;
	--m_iClip;

	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	// player "shoot" animation
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

#ifndef CLIENT_DLL
	m_pPlayer->FireBullets(9, vecSrc, vecAiming, M3_CONE_VECTOR, 3000, BULLET_PLAYER_BUCKSHOT, 0);
#endif

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireM3, 0, (float *)&g_vecZero, (float *)&g_vecZero, 0, 0, 0, 0, FALSE, FALSE);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		// HEV suit - indicate out of ammo condition
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif

	if (m_iClip != 0)
		m_flPumpTime = UTIL_WeaponTimeBase() + 0.5f;

	m_flNextPrimaryAttack = GetNextAttackDelay(0.875);
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.875f;

	if (m_iClip != 0)
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.5f;
	else
		m_flTimeWeaponIdle = 0.875f;

	m_fInSpecialReload = 0;

	if (m_pPlayer->pev->flags & FL_ONGROUND)
		m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomLong(m_pPlayer->random_seed + 1, 4, 6);
	else
		m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomLong(m_pPlayer->random_seed + 1, 8, 11);

	m_pPlayer->m_flEjectBrass = gpGlobals->time + 0.45f;
}

void CM3::Reload()
{
	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0 || m_iClip == iMaxClip())
		return;

	// don't reload until recoil is done
	if (m_flNextPrimaryAttack > UTIL_WeaponTimeBase())
		return;

	// check to see if we're ready to reload
	if (m_fInSpecialReload == 0)
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		SendWeaponAnim(M3_START_RELOAD, UseDecrement() != FALSE);

		m_fInSpecialReload = 1;
		m_flNextSecondaryAttack = m_flTimeWeaponIdle = m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.55f;
		m_flNextPrimaryAttack = GetNextAttackDelay(0.55);
	}
	else if (m_fInSpecialReload == 1)
	{
		if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
			return;

		// was waiting for gun to move to side
		m_fInSpecialReload = 2;
		SendWeaponAnim(M3_RELOAD, UseDecrement());

		m_flTimeWeaponIdle = m_flNextReload = UTIL_WeaponTimeBase() + 0.45f;
	}
	else
	{
		++m_iClip;

#ifdef REGAMEDLL_ADD
		if (refill_bpammo_weapons.value < 3.0f)
#endif
		{
			--m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType];
			--m_pPlayer->ammo_buckshot;
		}

		m_fInSpecialReload = 1;
	}
}

void CM3::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_5DEGREES);

	if (m_flPumpTime && m_flPumpTime < UTIL_WeaponTimeBase())
	{
		m_flPumpTime = 0;
	}

	if (m_flTimeWeaponIdle < UTIL_WeaponTimeBase())
	{
		if (m_iClip == 0 && m_fInSpecialReload == 0 && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
		{
			Reload();
		}
		else if (m_fInSpecialReload != 0)
		{
			if (m_iClip != iMaxClip() && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
			{
				Reload();
			}
			else
			{
				// reload debounce has timed out
				SendWeaponAnim(M3_PUMP, UseDecrement() != FALSE);

				m_fInSpecialReload = 0;
				m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.5f;
			}
		}
		else
		{
			SendWeaponAnim(M3_IDLE, UseDecrement() != FALSE);
		}
	}
}

```

`dlls/wpn_shared/wpn_m4a1.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_m4a1, CM4A1)

void CM4A1::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_m4a1");

	Precache();

	m_iId = WEAPON_M4A1;
	SET_MODEL(edict(), "models/w_m4a1.mdl");

	m_iDefaultAmmo = M4A1_DEFAULT_GIVE;
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;
	m_bDelayFire = true;

	FallInit();
}

void CM4A1::Precache()
{
	PRECACHE_MODEL("models/v_m4a1.mdl");
	PRECACHE_MODEL("models/w_m4a1.mdl");

	PRECACHE_SOUND("weapons/m4a1-1.wav");
	PRECACHE_SOUND("weapons/m4a1_unsil-1.wav");
	PRECACHE_SOUND("weapons/m4a1_unsil-2.wav");
	PRECACHE_SOUND("weapons/m4a1_clipin.wav");
	PRECACHE_SOUND("weapons/m4a1_clipout.wav");
	PRECACHE_SOUND("weapons/m4a1_boltpull.wav");
	PRECACHE_SOUND("weapons/m4a1_deploy.wav");
	PRECACHE_SOUND("weapons/m4a1_silencer_on.wav");
	PRECACHE_SOUND("weapons/m4a1_silencer_off.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireM4A1 = PRECACHE_EVENT(1, "events/m4a1.sc");
}

int CM4A1::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = MAX_AMMO_556NATO;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = M4A1_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 6;
	p->iId = m_iId = WEAPON_M4A1;
	p->iFlags = 0;
	p->iWeight = M4A1_WEIGHT;

	return 1;
}

BOOL CM4A1::Deploy()
{
	m_bDelayFire = true;
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;

	iShellOn = 1;

	if (m_iWeaponState & WPNSTATE_M4A1_SILENCED)
		return DefaultDeploy("models/v_m4a1.mdl", "models/p_m4a1.mdl", M4A1_DRAW, "rifle", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_m4a1.mdl", "models/p_m4a1.mdl", M4A1_UNSIL_DRAW, "rifle", UseDecrement() != FALSE);
}

void CM4A1::SecondaryAttack()
{
	if (m_iWeaponState & WPNSTATE_M4A1_SILENCED)
	{
		m_iWeaponState &= ~WPNSTATE_M4A1_SILENCED;
		SendWeaponAnim(M4A1_DETACH_SILENCER, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "rifle");
	}
	else
	{
		m_iWeaponState |= WPNSTATE_M4A1_SILENCED;
		SendWeaponAnim(M4A1_ATTACH_SILENCER, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "rifle");
	}

	m_flTimeWeaponIdle = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 2.0f;
	m_flNextPrimaryAttack = GetNextAttackDelay(2.0);
}

void CM4A1::PrimaryAttack()
{
	if (m_iWeaponState & WPNSTATE_M4A1_SILENCED)
	{
		if (!(m_pPlayer->pev->flags & FL_ONGROUND))
		{
			M4A1Fire(0.035 + (0.4 * m_flAccuracy), 0.0875, FALSE);
		}
		else if (m_pPlayer->pev->velocity.Length2D() > 140)
		{
			M4A1Fire(0.035 + (0.07 * m_flAccuracy), 0.0875, FALSE);
		}
		else
		{
			M4A1Fire(0.025 * m_flAccuracy, 0.0875, FALSE);
		}
	}
	else
	{
		if (!(m_pPlayer->pev->flags & FL_ONGROUND))
		{
			M4A1Fire(0.035 + (0.4 * m_flAccuracy), 0.0875, FALSE);
		}
		else if (m_pPlayer->pev->velocity.Length2D() > 140)
		{
			M4A1Fire(0.035 + (0.07 * m_flAccuracy), 0.0875, FALSE);
		}
		else
		{
			M4A1Fire(0.02 * m_flAccuracy, 0.0875, FALSE);
		}
	}
}

void CM4A1::M4A1Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 220) + 0.3f;

	if (m_flAccuracy > 1)
		m_flAccuracy = 1;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	if (m_iWeaponState & WPNSTATE_M4A1_SILENCED)
	{
		vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 2, BULLET_PLAYER_556MM,
			M4A1_DAMAGE_SIL, M4A1_RANGE_MODIFER_SIL, m_pPlayer->pev, false, m_pPlayer->random_seed);
	}
	else
	{
		vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 2, BULLET_PLAYER_556MM,
			M4A1_DAMAGE, M4A1_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

		m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	}

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

#ifndef REGAMEDLL_FIXES
	--m_pPlayer->ammo_556nato;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireM4A1, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), (m_iWeaponState & WPNSTATE_M4A1_SILENCED) == WPNSTATE_M4A1_SILENCED, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.5f;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(1.0, 0.45, 0.28, 0.045, 3.75, 3.0, 7);
	}
	else if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(1.2, 0.5, 0.23, 0.15, 5.5, 3.5, 6);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.6, 0.3, 0.2, 0.0125, 3.25, 2.0, 7);
	}
	else
	{
		KickBack(0.65, 0.35, 0.25, 0.015, 3.5, 2.25, 7);
	}
}

void CM4A1::Reload()
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(iMaxClip(), ((m_iWeaponState & WPNSTATE_M4A1_SILENCED) == WPNSTATE_M4A1_SILENCED) ? M4A1_RELOAD : M4A1_UNSIL_RELOAD, M4A1_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2f;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CM4A1::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
	SendWeaponAnim((m_iWeaponState & WPNSTATE_M4A1_SILENCED) == WPNSTATE_M4A1_SILENCED ? M4A1_IDLE : M4A1_UNSIL_IDLE, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_mac10.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_mac10, CMAC10)

void CMAC10::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_mac10");

	Precache();

	m_iId = WEAPON_MAC10;
	SET_MODEL(edict(), "models/w_mac10.mdl");

	m_iDefaultAmmo = MAC10_DEFAULT_GIVE;
	m_flAccuracy = 0.15f;
	m_bDelayFire = false;

	FallInit();
}

void CMAC10::Precache()
{
	PRECACHE_MODEL("models/v_mac10.mdl");
	PRECACHE_MODEL("models/w_mac10.mdl");

	PRECACHE_SOUND("weapons/mac10-1.wav");
	PRECACHE_SOUND("weapons/mac10_clipout.wav");
	PRECACHE_SOUND("weapons/mac10_clipin.wav");
	PRECACHE_SOUND("weapons/mac10_boltpull.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireMAC10 = PRECACHE_EVENT(1, "events/mac10.sc");
}

int CMAC10::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "45acp";
	p->iMaxAmmo1 = MAX_AMMO_45ACP;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = MAC10_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 13;
	p->iId = m_iId = WEAPON_MAC10;
	p->iFlags = 0;
	p->iWeight = MAC10_WEIGHT;

	return 1;
}

BOOL CMAC10::Deploy()
{
	m_flAccuracy = 0.15f;
	iShellOn = 1;
	m_bDelayFire = false;

	return DefaultDeploy("models/v_mac10.mdl", "models/p_mac10.mdl", MAC10_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CMAC10::PrimaryAttack()
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		MAC10Fire(0.375 * m_flAccuracy, 0.07, FALSE);
	}
	else
	{
		MAC10Fire(0.03 * m_flAccuracy, 0.07, FALSE);
	}
}

void CMAC10::MAC10Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 200) + 0.6f;

	if (m_flAccuracy > 1.65f)
		m_flAccuracy = 1.65f;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 1, BULLET_PLAYER_45ACP,
		MAC10_DAMAGE, MAC10_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireMAC10, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;

	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(1.3, 0.55, 0.4, 0.05, 4.75, 3.75, 5);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(0.9, 0.45, 0.25, 0.035, 3.5, 2.75, 7);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.75, 0.4, 0.175, 0.03, 2.75, 2.5, 10);
	}
	else
	{
		KickBack(0.775, 0.425, 0.2, 0.03, 3.0, 2.75, 9);
	}
}

void CMAC10::Reload()
{
	if (m_pPlayer->ammo_45acp <= 0)
		return;

	if (DefaultReload(iMaxClip(), MAC10_RELOAD, MAC10_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0;
		m_iShotsFired = 0;
	}
}

void CMAC10::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
	SendWeaponAnim(MAC10_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_mp5navy.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_mp5navy, CMP5N)

void CMP5N::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_mp5navy");

	Precache();

	m_iId = WEAPON_MP5N;
	SET_MODEL(edict(), "models/w_mp5.mdl");

	m_iDefaultAmmo = MP5NAVY_DEFAULT_GIVE;
	m_flAccuracy = 0.0f;
	m_bDelayFire = false;

	FallInit();
}

void CMP5N::Precache()
{
	PRECACHE_MODEL("models/v_mp5.mdl");
	PRECACHE_MODEL("models/w_mp5.mdl");

	PRECACHE_SOUND("weapons/mp5-1.wav");
	PRECACHE_SOUND("weapons/mp5-2.wav");
	PRECACHE_SOUND("weapons/mp5_clipout.wav");
	PRECACHE_SOUND("weapons/mp5_clipin.wav");
	PRECACHE_SOUND("weapons/mp5_slideback.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireMP5N = PRECACHE_EVENT(1, "events/mp5n.sc");
}

int CMP5N::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "9mm";
	p->iMaxAmmo1 = MAX_AMMO_9MM;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = MP5N_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 7;
	p->iId = m_iId = WEAPON_MP5N;
	p->iFlags = 0;
	p->iWeight = MP5NAVY_WEIGHT;

	return 1;
}

BOOL CMP5N::Deploy()
{
	m_flAccuracy = 0.0f;
	m_bDelayFire = false;
	iShellOn = 1;

	return DefaultDeploy("models/v_mp5.mdl", "models/p_mp5.mdl", MP5N_DRAW, "mp5", UseDecrement() != FALSE);
}

void CMP5N::PrimaryAttack()
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		MP5NFire(0.2 * m_flAccuracy, 0.075, FALSE);
	}
	else
	{
		MP5NFire(0.04 * m_flAccuracy, 0.075, FALSE);
	}
}

void CMP5N::MP5NFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = ((m_iShotsFired * m_iShotsFired) / 220.1) + 0.45f;

	if (m_flAccuracy > 0.75f)
		m_flAccuracy = 0.75f;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 1, BULLET_PLAYER_9MM,
		MP5N_DAMAGE, MP5N_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireMP5N, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;

	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(0.9, 0.475, 0.35, 0.0425, 5.0, 3.0, 6);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(0.5, 0.275, 0.2, 0.03, 3.0, 2.0, 10);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.225, 0.15, 0.1, 0.015, 2.0, 1.0, 10);
	}
	else
	{
		KickBack(0.25, 0.175, 0.125, 0.02, 2.25, 1.25, 10);
	}
}

void CMP5N::Reload()
{
	if (m_pPlayer->ammo_9mm <= 0)
		return;

	if (DefaultReload(iMaxClip(), MP5N_RELOAD, MP5N_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0;
		m_iShotsFired = 0;
	}
}

void CMP5N::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
	SendWeaponAnim(MP5N_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_p228.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_p228, CP228)

void CP228::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_p228");

	Precache();

	m_iId = WEAPON_P228;
	SET_MODEL(ENT(pev), "models/w_p228.mdl");

	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_iDefaultAmmo = P228_DEFAULT_GIVE;
	m_flAccuracy = 0.9f;

	FallInit();
}

void CP228::Precache()
{
	PRECACHE_MODEL("models/v_p228.mdl");
	PRECACHE_MODEL("models/w_p228.mdl");
	PRECACHE_MODEL("models/shield/v_shield_p228.mdl");

	PRECACHE_SOUND("weapons/p228-1.wav");
	PRECACHE_SOUND("weapons/p228_clipout.wav");
	PRECACHE_SOUND("weapons/p228_clipin.wav");
	PRECACHE_SOUND("weapons/p228_sliderelease.wav");
	PRECACHE_SOUND("weapons/p228_slidepull.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireP228 = PRECACHE_EVENT(1, "events/p228.sc");
}

int CP228::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "357SIG";
	p->iMaxAmmo1 = MAX_AMMO_357SIG;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = P228_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 3;
	p->iId = m_iId = WEAPON_P228;
	p->iFlags = 0;
	p->iWeight = P228_WEIGHT;

	return 1;
}

BOOL CP228::Deploy()
{
	m_flAccuracy = 0.9f;
	m_fMaxSpeed = P228_MAX_SPEED;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield())
		return DefaultDeploy("models/shield/v_shield_p228.mdl", "models/shield/p_shield_p228.mdl", P228_SHIELD_DRAW, "shieldgun", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_p228.mdl", "models/p_p228.mdl", P228_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CP228::PrimaryAttack()
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		P228Fire(1.5 * (1 - m_flAccuracy), 0.2, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		P228Fire(0.255 * (1 - m_flAccuracy), 0.2, FALSE);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		P228Fire(0.075 * (1 - m_flAccuracy), 0.2, FALSE);
	}
	else
	{
		P228Fire(0.15 * (1 - m_flAccuracy), 0.2, FALSE);
	}
}

void CP228::SecondaryAttack()
{
	ShieldSecondaryFire(SHIELDGUN_UP, SHIELDGUN_DOWN);
}

void CP228::P228Fire(float flSpread, float flCycleTime, BOOL fUseSemi)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	flCycleTime -= 0.05f;

	if (++m_iShotsFired > 1)
	{
		return;
	}

	if (m_flLastFire != 0.0f)
	{
		m_flAccuracy -= (0.325f - (gpGlobals->time - m_flLastFire)) * 0.3f;

		if (m_flAccuracy > 0.9f)
		{
			m_flAccuracy = 0.9f;
		}
		else if (m_flAccuracy < 0.6f)
		{
			m_flAccuracy = 0.6f;
		}
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	SetPlayerShieldAnim();

#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 4096, 1, BULLET_PLAYER_357SIG, P228_DAMAGE, P228_RANGE_MODIFER, m_pPlayer->pev, true, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireP228, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), m_iClip == 0, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, FALSE);
	}
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;
	m_pPlayer->pev->punchangle.x -= 2;
	ResetPlayerShieldAnim();
}

void CP228::Reload()
{
	if (m_pPlayer->ammo_357sig <= 0)
		return;

	if (DefaultReload(iMaxClip(), m_pPlayer->HasShield() ? (int)P228_SHIELD_RELOAD : (int)P228_RELOAD, P228_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.9f;
	}
}

void CP228::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	if (m_pPlayer->HasShield())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;

		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		{
			SendWeaponAnim(P228_SHIELD_IDLE_UP, UseDecrement() != FALSE);
		}
	}
	else if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 3.0625f;
		SendWeaponAnim(P228_IDLE, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_p90.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_p90, CP90)

void CP90::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_p90");

	Precache();

	m_iId = WEAPON_P90;
	SET_MODEL(edict(), "models/w_p90.mdl");

	m_iDefaultAmmo = P90_DEFAULT_GIVE;
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;
	m_bDelayFire = false;

	FallInit();
}

void CP90::Precache()
{
	PRECACHE_MODEL("models/v_p90.mdl");
	PRECACHE_MODEL("models/w_p90.mdl");

	PRECACHE_SOUND("weapons/p90-1.wav");
	PRECACHE_SOUND("weapons/p90_clipout.wav");
	PRECACHE_SOUND("weapons/p90_clipin.wav");
	PRECACHE_SOUND("weapons/p90_boltpull.wav");
	PRECACHE_SOUND("weapons/p90_cliprelease.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireP90 = PRECACHE_EVENT(1, "events/p90.sc");
}

int CP90::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "57mm";
	p->iMaxAmmo1 = MAX_AMMO_57MM;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = P90_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 8;
	p->iId = m_iId = WEAPON_P90;
	p->iFlags = 0;
	p->iWeight = P90_WEIGHT;

	return 1;
}

BOOL CP90::Deploy()
{
	m_iShotsFired = 0;
	m_bDelayFire = false;
	m_flAccuracy = 0.2f;

	iShellOn = 1;

	return DefaultDeploy("models/v_p90.mdl", "models/p_p90.mdl", P90_DRAW, "carbine", UseDecrement() != FALSE);
}

void CP90::PrimaryAttack()
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		P90Fire(0.3 * m_flAccuracy, 0.066, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 170)
	{
		P90Fire(0.115 * m_flAccuracy, 0.066, FALSE);
	}
	else
	{
		P90Fire(0.045 * m_flAccuracy, 0.066, FALSE);
	}
}

void CP90::P90Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = (m_iShotsFired * m_iShotsFired / 175) + 0.45f;

	if (m_flAccuracy > 1)
		m_flAccuracy = 1;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 1, BULLET_PLAYER_57MM, P90_DAMAGE, P90_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireP90, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), 5, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;

	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(0.9, 0.45, 0.35, 0.04, 5.25, 3.5, 4);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(0.45, 0.3, 0.2, 0.0275, 4.0, 2.25, 7);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.275, 0.2, 0.125, 0.02, 3.0, 1.0, 9);
	}
	else
	{
		KickBack(0.3, 0.225, 0.125, 0.02, 3.25, 1.25, 8);
	}
}

void CP90::Reload()
{
	if (m_pPlayer->ammo_57mm <= 0)
		return;

	if (DefaultReload(iMaxClip(), P90_RELOAD, P90_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2f;
		m_iShotsFired = 0;
	}
}

void CP90::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
	SendWeaponAnim(P90_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_scout.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_scout, CSCOUT)

void CSCOUT::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_scout");

	Precache();

	m_iId = WEAPON_SCOUT;
	SET_MODEL(edict(), "models/w_scout.mdl");

	m_iDefaultAmmo = SCOUT_DEFAULT_GIVE;

	FallInit();
}

void CSCOUT::Precache()
{
	PRECACHE_MODEL("models/v_scout.mdl");
	PRECACHE_MODEL("models/w_scout.mdl");

	PRECACHE_SOUND("weapons/scout_fire-1.wav");
	PRECACHE_SOUND("weapons/scout_bolt.wav");
	PRECACHE_SOUND("weapons/scout_clipin.wav");
	PRECACHE_SOUND("weapons/scout_clipout.wav");
	PRECACHE_SOUND("weapons/zoom.wav");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/rshell_big.mdl");
	m_usFireScout = PRECACHE_EVENT(1, "events/scout.sc");
}

int CSCOUT::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "762Nato";
	p->iMaxAmmo1 = MAX_AMMO_762NATO;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = SCOUT_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 9;
	p->iId = m_iId = WEAPON_SCOUT;
	p->iFlags = 0;
	p->iWeight = SCOUT_WEIGHT;

	return 1;
}

BOOL CSCOUT::Deploy()
{
	if (DefaultDeploy("models/v_scout.mdl", "models/p_scout.mdl", SCOUT_DRAW, "rifle", UseDecrement() != FALSE))
	{
		m_flNextPrimaryAttack = m_pPlayer->m_flNextAttack = GetNextAttackDelay(1.25);
		m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.0f;

		return TRUE;
	}

	return FALSE;
}

void CSCOUT::SecondaryAttack()
{
	switch (m_pPlayer->m_iFOV)
	{
	case 90: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 40; break;
	case 40: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 15; break;
#ifdef REGAMEDLL_FIXES
	default:
#else
	case 15:
#endif
		m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 90; break;
	}

#ifndef CLIENT_DLL
	if (TheBots != NULL)
	{
		TheBots->OnEvent(EVENT_WEAPON_ZOOMED, m_pPlayer);
	}
#endif

	m_pPlayer->ResetMaxSpeed();
	EMIT_SOUND(m_pPlayer->edict(), CHAN_ITEM, "weapons/zoom.wav", 0.2, 2.4);
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CSCOUT::PrimaryAttack()
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		SCOUTFire(0.2, 1.25, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 170)
	{
		SCOUTFire(0.075, 1.25, FALSE);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		SCOUTFire(0, 1.25, FALSE);
	}
	else
	{
		SCOUTFire(0.007, 1.25, FALSE);
	}
}

void CSCOUT::SCOUTFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	if (m_pPlayer->pev->fov != DEFAULT_FOV)
	{
		m_pPlayer->m_bResumeZoom = true;
		m_pPlayer->m_iLastZoom = m_pPlayer->m_iFOV;

		// reset a fov
		m_pPlayer->m_iFOV = DEFAULT_FOV;
	}
	else
	{
		flSpread += 0.025f;
	}

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_flEjectBrass = gpGlobals->time + 0.56f;
	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = NORMAL_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 3, BULLET_PLAYER_762MM, SCOUT_DAMAGE, SCOUT_RANGE_MODIFER, m_pPlayer->pev, true, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireScout, 0, (float *)&g_vecZero, (float *)&m_pPlayer->pev->angles, (vecDir.x * 1000), (vecDir.y * 1000),
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.x * 100), FALSE, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.8f;
	m_pPlayer->pev->punchangle.x -= 2.0f;
}

void CSCOUT::Reload()
{
#ifdef REGAMEDLL_FIXES
	// to prevent reload if not enough ammo
	if (m_pPlayer->ammo_762nato <= 0)
		return;
#endif

	if (DefaultReload(iMaxClip(), SCOUT_RELOAD, SCOUT_RELOAD_TIME))
	{
		if (m_pPlayer->pev->fov != DEFAULT_FOV)
		{
			m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 15;
			SecondaryAttack();
		}

#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
	}
}

void CSCOUT::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60.0f;
		SendWeaponAnim(SCOUT_IDLE, UseDecrement() != FALSE);
	}
}

float CSCOUT::GetMaxSpeed()
{
	return (m_pPlayer->m_iFOV == DEFAULT_FOV) ? SCOUT_MAX_SPEED : SCOUT_MAX_SPEED_ZOOM;
}

```

`dlls/wpn_shared/wpn_sg550.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_sg550, CSG550)

void CSG550::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_sg550");
	Precache();

	m_iId = WEAPON_SG550;
	SET_MODEL(edict(), "models/w_sg550.mdl");

	m_iDefaultAmmo = SG550_DEFAULT_GIVE;
	m_flLastFire = 0;

	FallInit();
}

void CSG550::Precache()
{
	PRECACHE_MODEL("models/v_sg550.mdl");
	PRECACHE_MODEL("models/w_sg550.mdl");

	PRECACHE_SOUND("weapons/sg550-1.wav");
	PRECACHE_SOUND("weapons/sg550_boltpull.wav");
	PRECACHE_SOUND("weapons/sg550_clipin.wav");
	PRECACHE_SOUND("weapons/sg550_clipout.wav");
	PRECACHE_SOUND("weapons/zoom.wav");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireSG550 = PRECACHE_EVENT(1, "events/sg550.sc");
}

int CSG550::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = MAX_AMMO_556NATO;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = SG550_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 16;
	p->iId = m_iId = WEAPON_SG550;
	p->iFlags = 0;
	p->iWeight = SG550_WEIGHT;

	return 1;
}

BOOL CSG550::Deploy()
{
	return DefaultDeploy("models/v_sg550.mdl", "models/p_sg550.mdl", SG550_DRAW, "rifle", UseDecrement() != FALSE);
}

void CSG550::SecondaryAttack()
{
	switch (m_pPlayer->m_iFOV)
	{
	case 90: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 40; break;
	case 40: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 15; break;
#ifdef REGAMEDLL_FIXES
	default:
#else
	case 15:
#endif
		m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 90; break;
	}

	m_pPlayer->ResetMaxSpeed();

#ifndef CLIENT_DLL
	if (TheBots != NULL)
	{
		TheBots->OnEvent(EVENT_WEAPON_ZOOMED, m_pPlayer);
	}
#endif

	EMIT_SOUND(m_pPlayer->edict(), CHAN_ITEM, "weapons/zoom.wav", 0.2, 2.4);
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CSG550::PrimaryAttack()
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		SG550Fire(0.45 * (1 - m_flAccuracy), 0.25, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		SG550Fire(0.15, 0.25, FALSE);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		SG550Fire(0.04 * (1 - m_flAccuracy), 0.25, FALSE);
	}
	else
	{
		SG550Fire(0.05 * (1 - m_flAccuracy), 0.25, FALSE);
	}
}

void CSG550::SG550Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	if (m_pPlayer->pev->fov == DEFAULT_FOV)
	{
		flSpread += 0.025f;
	}

	if (m_flLastFire)
	{
		m_flAccuracy = (gpGlobals->time - m_flLastFire) * 0.35f + 0.65f;

		if (m_flAccuracy > 0.98f)
		{
			m_flAccuracy = 0.98f;
		}
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = NORMAL_GUN_FLASH;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 2, BULLET_PLAYER_556MM, SG550_DAMAGE, SG550_RANGE_MODIFER, m_pPlayer->pev, true, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireSG550, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.x * 100), 5, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.8f;

	m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomFloat(m_pPlayer->random_seed + 4, 0.75, 1.25) + m_pPlayer->pev->punchangle.x * 0.25;
	m_pPlayer->pev->punchangle.y += UTIL_SharedRandomFloat(m_pPlayer->random_seed + 5, -0.75, 0.75);
}

void CSG550::Reload()
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(iMaxClip(), SG550_RELOAD, SG550_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		if (m_pPlayer->pev->fov != DEFAULT_FOV)
		{
			m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 15;
			SecondaryAttack();
		}
	}
}

void CSG550::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60.0f;
		SendWeaponAnim(SG550_IDLE, UseDecrement() != FALSE);
	}
}

float CSG550::GetMaxSpeed()
{
	return (m_pPlayer->m_iFOV == DEFAULT_FOV) ? SG550_MAX_SPEED : SG550_MAX_SPEED_ZOOM;
}

```

`dlls/wpn_shared/wpn_sg552.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_sg552, CSG552)

void CSG552::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_sg552");

	Precache();

	m_iId = WEAPON_SG552;
	SET_MODEL(edict(), "models/w_sg552.mdl");

	m_iDefaultAmmo = SG552_DEFAULT_GIVE;
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;

	FallInit();
}

void CSG552::Precache()
{
	PRECACHE_MODEL("models/v_sg552.mdl");
	PRECACHE_MODEL("models/w_sg552.mdl");

	PRECACHE_SOUND("weapons/sg552-1.wav");
	PRECACHE_SOUND("weapons/sg552-2.wav");
	PRECACHE_SOUND("weapons/sg552_clipout.wav");
	PRECACHE_SOUND("weapons/sg552_clipin.wav");
	PRECACHE_SOUND("weapons/sg552_boltpull.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireSG552 = PRECACHE_EVENT(1, "events/sg552.sc");
}

int CSG552::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = MAX_AMMO_556NATO;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = SG552_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 10;
	p->iId = m_iId = WEAPON_SG552;
	p->iFlags = 0;
	p->iWeight = SG552_WEIGHT;

	return 1;
}

BOOL CSG552::Deploy()
{
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;
	iShellOn = 1;

	return DefaultDeploy("models/v_sg552.mdl", "models/p_sg552.mdl", SG552_DRAW, "mp5", UseDecrement() != FALSE);
}

void CSG552::SecondaryAttack()
{
	if (m_pPlayer->m_iFOV == DEFAULT_FOV)
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 55;
	else
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 90;

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3f;
}

void CSG552::PrimaryAttack()
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		SG552Fire(0.035 + (0.45 * m_flAccuracy), 0.0825, FALSE);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
	{
		SG552Fire(0.035 + (0.075 * m_flAccuracy), 0.0825, FALSE);
	}
	else if (m_pPlayer->pev->fov == DEFAULT_FOV)
	{
		SG552Fire(0.02 * m_flAccuracy, 0.0825, FALSE);
	}
	else
	{
		SG552Fire(0.02 * m_flAccuracy, 0.135, FALSE);
	}
}

void CSG552::SG552Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	m_iShotsFired++;

	m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 220) + 0.3f;

	if (m_flAccuracy > 1.0f)
		m_flAccuracy = 1.0f;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 2, BULLET_PLAYER_556MM,
		SG552_DAMAGE, SG552_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireSG552, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), 5, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(1.0, 0.45, 0.28, 0.04, 4.25, 2.5, 7);
	}
	else if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(1.25, 0.45, 0.22, 0.18, 6.0, 4.0, 5);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.6, 0.35, 0.2, 0.0125, 3.7, 2.0, 10);
	}
	else
	{
		KickBack(0.625, 0.375, 0.25, 0.0125, 4.0, 2.25, 9);
	}
}

void CSG552::Reload()
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(iMaxClip(), SG552_RELOAD, SG552_RELOAD_TIME))
	{
		if (m_pPlayer->m_iFOV != DEFAULT_FOV)
		{
			SecondaryAttack();
		}

#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2f;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CSG552::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
	SendWeaponAnim(SG552_IDLE1, UseDecrement() != FALSE);
}

float CSG552::GetMaxSpeed()
{
	if (m_pPlayer->m_iFOV == DEFAULT_FOV)
		return SG552_MAX_SPEED;

	return SG552_MAX_SPEED_ZOOM;
}

```

`dlls/wpn_shared/wpn_smokegrenade.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_smokegrenade, CSmokeGrenade)

void CSmokeGrenade::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_smokegrenade");

	Precache();

	m_iId = WEAPON_SMOKEGRENADE;
	SET_MODEL(edict(), "models/w_smokegrenade.mdl");

	pev->dmg = 4;

	m_iDefaultAmmo = SMOKEGRENADE_DEFAULT_GIVE;
	m_flStartThrow = 0;
	m_flReleaseThrow = -1;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	// get ready to fall down.
	FallInit();
}

void CSmokeGrenade::Precache()
{
	PRECACHE_MODEL("models/v_smokegrenade.mdl");
	PRECACHE_MODEL("models/shield/v_shield_smokegrenade.mdl");

	PRECACHE_SOUND("weapons/pinpull.wav");
	PRECACHE_SOUND("weapons/sg_explode.wav");

	m_usCreateSmoke = PRECACHE_EVENT(1, "events/createsmoke.sc");
}

int CSmokeGrenade::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "SmokeGrenade";

	p->iMaxAmmo1 = MAX_AMMO_SMOKEGRENADE;
	p->iMaxClip = WEAPON_NOCLIP;

	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iSlot = 3;
	p->iPosition = 3;
	p->iId = m_iId = WEAPON_SMOKEGRENADE;
	p->iWeight = SMOKEGRENADE_WEIGHT;
	p->iFlags = ITEM_FLAG_LIMITINWORLD | ITEM_FLAG_EXHAUSTIBLE;

	return 1;
}

BOOL CSmokeGrenade::Deploy()
{
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	m_flReleaseThrow = -1;
	m_fMaxSpeed = SMOKEGRENADE_MAX_SPEED;

	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield())
		return DefaultDeploy("models/shield/v_shield_smokegrenade.mdl", "models/shield/p_shield_smokegrenade.mdl", SMOKEGRENADE_DRAW, "shieldgren", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_smokegrenade.mdl", "models/p_smokegrenade.mdl", SMOKEGRENADE_DRAW, "grenade", UseDecrement() != FALSE);
}

void CSmokeGrenade::Holster(int skiplocal)
{
	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.5f;

	if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		// no more smokegrenades!
		// clear the smokegrenade of bits for HUD
		m_pPlayer->pev->weapons &= ~(1 << WEAPON_SMOKEGRENADE);
		DestroyItem();
	}

	m_flStartThrow = 0;
	m_flReleaseThrow = -1;
}

void CSmokeGrenade::PrimaryAttack()
{
	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		return;

	if (!m_flStartThrow && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] > 0)
	{
		m_flReleaseThrow = 0;
		m_flStartThrow = gpGlobals->time;

		SendWeaponAnim(SMOKEGRENADE_PINPULL, UseDecrement() != FALSE);
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.5f;
	}
}

bool CSmokeGrenade::ShieldSecondaryFire(int iUpAnim, int iDownAnim)
{
	if (!m_pPlayer->HasShield() || m_flStartThrow > 0)
	{
		return false;
	}

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(iDownAnim, UseDecrement() != FALSE);

		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");

		m_fMaxSpeed = SMOKEGRENADE_MAX_SPEED;
		m_pPlayer->m_bShieldDrawn = false;
	}
	else
	{
		m_iWeaponState |= WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(iUpAnim, UseDecrement() != FALSE);

		strcpy(m_pPlayer->m_szAnimExtention, "shielded");

		m_fMaxSpeed = SMOKEGRENADE_MAX_SPEED_SHIELD;
		m_pPlayer->m_bShieldDrawn = true;
	}

#ifndef CLIENT_DLL
	m_pPlayer->UpdateShieldCrosshair((m_iWeaponState & WPNSTATE_SHIELD_DRAWN) != WPNSTATE_SHIELD_DRAWN);
#endif
	m_pPlayer->ResetMaxSpeed();

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.4f;
	m_flNextPrimaryAttack = GetNextAttackDelay(0.4);
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.6f;

	return true;
}

void CSmokeGrenade::SecondaryAttack()
{
	ShieldSecondaryFire(SHIELDGUN_DRAW, SHIELDGUN_DRAWN_IDLE);
}

void CSmokeGrenade::SetPlayerShieldAnim()
{
	if (!m_pPlayer->HasShield())
		return;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		strcpy(m_pPlayer->m_szAnimExtention, "shield");
	else
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
}

void CSmokeGrenade::ResetPlayerShieldAnim()
{
	if (!m_pPlayer->HasShield())
		return;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
	}
}

void CSmokeGrenade::WeaponIdle()
{
	if (m_flReleaseThrow == 0)
		m_flReleaseThrow = gpGlobals->time;

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_flStartThrow)
	{
		m_pPlayer->Radio("%!MRAD_FIREINHOLE", "#Fire_in_the_hole");

		Vector angThrow = m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle;

		if (angThrow.x < 0)
			angThrow.x = -10 + angThrow.x * ((90 - 10) / 90.0);
		else
			angThrow.x = -10 + angThrow.x * ((90 + 10) / 90.0);

		float flVel = (90.0f - angThrow.x) * 6.0f;

		if (flVel > 750.0f)
			flVel = 750.0f;

		UTIL_MakeVectors(angThrow);

		Vector vecSrc = m_pPlayer->pev->origin + m_pPlayer->pev->view_ofs + gpGlobals->v_forward * 16.0f;
		Vector vecThrow = gpGlobals->v_forward * flVel + m_pPlayer->pev->velocity;

		CGrenade::ShootSmokeGrenade(m_pPlayer->pev, vecSrc, vecThrow, 1.5, m_usCreateSmoke);

		SendWeaponAnim(SMOKEGRENADE_THROW, UseDecrement() != FALSE);
		SetPlayerShieldAnim();

#ifndef CLIENT_DLL
		// player "shoot" animation
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		m_flStartThrow = 0;
		m_flNextPrimaryAttack = GetNextAttackDelay(0.5);
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.75f;

		if (--m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		{
			// just threw last grenade
			// set attack times in the future, and weapon idle in the future so we can see the whole throw
			// animation, weapon idle will automatically retire the weapon for us.
			// ensure that the animation can finish playing
			m_flTimeWeaponIdle = m_flNextSecondaryAttack = m_flNextPrimaryAttack = GetNextAttackDelay(0.5);
		}

		ResetPlayerShieldAnim();
	}
	else if (m_flReleaseThrow > 0)
	{
		// we've finished the throw, restart.
		m_flStartThrow = 0;

		if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
		{
			SendWeaponAnim(SMOKEGRENADE_DRAW, UseDecrement() != FALSE);
		}
		else
		{
			RetireWeapon();
			return;
		}

		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
		m_flReleaseThrow = -1;
	}
	else if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		int iAnim;
		float flRand = RANDOM_FLOAT(0, 1);

		if (m_pPlayer->HasShield())
		{
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;

			if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			{
				SendWeaponAnim(SHIELDREN_IDLE, UseDecrement() != FALSE);
			}
		}
		else
		{
			if (flRand <= 0.75)
			{
				iAnim = SMOKEGRENADE_IDLE;

				// how long till we do this again.
				m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
			}
			else
			{
				iAnim = SMOKEGRENADE_IDLE;
				m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 75.0f / 30.0f;
			}

			SendWeaponAnim(iAnim, UseDecrement() != FALSE);
		}
	}
}

BOOL CSmokeGrenade::CanDeploy()
{
	return m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] != 0;
}

```

`dlls/wpn_shared/wpn_tmp.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_tmp, CTMP)

void CTMP::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_tmp");

	Precache();

	m_iId = WEAPON_TMP;
	SET_MODEL(edict(), "models/w_tmp.mdl");

	m_iDefaultAmmo = TMP_DEFAULT_GIVE;
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;
	m_bDelayFire = false;

	FallInit();
}

void CTMP::Precache()
{
	PRECACHE_MODEL("models/v_tmp.mdl");
	PRECACHE_MODEL("models/w_tmp.mdl");

	PRECACHE_SOUND("weapons/tmp-1.wav");
	PRECACHE_SOUND("weapons/tmp-2.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireTMP = PRECACHE_EVENT(1, "events/tmp.sc");
}

int CTMP::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "9mm";
	p->iMaxAmmo1 = MAX_AMMO_9MM;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = TMP_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 11;
	p->iId = m_iId = WEAPON_TMP;
	p->iFlags = 0;
	p->iWeight = TMP_WEIGHT;

	return 1;
}

BOOL CTMP::Deploy()
{
	m_flAccuracy = 0.2f;
	m_iShotsFired = 0;
	m_bDelayFire = false;
	iShellOn = 1;

	return DefaultDeploy("models/v_tmp.mdl", "models/p_tmp.mdl", TMP_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CTMP::PrimaryAttack()
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		TMPFire(0.25 * m_flAccuracy, 0.07, FALSE);
	}
	else
	{
		TMPFire(0.03 * m_flAccuracy, 0.07, FALSE);
	}
}

void CTMP::TMPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 200) + 0.55f;

	if (m_flAccuracy > 1.4f)
		m_flAccuracy = 1.4f;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	--m_iClip;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 1, BULLET_PLAYER_9MM,
		TMP_DAMAGE, TMP_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireTMP, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), 5, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;

	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(1.1, 0.5, 0.35, 0.045, 4.5, 3.5, 6);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(0.8, 0.4, 0.2, 0.03, 3.0, 2.5, 7);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.7, 0.35, 0.125, 0.025, 2.5, 2.0, 10);
	}
	else
	{
		KickBack(0.725, 0.375, 0.15, 0.025, 2.75, 2.25, 9);
	}
}

void CTMP::Reload()
{
#ifdef REGAMEDLL_FIXES
	// to prevent reload if not enough ammo
	if (m_pPlayer->ammo_9mm <= 0)
		return;
#endif

	if (DefaultReload(iMaxClip(), TMP_RELOAD, TMP_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2f;
		m_iShotsFired = 0;
	}
}

void CTMP::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
	SendWeaponAnim(TMP_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_ump45.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_ump45, CUMP45)

void CUMP45::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_ump45");

	Precache();

	m_iId = WEAPON_UMP45;
	SET_MODEL(edict(), "models/w_ump45.mdl");

	m_iDefaultAmmo = UMP45_DEFAULT_GIVE;
	m_flAccuracy = 0.0f;
	m_bDelayFire = false;

	FallInit();
}

void CUMP45::Precache()
{
	PRECACHE_MODEL("models/v_ump45.mdl");
	PRECACHE_MODEL("models/w_ump45.mdl");

	PRECACHE_SOUND("weapons/ump45-1.wav");
	PRECACHE_SOUND("weapons/ump45_clipout.wav");
	PRECACHE_SOUND("weapons/ump45_clipin.wav");
	PRECACHE_SOUND("weapons/ump45_boltslap.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireUMP45 = PRECACHE_EVENT(1, "events/ump45.sc");
}

int CUMP45::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
#ifdef REGAMEDLL_FIXES
	p->pszAmmo1 = "45acp";
#else
	p->pszAmmo1 = "45ACP";
#endif
	p->iMaxAmmo1 = MAX_AMMO_45ACP;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = UMP45_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 15;
	p->iId = m_iId = WEAPON_UMP45;
	p->iFlags = 0;
	p->iWeight = UMP45_WEIGHT;

	return 1;
}

BOOL CUMP45::Deploy()
{
	m_flAccuracy = 0.0f;
	m_bDelayFire = false;
	iShellOn = 1;

	return DefaultDeploy("models/v_ump45.mdl", "models/p_ump45.mdl", UMP45_DRAW, "carbine", UseDecrement() != FALSE);
}

void CUMP45::PrimaryAttack()
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		UMP45Fire(0.24 * m_flAccuracy, 0.1, FALSE);
	}
	else
	{
		UMP45Fire(0.04 * m_flAccuracy, 0.1, FALSE);
	}
}

void CUMP45::UMP45Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	m_bDelayFire = true;
	++m_iShotsFired;

	m_flAccuracy = ((m_iShotsFired * m_iShotsFired) / 210) + 0.5f;

	if (m_flAccuracy > 1.0f)
		m_flAccuracy = 1.0f;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif
		return;
	}

	--m_iClip;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 8192, 1, BULLET_PLAYER_45ACP,
		UMP45_DAMAGE, UMP45_RANGE_MODIFER, m_pPlayer->pev, false, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireUMP45, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		int(m_pPlayer->pev->punchangle.x * 100), int(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;

	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
	{
		KickBack(0.125, 0.65, 0.55, 0.0475, 5.5, 4.0, 10);
	}
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
	{
		KickBack(0.55, 0.3, 0.225, 0.03, 3.5, 2.5, 10);
	}
	else if (m_pPlayer->pev->flags & FL_DUCKING)
	{
		KickBack(0.25, 0.175, 0.125, 0.02, 2.25, 1.25, 10);
	}
	else
	{
		KickBack(0.275, 0.2, 0.15, 0.0225, 2.5, 1.5, 10);
	}
}

void CUMP45::Reload()
{
	if (m_pPlayer->ammo_45acp <= 0)
		return;

	if (DefaultReload(iMaxClip(), UMP45_RELOAD, UMP45_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.0f;
		m_iShotsFired = 0;
	}
}

void CUMP45::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
	{
		return;
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;
	SendWeaponAnim(UMP45_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_usp.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_usp, CUSP)

void CUSP::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_usp");

	Precache();

	m_iId = WEAPON_USP;
	SET_MODEL(ENT(pev), "models/w_usp.mdl");

	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_iDefaultAmmo = USP_DEFAULT_GIVE;
	m_flAccuracy = 0.92f;

	FallInit();
}

void CUSP::Precache()
{
	PRECACHE_MODEL("models/v_usp.mdl");
	PRECACHE_MODEL("models/w_usp.mdl");
	PRECACHE_MODEL("models/shield/v_shield_usp.mdl");

	PRECACHE_SOUND("weapons/usp1.wav");
	PRECACHE_SOUND("weapons/usp2.wav");
	PRECACHE_SOUND("weapons/usp_unsil-1.wav");
	PRECACHE_SOUND("weapons/usp_clipout.wav");
	PRECACHE_SOUND("weapons/usp_clipin.wav");
	PRECACHE_SOUND("weapons/usp_silencer_on.wav");
	PRECACHE_SOUND("weapons/usp_silencer_off.wav");
	PRECACHE_SOUND("weapons/usp_sliderelease.wav");
	PRECACHE_SOUND("weapons/usp_slideback.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireUSP = PRECACHE_EVENT(1, "events/usp.sc");
}

int CUSP::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
#ifdef REGAMEDLL_FIXES
	p->pszAmmo1 = "45acp";
#else
	p->pszAmmo1 = "45ACP";
#endif // REGAMEDLL_FIXES
	p->iMaxAmmo1 = MAX_AMMO_45ACP;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = USP_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 4;
	p->iFlags = 0;
	p->iId = m_iId = WEAPON_USP;
	p->iWeight = USP_WEIGHT;

	return 1;
}

BOOL CUSP::Deploy()
{
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_flAccuracy = 0.92f;
	m_fMaxSpeed = USP_MAX_SPEED;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield())
	{
		m_iWeaponState &= ~WPNSTATE_USP_SILENCED;
		return DefaultDeploy("models/shield/v_shield_usp.mdl", "models/shield/p_shield_usp.mdl", USP_SHIELD_DRAW, "shieldgun", UseDecrement());
	}
	else if (m_iWeaponState & WPNSTATE_USP_SILENCED)
	{
		return DefaultDeploy("models/v_usp.mdl", "models/p_usp.mdl", USP_DRAW, "onehanded", UseDecrement());
	}

	return DefaultDeploy("models/v_usp.mdl", "models/p_usp.mdl", USP_UNSIL_DRAW, "onehanded", UseDecrement());
}

void CUSP::SecondaryAttack()
{
	if (ShieldSecondaryFire(USP_SHIELD_UP, USP_SHIELD_DOWN))
	{
		return;
	}

	if (m_iWeaponState & WPNSTATE_USP_SILENCED)
	{
		m_iWeaponState &= ~WPNSTATE_USP_SILENCED;

		SendWeaponAnim(USP_DETACH_SILENCER, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "onehanded");
	}
	else
	{
		m_iWeaponState |= WPNSTATE_USP_SILENCED;

		SendWeaponAnim(USP_ATTACH_SILENCER, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "onehanded");
	}

	m_flNextSecondaryAttack = m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 3.0f;
	m_flNextPrimaryAttack = GetNextAttackDelay(3.0);
}

void CUSP::PrimaryAttack()
{
	if (m_iWeaponState & WPNSTATE_USP_SILENCED)
	{
		if (!(m_pPlayer->pev->flags & FL_ONGROUND))
		{
			USPFire(1.3 * (1 - m_flAccuracy), 0.225, FALSE);
		}
		else if (m_pPlayer->pev->velocity.Length2D() > 0)
		{
			USPFire(0.25 * (1 - m_flAccuracy), 0.225, FALSE);
		}
		else if (m_pPlayer->pev->flags & FL_DUCKING)
		{
			USPFire(0.125 * (1 - m_flAccuracy), 0.225, FALSE);
		}
		else
		{
			USPFire(0.15 * (1 - m_flAccuracy), 0.225, FALSE);
		}
	}
	else
	{
		if (!(m_pPlayer->pev->flags & FL_ONGROUND))
		{
			USPFire(1.2 * (1 - m_flAccuracy), 0.225, FALSE);
		}
		else if (m_pPlayer->pev->velocity.Length2D() > 0)
		{
			USPFire(0.225 * (1 - m_flAccuracy), 0.225, FALSE);
		}
		else if (m_pPlayer->pev->flags & FL_DUCKING)
		{
			USPFire(0.08 * (1 - m_flAccuracy), 0.225, FALSE);
		}
		else
		{
			USPFire(0.1 * (1 - m_flAccuracy), 0.225, FALSE);
		}
	}
}

void CUSP::USPFire(float flSpread, float flCycleTime, BOOL fUseSemi)
{
	int flag;
	int iDamage;
	Vector vecAiming, vecSrc, vecDir;

	flCycleTime -= 0.075f;

	if (++m_iShotsFired > 1)
	{
		return;
	}

	if (m_flLastFire != 0.0f)
	{
		m_flAccuracy -= (0.3f - (gpGlobals->time - m_flLastFire)) * 0.275f;

		if (m_flAccuracy > 0.92f)
		{
			m_flAccuracy = 0.92f;
		}
		else if (m_flAccuracy < 0.6f)
		{
			m_flAccuracy = 0.6f;
		}
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = GetNextAttackDelay(0.2);
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		return;
	}

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = GetNextAttackDelay(flCycleTime);

	--m_iClip;
	SetPlayerShieldAnim();

#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	if (!(m_iWeaponState & WPNSTATE_USP_SILENCED))
	{
		m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	}

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

	iDamage = (m_iWeaponState & WPNSTATE_USP_SILENCED) ? USP_DAMAGE_SIL : USP_DAMAGE;

	vecDir = m_pPlayer->FireBullets3(vecSrc, vecAiming, flSpread, 4096, 1, BULLET_PLAYER_45ACP, iDamage, USP_RANGE_MODIFER, m_pPlayer->pev, true, m_pPlayer->random_seed);

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif // CLIENT_WEAPONS

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireUSP, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y,
		(int)(m_pPlayer->pev->punchangle.x * 100), 0, m_iClip == 0, (m_iWeaponState & WPNSTATE_USP_SILENCED));

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, FALSE);
	}
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.0f;
	m_pPlayer->pev->punchangle.x -= 2.0f;
	ResetPlayerShieldAnim();
}

void CUSP::Reload()
{
	if (m_pPlayer->ammo_45acp <= 0)
		return;

	int iAnim;
	if (m_pPlayer->HasShield())
		iAnim = USP_SHIELD_RELOAD;
	else if (m_iWeaponState & WPNSTATE_USP_SILENCED)
		iAnim = USP_RELOAD;
	else
		iAnim = USP_UNSIL_RELOAD;

	if (DefaultReload(iMaxClip(), iAnim, USP_RELOAD_TIME))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.92f;
	}
}

void CUSP::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > 0)
	{
		return;
	}

	if (m_pPlayer->HasShield())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0f;

		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		{
			SendWeaponAnim(USP_DRAW, UseDecrement());
		}
	}
	else if (m_iClip)
	{
		int iAnim = (~m_iWeaponState & WPNSTATE_USP_SILENCED) ? USP_UNSIL_IDLE: USP_IDLE;

		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60.0f;
		SendWeaponAnim(iAnim, UseDecrement());
	}
}

```

`dlls/wpn_shared/wpn_xm1014.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

LINK_ENTITY_TO_CLASS(weapon_xm1014, CXM1014)

void CXM1014::Spawn(void)
{
	Precache();

	m_iId = WEAPON_XM1014;
	SET_MODEL(edict(), "models/w_xm1014.mdl");

	m_iDefaultAmmo = XM1014_DEFAULT_GIVE;

	// get ready to fall
	FallInit();
}

void CXM1014::Precache()
{
	PRECACHE_MODEL("models/v_xm1014.mdl");
	PRECACHE_MODEL("models/w_xm1014.mdl");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/shotgunshell.mdl");

	PRECACHE_SOUND("weapons/xm1014-1.wav");
	PRECACHE_SOUND("weapons/reload1.wav");
	PRECACHE_SOUND("weapons/reload3.wav");

	m_usFireXM1014 = PRECACHE_EVENT(1, "events/xm1014.sc");
}

int CXM1014::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "buckshot";
	p->iMaxAmmo1 = MAX_AMMO_BUCKSHOT;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = XM1014_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 12;
	p->iId = m_iId = WEAPON_XM1014;
	p->iFlags = 0;
	p->iWeight = XM1014_WEIGHT;

	return 1;
}

BOOL CXM1014::Deploy()
{
	return DefaultDeploy("models/v_xm1014.mdl", "models/p_xm1014.mdl", XM1014_DRAW, "m249", UseDecrement() != FALSE);
}

void CXM1014::PrimaryAttack()
{
	Vector vecAiming, vecSrc, vecDir;
	int flag;

	// don't fire underwater
	if (m_pPlayer->pev->waterlevel == 3)
	{
		PlayEmptySound();
		m_flNextPrimaryAttack = GetNextAttackDelay(0.15);
		return;
	}

	if (m_iClip <= 0)
	{
		Reload();

		if (!m_iClip)
		{
			PlayEmptySound();
		}

#ifndef CLIENT_DLL
		if (TheBots != NULL)
		{
			TheBots->OnEvent(EVENT_WEAPON_FIRED_ON_EMPTY, m_pPlayer);
		}
#endif

		m_flNextPrimaryAttack = GetNextAttackDelay(1);
		return;
	}

	m_pPlayer->m_iWeaponVolume = LOUD_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;
	m_iClip--;

	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	// player "shoot" animation
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	vecSrc = m_pPlayer->GetGunPosition();
	vecAiming = gpGlobals->v_forward;

#ifndef CLIENT_DLL
	m_pPlayer->FireBullets(6, vecSrc, vecAiming, XM1014_CONE_VECTOR, 3048, BULLET_PLAYER_BUCKSHOT, 0);
#endif

#ifdef CLIENT_WEAPONS
	flag = FEV_NOTHOST;
#else
	flag = 0;
#endif

	PLAYBACK_EVENT_FULL(flag, m_pPlayer->edict(), m_usFireXM1014, 0, (float *)&g_vecZero, (float *)&g_vecZero, m_vVecAiming.x, m_vVecAiming.y, 7,
		int(m_vVecAiming.x * 100), m_iClip == 0, FALSE);

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
	{
		// HEV suit - indicate out of ammo condition
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
	}
#endif
	if (m_iClip != 0)
		m_flPumpTime = UTIL_WeaponTimeBase() + 0.125f;

	m_flNextPrimaryAttack = GetNextAttackDelay(0.25);
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.25f;

	if (m_iClip != 0)
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.25f;
	else
		m_flTimeWeaponIdle = 0.75f;

	m_fInSpecialReload = 0;

	if (m_pPlayer->pev->flags & FL_ONGROUND)
		m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomLong(m_pPlayer->random_seed + 1, 3, 5);
	else
		m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomLong(m_pPlayer->random_seed + 1, 7, 10);
}

void CXM1014::Reload()
{
	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0 || m_iClip == iMaxClip())
		return;

	// don't reload until recoil is done
	if (m_flNextPrimaryAttack > UTIL_WeaponTimeBase())
		return;

	// check to see if we're ready to reload
	if (m_fInSpecialReload == 0)
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		SendWeaponAnim(XM1014_START_RELOAD, UseDecrement() != FALSE);

		m_fInSpecialReload = 1;
		m_flNextSecondaryAttack = m_flTimeWeaponIdle = m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.55f;
		m_flNextPrimaryAttack = GetNextAttackDelay(0.55);
	}
	else if (m_fInSpecialReload == 1)
	{
		if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
			return;

		// was waiting for gun to move to side
		m_fInSpecialReload = 2;

		if (RANDOM_LONG(0, 1))
			EMIT_SOUND_DYN(m_pPlayer->edict(), CHAN_ITEM, "weapons/reload1.wav", VOL_NORM, ATTN_NORM, 0, 85 + RANDOM_LONG(0, 31));
		else
			EMIT_SOUND_DYN(m_pPlayer->edict(), CHAN_ITEM, "weapons/reload3.wav", VOL_NORM, ATTN_NORM, 0, 85 + RANDOM_LONG(0, 31));

		SendWeaponAnim(XM1014_RELOAD, UseDecrement());

		m_flTimeWeaponIdle = m_flNextReload = UTIL_WeaponTimeBase() + 0.3f;
	}
	else
	{
		++m_iClip;

#ifdef REGAMEDLL_ADD
		if (refill_bpammo_weapons.value < 3.0f)
#endif
		{
			--m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType];
			--m_pPlayer->ammo_buckshot;
		}

		m_fInSpecialReload = 1;
	}
}

void CXM1014::WeaponIdle()
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_5DEGREES);

	if (m_flPumpTime && m_flPumpTime < UTIL_WeaponTimeBase())
	{
		m_flPumpTime = 0;
	}

	if (m_flTimeWeaponIdle < UTIL_WeaponTimeBase())
	{
		if (m_iClip == 0 && m_fInSpecialReload == 0 && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
		{
			Reload();
		}
		else if (m_fInSpecialReload != 0)
		{
			if (m_iClip != iMaxClip() && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
			{
				Reload();
			}
			else
			{
				// reload debounce has timed out
				SendWeaponAnim(XM1014_PUMP, UseDecrement() != FALSE);

				m_fInSpecialReload = 0;
				m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.5f;
			}
		}
		else
		{
			SendWeaponAnim(XM1014_IDLE, UseDecrement() != FALSE);
		}
	}
}

```

`engine/APIProxy.h`:

```h
#ifndef __APIPROXY__
#define __APIPROXY__

#include "archtypes.h"     // DAL
#include "netadr.h"
#include "Sequence.h"

#ifndef _WIN32
#include "enums.h"
#endif

#define	MAX_ALIAS_NAME	32

typedef struct cmdalias_s
{
	struct cmdalias_s	*next;
	char	name[MAX_ALIAS_NAME];
	char	*value;
} cmdalias_t;


// ********************************************************
// Functions exported by the client .dll
// ********************************************************

// Function type declarations for client exports
typedef int (*INITIALIZE_FUNC)	( struct cl_enginefuncs_s*, int );
typedef void (*HUD_INIT_FUNC)		( void );
typedef int (*HUD_VIDINIT_FUNC)	( void );
typedef int (*HUD_REDRAW_FUNC)	( float, int );
typedef int (*HUD_UPDATECLIENTDATA_FUNC) ( struct client_data_s*, float );
typedef void (*HUD_RESET_FUNC)    ( void );
typedef void (*HUD_CLIENTMOVE_FUNC)( struct playermove_s *ppmove, qboolean server );
typedef void (*HUD_CLIENTMOVEINIT_FUNC)( struct playermove_s *ppmove );
typedef char (*HUD_TEXTURETYPE_FUNC)( char *name );
typedef void (*HUD_IN_ACTIVATEMOUSE_FUNC) ( void );
typedef void (*HUD_IN_DEACTIVATEMOUSE_FUNC)		( void );
typedef void (*HUD_IN_MOUSEEVENT_FUNC)		( int mstate );
typedef void (*HUD_IN_CLEARSTATES_FUNC)		( void );
typedef void (*HUD_IN_ACCUMULATE_FUNC ) ( void );
typedef void (*HUD_CL_CREATEMOVE_FUNC)		( float frametime, struct usercmd_s *cmd, int active );
typedef int (*HUD_CL_ISTHIRDPERSON_FUNC) ( void );
typedef void (*HUD_CL_GETCAMERAOFFSETS_FUNC )( float *ofs );
typedef struct kbutton_s * (*HUD_KB_FIND_FUNC) ( const char *name );
typedef void ( *HUD_CAMTHINK_FUNC )( void );
typedef void ( *HUD_CALCREF_FUNC ) ( struct ref_params_s *pparams );
typedef int	 ( *HUD_ADDENTITY_FUNC ) ( int type, struct cl_entity_s *ent, const char *modelname );
typedef void ( *HUD_CREATEENTITIES_FUNC ) ( void );
typedef void ( *HUD_DRAWNORMALTRIS_FUNC ) ( void );
typedef void ( *HUD_DRAWTRANSTRIS_FUNC ) ( void );
typedef void ( *HUD_STUDIOEVENT_FUNC ) ( const struct mstudioevent_s *event, struct cl_entity_s *entity );
typedef void ( *HUD_POSTRUNCMD_FUNC ) ( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
typedef void ( *HUD_SHUTDOWN_FUNC ) ( void );
typedef void ( *HUD_TXFERLOCALOVERRIDES_FUNC )( struct entity_state_s *state, const struct clientdata_s *client );
typedef void ( *HUD_PROCESSPLAYERSTATE_FUNC )( struct entity_state_s *dst, const struct entity_state_s *src );
typedef void ( *HUD_TXFERPREDICTIONDATA_FUNC ) ( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd );
typedef void ( *HUD_DEMOREAD_FUNC ) ( int size, unsigned char *buffer );
typedef int ( *HUD_CONNECTIONLESS_FUNC )( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );
typedef	int	( *HUD_GETHULLBOUNDS_FUNC ) ( int hullnumber, float *mins, float *maxs );
typedef void (*HUD_FRAME_FUNC)		( double );
typedef int (*HUD_KEY_EVENT_FUNC ) ( int eventcode, int keynum, const char *pszCurrentBinding );
typedef void (*HUD_TEMPENTUPDATE_FUNC) ( double frametime, double client_time, double cl_gravity, struct tempent_s **ppTempEntFree, struct tempent_s **ppTempEntActive, 	int ( *Callback_AddVisibleEntity )( struct cl_entity_s *pEntity ),	void ( *Callback_TempEntPlaySound )( struct tempent_s *pTemp, float damp ) );
typedef struct cl_entity_s *(*HUD_GETUSERENTITY_FUNC ) ( int index );
typedef void (*HUD_VOICESTATUS_FUNC)(int entindex, qboolean bTalking);
typedef void (*HUD_DIRECTORMESSAGE_FUNC)( int iSize, void *pbuf );
typedef int ( *HUD_STUDIO_INTERFACE_FUNC )( int version, struct r_studio_interface_s **ppinterface, struct engine_studio_api_s *pstudio );
typedef void (*HUD_CHATINPUTPOSITION_FUNC)( int *x, int *y );
typedef int (*HUD_GETPLAYERTEAM)(int iplayer);
typedef void *(*CLIENTFACTORY)(); // this should be CreateInterfaceFn but that means including interface.h
									// which is a C++ file and some of the client files a C only... 
									// so we return a void * which we then do a typecast on later.


// Pointers to the exported client functions themselves
typedef struct
{
	INITIALIZE_FUNC						pInitFunc;
	HUD_INIT_FUNC						pHudInitFunc;
	HUD_VIDINIT_FUNC					pHudVidInitFunc;
	HUD_REDRAW_FUNC						pHudRedrawFunc;
	HUD_UPDATECLIENTDATA_FUNC			pHudUpdateClientDataFunc;
	HUD_RESET_FUNC						pHudResetFunc;
	HUD_CLIENTMOVE_FUNC					pClientMove;
	HUD_CLIENTMOVEINIT_FUNC				pClientMoveInit;
	HUD_TEXTURETYPE_FUNC				pClientTextureType;
	HUD_IN_ACTIVATEMOUSE_FUNC			pIN_ActivateMouse;
	HUD_IN_DEACTIVATEMOUSE_FUNC			pIN_DeactivateMouse;
	HUD_IN_MOUSEEVENT_FUNC				pIN_MouseEvent;
	HUD_IN_CLEARSTATES_FUNC				pIN_ClearStates;
	HUD_IN_ACCUMULATE_FUNC				pIN_Accumulate;
	HUD_CL_CREATEMOVE_FUNC				pCL_CreateMove;
	HUD_CL_ISTHIRDPERSON_FUNC			pCL_IsThirdPerson;
	HUD_CL_GETCAMERAOFFSETS_FUNC		pCL_GetCameraOffsets;
	HUD_KB_FIND_FUNC					pFindKey;
	HUD_CAMTHINK_FUNC					pCamThink;
	HUD_CALCREF_FUNC					pCalcRefdef;
	HUD_ADDENTITY_FUNC					pAddEntity;
	HUD_CREATEENTITIES_FUNC				pCreateEntities;
	HUD_DRAWNORMALTRIS_FUNC				pDrawNormalTriangles;
	HUD_DRAWTRANSTRIS_FUNC				pDrawTransparentTriangles;
	HUD_STUDIOEVENT_FUNC				pStudioEvent;
	HUD_POSTRUNCMD_FUNC					pPostRunCmd;
	HUD_SHUTDOWN_FUNC					pShutdown;
	HUD_TXFERLOCALOVERRIDES_FUNC		pTxferLocalOverrides;
	HUD_PROCESSPLAYERSTATE_FUNC			pProcessPlayerState;
	HUD_TXFERPREDICTIONDATA_FUNC		pTxferPredictionData;
	HUD_DEMOREAD_FUNC					pReadDemoBuffer;
	HUD_CONNECTIONLESS_FUNC				pConnectionlessPacket;
	HUD_GETHULLBOUNDS_FUNC				pGetHullBounds;
	HUD_FRAME_FUNC						pHudFrame;
	HUD_KEY_EVENT_FUNC					pKeyEvent;
	HUD_TEMPENTUPDATE_FUNC				pTempEntUpdate;
	HUD_GETUSERENTITY_FUNC				pGetUserEntity;
	HUD_VOICESTATUS_FUNC				pVoiceStatus;		// Possibly null on old client dlls.
	HUD_DIRECTORMESSAGE_FUNC			pDirectorMessage;	// Possibly null on old client dlls.
	HUD_STUDIO_INTERFACE_FUNC			pStudioInterface;	// Not used by all clients
	HUD_CHATINPUTPOSITION_FUNC			pChatInputPosition;	// Not used by all clients
	HUD_GETPLAYERTEAM					pGetPlayerTeam; // Not used by all clients
	CLIENTFACTORY						pClientFactory;
} cldll_func_t;

// Function type declarations for client destination functions
typedef void (*DST_INITIALIZE_FUNC)	( struct cl_enginefuncs_s**, int *);
typedef void (*DST_HUD_INIT_FUNC)		( void );
typedef void (*DST_HUD_VIDINIT_FUNC)	( void );
typedef void (*DST_HUD_REDRAW_FUNC)	( float*, int* );
typedef void (*DST_HUD_UPDATECLIENTDATA_FUNC) ( struct client_data_s**, float* );
typedef void (*DST_HUD_RESET_FUNC)    ( void );
typedef void (*DST_HUD_CLIENTMOVE_FUNC)( struct playermove_s **, qboolean * );
typedef void (*DST_HUD_CLIENTMOVEINIT_FUNC)( struct playermove_s ** );
typedef void (*DST_HUD_TEXTURETYPE_FUNC)( char ** );
typedef void (*DST_HUD_IN_ACTIVATEMOUSE_FUNC) ( void );
typedef void (*DST_HUD_IN_DEACTIVATEMOUSE_FUNC)		( void );
typedef void (*DST_HUD_IN_MOUSEEVENT_FUNC)		( int * );
typedef void (*DST_HUD_IN_CLEARSTATES_FUNC)		( void );
typedef void (*DST_HUD_IN_ACCUMULATE_FUNC ) ( void );
typedef void (*DST_HUD_CL_CREATEMOVE_FUNC)		( float *, struct usercmd_s **, int * );
typedef void (*DST_HUD_CL_ISTHIRDPERSON_FUNC) ( void );
typedef void (*DST_HUD_CL_GETCAMERAOFFSETS_FUNC )( float ** );
typedef void (*DST_HUD_KB_FIND_FUNC) ( const char ** );
typedef void (*DST_HUD_CAMTHINK_FUNC )( void );
typedef void (*DST_HUD_CALCREF_FUNC ) ( struct ref_params_s ** );
typedef void (*DST_HUD_ADDENTITY_FUNC ) ( int *, struct cl_entity_s **, const char ** );
typedef void (*DST_HUD_CREATEENTITIES_FUNC ) ( void );
typedef void (*DST_HUD_DRAWNORMALTRIS_FUNC ) ( void );
typedef void (*DST_HUD_DRAWTRANSTRIS_FUNC ) ( void );
typedef void (*DST_HUD_STUDIOEVENT_FUNC ) ( const struct mstudioevent_s **, struct cl_entity_s ** );
typedef void (*DST_HUD_POSTRUNCMD_FUNC ) ( struct local_state_s **, struct local_state_s **, struct usercmd_s **, int *, double *, unsigned int * );
typedef void (*DST_HUD_SHUTDOWN_FUNC ) ( void );
typedef void (*DST_HUD_TXFERLOCALOVERRIDES_FUNC )( struct entity_state_s **, const struct clientdata_s ** );
typedef void (*DST_HUD_PROCESSPLAYERSTATE_FUNC )( struct entity_state_s **, const struct entity_state_s ** );
typedef void (*DST_HUD_TXFERPREDICTIONDATA_FUNC ) ( struct entity_state_s **, const struct entity_state_s **, struct clientdata_s **, const struct clientdata_s **, struct weapon_data_s **, const struct weapon_data_s ** );
typedef void (*DST_HUD_DEMOREAD_FUNC ) ( int *, unsigned char ** );
typedef void (*DST_HUD_CONNECTIONLESS_FUNC )( const struct netadr_s **, const char **, char **, int ** );
typedef void (*DST_HUD_GETHULLBOUNDS_FUNC ) ( int *, float **, float ** );
typedef void (*DST_HUD_FRAME_FUNC)		( double * );
typedef void (*DST_HUD_KEY_EVENT_FUNC ) ( int *, int *, const char ** );
typedef void (*DST_HUD_TEMPENTUPDATE_FUNC) ( double *, double *, double *, struct tempent_s ***, struct tempent_s ***, int ( **Callback_AddVisibleEntity )( struct cl_entity_s *pEntity ),	void ( **Callback_TempEntPlaySound )( struct tempent_s *pTemp, float damp ) );
typedef void (*DST_HUD_GETUSERENTITY_FUNC ) ( int * );
typedef void (*DST_HUD_VOICESTATUS_FUNC)(int *, qboolean *);
typedef void (*DST_HUD_DIRECTORMESSAGE_FUNC)( int *, void ** );
typedef void (*DST_HUD_STUDIO_INTERFACE_FUNC ) ( int *, struct r_studio_interface_s ***, struct engine_studio_api_s ** );
typedef void (*DST_HUD_CHATINPUTPOSITION_FUNC)( int **, int ** );
typedef void (*DST_HUD_GETPLAYERTEAM)(int);

// Pointers to the client destination functions
typedef struct
{
	DST_INITIALIZE_FUNC						pInitFunc;
	DST_HUD_INIT_FUNC						pHudInitFunc;
	DST_HUD_VIDINIT_FUNC					pHudVidInitFunc;
	DST_HUD_REDRAW_FUNC						pHudRedrawFunc;
	DST_HUD_UPDATECLIENTDATA_FUNC			pHudUpdateClientDataFunc;
	DST_HUD_RESET_FUNC						pHudResetFunc;
	DST_HUD_CLIENTMOVE_FUNC					pClientMove;
	DST_HUD_CLIENTMOVEINIT_FUNC				pClientMoveInit;
	DST_HUD_TEXTURETYPE_FUNC				pClientTextureType;
	DST_HUD_IN_ACTIVATEMOUSE_FUNC			pIN_ActivateMouse;
	DST_HUD_IN_DEACTIVATEMOUSE_FUNC			pIN_DeactivateMouse;
	DST_HUD_IN_MOUSEEVENT_FUNC				pIN_MouseEvent;
	DST_HUD_IN_CLEARSTATES_FUNC				pIN_ClearStates;
	DST_HUD_IN_ACCUMULATE_FUNC				pIN_Accumulate;
	DST_HUD_CL_CREATEMOVE_FUNC				pCL_CreateMove;
	DST_HUD_CL_ISTHIRDPERSON_FUNC			pCL_IsThirdPerson;
	DST_HUD_CL_GETCAMERAOFFSETS_FUNC		pCL_GetCameraOffsets;
	DST_HUD_KB_FIND_FUNC					pFindKey;
	DST_HUD_CAMTHINK_FUNC					pCamThink;
	DST_HUD_CALCREF_FUNC					pCalcRefdef;
	DST_HUD_ADDENTITY_FUNC					pAddEntity;
	DST_HUD_CREATEENTITIES_FUNC				pCreateEntities;
	DST_HUD_DRAWNORMALTRIS_FUNC				pDrawNormalTriangles;
	DST_HUD_DRAWTRANSTRIS_FUNC				pDrawTransparentTriangles;
	DST_HUD_STUDIOEVENT_FUNC				pStudioEvent;
	DST_HUD_POSTRUNCMD_FUNC					pPostRunCmd;
	DST_HUD_SHUTDOWN_FUNC					pShutdown;
	DST_HUD_TXFERLOCALOVERRIDES_FUNC		pTxferLocalOverrides;
	DST_HUD_PROCESSPLAYERSTATE_FUNC			pProcessPlayerState;
	DST_HUD_TXFERPREDICTIONDATA_FUNC		pTxferPredictionData;
	DST_HUD_DEMOREAD_FUNC					pReadDemoBuffer;
	DST_HUD_CONNECTIONLESS_FUNC				pConnectionlessPacket;
	DST_HUD_GETHULLBOUNDS_FUNC				pGetHullBounds;
	DST_HUD_FRAME_FUNC						pHudFrame;
	DST_HUD_KEY_EVENT_FUNC					pKeyEvent;
	DST_HUD_TEMPENTUPDATE_FUNC				pTempEntUpdate;
	DST_HUD_GETUSERENTITY_FUNC				pGetUserEntity;
	DST_HUD_VOICESTATUS_FUNC				pVoiceStatus;	// Possibly null on old client dlls.
	DST_HUD_DIRECTORMESSAGE_FUNC			pDirectorMessage;	// Possibly null on old client dlls.
	DST_HUD_STUDIO_INTERFACE_FUNC			pStudioInterface;  // Not used by all clients
	DST_HUD_CHATINPUTPOSITION_FUNC			pChatInputPosition;  // Not used by all clients
	DST_HUD_GETPLAYERTEAM					pGetPlayerTeam; // Not used by all clients
} cldll_func_dst_t;




// ********************************************************
// Functions exported by the engine
// ********************************************************

// Function type declarations for engine exports
typedef HSPRITE						(*pfnEngSrc_pfnSPR_Load_t )			( const char *szPicName );
typedef int							(*pfnEngSrc_pfnSPR_Frames_t )			( HSPRITE hPic );
typedef int							(*pfnEngSrc_pfnSPR_Height_t )			( HSPRITE hPic, int frame );
typedef int							(*pfnEngSrc_pfnSPR_Width_t )			( HSPRITE hPic, int frame );
typedef void						(*pfnEngSrc_pfnSPR_Set_t )				( HSPRITE hPic, int r, int g, int b );
typedef void						(*pfnEngSrc_pfnSPR_Draw_t )			( int frame, int x, int y, const struct rect_s *prc );
typedef void						(*pfnEngSrc_pfnSPR_DrawHoles_t )		( int frame, int x, int y, const struct rect_s *prc );
typedef void						(*pfnEngSrc_pfnSPR_DrawAdditive_t )	( int frame, int x, int y, const struct rect_s *prc );
typedef void						(*pfnEngSrc_pfnSPR_EnableScissor_t )	( int x, int y, int width, int height );
typedef void						(*pfnEngSrc_pfnSPR_DisableScissor_t )	( void );
typedef struct client_sprite_s	*	(*pfnEngSrc_pfnSPR_GetList_t )			( const char *psz, int *piCount );
typedef void						(*pfnEngSrc_pfnFillRGBA_t )			( int x, int y, int width, int height, int r, int g, int b, int a );
typedef int							(*pfnEngSrc_pfnGetScreenInfo_t ) 		( struct SCREENINFO_s *pscrinfo );
typedef void						(*pfnEngSrc_pfnSetCrosshair_t )		( HSPRITE hspr, wrect_t rc, int r, int g, int b );
typedef struct cvar_s *				(*pfnEngSrc_pfnRegisterVariable_t )	( const char *szName, const char *szValue, int flags );
typedef float						(*pfnEngSrc_pfnGetCvarFloat_t )		( const char *szName );
typedef char*						(*pfnEngSrc_pfnGetCvarString_t )		( const char *szName );
typedef int							(*pfnEngSrc_pfnAddCommand_t )			( const char *cmd_name, void (*pfnEngSrc_function)(void) );
typedef int							(*pfnEngSrc_pfnHookUserMsg_t )			( const char *szMsgName, pfnUserMsgHook pfn );
typedef int							(*pfnEngSrc_pfnServerCmd_t )			( const char *szCmdString );
typedef int							(*pfnEngSrc_pfnClientCmd_t )			( const char *szCmdString );
typedef void						(*pfnEngSrc_pfnPrimeMusicStream_t )	( char *szFilename, int looping );
typedef void						(*pfnEngSrc_pfnGetPlayerInfo_t )		( int ent_num, struct hud_player_info_s *pinfo );
typedef void						(*pfnEngSrc_pfnPlaySoundByName_t )		( const char *szSound, float volume );
typedef void						(*pfnEngSrc_pfnPlaySoundByNameAtPitch_t )	( const char *szSound, float volume, int pitch );
typedef void						(*pfnEngSrc_pfnPlaySoundVoiceByName_t )		( const char *szSound, float volume, int pitch );
typedef void						(*pfnEngSrc_pfnPlaySoundByIndex_t )	( int iSound, float volume );
typedef void						(*pfnEngSrc_pfnAngleVectors_t )		( const float * vecAngles, float * forward, float * right, float * up );
typedef struct client_textmessage_s*(*pfnEngSrc_pfnTextMessageGet_t )		( const char *pName );
typedef int							(*pfnEngSrc_pfnDrawCharacter_t )		( int x, int y, int number, int r, int g, int b );
typedef int							(*pfnEngSrc_pfnDrawConsoleString_t )	( int x, int y, char *string );
typedef void						(*pfnEngSrc_pfnDrawSetTextColor_t )	( float r, float g, float b );
typedef void						(*pfnEngSrc_pfnDrawConsoleStringLen_t )(  const char *string, int *length, int *height );
typedef void						(*pfnEngSrc_pfnConsolePrint_t )		( const char *string );
typedef void						(*pfnEngSrc_pfnCenterPrint_t )			( const char *string );
typedef int							(*pfnEngSrc_GetWindowCenterX_t )		( void );
typedef int							(*pfnEngSrc_GetWindowCenterY_t )		( void );
typedef void						(*pfnEngSrc_GetViewAngles_t )			( float * );
typedef void						(*pfnEngSrc_SetViewAngles_t )			( float * );
typedef int							(*pfnEngSrc_GetMaxClients_t )			( void );
typedef void						(*pfnEngSrc_Cvar_SetValue_t )			( const char *cvar, float value );
typedef int       					(*pfnEngSrc_Cmd_Argc_t)					(void);	
typedef char *						(*pfnEngSrc_Cmd_Argv_t )				( int arg );
typedef void						(*pfnEngSrc_Con_Printf_t )				( const char *fmt, ... );
typedef void						(*pfnEngSrc_Con_DPrintf_t )			( const char *fmt, ... );
typedef void						(*pfnEngSrc_Con_NPrintf_t )			( int pos, const char *fmt, ... );
typedef void						(*pfnEngSrc_Con_NXPrintf_t )			( struct con_nprint_s *info, const char *fmt, ... );
typedef const char *				(*pfnEngSrc_PhysInfo_ValueForKey_t )	( const char *key );
typedef const char *				(*pfnEngSrc_ServerInfo_ValueForKey_t )( const char *key );
typedef float						(*pfnEngSrc_GetClientMaxspeed_t )		( void );
typedef int							(*pfnEngSrc_CheckParm_t )				( const char *parm, char **ppnext );
typedef void						(*pfnEngSrc_Key_Event_t )				( int key, int down );
typedef void						(*pfnEngSrc_GetMousePosition_t )		( int *mx, int *my );
typedef int							(*pfnEngSrc_IsNoClipping_t )			( void );
typedef struct cl_entity_s *		(*pfnEngSrc_GetLocalPlayer_t )		( void );
typedef struct cl_entity_s *		(*pfnEngSrc_GetViewModel_t )			( void );
typedef struct cl_entity_s *		(*pfnEngSrc_GetEntityByIndex_t )		( int idx );
typedef float						(*pfnEngSrc_GetClientTime_t )			( void );
typedef void						(*pfnEngSrc_V_CalcShake_t )			( void );
typedef void						(*pfnEngSrc_V_ApplyShake_t )			( float *origin, float *angles, float factor );
typedef int							(*pfnEngSrc_PM_PointContents_t )		( float *point, int *truecontents );
typedef int							(*pfnEngSrc_PM_WaterEntity_t )			( float *p );
typedef struct pmtrace_s *			(*pfnEngSrc_PM_TraceLine_t )			( float *start, float *end, int flags, int usehull, int ignore_pe );
typedef struct model_s *			(*pfnEngSrc_CL_LoadModel_t )			( const char *modelname, int *index );
typedef int							(*pfnEngSrc_CL_CreateVisibleEntity_t )	( int type, struct cl_entity_s *ent );
typedef const struct model_s *		(*pfnEngSrc_GetSpritePointer_t )		( HSPRITE hSprite );
typedef void						(*pfnEngSrc_pfnPlaySoundByNameAtLocation_t )	( char *szSound, float volume, float *origin );
typedef unsigned short				(*pfnEngSrc_pfnPrecacheEvent_t )		( int type, const char* psz );
typedef void						(*pfnEngSrc_pfnPlaybackEvent_t )		( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
typedef void						(*pfnEngSrc_pfnWeaponAnim_t )			( int iAnim, int body );
typedef float						(*pfnEngSrc_pfnRandomFloat_t )			( float flLow, float flHigh );
typedef int32						(*pfnEngSrc_pfnRandomLong_t )			( int32 lLow, int32 lHigh );
typedef void						(*pfnEngSrc_pfnHookEvent_t )			( const char *name, void ( *pfnEvent )( struct event_args_s *args ) );
typedef int							(*pfnEngSrc_Con_IsVisible_t)			();
typedef const char *				(*pfnEngSrc_pfnGetGameDirectory_t )	( void );
typedef struct cvar_s *				(*pfnEngSrc_pfnGetCvarPointer_t )		( const char *szName );
typedef const char *				(*pfnEngSrc_Key_LookupBinding_t )		( const char *pBinding );
typedef const char *				(*pfnEngSrc_pfnGetLevelName_t )		( void );
typedef void						(*pfnEngSrc_pfnGetScreenFade_t )		( struct screenfade_s *fade );
typedef void						(*pfnEngSrc_pfnSetScreenFade_t )		( struct screenfade_s *fade );
typedef void *						(*pfnEngSrc_VGui_GetPanel_t )         ( );
typedef void                        (*pfnEngSrc_VGui_ViewportPaintBackground_t ) (int extents[4]);
typedef byte*						(*pfnEngSrc_COM_LoadFile_t )				( const char *path, int usehunk, int *pLength );
typedef char*						(*pfnEngSrc_COM_ParseFile_t )			( char *data, char *token );
typedef void						(*pfnEngSrc_COM_FreeFile_t)				( void *buffer );
typedef struct triangleapi_s *		pTriAPI;
typedef struct efx_api_s *			pEfxAPI;
typedef struct event_api_s *		pEventAPI;
typedef struct demo_api_s *			pDemoAPI;
typedef struct net_api_s *			pNetAPI;
typedef struct IVoiceTweak_s *		pVoiceTweak;
typedef int							(*pfnEngSrc_IsSpectateOnly_t ) ( void );
typedef struct model_s *			(*pfnEngSrc_LoadMapSprite_t )			( const char *filename );
typedef void						(*pfnEngSrc_COM_AddAppDirectoryToSearchPath_t ) ( const char *pszBaseDir, const char *appName );
typedef int							(*pfnEngSrc_COM_ExpandFilename_t)				 ( const char *fileName, char *nameOutBuffer, int nameOutBufferSize );
typedef const char *				(*pfnEngSrc_PlayerInfo_ValueForKey_t )( int playerNum, const char *key );
typedef void						(*pfnEngSrc_PlayerInfo_SetValueForKey_t )( const char *key, const char *value );
typedef qboolean					(*pfnEngSrc_GetPlayerUniqueID_t)(int iPlayer, char playerID[16]);
typedef int							(*pfnEngSrc_GetTrackerIDForPlayer_t)(int playerSlot);
typedef int							(*pfnEngSrc_GetPlayerForTrackerID_t)(int trackerID);
typedef int							(*pfnEngSrc_pfnServerCmdUnreliable_t )( char *szCmdString );
typedef void						(*pfnEngSrc_GetMousePos_t )(struct tagPOINT *ppt);
typedef void						(*pfnEngSrc_SetMousePos_t )(int x, int y);
typedef void						(*pfnEngSrc_SetMouseEnable_t)(qboolean fEnable);
typedef struct cvar_s *				(*pfnEngSrc_GetFirstCVarPtr_t)();
typedef unsigned int				(*pfnEngSrc_GetFirstCmdFunctionHandle_t)();
typedef unsigned int				(*pfnEngSrc_GetNextCmdFunctionHandle_t)(unsigned int cmdhandle);
typedef const char *				(*pfnEngSrc_GetCmdFunctionName_t)(unsigned int cmdhandle);
typedef float						(*pfnEngSrc_GetClientOldTime_t)();
typedef float						(*pfnEngSrc_GetServerGravityValue_t)();
typedef struct model_s	*			(*pfnEngSrc_GetModelByIndex_t)( int index );
typedef void						(*pfnEngSrc_pfnSetFilterMode_t )( int mode );
typedef void						(*pfnEngSrc_pfnSetFilterColor_t )( float r, float g, float b );
typedef void						(*pfnEngSrc_pfnSetFilterBrightness_t )( float brightness );
typedef sequenceEntry_s*			(*pfnEngSrc_pfnSequenceGet_t )( const char *fileName, const char* entryName );
typedef void						(*pfnEngSrc_pfnSPR_DrawGeneric_t )( int frame, int x, int y, const struct rect_s *prc, int src, int dest, int w, int h );
typedef sentenceEntry_s*			(*pfnEngSrc_pfnSequencePickSentence_t )( const char *sentenceName, int pickMethod, int* entryPicked );
// draw a complete string
typedef int							(*pfnEngSrc_pfnDrawString_t )		( int x, int y, const char *str, int r, int g, int b );
typedef int							(*pfnEngSrc_pfnDrawStringReverse_t )		( int x, int y, const char *str, int r, int g, int b );
typedef const char *				(*pfnEngSrc_LocalPlayerInfo_ValueForKey_t )( const char *key );
typedef int							(*pfnEngSrc_pfnVGUI2DrawCharacter_t )		( int x, int y, int ch, unsigned int font );
typedef int							(*pfnEngSrc_pfnVGUI2DrawCharacterAdd_t )	( int x, int y, int ch, int r, int g, int b, unsigned int font);
typedef unsigned int		(*pfnEngSrc_COM_GetApproxWavePlayLength ) ( const char * filename);
typedef void *						(*pfnEngSrc_pfnGetCareerUI_t)();
typedef void						(*pfnEngSrc_Cvar_Set_t )			( const char *cvar, const char *value );
typedef int							(*pfnEngSrc_pfnIsPlayingCareerMatch_t)();
typedef double						(*pfnEngSrc_GetAbsoluteTime_t) ( void );
typedef void						(*pfnEngSrc_pfnProcessTutorMessageDecayBuffer_t)(int *buffer, int bufferLength);
typedef void						(*pfnEngSrc_pfnConstructTutorMessageDecayBuffer_t)(int *buffer, int bufferLength);
typedef void						(*pfnEngSrc_pfnResetTutorMessageDecayData_t)();
typedef void						(*pfnEngSrc_pfnFillRGBABlend_t )			( int x, int y, int width, int height, int r, int g, int b, int a );
typedef int						(*pfnEngSrc_pfnGetAppID_t)			( void );
typedef cmdalias_t*				(*pfnEngSrc_pfnGetAliases_t)		( void );
typedef void					(*pfnEngSrc_pfnVguiWrap2_GetMouseDelta_t) ( int *x, int *y );
typedef int							(*pfnEngSrc_pfnFilteredClientCmd_t) 	( char *szCmdString );

// Pointers to the exported engine functions themselves
typedef struct cl_enginefuncs_s
{
	pfnEngSrc_pfnSPR_Load_t					pfnSPR_Load;
	pfnEngSrc_pfnSPR_Frames_t				pfnSPR_Frames;
	pfnEngSrc_pfnSPR_Height_t				pfnSPR_Height;
	pfnEngSrc_pfnSPR_Width_t				pfnSPR_Width;
	pfnEngSrc_pfnSPR_Set_t					pfnSPR_Set;
	pfnEngSrc_pfnSPR_Draw_t					pfnSPR_Draw;
	pfnEngSrc_pfnSPR_DrawHoles_t			pfnSPR_DrawHoles;
	pfnEngSrc_pfnSPR_DrawAdditive_t			pfnSPR_DrawAdditive;
	pfnEngSrc_pfnSPR_EnableScissor_t		pfnSPR_EnableScissor;
	pfnEngSrc_pfnSPR_DisableScissor_t		pfnSPR_DisableScissor;
	pfnEngSrc_pfnSPR_GetList_t				pfnSPR_GetList;
	pfnEngSrc_pfnFillRGBA_t					pfnFillRGBA;
	pfnEngSrc_pfnGetScreenInfo_t			pfnGetScreenInfo;
	pfnEngSrc_pfnSetCrosshair_t				pfnSetCrosshair;
	pfnEngSrc_pfnRegisterVariable_t			pfnRegisterVariable;
	pfnEngSrc_pfnGetCvarFloat_t				pfnGetCvarFloat;
	pfnEngSrc_pfnGetCvarString_t			pfnGetCvarString;
	pfnEngSrc_pfnAddCommand_t				pfnAddCommand;
	pfnEngSrc_pfnHookUserMsg_t				pfnHookUserMsg;
	pfnEngSrc_pfnServerCmd_t				pfnServerCmd;
	pfnEngSrc_pfnClientCmd_t				pfnClientCmd;
	pfnEngSrc_pfnGetPlayerInfo_t			pfnGetPlayerInfo;
	pfnEngSrc_pfnPlaySoundByName_t			pfnPlaySoundByName;
	pfnEngSrc_pfnPlaySoundByIndex_t			pfnPlaySoundByIndex;
	pfnEngSrc_pfnAngleVectors_t				pfnAngleVectors;
	pfnEngSrc_pfnTextMessageGet_t			pfnTextMessageGet;
	pfnEngSrc_pfnDrawCharacter_t			pfnDrawCharacter;
	pfnEngSrc_pfnDrawConsoleString_t		pfnDrawConsoleString;
	pfnEngSrc_pfnDrawSetTextColor_t			pfnDrawSetTextColor;
	pfnEngSrc_pfnDrawConsoleStringLen_t		pfnDrawConsoleStringLen;
	pfnEngSrc_pfnConsolePrint_t				pfnConsolePrint;
	pfnEngSrc_pfnCenterPrint_t				pfnCenterPrint;
	pfnEngSrc_GetWindowCenterX_t			GetWindowCenterX;
	pfnEngSrc_GetWindowCenterY_t			GetWindowCenterY;
	pfnEngSrc_GetViewAngles_t				GetViewAngles;
	pfnEngSrc_SetViewAngles_t				SetViewAngles;
	pfnEngSrc_GetMaxClients_t				GetMaxClients;
	pfnEngSrc_Cvar_SetValue_t				Cvar_SetValue;
	pfnEngSrc_Cmd_Argc_t					Cmd_Argc;
	pfnEngSrc_Cmd_Argv_t					Cmd_Argv;
	pfnEngSrc_Con_Printf_t					Con_Printf;
	pfnEngSrc_Con_DPrintf_t					Con_DPrintf;
	pfnEngSrc_Con_NPrintf_t					Con_NPrintf;
	pfnEngSrc_Con_NXPrintf_t				Con_NXPrintf;
	pfnEngSrc_PhysInfo_ValueForKey_t		PhysInfo_ValueForKey;
	pfnEngSrc_ServerInfo_ValueForKey_t		ServerInfo_ValueForKey;
	pfnEngSrc_GetClientMaxspeed_t			GetClientMaxspeed;
	pfnEngSrc_CheckParm_t					CheckParm;
	pfnEngSrc_Key_Event_t					Key_Event;
	pfnEngSrc_GetMousePosition_t			GetMousePosition;
	pfnEngSrc_IsNoClipping_t				IsNoClipping;
	pfnEngSrc_GetLocalPlayer_t				GetLocalPlayer;
	pfnEngSrc_GetViewModel_t				GetViewModel;
	pfnEngSrc_GetEntityByIndex_t			GetEntityByIndex;
	pfnEngSrc_GetClientTime_t				GetClientTime;
	pfnEngSrc_V_CalcShake_t					V_CalcShake;
	pfnEngSrc_V_ApplyShake_t				V_ApplyShake;
	pfnEngSrc_PM_PointContents_t			PM_PointContents;
	pfnEngSrc_PM_WaterEntity_t				PM_WaterEntity;
	pfnEngSrc_PM_TraceLine_t				PM_TraceLine;
	pfnEngSrc_CL_LoadModel_t				CL_LoadModel;
	pfnEngSrc_CL_CreateVisibleEntity_t		CL_CreateVisibleEntity;
	pfnEngSrc_GetSpritePointer_t			GetSpritePointer;
	pfnEngSrc_pfnPlaySoundByNameAtLocation_t	pfnPlaySoundByNameAtLocation;
	pfnEngSrc_pfnPrecacheEvent_t			pfnPrecacheEvent;
	pfnEngSrc_pfnPlaybackEvent_t			pfnPlaybackEvent;
	pfnEngSrc_pfnWeaponAnim_t				pfnWeaponAnim;
	pfnEngSrc_pfnRandomFloat_t				pfnRandomFloat;
	pfnEngSrc_pfnRandomLong_t				pfnRandomLong;
	pfnEngSrc_pfnHookEvent_t				pfnHookEvent;
	pfnEngSrc_Con_IsVisible_t				Con_IsVisible;
	pfnEngSrc_pfnGetGameDirectory_t			pfnGetGameDirectory;
	pfnEngSrc_pfnGetCvarPointer_t			pfnGetCvarPointer;
	pfnEngSrc_Key_LookupBinding_t			Key_LookupBinding;
	pfnEngSrc_pfnGetLevelName_t				pfnGetLevelName;
	pfnEngSrc_pfnGetScreenFade_t			pfnGetScreenFade;
	pfnEngSrc_pfnSetScreenFade_t			pfnSetScreenFade;
	pfnEngSrc_VGui_GetPanel_t				VGui_GetPanel;
	pfnEngSrc_VGui_ViewportPaintBackground_t	VGui_ViewportPaintBackground;
	pfnEngSrc_COM_LoadFile_t				COM_LoadFile;
	pfnEngSrc_COM_ParseFile_t				COM_ParseFile;
	pfnEngSrc_COM_FreeFile_t				COM_FreeFile;
	struct triangleapi_s		*pTriAPI;
	struct efx_api_s			*pEfxAPI;
	struct event_api_s			*pEventAPI;
	struct demo_api_s			*pDemoAPI;
	struct net_api_s			*pNetAPI;
	struct IVoiceTweak_s		*pVoiceTweak;
	pfnEngSrc_IsSpectateOnly_t				IsSpectateOnly;
	pfnEngSrc_LoadMapSprite_t				LoadMapSprite;
	pfnEngSrc_COM_AddAppDirectoryToSearchPath_t		COM_AddAppDirectoryToSearchPath;
	pfnEngSrc_COM_ExpandFilename_t			COM_ExpandFilename;
	pfnEngSrc_PlayerInfo_ValueForKey_t		PlayerInfo_ValueForKey;
	pfnEngSrc_PlayerInfo_SetValueForKey_t	PlayerInfo_SetValueForKey;
	pfnEngSrc_GetPlayerUniqueID_t			GetPlayerUniqueID;
	pfnEngSrc_GetTrackerIDForPlayer_t		GetTrackerIDForPlayer;
	pfnEngSrc_GetPlayerForTrackerID_t		GetPlayerForTrackerID;
	pfnEngSrc_pfnServerCmdUnreliable_t		pfnServerCmdUnreliable;
	pfnEngSrc_GetMousePos_t					pfnGetMousePos;
	pfnEngSrc_SetMousePos_t					pfnSetMousePos;
	pfnEngSrc_SetMouseEnable_t				pfnSetMouseEnable;
	pfnEngSrc_GetFirstCVarPtr_t				GetFirstCvarPtr;
	pfnEngSrc_GetFirstCmdFunctionHandle_t	GetFirstCmdFunctionHandle;
	pfnEngSrc_GetNextCmdFunctionHandle_t	GetNextCmdFunctionHandle;
	pfnEngSrc_GetCmdFunctionName_t			GetCmdFunctionName;
	pfnEngSrc_GetClientOldTime_t			hudGetClientOldTime;
	pfnEngSrc_GetServerGravityValue_t		hudGetServerGravityValue;
	pfnEngSrc_GetModelByIndex_t				hudGetModelByIndex;
	pfnEngSrc_pfnSetFilterMode_t			pfnSetFilterMode;
	pfnEngSrc_pfnSetFilterColor_t			pfnSetFilterColor;
	pfnEngSrc_pfnSetFilterBrightness_t		pfnSetFilterBrightness;
	pfnEngSrc_pfnSequenceGet_t				pfnSequenceGet;
	pfnEngSrc_pfnSPR_DrawGeneric_t			pfnSPR_DrawGeneric;
	pfnEngSrc_pfnSequencePickSentence_t		pfnSequencePickSentence;
	pfnEngSrc_pfnDrawString_t				pfnDrawString;
	pfnEngSrc_pfnDrawStringReverse_t				pfnDrawStringReverse;
	pfnEngSrc_LocalPlayerInfo_ValueForKey_t		LocalPlayerInfo_ValueForKey;
	pfnEngSrc_pfnVGUI2DrawCharacter_t		pfnVGUI2DrawCharacter;
	pfnEngSrc_pfnVGUI2DrawCharacterAdd_t	pfnVGUI2DrawCharacterAdd;
	pfnEngSrc_COM_GetApproxWavePlayLength	COM_GetApproxWavePlayLength;
	pfnEngSrc_pfnGetCareerUI_t				pfnGetCareerUI;
	pfnEngSrc_Cvar_Set_t					Cvar_Set;
	pfnEngSrc_pfnIsPlayingCareerMatch_t		pfnIsCareerMatch;
	pfnEngSrc_pfnPlaySoundVoiceByName_t	pfnPlaySoundVoiceByName;
	pfnEngSrc_pfnPrimeMusicStream_t		pfnPrimeMusicStream;
	pfnEngSrc_GetAbsoluteTime_t				GetAbsoluteTime;
	pfnEngSrc_pfnProcessTutorMessageDecayBuffer_t		pfnProcessTutorMessageDecayBuffer;
	pfnEngSrc_pfnConstructTutorMessageDecayBuffer_t		pfnConstructTutorMessageDecayBuffer;
	pfnEngSrc_pfnResetTutorMessageDecayData_t		pfnResetTutorMessageDecayData;
	pfnEngSrc_pfnPlaySoundByNameAtPitch_t	pfnPlaySoundByNameAtPitch;
	pfnEngSrc_pfnFillRGBABlend_t					pfnFillRGBABlend;
	pfnEngSrc_pfnGetAppID_t					pfnGetAppID;
	pfnEngSrc_pfnGetAliases_t				pfnGetAliasList;
	pfnEngSrc_pfnVguiWrap2_GetMouseDelta_t pfnVguiWrap2_GetMouseDelta;
	pfnEngSrc_pfnFilteredClientCmd_t		pfnFilteredClientCmd;
} cl_enginefunc_t;

// Function type declarations for engine destination functions
typedef void	(*pfnEngDst_pfnSPR_Load_t )				( const char ** );
typedef void	(*pfnEngDst_pfnSPR_Frames_t )			( HSPRITE * );
typedef void	(*pfnEngDst_pfnSPR_Height_t )			( HSPRITE *, int * );
typedef void	(*pfnEngDst_pfnSPR_Width_t )			( HSPRITE *, int * );
typedef void	(*pfnEngDst_pfnSPR_Set_t )				( HSPRITE *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnSPR_Draw_t )				( int *, int *, int *, const struct rect_s ** );
typedef void	(*pfnEngDst_pfnSPR_DrawHoles_t )		( int *, int *, int *, const struct rect_s ** );
typedef void	(*pfnEngDst_pfnSPR_DrawAdditive_t )		( int *, int *, int *, const struct rect_s ** );
typedef void	(*pfnEngDst_pfnSPR_EnableScissor_t )	( int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnSPR_DisableScissor_t )	( void );
typedef void	(*pfnEngDst_pfnSPR_GetList_t )			( char **, int ** );
typedef void	(*pfnEngDst_pfnFillRGBA_t )				( int *, int *, int *, int *, int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnGetScreenInfo_t ) 		( struct SCREENINFO_s ** );
typedef void	(*pfnEngDst_pfnSetCrosshair_t )			( HSPRITE *, struct rect_s *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnRegisterVariable_t )		( char **, char **, int * );
typedef void	(*pfnEngDst_pfnGetCvarFloat_t )			( char ** );
typedef void	(*pfnEngDst_pfnGetCvarString_t )		( char ** );
typedef void	(*pfnEngDst_pfnAddCommand_t )			( char **, void (**pfnEngDst_function)(void) );
typedef void	(*pfnEngDst_pfnHookUserMsg_t )			( char **, pfnUserMsgHook * );
typedef void	(*pfnEngDst_pfnServerCmd_t )			( char ** );
typedef void	(*pfnEngDst_pfnClientCmd_t )			( char ** );
typedef void	(*pfnEngDst_pfnPrimeMusicStream_t )	( char **, int *);
typedef void	(*pfnEngDst_pfnGetPlayerInfo_t )		( int *, struct hud_player_info_s ** );
typedef void	(*pfnEngDst_pfnPlaySoundByName_t )		( char **, float * );
typedef void	(*pfnEngDst_pfnPlaySoundByNameAtPitch_t )	( char **, float *, int * );
typedef void	(*pfnEngDst_pfnPlaySoundVoiceByName_t )	(char **, float * );
typedef void	(*pfnEngDst_pfnPlaySoundByIndex_t )		( int *, float * );
typedef void	(*pfnEngDst_pfnAngleVectors_t )			( const float * *, float * *, float * *, float * * );
typedef void	(*pfnEngDst_pfnTextMessageGet_t )		( const char ** );
typedef void	(*pfnEngDst_pfnDrawCharacter_t )		( int *, int *, int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnDrawConsoleString_t )	( int *, int *, char ** );
typedef void	(*pfnEngDst_pfnDrawSetTextColor_t )		( float *, float *, float * );
typedef void	(*pfnEngDst_pfnDrawConsoleStringLen_t )	(  const char **, int **, int ** );
typedef void	(*pfnEngDst_pfnConsolePrint_t )			( const char ** );
typedef void	(*pfnEngDst_pfnCenterPrint_t )			( const char ** );
typedef void	(*pfnEngDst_GetWindowCenterX_t )		( void );
typedef void	(*pfnEngDst_GetWindowCenterY_t )		( void );
typedef void	(*pfnEngDst_GetViewAngles_t )			( float ** );
typedef void	(*pfnEngDst_SetViewAngles_t )			( float ** );
typedef void	(*pfnEngDst_GetMaxClients_t )			( void );
typedef void	(*pfnEngDst_Cvar_SetValue_t )			( char **, float * );
typedef void    (*pfnEngDst_Cmd_Argc_t)					(void);	
typedef void	(*pfnEngDst_Cmd_Argv_t )				( int * );
typedef void	(*pfnEngDst_Con_Printf_t )				( char **);
typedef void	(*pfnEngDst_Con_DPrintf_t )				( char **);
typedef void	(*pfnEngDst_Con_NPrintf_t )				( int *, char ** );
typedef void	(*pfnEngDst_Con_NXPrintf_t )			( struct con_nprint_s **, char **);
typedef void	(*pfnEngDst_PhysInfo_ValueForKey_t )	( const char ** );
typedef void	(*pfnEngDst_ServerInfo_ValueForKey_t )	( const char ** );
typedef void	(*pfnEngDst_GetClientMaxspeed_t )		( void );
typedef void	(*pfnEngDst_CheckParm_t )				( char **, char *** );
typedef void	(*pfnEngDst_Key_Event_t )				( int *, int * );
typedef void	(*pfnEngDst_GetMousePosition_t )		( int **, int ** );
typedef void	(*pfnEngDst_IsNoClipping_t )			( void );
typedef void	(*pfnEngDst_GetLocalPlayer_t )			( void );
typedef void	(*pfnEngDst_GetViewModel_t )			( void );
typedef void	(*pfnEngDst_GetEntityByIndex_t )		( int * );
typedef void	(*pfnEngDst_GetClientTime_t )			( void );
typedef void	(*pfnEngDst_V_CalcShake_t )				( void );
typedef void	(*pfnEngDst_V_ApplyShake_t )			( float **, float **, float * );
typedef void	(*pfnEngDst_PM_PointContents_t )		( float **, int ** );
typedef void	(*pfnEngDst_PM_WaterEntity_t )			( float ** );
typedef void	(*pfnEngDst_PM_TraceLine_t )			( float **, float **, int *, int *, int * );
typedef void	(*pfnEngDst_CL_LoadModel_t )			( const char **, int ** );
typedef void	(*pfnEngDst_CL_CreateVisibleEntity_t )	( int *, struct cl_entity_s ** );
typedef void	(*pfnEngDst_GetSpritePointer_t )		( HSPRITE * );
typedef void	(*pfnEngDst_pfnPlaySoundByNameAtLocation_t )	( char **, float *, float ** );
typedef void	(*pfnEngDst_pfnPrecacheEvent_t )		( int *, const char* * );
typedef void	(*pfnEngDst_pfnPlaybackEvent_t )		( int *, const struct edict_s **, unsigned short *, float *, float **, float **, float *, float *, int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnWeaponAnim_t )			( int *, int * );
typedef void	(*pfnEngDst_pfnRandomFloat_t )			( float *, float * );
typedef void	(*pfnEngDst_pfnRandomLong_t )			( int32 *, int32 * );
typedef void	(*pfnEngDst_pfnHookEvent_t )			( char **, void ( **pfnEvent )( struct event_args_s *args ) );
typedef void	(*pfnEngDst_Con_IsVisible_t)			();
typedef void	(*pfnEngDst_pfnGetGameDirectory_t )		( void );
typedef void	(*pfnEngDst_pfnGetCvarPointer_t )		( const char ** );
typedef void	(*pfnEngDst_Key_LookupBinding_t )		( const char ** );
typedef void	(*pfnEngDst_pfnGetLevelName_t )			( void );
typedef void	(*pfnEngDst_pfnGetScreenFade_t )		( struct screenfade_s ** );
typedef void	(*pfnEngDst_pfnSetScreenFade_t )		( struct screenfade_s ** );
typedef void	(*pfnEngDst_VGui_GetPanel_t )			( );
typedef void	(*pfnEngDst_VGui_ViewportPaintBackground_t ) (int **);
typedef void	(*pfnEngDst_COM_LoadFile_t )			( char **, int *, int ** );
typedef void	(*pfnEngDst_COM_ParseFile_t )			( char **, char ** );
typedef void	(*pfnEngDst_COM_FreeFile_t)				( void ** );
typedef void	(*pfnEngDst_IsSpectateOnly_t )			( void );
typedef void	(*pfnEngDst_LoadMapSprite_t )			( const char ** );
typedef void	(*pfnEngDst_COM_AddAppDirectoryToSearchPath_t ) ( const char **, const char ** );
typedef void	(*pfnEngDst_COM_ExpandFilename_t)		( const char **, char **, int * );
typedef void	(*pfnEngDst_PlayerInfo_ValueForKey_t )	( int *, const char ** );
typedef void	(*pfnEngDst_PlayerInfo_SetValueForKey_t )( const char **, const char ** );
typedef void	(*pfnEngDst_GetPlayerUniqueID_t)		(int *, char **);
typedef void	(*pfnEngDst_GetTrackerIDForPlayer_t)	(int *);
typedef void	(*pfnEngDst_GetPlayerForTrackerID_t)	(int *);
typedef void	(*pfnEngDst_pfnServerCmdUnreliable_t )	( char ** );
typedef void	(*pfnEngDst_GetMousePos_t )				(struct tagPOINT **);
typedef void	(*pfnEngDst_SetMousePos_t )				(int *, int *);
typedef void	(*pfnEngDst_SetMouseEnable_t )			(qboolean *);
typedef void	(*pfnEngDst_pfnSetFilterMode_t)			( int * );
typedef void	(*pfnEngDst_pfnSetFilterColor_t)		( float *, float *, float * );
typedef void	(*pfnEngDst_pfnSetFilterBrightness_t)	( float * );
typedef void	(*pfnEngDst_pfnSequenceGet_t )			( const char**, const char** );
typedef void	(*pfnEngDst_pfnSPR_DrawGeneric_t )		( int *, int *, int *, const struct rect_s **, int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnSequencePickSentence_t )	( const char**, int *, int ** );
typedef void	(*pfnEngDst_pfnDrawString_t )			( int *, int *, const char *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnDrawStringReverse_t )			( int *, int *, const char *, int *, int *, int * );
typedef void	(*pfnEngDst_LocalPlayerInfo_ValueForKey_t )( const char **);
typedef void	(*pfnEngDst_pfnVGUI2DrawCharacter_t )		( int *, int *, int *, unsigned int * );
typedef void	(*pfnEngDst_pfnVGUI2DrawCharacterAdd_t )	( int *, int *, int *, int *, int *, int *, unsigned int *);
typedef void	(*pfnEngDst_pfnProcessTutorMessageDecayBuffer_t )(int **, int *);
typedef void	(*pfnEngDst_pfnConstructTutorMessageDecayBuffer_t )(int **, int *);
typedef void	(*pfnEngDst_pfnResetTutorMessageDecayData_t)();
typedef void	(*pfnEngDst_pfnFillRGBABlend_t )				( int *, int *, int *, int *, int *, int *, int *, int * );
typedef void	(*pfnEngDst_pfnGetAppID_t )				( void );
typedef void	(*pfnEngDst_pfnGetAliases_t )				( void );
typedef void	(*pfnEngDst_pfnVguiWrap2_GetMouseDelta_t) ( int *x, int *y );
typedef void	(*pfnEngDst_pfnFilteredClientCmd_t )	( char ** );


// Pointers to the engine destination functions
typedef struct
{
	pfnEngDst_pfnSPR_Load_t					pfnSPR_Load;
	pfnEngDst_pfnSPR_Frames_t				pfnSPR_Frames;
	pfnEngDst_pfnSPR_Height_t				pfnSPR_Height;
	pfnEngDst_pfnSPR_Width_t				pfnSPR_Width;
	pfnEngDst_pfnSPR_Set_t					pfnSPR_Set;
	pfnEngDst_pfnSPR_Draw_t					pfnSPR_Draw;
	pfnEngDst_pfnSPR_DrawHoles_t			pfnSPR_DrawHoles;
	pfnEngDst_pfnSPR_DrawAdditive_t			pfnSPR_DrawAdditive;
	pfnEngDst_pfnSPR_EnableScissor_t		pfnSPR_EnableScissor;
	pfnEngDst_pfnSPR_DisableScissor_t		pfnSPR_DisableScissor;
	pfnEngDst_pfnSPR_GetList_t				pfnSPR_GetList;
	pfnEngDst_pfnFillRGBA_t					pfnFillRGBA;
	pfnEngDst_pfnGetScreenInfo_t			pfnGetScreenInfo;
	pfnEngDst_pfnSetCrosshair_t				pfnSetCrosshair;
	pfnEngDst_pfnRegisterVariable_t			pfnRegisterVariable;
	pfnEngDst_pfnGetCvarFloat_t				pfnGetCvarFloat;
	pfnEngDst_pfnGetCvarString_t			pfnGetCvarString;
	pfnEngDst_pfnAddCommand_t				pfnAddCommand;
	pfnEngDst_pfnHookUserMsg_t				pfnHookUserMsg;
	pfnEngDst_pfnServerCmd_t				pfnServerCmd;
	pfnEngDst_pfnClientCmd_t				pfnClientCmd;
	pfnEngDst_pfnGetPlayerInfo_t			pfnGetPlayerInfo;
	pfnEngDst_pfnPlaySoundByName_t			pfnPlaySoundByName;
	pfnEngDst_pfnPlaySoundByIndex_t			pfnPlaySoundByIndex;
	pfnEngDst_pfnAngleVectors_t				pfnAngleVectors;
	pfnEngDst_pfnTextMessageGet_t			pfnTextMessageGet;
	pfnEngDst_pfnDrawCharacter_t			pfnDrawCharacter;
	pfnEngDst_pfnDrawConsoleString_t		pfnDrawConsoleString;
	pfnEngDst_pfnDrawSetTextColor_t			pfnDrawSetTextColor;
	pfnEngDst_pfnDrawConsoleStringLen_t		pfnDrawConsoleStringLen;
	pfnEngDst_pfnConsolePrint_t				pfnConsolePrint;
	pfnEngDst_pfnCenterPrint_t				pfnCenterPrint;
	pfnEngDst_GetWindowCenterX_t			GetWindowCenterX;
	pfnEngDst_GetWindowCenterY_t			GetWindowCenterY;
	pfnEngDst_GetViewAngles_t				GetViewAngles;
	pfnEngDst_SetViewAngles_t				SetViewAngles;
	pfnEngDst_GetMaxClients_t				GetMaxClients;
	pfnEngDst_Cvar_SetValue_t				Cvar_SetValue;
	pfnEngDst_Cmd_Argc_t					Cmd_Argc;
	pfnEngDst_Cmd_Argv_t					Cmd_Argv;
	pfnEngDst_Con_Printf_t					Con_Printf;
	pfnEngDst_Con_DPrintf_t					Con_DPrintf;
	pfnEngDst_Con_NPrintf_t					Con_NPrintf;
	pfnEngDst_Con_NXPrintf_t				Con_NXPrintf;
	pfnEngDst_PhysInfo_ValueForKey_t		PhysInfo_ValueForKey;
	pfnEngDst_ServerInfo_ValueForKey_t		ServerInfo_ValueForKey;
	pfnEngDst_GetClientMaxspeed_t			GetClientMaxspeed;
	pfnEngDst_CheckParm_t					CheckParm;
	pfnEngDst_Key_Event_t					Key_Event;
	pfnEngDst_GetMousePosition_t			GetMousePosition;
	pfnEngDst_IsNoClipping_t				IsNoClipping;
	pfnEngDst_GetLocalPlayer_t				GetLocalPlayer;
	pfnEngDst_GetViewModel_t				GetViewModel;
	pfnEngDst_GetEntityByIndex_t			GetEntityByIndex;
	pfnEngDst_GetClientTime_t				GetClientTime;
	pfnEngDst_V_CalcShake_t					V_CalcShake;
	pfnEngDst_V_ApplyShake_t				V_ApplyShake;
	pfnEngDst_PM_PointContents_t			PM_PointContents;
	pfnEngDst_PM_WaterEntity_t				PM_WaterEntity;
	pfnEngDst_PM_TraceLine_t				PM_TraceLine;
	pfnEngDst_CL_LoadModel_t				CL_LoadModel;
	pfnEngDst_CL_CreateVisibleEntity_t		CL_CreateVisibleEntity;
	pfnEngDst_GetSpritePointer_t			GetSpritePointer;
	pfnEngDst_pfnPlaySoundByNameAtLocation_t	pfnPlaySoundByNameAtLocation;
	pfnEngDst_pfnPrecacheEvent_t			pfnPrecacheEvent;
	pfnEngDst_pfnPlaybackEvent_t			pfnPlaybackEvent;
	pfnEngDst_pfnWeaponAnim_t				pfnWeaponAnim;
	pfnEngDst_pfnRandomFloat_t				pfnRandomFloat;
	pfnEngDst_pfnRandomLong_t				pfnRandomLong;
	pfnEngDst_pfnHookEvent_t				pfnHookEvent;
	pfnEngDst_Con_IsVisible_t				Con_IsVisible;
	pfnEngDst_pfnGetGameDirectory_t			pfnGetGameDirectory;
	pfnEngDst_pfnGetCvarPointer_t			pfnGetCvarPointer;
	pfnEngDst_Key_LookupBinding_t			Key_LookupBinding;
	pfnEngDst_pfnGetLevelName_t				pfnGetLevelName;
	pfnEngDst_pfnGetScreenFade_t			pfnGetScreenFade;
	pfnEngDst_pfnSetScreenFade_t			pfnSetScreenFade;
	pfnEngDst_VGui_GetPanel_t				VGui_GetPanel;
	pfnEngDst_VGui_ViewportPaintBackground_t	VGui_ViewportPaintBackground;
	pfnEngDst_COM_LoadFile_t				COM_LoadFile;
	pfnEngDst_COM_ParseFile_t				COM_ParseFile;
	pfnEngDst_COM_FreeFile_t				COM_FreeFile;
	struct triangleapi_s		*pTriAPI;
	struct efx_api_s			*pEfxAPI;
	struct event_api_s			*pEventAPI;
	struct demo_api_s			*pDemoAPI;
	struct net_api_s			*pNetAPI;
	struct IVoiceTweak_s		*pVoiceTweak;
	pfnEngDst_IsSpectateOnly_t				IsSpectateOnly;
	pfnEngDst_LoadMapSprite_t				LoadMapSprite;
	pfnEngDst_COM_AddAppDirectoryToSearchPath_t		COM_AddAppDirectoryToSearchPath;
	pfnEngDst_COM_ExpandFilename_t			COM_ExpandFilename;
	pfnEngDst_PlayerInfo_ValueForKey_t		PlayerInfo_ValueForKey;
	pfnEngDst_PlayerInfo_SetValueForKey_t	PlayerInfo_SetValueForKey;
	pfnEngDst_GetPlayerUniqueID_t			GetPlayerUniqueID;
	pfnEngDst_GetTrackerIDForPlayer_t		GetTrackerIDForPlayer;
	pfnEngDst_GetPlayerForTrackerID_t		GetPlayerForTrackerID;
	pfnEngDst_pfnServerCmdUnreliable_t		pfnServerCmdUnreliable;
	pfnEngDst_GetMousePos_t					pfnGetMousePos;
	pfnEngDst_SetMousePos_t					pfnSetMousePos;
	pfnEngDst_SetMouseEnable_t				pfnSetMouseEnable;
	pfnEngDst_pfnSetFilterMode_t			pfnSetFilterMode ;
	pfnEngDst_pfnSetFilterColor_t			pfnSetFilterColor ;
	pfnEngDst_pfnSetFilterBrightness_t		pfnSetFilterBrightness ;
	pfnEngDst_pfnSequenceGet_t				pfnSequenceGet;
	pfnEngDst_pfnSPR_DrawGeneric_t			pfnSPR_DrawGeneric;
	pfnEngDst_pfnSequencePickSentence_t		pfnSequencePickSentence;
	pfnEngDst_pfnDrawString_t				pfnDrawString;
	pfnEngDst_pfnDrawString_t				pfnDrawStringReverse;
	pfnEngDst_LocalPlayerInfo_ValueForKey_t	LocalPlayerInfo_ValueForKey;
	pfnEngDst_pfnVGUI2DrawCharacter_t		pfnVGUI2DrawCharacter;
	pfnEngDst_pfnVGUI2DrawCharacterAdd_t	pfnVGUI2DrawCharacterAdd;
	pfnEngDst_pfnPlaySoundVoiceByName_t	pfnPlaySoundVoiceByName;
	pfnEngDst_pfnPrimeMusicStream_t			pfnPrimeMusicStream;
	pfnEngDst_pfnProcessTutorMessageDecayBuffer_t		pfnProcessTutorMessageDecayBuffer;
	pfnEngDst_pfnConstructTutorMessageDecayBuffer_t		pfnConstructTutorMessageDecayBuffer;
	pfnEngDst_pfnResetTutorMessageDecayData_t		pfnResetTutorMessageDecayData;
	pfnEngDst_pfnPlaySoundByNameAtPitch_t	pfnPlaySoundByNameAtPitch;
	pfnEngDst_pfnFillRGBABlend_t					pfnFillRGBABlend;
	pfnEngDst_pfnGetAppID_t							pfnGetAppID;
	pfnEngDst_pfnGetAliases_t				pfnGetAliasList;
	pfnEngDst_pfnVguiWrap2_GetMouseDelta_t	pfnVguiWrap2_GetMouseDelta;
	pfnEngDst_pfnFilteredClientCmd_t		pfnFilteredClientCmd;
} cl_enginefunc_dst_t;


// ********************************************************
// Functions exposed by the engine to the module
// ********************************************************

// Functions for ModuleS
typedef void (*PFN_KICKPLAYER)(int nPlayerSlot, int nReason);

typedef struct modshelpers_s
{
	PFN_KICKPLAYER m_pfnKickPlayer;

	// reserved for future expansion
	int m_nVoid1;
	int m_nVoid2;
	int m_nVoid3;
	int m_nVoid4;
	int m_nVoid5;
	int m_nVoid6;
	int m_nVoid7;
	int m_nVoid8;
	int m_nVoid9;
} modshelpers_t;

// Functions for moduleC
typedef struct modchelpers_s
{
	// reserved for future expansion
	int m_nVoid0;
	int m_nVoid1;
	int m_nVoid2;
	int m_nVoid3;
	int m_nVoid4;
	int m_nVoid5;
	int m_nVoid6;
	int m_nVoid7;
	int m_nVoid8;
	int m_nVoid9;
} modchelpers_t;


// ********************************************************
// Information about the engine
// ********************************************************
typedef struct engdata_s
{
	cl_enginefunc_t	*pcl_enginefuncs;		// functions exported by the engine
	cl_enginefunc_dst_t *pg_engdstAddrs;	// destination handlers for engine exports
	cldll_func_t *pcl_funcs;				// client exports
	cldll_func_dst_t *pg_cldstAddrs;		// client export destination handlers
	struct modfuncs_s *pg_modfuncs;			// engine's pointer to module functions
	struct cmd_function_s **pcmd_functions;	// list of all registered commands
	void *pkeybindings;						// all key bindings (not really a void *, but easier this way)
	void (*pfnConPrintf)(char *, ...);		// dump to console
	struct cvar_s **pcvar_vars;				// pointer to head of cvar list
	struct glwstate_t *pglwstate;			// OpenGl information
	void *(*pfnSZ_GetSpace)(struct sizebuf_s *, int); // pointer to SZ_GetSpace
	struct modfuncs_s *pmodfuncs;			// &g_modfuncs
	void *pfnGetProcAddress;				// &GetProcAddress
	void *pfnGetModuleHandle;				// &GetModuleHandle
	struct server_static_s *psvs;			// &svs
	struct client_static_s *pcls;			// &cls
	void (*pfnSV_DropClient)(struct client_s *, qboolean, char *, ...);	// pointer to SV_DropClient
	void (*pfnNetchan_Transmit)(struct netchan_s *, int, byte *);		// pointer to Netchan_Transmit
	void (*pfnNET_SendPacket)(enum netsrc_s sock, int length, void *data, netadr_t to); // &NET_SendPacket
	struct cvar_s *(*pfnCvarFindVar)(const char *pchName);				// pointer to Cvar_FindVar
	int *phinstOpenGlEarly;					// &g_hinstOpenGlEarly

	// Reserved for future expansion
	void *pVoid0;							// reserved for future expan
	void *pVoid1;							// reserved for future expan
	void *pVoid2;							// reserved for future expan
	void *pVoid3;							// reserved for future expan
	void *pVoid4;							// reserved for future expan
	void *pVoid5;							// reserved for future expan
	void *pVoid6;							// reserved for future expan
	void *pVoid7;							// reserved for future expan
	void *pVoid8;							// reserved for future expan
	void *pVoid9;							// reserved for future expan
} engdata_t;


// ********************************************************
// Functions exposed by the security module
// ********************************************************
typedef void (*PFN_LOADMOD)(char *pchModule);
typedef void (*PFN_CLOSEMOD)(void);
typedef int (*PFN_NCALL)(int ijump, int cnArg, ...);

typedef void (*PFN_GETCLDSTADDRS)(cldll_func_dst_t *pcldstAddrs);
typedef void (*PFN_GETENGDSTADDRS)(cl_enginefunc_dst_t *pengdstAddrs);
typedef void (*PFN_MODULELOADED)(void);

typedef void (*PFN_PROCESSOUTGOINGNET)(struct netchan_s *pchan, struct sizebuf_s *psizebuf);
typedef qboolean (*PFN_PROCESSINCOMINGNET)(struct netchan_s *pchan, struct sizebuf_s *psizebuf);

typedef void (*PFN_TEXTURELOAD)(char *pszName, int dxWidth, int dyHeight, char *pbData);
typedef void (*PFN_MODELLOAD)(struct model_s *pmodel, void *pvBuf);

typedef void (*PFN_FRAMEBEGIN)(void);
typedef void (*PFN_FRAMERENDER1)(void);
typedef void (*PFN_FRAMERENDER2)(void);

typedef void (*PFN_SETMODSHELPERS)(modshelpers_t *pmodshelpers);
typedef void (*PFN_SETMODCHELPERS)(modchelpers_t *pmodchelpers);
typedef void (*PFN_SETENGDATA)(engdata_t *pengdata);

typedef void (*PFN_CONNECTCLIENT)(int iPlayer);
typedef void (*PFN_RECORDIP)(unsigned int pnIP);
typedef void (*PFN_PLAYERSTATUS)(unsigned char *pbData, int cbData);

typedef void (*PFN_SETENGINEVERSION)(int nVersion);

// typedef class CMachine *(*PFN_PCMACHINE)(void);
typedef int (*PFN_PCMACHINE)(void);
typedef void (*PFN_SETIP)(int ijump);
typedef void (*PFN_EXECUTE)(void);

typedef struct modfuncs_s
{
	// Functions for the pcode interpreter
	PFN_LOADMOD m_pfnLoadMod;
	PFN_CLOSEMOD m_pfnCloseMod;
	PFN_NCALL m_pfnNCall;

	// API destination functions
	PFN_GETCLDSTADDRS m_pfnGetClDstAddrs;
	PFN_GETENGDSTADDRS m_pfnGetEngDstAddrs;

	// Miscellaneous functions
	PFN_MODULELOADED m_pfnModuleLoaded;     // Called right after the module is loaded

	// Functions for processing network traffic
	PFN_PROCESSOUTGOINGNET m_pfnProcessOutgoingNet;   // Every outgoing packet gets run through this
	PFN_PROCESSINCOMINGNET m_pfnProcessIncomingNet;   // Every incoming packet gets run through this

	// Resource functions
	PFN_TEXTURELOAD m_pfnTextureLoad;     // Called as each texture is loaded
	PFN_MODELLOAD m_pfnModelLoad;         // Called as each model is loaded

	// Functions called every frame
	PFN_FRAMEBEGIN m_pfnFrameBegin;       // Called at the beginning of each frame cycle
	PFN_FRAMERENDER1 m_pfnFrameRender1;   // Called at the beginning of the render loop
	PFN_FRAMERENDER2 m_pfnFrameRender2;   // Called at the end of the render loop

	// Module helper transfer
	PFN_SETMODSHELPERS m_pfnSetModSHelpers;
	PFN_SETMODCHELPERS m_pfnSetModCHelpers;
	PFN_SETENGDATA m_pfnSetEngData;

	// Which version of the module is this?
	int m_nVersion;

	// Miscellaneous game stuff
	PFN_CONNECTCLIENT m_pfnConnectClient;	// Called whenever a new client connects
	PFN_RECORDIP m_pfnRecordIP;				// Secure master has reported a new IP for us
	PFN_PLAYERSTATUS m_pfnPlayerStatus;		// Called whenever we receive a PlayerStatus packet

	// Recent additions
	PFN_SETENGINEVERSION m_pfnSetEngineVersion;	// 1 = patched engine

	// reserved for future expansion
	int m_nVoid2;
	int m_nVoid3;
	int m_nVoid4;
	int m_nVoid5;
	int m_nVoid6;
	int m_nVoid7;
	int m_nVoid8;
	int m_nVoid9;
} modfuncs_t;


#define k_nEngineVersion15Base		0
#define k_nEngineVersion15Patch		1
#define k_nEngineVersion16Base		2
#define k_nEngineVersion16Validated	3		// 1.6 engine with built-in validation


typedef struct validator_s
{
	int m_nRandomizer;			// Random number to be XOR'd into all subsequent fields
	int m_nSignature1;			// First signature that identifies this structure
	int m_nSignature2;			// Second signature
	int m_pbCode;				// Beginning of the code block
	int m_cbCode;				// Size of the code block
	int m_nChecksum;			// Checksum of the code block
	int m_nSpecial;				// For engine, 1 if hw.dll, 0 if sw.dll.  For client, pclfuncs checksum
	int m_nCompensator;			// Keeps the checksum correct
} validator_t;


#define k_nChecksumCompensator 0x36a8f09c	// Don't change this value: it's hardcorded in cdll_int.cpp, 

#define k_nModuleVersionCur 0x43210004


#endif // __APIPROXY__

```

`engine/Sequence.h`:

```h
//---------------------------------------------------------------------------
// 
//		S c r i p t e d   S e q u e n c e s
// 
//---------------------------------------------------------------------------
#ifndef _INCLUDE_SEQUENCE_H_
#define _INCLUDE_SEQUENCE_H_


#ifndef _DEF_BYTE_
typedef unsigned char byte;
#endif

//---------------------------------------------------------------------------
// client_textmessage_t
//---------------------------------------------------------------------------

#define CLIENT_TEXTMESAGE_S
typedef struct client_textmessage_s
{
	int		effect;
	byte	r1, g1, b1, a1;		// 2 colors for effects
	byte	r2, g2, b2, a2;
	float	x;
	float	y;
	float	fadein;
	float	fadeout;
	float	holdtime;
	float	fxtime;
	const char *pName;
	const char *pMessage;
} client_textmessage_t;

//--------------------------------------------------------------------------
// sequenceDefaultBits_e
//	
// Enumerated list of possible modifiers for a command.  This enumeration
// is used in a bitarray controlling what modifiers are specified for a command.
//---------------------------------------------------------------------------
enum sequenceModifierBits
{
	SEQUENCE_MODIFIER_EFFECT_BIT		= (1 << 1),
	SEQUENCE_MODIFIER_POSITION_BIT		= (1 << 2),
	SEQUENCE_MODIFIER_COLOR_BIT			= (1 << 3),
	SEQUENCE_MODIFIER_COLOR2_BIT		= (1 << 4),
	SEQUENCE_MODIFIER_FADEIN_BIT		= (1 << 5),
	SEQUENCE_MODIFIER_FADEOUT_BIT		= (1 << 6),
	SEQUENCE_MODIFIER_HOLDTIME_BIT		= (1 << 7),
	SEQUENCE_MODIFIER_FXTIME_BIT		= (1 << 8),
	SEQUENCE_MODIFIER_SPEAKER_BIT		= (1 << 9),
	SEQUENCE_MODIFIER_LISTENER_BIT		= (1 << 10),
	SEQUENCE_MODIFIER_TEXTCHANNEL_BIT	= (1 << 11),
};
typedef enum sequenceModifierBits sequenceModifierBits_e ;


//---------------------------------------------------------------------------
// sequenceCommandEnum_e
// 
// Enumerated sequence command types.
//---------------------------------------------------------------------------
enum sequenceCommandEnum_
{
	SEQUENCE_COMMAND_ERROR = -1,
	SEQUENCE_COMMAND_PAUSE = 0,
	SEQUENCE_COMMAND_FIRETARGETS,
	SEQUENCE_COMMAND_KILLTARGETS,
	SEQUENCE_COMMAND_TEXT,
	SEQUENCE_COMMAND_SOUND,
	SEQUENCE_COMMAND_GOSUB,
	SEQUENCE_COMMAND_SENTENCE,
	SEQUENCE_COMMAND_REPEAT,
	SEQUENCE_COMMAND_SETDEFAULTS,
	SEQUENCE_COMMAND_MODIFIER,
	SEQUENCE_COMMAND_POSTMODIFIER,
	SEQUENCE_COMMAND_NOOP,

	SEQUENCE_MODIFIER_EFFECT,
	SEQUENCE_MODIFIER_POSITION,
	SEQUENCE_MODIFIER_COLOR,
	SEQUENCE_MODIFIER_COLOR2,
	SEQUENCE_MODIFIER_FADEIN,
	SEQUENCE_MODIFIER_FADEOUT,
	SEQUENCE_MODIFIER_HOLDTIME,
	SEQUENCE_MODIFIER_FXTIME,
	SEQUENCE_MODIFIER_SPEAKER,
	SEQUENCE_MODIFIER_LISTENER,
	SEQUENCE_MODIFIER_TEXTCHANNEL,
};
typedef enum sequenceCommandEnum_ sequenceCommandEnum_e;


//---------------------------------------------------------------------------
// sequenceCommandType_e
// 
// Typeerated sequence command types.
//---------------------------------------------------------------------------
enum sequenceCommandType_
{
	SEQUENCE_TYPE_COMMAND,
	SEQUENCE_TYPE_MODIFIER,
};
typedef enum sequenceCommandType_ sequenceCommandType_e;


//---------------------------------------------------------------------------
// sequenceCommandMapping_s
// 
// A mapping of a command enumerated-value to its name.
//---------------------------------------------------------------------------
typedef struct sequenceCommandMapping_ sequenceCommandMapping_s;
struct sequenceCommandMapping_
{
	sequenceCommandEnum_e	commandEnum;
	const char*				commandName;
	sequenceCommandType_e	commandType;
};


//---------------------------------------------------------------------------
// sequenceCommandLine_s
// 
// Structure representing a single command (usually 1 line) from a
//	.SEQ file entry.
//---------------------------------------------------------------------------
typedef struct sequenceCommandLine_ sequenceCommandLine_s;
struct sequenceCommandLine_
{
	int						commandType;		// Specifies the type of command
	client_textmessage_t	clientMessage;		// Text HUD message struct
	char*					speakerName;		// Targetname of speaking entity
	char*					listenerName;		// Targetname of entity being spoken to
	char*					soundFileName;		// Name of sound file to play
	char*					sentenceName;		// Name of sentences.txt to play
	char*					fireTargetNames;	// List of targetnames to fire
	char*					killTargetNames;	// List of targetnames to remove
	float					delay;				// Seconds 'till next command
	int						repeatCount;		// If nonzero, reset execution pointer to top of block (N times, -1 = infinite)
	int						textChannel;		// Display channel on which text message is sent
	int						modifierBitField;	// Bit field to specify what clientmessage fields are valid
	sequenceCommandLine_s*	nextCommandLine;	// Next command (linked list)
};


//---------------------------------------------------------------------------
// sequenceEntry_s
// 
// Structure representing a single command (usually 1 line) from a
//	.SEQ file entry.
//---------------------------------------------------------------------------
typedef struct sequenceEntry_ sequenceEntry_s;
struct sequenceEntry_
{
	char*					fileName;		// Name of sequence file without .SEQ extension
	char*					entryName;		// Name of entry label in file
	sequenceCommandLine_s*	firstCommand;	// Linked list of commands in entry
	sequenceEntry_s*		nextEntry;		// Next loaded entry
	qboolean				isGlobal;		// Is entry retained over level transitions?
};



//---------------------------------------------------------------------------
// sentenceEntry_s
// Structure representing a single sentence of a group from a .SEQ
// file entry.  Sentences are identical to entries in sentences.txt, but
// can be unique per level and are loaded/unloaded with the level.
//---------------------------------------------------------------------------
typedef struct sentenceEntry_ sentenceEntry_s;
struct sentenceEntry_
{
	char*					data;			// sentence data (ie "We have hostiles" )
	sentenceEntry_s*		nextEntry;		// Next loaded entry
	qboolean				isGlobal;		// Is entry retained over level transitions?
	unsigned int			index;			// this entry's position in the file.
};

//--------------------------------------------------------------------------
// sentenceGroupEntry_s
// Structure representing a group of sentences found in a .SEQ file.
// A sentence group is defined by all sentences with the same name, ignoring
// the number at the end of the sentence name.  Groups enable a sentence
// to be picked at random across a group.
//--------------------------------------------------------------------------
typedef struct sentenceGroupEntry_ sentenceGroupEntry_s;
struct sentenceGroupEntry_
{
	char*					groupName;		// name of the group (ie CT_ALERT )
	unsigned int			numSentences;	// number of sentences in group
	sentenceEntry_s*		firstSentence;	// head of linked list of sentences in group
	sentenceGroupEntry_s*	nextEntry;		// next loaded group
};

//---------------------------------------------------------------------------
// Function declarations
//---------------------------------------------------------------------------
sequenceEntry_s* SequenceGet( const char* fileName, const char* entryName );
void Sequence_ParseFile( const char* fileName, qboolean isGlobal );
void Sequence_OnLevelLoad( const char* mapName );
sentenceEntry_s* SequencePickSentence( const char *groupName, int pickMethod, int *picked );

#endif /* _INCLUDE_SEQUENCE_H_ */

```

`engine/anorms.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

{-0.525731, 0.000000, 0.850651}, 
{-0.442863, 0.238856, 0.864188}, 
{-0.295242, 0.000000, 0.955423}, 
{-0.309017, 0.500000, 0.809017}, 
{-0.162460, 0.262866, 0.951056}, 
{0.000000, 0.000000, 1.000000}, 
{0.000000, 0.850651, 0.525731}, 
{-0.147621, 0.716567, 0.681718}, 
{0.147621, 0.716567, 0.681718}, 
{0.000000, 0.525731, 0.850651}, 
{0.309017, 0.500000, 0.809017}, 
{0.525731, 0.000000, 0.850651}, 
{0.295242, 0.000000, 0.955423}, 
{0.442863, 0.238856, 0.864188}, 
{0.162460, 0.262866, 0.951056}, 
{-0.681718, 0.147621, 0.716567}, 
{-0.809017, 0.309017, 0.500000}, 
{-0.587785, 0.425325, 0.688191}, 
{-0.850651, 0.525731, 0.000000}, 
{-0.864188, 0.442863, 0.238856}, 
{-0.716567, 0.681718, 0.147621}, 
{-0.688191, 0.587785, 0.425325}, 
{-0.500000, 0.809017, 0.309017}, 
{-0.238856, 0.864188, 0.442863}, 
{-0.425325, 0.688191, 0.587785}, 
{-0.716567, 0.681718, -0.147621}, 
{-0.500000, 0.809017, -0.309017}, 
{-0.525731, 0.850651, 0.000000}, 
{0.000000, 0.850651, -0.525731}, 
{-0.238856, 0.864188, -0.442863}, 
{0.000000, 0.955423, -0.295242}, 
{-0.262866, 0.951056, -0.162460}, 
{0.000000, 1.000000, 0.000000}, 
{0.000000, 0.955423, 0.295242}, 
{-0.262866, 0.951056, 0.162460}, 
{0.238856, 0.864188, 0.442863}, 
{0.262866, 0.951056, 0.162460}, 
{0.500000, 0.809017, 0.309017}, 
{0.238856, 0.864188, -0.442863}, 
{0.262866, 0.951056, -0.162460}, 
{0.500000, 0.809017, -0.309017}, 
{0.850651, 0.525731, 0.000000}, 
{0.716567, 0.681718, 0.147621}, 
{0.716567, 0.681718, -0.147621}, 
{0.525731, 0.850651, 0.000000}, 
{0.425325, 0.688191, 0.587785}, 
{0.864188, 0.442863, 0.238856}, 
{0.688191, 0.587785, 0.425325}, 
{0.809017, 0.309017, 0.500000}, 
{0.681718, 0.147621, 0.716567}, 
{0.587785, 0.425325, 0.688191}, 
{0.955423, 0.295242, 0.000000}, 
{1.000000, 0.000000, 0.000000}, 
{0.951056, 0.162460, 0.262866}, 
{0.850651, -0.525731, 0.000000}, 
{0.955423, -0.295242, 0.000000}, 
{0.864188, -0.442863, 0.238856}, 
{0.951056, -0.162460, 0.262866}, 
{0.809017, -0.309017, 0.500000}, 
{0.681718, -0.147621, 0.716567}, 
{0.850651, 0.000000, 0.525731}, 
{0.864188, 0.442863, -0.238856}, 
{0.809017, 0.309017, -0.500000}, 
{0.951056, 0.162460, -0.262866}, 
{0.525731, 0.000000, -0.850651}, 
{0.681718, 0.147621, -0.716567}, 
{0.681718, -0.147621, -0.716567}, 
{0.850651, 0.000000, -0.525731}, 
{0.809017, -0.309017, -0.500000}, 
{0.864188, -0.442863, -0.238856}, 
{0.951056, -0.162460, -0.262866}, 
{0.147621, 0.716567, -0.681718}, 
{0.309017, 0.500000, -0.809017}, 
{0.425325, 0.688191, -0.587785}, 
{0.442863, 0.238856, -0.864188}, 
{0.587785, 0.425325, -0.688191}, 
{0.688191, 0.587785, -0.425325}, 
{-0.147621, 0.716567, -0.681718}, 
{-0.309017, 0.500000, -0.809017}, 
{0.000000, 0.525731, -0.850651}, 
{-0.525731, 0.000000, -0.850651}, 
{-0.442863, 0.238856, -0.864188}, 
{-0.295242, 0.000000, -0.955423}, 
{-0.162460, 0.262866, -0.951056}, 
{0.000000, 0.000000, -1.000000}, 
{0.295242, 0.000000, -0.955423}, 
{0.162460, 0.262866, -0.951056}, 
{-0.442863, -0.238856, -0.864188}, 
{-0.309017, -0.500000, -0.809017}, 
{-0.162460, -0.262866, -0.951056}, 
{0.000000, -0.850651, -0.525731}, 
{-0.147621, -0.716567, -0.681718}, 
{0.147621, -0.716567, -0.681718}, 
{0.000000, -0.525731, -0.850651}, 
{0.309017, -0.500000, -0.809017}, 
{0.442863, -0.238856, -0.864188}, 
{0.162460, -0.262866, -0.951056}, 
{0.238856, -0.864188, -0.442863}, 
{0.500000, -0.809017, -0.309017}, 
{0.425325, -0.688191, -0.587785}, 
{0.716567, -0.681718, -0.147621}, 
{0.688191, -0.587785, -0.425325}, 
{0.587785, -0.425325, -0.688191}, 
{0.000000, -0.955423, -0.295242}, 
{0.000000, -1.000000, 0.000000}, 
{0.262866, -0.951056, -0.162460}, 
{0.000000, -0.850651, 0.525731}, 
{0.000000, -0.955423, 0.295242}, 
{0.238856, -0.864188, 0.442863}, 
{0.262866, -0.951056, 0.162460}, 
{0.500000, -0.809017, 0.309017}, 
{0.716567, -0.681718, 0.147621}, 
{0.525731, -0.850651, 0.000000}, 
{-0.238856, -0.864188, -0.442863}, 
{-0.500000, -0.809017, -0.309017}, 
{-0.262866, -0.951056, -0.162460}, 
{-0.850651, -0.525731, 0.000000}, 
{-0.716567, -0.681718, -0.147621}, 
{-0.716567, -0.681718, 0.147621}, 
{-0.525731, -0.850651, 0.000000}, 
{-0.500000, -0.809017, 0.309017}, 
{-0.238856, -0.864188, 0.442863}, 
{-0.262866, -0.951056, 0.162460}, 
{-0.864188, -0.442863, 0.238856}, 
{-0.809017, -0.309017, 0.500000}, 
{-0.688191, -0.587785, 0.425325}, 
{-0.681718, -0.147621, 0.716567}, 
{-0.442863, -0.238856, 0.864188}, 
{-0.587785, -0.425325, 0.688191}, 
{-0.309017, -0.500000, 0.809017}, 
{-0.147621, -0.716567, 0.681718}, 
{-0.425325, -0.688191, 0.587785}, 
{-0.162460, -0.262866, 0.951056}, 
{0.442863, -0.238856, 0.864188}, 
{0.162460, -0.262866, 0.951056}, 
{0.309017, -0.500000, 0.809017}, 
{0.147621, -0.716567, 0.681718}, 
{0.000000, -0.525731, 0.850651}, 
{0.425325, -0.688191, 0.587785}, 
{0.587785, -0.425325, 0.688191}, 
{0.688191, -0.587785, 0.425325}, 
{-0.955423, 0.295242, 0.000000}, 
{-0.951056, 0.162460, 0.262866}, 
{-1.000000, 0.000000, 0.000000}, 
{-0.850651, 0.000000, 0.525731}, 
{-0.955423, -0.295242, 0.000000}, 
{-0.951056, -0.162460, 0.262866}, 
{-0.864188, 0.442863, -0.238856}, 
{-0.951056, 0.162460, -0.262866}, 
{-0.809017, 0.309017, -0.500000}, 
{-0.864188, -0.442863, -0.238856}, 
{-0.951056, -0.162460, -0.262866}, 
{-0.809017, -0.309017, -0.500000}, 
{-0.681718, 0.147621, -0.716567}, 
{-0.681718, -0.147621, -0.716567}, 
{-0.850651, 0.000000, -0.525731}, 
{-0.688191, 0.587785, -0.425325}, 
{-0.587785, 0.425325, -0.688191}, 
{-0.425325, 0.688191, -0.587785}, 
{-0.425325, -0.688191, -0.587785}, 
{-0.587785, -0.425325, -0.688191}, 
{-0.688191, -0.587785, -0.425325}, 

```

`engine/archtypes.h`:

```h
//
// Word size dependent definitions
// DAL 1/03
//
#ifndef ARCHTYPES_H
#define ARCHTYPES_H

#if defined(__x86_64__) || defined(_WIN64) || defined(__aarch64__) || defined(__powerpc64__)
#define X64BITS
#endif

#if defined( _WIN32 ) && (! defined( __MINGW32__ ))

typedef __int16 int16;
typedef unsigned __int16 uint16;
typedef __int32 int32;
typedef unsigned __int32 uint32;
typedef __int64 int64;
typedef unsigned __int64 uint64;

#ifdef X64BITS
typedef __int64 intp;				// intp is an integer that can accomodate a pointer
typedef unsigned __int64 uintp;		// (ie, sizeof(intp) >= sizeof(int) && sizeof(intp) >= sizeof(void *)
#else
typedef __int32 intp;
typedef unsigned __int32 uintp;
#endif	// (ie, sizeof(intp) >= sizeof(int) && sizeof(intp) >= sizeof(void *)

#else /* _WIN32 */

typedef short int16;
typedef unsigned short uint16;
typedef int int32;
typedef unsigned int uint32;
typedef long long int64;
typedef unsigned long long uint64;
#ifdef X64BITS
typedef long long intp;
typedef unsigned long long uintp;
#else
typedef int intp;
typedef unsigned int uintp;
#endif

#endif /* else _WIN32 */

#endif /* ARCHTYPES_H */

```

`engine/cdll_int.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cdll_int.h
//
// 4-23-98  
// JOHN:  client dll interface declarations
//

#ifndef CDLL_INT_H
#define CDLL_INT_H

#ifdef __cplusplus
extern "C" {
#endif

#include "const.h"
#include "steam/steamtypes.h"
#include "ref_params.h"
#include "r_efx.h"
#include "studio_event.h"

// this file is included by both the engine and the client-dll,
// so make sure engine declarations aren't done twice

typedef int HSPRITE;	// handle to a graphic

#define SCRINFO_SCREENFLASH 1
#define SCRINFO_STRETCHED	2

typedef struct SCREENINFO_s
{
	int		iSize;
	int		iWidth;
	int		iHeight;
	int		iFlags;
	int		iCharHeight;
	short	charWidths[256];
} SCREENINFO;


typedef struct client_data_s
{
	// fields that cannot be modified  (ie. have no effect if changed)
	vec3_t origin;

	// fields that can be changed by the cldll
	vec3_t viewangles;
	int		iWeaponBits;
//	int		iAccessoryBits;
	float	fov;	// field of view
} client_data_t;

typedef struct client_sprite_s
{
	char szName[64];
	char szSprite[64];
	int hspr;
	int iRes;
	wrect_t rc;
} client_sprite_t;



typedef struct hud_player_info_s
{
	char *name;
	short ping;
	byte thisplayer;  // TRUE if this is the calling player

	byte spectator;
	byte packetloss;

	char *model;
	short topcolor;
	short bottomcolor;

	uint64 m_nSteamID;
} hud_player_info_t;



typedef struct module_s
{
	unsigned char				ucMD5Hash[16];	// hash over code
	qboolean					fLoaded;		// true if successfully loaded
} module_t;



	
		

#ifndef IN_BUTTONS_H
#include "in_buttons.h"
#endif

#define CLDLL_INTERFACE_VERSION		7

extern void LoadSecurityModuleFromDisk(char * pszDllName);
extern void LoadSecurityModuleFromMemory( unsigned char * pCode, int nSize );
extern void CloseSecurityModule();


extern void ClientDLL_Init( void ); // from cdll_int.c
extern void ClientDLL_Shutdown( void );
extern void ClientDLL_HudInit( void );
extern void ClientDLL_HudVidInit( void );
extern void	ClientDLL_UpdateClientData( void );
extern void ClientDLL_Frame( double time );
extern void ClientDLL_HudRedraw( int intermission );
extern void ClientDLL_MoveClient( struct playermove_s *ppmove );
extern void ClientDLL_ClientMoveInit( struct playermove_s *ppmove );
extern char ClientDLL_ClientTextureType( char *name );

extern void ClientDLL_CreateMove( float frametime, struct usercmd_s *cmd, int active );
extern void ClientDLL_ActivateMouse( void );
extern void ClientDLL_DeactivateMouse( void );
extern void ClientDLL_MouseEvent( int mstate );
extern void ClientDLL_ClearStates( void );
extern int ClientDLL_IsThirdPerson( void );
extern void ClientDLL_GetCameraOffsets( float *ofs );
extern int ClientDLL_GraphKeyDown( void );
extern struct kbutton_s *ClientDLL_FindKey( const char *name );
extern void ClientDLL_CAM_Think( void );
extern void ClientDLL_IN_Accumulate( void );
extern void ClientDLL_CalcRefdef( struct ref_params_s *pparams );
extern int ClientDLL_AddEntity( int type, struct cl_entity_s *ent );
extern void ClientDLL_CreateEntities( void );

extern void ClientDLL_DrawNormalTriangles( void );
extern void ClientDLL_DrawTransparentTriangles( void );
extern void ClientDLL_StudioEvent( const struct mstudioevent_s *event, const struct cl_entity_s *entity );
extern void ClientDLL_PostRunCmd( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
extern void ClientDLL_TxferLocalOverrides( struct entity_state_s *state, const struct clientdata_s *client );
extern void ClientDLL_ProcessPlayerState( struct entity_state_s *dst, const struct entity_state_s *src );
extern void ClientDLL_TxferPredictionData ( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd );
extern void ClientDLL_ReadDemoBuffer( int size, unsigned char *buffer );
extern int ClientDLL_ConnectionlessPacket( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );
extern int ClientDLL_GetHullBounds( int hullnumber, float *mins, float *maxs );

extern void ClientDLL_VGui_ConsolePrint(const char* text);

extern int ClientDLL_Key_Event( int down, int keynum, const char *pszCurrentBinding );
extern void ClientDLL_TempEntUpdate( double ft, double ct, double grav, struct tempent_s **ppFreeTE, struct tempent_s **ppActiveTE, int ( *addTEntity )( struct cl_entity_s *pEntity ), void ( *playTESound )( struct tempent_s *pTemp, float damp ) );
extern struct cl_entity_s *ClientDLL_GetUserEntity( int index );
extern void ClientDLL_VoiceStatus(int entindex, qboolean bTalking);
extern void ClientDLL_DirectorMessage( int iSize, void *pbuf );
extern void ClientDLL_ChatInputPosition( int *x, int *y );

//#include "server.h" // server_static_t define for apiproxy
#include "APIProxy.h"

extern cldll_func_t	cl_funcs;
extern cl_enginefunc_t cl_engsrcProxies;
extern cl_enginefunc_dst_t g_engdstAddrs;

// Module exports
extern modfuncs_t g_modfuncs;
extern module_t	g_module;

// Macros for exported engine funcs
#define RecEngSPR_Load(a)					(g_engdstAddrs.pfnSPR_Load(&a))
#define RecEngSPR_Frames(a)					(g_engdstAddrs.pfnSPR_Frames(&a))
#define RecEngSPR_Height(a, b)				(g_engdstAddrs.pfnSPR_Height(&a, &b))
#define RecEngSPR_Width(a, b)				(g_engdstAddrs.pfnSPR_Width(&a, &b))
#define RecEngSPR_Set(a, b, c, d)			(g_engdstAddrs.pfnSPR_Set(&a, &b, &c, &d))
#define RecEngSPR_Draw(a, b, c, d)			(g_engdstAddrs.pfnSPR_Draw(&a, &b, &c, &d))
#define RecEngSPR_DrawHoles(a, b, c, d)		(g_engdstAddrs.pfnSPR_DrawHoles(&a, &b, &c, &d))
#define RecEngSPR_DrawAdditive(a, b, c, d)	(g_engdstAddrs.pfnSPR_DrawAdditive(&a, &b, &c, &d))
#define RecEngSPR_EnableScissor(a, b, c, d)	(g_engdstAddrs.pfnSPR_EnableScissor(&a, &b, &c, &d))
#define RecEngSPR_DisableScissor()			(g_engdstAddrs.pfnSPR_DisableScissor())
#define RecEngSPR_GetList(a, b)				(g_engdstAddrs.pfnSPR_GetList(&a, &b))
#define RecEngDraw_FillRGBA(a, b, c, d, e, f, g, h)		(g_engdstAddrs.pfnFillRGBA(&a, &b, &c, &d, &e, &f, &g, &h))
#define RecEnghudGetScreenInfo(a)			(g_engdstAddrs.pfnGetScreenInfo(&a))
#define RecEngSetCrosshair(a, b, c, d, e)	(g_engdstAddrs.pfnSetCrosshair(&a, &b, &c, &d, &e))
#define RecEnghudRegisterVariable(a, b, c)	(g_engdstAddrs.pfnRegisterVariable(&a, &b, &c))
#define RecEnghudGetCvarFloat(a)			(g_engdstAddrs.pfnGetCvarFloat(&a))
#define RecEnghudGetCvarString(a)			(g_engdstAddrs.pfnGetCvarString(&a))
#define RecEnghudAddCommand(a, b)			(g_engdstAddrs.pfnAddCommand(&a, &b))
#define RecEnghudHookUserMsg(a, b)			(g_engdstAddrs.pfnHookUserMsg(&a, &b))
#define RecEnghudServerCmd(a)				(g_engdstAddrs.pfnServerCmd(&a))
#define RecEnghudClientCmd(a)				(g_engdstAddrs.pfnClientCmd(&a))
#define RecEnghudFilteredClientCmd(a)		(g_engdstAddrs.pfnFilteredClientCmd(&a))
#define RecEngPrimeMusicStream(a, b)	(g_engdstAddrs.pfnPrimeMusicStream(&a, &b))
#define RecEnghudGetPlayerInfo(a, b)		(g_engdstAddrs.pfnGetPlayerInfo(&a, &b))
#define RecEnghudPlaySoundByName(a, b)		(g_engdstAddrs.pfnPlaySoundByName(&a, &b))
#define RecEnghudPlaySoundByNameAtPitch(a, b, c)	(g_engdstAddrs.pfnPlaySoundByNameAtPitch(&a, &b, &c))
#define RecEnghudPlaySoundVoiceByName(a, b)	(g_engdstAddrs.pfnPlaySoundVoiceByName(&a, &b))
#define RecEnghudPlaySoundByIndex(a, b)		(g_engdstAddrs.pfnPlaySoundByIndex(&a, &b))
#define RecEngAngleVectors(a, b, c, d)		(g_engdstAddrs.pfnAngleVectors(&a, &b, &c, &d))
#define RecEngTextMessageGet(a)				(g_engdstAddrs.pfnTextMessageGet(&a))
#define RecEngTextMessageDrawCharacter(a, b, c, d, e, f)	(g_engdstAddrs.pfnDrawCharacter(&a, &b, &c, &d, &e, &f))
#define RecEngDrawConsoleString(a, b, c)	(g_engdstAddrs.pfnDrawConsoleString(&a, &b, &c))
#define RecEngDrawSetTextColor(a, b, c)		(g_engdstAddrs.pfnDrawSetTextColor(&a, &b, &c))
#define RecEnghudDrawConsoleStringLen(a, b, c)	(g_engdstAddrs.pfnDrawConsoleStringLen(&a, &b, &c))
#define RecEnghudConsolePrint(a)			(g_engdstAddrs.pfnConsolePrint(&a))
#define RecEnghudCenterPrint(a)				(g_engdstAddrs.pfnCenterPrint(&a))
#define RecEnghudCenterX()					(g_engdstAddrs.GetWindowCenterX())
#define RecEnghudCenterY()					(g_engdstAddrs.GetWindowCenterY())
#define RecEnghudGetViewAngles(a)			(g_engdstAddrs.GetViewAngles(&a))
#define RecEnghudSetViewAngles(a)			(g_engdstAddrs.SetViewAngles(&a))
#define RecEnghudGetMaxClients()			(g_engdstAddrs.GetMaxClients())
#define RecEngCvar_SetValue(a, b)			(g_engdstAddrs.Cvar_SetValue(&a, &b))
#define RecEngCmd_Argc()					(g_engdstAddrs.Cmd_Argc())
#define RecEngCmd_Argv(a)					(g_engdstAddrs.Cmd_Argv(&a))
#define RecEngCon_Printf(a)					(g_engdstAddrs.Con_Printf(&a))
#define RecEngCon_DPrintf(a)				(g_engdstAddrs.Con_DPrintf(&a))
#define RecEngCon_NPrintf(a, b)				(g_engdstAddrs.Con_NPrintf(&a, &b))
#define RecEngCon_NXPrintf(a, b)			(g_engdstAddrs.Con_NXPrintf(&a, &b))
#define RecEnghudPhysInfo_ValueForKey(a)	(g_engdstAddrs.PhysInfo_ValueForKey(&a))
#define RecEnghudServerInfo_ValueForKey(a)	(g_engdstAddrs.ServerInfo_ValueForKey(&a))
#define RecEnghudGetClientMaxspeed()		(g_engdstAddrs.GetClientMaxspeed())
#define RecEnghudCheckParm(a, b)			(g_engdstAddrs.CheckParm(&a, &b))
#define RecEngKey_Event(a, b)				(g_engdstAddrs.Key_Event(&a, &b))
#define RecEnghudGetMousePosition(a, b)		(g_engdstAddrs.GetMousePosition(&a, &b))
#define RecEnghudIsNoClipping()				(g_engdstAddrs.IsNoClipping())
#define RecEnghudGetLocalPlayer()			(g_engdstAddrs.GetLocalPlayer())
#define RecEnghudGetViewModel()				(g_engdstAddrs.GetViewModel())
#define RecEnghudGetEntityByIndex(a)		(g_engdstAddrs.GetEntityByIndex(&a))
#define RecEnghudGetClientTime()			(g_engdstAddrs.GetClientTime())
#define RecEngV_CalcShake()					(g_engdstAddrs.V_CalcShake())
#define RecEngV_ApplyShake(a, b, c)			(g_engdstAddrs.V_ApplyShake(&a, &b, &c))
#define RecEngPM_PointContents(a, b)		(g_engdstAddrs.PM_PointContents(&a, &b))
#define RecEngPM_WaterEntity(a)				(g_engdstAddrs.PM_WaterEntity(&a))
#define RecEngPM_TraceLine(a, b, c, d, e)	(g_engdstAddrs.PM_TraceLine(&a, &b, &c, &d, &e))
#define RecEngCL_LoadModel(a, b)			(g_engdstAddrs.CL_LoadModel(&a, &b))
#define RecEngCL_CreateVisibleEntity(a, b)	(g_engdstAddrs.CL_CreateVisibleEntity(&a, &b))
#define RecEnghudGetSpritePointer(a)		(g_engdstAddrs.GetSpritePointer(&a))
#define RecEnghudPlaySoundByNameAtLocation(a, b, c)		(g_engdstAddrs.pfnPlaySoundByNameAtLocation(&a, &b, &c))
#define RecEnghudPrecacheEvent(a, b)		(g_engdstAddrs.pfnPrecacheEvent(&a, &b))
#define RecEnghudPlaybackEvent(a, b, c, d, e, f, g, h, i, j, k, l)	(g_engdstAddrs.pfnPlaybackEvent(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l))
#define RecEnghudWeaponAnim(a, b)			(g_engdstAddrs.pfnWeaponAnim(&a, &b))
#define RecEngRandomFloat(a, b)				(g_engdstAddrs.pfnRandomFloat(&a, &b))
#define RecEngRandomLong(a, b)				(g_engdstAddrs.pfnRandomLong(&a, &b))
#define RecEngCL_HookEvent(a, b)			(g_engdstAddrs.pfnHookEvent(&a, &b))
#define RecEngCon_IsVisible()				(g_engdstAddrs.Con_IsVisible())
#define RecEnghudGetGameDir()				(g_engdstAddrs.pfnGetGameDirectory())
#define RecEngCvar_FindVar(a)				(g_engdstAddrs.pfnGetCvarPointer(&a))
#define RecEngKey_NameForBinding(a)			(g_engdstAddrs.Key_LookupBinding(&a))
#define RecEnghudGetLevelName()				(g_engdstAddrs.pfnGetLevelName())
#define RecEnghudGetScreenFade(a)			(g_engdstAddrs.pfnGetScreenFade(&a))
#define RecEnghudSetScreenFade(a)			(g_engdstAddrs.pfnSetScreenFade(&a))
#define RecEngVGuiWrap_GetPanel()			(g_engdstAddrs.VGui_GetPanel())
#define RecEngVGui_ViewportPaintBackground(a)	(g_engdstAddrs.VGui_ViewportPaintBackground(&a))
#define RecEngCOM_LoadFile(a, b, c)			(g_engdstAddrs.COM_LoadFile(&a, &b, &c))
#define RecEngCOM_ParseFile(a, b)			(g_engdstAddrs.COM_ParseFile(&a, &b))
#define RecEngCOM_FreeFile(a)				(g_engdstAddrs.COM_FreeFile(&a))
#define RecEngCL_IsSpectateOnly()			(g_engdstAddrs.IsSpectateOnly())
#define RecEngR_LoadMapSprite(a)			(g_engdstAddrs.LoadMapSprite(&a))
#define RecEngCOM_AddAppDirectoryToSearchPath(a, b)		(g_engdstAddrs.COM_AddAppDirectoryToSearchPath(&a, &b))
#define RecEngClientDLL_ExpandFileName(a, b, c)		(g_engdstAddrs.COM_ExpandFilename(&a, &b, &c))
#define RecEngPlayerInfo_ValueForKey(a, b)	(g_engdstAddrs.PlayerInfo_ValueForKey(&a, &b))
#define RecEngPlayerInfo_SetValueForKey(a, b)		(g_engdstAddrs.PlayerInfo_SetValueForKey(&a, &b))
#define RecEngGetPlayerUniqueID(a, b)		(g_engdstAddrs.GetPlayerUniqueID(&a, &b))
#define RecEngGetTrackerIDForPlayer(a)		(g_engdstAddrs.GetTrackerIDForPlayer(&a))
#define RecEngGetPlayerForTrackerID(a)		(g_engdstAddrs.GetPlayerForTrackerID(&a))
#define RecEnghudServerCmdUnreliable(a)		(g_engdstAddrs.pfnServerCmdUnreliable(&a))
#define RecEngGetMousePos(a)				(g_engdstAddrs.pfnGetMousePos(&a))
#define RecEngSetMousePos(a, b)				(g_engdstAddrs.pfnSetMousePos(&a, &b))
#define RecEngSetMouseEnable(a)				(g_engdstAddrs.pfnSetMouseEnable(&a))
#define RecEngSetFilterMode(a)				(g_engdstAddrs.pfnSetFilterMode(&a))
#define RecEngSetFilterColor(a,b,c)			(g_engdstAddrs.pfnSetFilterColor(&a,&b,&c))
#define RecEngSetFilterBrightness(a)		(g_engdstAddrs.pfnSetFilterBrightness(&a))
#define RecEngSequenceGet(a,b)				(g_engdstAddrs.pfnSequenceGet(&a,&b))
#define RecEngSPR_DrawGeneric(a,b,c,d,e,f,g,h)	(g_engdstAddrs.pfnSPR_DrawGeneric(&a, &b, &c, &d, &e, &f, &g, &h))
#define RecEngSequencePickSentence(a,b,c)	(g_engdstAddrs.pfnSequencePickSentence(&a, &b, &c))
#define RecEngLocalPlayerInfo_ValueForKey(a)	(g_engdstAddrs.LocalPlayerInfo_ValueForKey(&a))
#define RecEngProcessTutorMessageDecayBuffer(a, b)		(g_engdstAddrs.pfnProcessTutorMessageDecayBuffer(&a, &b))
#define RecEngConstructTutorMessageDecayBuffer(a, b)	(g_engdstAddrs.pfnConstructTutorMessageDecayBuffer(&a, &b))
#define RecEngResetTutorMessageDecayBuffer()		(g_engdstAddrs.pfnResetTutorMessageDecayBuffer())
#define RecEngDraw_FillRGBABlend(a, b, c, d, e, f, g, h)		(g_engdstAddrs.pfnFillRGBABlend(&a, &b, &c, &d, &e, &f, &g, &h))

// Dummy destination function for use when there's no security module
extern void NullDst(void);

// Use this to init an engdst structure to point to NullDst
#define k_engdstNull \
{ \
	(pfnEngDst_pfnSPR_Load_t)						NullDst, \
	(pfnEngDst_pfnSPR_Frames_t)						NullDst, \
	(pfnEngDst_pfnSPR_Height_t)						NullDst, \
	(pfnEngDst_pfnSPR_Width_t)						NullDst, \
	(pfnEngDst_pfnSPR_Set_t)						NullDst, \
	(pfnEngDst_pfnSPR_Draw_t)						NullDst, \
	(pfnEngDst_pfnSPR_DrawHoles_t)					NullDst, \
	(pfnEngDst_pfnSPR_DrawAdditive_t)				NullDst, \
	(pfnEngDst_pfnSPR_EnableScissor_t)				NullDst, \
	(pfnEngDst_pfnSPR_DisableScissor_t)				NullDst, \
	(pfnEngDst_pfnSPR_GetList_t)					NullDst, \
	(pfnEngDst_pfnFillRGBA_t)						NullDst, \
	(pfnEngDst_pfnGetScreenInfo_t)					NullDst, \
	(pfnEngDst_pfnSetCrosshair_t)					NullDst, \
	(pfnEngDst_pfnRegisterVariable_t)				NullDst, \
	(pfnEngDst_pfnGetCvarFloat_t)					NullDst, \
	(pfnEngDst_pfnGetCvarString_t)					NullDst, \
	(pfnEngDst_pfnAddCommand_t)						NullDst, \
	(pfnEngDst_pfnHookUserMsg_t)					NullDst, \
	(pfnEngDst_pfnServerCmd_t)						NullDst, \
	(pfnEngDst_pfnClientCmd_t)						NullDst, \
	(pfnEngDst_pfnGetPlayerInfo_t)					NullDst, \
	(pfnEngDst_pfnPlaySoundByName_t)				NullDst, \
	(pfnEngDst_pfnPlaySoundByIndex_t)				NullDst, \
	(pfnEngDst_pfnAngleVectors_t)					NullDst, \
	(pfnEngDst_pfnTextMessageGet_t)					NullDst, \
	(pfnEngDst_pfnDrawCharacter_t)					NullDst, \
	(pfnEngDst_pfnDrawConsoleString_t)				NullDst, \
	(pfnEngDst_pfnDrawSetTextColor_t)				NullDst, \
	(pfnEngDst_pfnDrawConsoleStringLen_t)			NullDst, \
	(pfnEngDst_pfnConsolePrint_t)					NullDst, \
	(pfnEngDst_pfnCenterPrint_t)					NullDst, \
	(pfnEngDst_GetWindowCenterX_t)					NullDst, \
	(pfnEngDst_GetWindowCenterY_t)					NullDst, \
	(pfnEngDst_GetViewAngles_t)						NullDst, \
	(pfnEngDst_SetViewAngles_t)						NullDst, \
	(pfnEngDst_GetMaxClients_t)						NullDst, \
	(pfnEngDst_Cvar_SetValue_t)						NullDst, \
	(pfnEngDst_Cmd_Argc_t)							NullDst, \
	(pfnEngDst_Cmd_Argv_t)							NullDst, \
	(pfnEngDst_Con_Printf_t)						NullDst, \
	(pfnEngDst_Con_DPrintf_t)						NullDst, \
	(pfnEngDst_Con_NPrintf_t)						NullDst, \
	(pfnEngDst_Con_NXPrintf_t)						NullDst, \
	(pfnEngDst_PhysInfo_ValueForKey_t)				NullDst, \
	(pfnEngDst_ServerInfo_ValueForKey_t)			NullDst, \
	(pfnEngDst_GetClientMaxspeed_t)					NullDst, \
	(pfnEngDst_CheckParm_t)							NullDst, \
	(pfnEngDst_Key_Event_t)							NullDst, \
	(pfnEngDst_GetMousePosition_t)					NullDst, \
	(pfnEngDst_IsNoClipping_t)						NullDst, \
	(pfnEngDst_GetLocalPlayer_t)					NullDst, \
	(pfnEngDst_GetViewModel_t)						NullDst, \
	(pfnEngDst_GetEntityByIndex_t)					NullDst, \
	(pfnEngDst_GetClientTime_t)						NullDst, \
	(pfnEngDst_V_CalcShake_t)						NullDst, \
	(pfnEngDst_V_ApplyShake_t)						NullDst, \
	(pfnEngDst_PM_PointContents_t)					NullDst, \
	(pfnEngDst_PM_WaterEntity_t)					NullDst, \
	(pfnEngDst_PM_TraceLine_t)						NullDst, \
	(pfnEngDst_CL_LoadModel_t)						NullDst, \
	(pfnEngDst_CL_CreateVisibleEntity_t)			NullDst, \
	(pfnEngDst_GetSpritePointer_t)					NullDst, \
	(pfnEngDst_pfnPlaySoundByNameAtLocation_t)		NullDst, \
	(pfnEngDst_pfnPrecacheEvent_t)					NullDst, \
	(pfnEngDst_pfnPlaybackEvent_t)					NullDst, \
	(pfnEngDst_pfnWeaponAnim_t)						NullDst, \
	(pfnEngDst_pfnRandomFloat_t)					NullDst, \
	(pfnEngDst_pfnRandomLong_t)						NullDst, \
	(pfnEngDst_pfnHookEvent_t)						NullDst, \
	(pfnEngDst_Con_IsVisible_t)						NullDst, \
	(pfnEngDst_pfnGetGameDirectory_t)				NullDst, \
	(pfnEngDst_pfnGetCvarPointer_t)					NullDst, \
	(pfnEngDst_Key_LookupBinding_t)					NullDst, \
	(pfnEngDst_pfnGetLevelName_t)					NullDst, \
	(pfnEngDst_pfnGetScreenFade_t)					NullDst, \
	(pfnEngDst_pfnSetScreenFade_t)					NullDst, \
	(pfnEngDst_VGui_GetPanel_t)						NullDst, \
	(pfnEngDst_VGui_ViewportPaintBackground_t)		NullDst, \
	(pfnEngDst_COM_LoadFile_t)						NullDst, \
	(pfnEngDst_COM_ParseFile_t)						NullDst, \
	(pfnEngDst_COM_FreeFile_t)						NullDst, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	(pfnEngDst_IsSpectateOnly_t)					NullDst, \
	(pfnEngDst_LoadMapSprite_t)						NullDst, \
	(pfnEngDst_COM_AddAppDirectoryToSearchPath_t)	NullDst, \
	(pfnEngDst_COM_ExpandFilename_t)				NullDst, \
	(pfnEngDst_PlayerInfo_ValueForKey_t)			NullDst, \
	(pfnEngDst_PlayerInfo_SetValueForKey_t)			NullDst, \
	(pfnEngDst_GetPlayerUniqueID_t)					NullDst, \
	(pfnEngDst_GetTrackerIDForPlayer_t)				NullDst, \
	(pfnEngDst_GetPlayerForTrackerID_t)				NullDst, \
	(pfnEngDst_pfnServerCmdUnreliable_t)			NullDst, \
	(pfnEngDst_GetMousePos_t)						NullDst, \
	(pfnEngDst_SetMousePos_t)						NullDst, \
	(pfnEngDst_SetMouseEnable_t)					NullDst, \
	(pfnEngDst_pfnSetFilterMode_t)					NullDst, \
	(pfnEngDst_pfnSetFilterColor_t)					NullDst, \
	(pfnEngDst_pfnSetFilterBrightness_t)			NullDst, \
	(pfnEngDst_pfnSequenceGet_t)					NullDst, \
	(pfnEngDst_pfnSPR_DrawGeneric_t)				NullDst, \
	(pfnEngDst_pfnSequencePickSentence_t)			NullDst, \
	(pfnEngDst_pfnDrawString_t)						NullDst, \
	(pfnEngDst_pfnDrawStringReverse_t)				NullDst, \
	(pfnEngDst_LocalPlayerInfo_ValueForKey_t)		NullDst, \
	(pfnEngDst_pfnVGUI2DrawCharacter_t)			NullDst, \
	(pfnEngDst_pfnVGUI2DrawCharacterAdd_t)	NullDst, \
	(pfnEngDst_pfnPlaySoundVoiceByName_t)		NullDst, \
	(pfnEngDst_pfnPrimeMusicStream_t)				NullDst, \
	(pfnEngDst_pfnProcessTutorMessageDecayBuffer_t)	NullDst, \
	(pfnEngDst_pfnConstructTutorMessageDecayBuffer_t)	NullDst, \
	(pfnEngDst_pfnResetTutorMessageDecayData_t) NullDst, \
	(pfnEngDst_pfnPlaySoundByNameAtPitch_t)			NullDst, \
	(pfnEngDst_pfnFillRGBABlend_t)						NullDst, \
	(pfnEngDst_pfnGetAppID_t)						NullDst, \
	(pfnEngDst_pfnGetAliases_t)						NullDst, \
	(pfnEngDst_pfnVguiWrap2_GetMouseDelta_t)		NullDst, \
	(pfnEngDst_pfnFilteredClientCmd_t)				NullDst, \
};

// Use this to init a cldll_func_dst structure to point to NullDst
#define k_cldstNull \
{ \
	(DST_INITIALIZE_FUNC)				NullDst, \
	(DST_HUD_INIT_FUNC)					NullDst, \
	(DST_HUD_VIDINIT_FUNC)				NullDst, \
	(DST_HUD_REDRAW_FUNC)				NullDst, \
	(DST_HUD_UPDATECLIENTDATA_FUNC)		NullDst, \
	(DST_HUD_RESET_FUNC)				NullDst, \
	(DST_HUD_CLIENTMOVE_FUNC)			NullDst, \
	(DST_HUD_CLIENTMOVEINIT_FUNC)		NullDst, \
	(DST_HUD_TEXTURETYPE_FUNC)			NullDst, \
	(DST_HUD_IN_ACTIVATEMOUSE_FUNC)		NullDst, \
	(DST_HUD_IN_DEACTIVATEMOUSE_FUNC)	NullDst, \
	(DST_HUD_IN_MOUSEEVENT_FUNC)		NullDst, \
	(DST_HUD_IN_CLEARSTATES_FUNC)		NullDst, \
	(DST_HUD_IN_ACCUMULATE_FUNC)		NullDst, \
	(DST_HUD_CL_CREATEMOVE_FUNC)		NullDst, \
	(DST_HUD_CL_ISTHIRDPERSON_FUNC)		NullDst, \
	(DST_HUD_CL_GETCAMERAOFFSETS_FUNC)	NullDst, \
	(DST_HUD_KB_FIND_FUNC)				NullDst, \
	(DST_HUD_CAMTHINK_FUNC)				NullDst, \
	(DST_HUD_CALCREF_FUNC)				NullDst, \
	(DST_HUD_ADDENTITY_FUNC)			NullDst, \
	(DST_HUD_CREATEENTITIES_FUNC)		NullDst, \
	(DST_HUD_DRAWNORMALTRIS_FUNC)		NullDst, \
	(DST_HUD_DRAWTRANSTRIS_FUNC)		NullDst, \
	(DST_HUD_STUDIOEVENT_FUNC)			NullDst, \
	(DST_HUD_POSTRUNCMD_FUNC)			NullDst, \
	(DST_HUD_SHUTDOWN_FUNC)				NullDst, \
	(DST_HUD_TXFERLOCALOVERRIDES_FUNC)	NullDst, \
	(DST_HUD_PROCESSPLAYERSTATE_FUNC)	NullDst, \
	(DST_HUD_TXFERPREDICTIONDATA_FUNC)	NullDst, \
	(DST_HUD_DEMOREAD_FUNC)				NullDst, \
	(DST_HUD_CONNECTIONLESS_FUNC)		NullDst, \
	(DST_HUD_GETHULLBOUNDS_FUNC)		NullDst, \
	(DST_HUD_FRAME_FUNC)				NullDst, \
	(DST_HUD_KEY_EVENT_FUNC)			NullDst, \
	(DST_HUD_TEMPENTUPDATE_FUNC)		NullDst, \
	(DST_HUD_GETUSERENTITY_FUNC)		NullDst, \
	(DST_HUD_VOICESTATUS_FUNC)			NullDst, \
	(DST_HUD_DIRECTORMESSAGE_FUNC)		NullDst, \
	(DST_HUD_STUDIO_INTERFACE_FUNC)		NullDst, \
	(DST_HUD_CHATINPUTPOSITION_FUNC)	NullDst, \
	(DST_HUD_GETPLAYERTEAM)				NullDst, \
}

#ifdef __cplusplus
}
#endif

#endif // CDLL_INT_H
	
```

`engine/custom.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// Customization.h

#ifndef CUSTOM_H
#define CUSTOM_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#include "const.h"

#define MAX_QPATH 64    // Must match value in quakedefs.h

/////////////////
// Customization
// passed to pfnPlayerCustomization
// For automatic downloading.
typedef enum
{
	t_sound = 0,
	t_skin,
	t_model,
	t_decal,
	t_generic,
	t_eventscript,
	t_world,		// Fake type for world, is really t_model
} resourcetype_t;


typedef struct
{
	int				size;
} _resourceinfo_t;

typedef struct resourceinfo_s
{
	_resourceinfo_t info[ 8 ];
} resourceinfo_t;

#define RES_FATALIFMISSING (1<<0)   // Disconnect if we can't get this file.
#define RES_WASMISSING     (1<<1)   // Do we have the file locally, did we get it ok?
#define RES_CUSTOM         (1<<2)   // Is this resource one that corresponds to another player's customization
								    //  or is it a server startup resource.
#define RES_REQUESTED	   (1<<3)	// Already requested a download of this one
#define RES_PRECACHED	   (1<<4)	// Already precached

#include "crc.h"

typedef struct resource_s
{
	char              szFileName[MAX_QPATH]; // File name to download/precache.
	resourcetype_t    type;                // t_sound, t_skin, t_model, t_decal.
	int               nIndex;              // For t_decals
	int               nDownloadSize;       // Size in Bytes if this must be downloaded.
	unsigned char     ucFlags;

// For handling client to client resource propagation
	unsigned char     rgucMD5_hash[16];    // To determine if we already have it.
	unsigned char     playernum;           // Which player index this resource is associated with, if it's a custom resource.

	unsigned char	  rguc_reserved[ 32 ]; // For future expansion
	struct resource_s *pNext;              // Next in chain.
	struct resource_s *pPrev;
} resource_t;

typedef struct customization_s
{
	qboolean bInUse;     // Is this customization in use;
	resource_t resource; // The resource_t for this customization
	qboolean bTranslated; // Has the raw data been translated into a useable format?  
						   //  (e.g., raw decal .wad make into texture_t *)
	int        nUserData1; // Customization specific data
	int        nUserData2; // Customization specific data
	void *pInfo;          // Buffer that holds the data structure that references the data (e.g., the cachewad_t)
	void *pBuffer;       // Buffer that holds the data for the customization (the raw .wad data)
	struct customization_s *pNext; // Next in chain
} customization_t;

#define FCUST_FROMHPAK		( 1<<0 )
#define FCUST_WIPEDATA		( 1<<1 )
#define FCUST_IGNOREINIT	( 1<<2 )

void		COM_ClearCustomizationList( struct customization_s *pHead, qboolean bCleanDecals);
qboolean	COM_CreateCustomization( struct customization_s *pListHead, struct resource_s *pResource, int playernumber, int flags, 
				struct customization_s **pCustomization, int *nLumps ); 
int			COM_SizeofResourceList ( struct resource_s *pList, struct resourceinfo_s *ri );

#endif // CUSTOM_H

```

`engine/customentity.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CUSTOMENTITY_H
#define CUSTOMENTITY_H

// Custom Entities

// Start/End Entity is encoded as 12 bits of entity index, and 4 bits of attachment (4:12)
#define BEAMENT_ENTITY(x)		((x)&0xFFF)
#define BEAMENT_ATTACHMENT(x)	(((x)>>12)&0xF)

// Beam types, encoded as a byte
enum 
{
	BEAM_POINTS = 0,
	BEAM_ENTPOINT,
	BEAM_ENTS,
	BEAM_HOSE,
};

#define BEAM_FSINE		0x10
#define BEAM_FSOLID		0x20
#define BEAM_FSHADEIN	0x40
#define BEAM_FSHADEOUT	0x80

#endif	//CUSTOMENTITY_H

```

`engine/edict.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined EDICT_H
#define EDICT_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif
#define	MAX_ENT_LEAFS	48

#include "progdefs.h"

struct edict_s
{
	qboolean	free;
	int			serialnumber;
	link_t		area;				// linked to a division node or leaf
	
	int			headnode;			// -1 to use normal leaf check
	int			num_leafs;
	short		leafnums[MAX_ENT_LEAFS];

	float		freetime;			// sv.time when the object was freed

	void*		pvPrivateData;		// Alloced and freed by engine, used by DLLs

	entvars_t	v;					// C exported fields from progs

	// other fields from progs come immediately after
};

#endif

```

`engine/eiface.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef EIFACE_H
#define EIFACE_H

#include "archtypes.h"     // DAL

#ifdef HLDEMO_BUILD
#define INTERFACE_VERSION       001
#else  // !HLDEMO_BUILD, i.e., regular version of HL
#define INTERFACE_VERSION		140
#endif // !HLDEMO_BUILD

#include <stdio.h>
#include "custom.h"
#include "cvardef.h"
#include "Sequence.h"
//
// Defines entity interface between engine and DLLs.
// This header file included by engine files and DLL files.
//
// Before including this header, DLLs must:
//		include progdefs.h
// This is conveniently done for them in extdll.h
//

typedef enum
	{
	at_notice,
	at_console,		// same as at_notice, but forces a ConPrintf, not a message box
	at_aiconsole,	// same as at_console, but only shown if developer level is 2!
	at_warning,
	at_error,
	at_logged		// Server print to console ( only in multiplayer games ).
	} ALERT_TYPE;

// 4-22-98  JOHN: added for use in pfnClientPrintf
typedef enum
	{
	print_console,
	print_center,
	print_chat,
	} PRINT_TYPE;

// For integrity checking of content on clients
typedef enum
{
	force_exactfile,					// File on client must exactly match server's file
	force_model_samebounds,				// For model files only, the geometry must fit in the same bbox
	force_model_specifybounds,			// For model files only, the geometry must fit in the specified bbox
	force_model_specifybounds_if_avail,	// For Steam model files only, the geometry must fit in the specified bbox (if the file is available)
} FORCE_TYPE;

// Returned by TraceLine
typedef struct
	{
	int		fAllSolid;			// if true, plane is not valid
	int		fStartSolid;		// if true, the initial point was in a solid area
	int		fInOpen;
	int		fInWater;
	float	flFraction;			// time completed, 1.0 = didn't hit anything
	vec3_t	vecEndPos;			// final position
	float	flPlaneDist;
	vec3_t	vecPlaneNormal;		// surface normal at impact
	edict_t	*pHit;				// entity the surface is on
	int		iHitgroup;			// 0 == generic, non zero is specific body part
	} TraceResult;

// CD audio status
typedef struct 
{
	int	fPlaying;// is sound playing right now?
	int	fWasPlaying;// if not, CD is paused if WasPlaying is true.
	int	fInitialized;
	int	fEnabled;
	int	fPlayLooping;
	float	cdvolume;
	//BYTE 	remap[100];
	int	fCDRom;
	int	fPlayTrack;
} CDStatus;

#include "../common/crc.h"


// Engine hands this to DLLs for functionality callbacks
typedef struct enginefuncs_s
{
	int			(*pfnPrecacheModel)			(const char* s);
	int			(*pfnPrecacheSound)			(const char* s);
	void		(*pfnSetModel)				(edict_t *e, const char *m);
	int			(*pfnModelIndex)			(const char *m);
	int			(*pfnModelFrames)			(int modelIndex);
	void		(*pfnSetSize)				(edict_t *e, const float *rgflMin, const float *rgflMax);
	void		(*pfnChangeLevel)			(char* s1, char* s2);
	void		(*pfnGetSpawnParms)			(edict_t *ent);
	void		(*pfnSaveSpawnParms)		(edict_t *ent);
	float		(*pfnVecToYaw)				(const float *rgflVector);
	void		(*pfnVecToAngles)			(const float *rgflVectorIn, float *rgflVectorOut);
	void		(*pfnMoveToOrigin)			(edict_t *ent, const float *pflGoal, float dist, int iMoveType);
	void		(*pfnChangeYaw)				(edict_t* ent);
	void		(*pfnChangePitch)			(edict_t* ent);
	edict_t*	(*pfnFindEntityByString)	(edict_t *pEdictStartSearchAfter, const char *pszField, const char *pszValue);
	int			(*pfnGetEntityIllum)		(edict_t* pEnt);
	edict_t*	(*pfnFindEntityInSphere)	(edict_t *pEdictStartSearchAfter, const float *org, float rad);
	edict_t*	(*pfnFindClientInPVS)		(edict_t *pEdict);
	edict_t* (*pfnEntitiesInPVS)			(edict_t *pplayer);
	void		(*pfnMakeVectors)			(const float *rgflVector);
	void		(*pfnAngleVectors)			(const float *rgflVector, float *forward, float *right, float *up);
	edict_t*	(*pfnCreateEntity)			(void);
	void		(*pfnRemoveEntity)			(edict_t* e);
	edict_t*	(*pfnCreateNamedEntity)		(int className);
	void		(*pfnMakeStatic)			(edict_t *ent);
	int			(*pfnEntIsOnFloor)			(edict_t *e);
	int			(*pfnDropToFloor)			(edict_t* e);
	int			(*pfnWalkMove)				(edict_t *ent, float yaw, float dist, int iMode);
	void		(*pfnSetOrigin)				(edict_t *e, const float *rgflOrigin);
	void		(*pfnEmitSound)				(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch);
	void		(*pfnEmitAmbientSound)		(edict_t *entity, float *pos, const char *samp, float vol, float attenuation, int fFlags, int pitch);
	void		(*pfnTraceLine)				(const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceToss)				(edict_t* pent, edict_t* pentToIgnore, TraceResult *ptr);
	int			(*pfnTraceMonsterHull)		(edict_t *pEdict, const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceHull)				(const float *v1, const float *v2, int fNoMonsters, int hullNumber, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceModel)			(const float *v1, const float *v2, int hullNumber, edict_t *pent, TraceResult *ptr);
	const char *(*pfnTraceTexture)			(edict_t *pTextureEntity, const float *v1, const float *v2 );
	void		(*pfnTraceSphere)			(const float *v1, const float *v2, int fNoMonsters, float radius, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnGetAimVector)			(edict_t* ent, float speed, float *rgflReturn);
	void		(*pfnServerCommand)			(char* str);
	void		(*pfnServerExecute)			(void);
	void		(*pfnClientCommand)			(edict_t* pEdict, char* szFmt, ...);
	void		(*pfnParticleEffect)		(const float *org, const float *dir, float color, float count);
	void		(*pfnLightStyle)			(int style, char* val);
	int			(*pfnDecalIndex)			(const char *name);
	int			(*pfnPointContents)			(const float *rgflVector);
	void		(*pfnMessageBegin)			(int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	void		(*pfnMessageEnd)			(void);
	void		(*pfnWriteByte)				(int iValue);
	void		(*pfnWriteChar)				(int iValue);
	void		(*pfnWriteShort)			(int iValue);
	void		(*pfnWriteLong)				(int iValue);
	void		(*pfnWriteAngle)			(float flValue);
	void		(*pfnWriteCoord)			(float flValue);
	void		(*pfnWriteString)			(const char *sz);
	void		(*pfnWriteEntity)			(int iValue);
	void		(*pfnCVarRegister)			(cvar_t *pCvar);
	float		(*pfnCVarGetFloat)			(const char *szVarName);
	const char*	(*pfnCVarGetString)			(const char *szVarName);
	void		(*pfnCVarSetFloat)			(const char *szVarName, float flValue);
	void		(*pfnCVarSetString)			(const char *szVarName, const char *szValue);
	void		(*pfnAlertMessage)			(ALERT_TYPE atype, const char *szFmt, ...);
	void		(*pfnEngineFprintf)			(void *pfile, const char *szFmt, ...);
	void*		(*pfnPvAllocEntPrivateData)	(edict_t *pEdict, int32 cb);
	void*		(*pfnPvEntPrivateData)		(edict_t *pEdict);
	void		(*pfnFreeEntPrivateData)	(edict_t *pEdict);
	const char*	(*pfnSzFromIndex)			(int iString);
	int			(*pfnAllocString)			(const char *szValue);
	struct entvars_s*	(*pfnGetVarsOfEnt)			(edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntOffset)	(int iEntOffset);
	int			(*pfnEntOffsetOfPEntity)	(const edict_t *pEdict);
	int			(*pfnIndexOfEdict)			(const edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntIndex)		(int iEntIndex);
	edict_t*	(*pfnFindEntityByVars)		(struct entvars_s* pvars);
	void*		(*pfnGetModelPtr)			(edict_t* pEdict);
	int			(*pfnRegUserMsg)			(const char *pszName, int iSize);
	void		(*pfnAnimationAutomove)		(const edict_t* pEdict, float flTime);
	void		(*pfnGetBonePosition)		(const edict_t* pEdict, int iBone, float *rgflOrigin, float *rgflAngles );
	uint32 (*pfnFunctionFromName)	( const char *pName );
	const char *(*pfnNameForFunction)		( uint32 function );
	void		(*pfnClientPrintf)			( edict_t* pEdict, PRINT_TYPE ptype, const char *szMsg ); // JOHN: engine callbacks so game DLL can print messages to individual clients
	void		(*pfnServerPrint)			( const char *szMsg );
	const char *(*pfnCmd_Args)				( void );		// these 3 added 
	const char *(*pfnCmd_Argv)				( int argc );	// so game DLL can easily 
	int			(*pfnCmd_Argc)				( void );		// access client 'cmd' strings
	void		(*pfnGetAttachment)			(const edict_t *pEdict, int iAttachment, float *rgflOrigin, float *rgflAngles );
	void		(*pfnCRC32_Init)			(CRC32_t *pulCRC);
	void        (*pfnCRC32_ProcessBuffer)   (CRC32_t *pulCRC, void *p, int len);
	void		(*pfnCRC32_ProcessByte)     (CRC32_t *pulCRC, unsigned char ch);
	CRC32_t		(*pfnCRC32_Final)			(CRC32_t pulCRC);
	int32		(*pfnRandomLong)			(int32  lLow,  int32  lHigh);
	float		(*pfnRandomFloat)			(float flLow, float flHigh);
	void		(*pfnSetView)				(const edict_t *pClient, const edict_t *pViewent );
	float		(*pfnTime)					( void );
	void		(*pfnCrosshairAngle)		(const edict_t *pClient, float pitch, float yaw);
	byte *      (*pfnLoadFileForMe)         (char *filename, int *pLength);
	void        (*pfnFreeFile)              (void *buffer);
	void        (*pfnEndSection)            (const char *pszSectionName); // trigger_endsection
	int 		(*pfnCompareFileTime)       (char *filename1, char *filename2, int *iCompare);
	void        (*pfnGetGameDir)            (char *szGetGameDir);
	void		(*pfnCvar_RegisterVariable) (cvar_t *variable);
	void        (*pfnFadeClientVolume)      (const edict_t *pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds);
	void        (*pfnSetClientMaxspeed)     (const edict_t *pEdict, float fNewMaxspeed);
	edict_t *	(*pfnCreateFakeClient)		(const char *netname);	// returns NULL if fake client can't be created
	void		(*pfnRunPlayerMove)			(edict_t *fakeclient, const float *viewangles, float forwardmove, float sidemove, float upmove, unsigned short buttons, byte impulse, byte msec );
	int			(*pfnNumberOfEntities)		(void);
	char*		(*pfnGetInfoKeyBuffer)		(edict_t *e);	// passing in NULL gets the serverinfo
	char*		(*pfnInfoKeyValue)			(char *infobuffer, char *key);
	void		(*pfnSetKeyValue)			(char *infobuffer, char *key, char *value);
	void		(*pfnSetClientKeyValue)		(int clientIndex, char *infobuffer, char *key, char *value);
	int			(*pfnIsMapValid)			(char *filename);
	void		(*pfnStaticDecal)			( const float *origin, int decalIndex, int entityIndex, int modelIndex );
	int			(*pfnPrecacheGeneric)		(char* s);
	int			(*pfnGetPlayerUserId)		(edict_t *e ); // returns the server assigned userid for this player.  useful for logging frags, etc.  returns -1 if the edict couldn't be found in the list of clients
	void		(*pfnBuildSoundMsg)			(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch, int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	int			(*pfnIsDedicatedServer)		(void);// is this a dedicated server?
	cvar_t		*(*pfnCVarGetPointer)		(const char *szVarName);
	unsigned int (*pfnGetPlayerWONId)		(edict_t *e); // returns the server assigned WONid for this player.  useful for logging frags, etc.  returns -1 if the edict couldn't be found in the list of clients

	// YWB 8/1/99 TFF Physics additions
	void		(*pfnInfo_RemoveKey)		( char *s, const char *key );
	const char *(*pfnGetPhysicsKeyValue)	( const edict_t *pClient, const char *key );
	void		(*pfnSetPhysicsKeyValue)	( const edict_t *pClient, const char *key, const char *value );
	const char *(*pfnGetPhysicsInfoString)	( const edict_t *pClient );
	unsigned short (*pfnPrecacheEvent)		( int type, const char*psz );
	void		(*pfnPlaybackEvent)			( int flags, const edict_t *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );

	unsigned char *(*pfnSetFatPVS)			( float *org );
	unsigned char *(*pfnSetFatPAS)			( float *org );

	int			(*pfnCheckVisibility )		( const edict_t *entity, unsigned char *pset );

	void		(*pfnDeltaSetField)			( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaUnsetField)		( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaAddEncoder)		( char *name, void (*conditionalencode)( struct delta_s *pFields, const unsigned char *from, const unsigned char *to ) );
	int			(*pfnGetCurrentPlayer)		( void );
	int			(*pfnCanSkipPlayer)			( const edict_t *player );
	int			(*pfnDeltaFindField)		( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaSetFieldByIndex)	( struct delta_s *pFields, int fieldNumber );
	void		(*pfnDeltaUnsetFieldByIndex)( struct delta_s *pFields, int fieldNumber );

	void		(*pfnSetGroupMask)			( int mask, int op );

	int			(*pfnCreateInstancedBaseline) ( int classname, struct entity_state_s *baseline );
	void		(*pfnCvar_DirectSet)		( struct cvar_s *var, char *value );

	// Forces the client and server to be running with the same version of the specified file
	//  ( e.g., a player model ).
	// Calling this has no effect in single player
	void		(*pfnForceUnmodified)		( FORCE_TYPE type, float *mins, float *maxs, const char *filename );

	void		(*pfnGetPlayerStats)		( const edict_t *pClient, int *ping, int *packet_loss );

	void		(*pfnAddServerCommand)		( char *cmd_name, void (*function) (void) );

	// For voice communications, set which clients hear eachother.
	// NOTE: these functions take player entity indices (starting at 1).
	qboolean	(*pfnVoice_GetClientListening)(int iReceiver, int iSender);
	qboolean	(*pfnVoice_SetClientListening)(int iReceiver, int iSender, qboolean bListen);

	const char *(*pfnGetPlayerAuthId)		( edict_t *e );

	// PSV: Added for CZ training map
//	const char *(*pfnKeyNameForBinding)					( const char* pBinding );
	
	sequenceEntry_s*	(*pfnSequenceGet)				( const char* fileName, const char* entryName );
	sentenceEntry_s*	(*pfnSequencePickSentence)		( const char* groupName, int pickMethod, int *picked );

	// LH: Give access to filesize via filesystem
	int			(*pfnGetFileSize)						( char *filename );

	unsigned int (*pfnGetApproxWavePlayLen)				(const char *filepath);
	// MDC: Added for CZ career-mode
	int			(*pfnIsCareerMatch)						( void );

	// BGC: return the number of characters of the localized string referenced by using "label"
	int			(*pfnGetLocalizedStringLength)			(const char *label);

	// BGC: added to facilitate persistent storage of tutor message decay values for
	// different career game profiles.  Also needs to persist regardless of mp.dll being
	// destroyed and recreated.
	void		(*pfnRegisterTutorMessageShown)			(int mid);
	int			(*pfnGetTimesTutorMessageShown)			(int mid);
	void		(*pfnProcessTutorMessageDecayBuffer)	(int *buffer, int bufferLength);
	void		(*pfnConstructTutorMessageDecayBuffer)	(int *buffer, int bufferLength);
	void		(*pfnResetTutorMessageDecayData)		( void );
	void		(*pfnQueryClientCvarValue)				( const edict_t *player, const char *cvarName );
	void		(*pfnQueryClientCvarValue2)				( const edict_t *player, const char *cvarName, int requestID );
	int		(*pfnEngCheckParm)					( const char *pchCmdLineToken, char **pchNextVal );
} enginefuncs_t;


// ONLY ADD NEW FUNCTIONS TO THE END OF THIS STRUCT.  INTERFACE VERSION IS FROZEN AT 138

// Passed to pfnKeyValue
typedef struct KeyValueData_s
{
	char	*szClassName;	// in: entity classname
	char	*szKeyName;		// in: name of key
	char	*szValue;		// in: value of key
	int32	fHandled;		// out: DLL sets to true if key-value pair was understood
} KeyValueData;


typedef struct
{
	char		mapName[ 32 ];
	char		landmarkName[ 32 ];
	edict_t	*pentLandmark;
	vec3_t		vecLandmarkOrigin;
} LEVELLIST;
#define MAX_LEVEL_CONNECTIONS	16		// These are encoded in the lower 16bits of ENTITYTABLE->flags

typedef struct 
{
	int			id;				// Ordinal ID of this entity (used for entity <--> pointer conversions)
	edict_t	*pent;			// Pointer to the in-game entity

	int			location;		// Offset from the base data of this entity
	int			size;			// Byte size of this entity's data
	int			flags;			// This could be a short -- bit mask of transitions that this entity is in the PVS of
	string_t	classname;		// entity class name

} ENTITYTABLE;

#define FENTTABLE_PLAYER		0x80000000
#define FENTTABLE_REMOVED		0x40000000
#define FENTTABLE_MOVEABLE		0x20000000
#define FENTTABLE_GLOBAL		0x10000000

typedef struct saverestore_s SAVERESTOREDATA;

#ifdef _WIN32
typedef 
#endif
struct saverestore_s
{
	char		*pBaseData;		// Start of all entity save data
	char		*pCurrentData;	// Current buffer pointer for sequential access
	int			size;			// Current data size
	int			bufferSize;		// Total space for data
	int			tokenSize;		// Size of the linear list of tokens
	int			tokenCount;		// Number of elements in the pTokens table
	char		**pTokens;		// Hash table of entity strings (sparse)
	int			currentIndex;	// Holds a global entity table ID
	int			tableCount;		// Number of elements in the entity table
	int			connectionCount;// Number of elements in the levelList[]
	ENTITYTABLE	*pTable;		// Array of ENTITYTABLE elements (1 for each entity)
	LEVELLIST	levelList[ MAX_LEVEL_CONNECTIONS ];		// List of connections from this level

	// smooth transition
	int			fUseLandmark;
	char		szLandmarkName[20];// landmark we'll spawn near in next level
	vec3_t		vecLandmarkOffset;// for landmark transitions
	float		time;
	char		szCurrentMapName[32];	// To check global entities

} 
#ifdef _WIN32
SAVERESTOREDATA 
#endif
;

typedef enum _fieldtypes
{
	FIELD_FLOAT = 0,		// Any floating point value
	FIELD_STRING,			// A string ID (return from ALLOC_STRING)
	FIELD_ENTITY,			// An entity offset (EOFFSET)
	FIELD_CLASSPTR,			// CBaseEntity *
	FIELD_EHANDLE,			// Entity handle
	FIELD_EVARS,			// EVARS *
	FIELD_EDICT,			// edict_t *, or edict_t *  (same thing)
	FIELD_VECTOR,			// Any vector
	FIELD_POSITION_VECTOR,	// A world coordinate (these are fixed up across level transitions automagically)
	FIELD_POINTER,			// Arbitrary data pointer... to be removed, use an array of FIELD_CHARACTER
	FIELD_INTEGER,			// Any integer or enum
	FIELD_FUNCTION,			// A class function pointer (Think, Use, etc)
	FIELD_BOOLEAN,			// boolean, implemented as an int, I may use this as a hint for compression
	FIELD_SHORT,			// 2 byte integer
	FIELD_CHARACTER,		// a byte
	FIELD_TIME,				// a floating point time (these are fixed up automatically too!)
	FIELD_MODELNAME,		// Engine string that is a model name (needs precache)
	FIELD_SOUNDNAME,		// Engine string that is a sound name (needs precache)

	FIELD_TYPECOUNT,		// MUST BE LAST
} FIELDTYPE;

#ifndef offsetof
#define offsetof(s,m)	(size_t)&(((s *)0)->m)
#endif

#define _FIELD(type,name,fieldtype,count,flags)		{ fieldtype, #name, offsetof(type, name), count, flags }
#define DEFINE_FIELD(type,name,fieldtype)			_FIELD(type, name, fieldtype, 1, 0)
#define DEFINE_ARRAY(type,name,fieldtype,count)		_FIELD(type, name, fieldtype, count, 0)
#define DEFINE_ENTITY_FIELD(name,fieldtype)			_FIELD(entvars_t, name, fieldtype, 1, 0 )
#define DEFINE_ENTITY_GLOBAL_FIELD(name,fieldtype)	_FIELD(entvars_t, name, fieldtype, 1, FTYPEDESC_GLOBAL )
#define DEFINE_GLOBAL_FIELD(type,name,fieldtype)	_FIELD(type, name, fieldtype, 1, FTYPEDESC_GLOBAL )


#define FTYPEDESC_GLOBAL			0x0001		// This field is masked for global entity save/restore

typedef struct 
{
	FIELDTYPE		fieldType;
	char			*fieldName;
	int				fieldOffset;
	short			fieldSize;
	short			flags;
} TYPEDESCRIPTION;

#ifndef ARRAYSIZE
#define ARRAYSIZE(p)		(sizeof(p)/sizeof(p[0]))
#endif

typedef struct 
{
	// Initialize/shutdown the game (one-time call after loading of game .dll )
	void			(*pfnGameInit)			( void );				
	int				(*pfnSpawn)				( edict_t *pent );
	void			(*pfnThink)				( edict_t *pent );
	void			(*pfnUse)				( edict_t *pentUsed, edict_t *pentOther );
	void			(*pfnTouch)				( edict_t *pentTouched, edict_t *pentOther );
	void			(*pfnBlocked)			( edict_t *pentBlocked, edict_t *pentOther );
	void			(*pfnKeyValue)			( edict_t *pentKeyvalue, KeyValueData *pkvd );
	void			(*pfnSave)				( edict_t *pent, SAVERESTOREDATA *pSaveData );
	int 			(*pfnRestore)			( edict_t *pent, SAVERESTOREDATA *pSaveData, int globalEntity );
	void			(*pfnSetAbsBox)			( edict_t *pent );

	void			(*pfnSaveWriteFields)	( SAVERESTOREDATA *, const char *, void *, TYPEDESCRIPTION *, int );
	void			(*pfnSaveReadFields)	( SAVERESTOREDATA *, const char *, void *, TYPEDESCRIPTION *, int );

	void			(*pfnSaveGlobalState)		( SAVERESTOREDATA * );
	void			(*pfnRestoreGlobalState)	( SAVERESTOREDATA * );
	void			(*pfnResetGlobalState)		( void );

	qboolean		(*pfnClientConnect)		( edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[ 128 ] );
	
	void			(*pfnClientDisconnect)	( edict_t *pEntity );
	void			(*pfnClientKill)		( edict_t *pEntity );
	void			(*pfnClientPutInServer)	( edict_t *pEntity );
	void			(*pfnClientCommand)		( edict_t *pEntity );
	void			(*pfnClientUserInfoChanged)( edict_t *pEntity, char *infobuffer );

	void			(*pfnServerActivate)	( edict_t *pEdictList, int edictCount, int clientMax );
	void			(*pfnServerDeactivate)	( void );

	void			(*pfnPlayerPreThink)	( edict_t *pEntity );
	void			(*pfnPlayerPostThink)	( edict_t *pEntity );

	void			(*pfnStartFrame)		( void );
	void			(*pfnParmsNewLevel)		( void );
	void			(*pfnParmsChangeLevel)	( void );

	 // Returns string describing current .dll.  E.g., TeamFotrress 2, Half-Life
	const char     *(*pfnGetGameDescription)( void );     

	// Notify dll about a player customization.
	void            (*pfnPlayerCustomization) ( edict_t *pEntity, customization_t *pCustom );  

	// Spectator funcs
	void			(*pfnSpectatorConnect)		( edict_t *pEntity );
	void			(*pfnSpectatorDisconnect)	( edict_t *pEntity );
	void			(*pfnSpectatorThink)		( edict_t *pEntity );

	// Notify game .dll that engine is going to shut down.  Allows mod authors to set a breakpoint.
	void			(*pfnSys_Error)			( const char *error_string );

	void			(*pfnPM_Move) ( struct playermove_s *ppmove, qboolean server );
	void			(*pfnPM_Init) ( struct playermove_s *ppmove );
	char			(*pfnPM_FindTextureType)( char *name );
	void			(*pfnSetupVisibility)( struct edict_s *pViewEntity, struct edict_s *pClient, unsigned char **pvs, unsigned char **pas );
	void			(*pfnUpdateClientData) ( const struct edict_s *ent, int sendweapons, struct clientdata_s *cd );
	int				(*pfnAddToFullPack)( struct entity_state_s *state, int e, edict_t *ent, edict_t *host, int hostflags, int player, unsigned char *pSet );
	void			(*pfnCreateBaseline) ( int player, int eindex, struct entity_state_s *baseline, struct edict_s *entity, int playermodelindex, vec3_t player_mins, vec3_t player_maxs );
	void			(*pfnRegisterEncoders)	( void );
	int				(*pfnGetWeaponData)		( struct edict_s *player, struct weapon_data_s *info );

	void			(*pfnCmdStart)			( const edict_t *player, const struct usercmd_s *cmd, unsigned int random_seed );
	void			(*pfnCmdEnd)			( const edict_t *player );

	// Return 1 if the packet is valid.  Set response_buffer_size if you want to send a response packet.  Incoming, it holds the max
	//  size of the response_buffer, so you must zero it out if you choose not to respond.
	int				(*pfnConnectionlessPacket )	( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );

	// Enumerates player hulls.  Returns 0 if the hull number doesn't exist, 1 otherwise
	int				(*pfnGetHullBounds)	( int hullnumber, float *mins, float *maxs );

	// Create baselines for certain "unplaced" items.
	void			(*pfnCreateInstancedBaselines) ( void );

	// One of the pfnForceUnmodified files failed the consistency check for the specified player
	// Return 0 to allow the client to continue, 1 to force immediate disconnection ( with an optional disconnect message of up to 256 characters )
	int				(*pfnInconsistentFile)( const struct edict_s *player, const char *filename, char *disconnect_message );

	// The game .dll should return 1 if lag compensation should be allowed ( could also just set
	//  the sv_unlag cvar.
	// Most games right now should return 0, until client-side weapon prediction code is written
	//  and tested for them.
	int				(*pfnAllowLagCompensation)( void );
} DLL_FUNCTIONS;

extern DLL_FUNCTIONS		gEntityInterface;

// Current version.
#define NEW_DLL_FUNCTIONS_VERSION	1

typedef struct
{
	// Called right before the object's memory is freed. 
	// Calls its destructor.
	void			(*pfnOnFreeEntPrivateData)(edict_t *pEnt);
	void			(*pfnGameShutdown)(void);
	int				(*pfnShouldCollide)( edict_t *pentTouched, edict_t *pentOther );
	void			(*pfnCvarValue)( const edict_t *pEnt, const char *value );
	void			(*pfnCvarValue2)( const edict_t *pEnt, int requestID, const char *cvarName, const char *value );
} NEW_DLL_FUNCTIONS;
typedef int	(*NEW_DLL_FUNCTIONS_FN)( NEW_DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion );

// Pointers will be null if the game DLL doesn't support this API.
extern NEW_DLL_FUNCTIONS	gNewDLLFunctions;

typedef int	(*APIFUNCTION)( DLL_FUNCTIONS *pFunctionTable, int interfaceVersion );
typedef int	(*APIFUNCTION2)( DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion );

#endif /* EIFACE_H */

```

`engine/keydefs.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#ifndef KEYDEFS_H
#define KEYDEFS_H

//
// these are the key numbers that should be passed to Key_Event
//
#define K_TAB		9
#define K_ENTER		13
#define K_ESCAPE	27
#define K_SPACE		32
#define K_SCROLLOCK	70

// normal keys should be passed as lowercased ascii

#define K_BACKSPACE		127
#define K_UPARROW		128
#define K_DOWNARROW		129
#define K_LEFTARROW		130
#define K_RIGHTARROW	131

#define K_ALT		132
#define K_CTRL		133
#define K_SHIFT		134
#define K_F1		135
#define K_F2		136
#define K_F3		137
#define K_F4		138
#define K_F5		139
#define K_F6		140
#define K_F7		141
#define K_F8		142
#define K_F9		143
#define K_F10		144
#define K_F11		145
#define K_F12		146
#define K_INS		147
#define K_DEL		148
#define K_PGDN		149
#define K_PGUP		150
#define K_HOME		151
#define K_END		152

#define K_KP_HOME		160
#define K_KP_UPARROW	161
#define K_KP_PGUP		162
#define K_KP_LEFTARROW	163
#define K_KP_5			164
#define K_KP_RIGHTARROW	165
#define K_KP_END		166
#define K_KP_DOWNARROW	167
#define K_KP_PGDN		168
#define K_KP_ENTER		169
#define K_KP_INS   		170
#define K_KP_DEL		171
#define K_KP_SLASH		172
#define K_KP_MINUS		173
#define K_KP_PLUS		174
#define K_CAPSLOCK		175
#define K_KP_MUL		176
#define K_WIN			177
#define K_KP_NUMLOCK	178

//
// joystick buttons
//
#define K_JOY1		203 // LTRIGGER (L2)
#define K_JOY2		204 // RTRIGGER (R2)
#define K_JOY3		205
#define K_JOY4		206

//
// aux keys are for multi-buttoned joysticks to generate so they can use
// the normal binding process
//
#define K_AUX1		207
#define K_A_BUTTON	K_AUX1

#define K_AUX2		208
#define K_B_BUTTON	K_AUX2

#define K_AUX3		209
#define K_X_BUTTON	K_AUX3

#define K_AUX4		210
#define K_Y_BUTTON	K_AUX4

#define K_AUX5		211
#define K_L1_BUTTON	K_AUX5

#define K_AUX6		212
#define K_R1_BUTTON K_AUX6

#define K_AUX7		  213
#define K_BACK_BUTTON K_AUX7

#define K_AUX8		  214
#define K_MODE_BUTTON K_AUX8

#define K_AUX9		   215
#define K_START_BUTTON K_AUX9

#define K_AUX10		216
#define K_LSTICK	K_AUX10

#define K_AUX11		217
#define K_RSTICK	K_AUX11

#define K_AUX12		218
#define K_L2_BUTTON	K_AUX12

#define K_AUX13		219
#define K_R2_BUTTON K_AUX13

#define K_AUX14		220
#define K_C_BUTTON  K_AUX14

#define K_AUX15		221
#define K_Z_BUTTON  K_AUX15

#define K_AUX16		222
#define K_DPAD_UP  K_AUX16

#define K_AUX17		223
#define K_DPAD_DOWN  K_AUX17

#define K_AUX18		224
#define K_DPAD_LEFT  K_AUX18

#define K_AUX19		225
#define K_DPAD_RIGHT  K_AUX19

#define K_AUX20			226
#define K_AUX21			227
#define K_AUX22			228
#define K_AUX23			229
#define K_AUX24			230
#define K_AUX25			231
#define K_AUX26			232
#define K_AUX27			233
#define K_AUX28			234
#define K_AUX29			235
#define K_AUX30			236
#define K_AUX31			237
#define K_AUX32			238
#define K_MWHEELDOWN	239
#define K_MWHEELUP		240

#define K_PAUSE			255

//
// mouse buttons generate virtual keys
//
#define K_MOUSE1		241
#define K_MOUSE2		242
#define K_MOUSE3		243
#define K_MOUSE4		244
#define K_MOUSE5		245

#endif//KEYDEFS_H

```

`engine/menu_int.h`:

```h
/*
menu_int.h - interface between engine and menu
Copyright (C) 2010 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef MENU_INT_H
#define MENU_INT_H

#include "cvardef.h"
#include "gameinfo.h"
#include "wrect.h"

// a macro for mainui_cpp, indicating that mainui should be compiled for
// Xash3D 1.0 interface
#define NEW_ENGINE_INTERFACE

typedef int		HIMAGE;		// handle to a graphic

// flags for PIC_Load
#define PIC_NEAREST		(1<<0)		// disable texfilter
#define PIC_KEEP_SOURCE	(1<<1)		// some images keep source
#define PIC_NOFLIP_TGA	(1<<2)		// Steam background completely ignore tga attribute 0x20
#define PIC_EXPAND_SOURCE (1<<3)		// don't keep as 8-bit source, expand to RGBA

// flags for COM_ParseFileSafe
#define PFILE_IGNOREBRACKET (1<<0)
#define PFILE_HANDLECOLON   (1<<1)

typedef struct ui_globalvars_s
{
	float		time;		// unclamped host.realtime
	float		frametime;

	int		scrWidth;		// actual values
	int		scrHeight;

	int		maxClients;
	int		developer; // boolean, changed from allow_console to make mainui_cpp compile for both engines
	int		demoplayback;
	int		demorecording;
	char		demoname[64];	// name of currently playing demo
	char		maptitle[64];	// title of active map
} ui_globalvars_t;

struct ref_viewpass_s;

typedef struct ui_enginefuncs_s
{
	// image handlers
	HIMAGE	(*pfnPIC_Load)( const char *szPicName, const byte *ucRawImage, int ulRawImageSize, int flags );
	void	(*pfnPIC_Free)( const char *szPicName );
	int	(*pfnPIC_Width)( HIMAGE hPic );
	int	(*pfnPIC_Height)( HIMAGE hPic );
	void	(*pfnPIC_Set)( HIMAGE hPic, int r, int g, int b, int a );
	void	(*pfnPIC_Draw)( int x, int y, int width, int height, const wrect_t *prc );
	void	(*pfnPIC_DrawHoles)( int x, int y, int width, int height, const wrect_t *prc );
	void	(*pfnPIC_DrawTrans)( int x, int y, int width, int height, const wrect_t *prc );
	void	(*pfnPIC_DrawAdditive)( int x, int y, int width, int height, const wrect_t *prc );
	void	(*pfnPIC_EnableScissor)( int x, int y, int width, int height );
	void	(*pfnPIC_DisableScissor)( void );

	// screen handlers
	void	(*pfnFillRGBA)( int x, int y, int width, int height, int r, int g, int b, int a );

	// cvar handlers
	cvar_t*	(*pfnRegisterVariable)( const char *szName, const char *szValue, int flags );
	float	(*pfnGetCvarFloat)( const char *szName );
	const char*	(*pfnGetCvarString)( const char *szName );
	void	(*pfnCvarSetString)( const char *szName, const char *szValue );
	void	(*pfnCvarSetValue)( const char *szName, float flValue );

	// command handlers
	int	(*pfnAddCommand)( const char *cmd_name, void (*function)(void) );
	void	(*pfnClientCmd)( int execute_now, const char *szCmdString );
	void	(*pfnDelCommand)( const char *cmd_name );
	int (*pfnCmdArgc)( void );
	const char*	(*pfnCmdArgv)( int argc );
	const char*	(*pfnCmd_Args)( void );

	// debug messages (in-menu shows only notify)
	void	(*Con_Printf)( const char *fmt, ... ) _format( 1 );
	void	(*Con_DPrintf)( const char *fmt, ... )  _format( 1 );
	void	(*Con_NPrintf)( int pos, const char *fmt, ... )  _format( 2 );
	void	(*Con_NXPrintf)( struct con_nprint_s *info, const char *fmt, ... ) _format( 2 );

	// sound handlers
	void	(*pfnPlayLocalSound)( const char *szSound );

	// cinematic handlers
	void	(*pfnDrawLogo)( const char *filename, float x, float y, float width, float height );
	int	(*pfnGetLogoWidth)( void );
	int	(*pfnGetLogoHeight)( void );
	float	(*pfnGetLogoLength)( void );	// cinematic duration in seconds

	// text message system
	void	(*pfnDrawCharacter)( int x, int y, int width, int height, int ch, int ulRGBA, HIMAGE hFont );
	int	(*pfnDrawConsoleString)( int x, int y, const char *string );
	void	(*pfnDrawSetTextColor)( int r, int g, int b, int alpha );
	void	(*pfnDrawConsoleStringLen)(  const char *string, int *length, int *height );
	void	(*pfnSetConsoleDefaultColor)( int r, int g, int b ); // color must came from colors.lst

	// custom rendering (for playermodel preview)
	struct cl_entity_s* (*pfnGetPlayerModel)( void );	// for drawing playermodel previews
	void	(*pfnSetModel)( struct cl_entity_s *ed, const char *path );
	void	(*pfnClearScene)( void );
	void	(*pfnRenderScene)( const struct ref_viewpass_s *rvp );
	int	(*CL_CreateVisibleEntity)( int type, struct cl_entity_s *ent );

	// misc handlers
	void	(*pfnHostError)( const char *szFmt, ... ) _format( 1 );
	int	(*pfnFileExists)( const char *filename, int gamedironly );
	void	(*pfnGetGameDir)( char *szGetGameDir );

	// gameinfo handlers
	int	(*pfnCreateMapsList)( int fRefresh );
	int	(*pfnClientInGame)( void );
	void	(*pfnClientJoin)( const struct netadr_s adr );

	// parse txt files
	byte*	(*COM_LoadFile)( const char *filename, int *pLength );
	char*	(*COM_ParseFile)( char *data, char *token );
	void	(*COM_FreeFile)( void *buffer );

	// keyfuncs
	void	(*pfnKeyClearStates)( void );				// call when menu open or close
	void	(*pfnSetKeyDest)( int dest );
	const char *(*pfnKeynumToString)( int keynum );
	const char *(*pfnKeyGetBinding)( int keynum );
	void	(*pfnKeySetBinding)( int keynum, const char *binding );
	int	(*pfnKeyIsDown)( int keynum );
	int	(*pfnKeyGetOverstrikeMode)( void );
	void	(*pfnKeySetOverstrikeMode)( int fActive );
	void	*(*pfnKeyGetState)( const char *name );			// for mlook, klook etc

	// engine memory manager
	void*	(*pfnMemAlloc)( size_t cb, const char *filename, const int fileline );
	void	(*pfnMemFree)( void *mem, const char *filename, const int fileline );

	// collect info from engine
	int	(*pfnGetGameInfo)( GAMEINFO *pgameinfo );
	GAMEINFO	**(*pfnGetGamesList)( int *numGames );			// collect info about all mods
	char 	**(*pfnGetFilesList)( const char *pattern, int *numFiles, int gamedironly );	// find in files
	int (*pfnGetSaveComment)( const char *savename, char *comment );
	int	(*pfnGetDemoComment)( const char *demoname, char *comment );
	int	(*pfnCheckGameDll)( void );				// returns false if hl.dll is missed or invalid
	char	*(*pfnGetClipboardData)( void );

	// engine launcher
	void	(*pfnShellExecute)( const char *name, const char *args, int closeEngine );
	void	(*pfnWriteServerConfig)( const char *name );
	void	(*pfnChangeInstance)( const char *newInstance, const char *szFinalMessage );
	void	(*pfnPlayBackgroundTrack)( const char *introName, const char *loopName );
	void	(*pfnHostEndGame)( const char *szFinalMessage );

	// menu interface is freezed at version 0.75
	// new functions starts here
	float	(*pfnRandomFloat)( float flLow, float flHigh );
	int		(*pfnRandomLong)( int lLow, int lHigh );

	void	(*pfnSetCursor)( void *hCursor );			// change cursor
	int	(*pfnIsMapValid)( char *filename );
	void	(*pfnProcessImage)( int texnum, float gamma, int topColor, int bottomColor );
	int	(*pfnCompareFileTime)( const char *filename1, const char *filename2, int *iCompare );

	const char *(*pfnGetModeString)( int vid_mode );
	int	(*COM_SaveFile)( const char *filename, const void *data, int len );
	int	(*COM_RemoveFile)( const char *filepath );
} ui_enginefuncs_t;

typedef struct
{
	int	(*pfnVidInit)( void );
	void	(*pfnInit)( void );
	void	(*pfnShutdown)( void );
	void	(*pfnRedraw)( float flTime );
	void	(*pfnKeyEvent)( int key, int down );
	void	(*pfnMouseMove)( int x, int y );
	void	(*pfnSetActiveMenu)( int active );
	void	(*pfnAddServerToList)( struct netadr_s adr, const char *info );
	void	(*pfnGetCursorPos)( int *pos_x, int *pos_y );
	void	(*pfnSetCursorPos)( int pos_x, int pos_y );
	void	(*pfnShowCursor)( int show );
	void	(*pfnCharEvent)( int key );
	int	(*pfnMouseInRect)( void );	// mouse entering\leave game window
	int	(*pfnIsVisible)( void );
	int	(*pfnCreditsActive)( void );	// unused
	void	(*pfnFinalCredits)( void );	// show credits + game end
} UI_FUNCTIONS;

#define MENU_EXTENDED_API_VERSION 1

typedef struct ui_extendedfuncs_s {
	// text functions, frozen
	void (*pfnEnableTextInput)( int enable );
	int (*pfnUtfProcessChar) ( int ch );
	int (*pfnUtfMoveLeft) ( char *str, int pos );
	int (*pfnUtfMoveRight) ( char *str, int pos, int length );

	// new engine extended api start here
	// returns 1 if there are more in list, otherwise 0
	int (*pfnGetRenderers)( unsigned int num, char *shortName, size_t size1, char *readableName, size_t size2 );
	double (*pfnDoubleTime)( void );
	char *(*pfnParseFile)( char *data, char *buf, const int size, unsigned int flags, int *len );

	// network address funcs
	const char *(*pfnAdrToString)( const struct netadr_s a );
	int (*pfnCompareAdr)( const void *a, const void *b ); // netadr_t
} ui_extendedfuncs_t;

// deprecated export from old engine
typedef void (*ADDTOUCHBUTTONTOLIST)( const char *name, const char *texture, const char *command, unsigned char *color, int flags );

typedef struct
{
	ADDTOUCHBUTTONTOLIST pfnAddTouchButtonToList;
	void (*pfnResetPing)( void );
	void (*pfnShowConnectionWarning)( void );
	void (*pfnShowUpdateDialog)( int preferStore );
	void (*pfnShowMessageBox)( const char *text );
	void (*pfnConnectionProgress_Disconnect)( void );
	void (*pfnConnectionProgress_Download)( const char *pszFileName, const char *pszServerName, int iCurrent, int iTotal, const char *comment );
	void (*pfnConnectionProgress_DownloadEnd)( void );
	void (*pfnConnectionProgress_Precache)( void );
	void (*pfnConnectionProgress_Connect)( const char *server ); // NULL for local server
	void (*pfnConnectionProgress_ChangeLevel)( void );
	void (*pfnConnectionProgress_ParseServerInfo)( const char *server );
} UI_EXTENDED_FUNCTIONS;

typedef int (*MENUAPI)( UI_FUNCTIONS *pFunctionTable, ui_enginefuncs_t* engfuncs, ui_globalvars_t *pGlobals );

typedef int (*UIEXTENEDEDAPI)( int version, UI_EXTENDED_FUNCTIONS *pFunctionTable, ui_extendedfuncs_t *engfuncs );

// deprecated interface from old engine
typedef int (*UITEXTAPI)( ui_extendedfuncs_t* engfuncs );

#define PLATFORM_UPDATE_PAGE "PlatformUpdatePage"
#define GENERIC_UPDATE_PAGE "GenericUpdatePage"

typedef void (*ADDTOUCHBUTTONTOLIST)( const char *name, const char *texture, const char *command, unsigned char *color, int flags );
#endif//MENU_INT_H
```

`engine/mobility_int.h`:

```h
/*
mobility_int.h - interface between engine and client for mobile platforms
Copyright (C) 2015 a1batross

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#pragma once
#ifndef MOBILITY_INT_H
#define MOBILITY_INT_H
#ifdef __cplusplus
extern "C" {
#endif

#define MOBILITY_API_VERSION 2
#define MOBILITY_CLIENT_EXPORT "HUD_MobilityInterface"

#define VIBRATE_NORMAL (1U << 0) // just vibrate for given "life"

#define TOUCH_FL_HIDE			(1U << 0)
#define TOUCH_FL_NOEDIT			(1U << 1)
#define TOUCH_FL_CLIENT			(1U << 2)
#define TOUCH_FL_MP				(1U << 3)
#define TOUCH_FL_SP				(1U << 4)
#define TOUCH_FL_DEF_SHOW		(1U << 5)
#define TOUCH_FL_DEF_HIDE		(1U << 6)
#define TOUCH_FL_DRAW_ADDITIVE	(1U << 7)
#define TOUCH_FL_STROKE			(1U << 8)
#define TOUCH_FL_PRECISION		(1U << 9)

typedef struct mobile_engfuncs_s
{
	// indicates version of API. Should be equal to MOBILITY_API_VERSION
	// version changes when existing functions are changes
	int version;

	// vibration control
	// life -- time to vibrate in ms
	void (*pfnVibrate)( float life, char flags );

	// enable text input
	void (*pfnEnableTextInput)( int enable );

	// add temporaty button, edit will be disabled
	void (*pfnTouchAddClientButton)( const char *name, const char *texture, const char *command, float x1, float y1, float x2, float y2, unsigned char *color, int round, float aspect, int flags );

	// add button to defaults list. Will be loaded on config generation
	void (*pfnTouchAddDefaultButton)( const char *name, const char *texturefile, const char *command, float x1, float y1, float x2, float y2, unsigned char *color, int round, float aspect, int flags );

	// hide/show buttons by pattern
	void (*pfnTouchHideButtons)( const char *name, unsigned char hide );

	// remove button with given name
	void (*pfnTouchRemoveButton)( const char *name );

	// when enabled, only client buttons shown
	void (*pfnTouchSetClientOnly)( unsigned char state );

	// Clean defaults list
	void (*pfnTouchResetDefaultButtons)();

	// Draw scaled font for client
	int (*pfnDrawScaledCharacter)( int x, int y, int number, int r, int g, int b, float scale );

	// To be continued...
} mobile_engfuncs_t;

// function exported from client
// returns 0 on no error otherwise error
typedef int (*pfnMobilityInterface)( mobile_engfuncs_t *gMobileEngfuncs );

#ifdef __cplusplus
}
#endif
#endif

```

`engine/progdefs.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef PROGDEFS_H
#define PROGDEFS_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct
{	
	float		time;
	float		frametime;
	float		force_retouch;
	string_t	mapname;
	string_t	startspot;
	float		deathmatch;
	float		coop;
	float		teamplay;
	float		serverflags;
	float		found_secrets;
	vec3_t		v_forward;
	vec3_t		v_up;
	vec3_t		v_right;
	float		trace_allsolid;
	float		trace_startsolid;
	float		trace_fraction;
	vec3_t		trace_endpos;
	vec3_t		trace_plane_normal;
	float		trace_plane_dist;
	edict_t		*trace_ent;
	float		trace_inopen;
	float		trace_inwater;
	int			trace_hitgroup;
	int			trace_flags;
	int			msg_entity;
	int			cdAudioTrack;
	int			maxClients;
	int			maxEntities;
	const char	*pStringBase;

	void		*pSaveData;
	vec3_t		vecLandmarkOffset;
} globalvars_t;


typedef struct entvars_s
{
	string_t	classname;
	string_t	globalname;

	vec3_t		origin;
	vec3_t		oldorigin;
	vec3_t		velocity;
	vec3_t		basevelocity;
	vec3_t      clbasevelocity;  // Base velocity that was passed in to server physics so 
							     //  client can predict conveyors correctly.  Server zeroes it, so we need to store here, too.
	vec3_t		movedir;

	vec3_t		angles;			// Model angles
	vec3_t		avelocity;		// angle velocity (degrees per second)
	vec3_t		punchangle;		// auto-decaying view angle adjustment
	vec3_t		v_angle;		// Viewing angle (player only)

	// For parametric entities
	vec3_t		endpos;
	vec3_t		startpos;
	float		impacttime;
	float		starttime;

	int			fixangle;		// 0:nothing, 1:force view angles, 2:add avelocity
	float		idealpitch;
	float		pitch_speed;
	float		ideal_yaw;
	float		yaw_speed;

	int			modelindex;
	string_t	model;

	int			viewmodel;		// player's viewmodel
	int			weaponmodel;	// what other players see
	
	vec3_t		absmin;		// BB max translated to world coord
	vec3_t		absmax;		// BB max translated to world coord
	vec3_t		mins;		// local BB min
	vec3_t		maxs;		// local BB max
	vec3_t		size;		// maxs - mins

	float		ltime;
	float		nextthink;

	int			movetype;
	int			solid;

	int			skin;			
	int			body;			// sub-model selection for studiomodels
	int 		effects;
	
	float		gravity;		// % of "normal" gravity
	float		friction;		// inverse elasticity of MOVETYPE_BOUNCE
	
	int			light_level;

	int			sequence;		// animation sequence
	int			gaitsequence;	// movement animation sequence for player (0 for none)
	float		frame;			// % playback position in animation sequences (0..255)
	float		animtime;		// world time when frame was set
	float		framerate;		// animation playback rate (-8x to 8x)
	byte		controller[4];	// bone controller setting (0..255)
	byte		blending[2];	// blending amount between sub-sequences (0..255)

	float		scale;			// sprite rendering scale (0..255)

	int			rendermode;
	float		renderamt;
	vec3_t		rendercolor;
	int			renderfx;

	float		health;
	float		frags;
	int			weapons;  // bit mask for available weapons
	float		takedamage;

	int			deadflag;
	vec3_t		view_ofs;	// eye position

	int			button;
	int			impulse;

	edict_t		*chain;			// Entity pointer when linked into a linked list
	edict_t		*dmg_inflictor;
	edict_t		*enemy;
	edict_t		*aiment;		// entity pointer when MOVETYPE_FOLLOW
	edict_t		*owner;
	edict_t		*groundentity;

	int			spawnflags;
	int			flags;
	
	int			colormap;		// lowbyte topcolor, highbyte bottomcolor
	int			team;

	float		max_health;
	float		teleport_time;
	float		armortype;
	float		armorvalue;
	int			waterlevel;
	int			watertype;
	
	string_t	target;
	string_t	targetname;
	string_t	netname;
	string_t	message;

	float		dmg_take;
	float		dmg_save;
	float		dmg;
	float		dmgtime;
	
	string_t	noise;
	string_t	noise1;
	string_t	noise2;
	string_t	noise3;
	
	float		speed;
	float		air_finished;
	float		pain_finished;
	float		radsuit_finished;
	
	edict_t		*pContainingEntity;

	int			playerclass;
	float		maxspeed;

	float		fov;
	int			weaponanim;

	int			pushmsec;

	int			bInDuck;
	int			flTimeStepSound;
	int			flSwimTime;
	int			flDuckTime;
	int			iStepLeft;
	float		flFallVelocity;

	int			gamestate;

	int			oldbuttons;

	int			groupinfo;

	// For mods
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
	edict_t		*euser1;
	edict_t		*euser2;
	edict_t		*euser3;
	edict_t		*euser4;
} entvars_t;


#endif // PROGDEFS_H

```

`engine/progs.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef PROGS_H
#define PROGS_H

#include "progdefs.h"

// 16 simultaneous events, max
#define MAX_EVENT_QUEUE 64

#define DEFAULT_EVENT_RESENDS 1

#include "event_flags.h"

typedef struct event_info_s event_info_t;

#include "event_args.h"

struct event_info_s
{
	unsigned short index;			  // 0 implies not in use

	short packet_index;      // Use data from state info for entity in delta_packet .  -1 implies separate info based on event
	                         // parameter signature
	short entity_index;      // The edict this event is associated with

	float fire_time;        // if non-zero, the time when the event should be fired ( fixed up on the client )
	
	event_args_t args;

// CLIENT ONLY	
	int	  flags;			// Reliable or not, etc.

};

typedef struct event_state_s event_state_t;

struct event_state_s
{
	struct event_info_s ei[ MAX_EVENT_QUEUE ];
};

#if !defined( ENTITY_STATEH )
#include "entity_state.h"
#endif

#if !defined( EDICT_H )
#include "edict.h"
#endif

#define	STRUCT_FROM_LINK(l,t,m) ((t *)((byte *)l - (int)&(((t *)0)->m)))
#define	EDICT_FROM_AREA(l) STRUCT_FROM_LINK(l,edict_t,area)

//============================================================================

extern	char			*pr_strings;
extern	globalvars_t	gGlobalVariables;

//============================================================================

edict_t		*ED_Alloc (void);
void		ED_Free (edict_t *ed);
void		ED_LoadFromFile (char *data);

edict_t		*EDICT_NUM(int n);
int			NUM_FOR_EDICT(const edict_t *e);

#define PROG_TO_EDICT(e) ((edict_t *)((byte *)sv.edicts + e))

#endif // PROGS_H

```

`engine/shake.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef SHAKE_H
#define SHAKE_H

// Screen / View effects

// screen shake
extern int gmsgShake;

// This structure is sent over the net to describe a screen shake event
typedef struct
{
	unsigned short	amplitude;		// FIXED 4.12 amount of shake
	unsigned short 	duration;		// FIXED 4.12 seconds duration
	unsigned short	frequency;		// FIXED 8.8 noise frequency (low frequency is a jerk,high frequency is a rumble)
} ScreenShake;

extern void V_ApplyShake( float *origin, float *angles, float factor );
extern void V_CalcShake( void );
extern int V_ScreenShake( const char *pszName, int iSize, void *pbuf );
extern int V_ScreenFade( const char *pszName, int iSize, void *pbuf );


// Fade in/out
extern int gmsgFade;

#define FFADE_IN			0x0000		// Just here so we don't pass 0 into the function
#define FFADE_OUT			0x0001		// Fade out (not in)
#define FFADE_MODULATE		0x0002		// Modulate (don't blend)
#define FFADE_STAYOUT		0x0004		// ignores the duration, stays faded out until new ScreenFade message received

// This structure is sent over the net to describe a screen fade event
typedef struct
{
	unsigned short 	duration;		// FIXED 4.12 seconds duration
	unsigned short 	holdTime;		// FIXED 4.12 seconds duration until reset (fade & hold)
	short			fadeFlags;		// flags
	byte			r, g, b, a;		// fade to color ( max alpha )
} ScreenFade;

#endif		// SHAKE_H


```

`engine/studio.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/




#ifndef _STUDIO_H_
#define _STUDIO_H_

/*
==============================================================================

STUDIO MODELS

Studio models are position independent, so the cache manager can move them.
==============================================================================
*/


#define MAXSTUDIOTRIANGLES	20000	// TODO: tune this
#define MAXSTUDIOVERTS		2048	// TODO: tune this
#define MAXSTUDIOSEQUENCES	256		// total animation sequences
#define MAXSTUDIOSKINS		100		// total textures
#define MAXSTUDIOSRCBONES	512		// bones allowed at source movement
#define MAXSTUDIOBONES		128		// total bones actually used
#define MAXSTUDIOMODELS		32		// sub-models per model
#define MAXSTUDIOBODYPARTS	32
#define MAXSTUDIOGROUPS		16
#define MAXSTUDIOANIMATIONS	512		// per sequence
#define MAXSTUDIOMESHES		256
#define MAXSTUDIOEVENTS		1024
#define MAXSTUDIOPIVOTS		256
#define MAXSTUDIOCONTROLLERS 8

typedef struct 
{
	int					id;
	int					version;

	char				name[64];
	int					length;

	vec3_t				eyeposition;	// ideal eye position
	vec3_t				min;			// ideal movement hull size
	vec3_t				max;			

	vec3_t				bbmin;			// clipping bounding box
	vec3_t				bbmax;		

	int					flags;

	int					numbones;			// bones
	int					boneindex;

	int					numbonecontrollers;		// bone controllers
	int					bonecontrollerindex;

	int					numhitboxes;			// complex bounding boxes
	int					hitboxindex;			
	
	int					numseq;				// animation sequences
	int					seqindex;

	int					numseqgroups;		// demand loaded sequences
	int					seqgroupindex;

	int					numtextures;		// raw textures
	int					textureindex;
	int					texturedataindex;

	int					numskinref;			// replaceable textures
	int					numskinfamilies;
	int					skinindex;

	int					numbodyparts;		
	int					bodypartindex;

	int					numattachments;		// queryable attachable points
	int					attachmentindex;

	int					soundtable;
	int					soundindex;
	int					soundgroups;
	int					soundgroupindex;

	int					numtransitions;		// animation node to animation node transition graph
	int					transitionindex;
} studiohdr_t;

// header for demand loaded sequence group data
typedef struct 
{
	int					id;
	int					version;

	char				name[64];
	int					length;
} studioseqhdr_t;

// bones
typedef struct 
{
	char				name[32];	// bone name for symbolic links
	int		 			parent;		// parent bone
	int					flags;		// ??
	int					bonecontroller[6];	// bone controller index, -1 == none
	float				value[6];	// default DoF values
	float				scale[6];   // scale for delta DoF values
} mstudiobone_t;


// bone controllers
typedef struct 
{
	int					bone;	// -1 == 0
	int					type;	// X, Y, Z, XR, YR, ZR, M
	float				start;
	float				end;
	int					rest;	// byte index value at rest
	int					index;	// 0-3 user set controller, 4 mouth
} mstudiobonecontroller_t;

// intersection boxes
typedef struct
{
	int					bone;
	int					group;			// intersection group
	vec3_t				bbmin;		// bounding box
	vec3_t				bbmax;		
} mstudiobbox_t;

#if !defined( CACHE_USER ) && !defined( QUAKEDEF_H )
#define CACHE_USER
typedef struct cache_user_s
{
	void *data;
} cache_user_t;
#endif

// demand loaded sequence groups
typedef struct
{
	char				label[32];	// textual name
	char				name[64];	// file name
	cache_user_t		cache;		// cache index pointer
	int					data;		// hack for group 0
} mstudioseqgroup_t;

// sequence descriptions
typedef struct
{
	char				label[32];	// sequence label

	float				fps;		// frames per second	
	int					flags;		// looping/non-looping flags

	int					activity;
	int					actweight;

	int					numevents;
	int					eventindex;

	int					numframes;	// number of frames per sequence

	int					numpivots;	// number of foot pivots
	int					pivotindex;

	int					motiontype;	
	int					motionbone;
	vec3_t				linearmovement;
	int					automoveposindex;
	int					automoveangleindex;

	vec3_t				bbmin;		// per sequence bounding box
	vec3_t				bbmax;		

	int					numblends;
	int					animindex;		// mstudioanim_t pointer relative to start of sequence group data
										// [blend][bone][X, Y, Z, XR, YR, ZR]

	int					blendtype[2];	// X, Y, Z, XR, YR, ZR
	float				blendstart[2];	// starting value
	float				blendend[2];	// ending value
	int					blendparent;

	int					seqgroup;		// sequence group for demand loading

	int					entrynode;		// transition node at entry
	int					exitnode;		// transition node at exit
	int					nodeflags;		// transition rules
	
	int					nextseq;		// auto advancing sequences
} mstudioseqdesc_t;

// events
#include "studio_event.h"
/*
typedef struct 
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;
*/

// pivots
typedef struct 
{
	vec3_t				org;	// pivot point
	int					start;
	int					end;
} mstudiopivot_t;

// attachment
typedef struct 
{
	char				name[32];
	int					type;
	int					bone;
	vec3_t				org;	// attachment point
	vec3_t				vectors[3];
} mstudioattachment_t;

typedef struct
{
	unsigned short	offset[6];
} mstudioanim_t;

// animation frames
typedef union 
{
	struct {
		byte	valid;
		byte	total;
	} num;
	short		value;
} mstudioanimvalue_t;



// body part index
typedef struct
{
	char				name[64];
	int					nummodels;
	int					base;
	int					modelindex; // index into models array
} mstudiobodyparts_t;



// skin info
typedef struct
{
	char					name[64];
	int						flags;
	int						width;
	int						height;
	int						index;
} mstudiotexture_t;


// skin families
// short	index[skinfamilies][skinref]

// studio models
typedef struct
{
	char				name[64];

	int					type;

	float				boundingradius;

	int					nummesh;
	int					meshindex;

	int					numverts;		// number of unique vertices
	int					vertinfoindex;	// vertex bone info
	int					vertindex;		// vertex vec3_t
	int					numnorms;		// number of unique surface normals
	int					norminfoindex;	// normal bone info
	int					normindex;		// normal vec3_t

	int					numgroups;		// deformation groups
	int					groupindex;
} mstudiomodel_t;


// vec3_t	boundingbox[model][bone][2];	// complex intersection info


// meshes
typedef struct 
{
	int					numtris;
	int					triindex;
	int					skinref;
	int					numnorms;		// per mesh normals
	int					normindex;		// normal vec3_t
} mstudiomesh_t;

// triangles
#if 0
typedef struct 
{
	short				vertindex;		// index into vertex array
	short				normindex;		// index into normal array
	short				s,t;			// s,t position on skin
} mstudiotrivert_t;
#endif

// lighting options
#define STUDIO_NF_FLATSHADE		0x0001
#define STUDIO_NF_CHROME		0x0002
#define STUDIO_NF_FULLBRIGHT	0x0004

// motion flags
#define STUDIO_X		0x0001
#define STUDIO_Y		0x0002	
#define STUDIO_Z		0x0004
#define STUDIO_XR		0x0008
#define STUDIO_YR		0x0010
#define STUDIO_ZR		0x0020
#define STUDIO_LX		0x0040
#define STUDIO_LY		0x0080
#define STUDIO_LZ		0x0100
#define STUDIO_AX		0x0200
#define STUDIO_AY		0x0400
#define STUDIO_AZ		0x0800
#define STUDIO_AXR		0x1000
#define STUDIO_AYR		0x2000
#define STUDIO_AZR		0x4000
#define STUDIO_TYPES	0x7FFF
#define STUDIO_RLOOP	0x8000	// controller that wraps shortest distance

// sequence flags
#define STUDIO_LOOPING	0x0001

// bone flags
#define STUDIO_HAS_NORMALS	0x0001
#define STUDIO_HAS_VERTICES 0x0002
#define STUDIO_HAS_BBOX		0x0004
#define STUDIO_HAS_CHROME	0x0008	// if any of the textures have chrome on them

#define RAD_TO_STUDIO		(32768.0/M_PI)
#define STUDIO_TO_RAD		(M_PI/32768.0)

#endif

```

`game_shared/bitvec.h`:

```h
//========= Copyright (c) 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#if !defined(BITVEC_H)
#define BITVEC_H

#include <assert.h>
#include <string.h>

class CBitVecAccessor
{
public:
	CBitVecAccessor( unsigned long *pDWords, int iBit );

	void operator=( int val );
	operator unsigned long();

private:
	unsigned long *m_pDWords;
	int m_iBit;
};

// CBitVec allows you to store a list of bits and do operations on them like they were 
// an atomic type.
template<int NUM_BITS>
class CBitVec
{
public:
	CBitVec();

	// Set all values to the specified value (0 or 1..)
	void Init( int val = 0 );

	// Access the bits like an array.
	CBitVecAccessor	operator[]( int i );

	// Operations on other bit vectors.
	CBitVec& operator=( CBitVec<NUM_BITS> const &other );
	bool operator==( CBitVec<NUM_BITS> const &other );
	bool operator!=( CBitVec<NUM_BITS> const &other );

	// Get underlying dword representations of the bits.
	int GetNumDWords();
	unsigned long GetDWord( int i );
	void SetDWord( int i, unsigned long val );

	int GetNumBits();

private:
	enum
	{
		NUM_DWORDS = NUM_BITS / 32 + !!( NUM_BITS & 31 )
	};
	unsigned long m_DWords[NUM_DWORDS];
};

// ------------------------------------------------------------------------ //
// CBitVecAccessor inlines.
// ------------------------------------------------------------------------ //
inline CBitVecAccessor::CBitVecAccessor(unsigned long *pDWords, int iBit)
{
	m_pDWords = pDWords;
	m_iBit = iBit;
}

inline void CBitVecAccessor::operator=( int val )
{
	if( val )
		m_pDWords[m_iBit >> 5] |= ( 1 << ( m_iBit & 31 ) );
	else
		m_pDWords[m_iBit >> 5] &= ~(unsigned long)( 1 << ( m_iBit & 31 ) );
}

inline CBitVecAccessor::operator unsigned long()
{
	return m_pDWords[m_iBit >> 5] & ( 1 << ( m_iBit & 31 ) );
}

// ------------------------------------------------------------------------ //
// CBitVec inlines.
// ------------------------------------------------------------------------ //
template<int NUM_BITS>
inline int CBitVec<NUM_BITS>::GetNumBits()
{
	return NUM_BITS;
}

template<int NUM_BITS>
inline CBitVec<NUM_BITS>::CBitVec()
{
	for( int i = 0; i < NUM_DWORDS; i++ )
		m_DWords[i] = 0;
}

template<int NUM_BITS>
inline void CBitVec<NUM_BITS>::Init( int val )
{
	for( int i = 0; i < GetNumBits(); i++ )
	{
		( *this )[i] = val;
	}
}

template<int NUM_BITS>
inline CBitVec<NUM_BITS>& CBitVec<NUM_BITS>::operator=( CBitVec<NUM_BITS> const &other )
{
	memcpy( m_DWords, other.m_DWords, sizeof(m_DWords) );
	return *this;
}

template<int NUM_BITS>
inline CBitVecAccessor CBitVec<NUM_BITS>::operator[]( int i )	
{
	assert( i >= 0 && i < GetNumBits() );
	return CBitVecAccessor( m_DWords, i );
}

template<int NUM_BITS>
inline bool CBitVec<NUM_BITS>::operator==( CBitVec<NUM_BITS> const &other )
{
	for( int i = 0; i < NUM_DWORDS; i++ )
		if( m_DWords[i] != other.m_DWords[i] )
			return false;

	return true;
}

template<int NUM_BITS>
inline bool CBitVec<NUM_BITS>::operator!=( CBitVec<NUM_BITS> const &other )
{
	return !( *this == other );
}

template<int NUM_BITS>
inline int CBitVec<NUM_BITS>::GetNumDWords()
{
	return NUM_DWORDS;
}

template<int NUM_BITS>
inline unsigned long CBitVec<NUM_BITS>::GetDWord( int i )
{
	assert( i >= 0 && i < NUM_DWORDS );
	return m_DWords[i];
}

template<int NUM_BITS>
inline void CBitVec<NUM_BITS>::SetDWord( int i, unsigned long val )
{
	assert( i >= 0 && i < NUM_DWORDS );
	m_DWords[i] = val;
}
#endif // BITVEC_H

```

`game_shared/voice_banmgr.cpp`:

```cpp
//========= Copyright (c) 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include <string.h>
#include <stdio.h>
#include "voice_banmgr.h"

#define BANMGR_FILEVERSION	1
char const *g_pBanMgrFilename = "voice_ban.dt";

// Hash a player ID to a byte.
unsigned char HashPlayerID( char const playerID[16] )
{
	unsigned char curHash = 0;

	for( int i = 0; i < 16; i++ )
		curHash += (unsigned char)playerID[i];

	return curHash;
}

CVoiceBanMgr::CVoiceBanMgr()
{
	Clear();
}

CVoiceBanMgr::~CVoiceBanMgr()
{
	Term();
}

bool CVoiceBanMgr::Init( char const *pGameDir )
{
	Term();

	char filename[512];
	sprintf( filename, "%s/%s", pGameDir, g_pBanMgrFilename );

	// Load in the squelch file.
	FILE *fp = fopen( filename, "rb" );
	if( fp )
	{
		int version;
		fread( &version, 1, sizeof(version), fp );
		if( version == BANMGR_FILEVERSION )
		{
			fseek( fp, 0, SEEK_END );
			int nIDs = ( ftell( fp ) - sizeof(version) ) / 16;
			fseek( fp, sizeof(version), SEEK_SET );

			for( int i = 0; i < nIDs; i++ )
			{
				char playerID[16];

				fread( playerID, 1, 16, fp );
				AddBannedPlayer( playerID );
			}
		}

		fclose( fp );
	}

	return true;
}

void CVoiceBanMgr::Term()
{
	// Free all the player structures.
	for( int i = 0; i < 256; i++ )
	{
		BannedPlayer *pListHead = &m_PlayerHash[i];
		BannedPlayer *pNext;

		for( BannedPlayer *pCur=pListHead->m_pNext; pCur != pListHead; pCur = pNext )
		{
			pNext = pCur->m_pNext;
			delete pCur;
		}
	}

	Clear();
}

void CVoiceBanMgr::SaveState(char const *pGameDir)
{
	// Save the file out.
	char filename[512];

	sprintf( filename, "%s/%s", pGameDir, g_pBanMgrFilename );

	FILE *fp = fopen( filename, "wb" );
	if( fp )
	{
		int version = BANMGR_FILEVERSION;
		fwrite( &version, 1, sizeof(version), fp );

		for( int i = 0; i < 256; i++ )
		{
			BannedPlayer *pListHead = &m_PlayerHash[i];
			for( BannedPlayer *pCur = pListHead->m_pNext; pCur != pListHead; pCur = pCur->m_pNext )
			{
				fwrite( pCur->m_PlayerID, 1, 16, fp );
			}
		}

		fclose( fp );
	}
}

bool CVoiceBanMgr::GetPlayerBan( char const playerID[16] )
{
	return !!InternalFindPlayerSquelch( playerID );
}

void CVoiceBanMgr::SetPlayerBan( char const playerID[16], bool bSquelch )
{
	if( bSquelch )
	{
		// Is this guy already squelched?
		if( GetPlayerBan( playerID ) )
			return;

		AddBannedPlayer( playerID );
	}
	else
	{
		BannedPlayer *pPlayer = InternalFindPlayerSquelch( playerID );
		if( pPlayer )
		{
			pPlayer->m_pPrev->m_pNext = pPlayer->m_pNext;
			pPlayer->m_pNext->m_pPrev = pPlayer->m_pPrev;
			delete pPlayer;
		}
	}
}

void CVoiceBanMgr::ForEachBannedPlayer(void (*callback)( char id[16] ) )
{
	for( int i = 0; i < 256; i++ )
	{
		for( BannedPlayer *pCur = m_PlayerHash[i].m_pNext; pCur != &m_PlayerHash[i]; pCur = pCur->m_pNext )
		{
			callback( pCur->m_PlayerID );
		}
	}
}

void CVoiceBanMgr::Clear()
{
	// Tie off the hash table entries.
	for( int i = 0; i < 256; i++ )
		m_PlayerHash[i].m_pNext = m_PlayerHash[i].m_pPrev = &m_PlayerHash[i];
}

CVoiceBanMgr::BannedPlayer *CVoiceBanMgr::InternalFindPlayerSquelch( char const playerID[16] )
{
	int index = HashPlayerID( playerID );

	BannedPlayer *pListHead = &m_PlayerHash[index];
	for( BannedPlayer *pCur = pListHead->m_pNext; pCur != pListHead; pCur=pCur->m_pNext )
	{
		if( memcmp( playerID, pCur->m_PlayerID, 16 ) == 0 )
			return pCur;
	}

	return NULL;
}

CVoiceBanMgr::BannedPlayer* CVoiceBanMgr::AddBannedPlayer( char const playerID[16] )
{
	BannedPlayer *pNew = new BannedPlayer;
	if( !pNew )
		return NULL;

	int index = HashPlayerID( playerID );

	memcpy( pNew->m_PlayerID, playerID, 16 );
	pNew->m_pNext = &m_PlayerHash[index];
	pNew->m_pPrev = m_PlayerHash[index].m_pPrev;
	pNew->m_pPrev->m_pNext = pNew->m_pNext->m_pPrev = pNew;

	return pNew;
}

```

`game_shared/voice_banmgr.h`:

```h
//========= Copyright (c) 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#ifndef VOICE_BANMGR_H
#define VOICE_BANMGR_H

// This class manages the (persistent) list of squelched players.
class CVoiceBanMgr
{
public:
			CVoiceBanMgr();
			~CVoiceBanMgr();

	// Init loads the list of squelched players from disk.
	bool		Init( char const *pGameDir );
	void		Term();

	// Saves the state into voice_squelch.dt.
	void		SaveState( char const *pGameDir );

	bool		GetPlayerBan( char const playerID[16] );
	void		SetPlayerBan( char const playerID[16], bool bSquelch );

	// Call your callback for each banned player.
	void		ForEachBannedPlayer( void (*callback)( char id[16] ) );

protected:
	class BannedPlayer
	{
	public:
		char		 m_PlayerID[16];
		BannedPlayer	*m_pPrev, *m_pNext;
	};

	void		 Clear();
	BannedPlayer	*InternalFindPlayerSquelch( char const playerID[16] );
	BannedPlayer	*AddBannedPlayer( char const playerID[16] );

	BannedPlayer	m_PlayerHash[256];
};
#endif // VOICE_BANMGR_H

```

`game_shared/voice_common.h`:

```h
//========= Copyright (c) 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#ifndef VOICE_COMMON_H
#define VOICE_COMMON_H

#include "bitvec.h"

#define VOICE_MAX_PLAYERS		32	// (todo: this should just be set to MAX_CLIENTS).
#define VOICE_MAX_PLAYERS_DW		((VOICE_MAX_PLAYERS / 32) + !!(VOICE_MAX_PLAYERS & 31))

typedef CBitVec<VOICE_MAX_PLAYERS> CPlayerBitVec;
#endif // VOICE_COMMON_H

```

`game_shared/voice_gamemgr.cpp`:

```cpp
//========= Copyright (c) 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include "archtypes.h"     // DAL
#include "voice_gamemgr.h"
#include <string.h>
#include <assert.h>
#include "extdll.h"
#include "util.h"
#include "cbase.h"
#include "player.h"



#define UPDATE_INTERVAL	0.3


// These are stored off as CVoiceGameMgr is created and deleted.
CPlayerBitVec	g_PlayerModEnable;		// Set to 1 for each player if the player wants to use voice in this mod.
										// (If it's zero, then the server reports that the game rules are saying the
										// player can't hear anyone).

CPlayerBitVec	g_BanMasks[VOICE_MAX_PLAYERS];	// Tells which players don't want to hear each other.
												// These are indexed as clients and each bit represents a client
												// (so player entity is bit+1).

CPlayerBitVec	g_SentGameRulesMasks[VOICE_MAX_PLAYERS];	// These store the masks we last sent to each client so we can determine if
CPlayerBitVec	g_SentBanMasks[VOICE_MAX_PLAYERS];			// we need to resend them.
CPlayerBitVec	g_bWantModEnable;

cvar_t voice_serverdebug = {"voice_serverdebug", "0"};

// Set game rules to allow all clients to talk to each other.
// Muted players still can't talk to each other.
cvar_t sv_alltalk = {"sv_alltalk", "0", FCVAR_SERVER};

// ------------------------------------------------------------------------ //
// Static helpers.
// ------------------------------------------------------------------------ //

// Find a player with a case-insensitive name search.
static CBasePlayer* FindPlayerByName(const char *pTestName)
{
	for(int i=1; i <= gpGlobals->maxClients; i++)
	{
		edict_t *pEdict = g_engfuncs.pfnPEntityOfEntIndex(i);
		if(pEdict)
		{
			CBaseEntity *pEnt = CBaseEntity::Instance(pEdict);
			if(pEnt && pEnt->IsPlayer())
			{			
				const char *pNetName = STRING(pEnt->pev->netname);
				if(stricmp(pNetName, pTestName) == 0)
				{
					return (CBasePlayer*)pEnt;
				}
			}
		}
	}

	return NULL;
}

static void VoiceServerDebug( char const *pFmt, ... )
{
	char msg[4096];
	va_list marker;

	if( !voice_serverdebug.value )
		return;

	va_start( marker, pFmt );
	_vsnprintf( msg, sizeof(msg), pFmt, marker );
	va_end( marker );

	ALERT( at_console, "%s", msg );
}



// ------------------------------------------------------------------------ //
// CVoiceGameMgr.
// ------------------------------------------------------------------------ //

CVoiceGameMgr::CVoiceGameMgr()
{
	m_UpdateInterval = 0;
	m_nMaxPlayers = 0;
}


CVoiceGameMgr::~CVoiceGameMgr()
{
}


bool CVoiceGameMgr::Init(
	IVoiceGameMgrHelper *pHelper,
	int maxClients)
{		  
	m_pHelper = pHelper;
	m_nMaxPlayers = VOICE_MAX_PLAYERS < maxClients ? VOICE_MAX_PLAYERS : maxClients;
	g_engfuncs.pfnPrecacheModel("sprites/voiceicon.spr");

	m_msgPlayerVoiceMask = REG_USER_MSG( "VoiceMask", VOICE_MAX_PLAYERS_DW*4 * 2 );
	m_msgRequestState = REG_USER_MSG( "ReqState", 0 );
	
	// register voice_serverdebug if it hasn't been registered already
	if ( !CVAR_GET_POINTER( "voice_serverdebug" ) )
		CVAR_REGISTER( &voice_serverdebug );

	if( !CVAR_GET_POINTER( "sv_alltalk" ) )
		CVAR_REGISTER( &sv_alltalk );

	return true;
}


void CVoiceGameMgr::SetHelper(IVoiceGameMgrHelper *pHelper)
{
	m_pHelper = pHelper;
}


void CVoiceGameMgr::Update(double frametime)
{
	// Only update periodically.
	m_UpdateInterval += frametime;
	if(m_UpdateInterval < UPDATE_INTERVAL)
		return;

	UpdateMasks();
}


void CVoiceGameMgr::ClientConnected(edict_t *pEdict)
{
	int index = ENTINDEX(pEdict) - 1;
	
	// Clear out everything we use for deltas on this guy.
	g_bWantModEnable[index] = true;
	g_SentGameRulesMasks[index].Init(0);
	g_SentBanMasks[index].Init(0);
}

// Called to determine if the Receiver has muted (blocked) the Sender
// Returns true if the receiver has blocked the sender
bool CVoiceGameMgr::PlayerHasBlockedPlayer(CBasePlayer *pReceiver, CBasePlayer *pSender)
{
	int iReceiverIndex, iSenderIndex;

	if ( !pReceiver || !pSender )
		return false;

	iReceiverIndex = pReceiver->entindex() - 1;
	iSenderIndex   = pSender->entindex() - 1;

	if ( iReceiverIndex < 0 || iReceiverIndex >= m_nMaxPlayers || iSenderIndex < 0 || iSenderIndex >= m_nMaxPlayers )
		return false;

	return ( g_BanMasks[iReceiverIndex][iSenderIndex] ? true : false );
}

bool CVoiceGameMgr::ClientCommand(CBasePlayer *pPlayer, const char *cmd)
{
	int playerClientIndex = pPlayer->entindex() - 1;
	if(playerClientIndex < 0 || playerClientIndex >= m_nMaxPlayers)
	{
		VoiceServerDebug( "CVoiceGameMgr::ClientCommand: cmd %s from invalid client (%d)\n", cmd, playerClientIndex );
		return true;
	}

	bool bBan = stricmp(cmd, "vban") == 0;
	if(bBan && CMD_ARGC() >= 2)
	{
		for(int i=1; i < CMD_ARGC(); i++)
		{
			uint32 mask = 0;
			sscanf(CMD_ARGV(i), "%x", &mask);

			if(i <= VOICE_MAX_PLAYERS_DW)
			{
				VoiceServerDebug( "CVoiceGameMgr::ClientCommand: vban (0x%x) from %d\n", mask, playerClientIndex );
				g_BanMasks[playerClientIndex].SetDWord(i-1, mask);
			}
			else
			{
				VoiceServerDebug( "CVoiceGameMgr::ClientCommand: invalid index (%d)\n", i );
			}
		}

		// Force it to update the masks now.
		// UpdateMasks();		
		return true;
	}
	else if(stricmp(cmd, "VModEnable") == 0 && CMD_ARGC() >= 2)
	{
		VoiceServerDebug( "CVoiceGameMgr::ClientCommand: VModEnable (%d)\n", !!atoi(CMD_ARGV(1)) );
		g_PlayerModEnable[playerClientIndex] = !!atoi(CMD_ARGV(1));
		g_bWantModEnable[playerClientIndex] = false;
		// UpdateMasks();
		return true;
	}
	else
	{
		return false;
	}
}


void CVoiceGameMgr::UpdateMasks()
{
	m_UpdateInterval = 0;

	bool bAllTalk = !!(sv_alltalk.value);

	for(int iClient=0; iClient < m_nMaxPlayers; iClient++)
	{
		CBaseEntity *pEnt = UTIL_PlayerByIndex(iClient+1);
		if(!pEnt || !pEnt->IsPlayer())
			continue;

		// Request the state of their "VModEnable" cvar.
		if(g_bWantModEnable[iClient])
		{
			MESSAGE_BEGIN(MSG_ONE, m_msgRequestState, NULL, pEnt->pev);
			MESSAGE_END();
		}

		CBasePlayer *pPlayer = (CBasePlayer*)pEnt;

		CPlayerBitVec gameRulesMask;
		if( g_PlayerModEnable[iClient] )
		{
			// Build a mask of who they can hear based on the game rules.
			for(int iOtherClient=0; iOtherClient < m_nMaxPlayers; iOtherClient++)
			{
				CBaseEntity *pEnt = UTIL_PlayerByIndex(iOtherClient+1);
				if(pEnt && (bAllTalk || m_pHelper->CanPlayerHearPlayer(pPlayer, (CBasePlayer*)pEnt)) )
				{
					gameRulesMask[iOtherClient] = true;
				}
			}
		}

		// If this is different from what the client has, send an update. 
		if(gameRulesMask != g_SentGameRulesMasks[iClient] || 
			g_BanMasks[iClient] != g_SentBanMasks[iClient])
		{
			g_SentGameRulesMasks[iClient] = gameRulesMask;
			g_SentBanMasks[iClient] = g_BanMasks[iClient];

			MESSAGE_BEGIN(MSG_ONE, m_msgPlayerVoiceMask, NULL, pPlayer->pev);
				int dw;
				for(dw=0; dw < VOICE_MAX_PLAYERS_DW; dw++)
				{
					WRITE_LONG(gameRulesMask.GetDWord(dw));
					WRITE_LONG(g_BanMasks[iClient].GetDWord(dw));
				}
			MESSAGE_END();
		}

		// Tell the engine.
		for(int iOtherClient=0; iOtherClient < m_nMaxPlayers; iOtherClient++)
		{
			bool bCanHear = gameRulesMask[iOtherClient] && !g_BanMasks[iClient][iOtherClient];
			g_engfuncs.pfnVoice_SetClientListening(iClient+1, iOtherClient+1, bCanHear);
		}
	}
}
```

`game_shared/voice_gamemgr.h`:

```h
//========= Copyright (c) 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#ifndef VOICE_GAMEMGR_H
#define VOICE_GAMEMGR_H

#ifdef _WIN32
#endif


#include "voice_common.h"


class CGameRules;
class CBasePlayer;


class IVoiceGameMgrHelper
{
public:
	virtual				~IVoiceGameMgrHelper() {}

	// Called each frame to determine which players are allowed to hear each other.	This overrides
	// whatever squelch settings players have.
	virtual bool		CanPlayerHearPlayer(CBasePlayer *pListener, CBasePlayer *pTalker) = 0;
};


// CVoiceGameMgr manages which clients can hear which other clients.
class CVoiceGameMgr
{
public:
						CVoiceGameMgr();
	virtual				~CVoiceGameMgr();
	
	bool				Init(
		IVoiceGameMgrHelper *m_pHelper,
		int maxClients
		);

	void				SetHelper(IVoiceGameMgrHelper *pHelper);

	// Updates which players can hear which other players.
	// If gameplay mode is DM, then only players within the PVS can hear each other.
	// If gameplay mode is teamplay, then only players on the same team can hear each other.
	// Player masks are always applied.
	void				Update(double frametime);

	// Called when a new client connects (unsquelches its entity for everyone).
	void				ClientConnected(struct edict_s *pEdict);

	// Called on ClientCommand. Checks for the squelch and unsquelch commands.
	// Returns true if it handled the command.
	bool				ClientCommand(CBasePlayer *pPlayer, const char *cmd);

	// Called to determine if the Receiver has muted (blocked) the Sender
	// Returns true if the receiver has blocked the sender
	bool				PlayerHasBlockedPlayer(CBasePlayer *pReceiver, CBasePlayer *pSender);


private:

	// Force it to update the client masks.
	void				UpdateMasks();


	int					m_msgPlayerVoiceMask;
	int					m_msgRequestState;

	IVoiceGameMgrHelper	*m_pHelper;
	int					m_nMaxPlayers;
	double				m_UpdateInterval;						// How long since the last update.
};


#endif // VOICE_GAMEMGR_H
```

`game_shared/voice_status.cpp`:

```cpp

#include <stdio.h>
#include <string.h>

#include "wrect.h"
#include "cl_dll.h"
#include "cl_util.h"
#include "cl_entity.h"
#include "const.h"

#include "parsemsg.h" // BEGIN_READ(), ...

#include "voice_status.h"

#pragma warning( disable : 4800 ) // disable forcing int to bool performance warning

static CVoiceStatus *g_pInternalVoiceStatus = NULL;

// ---------------------------------------------------------------------- //
// The voice manager for the client.
// ---------------------------------------------------------------------- //
CVoiceStatus g_VoiceStatus;

CVoiceStatus *GetClientVoice()
{
	return &g_VoiceStatus;
}

int __MsgFunc_VoiceMask( const char *pszName, int iSize, void *pbuf )
{
	if ( g_pInternalVoiceStatus )
		g_pInternalVoiceStatus->HandleVoiceMaskMsg( iSize, pbuf );

	return 1;
}

int __MsgFunc_ReqState( const char *pszName, int iSize, void *pbuf )
{
	if ( g_pInternalVoiceStatus )
		g_pInternalVoiceStatus->HandleReqStateMsg( iSize, pbuf );

	return 1;
}

int g_BannedPlayerPrintCount;
void ForEachBannedPlayer( char id[16] )
{
	char str[256];
	sprintf( str, "Ban %d: %2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x\n",
	         g_BannedPlayerPrintCount++,
	         id[0], id[1], id[2], id[3],
	         id[4], id[5], id[6], id[7],
	         id[8], id[9], id[10], id[11],
	         id[12], id[13], id[14], id[15] );
#ifdef _WIN32
	strupr( str );
#endif
	gEngfuncs.pfnConsolePrint( str );
}

void ShowBannedCallback()
{
	if ( g_pInternalVoiceStatus )
	{
		g_BannedPlayerPrintCount = 0;
		gEngfuncs.pfnConsolePrint( "------- BANNED PLAYERS -------\n" );
		g_pInternalVoiceStatus->GetBanMgr()->ForEachBannedPlayer( ForEachBannedPlayer );
		gEngfuncs.pfnConsolePrint( "------------------------------\n" );
	}
}

CVoiceStatus::CVoiceStatus()
{
	m_bBanMgrInitialized = false;
	m_LastUpdateServerState = 0;

	m_bTalking = m_bServerAcked = false;

	m_bServerModEnable = -1;

	m_pchGameDir = NULL;
}

CVoiceStatus::~CVoiceStatus()
{
	g_pInternalVoiceStatus = NULL;

	if ( m_pchGameDir )
	{
		if ( m_bBanMgrInitialized )
		{
			m_BanMgr.SaveState( m_pchGameDir );
		}

		free( m_pchGameDir );
	}
}

void CVoiceStatus::Init( IVoiceStatusHelper *pHelper )
{
	// Setup the voice_modenable cvar.
	gEngfuncs.pfnRegisterVariable( "voice_modenable", "1", FCVAR_ARCHIVE );

	gEngfuncs.pfnRegisterVariable( "voice_clientdebug", "0", 0 );

	gEngfuncs.pfnAddCommand( "voice_showbanned", ShowBannedCallback );

	// Cache the game directory for use when we shut down
	const char *pchGameDirT = gEngfuncs.pfnGetGameDirectory();
	m_pchGameDir = (char *)malloc( strlen( pchGameDirT ) + 1 );

	if ( m_pchGameDir )
	{
		strcpy( m_pchGameDir, pchGameDirT );
	}

	if ( m_pchGameDir )
	{
		m_BanMgr.Init( m_pchGameDir );
		m_bBanMgrInitialized = true;
	}

	assert( !g_pInternalVoiceStatus );
	g_pInternalVoiceStatus = this;

	m_bInSquelchMode = false;

	m_pHelper = pHelper;

	gEngfuncs.pfnHookUserMsg( "VoiceMask", __MsgFunc_VoiceMask );
	gEngfuncs.pfnHookUserMsg( "ReqState", __MsgFunc_ReqState );

	GetClientVoiceHud()->Init( pHelper, this );
}

void CVoiceStatus::Frame( double frametime )
{
	// check server banned players once per second
	if ( gEngfuncs.GetClientTime() - m_LastUpdateServerState > 1 )
	{
		UpdateServerState( false );
	}
}

void CVoiceStatus::StartSquelchMode()
{
	if ( m_bInSquelchMode )
		return;

	m_bInSquelchMode = true;
}

void CVoiceStatus::StopSquelchMode()
{
	m_bInSquelchMode = false;
}

bool CVoiceStatus::IsInSquelchMode()
{
	return m_bInSquelchMode;
}

void CVoiceStatus::UpdateServerState( bool bForce )
{
	// Can't do anything when we're not in a level.
	char const *pLevelName = gEngfuncs.pfnGetLevelName();
	if ( pLevelName[0] == 0 )
	{
		if ( gEngfuncs.pfnGetCvarFloat( "voice_clientdebug" ) )
		{
			gEngfuncs.pfnConsolePrint( "CVoiceStatus::UpdateServerState: pLevelName[0]==0\n" );
		}

		return;
	}

	int bCVarModEnable = !!gEngfuncs.pfnGetCvarFloat( "voice_modenable" );
	if ( bForce || m_bServerModEnable != bCVarModEnable )
	{
		m_bServerModEnable = bCVarModEnable;

		char str[256];
		sprintf( str, "VModEnable %d", m_bServerModEnable );
		ServerCmd( str );

		if ( gEngfuncs.pfnGetCvarFloat( "voice_clientdebug" ) )
		{
			char msg[256];
			sprintf( msg, "CVoiceStatus::UpdateServerState: Sending '%s'\n", str );
			gEngfuncs.pfnConsolePrint( msg );
		}
	}

	char str[2048];
	sprintf( str, "vban" );
	bool bChange = false;

	for ( uint32 dw = 0; dw < VOICE_MAX_PLAYERS_DW; dw++ )
	{
		uint32 serverBanMask = 0;
		uint32 banMask = 0;

		for ( uint32 i = 0; i < 32; i++ )
		{
			char playerID[16];
			if ( !gEngfuncs.GetPlayerUniqueID( i + 1, playerID ) )
				continue;

			if ( m_BanMgr.GetPlayerBan( playerID ) )
				banMask |= 1 << i;

			if ( m_ServerBannedPlayers[dw * 32 + i] )
				serverBanMask |= 1 << i;
		}

		if ( serverBanMask != banMask )
			bChange = true;

		// Ok, the server needs to be updated.
		char numStr[512];
		sprintf( numStr, " %x", banMask );
		strcat( str, numStr );
	}

	if ( bChange || bForce )
	{
		if ( gEngfuncs.pfnGetCvarFloat( "voice_clientdebug" ) )
		{
			char msg[256];
			sprintf( msg, "CVoiceStatus::UpdateServerState: Sending '%s'\n", str );
			gEngfuncs.pfnConsolePrint( msg );
		}

		gEngfuncs.pfnServerCmdUnreliable( str ); // Tell the server..
	}
	else
	{
		if ( gEngfuncs.pfnGetCvarFloat( "voice_clientdebug" ) )
		{
			gEngfuncs.pfnConsolePrint( "CVoiceStatus::UpdateServerState: no change\n" );
		}
	}

	m_LastUpdateServerState = gEngfuncs.GetClientTime();
}

int CVoiceStatus::GetSpeakerStatus( int iPlayer )
{
	bool bTalking = static_cast<bool>( m_VoicePlayers[iPlayer] );

	char playerID[16];
	qboolean id = gEngfuncs.GetPlayerUniqueID( iPlayer + 1, playerID );
	if ( !id )
		return VOICE_NEVERSPOKEN;

	bool bBanned = m_BanMgr.GetPlayerBan( playerID );
	bool bNeverSpoken = !m_VoiceEnabledPlayers[iPlayer];

	if ( bBanned )
	{
		return VOICE_BANNED;
	}
	else if ( bNeverSpoken )
	{
		return VOICE_NEVERSPOKEN;
	}
	else if ( bTalking )
	{
		return VOICE_TALKING;
	}
	else
		return VOICE_NOTTALKING;
}

void CVoiceStatus::HandleVoiceMaskMsg( int iSize, void *pbuf )
{
	BufferReader reader( pbuf, iSize );

	uint32 dw;
	for ( dw = 0; dw < VOICE_MAX_PLAYERS_DW; dw++ )
	{
		m_AudiblePlayers.SetDWord( dw, (uint32)reader.ReadLong() );
		m_ServerBannedPlayers.SetDWord( dw, (uint32)reader.ReadLong() );

		if ( gEngfuncs.pfnGetCvarFloat( "voice_clientdebug" ) )
		{
			char str[256];
			gEngfuncs.pfnConsolePrint( "CVoiceStatus::HandleVoiceMaskMsg\n" );

			sprintf( str, "    - m_AudiblePlayers[%d] = %lu\n", dw, m_AudiblePlayers.GetDWord( dw ) );
			gEngfuncs.pfnConsolePrint( str );

			sprintf( str, "    - m_ServerBannedPlayers[%d] = %lu\n", dw, m_ServerBannedPlayers.GetDWord( dw ) );
			gEngfuncs.pfnConsolePrint( str );
		}
	}

	m_bServerModEnable = reader.ReadByte();
}

void CVoiceStatus::HandleReqStateMsg( int iSize, void *pbuf )
{
	if ( gEngfuncs.pfnGetCvarFloat( "voice_clientdebug" ) )
	{
		gEngfuncs.pfnConsolePrint( "CVoiceStatus::HandleReqStateMsg\n" );
	}

	UpdateServerState( true );
}

void CVoiceStatus::UpdateSpeakerStatus( int entindex, bool bTalking )
{
	const char *levelName = gEngfuncs.pfnGetLevelName();

	if ( levelName && levelName[0] )
	{
		if ( gEngfuncs.pfnGetCvarFloat( "voice_clientdebug" ) )
		{
			char msg[256];
			sprintf( msg, "CVoiceStatus::UpdateSpeakerStatus: ent %d talking = %d\n", entindex, bTalking );
			gEngfuncs.pfnConsolePrint( msg );
		}

		// Is it the local player talking?
		if ( entindex == -1 )
		{
			m_bTalking = bTalking;
			if ( bTalking )
			{
				// Enable voice for them automatically if they try to talk.
				gEngfuncs.pfnClientCmd( "voice_modenable 1" );
			}
			if ( !gEngfuncs.GetLocalPlayer() )
			{
				return;
			}

			int entindex = gEngfuncs.GetLocalPlayer()->index;
			GetClientVoiceHud()->UpdateSpeakerStatus( -2, bTalking );

			m_VoicePlayers[entindex - 1] = m_bTalking;
			m_VoiceEnabledPlayers[entindex - 1] = true;
		}
		else if ( entindex == -2 )
		{
			m_bServerAcked = bTalking;
		}
		else if ( entindex >= 0 && entindex <= VOICE_MAX_PLAYERS )
		{
			int iClient = entindex - 1;
			if ( iClient < 0 )
				return;

			GetClientVoiceHud()->UpdateSpeakerStatus( entindex, bTalking );

			if ( bTalking )
			{
				m_VoicePlayers[iClient] = true;
				m_VoiceEnabledPlayers[iClient] = true;
			}
			else
			{
				m_VoicePlayers[iClient] = false;
			}
		}

		GetClientVoiceHud()->RepositionLabels();
	}
}

//-----------------------------------------------------------------------------
// Purpose: returns true if the target client has been banned
// Input  : playerID -
// Output : Returns true on success, false on failure.
//-----------------------------------------------------------------------------
bool CVoiceStatus::IsPlayerBlocked( int iPlayer )
{
	char playerID[16];
	if ( !gEngfuncs.GetPlayerUniqueID( iPlayer, playerID ) )
		return false;

	return m_BanMgr.GetPlayerBan( playerID );
}

//-----------------------------------------------------------------------------
// Purpose: returns true if the player can't hear the other client due to game rules (eg. the other team)
// Input  : playerID -
// Output : Returns true on success, false on failure.
//-----------------------------------------------------------------------------
bool CVoiceStatus::IsPlayerAudible( int iPlayer )
{
	return !!m_AudiblePlayers[iPlayer - 1];
}

//-----------------------------------------------------------------------------
// Purpose: blocks/unblocks the target client from being heard
// Input  : playerID -
// Output : Returns true on success, false on failure.
//-----------------------------------------------------------------------------
void CVoiceStatus::SetPlayerBlockedState( int iPlayer, bool blocked )
{
	if ( gEngfuncs.pfnGetCvarFloat( "voice_clientdebug" ) )
	{
		gEngfuncs.pfnConsolePrint( "CVoiceStatus::SetPlayerBlockedState part 1\n" );
	}

	char playerID[16];
	if ( !gEngfuncs.GetPlayerUniqueID( iPlayer, playerID ) )
		return;

	if ( gEngfuncs.pfnGetCvarFloat( "voice_clientdebug" ) )
	{
		gEngfuncs.pfnConsolePrint( "CVoiceStatus::SetPlayerBlockedState part 2\n" );
	}

	// Squelch or (try to) unsquelch this player.
	if ( gEngfuncs.pfnGetCvarFloat( "voice_clientdebug" ) )
	{
		char str[256];
		sprintf( str, "CVoiceStatus::SetPlayerBlockedState: setting player %d ban to %d\n", iPlayer, !m_BanMgr.GetPlayerBan( playerID ) );
		gEngfuncs.pfnConsolePrint( str );
	}

	m_BanMgr.SetPlayerBan( playerID, blocked );
	UpdateServerState( false );
}
```

`game_shared/voice_status.h`:

```h
//========= Copyright © 1996-2001, Valve LLC, All rights reserved. ============
//
// Purpose:
//
// $NoKeywords: $
//=============================================================================

#ifndef VOICE_STATUS_H
#define VOICE_STATUS_H
#pragma once

#include "voice_common.h"
#include "voice_banmgr.h"

// This is provided by each mod to access data that may not be the same across mods.
class IVoiceStatusHelper
{
public:
	virtual ~IVoiceStatusHelper() { }

	// Get RGB color for voice status text about this player.
	virtual void GetPlayerTextColor( int entindex, int color[3] ) = 0;

	// Return the height above the bottom that the voice ack icons should be drawn at.
	virtual int GetAckIconHeight() = 0;

	// Return true if the voice manager is allowed to show speaker labels
	// (mods usually return false when the scoreboard is up).
	virtual bool CanShowSpeakerLabels() = 0;

	// return a pre-translated string for the player's location.  Defaults to empty string for games without locations
	virtual const char *GetPlayerLocation( int entindex ) { return ""; }
};

class IVoiceStatus
{
public:
	// returns the state of this player using the enum above
	virtual int GetSpeakerStatus( int iPlayer ) = 0;
	virtual bool IsTalking() = 0;
	virtual bool ServerAcked() = 0;
};

class IVoiceHud
{
public:
	virtual int Init( IVoiceStatusHelper *pHelper, IVoiceStatus *pStatus ) = 0;

	// ackPosition is the bottom position of where CVoiceStatus will draw the voice acknowledgement labels.
	virtual int VidInit() = 0;

	// Call from the HUD_CreateEntities function so it can add sprites above player heads.
	virtual void CreateEntities() = 0;

	// Sets a player's location (can be a #-prefixed string for localization).
	virtual void UpdateLocation( int entindex, const char *location ) = 0;

	virtual void UpdateSpeakerStatus( int entindex, bool bTalking ) = 0;

	virtual void RepositionLabels() = 0;
};

class CVoiceStatus : public IVoiceStatusHelper, public IVoiceStatus
{

public:
	CVoiceStatus();
	~CVoiceStatus();

	void Init( IVoiceStatusHelper *pHelper );

	// Called when a player starts or stops talking.
	// entindex is -1 to represent the local client talking (before the data comes back from the server).
	// When the server acknowledges that the local client is talking, then entindex will be gEngfuncs.GetLocalPlayer().
	// entindex is -2 to represent the local client's voice being acked by the server.
	void UpdateSpeakerStatus( int entindex, bool bTalking );

	// returns the state of this player using the enum above
	int GetSpeakerStatus( int iPlayer );

	// Called when the server registers a change to who this client can hear.
	void HandleVoiceMaskMsg( int iSize, void *pbuf );

	// The server sends this message initially to tell the client to send their state.
	void HandleReqStateMsg( int iSize, void *pbuf );

	void Frame( double frametime );

	// When you enter squelch mode, pass in
	void StartSquelchMode();
	void StopSquelchMode();
	bool IsInSquelchMode();

	// returns true if the target client has been banned
	// playerIndex is of range 1..maxplayers
	bool IsPlayerBlocked( int iPlayerIndex );

	// returns false if the player can't hear the other client due to game rules (eg. the other team)
	bool IsPlayerAudible( int iPlayerIndex );

	// blocks the target client from being heard
	void SetPlayerBlockedState( int iPlayerIndex, bool blocked );

	void UpdateServerState( bool bForce );

	virtual bool CanShowSpeakerLabels()
	{
		return m_pHelper->CanShowSpeakerLabels();
	}

	virtual void GetPlayerTextColor( int entindex, int color[3] )
	{
		m_pHelper->GetPlayerTextColor( entindex, color );
	}

	virtual int GetAckIconHeight()
	{
		return m_pHelper->GetAckIconHeight();
	}

	bool IsTalking()
	{
		return m_bTalking;
	}

	bool ServerAcked()
	{
		return m_bServerAcked;
	}

	CVoiceBanMgr *GetBanMgr() { return &m_BanMgr; }

	enum
	{
		VOICE_TALKING = 1, // start from one because ImageList's don't use pos 0
		VOICE_BANNED,
		VOICE_NEVERSPOKEN,
		VOICE_NOTTALKING,
	}; // various voice states

private:
	float m_LastUpdateServerState; // Last time we called this function.
	int m_bServerModEnable;        // What we've sent to the server about our "voice_modenable" cvar.

	CPlayerBitVec m_VoicePlayers; // Who is currently talking. Indexed by client index.

	// This is the gamerules-defined list of players that you can hear. It is based on what teams people are on
	// and is totally separate from the ban list. Indexed by client index.
	CPlayerBitVec m_AudiblePlayers;

	// Players who have spoken at least once in the game so far
	CPlayerBitVec m_VoiceEnabledPlayers;

	// This is who the server THINKS we have banned (it can become incorrect when a new player arrives on the server).
	// It is checked periodically, and the server is told to squelch or unsquelch the appropriate players.
	CPlayerBitVec m_ServerBannedPlayers;

	IVoiceStatusHelper *m_pHelper; // Each mod provides an implementation of this.

	// Squelch mode stuff.
	bool m_bInSquelchMode;

	bool m_bTalking;     // Set to true when the client thinks it's talking.
	bool m_bServerAcked; // Set to true when the server knows the client is talking.

	CVoiceBanMgr m_BanMgr; // Tracks which users we have squelched and don't want to hear.

	bool m_bBanMgrInitialized;

	// Cache the game directory for use when we shut down
	char *m_pchGameDir;
};

CVoiceStatus *GetClientVoice();

// Get the (global) voice manager.
IVoiceHud *GetClientVoiceHud();

#endif // VOICE_STATUS_H
```

`game_shared/voice_status_hud.cpp`:

```cpp
//========= Copyright 1996-2001, Valve LLC, All rights reserved. ============
//
// Purpose:
//
// $NoKeywords: $
//=============================================================================

// There are hud.h's coming out of the woodwork so this ensures that we get the right one.
#if defined( THREEWAVE ) || defined( DMC_BUILD )
#include "../dmc/cl_dll/hud.h"
#elif defined( CZERO )
#include "../czero/cl_dll/hud.h"
#elif defined( CSTRIKE )
#include "../cstrike/cl_dll/hud.h"
#elif defined( DOD )
#include "../dod/cl_dll/hud.h"
#elif defined( BLUESHIFT )
#include "../blueshift/cl_dll/hud.h"
#else
#include "../cl_dll/hud.h"
#endif

#include "cl_util.h"
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "demo.h"
#include "demo_api.h"
#include "r_efx.h"
#include "entity_types.h"
// #include "shared_util.h"

#include "voice_status.h"
#include "voice_status_hud.h"

#include <vgui_parser.h>

// using namespace vgui;

// #include <vgui/IVGui.h>
// #include <vgui/IImage.h>
//
// #include <vgui/ILocalize.h>

#include "triangleapi.h"
#include "draw_util.h"

extern int cam_thirdperson;

#define VOICE_MODEL_INTERVAL 0.3
// #define SCOREBOARD_BLINK_FREQUENCY	0.3	// How often to blink the scoreboard icons.
#define SQUELCHOSCILLATE_PER_SECOND 2.0f

int g_VoiceLabelIcon;

// ---------------------------------------------------------------------- //
// The voice manager for the client.
// ---------------------------------------------------------------------- //
CVoiceStatusHud g_VoiceStatusHud;

IVoiceHud *GetClientVoiceHud()
{
	return &g_VoiceStatusHud;
}

// ---------------------------------------------------------------------- //
// CVoiceLabel.
// ---------------------------------------------------------------------- //
void CVoiceLabel::SetLocation( const char *location )
{
	if ( !location || !*location )
	{
		if ( m_locationString )
		{
			delete[] m_locationString;
			m_locationString = NULL;
			RebuildLabelText();
		}
		return;
	}

	// const wchar_t *newLocation = vgui::localize()->Find( location );
	const char *newLocation = Localize( location );

	if ( strcmp( newLocation, location ) != 0 )
	{
		// localized version
		if ( m_locationString && strcmp( newLocation, m_locationString ) )
		{
			delete[] m_locationString;
			m_locationString = NULL;
		}

		if ( !m_locationString )
		{
			// m_locationString = CloneWString( newLocation );
			m_locationString = new char[sizeof( newLocation )];
			strncpy( m_locationString, newLocation, sizeof( m_locationString ) );
			// m_locationString[sizeof( m_locationString ) - 1] = '\0';
			RebuildLabelText();
		}
	}
	/*
	else
	{
	    // just convert the ANSI version to Unicode
	    wchar_t *tmpBuf = new wchar_t[strlen( location ) + 1];
	    localize()->ConvertANSIToUnicode( location, tmpBuf, sizeof( tmpBuf ) );

	    if ( m_locationString && wcscmp( tmpBuf, m_locationString ) )
	    {
	        delete[] m_locationString;
	        m_locationString = NULL;
	    }

	    if ( !m_locationString )
	    {
	        m_locationString = CloneWString( tmpBuf );
	        RebuildLabelText();
	    }

	    delete[] tmpBuf;
	}
	*/
}

void CVoiceLabel::SetPlayerName( const char *name )
{
	if ( m_playerName )
	{
		delete[] m_playerName;
		m_playerName = NULL;
	}

	if ( name )
	{
		// m_playerName = CloneString( name );
		m_playerName = new char[strlen( name ) + 1];
		strcpy( m_playerName, name );
		// m_playerName[sizeof( m_locationString ) - 1] = '\0';
	}

	RebuildLabelText();
}

void CVoiceLabel::RebuildLabelText()
{
	const int BufLen = 512;
	// wchar_t buf[BufLen] = L"";
	char buf[BufLen] = "";
	if ( m_playerName )
	{
		// wchar_t wsPlayer[BufLen] = L"";

		// localize()->ConvertANSIToUnicode( m_playerName, wsPlayer, sizeof( wsPlayer ) );

		// const wchar_t *formatStr = L"%ls   ";
		const char *formatStr = "%s   ";
		if ( m_locationString )
		{
			// formatStr = localize()->Find( "#Voice_Location" );
			formatStr = Localize( "#Voice_Location" );
			if ( !strcmp( formatStr, "#Voice_Location") )
				formatStr = "%ls/%ls   ";
		}
		// _snwprintf( buf, BufLen, formatStr, wsPlayer, m_locationString );
		snprintf( buf, BufLen, formatStr, m_playerName, m_locationString );
	}
	// /m_pLabel->SetText( buf );
	strncpy( m_buf, buf, sizeof( m_buf ) );
	// gEngfuncs.Con_DPrintf( "CVoiceLabel::RebuildLabelText() - [%ls]\n", buf );
}

// ---------------------------------------------------------------------- //
// CVoiceStatus.
// ---------------------------------------------------------------------- //

CVoiceStatusHud::CVoiceStatusHud()
{
}

CVoiceStatusHud::~CVoiceStatusHud()
{
}

int CVoiceStatusHud::Init( IVoiceStatusHelper *pHelper, IVoiceStatus *pStatus )
{
	m_VoiceHeadModel = NULL;

	m_pHelper = pHelper;
	m_pStatus = pStatus;

	gHUD.AddHudElem( this );
	m_iFlags = HUD_ACTIVE;

	// m_pLocalPlayerTalkIcon = new vgui::ImagePanel( NULL, "LocalPlayerIcon" );
	// m_pLocalPlayerTalkIcon->SetParent( gViewPortInterface->GetViewPortPanel() );
	// m_pLocalPlayerTalkIcon->SetVisible( false );
	// m_pLocalPlayerTalkIcon->SetImage( scheme()->GetImage( "gfx/vgui/icntlk_pl", false ) );
	m_pLocalPlayerTalkIcon = gRenderAPI.GL_LoadTexture( "gfx/vgui/icntlk_pl.tga", NULL, 0, TF_NEAREST | TF_NOMIPMAP | TF_CLAMP );
	m_LocalPlayerTalkIconVisible = false;

	g_VoiceLabelIcon = gRenderAPI.GL_LoadTexture( "gfx/vgui/speaker4.tga", NULL, 0, TF_NEAREST | TF_NOMIPMAP | TF_CLAMP );

	return 1;
}

int CVoiceStatusHud::VidInit()
{
	// Figure out the voice head model height.
	m_VoiceHeadModelHeight = 45;
	char *pFile = (char *)gEngfuncs.COM_LoadFile( "scripts/voicemodel.txt", 5, NULL );
	if ( pFile )
	{
		char token[4096];
		gEngfuncs.COM_ParseFile( pFile, token );
		if ( token[0] >= '0' && token[0] <= '9' )
		{
			m_VoiceHeadModelHeight = (float)atof( token );
		}

		gEngfuncs.COM_FreeFile( pFile );
	}

	m_VoiceHeadModel = gEngfuncs.pfnSPR_Load( "sprites/voiceicon.spr" );
	return TRUE;
}

void CVoiceStatusHud::CreateEntities()
{
	if ( !m_VoiceHeadModel )
		return;

	cl_entity_t *localPlayer = gEngfuncs.GetLocalPlayer();

	int iOutModel = 0;
	for ( int i = 0; i < VOICE_MAX_PLAYERS; i++ )
	{
		if ( m_pStatus->GetSpeakerStatus( i ) != CVoiceStatus::VOICE_TALKING )
		{
			continue;
		}

		cl_entity_s *pClient = gEngfuncs.GetEntityByIndex( i + 1 );

		// Don't show an icon if the player is not in our PVS.
		if ( !pClient || pClient->curstate.messagenum < localPlayer->curstate.messagenum )
			continue;

		// Don't show an icon for dead or spectating players (ie: invisible entities).
		if ( pClient->curstate.effects & EF_NODRAW )
			continue;

		// Don't show an icon for the local player unless we're in thirdperson mode.
		if ( pClient == localPlayer && !cam_thirdperson )
			continue;

		cl_entity_s *pEnt = &m_VoiceHeadModels[iOutModel];
		++iOutModel;

		memset( pEnt, 0, sizeof( *pEnt ) );

		pEnt->curstate.rendermode = kRenderTransAdd;
		pEnt->curstate.renderamt = 255;
		pEnt->baseline.renderamt = 255;
		pEnt->curstate.renderfx = kRenderFxNoDissipation;
		pEnt->curstate.framerate = 1;
		pEnt->curstate.frame = 0;
		pEnt->model = (struct model_s *)gEngfuncs.GetSpritePointer( m_VoiceHeadModel );
		pEnt->angles[0] = pEnt->angles[1] = pEnt->angles[2] = 0;
		pEnt->curstate.scale = 0.5f;

		pEnt->origin[0] = pEnt->origin[1] = 0;
		pEnt->origin[2] = 45;

		VectorAdd( pEnt->origin, pClient->origin, pEnt->origin );

		// Tell the engine.
		gEngfuncs.CL_CreateVisibleEntity( ET_NORMAL, pEnt );
	}
}

void CVoiceStatusHud::UpdateLocation( int entindex, const char *location )
{
	int iClient = entindex - 1;

	if ( iClient < 0 )
		return;

	CVoiceLabel *pLabel = FindVoiceLabel( iClient );
	if ( !pLabel )
		return;

	pLabel->SetLocation( location );

	RepositionLabels();
}

CVoiceLabel *CVoiceStatusHud::FindVoiceLabel( int clientindex )
{
	for ( int i = 0; i < m_Labels.Count(); i++ )
	{
		if ( m_Labels[i]->GetClientIndex() == clientindex )
			return m_Labels[i];
	}

	return NULL;
}

CVoiceLabel *CVoiceStatusHud::GetFreeVoiceLabel()
{
	CVoiceLabel *lab = FindVoiceLabel( -1 );

	if ( !lab )
	{
		lab = new CVoiceLabel();
		m_Labels.AddToTail( lab );
	}

	return lab;
}

void CVoiceStatusHud::RepositionLabels()
{
	// find starting position to draw from, along right-hand side of screen
	int y = ScreenHeight / 2;

	// Reposition active labels.
	for ( int i = 0; i < m_Labels.Count(); i++ )
	{
		CVoiceLabel *pLabel = m_Labels[i];

		int textWide, textTall;
		pLabel->GetContentSize( textWide, textTall );
		pLabel->SetBounds( ScreenWidth - textWide - 8, y ); // if you adjust the x pos also play with VoiceVGUILabel in voice_status_hud.h

		y += textTall + 2;
	}
}

void CVoiceStatusHud::UpdateSpeakerStatus( int entindex, bool bTalking )
{
	if ( entindex == -2 ) // this is the local player
	{
		if ( bTalking )
		{
			// int sizeX, sizeY;
			// IImage *image = m_pLocalPlayerTalkIcon->GetImage();
			int image = m_pLocalPlayerTalkIcon;
			if ( image )
			{
				// image->GetContentSize( sizeX, sizeY );
				m_LocalPlayerTalkIconXSize = (int)gRenderAPI.RenderGetParm( PARM_TEX_WIDTH, image );
				m_LocalPlayerTalkIconYSize = (int)gRenderAPI.RenderGetParm( PARM_TEX_HEIGHT, image );

				// int local_xPos = ScreenWidth - sizeX - 10;
				// int local_yPos = ScreenHeight - m_pHelper->GetAckIconHeight() - sizeY;
				int local_xPos = ScreenWidth - m_LocalPlayerTalkIconXSize - 10;
				int local_yPos = ScreenHeight - m_pHelper->GetAckIconHeight() - m_LocalPlayerTalkIconYSize;
				// m_pLocalPlayerTalkIcon->SetPos( local_xPos, local_yPos );
				// m_pLocalPlayerTalkIcon->SetVisible( true );
				m_LocalPlayerTalkIconXPos = local_xPos;
				m_LocalPlayerTalkIconYPos = local_yPos;
				m_LocalPlayerTalkIconVisible = true;
			}
		}
		else
		{
			// m_pLocalPlayerTalkIcon->SetVisible( false );
			m_LocalPlayerTalkIconVisible = false;
		}
	}
	else // a remote player, draw a label for them
	{
		if ( entindex >= 0 && entindex <= MAX_PLAYERS )
		{
			int iClient = entindex - 1;
			if ( iClient < 0 )
				return;

			CVoiceLabel *pLabel = FindVoiceLabel( iClient );
			if ( bTalking )
			{
				// If we don't have a label for this guy yet, then create one.
				if ( !pLabel )
				{
					if ( pLabel = GetFreeVoiceLabel() )
					{
						// Get the name from the engine.
						hud_player_info_t info;
						memset( &info, 0, sizeof( info ) );
						gEngfuncs.pfnGetPlayerInfo( entindex, &info );

						int color[3];
						m_pHelper->GetPlayerTextColor( entindex, color );

						// pLabel->SetFgColor( Color(255, 255, 255, 255) );
						// pLabel->SetBgColor( Color(color[0], color[1], color[2], 180) );
						pLabel->SetFgColor( RGBA( { 255, 255, 255, 255 } ) );
						pLabel->SetBgColor( RGBA( { (unsigned char)color[0], (unsigned char)color[1], (unsigned char)color[2], 180 } ) );
						pLabel->SetPlayerName( info.name );
						pLabel->SetLocation( m_pHelper->GetPlayerLocation( entindex ) );
						pLabel->SetClientIndex( iClient );
						if ( m_pHelper )
						{
							if ( m_pHelper->CanShowSpeakerLabels() )
							{
								pLabel->SetVisible( true );
							}
						}
						else
						{
							pLabel->SetVisible( true );
						}
					}
				}
			}
			else
			{
				// If we have a label for this guy, kill it.
				if ( pLabel )
				{
					pLabel->SetVisible( false );
					pLabel->SetClientIndex( -1 );
				}
			}
		}
	}

	RepositionLabels();
}

void CVoiceStatusHud::Shutdown( void )
{
	gRenderAPI.GL_FreeTexture( m_pLocalPlayerTalkIcon );
	gRenderAPI.GL_FreeTexture( g_VoiceLabelIcon );
}

int CVoiceStatusHud::Draw( float flTime )
{
	if ( m_LocalPlayerTalkIconVisible && m_pLocalPlayerTalkIcon )
	{
		gRenderAPI.GL_SelectTexture( 0 );
		gRenderAPI.GL_Bind( 0, m_pLocalPlayerTalkIcon );
		gEngfuncs.pTriAPI->RenderMode( kRenderTransTexture );
		gEngfuncs.pTriAPI->Color4f( 1.0f, 1.0f, 1.0f, 1.0f );
		DrawUtils::Draw2DQuad( m_LocalPlayerTalkIconXPos * gHUD.m_flScale,
		                       m_LocalPlayerTalkIconYPos * gHUD.m_flScale,
		                       ( m_LocalPlayerTalkIconXPos + m_LocalPlayerTalkIconXSize ) * gHUD.m_flScale,
		                       ( m_LocalPlayerTalkIconYPos + m_LocalPlayerTalkIconYSize ) * gHUD.m_flScale );
	}

	for ( int i = 0; i < m_Labels.Count(); i++ )
		m_Labels[i]->Draw();

	return 1;
}
```

`pm_shared/pm_debug.cpp`:

```cpp
#include "mathlib.h"
#include "const.h"
#include "usercmd.h"
#include "pm_defs.h"
#include "pm_shared.h"
#include "pm_movevars.h"
#include "pm_debug.h"

#include <string.h>
#undef vec3_t

// Expand debugging BBOX particle hulls by this many units.
#define BOX_GAP 0.0f

int PM_boxpnt[6][4] =
{
	{ 0, 4, 6, 2 }, // +X
	{ 0, 1, 5, 4 }, // +Y
	{ 0, 2, 3, 1 }, // +Z
	{ 7, 5, 1, 3 }, // -X
	{ 7, 3, 2, 6 }, // -Y
	{ 7, 6, 4, 5 }, // -Z
};

void PM_ShowClipBox()
{
#ifdef _DEBUG
	if (!pmove->runfuncs)
		return;

	// More debugging, draw the particle bbox for player and for the entity we are looking directly at.
	// aslo prints entity info to the console overlay.
	if (!pmove->server)
		return;

	// Draw entity in center of view
	// Also draws the normal to the clip plane that intersects our movement ray. Leaves a particle
	// trail at the intersection point.
	PM_ViewEntity();

	// Show our BBOX in particles.
 	//PM_DrawBBox(pmove->player_mins[pmove->usehull], pmove->player_maxs[pmove->usehull], pmove->origin, 132, 0.1);
/*
	{
		int i;
		for (i = 0; i < pmove->numphysent; i++)
		{
			if (pmove->physents[ i ].info >= 1 && pmove->physents[ i ].info <= 4)
			{
			 	PM_DrawBBox(pmove->player_mins[pmove->usehull], pmove->player_maxs[pmove->usehull], pmove->physents[i].origin, 132, 0.1);
			}
		}
	}
*/
#endif // _DEBUG
}

void PM_ParticleLine(vec3_t start, vec3_t end, int pcolor, float life, float vert)
{
	float linestep = 2.0f;
	float curdist;
	float len;
	vec3_t curpos;
	vec3_t diff;
	int i;
	// Determine distance;

	VectorSubtract(end, start, diff);

	len = VectorNormalize(diff);

	curdist = 0;
	while (curdist <= len)
	{
		for (i = 0; i < 3; ++i)
			curpos[i] = start[i] + curdist * diff[i];

		pmove->PM_Particle(curpos, pcolor, life, 0, vert);
		curdist += linestep;
	}
}

void PM_DrawRectangle(vec3_t tl, vec3_t bl, vec3_t tr, vec3_t br, int pcolor, float life)
{
	PM_ParticleLine(tl, bl, pcolor, life, 0);
	PM_ParticleLine(bl, br, pcolor, life, 0);
	PM_ParticleLine(br, tr, pcolor, life, 0);
	PM_ParticleLine(tr, tl, pcolor, life, 0);
}

void PM_DrawPhysEntBBox(int num, int pcolor, float life)
{
	physent_t *pe;
	vec3_t org;
	int j;
	vec3_t tmp;
	vec3_t p[8];
	float gap = BOX_GAP;
	vec3_t modelmins, modelmaxs;

	if (num >= pmove->numphysent || num <= 0)
		return;

	pe = &pmove->physents[num];

	if (pe->model)
	{
		VectorCopy(pe->origin, org);

		pmove->PM_GetModelBounds(pe->model, modelmins, modelmaxs);
		for (j = 0; j < 8; ++j)
		{
			tmp[0] = (j & 1) ? modelmins[0] - gap : modelmaxs[0] + gap;
			tmp[1] = (j & 2) ? modelmins[1] - gap : modelmaxs[1] + gap;
			tmp[2] = (j & 4) ? modelmins[2] - gap : modelmaxs[2] + gap;

			VectorCopy(tmp, p[j]);
		}

		// If the bbox should be rotated, do that
		if (pe->angles[0] || pe->angles[1] || pe->angles[2])
		{
			vec3_t forward, right, up;

			AngleVectorsTranspose(pe->angles, forward, right, up);
			for (j = 0; j < 8; ++j)
			{
				VectorCopy(p[j], tmp);
				p[j][0] = DotProduct(tmp, forward);
				p[j][1] = DotProduct(tmp, right);
				p[j][2] = DotProduct(tmp, up);
			}
		}

		// Offset by entity origin, if any.
		for (j = 0; j < 8; ++j)
			VectorAdd(p[j], org, p[j]);

		for (j = 0; j < 6; ++j)
		{
			PM_DrawRectangle(
				p[PM_boxpnt[j][1]],
				p[PM_boxpnt[j][0]],
				p[PM_boxpnt[j][2]],
				p[PM_boxpnt[j][3]],
				pcolor, life);
		}
	}
	else
	{
		for (j = 0; j < 8; ++j)
		{
			tmp[0] = (j & 1) ? pe->mins[0] : pe->maxs[0];
			tmp[1] = (j & 2) ? pe->mins[1] : pe->maxs[1];
			tmp[2] = (j & 4) ? pe->mins[2] : pe->maxs[2];

			VectorAdd(tmp, pe->origin, tmp);
			VectorCopy(tmp, p[j]);
		}

		for (j = 0; j < 6; ++j)
		{
			PM_DrawRectangle(
				p[PM_boxpnt[j][1]],
				p[PM_boxpnt[j][0]],
				p[PM_boxpnt[j][2]],
				p[PM_boxpnt[j][3]],
				pcolor, life);
		}
	}
}

void PM_DrawBBox(vec3_t mins, vec3_t maxs, vec3_t origin, int pcolor, float life)
{
	int j;

	vec3_t tmp;
	vec3_t p[8];
	float gap = BOX_GAP;

	for (j = 0; j < 8; ++j)
	{
		tmp[0] = (j & 1) ? mins[0] - gap : maxs[0] + gap;
		tmp[1] = (j & 2) ? mins[1] - gap : maxs[1] + gap;
		tmp[2] = (j & 4) ? mins[2] - gap : maxs[2] + gap;

		VectorAdd(tmp, origin, tmp);
		VectorCopy(tmp, p[j]);
	}

	for (j = 0; j < 6; ++j)
	{
		PM_DrawRectangle(
			p[PM_boxpnt[j][1]],
			p[PM_boxpnt[j][0]],
			p[PM_boxpnt[j][2]],
			p[PM_boxpnt[j][3]],
			pcolor, life);
	}
}

// Shows a particle trail from player to entity in crosshair.
// Shows particles at that entities bbox
// Tries to shoot a ray out by about 128 units.

void PM_ViewEntity()
{
	vec3_t forward, right, up;
	float raydist = 256.0f;
	vec3_t origin;
	vec3_t end;
	int i;
	pmtrace_t trace;
	int pcolor = 77;
	float fup;

#if 0
	if (!pm_showclip.value)
		return;
#endif

	// Determine movement angles
	AngleVectors(pmove->angles, forward, right, up);

	VectorCopy(pmove->origin, origin);

	fup = 0.5 * (pmove->player_mins[pmove->usehull][2] + pmove->player_maxs[pmove->usehull][2]);
	fup += pmove->view_ofs[2];
	fup -= 4;

	for (i = 0; i < 3; i++)
	{
		end[i] = origin[i] + raydist * forward[i];
	}

	trace = pmove->PM_PlayerTrace(origin, end, PM_STUDIO_BOX, -1);

	// Not the world
	if (trace.ent > 0)
	{
		pcolor = 111;
		// Draw the hull or bbox.
		PM_DrawPhysEntBBox(trace.ent, pcolor, 0.3f);
	}
}

```

`pm_shared/pm_debug.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_DEBUG_H
#define PM_DEBUG_H
#ifdef _WIN32
#pragma once
#endif

void PM_ShowClipBox();
void PM_ParticleLine(vec3_t start, vec3_t end, int pcolor, float life, float vert);
void PM_DrawRectangle(vec3_t tl, vec3_t bl, vec3_t tr, vec3_t br, int pcolor, float life);
void PM_DrawPhysEntBBox(int num, int pcolor, float life);
void PM_DrawBBox(vec3_t mins, vec3_t maxs, vec3_t origin, int pcolor, float life);
void PM_ViewEntity();

#endif // PM_DEBUG_H

```

`pm_shared/pm_defs.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_DEFS_H
#define PM_DEFS_H
#ifdef _WIN32
#pragma once
#endif

#include "pm_info.h"
#include "pmtrace.h"

#ifndef USERCMD_H
#include "usercmd.h"
#endif

#include "const.h"

#define MAX_PHYSENTS 600 		  		// Must have room for all entities in the world.
#define MAX_MOVEENTS 64
#define MAX_CLIP_PLANES	5

#define PM_NORMAL				0x00000000
#define PM_STUDIO_IGNORE		0x00000001	// Skip studio models
#define PM_STUDIO_BOX			0x00000002	// Use boxes for non-complex studio models (even in traceline)
#define PM_GLASS_IGNORE			0x00000004	// Ignore entities with non-normal rendermode
#define PM_WORLD_ONLY			0x00000008	// Only trace against the world

#define PM_TRACELINE_PHYSENTSONLY	0
#define PM_TRACELINE_ANYVISIBLE		1

typedef struct physent_s
{
	char name[32];					// Name of model, or "player" or "world".
	int player;
	vec3_t origin;					// Model's origin in world coordinates.
	struct model_s *model;			// only for bsp models
	struct model_s *studiomodel;	// SOLID_BBOX, but studio clip intersections.
	vec3_t mins, maxs;				// only for non-bsp models
	int info;						// For client or server to use to identify (index into edicts or cl_entities)
	vec3_t angles;					// rotated entities need this info for hull testing to work.

	int solid;						// Triggers and func_door type WATER brushes are SOLID_NOT
	int skin;						// BSP Contents for such things like fun_door water brushes.
	int rendermode;					// So we can ignore glass

	float frame;
	int sequence;
	byte controller[4];
	byte blending[2];

	int movetype;
	int takedamage;
	int blooddecal;
	int team;
	int classnumber;

	int iuser1;
	int iuser2;
	int iuser3;
	int iuser4;
	float fuser1;
	float fuser2;
	float fuser3;
	float fuser4;
	vec3_t vuser1;
	vec3_t vuser2;
	vec3_t vuser3;
	vec3_t vuser4;

} physent_t;

typedef struct playermove_s
{
	int player_index;				// So we don't try to run the PM_CheckStuck nudging too quickly.
	qboolean server;				// For debugging, are we running physics code on server side?
	qboolean multiplayer;			// 1 == multiplayer server
	float time;						// realtime on host, for reckoning duck timing
	float frametime;				// Duration of this frame
	vec3_t forward, right, up;		// Vectors for angles
	vec3_t origin;					// Movement origin.
	vec3_t angles;					// Movement view angles.
	vec3_t oldangles;				// Angles before movement view angles were looked at.
	vec3_t velocity;				// Current movement direction.
	vec3_t movedir;					// For waterjumping, a forced forward velocity so we can fly over lip of ledge.
	vec3_t basevelocity;			// Velocity of the conveyor we are standing, e.g.
	vec3_t view_ofs;				// For ducking/dead
									// Our eye position.
	float flDuckTime;				// Time we started duck
	qboolean bInDuck;				// In process of ducking or ducked already?
	int flTimeStepSound;			// For walking/falling
									// Next time we can play a step sound
	int iStepLeft;
	float flFallVelocity;
	vec3_t punchangle;
	float flSwimTime;
	float flNextPrimaryAttack;
	int effects;					// MUZZLE FLASH, e.g.
	int flags;						// FL_ONGROUND, FL_DUCKING, etc.
	int usehull;					// 0 = regular player hull, 1 = ducked player hull, 2 = point hull
	float gravity;					// Our current gravity and friction.
	float friction;
	int oldbuttons;					// Buttons last usercmd
	float waterjumptime;			// Amount of time left in jumping out of water cycle.
	qboolean dead;					// Are we a dead player?
	int deadflag;
	int spectator;					// Should we use spectator physics model?
	int movetype;					// Our movement type, NOCLIP, WALK, FLY
	int onground;					// -1 = in air, else pmove entity number
	int waterlevel;
	int watertype;
	int oldwaterlevel;
	char sztexturename[256];
	char chtexturetype;
	float maxspeed;
	float clientmaxspeed;
	int iuser1;
	int iuser2;
	int iuser3;
	int iuser4;
	float fuser1;
	float fuser2;
	float fuser3;
	float fuser4;
	vec3_t vuser1;
	vec3_t vuser2;
	vec3_t vuser3;
	vec3_t vuser4;
	int numphysent;						// world state
										// Number of entities to clip against.
	physent_t physents[MAX_PHYSENTS];
	int nummoveent;						// Number of momvement entities (ladders)
	physent_t moveents[MAX_MOVEENTS];	// just a list of ladders
	int numvisent;						// All things being rendered, for tracing against things you don't actually collide with
	physent_t visents[MAX_PHYSENTS];
	usercmd_t cmd;						// input to run through physics.
	int numtouch;						// Trace results for objects we collided with.
	pmtrace_t touchindex[MAX_PHYSENTS];
	char physinfo[MAX_PHYSINFO_STRING];	// Physics info string
	struct movevars_s *movevars;
	vec_t player_mins[4][3];
	vec_t player_maxs[4][3];

	const char *(*PM_Info_ValueForKey)(const char *s, const char *key);
	void (*PM_Particle)(float *origin, int color, float life, int zpos, int zvel);
	int (*PM_TestPlayerPosition)(float *pos, pmtrace_t *ptrace);
	void (*Con_NPrintf)(int idx, char *fmt, ...);
	void (*Con_DPrintf)(const char *fmt, ...);
	void (*Con_Printf)(const char *fmt, ...);
	double (*Sys_FloatTime)();
	void (*PM_StuckTouch)(int hitent, pmtrace_t *ptraceresult);
	int (*PM_PointContents)(float *p, int *truecontents);
	int (*PM_TruePointContents)(float *p);
	int (*PM_HullPointContents)(struct hull_s *hull, int num, float *p);
	pmtrace_t (*PM_PlayerTrace)(float *start, float *end, int traceFlags, int ignore_pe);
	struct pmtrace_s *(*PM_TraceLine)(float *start, float *end, int flags, int usehulll, int ignore_pe);
	int (*RandomLong)(int lLow, int lHigh);
	float (*RandomFloat)(float flLow, float flHigh);
	int (*PM_GetModelType)(struct model_s *mod);
	void (*PM_GetModelBounds)(struct model_s *mod, float *mins, float *maxs);
	void *(*PM_HullForBsp)(physent_t *pe, float *offset);
	float (*PM_TraceModel)(physent_t *pEnt, float *start, float *end, trace_t *trace);
	int (*COM_FileSize)(char *filename);
	byte *(*COM_LoadFile)(const char *path, int usehunk, int *pLength);
	void (*COM_FreeFile)(void *buffer);
	char *(*memfgets)(byte *pMemFile, int fileSize, int *pFilePos, char *pBuffer, int bufferSize);
	qboolean runfuncs;
	void (*PM_PlaySound)(int channel, const char *sample, float volume, float attenuation, int fFlags, int pitch);
	const char *(*PM_TraceTexture)(int ground, float *vstart, float *vend);
	void (*PM_PlaybackEventFull)(int flags, int clientindex, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2);

	pmtrace_t (*PM_PlayerTraceEx)(float *start, float *end, int traceFlags, int (*pfnIgnore)(physent_t *pe));
	int (*PM_TestPlayerPositionEx)(float *pos, pmtrace_t *ptrace, int (*pfnIgnore)(physent_t *pe));
	struct pmtrace_s *(*PM_TraceLineEx)(float *start, float *end, int flags, int usehulll, int (*pfnIgnore)(physent_t *pe));

} playermove_t;

#endif // PM_DEFS_H

```

`pm_shared/pm_info.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_INFO_H
#define PM_INFO_H
#ifdef _WIN32
#pragma once
#endif

#define MAX_PHYSINFO_STRING 256

#endif // PM_INFO_H

```

`pm_shared/pm_materials.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_MATERIALS_H
#define PM_MATERIALS_H
#ifdef _WIN32
#pragma once
#endif

#define CTEXTURESMAX		1024	// max number of textures loaded
#define CBTEXTURENAMEMAX	17	// only load first n chars of name

#define CHAR_TEX_CONCRETE	'C'	// texture types
#define CHAR_TEX_METAL		'M'
#define CHAR_TEX_DIRT		'D'
#define CHAR_TEX_VENT		'V'
#define CHAR_TEX_GRATE		'G'
#define CHAR_TEX_TILE		'T'
#define CHAR_TEX_SLOSH		'S'
#define CHAR_TEX_WOOD		'W'
#define CHAR_TEX_COMPUTER	'P'
#define CHAR_TEX_GRASS		'X'
#define CHAR_TEX_GLASS		'Y'
#define CHAR_TEX_FLESH		'F'
#define CHAR_TEX_SNOW		'N'

#endif // PM_MATERIALS_H

```

`pm_shared/pm_math.cpp`:

```cpp
#include "mathlib.h"
#include "const.h"
#include <math.h>
/*
* Globals initialization
*/
float vec3_origin[] = {0, 0, 0};
int nanmask = 255<<23;

float anglemod(float a)
{
	a = (360.0 / 65536) * ((int)(a  *(65536 / 360.0)) & 65535);
	return a;
}

void AngleVectors(const vec_t *angles, vec_t *forward, vec_t *right, vec_t *up)
{
	float sr, sp, sy, cr, cp;

	float cy;
	float angle;

	angle = (float)(angles[YAW] * (M_PI * 2 / 360));
	sy = sin(angle);
	cy = cos(angle);

	angle = (float)(angles[PITCH] * (M_PI * 2 / 360));
	sp = sin(angle);
	cp = cos(angle);

	angle = (float)(angles[ROLL] * (M_PI * 2 / 360));
	sr = sin(angle);
	cr = cos(angle);

	if (forward)
	{
		forward[0] = cp * cy;
		forward[1] = cp * sy;
		forward[2] = -sp;
	}
	if (right)
	{
		right[0] = (-1 * sr * sp * cy + -1 * cr * -sy);
		right[1] = (-1 * sr * sp * sy + -1 * cr * cy);
		right[2] = -1 * sr * cp;
	}
	if (up)
	{
		up[0] = (cr * sp * cy + -sr * -sy);
		up[1] = (cr * sp * sy + -sr * cy);
		up[2] = cr * cp;
	}
}

void AngleVectorsTranspose(const vec_t *angles, vec_t *forward, vec_t *right, vec_t *up)
{
	float angle;
	float sr, sp, sy, cr, cp, cy;

	angle = angles[YAW] * (M_PI * 2 / 360);
	sy = sin(angle);
	cy = cos(angle);
	angle = angles[PITCH] * (M_PI * 2 / 360);
	sp = sin(angle);
	cp = cos(angle);
	angle = angles[ROLL] * (M_PI * 2 / 360);
	sr = sin(angle);
	cr = cos(angle);

	if (forward)
	{
		forward[0] = cp * cy;
		forward[1] = (sr * sp * cy + cr * -sy);
		forward[2] = (cr * sp * cy + -sr * -sy);
	}
	if (right)
	{
		right[0] = cp * sy;
		right[1] = (sr * sp * sy + cr * cy);
		right[2] = (cr * sp * sy + -sr * cy);
	}
	if (up)
	{
		up[0] = -sp;
		up[1] = sr * cp;
		up[2] = cr * cp;
	}
}

void AngleMatrix(const vec_t *angles, float (*matrix)[4])
{
	float angle;
	float  sr, sp, sy, cr, cp, cy;

	angle = (float)(angles[ROLL] * (M_PI * 2 / 360));
	sy = sin(angle);
	cy = cos(angle);

	angle = (float)(angles[YAW] * (M_PI * 2 / 360));
	sp = sin(angle);
	cp = cos(angle);

	angle = (float)(angles[PITCH] * (M_PI * 2 / 360));
	sr = sin(angle);
	cr = cos(angle);

	matrix[0][0] = cr * cp;
	matrix[1][0] = cr * sp;
	matrix[2][0] = -sr;

	matrix[0][1] = (sy * sr) * cp - cy * sp;
	matrix[1][1] = (sy * sr) * sp + cy * cp;
	matrix[2][1] = sy * cr;

	matrix[0][2] = (cy * sr) * cp + sy * sp;
	matrix[1][2] = (cy * sr) * sp - sy * cp;
	matrix[2][2] = cy * cr;

	matrix[0][3] = 0.0f;
	matrix[1][3] = 0.0f;
	matrix[2][3] = 0.0f;
}

void AngleIMatrix(const vec_t *angles, float (*matrix)[4])
{
	float angle;
	float sr, sp, sy, cr, cp, cy;

	angle = angles[YAW] * (M_PI * 2 / 360);
	sy = sin(angle);
	cy = cos(angle);
	angle = angles[PITCH] * (M_PI * 2 / 360);
	sp = sin(angle);
	cp = cos(angle);
	angle = angles[ROLL] * (M_PI * 2 / 360);
	sr = sin(angle);
	cr = cos(angle);

	// matrix = (YAW * PITCH) * ROLL
	matrix[0][0] = cp * cy;
	matrix[0][1] = cp * sy;
	matrix[0][2] = -sp;
	matrix[1][0] = sr * sp * cy + cr * -sy;
	matrix[1][1] = sr * sp * sy + cr * cy;
	matrix[1][2] = sr * cp;
	matrix[2][0] = (cr * sp * cy + -sr * -sy);
	matrix[2][1] = (cr * sp * sy + -sr * cy);
	matrix[2][2] = cr * cp;
	matrix[0][3] = 0.0;
	matrix[1][3] = 0.0;
	matrix[2][3] = 0.0;
}

void NormalizeAngles(float *angles)
{
	int i;
	// Normalize angles
	for (i = 0; i < 3; ++i)
	{
		if (angles[i] > 180.0)
		{
			angles[i] -= 360.0;
		}
		else if (angles[i] < -180.0)
		{
			angles[i] += 360.0;
		}
	}
}

// Interpolate Euler angles.
// FIXME:  Use Quaternions to avoid discontinuities
// Frac is 0.0 to 1.0 (i.e., should probably be clamped, but doesn't have to be)

void InterpolateAngles(float *start, float *end, float *output, float frac)
{
	int i;
	float ang1, ang2;
	float d;

	NormalizeAngles(start);
	NormalizeAngles(end);

	for (i = 0; i < 3; ++i)
	{
		ang1 = start[i];
		ang2 = end[i];

		d = ang2 - ang1;
		if (d > 180)
		{
			d -= 360;
		}
		else if (d < -180)
		{
			d += 360;
		}

		output[i] = ang1 + d * frac;
	}

	NormalizeAngles(output);
}

float AngleBetweenVectors(const vec_t *v1, const vec_t *v2)
{
	float angle;
	float l1 = Length(v1);
	float l2 = Length(v2);

	if (!l1 || !l2)
		return 0.0f;

	angle = acos(DotProduct(v1, v2)) / (l1 * l2);
	angle = (angle * 180.0f) / M_PI;

	return angle;
}

void VectorTransform(const vec_t *in1, float (*in2)[4], vec_t *out)
{
	out[0] = DotProduct(in1, in2[0]) + in2[0][3];
	out[1] = DotProduct(in1, in2[1]) + in2[1][3];
	out[2] = DotProduct(in1, in2[2]) + in2[2][3];
}

int VectorCompare(const vec_t *v1, const vec_t *v2)
{
	int i;
	for (i = 0; i < 3; ++i)
	{
		if (v1[i] != v2[i])
			return 0;
	}

	return 1;
}

void VectorMA(const vec_t *veca, float scale, const vec_t *vecb, vec_t *vecc)
{
	vecc[0] = veca[0] + scale * vecb[0];
	vecc[1] = veca[1] + scale * vecb[1];
	vecc[2] = veca[2] + scale * vecb[2];
}

float _DotProduct(const vec_t *v1, const vec_t *v2)
{
	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
}

void _VectorSubtract(vec_t *veca, vec_t *vecb, vec_t *out)
{
	out[0] = veca[0] - vecb[0];
	out[1] = veca[1] - vecb[1];
	out[2] = veca[2] - vecb[2];
}

void _VectorAdd(vec_t *veca, vec_t *vecb, vec_t *out)
{
	out[0] = veca[0] + vecb[0];
	out[1] = veca[1] + vecb[1];
	out[2] = veca[2] + vecb[2];
}

void _VectorCopy(vec_t *in, vec_t *out)
{
	out[0] = in[0];
	out[1] = in[1];
	out[2] = in[2];
}

void CrossProduct(const vec_t *v1, const vec_t *v2, vec_t *cross)
{
	cross[0] = v1[1] * v2[2] - v1[2] * v2[1];
	cross[1] = v1[2] * v2[0] - v1[0] * v2[2];
	cross[2] = v1[0] * v2[1] - v1[1] * v2[0];
}

float Length(const vec_t *v)
{
	int i;
	float length = 0.0f;

	for (i = 0; i < 3; ++i)
		length += v[i] * v[i];

	return sqrt(length);
}

float Distance(const vec_t *v1, const vec_t *v2)
{
	vec_t d[3];
	VectorSubtract(v2, v1, d);
	return Length(d);
}

float VectorNormalize(vec_t *v)
{
	float length;
	float ilength;

	length = sqrt((float)(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]));

	if (length)
	{
		ilength = 1.0 / length;

		v[0] *= ilength;
		v[1] *= ilength;
		v[2] *= ilength;
	}

	return length;
}

void VectorInverse(vec_t *v)
{
	v[0] = -v[0];
	v[1] = -v[1];
	v[2] = -v[2];
}

void VectorScale(const vec_t *in, vec_t scale, vec_t *out)
{
	out[0] = scale * in[0];
	out[1] = scale * in[1];
	out[2] = scale * in[2];
}

int Q_log2(int val)
{
	int answer = 0;
	while (val >>= 1)
		++answer;

	return answer;
}

void VectorMatrix(vec_t *forward, vec_t *right, vec_t *up)
{
	vec_t tmp[3];

	if (forward[0] == 0 && forward[1] == 0)
	{
		right[0] = 1;
		right[1] = 0;
		right[2] = 0;

		up[0] = -forward[2];
		up[1] = 0;
		up[2] = 0;
		return;
	}

	tmp[0] = 0;
	tmp[1] = 0;
	tmp[2] = 1.0f;

	CrossProduct(forward, tmp, right);
	VectorNormalize(right);
	CrossProduct(right, forward, up);
	VectorNormalize(up);
}

void VectorAngles(const vec_t *forward, vec_t *angles)
{
	float tmp, yaw, pitch;

	if (forward[1] == 0 && forward[0] == 0)
	{
		yaw = 0;
		if (forward[2] > 0)
			pitch = 90;
		else
			pitch = 270;
	}
	else
	{
		yaw = (atan2(forward[1], forward[0]) * 180 / M_PI);
		if (yaw < 0)
			yaw += 360;

		tmp = sqrt (forward[0] * forward[0] + forward[1] * forward[1]);
		pitch = (atan2(forward[2], tmp) * 180 / M_PI);
		if (pitch < 0)
			pitch += 360;
	}

	angles[0] = pitch;
	angles[1] = yaw;
	angles[2] = 0;
}

```

`pm_shared/pm_math.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_MATH_H
#define PM_MATH_H
#ifdef _WIN32
#pragma once
#endif

#define PITCH	0	// up/down
#define YAW	1	// left/right
#define ROLL	2	// fall over

extern float vec3_origin[3];
extern int nanmask;

#define IS_NAN(x)	((*reinterpret_cast<int *>(&(x)) & nanmask) == nanmask)

float anglemod(float a);
void  AngleVectors(const vec_t *angles, vec_t *forward, vec_t *right, vec_t *up);
void  AngleVectorsTranspose(const vec_t *angles, vec_t *forward, vec_t *right, vec_t *up);
void  AngleMatrix(const vec_t *angles, float (*matrix)[4]);
void  AngleIMatrix(const vec_t *angles, float (*matrix)[4]);
void  NormalizeAngles(float *angles);
void  InterpolateAngles(float *start, float *end, float *output, float frac);
float AngleBetweenVectors(const vec_t *v1, const vec_t *v2);
void VectorTransform(const vec_t *in1, float (*in2)[4], vec_t *out);
int   VectorCompare(const vec_t *v1, const vec_t *v2);
void  VectorMA(const vec_t *veca, float scale, const vec_t *vecb, vec_t *vecc);

float _DotProduct(const vec_t *v1, const vec_t *v2);
void  _VectorSubtract(vec_t *veca, vec_t *vecb, vec_t *out);
void  _VectorAdd(vec_t *veca, vec_t *vecb, vec_t *out);
void  _VectorCopy(vec_t *in, vec_t *out);
void  CrossProduct(const vec_t *v1, const vec_t *v2, vec_t *cross);

float Length(const vec_t *v);
float Distance(const vec_t *v1, const vec_t *v2);
float VectorNormalize(vec_t *v);

void  VectorInverse(vec_t *v);
void  VectorScale(const vec_t *in, vec_t scale, vec_t *out);
int   Q_log2(int val);
void  VectorMatrix(vec_t *forward, vec_t *right, vec_t *up);
void  VectorAngles(const vec_t *forward, vec_t *angles);

#endif // PM_MATH_H

```

`pm_shared/pm_movevars.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_MOVEVARS_H
#define PM_MOVEVARS_H
#ifdef _WIN32
#pragma once
#endif

typedef struct movevars_s
{
	float gravity;			// Gravity for map
	float stopspeed;		// Deceleration when not moving
	float maxspeed;			// Max allowed speed
	float spectatormaxspeed;
	float accelerate;		// Acceleration factor
	float airaccelerate;		// Same for when in open air
	float wateraccelerate;		// Same for when in water
	float friction;
	float edgefriction;		// Extra friction near dropofs
	float waterfriction;		// Less in water
	float entgravity;		// 1.0
	float bounce;			// Wall bounce value. 1.0
	float stepsize;			// sv_stepsize;
	float maxvelocity;		// maximum server velocity.
	float zmax;			// Max z-buffer range (for GL)
	float waveHeight;		// Water wave height (for GL)
	qboolean footsteps;		// Play footstep sounds
	char skyName[32];		// Name of the sky map
	float rollangle;
	float rollspeed;
	float skycolor_r;		// Sky color
	float skycolor_g;
	float skycolor_b;
	float skyvec_x;			// Sky vector
	float skyvec_y;
	float skyvec_z;

} movevars_t;

#endif // PM_MOVEVARS_H

```

`pm_shared/pm_shared.cpp`:

```cpp
#include <assert.h>
#include "mathlib.h"
#include "const.h"
#include "usercmd.h"
#include "pm_defs.h"
#include "pm_shared.h"
#include "pm_movevars.h"
#include "pm_materials.h"
#include "pm_debug.h"
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "com_model.h"

#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif

#ifndef max
#define max(a, b) ((a) > (b) ? (a) : (b))
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

const int MAX_TEXTURES           = 1024; // max number of textures loaded
const int MAX_TEXTURENAME_LENGHT = 17;   // only load first n chars of name
const float HalfHumanHeight = 36.0f;

#ifdef CLIENT_DLL
	int iJumpSpectator;
	float vJumpOrigin[3];
	float vJumpAngles[3];
#endif

#define REGAMEDLL_ADD
#define REGAMEDLL_FIXES

/*
* Globals initialization
*/
int pm_shared_initialized = FALSE;

vec3_t rgv3tStuckTable[54];
int rgStuckLast[MAX_CLIENTS][2];

int pm_gcTextures = 0;
char pm_grgszTextureName[MAX_TEXTURES][MAX_TEXTURENAME_LENGHT];
char pm_grgchTextureType[MAX_TEXTURES];

playermove_t *pmove = nullptr;
int g_onladder = FALSE;

void PM_SwapTextures(int i, int j)
{
	char chTemp;
	char szTemp[MAX_TEXTURENAME_LENGHT];

	strcpy(szTemp, pm_grgszTextureName[i]);
	chTemp = pm_grgchTextureType[i];

	strcpy(pm_grgszTextureName[i], pm_grgszTextureName[j]);
	pm_grgchTextureType[i] = pm_grgchTextureType[j];

	strcpy(pm_grgszTextureName[j], szTemp);
	pm_grgchTextureType[j] = chTemp;
}

qboolean PM_IsThereGrassTexture()
{
	for (int i = 0; i < pm_gcTextures; i++)
	{
		if (pm_grgchTextureType[i] == CHAR_TEX_GRASS)
			return TRUE;
	}

	return FALSE;
}

void PM_SortTextures()
{
	// Bubble sort, yuck, but this only occurs at startup and it's only 512 elements...
	int i, j;
	for (i = 0; i < pm_gcTextures; i++)
	{
		for (j = i + 1; j < pm_gcTextures; j++)
		{
			if (stricmp(pm_grgszTextureName[i], pm_grgszTextureName[j]) > 0)
			{
				// Swap
				PM_SwapTextures(i, j);
			}
		}
	}
}

void PM_InitTextureTypes()
{
	char buffer[512];
	int i, j;
	byte *pMemFile;
	int fileSize, filePos = 0;
	static bool bTextureTypeInit = false;

	if (bTextureTypeInit)
		return;

	memset(&(pm_grgszTextureName[0][0]), 0, sizeof(pm_grgszTextureName));
	memset(pm_grgchTextureType, 0, sizeof(pm_grgchTextureType));

	pm_gcTextures = 0;
	memset(buffer, 0, sizeof(buffer));

	pMemFile = pmove->COM_LoadFile("sound/materials.txt", 5, &fileSize);
	if (!pMemFile)
		return;

	// for each line in the file...
	while (pmove->memfgets(pMemFile, fileSize, &filePos, buffer, sizeof(buffer) - 1) && (pm_gcTextures < MAX_TEXTURES))
	{
		// skip whitespace
		i = 0;
		while (buffer[i] && isspace(buffer[i]))
			i++;

		if (!buffer[i])
			continue;

		// skip comment lines
		if (buffer[i] == '/' || !isalpha(buffer[i]))
			continue;

		// get texture type
		pm_grgchTextureType[pm_gcTextures] = toupper(buffer[i++]);

		// skip whitespace
		while (buffer[i] && isspace(buffer[i]))
			i++;

		if (!buffer[i])
			continue;

		// get sentence name
		j = i;
		while (buffer[j] && !isspace(buffer[j]))
			j++;

		if (!buffer[j])
			continue;

		// null-terminate name and save in sentences array
		j = min(j, MAX_TEXTURENAME_LENGHT - 1 + i);
		buffer[j] = '\0';

		strcpy(&(pm_grgszTextureName[pm_gcTextures++][0]), &(buffer[i]));
	}

	// Must use engine to free since we are in a .dll
	pmove->COM_FreeFile(pMemFile);

	PM_SortTextures();
	bTextureTypeInit = true;
}

char PM_FindTextureType(char *name)
{
	int left, right, pivot;
	int val;
#if 0 // Velaron: TODO commented out until the issue is resolved
	assert(pm_shared_initialized);
#endif
	left = 0;
	right = pm_gcTextures - 1;

	while (left <= right)
	{
		pivot = (left + right) / 2;

		val = strnicmp(name, pm_grgszTextureName[pivot], MAX_TEXTURENAME_LENGHT - 1);

		if (val == 0)
		{
			return pm_grgchTextureType[pivot];
		}
		else if (val > 0)
		{
			left = pivot + 1;
		}
		else if (val < 0)
		{
			right = pivot - 1;
		}
	}

	return CHAR_TEX_CONCRETE;
}

void PM_PlayStepSound(int step, float fvol)
{
	static int iSkipStep = 0;
	int irand;

	pmove->iStepLeft = !pmove->iStepLeft;

	if (!pmove->runfuncs)
	{
		return;
	}

	irand = pmove->RandomLong(0, 1) + (pmove->iStepLeft * 2);

	// FIXME mp_footsteps needs to be a movevar
	if (pmove->multiplayer && !pmove->movevars->footsteps)
		return;

	// irand - 0,1 for right foot, 2,3 for left foot
	// used to alternate left and right foot
	// FIXME, move to player state
	switch (step)
	{
	default:
	case STEP_CONCRETE:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_step1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_step3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_step2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_step4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_METAL:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_metal1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_metal3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_metal2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_metal4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_DIRT:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_dirt1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_dirt3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_dirt2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_dirt4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_VENT:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_duct1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_duct3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_duct2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_duct4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_GRATE:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_grate1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_grate3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_grate2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_grate4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_TILE:
		if (!pmove->RandomLong(0, 4))
			irand = 4;

		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_tile1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_tile3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_tile2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_tile4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 4: pmove->PM_PlaySound(CHAN_BODY, "player/pl_tile5.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_SLOSH:
		switch (irand)
		{
			// right foot
			case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_slosh1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
			case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_slosh3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
			// left foot
			case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_slosh2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
			case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_slosh4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_WADE:
		if (iSkipStep == 0)
		{
			iSkipStep++;
			break;
		}

		if (iSkipStep++ == 3)
		{
			iSkipStep = 0;
		}

		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}

		break;
	case STEP_LADDER:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_ladder1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_ladder3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_ladder2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_ladder4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_SNOW:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_snow1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_snow3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_snow2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_snow4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	}
}

int PM_MapTextureTypeStepType(char chTextureType)
{
	switch (chTextureType)
	{
	default:
	case CHAR_TEX_CONCRETE: return STEP_CONCRETE;
	case CHAR_TEX_METAL:    return STEP_METAL;
	case CHAR_TEX_DIRT:     return STEP_DIRT;
	case CHAR_TEX_VENT:     return STEP_VENT;
	case CHAR_TEX_GRATE:    return STEP_GRATE;
	case CHAR_TEX_TILE:     return STEP_TILE;
	case CHAR_TEX_SLOSH:    return STEP_SLOSH;
	case CHAR_TEX_SNOW:     return STEP_SNOW;
	}
}

void PM_CatagorizeTextureType()
{
	vec3_t start, end;
	const char *pTextureName;

	VectorCopy(pmove->origin, start);
	VectorCopy(pmove->origin, end);

	// Straight down
	end[2] -= 64.0f;

	// Fill in default values, just in case.
	pmove->sztexturename[0] = '\0';
	pmove->chtexturetype = CHAR_TEX_CONCRETE;

	pTextureName = pmove->PM_TraceTexture(pmove->onground, start, end);

	if (!pTextureName)
		return;

	// strip leading '-0' or '+0~' or '{' or '!'
	if (*pTextureName == '-' || *pTextureName == '+')
		pTextureName += 2;

	if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')
		pTextureName++;

	strcpy(pmove->sztexturename, pTextureName);
	pmove->sztexturename[MAX_TEXTURENAME_LENGHT - 1] = '\0';

	// get texture type
	pmove->chtexturetype = PM_FindTextureType(pmove->sztexturename);
}

void PM_UpdateStepSound()
{
	float fvol;
	vec3_t knee;
	vec3_t feet;
	vec3_t center;
	float height;
	float speed;
	int fLadder;
	int step;
	int onground;

	if (pmove->flTimeStepSound > 0)
		return;

	if (pmove->flags & FL_FROZEN)
		return;

	speed = Length(pmove->velocity);

	if (speed <= 150.0)
	{
		pmove->flTimeStepSound = 400;
		return;
	}

	// determine if we are on a ladder
	fLadder = (pmove->movetype == MOVETYPE_FLY);

	// determine if we are not in air
	onground = (pmove->onground != -1);

	// If we're on a ladder or on the ground play step sound.
	if (fLadder || onground)
	{
		PM_CatagorizeTextureType();

		VectorCopy(pmove->origin, center);
		VectorCopy(pmove->origin, knee);
		VectorCopy(pmove->origin, feet);

		height = pmove->player_maxs[pmove->usehull][2] - pmove->player_mins[pmove->usehull][2];

		knee[2] = pmove->origin[2] - 0.3 * height;
		feet[2] = pmove->origin[2] - 0.5 * height;

		// find out what we're stepping in or on...
		if (fLadder)
		{
			step = STEP_LADDER;
			fvol = 0.35;
			pmove->flTimeStepSound = 350;
		}
		else if (pmove->PM_PointContents(knee, nullptr) == CONTENTS_WATER)
		{
			step = STEP_WADE;
			fvol = 0.65;
			pmove->flTimeStepSound = 600;
		}
		else if (pmove->PM_PointContents(feet, nullptr) == CONTENTS_WATER)
		{
			step = STEP_SLOSH;
			fvol = 0.5;
			pmove->flTimeStepSound = 300;
		}
		else
		{
			// find texture under player, if different from current texture,
			// get material type
			step = PM_MapTextureTypeStepType(pmove->chtexturetype);

			switch (pmove->chtexturetype)
			{
			default:
			case CHAR_TEX_CONCRETE:
				fvol = 0.5;
				pmove->flTimeStepSound = 300;
				break;
			case CHAR_TEX_METAL:
				fvol = 0.5;
				pmove->flTimeStepSound = 300;
				break;
			case CHAR_TEX_DIRT:
				fvol = 0.55;
				pmove->flTimeStepSound = 300;
				break;
			case CHAR_TEX_VENT:
				fvol = 0.7;
				pmove->flTimeStepSound = 300;
				break;
			case CHAR_TEX_GRATE:
				fvol = 0.5;
				pmove->flTimeStepSound = 300;
				break;
			case CHAR_TEX_TILE:
				fvol = 0.5;
				pmove->flTimeStepSound = 300;
				break;
			case CHAR_TEX_SLOSH:
				fvol = 0.5;
				pmove->flTimeStepSound = 300;
				break;
			}
		}

		if ((pmove->flags & FL_DUCKING) || fLadder)
		{
			// slower step time if ducking
			pmove->flTimeStepSound += 100;

			// play the sound
			// 35% volume if ducking
			if ((pmove->flags & FL_DUCKING) && pmove->flDuckTime < 950.0)
			{
				fvol *= 0.35;
			}
		}

		PM_PlayStepSound(step, fvol);
	}
}

// Add's the trace result to touch list, if contact is not already in list.
qboolean PM_AddToTouched(pmtrace_t tr, vec_t *impactvelocity)
{
	int i;
	for (i = 0; i < pmove->numtouch; i++)
	{
		if (pmove->touchindex[i].ent == tr.ent)
			break;
	}

	// Already in list.
	if (i != pmove->numtouch)
	{
		return FALSE;
	}

	VectorCopy(impactvelocity, tr.deltavelocity);

	if (pmove->numtouch >= MAX_PHYSENTS)
	{
		pmove->Con_DPrintf("Too many entities were touched!\n");
	}

	pmove->touchindex[pmove->numtouch++] = tr;
	return TRUE;
}

void PM_CheckVelocity()
{
	int i;

	// bound velocity
	for (i = 0; i < 3; i++)
	{
		// See if it's bogus.
		if (IS_NAN(pmove->velocity[i]))
		{
			pmove->Con_Printf("PM  Got a NaN velocity %i\n", i);
			pmove->velocity[i] = 0;
		}

		if (IS_NAN(pmove->origin[i]))
		{
			pmove->Con_Printf("PM  Got a NaN origin on %i\n", i);
			pmove->origin[i] = 0;
		}

		// Bound it.
		if (pmove->velocity[i] > pmove->movevars->maxvelocity)
		{
			pmove->Con_DPrintf("PM  Got a velocity too high on %i\n", i);
			pmove->velocity[i] = pmove->movevars->maxvelocity;
		}
		else if (pmove->velocity[i] < -pmove->movevars->maxvelocity)
		{
			pmove->Con_DPrintf("PM  Got a velocity too low on %i\n", i);
			pmove->velocity[i] = -pmove->movevars->maxvelocity;
		}
	}
}

// Slide off of the impacting object
// returns the blocked flags:
// 0x01 == floor
// 0x02 == step / wall
int PM_ClipVelocity(vec_t *in, vec_t *normal, vec_t *out, float overbounce)
{
	float change;
	float angle;
	float backoff;
	int i, blocked;

	angle = normal[2];

	// Assume unblocked.
	blocked = 0x00;

	// If the plane that is blocking us has a positive z component, then assume it's a floor.
	if (angle > 0)
	{
		blocked |= 0x01;
	}

	// If the plane has no Z, it is vertical (wall/step)
	if (!angle)
	{
		blocked |= 0x02;
	}

	// Determine how far along plane to slide based on incoming direction.
	// Scale by overbounce factor.
	backoff = DotProduct(in, normal) * overbounce;

	for (i = 0; i < 3; i++)
	{
		change = in[i] - normal[i] * backoff;
		out[i] = change;

		// If out velocity is too small, zero it out.
		if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
		{
			out[i] = 0;
		}
	}

	// Return blocking flags.
	return blocked;
}

void PM_AddCorrectGravity()
{
	float ent_gravity;

	if (pmove->waterjumptime)
		return;

	if (pmove->gravity != 0.0f)
		ent_gravity = pmove->gravity;
	else
		ent_gravity = 1.0f;

	// Add gravity so they'll be in the correct position during movement
	// yes, this 0.5 looks wrong, but it's not.
	pmove->velocity[2] -= (ent_gravity * pmove->movevars->gravity * 0.5f * pmove->frametime);
	pmove->velocity[2] += pmove->basevelocity[2] * pmove->frametime;

	pmove->basevelocity[2] = 0;

	PM_CheckVelocity();
}

void PM_FixupGravityVelocity()
{
	float ent_gravity;

	if (pmove->waterjumptime)
		return;

	if (pmove->gravity != 0.0)
		ent_gravity = pmove->gravity;
	else
		ent_gravity = 1.0;

	// Get the correct velocity for the end of the dt
	pmove->velocity[2] -= (pmove->movevars->gravity * pmove->frametime * ent_gravity * 0.5);
	PM_CheckVelocity();
}

int PM_FlyMove()
{
	int bumpcount, numbumps;
	vec3_t dir;
	float d;
	int numplanes;
	vec3_t planes[MAX_CLIP_PLANES];
	vec3_t primal_velocity, original_velocity;
	vec3_t new_velocity;
	int i, j;
	pmtrace_t trace;
	vec3_t end;
	float time_left, allFraction;
	int blocked;

	numbumps = 4;	// Bump up to four times
	blocked = 0x00;	// Assume not blocked
	numplanes = 0;	// and not sliding along any planes

	VectorCopy(pmove->velocity, original_velocity);		// Store original velocity
	VectorCopy(pmove->velocity, primal_velocity);

	allFraction = 0;
	time_left = pmove->frametime;				// Total time for this movement operation.

	for (bumpcount = 0; bumpcount < numbumps; bumpcount++)
	{
		if (!pmove->velocity[0] && !pmove->velocity[1] && !pmove->velocity[2])
			break;

		// Assume we can move all the way from the current origin to the
		// end point.
		for (i = 0; i < 3; i++)
		{
			float flScale = time_left * pmove->velocity[i];

			end[i] = pmove->origin[i] + flScale;
		}

		// See if we can make it from origin to end point.
		trace = pmove->PM_PlayerTrace(pmove->origin, end, PM_NORMAL, -1);

		allFraction += trace.fraction;

		// If we started in a solid object, or we were in solid space
		// the whole way, zero out our velocity and return that we
		// are blocked by floor and wall.
		if (trace.allsolid)
		{
			// entity is trapped in another solid
			VectorCopy(vec3_origin, pmove->velocity);
			return 4;
		}

		// If we moved some portion of the total distance, then
		// copy the end position into the pmove->origin and
		// zero the plane counter.
		if (trace.fraction > 0.0f)
		{
			// actually covered some distance
			VectorCopy(trace.endpos, pmove->origin);
			VectorCopy(pmove->velocity, original_velocity);

			numplanes = 0;
		}

		// If we covered the entire distance, we are done
		// and can return.
		if (trace.fraction == 1.0f)
		{
			// moved the entire distance
			break;
		}

		// Save entity that blocked us (since fraction was < 1.0)
		// for contact
		// Add it if it's not already in the list
		PM_AddToTouched(trace, pmove->velocity);

		// If the plane we hit has a high z component in the normal, then
		// it's probably a floor
		if (trace.plane.normal[2] > 0.7f)
		{
			// floor
			blocked |= 0x01;
		}

		// If the plane has a zero z component in the normal, then it's a
		// step or wall
		if (!trace.plane.normal[2])
		{
			// step / wall
			blocked |= 0x02;
		}

		// Reduce amount of pmove->frametime left by total time left * fraction
		// that we covered.
		time_left -= time_left * trace.fraction;

		// Did we run out of planes to clip against?
		if (numplanes >= MAX_CLIP_PLANES)
		{
			// this shouldn't really happen
			// Stop our movement if so.
			VectorCopy(vec3_origin, pmove->velocity);
			break;
		}

		// Set up next clipping plane
		VectorCopy(trace.plane.normal, planes[numplanes]);
		numplanes++;

		// modify original_velocity so it parallels all of the clip planes
		// relfect player velocity
		if (numplanes == 1 && pmove->movetype == MOVETYPE_WALK && (pmove->onground == -1 || pmove->friction != 1))
		{
			for (i = 0; i < numplanes; i++)
			{
				if (planes[i][2] > 0.7f)
				{
					// floor or slope
					PM_ClipVelocity(original_velocity, planes[i], new_velocity, 1);
					VectorCopy(new_velocity, original_velocity);
				}
				else
					PM_ClipVelocity(original_velocity, planes[i], new_velocity, 1.0 + pmove->movevars->bounce * (1.0 - pmove->friction));
			}

			VectorCopy(new_velocity, pmove->velocity);
			VectorCopy(new_velocity, original_velocity);
		}
		else
		{
			for (i = 0; i < numplanes; i++)
			{
				PM_ClipVelocity(original_velocity, planes[i], pmove->velocity, 1);

				for (j = 0; j < numplanes; j++)
				{
					if (j != i && DotProduct(pmove->velocity, planes[j]) < 0)
					{
						break;
					}
				}

				if (j == numplanes)
					break;
			}

			if (i == numplanes)
			{
				if (numplanes != 2)
				{
					VectorCopy(vec3_origin, pmove->velocity);
					break;
				}

				CrossProduct(planes[0], planes[1], dir);
				d = DotProduct(dir, pmove->velocity);
				VectorScale(dir, d, pmove->velocity);
			}

			if (DotProduct(pmove->velocity, primal_velocity) <= 0)
			{
				VectorCopy(vec3_origin, pmove->velocity);
				break;
			}
		}
	}

	if (allFraction == 0.0f)
	{
		VectorCopy(vec3_origin, pmove->velocity);
	}

	return blocked;
}

void PM_Accelerate(vec_t *wishdir, float wishspeed, float accel)
{
	int i;
	float addspeed;

	float currentspeed;
	float accelspeed;

	// Dead player's don't accelerate
	if (pmove->dead)
		return;

	// If waterjumping, don't accelerate
	if (pmove->waterjumptime)
		return;

	// See if we are changing direction a bit
	currentspeed = DotProduct(pmove->velocity, wishdir);

	// Reduce wishspeed by the amount of veer.
	addspeed = wishspeed - currentspeed;

	// If not going to add any speed, done.
	if (addspeed <= 0)
		return;

	// Determine amount of accleration.
	accelspeed = accel * pmove->frametime * wishspeed * pmove->friction;

	// Cap at addspeed
	if (accelspeed > addspeed)
		accelspeed = addspeed;

	// Adjust velocity.
	for (i = 0; i < 3; i++)
	{
		pmove->velocity[i] += accelspeed * wishdir[i];
	}
}

// Only used by players. Moves along the ground when player is a MOVETYPE_WALK.
void PM_WalkMove()
{
	int clip;
	int oldonground;
	int i;

	vec3_t wishvel;
	float spd;
	float fmove, smove;
	vec3_t wishdir;
	float wishspeed;

	//vec3_t start;	// TODO: unused
	vec3_t dest;
	vec3_t original, originalvel;
	vec3_t down, downvel;
	float downdist, updist;

	pmtrace_t trace;

	if (pmove->fuser2 > 0.0)
	{
		float flRatio = (100 - pmove->fuser2 * 0.001 * 19) * 0.01;

		pmove->velocity[0] *= flRatio;
		pmove->velocity[1] *= flRatio;
	}

	// Copy movement amounts
	fmove = pmove->cmd.forwardmove;
	smove = pmove->cmd.sidemove;

	// Zero out z components of movement vectors
	pmove->forward[2] = 0;
	pmove->right[2] = 0;

	// Normalize remainder of vectors.
	VectorNormalize(pmove->forward);
	VectorNormalize(pmove->right);

	// Determine x and y parts of velocity
	for (i = 0; i < 2; i++)
	{
		wishvel[i] = pmove->forward[i] * fmove + pmove->right[i] * smove;
	}

	// Zero out z part of velocity
	wishvel[2] = 0;

	// Determine maginitude of speed of move
	VectorCopy(wishvel, wishdir);
	wishspeed = VectorNormalize(wishdir);

	// Clamp to server defined max speed
	if (wishspeed > pmove->maxspeed)
	{
		VectorScale(wishvel, pmove->maxspeed / wishspeed, wishvel);
		wishspeed = pmove->maxspeed;
	}

	// Set pmove velocity
	pmove->velocity[2] = 0;
	PM_Accelerate(wishdir, wishspeed, pmove->movevars->accelerate);
	pmove->velocity[2] = 0;

	// Add in any base velocity to the current velocity.
	VectorAdd(pmove->velocity, pmove->basevelocity, pmove->velocity);

	spd = Length(pmove->velocity);

	if (spd < 1.0)
	{
		VectorClear(pmove->velocity);
		return;
	}

	// If we are not moving, do nothing
	//if (!pmove->velocity[0] && !pmove->velocity[1] && !pmove->velocity[2])
	//	return;

	oldonground = pmove->onground;

	// first try just moving to the destination
	dest[0] = pmove->origin[0] + pmove->velocity[0] * pmove->frametime;
	dest[1] = pmove->origin[1] + pmove->velocity[1] * pmove->frametime;
	dest[2] = pmove->origin[2];

	// first try moving directly to the next spot
	// VectorCopy(dest, start);

	trace = pmove->PM_PlayerTrace(pmove->origin, dest, PM_NORMAL, -1);

	// If we made it all the way, then copy trace end
	// as new player position.
	if (trace.fraction == 1.0f)
	{
		VectorCopy(trace.endpos, pmove->origin);
		return;
	}

	// Don't walk up stairs if not on ground.
	if (oldonground == -1 && pmove->waterlevel == 0)
	{
		return;
	}

	// If we are jumping out of water, don't do anything more.
	if (pmove->waterjumptime)
		return;

	// Try sliding forward both on ground and up 16 pixels
	// take the move that goes farthest

	// Save out original pos &
	VectorCopy(pmove->origin, original);

	// velocity.
	VectorCopy(pmove->velocity, originalvel);

	// Slide move
	clip = PM_FlyMove();

	// Copy the results out
	VectorCopy(pmove->origin, down);
	VectorCopy(pmove->velocity, downvel);

	// Reset original values.
	VectorCopy(original, pmove->origin);
	VectorCopy(originalvel, pmove->velocity);

	// Start out up one stair height
	VectorCopy(pmove->origin, dest);

	dest[2] += pmove->movevars->stepsize;

	trace = pmove->PM_PlayerTrace(pmove->origin, dest, PM_NORMAL, -1);

	// If we started okay and made it part of the way at least,
	// copy the results to the movement start position and then
	// run another move try.
	if (!trace.startsolid && !trace.allsolid)
	{
		VectorCopy(trace.endpos, pmove->origin);
	}

	// slide move the rest of the way.
	clip = PM_FlyMove();

	// Now try going back down from the end point
	//  press down the stepheight
	VectorCopy(pmove->origin, dest);
	dest[2] -= pmove->movevars->stepsize;

	trace = pmove->PM_PlayerTrace(pmove->origin, dest, PM_NORMAL, -1);

	// If we are not on the ground any more then
	// use the original movement attempt
	if (trace.plane.normal[2] < 0.7f)
		goto usedown;

	// If the trace ended up in empty space, copy the end
	// over to the origin.
	if (!trace.startsolid && !trace.allsolid)
	{
		VectorCopy(trace.endpos, pmove->origin);
	}

	// Copy this origion to up.
	VectorCopy(pmove->origin, pmove->up);

	// decide which one went farther
	downdist = (down[0] - original[0]) * (down[0] - original[0]) + (down[1] - original[1]) * (down[1] - original[1]);
	updist = (pmove->up[0] - original[0]) * (pmove->up[0] - original[0]) + (pmove->up[1] - original[1]) * (pmove->up[1] - original[1]);

	if (downdist > updist)
	{
usedown:
		VectorCopy(down, pmove->origin);
		VectorCopy(downvel, pmove->velocity);
	}
	else
	{
		// copy z value from slide move
		pmove->velocity[2] = downvel[2];
	}
}

// Handles both ground friction and water friction
void PM_Friction()
{
	float *vel;
	float speed;
	float newspeed, control, friction, drop;
	vec3_t newvel;

	// If we are in water jump cycle, don't apply friction
	if (pmove->waterjumptime)
		return;

	// Get velocity
	vel = pmove->velocity;

	// Calculate speed
	speed =  sqrt(float(vel[0] * vel[0] + vel[1] * vel[1] + vel[2] * vel[2]));

	// If too slow, return
	if (speed < 0.1f)
	{
		return;
	}

	drop = 0;

	// apply ground friction
	// On an entity that is the ground
	if (pmove->onground != -1)
	{
		vec3_t start, stop;
		pmtrace_t trace;

		start[0] = stop[0] = pmove->origin[0] + vel[0] / speed * 16;
		start[1] = stop[1] = pmove->origin[1] + vel[1] / speed * 16;
		start[2] = pmove->origin[2] + pmove->player_mins[pmove->usehull][2];
		stop[2] = start[2] - 34;

		trace = pmove->PM_PlayerTrace(start, stop, PM_NORMAL, -1);

		if (trace.fraction == 1.0f)
			friction = pmove->movevars->friction * pmove->movevars->edgefriction;
		else
			friction = pmove->movevars->friction;

		// Grab friction value.
		//friction = pmove->movevars->friction;

		// player friction?
		friction *= pmove->friction;

		// Bleed off some speed, but if we have less than the bleed
		// threshhold, bleed the theshold amount.
		control = (speed < pmove->movevars->stopspeed) ? pmove->movevars->stopspeed : speed;

		// Add the amount to t'he drop amount.
		drop += friction * (control * pmove->frametime);
	}

	// apply water friction
	//if (pmove->waterlevel)
	//{
	//	drop += speed * pmove->movevars->waterfriction * waterlevel * pmove->frametime;
	//}

	// scale the velocity
	newspeed = speed - drop;

	if (newspeed < 0)
	{
		newspeed = 0;
	}

	// Determine proportion of old speed we are using.
	newspeed /= speed;

	// Adjust velocity according to proportion.
	newvel[0] = vel[0] * newspeed;
	newvel[1] = vel[1] * float(newspeed);
	newvel[2] = vel[2] * float(newspeed);

	VectorCopy(newvel, pmove->velocity);
}

void PM_AirAccelerate(vec_t *wishdir, float wishspeed, float accel)
{
	int i;
	float addspeed;
	float wishspd = wishspeed;

	float currentspeed;
	float accelspeed;

	if (pmove->dead || pmove->waterjumptime)
		return;

	// Cap speed
	if (wishspd > 30)
		wishspd = 30;

	// Determine veer amount
	currentspeed = DotProduct(pmove->velocity, wishdir);

	// See how much to add
	addspeed = wishspd - currentspeed;

	// If not adding any, done.
	if (addspeed <= 0)
		return;

	// Determine acceleration speed after acceleration
	accelspeed = accel * wishspeed * pmove->frametime * pmove->friction;

	// Cap it
	if (accelspeed > addspeed)
		accelspeed = addspeed;

	// Adjust pmove vel.
	for (i = 0; i < 3; i++)
	{
		pmove->velocity[i] += accelspeed * wishdir[i];
	}
}

void PM_WaterMove()
{
	int i;
	vec3_t wishvel;
	vec3_t wishdir;
	vec3_t start, dest;
	vec3_t temp;
	pmtrace_t trace;

	float speed, accelspeed, wishspeed;
	float newspeed, addspeed;

	// user intentions
	for (i = 0; i < 3; i++)
	{
		wishvel[i] = (pmove->forward[i] * pmove->cmd.forwardmove) + (pmove->cmd.sidemove * pmove->right[i]);
	}

	// Sinking after no other movement occurs
	if (!pmove->cmd.forwardmove && !pmove->cmd.sidemove && !pmove->cmd.upmove)
	{
		// drift towards bottom
		wishvel[2] -= 60.0f;
	}
	else
	{
		// Go straight up by upmove amount.
		wishvel[2] += pmove->cmd.upmove;
	}

	// Copy it over and determine speed
	VectorCopy(wishvel, wishdir);
	wishspeed = VectorNormalize(wishdir);

	// Cap speed.
	if (wishspeed > pmove->maxspeed)
	{
		VectorScale(wishvel, pmove->maxspeed / wishspeed, wishvel);
		wishspeed = pmove->maxspeed;
	}

	// Slow us down a bit.
	wishspeed *= 0.8;
	VectorAdd(pmove->velocity, pmove->basevelocity, pmove->velocity);

	// Water friction
	VectorCopy(pmove->velocity, temp);
	speed = VectorNormalize(temp);

	if (speed)
	{
		newspeed = speed - pmove->movevars->friction * pmove->friction * pmove->frametime * speed;

		if (newspeed < 0.0f)
		{
			newspeed = 0.0f;
		}

		VectorScale(pmove->velocity, newspeed / speed, pmove->velocity);
	}
	else
		newspeed = 0;

	// water acceleration
	if (float(wishspeed) < 0.1f)
	{
		return;
	}

	addspeed = float(wishspeed) - newspeed;

	if (addspeed > 0.0f)
	{
		VectorNormalize(wishvel);
		accelspeed = pmove->movevars->accelerate * pmove->friction * pmove->frametime * float(wishspeed);

		if (accelspeed > addspeed)
		{
			accelspeed = addspeed;
		}

		for (i = 0; i < 3; i++)
		{
			pmove->velocity[i] += accelspeed * wishvel[i];
		}
	}

	// Now move
	// assume it is a stair or a slope, so press down from stepheight above
	VectorMA(pmove->origin, pmove->frametime, pmove->velocity, dest);
	VectorCopy(dest, start);

	start[2] += pmove->movevars->stepsize + 1;
	trace = pmove->PM_PlayerTrace(start, dest, PM_NORMAL, -1);

	// FIXME: check steep slope?
	if (!trace.startsolid && !trace.allsolid)
	{
		// walked up the step, so just keep result and exit
		VectorCopy(trace.endpos, pmove->origin);
		return;
	}

	// Try moving straight along out normal path.
	PM_FlyMove();
}

void PM_AirMove()
{
	int i;
	vec3_t wishvel;
	float fmove, smove;
	vec3_t wishdir;
	float wishspeed;

	// Copy movement amounts
	fmove = pmove->cmd.forwardmove;
	smove = pmove->cmd.sidemove;

	// Zero out z components of movement vectors
	pmove->forward[2] = 0;
	pmove->right[2] = 0;

	// Renormalize
	VectorNormalize(pmove->forward);
	VectorNormalize(pmove->right);

	// Determine x and y parts of velocity
	for (i = 0; i < 2; i++)
	{
		wishvel[i] = pmove->forward[i] * fmove + pmove->right[i] * smove;
	}

	// Zero out z part of velocity
	wishvel[2] = 0;

	 // Determine maginitude of speed of move
	VectorCopy(wishvel, wishdir);
	wishspeed = VectorNormalize(wishdir);

	// Clamp to server defined max speed
	if (wishspeed > pmove->maxspeed)
	{
		VectorScale(wishvel, pmove->maxspeed/wishspeed, wishvel);
		wishspeed = pmove->maxspeed;
	}

	PM_AirAccelerate(wishdir, wishspeed, pmove->movevars->airaccelerate);

	// Add in any base velocity to the current velocity.
	VectorAdd(pmove->velocity, pmove->basevelocity, pmove->velocity);

	PM_FlyMove();
}

qboolean PM_InWater()
{
	return (pmove->waterlevel > 1) ? TRUE : FALSE;
}

// Sets pmove->waterlevel and pmove->watertype values.
qboolean PM_CheckWater()
{
#ifdef REGAMEDLL_FIXES
	// do not check for dead
	if (pmove->dead || pmove->deadflag != DEAD_NO)
		return FALSE;
#endif

	vec3_t point;
	int cont;
	int truecont;
	float height;
	float heightover2;

	// Pick a spot just above the players feet.
	point[0] = pmove->origin[0] + (pmove->player_mins[pmove->usehull][0] + pmove->player_maxs[pmove->usehull][0]) * 0.5f;
	point[1] = pmove->origin[1] + (pmove->player_mins[pmove->usehull][1] + pmove->player_maxs[pmove->usehull][1]) * 0.5f;
	point[2] = pmove->origin[2] + pmove->player_mins[pmove->usehull][2] + 1;

	// Assume that we are not in water at all.
	pmove->waterlevel = 0;
	pmove->watertype = CONTENTS_EMPTY;

	// Grab point contents.
	cont = pmove->PM_PointContents(point, &truecont);

	// Are we under water? (not solid and not empty?)
	if (cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT)
	{
		// Set water type
		pmove->watertype = cont;

		// We are at least at level one
		pmove->waterlevel = 1;

		height = (pmove->player_mins[pmove->usehull][2] + pmove->player_maxs[pmove->usehull][2]);
		heightover2 = height * 0.5;

		// Now check a point that is at the player hull midpoint.
		point[2] = pmove->origin[2] + heightover2;
		cont = pmove->PM_PointContents(point, nullptr);

		// If that point is also under water...
		if (cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT)
		{
			// Set a higher water level.
			pmove->waterlevel = 2;

			// Now check the eye position.  (view_ofs is relative to the origin)
			point[2] = pmove->origin[2] + pmove->view_ofs[2];

			cont = pmove->PM_PointContents(point, nullptr);
			if (cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT)
			{
				// In over our eyes
				pmove->waterlevel = 3;
			}
		}

		// Adjust velocity based on water current, if any.
		if ((truecont <= CONTENTS_CURRENT_0) && (truecont >= CONTENTS_CURRENT_DOWN))
		{
			// The deeper we are, the stronger the current.
			static vec3_t current_table[] =
			{
				{1, 0, 0}, {0, 1, 0}, {-1, 0, 0},
				{0, -1, 0}, {0, 0, 1}, {0, 0, -1}
			};

			VectorMA(pmove->basevelocity, 50.0 * pmove->waterlevel, current_table[CONTENTS_CURRENT_0 - truecont], pmove->basevelocity);
		}
	}

	return (pmove->waterlevel > 1) ? TRUE : FALSE;
}

void PM_CategorizePosition()
{
	vec3_t point;
	pmtrace_t tr;

	// if the player hull point one unit down is solid, the player
	// is on ground

	// see if standing on something solid

	// Doing this before we move may introduce a potential latency in water detection, but
	// doing it after can get us stuck on the bottom in water if the amount we move up
	// is less than the 1 pixel 'threshold' we're about to snap to.	Also, we'll call
	// this several times per frame, so we really need to avoid sticking to the bottom of
	// water on each call, and the converse case will correct itself if called twice.
	PM_CheckWater();

	point[0] = pmove->origin[0];
	point[1] = pmove->origin[1];
	point[2] = pmove->origin[2] - 2;

	// Shooting up really fast.  Definitely not on ground.
	if (pmove->velocity[2] > 180)
	{
		pmove->onground = -1;
		return;
	}

	// Try and move down.
	tr = pmove->PM_PlayerTrace(pmove->origin, point, PM_NORMAL, -1);

	// If we hit a steep plane, we are not on ground
	if (tr.plane.normal[2] < 0.7f)
	{
		// too steep
		pmove->onground = -1;
	}
	else
	{
		// Otherwise, point to index of ent under us.
		pmove->onground = tr.ent;
	}

	// If we are on something...
	if (pmove->onground != -1)
	{
		// Then we are not in water jump sequence
		pmove->waterjumptime = 0;

		// If we could make the move, drop us down that 1 pixel
		if (pmove->waterlevel < 2 && !tr.startsolid && !tr.allsolid)
		{
			VectorCopy(tr.endpos, pmove->origin);
		}
	}

	// Standing on an entity other than the world
	// So signal that we are touching something.
	if (tr.ent > 0)
	{
		PM_AddToTouched(tr, pmove->velocity);
	}
}

// When a player is stuck, it's costly to try and unstick them
// Grab a test offset for the player based on a passed in index
int PM_GetRandomStuckOffsets(int nIndex, int server, vec_t *offset)
{
	// Last time we did a full
	int idx;
	idx = rgStuckLast[nIndex][server]++;

	VectorCopy(rgv3tStuckTable[idx % 54], offset);

	return (idx % 54);
}

void PM_ResetStuckOffsets(int nIndex, int server)
{
	rgStuckLast[nIndex][server] = 0;
}

// If pmove->origin is in a solid position,
// try nudging slightly on all axis to
// allow for the cut precision of the net coordinates
qboolean PM_CheckStuck()
{
	vec3_t base;
	vec3_t offset;
	vec3_t test;
	int hitent;
	int idx;
	float fTime;
	int i;
	pmtrace_t traceresult;

	// Last time we did a full
	static float rgStuckCheckTime[MAX_CLIENTS][2];

	// If position is okay, exit
	hitent = pmove->PM_TestPlayerPosition(pmove->origin, &traceresult);
	if (hitent == -1)
	{
		PM_ResetStuckOffsets(pmove->player_index, pmove->server);
		return FALSE;
	}

	VectorCopy(pmove->origin, base);

	// Deal with precision error in network.
	if (!pmove->server)
	{
		// World or BSP model
		if (hitent == 0 || pmove->physents[hitent].model)
		{
			int nReps = 0;
			PM_ResetStuckOffsets(pmove->player_index, pmove->server);
			do
			{
				i = PM_GetRandomStuckOffsets(pmove->player_index, pmove->server, offset);

				VectorAdd(base, offset, test);
				if (pmove->PM_TestPlayerPosition(test, &traceresult) == -1)
				{
					PM_ResetStuckOffsets(pmove->player_index, pmove->server);
					VectorCopy(test, pmove->origin);
					return FALSE;
				}

				nReps++;
			}
			while (nReps < 54);
		}
	}

	// Only an issue on the client.
	if (pmove->server)
		idx = 0;
	else
		idx = 1;

	fTime = pmove->Sys_FloatTime();

	// Too soon?
	if (rgStuckCheckTime[pmove->player_index][idx] >= (fTime - PM_CHECKSTUCK_MINTIME))
	{
		return TRUE;
	}

	rgStuckCheckTime[pmove->player_index][idx] = fTime;

	pmove->PM_StuckTouch(hitent, &traceresult);

	i = PM_GetRandomStuckOffsets(pmove->player_index, pmove->server, offset);

	VectorAdd(base, offset, test);
	if ((hitent = pmove->PM_TestPlayerPosition(test, nullptr)) == -1)
	{
		PM_ResetStuckOffsets(pmove->player_index, pmove->server);

		if (i >= 27)
		{
			VectorCopy(test, pmove->origin);
		}

		return FALSE;
	}

	// If player is flailing while stuck in another player (should never happen), then see
	//  if we can't "unstick" them forceably.
	if ((pmove->cmd.buttons & (IN_JUMP | IN_DUCK | IN_ATTACK)) && pmove->physents[hitent].player != 0)
	{
		float x, y, z;
		float xystep = 8.0;
		float zstep = 18.0;
		float xyminmax = xystep;
		float zminmax = 4 * zstep;

		for (z = 0; z <= zminmax; z += zstep)
		{
			for (x = -xyminmax; x <= xyminmax; x += xystep)
			{
				for (y = -xyminmax; y <= xyminmax; y += xystep)
				{
					VectorCopy(base, test);

					test[0] += x;
					test[1] += y;
					test[2] += z;

					if (pmove->PM_TestPlayerPosition(test, nullptr) == -1)
					{
						VectorCopy(test, pmove->origin);
						return FALSE;
					}
				}
			}
		}
	}

	return TRUE;
}

void PM_SpectatorMove()
{
	float speed, drop, friction;
	float control, newspeed;
	float currentspeed, addspeed;
	float accelspeed;
	int i;
	vec3_t wishvel;
	float fmove, smove;
	vec3_t wishdir;
	float wishspeed;

	// this routine keeps track of the spectators psoition
	// there a two different main move types : track player or moce freely (OBS_ROAMING)
	// doesn't need excate track position, only to generate PVS, so just copy
	// targets position and real view position is calculated on client (saves server CPU)
	if (pmove->iuser1 == OBS_ROAMING)
	{
#ifdef CLIENT_DLL
		if (iJumpSpectator)
		{
			VectorCopy(vJumpOrigin, pmove->origin);
			VectorCopy(vJumpAngles, pmove->angles);
			VectorCopy(vec3_origin, pmove->velocity);
			iJumpSpectator = 0;
			return;
		}
#endif
		// Move around in normal spectator method
		speed = Length (pmove->velocity);

		if (speed >= 1.0)
		{
			drop = 0;

			// extra friction
			friction = pmove->movevars->friction * 1.5;
			control = speed < pmove->movevars->stopspeed ? pmove->movevars->stopspeed : speed;
			drop += friction * (control * pmove->frametime);

			// scale the velocity
			newspeed = speed - drop;

			if (newspeed < 0)
			{
				newspeed = 0;
			}
			newspeed /= speed;

			VectorScale(pmove->velocity, newspeed, pmove->velocity);
		}
		else
		{
			VectorCopy(vec3_origin, pmove->velocity);
		}

		// accelerate
		fmove = pmove->cmd.forwardmove;
		smove = pmove->cmd.sidemove;

		VectorNormalize(pmove->forward);
		VectorNormalize(pmove->right);

		for (i = 0; i < 3; i++)
		{
			wishvel[i] = pmove->forward[i] * fmove + pmove->right[i] * smove;
		}

		wishvel[2] += pmove->cmd.upmove;

		VectorCopy(wishvel, wishdir);
		wishspeed = VectorNormalize(wishdir);

		// clamp to server defined max speed
		if (wishspeed > pmove->movevars->spectatormaxspeed)
		{
			VectorScale(wishvel, pmove->movevars->spectatormaxspeed / wishspeed, wishvel);
			wishspeed = pmove->movevars->spectatormaxspeed;
		}

		currentspeed = DotProduct(pmove->velocity, wishdir);

		addspeed = wishspeed - currentspeed;
		if (addspeed <= 0)
		{
			return;
		}

		accelspeed = pmove->movevars->accelerate * pmove->frametime * wishspeed;
		if (accelspeed > addspeed)
		{
			accelspeed = addspeed;
		}

		for (i = 0; i < 3; i++)
		{
			pmove->velocity[i] += accelspeed * wishdir[i];
		}

		// move
		VectorMA(pmove->origin, pmove->frametime, pmove->velocity, pmove->origin);
	}
	else
	{
		// all other modes just track some kind of target, so spectator PVS = target PVS
		int target;

		// no valid target ?
		if (pmove->iuser2 <= 0)
			return;

		// Find the client this player's targeting
		for (target = 0; target < pmove->numphysent; target++)
		{
			if (pmove->physents[target].info == pmove->iuser2)
				break;
		}

		if (target == pmove->numphysent)
			return;

		// use targets position as own origin for PVS
		VectorCopy(pmove->physents[target].angles, pmove->angles);
		VectorCopy(pmove->physents[target].origin, pmove->origin);

		// no velocity
		VectorCopy(vec3_origin, pmove->velocity);
	}
}

// Use for ease-in, ease-out style interpolation (accel/decel)
// Used by ducking code.
float PM_SplineFraction(float value, float scale)
{
	float valueSquared;

	value = scale * value;
	valueSquared = value * value;

	// Nice little ease-in, ease-out spline-like curve
	return 3 * valueSquared - 2 * valueSquared * value;
}

float PM_SimpleSpline(float value)
{
	float valueSquared;

	valueSquared = value * value;

	return 3 * valueSquared - 2 * valueSquared * value;
}

void PM_FixPlayerCrouchStuck(int direction)
{
	int hitent;
	int i;
	vec3_t test;

	hitent = pmove->PM_TestPlayerPosition (pmove->origin, nullptr);

	if (hitent == -1)
	{
		return;
	}

	VectorCopy(pmove->origin, test);

	for (i = 0; i < HalfHumanHeight; i++)
	{
		pmove->origin[2] += direction;
		hitent = pmove->PM_TestPlayerPosition(pmove->origin, nullptr);

		if (hitent == -1)
		{
			return;
		}
	}

	// Failed
	VectorCopy(test, pmove->origin);
}

void PM_UnDuck()
{
	pmtrace_t trace;
	vec3_t newOrigin;

	VectorCopy(pmove->origin, newOrigin);

	if (pmove->onground != -1)
	{
#ifdef REGAMEDLL_FIXES
		vec3_t offset;
		VectorSubtract(pmove->player_mins[1], pmove->player_mins[0], offset);
		VectorAdd(newOrigin, offset, newOrigin);
#else
		newOrigin[2] += 18.0;
#endif
	}

	trace = pmove->PM_PlayerTrace(newOrigin, newOrigin, PM_NORMAL, -1);
	if (!trace.startsolid)
	{
		pmove->usehull = 0;

		// Oh, no, changing hulls stuck us into something, try unsticking downward first.
		trace = pmove->PM_PlayerTrace(newOrigin, newOrigin, PM_NORMAL, -1);

		if (trace.startsolid)
		{
			// See if we are stuck?  If so, stay ducked with the duck hull until we have a clear spot
			// Con_Printf("unstick got stuck\n");
			pmove->usehull = 1;
			return;
		}

		pmove->flags &= ~FL_DUCKING;
		pmove->bInDuck = FALSE;
		pmove->view_ofs[2] = PM_VEC_VIEW;
		pmove->flDuckTime = 0;

		pmove->flTimeStepSound -= 100;

		if (pmove->flTimeStepSound < 0)
		{
			pmove->flTimeStepSound = 0;
		}

		VectorCopy(newOrigin, pmove->origin);

		// Recatagorize position since ducking can change origin
		PM_CategorizePosition();
	}
}

void PM_Duck()
{
	int buttonsChanged = (pmove->oldbuttons ^ pmove->cmd.buttons);	// These buttons have changed this frame
	int nButtonPressed =  buttonsChanged & pmove->cmd.buttons;		// The changed ones still down are "pressed"

	int duckchange = buttonsChanged & IN_DUCK ? 1 : 0;
	int duckpressed = nButtonPressed & IN_DUCK ? 1 : 0;

	if (pmove->cmd.buttons & IN_DUCK)
	{
		pmove->oldbuttons |= IN_DUCK;
	}
	else
	{
		pmove->oldbuttons &= ~IN_DUCK;
	}

#ifdef REGAMEDLL_FIXES
#define PLAYER_PREVENT_DUCK     (1 << 4)
	// Prevent ducking if the iuser3 variable is contain PLAYER_PREVENT_DUCK
	if ((pmove->iuser3 & PLAYER_PREVENT_DUCK) == PLAYER_PREVENT_DUCK)
	{
		// Try to unduck
		if (pmove->flags & FL_DUCKING)
		{
			PM_UnDuck();
		}

		return;
	}
#endif

	if (pmove->dead || (!(pmove->cmd.buttons & IN_DUCK) && !pmove->bInDuck && !(pmove->flags & FL_DUCKING)))
	{
		return;
	}

	pmove->cmd.forwardmove *= PLAYER_DUCKING_MULTIPLIER;
	pmove->cmd.sidemove *= PLAYER_DUCKING_MULTIPLIER;
	pmove->cmd.upmove *= PLAYER_DUCKING_MULTIPLIER;

	if (pmove->cmd.buttons & IN_DUCK)
	{
		if ((nButtonPressed & IN_DUCK) && !(pmove->flags & FL_DUCKING))
		{
			// Use 1 second so super long jump will work
			pmove->flDuckTime = 1000;
			pmove->bInDuck = TRUE;
		}

		if (pmove->bInDuck)
		{
			// Finish ducking immediately if duck time is over or not on ground
			if (((pmove->flDuckTime / 1000.0) <= (1.0 - TIME_TO_DUCK)) || pmove->onground == -1)
			{
				pmove->usehull = 1;
				pmove->view_ofs[2] = PM_VEC_DUCK_VIEW;
				pmove->flags |= FL_DUCKING;
				pmove->bInDuck = FALSE;

				// HACKHACK - Fudge for collision bug - no time to fix this properly
				if (pmove->onground != -1)
				{
#ifdef REGAMEDLL_FIXES
					vec3_t newOrigin;
					VectorSubtract(pmove->player_mins[1], pmove->player_mins[0], newOrigin);
					VectorSubtract(pmove->origin, newOrigin, pmove->origin);
#else
					pmove->origin[2] = pmove->origin[2] - 18.0;
#endif

					// See if we are stuck?
					PM_FixPlayerCrouchStuck(STUCK_MOVEUP);

					// Recatagorize position since ducking can change origin
					PM_CategorizePosition();
				}
			}
			else
			{
				float duckFraction = PM_VEC_VIEW;
				float time = (1.0 - pmove->flDuckTime / 1000.0);

				// Calc parametric time
				if (time >= 0.0) {
					duckFraction = PM_SplineFraction(time, (1.0 / TIME_TO_DUCK));
				}

#ifdef REGAMEDLL_FIXES
				float fMore = (pmove->player_mins[1][2] - pmove->player_mins[0][2]);
#else
				float fMore = (PM_VEC_DUCK_HULL_MIN - PM_VEC_HULL_MIN);
#endif

				pmove->view_ofs[2] = ((PM_VEC_DUCK_VIEW - fMore) * duckFraction) + (PM_VEC_VIEW * (1 - duckFraction));
			}
		}
	}
	// Try to unduck
	else
	{
		PM_UnDuck();
	}
}

void PM_LadderMove(physent_t *pLadder)
{
	vec3_t ladderCenter;
	trace_t trace;
	bool onFloor;
	vec3_t floor;
	vec3_t modelmins, modelmaxs;

	if (pmove->movetype == MOVETYPE_NOCLIP)
		return;

	pmove->PM_GetModelBounds(pLadder->model, modelmins, modelmaxs);

	VectorAdd(modelmins, modelmaxs, ladderCenter);
	VectorScale(ladderCenter, 0.5, ladderCenter);

	pmove->movetype = MOVETYPE_FLY;

	// On ladder, convert movement to be relative to the ladder
	VectorCopy(pmove->origin, floor);
	floor[2] += pmove->player_mins[pmove->usehull][2] - 1;

	if (pmove->PM_PointContents(floor, nullptr) == CONTENTS_SOLID)
		onFloor = true;
	else
		onFloor = false;

	pmove->gravity = 0;
	pmove->PM_TraceModel(pLadder, pmove->origin, ladderCenter, &trace);

	if (trace.fraction != 1.0f)
	{
		float forward = 0, right = 0;
		vec3_t vpn, v_right;
		float flSpeed = MAX_CLIMB_SPEED;

		// they shouldn't be able to move faster than their maxspeed
		if (flSpeed > pmove->maxspeed)
		{
			flSpeed = pmove->maxspeed;
		}

		AngleVectors(pmove->angles, vpn, v_right, nullptr);

		if (pmove->flags & FL_DUCKING)
		{
			flSpeed *= PLAYER_DUCKING_MULTIPLIER;
		}

		if (pmove->cmd.buttons & IN_BACK)
		{
			forward -= flSpeed;
		}
		if (pmove->cmd.buttons & IN_FORWARD)
		{
			forward += flSpeed;
		}
		if (pmove->cmd.buttons & IN_MOVELEFT)
		{
			right -= flSpeed;
		}
		if (pmove->cmd.buttons & IN_MOVERIGHT)
		{
			right += flSpeed;
		}

		if (pmove->cmd.buttons & IN_JUMP)
		{
			pmove->movetype = MOVETYPE_WALK;
			VectorScale(trace.plane.normal, 270, pmove->velocity);
		}
		else
		{
			if (forward != 0 || right != 0)
			{
				vec3_t velocity, perp, cross, lateral, tmp;
				float normal;

				VectorScale(vpn, forward, velocity);
				VectorMA(velocity, right, v_right, velocity);

				VectorClear(tmp);
				tmp[2] = 1;

				CrossProduct(tmp, trace.plane.normal, perp);
				VectorNormalize(perp);

				// decompose velocity into ladder plane
				normal = DotProduct(velocity, trace.plane.normal);
				// This is the velocity into the face of the ladder
				VectorScale(trace.plane.normal, normal, cross);

				// This is the player's additional velocity
				VectorSubtract(velocity, cross, lateral);

				// This turns the velocity into the face of the ladder into velocity that
				// is roughly vertically perpendicular to the face of the ladder.
				// NOTE: It IS possible to face up and move down or face down and move up
				// because the velocity is a sum of the directional velocity and the converted
				// velocity through the face of the ladder - by design.
				CrossProduct(trace.plane.normal, perp, tmp);
				VectorMA(lateral, -normal, tmp, pmove->velocity);

				// On ground moving away from the ladder
				if (onFloor && normal > 0)
				{
					VectorMA(pmove->velocity, MAX_CLIMB_SPEED, trace.plane.normal, pmove->velocity);
				}
			}
			else
			{
				VectorClear(pmove->velocity);
			}
		}
	}
}

physent_t *PM_Ladder()
{
	int i;
	physent_t *pe;
	hull_t *hull;
	int num;
	vec3_t test;

	for (i = 0; i < pmove->nummoveent; i++)
	{
		pe = &pmove->moveents[i];

		if (pe->model && (modtype_t)pmove->PM_GetModelType(pe->model) == mod_brush && pe->skin == CONTENTS_LADDER)
		{
			hull = (hull_t *)pmove->PM_HullForBsp(pe, test);
			num = hull->firstclipnode;

			// Offset the test point appropriately for this hull.
			VectorSubtract(pmove->origin, test, test);

			// Test the player's hull for intersection with this model
			if (pmove->PM_HullPointContents(hull, num, test) == CONTENTS_EMPTY)
			{
				continue;
			}

			return pe;
		}
	}

	return nullptr;
}

void PM_WaterJump()
{
	if (pmove->waterjumptime > 10000)
	{
		pmove->waterjumptime = 10000;
	}

	if (!pmove->waterjumptime)
	{
		return;
	}

	pmove->waterjumptime -= pmove->cmd.msec;

	if (pmove->waterjumptime < 0 || !pmove->waterlevel)
	{
		pmove->waterjumptime = 0;
		pmove->flags &= ~FL_WATERJUMP;
	}

	pmove->velocity[0] = pmove->movedir[0];
	pmove->velocity[1] = pmove->movedir[1];
}

void PM_AddGravity()
{
	float ent_gravity;

	if (pmove->gravity != 0.0f)
		ent_gravity = pmove->gravity;
	else
		ent_gravity = 1.0f;

	pmove->velocity[2] -= (ent_gravity * pmove->movevars->gravity * pmove->frametime);
	pmove->velocity[2] += pmove->basevelocity[2] * pmove->frametime;

	pmove->basevelocity[2] = 0;
	PM_CheckVelocity();
}

// Does not change the entities velocity at all
pmtrace_t PM_PushEntity(vec_t *push)
{
	pmtrace_t trace;
	vec3_t end;

	VectorAdd(pmove->origin, push, end);

	trace = pmove->PM_PlayerTrace(pmove->origin, end, PM_NORMAL, -1);

	VectorCopy(trace.endpos, pmove->origin);

	// So we can run impact function afterwards.
	if (trace.fraction < 1.0f && !trace.allsolid)
	{
		PM_AddToTouched(trace, pmove->velocity);
	}

	return trace;
}

void PM_Physics_Toss()
{
	pmtrace_t trace;
	vec3_t move;
	float backoff;

	PM_CheckWater();

	if (pmove->velocity[2] > 0)
	{
		pmove->onground = -1;
	}

	// If on ground and not moving, return.
	if (pmove->onground != -1)
	{
		if (VectorCompare(pmove->basevelocity, vec3_origin) && VectorCompare(pmove->velocity, vec3_origin))
		{
			return;
		}
	}

	PM_CheckVelocity();

	// add gravity
	if (pmove->movetype != MOVETYPE_FLY && pmove->movetype != MOVETYPE_BOUNCEMISSILE && pmove->movetype != MOVETYPE_FLYMISSILE)
	{
		PM_AddGravity();
	}

	// move origin
	// Base velocity is not properly accounted for since this entity will move again after the bounce without
	// taking it into account
	VectorAdd(pmove->velocity, pmove->basevelocity, pmove->velocity);

	PM_CheckVelocity();
	VectorScale(pmove->velocity, pmove->frametime, move);
	VectorSubtract(pmove->velocity, pmove->basevelocity, pmove->velocity);

	// Should this clear basevelocity
	trace = PM_PushEntity(move);

	PM_CheckVelocity();

	if (trace.allsolid)
	{
		// entity is trapped in another solid
		pmove->onground = trace.ent;
		VectorCopy(vec3_origin, pmove->velocity);
		return;
	}

	if (trace.fraction == 1.0f)
	{
		PM_CheckWater();
		return;
	}

	if (pmove->movetype == MOVETYPE_BOUNCE)
	{
		backoff = 2.0f - pmove->friction;
	}
	else if (pmove->movetype == MOVETYPE_BOUNCEMISSILE)
	{
		backoff = 2.0f;
	}
	else
		backoff = 1.0f;

	PM_ClipVelocity(pmove->velocity, trace.plane.normal, pmove->velocity, backoff);

	// stop if on ground
	if (trace.plane.normal[2] > 0.7f)
	{
		float vel;
		vec3_t base;

		VectorClear(base);
		if (pmove->velocity[2] < pmove->movevars->gravity * pmove->frametime)
		{
			// we're rolling on the ground, add static friction.
			pmove->onground = trace.ent;
			pmove->velocity[2] = 0;
		}

		vel = DotProduct(pmove->velocity, pmove->velocity);

		if (vel < (30 * 30) || (pmove->movetype != MOVETYPE_BOUNCE && pmove->movetype != MOVETYPE_BOUNCEMISSILE))
		{
			pmove->onground = trace.ent;
			VectorCopy(vec3_origin, pmove->velocity);
		}
		else
		{
			VectorScale(pmove->velocity, (1.0f - trace.fraction) * pmove->frametime * 0.9f, move);
			trace = PM_PushEntity(move);
		}

		VectorSubtract(pmove->velocity, base, pmove->velocity);
	}

	// check for in water
	PM_CheckWater();
}

void PM_NoClip()
{
	int i;
	vec3_t wishvel;
	float fmove, smove;

	// Copy movement amounts
	fmove = pmove->cmd.forwardmove;
	smove = pmove->cmd.sidemove;

	VectorNormalize(pmove->forward);
	VectorNormalize(pmove->right);

	// Determine x and y parts of velocity
	for (i = 0; i < 3; i++)
	{
		wishvel[i] = pmove->forward[i] * fmove + pmove->right[i] * smove;
	}

	wishvel[2] += pmove->cmd.upmove;

	VectorMA(pmove->origin, pmove->frametime, wishvel, pmove->origin);

	// Zero out the velocity so that we don't accumulate a huge downward velocity from
	// gravity, etc.
	VectorClear(pmove->velocity);
}

// Purpose: Corrects bunny jumping (where player initiates a bunny jump before other
// movement logic runs, thus making onground == -1 thus making PM_Friction get skipped and
// running PM_AirMove, which doesn't crop velocity to maxspeed like the ground / other
// movement logic does.
void PM_PreventMegaBunnyJumping()
{
	// Current player speed
	float spd;
	// If we have to crop, apply this cropping fraction to velocity
	float fraction;
	// Speed at which bunny jumping is limited
	float maxscaledspeed;

	maxscaledspeed = BUNNYJUMP_MAX_SPEED_FACTOR * pmove->maxspeed;

	// Don't divide by zero
	if (maxscaledspeed <= 0.0f)
		return;

	spd = Length(pmove->velocity);

	if (spd <= maxscaledspeed)
		return;

	// Returns the modifier for the velocity
	fraction = (maxscaledspeed / spd) * 0.8;

	// Crop it down!.
	VectorScale(pmove->velocity, fraction, pmove->velocity);
}

void PM_Jump()
{
	if (pmove->dead)
	{
		// don't jump again until released
		pmove->oldbuttons |= IN_JUMP;
		return;
	}

	// See if we are waterjumping.  If so, decrement count and return.
	if (pmove->waterjumptime != 0.0f)
	{
		pmove->waterjumptime -= pmove->cmd.msec;

		if (pmove->waterjumptime < 0)
		{
			pmove->waterjumptime = 0;
		}

		return;
	}

	// If we are in the water most of the way...
	if (pmove->waterlevel >= 2)
	{
		// swimming, not jumping
		pmove->onground = -1;

		// We move up a certain amount
		if (pmove->watertype == CONTENTS_WATER)
		{
			pmove->velocity[2] = 100;
		}
		else if (pmove->watertype == CONTENTS_SLIME)
		{
			pmove->velocity[2] = 80;
		}
		else // LAVA
			pmove->velocity[2] = 50;

		// play swiming sound
		if (pmove->flSwimTime <= 0)
		{
			// Don't play sound again for 1 second
			pmove->flSwimTime = 1000.0f;

			switch (pmove->RandomLong(0, 3))
			{
			case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade1.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
			case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade2.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
			case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade3.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
			case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade4.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
			}
		}

		return;
	}

	// No more effect
	// in air, so no effect
	if (pmove->onground == -1)
	{
		// Flag that we jumped.
		// don't jump again until released
		pmove->oldbuttons |= IN_JUMP;
		return;
	}

	// don't pogo stick
	if (pmove->oldbuttons & IN_JUMP)
	{
		return;
	}

	if (pmove->bInDuck && (pmove->flags & FL_DUCKING))
	{
		return;
	}

	PM_CatagorizeTextureType();

	// In the air now.
	pmove->onground = -1;

	PM_PreventMegaBunnyJumping();

	float fvel = Length(pmove->velocity);
	float fvol = 1.0f;

	if (fvel >= 150.0f)
	{
		PM_PlayStepSound(PM_MapTextureTypeStepType(pmove->chtexturetype), fvol);
	}

#ifdef REGAMEDLL_ADD
	// See if user can super long jump?
	bool cansuperjump = (pmove->PM_Info_ValueForKey(pmove->physinfo, "slj")[0] == '1');

	// Acclerate upward
	// If we are ducking...
	if (pmove->bInDuck || (pmove->flags & FL_DUCKING))
	{
		// Adjust for super long jump module
		// UNDONE: note this should be based on forward angles, not current velocity.
		if (cansuperjump && (pmove->cmd.buttons & IN_DUCK) && pmove->flDuckTime > 0 && Length(pmove->velocity) > 50)
		{
			pmove->punchangle[0] = -5.0f;

			for (int i  = 0; i < 2; i++)
			{
				pmove->velocity[i] = pmove->forward[i] * PLAYER_LONGJUMP_SPEED * 1.6f;
			}

			pmove->velocity[2] =  sqrt(2 * 800 * 56.0f);
		}
		else
		{
			pmove->velocity[2] =  sqrt(2 * 800 * 45.0f);
		}
	}
	else
#endif
	{
		// NOTE: don't do it in .f (float)
		pmove->velocity[2] =  sqrt(2.0 * 800.0f * 45.0f);
	}

	if (pmove->fuser2 > 0.0f)
	{
		// NOTE: don't do it in .f (float)
		float flRatio = (100.0 - pmove->fuser2 * 0.001 * 19.0) * 0.01;
		pmove->velocity[2] *= flRatio;
	}

	pmove->fuser2 = 1315.789429;

	// Decay it for simulation
	PM_FixupGravityVelocity();

	// Flag that we jumped.
	// don't jump again until released
	pmove->oldbuttons |= IN_JUMP;
}

void PM_CheckWaterJump()
{
	vec3_t vecStart, vecEnd;
	vec3_t flatforward;
	vec3_t flatvelocity;
	float curspeed;
	pmtrace_t tr;
	int savehull;

	// Already water jumping.
	if (pmove->waterjumptime)
		return;

	// Don't hop out if we just jumped in
	if (pmove->velocity[2] < -180)
	{
		// only hop out if we are moving up
		return;
	}

	// See if we are backing up
	flatvelocity[0] = pmove->velocity[0];
	flatvelocity[1] = pmove->velocity[1];
	flatvelocity[2] = 0;

	// Must be moving
	curspeed = VectorNormalize(flatvelocity);

	// see if near an edge
	flatforward[0] = pmove->forward[0];
	flatforward[1] = pmove->forward[1];
	flatforward[2] = 0;
	VectorNormalize(flatforward);

	// Are we backing into water from steps or something?  If so, don't pop forward
	if (curspeed != 0.0 && (DotProduct(flatvelocity, flatforward) < 0.0))
	{
		return;
	}

	VectorCopy(pmove->origin, vecStart);
	vecStart[2] += WJ_HEIGHT;

	VectorMA(vecStart, 24, flatforward, vecEnd);

	// Trace, this trace should use the point sized collision hull
	savehull = pmove->usehull;
	pmove->usehull = 2;

	tr = pmove->PM_PlayerTrace(vecStart, vecEnd, PM_NORMAL, -1);

	// Facing a near vertical wall?
	if (tr.fraction < 1.0f && fabs(float(tr.plane.normal[2])) < 0.1f)
	{
		vecStart[2] += pmove->player_maxs[savehull][2] - WJ_HEIGHT;

		VectorMA(vecStart, 24, flatforward, vecEnd);
		VectorMA(vec3_origin, -50, tr.plane.normal, pmove->movedir);

		tr = pmove->PM_PlayerTrace(vecStart, vecEnd, PM_NORMAL, -1);

		if (tr.fraction == 1.0f)
		{
			pmove->waterjumptime = 2000.0f;
			pmove->velocity[2] = 225.0f;

			pmove->oldbuttons |= IN_JUMP;
			pmove->flags |= FL_WATERJUMP;
		}
	}

	// Reset the collision hull
	pmove->usehull = savehull;
}

void PM_CheckFalling()
{
	if (pmove->onground != -1 && !pmove->dead && pmove->flFallVelocity >= PM_PLAYER_FALL_PUNCH_THRESHHOLD)
	{
		float fvol = 0.5f;

		if (pmove->waterlevel <= 0)
		{
			if (pmove->flFallVelocity > PM_PLAYER_MAX_SAFE_FALL_SPEED)
			{
				fvol = 1.0f;
			}
			else if (pmove->flFallVelocity > PM_PLAYER_MAX_SAFE_FALL_SPEED / 2)
			{
				fvol = 0.85f;
			}
			else if (pmove->flFallVelocity < PM_PLAYER_MIN_BOUNCE_SPEED)
			{
				fvol = 0.0f;
			}
		}

		if (fvol > 0.0f)
		{
			PM_CatagorizeTextureType();

			// play step sound for current texture
			PM_PlayStepSound(PM_MapTextureTypeStepType(pmove->chtexturetype), fvol);

			pmove->flTimeStepSound = 300;

			// Knock the screen around a little bit, temporary effect
			// punch z axis
			pmove->punchangle[2] = pmove->flFallVelocity * 0.013;

			if (pmove->punchangle[0] > 8.0f)
			{
				pmove->punchangle[0] = 8.0f;
			}
		}
	}

	if (pmove->onground != -1)
	{
		pmove->flFallVelocity = 0;
	}
}

void PM_PlayWaterSounds()
{
	// Did we enter or leave water?
	if (pmove->oldwaterlevel != 0)
	{
		if (pmove->waterlevel != 0)
			return;
	}
	else
	{
		if (pmove->waterlevel == 0)
			return;
	}

	switch (pmove->RandomLong(0, 3))
	{
	case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade1.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
	case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade2.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
	case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade3.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
	case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade4.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
	}
}

float PM_CalcRoll(vec_t *angles, vec_t *velocity, float rollangle, float rollspeed)
{
	float sign;
	float side;
	float value;
	vec3_t forward, right, up;

	AngleVectors(angles, forward, right, up);

	side = DotProduct(velocity, right);
	sign = side < 0 ? -1 : 1;
	side = fabs(side);

	value = rollangle;

	if (side < rollspeed)
	{
		side = side * value / rollspeed;
	}
	else
	{
		side = value;
	}

	return side * sign;
}

void PM_DropPunchAngle(vec_t *punchangle)
{
	float len;

	len = VectorNormalize(punchangle);
	len -= (10.0 + len * 0.5) * pmove->frametime;
	len = max(len, 0.0f);

	VectorScale(punchangle, len, punchangle);
}

void PM_CheckParameters()
{
	float spd;
	float maxspeed;
	vec3_t v_angle;

	spd =  sqrt(float(pmove->cmd.sidemove * pmove->cmd.sidemove + pmove->cmd.forwardmove * pmove->cmd.forwardmove + pmove->cmd.upmove * pmove->cmd.upmove));

	maxspeed = pmove->clientmaxspeed;

	if (maxspeed != 0.0f)
	{
		pmove->maxspeed = min(maxspeed, float(pmove->maxspeed));
	}

	if (spd != 0.0f && spd > float(pmove->maxspeed))
	{
		float fRatio = pmove->maxspeed / spd;

		pmove->cmd.forwardmove *= fRatio;
		pmove->cmd.sidemove *= fRatio;
		pmove->cmd.upmove *= fRatio;
	}

	if ((pmove->flags & (FL_FROZEN | FL_ONTRAIN)) || pmove->dead)
	{
		pmove->cmd.forwardmove = 0;
		pmove->cmd.sidemove = 0;
		pmove->cmd.upmove = 0;
	}

	PM_DropPunchAngle(pmove->punchangle);

	// Take angles from command.
	if (!pmove->dead)
	{
		VectorCopy(pmove->cmd.viewangles, v_angle);
		VectorAdd(v_angle, pmove->punchangle, v_angle);

		// Set up view angles.
		pmove->angles[ROLL] = PM_CalcRoll(v_angle, pmove->velocity, pmove->movevars->rollangle, pmove->movevars->rollspeed) * 4;
		pmove->angles[PITCH] = v_angle[PITCH];
		pmove->angles[YAW] = v_angle[YAW];
	}
	else
	{
		VectorCopy(pmove->oldangles, pmove->angles);
	}

	// Set dead player view_offset
	if (pmove->dead)
	{
		if (pmove->bInDuck)
		{
			PM_UnDuck();
			pmove->bInDuck = FALSE;
		}

		pmove->view_ofs[2] = PM_DEAD_VIEWHEIGHT;
	}

	// Adjust client view angles to match values used on server.
	if (pmove->angles[YAW] > 180.0f)
	{
		pmove->angles[YAW] -= 360.0f;
	}
}

void PM_ReduceTimers()
{
	if (pmove->flTimeStepSound > 0)
	{
		pmove->flTimeStepSound -= pmove->cmd.msec;

		if (pmove->flTimeStepSound < 0)
		{
			pmove->flTimeStepSound = 0;
		}
	}

	if (pmove->flDuckTime > 0)
	{
		pmove->flDuckTime -= pmove->cmd.msec;

		if (pmove->flDuckTime < 0)
		{
			pmove->flDuckTime = 0;
		}
	}

	if (pmove->flSwimTime > 0)
	{
		pmove->flSwimTime -= pmove->cmd.msec;

		if (pmove->flSwimTime < 0)
		{
			pmove->flSwimTime = 0;
		}
	}

	if (pmove->fuser2 > 0.0)
	{
		pmove->fuser2 -= pmove->cmd.msec;

		if (pmove->fuser2 < 0.0)
		{
			pmove->fuser2 = 0;
		}
	}
}

qboolean PM_ShouldDoSpectMode()
{
	return (pmove->iuser3 <= 0 || pmove->deadflag == DEAD_DEAD);
}

// Returns with origin, angles, and velocity modified in place.
// Numtouch and touchindex[] will be set if any of the physents
// were contacted during the move.

void PM_PlayerMove(qboolean server)
{
	physent_t *pLadder = nullptr;

	// Are we running server code?
	pmove->server = server;

	// Adjust speeds etc.
	PM_CheckParameters();

	// Assume we don't touch anything
	pmove->numtouch = 0;

	// # of msec to apply movement

	//double v2 = (double)pmove->cmd.msec * 0.001;
	pmove->frametime = pmove->cmd.msec * 0.001;

	PM_ReduceTimers();

	// Convert view angles to vectors
	AngleVectors(pmove->angles, pmove->forward, pmove->right, pmove->up);

	//PM_ShowClipBox();

	// Special handling for spectator and observers. (iuser1 is set if the player's in observer mode)
	if ((pmove->spectator || pmove->iuser1 > 0) && PM_ShouldDoSpectMode())
	{
		PM_SpectatorMove();
		PM_CategorizePosition();
		return;
	}

	// Always try and unstick us unless we are in NOCLIP mode
	if (pmove->movetype != MOVETYPE_NOCLIP && pmove->movetype != MOVETYPE_NONE)
	{
		if (PM_CheckStuck())
		{
			// Can't move, we're stuck
			return;
		}
	}

	// Now that we are "unstuck", see where we are (waterlevel and type, pmove->onground).
	PM_CategorizePosition();

	// Store off the starting water level
	pmove->oldwaterlevel = pmove->waterlevel;

	// If we are not on ground, store off how fast we are moving down
	if (pmove->onground == -1)
	{
		pmove->flFallVelocity = -pmove->velocity[2];
	}

	g_onladder = FALSE;

	// Don't run ladder code if dead or on a train
	if (!pmove->dead && !(pmove->flags & FL_ONTRAIN))
	{
		pLadder = PM_Ladder();

		if (pLadder)
		{
			g_onladder = TRUE;
		}
	}

	PM_Duck();
	PM_UpdateStepSound();

	// Don't run ladder code if dead or on a train
	if (!pmove->dead && !(pmove->flags & FL_ONTRAIN))
	{
		if (pLadder)
		{
			PM_LadderMove(pLadder);
		}
		else if (pmove->movetype != MOVETYPE_WALK && pmove->movetype != MOVETYPE_NOCLIP)
		{
			// Clear ladder stuff unless player is noclipping
			// it will be set immediately again next frame if necessary
			pmove->movetype = MOVETYPE_WALK;
		}
	}

	// Handle movement
	switch (pmove->movetype)
	{
	default:
		pmove->Con_DPrintf("Bogus pmove player movetype %i on (%i) 0=cl 1=sv\n", pmove->movetype, pmove->server);
		break;

	case MOVETYPE_NONE:
		break;

	case MOVETYPE_NOCLIP:
		PM_NoClip();
		break;

	case MOVETYPE_TOSS:
	case MOVETYPE_BOUNCE:
		PM_Physics_Toss();
		break;

	case MOVETYPE_FLY:
		PM_CheckWater();

		// Was jump button pressed?
		// If so, set velocity to 270 away from ladder.  This is currently wrong.
		// Also, set MOVE_TYPE to walk, too.
		if (pmove->cmd.buttons & IN_JUMP)
		{
			if (!pLadder)
			{
				PM_Jump();
			}
		}
		else
		{
			pmove->oldbuttons &= ~IN_JUMP;
		}

		// Perform the move accounting for any base velocity.
		VectorAdd(pmove->velocity, pmove->basevelocity, pmove->velocity);
		PM_FlyMove();
		VectorSubtract(pmove->velocity, pmove->basevelocity, pmove->velocity);
		break;

	case MOVETYPE_WALK:
		if (!PM_InWater())
		{
			PM_AddCorrectGravity();
		}

		// If we are leaping out of the water, just update the counters.
		if (pmove->waterjumptime != 0.0f)
		{
			PM_WaterJump();
			PM_FlyMove();

			// Make sure waterlevel is set correctly
			PM_CheckWater();
			return;
		}

		// If we are swimming in the water, see if we are nudging against a place we can jump up out
		//  of, and, if so, start out jump.  Otherwise, if we are not moving up, then reset jump timer to 0
		if (pmove->waterlevel >= 2)
		{
			if (pmove->waterlevel == 2)
			{
				PM_CheckWaterJump();
			}

			// If we are falling again, then we must not trying to jump out of water any more.
			if (pmove->velocity[2] < 0 && pmove->waterjumptime)
			{
				pmove->waterjumptime = 0;
			}

			// Was jump button pressed?
			if (pmove->cmd.buttons & IN_JUMP)
			{
				PM_Jump();
			}
			else
			{
				pmove->oldbuttons &= ~IN_JUMP;
			}

			// Perform regular water movement
			PM_WaterMove();

			VectorSubtract(pmove->velocity, pmove->basevelocity, pmove->velocity);

			// Get a final position
			PM_CategorizePosition();
		}
		// Not underwater
		else
		{
			// Was jump button pressed?
			if (pmove->cmd.buttons & IN_JUMP)
			{
				if (!pLadder)
				{
					PM_Jump();
				}
			}
			else
			{
				pmove->oldbuttons &= ~IN_JUMP;
			}

			// Fricion is handled before we add in any base velocity. That way, if we are on a conveyor,
			// we don't slow when standing still, relative to the conveyor.
			if (pmove->onground != -1)
			{
				pmove->velocity[2] = 0;
				PM_Friction();
			}

			// Make sure velocity is valid.
			PM_CheckVelocity();

			// Are we on ground now
			if (pmove->onground != -1)
			{
				PM_WalkMove();
			}
			else
			{
				// Take into account movement when in air.
				PM_AirMove();
			}

			// Set final flags.
			PM_CategorizePosition();

			// Now pull the base velocity back out.
			// Base velocity is set if you are on a moving object, like
			// a conveyor (or maybe another monster?)
			VectorSubtract(pmove->velocity, pmove->basevelocity, pmove->velocity);

			// Make sure velocity is valid.
			PM_CheckVelocity();

			// Add any remaining gravitational component.
			if (!PM_InWater())
			{
				PM_FixupGravityVelocity();
			}

			// If we are on ground, no downward velocity.
			if (pmove->onground != -1)
			{
				pmove->velocity[2] = 0;
			}

			// See if we landed on the ground with enough force to play a landing sound.
			PM_CheckFalling();
		}

		// Did we enter or leave the water?
		PM_PlayWaterSounds();
		break;
	}
}

void PM_CreateStuckTable()
{
	float x, y, z;

	int idx;
	int i;
	float zi[3];

	memset(rgv3tStuckTable, 0, sizeof(rgv3tStuckTable));

	idx = 0;

	// Little Moves.
	x = 0;
	y = 0;

	// Z moves
	for (z = -0.125; z <= 0.125; z += 0.125)
	{
		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	x = 0;
	z = 0;
	// Y moves
	for (y = -0.125; y <= 0.125; y += 0.125)
	{
		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	y = 0;
	z = 0;
	// X moves
	for (x = -0.125; x <= 0.125; x += 0.125)
	{
		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	// Remaining multi axis nudges.
	for (x = -0.125; x <= 0.125; x += 0.250)
	{
		for (y = -0.125; y <= 0.125; y += 0.250)
		{
			for (z = -0.125; z <= 0.125; z += 0.250)
			{
				rgv3tStuckTable[idx][0] = x;
				rgv3tStuckTable[idx][1] = y;
				rgv3tStuckTable[idx][2] = z;

				idx++;
			}
		}
	}

	// Big Moves.
	x = 0;
	y = 0;

	zi[0] = 0.0f;
	zi[1] = 1.0f;
	zi[2] = 6.0f;

	for (i = 0; i < 3; i++)
	{
		// Z moves
		z = zi[i];

		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	x = 0;
	z = 0;

	// Y moves
	for (y = -2.0f; y <= 2.0f; y += 2.0)
	{
		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	y = 0;
	z = 0;

	// X moves
	for (x = -2.0f; x <= 2.0f; x += 2.0f)
	{
		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	// Remaining multi axis nudges.
	for (i = 0; i < 3; i++)
	{
		z = zi[i];

		for (x = -2.0f; x <= 2.0f; x += 2.0f)
		{
			for (y = -2.0f; y <= 2.0f; y += 2.0)
			{
				rgv3tStuckTable[idx][0] = x;
				rgv3tStuckTable[idx][1] = y;
				rgv3tStuckTable[idx][2] = z;

				idx++;
			}
		}
	}
}

// This module implements the shared player physics code between any particular game and
// the engine. The same PM_Move routine is built into the game .dll and the client .dll and is
// invoked by each side as appropriate. There should be no distinction, internally, between server
// and client. This will ensure that prediction behaves appropriately.

void PM_Move(playermove_t *ppmove, int server)
{
#if 0
	assert(pm_shared_initialized);
#endif
	pmove = ppmove;

	PM_PlayerMove((server != 0) ? TRUE : FALSE);

	if (pmove->onground != -1)
		pmove->flags |= FL_ONGROUND;
	else
		pmove->flags &= ~FL_ONGROUND;

	if (!pmove->multiplayer && pmove->movetype == MOVETYPE_WALK)
	{
		pmove->friction = 1.0f;
	}
}

int PM_GetVisEntInfo(int ent)
{
	if (ent >= 0 && ent <= pmove->numvisent)
	{
		return pmove->visents[ent].info;
	}

	return -1;
}

int PM_GetPhysEntInfo(int ent)
{
	if (ent >= 0 && ent <= pmove->numphysent)
	{
		return pmove->physents[ent].info;
	}

	return -1;
}

void PM_Init( playermove_t *ppmove)
{
#if 0
	assert(!pm_shared_initialized);
#endif
	pmove = ppmove;

	PM_CreateStuckTable();
	PM_InitTextureTypes();

	pm_shared_initialized = TRUE;
}

```

`pm_shared/pm_shared.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_SHARED_H
#define PM_SHARED_H
#ifdef _WIN32
#pragma once
#endif

#include "pmtrace.h"
#include "pm_defs.h"

#define MAX_CLIENTS			32

#define PM_DEAD_VIEWHEIGHT		-8

#define OBS_NONE			0
#define OBS_CHASE_LOCKED		1
#define OBS_CHASE_FREE			2
#define OBS_ROAMING			3
#define OBS_IN_EYE			4
#define OBS_MAP_FREE			5
#define OBS_MAP_CHASE			6

#define STEP_CONCRETE			0
#define STEP_METAL			1
#define STEP_DIRT			2
#define STEP_VENT			3
#define STEP_GRATE			4
#define STEP_TILE			5
#define STEP_SLOSH			6
#define STEP_WADE			7
#define STEP_LADDER			8
#define STEP_SNOW			9

#define WJ_HEIGHT				8
#define	STOP_EPSILON				0.1
#define MAX_CLIMB_SPEED				200
#define PLAYER_DUCKING_MULTIPLIER		0.333
#define PM_CHECKSTUCK_MINTIME			0.05	// Don't check again too quickly.

#define PLAYER_LONGJUMP_SPEED			350.0f	// how fast we longjump

// Ducking time
#define TIME_TO_DUCK				0.4
#define STUCK_MOVEUP				1

#define PM_VEC_DUCK_HULL_MIN			-18
#define PM_VEC_HULL_MIN				-36
#define PM_VEC_DUCK_VIEW			12
#define PM_VEC_VIEW				17

#define PM_PLAYER_MAX_SAFE_FALL_SPEED		580	// approx 20 feet
#define PM_PLAYER_MIN_BOUNCE_SPEED		350
#define PM_PLAYER_FALL_PUNCH_THRESHHOLD		250	// won't punch player's screen/make scrape noise unless player falling at least this fast.

// Only allow bunny jumping up to 1.2x server / player maxspeed setting
#define BUNNYJUMP_MAX_SPEED_FACTOR		1.2f

void PM_SwapTextures(int i, int j);
int PM_IsThereGrassTexture();
void PM_SortTextures();
void PM_InitTextureTypes();
char PM_FindTextureType(char *name);
void PM_PlayStepSound(int step, float fvol);
int PM_MapTextureTypeStepType(char chTextureType);
void PM_CatagorizeTextureType();
void PM_UpdateStepSound();
qboolean PM_AddToTouched(pmtrace_t tr, vec_t *impactvelocity);
void PM_CheckVelocity();
int PM_ClipVelocity(vec_t *in, vec_t *normal, vec_t *out, float overbounce);
void PM_AddCorrectGravity();
void PM_FixupGravityVelocity();
int PM_FlyMove();
void PM_Accelerate(vec_t *wishdir, float wishspeed, float accel);
void PM_WalkMove();
void PM_Friction();
void PM_AirAccelerate(vec_t *wishdir, float wishspeed, float accel);
void PM_WaterMove();
void PM_AirMove();
qboolean PM_InWater();
qboolean PM_CheckWater();
void PM_CatagorizePosition();
int PM_GetRandomStuckOffsets(int nIndex, int server, vec_t *offset);
void PM_ResetStuckOffsets(int nIndex, int server);
int PM_CheckStuck();
void PM_SpectatorMove();
float PM_SplineFraction(float value, float scale);
float PM_SimpleSpline(float value);
void PM_FixPlayerCrouchStuck(int direction);
void PM_Duck();
void PM_LadderMove(physent_t *pLadder);
physent_t *PM_Ladder();
void PM_WaterJump();
void PM_AddGravity();
pmtrace_t PM_PushEntity(vec_t *push);
void PM_Physics_Toss();
void PM_NoClip();
void PM_PreventMegaBunnyJumping();
void PM_Jump();
void PM_CheckWaterJump();
void PM_CheckFalling();
void PM_PlayWaterSounds();
float PM_CalcRoll(vec_t *angles, vec_t *velocity, float rollangle, float rollspeed);
void PM_DropPunchAngle(vec_t *punchangle);
void PM_CheckParamters();
void PM_ReduceTimers();
qboolean PM_ShouldDoSpectMode();
void PM_PlayerMove(qboolean server);
void PM_CreateStuckTable();
void PM_Move(playermove_t *ppmove, int server);
int PM_GetVisEntInfo(int ent);
int PM_GetPhysEntInfo(int ent);
void PM_Init(playermove_t *ppmove);

extern playermove_t *pmove;

#endif // PM_SHARED_H

```

`public/build.h`:

```h
/*
build.h - compile-time build information

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>
*/
#pragma once
#ifndef BUILD_H
#define BUILD_H

/*
All XASH_* macros set by this header are guaranteed to have positive value
otherwise not defined.

Every macro is intended to be the unified interface for buildsystems that lack
platform & CPU detection, and a neat quick way for checks in platform code
For Q_build* macros, refer to buildenums.h

Any new define must be undefined at first
You can generate #undef list below with this oneliner:
  $ sed 's/\t//g' build.h | grep '^#define XASH' | awk '{ print $2 }' | \
		sort | uniq | awk '{ print "#undef " $1 }'

Then you can use another oneliner to query all variables:
  $ grep '^#undef XASH' build.h | awk '{ print $2 }'
*/

#undef XASH_64BIT
#undef XASH_AMD64
#undef XASH_ANDROID
#undef XASH_APPLE
#undef XASH_ARM
#undef XASH_ARM_HARDFP
#undef XASH_ARM_SOFTFP
#undef XASH_ARMv4
#undef XASH_ARMv5
#undef XASH_ARMv6
#undef XASH_ARMv7
#undef XASH_ARMv8
#undef XASH_BIG_ENDIAN
#undef XASH_DOS4GW
#undef XASH_E2K
#undef XASH_EMSCRIPTEN
#undef XASH_FREEBSD
#undef XASH_HAIKU
#undef XASH_IOS
#undef XASH_IRIX
#undef XASH_JS
#undef XASH_LINUX
#undef XASH_LITTLE_ENDIAN
#undef XASH_MIPS
#undef XASH_MOBILE_PLATFORM
#undef XASH_NETBSD
#undef XASH_OPENBSD
#undef XASH_POSIX
#undef XASH_PPC
#undef XASH_RISCV
#undef XASH_RISCV_DOUBLEFP
#undef XASH_RISCV_SINGLEFP
#undef XASH_RISCV_SOFTFP
#undef XASH_SERENITY
#undef XASH_SUNOS
#undef XASH_TERMUX
#undef XASH_WIN32
#undef XASH_X86
#undef XASH_NSWITCH
#undef XASH_PSVITA
#undef XASH_WASI
#undef XASH_WASM

//================================================================
//
//           PLATFORM DETECTION CODE
//
//================================================================
#if defined _WIN32
	#define XASH_WIN32 1
#elif defined __WATCOMC__ && defined __DOS__
	#define XASH_DOS4GW 1
#else // POSIX compatible
	#define XASH_POSIX 1
	#if defined __linux__
		#if defined __ANDROID__
			#define XASH_ANDROID 1
			#if defined __TERMUX__
				#define XASH_TERMUX 1
			#endif
		#endif
		#define XASH_LINUX 1
	#elif defined __FreeBSD__
		#define XASH_FREEBSD 1
	#elif defined __NetBSD__
		#define XASH_NETBSD 1
	#elif defined __OpenBSD__
		#define XASH_OPENBSD 1
	#elif defined __HAIKU__
		#define XASH_HAIKU 1
	#elif defined __serenity__
		#define XASH_SERENITY 1
	#elif defined __sgi
		#define XASH_IRIX 1
	#elif defined __APPLE__
		#include <TargetConditionals.h>
		#define XASH_APPLE 1
		#if TARGET_OS_IOS
			#define XASH_IOS 1
		#endif // TARGET_OS_IOS
	#elif defined __SWITCH__
		#define XASH_NSWITCH 1
	#elif defined __vita__
		#define XASH_PSVITA 1
	#elif defined __wasi__
		#define XASH_WASI 1
	#elif defined __sun__
		#define XASH_SUNOS 1
	#elif defined __EMSCRIPTEN__
		#define XASH_EMSCRIPTEN 1
	#else
		#error
	#endif
#endif

// XASH_SAILFISH is special: SailfishOS by itself is a normal GNU/Linux platform
// It doesn't make sense to split it to separate platform
// but we still need XASH_MOBILE_PLATFORM for the engine.
// So this macro is defined entirely in build-system: see main wscript
// HLSDK/PrimeXT/other SDKs users note: you may ignore this macro
#if ( XASH_ANDROID && !XASH_TERMUX ) || XASH_IOS || XASH_NSWITCH || XASH_PSVITA || XASH_SAILFISH
	#define XASH_MOBILE_PLATFORM 1
#endif

//================================================================
//
//           ENDIANNESS DEFINES
//
//================================================================

#if !defined XASH_ENDIANNESS
	#if defined XASH_WIN32 || __LITTLE_ENDIAN__
		//!!! Probably all WinNT installations runs in little endian
		#define XASH_LITTLE_ENDIAN 1
	#elif __BIG_ENDIAN__
		#define XASH_BIG_ENDIAN 1
	#elif defined __BYTE_ORDER__ && defined __ORDER_BIG_ENDIAN__ && defined __ORDER_LITTLE_ENDIAN__ // some compilers define this
		#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			#define XASH_BIG_ENDIAN 1
		#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			#define XASH_LITTLE_ENDIAN 1
		#endif
	#else
		#include <sys/param.h>
		#if __BYTE_ORDER == __BIG_ENDIAN
			#define XASH_BIG_ENDIAN 1
		#elif __BYTE_ORDER == __LITTLE_ENDIAN
			#define XASH_LITTLE_ENDIAN 1
		#endif
	#endif // !XASH_WIN32
#endif

//================================================================
//
//           CPU ARCHITECTURE DEFINES
//
//================================================================
#if defined __x86_64__ || defined _M_X64
	#define XASH_64BIT 1
	#define XASH_AMD64 1
#elif defined __i386__ || defined _X86_ || defined _M_IX86
	#define XASH_X86 1
#elif defined __aarch64__ || defined _M_ARM64
	#define XASH_64BIT 1
	#define XASH_ARM   8
#elif defined __mips__
	#define XASH_MIPS 1
// commented out to avoid misdetection, modern Emscripten versions target WASM only
//#elif defined __EMSCRIPTEN__
//	#define XASH_JS 1
#elif defined __e2k__
	#define XASH_64BIT 1
	#define XASH_E2K 1
#elif defined __PPC__ || defined __powerpc__
	#define XASH_PPC 1
	#if defined __PPC64__ || defined __powerpc64__
		#define XASH_64BIT 1
	#endif
#elif defined _M_ARM // msvc
	#define XASH_ARM 7
	#define XASH_ARM_HARDFP 1
#elif defined __arm__
	#if __ARM_ARCH == 8 || __ARM_ARCH_8__
		#define XASH_ARM 8
	#elif __ARM_ARCH == 7 || __ARM_ARCH_7__
		#define XASH_ARM 7
	#elif __ARM_ARCH == 6 || __ARM_ARCH_6__ || __ARM_ARCH_6J__
		#define XASH_ARM 6
	#elif __ARM_ARCH == 5 || __ARM_ARCH_5__
		#define XASH_ARM 5
	#elif __ARM_ARCH == 4 || __ARM_ARCH_4__
		#define XASH_ARM 4
	#else
		#error "Unknown ARM"
	#endif

	#if defined __SOFTFP__ || __ARM_PCS_VFP == 0
		#define XASH_ARM_SOFTFP 1
	#else // __SOFTFP__
		#define XASH_ARM_HARDFP 1
	#endif // __SOFTFP__
#elif defined __riscv
	#define XASH_RISCV 1

	#if __riscv_xlen == 64
		#define XASH_64BIT 1
	#elif __riscv_xlen != 32
		#error "Unknown RISC-V ABI"
	#endif

	#if defined __riscv_float_abi_soft
		#define XASH_RISCV_SOFTFP 1
	#elif defined __riscv_float_abi_single
		#define XASH_RISCV_SINGLEFP 1
	#elif defined __riscv_float_abi_double
		#define XASH_RISCV_DOUBLEFP 1
	#else
		#error "Unknown RISC-V float ABI"
	#endif
#elif defined __wasm__
	#if defined __wasm64__
		#define XASH_64BIT 1
	#endif
	#define XASH_WASM 1
#else
	#error "Place your architecture name here! If this is a mistake, try to fix conditions above and report a bug"
#endif

#if !XASH_64BIT && ( defined( __LP64__ ) || defined( _LP64 ))
#define XASH_64BIT 1
#endif

#if XASH_ARM == 8
	#define XASH_ARMv8 1
#elif XASH_ARM == 7
	#define XASH_ARMv7 1
#elif XASH_ARM == 6
	#define XASH_ARMv6 1
#elif XASH_ARM == 5
	#define XASH_ARMv5 1
#elif XASH_ARM == 4
	#define XASH_ARMv4 1
#endif

#endif // BUILD_H

```

`public/tier1/UtlMemory.h`:

```h
//=========== (C) Copyright 1999 Valve, L.L.C. All rights reserved. ===========
//
// The copyright to the contents herein is the property of Valve, L.L.C.
// The contents may be used and/or copied only with the written permission of
// Valve, L.L.C., or in accordance with the terms and conditions stipulated in
// the agreement/contract under which the contents have been supplied.
//
// $Header: $
// $NoKeywords: $
//
// A growable memory class.
//=============================================================================
#pragma once
#ifndef UTLMEMORY_H
#define UTLMEMORY_H

#include <string.h>
#include <new>
#include <stdlib.h>
#include <stdarg.h>
#include <assert.h>

#ifdef _MSC_VER
#pragma warning (disable:4100)
#pragma warning (disable:4514)
#endif

//-----------------------------------------------------------------------------
// Methods to invoke the constructor, copy constructor, and destructor
//-----------------------------------------------------------------------------

template <class T> 
inline void Construct( T* pMemory )
{
	::new( pMemory ) T;
}

template <class T> 
inline void CopyConstruct( T* pMemory, T const& src )
{
	::new( pMemory ) T(src);
}

template <class T> 
inline void Destruct( T* pMemory )
{
	pMemory->~T();

#ifdef _DEBUG
	memset( pMemory, 0xDD, sizeof(T) );
#endif
}


















//-----------------------------------------------------------------------------
// The CUtlMemory class:
// A growable memory class which doubles in size by default.
//-----------------------------------------------------------------------------
template< class T >
class CUtlMemory
{
public:
	// constructor, destructor
	CUtlMemory( int nGrowSize = 0, int nInitSize = 0 );
	CUtlMemory( T* pMemory, int numElements );
	CUtlMemory( const T* pMemory, int numElements );
	~CUtlMemory();

	// element access
	T& operator[]( int i );
	T const& operator[]( int i ) const;
	T& Element( int i );
	T const& Element( int i ) const;

	// Can we use this index?
	bool IsIdxValid( int i ) const;

	// Gets the base address (can change when adding elements!)
	T* Base();
	T const* Base() const;

	// Attaches the buffer to external memory....
	void SetExternalBuffer( T* pMemory, int numElements );

	// Size
	int NumAllocated() const;
	int Count() const;

	// Grows the memory, so that at least allocated + num elements are allocated
	void Grow( int num = 1 );

	// Makes sure we've got at least this much memory
	void EnsureCapacity( int num );

	// Memory deallocation
	void Purge();

	// is the memory externally allocated?
	bool IsExternallyAllocated() const;

	// is the memory read only?
	bool IsReadOnly() const;

	// Set the size by which the memory grows
	void SetGrowSize( int size );

private:
	enum
	{
		EXTERNAL_BUFFER_MARKER = -1,
		EXTERNAL_CONST_BUFFER_MARKER = 2,
	};

	T* m_pMemory;
	int m_nAllocationCount;
	int m_nGrowSize;
};


//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
template< class T >
CUtlMemory<T>::CUtlMemory( int nGrowSize, int nInitAllocationCount ) : m_pMemory(0), 
	m_nAllocationCount( nInitAllocationCount ), m_nGrowSize( nGrowSize )
{
	assert( (nGrowSize >= 0) && (nGrowSize != EXTERNAL_BUFFER_MARKER) );
	if (m_nAllocationCount)
	{
		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );
	}
}

template< class T >
CUtlMemory<T>::CUtlMemory( T* pMemory, int numElements ) : m_pMemory(pMemory),
	m_nAllocationCount( numElements )
{
	// Special marker indicating externally supplied memory
	m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template< class T >
CUtlMemory<T>::CUtlMemory( const T* pMemory, int numElements ) : m_pMemory( (T*)pMemory ),
	m_nAllocationCount( numElements )
{
	// Special marker indicating externally supplied modifyable memory
	m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template< class T >
CUtlMemory<T>::~CUtlMemory()
{
	Purge();
}


//-----------------------------------------------------------------------------
// Attaches the buffer to external memory....
//-----------------------------------------------------------------------------
template< class T >
void CUtlMemory<T>::SetExternalBuffer( T* pMemory, int numElements )
{
	// Blow away any existing allocated memory
	Purge();

	m_pMemory = pMemory;
	m_nAllocationCount = numElements;

	// Indicate that we don't own the memory
	m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}


//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template< class T >
inline T& CUtlMemory<T>::operator[]( int i )
{
	assert( IsIdxValid(i) );
	return m_pMemory[i];
}

template< class T >
inline T const& CUtlMemory<T>::operator[]( int i ) const
{
	assert( IsIdxValid(i) );
	return m_pMemory[i];
}

template< class T >
inline T& CUtlMemory<T>::Element( int i )
{
	assert( IsIdxValid(i) );
	return m_pMemory[i];
}

template< class T >
inline T const& CUtlMemory<T>::Element( int i ) const
{
	assert( IsIdxValid(i) );
	return m_pMemory[i];
}


//-----------------------------------------------------------------------------
// is the memory externally allocated?
//-----------------------------------------------------------------------------
template< class T >
bool CUtlMemory<T>::IsExternallyAllocated() const
{
	return m_nGrowSize == EXTERNAL_BUFFER_MARKER;
}

//-----------------------------------------------------------------------------
// is the memory read only?
//-----------------------------------------------------------------------------
template< class T >
bool CUtlMemory<T>::IsReadOnly() const
{
	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);
}

template< class T >
void CUtlMemory<T>::SetGrowSize( int nSize )
{
	assert( (nSize >= 0) && (nSize != EXTERNAL_BUFFER_MARKER) );
	m_nGrowSize = nSize;
}


//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------
template< class T >
inline T* CUtlMemory<T>::Base()
{
	return m_pMemory;
}

template< class T >
inline T const* CUtlMemory<T>::Base() const
{
	return m_pMemory;
}


//-----------------------------------------------------------------------------
// Size
//-----------------------------------------------------------------------------
template< class T >
inline int CUtlMemory<T>::NumAllocated() const
{
	return m_nAllocationCount;
}

template< class T >
inline int CUtlMemory<T>::Count() const
{
	return m_nAllocationCount;
}


//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template< class T >
inline bool CUtlMemory<T>::IsIdxValid( int i ) const
{
	return (i >= 0) && (i < m_nAllocationCount);
}
 

//-----------------------------------------------------------------------------
// Grows the memory
//-----------------------------------------------------------------------------
template< class T >
void CUtlMemory<T>::Grow( int num )
{
	assert( num > 0 );

	if (IsExternallyAllocated())
	{
		// Can't grow a buffer whose memory was externally allocated 
		assert(0);
		return;
	}

	// Make sure we have at least numallocated + num allocations.
	// Use the grow rules specified for this memory (in m_nGrowSize)
	int nAllocationRequested = m_nAllocationCount + num;
	while (m_nAllocationCount < nAllocationRequested)
	{
		if ( m_nAllocationCount != 0 )
		{
			if (m_nGrowSize)
			{
				m_nAllocationCount += m_nGrowSize;
			}
			else
			{
				m_nAllocationCount += m_nAllocationCount;
			}
		}
		else
		{
			// Compute an allocation which is at least as big as a cache line...
			m_nAllocationCount = (31 + sizeof(T)) / sizeof(T);
			assert(m_nAllocationCount != 0);
		}
	}

	if (m_pMemory)
	{
		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );
	}
	else
	{
		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );
	}
}


//-----------------------------------------------------------------------------
// Makes sure we've got at least this much memory
//-----------------------------------------------------------------------------
template< class T >
inline void CUtlMemory<T>::EnsureCapacity( int num )
{
	if (m_nAllocationCount >= num)
		return;

	if (IsExternallyAllocated())
	{
		// Can't grow a buffer whose memory was externally allocated 
		assert(0);
		return;
	}

	m_nAllocationCount = num;
	if (m_pMemory)
	{
		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );
	}
	else
	{
		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );
	}
}


//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------
template< class T >
void CUtlMemory<T>::Purge()
{
	if (!IsExternallyAllocated())
	{
		if (m_pMemory)
		{
			free( (void*)m_pMemory );
			m_pMemory = 0;
		}
		m_nAllocationCount = 0;
	}
}


#endif // UTLSTORAGE_H

```

`public/tier1/UtlVector.h`:

```h
//=========== (C) Copyright 1999 Valve, L.L.C. All rights reserved. ===========
//
// The copyright to the contents herein is the property of Valve, L.L.C.
// The contents may be used and/or copied only with the written permission of
// Valve, L.L.C., or in accordance with the terms and conditions stipulated in
// the agreement/contract under which the contents have been supplied.
//
// $Header: $
// $NoKeywords: $
//
// A growable array class that maintains a free list and keeps elements
// in the same location
//=============================================================================

#ifndef UTLVECTOR_H
#define UTLVECTOR_H

#ifdef _WIN32
#pragma once
#endif

#include "UtlMemory.h"

//-----------------------------------------------------------------------------
// The CUtlVector class:
// A growable array class which doubles in size by default.
// It will always keep all elements consecutive in memory, and may move the
// elements around in memory (via a realloc) when elements are inserted or
// removed. Clients should therefore refer to the elements of the vector
// by index (they should *never* maintain pointers to elements in the vector).
//-----------------------------------------------------------------------------

template< class T >
class CUtlVector
{
public:
	typedef T ElemType_t;

	// constructor, destructor
	CUtlVector( int growSize = 0, int initSize = 0 );
	CUtlVector( T* pMemory, int numElements );
	~CUtlVector();
	
	// Copy the array.
	CUtlVector<T>& operator=( const CUtlVector<T> &other );

	// element access
	T& operator[]( int i );
	T const& operator[]( int i ) const;
	T& Element( int i );
	T const& Element( int i ) const;

	// Gets the base address (can change when adding elements!)
	T* Base();
	T const* Base() const;

	// Returns the number of elements in the vector
	// SIZE IS DEPRECATED!
	int Count() const;
	int Size() const;	// don't use me!

	// Is element index valid?
	bool IsValidIndex( int i ) const;
	static int InvalidIndex( void );

	// Adds an element, uses default constructor
	int AddToHead();
	int AddToTail();
	int InsertBefore( int elem );
	int InsertAfter( int elem );

	// Adds an element, uses copy constructor
	int AddToHead( T const& src );
	int AddToTail( T const& src );
	int InsertBefore( int elem, T const& src );
	int InsertAfter( int elem, T const& src );

	// Adds multiple elements, uses default constructor
	int AddMultipleToHead( int num );
	int AddMultipleToTail( int num, const T *pToCopy=NULL );	   
	int InsertMultipleBefore( int elem, int num, const T *pToCopy=NULL );	// If pToCopy is set, then it's an array of length 'num' and
	int InsertMultipleAfter( int elem, int num );

	// Calls RemoveAll() then AddMultipleToTail.
	void SetSize( int size );
	void SetCount( int count );
	
	// Calls SetSize and copies each element.
	void CopyArray( T const *pArray, int size );
	
	// Add the specified array to the tail.
	int AddVectorToTail( CUtlVector<T> const &src );

	// Finds an element (element needs operator== defined)
	int Find( T const& src ) const;

	bool HasElement( T const& src );

	// Makes sure we have enough memory allocated to store a requested # of elements
	void EnsureCapacity( int num );

	// Makes sure we have at least this many elements
	void EnsureCount( int num );

	// Element removal
	void FastRemove( int elem );	// doesn't preserve order
	void Remove( int elem );		// preserves order, shifts elements
	void FindAndRemove( T const& src );	// removes first occurrence of src, preserves order, shifts elements
	void RemoveMultiple( int elem, int num );	// preserves order, shifts elements
	void RemoveAll();				// doesn't deallocate memory

	// Memory deallocation
	void Purge();

	// Purges the list and calls delete on each element in it.
	void PurgeAndDeleteElements();

	// Set the size by which it grows when it needs to allocate more memory.
	void SetGrowSize( int size );

protected:
	// Can't copy this unless we explicitly do it!
	CUtlVector( CUtlVector const& vec ) { assert(0); }

	// Grows the vector
	void GrowVector( int num = 1 );

	// Shifts elements....
	void ShiftElementsRight( int elem, int num = 1 );
	void ShiftElementsLeft( int elem, int num = 1 );

	// For easier access to the elements through the debugger
	void ResetDbgInfo();

	CUtlMemory<T> m_Memory;
	int m_Size;

	// For easier access to the elements through the debugger
	// it's in release builds so this can be used in libraries correctly
	T *m_pElements;
};


//-----------------------------------------------------------------------------
// For easier access to the elements through the debugger
//-----------------------------------------------------------------------------

template< class T >
inline void CUtlVector<T>::ResetDbgInfo()
{
	m_pElements = m_Memory.Base();
}

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------

template< class T >
inline CUtlVector<T>::CUtlVector( int growSize, int initSize )	: 
	m_Memory(growSize, initSize), m_Size(0)
{
	ResetDbgInfo();
}

template< class T >
inline CUtlVector<T>::CUtlVector( T* pMemory, int numElements )	: 
	m_Memory(pMemory, numElements), m_Size(0)
{
	ResetDbgInfo();
}

template< class T >
inline CUtlVector<T>::~CUtlVector()
{
	Purge();
}

template<class T>
inline CUtlVector<T>& CUtlVector<T>::operator=( const CUtlVector<T> &other )
{
	CopyArray( other.Base(), other.Count() );
	return *this;
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------

template< class T >
inline T& CUtlVector<T>::operator[]( int i )
{
	assert( IsValidIndex(i) );
	return m_Memory[i];
}

template< class T >
inline T const& CUtlVector<T>::operator[]( int i ) const
{
	assert( IsValidIndex(i) );
	return m_Memory[i];
}

template< class T >
inline T& CUtlVector<T>::Element( int i )
{
	assert( IsValidIndex(i) );
	return m_Memory[i];
}

template< class T >
inline T const& CUtlVector<T>::Element( int i ) const
{
	assert( IsValidIndex(i) );
	return m_Memory[i];
}


//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------

template< class T >
inline T* CUtlVector<T>::Base()
{
	return m_Memory.Base();
}

template< class T >
inline T const* CUtlVector<T>::Base() const
{
	return m_Memory.Base();
}

//-----------------------------------------------------------------------------
// Count
//-----------------------------------------------------------------------------

template< class T >
inline int CUtlVector<T>::Size() const
{
	return m_Size;
}

template< class T >
inline int CUtlVector<T>::Count() const
{
	return m_Size;
}


//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------

template< class T >
inline bool CUtlVector<T>::IsValidIndex( int i ) const
{
	return (i >= 0) && (i < m_Size);
}
 

//-----------------------------------------------------------------------------
// Returns in invalid index
//-----------------------------------------------------------------------------
template< class T >
inline int CUtlVector<T>::InvalidIndex( void )
{
	return -1;
}


//-----------------------------------------------------------------------------
// Grows the vector
//-----------------------------------------------------------------------------
template< class T >
void CUtlVector<T>::GrowVector( int num )
{
	if (m_Size + num - 1 >= m_Memory.NumAllocated())
	{
		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );
	}

	m_Size += num;
	ResetDbgInfo();
}


//-----------------------------------------------------------------------------
// Makes sure we have enough memory allocated to store a requested # of elements
//-----------------------------------------------------------------------------
template< class T >
void CUtlVector<T>::EnsureCapacity( int num )
{
	m_Memory.EnsureCapacity(num);
	ResetDbgInfo();
}


//-----------------------------------------------------------------------------
// Makes sure we have at least this many elements
//-----------------------------------------------------------------------------
template< class T >
void CUtlVector<T>::EnsureCount( int num )
{
	if (Count() < num)
		AddMultipleToTail( num - Count() );
}


//-----------------------------------------------------------------------------
// Shifts elements
//-----------------------------------------------------------------------------
template< class T >
void CUtlVector<T>::ShiftElementsRight( int elem, int num )
{
	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));
	int numToMove = m_Size - elem - num;
	if ((numToMove > 0) && (num > 0))
		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );
}

template< class T >
void CUtlVector<T>::ShiftElementsLeft( int elem, int num )
{
	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));
	int numToMove = m_Size - elem - num;
	if ((numToMove > 0) && (num > 0))
	{
		memmove( &Element(elem), &Element(elem+num), numToMove * sizeof(T) );

#ifdef _DEBUG
		memset( &Element(m_Size-num), 0xDD, num * sizeof(T) );
#endif
	}
}

//-----------------------------------------------------------------------------
// Adds an element, uses default constructor
//-----------------------------------------------------------------------------

template< class T >
inline int CUtlVector<T>::AddToHead()
{
	return InsertBefore(0);
}

template< class T >
inline int CUtlVector<T>::AddToTail()
{
	return InsertBefore( m_Size );
}

template< class T >
inline int CUtlVector<T>::InsertAfter( int elem )
{
	return InsertBefore( elem + 1 );
}

template< class T >
int CUtlVector<T>::InsertBefore( int elem )
{
	// Can insert at the end
	assert( (elem == Count()) || IsValidIndex(elem) );

	GrowVector();
	ShiftElementsRight(elem);
	Construct( &Element(elem) );
	return elem;
}


//-----------------------------------------------------------------------------
// Adds an element, uses copy constructor
//-----------------------------------------------------------------------------

template< class T >
inline int CUtlVector<T>::AddToHead( T const& src )
{
	return InsertBefore( 0, src );
}

template< class T >
inline int CUtlVector<T>::AddToTail( T const& src )
{
	return InsertBefore( m_Size, src );
}

template< class T >
inline int CUtlVector<T>::InsertAfter( int elem, T const& src )
{
	return InsertBefore( elem + 1, src );
}

template< class T >
int CUtlVector<T>::InsertBefore( int elem, T const& src )
{
	// Can insert at the end
	assert( (elem == Count()) || IsValidIndex(elem) );

	GrowVector();
	ShiftElementsRight(elem);
	CopyConstruct( &Element(elem), src );
	return elem;
}


//-----------------------------------------------------------------------------
// Adds multiple elements, uses default constructor
//-----------------------------------------------------------------------------

template< class T >
inline int CUtlVector<T>::AddMultipleToHead( int num )
{
	return InsertMultipleBefore( 0, num );
}

template< class T >
inline int CUtlVector<T>::AddMultipleToTail( int num, const T *pToCopy )
{
	return InsertMultipleBefore( m_Size, num, pToCopy );
}

template< class T >
int CUtlVector<T>::InsertMultipleAfter( int elem, int num )
{
	return InsertMultipleBefore( elem + 1, num );
}


template< class T >
void CUtlVector<T>::SetCount( int count )
{
	RemoveAll();
	AddMultipleToTail( count );
}

template< class T >
inline void CUtlVector<T>::SetSize( int size )
{
	SetCount( size );
}

template< class T >
void CUtlVector<T>::CopyArray( T const *pArray, int size )
{
	SetSize( size );
	for( int i=0; i < size; i++ )
		(*this)[i] = pArray[i];
}

template< class T >
int CUtlVector<T>::AddVectorToTail( CUtlVector const &src )
{
	int base = Count();
	
	// Make space.
	AddMultipleToTail( src.Count() );

	// Copy the elements.	
	for ( int i=0; i < src.Count(); i++ )
		(*this)[base + i] = src[i];

	return base;
}

template< class T >
inline int CUtlVector<T>::InsertMultipleBefore( int elem, int num, const T *pToInsert )
{
	if( num == 0 )
		return elem;
	
	// Can insert at the end
	assert( (elem == Count()) || IsValidIndex(elem) );

	GrowVector(num);
	ShiftElementsRight(elem, num);

	// Invoke default constructors
	for (int i = 0; i < num; ++i)
		Construct( &Element(elem+i) );

	// Copy stuff in?
	if ( pToInsert )
	{
		for ( int i=0; i < num; i++ )
		{
			Element( elem+i ) = pToInsert[i];
		}
	}

	return elem;
}

//-----------------------------------------------------------------------------
// Finds an element (element needs operator== defined)
//-----------------------------------------------------------------------------
template< class T >
int CUtlVector<T>::Find( T const& src ) const
{
	for ( int i = 0; i < Count(); ++i )
	{
		if (Element(i) == src)
			return i;
	}
	return -1;
}

template< class T >
bool CUtlVector<T>::HasElement( T const& src )
{
	return ( Find(src) >= 0 );
}

//-----------------------------------------------------------------------------
// Element removal
//-----------------------------------------------------------------------------

template< class T >
void CUtlVector<T>::FastRemove( int elem )
{
	assert( IsValidIndex(elem) );

	Destruct( &Element(elem) );
	if (m_Size > 0)
	{
		memcpy( &Element(elem), &Element(m_Size-1), sizeof(T) );
		--m_Size;
	}
}

template< class T >
void CUtlVector<T>::Remove( int elem )
{
	Destruct( &Element(elem) );
	ShiftElementsLeft(elem);
	--m_Size;
}

template< class T >
void CUtlVector<T>::FindAndRemove( T const& src )
{
	int elem = Find( src );
	if ( elem != -1 )
	{
		Remove( elem );
	}
}

template< class T >
void CUtlVector<T>::RemoveMultiple( int elem, int num )
{
	assert( IsValidIndex(elem) );
	assert( elem + num <= Count() );

	for (int i = elem + num; --i >= elem; )
		Destruct(&Element(i));

	ShiftElementsLeft(elem, num);
	m_Size -= num;
}

template< class T >
void CUtlVector<T>::RemoveAll()
{
	for (int i = m_Size; --i >= 0; )
		Destruct(&Element(i));

	m_Size = 0;
}


//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------

template< class T >
void CUtlVector<T>::Purge()
{
	RemoveAll();
	m_Memory.Purge( );
	ResetDbgInfo();
}


template<class T>
inline void CUtlVector<T>::PurgeAndDeleteElements()
{
	for( int i=0; i < m_Size; i++ )
		delete Element(i);

	Purge();
}


template< class T >
void CUtlVector<T>::SetGrowSize( int size )
{
	m_Memory.SetGrowSize( size );
}


#endif // CCVECTOR_H

```

`public/utflib.cpp`:

```cpp
/*
utflib.c - small unicode conversion library
Copyright (C) 2024 Alibek Omarov

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/
#include "utflib.h"
#include "xash3d_types.h"

uint32_t Q_DecodeUTF8( utfstate_t *s, uint32_t in )
{
	// get character length
	if( s->len == 0 )
	{
		// init state
		s->uc = 0;

		// expect ASCII symbols by default
		if( likely( in <= 0x7fu ))
			return in;

		// invalid sequence
		if( unlikely( in >= 0xf8u ))
			return 0;

		s->k = 0;

		if( in >= 0xf0u )
		{
			s->uc = in & 0x07u;
			s->len = 3;
		}
		else if( in >= 0xe0u )
		{
			s->uc = in & 0x0fu;
			s->len = 2;
		}
		else if( in >= 0xc0u )
		{
			s->uc = in & 0x1fu;
			s->len = 1;
		}

		return 0;
	}

	// invalid sequence, reset
	if( unlikely( in > 0xbfu ))
	{
		s->len = 0;
		return 0;
	}

	s->uc <<= 6;
	s->uc += in & 0x3fu;
	s->k++;

	// sequence complete, reset and return code point
	if( likely( s->k == s->len ))
	{
		s->len = 0;
		return s->uc;
	}

	// feed more characters
	return 0;
}

uint32_t Q_DecodeUTF16( utfstate_t *s, uint32_t in )
{
	// get character length
	if( s->len == 0 )
	{
		// init state
		s->uc = 0;

		// expect simple case, after all decoding UTF-16 must be easy
		if( likely( in < 0xd800u || in > 0xdfffu ))
			return in;

		s->uc = (( in - 0xd800u ) << 10 ) + 0x10000u;
		s->len = 1;
		s->k = 0;

		return 0;
	}

	// invalid sequence, reset
	if( unlikely( in < 0xdc00u || in > 0xdfffu ))
	{
		s->len = 0;
		return 0;
	}

	s->uc |= in - 0xdc00u;
	s->k++;

	// sequence complete, reset and return code point
	if( likely( s->k == s->len ))
	{
		s->len = 0;
		return s->uc;
	}

	// feed more characters (should never happen with UTF-16)
	return 0;
}

static size_t Q_CodepointLength( uint32_t ch )
{
	if( ch <= 0x7fu )
		return 1;
	else if( ch <= 0x7ffu )
		return 2;
	else if( ch <= 0xffffu )
		return 3;

	return 4;
}

size_t Q_EncodeUTF8( char dst[4], uint32_t ch )
{
	switch( Q_CodepointLength( ch ))
	{
	case 1:
		dst[0] = ch;
		return 1;
	case 2:
		dst[0] = 0xc0u | (( ch >> 6 ) & 0x1fu );
		dst[1] = 0x80u | (( ch ) & 0x3fu );
		return 2;
	case 3:
		dst[0] = 0xe0u | (( ch >> 12 ) & 0x0fu );
		dst[1] = 0x80u | (( ch >> 6 ) & 0x3fu );
		dst[2] = 0x80u | (( ch ) & 0x3fu );
		return 3;
	}
	dst[0] = 0xf0u | (( ch >> 18 ) & 0x07u );
	dst[1] = 0x80u | (( ch >> 12 ) & 0x3fu );
	dst[2] = 0x80u | (( ch >> 6 ) & 0x3fu );
	dst[3] = 0x80u | (( ch ) & 0x3fu );
	return 4;
}

size_t Q_UTF8Length( const char *s )
{
	size_t len = 0;
	utfstate_t state = { 0 };

	if( !s )
		return 0;

	for( ; *s; s++ )
	{
		uint32_t ch = Q_DecodeUTF8( &state, (uint32_t)*s );

		if( ch == 0 )
			continue;

		len++;
	}

	return len;
}

size_t Q_UTF16ToUTF8( char *dst, size_t dstsize, const uint16_t *src, size_t srcsize )
{
	utfstate_t state = { 0 };
	size_t dsti = 0, srci;

	if( !dst || !src || !dstsize || !srcsize )
		return 0;

	for( srci = 0; srci < srcsize && src[srci]; srci++ )
	{
		uint32_t ch;
		size_t len;

		ch = Q_DecodeUTF16( &state, src[srci] );

		if( ch == 0 )
			continue;

		len = Q_CodepointLength( ch );

		if( dsti + len + 1 > dstsize )
			break;

		dsti += Q_EncodeUTF8( &dst[dsti], ch );
	}

	dst[dsti] = 0;

	return dsti;
}

static uint16_t table_cp1251[64] = {
	0x0402, 0x0403, 0x201A, 0x0453, 0x201E, 0x2026, 0x2020, 0x2021,
	0x20AC, 0x2030, 0x0409, 0x2039, 0x040A, 0x040C, 0x040B, 0x040F,
	0x0452, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
	0x007F, 0x2122, 0x0459, 0x203A, 0x045A, 0x045C, 0x045B, 0x045F,
	0x00A0, 0x040E, 0x045E, 0x0408, 0x00A4, 0x0490, 0x00A6, 0x00A7,
	0x0401, 0x00A9, 0x0404, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x0407,
	0x00B0, 0x00B1, 0x0406, 0x0456, 0x0491, 0x00B5, 0x00B6, 0x00B7,
	0x0451, 0x2116, 0x0454, 0x00BB, 0x0458, 0x0405, 0x0455, 0x0457
};

uint32_t Q_UnicodeToCP1251( uint32_t uc )
{
	size_t i;

	if( uc < 0x80 )
		return uc;

	if( uc >= 0x0410 && uc <= 0x042F )
		return uc - 0x410 + 0xC0;

	if( uc >= 0x0430 && uc <= 0x044F )
		return uc - 0x430 + 0xE0;

	for( i = 0; i < sizeof( table_cp1251 ) / sizeof( table_cp1251[0] ); i++ )
	{
		if( uc == (uint32_t)table_cp1251[i] )
			return i + 0x80;
	}

	return '?';
}

uint32_t Q_UnicodeToCP1252( uint32_t uc )
{
	// this is NOT valid way to convert Unicode codepoint back to CP1252!!!
	return uc < 0xFF ? uc : '?';
}

```

`public/utflib.h`:

```h
/*
utflib.h - small unicode conversion library
Copyright (C) 2024 Alibek Omarov

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/
#ifndef UTFLIB_H
#define UTFLIB_H

#include STDINT_H
#include <stddef.h>

typedef struct utfstate_s
{
	uint32_t uc;
	uint8_t len;
	uint8_t k;
} utfstate_t;

// feed utf8 characters one by one
// if it returns 0, feed more
// utfstate_t must be zero initialized
uint32_t Q_DecodeUTF8( utfstate_t *s, uint32_t ch );
uint32_t Q_DecodeUTF16( utfstate_t *s, uint32_t ch );
size_t Q_EncodeUTF8( char dst[4], uint32_t ch );

size_t Q_UTF8Length( const char *s );

// srcsize in byte pairs
size_t Q_UTF16ToUTF8( char *dst, size_t dstsize, const uint16_t *src, size_t srcsize );

// function to convert Unicode codepoints into CP1251 or CP1252
uint32_t Q_UnicodeToCP1251( uint32_t uc );
uint32_t Q_UnicodeToCP1252( uint32_t uc );

#endif // UTFLIB_H

```

`scripts/pack_extras.py`:

```py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import zipfile

out = sys.argv[1]
src_dirs = sys.argv[2:]

zip_file = zipfile.ZipFile(out, "w", compression=zipfile.ZIP_STORED)

for src in src_dirs:
    for dirpath, dirnames, filenames in os.walk(src):
        for filename in filenames:
            file_path = os.path.join(dirpath, filename)
            name = os.path.relpath(file_path, src)
            zip_file.write(file_path, name)

zip_file.close()
```

`scripts/psvita_generate_configs.sh`:

```sh
#!/bin/bash

touch config.cfg
echo 'unbindall'                                     >> config.cfg
echo 'bind A_BUTTON "+use"'                          >> config.cfg
echo 'bind B_BUTTON "+jump"'                         >> config.cfg
echo 'bind X_BUTTON "+reload"'                       >> config.cfg
echo 'bind Y_BUTTON "+duck"'                         >> config.cfg
echo 'bind L1_BUTTON "+attack2"'                     >> config.cfg
echo 'bind R1_BUTTON "+attack"'                      >> config.cfg
echo 'bind START "escape"'                           >> config.cfg
echo 'bind DPAD_UP "lastinv"'                        >> config.cfg
echo 'bind DPAD_DOWN "impulse 100"'                  >> config.cfg
echo 'bind DPAD_LEFT "invprev"'                      >> config.cfg
echo 'bind DPAD_RIGHT "invnext"'                     >> config.cfg
echo 'bind BACK "chooseteam"'                        >> config.cfg
echo 'gl_vsync "1"'                                  >> config.cfg
echo 'sv_autosave "0"'                               >> config.cfg
echo 'touch_config_file "touch_presets/psvita.cfg"'  >> config.cfg

touch kb_def.lst
echo '"A_BUTTON"		"+use"'                      >> kb_def.lst
echo '"B_BUTTON"		"+jump"'                     >> kb_def.lst
echo '"X_BUTTON"		"+reload"'                   >> kb_def.lst
echo '"Y_BUTTON"		"+duck"'                     >> kb_def.lst
echo '"L1_BUTTON"		"+attack2"'                  >> kb_def.lst
echo '"R1_BUTTON"		"+attack"'                   >> kb_def.lst
echo '"START"			"escape"'                    >> kb_def.lst
echo '"DPAD_UP"			"lastinv"'                   >> kb_def.lst
echo '"DPAD_DOWN"		"impulse 100"'               >> kb_def.lst
echo '"DPAD_LEFT"		"invprev"'                   >> kb_def.lst
echo '"DPAD_RIGHT"		"invnext"'                   >> kb_def.lst
echo '"BACK"			"chooseteam"'                >> kb_def.lst

touch video.cfg
echo 'fullscreen "1"' >> video.cfg
echo 'width "960"'    >> video.cfg
echo 'height "544"'   >> video.cfg
echo 'r_refdll "gl"'  >> video.cfg

touch opengl.cfg
echo 'gl_nosort "1"'  >> opengl.cfg

```

`scripts/psvita_sdk.sh`:

```sh
#!/bin/bash

cd $GITHUB_WORKSPACE

export VITASDK=/usr/local/vitasdk

echo "Downloading vitasdk..."
git clone https://github.com/vitasdk/vdpm.git --depth=1 || exit 1
pushd vdpm
./bootstrap-vitasdk.sh || exit 1
./vdpm taihen || exit 1
./vdpm kubridge || exit 1
./vdpm zlib || exit 1
./vdpm SceShaccCgExt || exit 1
./vdpm vitaShaRK || exit 1
./vdpm libmathneon || exit 1
popd

echo "Building vrtld..."
git clone https://github.com/fgsfdsfgs/vita-rtld.git --depth=1 || exit 1
pushd vita-rtld || die
cmake -S. -Bbuild -DCMAKE_BUILD_TYPE=Release || die_configure
cmake --build build -- -j$JOBS || die
cmake --install build || die
popd

```

`scripts/yapb_graph_dl.py`:

```py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function

import os
import sys

try:
    from urllib import urlretrieve

    URLError = IOError
except ImportError:
    from urllib.request import urlretrieve
    from urllib.error import URLError
    
# banned for me :(
# DATABASE_URL = "https://yapb.jeefo.net/graph/"
DATABASE_URL = "https://raw.githubusercontent.com/yapb/graph/master/graph/"
DEST_DIR = sys.argv[1]
OFFICIAL_MAPS = [
    "as_oilrig",
    "cs_747",
    "cs_assault",
    "cs_backalley",
    "cs_estate",
    "cs_havana",
    "cs_italy",
    "cs_militia",
    "cs_office",
    "cs_siege",
    "de_airstrip",
    "de_aztec",
    "de_cbble",
    "de_chateau",
    "de_dust",
    "de_dust2",
    "de_inferno",
    "de_nuke",
    "de_piranesi",
    "de_prodigy",
    "de_storm",
    "de_survivor",
    "de_torn",
    "de_train",
    "de_vertigo"
]

if not os.path.exists(DEST_DIR):
    os.makedirs(DEST_DIR)

for graph_name in OFFICIAL_MAPS:
    file_url = "{}{}.graph".format(DATABASE_URL, graph_name)
    file_path = os.path.join(DEST_DIR, "{}.graph".format(graph_name))

    try:
        # don't download if it already exists
        if not os.path.exists(file_path):
            urlretrieve(file_url, file_path)
            print("Downloaded: {}".format(file_path))
    except URLError:
        print("Failed to download: {}".format(file_url))
        continue
    except Exception as e:
        print("Unknown error: {}".format(e))
        continue

print("YaPB Graphs have been downloaded for the maps specified in the list.")

```

`toolchains/i386-linux-gnu.cmake`:

```cmake
set(CMAKE_SYSTEM_NAME Linux CACHE STRING "" FORCE)
set(CMAKE_SYSTEM_PROCESSOR i386 CACHE STRING "" FORCE)

set(CMAKE_C_FLAGS "-m32" CACHE STRING "" FORCE)
set(CMAKE_CXX_FLAGS "-m32" CACHE STRING "" FORCE)
set(CMAKE_EXE_LINKER_FLAGS "-m32" CACHE STRING "" FORCE)
```