Project Path: arc_lguilhermee_EAC-Extractor-Utility_678i27wh

Source Tree:

```txt
arc_lguilhermee_EAC-Extractor-Utility_678i27wh
‚îú‚îÄ‚îÄ CryptoUtils.cpp
‚îú‚îÄ‚îÄ CryptoUtils.h
‚îú‚îÄ‚îÄ DecryptEACPayload.sln
‚îú‚îÄ‚îÄ DecryptEACPayload.vcxproj
‚îú‚îÄ‚îÄ DecryptEACPayload.vcxproj.filters
‚îú‚îÄ‚îÄ DecryptEACPayload.vcxproj.user
‚îú‚îÄ‚îÄ EACExtractor.cpp
‚îú‚îÄ‚îÄ EACExtractor.h
‚îú‚îÄ‚îÄ GameConfig.cpp
‚îú‚îÄ‚îÄ GameConfig.h
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ Log.cpp
‚îú‚îÄ‚îÄ Log.h
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ Utils
‚îÇ   ‚îú‚îÄ‚îÄ FileUtils.cpp
‚îÇ   ‚îú‚îÄ‚îÄ FileUtils.h
‚îÇ   ‚îú‚îÄ‚îÄ MemoryDumper.cpp
‚îÇ   ‚îú‚îÄ‚îÄ MemoryDumper.h
‚îÇ   ‚îú‚îÄ‚îÄ ModuleDownloader.cpp
‚îÇ   ‚îú‚îÄ‚îÄ ModuleDownloader.h
‚îÇ   ‚îú‚îÄ‚îÄ PatternScanner.cpp
‚îÇ   ‚îú‚îÄ‚îÄ PatternScanner.h
‚îÇ   ‚îú‚îÄ‚îÄ kraken.cpp
‚îÇ   ‚îî‚îÄ‚îÄ kraken.h
‚îú‚îÄ‚îÄ games.json
‚îú‚îÄ‚îÄ logo.png
‚îú‚îÄ‚îÄ main.cpp
‚îú‚îÄ‚îÄ miniz
‚îÇ   ‚îú‚îÄ‚îÄ miniz.c
‚îÇ   ‚îú‚îÄ‚îÄ miniz.h
‚îÇ   ‚îú‚îÄ‚îÄ miniz_common.h
‚îÇ   ‚îú‚îÄ‚îÄ miniz_export.h
‚îÇ   ‚îú‚îÄ‚îÄ miniz_tdef.c
‚îÇ   ‚îú‚îÄ‚îÄ miniz_tdef.h
‚îÇ   ‚îú‚îÄ‚îÄ miniz_tinfl.c
‚îÇ   ‚îú‚îÄ‚îÄ miniz_tinfl.h
‚îÇ   ‚îú‚îÄ‚îÄ miniz_zip.c
‚îÇ   ‚îî‚îÄ‚îÄ miniz_zip.h
‚îî‚îÄ‚îÄ x64
    ‚îî‚îÄ‚îÄ Release
        ‚îî‚îÄ‚îÄ games.json

```

`CryptoUtils.cpp`:

```cpp
#include "CryptoUtils.h"
#include "Log.h"
#include "miniz.h"
#include "kraken.h"

namespace CryptoUtils
{
	std::vector<uint8_t> DecryptPayload(const std::vector<uint8_t>& encryptedVector)
	{
		std::vector<uint8_t> tmp = encryptedVector;

		auto     beginBuffer  = tmp.data();
		auto     endBuffer    = beginBuffer + tmp.size();
		uint8_t* pCurrentByte = tmp.data();
		size_t   moduleSize   = endBuffer - beginBuffer;

		if (moduleSize >= 2)
		{
			endBuffer[-1] += 3 - 3 * moduleSize;

			for (size_t i = moduleSize - 2; i; --i)
				pCurrentByte[i] += -3 * i - pCurrentByte[i + 1];

			*pCurrentByte -= pCurrentByte[1];
		}

		Log::Success("Decrypted payload (%zu bytes)", moduleSize);
		return tmp;
	}

	std::vector<uint8_t> UnpackModule(const std::vector<uint8_t>& encryptedVector)
	{

		bool isEncrypted = *reinterpret_cast<const uint16_t*>( encryptedVector.data( ) + 12 ) != 0x5A4D;
		std::vector<uint8_t> decrypted;

		if ( isEncrypted )
		{
			decrypted = DecryptPayload( encryptedVector );
		}
		else
		{
			decrypted = encryptedVector;
		}

		bool usesKraken = *reinterpret_cast<const uint16_t*>( decrypted.data( ) + 12 ) == 0x5A4D;

		if ( usesKraken )
		{
			uint32_t decompressedSize = *reinterpret_cast<const uint32_t*>( decrypted.data( ) );
			std::vector<uint8_t>decompressedData;
			decompressedData.resize( decompressedSize );
			auto ret = Kraken_Decompress( decrypted.data( ) + 4, decrypted.size( ) - 4, decompressedData.data( ), decompressedData.size( ) );
			if ( ret == -1 )
			{
				Log::Error( "Failed to decompress using kraken" );
				return {};
			}
			return decompressedData;
		}
		else
		{
			size_t decompressedSize = 0;
			void* pDecompressed = tinfl_decompress_mem_to_heap(
				decrypted.data( ),
				decrypted.size( ),
				&decompressedSize,
				0  // Raw deflate -- no zlib header
			);

			if ( !pDecompressed )
			{
				Log::Error( "Failed to inflate module" );
				return {};
			}

			Log::Success( "Unpacked module: %zu -> %zu bytes", decrypted.size( ), decompressedSize );

			std::vector<uint8_t> result(
				static_cast<uint8_t*>( pDecompressed ),
				static_cast<uint8_t*>( pDecompressed ) + decompressedSize
			);

			mz_free( pDecompressed );
			return result;
		}

		
	}

	std::vector<uint8_t> PackModule(const std::vector<uint8_t>& plainVector)
	{
		// Step 1: Raw deflate compression
		size_t compressedSize = 0;
		int    compFlags      = tdefl_create_comp_flags_from_zip_params(
			MZ_BEST_COMPRESSION, -MZ_DEFAULT_WINDOW_BITS, MZ_DEFAULT_STRATEGY);

		void* pCompressed = tdefl_compress_mem_to_heap(
			plainVector.data(),
			plainVector.size(),
			&compressedSize,
			compFlags
		);

		if (!pCompressed)
		{
			Log::Error("Failed to deflate module");
			return {};
		}

		Log::Success("Compressed module: %zu -> %zu bytes", plainVector.size(), compressedSize);

		std::vector<uint8_t> result(
			static_cast<uint8_t*>(pCompressed),
			static_cast<uint8_t*>(pCompressed) + compressedSize
		);
		mz_free(pCompressed);

		// Step 2: Chain cipher encryption (exact inverse of DecryptPayload)
		size_t   n = result.size();
		uint8_t* p = result.data();

		if (n >= 2)
		{
			p[0] += p[1];

			for (size_t i = 1; i < n - 1; ++i)
				p[i] -= -3 * i - p[i + 1];

			p[n - 1] -= 3 - 3 * n;
		}

		Log::Success("Encrypted payload (%zu bytes)", n);
		return result;
	}
}

```

`CryptoUtils.h`:

```h
#pragma once
#include <vector>
#include <cstdint>

namespace CryptoUtils
{
	// Chain cipher only -- used for the EAC launcher payload.
	std::vector<uint8_t> DecryptPayload(const std::vector<uint8_t>& encryptedVector);

	// Chain cipher + raw deflate -- used for driver/usermode modules.
	std::vector<uint8_t> UnpackModule(const std::vector<uint8_t>& encryptedVector);
	std::vector<uint8_t> PackModule(const std::vector<uint8_t>& plainVector);
}

```

`DecryptEACPayload.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DecryptEACPayload", "DecryptEACPayload.vcxproj", "{84195FF5-295B-412A-9614-9CCB44A9DCF4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Debug|x64.ActiveCfg = Debug|x64
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Debug|x64.Build.0 = Debug|x64
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Debug|x86.ActiveCfg = Debug|Win32
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Debug|x86.Build.0 = Debug|Win32
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Release|x64.ActiveCfg = Release|x64
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Release|x64.Build.0 = Release|x64
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Release|x86.ActiveCfg = Release|Win32
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FBDA31DE-1327-475E-91C3-AE194CD2FFC2}
	EndGlobalSection
EndGlobal

```

`DecryptEACPayload.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{84195ff5-295b-412a-9614-9ccb44a9dcf4}</ProjectGuid>
    <RootNamespace>DecryptEACPayload</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)Utils;$(ProjectDir)miniz;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)Utils;$(ProjectDir)miniz;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)Utils;$(ProjectDir)miniz;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)Utils;$(ProjectDir)miniz;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Log.cpp" />
    <ClCompile Include="CryptoUtils.cpp" />
    <ClCompile Include="EACExtractor.cpp" />
    <ClCompile Include="Utils\FileUtils.cpp" />
    <ClCompile Include="GameConfig.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="Utils\MemoryDumper.cpp" />
    <ClCompile Include="Utils\ModuleDownloader.cpp" />
    <ClCompile Include="Utils\PatternScanner.cpp" />
    <ClCompile Include="miniz\miniz.c" />
    <ClCompile Include="miniz\miniz_tinfl.c" />
    <ClCompile Include="miniz\miniz_tdef.c" />
    <ClCompile Include="miniz\miniz_zip.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Log.h" />
    <ClInclude Include="CryptoUtils.h" />
    <ClInclude Include="EACExtractor.h" />
    <ClInclude Include="Utils\FileUtils.h" />
    <ClInclude Include="GameConfig.h" />
    <ClInclude Include="Utils\MemoryDumper.h" />
    <ClInclude Include="Utils\ModuleDownloader.h" />
    <ClInclude Include="Utils\PatternScanner.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DecryptEACPayload.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DecryptEACPayload.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EACExtractor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FileUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemoryDumper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PatternScanner.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ConsoleUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CryptoUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="GameConfig.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ModuleDownloader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="EACExtractor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FileUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MemoryDumper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PatternScanner.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ConsoleUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CryptoUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="GameConfig.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ModuleDownloader.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DecryptEACPayload.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`EACExtractor.cpp`:

```cpp
#include "EACExtractor.h"
#include "FileUtils.h"
#include "CryptoUtils.h"
#include "PatternScanner.h"
#include "MemoryDumper.h"
#include "Log.h"
#include <algorithm>
#include <initializer_list>

// Try multiple signatures in order, return first match
static uintptr_t FindFirstMatchMulti(uintptr_t base, std::initializer_list<const char*> patterns)
{
	for (auto* sig : patterns)
	{
		if (auto result = PatternScanner::FindFirstMatch(base, sig))
			return result;
	}
	return 0;
}

EACExtractor::EACExtractor(std::string inputFile)
	: InputFilePath(std::move(inputFile))
{
}

EACExtractor::EACExtractor(std::string inputFile, std::string outputFolder)
	: dumpFolder(std::move(outputFolder)), InputFilePath(std::move(inputFile))
{
}

EACExtractor::~EACExtractor()
{
	Cleanup();
}

bool EACExtractor::CreateOutputFolder()
{
	if (!dumpFolder.empty())
	{
		if (!FileUtils::EnsureDirectoryExists(dumpFolder))
		{
			Log::Error("Failed to ensure output folder exists");
			return false;
		}
		return true;
	}

	dumpFolder = FileUtils::CreateDumpFolder();
	if (dumpFolder.empty())
	{
		Log::Error("Failed to create dump folder");
		return false;
	}
	return true;
}

bool EACExtractor::SaveOriginalFile()
{
	try
	{
		auto normalize = [](std::string s)
		{
			std::ranges::replace(s, '/', '\\');
			std::string lower;
			lower.resize(s.size());
			std::ranges::transform(s, lower.begin(), [](unsigned char c)
			{
				return static_cast<char>(std::tolower(c));
			});
			return lower;
		};

		const std::string inputLower = normalize(InputFilePath);
		const std::string dumpLower  = normalize(dumpFolder);

		if (!dumpLower.empty())
		{
			if (inputLower.starts_with(dumpLower + "\\") || inputLower == dumpLower)
			{
				Log::Info("Input file is already in the output folder. Skipping copy of original.");
				return true;
			}
		}

		auto originalData = FileUtils::LoadBinaryFile(InputFilePath);
		if (originalData.empty())
		{
			Log::Error("Failed to read input file for original copy");
			return false;
		}

		std::string outputPath = dumpFolder + "\\original_eac.bin";
		return FileUtils::SaveBinaryFile(outputPath, originalData);
	}
	catch (const std::exception& e)
	{
		Log::Error("Failed to copy original file: %s", e.what());
		return false;
	}
}

bool EACExtractor::DecryptAndSaveLauncher()
{
	Log::Info("Loading and decrypting launcher...");

	auto encryptedFile = FileUtils::LoadBinaryFile(InputFilePath);
	if (encryptedFile.empty())
	{
		Log::Error("Failed to load input file");
		return false;
	}

	auto decryptedBuffer = CryptoUtils::DecryptPayload(encryptedFile);

	std::string launcherPath = dumpFolder + "\\EAC_Launcher_decrypted.dll";
	if (!FileUtils::SaveBinaryFile(launcherPath, decryptedBuffer))
	{
		Log::Error("Failed to save decrypted launcher");
		return false;
	}

	return true;
}

bool EACExtractor::LoadLauncherModule()
{
	std::string launcherPath = dumpFolder + "\\EAC_Launcher_decrypted.dll";
	LauncherModule           = LoadLibraryA(launcherPath.c_str());

	if (!LauncherModule)
	{
		Log::Error("Failed to load launcher module");
		return false;
	}

	Log::Success("Launcher module loaded at: 0x%llX", (unsigned long long)(uintptr_t)LauncherModule);
	return true;
}

bool EACExtractor::DumpLoadedModule()
{
	if (!LauncherModule)
	{
		Log::Error("Launcher module not loaded");
		return false;
	}

	std::string dumpPath = dumpFolder + "\\EAC_Launcher_memory_dump.dll";
	if (!MemoryDumper::DumpModuleFromMemory(LauncherModule, dumpPath))
	{
		Log::Error("Failed to dump launcher from memory");
		return false;
	}

	return true;
}

ExtractedPayloads EACExtractor::ExtractPayloads()
{
	ExtractedPayloads payloads;

	if (!LauncherModule)
	{
		Log::Error("Launcher module not loaded");
		return payloads;
	}

	Log::Info("Extracting embedded payloads...");

	auto userModuleEncrypted = PatternScanner::FindFirstMatch(
		(uintptr_t)LauncherModule, "48 8D 05 ? ? ? ? 89 54 24");

	if (userModuleEncrypted)
	{
#ifdef _WIN64
		userModuleEncrypted = PatternScanner::ResolveRelative(userModuleEncrypted, 3, 7);

		uint32_t userModeModuleSize = 0;

		auto patternResult = PatternScanner::FindFirstMatch(
			(uintptr_t)LauncherModule, "8B 15 ? ? ? ? ? 89 ? 24");
		if (patternResult)
		{
			userModeModuleSize = *(uint32_t*)PatternScanner::ResolveRelative(patternResult, 2, 6);
		}
#else
		auto scanResult = PatternScanner::FindFirstMatch((uintptr_t)LauncherModule,
		                                                 "8B 93 ? 00 00 00 8B 0D");
		uint32_t userModeModuleSize = 0;
		if (scanResult) {
			userModeModuleSize = *(uint32_t*)*(uint32_t*)(scanResult + 0x8);
		}
#endif

		if (userModeModuleSize > 0 && userModeModuleSize < 100 * 1024 * 1024)
		{
			Log::Success("Found user mode module: %u bytes", userModeModuleSize);

			std::vector<uint8_t> encryptedUserMode(
				(uint8_t*)userModuleEncrypted,
				(uint8_t*)userModuleEncrypted + userModeModuleSize);

			payloads.UserModeModule = CryptoUtils::UnpackModule(encryptedUserMode);
			payloads.HasUserMode    = !payloads.UserModeModule.empty();
		}
	}

#ifdef _WIN64

	auto FindDriverModule = [&]( ) -> uint64_t
		{
			auto base = reinterpret_cast<uint64_t>( LauncherModule );
			auto nt = reinterpret_cast<PIMAGE_NT_HEADERS>( base + ( reinterpret_cast<PIMAGE_DOS_HEADER>( base ))->e_lfanew );
			auto secs = IMAGE_FIRST_SECTION( nt );
			for ( int i = 0; i < nt->FileHeader.NumberOfSections; i++ )
			{
				auto sec = &secs[i];
				if ( !_stricmp( (char*)sec->Name, ".data" ) )
					return base + sec->VirtualAddress;
			}
			return 0;
		};

	auto FindDriverSize = [&]( uintptr_t driverDataPtr ) -> uint32_t
		{
			auto base = reinterpret_cast<uint8_t*>( LauncherModule );
			auto nt = reinterpret_cast<PIMAGE_NT_HEADERS>( base + reinterpret_cast<PIMAGE_DOS_HEADER>( base )->e_lfanew );

			

			uint8_t* codeStart = base + nt->OptionalHeader.BaseOfCode;
			uint8_t* codeEnd = codeStart + nt->OptionalHeader.SizeOfCode;

			for ( uint8_t* i = codeStart; i < codeEnd; ++i )
			{
				if ( i[0] == 0x48 && i[1] == 0x8D && ( i[2] == 0x0D || i[2] == 0x15 ) )
				{
					if ( PatternScanner::ResolveRelative(reinterpret_cast<uint64_t>(i), 3, 7 ) != driverDataPtr )
						continue;

					for ( uint8_t* prev = i; prev >= codeStart; --prev )
					{
						if ( prev[0] == 0x8B && prev[1] == 0x15 )
						{
							auto sizePtr = PatternScanner::ResolveRelative( reinterpret_cast<uint64_t>( prev), 2, 6 );
							return *reinterpret_cast<uint32_t*>( sizePtr );
						}
					}
				}
			}
			return 0;
		};

	if (auto driverDataPtr = FindDriverModule())
	{
		auto driverSizePattern = FindFirstMatchMulti((uintptr_t)LauncherModule, {
			"44 8B 35 ? ? ? ? 41 8B CE",
			"44 8B 35 ? ? ? ? 33 D2",
			"44 8B 3D ? ? ? ? 49 3B 40"
		});

		uint32_t driverSize {};

		if ( !driverSizePattern )
		{
			driverSize = FindDriverSize( driverDataPtr );
		}
		else
		{
			driverSize = *(uint32_t*)PatternScanner::ResolveRelative(
				driverSizePattern, 3, 7 );
		}

		if ( driverSize > 0 && driverSize < 100 * 1024 * 1024 )
		{
			Log::Success( "Found driver module: %u bytes", driverSize );

			std::vector<uint8_t> encryptedDriver(
				(uint8_t*)driverDataPtr,
				(uint8_t*)driverDataPtr + driverSize );

			payloads.DriverModule = CryptoUtils::UnpackModule( encryptedDriver );
			payloads.HasDriver = !payloads.DriverModule.empty( );
		}
	}
#else
	auto driverSizePattern = PatternScanner::FindFirstMatch(
		(uintptr_t)LauncherModule, "FF 35 ? ? ? ? 99 68");

	if (driverSizePattern) {
		auto driverSize = *(uint32_t*)(*(uint32_t*)(driverSizePattern + 2));

		if (driverSize > 0 && driverSize < 10 * 1024 * 1024) {
			Log::Success("Found driver module: %u bytes", driverSize);
			payloads.HasDriver = true;
		}
	}
#endif

	return payloads;
}

bool EACExtractor::SaveExtractedPayloads(const ExtractedPayloads& payloads)
{
	bool success = true;

	if (payloads.HasUserMode)
	{
		std::string userModePath = dumpFolder + "\\EAC_UserMode.dll";
		if (!FileUtils::SaveBinaryFile(userModePath, payloads.UserModeModule))
		{
			Log::Error("Failed to save user mode module");
			success = false;
		}
	}

	if (payloads.HasDriver)
	{
		std::string driverPath = dumpFolder + "\\EAC_Driver.sys";
		if (!FileUtils::SaveBinaryFile(driverPath, payloads.DriverModule))
		{
			Log::Error("Failed to save driver module");
			success = false;
		}
	}

	return success;
}

void EACExtractor::Cleanup()
{
	if (LauncherModule)
	{
		FreeLibrary(LauncherModule);
		LauncherModule = nullptr;
	}
}

bool EACExtractor::Process()
{
	Log::Banner();
	Log::Info("Input file: %s", InputFilePath.c_str());

	if (!CreateOutputFolder())  return false;
	if (!SaveOriginalFile())    return false;
	if (!DecryptAndSaveLauncher()) return false;
	if (!LoadLauncherModule())  return false;
	if (!DumpLoadedModule())    return false;

	auto payloads = ExtractPayloads();

	if (!SaveExtractedPayloads(payloads))
		return false;

	// --- Results summary ---
	printf("\n");
	Log::Info("Results:");
	Log::Info("  Output folder: %s", dumpFolder.c_str());

	if (payloads.HasUserMode)
		Log::Success("  UserMode:  %zu bytes", payloads.UserModeModule.size());
	else
		Log::Warning("  UserMode:  not found");

	if (payloads.HasDriver)
		Log::Success("  Driver:    %zu bytes", payloads.DriverModule.size());
	else
		Log::Warning("  Driver:    not found");

	Log::Success("Extraction completed successfully!");
	return true;
}

```

`EACExtractor.h`:

```h
#pragma once
#include <Windows.h>
#include <string>
#include <vector>
#include <cstdint>

struct ExtractedPayloads
{
	std::vector<uint8_t> UserModeModule;
	std::vector<uint8_t> DriverModule;
	bool                 HasUserMode = false;
	bool                 HasDriver   = false;
};

class EACExtractor
{
	std::string dumpFolder;
	std::string InputFilePath;
	HMODULE     LauncherModule = nullptr;

public:
	EACExtractor(std::string inputFile);
	EACExtractor(std::string inputFile, std::string outputFolder);
	~EACExtractor();

	bool Process();

private:
	bool              CreateOutputFolder();
	bool              SaveOriginalFile();
	bool              DecryptAndSaveLauncher();
	bool              LoadLauncherModule();
	bool              DumpLoadedModule();
	ExtractedPayloads ExtractPayloads();
	bool              SaveExtractedPayloads(const ExtractedPayloads& payloads);
	void              Cleanup();
};

```

`GameConfig.cpp`:

```cpp
#include "GameConfig.h"
#include "Log.h"
#include <fstream>
#include <sstream>
#include <iomanip>

GameConfig::GameConfig(std::string configFile) : ConfigFilePath(std::move(configFile))
{
}

bool GameConfig::LoadConfig()
{
	std::ifstream file(ConfigFilePath);
	if (!file.is_open())
	{
		return false;
	}

	std::stringstream buffer;
	buffer << file.rdbuf();
	std::string content = buffer.str();
	file.close();

	try
	{
		ParseJsonFile(content);
		return true;
	}
	catch (const std::exception& e)
	{
		Log::Error("Error parsing config file: %s", e.what());
		return false;
	}
}

bool GameConfig::SaveConfig()
{
	std::ofstream file(ConfigFilePath);
	if (!file.is_open())
	{
		Log::Error("Failed to create config file: %s", ConfigFilePath.c_str());
		return false;
	}

	std::string jsonContent = GenerateJsonContent();
	file << jsonContent;
	file.close();

	return true;
}

void GameConfig::AddGame(const GameInfo& gameInfo)
{
	// Check if game already exists
	for (auto& game : Games)
	{
		if (game.ProductId == gameInfo.ProductId && game.DeploymentId == gameInfo.DeploymentId)
		{
			// Update existing game
			game = gameInfo;
			return;
		}
	}

	// Add new game
	Games.push_back(gameInfo);
}

std::vector<GameInfo> GameConfig::GetAllGames() const
{
	return Games;
}

GameInfo* GameConfig::FindGameByName(const std::string& name)
{
	for (auto& game : Games)
	{
		if (game.Name == name)
		{
			return &game;
		}
	}
	return nullptr;
}

GameInfo* GameConfig::FindGameByProductId(const std::string& productId)
{
	for (auto& game : Games)
	{
		if (game.ProductId == productId)
		{
			return &game;
		}
	}
	return nullptr;
}

void GameConfig::ListGames() const
{
	if (Games.empty())
	{
		Log::Info("No games configured yet.");
		return;
	}

	Log::Success("Available games:");
	printf("%.80s\n", "--------------------------------------------------------------------------------");

	for (size_t i = 0; i < Games.size(); ++i)
	{
		const auto& game = Games[i];
		printf("[%zu] %s\n", i + 1, game.Name.c_str());
		printf("    ProductID: %s\n", game.ProductId.c_str());
		printf("    DeploymentID: %s\n\n", game.DeploymentId.c_str());
	}
}

bool GameConfig::IsEmpty() const
{
	return Games.empty();
}

std::string GameConfig::EscapeJson(const std::string& str)
{
	std::string escaped;
	for (char c : str)
	{
		switch (c)
		{
		case '"': escaped += "\\\"";
			break;
		case '\\': escaped += "\\\\";
			break;
		case '\b': escaped += "\\b";
			break;
		case '\f': escaped += "\\f";
			break;
		case '\n': escaped += "\\n";
			break;
		case '\r': escaped += "\\r";
			break;
		case '\t': escaped += "\\t";
			break;
		default: escaped += c;
			break;
		}
	}
	return escaped;
}

std::string GameConfig::UnescapeJson(const std::string& str)
{
	std::string unescaped;
	for (size_t i = 0; i < str.length(); ++i)
	{
		if (str[i] == '\\' && i + 1 < str.length())
		{
			switch (str[i + 1])
			{
			case '"': unescaped += '"';
				i++;
				break;
			case '\\': unescaped += '\\';
				i++;
				break;
			case 'b': unescaped += '\b';
				i++;
				break;
			case 'f': unescaped += '\f';
				i++;
				break;
			case 'n': unescaped += '\n';
				i++;
				break;
			case 'r': unescaped += '\r';
				i++;
				break;
			case 't': unescaped += '\t';
				i++;
				break;
			default: unescaped += str[i];
				break;
			}
		}
		else
		{
			unescaped += str[i];
		}
	}
	return unescaped;
}

void GameConfig::ParseJsonFile(const std::string& content)
{
	Games.clear();

	// Parse config section first
	size_t configPos = content.find("\"config\"");
	if (configPos != std::string::npos)
	{
		size_t configStart = content.find('{', configPos);
		if (configStart != std::string::npos)
		{
			size_t configEnd = content.find('}', configStart);
			if (configEnd != std::string::npos)
			{
				std::string configObj = content.substr(configStart + 1, configEnd - configStart - 1);

				// Parse baseUrl
				size_t urlStart = configObj.find("\"baseUrl\"");
				if (urlStart != std::string::npos)
				{
					urlStart = configObj.find('"', urlStart + 9);
					if (urlStart != std::string::npos)
					{
						urlStart++;
						size_t urlEnd = configObj.find('"', urlStart);
						if (urlEnd != std::string::npos)
						{
							Settings.BaseUrl = UnescapeJson(configObj.substr(urlStart, urlEnd - urlStart));
						}
					}
				}

				// Parse defaultPlatform
				size_t platStart = configObj.find("\"defaultPlatform\"");
				if (platStart != std::string::npos)
				{
					platStart = configObj.find('"', platStart + 17);
					if (platStart != std::string::npos)
					{
						platStart++;
						size_t platEnd = configObj.find('"', platStart);
						if (platEnd != std::string::npos)
						{
							Settings.DefaultPlatform = configObj.substr(platStart, platEnd - platStart);
						}
					}
				}
			}
		}
	}

	// Simple JSON parser for our specific format
	size_t pos = content.find("\"games\"");
	if (pos == std::string::npos) return;

	pos = content.find('[', pos);
	if (pos == std::string::npos) return;

	size_t endPos = content.find_last_of(']');
	if (endPos == std::string::npos) return;

	std::string gamesArray = content.substr(pos + 1, endPos - pos - 1);

	// Parse each game object
	size_t gameStart = 0;
	while (true)
	{
		size_t objStart = gamesArray.find('{', gameStart);
		if (objStart == std::string::npos) break;

		size_t objEnd = gamesArray.find('}', objStart);
		if (objEnd == std::string::npos) break;

		std::string gameObj = gamesArray.substr(objStart + 1, objEnd - objStart - 1);

		GameInfo game;

		// Parse name
		size_t nameStart = gameObj.find("\"name\"");
		if (nameStart != std::string::npos)
		{
			nameStart = gameObj.find('"', nameStart + 6);
			if (nameStart != std::string::npos)
			{
				nameStart++;
				size_t nameEnd = gameObj.find('"', nameStart);
				if (nameEnd != std::string::npos)
				{
					game.Name = UnescapeJson(gameObj.substr(nameStart, nameEnd - nameStart));
				}
			}
		}

		// Parse productId
		size_t prodStart = gameObj.find("\"productId\"");
		if (prodStart != std::string::npos)
		{
			prodStart = gameObj.find('"', prodStart + 11);
			if (prodStart != std::string::npos)
			{
				prodStart++;
				size_t prodEnd = gameObj.find('"', prodStart);
				if (prodEnd != std::string::npos)
				{
					game.ProductId = gameObj.substr(prodStart, prodEnd - prodStart);
				}
			}
		}

		// Parse deploymentId
		size_t depStart = gameObj.find("\"deploymentId\"");
		if (depStart != std::string::npos)
		{
			depStart = gameObj.find('"', depStart + 14);
			if (depStart != std::string::npos)
			{
				depStart++;
				size_t depEnd = gameObj.find('"', depStart);
				if (depEnd != std::string::npos)
				{
					game.DeploymentId = gameObj.substr(depStart, depEnd - depStart);
				}
			}
		}


		if (!game.Name.empty() && !game.ProductId.empty() && !game.DeploymentId.empty())
		{
			Games.push_back(game);
		}

		gameStart = objEnd + 1;
	}
}

std::string GameConfig::GenerateJsonContent() const
{
	std::stringstream ss;
	ss << "{\n";
	ss << "  \"version\": \"1.1\",\n";
	ss << "  \"description\": \"EAC Module Configuration - Community maintained list of game IDs\",\n";
	ss << "  \"config\": {\n";
	ss << "    \"baseUrl\": \"" << EscapeJson(Settings.BaseUrl) << "\",\n";
	ss << "    \"defaultPlatform\": \"" << Settings.DefaultPlatform << "\"\n";
	ss << "  },\n";
	ss << "  \"games\": [\n";

	for (size_t i = 0; i < Games.size(); ++i)
	{
		const auto& game = Games[i];
		ss << "    {\n";
		ss << R"(      "name": ")" << EscapeJson(game.Name) << "\",\n";
		ss << R"(      "productId": ")" << game.ProductId << "\",\n";
		ss << R"(      "deploymentId": ")" << game.DeploymentId << "\"\n    }";
		if (i < Games.size() - 1)
		{
			ss << ",";
		}
		ss << "\n";
	}

	ss << "  ]\n";
	ss << "}\n";

	return ss.str();
}

std::vector<std::string> GameConfig::GetAvailablePlatforms()
{
	return {
		"win64",
		"win64_wow64",
		"linux64",
		"linux32",
		"mac64",
		"mac_arm64"
	};
}

```

`GameConfig.h`:

```h
#pragma once
#include <string>
#include <vector>
#include <map>

struct GameInfo
{
	std::string Name;
	std::string ProductId;
	std::string DeploymentId;
};

struct ConfigSettings
{
	std::string BaseUrl         = "https://modules-cdn.eac-prod.on.epicgames.com/modules";
	std::string DefaultPlatform = "win64";
};

class GameConfig
{
public:
	GameConfig(std::string configFile = "games.json");

	bool LoadConfig();
	bool SaveConfig();

	void                  AddGame(const GameInfo& gameInfo);
	std::vector<GameInfo> GetAllGames() const;
	GameInfo*             FindGameByName(const std::string& name);
	GameInfo*             FindGameByProductId(const std::string& productId);

	void ListGames() const;
	bool IsEmpty() const;

	// Config settings getters
	std::string GetBaseUrl() const { return Settings.BaseUrl; }
	std::string GetDefaultPlatform() const { return Settings.DefaultPlatform; }

	// Platform related methods
	static std::vector<std::string> GetAvailablePlatforms();

private:
	std::string           ConfigFilePath;
	std::vector<GameInfo> Games;
	ConfigSettings        Settings;

	static std::string EscapeJson(const std::string& str);
	static std::string UnescapeJson(const std::string& str);
	void               ParseJsonFile(const std::string& content);
	std::string        GenerateJsonContent() const;
};

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Lucas Guilherme

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Log.cpp`:

```cpp
#include "Log.h"

namespace
{
	constexpr auto Reset   = "\x1b[0m";
	constexpr auto Bold    = "\x1b[1m";
	constexpr auto Red     = "\x1b[31m";
	constexpr auto Green   = "\x1b[32m";
	constexpr auto Yellow  = "\x1b[33m";
	constexpr auto Cyan    = "\x1b[36m";
	constexpr auto Gray    = "\x1b[90m";

	void VPrint(FILE* stream, const char* color, const char* prefix, const char* fmt, va_list args)
	{
		fprintf(stream, "%s%s", color, prefix);
		vfprintf(stream, fmt, args);
		fprintf(stream, "%s\n", Reset);
	}
}

namespace Log
{
	void Init()
	{
		SetConsoleOutputCP(CP_UTF8);

		auto enableVT = [](DWORD handle)
		{
			HANDLE h = GetStdHandle(handle);
			if (h == INVALID_HANDLE_VALUE) return;
			DWORD mode = 0;
			if (!GetConsoleMode(h, &mode)) return;
			SetConsoleMode(h, mode | ENABLE_PROCESSED_OUTPUT | ENABLE_VIRTUAL_TERMINAL_PROCESSING);
		};

		enableVT(STD_OUTPUT_HANDLE);
		enableVT(STD_ERROR_HANDLE);
	}

	void Info(const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		VPrint(stdout, "", "[*] ", fmt, args);
		va_end(args);
	}

	void Success(const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		VPrint(stdout, Green, "[+] ", fmt, args);
		va_end(args);
	}

	void Warning(const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		VPrint(stdout, Yellow, "[!] ", fmt, args);
		va_end(args);
	}

	void Error(const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		VPrint(stderr, Red, "[!] ", fmt, args);
		va_end(args);
	}

	void Banner()
	{
		printf("%s%s", Bold, Cyan);
		printf("EAC Module Downloader & Payload Extractor\n");
		printf("==========================================%s\n", Reset);
	}

	void Progress(double pct, size_t downloaded, size_t total)
	{
		constexpr int barWidth = 50;
		int pos = static_cast<int>(barWidth * (pct / 100.0));

		printf("\r[%s", Green);
		for (int i = 0; i < barWidth; ++i)
		{
			if (i < pos)       putchar('=');
			else if (i == pos) putchar('>');
			else               putchar(' ');
		}
		printf("%s] %s%s%.1f%%%s %s(%zu/%zu MB)%s",
			Reset, Bold, "", pct, Reset,
			Gray, downloaded / 1024 / 1024, total / 1024 / 1024, Reset);
		fflush(stdout);
	}
}

```

`Log.h`:

```h
#pragma once
#include <cstdio>
#include <cstdarg>
#include <Windows.h>

namespace Log
{
	void Init();

	void Info(const char* fmt, ...);
	void Success(const char* fmt, ...);
	void Warning(const char* fmt, ...);
	void Error(const char* fmt, ...);
	void Banner();
	void Progress(double pct, size_t downloaded, size_t total);
}

```

`README.md`:

```md
![EAC Decrypt and Extract Utility](https://github.com/lguilhermee/EAC-Extractor-Utility/blob/main/logo.png)
# EAC Decrypt and Extract Utility v2.0

A powerful Windows utility to decrypt and extract files from EAC (Easy Anti-Cheat) modules. Now featuring an interactive console menu, web-based module downloading, and support for multiple games!

## üöÄ Features

- **Interactive Console Menu**: User-friendly interface for easy navigation
- **Web-Based Module Downloader**: Download EAC modules directly without manual extraction
- **Local File Extraction**: Extract from existing EAC.bin files
- **Game Configuration System**: JSON-based configuration for multiple games
- **Enhanced Pattern Scanner**: Improved accuracy for module detection
- **Automatic File Extraction**: Extracts launcher, driver, and usermode components

## üìã Requirements

- Windows Operating System (Windows 10/11 recommended)
- Visual C++ Redistributables
- Internet connection (for web-based downloading)

## üéÆ Usage

### Method 1: Interactive Mode (Recommended)
Simply run the executable and follow the interactive menu:
```bash
DecryptEACPayload.exe
```

The menu will guide you through:
1. Choosing between web download or local file extraction
2. Selecting a game from the configuration
3. Automatic processing and extraction

### Method 2: Command Line
For direct file extraction:
```bash
DecryptEACPayload.exe <path_to_EAC.bin>
```

## üîç Finding Game IDs

To add new games or use custom configurations, you'll need the `productId` and `deploymentId`:

1. **Navigate to your game's EAC folder**:
   ```
   ..\[GameName]\EasyAntiCheat\
   ```
   Example: `..\Throne and Liberty\EasyAntiCheat\`

2. **Open `Settings.json`** with any text editor

3. **Look for the configuration**:
   ```json
   {
       "deploymentid": "278b7d6708d198db6305102c77abdf50",
       "executable": "TL\\Binaries\\Win64\\TL.exe",
       "hide_bootstrapper": "true",
       "hide_gui": "true",
       "productid": "21bf5373a3f1ebc9d1cbe14de40871b0",
       "requested_splash": "EasyAntiCheat/SplashScreen.png",
       "sandboxid": "9e11c91c1a3047c8e03369eb271f6f50",
       "title": "TL",
       "wait_for_game_process_exit": "false"
   }
   ```

4. **Copy the `productid` and `deploymentid`** values

5. **Add to `games.json`** or use in the console menu

## ü§ù Contributing

We welcome contributions! You can help by:

- **Adding new games**: Submit a pull request to update `games.json` with new game configurations
- **Reporting bugs**: Open an issue on GitHub
- **Improving documentation**: Help other users with better guides

### Adding a New Game to games.json

```json
{
    "name": "Your Game Name",
    "productId": "productid_from_settings.json",
    "deploymentId": "deploymentid_from_settings.json"
}
```

Submit a pull request with your additions!

## üìÅ Output Files

The utility extracts the following components:

- **EAC_Launcher.dll** - The main launcher component
- **EAC_Driver.sys** - Kernel-mode driver
- **EAC_UserMode.dll** - User-mode module

Files are saved in the current working directory or a specified output folder.

## üîß Technical Details

### How EAC Modules Work

Easy Anti-Cheat operates through a multi-stage process:

1. **Module Download**: The launcher downloads the encrypted EAC.bin module
2. **Decryption**: The binary is decrypted and loaded into memory
3. **Component Extraction**: Three main components are extracted:
   - Launcher DLL for initialization
   - Kernel driver
   - Usermode DLL
4. **Driver Loading**: The kernel driver is loaded for deep system integration
5. **Process Protection**: The usermode DLL is mapped into the game process

### Module Structure

Each EAC.bin contains:
- Encrypted launcher library code
- Encrypted usermode library code
- Encrypted kernel driver code

## üôè Acknowledgments

- Special thanks to [iPower](https://github.com/iPower) for their valuable insights
- Community contributors who maintain the game configuration list

## ‚ö†Ô∏è Legal Notice

This tool is for **educational and research purposes only**. Users are responsible for:
- Compliance with all applicable laws
- Respecting game Terms of Service
- Using the tool responsibly and ethically

**We do not encourage or support cheating in online games.**

---

If you find this tool useful, consider ‚≠ê starring the repository and contributing to the games.json list!

```

`Utils/FileUtils.cpp`:

```cpp
#include "FileUtils.h"
#include "Log.h"
#include <fstream>
#include <filesystem>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <Windows.h>

namespace FileUtils
{
	std::vector<uint8_t> LoadBinaryFile(const std::string& filePath)
	{
		std::ifstream file(filePath, std::ios::binary);
		if (!file)
		{
			Log::Error("Failed to open the file: %s", filePath.c_str());
			return {};
		}

		file.seekg(0, std::ios::end);
		std::streampos fileSize = file.tellg();
		file.seekg(0, std::ios::beg);

		std::vector<uint8_t> buffer(fileSize);

		if (!file.read(reinterpret_cast<char*>(buffer.data()), fileSize))
		{
			Log::Error("Failed to read the file: %s", filePath.c_str());
			return {};
		}

		return buffer;
	}

	bool SaveBinaryFile(const std::string& filePath, const std::vector<uint8_t>& data)
	{
		std::ofstream file(filePath, std::ios::binary);
		if (!file)
		{
			Log::Error("Failed to create the file: %s", filePath.c_str());
			return false;
		}

		file.write(reinterpret_cast<const char*>(data.data()), data.size());
		if (!file)
		{
			Log::Error("Failed to write the data to the file: %s", filePath.c_str());
			return false;
		}

		Log::Success("Saved file: %s (%zu bytes)", filePath.c_str(), data.size());
		return true;
	}

	std::string SanitizeFileName(const std::string& name)
	{
		std::string sanitized = name;
		const std::string invalid = "<>:\"|?*";
		for (char& c : sanitized) {
			if (invalid.find(c) != std::string::npos || c < 32) {
				c = '_';
			}
		}
		while (!sanitized.empty() && sanitized.back() == ' ') {
			sanitized.pop_back();
		}
		while (!sanitized.empty() && sanitized.front() == ' ') {
			sanitized.erase(0, 1);
		}
		return sanitized;
	}

	std::string GetTimestampedFolderName()
	{
		return GetTimestampedFolderName("");
	}

	std::string GetTimestampedFolderName(const std::string& gameName)
	{
		auto now    = std::chrono::system_clock::now();
		auto time_t = std::chrono::system_clock::to_time_t(now);

		tm timeinfo;
		localtime_s(&timeinfo, &time_t);

		std::stringstream ss;
		if (!gameName.empty()) {
			ss << SanitizeFileName(gameName) << "_";
		}
		ss << "Dump_"
			<< std::put_time(&timeinfo, "%Y%m%d_%H%M%S");

		return ss.str();
	}

	bool EnsureDirectoryExists(const std::string& path)
	{
		try
		{
			if (!std::filesystem::exists(path))
			{
				return std::filesystem::create_directories(path);
			}
			return true;
		}
		catch (const std::exception& e)
		{
			Log::Error("Failed to create directory: %s - %s", path.c_str(), e.what());
			return false;
		}
	}

	std::string CreateDumpFolder()
	{
		return CreateDumpFolder("");
	}

	std::string CreateDumpFolder(const std::string& gameName)
	{
		const std::string baseDir = "C:\\EAC_Dumps";

		if (!EnsureDirectoryExists(baseDir))
		{
			Log::Error("Failed to create base directory: %s", baseDir.c_str());
			return "";
		}

		std::string timestampedFolder = baseDir + "\\" + GetTimestampedFolderName(gameName);

		if (!EnsureDirectoryExists(timestampedFolder))
		{
			Log::Error("Failed to create dump folder: %s", timestampedFolder.c_str());
			return "";
		}

		Log::Success("Created dump folder: %s", timestampedFolder.c_str());
		return timestampedFolder;
	}
}

```

`Utils/FileUtils.h`:

```h
#pragma once
#include <string>
#include <vector>

namespace FileUtils
{
	std::vector<uint8_t> LoadBinaryFile(const std::string& filePath);
	bool                 SaveBinaryFile(const std::string& filePath, const std::vector<uint8_t>& data);
	std::string          CreateDumpFolder();
	std::string          CreateDumpFolder(const std::string& gameName);
	std::string          GetTimestampedFolderName();
	std::string          GetTimestampedFolderName(const std::string& gameName);
	bool                 EnsureDirectoryExists(const std::string& path);
	std::string          SanitizeFileName(const std::string& name);
}

```

`Utils/MemoryDumper.cpp`:

```cpp
#include "MemoryDumper.h"
#include "FileUtils.h"
#include "Log.h"
#include <Psapi.h>
#include <TlHelp32.h>
#include <sstream>
#include <iomanip>
#include <cstring>

#pragma comment(lib, "psapi.lib")

namespace MemoryDumper
{
	static bool FixHeaderRawToVirtual(char* pLocalImage)
	{
		auto pNtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(
			reinterpret_cast<uint64_t>(pLocalImage) +
			reinterpret_cast<PIMAGE_DOS_HEADER>(pLocalImage)->e_lfanew);

		auto pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);
		for (int i = 0; i < pNtHeaders->FileHeader.NumberOfSections; ++i, ++pSectionHeader)
		{
			pSectionHeader->PointerToRawData = pSectionHeader->VirtualAddress;
			pSectionHeader->SizeOfRawData = pSectionHeader->Misc.VirtualSize;
		}

		return true;
	}

	static std::string AppendBaseAddressToPath(const std::string& originalPath, uintptr_t baseAddress)
	{
		std::stringstream ss;
		ss << std::hex << std::uppercase << baseAddress;
		std::string baseAddrStr = ss.str();

		size_t lastDot = originalPath.find_last_of('.');
		if (lastDot != std::string::npos)
		{
			return originalPath.substr(0, lastDot) + "_0x" + baseAddrStr + originalPath.substr(lastDot);
		}
		return originalPath + "_0x" + baseAddrStr;
	}

	std::vector<uint8_t> GetModuleBytes(HMODULE hModule)
	{
		if (!hModule)
		{
			Log::Error("Invalid module handle");
			return {};
		}

		MODULEINFO modInfo = {0};
		if (!GetModuleInformation(GetCurrentProcess(), hModule, &modInfo, sizeof(modInfo)))
		{
			Log::Error("Failed to get module information");
			return {};
		}

		std::vector<uint8_t> moduleBytes(modInfo.SizeOfImage);
		SYSTEM_INFO sysInfo;
		GetSystemInfo(&sysInfo);
		DWORD pageSize = sysInfo.dwPageSize;

		SIZE_T totalBytesRead = 0;
		uint8_t* baseAddress = static_cast<uint8_t*>(modInfo.lpBaseOfDll);
		uint8_t* currentAddress = baseAddress;
		uint8_t* endAddress = baseAddress + modInfo.SizeOfImage;

		while (currentAddress < endAddress)
		{
			SIZE_T bytesToRead = min(pageSize, endAddress - currentAddress);
			SIZE_T bytesRead = 0;

			MEMORY_BASIC_INFORMATION mbi;
			if (VirtualQuery(currentAddress, &mbi, sizeof(mbi)))
			{
				if (mbi.State == MEM_COMMIT &&
				    (mbi.Protect & (PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY |
				                    PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)))
				{
					if (ReadProcessMemory(GetCurrentProcess(), currentAddress,
					                      moduleBytes.data() + (currentAddress - baseAddress),
					                      bytesToRead, &bytesRead))
					{
						totalBytesRead += bytesRead;
					}
					else
					{
						memset(moduleBytes.data() + (currentAddress - baseAddress), 0, bytesToRead);
						Log::Warning("Failed to read page at 0x%llX", (unsigned long long)(uintptr_t)currentAddress);
					}
				}
				else
				{
					memset(moduleBytes.data() + (currentAddress - baseAddress), 0, bytesToRead);
				}
			}

			currentAddress += pageSize;
		}

		Log::Success("Dumped module from memory: %u bytes (%zu bytes read)",
			modInfo.SizeOfImage, totalBytesRead);
		Log::Info("Module base address: 0x%llX",
			(unsigned long long)(uintptr_t)modInfo.lpBaseOfDll);
		return moduleBytes;
	}

	bool DumpModuleFromMemory(HMODULE hModule, const std::string& outputPath)
	{
		if (!hModule)
		{
			Log::Error("Invalid module handle");
			return false;
		}

		auto moduleBytes = GetModuleBytes(hModule);
		if (moduleBytes.empty())
		{
			return false;
		}

		if (!FixHeaderRawToVirtual(reinterpret_cast<char*>(moduleBytes.data())))
		{
			Log::Warning("Failed to fix PE header");
		}

		MODULEINFO modInfo = {0};
		if (GetModuleInformation(GetCurrentProcess(), hModule, &modInfo, sizeof(modInfo)))
		{
			std::string modifiedPath = AppendBaseAddressToPath(
				outputPath, reinterpret_cast<uintptr_t>(modInfo.lpBaseOfDll));
			return FileUtils::SaveBinaryFile(modifiedPath, moduleBytes);
		}

		return FileUtils::SaveBinaryFile(outputPath, moduleBytes);
	}

	bool DumpProcessModule(DWORD processId, const std::string& moduleName, const std::string& outputPath)
	{
		HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processId);
		if (!hProcess)
		{
			Log::Error("Failed to open process: %u", processId);
			return false;
		}

		HMODULE hMods[1024];
		DWORD   cbNeeded;

		if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))
		{
			for (unsigned int i = 0; i < (cbNeeded / sizeof(HMODULE)); i++)
			{
				char szModName[MAX_PATH];

				if (GetModuleFileNameExA(hProcess, hMods[i], szModName, sizeof(szModName) / sizeof(char)))
				{
					std::string modNameStr(szModName);
					if (modNameStr.find(moduleName) != std::string::npos)
					{
						MODULEINFO modInfo;
						if (GetModuleInformation(hProcess, hMods[i], &modInfo, sizeof(modInfo)))
						{
							std::vector<uint8_t> moduleBytes(modInfo.SizeOfImage);
							SYSTEM_INFO sysInfo;
							GetSystemInfo(&sysInfo);
							DWORD pageSize = sysInfo.dwPageSize;

							SIZE_T totalBytesRead = 0;
							uint8_t* baseAddress = static_cast<uint8_t*>(modInfo.lpBaseOfDll);
							uint8_t* currentAddress = baseAddress;
							uint8_t* endAddress = baseAddress + modInfo.SizeOfImage;

							while (currentAddress < endAddress)
							{
								SIZE_T bytesToRead = min(pageSize, endAddress - currentAddress);
								SIZE_T bytesRead = 0;

								if (!ReadProcessMemory(hProcess, currentAddress,
								                       moduleBytes.data() + (currentAddress - baseAddress),
								                       bytesToRead, &bytesRead))
								{
									memset(moduleBytes.data() + (currentAddress - baseAddress), 0, bytesToRead);
								}
								else
								{
									totalBytesRead += bytesRead;
								}

								currentAddress += pageSize;
							}

							if (totalBytesRead > 0)
							{
								Log::Success("Dumped module from process: %u bytes (%zu bytes read)",
									modInfo.SizeOfImage, totalBytesRead);
								Log::Info("Module base address: 0x%llX",
									(unsigned long long)(uintptr_t)modInfo.lpBaseOfDll);

								if (!FixHeaderRawToVirtual(reinterpret_cast<char*>(moduleBytes.data())))
								{
									Log::Warning("Failed to fix PE header");
								}

								std::string modifiedPath = AppendBaseAddressToPath(
									outputPath, reinterpret_cast<uintptr_t>(modInfo.lpBaseOfDll));
								CloseHandle(hProcess);
								return FileUtils::SaveBinaryFile(modifiedPath, moduleBytes);
							}
						}
					}
				}
			}
		}

		CloseHandle(hProcess);
		Log::Error("Module not found: %s", moduleName.c_str());
		return false;
	}
}

```

`Utils/MemoryDumper.h`:

```h
#pragma once
#include <Windows.h>
#include <vector>
#include <string>
#include <cstdint>

namespace MemoryDumper
{
	bool DumpModuleFromMemory(HMODULE hModule, const std::string& outputPath);
	std::vector<uint8_t> GetModuleBytes(HMODULE hModule);
	bool DumpProcessModule(DWORD processId, const std::string& moduleName, const std::string& outputPath);
}

```

`Utils/ModuleDownloader.cpp`:

```cpp
#include "ModuleDownloader.h"
#include "Log.h"
#include <cstdio>
#include <iomanip>
#include <Windows.h>
#include <wininet.h>

#pragma comment(lib, "wininet.lib")


std::string ModuleDownloader::BuildDownloadUrl(const std::string& productId, const std::string& deploymentId,
                                               const std::string& platform, const std::string&  baseUrl)
{
	return baseUrl + "/" + productId + "/" + deploymentId + "/" + platform;
}

bool ModuleDownloader::DownloadModule(const std::string& productId, const std::string&       deploymentId,
                                      const std::string& outputPath, const ProgressCallback& progressCallback)
{
	std::string url = BuildDownloadUrl(productId, deploymentId);
	return PerformDownload(url, outputPath, progressCallback);
}

bool ModuleDownloader::DownloadModule(const std::string&      productId, const std::string& deploymentId,
                                      const std::string&      platform, const std::string&  outputPath,
                                      const ProgressCallback& progressCallback)
{
	std::string url = BuildDownloadUrl(productId, deploymentId, platform);
	return PerformDownload(url, outputPath, progressCallback);
}

bool ModuleDownloader::DownloadModule(const std::string& productId, const std::string&       deploymentId,
                                      const std::string& platform, const std::string&        baseUrl,
                                      const std::string& outputPath, const ProgressCallback& progressCallback)
{
	std::string url = BuildDownloadUrl(productId, deploymentId, platform, baseUrl);
	return PerformDownload(url, outputPath, progressCallback);
}

bool ModuleDownloader::PerformDownload(const std::string& url, const std::string& outputPath, const ProgressCallback&
                                       progressCallback)
{
	HINTERNET hInternet = InternetOpenA("EAC Module Downloader", INTERNET_OPEN_TYPE_DIRECT, nullptr, nullptr, 0);
	if (!hInternet)
	{
		Log::Error("Failed to initialize WinINet");
		return false;
	}

	HINTERNET hUrl = InternetOpenUrlA(hInternet, url.c_str(), nullptr, 0, INTERNET_FLAG_RELOAD, 0);
	if (!hUrl)
	{
		Log::Error("Failed to open URL: %s", url.c_str());
		InternetCloseHandle(hInternet);
		return false;
	}

	DWORD bufferSize    = sizeof(DWORD);
	DWORD contentLength = 0;
	HttpQueryInfoA(hUrl, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,
	               &contentLength, &bufferSize, nullptr);

	FILE* file = nullptr;
	if (fopen_s(&file, outputPath.c_str(), "wb") != 0 || !file)
	{
		Log::Error("Failed to create output file: %s", outputPath.c_str());
		InternetCloseHandle(hUrl);
		InternetCloseHandle(hInternet);
		return false;
	}

	Log::Info("Downloading module...");
	Log::Info("URL: %s", url.c_str());
	Log::Info("Output: %s", outputPath.c_str());

	if (contentLength > 0)
	{
		Log::Info("Size: %.2f MB", contentLength / 1024.0 / 1024.0);
	}

	constexpr DWORD bufferLen = 8192;
	char            buffer[bufferLen];
	DWORD           bytesRead;
	DWORD           totalDownloaded = 0;

	while (InternetReadFile(hUrl, buffer, bufferLen, &bytesRead) && bytesRead > 0)
	{
		fwrite(buffer, 1, bytesRead, file);
		totalDownloaded += bytesRead;

		if (progressCallback && contentLength > 0)
		{
			double percentage = (static_cast<double>(totalDownloaded) / contentLength) * 100.0;
			progressCallback(percentage, totalDownloaded, contentLength);
		}
		else
		{
			printf("\r[+] Downloaded: %.2f MB", totalDownloaded / 1024.0 / 1024.0);
			fflush(stdout);
		}
	}

	printf("\n");

	fclose(file);
	InternetCloseHandle(hUrl);
	InternetCloseHandle(hInternet);

	if (totalDownloaded == 0)
	{
		Log::Error("No data downloaded");
		return false;
	}

	Log::Success("Download completed successfully!");
	Log::Info("Total downloaded: %.2f MB", totalDownloaded / 1024.0 / 1024.0);

	return true;
}

```

`Utils/ModuleDownloader.h`:

```h
#pragma once
#include <string>
#include <functional>

class ModuleDownloader
{
public:
	using ProgressCallback = std::function<void(double percentage, size_t downloaded, size_t total)>;

	static bool DownloadModule(const std::string& productId, const std::string&       deploymentId,
	                           const std::string& outputPath, const ProgressCallback& progressCallback = nullptr);

	static bool DownloadModule(const std::string&      productId, const std::string& deploymentId,
	                           const std::string&      platform, const std::string&  outputPath,
	                           const ProgressCallback& progressCallback = nullptr);

	static bool DownloadModule(const std::string& productId, const std::string&       deploymentId,
	                           const std::string& platform, const std::string&        baseUrl,
	                           const std::string& outputPath, const ProgressCallback& progressCallback = nullptr);

private:
	static std::string BuildDownloadUrl(const std::string& productId, const std::string& deploymentId,
	                                    const std::string& platform = "win64",
	                                    const std::string& baseUrl  =
		                                    "https://modules-cdn.eac-prod.on.epicgames.com/modules");
	static bool PerformDownload(const std::string&      url, const std::string& outputPath,
	                            const ProgressCallback& progressCallback);
};

```

`Utils/PatternScanner.cpp`:

```cpp
#include "PatternScanner.h"
#include "Log.h"
#include <cstring>

namespace PatternScanner
{
	uintptr_t ResolveRelative(uintptr_t addressPointer, ULONG offsetCount, ULONG sizeOfInstruction)
	{
		const ULONG_PTR addressToResolve = addressPointer;
		const LONG      totalBytesFromSpecifiedAddress = *(PLONG)(addressToResolve + offsetCount);
		const uintptr_t resultFinal = (addressToResolve + sizeOfInstruction + totalBytesFromSpecifiedAddress);

		return resultFinal;
	}

	std::vector<uintptr_t> PatternScan(uintptr_t moduleAddress, const char* signature)
	{
		std::vector<uintptr_t> results;

		if (!moduleAddress)
			return results;

		auto patternToByte = [](const char* pattern)
		{
			auto       bytes = std::vector<int>{};
			const auto start = const_cast<char*>(pattern);
			const auto end   = const_cast<char*>(pattern) + strlen(pattern);

			for (auto current = start; current < end; ++current)
			{
				if (*current == '?')
				{
					++current;
					if (*current == '?')
						++current;
					bytes.push_back(-1);
				}
				else
				{
					bytes.push_back(strtoul(current, &current, 16));
				}
			}
			return bytes;
		};

		const auto dosHeader = (PIMAGE_DOS_HEADER)moduleAddress;
		const auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)moduleAddress + dosHeader->e_lfanew);

		const auto sizeOfImage  = ntHeaders->OptionalHeader.SizeOfImage;
		auto       patternBytes = patternToByte(signature);
		const auto scanBytes    = reinterpret_cast<std::uint8_t*>(moduleAddress);

		const auto s = patternBytes.size();
		const auto d = patternBytes.data();

		for (auto i = 0ul; i < sizeOfImage - s; ++i)
		{
			bool found = true;
			for (auto j = 0ul; j < s; ++j)
			{
				if (scanBytes[i + j] != d[j] && d[j] != -1)
				{
					found = false;
					break;
				}
			}
			if (found)
			{
				results.push_back(reinterpret_cast<uintptr_t>(&scanBytes[i]));
			}
		}

		return results;
	}

	uintptr_t FindFirstMatch(uintptr_t moduleAddress, const char* signature)
	{
		auto results = PatternScan(moduleAddress, signature);
		if (!results.empty())
		{
			Log::Success("Pattern found: %s at 0x%llX", signature, (unsigned long long)results[0]);
			return results[0];
		}
		Log::Warning("Pattern not found: %s", signature);
		return 0;
	}
}

```

`Utils/PatternScanner.h`:

```h
#pragma once
#include <vector>
#include <cstdint>
#include <Windows.h>

namespace PatternScanner
{
	std::vector<uintptr_t> PatternScan(uintptr_t moduleAddress, const char* signature);
	uintptr_t              ResolveRelative(uintptr_t addressPointer, ULONG offsetCount, ULONG sizeOfInstruction);
	uintptr_t              FindFirstMatch(uintptr_t moduleAddress, const char* signature);
}

```

`Utils/kraken.cpp`:

```cpp
/*
=== Kraken Decompressor ===
Copyright (C) 2016, Powzix

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "kraken.h"

// Header in front of each 256k block
typedef struct KrakenHeader
{
	// Type of decoder used, 6 means kraken
	int decoder_type;

	// Whether to restart the decoder
	bool restart_decoder;

	// Whether this block is uncompressed
	bool uncompressed;

	// Whether this block uses checksums.
	bool use_checksums;
} KrakenHeader;

// Additional header in front of each 256k block ("quantum").
typedef struct KrakenQuantumHeader
{
	// The compressed size of this quantum. If this value is 0 it means
	// the quantum is a special quantum such as memset.
	uint32 compressed_size;
	// If checksums are enabled, holds the checksum.
	uint32 checksum;
	// Two flags
	uint8 flag1;
	uint8 flag2;
	// Whether the whole block matched a previous block
	uint32 whole_match_distance;
} KrakenQuantumHeader;

// Kraken decompression happens in two phases, first one decodes
// all the literals and copy lengths using huffman and second
// phase runs the copy loop. This holds the tables needed by stage 2.
typedef struct KrakenLzTable
{
	// Stream of (literal, match) pairs. The flag byte contains
	// the length of the match, the length of the literal and whether
	// to use a recent offset.
	byte* cmd_stream;
	int cmd_stream_size;

	// Holds the actual distances in case we're not using a recent
	// offset.
	int* offs_stream;
	int offs_stream_size;

	// Holds the sequence of literals. All literal copying happens from
	// here.
	byte* lit_stream;
	int lit_stream_size;

	// Holds the lengths that do not fit in the flag stream. Both literal
	// lengths and match length are stored in the same array.
	int* len_stream;
	int len_stream_size;
} KrakenLzTable;

typedef struct KrakenDecoder
{
	// Updated after the |*_DecodeStep| function completes to hold
	// the number of bytes read and written.
	int src_used, dst_used;

	// Pointer to a 256k buffer that holds the intermediate state
	// in between decode phase 1 and 2.
	byte* scratch;
	size_t scratch_size;

	KrakenHeader hdr;
} KrakenDecoder;

typedef struct BitReader
{
	// |p| holds the current byte and |p_end| the end of the buffer.
	const byte* p, * p_end;
	// Bits accumulated so far
	uint32 bits;
	// Next byte will end up in the |bitpos| position in |bits|.
	int bitpos;
} BitReader;

struct HuffRevLut
{
	uint8 bits2len[2048];
	uint8 bits2sym[2048];
};

typedef struct HuffReader
{
	// Array to hold the output of the huffman read array operation
	byte* output, * output_end;
	// We decode three parallel streams, two forwards, |src| and |src_mid|
	// while |src_end| is decoded backwards.
	const byte* src, * src_mid, * src_end, * src_mid_org;
	int src_bitpos, src_mid_bitpos, src_end_bitpos;
	uint32 src_bits, src_mid_bits, src_end_bits;
} HuffReader;

inline size_t Max( size_t a, size_t b ) { return a > b ? a : b; }
inline size_t Min( size_t a, size_t b ) { return a < b ? a : b; }

#define ALIGN_POINTER(p, align) ((uint8 *)(((uintptr_t)(p) + (align - 1)) & ~(align - 1)))

struct HuffRange;

int Kraken_DecodeBytes( byte** output, const byte* src, const byte* src_end, int* decoded_size, size_t output_size,
	bool force_memmove, uint8* scratch, uint8* scratch_end );
int Kraken_GetBlockSize( const uint8* src, const uint8* src_end, int* dest_size, int dest_capacity );
int Huff_ConvertToRanges( HuffRange* range, int num_symbols, int P, const uint8* symlen, BitReader* bits );

// Allocate memory with a specific alignment
void* MallocAligned( size_t size, size_t alignment )
{
	void* x = malloc( size + ( alignment - 1 ) + sizeof( void* ) ), * x_org = x;
	if ( x )
	{
		x = (void*)( ( (intptr_t)x + alignment - 1 + sizeof( void* ) ) & ~( alignment - 1 ) );
		( (void**)x )[-1] = x_org;
	}
	return x;
}

// Free memory allocated through |MallocAligned|
void FreeAligned( void* p ) { free( ( (void**)p )[-1] ); }

uint32 BSR( uint32 x )
{
	unsigned long index;
	_BitScanReverse( &index, x );
	return index;
}

uint32 BSF( uint32 x )
{
	unsigned long index;
	_BitScanForward( &index, x );
	return index;
}

// Read more bytes to make sure we always have at least 24 bits in |bits|.
void BitReader_Refill( BitReader* bits )
{
	assert( bits->bitpos <= 24 );
	while ( bits->bitpos > 0 )
	{
		bits->bits |= ( bits->p < bits->p_end ? *bits->p : 0 ) << bits->bitpos;
		bits->bitpos -= 8;
		bits->p++;
	}
}

// Read more bytes to make sure we always have at least 24 bits in |bits|,
// used when reading backwards.
void BitReader_RefillBackwards( BitReader* bits )
{
	assert( bits->bitpos <= 24 );
	while ( bits->bitpos > 0 )
	{
		bits->p--;
		bits->bits |= ( bits->p >= bits->p_end ? *bits->p : 0 ) << bits->bitpos;
		bits->bitpos -= 8;
	}
}

// Refill bits then read a single bit.
int BitReader_ReadBit( BitReader* bits )
{
	int r;
	BitReader_Refill( bits );
	r = bits->bits >> 31;
	bits->bits <<= 1;
	bits->bitpos += 1;
	return r;
}

int BitReader_ReadBitNoRefill( BitReader* bits )
{
	int r;
	r = bits->bits >> 31;
	bits->bits <<= 1;
	bits->bitpos += 1;
	return r;
}

// Read |n| bits without refilling.
int BitReader_ReadBitsNoRefill( BitReader* bits, int n )
{
	int r = ( bits->bits >> ( 32 - n ) );
	bits->bits <<= n;
	bits->bitpos += n;
	return r;
}

// Read |n| bits without refilling, n may be zero.
int BitReader_ReadBitsNoRefillZero( BitReader* bits, int n )
{
	int r = ( bits->bits >> 1 >> ( 31 - n ) );
	bits->bits <<= n;
	bits->bitpos += n;
	return r;
}

uint32 BitReader_ReadMoreThan24Bits( BitReader* bits, int n )
{
	uint32 rv;
	if ( n <= 24 )
	{
		rv = BitReader_ReadBitsNoRefillZero( bits, n );
	}
	else
	{
		rv = BitReader_ReadBitsNoRefill( bits, 24 ) << ( n - 24 );
		BitReader_Refill( bits );
		rv += BitReader_ReadBitsNoRefill( bits, n - 24 );
	}
	BitReader_Refill( bits );
	return rv;
}

uint32 BitReader_ReadMoreThan24BitsB( BitReader* bits, int n )
{
	uint32 rv;
	if ( n <= 24 )
	{
		rv = BitReader_ReadBitsNoRefillZero( bits, n );
	}
	else
	{
		rv = BitReader_ReadBitsNoRefill( bits, 24 ) << ( n - 24 );
		BitReader_RefillBackwards( bits );
		rv += BitReader_ReadBitsNoRefill( bits, n - 24 );
	}
	BitReader_RefillBackwards( bits );
	return rv;
}

// Reads a gamma value.
// Assumes bitreader is already filled with at least 23 bits
int BitReader_ReadGamma( BitReader* bits )
{
	unsigned long bitresult;
	int n;
	int r;
	if ( bits->bits != 0 )
	{
		_BitScanReverse( &bitresult, bits->bits );
		n = 31 - bitresult;
	}
	else
	{
		n = 32;
	}
	n = 2 * n + 2;
	assert( n < 24 );
	bits->bitpos += n;
	r = bits->bits >> ( 32 - n );
	bits->bits <<= n;
	return r - 2;
}

int CountLeadingZeros( uint32 bits )
{
	unsigned long x;
	_BitScanReverse( &x, bits );
	return 31 - x;
}

// Reads a gamma value with |forced| number of forced bits.
int BitReader_ReadGammaX( BitReader* bits, int forced )
{
	unsigned long bitresult;
	int r;
	if ( bits->bits != 0 )
	{
		_BitScanReverse( &bitresult, bits->bits );
		int lz = 31 - bitresult;
		assert( lz < 24 );
		r = ( bits->bits >> ( 31 - lz - forced ) ) + ( ( lz - 1 ) << forced );
		bits->bits <<= lz + forced + 1;
		bits->bitpos += lz + forced + 1;
		return r;
	}
	return 0;
}

// Reads a offset code parametrized by |v|.
uint32 BitReader_ReadDistance( BitReader* bits, uint32 v )
{
	uint32 w, m, n, rv;
	if ( v < 0xF0 )
	{
		n = ( v >> 4 ) + 4;
		w = _rotl( bits->bits | 1, n );
		bits->bitpos += n;
		m = ( 2 << n ) - 1;
		bits->bits = w & ~m;
		rv = ( ( w & m ) << 4 ) + ( v & 0xF ) - 248;
	}
	else
	{
		n = v - 0xF0 + 4;
		w = _rotl( bits->bits | 1, n );
		bits->bitpos += n;
		m = ( 2 << n ) - 1;
		bits->bits = w & ~m;
		rv = 8322816 + ( ( w & m ) << 12 );
		BitReader_Refill( bits );
		rv += ( bits->bits >> 20 );
		bits->bitpos += 12;
		bits->bits <<= 12;
	}
	BitReader_Refill( bits );
	return rv;
}

// Reads a offset code parametrized by |v|, backwards.
uint32 BitReader_ReadDistanceB( BitReader* bits, uint32 v )
{
	uint32 w, m, n, rv;
	if ( v < 0xF0 )
	{
		n = ( v >> 4 ) + 4;
		w = _rotl( bits->bits | 1, n );
		bits->bitpos += n;
		m = ( 2 << n ) - 1;
		bits->bits = w & ~m;
		rv = ( ( w & m ) << 4 ) + ( v & 0xF ) - 248;
	}
	else
	{
		n = v - 0xF0 + 4;
		w = _rotl( bits->bits | 1, n );
		bits->bitpos += n;
		m = ( 2 << n ) - 1;
		bits->bits = w & ~m;
		rv = 8322816 + ( ( w & m ) << 12 );
		BitReader_RefillBackwards( bits );
		rv += ( bits->bits >> ( 32 - 12 ) );
		bits->bitpos += 12;
		bits->bits <<= 12;
	}
	BitReader_RefillBackwards( bits );
	return rv;
}

// Reads a length code.
bool BitReader_ReadLength( BitReader* bits, uint32* v )
{
	unsigned long bitresult;
	int n;
	uint32 rv;
	_BitScanReverse( &bitresult, bits->bits );
	n = 31 - bitresult;
	if ( n > 12 )
		return false;
	bits->bitpos += n;
	bits->bits <<= n;
	BitReader_Refill( bits );
	n += 7;
	bits->bitpos += n;
	rv = ( bits->bits >> ( 32 - n ) ) - 64;
	bits->bits <<= n;
	*v = rv;
	BitReader_Refill( bits );
	return true;
}

// Reads a length code, backwards.
bool BitReader_ReadLengthB( BitReader* bits, uint32* v )
{
	unsigned long bitresult;
	int n;
	uint32 rv;
	_BitScanReverse( &bitresult, bits->bits );
	n = 31 - bitresult;
	if ( n > 12 )
		return false;
	bits->bitpos += n;
	bits->bits <<= n;
	BitReader_RefillBackwards( bits );
	n += 7;
	bits->bitpos += n;
	rv = ( bits->bits >> ( 32 - n ) ) - 64;
	bits->bits <<= n;
	*v = rv;
	BitReader_RefillBackwards( bits );
	return true;
}

int Log2RoundUp( uint32 v )
{
	if ( v > 1 )
	{
		unsigned long idx;
		_BitScanReverse( &idx, v - 1 );
		return idx + 1;
	}
	else
	{
		return 0;
	}
}

#define ALIGN_16(x) (((x) + 15) & ~15)
#define COPY_64(d, s)                                                                                                  \
	{                                                                                                                  \
		*(uint64 *)(d) = *(uint64 *)(s);                                                                               \
	}
#define COPY_64_BYTES(d, s)                                                                                            \
	{                                                                                                                  \
		_mm_storeu_si128((__m128i *)d + 0, _mm_loadu_si128((__m128i *)s + 0));                                         \
		_mm_storeu_si128((__m128i *)d + 1, _mm_loadu_si128((__m128i *)s + 1));                                         \
		_mm_storeu_si128((__m128i *)d + 2, _mm_loadu_si128((__m128i *)s + 2));                                         \
		_mm_storeu_si128((__m128i *)d + 3, _mm_loadu_si128((__m128i *)s + 3));                                         \
	}

#define COPY_64_ADD(d, s, t)                                                                                           \
	_mm_storel_epi64((__m128i *)(d), _mm_add_epi8(_mm_loadl_epi64((__m128i *)(s)), _mm_loadl_epi64((__m128i *)(t))))

KrakenDecoder* Kraken_Create( )
{
	size_t scratch_size = 0x6C000;
	size_t memory_needed = sizeof( KrakenDecoder ) + scratch_size;
	KrakenDecoder* dec = (KrakenDecoder*)MallocAligned( memory_needed, 16 );
	memset( dec, 0, sizeof( KrakenDecoder ) );
	dec->scratch_size = scratch_size;
	dec->scratch = (byte*)( dec + 1 );
	return dec;
}

void Kraken_Destroy( KrakenDecoder* kraken ) { FreeAligned( kraken ); }

const byte* Kraken_ParseHeader( KrakenHeader* hdr, const byte* p )
{
	int b = p[0];
	if ( ( b & 0xF ) == 0xC )
	{
		if ( ( ( b >> 4 ) & 3 ) != 0 )
			return NULL;
		hdr->restart_decoder = ( b >> 7 ) & 1;
		hdr->uncompressed = ( b >> 6 ) & 1;
		b = p[1];
		hdr->decoder_type = b & 0x7F;
		hdr->use_checksums = !!( b >> 7 );
		if ( hdr->decoder_type != 6 && hdr->decoder_type != 10 && hdr->decoder_type != 5 && hdr->decoder_type != 11 &&
			hdr->decoder_type != 12 )
			return NULL;
		return p + 2;
	}

	return NULL;
}

const byte* Kraken_ParseQuantumHeader( KrakenQuantumHeader* hdr, const byte* p, bool use_checksum )
{
	uint32 v = ( p[0] << 16 ) | ( p[1] << 8 ) | p[2];
	uint32 size = v & 0x3FFFF;
	if ( size != 0x3ffff )
	{
		hdr->compressed_size = size + 1;
		hdr->flag1 = ( v >> 18 ) & 1;
		hdr->flag2 = ( v >> 19 ) & 1;
		if ( use_checksum )
		{
			hdr->checksum = ( p[3] << 16 ) | ( p[4] << 8 ) | p[5];
			return p + 6;
		}
		else
		{
			return p + 3;
		}
	}
	v >>= 18;
	if ( v == 1 )
	{
		// memset
		hdr->checksum = p[3];
		hdr->compressed_size = 0;
		hdr->whole_match_distance = 0;
		return p + 4;
	}
	return NULL;
}

const byte* LZNA_ParseWholeMatchInfo( const byte* p, uint32* dist )
{
	uint32 v = _byteswap_ushort( *(uint16*)p );

	if ( v < 0x8000 )
	{
		uint32 x = 0, b, pos = 0;
		for ( ;;)
		{
			b = p[2];
			p += 1;
			if ( b & 0x80 )
				break;
			x += ( b + 0x80 ) << pos;
			pos += 7;
		}
		x += ( b - 128 ) << pos;
		*dist = 0x8000 + v + ( x << 15 ) + 1;
		return p + 2;
	}
	else
	{
		*dist = v - 0x8000 + 1;
		return p + 2;
	}
}

const byte* LZNA_ParseQuantumHeader( KrakenQuantumHeader* hdr, const byte* p, bool use_checksum, int raw_len )
{
	uint32 v = ( p[0] << 8 ) | p[1];
	uint32 size = v & 0x3FFF;
	if ( size != 0x3fff )
	{
		hdr->compressed_size = size + 1;
		hdr->flag1 = ( v >> 14 ) & 1;
		hdr->flag2 = ( v >> 15 ) & 1;
		if ( use_checksum )
		{
			hdr->checksum = ( p[2] << 16 ) | ( p[3] << 8 ) | p[4];
			return p + 5;
		}
		else
		{
			return p + 2;
		}
	}
	v >>= 14;
	if ( v == 0 )
	{
		p = LZNA_ParseWholeMatchInfo( p + 2, &hdr->whole_match_distance );
		hdr->compressed_size = 0;
		return p;
	}
	if ( v == 1 )
	{
		// memset
		hdr->checksum = p[2];
		hdr->compressed_size = 0;
		hdr->whole_match_distance = 0;
		return p + 3;
	}
	if ( v == 2 )
	{
		// uncompressed
		hdr->compressed_size = raw_len;
		return p + 2;
	}
	return NULL;
}

uint32 Kraken_GetCrc( const byte* p, size_t p_size )
{
	// TODO: implement
	return 0;
}

// Rearranges elements in the input array so that bits in the index
// get flipped.
static void ReverseBitsArray2048( const byte* input, byte* output )
{
	static const uint8 offsets[32] = { 0,	0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50,
									  0xD0, 0x30, 0xB0, 0x70, 0xF0, 0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8,
									  0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8 };
	__m128i t0, t1, t2, t3, s0, s1, s2, s3;
	int i, j;
	for ( i = 0; i != 32; i++ )
	{
		j = offsets[i];
		t0 = _mm_unpacklo_epi8( _mm_loadl_epi64( ( const __m128i* ) & input[j] ),
			_mm_loadl_epi64( ( const __m128i* ) & input[j + 256] ) );
		t1 = _mm_unpacklo_epi8( _mm_loadl_epi64( ( const __m128i* ) & input[j + 512] ),
			_mm_loadl_epi64( ( const __m128i* ) & input[j + 768] ) );
		t2 = _mm_unpacklo_epi8( _mm_loadl_epi64( ( const __m128i* ) & input[j + 1024] ),
			_mm_loadl_epi64( ( const __m128i* ) & input[j + 1280] ) );
		t3 = _mm_unpacklo_epi8( _mm_loadl_epi64( ( const __m128i* ) & input[j + 1536] ),
			_mm_loadl_epi64( ( const __m128i* ) & input[j + 1792] ) );

		s0 = _mm_unpacklo_epi8( t0, t1 );
		s1 = _mm_unpacklo_epi8( t2, t3 );
		s2 = _mm_unpackhi_epi8( t0, t1 );
		s3 = _mm_unpackhi_epi8( t2, t3 );

		t0 = _mm_unpacklo_epi8( s0, s1 );
		t1 = _mm_unpacklo_epi8( s2, s3 );
		t2 = _mm_unpackhi_epi8( s0, s1 );
		t3 = _mm_unpackhi_epi8( s2, s3 );

		_mm_storel_epi64( ( __m128i* ) & output[0], t0 );
		_mm_storeh_pi( ( __m64* ) & output[1024], _mm_castsi128_ps( t0 ) );
		_mm_storel_epi64( ( __m128i* ) & output[256], t1 );
		_mm_storeh_pi( ( __m64* ) & output[1280], _mm_castsi128_ps( t1 ) );
		_mm_storel_epi64( ( __m128i* ) & output[512], t2 );
		_mm_storeh_pi( ( __m64* ) & output[1536], _mm_castsi128_ps( t2 ) );
		_mm_storel_epi64( ( __m128i* ) & output[768], t3 );
		_mm_storeh_pi( ( __m64* ) & output[1792], _mm_castsi128_ps( t3 ) );
		output += 8;
	}
}

bool Kraken_DecodeBytesCore( HuffReader* hr, HuffRevLut* lut )
{
	const byte* src = hr->src;
	uint32 src_bits = hr->src_bits;
	int src_bitpos = hr->src_bitpos;

	const byte* src_mid = hr->src_mid;
	uint32 src_mid_bits = hr->src_mid_bits;
	int src_mid_bitpos = hr->src_mid_bitpos;

	const byte* src_end = hr->src_end;
	uint32 src_end_bits = hr->src_end_bits;
	int src_end_bitpos = hr->src_end_bitpos;

	int k, n;

	byte* dst = hr->output;
	byte* dst_end = hr->output_end;

	if ( src > src_mid )
		return false;

	if ( hr->src_end - src_mid >= 4 && dst_end - dst >= 6 )
	{
		dst_end -= 5;
		src_end -= 4;

		while ( dst < dst_end && src <= src_mid && src_mid <= src_end )
		{
			src_bits |= *(uint32*)src << src_bitpos;
			src += ( 31 - src_bitpos ) >> 3;

			src_end_bits |= _byteswap_ulong( *(uint32*)src_end ) << src_end_bitpos;
			src_end -= ( 31 - src_end_bitpos ) >> 3;

			src_mid_bits |= *(uint32*)src_mid << src_mid_bitpos;
			src_mid += ( 31 - src_mid_bitpos ) >> 3;

			src_bitpos |= 0x18;
			src_end_bitpos |= 0x18;
			src_mid_bitpos |= 0x18;

			k = src_bits & 0x7FF;
			n = lut->bits2len[k];
			src_bits >>= n;
			src_bitpos -= n;
			dst[0] = lut->bits2sym[k];

			k = src_end_bits & 0x7FF;
			n = lut->bits2len[k];
			src_end_bits >>= n;
			src_end_bitpos -= n;
			dst[1] = lut->bits2sym[k];

			k = src_mid_bits & 0x7FF;
			n = lut->bits2len[k];
			src_mid_bits >>= n;
			src_mid_bitpos -= n;
			dst[2] = lut->bits2sym[k];

			k = src_bits & 0x7FF;
			n = lut->bits2len[k];
			src_bits >>= n;
			src_bitpos -= n;
			dst[3] = lut->bits2sym[k];

			k = src_end_bits & 0x7FF;
			n = lut->bits2len[k];
			src_end_bits >>= n;
			src_end_bitpos -= n;
			dst[4] = lut->bits2sym[k];

			k = src_mid_bits & 0x7FF;
			n = lut->bits2len[k];
			src_mid_bits >>= n;
			src_mid_bitpos -= n;
			dst[5] = lut->bits2sym[k];
			dst += 6;
		}
		dst_end += 5;

		src -= src_bitpos >> 3;
		src_bitpos &= 7;

		src_end += 4 + ( src_end_bitpos >> 3 );
		src_end_bitpos &= 7;

		src_mid -= src_mid_bitpos >> 3;
		src_mid_bitpos &= 7;
	}
	for ( ;;)
	{
		if ( dst >= dst_end )
			break;

		if ( src_mid - src <= 1 )
		{
			if ( src_mid - src == 1 )
				src_bits |= *src << src_bitpos;
		}
		else
		{
			src_bits |= *(uint16*)src << src_bitpos;
		}
		k = src_bits & 0x7FF;
		n = lut->bits2len[k];
		src_bitpos -= n;
		src_bits >>= n;
		*dst++ = lut->bits2sym[k];
		src += ( 7 - src_bitpos ) >> 3;
		src_bitpos &= 7;

		if ( dst < dst_end )
		{
			if ( src_end - src_mid <= 1 )
			{
				if ( src_end - src_mid == 1 )
				{
					src_end_bits |= *src_mid << src_end_bitpos;
					src_mid_bits |= *src_mid << src_mid_bitpos;
				}
			}
			else
			{
				unsigned int v = *(uint16*)( src_end - 2 );
				src_end_bits |= ( ( ( v >> 8 ) | ( v << 8 ) ) & 0xffff ) << src_end_bitpos;
				src_mid_bits |= *(uint16*)src_mid << src_mid_bitpos;
			}
			n = lut->bits2len[src_end_bits & 0x7FF];
			*dst++ = lut->bits2sym[src_end_bits & 0x7FF];
			src_end_bitpos -= n;
			src_end_bits >>= n;
			src_end -= ( 7 - src_end_bitpos ) >> 3;
			src_end_bitpos &= 7;
			if ( dst < dst_end )
			{
				n = lut->bits2len[src_mid_bits & 0x7FF];
				*dst++ = lut->bits2sym[src_mid_bits & 0x7FF];
				src_mid_bitpos -= n;
				src_mid_bits >>= n;
				src_mid += ( 7 - src_mid_bitpos ) >> 3;
				src_mid_bitpos &= 7;
			}
		}
		if ( src > src_mid || src_mid > src_end )
			return false;
	}
	if ( src != hr->src_mid_org || src_end != src_mid )
		return false;
	return true;
}

int Huff_ReadCodeLengthsOld( BitReader* bits, uint8* syms, uint32* code_prefix )
{
	if ( BitReader_ReadBitNoRefill( bits ) )
	{
		int n, sym = 0, codelen, num_symbols = 0;
		int avg_bits_x4 = 32;
		int forced_bits = BitReader_ReadBitsNoRefill( bits, 2 );

		uint32 thres_for_valid_gamma_bits = 1 << ( 31 - ( 20u >> forced_bits ) );
		if ( BitReader_ReadBit( bits ) )
			goto SKIP_INITIAL_ZEROS;
		do
		{
			// Run of zeros
			if ( !( bits->bits & 0xff000000 ) )
				return -1;
			sym += BitReader_ReadBitsNoRefill( bits, 2 * ( CountLeadingZeros( bits->bits ) + 1 ) ) - 2 + 1;
			if ( sym >= 256 )
				break;
		SKIP_INITIAL_ZEROS:
			BitReader_Refill( bits );
			// Read out the gamma value for the # of symbols
			if ( !( bits->bits & 0xff000000 ) )
				return -1;
			n = BitReader_ReadBitsNoRefill( bits, 2 * ( CountLeadingZeros( bits->bits ) + 1 ) ) - 2 + 1;
			// Overflow?
			if ( sym + n > 256 )
				return -1;
			BitReader_Refill( bits );
			num_symbols += n;
			do
			{
				if ( bits->bits < thres_for_valid_gamma_bits )
					return -1; // too big gamma value?

				int lz = CountLeadingZeros( bits->bits );
				int v = BitReader_ReadBitsNoRefill( bits, lz + forced_bits + 1 ) + ( ( lz - 1 ) << forced_bits );
				codelen = ( -(int)( v & 1 ) ^ ( v >> 1 ) ) + ( ( avg_bits_x4 + 2 ) >> 2 );
				if ( codelen < 1 || codelen > 11 )
					return -1;
				avg_bits_x4 = codelen + ( ( 3 * avg_bits_x4 + 2 ) >> 2 );
				BitReader_Refill( bits );
				syms[code_prefix[codelen]++] = sym++;
			} while ( --n );
		} while ( sym != 256 );
		return ( sym == 256 ) && ( num_symbols >= 2 ) ? num_symbols : -1;
	}
	else
	{
		// Sparse symbol encoding
		int num_symbols = BitReader_ReadBitsNoRefill( bits, 8 );
		if ( num_symbols == 0 )
			return -1;
		if ( num_symbols == 1 )
		{
			syms[0] = BitReader_ReadBitsNoRefill( bits, 8 );
		}
		else
		{
			int codelen_bits = BitReader_ReadBitsNoRefill( bits, 3 );
			if ( codelen_bits > 4 )
				return -1;
			for ( int i = 0; i < num_symbols; i++ )
			{
				BitReader_Refill( bits );
				int sym = BitReader_ReadBitsNoRefill( bits, 8 );
				int codelen = BitReader_ReadBitsNoRefillZero( bits, codelen_bits ) + 1;
				if ( codelen > 11 )
					return -1;
				syms[code_prefix[codelen]++] = sym;
			}
		}
		return num_symbols;
	}
}

int BitReader_ReadFluff( BitReader* bits, int num_symbols )
{
	unsigned long y;

	if ( num_symbols == 256 )
		return 0;

	int x = 257 - num_symbols;
	if ( x > num_symbols )
		x = num_symbols;

	x *= 2;

	_BitScanReverse( &y, x - 1 );
	y += 1;

	uint32 v = bits->bits >> ( 32 - y );
	uint32 z = ( 1 << y ) - x;

	if ( ( v >> 1 ) >= z )
	{
		bits->bits <<= y;
		bits->bitpos += y;
		return v - z;
	}
	else
	{
		bits->bits <<= ( y - 1 );
		bits->bitpos += ( y - 1 );
		return ( v >> 1 );
	}
}

struct BitReader2
{
	const uint8* p, * p_end;
	uint32 bitpos;
};

static const uint32 kRiceCodeBits2Value[256] = {
	0x80000000, 0x00000007, 0x10000006, 0x00000006, 0x20000005, 0x00000105, 0x10000005, 0x00000005, 0x30000004,
	0x00000204, 0x10000104, 0x00000104, 0x20000004, 0x00010004, 0x10000004, 0x00000004, 0x40000003, 0x00000303,
	0x10000203, 0x00000203, 0x20000103, 0x00010103, 0x10000103, 0x00000103, 0x30000003, 0x00020003, 0x10010003,
	0x00010003, 0x20000003, 0x01000003, 0x10000003, 0x00000003, 0x50000002, 0x00000402, 0x10000302, 0x00000302,
	0x20000202, 0x00010202, 0x10000202, 0x00000202, 0x30000102, 0x00020102, 0x10010102, 0x00010102, 0x20000102,
	0x01000102, 0x10000102, 0x00000102, 0x40000002, 0x00030002, 0x10020002, 0x00020002, 0x20010002, 0x01010002,
	0x10010002, 0x00010002, 0x30000002, 0x02000002, 0x11000002, 0x01000002, 0x20000002, 0x00000012, 0x10000002,
	0x00000002, 0x60000001, 0x00000501, 0x10000401, 0x00000401, 0x20000301, 0x00010301, 0x10000301, 0x00000301,
	0x30000201, 0x00020201, 0x10010201, 0x00010201, 0x20000201, 0x01000201, 0x10000201, 0x00000201, 0x40000101,
	0x00030101, 0x10020101, 0x00020101, 0x20010101, 0x01010101, 0x10010101, 0x00010101, 0x30000101, 0x02000101,
	0x11000101, 0x01000101, 0x20000101, 0x00000111, 0x10000101, 0x00000101, 0x50000001, 0x00040001, 0x10030001,
	0x00030001, 0x20020001, 0x01020001, 0x10020001, 0x00020001, 0x30010001, 0x02010001, 0x11010001, 0x01010001,
	0x20010001, 0x00010011, 0x10010001, 0x00010001, 0x40000001, 0x03000001, 0x12000001, 0x02000001, 0x21000001,
	0x01000011, 0x11000001, 0x01000001, 0x30000001, 0x00000021, 0x10000011, 0x00000011, 0x20000001, 0x00001001,
	0x10000001, 0x00000001, 0x70000000, 0x00000600, 0x10000500, 0x00000500, 0x20000400, 0x00010400, 0x10000400,
	0x00000400, 0x30000300, 0x00020300, 0x10010300, 0x00010300, 0x20000300, 0x01000300, 0x10000300, 0x00000300,
	0x40000200, 0x00030200, 0x10020200, 0x00020200, 0x20010200, 0x01010200, 0x10010200, 0x00010200, 0x30000200,
	0x02000200, 0x11000200, 0x01000200, 0x20000200, 0x00000210, 0x10000200, 0x00000200, 0x50000100, 0x00040100,
	0x10030100, 0x00030100, 0x20020100, 0x01020100, 0x10020100, 0x00020100, 0x30010100, 0x02010100, 0x11010100,
	0x01010100, 0x20010100, 0x00010110, 0x10010100, 0x00010100, 0x40000100, 0x03000100, 0x12000100, 0x02000100,
	0x21000100, 0x01000110, 0x11000100, 0x01000100, 0x30000100, 0x00000120, 0x10000110, 0x00000110, 0x20000100,
	0x00001100, 0x10000100, 0x00000100, 0x60000000, 0x00050000, 0x10040000, 0x00040000, 0x20030000, 0x01030000,
	0x10030000, 0x00030000, 0x30020000, 0x02020000, 0x11020000, 0x01020000, 0x20020000, 0x00020010, 0x10020000,
	0x00020000, 0x40010000, 0x03010000, 0x12010000, 0x02010000, 0x21010000, 0x01010010, 0x11010000, 0x01010000,
	0x30010000, 0x00010020, 0x10010010, 0x00010010, 0x20010000, 0x00011000, 0x10010000, 0x00010000, 0x50000000,
	0x04000000, 0x13000000, 0x03000000, 0x22000000, 0x02000010, 0x12000000, 0x02000000, 0x31000000, 0x01000020,
	0x11000010, 0x01000010, 0x21000000, 0x01001000, 0x11000000, 0x01000000, 0x40000000, 0x00000030, 0x10000020,
	0x00000020, 0x20000010, 0x00001010, 0x10000010, 0x00000010, 0x30000000, 0x00002000, 0x10001000, 0x00001000,
	0x20000000, 0x00100000, 0x10000000, 0x00000000,
};

static const uint8 kRiceCodeBits2Len[256] = {
	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2,
	3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3,
	3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5,
	6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4,
	3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4,
	5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6,
	6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
};

bool DecodeGolombRiceLengths( uint8* dst, size_t size, BitReader2* br )
{
	const uint8* p = br->p, * p_end = br->p_end;
	uint8* dst_end = dst + size;
	if ( p >= p_end )
		return false;

	int count = -(int)br->bitpos;
	uint32 v = *p++ & ( 255 >> br->bitpos );
	for ( ;;)
	{
		if ( v == 0 )
		{
			count += 8;
		}
		else
		{
			uint32 x = kRiceCodeBits2Value[v];
			*(uint32*)&dst[0] = count + ( x & 0x0f0f0f0f );
			*(uint32*)&dst[4] = ( x >> 4 ) & 0x0f0f0f0f;
			dst += kRiceCodeBits2Len[v];
			if ( dst >= dst_end )
				break;
			count = x >> 28;
		}
		if ( p >= p_end )
			return false;
		v = *p++;
	}
	// went too far, step back
	if ( dst > dst_end )
	{
		int n = dst - dst_end;
		do
			v &= ( v - 1 );
		while ( --n );
	}
	// step back if byte not finished
	int bitpos = 0;
	if ( !( v & 1 ) )
	{
		p--;
		unsigned long q;
		_BitScanForward( &q, v );
		bitpos = 8 - q;
	}
	br->p = p;
	br->bitpos = bitpos;
	return true;
}

bool DecodeGolombRiceBits( uint8* dst, uint size, uint bitcount, BitReader2* br )
{
	if ( bitcount == 0 )
		return true;
	uint8* dst_end = dst + size;
	const uint8* p = br->p;
	int bitpos = br->bitpos;

	uint bits_required = bitpos + bitcount * size;
	uint bytes_required = ( bits_required + 7 ) >> 3;
	if ( bytes_required > br->p_end - p )
		return false;

	br->p = p + ( bits_required >> 3 );
	br->bitpos = bits_required & 7;

	// todo. handle r/w outside of range
	uint64 bak = *(uint64*)dst_end;

	if ( bitcount < 2 )
	{
		assert( bitcount == 1 );
		do
		{
			// Read the next byte
			uint64 bits = (uint8)( _byteswap_ulong( *(uint32*)p ) >> ( 24 - bitpos ) );
			p += 1;
			// Expand each bit into each byte of the uint64.
			bits = ( bits | ( bits << 28 ) ) & 0xF0000000Full;
			bits = ( bits | ( bits << 14 ) ) & 0x3000300030003ull;
			bits = ( bits | ( bits << 7 ) ) & 0x0101010101010101ull;
			*(uint64*)dst = *(uint64*)dst * 2 + _byteswap_uint64( bits );
			dst += 8;
		} while ( dst < dst_end );
	}
	else if ( bitcount == 2 )
	{
		do
		{
			// Read the next 2 bytes
			uint64 bits = (uint16)( _byteswap_ulong( *(uint32*)p ) >> ( 16 - bitpos ) );
			p += 2;
			// Expand each bit into each byte of the uint64.
			bits = ( bits | ( bits << 24 ) ) & 0xFF000000FFull;
			bits = ( bits | ( bits << 12 ) ) & 0xF000F000F000Full;
			bits = ( bits | ( bits << 6 ) ) & 0x0303030303030303ull;
			*(uint64*)dst = *(uint64*)dst * 4 + _byteswap_uint64( bits );
			dst += 8;
		} while ( dst < dst_end );

	}
	else
	{
		assert( bitcount == 3 );
		do
		{
			// Read the next 3 bytes
			uint64 bits = ( _byteswap_ulong( *(uint32*)p ) >> ( 8 - bitpos ) ) & 0xffffff;
			p += 3;
			// Expand each bit into each byte of the uint64.
			bits = ( bits | ( bits << 20 ) ) & 0xFFF00000FFFull;
			bits = ( bits | ( bits << 10 ) ) & 0x3F003F003F003Full;
			bits = ( bits | ( bits << 5 ) ) & 0x0707070707070707ull;
			*(uint64*)dst = *(uint64*)dst * 8 + _byteswap_uint64( bits );
			dst += 8;
		} while ( dst < dst_end );
	}
	*(uint64*)dst_end = bak;
	return true;
}

struct HuffRange
{
	uint16 symbol;
	uint16 num;
};

int Huff_ConvertToRanges( HuffRange* range, int num_symbols, int P, const uint8* symlen, BitReader* bits )
{
	int num_ranges = P >> 1, v, sym_idx = 0;

	// Start with space?
	if ( P & 1 )
	{
		BitReader_Refill( bits );
		v = *symlen++;
		if ( v >= 8 )
			return -1;
		sym_idx = BitReader_ReadBitsNoRefill( bits, v + 1 ) + ( 1 << ( v + 1 ) ) - 1;
	}
	int syms_used = 0;

	for ( int i = 0; i < num_ranges; i++ )
	{
		BitReader_Refill( bits );
		v = symlen[0];
		if ( v >= 9 )
			return -1;
		int num = BitReader_ReadBitsNoRefillZero( bits, v ) + ( 1 << v );
		v = symlen[1];
		if ( v >= 8 )
			return -1;
		int space = BitReader_ReadBitsNoRefill( bits, v + 1 ) + ( 1 << ( v + 1 ) ) - 1;
		range[i].symbol = sym_idx;
		range[i].num = num;
		syms_used += num;
		sym_idx += num + space;
		symlen += 2;
	}

	if ( sym_idx >= 256 || syms_used >= num_symbols || sym_idx + num_symbols - syms_used > 256 )
		return -1;

	range[num_ranges].symbol = sym_idx;
	range[num_ranges].num = num_symbols - syms_used;

	return num_ranges + 1;
}

int Huff_ReadCodeLengthsNew( BitReader* bits, uint8* syms, uint32* code_prefix )
{
	int forced_bits = BitReader_ReadBitsNoRefill( bits, 2 );

	int num_symbols = BitReader_ReadBitsNoRefill( bits, 8 ) + 1;

	int fluff = BitReader_ReadFluff( bits, num_symbols );

	uint8 code_len[512];
	BitReader2 br2;
	br2.bitpos = ( bits->bitpos - 24 ) & 7;
	br2.p_end = bits->p_end;
	br2.p = bits->p - (unsigned)( ( 24 - bits->bitpos + 7 ) >> 3 );

	if ( !DecodeGolombRiceLengths( code_len, num_symbols + fluff, &br2 ) )
		return -1;
	memset( code_len + ( num_symbols + fluff ), 0, 16 );
	if ( !DecodeGolombRiceBits( code_len, num_symbols, forced_bits, &br2 ) )
		return -1;

	// Reset the bits decoder.
	bits->bitpos = 24;
	bits->p = br2.p;
	bits->bits = 0;
	BitReader_Refill( bits );
	bits->bits <<= br2.bitpos;
	bits->bitpos += br2.bitpos;

	if ( 1 )
	{
		uint running_sum = 0x1e;
		int maxlen = 11;
		for ( int i = 0; i < num_symbols; i++ )
		{
			int v = code_len[i];
			v = -(int)( v & 1 ) ^ ( v >> 1 );
			code_len[i] = v + ( running_sum >> 2 ) + 1;
			if ( code_len[i] < 1 || code_len[i] > 11 )
				return -1;
			running_sum += v;
		}

	}
	else
	{
		// Ensure we don't read unknown data that could contaminate
		// max_codeword_len.
		__m128i bak = _mm_loadu_si128( ( __m128i* ) & code_len[num_symbols] );
		_mm_storeu_si128( ( __m128i* ) & code_len[num_symbols], _mm_set1_epi32( 0 ) );
		// apply a filter
		__m128i avg = _mm_set1_epi8( 0x1e );
		__m128i ones = _mm_set1_epi8( 1 );
		__m128i max_codeword_len = _mm_set1_epi8( 10 );
		for ( uint i = 0; i < num_symbols; i += 16 )
		{
			__m128i v = _mm_loadu_si128( ( __m128i* ) & code_len[i] ), t;
			// avg[0..15] = avg[15]
			avg = _mm_unpackhi_epi8( avg, avg );
			avg = _mm_unpackhi_epi8( avg, avg );
			avg = _mm_shuffle_epi32( avg, 255 );
			// v = -(int)(v & 1) ^ (v >> 1)
			v = _mm_xor_si128( _mm_sub_epi8( _mm_set1_epi8( 0 ), _mm_and_si128( v, ones ) ),
				_mm_and_si128( _mm_srli_epi16( v, 1 ), _mm_set1_epi8( 0x7f ) ) );
			// create all the sums. v[n] = v[0] + ... + v[n]
			t = _mm_add_epi8( _mm_slli_si128( v, 1 ), v );
			t = _mm_add_epi8( _mm_slli_si128( t, 2 ), t );
			t = _mm_add_epi8( _mm_slli_si128( t, 4 ), t );
			t = _mm_add_epi8( _mm_slli_si128( t, 8 ), t );
			// u[x] = (avg + t[x-1]) >> 2
			__m128i u = _mm_and_si128( _mm_srli_epi16( _mm_add_epi8( _mm_slli_si128( t, 1 ), avg ), 2u ), _mm_set1_epi8( 0x3f ) );
			// v += u
			v = _mm_add_epi8( v, u );
			// avg += t
			avg = _mm_add_epi8( avg, t );
			// max_codeword_len = max(max_codeword_len, v)
			max_codeword_len = _mm_max_epu8( max_codeword_len, v );
			// mem[] = v+1
			_mm_storeu_si128( ( __m128i* ) & code_len[i], _mm_add_epi8( v, _mm_set1_epi8( 1 ) ) );
		}
		_mm_storeu_si128( ( __m128i* ) & code_len[num_symbols], bak );
		if ( _mm_movemask_epi8( _mm_cmpeq_epi8( max_codeword_len, _mm_set1_epi8( 10 ) ) ) != 0xffff )
			return -1; // codeword too big?
	}

	HuffRange range[128];
	int ranges = Huff_ConvertToRanges( range, num_symbols, fluff, &code_len[num_symbols], bits );
	if ( ranges <= 0 )
		return -1;

	uint8* cp = code_len;
	for ( int i = 0; i < ranges; i++ )
	{
		int sym = range[i].symbol;
		int n = range[i].num;
		do
		{
			syms[code_prefix[*cp++]++] = sym++;
		} while ( --n );
	}

	return num_symbols;
}

struct NewHuffLut
{
	// Mapping that maps a bit pattern to a code length.
	uint8 bits2len[2048 + 16];
	// Mapping that maps a bit pattern to a symbol.
	uint8 bits2sym[2048 + 16];
};

// May overflow 16 bytes past the end
void FillByteOverflow16( uint8* dst, uint8 v, size_t n ) { memset( dst, v, n ); }

bool Huff_MakeLut( const uint32* prefix_org, const uint32* prefix_cur, NewHuffLut* hufflut, uint8* syms )
{
	uint32 currslot = 0;
	for ( uint32 i = 1; i < 11; i++ )
	{
		uint32 start = prefix_org[i];
		uint32 count = prefix_cur[i] - start;
		if ( count )
		{
			uint32 stepsize = 1 << ( 11 - i );
			uint32 num_to_set = count << ( 11 - i );
			if ( currslot + num_to_set > 2048 )
				return false;
			FillByteOverflow16( &hufflut->bits2len[currslot], i, num_to_set );

			uint8* p = &hufflut->bits2sym[currslot];
			for ( uint32 j = 0; j != count; j++, p += stepsize )
				FillByteOverflow16( p, syms[start + j], stepsize );
			currslot += num_to_set;
		}
	}
	if ( prefix_cur[11] - prefix_org[11] != 0 )
	{
		uint32 num_to_set = prefix_cur[11] - prefix_org[11];
		if ( currslot + num_to_set > 2048 )
			return false;
		FillByteOverflow16( &hufflut->bits2len[currslot], 11, num_to_set );
		memcpy( &hufflut->bits2sym[currslot], &syms[prefix_org[11]], num_to_set );
		currslot += num_to_set;
	}
	return currslot == 2048;
}

int Kraken_DecodeBytes_Type12( const byte* src, size_t src_size, byte* output, int output_size, int type )
{
	BitReader bits;
	int half_output_size;
	uint32 split_left, split_mid, split_right;
	const byte* src_mid;
	NewHuffLut huff_lut;
	HuffReader hr;
	HuffRevLut rev_lut;
	const uint8* src_end = src + src_size;

	bits.bitpos = 24;
	bits.bits = 0;
	bits.p = src;
	bits.p_end = src_end;
	BitReader_Refill( &bits );

	static const uint32 code_prefix_org[12] = { 0x0, 0x0, 0x2, 0x6, 0xE, 0x1E, 0x3E, 0x7E, 0xFE, 0x1FE, 0x2FE, 0x3FE };
	uint32 code_prefix[12] = { 0x0, 0x0, 0x2, 0x6, 0xE, 0x1E, 0x3E, 0x7E, 0xFE, 0x1FE, 0x2FE, 0x3FE };
	uint8 syms[1280];
	int num_syms;
	if ( !BitReader_ReadBitNoRefill( &bits ) )
	{
		num_syms = Huff_ReadCodeLengthsOld( &bits, syms, code_prefix );
	}
	else if ( !BitReader_ReadBitNoRefill( &bits ) )
	{
		num_syms = Huff_ReadCodeLengthsNew( &bits, syms, code_prefix );
	}
	else
	{
		return -1;
	}

	if ( num_syms < 1 )
		return -1;
	src = bits.p - ( ( 24 - bits.bitpos ) / 8 );

	if ( num_syms == 1 )
	{
		memset( output, syms[0], output_size );
		return src - src_end;
	}

	if ( !Huff_MakeLut( code_prefix_org, code_prefix, &huff_lut, syms ) )
		return -1;

	ReverseBitsArray2048( huff_lut.bits2len, rev_lut.bits2len );
	ReverseBitsArray2048( huff_lut.bits2sym, rev_lut.bits2sym );

	if ( type == 1 )
	{
		if ( src + 3 > src_end )
			return -1;
		split_mid = *(uint16*)src;
		src += 2;
		hr.output = output;
		hr.output_end = output + output_size;
		hr.src = src;
		hr.src_end = src_end;
		hr.src_mid_org = hr.src_mid = src + split_mid;
		hr.src_bitpos = 0;
		hr.src_bits = 0;
		hr.src_mid_bitpos = 0;
		hr.src_mid_bits = 0;
		hr.src_end_bitpos = 0;
		hr.src_end_bits = 0;
		if ( !Kraken_DecodeBytesCore( &hr, &rev_lut ) )
			return -1;
	}
	else
	{
		if ( src + 6 > src_end )
			return -1;

		half_output_size = ( output_size + 1 ) >> 1;
		split_mid = *(uint32*)src & 0xFFFFFF;
		src += 3;
		if ( split_mid > ( src_end - src ) )
			return -1;
		src_mid = src + split_mid;
		split_left = *(uint16*)src;
		src += 2;
		if ( src_mid - src < split_left + 2 || src_end - src_mid < 3 )
			return -1;
		split_right = *(uint16*)src_mid;
		if ( src_end - ( src_mid + 2 ) < split_right + 2 )
			return -1;

		hr.output = output;
		hr.output_end = output + half_output_size;
		hr.src = src;
		hr.src_end = src_mid;
		hr.src_mid_org = hr.src_mid = src + split_left;
		hr.src_bitpos = 0;
		hr.src_bits = 0;
		hr.src_mid_bitpos = 0;
		hr.src_mid_bits = 0;
		hr.src_end_bitpos = 0;
		hr.src_end_bits = 0;
		if ( !Kraken_DecodeBytesCore( &hr, &rev_lut ) )
			return -1;

		hr.output = output + half_output_size;
		hr.output_end = output + output_size;
		hr.src = src_mid + 2;
		hr.src_end = src_end;
		hr.src_mid_org = hr.src_mid = src_mid + 2 + split_right;
		hr.src_bitpos = 0;
		hr.src_bits = 0;
		hr.src_mid_bitpos = 0;
		hr.src_mid_bits = 0;
		hr.src_end_bitpos = 0;
		hr.src_end_bits = 0;
		if ( !Kraken_DecodeBytesCore( &hr, &rev_lut ) )
			return -1;
	}
	return (int)src_size;
}

static uint32 bitmasks[32] = { 0x1,		  0x3,		  0x7,		  0xf,		 0x1f,		0x3f,	   0x7f,
							  0xff,		  0x1ff,	  0x3ff,	  0x7ff,	 0xfff,		0x1fff,	   0x3fff,
							  0x7fff,	  0xffff,	  0x1ffff,	  0x3ffff,	 0x7ffff,	0xfffff,   0x1fffff,
							  0x3fffff,	  0x7fffff,	  0xffffff,	  0x1ffffff, 0x3ffffff, 0x7ffffff, 0xfffffff,
							  0x1fffffff, 0x3fffffff, 0x7fffffff, 0xffffffff };

int Kraken_DecodeMultiArray( const uint8* src, const uint8* src_end, uint8* dst, uint8* dst_end, uint8** array_data,
	int* array_lens, int array_count, int* total_size_out, bool force_memmove, uint8* scratch,
	uint8* scratch_end )
{
	const uint8* src_org = src;

	if ( src_end - src < 4 )
		return -1;

	int decoded_size;
	int num_arrays_in_file = *src++;
	if ( !( num_arrays_in_file & 0x80 ) )
		return -1;
	num_arrays_in_file &= 0x3f;

	if ( dst == scratch )
	{
		// todo: ensure scratch space first?
		scratch += ( scratch_end - scratch - 0xc000 ) >> 1;
		dst_end = scratch;
	}

	int total_size = 0;

	if ( num_arrays_in_file == 0 )
	{
		for ( int i = 0; i < array_count; i++ )
		{
			uint8* chunk_dst = dst;
			int dec = Kraken_DecodeBytes( &chunk_dst, src, src_end, &decoded_size, dst_end - dst, force_memmove, scratch,
				scratch_end );
			if ( dec < 0 )
				return -1;
			dst += decoded_size;
			array_lens[i] = decoded_size;
			array_data[i] = chunk_dst;
			src += dec;
			total_size += decoded_size;
		}
		*total_size_out = total_size;
		return src - src_org; // not supported yet
	}

	uint8* entropy_array_data[32];
	uint32 entropy_array_size[32];

	// First loop just decodes everything to scratch
	uint8* scratch_cur = scratch;

	for ( int i = 0; i < num_arrays_in_file; i++ )
	{
		uint8* chunk_dst = scratch_cur;
		int dec = Kraken_DecodeBytes( &chunk_dst, src, src_end, &decoded_size, scratch_end - scratch_cur, force_memmove,
			scratch_cur, scratch_end );
		if ( dec < 0 )
			return -1;
		entropy_array_data[i] = chunk_dst;
		entropy_array_size[i] = decoded_size;
		scratch_cur += decoded_size;
		total_size += decoded_size;
		src += dec;
	}
	*total_size_out = total_size;

	if ( src_end - src < 3 )
		return -1;

	int Q = *(uint16*)src;
	src += 2;

	int out_size;
	if ( Kraken_GetBlockSize( src, src_end, &out_size, total_size ) < 0 )
		return -1;
	int num_indexes = out_size;

	int num_lens = num_indexes - array_count;
	if ( num_lens < 1 )
		return -1;

	if ( scratch_end - scratch_cur < num_indexes )
		return -1;
	uint8* interval_lenlog2 = scratch_cur;
	scratch_cur += num_indexes;

	if ( scratch_end - scratch_cur < num_indexes )
		return -1;
	uint8* interval_indexes = scratch_cur;
	scratch_cur += num_indexes;

	if ( Q & 0x8000 )
	{
		int size_out;
		int n = Kraken_DecodeBytes( &interval_indexes, src, src_end, &size_out, num_indexes, false, scratch_cur,
			scratch_end );
		if ( n < 0 || size_out != num_indexes )
			return -1;
		src += n;

		for ( int i = 0; i < num_indexes; i++ )
		{
			int t = interval_indexes[i];
			interval_lenlog2[i] = t >> 4;
			interval_indexes[i] = t & 0xF;
		}

		num_lens = num_indexes;
	}
	else
	{
		int lenlog2_chunksize = num_indexes - array_count;

		int size_out;
		int n = Kraken_DecodeBytes( &interval_indexes, src, src_end, &size_out, num_indexes, false, scratch_cur,
			scratch_end );
		if ( n < 0 || size_out != num_indexes )
			return -1;
		src += n;

		n = Kraken_DecodeBytes( &interval_lenlog2, src, src_end, &size_out, lenlog2_chunksize, false, scratch_cur,
			scratch_end );
		if ( n < 0 || size_out != lenlog2_chunksize )
			return -1;
		src += n;

		for ( int i = 0; i < lenlog2_chunksize; i++ )
			if ( interval_lenlog2[i] > 16 )
				return -1;
	}

	if ( scratch_end - scratch_cur < 4 )
		return -1;

	scratch_cur = ALIGN_POINTER( scratch_cur, 4 );
	if ( scratch_end - scratch_cur < num_lens * 4 )
		return -1;
	uint32* decoded_intervals = (uint32*)scratch_cur;

	int varbits_complen = Q & 0x3FFF;
	if ( src_end - src < varbits_complen )
		return -1;

	const uint8* f = src;
	uint32 bits_f = 0;
	int bitpos_f = 24;

	const uint8* src_end_actual = src + varbits_complen;

	const uint8* b = src_end_actual;
	uint32 bits_b = 0;
	int bitpos_b = 24;

	int i;
	for ( i = 0; i + 2 <= num_lens; i += 2 )
	{
		bits_f |= _byteswap_ulong( *(uint32*)f ) >> ( 24 - bitpos_f );
		f += ( bitpos_f + 7 ) >> 3;

		bits_b |= ( (uint32*)b )[-1] >> ( 24 - bitpos_b );
		b -= ( bitpos_b + 7 ) >> 3;

		int numbits_f = interval_lenlog2[i + 0];
		int numbits_b = interval_lenlog2[i + 1];

		bits_f = _rotl( bits_f | 1, numbits_f );
		bitpos_f += numbits_f - 8 * ( ( bitpos_f + 7 ) >> 3 );

		bits_b = _rotl( bits_b | 1, numbits_b );
		bitpos_b += numbits_b - 8 * ( ( bitpos_b + 7 ) >> 3 );

		int value_f = bits_f & bitmasks[numbits_f];
		bits_f &= ~bitmasks[numbits_f];

		int value_b = bits_b & bitmasks[numbits_b];
		bits_b &= ~bitmasks[numbits_b];

		decoded_intervals[i + 0] = value_f;
		decoded_intervals[i + 1] = value_b;
	}

	// read final one since above loop reads 2
	if ( i < num_lens )
	{
		bits_f |= _byteswap_ulong( *(uint32*)f ) >> ( 24 - bitpos_f );
		int numbits_f = interval_lenlog2[i];
		bits_f = _rotl( bits_f | 1, numbits_f );
		int value_f = bits_f & bitmasks[numbits_f];
		decoded_intervals[i + 0] = value_f;
	}

	if ( interval_indexes[num_indexes - 1] )
		return -1;

	int indi = 0, leni = 0, source;
	int increment_leni = ( Q & 0x8000 ) != 0;

	for ( int arri = 0; arri < array_count; arri++ )
	{
		array_data[arri] = dst;
		if ( indi >= num_indexes )
			return -1;

		while ( ( source = interval_indexes[indi++] ) != 0 )
		{
			if ( source > num_arrays_in_file )
				return -1;
			if ( leni >= num_lens )
				return -1;
			int cur_len = decoded_intervals[leni++];
			int bytes_left = entropy_array_size[source - 1];
			if ( cur_len > bytes_left || cur_len > dst_end - dst )
				return -1;
			uint8* blksrc = entropy_array_data[source - 1];
			entropy_array_size[source - 1] -= cur_len;
			entropy_array_data[source - 1] += cur_len;
			uint8* dstx = dst;
			dst += cur_len;
			memcpy( dstx, blksrc, cur_len );
		}
		leni += increment_leni;
		array_lens[arri] = dst - array_data[arri];
	}

	if ( indi != num_indexes || leni != num_lens )
		return -1;

	for ( int i = 0; i < num_arrays_in_file; i++ )
	{
		if ( entropy_array_size[i] )
			return -1;
	}
	return src_end_actual - src_org;
}

int Krak_DecodeRecursive( const byte* src, size_t src_size, byte* output, int output_size, uint8* scratch,
	uint8* scratch_end )
{
	const uint8* src_org = src;
	byte* output_end = output + output_size;
	const byte* src_end = src + src_size;

	if ( src_size < 6 )
		return -1;

	int n = src[0] & 0x7f;
	if ( n < 2 )
		return -1;

	if ( !( src[0] & 0x80 ) )
	{
		src++;
		do
		{
			int decoded_size;
			int dec = Kraken_DecodeBytes( &output, src, src_end, &decoded_size, output_end - output, true, scratch,
				scratch_end );
			if ( dec < 0 )
				return -1;
			output += decoded_size;
			src += dec;
		} while ( --n );
		if ( output != output_end )
			return -1;
		return src - src_org;
	}
	else
	{
		uint8* array_data;
		int array_len, decoded_size;
		int dec = Kraken_DecodeMultiArray( src, src_end, output, output_end, &array_data, &array_len, 1, &decoded_size,
			true, scratch, scratch_end );
		if ( dec < 0 )
			return -1;
		output += decoded_size;
		if ( output != output_end )
			return -1;
		return dec;
	}
}

int Krak_DecodeRLE( const byte* src, size_t src_size, byte* dst, int dst_size, uint8* scratch, uint8* scratch_end )
{
	if ( src_size <= 1 )
	{
		if ( src_size != 1 )
			return -1;
		memset( dst, src[0], dst_size );
		return 1;
	}
	uint8* dst_end = dst + dst_size;
	const uint8* cmd_ptr = src + 1, * cmd_ptr_end = src + src_size;
	// Unpack the first X bytes of the command buffer?
	if ( src[0] )
	{
		uint8* dst_ptr = scratch;
		int dec_size;
		int n = Kraken_DecodeBytes( &dst_ptr, src, src + src_size, &dec_size, scratch_end - scratch, true, scratch,
			scratch_end );
		if ( n <= 0 )
			return -1;
		int cmd_len = src_size - n + dec_size;
		if ( cmd_len > scratch_end - scratch )
			return -1;
		memcpy( dst_ptr + dec_size, src + n, src_size - n );
		cmd_ptr = dst_ptr;
		cmd_ptr_end = &dst_ptr[cmd_len];
	}

	int rle_byte = 0;

	while ( cmd_ptr < cmd_ptr_end )
	{
		uint32 cmd = cmd_ptr_end[-1];
		if ( cmd - 1 >= 0x2f )
		{
			cmd_ptr_end--;
			uint32 bytes_to_copy = ( -1 - cmd ) & 0xF;
			uint32 bytes_to_rle = cmd >> 4;
			if ( dst_end - dst < bytes_to_copy + bytes_to_rle || cmd_ptr_end - cmd_ptr < bytes_to_copy )
				return -1;
			memcpy( dst, cmd_ptr, bytes_to_copy );
			cmd_ptr += bytes_to_copy;
			dst += bytes_to_copy;
			memset( dst, rle_byte, bytes_to_rle );
			dst += bytes_to_rle;
		}
		else if ( cmd >= 0x10 )
		{
			uint32 data = *(uint16*)( cmd_ptr_end - 2 ) - 4096;
			cmd_ptr_end -= 2;
			uint32 bytes_to_copy = data & 0x3F;
			uint32 bytes_to_rle = data >> 6;
			if ( dst_end - dst < bytes_to_copy + bytes_to_rle || cmd_ptr_end - cmd_ptr < bytes_to_copy )
				return -1;
			memcpy( dst, cmd_ptr, bytes_to_copy );
			cmd_ptr += bytes_to_copy;
			dst += bytes_to_copy;
			memset( dst, rle_byte, bytes_to_rle );
			dst += bytes_to_rle;
		}
		else if ( cmd == 1 )
		{
			rle_byte = *cmd_ptr++;
			cmd_ptr_end--;
		}
		else if ( cmd >= 9 )
		{
			uint32 bytes_to_rle = ( *(uint16*)( cmd_ptr_end - 2 ) - 0x8ff ) * 128;
			cmd_ptr_end -= 2;
			if ( dst_end - dst < bytes_to_rle )
				return -1;
			memset( dst, rle_byte, bytes_to_rle );
			dst += bytes_to_rle;
		}
		else
		{
			uint32 bytes_to_copy = ( *(uint16*)( cmd_ptr_end - 2 ) - 511 ) * 64;
			cmd_ptr_end -= 2;
			if ( cmd_ptr_end - cmd_ptr < bytes_to_copy || dst_end - dst < bytes_to_copy )
				return -1;
			memcpy( dst, cmd_ptr, bytes_to_copy );
			dst += bytes_to_copy;
			cmd_ptr += bytes_to_copy;
		}
	}
	if ( cmd_ptr_end != cmd_ptr )
		return -1;

	if ( dst != dst_end )
		return -1;

	return src_size;
}

struct TansData
{
	uint32 A_used;
	uint32 B_used;
	uint8 A[256];
	uint32 B[256];
};

template <typename T> void SimpleSort( T* p, T* pend )
{
	if ( p != pend )
	{
		for ( T* lp = p + 1, *rp; lp != pend; lp++ )
		{
			T t = lp[0];
			for ( rp = lp; rp > p && t < rp[-1]; rp-- )
				rp[0] = rp[-1];
			rp[0] = t;
		}
	}
}

bool Tans_DecodeTable( BitReader* bits, int L_bits, TansData* tans_data )
{
	BitReader_Refill( bits );
	if ( BitReader_ReadBitNoRefill( bits ) )
	{
		int Q = BitReader_ReadBitsNoRefill( bits, 3 );
		int num_symbols = BitReader_ReadBitsNoRefill( bits, 8 ) + 1;
		if ( num_symbols < 2 )
			return false;
		int fluff = BitReader_ReadFluff( bits, num_symbols );
		int total_rice_values = fluff + num_symbols;
		uint8 rice[512 + 16];
		BitReader2 br2;

		// another bit reader...
		br2.p = bits->p - ( (uint)( 24 - bits->bitpos + 7 ) >> 3 );
		br2.p_end = bits->p_end;
		br2.bitpos = ( bits->bitpos - 24 ) & 7;

		if ( !DecodeGolombRiceLengths( rice, total_rice_values, &br2 ) )
			return false;
		memset( rice + total_rice_values, 0, 16 );

		// Switch back to other bitreader impl
		bits->bitpos = 24;
		bits->p = br2.p;
		bits->bits = 0;
		BitReader_Refill( bits );
		bits->bits <<= br2.bitpos;
		bits->bitpos += br2.bitpos;

		HuffRange range[133];
		fluff = Huff_ConvertToRanges( range, num_symbols, fluff, &rice[num_symbols], bits );
		if ( fluff < 0 )
			return false;

		BitReader_Refill( bits );

		uint32 L = 1 << L_bits;
		uint8* cur_rice_ptr = rice;
		int average = 6;
		int somesum = 0;
		uint8* tanstable_A = tans_data->A;
		uint32* tanstable_B = tans_data->B;

		for ( int ri = 0; ri < fluff; ri++ )
		{
			int symbol = range[ri].symbol;
			int num = range[ri].num;
			do
			{
				BitReader_Refill( bits );

				int nextra = Q + *cur_rice_ptr++;
				if ( nextra > 15 )
					return false;
				int v = BitReader_ReadBitsNoRefillZero( bits, nextra ) + ( 1 << nextra ) - ( 1 << Q );

				int average_div4 = average >> 2;
				int limit = 2 * average_div4;
				if ( v <= limit )
					v = average_div4 + ( -( v & 1 ) ^ ( (uint32)v >> 1 ) );
				if ( limit > v )
					limit = v;
				v += 1;
				average += limit - average_div4;
				*tanstable_A = symbol;
				*tanstable_B = ( symbol << 16 ) + v;
				tanstable_A += ( v == 1 );
				tanstable_B += v >= 2;
				somesum += v;
				symbol += 1;
			} while ( --num );
		}
		tans_data->A_used = tanstable_A - tans_data->A;
		tans_data->B_used = tanstable_B - tans_data->B;
		if ( somesum != L )
			return false;

		return true;
	}
	else
	{
		bool seen[256];
		memset( seen, 0, sizeof( seen ) );
		uint32 L = 1 << L_bits;

		int count = BitReader_ReadBitsNoRefill( bits, 3 ) + 1;

		int bits_per_sym = BSR( L_bits ) + 1;
		int max_delta_bits = BitReader_ReadBitsNoRefill( bits, bits_per_sym );

		if ( max_delta_bits == 0 || max_delta_bits > L_bits )
			return false;

		uint8* tanstable_A = tans_data->A;
		uint32* tanstable_B = tans_data->B;

		int weight = 0;
		int total_weights = 0;

		do
		{
			BitReader_Refill( bits );

			int sym = BitReader_ReadBitsNoRefill( bits, 8 );
			if ( seen[sym] )
				return false;

			int delta = BitReader_ReadBitsNoRefill( bits, max_delta_bits );

			weight += delta;

			if ( weight == 0 )
				return false;

			seen[sym] = true;
			if ( weight == 1 )
			{
				*tanstable_A++ = sym;
			}
			else
			{
				*tanstable_B++ = ( sym << 16 ) + weight;
			}

			total_weights += weight;
		} while ( --count );

		BitReader_Refill( bits );

		int sym = BitReader_ReadBitsNoRefill( bits, 8 );
		if ( seen[sym] )
			return false;

		if ( L - total_weights < weight || L - total_weights <= 1 )
			return false;

		*tanstable_B++ = ( sym << 16 ) + ( L - total_weights );

		tans_data->A_used = tanstable_A - tans_data->A;
		tans_data->B_used = tanstable_B - tans_data->B;

		SimpleSort( tans_data->A, tanstable_A );
		SimpleSort( tans_data->B, tanstable_B );
		return true;
	}
}

struct TansLutEnt
{
	uint32 x;
	uint8 bits_x;
	uint8 symbol;
	uint16 w;
};

void Tans_InitLut( TansData* tans_data, int L_bits, TansLutEnt* lut )
{
	TansLutEnt* pointers[4];

	int L = 1 << L_bits;
	int a_used = tans_data->A_used;

	uint slots_left_to_alloc = L - a_used;

	uint sa = slots_left_to_alloc >> 2;
	pointers[0] = lut;
	uint sb = sa + ( ( slots_left_to_alloc & 3 ) > 0 );
	pointers[1] = lut + sb;
	sb += sa + ( ( slots_left_to_alloc & 3 ) > 1 );
	pointers[2] = lut + sb;
	sb += sa + ( ( slots_left_to_alloc & 3 ) > 2 );
	pointers[3] = lut + sb;

	// Setup the single entrys with weight=1
	{
		TansLutEnt* lut_singles = lut + slots_left_to_alloc, le;
		le.w = 0;
		le.bits_x = L_bits;
		le.x = ( 1 << L_bits ) - 1;
		for ( int i = 0; i < a_used; i++ )
		{
			lut_singles[i] = le;
			lut_singles[i].symbol = tans_data->A[i];
		}
	}

	// Setup the entrys with weight >= 2
	int weights_sum = 0;
	for ( int i = 0; i < tans_data->B_used; i++ )
	{
		int weight = tans_data->B[i] & 0xffff;
		int symbol = tans_data->B[i] >> 16;
		if ( weight > 4 )
		{
			uint32 sym_bits = BSR( weight );
			int Z = L_bits - sym_bits;
			TansLutEnt le;
			le.symbol = symbol;
			le.bits_x = Z;
			le.x = ( 1 << Z ) - 1;
			le.w = ( L - 1 ) & ( weight << Z );
			int what_to_add = 1 << Z;
			int X = ( 1 << ( sym_bits + 1 ) ) - weight;

			for ( int j = 0; j < 4; j++ )
			{
				TansLutEnt* dst = pointers[j];

				int Y = ( weight + ( ( weights_sum - j - 1 ) & 3 ) ) >> 2;
				if ( X >= Y )
				{
					for ( int n = Y; n; n-- )
					{
						*dst++ = le;
						le.w += what_to_add;
					}
					X -= Y;
				}
				else
				{
					for ( int n = X; n; n-- )
					{
						*dst++ = le;
						le.w += what_to_add;
					}
					Z--;

					what_to_add >>= 1;
					le.bits_x = Z;
					le.w = 0;
					le.x >>= 1;
					for ( int n = Y - X; n; n-- )
					{
						*dst++ = le;
						le.w += what_to_add;
					}
					X = weight;
				}
				pointers[j] = dst;
			}
		}
		else
		{
			assert( weight > 0 );
			uint32 bits = ( ( 1 << weight ) - 1 ) << ( weights_sum & 3 );
			bits |= ( bits >> 4 );
			int n = weight, ww = weight;
			do
			{
				uint32 idx = BSF( bits );
				bits &= bits - 1;
				TansLutEnt* dst = pointers[idx]++;
				dst->symbol = symbol;
				uint32 weight_bits = BSR( ww );
				dst->bits_x = L_bits - weight_bits;
				dst->x = ( 1 << ( L_bits - weight_bits ) ) - 1;
				dst->w = ( L - 1 ) & ( ww++ << ( L_bits - weight_bits ) );
			} while ( --n );
		}
		weights_sum += weight;
	}
}

struct TansDecoderParams
{
	TansLutEnt* lut;
	uint8* dst, * dst_end;
	const uint8* ptr_f, * ptr_b;
	uint32 bits_f, bits_b;
	int bitpos_f, bitpos_b;
	uint32 state_0, state_1, state_2, state_3, state_4;
};

bool Tans_Decode( TansDecoderParams* params )
{
	TansLutEnt* lut = params->lut, * e;
	uint8* dst = params->dst, * dst_end = params->dst_end;
	const uint8* ptr_f = params->ptr_f, * ptr_b = params->ptr_b;
	uint32 bits_f = params->bits_f, bits_b = params->bits_b;
	int bitpos_f = params->bitpos_f, bitpos_b = params->bitpos_b;
	uint32 state_0 = params->state_0, state_1 = params->state_1;
	uint32 state_2 = params->state_2, state_3 = params->state_3;
	uint32 state_4 = params->state_4;

	if ( ptr_f > ptr_b )
		return false;

#define TANS_FORWARD_BITS()                                                                                            \
	bits_f |= *(uint32 *)ptr_f << bitpos_f;                                                                            \
	ptr_f += (31 - bitpos_f) >> 3;                                                                                     \
	bitpos_f |= 24;

#define TANS_FORWARD_ROUND(state)                                                                                      \
	e = &lut[state];                                                                                                   \
	*dst++ = e->symbol;                                                                                                \
	bitpos_f -= e->bits_x;                                                                                             \
	state = (bits_f & e->x) + e->w;                                                                                    \
	bits_f >>= e->bits_x;                                                                                              \
	if (dst >= dst_end)                                                                                                \
		break;

#define TANS_BACKWARD_BITS()                                                                                           \
	bits_b |= _byteswap_ulong(((uint32 *)ptr_b)[-1]) << bitpos_b;                                                      \
	ptr_b -= (31 - bitpos_b) >> 3;                                                                                     \
	bitpos_b |= 24;

#define TANS_BACKWARD_ROUND(state)                                                                                     \
	e = &lut[state];                                                                                                   \
	*dst++ = e->symbol;                                                                                                \
	bitpos_b -= e->bits_x;                                                                                             \
	state = (bits_b & e->x) + e->w;                                                                                    \
	bits_b >>= e->bits_x;                                                                                              \
	if (dst >= dst_end)                                                                                                \
		break;

	if ( dst < dst_end )
	{
		for ( ;;)
		{
			TANS_FORWARD_BITS( );
			TANS_FORWARD_ROUND( state_0 );
			TANS_FORWARD_ROUND( state_1 );
			TANS_FORWARD_BITS( );
			TANS_FORWARD_ROUND( state_2 );
			TANS_FORWARD_ROUND( state_3 );
			TANS_FORWARD_BITS( );
			TANS_FORWARD_ROUND( state_4 );
			TANS_BACKWARD_BITS( );
			TANS_BACKWARD_ROUND( state_0 );
			TANS_BACKWARD_ROUND( state_1 );
			TANS_BACKWARD_BITS( );
			TANS_BACKWARD_ROUND( state_2 );
			TANS_BACKWARD_ROUND( state_3 );
			TANS_BACKWARD_BITS( );
			TANS_BACKWARD_ROUND( state_4 );
		}
	}

	if ( ptr_b - ptr_f + ( bitpos_f >> 3 ) + ( bitpos_b >> 3 ) != 0 )
		return false;

	uint32 states_or = state_0 | state_1 | state_2 | state_3 | state_4;
	if ( states_or & ~0xFF )
		return false;

	dst_end[0] = (uint8)state_0;
	dst_end[1] = (uint8)state_1;
	dst_end[2] = (uint8)state_2;
	dst_end[3] = (uint8)state_3;
	dst_end[4] = (uint8)state_4;
	return true;
}

int Krak_DecodeTans( const byte* src, size_t src_size, byte* dst, int dst_size, uint8* scratch, uint8* scratch_end )
{
	if ( src_size < 8 || dst_size < 5 )
		return -1;

	const uint8* src_end = src + src_size;

	BitReader br;
	TansData tans_data;

	br.bitpos = 24;
	br.bits = 0;
	br.p = src;
	br.p_end = src_end;
	BitReader_Refill( &br );

	// reserved bit
	if ( BitReader_ReadBitNoRefill( &br ) )
		return -1;

	int L_bits = BitReader_ReadBitsNoRefill( &br, 2 ) + 8;

	if ( !Tans_DecodeTable( &br, L_bits, &tans_data ) )
		return -1;

	src = br.p - ( 24 - br.bitpos ) / 8;

	if ( src >= src_end )
		return -1;

	uint32 lut_space_required = ( ( sizeof( TansLutEnt ) << L_bits ) + 15 ) & ~15;
	if ( lut_space_required > ( scratch_end - scratch ) )
		return -1;

	TansDecoderParams params;
	params.dst = dst;
	params.dst_end = dst + dst_size - 5;

	params.lut = (TansLutEnt*)ALIGN_POINTER( scratch, 16 );
	Tans_InitLut( &tans_data, L_bits, params.lut );

	// Read out the initial state
	uint32 L_mask = ( 1 << L_bits ) - 1;
	uint32 bits_f = *(uint32*)src;
	src += 4;
	uint32 bits_b = _byteswap_ulong( *(uint32*)( src_end - 4 ) );
	src_end -= 4;
	uint32 bitpos_f = 32, bitpos_b = 32;

	// Read first two.
	params.state_0 = bits_f & L_mask;
	params.state_1 = bits_b & L_mask;
	bits_f >>= L_bits, bitpos_f -= L_bits;
	bits_b >>= L_bits, bitpos_b -= L_bits;

	// Read next two.
	params.state_2 = bits_f & L_mask;
	params.state_3 = bits_b & L_mask;
	bits_f >>= L_bits, bitpos_f -= L_bits;
	bits_b >>= L_bits, bitpos_b -= L_bits;

	// Refill more bits
	bits_f |= *(uint32*)src << bitpos_f;
	src += ( 31 - bitpos_f ) >> 3;
	bitpos_f |= 24;

	// Read final state variable
	params.state_4 = bits_f & L_mask;
	bits_f >>= L_bits, bitpos_f -= L_bits;

	params.bits_f = bits_f;
	params.ptr_f = src - ( bitpos_f >> 3 );
	params.bitpos_f = bitpos_f & 7;

	params.bits_b = bits_b;
	params.ptr_b = src_end + ( bitpos_b >> 3 );
	params.bitpos_b = bitpos_b & 7;

	if ( !Tans_Decode( &params ) )
		return -1;

	return src_size;
}

int Kraken_GetBlockSize( const uint8* src, const uint8* src_end, int* dest_size, int dest_capacity )
{
	const byte* src_org = src;
	int src_size, dst_size;

	if ( src_end - src < 2 )
		return -1; // too few bytes

	int chunk_type = ( src[0] >> 4 ) & 0x7;
	if ( chunk_type == 0 )
	{
		if ( src[0] >= 0x80 )
		{
			// In this mode, memcopy stores the length in the bottom 12 bits.
			src_size = ( ( src[0] << 8 ) | src[1] ) & 0xFFF;
			src += 2;
		}
		else
		{
			if ( src_end - src < 3 )
				return -1; // too few bytes
			src_size = ( ( src[0] << 16 ) | ( src[1] << 8 ) | src[2] );
			if ( src_size & ~0x3ffff )
				return -1; // reserved bits must not be set
			src += 3;
		}
		if ( src_size > dest_capacity || src_end - src < src_size )
			return -1;
		*dest_size = src_size;
		return src + src_size - src_org;
	}

	if ( chunk_type >= 6 )
		return -1;

	// In all the other modes, the initial bytes encode
	// the src_size and the dst_size
	if ( src[0] >= 0x80 )
	{
		if ( src_end - src < 3 )
			return -1; // too few bytes

		// short mode, 10 bit sizes
		uint32 bits = ( ( src[0] << 16 ) | ( src[1] << 8 ) | src[2] );
		src_size = bits & 0x3ff;
		dst_size = src_size + ( ( bits >> 10 ) & 0x3ff ) + 1;
		src += 3;
	}
	else
	{
		// long mode, 18 bit sizes
		if ( src_end - src < 5 )
			return -1; // too few bytes
		uint32 bits = ( ( src[1] << 24 ) | ( src[2] << 16 ) | ( src[3] << 8 ) | src[4] );
		src_size = bits & 0x3ffff;
		dst_size = ( ( ( bits >> 18 ) | ( src[0] << 14 ) ) & 0x3FFFF ) + 1;
		if ( src_size >= dst_size )
			return -1;
		src += 5;
	}
	if ( src_end - src < src_size || dst_size > dest_capacity )
		return -1;
	*dest_size = dst_size;
	return src_size;
}

int Kraken_DecodeBytes( byte** output, const byte* src, const byte* src_end, int* decoded_size, size_t output_size,
	bool force_memmove, uint8* scratch, uint8* scratch_end )
{
	const byte* src_org = src;
	int src_size, dst_size;

	if ( src_end - src < 2 )
		return -1; // too few bytes

	int chunk_type = ( src[0] >> 4 ) & 0x7;
	if ( chunk_type == 0 )
	{
		if ( src[0] >= 0x80 )
		{
			// In this mode, memcopy stores the length in the bottom 12 bits.
			src_size = ( ( src[0] << 8 ) | src[1] ) & 0xFFF;
			src += 2;
		}
		else
		{
			if ( src_end - src < 3 )
				return -1; // too few bytes
			src_size = ( ( src[0] << 16 ) | ( src[1] << 8 ) | src[2] );
			if ( src_size & ~0x3ffff )
				return -1; // reserved bits must not be set
			src += 3;
		}
		if ( src_size > output_size || src_end - src < src_size )
			return -1;
		*decoded_size = src_size;
		if ( force_memmove )
			memmove( *output, src, src_size );
		else
			*output = (byte*)src;
		return src + src_size - src_org;
	}

	// In all the other modes, the initial bytes encode
	// the src_size and the dst_size
	if ( src[0] >= 0x80 )
	{
		if ( src_end - src < 3 )
			return -1; // too few bytes

		// short mode, 10 bit sizes
		uint32 bits = ( ( src[0] << 16 ) | ( src[1] << 8 ) | src[2] );
		src_size = bits & 0x3ff;
		dst_size = src_size + ( ( bits >> 10 ) & 0x3ff ) + 1;
		src += 3;
	}
	else
	{
		// long mode, 18 bit sizes
		if ( src_end - src < 5 )
			return -1; // too few bytes
		uint32 bits = ( ( src[1] << 24 ) | ( src[2] << 16 ) | ( src[3] << 8 ) | src[4] );
		src_size = bits & 0x3ffff;
		dst_size = ( ( ( bits >> 18 ) | ( src[0] << 14 ) ) & 0x3FFFF ) + 1;
		if ( src_size >= dst_size )
			return -1;
		src += 5;
	}
	if ( src_end - src < src_size || dst_size > output_size )
		return -1;

	uint8* dst = *output;
	if ( dst == scratch )
	{
		if ( scratch_end - scratch < dst_size )
			return -1;
		scratch += dst_size;
	}

	//  printf("%d -> %d (%d)\n", src_size, dst_size, chunk_type);

	int src_used = -1;
	switch ( chunk_type )
	{
	case 2:
	case 4:
		src_used = Kraken_DecodeBytes_Type12( src, src_size, dst, dst_size, chunk_type >> 1 );
		break;
	case 5:
		src_used = Krak_DecodeRecursive( src, src_size, dst, dst_size, scratch, scratch_end );
		break;
	case 3:
		src_used = Krak_DecodeRLE( src, src_size, dst, dst_size, scratch, scratch_end );
		break;
	case 1:
		src_used = Krak_DecodeTans( src, src_size, dst, dst_size, scratch, scratch_end );
		break;
	}
	if ( src_used != src_size )
		return -1;
	*decoded_size = dst_size;
	return src + src_size - src_org;
}

void CombineScaledOffsetArrays( int* offs_stream, size_t offs_stream_size, int scale, const uint8* low_bits )
{
	for ( size_t i = 0; i != offs_stream_size; i++ )
		offs_stream[i] = scale * offs_stream[i] - low_bits[i];
}

// Unpacks the packed 8 bit offset and lengths into 32 bit.
bool Kraken_UnpackOffsets( const byte* src, const byte* src_end, const byte* packed_offs_stream,
	const byte* packed_offs_stream_extra, int packed_offs_stream_size, int multi_dist_scale,
	const byte* packed_litlen_stream, int packed_litlen_stream_size, int* offs_stream,
	int* len_stream, bool excess_flag, int excess_bytes )
{
	BitReader bits_a, bits_b;
	int n, i;
	int u32_len_stream_size = 0;

	bits_a.bitpos = 24;
	bits_a.bits = 0;
	bits_a.p = src;
	bits_a.p_end = src_end;
	BitReader_Refill( &bits_a );

	bits_b.bitpos = 24;
	bits_b.bits = 0;
	bits_b.p = src_end;
	bits_b.p_end = src;
	BitReader_RefillBackwards( &bits_b );

	if ( !excess_flag )
	{
		if ( bits_b.bits < 0x2000 )
			return false;
		n = 31 - BSR( bits_b.bits );
		bits_b.bitpos += n;
		bits_b.bits <<= n;
		BitReader_RefillBackwards( &bits_b );
		n++;
		u32_len_stream_size = ( bits_b.bits >> ( 32 - n ) ) - 1;
		bits_b.bitpos += n;
		bits_b.bits <<= n;
		BitReader_RefillBackwards( &bits_b );
	}

	if ( multi_dist_scale == 0 )
	{
		// Traditional way of coding offsets
		const uint8* packed_offs_stream_end = packed_offs_stream + packed_offs_stream_size;
		while ( packed_offs_stream != packed_offs_stream_end )
		{
			*offs_stream++ = -(int32)BitReader_ReadDistance( &bits_a, *packed_offs_stream++ );
			if ( packed_offs_stream == packed_offs_stream_end )
				break;
			*offs_stream++ = -(int32)BitReader_ReadDistanceB( &bits_b, *packed_offs_stream++ );
		}
	}
	else
	{
		// New way of coding offsets
		int* offs_stream_org = offs_stream;
		const uint8* packed_offs_stream_end = packed_offs_stream + packed_offs_stream_size;
		uint32 cmd, offs;
		while ( packed_offs_stream != packed_offs_stream_end )
		{
			cmd = *packed_offs_stream++;
			if ( ( cmd >> 3 ) > 26 )
				return 0;
			offs = ( ( 8 + ( cmd & 7 ) ) << ( cmd >> 3 ) ) | BitReader_ReadMoreThan24Bits( &bits_a, ( cmd >> 3 ) );
			*offs_stream++ = 8 - (int32)offs;
			if ( packed_offs_stream == packed_offs_stream_end )
				break;
			cmd = *packed_offs_stream++;
			if ( ( cmd >> 3 ) > 26 )
				return 0;
			offs = ( ( 8 + ( cmd & 7 ) ) << ( cmd >> 3 ) ) | BitReader_ReadMoreThan24BitsB( &bits_b, ( cmd >> 3 ) );
			*offs_stream++ = 8 - (int32)offs;
		}
		if ( multi_dist_scale != 1 )
		{
			CombineScaledOffsetArrays( offs_stream_org, offs_stream - offs_stream_org, multi_dist_scale,
				packed_offs_stream_extra );
		}
	}
	uint32 u32_len_stream_buf[512]; // max count is 128kb / 256 = 512
	if ( u32_len_stream_size > 512 )
		return false;

	uint32* u32_len_stream = u32_len_stream_buf, * u32_len_stream_end = u32_len_stream_buf + u32_len_stream_size;
	for ( i = 0; i + 1 < u32_len_stream_size; i += 2 )
	{
		if ( !BitReader_ReadLength( &bits_a, &u32_len_stream[i + 0] ) )
			return false;
		if ( !BitReader_ReadLengthB( &bits_b, &u32_len_stream[i + 1] ) )
			return false;
	}
	if ( i < u32_len_stream_size )
	{
		if ( !BitReader_ReadLength( &bits_a, &u32_len_stream[i + 0] ) )
			return false;
	}

	bits_a.p -= ( 24 - bits_a.bitpos ) >> 3;
	bits_b.p += ( 24 - bits_b.bitpos ) >> 3;

	if ( bits_a.p != bits_b.p )
		return false;

	for ( i = 0; i < packed_litlen_stream_size; i++ )
	{
		uint32 v = packed_litlen_stream[i];
		if ( v == 255 )
			v = *u32_len_stream++ + 255;
		len_stream[i] = v + 3;
	}
	if ( u32_len_stream != u32_len_stream_end )
		return false;

	return true;
}
bool Kraken_ReadLzTable( int mode, const byte* src, const byte* src_end, byte* dst, int dst_size, int offset,
	byte* scratch, byte* scratch_end, KrakenLzTable* lztable )
{
	byte* out;
	int decode_count, n;
	byte* packed_offs_stream, * packed_len_stream;

	if ( mode > 1 )
		return false;

	if ( src_end - src < 13 )
		return false;

	if ( offset == 0 )
	{
		COPY_64( dst, src );
		dst += 8;
		src += 8;
	}

	if ( *src & 0x80 )
	{
		uint8 flag = *src++;
		if ( ( flag & 0xc0 ) != 0x80 )
			return false; // reserved flag set

		return false; // excess bytes not supported
	}

	// Disable no copy optimization if source and dest overlap
	bool force_copy = dst <= src_end && src <= dst + dst_size;

	// Decode lit stream, bounded by dst_size
	out = scratch;
	n = Kraken_DecodeBytes( &out, src, src_end, &decode_count, Min( scratch_end - scratch, dst_size ), force_copy, scratch,
		scratch_end );
	if ( n < 0 )
		return false;
	src += n;
	lztable->lit_stream = out;
	lztable->lit_stream_size = decode_count;
	scratch += decode_count;

	// Decode command stream, bounded by dst_size
	out = scratch;
	n = Kraken_DecodeBytes( &out, src, src_end, &decode_count, Min( scratch_end - scratch, dst_size ), force_copy, scratch,
		scratch_end );
	if ( n < 0 )
		return false;
	src += n;
	lztable->cmd_stream = out;
	lztable->cmd_stream_size = decode_count;
	scratch += decode_count;

	// Check if to decode the multistuff crap
	if ( src_end - src < 3 )
		return false;

	int offs_scaling = 0;
	uint8* packed_offs_stream_extra = NULL;

	if ( src[0] & 0x80 )
	{
		// uses the mode where distances are coded with 2 tables
		offs_scaling = src[0] - 127;
		src++;

		packed_offs_stream = scratch;
		n = Kraken_DecodeBytes( &packed_offs_stream, src, src_end, &lztable->offs_stream_size,
			Min( scratch_end - scratch, lztable->cmd_stream_size ), false, scratch, scratch_end );
		if ( n < 0 )
			return false;
		src += n;
		scratch += lztable->offs_stream_size;

		if ( offs_scaling != 1 )
		{
			packed_offs_stream_extra = scratch;
			n = Kraken_DecodeBytes( &packed_offs_stream_extra, src, src_end, &decode_count,
				Min( scratch_end - scratch, lztable->offs_stream_size ), false, scratch, scratch_end );
			if ( n < 0 || decode_count != lztable->offs_stream_size )
				return false;
			src += n;
			scratch += decode_count;
		}
	}
	else
	{
		// Decode packed offset stream, it's bounded by the command length.
		packed_offs_stream = scratch;
		n = Kraken_DecodeBytes( &packed_offs_stream, src, src_end, &lztable->offs_stream_size,
			Min( scratch_end - scratch, lztable->cmd_stream_size ), false, scratch, scratch_end );
		if ( n < 0 )
			return false;
		src += n;
		scratch += lztable->offs_stream_size;
	}

	// Decode packed litlen stream. It's bounded by 1/4 of dst_size.
	packed_len_stream = scratch;
	n = Kraken_DecodeBytes( &packed_len_stream, src, src_end, &lztable->len_stream_size,
		Min( scratch_end - scratch, dst_size >> 2 ), false, scratch, scratch_end );
	if ( n < 0 )
		return false;
	src += n;
	scratch += lztable->len_stream_size;

	// Reserve memory for final dist stream
	scratch = ALIGN_POINTER( scratch, 16 );
	lztable->offs_stream = (int*)scratch;
	scratch += lztable->offs_stream_size * 4;

	// Reserve memory for final len stream
	scratch = ALIGN_POINTER( scratch, 16 );
	lztable->len_stream = (int*)scratch;
	scratch += lztable->len_stream_size * 4;

	if ( scratch + 64 > scratch_end )
		return false;

	return Kraken_UnpackOffsets( src, src_end, packed_offs_stream, packed_offs_stream_extra, lztable->offs_stream_size,
		offs_scaling, packed_len_stream, lztable->len_stream_size, lztable->offs_stream,
		lztable->len_stream, 0, 0 );
}

// Note: may access memory out of bounds on invalid input.
bool Kraken_ProcessLzRuns_Type0( KrakenLzTable* lzt, byte* dst, byte* dst_end, byte* dst_start )
{
	const byte* cmd_stream = lzt->cmd_stream, * cmd_stream_end = cmd_stream + lzt->cmd_stream_size;
	const int* len_stream = lzt->len_stream;
	const int* len_stream_end = lzt->len_stream + lzt->len_stream_size;
	const byte* lit_stream = lzt->lit_stream;
	const byte* lit_stream_end = lzt->lit_stream + lzt->lit_stream_size;
	const int* offs_stream = lzt->offs_stream;
	const int* offs_stream_end = lzt->offs_stream + lzt->offs_stream_size;
	const byte* copyfrom;
	uint32 final_len;
	int32 offset;
	int32 recent_offs[7];
	int32 last_offset;

	recent_offs[3] = -8;
	recent_offs[4] = -8;
	recent_offs[5] = -8;
	last_offset = -8;

	while ( cmd_stream < cmd_stream_end )
	{
		uint32 f = *cmd_stream++;
		uint32 litlen = f & 3;
		uint32 offs_index = f >> 6;
		uint32 matchlen = ( f >> 2 ) & 0xF;

		// use cmov
		uint32 next_long_length = *len_stream;
		const int* next_len_stream = len_stream + 1;

		len_stream = ( litlen == 3 ) ? next_len_stream : len_stream;
		litlen = ( litlen == 3 ) ? next_long_length : litlen;
		recent_offs[6] = *offs_stream;

		COPY_64_ADD( dst, lit_stream, &dst[last_offset] );
		if ( litlen > 8 )
		{
			COPY_64_ADD( dst + 8, lit_stream + 8, &dst[last_offset + 8] );
			if ( litlen > 16 )
			{
				COPY_64_ADD( dst + 16, lit_stream + 16, &dst[last_offset + 16] );
				if ( litlen > 24 )
				{
					do
					{
						COPY_64_ADD( dst + 24, lit_stream + 24, &dst[last_offset + 24] );
						litlen -= 8;
						dst += 8;
						lit_stream += 8;
					} while ( litlen > 24 );
				}
			}
		}
		dst += litlen;
		lit_stream += litlen;

		offset = recent_offs[offs_index + 3];
		recent_offs[offs_index + 3] = recent_offs[offs_index + 2];
		recent_offs[offs_index + 2] = recent_offs[offs_index + 1];
		recent_offs[offs_index + 1] = recent_offs[offs_index + 0];
		recent_offs[3] = offset;
		last_offset = offset;

		offs_stream = (int*)( (intptr_t)offs_stream + ( ( offs_index + 1 ) & 4 ) );

		if ( (uintptr_t)offset < (uintptr_t)( dst_start - dst ) )
			return false; // offset out of bounds

		copyfrom = dst + offset;
		if ( matchlen != 15 )
		{
			COPY_64( dst, copyfrom );
			COPY_64( dst + 8, copyfrom + 8 );
			dst += matchlen + 2;
		}
		else
		{
			matchlen = 14 + *len_stream++; // why is the value not 16 here, the above case copies up to 16 bytes.
			if ( (uintptr_t)matchlen > (uintptr_t)( dst_end - dst ) )
				return false; // copy length out of bounds
			COPY_64( dst, copyfrom );
			COPY_64( dst + 8, copyfrom + 8 );
			COPY_64( dst + 16, copyfrom + 16 );
			do
			{
				COPY_64( dst + 24, copyfrom + 24 );
				matchlen -= 8;
				dst += 8;
				copyfrom += 8;
			} while ( matchlen > 24 );
			dst += matchlen;
		}
	}

	// check for incorrect input
	if ( offs_stream != offs_stream_end || len_stream != len_stream_end )
		return false;

	final_len = dst_end - dst;
	if ( final_len != lit_stream_end - lit_stream )
		return false;

	if ( final_len >= 8 )
	{
		do
		{
			COPY_64_ADD( dst, lit_stream, &dst[last_offset] );
			dst += 8, lit_stream += 8, final_len -= 8;
		} while ( final_len >= 8 );
	}
	if ( final_len > 0 )
	{
		do
		{
			*dst = *lit_stream++ + dst[last_offset];
		} while ( dst++, --final_len );
	}
	return true;
}

// Note: may access memory out of bounds on invalid input.
bool Kraken_ProcessLzRuns_Type1( KrakenLzTable* lzt, byte* dst, byte* dst_end, byte* dst_start )
{
	const byte* cmd_stream = lzt->cmd_stream, * cmd_stream_end = cmd_stream + lzt->cmd_stream_size;
	const int* len_stream = lzt->len_stream;
	const int* len_stream_end = lzt->len_stream + lzt->len_stream_size;
	const byte* lit_stream = lzt->lit_stream;
	const byte* lit_stream_end = lzt->lit_stream + lzt->lit_stream_size;
	const int* offs_stream = lzt->offs_stream;
	const int* offs_stream_end = lzt->offs_stream + lzt->offs_stream_size;
	const byte* copyfrom;
	uint32 final_len;
	int32 offset;
	int32 recent_offs[7];

	recent_offs[3] = -8;
	recent_offs[4] = -8;
	recent_offs[5] = -8;

	while ( cmd_stream < cmd_stream_end )
	{
		uint32 f = *cmd_stream++;
		uint32 litlen = f & 3;
		uint32 offs_index = f >> 6;
		uint32 matchlen = ( f >> 2 ) & 0xF;

		// use cmov
		uint32 next_long_length = *len_stream;
		const int* next_len_stream = len_stream + 1;

		len_stream = ( litlen == 3 ) ? next_len_stream : len_stream;
		litlen = ( litlen == 3 ) ? next_long_length : litlen;
		recent_offs[6] = *offs_stream;

		COPY_64( dst, lit_stream );
		if ( litlen > 8 )
		{
			COPY_64( dst + 8, lit_stream + 8 );
			if ( litlen > 16 )
			{
				COPY_64( dst + 16, lit_stream + 16 );
				if ( litlen > 24 )
				{
					do
					{
						COPY_64( dst + 24, lit_stream + 24 );
						litlen -= 8;
						dst += 8;
						lit_stream += 8;
					} while ( litlen > 24 );
				}
			}
		}
		dst += litlen;
		lit_stream += litlen;

		offset = recent_offs[offs_index + 3];
		recent_offs[offs_index + 3] = recent_offs[offs_index + 2];
		recent_offs[offs_index + 2] = recent_offs[offs_index + 1];
		recent_offs[offs_index + 1] = recent_offs[offs_index + 0];
		recent_offs[3] = offset;

		offs_stream = (int*)( (intptr_t)offs_stream + ( ( offs_index + 1 ) & 4 ) );

		if ( (uintptr_t)offset < (uintptr_t)( dst_start - dst ) )
			return false; // offset out of bounds

		copyfrom = dst + offset;
		if ( matchlen != 15 )
		{
			COPY_64( dst, copyfrom );
			COPY_64( dst + 8, copyfrom + 8 );
			dst += matchlen + 2;
		}
		else
		{
			matchlen = 14 + *len_stream++; // why is the value not 16 here, the above case copies up to 16 bytes.
			if ( (uintptr_t)matchlen > (uintptr_t)( dst_end - dst ) )
				return false; // copy length out of bounds
			COPY_64( dst, copyfrom );
			COPY_64( dst + 8, copyfrom + 8 );
			COPY_64( dst + 16, copyfrom + 16 );
			do
			{
				COPY_64( dst + 24, copyfrom + 24 );
				matchlen -= 8;
				dst += 8;
				copyfrom += 8;
			} while ( matchlen > 24 );
			dst += matchlen;
		}
	}

	// check for incorrect input
	if ( offs_stream != offs_stream_end || len_stream != len_stream_end )
		return false;

	final_len = dst_end - dst;
	if ( final_len != lit_stream_end - lit_stream )
		return false;

	if ( final_len >= 64 )
	{
		do
		{
			COPY_64_BYTES( dst, lit_stream );
			dst += 64, lit_stream += 64, final_len -= 64;
		} while ( final_len >= 64 );
	}
	if ( final_len >= 8 )
	{
		do
		{
			COPY_64( dst, lit_stream );
			dst += 8, lit_stream += 8, final_len -= 8;
		} while ( final_len >= 8 );
	}
	if ( final_len > 0 )
	{
		do
		{
			*dst++ = *lit_stream++;
		} while ( --final_len );
	}
	return true;
}

bool Kraken_ProcessLzRuns( int mode, byte* dst, int dst_size, int offset, KrakenLzTable* lztable )
{
	byte* dst_end = dst + dst_size;

	if ( mode == 1 )
		return Kraken_ProcessLzRuns_Type1( lztable, dst + ( offset == 0 ? 8 : 0 ), dst_end, dst - offset );

	if ( mode == 0 )
		return Kraken_ProcessLzRuns_Type0( lztable, dst + ( offset == 0 ? 8 : 0 ), dst_end, dst - offset );

	return false;
}

// Decode one 256kb big quantum block. It's divided into two 128k blocks
// internally that are compressed separately but with a shared history.
int Kraken_DecodeQuantum( byte* dst, byte* dst_end, byte* dst_start, const byte* src, const byte* src_end, byte* scratch,
	byte* scratch_end )
{
	const byte* src_in = src;
	int mode, chunkhdr, dst_count, src_used, written_bytes;

	while ( dst_end - dst != 0 )
	{
		dst_count = dst_end - dst;
		if ( dst_count > 0x20000 )
			dst_count = 0x20000;
		if ( src_end - src < 4 )
			return -1;
		chunkhdr = src[2] | src[1] << 8 | src[0] << 16;
		if ( !( chunkhdr & 0x800000 ) )
		{
			// Stored as entropy without any match copying.
			byte* out = dst;
			src_used = Kraken_DecodeBytes( &out, src, src_end, &written_bytes, dst_count, false, scratch, scratch_end );
			if ( src_used < 0 || written_bytes != dst_count )
				return -1;
		}
		else
		{
			src += 3;
			src_used = chunkhdr & 0x7FFFF;
			mode = ( chunkhdr >> 19 ) & 0xF;
			if ( src_end - src < src_used )
				return -1;
			if ( src_used < dst_count )
			{
				size_t scratch_usage = Min( Min( 3 * dst_count + 32 + 0xd000, 0x6C000 ), scratch_end - scratch );
				if ( scratch_usage < sizeof( KrakenLzTable ) )
					return -1;
				if ( !Kraken_ReadLzTable( mode, src, src + src_used, dst, dst_count, dst - dst_start,
					scratch + sizeof( KrakenLzTable ), scratch + scratch_usage,
					(KrakenLzTable*)scratch ) )
					return -1;
				if ( !Kraken_ProcessLzRuns( mode, dst, dst_count, dst - dst_start, (KrakenLzTable*)scratch ) )
					return -1;
			}
			else if ( src_used > dst_count || mode != 0 )
			{
				return -1;
			}
			else
			{
				memmove( dst, src, dst_count );
			}
		}
		src += src_used;
		dst += dst_count;
	}
	return src - src_in;
}

void Kraken_CopyWholeMatch( byte* dst, uint32 offset, size_t length )
{
	size_t i = 0;
	byte* src = dst - offset;
	if ( offset >= 8 )
	{
		for ( ; i + 8 <= length; i += 8 )
			*(uint64*)( dst + i ) = *(uint64*)( src + i );
	}
	for ( ; i < length; i++ )
		dst[i] = src[i];
}

bool Kraken_DecodeStep( struct KrakenDecoder* dec, byte* dst_start, int offset, size_t dst_bytes_left_in,
	const byte* src, size_t src_bytes_left )
{
	const byte* src_in = src;
	const byte* src_end = src + src_bytes_left;
	KrakenQuantumHeader qhdr;
	int n;

	if ( ( offset & 0x3FFFF ) == 0 )
	{
		src = Kraken_ParseHeader( &dec->hdr, src );
		if ( !src )
			return false;
	}

	bool is_kraken_decoder = ( dec->hdr.decoder_type == 6 || dec->hdr.decoder_type == 10 || dec->hdr.decoder_type == 12 );

	int dst_bytes_left = (int)Min( is_kraken_decoder ? 0x40000 : 0x4000, dst_bytes_left_in );

	if ( dec->hdr.uncompressed )
	{
		if ( src_end - src < dst_bytes_left )
		{
			dec->src_used = dec->dst_used = 0;
			return true;
		}
		memmove( dst_start + offset, src, dst_bytes_left );
		dec->src_used = ( src - src_in ) + dst_bytes_left;
		dec->dst_used = dst_bytes_left;
		return true;
	}

	if ( is_kraken_decoder )
	{
		src = Kraken_ParseQuantumHeader( &qhdr, src, dec->hdr.use_checksums );
	}
	else
	{
		src = LZNA_ParseQuantumHeader( &qhdr, src, dec->hdr.use_checksums, dst_bytes_left );
	}

	if ( !src || src > src_end )
		return false;

	// Too few bytes in buffer to make any progress?
	if ( (uintptr_t)( src_end - src ) < qhdr.compressed_size )
	{
		dec->src_used = dec->dst_used = 0;
		return true;
	}

	if ( qhdr.compressed_size > (uint32)dst_bytes_left )
		return false;

	if ( qhdr.compressed_size == 0 )
	{
		if ( qhdr.whole_match_distance != 0 )
		{
			if ( qhdr.whole_match_distance > (uint32)offset )
				return false;
			Kraken_CopyWholeMatch( dst_start + offset, qhdr.whole_match_distance, dst_bytes_left );
		}
		else
		{
			memset( dst_start + offset, qhdr.checksum, dst_bytes_left );
		}
		dec->src_used = ( src - src_in );
		dec->dst_used = dst_bytes_left;
		return true;
	}

	if ( dec->hdr.use_checksums && ( Kraken_GetCrc( src, qhdr.compressed_size ) & 0xFFFFFF ) != qhdr.checksum )
		return false;

	if ( qhdr.compressed_size == dst_bytes_left )
	{
		memmove( dst_start + offset, src, dst_bytes_left );
		dec->src_used = ( src - src_in ) + dst_bytes_left;
		dec->dst_used = dst_bytes_left;
		return true;
	}

	if ( dec->hdr.decoder_type == 6 )
	{
		n = Kraken_DecodeQuantum( dst_start + offset, dst_start + offset + dst_bytes_left, dst_start, src,
			src + qhdr.compressed_size, dec->scratch, dec->scratch + dec->scratch_size );
	}
	else
	{
		return false;
	}

	if ( n != qhdr.compressed_size )
		return false;

	dec->src_used = ( src - src_in ) + n;
	dec->dst_used = dst_bytes_left;
	return true;
}

// EXPORT int Kraken_Decompress(const byte *src, size_t src_len, byte *dst, size_t dst_len) {
int Kraken_Decompress( const byte* src, size_t src_len, byte* dst, size_t dst_len )
{
	KrakenDecoder* dec = Kraken_Create( );
	int offset = 0;
	while ( dst_len != 0 )
	{
		if ( !Kraken_DecodeStep( dec, dst, offset, dst_len, src, src_len ) )
			goto FAIL;
		if ( dec->src_used == 0 )
			goto FAIL;
		src += dec->src_used;
		src_len -= dec->src_used;
		dst_len -= dec->dst_used;
		offset += dec->dst_used;
	}
	if ( src_len != 0 )
		goto FAIL;
	Kraken_Destroy( dec );
	return offset;
FAIL:
	Kraken_Destroy( dec );
	return -1;
}

// The decompressor will write outside of the target buffer.
#define SAFE_SPACE 64

void error( const char* s )
{
	fprintf( stderr, "%s\n", s );
	exit( 1 );
}

enum
{
	kCompressor_Kraken = 8,
	kCompressor_Mermaid = 9,
	kCompressor_Selkie = 11,
	kCompressor_Hydra = 12,
	kCompressor_Leviathan = 13,
};

bool arg_stdout, arg_force, arg_quiet, arg_dll;
int arg_compressor = kCompressor_Kraken, arg_level = 5;
char arg_direction;
char* verifyfolder;
```

`Utils/kraken.h`:

```h
#pragma once

// #ifdef _MSC_VER
// #include <SDKDDKVer.h>
// #endif

// #define _CRT_SECURE_NO_WARNINGS 1

#include <assert.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined(_MSC_VER)
#include <Windows.h>
#include <intrin.h>
#undef max
#undef min
#else
#include <stddef.h>
#include <x86intrin.h>
#if defined(__GNUC__) || defined(__clang__)
// GNU C / Clang supports forcing inline, just via a different syntax.
// disable this on MinGW compiler
#if not defined(__MINGW32__)
#define __forceinline inline __attribute__((always_inline))
#endif //__MINGW32__
#else
// Fall back to the standardized inline keyword for unknown dialects
#define __forceinline inline
#endif //__GNUC__

#define _byteswap_ushort(x) __builtin_bswap16((uint16)(x))
#define _byteswap_ulong(x) __builtin_bswap32((uint32)(x))
#define _byteswap_uint64(x) __builtin_bswap64((uint64)(x))
#define _BitScanForward(dst, x) (*(dst) = __builtin_ctz(x))
#define _BitScanReverse(dst, x) (*(dst) = (__builtin_clz(x) ^ 31))

// // disable this on MinGW compiler
// static inline uint32_t _rotl(uint32_t x, int n) {
//   return (((x) << (n)) | ((x) >> (32-(n))));
// }
#endif

// Windows has this enabled implicitly (and uses different headers), GNU C compilers generally require passing an
// additional flag, so check for that first.
#ifdef __AVX__
#ifdef _WIN32
#include <xmmintrin.h>
#endif
#endif
#ifdef __APPLE__
#include <simde/x86/sse.h>
#include <simde/x86/sse2.h>
#endif

#ifdef __GNUC__
#define UNUSED __attribute__((unused))
#elif defined(__cplusplus) && __cplusplus >= 201703L // C++17 attributes
#define UNUSED [[maybe_unused]]
#else // unknown or incompatible method of indicating unused.
#define UNUSED
#endif

#if defined(_MSC_VER)
//  Microsoft
#define EXPORT extern "C" __declspec(dllexport)
#define IMPORT __declspec(dllimport)
#elif defined(__GNUC__)
//  GCC
#define EXPORT extern "C" __attribute__((visibility("default")))
#define IMPORT
#else
//  do nothing and hope for the best?
#define EXPORT
#define IMPORT
#pragma warning Unknown dynamic link import / export semantics.
#endif

typedef uint8_t byte;
typedef uint8_t uint8;
typedef uint32_t uint32;
typedef uint64_t uint64;
typedef int64_t int64;
typedef int32_t int32;
typedef uint16_t uint16;
typedef int16_t int16;
typedef unsigned int uint;

// EXPORT int Kraken_Decompress(const byte *src, size_t src_len, byte *dst, size_t dst_len);
int Kraken_Decompress( const byte* src, size_t src_len, byte* dst, size_t dst_len );
```

`games.json`:

```json
{
  "version": "1.1",
  "description": "EAC Module Configuration - Community maintained list of game IDs",
  "config": {
    "baseUrl": "https://modules-cdn.eac-prod.on.epicgames.com/modules",
    "defaultPlatform": "win64"
  },
  "games": [
    {
      "name": "Gray Zone Warfare",
      "productId": "320d5d3f30f5495ebae73a8c74bc349d",
      "deploymentId": "5844bb109c5343f78b8f76f604ae3569"
    },
    {
      "name": "Arc Raiders",
      "productId": "9e8b37541e614575b4de303d2c2e44cf",
      "deploymentId": "35e06571d8ab4de4b98519b624125459"
    },
    {
      "name": "Fortnite",
      "productId": "b2504259773b40e3a818f820e31979ca",
      "deploymentId": "47b56979fab54704970a6b1331d1e291"
    }
  ]
}

```

`main.cpp`:

```cpp
#include <iostream>
#include <string>
#include <Windows.h>
#include "EACExtractor.h"
#include "ModuleDownloader.h"
#include "GameConfig.h"
#include "FileUtils.h"
#include "Log.h"

// ---- ANSI color helpers for interactive menus ----
namespace
{
	constexpr auto Reset  = "\x1b[0m";
	constexpr auto Bold   = "\x1b[1m";
	constexpr auto Yellow = "\x1b[33m";
	constexpr auto Cyan   = "\x1b[36m";
	constexpr auto Gray   = "\x1b[90m";
}

static void PrintMainMenu()
{
	printf("\n");
	Log::Info("What would you like to do?");
	printf("%s[1]%s Download and extract from Epic Games CDN\n", Yellow, Reset);
	printf("%s[2]%s Extract from local file\n", Yellow, Reset);
	printf("%s[3]%s List available games\n", Yellow, Reset);
	printf("%s[4]%s Show help\n", Yellow, Reset);
	printf("%s[Q]%s Quit\n", Yellow, Reset);
}

static void PrintUsage(const char* programName)
{
	Log::Banner();
	printf("%sUsage:%s %s [options]\n", Bold, Reset, programName);
	printf("       %s -h | --help\n", programName);
	printf("\n%sOptions:%s\n", Bold, Reset);
	printf("  %s-d, --download%s    Download and then extract from Epic Games CDN\n", Yellow, Reset);
	printf("  %s-e, --extract%s     Extract and decrypt local EAC binary (optional: path)\n", Yellow, Reset);
	printf("  %s-l, --list%s        List available games from configuration\n", Yellow, Reset);
	printf("\n%sOutput:%s\n", Bold, Reset);
	printf("  Creates timestamped folder in C:%s\\EAC_Dumps%s with extracted components\n", Yellow, Reset);
}

static std::string SelectPlatform(const GameConfig& config)
{
	auto platforms = config.GetAvailablePlatforms();
	printf("\n%sSelect platform:%s\n", Bold, Reset);

	for (size_t i = 0; i < platforms.size(); ++i)
	{
		printf("[%zu] %s", i + 1, platforms[i].c_str());
		if (platforms[i] == config.GetDefaultPlatform())
		{
			printf(" %s(default)%s", Gray, Reset);
		}
		printf("\n");
	}

	printf("\n%sChoice (default: %s): %s", Yellow, config.GetDefaultPlatform().c_str(), Reset);
	std::string choice;
	std::getline(std::cin, choice);

	if (choice.empty())
	{
		return config.GetDefaultPlatform();
	}

	try
	{
		int index = std::stoi(choice) - 1;
		if (index >= 0 && index < static_cast<int>(platforms.size()))
		{
			return platforms[index];
		}
	}
	catch (...)
	{
		Log::Error("Invalid input, please enter a valid number.");
		return config.GetDefaultPlatform();
	}

	Log::Warning("Invalid choice, using default platform");
	return config.GetDefaultPlatform();
}

static bool ExtractModuleFrom(const std::string& inputFile, const std::string& outputFolder)
{
	printf("\n%s%s=== EAC Payload Extractor ===%s\n", Bold, Cyan, Reset);
	Log::Info("Input file: %s", inputFile.c_str());

	try
	{
		EACExtractor extractor(inputFile, outputFolder);

		if (!extractor.Process())
		{
			Log::Error("Extraction failed");
			return false;
		}

		return true;
	}
	catch (const std::exception& e)
	{
		Log::Error("Exception: %s", e.what());
		return false;
	}
}

static bool DownloadThenExtract()
{
	GameConfig config;
	config.LoadConfig();
	std::string gameName;
	std::string productId;
	std::string deploymentId;

	printf("\n%s%s=== EAC Module Downloader ===%s\n", Bold, Cyan, Reset);

	if (!config.IsEmpty())
	{
		Log::Success("Found game configuration file!");
		config.ListGames();

		printf("\n%sSelect an option:%s\n", Bold, Reset);
		printf("[1-%zu] Select a game from the list\n", config.GetAllGames().size());
		printf("[%sC%s] Enter ProductID and DeploymentID\n", Yellow, Reset);
		printf("\n%sChoice: %s", Yellow, Reset);

		std::string choice;
		std::getline(std::cin, choice);

		if (!choice.empty() && choice[0] != 'c' && choice[0] != 'C')
		{
			try
			{
				int  gameIndex = std::stoi(choice) - 1;
				auto games     = config.GetAllGames();
				if (gameIndex >= 0 && gameIndex < static_cast<int>(games.size()))
				{
					auto& game   = games[gameIndex];
					gameName     = game.Name;
					productId    = game.ProductId;
					deploymentId = game.DeploymentId;

					Log::Success("Selected: %s", game.Name.c_str());
					Log::Info("ProductID: %s", game.ProductId.c_str());
					Log::Info("DeploymentID: %s", game.DeploymentId.c_str());
				}
				else
				{
					Log::Error("Invalid choice index");
					return false;
				}
			}
			catch (...)
			{
				Log::Error("Invalid choice, please enter a valid number or 'C' for custom input.");
				return false;
			}
		}
	}

	// Manual input if needed
	if (productId.empty() || deploymentId.empty())
	{
		Log::Info("Please enter the EAC module details:");
		printf("%sExample: Gray Zone Warfare%s\n", Gray, Reset);
		printf("%sProductID: 320d5d3f30f5495ebae73a8c74bc349d%s\n", Gray, Reset);
		printf("%sDeploymentID: 5844bb109c5343f78b8f76f604ae3569%s\n", Gray, Reset);

		printf("\n%sGame name (optional): %s", Yellow, Reset);
		std::getline(std::cin, gameName);

		printf("%sProductID: %s", Yellow, Reset);
		std::getline(std::cin, productId);

		printf("%sDeploymentID: %s", Yellow, Reset);
		std::getline(std::cin, deploymentId);

		if (productId.empty() || deploymentId.empty())
		{
			Log::Error("Product ID and Deployment ID are required!");
			return false;
		}

		if (!gameName.empty())
		{
			printf("\n%s[?] Save this configuration for future use? (y/N): %s", Yellow, Reset);
			std::string saveChoice;
			std::getline(std::cin, saveChoice);

			if (!saveChoice.empty() && (saveChoice[0] == 'y' || saveChoice[0] == 'Y'))
			{
				GameInfo gameInfo;
				gameInfo.Name         = gameName;
				gameInfo.ProductId    = productId;
				gameInfo.DeploymentId = deploymentId;

				config.AddGame(gameInfo);
				if (config.SaveConfig())
					Log::Success("Configuration saved successfully!");
				else
					Log::Error("Failed to save configuration");
			}
		}
	}

	// Create dump folder with game name
	const std::string dumpFolder = gameName.empty()
		                               ? FileUtils::CreateDumpFolder()
		                               : FileUtils::CreateDumpFolder(gameName);
	if (dumpFolder.empty())
	{
		Log::Error("Failed to create dump folder");
		return false;
	}

	// Select platform
	std::string platform = SelectPlatform(config);
	Log::Info("Platform: %s", platform.c_str());

	const std::string downloadedPath = dumpFolder + "\\eac_.bin";

	if (!ModuleDownloader::DownloadModule(productId, deploymentId, platform, config.GetBaseUrl(),
	                                      downloadedPath, Log::Progress))
	{
		Log::Error("Download failed");
		return false;
	}

	Log::Info("Download finished. Starting extraction...");

	return ExtractModuleFrom(downloadedPath, dumpFolder);
}

int main(int argc, char* argv[])
{
	Log::Init();
	Log::Banner();

	// Command line arguments
	if (argc > 1)
	{
		std::string arg = argv[1];
		if (arg == "-h" || arg == "--help")
		{
			PrintUsage(argv[0]);
			return 0;
		}

		if (arg == "-d" || arg == "--download")
		{
			return DownloadThenExtract() ? 0 : 1;
		}

		if (arg == "-e" || arg == "--extract")
		{
			std::string path = (argc > 2 && argv[2]) ? std::string(argv[2]) : std::string("eac_.bin");
			return ExtractModuleFrom(path, "") ? 0 : 1;
		}

		if (arg == "-l" || arg == "--list")
		{
			GameConfig config;
			if (config.LoadConfig())
			{
				config.ListGames();
			}
			else
			{
				Log::Info("No game configuration file found.");
			}
			return 0;
		}
	}

	// Interactive mode
	PrintMainMenu();

	while (true)
	{
		printf("\n%sChoice (1-4, Q): %s", Yellow, Reset);
		std::string choice;
		std::getline(std::cin, choice);

		if (choice.empty()) continue;

		switch (choice[0])
		{
		case '1':
			return DownloadThenExtract() ? 0 : 1;

		case '2':
			{
				printf("%sEnter path to EAC binary (default: eac_.bin): %s", Yellow, Reset);
				std::string path;
				std::getline(std::cin, path);
				if (path.empty()) path = "eac_.bin";
				return ExtractModuleFrom(path, "") ? 0 : 1;
			}

		case '3':
			{
				GameConfig config;
				if (config.LoadConfig())
				{
					config.ListGames();
				}
				else
				{
					Log::Info("No game configuration file found.");
					Log::Info("Use option 1 to download and configure games.");
				}
				break;
			}

		case '4':
			PrintUsage(argv[0]);
			break;

		case 'q':
		case 'Q':
			Log::Success("Goodbye!");
			return 0;

		default:
			Log::Warning("Invalid choice. Please enter 1-4 or Q.");
			break;
		}
	}

	return 0;
}

```

`miniz/miniz.c`:

```c
/**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/

#include "miniz.h"

typedef unsigned char mz_validate_uint16[sizeof(mz_uint16) == 2 ? 1 : -1];
typedef unsigned char mz_validate_uint32[sizeof(mz_uint32) == 4 ? 1 : -1];
typedef unsigned char mz_validate_uint64[sizeof(mz_uint64) == 8 ? 1 : -1];

#ifdef __cplusplus
extern "C"
{
#endif

    /* ------------------- zlib-style API's */

    mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)
    {
        mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16);
        size_t block_len = buf_len % 5552;
        if (!ptr)
            return MZ_ADLER32_INIT;
        while (buf_len)
        {
            for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
            {
                s1 += ptr[0], s2 += s1;
                s1 += ptr[1], s2 += s1;
                s1 += ptr[2], s2 += s1;
                s1 += ptr[3], s2 += s1;
                s1 += ptr[4], s2 += s1;
                s1 += ptr[5], s2 += s1;
                s1 += ptr[6], s2 += s1;
                s1 += ptr[7], s2 += s1;
            }
            for (; i < block_len; ++i)
                s1 += *ptr++, s2 += s1;
            s1 %= 65521U, s2 %= 65521U;
            buf_len -= block_len;
            block_len = 5552;
        }
        return (s2 << 16) + s1;
    }

/* Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/ */
#if 0
    mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
    {
        static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
                                               0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };
        mz_uint32 crcu32 = (mz_uint32)crc;
        if (!ptr)
            return MZ_CRC32_INIT;
        crcu32 = ~crcu32;
        while (buf_len--)
        {
            mz_uint8 b = *ptr++;
            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
        }
        return ~crcu32;
    }
#elif defined(USE_EXTERNAL_MZCRC)
/* If USE_EXTERNAL_CRC is defined, an external module will export the
 * mz_crc32() symbol for us to use, e.g. an SSE-accelerated version.
 * Depending on the impl, it may be necessary to ~ the input/output crc values.
 */
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len);
#else
/* Faster, but larger CPU cache footprint.
 */
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
{
    static const mz_uint32 s_crc_table[256] = {
        0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535,
        0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD,
        0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D,
        0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
        0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
        0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
        0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC,
        0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
        0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB,
        0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
        0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB,
        0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
        0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA,
        0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE,
        0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
        0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
        0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409,
        0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
        0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739,
        0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
        0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268,
        0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0,
        0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8,
        0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
        0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
        0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703,
        0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7,
        0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
        0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE,
        0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
        0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6,
        0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
        0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D,
        0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5,
        0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
        0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
        0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
    };

    mz_uint32 crc32 = (mz_uint32)crc ^ 0xFFFFFFFF;
    const mz_uint8 *pByte_buf = (const mz_uint8 *)ptr;

    while (buf_len >= 4)
    {
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[1]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[2]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[3]) & 0xFF];
        pByte_buf += 4;
        buf_len -= 4;
    }

    while (buf_len)
    {
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
        ++pByte_buf;
        --buf_len;
    }

    return ~crc32;
}
#endif

    void mz_free(void *p)
    {
        MZ_FREE(p);
    }

    MINIZ_EXPORT void *miniz_def_alloc_func(void *opaque, size_t items, size_t size)
    {
        (void)opaque, (void)items, (void)size;
        return MZ_MALLOC(items * size);
    }
    MINIZ_EXPORT void miniz_def_free_func(void *opaque, void *address)
    {
        (void)opaque, (void)address;
        MZ_FREE(address);
    }
    MINIZ_EXPORT void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size)
    {
        (void)opaque, (void)address, (void)items, (void)size;
        return MZ_REALLOC(address, items * size);
    }

    const char *mz_version(void)
    {
        return MZ_VERSION;
    }

#ifndef MINIZ_NO_ZLIB_APIS

#ifndef MINIZ_NO_DEFLATE_APIS

    int mz_deflateInit(mz_streamp pStream, int level)
    {
        return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9, MZ_DEFAULT_STRATEGY);
    }

    int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
    {
        tdefl_compressor *pComp;
        mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);

        if (!pStream)
            return MZ_STREAM_ERROR;
        if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)))
            return MZ_PARAM_ERROR;

        pStream->data_type = 0;
        pStream->adler = MZ_ADLER32_INIT;
        pStream->msg = NULL;
        pStream->reserved = 0;
        pStream->total_in = 0;
        pStream->total_out = 0;
        if (!pStream->zalloc)
            pStream->zalloc = miniz_def_alloc_func;
        if (!pStream->zfree)
            pStream->zfree = miniz_def_free_func;

        pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor));
        if (!pComp)
            return MZ_MEM_ERROR;

        pStream->state = (struct mz_internal_state *)pComp;

        if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY)
        {
            mz_deflateEnd(pStream);
            return MZ_PARAM_ERROR;
        }

        return MZ_OK;
    }

    int mz_deflateReset(mz_streamp pStream)
    {
        if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree))
            return MZ_STREAM_ERROR;
        pStream->total_in = pStream->total_out = 0;
        tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL, ((tdefl_compressor *)pStream->state)->m_flags);
        return MZ_OK;
    }

    int mz_deflate(mz_streamp pStream, int flush)
    {
        size_t in_bytes, out_bytes;
        mz_ulong orig_total_in, orig_total_out;
        int mz_status = MZ_OK;

        if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out))
            return MZ_STREAM_ERROR;
        if (!pStream->avail_out)
            return MZ_BUF_ERROR;

        if (flush == MZ_PARTIAL_FLUSH)
            flush = MZ_SYNC_FLUSH;

        if (((tdefl_compressor *)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
            return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;

        orig_total_in = pStream->total_in;
        orig_total_out = pStream->total_out;
        for (;;)
        {
            tdefl_status defl_status;
            in_bytes = pStream->avail_in;
            out_bytes = pStream->avail_out;

            defl_status = tdefl_compress((tdefl_compressor *)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
            pStream->next_in += (mz_uint)in_bytes;
            pStream->avail_in -= (mz_uint)in_bytes;
            pStream->total_in += (mz_uint)in_bytes;
            pStream->adler = tdefl_get_adler32((tdefl_compressor *)pStream->state);

            pStream->next_out += (mz_uint)out_bytes;
            pStream->avail_out -= (mz_uint)out_bytes;
            pStream->total_out += (mz_uint)out_bytes;

            if (defl_status < 0)
            {
                mz_status = MZ_STREAM_ERROR;
                break;
            }
            else if (defl_status == TDEFL_STATUS_DONE)
            {
                mz_status = MZ_STREAM_END;
                break;
            }
            else if (!pStream->avail_out)
                break;
            else if ((!pStream->avail_in) && (flush != MZ_FINISH))
            {
                if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))
                    break;
                return MZ_BUF_ERROR; /* Can't make forward progress without some input.
                                      */
            }
        }
        return mz_status;
    }

    int mz_deflateEnd(mz_streamp pStream)
    {
        if (!pStream)
            return MZ_STREAM_ERROR;
        if (pStream->state)
        {
            pStream->zfree(pStream->opaque, pStream->state);
            pStream->state = NULL;
        }
        return MZ_OK;
    }

    mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)
    {
        (void)pStream;
        /* This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.) */
        return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
    }

    int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level)
    {
        int status;
        mz_stream stream;
        memset(&stream, 0, sizeof(stream));

        /* In case mz_ulong is 64-bits (argh I hate longs). */
        if ((mz_uint64)(source_len | *pDest_len) > 0xFFFFFFFFU)
            return MZ_PARAM_ERROR;

        stream.next_in = pSource;
        stream.avail_in = (mz_uint32)source_len;
        stream.next_out = pDest;
        stream.avail_out = (mz_uint32)*pDest_len;

        status = mz_deflateInit(&stream, level);
        if (status != MZ_OK)
            return status;

        status = mz_deflate(&stream, MZ_FINISH);
        if (status != MZ_STREAM_END)
        {
            mz_deflateEnd(&stream);
            return (status == MZ_OK) ? MZ_BUF_ERROR : status;
        }

        *pDest_len = stream.total_out;
        return mz_deflateEnd(&stream);
    }

    int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
    {
        return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);
    }

    mz_ulong mz_compressBound(mz_ulong source_len)
    {
        return mz_deflateBound(NULL, source_len);
    }

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS

    typedef struct
    {
        tinfl_decompressor m_decomp;
        mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;
        int m_window_bits;
        mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
        tinfl_status m_last_status;
    } inflate_state;

    int mz_inflateInit2(mz_streamp pStream, int window_bits)
    {
        inflate_state *pDecomp;
        if (!pStream)
            return MZ_STREAM_ERROR;
        if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS))
            return MZ_PARAM_ERROR;

        pStream->data_type = 0;
        pStream->adler = 0;
        pStream->msg = NULL;
        pStream->total_in = 0;
        pStream->total_out = 0;
        pStream->reserved = 0;
        if (!pStream->zalloc)
            pStream->zalloc = miniz_def_alloc_func;
        if (!pStream->zfree)
            pStream->zfree = miniz_def_free_func;

        pDecomp = (inflate_state *)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));
        if (!pDecomp)
            return MZ_MEM_ERROR;

        pStream->state = (struct mz_internal_state *)pDecomp;

        tinfl_init(&pDecomp->m_decomp);
        pDecomp->m_dict_ofs = 0;
        pDecomp->m_dict_avail = 0;
        pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
        pDecomp->m_first_call = 1;
        pDecomp->m_has_flushed = 0;
        pDecomp->m_window_bits = window_bits;

        return MZ_OK;
    }

    int mz_inflateInit(mz_streamp pStream)
    {
        return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
    }

    int mz_inflateReset(mz_streamp pStream)
    {
        inflate_state *pDecomp;
        if (!pStream)
            return MZ_STREAM_ERROR;

        pStream->data_type = 0;
        pStream->adler = 0;
        pStream->msg = NULL;
        pStream->total_in = 0;
        pStream->total_out = 0;
        pStream->reserved = 0;

        pDecomp = (inflate_state *)pStream->state;

        tinfl_init(&pDecomp->m_decomp);
        pDecomp->m_dict_ofs = 0;
        pDecomp->m_dict_avail = 0;
        pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
        pDecomp->m_first_call = 1;
        pDecomp->m_has_flushed = 0;
        /* pDecomp->m_window_bits = window_bits */;

        return MZ_OK;
    }

    int mz_inflate(mz_streamp pStream, int flush)
    {
        inflate_state *pState;
        mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
        size_t in_bytes, out_bytes, orig_avail_in;
        tinfl_status status;

        if ((!pStream) || (!pStream->state))
            return MZ_STREAM_ERROR;
        if (flush == MZ_PARTIAL_FLUSH)
            flush = MZ_SYNC_FLUSH;
        if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH))
            return MZ_STREAM_ERROR;

        pState = (inflate_state *)pStream->state;
        if (pState->m_window_bits > 0)
            decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
        orig_avail_in = pStream->avail_in;

        first_call = pState->m_first_call;
        pState->m_first_call = 0;
        if (pState->m_last_status < 0)
            return MZ_DATA_ERROR;

        if (pState->m_has_flushed && (flush != MZ_FINISH))
            return MZ_STREAM_ERROR;
        pState->m_has_flushed |= (flush == MZ_FINISH);

        if ((flush == MZ_FINISH) && (first_call))
        {
            /* MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file. */
            decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
            in_bytes = pStream->avail_in;
            out_bytes = pStream->avail_out;
            status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);
            pState->m_last_status = status;
            pStream->next_in += (mz_uint)in_bytes;
            pStream->avail_in -= (mz_uint)in_bytes;
            pStream->total_in += (mz_uint)in_bytes;
            pStream->adler = tinfl_get_adler32(&pState->m_decomp);
            pStream->next_out += (mz_uint)out_bytes;
            pStream->avail_out -= (mz_uint)out_bytes;
            pStream->total_out += (mz_uint)out_bytes;

            if (status < 0)
                return MZ_DATA_ERROR;
            else if (status != TINFL_STATUS_DONE)
            {
                pState->m_last_status = TINFL_STATUS_FAILED;
                return MZ_BUF_ERROR;
            }
            return MZ_STREAM_END;
        }
        /* flush != MZ_FINISH then we must assume there's more input. */
        if (flush != MZ_FINISH)
            decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;

        if (pState->m_dict_avail)
        {
            n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
            memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
            pStream->next_out += n;
            pStream->avail_out -= n;
            pStream->total_out += n;
            pState->m_dict_avail -= n;
            pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
            return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
        }

        for (;;)
        {
            in_bytes = pStream->avail_in;
            out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;

            status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
            pState->m_last_status = status;

            pStream->next_in += (mz_uint)in_bytes;
            pStream->avail_in -= (mz_uint)in_bytes;
            pStream->total_in += (mz_uint)in_bytes;
            pStream->adler = tinfl_get_adler32(&pState->m_decomp);

            pState->m_dict_avail = (mz_uint)out_bytes;

            n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
            memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
            pStream->next_out += n;
            pStream->avail_out -= n;
            pStream->total_out += n;
            pState->m_dict_avail -= n;
            pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);

            if (status < 0)
                return MZ_DATA_ERROR; /* Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well). */
            else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
                return MZ_BUF_ERROR; /* Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH. */
            else if (flush == MZ_FINISH)
            {
                /* The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH. */
                if (status == TINFL_STATUS_DONE)
                    return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
                /* status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong. */
                else if (!pStream->avail_out)
                    return MZ_BUF_ERROR;
            }
            else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))
                break;
        }

        return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
    }

    int mz_inflateEnd(mz_streamp pStream)
    {
        if (!pStream)
            return MZ_STREAM_ERROR;
        if (pStream->state)
        {
            pStream->zfree(pStream->opaque, pStream->state);
            pStream->state = NULL;
        }
        return MZ_OK;
    }
    int mz_uncompress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong *pSource_len)
    {
        mz_stream stream;
        int status;
        memset(&stream, 0, sizeof(stream));

        /* In case mz_ulong is 64-bits (argh I hate longs). */
        if ((mz_uint64)(*pSource_len | *pDest_len) > 0xFFFFFFFFU)
            return MZ_PARAM_ERROR;

        stream.next_in = pSource;
        stream.avail_in = (mz_uint32)*pSource_len;
        stream.next_out = pDest;
        stream.avail_out = (mz_uint32)*pDest_len;

        status = mz_inflateInit(&stream);
        if (status != MZ_OK)
            return status;

        status = mz_inflate(&stream, MZ_FINISH);
        *pSource_len = *pSource_len - stream.avail_in;
        if (status != MZ_STREAM_END)
        {
            mz_inflateEnd(&stream);
            return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR : status;
        }
        *pDest_len = stream.total_out;

        return mz_inflateEnd(&stream);
    }

    int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
    {
        return mz_uncompress2(pDest, pDest_len, pSource, &source_len);
    }

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

    const char *mz_error(int err)
    {
        static struct
        {
            int m_err;
            const char *m_pDesc;
        } s_error_descs[] = {
            { MZ_OK, "" }, { MZ_STREAM_END, "stream end" }, { MZ_NEED_DICT, "need dictionary" }, { MZ_ERRNO, "file error" }, { MZ_STREAM_ERROR, "stream error" }, { MZ_DATA_ERROR, "data error" }, { MZ_MEM_ERROR, "out of memory" }, { MZ_BUF_ERROR, "buf error" }, { MZ_VERSION_ERROR, "version error" }, { MZ_PARAM_ERROR, "parameter error" }
        };
        mz_uint i;
        for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)
            if (s_error_descs[i].m_err == err)
                return s_error_descs[i].m_pDesc;
        return NULL;
    }

#endif /*MINIZ_NO_ZLIB_APIS */

#ifdef __cplusplus
}
#endif

/*
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.

  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
*/

```

`miniz/miniz.h`:

```h
/* miniz.c 3.1.0 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing
   See "unlicense" statement at the end of this file.
   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt

   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define
   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).

   * Low-level Deflate/Inflate implementation notes:

     Compression: Use the "tdefl" API's. The compressor supports raw, static, and dynamic blocks, lazy or
     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses
     approximately as well as zlib.

     Decompression: Use the "tinfl" API's. The entire decompressor is implemented as a single function
     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory
     block large enough to hold the entire file.

     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.

   * zlib-style API notes:

     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in
     zlib replacement in many apps:
        The z_stream struct, optional memory allocation callbacks
        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
        inflateInit/inflateInit2/inflate/inflateReset/inflateEnd
        compress, compress2, compressBound, uncompress
        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.
        Supports raw deflate streams or standard zlib streams with adler-32 checking.

     Limitations:
      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.
      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but
      there are no guarantees that miniz.c pulls this off perfectly.

   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by
     Alex Evans. Supports 1-4 bytes/pixel images.

   * ZIP archive API notes:

     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to
     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from
     existing archives, create new archives, append new files to existing archives, or clone archive data from
     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),
     or you can specify custom file read/write callbacks.

     - Archive reading: Just call this function to read a single file from a disk archive:

      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,
        size_t *pSize, mz_uint zip_flags);

     For more complex cases, use the "mz_zip_reader" functions. Upon opening an archive, the entire central
     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.

     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:

     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);

     The locate operation can optionally check file comments too, which (as one example) can be used to identify
     multiple versions of the same file in an archive. This function uses a simple linear search through the central
     directory, so it's not very fast.

     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and
     retrieve detailed info on each file by calling mz_zip_reader_file_stat().

     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer immediately writes compressed file data
     to disk and builds an exact image of the central directory in memory. The central directory image is written
     all at once at the end of the archive file when the archive is finalized.

     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,
     which can be useful when the archive will be read from optical media. Also, the writer supports placing
     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still
     readable by any ZIP tool.

     - Archive appending: The simple way to add a single file to an archive is to call this function:

      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,
        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

     The archive will be created if it doesn't already exist, otherwise it'll be appended to.
     Note the appending is done in-place and is not an atomic operation, so if something goes wrong
     during the operation it's possible the archive could be left without a central directory (although the local
     file headers and file data will be fine, so the archive will be recoverable).

     For more complex archive modification scenarios:
     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to
     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the
     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and
     you're done. This is safe but requires a bunch of temporary disk space or heap memory.

     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),
     append new files as needed, then finalize the archive which will write an updated central directory to the
     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a
     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.

     - ZIP archive support limitations:
     No spanning support. Extraction functions can only handle unencrypted, stored or deflated files.
     Requires streams capable of seeking.

   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the
     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.

   * Important: For best perf. be sure to customize the below macros for your target platform:
     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
     #define MINIZ_LITTLE_ENDIAN 1
     #define MINIZ_HAS_64BIT_REGISTERS 1

   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before including miniz.c to ensure miniz
     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files
     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
*/
#pragma once

#include "miniz_export.h"

#if defined(__STRICT_ANSI__)
#define MZ_FORCEINLINE
#elif defined(_MSC_VER)
#define MZ_FORCEINLINE __forceinline
#elif defined(__GNUC__)
#define MZ_FORCEINLINE __inline__ __attribute__((__always_inline__))
#else
#define MZ_FORCEINLINE inline
#endif

/* Defines to completely disable specific portions of miniz.c:
   If all macros here are defined the only functionality remaining will be CRC-32 and adler-32. */

/* Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O. */
/*#define MINIZ_NO_STDIO */

/* If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or */
/* get/set file times, and the C run-time funcs that get/set times won't be called. */
/* The current downside is the times written to your archives will be from 1979. */
/*#define MINIZ_NO_TIME */

/* Define MINIZ_NO_DEFLATE_APIS to disable all compression API's. */
/*#define MINIZ_NO_DEFLATE_APIS */

/* Define MINIZ_NO_INFLATE_APIS to disable all decompression API's. */
/*#define MINIZ_NO_INFLATE_APIS */

/* Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's. */
/*#define MINIZ_NO_ARCHIVE_APIS */

/* Define MINIZ_NO_ARCHIVE_WRITING_APIS to disable all writing related ZIP archive API's. */
/*#define MINIZ_NO_ARCHIVE_WRITING_APIS */

/* Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's. */
/*#define MINIZ_NO_ZLIB_APIS */

/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib. */
/*#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES */

/* Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.
   Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc
   callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
   functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work. */
/*#define MINIZ_NO_MALLOC */

#ifdef MINIZ_NO_INFLATE_APIS
#define MINIZ_NO_ARCHIVE_APIS
#endif

#ifdef MINIZ_NO_DEFLATE_APIS
#define MINIZ_NO_ARCHIVE_WRITING_APIS
#endif

#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
/* TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux */
#define MINIZ_NO_TIME
#endif

#include <stddef.h>

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
#include <time.h>
#endif

#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)
/* MINIZ_X86_OR_X64_CPU is only used to help set the below macros. */
#define MINIZ_X86_OR_X64_CPU 1
#else
#define MINIZ_X86_OR_X64_CPU 0
#endif

/* Set MINIZ_LITTLE_ENDIAN only if not set */
#if !defined(MINIZ_LITTLE_ENDIAN)
#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__)

#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
/* Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian. */
#define MINIZ_LITTLE_ENDIAN 1
#else
#define MINIZ_LITTLE_ENDIAN 0
#endif

#else

#if MINIZ_X86_OR_X64_CPU
#define MINIZ_LITTLE_ENDIAN 1
#else
#define MINIZ_LITTLE_ENDIAN 0
#endif

#endif
#endif

/* Using unaligned loads and stores causes errors when using UBSan */
#if defined(__has_feature)
#if __has_feature(undefined_behavior_sanitizer)
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#endif
#endif

/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES only if not set */
#if !defined(MINIZ_USE_UNALIGNED_LOADS_AND_STORES)
#if MINIZ_X86_OR_X64_CPU
/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses. */
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#define MINIZ_UNALIGNED_USE_MEMCPY
#else
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#endif
#endif

#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)
/* Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions). */
#define MINIZ_HAS_64BIT_REGISTERS 1
#else
#define MINIZ_HAS_64BIT_REGISTERS 0
#endif

#ifdef __cplusplus
extern "C"
{
#endif

    /* ------------------- zlib-style API Definitions. */

    /* For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits! */
    typedef unsigned long mz_ulong;

    /* mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap. */
    MINIZ_EXPORT void mz_free(void *p);

#define MZ_ADLER32_INIT (1)
    /* mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL. */
    MINIZ_EXPORT mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);

#define MZ_CRC32_INIT (0)
    /* mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL. */
    MINIZ_EXPORT mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);

    /* Compression strategies. */
    enum
    {
        MZ_DEFAULT_STRATEGY = 0,
        MZ_FILTERED = 1,
        MZ_HUFFMAN_ONLY = 2,
        MZ_RLE = 3,
        MZ_FIXED = 4
    };

/* Method */
#define MZ_DEFLATED 8

    /* Heap allocation callbacks.
    Note that mz_alloc_func parameter types purposely differ from zlib's: items/size is size_t, not unsigned long. */
    typedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);
    typedef void (*mz_free_func)(void *opaque, void *address);
    typedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items, size_t size);

    /* Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL. */
    enum
    {
        MZ_NO_COMPRESSION = 0,
        MZ_BEST_SPEED = 1,
        MZ_BEST_COMPRESSION = 9,
        MZ_UBER_COMPRESSION = 10,
        MZ_DEFAULT_LEVEL = 6,
        MZ_DEFAULT_COMPRESSION = -1
    };

#define MZ_VERSION "11.3.1"
#define MZ_VERNUM 0xB301
#define MZ_VER_MAJOR 11
#define MZ_VER_MINOR 3
#define MZ_VER_REVISION 1
#define MZ_VER_SUBREVISION 0

#ifndef MINIZ_NO_ZLIB_APIS

    /* Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs). */
    enum
    {
        MZ_NO_FLUSH = 0,
        MZ_PARTIAL_FLUSH = 1,
        MZ_SYNC_FLUSH = 2,
        MZ_FULL_FLUSH = 3,
        MZ_FINISH = 4,
        MZ_BLOCK = 5
    };

    /* Return status codes. MZ_PARAM_ERROR is non-standard. */
    enum
    {
        MZ_OK = 0,
        MZ_STREAM_END = 1,
        MZ_NEED_DICT = 2,
        MZ_ERRNO = -1,
        MZ_STREAM_ERROR = -2,
        MZ_DATA_ERROR = -3,
        MZ_MEM_ERROR = -4,
        MZ_BUF_ERROR = -5,
        MZ_VERSION_ERROR = -6,
        MZ_PARAM_ERROR = -10000
    };

/* Window bits */
#define MZ_DEFAULT_WINDOW_BITS 15

    struct mz_internal_state;

    /* Compression/decompression stream struct. */
    typedef struct mz_stream_s
    {
        const unsigned char *next_in; /* pointer to next byte to read */
        unsigned int avail_in;        /* number of bytes available at next_in */
        mz_ulong total_in;            /* total number of bytes consumed so far */

        unsigned char *next_out; /* pointer to next byte to write */
        unsigned int avail_out;  /* number of bytes that can be written to next_out */
        mz_ulong total_out;      /* total number of bytes produced so far */

        char *msg;                       /* error msg (unused) */
        struct mz_internal_state *state; /* internal state, allocated by zalloc/zfree */

        mz_alloc_func zalloc; /* optional heap allocation function (defaults to malloc) */
        mz_free_func zfree;   /* optional heap free function (defaults to free) */
        void *opaque;         /* heap alloc function user pointer */

        int data_type;     /* data_type (unused) */
        mz_ulong adler;    /* adler32 of the source or uncompressed data */
        mz_ulong reserved; /* not used */
    } mz_stream;

    typedef mz_stream *mz_streamp;

    /* Returns the version string of miniz.c. */
    MINIZ_EXPORT const char *mz_version(void);

#ifndef MINIZ_NO_DEFLATE_APIS

    /* mz_deflateInit() initializes a compressor with default options: */
    /* Parameters: */
    /*  pStream must point to an initialized mz_stream struct. */
    /*  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION]. */
    /*  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio. */
    /*  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.) */
    /* Return values: */
    /*  MZ_OK on success. */
    /*  MZ_STREAM_ERROR if the stream is bogus. */
    /*  MZ_PARAM_ERROR if the input parameters are bogus. */
    /*  MZ_MEM_ERROR on out of memory. */
    MINIZ_EXPORT int mz_deflateInit(mz_streamp pStream, int level);

    /* mz_deflateInit2() is like mz_deflate(), except with more control: */
    /* Additional parameters: */
    /*   method must be MZ_DEFLATED */
    /*   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer) */
    /*   mem_level must be between [1, 9] (it's checked but ignored by miniz.c) */
    MINIZ_EXPORT int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);

    /* Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2(). */
    MINIZ_EXPORT int mz_deflateReset(mz_streamp pStream);

    /* mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible. */
    /* Parameters: */
    /*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */
    /*   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH. */
    /* Return values: */
    /*   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full). */
    /*   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore. */
    /*   MZ_STREAM_ERROR if the stream is bogus. */
    /*   MZ_PARAM_ERROR if one of the parameters is invalid. */
    /*   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.) */
    MINIZ_EXPORT int mz_deflate(mz_streamp pStream, int flush);

    /* mz_deflateEnd() deinitializes a compressor: */
    /* Return values: */
    /*  MZ_OK on success. */
    /*  MZ_STREAM_ERROR if the stream is bogus. */
    MINIZ_EXPORT int mz_deflateEnd(mz_streamp pStream);

    /* mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH. */
    MINIZ_EXPORT mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);

    /* Single-call compression functions mz_compress() and mz_compress2(): */
    /* Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure. */
    MINIZ_EXPORT int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
    MINIZ_EXPORT int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level);

    /* mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress(). */
    MINIZ_EXPORT mz_ulong mz_compressBound(mz_ulong source_len);

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS

    /* Initializes a decompressor. */
    MINIZ_EXPORT int mz_inflateInit(mz_streamp pStream);

    /* mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer: */
    /* window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate). */
    MINIZ_EXPORT int mz_inflateInit2(mz_streamp pStream, int window_bits);

    /* Quickly resets a compressor without having to reallocate anything. Same as calling mz_inflateEnd() followed by mz_inflateInit()/mz_inflateInit2(). */
    MINIZ_EXPORT int mz_inflateReset(mz_streamp pStream);

    /* Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible. */
    /* Parameters: */
    /*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */
    /*   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH. */
    /*   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster). */
    /*   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data. */
    /* Return values: */
    /*   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full. */
    /*   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified. */
    /*   MZ_STREAM_ERROR if the stream is bogus. */
    /*   MZ_DATA_ERROR if the deflate stream is invalid. */
    /*   MZ_PARAM_ERROR if one of the parameters is invalid. */
    /*   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again */
    /*   with more input data, or with more room in the output buffer (except when using single call decompression, described above). */
    MINIZ_EXPORT int mz_inflate(mz_streamp pStream, int flush);

    /* Deinitializes a decompressor. */
    MINIZ_EXPORT int mz_inflateEnd(mz_streamp pStream);

    /* Single-call decompression. */
    /* Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure. */
    MINIZ_EXPORT int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
    MINIZ_EXPORT int mz_uncompress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong *pSource_len);
#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

    /* Returns a string description of the specified error code, or NULL if the error code is invalid. */
    MINIZ_EXPORT const char *mz_error(int err);

/* Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports. */
/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project. */
#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
    typedef unsigned char Byte;
    typedef unsigned int uInt;
    typedef mz_ulong uLong;
    typedef Byte Bytef;
    typedef uInt uIntf;
    typedef char charf;
    typedef int intf;
    typedef void *voidpf;
    typedef uLong uLongf;
    typedef void *voidp;
    typedef void *const voidpc;
#define Z_NULL 0
#define Z_NO_FLUSH MZ_NO_FLUSH
#define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH
#define Z_SYNC_FLUSH MZ_SYNC_FLUSH
#define Z_FULL_FLUSH MZ_FULL_FLUSH
#define Z_FINISH MZ_FINISH
#define Z_BLOCK MZ_BLOCK
#define Z_OK MZ_OK
#define Z_STREAM_END MZ_STREAM_END
#define Z_NEED_DICT MZ_NEED_DICT
#define Z_ERRNO MZ_ERRNO
#define Z_STREAM_ERROR MZ_STREAM_ERROR
#define Z_DATA_ERROR MZ_DATA_ERROR
#define Z_MEM_ERROR MZ_MEM_ERROR
#define Z_BUF_ERROR MZ_BUF_ERROR
#define Z_VERSION_ERROR MZ_VERSION_ERROR
#define Z_PARAM_ERROR MZ_PARAM_ERROR
#define Z_NO_COMPRESSION MZ_NO_COMPRESSION
#define Z_BEST_SPEED MZ_BEST_SPEED
#define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION
#define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
#define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY
#define Z_FILTERED MZ_FILTERED
#define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY
#define Z_RLE MZ_RLE
#define Z_FIXED MZ_FIXED
#define Z_DEFLATED MZ_DEFLATED
#define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
    /* See mz_alloc_func */
    typedef void *(*alloc_func)(void *opaque, size_t items, size_t size);
    /* See mz_free_func */
    typedef void (*free_func)(void *opaque, void *address);

#define internal_state mz_internal_state
#define z_stream mz_stream

#ifndef MINIZ_NO_DEFLATE_APIS
    /* Compatiblity with zlib API. See called functions for documentation */
    static MZ_FORCEINLINE int deflateInit(mz_streamp pStream, int level)
    {
        return mz_deflateInit(pStream, level);
    }
    static MZ_FORCEINLINE int deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
    {
        return mz_deflateInit2(pStream, level, method, window_bits, mem_level, strategy);
    }
    static MZ_FORCEINLINE int deflateReset(mz_streamp pStream)
    {
        return mz_deflateReset(pStream);
    }
    static MZ_FORCEINLINE int deflate(mz_streamp pStream, int flush)
    {
        return mz_deflate(pStream, flush);
    }
    static MZ_FORCEINLINE int deflateEnd(mz_streamp pStream)
    {
        return mz_deflateEnd(pStream);
    }
    static MZ_FORCEINLINE mz_ulong deflateBound(mz_streamp pStream, mz_ulong source_len)
    {
        return mz_deflateBound(pStream, source_len);
    }
    static MZ_FORCEINLINE int compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
    {
        return mz_compress(pDest, pDest_len, pSource, source_len);
    }
    static MZ_FORCEINLINE int compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level)
    {
        return mz_compress2(pDest, pDest_len, pSource, source_len, level);
    }
    static MZ_FORCEINLINE mz_ulong compressBound(mz_ulong source_len)
    {
        return mz_compressBound(source_len);
    }
#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS
    /* Compatiblity with zlib API. See called functions for documentation */
    static MZ_FORCEINLINE int inflateInit(mz_streamp pStream)
    {
        return mz_inflateInit(pStream);
    }

    static MZ_FORCEINLINE int inflateInit2(mz_streamp pStream, int window_bits)
    {
        return mz_inflateInit2(pStream, window_bits);
    }

    static MZ_FORCEINLINE int inflateReset(mz_streamp pStream)
    {
        return mz_inflateReset(pStream);
    }

    static MZ_FORCEINLINE int inflate(mz_streamp pStream, int flush)
    {
        return mz_inflate(pStream, flush);
    }

    static MZ_FORCEINLINE int inflateEnd(mz_streamp pStream)
    {
        return mz_inflateEnd(pStream);
    }

    static MZ_FORCEINLINE int uncompress(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len)
    {
        return mz_uncompress(pDest, pDest_len, pSource, source_len);
    }

    static MZ_FORCEINLINE int uncompress2(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong* pSource_len)
    {
        return mz_uncompress2(pDest, pDest_len, pSource, pSource_len);
    }
#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

    static MZ_FORCEINLINE mz_ulong crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len)
    {
        return mz_crc32(crc, ptr, buf_len);
    }

    static MZ_FORCEINLINE mz_ulong adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)
    {
        return mz_adler32(adler, ptr, buf_len);
    }
    
#define MAX_WBITS 15
#define MAX_MEM_LEVEL 9

    static MZ_FORCEINLINE const char* zError(int err)
    {
        return mz_error(err);
    }
#define ZLIB_VERSION MZ_VERSION
#define ZLIB_VERNUM MZ_VERNUM
#define ZLIB_VER_MAJOR MZ_VER_MAJOR
#define ZLIB_VER_MINOR MZ_VER_MINOR
#define ZLIB_VER_REVISION MZ_VER_REVISION
#define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION

#define zlibVersion mz_version
#define zlib_version mz_version()
#endif /* #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES */

#endif /* MINIZ_NO_ZLIB_APIS */

#ifdef __cplusplus
}
#endif

#include "miniz_common.h"
#include "miniz_tdef.h"
#include "miniz_tinfl.h"
#include "miniz_zip.h"

```

`miniz/miniz_common.h`:

```h
#pragma once
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "miniz_export.h"

/* ------------------- Types and macros */
typedef unsigned char mz_uint8;
typedef int16_t mz_int16;
typedef uint16_t mz_uint16;
typedef uint32_t mz_uint32;
typedef uint32_t mz_uint;
typedef int64_t mz_int64;
typedef uint64_t mz_uint64;
typedef int mz_bool;

#define MZ_FALSE (0)
#define MZ_TRUE (1)

/* Works around MSVC's spammy "warning C4127: conditional expression is constant" message. */
#ifdef _MSC_VER
#define MZ_MACRO_END while (0, 0)
#else
#define MZ_MACRO_END while (0)
#endif

#ifdef MINIZ_NO_STDIO
#define MZ_FILE void *
#else
#include <stdio.h>
#define MZ_FILE FILE
#endif /* #ifdef MINIZ_NO_STDIO */

#ifdef MINIZ_NO_TIME
typedef struct mz_dummy_time_t_tag
{
    mz_uint32 m_dummy1;
    mz_uint32 m_dummy2;
} mz_dummy_time_t;
#define MZ_TIME_T mz_dummy_time_t
#else
#define MZ_TIME_T time_t
#endif

#define MZ_ASSERT(x) assert(x)

#ifdef MINIZ_NO_MALLOC
#define MZ_MALLOC(x) NULL
#define MZ_FREE(x) (void)x, ((void)0)
#define MZ_REALLOC(p, x) NULL
#else
#define MZ_MALLOC(x) malloc(x)
#define MZ_FREE(x) free(x)
#define MZ_REALLOC(p, x) realloc(p, x)
#endif

#define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))
#define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))
#define MZ_CLEAR_ARR(obj) memset((obj), 0, sizeof(obj))
#define MZ_CLEAR_PTR(obj) memset((obj), 0, sizeof(*obj))

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))
#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))
#else
#define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))
#define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))
#endif

#define MZ_READ_LE64(p) (((mz_uint64)MZ_READ_LE32(p)) | (((mz_uint64)MZ_READ_LE32((const mz_uint8 *)(p) + sizeof(mz_uint32))) << 32U))

#ifdef __cplusplus
extern "C"
{
#endif

    extern MINIZ_EXPORT void *miniz_def_alloc_func(void *opaque, size_t items, size_t size);
    extern MINIZ_EXPORT void miniz_def_free_func(void *opaque, void *address);
    extern MINIZ_EXPORT void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size);

#define MZ_UINT16_MAX (0xFFFFU)
#define MZ_UINT32_MAX (0xFFFFFFFFU)

#ifdef __cplusplus
}
#endif

```

`miniz/miniz_export.h`:

```h
#pragma once

// miniz_export.h - Normally generated by CMake.
// For static compilation, MINIZ_EXPORT is empty.
#ifndef MINIZ_EXPORT
#define MINIZ_EXPORT
#endif

```

`miniz/miniz_tdef.c`:

```c
/**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/

#include "miniz.h"

#ifndef MINIZ_NO_DEFLATE_APIS

#ifdef __cplusplus
extern "C"
{
#endif

    /* ------------------- Low-level Compression (independent from all decompression API's) */

    /* Purposely making these tables static for faster init and thread safety. */
    static const mz_uint16 s_tdefl_len_sym[256] = {
        257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272,
        273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276,
        277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
        279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,
        281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
        282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
        283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
        284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285
    };

    static const mz_uint8 s_tdefl_len_extra[256] = {
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0
    };

    static const mz_uint8 s_tdefl_small_dist_sym[512] = {
        0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13,
        13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
        14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
        14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
        17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
        17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
        17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17
    };

    static const mz_uint8 s_tdefl_small_dist_extra[512] = {
        0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7
    };

    static const mz_uint8 s_tdefl_large_dist_sym[128] = {
        0, 0, 18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
        26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
        28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
    };

    static const mz_uint8 s_tdefl_large_dist_extra[128] = {
        0, 0, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
        12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
        13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13
    };

    /* Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values. */
    typedef struct
    {
        mz_uint16 m_key, m_sym_index;
    } tdefl_sym_freq;
    static tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq *pSyms0, tdefl_sym_freq *pSyms1)
    {
        mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2];
        tdefl_sym_freq *pCur_syms = pSyms0, *pNew_syms = pSyms1;
        MZ_CLEAR_ARR(hist);
        for (i = 0; i < num_syms; i++)
        {
            mz_uint freq = pSyms0[i].m_key;
            hist[freq & 0xFF]++;
            hist[256 + ((freq >> 8) & 0xFF)]++;
        }
        while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))
            total_passes--;
        for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)
        {
            const mz_uint32 *pHist = &hist[pass << 8];
            mz_uint offsets[256], cur_ofs = 0;
            for (i = 0; i < 256; i++)
            {
                offsets[i] = cur_ofs;
                cur_ofs += pHist[i];
            }
            for (i = 0; i < num_syms; i++)
                pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
            {
                tdefl_sym_freq *t = pCur_syms;
                pCur_syms = pNew_syms;
                pNew_syms = t;
            }
        }
        return pCur_syms;
    }

    /* tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996. */
    static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)
    {
        int root, leaf, next, avbl, used, dpth;
        if (n == 0)
            return;
        else if (n == 1)
        {
            A[0].m_key = 1;
            return;
        }
        A[0].m_key += A[1].m_key;
        root = 0;
        leaf = 2;
        for (next = 1; next < n - 1; next++)
        {
            if (leaf >= n || A[root].m_key < A[leaf].m_key)
            {
                A[next].m_key = A[root].m_key;
                A[root++].m_key = (mz_uint16)next;
            }
            else
                A[next].m_key = A[leaf++].m_key;
            if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key))
            {
                A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);
                A[root++].m_key = (mz_uint16)next;
            }
            else
                A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
        }
        A[n - 2].m_key = 0;
        for (next = n - 3; next >= 0; next--)
            A[next].m_key = A[A[next].m_key].m_key + 1;
        avbl = 1;
        used = dpth = 0;
        root = n - 2;
        next = n - 1;
        while (avbl > 0)
        {
            while (root >= 0 && (int)A[root].m_key == dpth)
            {
                used++;
                root--;
            }
            while (avbl > used)
            {
                A[next--].m_key = (mz_uint16)(dpth);
                avbl--;
            }
            avbl = 2 * used;
            dpth++;
            used = 0;
        }
    }

    /* Limits canonical Huffman code table's max code size. */
    enum
    {
        TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32
    };
    static void tdefl_huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)
    {
        int i;
        mz_uint32 total = 0;
        if (code_list_len <= 1)
            return;
        for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++)
            pNum_codes[max_code_size] += pNum_codes[i];
        for (i = max_code_size; i > 0; i--)
            total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
        while (total != (1UL << max_code_size))
        {
            pNum_codes[max_code_size]--;
            for (i = max_code_size - 1; i > 0; i--)
                if (pNum_codes[i])
                {
                    pNum_codes[i]--;
                    pNum_codes[i + 1] += 2;
                    break;
                }
            total--;
        }
    }

    static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num, int table_len, int code_size_limit, int static_table)
    {
        int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
        mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
        MZ_CLEAR_ARR(num_codes);
        if (static_table)
        {
            for (i = 0; i < table_len; i++)
                num_codes[d->m_huff_code_sizes[table_num][i]]++;
        }
        else
        {
            tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;
            int num_used_syms = 0;
            const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];
            for (i = 0; i < table_len; i++)
                if (pSym_count[i])
                {
                    syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i];
                    syms0[num_used_syms++].m_sym_index = (mz_uint16)i;
                }

            pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1);
            tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);

            for (i = 0; i < num_used_syms; i++)
                num_codes[pSyms[i].m_key]++;

            tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);

            MZ_CLEAR_ARR(d->m_huff_code_sizes[table_num]);
            MZ_CLEAR_ARR(d->m_huff_codes[table_num]);
            for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
                for (l = num_codes[i]; l > 0; l--)
                    d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
        }

        next_code[1] = 0;
        for (j = 0, i = 2; i <= code_size_limit; i++)
            next_code[i] = j = ((j + num_codes[i - 1]) << 1);

        for (i = 0; i < table_len; i++)
        {
            mz_uint rev_code = 0, code, code_size;
            if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0)
                continue;
            code = next_code[code_size]++;
            for (l = code_size; l > 0; l--, code >>= 1)
                rev_code = (rev_code << 1) | (code & 1);
            d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
        }
    }

#define TDEFL_PUT_BITS(b, l)                                       \
    do                                                             \
    {                                                              \
        mz_uint bits = b;                                          \
        mz_uint len = l;                                           \
        MZ_ASSERT(bits <= ((1U << len) - 1U));                     \
        d->m_bit_buffer |= (bits << d->m_bits_in);                 \
        d->m_bits_in += len;                                       \
        while (d->m_bits_in >= 8)                                  \
        {                                                          \
            if (d->m_pOutput_buf < d->m_pOutput_buf_end)           \
                *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \
            d->m_bit_buffer >>= 8;                                 \
            d->m_bits_in -= 8;                                     \
        }                                                          \
    }                                                              \
    MZ_MACRO_END

#define TDEFL_RLE_PREV_CODE_SIZE()                                                                                       \
    {                                                                                                                    \
        if (rle_repeat_count)                                                                                            \
        {                                                                                                                \
            if (rle_repeat_count < 3)                                                                                    \
            {                                                                                                            \
                d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
                while (rle_repeat_count--)                                                                               \
                    packed_code_sizes[num_packed_code_sizes++] = prev_code_size;                                         \
            }                                                                                                            \
            else                                                                                                         \
            {                                                                                                            \
                d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1);                                        \
                packed_code_sizes[num_packed_code_sizes++] = 16;                                                         \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3);                           \
            }                                                                                                            \
            rle_repeat_count = 0;                                                                                        \
        }                                                                                                                \
    }

#define TDEFL_RLE_ZERO_CODE_SIZE()                                                         \
    {                                                                                      \
        if (rle_z_count)                                                                   \
        {                                                                                  \
            if (rle_z_count < 3)                                                           \
            {                                                                              \
                d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count);  \
                while (rle_z_count--)                                                      \
                    packed_code_sizes[num_packed_code_sizes++] = 0;                        \
            }                                                                              \
            else if (rle_z_count <= 10)                                                    \
            {                                                                              \
                d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1);          \
                packed_code_sizes[num_packed_code_sizes++] = 17;                           \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3);  \
            }                                                                              \
            else                                                                           \
            {                                                                              \
                d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1);          \
                packed_code_sizes[num_packed_code_sizes++] = 18;                           \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \
            }                                                                              \
            rle_z_count = 0;                                                               \
        }                                                                                  \
    }

    static const mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

    static void tdefl_start_dynamic_block(tdefl_compressor *d)
    {
        int num_lit_codes, num_dist_codes, num_bit_lengths;
        mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;
        mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;

        d->m_huff_count[0][256] = 1;

        tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
        tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);

        for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--)
            if (d->m_huff_code_sizes[0][num_lit_codes - 1])
                break;
        for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--)
            if (d->m_huff_code_sizes[1][num_dist_codes - 1])
                break;

        memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
        memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);
        total_code_sizes_to_pack = num_lit_codes + num_dist_codes;
        num_packed_code_sizes = 0;
        rle_z_count = 0;
        rle_repeat_count = 0;

        memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
        for (i = 0; i < total_code_sizes_to_pack; i++)
        {
            mz_uint8 code_size = code_sizes_to_pack[i];
            if (!code_size)
            {
                TDEFL_RLE_PREV_CODE_SIZE();
                if (++rle_z_count == 138)
                {
                    TDEFL_RLE_ZERO_CODE_SIZE();
                }
            }
            else
            {
                TDEFL_RLE_ZERO_CODE_SIZE();
                if (code_size != prev_code_size)
                {
                    TDEFL_RLE_PREV_CODE_SIZE();
                    d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1);
                    packed_code_sizes[num_packed_code_sizes++] = code_size;
                }
                else if (++rle_repeat_count == 6)
                {
                    TDEFL_RLE_PREV_CODE_SIZE();
                }
            }
            prev_code_size = code_size;
        }
        if (rle_repeat_count)
        {
            TDEFL_RLE_PREV_CODE_SIZE();
        }
        else
        {
            TDEFL_RLE_ZERO_CODE_SIZE();
        }

        tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);

        TDEFL_PUT_BITS(2, 2);

        TDEFL_PUT_BITS(num_lit_codes - 257, 5);
        TDEFL_PUT_BITS(num_dist_codes - 1, 5);

        for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--)
            if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]])
                break;
        num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1));
        TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
        for (i = 0; (int)i < num_bit_lengths; i++)
            TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);

        for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes;)
        {
            mz_uint code = packed_code_sizes[packed_code_sizes_index++];
            MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
            TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
            if (code >= 16)
                TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], "\02\03\07"[code - 16]);
        }
    }

    static void tdefl_start_static_block(tdefl_compressor *d)
    {
        mz_uint i;
        mz_uint8 *p = &d->m_huff_code_sizes[0][0];

        for (i = 0; i <= 143; ++i)
            *p++ = 8;
        for (; i <= 255; ++i)
            *p++ = 9;
        for (; i <= 279; ++i)
            *p++ = 7;
        for (; i <= 287; ++i)
            *p++ = 8;

        memset(d->m_huff_code_sizes[1], 5, 32);

        tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
        tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);

        TDEFL_PUT_BITS(1, 2);
    }

    static const mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
    static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
    {
        mz_uint flags;
        mz_uint8 *pLZ_codes;
        mz_uint8 *pOutput_buf = d->m_pOutput_buf;
        mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
        mz_uint64 bit_buffer = d->m_bit_buffer;
        mz_uint bits_in = d->m_bits_in;

#define TDEFL_PUT_BITS_FAST(b, l)                    \
    {                                                \
        bit_buffer |= (((mz_uint64)(b)) << bits_in); \
        bits_in += (l);                              \
    }

        flags = 1;
        for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1)
        {
            if (flags == 1)
                flags = *pLZ_codes++ | 0x100;

            if (flags & 1)
            {
                mz_uint s0, s1, n0, n1, sym, num_extra_bits;
                mz_uint match_len = pLZ_codes[0];
                mz_uint match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
                pLZ_codes += 3;

                MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
                TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
                TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

                /* This sequence coaxes MSVC into using cmov's vs. jmp's. */
                s0 = s_tdefl_small_dist_sym[match_dist & 511];
                n0 = s_tdefl_small_dist_extra[match_dist & 511];
                s1 = s_tdefl_large_dist_sym[match_dist >> 8];
                n1 = s_tdefl_large_dist_extra[match_dist >> 8];
                sym = (match_dist < 512) ? s0 : s1;
                num_extra_bits = (match_dist < 512) ? n0 : n1;

                MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
                TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
                TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
            }
            else
            {
                mz_uint lit = *pLZ_codes++;
                MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
                TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

                if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
                {
                    flags >>= 1;
                    lit = *pLZ_codes++;
                    MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
                    TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

                    if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
                    {
                        flags >>= 1;
                        lit = *pLZ_codes++;
                        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
                        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
                    }
                }
            }

            if (pOutput_buf >= d->m_pOutput_buf_end)
                return MZ_FALSE;

            memcpy(pOutput_buf, &bit_buffer, sizeof(mz_uint64));
            pOutput_buf += (bits_in >> 3);
            bit_buffer >>= (bits_in & ~7);
            bits_in &= 7;
        }

#undef TDEFL_PUT_BITS_FAST

        d->m_pOutput_buf = pOutput_buf;
        d->m_bits_in = 0;
        d->m_bit_buffer = 0;

        while (bits_in)
        {
            mz_uint32 n = MZ_MIN(bits_in, 16);
            TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
            bit_buffer >>= n;
            bits_in -= n;
        }

        TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

        return (d->m_pOutput_buf < d->m_pOutput_buf_end);
    }
#else
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
    mz_uint flags;
    mz_uint8 *pLZ_codes;

    flags = 1;
    for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1)
    {
        if (flags == 1)
            flags = *pLZ_codes++ | 0x100;
        if (flags & 1)
        {
            mz_uint sym, num_extra_bits;
            mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
            pLZ_codes += 3;

            MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

            if (match_dist < 512)
            {
                sym = s_tdefl_small_dist_sym[match_dist];
                num_extra_bits = s_tdefl_small_dist_extra[match_dist];
            }
            else
            {
                sym = s_tdefl_large_dist_sym[match_dist >> 8];
                num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
            }
            MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
        }
        else
        {
            mz_uint lit = *pLZ_codes++;
            MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
            TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
        }
    }

    TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

    return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#endif /* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS */

    static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)
    {
        if (static_block)
            tdefl_start_static_block(d);
        else
            tdefl_start_dynamic_block(d);
        return tdefl_compress_lz_codes(d);
    }

    static const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };

    static int tdefl_flush_block(tdefl_compressor *d, int flush)
    {
        mz_uint saved_bit_buf, saved_bits_in;
        mz_uint8 *pSaved_output_buf;
        mz_bool comp_block_succeeded = MZ_FALSE;
        int n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
        mz_uint8 *pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs) : d->m_output_buf;

        d->m_pOutput_buf = pOutput_buf_start;
        d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;

        MZ_ASSERT(!d->m_output_flush_remaining);
        d->m_output_flush_ofs = 0;
        d->m_output_flush_remaining = 0;

        *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
        d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);

        if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index))
        {
            const mz_uint8 cmf = 0x78;
            mz_uint8 flg, flevel = 3;
            mz_uint header, i, mz_un = sizeof(s_tdefl_num_probes) / sizeof(mz_uint);

            /* Determine compression level by reversing the process in tdefl_create_comp_flags_from_zip_params() */
            for (i = 0; i < mz_un; i++)
                if (s_tdefl_num_probes[i] == (d->m_flags & 0xFFF))
                    break;

            if (i < 2)
                flevel = 0;
            else if (i < 6)
                flevel = 1;
            else if (i == 6)
                flevel = 2;

            header = cmf << 8 | (flevel << 6);
            header += 31 - (header % 31);
            flg = header & 0xFF;

            TDEFL_PUT_BITS(cmf, 8);
            TDEFL_PUT_BITS(flg, 8);
        }

        TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);

        pSaved_output_buf = d->m_pOutput_buf;
        saved_bit_buf = d->m_bit_buffer;
        saved_bits_in = d->m_bits_in;

        if (!use_raw_block)
            comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));

        /* If the block gets expanded, forget the current contents of the output buffer and send a raw block instead. */
        if (((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes))) &&
            ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size))
        {
            mz_uint i;
            d->m_pOutput_buf = pSaved_output_buf;
            d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
            TDEFL_PUT_BITS(0, 2);
            if (d->m_bits_in)
            {
                TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
            }
            for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF)
            {
                TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
            }
            for (i = 0; i < d->m_total_lz_bytes; ++i)
            {
                TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);
            }
        }
        /* Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes. */
        else if (!comp_block_succeeded)
        {
            d->m_pOutput_buf = pSaved_output_buf;
            d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
            tdefl_compress_block(d, MZ_TRUE);
        }

        if (flush)
        {
            if (flush == TDEFL_FINISH)
            {
                if (d->m_bits_in)
                {
                    TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
                }
                if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER)
                {
                    mz_uint i, a = d->m_adler32;
                    for (i = 0; i < 4; i++)
                    {
                        TDEFL_PUT_BITS((a >> 24) & 0xFF, 8);
                        a <<= 8;
                    }
                }
            }
            else
            {
                mz_uint i, z = 0;
                TDEFL_PUT_BITS(0, 3);
                if (d->m_bits_in)
                {
                    TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
                }
                for (i = 2; i; --i, z ^= 0xFFFF)
                {
                    TDEFL_PUT_BITS(z & 0xFFFF, 16);
                }
            }
        }

        MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);

        memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
        memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);

        d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
        d->m_pLZ_flags = d->m_lz_code_buf;
        d->m_num_flags_left = 8;
        d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
        d->m_total_lz_bytes = 0;
        d->m_block_index++;

        if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0)
        {
            if (d->m_pPut_buf_func)
            {
                *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
                if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))
                    return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
            }
            else if (pOutput_buf_start == d->m_output_buf)
            {
                int bytes_to_copy = (int)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
                memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);
                d->m_out_buf_ofs += bytes_to_copy;
                if ((n -= bytes_to_copy) != 0)
                {
                    d->m_output_flush_ofs = bytes_to_copy;
                    d->m_output_flush_remaining = n;
                }
            }
            else
            {
                d->m_out_buf_ofs += n;
            }
        }

        return d->m_output_flush_remaining;
    }

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
    static mz_uint16 TDEFL_READ_UNALIGNED_WORD(const mz_uint8 *p)
    {
        mz_uint16 ret;
        memcpy(&ret, p, sizeof(mz_uint16));
        return ret;
    }
    static mz_uint16 TDEFL_READ_UNALIGNED_WORD2(const mz_uint16 *p)
    {
        mz_uint16 ret;
        memcpy(&ret, p, sizeof(mz_uint16));
        return ret;
    }
#else
#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16 *)(p)
#define TDEFL_READ_UNALIGNED_WORD2(p) *(const mz_uint16 *)(p)
#endif
    static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
    {
        mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
        mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
        const mz_uint16 *s = (const mz_uint16 *)(d->m_dict + pos), *p, *q;
        mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD2(s);
        MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
        if (max_match_len <= match_len)
            return;
        for (;;)
        {
            for (;;)
            {
                if (--num_probes_left == 0)
                    return;
#define TDEFL_PROBE                                                                             \
    next_probe_pos = d->m_next[probe_pos];                                                      \
    if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) \
        return;                                                                                 \
    probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                       \
    if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01)                \
        break;
                TDEFL_PROBE;
                TDEFL_PROBE;
                TDEFL_PROBE;
            }
            if (!dist)
                break;
            q = (const mz_uint16 *)(d->m_dict + probe_pos);
            if (TDEFL_READ_UNALIGNED_WORD2(q) != s01)
                continue;
            p = s;
            probe_len = 32;
            do
            {
            } while ((TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) &&
                     (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (--probe_len > 0));
            if (!probe_len)
            {
                *pMatch_dist = dist;
                *pMatch_len = MZ_MIN(max_match_len, (mz_uint)TDEFL_MAX_MATCH_LEN);
                break;
            }
            else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q)) > match_len)
            {
                *pMatch_dist = dist;
                if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len)
                    break;
                c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
            }
        }
    }
#else
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
    mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
    mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
    const mz_uint8 *s = d->m_dict + pos, *p, *q;
    mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
    MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
    if (max_match_len <= match_len)
        return;
    for (;;)
    {
        for (;;)
        {
            if (--num_probes_left == 0)
                return;
#define TDEFL_PROBE                                                                               \
    next_probe_pos = d->m_next[probe_pos];                                                        \
    if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))   \
        return;                                                                                   \
    probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                         \
    if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) \
        break;
            TDEFL_PROBE;
            TDEFL_PROBE;
            TDEFL_PROBE;
        }
        if (!dist)
            break;
        p = s;
        q = d->m_dict + probe_pos;
        for (probe_len = 0; probe_len < max_match_len; probe_len++)
            if (*p++ != *q++)
                break;
        if (probe_len > match_len)
        {
            *pMatch_dist = dist;
            if ((*pMatch_len = match_len = probe_len) == max_match_len)
                return;
            c0 = d->m_dict[pos + match_len];
            c1 = d->m_dict[pos + match_len - 1];
        }
    }
}
#endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES */

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
    static mz_uint32 TDEFL_READ_UNALIGNED_WORD32(const mz_uint8 *p)
    {
        mz_uint32 ret;
        memcpy(&ret, p, sizeof(mz_uint32));
        return ret;
    }
#else
#define TDEFL_READ_UNALIGNED_WORD32(p) *(const mz_uint32 *)(p)
#endif
    static mz_bool tdefl_compress_fast(tdefl_compressor *d)
    {
        /* Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio. */
        mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
        mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
        mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;

        while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))
        {
            const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
            mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
            mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
            d->m_src_buf_left -= num_bytes_to_process;
            lookahead_size += num_bytes_to_process;

            while (num_bytes_to_process)
            {
                mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
                memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
                if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                    memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
                d->m_pSrc += n;
                dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
                num_bytes_to_process -= n;
            }

            dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
            if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE))
                break;

            while (lookahead_size >= 4)
            {
                mz_uint cur_match_dist, cur_match_len = 1;
                mz_uint8 *pCur_dict = d->m_dict + cur_pos;
                mz_uint first_trigram = TDEFL_READ_UNALIGNED_WORD32(pCur_dict) & 0xFFFFFF;
                mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
                mz_uint probe_pos = d->m_hash[hash];
                d->m_hash[hash] = (mz_uint16)lookahead_pos;

                if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((TDEFL_READ_UNALIGNED_WORD32(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))
                {
                    const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
                    const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
                    mz_uint32 probe_len = 32;
                    do
                    {
                    } while ((TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) &&
                             (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (--probe_len > 0));
                    cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
                    if (!probe_len)
                        cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;

                    if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)))
                    {
                        cur_match_len = 1;
                        *pLZ_code_buf++ = (mz_uint8)first_trigram;
                        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
                        d->m_huff_count[0][(mz_uint8)first_trigram]++;
                    }
                    else
                    {
                        mz_uint32 s0, s1;
                        cur_match_len = MZ_MIN(cur_match_len, lookahead_size);

                        MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));

                        cur_match_dist--;

                        pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
                        memcpy(&pLZ_code_buf[1], &cur_match_dist, sizeof(cur_match_dist));
#else
                        *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
#endif
                        pLZ_code_buf += 3;
                        *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);

                        s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
                        s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
                        d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;

                        d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
                    }
                }
                else
                {
                    *pLZ_code_buf++ = (mz_uint8)first_trigram;
                    *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
                    d->m_huff_count[0][(mz_uint8)first_trigram]++;
                }

                if (--num_flags_left == 0)
                {
                    num_flags_left = 8;
                    pLZ_flags = pLZ_code_buf++;
                }

                total_lz_bytes += cur_match_len;
                lookahead_pos += cur_match_len;
                dict_size = MZ_MIN(dict_size + cur_match_len, (mz_uint)TDEFL_LZ_DICT_SIZE);
                cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
                MZ_ASSERT(lookahead_size >= cur_match_len);
                lookahead_size -= cur_match_len;

                if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
                {
                    int n;
                    d->m_lookahead_pos = lookahead_pos;
                    d->m_lookahead_size = lookahead_size;
                    d->m_dict_size = dict_size;
                    d->m_total_lz_bytes = total_lz_bytes;
                    d->m_pLZ_code_buf = pLZ_code_buf;
                    d->m_pLZ_flags = pLZ_flags;
                    d->m_num_flags_left = num_flags_left;
                    if ((n = tdefl_flush_block(d, 0)) != 0)
                        return (n < 0) ? MZ_FALSE : MZ_TRUE;
                    total_lz_bytes = d->m_total_lz_bytes;
                    pLZ_code_buf = d->m_pLZ_code_buf;
                    pLZ_flags = d->m_pLZ_flags;
                    num_flags_left = d->m_num_flags_left;
                }
            }

            while (lookahead_size)
            {
                mz_uint8 lit = d->m_dict[cur_pos];

                total_lz_bytes++;
                *pLZ_code_buf++ = lit;
                *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
                if (--num_flags_left == 0)
                {
                    num_flags_left = 8;
                    pLZ_flags = pLZ_code_buf++;
                }

                d->m_huff_count[0][lit]++;

                lookahead_pos++;
                dict_size = MZ_MIN(dict_size + 1, (mz_uint)TDEFL_LZ_DICT_SIZE);
                cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
                lookahead_size--;

                if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
                {
                    int n;
                    d->m_lookahead_pos = lookahead_pos;
                    d->m_lookahead_size = lookahead_size;
                    d->m_dict_size = dict_size;
                    d->m_total_lz_bytes = total_lz_bytes;
                    d->m_pLZ_code_buf = pLZ_code_buf;
                    d->m_pLZ_flags = pLZ_flags;
                    d->m_num_flags_left = num_flags_left;
                    if ((n = tdefl_flush_block(d, 0)) != 0)
                        return (n < 0) ? MZ_FALSE : MZ_TRUE;
                    total_lz_bytes = d->m_total_lz_bytes;
                    pLZ_code_buf = d->m_pLZ_code_buf;
                    pLZ_flags = d->m_pLZ_flags;
                    num_flags_left = d->m_num_flags_left;
                }
            }
        }

        d->m_lookahead_pos = lookahead_pos;
        d->m_lookahead_size = lookahead_size;
        d->m_dict_size = dict_size;
        d->m_total_lz_bytes = total_lz_bytes;
        d->m_pLZ_code_buf = pLZ_code_buf;
        d->m_pLZ_flags = pLZ_flags;
        d->m_num_flags_left = num_flags_left;
        return MZ_TRUE;
    }
#endif /* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */

    static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)
    {
        d->m_total_lz_bytes++;
        *d->m_pLZ_code_buf++ = lit;
        *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);
        if (--d->m_num_flags_left == 0)
        {
            d->m_num_flags_left = 8;
            d->m_pLZ_flags = d->m_pLZ_code_buf++;
        }
        d->m_huff_count[0][lit]++;
    }

    static MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)
    {
        mz_uint32 s0, s1;

        MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));

        d->m_total_lz_bytes += match_len;

        d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);

        match_dist -= 1;
        d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
        d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8);
        d->m_pLZ_code_buf += 3;

        *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80);
        if (--d->m_num_flags_left == 0)
        {
            d->m_num_flags_left = 8;
            d->m_pLZ_flags = d->m_pLZ_code_buf++;
        }

        s0 = s_tdefl_small_dist_sym[match_dist & 511];
        s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
        d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;
        d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
    }

    static mz_bool tdefl_compress_normal(tdefl_compressor *d)
    {
        const mz_uint8 *pSrc = d->m_pSrc;
        size_t src_buf_left = d->m_src_buf_left;
        tdefl_flush flush = d->m_flush;

        while ((src_buf_left) || ((flush) && (d->m_lookahead_size)))
        {
            mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
            /* Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN. */
            if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1))
            {
                mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK, ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
                mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
                mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
                const mz_uint8 *pSrc_end = pSrc ? pSrc + num_bytes_to_process : NULL;
                src_buf_left -= num_bytes_to_process;
                d->m_lookahead_size += num_bytes_to_process;
                while (pSrc != pSrc_end)
                {
                    mz_uint8 c = *pSrc++;
                    d->m_dict[dst_pos] = c;
                    if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                        d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
                    hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
                    d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
                    d->m_hash[hash] = (mz_uint16)(ins_pos);
                    dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
                    ins_pos++;
                }
            }
            else
            {
                while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
                {
                    mz_uint8 c = *pSrc++;
                    mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
                    src_buf_left--;
                    d->m_dict[dst_pos] = c;
                    if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                        d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
                    if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN)
                    {
                        mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
                        mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2)) ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
                        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
                        d->m_hash[hash] = (mz_uint16)(ins_pos);
                    }
                }
            }
            d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
            if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
                break;

            /* Simple lazy/greedy parsing state machine. */
            len_to_move = 1;
            cur_match_dist = 0;
            cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1);
            cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
            if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS))
            {
                if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))
                {
                    mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
                    cur_match_len = 0;
                    while (cur_match_len < d->m_lookahead_size)
                    {
                        if (d->m_dict[cur_pos + cur_match_len] != c)
                            break;
                        cur_match_len++;
                    }
                    if (cur_match_len < TDEFL_MIN_MATCH_LEN)
                        cur_match_len = 0;
                    else
                        cur_match_dist = 1;
                }
            }
            else
            {
                tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);
            }
            if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)) || (cur_pos == cur_match_dist) || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5)))
            {
                cur_match_dist = cur_match_len = 0;
            }
            if (d->m_saved_match_len)
            {
                if (cur_match_len > d->m_saved_match_len)
                {
                    tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
                    if (cur_match_len >= 128)
                    {
                        tdefl_record_match(d, cur_match_len, cur_match_dist);
                        d->m_saved_match_len = 0;
                        len_to_move = cur_match_len;
                    }
                    else
                    {
                        d->m_saved_lit = d->m_dict[cur_pos];
                        d->m_saved_match_dist = cur_match_dist;
                        d->m_saved_match_len = cur_match_len;
                    }
                }
                else
                {
                    tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
                    len_to_move = d->m_saved_match_len - 1;
                    d->m_saved_match_len = 0;
                }
            }
            else if (!cur_match_dist)
                tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
            else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128))
            {
                tdefl_record_match(d, cur_match_len, cur_match_dist);
                len_to_move = cur_match_len;
            }
            else
            {
                d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)];
                d->m_saved_match_dist = cur_match_dist;
                d->m_saved_match_len = cur_match_len;
            }
            /* Move the lookahead forward by len_to_move bytes. */
            d->m_lookahead_pos += len_to_move;
            MZ_ASSERT(d->m_lookahead_size >= len_to_move);
            d->m_lookahead_size -= len_to_move;
            d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, (mz_uint)TDEFL_LZ_DICT_SIZE);
            /* Check if it's time to flush the current LZ codes to the internal output buffer. */
            if ((d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||
                ((d->m_total_lz_bytes > 31 * 1024) && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes) || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))))
            {
                int n;
                d->m_pSrc = pSrc;
                d->m_src_buf_left = src_buf_left;
                if ((n = tdefl_flush_block(d, 0)) != 0)
                    return (n < 0) ? MZ_FALSE : MZ_TRUE;
            }
        }

        d->m_pSrc = pSrc;
        d->m_src_buf_left = src_buf_left;
        return MZ_TRUE;
    }

    static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)
    {
        if (d->m_pIn_buf_size)
        {
            *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
        }

        if (d->m_pOut_buf_size)
        {
            size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);
            memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);
            d->m_output_flush_ofs += (mz_uint)n;
            d->m_output_flush_remaining -= (mz_uint)n;
            d->m_out_buf_ofs += n;

            *d->m_pOut_buf_size = d->m_out_buf_ofs;
        }

        return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;
    }

    tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)
    {
        if (!d)
        {
            if (pIn_buf_size)
                *pIn_buf_size = 0;
            if (pOut_buf_size)
                *pOut_buf_size = 0;
            return TDEFL_STATUS_BAD_PARAM;
        }

        d->m_pIn_buf = pIn_buf;
        d->m_pIn_buf_size = pIn_buf_size;
        d->m_pOut_buf = pOut_buf;
        d->m_pOut_buf_size = pOut_buf_size;
        d->m_pSrc = (const mz_uint8 *)(pIn_buf);
        d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
        d->m_out_buf_ofs = 0;
        d->m_flush = flush;

        if (((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||
            (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf) || (pOut_buf_size && *pOut_buf_size && !pOut_buf))
        {
            if (pIn_buf_size)
                *pIn_buf_size = 0;
            if (pOut_buf_size)
                *pOut_buf_size = 0;
            return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
        }
        d->m_wants_to_finish |= (flush == TDEFL_FINISH);

        if ((d->m_output_flush_remaining) || (d->m_finished))
            return (d->m_prev_return_status = tdefl_flush_output_buffer(d));

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
        if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
            ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
            ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))
        {
            if (!tdefl_compress_fast(d))
                return d->m_prev_return_status;
        }
        else
#endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */
        {
            if (!tdefl_compress_normal(d))
                return d->m_prev_return_status;
        }

        if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))
            d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf, d->m_pSrc - (const mz_uint8 *)pIn_buf);

        if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining))
        {
            if (tdefl_flush_block(d, flush) < 0)
                return d->m_prev_return_status;
            d->m_finished = (flush == TDEFL_FINISH);
            if (flush == TDEFL_FULL_FLUSH)
            {
                MZ_CLEAR_ARR(d->m_hash);
                MZ_CLEAR_ARR(d->m_next);
                d->m_dict_size = 0;
            }
        }

        return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
    }

    tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)
    {
        MZ_ASSERT(d->m_pPut_buf_func);
        return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
    }

    tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
    {
        d->m_pPut_buf_func = pPut_buf_func;
        d->m_pPut_buf_user = pPut_buf_user;
        d->m_flags = (mz_uint)(flags);
        d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3;
        d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
        d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
        if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG))
            MZ_CLEAR_ARR(d->m_hash);
        d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
        d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
        d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
        d->m_pLZ_flags = d->m_lz_code_buf;
        *d->m_pLZ_flags = 0;
        d->m_num_flags_left = 8;
        d->m_pOutput_buf = d->m_output_buf;
        d->m_pOutput_buf_end = d->m_output_buf;
        d->m_prev_return_status = TDEFL_STATUS_OKAY;
        d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0;
        d->m_adler32 = 1;
        d->m_pIn_buf = NULL;
        d->m_pOut_buf = NULL;
        d->m_pIn_buf_size = NULL;
        d->m_pOut_buf_size = NULL;
        d->m_flush = TDEFL_NO_FLUSH;
        d->m_pSrc = NULL;
        d->m_src_buf_left = 0;
        d->m_out_buf_ofs = 0;
        if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG))
            MZ_CLEAR_ARR(d->m_dict);
        memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
        memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
        return TDEFL_STATUS_OKAY;
    }

    tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)
    {
        return d->m_prev_return_status;
    }

    mz_uint32 tdefl_get_adler32(tdefl_compressor *d)
    {
        return d->m_adler32;
    }

    mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
    {
        tdefl_compressor *pComp;
        mz_bool succeeded;
        if (((buf_len) && (!pBuf)) || (!pPut_buf_func))
            return MZ_FALSE;
        pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
        if (!pComp)
            return MZ_FALSE;
        succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
        succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
        MZ_FREE(pComp);
        return succeeded;
    }

    typedef struct
    {
        size_t m_size, m_capacity;
        mz_uint8 *m_pBuf;
        mz_bool m_expandable;
    } tdefl_output_buffer;

    static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len, void *pUser)
    {
        tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
        size_t new_size = p->m_size + len;
        if (new_size > p->m_capacity)
        {
            size_t new_capacity = p->m_capacity;
            mz_uint8 *pNew_buf;
            if (!p->m_expandable)
                return MZ_FALSE;
            do
            {
                new_capacity = MZ_MAX(128U, new_capacity << 1U);
            } while (new_size > new_capacity);
            pNew_buf = (mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity);
            if (!pNew_buf)
                return MZ_FALSE;
            p->m_pBuf = pNew_buf;
            p->m_capacity = new_capacity;
        }
        memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len);
        p->m_size = new_size;
        return MZ_TRUE;
    }

    void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
    {
        tdefl_output_buffer out_buf;
        MZ_CLEAR_OBJ(out_buf);
        if (!pOut_len)
            return MZ_FALSE;
        else
            *pOut_len = 0;
        out_buf.m_expandable = MZ_TRUE;
        if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
            return NULL;
        *pOut_len = out_buf.m_size;
        return out_buf.m_pBuf;
    }

    size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
    {
        tdefl_output_buffer out_buf;
        MZ_CLEAR_OBJ(out_buf);
        if (!pOut_buf)
            return 0;
        out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
        out_buf.m_capacity = out_buf_len;
        if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
            return 0;
        return out_buf.m_size;
    }

    /* level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files). */
    mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)
    {
        mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
        if (window_bits > 0)
            comp_flags |= TDEFL_WRITE_ZLIB_HEADER;

        if (!level)
            comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
        else if (strategy == MZ_FILTERED)
            comp_flags |= TDEFL_FILTER_MATCHES;
        else if (strategy == MZ_HUFFMAN_ONLY)
            comp_flags &= ~TDEFL_MAX_PROBES_MASK;
        else if (strategy == MZ_FIXED)
            comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
        else if (strategy == MZ_RLE)
            comp_flags |= TDEFL_RLE_MATCHES;

        return comp_flags;
    }

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4204) /* nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal) */
#endif

    /* Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
     http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
     This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck. */
    void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)
    {
        /* Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined. */
        static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
        tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
        tdefl_output_buffer out_buf;
        int i, bpl = w * num_chans, y, z;
        mz_uint32 c;
        *pLen_out = 0;
        if (!pComp)
            return NULL;
        MZ_CLEAR_OBJ(out_buf);
        out_buf.m_expandable = MZ_TRUE;
        out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);
        if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity)))
        {
            MZ_FREE(pComp);
            return NULL;
        }
        /* write dummy header */
        for (z = 41; z; --z)
            tdefl_output_buffer_putter(&z, 1, &out_buf);
        /* compress image data */
        tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
        for (y = 0; y < h; ++y)
        {
            tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);
            tdefl_compress_buffer(pComp, (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH);
        }
        if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE)
        {
            MZ_FREE(pComp);
            MZ_FREE(out_buf.m_pBuf);
            return NULL;
        }
        /* write real header */
        *pLen_out = out_buf.m_size - 41;
        {
            static const mz_uint8 chans[] = { 0x00, 0x00, 0x04, 0x02, 0x06 };
            mz_uint8 pnghdr[41] = { 0x89, 0x50, 0x4e, 0x47, 0x0d,
                                    0x0a, 0x1a, 0x0a, 0x00, 0x00,
                                    0x00, 0x0d, 0x49, 0x48, 0x44,
                                    0x52, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x08,
                                    0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x49, 0x44, 0x41,
                                    0x54 };
            pnghdr[18] = (mz_uint8)(w >> 8);
            pnghdr[19] = (mz_uint8)w;
            pnghdr[22] = (mz_uint8)(h >> 8);
            pnghdr[23] = (mz_uint8)h;
            pnghdr[25] = chans[num_chans];
            pnghdr[33] = (mz_uint8)(*pLen_out >> 24);
            pnghdr[34] = (mz_uint8)(*pLen_out >> 16);
            pnghdr[35] = (mz_uint8)(*pLen_out >> 8);
            pnghdr[36] = (mz_uint8)*pLen_out;
            c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);
            for (i = 0; i < 4; ++i, c <<= 8)
                ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);
            memcpy(out_buf.m_pBuf, pnghdr, 41);
        }
        /* write footer (IDAT CRC-32, followed by IEND chunk) */
        if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf))
        {
            *pLen_out = 0;
            MZ_FREE(pComp);
            MZ_FREE(out_buf.m_pBuf);
            return NULL;
        }
        c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4, *pLen_out + 4);
        for (i = 0; i < 4; ++i, c <<= 8)
            (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);
        /* compute final size of file, grab compressed data buffer and return */
        *pLen_out += 57;
        MZ_FREE(pComp);
        return out_buf.m_pBuf;
    }
    void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out)
    {
        /* Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out) */
        return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
    }

#ifndef MINIZ_NO_MALLOC
    /* Allocate the tdefl_compressor and tinfl_decompressor structures in C so that */
    /* non-C language bindings to tdefL_ and tinfl_ API don't need to worry about */
    /* structure size and allocation mechanism. */
    tdefl_compressor *tdefl_compressor_alloc(void)
    {
        return (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
    }

    void tdefl_compressor_free(tdefl_compressor *pComp)
    {
        MZ_FREE(pComp);
    }
#endif

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

```

`miniz/miniz_tdef.h`:

```h
#pragma once
#include "miniz_common.h"

#ifndef MINIZ_NO_DEFLATE_APIS

#ifdef __cplusplus
extern "C"
{
#endif
/* ------------------- Low-level Compression API Definitions */

/* Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently). */
#ifndef TDEFL_LESS_MEMORY
#define TDEFL_LESS_MEMORY 0
#endif

    /* tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search): */
    /* TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression). */
    enum
    {
        TDEFL_HUFFMAN_ONLY = 0,
        TDEFL_DEFAULT_MAX_PROBES = 128,
        TDEFL_MAX_PROBES_MASK = 0xFFF
    };

    /* TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data. */
    /* TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers). */
    /* TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing. */
    /* TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory). */
    /* TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1) */
    /* TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled. */
    /* TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables. */
    /* TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks. */
    /* The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK). */
    enum
    {
        TDEFL_WRITE_ZLIB_HEADER = 0x01000,
        TDEFL_COMPUTE_ADLER32 = 0x02000,
        TDEFL_GREEDY_PARSING_FLAG = 0x04000,
        TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
        TDEFL_RLE_MATCHES = 0x10000,
        TDEFL_FILTER_MATCHES = 0x20000,
        TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
        TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
    };

    /* High level compression functions: */
    /* tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc(). */
    /* On entry: */
    /*  pSrc_buf, src_buf_len: Pointer and size of source block to compress. */
    /*  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression. */
    /* On return: */
    /*  Function returns a pointer to the compressed data, or NULL on failure. */
    /*  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data. */
    /*  The caller must free() the returned block when it's no longer needed. */
    MINIZ_EXPORT void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

    /* tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory. */
    /* Returns 0 on failure. */
    MINIZ_EXPORT size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

    /* Compresses an image to a compressed PNG file in memory. */
    /* On entry: */
    /*  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. */
    /*  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory. */
    /*  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL */
    /*  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps). */
    /* On return: */
    /*  Function returns a pointer to the compressed data, or NULL on failure. */
    /*  *pLen_out will be set to the size of the PNG image file. */
    /*  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed. */
    MINIZ_EXPORT void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);
    MINIZ_EXPORT void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out);

    /* Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time. */
    typedef mz_bool (*tdefl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);

    /* tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally. */
    MINIZ_EXPORT mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

    enum
    {
        TDEFL_MAX_HUFF_TABLES = 3,
        TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
        TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
        TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
        TDEFL_LZ_DICT_SIZE = 32768,
        TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
        TDEFL_MIN_MATCH_LEN = 3,
        TDEFL_MAX_MATCH_LEN = 258
    };

/* TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes). */
#if TDEFL_LESS_MEMORY
    enum
    {
        TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,
        TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
        TDEFL_MAX_HUFF_SYMBOLS = 288,
        TDEFL_LZ_HASH_BITS = 12,
        TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
        TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
        TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
    };
#else
enum
{
    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
    TDEFL_OUT_BUF_SIZE = (mz_uint)((TDEFL_LZ_CODE_BUF_SIZE * 13) / 10),
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 15,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#endif

    /* The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions. */
    typedef enum
    {
        TDEFL_STATUS_BAD_PARAM = -2,
        TDEFL_STATUS_PUT_BUF_FAILED = -1,
        TDEFL_STATUS_OKAY = 0,
        TDEFL_STATUS_DONE = 1
    } tdefl_status;

    /* Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums */
    typedef enum
    {
        TDEFL_NO_FLUSH = 0,
        TDEFL_SYNC_FLUSH = 2,
        TDEFL_FULL_FLUSH = 3,
        TDEFL_FINISH = 4
    } tdefl_flush;

    /* tdefl's compression state structure. */
    typedef struct
    {
        tdefl_put_buf_func_ptr m_pPut_buf_func;
        void *m_pPut_buf_user;
        mz_uint m_flags, m_max_probes[2];
        int m_greedy_parsing;
        mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
        mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
        mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;
        mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;
        tdefl_status m_prev_return_status;
        const void *m_pIn_buf;
        void *m_pOut_buf;
        size_t *m_pIn_buf_size, *m_pOut_buf_size;
        tdefl_flush m_flush;
        const mz_uint8 *m_pSrc;
        size_t m_src_buf_left, m_out_buf_ofs;
        mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
        mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
        mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
        mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
        mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
        mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
        mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
        mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
    } tdefl_compressor;

    /* Initializes the compressor. */
    /* There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory. */
    /* pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression. */
    /* If pBut_buf_func is NULL the user should always call the tdefl_compress() API. */
    /* flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.) */
    MINIZ_EXPORT tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

    /* Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible. */
    MINIZ_EXPORT tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

    /* tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr. */
    /* tdefl_compress_buffer() always consumes the entire input buffer. */
    MINIZ_EXPORT tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);

    MINIZ_EXPORT tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
    MINIZ_EXPORT mz_uint32 tdefl_get_adler32(tdefl_compressor *d);

    /* Create tdefl_compress() flags given zlib-style compression parameters. */
    /* level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files) */
    /* window_bits may be -15 (raw deflate) or 15 (zlib) */
    /* strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED */
    MINIZ_EXPORT mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy);

#ifndef MINIZ_NO_MALLOC
    /* Allocate the tdefl_compressor structure in C so that */
    /* non-C language bindings to tdefl_ API don't need to worry about */
    /* structure size and allocation mechanism. */
    MINIZ_EXPORT tdefl_compressor *tdefl_compressor_alloc(void);
    MINIZ_EXPORT void tdefl_compressor_free(tdefl_compressor *pComp);
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

```

`miniz/miniz_tinfl.c`:

```c
/**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/

#include "miniz.h"

#ifndef MINIZ_NO_INFLATE_APIS

#ifdef __cplusplus
extern "C"
{
#endif

    /* ------------------- Low-level Decompression (completely independent from all compression API's) */

#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
#define TINFL_MEMSET(p, c, l) memset(p, c, l)

#define TINFL_CR_BEGIN  \
    switch (r->m_state) \
    {                   \
        case 0:
#define TINFL_CR_RETURN(state_index, result) \
    do                                       \
    {                                        \
        status = result;                     \
        r->m_state = state_index;            \
        goto common_exit;                    \
        case state_index:;                   \
    }                                        \
    MZ_MACRO_END
#define TINFL_CR_RETURN_FOREVER(state_index, result) \
    do                                               \
    {                                                \
        for (;;)                                     \
        {                                            \
            TINFL_CR_RETURN(state_index, result);    \
        }                                            \
    }                                                \
    MZ_MACRO_END
#define TINFL_CR_FINISH }

#define TINFL_GET_BYTE(state_index, c)                                                                                                                           \
    do                                                                                                                                                           \
    {                                                                                                                                                            \
        while (pIn_buf_cur >= pIn_buf_end)                                                                                                                       \
        {                                                                                                                                                        \
            TINFL_CR_RETURN(state_index, (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) ? TINFL_STATUS_NEEDS_MORE_INPUT : TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS); \
        }                                                                                                                                                        \
        c = *pIn_buf_cur++;                                                                                                                                      \
    }                                                                                                                                                            \
    MZ_MACRO_END

#define TINFL_NEED_BITS(state_index, n)                \
    do                                                 \
    {                                                  \
        mz_uint c;                                     \
        TINFL_GET_BYTE(state_index, c);                \
        bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); \
        num_bits += 8;                                 \
    } while (num_bits < (mz_uint)(n))
#define TINFL_SKIP_BITS(state_index, n)      \
    do                                       \
    {                                        \
        if (num_bits < (mz_uint)(n))         \
        {                                    \
            TINFL_NEED_BITS(state_index, n); \
        }                                    \
        bit_buf >>= (n);                     \
        num_bits -= (n);                     \
    }                                        \
    MZ_MACRO_END
#define TINFL_GET_BITS(state_index, b, n)    \
    do                                       \
    {                                        \
        if (num_bits < (mz_uint)(n))         \
        {                                    \
            TINFL_NEED_BITS(state_index, n); \
        }                                    \
        b = bit_buf & ((1 << (n)) - 1);      \
        bit_buf >>= (n);                     \
        num_bits -= (n);                     \
    }                                        \
    MZ_MACRO_END

/* TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2. */
/* It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a */
/* Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the */
/* bit buffer contains >=15 bits (deflate's max. Huffman code size). */
#define TINFL_HUFF_BITBUF_FILL(state_index, pLookUp, pTree)          \
    do                                                               \
    {                                                                \
        temp = pLookUp[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)];      \
        if (temp >= 0)                                               \
        {                                                            \
            code_len = temp >> 9;                                    \
            if ((code_len) && (num_bits >= code_len))                \
                break;                                               \
        }                                                            \
        else if (num_bits > TINFL_FAST_LOOKUP_BITS)                  \
        {                                                            \
            code_len = TINFL_FAST_LOOKUP_BITS;                       \
            do                                                       \
            {                                                        \
                temp = pTree[~temp + ((bit_buf >> code_len++) & 1)]; \
            } while ((temp < 0) && (num_bits >= (code_len + 1)));    \
            if (temp >= 0)                                           \
                break;                                               \
        }                                                            \
        TINFL_GET_BYTE(state_index, c);                              \
        bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);               \
        num_bits += 8;                                               \
    } while (num_bits < 15);

/* TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read */
/* beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully */
/* decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32. */
/* The slow path is only executed at the very end of the input buffer. */
/* v1.16: The original macro handled the case at the very end of the passed-in input buffer, but we also need to handle the case where the user passes in 1+zillion bytes */
/* following the deflate data and our non-conservative read-ahead path won't kick in here on this code. This is much trickier. */
#define TINFL_HUFF_DECODE(state_index, sym, pLookUp, pTree)                                                                         \
    do                                                                                                                              \
    {                                                                                                                               \
        int temp;                                                                                                                   \
        mz_uint code_len, c;                                                                                                        \
        if (num_bits < 15)                                                                                                          \
        {                                                                                                                           \
            if ((pIn_buf_end - pIn_buf_cur) < 2)                                                                                    \
            {                                                                                                                       \
                TINFL_HUFF_BITBUF_FILL(state_index, pLookUp, pTree);                                                                \
            }                                                                                                                       \
            else                                                                                                                    \
            {                                                                                                                       \
                bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); \
                pIn_buf_cur += 2;                                                                                                   \
                num_bits += 16;                                                                                                     \
            }                                                                                                                       \
        }                                                                                                                           \
        if ((temp = pLookUp[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)                                                          \
            code_len = temp >> 9, temp &= 511;                                                                                      \
        else                                                                                                                        \
        {                                                                                                                           \
            code_len = TINFL_FAST_LOOKUP_BITS;                                                                                      \
            do                                                                                                                      \
            {                                                                                                                       \
                temp = pTree[~temp + ((bit_buf >> code_len++) & 1)];                                                                \
            } while (temp < 0);                                                                                                     \
        }                                                                                                                           \
        sym = temp;                                                                                                                 \
        bit_buf >>= code_len;                                                                                                       \
        num_bits -= code_len;                                                                                                       \
    }                                                                                                                               \
    MZ_MACRO_END

    static void tinfl_clear_tree(tinfl_decompressor *r)
    {
        if (r->m_type == 0)
            MZ_CLEAR_ARR(r->m_tree_0);
        else if (r->m_type == 1)
            MZ_CLEAR_ARR(r->m_tree_1);
        else
            MZ_CLEAR_ARR(r->m_tree_2);
    }

    tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)
    {
        static const mz_uint16 s_length_base[31] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 };
        static const mz_uint8 s_length_extra[31] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 };
        static const mz_uint16 s_dist_base[32] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 };
        static const mz_uint8 s_dist_extra[32] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 };
        static const mz_uint8 s_length_dezigzag[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
        static const mz_uint16 s_min_table_sizes[3] = { 257, 1, 4 };

        mz_int16 *pTrees[3];
        mz_uint8 *pCode_sizes[3];

        tinfl_status status = TINFL_STATUS_FAILED;
        mz_uint32 num_bits, dist, counter, num_extra;
        tinfl_bit_buf_t bit_buf;
        const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
        mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next ? pOut_buf_next + *pOut_buf_size : NULL;
        size_t out_buf_size_mask = (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1, dist_from_out_buf_start;

        /* Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter). */
        if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start))
        {
            *pIn_buf_size = *pOut_buf_size = 0;
            return TINFL_STATUS_BAD_PARAM;
        }

        pTrees[0] = r->m_tree_0;
        pTrees[1] = r->m_tree_1;
        pTrees[2] = r->m_tree_2;
        pCode_sizes[0] = r->m_code_size_0;
        pCode_sizes[1] = r->m_code_size_1;
        pCode_sizes[2] = r->m_code_size_2;

        num_bits = r->m_num_bits;
        bit_buf = r->m_bit_buf;
        dist = r->m_dist;
        counter = r->m_counter;
        num_extra = r->m_num_extra;
        dist_from_out_buf_start = r->m_dist_from_out_buf_start;
        TINFL_CR_BEGIN

        bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0;
        r->m_z_adler32 = r->m_check_adler32 = 1;
        if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
        {
            TINFL_GET_BYTE(1, r->m_zhdr0);
            TINFL_GET_BYTE(2, r->m_zhdr1);
            counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
            if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
                counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)((size_t)1 << (8U + (r->m_zhdr0 >> 4)))));
            if (counter)
            {
                TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED);
            }
        }

        do
        {
            TINFL_GET_BITS(3, r->m_final, 3);
            r->m_type = r->m_final >> 1;
            if (r->m_type == 0)
            {
                TINFL_SKIP_BITS(5, num_bits & 7);
                for (counter = 0; counter < 4; ++counter)
                {
                    if (num_bits)
                        TINFL_GET_BITS(6, r->m_raw_header[counter], 8);
                    else
                        TINFL_GET_BYTE(7, r->m_raw_header[counter]);
                }
                if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8))))
                {
                    TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED);
                }
                while ((counter) && (num_bits))
                {
                    TINFL_GET_BITS(51, dist, 8);
                    while (pOut_buf_cur >= pOut_buf_end)
                    {
                        TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT);
                    }
                    *pOut_buf_cur++ = (mz_uint8)dist;
                    counter--;
                }
                while (counter)
                {
                    size_t n;
                    while (pOut_buf_cur >= pOut_buf_end)
                    {
                        TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT);
                    }
                    while (pIn_buf_cur >= pIn_buf_end)
                    {
                        TINFL_CR_RETURN(38, (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) ? TINFL_STATUS_NEEDS_MORE_INPUT : TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS);
                    }
                    n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);
                    TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n);
                    pIn_buf_cur += n;
                    pOut_buf_cur += n;
                    counter -= (mz_uint)n;
                }
            }
            else if (r->m_type == 3)
            {
                TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
            }
            else
            {
                if (r->m_type == 1)
                {
                    mz_uint8 *p = r->m_code_size_0;
                    mz_uint i;
                    r->m_table_sizes[0] = 288;
                    r->m_table_sizes[1] = 32;
                    TINFL_MEMSET(r->m_code_size_1, 5, 32);
                    for (i = 0; i <= 143; ++i)
                        *p++ = 8;
                    for (; i <= 255; ++i)
                        *p++ = 9;
                    for (; i <= 279; ++i)
                        *p++ = 7;
                    for (; i <= 287; ++i)
                        *p++ = 8;
                }
                else
                {
                    for (counter = 0; counter < 3; counter++)
                    {
                        TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]);
                        r->m_table_sizes[counter] += s_min_table_sizes[counter];
                    }
                    MZ_CLEAR_ARR(r->m_code_size_2);
                    for (counter = 0; counter < r->m_table_sizes[2]; counter++)
                    {
                        mz_uint s;
                        TINFL_GET_BITS(14, s, 3);
                        r->m_code_size_2[s_length_dezigzag[counter]] = (mz_uint8)s;
                    }
                    r->m_table_sizes[2] = 19;
                }
                for (; (int)r->m_type >= 0; r->m_type--)
                {
                    int tree_next, tree_cur;
                    mz_int16 *pLookUp;
                    mz_int16 *pTree;
                    mz_uint8 *pCode_size;
                    mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16];
                    pLookUp = r->m_look_up[r->m_type];
                    pTree = pTrees[r->m_type];
                    pCode_size = pCode_sizes[r->m_type];
                    MZ_CLEAR_ARR(total_syms);
                    TINFL_MEMSET(pLookUp, 0, sizeof(r->m_look_up[0]));
                    tinfl_clear_tree(r);
                    for (i = 0; i < r->m_table_sizes[r->m_type]; ++i)
                        total_syms[pCode_size[i]]++;
                    used_syms = 0, total = 0;
                    next_code[0] = next_code[1] = 0;
                    for (i = 1; i <= 15; ++i)
                    {
                        used_syms += total_syms[i];
                        next_code[i + 1] = (total = ((total + total_syms[i]) << 1));
                    }
                    if ((65536 != total) && (used_syms > 1))
                    {
                        TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
                    }
                    for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index)
                    {
                        mz_uint rev_code = 0, l, cur_code, code_size = pCode_size[sym_index];
                        if (!code_size)
                            continue;
                        cur_code = next_code[code_size]++;
                        for (l = code_size; l > 0; l--, cur_code >>= 1)
                            rev_code = (rev_code << 1) | (cur_code & 1);
                        if (code_size <= TINFL_FAST_LOOKUP_BITS)
                        {
                            mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
                            while (rev_code < TINFL_FAST_LOOKUP_SIZE)
                            {
                                pLookUp[rev_code] = k;
                                rev_code += (1 << code_size);
                            }
                            continue;
                        }
                        if (0 == (tree_cur = pLookUp[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)]))
                        {
                            pLookUp[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next;
                            tree_cur = tree_next;
                            tree_next -= 2;
                        }
                        rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
                        for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--)
                        {
                            tree_cur -= ((rev_code >>= 1) & 1);
                            if (!pTree[-tree_cur - 1])
                            {
                                pTree[-tree_cur - 1] = (mz_int16)tree_next;
                                tree_cur = tree_next;
                                tree_next -= 2;
                            }
                            else
                                tree_cur = pTree[-tree_cur - 1];
                        }
                        tree_cur -= ((rev_code >>= 1) & 1);
                        pTree[-tree_cur - 1] = (mz_int16)sym_index;
                    }
                    if (r->m_type == 2)
                    {
                        for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]);)
                        {
                            mz_uint s;
                            TINFL_HUFF_DECODE(16, dist, r->m_look_up[2], r->m_tree_2);
                            if (dist < 16)
                            {
                                r->m_len_codes[counter++] = (mz_uint8)dist;
                                continue;
                            }
                            if ((dist == 16) && (!counter))
                            {
                                TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
                            }
                            num_extra = "\02\03\07"[dist - 16];
                            TINFL_GET_BITS(18, s, num_extra);
                            s += "\03\03\013"[dist - 16];
                            TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);
                            counter += s;
                        }
                        if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter)
                        {
                            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
                        }
                        TINFL_MEMCPY(r->m_code_size_0, r->m_len_codes, r->m_table_sizes[0]);
                        TINFL_MEMCPY(r->m_code_size_1, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);
                    }
                }
                for (;;)
                {
                    mz_uint8 *pSrc;
                    for (;;)
                    {
                        if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2))
                        {
                            TINFL_HUFF_DECODE(23, counter, r->m_look_up[0], r->m_tree_0);
                            if (counter >= 256)
                                break;
                            while (pOut_buf_cur >= pOut_buf_end)
                            {
                                TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT);
                            }
                            *pOut_buf_cur++ = (mz_uint8)counter;
                        }
                        else
                        {
                            int sym2;
                            mz_uint code_len;
#if TINFL_USE_64BIT_BITBUF
                            if (num_bits < 30)
                            {
                                bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits);
                                pIn_buf_cur += 4;
                                num_bits += 32;
                            }
#else
                        if (num_bits < 15)
                        {
                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
                            pIn_buf_cur += 2;
                            num_bits += 16;
                        }
#endif
                            if ((sym2 = r->m_look_up[0][bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
                                code_len = sym2 >> 9;
                            else
                            {
                                code_len = TINFL_FAST_LOOKUP_BITS;
                                do
                                {
                                    sym2 = r->m_tree_0[~sym2 + ((bit_buf >> code_len++) & 1)];
                                } while (sym2 < 0);
                            }
                            counter = sym2;
                            bit_buf >>= code_len;
                            num_bits -= code_len;
                            if (counter & 256)
                                break;

#if !TINFL_USE_64BIT_BITBUF
                            if (num_bits < 15)
                            {
                                bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
                                pIn_buf_cur += 2;
                                num_bits += 16;
                            }
#endif
                            if ((sym2 = r->m_look_up[0][bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
                                code_len = sym2 >> 9;
                            else
                            {
                                code_len = TINFL_FAST_LOOKUP_BITS;
                                do
                                {
                                    sym2 = r->m_tree_0[~sym2 + ((bit_buf >> code_len++) & 1)];
                                } while (sym2 < 0);
                            }
                            bit_buf >>= code_len;
                            num_bits -= code_len;

                            pOut_buf_cur[0] = (mz_uint8)counter;
                            if (sym2 & 256)
                            {
                                pOut_buf_cur++;
                                counter = sym2;
                                break;
                            }
                            pOut_buf_cur[1] = (mz_uint8)sym2;
                            pOut_buf_cur += 2;
                        }
                    }
                    if ((counter &= 511) == 256)
                        break;

                    num_extra = s_length_extra[counter - 257];
                    counter = s_length_base[counter - 257];
                    if (num_extra)
                    {
                        mz_uint extra_bits;
                        TINFL_GET_BITS(25, extra_bits, num_extra);
                        counter += extra_bits;
                    }

                    TINFL_HUFF_DECODE(26, dist, r->m_look_up[1], r->m_tree_1);
                    num_extra = s_dist_extra[dist];
                    dist = s_dist_base[dist];
                    if (num_extra)
                    {
                        mz_uint extra_bits;
                        TINFL_GET_BITS(27, extra_bits, num_extra);
                        dist += extra_bits;
                    }

                    dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
                    if ((dist == 0 || dist > dist_from_out_buf_start || dist_from_out_buf_start == 0) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
                    {
                        TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
                    }

                    pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);

                    if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end)
                    {
                        while (counter--)
                        {
                            while (pOut_buf_cur >= pOut_buf_end)
                            {
                                TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT);
                            }
                            *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];
                        }
                        continue;
                    }
#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
                    else if ((counter >= 9) && (counter <= dist))
                    {
                        const mz_uint8 *pSrc_end = pSrc + (counter & ~7);
                        do
                        {
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
                            memcpy(pOut_buf_cur, pSrc, sizeof(mz_uint32) * 2);
#else
                            ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];
                            ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];
#endif
                            pOut_buf_cur += 8;
                        } while ((pSrc += 8) < pSrc_end);
                        if ((counter &= 7) < 3)
                        {
                            if (counter)
                            {
                                pOut_buf_cur[0] = pSrc[0];
                                if (counter > 1)
                                    pOut_buf_cur[1] = pSrc[1];
                                pOut_buf_cur += counter;
                            }
                            continue;
                        }
                    }
#endif
                    while (counter > 2)
                    {
                        pOut_buf_cur[0] = pSrc[0];
                        pOut_buf_cur[1] = pSrc[1];
                        pOut_buf_cur[2] = pSrc[2];
                        pOut_buf_cur += 3;
                        pSrc += 3;
                        counter -= 3;
                    }
                    if (counter > 0)
                    {
                        pOut_buf_cur[0] = pSrc[0];
                        if (counter > 1)
                            pOut_buf_cur[1] = pSrc[1];
                        pOut_buf_cur += counter;
                    }
                }
            }
        } while (!(r->m_final & 1));

        /* Ensure byte alignment and put back any bytes from the bitbuf if we've looked ahead too far on gzip, or other Deflate streams followed by arbitrary data. */
        /* I'm being super conservative here. A number of simplifications can be made to the byte alignment part, and the Adler32 check shouldn't ever need to worry about reading from the bitbuf now. */
        TINFL_SKIP_BITS(32, num_bits & 7);
        while ((pIn_buf_cur > pIn_buf_next) && (num_bits >= 8))
        {
            --pIn_buf_cur;
            num_bits -= 8;
        }
        bit_buf &= ~(~(tinfl_bit_buf_t)0 << num_bits);
        MZ_ASSERT(!num_bits); /* if this assert fires then we've read beyond the end of non-deflate/zlib streams with following data (such as gzip streams). */

        if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
        {
            for (counter = 0; counter < 4; ++counter)
            {
                mz_uint s;
                if (num_bits)
                    TINFL_GET_BITS(41, s, 8);
                else
                    TINFL_GET_BYTE(42, s);
                r->m_z_adler32 = (r->m_z_adler32 << 8) | s;
            }
        }
        TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);

        TINFL_CR_FINISH

    common_exit:
        /* As long as we aren't telling the caller that we NEED more input to make forward progress: */
        /* Put back any bytes from the bitbuf in case we've looked ahead too far on gzip, or other Deflate streams followed by arbitrary data. */
        /* We need to be very careful here to NOT push back any bytes we definitely know we need to make forward progress, though, or we'll lock the caller up into an inf loop. */
        if ((status != TINFL_STATUS_NEEDS_MORE_INPUT) && (status != TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS))
        {
            while ((pIn_buf_cur > pIn_buf_next) && (num_bits >= 8))
            {
                --pIn_buf_cur;
                num_bits -= 8;
            }
        }
        r->m_num_bits = num_bits;
        r->m_bit_buf = bit_buf & ~(~(tinfl_bit_buf_t)0 << num_bits);
        r->m_dist = dist;
        r->m_counter = counter;
        r->m_num_extra = num_extra;
        r->m_dist_from_out_buf_start = dist_from_out_buf_start;
        *pIn_buf_size = pIn_buf_cur - pIn_buf_next;
        *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
        if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0))
        {
            const mz_uint8 *ptr = pOut_buf_next;
            size_t buf_len = *pOut_buf_size;
            mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16;
            size_t block_len = buf_len % 5552;
            while (buf_len)
            {
                for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
                {
                    s1 += ptr[0], s2 += s1;
                    s1 += ptr[1], s2 += s1;
                    s1 += ptr[2], s2 += s1;
                    s1 += ptr[3], s2 += s1;
                    s1 += ptr[4], s2 += s1;
                    s1 += ptr[5], s2 += s1;
                    s1 += ptr[6], s2 += s1;
                    s1 += ptr[7], s2 += s1;
                }
                for (; i < block_len; ++i)
                    s1 += *ptr++, s2 += s1;
                s1 %= 65521U, s2 %= 65521U;
                buf_len -= block_len;
                block_len = 5552;
            }
            r->m_check_adler32 = (s2 << 16) + s1;
            if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32))
                status = TINFL_STATUS_ADLER32_MISMATCH;
        }
        return status;
    }

    /* Higher level helper functions. */
    void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
    {
        tinfl_decompressor decomp;
        void *pBuf = NULL, *pNew_buf;
        size_t src_buf_ofs = 0, out_buf_capacity = 0;
        *pOut_len = 0;
        tinfl_init(&decomp);
        for (;;)
        {
            size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
            tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL, &dst_buf_size,
                                                   (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
            if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))
            {
                MZ_FREE(pBuf);
                *pOut_len = 0;
                return NULL;
            }
            src_buf_ofs += src_buf_size;
            *pOut_len += dst_buf_size;
            if (status == TINFL_STATUS_DONE)
                break;
            new_out_buf_capacity = out_buf_capacity * 2;
            if (new_out_buf_capacity < 128)
                new_out_buf_capacity = 128;
            pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
            if (!pNew_buf)
            {
                MZ_FREE(pBuf);
                *pOut_len = 0;
                return NULL;
            }
            pBuf = pNew_buf;
            out_buf_capacity = new_out_buf_capacity;
        }
        return pBuf;
    }

    size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
    {
        tinfl_decompressor decomp;
        tinfl_status status;
        tinfl_init(&decomp);
        status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len, (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
        return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
    }

    int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
    {
        int result = 0;
        tinfl_decompressor decomp;
        mz_uint8 *pDict = (mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE);
        size_t in_buf_ofs = 0, dict_ofs = 0;
        if (!pDict)
            return TINFL_STATUS_FAILED;
        memset(pDict, 0, TINFL_LZ_DICT_SIZE);
        tinfl_init(&decomp);
        for (;;)
        {
            size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
            tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
                                                   (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
            in_buf_ofs += in_buf_size;
            if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))
                break;
            if (status != TINFL_STATUS_HAS_MORE_OUTPUT)
            {
                result = (status == TINFL_STATUS_DONE);
                break;
            }
            dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
        }
        MZ_FREE(pDict);
        *pIn_buf_size = in_buf_ofs;
        return result;
    }

#ifndef MINIZ_NO_MALLOC
    tinfl_decompressor *tinfl_decompressor_alloc(void)
    {
        tinfl_decompressor *pDecomp = (tinfl_decompressor *)MZ_MALLOC(sizeof(tinfl_decompressor));
        if (pDecomp)
            tinfl_init(pDecomp);
        return pDecomp;
    }

    void tinfl_decompressor_free(tinfl_decompressor *pDecomp)
    {
        MZ_FREE(pDecomp);
    }
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

```

`miniz/miniz_tinfl.h`:

```h
#pragma once
#include "miniz_common.h"
/* ------------------- Low-level Decompression API Definitions */

#ifndef MINIZ_NO_INFLATE_APIS

#ifdef __cplusplus
extern "C"
{
#endif
    /* Decompression flags used by tinfl_decompress(). */
    /* TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream. */
    /* TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input. */
    /* TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB). */
    /* TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes. */
    enum
    {
        TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
        TINFL_FLAG_HAS_MORE_INPUT = 2,
        TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
        TINFL_FLAG_COMPUTE_ADLER32 = 8
    };

    /* High level decompression functions: */
    /* tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc(). */
    /* On entry: */
    /*  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress. */
    /* On return: */
    /*  Function returns a pointer to the decompressed data, or NULL on failure. */
    /*  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data. */
    /*  The caller must call mz_free() on the returned block when it's no longer needed. */
    MINIZ_EXPORT void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

/* tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory. */
/* Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success. */
#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
    MINIZ_EXPORT size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

    /* tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer. */
    /* Returns 1 on success or 0 on failure. */
    typedef int (*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);
    MINIZ_EXPORT int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

    struct tinfl_decompressor_tag;
    typedef struct tinfl_decompressor_tag tinfl_decompressor;

#ifndef MINIZ_NO_MALLOC
    /* Allocate the tinfl_decompressor structure in C so that */
    /* non-C language bindings to tinfl_ API don't need to worry about */
    /* structure size and allocation mechanism. */
    MINIZ_EXPORT tinfl_decompressor *tinfl_decompressor_alloc(void);
    MINIZ_EXPORT void tinfl_decompressor_free(tinfl_decompressor *pDecomp);
#endif

/* Max size of LZ dictionary. */
#define TINFL_LZ_DICT_SIZE 32768

    /* Return status. */
    typedef enum
    {
        /* This flags indicates the inflator needs 1 or more input bytes to make forward progress, but the caller is indicating that no more are available. The compressed data */
        /* is probably corrupted. If you call the inflator again with more bytes it'll try to continue processing the input but this is a BAD sign (either the data is corrupted or you called it incorrectly). */
        /* If you call it again with no input you'll just get TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS again. */
        TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS = -4,

        /* This flag indicates that one or more of the input parameters was obviously bogus. (You can try calling it again, but if you get this error the calling code is wrong.) */
        TINFL_STATUS_BAD_PARAM = -3,

        /* This flags indicate the inflator is finished but the adler32 check of the uncompressed data didn't match. If you call it again it'll return TINFL_STATUS_DONE. */
        TINFL_STATUS_ADLER32_MISMATCH = -2,

        /* This flags indicate the inflator has somehow failed (bad code, corrupted input, etc.). If you call it again without resetting via tinfl_init() it it'll just keep on returning the same status failure code. */
        TINFL_STATUS_FAILED = -1,

        /* Any status code less than TINFL_STATUS_DONE must indicate a failure. */

        /* This flag indicates the inflator has returned every byte of uncompressed data that it can, has consumed every byte that it needed, has successfully reached the end of the deflate stream, and */
        /* if zlib headers and adler32 checking enabled that it has successfully checked the uncompressed data's adler32. If you call it again you'll just get TINFL_STATUS_DONE over and over again. */
        TINFL_STATUS_DONE = 0,

        /* This flag indicates the inflator MUST have more input data (even 1 byte) before it can make any more forward progress, or you need to clear the TINFL_FLAG_HAS_MORE_INPUT */
        /* flag on the next call if you don't have any more source data. If the source data was somehow corrupted it's also possible (but unlikely) for the inflator to keep on demanding input to */
        /* proceed, so be sure to properly set the TINFL_FLAG_HAS_MORE_INPUT flag. */
        TINFL_STATUS_NEEDS_MORE_INPUT = 1,

        /* This flag indicates the inflator definitely has 1 or more bytes of uncompressed data available, but it cannot write this data into the output buffer. */
        /* Note if the source compressed data was corrupted it's possible for the inflator to return a lot of uncompressed data to the caller. I've been assuming you know how much uncompressed data to expect */
        /* (either exact or worst case) and will stop calling the inflator and fail after receiving too much. In pure streaming scenarios where you have no idea how many bytes to expect this may not be possible */
        /* so I may need to add some code to address this. */
        TINFL_STATUS_HAS_MORE_OUTPUT = 2
    } tinfl_status;

/* Initializes the decompressor to its initial state. */
#define tinfl_init(r)     \
    do                    \
    {                     \
        (r)->m_state = 0; \
    }                     \
    MZ_MACRO_END
#define tinfl_get_adler32(r) (r)->m_check_adler32

    /* Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability. */
    /* This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output. */
    MINIZ_EXPORT tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags);

    /* Internal/private bits follow. */
    enum
    {
        TINFL_MAX_HUFF_TABLES = 3,
        TINFL_MAX_HUFF_SYMBOLS_0 = 288,
        TINFL_MAX_HUFF_SYMBOLS_1 = 32,
        TINFL_MAX_HUFF_SYMBOLS_2 = 19,
        TINFL_FAST_LOOKUP_BITS = 10,
        TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
    };

#if MINIZ_HAS_64BIT_REGISTERS
#define TINFL_USE_64BIT_BITBUF 1
#else
#define TINFL_USE_64BIT_BITBUF 0
#endif

#if TINFL_USE_64BIT_BITBUF
    typedef mz_uint64 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (64)
#else
typedef mz_uint32 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (32)
#endif

    struct tinfl_decompressor_tag
    {
        mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];
        tinfl_bit_buf_t m_bit_buf;
        size_t m_dist_from_out_buf_start;
        mz_int16 m_look_up[TINFL_MAX_HUFF_TABLES][TINFL_FAST_LOOKUP_SIZE];
        mz_int16 m_tree_0[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
        mz_int16 m_tree_1[TINFL_MAX_HUFF_SYMBOLS_1 * 2];
        mz_int16 m_tree_2[TINFL_MAX_HUFF_SYMBOLS_2 * 2];
        mz_uint8 m_code_size_0[TINFL_MAX_HUFF_SYMBOLS_0];
        mz_uint8 m_code_size_1[TINFL_MAX_HUFF_SYMBOLS_1];
        mz_uint8 m_code_size_2[TINFL_MAX_HUFF_SYMBOLS_2];
        mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
    };

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

```

`miniz/miniz_zip.c`:

```c
/**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * Copyright 2016 Martin Raiber
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/
#include "miniz.h"

#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
extern "C"
{
#endif

    /* ------------------- .ZIP archive reading */

#ifdef MINIZ_NO_STDIO
#define MZ_FILE void *
#else
#include <sys/stat.h>

#if defined(_MSC_VER) || defined(__MINGW64__) || defined(__MINGW32__)

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef __cplusplus
#define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>

static WCHAR *mz_utf8z_to_widechar(const char *str)
{
    int reqChars = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0);
    WCHAR *wStr = (WCHAR *)malloc(reqChars * sizeof(WCHAR));
    MultiByteToWideChar(CP_UTF8, 0, str, -1, wStr, reqChars);
    return wStr;
}

static FILE *mz_fopen(const char *pFilename, const char *pMode)
{
    WCHAR *wFilename = mz_utf8z_to_widechar(pFilename);
    WCHAR *wMode = mz_utf8z_to_widechar(pMode);
    FILE *pFile = NULL;
    errno_t err = _wfopen_s(&pFile, wFilename, wMode);
    free(wFilename);
    free(wMode);
    return err ? NULL : pFile;
}

static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream)
{
    WCHAR *wPath = mz_utf8z_to_widechar(pPath);
    WCHAR *wMode = mz_utf8z_to_widechar(pMode);
    FILE *pFile = NULL;
    errno_t err = _wfreopen_s(&pFile, wPath, wMode, pStream);
    free(wPath);
    free(wMode);
    return err ? NULL : pFile;
}

#if defined(__MINGW32__)
static int mz_stat(const char *path, struct _stat *buffer)
{
    WCHAR *wPath = mz_utf8z_to_widechar(path);
    int res = _wstat(wPath, buffer);
    free(wPath);
    return res;
}
#else
static int mz_stat64(const char *path, struct __stat64 *buffer)
{
    WCHAR *wPath = mz_utf8z_to_widechar(path);
    int res = _wstat64(wPath, buffer);
    free(wPath);
    return res;
}
#endif

#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN mz_fopen
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 _ftelli64
#define MZ_FSEEK64 _fseeki64
#if defined(__MINGW32__)
#define MZ_FILE_STAT_STRUCT _stat
#define MZ_FILE_STAT mz_stat
#else
#define MZ_FILE_STAT_STRUCT _stat64
#define MZ_FILE_STAT mz_stat64
#endif
#define MZ_FFLUSH fflush
#define MZ_FREOPEN mz_freopen
#define MZ_DELETE_FILE remove

#elif defined(__WATCOMC__)
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 _ftelli64
#define MZ_FSEEK64 _fseeki64
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__TINYC__)
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftell
#define MZ_FSEEK64 fseek
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__USE_LARGEFILE64) /* gcc, clang */
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen64(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello64
#define MZ_FSEEK64 fseeko64
#define MZ_FILE_STAT_STRUCT stat64
#define MZ_FILE_STAT stat64
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__APPLE__) || defined(__FreeBSD__) || (defined(__linux__) && defined(__x86_64__))
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello
#define MZ_FSEEK64 fseeko
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(p, m, s) freopen(p, m, s)
#define MZ_DELETE_FILE remove

#else
#pragma message("Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.")
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#ifdef __STRICT_ANSI__
#define MZ_FTELL64 ftell
#define MZ_FSEEK64 fseek
#else
#define MZ_FTELL64 ftello
#define MZ_FSEEK64 fseeko
#endif
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove
#endif /* #ifdef _MSC_VER */
#endif /* #ifdef MINIZ_NO_STDIO */

#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))

    /* Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff. */
    enum
    {
        /* ZIP archive identifiers and record sizes */
        MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
        MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
        MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
        MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
        MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
        MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,

        /* ZIP64 archive identifier and record sizes */
        MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06064b50,
        MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG = 0x07064b50,
        MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE = 56,
        MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE = 20,
        MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID = 0x0001,
        MZ_ZIP_DATA_DESCRIPTOR_ID = 0x08074b50,
        MZ_ZIP_DATA_DESCRIPTER_SIZE64 = 24,
        MZ_ZIP_DATA_DESCRIPTER_SIZE32 = 16,

        /* Central directory header record offsets */
        MZ_ZIP_CDH_SIG_OFS = 0,
        MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
        MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
        MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
        MZ_ZIP_CDH_METHOD_OFS = 10,
        MZ_ZIP_CDH_FILE_TIME_OFS = 12,
        MZ_ZIP_CDH_FILE_DATE_OFS = 14,
        MZ_ZIP_CDH_CRC32_OFS = 16,
        MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
        MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
        MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
        MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
        MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
        MZ_ZIP_CDH_DISK_START_OFS = 34,
        MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
        MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
        MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,

        /* Local directory header offsets */
        MZ_ZIP_LDH_SIG_OFS = 0,
        MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
        MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
        MZ_ZIP_LDH_METHOD_OFS = 8,
        MZ_ZIP_LDH_FILE_TIME_OFS = 10,
        MZ_ZIP_LDH_FILE_DATE_OFS = 12,
        MZ_ZIP_LDH_CRC32_OFS = 14,
        MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
        MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
        MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
        MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
        MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR = 1 << 3,

        /* End of central directory offsets */
        MZ_ZIP_ECDH_SIG_OFS = 0,
        MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
        MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
        MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
        MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
        MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
        MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
        MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,

        /* ZIP64 End of central directory locator offsets */
        MZ_ZIP64_ECDL_SIG_OFS = 0,                    /* 4 bytes */
        MZ_ZIP64_ECDL_NUM_DISK_CDIR_OFS = 4,          /* 4 bytes */
        MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS = 8,  /* 8 bytes */
        MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS = 16, /* 4 bytes */

        /* ZIP64 End of central directory header offsets */
        MZ_ZIP64_ECDH_SIG_OFS = 0,                       /* 4 bytes */
        MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS = 4,            /* 8 bytes */
        MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS = 12,          /* 2 bytes */
        MZ_ZIP64_ECDH_VERSION_NEEDED_OFS = 14,           /* 2 bytes */
        MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS = 16,            /* 4 bytes */
        MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS = 20,            /* 4 bytes */
        MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 24, /* 8 bytes */
        MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS = 32,       /* 8 bytes */
        MZ_ZIP64_ECDH_CDIR_SIZE_OFS = 40,                /* 8 bytes */
        MZ_ZIP64_ECDH_CDIR_OFS_OFS = 48,                 /* 8 bytes */
        MZ_ZIP_VERSION_MADE_BY_DOS_FILESYSTEM_ID = 0,
        MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG = 0x10,
        MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED = 1,
        MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG = 32,
        MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION = 64,
        MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED = 8192,
        MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8 = 1 << 11
    };

    typedef struct
    {
        void *m_p;
        size_t m_size, m_capacity;
        mz_uint m_element_size;
    } mz_zip_array;

    struct mz_zip_internal_state_tag
    {
        mz_zip_array m_central_dir;
        mz_zip_array m_central_dir_offsets;
        mz_zip_array m_sorted_central_dir_offsets;

        /* The flags passed in when the archive is initially opened. */
        mz_uint32 m_init_flags;

        /* MZ_TRUE if the archive has a zip64 end of central directory headers, etc. */
        mz_bool m_zip64;

        /* MZ_TRUE if we found zip64 extended info in the central directory (m_zip64 will also be slammed to true too, even if we didn't find a zip64 end of central dir header, etc.) */
        mz_bool m_zip64_has_extended_info_fields;

        /* These fields are used by the file, FILE, memory, and memory/heap read/write helpers. */
        MZ_FILE *m_pFile;
        mz_uint64 m_file_archive_start_ofs;

        void *m_pMem;
        size_t m_mem_size;
        size_t m_mem_capacity;
    };

#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size

#if defined(DEBUG) || defined(_DEBUG)
    static MZ_FORCEINLINE mz_uint mz_zip_array_range_check(const mz_zip_array *pArray, mz_uint index)
    {
        MZ_ASSERT(index < pArray->m_size);
        return index;
    }
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[mz_zip_array_range_check(array_ptr, index)]
#else
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[index]
#endif

    static MZ_FORCEINLINE void mz_zip_array_init(mz_zip_array *pArray, mz_uint32 element_size)
    {
        memset(pArray, 0, sizeof(mz_zip_array));
        pArray->m_element_size = element_size;
    }

    static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
        memset(pArray, 0, sizeof(mz_zip_array));
    }

    static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)
    {
        void *pNew_p;
        size_t new_capacity = min_new_capacity;
        MZ_ASSERT(pArray->m_element_size);
        if (pArray->m_capacity >= min_new_capacity)
            return MZ_TRUE;
        if (growing)
        {
            new_capacity = MZ_MAX(1, pArray->m_capacity);
            while (new_capacity < min_new_capacity)
                new_capacity *= 2;
        }
        if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity)))
            return MZ_FALSE;
        pArray->m_p = pNew_p;
        pArray->m_capacity = new_capacity;
        return MZ_TRUE;
    }

    static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)
    {
        if (new_capacity > pArray->m_capacity)
        {
            if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing))
                return MZ_FALSE;
        }
        return MZ_TRUE;
    }

    static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)
    {
        if (new_size > pArray->m_capacity)
        {
            if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing))
                return MZ_FALSE;
        }
        pArray->m_size = new_size;
        return MZ_TRUE;
    }

    static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)
    {
        return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
    }

    static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)
    {
        size_t orig_size = pArray->m_size;
        if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))
            return MZ_FALSE;
        if (n > 0)
            memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
        return MZ_TRUE;
    }

#ifndef MINIZ_NO_TIME
    static MZ_TIME_T mz_zip_dos_to_time_t(int dos_time, int dos_date)
    {
        struct tm tm;
        memset(&tm, 0, sizeof(tm));
        tm.tm_isdst = -1;
        tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;
        tm.tm_mon = ((dos_date >> 5) & 15) - 1;
        tm.tm_mday = dos_date & 31;
        tm.tm_hour = (dos_time >> 11) & 31;
        tm.tm_min = (dos_time >> 5) & 63;
        tm.tm_sec = (dos_time << 1) & 62;
        return mktime(&tm);
    }

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
    static void mz_zip_time_t_to_dos_time(MZ_TIME_T time, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
    {
#ifdef _MSC_VER
        struct tm tm_struct;
        struct tm *tm = &tm_struct;
        errno_t err = localtime_s(tm, &time);
        if (err)
        {
            *pDOS_date = 0;
            *pDOS_time = 0;
            return;
        }
#else
        struct tm *tm = localtime(&time);
#endif /* #ifdef _MSC_VER */

        *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
        *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
    }
#endif /* MINIZ_NO_ARCHIVE_WRITING_APIS */

#ifndef MINIZ_NO_STDIO
#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
    static mz_bool mz_zip_get_file_modified_time(const char *pFilename, MZ_TIME_T *pTime)
    {
        struct MZ_FILE_STAT_STRUCT file_stat;

        /* On Linux with x86 glibc, this call will fail on large files (I think >= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh. */
        if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
            return MZ_FALSE;

        *pTime = file_stat.st_mtime;

        return MZ_TRUE;
    }
#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS*/

    static mz_bool mz_zip_set_file_times(const char *pFilename, MZ_TIME_T access_time, MZ_TIME_T modified_time)
    {
        struct utimbuf t;

        memset(&t, 0, sizeof(t));
        t.actime = access_time;
        t.modtime = modified_time;

        return !utime(pFilename, &t);
    }
#endif /* #ifndef MINIZ_NO_STDIO */
#endif /* #ifndef MINIZ_NO_TIME */

    static MZ_FORCEINLINE mz_bool mz_zip_set_error(mz_zip_archive *pZip, mz_zip_error err_num)
    {
        if (pZip)
            pZip->m_last_error = err_num;
        return MZ_FALSE;
    }

    static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint flags)
    {
        (void)flags;
        if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (!pZip->m_pAlloc)
            pZip->m_pAlloc = miniz_def_alloc_func;
        if (!pZip->m_pFree)
            pZip->m_pFree = miniz_def_free_func;
        if (!pZip->m_pRealloc)
            pZip->m_pRealloc = miniz_def_realloc_func;

        pZip->m_archive_size = 0;
        pZip->m_central_directory_file_ofs = 0;
        pZip->m_total_files = 0;
        pZip->m_last_error = MZ_ZIP_NO_ERROR;

        if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
        pZip->m_pState->m_init_flags = flags;
        pZip->m_pState->m_zip64 = MZ_FALSE;
        pZip->m_pState->m_zip64_has_extended_info_fields = MZ_FALSE;

        pZip->m_zip_mode = MZ_ZIP_MODE_READING;

        return MZ_TRUE;
    }

    static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)
    {
        const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
        const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
        mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        mz_uint8 l = 0, r = 0;
        pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
        pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
        pE = pL + MZ_MIN(l_len, r_len);
        while (pL < pE)
        {
            if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
                break;
            pL++;
            pR++;
        }
        return (pL == pE) ? (l_len < r_len) : (l < r);
    }

#define MZ_SWAP_UINT32(a, b) \
    do                       \
    {                        \
        mz_uint32 t = a;     \
        a = b;               \
        b = t;               \
    }                        \
    MZ_MACRO_END

    /* Heap sort of lowercased filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.) */
    static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)
    {
        mz_zip_internal_state *pState = pZip->m_pState;
        const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
        const mz_zip_array *pCentral_dir = &pState->m_central_dir;
        mz_uint32 *pIndices;
        mz_uint32 start, end;
        const mz_uint32 size = pZip->m_total_files;

        if (size <= 1U)
            return;

        pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);

        start = (size - 2U) >> 1U;
        for (;;)
        {
            mz_uint64 child, root = start;
            for (;;)
            {
                if ((child = (root << 1U) + 1U) >= size)
                    break;
                child += (((child + 1U) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U])));
                if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
                    break;
                MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
                root = child;
            }
            if (!start)
                break;
            start--;
        }

        end = size - 1;
        while (end > 0)
        {
            mz_uint64 child, root = 0;
            MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
            for (;;)
            {
                if ((child = (root << 1U) + 1U) >= end)
                    break;
                child += (((child + 1U) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U]));
                if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
                    break;
                MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
                root = child;
            }
            end--;
        }
    }

    static mz_bool mz_zip_reader_locate_header_sig(mz_zip_archive *pZip, mz_uint32 record_sig, mz_uint32 record_size, mz_int64 *pOfs)
    {
        mz_int64 cur_file_ofs;
        mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
        mz_uint8 *pBuf = (mz_uint8 *)buf_u32;

        /* Basic sanity checks - reject files which are too small */
        if (pZip->m_archive_size < record_size)
            return MZ_FALSE;

        /* Find the record by scanning the file from the end towards the beginning. */
        cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
        for (;;)
        {
            int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);

            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
                return MZ_FALSE;

            for (i = n - 4; i >= 0; --i)
            {
                mz_uint s = MZ_READ_LE32(pBuf + i);
                if (s == record_sig)
                {
                    if ((pZip->m_archive_size - (cur_file_ofs + i)) >= record_size)
                        break;
                }
            }

            if (i >= 0)
            {
                cur_file_ofs += i;
                break;
            }

            /* Give up if we've searched the entire file, or we've gone back "too far" (~64kb) */
            if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= ((mz_uint64)(MZ_UINT16_MAX) + record_size)))
                return MZ_FALSE;

            cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
        }

        *pOfs = cur_file_ofs;
        return MZ_TRUE;
    }

    static mz_bool mz_zip_reader_eocd64_valid(mz_zip_archive *pZip, uint64_t offset, uint8_t *buf)
    {
        if (pZip->m_pRead(pZip->m_pIO_opaque, offset, buf, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
        {
            if (MZ_READ_LE32(buf + MZ_ZIP64_ECDH_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG)
            {
                return MZ_TRUE;
            }
        }

        return MZ_FALSE;
    }

    static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint flags)
    {
        mz_uint cdir_size = 0, cdir_entries_on_this_disk = 0, num_this_disk = 0, cdir_disk_index = 0;
        mz_uint64 cdir_ofs = 0, eocd_ofs = 0, archive_ofs = 0;
        mz_int64 cur_file_ofs = 0;
        const mz_uint8 *p;

        mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
        mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
        mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
        mz_uint32 zip64_end_of_central_dir_locator_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
        mz_uint8 *pZip64_locator = (mz_uint8 *)zip64_end_of_central_dir_locator_u32;

        mz_uint32 zip64_end_of_central_dir_header_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
        mz_uint8 *pZip64_end_of_central_dir = (mz_uint8 *)zip64_end_of_central_dir_header_u32;

        mz_uint64 zip64_end_of_central_dir_ofs = 0;

        /* Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there. */
        if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

        if (!mz_zip_reader_locate_header_sig(pZip, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE, &cur_file_ofs))
            return mz_zip_set_error(pZip, MZ_ZIP_FAILED_FINDING_CENTRAL_DIR);

        eocd_ofs = cur_file_ofs;
        /* Read and verify the end of central directory record. */
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

        if (MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
            return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

        if (cur_file_ofs >= (MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
        {
            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs - MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE, pZip64_locator, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
            {
                if (MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG)
                {
                    pZip->m_pState->m_zip64 = MZ_TRUE;
                }
            }
        }

        if (pZip->m_pState->m_zip64)
        {
            /* Try locating the EOCD64 right before the EOCD64 locator. This works even
             * when the effective start of the zip header is not yet known. */
            if (cur_file_ofs < MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE +
                                   MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
                return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

            zip64_end_of_central_dir_ofs = cur_file_ofs -
                                           MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE -
                                           MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE;

            if (!mz_zip_reader_eocd64_valid(pZip, zip64_end_of_central_dir_ofs,
                                            pZip64_end_of_central_dir))
            {
                /* That failed, try reading where the locator tells us to. */
                zip64_end_of_central_dir_ofs = MZ_READ_LE64(
                    pZip64_locator + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS);

                if (zip64_end_of_central_dir_ofs >
                    (pZip->m_archive_size - MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
                    return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

                if (!mz_zip_reader_eocd64_valid(pZip, zip64_end_of_central_dir_ofs,
                                                pZip64_end_of_central_dir))
                    return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
            }
        }

        pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS);
        cdir_entries_on_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
        num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
        cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
        cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS);
        cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);

        if (pZip->m_pState->m_zip64)
        {
            mz_uint32 zip64_total_num_of_disks = MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS);
            mz_uint64 zip64_cdir_total_entries = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS);
            mz_uint64 zip64_cdir_total_entries_on_this_disk = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
            mz_uint64 zip64_size_of_end_of_central_dir_record = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS);
            mz_uint64 zip64_size_of_central_directory = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_SIZE_OFS);

            if (zip64_size_of_end_of_central_dir_record < (MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - 12))
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            if (zip64_total_num_of_disks != 1U)
                return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

            /* Check for miniz's practical limits */
            if (zip64_cdir_total_entries > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

            pZip->m_total_files = (mz_uint32)zip64_cdir_total_entries;

            if (zip64_cdir_total_entries_on_this_disk > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

            cdir_entries_on_this_disk = (mz_uint32)zip64_cdir_total_entries_on_this_disk;

            /* Check for miniz's current practical limits (sorry, this should be enough for millions of files) */
            if (zip64_size_of_central_directory > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

            cdir_size = (mz_uint32)zip64_size_of_central_directory;

            num_this_disk = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS);

            cdir_disk_index = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS);

            cdir_ofs = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_OFS_OFS);
        }

        if (pZip->m_total_files != cdir_entries_on_this_disk)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

        if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1)))
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

        if (cdir_size < (mz_uint64)pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        if (eocd_ofs < cdir_ofs + cdir_size)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        /* The end of central dir follows the central dir, unless the zip file has
         * some trailing data (e.g. it is appended to an executable file). */
        archive_ofs = eocd_ofs - (cdir_ofs + cdir_size);
        if (pZip->m_pState->m_zip64)
        {
            if (archive_ofs < MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE +
                                  MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            archive_ofs -= MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE +
                           MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE;
        }

        /* Update the archive start position, but only if not specified. */
        if ((pZip->m_zip_type == MZ_ZIP_TYPE_FILE || pZip->m_zip_type == MZ_ZIP_TYPE_CFILE ||
            pZip->m_zip_type == MZ_ZIP_TYPE_USER) && pZip->m_pState->m_file_archive_start_ofs == 0)
        {
            pZip->m_pState->m_file_archive_start_ofs = archive_ofs;
            pZip->m_archive_size -= archive_ofs;
        }

        pZip->m_central_directory_file_ofs = cdir_ofs;

        if (pZip->m_total_files)
        {
            mz_uint i, n;
            /* Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and possibly another to hold the sorted indices. */
            if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) ||
                (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

            if (sort_central_dir)
            {
                if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE))
                    return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

            /* Now create an index into the central directory file records, do some basic sanity checking on each record */
            p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
            for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i)
            {
                mz_uint total_header_size, disk_index, bit_flags, filename_size, ext_data_size;
                mz_uint64 comp_size, decomp_size, local_header_ofs;

                if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);

                if (sort_central_dir)
                    MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;

                comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
                decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
                local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
                filename_size = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
                ext_data_size = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);

                if ((!pZip->m_pState->m_zip64_has_extended_info_fields) &&
                    (ext_data_size) &&
                    (MZ_MAX(MZ_MAX(comp_size, decomp_size), local_header_ofs) == MZ_UINT32_MAX))
                {
                    /* Attempt to find zip64 extended information field in the entry's extra data */
                    mz_uint32 extra_size_remaining = ext_data_size;

                    if (extra_size_remaining)
                    {
                        const mz_uint8 *pExtra_data;
                        void *buf = NULL;

                        if (MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + ext_data_size > n)
                        {
                            buf = MZ_MALLOC(ext_data_size);
                            if (buf == NULL)
                                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

                            if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size, buf, ext_data_size) != ext_data_size)
                            {
                                MZ_FREE(buf);
                                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                            }

                            pExtra_data = (mz_uint8 *)buf;
                        }
                        else
                        {
                            pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size;
                        }

                        do
                        {
                            mz_uint32 field_id;
                            mz_uint32 field_data_size;

                            if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                            {
                                MZ_FREE(buf);
                                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                            }

                            field_id = MZ_READ_LE16(pExtra_data);
                            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));

                            if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
                            {
                                MZ_FREE(buf);
                                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                            }

                            if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                            {
                                /* Ok, the archive didn't have any zip64 headers but it uses a zip64 extended information field so mark it as zip64 anyway (this can occur with infozip's zip util when it reads compresses files from stdin). */
                                pZip->m_pState->m_zip64 = MZ_TRUE;
                                pZip->m_pState->m_zip64_has_extended_info_fields = MZ_TRUE;
                                break;
                            }

                            pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
                            extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
                        } while (extra_size_remaining);

                        MZ_FREE(buf);
                    }
                }

                /* I've seen archives that aren't marked as zip64 that uses zip64 ext data, argh */
                if ((comp_size != MZ_UINT32_MAX) && (decomp_size != MZ_UINT32_MAX))
                {
                    if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size))
                        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                }

                disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
                if ((disk_index == MZ_UINT16_MAX) || ((disk_index != num_this_disk) && (disk_index != 1)))
                    return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

                if (comp_size != MZ_UINT32_MAX)
                {
                    if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
                        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                }

                bit_flags = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
                if (bit_flags & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED)
                    return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

                if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) > n)
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                n -= total_header_size;
                p += total_header_size;
            }
        }

        if (sort_central_dir)
            mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);

        return MZ_TRUE;
    }

    void mz_zip_zero_struct(mz_zip_archive *pZip)
    {
        if (pZip)
            MZ_CLEAR_PTR(pZip);
    }

    static mz_bool mz_zip_reader_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
    {
        mz_bool status = MZ_TRUE;

        if (!pZip)
            return MZ_FALSE;

        if ((!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
        {
            if (set_last_error)
                pZip->m_last_error = MZ_ZIP_INVALID_PARAMETER;

            return MZ_FALSE;
        }

        if (pZip->m_pState)
        {
            mz_zip_internal_state *pState = pZip->m_pState;
            pZip->m_pState = NULL;

            mz_zip_array_clear(pZip, &pState->m_central_dir);
            mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
            mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
            if (pState->m_pFile)
            {
                if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
                {
                    if (MZ_FCLOSE(pState->m_pFile) == EOF)
                    {
                        if (set_last_error)
                            pZip->m_last_error = MZ_ZIP_FILE_CLOSE_FAILED;
                        status = MZ_FALSE;
                    }
                }
                pState->m_pFile = NULL;
            }
#endif /* #ifndef MINIZ_NO_STDIO */

            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        }
        pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;

        return status;
    }

    mz_bool mz_zip_reader_end(mz_zip_archive *pZip)
    {
        return mz_zip_reader_end_internal(pZip, MZ_TRUE);
    }
    mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags)
    {
        if ((!pZip) || (!pZip->m_pRead))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (!mz_zip_reader_init_internal(pZip, flags))
            return MZ_FALSE;

        pZip->m_zip_type = MZ_ZIP_TYPE_USER;
        pZip->m_archive_size = size;

        if (!mz_zip_reader_read_central_dir(pZip, flags))
        {
            mz_zip_reader_end_internal(pZip, MZ_FALSE);
            return MZ_FALSE;
        }

        return MZ_TRUE;
    }

    static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
    {
        mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
        size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
        memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
        return s;
    }

    mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags)
    {
        if (!pMem)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

        if (!mz_zip_reader_init_internal(pZip, flags))
            return MZ_FALSE;

        pZip->m_zip_type = MZ_ZIP_TYPE_MEMORY;
        pZip->m_archive_size = size;
        pZip->m_pRead = mz_zip_mem_read_func;
        pZip->m_pIO_opaque = pZip;
        pZip->m_pNeeds_keepalive = NULL;

#ifdef __cplusplus
        pZip->m_pState->m_pMem = const_cast<void *>(pMem);
#else
    pZip->m_pState->m_pMem = (void *)pMem;
#endif

        pZip->m_pState->m_mem_size = size;

        if (!mz_zip_reader_read_central_dir(pZip, flags))
        {
            mz_zip_reader_end_internal(pZip, MZ_FALSE);
            return MZ_FALSE;
        }

        return MZ_TRUE;
    }

#ifndef MINIZ_NO_STDIO
    static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
    {
        mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
        mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);

        file_ofs += pZip->m_pState->m_file_archive_start_ofs;

        if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
            return 0;

        return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
    }

    mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)
    {
        return mz_zip_reader_init_file_v2(pZip, pFilename, flags, 0, 0);
    }

    mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size)
    {
        mz_uint64 file_size;
        MZ_FILE *pFile;

        if ((!pZip) || (!pFilename) || ((archive_size) && (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        pFile = MZ_FOPEN(pFilename, (flags & MZ_ZIP_FLAG_READ_ALLOW_WRITING ) ? "r+b" : "rb");
        if (!pFile)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

        file_size = archive_size;
        if (!file_size)
        {
            if (MZ_FSEEK64(pFile, 0, SEEK_END))
            {
                MZ_FCLOSE(pFile);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
            }

            file_size = MZ_FTELL64(pFile);
        }

        /* TODO: Better sanity check archive_size and the # of actual remaining bytes */

        if (file_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        {
            MZ_FCLOSE(pFile);
            return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
        }

        if (!mz_zip_reader_init_internal(pZip, flags))
        {
            MZ_FCLOSE(pFile);
            return MZ_FALSE;
        }

        pZip->m_zip_type = MZ_ZIP_TYPE_FILE;
        pZip->m_pRead = mz_zip_file_read_func;
        pZip->m_pIO_opaque = pZip;
        pZip->m_pState->m_pFile = pFile;
        pZip->m_archive_size = file_size;
        pZip->m_pState->m_file_archive_start_ofs = file_start_ofs;

        if (!mz_zip_reader_read_central_dir(pZip, flags))
        {
            mz_zip_reader_end_internal(pZip, MZ_FALSE);
            return MZ_FALSE;
        }

        return MZ_TRUE;
    }

    mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags)
    {
        mz_uint64 cur_file_ofs;

        if ((!pZip) || (!pFile))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

        cur_file_ofs = MZ_FTELL64(pFile);

        if (!archive_size)
        {
            if (MZ_FSEEK64(pFile, 0, SEEK_END))
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);

            archive_size = MZ_FTELL64(pFile) - cur_file_ofs;

            if (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
                return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
        }

        if (!mz_zip_reader_init_internal(pZip, flags))
            return MZ_FALSE;

        pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;
        pZip->m_pRead = mz_zip_file_read_func;

        pZip->m_pIO_opaque = pZip;
        pZip->m_pState->m_pFile = pFile;
        pZip->m_archive_size = archive_size;
        pZip->m_pState->m_file_archive_start_ofs = cur_file_ofs;

        if (!mz_zip_reader_read_central_dir(pZip, flags))
        {
            mz_zip_reader_end_internal(pZip, MZ_FALSE);
            return MZ_FALSE;
        }

        return MZ_TRUE;
    }

#endif /* #ifndef MINIZ_NO_STDIO */

    static MZ_FORCEINLINE const mz_uint8 *mz_zip_get_cdh(mz_zip_archive *pZip, mz_uint file_index)
    {
        if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files))
            return NULL;
        return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
    }

    mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)
    {
        mz_uint m_bit_flag;
        const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
        if (!p)
        {
            mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
            return MZ_FALSE;
        }

        m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
        return (m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION)) != 0;
    }

    mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index)
    {
        mz_uint bit_flag;
        mz_uint method;

        const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
        if (!p)
        {
            mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
            return MZ_FALSE;
        }

        method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
        bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);

        if ((method != 0) && (method != MZ_DEFLATED))
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
            return MZ_FALSE;
        }

        if (bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION))
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
            return MZ_FALSE;
        }

        if (bit_flag & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG)
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);
            return MZ_FALSE;
        }

        return MZ_TRUE;
    }

    mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)
    {
        mz_uint filename_len, attribute_mapping_id, external_attr;
        const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
        if (!p)
        {
            mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
            return MZ_FALSE;
        }

        filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        if (filename_len)
        {
            if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
                return MZ_TRUE;
        }

        /* Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct. */
        /* Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field. */
        /* FIXME: Remove this check? Is it necessary - we already check the filename. */
        attribute_mapping_id = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS) >> 8;
        (void)attribute_mapping_id;

        external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
        if ((external_attr & MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG) != 0)
        {
            return MZ_TRUE;
        }

        return MZ_FALSE;
    }

    static mz_bool mz_zip_file_stat_internal(mz_zip_archive *pZip, mz_uint file_index, const mz_uint8 *pCentral_dir_header, mz_zip_archive_file_stat *pStat, mz_bool *pFound_zip64_extra_data)
    {
        mz_uint n;
        const mz_uint8 *p = pCentral_dir_header;

        if (pFound_zip64_extra_data)
            *pFound_zip64_extra_data = MZ_FALSE;

        if ((!p) || (!pStat))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        /* Extract fields from the central directory record. */
        pStat->m_file_index = file_index;
        pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
        pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
        pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
        pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
        pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
#ifndef MINIZ_NO_TIME
        pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
#endif
        pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
        pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
        pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
        pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
        pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
        pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);

        /* Copy as much of the filename and comment as possible. */
        n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
        memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
        pStat->m_filename[n] = '\0';

        n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);
        n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
        pStat->m_comment_size = n;
        memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n);
        pStat->m_comment[n] = '\0';

        /* Set some flags for convienance */
        pStat->m_is_directory = mz_zip_reader_is_file_a_directory(pZip, file_index);
        pStat->m_is_encrypted = mz_zip_reader_is_file_encrypted(pZip, file_index);
        pStat->m_is_supported = mz_zip_reader_is_file_supported(pZip, file_index);

        /* See if we need to read any zip64 extended information fields. */
        /* Confusingly, these zip64 fields can be present even on non-zip64 archives (Debian zip on a huge files from stdin piped to stdout creates them). */
        if (MZ_MAX(MZ_MAX(pStat->m_comp_size, pStat->m_uncomp_size), pStat->m_local_header_ofs) == MZ_UINT32_MAX)
        {
            /* Attempt to find zip64 extended information field in the entry's extra data */
            mz_uint32 extra_size_remaining = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);

            if (extra_size_remaining)
            {
                const mz_uint8 *pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);

                do
                {
                    mz_uint32 field_id;
                    mz_uint32 field_data_size;

                    if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                    field_id = MZ_READ_LE16(pExtra_data);
                    field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));

                    if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
                        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                    if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                    {
                        const mz_uint8 *pField_data = pExtra_data + sizeof(mz_uint16) * 2;
                        mz_uint32 field_data_remaining = field_data_size;

                        if (pFound_zip64_extra_data)
                            *pFound_zip64_extra_data = MZ_TRUE;

                        if (pStat->m_uncomp_size == MZ_UINT32_MAX)
                        {
                            if (field_data_remaining < sizeof(mz_uint64))
                                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                            pStat->m_uncomp_size = MZ_READ_LE64(pField_data);
                            pField_data += sizeof(mz_uint64);
                            field_data_remaining -= sizeof(mz_uint64);
                        }

                        if (pStat->m_comp_size == MZ_UINT32_MAX)
                        {
                            if (field_data_remaining < sizeof(mz_uint64))
                                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                            pStat->m_comp_size = MZ_READ_LE64(pField_data);
                            pField_data += sizeof(mz_uint64);
                            field_data_remaining -= sizeof(mz_uint64);
                        }

                        if (pStat->m_local_header_ofs == MZ_UINT32_MAX)
                        {
                            if (field_data_remaining < sizeof(mz_uint64))
                                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                            pStat->m_local_header_ofs = MZ_READ_LE64(pField_data);
                            pField_data += sizeof(mz_uint64);
                            field_data_remaining -= sizeof(mz_uint64);
                        }

                        break;
                    }

                    pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
                    extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
                } while (extra_size_remaining);
            }
        }

        return MZ_TRUE;
    }

    static MZ_FORCEINLINE mz_bool mz_zip_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)
    {
        mz_uint i;
        if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
            return 0 == memcmp(pA, pB, len);
        for (i = 0; i < len; ++i)
            if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
                return MZ_FALSE;
        return MZ_TRUE;
    }

    static MZ_FORCEINLINE int mz_zip_filename_compare(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR, mz_uint r_len)
    {
        const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
        mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        mz_uint8 l = 0, r = 0;
        pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
        pE = pL + MZ_MIN(l_len, r_len);
        while (pL < pE)
        {
            if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
                break;
            pL++;
            pR++;
        }
        return (pL == pE) ? (int)(l_len - r_len) : (l - r);
    }

    static mz_bool mz_zip_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename, mz_uint32 *pIndex)
    {
        mz_zip_internal_state *pState = pZip->m_pState;
        const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
        const mz_zip_array *pCentral_dir = &pState->m_central_dir;
        mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
        const mz_uint32 size = pZip->m_total_files;
        const mz_uint filename_len = (mz_uint)strlen(pFilename);

        if (pIndex)
            *pIndex = 0;

        if (size)
        {
            /* yes I could use uint32_t's, but then we would have to add some special case checks in the loop, argh, and */
            /* honestly the major expense here on 32-bit CPU's will still be the filename compare */
            mz_int64 l = 0, h = (mz_int64)size - 1;

            while (l <= h)
            {
                mz_int64 m = l + ((h - l) >> 1);
                mz_uint32 file_index = pIndices[(mz_uint32)m];

                int comp = mz_zip_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
                if (!comp)
                {
                    if (pIndex)
                        *pIndex = file_index;
                    return MZ_TRUE;
                }
                else if (comp < 0)
                    l = m + 1;
                else
                    h = m - 1;
            }
        }

        return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
    }

    int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)
    {
        mz_uint32 index;
        if (!mz_zip_reader_locate_file_v2(pZip, pName, pComment, flags, &index))
            return -1;
        else
            return (int)index;
    }

    mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *pIndex)
    {
        mz_uint file_index;
        size_t name_len, comment_len;

        if (pIndex)
            *pIndex = 0;

        if ((!pZip) || (!pZip->m_pState) || (!pName))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        /* See if we can use a binary search */
        if (((pZip->m_pState->m_init_flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0) &&
            (pZip->m_zip_mode == MZ_ZIP_MODE_READING) &&
            ((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
        {
            return mz_zip_locate_file_binary_search(pZip, pName, pIndex);
        }

        /* Locate the entry by scanning the entire central directory */
        name_len = strlen(pName);
        if (name_len > MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        comment_len = pComment ? strlen(pComment) : 0;
        if (comment_len > MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        for (file_index = 0; file_index < pZip->m_total_files; file_index++)
        {
            const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
            mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
            const char *pFilename = (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
            if (filename_len < name_len)
                continue;
            if (comment_len)
            {
                mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
                const char *pFile_comment = pFilename + filename_len + file_extra_len;
                if ((file_comment_len != comment_len) || (!mz_zip_string_equal(pComment, pFile_comment, file_comment_len, flags)))
                    continue;
            }
            if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))
            {
                int ofs = filename_len - 1;
                do
                {
                    if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':'))
                        break;
                } while (--ofs >= 0);
                ofs++;
                pFilename += ofs;
                filename_len -= ofs;
            }
            if ((filename_len == name_len) && (mz_zip_string_equal(pName, pFilename, filename_len, flags)))
            {
                if (pIndex)
                    *pIndex = file_index;
                return MZ_TRUE;
            }
        }

        return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
    }

    static mz_bool mz_zip_reader_extract_to_mem_no_alloc1(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size, const mz_zip_archive_file_stat *st)
    {
        int status = TINFL_STATUS_DONE;
        mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
        mz_zip_archive_file_stat file_stat;
        void *pRead_buf;
        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
        mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
        tinfl_decompressor inflator;

        if ((!pZip) || (!pZip->m_pState) || ((buf_size) && (!pBuf)) || ((user_read_buf_size) && (!pUser_read_buf)) || (!pZip->m_pRead))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (st)
        {
            file_stat = *st;
        }
        else if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
            return MZ_FALSE;

        /* A directory or zero length file */
        if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
            return MZ_TRUE;

        /* Encryption and patch files are not supported. */
        if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

        /* This function only supports decompressing stored and deflate. */
        if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

        /* Ensure supplied output buffer is large enough. */
        needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
        if (buf_size < needed_size)
            return mz_zip_set_error(pZip, MZ_ZIP_BUF_TOO_SMALL);

        /* Read and parse the local directory entry. */
        cur_file_ofs = file_stat.m_local_header_ofs;
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        cur_file_ofs += (mz_uint64)(MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
        if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
        {
            /* The file is stored or the caller has requested the compressed data. */
            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
            if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) == 0)
            {
                if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
                    return mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
            }
#endif

            return MZ_TRUE;
        }

        /* Decompress the file either directly from memory or from a file input buffer. */
        tinfl_init(&inflator);

        if (pZip->m_pState->m_pMem)
        {
            /* Read directly from the archive in memory. */
            pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
            read_buf_size = read_buf_avail = file_stat.m_comp_size;
            comp_remaining = 0;
        }
        else if (pUser_read_buf)
        {
            /* Use a user provided read buffer. */
            if (!user_read_buf_size)
                return MZ_FALSE;
            pRead_buf = (mz_uint8 *)pUser_read_buf;
            read_buf_size = user_read_buf_size;
            read_buf_avail = 0;
            comp_remaining = file_stat.m_comp_size;
        }
        else
        {
            /* Temporarily allocate a read buffer. */
            read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
            if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

            if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

            read_buf_avail = 0;
            comp_remaining = file_stat.m_comp_size;
        }

        do
        {
            /* The size_t cast here should be OK because we've verified that the output buffer is >= file_stat.m_uncomp_size above */
            size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
            if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
            {
                read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
                if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                {
                    status = TINFL_STATUS_FAILED;
                    mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                    break;
                }
                cur_file_ofs += read_buf_avail;
                comp_remaining -= read_buf_avail;
                read_buf_ofs = 0;
            }
            in_buf_size = (size_t)read_buf_avail;
            status = tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
            read_buf_avail -= in_buf_size;
            read_buf_ofs += in_buf_size;
            out_buf_ofs += out_buf_size;
        } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);

        if (status == TINFL_STATUS_DONE)
        {
            /* Make sure the entire file was decompressed, and check its CRC. */
            if (out_buf_ofs != file_stat.m_uncomp_size)
            {
                mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
                status = TINFL_STATUS_FAILED;
            }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
            else if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
            {
                mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
                status = TINFL_STATUS_FAILED;
            }
#endif
        }

        if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
            pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

        return status == TINFL_STATUS_DONE;
    }

    mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
    {
        return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size, NULL);
    }

    mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
    {
        mz_uint32 file_index;
        if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
            return MZ_FALSE;
        return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size, NULL);
    }

    mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)
    {
        return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, NULL, 0, NULL);
    }

    mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)
    {
        return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
    }

    void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)
    {
        mz_zip_archive_file_stat file_stat;
        mz_uint64 alloc_size;
        void *pBuf;

        if (pSize)
            *pSize = 0;

        if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
            return NULL;

        alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
        if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
        {
            mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
            return NULL;
        }

        if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            return NULL;
        }

        if (!mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, (size_t)alloc_size, flags, NULL, 0, &file_stat))
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
            return NULL;
        }

        if (pSize)
            *pSize = (size_t)alloc_size;
        return pBuf;
    }

    void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)
    {
        mz_uint32 file_index;
        if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
        {
            if (pSize)
                *pSize = 0;
            return MZ_FALSE;
        }
        return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
    }

    mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
    {
        int status = TINFL_STATUS_DONE;
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        mz_uint file_crc32 = MZ_CRC32_INIT;
#endif
        mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
        mz_zip_archive_file_stat file_stat;
        void *pRead_buf = NULL;
        void *pWrite_buf = NULL;
        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
        mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

        if ((!pZip) || (!pZip->m_pState) || (!pCallback) || (!pZip->m_pRead))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
            return MZ_FALSE;

        /* A directory or zero length file */
        if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
            return MZ_TRUE;

        /* Encryption and patch files are not supported. */
        if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

        /* This function only supports decompressing stored and deflate. */
        if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

        /* Read and do some minimal validation of the local directory entry (this doesn't crack the zip64 stuff, which we already have from the central dir) */
        cur_file_ofs = file_stat.m_local_header_ofs;
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        cur_file_ofs += (mz_uint64)(MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
        if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        /* Decompress the file either directly from memory or from a file input buffer. */
        if (pZip->m_pState->m_pMem)
        {
            pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
            read_buf_size = read_buf_avail = file_stat.m_comp_size;
            comp_remaining = 0;
        }
        else
        {
            read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
            if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

            read_buf_avail = 0;
            comp_remaining = file_stat.m_comp_size;
        }

        if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
        {
            /* The file is stored or the caller has requested the compressed data. */
            if (pZip->m_pState->m_pMem)
            {
                if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > MZ_UINT32_MAX))
                    return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

                if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                    status = TINFL_STATUS_FAILED;
                }
                else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
                {
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)file_stat.m_comp_size);
#endif
                }

                cur_file_ofs += file_stat.m_comp_size;
                out_buf_ofs += file_stat.m_comp_size;
                comp_remaining = 0;
            }
            else
            {
                while (comp_remaining)
                {
                    read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
                    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                    if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
                    {
                        file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);
                    }
#endif

                    if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }

                    cur_file_ofs += read_buf_avail;
                    out_buf_ofs += read_buf_avail;
                    comp_remaining -= read_buf_avail;
                }
            }
        }
        else
        {
            tinfl_decompressor inflator;
            tinfl_init(&inflator);

            if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
            {
                mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
                status = TINFL_STATUS_FAILED;
            }
            else
            {
                do
                {
                    mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
                    size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
                    if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
                    {
                        read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
                        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                        {
                            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                            status = TINFL_STATUS_FAILED;
                            break;
                        }
                        cur_file_ofs += read_buf_avail;
                        comp_remaining -= read_buf_avail;
                        read_buf_ofs = 0;
                    }

                    in_buf_size = (size_t)read_buf_avail;
                    status = tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
                    read_buf_avail -= in_buf_size;
                    read_buf_ofs += in_buf_size;

                    if (out_buf_size)
                    {
                        if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size)
                        {
                            mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                            status = TINFL_STATUS_FAILED;
                            break;
                        }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                        file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
#endif
                        if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size)
                        {
                            mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                            status = TINFL_STATUS_FAILED;
                            break;
                        }
                    }
                } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
            }
        }

        if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
        {
            /* Make sure the entire file was decompressed, and check its CRC. */
            if (out_buf_ofs != file_stat.m_uncomp_size)
            {
                mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
                status = TINFL_STATUS_FAILED;
            }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
            else if (file_crc32 != file_stat.m_crc32)
            {
                mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                status = TINFL_STATUS_FAILED;
            }
#endif
        }

        if (!pZip->m_pState->m_pMem)
            pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

        if (pWrite_buf)
            pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);

        return status == TINFL_STATUS_DONE;
    }

    mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
    {
        mz_uint32 file_index;
        if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
            return MZ_FALSE;

        return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
    }

    mz_zip_reader_extract_iter_state *mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
    {
        mz_zip_reader_extract_iter_state *pState;
        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
        mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

        /* Argument sanity check */
        if ((!pZip) || (!pZip->m_pState))
            return NULL;

        /* Allocate an iterator status structure */
        pState = (mz_zip_reader_extract_iter_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_reader_extract_iter_state));
        if (!pState)
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            return NULL;
        }

        /* Fetch file details */
        if (!mz_zip_reader_file_stat(pZip, file_index, &pState->file_stat))
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
            return NULL;
        }

        /* Encryption and patch files are not supported. */
        if (pState->file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
            return NULL;
        }

        /* This function only supports decompressing stored and deflate. */
        if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (pState->file_stat.m_method != 0) && (pState->file_stat.m_method != MZ_DEFLATED))
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
            return NULL;
        }

        /* Init state - save args */
        pState->pZip = pZip;
        pState->flags = flags;

        /* Init state - reset variables to defaults */
        pState->status = TINFL_STATUS_DONE;
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        pState->file_crc32 = MZ_CRC32_INIT;
#endif
        pState->read_buf_ofs = 0;
        pState->out_buf_ofs = 0;
        pState->pRead_buf = NULL;
        pState->pWrite_buf = NULL;
        pState->out_blk_remain = 0;

        /* Read and parse the local directory entry. */
        pState->cur_file_ofs = pState->file_stat.m_local_header_ofs;
        if (pZip->m_pRead(pZip->m_pIO_opaque, pState->cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
            return NULL;
        }

        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        {
            mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
            return NULL;
        }

        pState->cur_file_ofs += (mz_uint64)(MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
        if ((pState->cur_file_ofs + pState->file_stat.m_comp_size) > pZip->m_archive_size)
        {
            mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
            return NULL;
        }

        /* Decompress the file either directly from memory or from a file input buffer. */
        if (pZip->m_pState->m_pMem)
        {
            pState->pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + pState->cur_file_ofs;
            pState->read_buf_size = pState->read_buf_avail = pState->file_stat.m_comp_size;
            pState->comp_remaining = pState->file_stat.m_comp_size;
        }
        else
        {
            if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
            {
                /* Decompression required, therefore intermediate read buffer required */
                pState->read_buf_size = MZ_MIN(pState->file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
                if (NULL == (pState->pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)pState->read_buf_size)))
                {
                    mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
                    return NULL;
                }
            }
            else
            {
                /* Decompression not required - we will be reading directly into user buffer, no temp buf required */
                pState->read_buf_size = 0;
            }
            pState->read_buf_avail = 0;
            pState->comp_remaining = pState->file_stat.m_comp_size;
        }

        if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
        {
            /* Decompression required, init decompressor */
            tinfl_init(&pState->inflator);

            /* Allocate write buffer */
            if (NULL == (pState->pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
            {
                mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
                if (pState->pRead_buf)
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pState->pRead_buf);
                pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
                return NULL;
            }
        }

        return pState;
    }

    mz_zip_reader_extract_iter_state *mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
    {
        mz_uint32 file_index;

        /* Locate file index by name */
        if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
            return NULL;

        /* Construct iterator */
        return mz_zip_reader_extract_iter_new(pZip, file_index, flags);
    }

    size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state *pState, void *pvBuf, size_t buf_size)
    {
        size_t copied_to_caller = 0;

        /* Argument sanity check */
        if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState) || (!pvBuf))
            return 0;

        if ((pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method))
        {
            /* The file is stored or the caller has requested the compressed data, calc amount to return. */
            copied_to_caller = (size_t)MZ_MIN(buf_size, pState->comp_remaining);

            /* Zip is in memory....or requires reading from a file? */
            if (pState->pZip->m_pState->m_pMem)
            {
                /* Copy data to caller's buffer */
                memcpy(pvBuf, pState->pRead_buf, copied_to_caller);
                pState->pRead_buf = ((mz_uint8 *)pState->pRead_buf) + copied_to_caller;
            }
            else
            {
                /* Read directly into caller's buffer */
                if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pvBuf, copied_to_caller) != copied_to_caller)
                {
                    /* Failed to read all that was asked for, flag failure and alert user */
                    mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
                    pState->status = TINFL_STATUS_FAILED;
                    copied_to_caller = 0;
                }
            }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
            /* Compute CRC if not returning compressed data only */
            if (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
                pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, (const mz_uint8 *)pvBuf, copied_to_caller);
#endif

            /* Advance offsets, dec counters */
            pState->cur_file_ofs += copied_to_caller;
            pState->out_buf_ofs += copied_to_caller;
            pState->comp_remaining -= copied_to_caller;
        }
        else
        {
            do
            {
                /* Calc ptr to write buffer - given current output pos and block size */
                mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pState->pWrite_buf + (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));

                /* Calc max output size - given current output pos and block size */
                size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));

                if (!pState->out_blk_remain)
                {
                    /* Read more data from file if none available (and reading from file) */
                    if ((!pState->read_buf_avail) && (!pState->pZip->m_pState->m_pMem))
                    {
                        /* Calc read size */
                        pState->read_buf_avail = MZ_MIN(pState->read_buf_size, pState->comp_remaining);
                        if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pState->pRead_buf, (size_t)pState->read_buf_avail) != pState->read_buf_avail)
                        {
                            mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
                            pState->status = TINFL_STATUS_FAILED;
                            break;
                        }

                        /* Advance offsets, dec counters */
                        pState->cur_file_ofs += pState->read_buf_avail;
                        pState->comp_remaining -= pState->read_buf_avail;
                        pState->read_buf_ofs = 0;
                    }

                    /* Perform decompression */
                    in_buf_size = (size_t)pState->read_buf_avail;
                    pState->status = tinfl_decompress(&pState->inflator, (const mz_uint8 *)pState->pRead_buf + pState->read_buf_ofs, &in_buf_size, (mz_uint8 *)pState->pWrite_buf, pWrite_buf_cur, &out_buf_size, pState->comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
                    pState->read_buf_avail -= in_buf_size;
                    pState->read_buf_ofs += in_buf_size;

                    /* Update current output block size remaining */
                    pState->out_blk_remain = out_buf_size;
                }

                if (pState->out_blk_remain)
                {
                    /* Calc amount to return. */
                    size_t to_copy = MZ_MIN((buf_size - copied_to_caller), pState->out_blk_remain);

                    /* Copy data to caller's buffer */
                    memcpy((mz_uint8 *)pvBuf + copied_to_caller, pWrite_buf_cur, to_copy);

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                    /* Perform CRC */
                    pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, pWrite_buf_cur, to_copy);
#endif

                    /* Decrement data consumed from block */
                    pState->out_blk_remain -= to_copy;

                    /* Inc output offset, while performing sanity check */
                    if ((pState->out_buf_ofs += to_copy) > pState->file_stat.m_uncomp_size)
                    {
                        mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                        pState->status = TINFL_STATUS_FAILED;
                        break;
                    }

                    /* Increment counter of data copied to caller */
                    copied_to_caller += to_copy;
                }
            } while ((copied_to_caller < buf_size) && ((pState->status == TINFL_STATUS_NEEDS_MORE_INPUT) || (pState->status == TINFL_STATUS_HAS_MORE_OUTPUT)));
        }

        /* Return how many bytes were copied into user buffer */
        return copied_to_caller;
    }

    mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state *pState)
    {
        int status;

        /* Argument sanity check */
        if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState))
            return MZ_FALSE;

        /* Was decompression completed and requested? */
        if ((pState->status == TINFL_STATUS_DONE) && (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
        {
            /* Make sure the entire file was decompressed, and check its CRC. */
            if (pState->out_buf_ofs != pState->file_stat.m_uncomp_size)
            {
                mz_zip_set_error(pState->pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
                pState->status = TINFL_STATUS_FAILED;
            }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
            else if (pState->file_crc32 != pState->file_stat.m_crc32)
            {
                mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                pState->status = TINFL_STATUS_FAILED;
            }
#endif
        }

        /* Free buffers */
        if (!pState->pZip->m_pState->m_pMem)
            pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pRead_buf);
        if (pState->pWrite_buf)
            pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pWrite_buf);

        /* Save status */
        status = pState->status;

        /* Free context */
        pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState);

        return status == TINFL_STATUS_DONE;
    }

#ifndef MINIZ_NO_STDIO
    static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)
    {
        (void)ofs;

        return MZ_FWRITE(pBuf, 1, n, (MZ_FILE *)pOpaque);
    }

    mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)
    {
        mz_bool status;
        mz_zip_archive_file_stat file_stat;
        MZ_FILE *pFile;

        if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
            return MZ_FALSE;

        if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

        pFile = MZ_FOPEN(pDst_filename, "wb");
        if (!pFile)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

        status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);

        if (MZ_FCLOSE(pFile) == EOF)
        {
            if (status)
                mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);

            status = MZ_FALSE;
        }

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
        if (status)
            mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
#endif

        return status;
    }

    mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)
    {
        mz_uint32 file_index;
        if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
            return MZ_FALSE;

        return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
    }

    mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *pFile, mz_uint flags)
    {
        mz_zip_archive_file_stat file_stat;

        if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
            return MZ_FALSE;

        if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

        return mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
    }

    mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags)
    {
        mz_uint32 file_index;
        if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
            return MZ_FALSE;

        return mz_zip_reader_extract_to_cfile(pZip, file_index, pFile, flags);
    }
#endif /* #ifndef MINIZ_NO_STDIO */

    static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
    {
        mz_uint32 *p = (mz_uint32 *)pOpaque;
        (void)file_ofs;
        *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);
        return n;
    }

    mz_bool mz_zip_validate_file(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
    {
        mz_zip_archive_file_stat file_stat;
        mz_zip_internal_state *pState;
        const mz_uint8 *pCentral_dir_header;
        mz_bool found_zip64_ext_data_in_cdir = MZ_FALSE;
        mz_bool found_zip64_ext_data_in_ldir = MZ_FALSE;
        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
        mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
        mz_uint64 local_header_ofs = 0;
        mz_uint32 local_header_filename_len, local_header_extra_len, local_header_crc32;
        mz_uint64 local_header_comp_size, local_header_uncomp_size;
        mz_uint32 uncomp_crc32 = MZ_CRC32_INIT;
        mz_bool has_data_descriptor;
        mz_uint32 local_header_bit_flags;

        mz_zip_array file_data_array;
        mz_zip_array_init(&file_data_array, 1);

        if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (!pZip->m_pRead))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (file_index > pZip->m_total_files)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        pState = pZip->m_pState;

        pCentral_dir_header = mz_zip_get_cdh(pZip, file_index);

        if (!mz_zip_file_stat_internal(pZip, file_index, pCentral_dir_header, &file_stat, &found_zip64_ext_data_in_cdir))
            return MZ_FALSE;

        /* A directory or zero length file */
        if ((file_stat.m_is_directory) || (!file_stat.m_uncomp_size))
            return MZ_TRUE;

        /* Encryption and patch files are not supported. */
        if (file_stat.m_is_encrypted)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

        /* This function only supports stored and deflate. */
        if ((file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

        if (!file_stat.m_is_supported)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

        /* Read and parse the local directory entry. */
        local_header_ofs = file_stat.m_local_header_ofs;
        if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        local_header_filename_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS);
        local_header_extra_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
        local_header_comp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS);
        local_header_uncomp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS);
        local_header_crc32 = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_CRC32_OFS);
        local_header_bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
        has_data_descriptor = (local_header_bit_flags & 8) != 0;

        if (local_header_filename_len != strlen(file_stat.m_filename))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        if ((local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len + local_header_extra_len + file_stat.m_comp_size) > pZip->m_archive_size)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        if (!mz_zip_array_resize(pZip, &file_data_array, MZ_MAX(local_header_filename_len, local_header_extra_len), MZ_FALSE))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            goto handle_failure;
        }

        if (local_header_filename_len)
        {
            if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE, file_data_array.m_p, local_header_filename_len) != local_header_filename_len)
            {
                mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                goto handle_failure;
            }

            /* I've seen 1 archive that had the same pathname, but used backslashes in the local dir and forward slashes in the central dir. Do we care about this? For now, this case will fail validation. */
            if (memcmp(file_stat.m_filename, file_data_array.m_p, local_header_filename_len) != 0)
            {
                mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
                goto handle_failure;
            }
        }

        if ((local_header_extra_len) && ((local_header_comp_size == MZ_UINT32_MAX) || (local_header_uncomp_size == MZ_UINT32_MAX)))
        {
            mz_uint32 extra_size_remaining = local_header_extra_len;
            const mz_uint8 *pExtra_data = (const mz_uint8 *)file_data_array.m_p;

            if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len, file_data_array.m_p, local_header_extra_len) != local_header_extra_len)
            {
                mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                goto handle_failure;
            }

            do
            {
                mz_uint32 field_id, field_data_size, field_total_size;

                if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                {
                    mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                    goto handle_failure;
                }

                field_id = MZ_READ_LE16(pExtra_data);
                field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
                field_total_size = field_data_size + sizeof(mz_uint16) * 2;

                if (field_total_size > extra_size_remaining)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                    goto handle_failure;
                }

                if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                {
                    const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);

                    if (field_data_size < sizeof(mz_uint64) * 2)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                        goto handle_failure;
                    }

                    local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);
                    local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64));

                    found_zip64_ext_data_in_ldir = MZ_TRUE;
                    break;
                }

                pExtra_data += field_total_size;
                extra_size_remaining -= field_total_size;
            } while (extra_size_remaining);
        }

        /* TODO: parse local header extra data when local_header_comp_size is 0xFFFFFFFF! (big_descriptor.zip) */
        /* I've seen zips in the wild with the data descriptor bit set, but proper local header values and bogus data descriptors */
        if ((has_data_descriptor) && (!local_header_comp_size) && (!local_header_crc32))
        {
            mz_uint8 descriptor_buf[32];
            mz_bool has_id;
            const mz_uint8 *pSrc;
            mz_uint32 file_crc32;
            mz_uint64 comp_size = 0, uncomp_size = 0;

            mz_uint32 num_descriptor_uint32s = ((pState->m_zip64) || (found_zip64_ext_data_in_ldir)) ? 6 : 4;

            if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len + local_header_extra_len + file_stat.m_comp_size, descriptor_buf, sizeof(mz_uint32) * num_descriptor_uint32s) != (sizeof(mz_uint32) * num_descriptor_uint32s))
            {
                mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                goto handle_failure;
            }

            has_id = (MZ_READ_LE32(descriptor_buf) == MZ_ZIP_DATA_DESCRIPTOR_ID);
            pSrc = has_id ? (descriptor_buf + sizeof(mz_uint32)) : descriptor_buf;

            file_crc32 = MZ_READ_LE32(pSrc);

            if ((pState->m_zip64) || (found_zip64_ext_data_in_ldir))
            {
                comp_size = MZ_READ_LE64(pSrc + sizeof(mz_uint32));
                uncomp_size = MZ_READ_LE64(pSrc + sizeof(mz_uint32) + sizeof(mz_uint64));
            }
            else
            {
                comp_size = MZ_READ_LE32(pSrc + sizeof(mz_uint32));
                uncomp_size = MZ_READ_LE32(pSrc + sizeof(mz_uint32) + sizeof(mz_uint32));
            }

            if ((file_crc32 != file_stat.m_crc32) || (comp_size != file_stat.m_comp_size) || (uncomp_size != file_stat.m_uncomp_size))
            {
                mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
                goto handle_failure;
            }
        }
        else
        {
            if ((local_header_crc32 != file_stat.m_crc32) || (local_header_comp_size != file_stat.m_comp_size) || (local_header_uncomp_size != file_stat.m_uncomp_size))
            {
                mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
                goto handle_failure;
            }
        }

        mz_zip_array_clear(pZip, &file_data_array);

        if ((flags & MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY) == 0)
        {
            if (!mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_compute_crc32_callback, &uncomp_crc32, 0))
                return MZ_FALSE;

            /* 1 more check to be sure, although the extract checks too. */
            if (uncomp_crc32 != file_stat.m_crc32)
            {
                mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
                return MZ_FALSE;
            }
        }

        return MZ_TRUE;

    handle_failure:
        mz_zip_array_clear(pZip, &file_data_array);
        return MZ_FALSE;
    }

    mz_bool mz_zip_validate_archive(mz_zip_archive *pZip, mz_uint flags)
    {
        mz_zip_internal_state *pState;
        mz_uint32 i;

        if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (!pZip->m_pRead))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        pState = pZip->m_pState;

        /* Basic sanity checks */
        if (!pState->m_zip64)
        {
            if (pZip->m_total_files > MZ_UINT16_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

            if (pZip->m_archive_size > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
        }
        else
        {
            if (pState->m_central_dir.m_size >= MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
        }

        for (i = 0; i < pZip->m_total_files; i++)
        {
            if (MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG & flags)
            {
                mz_uint32 found_index;
                mz_zip_archive_file_stat stat;

                if (!mz_zip_reader_file_stat(pZip, i, &stat))
                    return MZ_FALSE;

                if (!mz_zip_reader_locate_file_v2(pZip, stat.m_filename, NULL, 0, &found_index))
                    return MZ_FALSE;

                /* This check can fail if there are duplicate filenames in the archive (which we don't check for when writing - that's up to the user) */
                if (found_index != i)
                    return mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            }

            if (!mz_zip_validate_file(pZip, i, flags))
                return MZ_FALSE;
        }

        return MZ_TRUE;
    }

    mz_bool mz_zip_validate_mem_archive(const void *pMem, size_t size, mz_uint flags, mz_zip_error *pErr)
    {
        mz_bool success = MZ_TRUE;
        mz_zip_archive zip;
        mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

        if ((!pMem) || (!size))
        {
            if (pErr)
                *pErr = MZ_ZIP_INVALID_PARAMETER;
            return MZ_FALSE;
        }

        mz_zip_zero_struct(&zip);

        if (!mz_zip_reader_init_mem(&zip, pMem, size, flags))
        {
            if (pErr)
                *pErr = zip.m_last_error;
            return MZ_FALSE;
        }

        if (!mz_zip_validate_archive(&zip, flags))
        {
            actual_err = zip.m_last_error;
            success = MZ_FALSE;
        }

        if (!mz_zip_reader_end_internal(&zip, success))
        {
            if (!actual_err)
                actual_err = zip.m_last_error;
            success = MZ_FALSE;
        }

        if (pErr)
            *pErr = actual_err;

        return success;
    }

#ifndef MINIZ_NO_STDIO
    mz_bool mz_zip_validate_file_archive(const char *pFilename, mz_uint flags, mz_zip_error *pErr)
    {
        mz_bool success = MZ_TRUE;
        mz_zip_archive zip;
        mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

        if (!pFilename)
        {
            if (pErr)
                *pErr = MZ_ZIP_INVALID_PARAMETER;
            return MZ_FALSE;
        }

        mz_zip_zero_struct(&zip);

        if (!mz_zip_reader_init_file_v2(&zip, pFilename, flags, 0, 0))
        {
            if (pErr)
                *pErr = zip.m_last_error;
            return MZ_FALSE;
        }

        if (!mz_zip_validate_archive(&zip, flags))
        {
            actual_err = zip.m_last_error;
            success = MZ_FALSE;
        }

        if (!mz_zip_reader_end_internal(&zip, success))
        {
            if (!actual_err)
                actual_err = zip.m_last_error;
            success = MZ_FALSE;
        }

        if (pErr)
            *pErr = actual_err;

        return success;
    }
#endif /* #ifndef MINIZ_NO_STDIO */

    /* ------------------- .ZIP archive writing */

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

    static MZ_FORCEINLINE void mz_write_le16(mz_uint8 *p, mz_uint16 v)
    {
        p[0] = (mz_uint8)v;
        p[1] = (mz_uint8)(v >> 8);
    }
    static MZ_FORCEINLINE void mz_write_le32(mz_uint8 *p, mz_uint32 v)
    {
        p[0] = (mz_uint8)v;
        p[1] = (mz_uint8)(v >> 8);
        p[2] = (mz_uint8)(v >> 16);
        p[3] = (mz_uint8)(v >> 24);
    }
    static MZ_FORCEINLINE void mz_write_le64(mz_uint8 *p, mz_uint64 v)
    {
        mz_write_le32(p, (mz_uint32)v);
        mz_write_le32(p + sizeof(mz_uint32), (mz_uint32)(v >> 32));
    }

#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))
#define MZ_WRITE_LE64(p, v) mz_write_le64((mz_uint8 *)(p), (mz_uint64)(v))

    static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
    {
        mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
        mz_zip_internal_state *pState = pZip->m_pState;
        mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);

        if (!n)
            return 0;

        /* An allocation this big is likely to just fail on 32-bit systems, so don't even go there. */
        if ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF))
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
            return 0;
        }

        if (new_size > pState->m_mem_capacity)
        {
            void *pNew_block;
            size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);

            while (new_capacity < new_size)
                new_capacity *= 2;

            if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))
            {
                mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
                return 0;
            }

            pState->m_pMem = pNew_block;
            pState->m_mem_capacity = new_capacity;
        }
        memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
        pState->m_mem_size = (size_t)new_size;
        return n;
    }

    static mz_bool mz_zip_writer_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
    {
        mz_zip_internal_state *pState;
        mz_bool status = MZ_TRUE;

        if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
        {
            if (set_last_error)
                mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
            return MZ_FALSE;
        }

        pState = pZip->m_pState;
        pZip->m_pState = NULL;
        mz_zip_array_clear(pZip, &pState->m_central_dir);
        mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
        mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
        if (pState->m_pFile)
        {
            if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
            {
                if (MZ_FCLOSE(pState->m_pFile) == EOF)
                {
                    if (set_last_error)
                        mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
                    status = MZ_FALSE;
                }
            }

            pState->m_pFile = NULL;
        }
#endif /* #ifndef MINIZ_NO_STDIO */

        if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
            pState->m_pMem = NULL;
        }

        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
        return status;
    }

    mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags)
    {
        mz_bool zip64 = (flags & MZ_ZIP_FLAG_WRITE_ZIP64) != 0;

        if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
        {
            if (!pZip->m_pRead)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        }

        if (pZip->m_file_offset_alignment)
        {
            /* Ensure user specified file offset alignment is a power of 2. */
            if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        }

        if (!pZip->m_pAlloc)
            pZip->m_pAlloc = miniz_def_alloc_func;
        if (!pZip->m_pFree)
            pZip->m_pFree = miniz_def_free_func;
        if (!pZip->m_pRealloc)
            pZip->m_pRealloc = miniz_def_realloc_func;

        pZip->m_archive_size = existing_size;
        pZip->m_central_directory_file_ofs = 0;
        pZip->m_total_files = 0;

        if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));

        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));

        pZip->m_pState->m_zip64 = zip64;
        pZip->m_pState->m_zip64_has_extended_info_fields = zip64;

        pZip->m_zip_type = MZ_ZIP_TYPE_USER;
        pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;

        return MZ_TRUE;
    }

    mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)
    {
        return mz_zip_writer_init_v2(pZip, existing_size, 0);
    }

    mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags)
    {
        pZip->m_pWrite = mz_zip_heap_write_func;
        pZip->m_pNeeds_keepalive = NULL;

        if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
            pZip->m_pRead = mz_zip_mem_read_func;

        pZip->m_pIO_opaque = pZip;

        if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
            return MZ_FALSE;

        pZip->m_zip_type = MZ_ZIP_TYPE_HEAP;

        if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning)))
        {
            if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size)))
            {
                mz_zip_writer_end_internal(pZip, MZ_FALSE);
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }
            pZip->m_pState->m_mem_capacity = initial_allocation_size;
        }

        return MZ_TRUE;
    }

    mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)
    {
        return mz_zip_writer_init_heap_v2(pZip, size_to_reserve_at_beginning, initial_allocation_size, 0);
    }

#ifndef MINIZ_NO_STDIO
    static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
    {
        mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
        mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);

        file_ofs += pZip->m_pState->m_file_archive_start_ofs;

        if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
            return 0;
        }

        return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
    }

    mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)
    {
        return mz_zip_writer_init_file_v2(pZip, pFilename, size_to_reserve_at_beginning, 0);
    }

    mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags)
    {
        MZ_FILE *pFile;

        pZip->m_pWrite = mz_zip_file_write_func;
        pZip->m_pNeeds_keepalive = NULL;

        if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
            pZip->m_pRead = mz_zip_file_read_func;

        pZip->m_pIO_opaque = pZip;

        if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
            return MZ_FALSE;

        if (NULL == (pFile = MZ_FOPEN(pFilename, (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING) ? "w+b" : "wb")))
        {
            mz_zip_writer_end(pZip);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
        }

        pZip->m_pState->m_pFile = pFile;
        pZip->m_zip_type = MZ_ZIP_TYPE_FILE;

        if (size_to_reserve_at_beginning)
        {
            mz_uint64 cur_ofs = 0;
            char buf[4096];

            MZ_CLEAR_ARR(buf);

            do
            {
                size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
                if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n)
                {
                    mz_zip_writer_end(pZip);
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
                }
                cur_ofs += n;
                size_to_reserve_at_beginning -= n;
            } while (size_to_reserve_at_beginning);
        }

        return MZ_TRUE;
    }

    mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags)
    {
        pZip->m_pWrite = mz_zip_file_write_func;
        pZip->m_pNeeds_keepalive = NULL;

        if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
            pZip->m_pRead = mz_zip_file_read_func;

        pZip->m_pIO_opaque = pZip;

        if (!mz_zip_writer_init_v2(pZip, 0, flags))
            return MZ_FALSE;

        pZip->m_pState->m_pFile = pFile;
        pZip->m_pState->m_file_archive_start_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
        pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;

        return MZ_TRUE;
    }
#endif /* #ifndef MINIZ_NO_STDIO */

    mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
    {
        mz_zip_internal_state *pState;

        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (flags & MZ_ZIP_FLAG_WRITE_ZIP64)
        {
            /* We don't support converting a non-zip64 file to zip64 - this seems like more trouble than it's worth. (What about the existing 32-bit data descriptors that could follow the compressed data?) */
            if (!pZip->m_pState->m_zip64)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        }

        /* No sense in trying to write to an archive that's already at the support max size */
        if (pZip->m_pState->m_zip64)
        {
            if (pZip->m_total_files == MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
        }
        else
        {
            if (pZip->m_total_files == MZ_UINT16_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

            if ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
        }

        pState = pZip->m_pState;

        if (pState->m_pFile)
        {
#ifdef MINIZ_NO_STDIO
            (void)pFilename;
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
#else
            if (pZip->m_pIO_opaque != pZip)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

            if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE &&
                !(flags & MZ_ZIP_FLAG_READ_ALLOW_WRITING) )
            {
                if (!pFilename)
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

                /* Archive is being read from stdio and was originally opened only for reading. Try to reopen as writable. */
                if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile)))
                {
                    /* The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it. */
                    mz_zip_reader_end_internal(pZip, MZ_FALSE);
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
                }
            }

            pZip->m_pWrite = mz_zip_file_write_func;
            pZip->m_pNeeds_keepalive = NULL;
#endif /* #ifdef MINIZ_NO_STDIO */
        }
        else if (pState->m_pMem)
        {
            /* Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback. */
            if (pZip->m_pIO_opaque != pZip)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

            pState->m_mem_capacity = pState->m_mem_size;
            pZip->m_pWrite = mz_zip_heap_write_func;
            pZip->m_pNeeds_keepalive = NULL;
        }
        /* Archive is being read via a user provided read function - make sure the user has specified a write function too. */
        else if (!pZip->m_pWrite)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        /* Start writing new files at the archive's current central directory location. */
        /* TODO: We could add a flag that lets the user start writing immediately AFTER the existing central dir - this would be safer. */
        pZip->m_archive_size = pZip->m_central_directory_file_ofs;
        pZip->m_central_directory_file_ofs = 0;

        /* Clear the sorted central dir offsets, they aren't useful or maintained now. */
        /* Even though we're now in write mode, files can still be extracted and verified, but file locates will be slow. */
        /* TODO: We could easily maintain the sorted central directory offsets. */
        mz_zip_array_clear(pZip, &pZip->m_pState->m_sorted_central_dir_offsets);

        pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;

        return MZ_TRUE;
    }

    mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)
    {
        return mz_zip_writer_init_from_reader_v2(pZip, pFilename, 0);
    }

    /* TODO: pArchive_name is a terrible name here! */
    mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)
    {
        return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
    }

    typedef struct
    {
        mz_zip_archive *m_pZip;
        mz_uint64 m_cur_archive_file_ofs;
        mz_uint64 m_comp_size;
    } mz_zip_writer_add_state;

    static mz_bool mz_zip_writer_add_put_buf_callback(const void *pBuf, int len, void *pUser)
    {
        mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
        if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len)
            return MZ_FALSE;

        pState->m_cur_archive_file_ofs += len;
        pState->m_comp_size += len;
        return MZ_TRUE;
    }

#define MZ_ZIP64_MAX_LOCAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 2)
#define MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 3)
    static mz_uint32 mz_zip_writer_create_zip64_extra_data(mz_uint8 *pBuf, mz_uint64 *pUncomp_size, mz_uint64 *pComp_size, mz_uint64 *pLocal_header_ofs)
    {
        mz_uint8 *pDst = pBuf;
        mz_uint32 field_size = 0;

        MZ_WRITE_LE16(pDst + 0, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
        MZ_WRITE_LE16(pDst + 2, 0);
        pDst += sizeof(mz_uint16) * 2;

        if (pUncomp_size)
        {
            MZ_WRITE_LE64(pDst, *pUncomp_size);
            pDst += sizeof(mz_uint64);
            field_size += sizeof(mz_uint64);
        }

        if (pComp_size)
        {
            MZ_WRITE_LE64(pDst, *pComp_size);
            pDst += sizeof(mz_uint64);
            field_size += sizeof(mz_uint64);
        }

        if (pLocal_header_ofs)
        {
            MZ_WRITE_LE64(pDst, *pLocal_header_ofs);
            pDst += sizeof(mz_uint64);
            field_size += sizeof(mz_uint64);
        }

        MZ_WRITE_LE16(pBuf + 2, field_size);

        return (mz_uint32)(pDst - pBuf);
    }

    static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)
    {
        (void)pZip;
        memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
        return MZ_TRUE;
    }

    static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst,
                                                           mz_uint16 filename_size, mz_uint16 extra_size, mz_uint16 comment_size,
                                                           mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
                                                           mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
                                                           mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
    {
        (void)pZip;
        memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_MIN(local_header_ofs, MZ_UINT32_MAX));
        return MZ_TRUE;
    }

    static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size,
                                                    const void *pExtra, mz_uint16 extra_size, const void *pComment, mz_uint16 comment_size,
                                                    mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
                                                    mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
                                                    mz_uint64 local_header_ofs, mz_uint32 ext_attributes,
                                                    const char *user_extra_data, mz_uint user_extra_data_len)
    {
        mz_zip_internal_state *pState = pZip->m_pState;
        mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
        size_t orig_central_dir_size = pState->m_central_dir.m_size;
        mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];

        if (!pZip->m_pState->m_zip64)
        {
            if (local_header_ofs > 0xFFFFFFFF)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
        }

        /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
        if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + user_extra_data_len + comment_size) >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

        if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, (mz_uint16)(extra_size + user_extra_data_len), comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
            (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size)) ||
            (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size)) ||
            (!mz_zip_array_push_back(pZip, &pState->m_central_dir, user_extra_data, user_extra_data_len)) ||
            (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size)) ||
            (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1)))
        {
            /* Try to resize the central directory array back into its original state. */
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        return MZ_TRUE;
    }

    static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name)
    {
        /* Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes. */
        if (*pArchive_name == '/')
            return MZ_FALSE;

        /* Making sure the name does not contain drive letters or DOS style backward slashes is the responsibility of the program using miniz*/

        return MZ_TRUE;
    }

    static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)
    {
        mz_uint32 n;
        if (!pZip->m_file_offset_alignment)
            return 0;
        n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
        return (mz_uint)((pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1));
    }

    static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)
    {
        char buf[4096];
        memset(buf, 0, MZ_MIN(sizeof(buf), n));
        while (n)
        {
            mz_uint32 s = MZ_MIN(sizeof(buf), n);
            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_file_ofs += s;
            n -= s;
        }
        return MZ_TRUE;
    }

    mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                     mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)
    {
        return mz_zip_writer_add_mem_ex_v2(pZip, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, uncomp_size, uncomp_crc32, NULL, NULL, 0, NULL, 0);
    }

    mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size,
                                        mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified,
                                        const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
    {
        mz_uint16 method = 0, dos_time = 0, dos_date = 0;
        mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
        mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
        size_t archive_name_size;
        mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
        tdefl_compressor *pComp = NULL;
        mz_bool store_data_uncompressed;
        mz_zip_internal_state *pState;
        mz_uint8 *pExtra_data = NULL;
        mz_uint32 extra_size = 0;
        mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
        mz_uint16 bit_flags = 0;

        if ((int)level_and_flags < 0)
            level_and_flags = MZ_DEFAULT_LEVEL;

        if (uncomp_size || (buf_size && !(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
            bit_flags |= MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;

        if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
            bit_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;

        level = level_and_flags & 0xF;
        store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));

        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        pState = pZip->m_pState;

        if (pState->m_zip64)
        {
            if (pZip->m_total_files == MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
        }
        else
        {
            if (pZip->m_total_files == MZ_UINT16_MAX)
            {
                pState->m_zip64 = MZ_TRUE;
                /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
            }
            if (((mz_uint64)buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
            {
                pState->m_zip64 = MZ_TRUE;
                /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
            }
        }

        if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (!mz_zip_writer_validate_archive_name(pArchive_name))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

#ifndef MINIZ_NO_TIME
        if (last_modified != NULL)
        {
            mz_zip_time_t_to_dos_time(*last_modified, &dos_time, &dos_date);
        }
        else
        {
            MZ_TIME_T cur_time;
            time(&cur_time);
            mz_zip_time_t_to_dos_time(cur_time, &dos_time, &dos_date);
        }
#else
        (void)last_modified;
#endif /* #ifndef MINIZ_NO_TIME */

        if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
        {
            uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size);
            uncomp_size = buf_size;
            if (uncomp_size <= 3)
            {
                level = 0;
                store_data_uncompressed = MZ_TRUE;
            }
        }

        archive_name_size = strlen(pArchive_name);
        if (archive_name_size > MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

        num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

        /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
        if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

        if (!pState->m_zip64)
        {
            /* Bail early if the archive would obviously become too large */
            if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + user_extra_data_len +
                 pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + user_extra_data_central_len + MZ_ZIP_DATA_DESCRIPTER_SIZE32) > 0xFFFFFFFF)
            {
                pState->m_zip64 = MZ_TRUE;
                /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
            }
        }

        if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/'))
        {
            /* Set DOS Subdirectory attribute bit. */
            ext_attributes |= MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG;

            /* Subdirectories cannot contain data. */
            if ((buf_size) || (uncomp_size))
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        }

        /* Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.) */
        if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + (pState->m_zip64 ? MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE : 0))) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        if ((!store_data_uncompressed) && (buf_size))
        {
            if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return MZ_FALSE;
        }

        local_dir_header_ofs += num_alignment_padding_bytes;
        if (pZip->m_file_offset_alignment)
        {
            MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
        }
        cur_archive_file_ofs += num_alignment_padding_bytes;

        MZ_CLEAR_ARR(local_dir_header);

        if (!store_data_uncompressed || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
        {
            method = MZ_DEFLATED;
        }

        if (pState->m_zip64)
        {
            if (uncomp_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
            {
                pExtra_data = extra_data;
                extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                                   (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
            }

            if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len), 0, 0, 0, method, bit_flags, dos_time, dos_date))
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_file_ofs += sizeof(local_dir_header);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }
            cur_archive_file_ofs += archive_name_size;

            if (pExtra_data != NULL)
            {
                if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

                cur_archive_file_ofs += extra_size;
            }
        }
        else
        {
            if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
            if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)user_extra_data_len, 0, 0, 0, method, bit_flags, dos_time, dos_date))
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_file_ofs += sizeof(local_dir_header);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }
            cur_archive_file_ofs += archive_name_size;
        }

        if (user_extra_data_len > 0)
        {
            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_file_ofs += user_extra_data_len;
        }

        if (store_data_uncompressed)
        {
            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }

            cur_archive_file_ofs += buf_size;
            comp_size = buf_size;
        }
        else if (buf_size)
        {
            mz_zip_writer_add_state state;

            state.m_pZip = pZip;
            state.m_cur_archive_file_ofs = cur_archive_file_ofs;
            state.m_comp_size = 0;

            if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) ||
                (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
                return mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
            }

            comp_size = state.m_comp_size;
            cur_archive_file_ofs = state.m_cur_archive_file_ofs;
        }

        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        pComp = NULL;

        if (uncomp_size)
        {
            mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
            mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;

            MZ_ASSERT(bit_flags & MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR);

            MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
            MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
            if (pExtra_data == NULL)
            {
                if (comp_size > MZ_UINT32_MAX)
                    return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

                MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
                MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
            }
            else
            {
                MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
                MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
                local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
            }

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
                return MZ_FALSE;

            cur_archive_file_ofs += local_dir_footer_size;
        }

        if (pExtra_data != NULL)
        {
            extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, (mz_uint16)extra_size, pComment,
                                              comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
                                              user_extra_data_central, user_extra_data_central_len))
            return MZ_FALSE;

        pZip->m_total_files++;
        pZip->m_archive_size = cur_archive_file_ofs;

        return MZ_TRUE;
    }

    mz_bool mz_zip_writer_add_read_buf_callback(mz_zip_archive *pZip, const char *pArchive_name, mz_file_read_func read_callback, void *callback_opaque, mz_uint64 max_size, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                                const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
    {
        mz_uint16 gen_flags;
        mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
        mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
        mz_uint64 local_dir_header_ofs, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0, comp_size = 0;
        size_t archive_name_size;
        mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
        mz_uint8 *pExtra_data = NULL;
        mz_uint32 extra_size = 0;
        mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
        mz_zip_internal_state *pState;
        mz_uint64 file_ofs = 0, cur_archive_header_file_ofs;

        if ((int)level_and_flags < 0)
            level_and_flags = MZ_DEFAULT_LEVEL;
        level = level_and_flags & 0xF;

        gen_flags = (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE) ? 0 : MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;

        if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
            gen_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;

        /* Sanity checks */
        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        pState = pZip->m_pState;

        if ((!pState->m_zip64) && (max_size > MZ_UINT32_MAX))
        {
            /* Source file is too large for non-zip64 */
            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
            pState->m_zip64 = MZ_TRUE;
        }

        /* We could support this, but why? */
        if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (!mz_zip_writer_validate_archive_name(pArchive_name))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

        if (pState->m_zip64)
        {
            if (pZip->m_total_files == MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
        }
        else
        {
            if (pZip->m_total_files == MZ_UINT16_MAX)
            {
                pState->m_zip64 = MZ_TRUE;
                /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
            }
        }

        archive_name_size = strlen(pArchive_name);
        if (archive_name_size > MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

        num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

        /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
        if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

        if (!pState->m_zip64)
        {
            /* Bail early if the archive would obviously become too large */
            if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + user_extra_data_len + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 1024 + MZ_ZIP_DATA_DESCRIPTER_SIZE32 + user_extra_data_central_len) > 0xFFFFFFFF)
            {
                pState->m_zip64 = MZ_TRUE;
                /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
            }
        }

#ifndef MINIZ_NO_TIME
        if (pFile_time)
        {
            mz_zip_time_t_to_dos_time(*pFile_time, &dos_time, &dos_date);
        }
#else
        (void)pFile_time;
#endif

        if (max_size <= 3)
            level = 0;

        if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
        {
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_archive_file_ofs += num_alignment_padding_bytes;
        local_dir_header_ofs = cur_archive_file_ofs;

        if (pZip->m_file_offset_alignment)
        {
            MZ_ASSERT((cur_archive_file_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
        }

        if (max_size && level)
        {
            method = MZ_DEFLATED;
        }

        MZ_CLEAR_ARR(local_dir_header);
        if (pState->m_zip64)
        {
            if (max_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
            {
                pExtra_data = extra_data;
                if (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE)
                    extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (max_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                                       (max_size >= MZ_UINT32_MAX) ? &comp_size : NULL,
                                                                       (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
                else
                    extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, NULL,
                                                                       NULL,
                                                                       (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
            }

            if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len), 0, 0, 0, method, gen_flags, dos_time, dos_date))
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_file_ofs += sizeof(local_dir_header);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
            {
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }

            cur_archive_file_ofs += archive_name_size;

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_file_ofs += extra_size;
        }
        else
        {
            if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
            if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)user_extra_data_len, 0, 0, 0, method, gen_flags, dos_time, dos_date))
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_file_ofs += sizeof(local_dir_header);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
            {
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }

            cur_archive_file_ofs += archive_name_size;
        }

        if (user_extra_data_len > 0)
        {
            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_file_ofs += user_extra_data_len;
        }

        if (max_size)
        {
            void *pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
            if (!pRead_buf)
            {
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            if (!level)
            {
                while (1)
                {
                    size_t n = read_callback(callback_opaque, file_ofs, pRead_buf, MZ_ZIP_MAX_IO_BUF_SIZE);
                    if (n == 0)
                        break;

                    if ((n > MZ_ZIP_MAX_IO_BUF_SIZE) || (file_ofs + n > max_size))
                    {
                        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                    }
                    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n)
                    {
                        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
                    }
                    file_ofs += n;
                    uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
                    cur_archive_file_ofs += n;
                }
                uncomp_size = file_ofs;
                comp_size = uncomp_size;
            }
            else
            {
                mz_bool result = MZ_FALSE;
                mz_zip_writer_add_state state;
                tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
                if (!pComp)
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                    return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
                }

                state.m_pZip = pZip;
                state.m_cur_archive_file_ofs = cur_archive_file_ofs;
                state.m_comp_size = 0;

                if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY)
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                    return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
                }

                for (;;)
                {
                    tdefl_status status;
                    tdefl_flush flush = TDEFL_NO_FLUSH;

                    size_t n = read_callback(callback_opaque, file_ofs, pRead_buf, MZ_ZIP_MAX_IO_BUF_SIZE);
                    if ((n > MZ_ZIP_MAX_IO_BUF_SIZE) || (file_ofs + n > max_size))
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                        break;
                    }

                    file_ofs += n;
                    uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);

                    if (pZip->m_pNeeds_keepalive != NULL && pZip->m_pNeeds_keepalive(pZip->m_pIO_opaque))
                        flush = TDEFL_FULL_FLUSH;

                    if (n == 0)
                        flush = TDEFL_FINISH;

                    status = tdefl_compress_buffer(pComp, pRead_buf, n, flush);
                    if (status == TDEFL_STATUS_DONE)
                    {
                        result = MZ_TRUE;
                        break;
                    }
                    else if (status != TDEFL_STATUS_OKAY)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
                        break;
                    }
                }

                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);

                if (!result)
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                    return MZ_FALSE;
                }

                uncomp_size = file_ofs;
                comp_size = state.m_comp_size;
                cur_archive_file_ofs = state.m_cur_archive_file_ofs;
            }

            pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        }

        if (!(level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE))
        {
            mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
            mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;

            MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
            MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
            if (pExtra_data == NULL)
            {
                if (comp_size > MZ_UINT32_MAX)
                    return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

                MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
                MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
            }
            else
            {
                MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
                MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
                local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
            }

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
                return MZ_FALSE;

            cur_archive_file_ofs += local_dir_footer_size;
        }

        if (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE)
        {
            if (pExtra_data != NULL)
            {
                extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (max_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                                   (max_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
            }

            if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header,
                                                       (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len),
                                                       (max_size >= MZ_UINT32_MAX) ? MZ_UINT32_MAX : uncomp_size,
                                                       (max_size >= MZ_UINT32_MAX) ? MZ_UINT32_MAX : comp_size,
                                                       uncomp_crc32, method, gen_flags, dos_time, dos_date))
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

            cur_archive_header_file_ofs = local_dir_header_ofs;

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            if (pExtra_data != NULL)
            {
                cur_archive_header_file_ofs += sizeof(local_dir_header);

                if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
                {
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
                }

                cur_archive_header_file_ofs += archive_name_size;

                if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, extra_data, extra_size) != extra_size)
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

                cur_archive_header_file_ofs += extra_size;
            }
        }

        if (pExtra_data != NULL)
        {
            extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, (mz_uint16)extra_size, pComment, comment_size,
                                              uncomp_size, comp_size, uncomp_crc32, method, gen_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
                                              user_extra_data_central, user_extra_data_central_len))
            return MZ_FALSE;

        pZip->m_total_files++;
        pZip->m_archive_size = cur_archive_file_ofs;

        return MZ_TRUE;
    }

#ifndef MINIZ_NO_STDIO

    static size_t mz_file_read_func_stdio(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
    {
        MZ_FILE *pSrc_file = (MZ_FILE *)pOpaque;
        mz_int64 cur_ofs = MZ_FTELL64(pSrc_file);

        if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pSrc_file, (mz_int64)file_ofs, SEEK_SET))))
            return 0;

        return MZ_FREAD(pBuf, 1, n, pSrc_file);
    }

    mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 max_size, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                    const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
    {
        return mz_zip_writer_add_read_buf_callback(pZip, pArchive_name, mz_file_read_func_stdio, pSrc_file, max_size, pFile_time, pComment, comment_size, level_and_flags,
                                                   user_extra_data, user_extra_data_len, user_extra_data_central, user_extra_data_central_len);
    }

    mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
    {
        MZ_FILE *pSrc_file = NULL;
        mz_uint64 uncomp_size = 0;
        MZ_TIME_T file_modified_time;
        MZ_TIME_T *pFile_time = NULL;
        mz_bool status;

        memset(&file_modified_time, 0, sizeof(file_modified_time));

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
        pFile_time = &file_modified_time;
        if (!mz_zip_get_file_modified_time(pSrc_filename, &file_modified_time))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_STAT_FAILED);
#endif

        pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
        if (!pSrc_file)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

        MZ_FSEEK64(pSrc_file, 0, SEEK_END);
        uncomp_size = MZ_FTELL64(pSrc_file);
        MZ_FSEEK64(pSrc_file, 0, SEEK_SET);

        status = mz_zip_writer_add_cfile(pZip, pArchive_name, pSrc_file, uncomp_size, pFile_time, pComment, comment_size, level_and_flags, NULL, 0, NULL, 0);

        MZ_FCLOSE(pSrc_file);

        return status;
    }
#endif /* #ifndef MINIZ_NO_STDIO */

    static mz_bool mz_zip_writer_update_zip64_extension_block(mz_zip_array *pNew_ext, mz_zip_archive *pZip, const mz_uint8 *pExt, mz_uint32 ext_len, mz_uint64 *pComp_size, mz_uint64 *pUncomp_size, mz_uint64 *pLocal_header_ofs, mz_uint32 *pDisk_start)
    {
        /* + 64 should be enough for any new zip64 data */
        if (!mz_zip_array_reserve(pZip, pNew_ext, ext_len + 64, MZ_FALSE))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        mz_zip_array_resize(pZip, pNew_ext, 0, MZ_FALSE);

        if ((pUncomp_size) || (pComp_size) || (pLocal_header_ofs) || (pDisk_start))
        {
            mz_uint8 new_ext_block[64];
            mz_uint8 *pDst = new_ext_block;
            mz_write_le16(pDst, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
            mz_write_le16(pDst + sizeof(mz_uint16), 0);
            pDst += sizeof(mz_uint16) * 2;

            if (pUncomp_size)
            {
                mz_write_le64(pDst, *pUncomp_size);
                pDst += sizeof(mz_uint64);
            }

            if (pComp_size)
            {
                mz_write_le64(pDst, *pComp_size);
                pDst += sizeof(mz_uint64);
            }

            if (pLocal_header_ofs)
            {
                mz_write_le64(pDst, *pLocal_header_ofs);
                pDst += sizeof(mz_uint64);
            }

            if (pDisk_start)
            {
                mz_write_le32(pDst, *pDisk_start);
                pDst += sizeof(mz_uint32);
            }

            mz_write_le16(new_ext_block + sizeof(mz_uint16), (mz_uint16)((pDst - new_ext_block) - sizeof(mz_uint16) * 2));

            if (!mz_zip_array_push_back(pZip, pNew_ext, new_ext_block, pDst - new_ext_block))
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if ((pExt) && (ext_len))
        {
            mz_uint32 extra_size_remaining = ext_len;
            const mz_uint8 *pExtra_data = pExt;

            do
            {
                mz_uint32 field_id, field_data_size, field_total_size;

                if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                field_id = MZ_READ_LE16(pExtra_data);
                field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
                field_total_size = field_data_size + sizeof(mz_uint16) * 2;

                if (field_total_size > extra_size_remaining)
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                if (field_id != MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                {
                    if (!mz_zip_array_push_back(pZip, pNew_ext, pExtra_data, field_total_size))
                        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
                }

                pExtra_data += field_total_size;
                extra_size_remaining -= field_total_size;
            } while (extra_size_remaining);
        }

        return MZ_TRUE;
    }

    /* TODO: This func is now pretty freakin complex due to zip64, split it up? */
    mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index)
    {
        mz_uint n, bit_flags, num_alignment_padding_bytes, src_central_dir_following_data_size;
        mz_uint64 src_archive_bytes_remaining, local_dir_header_ofs;
        mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
        mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
        mz_uint8 new_central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
        size_t orig_central_dir_size;
        mz_zip_internal_state *pState;
        void *pBuf;
        const mz_uint8 *pSrc_central_header;
        mz_zip_archive_file_stat src_file_stat;
        mz_uint32 src_filename_len, src_comment_len, src_ext_len;
        mz_uint32 local_header_filename_size, local_header_extra_len;
        mz_uint64 local_header_comp_size, local_header_uncomp_size;
        mz_bool found_zip64_ext_data_in_ldir = MZ_FALSE;

        /* Sanity checks */
        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pSource_zip->m_pRead))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        pState = pZip->m_pState;

        /* Don't support copying files from zip64 archives to non-zip64, even though in some cases this is possible */
        if ((pSource_zip->m_pState->m_zip64) && (!pZip->m_pState->m_zip64))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        /* Get pointer to the source central dir header and crack it */
        if (NULL == (pSrc_central_header = mz_zip_get_cdh(pSource_zip, src_file_index)))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_SIG_OFS) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        src_filename_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        src_comment_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
        src_ext_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS);
        src_central_dir_following_data_size = src_filename_len + src_ext_len + src_comment_len;

        /* TODO: We don't support central dir's >= MZ_UINT32_MAX bytes right now (+32 fudge factor in case we need to add more extra data) */
        if ((pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + 32) >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

        num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

        if (!pState->m_zip64)
        {
            if (pZip->m_total_files == MZ_UINT16_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
        }
        else
        {
            /* TODO: Our zip64 support still has some 32-bit limits that may not be worth fixing. */
            if (pZip->m_total_files == MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
        }

        if (!mz_zip_file_stat_internal(pSource_zip, src_file_index, pSrc_central_header, &src_file_stat, NULL))
            return MZ_FALSE;

        cur_src_file_ofs = src_file_stat.m_local_header_ofs;
        cur_dst_file_ofs = pZip->m_archive_size;

        /* Read the source archive's local dir header */
        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

        /* Compute the total size we need to copy (filename+extra data+compressed data) */
        local_header_filename_size = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS);
        local_header_extra_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
        local_header_comp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS);
        local_header_uncomp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS);
        src_archive_bytes_remaining = src_file_stat.m_comp_size + local_header_filename_size + local_header_extra_len;

        /* Try to find a zip64 extended information field */
        if ((local_header_extra_len) && ((local_header_comp_size == MZ_UINT32_MAX) || (local_header_uncomp_size == MZ_UINT32_MAX)))
        {
            mz_zip_array file_data_array;
            const mz_uint8 *pExtra_data;
            mz_uint32 extra_size_remaining = local_header_extra_len;

            mz_zip_array_init(&file_data_array, 1);
            if (!mz_zip_array_resize(pZip, &file_data_array, local_header_extra_len, MZ_FALSE))
            {
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, src_file_stat.m_local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_size, file_data_array.m_p, local_header_extra_len) != local_header_extra_len)
            {
                mz_zip_array_clear(pZip, &file_data_array);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            }

            pExtra_data = (const mz_uint8 *)file_data_array.m_p;

            do
            {
                mz_uint32 field_id, field_data_size, field_total_size;

                if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                {
                    mz_zip_array_clear(pZip, &file_data_array);
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                }

                field_id = MZ_READ_LE16(pExtra_data);
                field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
                field_total_size = field_data_size + sizeof(mz_uint16) * 2;

                if (field_total_size > extra_size_remaining)
                {
                    mz_zip_array_clear(pZip, &file_data_array);
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                }

                if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                {
                    const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);

                    if (field_data_size < sizeof(mz_uint64) * 2)
                    {
                        mz_zip_array_clear(pZip, &file_data_array);
                        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                    }

                    local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);
                    local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64)); /* may be 0 if there's a descriptor */

                    found_zip64_ext_data_in_ldir = MZ_TRUE;
                    break;
                }

                pExtra_data += field_total_size;
                extra_size_remaining -= field_total_size;
            } while (extra_size_remaining);

            mz_zip_array_clear(pZip, &file_data_array);
        }

        if (!pState->m_zip64)
        {
            /* Try to detect if the new archive will most likely wind up too big and bail early (+(sizeof(mz_uint32) * 4) is for the optional descriptor which could be present, +64 is a fudge factor). */
            /* We also check when the archive is finalized so this doesn't need to be perfect. */
            mz_uint64 approx_new_archive_size = cur_dst_file_ofs + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + src_archive_bytes_remaining + (sizeof(mz_uint32) * 4) +
                                                pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 64;

            if (approx_new_archive_size >= MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
        }

        /* Write dest archive padding */
        if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))
            return MZ_FALSE;

        cur_dst_file_ofs += num_alignment_padding_bytes;

        local_dir_header_ofs = cur_dst_file_ofs;
        if (pZip->m_file_offset_alignment)
        {
            MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
        }

        /* The original zip's local header+ext block doesn't change, even with zip64, so we can just copy it over to the dest zip */
        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

        /* Copy over the source archive bytes to the dest archive, also ensure we have enough buf space to handle optional data descriptor */
        if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)MZ_MAX(32U, MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining)))))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        while (src_archive_bytes_remaining)
        {
            n = (mz_uint)MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining);
            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            }
            cur_src_file_ofs += n;

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }
            cur_dst_file_ofs += n;

            src_archive_bytes_remaining -= n;
        }

        /* Now deal with the optional data descriptor */
        bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
        if (bit_flags & 8)
        {
            /* Copy data descriptor */
            if ((pSource_zip->m_pState->m_zip64) || (found_zip64_ext_data_in_ldir))
            {
                /* src is zip64, dest must be zip64 */

                /* name			uint32_t's */
                /* id				1 (optional in zip64?) */
                /* crc			1 */
                /* comp_size	2 */
                /* uncomp_size 2 */
                if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, (sizeof(mz_uint32) * 6)) != (sizeof(mz_uint32) * 6))
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                }

                n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID) ? 6 : 5);
            }
            else
            {
                /* src is NOT zip64 */
                mz_bool has_id;

                if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4)
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                }

                has_id = (MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID);

                if (pZip->m_pState->m_zip64)
                {
                    /* dest is zip64, so upgrade the data descriptor */
                    const mz_uint8 *pSrc_descriptor = (const mz_uint8 *)pBuf + (has_id ? sizeof(mz_uint32) : 0);
                    const mz_uint32 src_crc32 = MZ_READ_LE32(pSrc_descriptor);
                    const mz_uint64 src_comp_size = MZ_READ_LE32(pSrc_descriptor + sizeof(mz_uint32));
                    const mz_uint64 src_uncomp_size = MZ_READ_LE32(pSrc_descriptor + 2 * sizeof(mz_uint32));

                    mz_write_le32((mz_uint8 *)pBuf, MZ_ZIP_DATA_DESCRIPTOR_ID);
                    mz_write_le32((mz_uint8 *)pBuf + sizeof(mz_uint32) * 1, src_crc32);
                    mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 2, src_comp_size);
                    mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 4, src_uncomp_size);

                    n = sizeof(mz_uint32) * 6;
                }
                else
                {
                    /* dest is NOT zip64, just copy it as-is */
                    n = sizeof(mz_uint32) * (has_id ? 4 : 3);
                }
            }

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }

            cur_src_file_ofs += n;
            cur_dst_file_ofs += n;
        }
        pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);

        /* Finally, add the new central dir header */
        orig_central_dir_size = pState->m_central_dir.m_size;

        memcpy(new_central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);

        if (pState->m_zip64)
        {
            /* This is the painful part: We need to write a new central dir header + ext block with updated zip64 fields, and ensure the old fields (if any) are not included. */
            const mz_uint8 *pSrc_ext = pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len;
            mz_zip_array new_ext_block;

            mz_zip_array_init(&new_ext_block, sizeof(mz_uint8));

            MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_UINT32_MAX);
            MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_UINT32_MAX);
            MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_UINT32_MAX);

            if (!mz_zip_writer_update_zip64_extension_block(&new_ext_block, pZip, pSrc_ext, src_ext_len, &src_file_stat.m_comp_size, &src_file_stat.m_uncomp_size, &local_dir_header_ofs, NULL))
            {
                mz_zip_array_clear(pZip, &new_ext_block);
                return MZ_FALSE;
            }

            MZ_WRITE_LE16(new_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS, new_ext_block.m_size);

            if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
            {
                mz_zip_array_clear(pZip, &new_ext_block);
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_filename_len))
            {
                mz_zip_array_clear(pZip, &new_ext_block);
                mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_ext_block.m_p, new_ext_block.m_size))
            {
                mz_zip_array_clear(pZip, &new_ext_block);
                mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len + src_ext_len, src_comment_len))
            {
                mz_zip_array_clear(pZip, &new_ext_block);
                mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            mz_zip_array_clear(pZip, &new_ext_block);
        }
        else
        {
            /* sanity checks */
            if (cur_dst_file_ofs > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

            if (local_dir_header_ofs >= MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

            MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);

            if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

            if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_central_dir_following_data_size))
            {
                mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }
        }

        /* This shouldn't trigger unless we screwed up during the initial sanity checks */
        if (pState->m_central_dir.m_size >= MZ_UINT32_MAX)
        {
            /* TODO: Support central dirs >= 32-bits in size */
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
        }

        n = (mz_uint32)orig_central_dir_size;
        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1))
        {
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        pZip->m_total_files++;
        pZip->m_archive_size = cur_dst_file_ofs;

        return MZ_TRUE;
    }

    mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip)
    {
        mz_zip_internal_state *pState;
        mz_uint64 central_dir_ofs, central_dir_size;
        mz_uint8 hdr[256];

        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        pState = pZip->m_pState;

        if (pState->m_zip64)
        {
            if ((mz_uint64)pState->m_central_dir.m_size >= MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
        }
        else
        {
            if ((pZip->m_total_files > MZ_UINT16_MAX) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX))
                return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
        }

        central_dir_ofs = 0;
        central_dir_size = 0;
        if (pZip->m_total_files)
        {
            /* Write central directory */
            central_dir_ofs = pZip->m_archive_size;
            central_dir_size = pState->m_central_dir.m_size;
            pZip->m_central_directory_file_ofs = central_dir_ofs;
            if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            pZip->m_archive_size += central_dir_size;
        }

        if (pState->m_zip64)
        {
            /* Write zip64 end of central directory header */
            mz_uint64 rel_ofs_to_zip64_ecdr = pZip->m_archive_size;

            MZ_CLEAR_ARR(hdr);
            MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDH_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG);
            MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - sizeof(mz_uint32) - sizeof(mz_uint64));
            MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS, 0x031E); /* TODO: always Unix */
            MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_NEEDED_OFS, 0x002D);
            MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
            MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
            MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_SIZE_OFS, central_dir_size);
            MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_OFS_OFS, central_dir_ofs);
            if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE;

            /* Write zip64 end of central directory locator */
            MZ_CLEAR_ARR(hdr);
            MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG);
            MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS, rel_ofs_to_zip64_ecdr);
            MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS, 1);
            if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE;
        }

        /* Write end of central directory record */
        MZ_CLEAR_ARR(hdr);
        MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
        MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
        MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
        MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_size));
        MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_ofs));

        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

#ifndef MINIZ_NO_STDIO
        if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
#endif /* #ifndef MINIZ_NO_STDIO */

        pZip->m_archive_size += MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE;

        pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
        return MZ_TRUE;
    }

    mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize)
    {
        if ((!ppBuf) || (!pSize))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        *ppBuf = NULL;
        *pSize = 0;

        if ((!pZip) || (!pZip->m_pState))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (pZip->m_pWrite != mz_zip_heap_write_func)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (!mz_zip_writer_finalize_archive(pZip))
            return MZ_FALSE;

        *ppBuf = pZip->m_pState->m_pMem;
        *pSize = pZip->m_pState->m_mem_size;
        pZip->m_pState->m_pMem = NULL;
        pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;

        return MZ_TRUE;
    }

    mz_bool mz_zip_writer_end(mz_zip_archive *pZip)
    {
        return mz_zip_writer_end_internal(pZip, MZ_TRUE);
    }

#ifndef MINIZ_NO_STDIO
    mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
    {
        return mz_zip_add_mem_to_archive_file_in_place_v2(pZip_filename, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, NULL);
    }

    mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr)
    {
        mz_bool status, created_new_archive = MZ_FALSE;
        mz_zip_archive zip_archive;
        struct MZ_FILE_STAT_STRUCT file_stat;
        mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

        mz_zip_zero_struct(&zip_archive);
        if ((int)level_and_flags < 0)
            level_and_flags = MZ_DEFAULT_LEVEL;

        if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment)) || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
        {
            if (pErr)
                *pErr = MZ_ZIP_INVALID_PARAMETER;
            return MZ_FALSE;
        }

        if (!mz_zip_writer_validate_archive_name(pArchive_name))
        {
            if (pErr)
                *pErr = MZ_ZIP_INVALID_FILENAME;
            return MZ_FALSE;
        }

        /* Important: The regular non-64 bit version of stat() can fail here if the file is very large, which could cause the archive to be overwritten. */
        /* So be sure to compile with _LARGEFILE64_SOURCE 1 */
        if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0)
        {
            /* Create a new archive. */
            if (!mz_zip_writer_init_file_v2(&zip_archive, pZip_filename, 0, level_and_flags))
            {
                if (pErr)
                    *pErr = zip_archive.m_last_error;
                return MZ_FALSE;
            }

            created_new_archive = MZ_TRUE;
        }
        else
        {
            /* Append to an existing archive. */
            if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY | MZ_ZIP_FLAG_READ_ALLOW_WRITING, 0, 0))
            {
                if (pErr)
                    *pErr = zip_archive.m_last_error;
                return MZ_FALSE;
            }

            if (!mz_zip_writer_init_from_reader_v2(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_READ_ALLOW_WRITING))
            {
                if (pErr)
                    *pErr = zip_archive.m_last_error;

                mz_zip_reader_end_internal(&zip_archive, MZ_FALSE);

                return MZ_FALSE;
            }
        }

        status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
        actual_err = zip_archive.m_last_error;

        /* Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.) */
        if (!mz_zip_writer_finalize_archive(&zip_archive))
        {
            if (!actual_err)
                actual_err = zip_archive.m_last_error;

            status = MZ_FALSE;
        }

        if (!mz_zip_writer_end_internal(&zip_archive, status))
        {
            if (!actual_err)
                actual_err = zip_archive.m_last_error;

            status = MZ_FALSE;
        }

        if ((!status) && (created_new_archive))
        {
            /* It's a new archive and something went wrong, so just delete it. */
            int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
            (void)ignoredStatus;
        }

        if (pErr)
            *pErr = actual_err;

        return status;
    }

    void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr)
    {
        mz_uint32 file_index;
        mz_zip_archive zip_archive;
        void *p = NULL;

        if (pSize)
            *pSize = 0;

        if ((!pZip_filename) || (!pArchive_name))
        {
            if (pErr)
                *pErr = MZ_ZIP_INVALID_PARAMETER;

            return NULL;
        }

        mz_zip_zero_struct(&zip_archive);
        if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
        {
            if (pErr)
                *pErr = zip_archive.m_last_error;

            return NULL;
        }

        if (mz_zip_reader_locate_file_v2(&zip_archive, pArchive_name, pComment, flags, &file_index))
        {
            p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);
        }

        mz_zip_reader_end_internal(&zip_archive, p != NULL);

        if (pErr)
            *pErr = zip_archive.m_last_error;

        return p;
    }

    void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)
    {
        return mz_zip_extract_archive_file_to_heap_v2(pZip_filename, pArchive_name, NULL, pSize, flags, NULL);
    }

#endif /* #ifndef MINIZ_NO_STDIO */

#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */

    /* ------------------- Misc utils */

    mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip)
    {
        return pZip ? pZip->m_zip_mode : MZ_ZIP_MODE_INVALID;
    }

    mz_zip_type mz_zip_get_type(mz_zip_archive *pZip)
    {
        return pZip ? pZip->m_zip_type : MZ_ZIP_TYPE_INVALID;
    }

    mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num)
    {
        mz_zip_error prev_err;

        if (!pZip)
            return MZ_ZIP_INVALID_PARAMETER;

        prev_err = pZip->m_last_error;

        pZip->m_last_error = err_num;
        return prev_err;
    }

    mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip)
    {
        if (!pZip)
            return MZ_ZIP_INVALID_PARAMETER;

        return pZip->m_last_error;
    }

    mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip)
    {
        return mz_zip_set_last_error(pZip, MZ_ZIP_NO_ERROR);
    }

    mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip)
    {
        mz_zip_error prev_err;

        if (!pZip)
            return MZ_ZIP_INVALID_PARAMETER;

        prev_err = pZip->m_last_error;

        pZip->m_last_error = MZ_ZIP_NO_ERROR;
        return prev_err;
    }

    const char *mz_zip_get_error_string(mz_zip_error mz_err)
    {
        switch (mz_err)
        {
            case MZ_ZIP_NO_ERROR:
                return "no error";
            case MZ_ZIP_UNDEFINED_ERROR:
                return "undefined error";
            case MZ_ZIP_TOO_MANY_FILES:
                return "too many files";
            case MZ_ZIP_FILE_TOO_LARGE:
                return "file too large";
            case MZ_ZIP_UNSUPPORTED_METHOD:
                return "unsupported method";
            case MZ_ZIP_UNSUPPORTED_ENCRYPTION:
                return "unsupported encryption";
            case MZ_ZIP_UNSUPPORTED_FEATURE:
                return "unsupported feature";
            case MZ_ZIP_FAILED_FINDING_CENTRAL_DIR:
                return "failed finding central directory";
            case MZ_ZIP_NOT_AN_ARCHIVE:
                return "not a ZIP archive";
            case MZ_ZIP_INVALID_HEADER_OR_CORRUPTED:
                return "invalid header or archive is corrupted";
            case MZ_ZIP_UNSUPPORTED_MULTIDISK:
                return "unsupported multidisk archive";
            case MZ_ZIP_DECOMPRESSION_FAILED:
                return "decompression failed or archive is corrupted";
            case MZ_ZIP_COMPRESSION_FAILED:
                return "compression failed";
            case MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE:
                return "unexpected decompressed size";
            case MZ_ZIP_CRC_CHECK_FAILED:
                return "CRC-32 check failed";
            case MZ_ZIP_UNSUPPORTED_CDIR_SIZE:
                return "unsupported central directory size";
            case MZ_ZIP_ALLOC_FAILED:
                return "allocation failed";
            case MZ_ZIP_FILE_OPEN_FAILED:
                return "file open failed";
            case MZ_ZIP_FILE_CREATE_FAILED:
                return "file create failed";
            case MZ_ZIP_FILE_WRITE_FAILED:
                return "file write failed";
            case MZ_ZIP_FILE_READ_FAILED:
                return "file read failed";
            case MZ_ZIP_FILE_CLOSE_FAILED:
                return "file close failed";
            case MZ_ZIP_FILE_SEEK_FAILED:
                return "file seek failed";
            case MZ_ZIP_FILE_STAT_FAILED:
                return "file stat failed";
            case MZ_ZIP_INVALID_PARAMETER:
                return "invalid parameter";
            case MZ_ZIP_INVALID_FILENAME:
                return "invalid filename";
            case MZ_ZIP_BUF_TOO_SMALL:
                return "buffer too small";
            case MZ_ZIP_INTERNAL_ERROR:
                return "internal error";
            case MZ_ZIP_FILE_NOT_FOUND:
                return "file not found";
            case MZ_ZIP_ARCHIVE_TOO_LARGE:
                return "archive is too large";
            case MZ_ZIP_VALIDATION_FAILED:
                return "validation failed";
            case MZ_ZIP_WRITE_CALLBACK_FAILED:
                return "write callback failed";
            case MZ_ZIP_TOTAL_ERRORS:
                return "total errors";
            default:
                break;
        }

        return "unknown error";
    }

    /* Note: Just because the archive is not zip64 doesn't necessarily mean it doesn't have Zip64 extended information extra field, argh. */
    mz_bool mz_zip_is_zip64(mz_zip_archive *pZip)
    {
        if ((!pZip) || (!pZip->m_pState))
            return MZ_FALSE;

        return pZip->m_pState->m_zip64;
    }

    size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip)
    {
        if ((!pZip) || (!pZip->m_pState))
            return 0;

        return pZip->m_pState->m_central_dir.m_size;
    }

    mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip)
    {
        return pZip ? pZip->m_total_files : 0;
    }

    mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip)
    {
        if (!pZip)
            return 0;
        return pZip->m_archive_size;
    }

    mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip)
    {
        if ((!pZip) || (!pZip->m_pState))
            return 0;
        return pZip->m_pState->m_file_archive_start_ofs;
    }

    MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip)
    {
        if ((!pZip) || (!pZip->m_pState))
            return 0;
        return pZip->m_pState->m_pFile;
    }

    size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n)
    {
        if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pZip->m_pRead))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        return pZip->m_pRead(pZip->m_pIO_opaque, file_ofs, pBuf, n);
    }

    mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)
    {
        mz_uint n;
        const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
        if (!p)
        {
            if (filename_buf_size)
                pFilename[0] = '\0';
            mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
            return 0;
        }
        n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        if (filename_buf_size)
        {
            n = MZ_MIN(n, filename_buf_size - 1);
            memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
            pFilename[n] = '\0';
        }
        return n + 1;
    }

    mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)
    {
        return mz_zip_file_stat_internal(pZip, file_index, mz_zip_get_cdh(pZip, file_index), pStat, NULL);
    }

    mz_bool mz_zip_end(mz_zip_archive *pZip)
    {
        if (!pZip)
            return MZ_FALSE;

        if (pZip->m_zip_mode == MZ_ZIP_MODE_READING)
            return mz_zip_reader_end(pZip);
#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
        else if ((pZip->m_zip_mode == MZ_ZIP_MODE_WRITING) || (pZip->m_zip_mode == MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED))
            return mz_zip_writer_end(pZip);
#endif

        return MZ_FALSE;
    }

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_ARCHIVE_APIS*/

```

`miniz/miniz_zip.h`:

```h

#pragma once
#include "miniz_common.h"

/* ------------------- ZIP archive reading/writing */

#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
extern "C"
{
#endif

    enum
    {
        /* Note: These enums can be reduced as needed to save memory or stack space - they are pretty conservative. */
        MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
        MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 512,
        MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 512
    };

    typedef struct
    {
        /* Central directory file index. */
        mz_uint32 m_file_index;

        /* Byte offset of this entry in the archive's central directory. Note we currently only support up to UINT_MAX or less bytes in the central dir. */
        mz_uint64 m_central_dir_ofs;

        /* These fields are copied directly from the zip's central dir. */
        mz_uint16 m_version_made_by;
        mz_uint16 m_version_needed;
        mz_uint16 m_bit_flag;
        mz_uint16 m_method;

        /* CRC-32 of uncompressed data. */
        mz_uint32 m_crc32;

        /* File's compressed size. */
        mz_uint64 m_comp_size;

        /* File's uncompressed size. Note, I've seen some old archives where directory entries had 512 bytes for their uncompressed sizes, but when you try to unpack them you actually get 0 bytes. */
        mz_uint64 m_uncomp_size;

        /* Zip internal and external file attributes. */
        mz_uint16 m_internal_attr;
        mz_uint32 m_external_attr;

        /* Entry's local header file offset in bytes. */
        mz_uint64 m_local_header_ofs;

        /* Size of comment in bytes. */
        mz_uint32 m_comment_size;

        /* MZ_TRUE if the entry appears to be a directory. */
        mz_bool m_is_directory;

        /* MZ_TRUE if the entry uses encryption/strong encryption (which miniz_zip doesn't support) */
        mz_bool m_is_encrypted;

        /* MZ_TRUE if the file is not encrypted, a patch file, and if it uses a compression method we support. */
        mz_bool m_is_supported;

        /* Filename. If string ends in '/' it's a subdirectory entry. */
        /* Guaranteed to be zero terminated, may be truncated to fit. */
        char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];

        /* Comment field. */
        /* Guaranteed to be zero terminated, may be truncated to fit. */
        char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];

#ifdef MINIZ_NO_TIME
        MZ_TIME_T m_padding;
#else
    MZ_TIME_T m_time;
#endif
    } mz_zip_archive_file_stat;

    typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);
    typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);
    typedef mz_bool (*mz_file_needs_keepalive)(void *pOpaque);

    struct mz_zip_internal_state_tag;
    typedef struct mz_zip_internal_state_tag mz_zip_internal_state;

    typedef enum
    {
        MZ_ZIP_MODE_INVALID = 0,
        MZ_ZIP_MODE_READING = 1,
        MZ_ZIP_MODE_WRITING = 2,
        MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
    } mz_zip_mode;

    typedef enum
    {
        MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
        MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
        MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
        MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800,
        MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG = 0x1000, /* if enabled, mz_zip_reader_locate_file() will be called on each file as its validated to ensure the func finds the file in the central dir (intended for testing) */
        MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY = 0x2000,     /* validate the local headers, but don't decompress the entire file and check the crc32 */
        MZ_ZIP_FLAG_WRITE_ZIP64 = 0x4000,               /* always use the zip64 file format, instead of the original zip file format with automatic switch to zip64. Use as flags parameter with mz_zip_writer_init*_v2 */
        MZ_ZIP_FLAG_WRITE_ALLOW_READING = 0x8000,
        MZ_ZIP_FLAG_ASCII_FILENAME = 0x10000,
        /*After adding a compressed file, seek back
        to local file header and set the correct sizes*/
        MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE = 0x20000,
        MZ_ZIP_FLAG_READ_ALLOW_WRITING = 0x40000
    } mz_zip_flags;

    typedef enum
    {
        MZ_ZIP_TYPE_INVALID = 0,
        MZ_ZIP_TYPE_USER,
        MZ_ZIP_TYPE_MEMORY,
        MZ_ZIP_TYPE_HEAP,
        MZ_ZIP_TYPE_FILE,
        MZ_ZIP_TYPE_CFILE,
        MZ_ZIP_TOTAL_TYPES
    } mz_zip_type;

    /* miniz error codes. Be sure to update mz_zip_get_error_string() if you add or modify this enum. */
    typedef enum
    {
        MZ_ZIP_NO_ERROR = 0,
        MZ_ZIP_UNDEFINED_ERROR,
        MZ_ZIP_TOO_MANY_FILES,
        MZ_ZIP_FILE_TOO_LARGE,
        MZ_ZIP_UNSUPPORTED_METHOD,
        MZ_ZIP_UNSUPPORTED_ENCRYPTION,
        MZ_ZIP_UNSUPPORTED_FEATURE,
        MZ_ZIP_FAILED_FINDING_CENTRAL_DIR,
        MZ_ZIP_NOT_AN_ARCHIVE,
        MZ_ZIP_INVALID_HEADER_OR_CORRUPTED,
        MZ_ZIP_UNSUPPORTED_MULTIDISK,
        MZ_ZIP_DECOMPRESSION_FAILED,
        MZ_ZIP_COMPRESSION_FAILED,
        MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE,
        MZ_ZIP_CRC_CHECK_FAILED,
        MZ_ZIP_UNSUPPORTED_CDIR_SIZE,
        MZ_ZIP_ALLOC_FAILED,
        MZ_ZIP_FILE_OPEN_FAILED,
        MZ_ZIP_FILE_CREATE_FAILED,
        MZ_ZIP_FILE_WRITE_FAILED,
        MZ_ZIP_FILE_READ_FAILED,
        MZ_ZIP_FILE_CLOSE_FAILED,
        MZ_ZIP_FILE_SEEK_FAILED,
        MZ_ZIP_FILE_STAT_FAILED,
        MZ_ZIP_INVALID_PARAMETER,
        MZ_ZIP_INVALID_FILENAME,
        MZ_ZIP_BUF_TOO_SMALL,
        MZ_ZIP_INTERNAL_ERROR,
        MZ_ZIP_FILE_NOT_FOUND,
        MZ_ZIP_ARCHIVE_TOO_LARGE,
        MZ_ZIP_VALIDATION_FAILED,
        MZ_ZIP_WRITE_CALLBACK_FAILED,
        MZ_ZIP_TOTAL_ERRORS
    } mz_zip_error;

    typedef struct
    {
        mz_uint64 m_archive_size;
        mz_uint64 m_central_directory_file_ofs;

        /* We only support up to UINT32_MAX files in zip64 mode. */
        mz_uint32 m_total_files;
        mz_zip_mode m_zip_mode;
        mz_zip_type m_zip_type;
        mz_zip_error m_last_error;

        mz_uint64 m_file_offset_alignment;

        mz_alloc_func m_pAlloc;
        mz_free_func m_pFree;
        mz_realloc_func m_pRealloc;
        void *m_pAlloc_opaque;

        mz_file_read_func m_pRead;
        mz_file_write_func m_pWrite;
        mz_file_needs_keepalive m_pNeeds_keepalive;
        void *m_pIO_opaque;

        mz_zip_internal_state *m_pState;

    } mz_zip_archive;

    typedef struct
    {
        mz_zip_archive *pZip;
        mz_uint flags;

        int status;

        mz_uint64 read_buf_size, read_buf_ofs, read_buf_avail, comp_remaining, out_buf_ofs, cur_file_ofs;
        mz_zip_archive_file_stat file_stat;
        void *pRead_buf;
        void *pWrite_buf;

        size_t out_blk_remain;

        tinfl_decompressor inflator;

#ifdef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        mz_uint padding;
#else
    mz_uint file_crc32;
#endif

    } mz_zip_reader_extract_iter_state;

    /* -------- ZIP reading */

    /* Inits a ZIP archive reader. */
    /* These functions read and validate the archive's central directory. */
    MINIZ_EXPORT mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags);

    MINIZ_EXPORT mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags);

#ifndef MINIZ_NO_STDIO
    /* Read a archive from a disk file. */
    /* file_start_ofs is the file offset where the archive actually begins, or 0. */
    /* actual_archive_size is the true total size of the archive, which may be smaller than the file's actual size on disk. If zero the entire file is treated as the archive. */
    MINIZ_EXPORT mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);
    MINIZ_EXPORT mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size);

    /* Read an archive from an already opened FILE, beginning at the current file position. */
    /* The archive is assumed to be archive_size bytes long. If archive_size is 0, then the entire rest of the file is assumed to contain the archive. */
    /* The FILE will NOT be closed when mz_zip_reader_end() is called. */
    MINIZ_EXPORT mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags);
#endif

    /* Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used. */
    MINIZ_EXPORT mz_bool mz_zip_reader_end(mz_zip_archive *pZip);

    /* -------- ZIP reading or writing */

    /* Clears a mz_zip_archive struct to all zeros. */
    /* Important: This must be done before passing the struct to any mz_zip functions. */
    MINIZ_EXPORT void mz_zip_zero_struct(mz_zip_archive *pZip);

    MINIZ_EXPORT mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip);
    MINIZ_EXPORT mz_zip_type mz_zip_get_type(mz_zip_archive *pZip);

    /* Returns the total number of files in the archive. */
    MINIZ_EXPORT mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);

    MINIZ_EXPORT mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip);
    MINIZ_EXPORT mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip);
    MINIZ_EXPORT MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip);

    /* Reads n bytes of raw archive data, starting at file offset file_ofs, to pBuf. */
    MINIZ_EXPORT size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n);

    /* All mz_zip funcs set the m_last_error field in the mz_zip_archive struct. These functions retrieve/manipulate this field. */
    /* Note that the m_last_error functionality is not thread safe. */
    MINIZ_EXPORT mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num);
    MINIZ_EXPORT mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip);
    MINIZ_EXPORT mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip);
    MINIZ_EXPORT mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip);
    MINIZ_EXPORT const char *mz_zip_get_error_string(mz_zip_error mz_err);

    /* MZ_TRUE if the archive file entry is a directory entry. */
    MINIZ_EXPORT mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);

    /* MZ_TRUE if the file is encrypted/strong encrypted. */
    MINIZ_EXPORT mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);

    /* MZ_TRUE if the compression method is supported, and the file is not encrypted, and the file is not a compressed patch file. */
    MINIZ_EXPORT mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index);

    /* Retrieves the filename of an archive file entry. */
    /* Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename. */
    MINIZ_EXPORT mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);

    /* Attempts to locates a file in the archive's central directory. */
    /* Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH */
    /* Returns -1 if the file cannot be found. */
    MINIZ_EXPORT int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
    MINIZ_EXPORT mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *file_index);

    /* Returns detailed information about an archive file entry. */
    MINIZ_EXPORT mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);

    /* MZ_TRUE if the file is in zip64 format. */
    /* A file is considered zip64 if it contained a zip64 end of central directory marker, or if it contained any zip64 extended file information fields in the central directory. */
    MINIZ_EXPORT mz_bool mz_zip_is_zip64(mz_zip_archive *pZip);

    /* Returns the total central directory size in bytes. */
    /* The current max supported size is <= MZ_UINT32_MAX. */
    MINIZ_EXPORT size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip);

    /* Extracts a archive file to a memory buffer using no memory allocation. */
    /* There must be at least enough room on the stack to store the inflator's state (~34KB or so). */
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);

    /* Extracts a archive file to a memory buffer. */
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);

    /* Extracts a archive file to a dynamically allocated heap buffer. */
    /* The memory will be allocated via the mz_zip_archive's alloc/realloc functions. */
    /* Returns NULL and sets the last error on failure. */
    MINIZ_EXPORT void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);
    MINIZ_EXPORT void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);

    /* Extracts a archive file using a callback function to output the file's data. */
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);

    /* Extract a file iteratively */
    MINIZ_EXPORT mz_zip_reader_extract_iter_state *mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
    MINIZ_EXPORT mz_zip_reader_extract_iter_state *mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);
    MINIZ_EXPORT size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state *pState, void *pvBuf, size_t buf_size);
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state *pState);

#ifndef MINIZ_NO_STDIO
    /* Extracts a archive file to a disk file and sets its last accessed and modified times. */
    /* This function only extracts files, not archive directory records. */
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);

    /* Extracts a archive file starting at the current position in the destination FILE stream. */
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *File, mz_uint flags);
    MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags);
#endif

#if 0
/* TODO */
	typedef void *mz_zip_streaming_extract_state_ptr;
	mz_zip_streaming_extract_state_ptr mz_zip_streaming_extract_begin(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
	mz_uint64 mz_zip_streaming_extract_get_size(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
	mz_uint64 mz_zip_streaming_extract_get_cur_ofs(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
	mz_bool mz_zip_streaming_extract_seek(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState, mz_uint64 new_ofs);
	size_t mz_zip_streaming_extract_read(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState, void *pBuf, size_t buf_size);
	mz_bool mz_zip_streaming_extract_end(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
#endif

    /* This function compares the archive's local headers, the optional local zip64 extended information block, and the optional descriptor following the compressed data vs. the data in the central directory. */
    /* It also validates that each file can be successfully uncompressed unless the MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY is specified. */
    MINIZ_EXPORT mz_bool mz_zip_validate_file(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);

    /* Validates an entire archive by calling mz_zip_validate_file() on each file. */
    MINIZ_EXPORT mz_bool mz_zip_validate_archive(mz_zip_archive *pZip, mz_uint flags);

    /* Misc utils/helpers, valid for ZIP reading or writing */
    MINIZ_EXPORT mz_bool mz_zip_validate_mem_archive(const void *pMem, size_t size, mz_uint flags, mz_zip_error *pErr);
#ifndef MINIZ_NO_STDIO
    MINIZ_EXPORT mz_bool mz_zip_validate_file_archive(const char *pFilename, mz_uint flags, mz_zip_error *pErr);
#endif

    /* Universal end function - calls either mz_zip_reader_end() or mz_zip_writer_end(). */
    MINIZ_EXPORT mz_bool mz_zip_end(mz_zip_archive *pZip);

    /* -------- ZIP writing */

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

    /* Inits a ZIP archive writer. */
    /*Set pZip->m_pWrite (and pZip->m_pIO_opaque) before calling mz_zip_writer_init or mz_zip_writer_init_v2*/
    /*The output is streamable, i.e. file_ofs in mz_file_write_func always increases only by n*/
    MINIZ_EXPORT mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
    MINIZ_EXPORT mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags);

    MINIZ_EXPORT mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);
    MINIZ_EXPORT mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags);

#ifndef MINIZ_NO_STDIO
    MINIZ_EXPORT mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
    MINIZ_EXPORT mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags);
    MINIZ_EXPORT mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags);
#endif

    /* Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive. */
    /* For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called. */
    /* For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it). */
    /* Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL. */
    /* Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before */
    /* the archive is finalized the file's central directory will be hosed. */
    MINIZ_EXPORT mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);
    MINIZ_EXPORT mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);

    /* Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive. */
    /* To add a directory entry, call this method with an archive name ending in a forwardslash with an empty buffer. */
    /* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
    MINIZ_EXPORT mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);

    /* Like mz_zip_writer_add_mem(), except you can specify a file comment field, and optionally supply the function with already compressed data. */
    /* uncomp_size/uncomp_crc32 are only used if the MZ_ZIP_FLAG_COMPRESSED_DATA flag is specified. */
    MINIZ_EXPORT mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                                  mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);

    MINIZ_EXPORT mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                                     mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                                     const char *user_extra_data_central, mz_uint user_extra_data_central_len);

    /* Adds the contents of a file to an archive. This function also records the disk file's modified time into the archive. */
    /* File data is supplied via a read callback function. User mz_zip_writer_add_(c)file to add a file directly.*/
    MINIZ_EXPORT mz_bool mz_zip_writer_add_read_buf_callback(mz_zip_archive *pZip, const char *pArchive_name, mz_file_read_func read_callback, void *callback_opaque, mz_uint64 max_size,
                                                             const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                                             const char *user_extra_data_central, mz_uint user_extra_data_central_len);

#ifndef MINIZ_NO_STDIO
    /* Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive. */
    /* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
    MINIZ_EXPORT mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

    /* Like mz_zip_writer_add_file(), except the file data is read from the specified FILE stream. */
    MINIZ_EXPORT mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 max_size,
                                                 const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                                 const char *user_extra_data_central, mz_uint user_extra_data_central_len);
#endif

    /* Adds a file to an archive by fully cloning the data from another archive. */
    /* This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data (it may add or modify the zip64 local header extra data field), and the optional descriptor following the compressed data. */
    MINIZ_EXPORT mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index);

    /* Finalizes the archive by writing the central directory records followed by the end of central directory record. */
    /* After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end(). */
    /* An archive must be manually finalized by calling this function for it to be valid. */
    MINIZ_EXPORT mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);

    /* Finalizes a heap archive, returning a pointer to the heap block and its size. */
    /* The heap block will be allocated using the mz_zip_archive's alloc/realloc callbacks. */
    MINIZ_EXPORT mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize);

    /* Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used. */
    /* Note for the archive to be valid, it *must* have been finalized before ending (this function will not do it for you). */
    MINIZ_EXPORT mz_bool mz_zip_writer_end(mz_zip_archive *pZip);

    /* -------- Misc. high-level helper functions: */

    /* mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive. */
    /* Note this is NOT a fully safe operation. If it crashes or dies in some way your archive can be left in a screwed up state (without a central directory). */
    /* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
    /* TODO: Perhaps add an option to leave the existing central dir in place in case the add dies? We could then truncate the file (so the old central dir would be at the end) if something goes wrong. */
    MINIZ_EXPORT mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
    MINIZ_EXPORT mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr);

#ifndef MINIZ_NO_STDIO
    /* Reads a single file from an archive into a heap block. */
    /* If pComment is not NULL, only the file with the specified comment will be extracted. */
    /* Returns NULL on failure. */
    MINIZ_EXPORT void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags);
    MINIZ_EXPORT void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr);
#endif

#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */

#ifdef __cplusplus
}
#endif

#endif /* MINIZ_NO_ARCHIVE_APIS */

```

`x64/Release/games.json`:

```json
{
  "version": "1.1",
  "description": "EAC Module Configuration - Community maintained list of game IDs",
  "config": {
    "baseUrl": "https://modules-cdn.eac-prod.on.epicgames.com/modules",
    "defaultPlatform": "win64"
  },
  "games": [
    {
      "name": "Gray Zone Warfare",
      "productId": "320d5d3f30f5495ebae73a8c74bc349d",
      "deploymentId": "5844bb109c5343f78b8f76f604ae3569"
    },
    {
      "name": "Arc Raiders",
      "productId": "9e8b37541e614575b4de303d2c2e44cf",
      "deploymentId": "35e06571d8ab4de4b98519b624125459"
    },
    {
      "name": "Fortnite",
      "productId": "prod-fn",
      "deploymentId": "62a9473a2dca46b29ccf17577fcf42d7"
    },
	{
      "name": "Rust",
      "productId": "429c2212ad284866aee071454c2125b5",
      "deploymentId": "76796531e86443548754600511f42e9e"
    }
  ]
}

```