Project Path: arc_invi1998_MultiplayerBlasterGame_280v1xcl

Source Tree:

```txt
arc_invi1998_MultiplayerBlasterGame_280v1xcl
├── Blaster.png
├── Blaster.uproject
├── Config
│   ├── DefaultEditor.ini
│   ├── DefaultEngine.ini
│   ├── DefaultGame.ini
│   ├── DefaultInput.ini
│   └── HoloLens
│       └── HoloLensEngine.ini
├── Content
│   ├── Assets
│   │   ├── Animations
│   │   │   ├── AimOffset
│   │   │   │   ├── AimAO
│   │   │   │   │   ├── AIM_AO_CC.uasset
│   │   │   │   │   ├── AIM_AO_CD.uasset
│   │   │   │   │   ├── AIM_AO_CL.uasset
│   │   │   │   │   ├── AIM_AO_CR.uasset
│   │   │   │   │   ├── AIM_AO_CU.uasset
│   │   │   │   │   ├── AIM_AO_LD.uasset
│   │   │   │   │   ├── AIM_AO_LU.uasset
│   │   │   │   │   ├── AIM_AO_RD.uasset
│   │   │   │   │   ├── AIM_AO_RU.uasset
│   │   │   │   │   └── AIM_ZERO_POSE.uasset
│   │   │   │   └── HipAO
│   │   │   │       ├── AO_CC.uasset
│   │   │   │       ├── AO_CD.uasset
│   │   │   │       ├── AO_CL.uasset
│   │   │   │       ├── AO_CR.uasset
│   │   │   │       ├── AO_CU.uasset
│   │   │   │       ├── AO_LD.uasset
│   │   │   │       ├── AO_LU.uasset
│   │   │   │       ├── AO_RD.uasset
│   │   │   │       ├── AO_RU.uasset
│   │   │   │       └── ZERO_POSE.uasset
│   │   │   ├── AnimStarterPack
│   │   │   │   ├── Aim_Space_Hip.uasset
│   │   │   │   ├── Aim_Space_Ironsights.uasset
│   │   │   │   ├── BS_CrouchWalk.uasset
│   │   │   │   ├── BS_Jog.uasset
│   │   │   │   ├── Crouch_Idle_Rifle_Hip.uasset
│   │   │   │   ├── Crouch_Idle_Rifle_Ironsights.uasset
│   │   │   │   ├── Crouch_Walk_Bwd_Rifle_Hip.uasset
│   │   │   │   ├── Crouch_Walk_Bwd_Rifle_Ironsights.uasset
│   │   │   │   ├── Crouch_Walk_Fwd_Rifle_Hip.uasset
│   │   │   │   ├── Crouch_Walk_Fwd_Rifle_Ironsights.uasset
│   │   │   │   ├── Crouch_Walk_Lt_Rifle_Hip.uasset
│   │   │   │   ├── Crouch_Walk_Lt_Rifle_Ironsights.uasset
│   │   │   │   ├── Crouch_Walk_Rt_Rifle_Hip.uasset
│   │   │   │   ├── Crouch_Walk_Rt_Rifle_Ironsights.uasset
│   │   │   │   ├── Crouch_to_Stand_Rifle_Hip.uasset
│   │   │   │   ├── Crouch_to_Stand_Rifle_Ironsights.uasset
│   │   │   │   ├── Death_1.uasset
│   │   │   │   ├── Death_2.uasset
│   │   │   │   ├── Death_3.uasset
│   │   │   │   ├── Death_Ironsights_1.uasset
│   │   │   │   ├── Death_Ironsights_2.uasset
│   │   │   │   ├── Equip_Pistol_Standing.uasset
│   │   │   │   ├── Equip_Rifle_Standing.uasset
│   │   │   │   ├── Fire_Rifle_Hip.uasset
│   │   │   │   ├── Fire_Rifle_Ironsights.uasset
│   │   │   │   ├── Fire_Shotgun_Hip.uasset
│   │   │   │   ├── Fire_Shotgun_Ironsights.uasset
│   │   │   │   ├── Hit_React_1.uasset
│   │   │   │   ├── Hit_React_2.uasset
│   │   │   │   ├── Hit_React_3.uasset
│   │   │   │   ├── Hit_React_4.uasset
│   │   │   │   ├── Idle_Pistol.uasset
│   │   │   │   ├── Idle_Rifle_Hip.uasset
│   │   │   │   ├── Idle_Rifle_Hip_Break1.uasset
│   │   │   │   ├── Idle_Rifle_Hip_Break2.uasset
│   │   │   │   ├── Idle_Rifle_Ironsights.uasset
│   │   │   │   ├── Jog_Bwd_Rifle.uasset
│   │   │   │   ├── Jog_Fwd_Rifle.uasset
│   │   │   │   ├── Jog_Lt_Rifle.uasset
│   │   │   │   ├── Jog_Rt_Rifle.uasset
│   │   │   │   ├── Jump_From_Jog.uasset
│   │   │   │   ├── Jump_From_Stand.uasset
│   │   │   │   ├── Jump_From_Stand_Ironsights.uasset
│   │   │   │   ├── Prone_Death_1.uasset
│   │   │   │   ├── Prone_Death_2.uasset
│   │   │   │   ├── Prone_Fire_1.uasset
│   │   │   │   ├── Prone_Fire_2.uasset
│   │   │   │   ├── Prone_Idle.uasset
│   │   │   │   ├── Prone_Reload_Rifle.uasset
│   │   │   │   ├── Prone_Reload_Shotgun.uasset
│   │   │   │   ├── Prone_To_Stand.uasset
│   │   │   │   ├── Reload_Pistol.uasset
│   │   │   │   ├── Reload_Rifle_Hip.uasset
│   │   │   │   ├── Reload_Rifle_Ironsights.uasset
│   │   │   │   ├── Reload_Shotgun_Hip.uasset
│   │   │   │   ├── Reload_Shotgun_Ironsights.uasset
│   │   │   │   ├── Showcase.umap
│   │   │   │   ├── Sprint_Fwd_Rifle.uasset
│   │   │   │   ├── Stand_To_Prone.uasset
│   │   │   │   ├── Stand_to_Crouch_Rifle_Hip.uasset
│   │   │   │   ├── Stand_to_Crouch_Rifle_Ironsights.uasset
│   │   │   │   ├── UE4ASP_HeroTPP_AnimBlueprint.uasset
│   │   │   │   ├── UE4_Mannequin
│   │   │   │   │   ├── Materials
│   │   │   │   │   │   ├── M_UE4Man_Body.uasset
│   │   │   │   │   │   ├── M_UE4Man_ChestLogo.uasset
│   │   │   │   │   │   └── MaterialLayers
│   │   │   │   │   │       ├── ML_GlossyBlack_Latex_UE4.uasset
│   │   │   │   │   │       ├── ML_Plastic_Shiny_Beige.uasset
│   │   │   │   │   │       ├── ML_Plastic_Shiny_Beige_LOGO.uasset
│   │   │   │   │   │       ├── ML_SoftMetal_UE4.uasset
│   │   │   │   │   │       ├── T_ML_Aluminum01.uasset
│   │   │   │   │   │       ├── T_ML_Aluminum01_N.uasset
│   │   │   │   │   │       ├── T_ML_Rubber_Blue_01_D.uasset
│   │   │   │   │   │       └── T_ML_Rubber_Blue_01_N.uasset
│   │   │   │   │   ├── Mesh
│   │   │   │   │   │   ├── SK_Mannequin.uasset
│   │   │   │   │   │   ├── SK_Mannequin_PhysicsAsset.uasset
│   │   │   │   │   │   └── UE4_Mannequin_Skeleton.uasset
│   │   │   │   │   ├── Rigs
│   │   │   │   │   │   ├── IK_Mannequin.uasset
│   │   │   │   │   │   └── RTG_Mannequin.uasset
│   │   │   │   │   └── Textures
│   │   │   │   │       ├── UE4Man_Logo_N.uasset
│   │   │   │   │       ├── UE4_LOGO_CARD.uasset
│   │   │   │   │       ├── UE4_Mannequin_MAT_MASKA.uasset
│   │   │   │   │       ├── UE4_Mannequin__normals.uasset
│   │   │   │   │       └── UE4_Mannequin_occlusion_Mobile.uasset
│   │   │   │   ├── Ue4ASP_Character.uasset
│   │   │   │   ├── Walk_Bwd_Rifle_Ironsights.uasset
│   │   │   │   ├── Walk_Fwd_Rifle_Ironsights.uasset
│   │   │   │   ├── Walk_Lt_Rifle_Ironsights.uasset
│   │   │   │   └── Walk_Rt_Rifle_Ironsights.uasset
│   │   │   ├── Crouch_Idle_Rifle_Hip.uasset
│   │   │   ├── Crouch_Walk_Bwd_Rifle_Hip.uasset
│   │   │   ├── Elim.uasset
│   │   │   ├── Jog_Bwd_45_Right.uasset
│   │   │   ├── Jog_Fwd_45_Left.uasset
│   │   │   ├── ReloadPistol.uasset
│   │   │   ├── ReloadRifle.uasset
│   │   │   ├── ReloadRocket.uasset
│   │   │   ├── Retargeted
│   │   │   │   ├── AnimStarterPack
│   │   │   │   │   ├── Aim_Space_Hip_Retargeted.uasset
│   │   │   │   │   ├── Aim_Space_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Aim_Space_Ironsights_Retargeted1.uasset
│   │   │   │   │   ├── Crouch_Idle_Rifle_Hip_Retargeted.uasset
│   │   │   │   │   ├── Crouch_Idle_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Crouch_Walk_Bwd_Rifle_Hip_Retargeted.uasset
│   │   │   │   │   ├── Crouch_Walk_Bwd_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Crouch_Walk_Fwd_Rifle_Hip_Retargeted.uasset
│   │   │   │   │   ├── Crouch_Walk_Fwd_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Crouch_Walk_Lt_Rifle_Hip_Retargeted.uasset
│   │   │   │   │   ├── Crouch_Walk_Lt_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Crouch_Walk_Rt_Rifle_Hip_Retargeted.uasset
│   │   │   │   │   ├── Crouch_Walk_Rt_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Crouch_to_Stand_Rifle_Hip_Retargeted.uasset
│   │   │   │   │   ├── Crouch_to_Stand_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Death_1_Retargeted.uasset
│   │   │   │   │   ├── Death_2_Retargeted.uasset
│   │   │   │   │   ├── Death_3_Retargeted.uasset
│   │   │   │   │   ├── Death_Ironsights_1_Retargeted.uasset
│   │   │   │   │   ├── Death_Ironsights_2_Retargeted.uasset
│   │   │   │   │   ├── Equip_Pistol_Standing_Retargeted.uasset
│   │   │   │   │   ├── Equip_Rifle_Standing_Retargeted.uasset
│   │   │   │   │   ├── Fire_Rifle_Hip_Retargeted.uasset
│   │   │   │   │   ├── Fire_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Fire_Shotgun_Hip_Retargeted.uasset
│   │   │   │   │   ├── Fire_Shotgun_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Hit_React_1.uasset
│   │   │   │   │   ├── Hit_React_1_Add.uasset
│   │   │   │   │   ├── Hit_React_2.uasset
│   │   │   │   │   ├── Hit_React_2_Add.uasset
│   │   │   │   │   ├── Hit_React_3.uasset
│   │   │   │   │   ├── Hit_React_3_Add.uasset
│   │   │   │   │   ├── Hit_React_4.uasset
│   │   │   │   │   ├── Hit_React_4_Add.uasset
│   │   │   │   │   ├── Idle_Pistol_Retargeted.uasset
│   │   │   │   │   ├── Idle_Rifle_Hip_Break1_Retargeted.uasset
│   │   │   │   │   ├── Idle_Rifle_Hip_Break2_Retargeted.uasset
│   │   │   │   │   ├── Idle_Rifle_Hip_Retargeted.uasset
│   │   │   │   │   ├── Idle_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Jog_Bwd_Lean_L.uasset
│   │   │   │   │   ├── Jog_Bwd_Lean_R.uasset
│   │   │   │   │   ├── Jog_Bwd_Rifle_Retargeted.uasset
│   │   │   │   │   ├── Jog_Fwd_Lean_L.uasset
│   │   │   │   │   ├── Jog_Fwd_Lean_R.uasset
│   │   │   │   │   ├── Jog_Fwd_Rifle_Retargeted.uasset
│   │   │   │   │   ├── Jog_Lt_Lean_L.uasset
│   │   │   │   │   ├── Jog_Lt_Lean_R.uasset
│   │   │   │   │   ├── Jog_Lt_Rifle_Retargeted.uasset
│   │   │   │   │   ├── Jog_Rt_Lean_R.uasset
│   │   │   │   │   ├── Jog_Rt_Rifle_Retargeted.uasset
│   │   │   │   │   ├── Jog_Rt_lean_L.uasset
│   │   │   │   │   ├── JumpDown_trim_rot.uasset
│   │   │   │   │   ├── JumpLoop_rot.uasset
│   │   │   │   │   ├── JumpUp_rot.uasset
│   │   │   │   │   ├── Jump_Down_Trim_Rot.uasset
│   │   │   │   │   ├── Jump_Down_Trim_Rot_New.uasset
│   │   │   │   │   ├── Jump_From_Jog_Retargeted.uasset
│   │   │   │   │   ├── Jump_From_Stand_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Jump_From_Stand_Retargeted.uasset
│   │   │   │   │   ├── Jump_Loop_Rot.uasset
│   │   │   │   │   ├── Prone_Death_1_Retargeted.uasset
│   │   │   │   │   ├── Prone_Death_2_Retargeted.uasset
│   │   │   │   │   ├── Prone_Fire_1_Retargeted.uasset
│   │   │   │   │   ├── Prone_Fire_2_Retargeted.uasset
│   │   │   │   │   ├── Prone_Idle_Retargeted.uasset
│   │   │   │   │   ├── Prone_Reload_Rifle_Retargeted.uasset
│   │   │   │   │   ├── Prone_Reload_Shotgun_Retargeted.uasset
│   │   │   │   │   ├── Prone_To_Stand_Retargeted.uasset
│   │   │   │   │   ├── Reload_Pistol_Retargeted.uasset
│   │   │   │   │   ├── Reload_Pistol_Retargeted1.uasset
│   │   │   │   │   ├── Reload_Rifle_Hip_Retargeted.uasset
│   │   │   │   │   ├── Reload_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Reload_Shotgun_Hip_Retargeted.uasset
│   │   │   │   │   ├── Reload_Shotgun_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Sprint_Fwd_Rifle_Retargeted.uasset
│   │   │   │   │   ├── Stand_To_Prone_Retargeted.uasset
│   │   │   │   │   ├── Stand_to_Crouch_Rifle_Hip_Retargeted.uasset
│   │   │   │   │   ├── Stand_to_Crouch_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Walk_Bwd_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Walk_Fwd_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   ├── Walk_Lt_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   │   └── Walk_Rt_Rifle_Ironsights_Retargeted.uasset
│   │   │   │   └── Mixamo
│   │   │   │       ├── CrouchTurnLeft_Retargeted.uasset
│   │   │   │       ├── CrouchTurnRight_Retargeted.uasset
│   │   │   │       ├── GrenadeToss.uasset
│   │   │   │       ├── Jump_Down_Retargeted.uasset
│   │   │   │       ├── Jump_Down_Trim.uasset
│   │   │   │       ├── Jump_Loop_Retargeted.uasset
│   │   │   │       ├── Jump_Up_Retargeted.uasset
│   │   │   │       ├── SniperReload.uasset
│   │   │   │       ├── Toss_Grenade_Retargeted.uasset
│   │   │   │       ├── TurnLeft_Retargeted.uasset
│   │   │   │       ├── TurnRight_Retargeted.uasset
│   │   │   │       └── Zombie_Attack_Retargeted.uasset
│   │   │   ├── SwapWeapons.uasset
│   │   │   ├── TorchIdle.uasset
│   │   │   └── TorchWalk1.uasset
│   │   ├── CartoonWaterShader
│   │   │   ├── Blueprints
│   │   │   │   ├── Buoyancy
│   │   │   │   │   ├── BP_BuoyantActor.uasset
│   │   │   │   │   ├── BP_LakeManager.uasset
│   │   │   │   │   ├── BP_OceanManager.uasset
│   │   │   │   │   └── BP_RiverManager.uasset
│   │   │   │   ├── CartoonWaterBlueprints
│   │   │   │   │   ├── BP_CartoonWater_Lake.uasset
│   │   │   │   │   ├── BP_CartoonWater_Ocean.uasset
│   │   │   │   │   ├── BP_CartoonWater_RiverTool.uasset
│   │   │   │   │   ├── BP_WaterRipple_Lake.uasset
│   │   │   │   │   ├── BP_WaterRipple_Ocean.uasset
│   │   │   │   │   ├── BP_WaterRipple_River.uasset
│   │   │   │   │   └── BP_Waterfall.uasset
│   │   │   │   ├── LightControl
│   │   │   │   │   └── BP_LightControl.uasset
│   │   │   │   └── Underwater
│   │   │   │       └── BP_Underwater_ScreenEffect.uasset
│   │   │   ├── Data
│   │   │   │   ├── BuoyancyType.uasset
│   │   │   │   ├── LakeType.uasset
│   │   │   │   ├── OceanType.uasset
│   │   │   │   ├── RiverData.uasset
│   │   │   │   ├── RiverType.uasset
│   │   │   │   ├── UnderwaterType.uasset
│   │   │   │   └── WaterfallType.uasset
│   │   │   ├── Environment
│   │   │   │   └── HDRI
│   │   │   │       ├── HDRI_CartoonWater.uasset
│   │   │   │       └── HDRI_Clouds.uasset
│   │   │   ├── EpicGamesFog
│   │   │   │   ├── Blueprints
│   │   │   │   │   ├── BP_FogSheet.uasset
│   │   │   │   │   └── BP_LightBeam.uasset
│   │   │   │   ├── Materials
│   │   │   │   │   ├── ML_NormalMaskedVectors.uasset
│   │   │   │   │   ├── ML_Raycast.uasset
│   │   │   │   │   ├── M_FogSheet_Master.uasset
│   │   │   │   │   ├── M_FogSheet_Master_INST.uasset
│   │   │   │   │   ├── M_GodRay_Animated.uasset
│   │   │   │   │   └── M_GodRay_MASTER.uasset
│   │   │   │   ├── Meshes
│   │   │   │   │   ├── SM_FogSheet_Plane.uasset
│   │   │   │   │   ├── SM_GodRay_Plane.uasset
│   │   │   │   │   └── SM_Plane.uasset
│   │   │   │   └── Textures
│   │   │   │       ├── T_GodRay_Mask01.uasset
│   │   │   │       ├── T_GodRay_Mask02.uasset
│   │   │   │       ├── T_TilingNoise02_M.uasset
│   │   │   │       └── T_TilingNoise03_M.uasset
│   │   │   ├── Maps
│   │   │   │   ├── DemoMapLake.umap
│   │   │   │   ├── DemoMapLake_BuiltData.uasset
│   │   │   │   ├── DemoMapOcean.umap
│   │   │   │   ├── DemoMapOcean_BuiltData.uasset
│   │   │   │   ├── DemoMapRiver.umap
│   │   │   │   ├── DemoMapRiver_BuiltData.uasset
│   │   │   │   └── OverviewMap.umap
│   │   │   ├── Materials
│   │   │   │   ├── BaseMaterials
│   │   │   │   │   ├── MI_Dock.uasset
│   │   │   │   │   ├── MI_Foliage.uasset
│   │   │   │   │   ├── MI_FoliageOpaque.uasset
│   │   │   │   │   ├── MI_House.uasset
│   │   │   │   │   ├── MI_Rock.uasset
│   │   │   │   │   ├── MI_Tree.uasset
│   │   │   │   │   ├── MI_Wall.uasset
│   │   │   │   │   ├── M_Basic.uasset
│   │   │   │   │   ├── M_Basic_Caustic.uasset
│   │   │   │   │   ├── M_Foliage.uasset
│   │   │   │   │   └── M_FoliageOpaque.uasset
│   │   │   │   ├── Fog
│   │   │   │   │   ├── MI_MultiColoredFog.uasset
│   │   │   │   │   └── M_MultiColoredFog.uasset
│   │   │   │   ├── MaterialCollections
│   │   │   │   │   ├── MPC_Caustic_and_Wetness.uasset
│   │   │   │   │   ├── MPC_Lake.uasset
│   │   │   │   │   ├── MPC_LightData.uasset
│   │   │   │   │   ├── MPC_Ocean.uasset
│   │   │   │   │   ├── MPC_RipplesDecal.uasset
│   │   │   │   │   ├── MPC_River.uasset
│   │   │   │   │   └── MPC_Waterfall.uasset
│   │   │   │   ├── MaterialFunctions
│   │   │   │   │   ├── MF_4WayMotion.uasset
│   │   │   │   │   ├── MF_4WayMotionNormal.uasset
│   │   │   │   │   ├── MF_4WayMotionNormal_TileSolved.uasset
│   │   │   │   │   ├── MF_4WayMotion_LinearColor.uasset
│   │   │   │   │   ├── MF_CratoonWaterTriplanarCaustic.uasset
│   │   │   │   │   ├── MF_FlowMapCalculator.uasset
│   │   │   │   │   ├── MF_GerstnerWave.uasset
│   │   │   │   │   ├── MF_GerstnerWave_Combined.uasset
│   │   │   │   │   ├── MF_GerstnerWave_Combined_River.uasset
│   │   │   │   │   ├── MF_NormalBlend.uasset
│   │   │   │   │   ├── MF_RiverMotionColor.uasset
│   │   │   │   │   ├── MF_RiverMotionNormal.uasset
│   │   │   │   │   ├── MF_TileRepeatSolver.uasset
│   │   │   │   │   ├── MF_WaterfallProceduralNoise.uasset
│   │   │   │   │   ├── MF_Waterline.uasset
│   │   │   │   │   └── MF_WetSand.uasset
│   │   │   │   ├── Particles
│   │   │   │   │   ├── MI_BasicParticle.uasset
│   │   │   │   │   ├── MI_Firefly.uasset
│   │   │   │   │   ├── MI_Rainbow.uasset
│   │   │   │   │   ├── M_BasicParticle.uasset
│   │   │   │   │   ├── M_Firefly.uasset
│   │   │   │   │   └── M_Rainbow.uasset
│   │   │   │   ├── Terrain
│   │   │   │   │   ├── Grass_LayerInfo.uasset
│   │   │   │   │   ├── M_Terrain.uasset
│   │   │   │   │   ├── M_Terrain_Inst.uasset
│   │   │   │   │   ├── Mud_LayerInfo.uasset
│   │   │   │   │   └── WetSandNotVisible_LayerInfo.uasset
│   │   │   │   ├── Underwater
│   │   │   │   │   ├── MI_BoxBlur_PP.uasset
│   │   │   │   │   ├── MI_BoxBlur_and_ScreenDistortion_PP.uasset
│   │   │   │   │   ├── MI_Underwater_PP.uasset
│   │   │   │   │   ├── MI_Underwater_River_PP.uasset
│   │   │   │   │   ├── M_BoxBlur_PP.uasset
│   │   │   │   │   ├── M_BoxBlur_and_ScreenDistortion_PP.uasset
│   │   │   │   │   ├── M_Underwater_PP.uasset
│   │   │   │   │   └── M_Underwater_River_PP.uasset
│   │   │   │   ├── Water
│   │   │   │   │   ├── Lake
│   │   │   │   │   │   ├── MI_Lake_Mobile_NonTransparent.uasset
│   │   │   │   │   │   ├── MI_Lake_Mobile_Transparent.uasset
│   │   │   │   │   │   ├── MI_Lake_NoTessellation_Depth.uasset
│   │   │   │   │   │   ├── MI_Lake_PBR_NonTransparent_NonTessellated.uasset
│   │   │   │   │   │   ├── MI_Lake_PBR_Transparent_NonTessellated.uasset
│   │   │   │   │   │   ├── MI_Lake_UNLIT_NonTransparent_NonTessellated.uasset
│   │   │   │   │   │   ├── MI_Lake_UNLIT_Transparent_NonTessellated.uasset
│   │   │   │   │   │   ├── M_Lake_Mobile_NonTransparent.uasset
│   │   │   │   │   │   ├── M_Lake_Mobile_Transparent.uasset
│   │   │   │   │   │   ├── M_Lake_NoTessellation_Depth.uasset
│   │   │   │   │   │   ├── M_Lake_PBR_NonTransparent_NonTessellated.uasset
│   │   │   │   │   │   ├── M_Lake_PBR_Transparent_NonTessellated.uasset
│   │   │   │   │   │   ├── M_Lake_UNLIT_NonTransparent_NonTessellated.uasset
│   │   │   │   │   │   └── M_Lake_UNLIT_Transparent_NonTessellated.uasset
│   │   │   │   │   ├── Ocean
│   │   │   │   │   │   ├── MI_Ocean_Mobile_NonTransparent.uasset
│   │   │   │   │   │   ├── MI_Ocean_Mobile_Transparent.uasset
│   │   │   │   │   │   ├── MI_Ocean_NoTessellation_Depth.uasset
│   │   │   │   │   │   ├── MI_Ocean_PBR_NonTransparent_NonTessellated.uasset
│   │   │   │   │   │   ├── MI_Ocean_PBR_Transparent_NonTessellated.uasset
│   │   │   │   │   │   ├── MI_Ocean_UNLIT_NonTransparent_NonTessellated.uasset
│   │   │   │   │   │   ├── MI_Ocean_UNLIT_Transparent_NonTessellated.uasset
│   │   │   │   │   │   ├── M_Ocean_Mobile_NonTransparent.uasset
│   │   │   │   │   │   ├── M_Ocean_Mobile_Transparent.uasset
│   │   │   │   │   │   ├── M_Ocean_NoTessellation_Depth.uasset
│   │   │   │   │   │   ├── M_Ocean_PBR_NonTransparent_NonTessellated.uasset
│   │   │   │   │   │   ├── M_Ocean_PBR_Transparent_NonTessellated.uasset
│   │   │   │   │   │   ├── M_Ocean_UNLIT_NonTransparent_NonTessellated.uasset
│   │   │   │   │   │   └── M_Ocean_UNLIT_Transparent_NonTessellated.uasset
│   │   │   │   │   ├── River
│   │   │   │   │   │   ├── MI_River_Mobile.uasset
│   │   │   │   │   │   ├── MI_River_Mobile_NonTransparent.uasset
│   │   │   │   │   │   ├── MI_River_NonTesselated_WaterDepth.uasset
│   │   │   │   │   │   ├── MI_River_PBR_NonTransparent_NonTesselated.uasset
│   │   │   │   │   │   ├── MI_River_PBR_Transparent_NonTesselated.uasset
│   │   │   │   │   │   ├── MI_River_Tesselated_WaterDepth.uasset
│   │   │   │   │   │   ├── MI_River_UNLIT_NonTransparent_NonTesselated.uasset
│   │   │   │   │   │   ├── MI_River_UNLIT_Transparent_NonTesselated.uasset
│   │   │   │   │   │   ├── M_River_Mobile.uasset
│   │   │   │   │   │   ├── M_River_Mobile_NonTransparent.uasset
│   │   │   │   │   │   ├── M_River_NonTesselated_WaterDepth.uasset
│   │   │   │   │   │   ├── M_River_PBR_NonTransparent_NonTesselated.uasset
│   │   │   │   │   │   ├── M_River_PBR_Transparent_NonTesselated.uasset
│   │   │   │   │   │   ├── M_River_Tesselated_WaterDepth.uasset
│   │   │   │   │   │   ├── M_River_UNLIT_NonTransparent_NonTesselated.uasset
│   │   │   │   │   │   └── M_River_UNLIT_Transparent_NonTesselated.uasset
│   │   │   │   │   ├── WaterDecal
│   │   │   │   │   │   ├── MI_WaterRippleDecal.uasset
│   │   │   │   │   │   ├── MI_WaterRipple_Lake.uasset
│   │   │   │   │   │   ├── MI_WaterRipple_Ocean.uasset
│   │   │   │   │   │   ├── MI_WaterRipple_River.uasset
│   │   │   │   │   │   ├── M_WaterRippleDecal.uasset
│   │   │   │   │   │   ├── M_WaterRipple_Lake.uasset
│   │   │   │   │   │   ├── M_WaterRipple_Ocean.uasset
│   │   │   │   │   │   └── M_WaterRipple_River.uasset
│   │   │   │   │   └── Waterfall
│   │   │   │   │       ├── MI_Waterfall_Bottom_Foam.uasset
│   │   │   │   │       ├── MI_Waterfall_Extra_Foam.uasset
│   │   │   │   │       ├── MI_Waterfall_Opaque.uasset
│   │   │   │   │       ├── MI_Waterfall_Splash.uasset
│   │   │   │   │       ├── MI_Waterfall_Transparent.uasset
│   │   │   │   │       ├── M_Waterfall_Bottom_Foam.uasset
│   │   │   │   │       ├── M_Waterfall_Extra_Foam.uasset
│   │   │   │   │       ├── M_Waterfall_Opaque.uasset
│   │   │   │   │       ├── M_Waterfall_Splash.uasset
│   │   │   │   │       └── M_Waterfall_Transparent.uasset
│   │   │   │   ├── WaterCaustic
│   │   │   │   │   ├── M_WaterCaustic.uasset
│   │   │   │   │   └── M_WaterCaustic_Inst.uasset
│   │   │   │   └── WaterLine
│   │   │   │       ├── MI_WaterLine_PP.uasset
│   │   │   │       └── M_WaterLine_PP.uasset
│   │   │   ├── Meshes
│   │   │   │   ├── Box
│   │   │   │   │   └── SM_Box.uasset
│   │   │   │   ├── Dock
│   │   │   │   │   └── SM_Dock.uasset
│   │   │   │   ├── GrassBlades
│   │   │   │   │   ├── FT_Grassblades.uasset
│   │   │   │   │   └── SM_GrassBlades.uasset
│   │   │   │   ├── House
│   │   │   │   │   └── SM_FantasyHouse.uasset
│   │   │   │   ├── Rainbow
│   │   │   │   │   └── SM_Rainbow.uasset
│   │   │   │   ├── Rock
│   │   │   │   │   └── SM_Rock.uasset
│   │   │   │   ├── RowBoat
│   │   │   │   │   ├── BP_Rowboat.uasset
│   │   │   │   │   ├── SM_Cap.uasset
│   │   │   │   │   └── SM_Rowboat.uasset
│   │   │   │   ├── Tree
│   │   │   │   │   └── SM_Tree.uasset
│   │   │   │   ├── Water
│   │   │   │   │   ├── SM_StilyzedWater_10x10.uasset
│   │   │   │   │   ├── SM_StilyzedWater_Depth_10x10.uasset
│   │   │   │   │   └── SM_StilyzedWater_SideDepth_10x10.uasset
│   │   │   │   ├── WaterRipples
│   │   │   │   │   └── SM_WaterRipples.uasset
│   │   │   │   └── Waterfalls
│   │   │   │       ├── SM_Waterfall_01.uasset
│   │   │   │       └── SM_Waterfall_Bottom_Foam.uasset
│   │   │   ├── Particles
│   │   │   │   ├── PS_Firefly.uasset
│   │   │   │   ├── PS_UnderwaterDirt.uasset
│   │   │   │   └── PS_Waterfall_BottomFoam.uasset
│   │   │   └── Textures
│   │   │       ├── Foliage
│   │   │       │   └── T_Foliage_BC.uasset
│   │   │       ├── House
│   │   │       │   ├── T_FantasyHouse_BC.uasset
│   │   │       │   ├── T_FantasyHouse_E.uasset
│   │   │       │   ├── T_FantasyHouse_M.uasset
│   │   │       │   ├── T_FantasyHouse_N.uasset
│   │   │       │   └── T_FantasyHouse_R.uasset
│   │   │       ├── Particle
│   │   │       │   └── T_UnderwaterDirt_M.uasset
│   │   │       ├── RT
│   │   │       │   └── RT_UnderwaterMesh.uasset
│   │   │       ├── Rock
│   │   │       │   ├── T_Rock_BC.uasset
│   │   │       │   ├── T_Rock_N.uasset
│   │   │       │   └── T_Rock_R.uasset
│   │   │       ├── Terrain
│   │   │       │   ├── T_StylizedGrass_BC.uasset
│   │   │       │   ├── T_StylizedGrass_H.uasset
│   │   │       │   ├── T_StylizedGrass_N.uasset
│   │   │       │   ├── T_StylizedGrass_R.uasset
│   │   │       │   ├── T_StylizedMud_BC.uasset
│   │   │       │   ├── T_StylizedMud_H.uasset
│   │   │       │   ├── T_StylizedMud_N.uasset
│   │   │       │   └── T_StylizedMud_R.uasset
│   │   │       ├── Tree
│   │   │       │   ├── T_Tree_BC.uasset
│   │   │       │   ├── T_Tree_N.uasset
│   │   │       │   └── T_Tree_R.uasset
│   │   │       ├── Wall
│   │   │       │   ├── T_Wall_BC.uasset
│   │   │       │   ├── T_Wall_N.uasset
│   │   │       │   └── T_Wall_R.uasset
│   │   │       ├── Water
│   │   │       │   ├── T_CartoonFoam_02_M.uasset
│   │   │       │   ├── T_CartoonFoam_03_M.uasset
│   │   │       │   ├── T_CartoonFoam_04_M.uasset
│   │   │       │   ├── T_CartoonFoam_05_M.uasset
│   │   │       │   ├── T_CartoonFoam_06_M.uasset
│   │   │       │   ├── T_CartoonFoam_M.uasset
│   │   │       │   ├── T_LowpolyFoamTexture_M.uasset
│   │   │       │   ├── T_Seafoam_BC.uasset
│   │   │       │   ├── T_StylizedWater_02_N.uasset
│   │   │       │   ├── T_StylizedWater_03_N.uasset
│   │   │       │   ├── T_StylizedWater_N.uasset
│   │   │       │   ├── T_StylizedWater_Ocean_DP.uasset
│   │   │       │   ├── T_StylizedWater_Ocean_N.uasset
│   │   │       │   ├── T_StylizedWater_River_02_N.uasset
│   │   │       │   ├── T_StylizedWater_River_03_N.uasset
│   │   │       │   ├── T_StylizedWater_River_04_N.uasset
│   │   │       │   ├── T_StylizedWater_River_05_N.uasset
│   │   │       │   ├── T_StylizedWater_River_N.uasset
│   │   │       │   ├── T_WaterLowpoly_N.uasset
│   │   │       │   ├── T_WaterRipples_02_M.uasset
│   │   │       │   ├── T_WaterRipples_M.uasset
│   │   │       │   └── T_Water_DP.uasset
│   │   │       └── WaterCaustic
│   │   │           ├── T_WaterCaustic_BC.uasset
│   │   │           └── T_WaterCaustic_M.uasset
│   │   ├── Characters
│   │   │   ├── Mannequin_UE4
│   │   │   │   ├── Animations
│   │   │   │   │   └── Jog_Fwd.uasset
│   │   │   │   ├── Materials
│   │   │   │   │   ├── Layers
│   │   │   │   │   │   ├── ML_Latex_Black.uasset
│   │   │   │   │   │   ├── ML_ShinyPlastic_Beige.uasset
│   │   │   │   │   │   ├── ML_ShinyPlastic_Beige_Logo.uasset
│   │   │   │   │   │   └── ML_SoftMetal.uasset
│   │   │   │   │   ├── M_MannequinUE4_Body.uasset
│   │   │   │   │   └── M_MannequinUE4_ChestLogo.uasset
│   │   │   │   ├── Meshes
│   │   │   │   │   ├── SK_Mannequin.uasset
│   │   │   │   │   ├── SK_Mannequin_PhysicsAsset.uasset
│   │   │   │   │   └── SK_Mannequin_Skeleton.uasset
│   │   │   │   ├── Rigs
│   │   │   │   │   ├── IK_UE4_Mannequin.uasset
│   │   │   │   │   ├── RTG_UE4Manny_UE5Manny.uasset
│   │   │   │   │   └── RTG_UE5Manny_UE4Manny.uasset
│   │   │   │   └── Textures
│   │   │   │       ├── T_ML_Aluminum01.uasset
│   │   │   │       ├── T_ML_Aluminum01_N.uasset
│   │   │   │       ├── T_ML_Rubber_Blue_01_D.uasset
│   │   │   │       ├── T_ML_Rubber_Blue_01_N.uasset
│   │   │   │       ├── T_UE4_Mannequin_MAT_MASKA.uasset
│   │   │   │       ├── T_UE4_Mannequin__normals.uasset
│   │   │   │       ├── T_UELogo_Mask.uasset
│   │   │   │       └── T_UELogo_N_TGA.uasset
│   │   │   └── Mannequins
│   │   │       ├── Animations
│   │   │       │   ├── ABP_Manny.uasset
│   │   │       │   ├── ABP_Quinn.uasset
│   │   │       │   ├── Manny
│   │   │       │   │   ├── BS_MM_WalkRun.uasset
│   │   │       │   │   ├── MM_Fall_Loop.uasset
│   │   │       │   │   ├── MM_Idle.uasset
│   │   │       │   │   ├── MM_Jump.uasset
│   │   │       │   │   ├── MM_Land.uasset
│   │   │       │   │   ├── MM_Run_Fwd.uasset
│   │   │       │   │   ├── MM_Walk_Fwd.uasset
│   │   │       │   │   └── MM_Walk_InPlace.uasset
│   │   │       │   └── Quinn
│   │   │       │       ├── BS_MF_Unarmed_WalkRun.uasset
│   │   │       │       ├── MF_Idle.uasset
│   │   │       │       ├── MF_Run_Fwd.uasset
│   │   │       │       └── MF_Walk_Fwd.uasset
│   │   │       ├── Materials
│   │   │       │   ├── Functions
│   │   │       │   │   ├── CA_Mannequin.uasset
│   │   │       │   │   ├── ChromaticCurve.uasset
│   │   │       │   │   ├── MF_Diffraction.uasset
│   │   │       │   │   ├── MF_logo3layers.uasset
│   │   │       │   │   └── ML_BaseColorFallOff.uasset
│   │   │       │   ├── Instances
│   │   │       │   │   ├── Manny
│   │   │       │   │   │   ├── MI_Manny_01.uasset
│   │   │       │   │   │   └── MI_Manny_02.uasset
│   │   │       │   │   └── Quinn
│   │   │       │   │       ├── MI_Quinn_01.uasset
│   │   │       │   │       └── MI_Quinn_02.uasset
│   │   │       │   └── M_Mannequin.uasset
│   │   │       ├── Meshes
│   │   │       │   ├── Mannequin_LODSettings.uasset
│   │   │       │   ├── SKM_Manny.uasset
│   │   │       │   ├── SKM_Manny_Simple.uasset
│   │   │       │   ├── SKM_Quinn.uasset
│   │   │       │   ├── SKM_Quinn_Simple.uasset
│   │   │       │   └── SK_Mannequin.uasset
│   │   │       ├── Rigs
│   │   │       │   ├── ABP_Manny_PostProcess.uasset
│   │   │       │   ├── ABP_Quinn_PostProcess.uasset
│   │   │       │   ├── CR_Mannequin_BasicFootIK.uasset
│   │   │       │   ├── CR_Mannequin_Body.uasset
│   │   │       │   ├── CR_Mannequin_Procedural.uasset
│   │   │       │   ├── IK_Mannequin.uasset
│   │   │       │   ├── PA_Mannequin.uasset
│   │   │       │   ├── Poses
│   │   │       │   │   ├── Manny
│   │   │       │   │   │   ├── Manny_calf_l_anim.uasset
│   │   │       │   │   │   ├── Manny_calf_l_pose.uasset
│   │   │       │   │   │   ├── Manny_calf_r_anim.uasset
│   │   │       │   │   │   ├── Manny_calf_r_pose.uasset
│   │   │       │   │   │   ├── Manny_clavicle_l_anim.uasset
│   │   │       │   │   │   ├── Manny_clavicle_l_pose.uasset
│   │   │       │   │   │   ├── Manny_clavicle_r_anim.uasset
│   │   │       │   │   │   ├── Manny_clavicle_r_pose.uasset
│   │   │       │   │   │   ├── Manny_foot_l_anim.uasset
│   │   │       │   │   │   ├── Manny_foot_l_pose.uasset
│   │   │       │   │   │   ├── Manny_foot_r_anim.uasset
│   │   │       │   │   │   ├── Manny_foot_r_pose.uasset
│   │   │       │   │   │   ├── Manny_hand_l_anim.uasset
│   │   │       │   │   │   ├── Manny_hand_l_pose.uasset
│   │   │       │   │   │   ├── Manny_hand_r_anim.uasset
│   │   │       │   │   │   ├── Manny_hand_r_pose.uasset
│   │   │       │   │   │   ├── Manny_lowerarm_l_anim.uasset
│   │   │       │   │   │   ├── Manny_lowerarm_l_pose.uasset
│   │   │       │   │   │   ├── Manny_lowerarm_r_anim.uasset
│   │   │       │   │   │   ├── Manny_lowerarm_r_pose.uasset
│   │   │       │   │   │   ├── Manny_thigh_l_anim.uasset
│   │   │       │   │   │   ├── Manny_thigh_l_pose.uasset
│   │   │       │   │   │   ├── Manny_thigh_r_anim.uasset
│   │   │       │   │   │   ├── Manny_thigh_r_pose.uasset
│   │   │       │   │   │   ├── Manny_upperarm_l_anim.uasset
│   │   │       │   │   │   ├── Manny_upperarm_l_pose.uasset
│   │   │       │   │   │   ├── Manny_upperarm_r_anim.uasset
│   │   │       │   │   │   └── Manny_upperarm_r_pose.uasset
│   │   │       │   │   └── Quinn
│   │   │       │   │       ├── Quinn_calf_l_anim.uasset
│   │   │       │   │       ├── Quinn_calf_l_pose.uasset
│   │   │       │   │       ├── Quinn_calf_r_anim.uasset
│   │   │       │   │       ├── Quinn_calf_r_pose.uasset
│   │   │       │   │       ├── Quinn_clavicle_l_anim.uasset
│   │   │       │   │       ├── Quinn_clavicle_l_pose.uasset
│   │   │       │   │       ├── Quinn_clavicle_r_anim.uasset
│   │   │       │   │       ├── Quinn_clavicle_r_pose.uasset
│   │   │       │   │       ├── Quinn_foot_l_anim.uasset
│   │   │       │   │       ├── Quinn_foot_l_pose.uasset
│   │   │       │   │       ├── Quinn_foot_r_anim.uasset
│   │   │       │   │       ├── Quinn_foot_r_pose.uasset
│   │   │       │   │       ├── Quinn_hand_l_anim.uasset
│   │   │       │   │       ├── Quinn_hand_l_pose.uasset
│   │   │       │   │       ├── Quinn_hand_r_anim.uasset
│   │   │       │   │       ├── Quinn_hand_r_pose.uasset
│   │   │       │   │       ├── Quinn_lowerarm_l_anim.uasset
│   │   │       │   │       ├── Quinn_lowerarm_l_pose.uasset
│   │   │       │   │       ├── Quinn_lowerarm_r_anim.uasset
│   │   │       │   │       ├── Quinn_lowerarm_r_pose.uasset
│   │   │       │   │       ├── Quinn_thigh_l_anim.uasset
│   │   │       │   │       ├── Quinn_thigh_l_pose.uasset
│   │   │       │   │       ├── Quinn_thigh_r_anim.uasset
│   │   │       │   │       ├── Quinn_thigh_r_pose.uasset
│   │   │       │   │       ├── Quinn_upperarm_l_anim.uasset
│   │   │       │   │       ├── Quinn_upperarm_l_pose.uasset
│   │   │       │   │       ├── Quinn_upperarm_r_anim.uasset
│   │   │       │   │       └── Quinn_upperarm_r_pose.uasset
│   │   │       │   └── RTG_Mannequin.uasset
│   │   │       └── Textures
│   │   │           ├── Manny
│   │   │           │   ├── T_Manny_01_ASAOPMASK_MSK.uasset
│   │   │           │   ├── T_Manny_01_BN.uasset
│   │   │           │   ├── T_Manny_01_CCRCCPlastic_MSK.uasset
│   │   │           │   ├── T_Manny_01_D.uasset
│   │   │           │   ├── T_Manny_01_MSR_MSK.uasset
│   │   │           │   ├── T_Manny_01_N.uasset
│   │   │           │   ├── T_Manny_01_Tan.uasset
│   │   │           │   ├── T_Manny_02_ASAOPMASK_MSK.uasset
│   │   │           │   ├── T_Manny_02_BN.uasset
│   │   │           │   ├── T_Manny_02_CCRCCPlastic_MSK.uasset
│   │   │           │   ├── T_Manny_02_D.uasset
│   │   │           │   ├── T_Manny_02_MSR_MSK.uasset
│   │   │           │   ├── T_Manny_02_N.uasset
│   │   │           │   └── T_Manny_02_Tan.uasset
│   │   │           ├── Quinn
│   │   │           │   ├── T_Quinn_01ID_BN.uasset
│   │   │           │   ├── T_Quinn_01ID_D.uasset
│   │   │           │   ├── T_Quinn_01ID_MSR_MSK.uasset
│   │   │           │   ├── T_Quinn_01ID_N.uasset
│   │   │           │   ├── T_Quinn_01ID_Tan.uasset
│   │   │           │   ├── T_Quinn_01_ASAOMASK_MSK.uasset
│   │   │           │   ├── T_Quinn_01_CCRCCPlastic_MSK.uasset
│   │   │           │   ├── T_Quinn_02ID_BN.uasset
│   │   │           │   ├── T_Quinn_02ID_D.uasset
│   │   │           │   ├── T_Quinn_02ID_MSR_MSK.uasset
│   │   │           │   ├── T_Quinn_02ID_N.uasset
│   │   │           │   ├── T_Quinn_02ID_Tan.uasset
│   │   │           │   ├── T_Quinn_02_ASAOMASK_MSK.uasset
│   │   │           │   └── T_Quinn_02_CCRCCPlastic_MSK.uasset
│   │   │           └── Shared
│   │   │               └── T_UE_Logo_M.uasset
│   │   ├── Curves
│   │   │   └── DissolveCurve.uasset
│   │   ├── FPS_Weapon_Bundle
│   │   │   └── Weapons
│   │   │       ├── Materials
│   │   │       │   ├── Ammunition
│   │   │       │   │   └── M_9mm.uasset
│   │   │       │   ├── Master_Material
│   │   │       │   │   └── M_Weapon_Master_USE.uasset
│   │   │       │   └── SMG11
│   │   │       │       ├── M_SMG11.uasset
│   │   │       │       └── M_SMG11_Rem.uasset
│   │   │       ├── Meshes
│   │   │       │   └── SMG11
│   │   │       │       ├── SK_SMG11_Nostock_X.uasset
│   │   │       │       ├── SK_SMG11_Nostock_X_Physics.uasset
│   │   │       │       ├── SK_SMG11_Nostock_X_Skeleton.uasset
│   │   │       │       ├── SK_SMG11_Nostock_Y.uasset
│   │   │       │       ├── SK_SMG11_Nostock_Y_Physics.uasset
│   │   │       │       ├── SK_SMG11_Nostock_Y_Skeleton.uasset
│   │   │       │       ├── SK_SMG11_X.uasset
│   │   │       │       ├── SK_SMG11_X_Physics.uasset
│   │   │       │       ├── SK_SMG11_X_Skeleton.uasset
│   │   │       │       ├── SK_SMG11_Y.uasset
│   │   │       │       ├── SK_SMG11_Y_Physics.uasset
│   │   │       │       ├── SK_SMG11_Y_Skeleton.uasset
│   │   │       │       ├── SMG_PhyAt_Strap.uasset
│   │   │       │       ├── SM_SMG11_Mag_Empty_X.uasset
│   │   │       │       ├── SM_SMG11_Mag_Empty_Y.uasset
│   │   │       │       ├── SM_SMG11_Mag_X.uasset
│   │   │       │       ├── SM_SMG11_Nostock_X.uasset
│   │   │       │       ├── SM_SMG11_Nostock_Y.uasset
│   │   │       │       ├── SM_SMG11_X.uasset
│   │   │       │       └── SM_SMG11_Y.uasset
│   │   │       └── Textures
│   │   │           ├── Ammunition
│   │   │           │   ├── T_9mm_ALB.uasset
│   │   │           │   ├── T_9mm_M_MSK.uasset
│   │   │           │   └── T_9mm_NRM.uasset
│   │   │           ├── KA74U
│   │   │           │   ├── T_KA74U_ALB.uasset
│   │   │           │   ├── T_KA74U_M_MSK.uasset
│   │   │           │   └── T_KA74U_NRM.uasset
│   │   │           ├── Patterns
│   │   │           │   └── T_Stripes__Pattern.uasset
│   │   │           └── SMG11
│   │   │               ├── T_SMG11_ALB.uasset
│   │   │               ├── T_SMG11_M_MSK.uasset
│   │   │               ├── T_SMG11_NRM.uasset
│   │   │               ├── T_SMG11_Rem_ALB.uasset
│   │   │               ├── T_SMG11_Rem_M_MSK.uasset
│   │   │               └── T_SMG11_Rem_NRM.uasset
│   │   ├── FX
│   │   │   ├── RocketTrail
│   │   │   │   ├── MI_TrailSmoke.uasset
│   │   │   │   ├── M_TrailSmoke.uasset
│   │   │   │   ├── NE_TrailSmokeEmitter.uasset
│   │   │   │   ├── NS_TrailSmoke.uasset
│   │   │   │   └── NS_TrailSmoke_grenade.uasset
│   │   │   ├── SmokeBeam
│   │   │   │   ├── BeamTextureThin.uasset
│   │   │   │   ├── M_Beam.uasset
│   │   │   │   └── P_SmokeTrail.uasset
│   │   │   └── SniperScope
│   │   │       ├── BlkBG1920x1080.uasset
│   │   │       └── SniperScopeNoBG.uasset
│   │   ├── Fonts
│   │   │   ├── Kodchasan-Bold.uasset
│   │   │   ├── Kodchasan-BoldItalic.uasset
│   │   │   ├── Kodchasan-BoldItalic_Font.uasset
│   │   │   ├── Kodchasan-Bold_Font.uasset
│   │   │   ├── Kodchasan-ExtraLight.uasset
│   │   │   ├── Kodchasan-ExtraLightItalic.uasset
│   │   │   ├── Kodchasan-ExtraLightItalic_Font.uasset
│   │   │   ├── Kodchasan-ExtraLight_Font.uasset
│   │   │   ├── Kodchasan-Italic.uasset
│   │   │   ├── Kodchasan-Italic_Font.uasset
│   │   │   ├── Kodchasan-Light.uasset
│   │   │   ├── Kodchasan-LightItalic.uasset
│   │   │   ├── Kodchasan-LightItalic_Font.uasset
│   │   │   ├── Kodchasan-Light_Font.uasset
│   │   │   ├── Kodchasan-Medium.uasset
│   │   │   ├── Kodchasan-MediumItalic.uasset
│   │   │   ├── Kodchasan-MediumItalic_Font.uasset
│   │   │   ├── Kodchasan-Medium_Font.uasset
│   │   │   ├── Kodchasan-Regular.uasset
│   │   │   ├── Kodchasan-Regular_Font.uasset
│   │   │   ├── Kodchasan-SemiBold.uasset
│   │   │   ├── Kodchasan-SemiBoldItalic.uasset
│   │   │   ├── Kodchasan-SemiBoldItalic_Font.uasset
│   │   │   └── Kodchasan-SemiBold_Font.uasset
│   │   ├── HQUI_ProgressBars
│   │   │   ├── Blueprints
│   │   │   │   ├── Enums
│   │   │   │   │   ├── EEffectLayer.uasset
│   │   │   │   │   ├── EEffectType.uasset
│   │   │   │   │   ├── EGradientTypes.uasset
│   │   │   │   │   ├── EMarqueeMask.uasset
│   │   │   │   │   ├── EMarqueeMethod.uasset
│   │   │   │   │   ├── EProgressMethod.uasset
│   │   │   │   │   └── ETriggerMethod.uasset
│   │   │   │   ├── Interfaces
│   │   │   │   │   └── BPi_ProgressBars.uasset
│   │   │   │   ├── Libraries
│   │   │   │   │   ├── BP_ProgressBar_Functions.uasset
│   │   │   │   │   ├── BP_Widget_Functions.uasset
│   │   │   │   │   └── BP_Widget_Macros.uasset
│   │   │   │   └── Structs
│   │   │   │       └── S_Effects.uasset
│   │   │   ├── DemoContent
│   │   │   │   ├── Audio
│   │   │   │   │   └── SW_PowerUp1.uasset
│   │   │   │   ├── DemoLevel.umap
│   │   │   │   ├── Materials
│   │   │   │   │   ├── MI_CurvedHUD_Inst.uasset
│   │   │   │   │   ├── MI_UIFX_01_Inst.uasset
│   │   │   │   │   ├── MI_UIFX_Mask01_Inst.uasset
│   │   │   │   │   ├── MI_UIFX_Mask02_Inst.uasset
│   │   │   │   │   ├── M_CurvedHUD.uasset
│   │   │   │   │   ├── M_UIFX_Mask_Master.uasset
│   │   │   │   │   └── M_UIFX_Master.uasset
│   │   │   │   ├── Textures
│   │   │   │   │   ├── T_AddPoint_Empty.uasset
│   │   │   │   │   ├── T_AddPoint_Fill.uasset
│   │   │   │   │   ├── T_Arrow_L_128x128.uasset
│   │   │   │   │   ├── T_BG_Mood_06_1920x1080.uasset
│   │   │   │   │   ├── T_Brand.uasset
│   │   │   │   │   ├── T_ClickFX_256x256.uasset
│   │   │   │   │   ├── T_Demo1_1920x1080.uasset
│   │   │   │   │   ├── T_Demo2_1920x1080.uasset
│   │   │   │   │   ├── T_Demo4_1920x1080.uasset
│   │   │   │   │   ├── T_Demo5_1920x1080.uasset
│   │   │   │   │   ├── T_Demo6_1920x1080.uasset
│   │   │   │   │   ├── T_DemoCircleMask2_512x512.uasset
│   │   │   │   │   ├── T_DemoCircleMask3_512x512.uasset
│   │   │   │   │   ├── T_DemoCircleMask4_512x512.uasset
│   │   │   │   │   ├── T_DemoCircleMask5_768x768.uasset
│   │   │   │   │   ├── T_DemoCircle_128x128.uasset
│   │   │   │   │   ├── T_DemoIcon2.uasset
│   │   │   │   │   ├── T_DemoIcon3.uasset
│   │   │   │   │   ├── T_DemoIcon4.uasset
│   │   │   │   │   ├── T_DemoIcon5.uasset
│   │   │   │   │   ├── T_DemoIcon6.uasset
│   │   │   │   │   ├── T_DemoIcon7.uasset
│   │   │   │   │   ├── T_DemoIcon8.uasset
│   │   │   │   │   ├── T_DemoMask3_138x6.uasset
│   │   │   │   │   ├── T_DemoMask3_138x9.uasset
│   │   │   │   │   ├── T_DemoMask3_168x20.uasset
│   │   │   │   │   ├── T_DemoMask_1024x30.uasset
│   │   │   │   │   ├── T_DemoMask_40x40.uasset
│   │   │   │   │   ├── T_DemoMask_512x512.uasset
│   │   │   │   │   ├── T_Gradient_64x64.uasset
│   │   │   │   │   ├── T_Shine01_256x256.uasset
│   │   │   │   │   ├── T_Shine1_64x256.uasset
│   │   │   │   │   ├── T_Shine2_64x256.uasset
│   │   │   │   │   ├── T_Shine3_64x256.uasset
│   │   │   │   │   ├── T_UIFX_01_8x8_4k.uasset
│   │   │   │   │   ├── T_UIFX_Mask_01_8x8_2k.uasset
│   │   │   │   │   └── T_Waves1_8x8.uasset
│   │   │   │   └── Widgets
│   │   │   │       └── WB_DemoWidget.uasset
│   │   │   ├── Materials
│   │   │   │   ├── CircleProgress
│   │   │   │   │   ├── MI_CircleMarquee_Inst.uasset
│   │   │   │   │   ├── MI_CircleProgress_Inst.uasset
│   │   │   │   │   ├── MI_CircleTargetProgress_Inst.uasset
│   │   │   │   │   ├── MI_MarqueeBackground_Inst.uasset
│   │   │   │   │   ├── M_CircleMarquee.uasset
│   │   │   │   │   └── M_CircleProgress.uasset
│   │   │   │   ├── Functions
│   │   │   │   │   ├── MF_MapRangeClamped.uasset
│   │   │   │   │   └── MF_PB_UVDirection.uasset
│   │   │   │   ├── LinearProgress
│   │   │   │   │   ├── FillTypes
│   │   │   │   │   │   ├── MI_LeftToRight_Inst.uasset
│   │   │   │   │   │   ├── MI_RightToLeft_Inst.uasset
│   │   │   │   │   │   └── MI_TopToBottom_Inst.uasset
│   │   │   │   │   ├── MI_RetainerBlend_Inst.uasset
│   │   │   │   │   ├── MI_RetainerGradientBlend_Inst.uasset
│   │   │   │   │   ├── M_LinearShader.uasset
│   │   │   │   │   ├── M_RetainerBlend.uasset
│   │   │   │   │   └── M_RetainerGradientBlend.uasset
│   │   │   │   └── Marquee
│   │   │   │       ├── MI_Marquee_Inst.uasset
│   │   │   │       └── M_Marquee.uasset
│   │   │   ├── Textures
│   │   │   │   ├── Circular
│   │   │   │   │   ├── T_BaseMask2.uasset
│   │   │   │   │   ├── T_CircleMarquee1_1024x1024.uasset
│   │   │   │   │   ├── T_CircleMarquee2_1024x1024.uasset
│   │   │   │   │   ├── T_CircleMarquee3_1024x1024.uasset
│   │   │   │   │   ├── T_CircleMarquee4_1024x1024.uasset
│   │   │   │   │   ├── T_CircleMarquee5_1024x1024.uasset
│   │   │   │   │   ├── T_GradientMask1_1024x1024.uasset
│   │   │   │   │   ├── T_GradientMask2_1024x1024.uasset
│   │   │   │   │   ├── T_GradientMask3_1024x1024.uasset
│   │   │   │   │   └── T_GradientMask4_1024x1024.uasset
│   │   │   │   ├── Linear
│   │   │   │   │   └── Gradients
│   │   │   │   │       ├── T_PB_Gradient1_1024x1024.uasset
│   │   │   │   │       ├── T_PB_Gradient2_1024x1024.uasset
│   │   │   │   │       ├── T_PB_Gradient3_1024x1024.uasset
│   │   │   │   │       └── T_PB_Gradient4_1024x1024.uasset
│   │   │   │   └── Masks
│   │   │   │       ├── 1024x256
│   │   │   │       │   └── T_SoftShine_1024x256.uasset
│   │   │   │       ├── 256x16
│   │   │   │       │   ├── T_Mask1_256x16.uasset
│   │   │   │       │   ├── T_Mask2_256x16.uasset
│   │   │   │       │   ├── T_Mask3_256x16.uasset
│   │   │   │       │   ├── T_Mask4_256x16.uasset
│   │   │   │       │   ├── T_Mask5_256x16.uasset
│   │   │   │       │   ├── T_Mask6_256x16.uasset
│   │   │   │       │   └── T_Mask7_256x16.uasset
│   │   │   │       ├── 256x256
│   │   │   │       │   └── T_Cross_256x256.uasset
│   │   │   │       ├── 512x512
│   │   │   │       │   └── T_ShineEllipse_512x512.uasset
│   │   │   │       ├── Marquee
│   │   │   │       │   ├── T_Marquee_Mask0.uasset
│   │   │   │       │   ├── T_Marquee_Mask1.uasset
│   │   │   │       │   ├── T_Marquee_Mask2-1.uasset
│   │   │   │       │   ├── T_Marquee_Mask3.uasset
│   │   │   │       │   └── T_Marquee_Mask4.uasset
│   │   │   │       └── T_Mask_Base_1024x1024.uasset
│   │   │   └── Widgets
│   │   │       ├── Base
│   │   │       │   ├── ProgressBars
│   │   │       │   │   ├── WB_BaseProgressBar.uasset
│   │   │       │   │   ├── WB_PB_Linear_Base.uasset
│   │   │       │   │   ├── WB_PB_Linear_Target.uasset
│   │   │       │   │   └── WB_Particle.uasset
│   │   │       │   └── WB_Base.uasset
│   │   │       ├── ProgressBarCircular
│   │   │       │   ├── Content
│   │   │       │   │   ├── WB_Container_Circular.uasset
│   │   │       │   │   └── WB_Effect_Circular.uasset
│   │   │       │   └── ProgressBarCircular.uasset
│   │   │       └── ProgressBarLinear
│   │   │           ├── Content
│   │   │           │   ├── WB_Container_Linear.uasset
│   │   │           │   ├── WB_Effect.uasset
│   │   │           │   ├── WB_Image_Raw.uasset
│   │   │           │   ├── WB_LinearProgress_Separated.uasset
│   │   │           │   ├── WB_Marquee_Linear.uasset
│   │   │           │   └── WB_PB_Raw.uasset
│   │   │           └── ProgressBarLinear.uasset
│   │   ├── LUSH_StylizedEnvironmentSet
│   │   │   ├── EpicDemoContent
│   │   │   │   ├── Characters
│   │   │   │   │   └── Mannequins
│   │   │   │   │       ├── Animations
│   │   │   │   │       │   ├── ABP_DemoManny.uasset
│   │   │   │   │       │   ├── ABP_DemoQuinn.uasset
│   │   │   │   │       │   ├── Manny
│   │   │   │   │       │   │   ├── A_Demo_MM_Fall_Loop.uasset
│   │   │   │   │       │   │   ├── A_Demo_MM_Idle.uasset
│   │   │   │   │       │   │   ├── A_Demo_MM_Jump.uasset
│   │   │   │   │       │   │   ├── A_Demo_MM_Land.uasset
│   │   │   │   │       │   │   ├── A_Demo_MM_Run_Fwd.uasset
│   │   │   │   │       │   │   ├── A_Demo_MM_Walk_Fwd.uasset
│   │   │   │   │       │   │   ├── A_Demo_MM_Walk_InPlace.uasset
│   │   │   │   │       │   │   └── BS_Demo_MM_WalkRun.uasset
│   │   │   │   │       │   └── Quinn
│   │   │   │   │       │       ├── A_Demo_MF_Idle.uasset
│   │   │   │   │       │       ├── A_Demo_MF_Run_Fwd.uasset
│   │   │   │   │       │       ├── A_Demo_MF_Walk_Fwd.uasset
│   │   │   │   │       │       └── BS_Demo_MF_Unarmed_WalkRun.uasset
│   │   │   │   │       ├── Materials
│   │   │   │   │       │   └── M_DemoMannequin_Basic.uasset
│   │   │   │   │       ├── Meshes
│   │   │   │   │       │   ├── SKM_DemoManny_Simple.uasset
│   │   │   │   │       │   ├── SKM_DemoQuinn_Simple.uasset
│   │   │   │   │       │   └── SK_DemoMannequin.uasset
│   │   │   │   │       └── Rigs
│   │   │   │   │           ├── CR_DemoMannequin_BasicFootIK.uasset
│   │   │   │   │           └── PA_DemoMannequin.uasset
│   │   │   │   └── ThirdPerson
│   │   │   │       ├── Blueprints
│   │   │   │       │   ├── BP_DemoGameMode.uasset
│   │   │   │       │   └── BP_DemoThirdPersonCharacter.uasset
│   │   │   │       └── Input
│   │   │   │           ├── Actions
│   │   │   │           │   ├── IA_Demo_CameraDistance.uasset
│   │   │   │           │   ├── IA_Demo_EnableLumen.uasset
│   │   │   │           │   ├── IA_Demo_Jump.uasset
│   │   │   │           │   ├── IA_Demo_Look.uasset
│   │   │   │           │   ├── IA_Demo_Move.uasset
│   │   │   │           │   ├── IA_Demo_Run.uasset
│   │   │   │           │   └── IA_Demo_SwitchMesh.uasset
│   │   │   │           ├── IMC_Demo_Debugging.uasset
│   │   │   │           └── IMC_Demo_General.uasset
│   │   │   ├── Foliage
│   │   │   │   ├── Bushes
│   │   │   │   │   ├── Materials
│   │   │   │   │   │   └── MI_Leaves_Bushes.uasset
│   │   │   │   │   ├── SMF_Bush_Large.uasset
│   │   │   │   │   ├── SMF_Bush_Medium_01.uasset
│   │   │   │   │   ├── SMF_Bush_Medium_02.uasset
│   │   │   │   │   ├── SMF_Bush_Medium_03.uasset
│   │   │   │   │   ├── SMF_Bush_Medium_04.uasset
│   │   │   │   │   ├── SM_Bush_Large.uasset
│   │   │   │   │   ├── SM_Bush_Medium_01.uasset
│   │   │   │   │   ├── SM_Bush_Medium_02.uasset
│   │   │   │   │   ├── SM_Bush_Medium_03.uasset
│   │   │   │   │   └── SM_Bush_Medium_04.uasset
│   │   │   │   ├── Flowers
│   │   │   │   │   ├── Materials
│   │   │   │   │   │   └── MI_Flowers_01.uasset
│   │   │   │   │   ├── SMF_Flowers_A_01.uasset
│   │   │   │   │   ├── SMF_Flowers_B_01.uasset
│   │   │   │   │   ├── SMF_Flowers_C_01.uasset
│   │   │   │   │   ├── SMF_Flowers_D_01.uasset
│   │   │   │   │   ├── SM_FlowerClump_A_01.uasset
│   │   │   │   │   ├── SM_FlowerClump_A_02.uasset
│   │   │   │   │   ├── SM_FlowerClump_B_01.uasset
│   │   │   │   │   ├── SM_FlowerClump_B_02.uasset
│   │   │   │   │   ├── SM_FlowerClump_C_01.uasset
│   │   │   │   │   ├── SM_FlowerClump_C_02.uasset
│   │   │   │   │   ├── SM_FlowerClump_D_01.uasset
│   │   │   │   │   ├── SM_FlowerClump_D_02.uasset
│   │   │   │   │   └── Textures
│   │   │   │   │       └── T_Flowers_01_D.uasset
│   │   │   │   ├── Grass
│   │   │   │   │   ├── LG_AutoGrass.uasset
│   │   │   │   │   ├── LG_Grass.uasset
│   │   │   │   │   ├── Materials
│   │   │   │   │   │   ├── MI_Grass_01.uasset
│   │   │   │   │   │   ├── MI_Grass_01_overview.uasset
│   │   │   │   │   │   ├── MI_Grass_Tiny_A.uasset
│   │   │   │   │   │   └── MI_Grass_Tiny_A_overview.uasset
│   │   │   │   │   ├── SMF_Grass.uasset
│   │   │   │   │   ├── SMF_Grass_Tiny.uasset
│   │   │   │   │   ├── SMF_TinyGrass.uasset
│   │   │   │   │   ├── SM_Grass_Generic.uasset
│   │   │   │   │   └── SM_Grass_Tiny.uasset
│   │   │   │   ├── GroundIvy
│   │   │   │   │   ├── LG_GroundIvy.uasset
│   │   │   │   │   ├── Materials
│   │   │   │   │   │   └── MI_GroundIvy.uasset
│   │   │   │   │   ├── SM_GroundIvy_01.uasset
│   │   │   │   │   ├── SM_GroundIvy_02.uasset
│   │   │   │   │   ├── SM_GroundIvy_03.uasset
│   │   │   │   │   ├── SM_GroundIvy_04.uasset
│   │   │   │   │   └── Textures
│   │   │   │   │       ├── T_GroundIvy_D.uasset
│   │   │   │   │       ├── T_GroundIvy_N.uasset
│   │   │   │   │       └── T_GroundIvy_RAOH.uasset
│   │   │   │   ├── PFS_Trees.uasset
│   │   │   │   ├── Plants
│   │   │   │   │   ├── Materials
│   │   │   │   │   │   ├── MI_LilyPad.uasset
│   │   │   │   │   │   └── MI_Plant_Taro.uasset
│   │   │   │   │   ├── SMF_Plant_Taro_01.uasset
│   │   │   │   │   ├── SMF_Plant_Taro_02.uasset
│   │   │   │   │   ├── SM_LilyPad.uasset
│   │   │   │   │   ├── SM_Plant_Taro_01.uasset
│   │   │   │   │   ├── SM_Plant_Taro_02.uasset
│   │   │   │   │   └── Textures
│   │   │   │   │       ├── T_LilyPad_D.uasset
│   │   │   │   │       ├── T_LilyPad_N.uasset
│   │   │   │   │       ├── T_eleplant_leaf_01.uasset
│   │   │   │   │       └── T_eleplant_leaf_01_N.uasset
│   │   │   │   └── Trees
│   │   │   │       ├── Materials
│   │   │   │       │   ├── MI_BananaLeaf_01.uasset
│   │   │   │       │   ├── MI_Bark_01.uasset
│   │   │   │       │   ├── MI_Bark_02.uasset
│   │   │   │       │   ├── MI_Bark_03.uasset
│   │   │   │       │   ├── MI_Bark_04_Moss.uasset
│   │   │   │       │   ├── MI_Bark_05.uasset
│   │   │   │       │   ├── MI_Bark_BananaTree.uasset
│   │   │   │       │   ├── MI_Leaves_SwampTree_01.uasset
│   │   │   │       │   ├── MI_Leaves_Tree_01.uasset
│   │   │   │       │   ├── MI_Palm_A_Bark_01.uasset
│   │   │   │       │   ├── MI_Palm_A_Leaf_01.uasset
│   │   │   │       │   ├── MI_Palm_B_Bark_01.uasset
│   │   │   │       │   ├── MI_Palm_B_Leaf_01.uasset
│   │   │   │       │   ├── MI_Tree_Large_Bark.uasset
│   │   │   │       │   └── M_Bark_Base.uasset
│   │   │   │       ├── SMF_BananaTree_01.uasset
│   │   │   │       ├── SMF_BananaTree_02.uasset
│   │   │   │       ├── SMF_BananaTree_03.uasset
│   │   │   │       ├── SMF_BananaTree_04.uasset
│   │   │   │       ├── SMF_Palm_A_01.uasset
│   │   │   │       ├── SMF_Palm_A_02.uasset
│   │   │   │       ├── SMF_Palm_A_03.uasset
│   │   │   │       ├── SMF_Palm_A_04.uasset
│   │   │   │       ├── SMF_Palm_B_01.uasset
│   │   │   │       ├── SMF_Palm_B_02.uasset
│   │   │   │       ├── SMF_Palm_B_03.uasset
│   │   │   │       ├── SMF_Palm_B_04.uasset
│   │   │   │       ├── SMF_Swamp_Tree_01.uasset
│   │   │   │       ├── SMF_Swamp_Tree_02.uasset
│   │   │   │       ├── SMF_Tree_Large_01.uasset
│   │   │   │       ├── SMF_Tree_Medium_01.uasset
│   │   │   │       ├── SMF_Tree_Medium_02.uasset
│   │   │   │       ├── SM_BananaTree_01.uasset
│   │   │   │       ├── SM_BananaTree_02.uasset
│   │   │   │       ├── SM_BananaTree_03.uasset
│   │   │   │       ├── SM_BananaTree_04.uasset
│   │   │   │       ├── SM_Palm_A_01.uasset
│   │   │   │       ├── SM_Palm_A_02.uasset
│   │   │   │       ├── SM_Palm_A_03.uasset
│   │   │   │       ├── SM_Palm_A_04.uasset
│   │   │   │       ├── SM_Palm_B_01.uasset
│   │   │   │       ├── SM_Palm_B_02.uasset
│   │   │   │       ├── SM_Palm_B_03.uasset
│   │   │   │       ├── SM_Palm_B_04.uasset
│   │   │   │       ├── SM_SwampTree_01.uasset
│   │   │   │       ├── SM_SwampTree_02.uasset
│   │   │   │       ├── SM_Tree_Large_01.uasset
│   │   │   │       ├── SM_Tree_Medium_01.uasset
│   │   │   │       ├── SM_Tree_Medium_02.uasset
│   │   │   │       └── Textures
│   │   │   │           ├── T_BananaLeaf_02_D.uasset
│   │   │   │           ├── T_BananaLeaf_02_N.uasset
│   │   │   │           ├── T_BananaLeaf_02_RAOH.uasset
│   │   │   │           ├── T_Banana_Bark_D.uasset
│   │   │   │           ├── T_Banana_Bark_N.uasset
│   │   │   │           ├── T_Banana_Bark_RHAO.uasset
│   │   │   │           ├── T_Banana_Blend_D.uasset
│   │   │   │           ├── T_Bark_01_D.uasset
│   │   │   │           ├── T_Bark_01_N.uasset
│   │   │   │           ├── T_Bark_01_RAOH.uasset
│   │   │   │           ├── T_Bark_02_D.uasset
│   │   │   │           ├── T_Bark_02_N.uasset
│   │   │   │           ├── T_Bark_02_RAOH.uasset
│   │   │   │           ├── T_Bark_03_D.uasset
│   │   │   │           ├── T_Bark_03_N.uasset
│   │   │   │           ├── T_Bark_03_RAOH.uasset
│   │   │   │           ├── T_Bark_04_D.uasset
│   │   │   │           ├── T_Bark_04_N.uasset
│   │   │   │           ├── T_Bark_04_RAOH.uasset
│   │   │   │           ├── T_Palm_A_Bark_D.uasset
│   │   │   │           ├── T_Palm_A_Bark_N.uasset
│   │   │   │           ├── T_Palm_A_Bark_RAOH.uasset
│   │   │   │           ├── T_Palm_A_Leaf_D.uasset
│   │   │   │           ├── T_Palm_A_Leaf_N.uasset
│   │   │   │           ├── T_Palm_B_Bark_D.uasset
│   │   │   │           ├── T_Palm_B_Bark_N.uasset
│   │   │   │           ├── T_Palm_B_Bark_RAOH.uasset
│   │   │   │           ├── T_Palm_B_Leaf_D.uasset
│   │   │   │           ├── T_Palm_B_Leaf_N.uasset
│   │   │   │           ├── T_Trunk_04_Moss_D.uasset
│   │   │   │           ├── T_Trunk_04_Moss_N.uasset
│   │   │   │           └── T_Trunk_04_Moss_RAOH.uasset
│   │   │   ├── Landscape
│   │   │   │   ├── MI_LND_01.uasset
│   │   │   │   ├── M_LND_Base.uasset
│   │   │   │   ├── MaterialFunctions
│   │   │   │   │   └── MF_ResetWPO.uasset
│   │   │   │   ├── MaterialLayers
│   │   │   │   │   ├── ML_Cliff.uasset
│   │   │   │   │   ├── ML_Grass.uasset
│   │   │   │   │   ├── ML_Gravel.uasset
│   │   │   │   │   ├── ML_Mud.uasset
│   │   │   │   │   ├── ML_RiverBed.uasset
│   │   │   │   │   ├── ML_Sand.uasset
│   │   │   │   │   └── ML_Sand_02.uasset
│   │   │   │   └── Textures
│   │   │   │       ├── RVT_BaseColor.uasset
│   │   │   │       ├── RVT_Height.uasset
│   │   │   │       ├── T_BeachSand_D.uasset
│   │   │   │       ├── T_BeachSand_N.uasset
│   │   │   │       ├── T_GenericGravel_D.uasset
│   │   │   │       ├── T_GenericGravel_N.uasset
│   │   │   │       ├── T_GenericGravel_RAOH.uasset
│   │   │   │       ├── T_LushGrass_D.uasset
│   │   │   │       ├── T_LushGrass_N.uasset
│   │   │   │       ├── T_LushGrass_RAOH.uasset
│   │   │   │       ├── T_RiverBed_D.uasset
│   │   │   │       ├── T_RiverBed_N.uasset
│   │   │   │       ├── T_RiverBed_RAOH.uasset
│   │   │   │       ├── T_SandBank_D.uasset
│   │   │   │       ├── T_SandBank_N.uasset
│   │   │   │       ├── T_SandBank_RAOH.uasset
│   │   │   │       ├── T_SwampMud_D.uasset
│   │   │   │       ├── T_SwampMud_N.uasset
│   │   │   │       ├── T_SwampMud_RAOH.uasset
│   │   │   │       ├── T_TropicalCliff_D.uasset
│   │   │   │       ├── T_TropicalCliff_ND.uasset
│   │   │   │       └── T_TropicalCliff_RAOH.uasset
│   │   │   ├── Maps
│   │   │   │   ├── DemoMap.umap
│   │   │   │   ├── DemoMap_sharedassets
│   │   │   │   │   ├── Cliff_LayerInfo.uasset
│   │   │   │   │   ├── GrassOnly_LayerInfo.uasset
│   │   │   │   │   ├── Grass_LayerInfo.uasset
│   │   │   │   │   ├── Gravel_LayerInfo.uasset
│   │   │   │   │   ├── Mud_LayerInfo.uasset
│   │   │   │   │   ├── RiverBed_LayerInfo.uasset
│   │   │   │   │   └── Sand_LayerInfo.uasset
│   │   │   │   └── Overview.umap
│   │   │   ├── Meshes
│   │   │   │   ├── Rocks
│   │   │   │   │   ├── Materials
│   │   │   │   │   │   ├── MI_LongRock_01.uasset
│   │   │   │   │   │   ├── MI_Rock_01_A.uasset
│   │   │   │   │   │   ├── MI_Rock_01_B.uasset
│   │   │   │   │   │   ├── MI_Rock_02_A.uasset
│   │   │   │   │   │   └── MI_Rock_03_A.uasset
│   │   │   │   │   ├── SM_LongRock.uasset
│   │   │   │   │   ├── SM_Rock_01.uasset
│   │   │   │   │   ├── SM_Rock_02.uasset
│   │   │   │   │   ├── SM_Rock_03.uasset
│   │   │   │   │   └── Textures
│   │   │   │   │       ├── T_LongRock_N.uasset
│   │   │   │   │       ├── T_RockSurface_D_01.uasset
│   │   │   │   │       ├── T_RockSurface_D_02.uasset
│   │   │   │   │       ├── T_RockSurface_N.uasset
│   │   │   │   │       ├── T_RockSurface_RAOH.uasset
│   │   │   │   │       ├── T_Rock_01_N.uasset
│   │   │   │   │       ├── T_Rock_02_N.uasset
│   │   │   │   │       ├── T_Rock_03_N.uasset
│   │   │   │   │       ├── T_StylizedMoss_D.uasset
│   │   │   │   │       ├── T_StylizedMoss_N.uasset
│   │   │   │   │       └── T_StylizedMoss_RAOH.uasset
│   │   │   │   └── Stones
│   │   │   │       ├── Materials
│   │   │   │       │   ├── MI_Stones_A.uasset
│   │   │   │       │   └── MI_Stones_B.uasset
│   │   │   │       ├── SM_StoneSet_A.uasset
│   │   │   │       ├── SM_StoneSet_B.uasset
│   │   │   │       ├── SM_Stone_A_01.uasset
│   │   │   │       ├── SM_Stone_A_02.uasset
│   │   │   │       ├── SM_Stone_B_01.uasset
│   │   │   │       ├── SM_Stone_B_02.uasset
│   │   │   │       └── Textures
│   │   │   │           ├── T_Stones_01_N.uasset
│   │   │   │           └── T_Stones_02_N.uasset
│   │   │   ├── StylizedWaterComponent
│   │   │   │   ├── Assets
│   │   │   │   │   └── Materials
│   │   │   │   │       ├── MF_ClampToNightSkyColor.uasset
│   │   │   │   │       └── MF_RemapValueRange_Vector3.uasset
│   │   │   │   ├── BP_SimpleWaterVolume.uasset
│   │   │   │   ├── MaterialFunctions
│   │   │   │   │   ├── MF_AmbientBlur.uasset
│   │   │   │   │   └── MF_WorldPositionBehindWater.uasset
│   │   │   │   ├── Materials
│   │   │   │   │   ├── MI_Water_01_WavesDisabled.uasset
│   │   │   │   │   ├── MI_Water_01_WavesEnabled.uasset
│   │   │   │   │   ├── M_D_Caustics.uasset
│   │   │   │   │   ├── M_PP_Underwater.uasset
│   │   │   │   │   ├── M_PP_UnderwaterAmbiance_Experimental.uasset
│   │   │   │   │   ├── M_WaterVolume_Preview.uasset
│   │   │   │   │   └── M_Water_Base.uasset
│   │   │   │   ├── Meshes
│   │   │   │   │   ├── SM_WaterSurface.uasset
│   │   │   │   │   ├── SM_WaterSurface_Circle_32.uasset
│   │   │   │   │   ├── SM_WaterVolume.uasset
│   │   │   │   │   └── SM_WaterVolume_Cylinder_32.uasset
│   │   │   │   └── Texture
│   │   │   │       ├── T_FX_BlurNoise.uasset
│   │   │   │       ├── T_FX_Caustic_01.uasset
│   │   │   │       ├── T_FX_Caustic_02.uasset
│   │   │   │       ├── T_FX_Waves.uasset
│   │   │   │       ├── T_WaterWaves_01_H.uasset
│   │   │   │       └── T_WaterWaves_01_N.uasset
│   │   │   └── _SharedAssets
│   │   │       ├── Materials
│   │   │       │   ├── MF_LeafGradient.uasset
│   │   │       │   ├── M_Grass_Base.uasset
│   │   │       │   ├── M_Leaves_Base.uasset
│   │   │       │   ├── M_Plants_Base.uasset
│   │   │       │   ├── M_Plants_Base_TangentSpace.uasset
│   │   │       │   ├── M_Rock_Base.uasset
│   │   │       │   └── M_Stylized_Sky.uasset
│   │   │       ├── T_Leaves_01.uasset
│   │   │       ├── T_Tree_Leaves_01.uasset
│   │   │       ├── T_Tree_Leaves_02.uasset
│   │   │       ├── T_Tree_Leaves_03.uasset
│   │   │       └── Textures
│   │   │           ├── T_Default_D.uasset
│   │   │           ├── T_Default_N.uasset
│   │   │           ├── T_Default_RAOH.uasset
│   │   │           ├── T_FX_Clouds.uasset
│   │   │           └── T_LUT_NaturalContrast.uasset
│   │   ├── LearningKit_Games
│   │   │   ├── Assets
│   │   │   │   ├── Architecture
│   │   │   │   │   ├── Floors
│   │   │   │   │   │   ├── Material
│   │   │   │   │   │   │   └── MI_Kit_Floor.uasset
│   │   │   │   │   │   ├── SM_Kit_Floor.uasset
│   │   │   │   │   │   └── Texture
│   │   │   │   │   │       ├── T_Kit_Floor_ARM.uasset
│   │   │   │   │   │       └── T_Kit_Floor_BC.uasset
│   │   │   │   │   ├── Gates
│   │   │   │   │   │   ├── Material
│   │   │   │   │   │   │   ├── MI_Forcefield.uasset
│   │   │   │   │   │   │   └── MI_Large_Gate.uasset
│   │   │   │   │   │   ├── SM_Large_Gate.uasset
│   │   │   │   │   │   ├── SM_Large_Gate_01.uasset
│   │   │   │   │   │   ├── SM_Large_Gate_Forcefield.uasset
│   │   │   │   │   │   ├── SM_Large_Gate_Frame.uasset
│   │   │   │   │   │   └── Texture
│   │   │   │   │   │       ├── T_Forcefield_ARM.uasset
│   │   │   │   │   │       ├── T_Forcefield_BC.uasset
│   │   │   │   │   │       ├── T_Forcefield_E.uasset
│   │   │   │   │   │       ├── T_Forcefield_O.uasset
│   │   │   │   │   │       ├── T_Forcefield_RGB.uasset
│   │   │   │   │   │       ├── T_Gate_ARM.uasset
│   │   │   │   │   │       └── T_Gate_BC.uasset
│   │   │   │   │   ├── KitCottage
│   │   │   │   │   │   ├── SM_KitCottage_Awning.uasset
│   │   │   │   │   │   ├── SM_KitCottage_Balcony.uasset
│   │   │   │   │   │   ├── SM_KitCottage_Pillar.uasset
│   │   │   │   │   │   ├── SM_KitCottage_PillarDmg.uasset
│   │   │   │   │   │   ├── SM_KitCottage_Roof.uasset
│   │   │   │   │   │   ├── SM_KitCottage_RoofTrim1Side.uasset
│   │   │   │   │   │   ├── SM_KitCottage_RoofTrim2Side.uasset
│   │   │   │   │   │   ├── SM_KitCottage_RoofTrim3Side.uasset
│   │   │   │   │   │   ├── SM_KitCottage_RoofTrim4Side.uasset
│   │   │   │   │   │   ├── SM_KitCottage_RoofTrimCorner.uasset
│   │   │   │   │   │   ├── SM_KitCottage_Wall.uasset
│   │   │   │   │   │   ├── SM_KitCottage_WallDiagonal.uasset
│   │   │   │   │   │   ├── SM_KitCottage_WallDoor.uasset
│   │   │   │   │   │   ├── SM_KitCottage_WallWindow.uasset
│   │   │   │   │   │   └── SM_KitCottage_WallWindowPlanter.uasset
│   │   │   │   │   ├── M_Kit_Wall_Door.uasset
│   │   │   │   │   ├── Platform
│   │   │   │   │   │   ├── Material
│   │   │   │   │   │   │   └── MI_Platform_M_A.uasset
│   │   │   │   │   │   ├── SM_Platform_M_A.uasset
│   │   │   │   │   │   └── Texture
│   │   │   │   │   │       ├── T_Platform_M_A_ARM.uasset
│   │   │   │   │   │       └── T_Platform_M_A_BC.uasset
│   │   │   │   │   ├── Ramps
│   │   │   │   │   │   ├── Material
│   │   │   │   │   │   │   └── MI_Ramp.uasset
│   │   │   │   │   │   ├── SM_Kit_Ramp.uasset
│   │   │   │   │   │   └── Texture
│   │   │   │   │   │       ├── T_Kit_Ramp_ARM.uasset
│   │   │   │   │   │       └── T_Kit_Ramp_BC.uasset
│   │   │   │   │   ├── Roofs
│   │   │   │   │   │   ├── Material
│   │   │   │   │   │   │   ├── MI_Kit_Roof_Corner_In.uasset
│   │   │   │   │   │   │   ├── MI_Kit_Roof_Corner_Out.uasset
│   │   │   │   │   │   │   └── MI_Kit_Roof_Straight.uasset
│   │   │   │   │   │   ├── SM_Kit_Roof_Corner_In.uasset
│   │   │   │   │   │   ├── SM_Kit_Roof_Corner_Out.uasset
│   │   │   │   │   │   ├── SM_Kit_Roof_Straight.uasset
│   │   │   │   │   │   └── Texture
│   │   │   │   │   │       ├── T_Kit_Roof_Corner_In_ARM.uasset
│   │   │   │   │   │       ├── T_Kit_Roof_Corner_In_BC.uasset
│   │   │   │   │   │       ├── T_Kit_Roof_Corner_Out_ARM.uasset
│   │   │   │   │   │       ├── T_Kit_Roof_Corner_Out_BC.uasset
│   │   │   │   │   │       ├── T_Kit_Roof_Straight_ARM.uasset
│   │   │   │   │   │       └── T_Kit_Roof_Straight_BC.uasset
│   │   │   │   │   ├── SM_Kit_Floor.uasset
│   │   │   │   │   ├── Stairs
│   │   │   │   │   │   ├── Material
│   │   │   │   │   │   │   ├── MI_Kit_Stairs_A.uasset
│   │   │   │   │   │   │   └── MI_Kit_Stairs_B.uasset
│   │   │   │   │   │   ├── SM_Kit_Stairs_A.uasset
│   │   │   │   │   │   ├── SM_Kit_Stairs_B.uasset
│   │   │   │   │   │   └── Texture
│   │   │   │   │   │       ├── T_Kit_Stairs_A_ARM.uasset
│   │   │   │   │   │       ├── T_Kit_Stairs_A_BC.uasset
│   │   │   │   │   │       ├── T_Kit_Stairs_B_ARM.uasset
│   │   │   │   │   │       └── T_Kit_Stairs_B_BC.uasset
│   │   │   │   │   └── Walls
│   │   │   │   │       ├── Material
│   │   │   │   │       │   ├── MI_Kit_Wall_Diagonal.uasset
│   │   │   │   │       │   ├── MI_Kit_Wall_Door.uasset
│   │   │   │   │       │   ├── MI_Kit_Wall_Straight.uasset
│   │   │   │   │       │   └── MI_Kit_Wall_Window.uasset
│   │   │   │   │       ├── SM_Kit_Wall_Diagonal.uasset
│   │   │   │   │       ├── SM_Kit_Wall_Door.uasset
│   │   │   │   │       ├── SM_Kit_Wall_Straight.uasset
│   │   │   │   │       ├── SM_Kit_Wall_Window.uasset
│   │   │   │   │       └── Texture
│   │   │   │   │           ├── T_Kit_Wall_Diagonal_ARM.uasset
│   │   │   │   │           ├── T_Kit_Wall_Diagonal_BC.uasset
│   │   │   │   │           ├── T_Kit_Wall_Door_ARM.uasset
│   │   │   │   │           ├── T_Kit_Wall_Door_BC.uasset
│   │   │   │   │           ├── T_Kit_Wall_Straight_ARM.uasset
│   │   │   │   │           ├── T_Kit_Wall_Straight_BC.uasset
│   │   │   │   │           ├── T_Kit_Wall_Window_ARM.uasset
│   │   │   │   │           └── T_Kit_Wall_Window_BC.uasset
│   │   │   │   ├── Characters
│   │   │   │   │   └── Character
│   │   │   │   │       ├── Animations
│   │   │   │   │       │   ├── EpicCharacter_AnimBP.uasset
│   │   │   │   │       │   ├── EpicCharacter_Celebrate.uasset
│   │   │   │   │       │   ├── EpicCharacter_CrouchIdle.uasset
│   │   │   │   │       │   ├── EpicCharacter_CrouchWalk.uasset
│   │   │   │   │       │   ├── EpicCharacter_CrouchWalk_2D.uasset
│   │   │   │   │       │   ├── EpicCharacter_Falling.uasset
│   │   │   │   │       │   ├── EpicCharacter_FlyRough.uasset
│   │   │   │   │       │   ├── EpicCharacter_FlySmooth.uasset
│   │   │   │   │       │   ├── EpicCharacter_Hover.uasset
│   │   │   │   │       │   ├── EpicCharacter_HoverFly_2D1.uasset
│   │   │   │   │       │   ├── EpicCharacter_Idle.uasset
│   │   │   │   │       │   ├── EpicCharacter_IdleRun_2D.uasset
│   │   │   │   │       │   ├── EpicCharacter_Interact.uasset
│   │   │   │   │       │   ├── EpicCharacter_InteractQuick.uasset
│   │   │   │   │       │   ├── EpicCharacter_Interact_End.uasset
│   │   │   │   │       │   ├── EpicCharacter_Interact_Loop.uasset
│   │   │   │   │       │   ├── EpicCharacter_Interact_Start.uasset
│   │   │   │   │       │   ├── EpicCharacter_JumpRun.uasset
│   │   │   │   │       │   ├── EpicCharacter_JumpRun_End.uasset
│   │   │   │   │       │   ├── EpicCharacter_JumpRun_Loop.uasset
│   │   │   │   │       │   ├── EpicCharacter_JumpRun_Start.uasset
│   │   │   │   │       │   ├── EpicCharacter_JumpUp.uasset
│   │   │   │   │       │   ├── EpicCharacter_JumpUp_End.uasset
│   │   │   │   │       │   ├── EpicCharacter_JumpUp_Loop.uasset
│   │   │   │   │       │   ├── EpicCharacter_JumpUp_Start.uasset
│   │   │   │   │       │   ├── EpicCharacter_Jump_Loop.uasset
│   │   │   │   │       │   ├── EpicCharacter_Run.uasset
│   │   │   │   │       │   ├── EpicCharacter_Walk.uasset
│   │   │   │   │       │   └── ThirdPerson_Retarget
│   │   │   │   │       │       ├── ThirdPersonIdle.uasset
│   │   │   │   │       │       ├── ThirdPersonJump_Loop.uasset
│   │   │   │   │       │       ├── ThirdPersonJump_Start.uasset
│   │   │   │   │       │       ├── ThirdPersonRun.uasset
│   │   │   │   │       │       ├── ThirdPersonWalk.uasset
│   │   │   │   │       │       ├── ThirdPerson_AnimBP.uasset
│   │   │   │   │       │       ├── ThirdPerson_IdleRun_2D.uasset
│   │   │   │   │       │       └── ThirdPerson_Jump.uasset
│   │   │   │   │       ├── Material
│   │   │   │   │       │   ├── MI_EpicCharacter_Optimized.uasset
│   │   │   │   │       │   ├── MI_RedTeam.uasset
│   │   │   │   │       │   ├── MI_epicCharacter_Backpack.uasset
│   │   │   │   │       │   ├── MI_epicCharacter_BedRoll.uasset
│   │   │   │   │       │   ├── MI_epicCharacter_Boots.uasset
│   │   │   │   │       │   ├── MI_epicCharacter_Head.uasset
│   │   │   │   │       │   ├── MI_epicCharacter_Hood.uasset
│   │   │   │   │       │   ├── MI_epicCharacter_Hood1.uasset
│   │   │   │   │       │   ├── MI_epicCharacter_Skin.uasset
│   │   │   │   │       │   ├── MI_epicCharacter_SleevesShorts.uasset
│   │   │   │   │       │   ├── MI_epicCharacter_Tunic.uasset
│   │   │   │   │       │   ├── M_EpicCharacter_Elim_Dissolve.uasset
│   │   │   │   │       │   └── M_EpicCharacter_Optimized.uasset
│   │   │   │   │       ├── Mesh
│   │   │   │   │       │   ├── SK_EpicCharacter.uasset
│   │   │   │   │       │   ├── SK_EpicCharacter_Optimized.uasset
│   │   │   │   │       │   ├── SK_EpicCharacter_Optimized_LODSettings.uasset
│   │   │   │   │       │   ├── SK_EpicCharacter_Physics.uasset
│   │   │   │   │       │   ├── SK_EpicCharacter_Skeleton.uasset
│   │   │   │   │       │   └── SM_MpicCharacter.uasset
│   │   │   │   │       ├── Rigs
│   │   │   │   │       │   └── IK_Blaster.uasset
│   │   │   │   │       └── Texture
│   │   │   │   │           ├── T_EpicCharacter_ARM.uasset
│   │   │   │   │           ├── T_EpicCharacter_BCE.uasset
│   │   │   │   │           ├── T_EpicCharacter_Backpack_ARM.uasset
│   │   │   │   │           ├── T_EpicCharacter_Backpack_BC.uasset
│   │   │   │   │           ├── T_EpicCharacter_Backpack_RGB.uasset
│   │   │   │   │           ├── T_EpicCharacter_Bedroll_ARM.uasset
│   │   │   │   │           ├── T_EpicCharacter_Bedroll_BC.uasset
│   │   │   │   │           ├── T_EpicCharacter_Bedroll_RGB.uasset
│   │   │   │   │           ├── T_EpicCharacter_Boots_ARM.uasset
│   │   │   │   │           ├── T_EpicCharacter_Boots_BC.uasset
│   │   │   │   │           ├── T_EpicCharacter_Boots_RGB.uasset
│   │   │   │   │           ├── T_EpicCharacter_Colors.uasset
│   │   │   │   │           ├── T_EpicCharacter_Colors_Red.uasset
│   │   │   │   │           ├── T_EpicCharacter_Head_ARM.uasset
│   │   │   │   │           ├── T_EpicCharacter_Head_BC.uasset
│   │   │   │   │           ├── T_EpicCharacter_Head_E.uasset
│   │   │   │   │           ├── T_EpicCharacter_Head_RGB.uasset
│   │   │   │   │           ├── T_EpicCharacter_Hood_ARM.uasset
│   │   │   │   │           ├── T_EpicCharacter_Hood_BC.uasset
│   │   │   │   │           ├── T_EpicCharacter_Hood_RGB.uasset
│   │   │   │   │           ├── T_EpicCharacter_Skin_ARM.uasset
│   │   │   │   │           ├── T_EpicCharacter_Skin_BC.uasset
│   │   │   │   │           ├── T_EpicCharacter_Skin_RGB.uasset
│   │   │   │   │           ├── T_EpicCharacter_SleevesShorts_ARM.uasset
│   │   │   │   │           ├── T_EpicCharacter_SleevesShorts_BC.uasset
│   │   │   │   │           ├── T_EpicCharacter_SleevesShorts_RGB.uasset
│   │   │   │   │           ├── T_EpicCharacter_Tunic_ARM.uasset
│   │   │   │   │           ├── T_EpicCharacter_Tunic_BC.uasset
│   │   │   │   │           ├── T_EpicCharacter_Tunic_E.uasset
│   │   │   │   │           └── T_EpicCharacter_Tunic_RGB.uasset
│   │   │   │   ├── Environment
│   │   │   │   │   ├── Clouds
│   │   │   │   │   │   ├── Material
│   │   │   │   │   │   │   ├── MI_Cloud_01.uasset
│   │   │   │   │   │   │   └── MI_Cloud_02.uasset
│   │   │   │   │   │   ├── SM_Cloud_A.uasset
│   │   │   │   │   │   ├── SM_Cloud_B.uasset
│   │   │   │   │   │   ├── SM_Cloud_C.uasset
│   │   │   │   │   │   ├── SM_Cloud_D.uasset
│   │   │   │   │   │   └── Texture
│   │   │   │   │   │       ├── T_Cloud_ARM.uasset
│   │   │   │   │   │       ├── T_Cloud_BC.uasset
│   │   │   │   │   │       ├── T_Cloud_E.uasset
│   │   │   │   │   │       ├── T_Cloud_N.uasset
│   │   │   │   │   │       └── T_Cloud_RGB.uasset
│   │   │   │   │   ├── Foliage
│   │   │   │   │   │   ├── FoliageTypes
│   │   │   │   │   │   │   ├── SM_CloverFlower_01_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_CloverFlower_02_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_CloverFlower_03_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Clover_01_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Clover_02_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Clover_03_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Flower_Daisy_01_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Flower_Daisy_02_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Flower_Daisy_03_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Grass_Dk_01_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Grass_Dk_02_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Grass_Dk_03_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Grass_Dk_04_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Grass_Dk_05_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Grass_Lt_01_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Grass_Lt_02_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Grass_Lt_03_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Grass_Lt_04_FoliageType.uasset
│   │   │   │   │   │   │   ├── SM_Grass_Lt_05_FoliageType.uasset
│   │   │   │   │   │   │   └── SM_TreeA_FoliageType.uasset
│   │   │   │   │   │   ├── SM_CloverFlower_01.uasset
│   │   │   │   │   │   ├── SM_CloverFlower_02.uasset
│   │   │   │   │   │   ├── SM_CloverFlower_03.uasset
│   │   │   │   │   │   ├── SM_Clover_01.uasset
│   │   │   │   │   │   ├── SM_Clover_02.uasset
│   │   │   │   │   │   ├── SM_Clover_03.uasset
│   │   │   │   │   │   ├── SM_Flower_Daisy_01.uasset
│   │   │   │   │   │   ├── SM_Flower_Daisy_02.uasset
│   │   │   │   │   │   ├── SM_Flower_Daisy_03.uasset
│   │   │   │   │   │   ├── SM_Grass_Dk_01.uasset
│   │   │   │   │   │   ├── SM_Grass_Dk_02.uasset
│   │   │   │   │   │   ├── SM_Grass_Dk_03.uasset
│   │   │   │   │   │   ├── SM_Grass_Dk_04.uasset
│   │   │   │   │   │   ├── SM_Grass_Dk_05.uasset
│   │   │   │   │   │   ├── SM_Grass_Lt_01.uasset
│   │   │   │   │   │   ├── SM_Grass_Lt_02.uasset
│   │   │   │   │   │   ├── SM_Grass_Lt_03.uasset
│   │   │   │   │   │   ├── SM_Grass_Lt_04.uasset
│   │   │   │   │   │   └── SM_Grass_Lt_05.uasset
│   │   │   │   │   ├── Islands
│   │   │   │   │   │   ├── Material
│   │   │   │   │   │   │   ├── MI_FloatingIsland_Bot.uasset
│   │   │   │   │   │   │   ├── MI_FloatingIsland_Bot_L.uasset
│   │   │   │   │   │   │   ├── MI_FloatingIsland_Bot_S.uasset
│   │   │   │   │   │   │   └── MI_FloatingIsland_Ground.uasset
│   │   │   │   │   │   ├── SM_FloatingIsland_L.uasset
│   │   │   │   │   │   ├── SM_FloatingIsland_L_Grass.uasset
│   │   │   │   │   │   ├── SM_FloatingIsland_L_Island.uasset
│   │   │   │   │   │   ├── SM_FloatingIsland_M.uasset
│   │   │   │   │   │   ├── SM_FloatingIsland_S.uasset
│   │   │   │   │   │   └── Texture
│   │   │   │   │   │       ├── T_FloatingIsland_Bot_L_ARM.uasset
│   │   │   │   │   │       ├── T_FloatingIsland_Bot_L_BC.uasset
│   │   │   │   │   │       ├── T_FloatingIsland_Bot_M_ARM.uasset
│   │   │   │   │   │       ├── T_FloatingIsland_Bot_M_BC.uasset
│   │   │   │   │   │       ├── T_FloatingIsland_Bot_S_ARM.uasset
│   │   │   │   │   │       ├── T_FloatingIsland_Bot_S_BC.uasset
│   │   │   │   │   │       ├── T_FloatingIsland_Grass_ARM.uasset
│   │   │   │   │   │       ├── T_FloatingIsland_Grass_BC.uasset
│   │   │   │   │   │       ├── T_FloatingIsland_Ground_ARM.uasset
│   │   │   │   │   │       └── T_FloatingIsland_Ground_BC.uasset
│   │   │   │   │   └── KitGround
│   │   │   │   │       ├── SM_KitGround_Cobblestone.uasset
│   │   │   │   │       ├── SM_KitGround_Cobblestone_Arch.uasset
│   │   │   │   │       ├── SM_KitGround_Cobblestone_Corner.uasset
│   │   │   │   │       ├── SM_KitGround_DirtMound.uasset
│   │   │   │   │       ├── SM_KitGround_DirtMoundSml.uasset
│   │   │   │   │       ├── SM_KitGround_GrassMound.uasset
│   │   │   │   │       ├── SM_KitGround_GrassMoundSml.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_Curb1Corner.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_Curb1Edge.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_Curb1EdgeA.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_Curb2CornerA.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_Curb2CornerB.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_Curb2Edge.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_Curb3Corner.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_Curb3Edge.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_Curb4Corner.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_Curb4Edge.uasset
│   │   │   │   │       ├── SM_KitGround_Sidewalk_CurbEdgeCorner.uasset
│   │   │   │   │       └── SM_KitGround_Street.uasset
│   │   │   │   ├── Props
│   │   │   │   │   ├── Buttons
│   │   │   │   │   │   └── Button_A
│   │   │   │   │   │       ├── Material
│   │   │   │   │   │       │   ├── MI_Button_A.uasset
│   │   │   │   │   │       │   ├── MI_Button_A_1.uasset
│   │   │   │   │   │       │   └── MI_Button_A_2.uasset
│   │   │   │   │   │       ├── SM_Button_A.uasset
│   │   │   │   │   │       ├── SM_Button_A_Push.uasset
│   │   │   │   │   │       ├── SM_Button_A_Ring.uasset
│   │   │   │   │   │       └── Texture
│   │   │   │   │   │           ├── T_Button_A_ARM.uasset
│   │   │   │   │   │           ├── T_Button_A_BC.uasset
│   │   │   │   │   │           ├── T_Button_A_E.uasset
│   │   │   │   │   │           └── T_Button_A_RGB.uasset
│   │   │   │   │   ├── Collectibles
│   │   │   │   │   │   └── Common
│   │   │   │   │   │       ├── Material
│   │   │   │   │   │       │   └── MI_Collictible_Common.uasset
│   │   │   │   │   │       ├── SM_Collectible_Common.uasset
│   │   │   │   │   │       └── Texture
│   │   │   │   │   │           ├── T_Collectible_Common_ARM.uasset
│   │   │   │   │   │           └── T_Collectible_Common_BC.uasset
│   │   │   │   │   ├── Levers
│   │   │   │   │   │   └── Lever_A
│   │   │   │   │   │       ├── Material
│   │   │   │   │   │       │   ├── MI_Lever_A.uasset
│   │   │   │   │   │       │   └── MI_Lever_A_EmissiveOn.uasset
│   │   │   │   │   │       ├── SM_Player_Lever_Base.uasset
│   │   │   │   │   │       ├── SM_Player_Lever_Handle.uasset
│   │   │   │   │   │       └── Texture
│   │   │   │   │   │           ├── T_Lever_A_E.uasset
│   │   │   │   │   │           ├── T_Player_Lever_A_ARM.uasset
│   │   │   │   │   │           └── T_Player_Lever_A_BC.uasset
│   │   │   │   │   ├── Powerups
│   │   │   │   │   │   └── Powerup_A
│   │   │   │   │   │       ├── Material
│   │   │   │   │   │       │   ├── MI_Powerup_A.uasset
│   │   │   │   │   │       │   ├── MI_Powerup_A_2.uasset
│   │   │   │   │   │       │   ├── MI_Powerup_A_3.uasset
│   │   │   │   │   │       │   └── MI_Powerup_A_4.uasset
│   │   │   │   │   │       ├── SM_Powerup_01_Shard01.uasset
│   │   │   │   │   │       ├── SM_Powerup_01_Shard02.uasset
│   │   │   │   │   │       ├── SM_Powerup_01_Shard03.uasset
│   │   │   │   │   │       ├── SM_Powerup_01_Shard04.uasset
│   │   │   │   │   │       ├── SM_Powerup_A.uasset
│   │   │   │   │   │       └── Texture
│   │   │   │   │   │           ├── T_Powerup_A_ARM.uasset
│   │   │   │   │   │           ├── T_Powerup_A_BC.uasset
│   │   │   │   │   │           ├── T_Powerup_A_E.uasset
│   │   │   │   │   │           └── T_Powerup_A_RGB.uasset
│   │   │   │   │   └── PuzzlePieces
│   │   │   │   │       ├── PuzzleCube_A
│   │   │   │   │       │   ├── Material
│   │   │   │   │       │   │   ├── MI_PuzzleCube_A.uasset
│   │   │   │   │       │   │   ├── MI_PuzzleCube_A_2.uasset
│   │   │   │   │       │   │   ├── MI_PuzzleCube_A_3.uasset
│   │   │   │   │       │   │   └── MI_PuzzleCube_A_4.uasset
│   │   │   │   │       │   ├── SM_PuzzleCube_A.uasset
│   │   │   │   │       │   └── Texture
│   │   │   │   │       │       ├── T_PuzzleCube_A_ARM.uasset
│   │   │   │   │       │       ├── T_PuzzleCube_A_BC.uasset
│   │   │   │   │       │       ├── T_PuzzleCube_A_E.uasset
│   │   │   │   │       │       └── T_PuzzleCube_A_RGB.uasset
│   │   │   │   │       └── PuzzleSphere_A
│   │   │   │   │           ├── Material
│   │   │   │   │           │   ├── MI_PuzzleSphere_A.uasset
│   │   │   │   │           │   ├── MI_PuzzleSphere_A_2.uasset
│   │   │   │   │           │   ├── MI_PuzzleSphere_A_3.uasset
│   │   │   │   │           │   └── MI_PuzzleSphere_A_4.uasset
│   │   │   │   │           ├── SM_PuzzleSphere_A.uasset
│   │   │   │   │           └── Texture
│   │   │   │   │               ├── T_PuzzleSphere_A_ARM.uasset
│   │   │   │   │               ├── T_PuzzleSphere_A_BC.uasset
│   │   │   │   │               ├── T_PuzzleSphere_A_E.uasset
│   │   │   │   │               └── T_PuzzleSphere_A_RGB.uasset
│   │   │   │   ├── SFX
│   │   │   │   │   ├── SFX_Chime_01A.uasset
│   │   │   │   │   ├── SFX_Chime_02A.uasset
│   │   │   │   │   ├── SFX_Chime_02B.uasset
│   │   │   │   │   ├── SFX_Chime_03A.uasset
│   │   │   │   │   ├── SFX_Chime_03B.uasset
│   │   │   │   │   ├── SFX_Chime_04A.uasset
│   │   │   │   │   ├── SFX_Chime_04B.uasset
│   │   │   │   │   ├── SFX_Chime_05A.uasset
│   │   │   │   │   ├── SFX_Chime_05B.uasset
│   │   │   │   │   ├── SFX_Chime_06A.uasset
│   │   │   │   │   ├── SFX_Chime_06B.uasset
│   │   │   │   │   ├── SFX_Chime_07A.uasset
│   │   │   │   │   ├── SFX_Chime_07B.uasset
│   │   │   │   │   ├── SFX_Wind_Long.uasset
│   │   │   │   │   └── SFX_Wind_Short.uasset
│   │   │   │   ├── VFX
│   │   │   │   │   ├── Clouds
│   │   │   │   │   │   ├── NE_Clouds.uasset
│   │   │   │   │   │   ├── VFX_MeshClouds_Base.uasset
│   │   │   │   │   │   └── VFX_MeshClouds_Sky.uasset
│   │   │   │   │   ├── Dependencies
│   │   │   │   │   │   ├── Materials
│   │   │   │   │   │   │   ├── MI_GroundAura.uasset
│   │   │   │   │   │   │   ├── MI_LeafLogo.uasset
│   │   │   │   │   │   │   ├── MI_Lines.uasset
│   │   │   │   │   │   │   ├── MI_LogoSweep.uasset
│   │   │   │   │   │   │   ├── MI_TopUnderlitAura.uasset
│   │   │   │   │   │   │   ├── MI_TwinklingStars.uasset
│   │   │   │   │   │   │   ├── MI_UnderlitAura.uasset
│   │   │   │   │   │   │   ├── MI_WindLead.uasset
│   │   │   │   │   │   │   ├── MI_WindRibbon.uasset
│   │   │   │   │   │   │   ├── MI_WindRibbonREV.uasset
│   │   │   │   │   │   │   ├── MI_WindTunnel.uasset
│   │   │   │   │   │   │   ├── MI_WindTunnelRibbons.uasset
│   │   │   │   │   │   │   ├── MI_WindTunnelWisps.uasset
│   │   │   │   │   │   │   ├── MI_WindTunnel_2.uasset
│   │   │   │   │   │   │   ├── MI_WindWipe.uasset
│   │   │   │   │   │   │   ├── M_LogoSweep.uasset
│   │   │   │   │   │   │   ├── M_ParticleMaskedFade.uasset
│   │   │   │   │   │   │   ├── M_TwinklingStars.uasset
│   │   │   │   │   │   │   ├── M_VFX_EmissiveMesh.uasset
│   │   │   │   │   │   │   ├── M_WindStreak.uasset
│   │   │   │   │   │   │   ├── M_WindTunnel.uasset
│   │   │   │   │   │   │   ├── M_WindTunnelRibbons.uasset
│   │   │   │   │   │   │   ├── M_WindTunnelWisps.uasset
│   │   │   │   │   │   │   └── M_WindWipe.uasset
│   │   │   │   │   │   ├── Meshes
│   │   │   │   │   │   │   ├── SM_LeafLogo.uasset
│   │   │   │   │   │   │   ├── SM_LogoSweepMesh.uasset
│   │   │   │   │   │   │   ├── SM_WindTunnel.uasset
│   │   │   │   │   │   │   └── WindPlane.uasset
│   │   │   │   │   │   └── Textures
│   │   │   │   │   │       ├── T_Celebrate.uasset
│   │   │   │   │   │       ├── T_Celebrate_upwardsAura.uasset
│   │   │   │   │   │       ├── T_LogoLines.uasset
│   │   │   │   │   │       ├── T_Noise.uasset
│   │   │   │   │   │       ├── T_NoiseA.uasset
│   │   │   │   │   │       ├── T_RadialMask.uasset
│   │   │   │   │   │       ├── T_SimplexNoise.uasset
│   │   │   │   │   │       ├── T_WindLead.uasset
│   │   │   │   │   │       ├── T_WindLeadSide.uasset
│   │   │   │   │   │       ├── T_WindRibbon.uasset
│   │   │   │   │   │       ├── T_WindRibbonRev.uasset
│   │   │   │   │   │       ├── T_WindTunnelMask.uasset
│   │   │   │   │   │       ├── T_WindTunnelRibbon.uasset
│   │   │   │   │   │       ├── T_WindWipe.uasset
│   │   │   │   │   │       ├── T_WindWisp.uasset
│   │   │   │   │   │       ├── T_simplexNoise_height.uasset
│   │   │   │   │   │       ├── T_simplexNoise_normal.uasset
│   │   │   │   │   │       └── T_topUpwardsAura.uasset
│   │   │   │   │   ├── Emitters
│   │   │   │   │   │   ├── Character
│   │   │   │   │   │   │   ├── NE_LogoLines_Mesh.uasset
│   │   │   │   │   │   │   ├── NS_Celebrate.uasset
│   │   │   │   │   │   │   ├── PEN_GroundAura1.uasset
│   │   │   │   │   │   │   ├── PEN_Lines.uasset
│   │   │   │   │   │   │   ├── PEN_TopUpwardsAura.uasset
│   │   │   │   │   │   │   ├── PEN_TwinkleAura.uasset
│   │   │   │   │   │   │   ├── PEN_Twinkles.uasset
│   │   │   │   │   │   │   └── PEN_UpwardsAura.uasset
│   │   │   │   │   │   └── Enviroment
│   │   │   │   │   │       ├── BP_WindSystem.uasset
│   │   │   │   │   │       ├── NE_WindCurve.uasset
│   │   │   │   │   │       ├── NE_WindStreams_Lead.uasset
│   │   │   │   │   │       ├── NE_WindStreams_Trails.uasset
│   │   │   │   │   │       ├── NE_WindTunnel.uasset
│   │   │   │   │   │       ├── NE_WindWipe.uasset
│   │   │   │   │   │       ├── NE_Wind_Lead.uasset
│   │   │   │   │   │       ├── NE_Wind_Trails.uasset
│   │   │   │   │   │       ├── NM_SplineFollow.uasset
│   │   │   │   │   │       ├── NS_Wind.uasset
│   │   │   │   │   │       ├── NS_WindCurveSystem.uasset
│   │   │   │   │   │       └── NS_WindTunnel.uasset
│   │   │   │   │   ├── LightRay
│   │   │   │   │   │   ├── MI_lightray_01_bright.uasset
│   │   │   │   │   │   ├── M_vfx_lightray_01_bright.uasset
│   │   │   │   │   │   ├── T_vfx_Fog_01.uasset
│   │   │   │   │   │   ├── T_vfx_Light_Ray_01.uasset
│   │   │   │   │   │   ├── T_vfx_lightray_card_01_O.uasset
│   │   │   │   │   │   └── vfx_lightray_card_01_P1_soft1_sea.uasset
│   │   │   │   │   └── Pollen
│   │   │   │   │       ├── MI_pollem_camerafade.uasset
│   │   │   │   │       ├── M_vfx_aura.uasset
│   │   │   │   │       ├── T_VFX_aura_noise.uasset
│   │   │   │   │       ├── VFX_Pollen.uasset
│   │   │   │   │       └── vfx_pollen_magic_camera_fade.uasset
│   │   │   │   └── _Shared
│   │   │   │       ├── Functions
│   │   │   │       │   ├── MF_ColorMask.uasset
│   │   │   │       │   ├── MF_GradientMap.uasset
│   │   │   │       │   ├── MF_MasterMaterialFunction.uasset
│   │   │   │       │   └── MF_MasterObjectGradient.uasset
│   │   │   │       ├── Gradients
│   │   │   │       │   ├── CA_Gradients.uasset
│   │   │   │       │   └── CL_Gradient_RedYellow.uasset
│   │   │   │       ├── Materials
│   │   │   │       │   ├── MI_Emissive_BaseInstance.uasset
│   │   │   │       │   ├── MI_Grass_BaseInstance.uasset
│   │   │   │       │   ├── MI_Opaque_BaseInstance.uasset
│   │   │   │       │   ├── M_Fresnel_MasterMaterial.uasset
│   │   │   │       │   ├── M_LearningKit_Foliage_Master.uasset
│   │   │   │       │   ├── M_LearningKit_MasterGradient.uasset
│   │   │   │       │   ├── M_LearningKit_MasterMaterial.uasset
│   │   │   │       │   ├── M_MASTER_OPAQUE.uasset
│   │   │   │       │   ├── M_RenderTarget.uasset
│   │   │   │       │   ├── M_TextRender_MASTER.uasset
│   │   │   │       │   ├── M_unsharpmask_POST.uasset
│   │   │   │       │   ├── Material_Master.uasset
│   │   │   │       │   ├── Physical_Materials
│   │   │   │       │   │   ├── PM_BeachBall.uasset
│   │   │   │       │   │   ├── PM_Center.uasset
│   │   │   │       │   │   ├── PM_Football.uasset
│   │   │   │       │   │   ├── PM_GuideBall.uasset
│   │   │   │       │   │   ├── PM_Metal.uasset
│   │   │   │       │   │   └── PM_Wheels.uasset
│   │   │   │       │   └── RT_Field.uasset
│   │   │   │       └── Textures
│   │   │   │           ├── T_Default_ARM.uasset
│   │   │   │           ├── T_Default_BC.uasset
│   │   │   │           ├── T_Default_E.uasset
│   │   │   │           ├── T_Default_E2.uasset
│   │   │   │           ├── T_Default_N.uasset
│   │   │   │           ├── T_Default_O.uasset
│   │   │   │           ├── T_Default_RGB.uasset
│   │   │   │           ├── T_Grass_Tile_ARM.uasset
│   │   │   │           └── T_Grass_Tile_D.uasset
│   │   │   ├── Blueprints
│   │   │   │   ├── BaseClasses
│   │   │   │   │   └── Master_Pickup_BP.uasset
│   │   │   │   ├── GameFramework
│   │   │   │   │   └── BP_LearningKitGameMode.uasset
│   │   │   │   ├── Interactables
│   │   │   │   │   ├── Lever_BP.uasset
│   │   │   │   │   └── PlayerButton_BP.uasset
│   │   │   │   ├── Pickups
│   │   │   │   │   ├── Collectable_Pickup_BP.uasset
│   │   │   │   │   └── PowerUp_Pickup_BP_Child.uasset
│   │   │   │   └── PlayerCharacter
│   │   │   │       ├── BPI_LearningKit_PlayerInteractions.uasset
│   │   │   │       └── BP_LearningKit_PlayerCharacter.uasset
│   │   │   ├── Maps
│   │   │   │   ├── LearningKit_Games_Showcase.umap
│   │   │   │   └── LearningKit_Robotics_Showcase.umap
│   │   │   └── MaterialLibrary
│   │   │       ├── Emissives
│   │   │       │   ├── MI_EmissiveA.uasset
│   │   │       │   ├── MI_EmissiveB.uasset
│   │   │       │   ├── MI_EmissiveC.uasset
│   │   │       │   ├── MI_EmissiveD.uasset
│   │   │       │   ├── MI_EmissiveE.uasset
│   │   │       │   ├── MI_EmissiveF.uasset
│   │   │       │   ├── MI_EmissiveG.uasset
│   │   │       │   ├── MI_EmissiveH.uasset
│   │   │       │   └── MI_EmissiveI.uasset
│   │   │       ├── Misc
│   │   │       │   ├── MI_Free.uasset
│   │   │       │   ├── MI_Grass_Landscape.uasset
│   │   │       │   ├── MI_Lessons_TextRende_Lightr.uasset
│   │   │       │   ├── MI_Lessons_TextRender.uasset
│   │   │       │   ├── MI_Lessons_TextRender_Dark.uasset
│   │   │       │   ├── M_SensorMulti_UI.uasset
│   │   │       │   ├── M_Spline_Center.uasset
│   │   │       │   └── M_Spline_Edges.uasset
│   │   │       ├── ObjBasedGradients
│   │   │       │   ├── MI_Grad_Cermaic.uasset
│   │   │       │   ├── MI_Grad_Clover.uasset
│   │   │       │   ├── MI_Grad_CloverFlowers.uasset
│   │   │       │   ├── MI_Grad_Cobblestone.uasset
│   │   │       │   ├── MI_Grad_Dirt.uasset
│   │   │       │   ├── MI_Grad_Grass.uasset
│   │   │       │   ├── MI_Grad_GrassB.uasset
│   │   │       │   ├── MI_Grad_GreenBlue.uasset
│   │   │       │   ├── MI_Grad_GreenBlueB.uasset
│   │   │       │   ├── MI_Grad_GreenYellow.uasset
│   │   │       │   ├── MI_Grad_RainbowA.uasset
│   │   │       │   ├── MI_Grad_RainbowB.uasset
│   │   │       │   ├── MI_Grad_RainbowC.uasset
│   │   │       │   ├── MI_Grad_RainbowD.uasset
│   │   │       │   ├── MI_Grad_TanPurple.uasset
│   │   │       │   ├── T_EnvTile_Ceramic_ARM.uasset
│   │   │       │   ├── T_EnvTile_Ceramic_BC.uasset
│   │   │       │   └── T_EnvTile_Ceramic_N.uasset
│   │   │       └── Tileable
│   │   │           ├── MI_Argyle.uasset
│   │   │           ├── MI_AsphaltA.uasset
│   │   │           ├── MI_Brick.uasset
│   │   │           ├── MI_CarbonFiber.uasset
│   │   │           ├── MI_Ceramic.uasset
│   │   │           ├── MI_Checkers.uasset
│   │   │           ├── MI_Cloud.uasset
│   │   │           ├── MI_ConcreteA.uasset
│   │   │           ├── MI_ConcreteB.uasset
│   │   │           ├── MI_DirtPebbles.uasset
│   │   │           ├── MI_Galaxy.uasset
│   │   │           ├── MI_Glass.uasset
│   │   │           ├── MI_Hearts.uasset
│   │   │           ├── MI_LadyBug.uasset
│   │   │           ├── MI_LadyBugB.uasset
│   │   │           ├── MI_Leaves.uasset
│   │   │           ├── MI_Leopard.uasset
│   │   │           ├── MI_Marble.uasset
│   │   │           ├── MI_MetalBrushed.uasset
│   │   │           ├── MI_MetalBrushed_Silver.uasset
│   │   │           ├── MI_MetalDiamondPlatingA.uasset
│   │   │           ├── MI_MetalDiamondPlatingB.uasset
│   │   │           ├── MI_MetalGalvanized.uasset
│   │   │           ├── MI_MetalPainted.uasset
│   │   │           ├── MI_MetalPanneling.uasset
│   │   │           ├── MI_MetalPolished.uasset
│   │   │           ├── MI_Metal_Anodized.uasset
│   │   │           ├── MI_Metal_Gold.uasset
│   │   │           ├── MI_Metal_Platinum.uasset
│   │   │           ├── MI_PlasticShiny.uasset
│   │   │           ├── MI_PlasticShinyB.uasset
│   │   │           ├── MI_PlasticShinyC.uasset
│   │   │           ├── MI_PlasticShinyD.uasset
│   │   │           ├── MI_PlasticShinyE.uasset
│   │   │           ├── MI_PlasticShinyF.uasset
│   │   │           ├── MI_PlasticShinyG.uasset
│   │   │           ├── MI_PlasticShinyH.uasset
│   │   │           ├── MI_Polkadots.uasset
│   │   │           ├── MI_Present.uasset
│   │   │           ├── MI_Present_Ribbons.uasset
│   │   │           ├── MI_Reflector.uasset
│   │   │           ├── MI_Rubber.uasset
│   │   │           ├── MI_ScalesFish.uasset
│   │   │           ├── MI_ScalesSnake.uasset
│   │   │           ├── MI_Stars.uasset
│   │   │           ├── MI_StoneA.uasset
│   │   │           ├── MI_StoneB.uasset
│   │   │           ├── MI_StoneC.uasset
│   │   │           ├── MI_StoneD.uasset
│   │   │           ├── MI_StuccoA.uasset
│   │   │           ├── MI_Tiger.uasset
│   │   │           ├── MI_WoodA.uasset
│   │   │           ├── T_EnvTile_Argyle_ARM.uasset
│   │   │           ├── T_EnvTile_Argyle_BC.uasset
│   │   │           ├── T_EnvTile_Argyle_N.uasset
│   │   │           ├── T_EnvTile_Argyle_RGB.uasset
│   │   │           ├── T_EnvTile_Asphalt_ARM.uasset
│   │   │           ├── T_EnvTile_Asphalt_BC.uasset
│   │   │           ├── T_EnvTile_Brick_ARM.uasset
│   │   │           ├── T_EnvTile_Brick_BC.uasset
│   │   │           ├── T_EnvTile_CarbonFiber_ARM.uasset
│   │   │           ├── T_EnvTile_CarbonFiber_BC.uasset
│   │   │           ├── T_EnvTile_CarbonFiber_N.uasset
│   │   │           ├── T_EnvTile_Ceramic_ARM.uasset
│   │   │           ├── T_EnvTile_Ceramic_BC.uasset
│   │   │           ├── T_EnvTile_Ceramic_N.uasset
│   │   │           ├── T_EnvTile_Checkers_ARM.uasset
│   │   │           ├── T_EnvTile_Checkers_BC.uasset
│   │   │           ├── T_EnvTile_Checkers_N.uasset
│   │   │           ├── T_EnvTile_Checkers_RGB.uasset
│   │   │           ├── T_EnvTile_Cloud_ARM.uasset
│   │   │           ├── T_EnvTile_Cloud_BC.uasset
│   │   │           ├── T_EnvTile_Cloud_N.uasset
│   │   │           ├── T_EnvTile_Cloud_RGB.uasset
│   │   │           ├── T_EnvTile_Concrete_ARM.uasset
│   │   │           ├── T_EnvTile_Concrete_BC.uasset
│   │   │           ├── T_EnvTile_Concrete_N.uasset
│   │   │           ├── T_EnvTile_Dirt_ARM.uasset
│   │   │           ├── T_EnvTile_Dirt_BC.uasset
│   │   │           ├── T_EnvTile_Dirt_N.uasset
│   │   │           ├── T_EnvTile_Dirt_RGB.uasset
│   │   │           ├── T_EnvTile_Galaxy_ARM.uasset
│   │   │           ├── T_EnvTile_Galaxy_BC.uasset
│   │   │           ├── T_EnvTile_Galaxy_RGB.uasset
│   │   │           ├── T_EnvTile_Grass_ARM.uasset
│   │   │           ├── T_EnvTile_Grass_BC.uasset
│   │   │           ├── T_EnvTile_Grass_RGB.uasset
│   │   │           ├── T_EnvTile_Hearts_ARM.uasset
│   │   │           ├── T_EnvTile_Hearts_BC.uasset
│   │   │           ├── T_EnvTile_Hearts_RGB.uasset
│   │   │           ├── T_EnvTile_LadyBugB_ARM.uasset
│   │   │           ├── T_EnvTile_LadyBugB_BC.uasset
│   │   │           ├── T_EnvTile_LadyBugB_RGB.uasset
│   │   │           ├── T_EnvTile_LadyBug_ARM.uasset
│   │   │           ├── T_EnvTile_LadyBug_BC.uasset
│   │   │           ├── T_EnvTile_LadyBug_RGB.uasset
│   │   │           ├── T_EnvTile_Leaves_ARM.uasset
│   │   │           ├── T_EnvTile_Leaves_BC.uasset
│   │   │           ├── T_EnvTile_Leaves_N.uasset
│   │   │           ├── T_EnvTile_Leaves_RGB.uasset
│   │   │           ├── T_EnvTile_Leopard_ARM.uasset
│   │   │           ├── T_EnvTile_Leopard_BC.uasset
│   │   │           ├── T_EnvTile_Leopard_RGB.uasset
│   │   │           ├── T_EnvTile_Marble_ARM.uasset
│   │   │           ├── T_EnvTile_Marble_BC.uasset
│   │   │           ├── T_EnvTile_Marble_RGB.uasset
│   │   │           ├── T_EnvTile_MetalBrushed_ARM.uasset
│   │   │           ├── T_EnvTile_MetalBrushed_BC.uasset
│   │   │           ├── T_EnvTile_MetalDiamondPlatingA_ARM.uasset
│   │   │           ├── T_EnvTile_MetalDiamondPlatingA_BC.uasset
│   │   │           ├── T_EnvTile_MetalDiamondPlatingA_N.uasset
│   │   │           ├── T_EnvTile_MetalDiamondPlatingB_ARM.uasset
│   │   │           ├── T_EnvTile_MetalDiamondPlatingB_BC.uasset
│   │   │           ├── T_EnvTile_MetalDiamondPlatingB_N.uasset
│   │   │           ├── T_EnvTile_MetalGalvanized_ARM.uasset
│   │   │           ├── T_EnvTile_MetalGalvanized_N.uasset
│   │   │           ├── T_EnvTile_MetalPainted_ARM.uasset
│   │   │           ├── T_EnvTile_MetalPainted_BC.uasset
│   │   │           ├── T_EnvTile_MetalPainted_N.uasset
│   │   │           ├── T_EnvTile_MetalPainted_RGB.uasset
│   │   │           ├── T_EnvTile_MetalPanneling_ARM.uasset
│   │   │           ├── T_EnvTile_MetalPanneling_BC.uasset
│   │   │           ├── T_EnvTile_MetalPanneling_N.uasset
│   │   │           ├── T_EnvTile_MetalPanneling_RGB.uasset
│   │   │           ├── T_EnvTile_MetalPolished_ARM.uasset
│   │   │           ├── T_EnvTile_MetalPolished_BC.uasset
│   │   │           ├── T_EnvTile_Polkadots_ARM.uasset
│   │   │           ├── T_EnvTile_Polkadots_BC.uasset
│   │   │           ├── T_EnvTile_Polkadots_N.uasset
│   │   │           ├── T_EnvTile_Polkadots_RGB.uasset
│   │   │           ├── T_EnvTile_Reflector_ARM.uasset
│   │   │           ├── T_EnvTile_Reflector_BC.uasset
│   │   │           ├── T_EnvTile_Reflector_E.uasset
│   │   │           ├── T_EnvTile_Reflector_RGB.uasset
│   │   │           ├── T_EnvTile_ScalesFish_ARM.uasset
│   │   │           ├── T_EnvTile_ScalesFish_BC.uasset
│   │   │           ├── T_EnvTile_ScalesFish_N.uasset
│   │   │           ├── T_EnvTile_ScalesSnake_ARM.uasset
│   │   │           ├── T_EnvTile_ScalesSnake_BC.uasset
│   │   │           ├── T_EnvTile_ScalesSnake_N.uasset
│   │   │           ├── T_EnvTile_Stars_ARM.uasset
│   │   │           ├── T_EnvTile_Stars_BC.uasset
│   │   │           ├── T_EnvTile_Stars_RGB.uasset
│   │   │           ├── T_EnvTile_Stone_ARM.uasset
│   │   │           ├── T_EnvTile_Stone_BC.uasset
│   │   │           ├── T_EnvTile_Stone_N.uasset
│   │   │           ├── T_EnvTile_Stucco_ARM.uasset
│   │   │           ├── T_EnvTile_Stucco_BC.uasset
│   │   │           ├── T_EnvTile_Stucco_N.uasset
│   │   │           ├── T_EnvTile_Stucco_RGB.uasset
│   │   │           ├── T_EnvTile_Tiger_ARM.uasset
│   │   │           ├── T_EnvTile_Tiger_BC.uasset
│   │   │           ├── T_EnvTile_Tiger_RGB.uasset
│   │   │           ├── T_EnvTile_Wood_ARM.uasset
│   │   │           ├── T_EnvTile_Wood_BC.uasset
│   │   │           └── T_EnvTile_Wood_N.uasset
│   │   ├── LearningKit_Robots
│   │   │   ├── Audio
│   │   │   │   ├── Approaching-object_V2.uasset
│   │   │   │   ├── Approaching-object_V2_Cue.uasset
│   │   │   │   ├── Bump_Metal_v3.uasset
│   │   │   │   ├── Bump_Metal_v3_Cue.uasset
│   │   │   │   └── General_Att.uasset
│   │   │   ├── Blueprints
│   │   │   │   ├── Robots
│   │   │   │   │   ├── L1_Robots
│   │   │   │   │   │   ├── BPC_Robot_DeadRec.uasset
│   │   │   │   │   │   ├── BPC_Robot_DeadRec_Challenge.uasset
│   │   │   │   │   │   ├── BPC_Robot_Simple.uasset
│   │   │   │   │   │   ├── BPC_Robot_Simple_SpinA.uasset
│   │   │   │   │   │   ├── BPC_Robot_Simple_SpinB.uasset
│   │   │   │   │   │   ├── BPC_Robot_Simple_TurnArc.uasset
│   │   │   │   │   │   ├── BPC_Robot_Simple_TurnOneWheel.uasset
│   │   │   │   │   │   ├── BPC_Robot_TopHeavy.uasset
│   │   │   │   │   │   ├── BPC_Robot_Unicycle.uasset
│   │   │   │   │   │   ├── BPC_Robot_WheelCollisionIssue.uasset
│   │   │   │   │   │   ├── BPC_Robot_WideWheels_Long.uasset
│   │   │   │   │   │   ├── BPC_Robot_WideWheels_SpinA.uasset
│   │   │   │   │   │   └── BPC_Robot_WideWheels_SpinB.uasset
│   │   │   │   │   ├── L2_Robots
│   │   │   │   │   │   ├── BPC_Robot_LineDetection.uasset
│   │   │   │   │   │   ├── BPC_Robot_LineDetection_FINAL.uasset
│   │   │   │   │   │   └── BPC_Robot_LineDetection_sensor.uasset
│   │   │   │   │   ├── L3_Robots
│   │   │   │   │   │   ├── BPC_Robot_FollowLine.uasset
│   │   │   │   │   │   ├── BPC_Robot_FollowLine_FINAL.uasset
│   │   │   │   │   │   ├── BPC_Robot_FollowLine_Sensors2_FINAL.uasset
│   │   │   │   │   │   └── BPC_Robot_FollowLine_sensor.uasset
│   │   │   │   │   ├── L4_Robots
│   │   │   │   │   │   ├── BPC_Robot_Distance.uasset
│   │   │   │   │   │   ├── BPC_Robot_DistanceFollowLine.uasset
│   │   │   │   │   │   ├── BPC_Robot_DistanceFollowLine_FINAL.uasset
│   │   │   │   │   │   ├── BPC_Robot_Distance_FINAL.uasset
│   │   │   │   │   │   └── BPC_Robot_Distance_Turn_FINAL.uasset
│   │   │   │   │   ├── L5_Robots
│   │   │   │   │   │   ├── BPC_Robot_Remote.uasset
│   │   │   │   │   │   ├── BPC_Robot_Remote_FINAL.uasset
│   │   │   │   │   │   └── BPC_Robot_Remote_FINAL_P2.uasset
│   │   │   │   │   └── Robot_MASTER
│   │   │   │   │       ├── BPML_Robot.uasset
│   │   │   │   │       ├── BP_Antenna.uasset
│   │   │   │   │       ├── BP_Motor.uasset
│   │   │   │   │       ├── BP_Robot_MASTER.uasset
│   │   │   │   │       ├── BP_Sensor_Distance.uasset
│   │   │   │   │       ├── BP_Sensor_Light.uasset
│   │   │   │   │       └── RobotFunctionLib.uasset
│   │   │   │   ├── Widgets
│   │   │   │   │   ├── W_DistanceSensorFeedback.uasset
│   │   │   │   │   ├── W_LightSensorFeedback.uasset
│   │   │   │   │   └── W_MultiSensorsFeedback.uasset
│   │   │   │   └── WorldBuilding
│   │   │   │       ├── BP_FloatIsland_a.uasset
│   │   │   │       ├── BP_FloatIsland_b.uasset
│   │   │   │       ├── BP_FloatIsland_c.uasset
│   │   │   │       └── BP_Spline_ANIM.uasset
│   │   │   ├── Materials
│   │   │   │   ├── Widget3DPassThrough_Facing.uasset
│   │   │   │   └── Widget3DPassThrough_Masked_OneSided_Facing.uasset
│   │   │   ├── StaticMeshes
│   │   │   │   ├── MergedActors
│   │   │   │   │   ├── MA_Building_1x1a.uasset
│   │   │   │   │   ├── MA_Building_1x1b.uasset
│   │   │   │   │   ├── MA_Building_2x2_Patio.uasset
│   │   │   │   │   ├── MA_Building_2x2a.uasset
│   │   │   │   │   ├── MA_Building_2x2x2.uasset
│   │   │   │   │   ├── MA_Building_2x2x4.uasset
│   │   │   │   │   ├── MA_Building_2x3a.uasset
│   │   │   │   │   ├── MA_Building_3x3_Patioa.uasset
│   │   │   │   │   ├── MA_Building_3x3_Patiob.uasset
│   │   │   │   │   ├── MA_Robot_A1.uasset
│   │   │   │   │   ├── MA_Robot_A2.uasset
│   │   │   │   │   ├── MA_Robot_B.uasset
│   │   │   │   │   ├── MA_StadiumBleachers.uasset
│   │   │   │   │   └── MA_StadiumCorners.uasset
│   │   │   │   ├── Robot
│   │   │   │   │   ├── SM_KitRobot_ConnectorA.uasset
│   │   │   │   │   ├── SM_KitRobot_ConnectorB.uasset
│   │   │   │   │   ├── SM_KitRobot_ConnectorC.uasset
│   │   │   │   │   ├── SM_KitRobot_Fin_01.uasset
│   │   │   │   │   ├── SM_KitRobot_GlideWheel.uasset
│   │   │   │   │   ├── SM_KitRobot_Handle.uasset
│   │   │   │   │   ├── SM_KitRobot_Hood.uasset
│   │   │   │   │   ├── SM_KitRobot_Horn.uasset
│   │   │   │   │   ├── SM_KitRobot_IRSensorA.uasset
│   │   │   │   │   ├── SM_KitRobot_MotorA.uasset
│   │   │   │   │   ├── SM_KitRobot_PaddleA.uasset
│   │   │   │   │   ├── SM_KitRobot_PowerBrickA.uasset
│   │   │   │   │   ├── SM_KitRobot_Rail.uasset
│   │   │   │   │   ├── SM_KitRobot_RibArm.uasset
│   │   │   │   │   ├── SM_KitRobot_Scoop.uasset
│   │   │   │   │   ├── SM_KitRobot_SensorA.uasset
│   │   │   │   │   ├── SM_KitRobot_SensorB.uasset
│   │   │   │   │   ├── SM_KitRobot_Spike.uasset
│   │   │   │   │   ├── SM_KitRobot_WheelA.uasset
│   │   │   │   │   └── SM_KitRobot_Wing.uasset
│   │   │   │   └── WorldDecor
│   │   │   │       ├── SM_BallBeachA.uasset
│   │   │   │       ├── SM_BallSoccerA.uasset
│   │   │   │       ├── SM_GoalA.uasset
│   │   │   │       ├── SM_PlanterBushA.uasset
│   │   │   │       ├── SM_TrafficBarrelA.uasset
│   │   │   │       ├── SM_TrafficBarrierA.uasset
│   │   │   │       ├── SM_TrafficConeA.uasset
│   │   │   │       ├── SM_TrafficConeB.uasset
│   │   │   │       └── SM_TreeA.uasset
│   │   │   └── Textures
│   │   │       ├── T_CL_Logo.uasset
│   │   │       └── T_Sensor_BG.uasset
│   │   ├── Materials
│   │   │   ├── CharacterMaterials
│   │   │   │   ├── MI_BlueTeam.uasset
│   │   │   │   ├── MI_BlueTeamDissolve.uasset
│   │   │   │   ├── MI_RedTeam.uasset
│   │   │   │   ├── MI_RedTeamDissolve.uasset
│   │   │   │   ├── M_EpicCharacter_Dissolve.uasset
│   │   │   │   └── Mi_EpicCharacter_Elim_Dissolve.uasset
│   │   │   ├── MI_DissolveEffect.uasset
│   │   │   ├── M_DissolveEffect.uasset
│   │   │   └── PP_Highlight.uasset
│   │   ├── MilitaryWeapSilver
│   │   │   ├── FX
│   │   │   │   ├── Materials
│   │   │   │   │   ├── M_AssaultRifle_MuzzleFlash_4x1.uasset
│   │   │   │   │   ├── M_Debris_Tileable_01.uasset
│   │   │   │   │   ├── M_Ember_01.uasset
│   │   │   │   │   ├── M_Ember_Speed_01.uasset
│   │   │   │   │   ├── M_Explosion_8x8_A_01.uasset
│   │   │   │   │   ├── M_GlowSphere_01.uasset
│   │   │   │   │   ├── M_Knife_RibbonTrail_01.uasset
│   │   │   │   │   ├── M_LightRay_01.uasset
│   │   │   │   │   ├── M_Pistol_MuzzleFlash_4x1_A.uasset
│   │   │   │   │   ├── M_Pistol_Smoke_2x2_A.uasset
│   │   │   │   │   ├── M_Pistol_Streaks_01.uasset
│   │   │   │   │   ├── M_RockMesh_01.uasset
│   │   │   │   │   ├── M_RockSmall_01.uasset
│   │   │   │   │   ├── M_RocketExplosion_8x8_A_01_Inst.uasset
│   │   │   │   │   ├── M_RocketLauncher_Trail_01_Inst.uasset
│   │   │   │   │   ├── M_RocketLauncher_Trail_02_Inst.uasset
│   │   │   │   │   ├── M_Shockwave_Refraction_01.uasset
│   │   │   │   │   ├── M_SmokeRibbon_01.uasset
│   │   │   │   │   ├── M_SmokeSimple_01.uasset
│   │   │   │   │   ├── M_Smoke_8x8_B_01.uasset
│   │   │   │   │   ├── M_Smoke_8x8_B_01_Inst.uasset
│   │   │   │   │   ├── M_SparksImpact_2x2_01.uasset
│   │   │   │   │   ├── M_Sparks_02.uasset
│   │   │   │   │   ├── M_Sparks_4x1_01.uasset
│   │   │   │   │   ├── M_Tracer_A.uasset
│   │   │   │   │   └── M_Woodchips_8x1_01.uasset
│   │   │   │   ├── Meshes
│   │   │   │   │   ├── St_Rock_01.uasset
│   │   │   │   │   ├── St_Sphere_01.uasset
│   │   │   │   │   └── St_Tracer_A.uasset
│   │   │   │   ├── P_AssaultRifle_MuzzleFlash.uasset
│   │   │   │   ├── P_AssaultRifle_Tracer_01.uasset
│   │   │   │   ├── P_Grenade_Explosion_01.uasset
│   │   │   │   ├── P_Grenade_MuzzleFlash_01.uasset
│   │   │   │   ├── P_Grenade_Trail_01.uasset
│   │   │   │   ├── P_Impact_Metal_Large_01.uasset
│   │   │   │   ├── P_Impact_Metal_Medium_01.uasset
│   │   │   │   ├── P_Impact_Metal_Small_01.uasset
│   │   │   │   ├── P_Impact_Stone_Large_01.uasset
│   │   │   │   ├── P_Impact_Stone_Medium_01.uasset
│   │   │   │   ├── P_Impact_Stone_Small_01.uasset
│   │   │   │   ├── P_Impact_Wood_Large_01.uasset
│   │   │   │   ├── P_Impact_Wood_Medium_01.uasset
│   │   │   │   ├── P_Impact_Wood_Small_01.uasset
│   │   │   │   ├── P_Knife_RibbonTrail_01.uasset
│   │   │   │   ├── P_Pistol_MuzzleFlash_01.uasset
│   │   │   │   ├── P_Pistol_Tracer_01.uasset
│   │   │   │   ├── P_RocketLauncher_Explosion_01.uasset
│   │   │   │   ├── P_RocketLauncher_MuzzleFlash_Front_01.uasset
│   │   │   │   ├── P_RocketLauncher_MuzzleFlash_Rear_01.uasset
│   │   │   │   ├── P_RocketLauncher_Trail_01.uasset
│   │   │   │   ├── P_Shotgun_MuzzleFlash_01.uasset
│   │   │   │   ├── P_Shotgun_Tracer_01.uasset
│   │   │   │   ├── P_SniperRifle_MuzzleFlash_01.uasset
│   │   │   │   ├── P_SniperRifle_Tracer_01.uasset
│   │   │   │   ├── Textures
│   │   │   │   │   ├── T_AssaultRifle_MuzzleFlashes_01.uasset
│   │   │   │   │   ├── T_Debris_Tileable_01.uasset
│   │   │   │   │   ├── T_Ember_01.uasset
│   │   │   │   │   ├── T_Explosion_8x8_A_01.uasset
│   │   │   │   │   ├── T_Explosion_8x8_A_02.uasset
│   │   │   │   │   ├── T_Explosion_8x8_Density_01.uasset
│   │   │   │   │   ├── T_Explosion_8x8_Erode_01.uasset
│   │   │   │   │   ├── T_Explosion_8x8_Temperature_01.uasset
│   │   │   │   │   ├── T_Explosion_Macro_01.uasset
│   │   │   │   │   ├── T_FL_Detail_01.uasset
│   │   │   │   │   ├── T_FrameClamp.uasset
│   │   │   │   │   ├── T_Grit_01.uasset
│   │   │   │   │   ├── T_Knife_RibbonTrail_01.uasset
│   │   │   │   │   ├── T_Knife_RibbonTrail_Refraction_01.uasset
│   │   │   │   │   ├── T_LightRay_01.uasset
│   │   │   │   │   ├── T_NormalNoise_01.uasset
│   │   │   │   │   ├── T_Pistol_MuzzleFlashes_4x1_A.uasset
│   │   │   │   │   ├── T_Pistol_MuzzleFlashes_4x1_B.uasset
│   │   │   │   │   ├── T_Pistol_Smoke_2x2_A.uasset
│   │   │   │   │   ├── T_Pistol_Streaks_01.uasset
│   │   │   │   │   ├── T_RockSmall_01.uasset
│   │   │   │   │   ├── T_Rock_Normal_01.uasset
│   │   │   │   │   ├── T_Shockwave_NormalMap_01.uasset
│   │   │   │   │   ├── T_SmokeRibbon_01.uasset
│   │   │   │   │   ├── T_SmokeSimple_01.uasset
│   │   │   │   │   ├── T_Smoke_8x8_B_01.uasset
│   │   │   │   │   ├── T_SparkImpacts_2x2_01.uasset
│   │   │   │   │   ├── T_Sparks_02.uasset
│   │   │   │   │   ├── T_Sparks_4x1_01.uasset
│   │   │   │   │   ├── T_Spherical_NormalMap_01.uasset
│   │   │   │   │   ├── T_WoodChips_8x1_01.uasset
│   │   │   │   │   └── T_WoodChips_8x1_Normal_01.uasset
│   │   │   │   └── Vector_Fields
│   │   │   │       └── VF_Turbulence_01.uasset
│   │   │   ├── Pickups
│   │   │   │   ├── AssaultRifle_Pickup.uasset
│   │   │   │   ├── GrenadeLauncher_Pickup.uasset
│   │   │   │   ├── Materials
│   │   │   │   │   └── M_Pickups_Inst.uasset
│   │   │   │   ├── Pistol_Pickup.uasset
│   │   │   │   ├── RocketLauncher_Pickup.uasset
│   │   │   │   ├── Shotgun_Pickup.uasset
│   │   │   │   ├── SniperRifle_Pickup.uasset
│   │   │   │   └── Textures
│   │   │   │       ├── Pickup_Diff.uasset
│   │   │   │       ├── Pickup_Masks.uasset
│   │   │   │       └── Pickup_Norm.uasset
│   │   │   ├── Showcase.umap
│   │   │   ├── Sound
│   │   │   │   ├── Attenuation
│   │   │   │   │   ├── Explosion_att.uasset
│   │   │   │   │   ├── ProjectileImpact_att.uasset
│   │   │   │   │   ├── RocketLoop_att.uasset
│   │   │   │   │   ├── WeaponHandling_att.uasset
│   │   │   │   │   ├── WeaponShotClose_Att.uasset
│   │   │   │   │   └── WeaponShot_att.uasset
│   │   │   │   ├── GrenadeLauncher
│   │   │   │   │   ├── Cues
│   │   │   │   │   │   ├── GrenadeLauncherA_Fire_Cue.uasset
│   │   │   │   │   │   ├── GrenadeLauncher_AmmoPickup_Cue.uasset
│   │   │   │   │   │   ├── GrenadeLauncher_Bounce_Cue.uasset
│   │   │   │   │   │   ├── GrenadeLauncher_Explosion_Cue.uasset
│   │   │   │   │   │   ├── GrenadeLauncher_Lower_Cue.uasset
│   │   │   │   │   │   ├── GrenadeLauncher_Raise_Cue.uasset
│   │   │   │   │   │   ├── GrenadeLauncher_Reload_Cue.uasset
│   │   │   │   │   │   └── GrenadeLauncher_Warning_Cue.uasset
│   │   │   │   │   └── Wavs
│   │   │   │   │       ├── GrenadeLauncherA_Fire01.uasset
│   │   │   │   │       ├── GrenadeLauncherA_Fire02.uasset
│   │   │   │   │       ├── GrenadeLauncherA_Fire03.uasset
│   │   │   │   │       ├── GrenadeLauncherA_Fire04.uasset
│   │   │   │   │       ├── GrenadeLauncherA_Fire_ST01.uasset
│   │   │   │   │       ├── GrenadeLauncherA_Fire_ST02.uasset
│   │   │   │   │       ├── GrenadeLauncherA_Fire_ST03.uasset
│   │   │   │   │       ├── GrenadeLauncherA_Fire_ST04.uasset
│   │   │   │   │       ├── GrenadeLauncher_AmmoPickup.uasset
│   │   │   │   │       ├── GrenadeLauncher_Bounce01.uasset
│   │   │   │   │       ├── GrenadeLauncher_Bounce02.uasset
│   │   │   │   │       ├── GrenadeLauncher_Bounce03.uasset
│   │   │   │   │       ├── GrenadeLauncher_Bounce04.uasset
│   │   │   │   │       ├── GrenadeLauncher_Bounce05.uasset
│   │   │   │   │       ├── GrenadeLauncher_Explosion01.uasset
│   │   │   │   │       ├── GrenadeLauncher_Explosion02.uasset
│   │   │   │   │       ├── GrenadeLauncher_Explosion03.uasset
│   │   │   │   │       ├── GrenadeLauncher_Explosion04.uasset
│   │   │   │   │       ├── GrenadeLauncher_Explosion05.uasset
│   │   │   │   │       ├── GrenadeLauncher_Lower.uasset
│   │   │   │   │       ├── GrenadeLauncher_Raise.uasset
│   │   │   │   │       ├── GrenadeLauncher_Reload01.uasset
│   │   │   │   │       ├── GrenadeLauncher_Reload02.uasset
│   │   │   │   │       ├── GrenadeLauncher_Reload03.uasset
│   │   │   │   │       └── GrenadeLauncher_Warning.uasset
│   │   │   │   ├── Knife
│   │   │   │   │   ├── Cues
│   │   │   │   │   │   ├── KnifeA_Swing_Cue.uasset
│   │   │   │   │   │   ├── Knife_ImpactBody_Cue.uasset
│   │   │   │   │   │   ├── Knife_ImpactSurface_Cue.uasset
│   │   │   │   │   │   ├── Knife_Lower_Cue.uasset
│   │   │   │   │   │   └── Knife_Raise_Cue.uasset
│   │   │   │   │   └── Wavs
│   │   │   │   │       ├── KnifeA_Swing01.uasset
│   │   │   │   │       ├── KnifeA_Swing02.uasset
│   │   │   │   │       ├── KnifeA_Swing03.uasset
│   │   │   │   │       ├── KnifeA_Swing04.uasset
│   │   │   │   │       ├── KnifeA_Swing05.uasset
│   │   │   │   │       ├── Knife_ImpactBody01.uasset
│   │   │   │   │       ├── Knife_ImpactBody02.uasset
│   │   │   │   │       ├── Knife_ImpactBody03.uasset
│   │   │   │   │       ├── Knife_ImpactSurface01.uasset
│   │   │   │   │       ├── Knife_ImpactSurface02.uasset
│   │   │   │   │       ├── Knife_ImpactSurface03.uasset
│   │   │   │   │       ├── Knife_Lower.uasset
│   │   │   │   │       └── Knife_Raise.uasset
│   │   │   │   ├── Pistol
│   │   │   │   │   ├── Cues
│   │   │   │   │   │   ├── PistolA_Fire_Cue.uasset
│   │   │   │   │   │   ├── Pistol_AmmoPickup_Cue.uasset
│   │   │   │   │   │   ├── Pistol_Lower_Cue.uasset
│   │   │   │   │   │   ├── Pistol_Raise_Cue.uasset
│   │   │   │   │   │   ├── Pistol_ReloadEject_Cue.uasset
│   │   │   │   │   │   ├── Pistol_ReloadInsert_Cue.uasset
│   │   │   │   │   │   └── Pistol_Whip_Cue.uasset
│   │   │   │   │   └── Wavs
│   │   │   │   │       ├── PistolA_Fire01.uasset
│   │   │   │   │       ├── PistolA_Fire02.uasset
│   │   │   │   │       ├── PistolA_Fire03.uasset
│   │   │   │   │       ├── PistolA_Fire04.uasset
│   │   │   │   │       ├── PistolA_Fire05.uasset
│   │   │   │   │       ├── PistolA_Fire06.uasset
│   │   │   │   │       ├── PistolA_Fire_ST01.uasset
│   │   │   │   │       ├── PistolA_Fire_ST02.uasset
│   │   │   │   │       ├── PistolA_Fire_ST03.uasset
│   │   │   │   │       ├── PistolA_Fire_ST04.uasset
│   │   │   │   │       ├── PistolA_Fire_ST05.uasset
│   │   │   │   │       ├── PistolA_Fire_ST06.uasset
│   │   │   │   │       ├── Pistol_AmmoPickup.uasset
│   │   │   │   │       ├── Pistol_Lower.uasset
│   │   │   │   │       ├── Pistol_Raise.uasset
│   │   │   │   │       ├── Pistol_Reload01.uasset
│   │   │   │   │       ├── Pistol_Reload02.uasset
│   │   │   │   │       ├── Pistol_Reload03.uasset
│   │   │   │   │       ├── Pistol_ReloadMagEject01.uasset
│   │   │   │   │       ├── Pistol_ReloadMagEject02.uasset
│   │   │   │   │       ├── Pistol_ReloadMagInsert01.uasset
│   │   │   │   │       ├── Pistol_ReloadMagInsert02.uasset
│   │   │   │   │       ├── Pistol_ReloadSlideRack01.uasset
│   │   │   │   │       ├── Pistol_ReloadSlideRack02.uasset
│   │   │   │   │       ├── Pistol_ReloadSlideRack03.uasset
│   │   │   │   │       ├── Pistol_Whip01.uasset
│   │   │   │   │       ├── Pistol_Whip02.uasset
│   │   │   │   │       ├── Pistol_Whip03.uasset
│   │   │   │   │       ├── Pistol_Whip04.uasset
│   │   │   │   │       └── Pistol_Whip05.uasset
│   │   │   │   ├── Rifle
│   │   │   │   │   ├── Cues
│   │   │   │   │   │   ├── RifleA_FireEnd_Cue.uasset
│   │   │   │   │   │   ├── RifleA_FireLoop_Cue.uasset
│   │   │   │   │   │   ├── RifleA_Fire_Cue.uasset
│   │   │   │   │   │   ├── Rifle_AmmoPickup_Cue.uasset
│   │   │   │   │   │   ├── Rifle_ImpactBody_Cue.uasset
│   │   │   │   │   │   ├── Rifle_ImpactSurface_Cue.uasset
│   │   │   │   │   │   ├── Rifle_Lower_Cue.uasset
│   │   │   │   │   │   ├── Rifle_Raise_Cue.uasset
│   │   │   │   │   │   ├── Rifle_ReloadInsert_Cue.uasset
│   │   │   │   │   │   ├── Rifle_Reload_Cue.uasset
│   │   │   │   │   │   └── Rifle_Whip_Cue.uasset
│   │   │   │   │   └── Wavs
│   │   │   │   │       ├── RifleA_Fire01.uasset
│   │   │   │   │       ├── RifleA_Fire02.uasset
│   │   │   │   │       ├── RifleA_Fire03.uasset
│   │   │   │   │       ├── RifleA_Fire04.uasset
│   │   │   │   │       ├── RifleA_Fire05.uasset
│   │   │   │   │       ├── RifleA_Fire06.uasset
│   │   │   │   │       ├── RifleA_FireEnd01.uasset
│   │   │   │   │       ├── RifleA_FireEnd02.uasset
│   │   │   │   │       ├── RifleA_FireEnd03.uasset
│   │   │   │   │       ├── RifleA_FireLoop01.uasset
│   │   │   │   │       ├── RifleA_FireLoop02.uasset
│   │   │   │   │       ├── RifleA_FireLoop03.uasset
│   │   │   │   │       ├── RifleA_Fire_End_ST01.uasset
│   │   │   │   │       ├── RifleA_Fire_End_ST02.uasset
│   │   │   │   │       ├── RifleA_Fire_End_ST03.uasset
│   │   │   │   │       ├── RifleA_Fire_Loop_ST01.uasset
│   │   │   │   │       ├── RifleA_Fire_Loop_ST02.uasset
│   │   │   │   │       ├── RifleA_Fire_Loop_ST03.uasset
│   │   │   │   │       ├── RifleA_Fire_ST01.uasset
│   │   │   │   │       ├── RifleA_Fire_ST02.uasset
│   │   │   │   │       ├── RifleA_Fire_ST03.uasset
│   │   │   │   │       ├── RifleA_Fire_ST04.uasset
│   │   │   │   │       ├── RifleA_Fire_ST05.uasset
│   │   │   │   │       ├── RifleA_Fire_ST06.uasset
│   │   │   │   │       ├── Rifle_AmmoPickup.uasset
│   │   │   │   │       ├── Rifle_ImpactBody01.uasset
│   │   │   │   │       ├── Rifle_ImpactBody02.uasset
│   │   │   │   │       ├── Rifle_ImpactBody03.uasset
│   │   │   │   │       ├── Rifle_ImpactBody04.uasset
│   │   │   │   │       ├── Rifle_ImpactBody05.uasset
│   │   │   │   │       ├── Rifle_ImpactBody06.uasset
│   │   │   │   │       ├── Rifle_ImpactSurface01.uasset
│   │   │   │   │       ├── Rifle_ImpactSurface02.uasset
│   │   │   │   │       ├── Rifle_ImpactSurface03.uasset
│   │   │   │   │       ├── Rifle_ImpactSurface04.uasset
│   │   │   │   │       ├── Rifle_ImpactSurface05.uasset
│   │   │   │   │       ├── Rifle_ImpactSurface06.uasset
│   │   │   │   │       ├── Rifle_Lower.uasset
│   │   │   │   │       ├── Rifle_Raise.uasset
│   │   │   │   │       ├── Rifle_Reload01.uasset
│   │   │   │   │       ├── Rifle_Reload02.uasset
│   │   │   │   │       ├── Rifle_Reload03.uasset
│   │   │   │   │       ├── Rifle_Whip01.uasset
│   │   │   │   │       ├── Rifle_Whip02.uasset
│   │   │   │   │       ├── Rifle_Whip03.uasset
│   │   │   │   │       ├── Rifle_Whip04.uasset
│   │   │   │   │       └── Rifle_Whip05.uasset
│   │   │   │   ├── RocketLauncher
│   │   │   │   │   ├── Cues
│   │   │   │   │   │   ├── RocketLauncherA_Fire_Cue.uasset
│   │   │   │   │   │   ├── RocketLauncher_AmmoPickup_Cue.uasset
│   │   │   │   │   │   ├── RocketLauncher_Explosion_Cue.uasset
│   │   │   │   │   │   ├── RocketLauncher_InAirLoop_Cue.uasset
│   │   │   │   │   │   ├── RocketLauncher_Lower_Cue.uasset
│   │   │   │   │   │   ├── RocketLauncher_Raise_Cue.uasset
│   │   │   │   │   │   ├── RocketLauncher_ReloadDetach_Cue.uasset
│   │   │   │   │   │   └── RocketLauncher_Reload_Cue.uasset
│   │   │   │   │   └── Wavs
│   │   │   │   │       ├── RocketLauncherA_Fire01.uasset
│   │   │   │   │       ├── RocketLauncherA_Fire02.uasset
│   │   │   │   │       ├── RocketLauncherA_Fire03.uasset
│   │   │   │   │       ├── RocketLauncherA_Fire04.uasset
│   │   │   │   │       ├── RocketLauncherA_Fire_ST01.uasset
│   │   │   │   │       ├── RocketLauncherA_Fire_ST02.uasset
│   │   │   │   │       ├── RocketLauncherA_Fire_ST03.uasset
│   │   │   │   │       ├── RocketLauncherA_Fire_ST04.uasset
│   │   │   │   │       ├── RocketLauncher_AmmoPickup.uasset
│   │   │   │   │       ├── RocketLauncher_Explosion01.uasset
│   │   │   │   │       ├── RocketLauncher_Explosion02.uasset
│   │   │   │   │       ├── RocketLauncher_Explosion03.uasset
│   │   │   │   │       ├── RocketLauncher_Explosion04.uasset
│   │   │   │   │       ├── RocketLauncher_Explosion05.uasset
│   │   │   │   │       ├── RocketLauncher_InAirLoop.uasset
│   │   │   │   │       ├── RocketLauncher_Lower.uasset
│   │   │   │   │       ├── RocketLauncher_Raise.uasset
│   │   │   │   │       ├── RocketLauncher_Reload01.uasset
│   │   │   │   │       ├── RocketLauncher_Reload02.uasset
│   │   │   │   │       └── RocketLauncher_Reload03.uasset
│   │   │   │   ├── Shotgun
│   │   │   │   │   ├── Cues
│   │   │   │   │   │   ├── ShotgunA_Fire_Cue.uasset
│   │   │   │   │   │   ├── Shotgun_AmmoPickup_Cue.uasset
│   │   │   │   │   │   ├── Shotgun_ImpactBody_Cue.uasset
│   │   │   │   │   │   ├── Shotgun_ImpactSurface_Cue.uasset
│   │   │   │   │   │   ├── Shotgun_Lower_Cue.uasset
│   │   │   │   │   │   ├── Shotgun_Raise_Cue.uasset
│   │   │   │   │   │   ├── Shotgun_Reload_Cue.uasset
│   │   │   │   │   │   ├── Shotgun_Reload_In_Cue.uasset
│   │   │   │   │   │   └── Shotgun_Reload_Out_Cue.uasset
│   │   │   │   │   └── Wavs
│   │   │   │   │       ├── ShotgunA_Fire01.uasset
│   │   │   │   │       ├── ShotgunA_Fire02.uasset
│   │   │   │   │       ├── ShotgunA_Fire03.uasset
│   │   │   │   │       ├── ShotgunA_Fire04.uasset
│   │   │   │   │       ├── ShotgunA_Fire_ST01.uasset
│   │   │   │   │       ├── ShotgunA_Fire_ST02.uasset
│   │   │   │   │       ├── ShotgunA_Fire_ST03.uasset
│   │   │   │   │       ├── ShotgunA_Fire_ST04.uasset
│   │   │   │   │       ├── Shotgun_AmmoPickup.uasset
│   │   │   │   │       ├── Shotgun_ImpactBody01.uasset
│   │   │   │   │       ├── Shotgun_ImpactBody02.uasset
│   │   │   │   │       ├── Shotgun_ImpactBody03.uasset
│   │   │   │   │       ├── Shotgun_ImpactBody04.uasset
│   │   │   │   │       ├── Shotgun_ImpactSurface01.uasset
│   │   │   │   │       ├── Shotgun_ImpactSurface02.uasset
│   │   │   │   │       ├── Shotgun_ImpactSurface03.uasset
│   │   │   │   │       ├── Shotgun_ImpactSurface04.uasset
│   │   │   │   │       ├── Shotgun_Lower.uasset
│   │   │   │   │       ├── Shotgun_Raise.uasset
│   │   │   │   │       ├── Shotgun_Reload01.uasset
│   │   │   │   │       ├── Shotgun_Reload02.uasset
│   │   │   │   │       ├── Shotgun_Reload03.uasset
│   │   │   │   │       ├── Shotgun_Reload_In01.uasset
│   │   │   │   │       ├── Shotgun_Reload_In02.uasset
│   │   │   │   │       ├── Shotgun_Reload_In03.uasset
│   │   │   │   │       ├── Shotgun_Reload_Out01.uasset
│   │   │   │   │       ├── Shotgun_Reload_Out02.uasset
│   │   │   │   │       └── Shotgun_Reload_Out03.uasset
│   │   │   │   └── SniperRifle
│   │   │   │       ├── Cues
│   │   │   │       │   ├── SniperRifleA_Fire_Cue.uasset
│   │   │   │       │   ├── SniperRifle_AmmoPickup_Cue.uasset
│   │   │   │       │   ├── SniperRifle_ImpactBody_Cue.uasset
│   │   │   │       │   ├── SniperRifle_ImpactSurface_Cue.uasset
│   │   │   │       │   ├── SniperRifle_Lower_Cue.uasset
│   │   │   │       │   ├── SniperRifle_Raise_Cue.uasset
│   │   │   │       │   ├── SniperRifle_ReloadInsert_Cue.uasset
│   │   │   │       │   ├── SniperRifle_Reload_Cue.uasset
│   │   │   │       │   ├── SniperRifle_ZoomIn_Cue.uasset
│   │   │   │       │   └── SniperRifle_ZoomOut_Cue.uasset
│   │   │   │       └── Wavs
│   │   │   │           ├── SniperRifleA_Fire01.uasset
│   │   │   │           ├── SniperRifleA_Fire02.uasset
│   │   │   │           ├── SniperRifleA_Fire03.uasset
│   │   │   │           ├── SniperRifleA_Fire04.uasset
│   │   │   │           ├── SniperRifleA_Fire_ST01.uasset
│   │   │   │           ├── SniperRifleA_Fire_ST02.uasset
│   │   │   │           ├── SniperRifleA_Fire_ST03.uasset
│   │   │   │           ├── SniperRifleA_Fire_ST04.uasset
│   │   │   │           ├── SniperRifle_AmmoPickup.uasset
│   │   │   │           ├── SniperRifle_ImpactBody01.uasset
│   │   │   │           ├── SniperRifle_ImpactBody02.uasset
│   │   │   │           ├── SniperRifle_ImpactBody03.uasset
│   │   │   │           ├── SniperRifle_ImpactBody04.uasset
│   │   │   │           ├── SniperRifle_ImpactSurface01.uasset
│   │   │   │           ├── SniperRifle_ImpactSurface02.uasset
│   │   │   │           ├── SniperRifle_ImpactSurface03.uasset
│   │   │   │           ├── SniperRifle_ImpactSurface04.uasset
│   │   │   │           ├── SniperRifle_Lower.uasset
│   │   │   │           ├── SniperRifle_Raise.uasset
│   │   │   │           ├── SniperRifle_Reload01.uasset
│   │   │   │           ├── SniperRifle_Reload02.uasset
│   │   │   │           ├── SniperRifle_Reload03.uasset
│   │   │   │           ├── SniperRifle_ReloadInsert01.uasset
│   │   │   │           ├── SniperRifle_ReloadInsert02.uasset
│   │   │   │           ├── SniperRifle_ReloadInsert03.uasset
│   │   │   │           ├── SniperRifle_ZoomIn.uasset
│   │   │   │           └── SniperRifle_ZoomOut.uasset
│   │   │   └── Weapons
│   │   │       ├── Animations
│   │   │       │   ├── Assault_Rifle_A_Skeleton.uasset
│   │   │       │   ├── Fire_GrenadeLauncher_W.uasset
│   │   │       │   ├── Fire_Pistol_W.uasset
│   │   │       │   ├── Fire_Rifle_W.uasset
│   │   │       │   ├── Fire_RocketLauncher_W.uasset
│   │   │       │   ├── Fire_Shotgun_W.uasset
│   │   │       │   ├── Fire_Shotgun_W1.uasset
│   │   │       │   ├── Fire_SniperRifle_W.uasset
│   │   │       │   ├── Grenade_Launcher_A_Skeleton.uasset
│   │   │       │   ├── Knife_A_Skeleton.uasset
│   │   │       │   ├── Pistols_A_Skeleton.uasset
│   │   │       │   ├── Prone_Reload_Rifle_W.uasset
│   │   │       │   ├── Prone_Reload_Shotgun_W.uasset
│   │   │       │   ├── Prone_Reload_SniperRifle_W.uasset
│   │   │       │   ├── Reload_GrenadeLauncher_W.uasset
│   │   │       │   ├── Reload_Pistol_W.uasset
│   │   │       │   ├── Reload_Rifle_Hip_W.uasset
│   │   │       │   ├── Reload_Rifle_Ironsights_W.uasset
│   │   │       │   ├── Reload_RocketLauncher_W.uasset
│   │   │       │   ├── Reload_Shotgun_Hip_W.uasset
│   │   │       │   ├── Reload_Shotgun_Ironsights_W.uasset
│   │   │       │   ├── Reload_SniperRifle_Hip_W.uasset
│   │   │       │   ├── Reload_SniperRifle_Ironsights_W.uasset
│   │   │       │   ├── Rocket_Launcher_A_Skeleton.uasset
│   │   │       │   ├── ShotgunFire_W.uasset
│   │   │       │   ├── Shotgun_A_Skeleton.uasset
│   │   │       │   └── Sniper_Rifle_A_Skeleton.uasset
│   │   │       ├── AssaultRifleA_Ammo.uasset
│   │   │       ├── Assault_Rifle_A.uasset
│   │   │       ├── Assault_Rifle_A_PhysicsAsset.uasset
│   │   │       ├── Assault_Rifle_A_Skeleton.uasset
│   │   │       ├── GrenadeLauncherA_Ammo.uasset
│   │   │       ├── Grenade_Launcher_A.uasset
│   │   │       ├── Grenade_Launcher_A_PhysicsAsset.uasset
│   │   │       ├── Grenade_Launcher_A_Skeleton.uasset
│   │   │       ├── Knife_A.uasset
│   │   │       ├── Knife_A_PhysicsAsset.uasset
│   │   │       ├── Knife_A_Skeleton.uasset
│   │   │       ├── Materials
│   │   │       │   ├── M_Ammo.uasset
│   │   │       │   ├── M_AssaultRifle_01.uasset
│   │   │       │   ├── M_GrenadeLauncher_01.uasset
│   │   │       │   ├── M_Knife_01.uasset
│   │   │       │   ├── M_PistolAmmo.uasset
│   │   │       │   ├── M_Pistol_01.uasset
│   │   │       │   ├── M_RocketLauncher_01.uasset
│   │   │       │   ├── M_Shotgun_01.uasset
│   │   │       │   ├── M_SniperRifle_01.uasset
│   │   │       │   └── M_WeaponMaster_01.uasset
│   │   │       ├── PistolA_Ammo.uasset
│   │   │       ├── Pistols_A.uasset
│   │   │       ├── Pistols_A_PhysicsAsset.uasset
│   │   │       ├── Pistols_A_Skeleton.uasset
│   │   │       ├── RocketLauncherA_Ammo.uasset
│   │   │       ├── Rocket_Launcher_A.uasset
│   │   │       ├── Rocket_Launcher_A_PhysicsAsset.uasset
│   │   │       ├── Rocket_Launcher_A_Skeleton.uasset
│   │   │       ├── ShotgunA_Ammo.uasset
│   │   │       ├── Shotgun_A.uasset
│   │   │       ├── Shotgun_A_PhysicsAsset.uasset
│   │   │       ├── Shotgun_A_Skeleton.uasset
│   │   │       ├── SniperRifleA_Ammo.uasset
│   │   │       ├── Sniper_Rifle_A.uasset
│   │   │       ├── Sniper_Rifle_A_PhysicsAsset.uasset
│   │   │       ├── Sniper_Rifle_A_Skeleton.uasset
│   │   │       └── Textures
│   │   │           ├── Assault_Rifle_A_Diff.uasset
│   │   │           ├── Assault_Rifle_A_Norm.uasset
│   │   │           ├── Assault_Rifle_A_masks.uasset
│   │   │           ├── Grenade_Launcher_A_Diff.uasset
│   │   │           ├── Grenade_Launcher_A_Masks.uasset
│   │   │           ├── Grenade_Launcher_A_Norm.uasset
│   │   │           ├── Knife_A_Diff.uasset
│   │   │           ├── Knife_A_Masks.uasset
│   │   │           ├── Knife_A_Norm.uasset
│   │   │           ├── Pistols_A_Diff.uasset
│   │   │           ├── Pistols_A_Masks.uasset
│   │   │           ├── Pistols_A_Norm.uasset
│   │   │           ├── Rocket_launcher_A_Diff.uasset
│   │   │           ├── Rocket_launcher_A_Masks.uasset
│   │   │           ├── Rocket_launcher_A_Norm.uasset
│   │   │           ├── Shotgun_A_Diff.uasset
│   │   │           ├── Shotgun_A_Masks.uasset
│   │   │           ├── Shotgun_A_Norm.uasset
│   │   │           ├── Sniper_Rifle_A_Diff.uasset
│   │   │           ├── Sniper_Rifle_A_Masks.uasset
│   │   │           └── Sniper_Rifle_A_Norm.uasset
│   │   ├── Mixamo
│   │   │   ├── Animations
│   │   │   │   ├── CrouchTurnLeft.uasset
│   │   │   │   ├── CrouchTurnRight.uasset
│   │   │   │   ├── Jump_Down.uasset
│   │   │   │   ├── Jump_Loop.uasset
│   │   │   │   ├── Jump_Up.uasset
│   │   │   │   ├── Reloading.uasset
│   │   │   │   ├── Toss_Grenade.uasset
│   │   │   │   ├── TurnLeft.uasset
│   │   │   │   ├── TurnRight.uasset
│   │   │   │   └── Zombie_Attack.uasset
│   │   │   ├── Materials
│   │   │   │   ├── M_DarkPink.uasset
│   │   │   │   └── M_LightPink.uasset
│   │   │   ├── Rigs
│   │   │   │   ├── IK_xbot.uasset
│   │   │   │   └── RTG_xbot.uasset
│   │   │   ├── SKM_xbot.uasset
│   │   │   ├── SK_xbot.uasset
│   │   │   └── X_Bot_PhysicsAsset.uasset
│   │   ├── ParagonDekker
│   │   │   └── FX
│   │   │       ├── Materials
│   │   │       │   ├── Flares
│   │   │       │   │   ├── M_Lensflare_TB_Soft.uasset
│   │   │       │   │   ├── M_Lensflare_TB_SoftGlow.uasset
│   │   │       │   │   └── M_Lensflare_TB_SoftGlow_LowDepth_Inst.uasset
│   │   │       │   ├── Functions
│   │   │       │   │   ├── FX_EmissiveModulate.uasset
│   │   │       │   │   ├── FadeBasedOnViewAngle.uasset
│   │   │       │   │   ├── HitFlash.uasset
│   │   │       │   │   ├── MF_BaseColorTintAndContrast.uasset
│   │   │       │   │   ├── MF_BrightnessAdjust.uasset
│   │   │       │   │   ├── MF_CharacterEffects.uasset
│   │   │       │   │   ├── MF_DeathFade.uasset
│   │   │       │   │   ├── MF_OrionCharacterAO.uasset
│   │   │       │   │   ├── MF_RoughnessAdjustment.uasset
│   │   │       │   │   ├── MLC_ScratchAndGrime.uasset
│   │   │       │   │   ├── MLC_Standard.uasset
│   │   │       │   │   └── ML__Blank.uasset
│   │   │       │   ├── Hero_Specific
│   │   │       │   │   ├── MF_OrionRimlight.uasset
│   │   │       │   │   ├── ML_Chrome.uasset
│   │   │       │   │   ├── ML_Dirty_Gun_Metal_1.uasset
│   │   │       │   │   ├── ML_GlossyBlack_Latex.uasset
│   │   │       │   │   ├── ML_PurplePattern.uasset
│   │   │       │   │   ├── ML_White_shinyPaint.uasset
│   │   │       │   │   ├── ML_blue_Metal.uasset
│   │   │       │   │   └── M_Dekker_Weapon_Bot.uasset
│   │   │       │   ├── Param_Collections
│   │   │       │   │   └── GlobalGameplayCollection.uasset
│   │   │       │   ├── Tech
│   │   │       │   │   └── M_Spline_Light_Scanner.uasset
│   │   │       │   └── Trails
│   │   │       │       └── M_Bullet_Trail.uasset
│   │   │       ├── Meshes
│   │   │       │   ├── Bots
│   │   │       │   │   └── SM_Dekker_BotFriend.uasset
│   │   │       │   └── Shapes
│   │   │       │       └── SM_Holo_Projector_Beams.uasset
│   │   │       ├── Particles
│   │   │       │   └── Abilities
│   │   │       │       └── Cage
│   │   │       │           └── FX
│   │   │       │               └── P_Bot_Cage.uasset
│   │   │       └── Textures
│   │   │           ├── Flares
│   │   │           │   └── T_Flare_Spikeball.uasset
│   │   │           ├── Gradients
│   │   │           │   └── Color
│   │   │           │       └── T_Muriel_Prism_03.uasset
│   │   │           ├── Hero_Specific
│   │   │           │   ├── T_Blank_N.uasset
│   │   │           │   ├── T_Blue_Metal02.uasset
│   │   │           │   ├── T_Dekker_UV2_RGB.uasset
│   │   │           │   ├── T_Dekker_Weapon_M.uasset
│   │   │           │   ├── T_Dekker_Weapon_M2.uasset
│   │   │           │   ├── T_Dekker_Weapon_N.uasset
│   │   │           │   ├── T_Dekker_Weapon_RGB.uasset
│   │   │           │   ├── T_ML_PaintedConstructionMetal_N.uasset
│   │   │           │   ├── T_ML_PlasticPattern01.uasset
│   │   │           │   ├── T_ML_PlasticPattern01_N.uasset
│   │   │           │   ├── T_ML_Rubber_Blue_01_D.uasset
│   │   │           │   ├── T_ML_Rubber_Blue_01_N.uasset
│   │   │           │   ├── T_Rough_Plastic_D.uasset
│   │   │           │   ├── T_Rough_Plastic_N.uasset
│   │   │           │   └── T_metal02.uasset
│   │   │           ├── Masks
│   │   │           │   ├── T_Beam_Gradient_02.uasset
│   │   │           │   ├── T_SmokeTrailCoord1_Mask.uasset
│   │   │           │   └── T_Square_SoftEdges.uasset
│   │   │           └── Tile
│   │   │               ├── Noise
│   │   │               │   ├── T_AtmosphericCloudNoise01.uasset
│   │   │               │   ├── T_AtmosphericCloudNoise01_N.uasset
│   │   │               │   └── T_AtmosphericCloudNoise03.uasset
│   │   │               └── T_TestML_Mask.uasset
│   │   ├── ParagonWraith
│   │   │   └── FX
│   │   │       ├── Materials
│   │   │       │   ├── Functions
│   │   │       │   │   ├── FX_EmissiveModulate.uasset
│   │   │       │   │   └── MF_DitheredRefraction.uasset
│   │   │       │   ├── Heroes
│   │   │       │   │   └── Wraith
│   │   │       │   │       ├── FX
│   │   │       │   │       │   ├── M_Wraith_Drone_ElectroField.uasset
│   │   │       │   │       │   └── M_Wraith_Upperbody_Drone_Inst.uasset
│   │   │       │   │       ├── MLayer
│   │   │       │   │       │   ├── MF_Wraithlatex.uasset
│   │   │       │   │       │   └── T_TireRubber_R.uasset
│   │   │       │   │       └── M_Wraith_Upperbody.uasset
│   │   │       │   ├── MaterialFunctions
│   │   │       │   │   ├── HitFlash.uasset
│   │   │       │   │   ├── MF_BrightnessAdjust.uasset
│   │   │       │   │   ├── MF_CharacterEffects.uasset
│   │   │       │   │   ├── MF_Character_MaterialLayerQuality.uasset
│   │   │       │   │   ├── MF_DeathFade.uasset
│   │   │       │   │   ├── MF_OrionCharacterAO.uasset
│   │   │       │   │   ├── MF_OrionRimlight.uasset
│   │   │       │   │   ├── M_Tri_Test.uasset
│   │   │       │   │   ├── MaterialLayerConstructors
│   │   │       │   │   │   ├── MF_BaseColorTintAndContrast.uasset
│   │   │       │   │   │   ├── MF_RoughnessAdjustment.uasset
│   │   │       │   │   │   ├── MLC_ScratchAndGrime.uasset
│   │   │       │   │   │   └── MLC_Standard.uasset
│   │   │       │   │   ├── ParameterCollections
│   │   │       │   │   │   └── OrionGlobalGameplayCollection.uasset
│   │   │       │   │   └── Textures
│   │   │       │   │       ├── Noise
│   │   │       │   │       │   ├── T_AtmosphericCloudNoise01.uasset
│   │   │       │   │       │   ├── T_AtmosphericCloudNoise01_N.uasset
│   │   │       │   │       │   └── T_AtmosphericCloudNoise03.uasset
│   │   │       │   │       └── T_Black_Linear.uasset
│   │   │       │   ├── MaterialLayers
│   │   │       │   │   ├── ML__Blank.uasset
│   │   │       │   │   ├── Metal
│   │   │       │   │   │   ├── ML_Metal_Scratched_Circular.uasset
│   │   │       │   │   │   ├── ML_SoftMetal01.uasset
│   │   │       │   │   │   ├── ML_blue_Metal.uasset
│   │   │       │   │   │   ├── T_Blue_Metal02.uasset
│   │   │       │   │   │   ├── T_ML_Aluminum01.uasset
│   │   │       │   │   │   ├── T_ML_Aluminum01_N.uasset
│   │   │       │   │   │   ├── T_Metal_Scratched_Circular_01_COLOR.uasset
│   │   │       │   │   │   ├── T_Metal_Scratched_Circular_01_N.uasset
│   │   │       │   │   │   └── T_ScratchMask.uasset
│   │   │       │   │   ├── Painted
│   │   │       │   │   │   ├── ML_MetallicClearCoat.uasset
│   │   │       │   │   │   └── T_PaintScratches.uasset
│   │   │       │   │   ├── Rubber
│   │   │       │   │   │   ├── T_Blank_N.uasset
│   │   │       │   │   │   └── T_ML_FineRubber_N.uasset
│   │   │       │   │   ├── Synthetics
│   │   │       │   │   │   └── ML_SimpleEmissive_underGlass.uasset
│   │   │       │   │   └── T_TestML_Mask.uasset
│   │   │       │   └── Trails
│   │   │       │       └── M_Bullet_Trail.uasset
│   │   │       ├── Meshes
│   │   │       │   └── Heroes
│   │   │       │       └── Wraith
│   │   │       │           ├── FX
│   │   │       │           │   └── SM_Wraith_Drone_ElectroField.uasset
│   │   │       │           ├── SM_Wraith_Drone.uasset
│   │   │       │           └── SM_Wraith_Drone_open.uasset
│   │   │       ├── Particles
│   │   │       │   └── Abilities
│   │   │       │       └── Drone
│   │   │       │           └── FX
│   │   │       │               └── P_Wraith_Drone_Attached_TeamColored.uasset
│   │   │       └── Textures
│   │   │           ├── FluidPatterns
│   │   │           │   └── T_FluidTile01_DA.uasset
│   │   │           ├── Heroes
│   │   │           │   └── Wraith
│   │   │           │       ├── T_ElectroHex_Tile.uasset
│   │   │           │       ├── T_Wraith_BackPackbody_RGBA.uasset
│   │   │           │       ├── T_Wraith_UpperBody_Mask.uasset
│   │   │           │       ├── T_Wraith_UpperBody_Mask2.uasset
│   │   │           │       ├── T_Wraith_Upperbody_RGBA.uasset
│   │   │           │       └── T_Wraith_upperbody_N_DEMO.uasset
│   │   │           ├── Masks
│   │   │           │   ├── T_Beam_Gradient_02.uasset
│   │   │           │   └── T_SmokeTrailCoord1_Mask.uasset
│   │   │           └── Tile
│   │   │               └── Noise
│   │   │                   └── T_Noise_Rough_Dark_Big.uasset
│   │   ├── Reloading_Retargeted.uasset
│   │   ├── RoboBars
│   │   │   ├── Demo
│   │   │   │   ├── Blueprints
│   │   │   │   │   ├── BP_FirstPersonCharacter.uasset
│   │   │   │   │   ├── BP_FirstPersonGameMode.uasset
│   │   │   │   │   └── BP_Hud.uasset
│   │   │   │   └── Maps
│   │   │   │       ├── RoboBarsDemoMap.umap
│   │   │   │       └── RoboBarsDemoMap_BuiltData.uasset
│   │   │   ├── DemoRoom
│   │   │   │   ├── BluePrint
│   │   │   │   │   ├── BPInterface_Button.uasset
│   │   │   │   │   ├── BP_DemoDisplay.uasset
│   │   │   │   │   ├── BP_DemoDisplay_Enum.uasset
│   │   │   │   │   ├── BP_DemoRoom.uasset
│   │   │   │   │   ├── BP_DemoRoom_Enum.uasset
│   │   │   │   │   ├── BP_DemoTrigger.uasset
│   │   │   │   │   ├── DemoRoomStruct.uasset
│   │   │   │   │   └── RoomDescription.uasset
│   │   │   │   ├── Materials
│   │   │   │   │   ├── DefaultTextMaterialTranslucentUnlit.uasset
│   │   │   │   │   ├── M_Button.uasset
│   │   │   │   │   ├── M_Button_Chrome.uasset
│   │   │   │   │   ├── M_Button_Inst.uasset
│   │   │   │   │   ├── M_DemoAnimated.uasset
│   │   │   │   │   ├── M_DemoAnimated_Inst.uasset
│   │   │   │   │   ├── M_DemoAnimated_Vertex.uasset
│   │   │   │   │   ├── M_DemoLightFunktion.uasset
│   │   │   │   │   ├── M_DemoLightFunktion_Inst.uasset
│   │   │   │   │   ├── M_DemoMinRoughnesS_Inst.uasset
│   │   │   │   │   ├── M_DemoRoomTiles.uasset
│   │   │   │   │   ├── M_DemoRoomTiles_Inst.uasset
│   │   │   │   │   ├── M_DemoRoomTiles_Inst_Color1.uasset
│   │   │   │   │   ├── M_DemoRoomTiles_Inst_Color2.uasset
│   │   │   │   │   ├── M_DemoRoomTiles_Inst_Color3.uasset
│   │   │   │   │   ├── M_DemoRoomTiles_Inst_Color5_Inst.uasset
│   │   │   │   │   ├── M_DemoWall.uasset
│   │   │   │   │   ├── M_DemoWallPattern.uasset
│   │   │   │   │   ├── M_DemoWallPattern_Inst.uasset
│   │   │   │   │   ├── M_DemoWallPattern_Inst_Mirrored.uasset
│   │   │   │   │   ├── M_DemoWallPattern_NoText.uasset
│   │   │   │   │   ├── M_DemoWall_Inst.uasset
│   │   │   │   │   ├── M_DemoWall_Inst2.uasset
│   │   │   │   │   ├── M_DemoWall_Inst_3.uasset
│   │   │   │   │   ├── M_DemoWall_Inst_BaseFloor_Inst.uasset
│   │   │   │   │   ├── M_DemoWall_Inst_NamePlate.uasset
│   │   │   │   │   ├── M_DemoWall_MattPlastic.uasset
│   │   │   │   │   ├── M_Emissive.uasset
│   │   │   │   │   ├── M_Emissive_1.uasset
│   │   │   │   │   ├── M_Emissive_2.uasset
│   │   │   │   │   ├── M_GlasDoor.uasset
│   │   │   │   │   ├── M_GlasDoor_Inst.uasset
│   │   │   │   │   ├── M_Glass.uasset
│   │   │   │   │   ├── M_Glass_Inst.uasset
│   │   │   │   │   ├── M_Gradient.uasset
│   │   │   │   │   ├── M_Gradient_Blue.uasset
│   │   │   │   │   ├── M_Gradient_EmissiveOverbright.uasset
│   │   │   │   │   ├── M_Gradient_Green.uasset
│   │   │   │   │   ├── M_Gradient_Red.uasset
│   │   │   │   │   ├── M_LightSculpture.uasset
│   │   │   │   │   ├── M_LightSculpture_Blue.uasset
│   │   │   │   │   ├── M_LightSculpture_Green.uasset
│   │   │   │   │   ├── M_LightSculpture_Red.uasset
│   │   │   │   │   ├── M_LightTube.uasset
│   │   │   │   │   ├── M_LightTube_Inst.uasset
│   │   │   │   │   ├── M_ReflectionDemo_1.uasset
│   │   │   │   │   ├── M_ReflectionDemo_2.uasset
│   │   │   │   │   ├── M_ReflectionDemo_3.uasset
│   │   │   │   │   ├── M_ReflectionDemo_MAT.uasset
│   │   │   │   │   ├── M_ReflectionDemo_Metallic_1.uasset
│   │   │   │   │   ├── M_ReflectionDemo_Metallic_2.uasset
│   │   │   │   │   ├── M_ReflectionDemo_Metallic_3.uasset
│   │   │   │   │   ├── M_SceneCapture2d.uasset
│   │   │   │   │   ├── M_SceneCaptureCube.uasset
│   │   │   │   │   ├── M_TestSky.uasset
│   │   │   │   │   ├── M_TestSky_Inst.uasset
│   │   │   │   │   ├── M_UE4_Logo_2.uasset
│   │   │   │   │   ├── M_UE4_Logo_Door.uasset
│   │   │   │   │   └── M_UE4_Logo_Doors.uasset
│   │   │   │   ├── Meshes
│   │   │   │   │   ├── SM_Base.uasset
│   │   │   │   │   ├── SM_Base2.uasset
│   │   │   │   │   ├── SM_BaseRoom.uasset
│   │   │   │   │   ├── SM_BaseTrimSquare.uasset
│   │   │   │   │   ├── SM_Base_FlatWall.uasset
│   │   │   │   │   ├── SM_Button.uasset
│   │   │   │   │   ├── SM_DemoCube.uasset
│   │   │   │   │   ├── SM_DemoDivider_1.uasset
│   │   │   │   │   ├── SM_DemoDivider_2.uasset
│   │   │   │   │   ├── SM_DemoPlate.uasset
│   │   │   │   │   ├── SM_DemoRoomBackWall.uasset
│   │   │   │   │   ├── SM_DemoRoomBackWall2.uasset
│   │   │   │   │   ├── SM_DemoRoomBox.uasset
│   │   │   │   │   ├── SM_DemoRoomClamp.uasset
│   │   │   │   │   ├── SM_DemoRoomClamp2.uasset
│   │   │   │   │   ├── SM_DemoRoomL.uasset
│   │   │   │   │   ├── SM_DemoRoomLTrim.uasset
│   │   │   │   │   ├── SM_DemoRoomTrim.uasset
│   │   │   │   │   ├── SM_DemoRoomTrim2.uasset
│   │   │   │   │   ├── SM_DemoRoomTrimAdd.uasset
│   │   │   │   │   ├── SM_DemoRoomU.uasset
│   │   │   │   │   ├── SM_DemoRoomU2.uasset
│   │   │   │   │   ├── SM_DemoRoomU_Hole.uasset
│   │   │   │   │   ├── SM_DemoSurface.uasset
│   │   │   │   │   ├── SM_Door.uasset
│   │   │   │   │   ├── SM_DoorLock.uasset
│   │   │   │   │   ├── SM_GraphFrame.uasset
│   │   │   │   │   ├── SM_LightSculpture.uasset
│   │   │   │   │   ├── SM_NamePlate.uasset
│   │   │   │   │   ├── SM_Slider1.uasset
│   │   │   │   │   ├── SM_SliderBase.uasset
│   │   │   │   │   ├── SM_UE4_Logo.uasset
│   │   │   │   │   ├── SM_URoom_Wall.uasset
│   │   │   │   │   └── SM_URoom_Wall2.uasset
│   │   │   │   └── Textures
│   │   │   │       ├── NewTextureRenderTarget2D.uasset
│   │   │   │       ├── NewTextureRenderTargetCube.uasset
│   │   │   │       ├── T_Pattern_M.uasset
│   │   │   │       ├── T_RoomTiles_M.uasset
│   │   │   │       ├── T_RoomTiles_N.uasset
│   │   │   │       ├── T_UE4_Logo_M.uasset
│   │   │   │       └── T_UnrealEngineDecal.uasset
│   │   │   ├── Functins
│   │   │   │   ├── MF_CircleBarTime.uasset
│   │   │   │   ├── MF_DivisionJumpHard.uasset
│   │   │   │   ├── MF_SMin.uasset
│   │   │   │   ├── MF_SMin2.uasset
│   │   │   │   ├── MF_SmoothStepWidth.uasset
│   │   │   │   ├── MF_Translcent.uasset
│   │   │   │   └── MF_TriangleWave.uasset
│   │   │   ├── Materials
│   │   │   │   ├── ExamplesSurface
│   │   │   │   │   ├── MI_DivisionPattern.uasset
│   │   │   │   │   ├── MI_DivisionScale.uasset
│   │   │   │   │   ├── MI_DivisionSmooth.uasset
│   │   │   │   │   ├── MI_DivisionWinXP.uasset
│   │   │   │   │   ├── MI_PatternArrow.uasset
│   │   │   │   │   ├── MI_PatternHearts.uasset
│   │   │   │   │   ├── MI_PatternHex.uasset
│   │   │   │   │   ├── MI_PatternStars.uasset
│   │   │   │   │   ├── MI_PogressColors.uasset
│   │   │   │   │   ├── MI_ProgressBurn.uasset
│   │   │   │   │   ├── MI_ProgressHealth.uasset
│   │   │   │   │   ├── MI_ProgressRound.uasset
│   │   │   │   │   ├── MI_Tutorial.uasset
│   │   │   │   │   ├── SM_PreviewCircleModel.uasset
│   │   │   │   │   └── SM_PreviewModel.uasset
│   │   │   │   ├── ExamplesSurfaceCircle
│   │   │   │   │   ├── BP_CircleBar.uasset
│   │   │   │   │   ├── MI_DivisionsThin.uasset
│   │   │   │   │   ├── MI_FlatColor.uasset
│   │   │   │   │   ├── MI_FlatOutline.uasset
│   │   │   │   │   ├── MI_HeartShape.uasset
│   │   │   │   │   ├── MI_LoadingBar.uasset
│   │   │   │   │   ├── MI_OutlineBIg.uasset
│   │   │   │   │   ├── MI_OutlineRadius.uasset
│   │   │   │   │   ├── MI_OutlineSmall.uasset
│   │   │   │   │   ├── MI_SimplePogress.uasset
│   │   │   │   │   └── MI_SoftNeon.uasset
│   │   │   │   ├── ExamplesUmg
│   │   │   │   │   ├── MI_UmgDivisionScale.uasset
│   │   │   │   │   ├── MI_UmgDivisionSmooth.uasset
│   │   │   │   │   ├── MI_UmgDivisionWinXP.uasset
│   │   │   │   │   ├── MI_UmgParameterChange.uasset
│   │   │   │   │   ├── MI_UmgPatternArrow.uasset
│   │   │   │   │   ├── MI_UmgPatternHearts.uasset
│   │   │   │   │   ├── MI_UmgPatternHex.uasset
│   │   │   │   │   ├── MI_UmgPatternStars.uasset
│   │   │   │   │   ├── MI_UmgPogressColors.uasset
│   │   │   │   │   ├── MI_UmgProgressBurn.uasset
│   │   │   │   │   ├── MI_UmgProgressHealth.uasset
│   │   │   │   │   ├── MI_UmgProgressRound.uasset
│   │   │   │   │   └── MI_UmgUmgDivisionPattern.uasset
│   │   │   │   ├── ExamplesUmgCircle
│   │   │   │   │   ├── MI_DivisionsThin.uasset
│   │   │   │   │   ├── MI_FlatColor.uasset
│   │   │   │   │   ├── MI_FlatOutline.uasset
│   │   │   │   │   ├── MI_HeartShape.uasset
│   │   │   │   │   ├── MI_LoadingBar.uasset
│   │   │   │   │   ├── MI_OutlineBIg.uasset
│   │   │   │   │   ├── MI_OutlineRadius.uasset
│   │   │   │   │   ├── MI_OutlineSmall.uasset
│   │   │   │   │   ├── MI_SimplePogress.uasset
│   │   │   │   │   └── MI_SoftNeon.uasset
│   │   │   │   ├── MF_Circle.uasset
│   │   │   │   ├── MF_Layers.uasset
│   │   │   │   ├── MF_Rect.uasset
│   │   │   │   ├── MI_SurfaceCircleBar.uasset
│   │   │   │   ├── MI_SurfaceRectBar.uasset
│   │   │   │   ├── MI_UmgCircleBar.uasset
│   │   │   │   ├── MI_UmgRectBar.uasset
│   │   │   │   ├── M_SurfaceCircleBar.uasset
│   │   │   │   ├── M_SurfaceRectBar.uasset
│   │   │   │   ├── M_UmgCircleBar.uasset
│   │   │   │   └── M_UmgRectBar.uasset
│   │   │   └── Textures
│   │   │       ├── Gloss
│   │   │       │   ├── T_GLossShadowCenter.uasset
│   │   │       │   ├── T_GLossShadowVertical.uasset
│   │   │       │   ├── T_GlossShadowEdge.uasset
│   │   │       │   ├── T_Gloss_Dark.uasset
│   │   │       │   └── T_Gloss_Light.uasset
│   │   │       ├── Gradient
│   │   │       │   ├── T_GradientBurn.uasset
│   │   │       │   └── T_GradientColors.uasset
│   │   │       └── Patterns
│   │   │           ├── T_PatternHeart.uasset
│   │   │           ├── T_PatternHex.uasset
│   │   │           ├── T_PatternLayersArrow.uasset
│   │   │           ├── T_PatternWorley.uasset
│   │   │           └── T_patternStar.uasset
│   │   ├── Sounds
│   │   │   ├── Attenuations
│   │   │   │   └── Footsteps_att.uasset
│   │   │   ├── ElimBot
│   │   │   │   ├── ElimBot.uasset
│   │   │   │   ├── ElimBot_Cue.uasset
│   │   │   │   └── ElimBot_att.uasset
│   │   │   ├── Footsteps
│   │   │   │   ├── SCue_FS_Tile.uasset
│   │   │   │   └── wav
│   │   │   │       ├── sw_FS_Tile_01.uasset
│   │   │   │       ├── sw_FS_Tile_02.uasset
│   │   │   │       ├── sw_FS_Tile_03.uasset
│   │   │   │       ├── sw_FS_Tile_04.uasset
│   │   │   │       ├── sw_FS_Tile_05.uasset
│   │   │   │       ├── sw_FS_Tile_06.uasset
│   │   │   │       ├── sw_FS_Tile_07.uasset
│   │   │   │       ├── sw_FS_Tile_08.uasset
│   │   │   │       ├── sw_FS_Tile_09.uasset
│   │   │   │       └── sw_FS_Tile_10.uasset
│   │   │   ├── Grenade
│   │   │   │   ├── ThrowGrenade_Cue.uasset
│   │   │   │   └── sw_Foley_Aim_01.uasset
│   │   │   ├── Gunshots
│   │   │   │   ├── SMG_Cue.uasset
│   │   │   │   ├── SMG_Shot_1.uasset
│   │   │   │   ├── SMG_Shot_10.uasset
│   │   │   │   ├── SMG_Shot_2.uasset
│   │   │   │   ├── SMG_Shot_3.uasset
│   │   │   │   ├── SMG_Shot_4.uasset
│   │   │   │   ├── SMG_Shot_5.uasset
│   │   │   │   ├── SMG_Shot_6.uasset
│   │   │   │   ├── SMG_Shot_7.uasset
│   │   │   │   ├── SMG_Shot_8.uasset
│   │   │   │   └── SMG_Shot_9.uasset
│   │   │   ├── Interface_And_Item_Sounds
│   │   │   │   ├── Cues
│   │   │   │   │   ├── Abstract_Pop_01_Cue.uasset
│   │   │   │   │   ├── Abstract_Pop_02_Cue.uasset
│   │   │   │   │   ├── Abstract_Pop_03_Cue.uasset
│   │   │   │   │   ├── Abstract_Pop_04_Cue.uasset
│   │   │   │   │   ├── Abstract_Pop_05_Cue.uasset
│   │   │   │   │   ├── Back_Click_01_Cue.uasset
│   │   │   │   │   ├── Back_Click_02_Cue.uasset
│   │   │   │   │   ├── Back_Click_03_Cue.uasset
│   │   │   │   │   ├── Back_Click_04_Cue.uasset
│   │   │   │   │   ├── Back_Click_05_Cue.uasset
│   │   │   │   │   ├── Back_Click_06_Cue.uasset
│   │   │   │   │   ├── Back_Click_07_Cue.uasset
│   │   │   │   │   ├── Back_Click_08_Cue.uasset
│   │   │   │   │   ├── Back_Click_09_Cue.uasset
│   │   │   │   │   ├── Back_Click_10_Cue.uasset
│   │   │   │   │   ├── Back_Click_11_Cue.uasset
│   │   │   │   │   ├── Bar_Filling_01_Cue.uasset
│   │   │   │   │   ├── Bar_Filling_02_Cue.uasset
│   │   │   │   │   ├── Cartoon_Falling_01_Cue.uasset
│   │   │   │   │   ├── Cartoon_Falling_02_Cue.uasset
│   │   │   │   │   ├── Cartoon_Falling_03_Cue.uasset
│   │   │   │   │   ├── Cartoon_Falling_04_Cue.uasset
│   │   │   │   │   ├── Cartoon_Falling_05_Cue.uasset
│   │   │   │   │   ├── Click_01_Cue.uasset
│   │   │   │   │   ├── Click_02_Cue.uasset
│   │   │   │   │   ├── Click_03_Cue.uasset
│   │   │   │   │   ├── Click_04_Cue.uasset
│   │   │   │   │   ├── Click_05_Cue.uasset
│   │   │   │   │   ├── Click_06_Cue.uasset
│   │   │   │   │   ├── Click_07_Cue.uasset
│   │   │   │   │   ├── Click_08_Cue.uasset
│   │   │   │   │   ├── Click_09_Cue.uasset
│   │   │   │   │   ├── Click_10_Cue.uasset
│   │   │   │   │   ├── Click_11_Cue.uasset
│   │   │   │   │   ├── Coins_01_Cue.uasset
│   │   │   │   │   ├── Coins_02_Cue.uasset
│   │   │   │   │   ├── Coins_03_Cue.uasset
│   │   │   │   │   ├── Coins_04_Cue.uasset
│   │   │   │   │   ├── Coins_05_Cue.uasset
│   │   │   │   │   ├── Coins_06_Cue.uasset
│   │   │   │   │   ├── Coins_07_Cue.uasset
│   │   │   │   │   ├── Coins_08_Cue.uasset
│   │   │   │   │   ├── Coins_09_Cue.uasset
│   │   │   │   │   ├── Coins_10_Cue.uasset
│   │   │   │   │   ├── Coins_11_Cue.uasset
│   │   │   │   │   ├── Coins_12_Cue.uasset
│   │   │   │   │   ├── Coins_13_Cue.uasset
│   │   │   │   │   ├── Coins_14_Cue.uasset
│   │   │   │   │   ├── Coins_15_Cue.uasset
│   │   │   │   │   ├── Discordant_GameOver_Musical_Long_Cue.uasset
│   │   │   │   │   ├── Discordant_GameOver_Musical_Short_Cue.uasset
│   │   │   │   │   ├── Error_Buzz_01_Cue.uasset
│   │   │   │   │   ├── Error_Buzz_02_Cue.uasset
│   │   │   │   │   ├── Error_Buzz_03_Cue.uasset
│   │   │   │   │   ├── Error_Buzz_04_Cue.uasset
│   │   │   │   │   ├── Error_Buzz_05_Cue.uasset
│   │   │   │   │   ├── Flick_Switch_01_Cue.uasset
│   │   │   │   │   ├── Flick_Switch_02_Cue.uasset
│   │   │   │   │   ├── Flick_Switch_03_Cue.uasset
│   │   │   │   │   ├── Flick_Switch_04_Cue.uasset
│   │   │   │   │   ├── Flick_Switch_05_Cue.uasset
│   │   │   │   │   ├── Futuristic_Alarm_01_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_01_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_02_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_03_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_04_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_05_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_06_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_07_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_08_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_09_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_10_Cue.uasset
│   │   │   │   │   ├── Futuristic_Click_11_Cue.uasset
│   │   │   │   │   ├── Gong_01_Cue.uasset
│   │   │   │   │   ├── Gong_02_Cue.uasset
│   │   │   │   │   ├── Gong_03_Cue.uasset
│   │   │   │   │   ├── Item_Sell_Purchase_01_Cue.uasset
│   │   │   │   │   ├── Item_Sell_Purchase_02_Cue.uasset
│   │   │   │   │   ├── Item_Sell_Purchase_03_Cue.uasset
│   │   │   │   │   ├── Item_Sell_Purchase_04_Cue.uasset
│   │   │   │   │   ├── Item_Sell_Purchase_05_Cue.uasset
│   │   │   │   │   ├── Musical_Click_01_Cue.uasset
│   │   │   │   │   ├── Musical_Click_02_Cue.uasset
│   │   │   │   │   ├── Musical_Click_03_Cue.uasset
│   │   │   │   │   ├── Musical_Click_04_Cue.uasset
│   │   │   │   │   ├── Musical_Click_05_Cue.uasset
│   │   │   │   │   ├── Musical_Click_06_Cue.uasset
│   │   │   │   │   ├── Musical_Click_07_Cue.uasset
│   │   │   │   │   ├── Musical_Click_08_Cue.uasset
│   │   │   │   │   ├── Musical_Click_09_Cue.uasset
│   │   │   │   │   ├── Musical_Click_10_Cue.uasset
│   │   │   │   │   ├── Pop_01_Cue.uasset
│   │   │   │   │   ├── Pop_02_Cue.uasset
│   │   │   │   │   ├── Pop_03_Cue.uasset
│   │   │   │   │   ├── Pop_04_Cue.uasset
│   │   │   │   │   ├── Pop_05_Cue.uasset
│   │   │   │   │   ├── Pop_06_Cue.uasset
│   │   │   │   │   ├── Pop_07_Cue.uasset
│   │   │   │   │   ├── Pop_08_Cue.uasset
│   │   │   │   │   ├── Pop_09_Cue.uasset
│   │   │   │   │   ├── Pop_10_Cue.uasset
│   │   │   │   │   ├── Ringtone_01_Cue.uasset
│   │   │   │   │   ├── Special_Musical_01_Cue.uasset
│   │   │   │   │   ├── Special_Musical_02_Cue.uasset
│   │   │   │   │   ├── Special_Musical_03_Cue.uasset
│   │   │   │   │   ├── Special_Musical_04_Cue.uasset
│   │   │   │   │   ├── Special_Musical_05_Cue.uasset
│   │   │   │   │   ├── Special_Powerup_01_Cue.uasset
│   │   │   │   │   ├── Special_Powerup_02_Cue.uasset
│   │   │   │   │   ├── Special_Powerup_03_Cue.uasset
│   │   │   │   │   ├── Special_Powerup_04_Cue.uasset
│   │   │   │   │   ├── Special_Powerup_05_Cue.uasset
│   │   │   │   │   ├── Special_Powerup_06_Cue.uasset
│   │   │   │   │   ├── Special_Powerup_07_Cue.uasset
│   │   │   │   │   ├── Special_Powerup_08_Cue.uasset
│   │   │   │   │   ├── Special_Powerup_09_Cue.uasset
│   │   │   │   │   └── Special_Powerup_10_Cue.uasset
│   │   │   │   └── WAV
│   │   │   │       ├── Abstract_Pop_01.uasset
│   │   │   │       ├── Abstract_Pop_02.uasset
│   │   │   │       ├── Abstract_Pop_03.uasset
│   │   │   │       ├── Abstract_Pop_04.uasset
│   │   │   │       ├── Abstract_Pop_05.uasset
│   │   │   │       ├── Back_Click_01.uasset
│   │   │   │       ├── Back_Click_02.uasset
│   │   │   │       ├── Back_Click_03.uasset
│   │   │   │       ├── Back_Click_04.uasset
│   │   │   │       ├── Back_Click_05.uasset
│   │   │   │       ├── Back_Click_06.uasset
│   │   │   │       ├── Back_Click_07.uasset
│   │   │   │       ├── Back_Click_08.uasset
│   │   │   │       ├── Back_Click_09.uasset
│   │   │   │       ├── Back_Click_10.uasset
│   │   │   │       ├── Back_Click_11.uasset
│   │   │   │       ├── Bar_Filling_01.uasset
│   │   │   │       ├── Bar_Filling_02.uasset
│   │   │   │       ├── Cartoon_Falling_01.uasset
│   │   │   │       ├── Cartoon_Falling_02.uasset
│   │   │   │       ├── Cartoon_Falling_03.uasset
│   │   │   │       ├── Cartoon_Falling_04.uasset
│   │   │   │       ├── Cartoon_Falling_05.uasset
│   │   │   │       ├── Click_01.uasset
│   │   │   │       ├── Click_02.uasset
│   │   │   │       ├── Click_03.uasset
│   │   │   │       ├── Click_04.uasset
│   │   │   │       ├── Click_05.uasset
│   │   │   │       ├── Click_06.uasset
│   │   │   │       ├── Click_07.uasset
│   │   │   │       ├── Click_08.uasset
│   │   │   │       ├── Click_09.uasset
│   │   │   │       ├── Click_10.uasset
│   │   │   │       ├── Click_11.uasset
│   │   │   │       ├── Coins_01.uasset
│   │   │   │       ├── Coins_02.uasset
│   │   │   │       ├── Coins_03.uasset
│   │   │   │       ├── Coins_04.uasset
│   │   │   │       ├── Coins_05.uasset
│   │   │   │       ├── Coins_06.uasset
│   │   │   │       ├── Coins_07.uasset
│   │   │   │       ├── Coins_08.uasset
│   │   │   │       ├── Coins_09.uasset
│   │   │   │       ├── Coins_10.uasset
│   │   │   │       ├── Coins_11.uasset
│   │   │   │       ├── Coins_12.uasset
│   │   │   │       ├── Coins_13.uasset
│   │   │   │       ├── Coins_14.uasset
│   │   │   │       ├── Coins_15.uasset
│   │   │   │       ├── Discordant_GameOver_Musical_Long.uasset
│   │   │   │       ├── Discordant_GameOver_Musical_Short.uasset
│   │   │   │       ├── Error_Buzz_01.uasset
│   │   │   │       ├── Error_Buzz_02.uasset
│   │   │   │       ├── Error_Buzz_03.uasset
│   │   │   │       ├── Error_Buzz_04.uasset
│   │   │   │       ├── Error_Buzz_05.uasset
│   │   │   │       ├── Flick_Switch_01.uasset
│   │   │   │       ├── Flick_Switch_02.uasset
│   │   │   │       ├── Flick_Switch_03.uasset
│   │   │   │       ├── Flick_Switch_04.uasset
│   │   │   │       ├── Flick_Switch_05.uasset
│   │   │   │       ├── Futuristic_Alarm_01.uasset
│   │   │   │       ├── Futuristic_Click_01.uasset
│   │   │   │       ├── Futuristic_Click_02.uasset
│   │   │   │       ├── Futuristic_Click_03.uasset
│   │   │   │       ├── Futuristic_Click_04.uasset
│   │   │   │       ├── Futuristic_Click_05.uasset
│   │   │   │       ├── Futuristic_Click_06.uasset
│   │   │   │       ├── Futuristic_Click_07.uasset
│   │   │   │       ├── Futuristic_Click_08.uasset
│   │   │   │       ├── Futuristic_Click_09.uasset
│   │   │   │       ├── Futuristic_Click_10.uasset
│   │   │   │       ├── Futuristic_Click_11.uasset
│   │   │   │       ├── Gong_01.uasset
│   │   │   │       ├── Gong_02.uasset
│   │   │   │       ├── Gong_03.uasset
│   │   │   │       ├── Item_Sell_Purchase_01.uasset
│   │   │   │       ├── Item_Sell_Purchase_02.uasset
│   │   │   │       ├── Item_Sell_Purchase_03.uasset
│   │   │   │       ├── Item_Sell_Purchase_04.uasset
│   │   │   │       ├── Item_Sell_Purchase_05.uasset
│   │   │   │       ├── Musical_Click_01.uasset
│   │   │   │       ├── Musical_Click_02.uasset
│   │   │   │       ├── Musical_Click_03.uasset
│   │   │   │       ├── Musical_Click_04.uasset
│   │   │   │       ├── Musical_Click_05.uasset
│   │   │   │       ├── Musical_Click_06.uasset
│   │   │   │       ├── Musical_Click_07.uasset
│   │   │   │       ├── Musical_Click_08.uasset
│   │   │   │       ├── Musical_Click_09.uasset
│   │   │   │       ├── Musical_Click_10.uasset
│   │   │   │       ├── Pop_01.uasset
│   │   │   │       ├── Pop_02.uasset
│   │   │   │       ├── Pop_03.uasset
│   │   │   │       ├── Pop_04.uasset
│   │   │   │       ├── Pop_05.uasset
│   │   │   │       ├── Pop_06.uasset
│   │   │   │       ├── Pop_07.uasset
│   │   │   │       ├── Pop_08.uasset
│   │   │   │       ├── Pop_09.uasset
│   │   │   │       ├── Pop_10.uasset
│   │   │   │       ├── Ringtone_01.uasset
│   │   │   │       ├── Special_Musical_01.uasset
│   │   │   │       ├── Special_Musical_02.uasset
│   │   │   │       ├── Special_Musical_03.uasset
│   │   │   │       ├── Special_Musical_04.uasset
│   │   │   │       ├── Special_Musical_05.uasset
│   │   │   │       ├── Special_Powerup_01.uasset
│   │   │   │       ├── Special_Powerup_02.uasset
│   │   │   │       ├── Special_Powerup_03.uasset
│   │   │   │       ├── Special_Powerup_04.uasset
│   │   │   │       ├── Special_Powerup_05.uasset
│   │   │   │       ├── Special_Powerup_06.uasset
│   │   │   │       ├── Special_Powerup_07.uasset
│   │   │   │       ├── Special_Powerup_08.uasset
│   │   │   │       ├── Special_Powerup_09.uasset
│   │   │   │       └── Special_Powerup_10.uasset
│   │   │   ├── Jumps
│   │   │   │   ├── SCue_Foley_Jump.uasset
│   │   │   │   ├── SCue_Foley_Jumpland_Tile.uasset
│   │   │   │   └── wav
│   │   │   │       ├── sw_Foley_JumpLand_Tile_01.uasset
│   │   │   │       ├── sw_Foley_JumpLand_Tile_02.uasset
│   │   │   │       ├── sw_Foley_JumpLand_Tile_03.uasset
│   │   │   │       ├── sw_Foley_Jump_01.uasset
│   │   │   │       ├── sw_Foley_Jump_02.uasset
│   │   │   │       └── sw_Foley_Jump_03.uasset
│   │   │   ├── Pickups
│   │   │   │   ├── HealthPickup_Cue.uasset
│   │   │   │   ├── ShieldBuff_Cue.uasset
│   │   │   │   ├── SpeedBuff_Cue.uasset
│   │   │   │   ├── sw_Amb_OS_26.uasset
│   │   │   │   └── sw_Pickup_Health.uasset
│   │   │   ├── SMG
│   │   │   │   ├── SMG_PicupCue.uasset
│   │   │   │   ├── sw_Wep_AR_Equip_01.uasset
│   │   │   │   ├── sw_Wep_AR_Equip_02.uasset
│   │   │   │   └── sw_Wep_AR_Equip_03.uasset
│   │   │   └── Shells
│   │   │       ├── shell_03_wav.uasset
│   │   │       ├── shell_04_wav.uasset
│   │   │       ├── shell_10_wav.uasset
│   │   │       ├── shell_12_wav.uasset
│   │   │       ├── shell_13_wav.uasset
│   │   │       ├── shell_14_wav.uasset
│   │   │       ├── shell_16_wav.uasset
│   │   │       ├── shell_17_wav.uasset
│   │   │       ├── shell_21_wav.uasset
│   │   │       ├── shell_22_wav.uasset
│   │   │       ├── shell_25_wav.uasset
│   │   │       ├── shell_26_wav.uasset
│   │   │       ├── shell_32_wav.uasset
│   │   │       ├── shell_42_wav.uasset
│   │   │       ├── shell_44_wav.uasset
│   │   │       ├── shell_45_wav.uasset
│   │   │       ├── shell_47_wav.uasset
│   │   │       ├── shell_55_wav.uasset
│   │   │       ├── shell_59_wav.uasset
│   │   │       ├── shell_60_wav.uasset
│   │   │       ├── shell_61_wav.uasset
│   │   │       ├── shell_Cue.uasset
│   │   │       └── shells_att.uasset
│   │   ├── Textures
│   │   │   ├── Crosshairs
│   │   │   │   ├── Primary
│   │   │   │   │   ├── Crosshair_Bottom.uasset
│   │   │   │   │   ├── Crosshair_Center.uasset
│   │   │   │   │   ├── Crosshair_Left.uasset
│   │   │   │   │   ├── Crosshair_Right.uasset
│   │   │   │   │   └── Crosshair_Top.uasset
│   │   │   │   └── Shotgun
│   │   │   │       ├── shotgun_small_center.uasset
│   │   │   │       ├── shotgun_small_left.uasset
│   │   │   │       └── shotgun_small_right.uasset
│   │   │   ├── Grenades
│   │   │   │   └── GrenadeTextureOutlined12.uasset
│   │   │   ├── Overlay
│   │   │   │   └── Wifi_Signal.uasset
│   │   │   └── bar
│   │   │       ├── HealthBarMaterial.uasset
│   │   │       ├── HealthBar_TX.uasset
│   │   │       └── NegativeProgressTexture.uasset
│   │   ├── WeaponPack
│   │   │   ├── Materials
│   │   │   │   └── Weapons
│   │   │   │       ├── MI_FlagBlue.uasset
│   │   │   │       ├── MI_FlagRed.uasset
│   │   │   │       ├── M_Flag.uasset
│   │   │   │       └── M_WeaponSet_1.uasset
│   │   │   ├── Mesh
│   │   │   │   └── Weapons
│   │   │   │       └── Weapons_Kit
│   │   │   │           └── SM_Sword.uasset
│   │   │   └── Textures
│   │   │       └── Weapons
│   │   │           ├── T_Weapon_Set1_BaseColor.uasset
│   │   │           ├── T_Weapon_Set1_Normal.uasset
│   │   │           └── T_Weapon_Set1_OcclusionRoughnessMetallic.uasset
│   │   └── sA_PickupSet_1
│   │       ├── Blueprints
│   │       │   └── BP_RAY_Spawner.uasset
│   │       ├── Fx
│   │       │   ├── NiagaraEmitters
│   │       │   │   ├── NE_CoinBurst.uasset
│   │       │   │   ├── NE_Light.uasset
│   │       │   │   ├── NE_PickupCricle.uasset
│   │       │   │   ├── NE_SimpleBurst.uasset
│   │       │   │   ├── NE_SimpleSprite.uasset
│   │       │   │   └── Ne_Aura.uasset
│   │       │   └── NiagaraSystems
│   │       │       ├── NS_CoinBurst.uasset
│   │       │       ├── NS_CoinBurst2.uasset
│   │       │       ├── NS_Coin_Shower.uasset
│   │       │       ├── NS_Crown.uasset
│   │       │       ├── NS_Energy_1.uasset
│   │       │       ├── NS_Energy_2.uasset
│   │       │       ├── NS_Healing_1.uasset
│   │       │       ├── NS_Healing_2.uasset
│   │       │       ├── NS_Healing_3.uasset
│   │       │       ├── NS_Magic_1.uasset
│   │       │       ├── NS_Magic_2.uasset
│   │       │       ├── NS_Pickup_1.uasset
│   │       │       ├── NS_Pickup_2.uasset
│   │       │       ├── NS_Pickup_3.uasset
│   │       │       ├── NS_Pickup_4.uasset
│   │       │       ├── NS_Pickup_5.uasset
│   │       │       ├── NS_Shield.uasset
│   │       │       ├── NS_Shield_2.uasset
│   │       │       └── NS_Shield_3.uasset
│   │       ├── Levels
│   │       │   ├── LVL_Showroom.umap
│   │       │   └── LVL_Showroom_BuiltData.uasset
│   │       ├── Materials
│   │       │   ├── MI_Aura_1.uasset
│   │       │   ├── MI_Coin_1.uasset
│   │       │   ├── MI_Fresnel.uasset
│   │       │   ├── MI_Ground_Showscene.uasset
│   │       │   ├── MI_Scroll_1.uasset
│   │       │   ├── MI_Shield_1.uasset
│   │       │   ├── M_AdditiveScrollNiagara.uasset
│   │       │   ├── M_Ground.uasset
│   │       │   ├── M_Master_Fresnel.uasset
│   │       │   ├── M_Master_MetalFX.uasset
│   │       │   ├── M_Master_RadialBeam.uasset
│   │       │   ├── M_sA_Aura.uasset
│   │       │   └── Textures
│   │       │       ├── Beam01.png
│   │       │       ├── Noise00.png
│   │       │       ├── Noise000.png
│   │       │       ├── Noise01.png
│   │       │       ├── Noise01.uasset
│   │       │       ├── Noise02.png
│   │       │       ├── Noise02.uasset
│   │       │       ├── Noise04.png
│   │       │       ├── Noise04.uasset
│   │       │       ├── Noise06.png
│   │       │       ├── Noise06.uasset
│   │       │       ├── Noise07.png
│   │       │       ├── Noise07.uasset
│   │       │       ├── Noise08.png
│   │       │       ├── Noise08.uasset
│   │       │       ├── Noise09.png
│   │       │       ├── Noise09.uasset
│   │       │       ├── Noise10.png
│   │       │       ├── Noise11.png
│   │       │       ├── Noise11.uasset
│   │       │       ├── Noise12.png
│   │       │       ├── Noise12.uasset
│   │       │       ├── T_Beam_01.uasset
│   │       │       ├── T_NoiseCloud_1.uasset
│   │       │       ├── T_NoiseCloud_2.uasset
│   │       │       ├── T_NoiseFurry.uasset
│   │       │       ├── T_Noise_DistortedCaustic.uasset
│   │       │       ├── T_Ray_5.uasset
│   │       │       └── T_Shield_1.uasset
│   │       └── Models
│   │           ├── SM_Coin_1.uasset
│   │           ├── SM_Crown.uasset
│   │           ├── SM_Energy_1.uasset
│   │           ├── SM_Pickup_Defence.uasset
│   │           ├── SM_Pickup_Defence_2.uasset
│   │           ├── SM_Pickup_Defence_3.uasset
│   │           ├── SM_Pickup_Gem.uasset
│   │           ├── SM_Pickup_Health.uasset
│   │           ├── SM_Pickup_Magic.uasset
│   │           ├── SM_Pickup_ss.uasset
│   │           └── SM_Plane.uasset
│   ├── Blueprint
│   │   ├── CaptureTheFlag
│   │   │   ├── BP_BlueFlagZone.uasset
│   │   │   └── BP_RedFlagZone.uasset
│   │   ├── Character
│   │   │   ├── Animation
│   │   │   │   ├── AimAimOffset.uasset
│   │   │   │   ├── AimWalk.uasset
│   │   │   │   ├── BlasterAnimBP.uasset
│   │   │   │   ├── CrouchAimWalk.uasset
│   │   │   │   ├── CrouchWalking.uasset
│   │   │   │   ├── Elim.uasset
│   │   │   │   ├── EquippedRun.uasset
│   │   │   │   ├── FireWeapon.uasset
│   │   │   │   ├── Flag.uasset
│   │   │   │   ├── HipAimOffset.uasset
│   │   │   │   ├── HitReact.uasset
│   │   │   │   ├── Reload.uasset
│   │   │   │   ├── Swap.uasset
│   │   │   │   ├── ThrowGrenade.uasset
│   │   │   │   └── UnEquippedIdleWallRun.uasset
│   │   │   └── BP_BlasterCharacter.uasset
│   │   ├── GameModes
│   │   │   ├── BP_BlasterGameMode.uasset
│   │   │   ├── BP_CTFGameMode.uasset
│   │   │   ├── BP_LobbyGameMode.uasset
│   │   │   └── BP_TeamsGamgeMode.uasset
│   │   ├── GameState
│   │   │   └── BP_BlasterGameState.uasset
│   │   ├── HUD
│   │   │   ├── BP_BlasterHUD.uasset
│   │   │   ├── WBP_Announcement.uasset
│   │   │   ├── WBP_Character_Overlay.uasset
│   │   │   ├── WBP_Chart.uasset
│   │   │   ├── WBP_ElimAnnouncement.uasset
│   │   │   ├── WBP_OverheadWidget.uasset
│   │   │   ├── WBP_PickupWidget.uasset
│   │   │   ├── WBP_ReturnToMainMenu.uasset
│   │   │   └── WBP_SniperScope.uasset
│   │   ├── Pickups
│   │   │   ├── AmmoPickups
│   │   │   │   ├── BP_ARAmmo.uasset
│   │   │   │   ├── BP_GrenadeLauncherAmmo.uasset
│   │   │   │   ├── BP_PistolAmmo.uasset
│   │   │   │   ├── BP_RocketAmmo.uasset
│   │   │   │   ├── BP_SMGAmmo.uasset
│   │   │   │   ├── BP_ShotgunAmmo.uasset
│   │   │   │   └── BP_SniperAmmo.uasset
│   │   │   ├── BP_ARAmmo.uasset
│   │   │   ├── BP_ARAmmoSpawnPoint.uasset
│   │   │   ├── BP_AmmoSpawnPoint.uasset
│   │   │   ├── BP_BuffSpawnPoint.uasset
│   │   │   ├── BP_GrenadeLauncherAmmo.uasset
│   │   │   ├── BP_GrenadeLauncherAmmoSpawnPoint.uasset
│   │   │   ├── BP_HealthBuffSpawnPoint.uasset
│   │   │   ├── BP_JumpSpawnPoint.uasset
│   │   │   ├── BP_PistolAmmo.uasset
│   │   │   ├── BP_PistolAmmoSpawnPoint.uasset
│   │   │   ├── BP_RocketAmmo.uasset
│   │   │   ├── BP_RocketAmmoSpawnPoint.uasset
│   │   │   ├── BP_SMGAmmo.uasset
│   │   │   ├── BP_SMGAmmoSpawnPoint.uasset
│   │   │   ├── BP_ShieldBuffSpawnPoint.uasset
│   │   │   ├── BP_ShotgunAmmo.uasset
│   │   │   ├── BP_ShotgunAmmoSpawnPoint.uasset
│   │   │   ├── BP_SniperAmmo.uasset
│   │   │   ├── BP_SniperAmmoSpawnPoint.uasset
│   │   │   ├── BP_SpeedBuffSpawnPoint.uasset
│   │   │   └── BuffPickups
│   │   │       ├── BP_HealthPicup.uasset
│   │   │       ├── BP_JumpPickup.uasset
│   │   │       ├── BP_ShieldPickup.uasset
│   │   │       └── BP_SpeedPickup.uasset
│   │   ├── PlayerController
│   │   │   └── BP_BlasterPlayerController.uasset
│   │   ├── PlayerStart
│   │   │   ├── BP_BlueTeamStart.uasset
│   │   │   └── BP_RedTeamStart.uasset
│   │   ├── PlayerState
│   │   │   └── BP_BlasterPlayerState.uasset
│   │   └── Weapon
│   │       ├── BP_AssaultRifle.uasset
│   │       ├── BP_BlueFlag.uasset
│   │       ├── BP_Flag.uasset
│   │       ├── BP_GrenadeLauncher.uasset
│   │       ├── BP_Pistol.uasset
│   │       ├── BP_RedFlag.uasset
│   │       ├── BP_RocketLauncher.uasset
│   │       ├── BP_Shotgun.uasset
│   │       ├── BP_SniperRifle.uasset
│   │       ├── BP_SubmachineGun.uasset
│   │       ├── Casings
│   │       │   ├── BP_Casing.uasset
│   │       │   ├── BP_PistolCasing.uasset
│   │       │   └── BP_ShotgunCasing.uasset
│   │       └── Projectiles
│   │           ├── BP_Projectile.uasset
│   │           ├── BP_ProjectileBullet.uasset
│   │           ├── BP_ProjectileGrenade.uasset
│   │           ├── BP_Rocket.uasset
│   │           ├── BP_ServerSideRewindProjectile.uasset
│   │           └── BP_ThrowGrenade.uasset
│   ├── Maps
│   │   ├── BlasterLushMap.umap
│   │   ├── BlasterMap.umap
│   │   ├── BlasterMap_BuiltData.uasset
│   │   ├── CaptureTheFlagMap.umap
│   │   ├── DemoMap.umap
│   │   ├── GameStartupMap.umap
│   │   ├── Lobby.umap
│   │   ├── TeamsMap.umap
│   │   └── TransitionMap.umap
│   └── __ExternalActors__
│       └── ThirdPerson
│           └── Maps
│               └── ThirdPersonMap
│                   └── D
│                       └── SY
│                           └── Z4CTQ4LG3YV10EKPD0UE8Q.uasset
├── LICENSE
├── Plugins
│   └── MultiplayerSessions
│       ├── Content
│       │   └── WBP_Menu.uasset
│       ├── MultiplayerSessions.uplugin
│       ├── Resources
│       │   └── Icon128.png
│       └── Source
│           └── MultiplayerSessions
│               ├── MultiplayerSessions.Build.cs
│               ├── Private
│               │   ├── Menu.cpp
│               │   ├── MultiplayerSessions.cpp
│               │   └── MultiplayerSessionsSubsystem.cpp
│               └── Public
│                   ├── Menu.h
│                   ├── MultiplayerSessions.h
│                   └── MultiplayerSessionsSubsystem.h
├── README.md
├── Source
│   ├── Blaster
│   │   ├── Blaster.Build.cs
│   │   ├── Blaster.cpp
│   │   ├── Blaster.h
│   │   ├── BlasterComponents
│   │   │   ├── BuffComponent.cpp
│   │   │   ├── BuffComponent.h
│   │   │   ├── CombatComponent.cpp
│   │   │   ├── CombatComponent.h
│   │   │   ├── LagCompensationComponent.cpp
│   │   │   └── LagCompensationComponent.h
│   │   ├── BlasterTypes
│   │   │   ├── Announcement.h
│   │   │   ├── CombatState.h
│   │   │   ├── Team.h
│   │   │   └── TurningInPlace.h
│   │   ├── CaptureTheFlag
│   │   │   ├── FlagZone.cpp
│   │   │   └── FlagZone.h
│   │   ├── Character
│   │   │   ├── BlasterAnimInstance.cpp
│   │   │   ├── BlasterAnimInstance.h
│   │   │   ├── BlasterCharacter.cpp
│   │   │   └── BlasterCharacter.h
│   │   ├── GameMode
│   │   │   ├── BlasterGameMode.cpp
│   │   │   ├── BlasterGameMode.h
│   │   │   ├── CaptureTheFlagGameMode.cpp
│   │   │   ├── CaptureTheFlagGameMode.h
│   │   │   ├── LobbyGameMode.cpp
│   │   │   ├── LobbyGameMode.h
│   │   │   ├── TeamsGameMode.cpp
│   │   │   └── TeamsGameMode.h
│   │   ├── GameState
│   │   │   ├── BlasterGameState.cpp
│   │   │   └── BlasterGameState.h
│   │   ├── HUD
│   │   │   ├── Announcement.cpp
│   │   │   ├── Announcement.h
│   │   │   ├── BlasterHUD.cpp
│   │   │   ├── BlasterHUD.h
│   │   │   ├── CharacterOverlay.cpp
│   │   │   ├── CharacterOverlay.h
│   │   │   ├── ElimAnnouncement.cpp
│   │   │   ├── ElimAnnouncement.h
│   │   │   ├── OverheadWidget.cpp
│   │   │   ├── OverheadWidget.h
│   │   │   ├── ReturnToMainMenu.cpp
│   │   │   └── ReturnToMainMenu.h
│   │   ├── Interface
│   │   │   ├── InteractWithCrosshairsInterface.cpp
│   │   │   └── InteractWithCrosshairsInterface.h
│   │   ├── Pickups
│   │   │   ├── AmmoPickup.cpp
│   │   │   ├── AmmoPickup.h
│   │   │   ├── BacktrackingPickup.cpp
│   │   │   ├── BacktrackingPickup.h
│   │   │   ├── HealthPickup.cpp
│   │   │   ├── HealthPickup.h
│   │   │   ├── JumpPickup.cpp
│   │   │   ├── JumpPickup.h
│   │   │   ├── Pickup.cpp
│   │   │   ├── Pickup.h
│   │   │   ├── PickupSpawnPoint.cpp
│   │   │   ├── PickupSpawnPoint.h
│   │   │   ├── ShieldPickup.cpp
│   │   │   ├── ShieldPickup.h
│   │   │   ├── SpeedPickup.cpp
│   │   │   └── SpeedPickup.h
│   │   ├── PlayerController
│   │   │   ├── BlasterPlayerController.cpp
│   │   │   └── BlasterPlayerController.h
│   │   ├── PlayerStart
│   │   │   ├── TeamPlayerStart.cpp
│   │   │   └── TeamPlayerStart.h
│   │   ├── PlayerState
│   │   │   ├── BlasterPlayerState.cpp
│   │   │   └── BlasterPlayerState.h
│   │   └── Weapon
│   │       ├── Casing.cpp
│   │       ├── Casing.h
│   │       ├── Flag.cpp
│   │       ├── Flag.h
│   │       ├── HitScanWeapon.cpp
│   │       ├── HitScanWeapon.h
│   │       ├── Projectile.cpp
│   │       ├── Projectile.h
│   │       ├── ProjectileBullet.cpp
│   │       ├── ProjectileBullet.h
│   │       ├── ProjectileGrenade.cpp
│   │       ├── ProjectileGrenade.h
│   │       ├── ProjectileRocket.cpp
│   │       ├── ProjectileRocket.h
│   │       ├── ProjectileWeapon.cpp
│   │       ├── ProjectileWeapon.h
│   │       ├── RocketMovementComponent.cpp
│   │       ├── RocketMovementComponent.h
│   │       ├── Shotgun.cpp
│   │       ├── Shotgun.h
│   │       ├── Weapon.cpp
│   │       ├── Weapon.h
│   │       └── WeaponTypes.h
│   ├── Blaster.Target.cs
│   └── BlasterEditor.Target.cs
└── note
    ├── Actor与Component的插件与销毁.md
    ├── Multiplayer Online Subsystem 多人在线子系统.md
    ├── ProjectleSSR.md
    ├── UE
    │   ├── UE4 C++基础 - Hello World.md
    │   ├── UE4 C++基础 - 基础数据结构.md
    │   ├── UE4 C++基础 - 多线程.md
    │   ├── UE4 C++基础 - 字符串和本地化.md
    │   ├── UE4 C++基础 - 工程目录结构.md
    │   ├── UE4 C++基础 - 编码规范.md
    │   ├── UE4 C++基础 - 资源常见名词解释.md
    │   ├── UE4 UObject解析.md
    │   ├── UE4设计模式 - 简介.md
    │   └── 内存相关资料收集.md
    ├── UE中的旋转.md
    ├── UE在RPC调用中对旋转角的优化.md
    ├── UE基础问题.md
    ├── UE是如何让角色动起来的.md
    ├── UE添加自定义的碰撞类型.md
    ├── image-20240329175041524.png
    ├── image-20240329183038566.png
    ├── image-20240329183201839.png
    └── image-20240329183629142.png

```

`Blaster.uproject`:

```uproject
{
	"FileVersion": 3,
	"EngineAssociation": "5.3",
	"Category": "",
	"Description": "",
	"Modules": [
		{
			"Name": "Blaster",
			"Type": "Runtime",
			"LoadingPhase": "Default",
			"AdditionalDependencies": [
				"Engine",
				"UMG"
			]
		}
	],
	"Plugins": [
		{
			"Name": "ModelingToolsEditorMode",
			"Enabled": true,
			"TargetAllowList": [
				"Editor"
			]
		},
		{
			"Name": "OnlineSubsystemSteam",
			"Enabled": true
		},
		{
			"Name": "Bridge",
			"Enabled": true,
			"SupportedTargetPlatforms": [
				"Win64",
				"Mac",
				"Linux"
			]
		}
	]
}
```

`Config/DefaultEditor.ini`:

```ini
[/Script/AdvancedPreviewScene.SharedProfiles]


```

`Config/DefaultEngine.ini`:

```ini


[/Script/EngineSettings.GameMapsSettings]
GameDefaultMap=/Game/Maps/GameStartupMap.GameStartupMap
EditorStartupMap=/Game/Maps/GameStartupMap.GameStartupMap
TransitionMap=/Game/Maps/TransitionMap.TransitionMap

[/Script/HardwareTargeting.HardwareTargetingSettings]
TargetedHardwareClass=Desktop
AppliedTargetedHardwareClass=Desktop
DefaultGraphicsPerformance=Maximum
AppliedDefaultGraphicsPerformance=Maximum

[/Script/WindowsTargetPlatform.WindowsTargetSettings]
DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
-D3D12TargetedShaderFormats=PCD3D_SM5
+D3D12TargetedShaderFormats=PCD3D_SM5
+D3D12TargetedShaderFormats=PCD3D_SM6
-D3D11TargetedShaderFormats=PCD3D_SM5
+D3D11TargetedShaderFormats=PCD3D_SM5
Compiler=Default
AudioSampleRate=48000
AudioCallbackBufferFrameSize=1024
AudioNumBuffersToEnqueue=1
AudioMaxChannels=0
AudioNumSourceWorkers=4
SpatializationPlugin=
SourceDataOverridePlugin=
ReverbPlugin=
OcclusionPlugin=
CompressionOverrides=(bOverrideCompressionTimes=False,DurationThreshold=5.000000,MaxNumRandomBranches=0,SoundCueQualityIndex=0)
CacheSizeKB=65536
MaxChunkSizeOverrideKB=0
bResampleForDevice=False
MaxSampleRate=48000.000000
HighSampleRate=32000.000000
MedSampleRate=24000.000000
LowSampleRate=12000.000000
MinSampleRate=8000.000000
CompressionQualityModifier=1.000000
AutoStreamingThreshold=0.000000
SoundCueCookQualityIndex=-1

[/Script/Engine.RendererSettings]
r.GenerateMeshDistanceFields=True
r.DynamicGlobalIlluminationMethod=1
r.ReflectionMethod=1
r.Shadow.Virtual.Enable=1
r.CustomDepth=3

[/Script/WorldPartitionEditor.WorldPartitionEditorSettings]
CommandletClass=Class'/Script/UnrealEd.WorldPartitionConvertCommandlet'

[/Script/Engine.Engine]
+ActiveGameNameRedirects=(OldGameName="TP_Blank",NewGameName="/Script/Blaster")
+ActiveGameNameRedirects=(OldGameName="/Script/TP_Blank",NewGameName="/Script/Blaster")
+ActiveClassRedirects=(OldClassName="TP_BlankGameModeBase",NewClassName="BlasterGameModeBase")

[/Script/AndroidFileServerEditor.AndroidFileServerRuntimeSettings]
bEnablePlugin=True
bAllowNetworkConnection=True
SecurityToken=40A0E1B54A5F9C58F0E79FA10A56F8D8
bIncludeInShipping=False
bAllowExternalStartInShipping=False
bCompileAFSProject=False
bUseCompression=False
bLogFiles=False
bReportStats=False
ConnectionType=USBOnly
bUseManualIPAddress=False
ManualIPAddress=

[/Script/Engine.GameEngine]
+NetDriverDefinitions=(DefName="GameNetDriver",DriverClassName="OnlineSubsystemSteam.SteamNetDriver",DriverClassNameFallback="OnlineSubsystemUtils.IpNetDriver")

[OnlineSubsystem]
DefaultPlatformService=Steam

[OnlineSubsystemSteam]
bEnabled=true
SteamDevAppId=480

; If using Sessions
bInitServerOnClient=true

[/Script/OnlineSubsystemSteam.SteamNetDriver]
NetConnectionClassName="OnlineSubsystemSteam.SteamNetConnection"

; ?????????δ???

[/Script/OnlineSubsystemUtils.IpNetDriver]
NetServerMaxTickRate=60

[/Script/Engine.CollisionProfile]
-Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision",bCanModify=False)
-Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ",bCanModify=False)
-Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ",bCanModify=False)
-Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic",Response=ECR_Block),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.",bCanModify=False)
-Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors",bCanModify=False)
-Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors",bCanModify=False)
-Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.",bCanModify=False)
-Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.",bCanModify=False)
-Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="UI",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Block),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
+Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision")
+Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.")
+Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ")
+Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ")
+Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic"),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.")
+Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.")
+Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors")
+Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors")
+Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.")
+Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.")
+Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.")
+Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.")
+Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.")
+Profiles=(Name="UI",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility"),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel1,DefaultResponse=ECR_Block,bTraceType=False,bStaticObject=False,Name="SkeletalMesh")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel2,DefaultResponse=ECR_Ignore,bTraceType=False,bStaticObject=False,Name="HitBox")
-ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
-ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
-ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
-ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
-ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
+ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
+ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
+ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
+ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
+ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
-CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
-CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
-CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
-CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")
+CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
+CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
+CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
+CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")

[PacketSimulationSettings]
PktLag = 0


```

`Config/DefaultGame.ini`:

```ini


[/Script/EngineSettings.GeneralProjectSettings]
ProjectID=FF69ACB34E8E7B16ABB293927569ABB5

[/Script/Engine.GameSession]
MaxPlayers=100

[/Script/UnrealEd.ProjectPackagingSettings]
Build=IfProjectHasCode
BuildConfiguration=PPBC_Development
BuildTarget=
FullRebuild=False
ForDistribution=False
IncludeDebugFiles=False
BlueprintNativizationMethod=Disabled
bIncludeNativizedAssetsInProjectGeneration=False
bExcludeMonolithicEngineHeadersInNativizedCode=False
UsePakFile=True
bUseIoStore=True
bUseZenStore=False
bMakeBinaryConfig=False
bGenerateChunks=False
bGenerateNoChunks=False
bChunkHardReferencesOnly=False
bForceOneChunkPerFile=False
MaxChunkSize=0
bBuildHttpChunkInstallData=False
HttpChunkInstallDataDirectory=(Path="")
WriteBackMetadataToAssetRegistry=Disabled
bCompressed=True
PackageCompressionFormat=Oodle
bForceUseProjectCompressionFormatIgnoreHardwareOverride=False
PackageAdditionalCompressionOptions=
PackageCompressionMethod=Kraken
PackageCompressionLevel_DebugDevelopment=4
PackageCompressionLevel_TestShipping=5
PackageCompressionLevel_Distribution=7
PackageCompressionMinBytesSaved=1024
PackageCompressionMinPercentSaved=5
bPackageCompressionEnableDDC=False
PackageCompressionMinSizeToConsiderDDC=0
HttpChunkInstallDataVersion=
IncludePrerequisites=True
IncludeAppLocalPrerequisites=False
bShareMaterialShaderCode=True
bDeterministicShaderCodeOrder=False
bSharedMaterialNativeLibraries=True
ApplocalPrerequisitesDirectory=(Path="")
IncludeCrashReporter=False
InternationalizationPreset=English
-CulturesToStage=en
+CulturesToStage=en
LocalizationTargetCatchAllChunkId=0
bCookAll=False
bCookMapsOnly=False
bSkipEditorContent=False
bSkipMovies=False
-IniKeyDenylist=KeyStorePassword
-IniKeyDenylist=KeyPassword
-IniKeyDenylist=rsa.privateexp
-IniKeyDenylist=rsa.modulus
-IniKeyDenylist=rsa.publicexp
-IniKeyDenylist=aes.key
-IniKeyDenylist=SigningPublicExponent
-IniKeyDenylist=SigningModulus
-IniKeyDenylist=SigningPrivateExponent
-IniKeyDenylist=EncryptionKey
-IniKeyDenylist=DevCenterUsername
-IniKeyDenylist=DevCenterPassword
-IniKeyDenylist=IOSTeamID
-IniKeyDenylist=SigningCertificate
-IniKeyDenylist=MobileProvision
-IniKeyDenylist=IniKeyDenylist
-IniKeyDenylist=IniSectionDenylist
+IniKeyDenylist=IniKeyDenylist
+IniKeyDenylist=KeyStorePassword
+IniKeyDenylist=KeyPassword
+IniKeyDenylist=rsa.privateexp
+IniKeyDenylist=rsa.modulus
+IniKeyDenylist=rsa.publicexp
+IniKeyDenylist=aes.key
+IniKeyDenylist=SigningPublicExponent
+IniKeyDenylist=SigningModulus
+IniKeyDenylist=SigningPrivateExponent
+IniKeyDenylist=EncryptionKey
+IniKeyDenylist=DevCenterUsername
+IniKeyDenylist=DevCenterPassword
+IniKeyDenylist=IOSTeamID
+IniKeyDenylist=SigningCertificate
+IniKeyDenylist=MobileProvision
+IniKeyDenylist=IniKeyBlacklist
+IniKeyDenylist=IniSectionDenylist
-IniSectionDenylist=HordeStorageServers
-IniSectionDenylist=StorageServers
+IniSectionDenylist=StorageServers
+IniSectionDenylist=HordeStorageServers
+MapsToCook=(FilePath="/Game/Maps/Lobby")
+MapsToCook=(FilePath="/Game/Maps/GameStartupMap")
+MapsToCook=(FilePath="/Game/Maps/BlasterMap")
+MapsToCook=(FilePath="/Game/Maps/TeamsMap")
+MapsToCook=(FilePath="/Game/Maps/CaptureTheFlagMap")


```

`Config/DefaultInput.ini`:

```ini
[/Script/Engine.InputSettings]
-AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
+AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Touch",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
bAltEnterTogglesFullscreen=True
bF11TogglesFullscreen=True
bUseMouseForTouch=False
bEnableMouseSmoothing=True
bEnableFOVScaling=True
bCaptureMouseOnLaunch=True
bEnableLegacyInputScales=True
bEnableMotionControls=True
bFilterInputByPlatformUser=False
bEnableInputDeviceSubsystem=True
bShouldFlushPressedKeysOnViewportFocusLost=True
bEnableDynamicComponentInputBinding=True
bAlwaysShowTouchInterface=False
bShowConsoleOnFourFingerTap=True
bEnableGestureRecognizer=False
bUseAutocorrect=False
DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
DefaultViewportMouseLockMode=LockOnCapture
FOVScale=0.011110
DoubleClickTime=0.200000
+ActionMappings=(ActionName="Jump",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=SpaceBar)
+ActionMappings=(ActionName="Equip",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=E)
+ActionMappings=(ActionName="Crouch",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftControl)
+ActionMappings=(ActionName="Crouch",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=RightControl)
+ActionMappings=(ActionName="Aim",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=RightMouseButton)
+ActionMappings=(ActionName="Fire",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftMouseButton)
+ActionMappings=(ActionName="Reload",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=R)
+ActionMappings=(ActionName="ThrowGrenade",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=T)
+ActionMappings=(ActionName="Quit",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Escape)
+ActionMappings=(ActionName="Quit",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Q)
+AxisMappings=(AxisName="MoveForward",Scale=1.000000,Key=W)
+AxisMappings=(AxisName="MoveForward",Scale=-1.000000,Key=S)
+AxisMappings=(AxisName="MoveRight",Scale=1.000000,Key=D)
+AxisMappings=(AxisName="MoveRight",Scale=-1.000000,Key=A)
+AxisMappings=(AxisName="Turn",Scale=1.000000,Key=MouseX)
+AxisMappings=(AxisName="LookUp",Scale=-1.000000,Key=MouseY)
DefaultPlayerInputClass=/Script/EnhancedInput.EnhancedPlayerInput
DefaultInputComponentClass=/Script/EnhancedInput.EnhancedInputComponent
DefaultTouchInterface=/Engine/MobileResources/HUD/DefaultVirtualJoysticks.DefaultVirtualJoysticks
-ConsoleKeys=Tilde
+ConsoleKeys=Tilde


```

`Config/HoloLens/HoloLensEngine.ini`:

```ini


[/Script/HoloLensPlatformEditor.HoloLensTargetSettings]
bBuildForEmulation=False
bBuildForDevice=True
bUseNameForLogo=True
bBuildForRetailWindowsStore=False
bAutoIncrementVersion=False
bShouldCreateAppInstaller=False
AppInstallerInstallationURL=
HoursBetweenUpdateChecks=0
bEnablePIXProfiling=False
TileBackgroundColor=(B=64,G=0,R=0,A=255)
SplashScreenBackgroundColor=(B=64,G=0,R=0,A=255)
+PerCultureResources=(CultureId="",Strings=(PackageDisplayName="",PublisherDisplayName="",PackageDescription="",ApplicationDisplayName="",ApplicationDescription=""),Images=())
TargetDeviceFamily=Windows.Holographic
MinimumPlatformVersion=
MaximumPlatformVersionTested=10.0.18362.0
MaxTrianglesPerCubicMeter=500.000000
SpatialMeshingVolumeSize=20.000000
CompilerVersion=Default
Windows10SDKVersion=10.0.18362.0
+CapabilityList=internetClientServer
+CapabilityList=privateNetworkClientServer
+Uap2CapabilityList=spatialPerception
bSetDefaultCapabilities=False
SpatializationPlugin=
ReverbPlugin=
OcclusionPlugin=
SoundCueCookQualityIndex=-1


```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`Plugins/MultiplayerSessions/MultiplayerSessions.uplugin`:

```uplugin
{
	"FileVersion": 3,
	"Version": 1,
	"VersionName": "1.0",
	"FriendlyName": "MultiplayerSessions",
	"Description": "A plugin for handling online multiplayer sessions",
	"Category": "Other",
	"CreatedBy": "Stephen Ulibarri",
	"CreatedByURL": "",
	"DocsURL": "",
	"MarketplaceURL": "",
	"SupportURL": "",
	"CanContainContent": true,
	"IsBetaVersion": false,
	"IsExperimentalVersion": false,
	"Installed": false,
	"Modules": [
		{
			"Name": "MultiplayerSessions",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		}
	],
	"Plugins": [
		{
			"Name": "OnlineSubsystem",
			"Enabled": true
		},
		{
			"Name": "OnlineSubsystemSteam",
			"Enabled": true
		}
	]
}
```

`Plugins/MultiplayerSessions/Source/MultiplayerSessions/MultiplayerSessions.Build.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class MultiplayerSessions : ModuleRules
{
	public MultiplayerSessions(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;
		
		PublicIncludePaths.AddRange(
			new string[] {
				// ... add public include paths required here ...
			}
			);
				
		
		PrivateIncludePaths.AddRange(
			new string[] {
				// ... add other private include paths required here ...
			}
			);
			
		
		PublicDependencyModuleNames.AddRange(
			new string[]
			{
				"Core",
				"OnlineSubsystem",
				"OnlineSubsystemSteam",
				"UMG",
				"Slate",
				"SlateCore"
				// ... add other public dependencies that you statically link with here ...
			}
			);
			
		
		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore",
				// ... add private dependencies that you statically link with here ...	
			}
			);
		
		
		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
				// ... add any modules that your module loads dynamically here ...
			}
			);
	}
}

```

`Plugins/MultiplayerSessions/Source/MultiplayerSessions/Private/Menu.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Menu.h"
#include "Components/Button.h"
#include "MultiplayerSessionsSubsystem.h"
#include "OnlineSessionSettings.h"
#include "OnlineSubsystem.h"	// 从 5.2 版本开始， OnlineSessionSettings.h 的包含已被弃用
// #include "Online/OnlineSessionNames.h"

void UMenu::MenuSetup(int32 NumberOfPublicConnections, FString TypeOfMatch, FString LobbyPath)
{
	PathToLobby = FString::Printf(TEXT("%s?listen"), *LobbyPath);	// 设置路径
	NumPublicConnections = NumberOfPublicConnections;	// 设置公共连接数
	MatchType = TypeOfMatch;	// 设置比赛类型
	AddToViewport();
	SetVisibility(ESlateVisibility::Visible);
	bIsFocusable = true;

	UWorld* World = GetWorld();
	if (World)
	{
		APlayerController* PlayerController = World->GetFirstPlayerController();
		if (PlayerController)
		{
			FInputModeUIOnly InputModeData;
			InputModeData.SetWidgetToFocus(TakeWidget());
			InputModeData.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
			PlayerController->SetInputMode(InputModeData);
			PlayerController->SetShowMouseCursor(true);
		}
	}

	UGameInstance* GameInstance = GetGameInstance();
	if (GameInstance)
	{
		MultiplayerSessionsSubsystem = GameInstance->GetSubsystem<UMultiplayerSessionsSubsystem>();
	}

	if (MultiplayerSessionsSubsystem)
	{
		// 给多人游戏会话子系统添加委托
		MultiplayerSessionsSubsystem->MultiplayerOnCreateSessionComplete.AddDynamic(this, &ThisClass::OnCreateSession);		// 添加委托,创建会话完成
		MultiplayerSessionsSubsystem->MultiplayerOnFindSessionsComplete.AddUObject(this, &ThisClass::OnFindSessions);		// 添加委托,查找会话完成
		MultiplayerSessionsSubsystem->MultiplayerOnJoinSessionComplete.AddUObject(this, &ThisClass::OnJoinSession);		// 添加委托,加入会话完成
		MultiplayerSessionsSubsystem->MultiplayerOnDestroySessionComplete.AddDynamic(this, &ThisClass::OnDestroySession);	// 添加委托,销毁会话完成
		MultiplayerSessionsSubsystem->MultiplayerOnStartSessionComplete.AddDynamic(this, &ThisClass::OnStartSession);		// 添加委托,开始会话完成
	}
}

bool UMenu::Initialize()
{
	if (!Super::Initialize())
	{
		return false;
	}

	if (HostButton)
	{
		HostButton->OnClicked.AddDynamic(this, &ThisClass::HostButtonClicked);
	}
	if (JoinButton)
	{
		JoinButton->OnClicked.AddDynamic(this, &ThisClass::JoinButtonClicked);
	}

	return true;
}

void UMenu::NativeDestruct()
{
	MenuTearDown();
	Super::NativeDestruct();
}

// UE5.1之后该方法被弃用，改为使用NativeDestruct方法代替
//void UMenu::OnLevelRemovedFromWorld(ULevel* InLevel, UWorld* InWorld)
//{
//	MenuTearDown();
//	Super::OnLevelRemovedFromWorld(InLevel, InWorld);
//}

void UMenu::OnCreateSession(bool bWasSuccessful)
{
	if (bWasSuccessful)
	{
		UWorld* World = GetWorld();
		if (World)
		{
			World->ServerTravel(PathToLobby);
		}
	}
	else
	{
		if (GEngine)
		{
			GEngine->AddOnScreenDebugMessage(
				-1,
				15.f,
				FColor::Red,
				FString(TEXT("Failed to create session!"))
			);
		}
		HostButton->SetIsEnabled(true);
	}
}

void UMenu::OnFindSessions(const TArray<FOnlineSessionSearchResult>& SessionResults, bool bWasSuccessful)
{
	if (MultiplayerSessionsSubsystem == nullptr)
	{
		return;
	}

	for (auto Result : SessionResults)
	{
		FString SettingsValue;
		Result.Session.SessionSettings.Get(FName("MatchType"), SettingsValue);
		if (SettingsValue == MatchType)
		{
			// 如果找到了匹配的会话，就加入会话
			MultiplayerSessionsSubsystem->JoinSession(Result);
			return;
		}
	}
	if (!bWasSuccessful || SessionResults.Num() == 0)
	{
		JoinButton->SetIsEnabled(true);
	}
}

void UMenu::OnJoinSession(EOnJoinSessionCompleteResult::Type Result)
{
	IOnlineSubsystem* Subsystem = IOnlineSubsystem::Get();
	if (Subsystem)
	{
		IOnlineSessionPtr SessionInterface = Subsystem->GetSessionInterface();
		if (SessionInterface.IsValid())
		{
			FString Address;
			SessionInterface->GetResolvedConnectString(NAME_GameSession, Address);

			if (APlayerController* PlayerController = GetGameInstance()->GetFirstLocalPlayerController())
			{
				PlayerController->ClientTravel(Address, ETravelType::TRAVEL_Absolute);
			}
		}
	}
}

void UMenu::OnDestroySession(bool bWasSuccessful)
{
}

void UMenu::OnStartSession(bool bWasSuccessful)
{
}

void UMenu::HostButtonClicked()
{
	HostButton->SetIsEnabled(false);
	if (MultiplayerSessionsSubsystem)
	{
		MultiplayerSessionsSubsystem->CreateSession(NumPublicConnections, MatchType);
	}
}

void UMenu::JoinButtonClicked()
{
	JoinButton->SetIsEnabled(false);
	if (MultiplayerSessionsSubsystem)
	{
		MultiplayerSessionsSubsystem->FindSessions(10000);
	}
}

void UMenu::MenuTearDown()
{
	RemoveFromParent();
	UWorld* World = GetWorld();
	if (World)
	{
		if (APlayerController* PlayerController = World->GetFirstPlayerController())		// 获取第一个玩家控制器
		{
			const FInputModeGameOnly InputModeData;
			PlayerController->SetInputMode(InputModeData);
			PlayerController->SetShowMouseCursor(false);
		}
	}
}

```

`Plugins/MultiplayerSessions/Source/MultiplayerSessions/Private/MultiplayerSessions.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "MultiplayerSessions.h"

#define LOCTEXT_NAMESPACE "FMultiplayerSessionsModule"

void FMultiplayerSessionsModule::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
}

void FMultiplayerSessionsModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}

#undef LOCTEXT_NAMESPACE
	
IMPLEMENT_MODULE(FMultiplayerSessionsModule, MultiplayerSessions)
```

`Plugins/MultiplayerSessions/Source/MultiplayerSessions/Private/MultiplayerSessionsSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MultiplayerSessionsSubsystem.h"
#include "OnlineSubsystem.h"
#include "OnlineSessionSettings.h"
#include "Online/OnlineSessionNames.h"

UMultiplayerSessionsSubsystem::UMultiplayerSessionsSubsystem():
	CreateSessionCompleteDelegate(FOnCreateSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnCreateSessionComplete)),
	FindSessionsCompleteDelegate(FOnFindSessionsCompleteDelegate::CreateUObject(this, &ThisClass::OnFindSessionsComplete)),
	JoinSessionCompleteDelegate(FOnJoinSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnJoinSessionComplete)),
	DestroySessionCompleteDelegate(FOnDestroySessionCompleteDelegate::CreateUObject(this, &ThisClass::OnDestroySessionComplete)),
	StartSessionCompleteDelegate(FOnStartSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnStartSessionComplete))
{
	IOnlineSubsystem* Subsystem = IOnlineSubsystem::Get();
	if (Subsystem)
	{
		SessionInterface = Subsystem->GetSessionInterface();
	}
}

void UMultiplayerSessionsSubsystem::CreateSession(int32 NumPublicConnections, FString MatchType)
{
	DesiredNumPublicConnections = NumPublicConnections;
	DesiredMatchType = MatchType;

	if (!SessionInterface.IsValid())
	{
		return;
	}

	auto ExistingSession = SessionInterface->GetNamedSession(NAME_GameSession);
	if (ExistingSession != nullptr)
	{
		bCreateSessionOnDestroy = true;
		LastNumPublicConnections = NumPublicConnections;
		LastMatchType = MatchType;

		DestroySession();
	}

	// Store the delegate in a FDelegateHandle so we can later remove it from the delegate list
	CreateSessionCompleteDelegateHandle = SessionInterface->AddOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegate);

	LastSessionSettings = MakeShareable(new FOnlineSessionSettings());
	LastSessionSettings->bIsLANMatch = IOnlineSubsystem::Get()->GetSubsystemName() == "NULL" ? true : false;
	LastSessionSettings->NumPublicConnections = NumPublicConnections;
	LastSessionSettings->bAllowJoinInProgress = true;
	LastSessionSettings->bAllowJoinViaPresence = true;
	LastSessionSettings->bShouldAdvertise = true;
	LastSessionSettings->bUsesPresence = true;
	LastSessionSettings->Set(FName("MatchType"), MatchType, EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);
	LastSessionSettings->BuildUniqueId = 1;
	LastSessionSettings->bUseLobbiesIfAvailable = true;

	const ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();
	if (!SessionInterface->CreateSession(*LocalPlayer->GetPreferredUniqueNetId(), NAME_GameSession, *LastSessionSettings))
	{
		SessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle);

		// Broadcast our own custom delegate
		MultiplayerOnCreateSessionComplete.Broadcast(false);
	}
}

void UMultiplayerSessionsSubsystem::FindSessions(int32 MaxSearchResults)
{
	if (!SessionInterface.IsValid())
	{
		return;
	}

	FindSessionsCompleteDelegateHandle = SessionInterface->AddOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegate);

	LastSessionSearch = MakeShareable(new FOnlineSessionSearch());
	LastSessionSearch->MaxSearchResults = MaxSearchResults;
	LastSessionSearch->bIsLanQuery = IOnlineSubsystem::Get()->GetSubsystemName() == "NULL" ? true : false;
	LastSessionSearch->QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals);

	const ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();
	if (!SessionInterface->FindSessions(*LocalPlayer->GetPreferredUniqueNetId(), LastSessionSearch.ToSharedRef()))
	{
		SessionInterface->ClearOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle);

		MultiplayerOnFindSessionsComplete.Broadcast(TArray<FOnlineSessionSearchResult>(), false);
	}
}

void UMultiplayerSessionsSubsystem::JoinSession(const FOnlineSessionSearchResult& SessionResult)
{
	if (!SessionInterface.IsValid())
	{
		MultiplayerOnJoinSessionComplete.Broadcast(EOnJoinSessionCompleteResult::UnknownError);
		return;
	}

	JoinSessionCompleteDelegateHandle = SessionInterface->AddOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegate);

	const ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();
	if (!SessionInterface->JoinSession(*LocalPlayer->GetPreferredUniqueNetId(), NAME_GameSession, SessionResult))
	{
		SessionInterface->ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle);

		MultiplayerOnJoinSessionComplete.Broadcast(EOnJoinSessionCompleteResult::UnknownError);
	}
}

void UMultiplayerSessionsSubsystem::DestroySession()
{
	if (!SessionInterface.IsValid())
	{
		MultiplayerOnDestroySessionComplete.Broadcast(false);
		return;
	}

	DestroySessionCompleteDelegateHandle = SessionInterface->AddOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegate);

	if (!SessionInterface->DestroySession(NAME_GameSession))
	{
		SessionInterface->ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle);
		MultiplayerOnDestroySessionComplete.Broadcast(false);
	}
}

void UMultiplayerSessionsSubsystem::StartSession()
{
}

void UMultiplayerSessionsSubsystem::OnCreateSessionComplete(FName SessionName, bool bWasSuccessful)
{
	if (SessionInterface)
	{
		SessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle);
	}

	MultiplayerOnCreateSessionComplete.Broadcast(bWasSuccessful);
}

void UMultiplayerSessionsSubsystem::OnFindSessionsComplete(bool bWasSuccessful)
{
	if (SessionInterface)
	{
		SessionInterface->ClearOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle);
	}

	if (LastSessionSearch->SearchResults.Num() <= 0)
	{
		MultiplayerOnFindSessionsComplete.Broadcast(TArray<FOnlineSessionSearchResult>(), false);
		return;
	}

	MultiplayerOnFindSessionsComplete.Broadcast(LastSessionSearch->SearchResults, bWasSuccessful);
}

void UMultiplayerSessionsSubsystem::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result)
{
	if (SessionInterface)
	{
		SessionInterface->ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle);
	}

	MultiplayerOnJoinSessionComplete.Broadcast(Result);
}

void UMultiplayerSessionsSubsystem::OnDestroySessionComplete(FName SessionName, bool bWasSuccessful)
{
	if (SessionInterface)
	{
		SessionInterface->ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle);
	}
	if (bWasSuccessful && bCreateSessionOnDestroy)
	{
		bCreateSessionOnDestroy = false;
		CreateSession(LastNumPublicConnections, LastMatchType);
	}
	MultiplayerOnDestroySessionComplete.Broadcast(bWasSuccessful);
}

void UMultiplayerSessionsSubsystem::OnStartSessionComplete(FName SessionName, bool bWasSuccessful)
{
}

```

`Plugins/MultiplayerSessions/Source/MultiplayerSessions/Public/Menu.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "Interfaces/OnlineSessionInterface.h"
#include "Menu.generated.h"

/**
 * 
 */
UCLASS()
class MULTIPLAYERSESSIONS_API UMenu : public UUserWidget
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	void MenuSetup(int32 NumberOfPublicConnections = 4, FString TypeOfMatch = FString(TEXT("FreeForAll")), FString LobbyPath = FString(TEXT("/Game/Maps/Lobby")));

protected:

	virtual bool Initialize() override;
	// virtual void NativeDestruct(ULevel* InLevel, UWorld* InWorld) override;	// UE5.1之后该方法被弃用，使用下面的方法代替
	virtual void NativeDestruct() override;

	//
	// Callbacks for the custom delegates on the MultiplayerSessionsSubsystem
	//
	UFUNCTION()
	void OnCreateSession(bool bWasSuccessful);
	void OnFindSessions(const TArray<FOnlineSessionSearchResult>& SessionResults, bool bWasSuccessful);
	void OnJoinSession(EOnJoinSessionCompleteResult::Type Result);
	UFUNCTION()
	void OnDestroySession(bool bWasSuccessful);
	UFUNCTION()
	void OnStartSession(bool bWasSuccessful);

private:

	UPROPERTY(meta = (BindWidget))
	class UButton* HostButton;

	UPROPERTY(meta = (BindWidget))
	UButton* JoinButton;

	UFUNCTION()
	void HostButtonClicked();

	UFUNCTION()
	void JoinButtonClicked();

	void MenuTearDown();

	// The subsystem designed to handle all online session functionality
	class UMultiplayerSessionsSubsystem* MultiplayerSessionsSubsystem;

	UPROPERTY(BlueprintReadWrite, meta=(AllowPrivateAccess = "true"))
	int32 NumPublicConnections = 4;

	UPROPERTY(BlueprintReadWrite, meta=(AllowPrivateAccess = "true"))
	FString MatchType{TEXT("FreeForAll")};
	FString PathToLobby{TEXT("")};
};

```

`Plugins/MultiplayerSessions/Source/MultiplayerSessions/Public/MultiplayerSessions.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FMultiplayerSessionsModule : public IModuleInterface
{
public:

	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

```

`Plugins/MultiplayerSessions/Source/MultiplayerSessions/Public/MultiplayerSessionsSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "Interfaces/OnlineSessionInterface.h"

#include "MultiplayerSessionsSubsystem.generated.h"

//
// Delcaring our own custom delegates for the Menu class to bind callbacks to
//
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnCreateSessionComplete, bool, bWasSuccessful);
DECLARE_MULTICAST_DELEGATE_TwoParams(FMultiplayerOnFindSessionsComplete, const TArray<FOnlineSessionSearchResult>& SessionResults, bool bWasSuccessful);
DECLARE_MULTICAST_DELEGATE_OneParam(FMultiplayerOnJoinSessionComplete, EOnJoinSessionCompleteResult::Type Result);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnDestroySessionComplete, bool, bWasSuccessful);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnStartSessionComplete, bool, bWasSuccessful);

/**
 * 
 */
UCLASS()
class MULTIPLAYERSESSIONS_API UMultiplayerSessionsSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()
public:
	UMultiplayerSessionsSubsystem();

	//
	// To handle session functionality. The Menu class will call these
	//
	void CreateSession(int32 NumPublicConnections, FString MatchType);
	void FindSessions(int32 MaxSearchResults);
	void JoinSession(const FOnlineSessionSearchResult& SessionResult);
	void DestroySession();
	void StartSession();

	//
	// Our own custom delegates for the Menu class to bind callbacks to
	//
	FMultiplayerOnCreateSessionComplete MultiplayerOnCreateSessionComplete;
	FMultiplayerOnFindSessionsComplete MultiplayerOnFindSessionsComplete;
	FMultiplayerOnJoinSessionComplete MultiplayerOnJoinSessionComplete;
	FMultiplayerOnDestroySessionComplete MultiplayerOnDestroySessionComplete;
	FMultiplayerOnStartSessionComplete MultiplayerOnStartSessionComplete;

	FORCEINLINE int32 GetDesiredNumPublicConnections() const { return DesiredNumPublicConnections; }
	FORCEINLINE FString GetDesiredMatchType() const { return DesiredMatchType; }

protected:

	//
	// Internal callbacks for the delegates we'll add to the Online Session Interface delegate list.
	// Thise don't need to be called outside this class.
	//
	void OnCreateSessionComplete(FName SessionName, bool bWasSuccessful);
	void OnFindSessionsComplete(bool bWasSuccessful);
	void OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result);
	void OnDestroySessionComplete(FName SessionName, bool bWasSuccessful);
	void OnStartSessionComplete(FName SessionName, bool bWasSuccessful);

private:
	IOnlineSessionPtr SessionInterface;
	TSharedPtr<FOnlineSessionSettings> LastSessionSettings;
	TSharedPtr<FOnlineSessionSearch> LastSessionSearch;

	//
	// To add to the Online Session Interface delegate list.
	// We'll bind our MultiplayerSessionsSubsystem internal callbacks to these.
	//
	FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate;
	FDelegateHandle CreateSessionCompleteDelegateHandle;
	FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate;
	FDelegateHandle FindSessionsCompleteDelegateHandle;
	FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate;
	FDelegateHandle JoinSessionCompleteDelegateHandle;
	FOnDestroySessionCompleteDelegate DestroySessionCompleteDelegate;
	FDelegateHandle DestroySessionCompleteDelegateHandle;
	FOnStartSessionCompleteDelegate StartSessionCompleteDelegate;
	FDelegateHandle StartSessionCompleteDelegateHandle;

	bool bCreateSessionOnDestroy{ false };
	int32 LastNumPublicConnections;
	FString LastMatchType;

	int32 DesiredNumPublicConnections{};	// 我们想要的公共连接数
	FString DesiredMatchType{};	// 我们想要的比赛类型
};

```

`README.md`:

```md
# MultiplayerBlasterGame

[![License: Apache 2.0](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://github.com/invi1998/MultiplayerBlasterGame/blob/main/LICENSE)

[![Bilibili](https://img.shields.io/badge/Bilibili-invi1998-brightgreen?logo=bilibili&logoColor=blue)](https://www.bilibili.com/video/BV15AYyexED6)

[![JetBrains Logo](https://resources.jetbrains.com/storage/products/company/brand/logos/jetbrains.png)](https://jb.gg/OpenSourceSupport)



---

<img src="data:image/svg+xml,%3Csvg%20width%3D%22300%22%20height%3D%22300%22%20viewBox%3D%220%200%20300%20300%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22grad1%22%20x1%3D%220%25%22%20y1%3D%220%25%22%20x2%3D%22100%25%22%20y2%3D%220%25%22%3E%3Cstop%20offset%3D%220%25%22%20style%3D%22stop-color%3A%231a237e%3Bstop-opacity%3A1%22%20%2F%3E%3Cstop%20offset%3D%22100%25%22%20style%3D%22stop-color%3A%2300c853%3Bstop-opacity%3A1%22%20%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Cpath%20d%3D%22M150%2050%20C%20200%2050%2C%20200%20150%2C%20150%20150%20S%20100%2050%2C%20150%2050%20Z%22%20fill%3D%22url(%23grad1)%22%20stroke%3D%22black%22%20stroke-width%3D%222%22%20%2F%3E%3Ctext%20x%3D%22150%22%20y%3D%22150%22%20font-family%3D%22Arial%2C%20sans-serif%22%20font-size%3D%2260%22%20fill%3D%22white%22%20text-anchor%3D%22middle%22%20dominant-baseline%3D%22central%22%3Einvi%3C%2Ftext%3E%3Ctext%20x%3D%22150%22%20y%3D%22250%22%20font-family%3D%22Arial%2C%20sans-serif%22%20font-size%3D%2220%22%20fill%3D%22white%22%20text-anchor%3D%22middle%22%20dominant-baseline%3D%22central%22%3Einvi1998%3C%2Ftext%3E%3C%2Fsvg%3E" alt="invi Logo" />

## 介绍

Multiplayer Blaster Game 是一个多人在线射击游戏，支持多个玩家在同一地图上进行实时对战。该游戏基于steam联机网络和UE5引擎开发，旨在提供流畅的游戏体验和个人UE开发学习。

## 特性

- **多人在线对战**：支持多玩家同时在线对战。
- **实时同步**：游戏状态实时同步，保证公平竞技。
- **多种地图**：提供多种不同的地图供玩家选择。
- **简单易用**：用户界面友好，易于上手。

### 克隆仓库

```bash
git clone https://github.com/invi1998/MultiplayerBlasterGame.git
cd MultiplayerBlasterGame
```

**UE版本**：UE5.3 (如您使用的是其他更高版本，编译过程可能会遇到部分API失效问题，自行查阅代码提示结合官方文档解决)

## 使用

### 游戏玩法

1. 进入游戏后，选择一个角色。
2. 加入一个房间或创建一个新的房间。
3. 开始对战，击败其他玩家。

### 控制键

- **移动**：WASD 键
- **蹲伏**：ctrl
- **跳跃**：空格键
- **射击**：鼠标左键
- **瞄准/开倍镜**：鼠标右键
- **切换武器**：E
- **拾取武器**：E
- **投掷手雷**：T




```

`Source/Blaster.Target.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;	// UnrealBuildTool is a set of scripts used to build Unreal Engine 4 (UE4) across multiple platforms.
using System.Collections.Generic;	// System.Collections.Generic contains interfaces and classes that define generic collections, which allow users to create strongly typed collections that provide better type safety and performance than non-generic strongly typed collections.

public class BlasterTarget : TargetRules
{
	public BlasterTarget( TargetInfo Target) : base(Target)     // TargetInfo是一个包含了目标平台，比如平台名称、平台架构、编译器等等信息的结构体
    {
		Type = TargetType.Game;		// TargetType是一个枚举类型，包含了Game、Client、Server、Editor、Program、Unspecified等类型
		DefaultBuildSettings = BuildSettingsVersion.V2;		// BuildSettingsVersion是一个枚举类型，包含了V1、V2、V3等类型
		ExtraModuleNames.AddRange( new string[] { "Blaster" } );	// ExtraModuleNames是一个字符串数组，用于指定需要编译的模块名称
	}
}

```

`Source/Blaster/Blaster.Build.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class Blaster : ModuleRules
{
	public Blaster(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;	// PCHUsageMode是一个枚举类型，包含了UseExplicitOrSharedPCHs、UseSharedPCHs、Default等类型
	
		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "Niagara", "MultiplayerSessions", "OnlineSubsystem", "OnlineSubsystemSteam" });	// PublicDependencyModuleNames是一个字符串数组，用于指定需要引用的模块名称 这里引用了Core、CoreUObject、Engine、InputCore、Niagara模块

		PrivateDependencyModuleNames.AddRange(new string[] {  });

		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
		
		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");

		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}

```

`Source/Blaster/Blaster.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "Blaster.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, Blaster, "Blaster" );	// Blaster 项目名称

```

`Source/Blaster/Blaster.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"

#define ECC_SkeletalMesh ECollisionChannel::ECC_GameTraceChannel1	// 骨骼网格 ECC_GameTraceChannel1 用于射线检测 1 代表的是 ECC_GameTraceChannel1 
#define ECC_HitBox ECollisionChannel::ECC_GameTraceChannel2		// 命中框 ECC_GameTraceChannel2 用于射线检测 2 代表的是 ECC_GameTraceChannel2

```

`Source/Blaster/BlasterComponents/BuffComponent.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "BuffComponent.h"

#include "Blaster/Character/BlasterCharacter.h"
#include "GameFramework/CharacterMovementComponent.h"

// Sets default values for this component's properties
UBuffComponent::UBuffComponent()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.
	PrimaryComponentTick.bCanEverTick = true;

	// ...
}


// Called when the game starts
void UBuffComponent::BeginPlay()
{
	Super::BeginPlay();

	// ...

}

// Called every frame
void UBuffComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	// 每帧调用HealRampUp()方法
	HealRampUp(DeltaTime);

	// 每帧调用ShieldRampUp()方法
	ShieldRampUp(DeltaTime);

}

void UBuffComponent::AddHealth(float HealthAmount, float HealingTime)
{
	bHealing = true;		// 设置正在治疗为true
	HealingRate = HealthAmount / HealingTime;		// 计算治疗速率
	AmountToHeal = HealthAmount;		// 计算治疗量，一旦治疗量达到了HealthAmount，就会停止治疗

	if (Character)
	{
		Character->SetAfterHealHealth(FMath::Clamp(Character->GetHealth() + AmountToHeal, 0.0f, Character->GetMaxHealth()));		// 设置治疗后的血量
	}
	
}

void UBuffComponent::AddSpeed(float BuffBaseSpeed, float BuffCrouchSpeed, float BuffTime)
{
	if (Character == nullptr) return;		// 如果Character为空，就返回

	if (SpeedBuffTimerHandle.IsValid())		// 如果计时器有效
	{
		Character->GetWorldTimerManager().ClearTimer(SpeedBuffTimerHandle);		// 清除计时器
	}
	Character->GetWorldTimerManager().SetTimer(SpeedBuffTimerHandle, this, &UBuffComponent::ResetSpeed, BuffTime);		// 设置计时器

	if (Character->GetCharacterMovement())
	{
		Character->GetCharacterMovement()->MaxWalkSpeed = BuffBaseSpeed;		// 设置最大行走速度
		Character->GetCharacterMovement()->MaxWalkSpeedCrouched = BuffCrouchSpeed;		// 设置最大蹲下速度
	}

	MulticastSpeedBuff(BuffBaseSpeed, BuffCrouchSpeed, BuffTime);		// 多播速度buff
}

void UBuffComponent::AddJump(float JumpZVelocity, float JumpTime)
{
	if (Character == nullptr) return;		// 如果Character为空，就返回

	if (JumpBuffTimerHandle.IsValid())
	{
		Character->GetWorldTimerManager().ClearTimer(JumpBuffTimerHandle);		// 清除计时器
	}

	Character->GetWorldTimerManager().SetTimer(JumpBuffTimerHandle, this, &UBuffComponent::RestJump, JumpTime);		// 设置计时器

	if (Character->GetCharacterMovement())
	{
		Character->GetCharacterMovement()->JumpZVelocity = JumpZVelocity;		// 设置跳跃速度
	}

	MulticastJumpBuff(JumpZVelocity, JumpTime);		// 多播跳跃buff
}

void UBuffComponent::SetInitialSpeed(float BaseSpeed, float CrouchSpeed)
{
	InitialBaseSpeed = BaseSpeed;		// 设置初始基础速度
	InitialCrouchSpeed = CrouchSpeed;	// 设置初始蹲下速度
}

void UBuffComponent::SetInitialJumpZVelocity(float JumpZVelocity)
{
	InitialJumpZVelocity = JumpZVelocity;		// 设置初始跳跃速度
}

void UBuffComponent::ReplenishShield(float ShieldReplenishAmount, float ShieldReplenishTime)
{
	bShieldReplenishing = true;		// 设置正在补充护盾为true
	ShieldReplenishRate = ShieldReplenishAmount / ShieldReplenishTime;		// 计算护盾补充速率
	ShieldAmountToReplenish += ShieldReplenishAmount;		// 计算护盾补充量
}

void UBuffComponent::AddBacktracking(float BacktrackingTime, float BuffAliveTime, float BacktrackingCostTime)
{
	if (Character == nullptr) return;		// 如果Character为空，就返回

	if (BacktrackingTimerHandle.IsValid())		// 如果计时器有效
	{
		Character->GetWorldTimerManager().ClearTimer(BacktrackingTimerHandle);		// 清除计时器
	}
	Character->GetWorldTimerManager().SetTimer(BacktrackingTimerHandle, this, &UBuffComponent::ResetBacktracking, BuffAliveTime);		// 设置计时器

	Character->SetBacktrackingTime(BacktrackingTime, BacktrackingCostTime);		// 设置回溯时间
}

void UBuffComponent::HealRampUp(float DeltaTime)
{
	if (!bHealing || Character == nullptr || Character->IsElimmed()) return;		// 如果没有治疗或者Character为空，或者Character已经被淘汰，就返回

	const float HealThisFrame = HealingRate * DeltaTime;		// 计算本帧治疗量
	
	Character->SetHealth(FMath::Clamp(Character->GetHealth() + HealThisFrame, 0.0f, Character->GetMaxHealth()));		// 设置血量，使用FMath::Clamp()方法来限制血量在0到最大血量之间
	
	AmountToHeal -= HealThisFrame;		// 治疗量减去本帧治疗量

	if (AmountToHeal <= 0.0f || Character->GetHealth() >= Character->GetMaxHealth())		// 如果治疗量小于等于0 或者 血量大于等于最大血量
	{
		bHealing = false;		// 设置正在治疗为false
		HealingRate = 0.0f;		// 设置治疗速率为0
		AmountToHeal = 0.0f;		// 设置治疗量为0

		Character->SetAfterHealHealth(0.f);		// 设置治疗后的血量
	}

	Character->UpdateHUDHealth();		// 更新血量UI
	Character->UpdateHUDHealthNative();		// 更新伤害UI
}

void UBuffComponent::ShieldRampUp(float DeltaTime)
{
	if (!bShieldReplenishing || Character == nullptr || Character->IsElimmed()) return;		// 如果没有补充护盾或者Character为空，或者Character已经被淘汰，就返回

	const float ShieldThisFrame = ShieldReplenishRate * DeltaTime;		// 计算本帧护盾补充量
	Character->SetShield(FMath::Clamp(Character->GetShield() + ShieldThisFrame, 0.0f, Character->GetMaxShield()));		// 设置护盾，使用FMath::Clamp()方法来限制护盾在0到最大护盾之间
	Character->UpdateHUDShield();		// 更新护盾UI
	ShieldAmountToReplenish -= ShieldThisFrame;		// 护盾补充量减去本帧护盾补充量

	if (ShieldAmountToReplenish <= 0.0f || Character->GetShield() >= Character->GetMaxShield())		// 如果护盾补充量小于等于0 或者 护盾大于等于最大护盾
	{
		bShieldReplenishing = false;		// 设置正在补充护盾为false
		ShieldReplenishRate = 0.0f;		// 设置护盾补充速率为0
		ShieldAmountToReplenish = 0.0f;		// 设置护盾补充量为0
	}
}

void UBuffComponent::BacktrackingRampUp(float DeltaTime)
{
	if (!bBacktracking || Character == nullptr || Character->IsElimmed()) return;		// 如果没有回溯或者Character为空，或者Character已经被淘汰，就返回

	const float BacktrackingTimeThisFrame = BacktrackingRate * DeltaTime;		// 计算本帧回溯的时间节点
}


void UBuffComponent::ResetSpeed()
{
	if (Character == nullptr || Character->GetCharacterMovement() == nullptr) return;		// 如果Character为空或者Character的CharacterMovement为空，就返回

	Character->GetCharacterMovement()->MaxWalkSpeed = InitialBaseSpeed;		// 设置最大行走速度
	Character->GetCharacterMovement()->MaxWalkSpeedCrouched = InitialCrouchSpeed;		// 设置最大蹲下速度

	MulticastSpeedBuff(InitialBaseSpeed, InitialCrouchSpeed, 0.0f);		// 多播速度buff
}

void UBuffComponent::MulticastSpeedBuff_Implementation(float BuffBaseSpeed, float BuffCrouchSpeed, float BuffTime)
{
	if (Character == nullptr || Character->GetCharacterMovement() == nullptr) return;		// 如果Character为空或者Character的CharacterMovement为空，就返回

	Character->GetCharacterMovement()->MaxWalkSpeed = BuffBaseSpeed;		// 设置最大行走速度
	Character->GetCharacterMovement()->MaxWalkSpeedCrouched = BuffCrouchSpeed;		// 设置最大蹲下速度
}

void UBuffComponent::RestJump()
{
	if (Character == nullptr || Character->GetCharacterMovement() == nullptr) return;		// 如果Character为空或者Character的CharacterMovement为空，就返回

	Character->GetCharacterMovement()->JumpZVelocity = InitialJumpZVelocity;		// 设置跳跃速度

	MulticastJumpBuff(InitialJumpZVelocity, 0.0f);		// 多播跳跃buff
}

void UBuffComponent::ResetBacktracking()
{
	if (Character == nullptr) return;		// 如果Character为空，就返回

	Character->SetBacktrackingTime(0.0f, 0.f);		// 设置回溯时间

	MulticastBacktracking(0.0f, 0.0f);		// 多播回溯buff
}

void UBuffComponent::MulticastJumpBuff_Implementation(float JumpZVelocity, float JumpTime)
{
	if (Character == nullptr || Character->GetCharacterMovement() == nullptr) return;		// 如果Character为空或者Character的CharacterMovement为空，就返回

	Character->GetCharacterMovement()->JumpZVelocity = JumpZVelocity;		// 设置跳跃速度
}

void UBuffComponent::MulticastBacktracking_Implementation(float BacktrackingTime, float BuffAliveTime)
{
	if (Character == nullptr) return;		// 如果Character为空，就返回

}


```

`Source/Blaster/BlasterComponents/BuffComponent.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blaster/Pickups/BacktrackingPickup.h"
#include "Blaster/Pickups/HealthPickup.h"
#include "Blaster/Pickups/ShieldPickup.h"
#include "Components/ActorComponent.h"
#include "BuffComponent.generated.h"


UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class BLASTER_API UBuffComponent : public UActorComponent
{
	GENERATED_BODY()

public:	
	// Sets default values for this component's properties
	UBuffComponent();

	friend class ABlasterCharacter;		// 允许ABlasterCharacter访问私有成员

	void AddHealth(float HealthAmount, float HealingTime);	// 增加血量 传入血量和治疗时间

	void AddSpeed(float BuffBaseSpeed, float BuffCrouchSpeed, float BuffTime);		// 增加速度 传入速度和持续时间

	void AddJump(float JumpZVelocity, float JumpTime);		// 增加跳跃速度 传入跳跃速度和持续时间

	void SetInitialSpeed(float BaseSpeed, float CrouchSpeed);		// 设置初始速度

	void SetInitialJumpZVelocity(float JumpZVelocity);		// 设置初始跳跃速度
	void ReplenishShield(float ShieldReplenishAmount, float ShieldReplenishTime);		// 增加护盾 传入护盾补充量和护盾补充时间
	void AddBacktracking(float BacktrackingTime, float BuffAliveTime, float BacktrackingCostTime);					// 增加回溯时间 传入回溯时间和buff存活时间, 回溯消耗时间

protected:
	// Called when the game starts
	virtual void BeginPlay() override;

	void HealRampUp(float DeltaTime);		// 治疗速率上升, 传入DeltaTime, 用于计算治疗速率

	void ShieldRampUp(float DeltaTime);		// 护盾速率上升, 传入DeltaTime, 用于计算护盾速率

	void BacktrackingRampUp(float DeltaTime);		// 回溯速率上升, 传入DeltaTime, 用于计算回溯速率

private:
	UPROPERTY()
	class ABlasterCharacter* Character;		// 指向ABlasterCharacter的指针

	/*
	 * 回血buff
	 */
	bool bHealing = false;		// 是否正在治疗
	float HealingRate = 0.0f;	// 治疗速率
	float AmountToHeal = 0.0f;	// 治疗量

	/*
	 * 护盾Buff
	 */
	bool bShieldReplenishing = false;			// 是否正在补充护盾
	float ShieldReplenishRate = 0.0f;			// 护盾补充速率
	float ShieldAmountToReplenish = 0.0f;		// 护盾补充量

	/*
	 * 速度buff
	 */
	FTimerHandle SpeedBuffTimerHandle;		// 速度buff计时器句柄
	void ResetSpeed();		// 重置速度
	float InitialBaseSpeed = 0.0f;		// 初始基础速度
	float InitialCrouchSpeed = 0.0f;	// 初始蹲下速度

	UFUNCTION(NetMulticast, Reliable)
	void MulticastSpeedBuff(float BuffBaseSpeed, float BuffCrouchSpeed, float BuffTime);		// 速度buff多播函数

	/*
	 * 跳跃buff
	 */
	FTimerHandle JumpBuffTimerHandle;		// 跳跃buff计时器句柄

	void RestJump();		// 重置跳跃
	float InitialJumpZVelocity = 0.0f;		// 初始跳跃速度

	UFUNCTION(NetMulticast, Reliable)
	void MulticastJumpBuff(float JumpZVelocity, float JumpTime);		// 跳跃buff多播函数

	/*
	 * 回溯buff
	 */
	FTimerHandle BacktrackingTimerHandle;		// 回溯buff计时器句柄
	void ResetBacktracking();		// 重置回溯

	bool bBacktracking = false;		// 是否正在回溯
	float BacktrackingRate = 0.0f;	// 回溯速率

	UFUNCTION(NetMulticast, Reliable)
	void MulticastBacktracking(float BacktrackingTime, float BuffAliveTime);		// 回溯buff多播函数


public:	
	// Called every frame
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;
};

```

`Source/Blaster/BlasterComponents/CombatComponent.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "CombatComponent.h"

#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/Weapon/Weapon.h"
#include "Components/SphereComponent.h"
#include "Engine/SkeletalMeshSocket.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Net/UnrealNetwork.h"
#include "Kismet/GameplayStatics.h"
#include "DrawDebugHelpers.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "Blaster/HUD/BlasterHUD.h"
#include "Camera/CameraComponent.h"
#include "TimerManager.h"
#include "Blaster/PlayerState/BlasterPlayerState.h"
#include "Sound/SoundCue.h"
#include "Blaster/Character/BlasterAnimInstance.h"
#include "Blaster/Weapon/Projectile.h"
#include "Blaster/Weapon/Shotgun.h"

// Sets default values for this component's properties
UCombatComponent::UCombatComponent()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.
	PrimaryComponentTick.bCanEverTick = true;

	// ...
	BaseWalkSpeed = 600.f;
	AimWalkSpeed = 450.f;
}

void UCombatComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	// 这些变量都是需要通过rpc网络复制到各个客户单进行同步的数据
	// 注册装备的武器,是否瞄准，携带的弹药数量
	DOREPLIFETIME(UCombatComponent, EquippedWeapon);	// 装备的武器
	DOREPLIFETIME(UCombatComponent, SecondaryWeapon);	// 次要武器
	DOREPLIFETIME(UCombatComponent, bAiming);	// 是否瞄准
	// 携带的弹药数量只对客户端来说是有重要意义，因为他和客户端是一对一的关系，只有一个客户端需要将这个值设置在HUD中显示
	// 所以这里可以使用适当的生命周期条件,并指定条件对象 COND_OwnerOnly
	// 这样，该变量就只会复制到拥有该弹药的客户端，而不会广播给所有客户端，谁拿到，复制给谁，就这样，这将会节省带宽提高性能
	DOREPLIFETIME_CONDITION(UCombatComponent, CarriedAmmo, COND_OwnerOnly);	// 携带的弹药数量
	DOREPLIFETIME(UCombatComponent, CombatState); // 战斗状态
	DOREPLIFETIME(UCombatComponent, GrenadeCount);	// 手榴弹数量
	DOREPLIFETIME(UCombatComponent, bHoldingFlag);	// 是否持有旗帜
}

void UCombatComponent::PickupAmmo(EWeaponType WeaponType, int32 Amount)
{
	if (Character == nullptr) return;

	if (CarriedAmmoMap.Contains(WeaponType))	// 确保携带的弹药数量中包含该类型的弹药
	{
		CarriedAmmoMap[WeaponType] = FMath::Clamp(CarriedAmmoMap[WeaponType] + Amount, 0, MaxCarriedAmmoMap[WeaponType]);	// 更新携带的弹药数量
		// CarriedAmmo = CarriedAmmoMap[WeaponType];	// 更新携带的弹药数量
		UpdateCarriedAmmo();	// 更新携带的弹药数量
	}

	// 同时，如果我们拾取了弹药，这时我们装备的武器正好是空的，而且也正好是我们拾取的弹药类型，那么我们就需要换弹
	if (EquippedWeapon && EquippedWeapon->IsEmpty() && EquippedWeapon->GetWeaponType() == WeaponType)
	{
		Reload();
	}
}

// Called when the game starts or when spawned
void UCombatComponent::BeginPlay()
{
	Super::BeginPlay();

	MaxCarriedAmmoMap.Emplace(EWeaponType::EWT_AssaultRifle, MaxARAmmo);	// 最大携带的突击步枪弹药数量
	MaxCarriedAmmoMap.Emplace(EWeaponType::EWT_RocketLauncher, MaxRocketAmmo);	// 最大携带的火箭弹药数量
	MaxCarriedAmmoMap.Emplace(EWeaponType::EWT_Pistol, MaxPistolAmmo);	// 最大携带的手枪子弹的数量
	MaxCarriedAmmoMap.Emplace(EWeaponType::EWT_SubmachineGun, MaxSMGAmmo);	// 最大携带的冲锋枪子弹的数量
	MaxCarriedAmmoMap.Emplace(EWeaponType::EWT_Shotgun, MaxShotgunAmmo);	// 最大携带的霰弹枪子弹的数量
	MaxCarriedAmmoMap.Emplace(EWeaponType::EWT_SniperRifle, MaxSniperAmmo);	// 最大携带的狙击枪子弹的数量
	MaxCarriedAmmoMap.Emplace(EWeaponType::EWT_GrenadeLauncher, MaxGrenadeLauncherAmmo);	// 最大携带的手榴弹的数量

	// ...
	if (Character)
	{
		Character->GetCharacterMovement()->MaxWalkSpeed = BaseWalkSpeed;

		if (Character->GetFollowCamera())
		{
			DefaultFOV = Character->GetFollowCamera()->FieldOfView;
			CurrentFOV = DefaultFOV;
		}

		if (Character->HasAuthority()) {
			InitializeCarriedAmmo();
		}
	}
}

// Called every frame
void UCombatComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	// ...
	if (Character && Character->IsLocallyControlled())
	{
		FHitResult HitResult;
		TraceUnderCrosshairs(HitResult);
		HitTarget = HitResult.ImpactPoint;

		SetHUDCrosshairs(DeltaTime);
		InterpFOV(DeltaTime);
	}
}

void UCombatComponent::FireButtonPressed(bool bPressed)
{
	// 战斗组件需要知道按下和抬起开火按钮的时间
	bFireButtonPressed = bPressed;

	if (bFireButtonPressed)
	{
		Fire();
	}
}

void UCombatComponent::ShotgunShellReload()
{
	if (Character && Character->HasAuthority())
	{
		UpdateShotgunAmmoValue();
	}
	
}

void UCombatComponent::JumpToShotgunEnd()
{
	// 跳转到霰弹枪装弹结束动画蒙太奇部分（ShotgunEnd）
	UAnimInstance* AnimInstance = Character->GetMesh()->GetAnimInstance();

	if (AnimInstance && Character->GetReloadMontage())
	{
		AnimInstance->Montage_JumpToSection(FName("ShotgunEnd"));
	}
}

void UCombatComponent::ThrowGrenadeFinished()
{
	CombatState = ECombatState::ECS_Unoccupied;
	AttachActorToRightHand(EquippedWeapon);
}

void UCombatComponent::LaunchGrenade()
{
	ShowAttachedGrenade(false);
	if (Character && Character->IsLocallyControlled())
	{
		ServerLaunchGrenade(HitTarget);
	}
	
}

void UCombatComponent::ServerLaunchGrenade_Implementation(const FVector_NetQuantize& Target)
{
	if (Character && GrenadeClass && Character->GetAttachedGrenade())
	{
		// 获取手榴弹组件的位置，然后记录该位置，用于后续在该位置生成一个手榴弹
		const FVector StartingLocation = Character->GetAttachedGrenade()->GetComponentLocation();

		FVector ToTarget = Target - StartingLocation;
		FActorSpawnParameters SpawnParams;
		SpawnParams.Owner = Character;
		SpawnParams.Instigator = Character;
		UWorld* World = GetWorld();
		if (World)
		{
			World->SpawnActor<AProjectile>(
				GrenadeClass,
				StartingLocation,
				ToTarget.Rotation(),
				SpawnParams);
		}
	}
}

void UCombatComponent::Fire()
{
	if (CanFire())
	{
		bCanFire = false;

		if (EquippedWeapon)
		{
			CrosshairShootingFactor = 0.75f;

			switch (EquippedWeapon->FiringType)
			{
			case EFiringType::EFT_HitScan:
				FireHitScanWeapon();
				break;
			case EFiringType::EFT_Projectile: 
				FireProjectileWeapon();
				break;
			case EFiringType::EFT_Shotgun: 
				FireShotgun();
				break;
			case EFiringType::EFT_MAX: break;
			default: break;
			}

		}
		StartFireTimer();
	}
}

void UCombatComponent::FireProjectileWeapon()
{
	if (EquippedWeapon && Character)
	{
		// 如果武器是使用散射的，那么就使用散射
		HitTarget = EquippedWeapon->bUseScatter ? EquippedWeapon->TraceEndWithScatter(HitTarget) : HitTarget;

		if (!Character->HasAuthority())
		{
			LocalFire(HitTarget);
		}
		
		ServerFire(HitTarget, EquippedWeapon->FireDelay);
	}
}

void UCombatComponent::FireHitScanWeapon()
{
	if (EquippedWeapon && Character)
	{
		// 如果武器是使用散射的，那么就使用散射
		HitTarget = EquippedWeapon->bUseScatter ? EquippedWeapon->TraceEndWithScatter(HitTarget) : HitTarget;
		
		if (!Character->HasAuthority())
		{
			LocalFire(HitTarget);
		}

		ServerFire(HitTarget, EquippedWeapon->FireDelay);
	}
}

void UCombatComponent::FireShotgun()
{
	AShotgun* Shotgun = Cast<AShotgun>(EquippedWeapon);
	if (Shotgun && Character)
	{
		TArray<FVector_NetQuantize> HitTargets;
		Shotgun->ShotgunTraceHitWithScatter(HitTarget, HitTargets);

		if (!Character->HasAuthority())
		{
			LocalShotgunFire(HitTargets);
		}
		
		ServerShotgunFire(HitTargets, Shotgun->FireDelay);
	}
}

void UCombatComponent::LocalFire(const FVector_NetQuantize& TraceHitTarget)
{
	if (EquippedWeapon == nullptr) return;

	if (Character && CombatState == ECombatState::ECS_Unoccupied)
	{
		Character->PlayFireMontage(bAiming);
		EquippedWeapon->Fire(TraceHitTarget);
	}
}

void UCombatComponent::LocalShotgunFire(const TArray<FVector_NetQuantize>& TraceHitTargets)
{
	AShotgun* Shotgun = Cast<AShotgun>(EquippedWeapon);
	if (Character == nullptr || Shotgun == nullptr) return;

	if (CombatState == ECombatState::ECS_Reloading || CombatState == ECombatState::ECS_Unoccupied)
	{
		bLocalReloading = false;
		Character->PlayFireMontage(bAiming);
		Shotgun->FireShotgun(TraceHitTargets);
		CombatState = ECombatState::ECS_Unoccupied;
	}
}

bool UCombatComponent::CanFire()
{
	if (EquippedWeapon == nullptr) return false;
	// 因为霰弹枪一次性装弹会有4次装弹动画，所以这里特写霰弹枪的开火判定逻辑，只要有一次装弹（有子弹，哪怕是在装弹状态下也可以开火）
	if (!EquippedWeapon->IsEmpty() && bCanFire && CombatState == ECombatState::ECS_Reloading && EquippedWeapon->GetWeaponType() == EWeaponType::EWT_Shotgun)
	{
		return true;
	}

	if (bLocalReloading) return false;

	return !EquippedWeapon->IsEmpty() && bCanFire && CombatState == ECombatState::ECS_Unoccupied;
}

void UCombatComponent::OnRep_CarriedAmmo()
{
	Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;
	if (Controller) 
	{
		Controller->SetHUDCarriedAmmo(CarriedAmmo);
	}

	bool bJumpToShotgunEnd = CombatState == ECombatState::ECS_Reloading && EquippedWeapon != nullptr && EquippedWeapon->GetWeaponType() == EWeaponType::EWT_Shotgun && CarriedAmmo == 0;

	if (bJumpToShotgunEnd)
	{
		JumpToShotgunEnd();
	}
}

void UCombatComponent::InitializeCarriedAmmo()
{
	CarriedAmmoMap.Emplace(EWeaponType::EWT_AssaultRifle, StartingARAmmo);
	CarriedAmmoMap.Emplace(EWeaponType::EWT_RocketLauncher, StartingRocketAmmo);
	CarriedAmmoMap.Emplace(EWeaponType::EWT_Pistol, StartingPistolAmmo);
	CarriedAmmoMap.Emplace(EWeaponType::EWT_SubmachineGun, StartingSMGAmmo);
	CarriedAmmoMap.Emplace(EWeaponType::EWT_Shotgun, StartingShotgunAmmo);
	CarriedAmmoMap.Emplace(EWeaponType::EWT_SniperRifle, StartingSniperAmmo);
	CarriedAmmoMap.Emplace(EWeaponType::EWT_GrenadeLauncher, StartingGrenadeLauncherAmmo);
}

void UCombatComponent::SetAiming(bool bIsAiming)
{
	if (Character == nullptr || EquippedWeapon == nullptr) return;

	bAiming = bIsAiming;
	// 如果是客户端，那么客户端需要通过RPC网络复制调用服务端的函数进行瞄准
	// 当然，因为RPC只会在客户端进行调用，所以，这里不用判断是客户端还是服务端
	ServerSetAiming(bIsAiming);
	//if (!Character->HasAuthority())
	//{
	//	// 如果是客户端，那么客户端需要通过RPC网络复制调用服务端的函数进行瞄准
	//	// 当然，因为RPC只会在客户端进行调用，所以，这里不用判断是客户端还是服务端
	//	ServerSetAiming(bIsAiming);
	//}
	if (Character)
	{
		Character->GetCharacterMovement()->MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed;
	}

	if (Character->IsLocallyControlled() && EquippedWeapon->GetWeaponType() == EWeaponType::EWT_SniperRifle)
	{
		Character->ShowSniperScopeWidget(bIsAiming);
	}

	// 只在客户端记录瞄准状态
	if (Character->IsLocallyControlled())
	{
		bAimingButtonPressed = bIsAiming;
	}
	
}

void UCombatComponent::StartFireTimer()
{
	if (EquippedWeapon == nullptr || Character == nullptr) return;
	Character->GetWorldTimerManager().SetTimer(
		FireTimer,
		this,
		&UCombatComponent::FireTimerFinished,
		EquippedWeapon->FireDelay);
}

void UCombatComponent::FireTimerFinished()
{
	if (EquippedWeapon == nullptr) return;

	bCanFire = true;
	if (bFireButtonPressed && EquippedWeapon->bAutomatic)
	{
		Fire();
	}

	ReloadEmptyWeapon();
}

void UCombatComponent::ServerFire_Implementation(const FVector_NetQuantize& TracerHitTarget, float FireDelay)
{
	MuticastFire(TracerHitTarget);
}

// 验证是否可以开火，这个函数是用来验证客户端发送给服务端的开火请求是否合法的
bool UCombatComponent::ServerFire_Validate(const FVector_NetQuantize& TracerHitTarget, float FireDelay)
{
	if (EquippedWeapon)
	{
		// 如果当前客户端的武器和服务端的武器的开火延迟是一样的，那么就可以开火（延迟精度为0.001f）
		if (FMath::IsNearlyEqual(EquippedWeapon->FireDelay, FireDelay, 0.001f))
		{
			return true;
		}
	}

	return true;
}

void UCombatComponent::ServerShotgunFire_Implementation(const TArray<FVector_NetQuantize>& TraceHitTargets, float FireDelay)
{
	MulticastShotgunFire(TraceHitTargets, FireDelay);
}

// 验证是否可以开火，这个函数是用来验证客户端发送给服务端的开火请求是否合法的
bool UCombatComponent::ServerShotgunFire_Validate(const TArray<FVector_NetQuantize>& TraceHitTargets,
	float FireDelay)
{
	if (EquippedWeapon)
	{
		// 如果当前客户端的武器和服务端的武器的开火延迟是一样的，那么就可以开火（延迟精度为0.001f）
		if (FMath::IsNearlyEqual(EquippedWeapon->FireDelay, FireDelay, 0.001f))
		{
			return true;
		}
	}
	
	return true;

}

void UCombatComponent::MulticastShotgunFire_Implementation(const TArray<FVector_NetQuantize>& TraceHitTargets, float FireDelay)
{
	if (Character && Character->IsLocallyControlled() && !Character->HasAuthority()) return;	// 如果是客户端，那么客户端不需要再次进行多播，因为客户端已经在本地进行了多播

	LocalShotgunFire(TraceHitTargets);	// 如果是服务端，那么服务端需要再次进行多播，因为服务端需要将多播的结果同步到客户端
}

void UCombatComponent::MuticastFire_Implementation(const FVector_NetQuantize& TracerHitTarget)
{
	if (Character && Character->IsLocallyControlled() && !Character->HasAuthority()) return;
	
	LocalFire(TracerHitTarget);
	
}

void UCombatComponent::ServerSetAiming_Implementation(bool bIsAiming)
{
	bAiming = bIsAiming;
	if (Character)
	{
		Character->GetCharacterMovement()->MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed;
	}
}

void UCombatComponent::EquipWeapon(AWeapon* WeaponToEquip)
{
	if (Character == nullptr || WeaponToEquip == nullptr) return;
	if (CombatState != ECombatState::ECS_Unoccupied) return;

	if (WeaponToEquip->GetWeaponType() == EWeaponType::EWT_Flag)
	{
		Character->Crouch();
		bHoldingFlag = true;
		// 如果是旗帜
		WeaponToEquip->SetWeaponState(EWeaponState::EWS_Equipped);
		AttachFlagToLeftHand(WeaponToEquip);
		WeaponToEquip->SetOwner(Character);
		TheFlag = WeaponToEquip;
	}
	else
	{
		if (EquippedWeapon != nullptr && SecondaryWeapon == nullptr)
		{
			// 如果当前角色主武器装备，次要武器没有装备，那么就装备次要武器
			EquipSecondaryWeapon(WeaponToEquip);
		}
		else
		{
			// 如果当前角色主武器没有装备，或者主幅武器都装备了，那么就装备主武器
			EquipPrimaryWeapon(WeaponToEquip);
		}

		// 一旦bOrientRotationToMovement设置为True后，角色的朝向会转向移动的方向
		// 一旦bOrientRotationToMovement 为False，但是bUseControllerDesiredRotation设置为True。
		// 那么在角色移动中，如果Controller的朝向和角色朝向不一致，
		// 角色朝向就会平滑的按照RotationRate里配置的各个轴的旋转速率来旋转角色的Rotation到Controller的朝向。
		Character->GetCharacterMovement()->bOrientRotationToMovement = false;
		Character->bUseControllerRotationYaw = true;
	}

	
}

void UCombatComponent::SwapWeapon()
{
	if (Character == nullptr) return;
	if (CombatState != ECombatState::ECS_Unoccupied) return;

	Character->bFinishedSwapping = false;

	if (EquippedWeapon && SecondaryWeapon)
	{
		Character->PlaySwapWeaponMontage();
		CombatState = ECombatState::ECS_SwappingWeapon;

		// 如果当前角色主武器装备，次要武器也装备了，那么就交换主武器和次要武器
		AWeapon* TempWeapon = EquippedWeapon;
		EquippedWeapon = SecondaryWeapon;
		SecondaryWeapon = TempWeapon;

		SecondaryWeapon->EnableCustomDepth(false);
	}
}

void UCombatComponent::EquipPrimaryWeapon(AWeapon* WeaponToEquip)
{
	if (!WeaponToEquip) return;

	DropEquippedWeapon();

	EquippedWeapon = WeaponToEquip;
	EquippedWeapon->SetWeaponState(EWeaponState::EWS_Equipped);

	AttachActorToRightHand(EquippedWeapon);

	EquippedWeapon->SetOwner(Character);
	EquippedWeapon->SetHUDAmmo();

	UpdateCarriedAmmo();

	PlayEquipWeaponSound(WeaponToEquip);

	ReloadEmptyWeapon();

	EquippedWeapon->EnableCustomDepth(false);
}

void UCombatComponent::EquipSecondaryWeapon(AWeapon* WeaponToEquip)
{
	if (!WeaponToEquip) return;

	SecondaryWeapon = WeaponToEquip;
	SecondaryWeapon->SetWeaponState(EWeaponState::EWS_EquippedSecondary);

	AttachActorToBack(SecondaryWeapon);

	SecondaryWeapon->SetOwner(Character);

	PlayEquipWeaponSound(WeaponToEquip);
}

void UCombatComponent::OnRep_Aiming()
{
	if (Character && Character->IsLocallyControlled())
	{
		// 首先，bAiming是服务端同步的值，正常来说，客户端这个值和服务端是一致的
		// 但是如果存在网络延迟，那么客户端的bAiming值可能会比服务端的bAiming值要慢一步
		// 那么这里我们采取的策略是，这个瞄准状态我们在客户端向服务器同步的时候，我们先记录下客户端的瞄准状态
		// 然后，我们在客户端用的就是这个记录的状态，这样在收到服务端的同步值的时候，我们就不用再去改变客户端的瞄准状态了
		// 从而避免了因为网络延迟导致的瞄准状态的不同步，而导致一次点击，瞄准状态来回切换的情况
		bAiming = bAimingButtonPressed;
	}
}

void UCombatComponent::DropEquippedWeapon()
{
	if (EquippedWeapon)
	{
		EquippedWeapon->Dropped();
	}
}

void UCombatComponent::AttachActorToRightHand(AActor* ActorToAttach)
{
	if (Character == nullptr || Character->GetMesh() == nullptr || ActorToAttach == nullptr) return;

	const USkeletalMeshSocket* HandSocket = Character->GetMesh()->GetSocketByName(FName("RightHandSocket"));

	if (HandSocket)
	{
		HandSocket->AttachActor(ActorToAttach, Character->GetMesh());
	}

}

void UCombatComponent::AttachActorToLeftHand(AActor* ActorToAttach)
{
	if (Character == nullptr || Character->GetMesh() == nullptr || ActorToAttach == nullptr || EquippedWeapon == nullptr) return;

	const bool bUsePistolSocket = EquippedWeapon->GetWeaponType() == EWeaponType::EWT_Pistol || EquippedWeapon->GetWeaponType() == EWeaponType::EWT_SniperRifle;

	if (const USkeletalMeshSocket* HandSocket = Character->GetMesh()->GetSocketByName(FName(bUsePistolSocket ? "PistolSocket" : "LeftHandSocket")))
	{
		HandSocket->AttachActor(ActorToAttach, Character->GetMesh());
	}
}

void UCombatComponent::AttachFlagToLeftHand(AWeapon* Flag)
{
	if (Character == nullptr || Character->GetMesh() == nullptr || Flag == nullptr) return;

	if (const USkeletalMeshSocket* HandSocket = Character->GetMesh()->GetSocketByName(FName("FlagSocket")))
	{
		HandSocket->AttachActor(Flag, Character->GetMesh());
	}
}

void UCombatComponent::AttachActorToBack(AActor* ActorToAttach)
{
	if (Character == nullptr || Character->GetMesh() == nullptr || ActorToAttach == nullptr) return;

	if (const USkeletalMeshSocket* BackpackSocket = Character->GetMesh()->GetSocketByName(FName("BackpackSocket")))
	{
		BackpackSocket->AttachActor(ActorToAttach, Character->GetMesh());
	}
}

void UCombatComponent::UpdateCarriedAmmo()
{
	if (EquippedWeapon == nullptr) return;

	if (CarriedAmmoMap.Contains(EquippedWeapon->GetWeaponType())) {
		CarriedAmmo = CarriedAmmoMap[EquippedWeapon->GetWeaponType()];
	}

	Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;
	if (Controller)
	{
		Controller->SetHUDCarriedAmmo(CarriedAmmo);
	}
}

void UCombatComponent::PlayEquipWeaponSound(AWeapon* WeaponToEquip)
{

	if (Character && WeaponToEquip && WeaponToEquip->EquipSound)
	{
		UGameplayStatics::PlaySoundAtLocation(
			this,
			WeaponToEquip->EquipSound,
			Character->GetActorLocation()
		);
	}
}

void UCombatComponent::ReloadEmptyWeapon()
{
	if (Character && EquippedWeapon && EquippedWeapon->IsEmpty())
	{
		Reload();
	}
}

void UCombatComponent::ShowAttachedGrenade(bool bShowGrenade)
{
	if (Character && Character->GetAttachedGrenade())
	{
		Character->GetAttachedGrenade()->SetVisibility(bShowGrenade);
	}
}

void UCombatComponent::Reload()
{
	if (CarriedAmmo > 0 && CombatState == ECombatState::ECS_Unoccupied && EquippedWeapon && !EquippedWeapon->IsFull() && !bLocalReloading)
	{
		// 如果当前角色携带的弹药数量小于等于0（没有子弹），那么就没必要rpc广播换弹动作，没有子弹，不需要换弹，节省网络带宽
		ServerReload();
		HandleReload();

		bLocalReloading = true;
	}
}

bool UCombatComponent::IsValidSwapWeapon() const
{
	return EquippedWeapon && SecondaryWeapon;
}

void UCombatComponent::FinishReloading()
{
	if (Character == nullptr) return;
	bLocalReloading = false;
	if (Character->HasAuthority())
	{
		CombatState = ECombatState::ECS_Unoccupied;
		UpdateAmmoValue();
	}
	if (bFireButtonPressed)
	{
		Fire();
	}
}

void UCombatComponent::FinishSwapping()
{
	if (Character && Character->HasAuthority())
	{
		CombatState = ECombatState::ECS_Unoccupied;
	}

	if (Character) Character->bFinishedSwapping = true;		// 交换武器完成

	if (SecondaryWeapon) SecondaryWeapon->EnableCustomDepth(true);	// 交换武器后，需要将武器的自定义深度设置
}

void UCombatComponent::FinishSwapAttachWeapon()
{
	// 交换武器后，需要将武器的状态设置为装备状态
	EquippedWeapon->SetWeaponState(EWeaponState::EWS_Equipped);
	SecondaryWeapon->SetWeaponState(EWeaponState::EWS_EquippedSecondary);

	// 交换武器后，需要将武器的位置设置为装备状态
	AttachActorToRightHand(EquippedWeapon);
	AttachActorToBack(SecondaryWeapon);

	// 交换武器后，需要将武器的拥有者设置为角色
	EquippedWeapon->SetOwner(Character);
	SecondaryWeapon->SetOwner(Character);

	//// 交换武器后，需要将武器的HUD弹药数量设置
	EquippedWeapon->SetHUDAmmo();
	//SecondaryWeapon->SetHUDAmmo();

	// 交换武器后，需要将武器的携带的弹药数量设置
	UpdateCarriedAmmo();

	// 交换武器后，需要将武器的自定义深度设置
	EquippedWeapon->EnableCustomDepth(false);
	SecondaryWeapon->EnableCustomDepth(false);

	// 交换武器后，需要将武器的装备声音设置
	PlayEquipWeaponSound(EquippedWeapon);
	// PlayEquipWeaponSound(SecondaryWeapon);

	// 交换武器后，需要将武器的装备声音设置
	ReloadEmptyWeapon();

	if (Character)
	{
		Character->bFinishedSwapping = true;
	}
	
}

void UCombatComponent::ServerReload_Implementation()
{
	if (Character == nullptr || EquippedWeapon == nullptr) return;

	CombatState = ECombatState::ECS_Reloading;

	if (!Character->IsLocallyControlled())
	{
		// 我们只在服务端换弹操作，因为我们在向服务端发送换弹操作的时候，客户端已经在本地进行了换弹操作
		HandleReload();
	}
}

void UCombatComponent::HandleReload()
{
	if (Character)
	{
		Character->PlayReloadMontage();
	}
}

int32 UCombatComponent::AmountToReload()
{
	if (EquippedWeapon == nullptr) return 0;
	int RoomInMag = EquippedWeapon->GetMagCapacity() - EquippedWeapon->GetAmmo();

	if (CarriedAmmoMap.Contains(EquippedWeapon->GetWeaponType()))
	{
		int32 AmmountCarried = CarriedAmmoMap[EquippedWeapon->GetWeaponType()];
		int32 Laset = FMath::Min(RoomInMag, AmmountCarried);
		return FMath::Clamp(RoomInMag, 0, Laset);
	}
	return 0;
}

// 服务端换弹
void UCombatComponent::ThrowGrenade()
{
	if (GrenadeCount <= 0) return;	// 如果手榴弹数量小于等于0，那么就不需要进行投掷手榴弹的动作了

	if (CombatState != ECombatState::ECS_Unoccupied || EquippedWeapon == nullptr) return;;

	CombatState = ECombatState::ECS_ThrowingGrenade;

	if (Character)
	{
		Character->PlayThrowGrenadeMontage();	// 播放投掷手榴弹的蒙太奇动画
		AttachActorToLeftHand(EquippedWeapon);	// 将武器附加到左手
		ShowAttachedGrenade(true);		// 显示手榴弹
	}
	if (Character && !Character->HasAuthority())	// 如果是客户端，那么客户端需要通过RPC网络复制调用服务端的函数进行投掷手榴弹
	{
		ServerThrowGrenade();
	}
	if (Character && Character->HasAuthority())	// 如果是服务端，那么服务端需要通过RPC网络复制调用客户端的函数进行投掷手榴弹
	{
		GrenadeCount = FMath::Clamp(GrenadeCount - 1, 0, GrenadeCount);	// 手榴弹数量减1
		UpdateGrenadeCount();
	}
	
}

// 服务端投掷手榴弹
void UCombatComponent::ServerThrowGrenade_Implementation()
{
	if (GrenadeCount <= 0) return;	// 如果手榴弹数量小于等于0，那么就不需要进行投掷手榴弹的动作了
	CombatState = ECombatState::ECS_ThrowingGrenade;
	if (Character)
	{
		Character->PlayThrowGrenadeMontage();
		AttachActorToLeftHand(EquippedWeapon);
		ShowAttachedGrenade(true);
	}
	GrenadeCount = FMath::Clamp(GrenadeCount - 1, 0, GrenadeCount);	// 手榴弹数量减1
}

void UCombatComponent::OnRep_CombatState()
{
	switch (CombatState)
	{
	case ECombatState::ECS_Reloading:
		{
			if (Character && !Character->IsLocallyControlled())
			{
				HandleReload();
			}
		}
		break;
	case ECombatState::ECS_Unoccupied:
		if(bFireButtonPressed)
		{
			Fire();
		}
		break;
	case ECombatState::ECS_ThrowingGrenade:
		if(Character && !Character->IsLocallyControlled())
		{
			Character->PlayThrowGrenadeMontage();
			AttachActorToLeftHand(EquippedWeapon);
			ShowAttachedGrenade(true);
		}
		break;
	case ECombatState::ECS_SwappingWeapon:
		if (Character && !Character->IsLocallyControlled())
		{
			Character->PlaySwapWeaponMontage();
		}
		break;
	default:
		break;
	}
}

void UCombatComponent::UpdateAmmoValue()
{
	if (Character == nullptr || EquippedWeapon == nullptr) return;

	int32 ReloadAmount = AmountToReload();
	if (CarriedAmmoMap.Contains(EquippedWeapon->GetWeaponType()))
	{
		CarriedAmmoMap[EquippedWeapon->GetWeaponType()] -= ReloadAmount;
		CarriedAmmo = CarriedAmmoMap[EquippedWeapon->GetWeaponType()];
	}
	Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;
	if (Controller)
	{
		Controller->SetHUDCarriedAmmo(CarriedAmmo);
	}
	EquippedWeapon->AddAmmo(ReloadAmount);
}

void UCombatComponent::UpdateShotgunAmmoValue()
{
	if (Character == nullptr || EquippedWeapon == nullptr) return;

	if (CarriedAmmoMap.Contains(EquippedWeapon->GetWeaponType()))
	{
		CarriedAmmoMap[EquippedWeapon->GetWeaponType()] -= 1;
		CarriedAmmo = CarriedAmmoMap[EquippedWeapon->GetWeaponType()];
	}

	Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;
	if (Controller)
	{
		Controller->SetHUDCarriedAmmo(CarriedAmmo);
	}

	EquippedWeapon->AddAmmo(1);

	bCanFire = true;

	// 如果霰弹枪已经填充满子弹
	if (EquippedWeapon->IsFull() || CarriedAmmo == 0)
	{
		JumpToShotgunEnd();
	}

}

void UCombatComponent::OnRep_GrenadeCount()
{
	UpdateGrenadeCount();
}

void UCombatComponent::UpdateGrenadeCount()
{
	Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;	// 获取控制器

	if (Controller)
	{
		Controller->SetHUDGrenades(GrenadeCount);
	}
}

void UCombatComponent::OnRep_HoldingFlag()
{
	if (Character && bHoldingFlag && Character->IsLocallyControlled())
	{
		Character->Crouch();
	}
}

void UCombatComponent::OnRep_EquippedWeapon()
{
	if (EquippedWeapon && Character)
	{
		EquippedWeapon->SetWeaponState(EWeaponState::EWS_Equipped);

		AttachActorToRightHand(EquippedWeapon);
		// 如果我们装备了武器，那么我们就不应该继续定向移动
		// （通过是否装备武器来解决客户端定向移动设置问题，避免添加额外的RPC变量的开销）
		EquippedWeapon->SetWeaponState(EWeaponState::EWS_Equipped);
		Character->GetCharacterMovement()->bOrientRotationToMovement = false;
		Character->bUseControllerRotationYaw = true;

		PlayEquipWeaponSound(EquippedWeapon);

		EquippedWeapon->EnableCustomDepth(false);
		EquippedWeapon->SetHUDAmmo();
		UpdateCarriedAmmo();
	}
}

void UCombatComponent::OnRep_SecondaryWeapon()
{
	if (SecondaryWeapon && Character)
	{
		SecondaryWeapon->SetWeaponState(EWeaponState::EWS_EquippedSecondary);
		AttachActorToBack(SecondaryWeapon);
		PlayEquipWeaponSound(SecondaryWeapon);
		
	}
}

void UCombatComponent::TraceUnderCrosshairs(FHitResult& TraceHitResult)
{
	// 获取视口大小
	FVector2D ViewportSize;
	if (GEngine && GEngine->GameViewport)
	{
		GEngine->GameViewport->GetViewportSize(ViewportSize);
	}

	// 射击准心位置
	FVector2D CrosshairLocation(ViewportSize.X / 2.f, ViewportSize.Y / 2.f);

	// 将屏幕坐标转化为世界坐标
	FVector CrosshairWorldPosition;		// 准心世界坐标向量
	FVector CrosshairWorldDirection;	// 准心世界方向向量
	bool bScreenToWorld = UGameplayStatics::DeprojectScreenToWorld(
		UGameplayStatics::GetPlayerController(this, 0),
		CrosshairLocation,
		CrosshairWorldPosition,
		CrosshairWorldDirection
	);

	// 判断坐标是否转化成功
	if (bScreenToWorld)
	{
		FVector Start = CrosshairWorldPosition;

		if (Character)
		{
			float DistanceToCharacter = (Character->GetActorLocation() - Start).Size();
			Start += CrosshairWorldDirection * (DistanceToCharacter + 100.f);
		}

		FVector End = Start + CrosshairWorldDirection * TRACE_LENGTH;

		GetWorld()->LineTraceSingleByChannel(
			TraceHitResult,
			Start,
			End,
			ECollisionChannel::ECC_Visibility
		);

		if (TraceHitResult.GetActor() && TraceHitResult.GetActor()->Implements<UInteractWithCrosshairsInterface>())
		{
			HUDPackage.CrosshairsColor = FLinearColor::Red;
		}
		else
		{
			HUDPackage.CrosshairsColor = FLinearColor::White;
		}

		// 如果没有跟踪到任何结果（比如瞄准天空，瞄准的物品超出80000等)
		// 这种情况下，我们就将这个结果设置为End向量
		if (!TraceHitResult.bBlockingHit)
		{
			// 如果目标没有命中
			TraceHitResult.ImpactPoint = End;
		}
	}
}

void UCombatComponent::SetHUDCrosshairs(float DeltaTime)
{
	if (Character == nullptr || Character->Controller == nullptr) return;

	Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;

	if (Controller)
	{
		HUD = HUD == nullptr ? Cast<ABlasterHUD>(Controller->GetHUD()) : HUD;
		if (HUD)
		{
			if (EquippedWeapon)
			{
				HUDPackage.CrosshairsCenter = EquippedWeapon->CrosshairsCenter;
				HUDPackage.CrosshairsBottom = EquippedWeapon->CrosshairsBottom;
				HUDPackage.CrosshairsLeft = EquippedWeapon->CrosshairsLeft;
				HUDPackage.CrosshairsRight = EquippedWeapon->CrosshairsRight;
				HUDPackage.CrosshairsTop = EquippedWeapon->CrosshairsTop;
			}
			else
			{
				HUDPackage.CrosshairsCenter = nullptr;
				HUDPackage.CrosshairsBottom = nullptr;
				HUDPackage.CrosshairsLeft = nullptr;
				HUDPackage.CrosshairsRight = nullptr;
				HUDPackage.CrosshairsTop = nullptr;
			}
			// 计算十字准心的伸展值

			// 速度映射[0, 600] -> [0. 1]
			FVector2D WalkSpeedRange(0.f, Character->GetCharacterMovement()->MaxWalkSpeed);
			FVector2D VelocityMutiplierRange(0.f, 1.f);
			FVector Velocity = Character->GetVelocity();
			Velocity.Z = 0.f;
			CrosshairVelocityFacor = FMath::GetMappedRangeValueClamped(WalkSpeedRange, VelocityMutiplierRange, Velocity.Size());

			if (Character->GetCharacterMovement()->IsFalling())
			{
				CrosshairInAirFactor = FMath::FInterpTo(CrosshairInAirFactor, 2.25f, DeltaTime, 2.25f);
			}
			else
			{
				CrosshairInAirFactor = FMath::FInterpTo(CrosshairInAirFactor, 0.f, DeltaTime, 30.f);
			}

			if (bAiming)
			{
				CrosshairAimFactor = FMath::FInterpTo(CrosshairAimFactor, 0.58f, DeltaTime, 30.f);
			}
			else
			{
				CrosshairAimFactor = FMath::FInterpTo(CrosshairAimFactor, 0.f, DeltaTime, 30.f);
			}

			CrosshairShootingFactor = FMath::FInterpTo(CrosshairShootingFactor, 0.f, DeltaTime, 40.f);
			HUDPackage.CrosshairSpread =
				0.5f +
				CrosshairVelocityFacor +
				CrosshairInAirFactor -
				CrosshairAimFactor +
				CrosshairShootingFactor;

			HUD->SetHUDPackage(HUDPackage);
		}
	}
}

void UCombatComponent::InterpFOV(float DeltaTime)
{
	if (EquippedWeapon == nullptr) return;

	if (bAiming)
	{
		CurrentFOV = FMath::FInterpTo(CurrentFOV, EquippedWeapon->GetZoomedFOV(), DeltaTime, EquippedWeapon->GetZoomedInterpSpeed());
	}
	else
	{
		CurrentFOV = FMath::FInterpTo(CurrentFOV, DefaultFOV, DeltaTime, ZoomInterpSpeed);
	}
	if (Character && Character->GetFollowCamera())
	{
		Character->GetFollowCamera()->SetFieldOfView(CurrentFOV);
	}
}

```

`Source/Blaster/BlasterComponents/CombatComponent.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blaster/HUD/BlasterHUD.h"
#include "Blaster/Weapon/WeaponTypes.h"
#include "Blaster/BlasterTypes/CombatState.h"
#include "Components/ActorComponent.h"
#include "CombatComponent.generated.h"


UCLASS(ClassGroup = (Custom), meta = (BlueprintSpawnableComponent))
class BLASTER_API UCombatComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	// Sets default values for this component's properties
	UCombatComponent();
	friend class ABlasterCharacter;
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

	void EquipWeapon(class AWeapon* WeaponToEquip);
	void SwapWeapon();
	void Reload();

	bool IsValidSwapWeapon() const;

	UFUNCTION(BlueprintCallable)
	void FinishReloading();

	UFUNCTION(BlueprintCallable)
	void FinishSwapping();

	UFUNCTION(BlueprintCallable)
	void FinishSwapAttachWeapon();

	void FireButtonPressed(bool bPressed);

	UFUNCTION(BlueprintCallable)
	void ShotgunShellReload();

	void JumpToShotgunEnd();

	UFUNCTION(BlueprintCallable)
	void ThrowGrenadeFinished();

	UFUNCTION(BlueprintCallable)
	void LaunchGrenade();

	UFUNCTION(Server, Reliable)
	void ServerLaunchGrenade(const FVector_NetQuantize& Target);

	void PickupAmmo(EWeaponType WeaponType, int32 Amount); // 捡起弹药, 传入武器类型和数量

protected:
	// Called when the game starts
	virtual void BeginPlay() override;

	void SetAiming(bool bIsAiming);

	UFUNCTION(Server, Reliable)
	void ServerSetAiming(bool bIsAiming);

	UFUNCTION()
	void OnRep_EquippedWeapon();

	UFUNCTION()
	void OnRep_SecondaryWeapon();

	void Fire();

	void FireProjectileWeapon();

	void FireHitScanWeapon();

	void FireShotgun();

	void LocalFire(const FVector_NetQuantize& TraceHitTarget);

	void LocalShotgunFire(const TArray<FVector_NetQuantize>& TraceHitTargets);

	// 创建server RPC
	// 这个函数被设计为从客户端调用，然后再服务端进行执行
	UFUNCTION(Server, Reliable, WithValidation)
	void ServerFire(const FVector_NetQuantize& TracerHitTarget, float FireDelay);

	UFUNCTION(NetMulticast, Reliable)
	void MuticastFire(const FVector_NetQuantize& TracerHitTarget);

	UFUNCTION(Server, Reliable, WithValidation)
	void ServerShotgunFire(const TArray<FVector_NetQuantize>& TraceHitTargets, float FireDelay);		// 服务器端霰弹枪开火

	UFUNCTION(NetMulticast, Reliable)
	void MulticastShotgunFire(const TArray<FVector_NetQuantize>& TraceHitTargets, float FireDelay);		// 多播霰弹枪开火

	void TraceUnderCrosshairs(FHitResult& TraceHitResult);

	void SetHUDCrosshairs(float DeltaTime);

	UFUNCTION(Server, Reliable)
	void ServerReload();

	void HandleReload();

	int32 AmountToReload();

	void ThrowGrenade();

	UFUNCTION(Server, Reliable)
	void ServerThrowGrenade();

	UPROPERTY(EditAnywhere)
	TSubclassOf<class AProjectile> GrenadeClass;

	bool bLocalReloading = false;

	void DropEquippedWeapon();		// 丢弃当前装备的武器
	void AttachActorToRightHand(AActor* ActorToAttach);		// 将ActorToAttach附加到右手
	void AttachActorToLeftHand(AActor* ActorToAttach);		// 将ActorToAttach附加到左手
	void AttachFlagToLeftHand(AWeapon* Flag);				// 将Flag附加到左手
	void AttachActorToBack(AActor* ActorToAttach);			// 将ActorToAttach附加到背部
	void UpdateCarriedAmmo();		// 更新携带的弹药
	void PlayEquipWeaponSound(AWeapon* WeaponToEquip);	// 播放装备武器的声音	
	void ReloadEmptyWeapon();		// 重新装填空武器
	void ShowAttachedGrenade(bool bShowGrenade);	// 显示附加的榴弹

	void EquipPrimaryWeapon(class AWeapon* WeaponToEquip);		// 装备主武器
	void EquipSecondaryWeapon(class AWeapon* WeaponToEquip);	// 装备副武器

private:
	UPROPERTY()
	class ABlasterCharacter* Character;

	UPROPERTY()
	class ABlasterPlayerController* Controller;

	UPROPERTY()
	class ABlasterHUD* HUD;

	UPROPERTY(ReplicatedUsing = OnRep_EquippedWeapon)
	class AWeapon* EquippedWeapon;		// 当前装备的武器

	UPROPERTY(ReplicatedUsing = OnRep_SecondaryWeapon)
	class AWeapon* SecondaryWeapon;			// 副武器

	// 瞄准 这个值是服务器端的值，客户端的值是由服务器端同步过来的
	UPROPERTY(ReplicatedUsing = OnRep_Aiming)
	bool bAiming = false;

	bool bAimingButtonPressed = false;	// 瞄准按钮是否按下

	UFUNCTION()
	void OnRep_Aiming();

	// 行进速率
	UPROPERTY(EditAnywhere)
	float BaseWalkSpeed;

	// 瞄准行径速率
	UPROPERTY(EditAnywhere)
		float AimWalkSpeed;

	// 开火按钮是否按下
	bool bFireButtonPressed;

	// 保存准心瞄准的目标
	//FVector HitTarget;

	/*
	 * HUD 和 十字准心
	 * 这个控制因子作用就是基于角色移动速度来控制我们的十字准心的伸展速率
	 * 基于角色是否浮空
	 * 基于角色是否瞄准
	 * 基于角色是否在射击
	 */
	float CrosshairVelocityFacor;
	float CrosshairInAirFactor;
	float CrosshairAimFactor;
	float CrosshairShootingFactor;

	FVector HitTarget;

	FHUDPackage HUDPackage;

	/*
	 * Aiming and FOV
	 */

	 // 不瞄准时的视野。设置为相机的基本视野或FMV并开始播放。
	float DefaultFOV;

	float CurrentFOV;

	UPROPERTY(EditAnywhere, Category = Combat)
	float ZoomedFOV = 30.f;

	UPROPERTY(EditAnywhere, Category = Combat)
	float ZoomInterpSpeed = 20.f;

	void InterpFOV(float DeltaTime);

	/*
	 * 自动开火
	 */

	FTimerHandle FireTimer;

	// 标志是否能开火
	bool bCanFire = true;

	void StartFireTimer();
	void FireTimerFinished();

	bool CanFire();

	// 当前武器携带的弹药数量
	UPROPERTY(ReplicatedUsing = OnRep_CarriedAmmo)
	int32 CarriedAmmo;

	UFUNCTION()
	void OnRep_CarriedAmmo();

	TMap<EWeaponType, int32> CarriedAmmoMap;	// 携带的弹药数量（不同类型的武器携带的弹药数量）

	UPROPERTY(EditAnywhere)
	int32 MaxARAmmo = 300;	// 突击步枪最大弹药数量

	UPROPERTY(EditAnywhere)
	int32 MaxRocketAmmo = 10;	// 火箭筒最大弹药数量

	UPROPERTY(EditAnywhere)
	int32 MaxPistolAmmo = 100;	// 手枪最大弹药数量

	UPROPERTY(EditAnywhere)
	int32 MaxSMGAmmo = 200;	// 冲锋枪最大弹药数量

	UPROPERTY(EditAnywhere)
	int32 MaxShotgunAmmo = 100;	// 霰弹枪最大弹药数量

	UPROPERTY(EditAnywhere)
	int32 MaxSniperAmmo = 50;	// 狙击步枪最大弹药数量

	UPROPERTY(EditAnywhere)
	int32 MaxGrenadeLauncherAmmo = 10;	// 榴弹发射器最大弹药数量

	TMap<EWeaponType, int32> MaxCarriedAmmoMap;	// 携带的弹药数量（不同类型的武器允许携带的最大弹药数量）

	// 突击步枪子弹数
	UPROPERTY(EditAnywhere)
	int32 StartingARAmmo = 30;

	// 火箭筒炮弹数
	UPROPERTY(EditAnywhere)
	int32 StartingRocketAmmo = 0;

	// 手枪子弹数
	UPROPERTY(EditAnywhere)
	int32 StartingPistolAmmo = 0;

	// 冲锋枪子弹数
	UPROPERTY(EditAnywhere)
	int32 StartingSMGAmmo = 0;

	// 霰弹枪子弹数
	UPROPERTY(EditAnywhere)
	int32 StartingShotgunAmmo = 0;

	// 狙击步枪子弹数
	UPROPERTY(EditAnywhere)
	int32 StartingSniperAmmo = 0;

	// 榴弹发射器榴弹数
	UPROPERTY(EditAnywhere)
	int32 StartingGrenadeLauncherAmmo = 0;

	void InitializeCarriedAmmo();

	UPROPERTY(ReplicatedUsing = OnRep_CombatState)
	ECombatState CombatState = ECombatState::ECS_Unoccupied;

	UFUNCTION()
	void OnRep_CombatState();

	void UpdateAmmoValue();

	void UpdateShotgunAmmoValue();

	UPROPERTY(ReplicatedUsing = OnRep_GrenadeCount)
	int32 GrenadeCount = 4;		// 榴弹数量

	UFUNCTION()
	void OnRep_GrenadeCount();	// 榴弹数量通知函数

	UPROPERTY(EditAnywhere)
	int32 MaxGrenadeCount = 4;	// 最大榴弹数量

	void UpdateGrenadeCount();

	UPROPERTY(ReplicatedUsing = OnRep_HoldingFlag)
	bool bHoldingFlag = false;	// 是否持有旗帜

	UFUNCTION()
	void OnRep_HoldingFlag();	// 持有旗帜通知函数

	UPROPERTY()
	AWeapon* TheFlag;	// 旗帜

public:
	FORCEINLINE int32 GetGrenadeCount() const { return GrenadeCount; }

};

```

`Source/Blaster/BlasterComponents/LagCompensationComponent.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "LagCompensationComponent.h"

#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/Weapon/Weapon.h"
#include "Components/BoxComponent.h"
#include "Kismet/GameplayStatics.h"
#include "Kismet/KismetSystemLibrary.h"

#include "Blaster/Blaster.h"

ULagCompensationComponent::ULagCompensationComponent()
{
	PrimaryComponentTick.bCanEverTick = true;
	
}

// Called when the game starts
void ULagCompensationComponent::BeginPlay()
{
	Super::BeginPlay();
}

void ULagCompensationComponent::SaveFramePackage(FFramePackage& Package)
{
	Character = Character ? Character : Cast<ABlasterCharacter>(GetOwner());

	if (Character)
	{
		Package.Time = GetWorld()->TimeSeconds;
		Package.HitCharacter = Character;
		Package.Health = Character->GetHealth();
		Package.Location = Character->GetActorLocation();
		for(auto& BoxPair : Character->HitCollisionBoxes)
		{
			FBoxInformation BoxInfo;
			BoxInfo.Location = BoxPair.Value->GetComponentLocation();
			BoxInfo.Extent = BoxPair.Value->GetScaledBoxExtent();
			BoxInfo.Rotation = BoxPair.Value->GetComponentRotation();
			Package.HitBoxInfo.Add(BoxPair.Key, BoxInfo);

		}
	}
}

// Called every frame
void ULagCompensationComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	SaveFramePackage();	// 保存帧数据

}

FFramePackage ULagCompensationComponent::InterpolateFrame(const FFramePackage& OlderFrame,
	const FFramePackage& NewerFrame, float HitTime) const
{
	FFramePackage InterpolatedFrame{};
	const float Alpha = FMath::Clamp((HitTime - OlderFrame.Time) / (NewerFrame.Time - OlderFrame.Time), 0.f, 1.f);	// 插值公式：(HitTime - OlderFrame.Time) / (NewerFrame.Time - OlderFrame.Time)
	for(auto& BoxPair : OlderFrame.HitBoxInfo)
	{
		const FBoxInformation& OlderBoxInfo = BoxPair.Value;
		const FBoxInformation& NewerBoxInfo = NewerFrame.HitBoxInfo[BoxPair.Key];

		FBoxInformation InterpolatedBoxInfo;
		InterpolatedBoxInfo.Location = FMath::Lerp(OlderBoxInfo.Location, NewerBoxInfo.Location, Alpha);
		InterpolatedBoxInfo.Extent = NewerBoxInfo.Extent;		// 这里千万不能差值，否则会导致命中框大小变化（因为命中框大小是固定的）
		InterpolatedBoxInfo.Rotation = FMath::Lerp(OlderBoxInfo.Rotation, NewerBoxInfo.Rotation, Alpha);

		InterpolatedFrame.HitBoxInfo.Add(BoxPair.Key, InterpolatedBoxInfo);
	}

	return InterpolatedFrame;
}

FServerSideRewindResult ULagCompensationComponent::CheckHit(const FFramePackage& FramePackage,
	ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation)
{
	FServerSideRewindResult Result;
	Result.bHitConfirmed = false;
	Result.bHeadShot = false;

	if (HitCharacter == nullptr) return Result;

	FFramePackage CurrentFrame;
	CacheBoxPosition(HitCharacter, CurrentFrame);	// 缓存当前帧数据
	MoveBoxes(HitCharacter, FramePackage);	// 移动命中角色的命中框
	EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::NoCollision);	// 关闭角色的碰撞

	// 首先启用命中框的碰撞，然后进行射线检测
	UBoxComponent* HeadBox = HitCharacter->HitCollisionBoxes[FName("head")];
	HeadBox->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	HeadBox->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);	// 设置碰撞响应

	FHitResult HitResult;	// 射线检测
	const FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * 1.25f;	// 射线终点
	UWorld* World = GetWorld();
	if (World)
	{
		World->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECC_HitBox);	// 射线检测

		if (HitResult.bBlockingHit)		// 命中
		{
			/*if (HitResult.Component.IsValid())
			{
				if (UBoxComponent* HitBox = Cast<UBoxComponent>(HitResult.Component.Get()))
				{
					DrawDebugBox(World, HitBox->GetComponentLocation(), HitBox->GetScaledBoxExtent(), HitBox->GetComponentRotation().Quaternion(), FColor::Red, false, 5.0f);
				}
			}*/

			ResetHitBoxes(HitCharacter, CurrentFrame);	// 重置命中框
			EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);	// 启用角色的碰撞
			Result.bHitConfirmed = true;	// 命中确认
			Result.bHeadShot = true;	// 判断是否是爆头
		}
		else
		{
			for (auto& BoxPair : HitCharacter->HitCollisionBoxes)
			{
				if (BoxPair.Value != nullptr)
				{
					BoxPair.Value->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);	// 启用命中框的碰撞
					BoxPair.Value->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);	// 设置碰撞响应
				}
			}

			World->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECC_HitBox);	// 射线检测
			if (HitResult.bBlockingHit)		// 命中
			{
				/*if (HitResult.Component.IsValid())
				{
					if (UBoxComponent* HitBox = Cast<UBoxComponent>(HitResult.Component.Get()))
					{
						DrawDebugBox(World, HitBox->GetComponentLocation(), HitBox->GetScaledBoxExtent(), HitBox->GetComponentRotation().Quaternion(), FColor::Blue, false, 5.0f);
					}
				}*/

				ResetHitBoxes(HitCharacter, CurrentFrame);	// 重置命中框
				EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);	// 启用角色的碰撞
				Result.bHitConfirmed = true;	// 命中确认
				Result.bHeadShot = false;	// 判断是否是爆头
				return Result;
			}
		}
	}

	ResetHitBoxes(HitCharacter, CurrentFrame);	// 重置命中框
	EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);	// 启用角色的碰撞

	return Result;
}

void ULagCompensationComponent::CacheBoxPosition(ABlasterCharacter* HitCharacter, FFramePackage& OutFramePackage)
{
	if (HitCharacter == nullptr) return;

	for (auto& HitBoxPair : HitCharacter->HitCollisionBoxes)
	{
		// 遍历命中框
		if (HitBoxPair.Value != nullptr)	// 如果命中框不为空
		{
			FBoxInformation BoxInfo;
			BoxInfo.Location = HitBoxPair.Value->GetComponentLocation();	// 获取命中框的位置
			BoxInfo.Rotation = HitBoxPair.Value->GetComponentRotation();	// 获取命中框的旋转
			BoxInfo.Extent = HitBoxPair.Value->GetScaledBoxExtent();		// 获取命中框的大小
			OutFramePackage.HitBoxInfo.Add(HitBoxPair.Key, BoxInfo);

			// DrawDebugBox(GetWorld(), BoxInfo.Location, BoxInfo.Extent, BoxInfo.Rotation.Quaternion(), FColor::Orange, false, 5.0f);
		}
	}
}

void ULagCompensationComponent::MoveBoxes(ABlasterCharacter* HitCharacter, const FFramePackage& FramePackage)
{
	if (HitCharacter == nullptr) return;

	for (auto& HitBoxPair : HitCharacter->HitCollisionBoxes)	// 遍历命中框
	{
		if (HitBoxPair.Value != nullptr)	// 如果命中框不为空
		{
			HitBoxPair.Value->SetWorldLocation(FramePackage.HitBoxInfo[HitBoxPair.Key].Location);	// 设置命中框的位置
			HitBoxPair.Value->SetWorldRotation(FramePackage.HitBoxInfo[HitBoxPair.Key].Rotation);	// 设置命中框的旋转
			HitBoxPair.Value->SetBoxExtent(FramePackage.HitBoxInfo[HitBoxPair.Key].Extent);			// 设置命中框的大小

			// DrawDebugBox(GetWorld(), FramePackage.HitBoxInfo[HitBoxPair.Key].Location, FramePackage.HitBoxInfo[HitBoxPair.Key].Extent, FramePackage.HitBoxInfo[HitBoxPair.Key].Rotation.Quaternion(), FColor::Green, false, 5.0f);
		}
	}
}

void ULagCompensationComponent::ResetHitBoxes(ABlasterCharacter* HitCharacter, const FFramePackage& FramePackage)
{
	if (HitCharacter == nullptr) return;

	for (auto& HitBoxPair : HitCharacter->HitCollisionBoxes)
	{
		if (HitBoxPair.Value != nullptr)
		{
			HitBoxPair.Value->SetWorldLocation(FramePackage.HitBoxInfo[HitBoxPair.Key].Location);
			HitBoxPair.Value->SetWorldRotation(FramePackage.HitBoxInfo[HitBoxPair.Key].Rotation);
			HitBoxPair.Value->SetBoxExtent(FramePackage.HitBoxInfo[HitBoxPair.Key].Extent);
			HitBoxPair.Value->SetCollisionEnabled(ECollisionEnabled::NoCollision);

			// DrawDebugBox(GetWorld(), FramePackage.HitBoxInfo[HitBoxPair.Key].Location, FramePackage.HitBoxInfo[HitBoxPair.Key].Extent, FramePackage.HitBoxInfo[HitBoxPair.Key].Rotation.Quaternion(), FColor::Red, false, 5.0f);
		}
	}
}

void ULagCompensationComponent::EnableCharacterMeshCollision(ABlasterCharacter* HitCharacter,
	ECollisionEnabled::Type Collision)
{
	if (HitCharacter == nullptr || HitCharacter->GetMesh() == nullptr) return;

	HitCharacter->GetMesh()->SetCollisionEnabled(Collision);	// 设置角色的碰撞
}

void ULagCompensationComponent::SaveFramePackage()
{
	if (Character == nullptr || !Character->HasAuthority()) return;		// 如果角色为空或者不是服务器，就直接返回

	if (FrameHistory.Num() <= 1)
	{
		FFramePackage ThisFramePackage;
		SaveFramePackage(ThisFramePackage);
		FrameHistory.AddHead(ThisFramePackage);
	}
	else
	{
		// 我们通过时间来判断是否需要保存帧数据
		float HistoryLength = FrameHistory.GetHead()->GetValue().Time - FrameHistory.GetTail()->GetValue().Time;	// 获取最新的帧数据和最老的帧数据的时间差

		while (HistoryLength > MaxRecordTime)	// 如果时间差大于最大记录时间，就删除最老的帧数据
		{
			FrameHistory.RemoveNode(FrameHistory.GetTail());	// 删除最老的帧数据
			HistoryLength = FrameHistory.GetHead()->GetValue().Time - FrameHistory.GetTail()->GetValue().Time;	// 重新计算时间差
		}

		FFramePackage ThisFramePackage;
		SaveFramePackage(ThisFramePackage);
		FrameHistory.AddHead(ThisFramePackage);

		// ShowFramePackage(ThisFramePackage, FColor::Red);	// 显示当前帧数据
	}
}

void ULagCompensationComponent::ShowFramePackage(const FFramePackage& Package, const FColor& Color)
{
	Character = Character ? Character : Cast<ABlasterCharacter>(GetOwner());

	if (Character)
	{
		for(auto& BoxPair : Package.HitBoxInfo)
		{
			const FBoxInformation BoxInfo = BoxPair.Value;
			FVector Location = BoxInfo.Location;
			FVector Extent = BoxInfo.Extent;
			FRotator Rotation = BoxInfo.Rotation;

			DrawDebugBox(GetWorld(), Location, Extent, Rotation.Quaternion(), Color, false, 5.0f);
		}
	}
}

FServerSideRewindResult ULagCompensationComponent::ServerSideRewind(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart,
	const FVector_NetQuantize& HitLocation, float HitTime)
{
	const FFramePackage RewindFramePackage = GetFrameToCheck(HitCharacter, HitTime);	// 获取需要检查的帧数据

	return CheckHit(RewindFramePackage, HitCharacter, TraceStart, HitLocation);	// 检查命中
}


FFramePackage ULagCompensationComponent::GetFrameToCheck(ABlasterCharacter* HitCharacter, float HitTime)
{
	bool bReturn = HitCharacter == nullptr ||
		HitCharacter->GetLagCompensation() == nullptr ||
		HitCharacter->GetLagCompensation()->FrameHistory.Num() == 0;

	if (bReturn)
	{
		// UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT("GetFrameToCheck bReturn: %d"), bReturn), true, false, FLinearColor::Red, 5.f);
		return FFramePackage();
	}

	FFramePackage InterpolatedFrame{};
	bool bLerp = true;

	const TDoubleLinkedList<FFramePackage>& HistoryFrame = HitCharacter->GetLagCompensation()->FrameHistory;
	const float OldestHitTime = HistoryFrame.GetTail()->GetValue().Time;
	if (OldestHitTime > HitTime)
	{
		// UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT("GetFrameToCheck OldestHitTime: %f, HitTime: %f"), OldestHitTime, HitTime), true, false, FLinearColor::Red, 5.f);
		return FFramePackage();	// 如果最老的帧数据的时间大于命中时间，就直接返回空
	}

	if (OldestHitTime == HitTime)
	{
		// 如果最老的帧数据的时间等于命中时间，就直接获取最老的帧数据
		InterpolatedFrame = HistoryFrame.GetTail()->GetValue();
		bLerp = false;
	}

	const float NewestHitTime = HistoryFrame.GetHead()->GetValue().Time;
	if (NewestHitTime <= HitTime)
	{
		// 如果最新的帧数据的时间小于等于命中时间，存储最新的帧数据
		InterpolatedFrame = HistoryFrame.GetHead()->GetValue();
		bLerp = false;
	}

	TDoubleLinkedList<FFramePackage>::TDoubleLinkedListNode* YoungerNode = HistoryFrame.GetHead();
	TDoubleLinkedList<FFramePackage>::TDoubleLinkedListNode* OlderNode = YoungerNode;

	// 循环遍历历史帧数据，找到命中时间对应的帧数据（命中时间在两帧数据之间，因为float精度问题，可能不会命中）OlderNode->GetValue().Time > HitTime && YoungerNode->GetValue().Time <= HitTime
	while (OlderNode->GetValue().Time > HitTime)
	{
		// next节点为空，表示到达最老的帧数据
		if (OlderNode->GetNextNode() == nullptr)
		{
			break;
		}

		OlderNode = OlderNode->GetNextNode();

		if (OlderNode->GetValue().Time > HitTime)	// 如果次新的帧数据的时间大于命中时间
		{
			YoungerNode = OlderNode;	// 节点向前移动
		}
	}

	if (OlderNode->GetValue().Time == HitTime)	// 如果次新的帧数据的时间等于命中时间，就直接获取次新的帧数据
	{
		// 获取次新的帧数据和最新的帧数据
		InterpolatedFrame = OlderNode->GetValue();
		bLerp = false;
	}

	if (bLerp)
	{
		// 如果需要插值，就进行插值，插值公式：(HitTime - YoungerNode->GetValue().Time) / (OlderNode->GetValue().Time - YoungerNode->GetValue().Time)
		InterpolatedFrame = InterpolateFrame(YoungerNode->GetValue(), OlderNode->GetValue(), HitTime);
	}

	InterpolatedFrame.HitCharacter = HitCharacter;

	// UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT("GetFrameToCheck bLerp: %d"), bLerp), true, false, FLinearColor::Red, 5.f);
	return InterpolatedFrame;
}

FServerSideRewindResult_Shotgun ULagCompensationComponent::ServerSideRewind_Shotgun(
	const TArray<ABlasterCharacter*>& HitCharacters, const FVector_NetQuantize& TraceStart,
	const TArray<FVector_NetQuantize>& HitLocations, float HitTime)
{
	TArray<FFramePackage> RewindFramePackages;		// 用于存储需要检查的帧数据

	for (ABlasterCharacter* HitCharacter : HitCharacters)
	{
		if (HitCharacter == nullptr) continue;

		const FFramePackage RewindFramePackage = GetFrameToCheck(HitCharacter, HitTime);	// 获取需要检查的帧数据
		RewindFramePackages.Add(RewindFramePackage);
	}
	// UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT("ServerSideRewind_Shotgun: %d"), RewindFramePackages.Num()), true, false, FLinearColor::Red, 5.f);
	const FServerSideRewindResult_Shotgun RewindResult = CheckHit_Shotgun(RewindFramePackages, TraceStart, HitLocations);	// 检查命中

	return RewindResult;
}

FServerSideRewindResult_Shotgun ULagCompensationComponent::CheckHit_Shotgun(const TArray<FFramePackage>& FramePackages,
	const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations)
{
	//FServerSideRewindResult_Shotgun Result{};

	//if (FramePackages.Num() != HitLocations.Num()) return Result;

	//for (int32 i = 0; i < FramePackages.Num(); i++)
	//{
	//	const FFramePackage& FramePackage = FramePackages[i];
	//	ABlasterCharacter* HitCharacter = FramePackage.HitCharacter;
	//	for (const auto HitLocation : HitLocations)
	//	{
	//		const FServerSideRewindResult SingleResult = CheckHit(FramePackage, HitCharacter, TraceStart, HitLocation);	// 检查命中
	//		Result.HeadShots.Add(FramePackage.HitCharacter, SingleResult.bHeadShot ? Result.HeadShots[FramePackage.HitCharacter] + 1 : Result.HeadShots[FramePackage.HitCharacter]);	// 更新爆头信息
	//		Result.BodyShots.Add(FramePackage.HitCharacter, SingleResult.bHitConfirmed && !SingleResult.bHeadShot ? Result.BodyShots[FramePackage.HitCharacter] + 1 : Result.BodyShots[FramePackage.HitCharacter]);	// 更新身体信息
	//	}
	//}

	//return Result;

	FServerSideRewindResult_Shotgun ShotgunResult{};

	for (auto& Frame : FramePackages)
	{
		if (Frame.HitCharacter == nullptr)
		{
			// UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT("CheckHit_Shotgun Frame.HitCharacter == nullptr")), true, false, FLinearColor::Red, 5.f);
			return ShotgunResult;
		}
	}
	
	TArray<FFramePackage> CurrentFrames;
	for (auto& Frame : FramePackages)
	{
		FFramePackage CurrentFrame;
		CurrentFrame.HitCharacter = Frame.HitCharacter;
		CacheBoxPosition(Frame.HitCharacter, CurrentFrame);
		MoveBoxes(Frame.HitCharacter, Frame);
		EnableCharacterMeshCollision(Frame.HitCharacter, ECollisionEnabled::NoCollision);
		CurrentFrames.Add(CurrentFrame);
	}

	for (auto& Frame : FramePackages)
	{
		// Enable collision for the head first
		UBoxComponent* HeadBox = Frame.HitCharacter->HitCollisionBoxes[FName("head")];
		HeadBox->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
		HeadBox->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);	// 设置碰撞响应，只对可见性通道进行响应
	}

	UWorld* World = GetWorld();
	// check for head shots
	for (auto& HitLocation : HitLocations)
	{
		FHitResult ConfirmHitResult;
		const FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * 1.25f;
		if (World)
		{
			World->LineTraceSingleByChannel(
				ConfirmHitResult,
				TraceStart,
				TraceEnd,
				ECC_HitBox
			);
			if (ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(ConfirmHitResult.GetActor()))
			{
				/*if (UBoxComponent* HitBox = Cast<UBoxComponent>(ConfirmHitResult.Component.Get()))
				{
					DrawDebugBox(World, HitBox->GetComponentLocation(), HitBox->GetScaledBoxExtent(), HitBox->GetComponentRotation().Quaternion(), FColor::Red, false, 5.0f);
				}*/

				if (ShotgunResult.HeadShots.Contains(BlasterCharacter))
				{
					ShotgunResult.HeadShots[BlasterCharacter]++;
				}
				else
				{
					ShotgunResult.HeadShots.Emplace(BlasterCharacter, 1);
				}
			}
		}
	}

	// enable collision for all boxes, then disable for head box
	for (auto& Frame : FramePackages)
	{
		for (auto& HitBoxPair : Frame.HitCharacter->HitCollisionBoxes)
		{
			if (HitBoxPair.Value != nullptr)
			{
				HitBoxPair.Value->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
				HitBoxPair.Value->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);
			}
		}
		UBoxComponent* HeadBox = Frame.HitCharacter->HitCollisionBoxes[FName("head")];
		HeadBox->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	}

	// check for body shots
	for (auto& HitLocation : HitLocations)
	{
		const FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * 1.25f;
		if (World)
		{
			FHitResult ConfirmHitResult;
			World->LineTraceSingleByChannel(
				ConfirmHitResult,
				TraceStart,
				TraceEnd,
				ECC_HitBox
			);
			if (ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(ConfirmHitResult.GetActor()))
			{
				/*if (UBoxComponent* HitBox = Cast<UBoxComponent>(ConfirmHitResult.Component.Get()))
				{
					DrawDebugBox(World, HitBox->GetComponentLocation(), HitBox->GetScaledBoxExtent(), HitBox->GetComponentRotation().Quaternion(), FColor::Blue, false, 5.0f);
				}*/

				if (ShotgunResult.BodyShots.Contains(BlasterCharacter))
				{
					ShotgunResult.BodyShots[BlasterCharacter]++;
				}
				else
				{
					ShotgunResult.BodyShots.Emplace(BlasterCharacter, 1);
				}
			}
		}
	}

	for (auto& Frame : CurrentFrames)
	{
		ResetHitBoxes(Frame.HitCharacter, Frame);
		EnableCharacterMeshCollision(Frame.HitCharacter, ECollisionEnabled::QueryAndPhysics);
	}

	// UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT("CheckHit_Shotgun: %d"), ShotgunResult.HeadShots.Num()), true, false, FLinearColor::Red, 5.f);
	// UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT("CheckHit_Shotgun: %d"), ShotgunResult.BodyShots.Num()), true, false, FLinearColor::Red, 5.f);
	return ShotgunResult;

}

FServerSideRewindResult ULagCompensationComponent::CheckHit_Projectile(const FFramePackage& FramePackage,
	ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart,
	const FVector_NetQuantize100& InitialVelocity)
{
	FServerSideRewindResult Result{false, false};

	if (HitCharacter == nullptr) return Result;

	FFramePackage CurrentFrame;
	CacheBoxPosition(HitCharacter, CurrentFrame);	// 缓存当前帧数据
	MoveBoxes(HitCharacter, FramePackage);	// 移动命中角色的命中框
	EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::NoCollision);	// 关闭角色的碰撞

	// 首先启用命中框的碰撞，然后进行射线检测
	UBoxComponent* HeadBox = HitCharacter->HitCollisionBoxes[FName("head")];
	HeadBox->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	HeadBox->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);	// 设置碰撞响应

	FPredictProjectilePathParams PathParams;	// 预测射线路径参数
	PathParams.StartLocation = TraceStart;	// 设置起始位置
	PathParams.LaunchVelocity = InitialVelocity;	// 设置初始速度
	PathParams.MaxSimTime = MaxRecordTime;	// 设置最大模拟时间
	PathParams.SimFrequency = 15.f;	// 设置模拟频率
	PathParams.ProjectileRadius = 5.f;	// 设置射线半径
	PathParams.bTraceWithCollision = true;	// 设置是否进行碰撞检测
	PathParams.bTraceWithChannel = true;	// 设置是否进行通道检测
	PathParams.TraceChannel = ECC_HitBox;	// 设置射线通道
	PathParams.DrawDebugTime = 5.f;	// 设置调试时间
	PathParams.DrawDebugType = EDrawDebugTrace::ForDuration;	// 设置调试类型

	FPredictProjectilePathResult PathResult;	// 预测射线路径结果

	UGameplayStatics::PredictProjectilePath(this, PathParams, PathResult);	// 预测射线路径

	if (PathResult.HitResult.bBlockingHit)	// 命中
	{
		if (PathResult.HitResult.Component.IsValid())
		{
			if (UBoxComponent* HitBox = Cast<UBoxComponent>(PathResult.HitResult.Component.Get()))
			{
				DrawDebugBox(GetWorld(), HitBox->GetComponentLocation(), HitBox->GetScaledBoxExtent(), HitBox->GetComponentRotation().Quaternion(), FColor::Red, false, 5.0f);
			}
		}

		ResetHitBoxes(HitCharacter, CurrentFrame);	// 重置命中框
		EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);	// 启用角色的碰撞
		Result.bHitConfirmed = true;	// 命中确认
		Result.bHeadShot = true;	// 判断是否是爆头
	}
	else
	{
		for (auto& BoxPair : HitCharacter->HitCollisionBoxes)
		{
			if (BoxPair.Value != nullptr)
			{
				BoxPair.Value->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);	// 启用命中框的碰撞
				BoxPair.Value->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);	// 设置碰撞响应
			}
		}

		HeadBox->SetCollisionEnabled(ECollisionEnabled::NoCollision);

		UGameplayStatics::PredictProjectilePath(this, PathParams, PathResult);	// 预测射线路径
		if (PathResult.HitResult.bBlockingHit)	// 命中
		{
			if (PathResult.HitResult.Component.IsValid())
			{
				if (UBoxComponent* HitBox = Cast<UBoxComponent>(PathResult.HitResult.Component.Get()))
				{
					DrawDebugBox(GetWorld(), HitBox->GetComponentLocation(), HitBox->GetScaledBoxExtent(), HitBox->GetComponentRotation().Quaternion(), FColor::Blue, false, 5.0f);
				}
			}

			ResetHitBoxes(HitCharacter, CurrentFrame);	// 重置命中框
			EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);	// 启用角色的碰撞
			Result.bHitConfirmed = true;	// 命中确认
			Result.bHeadShot = false;		// 判断是否是爆头
		}
	}

	return Result;

}

void ULagCompensationComponent::ServerScoreRequest_Implementation(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation, float HitTime, AWeapon* DamageCauser)
{
	if (HitCharacter == nullptr) return;

	FServerSideRewindResult Result = ServerSideRewind(HitCharacter, TraceStart, HitLocation, HitTime);	// 服务器端倒带
	if (Result.bHitConfirmed && Character && Character->Controller)
	{
		const float TotalDamage = Result.bHeadShot ? Character->GetEquippedWeapon()->GetHeadShotDamage() : Character->GetEquippedWeapon()->GetDamage();	// 计算总伤害

		// 如果命中确认，就处理伤害
		UGameplayStatics::ApplyDamage(
			HitCharacter,	// 受击角色
			TotalDamage, // 伤害值
			Character->Controller,	// 伤害来源
			Character->GetEquippedWeapon(),	// 伤害来源
			UDamageType::StaticClass()	// 伤害类型
			);
	}
}

void ULagCompensationComponent::ServerScoreRequest_Shotgun_Implementation(
	const TArray<ABlasterCharacter*>& HitCharacters, const FVector_NetQuantize& TraceStart,
	const TArray<FVector_NetQuantize>& HitLocations, float HitTime, AWeapon* DamageCauser)
{
	// UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT("ServerScoreRequest_Shotgun_Implementation: %d"), HitCharacters.Num()), true, false, FLinearColor::Red, 5.f);
	const FServerSideRewindResult_Shotgun Result = ServerSideRewind_Shotgun(HitCharacters, TraceStart, HitLocations, HitTime);	// 服务器端倒带
	for (const auto& HitCharacter : HitCharacters)
	{
		//if (DamageCauser)
		//{
		//	if (Result.HeadShots.Contains(HitCharacter))
		//	{
		//		HeadDamage = Result.HeadShots[HitCharacter] * DamageCauser->GetDamage();	// 计算爆头伤害
		//	}
		//	if (Result.BodyShots.Contains(HitCharacter))
		//	{
		//		BodyDamage = Result.BodyShots[HitCharacter] * DamageCauser->GetDamage();	// 计算身体伤害
		//	}
		//}

		if (Character && Character->GetEquippedWeapon() && Character->Controller)
		{
			float BodyDamage = 0.f;
			float HeadDamage = 0.f;

			if (Result.HeadShots.Contains(HitCharacter))
			{
				HeadDamage = Result.HeadShots[HitCharacter] * Character->GetEquippedWeapon()->GetHeadShotDamage();	// 计算爆头伤害
				// UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT("Head Damage: %f"), HeadDamage), true, false, FLinearColor::Red, 5.f);
			}
			if (Result.BodyShots.Contains(HitCharacter))
			{
				BodyDamage = Result.BodyShots[HitCharacter] * Character->GetEquippedWeapon()->GetDamage();	// 计算身体伤害
				// UKismetSystemLibrary::PrintString(GetWorld(), FString::Printf(TEXT("Body Damage: %f"), BodyDamage), true, false, FLinearColor::Red, 5.f);
			}

			UGameplayStatics::ApplyDamage(
				HitCharacter,	// 受击角色
				HeadDamage + BodyDamage, // 伤害值
				Character->Controller,	// 伤害来源
				Character->GetEquippedWeapon(),	// 伤害来源
				UDamageType::StaticClass()	// 伤害类型
			);
		}

	}
}

void ULagCompensationComponent::ServerScoreRequest_Projectile_Implementation(ABlasterCharacter* HitCharacter,
	const FVector_NetQuantize& TraceStart, const FVector_NetQuantize100& InitialVelocity, float HitTime,
	AWeapon* DamageCauser)
{
	if (HitCharacter == nullptr) return;

	const FServerSideRewindResult Result = ServerSideRewind_Projectile(HitCharacter, TraceStart, InitialVelocity, HitTime);	// 服务器端倒带
	if (Result.bHitConfirmed && Character && Character->Controller)
	{
		const float TotalDamage = Result.bHeadShot ? Character->GetEquippedWeapon()->GetHeadShotDamage() : Character->GetEquippedWeapon()->GetDamage();	// 计算总伤害

		// 如果命中确认，就处理伤害
		UGameplayStatics::ApplyDamage(
			HitCharacter,	// 受击角色
			TotalDamage, // 伤害值
			Character->Controller,	// 伤害来源
			Character->GetEquippedWeapon(),	// 伤害来源
			UDamageType::StaticClass()	// 伤害类型
			);
	}
}

FServerSideRewindResult ULagCompensationComponent::ServerSideRewind_Projectile(
	ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart,
	const FVector_NetQuantize100& InitialVelocity, float HitTime)
{
	const FFramePackage RewindFramePackage = GetFrameToCheck(HitCharacter, HitTime);	// 获取需要检查的帧数据

	return CheckHit_Projectile(RewindFramePackage, HitCharacter, TraceStart, InitialVelocity);	// 检查命中
}

void ULagCompensationComponent::ServerBacktrackTime_Implementation(float BacktrackTime, float CostTime)
{
	if (Character == nullptr) return;

	if (FrameHistory.Num() == 0) return;		// 历史帧数据为空，直接返回

	const FFramePackage FramePackage = GetFrameToCheck(Character, BacktrackTime);	// 获取到达时间的帧数据

	if (FramePackage.HitCharacter == nullptr) return;

	
}


```

`Source/Blaster/BlasterComponents/LagCompensationComponent.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "LagCompensationComponent.generated.h"

USTRUCT(BlueprintType)
struct FBoxInformation
{
	GENERATED_BODY()

	UPROPERTY()
	FVector Location;	// 位置

	UPROPERTY()
	FVector Extent;		// 大小

	UPROPERTY()
	FRotator Rotation;	// 旋转
};

// 用于存储每一帧的数据（存储命中框信息的数据结构）
USTRUCT(BlueprintType)
struct FFramePackage
{
	GENERATED_BODY()

	UPROPERTY()
	float Time;		// 命中时间

	TMap<FName, FBoxInformation> HitBoxInfo;	// 命中框信息

	UPROPERTY()
	ABlasterCharacter* HitCharacter;	// 命中角色

	UPROPERTY()
	float Health;	// 血量

	UPROPERTY()
	FVector Location;	// 位置
};

// 普通武器的服务端倒带结果
USTRUCT(BlueprintType)
struct FServerSideRewindResult
{
	GENERATED_BODY()

	UPROPERTY()
	bool bHitConfirmed;	// 命中确认

	UPROPERTY()
	bool bHeadShot;		// 是否是爆头

};

// 霰弹枪的服务端倒带结果
USTRUCT(BlueprintType)
struct FServerSideRewindResult_Shotgun
{
	GENERATED_BODY()

	UPROPERTY()
	TMap<ABlasterCharacter*, uint32> HeadShots;		// 爆头次数

	UPROPERTY()
	TMap<ABlasterCharacter*, uint32> BodyShots;		// 身体命中次数
};

// 处理玩家延迟的组件（服务器倒带）

UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class BLASTER_API ULagCompensationComponent : public UActorComponent
{
	GENERATED_BODY()

public:	
	ULagCompensationComponent();

	friend class ABlasterCharacter;

	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

	void ShowFramePackage(const FFramePackage& Package, const FColor& Color);	// 显示帧数据

	FServerSideRewindResult ServerSideRewind(class ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart,  const FVector_NetQuantize& HitLocation, float HitTime);	// 服务器端倒带，传入命中角色，射线起始位置，命中位置，命中时间

	FServerSideRewindResult_Shotgun ServerSideRewind_Shotgun(const TArray<ABlasterCharacter*>& HitCharacters, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations, float HitTime);	// 服务器端倒带，传入命中角色，射线起始位置，命中位置，命中时间

	FServerSideRewindResult ServerSideRewind_Projectile(class ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize100& InitialVelocity, float HitTime);	// 服务器端倒带，传入命中角色，投射起始位置，投射初始速度，命中时间

	/*
	 * 射线类型的服务端倒带（SSR for Hit Scan）
	 */
	UFUNCTION(Server, Reliable)
	void ServerScoreRequest(class ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation, float HitTime, class AWeapon* DamageCauser);	// 服务器端请求得分，传入命中角色，射线起始位置，命中位置，命中时间, 伤害来源

	/*
	 * 霰弹枪类型的服务端倒带（SSR for Shotgun）
	 */
	UFUNCTION(Server, Reliable)
	void ServerScoreRequest_Shotgun(const TArray<ABlasterCharacter*>& HitCharacters, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations, float HitTime, class AWeapon* DamageCauser);	// 服务器端请求得分，传入命中角色，射线起始位置，命中位置，命中时间, 伤害来源

	/*
	 * 投射类型的服务端倒带（SSR for Projectile）
	 */
	UFUNCTION(Server, Reliable)
	void ServerScoreRequest_Projectile(class ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize100& InitialVelocity, float HitTime, class AWeapon* DamageCauser);	// 服务器端请求得分，传入命中角色，投射起始位置，投射初始速度，命中时间, 伤害来源

	/*
	 * 设置回溯时间
	 */
	UFUNCTION(Server, Reliable)
	void ServerBacktrackTime(float BacktrackTime, float CostTime);	// 服务器端回溯，传入回溯时间，回溯花费时间
	

protected:
	virtual void BeginPlay() override;

	void SaveFramePackage(FFramePackage& Package);		// 保存帧数据

	FFramePackage InterpolateFrame(const FFramePackage& OlderFrame, const FFramePackage& NewerFrame, float HitTime) const;	// 插值帧数据

	void CacheBoxPosition(ABlasterCharacter* HitCharacter, FFramePackage& OutFramePackage);	// 缓存命中框位置，传入命中角色，输出帧数据

	void MoveBoxes(ABlasterCharacter* HitCharacter, const FFramePackage& FramePackage);	// 移动命中框，传入命中角色，帧数据

	void ResetHitBoxes(ABlasterCharacter* HitCharacter, const FFramePackage& FramePackage);	// 重置命中框，传入命中角色, 帧数据

	void EnableCharacterMeshCollision(ABlasterCharacter* HitCharacter, ECollisionEnabled::Type Collision);	// 启用角色碰撞，传入命中角色，是否启用

	void SaveFramePackage();	// 保存帧数据到历史记录

	FFramePackage GetFrameToCheck(ABlasterCharacter* HitCharacter, float HitTime);	// 获取用于检查的帧数据，传入命中角色，命中时间

	/*
	 * 射线类型的命中检查
	 */
	FServerSideRewindResult CheckHit(const FFramePackage& FramePackage, ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation);	// 检查命中，传入帧数据，命中角色，射线起始位置，命中位置

	/*
	 * 霰弹枪
	 */
	FServerSideRewindResult_Shotgun CheckHit_Shotgun(const TArray<FFramePackage>& FramePackages, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations);	// 检查命中，传入帧数据，命中角色，射线起始位置，命中位置

	/*
	 * 投射类型的命中检查
	 */
	FServerSideRewindResult CheckHit_Projectile(const FFramePackage& FramePackage, ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize100& InitialVelocity);	// 检查命中，传入帧数据，命中角色，投射起始位置，投射初始速度


private:
	UPROPERTY()
	ABlasterCharacter* Character;	// 拥有该组件的角色

	UPROPERTY()
	class ABlasterPlayerController* Controller;	// 玩家控制器

	TDoubleLinkedList<FFramePackage> FrameHistory;	// 历史帧数据链表

	UPROPERTY(EditAnywhere)
	float MaxRecordTime = 5.0f;	// 最大记录时间

};

```

`Source/Blaster/BlasterTypes/Announcement.h`:

```h
#pragma once

namespace Announcement
{
	const FString NewMatchStartsIn(TEXT("New match starts in:"));
	const FString NoWinner(TEXT("There is no winner."));
	const FString YouAreTheWinner(TEXT("You are the winner!"));
	const FString PlayersTiedForTheWin(TEXT("Players tied for the win:"));
	const FString TeamsTiedForTheWin(TEXT("Teams tied for the win:"));
	const FString RedTeam(TEXT("Red team"));
	const FString BlueTeam(TEXT("Blue team"));
	const FString RedTeamWins(TEXT("Red team wins!"));
	const FString BlueTeamWins(TEXT("Blue team wins!"));

}

```

`Source/Blaster/BlasterTypes/CombatState.h`:

```h
#pragma once

UENUM(BlueprintType)
enum class ECombatState : uint8
{
	ECS_Unoccupied UMETA(DisplayName = "Unoccupied"),		// 未占用
	ECS_Reloading UMETA(DisplayName = "Reloading"),		// 武器装填
	ECS_ThrowingGrenade UMETA(DisplayName = "Throwing Grenade"),	// 扔榴弹
	ECS_SwappingWeapon UMETA(DisplayName = "Swapping Weapon"),		// 切换武器

	ECS_MAX UMETA(DisplayName = "DefaultMax")
};

```

`Source/Blaster/BlasterTypes/Team.h`:

```h
#pragma once

UENUM(BlueprintType)
enum class ETeam : uint8
{
	ET_RedTeam UMETA(DisplayName = "Red Team"),
	ET_BlueTeam UMETA(DisplayName = "Blue Team"),
	ET_GreenTeam UMETA(DisplayName = "Green Team"),
	ET_YellowTeam UMETA(DisplayName = "Yellow Team"),
	ET_PurpleTeam UMETA(DisplayName = "Purple Team"),
	ET_OrangeTeam UMETA(DisplayName = "Orange Team"),
	ET_PinkTeam UMETA(DisplayName = "Pink Team"),
	ET_BlackTeam UMETA(DisplayName = "Black Team"),
	ET_WhiteTeam UMETA(DisplayName = "White Team"),

	ET_NoTeam UMETA(DisplayName = "No Team"),

	ET_MAX UMETA(DisplayName = "DefaultMax")
};

```

`Source/Blaster/BlasterTypes/TurningInPlace.h`:

```h
#pragma once

// 人物转弯状态枚举类
UENUM(BlueprintType)
enum class ETurningInPlace : uint8
{
	ETIP_Left UMETA(DisplayName = "Turning Left"),
	ETIP_Right UMETA(DisplayName = "Turning Right"),
	ETIP_NotTurning UMETA(DisplayName = "Not Turning"),

	ETIP_MAX UMETA(DisplayName = "DefultMax")
};
```

`Source/Blaster/CaptureTheFlag/FlagZone.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "FlagZone.h"

#include "Blaster/Weapon/Flag.h"
#include "Components/SphereComponent.h"
#include "Blaster/GameMode/CaptureTheFlagGameMode.h"
#include "Kismet/KismetSystemLibrary.h"

AFlagZone::AFlagZone()
{
	PrimaryActorTick.bCanEverTick = false;		// 禁用Tick

	ZoneSphere = CreateDefaultSubobject<USphereComponent>(TEXT("ZoneSphere"));		// 创建区域球体
	// ZoneSphere->SetCollisionResponseToChannel(ECC_WorldDynamic, ECR_Overlap);		// 设置碰撞响应
	SetRootComponent(ZoneSphere);		// 设置根组件
}

void AFlagZone::BeginPlay()
{
	Super::BeginPlay();

	ZoneSphere->OnComponentBeginOverlap.AddDynamic(this, &AFlagZone::OnStartOverlap);	// 添加开始重叠事件
}

void AFlagZone::OnStartOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp,
	int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (AFlag* OverlappingFlag = Cast<AFlag>(OtherActor))		// 如果夺旗存在且队伍不同
	{
		if (OverlappingFlag->GetTeam() != Team)
		{
			if (ACaptureTheFlagGameMode* GameMode = GetWorld()->GetAuthGameMode<ACaptureTheFlagGameMode>())
			{
				GameMode->FlagCaptured(OverlappingFlag, this);
			}
			OverlappingFlag->ResetFlag();	// 重置旗帜
		}
	}
}


```

`Source/Blaster/CaptureTheFlag/FlagZone.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Blaster/BlasterTypes/Team.h"
#include "FlagZone.generated.h"

/*
 * 夺旗区域
 */

UCLASS()
class BLASTER_API AFlagZone : public AActor
{
	GENERATED_BODY()
	
public:	
	AFlagZone();

	UPROPERTY(EditAnywhere)
	ETeam Team;		// 队伍

protected:
	virtual void BeginPlay() override;

	UFUNCTION()
	virtual void OnStartOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);		// 开始重叠

private:
	UPROPERTY(EditAnywhere)
	class USphereComponent* ZoneSphere;		// 区域球体

public:	

};

```

`Source/Blaster/Character/BlasterAnimInstance.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "BlasterAnimInstance.h"

#include "BlasterCharacter.h"
#include "Blaster/Weapon/Weapon.h"
#include "Blaster/BlasterTypes/CombatState.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Kismet/KismetMathLibrary.h"

void UBlasterAnimInstance::NativeInitializeAnimation()
{
	Super::NativeInitializeAnimation();

	BlasterCharacter = Cast<ABlasterCharacter>(TryGetPawnOwner());
}

void UBlasterAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	Super::NativeUpdateAnimation(DeltaSeconds);

	if (BlasterCharacter == nullptr)
	{
		BlasterCharacter = Cast<ABlasterCharacter>(TryGetPawnOwner());
	}

	if (BlasterCharacter == nullptr)
	{
		return;
	}

	// 获取角色速度矢量
	FVector Velocity = BlasterCharacter->GetVelocity();
	Velocity.Z = 0.f;
	Spead = Velocity.Size();

	// 通过获取角色是否处于掉落状态来 赋值 bIsInAir
	bIsInAir = BlasterCharacter->GetCharacterMovement()->IsFalling();

	// 判断 获取当前加速度 是否大于0来判断是否处于加速状态
	bIsAccelerating = BlasterCharacter->GetCharacterMovement()->GetCurrentAcceleration().Size() > 0.f ? true : false;

	// 判断当前角色是否装备了武器，将状态赋值给 bWeaponEquipped
	bWeaponEquipped = BlasterCharacter->IsWeaponEquipped();
	EquippedWeapon = BlasterCharacter->GetEquippedWeapon();
	bIsCrouched = BlasterCharacter->bIsCrouched;

	bAiming = BlasterCharacter->IsAiming();
	TurningInPlace = BlasterCharacter->GetTurningInPlace();
	bRotateRootBone = BlasterCharacter->ShouldRotateRootBone();
	bElimmed = BlasterCharacter->IsElimmed();
	bHoldingFlag = BlasterCharacter->IsHoldingFlag();

	// offset Yaw for Strafing (获取扫射动作的偏移Yaw)
	// 为了得到倾斜角信息，我们需要知道我们正在移动的方向以及我们移动方向瞄准的控制器指向的方向
	// 在 UE 中，偏航角 Yaw 是指绕蓝色 Z 轴（也就是方向朝上的那个轴）旋转的角。
	// 偏航角 Yaw 使人物绕着 Z 轴旋转。偏航角旋转的效果，可以想象成人在原地转动。
	FRotator AimRotation = BlasterCharacter->GetBaseAimRotation();
	FRotator MovementRotation = UKismetMathLibrary::MakeRotFromX(BlasterCharacter->GetVelocity());
	//if (!BlasterCharacter->HasAuthority() && !BlasterCharacter->IsLocallyControlled())
	//{
	//	// 打印日志
	//	UE_LOG(LogTemp, Warning, TEXT("AimRotation Yaw %f : "), AimRotation.Yaw);
	//	UE_LOG(LogTemp, Warning, TEXT("MovementRotation Yaw %f : "), MovementRotation.Yaw);
	//}
	// 获取偏移
	// 为我们的增量旋转获取一个存储变量，然后平滑的插入该旋转
	FRotator DeltaRot = UKismetMathLibrary::NormalizedDeltaRotator(MovementRotation, AimRotation);
	DeltaRotation = FMath::RInterpTo(DeltaRotation, DeltaRot, DeltaSeconds, 6.f);
	YawOffset = DeltaRotation.Yaw;

	// 扫射动作的倾斜角
	CharacterRotationLastFrame = CharacterRotation;
	CharacterRotation = BlasterCharacter->GetActorRotation();
	const FRotator Delta = UKismetMathLibrary::NormalizedDeltaRotator(CharacterRotation, CharacterRotationLastFrame);
	const float Target = Delta.Yaw / DeltaSeconds;
	const float Interp = FMath::FInterpTo(Lean, Target, DeltaSeconds, 6.0f);
	Lean = FMath::Clamp(Interp, -90.f, 90.f);
	// DeltaTime 实际是距离上一帧调用过去了多久,如果帧率是稳定的,那么此数值为 1/fps ,例fps=100时,则DeltaTime=1/100=0.01
	// 实际运行帧率一定是不稳定的, 则可以用每秒需要的变化量, 乘以DeltaTime来平衡掉帧率的影响
	// 在UE5中，它被更名为 DeltaSeconds

	AO_Yaw = BlasterCharacter->GetAO_Yaw();
	AO_Pitch = BlasterCharacter->GetAO_Pitch();

	if (bWeaponEquipped && EquippedWeapon && EquippedWeapon->GetWeaponMesh() && BlasterCharacter->GetMesh())
	{
		// 我们需要从我们装备的武器上的插槽中获取插槽转换
		// 将武器插槽的世界空间变换赋值给我们的成员变量 LeftHandTransform
		LeftHandTransform = EquippedWeapon->GetWeaponMesh()->GetSocketTransform(FName("LeftHandSocket"), ERelativeTransformSpace::RTS_World);
		// 现在是在世界坐标中，但是我们实际要转换的是我们骨骼上的坐标
		FVector OutPosition;
		FRotator OutRotation;
		// TransformFromBoneSpace这个函数需要传入骨骼名称
		BlasterCharacter->GetMesh()->TransformToBoneSpace(FName("hand_r"), LeftHandTransform.GetLocation(), FRotator::ZeroRotator, OutPosition, OutRotation);
		// 在调用完这个函数后，变换到骨骼空间，这个向量和旋转器将会存储左手握在武器插槽在上的正确位置和旋转数据，
		// 然后将这两个数据设置给我们的左手变换
		LeftHandTransform.SetLocation(OutPosition);
		LeftHandTransform.SetRotation(FQuat(OutRotation));
		// 自此，我们就可以在蓝图中使用这个 LeftHandTransform

		// 修复武器指向和十字准心不一致的问题
		if (BlasterCharacter->IsLocallyControlled())
		{
			bLocallyControlled = true;
			FTransform RightHandTransform = EquippedWeapon->GetWeaponMesh()->GetSocketTransform(FName("Hand_r"), ERelativeTransformSpace::RTS_World);
			FRotator LookatRotation = UKismetMathLibrary::FindLookAtRotation(RightHandTransform.GetLocation(), RightHandTransform.GetLocation() + (RightHandTransform.GetLocation() - BlasterCharacter->GetHitTarget()));
			RightHandRotation = FMath::RInterpTo(RightHandRotation, LookatRotation, DeltaSeconds, 30.f);
		}

		/*调试线条
		FTransform MuzzleTipTransform = EquippedWeapon->GetWeaponMesh()->GetSocketTransform(FName("MuzzleFlash"), ERelativeTransformSpace::RTS_World);
		FVector MuzzleX(FRotationMatrix(MuzzleTipTransform.GetRotation().Rotator()).GetUnitAxis(EAxis::X));
		DrawDebugLine(GetWorld(), MuzzleTipTransform.GetLocation(), MuzzleTipTransform.GetLocation() + MuzzleX * 1000, FColor::Red);
		DrawDebugLine(GetWorld(), MuzzleTipTransform.GetLocation(), BlasterCharacter->GetHitTarget(), FColor::Green);
		*/
	}

	bUseFABRIK = BlasterCharacter->GetCombatState() == ECombatState::ECS_Unoccupied;
	if (BlasterCharacter->IsLocallyControlled() && BlasterCharacter->GetCombatState() == ECombatState::ECS_ThrowingGrenade && BlasterCharacter->bFinishedSwapping)	// 只有本地控制的角色才能使用 FABRIK
	{
		bUseFABRIK = !BlasterCharacter->IsLocalReloading();
	}
	bUseAimOffsets = BlasterCharacter->GetCombatState() == ECombatState::ECS_Unoccupied && !BlasterCharacter->GetDisableGamePlay();
	bTransformRightHand = BlasterCharacter->GetCombatState() == ECombatState::ECS_Unoccupied && !BlasterCharacter->GetDisableGamePlay();
}
```

`Source/Blaster/Character/BlasterAnimInstance.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimInstance.h"
#include "Blaster/BlasterTypes/TurningInPlace.h"
#include "BlasterAnimInstance.generated.h"

/**
 *
 */
UCLASS()
class BLASTER_API UBlasterAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

public:
	virtual void NativeInitializeAnimation() override;
	virtual void NativeUpdateAnimation(float DeltaSeconds) override;

private:
	// 存储 Blaster 字符变量
	// 需要从动画蓝图访问它，并且希望设置为蓝图只读，分类为Character
	// 因为这是一个私有变量，我们不能在私有变量上设置 BlueprintReadOnly ， 所以可以设置 meta ，AllowPrivateAccess 设置为true
	UPROPERTY(BlueprintReadOnly, Category = Character, meta = (AllowPrivateAccess = "true"))
	class ABlasterCharacter* BlasterCharacter;

	// 速度
	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	float Spead;

	// 是否在空中
	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bIsInAir;

	// 是否加速, 用于驱动动画
	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bIsAccelerating;

	// 检测是否有当前装备的武器
	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bWeaponEquipped;

	UPROPERTY()
	class AWeapon* EquippedWeapon;

	// 检测是否蹲下
	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bIsCrouched;

	// 检测瞄准
	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bAiming;

	// 水平偏移(用于驱动扫射动作)
	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	float YawOffset;

	// 倾斜角
	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	float Lean;

	FRotator CharacterRotationLastFrame;
	FRotator CharacterRotation;
	FRotator DeltaRotation;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	float AO_Yaw;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	float AO_Pitch;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	FTransform LeftHandTransform;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	ETurningInPlace TurningInPlace;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	FRotator RightHandRotation;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bLocallyControlled;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bRotateRootBone;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bElimmed;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bUseFABRIK;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bUseAimOffsets;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bTransformRightHand;

	UPROPERTY(BlueprintReadOnly, Category = Movement, meta = (AllowPrivateAccess = "true"))
	bool bHoldingFlag;

};

```

`Source/Blaster/Character/BlasterCharacter.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "BlasterCharacter.h"

#include "Blaster/BlasterComponents/CombatComponent.h"
#include "Blaster/BlasterComponents/BuffComponent.h"
#include "Blaster/Weapon/Weapon.h"
#include "Camera/CameraComponent.h"
#include "Components/CapsuleComponent.h"
#include "Components/WidgetComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "GameFramework/SpringArmComponent.h"
#include "Net/UnrealNetwork.h"
#include "Kismet/KismetMathLibrary.h"
#include "Blaster/Blaster.h"
#include "Blaster/BlasterComponents/LagCompensationComponent.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "Blaster/GameMode/BlasterGameMode.h"
#include "Blaster/PlayerState/BlasterPlayerState.h"
#include "Blaster/Weapon/WeaponTypes.h"
#include "Components/BoxComponent.h"
#include "Kismet/GameplayStatics.h"
#include "Particles/ParticleSystemComponent.h"
#include "Sound/SoundCue.h"
#include "NiagaraComponent.h"
#include "NiagaraFunctionLibrary.h"
#include "Blaster/GameState/BlasterGameState.h"
#include "Blaster/PlayerStart/TeamPlayerStart.h"

// Sets default values
ABlasterCharacter::ABlasterCharacter()
{
	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	// 尝试调整碰撞位置，及时碰撞调整失败，也依旧生成Spawn
	SpawnCollisionHandlingMethod = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;

	CameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraBoom"));
	// 将弹簧臂链接到网格上
	CameraBoom->SetupAttachment(GetMesh());
	// 设置相机臂长度
	CameraBoom->TargetArmLength = 600.f;
	// 把这个设置为true，这样当我们添加鼠标输入时，就可以随着控制器旋转相机吊杆。
	CameraBoom->bUsePawnControlRotation = true;

	// 前置相机
	FollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("FollowCamera"));
	// 绑定相机臂
	FollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);
	// 因为有相机臂控制旋转，所以不需要设置旋转为true
	FollowCamera->bUsePawnControlRotation = false;

	// 不希望角色与控制器一起旋转
	bUseControllerRotationYaw = false;

	// 获取角色移动来访问角色移动组件
	GetCharacterMovement()->bOrientRotationToMovement = true;

	OverheadWidget = CreateDefaultSubobject<UWidgetComponent>(TEXT("OverheadWidget"));
	OverheadWidget->SetupAttachment(RootComponent);

	// 战斗组件
	Combat = CreateDefaultSubobject<UCombatComponent>(TEXT("CombatComponent"));
	Combat->SetIsReplicated(true);

	// BUFF组件
	Buff = CreateDefaultSubobject<UBuffComponent>(TEXT("BuffComponent"));
	Buff->SetIsReplicated(true);	// 设置BUFF组件为可复制

	// 服务端倒带组件
	LagCompensation = CreateDefaultSubobject<ULagCompensationComponent>(TEXT("LagCompensation"));

	// 设置角色可蹲伏（也可以在UE编辑器中勾选）
	GetCharacterMovement()->NavAgentProps.bCanCrouch = true;

	// 设置角色胶囊体不会阻挡摄像机，设置骨骼不会阻挡摄像机
	GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore);
	GetMesh()->SetCollisionObjectType(ECC_SkeletalMesh);
	GetMesh()->SetCollisionResponseToChannel(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore);
	GetMesh()->SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);
	// 设置角色旋转速率，让其转身更自然
	GetCharacterMovement()->RotationRate = FRotator(0.f, 0.f, 850.f);

	// 设置角色默认姿势（不转弯）
	TurningInPlace = ETurningInPlace::ETIP_NotTurning;

	// 设置角色更新频率和最小更新频率
	NetUpdateFrequency = 66.f;
	MinNetUpdateFrequency = 33.f;

	DissolveTimeline = CreateDefaultSubobject<UTimelineComponent>(TEXT("DissolveTimelineCommponent"));

	// 手榴弹组件
	AttachedGrenade = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Attached Grenade"));
	// 将手榴弹组件绑定到右手的GrenadeSocket插槽上
	AttachedGrenade->SetupAttachment(GetMesh(), FName("GrenadeSocket"));
	// 设置手榴弹的碰撞
	AttachedGrenade->SetCollisionEnabled(ECollisionEnabled::NoCollision);

	/*
	 * 受击盒子 用于服务端倒带算法
	 */
	head = CreateDefaultSubobject<UBoxComponent>(TEXT("head"));
	head->SetupAttachment(GetMesh(), FName("head"));
	HitCollisionBoxes.Add(FName("head"), head);

	pelvis = CreateDefaultSubobject<UBoxComponent>(TEXT("pelvis"));
	pelvis->SetupAttachment(GetMesh(), FName("pelvis"));
	HitCollisionBoxes.Add(FName("pelvis"), pelvis);

	spine_02 = CreateDefaultSubobject<UBoxComponent>(TEXT("spine_02"));
	spine_02->SetupAttachment(GetMesh(), FName("spine_02"));
	HitCollisionBoxes.Add(FName("spine_02"), spine_02);

	spine_03 = CreateDefaultSubobject<UBoxComponent>(TEXT("spine_03"));
	spine_03->SetupAttachment(GetMesh(), FName("spine_03"));
	HitCollisionBoxes.Add(FName("spine_03"), spine_03);

	upperarm_l = CreateDefaultSubobject<UBoxComponent>(TEXT("upperarm_l"));
	upperarm_l->SetupAttachment(GetMesh(), FName("upperarm_l"));
	HitCollisionBoxes.Add(FName("upperarm_l"), upperarm_l);

	upperarm_r = CreateDefaultSubobject<UBoxComponent>(TEXT("upperarm_r"));
	upperarm_r->SetupAttachment(GetMesh(), FName("upperarm_r"));
	HitCollisionBoxes.Add(FName("upperarm_r"), upperarm_r);

	lowerarm_l = CreateDefaultSubobject<UBoxComponent>(TEXT("lowerarm_l"));
	lowerarm_l->SetupAttachment(GetMesh(), FName("lowerarm_l"));
	HitCollisionBoxes.Add(FName("lowerarm_l"), lowerarm_l);

	lowerarm_r = CreateDefaultSubobject<UBoxComponent>(TEXT("lowerarm_r"));
	lowerarm_r->SetupAttachment(GetMesh(), FName("lowerarm_r"));
	HitCollisionBoxes.Add(FName("lowerarm_r"), lowerarm_r);

	hand_l = CreateDefaultSubobject<UBoxComponent>(TEXT("hand_l"));
	hand_l->SetupAttachment(GetMesh(), FName("hand_l"));
	HitCollisionBoxes.Add(FName("hand_l"), hand_l);

	hand_r = CreateDefaultSubobject<UBoxComponent>(TEXT("hand_r"));
	hand_r->SetupAttachment(GetMesh(), FName("hand_r"));
	HitCollisionBoxes.Add(FName("hand_r"), hand_r);

	blanket = CreateDefaultSubobject<UBoxComponent>(TEXT("blanket"));
	blanket->SetupAttachment(GetMesh(), FName("backpack"));
	HitCollisionBoxes.Add(FName("blanket"), blanket);

	backpack = CreateDefaultSubobject<UBoxComponent>(TEXT("backpack"));
	backpack->SetupAttachment(GetMesh(), FName("backpack"));
	HitCollisionBoxes.Add(FName("backpack"), backpack);

	thigh_l = CreateDefaultSubobject<UBoxComponent>(TEXT("thigh_l"));
	thigh_l->SetupAttachment(GetMesh(), FName("thigh_l"));
	HitCollisionBoxes.Add(FName("thigh_l"), thigh_l);

	thigh_r = CreateDefaultSubobject<UBoxComponent>(TEXT("thigh_r"));
	thigh_r->SetupAttachment(GetMesh(), FName("thigh_r"));
	HitCollisionBoxes.Add(FName("thigh_r"), thigh_r);

	calf_l = CreateDefaultSubobject<UBoxComponent>(TEXT("calf_l"));
	calf_l->SetupAttachment(GetMesh(), FName("calf_l"));
	HitCollisionBoxes.Add(FName("calf_l"), calf_l);

	calf_r = CreateDefaultSubobject<UBoxComponent>(TEXT("calf_r"));
	calf_r->SetupAttachment(GetMesh(), FName("calf_r"));
	HitCollisionBoxes.Add(FName("calf_r"), calf_r);

	foot_l = CreateDefaultSubobject<UBoxComponent>(TEXT("foot_l"));
	foot_l->SetupAttachment(GetMesh(), FName("foot_l"));
	HitCollisionBoxes.Add(FName("foot_l"), foot_l);

	foot_r = CreateDefaultSubobject<UBoxComponent>(TEXT("foot_r"));
	foot_r->SetupAttachment(GetMesh(), FName("foot_r"));
	HitCollisionBoxes.Add(FName("foot_r"), foot_r);

	for (const auto& HitCollisionBox : HitCollisionBoxes)
	{
		if (HitCollisionBox.Value == nullptr) continue;

		HitCollisionBox.Value->SetCollisionObjectType(ECC_HitBox);		// 设置碰撞对象类型，这是我们自定义的碰撞通道
		HitCollisionBox.Value->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);	// 设置碰撞响应，忽略所有通道
		HitCollisionBox.Value->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);	// 设置碰撞响应，只响应我们自定义的碰撞通道
		HitCollisionBox.Value->SetCollisionEnabled(ECollisionEnabled::NoCollision);	// 设置碰撞启用，不启用碰撞
	}

	// ImpulseCharacter();	// 给角色添加冲量
}

void ABlasterCharacter::UpdateHUDHealth()
{
	BlasterPlayerController = BlasterPlayerController == nullptr ? Cast<ABlasterPlayerController>(Controller) : BlasterPlayerController;

	if (BlasterPlayerController)
	{
		BlasterPlayerController->SetHUDHealth(Health, MaxHealth);
	}
}

void ABlasterCharacter::UpdateHUDHealthNative()
{
	BlasterPlayerController = BlasterPlayerController == nullptr ? Cast<ABlasterPlayerController>(Controller) : BlasterPlayerController;

	if (BlasterPlayerController)
	{
		BlasterPlayerController->SetHUDHealthNative(Health, MaxHealth, BeforeDamageHealth, AfterHealHealth);
	}
}

void ABlasterCharacter::UpdateHUDShield()
{
	BlasterPlayerController = BlasterPlayerController == nullptr ? Cast<ABlasterPlayerController>(Controller) : BlasterPlayerController;

	if (BlasterPlayerController)
	{
		BlasterPlayerController->SetHUDShield(Shield, MaxShield);
		BlasterPlayerController->SetHUDShieldNative(Shield, MaxShield);
	}
}

void ABlasterCharacter::UpdateHUDAmmo()
{
	BlasterPlayerController = BlasterPlayerController == nullptr ? Cast<ABlasterPlayerController>(Controller) : BlasterPlayerController;

	if (BlasterPlayerController)
	{
		if (Combat && Combat->EquippedWeapon)
		{
			BlasterPlayerController->SetHUDCarriedAmmo(Combat->CarriedAmmo);	// 设置手榴弹数量
			BlasterPlayerController->SetHUDWeaponAmmo(Combat->EquippedWeapon->GetAmmo());	// 设置武器弹药数量
		}
	}
}

void ABlasterCharacter::PollInit()
{
	if (BlasterPlayerState == nullptr)
	{
		BlasterPlayerState = GetPlayerState<ABlasterPlayerState>();
		if (BlasterPlayerState)
		{
			OnPlayerInitialized();

			ABlasterGameState* BlasterGameState = Cast<ABlasterGameState>(UGameplayStatics::GetGameState(this));
			if (BlasterGameState && BlasterGameState->TopScoringPlayers.Contains(BlasterPlayerState))
			{
				MulticastGainedTheCrown();
			}
		}
	}
}

void ABlasterCharacter::SetSpawnPoint()
{
	if (HasAuthority() && BlasterPlayerState && BlasterPlayerState->GetTeam() != ETeam::ET_NoTeam)
	{
		TArray<AActor*> PlayerStarts;	// 玩家出生点数组
		UGameplayStatics::GetAllActorsOfClass(this, ATeamPlayerStart::StaticClass(), PlayerStarts);	// 获取所有的玩家出生点

		TArray<ATeamPlayerStart*> TeamPlayerStarts;	// 队伍玩家出生点数组
		for (AActor* PlayerStart : PlayerStarts)
		{
			ATeamPlayerStart* TeamPlayerStart = Cast<ATeamPlayerStart>(PlayerStart);
			if (TeamPlayerStart && TeamPlayerStart->GetTeam() == BlasterPlayerState->GetTeam())
			{
				TeamPlayerStarts.Add(TeamPlayerStart);		// 将相同队伍的玩家出生点添加到队伍玩家出生点数组中
			}
		}

		if (TeamPlayerStarts.Num() > 0)
		{
			const int32 RandomIndex = FMath::RandRange(0, TeamPlayerStarts.Num() - 1);	// 随机索引

			// 打印RandomIndex到屏幕上
			UKismetSystemLibrary::PrintString(this, FString::FromInt(RandomIndex), true, false, FLinearColor::Red, 0.f);

			const FVector SpawnLocation = TeamPlayerStarts[RandomIndex]->GetActorLocation();	// 随机生成的位置
			const FRotator SpawnRotation = TeamPlayerStarts[RandomIndex]->GetActorRotation();	// 随机生成的旋转
			SetActorLocation(SpawnLocation);	// 设置角色位置
			SetActorRotation(SpawnRotation);	// 设置角色旋转
		}
	}
}

void ABlasterCharacter::OnPlayerInitialized()
{
	BlasterPlayerState->AddToScore(0.f);
	BlasterPlayerState->AddToDefeats(0);
	SetTeamColor(BlasterPlayerState->GetTeam());
	SetSpawnPoint();
}

void ABlasterCharacter::RotatePlace(float DeltaTime)
{
	if (Combat && Combat->bHoldingFlag)
	{
		bUseControllerRotationYaw = false;		// 不使用控制器旋转Yaw
		GetCharacterMovement()->bOrientRotationToMovement = true;	// 朝向移动方向
		TurningInPlace = ETurningInPlace::ETIP_NotTurning;	// 不转弯
		return;
	}
	if (Combat && Combat->EquippedWeapon)
	{
		bUseControllerRotationYaw = false;		// 不使用控制器旋转Yaw
		GetCharacterMovement()->bOrientRotationToMovement = true;	// 朝向移动方向
	}
	if (bDisableGamePlay)
	{
		bUseControllerRotationYaw = false;
		TurningInPlace = ETurningInPlace::ETIP_NotTurning;
		return;
	}

	if (GetLocalRole() > ENetRole::ROLE_SimulatedProxy && IsLocallyControlled())
	{
		// 如果是一个本地角色（自己）
		AimOffset(DeltaTime);
	}
	else
	{
		// 如果是代理角色（其他客户端的角色）
		TimeSinceLastMovementReplication += DeltaTime;
		if (TimeSinceLastMovementReplication > 0.25f)
		{
			OnRep_ReplicatedMovement();
		}
		CalculateAO_Pitch();
	}
}

void ABlasterCharacter::SpawnDefaultWeapon()
{
	BlasterGameMode = BlasterGameMode == nullptr ? Cast<ABlasterGameMode>(UGameplayStatics::GetGameMode(this)) : BlasterGameMode;
	UWorld* World = GetWorld();
	if (World && !bElimmed && BlasterGameMode && DefaultWeaponClass)
	{
		AWeapon* StartingWeapon = World->SpawnActor<AWeapon>(DefaultWeaponClass);
		StartingWeapon->bDestroyWeapon = true;	// 对于角色的默认武器，我们希望它在被丢弃时被销毁
		StartingWeapon->bDestroyOnDrop = true;	// 对于角色的默认武器，我们希望它在被丢弃时被销毁
		if (Combat)
		{
			Combat->EquipWeapon(StartingWeapon);
		}
		
	}
}

void ABlasterCharacter::Destroyed()
{
	Super::Destroyed();

	if (ElimBotComponent)
	{
		ElimBotComponent->DestroyComponent();
	}

	BlasterGameMode = BlasterGameMode == nullptr ? Cast<ABlasterGameMode>(UGameplayStatics::GetGameMode(this)) : BlasterGameMode;
	const bool bMatchNotInProgress = BlasterGameMode && BlasterGameMode->GetMatchState() != MatchState::InProgress;

	if (Combat && Combat->EquippedWeapon && bMatchNotInProgress)
	{
		Combat->EquippedWeapon->Destroy();
	}
}

void ABlasterCharacter::SetBacktrackingTime(float BacktrackingTime, float CostTime)
{
	if (LagCompensation)
	{
		LagCompensation->ServerBacktrackTime(BacktrackingTime, CostTime);
	}
}

void ABlasterCharacter::MulticastGainedTheCrown_Implementation()
{
	if (!CrowSystem) return;
	if (CrowComponent == nullptr)
	{
		CrowComponent = UNiagaraFunctionLibrary::SpawnSystemAttached(
			CrowSystem, 
			GetMesh(),
			FName(),
			GetActorLocation() + FVector(0.f, 0.f, 110.f),
			GetActorRotation(),
			EAttachLocation::KeepWorldPosition,		// 保持世界位置
			false
			);
	}
	if (CrowComponent)
	{
		CrowComponent->Activate();	// 激活
	}
}

void ABlasterCharacter::MulticastLostTheCrown_Implementation()
{
	if (CrowComponent)
	{
		CrowComponent->DestroyComponent();	// 销毁组件
	}
}

void ABlasterCharacter::SetTeamColor(ETeam Team)
{
	if (GetMesh() == nullptr || DefaultMaterialInstance == nullptr) return;

	switch (Team)
	{
		case ETeam::ET_NoTeam:
			GetMesh()->SetMaterial(0, DefaultMaterialInstance);	// 设置默认材质
			DissolveMaterialInstance = DefaultDissolveMaterialInstance;		// 设置溶解材质
			break;
		case ETeam::ET_RedTeam:
			GetMesh()->SetMaterial(0, RedMaterialInstance);		// 设置红队材质
			DissolveMaterialInstance = RedDissolveMaterialInstance;			// 设置红队溶解材质
			break;
		case ETeam::ET_BlueTeam:
			GetMesh()->SetMaterial(0, BlueMaterialInstance);		// 设置蓝队材质
			DissolveMaterialInstance = BlueDissolveMaterialInstance;		// 设置蓝队溶解材质
			break;
		default: break;
	}
}

void ABlasterCharacter::ImpulseCharacter()
{
	if (GetCharacterMovement() == nullptr) return;

	// 计算角色的速度
	FVector Impulse = GetActorForwardVector() * 1000.f;
	// 添加冲量
	GetCharacterMovement()->AddImpulse(Impulse, true);
}

// Called when the game starts or when spawned
void ABlasterCharacter::BeginPlay()
{
	Super::BeginPlay();

	SpawnDefaultWeapon();	// 角色生成默认武器

	UpdateHUDAmmo();		// 更新HUD弹药数量
	UpdateHUDHealth();
	UpdateHUDShield();

	BeforeDamageHealth = Health;
	AfterHealHealth = 0.f;
	UpdateHUDHealthNative();

	if (HasAuthority())
	{
		// 将角色受到的伤害动态绑定到我们的处理函数ReceiveDamage上
		OnTakeAnyDamage.AddDynamic(this, &ABlasterCharacter::ReceiveDamage);
	}

	if (AttachedGrenade)
	{
		AttachedGrenade->SetVisibility(false);
	}
}

// Called every frame
void ABlasterCharacter::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	RotatePlace(DeltaTime);

	DamageRampUp(DeltaTime);

	HidCameraIfCharacterClose();
	PollInit();
}

void ABlasterCharacter::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	// 这里就是我们需要注册要复制重叠武器变量的地方
	DOREPLIFETIME_CONDITION(ABlasterCharacter, OverlappingWeapon, COND_OwnerOnly);	// 只有所有者才会复制,这样就不会出现武器重叠的bug了
	DOREPLIFETIME(ABlasterCharacter, Health);	// 复制血量
	DOREPLIFETIME(ABlasterCharacter, BeforeDamageHealth);	// 复制血量
	DOREPLIFETIME(ABlasterCharacter, AfterHealHealth);	// 复制血量
	DOREPLIFETIME(ABlasterCharacter, bDisableGamePlay);	// 复制是否禁用游戏
	DOREPLIFETIME(ABlasterCharacter, Shield);	// 复制护盾
}

void ABlasterCharacter::PostInitializeComponents()
{
	Super::PostInitializeComponents();
	if (Combat)
	{
		Combat->Character = this;
	}
	if (Buff)
	{
		Buff->Character = this;
		Buff->SetInitialSpeed(GetCharacterMovement()->MaxWalkSpeed, GetCharacterMovement()->MaxWalkSpeedCrouched);

		Buff->SetInitialJumpZVelocity(GetCharacterMovement()->JumpZVelocity);	// 设置初始跳跃速度
	}
	if (LagCompensation)
	{
		LagCompensation->Character = this;
		if (Controller)
		{
			LagCompensation->Controller = Cast<ABlasterPlayerController>(Controller);
		}
	}
}

void ABlasterCharacter::PlayFireMontage(bool bAiming)
{
	if (Combat == nullptr || Combat->EquippedWeapon == nullptr) return;

	UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();

	if (AnimInstance && FireWeaponMontage)
	{
		AnimInstance->Montage_Play(FireWeaponMontage);
		FName SectionName;
		SectionName = bAiming ? FName("Rifle_Aim") : FName("Rifle_Hip");
		AnimInstance->Montage_JumpToSection(SectionName);
	}
}

void ABlasterCharacter::PlayReloadMontage()
{
	if (Combat == nullptr || Combat->EquippedWeapon == nullptr) return;

	UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();

	if (AnimInstance && ReloadMontage)
	{
		AnimInstance->Montage_Play(ReloadMontage);
		FName SectionName;
		switch (Combat->EquippedWeapon->GetWeaponType())
		{
		case EWeaponType::EWT_AssaultRifle:
			SectionName = FName("Rifle");
			break;
		case EWeaponType::EWT_RocketLauncher:
			SectionName = FName("RocketLauncher");
			break;
		case EWeaponType::EWT_Pistol:
			SectionName = FName("Pistol");
			break;
		case EWeaponType::EWT_SubmachineGun:
			SectionName = FName("Pistol");
			break;
		case EWeaponType::EWT_Shotgun:
			SectionName = FName("Shotgun");
			break;
		case EWeaponType::EWT_SniperRifle:
			SectionName = FName("SniperRifle");
			break;
		case EWeaponType::EWT_GrenadeLauncher:
			SectionName = FName("GrenadeLauncher");
			break;
		default: break;
		}

		AnimInstance->Montage_JumpToSection(SectionName);
	}
}

void ABlasterCharacter::PlaySwapWeaponMontage() const
{
	UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();

	if (AnimInstance && SwapWeaponMontage)
	{
		AnimInstance->Montage_Play(SwapWeaponMontage);
	}
}

void ABlasterCharacter::PlayElimMontage()
{
	UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();

	if (AnimInstance && ElimMontage)
	{
		AnimInstance->Montage_Play(ElimMontage);
	}
}

void ABlasterCharacter::PlayHitReactMontage() const
{
	if (Combat == nullptr || Combat->EquippedWeapon == nullptr) return;

	UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();

	if (AnimInstance && HitReactMontage)
	{
		AnimInstance->Montage_Play(HitReactMontage);
		FName SectionName("FromFront");
		AnimInstance->Montage_JumpToSection(SectionName);
	}
}

void ABlasterCharacter::PlayThrowGrenadeMontage() const
{
	UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();

	if (AnimInstance && ThrowGrenadeMontage)
	{
		AnimInstance->Montage_Play(ThrowGrenadeMontage);
	}
}

void ABlasterCharacter::GrenadeButtonPressed()
{
	if (Combat)
	{
		if (Combat->bHoldingFlag) return;	// 如果角色正在持有旗帜，那么就不允许扔手榴弹
		Combat->ThrowGrenade();
	}
}

void ABlasterCharacter::ReceiveDamage(AActor* DamageActor, float Damage, const UDamageType* DamageType,
                                      AController* InstigatorController, AActor* DamageCauser)
{
	if (bElimmed) return;	// 如果已经被淘汰，那么就不再接受伤害

	BlasterGameMode = BlasterGameMode == nullptr ? GetWorld()->GetAuthGameMode<ABlasterGameMode>() : BlasterGameMode;

	if (BlasterGameMode)
	{
		Damage = BlasterGameMode->CalculateDamage(Controller, InstigatorController, Damage);

		float DamageToHealth = Damage;	// 伤害值
		if (Shield > 0.f)
		{
			// 如果护盾大于0，那么就先扣除护盾
			const float DamageToShield = FMath::Clamp(Damage, 0.f, Shield);
			Shield -= DamageToShield;
			DamageToHealth = FMath::Clamp(Damage - DamageToShield, 0.f, Health);
		}

		BeforeDamageHealth = Health;
		Health = FMath::Clamp(Health - DamageToHealth, 0.f, MaxHealth);
		DamageRate = DamageToHealth / 1.f;	// 伤害速率

		UpdateHUDHealthNative();
		UpdateHUDHealth();
		UpdateHUDShield();
		PlayHitReactMontage();

		if (Health == 0.f)
		{
			BlasterPlayerController = BlasterPlayerController == nullptr ? Cast<ABlasterPlayerController>(Controller) : BlasterPlayerController;
			ABlasterPlayerController* AttackerController = Cast<ABlasterPlayerController>(InstigatorController);
			BlasterGameMode->PlayerEliminated(this, BlasterPlayerController, AttackerController);
		}
	}
}

void ABlasterCharacter::OnRep_ReplicatedMovement()
{
	Super::OnRep_ReplicatedMovement();

	SimProxiesTurn();
	TimeSinceLastMovementReplication = 0;
}

// Called to bind functionality to input
void ABlasterCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	PlayerInputComponent->BindAxis("MoveForward", this, &ABlasterCharacter::MoveForward);
	PlayerInputComponent->BindAxis("MoveRight", this, &ABlasterCharacter::MoveRight);
	PlayerInputComponent->BindAxis("Turn", this, &ABlasterCharacter::Turn);
	PlayerInputComponent->BindAxis("LookUp", this, &ABlasterCharacter::LookUp);

	// 按键绑定到操作执行函数
	PlayerInputComponent->BindAction("Jump", IE_Pressed, this, &ABlasterCharacter::Jump);
	PlayerInputComponent->BindAction("Equip", IE_Pressed, this, &ABlasterCharacter::EquipButtonPressed);
	PlayerInputComponent->BindAction("Crouch", IE_Pressed, this, &ABlasterCharacter::CrouchButtonPressed);
	PlayerInputComponent->BindAction("Aim", IE_Pressed, this, &ABlasterCharacter::AimButtonPressed);
	PlayerInputComponent->BindAction("Aim", IE_Released, this, &ABlasterCharacter::AimButtonReleased);
	PlayerInputComponent->BindAction("Fire", IE_Pressed, this, &ABlasterCharacter::FireButtonPressed);
	PlayerInputComponent->BindAction("Fire", IE_Released, this, &ABlasterCharacter::FireButtonReleased);

	PlayerInputComponent->BindAction("Reload", IE_Released, this, &ABlasterCharacter::ReloadButtonPressed);
	PlayerInputComponent->BindAction("ThrowGrenade", IE_Released, this, &ABlasterCharacter::GrenadeButtonPressed);
}

void ABlasterCharacter::MoveForward(float Value)
{
	if (bDisableGamePlay) return;
	if (Controller != nullptr && Value != 0.f)
	{
		const FRotator YawRotation(0.f, Controller->GetControlRotation().Yaw, 0.f);
		const FVector Direction(FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X));
		AddMovementInput(Direction, Value);
	}
}

void ABlasterCharacter::MoveRight(float Value)
{
	if (bDisableGamePlay) return;
	if (Controller != nullptr && Value != 0.f)
	{
		const FRotator YawRotation(0.f, Controller->GetControlRotation().Yaw, 0.f);
		const FVector Direction(FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y));
		AddMovementInput(Direction, Value);
	}
}

void ABlasterCharacter::Turn(float Value)
{
	AddControllerYawInput(Value);
}

void ABlasterCharacter::LookUp(float Value)
{
	AddControllerPitchInput(Value);
}

void ABlasterCharacter::EquipButtonPressed()
{
	if (bDisableGamePlay) return;

	if (Combat)
	{
		if (Combat->bHoldingFlag) return;	// 如果角色正在持有旗帜，那么就不允许切换武器

		if (Combat->CombatState == ECombatState::ECS_Unoccupied)
		{
			ServerEquipButtonPressed();
		}
		
		if (Combat->IsValidSwapWeapon() && !HasAuthority() && Combat->CombatState == ECombatState::ECS_Unoccupied && OverlappingWeapon == nullptr)
		{
			PlaySwapWeaponMontage();
			Combat->CombatState = ECombatState::ECS_SwappingWeapon;
			bFinishedSwapping = false;
		}
	}
}

void ABlasterCharacter::CrouchButtonPressed()
{
	if (bDisableGamePlay) return;
	if (Combat && Combat->bHoldingFlag) return;	// 如果角色正在持有旗帜，那么就不允许切换是否蹲伏
	if (bIsCrouched)
	{
		UnCrouch();
	}
	else
	{
		Crouch();
	}
}

void ABlasterCharacter::ReloadButtonPressed()
{
	if (bDisableGamePlay) return;
	if (Combat)
	{
		if (Combat->bHoldingFlag) return;	// 如果角色正在持有旗帜，那么就不允许重新装填
		Combat->Reload();
	}
}

void ABlasterCharacter::AimButtonPressed()
{
	if (bDisableGamePlay) return;
	if (Combat)
	{
		if (Combat->bHoldingFlag) return;	// 如果角色正在持有旗帜，那么就不允许瞄准
		Combat->SetAiming(true);
	}
}

void ABlasterCharacter::AimButtonReleased()
{
	if (bDisableGamePlay) return;
	if (Combat)
	{
		if (Combat->bHoldingFlag) return;	// 如果角色正在持有旗帜，那么就不允许瞄准
		Combat->SetAiming(false);
	}
}

// 当我移动鼠标时，我希望角色的上半部分在站立状态下能按鼠标移动偏移量进行环顾四周的动作，
// 当偏移量超过一定限度（90°），我希望角色进行转向
void ABlasterCharacter::AimOffset(float DeltaTime)
{
	// 如果角色没有装备武器，那么就退出
	if (Combat && Combat->EquippedWeapon == nullptr) return;
	// 获取角色速度矢量
	float Spead = CalculateSpeed();
	bool bIsInAir = GetCharacterMovement()->IsFalling();

	// 当角色处于站立状态，并且没有跳跃（离地）
	if (Spead == 0.0f && !bIsInAir)
	{
		bRotateRootBone = true;
		FRotator CurrentAimRotation = FRotator(0.f, GetBaseAimRotation().Yaw, 0.f);
		FRotator DeltaAimRotation = UKismetMathLibrary::NormalizedDeltaRotator(CurrentAimRotation, StartingAimRotation);
		AO_Yaw = DeltaAimRotation.Yaw;
		// 如果角色没有原地转身动作，那么这个值就直接赋值为 AO_Yaw
		if (TurningInPlace == ETurningInPlace::ETIP_NotTurning)
		{
			InterpAO_Yaw = AO_Yaw;
		}
		// 如果角色有做转身动作，那么就需要对该值进行差值处理，这一步可以放在 TurnInPlace 中去做

		bUseControllerRotationYaw = true;
		// 原地转弯检测
		TurnInPlace(DeltaTime);
	}

	// 跑动或者跳跃（离地）
	if (Spead > 0.f || bIsInAir)
	{
		bRotateRootBone = false;
		// 当我们的角色跑步或者在空中时（当装备了武器的前提下），他会保存每一帧的旋转信息
		// 这个旋转信息将作为一个增量信息传递给上一个if使用
		StartingAimRotation = FRotator(0.f, GetBaseAimRotation().Yaw, 0.f);
		// 同时也应该将AO_Yaw置空清0，因为我们会在上面进行计算
		AO_Yaw = 0.f;
		// 同时一旦我们开始运动，我们就需要继续使用控制器旋转
		bUseControllerRotationYaw = true;
		TurningInPlace = ETurningInPlace::ETIP_NotTurning;
	}

	CalculateAO_Pitch();
}

void ABlasterCharacter::CalculateAO_Pitch()
{
	// 获取仰角并设置
	AO_Pitch = GetBaseAimRotation().Pitch;
	//if (HasAuthority() && !IsLocallyControlled())
	//{
	//	// 利用UE_LOG查看在服务端出现仰角错误bug的数据
	//	UE_LOG(LogTemp, Warning, TEXT("AO_Yaw : %f"), AO_Yaw);
	//	// 可以看到，我们的俯视角低头看地板的时候，我们服务端收到的数据确实270-360之间的数据，这不是我们设定中的我们的【-90,0）
	//}
	// !IsLocallyControlled() 这个判断就是确保不是在本机器上，非本机器就代表经过了RPC，数据被压缩过，需要进行还原映射
	if (AO_Pitch > 90.F && !IsLocallyControlled())
	{
		// 将仰角数据从 [270, 360) 映射到 [-90, 0)
		// 这个映射将会修复因为在 CharacterMovementComponent中，这个组件在GetPackedAngles（获取仰角数据）
		// 这个函数为了将仰角数据（旋转数据）通过RPC网络传输时，为了减少宽带占用，将数据压缩到4字节，
		// 导致我们客户端的俯视角在服务端显示确实抬头的仰视角的bug
		// 在我们的程序编写中，我们习惯的角度控制是例如 -90到90，但是在虚幻引擎中，这个函数在获取这些旋转角度数据时，
		// 他会将其压缩为一个无符号的整形数
		// 这个压缩过程就是通过 FRotator::CompressAxisToShort(Yaw) , FRotator::CompressAxisToShort(Patch)
		// 这两个函数进行的压缩处理，函数原型如下
		///*FORCEINLINE uint32 UCharacterMovementComponent::PackYawAndPitchTo32(const float Yaw, const float Pitch)
		//{
		//	const uint32 YawShort = FRotator::CompressAxisToShort(Yaw);
		//	const uint32 PitchShort = FRotator::CompressAxisToShort(Pitch);
		//	const uint32 Rotation32 = (YawShort << 16) | PitchShort;
		//	return Rotation32;
		//}*/
		// 然后关于 这里主要的执行函数 CompressAxisToShort,原型如下
		//template<typename T>
		//FORCEINLINE uint16 TRotator<T>::CompressAxisToShort(T Angle)
		//{
		//	// map [0->360) to [0->65536) and mask off any winding
		//	return FMath::RoundToInt(Angle * (T)65536.f / (T)360.f) & 0xFFFF;
		//}
		// 从源码中可以看出来，这个函数这里所做的，就是将一个float的角度数据，他的数值范围是[0,360)，
		// (Angle * (T)65536.f / (T)360.f)这串计算得到的结果是一个介于 [0, 65536)之间的浮点值
		// RoundToInt则是进行四舍五入，将浮点数转为整形
		// 我们知道float数据是具有小数点精度的，这些精度信息是需要字节信息来进行存储的，
		// 通过将float数据mask映射到这个范围，并删除这些小数点，我们就得到了一个一个介于 [0, 65536)之间的整形值
		// 而 65535 这个值他的十六进制数正好是 0xFFFF,16bit位的最大整形数
		// 将前面的整形数与 0xFFFF 进行按位与 & 运算，得到的结果就是将传递来的浮点数按360°进行切割。
		// 意思就是，假设你传递进来361，那么在经过计算后，得到的结果其实就是1，这一轮的旋转其实和你旋转1°是一样的效果
		// 这个就是虚幻底层在调用RPC传输旋转角和俯仰角时，为了减少网络开销所做的优化

		// 现在，我们可以知道，我们的旋转被压缩为 [0,360)的格式，当它通过rpc调用后，他会被解压缩，还原回浮点数。
		// 这点就是这里还原，因为它还原使用的是[0,360）的数据，它丢失了我们的负数信息，所以这里我们需要做映射
		// [270, 360) -> [-90, 0)
		// map pitch from [270,260) to [-90,0)
		FVector2D InRange(270.f, 360.f);
		FVector2D OutRange(-90.f, 0.f);
		AO_Pitch = FMath::GetMappedRangeValueClamped(InRange, OutRange, AO_Pitch);	// 映射
	}
}

void ABlasterCharacter::SimProxiesTurn()
{
	if (Combat == nullptr || Combat->EquippedWeapon == nullptr) return;
	bRotateRootBone = false;

	float Spead = CalculateSpeed();
	if (Spead > 0.f)
	{
		TurningInPlace = ETurningInPlace::ETIP_NotTurning;
		return;
	}

	ProxyRotationLastFrame = ProxyRotation;
	ProxyRotation = GetActorRotation();

	ProxyYaw = UKismetMathLibrary::NormalizedDeltaRotator(ProxyRotation, ProxyRotationLastFrame).Yaw;

	if (FMath::Abs(ProxyYaw) > TurnThreshold)
	{
		// 判断是否需要转体
		if (ProxyYaw > TurnThreshold)
		{
			// 向右转
			TurningInPlace = ETurningInPlace::ETIP_Right;
		}
		else if (ProxyYaw < TurnThreshold)
		{
			// 向左转
			TurningInPlace = ETurningInPlace::ETIP_Left;
		}
		else
		{
			TurningInPlace = ETurningInPlace::ETIP_NotTurning;	// 不转体
		}
		return;
	}
	TurningInPlace = ETurningInPlace::ETIP_NotTurning;
}

void ABlasterCharacter::Jump()
{
	if (bDisableGamePlay) return;
	if (Combat && Combat->bHoldingFlag) return;	// 如果角色正在持有旗帜，那么就不允许跳跃
	if (bIsCrouched)
	{
		UnCrouch();
	}
	else
	{
		Super::Jump();
	}
}

void ABlasterCharacter::FireButtonPressed()
{
	if (bDisableGamePlay) return;
	if (Combat)
	{
		if (Combat->bHoldingFlag) return;	// 如果角色正在持有旗帜，那么就不允许开火
		Combat->FireButtonPressed(true);
	}
}

void ABlasterCharacter::FireButtonReleased()
{
	if (bDisableGamePlay) return;
	if (Combat)
	{
		if (Combat->bHoldingFlag) return;	// 如果角色正在持有旗帜，那么就不允许开火
		Combat->FireButtonPressed(false);
	}
}

void ABlasterCharacter::OnRep_OverlappingWeapon(AWeapon* LastWeapon)
{
	if (OverlappingWeapon)
	{
		OverlappingWeapon->ShowPickupWidget(true);
	}

	if (LastWeapon)
	{
		LastWeapon->ShowPickupWidget(false);
	}
}

void ABlasterCharacter::ServerEquipButtonPressed_Implementation()
{
	if (Combat)
	{
		if (OverlappingWeapon)
		{
			Combat->EquipWeapon(OverlappingWeapon);
		}
		else if (Combat->IsValidSwapWeapon())
		{
			Combat->SwapWeapon();
		}
		
	}
}

void ABlasterCharacter::TurnInPlace(float DeltaTime)
{
	// 如果 AO_Yaw大于90，我们应该向右转。小于-90，应该向左转
	if (AO_Yaw > 90.f)
	{
		TurningInPlace = ETurningInPlace::ETIP_Right;
	}
	else if (AO_Yaw < -90.f)
	{
		TurningInPlace = ETurningInPlace::ETIP_Left;
	}
	if (TurningInPlace != ETurningInPlace::ETIP_NotTurning)
	{
		// 差值处理，最后一个参数决定了你的转身动作有多快(值越小，动作越灵敏越快）
		InterpAO_Yaw = FMath::FInterpTo(InterpAO_Yaw, 0.0f, DeltaTime, 4.f);
		AO_Yaw = InterpAO_Yaw;
		if (FMath::Abs(AO_Yaw) < 15.f)
		{
			// 如果原地转弯低于15°,那么就不再进行转弯
			TurningInPlace = ETurningInPlace::ETIP_NotTurning;
			StartingAimRotation = FRotator(0.f, GetBaseAimRotation().Yaw, 0.0f);
		}
	}
}

void ABlasterCharacter::HidCameraIfCharacterClose()
{
	if (!IsLocallyControlled()) return;

	if ((FollowCamera->GetComponentLocation() - GetActorLocation()).Size() < CameraThreshold)
	{
		GetMesh()->SetVisibility(false);
		if (Combat && Combat->EquippedWeapon && Combat->EquippedWeapon->GetWeaponMesh())
		{
			Combat->EquippedWeapon->GetWeaponMesh()->bOwnerNoSee = true;	// 隐藏主武器
		}
		if (Combat && Combat->SecondaryWeapon && Combat->SecondaryWeapon->GetWeaponMesh())
		{
			Combat->SecondaryWeapon->GetWeaponMesh()->bOwnerNoSee = true;	// 隐藏副武器
		}
	}
	else
	{
		GetMesh()->SetVisibility(true);
		if (Combat && Combat->EquippedWeapon && Combat->EquippedWeapon->GetWeaponMesh())
		{
			Combat->EquippedWeapon->GetWeaponMesh()->bOwnerNoSee = false;
		}
		if (Combat && Combat->SecondaryWeapon && Combat->SecondaryWeapon->GetWeaponMesh())
		{
			Combat->SecondaryWeapon->GetWeaponMesh()->bOwnerNoSee = false;
		}
	}
}

float ABlasterCharacter::CalculateSpeed()
{
	// 获取角色速度矢量
	FVector Velocity = GetVelocity();
	Velocity.Z = 0.f;
	return Velocity.Size();
}

void ABlasterCharacter::OnRep_Health(float LastHealth)
{
	UpdateHUDHealth();	// 更新HUD血量
	if (Health < LastHealth)
	{
		PlayHitReactMontage();	// 播放受伤动画
	}
}

void ABlasterCharacter::OnRep_BeforeHealth(float LastHealth)
{
	UpdateHUDHealthNative();	// 更新HUD血量
}

void ABlasterCharacter::OnRep_AfterHealth(float LastHealth)
{
	UpdateHUDHealthNative();	// 更新HUD血量
}

void ABlasterCharacter::OnRep_Shield(float LastShield)
{
	UpdateHUDShield();	// 更新HUD护盾
	if (Shield < LastShield)
	{
		PlayHitReactMontage();	// 播放受伤动画
	}
}

void ABlasterCharacter::Elim(bool bPlayerLeftGame)
{
	DropOrDestroyWeapon();

	MulticastElim(bPlayerLeftGame);
}

void ABlasterCharacter::DropOrDestroyWeapon()
{
	if (Combat && Combat->EquippedWeapon)
	{
		DropOrDestroyWeapon(Combat->EquippedWeapon);
	}
	if (Combat && Combat->SecondaryWeapon)
	{
		DropOrDestroyWeapon(Combat->SecondaryWeapon);
	}
	if (Combat && Combat->TheFlag)
	{
		Combat->TheFlag->Dropped();
	}
}

void ABlasterCharacter::DropOrDestroyWeapon(AWeapon* Weapon)
{
	if (Weapon)
	{
		if (Weapon->bDestroyOnDrop || Weapon->bDestroyWeapon)
		{
			Weapon->Destroy();
		}
		else
		{
			Weapon->Dropped();
		}
	}
}

void ABlasterCharacter::ElimTimerFinished()
{
	BlasterGameMode = BlasterGameMode == nullptr ? GetWorld()->GetAuthGameMode<ABlasterGameMode>() : BlasterGameMode;
	if (BlasterGameMode && !bLeftGame)
	{
		BlasterGameMode->RequestRespawn(this, Controller);
	}
	if (bLeftGame && IsLocallyControlled())
	{
		OnLeftGame.Broadcast();
	}
}

void ABlasterCharacter::MulticastElim_Implementation(bool bPlayerLeftGame)
{
	bLeftGame = bPlayerLeftGame;

	if (BlasterPlayerController)
	{
		BlasterPlayerController->SetHUDWeaponAmmo(0);
	}

	bElimmed = true;
	PlayElimMontage();

	// 开始角色溶解效果
	if (DissolveMaterialInstance)
	{
		DynamicDissolveMaterialInstance = UMaterialInstanceDynamic::Create(DissolveMaterialInstance, this);
		GetMesh()->SetMaterial(0, DynamicDissolveMaterialInstance);

		DynamicDissolveMaterialInstance->SetScalarParameterValue(TEXT("Dissolve"), 0.55f);
		DynamicDissolveMaterialInstance->SetScalarParameterValue(TEXT("Glow"), 200.f);
	}
	StartDissolve();

	// 禁用角色移动（阻止WASD按键移动）
	// GetCharacterMovement()->DisableMovement();
	// 立即停止移动 (阻止旋转鼠标带来的人物转体等）
	// GetCharacterMovement()->StopMovementImmediately();
	// 禁用开火
	bDisableGamePlay = true;
	GetCharacterMovement()->DisableMovement();
	if (Combat)
	{
		Combat->FireButtonPressed(false);
	}
	// 禁用碰撞
	GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	GetMesh()->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	AttachedGrenade->SetCollisionEnabled(ECollisionEnabled::NoCollision);	// 禁用手雷碰撞

	// 生成Elim Bot
	if (ElimBotEffect)
	{
		FVector ElimBotSpawnPoint(GetActorLocation().X, GetActorLocation().Y, GetActorLocation().Z + 200.f);
		ElimBotComponent = UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ElimBotEffect, ElimBotSpawnPoint, GetActorRotation());
	}
	if (ElimBotSound)
	{
		UGameplayStatics::SpawnSoundAtLocation(this, ElimBotSound, GetActorLocation());
	}

	const bool bHideSniperScope = IsLocallyControlled() && Combat && Combat->bAiming && Combat->EquippedWeapon && Combat->EquippedWeapon->GetWeaponType() == EWeaponType::EWT_SniperRifle;
	if (bHideSniperScope)
	{
		ShowSniperScopeWidget(false);
	}

	if (CrowComponent)
	{
		CrowComponent->DestroyInstance();
	}

	// 设置复活倒计时
	GetWorldTimerManager().SetTimer(
		ElimTimer,
		this,
		&ABlasterCharacter::ElimTimerFinished,
		ElimDelay
	);
}

void ABlasterCharacter::UpdateDissolveMaterial(float DissolveValue)
{
	if (DynamicDissolveMaterialInstance)
	{
		DynamicDissolveMaterialInstance->SetScalarParameterValue(TEXT("Dissolve"), DissolveValue);
	}
}

void ABlasterCharacter::StartDissolve()
{
	DissolveTrack.BindDynamic(this, &ABlasterCharacter::UpdateDissolveMaterial);
	if (DissolveCurve && DissolveTimeline)
	{
		DissolveTimeline->AddInterpFloat(DissolveCurve, DissolveTrack);
		DissolveTimeline->Play();
	}
}

void ABlasterCharacter::DamageRampUp(float DeltaTime)
{
	const float DamageThisFrame = DamageRate * DeltaTime;	// 计算本帧伤害量
	BeforeDamageHealth = FMath::Clamp(BeforeDamageHealth - DamageThisFrame, Health, MaxHealth);	// 计算伤害后的血量
	UpdateHUDHealthNative();	// 更新HUD血量

	if (BeforeDamageHealth <= Health)
	{
		DamageRate = 0.f;
	}
}

void ABlasterCharacter::ServerLeftGame_Implementation()
{
	BlasterGameMode = BlasterGameMode == nullptr ? GetWorld()->GetAuthGameMode<ABlasterGameMode>() : BlasterGameMode;
	BlasterPlayerState = BlasterPlayerState == nullptr ? GetPlayerState<ABlasterPlayerState>() : BlasterPlayerState;
	if (BlasterGameMode && BlasterPlayerState)
	{
		BlasterGameMode->PlayerLeftGame(BlasterPlayerState);
	}
}

void ABlasterCharacter::SetOverlappingWeapon(AWeapon* Weapon)
{
	if (OverlappingWeapon)
	{
		OverlappingWeapon->ShowPickupWidget(false);
	}

	OverlappingWeapon = Weapon;

	if (IsLocallyControlled())
	{
		if (OverlappingWeapon)
		{
			OverlappingWeapon->ShowPickupWidget(true);
		}
	}
}

bool ABlasterCharacter::IsWeaponEquipped()
{
	return (Combat && Combat->EquippedWeapon);
}

bool ABlasterCharacter::IsAiming()
{
	return (Combat && Combat->bAiming);
}

AWeapon* ABlasterCharacter::GetEquippedWeapon()
{
	if (Combat == nullptr) return nullptr;
	return Combat->EquippedWeapon;
}

FVector ABlasterCharacter::GetHitTarget() const
{
	if (Combat == nullptr) return FVector();

	return Combat->HitTarget;
}

ECombatState ABlasterCharacter::GetCombatState() const
{
	if (Combat == nullptr) return ECombatState::ECS_MAX;

	return Combat->CombatState;
}

bool ABlasterCharacter::IsLocalReloading() const
{
	if (Combat == nullptr) return false;

	return Combat->bLocalReloading;;
}

bool ABlasterCharacter::IsHoldingFlag() const
{
	if (Combat == nullptr) return false;

	return Combat->bHoldingFlag;
}

ETeam ABlasterCharacter::GetTeam()
{
	BlasterPlayerState = BlasterPlayerState == nullptr ? GetPlayerState<ABlasterPlayerState>() : BlasterPlayerState;

	if (BlasterPlayerState)
	{
		return BlasterPlayerState->GetTeam();
	}
	return ETeam::ET_NoTeam;
}

void ABlasterCharacter::SetIsHoldingFlag(bool bCond)
{
	if (Combat)
	{
		Combat->bHoldingFlag = bCond;
	}
}

```

`Source/Blaster/Character/BlasterCharacter.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NiagaraComponent.h"
#include "Blaster/BlasterComponents/CombatComponent.h"
#include "GameFramework/Character.h"
#include "Blaster/BlasterTypes/TurningInPlace.h"
#include "Blaster/Interface/InteractWithCrosshairsInterface.h"
#include "Blaster/BlasterTypes/CombatState.h"
#include "Blaster/BlasterTypes/Team.h"
#include "Components/TimelineComponent.h"
#include "BlasterCharacter.generated.h"

DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnLeftGame);	// 离开游戏委托

UCLASS()
class BLASTER_API ABlasterCharacter : public ACharacter, public IInteractWithCrosshairsInterface
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	ABlasterCharacter();

	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// Called to bind functionality to input
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;		// 设置玩家输入组件

	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;	// 获取生命周期复制属性

	virtual void PostInitializeComponents() override;	// 初始化组件

	// 播放开火蒙太奇动画
	void PlayFireMontage(bool bAiming);

	// 播放换弹蒙太奇动画
	void PlayReloadMontage();

	// 播放交换武器蒙太奇动画
	void PlaySwapWeaponMontage() const;

	// 播放死亡飞升蒙太奇动画
	void PlayElimMontage();

	// 播放人物受击的蒙太奇动画
	void PlayHitReactMontage() const;

	// 播放投掷手榴弹的蒙太奇动画
	void PlayThrowGrenadeMontage() const;

	//// 人物受击rpc函数（多播）
	//UFUNCTION(NetMulticast, Unreliable)
	//	void MuticastHit();

	virtual void OnRep_ReplicatedMovement() override;

	void Elim(bool bPlayerLeftGame);		// 角色被击败

	void DropOrDestroyWeapon();		// 丢弃或销毁武器
	void DropOrDestroyWeapon(AWeapon* Weapon);		// 丢弃或销毁武器

	UFUNCTION(NetMulticast, Reliable)
	void MulticastElim(bool bPlayerLeftGame);		// 多播击败

	virtual void Destroyed() override;

	void SetAfterHealHealth(float Clamp) { AfterHealHealth = Clamp; }
	void SetBacktrackingTime(float BacktrackingTime, float CostTime);		// 将玩家回溯到指定时间

	UPROPERTY(Replicated)
	bool bDisableGamePlay = false;

	// 显示狙击步枪的瞄准镜	ui
	UFUNCTION(BlueprintImplementableEvent)
	void ShowSniperScopeWidget(bool bShowScope);

	void UpdateHUDHealth();	// 更新HUD血量

	void UpdateHUDHealthNative();	// 更新HUD伤害

	void UpdateHUDShield();	// 更新HUD护盾

	void UpdateHUDAmmo();	// 更新HUD弹药

	UPROPERTY()
	TMap<FName, class UBoxComponent*> HitCollisionBoxes;	// 命中盒子

	bool bFinishedSwapping = false;	// 是否完成交换

	FOnLeftGame OnLeftGame;	// 离开游戏委托

	UFUNCTION(Server, Reliable)
	void ServerLeftGame();	// 服务端离开游戏

	UFUNCTION(NetMulticast, Reliable)
	void MulticastGainedTheCrown();	// 多播获得王冠

	UFUNCTION(NetMulticast, Reliable)
	void MulticastLostTheCrown();	// 多播失去王冠

	UFUNCTION()
	void SetTeamColor(ETeam Team);	// 设置队伍颜色

	void ImpulseCharacter();	// 推开周围的角色

	void SetSpawnPoint();		// 设置出生点

	void OnPlayerInitialized();	// 玩家初始化

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

	// 各种操作映射函数

	void MoveForward(float Value);

	void MoveRight(float Value);

	void Turn(float Value);

	void LookUp(float Value);

	// 按E装备武器
	void EquipButtonPressed();

	// 按ctrl蹲伏和起身
	void CrouchButtonPressed();

	void ReloadButtonPressed();	// 按R换弹

	// 鼠标右键瞄准
	void AimButtonPressed();

	// 松开右键瞄准
	void AimButtonReleased();
	void CalculateAO_Pitch();	// 计算目标偏移量 pitch 轴

	// 设置目标偏移量
	void AimOffset(float DeltaTime);

	// 模拟代理
	void SimProxiesTurn();

	// 原本Actor的jump逻辑是，在蹲下的时候是不可以跳跃的，为了实现蹲下的时候，按空格可以取消蹲伏，这里需要重写jump
	virtual void Jump() override;

	// 点击开火（鼠标左键按下）
	void FireButtonPressed();
	// 点击开火（鼠标左键抬起）
	void FireButtonReleased();


	// 手榴弹投掷按钮按下（T）
	void GrenadeButtonPressed();

	// 角色受到伤害处理函数
	UFUNCTION()
	void ReceiveDamage(AActor* DamageActor, float Damage, const UDamageType* DamageType, class AController* InstigatorController, AActor* DamageCauser);

	// 初始化HUD
	void PollInit();

	// 原地旋转
	void RotatePlace(float DeltaTime);

	// 生成默认武器
	void SpawnDefaultWeapon();

private:
	// 添加弹簧臂和摄像机

	// 属性宏，让其在任何地方可见，想将相机，吊杆归为一类，叫做相机
	UPROPERTY(VisibleAnywhere, Category = Camera)
	class USpringArmComponent* CameraBoom;	// 吊杆

	UPROPERTY(VisibleAnywhere, Category = Camera)
	class UCameraComponent* FollowCamera;	// 摄像机

	// 既然我们要从蓝图访问我们的部件，至少需要设置蓝图只读
	// 如果将私有变量设置蓝图只读，那么就需要允许私人访问，这意味着将这个变量暴露给蓝图
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))
	class UWidgetComponent* OverheadWidget;	// 顶部小部件

	// 武器类的前向声明
	// 我们想要复制这个变量，这意味着当它在服务器上发生变化时，我们想要同步在客户端上也进行更改，我们可以复制指向武器的指针
	UPROPERTY(ReplicatedUsing = OnRep_OverlappingWeapon)
	class AWeapon* OverlappingWeapon;

	UFUNCTION()
	void OnRep_OverlappingWeapon(AWeapon* LastWeapon);	// 当OverlappingWeapon发生变化时，调用该函数

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))
	class UCombatComponent* Combat;		// 战斗组件

	UPROPERTY(VisibleAnywhere)
	class UBuffComponent* Buff;		// buff组件

	UFUNCTION(Server, Reliable)
	void ServerEquipButtonPressed();

	UPROPERTY(VisibleAnywhere)
	class ULagCompensationComponent* LagCompensation;		// 服务端倒带组件（延迟补偿组件）

	float AO_Yaw;	// 目标偏移量 yaw 轴
	float InterpAO_Yaw;	// 插值目标偏移量 yaw 轴

	float AO_Pitch;	// 目标偏移量 pitch 轴

	// 起始旋转信息
	FRotator StartingAimRotation;

	ETurningInPlace TurningInPlace;		// 旋转状态 0：不旋转 1：旋转 2：旋转完成

	void TurnInPlace(float DeltaTime);		// 旋转

	// 武器开火的动画蒙太奇
	UPROPERTY(EditAnywhere, Category = Combat)
	class UAnimMontage* FireWeaponMontage;

	// 换弹动作蒙太奇动画
	UPROPERTY(EditAnywhere, Category = Combat)
	class UAnimMontage* ReloadMontage;

	// 人物受击动作的动画蒙太奇
	UPROPERTY(EditAnywhere, Category = Combat)
	class UAnimMontage* HitReactMontage;

	// 角色死亡飞升的动画蒙太奇
	UPROPERTY(EditAnywhere, Category = Combat)
	class UAnimMontage* ElimMontage;

	// 投掷手榴弹的动画蒙太奇
	UPROPERTY(EditAnywhere, Category = Combat)
	class UAnimMontage* ThrowGrenadeMontage;

	// 交换武器的动画蒙太奇
	UPROPERTY(EditAnywhere, Category = Combat)
	UAnimMontage* SwapWeaponMontage;

	// 如果角色靠太近就隐藏摄像头
	void HidCameraIfCharacterClose();

	UPROPERTY(EditAnywhere)
	float CameraThreshold = 200.f;

	// 是否旋转根骨骼
	bool bRotateRootBone;

	float TurnThreshold = 0.5f;
	FRotator ProxyRotationLastFrame;
	FRotator ProxyRotation;
	float ProxyYaw;
	float TimeSinceLastMovementReplication;
	float CalculateSpeed();

	/*
	 * 用于服务端倒带的命中盒子
	 */
	UPROPERTY(VisibleAnywhere)
	UBoxComponent* head;	// 头盒子

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* pelvis;	// 骨盆盒子

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* spine_02;	// 脊椎盒子

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* spine_03;	// 脊椎盒子

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* upperarm_l;	// 上臂盒子 左

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* upperarm_r;	// 上臂盒子 右

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* lowerarm_l;	// 下臂盒子 左

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* lowerarm_r;	// 下臂盒子 右

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* hand_l;	// 手臂盒子 左

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* hand_r;	// 手臂盒子 右

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* backpack;	// 背包

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* blanket;	// 背包毯子

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* thigh_l;	// 大腿盒子 左

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* thigh_r;	// 大腿盒子 右

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* calf_l;	// 小腿 左

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* calf_r;	// 小腿 右

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* foot_l;	// 脚盒子 左

	UPROPERTY(VisibleAnywhere)
	UBoxComponent* foot_r;	// 脚盒子 右

	/*
	 * 玩家血量
	 */

	UPROPERTY(EditAnywhere, Category = "Player Stats")
	float MaxHealth = 100.f;

	// 玩家血量，可被血量通知函数复制
	UPROPERTY(ReplicatedUsing = OnRep_Health, VisibleAnywhere, Category = "Player Stats")
	float Health = 100.f;

	// 将玩家血量更新给客户端
	UFUNCTION()
	void OnRep_Health(float LastHealth);

	// 将玩家血量更新给客户端
	UFUNCTION()
	void OnRep_BeforeHealth(float LastHealth);

	UFUNCTION()
	void OnRep_AfterHealth(float LastHealth);

	/*
	 * 玩家护盾
	 */
	UPROPERTY(EditAnywhere, Category = "Player Stats")
	float MaxShield = 100.f;

	UPROPERTY(ReplicatedUsing = OnRep_Shield, VisibleAnywhere, Category = "Player Stats")
	float Shield = 0.f;

	UFUNCTION()
	void OnRep_Shield(float LastShield);

	UPROPERTY()
	class ABlasterPlayerController* BlasterPlayerController;

	// 玩家是否被击败（死亡）
	bool bElimmed = false;

	// 玩家死亡复活倒计时时钟
	FTimerHandle ElimTimer;

	// 当复活倒计时结束时的处理逻辑
	void ElimTimerFinished();

	// 复活时间
	UPROPERTY(EditDefaultsOnly)
	float ElimDelay = 3.f;

	/*
	 * 角色溶解效果 Elim Dissolve Effect
	 */
	UPROPERTY(VisibleAnywhere)
	UTimelineComponent* DissolveTimeline;

	FOnTimelineFloat DissolveTrack;

	UFUNCTION()
	void UpdateDissolveMaterial(float DissolveValue);

	void StartDissolve();

	UPROPERTY(EditAnywhere)
	UCurveFloat* DissolveCurve;

	// 在游戏运行时更改的动态实例，这个实例在这里将会是材质实例
	// 动态溶解材质，用于存储动态创建的材质实例
	UPROPERTY(VisibleAnywhere, Category = Elim)
	UMaterialInstanceDynamic* DynamicDissolveMaterialInstance;

	// 将分配给角色蓝图的材质实例
	UPROPERTY(VisibleAnywhere, Category = Elim)
	UMaterialInstance* DissolveMaterialInstance;

	/*
	 * 队伍颜色
	 */
	UPROPERTY(EditAnywhere, Category = Elim)
	UMaterialInstance* RedDissolveMaterialInstance;		// 红队溶解材质实例

	UPROPERTY(EditAnywhere, Category = Elim)
	UMaterialInstance* RedMaterialInstance;		// 红队材质实例

	UPROPERTY(EditAnywhere, Category = Elim)
	UMaterialInstance* BlueDissolveMaterialInstance;	// 蓝队溶解材质实例

	UPROPERTY(EditAnywhere, Category = Elim)
	UMaterialInstance* BlueMaterialInstance;		// 蓝队材质实例

	UPROPERTY(EditAnywhere, Category = Elim)
	UMaterialInstance* DefaultDissolveMaterialInstance;		// 默认溶解材质实例

	UPROPERTY(EditAnywhere, Category = Elim)
	UMaterialInstance* DefaultMaterialInstance;		// 默认材质实例

	/*
	 * 排名王冠
	 */
	UPROPERTY(EditAnywhere)
	class UNiagaraSystem* CrowSystem;

	UPROPERTY()
	UNiagaraComponent* CrowComponent;

	/*
	 * Elim Bot
	 */

	UPROPERTY(EditAnywhere)
	UParticleSystem* ElimBotEffect;

	UPROPERTY(EditAnywhere)
	UParticleSystemComponent* ElimBotComponent;

	UPROPERTY(EditAnywhere)
	class USoundCue* ElimBotSound;

	UPROPERTY()
	class ABlasterPlayerState* BlasterPlayerState;

	/**
	 * 手榴弹
	 */
	UPROPERTY(VisibleAnywhere)
	UStaticMeshComponent* AttachedGrenade;

	/*
	 * 角色默认武器
	 */
	UPROPERTY(EditAnywhere)
	TSubclassOf<class AWeapon> DefaultWeaponClass;

	/*
	 * 扣血效果
	 */
	UPROPERTY(ReplicatedUsing = OnRep_BeforeHealth, VisibleAnywhere, Category = "Player Stats")
	float BeforeDamageHealth = 100.0f;	// 扣血前的血量

	/*
	 * 治疗效果
	 */
	UPROPERTY(ReplicatedUsing = OnRep_AfterHealth, VisibleAnywhere, Category = "Player Stats")
	float AfterHealHealth = 0.f;	// 治疗后的血量

	bool bDamaging = false;		// 是否正在扣血
	float DamageRate = 0.0f;	// 扣血速率
	float AmountToDamage = 0.0f;	// 扣血量

	void DamageRampUp(float DeltaTime);	// 扣血速率上升

	/*
	 * 离开游戏
	 */
	bool bLeftGame = false;	// 是否离开游戏

	UPROPERTY()
	class ABlasterGameMode* BlasterGameMode;	// 游戏模式

public:
	void SetOverlappingWeapon(AWeapon* Weapon);
	// 是否装备武器
	bool IsWeaponEquipped();
	bool IsAiming();
	FORCEINLINE float GetAO_Yaw() { return AO_Yaw; }
	FORCEINLINE float GetAO_Pitch() { return AO_Pitch; }
	AWeapon* GetEquippedWeapon();
	FORCEINLINE ETurningInPlace GetTurningInPlace() const { return TurningInPlace; }
	FVector GetHitTarget() const;
	FORCEINLINE UCameraComponent* GetFollowCamera() const { return FollowCamera; }
	FORCEINLINE bool ShouldRotateRootBone() const { return bRotateRootBone; }
	FORCEINLINE bool IsElimmed() const { return bElimmed; }
	FORCEINLINE float GetHealth() const { return Health; }
	FORCEINLINE void SetHealth(float NewHealth) { Health = NewHealth; }
	FORCEINLINE float GetMaxHealth() const { return MaxHealth; }
	ECombatState GetCombatState() const;
	FORCEINLINE UCombatComponent* GetCombat() const { return Combat; }
	FORCEINLINE bool GetDisableGamePlay() const { return bDisableGamePlay; }
	FORCEINLINE UAnimMontage* GetReloadMontage() const { return ReloadMontage; }
	FORCEINLINE UStaticMeshComponent* GetAttachedGrenade() const { return AttachedGrenade; }
	FORCEINLINE UBuffComponent* GetBuff() const { return Buff; }
	FORCEINLINE float GetShield() const { return Shield; }
	FORCEINLINE float GetMaxShield() const { return MaxShield; }
	FORCEINLINE void SetShield(float NewShield) { Shield = NewShield; }
	bool IsLocalReloading() const;
	FORCEINLINE ULagCompensationComponent* GetLagCompensation() const { return LagCompensation; }
	bool IsHoldingFlag() const;
	ETeam GetTeam();
	void SetIsHoldingFlag(bool bCond);		// 设置是否持有旗帜
};

```

`Source/Blaster/GameMode/BlasterGameMode.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "BlasterGameMode.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/GameState/BlasterGameState.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "Blaster/PlayerState/BlasterPlayerState.h"
#include "Engine/PawnIterator.h"
#include "GameFramework/PlayerStart.h"
#include "Kismet/GameplayStatics.h"
#include "Kismet/KismetSystemLibrary.h"

namespace MatchState
{
	const FName Cooldown = FName("Cooldown");
}

ABlasterGameMode::ABlasterGameMode()
{
	// 将其设置为true时，游戏模式将会停留在等待开始的状态，它会为所有玩家生成一个默认设置，他们可以使用它在地图中飞行，没有网格
	bDelayedStart = true;

}

void ABlasterGameMode::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	// 如果游戏状态为等待开始
	if (MatchState == MatchState::WaitingToStart)
	{
		CountdownTime = WarmupTime - GetWorld()->GetTimeSeconds() + LevelStartingTime;
		if (CountdownTime <= 0.f)
		{
			StartMatch();
		}
	}
	else if (MatchState == MatchState::InProgress)
	{
		CountdownTime = WarmupTime + MatchTime - GetWorld()->GetTimeSeconds() + LevelStartingTime;
		if (CountdownTime <= 0.f)
		{
			SetMatchState(MatchState::Cooldown);

		}
	}
	else if (MatchState == MatchState::Cooldown)
	{
		CountdownTime = CooldownTime + WarmupTime + MatchTime - GetWorld()->GetTimeSeconds() + LevelStartingTime;
		if (CountdownTime <= 0.f)
		{
			RestartGame();
		}
	}
}

void ABlasterGameMode::BeginPlay()
{
	Super::BeginPlay();

	LevelStartingTime = GetWorld()->GetTimeSeconds();
}

void ABlasterGameMode::OnMatchStateSet()
{
	Super::OnMatchStateSet();

	for (FConstPlayerControllerIterator Iterator = GetWorld()->GetPlayerControllerIterator(); Iterator; ++Iterator)
	{
		ABlasterPlayerController* BlasterPlayer = Cast<ABlasterPlayerController>(*Iterator);
		if (BlasterPlayer)
		{
			BlasterPlayer->OnMatchStateSet(MatchState, bTeamMatch);
		}
	}
}

void ABlasterGameMode::PlayerEliminated(ABlasterCharacter* ElimmedCharacter, ABlasterPlayerController* VictimController,
                                        ABlasterPlayerController* AttackerController)
{
	if (AttackerController == nullptr || AttackerController->PlayerState == nullptr) return;
	if (VictimController == nullptr || VictimController->PlayerState == nullptr) return;
	ABlasterPlayerState* AttackPlayerState = AttackerController ? Cast<ABlasterPlayerState>(AttackerController->PlayerState) : nullptr;
	ABlasterPlayerState* VictimPlayerState = VictimController ? Cast<ABlasterPlayerState>(VictimController->PlayerState) : nullptr;

	ABlasterGameState* BlasterGameState = GetGameState<ABlasterGameState>();

	if (AttackPlayerState && AttackPlayerState != VictimPlayerState && BlasterGameState)
	{
		TArray<ABlasterPlayerState*> PlayersCurrentlyInTheLead;
		for (auto LeadPlayer : BlasterGameState->TopScoringPlayers)
		{
			PlayersCurrentlyInTheLead.Add(LeadPlayer);
		}

		AttackPlayerState->AddToScore(1.f);
		BlasterGameState->UpdateTopScore(AttackPlayerState);

		if (BlasterGameState->TopScoringPlayers.Contains(AttackPlayerState))
		{
			ABlasterCharacter* WinnerCharacter = Cast<ABlasterCharacter>(AttackPlayerState->GetPawn());
			if (WinnerCharacter)
			{
				WinnerCharacter->MulticastGainedTheCrown();	// 获得王冠
			}
		}

		for (int32 i = 0; i < PlayersCurrentlyInTheLead.Num(); i++)
		{
			if (!BlasterGameState->TopScoringPlayers.Contains(PlayersCurrentlyInTheLead[i]))	// 如果不包含
			{
				ABlasterCharacter* LoserCharacter = Cast<ABlasterCharacter>(PlayersCurrentlyInTheLead[i]->GetPawn());
				if (LoserCharacter)
				{
					LoserCharacter->MulticastLostTheCrown();	// 失去王冠
				}
			}
		}
	}

	if (VictimPlayerState)
	{
		VictimPlayerState->AddToDefeats(1);
	}

	if (ElimmedCharacter)
	{
		ElimmedCharacter->Elim(false);
	}

	// 通知所有玩家，谁击杀了谁
	if (AttackPlayerState && VictimPlayerState)
	{
		for (FConstPlayerControllerIterator Iterator = GetWorld()->GetPlayerControllerIterator(); Iterator; ++Iterator)
		{
			if (ABlasterPlayerController* BlasterPlayer = Cast<ABlasterPlayerController>(*Iterator))
			{
				BlasterPlayer->BroadcastElimAnnouncement(AttackPlayerState, VictimPlayerState);
			}
		}
	}
	
}

void ABlasterGameMode::RequestRespawn(ACharacter* ElimmedCharacter, AController* ElimmedController)
{
	// 销毁玩家实体
	if (ElimmedCharacter)
	{
		ElimmedCharacter->Reset();
		ElimmedCharacter->Destroy();
	}

	// 重设玩家的游戏状态
	if (ElimmedController)
	{
		// 他会在起始点位置生成一个新角色
		TArray<AActor*> PlayerStarts;
		UGameplayStatics::GetAllActorsOfClass(this, APlayerStart::StaticClass(), PlayerStarts);
		int32 Selection = FMath::RandRange(0, PlayerStarts.Num() - 1);
		// RestartPlayerAtPlayerStart(ElimmedController, PlayerStarts[Selection]);

		// 推开周围的玩家

		// 先获取出生点的位置
		FVector PlayerStartLocation = PlayerStarts[Selection]->GetActorLocation();

		// 获取出点已经存在的玩家列表
		TArray<FOverlapResult> OverlappingActors;
		if (UWorld* World = GetWorld())
		{
			// 获取出生点周围的玩家
			World->OverlapMultiByObjectType(
				OverlappingActors, 
				PlayerStartLocation, 
				FQuat::Identity, 
				FCollisionObjectQueryParams(FCollisionObjectQueryParams::AllDynamicObjects),
				FCollisionShape::MakeSphere(100.f));

			// 遍历玩家列表，然后推开他们
			for (auto OverlappingActor : OverlappingActors)
			{
				if (ACharacter* OverlappingCharacter = Cast<ACharacter>(OverlappingActor.GetActor()))
				{
					FVector LaunchDirection = OverlappingCharacter->GetActorLocation() - PlayerStartLocation;
					LaunchDirection.Normalize();
					LaunchDirection.Z = 0.f;
					LaunchDirection *= 1000.f;
					OverlappingCharacter->LaunchCharacter(LaunchDirection, true, true);
				}
			}
		}

		RestartPlayerAtPlayerStart(ElimmedController, PlayerStarts[Selection]);

	}
}

void ABlasterGameMode::PlayerLeftGame(ABlasterPlayerState* PlayerLeaving)
{
	if (!PlayerLeaving) return;
	ABlasterGameState* BlasterGameState = GetGameState<ABlasterGameState>();	// 获取游戏状态
	if (BlasterGameState && BlasterGameState->TopScoringPlayers.Contains(PlayerLeaving))
	{
		BlasterGameState->TopScoringPlayers.Remove(PlayerLeaving);
	}
	if (ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(PlayerLeaving->GetPawn()))
	{
		BlasterCharacter->Elim(true);
	}
}

float ABlasterGameMode::CalculateDamage(AController* VictimController, AController* AttackerController, float Damage)
{
	//if (AttackPlayerState && AttackPlayerState != VictimPlayerState && BlasterGameState)
	//{
	//	TArray<ABlasterPlayerState*> PlayersCurrentlyInTheLead;
	//	for (auto LeadPlayer : BlasterGameState->TopScoringPlayers)
	//	{
	//		PlayersCurrentlyInTheLead.Add(LeadPlayer);
	//	}

	//	AttackPlayerState->AddToScore(1.f);
	//	BlasterGameState->UpdateTopScore(AttackPlayerState);

	//	if (BlasterGameState->TopScoringPlayers.Contains(AttackPlayerState))
	//	{
	//		ABlasterCharacter* WinnerCharacter = Cast<ABlasterCharacter>(AttackPlayerState->GetPawn());
	//		if (WinnerCharacter)
	//		{
	//			WinnerCharacter->MulticastGainedTheCrown();	// 获得王冠
	//		}
	//	}

	//	for (int32 i = 0; i < PlayersCurrentlyInTheLead.Num(); i++)
	//	{
	//		if (!BlasterGameState->TopScoringPlayers.Contains(PlayersCurrentlyInTheLead[i]))	// 如果不包含
	//		{
	//			ABlasterCharacter* LoserCharacter = Cast<ABlasterCharacter>(PlayersCurrentlyInTheLead[i]->GetPawn());
	//			if (LoserCharacter)
	//			{
	//				LoserCharacter->MulticastLostTheCrown();	// 失去王冠
	//			}
	//		}
	//	}
	//}
	return Damage;
}


```

`Source/Blaster/GameMode/BlasterGameMode.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameMode.h"
#include "BlasterGameMode.generated.h"

namespace MatchState
{
	extern BLASTER_API const FName Cooldown;	// 比赛持续时间到，显示获胜者并开始冷却计时器
}

/**
 *
 */
UCLASS()
class BLASTER_API ABlasterGameMode : public AGameMode
{
	GENERATED_BODY()

public:
	ABlasterGameMode();
	virtual void Tick(float DeltaSeconds) override;

	// 玩家淘汰
	virtual void PlayerEliminated(class ABlasterCharacter* ElimmedCharacter, class ABlasterPlayerController* VictimController, class ABlasterPlayerController* AttackerController);

	virtual void RequestRespawn(class ACharacter* ElimmedCharacter, AController* ElimmedController);	// 请求重生

	void PlayerLeftGame(class ABlasterPlayerState* PlayerLeaving);	// 玩家离开游戏

	virtual float CalculateDamage(class AController* VictimController, class AController* AttackerController, float Damage);	// 计算伤害

	UPROPERTY(EditDefaultsOnly)
		float WarmupTime = 10.f;	// 预热时间

	UPROPERTY(EditDefaultsOnly)
		float MatchTime = 120.f;		// 游戏比赛时间

	UPROPERTY(EditDefaultsOnly)
		float CooldownTime = 10.f;		// 游戏比赛冷却时间

	float LevelStartingTime = 0.f;		// 关卡开始时间

	bool bTeamMatch = false;	// 是否是团队比赛

protected:
	virtual void BeginPlay() override;
	virtual void OnMatchStateSet() override;

private:
	float CountdownTime = 0.f;		// 倒计时时间

public:
	FORCEINLINE float GetCountdownTime() const { return CooldownTime; }	// 获取倒计时时间

};

```

`Source/Blaster/GameMode/CaptureTheFlagGameMode.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "CaptureTheFlagGameMode.h"

#include "Blaster/CaptureTheFlag/FlagZone.h"
#include "Blaster/GameState/BlasterGameState.h"

void ACaptureTheFlagGameMode::PlayerEliminated(ABlasterCharacter* ElimmedCharacter,
                                               ABlasterPlayerController* VictimController, ABlasterPlayerController* AttackerController)
{
	// 夺旗模式下，我们不希望记录队伍的得分，所以我们不调用父类的PlayerEliminated函数
	ABlasterGameMode::PlayerEliminated(ElimmedCharacter, VictimController, AttackerController);
}

void ACaptureTheFlagGameMode::FlagCaptured(AFlag* Flag, AFlagZone* Zone)
{
	if (ABlasterGameState* BlasterGameState = Cast<ABlasterGameState>(GameState))
	{
		bool bValidCapture = Flag->GetTeam() != Zone->Team;		// 有效的夺取
		if (Zone->Team == ETeam::ET_RedTeam)
		{
			BlasterGameState->RedTeamScored();
		}
		else if (Zone->Team == ETeam::ET_BlueTeam)
		{
			BlasterGameState->BlueTeamScored();
		}
	}

}

```

`Source/Blaster/GameMode/CaptureTheFlagGameMode.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "TeamsGameMode.h"
#include "Blaster/Weapon/Flag.h"
#include "CaptureTheFlagGameMode.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API ACaptureTheFlagGameMode : public ATeamsGameMode
{
	GENERATED_BODY()

public:
	virtual void PlayerEliminated(ABlasterCharacter* ElimmedCharacter, ABlasterPlayerController* VictimController, ABlasterPlayerController* AttackerController) override;

	void FlagCaptured(class AFlag* Flag, class AFlagZone* Zone);	// 当旗帜被夺取时
};

```

`Source/Blaster/GameMode/LobbyGameMode.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "LobbyGameMode.h"

#include "GameFramework/GameStateBase.h"
#include "MultiplayerSessions/Public/MultiplayerSessionsSubsystem.h"

void ALobbyGameMode::PostLogin(APlayerController* NewPlayer)
{
	Super::PostLogin(NewPlayer);

	int32 NumberOfPlayers = GameState.Get()->PlayerArray.Num();		// 获取玩家数量

	UGameInstance* GameInstance = GetGameInstance();
	if (GameInstance)
	{
		UMultiplayerSessionsSubsystem* MultiplayerSessionsSubsystem = GameInstance->GetSubsystem<UMultiplayerSessionsSubsystem>();

		check(MultiplayerSessionsSubsystem);

		if (NumberOfPlayers == MultiplayerSessionsSubsystem->GetDesiredNumPublicConnections())		// 如果玩家数量为2
		{
			UWorld* World = GetWorld();
			if (World)
			{
				bUseSeamlessTravel = true;		// 使用无缝旅行

				FString MatchType = MultiplayerSessionsSubsystem->GetDesiredMatchType();		// 获取比赛类型
				if (MatchType == "FreeForAll")
				{
					World->ServerTravel(FString("/Game/Maps/BlasterMap?listen"));		// 服务器旅行 - 服务器旅行到指定的地图
				}
				else if (MatchType == "Teams")
				{
					World->ServerTravel(FString("/Game/Maps/TeamsMap?listen"));		// 服务器旅行 - 服务器旅行到指定的地图
				}
				else if (MatchType == "CaptureTheFlag")
				{
					World->ServerTravel(FString("/Game/Maps/CaptureTheFlagMap?listen"));		// 服务器旅行 - 服务器旅行到指定的地图
				}

			}
		}
	}

	
}
```

`Source/Blaster/GameMode/LobbyGameMode.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameMode.h"
#include "LobbyGameMode.generated.h"

/**
 *
 */
UCLASS()
class BLASTER_API ALobbyGameMode : public AGameMode
{
	GENERATED_BODY()

public:
	virtual void PostLogin(APlayerController* NewPlayer) override;
};

```

`Source/Blaster/GameMode/TeamsGameMode.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "TeamsGameMode.h"
#include "Blaster/GameState/BlasterGameState.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "Blaster/PlayerState/BlasterPlayerState.h"
#include "Kismet/GameplayStatics.h"

ATeamsGameMode::ATeamsGameMode()
{
	// 将其设置为true时，游戏模式将会停留在等待开始的状态，它会为所有玩家生成一个默认设置，他们可以使用它在地图中飞行，没有网格
	bDelayedStart = true;

	bTeamMatch = true;	// 设置为true时，游戏模式将会在团队之间进行比赛
}

void ATeamsGameMode::PostLogin(APlayerController* NewPlayer)
{
	Super::PostLogin(NewPlayer);

	ABlasterGameState* BlasterGameState = Cast<ABlasterGameState>(UGameplayStatics::GetGameState(this));
	if (BlasterGameState)
	{
		ABlasterPlayerState* BlasterPlayerState = NewPlayer->GetPlayerState<ABlasterPlayerState>();
		if (BlasterPlayerState && BlasterPlayerState->GetTeam() == ETeam::ET_NoTeam)
		{
			if (BlasterGameState->RedTeam.Num() <= BlasterGameState->BlueTeam.Num())
			{
				BlasterPlayerState->SetTeam(ETeam::ET_RedTeam);
				BlasterGameState->RedTeam.AddUnique(BlasterPlayerState);
			}
			else
			{
				BlasterPlayerState->SetTeam(ETeam::ET_BlueTeam);
				BlasterGameState->BlueTeam.AddUnique(BlasterPlayerState);
			}
		}
	}
}

void ATeamsGameMode::PlayerEliminated(ABlasterCharacter* ElimmedCharacter, ABlasterPlayerController* VictimController,
	ABlasterPlayerController* AttackerController)
{
	Super::PlayerEliminated(ElimmedCharacter, VictimController, AttackerController);

	ABlasterGameState* BlasterGameState = Cast<ABlasterGameState>(UGameplayStatics::GetGameState(this));
	if (BlasterGameState)
	{
		ABlasterPlayerState* AttackerPlayerState = AttackerController->GetPlayerState<ABlasterPlayerState>();

		if (AttackerPlayerState)
		{
			if (AttackerPlayerState->GetTeam() == ETeam::ET_RedTeam)
			{
				BlasterGameState->RedTeamScored();
			}
			else if (AttackerPlayerState->GetTeam() == ETeam::ET_BlueTeam)
			{
				BlasterGameState->BlueTeamScored();
			}
		}
	}

}

void ATeamsGameMode::Logout(AController* Exiting)
{
	Super::Logout(Exiting);

	ABlasterGameState* BlasterGameState = Cast<ABlasterGameState>(UGameplayStatics::GetGameState(this));
	ABlasterPlayerState* BlasterPlayerState = Exiting->GetPlayerState<ABlasterPlayerState>();

	if (BlasterGameState && BlasterPlayerState)
	{
		if (BlasterPlayerState->GetTeam() == ETeam::ET_RedTeam)
		{
			BlasterGameState->RedTeam.Remove(BlasterPlayerState);
		}
		else if (BlasterPlayerState->GetTeam() == ETeam::ET_BlueTeam)
		{
			BlasterGameState->BlueTeam.Remove(BlasterPlayerState);
		}
	}
}

float ATeamsGameMode::CalculateDamage(AController* VictimController, AController* AttackerController, float Damage)
{
	// 如果受害者和攻击者都在同一队伍，那么就不会造成伤害
	if (VictimController && AttackerController)
	{
		const ABlasterPlayerState* VictimPlayerState = VictimController->GetPlayerState<ABlasterPlayerState>();
		const ABlasterPlayerState* AttackerPlayerState = AttackerController->GetPlayerState<ABlasterPlayerState>();

		if (VictimPlayerState && AttackerPlayerState && VictimPlayerState->GetTeam() == AttackerPlayerState->GetTeam())
		{
			return 0.f;
		}
	}

	return Damage;
}

void ATeamsGameMode::HandleMatchHasStarted()
{
	Super::HandleMatchHasStarted();

	ABlasterGameState* BlasterGameState = Cast<ABlasterGameState>(UGameplayStatics::GetGameState(this));
	if (BlasterGameState)
	{
		for (APlayerState* PlayerState : BlasterGameState->PlayerArray)
		{
			ABlasterPlayerState* BlasterPlayerState = Cast<ABlasterPlayerState>(PlayerState);
			if (BlasterPlayerState && BlasterPlayerState->GetTeam() == ETeam::ET_NoTeam)
			{
				if (BlasterGameState->RedTeam.Num() <= BlasterGameState->BlueTeam.Num())
				{
					BlasterPlayerState->SetTeam(ETeam::ET_RedTeam);
					BlasterGameState->RedTeam.AddUnique(BlasterPlayerState);
				}
				else
				{
					BlasterPlayerState->SetTeam(ETeam::ET_BlueTeam);
					BlasterGameState->BlackTeam.AddUnique(BlasterPlayerState);
				}
			}
		}
	}
}

```

`Source/Blaster/GameMode/TeamsGameMode.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "BlasterGameMode.h"
#include "TeamsGameMode.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API ATeamsGameMode : public ABlasterGameMode
{
	GENERATED_BODY()

public:
	ATeamsGameMode();
	virtual void PostLogin(APlayerController* NewPlayer) override;	// 在玩家登录时调用
	virtual void PlayerEliminated(class ABlasterCharacter* ElimmedCharacter, class ABlasterPlayerController* VictimController, class ABlasterPlayerController* AttackerController) override;	// 玩家淘汰

	virtual void Logout(AController* Exiting) override;				// 在玩家退出时调用

	virtual float CalculateDamage(AController* VictimController, AController* AttackerController, float Damage) override;	// 计算伤害

protected:
	virtual void HandleMatchHasStarted() override;	// 在比赛开始时调用
	
};

```

`Source/Blaster/GameState/BlasterGameState.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "BlasterGameState.h"

#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "Blaster/PlayerState/BlasterPlayerState.h"
#include "Kismet/GameplayStatics.h"
#include "Net/UnrealNetwork.h"

void ABlasterGameState::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ABlasterGameState, TopScoringPlayers);
	DOREPLIFETIME(ABlasterGameState, RedTeamScore);
	DOREPLIFETIME(ABlasterGameState, BlueTeamScore);
	DOREPLIFETIME(ABlasterGameState, GreenTeamScore);
	DOREPLIFETIME(ABlasterGameState, YellowTeamScore);
	DOREPLIFETIME(ABlasterGameState, PurpleTeamScore);
	DOREPLIFETIME(ABlasterGameState, OrangeTeamScore);
	DOREPLIFETIME(ABlasterGameState, PinkTeamScore);
	DOREPLIFETIME(ABlasterGameState, BlackTeamScore);
	DOREPLIFETIME(ABlasterGameState, WhiteTeamScore);
}

void ABlasterGameState::UpdateTopScore(ABlasterPlayerState* ScoringPlayer)
{
	if (TopScoringPlayers.Num() == 0)
	{
		TopScoringPlayers.Add(ScoringPlayer);
		TopScore = ScoringPlayer->GetScore();
	}
	else if (ScoringPlayer->GetScore() == TopScore)
	{
		TopScoringPlayers.AddUnique(ScoringPlayer);
	}
	else if (ScoringPlayer->GetScore() > TopScore)
	{
		TopScoringPlayers.Empty();
		TopScoringPlayers.AddUnique(ScoringPlayer);
		TopScore = ScoringPlayer->GetScore();
	}
}

void ABlasterGameState::RedTeamScored()
{
	++RedTeamScore;

	ABlasterPlayerController* PlayerController = Cast<ABlasterPlayerController>(UGameplayStatics::GetPlayerController(GetWorld(), 0));
	if (PlayerController)
	{
		PlayerController->SetHUDRedTeamScores(RedTeamScore);
	}
}

void ABlasterGameState::BlueTeamScored()
{
	++BlueTeamScore;
	ABlasterPlayerController* PlayerController = Cast<ABlasterPlayerController>(UGameplayStatics::GetPlayerController(GetWorld(), 0));
	if (PlayerController)
	{
		PlayerController->SetHUDBlueTeamScores(BlueTeamScore);
	}
}

void ABlasterGameState::OnRepRedTeamScore()
{
	ABlasterPlayerController* PlayerController = Cast<ABlasterPlayerController>(UGameplayStatics::GetPlayerController(GetWorld(), 0));
	if (PlayerController)
	{
		PlayerController->SetHUDRedTeamScores(RedTeamScore);
	}
}

void ABlasterGameState::OnRepBlueTeamScore()
{
	ABlasterPlayerController* PlayerController = Cast<ABlasterPlayerController>(UGameplayStatics::GetPlayerController(GetWorld(), 0));
	if (PlayerController)
	{
		PlayerController->SetHUDBlueTeamScores(BlueTeamScore);
	}
}

void ABlasterGameState::OnRepGreenTeamScore()
{
}

void ABlasterGameState::OnRepYellowTeamScore()
{
}

void ABlasterGameState::OnRepPurpleTeamScore()
{
}

void ABlasterGameState::OnRepOrangeTeamScore()
{
}

void ABlasterGameState::OnRepPinkTeamScore()
{
}

void ABlasterGameState::OnRepBlackTeamScore()
{
}

void ABlasterGameState::OnRepWhiteTeamScore()
{
}


```

`Source/Blaster/GameState/BlasterGameState.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "Blaster/BlasterTypes/Team.h"

#include "CoreMinimal.h"
#include "GameFramework/GameState.h"
#include "BlasterGameState.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API ABlasterGameState : public AGameState
{
	GENERATED_BODY()

public:
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

	void UpdateTopScore(class ABlasterPlayerState* ScoringPlayer);

	UPROPERTY(Replicated)
	TArray<class ABlasterPlayerState*> TopScoringPlayers;

	/*
	 * Team Scores
	 */
	TArray<ABlasterPlayerState*> RedTeam;		// 红队
	TArray<ABlasterPlayerState*> BlueTeam;		// 蓝队
	TArray<ABlasterPlayerState*> GreenTeam;		// 绿队
	TArray<ABlasterPlayerState*> YellowTeam;	// 黄队
	TArray<ABlasterPlayerState*> PurpleTeam;	// 紫队
	TArray<ABlasterPlayerState*> OrangeTeam;	// 橙队
	TArray<ABlasterPlayerState*> PinkTeam;		// 粉队
	TArray<ABlasterPlayerState*> BlackTeam;		// 黑队
	TArray<ABlasterPlayerState*> WhiteTeam;		// 白队
	
	TMap<ETeam, float> TeamScores;

	void RedTeamScored();
	void BlueTeamScored();

	UPROPERTY(ReplicatedUsing=OnRepRedTeamScore)
	float RedTeamScore = 0.f;

	UFUNCTION()
	void OnRepRedTeamScore();

	UPROPERTY(ReplicatedUsing=OnRepBlueTeamScore)
	float BlueTeamScore = 0.f;

	UFUNCTION()
	void OnRepBlueTeamScore();

	UPROPERTY(ReplicatedUsing=OnRepGreenTeamScore)
	float GreenTeamScore = 0.f;

	UFUNCTION()
	void OnRepGreenTeamScore();

	UPROPERTY(ReplicatedUsing=OnRepYellowTeamScore)
	float YellowTeamScore = 0.f;

	UFUNCTION()
	void OnRepYellowTeamScore();

	UPROPERTY(ReplicatedUsing=OnRepPurpleTeamScore)
	float PurpleTeamScore = 0.f;

	UFUNCTION()
	void OnRepPurpleTeamScore();

	UPROPERTY(ReplicatedUsing=OnRepOrangeTeamScore)
	float OrangeTeamScore = 0.f;

	UFUNCTION()
	void OnRepOrangeTeamScore();

	UPROPERTY(ReplicatedUsing=OnRepPinkTeamScore)
	float PinkTeamScore = 0.f;

	UFUNCTION()
	void OnRepPinkTeamScore();

	UPROPERTY(ReplicatedUsing=OnRepBlackTeamScore)
	float BlackTeamScore = 0.f;

	UFUNCTION()
	void OnRepBlackTeamScore();

	UPROPERTY(ReplicatedUsing=OnRepWhiteTeamScore)
	float WhiteTeamScore = 0.f;

	UFUNCTION()
	void OnRepWhiteTeamScore();

private:
	float TopScore = 0.f;

};

```

`Source/Blaster/HUD/Announcement.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Announcement.h"


```

`Source/Blaster/HUD/Announcement.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "Announcement.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API UAnnouncement : public UUserWidget
{
	GENERATED_BODY()

public:
	UPROPERTY(meta = (BindWidget))
		class UTextBlock* WarmupTime;

	UPROPERTY(meta = (BindWidget))
		UTextBlock* AnnouncementText;

	UPROPERTY(meta = (BindWidget))
		UTextBlock* InfoText;
	
};

```

`Source/Blaster/HUD/BlasterHUD.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "BlasterHUD.h"

#include "CharacterOverlay.h"
#include "GameFramework/PlayerController.h"
#include "Announcement.h"
#include "ElimAnnouncement.h"
#include "Components/HorizontalBox.h"
#include "Blueprint/WidgetLayoutLibrary.h"
#include "Components/CanvasPanelSlot.h"
#include "Kismet/KismetSystemLibrary.h"

void ABlasterHUD::BeginPlay()
{
	Super::BeginPlay();
}

void ABlasterHUD::AddCharacterOverlay()
{
	OwnerPlayerController = OwnerPlayerController ? OwnerPlayerController : GetOwningPlayerController();
	if (OwnerPlayerController && CharacterOverlayClass)
	{
		CharacterOverlay = CreateWidget<UCharacterOverlay>(OwnerPlayerController, CharacterOverlayClass);
		if (CharacterOverlay)
		{
			CharacterOverlay->AddToViewport();
		}
	}
}

void ABlasterHUD::AddAnnouncement()
{
	OwnerPlayerController = OwnerPlayerController ? OwnerPlayerController : GetOwningPlayerController();
	if (OwnerPlayerController && AnnouncementClass)
	{
		Announcement = CreateWidget<UAnnouncement>(OwnerPlayerController, AnnouncementClass);
		if (Announcement)
		{
			Announcement->AddToViewport();
		}
	}
}

void ABlasterHUD::AddElimAnnouncement(FString Attacker, FString Victim)
{
	OwnerPlayerController = OwnerPlayerController ? OwnerPlayerController : GetOwningPlayerController();
	if (OwnerPlayerController && ElimAnnouncementClass)
	{
		UElimAnnouncement* ElimAnnouncementWidget = CreateWidget<UElimAnnouncement>(OwnerPlayerController, ElimAnnouncementClass);
		if (ElimAnnouncementWidget)
		{
			ElimAnnouncementWidget->SetElimAnnouncementText(Attacker, Victim);
			ElimAnnouncementWidget->AddToViewport();

			

			for (auto ElimMsg : ElimMassages)
			{
				if (ElimMsg && ElimMsg->AnnouncementBox)
				{
					UCanvasPanelSlot* CanvasSlot = UWidgetLayoutLibrary::SlotAsCanvasSlot(ElimMsg->AnnouncementBox);	// 获取画布插槽，用于设置位置

					if (CanvasSlot)
					{
						FVector2D ElimMsgPosition = CanvasSlot->GetPosition();	// 消息的位置
						FVector2D NewPosition = FVector2D(ElimMsgPosition.X, ElimMsgPosition.Y - CanvasSlot->GetSize().Y);	// 新的位置
						CanvasSlot->SetPosition(NewPosition);	// 设置新的位置
					}
				}
			}

			ElimMassages.Add(ElimAnnouncementWidget);	// 将该消息添加到数组中，以便在一段时间后移除

			// 为了在一段时间后移除该消息，我们需要一个计时器
			FTimerHandle ElimAnnouncementTimer;
			FTimerDelegate ElimAnnouncementTimerDelegate;	// 代理，用于绑定函数，当计时器结束时调用
			ElimAnnouncementTimerDelegate.BindUFunction(this, FName("ElimAnnouncementTimerFinished"), ElimAnnouncementWidget);		// 绑定函数, 传递的参数是ElimAnnouncement
			GetWorldTimerManager().SetTimer(ElimAnnouncementTimer, ElimAnnouncementTimerDelegate, ElimAnnouncementTime, false);	// 设置计时器
		}
	}
}

void ABlasterHUD::ElimAnnouncementTimerFinished(UElimAnnouncement* MsgToRemove)
{
	if (MsgToRemove)
	{
		MsgToRemove->RemoveFromParent();	// 从父级移除
	}
}

void ABlasterHUD::DrawHUD()
{
	Super::DrawHUD();

	// 绘制射击游戏的十字准心，十字准心应该在武器类上
	FVector2D ViewportSize;
	if (GEngine)
	{
		GEngine->GameViewport->GetViewportSize(ViewportSize);

		const FVector2D ViewPortCenter(ViewportSize.X / 2.f, ViewportSize.Y / 2.f);

		float SpreaScaled = CrosshairSpreadMax * HUDPackage.CrosshairSpread;
		if (HUDPackage.CrosshairsCenter)
		{
			FVector2D Spread(0.f, 0.f);
			DrawCrosshair(HUDPackage.CrosshairsCenter, ViewPortCenter, Spread, HUDPackage.CrosshairsColor);
		}
		if (HUDPackage.CrosshairsLeft)
		{
			FVector2D Spread(-SpreaScaled, 0.f);
			DrawCrosshair(HUDPackage.CrosshairsLeft, ViewPortCenter, Spread, HUDPackage.CrosshairsColor);
		}
		if (HUDPackage.CrosshairsRight)
		{
			FVector2D Spread(SpreaScaled, 0.f);
			DrawCrosshair(HUDPackage.CrosshairsRight, ViewPortCenter, Spread, HUDPackage.CrosshairsColor);
		}
		if (HUDPackage.CrosshairsBottom)
		{
			FVector2D Spread(0.f, SpreaScaled);
			DrawCrosshair(HUDPackage.CrosshairsBottom, ViewPortCenter, Spread, HUDPackage.CrosshairsColor);
		}
		if (HUDPackage.CrosshairsTop)
		{
			FVector2D Spread(0.f, -SpreaScaled);
			DrawCrosshair(HUDPackage.CrosshairsTop, ViewPortCenter, Spread, HUDPackage.CrosshairsColor);
		}
	}
}

void ABlasterHUD::DrawCrosshair(UTexture2D* Texture, FVector2D ViewportCenter, FVector2D Spread, FLinearColor Color)
{
	const float TextureWidth = Texture->GetSizeX();
	const float TextureHeight = Texture->GetSizeY();
	// 绘制点中心，需要在屏幕中心，按纹理向左移动TextureWidth/2, 纹理高度/2
	const FVector2D TextureDrawPoint(
		ViewportCenter.X - (TextureWidth / 2.f) + Spread.X,
		ViewportCenter.Y - (TextureHeight / 2.f) + Spread.Y
	);

	DrawTexture(
		Texture,
		TextureDrawPoint.X,
		TextureDrawPoint.Y,
		TextureWidth,
		TextureHeight,
		0.f,
		0.f,
		1.f,
		1.f,
		Color
	);
}

```

`Source/Blaster/HUD/BlasterHUD.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/HUD.h"
#include "BlasterHUD.generated.h"

// 目前为止，BlasterHUD并不知道要绘制哪些纹理到屏幕上作为十字准心
// 所以这里提供一个结构体，容纳应该有的不同十字准心的纹理
USTRUCT(BlueprintType)
struct FHUDPackage
{
	// 添加主体生成宏 以便虚幻的反射系统可以将我们的FHUDPackage也加入到反射中
	GENERATED_BODY()

public:
	class UTexture2D* CrosshairsCenter;
	class UTexture2D* CrosshairsLeft;
	class UTexture2D* CrosshairsRight;
	class UTexture2D* CrosshairsTop;
	class UTexture2D* CrosshairsBottom;
	float CrosshairSpread;		// 该值用于控制十字准心应该分散多少
	FLinearColor CrosshairsColor;	// 十字准心的颜色
};

/**
 *
 */
UCLASS()
class BLASTER_API ABlasterHUD : public AHUD
{
	GENERATED_BODY()

public:
	virtual void DrawHUD() override;

	UPROPERTY(EditAnywhere, Category = "Player Stats")
	TSubclassOf<class UUserWidget> CharacterOverlayClass;

	UPROPERTY()
	class UCharacterOverlay* CharacterOverlay;

	UPROPERTY(EditAnywhere, Category = "Announcement")
	TSubclassOf<UUserWidget> AnnouncementClass;

	UPROPERTY(EditAnywhere, Category="ElimAnnoucement")
	TSubclassOf<class UElimAnnouncement> ElimAnnouncementClass;

	UPROPERTY()
	class UAnnouncement* Announcement;

	//UPROPERTY()
	//class UElimAnnouncement* ElimAnnouncement;

	void AddCharacterOverlay();
	void AddAnnouncement();
	void AddElimAnnouncement(FString Attacker, FString Victim);

protected:
	virtual void BeginPlay() override;

private:
	FHUDPackage HUDPackage;

	void DrawCrosshair(UTexture2D* Texture, FVector2D ViewportCenter, FVector2D Spread, FLinearColor Color);

	UPROPERTY(EditAnywhere)
	float CrosshairSpreadMax = 16.f;

	UPROPERTY()
	class APlayerController* OwnerPlayerController;

	UPROPERTY(EditAnywhere, Category = "ElimAnnoucement")
	float ElimAnnouncementTime = 5.f;	// 击杀公告时间

	UFUNCTION()
	void ElimAnnouncementTimerFinished(UElimAnnouncement* MsgToRemove);	// 击杀公告时间结束

	UPROPERTY()
	TArray<UElimAnnouncement*> ElimMassages;	// 击杀公告消息

public:
	FORCEINLINE void SetHUDPackage(const FHUDPackage& Package) { HUDPackage = Package; }
};

```

`Source/Blaster/HUD/CharacterOverlay.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "CharacterOverlay.h"
```

`Source/Blaster/HUD/CharacterOverlay.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "CharacterOverlay.generated.h"

/**
 *
 */
UCLASS()
class BLASTER_API UCharacterOverlay : public UUserWidget
{
	GENERATED_BODY()

public:
	UPROPERTY(meta = (BindWidget))
	class UProgressBar* HealthBar;	// 血条

	UPROPERTY(meta=(BindWidget))
	class UImage* HealthBarNative;	// 血条

	//UPROPERTY(VisibleAnywhere, meta = (BindWidget))
	//class UMaterialInstanceDynamic* HealthBarMaterial;	// 血条材质

	UPROPERTY(meta = (BindWidget))
	UProgressBar* HealthAdditionBar;	// 血条增加

	UPROPERTY(meta = (BindWidget))
	UProgressBar* HealthSubtractionBar;	// 血条减少

	UPROPERTY(meta = (BindWidget))
	UProgressBar* ShieldBar_L2R;	// 护盾条 从左到右

	UPROPERTY(meta = (BindWidget))
	UProgressBar* ShieldBar_R2L;	// 护盾条 从右到左

	UPROPERTY(meta = (BindWidget))
	class UTextBlock* HealthText;	// 血量

	UPROPERTY(meta = (BindWidget))
	UTextBlock* ShieldText;		// 护盾

	UPROPERTY(meta = (BindWidget))
	UTextBlock* ScoreAmount;	// 分数

	UPROPERTY(meta=(BindWidget))
	UTextBlock* BlueTeamScore;	// 蓝队分数

	UPROPERTY(meta=(BindWidget))
	UTextBlock* RedTeamScore;	// 红队分数

	UPROPERTY(meta = (BindWidget))
	UTextBlock* DefeatsAmount;	// 击杀数

	UPROPERTY(meta = (BindWidget))
	UTextBlock* WeaponAmmoAmount;	// 武器弹药

	UPROPERTY(meta = (BindWidget))
	UTextBlock* CarriedAmmoAmount;	// 携带弹药

	UPROPERTY(meta = (BindWidget))
	UTextBlock* MatchCountdownText;	// 比赛倒计时

	UPROPERTY(meta = (BindWidget))
	UTextBlock* GrenadesText;	// 榴弹

	UPROPERTY(meta=(BindWidget))
	UImage* HighPingImage;			// 高延迟图标

	UPROPERTY(meta = (BindWidgetAnim), Transient)	// 标记为瞬态，也就是说这个变量不会被保存到内存中
	class UWidgetAnimation* HighPingAnimation;	// 高延迟动画
};

```

`Source/Blaster/HUD/ElimAnnouncement.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ElimAnnouncement.h"

#include "Components/TextBlock.h"

void UElimAnnouncement::SetElimAnnouncementText(FString AttackerName, FString VictimName)
{
	FString ElimText = AttackerName + " eliminated " + VictimName;
	if (AnnouncementText)
	{
		AnnouncementText->SetText(FText::FromString(ElimText));
	}
}

```

`Source/Blaster/HUD/ElimAnnouncement.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "ElimAnnouncement.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API UElimAnnouncement : public UUserWidget
{
	GENERATED_BODY()

public:
	UPROPERTY(meta = (BindWidget))
	class UHorizontalBox* AnnouncementBox;

	UPROPERTY(meta=(BindWidget))
	class UTextBlock* AnnouncementText;

	void SetElimAnnouncementText(FString AttackerName, FString VictimName);
};

```

`Source/Blaster/HUD/OverheadWidget.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "OverheadWidget.h"

#include "Components/TextBlock.h"

void UOverheadWidget::SetDisplayText(FString TextToDisplay)
{
	if (DisplayText)
	{
		DisplayText->SetText(FText::FromString(TextToDisplay));
	}
}

void UOverheadWidget::ShowPlayerNetRole(APawn* InPawn)
{
	// 在玩家输入中获取本地角色（本地或者网络角色）
	ENetRole RemoteRole = InPawn->GetRemoteRole();

	FString Role;

	switch (RemoteRole)
	{
	case ENetRole::ROLE_Authority:
		Role = FString("Authority");
		break;
	case ENetRole::ROLE_AutonomousProxy:
		Role = FString("Autonomous Proxy");
		break;
	case ENetRole::ROLE_SimulatedProxy:
		Role = FString("Simulated Proxy");
		break;
	case ENetRole::ROLE_None:
		Role = FString("None");
		break;
	}
	FString RemoteRoleString = FString::Printf(TEXT("Remote Role: %s"), *Role);

	SetDisplayText(RemoteRoleString);
}

void UOverheadWidget::NativeDestruct()
{
	// 将控件从视图中移除
	RemoveFromParent();
	Super::NativeDestruct();
}

//void UOverheadWidget::OnLevelRemovedFromWorld(ULevel* InLevel, UWorld* InWorld)
//{
//	// 将控件从视图中移除
//	RemoveFromParent();
//
//	Super::OnLevelRemovedFromWorld(InLevel, InWorld);
//}

```

`Source/Blaster/HUD/OverheadWidget.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "OverheadWidget.generated.h"

/**
 *
 */
UCLASS()
class BLASTER_API UOverheadWidget : public UUserWidget
{
	GENERATED_BODY()

public:
	UPROPERTY(meta = (BindWidget))
		class UTextBlock* DisplayText;

	void SetDisplayText(FString TextToDisplay);

	// 显示pown的网络角色
	UFUNCTION(BlueprintCallable)
		void ShowPlayerNetRole(APawn* InPawn);

protected:
	// UE5.1之后该方法被弃用，使用下面的方法代替
	// virtual void OnLevelRemovedFromWorld(ULevel* InLevel, UWorld* InWorld) override;
	virtual void NativeDestruct() override;	// 该方法在UMG部件被销毁时调用
};

```

`Source/Blaster/HUD/ReturnToMainMenu.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ReturnToMainMenu.h"

#include "Blaster/Character/BlasterCharacter.h"
#include "Components/Button.h"
#include "GameFramework/GameModeBase.h"
#include "MultiplayerSessions/Public/MultiplayerSessionsSubsystem.h"

void UReturnToMainMenu::MenuSetup()
{
	AddToViewport();	// 将按钮添加到视口
	SetVisibility(ESlateVisibility::Visible);	// 设置按钮可见
	bIsFocusable = true;	// 设置按钮可聚焦

	if (const UWorld* World = GetWorld())
	{
		PlayerController = PlayerController ? PlayerController : Cast<APlayerController>(World->GetFirstPlayerController());		// 获取玩家控制器
		if (PlayerController)
		{
			FInputModeGameAndUI InputMode;	// 游戏和UI模式, 显示UI
			InputMode.SetWidgetToFocus(TakeWidget());	// 设置聚焦的控件
			InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);	// 设置鼠标锁定模式
			PlayerController->SetInputMode(InputMode);	// 设置输入模式
			PlayerController->SetShowMouseCursor(true);	// 显示鼠标
		}
	}

	if (ReturnButton && !ReturnButton->OnClicked.IsBound())		// 如果返回按钮存在并且未绑定点击事件
	{
		ReturnButton->OnClicked.AddDynamic(this, &UReturnToMainMenu::ReturnButtonClicked);	// 绑定返回按钮点击事件
	}

	if (const UGameInstance* GameInstance = GetGameInstance())
	{
		MultiplayerSessionsSubsystem = GameInstance->GetSubsystem<UMultiplayerSessionsSubsystem>();	// 获取多人游戏会话子系统
		if (MultiplayerSessionsSubsystem)
		{
			MultiplayerSessionsSubsystem->MultiplayerOnDestroySessionComplete.AddDynamic(this, &UReturnToMainMenu::OnDestroySession);	// 绑定销毁会话完成事件
		}
	}

}

void UReturnToMainMenu::MenuTeardown()
{
	SetVisibility(ESlateVisibility::Hidden);	// 设置按钮不可见
	RemoveFromParent();	// 从父控件移除

	if (const UWorld* World = GetWorld())
	{
		PlayerController = PlayerController ? PlayerController : Cast<APlayerController>(World->GetFirstPlayerController());		// 获取玩家控制器
		if (PlayerController)
		{
			FInputModeGameOnly InputMode;	// 游戏模式, 不显示UI
			PlayerController->SetInputMode(InputMode);	// 设置输入模式
			PlayerController->SetShowMouseCursor(false);	// 隐藏鼠标
		}
	}

	if (ReturnButton && ReturnButton->OnClicked.IsBound())		// 如果返回按钮存在并且绑定点击事件
	{
		ReturnButton->OnClicked.RemoveDynamic(this, &UReturnToMainMenu::ReturnButtonClicked);	// 取消绑定返回按钮点击事件
	}

	if (MultiplayerSessionsSubsystem && MultiplayerSessionsSubsystem->MultiplayerOnDestroySessionComplete.IsBound())	// 如果多人游戏会话子系统存在并且绑定销毁会话完成事件
	{
		MultiplayerSessionsSubsystem->MultiplayerOnDestroySessionComplete.RemoveDynamic(this, &UReturnToMainMenu::OnDestroySession);	// 取消绑定销毁会话完成事件
	}
}

bool UReturnToMainMenu::Initialize()
{
	if (!Super::Initialize())
	{
		return false;
	}

	return true;
}

void UReturnToMainMenu::OnDestroySession(bool bWasSuccessful)
{
	if (!bWasSuccessful)
	{
		ReturnButton->SetIsEnabled(true);	// 启用返回按钮
		return;
	}

	if (const UWorld* World = GetWorld())
	{
		if (AGameModeBase* GameMode = World->GetAuthGameMode<AGameModeBase>())
		{
			GameMode->ReturnToMainMenuHost();	// 返回主菜单
		}
		else
		{
			// 如果没有找到游戏模式，我们将尝试使用玩家控制器
			PlayerController = PlayerController ? PlayerController : Cast<APlayerController>(World->GetFirstPlayerController());		// 获取玩家控制器
			if (PlayerController)
			{
				PlayerController->ClientReturnToMainMenuWithTextReason(FText());	// 返回主菜单
			}
		}
	}
}

void UReturnToMainMenu::OnPlayerLeftGame()
{
	if (MultiplayerSessionsSubsystem)
	{
		MultiplayerSessionsSubsystem->DestroySession();	// 销毁会话
	}
}

void UReturnToMainMenu::ReturnButtonClicked()
{
	ReturnButton->SetIsEnabled(false);	// 禁用返回按钮

	if (UWorld* World = GetWorld())
	{
		if (const APlayerController* FirstPlayerController = Cast<APlayerController>(World->GetFirstPlayerController()))
		{
			if (ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(FirstPlayerController->GetPawn()))
			{
				if (!BlasterCharacter->OnLeftGame.IsBound())
				{
					BlasterCharacter->OnLeftGame.AddDynamic(this, &UReturnToMainMenu::OnPlayerLeftGame);	// 绑定玩家离开游戏事件
				}
				BlasterCharacter->ServerLeftGame();	// 玩家离开游戏
			}
			else
			{
				ReturnButton->SetIsEnabled(true);	// 启用返回按钮
			}
		}
	}
}

```

`Source/Blaster/HUD/ReturnToMainMenu.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "ReturnToMainMenu.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API UReturnToMainMenu : public UUserWidget
{
	GENERATED_BODY()

public:

	void MenuSetup();		// 将按钮添加到视口

	void MenuTeardown();	// 将按钮从视口移除

protected:
	virtual bool Initialize() override;	// 初始化

	UFUNCTION()	// 创建会话完成
	void OnDestroySession(bool bWasSuccessful);	// 销毁会话完成

	UFUNCTION()	// 玩家离开游戏
	void OnPlayerLeftGame();	// 玩家离开游戏

private:
	UPROPERTY(meta = (BindWidget))	// 绑定按钮
	class UButton* ReturnButton;	// 返回主菜单按钮

	UFUNCTION()	// 返回按钮点击事件
	void ReturnButtonClicked();	// 返回按钮点击事件

	UPROPERTY()	// 多人游戏会话子系统
	class UMultiplayerSessionsSubsystem* MultiplayerSessionsSubsystem;	// 多人游戏会话子系统

	UPROPERTY()	// 玩家控制器
	class APlayerController* PlayerController;	// 玩家控制器
	
};

```

`Source/Blaster/Interface/InteractWithCrosshairsInterface.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "InteractWithCrosshairsInterface.h"

// Add default functionality here for any IInteractWithCrosshairsInterface functions that are not pure virtual.
```

`Source/Blaster/Interface/InteractWithCrosshairsInterface.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "InteractWithCrosshairsInterface.generated.h"

// This class does not need to be modified.
UINTERFACE(MinimalAPI)
class UInteractWithCrosshairsInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class BLASTER_API IInteractWithCrosshairsInterface
{
	GENERATED_BODY()

	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
public:
};

```

`Source/Blaster/Pickups/AmmoPickup.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "AmmoPickup.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/BlasterComponents/CombatComponent.h"

void AAmmoPickup::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (BlasterCharacter)
	{
		UCombatComponent* Combat = BlasterCharacter->GetCombat();
		if (Combat)
		{
			Combat->PickupAmmo(WeaponType, AmmoAmount);
		}
	}
	Destroy(); // 销毁 因为是一次性的
}

```

`Source/Blaster/Pickups/AmmoPickup.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Pickup.h"
#include "Blaster/Weapon/WeaponTypes.h"
#include "AmmoPickup.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API AAmmoPickup : public APickup
{
	GENERATED_BODY()

protected:
	// 在重写的OnSphereOverlap中调用，用于处理玩家拾取该物品的逻辑
	virtual void OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult) override;

private:
	UPROPERTY(EditAnywhere)
	int32 AmmoAmount = 30;

	UPROPERTY(EditAnywhere)
	EWeaponType WeaponType;
};

```

`Source/Blaster/Pickups/BacktrackingPickup.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "BacktrackingPickup.h"

#include "Blaster/BlasterComponents/BuffComponent.h"
#include "Blaster/Character/BlasterCharacter.h"

ABacktrackingPickup::ABacktrackingPickup()
{
}

void ABacktrackingPickup::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                                          UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	if (ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor))
	{
		if (UBuffComponent* Buff = BlasterCharacter->GetBuff())
		{
			Buff->AddBacktracking(BacktrackingTime, BuffAliveTime, BacktrackingCostTime);
		}
	}

}

```

`Source/Blaster/Pickups/BacktrackingPickup.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Pickup.h"
#include "BacktrackingPickup.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API ABacktrackingPickup : public APickup
{
	GENERATED_BODY()

public:
	ABacktrackingPickup();

private:
	virtual void OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult) override;

private:
	UPROPERTY(EditAnywhere)
	float BacktrackingTime = 5.f;	// 回溯时间

	UPROPERTY(EditAnywhere)
	float BacktrackingCostTime = 1.f;	// 回溯消耗时间

	UPROPERTY(EditAnywhere)
	float BuffAliveTime = 10.f;		// buff存活时间
};

```

`Source/Blaster/Pickups/HealthPickup.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "HealthPickup.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/BlasterComponents/BuffComponent.h"

AHealthPickup::AHealthPickup()
{
	bReplicates = true;	// 开启复制

}

void AHealthPickup::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                                    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (BlasterCharacter)
	{
		UBuffComponent* Buff = BlasterCharacter->GetBuff();
		if (Buff)
		{
			Buff->AddHealth(HealthAmount, HealingTime);
		}
	}
	Destroy();
}

```

`Source/Blaster/Pickups/HealthPickup.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Pickup.h"
#include "HealthPickup.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API AHealthPickup : public APickup
{
	GENERATED_BODY()

public:
	AHealthPickup();

protected:
	virtual void OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	                             UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep,
	                             const FHitResult& SweepResult) override;

private:
	UPROPERTY(EditAnywhere)
	float HealthAmount = 50.0f;	// 血量

	UPROPERTY(EditAnywhere)
	float HealingTime = 7.0f;	// 治疗时间，因为我们希望在拾取后有一个治疗的过程，而不是立刻就回满血量，所以我们需要一个治疗时间
};

```

`Source/Blaster/Pickups/JumpPickup.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "JumpPickup.h"

#include "Blaster/BlasterComponents/BuffComponent.h"
#include "Blaster/Character/BlasterCharacter.h"

AJumpPickup::AJumpPickup()
{
}

void AJumpPickup::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                                  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (BlasterCharacter)
	{
		if (UBuffComponent* Buff = BlasterCharacter->GetBuff())
		{
			Buff->AddJump(JumpZVelocity, JumpBuffTime);
		}
	}
	Destroy();
}

```

`Source/Blaster/Pickups/JumpPickup.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Pickup.h"
#include "JumpPickup.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API AJumpPickup : public APickup
{
	GENERATED_BODY()

public:
	AJumpPickup();

private:
	virtual void OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult) override;

private:
	UPROPERTY(EditAnywhere)
	float JumpZVelocity = 2400.f;	// 跳跃速度

	UPROPERTY(EditAnywhere)
	float JumpBuffTime = 10.f;	// 跳跃buff时间
};

```

`Source/Blaster/Pickups/Pickup.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Pickup.h"

#include "NiagaraComponent.h"
#include "NiagaraFunctionLibrary.h"
#include "Kismet/GameplayStatics.h"
#include "Sound/SoundCue.h"
#include "Components/SphereComponent.h"
#include "Blaster/Weapon/WeaponTypes.h"

// Sets default values
APickup::APickup()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	bReplicates = true;

	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));		// 创建根组件
	OverlapSphere = CreateDefaultSubobject<USphereComponent>(TEXT("OverlapShpere"));		// 创建碰撞球体
	OverlapSphere->SetupAttachment(RootComponent);		// 将碰撞球体附加到根组件
	OverlapSphere->SetSphereRadius(150.f);		// 设置碰撞球体半径
	OverlapSphere->SetCollisionEnabled(ECollisionEnabled::QueryOnly);		// 设置碰撞球体为查询碰撞
	OverlapSphere->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);		// 设置碰撞球体对所有通道的碰撞响应为忽略
	OverlapSphere->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);		// 设置碰撞球体对Pawn通道的碰撞响应为重叠

	// 设置拾取网格体的初始位置，初始大小
	OverlapSphere->AddLocalOffset(FVector(0.f, 0.f, 85.f));	// 设置碰撞球体的初始位置


	PickupMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("PickupMesh"));		// 创建拾取物体的静态网格组件
	PickupMesh->SetupAttachment(OverlapSphere);		// 将拾取物体的静态网格组件附加到碰撞球体
	PickupMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);		// 设置拾取物体的静态网格组件为无碰撞
	PickupMesh->SetRelativeScale3D(FVector(5.0f, 5.0f, 5.0f));		// 设置拾取物体的静态网格组件的初始大小
	PickupMesh->SetRenderCustomDepth(true);	// 开启自定义深度渲染
	PickupMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_PURPLE);	// 设置自定义深度值

	PickupEffectNiagaraComponent = CreateDefaultSubobject<UNiagaraComponent>(TEXT("PickupEffectNiagaraComponent"));		// 创建拾取特效
	PickupEffectNiagaraComponent->SetupAttachment(RootComponent);		// 设置拾取特效的父组件为根组件

}

void APickup::Destroyed()
{
	Super::Destroyed();

	if (PickupSound)
	{
		UGameplayStatics::PlaySoundAtLocation(
			this,
			PickupSound,
			GetActorLocation()
		);
	}

	if (PickupEffectNiagaraSystem)
	{
		// 我希望拾取组件被拾取后，有一个销毁的特效，所以我这里创建了一个NiagaraSystem，这与NiagaraComponent的创建方式不同，
		// 这里我们使用了NiagaraFunctionLibrary::SpawnSystemAtLocation()方法来创建NiagaraSystem
		// 这个方法需要传入一个WorldContextObject，这里我们传入this，因为我们希望在这个Actor的位置创建特效
		// 然后传入NiagaraSystem，这里我们传入了PickupEffectNiagaraSystem，这个变量在HealthPickup.h中定义
		// 最后传入位置和旋转，这里我们传入了血宝的位置和旋转
		UNiagaraFunctionLibrary::SpawnSystemAtLocation(this, PickupEffectNiagaraSystem, GetActorLocation(), GetActorRotation());
	}
}

// Called when the game starts or when spawned
void APickup::BeginPlay()
{
	Super::BeginPlay();

	if (HasAuthority())
	{
		GetWorldTimerManager().SetTimer(BindOverlapTimer, this, &APickup::BindOverlapTimerFinished, BindOverlapTime);
	}

	
}

void APickup::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{

}

void APickup::BindOverlapTimerFinished()
{
	if (HasAuthority())
	{
		OverlapSphere->OnComponentBeginOverlap.AddDynamic(this, &APickup::OnSphereOverlap);
	}
}

// Called every frame
void APickup::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	if (PickupMesh)
	{
		PickupMesh->AddRelativeRotation(FRotator(0.f, 1.f, 0.f));		// 拾取物体的静态网格组件每帧旋转
	}
}


```

`Source/Blaster/Pickups/Pickup.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Pickup.generated.h"

UCLASS()
class BLASTER_API APickup : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	APickup();
	virtual void Destroyed() override;

	virtual void Tick(float DeltaTime) override;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

	UFUNCTION()
	virtual void OnSphereOverlap(
		UPrimitiveComponent* OverlappedComponent,	// 该组件将被触发
		AActor* OtherActor,							// 与该组件发生重叠的Actor
		UPrimitiveComponent* OtherComp,			// 与该组件发生重叠的组件
		int32 OtherBodyIndex,						// 与该组件发生重叠的组件的BodyIndex
		bool bFromSweep,							// 是否是由Sweep引起的重叠
		const FHitResult& SweepResult				// Sweep引起的重叠的结果
	);

	UPROPERTY(EditAnywhere)
	float BaseTurnRate = 45.f;		// 基础旋转速率 (deg/sec)

private:
	UPROPERTY(EditAnywhere)
	class USphereComponent* OverlapSphere;

	UPROPERTY(EditAnywhere)
	class USoundCue* PickupSound;

	UPROPERTY(EditAnywhere)
	UStaticMeshComponent* PickupMesh;


	UPROPERTY(VisibleAnywhere)
	class UNiagaraComponent* PickupEffectNiagaraComponent;		// 拾取特效

	UPROPERTY(EditAnywhere)
	class UNiagaraSystem* PickupEffectNiagaraSystem;		// 拾取特效的NiagaraSystem

	FTimerHandle BindOverlapTimer;		// 绑定重叠事件的定时器

	float BindOverlapTime = 0.25f;		// 绑定重叠时间

	void BindOverlapTimerFinished();	// 绑定重叠事件的定时器结束时调用的函数

public:


};

```

`Source/Blaster/Pickups/PickupSpawnPoint.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "PickupSpawnPoint.h"

#include "Pickup.h"

// Sets default values
APickupSpawnPoint::APickupSpawnPoint()
{
	PrimaryActorTick.bCanEverTick = true;

	bReplicates = true;	// 开启复制

}

// Called when the game starts or when spawned
void APickupSpawnPoint::BeginPlay()
{
	Super::BeginPlay();

	StartSpawnPickupTimer(nullptr);	// 开始生成拾取的定时器
	
}

void APickupSpawnPoint::SpawnPickup()
{
	if (PickupClasses.Num() > 0)	// 如果我们的拾取类数量大于0，我们就可以生成一个拾取
	{
		UWorld* World = GetWorld();
		if (World)
		{
			int32 RandomIndex = FMath::RandRange(0, PickupClasses.Num() - 1);	// 生成一个随机数，用于选择一个拾取类
			SpawnedPickup = World->SpawnActor<APickup>(PickupClasses[RandomIndex], GetActorTransform());	// 生成一个拾取

			if (HasAuthority() && SpawnedPickup)
			{
				SpawnedPickup->OnDestroyed.AddDynamic(this, &APickupSpawnPoint::StartSpawnPickupTimer);	// 当拾取被销毁时，重新开始生成拾取的定时器
			}

		}
	}
}

void APickupSpawnPoint::SpawnPickupTimerFinished()
{
	if (HasAuthority())	// 如果是服务器
	{
		SpawnPickup();	// 生成拾取
		// StartSpawnPickupTimer();	// 重新开始生成拾取的定时器
	}
}

void APickupSpawnPoint::StartSpawnPickupTimer(AActor* DestoryedActor)
{
	// 生成一个随机时间，用于生成拾取
	const float SpawnTime = FMath::RandRange(SpawnTimeMin, SpawnTimeMax);
	// 设置定时器，用于生成拾取
	GetWorldTimerManager().SetTimer(SpawnPickupTimer, this, &APickupSpawnPoint::SpawnPickupTimerFinished, SpawnTime);
}

// Called every frame
void APickupSpawnPoint::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}


```

`Source/Blaster/Pickups/PickupSpawnPoint.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "PickupSpawnPoint.generated.h"

UCLASS()
class BLASTER_API APickupSpawnPoint : public AActor
{
	GENERATED_BODY()
	
public:	
	APickupSpawnPoint();
	virtual void Tick(float DeltaTime) override;

protected:
	virtual void BeginPlay() override;

	UPROPERTY(EditAnywhere)
	TArray<TSubclassOf<class APickup>> PickupClasses;		// 用于存储所有的Pickup类

	UPROPERTY(VisibleAnywhere)
	APickup* SpawnedPickup;		// 用于存储生成的Pickup

	void SpawnPickup();		// 生成Pickup
	void SpawnPickupTimerFinished();		// 定时器结束时调用的函数

	UFUNCTION()
	void StartSpawnPickupTimer(AActor* DestoryedActor);			// 开始生成Pickup的定时器

private:
	FTimerHandle SpawnPickupTimer;			// 用于生成Pickup的定时器

	UPROPERTY(EditAnywhere)
	float SpawnTimeMin = 5.0f;				// 生成Pickup的最小时间

	UPROPERTY(EditAnywhere)
	float SpawnTimeMax = 10.0f;				// 生成Pickup的最大时间

};

```

`Source/Blaster/Pickups/ShieldPickup.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ShieldPickup.h"

#include "Blaster/BlasterComponents/BuffComponent.h"
#include "Blaster/Character/BlasterCharacter.h"

void AShieldPickup::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                                    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (BlasterCharacter)
	{
		UBuffComponent* BuffComponent = BlasterCharacter->GetBuff();
		if (BuffComponent)
		{
			BuffComponent->ReplenishShield(ShieldReplenishAmount, ShieldReplenishTime);
		}
	}

	Destroy();
}

```

`Source/Blaster/Pickups/ShieldPickup.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Pickup.h"
#include "ShieldPickup.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API AShieldPickup : public APickup
{
	GENERATED_BODY()

protected:
	virtual void OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult) override;

private:
	UPROPERTY(EditAnywhere)
	float ShieldReplenishAmount = 50.0f;	// 护盾补充量

	UPROPERTY(EditAnywhere)
	float ShieldReplenishTime = 0.5f;		// 护盾补充时间

};

```

`Source/Blaster/Pickups/SpeedPickup.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "SpeedPickup.h"

#include "Blaster/BlasterComponents/BuffComponent.h"
#include "Blaster/Character/BlasterCharacter.h"

ASpeedPickup::ASpeedPickup()
{
}

void ASpeedPickup::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	
	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (BlasterCharacter)
	{
		UBuffComponent* Buff = BlasterCharacter->GetBuff();
		if (Buff)
		{
			Buff->AddSpeed(BaseSpeedBuff, CrouchSpeedBuff, SpeedBuffTime);
		}
	}

	Destroy();
}

```

`Source/Blaster/Pickups/SpeedPickup.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Pickup.h"
#include "SpeedPickup.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API ASpeedPickup : public APickup
{
	GENERATED_BODY()

public:
	ASpeedPickup();

protected:
	virtual void OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult) override;	// 碰撞体重叠时调用


private:
	UPROPERTY(EditAnywhere)
	float BaseSpeedBuff = 1600.5f;	// 基础速度加成

	UPROPERTY(EditAnywhere)
	float CrouchSpeedBuff = 0.5f;	// 蹲下速度加成

	float SpeedBuffTime = 3.0f;	// 速度加成持续时间
};

```

`Source/Blaster/PlayerController/BlasterPlayerController.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "BlasterPlayerController.h"

#include "Animation/WidgetAnimation.h"
#include "Blaster/HUD/BlasterHUD.h"
#include "Blaster/HUD/CharacterOverlay.h"
#include "Components/ProgressBar.h"
#include "Components/TextBlock.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Net/UnrealNetwork.h"
#include "Blaster/GameMode/BlasterGameMode.h"
#include "Blaster/HUD/Announcement.h"
#include "Kismet/GameplayStatics.h"
#include "Blaster/BlasterComponents/CombatComponent.h"
#include "Blaster/BlasterTypes/Announcement.h"
#include "Blaster/GameState/BlasterGameState.h"
#include "Blaster/HUD/ReturnToMainMenu.h"
#include "Blaster/PlayerState/BlasterPlayerState.h"
#include "Components/Image.h"
#include "GameFramework/PlayerState.h"

void ABlasterPlayerController::BeginPlay()
{
	Super::BeginPlay();

	BlasterHUD = Cast<ABlasterHUD>(GetHUD());

	ServerCheckMatchState();
}

void ABlasterPlayerController::SetupInputComponent()
{
	Super::SetupInputComponent();

	// 绑定Esc键
	if (InputComponent)
	{
		InputComponent->BindAction("Quit", IE_Pressed, this, &ABlasterPlayerController::ShowReturnToMainMenu);
	}

}

void ABlasterPlayerController::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	SetHUDTime();

	CheckTimeSync(DeltaSeconds);

	PollInit();

	CheckHighPing(DeltaSeconds);
}

void ABlasterPlayerController::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ABlasterPlayerController, MatchState);
	DOREPLIFETIME(ABlasterPlayerController, bShowTeamScores);
}

void ABlasterPlayerController::HideTeamScores()
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
	bool bHUDValid = BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->RedTeamScore &&
		BlasterHUD->CharacterOverlay->BlueTeamScore;

	if (bHUDValid)
	{
		BlasterHUD->CharacterOverlay->RedTeamScore->SetVisibility(ESlateVisibility::Hidden);
		BlasterHUD->CharacterOverlay->BlueTeamScore->SetVisibility(ESlateVisibility::Hidden);
	}
}

void ABlasterPlayerController::InitializeTeamScores()
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
	bool bHUDValid = BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->RedTeamScore &&
		BlasterHUD->CharacterOverlay->BlueTeamScore;

	if (bHUDValid)
	{
		const FString RedTeamScoreString = FString::Printf(TEXT("%d"), 0);
		const FString BlueTeamScoreString = FString::Printf(TEXT("%d"), 0);
		BlasterHUD->CharacterOverlay->RedTeamScore->SetText(FText::FromString(RedTeamScoreString));
		BlasterHUD->CharacterOverlay->BlueTeamScore->SetText(FText::FromString(BlueTeamScoreString));
		BlasterHUD->CharacterOverlay->RedTeamScore->SetVisibility(ESlateVisibility::Visible);
		BlasterHUD->CharacterOverlay->BlueTeamScore->SetVisibility(ESlateVisibility::Visible);
		bInitializeTeamScores = false;
	}
	else
	{
		bInitializeTeamScores = true;
	}
}

void ABlasterPlayerController::SetHUDRedTeamScores(int32 Scores)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->RedTeamScore;

	if (bHUDValid)
	{
		FString ScoreText = FString::Printf(TEXT("%d"), Scores);
		BlasterHUD->CharacterOverlay->RedTeamScore->SetText(FText::FromString(ScoreText));
		BlasterHUD->CharacterOverlay->RedTeamScore->SetVisibility(ESlateVisibility::Visible);
	}
	else
	{
		bInitializeScore = true;
		HUDScore = Scores;
	}
}

void ABlasterPlayerController::SetHUDBlueTeamScores(int32 Scores)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->BlueTeamScore;

	if (bHUDValid)
	{
		FString ScoreText = FString::Printf(TEXT("%d"), Scores);
		BlasterHUD->CharacterOverlay->BlueTeamScore->SetText(FText::FromString(ScoreText));
		BlasterHUD->CharacterOverlay->BlueTeamScore->SetVisibility(ESlateVisibility::Visible);
	}
	else
	{
		bInitializeScore = true;
		HUDScore = Scores;
	}
}

void ABlasterPlayerController::OnPossess(APawn* InPawn)
{
	Super::OnPossess(InPawn);

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(InPawn);
	if (BlasterCharacter)
	{
		SetHUDHealth(BlasterCharacter->GetHealth(), BlasterCharacter->GetMaxHealth());
	}
}

float ABlasterPlayerController::GetServerTime()
{
	return GetWorld()->GetTimeSeconds() + ClientServerDelta;
}

void ABlasterPlayerController::ReceivedPlayer()
{
	Super::ReceivedPlayer();

	if (IsLocalController())
	{
		ServerRequestServerTime(GetWorld()->GetTimeSeconds());
	}
}

void ABlasterPlayerController::OnMatchStateSet(FName state, bool bTeamMatch)
{
	MatchState = state;

	if (MatchState == MatchState::InProgress)
	{
		HandleMatchHasStarted(bTeamMatch);
	}
	else if (MatchState == MatchState::Cooldown)
	{
		HandleCooldown();
	}
	
}

void ABlasterPlayerController::OnRep_MatchState()
{
	if (MatchState == MatchState::InProgress)
	{
		HandleMatchHasStarted();
	}
	else if (MatchState == MatchState::Cooldown)
	{
		HandleCooldown();
	}
}

void ABlasterPlayerController::SetHUDTime()
{
	float TimeLeft = 0.f;
	if (MatchState == MatchState::WaitingToStart)
	{
		TimeLeft = WarmupTime - GetServerTime() + LevelStartingTime;
	}
	else if (MatchState == MatchState::InProgress)
	{
		TimeLeft = WarmupTime + MatchTime - GetServerTime() + LevelStartingTime;
	}
	else if (MatchState == MatchState::Cooldown)
	{
		TimeLeft = CooldownTime + WarmupTime + MatchTime - GetServerTime() + LevelStartingTime;
	}

	uint32 SecondsLeft = FMath::CeilToInt(TimeLeft);

	/*if (HasAuthority())
	{
		BlasterGameMode = BlasterGameMode == nullptr ? Cast<ABlasterGameMode>(UGameplayStatics::GetGameMode(this)) : BlasterGameMode;
		if (BlasterGameMode)
		{
			SecondsLeft = FMath::CeilToInt(BlasterGameMode->GetCountdownTime() + LevelStartingTime);
		}
	}*/

	if (CountdownInt != SecondsLeft)
	{
		if (MatchState == MatchState::WaitingToStart || MatchState == MatchState::Cooldown)
		{
			SetHUDAnnouncementCountdown(TimeLeft);
		}
		if (MatchState == MatchState::InProgress)
		{
			SetHUDMatchCountdown(TimeLeft);
		}
		
	}
	CountdownInt = SecondsLeft;
}

void ABlasterPlayerController::PollInit()
{
	if (CharacterOverlay == nullptr)
	{
		if (BlasterHUD && BlasterHUD->CharacterOverlay)
		{
			CharacterOverlay = BlasterHUD->CharacterOverlay;

			if (CharacterOverlay)
			{
				if (bInitializeHealth) SetHUDHealth(HUDHealth, HUDMaxHealth);
				if (bInitializeShield) {
					SetHUDShield(HUDShield, HUDMaxShield);
					SetHUDShieldNative(HUDShield, HUDMaxShield);
				}
				/*SetHUDHealthAddition(HUDHealthAddition, HUDMaxHealth);
				SetHUDHealthSubtraction(HUDHealthSubtraction, HUDMaxHealth);*/
				if (bInitializeScore) SetHUDScore(HUDScore);
				if (bInitializeDefeats) SetHUDDefeats(HUDDefeats);
				if (bInitializeWeaponAmmo) SetHUDWeaponAmmo(HUDWeaponAmmo);
				if (bInitializeCarriedAmmo) SetHUDCarriedAmmo(HUDCarriedAmmo);
				if (bInitializeBeforeHealth) SetHUDHealthNative(HUDHealth, HUDMaxHealth, HUDHealth, HUDHealth);
				if (!HasAuthority() && bInitializeTeamScores && bShowTeamScores) InitializeTeamScores();

				ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(GetPawn());
				if (BlasterCharacter && BlasterCharacter->GetCombat())
				{
					if (bInitializeGrenades) SetHUDGrenades(BlasterCharacter->GetCombat()->GetGrenadeCount());
				}
				
			}
		}
	}
}

void ABlasterPlayerController::CheckTimeSync(float DeltaTime)
{
	TimeSyncRunningTime += DeltaTime;

	if (IsLocalController() && TimeSyncRunningTime >= TimeSyncFrequency)
	{
		ServerRequestServerTime(GetWorld()->GetTimeSeconds());
		TimeSyncRunningTime = 0.f;
	}
}

void ABlasterPlayerController::HandleMatchHasStarted(bool bTeamMatch)
{
	if (HasAuthority()) bShowTeamScores = bTeamMatch;

	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
	if (BlasterHUD)
	{
		if (BlasterHUD->CharacterOverlay == nullptr)
		{
			BlasterHUD->AddCharacterOverlay();
		}
		if (BlasterHUD->Announcement)
		{
			BlasterHUD->Announcement->SetVisibility(ESlateVisibility::Hidden);
		}

		if (!HasAuthority()) return;

		if (bTeamMatch)
		{
			InitializeTeamScores();
		}
		else
		{
			HideTeamScores();
		}
	}
}

void ABlasterPlayerController::HandleCooldown()
{

	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
	if (BlasterHUD)
	{
		BlasterHUD->CharacterOverlay->RemoveFromParent();
		const bool bHUDValid = BlasterHUD->Announcement &&
			BlasterHUD->Announcement->AnnouncementText && 
			BlasterHUD->Announcement->InfoText;
		if (bHUDValid)
		{
			BlasterHUD->Announcement->SetVisibility(ESlateVisibility::Visible);
			const FString AnnouncementText = Announcement::NewMatchStartsIn;
			BlasterHUD->Announcement->AnnouncementText->SetText(FText::FromString(AnnouncementText));

			ABlasterGameState* BlasterGameState = Cast<ABlasterGameState>(UGameplayStatics::GetGameState(this));
			ABlasterPlayerState* BlasterPlayerState = GetPlayerState<ABlasterPlayerState>();
			if (BlasterGameState && BlasterPlayerState)
			{
				const TArray<ABlasterPlayerState*>TopPlayers = BlasterGameState->TopScoringPlayers;
				const FString InfoTextString = bShowTeamScores ? GetTeamsInfoText(BlasterGameState) : GetInfoText(TopPlayers);
				BlasterHUD->Announcement->InfoText->SetText(FText::FromString(InfoTextString));
			}
		}
	}

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(GetPawn());
	if (BlasterCharacter && BlasterCharacter->GetCombat())
	{
		BlasterCharacter->bDisableGamePlay = true;

		BlasterCharacter->GetCombat()->FireButtonPressed(false);
	}

}

void ABlasterPlayerController::HighPingWarning()
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
	bool bHUDValid = BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->HighPingImage &&
		BlasterHUD->CharacterOverlay->HighPingAnimation;

	if (bHUDValid)
	{
		BlasterHUD->CharacterOverlay->HighPingImage->SetOpacity(1.f);
		BlasterHUD->CharacterOverlay->PlayAnimation(BlasterHUD->CharacterOverlay->HighPingAnimation, 0, 5);
	}
}

void ABlasterPlayerController::StopHighPingWarning()
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
	bool bHUDValid = BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->HighPingImage &&
		BlasterHUD->CharacterOverlay->HighPingAnimation;

	if (bHUDValid)
	{
		BlasterHUD->CharacterOverlay->HighPingImage->SetOpacity(0.f);
		if (BlasterHUD->CharacterOverlay->IsAnimationPlaying(BlasterHUD->CharacterOverlay->HighPingAnimation))
		{
			BlasterHUD->CharacterOverlay->StopAnimation(BlasterHUD->CharacterOverlay->HighPingAnimation);
		}
	}
}

void ABlasterPlayerController::CheckHighPing(float DeltaSeconds)
{
	HighPingWarningTime += DeltaSeconds;
	if (HighPingWarningTime >= HighPingWarningFrequency)
	{
		PlayerState = PlayerState == nullptr ? GetPlayerState<ABlasterPlayerState>() : PlayerState;
		if (PlayerState)
		{
			// UKismetSystemLibrary::PrintString(this, FString::Printf(TEXT("Ping: %d"), static_cast<int>(PlayerState->GetPingInMilliseconds())));
			if (PlayerState->GetPingInMilliseconds() > HighPingThreshold)
			{
				HighPingWarning();
				PingAnimationRunningTime = 0;
				ServerReportPingStatus(true);
			}
			else
			{
				ServerReportPingStatus(false);
			}
		}
		HighPingWarningTime = 0.f;
	}
	if (BlasterHUD && BlasterHUD->CharacterOverlay && BlasterHUD->CharacterOverlay->HighPingAnimation && BlasterHUD->CharacterOverlay->IsAnimationPlaying(BlasterHUD->CharacterOverlay->HighPingAnimation))
	{
		PingAnimationRunningTime += DeltaSeconds;
		if (PingAnimationRunningTime >= HighPingWarningDuration)
		{
			StopHighPingWarning();
		}
	}
}

void ABlasterPlayerController::OnRep_ShowTeamScores()
{
	if (bShowTeamScores)
	{
		InitializeTeamScores();
	}
	else
	{
		HideTeamScores();
	}
}

FString ABlasterPlayerController::GetInfoText(const TArray<ABlasterPlayerState*>& TopPlayers)
{
	FString InfoTextString;

	ABlasterPlayerState* BlasterPlayerState = GetPlayerState<ABlasterPlayerState>();
	if (!BlasterPlayerState) return InfoTextString;
	
	if (TopPlayers.Num() == 0)
	{
		InfoTextString = Announcement::NoWinner;
	}
	else if (TopPlayers.Num() == 1 && TopPlayers[0] == BlasterPlayerState)
	{
		InfoTextString = Announcement::YouAreTheWinner;
	}
	else if (TopPlayers.Num() == 1)
	{
		InfoTextString = FString::Printf(TEXT("获胜者: \n%s"), *TopPlayers[0]->GetPlayerName());
	}
	else if (TopPlayers.Num() > 1)
	{
		InfoTextString = Announcement::PlayersTiedForTheWin;
		InfoTextString.Append(FString("\n"));
		for (const auto TiedPlayer : TopPlayers)
		{
			InfoTextString.Append(FString::Printf(TEXT("%s\n"), *TiedPlayer->GetPlayerName()));
		}
	}

	return InfoTextString;
}

FString ABlasterPlayerController::GetTeamsInfoText(ABlasterGameState* BlasterGameState)
{
	if (BlasterGameState == nullptr) return FString();
	FString InfoTextString;

	const int32 RedTeamScore = BlasterGameState->RedTeamScore;
	const int32 BlueTeamScore = BlasterGameState->BlueTeamScore;

	if (RedTeamScore == 0 && BlueTeamScore == 0)
	{
		InfoTextString = Announcement::NoWinner;
	}
	else if (RedTeamScore == BlueTeamScore)
	{
		InfoTextString = FString::Printf(TEXT("%s\n"), *Announcement::TeamsTiedForTheWin);
		InfoTextString.Append(Announcement::RedTeam);
		InfoTextString.Append(TEXT("\n"));
		InfoTextString.Append(Announcement::BlueTeam);
		InfoTextString.Append(TEXT("\n"));
	}
	else if (RedTeamScore > BlueTeamScore)
	{
		InfoTextString = Announcement::RedTeamWins;
		InfoTextString.Append(TEXT("\n"));
		InfoTextString.Append(FString::Printf(TEXT("%s: %d\n"), *Announcement::RedTeam, RedTeamScore));
		InfoTextString.Append(FString::Printf(TEXT("%s: %d\n"), *Announcement::BlueTeam, BlueTeamScore));
	}
	else if (BlueTeamScore > RedTeamScore)
	{
		InfoTextString = Announcement::BlueTeamWins;
		InfoTextString.Append(TEXT("\n"));
		InfoTextString.Append(FString::Printf(TEXT("%s: %d\n"), *Announcement::BlueTeam, BlueTeamScore));
		InfoTextString.Append(FString::Printf(TEXT("%s: %d\n"), *Announcement::RedTeam, RedTeamScore));
	}

	return InfoTextString;
}

void ABlasterPlayerController::ServerReportPingStatus_Implementation(bool bHighPing)
{
	HighPingDelegate.Broadcast(bHighPing);
}

void ABlasterPlayerController::ClientJoinMidGame_Implementation(FName StateOfMatch, float Warmup, float Match, float Cooldown, float StartingTime)
{
	WarmupTime = Warmup;
	MatchTime = Match;
	CooldownTime = Cooldown;
	LevelStartingTime = StartingTime;
	MatchState = StateOfMatch;

	OnMatchStateSet(MatchState);

	// 只有在HUD组件构建成功，并且游戏状态处于等待开始的阶段，才进行公告UI展示
	if (BlasterHUD && MatchState == MatchState::WaitingToStart)
	{
		BlasterHUD->AddAnnouncement();
	}
}

void ABlasterPlayerController::ServerCheckMatchState_Implementation()
{
	ABlasterGameMode* GameMode = Cast<ABlasterGameMode>(UGameplayStatics::GetGameMode(this));

	if (GameMode)
	{
		WarmupTime = GameMode->WarmupTime;
		MatchTime = GameMode->MatchTime;
		LevelStartingTime = GameMode->LevelStartingTime;
		CooldownTime = GameMode->CooldownTime;
		MatchState = GameMode->GetMatchState();

		ClientJoinMidGame(MatchState, WarmupTime, MatchTime, CooldownTime, LevelStartingTime);

	}
}

void ABlasterPlayerController::ClientReportServerTime_Implementation(float TimeOfClientRequest, float TimeServerReceivedClientRequest)
{
	// 通信往返时间
	const float RoundTripTime = GetWorld()->GetTimeSeconds() - TimeOfClientRequest;
	SingleTripTime = RoundTripTime * 0.5f;
	// 计算服务器当前时间
	const float CurrentServerTime = TimeServerReceivedClientRequest + SingleTripTime;

	ClientServerDelta = CurrentServerTime - GetWorld()->GetTimeSeconds();
}

void ABlasterPlayerController::ServerRequestServerTime_Implementation(float TimeOfClientRequest)
{
	const float ServerTimeOfReceipt = GetWorld()->GetTimeSeconds();
	ClientReportServerTime(TimeOfClientRequest, ServerTimeOfReceipt);
}

void ABlasterPlayerController::SetHUDHealth(float Health, float MaxHealth)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->HealthBar &&
		BlasterHUD->CharacterOverlay->HealthText;

	if (bHUDValid)
	{
		const float HealthPercent = Health / MaxHealth;
		BlasterHUD->CharacterOverlay->HealthBar->SetPercent(HealthPercent);
		FString HealthText = FString::Printf(TEXT("%d / %d"), FMath::CeilToInt(Health), FMath::CeilToInt(MaxHealth));
		BlasterHUD->CharacterOverlay->HealthText->SetText(FText::FromString(HealthText));
	}
	else
	{
		bInitializeHealth = true;
		HUDHealth = Health;
		HUDMaxHealth = MaxHealth;
	}
}

void ABlasterPlayerController::SetHUDHealthNative(float Health, float MaxHealth, float BeforeHealth, float AfterHealHealth)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->HealthBarNative;

	if (bHUDValid)
	{
		const float BeforeHealthPercent = BeforeHealth / MaxHealth;
		const float HealthPercent = Health / MaxHealth;
		const float AfterHealHealthPercent = AfterHealHealth / MaxHealth;
		if (UMaterialInstanceDynamic* HealthBarMaterial = BlasterHUD->CharacterOverlay->HealthBarNative->GetDynamicMaterial())
		{
			HealthBarMaterial->SetScalarParameterValue(FName("Before"), BeforeHealthPercent);
			HealthBarMaterial->SetScalarParameterValue(FName("Current"), HealthPercent);
			HealthBarMaterial->SetScalarParameterValue(FName("After"), AfterHealHealthPercent);
			// 设置播放动画时间范围
		}
		
	}
	else
	{
		bInitializeBeforeHealth = true;
		HUDBeforeDamage = Health;
		HUDMaxBeforeDamageHealth = MaxHealth;
	}
}


void ABlasterPlayerController::SetHUDShieldNative(float Shield, float MaxShield)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->HealthBarNative;

	if (bHUDValid)
	{
		const float ShieldPercent = Shield / MaxShield;
		if (UMaterialInstanceDynamic* ShieldBarMaterial = BlasterHUD->CharacterOverlay->HealthBarNative->GetDynamicMaterial())
		{
			ShieldBarMaterial->SetScalarParameterValue(FName("Shield"), ShieldPercent);
		}
	}
	else
	{
		bInitializeShield = true;
		HUDShield = Shield;
		HUDMaxShield = MaxShield;
	}
}


void ABlasterPlayerController::SetHUDShield(float Shield, float MaxShield)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD &&	// HUD存在
			BlasterHUD->CharacterOverlay &&	// HUD的角色信息UI存在
			BlasterHUD->CharacterOverlay->ShieldBar_R2L &&	// HUD的角色信息UI的护盾条存在(从右到左)
			BlasterHUD->CharacterOverlay->ShieldBar_L2R &&	// HUD的角色信息UI的护盾条存在(从左到右)
			BlasterHUD->CharacterOverlay->ShieldText;	// HUD的角色信息UI的护盾值文本存在

	if (bHUDValid)
	{
		float ShieldPercent = Shield / MaxShield;
		
		// 如果我们的护盾值小于等于当前血条的反向值，那么护盾值的起始点就是血条的终点（为了实现这种效果，我将护盾的百分比加上血条百分比）
		if (BlasterHUD->CharacterOverlay->HealthBar->Percent < 1.f && ShieldPercent > 0 && ShieldPercent <= 1.f - BlasterHUD->CharacterOverlay->HealthBar->Percent)
		{
			ShieldPercent += BlasterHUD->CharacterOverlay->HealthBar->Percent;
			// 然后我们使用从左到右的进度条填充类型
			BlasterHUD->CharacterOverlay->ShieldBar_R2L->SetPercent(0);
			BlasterHUD->CharacterOverlay->ShieldBar_L2R->SetPercent(ShieldPercent);
		}
		else if (BlasterHUD->CharacterOverlay->HealthBar->Percent < 1.f && ShieldPercent > 0 && ShieldPercent > 1.f - BlasterHUD->CharacterOverlay->HealthBar->Percent)
		{
			// 然后我们使用从右到左的进度条填充类型
			BlasterHUD->CharacterOverlay->ShieldBar_R2L->SetPercent(ShieldPercent);
			BlasterHUD->CharacterOverlay->ShieldBar_L2R->SetPercent(0);

		}
		else if (BlasterHUD->CharacterOverlay->HealthBar->Percent == 1.f)
		{
			// 如果我们的血条是满的，那么护盾的进度条的填充类型就是从右到左
			BlasterHUD->CharacterOverlay->ShieldBar_R2L->SetPercent(ShieldPercent);
			BlasterHUD->CharacterOverlay->ShieldBar_L2R->SetPercent(0);
		}

		if (ShieldPercent <= 0.f)
		{
			BlasterHUD->CharacterOverlay->ShieldBar_L2R->SetPercent(0);
			BlasterHUD->CharacterOverlay->ShieldBar_R2L->SetPercent(0);
		}

		FString ShieldString = FString::Printf(TEXT("%d / %d"), FMath::CeilToInt(Shield), FMath::CeilToInt(MaxShield));
		BlasterHUD->CharacterOverlay->ShieldText->SetText(FText::FromString(ShieldString));
	}
	else
	{
		bInitializeShield = true;
		HUDShield = Shield;
		HUDMaxShield = MaxShield;
	}
}

void ABlasterPlayerController::SetHUDScore(float Score)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD && BlasterHUD->CharacterOverlay && BlasterHUD->CharacterOverlay->HealthBar && BlasterHUD->CharacterOverlay->ScoreAmount;

	if (bHUDValid)
	{
		FString ScoreText = FString::Printf(TEXT("%d"), FMath::FloorToInt(Score));
		BlasterHUD->CharacterOverlay->ScoreAmount->SetText(FText::FromString(ScoreText));
	}
	else
	{
		bInitializeScore = true;
		HUDScore = Score;
	}
}

void ABlasterPlayerController::SetHUDDefeats(int32 Defeats)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD && BlasterHUD->CharacterOverlay && BlasterHUD->CharacterOverlay->HealthBar && BlasterHUD->CharacterOverlay->DefeatsAmount;

	if (bHUDValid)
	{
		FString DefeatsText = FString::Printf(TEXT("%d"), Defeats);
		BlasterHUD->CharacterOverlay->DefeatsAmount->SetText(FText::FromString(DefeatsText));
	}
	else
	{
		bInitializeDefeats = true;
		HUDDefeats = Defeats;
	}
}

void ABlasterPlayerController::SetHUDWeaponAmmo(int32 Ammo)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD && BlasterHUD->CharacterOverlay && BlasterHUD->CharacterOverlay->HealthBar && BlasterHUD->CharacterOverlay->WeaponAmmoAmount;

	if (bHUDValid)
	{
		FString AmmoText = FString::Printf(TEXT("%d"), Ammo);
		BlasterHUD->CharacterOverlay->WeaponAmmoAmount->SetText(FText::FromString(AmmoText));
	}
	else
	{
		bInitializeWeaponAmmo = true;
		HUDWeaponAmmo = Ammo;
	}
}

void ABlasterPlayerController::SetHUDCarriedAmmo(int32 Ammo)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD && BlasterHUD->CharacterOverlay && BlasterHUD->CharacterOverlay->HealthBar && BlasterHUD->CharacterOverlay->CarriedAmmoAmount;

	if (bHUDValid)
	{
		FString AmmoText = FString::Printf(TEXT("%d"), Ammo);
		BlasterHUD->CharacterOverlay->CarriedAmmoAmount->SetText(FText::FromString(AmmoText));
	}
	else
	{
		bInitializeCarriedAmmo = true;
		HUDCarriedAmmo = Ammo;
	}
}

void ABlasterPlayerController::SetHUDMatchCountdown(float CountdownTime)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	bool bHUDValid = BlasterHUD && BlasterHUD->CharacterOverlay && BlasterHUD->CharacterOverlay->HealthBar && BlasterHUD->CharacterOverlay->MatchCountdownText;

	if (bHUDValid)
	{
		int32 Minutes = FMath::FloorToInt(CountdownTime / 60.f);
		int32 Seconds = CountdownTime - Minutes * 60.f;

		FString CountdownText = FString::Printf(TEXT("%02d : %02d"), Minutes, Seconds);
		BlasterHUD->CharacterOverlay->MatchCountdownText->SetText(FText::FromString(CountdownText));
	}
}

void ABlasterPlayerController::SetHUDAnnouncementCountdown(float CountdownTime)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	if (BlasterHUD && BlasterHUD->Announcement && BlasterHUD->Announcement->WarmupTime)
	{
		if (CountdownTime < 0.f)
		{
			BlasterHUD->Announcement->WarmupTime->SetText(FText());
			return;
		}

		const int32 Minutes = FMath::FloorToInt(CountdownTime / 60.f);
		const int32 Seconds = CountdownTime - Minutes * 60.f;

		const FString CountdownText = FString::Printf(TEXT("%02d : %02d"), Minutes, Seconds);
		BlasterHUD->Announcement->WarmupTime->SetText(FText::FromString(CountdownText));
	}
}

void ABlasterPlayerController::SetHUDGrenades(int32 Grenades)
{
	BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;

	if (BlasterHUD && BlasterHUD->CharacterOverlay && BlasterHUD->CharacterOverlay->HealthBar && BlasterHUD->CharacterOverlay->GrenadesText)
	{
		const FString GrenadesText = FString::Printf(TEXT("%d"), Grenades);
		BlasterHUD->CharacterOverlay->GrenadesText->SetText(FText::FromString(GrenadesText));
	}
	else
	{
		bInitializeGrenades = true;
		HUDGrenades = Grenades;
	}
}

void ABlasterPlayerController::ShowReturnToMainMenu()
{
	if (ReturnToMainMenuWidget == nullptr) return;

	if (ReturnToMainMenu == nullptr)
	{
		ReturnToMainMenu = CreateWidget<UReturnToMainMenu>(this, ReturnToMainMenuWidget);
	}
	if (ReturnToMainMenu)
	{
		bReturnToMainMenuOpen = !bReturnToMainMenuOpen;
		if (bReturnToMainMenuOpen)
		{
			ReturnToMainMenu->MenuSetup();
		}
		else
		{
			ReturnToMainMenu->MenuTeardown();
		}
	}

}

void ABlasterPlayerController::BroadcastElimAnnouncement(APlayerState* Attacker, APlayerState* Victim)
{
	ClientElimAnnouncement(Attacker, Victim);
}

void ABlasterPlayerController::ClientElimAnnouncement_Implementation(APlayerState* Attacker, APlayerState* Victim)
{
	APlayerState* Self = GetPlayerState<APlayerState>();
	if (Attacker && Victim && Self)
	{
		BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
		if (BlasterHUD)
		{
			if (BlasterHUD->AnnouncementClass)
			{
				if (Attacker == Self && Victim != Self)
				{
					BlasterHUD->AddElimAnnouncement("You", Victim->GetPlayerName());
				}
				else if (Victim == Self && Attacker != Self)
				{
					BlasterHUD->AddElimAnnouncement(Attacker->GetPlayerName(), "You");
				}
				else if (Attacker == Self && Victim == Self)
				{
					BlasterHUD->AddElimAnnouncement("You", "yourself");
				}
				else if (Attacker != Self && Victim != Self && Attacker == Victim)
				{
					BlasterHUD->AddElimAnnouncement(Attacker->GetPlayerName(), "themselves");
				}
				else
				{
					BlasterHUD->AddElimAnnouncement(Attacker->GetPlayerName(), Victim->GetPlayerName());
				}
			}
		}
	}

	
}

```

`Source/Blaster/PlayerController/BlasterPlayerController.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerController.h"
#include "BlasterPlayerController.generated.h"

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FHighPingDelegate, bool, bHighPing);	// 高延迟委托

/**
 *
 */
UCLASS()
class BLASTER_API ABlasterPlayerController : public APlayerController
{
	GENERATED_BODY()

public:
	virtual void Tick(float DeltaSeconds) override;
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

	void SetHUDHealth(float Health, float MaxHealth);	// 设置生命值
	void SetHUDHealthNative(float Health, float MaxHealth, float BeforeDamage, float AfterHealHealth);	// 设置生命值
	void SetHUDShield(float Shield, float MaxShield);	// 设置护盾
	void SetHUDShieldNative(float Shield, float MaxShield);	// 设置护盾
	void SetHUDScore(float Score);
	void SetHUDDefeats(int32 Defeats);
	void SetHUDWeaponAmmo(int32 Ammo);
	void SetHUDCarriedAmmo(int32 Ammo);
	void SetHUDMatchCountdown(float CountdownTime);
	void SetHUDAnnouncementCountdown(float CountdownTime);
	void SetHUDGrenades(int32 Grenades);

	// Team Scores
	void HideTeamScores();	// 隐藏队伍分数
	void InitializeTeamScores();	// 初始化队伍分数
	void SetHUDRedTeamScores(int32 Scores);	// 设置红色队伍分数
	void SetHUDBlueTeamScores(int32 Scores);	// 设置蓝色队伍分数

	virtual float GetServerTime();

	virtual void ReceivedPlayer() override;		// 在玩家加入的时候，尽快与与服务器进行时间同步

	void OnMatchStateSet(FName state, bool bTeamMatch = false);	// 当游戏状态发生变化时，调用该函数

	float SingleTripTime = 0.0f;	// 单程时间

	FHighPingDelegate HighPingDelegate;	// 高延迟委托

	void BroadcastElimAnnouncement(APlayerState* Attacker, APlayerState* Victim);	// 广播击杀公告

protected:
	void ShowReturnToMainMenu();	// 返回主菜单
	virtual void SetupInputComponent() override;	// 设置输入组件
	virtual void BeginPlay() override;	// 当游戏开始时，调用该函数
	virtual void OnPossess(APawn* InPawn) override;		// 当玩家控制器开始控制一个Pawn时，调用该函数
	void SetHUDTime();	// 设置HUD时间
	void PollInit();	// 轮询初始化

	/*
	 * 服务端和客户端之间的同步时间
	 */
	// 请求当前服务器的时间，传入客户端发送请求的时间
	UFUNCTION(Server, Reliable)
	void ServerRequestServerTime(float TimeOfClientRequest);

	// 服务器将客户端的请求时间和服务器当前时间发回给客户端
	UFUNCTION(Client, Reliable)
	void ClientReportServerTime(float TimeOfClientRequest, float TimeServerReceivedClientRequest);

	// 服务端和客户端之间的同步时间差
	float ClientServerDelta = 0.0f;

	// 客户端与服务器同步时间的间隔（频率）
	UPROPERTY(EditAnywhere, Category = Time)
	float TimeSyncFrequency = 5.f;	// 时间同步频率

	float TimeSyncRunningTime = 0.f;	// 时间同步运行时间

	void CheckTimeSync(float DeltaTime);	// 检查时间同步
	void HandleMatchHasStarted(bool bTeamMatch = false);	// 处理游戏开始
	void HandleCooldown();	// 处理冷却时间

	// 服务器检查游戏状态
	UFUNCTION(Server, Reliable)
	void ServerCheckMatchState();

	// 客户端加入游戏
	UFUNCTION(Client, Reliable)
	void ClientJoinMidGame(FName StateOfMatch, float Warmup, float Match, float Cooldown, float StartingTime);	// 客户端在游戏中途加入


	void HighPingWarning();	// 高延迟警告

	void StopHighPingWarning();	// 停止高延迟警告

	void CheckHighPing(float DeltaSeconds);	// 检查高延迟

	UFUNCTION(Client, Reliable)
	void ClientElimAnnouncement(APlayerState* Attacker, APlayerState* Victim);	// 客户端击杀公告

	UPROPERTY(ReplicatedUsing= OnRep_ShowTeamScores)
	bool bShowTeamScores = false;	// 是否显示队伍分数

	UFUNCTION()
	void OnRep_ShowTeamScores();	// 当bShowTeamScores发生变化时，调用该函数

	FString GetInfoText(const TArray<class ABlasterPlayerState*>& Players);	// 获取信息文本
	FString GetTeamsInfoText(class ABlasterGameState* BlasterGameState);	// 获取队伍信息文本

private:
	UPROPERTY()
	class ABlasterHUD* BlasterHUD;	// HUD

	UPROPERTY()
	class ABlasterGameMode* BlasterGameMode;	// 游戏模式

	/*
	 * 返回主菜单
	 */
	UPROPERTY(EditAnywhere, Category=HUD)
	TSubclassOf<class UUserWidget> ReturnToMainMenuWidget;	// 返回主菜单类

	UPROPERTY()
	class UReturnToMainMenu* ReturnToMainMenu;	// 返回主菜单

	bool bReturnToMainMenuOpen = false;	// 返回主菜单是否打开

	float LevelStartingTime = 0.f;	//	游戏开始时间
	float MatchTime = 0.f;		// 游戏时间
	float WarmupTime = 0.f;		// 预热时间
	float CooldownTime = 0.f;	//	冷却时间
	uint32 CountdownInt = 0;	// 倒计时整数部分

	UPROPERTY(ReplicatedUsing = OnRep_MatchState)
	FName MatchState;	// 当前游戏状态

	UFUNCTION()
	void OnRep_MatchState();	// 当MatchState发生变化时，调用该函数

	UPROPERTY()
	class UCharacterOverlay* CharacterOverlay;	// 角色覆盖层
		
	float HUDHealth;	// 生命值
	bool bInitializeHealth = false;	// 是否初始化生命值
	float HUDMaxHealth;	// 最大生命值
	float HUDBeforeDamage;	// 受伤前的生命值
	bool bInitializeBeforeHealth = false;	// 是否初始化最大生命值
	float HUDMaxBeforeDamageHealth;	// 受伤前的护盾
	float HUDShield;	// 护盾
	bool bInitializeShield = false;	// 是否初始化护盾
	float HUDMaxShield;	// 最大护盾
	float HUDScore;	 // 分数
	bool bInitializeScore = false;	// 是否初始化分数
	int32 HUDDefeats;	// 击杀数
	bool bInitializeDefeats = false;	// 是否初始化击杀数
	int32 HUDGrenades;	// 手榴弹数量
	bool bInitializeGrenades = false;	// 是否初始化手榴弹数量
	float HUDCarriedAmmo;	// 携带弹药
	bool bInitializeCarriedAmmo = false;	// 是否初始化携带弹药
	float HUDWeaponAmmo;	// 武器弹药
	bool bInitializeWeaponAmmo = false;	// 是否初始化武器弹药
	bool bInitializeTeamScores = false;	// 是否初始化队伍分数

	UPROPERTY(EditAnywhere)
	float HighPingWarningTime = 0.f;		// 高延迟警告时间

	UPROPERTY(EditAnywhere)
	float PingAnimationRunningTime = 0.f;	// 高延迟警告动画运行时间

	UPROPERTY(EditAnywhere)
	float HighPingWarningDuration = 10.f;	// 高延迟警告持续时间

	UPROPERTY(EditAnywhere)
	float HighPingWarningFrequency = 20.f;			// 检查延迟频率

	UPROPERTY(EditAnywhere)
	float HighPingThreshold = 50.f;	// 高延迟阈值

	UFUNCTION(Server, Reliable)
	void ServerReportPingStatus(bool bHighPing);	// 服务器报告延迟状态
};

```

`Source/Blaster/PlayerStart/TeamPlayerStart.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "TeamPlayerStart.h"


```

`Source/Blaster/PlayerStart/TeamPlayerStart.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerStart.h"
#include "Blaster/BlasterTypes/Team.h"

#include "TeamPlayerStart.generated.h"

/**
 * 玩家出生点（区分队伍）
 */
UCLASS()
class BLASTER_API ATeamPlayerStart : public APlayerStart
{
	GENERATED_BODY()

public:

protected:
	UPROPERTY(EditAnywhere)
	ETeam Team;	// 队伍

private:

public:
	FORCEINLINE ETeam GetTeam() const { return Team; }
};

```

`Source/Blaster/PlayerState/BlasterPlayerState.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "BlasterPlayerState.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "Net/UnrealNetwork.h"

void ABlasterPlayerState::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ABlasterPlayerState, Defeats);
	DOREPLIFETIME(ABlasterPlayerState, Team);
}

void ABlasterPlayerState::AddToScore(float ScoreAmount)
{
	SetScore(GetScore() + ScoreAmount);

	Character = Character == nullptr ? Cast<ABlasterCharacter>(GetPawn()) : Character;
	if (Character)
	{
		Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;

		if (Controller)
		{
			Controller->SetHUDScore(GetScore());
		}
	}
}

void ABlasterPlayerState::AddToDefeats(int32 DefeatsAmount)
{
	Defeats += DefeatsAmount;

	Character = Character == nullptr ? Cast<ABlasterCharacter>(GetPawn()) : Character;
	if (Character)
	{
		Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;

		if (Controller)
		{
			Controller->SetHUDDefeats(Defeats);
		}
	}
}

void ABlasterPlayerState::SetTeam(ETeam NewTeam)
{
	Team = NewTeam;

	Character = Character == nullptr ? Cast<ABlasterCharacter>(GetPawn()) : Character;
	if (Character)
	{
		Character->SetTeamColor(Team);
	}
}

void ABlasterPlayerState::OnRep_Team()
{
	Character = Character == nullptr ? Cast<ABlasterCharacter>(GetPawn()) : Character;
	if (Character)
	{
		Character->SetTeamColor(Team);
	}
}

void ABlasterPlayerState::OnRep_Score()
{
	Super::OnRep_Score();

	Character = Character == nullptr ? Cast<ABlasterCharacter>(GetPawn()) : Character;
	if (Character)
	{
		Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;

		if (Controller)
		{
			Controller->SetHUDScore(GetScore());
		}
	}
}

void ABlasterPlayerState::OnRep_Defeats()
{
	Character = Character == nullptr ? Cast<ABlasterCharacter>(GetPawn()) : Character;
	if (Character)
	{
		Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;

		if (Controller)
		{
			Controller->SetHUDDefeats(Defeats);
		}
	}
}
```

`Source/Blaster/PlayerState/BlasterPlayerState.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blaster/BlasterTypes/Team.h"
#include "GameFramework/PlayerState.h"
#include "BlasterPlayerState.generated.h"

/**
 *
 */
UCLASS()
class BLASTER_API ABlasterPlayerState : public APlayerState
{
	GENERATED_BODY()

public:
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;	// 重写获取生命周期复制属性函数

	virtual void OnRep_Score() override;	// 重写得分复制属性函数

	UFUNCTION()
	virtual void OnRep_Defeats();	// 重写击败复制属性函数

	void AddToScore(float ScoreAmount);		// 增加得分
	void AddToDefeats(int32 DefeatsAmount);	// 增加击败数

private:
	UPROPERTY()
	class ABlasterCharacter* Character;		// 玩家角色

	UPROPERTY()
	class ABlasterPlayerController* Controller;	// 玩家控制器

	UPROPERTY(ReplicatedUsing = OnRep_Defeats)
	int32 Defeats;	// 击败数

	UPROPERTY(ReplicatedUsing = OnRep_Team)
	ETeam Team = ETeam::ET_NoTeam;		// 当前游戏的队伍

	UFUNCTION()
	void OnRep_Team();	// 重写队伍复制属性函数

public:
	FORCEINLINE ETeam GetTeam() const { return Team; }
	void SetTeam(ETeam NewTeam);
};

```

`Source/Blaster/Weapon/Casing.cpp`:

```cpp
#include "Casing.h"
#include "Kismet/GameplayStatics.h"
#include "Sound/SoundCue.h"

ACasing::ACasing()
{
	PrimaryActorTick.bCanEverTick = false;

	CasingMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("CasingMesh"));
	SetRootComponent(CasingMesh);
	CasingMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore);
	CasingMesh->SetSimulatePhysics(true);
	CasingMesh->SetEnableGravity(true);
	CasingMesh->SetNotifyRigidBodyCollision(true);
	ShellEjectionImpulse = 30.f;
}

void ACasing::BeginPlay()
{
	Super::BeginPlay();
	CasingMesh->OnComponentHit.AddDynamic(this, &ACasing::OnHit);
	CasingMesh->AddImpulse(GetActorForwardVector() * ShellEjectionImpulse);

	SetLifeSpan(3.f);
}

void ACasing::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp,
	FVector NormalImpulse, const FHitResult& Hit)
{
	if (ShellSound)
	{
		// 生成命中提示音
		UGameplayStatics::PlaySoundAtLocation(this, ShellSound, GetActorLocation());
	}
	CasingMesh->SetNotifyRigidBodyCollision(false);
	//Destroy();
}
```

`Source/Blaster/Weapon/Casing.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Casing.generated.h"

UCLASS()
class BLASTER_API ACasing : public AActor
{
	GENERATED_BODY()

public:
	ACasing();

protected:
	virtual void BeginPlay() override;

	// 子弹命中逻辑处理函数
	UFUNCTION()
		virtual void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);

private:
	UPROPERTY(VisibleAnywhere)
		UStaticMeshComponent* CasingMesh;	// 子弹外壳网格

	UPROPERTY(EditAnywhere)
		float ShellEjectionImpulse;	// 子弹弹壳弹出冲量

	UPROPERTY(EditAnywhere)
		class USoundCue* ShellSound;	// 子弹弹壳声音
};

```

`Source/Blaster/Weapon/Flag.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Flag.h"

#include "Blaster/Character/BlasterCharacter.h"
#include "Components/SphereComponent.h"
#include "Components/WidgetComponent.h"
#include "Kismet/KismetSystemLibrary.h"

AFlag::AFlag()
{
	FlagMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("FlagMesh"));
	SetRootComponent(FlagMesh);		// 设置FlagMesh为根组件
	GetAreaSphere()->SetupAttachment(FlagMesh);		// 将AreaSphere连接到FlagMesh上

	GetPickupWidget()->SetupAttachment(FlagMesh);	// 将拾取提示组件连接到FlagMesh上

	FlagMesh->SetCollisionResponseToAllChannels(ECR_Ignore);	// 设置FlagMesh忽略所有碰撞
	FlagMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);	// 设置FlagMesh不开启碰撞
}

void AFlag::Dropped()
{
	SetWeaponState(EWeaponState::EWS_Dropped);
	// 分离武器组件
	FDetachmentTransformRules DetachRules(EDetachmentRule::KeepWorld, true);
	FlagMesh->DetachFromComponent(DetachRules);
	// 清空武器所有者
	SetOwner(nullptr);
	BlasterOwnerCharacter = nullptr;
	BlasterOwnerController = nullptr;

	if (bDestroyOnDrop)
	{
		Destroy();
	}
}

void AFlag::ResetFlag()
{
	if (ABlasterCharacter* Player = Cast<ABlasterCharacter>(GetOwner()))
	{
		Player->SetIsHoldingFlag(false);	// 设置玩家不持有旗帜
		Player->SetOverlappingWeapon(nullptr);	// 设置玩家不重叠武器
		Player->UnCrouch();	// 站立
	}

	SetActorTransform(InitialTransform);

	if (!HasAuthority()) return;

	FDetachmentTransformRules DetachRules(EDetachmentRule::KeepWorld, true);
	FlagMesh->DetachFromComponent(DetachRules);

	SetWeaponState(EWeaponState::EWS_Initial);

	GetAreaSphere()->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);	// 设置区域球体开启碰撞
	GetAreaSphere()->SetCollisionResponseToChannel(ECC_Pawn, ECR_Overlap);	// 设置对Pawn的碰撞响应为重叠

	SetOwner(nullptr);
	BlasterOwnerCharacter = nullptr;
	BlasterOwnerController = nullptr;

}

void AFlag::BeginPlay()
{
	Super::BeginPlay();

	InitialTransform = GetActorTransform();
}

void AFlag::OnEquipped()
{
	ShowPickupWidget(false);
	GetAreaSphere()->SetCollisionEnabled(ECollisionEnabled::NoCollision);	// 设置区域球体关闭碰撞
	FlagMesh->SetSimulatePhysics(false);		// 关闭FlagMesh的物理模拟
	FlagMesh->SetEnableGravity(false);		// 关闭FlagMesh的重力
	FlagMesh->SetCollisionEnabled(ECollisionEnabled::QueryOnly);		// 设置FlagMesh开启碰撞	
	FlagMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_WorldDynamic, ECollisionResponse::ECR_Overlap);	// 设置对WorldDynamic的碰撞响应为重叠

	EnableCustomDepth(false);

}

void AFlag::OnDropped()
{
	if (HasAuthority())
	{
		GetAreaSphere()->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
	}
	// 开启武器物理模拟，模拟掉落地面的弹跳
	FlagMesh->SetSimulatePhysics(true);
	FlagMesh->SetEnableGravity(true);
	FlagMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	// 添加碰撞，设置对所有通道的碰撞响应为阻塞
	FlagMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
	// 忽略pawon的碰撞
	FlagMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Ignore);
	FlagMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore);
	FlagMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_BLUE);
	FlagMesh->MarkRenderStateDirty();
	UKismetSystemLibrary::PrintString(this, TEXT("Flag OnDropped"), true, true, FLinearColor::Red, 5.0f);
	EnableCustomDepth(true);

}

```

`Source/Blaster/Weapon/Flag.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Weapon.h"
#include "Flag.generated.h"

/**
 * 旗帜
 */
UCLASS()
class BLASTER_API AFlag : public AWeapon
{
	GENERATED_BODY()

public:
	AFlag();

	virtual void Dropped() override;	// 重写丢弃方法
	void ResetFlag();	// 重置旗帜

protected:
	virtual void BeginPlay() override;	// 重写开始方法
	virtual void OnEquipped() override;	// 重写装备时的方法
	virtual void OnDropped() override;	// 重写丢弃时的方法

private:
	UPROPERTY(EditAnywhere)
	UStaticMeshComponent* FlagMesh;	// 旗帜模型

	FTransform InitialTransform;	// 初始位置，旋转，缩放

public:
	FORCEINLINE FTransform GetInitialTransform() const { return InitialTransform; }	// 获取初始位置
};

```

`Source/Blaster/Weapon/HitScanWeapon.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "HitScanWeapon.h"

#include "Blaster/BlasterComponents/LagCompensationComponent.h"
#include "Engine/SkeletalMeshSocket.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "Kismet/GameplayStatics.h"
#include "particles/ParticleSystemComponent.h"
#include "Sound/SoundCue.h"
#include "Kismet/KismetMathLibrary.h"

void AHitScanWeapon::Fire(const FVector& HitTarget)
{
	Super::Fire(HitTarget);

	APawn* OwnerPawn = Cast<APawn>(GetOwner());
	if (OwnerPawn == nullptr)
	{
		return;
	}

	AController* InstigatorController = OwnerPawn->GetController();

	const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName("MuzzleFlash");
	if (MuzzleFlashSocket)
	{
		FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
		FVector Start = SocketTransform.GetLocation();

		FHitResult FireHit;
		WeaponTraceHit(Start, HitTarget, FireHit);
		
		UWorld* World = GetWorld();
		if (World)
		{

			ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(FireHit.GetActor());
			if (BlasterCharacter && InstigatorController)
			{
				bool bCauseAuthDamage = !bUseServerSideRewind || OwnerPawn->IsLocallyControlled();	// 是否造成伤害，如果不使用服务器倒带，或者是本地控制，那么就造成伤害

				// 如果是服务器，并且客户端不使用服务器倒带，那么就直接造成伤害
				if (HasAuthority() && bCauseAuthDamage)
				{
					float finalDamage = FireHit.BoneName.ToString() == "head" ? HeadShotDamage : Damage;	// 如果是头部射击，造成头部伤害，否则造成普通伤害

					UGameplayStatics::ApplyDamage(
						BlasterCharacter,
						finalDamage,
						InstigatorController,
						this,
						UDamageType::StaticClass()
					);
				}

				if (!HasAuthority() && bUseServerSideRewind)
				{
					// 如果是客户端，并且使用服务器倒带，那么就请求服务器倒带，让服务器在倒带时间点重新计算伤害
					BlasterOwnerCharacter = BlasterOwnerCharacter ? BlasterOwnerCharacter : Cast<ABlasterCharacter>(OwnerPawn);
					BlasterOwnerController = BlasterOwnerController ? BlasterOwnerController : Cast<ABlasterPlayerController>(InstigatorController);

					if (BlasterOwnerCharacter && BlasterOwnerController && BlasterOwnerCharacter->GetLagCompensation() && BlasterOwnerCharacter->IsLocallyControlled())
					{
						BlasterOwnerCharacter->GetLagCompensation()->ServerScoreRequest(
							BlasterCharacter,
							Start,
							HitTarget,
							BlasterOwnerController->GetServerTime() - BlasterOwnerController->SingleTripTime,	// 服务器时间 - 单程时间，因为数据通信也是要时间的，所以要减去单程时间，才是我们希望服务器倒带的真实时间点
							this);
					}
				}
			}

			if (ImpactParticles)
			{
				UGameplayStatics::SpawnEmitterAtLocation(
					World,
					ImpactParticles,
					FireHit.ImpactPoint,
					FireHit.ImpactNormal.Rotation()
				);
			}

			if (HitSound)
			{
				UGameplayStatics::PlaySoundAtLocation(
					this,
					HitSound,
					FireHit.ImpactPoint
				);
			}
		}

		if (MuzzleFlash)
		{
			UGameplayStatics::SpawnEmitterAtLocation(
				World,
				MuzzleFlash,
				SocketTransform
			);
		}
		if (FireSound)
		{
			UGameplayStatics::PlaySoundAtLocation(
				this,
				FireSound,
				GetActorLocation()
			);
		}
	}
}

void AHitScanWeapon::WeaponTraceHit(const FVector& TraceStart, const FVector& HitTarget, FHitResult& OutHit) const
{
	UWorld* World = GetWorld();

	if (World)
	{
		FVector End = TraceStart + (HitTarget - TraceStart) * 1.25f;

		World->LineTraceSingleByChannel(
			OutHit,
			TraceStart,
			End,
			ECollisionChannel::ECC_Visibility
		);

		FVector BeamEnd = End;

		if (OutHit.bBlockingHit)
		{
			BeamEnd = OutHit.ImpactPoint;
		}
		else
		{
			OutHit.ImpactPoint = End;
		}

		// Debug
		// DrawDebugSphere(GetWorld(), BeamEnd, 16.f, 12, FColor::Cyan, true);

		if (BeamParticles)
		{
			UParticleSystemComponent* Beam = UGameplayStatics::SpawnEmitterAtLocation(
				World,
				BeamParticles,
				TraceStart,
				FRotator::ZeroRotator,
				true
			);
			if (Beam)
			{
				Beam->SetVectorParameter(FName("Target"), BeamEnd);
			}
		}
	}
}

```

`Source/Blaster/Weapon/HitScanWeapon.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Weapon.h"
#include "HitScanWeapon.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API AHitScanWeapon : public AWeapon
{
	GENERATED_BODY()

public:
	virtual void Fire(const FVector& HitTarget) override;

protected:

	void WeaponTraceHit(const FVector& TraceStart, const FVector& HitTarget, FHitResult& OutHit) const;

protected:
	UPROPERTY(EditAnywhere)
	class UParticleSystem* ImpactParticles;

	UPROPERTY(EditAnywhere)
		USoundCue* HitSound;

private:

	UPROPERTY(EditAnywhere)
		UParticleSystem* BeamParticles;

	UPROPERTY(EditAnywhere)
		UParticleSystem* MuzzleFlash;

	UPROPERTY(EditAnywhere)
		USoundCue* FireSound;


};

```

`Source/Blaster/Weapon/Projectile.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "Projectile.h"

#include "NiagaraComponent.h"
#include "NiagaraFunctionLibrary.h"
#include "Components/BoxComponent.h"
#include "Kismet/GameplayStatics.h"
#include "Particles/ParticleSystemComponent.h"
#include "Particles/ParticleSystem.h"
#include "Sound/SoundCue.h"
#include "Blaster/Blaster.h"

// Sets default values
AProjectile::AProjectile()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	bReplicates = true;

	CollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT("CollisionBox"));
	SetRootComponent(CollisionBox);
	// 设置碰撞响应为重叠或者击中所有东西
	CollisionBox->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);
	CollisionBox->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	CollisionBox->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);

	CollisionBox->SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);
	CollisionBox->SetCollisionResponseToChannel(ECollisionChannel::ECC_WorldStatic, ECollisionResponse::ECR_Block);
	CollisionBox->SetCollisionResponseToChannel(ECC_SkeletalMesh, ECollisionResponse::ECR_Block);

}

// Called when the game starts or when spawned
void AProjectile::BeginPlay()
{
	Super::BeginPlay();

	if (Tracer)
	{
		TracerComponent = UGameplayStatics::SpawnEmitterAttached(
			Tracer,
			CollisionBox,
			FName(),
			GetActorLocation(),
			GetActorRotation(),
			EAttachLocation::KeepWorldPosition
		);
	}

	if (HasAuthority())
	{
		CollisionBox->OnComponentHit.AddDynamic(this, &AProjectile::OnHit);
	}
}

void AProjectile::StartDestroyTimer()
{
	GetWorldTimerManager().SetTimer(
		DestroyTimer,
		this,
		&AProjectile::DestroyTimerFinished,
		DestroyTime
	);
}

void AProjectile::DestroyTimerFinished()
{
	Destroy();
}

void AProjectile::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp,
                        FVector NormalImpulse, const FHitResult& Hit)
{
	Destroy();
}

void AProjectile::SpawnTrailSystem()
{
	if (TrailSystem)
	{
		TrailSystemComponent = UNiagaraFunctionLibrary::SpawnSystemAttached(
			TrailSystem,
			GetRootComponent(),
			FName(),
			GetActorLocation(),
			GetActorRotation(),
			EAttachLocation::KeepWorldPosition,
			false
		);
	}
}

void AProjectile::ExplodeDamage()
{
	APawn* FiringPawn = GetInstigator();
	if (FiringPawn && HasAuthority())
	{
		AController* FiringController = FiringPawn->GetController();
		if (FiringController)
		{
			UGameplayStatics::ApplyRadialDamageWithFalloff(
				this,	// 世界上下文对象
				Damage,	// 基础伤害
				10.f,	// 最小伤害
				GetActorLocation(),	// 伤害半径的圆心
				DamageInnerRadius,	// 伤害范围的内半径
				DamageOuterRadius,	// 伤害范围外半径
				1.0f,	// 伤害衰减方程（1表示线性衰减）
				UDamageType::StaticClass(),	// 伤害类型
				TArray<AActor*>(),	// 伤害忽略数组（设置为空数组，表示所有人都将会受到伤害，包括自己）
				this,	// 伤害发起者（自己）
				FiringController	// 伤害发起者的控制器
			);
		}
	}
}

// Called every frame
void AProjectile::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

void AProjectile::Destroyed()
{
	Super::Destroyed();

	if (ImpactParticles)
	{
		// 生成命中粒子
		UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ImpactParticles, GetActorTransform());
	}
	if (ImpactSound)
	{
		// 生成命中提示音
		UGameplayStatics::PlaySoundAtLocation(this, ImpactSound, GetActorLocation());
	}
}
```

`Source/Blaster/Weapon/Projectile.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Projectile.generated.h"

// 弹丸/子弹类

UCLASS()
class BLASTER_API AProjectile : public AActor
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	AProjectile();
	virtual void Tick(float DeltaTime) override;

	virtual void Destroyed() override;

	/*
	 * 用于服务端倒带
	 */
	bool bUseServerSideRewind = true;		// 是否使用服务端倒带
	FVector_NetQuantize TraceStart;			// 服务端倒带位置
	FVector_NetQuantize100 InitialVelocity;	// 服务端倒带初始速度，精度为0.01

	UPROPERTY(EditAnywhere)
	float InitialSpeed = 15000.f;		// 初始速度

	// 仅用于设置榴弹和火箭弹的伤害
	UPROPERTY(EditAnywhere)
	float Damage = 20.f;

	// 对榴弹和火箭筒并不重要，因为对于爆炸伤害，没有头部伤害区分
	UPROPERTY(EditAnywhere)
	float HeadShotDamage = 50.f;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
	void StartDestroyTimer();
	void DestroyTimerFinished();
	void SpawnTrailSystem();
	void ExplodeDamage();

	// 子弹命中逻辑处理函数
	UFUNCTION()
	virtual void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);

	// 子弹命中的粒子特效
	UPROPERTY(EditAnywhere)
	UParticleSystem* ImpactParticles;

	// 子弹命中的提示音
	UPROPERTY(EditAnywhere)
	class USoundCue* ImpactSound;

	// 添加一个碰撞箱
	// 设置可编辑
	UPROPERTY(EditAnywhere)
	class UBoxComponent* CollisionBox;


	UPROPERTY(EditAnywhere)
	class UNiagaraSystem* TrailSystem;;

	UPROPERTY()
	class UNiagaraComponent* TrailSystemComponent;

	UPROPERTY(VisibleAnywhere)
	class UProjectileMovementComponent* ProjectileMovementComponent;

	UPROPERTY(VisibleAnywhere)
	UStaticMeshComponent* ProjectileMesh;

	// 爆炸物的伤害范围内半径
	UPROPERTY(EditAnywhere)
	float DamageInnerRadius = 200.f;

	// 爆炸物的伤害范围外半径
	UPROPERTY(EditAnywhere)
	float DamageOuterRadius = 500.f;

private:

	// 示踪器 （显示子弹运动轨迹的粒子特效）
	UPROPERTY(EditAnywhere)
	UParticleSystem* Tracer;

	// 存储tracer的粒子系统组件
	UPROPERTY(EditAnywhere)
	UParticleSystemComponent* TracerComponent;

	FTimerHandle DestroyTimer;

	UPROPERTY(EditAnywhere)
	float DestroyTime = 3.0f;

public:
	// Called every frame
};

```

`Source/Blaster/Weapon/ProjectileBullet.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "ProjectileBullet.h"

#include "Blaster/BlasterComponents/LagCompensationComponent.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "GameFramework/Character.h"
#include "GameFramework/ProjectileMovementComponent.h"
#include "kismet/GameplayStatics.h"

AProjectileBullet::AProjectileBullet()
{
	ProjectileMovementComponent = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT("ProjectileMovementComponent"));
	// 确保子弹保持其旋转与速度对齐
	ProjectileMovementComponent->bRotationFollowsVelocity = true;
	ProjectileMovementComponent->SetIsReplicated(true);
	ProjectileMovementComponent->InitialSpeed = InitialSpeed;
	ProjectileMovementComponent->MaxSpeed = InitialSpeed;
}

#if WITH_EDITOR
void AProjectileBullet::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);

	const FName PropertyName = PropertyChangedEvent.Property != nullptr ? PropertyChangedEvent.Property->GetFName() : NAME_None;	// 获取属性名称

	if (PropertyName == GET_MEMBER_NAME_CHECKED(AProjectileBullet, InitialSpeed))	// 判断属性名称是否为初始速度
	{
		if (ProjectileMovementComponent)
		{
			ProjectileMovementComponent->InitialSpeed = InitialSpeed;	// 设置初始速度
			ProjectileMovementComponent->MaxSpeed = InitialSpeed;	// 设置最大速度
		}
	}
}
#endif

void AProjectileBullet::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp,
                              FVector NormalImpulse, const FHitResult& Hit)
{
	if (const ABlasterCharacter* OwnerCharacter = Cast<ABlasterCharacter>(GetOwner()))
	{
		if (ABlasterPlayerController* OwnerController = Cast<ABlasterPlayerController>(OwnerCharacter->Controller))
		{
			if (OwnerCharacter->HasAuthority() && !bUseServerSideRewind)	// 服务端，不使用服务端倒带
			{
				const float FinalDamage = Hit.BoneName.ToString() == "head" ? HeadShotDamage : Damage;	// 如果是头部射击，造成头部伤害，否则造成普通伤害

				// 服务端，不使用服务端倒带
				UGameplayStatics::ApplyDamage(OtherActor, FinalDamage, OwnerController, this, UDamageType::StaticClass());
				Super::OnHit(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);
				return;
			}
			ABlasterCharacter* HitCharacter = Cast<ABlasterCharacter>(OtherActor);
			if (bUseServerSideRewind && OwnerCharacter->GetLagCompensation() && OwnerCharacter->IsLocallyControlled() && HitCharacter)	// 需要使用服务端倒带，并且拥有服务端倒带组件，并且是本地控制，命中角色不为空
			{
				// 使用服务端倒带
				OwnerCharacter->GetLagCompensation()->ServerScoreRequest_Projectile(
					HitCharacter, 
					TraceStart, 
					InitialVelocity,
					OwnerController->GetServerTime() - OwnerController->SingleTripTime, 
					nullptr);		// 伤害来源这里填空，也可以传入角色当前装备的武器，不过不重要，因为倒带组件会自动获取伤害来源
			}
			
		}
	}

	
}

void AProjectileBullet::BeginPlay()
{
	Super::BeginPlay();

	/*
	 * 下列代码用于预测弹道路径，debug绘制
	 */
	//FPredictProjectilePathParams PredictedPath;		// 预测弹道路径参数
	//PredictedPath.bTraceWithCollision = true;	// 是否使用碰撞检测
	//PredictedPath.bTraceWithChannel = true;	// 是否使用通道检测
	//PredictedPath.DrawDebugType = EDrawDebugTrace::ForDuration;	// 绘制调试类型，持续时间
	//PredictedPath.DrawDebugTime = 5.f;	// 绘制调试时间
	//PredictedPath.LaunchVelocity = GetActorForwardVector() * InitialSpeed;	// 发射速度
	//PredictedPath.MaxSimTime = 5.f;	// 最大模拟时间
	//PredictedPath.ProjectileRadius = 5.f;	// 弹丸半径
	//PredictedPath.StartLocation = GetActorLocation();	// 起始位置
	//PredictedPath.SimFrequency = 30.f;	// 模拟频率
	//PredictedPath.StartLocation = GetActorLocation();	// 起始位置
	//PredictedPath.TraceChannel = ECC_Visibility;	// 跟踪通道
	//PredictedPath.ActorsToIgnore.Add(this);	// 忽略的角色

	//FPredictProjectilePathResult PredictedPathResult;	// 预测弹道路径结果


	//UGameplayStatics::PredictProjectilePath(this, PredictedPath, PredictedPathResult);
}

```

`Source/Blaster/Weapon/ProjectileBullet.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Projectile.h"
#include "ProjectileBullet.generated.h"

/**
 *
 */
UCLASS()
class BLASTER_API AProjectileBullet : public AProjectile
{
	GENERATED_BODY()

public:
	AProjectileBullet();

#if WITH_EDITOR		// 编辑器模式下才会编译
	virtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;	// 属性改变事件，用于编辑器中的属性改变，比如在编辑器中修改了子弹的初始速度，这个函数会被调用
#endif

	

protected:
	virtual void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit) override;

	virtual void BeginPlay() override;

};

```

`Source/Blaster/Weapon/ProjectileGrenade.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ProjectileGrenade.h"
#include "GameFramework/ProjectileMovementComponent.h"
#include "Kismet/GameplayStatics.h"
#include "Sound/SoundCue.h"

AProjectileGrenade::AProjectileGrenade()
{
	ProjectileMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Grenade Mesh"));
	ProjectileMesh->SetupAttachment(RootComponent);
	ProjectileMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);

	ProjectileMovementComponent = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT("ProjectileMovementComponent"));
	// 确保子弹保持其旋转与速度对齐
	ProjectileMovementComponent->bRotationFollowsVelocity = true;
	ProjectileMovementComponent->SetIsReplicated(true);
	ProjectileMovementComponent->bShouldBounce = true;
}

void AProjectileGrenade::Destroyed()
{
	ExplodeDamage();

	Super::Destroyed();
}

void AProjectileGrenade::BeginPlay()
{
	AActor::BeginPlay();


	SpawnTrailSystem();
	StartDestroyTimer();


	ProjectileMovementComponent->OnProjectileBounce.AddDynamic(this, &AProjectileGrenade::OnBounce);
}

void AProjectileGrenade::OnBounce(const FHitResult& ImpactResult, const FVector& ImpactVelocity)
{
	if (BounceSound)
	{
		UGameplayStatics::PlaySoundAtLocation(
			this,
			BounceSound,
			GetActorLocation()
		);
	}
}

```

`Source/Blaster/Weapon/ProjectileGrenade.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Projectile.h"
#include "ProjectileGrenade.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API AProjectileGrenade : public AProjectile
{
	GENERATED_BODY()

public:
	AProjectileGrenade();

	virtual void Destroyed() override;

protected:
	virtual void BeginPlay() override;

	UFUNCTION()
	void OnBounce(const FHitResult& ImpactResult, const FVector& ImpactVelocity);

private:
	UPROPERTY(EditAnywhere)
	USoundCue* BounceSound;

};

```

`Source/Blaster/Weapon/ProjectileRocket.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ProjectileRocket.h"

#include "Kismet/GameplayStatics.h"
#include "Components/BoxComponent.h"
#include "Sound/SoundCue.h"
#include "Components/AudioComponent.h"
#include "NiagaraComponent.h"
#include "RocketMovementComponent.h"

AProjectileRocket::AProjectileRocket()
{
	ProjectileMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Rocket Mesh"));
	ProjectileMesh->SetupAttachment(RootComponent);
	ProjectileMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);

	RocketMovementComponent = CreateDefaultSubobject<URocketMovementComponent>(TEXT("RocketMovementComponent"));
	RocketMovementComponent->bRotationFollowsVelocity = true;
	RocketMovementComponent->SetIsReplicated(true);

}

void AProjectileRocket::BeginPlay()
{
	Super::BeginPlay();

	if (!HasAuthority())
	{
		CollisionBox->OnComponentHit.AddDynamic(this, &AProjectileRocket::OnHit);
	}

	SpawnTrailSystem();

	if (ProjectileLoop && LoopingSoundAttenuation)
	{
		ProjectileLoopComponent = UGameplayStatics::SpawnSoundAttached(
			ProjectileLoop,
			GetRootComponent(),
			FName(),
			GetActorLocation(),
			EAttachLocation::KeepWorldPosition,
			false,
			1.0f,
			1.0f,
			0.f,
			LoopingSoundAttenuation,
			static_cast<USoundConcurrency*>(nullptr),
			false
		);
	}

}

void AProjectileRocket::Destroyed()
{
	
}

void AProjectileRocket::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp,
                              FVector NormalImpulse, const FHitResult& Hit)
{
	if (OtherActor == GetOwner())
	{
		// UE_LOG(LogTemp, Warning, TEXT("Hit self"));
		return;
	}

	ExplodeDamage();

	StartDestroyTimer();

	if (ImpactParticles)
	{
		// 生成命中粒子
		UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ImpactParticles, GetActorTransform());
	}
	if (ImpactSound)
	{
		// 生成命中提示音
		UGameplayStatics::PlaySoundAtLocation(this, ImpactSound, GetActorLocation());
	}
	if (ProjectileMesh)
	{
		ProjectileMesh->SetVisibility(false);
	}
	if (CollisionBox)
	{
		CollisionBox->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	}
	if (TrailSystemComponent && TrailSystemComponent->GetSystemInstance())
	{
		TrailSystemComponent->GetSystemInstance()->Deactivate();
	}
	if (ProjectileLoopComponent && ProjectileLoopComponent->IsPlaying())
	{
		ProjectileLoopComponent->Stop();
	}

	// Super::OnHit(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);
}


```

`Source/Blaster/Weapon/ProjectileRocket.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Projectile.h"
#include "ProjectileRocket.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API AProjectileRocket : public AProjectile
{
	GENERATED_BODY()

public:
	AProjectileRocket();
	virtual void Destroyed() override;

protected:
	virtual void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit) override;
	virtual void BeginPlay() override;

	UPROPERTY(EditAnywhere)
		USoundCue* ProjectileLoop;

	UPROPERTY()
		UAudioComponent* ProjectileLoopComponent;

	UPROPERTY(EditAnywhere)
		USoundAttenuation* LoopingSoundAttenuation;

	UPROPERTY(VisibleAnywhere)
		class URocketMovementComponent* RocketMovementComponent;

};

```

`Source/Blaster/Weapon/ProjectileWeapon.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "ProjectileWeapon.h"

#include "Engine/SkeletalMeshSocket.h"
#include "Projectile.h"

void AProjectileWeapon::Fire(const FVector& HitTarget)
{
	Super::Fire(HitTarget);

	APawn* InstigatorPawn = Cast<APawn>(GetOwner());

	const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName(FName("MuzzleFlash"));

	UWorld* World = GetWorld();

	if (MuzzleFlashSocket && World)
	{
		FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
		// 从枪口插槽到十字准心线轨迹的命中位置
		FVector ToTarget = HitTarget - SocketTransform.GetLocation();
		FRotator TargetRotator = ToTarget.Rotation();

		FActorSpawnParameters SpawnParams;
		SpawnParams.Owner = GetOwner();
		SpawnParams.Instigator = InstigatorPawn;

		AProjectile* SpawnedProjectile = nullptr;

		if (bUseServerSideRewind)
		{
			if (InstigatorPawn->HasAuthority())		// 服务端
			{
				if (InstigatorPawn->IsLocallyControlled())	// 服务端，本地控制，即服务端玩家，生成属性复制的子弹，不倒带
				{
					SpawnedProjectile = World->SpawnActor<AProjectile>(
						ProjectileClass,
						SocketTransform.GetLocation(),
						TargetRotator,
						SpawnParams
					);
					SpawnedProjectile->bUseServerSideRewind = false;
					SpawnedProjectile->Damage = Damage;
					SpawnedProjectile->HeadShotDamage = HeadShotDamage;	// 设置头部伤害
				}
				else	// 服务端，非本地控制，即客户端玩家，生成非属性复制的子弹，倒带
				{
					SpawnedProjectile = World->SpawnActor<AProjectile>(
						ServerSideRewindProjectileClass,
						SocketTransform.GetLocation(),
						TargetRotator,
						SpawnParams
					);
					SpawnedProjectile->bUseServerSideRewind = true;
				}
			}
			else	// 客户端，使用服务端倒带
			{
				if (InstigatorPawn->IsLocallyControlled())	// 客户端，本地控制，即客户端本机玩家，生成非属性复制的子弹，倒带
				{
					SpawnedProjectile = World->SpawnActor<AProjectile>(
						ServerSideRewindProjectileClass,
						SocketTransform.GetLocation(),
						TargetRotator,
						SpawnParams
					);
					SpawnedProjectile->bUseServerSideRewind = true;		// 设置倒带标志
					SpawnedProjectile->TraceStart = SocketTransform.GetLocation();	// 设置倒带位置
					SpawnedProjectile->InitialVelocity = SpawnedProjectile->GetActorForwardVector() * SpawnedProjectile->InitialSpeed;	// 设置倒带初始速度（精度为0.01）
					SpawnedProjectile->Damage = Damage;	// 设置伤害
					SpawnedProjectile->HeadShotDamage = HeadShotDamage;	// 设置头部伤害
				}
				else	// 客户端，非本地控制，即其他客户端机器玩家，生成非属性复制的子弹，不倒带，他会在自己的客户端进行倒带
				{
					SpawnedProjectile = World->SpawnActor<AProjectile>(
						ProjectileClass,
						SocketTransform.GetLocation(),
						TargetRotator,
						SpawnParams
					);
					SpawnedProjectile->bUseServerSideRewind = false;
				}
			}
		}
		else	// 不使用服务端倒带
		{
			if (InstigatorPawn->HasAuthority())	// 服务端，所有的子弹都是属性复制的
			{
				SpawnedProjectile = World->SpawnActor<AProjectile>(
					ProjectileClass,
					SocketTransform.GetLocation(),
					TargetRotator,
					SpawnParams
				);
				SpawnedProjectile->bUseServerSideRewind = false;
				SpawnedProjectile->Damage = Damage;
				SpawnedProjectile->HeadShotDamage = HeadShotDamage;	// 设置头部伤害
			}
		}
		
	}
}
```

`Source/Blaster/Weapon/ProjectileWeapon.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Weapon.h"
#include "ProjectileWeapon.generated.h"

/**
 * 投射武器类，派生自	Weapon
 */
UCLASS()
class BLASTER_API AProjectileWeapon : public AWeapon
{
	GENERATED_BODY()

public:
	virtual void Fire(const FVector& HitTarget) override;

private:
	UPROPERTY(EditAnywhere)
	TSubclassOf<class AProjectile> ProjectileClass;	// 子弹类

	UPROPERTY(EditAnywhere)
	TSubclassOf<AProjectile> ServerSideRewindProjectileClass;	// 服务端倒带子弹类
};

```

`Source/Blaster/Weapon/RocketMovementComponent.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RocketMovementComponent.h"

UProjectileMovementComponent::EHandleBlockingHitResult URocketMovementComponent::HandleBlockingHit(
	const FHitResult& Hit, float TimeTick, const FVector& MoveDelta, float& SubTickTimeRemaining)
{
	Super::HandleBlockingHit(Hit, TimeTick, MoveDelta, SubTickTimeRemaining);

	return EHandleBlockingHitResult::AdvanceNextSubstep;
}

void URocketMovementComponent::HandleImpact(const FHitResult& Hit, float TimeSlice, const FVector& MoveDelta)
{
	// Super::HandleImpact(Hit, TimeSlice, MoveDelta);
	// 火箭筒不应该停下，只有在检测到碰撞的时候才应该停下
}

```

`Source/Blaster/Weapon/RocketMovementComponent.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/ProjectileMovementComponent.h"
#include "RocketMovementComponent.generated.h"

/**
 * 
 */
UCLASS()
class BLASTER_API URocketMovementComponent : public UProjectileMovementComponent
{
	GENERATED_BODY()

protected:
	virtual EHandleBlockingHitResult HandleBlockingHit(const FHitResult& Hit, float TimeTick, const FVector& MoveDelta, float& SubTickTimeRemaining) override;
	virtual void HandleImpact(const FHitResult& Hit, float TimeSlice, const FVector& MoveDelta) override;

};

```

`Source/Blaster/Weapon/Shotgun.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Shotgun.h"

#include "Blaster/BlasterComponents/LagCompensationComponent.h"
#include "Engine/SkeletalMeshSocket.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "Kismet/GameplayStatics.h"
#include "Kismet/KismetMathLibrary.h"
#include "particles/ParticleSystemComponent.h"
#include "Sound/SoundCue.h"

void AShotgun::FireShotgun(const TArray<FVector_NetQuantize>& HitTargets)
{
	AWeapon::Fire(FVector());
	const APawn* OwnerPawn = Cast<APawn>(GetOwner());
	if (OwnerPawn == nullptr) return;

	AController* InstigatorController = OwnerPawn->GetController();

	const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName("MuzzleFlash");
	if (MuzzleFlashSocket)
	{
		const FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
		FVector Start = SocketTransform.GetLocation();

		// 计算霰弹枪子弹命中个数

		// 因为霰弹枪子弹散射的缘故，它有可能同时命中多个角色，我们也需要处理这种情况
		// 这里采用一个map结构处理，键为角色指针，值为子弹命中数量
		// 击中角色和对应数量的map映射
		TMap<ABlasterCharacter*, uint32> HitMap;			// 用于存储击中角色和对应数量的map映射
		TMap<ABlasterCharacter*, uint32> HeadShotHitMap;	// 用于存储击中角色和对应数量的map映射 (头部击中)

		for (FVector_NetQuantize HitTarget : HitTargets)
		{
			FHitResult FireHit;
			WeaponTraceHit(Start, HitTarget, FireHit);

			if (ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(FireHit.GetActor()))
			{
				if (FireHit.BoneName.ToString() == "head")
				{
					if (HeadShotHitMap.Contains(BlasterCharacter))
					{
						HeadShotHitMap[BlasterCharacter]++;
					}
					else
					{
						HeadShotHitMap.Emplace(BlasterCharacter, 1);
					}
				}
				else
				{
					if (HitMap.Contains(BlasterCharacter))
					{
						HitMap[BlasterCharacter]++;
					}
					else
					{
						HitMap.Emplace(BlasterCharacter, 1);
					}
				}
				
			}


			if (ImpactParticles)
			{
				UGameplayStatics::SpawnEmitterAtLocation(
					GetWorld(),
					ImpactParticles,
					FireHit.ImpactPoint,
					FireHit.ImpactNormal.Rotation()
				);
			}

			if (HitSound)
			{
				UGameplayStatics::PlaySoundAtLocation(
					this,
					HitSound,
					FireHit.ImpactPoint,
					0.5f,
					FMath::FRandRange(-.5f, .5f)
				);
			}

		}

		TArray<ABlasterCharacter*> HitCharacters;
		TMap<ABlasterCharacter*, float> HitDamageMap;

		// 计算伤害并应用在角色身上
		for (auto HitPair : HitMap)
		{
			if (HitPair.Key)
			{
				if (HitDamageMap.Contains(HitPair.Key))
				{
					HitDamageMap[HitPair.Key] += Damage * HitPair.Value;
				}
				else
				{
					HitDamageMap.Emplace(HitPair.Key, Damage * HitPair.Value);
				}
				
				HitCharacters.AddUnique(HitPair.Key);
			}
		}

		// 计算爆头伤害并应用在角色身上
		for (auto HitHeadPair : HeadShotHitMap)
		{
			if (HitHeadPair.Key)
			{
				if (HitDamageMap.Contains(HitHeadPair.Key))
				{
					HitDamageMap[HitHeadPair.Key] += HeadShotDamage * HitHeadPair.Value;
				}
				else
				{
					HitDamageMap.Emplace(HitHeadPair.Key, HeadShotDamage * HitHeadPair.Value);
				}

				HitCharacters.AddUnique(HitHeadPair.Key);
			}
		}

		bool bCauseAuthDamage = !bUseServerSideRewind || OwnerPawn->IsLocallyControlled();	// 是否造成伤害，如果不使用服务器倒带，或者是本地控制，那么就造成伤害

		for (auto DamagePair : HitDamageMap)
		{
			if (DamagePair.Key && HasAuthority() && bCauseAuthDamage && InstigatorController)
			{
				UGameplayStatics::ApplyDamage(
					DamagePair.Key,			// 被击中的角色
					DamagePair.Value,		// 伤害
					InstigatorController,
					this,
					UDamageType::StaticClass()
				);
			}
		}

		if (!HasAuthority() && bUseServerSideRewind)
		{
			BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
			BlasterOwnerController = BlasterOwnerController == nullptr ? Cast<ABlasterPlayerController>(InstigatorController) : BlasterOwnerController;

			if (BlasterOwnerCharacter && BlasterOwnerController && BlasterOwnerCharacter->GetLagCompensation() && BlasterOwnerCharacter->IsLocallyControlled())
			{
				BlasterOwnerCharacter->GetLagCompensation()->ServerScoreRequest_Shotgun(
					HitCharacters,
					Start,
					HitTargets,
					BlasterOwnerController->GetServerTime() - BlasterOwnerController->SingleTripTime,
					this
				);
			}
		}
	}
}

void AShotgun::ShotgunTraceHitWithScatter(const FVector& HitTarget, TArray<FVector_NetQuantize>& HitTargets)
{
	// 从武器的枪口位置开始追踪
	const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName("MuzzleFlash");

	if (MuzzleFlashSocket == nullptr) return;

	const FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
	const FVector TraceStart = SocketTransform.GetLocation();

	// 一个从跟踪起始位置指向命中目标的向量（归一化的向量）
	const FVector ToTargetNormalized = (HitTarget - TraceStart).GetSafeNormal();
	// 从轨迹起点到头部目标的某个位置
	const FVector SphereCenter = TraceStart + ToTargetNormalized * DistanceToSphere;
	
	for (uint32 i = 0; i < NumberOfPellets; i++)
	{
		FVector RandVec = UKismetMathLibrary::RandomUnitVector() * FMath::FRandRange(0.f, SphereRadius);
		FVector EndLoc = SphereCenter + RandVec;
		FVector ToEndLoc = EndLoc - TraceStart;

		/*DrawDebugSphere(GetWorld(), SphereCenter, SphereRadius, 12, FColor::Magenta, true);
		DrawDebugSphere(GetWorld(), EndLoc, 4.0f, 12, FColor::Orange, true);
		DrawDebugLine(
			GetWorld(),
			TraceStart, FVector(TraceStart + ToEndLoc * TRACE_LENGTH / ToEndLoc.Size()),
			FColor::Green,
			true);*/

		HitTargets.Add(FVector(TraceStart + ToEndLoc * TRACE_LENGTH / ToEndLoc.Size()));
	}
}

```

`Source/Blaster/Weapon/Shotgun.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "HitScanWeapon.h"
#include "Shotgun.generated.h"

/**
 * 霰弹枪
 */
UCLASS()
class BLASTER_API AShotgun : public AHitScanWeapon
{
	GENERATED_BODY()

public:
	virtual void FireShotgun(const TArray<FVector_NetQuantize>& HitTargets);

	void ShotgunTraceHitWithScatter(const FVector& HitTarget, TArray<FVector_NetQuantize>& HitTargets);		// 霰弹枪射击，返回多个命中目标

private:
	// 霰弹枪每发子弹射出的散弹数
	UPROPERTY(EditAnywhere, Category="Weapon Scatter")
	uint32 NumberOfPellets = 10;


	
};

```

`Source/Blaster/Weapon/Weapon.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "Weapon.h"

#include "Components/SphereComponent.h"
#include "Components/WidgetComponent.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "Blaster/BlasterComponents/CombatComponent.h"
#include "Net/UnrealNetwork.h"
#include "Casing.h"
#include "Engine/SkeletalMeshSocket.h"
#include "Kismet/KismetMathLibrary.h"

// Sets default values
AWeapon::AWeapon()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;
	bReplicates = true;
	AActor::SetReplicateMovement(true);

	WeaponMesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("WeaponMesh"));
	//WeaponMesh->SetupAttachment(RootComponent);
	SetRootComponent(WeaponMesh);

	// 添加碰撞，设置对所有通道的碰撞响应为阻塞
	WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
	// 忽略pawon的碰撞
	WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Ignore);
	WeaponMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);

	// 初始化设置武器的自定义深度模板值
	WeaponMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_BLUE);
	WeaponMesh->MarkRenderStateDirty();
	EnableCustomDepth(true);

	// 在多人联机游戏中，对于向武器这类交互物品的碰撞，我们应该将其在客户端进行忽略，然后再服务端进行碰撞检测
	AreaSphere = CreateDefaultSubobject<USphereComponent>(TEXT("AreaSphere"));
	AreaSphere->SetupAttachment(RootComponent);
	AreaSphere->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
	AreaSphere->SetCollisionEnabled(ECollisionEnabled::NoCollision);

	// AreaSphere->AddRelativeLocation(FVector(0.f, 0.f, 50.f));	// 使碰撞体在武器的上方

	PickupWidget = CreateDefaultSubobject<UWidgetComponent>(TEXT("PickupWidget"));
	PickupWidget->SetupAttachment(RootComponent);
}

void AWeapon::OnRep_Owner()
{
	Super::OnRep_Owner();
	if (Owner == nullptr)
	{
		BlasterOwnerCharacter = nullptr;
		BlasterOwnerController = nullptr;
	}
	else
	{
		BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
		if (BlasterOwnerCharacter && BlasterOwnerCharacter->GetEquippedWeapon() && BlasterOwnerCharacter->GetEquippedWeapon() == this)
		{
			SetHUDAmmo();
		}
	}
}

void AWeapon::EnableCustomDepth(bool bEnable)
{
	if (WeaponMesh)
	{
		WeaponMesh->SetRenderCustomDepth(bEnable);
	}
}

// Called when the game starts or when spawned
void AWeapon::BeginPlay()
{
	Super::BeginPlay();

	// 游戏开始，我们检测这里是否有权限启用碰撞（服务端有权启用碰撞，但是客户端不行）
	// GetLocalRole() == ENetRole::ROLE_Authority

	AreaSphere->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	AreaSphere->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);
	AreaSphere->OnComponentBeginOverlap.AddDynamic(this, &AWeapon::OnSphereOverlap);
	AreaSphere->OnComponentEndOverlap.AddDynamic(this, &AWeapon::OnSphereEndOverlap);

	if (PickupWidget)
	{
		PickupWidget->SetVisibility(false);
	}
}

// Called every frame
void AWeapon::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

void AWeapon::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(AWeapon, WeaponState);
	DOREPLIFETIME_CONDITION(AWeapon, bUseServerSideRewind, COND_OwnerOnly);		// 只在拥有者端复制
	DOREPLIFETIME(AWeapon, bDestroyOnDrop);		// 丢弃时销毁
	DOREPLIFETIME(AWeapon, bDestroyWeapon);		// 销毁武器
}

void AWeapon::OnWeaponStateSet()
{
	// 武器状态改变时
	switch (WeaponState)
	{
	case EWeaponState::EWS_Equipped:
		OnEquipped();
		break;
	case EWeaponState::EWS_Dropped:
		OnDropped();
		break;
	case EWeaponState::EWS_EquippedSecondary:
		OnEquippedSecondary();
		break;
	default: break;
	}
}

void AWeapon::OnEquipped()
{
	ShowPickupWidget(false);
	AreaSphere->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	WeaponMesh->SetSimulatePhysics(false);
	WeaponMesh->SetEnableGravity(false);
	WeaponMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	if (WeaponType == EWeaponType::EWT_SubmachineGun)
	{
		// 为冲锋枪启用网格物理模拟
		WeaponMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
		WeaponMesh->SetEnableGravity(true);
		WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
	}
	EnableCustomDepth(false);

	BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
	if (BlasterOwnerCharacter && bUseServerSideRewind)	// 我们希望只有在武器启用服务端倒带的时候才动态绑定高延迟事件，从而动态开启或关闭服务端倒带，否则如果是所有武器都会绑定高延迟事件，那么会导致所有武器都会在ping值变动的时候开启服务端倒带
	{
		BlasterOwnerController = BlasterOwnerController == nullptr ? Cast<ABlasterPlayerController>(BlasterOwnerCharacter->Controller) : BlasterOwnerController;
		if (BlasterOwnerController && HasAuthority() && !BlasterOwnerController->HighPingDelegate.IsBound())	// 服务端，绑定高延迟事件
		{
			// 绑定高延迟事件
			BlasterOwnerController->HighPingDelegate.AddDynamic(this, &AWeapon::OnPingTooHigh);
		}
	}
}

void AWeapon::OnDropped()
{
	if (HasAuthority())
	{
		AreaSphere->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
	}
	// 开启武器物理模拟，模拟掉落地面的弹跳
	WeaponMesh->SetSimulatePhysics(true);
	WeaponMesh->SetEnableGravity(true);
	WeaponMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	// 添加碰撞，设置对所有通道的碰撞响应为阻塞
	WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
	// 忽略pawon的碰撞
	WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Ignore);
	WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore);
	WeaponMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_BLUE);
	WeaponMesh->MarkRenderStateDirty();
	EnableCustomDepth(true);

	BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
	if (BlasterOwnerCharacter && bUseServerSideRewind)	// 我们希望只有在武器启用服务端倒带的时候才动态绑定高延迟事件，从而动态开启或关闭服务端倒带，否则如果是所有武器都会绑定高延迟事件，那么会导致所有武器都会在ping值变动的时候开启服务端倒带
	{
		BlasterOwnerController = BlasterOwnerController == nullptr ? Cast<ABlasterPlayerController>(BlasterOwnerCharacter->Controller) : BlasterOwnerController;
		if (BlasterOwnerController && HasAuthority() && BlasterOwnerController->HighPingDelegate.IsBound())	// 服务端，解绑高延迟事件
		{
			// 解绑高延迟事件
			BlasterOwnerController->HighPingDelegate.RemoveDynamic(this, &AWeapon::OnPingTooHigh);
		}
	}
}

void AWeapon::OnEquippedSecondary()
{
	ShowPickupWidget(false);
	AreaSphere->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	WeaponMesh->SetSimulatePhysics(false);
	WeaponMesh->SetEnableGravity(false);
	WeaponMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	if (WeaponType == EWeaponType::EWT_SubmachineGun)
	{
		// 为冲锋枪启用网格物理模拟
		WeaponMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
		WeaponMesh->SetEnableGravity(true);
		WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
	}

	WeaponMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_TAN);
	WeaponMesh->MarkRenderStateDirty();

	BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
	if (BlasterOwnerCharacter)
	{
		BlasterOwnerController = BlasterOwnerController == nullptr ? Cast<ABlasterPlayerController>(BlasterOwnerCharacter->Controller) : BlasterOwnerController;
		if (BlasterOwnerController && HasAuthority() && BlasterOwnerController->HighPingDelegate.IsBound())	// 服务端，解绑高延迟事件
		{
			// 解绑高延迟事件
			BlasterOwnerController->HighPingDelegate.RemoveDynamic(this, &AWeapon::OnPingTooHigh);
		}
	}
}

void AWeapon::Fire(const FVector& HitTarget)
{
	if (FireAnimation)
	{
		// 传入开火动画，设置取消循环播放
		WeaponMesh->PlayAnimation(FireAnimation, false);
	}

	if (CasingClass)
	{
		// 射击完后，从弹仓掉落的弹壳
		const USkeletalMeshSocket* AmmoEjectSocket = WeaponMesh->GetSocketByName(FName("AmmoEject"));

		if (AmmoEjectSocket)
		{
			FTransform SocketTransform = AmmoEjectSocket->GetSocketTransform(GetWeaponMesh());

			UWorld* World = GetWorld();
			if (World)
			{
				World->SpawnActor<ACasing>(
					CasingClass,
					SocketTransform.GetLocation(),
					SocketTransform.GetRotation().Rotator()
					);
			}
		}
	}
	// 服务端扣除弹药
	SpendRound();
}

void AWeapon::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (BlasterCharacter)
	{
		if (WeaponType == EWeaponType::EWT_Flag && BlasterCharacter->GetTeam() == Team) return;		//	如果是旗帜，那么只有队伍不同同的角色才能拾取
		if (BlasterCharacter->IsHoldingFlag()) return;	// 如果角色当前正在举旗帜，那么就不显示拾取提示
		BlasterCharacter->SetOverlappingWeapon(this);
	}
}

void AWeapon::OnSphereEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (BlasterCharacter)
	{
		if (WeaponType == EWeaponType::EWT_Flag && BlasterCharacter->GetTeam() == Team) return;		//	如果是旗帜，那么只有队伍不同的角色才能拾取
		if (BlasterCharacter->IsHoldingFlag()) return;	// 如果角色当前正在举旗帜，那么就不显示拾取提示
		BlasterCharacter->SetOverlappingWeapon(nullptr);
	}
}

void AWeapon::OnPingTooHigh(bool bHighPing)
{
	// 如果延迟过高，那么就禁用武器的服务端倒带
	bUseServerSideRewind = !bHighPing;
}

void AWeapon::OnRep_WeaponState()
{
	OnWeaponStateSet();
}

void AWeapon::SpendRound()
{
	// 子弹容量在0-MagCapacity之间
	Ammo = FMath::Clamp(Ammo - 1, 0, MagCapacity);
	SetHUDAmmo();

	if (HasAuthority())
	{
		ClientUpdateAmmo(Ammo);
	}
	else
	{
		++Sequence;		// 未处理的服务器弹药请求数量
	}
}

void AWeapon::AddAmmo(int32 Amount)
{
	Ammo = FMath::Clamp(Ammo + Amount, 0, MagCapacity);
	SetHUDAmmo();

	ClientAddAmmo(Amount);
}

void AWeapon::ClientAddAmmo_Implementation(int32 Amount)
{
	if (HasAuthority()) return;

	Ammo = FMath::Clamp(Ammo + Amount, 0, MagCapacity);

	BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;

	if (BlasterOwnerCharacter && BlasterOwnerCharacter->GetCombat() && IsFull())
	{
		BlasterOwnerCharacter->GetCombat()->JumpToShotgunEnd();	// 
	}
	SetHUDAmmo();
}

void AWeapon::ClientUpdateAmmo_Implementation(int32 ServerAmmo)
{
	if (HasAuthority()) return;

	Ammo = ServerAmmo;
	
	--Sequence;		// 处理掉一个服务器弹药请求

	Ammo -= Sequence;	// 根据未处理的服务器弹药请求数量减少弹药数量，用来纠正因为网络延迟导致的弹药数量错误

	SetHUDAmmo();
}

void AWeapon::SetHUDAmmo()
{
	BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
	if (BlasterOwnerCharacter)
	{
		BlasterOwnerController = BlasterOwnerController == nullptr ? Cast<ABlasterPlayerController>(BlasterOwnerCharacter->Controller) : BlasterOwnerController;
		if (BlasterOwnerController)
		{
			BlasterOwnerController->SetHUDWeaponAmmo(Ammo);
		}
	}
}

void AWeapon::SetWeaponState(EWeaponState State)
{
	WeaponState = State;
	OnWeaponStateSet();
}

bool AWeapon::IsEmpty()
{
	return Ammo <= 0;
}

bool AWeapon::IsFull()
{
	return Ammo == MagCapacity;
}

void AWeapon::ShowPickupWidget(bool bShowWidget)
{
	if (PickupWidget)
	{
		PickupWidget->SetVisibility(bShowWidget);
	}
}

void AWeapon::Dropped()
{
	SetWeaponState(EWeaponState::EWS_Dropped);
	// 分离武器组件
	FDetachmentTransformRules DetachRules(EDetachmentRule::KeepWorld, true);
	WeaponMesh->DetachFromComponent(DetachRules);
	// 清空武器所有者
	SetOwner(nullptr);
	BlasterOwnerCharacter = nullptr;
	BlasterOwnerController = nullptr;

	if (bDestroyOnDrop)
	{
		Destroy();
	}
}

FVector AWeapon::TraceEndWithScatter(const FVector& HitTarget) const
{
	// 从武器的枪口位置开始追踪
	const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName("MuzzleFlash");

	if (MuzzleFlashSocket == nullptr) return FVector::ZeroVector;

	const FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
	const FVector TraceStart = SocketTransform.GetLocation();


	// 一个从跟踪起始位置指向命中目标的向量（归一化的向量）
	const FVector ToTargetNormalized = (HitTarget - TraceStart).GetSafeNormal();
	// 从轨迹起点到头部目标的某个位置
	const FVector SphereCenter = TraceStart + ToTargetNormalized * DistanceToSphere;
	const FVector RandVec = UKismetMathLibrary::RandomUnitVector() * FMath::FRandRange(0.f, SphereRadius);
	const FVector EndLoc = SphereCenter + RandVec;
	const FVector ToEndLoc = EndLoc - TraceStart;

	/*DrawDebugSphere(GetWorld(), SphereCenter, SphereRadius, 12, FColor::Magenta, true);
	DrawDebugSphere(GetWorld(), EndLoc, 4.0f, 12, FColor::Orange, true);
	DrawDebugLine(
		GetWorld(),
		TraceStart, FVector(TraceStart + ToEndLoc * TRACE_LENGTH / ToEndLoc.Size()),
		FColor::Green,
		true);*/

	return FVector(TraceStart + ToEndLoc * TRACE_LENGTH / ToEndLoc.Size());
	
}

```

`Source/Blaster/Weapon/Weapon.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "WeaponTypes.h"
#include "Blaster/BlasterTypes/Team.h"
#include "Weapon.generated.h"

// 武器状态枚举，其枚举常量是无符号八位整数，同时这个也是一个蓝图类型
UENUM(BlueprintType)
enum class EWeaponState : uint8
{
	EWS_Initial UMETA(DisplayName = "Initial State"),		// 武器在世界上放置时的状态
	EWS_Equipped UMETA(DisplayName = "Equipped"),			// 武器被装备时的状态
	EWS_Dropped UMETA(DisplayName = "Dropped"),				// 武器被丢弃时的状态
	EWS_EquippedSecondary UMETA(DisplayName = "Equipped Secondary"),	// 武器被装备为次要武器时的状态
	// 这些就是我们可以用于控制打开物理，打开碰撞，让武器反弹的地方

	EWS_MAX UMETA(DisplayName = "DefaultMax")				// 默认最大常量
};

UENUM(BlueprintType)
enum class EFiringType : uint8
{
	EFT_HitScan UMETA(DisplayName = "Hit Scan Weapon"),		// 扫描
	EFT_Projectile UMETA(DisplayName = "Projectile Weapon"),			// 投射
	EFT_Shotgun UMETA(DisplayName = "Shotgun"),			// 霰弹枪

	EFT_MAX UMETA(DisplayName = "DefaultMax")				// 默认最大常量
};

UCLASS()
class BLASTER_API AWeapon : public AActor
{
	GENERATED_BODY()

public:
	/*
	 * 十字准心纹理
	 * 这里有几个变量，因为我想要控制左右上下以及中心的纹理
	 */
	UPROPERTY(EditAnywhere, Category = Crosshairs)
	class UTexture2D* CrosshairsCenter;

	UPROPERTY(EditAnywhere, Category = Crosshairs)
	class UTexture2D* CrosshairsLeft;

	UPROPERTY(EditAnywhere, Category = Crosshairs)
	class UTexture2D* CrosshairsRight;

	UPROPERTY(EditAnywhere, Category = Crosshairs)
	class UTexture2D* CrosshairsTop;

	UPROPERTY(EditAnywhere, Category = Crosshairs)
	class UTexture2D* CrosshairsBottom;

	// 瞄准时的武器缩放 FOV
	UPROPERTY(EditAnywhere)
	float ZoomedFOV = 30.f;

	UPROPERTY(EditAnywhere)
	float ZoomInterpSpeed = 20.f;

	/*
	 * 自动开火
	 */

	UPROPERTY(EditAnywhere, Category = Combat)
	float FireDelay = 0.15f;

	// 标志是否是自动武器（自动开火的武器）
	UPROPERTY(EditAnywhere, Category = Combat)
	bool bAutomatic = true;

	UPROPERTY(EditAnywhere, Category = Weapon)
	class USoundCue* EquipSound;

	/*
	 * 启用或者禁用自定义深度
	 */
	void EnableCustomDepth(bool bEnable);

	// 武器是否被销毁当被丢弃时
	UPROPERTY(Replicated)
	bool bDestroyOnDrop = false;

	// 武器是否会被销毁
	UPROPERTY(Replicated)
	bool bDestroyWeapon = false;

	UPROPERTY(EditAnywhere)
	EFiringType FiringType;	// 射击类型

	/*
	 * 跟踪和散射
	 */
	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
	float DistanceToSphere = 800.f;		// 距离球体

	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
	float SphereRadius = 75.0f;			// 球体半径


	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
	bool bUseScatter = false;	// 是否使用散射

public:
	// Sets default values for this actor's properties
	AWeapon();
	virtual void OnRep_Owner() override;
	virtual void Tick(float DeltaTime) override;
	void ShowPickupWidget(bool bShowWidget);
	void SetHUDAmmo();
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	virtual void Fire(const FVector& HitTarget);
	// 丢弃武器 / 死亡掉落武器
	virtual void Dropped();
	void AddAmmo(int32 Amount);

	FVector TraceEndWithScatter(const FVector& HitTarget) const;	// 跟踪结束位置


protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

	virtual void OnWeaponStateSet();

	virtual void OnEquipped();

	virtual void OnDropped();

	virtual void OnEquippedSecondary();

	// 武器的所有者
	UPROPERTY()
	class ABlasterCharacter* BlasterOwnerCharacter;

	// 武器的控制器
	UPROPERTY()
	class ABlasterPlayerController* BlasterOwnerController;

	// 在和武器的碰撞检测球体重叠的时候调用
	UFUNCTION()
	virtual void OnSphereOverlap(
			UPrimitiveComponent* OverlappedComponent,	// 原始组件
			AActor* OtherActor,
			UPrimitiveComponent* OtherComp,
			int32 OtherBodyIndex,
			bool bFromSweep,
			const FHitResult& SweepResult
		);

	// 在和武器的碰撞检测球体结束重叠的时候调用
	UFUNCTION()
	void OnSphereEndOverlap(
			UPrimitiveComponent* OverlappedComponent,	// 原始组件
			AActor* OtherActor,
			UPrimitiveComponent* OtherComp,
			int32 OtherBodyIndex
		);

	UPROPERTY(EditAnywhere)
	float Damage = 20.f;	// 武器伤害

	UPROPERTY(EditAnywhere)
	float HeadShotDamage = 50.f;	// 爆头伤害

	UPROPERTY(Replicated, EditAnywhere)
	bool bUseServerSideRewind = true;		// 是否使用服务器端倒带

	UFUNCTION()
	void OnPingTooHigh(bool bHighPing);		// 高延迟委托绑定函数

private:
	// 武器骨架网格
	UPROPERTY(VisibleAnywhere, Category = "Weapon Properties")
	USkeletalMeshComponent* WeaponMesh;

	// 武器碰撞体
	UPROPERTY(VisibleAnywhere, Category = "Weapon Properties")
	class USphereComponent* AreaSphere;

	// 武器状态
	UPROPERTY(ReplicatedUsing = OnRep_WeaponState, VisibleAnywhere, Category = "Weapon Properties")
	EWeaponState WeaponState;

	// 武器拾取的Widget组件
	UPROPERTY(VisibleAnywhere, Category = "Weapon Properties")
	class UWidgetComponent* PickupWidget;

	// 武器状态同步
	UFUNCTION()
	void OnRep_WeaponState();

	// 武器开火动画
	UPROPERTY(EditAnywhere, Category = "Weapon Properties")
	class UAnimationAsset* FireAnimation;

	// 武器准心
	UPROPERTY(EditAnywhere)
	TSubclassOf<class ACasing> CasingClass;

	// 武器子弹数量
	UPROPERTY(EditAnywhere)
	int32 Ammo;

	// 扣除弹药，检测武器是否有一个有效的所有者
	void SpendRound();

	UFUNCTION(Client, Reliable)
	void ClientUpdateAmmo(int32 ServerAmmo);

	UFUNCTION(Client, Reliable)
	void ClientAddAmmo(int32 Amount);

	// 未处理的服务器弹药请求数量
	// 在SpendRound()中增加，在ClientUpdateAmmo()中减少
	int32 Sequence = 0;

	// 武器的弹药容量
	UPROPERTY(EditAnywhere)
	int32 MagCapacity;

	// 武器类型
	UPROPERTY(EditAnywhere)
	EWeaponType WeaponType;

	UPROPERTY(EditAnywhere)
	ETeam Team;

public:
	// Called every frame

	void SetWeaponState(EWeaponState State);

	FORCEINLINE USphereComponent* GetAreaSphere() const { return AreaSphere; }

	FORCEINLINE USkeletalMeshComponent* GetWeaponMesh() const { return WeaponMesh; }

	FORCEINLINE UWidgetComponent* GetPickupWidget() const { return PickupWidget; }

	FORCEINLINE float GetZoomedFOV() const { return ZoomedFOV; }
	FORCEINLINE float GetZoomedInterpSpeed() const { return ZoomInterpSpeed; }

	bool IsEmpty();
	bool IsFull();

	FORCEINLINE EWeaponType GetWeaponType() const { return WeaponType; }

	FORCEINLINE int32 GetAmmo() const { return Ammo; }
	FORCEINLINE int32 GetMagCapacity() const { return MagCapacity; }

	FORCEINLINE float GetDamage() const { return Damage; }
	FORCEINLINE float GetHeadShotDamage() const { return HeadShotDamage; }

	FORCEINLINE ETeam GetTeam() const { return Team; }
};

```

`Source/Blaster/Weapon/WeaponTypes.h`:

```h
#pragma once


// 定义走线长度 (武器子弹的最长发射距离）
#define TRACE_LENGTH 80000.f

#define CUSTOM_DEPTH_PURPLE 250
#define CUSTOM_DEPTH_BLUE 251
#define CUSTOM_DEPTH_TAN 252

// 武器类型枚举类

UENUM(BlueprintType)
enum class EWeaponType : uint8
{
	EWT_AssaultRifle UMETA(DisplayName = "Assault Rifle"),		// 突击步枪
	EWT_RocketLauncher UMETA(DisplayName = "Rocket Launcher"),	// 火箭筒发射器
	EWT_Pistol UMETA(DisplayName = "Pistol"),					// 手枪
	EWT_SubmachineGun UMETA(DisplayName = "Submachine Gun"),	// 冲锋枪
	EWT_Shotgun UMETA(DisplayName = "Shotgun"),					// 霰弹枪
	EWT_SniperRifle UMETA(DisplayName = "Sniper Rifle"),		// 狙击步枪
	EWT_GrenadeLauncher UMETA(DisplayName = "Grenade Launcher"),		// 榴弹发射器

	EWT_Flag UMETA(DisplayName = "Flag"),	// 旗帜

	EWT_MAX UMETA(DisplayName = "DefaultMAX")
};

```

`Source/BlasterEditor.Target.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class BlasterEditorTarget : TargetRules
{
	public BlasterEditorTarget( TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V2;
		ExtraModuleNames.AddRange( new string[] { "Blaster" } );
	}
}

```

`note/Actor与Component的插件与销毁.md`:

```md
## Actor的创建与销毁

### 创建

UClass*
TSubclassOf<T>
SpawnActor()

```c++
UPROPERTY(EditAnywhere, Category = "init")
	UClass* bullet0; // 取类

UPROPERTY(EditAnywhere, Category = "init")
	TSubclassOf<Amissile> bullet; //取Amissile类及其派生类

UPROPERTY(EditAnywhere, Category = "init")
	Amissile* bullet2; // 取类的实例
```

### 销毁

直接销毁：Destroy()

```c++
MissileIns->Destroy();
```

### 设置生命周期

构造函数设置InitialLifeSpan

```c++
InitialLifeSpan = 8.0f;
```

BeginPlay里使用SetLifeSpan()设置声明周期

## Component 的创建与销毁

### 创建

构造函数创建：CreateDefaultSubobject<T>
```c++
UPROPERTY(VisibleAnywhere)
	UStaticMeshComponent* paddle1;

paddle1 = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("paddle1"));
```

Runtime创建：NewObject<T>、RegisterComponent()
```c++
Mesh = NewObject<UStaticMeshComponent>(this,TEXT("MyMesh"));
Mesh->SetupAttachment(root);
Mesh->RegisterComponent(); // 注册渲染/物理状态
// 可配合 LoadObject() 
```



### 加载资源

#### FObjectFinder构造函数加载资源

ConstructorHelpers::FObjectFinder<T>

```c++

static ConstructorHelpers::FObjectFinder<UStaticMesh> paddleMesh(TEXT("StaticMesh'/Game/Demo_Drone/SM/paddle.paddle'"));
if (paddleMesh.Succeeded())
{
	paddle1->SetStaticMesh(paddleMesh.Object);
}
```

#### LoadObject加载资源

```c++
UStaticMesh* bodyMesh = LoadObject<UStaticMesh>(this,TEXT("StaticMesh'/Game/Demo_Drone/SM/drone.drone'"));
if (bodyMesh)
{
	body->SetStaticMesh(bodyMesh);
}
```

### 设置组件层级关系

设置根组件RootComponent或者SetRootComponent()
SetupAttachment
AttachToComponent

```c++
RootComponent = outCollison;
SetRootComponent(outCollison);

paddle1->SetupAttachment(body, TEXT("paddle1"));
paddle2->SetupAttachment(body, TEXT("paddle2"));
paddle3->AttachToComponent(body, FAttachmentTransformRules::KeepRelativeTransform, TEXT("paddle3"));
paddle4->AttachToComponent(body, FAttachmentTransformRules::KeepRelativeTransform, TEXT("paddle4"));

childSceneComponent->AttachToComponent(root, FAttachmentTransformRules::SnapToTargetIncludingScale);
```

### 销毁组件

DestoryComponent()
UnregisterComponent()使用RegisterComponent创建，需要先注销再销毁

```c++
Mesh->UnregisterComponent();
Mesh->DestroyComponent();
```

## 各类组件创建与初始化

### UStaticMenshComponent

```c++
paddle1 = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("paddle1"));
auto paddleMesh = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("StaticMesh'/Game/Demo_Drone/SM/paddle.paddle'"));
if (paddleMesh.Object != nullptr)
{
	paddle1->SetStaticMesh(paddleMesh.Object);
}
```

### UBoxComponent

```c++
outCollison = CreateDefaultSubobject<UBoxComponent>(TEXT("outCollison"));
outCollison->SetBoxExtent(FVector(60, 60, 15));
outCollison->SetSimulatePhysics(true);
outCollison->SetCollisionProfileName(TEXT("WorldDynamic"));
outCollison->SetCollisionEnabled(ECollisionEnabled::NoCollision);
```

### USphereComponent

```c++
sphereComp = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComp"));
sphereComp->InitSphereRadius(5.0f);
sphereComp->SetCollisionProfileName(TEXT("WorldDynamic"));
sphereComp->SetGenerateOverlapEvents(true);
sphereComp->OnComponentBeginOverlap.AddDynamic(this, &Amissile::Overlaphandler);
// overlap 函数绑定
void Amissile::Overlaphandler(UPrimitiveComponent* OverlappedComponent,
				AActor* OtherActor, 
				UPrimitiveComponent* OtherComp,
				int32 OtherBodyIndex,
				bool bFromSweep,
				const FHitResult& SweepResult){}
```

### USkeletalMeshComponent

```c++
SkeletalMeshComp = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("SkeletalMeshComp"));
SkeletalMeshComp->SetGenerateOverlapEvents(true);
SkeletalMeshComp->SetSimulatePhysics(true);
```

### USpringArmComponent和UCameraComponent

```c++
springArmComp = CreateDefaultSubobject<USpringArmComponent>(TEXT("SpringArm"));
springArmComp->SetupAttachment(RootComponent);
cameraComp = CreateDefaultSubobject<UCameraComponent>(TEXT("Camera"));
cameraComp->SetupAttachment(springArmComp);
```

### UPhysicsThrusterComponent

```c++
upThrusterComp = CreateDefaultSubobject<UPhysicsThrusterComponent>(TEXT("upThrusterComp"));
upThrusterComp->SetupAttachment(RootComponent);
upThrusterComp->SetWorldRotation(UKismetMathLibrary::MakeRotFromX(FVector(-this->GetActorUpVector())));
upThrusterComp->ThrustStrength = 980.0f;
upThrusterComp->SetAutoActivate(true);
```

### UTexRenderComponent

```c++
CountdownText = CreateDefaultSubobject<UTextRenderComponent>(TEXT("CountdownNumber"));
CountdownText->SetHorizontalAlignment(EHTA_Center);
CountdownText->SetWorldSize(150.0f);
CountdownText->AttachTo(RootComponent);
CountdownTime = 3;
CountdownText->SetText(FString::FromInt(FMath::Max(CountdownTime, 0)));
```

### UProjectileMovementComponent

```c++
projectileMovementComp = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT("projectileMovement"));
projectileMovementComp->InitialSpeed = 500.0f;
```


```

`note/Multiplayer Online Subsystem 多人在线子系统.md`:

```md
# Multiplayer Online Subsystem


```

`note/ProjectleSSR.md`:

```md
# Projectile Server Side Rewind

```c++
#pragma once

#include "CoreMinimal.h"
#include "Weapon.h"
#include "ProjectileWeapon.generated.h"

/**
 * 投射武器类，派生自	Weapon
 */
UCLASS()
class BLASTER_API AProjectileWeapon : public AWeapon
{
	GENERATED_BODY()

public:
	virtual void Fire(const FVector& HitTarget) override;

private:
	UPROPERTY(EditAnywhere)
	TSubclassOf<class AProjectile> ProjectileClass;	// 子弹类

	UPROPERTY(EditAnywhere)
	TSubclassOf<AProjectile> ServerSideRewindProjectileClass;	// 服务端倒带子弹类
};

```

如上所示，我们的投射类武器（冲锋枪为例），它有两个子弹类，一个是属性复制的，一个不复制的，我们需要决定何时生成（或者说何时使用某个具体的类）

![image-20240329175041524](.\image-20240329175041524.png)

如图，我们有一个服务器和客户端，并且在服务器上的弹丸，要么是本地控制的，要么是非本地控制的。如果我们在服务器上，并且在本地控制托管玩家的位置，我们就会在服务端控制我们的角色，并且其他所有在服务器上的角色都会由其他的客户端控制。

现在如果我们在客户端上，我们要么是本地控制的，要么不是本地控制的。如果是本地控制的，我们就是在控制我们自己的角色，而所有其他的角色都是代理模拟的。

现在是否生成属性复制的弹丸取决于几件事。我们知道我们的武器本身有一个使用过的服务器端倒带布尔值 `bool bUseServerSideRewind = false;// 是否使用服务端倒带`，所以，我们的武器具有服务器端倒带控制变量，但是同时我们的投射类弹丸也是如此，这是因为弹丸可能想要使用服务器端倒带。

如果我们是在服务器上，我们的的武器设置为使用服务器端倒带，并且，我们是本地控制的，我们任然只是生成一个复制的弹丸，而没有在弹丸上启用服务端倒带。这是因为服务器上的本地控制角色不需要使用功能服务端倒带，服务器本地的所有计算都是权威可信的，它发射一枚射弹，并且根据弹头事件，他会立即在服务器上照成伤害，并将结果复制到客户端。

现在，对于在服务器上使用服务端倒带从武器上发射射弹的角色，如果我们不是本地控制的，那么发射炮弹的玩家就是其他客户端的角色。对于这种情况，我们只会生成一个不可复制的射弹，并且不启用服务端倒带。这是因为该客户端现在将生成他们自己本地的非复制射弹，这些射弹将会使用服务端倒带，然后根据倒带结果，客户端上的弹丸将会发送服务器的得分请求。

对于启用了Server Side Rewind(SSR)武器的客户端本地控制角色，如果该角色是本地控制的，他将会生成一个不可复制的射弹用于在该弹丸击中其计算机上的本地某人时，用来做服务端倒带计算。他将向服务端发送得分请求，以便服务端可以对其进行验证。

但是，向非本地控制的客户端角色发射的武器是为了响应多播RPG中的“发射武器”，这意味着武器是在其他人的机器上发射的。因此，即使武器在非本地控制的客户端上使用服务器端倒带，我们也会产生一个不使用服务器端倒带的炮弹。

现在，如果武器本身被设置为不使用服务器端倒带，那么在服务器上，无论我们是否受到本地控制，我们仍然会产生一个复制的投射物。未启用服务器端倒带。因此，即使客户端发射武器，炮弹仍将在服务器上产生并复制到客户端。

如果我们的武器没有设置为使用SSR，并且武器在客户端上开火，那么客户端上就不会产生炮弹，因为我们知道服务器最终会产生一个复制的炮弹，我们会在我们的机器上看到它。现在我们知道了什么时候产生复制的和非复制的射弹。



# WithValidation

**UFunction** 是虚幻引擎4（UE4）反射系统可识别的C++函数。 `UObject `或蓝图函数库可将成员函数声明为UFunction，方法是将 `UFUNCTION `宏放在头文件中函数声明上方的行中。宏将支持 **函数说明符** 更改UE4解译和使用函数的方式。

```
UFUNCTION([specifier1=setting1, specifier2, ...], [meta(key1="value1", key2, ...)])
ReturnType FunctionName([Parameter1, Parameter2, ..., ParameterN1=DefaultValueN1, ParameterN2=DefaultValueN2]) [const];
```

可利用函数说明符将UFunction对 [蓝图可视化脚本 ](https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/Blueprints)图表公开，以便开发者从蓝图资源调用或扩展UFunction，而无需更改C++代码。在类的默认属性中，UFunction可绑定到 [委托 ](https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Delegates)，从而能够执行一些操作（例如将操作与用户输入相关联）。它们还可以充当网络回调，这意味着当某个变量受网络更新影响时，用户可以将其用于接收通知并运行自定义代码。用户甚至可创建自己的控制台命令（通常也称 *debug* 、 *configuration* 或 *cheat code* 命令），并能在开发版本中从游戏控制台调用这些命令，或将拥有自定义功能的按钮添加到关卡编辑器中的游戏对象。

WithValidation 用于声明名称与主函数相同的附加函数，但是末尾需要添加`_Validate`。此函数使用相同的参数，但是会返回`bool`，以指示是否应继续调用主函数。

它可能作为函数调用或者类方法的一个选项出现，用来确保数据的有效性和完整性。

例如，在处理资产导入、保存或加载时，带有“WithValidation”后缀的方法可能会执行额外的数据验证步骤，以确保数据结构符合预期规则，不包含无效引用或其他可能导致运行时错误的情况。这种验证机制对于避免潜在的游戏崩溃、资源丢失等问题至关重要。

在UE5源代码或API中，开发者可能会看到类似这样的用法：

- `SavePackageWithValidation()`: 这种函数调用会在保存关卡或 actor 包时进行严格的数据验证，确保所有关联的数据都是合法且可序列化的。
- 在蓝图编译或更新过程中，也可能存在类似的验证环节，确保蓝图节点逻辑正确无误。

```c++
	// 创建server RPC
	// 这个函数被设计为从客户端调用，然后再服务端进行执行
	UFUNCTION(Server, Reliable, WithValidation)
	void ServerFire(const FVector_NetQuantize& TracerHitTarget, float FireDelay);
```

如上，添加了一WithValidation标识，就需要给该函数添加一个验证函数，返回bool，可以在cpp中或者直接在h中实现

```c++
void UCombatComponent::ServerFire_Implementation(const FVector_NetQuantize& TracerHitTarget, float FireDelay)
{
	MuticastFire(TracerHitTarget);
}

// 验证是否可以开火，这个函数是用来验证客户端发送给服务端的开火请求是否合法的
bool UCombatComponent::ServerFire_Validate(const FVector_NetQuantize& TracerHitTarget, float FireDelay)
{
	if (EquippedWeapon)
	{
		// 如果当前客户端的武器和服务端的武器的开火延迟是一样的，那么就可以开火（延迟精度为0.001f）
		if (FMath::IsNearlyEqual(EquippedWeapon->FireDelay, FireDelay, 0.001f))
		{
			return true;
		}
	}

	return true;
}
```


```

`note/UE/UE4 C++基础 - Hello World.md`:

```md
# UE4 C++基础 - Hello World

## 入门

学习UE4最好的方式就是编写代码实际调试。方便快捷的调试可以加快我们学习的进度。尽管这个过程很简单，但是对于初学者来说，它仍然可能成为一大障碍，因为要达到这个目的，我们必须能够正确部署UE4 C++环境，且成功编译运行，然后输出结果。掌握了这些操作细节以后，其他事情就比较容易了。

## 环境搭建

为了方便起见，我们建议大家使用Windows开发环境，当然Mac和Ubuntu环境也是可行的。引擎下载和配置可以参考下面这篇文章。有疑问的同学也可以在评论区留言，我们会视情况解决你遇到的问题。尽管各自的引擎和VS版本不同，但是大体步骤是相同的。

1. 安装 [Visual Studio](https://link.zhihu.com/?target=https%3A//visualstudio.microsoft.com/zh-hans/)
2. 安装 [Git](https://link.zhihu.com/?target=https%3A//git-scm.com/)
3. 注册Github，并加入 EPIC 开发组
4. Git拉取源码
5. Setup.bat 执行环境初始化
6. 生成新的C++工程
7. Viusal Studio打开工程

[Louis丶：UE4引擎 源码的获取、安装，以及VS配置53 赞同 · 4 评论文章![img](https://pic1.zhimg.com/v2-9046d9a6924ac98495af9cf40829dab0_180x120.jpg)](https://zhuanlan.zhihu.com/p/59536013)

## UE4，Hello World！

执行完上述步骤，如果一切顺利的话，你应该可以通过VS成功启动编辑器，并看到如下界面。Good Luck！

![img](https://pic1.zhimg.com/80/v2-e68d0b7ea6da2ff70820b739a5edd974_720w.webp)

图 1 成功配置环境并运行编辑器的样例

不过我们的起点不是这里，因为我们还有很多基础知识没有掌握。需要重新关闭编辑器，回到我们的Hello World，操作如下所示：

![img](https://pic4.zhimg.com/80/v2-0e60aec23d41f7a0f91ae7f5cc3a017b_720w.webp)

图 2 设置BlackProgram为启动项目

右键 解决方案 -》 Programs -》 BlankProgram 设置为启动项目，打开Private\BlankProgram.cpp，在

```cpp
return 0;
```

添加断点，并点击运行。

![img](https://pic2.zhimg.com/80/v2-cb187813856227a454e935db48fea449_720w.webp)

图 3 编译并启动 BlankProgram

![img](https://pic4.zhimg.com/80/v2-f827038fab7ae7a0abb99d16f569f56b_720w.webp)

图 4 Hello World

到这里，我们就可以开始接下来的步骤了，开始学习之前，我们先了解一下这段代码。

```cpp
// 包含了 CoreMinimal.h, 是对引擎常用模块的头文件引用
#include "BlankProgram.h" 

// BlankProgram是UE4最简单的独立程序，包含了运行独立应用程序最少的头文件
#include "RequiredProgramMainCPPInclude.h" 

// 定义LOG策略，用于UE_LOG宏
DEFINE_LOG_CATEGORY_STATIC(LogBlankProgram, Log, All);
// 定义Application，包含运行独立程序的最基本代码，暂时忽略
IMPLEMENT_APPLICATION(BlankProgram, "BlankProgram");

// Main入口点函数
INT32_MAIN_INT32_ARGC_TCHAR_ARGV()
{
        // 初始化引擎
	GEngineLoop.PreInit(ArgC, ArgV);
        // 输出Hello world, UE_LOG稍后解释
	UE_LOG(LogBlankProgram, Display, TEXT("Hello World"));
        // 返回0，表示程序运行成功
	return 0;
}
```

## UE_LOG

UE_LOG 是我们常用的输出内容至控制台的方式，原型如下：

```cpp
#define UE_LOG(CategoryName, Verbosity, Format, ...)
```

它包含以下几个参数，

- CategoryName 用于区分不同的Logger

- Verbosity 表示logging等级

- - **Fatal** 致命错误，无论该CategoryName禁用无否,都会输出至控制台和日志
  - **Error** 错误，输出至控制台和日志
  - **Warning** 警告，输出至控制台和日志
  - **Display** 显示日志，输出至控制台和日志
  - **Log** 调试信息，只输出至日志
  - **Verbose** 较繁琐的信息，通常是为了输出某些详细日志
  - **VeryVerbose** 更繁琐的信息

更多详细解释可以查看源码

```cpp
UnrealEngine\Engine\Source\Runtime\Core\Public\Logging\LogVerbosity.h
```

**Format**则与 [printf](https://link.zhihu.com/?target=https%3A//www.cplusplus.com/reference/cstdio/printf/) 函数保持一致。
```

`note/UE/UE4 C++基础 - 基础数据结构.md`:

```md
# UE4 C++基础 - 基础数据结构

## 简介

UE4是跨平台的引擎，为了尽可能减少跨平台数据大小不一致导致的问题，所以自定义了基本数据类型。使用 **typedef** 将其定义为我们常用的数据类型，并通过编译时检测[[1\]](https://zhuanlan.zhihu.com/p/137638251#ref_1)保证数据大小在各平台的一致性。还提供了常用的聚合数据类型，如数组，集合，哈希表用于满足业务侧开发需求。

## 1. 基本数据类型

```cpp
// 无符号基本数据类型
uint8 // 8位无符号整数
uint16 // 16位无符号整数
uint32 // 32位无符号整数
uint64 // 64位无符号整数

//有符号基本数据类型
int8 // 8位有符号整数
int16 // 16位有符号整数
int32 // 32位有符号整数
int64 // 64位有符号整数

// 字符类型
ANSICHAR // ANSI 字符. 通常是带符号类型
WIDECHAR // 宽字符. 通常是带符号类型
TCHAR // ANSICHAR 或者 WIDECHAR,根据平台是否支持宽字符或者licensee授权决定
UTF8CHAR // UTF-8 字符
UCS2CHAR // UCS2 字符
UTF16CHAR // UTF-16 字符
UTF32CHAR // UTF-32 字符

// 指针整数类型
UPTRINT // An unsigned integer the same size as a pointer
PTRINT // A signed integer the same size as a pointer
SIZE_T // An unsigned integer the same size as a pointer, the same as UPTRINT
SSIZE_T // An integer the same size as a pointer, the same as PTRINT

// 常量类型
TYPE_OF_NULL // NULL 常量
TYPE_OF_NULLPTR // C++ nullptr
```

## 2. 字符串类型

[篮子悠悠：UE4 C++基础教程 - 字符串和本地化48 赞同 · 3 评论文章![img](https://pic4.zhimg.com/v2-15e856c31120ed114ade5d26431b7657_180x120.jpg)](https://zhuanlan.zhihu.com/p/163587790)

## 3. 聚合数据类型

单靠基本的数据类型往往无法满足游戏业务侧开发的需求。假设我们要开发一个任务系统，任务是由一系列的子任务组成，每个任务都有各自的名称和子任务,我们如何储存这些任务信息呢？

为了解决类似的问题，我们需要一种结构化的数据结构，因此引入了聚合数据类型，UE4中称之为***容器**(Container)*，来组织我们的数据。就如同我们的衣柜，用来有序的储存我们各种各样的衣物。

## 3.1 TArray（动态数组）[[2\]](https://zhuanlan.zhihu.com/p/137638251#ref_2)

TArray是几个容器类中使用最频繁的一个，既可以作为列表，也可以作为集合，还可以作为栈来使用。其中储存的元素必须是同一个类型。

## 3.1.1 TArray创建

TArray是一个模板类，接受2个参数，分别是元素类型和分配器。

```cpp
template<typename InElementType, typename InAllocator>
class TArray
```

其中 InElementType 指明存储元素的类型， InAllocator 标识其所采用的内存分配器（TSizedHeapAllocator）。默认元素使用的内存是分配在堆上，而不是栈上。但是使用时不用关心这一点，将TArray当作普通的数值类型（如int32, float）处理即可。TArray销毁时其中的元素也会被销毁。

**初始化**

```cpp
// 普通创建
TArray<int32> IntArray;
// 
```



## TSet （集合）[[3\]](https://zhuanlan.zhihu.com/p/137638251#ref_3)

TSet是一种快速容器类，（通常）用于在排序不重要的情况下存储唯一元素。

`TSet` 类似于 `TMap` 和 `TMultiMap`，但有一个重要区别：`TSet` 是通过对元素求值的可覆盖函数，使用数据值本身作为键，而不是将数据值与独立的键相关联。`TSet` 可以非常快速地添加、查找和删除元素（恒定时间）。默认情况下，`TSet` 不支持重复的键，但使用模板参数可激活此行为。

### TSet

`TSet` 是一种快速容器类，用于在排序不重要的情况下存储唯一元素。在大多数情况下，只需要一种参数——元素类型。但是，`TSet` 可配置各种模板参数来改变其行为，使其更全面。除了可指定从 `DefaultKeyFuncs` 的派生结构体来提供散列功能，还可允许集合中的多个键拥有相同的值。它和其它容器类一样，可设置自定义内存分配器来存储数据。

和 `TArray` 一样，`TSet` 是同质容器。换而言之，其所有元素均完全为相同类型。`TSet` 也是值类型，支持常规复制、赋值和析构函数操作，以及其元素较强的所有权。`TSet` 被销毁时，其元素也将被销毁。键类型也必须是值类型。

`TSet` 使用散列，即如果给出了 `KeyFuncs` 模板参数，该参数会告知集合如何从某个元素确定键，如何比较两个键是否相等，如何对键进行散列，以及是否允许重复键。它们默认只返回对键的引用，使用 `运算符==` 对比相等性，使用非成员函数 `GetTypeHash` 进行散列。默认情况下，集合中不允许有重复的键。如果您的键类型支持这些函数，则可以将其用作集合键，无需提供自定义 `KeyFuncs`。要写入自定义 `KeyFuncs`，可扩展 `DefaultKeyFuncs` 结构体。

最后，`TSet` 可通过任选分配器控制内存分配行为。标准虚幻引擎4（UE4）分配器（如 `FHeapAllocator` 和 `TInlineAllocator`）不能用作 `TSet` 的分配器。实际上，`TSet` 使用集合分配器，该分配器可定义集合中使用的散列桶数量以及用于存储元素的标准UE4分配器。请参见 `TSetAllocator` 了解更多信息。

与 `TArray` 不同的是，内存中 `TSet` 元素的相对排序既不可靠也不稳定，对这些元素进行迭代很可能会使它们返回的顺序和它们添加的顺序有所不同。这些元素也不太可能在内存中连续排列。集合中的后台数据结构是稀疏数组，即在数组中有空位。从集合中移除元素时，稀疏数组中会出现空位。将新的元素添加到阵列可填补这些空位。但是，即便 `TSet` 不会打乱元素来填补空位，指向集元素的指针仍然可能失效，因为如果存储器被填满，又添加了新的元素，整个存储可能会重新分配。

### 创建和填充集合

`TSet` 的创建方法如下：

```c++
TSet<FString> FruitSet;
```

这会创建一个空白 `TSet`，用于存储 `FString` 数据。`TSet` 会直接使用 `运算符==` 比较元素，使用 `GetTypeHash` 对其进行散列，然后使用标准的堆分配器。此时尚未分配内存。

填充集合的标准方法是使用 `Add` 函数并提供键（元素）：

```c++
FruitSet.Add(TEXT("Banana"));
FruitSet.Add(TEXT("Grapefruit"));
FruitSet.Add(TEXT("Pineapple"));
// FruitSet == [ "Banana", "Grapefruit", "Pineapple" ]
```



此处的元素按插入顺序排列，但不保证这些元素在内存中实际保留此排序。如果是新集合，可能会保留插入排序，但插入和删除的次数越多，新元素不出现在末尾的可能性越大。



由于此集合使用了默认分配器，可以确保键是唯一的。如果尝试添加重复键，会发生以下情况：

```c++
FruitSet.Add(TEXT("Pear"));
FruitSet.Add(TEXT("Banana"));
// FruitSet == [ "Banana", "Grapefruit", "Pineapple", "Pear" ]
// Note:Only one banana entry.
```

该集合现在包含4个元素。"Pear"将数量从3增至4，但新的"Banana"没有改变集合中的元素数量，因为它替代了旧的"Banana"条目。

和 `TArray` 一样，还可使用 `Emplace` 代替 `Add`，避免插入集合时创建临时文件：

```c++
FruitSet.Emplace(TEXT("Orange"));
// FruitSet == [ "Banana", "Grapefruit", "Pineapple", "Pear", "Orange" ]
```

此处，参数直接传递给键类型的构造函数。这可以避免为该值创建临时 `FString`。与 `TArray` 不同的是，只能使用单一参数构造函数将元素放到集合中。

也可使用 `Append` 函数进行合并来插入另一个集合中的所有元素：

```c++
TSet<FString> FruitSet2;
FruitSet2.Emplace(TEXT("Kiwi"));
FruitSet2.Emplace(TEXT("Melon"));
FruitSet2.Emplace(TEXT("Mango"));
FruitSet2.Emplace(TEXT("Orange"));
FruitSet.Append(FruitSet2);
// FruitSet == [ "Banana", "Grapefruit", "Pineapple", "Pear", "Orange", "Kiwi", "Melon", "Mango" ]
```

在上述示例中，生成的集合和使用 `Add` 或 `Emplace` 进行单个添加是相同的。源集合中的重复键将会替代目标集合中相应的键。

### 编辑UPROPERTY TSet

如果用 `UPROPERTY` 宏和一个可编辑的关键词（`EditAnywhere`、`EditDefaultsOnly` 或 `EditInstanceOnly`）标记 `TSet`，则可[在虚幻编辑器中添加和编辑元素](https://docs.unrealengine.com/5.1/zh-CN/level-editor-details-panel-in-unreal-engine)。

```c++
UPROPERTY(Category = SetExample, EditAnywhere)
TSet<FString> FruitSet;
```

### 迭代

`TSet` 的迭代类似于 `TArray`。可使用C++的设置范围功能：

```c++
for (auto& Elem :FruitSet)
{
    FPlatformMisc::LocalPrint(
        *FString::Printf(
            TEXT(" \"%s\"\n"),
            *Elem
        )
    );
}
// Output:
//  "Banana"
//  "Grapefruit"
//  "Pineapple"
//  "Pear"
//  "Orange"
//  "Kiwi"
//  "Melon"
//  "Mango"
```

也可以用 `CreateIterator` 和 `CreateConstIterators` 函数来创建迭代器。`CreateIterator` 返回拥有读写访问权限的迭代器，而 `CreateConstIterator` 返回拥有只读访问权限的迭代器。无论哪种情况，均可用这些迭代器的 `Key` 和 `Value` 来检查元素。通过迭代器复制示例中的"fruit"集合产生如下结果：

```c++
for (auto It = FruitSet.CreateConstIterator(); It; ++It)
{
    FPlatformMisc::LocalPrint(
        *FString::Printf(
            TEXT("(%s)\n"),
            *It
        )
    );
}
```

### 查询

调用 `Num` 函数可查询集合中保存的元素数量：

```c++
int32 Count = FruitSet.Num();
// Count == 8
```

要确定集合是否包含特定元素，可按如下所示调用 `Contains` 函数：

```c++
bool bHasBanana = FruitSet.Contains(TEXT("Banana"));
bool bHasLemon = FruitSet.Contains(TEXT("Lemon"));
// bHasBanana == true
// bHasLemon == false
```

使用 `FSetElementId` 结构体可查找集合中某个键的索引。然后，就可使用该索引与 `运算符[]` 查找元素。在非常量集合上调用 `operator[]` 将返回非常量引用，而在常量集合上调用将返回常量引用。

```c++
FSetElementId BananaIndex = FruitSet.Index(TEXT("Banana"));
// BananaIndex is a value between 0 and (FruitSet.Num() - 1)
FPlatformMisc::LocalPrint(
    *FString::Printf(
        TEXT(" \"%s\"\n"),
        *FruitSet[BananaIndex]
    )
);
// Prints "Banana"

FSetElementId LemonIndex = FruitSet.Index(TEXT("Lemon"));
// LemonIndex is INDEX_NONE (-1)
FPlatformMisc::LocalPrint(
    *FString::Printf(
        TEXT(" \"%s\"\n"),
        *FruitSet[LemonIndex]
    )
); // Assert!
```

如果不确定集合中是否包含某个键，可使用 `Contains` 函数和 `运算符[]` 进行检查。但这并非理想的方法，因为同一键需要进行两次查找才能获取成功。使用 `Find` 函数查找一次即可完成这些行为。如果集合中包含该键，`Find` 将返回指向元素数值的指针。如果映射不包含该键，则返回null。对常量集合调用`Find`，返回的指针也将为常量。

```c++
FString* PtrBanana = FruitSet.Find(TEXT("Banana"));
FString* PtrLemon = FruitSet.Find(TEXT("Lemon"));
// *PtrBanana == "Banana"
//  PtrLemon == nullptr
```

`Array` 函数会返回一个 `TArray`，其中填充了 `TSet` 中每个元素的一份副本。被传递的数组在填入前会被清空，因此元素的生成数量将始终等于集合中的元素数量：

```c++
TArray<FString> FruitArray = FruitSet.Array();
// FruitArray == [ "Banana","Grapefruit","Pineapple","Pear","Orange","Kiwi","Melon","Mango" ] (order may vary)
```

### 移除

通过 `Remove` 函数可按索引移除元素，但仅建议在通过元素迭代时使用：Remove函数会返回已删除元素的数量。如果给定的键未包含在集合中，则会返回0。如果 `TSet` 支持重复的键，`Remove` 将移除所有匹配元素。

```c++
FruitSet.Remove(0);
// FruitSet == [ "Grapefruit","Pineapple","Pear","Orange","Kiwi","Melon","Mango" ]
```

移除元素将在数据结构（在Visual Studio的观察窗口中可视化集合时可看到）中留下空位，但为保证清晰度，此处省略。

```c++
int32 RemovedAmountPineapple = FruitSet.Remove(TEXT("Pineapple"));
// RemovedAmountPineapple == 1
// FruitSet == [ "Grapefruit","Pear","Orange","Kiwi","Melon","Mango" ]
FString RemovedAmountLemon = FruitSet.Remove(TEXT("Lemon"));
// RemovedAmountLemon == 0
```

最后，使用 `Empty` 或 `Reset` 函数可将集合中的所有元素移除。

```c++
TSet<FString> FruitSetCopy = FruitSet;
// FruitSetCopy == [ "Grapefruit","Pear","Orange","Kiwi","Melon","Mango" ]

FruitSetCopy.Empty();
// FruitSetCopy == []
Empty` 和 `Reset` 相似，但 `Empty` 可采用参数指示集合中保留的slack量，而 `Reset
```

### 排序

`TSet` 可以排序。排序后，迭代集合会以排序的顺序显示元素，但下次修改集合时，排序可能会发生变化。由于排序不稳定，可能按任何顺序显示集合中支持重复键的等效元素。

`Sort` 函数使用指定排序顺序的二进制谓词，如下所示：

```c++
FruitSet.Sort([](const FString& A, const FString& B) {
    return A > B; // sort by reverse-alphabetical order
});
// FruitSet == [ "Pear", "Orange", "Melon", "Mango", "Kiwi", "Grapefruit" ] (order is temporarily guaranteed)

FruitSet.Sort([](const FString& A, const FString& B) {
    return A.Len() < B.Len(); // sort strings by length, shortest to longest
});
// FruitSet == [ "Pear", "Kiwi", "Melon", "Mango", "Orange", "Grapefruit" ] (order is temporarily guaranteed)
```

### 运算符

和 `TArray` 一样，`TSet` 是常规值类型，可通过标准复制构造函数或赋值运算符进行复制。因为集合严格拥有其元素，复制集合的操作是深层的，所以新集合将拥有其自身的元素副本：

```c++
TSet<FString> NewSet = FruitSet;
NewSet.Add(TEXT("Apple"));
NewSet.Remove(TEXT("Pear"));
// FruitSet == [ "Pear", "Kiwi", "Melon", "Mango", "Orange", "Grapefruit" ]
// NewSet == [ "Kiwi", "Melon", "Mango", "Orange", "Grapefruit", "Apple" ]
```

### Slack

Slack是不包含元素的已分配内存。调用 `Reserve` 可分配内存，无需添加元素；通过非零slack参数调用 `Reset` 或 `Empty` 可移除元素，无需将其使用的内存取消分配。Slack优化了将新元素添加到集合的过程，因为可以使用预先分配的内存，而不必分配新内存。它在移除元素时也十分实用，因为系统不需要将内存取消分配。在清空希望用相同或更少的元素立即重新填充的集合时，此方法尤其有效。

`TSet` 不像 `TArray` 中的 `Max` 函数那样可检查预分配元素的数量。

以下代码可在不取消任何内存的情况下移除集合中的所有元素，从而产生slack：

```c++
FruitSet.Reset();
// FruitSet == [ <invalid>, <invalid>, <invalid>, <invalid>, <invalid>, <invalid> ]
```

使用 `Reserve` 函数可直接创建slack，例如在添加元素之前预分配内存。

```c++
FruitSet.Reserve(10);
for (int32 i = 0; i < 10; ++i)
{
    FruitSet.Add(FString::Printf(TEXT("Fruit%d"), i));
}
// FruitSet == [ "Fruit9", "Fruit8", "Fruit7" ..."Fruit2", "Fruit1", "Fruit0" ]
```



预先分配slack会导致以倒序添加新元素。与数组不同，集合不维护元素排序，处理集合的代码不能指望元素排序稳定或可预测。



使用 `Collapse` 和 `Shrink` 函数可移除 `TSet` 中的全部slack。`Shrink` 将从容器的末端移除所有slack，但这会在中间或开始处留下空白元素。

```c++
// Remove every other element from the set.
for (int32 i = 0; i < 10; i += 2)
{
    FruitSet.Remove(FSetElementId::FromInteger(i));
}
// FruitSet == ["Fruit8", <invalid>, "Fruit6", <invalid>, "Fruit4", <invalid>, "Fruit2", <invalid>, "Fruit0", <invalid> ]

FruitSet.Shrink();
// FruitSet == ["Fruit8", <invalid>, "Fruit6", <invalid>, "Fruit4", <invalid>, "Fruit2", <invalid>, "Fruit0" ]
```

在上述代码中，`Shrink` 只删除了一个无效元素，因为末端只有一个空元素。要移除所有slack，首先应调用 `Compact` 或 `CompactStable` 函数，将空白空间组合在一起，为调用 `Shrink` 做好准备。顾名思义，`CompactStable` 可在合并空元素时保持元素的排序。

```c++
FruitSet.CompactStable();
// FruitSet == ["Fruit8", "Fruit6", "Fruit4", "Fruit2", "Fruit0", <invalid>, <invalid>, <invalid>, <invalid> ]
FruitSet.Shrink();
// FruitSet == ["Fruit8", "Fruit6", "Fruit4", "Fruit2", "Fruit0" ]
```

### DefaultKeyFuncs

只要类型具有 `运算符==` 和非成员 `GetTypeHash` 重载，就可为TSet所用，因为此类型既是元素又是键。然而，不便于重载这些函数时可将类型作为键使用。在这些情况下，可对 `DefaultKeyFuncs` 进行自定义。为键类型创建 `KeyFuncs`，必须定义两个typedef和三个静态函数，如下所示：

- `KeyInitType` —— 用于传递键的类型。通常抽取自ElementType模板参数。
- `ElementInitType` —— 用于传递元素的类型。同样通常抽取自ElementType模板参数，因此与KeyInitType相同。
- `KeyInitType GetSetKey(ElementInitType Element)`——返回元素的键。在集合中，通常是元素本身。
- `bool Matches(KeyInitType A, KeyInitType B)` —— 如果 `A` 和 `B` 等值将返回 `true`，否则返回 `false`。
- `uint32 GetKeyHash(KeyInitType Key)` —— 返回 `Key` 的散列值。

`KeyInitType` 和 `ElementInitType` 是键/元素类型普通传递惯例的typedef。它们通常为浅显类型的一个值和非浅显类型的一个常量引用。请注意，集合的元素类型也是键类型，因此 `DefaultKeyFuncs` 仅使用一种模板参数 `ElementType` 定义两者。

`TSet` 假定在 `DefaultKeyFuncs` 中使用 `Matches` 进行对比结果为相等的两个项也将在 `KeyFuncs` 的 `GetKeyHash` 中返回相同的值。

```c++
DefaultKeyFuncs` 的默认实现时，此规则也适用于 `运算符==` 和 `GetKeyHash
```

### 其他

`CountBytes` 和 `GetAllocatedSize` 函数用于估计内部数组的当前内存使用情况。`CountBytes` 接受 `FArchive` 参数，而 `GetAllocatedSize` 则不接受。这些函数常用于统计报告。

`Dump` 函数接受 `FOutputDevice` 并写出关于集合内容的实现信息。还有一个名为 `DumpHashElements` 的函数，可列出来自所有散列条目的所有元素。这些函数常用于调试。



## TMap（字典或哈希表）[[4\]](https://zhuanlan.zhihu.com/p/137638251#ref_4)

TMap主要由两个类型定义（一个键类型和一个值类型），以关联对的形式存储在映射中。

继 `TArray` 之后，**虚幻引擎4**（UE4）中最常用的容器是 `TMap`。`TMap` 与 `TSet` 类似，它们的结构均基于对键进行散列运算。但与 `TSet` 不同的是，此容器将数据存储为键值对（`TPair<KeyType, ValueType>`），只将键用于存储和获取。

映射有两种类型：`TMap` 和 `TMultiMap`。两者之间的不同点是，`TMap` 中的键是唯一的，而`TMultiMap` 可存储多个相同的键。在 `TMap` 中添加新的键值时，若所用的键与原有的对相同，新对将替换原有的对。在 `TMultiMap` 中，容器可以同时存储新对和原有的对。

## TMap

在 `TMap` 中，键值对被视为映射的元素类型，相当于每一对都是个体对象。在本文中，元素就意味着键值对，而各个组件就被称作元素的键或元素的值。元素类型实际上是 `TPair<KeyType, ElementType>`，但很少需要直接引用 `TPair` 类型。

和 `TArray` 一样，`TMap` 也是同质容器，就是说它所有元素的类型都应完全相同。`TMap` 也是值类型，支持通常的复制、赋值和析构函数运算，以及它的元素的强所有权。在映射被销毁时，它的元素都会被销毁。键和值也必须为值类型。

`TMap` 是散列容器，这意味着键类型必须支持 `GetTypeHash` 函数，并提供 `运算符==` 来比较各个键是否等值。稍后将详细介绍散列。

`TMap` 也可使用任选分配器来控制内存分配行为。但不同于 `TArray`，这些是集合分配器，而不是 `FHeapAllocator` 和 `TInlineAllocator` 之类的标准UE4分配器。集合分配器（`TSetAllocator`类）定义映射应使用的散列桶数量，以及应使用哪个标准UE4分配器来存储散列和元素。

`KeyFuncs` 是最后一个 `TMap` 模板参数，该参数告知映射如何从元素类型获取键，如何比较两个键是否相等，以及如何对键进行散列计算。这些参数有默认值，它们只会返回对键的引用，使用 `运算符==` 确定相等性，并调用非成员 `GetTypeHash` 函数进行散列计算。如果您的键类型支持这些函数，可使用它作为映射键，不需要提供自定义 `KeyFuncs`。

与 `TArray` 不同的是，内存中 `TMap` 元素的相对排序既不可靠也不稳定，对这些元素进行迭代很可能会使它们返回的顺序和它们添加的顺序有所不同。这些元素也不太可能在内存中连续排列。映射的支持数据结构是稀疏数组，这种数组可有效支持元素之间的空位。当元素从映射中被移除时，稀疏数组中就会出现空位。将新的元素添加到数组可填补这些空位。但是，即便 `TMap` 不会打乱元素来填补空位，指向映射元素的指针仍然可能失效，因为如果存储器被填满，又添加了新的元素，整个存储可能会重新分配。

## 创建和填充映射

`TMap` 的创建方法如下：

```c++
TMap<int32, FString> FruitMap;
```

`FruitMap` 现在是一个字符串的空 `TMap`，该字符串由整数键标识。我们既没有指定分配器，也没有指定 `KeyFuncs`，所以映射将执行标准的堆分配，使用 `运算符==` 对键进行对比（`int32` 类型），并使用 `GetTypeHash` 进行散列运算。此时没有分配任何内存。

填充映射的标准方法是调用带一个键和值的 `Add` 函数：

```c++
FruitMap.Add(5, TEXT("Banana"));
FruitMap.Add(2, TEXT("Grapefruit"));
FruitMap.Add(7, TEXT("Pineapple"));
// FruitMap == [
//  { Key:5, Value:"Banana"     },
//  { Key:2, Value:"Grapefruit" },
//  { Key:7, Value:"Pineapple"  }
// ]
```



此处的元素按插入顺序排列，但不保证这些元素在内存中实际保留此排序。如果是新的映射，可能会保留插入排序，但插入和删除的次数越多，新元素不出现在末尾的可能性就越大。



这不是 `TMultiMap`，所以各个键都必定是唯一。如果尝试添加重复键，将发生以下情况：

```c++
FruitMap.Add(2, TEXT("Pear"));
// FruitMap == [
//  { Key:5, Value:"Banana"    },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" }
// ]
```

映射仍然包含3个元素，但之前键值为2的"Grapefruit"已被"Pear"替代。

`Add` 函数可接受不带值的键。调用此重载后的 `Add` 时，值将被默认构建：

```c++
FruitMap.Add(4);
// FruitMap == [
//  { Key:5, Value:"Banana"    },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:""          }
// ]
```

和 `TArray` 一样，还可使用 `Emplace` 代替 `Add`，防止插入映射时创建临时文件：

```c++
FruitMap.Emplace(3, TEXT("Orange"));
// FruitMap == [
//  { Key:5, Value:"Banana"    },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:""          },
//  { Key:3, Value:"Orange"    }
// ]
```

此处直接将键和值传递给了各自的构造函数。这对 `int32` 键实际上没有影响，但避免了为该值创建临时 `FString`。与 `TArray` 不同的是，只能通过单一参数构造函数将元素安放到映射中。

也可使用 `Append` 函数合并映射，将一个映射的所有元素移至另一个映射：

```c++
TMap<int32, FString> FruitMap2;
FruitMap2.Emplace(4, TEXT("Kiwi"));
FruitMap2.Emplace(9, TEXT("Melon"));
FruitMap2.Emplace(5, TEXT("Mango"));
FruitMap.Append(FruitMap2);
// FruitMap == [
//  { Key:5, Value:"Mango"     },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:"Kiwi"      },
//  { Key:3, Value:"Orange"    },
//  { Key:9, Value:"Melon"     }
// ]
// FruitMap2 is now empty.
```

在上面的示例中，生成的映射和使用 `Add` 或 `Emplace` 逐个添加 `FruitMap2` 的元素相同，在该过程完成时会清空 `FruitMap2`。这意味着如果 `FruitMap2` 中任何元素的键与 `FruitMap` 中原有元素的键相同，就会取代该元素。

如果用 `UPROPERTY` 宏和一个可编辑的关键词（`EditAnywhere`、`EditDefaultsOnly` 或 `EditInstanceOnly`）标记 `TMap`，即可[在编辑器中添加和编辑元素](https://docs.unrealengine.com/5.1/zh-CN/level-editor-details-panel-in-unreal-engine)。

```c++
UPROPERTY(Category = MapsAndSets, EditAnywhere)
TMap<int32, FString> FruitMap;
```

## 迭代

`TMaps` 的迭代类似于 `TArrays`。可使用C++的设置范围功能，注意元素类型是 `TPair`：

```c++
for (auto& Elem :FruitMap)
{
    FPlatformMisc::LocalPrint(
        *FString::Printf(
            TEXT("(%d, \"%s\")\n"),
            Elem.Key,
            *Elem.Value
        )
    );
}
// Output:
// (5, "Mango")
// (2, "Pear")
// (7, "Pineapple")
// (4, "Kiwi")
// (3, "Orange")
// (9, "Melon")
```

也可以用 `CreateIterator` 和 `CreateConstIterators` 函数来创建迭代器。`CreateIterator` 返回拥有读写访问权限的迭代器，而 `CreateConstIterator` 返回拥有只读访问权限的迭代器。无论哪种情况，均可用这些迭代器的 `Key` 和 `Value` 来检查元素。使用迭代器显示"fruit"范例映射将产生如下结果：

```c++
for (auto It = FruitMap.CreateConstIterator(); It; ++It)
{
    FPlatformMisc::LocalPrint(
        *FString::Printf(
            TEXT("(%d, \"%s\")\n"),
            It.Key(),   // same as It->Key
            *It.Value() // same as *It->Value
        )
    );
}
```

## 查询

调用 `Num` 函数即可查询映射中保存的元素数量：

```c++
int32 Count = FruitMap.Num();
// Count == 6
```

要确定映射是否包含特定键，可按下方所示调用 `Contains` 函数：

```c++
bool bHas7 = FruitMap.Contains(7);
bool bHas8 = FruitMap.Contains(8);
// bHas7 == true
// bHas8 == false
```

如果知道映射中存在某个特定键，可使用 `运算符[]` 查找相应值，将键用作索引。使用非常量映射执行该操作将返回非常量引用，使用常量映射将返回常量引用。

```c++
运算符[]
FString Val7 = FruitMap[7];
// Val7 == "Pineapple"
FString Val8 = FruitMap[8];
// Assert!
```

如果不确定映射中是否包含某个键，可使用 `Contains` 函数和 `运算符[]` 进行检查。但这并非理想的方法，因为同一键需要进行两次查找才能获取成功。使用 `Find` 函数查找一次即可完成这些行为。如果映射包含该键，`Find` 将返回指向元素数值的指针。如果映射不包含该键，则返回null。在常量映射上调用 `Find`，返回的指针也将为常量。

```c++
FString* Ptr7 = FruitMap.Find(7);
FString* Ptr8 = FruitMap.Find(8);
// *Ptr7 == "Pineapple"
//  Ptr8 == nullptr
```

或为了确保查询的结果有效，可使用 `FindOrAdd` 或 `FindRef`。`FindOrAdd` 将返回对与给定键关联的值的引用。如果映射中不存在该键，`FindOrAdd` 将返回新创建的元素（使用给定键和默认构建值），该元素也会被添加到映射。`FindOrAdd` 可修改映射，因此仅适用于非常量映射。不要被名称迷惑，`FindRef` 会返回与给定键关联的值副本；若映射中未找到给定键，则返回默认构建值。`FindRef` 不会创建新元素，因此既可用于常量映射，也可用于非常量映射。即使在映射中找不到键，`FindOrAdd` 和 `FindRef` 也会成功运行，因此无需执行常规的安全规程（如提前检查 `Contains` 或对返回值进行空白检查）就可安全地调用。

```c++
FString& Ref7 = FruitMap.FindOrAdd(7);
// Ref7     == "Pineapple"
// FruitMap == [
//  { Key:5, Value:"Mango"     },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:"Kiwi"      },
//  { Key:3, Value:"Orange"    },
//  { Key:9, Value:"Melon"     }
// ]
FString& Ref8 = FruitMap.FindOrAdd(8);
// Ref8     == ""
// FruitMap == [
//  { Key:5, Value:"Mango"     },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:"Kiwi"      },
//  { Key:3, Value:"Orange"    },
//  { Key:9, Value:"Melon"     },
//  { Key:8, Value:""          }
// ]

FString Val7 = FruitMap.FindRef(7);
FString Val6 = FruitMap.FindRef(6);
// Val7     == "Pineapple"
// Val6     == ""
// FruitMap == [
//  { Key:5, Value:"Mango"     },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:"Kiwi"      },
//  { Key:3, Value:"Orange"    },
//  { Key:9, Value:"Melon"     },
//  { Key:8, Value:""          }
// ]
```

和示例中初始化 `Ref8` 时一样，`FindOrAdd` 可向映射添加新条目，因此之前获得的指针（来自 `Find`）或引用（来自 `FindOrAdd`）可能会无效。如果映射的后端存储需要扩展以容纳新元素，会执行分配内存和移动现有数据的添加操作，从而导致这一结果。以上示例中，在调用 `FindOrAdd(8)` 之后，`Ref7` 可能会紧随 `Ref8` 失效。

`FindKey` 函数执行逆向查找，这意味着提供的值与键匹配，并返回指向与所提供值配对的第一个键的指针。搜索映射中不存在的值将返回空键。

```c++
const int32* KeyMangoPtr   = FruitMap.FindKey(TEXT("Mango"));
const int32* KeyKumquatPtr = FruitMap.FindKey(TEXT("Kumquat"));
// *KeyMangoPtr   == 5
//  KeyKumquatPtr == nullptr
```

按值查找比按键查找慢（线性时间）。这是因为映射按键排序，而非按值排序。此外，如果映射有多个具有相同值的键，`FindKey` 可返回其中任一键。

`GenerateKeyArray` 和 `GenerateValueArray` 分别使用所有键和值的副本来填充 `TArray`。在这两种情况下，都会在填充前清空所传递的数组，因此产生的元素数量始终等于映射中的元素数量。

```c++
TArray<int32>   FruitKeys;
TArray<FString> FruitValues;
FruitKeys.Add(999);
FruitKeys.Add(123);
FruitMap.GenerateKeyArray  (FruitKeys);
FruitMap.GenerateValueArray(FruitValues);
// FruitKeys   == [ 5,2,7,4,3,9,8 ]
// FruitValues == [ "Mango","Pear","Pineapple","Kiwi","Orange",
//                  "Melon","" ]
```

## 移除

从映射中移除元素的方法是使用 `Remove` 函数并提供要移除元素的键。返回值是被移除元素的数量。如果映射不包含与键匹配的元素，则返回值可为零。

```c++
FruitMap.Remove(8);
// FruitMap == [
//  { Key:5, Value:"Mango"     },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:"Kiwi"      },
//  { Key:3, Value:"Orange"    },
//  { Key:9, Value:"Melon"     }
// ]
```

移除元素将在数据结构（在Visual Studio的观察窗口中可视化映射时可看到）中留下空位，但为保证清晰度，此处省略。

`FindAndRemoveChecked` 函数可用于从映射移除元素并返回其值。名称的"已检查"部分表示若键不存在，映射将调用 `check`（UE4中等同于 `assert`）。

```c++
FString Removed7 = FruitMap.FindAndRemoveChecked(7);
// Removed7 == "Pineapple"
// FruitMap == [
//  { Key:5, Value:"Mango"  },
//  { Key:2, Value:"Pear"   },
//  { Key:4, Value:"Kiwi"   },
//  { Key:3, Value:"Orange" },
//  { Key:9, Value:"Melon"  }
// ]

FString Removed8 = FruitMap.FindAndRemoveChecked(8);
// Assert!
```

`RemoveAndCopyValue` 函数的作用与 `Remove` 相似，不同点是会将已移除元素的值复制到引用参数。如果映射中不存在指定的键，则输出参数将保持不变，函数将返回 `false`。

```c++
FString Removed;
bool bFound2 = FruitMap.RemoveAndCopyValue(2, Removed);
// bFound2  == true
// Removed  == "Pear"
// FruitMap == [
//  { Key:5, Value:"Mango"  },
//  { Key:4, Value:"Kiwi"   },
//  { Key:3, Value:"Orange" },
//  { Key:9, Value:"Melon"  }
// ]
bool bFound8 = FruitMap.RemoveAndCopyValue(8, Removed);
// bFound8  == false
// Removed  == "Pear", i.e. unchanged
// FruitMap == [
//  { Key:5, Value:"Mango"  },
//  { Key:4, Value:"Kiwi"   },
//  { Key:3, Value:"Orange" },
//  { Key:9, Value:"Melon"  }
// ]
```

最后，使用 `Empty` 或 `Reset` 函数可将映射中的所有元素移除。

```c++
TMap<int32, FString> FruitMapCopy = FruitMap;
// FruitMapCopy == [
//  { Key:5, Value:"Mango"  },
//  { Key:4, Value:"Kiwi"   },
//  { Key:3, Value:"Orange" },
//  { Key:9, Value:"Melon"  }
// ]

FruitMapCopy.Empty();       // We could also have called Reset() here.
// FruitMapCopy == []
Empty` 和 `Reset` 相似，但 `Empty` 可采用参数指示映射中保留的slack量，而 `Reset
```

## 排序

`TMap` 可以进行排序。排序后，迭代映射会以排序的顺序显示元素，但下次修改映射时，排序可能会发生变化。排序是不稳定的，因此等值元素在MultiMap中可能以任何顺序出现。

使用 `KeySort` 或 `ValueSort` 函数可分别按键和值进行排序。两个函数均使用二元谓词来进行排序：

```c++
FruitMap.KeySort([](int32 A, int32 B) {
    return A > B; // sort keys in reverse
});
// FruitMap == [
//  { Key:9, Value:"Melon"  },
//  { Key:5, Value:"Mango"  },
//  { Key:4, Value:"Kiwi"   },
//  { Key:3, Value:"Orange" }
// ]

FruitMap.ValueSort([](const FString& A, const FString& B) {
    return A.Len() < B.Len(); // sort strings by length
});
// FruitMap == [
//  { Key:4, Value:"Kiwi"   },
//  { Key:5, Value:"Mango"  },
//  { Key:9, Value:"Melon"  },
//  { Key:3, Value:"Orange" }
// ]
```

## 运算符

和 `TArray` 一样，`TMap` 是常规值类型，可通过标准复制构造函数或赋值运算符进行复制。因为映射严格拥有其元素，复制映射的操作是深层的，所以新的映射将拥有其自己的元素副本。

```c++
TMap<int32, FString> NewMap = FruitMap;
NewMap[5] = "Apple";
NewMap.Remove(3);
// FruitMap == [
//  { Key:4, Value:"Kiwi"   },
//  { Key:5, Value:"Mango"  },
//  { Key:9, Value:"Melon"  },
//  { Key:3, Value:"Orange" }
// ]
// NewMap == [
//  { Key:4, Value:"Kiwi"  },
//  { Key:5, Value:"Apple" },
//  { Key:9, Value:"Melon" }
// ]
```

`TMap` 支持移动语义，使用 `MoveTemp` 函数可调用这些语义。在移动后，源映射必定为空：

```c++
FruitMap = MoveTemp(NewMap);
// FruitMap == [
//  { Key:4, Value:"Kiwi"  },
//  { Key:5, Value:"Apple" },
//  { Key:9, Value:"Melon" }
// ]
// NewMap == []
```

## Slack

Slack是不包含元素的已分配内存。调用 `Reserve` 可分配内存，无需添加元素；通过非零slack参数调用 `Reset` 或 `Empty` 可移除元素，无需将其使用的内存取消分配。Slack优化了将新元素添加到映射的过程，因为可以使用预先分配的内存，而不必分配新内存。它在移除元素时也十分实用，因为系统不需要将内存取消分配。在清空希望用相同或更少的元素立即重新填充的映射时，此方法尤其有效。

`TMap` 不像 `TArray` 中的 `Max` 函数那样可以检查预分配元素的数量。

在下列代码中，`Reserve` 函数预先分配映射，最多可包含10个元素。

```c++
FruitMap.Reserve(10);
for (int32 i = 0; i < 10; ++i)
{
    FruitMap.Add(i, FString::Printf(TEXT("Fruit%d"), i));
}
// FruitMap == [
//  { Key:9, Value:"Fruit9" },
//  { Key:8, Value:"Fruit8" },
//  ...
//  { Key:1, Value:"Fruit1" },
//  { Key:0, Value:"Fruit0" }
// ]
```

使用 `Collapse` 和 `Shrink` 函数可移除 `TMap` 中的全部slack。`Shrink` 将从容器的末端移除所有slack，但这会在中间或开始处留下空白元素。

```c++
for (int32 i = 0; i < 10; i += 2)
{
    FruitMap.Remove(i);
}
// FruitMap == [
//  { Key:9, Value:"Fruit9" },
//  <invalid>,
//  { Key:7, Value:"Fruit7" },
//  <invalid>,
//  { Key:5, Value:"Fruit5" },
//  <invalid>,
//  { Key:3, Value:"Fruit3" },
//  <invalid>,
//  { Key:1, Value:"Fruit1" },
//  <invalid>
// ]
FruitMap.Shrink();
// FruitMap == [
//  { Key:9, Value:"Fruit9" },
//  <invalid>,
//  { Key:7, Value:"Fruit7" },
//  <invalid>,
//  { Key:5, Value:"Fruit5" },
//  <invalid>,
//  { Key:3, Value:"Fruit3" },
//  <invalid>,
//  { Key:1, Value:"Fruit1" }
// ]
```

在上述代码中，`Shrink` 只删除了一个无效元素，因为末端只有一个空元素。要移除所有slack，首先应调用 `Compact` 函数，将空白空间组合在一起，为调用 `Shrink` 做好准备。

```c++
FruitMap.Compact();
// FruitMap == [
//  { Key:9, Value:"Fruit9" },
//  { Key:7, Value:"Fruit7" },
//  { Key:5, Value:"Fruit5" },
//  { Key:3, Value:"Fruit3" },
//  { Key:1, Value:"Fruit1" },
//  <invalid>,
//  <invalid>,
//  <invalid>,
//  <invalid>
// ]
FruitMap.Shrink();
// FruitMap == [
//  { Key:9, Value:"Fruit9" },
//  { Key:7, Value:"Fruit7" },
//  { Key:5, Value:"Fruit5" },
//  { Key:3, Value:"Fruit3" },
//  { Key:1, Value:"Fruit1" }
// ]
```

## KeyFuncs

只要类型具有 `运算符==` 和非成员 `GetTypeHash` 重载，就可用作 `TMap` 的键类型，不需要任何更改。但是，您可能需要将类型用作键，而不重载这些函数。在这些情况下，可对 `KeyFuncs` 进行自定义。为键类型创建 `KeyFuncs`，必须定义两个typedef和三个静态函数，如下所示：

- `KeyInitType` —— 用于传递键的类型。
- `ElementInitType` —— 用于传递元素的类型。
- `KeyInitType GetSetKey(ElementInitType Element)`——返回元素的键。
- `bool Matches(KeyInitType A, KeyInitType B)` —— 如果 `A` 和 `B` 等值将返回 `true`，否则返回 `false`。
- `uint32 GetKeyHash(KeyInitType Key)` —— 返回 `Key` 的散列值。

`KeyInitType` 和 `ElementInitType` 是键类型和值类型的常规传递约定的typedef。它们通常为浅显类型的一个值，和非浅显类型的一个常量引用。请记住，映射的元素类型是 `TPair`。

自定义 `KeyFuncs` 的示例可能如下所示：

```c++
struct FMyStruct
{
    // String which identifies our key
    FString UniqueID;

    // Some state which doesn't affect struct identity
    float SomeFloat;

    explicit FMyStruct(float InFloat)
        :UniqueID (FGuid::NewGuid().ToString())
        , SomeFloat(InFloat)
    {
    }
};
template <typename ValueType>
struct TMyStructMapKeyFuncs :
    BaseKeyFuncs<
        TPair<FMyStruct, ValueType>,
        FString
    >
{
private:
    typedef BaseKeyFuncs<
        TPair<FMyStruct, ValueType>,
        FString
    > Super;

public:
    typedef typename Super::ElementInitType ElementInitType;
    typedef typename Super::KeyInitType     KeyInitType;

    static KeyInitType GetSetKey(ElementInitType Element)
    {
        return Element.Key.UniqueID;
    }

    static bool Matches(KeyInitType A, KeyInitType B)
    {
        return A.Compare(B, ESearchCase::CaseSensitive) == 0;
    }

    static uint32 GetKeyHash(KeyInitType Key)
    {
        return FCrc::StrCrc32(*Key);
    }
};
```

`FMyStruct` 具有唯一标识符，以及一些与身份无关的其他数据。`GetTypeHash` 和 `运算符==` 不适用于此，因为 `运算符==` 为实现通用目的不应忽略任何类型的数据，但同时又需要如此才能与 `GetTypeHash` 的行为保持一致，后者只关注 `UniqueID` 字段。以下步骤有助于为 `FMyStruct` 创建自定义 `KeyFuncs`：

1. 首先，继承 `BaseKeyFuncs`，因为它可以帮助定义某些类型，包括 `KeyInitType` 和 `ElementInitType`。

   `BaseKeyFuncs` 使用两个模板参数：映射的元素类型和键类型。和所有映射一样，元素类型是 `TPair`，使用 `FMyStruct` 作为其 `KeyType`，`TMyStructMapKeyFuncs` 的模板参数作为其 `ValueType`。将备用 `KeyFuncs` 用作模板，可为每个映射指定 `ValueType`，因此每次要在 `FMyStruct` 上创建键控 `TMap` 时不必定义新的 `KeyFuncs`。第二个 `BaseKeyFuncs` 参数是键类型，不要与元素存储的键区（`TPair` 的 `KeyType`）混淆。因为此映射应使用 `UniqueID`（来自 `FMyStruct`）作为键，所以此处使用 `FString`。

2. 然后，定义三个必需的 `KeyFuncs` 静态函数。第一个是 `GetSetKey`，该函数返回给定元素类型的键。由于元素类型是 `TPair`，而键是 `UniqueID`，所以该函数可直接返回 `UniqueID`。

   第二个静态函数是 `Matches`，该函数接受两个元素的键（由 `GetSetKey` 获取），然后比较它们是否相等。在 `FString` 中，标准的等效测试（`运算符==`）不区分大小写；要替换为区分大小写的搜索，请用相应的大小写对比选项使用 `Compare` 函数。

3. 最后，`GetKeyHash` 静态函数接受提取的键并返回其散列值。由于 `Matches` 函数区分大小写，`GetKeyHash` 也必须区分大小写。区分大小写的 `FCrc` 函数将计算键字符串的散列值。

4. 现在结构已满足 `TMap` 要求的行为，可创建它的实例。

```c++
KeyFuncs` 参数处于最后，所以这个 `TMap
    TMap<
        FMyStruct,
        int32,
        FDefaultSetAllocator,
        TMyStructMapKeyFuncs<int32>
    > MyMapToInt32;

    // Add some elements
    MyMapToInt32.Add(FMyStruct(3.14f), 5);
    MyMapToInt32.Add(FMyStruct(1.23f), 2);

    // MyMapToInt32 == [
    //  {
    //      Key:{
    //          UniqueID:"D06AABBA466CAA4EB62D2F97936274E4",
    //          SomeFloat:3.14f
    //      },
    //      Value:5
    //  },
    //  {
    //      Key:{
    //          UniqueID:"0661218447650259FD4E33AD6C9C5DCB",
    //          SomeFloat:1.23f
    //      },
    //      Value:5
    //  }
    // ]
TMap` 假设两个项目使用 `Matches` 比较的结果相等，则它们会从 `GetKeyHash` 返回相同的值。此外，如果对现有映射元素的键进行的修改将会改变来自这两个函数中任一个的结果，那么系统会将这种修改视作未定义的行为，因为这会使映射的内部散列失效。这些规则也适用于使用默认 `KeyFuncs` 时 `运算符==` 和 `GetKeyHash
```

## 其他

`CountBytes` 和 `GetAllocatedSize` 函数用于估计内部数组的当前内存使用情况。`CountBytes` 接受 `Farchive` 参数，而 `GetAllocatedSize` 则不会。这些函数常用于统计报告。

`Dump` 函数接受 `FOutputDevice`，并写出关于映射内容的实现信息。此函数常用于调试。

## 参考

1. [^](https://zhuanlan.zhihu.com/p/137638251#ref_1_0)static_assert https://zh.cppreference.com/w/cpp/language/static_assert
2. [^](https://zhuanlan.zhihu.com/p/137638251#ref_2_0)TArray https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/TArrays/index.html
3. [^](https://zhuanlan.zhihu.com/p/137638251#ref_3_0)TSet https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/TSet/index.html
4. [^](https://zhuanlan.zhihu.com/p/137638251#ref_4_0)TMap https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/TMap/index.html
```

`note/UE/UE4 C++基础 - 多线程.md`:

```md
# UE4 C++基础 - 多线程



## 1. 线程概念

线程是操作系统能够进行运行调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

典型的UNIX进程可以看成只有一个控制线程：一个进程在同一时刻只做一件事情。有了多个线程以后，在程序设计时可以把进程设计成在同一时刻能够做不止一件事，每个线程处理各自独立的任务。这种方法有很多好处[[1\]](https://zhuanlan.zhihu.com/p/133921916#ref_1)。

- 通过为每种事件类型的处理分配单独的线程，能够简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式，同步编程模式要比异步编程模式简单得多。
- 多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享。而多个线程自动地可以访问相同的储存地址空间和文件描述符。
- 有些问题可以通过将其分解从而改善整个程序的吞吐量。在只有一个控制线程的情况下，单个进程需要完成多个任务时，实际上需要把这些任务串行化；有了多个控制线程，相互独立的任务的处理就可以交叉进行，只需要为每个任务分配一个单独的线程，当然只有在处理过程互不依赖的情况下，两个任务的执行才可以穿插进行。
- 交互的程序同样可以通过使用多线程实现响应时间的改善，多线程可以把程序中处理用户输入输出的部分与其他部分分开。

## 2. UE4中的多线程 FRunnable & FRunnableThread

UE4是跨平台的引擎，对各个平台线程实现进行了封装，抽象出了 ***FRunnable\*** [[2\]](https://zhuanlan.zhihu.com/p/133921916#ref_2)。引擎中大部分的需要多线程执行逻辑都是继承这个类实现的多线程，如

- [FAsyncWriter](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Core/Misc/FAsyncWriter/index.html)
- [FUdpSocketReceiver](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Networking/Common/FUdpSocketReceiver/index.html)
- [FTcpListener](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Networking/Common/FTcpListener/index.html)

一个可执行的线程必须包含一个 runnable 对象，用来执行业务逻辑代码。样例如下：

```cpp
#include "HAL/Runnable.h"

class MyRunnable : public FRunnable {
public:
	virtual bool Init() override;  // 初始化 runnable 对象
	virtual uint32 Run() override; // 运行 runnable 对象
	virtual void Stop() override;  // 停止 runnable 对象,线程提前终止时被调用
	virtual void Exit() override;  // 退出 runnable 对象
};

bool MyRunnable::Init() { return true; }
uint32 MyRunnable::Run() { return 0; }
void MyRunnable::Stop() {}
void MyRunnable::Exit() {} 
```

调用顺序是 **Init()**, **Run()**, **Exit()**。Runnable对象初始化操作在 **Init()** 函数中完成，并通过返回值确定是否成功。初始化失败，则该线程停止执行，并返回一个错误码；成功，则会执行 **Run()** ；执行完毕后，则会调用 **Exit()** 执行清理操作。

## 2.1 多线程创建

**Runnable**负责具体业务逻辑的执行，UE4中使用 **[FRunnableThread](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FRunnableThread/index.html)** 表示一个可执行的线程。 可以通过调用 **[FRunnableThread::Create](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FRunnableThread/Create/index.html)** 完成线程的创建：

```cpp
#include "HAL/RunnableThread.h"

static FRunnableThread * Create
(
    class FRunnable * InRunnable, // Runnable 对象
    const TCHAR * ThreadName,     // 线程名称
    uint32 InStackSize,           // 线程栈大小,0表示使用当前线程的栈大小
    EThreadPriority InThreadPri,  // 线程优先级
    uint64 InThreadAffinityMask
);

// 返回值：若成功则返回创建的线程，否则返回 nullptr
```

样例代码如下：

```cpp
#include "HAL/RunnableThread.h"

FRunnable * Runnable = new MyRunnable();
FRunnableThread* RunnableThread = FRunnableThread::Create(Runnable, TEXT("LaLaLaDeMaXiYa!"));
```

线程对象创建成功后即开始执行Runnable对象的 ***Init\* ()** 函数，如果成功则分别执行***Run()\*** 和 ***Exit()\*** 函数。

## 2.2 线程标识

每个线程都有一个线程ID，线程ID在它所属的进程环境中有效。为增加标识性，UE4还增加了线程名称。线程ID是唯一的，线程名称可以重复。可通过[GetThreadID](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FRunnableThread/GetThreadID/index.html) 和 [GetThreadName](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FRunnableThread/GetThreadName/index.html) 获取线程ID和名称。

```cpp
const uint32 GetThreadID() const;
const FString & GetThreadName() const;
```

## 2.3 线程终止

单个线程可以通过如下三种方式退出。

1. 线程执行完 runnable 对象的 Run() 和 Exit() 函数后正常退出
2. 调用 [WaitForCompletion()](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FRunnableThread/WaitForCompletion/index.html) 函数，阻塞调用例程直到线程执行完毕
3. 调用 [Kill(bool bShouldWait=false)](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FRunnableThread/Kill/index.html) 函数，会先执行 runnable 对象的 stop 函数,然后根据 bShouldWait 参数决定是否等待线程执行完毕。如果不等待，则强制杀死线程，可能会造成内存泄漏。

```cpp
void WaitForCompletion(); // 阻塞调用例程，直到线程执行完毕
bool Kill(bool bShouldWait); // 强制杀掉线程
```

## 2.4 引擎样例代码

- Engine\Source\Programs\TestPAL\Private\Main.cpp

## 3. 实现细节 - FThreadManager

通过[FRunnableThread](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FRunnableThread/index.html) 创建的线程是通过 [FThreadManager](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FThreadManager/index.html) 进行统一管理。

```cpp
// ThreadingBase.cpp FRunnableThread::Create 函数
// Call the thread's create method
if (NewThread->CreateInternal(InRunnable,ThreadName,InStackSize,InThreadPri,InThreadAffinityMask) == false)
```

CreateInternal根据平台的不同实现不同，常用平台中，Android和iOS都是采用的 pthread标准线程库，Windows平台是单独实现的。线程创建完毕后会统一调用

```cpp
FThreadManager::Get().AddThread(ThreadID, this);
```

将线程本身添加至管理器。如 WindowsRunnableThread.h FRunnableThreadWin::CreateInternal 函数。标准线程对象 FRunnableThreadPThread 则是在入口点:

```cpp
virtual PthreadEntryPoint GetThreadEntryPoint() {
	return _ThreadProc;
}

static void *STDCALL _ThreadProc(void *pThis) {
	check(pThis);
	FRunnableThreadPThread* ThisThread = (FRunnableThreadPThread*)pThis;
	// cache the thread ID for this thread (defined by the platform)
	ThisThread->ThreadID = FPlatformTLS::GetCurrentThreadId();
	// ====================>>这里将线程本身加入管理器 <<==========================
	FThreadManager::Get().AddThread(ThisThread->ThreadID, ThisThread);
	// set the affinity.  This function sets affinity on the current thread, so don't call in the Create function which will trash the main thread affinity.
	FPlatformProcess::SetThreadAffinityMask(ThisThread->ThreadAffinityMask);		
	// run the thread!
	ThisThread->PreRun();
	ThisThread->Run();
	ThisThread->PostRun();
	pthread_exit(NULL);
	return NULL;
}
```



## 3. 线程池[[3\]](https://zhuanlan.zhihu.com/p/133921916#ref_3)

线程过多会带来调度开销，进而影响缓存局部性和整体性能。频繁创建和销毁线程也会带来极大的开销。通常我们更加关心的是任务可以并发执行，并不想管理线程的创建，销毁和调度。通过将任务处理成队列，交由线程池统一执行，可以提升任务的执行效率。UE4提供了对应的线程池来满足我们的需求。异步任务统一都继承至 **IQueuedWork**[[4\]](https://zhuanlan.zhihu.com/p/133921916#ref_4)，属于抽象接口类，可供我们直接使用的是

- **FAsyncTask**[[5\]](https://zhuanlan.zhihu.com/p/133921916#ref_5)异步任务，自动加入线程池
- **FAutoDeleteAsyncTask**[[6\]](https://zhuanlan.zhihu.com/p/133921916#ref_6) 异步任务，任务完成后会自动销毁

![img](https://pic1.zhimg.com/80/v2-20560dc1106cc350482d957b91ef8870_720w.webp)

图 1-1 线程池

异步任务通常继承 **FNonAbandonableTask**[[7\]](https://zhuanlan.zhihu.com/p/133921916#ref_7)，表明该任务不可被抛弃，必须被执行完毕。样例代码如下：

```cpp
idi#include "Async/AsyncWork.h"

class ExampleAsyncTask : public FNonAbandonableTask
{
	friend class FAsyncTask<ExampleAsyncTask>;
	friend class FAutoDeleteAsyncTask<ExampleAsyncTask>;
	int32 ExampleData;
	ExampleAsyncTask(int32 InExampleData)
		: ExampleData(InExampleData){}

	void DoWork() {
		UE_LOG(LogBlankProgram, Display, TEXT("ExampleAsyncTask %d Work."), ExampleData);
	}

	FORCEINLINE TStatId GetStatId() const {
		RETURN_QUICK_DECLARE_CYCLE_STAT(ExampleAsyncTask, STATGROUP_ThreadPoolAsyncTasks);
	}
};

void Example {
	// 2.1 线程池异步队列
	FAsyncTask<ExampleAsyncTask>* MyTask = new FAsyncTask<ExampleAsyncTask>(1);
	// 交由后台控制任务开始执行时机
	MyTask->StartBackgroundTask();
	// 确保线程被执行完成
	MyTask->EnsureCompletion();
	delete MyTask;
}
```

## 4. 线程同步

当多个线程共享相同的内存时，需要确保每个线程看到一致的数据视图。如果每个线程使用的变量都是其他线程不会读取或者修改的，那么就不存在一致性问题。同样地，如果变量是只读的，多个线程同时读取该变量也不会有一致性问题。但是，当某个线程可以修改变量，而其他线程也可以读取或者修改这个变量的时候，就需要对这些线程进行同步，以确保它们在访问变量的存储内容时不会访问到无效的数值。这个时候就需要用到线程同步机制。UE4提供了以下几个不同类别的同步机制：

## 4.1 Atomics 原子机制

Atomic operations(原子操作) 保证CPU在读取和写入内存时总线操作是不可分割的。它是许多高级同步机制的基础，主要优势是可以进行比较快的进行比较和解锁操作。一个用Atomics实现的样例如下：

```cpp
class FThreadSafeCounter{
public:
int32 Add( int32 Amount ) {
        return FPlatformAtomics::InterlockedAdd(&Counter, Amount);
    }
private:
    volatile int32 Counter; // 因为值可能以编译器无法预测的异步方式被改变，声明为volatile禁用优化
};
```

## 4.2 Locking 锁机制

在UE4中常用的两种锁机制是 Critical Sections(临界区）和 SpinLocks(自旋锁）。

- FSpinLock 自旋锁
- **FScopeLock**[[8\]](https://zhuanlan.zhihu.com/p/133921916#ref_8) 区域锁
- **FCriticalSection** 临界区
- **FRWLock**[[9\]](https://zhuanlan.zhihu.com/p/133921916#ref_9) 读写锁

## 4.3 Signaling 信号机制

- **FSemaphore**[[10\]](https://zhuanlan.zhihu.com/p/133921916#ref_10)信号量与互斥锁类型，但是他包含了一种信号机制。缺点是不是所有平台都支持。更加常用的线程间通信机制是 **FEvent**[[11\]](https://zhuanlan.zhihu.com/p/133921916#ref_11)。

## 4.4 Waiting

- **FEvent**[[11\]](https://zhuanlan.zhihu.com/p/133921916#ref_11) 事件

- - 阻塞直至被触发或者超时
  - 经常被用来激活其他工作线程

- **FScopedEvent**[[12\]](https://zhuanlan.zhihu.com/p/133921916#ref_12)区域事件

- - 对FEvent的一次包装，阻塞在域代码退出时

```cpp
{
    FScopedEvent MyEvent;
    SendReferenceOrPointerToSomeOtherThread(&MyEvent); // Other thread calls MyEvent->Trigger() ;
    // MyEvent destructor is here, we wait here.
}
```

其中 FCriticalSection 是根据各个平台的互斥锁进行的抽象。Windows 平台是基于Windows平台的临界区。常用的iOS, Android,Linux平台则是使用的[POSIX](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/POSIX)的[线程](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B)标准实现[[13\]](https://zhuanlan.zhihu.com/p/133921916#ref_13)。

## 4.5 其他

UE4常见的容器类【TArray, TMap, TSet】通常都不是线程安全的，需要我们仔细编写代码保证线程安全。下面是几个常见的线程安全类：

- **FThreadSafeCounter**[[14\]](https://zhuanlan.zhihu.com/p/133921916#ref_14)计数器
- **FThreadSingleton** 单例类
- **FThreadIdleStats** 线程空闲状态统计类
- **TLockFreePointerList 无锁队列**
- **TQueue**[[15\]](https://zhuanlan.zhihu.com/p/133921916#ref_15)队列

下面是一个简单的线程安全TSet，附带FCriticalSection使用示例。

```cpp
/** Simple thread safe proxy for TSet<FName> */
template <typename T>
class FThreadSafeSet
{
	TSet<T> InnerSet;
	FCriticalSection SetCritical;
public:
	void Add(T InValue) {
		FScopeLock SetLock(&SetCritical);
		InnerSet.Add(InValue);
	}

	bool AddUnique(T InValue) {
		FScopeLock SetLock(&SetCritical);
		if (!InnerSet.Contains(InValue))
		{
			InnerSet.Add(InValue);
			return true;
		}
		return false;
	}

	bool Contains(T InValue) {
		FScopeLock SetLock(&SetCritical);
		return InnerSet.Contains(InValue);
	}

	void Remove(T InValue) {
		FScopeLock SetLock(&SetCritical);
		InnerSet.Remove(InValue);
	}

	void Empty() {
		FScopeLock SetLock(&SetCritical);
		InnerSet.Empty();
	}

	void GetValues(TSet<T>& OutSet) {
		FScopeLock SetLock(&SetCritical);
		OutSet.Append(InnerSet);
	}

	int32 Num() { return InnerSet.Num();}
};
```

## 完整代码

```cpp
// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.
#include "BlankProgram.h"
#include "RequiredProgramMainCPPInclude.h"
#include "HAL/Runnable.h"
#include "HAL/RunnableThread.h"
#include "Async/AsyncWork.h"

DEFINE_LOG_CATEGORY_STATIC(LogBlankProgram, Log, All);
IMPLEMENT_APPLICATION(BlankProgram, "BlankProgram");

class MyRunnable : public FRunnable {
public:
	virtual bool Init() override;  // 初始化 runnable 对象
	virtual uint32 Run() override; // 运行 runnable 对象
	virtual void Stop() override;  // 停止 runnable 对象,线程提前终止时被调用
	virtual void Exit() override;  // 退出 runnable 对象
};

bool MyRunnable::Init() {
	UE_LOG(LogBlankProgram, Display, TEXT("Thread Init."));
	return true;
}

uint32 MyRunnable::Run() {
	UE_LOG(LogBlankProgram, Display, TEXT("Thread Run."));
	return 0;
}

void MyRunnable::Stop() {}

void MyRunnable::Exit() {
	UE_LOG(LogBlankProgram, Display, TEXT("Thread Exit."));
}

// 任务队列
class ExampleAsyncTask : public FNonAbandonableTask {
	friend class FAsyncTask<ExampleAsyncTask>;
	friend class FAutoDeleteAsyncTask<ExampleAsyncTask>;

	int32 ExampleData;

	ExampleAsyncTask(int32 InExampleData)
		: ExampleData(InExampleData){}

	void DoWork() {
		UE_LOG(LogBlankProgram, Display, TEXT("ExampleAsyncTask %d Work."), ExampleData);
	}

	FORCEINLINE TStatId GetStatId() const {
		RETURN_QUICK_DECLARE_CYCLE_STAT(ExampleAsyncTask, STATGROUP_ThreadPoolAsyncTasks);
	}
};

INT32_MAIN_INT32_ARGC_TCHAR_ARGV()
{
	GEngineLoop.PreInit(ArgC, ArgV);
	UE_LOG(LogBlankProgram, Display, TEXT("UE4 Multithreading Example."));

	// 1. FRunnable 使用示例
	FRunnable * Runnable = new MyRunnable();
	FRunnableThread* RunnableThread = FRunnableThread::Create(Runnable, TEXT("LaLaLaDeMaXiYa!"));
	RunnableThread->WaitForCompletion();

	// 2.1 线程池异步队列
	FAsyncTask<ExampleAsyncTask>* MyTask = new FAsyncTask<ExampleAsyncTask>(1);
	// 交由后台控制任务开始执行时机
	MyTask->StartBackgroundTask();
	// 确保线程被执行完成
	MyTask->EnsureCompletion();
	delete MyTask;

	// 2.2 线程池异步队列
	FAsyncTask<ExampleAsyncTask>* MyTask2 = new FAsyncTask<ExampleAsyncTask>(2);
	// 直接在当前线程中执行
	MyTask2->StartSynchronousTask();
	// 检查任务是否完成
	if (MyTask2->IsDone()) {
		UE_LOG(LogBlankProgram, Display, TEXT("MyTask2 is Done."));
	}
	MyTask2->EnsureCompletion();
	delete MyTask2;

	// 2.3 带自动销毁的异步任务
	// 交由后台控制任务开始执行时机
	(new FAutoDeleteAsyncTask<ExampleAsyncTask>(3))->StartBackgroundTask();

	// 直接在当前线程中开始执行
	(new FAutoDeleteAsyncTask<ExampleAsyncTask>(4))->StartSynchronousTask();

	return 0;
}
```



## 推荐阅读资料

《UNIX环境高级编程-第十一章 线程》

[![img](https://zhstatic.zhihu.com/assets/zhihu-components/file-icon/zhimg_answer_editor_file_other.svg)concurrency-parallelism-in-ue4.pptx4M·百度网盘](https://pan.baidu.com/link/zhihu/7VhDzOuShniDeQpWdEbaNLhXVtTIpUMQQwo0==)



## 参考

1. [^](https://zhuanlan.zhihu.com/p/133921916#ref_1_0)编程范式 - 多线程基础 https://www.bilibili.com/video/BV1Cx411S7HJ?p=15
2. [^](https://zhuanlan.zhihu.com/p/133921916#ref_2_0)UE4多线程资料 https://docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FRunnable/index.html
3. [^](https://zhuanlan.zhihu.com/p/133921916#ref_3_0)Thread pool https://en.wikipedia.org/wiki/Thread_pool
4. [^](https://zhuanlan.zhihu.com/p/133921916#ref_4_0)IQueuedWork https://docs.unrealengine.com/en-US/API/Runtime/Core/Misc/IQueuedWork/index.html
5. [^](https://zhuanlan.zhihu.com/p/133921916#ref_5_0)FAsyncTask https://docs.unrealengine.com/en-US/API/Runtime/Core/Async/FAsyncTask/index.html
6. [^](https://zhuanlan.zhihu.com/p/133921916#ref_6_0)FAutoDeleteAsyncTask https://docs.unrealengine.com/en-US/API/Runtime/Core/Async/FAutoDeleteAsyncTask/index.html
7. [^](https://zhuanlan.zhihu.com/p/133921916#ref_7_0)FNonAbandonableTask https://docs.unrealengine.com/en-US/API/Runtime/Core/Async/FNonAbandonableTask/index.html
8. [^](https://zhuanlan.zhihu.com/p/133921916#ref_8_0)FScopeLock https://docs.unrealengine.com/en-US/API/Runtime/Core/Misc/FScopeLock/index.html
9. [^](https://zhuanlan.zhihu.com/p/133921916#ref_9_0)FRWLock https://docs.unrealengine.com/en-US/API/Runtime/Core/Unix/FRWLock/index.html
10. [^](https://zhuanlan.zhihu.com/p/133921916#ref_10_0)FSemaphore https://docs.unrealengine.com/en-US/API/Runtime/Core/GenericPlatform/FGenericPlatformProcess/FSemaphore/index.html
11. ^[a](https://zhuanlan.zhihu.com/p/133921916#ref_11_0)[b](https://zhuanlan.zhihu.com/p/133921916#ref_11_1)FEvent https://docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FEvent/index.html
12. [^](https://zhuanlan.zhihu.com/p/133921916#ref_12_0)FScopedEvent https://docs.unrealengine.com/en-US/API/Runtime/Core/Misc/FScopedEvent/index.html
13. [^](https://zhuanlan.zhihu.com/p/133921916#ref_13_0)POSIX Threads https://en.wikipedia.org/wiki/POSIX_Threads
14. [^](https://zhuanlan.zhihu.com/p/133921916#ref_14_0)FThreadSafeCounter https://docs.unrealengine.com/en-US/API/Runtime/Core/HAL/FThreadSafeCounter/index.html
15. [^](https://zhuanlan.zhihu.com/p/133921916#ref_15_0)TQueue https://docs.unrealengine.com/en-US/API/Runtime/Core/Containers/TQueue/index.html
```

`note/UE/UE4 C++基础 - 字符串和本地化.md`:

```md
# UE4 C++基础 - 字符串和本地化

## 概览

UE4内建字符串有3种类型：

- **FString**[[1\]](https://zhuanlan.zhihu.com/p/163587790#ref_1)
- **FName**[[2\]](https://zhuanlan.zhihu.com/p/163587790#ref_2)
- **FText**[[3\]](https://zhuanlan.zhihu.com/p/163587790#ref_3)

最常见的是 **FString** 类型，**FName** 和 **FText** 属于不可变字符串，一经创建其中的内容就无法改变。**FString** 属于**可变**字符串，可以对其常规的字符串操作，如分片，大小写转换等操作，编程时使用较多的也是它。三者之间可以进行相互转换。

**FName** 不区分大小写，主要用于标识资源路径，它的优点就是查找和访问速度快，在游戏开发过程中，如果可以确定字符串是固定不变的数据，如资源路径，或者数据表格原始数据，且无需考虑文本国际化的时候，建议使用FName进行创建。

**FText** 主要用于文本本地化[[4\]](https://zhuanlan.zhihu.com/p/163587790#ref_4)。如今游戏出海已经成为一种趋势，当你的游戏需要支持不止一种语言时，就需要考虑文本本地化，建议最初时就作出这样设定。文本本地化是一项比较复杂的内容，会单独抽出章节讲解，现在需要需要记住的是，当字符串需要显示给玩家时，使用FText比较合适。

## 1. FString[[1\]](https://zhuanlan.zhihu.com/p/163587790#ref_1)

## 创建

> ***注意\*** ***大多数输出函数接收的是 TCHAR\* 类型的指针,因此需要使用 \****

```cpp
#include "GenericPlatform/GenericPlatformMisc.h"

FString TestFString = FString(TEXT("This is my test FString" LINE_TERMINATOR));
FGenericPlatformMisc::LocalPrint(*TestFString); // 输出: // This is my test FString.
```

## 比较

```cpp
FString StringA = FString(TEXT("This is my test FString.\n"));
FString StringB = FString(TEXT("This is my test FString.\n"));
// 直接使用 == 运算符
if (StringA == StringB) { }
// 等价于
if (StringA.Equals(StringB, ESearchCase::CaseSensitive)) { }
// 忽略大小写
if (StringA.Equals(StringB, ESearchCase::IgnoreCase)) { }
// 检测字符串是否以特定字符串开头
if (TestString.StartsWith(TEXT("This"))) { }
// 检测字符串是否以特定字符串结尾
if (TestString.EndsWith(TEXT("FString"))) { }
// 判断字符串是否为空
if (TestString.IsEmpty()) { }
```

## 查找

```cpp
// 查找某个字串是否存在有两种方式
// 1.  FString::Contains(),默认位忽略大小写，从字符串首查找至尾部
FString TestString = FString(TEXT("This is my test FString.\n"));
if (TestString.Contains(TEXT("This"), ESearchCase::IgnoreCase, ESearchDir::FromStart)) { }
// 等价于 2. FString.Find()
if (TestString.Find(TEXT("This"), ESearchCase::IgnoreCase, ESearchDir::FromStart, INDEX_NONE) != INDEX_NONE) { }
```

## 拼接

```cpp
// 直接使用 + 可以拼接2个字符串
FString A = FString(TEXT("A"));
FString B = FString(TEXT("B" LINE_TERMINATOR));
FString Plus = A + B;
FGenericPlatformMisc::LocalPrint(*Plus);

// 如果想在字符串尾部添加字符串，则使用 += 
A += FString(TEXT("C" LINE_TERMINATOR));
FGenericPlatformMisc::LocalPrint(*A);

// 更常见的是使用 FString::Printf() 函数
FString FormatString = FString::Printf(TEXT("FormatString:\n%s%s%s"), *A, *B, *Plus);
FGenericPlatformMisc::LocalPrint(*FormatString);

// 输出
// AB
// AC
// FormatString:
// AC
// B
// AB
```

## 其他常用方法

```cpp
// 逆序
FString MyString = FString(TEXT("123456"));
// 逆序并返回字符串副本
FString ReverseString = MyString.Reverse(); // 654321
// 直接逆序原始字符串
MyString.ReverseString();

// 字符串替换
FString SrcString = FString(TEXT("Apple Orange"));
// 返回替换后的字符串副本
FString ReplaceString = SrcString.Replace(TEXT("Apple"), TEXT("Coffee")); // Coffe Orange
// 直接替换原始字符串
SrcString.ReplaceInline(TEXT("Orange"), TEXT("Banana")); // Apple Banana

// 去除无用字符串
FString QuoteAndSpaceString = FString(TEXT("	\"StringWithEmpty\"  "));
// 返回剔除行首行末空白字符的字符串副本
FString WithoutSpace = QuoteAndSpaceString.TrimStartAndEnd(); // "StringWithEmpty"
// 直接剔除原始字符串的行首行末的空白字符
QuoteAndSpaceString.TrimStartAndEndInline(); // "StringWithEmpty"
// 返回剔除行首行末引号的字符串副本
FString WithoutQuotesString = QuoteAndSpaceString.TrimQuotes(); //StringWithEmpty
// 清空字符串
QuoteAndSpaceString.Empty();
```

## 字符串分片

将字符串按下标拆解为我们需要的字符串称之为***分片(Silce)，\***常用分片函数包含如下几个***：\***

- **FString::Mid**[[5\]](https://zhuanlan.zhihu.com/p/163587790#ref_5)
- **FString::Left**[[6\]](https://zhuanlan.zhihu.com/p/163587790#ref_6)
- **FString::LeftChop**[[7\]](https://zhuanlan.zhihu.com/p/163587790#ref_7)
- **FString::Right**[[8\]](https://zhuanlan.zhihu.com/p/163587790#ref_8)
- **FString::RightChop**[[9\]](https://zhuanlan.zhihu.com/p/163587790#ref_9)

5个函数都接受一个 **Count** 参数，表明要操作的字符串长度，这个长度如果超过字符串本身长度，就会被默认处理为字符串本身长度。其中Left,LeftChop和Right,RightChop可以看做Mid的一种简便写法，具体样例如下：

```cpp
// 字符串分片
FString Str = FString(TEXT("ABCDEFGHIJ"));
// 字符串长度
int32 StringLength = Str.Len();
// 通过下标获取字符
TCHAR Char = Str[0]; // A
// 从左往右截取指定长度的字符串
FString LeftStr = Str.Left(4); // ABCD
// 去除字符串末尾指定的长度字符串
FString LeftChopStr = Str.LeftChop(4); // ABCDEF
// 从右往左截取指定长度的字符串
FString RightStr = Str.Right(4); // GHIJ
// 去除字符串开头指定长度的字符串
FString RightChopStr = Str.RightChop(4); // EFGHIJ
// 从字符串指定位置获取指定长度的字符串
FString MidStr = Str.Mid(2,6);// CDEFGH
```

LeftChop 和 RightChop 这2个函数名歧义较大，硬记即可。如下图所示

![img](https://pic4.zhimg.com/80/v2-48f177aa23a9db44bd73fc364f41d157_720w.webp)

图 1-1 字符串切片

此外还有 ParseIntoArray[[10\]](https://zhuanlan.zhihu.com/p/163587790#ref_10) 函数用于将字符串按分隔符进行拆分

```cpp
// 按指定分割符号进行拆分
FString SplitStr = FString(TEXT("ABC,DEF,GHI,"));
// 保存拆分后的字符串数组
TArray<FString> SplitedStr;
// 最后一个参数 InCullEmtpy 表示是否剔除空字符串
SplitStr.ParseIntoArray(SplitedStr, TEXT(","), false); // ABC DEF GHI Empty
SplitStr.ParseIntoArray(SplitedStr, TEXT(","), true); // ABC DEF GHI
```

## 2. FName[[2\]](https://zhuanlan.zhihu.com/p/163587790#ref_2)

通常用于标识资源路径或者其他几乎不变的字符串，如资源文件类型，或者平台标识等。FName主要是为了性能上的优势。运行时，为了性能最优，应该尽可能的使用FName，只在必要的时候才将FName转换为其他字符串类型。引擎的UObject的就是使用的FName来储存对象名称。

```cpp
// K:\UnrealEngine\Engine\Source\Runtime\CoreUObject\Public\UObject\UObjectBase.h
/** Name of this object */
FName NamePrivate;
```

> 注意：
> FName是不区分大小写的，FString转换至FName时会丢失原始字符串的大小写信息

```cpp
// 创建FName
FName TestFName = FName(TEXT("ThisIsMyTestFName"));
FName TestFNameFromFString = FName(*FString(TEXT("FString")));
// 获取字符串长度
int32 FNameLength = TestFName.GetStringLength(); // 17
// 转换为 FString
FString FStringFromFName = TestFName.ToString();
// 测试字符串是否相等,注意比较是忽略大小写的
if (TestFName == FName(TEXT("thisismytestfname"))) { }
if (TestFName.IsEqual(FName(TEXT("THISISMYTESTFNAME")))) { }
```

## 3. FText[[3\]](https://zhuanlan.zhihu.com/p/163587790#ref_3)

主要用于支持**文本本地化**，本地化[[11\]](https://zhuanlan.zhihu.com/p/163587790#ref_11)是一个较复杂流程，我们这里只在源码层面[[12\]](https://zhuanlan.zhihu.com/p/163587790#ref_12)介绍如何编写可以本地化的代码，其他部分可以参考UE4官方文档。要让我们的C++源码支持本地化，在使用字符串时，必须对所有需要翻译的源码字符串用如下2个宏中的一个进行包裹：

- **NSLOCTEXT**
- **LOCTEXT**

NSLOCTEXT包含3个参数:

- **namespace 命名空间**
- **key 上下文**
- **source string 源文**

一个工程中可以存在多个命名空间，用于区分翻译的不同用途。例如我们可以简单的将要翻译的源码区分为引擎和项目2个命名空间。上下文用于相同的源文在不同的语义下需要翻译成不同的场景。源文则是我们要翻译的原始文本。样例如下：

```cpp
FText constFTextHelloWorld = NSLOCTEXT("MyOtherNamespace","HelloWorld","Hello World!");
```

**LOCTEXT** 可以看做 **NSLOCTEXT** 的一种简便写法，使用 **LOCTEXT** 必须在源文件头定义 **LOCTEXT_NAMESPACE** 宏：

```cpp
// 定义 LOCTEXT 命令空间
// 这个宏只在该源文件中生效，且必须在源文件结尾处取消定义
#define LOCTEXT_NAMESPACE "MyNamespace"
// Create text literals
FText constFTextGoodbyeWorld= LOCTEXT("GoodbyeWorld","Goodbye World!");
// Undefine the namespace before the end of the file
#undef LOCTEXT_NAMESPACE // 注意：必须取消宏定义
```

更多样例可以查看引擎单元测试源码

```cpp
UnrealEngine\Engine\Source\Runtime\Core\Private\Tests\Internationalization\TextTest.cpp
```

## 4. 字符串类型的转换

三种字符串类型之间可以根据需要进行转换，值得注意的是FText并不能直接转换为FName,需要转换为FString之后再转换为FText。FString转换至FName时会丢失原始字符串的大小写信息。FText转换为FString会丢失本地化信息。

```cpp
// 字符串之间的转换
FString SrcStr = FString(TEXT("SrcStr"));
FText SrcText = FText::FromString(*FString(TEXT("SrcText")));
FName SrcName = FName(TEXT("SrcName"));
// FString -> FName
FName NameStr = FName(*SrcStr);
// FString -> FText
FText TextFromString = FText::FromString(SrcStr);
// FName -> FText
FText TextFromName = FText::FromName(NameStr);
// FName -> FString
FString StringFromName = SrcName.ToString();
// FText -> FString
FString StringFromText = SrcText.ToString();
```

三者之间的转换方式如下图：

![img](https://pic1.zhimg.com/80/v2-069231f3f58e2feccecd2c103a6e98d0_720w.webp)

图 1-2 三者字符串类型之间的转换

在使用UE4的过程中，我们不可避免的会与第三方库打交道，这个时候就需要在内建字符串类型与std::string之间进行转换，样例如下：

```cpp
#include <string>
// std::string -> FString
std::string StdString = "ExampleStdString";
FString FStringFromStdString(StdString.c_str());

// FString -> std::string
FString ExampleString = TEXT("FString");
std::string StdStringFromString_ANSI = TCHAR_TO_ANSI(*ExampleString);
std::string StdStringFromString_UTF8 = TCHAR_TO_UTF8(*ExampleString);
```

## 5. UE4正则表达式（待补充）

## 参考

1. ^[a](https://zhuanlan.zhihu.com/p/163587790#ref_1_0)[b](https://zhuanlan.zhihu.com/p/163587790#ref_1_1)FString https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/StringHandling/FString/index.html
2. ^[a](https://zhuanlan.zhihu.com/p/163587790#ref_2_0)[b](https://zhuanlan.zhihu.com/p/163587790#ref_2_1)FName https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/StringHandling/FName/index.html
3. ^[a](https://zhuanlan.zhihu.com/p/163587790#ref_3_0)[b](https://zhuanlan.zhihu.com/p/163587790#ref_3_1)FText https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/StringHandling/FText/index.html
4. [^](https://zhuanlan.zhihu.com/p/163587790#ref_4_0)Text Localization https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html
5. [^](https://zhuanlan.zhihu.com/p/163587790#ref_5_0)FString::Mid https://docs.unrealengine.com/en-US/API/Runtime/Core/Containers/FString/Mid/index.html
6. [^](https://zhuanlan.zhihu.com/p/163587790#ref_6_0)FString::Left https://docs.unrealengine.com/en-US/API/Runtime/Core/Containers/FString/Left/index.html
7. [^](https://zhuanlan.zhihu.com/p/163587790#ref_7_0)FString::LeftChop https://docs.unrealengine.com/en-US/API/Runtime/Core/Containers/FString/LeftChop/index.html
8. [^](https://zhuanlan.zhihu.com/p/163587790#ref_8_0)FString::Right https://docs.unrealengine.com/en-US/API/Runtime/Core/Containers/FString/Right/index.html
9. [^](https://zhuanlan.zhihu.com/p/163587790#ref_9_0)FString::RightChop https://docs.unrealengine.com/en-US/API/Runtime/Core/Containers/FString/RightChop/index.html
10. [^](https://zhuanlan.zhihu.com/p/163587790#ref_10_0)FString::ParseIntoArray https://docs.unrealengine.com/en-US/API/Runtime/Core/Containers/FString/ParseIntoArray/1/index.html
11. [^](https://zhuanlan.zhihu.com/p/163587790#ref_11_0)本地化 https://docs.unrealengine.com/zh-CN/Gameplay/Localization/Overview/index.html
12. [^](https://zhuanlan.zhihu.com/p/163587790#ref_12_0)源码本地化 https://docs.unrealengine.com/zh-CN/Gameplay/Localization/Formatting/index.html
```

`note/UE/UE4 C++基础 - 工程目录结构.md`:

```md
# UE4 C++基础 - 工程目录结构

## 简介

介绍UE4工程目录结构[[1\]](https://zhuanlan.zhihu.com/p/160917246#ref_1)以及常用的目录操作接口[[2\]](https://zhuanlan.zhihu.com/p/160917246#ref_2)。UE4将目录分为：

- **引擎目录**
- **项目目录**

其中一些子目录是两个都有的，称之为**通用目录**，有一些目录是引擎特有的。当我们从github

```text
https://github.com/EpicGames/UnrealEngine.git
```

上检出工程到本地时，起始目录叫做根目录。此外，开发过程中，为了方便起见，资源之间的引用是通过**沙盒路径**（虚拟路径）来进行标识的。

## 根目录

![img](https://pic4.zhimg.com/80/v2-966f91451f1a6f410fdc1aede753298b_720w.webp)

图 1-1 根目录

根目录说明如下：

- **Engine** 引擎目录，包含构成引擎的所有源代码、内容等。

- **Samples** 样例资源。

- **Templates** 样例工程模块，[创建新项目](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/zh-CN/Engine/Basics/Projects/Browser/index.html)时可用的项目模板集合。

- **Setup.bat** 只需运行一次。

- - 拉取引擎的三方依赖
  - 安装引擎运行环境 - 执行Engine\Extras\Redist\en-us\UE4PrereqSetup_x64.exe
  - 引擎注册 - 执行UnrealVersionSelector.exe，让uproject可以被windows识别。

- **GenerateProjectFiles.bat** 用于生成引擎vs工程文件。

Setup 和 GenerateProjectFiles还有对应的 .sh 文件，作用与.bat相同，用于在Mac平台下是生成从xcode工程文件。.command是Mac平台下的一种快捷方式，可以支持双击打开，而不在命令行模式执行。

## 通用目录

一些子目录是在引擎和游戏项目目录之间通用的：

- **Binaries -** 包含可执行文件或编译期间创建的其他文件。

- **Build** - 包含构建引擎或游戏所需的文件，包括创建特定于平台的构建版所需的文件。

- **Config** - 配置文件，用于设置用来控制引擎行为的值。项目Config文件中设置的值会覆盖 Engine\Config 目录中设置的值。

- **Content** - 保存引擎或游戏的内容，包括资源包和贴图。

- **DerivedDataCache** - 包含加载时针对引用内容生成的派生数据文件。引用内容没有相应的缓存文件会导致加载时间显著延长。

- **Intermediate** - 包含构建引擎或游戏时生成的临时文件。在游戏目录中，着色器存储在Intermediate目录中。

- **Saved** - 包含自动保存、配置（.ini）文件和日志文件。此外，Engine\Saved目录还包含崩溃日志、硬件信息和Swarm选项与数据。

- **Source** - 包含引擎或游戏的所有源文件，包括引擎源代码、工具和游戏类等。

- - **Engine** - Engine目录中的源文件组织结构如下：

  - - **Developer** - 编辑器和引擎共同使用的文件。
    - **Editor** - 仅供编辑器使用的文件。
    - **Programs** - 引擎或编辑器使用的外部工具。
    - **Runtime** - 仅供引擎使用的文件。

  - **Game** - 游戏项目源码，建议按模块的方式进行组织。

## 源码模块组织方式

游戏项目目录中的源文件按模块分组，一个模块一个目录。每个模块包含以下内容：

- **Classes** - 包含所有项目头（.h）文件。
- **Private** - 包含所有 `.cpp` 文件，包括游戏类实现文件和模块实现文件。
- **Public** - 包含模块标头文件。

## 引擎Source模块

![img](https://pic1.zhimg.com/80/v2-3e917bff26957763ac5fe5e5d6c97d18_720w.webp)

图 1-2 Engine\Source

引擎Source目录下分为以下目录：

- **Developer** - Editor&Programs会使用，但不能是Games
- **Editor** - 只被Editor使用
- **Programs** - 独立的Applitcations或者工具类
- **Runtime** - Editor,Games,Programs都会使用
- **ThirdParty** - 第三方库

## 模块依赖原则

- **Runtime** 模块不能依赖 **Editor**或者**Developer**中的模块
- **Plug-in** 模块不能依赖其他Plug-ins

![img](https://pic2.zhimg.com/80/v2-12ebbf153a8a5f0cb20702a0b1462c75_720w.webp)

不同类型应用程序的模块使用样例

## 基础模块（新手）

- **Core** - Fundamental core types & functions 基础数据类型和函数
- **CoreUObject** - UObject实现
- **Engine** - Game类以及引擎核心框架
- **OnlineSubsystem** - Online & social networking features
- **Slate** - Widget library & high-level UI features

## 其他几个有趣模块（进阶）

- **DesktopPlatform** – Useful APIs for Windows, Mac & Linux
- **DetailCustomizations** – Editor’s Details panel customizations
- **Launch** – Main loop classes & functions
- **Messaging** – Message passing sub-system
- **Sockets** – Network socket implementations
- **Settings** – Editor & Project Settings API
- **SlateCore** – Fundamental UI functionality
- **TargetPlatform** – Platform abstraction layer
- **UMG** – Unreal Motion Graphics implementation
- **UnrealEd** – Unreal Editor main frame & features
- **Analytics** – Collects usage statistics from Editor & games
- **AssetRegistry** – Database for assets in Unreal Editor
- **GameLiveStreaming** – Twitch Streaming
- **HeadMountedDisplay** – HMD Support API (Oculus, etc.)
- **JsonUtilities & XmlParser** – Handle Json & XML files
- **SourceControl** – API for custom source control providers

## 特定于引擎的目录

![img](https://pic2.zhimg.com/80/v2-f91d4f45c350cb05db5534784611465d_720w.webp)

图 1-3 Engine引擎目录

部分子目录特定于Engine目录。

- **Documentation** - 包含引擎文档，包括源文件和发布的文件。

- - **HTML** - 发布的HTML文档文件。
  - **Source** - 源markdown文档文件。

- **Extras** - 其他帮助和实用程序文件。

- **Plugins** - 包含引擎中使用的插件。

- **Programs** - 包含UE4根目录中存储的项目以及其他虚幻程序（如UnrealFrontend和UnrealHeaderTool）的配置文件和日志文件。

- **Shaders** - 保存引擎的着色器源文件（`.usf`）。

## 游戏项目目录

![img](https://pic1.zhimg.com/80/v2-b1bde76edc9dcd2e4b743f2fea4c9f90_720w.webp)

图 1-4 游戏项目目录

- **Binaries** - 包含可执行文件或编译期间创建的其他文件。
- **Config** - 游戏的默认项目设置。
- **Content** - 包含引擎或游戏的内容，包括资源包和贴图。
- **Plugins** - 包含项目中使用的插件。
- **Intermediate** - 包含UnrealBuildTool生成的文件，如Visual Studio项目文件。这些文件可以删除并重新构建。
- **Saved** - 包含引擎生成的文件，如配置文件和日志。这些文件可以删除并重新构建。
- **Source** - 包含游戏模块对象类文件。
- **EasyUE4.sln** 项目vs工程文件。
- **EasyUE4.uproject** 项目文件。
- **EasyUE4.vs.db** vs分析源码后的数据缓存，可以理解为ctags文件。

## Plugin插件目录

![img](https://pic4.zhimg.com/80/v2-0b129348ca6fdd94a747ff1f0314d5b7_720w.webp)

图 1-5 Plugin插件目录

- **Binaries** - 包含可执行文件或编译期间创建的其他文件。
- **Content** - 包含游戏内用到的插件资源目录。
- **Intermediate** - 包含UnrealBuildTool生成的文件，如Visual Studio项目文件。这些文件可以删除并重新构建。
- **Resources** - 插件额外资源目录，如插件图标。
- **ThirdParty** - 插件依赖的三方库目录。
- **ScriptPlugin.uplugin** 插件文件，包含这个文件的目录会被UE4识别为一个插件目录。

## 沙盒路径

当我们在编辑器状态下浏览资源时，显示的资源路径，通常是**沙盒路径**

![img](https://pic3.zhimg.com/80/v2-fc389106d1de92654feda11a53436fea_720w.webp)

图 1-6 沙盒路径

```text
/Game/ThirdPerson/Meshes/LeftArm_StaticMesh
/Engine/Maps/Entry
```

其中 **/Game** 是一个虚拟路径，实际表示的是项目的 **FPaths::ProjectContentDir() 。/Engine** 也是一个虚拟路径，实际路径是引擎的 **FPaths::EngineContentDir()**。更多虚拟路径可以查阅源码[[3\]](https://zhuanlan.zhihu.com/p/160917246#ref_3)

```text
K:\UnrealEngine\Engine\Source\Runtime\CoreUObject\Private\Misc\PackageName.cpp
```

类 FLongPackagePathsSingleton 的定义。

内容浏览器视图选项勾选显示引擎内容操作如下所示：

![img](https://pic3.zhimg.com/80/v2-c11c2b16bafe834fc834f1e06f9c5cd2_720w.webp)

图 1-7 内容浏览器显示引擎内容

![img](https://pic2.zhimg.com/80/v2-c75ba764f4ab86a0f1bac1b9add89e09_720w.webp)

图 1-8 内容浏览器切换至引擎目录

## 路径获取和操作API

```cpp
#include "BlankProgram.h"

#include "RequiredProgramMainCPPInclude.h"
#include "Misc/Paths.h"

DEFINE_LOG_CATEGORY_STATIC(LogBlankProgram, Log, All);
IMPLEMENT_APPLICATION(BlankProgram, "BlankProgram");

INT32_MAIN_INT32_ARGC_TCHAR_ARGV()
{
GEngineLoop.PreInit(ArgC, ArgV);
UE_LOG(LogBlankProgram, Display, TEXT("Hello World"));

// 常用路径获取接口
UE_LOG(LogBlankProgram, Display, TEXT("EngineDir: %s"), *FPaths::EngineDir());
UE_LOG(LogBlankProgram, Display, TEXT("EngineSavedDir: %s"), *FPaths::EngineSavedDir());
UE_LOG(LogBlankProgram, Display, TEXT("EngineIntermediateDir: %s"), *FPaths::EngineIntermediateDir());
UE_LOG(LogBlankProgram, Display, TEXT("ProjectDir: %s"), *FPaths::ProjectDir());
UE_LOG(LogBlankProgram, Display, TEXT("ProjectContentDir: %s"), *FPaths::ProjectContentDir());
UE_LOG(LogBlankProgram, Display, TEXT("ProjectConfigDir: %s"), *FPaths::ProjectConfigDir());
UE_LOG(LogBlankProgram, Display, TEXT("ProjectSavedDir: %s"), *FPaths::ProjectSavedDir());
UE_LOG(LogBlankProgram, Display, TEXT("ProjectIntermediateDir: %s"), *FPaths::ProjectIntermediateDir());

FString TestFilename(TEXT("ParentDirectory/Directory/FileName.extion"));
FString Extension = FPaths::GetExtension(TestFilename);
FString BaseFilename = FPaths::GetBaseFilename(TestFilename);
FString CleanFilename = FPaths::GetCleanFilename(TestFilename);
FString Directory = FPaths::GetPath(TestFilename);
bool bFileExists = FPaths::FileExists(TestFilename);
bool bDirectoryExists = FPaths::DirectoryExists(Directory);

UE_LOG(LogBlankProgram, Display, TEXT("TestFilename: %s"), *TestFilename);
// 获取文件扩展名
UE_LOG(LogBlankProgram, Display, TEXT("Extension: %s"), *Extension);
// 获取文件名，不带扩展名
UE_LOG(LogBlankProgram, Display, TEXT("BaseFilename: %s"), *BaseFilename);
// 获取文件名，带扩展名
UE_LOG(LogBlankProgram, Display, TEXT("CleanFilename: %s"), *CleanFilename);
// 获取路径文件夹，去除CleanFilename后的路径
UE_LOG(LogBlankProgram, Display, TEXT("Directory: %s"), *Directory);
// 检测文件是否存在
UE_LOG(LogBlankProgram, Display, TEXT("FileExists: %s"), bFileExists ? TEXT("True") : TEXT("False"));
// 检测文件夹是否存在
UE_LOG(LogBlankProgram, Display, TEXT("DirectoryExists: %s"), bDirectoryExists ? TEXT("True") : TEXT("False"));

// 路径拼接
FString NewFilePath = FPaths::Combine(Directory, TEXT("NewFilePath.txt"));
// 简便写法
FString NewFilePathEasy = Directory / TEXT("NewFilePath.txt");
// 相对路径转换为绝对路径
FString FullPath = FPaths::ConvertRelativePathToFull(FPaths::EngineDir());
UE_LOG(LogBlankProgram, Display, TEXT("NewFilePath: %s"), *NewFilePath);
UE_LOG(LogBlankProgram, Display, TEXT("NewFilePathEasy: %s"), *NewFilePathEasy);
UE_LOG(LogBlankProgram, Display, TEXT("FullPath: %s"), *FullPath);

return 0;
}
```

输出

```cpp
LogBlankProgram: Display: Hello World
LogBlankProgram: Display: EngineDir: ../../../Engine/
LogBlankProgram: Display: EngineSavedDir: ../../../Engine/Saved/
LogBlankProgram: Display: EngineIntermediateDir: ../../../Engine/Intermediate/
LogBlankProgram: Display: ProjectDir: ../../../Engine/Programs/BlankProgram/
LogBlankProgram: Display: ProjectContentDir: ../../../Engine/Programs/BlankProgram/Content/
LogBlankProgram: Display: ProjectConfigDir: ../../../Engine/Programs/BlankProgram/Config/
LogBlankProgram: Display: ProjectSavedDir: ../../../Engine/Programs/BlankProgram/Saved/
LogBlankProgram: Display: ProjectIntermediateDir: ../../../Engine/Programs/BlankProgram/Intermediate/
LogBlankProgram: Display: TestFilename: ParentDirectory/Directory/FileName.extion
LogBlankProgram: Display: Extension: extion
LogBlankProgram: Display: BaseFilename: FileName
LogBlankProgram: Display: CleanFilename: FileName.extion
LogBlankProgram: Display: Directory: ParentDirectory/Directory
LogBlankProgram: Display: FileExists: False
LogBlankProgram: Display: DirectoryExists: False
LogBlankProgram: Display: NewFilePath: ParentDirectory/Directory/NewFilePath.txt
LogBlankProgram: Display: NewFilePathEasy: ParentDirectory/Directory/NewFilePath.txt
LogBlankProgram: Display: FullPath: K:/UnrealEngine/Engine/
```



## 参考

1. [^](https://zhuanlan.zhihu.com/p/160917246#ref_1_0)目录结构 https://docs.unrealengine.com/zh-CN/Engine/Basics/DirectoryStructure/index.html
2. [^](https://zhuanlan.zhihu.com/p/160917246#ref_2_0)FPaths https://docs.unrealengine.com/en-US/API/Runtime/Core/Misc/FPaths/index.html
3. [^](https://zhuanlan.zhihu.com/p/160917246#ref_3_0)FPackageName https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/Misc/FPackageName/index.html
```

`note/UE/UE4 C++基础 - 编码规范.md`:

```md
# UE4 C++基础 - 编码规范

## 为什么要学习编码规范？

良好的编码规范不仅利于项目维护，也增加了代码辨识度。使我们在阅读代码时能够更加清晰的理解代码意图。维护编码规范不是一件机械化的工作，它更像是一门艺术，让我们在有限的规范内发挥自己的创造力。除此之外，还有如下几个原因：

- 软件生命周期中80%的时间皆需要维护。
- 原开发者几乎不会对软件进行终身维护。
- 代码规则可提高软件可读性，让工程师更加快速透彻地理解新代码。
- 如决定向模组社区开发者公开源代码，则源代码需要易于理解。
- 交叉编译器兼容性实际上需要此类规则。

详细的编码规范可以参考UE4的官方文档[[1\]](https://zhuanlan.zhihu.com/p/137799980#ref_1)，这里我们只摘录其中有利于初学者阅读代码的部分。

## UE4命名规范

## Pascal命名法

每个单词首字母大写，如 `Health`或 `UPrimitiveComponent` 。变量、方法和类的命名应清楚、明了且进行描述。命名的范围越大，一个良好的描述性命名就越重要。避免过度缩写。所有变量应逐个声明，以便对变量的含义提供注释。其同样被JavaDocs格式需要。变量前可使用多行或单行注释，空白行为分组变量可选使用。

## 类型前缀

**类型名称**前有一个额外的大写字母用于区分不同的类型和普通的变量名。如 FSkin 是个类型名，**Skin** 则是 **FSkin** 的实例。下面是各种前缀以及其含义：

- **T** 表示模板类
- **U** 表示类继承自 UObject
- **A** 表示类继承自 AActor
- **S** 表示类继承自 SWidget
- **I** 表示抽象接口类
- **E** 表示枚举
- **b** 表示布尔值
- **F** 表示其他不满足上述规则的类

## 样例

```cpp
float TeaWeight;
int32 TeaCount;
bool bDoesTeaStink;
FName TeaName;
FString TeaFriendlyName;
UClass* TeaClass;
USoundCue* TeaSound;
UTexture* TeaTexture;
```

## 其他

typedef 应该以与其类型相符的字母为前缀，若为结构体，则使用F；若为UObject则使用U，以此类推。此外，使用模板实例化的类不再是模板，也应该加上相应前缀，如：

```cpp
typedef TArray<FMytype> FArrayOfMyTypes;
```

类型和变量的命名为名词。

方法名是动词，用于描述方法的效果或者无副作用的返回值。

返回布尔的函数应发起true/false的询问，如:

```cpp
IsVisible();
ShouldClearBuffer();
```

若函数参数通过引用传递，同时该值会写入函数，建议以“Out”做为函数参数命名的前缀（非必需）。此操作将明确表明传入该参数的值将被函数替换。

若In或Out参数同样为布尔，以b作为In/Out的前缀，如 `bOutResult`。

返回值的函数应描述返回的值.命名应说明函数将返回的值。此规则对布尔函数极为重要。请参考以下两个范例方法：

```cpp
// True的意义是什么？
bool CheckTea(FTea Tea);

// 命名明确说明茶是新鲜的
bool IsTeaFresh(FTea Tea);
```



## 参考

1. [^](https://zhuanlan.zhihu.com/p/137799980#ref_1_0)Coding Standard https://docs.unrealengine.com/en-US/Programming/Development/CodingStandard/index.html
```

`note/UE/UE4 C++基础 - 资源常见名词解释.md`:

```md
# UE4 C++基础 - 资源常见名词解释

## 背景

由于缺少UE4官方文档对关键概念进行解释，如：

- 什么是Outer？
- Outermost是何含义？
- Package是什么？
- Exporter和Impoter的关系是什么？

该篇文档是根据源码和代码注释，以及一些古老的资料，结合笔者对引擎理解给出的定义，提前理解这些概念，有利于我们更快的学习和阅读源码。如有错误的地方，欢迎指证 ;-) 。

## Object（对象）

所有继承自UObject类并创建的对象都称之为***Object\***。排除通过 new 创建的对象，剩下几乎所有的对象都是Object对象。编辑器中拖动的Actor，蓝图，游戏中各种常见资源如贴图,地图,音频资源等。甚至包括C++源码中通过UClass声明的类，也是Object。不出意外的话，几乎99%的时间都是在和UObject打交道。假想一个FPS游戏中人物死亡的场景，从技术实现角度来讲，这个角色包括：

- 角色骨骼 Skeleton
- 人物材质 MaterialInstanceConstant
- 贴图 Texture2D
- 等等

当角色死亡消失时，我们希望玩家看到的应该是整个角色完整的消失，并不希望将角色这个整体打散对待（例如，剩下一张头像贴图），也不希望把这项清理的工作交给编程人员，要求他们必须硬编码手动释放对象。这应该是一个自然递归的过程。UE4采用组合模式来解决此类问题。

## Outer（父对象）

所有的Object都拥有一个***Outer\***，称之为***父对象\***。每个Object都可以有（至多）一个Outer（父UObject），且可以拥有任意数量的子Object，换句话说，每个子对象的类型必须是UObject或者必须派生自UObject，每个Object将自身的Outer储存在OuterPrivate信息中，子对象的信息则是构建Object调用AddObject函数，通过全局的FUObjectHashTables 来储存的。除了自举时（bootstrapping）创建的UObject，所有其他的UObject在创建时都会调用AddObject将自身添加进全局表。

```cpp
// Add to global table.
AddObject(InName, InInternalFlags);
```

全局表由以下几张子表组成：

```cpp
/** Hash sets */
TMap<int32, FHashBucket> Hash; // 全局Hash表，可以通过对象名称查找到对应的对象
TMultiMap<int32, class UObjectBase*> HashOuter; // Outer对象表，可以通过Hash值查找到对应的Outer

/** Map of object to their outers, used to avoid an object iterator to find such things. **/
TMap<UObjectBase*, FHashBucket> ObjectOuterMap; // 子对象表，可以查询任意对象的子对象
TMap<UClass*, TSet<UObjectBase*> > ClassToObjectListMap; // 类型表，可以通过类型查找对应的对象
TMap<UClass*, TSet<UClass*> > ClassToChildListMap; // ？？还没理解到用途
```

## Package（包）[[1\]](https://zhuanlan.zhihu.com/p/152201635#ref_1)

UE4中的Package是一个抽象的概念，一个Package是一个文件（.uasset或者.umap），它包含一些可以UE4进行操作和访问的二进制数据文件。Package包含了各种各样的游戏资源，包括

- 贴图 Textures
- 静态网格物体 static meshes
- 骨架网格物体 skeletal meshes
- 物理资源 physics assets
- UI场景 等等...

凡是可以添加进游戏引擎的文件，都可以包含进Package，反之也成立。一个Object一定属于某一个Package，Object的Package名称称之为**PackageName**。路径形式如下

```text
/Engine/EngineDamageTypes/DmgTypeBP_Environmental
```

对象之间可以存在引用关系（例如，材质依赖于贴图）。

- **Exports** （导出资源）表示存在于该包中的对象。
- **Imports**（导入资源）表示对其他包对象的引用。

例如：如果包Ａ中有一个材质 MatX，并且它引用包A中的TexY和包B中的TexZ，则关系如下所示：

```ada
Package A:
    Exports:
          MatX
          TexY
    Imports:
          B.TexZ

Package B:
    Exports:
          TexZ
```

当我们在编辑器或者游戏中加载Package时，它会加载引用Package中的objects来解决引用关系。但是并不会加载引用Package中的所有objects。仅从引用包中必须加载的objects。

**关卡**（***Levels\***）是一种特殊的资源。关卡不包含具体的资源，它只包含Package中的资源引用。这样可以允许多个关卡来共享资源，并允许美术工作人员仅需将包文件中的资源改变一次，所有引用该资源的关卡将会自动地进行更新。

## **Package Types（包类型）**

包可以有不同的扩展名，但是它们在内部是完全一致的。虚幻引擎只关心包中的内容，而不包含任何处理特定扩展名的特殊情况。 然而，通用命名习惯：

- uasset 通用资源扩展名
- umap 关卡地图默认扩展名

## Groups（组）

包可以包含多层的组。可以把它们想象成您硬盘上文件结构中的子目录。 这些组的使用完全是为了使人们可以搞清包内容的意思；引擎不会关心您是否使用这些组。UE4支持多层次的组结构；但是，尽管您可以按照您的意愿设计组层次的深度，但通常推荐最多建立 3 或 4 层。否则，当使用内容浏览器包的树结构时，它将会变得特别不实用。以下是使用多个组来组织装甲资源的例子：

![img](https://pic4.zhimg.com/80/v2-acaf796218aa7567df62cb3ada487acf_720w.webp)

这个例子中的包是Pickups（可能在硬盘的Pickups.uasset中）。包内可能有很多组用于组织它内部的资源。比如，假设这个选中的资源，获得指定资源的路径是`Pickups.Armor.Materials`。类似于访问硬盘（"C:\Pickups\Armor\Materials"）。每个组都可以包含资源，就像目录可以包含文件一样。

## 资源路径格式名称和转换函数[[2\]](https://zhuanlan.zhihu.com/p/152201635#ref_2)

各种路径的格式如下所示:

```ada
ObjectPath: /Engine/EngineDamageTypes/DmgTypeBP_Environmental.DmgTypeBP_Environmental
PackageName: /Engine/EngineDamageTypes/DmgTypeBP_Environmental
ObjectName: DmgTypeBP_Environmental
Filename: ../../../Engine/Content/EngineDamageTypes/DmgTypeBP_Environmental
PackagePath: /Engine/EngineDamageTypes
ShortName: DmgTypeBP_Environmental
AssetName: DmgTypeBP_Environmental
AssetPackageExtension: .uasset
MapPackageExtension: .umap
```

路径转换函数代码

```cpp
// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.
#include "BlankProgram.h"
#include "RequiredProgramMainCPPInclude.h"
#include "Misc/PackageName.h"

DEFINE_LOG_CATEGORY_STATIC(LogBlankProgram, Log, All);
IMPLEMENT_APPLICATION(BlankProgram, "BlankProgram");

INT32_MAIN_INT32_ARGC_TCHAR_ARGV() {
GEngineLoop.PreInit(ArgC, ArgV);

FString ObjectPath = TEXT("/Engine/EngineDamageTypes/DmgTypeBP_Environmental.DmgTypeBP_Environmental");
FString PackageName = FPackageName::ObjectPathToPackageName(ObjectPath);
FString ObjectName = FPackageName::ObjectPathToObjectName(ObjectPath);
FString Filename = FPackageName::LongPackageNameToFilename(PackageName);
FString PackageName2 = FPackageName::FilenameToLongPackageName(Filename);
FString PackagePath = FPackageName::GetLongPackagePath(PackageName);
FString ShortName = FPackageName::GetLongPackageAssetName(PackageName);
FString AssetName = FPackageName::GetShortName(PackageName);
FString AssetPackageExtension = FPackageName::GetAssetPackageExtension();
FString MapPackageExtension = FPackageName::GetMapPackageExtension();

UE_LOG(LogBlankProgram, Display, TEXT("ObjectPath: %s"), *ObjectPath);
UE_LOG(LogBlankProgram, Display, TEXT("PackageName: %s"), *PackageName);
UE_LOG(LogBlankProgram, Display, TEXT("ObjectName: %s"), *ObjectName);
UE_LOG(LogBlankProgram, Display, TEXT("Filename: %s"), *Filename);
UE_LOG(LogBlankProgram, Display, TEXT("PackagePath: %s"), *PackagePath);
UE_LOG(LogBlankProgram, Display, TEXT("ShortName: %s"), *ShortName);
UE_LOG(LogBlankProgram, Display, TEXT("AssetName: %s"), *AssetName);
UE_LOG(LogBlankProgram, Display, TEXT("AssetPackageExtension: %s"), *AssetPackageExtension);
UE_LOG(LogBlankProgram, Display, TEXT("MapPackageExtension: %s"), *MapPackageExtension);

return 0;
}
```

输出如下

```abap
ObjectPath: /Engine/EngineDamageTypes/DmgTypeBP_Environmental.DmgTypeBP_Environmental
PackageName: /Engine/EngineDamageTypes/DmgTypeBP_Environmental
ObjectName: DmgTypeBP_Environmental
Filename: ../../../Engine/Content/EngineDamageTypes/DmgTypeBP_Environmental
PackagePath: /Engine/EngineDamageTypes
ShortName: DmgTypeBP_Environmental
AssetName: DmgTypeBP_Environmental
AssetPackageExtension: .uasset
MapPackageExtension: .umap
```

## AssetRegistry 资源管理器[[3\]](https://zhuanlan.zhihu.com/p/152201635#ref_3)

UE4编辑器模式是通过AssetRegistry对所有的资源进行管理的，加载方式如下所示

```cpp
FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>("AssetRegistry");
TArray<FAssetData> AssetData;
const UClass* Class = UStaticMesh::StaticClass();
AssetRegistryModule.Get().GetAssetsByClass(Class, AssetData);
```

其返回的AssetData原型如下，里面包含了各种路径名称的详细解释

```cpp
struct FAssetData {
/** The object path for the asset in the form PackageName.AssetName. Only top level objects in a package can have AssetData */
UPROPERTY(BlueprintReadOnly, Category=AssetData, transient)
FName ObjectPath;
/** The name of the package in which the asset is found, this is the full long package name such as /Game/Path/Package */
UPROPERTY(BlueprintReadOnly, Category=AssetData, transient)
FName PackageName;
/** The path to the package in which the asset is found, this is /Game/Path with the Package stripped off */
UPROPERTY(BlueprintReadOnly, Category=AssetData, transient)
FName PackagePath;
/** The name of the asset without the package */
UPROPERTY(BlueprintReadOnly, Category=AssetData, transient)
FName AssetName;
/** The name of the asset's class */
UPROPERTY(BlueprintReadOnly, Category=AssetData, transient)
FName AssetClass;
/** The map of values for properties that were marked AssetRegistrySearchable or added by GetAssetRegistryTags */
FAssetDataTagMapSharedView TagsAndValues;
/** The IDs of the chunks this asset is located in for streaming install.  Empty if not assigned to a chunk */
TArray<int32> ChunkIDs;
/** Asset package flags */
uint32 PackageFlags;
}
```



## 参考

1. [^](https://zhuanlan.zhihu.com/p/152201635#ref_1_0)Unreal Packages https://docs.unrealengine.com/udk/Three/UnrealPackages.html
2. [^](https://zhuanlan.zhihu.com/p/152201635#ref_2_0)FPackageName https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/Misc/FPackageName/index.html
3. [^](https://zhuanlan.zhihu.com/p/152201635#ref_3_0)Asset Registry https://docs.unrealengine.com/en-US/Programming/Assets/Registry/index.html
```

`note/UE/UE4 UObject解析.md`:

```md
# UE4 UObject解析

## 前言

UE4中所有引擎对象都是继承自UObject，UObject提供了UE4的反射系统，序列化，网络拷贝,,GC等功能，理解UObject对学习UE4和运用UE4至关重要，本文从源码角度出发，结合常用的设计模式讲解UObject，并对一些引擎里面一些常见的概念给出一个合理的解释（官方文档并没有提及的部分）。

## 1. Outer

所有Uobject对象初始化时候需要一个Outer参数，这个参数官方没有给出任何解释，通过阅读源码，我们可以将这个Outer理解为父对象，组合模式的一种实现方式。

每个UObject都可以有（至多）一个Outer（父UObject），且可以拥有任意数量的子UObject，换句话说，每个子对象的类型必须是UObject或者必须派生子UObject，每个UObject将自身的Outer储存在OuterPrivate信息中，子对象的信息则是通过构建时调用AddObject函数，通过全局的FUObjectHashTables 来储存的。

除了自举时创建的UObject，所有其他的UObject在创建时都会调用AddObject将自身添加进全局表.

```cpp
// Add to global table.
AddObject(InName, InInternalFlags);
```

全局表由如下几张子表构成

```cpp
/** Hash sets */
TMap<int32, FHashBucket> Hash; // 全局Hash表，可以通过对象名称查找到对应的对象
TMultiMap<int32, class UObjectBase*> HashOuter; // Outer对象表，可以通过Hash值查找到对应的Outer

/** Map of object to their outers, used to avoid an object iterator to find such things. **/
TMap<UObjectBase*, FHashBucket> ObjectOuterMap; // 子对象表，可以查询任意对象的子对象
TMap<UClass*, TSet<UObjectBase*> > ClassToObjectListMap; // 类型表，可以通过类型查找对应的对象
TMap<UClass*, TSet<UClass*> > ClassToChildListMap; // ？？还没理解到用途
```

添加代码如下所示

```cpp
void HashObject(UObjectBase* Object){
 SCOPE_CYCLE_COUNTER( STAT_Hash_HashObject );
 FName Name = Object->GetFName();
 if (Name != NAME_None) {
  int32 Hash = 0;
  auto& ThreadHash = FUObjectHashTables::Get(); // 多线程单例
  FHashTableLock HashLock(ThreadHash);
  Hash = GetObjectHash(Name);
  // if it already exists, something is wrong with the external code				
  checkSlow(!ThreadHash.PairExistsInHash(Hash, Object));  
  ThreadHash.AddToHash(Hash, O
bject); // <=============== 添加进全局表
  Hash = GetObjectOuterHash( Name, (PTRINT)Object->GetOuter() );
  // if it already exists, something is wrong with the external code
  checkSlow( !ThreadHash.HashOuter.FindPair( Hash, Object ) ); 
  ThreadHash.HashOuter.Add( Hash, Object );
  AddToOuterMap( ThreadHash, Object ); // <===============  完成Outer映射的添加
  AddToClassMap( ThreadHash, Object ); // <===============  完成类型的添加
 }
}
```

通过Outer我们可以非常容易的完成对象的生命周期管理。

组合模式（COMPOSITE）用于将对象组合树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。通过组合模式，我们可以很方便的管理UObject。目前还没有看到这样做的优势，后面再解释。

## UObjectBase

UObject 继承至 UObjectBaseUtility, UObjectBaseUtility 又继承至 UObjectBase。2个父类分别封装了不同的信息。UObjectBase关键的成员信息：

```cpp
/** Flags used to track and report various object states. 
This needs to be 8 byte aligned on 32-bit platforms to reduce memory waste */
EObjectFlags ObjectFlags;
/** Index into GObjectArray...very private. */
int32 InternalIndex;
/** Class the object belongs to. */
UClass*	ClassPrivate;
/** Name of this object */
FName NamePrivate;
/** Object this object resides in. */
UObject* OuterPrivate;
```

下面分别讲解各个字段的作用

- NamePrivate 对象名称，所有的对象有一个名称，用于标识该对象的来源。
- InternalIndex 对象在 GObjectArray 中的下标，object创建后都会添加进全局数组
- ObjectFlags 对象标记
- ClassPrivate 对象所属的类
- OuterPrivate 对象的Outer（父对象）

对象标记，用于标记object实例，RF缩写写可以理解为 ***RuntimeFlag\***

```cpp
// Do not add new flags unless they truly belong here. There are alternatives.
// if you change any the bit of any of the RF_Load flags, then you will need legacy serialization
RF_NoFlags		// 无标记 used to avoid a cast

// This first group of flags mostly has to do with what kind of object it is. Other than transient, these are the persistent object flags.
// The garbage collector also tends to look at these.
RF_Public		// 对象是否可以被其他Package中的对象引用
RF_Standalone		// 编辑器对象，即使没有被引用也不会被GC
RF_MarkAsNative		// 对象如UField在构造阶段会被标记为原始对象
RF_Transactional	// Object is transactional.
RF_ClassDefaultObject	// 类的默认对象
RF_ArchetypeObject	// 其他对象的模板对象，可以看做类的默认对象
RF_Transient		// 临时对象，不会被保存和序列化

// This group of flags is primarily concerned with garbage collection.
RF_MarkAsRootSet	// 对象被添加进根集合，即使没有被引用也不会被GC
RF_TagGarbageTemp	// This is a temp user flag for various utilities that need to use the garbage collector. The garbage collector itself does not interpret it.

// The group of flags tracks the stages of the lifetime of a uobject
// 这些标记用于标记对象生命周期的各个阶段
RF_NeedInitialization	// 对象还没有完成初始化，FObjectInitializer 析构之后这个标记会被清除
RF_NeedLoad		 // 加载阶段，说明这个对象需要被加载
RF_KeepForCooker	  // Cook阶段标记改对象不可被GC， 因为还有其他Cooker在使用
RF_NeedPostLoad		  // 对象需要后加载
RF_NeedPostLoadSubobjects // During load, indicates that the object still needs to instance subobjects and fixup serialized component references
RF_NewerVersionExists	 // Object has been consigned to oblivion due to its owner package being reloaded, and a newer version currently exists
RF_BeginDestroyed	 // 标记该对象BeginDestroy函数已经被调用
RF_FinishDestroyed	 // 标记该对象FinishDestroy函数已经被调用

// Misc. Flags
RF_BeingRegenerated      // Flagged on UObjects that are used to create UClasses (e.g. Blueprints) while they are regenerating their UClass on load (See FLinkerLoad::CreateExport())
RF_DefaultSubObject      // subobjects标记，说明他们是默认对象
RF_WasLoaded	         // 对象已经被加载
RF_TextExportTransient	// Do not export object to text form (e.g. copy/paste). Generally used for sub-objects that can be regenerated from data in their parent object.
RF_LoadCompleted	// 对象已经被linkerload完整序列化过至少一次  DO NOT USE THIS FLAG, It should be replaced with RF_WasLoaded.
RF_InheritableComponentTemplate // Archetype of the object can be in its super class
RF_DuplicateTransient    // 对象不可被复制 (如copy/paste, binary duplication, etc.)
RF_StrongRefOnFrame	 // References to this object from persistent function frame are handled as strong ones.
RF_NonPIEDuplicateTransient // Object should not be included for duplication unless it's being duplicated for a PIE session
RF_Dynamic               // 域标记，静态初始化阶段不会被初始哈，可以被构造多次
RF_WillBeLoaded          // 该对象是在加载过程中构造的，将在不久后加载
```



UObject对象并不是直接创建的，而是分成两步，

1. 分配内存
2. 执行初始化UObjectBase
3. UObject 使用 StaticAllocateObject 进行初始化

```cpp
UObject* StaticAllocateObject
(
	UClass*			InClass,
	UObject*		InOuter,
	FName			InName,
	EObjectFlags	InFlags,
	EInternalObjectFlags InternalSetFlags,
	bool bCanRecycleSubobjects,
	bool* bOutRecycledSubobject
)
{
// ...
	if( Obj == NULL )
	{	
		int32 Alignment	= FMath::Max( 4, InClass->GetMinAlignment() );
                // 分配内存
		Obj = (UObject *)GUObjectAllocator.AllocateUObject(TotalSize,Alignment,GIsInitialLoad);
	}
// ...
	if (!bSubObject)
	{
		FMemory::Memzero((void *)Obj, TotalSize);
                // 在已经分配好的内存上进行初始化操作
		new ((void *)Obj) UObjectBase(InClass, InFlags|RF_NeedInitialization, InternalSetFlags, InOuter, InName);
	}
}
```



## 类对象初始化

几个关键的宏

```cpp
// 声明一个类,所有继承至 UObject 的类都会带有这个宏，用来申明一些必备的函数
#define DECLARE_CLASS( TClass, TSuperClass, TStaticFlags, TStaticCastFlags, TPackage, TRequiredAPI  ) \
private: \
    TClass& operator=(TClass&&);   \
    TClass& operator=(const TClass&);   \
	TRequiredAPI static UClass* GetPrivateStaticClass(); \
public: \
	/** Bitwise union of #EClassFlags pertaining to this class.*/ \
	enum {StaticClassFlags=TStaticFlags}; \
	/** Typedef for the base class ({{ typedef-type }}) */ \
	typedef TSuperClass Super;\
	/** Typedef for {{ typedef-type }}. */ \
	typedef TClass ThisClass;\
	/** Returns a UClass object representing this class at runtime */ \
	/** 这里返回一个 UClass的object，表明这个对象所属的类 */ \
	inline static UClass* StaticClass() \
	{ \
		return GetPrivateStaticClass(); \
	} \
	/** Returns the package this class belongs in */ \
	inline static const TCHAR* StaticPackage() \
	{ \
		return TPackage; \
	} \
	/** Returns the static cast flags for this class */ \
	inline static EClassCastFlags StaticClassCastFlags() \
	{ \
		return TStaticCastFlags; \
	} \
	/** For internal use only; use StaticConstructObject() to create new objects. */ \
	inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags) \
	{ \
		return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags); \
	} \
	/** For internal use only; use StaticConstructObject() to create new objects. */ \
	inline void* operator new( const size_t InSize, EInternal* InMem ) \
	{ \
		return (void*)InMem; \
	}
```



```cpp
/**
 * Helper template to call the default constructor for a class
 */
template<class T>
void InternalConstructor( const FObjectInitializer& X ) { 
 T::__DefaultConstructor(X);
}

// 每个类都会默认生成 __DefaultConstructor
#define DEFINE_DEFAULT_CONSTRUCTOR_CALL(TClass) \
static void __DefaultConstructor(const FObjectInitializer& X) { new((EInternal*)X.GetObj())TClass(); }

#define DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(TClass) \
static void __DefaultConstructor(const FObjectInitializer& X) { new((EInternal*)X.GetObj())TClass(X); }

// Register a class at startup time.
#define IMPLEMENT_CLASS(TClass, TClassCrc) \
/* 这里利用了静态变量在main函数执行前会完成初始化的特性，从而完成了所有类信息的注册 */ \
static TClassCompiledInDefer<TClass> AutoInitialize##TClass(TEXT(#TClass), sizeof(TClass), TClassCrc); \
UClass* TClass::GetPrivateStaticClass() \
{ \
static UClass* PrivateStaticClass = NULL; \
if (!PrivateStaticClass) \
{ \
/* this could be handled with templates, but we want it external to avoid code bloat */ \
GetPrivateStaticClassBody( \
	StaticPackage(), \
	(TCHAR*)TEXT(#TClass) + 1 + ((StaticClassFlags & CLASS_Deprecated) ? 11 : 0), \
	PrivateStaticClass, \
	StaticRegisterNatives##TClass, \
	sizeof(TClass), \
	(EClassFlags)TClass::StaticClassFlags, \
	TClass::StaticClassCastFlags(), \
	TClass::StaticConfigName(), \
         /* 这里会传递__DefaultConstructor 函数指针 */ \
	(UClass::ClassConstructorType)InternalConstructor<TClass>, \
	(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>, \
	&TClass::AddReferencedObjects, \
	&TClass::Super::StaticClass, \
	&TClass::WithinClass::StaticClass \
); \
} \
return PrivateStaticClass; \
}

// Used for intrinsics, this sets up the boiler plate, plus an initialization singleton, which can create properties and GC tokens
// 引擎启动时就必须初始化的几个类型
#define IMPLEMENT_INTRINSIC_CLASS(TClass, TRequiredAPI, TSuperClass, TSuperRequiredAPI, TPackage, InitCode) \
IMPLEMENT_CLASS(TClass, 0) \
TRequiredAPI UClass* Z_Construct_UClass_##TClass(); \
UClass* Z_Construct_UClass_##TClass() \
{ \
	static UClass* Class = NULL; \
	if (!Class) \
	{ \
		extern TSuperRequiredAPI UClass* Z_Construct_UClass_##TSuperClass(); \
		UClass* SuperClass = Z_Construct_UClass_##TSuperClass(); \
		Class = TClass::StaticClass(); \
		UObjectForceRegistration(Class); \
		check(Class->GetSuperClass() == SuperClass); \
		InitCode \
		Class->StaticLink(); \
	} \
	check(Class->GetClass()); \
	return Class; \
} \
static FCompiledInDefer Z_CompiledInDefer_UClass_##TClass(Z_Construct_UClass_##TClass, &TClass::StaticClass, TEXT(TPackage), TEXT(#TClass), false);
```

类初始化的函数

```cpp
COREUOBJECT_API void GetPrivateStaticClassBody(
	const TCHAR* PackageName,
	const TCHAR* Name,
	UClass*& ReturnClass,
	void(*RegisterNativeFunc)(),
	uint32 InSize,
	EClassFlags InClassFlags,
	EClassCastFlags InClassCastFlags,
	const TCHAR* InConfigName,
	UClass::ClassConstructorType InClassConstructor,
	UClass::ClassVTableHelperCtorCallerType InClassVTableHelperCtorCaller,
	UClass::ClassAddReferencedObjectsType InClassAddReferencedObjects,
	UClass::StaticClassFunctionType InSuperClassFn,
	UClass::StaticClassFunctionType InWithinClassFn,
	bool bIsDynamic = false) {
if (!bIsDynamic) {
// placement new，先获取已经分配的内存
ReturnClass = (UClass*)GUObjectAllocator.AllocateUObject(sizeof(UClass), alignof(UClass), true);
// 然后初始化数据
ReturnClass = ::new (ReturnClass) UClass(
	EC_StaticConstructor,
	Name,
	InSize,
	InClassFlags,
	InClassCastFlags,
	InConfigName,
	EObjectFlags(RF_Public | RF_Standalone | RF_Transient | RF_MarkAsNative | RF_MarkAsRootSet),
	InClassConstructor,
	InClassVTableHelperCtorCaller,
	InClassAddReferencedObjects);
	check(ReturnClass);
}

// 然后初始化私有类
InitializePrivateStaticClass( InSuperClassFn(), ReturnClass, InWithinClassFn(), PackageName, Name );

// Register the class's native functions.
// 调用每个类的 __DefaultConstructor 原型如下，通过 FObjectInitializer 获取到其对象
// static void __DefaultConstructor(const FObjectInitializer& X) { 
//   new((EInternal*)X.GetObj())TClass(); 
// }

RegisterNativeFunc();
}
```

InitializePrivateStaticClass 函数实现

```cpp
/**
 * Shared function called from the various InitializePrivateStaticClass functions generated my the IMPLEMENT_CLASS macro.
 */
COREUOBJECT_API void InitializePrivateStaticClass(
	class UClass* TClass_Super_StaticClass,
	class UClass* TClass_PrivateStaticClass,
	class UClass* TClass_WithinClass_StaticClass,
	const TCHAR* PackageName,
	const TCHAR* Name
	) {
NotifyRegistrationEvent(PackageName, Name, ENotifyRegistrationType::NRT_Class, ENotifyRegistrationPhase::NRP_Started);

/* No recursive ::StaticClass calls allowed. Setup extras. */
if (TClass_Super_StaticClass != TClass_PrivateStaticClass) {
	TClass_PrivateStaticClass->SetSuperStruct(TClass_Super_StaticClass);
}
else {
	TClass_PrivateStaticClass->SetSuperStruct(NULL);
}
TClass_PrivateStaticClass->ClassWithin = TClass_WithinClass_StaticClass;

// Register the class's dependencies, then itself.
TClass_PrivateStaticClass->RegisterDependencies();
if (!TClass_PrivateStaticClass->HasAnyFlags(RF_Dynamic)){
	// Defer 这里完成包名和类的注册,这2个名字是反的！！！！
	TClass_PrivateStaticClass->Register(PackageName, Name);
} else {
	// Register immediately (don't let the function name mistake you!)
        // 立即创建，并将其加入到全局 UObjectArray中
	TClass_PrivateStaticClass->DeferredRegister(UDynamicClass::StaticClass(), PackageName, Name);
}
NotifyRegistrationEvent(PackageName, Name, ENotifyRegistrationType::NRT_Class, ENotifyRegistrationPhase::NRP_Finished);
}
```

先看DeferredRegister原型，这个函数直接将对应的静态类转变为真正的类对象

```cpp
/**
 * 将 自举阶段注册的类转变为真正的类对象，添加进全局表等
 * Convert a boot-strap registered class into a real one, add to uobject array, etc
 * 
 * @param UClassStaticClass Now that it is known, fill in UClass::StaticClass() as the class
 */
void UObjectBase::DeferredRegister(UClass *UClassStaticClass,
const TCHAR* PackageName,
const TCHAR* InName) {
check(Internal::GObjInitialized);
// Set object properties.
UPackage* Package = CreatePackage(nullptr, PackageName);
check(Package);
Package->SetPackageFlags(PKG_CompiledIn);
OuterPrivate = Package;

check(UClassStaticClass);
check(!ClassPrivate);
ClassPrivate = UClassStaticClass;

// Add to the global object table.
AddObject(FName(InName), EInternalObjectFlags::None);

// Make sure that objects disregarded for GC are part of root set.
check(!GUObjectArray.IsDisregardForGC(this) || GUObjectArray.IndexToObject(InternalIndex)->IsRootSet());
}
```

Register原型是采用的延迟注册，先注册，然后统一再调用 DeferredRegister 进行生成

```cpp
/** Enqueue the registration for this object. */
void UObjectBase::Register(const TCHAR* PackageName,const TCHAR* InName){
TMap<UObjectBase*, FPendingRegistrantInfo>& PendingRegistrants = FPendingRegistrantInfo::GetMap();

FPendingRegistrant* PendingRegistration = new FPendingRegistrant(this);
PendingRegistrants.Add(this, FPendingRegistrantInfo(InName, PackageName));
if(GLastPendingRegistrant){
	GLastPendingRegistrant->NextAutoRegister = PendingRegistration;
} else{
	check(!GFirstPendingRegistrant);
	GFirstPendingRegistrant = PendingRegistration;
}
GLastPendingRegistrant = PendingRegistration;
}
```

注册的 类 对象会在 函数中弹出

```cpp
/**
 * Process the auto register objects adding them to the UObject array
 */
static void UObjectProcessRegistrants(){
check(UObjectInitialized());
// Make list of all objects to be registered.
TArray<FPendingRegistrant> PendingRegistrants;
DequeuePendingAutoRegistrants(PendingRegistrants);

for(int32 RegistrantIndex = 0;RegistrantIndex < PendingRegistrants.Num();++RegistrantIndex){
	const FPendingRegistrant& PendingRegistrant = PendingRegistrants[RegistrantIndex];
        // 这里重新调用立即注册函数
	UObjectForceRegistration(PendingRegistrant.Object);
	check(PendingRegistrant.Object->GetClass()); // should have been set by DeferredRegister
	// Register may have resulted in new pending registrants being enqueued, so dequeue those.
	DequeuePendingAutoRegistrants(PendingRegistrants);
 }
}
```

UObjectProcessRegistrants函数被 UObjectBaseInit 函数调用，最后由 StaticUObjectInit

```cpp
//
// Init the object manager and allocate tables.
//
void StaticUObjectInit() {
UObjectBaseInit();

// Allocate special packages.
GObjTransientPkg = NewObject<UPackage>(nullptr, TEXT("/Engine/Transient"), RF_Transient);
GObjTransientPkg->AddToRoot();

if( FParse::Param( FCommandLine::Get(), TEXT("VERIFYGC") ) ) {
	GShouldVerifyGCAssumptions = true;
}
if( FParse::Param( FCommandLine::Get(), TEXT("NOVERIFYGC") ) ) {
	GShouldVerifyGCAssumptions = false;
}

UE_LOG(LogInit, Log, TEXT("Object subsystem initialized") );
}
```

InitUObject函数调用

```cpp
void InitUObject() { StaticUObjectInit(); }
```

最后在启动 模块时 由模块启动函数调用

```cpp
virtual void StartupModule() override{
// 注册所有的类信息
// Register all classes that have been loaded so far. This is required for CVars to work.		
UClassRegisterAllCompiledInClasses();

void InitUObject();
FCoreDelegates::OnInit.AddStatic(InitUObject);
}
```



## 类信息注册函数

```cpp
/** Register all loaded classes */
void UClassRegisterAllCompiledInClasses() {
	TArray<FFieldCompiledInInfo*>& DeferredClassRegistration = GetDeferredClassRegistration();
	for (const FFieldCompiledInInfo* Class : DeferredClassRegistration) {
		UClass* RegisteredClass = Class->Register();
        }
	DeferredClassRegistration.Empty();
}
```

GetDeferredClassRegistration函数原型

```text
// 返回一个静态变量，注册完毕后会被清零
/** Classes loaded with a module, deferred until we register them all in one go */
static TArray<FFieldCompiledInInfo*>& GetDeferredClassRegistration()
{
	static TArray<FFieldCompiledInInfo*> DeferredClassRegistration;
	return DeferredClassRegistration;
}
```

DeferredClassRegistration 静态信息是通过静态变量会在Main函数执行之前完成初始化的原理进行，进行统一初始化的

```cpp
void UClassCompiledInDefer(
 FFieldCompiledInInfo* ClassInfo,
 const TCHAR* Name,
 SIZE_T ClassSize,
 uint32 Crc) {
const FName CPPClassName = Name;
// We will either create a new class or update the static class pointer of the existing one
GetDeferredClassRegistration().Add(ClassInfo);
}
```

静态变量申明

```cpp
/**
 * Specialized version of the deferred class registration structure.
 */
template <typename TClass>
struct TClassCompiledInDefer : public FFieldCompiledInInfo {
        // 静态变量的构造函数 在Main函数执行前就会初始化，所以这里会被提前调用
	TClassCompiledInDefer(const TCHAR* InName, SIZE_T InClassSize, uint32 InCrc)
	: FFieldCompiledInInfo(InClassSize, InCrc) {
		UClassCompiledInDefer(this, InName, InClassSize, InCrc);
	}
	virtual UClass* Register() const override {
		return TClass::StaticClass();
	}
	virtual const TCHAR* ClassPackage() const override {
		return TClass::StaticPackage();
	}
};
```

回到 IMPLEMENT_CLASS 宏

```cpp
// Register a class at startup time.
#define IMPLEMENT_CLASS(TClass, TClassCrc) \
	static TClassCompiledInDefer<TClass> AutoInitialize##TClass(TEXT(#TClass), sizeof(TClass), TClassCrc); \
```

***AutoInitialize##TClass\*** 这里就是有类的静态变量的定义,定义时即完成了初始化。参考一个实际的例子，下面的代码截取于 UHT 生成的代码

```cpp
IMPLEMENT_CLASS(AgoCharacter, 2070891243);
// 等价于
static TClassCompiledInDefer<AgoCharacter> AutoInitializeAgoCharacter(TEXT("AgoCharacter"), 
sizeof(AgoCharacter),
 2070891243); 
static FCompiledInDefer Z_CompiledInDefer_UClass_AgoCharacter(
  Z_Construct_UClass_AgoCharacter,
 &AgoCharacter::StaticClass,
 TEXT("/Script/go"),
 TEXT("AgoCharacter"),
 false,
 nullptr,
 nullptr,
 nullptr);
```
```

`note/UE/UE4设计模式 - 简介.md`:

```md
# UE4设计模式 - 简介

> 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复的劳动。
> —— Christopher Alexander

## 1. 前言

软件工程就是用来解决现实生活各种重复的劳动，我们通过对现实世界中重复的过程进行建模，转变为计算机可以理解的代码和指令，从而将重复繁琐的工作交由计算机来完成。软件工程可以解决其他领域中重复劳动的问题，但是在开发软件的过程中，也不可避免的会面临一些重复劳动。我们经常会遇到一些相同的问题，每次可能都会从头做起。重复的解决一个问题让我们在面对相同情景的时候会变得游刃有余，但是本身并没有提升，我们还是停留在解决问题上，并没有思考问题的核心原因。设计模式通过将软件开发过程经常遇到的重复问题进行收集分类，并剖析问题的核心原因，系统地记录其解决方案和决策过程，让我们可以透过问题看到变化的本质。**封装变化的概念**，这是许多设计模式的主题。在学习和理解设计模式的过程中，理解其中变化是比较关键的。

新手在学习设计模式的过程中，比较困难的是，由于写的代码量比较少，遇到的问题也不够多，碰巧遇到类似的问题时，可能通过复制粘贴或者冗长的分支语句来解决问题。最后代码里面充斥着大量的重复代码，导致维护起来变得日益困难，新功能的添加也变得越来越难。当他们阅读那些设计优良的代码时，由于没有经历过迭代开发，也很难理解作者为何要这样设计。整个学习过程变得困难起来。**《设计模式-可复用面向对象软件的基础》**正是解决这个问题的关键，通过提前学习和理解那些复用性和灵活性好的设计，这样当我们遇到类似问题时，可以联想到手头的问题是否有对应的设计模式可以解决，并将其应用到实际开发过程中，渐渐地积累起我们的解决方案。**不要重复你自己**，当我们觉察到自己的代码变得越来越重复的时候，记得停下来，认真思考一下，这里是否有更优雅的解决方式。

> Don't repeat yourself [[1\]](https://zhuanlan.zhihu.com/p/141561198#ref_1)

## 2. 为什么要重复讲解一遍设计模式？

因为笔者正从事UE4游戏开发，UE4是一款庞大的工业游戏引擎，所有的设计模式在UE4中都有应用，通过提炼出其中的实际例子可以更深刻的理解UE4引擎和设计模式，相对于《设计模式》书上的已知应用，所有的代码片段都来自UE4引擎实际代码。随着时间的流逝，设计模式中很多模式如今已经成为行业标准了，如 Iterator迭代器。很多书中的设计模式也逐渐变得更加灵活，如Factory Method的演化版本Auto Register Factory。分析实际的代码可以让我们整体上有一个把握，一些具体的实现细节也能够体现出来。

> God is in the detail.

整理和收集这些模式本身也是一个有趣的过程，希望能够对大家学习UE4有所帮助。

Happy Reading! ;-)

## 3. 面向对象设计的原则

- **针对接口编程，而不是针对实现编程**
- **优先使用对象组合，而不是类继承**

## 4. 设计模式所支持的设计的可变方面

![img](https://pic3.zhimg.com/80/v2-0a2c9985300441c08de5059164bf62f2_720w.webp)

图 1-1 设计模式所支持的设计的可变方面

## 5. 目录

## 创建型模式

- [AbstractFactory（抽象工厂）- 未完成](https://zhuanlan.zhihu.com/p/141542546)
- [Builder（生成器）- 未完成](https://zhuanlan.zhihu.com/p/141543218)
- [FactoryMethod（工厂方法）- 未完成](https://zhuanlan.zhihu.com/p/141543355)
- [ProtoType（原型）- 未完成](https://zhuanlan.zhihu.com/p/141543766)
- [Singleton（单件）- 未完成](https://zhuanlan.zhihu.com/p/141546105)

## 结构型模式

- [Adapter（适配器）- 未完成](https://zhuanlan.zhihu.com/p/141546260)
- [Bridge（桥接）- 未完成](https://zhuanlan.zhihu.com/p/141546382)
- [Composite（组合）- 未完成](https://zhuanlan.zhihu.com/p/141546499)
- [Decorator（装饰）- 未完成](https://zhuanlan.zhihu.com/p/141546814)
- [Facade（外观）- 未完成](https://zhuanlan.zhihu.com/p/141546889)
- [Flyweight（享元）- 未完成](https://zhuanlan.zhihu.com/p/141547055)
- [Proxy（代理）- 未完成](https://zhuanlan.zhihu.com/p/141554391)

## 行为模式

- [ChainOfResponsibility（职责链）- 未完成](https://zhuanlan.zhihu.com/p/141554491)
- [Command（命令）- 未完成](https://zhuanlan.zhihu.com/p/141554976)
- [Interpreter（解释器）- 未完成](https://zhuanlan.zhihu.com/p/141555450)
- [Iterator（迭代器）- 未完成](https://zhuanlan.zhihu.com/p/141555550)
- [Mediator（中介者）- 未完成](https://zhuanlan.zhihu.com/p/141555733)
- [Memento（备忘录）- 未完成](https://zhuanlan.zhihu.com/p/141556022)
- [Observer（观察者）- 未完成](https://zhuanlan.zhihu.com/p/141556120)
- [State（状态）- 未完成](https://zhuanlan.zhihu.com/p/141556164)
- [Strategy（策略）- 未完成](https://zhuanlan.zhihu.com/p/141556336)
- [TemplateMethod（模板方法）- 未完成](https://zhuanlan.zhihu.com/p/141560724)
- [Visitor（访问者）- 未完成](https://zhuanlan.zhihu.com/p/141560841)

## 6. 设计模式相关书籍

- 《设计模式：可复用面向对象软件的基础》
- 《设计模式沉思录》
- 《程序员修炼之道：从小工到专家》
- 《重构：改善既有代码的设计》
- 《代码整洁之道》
- 《架构整洁之道》
- 《UNIX编程艺术》
- 《C++API设计》

## 参考

1. [^](https://zhuanlan.zhihu.com/p/141561198#ref_1_0)DRY [https://en.wikipedia.org/wiki/Don%27t_repeat_yourself](https://en.wikipedia.org/wiki/Don't_repeat_yourself)
```

`note/UE/内存相关资料收集.md`:

```md
# 内存相关资料收集

## 公开课课程

[CSE 351 - Spring 2016](https://link.zhihu.com/?target=https%3A//courses.cs.washington.edu/courses/cse351/16sp/videos.html)



### 系统介绍

[https://people.freebsd.org/~lstewart/articles/cpumemory.pdf](https://link.zhihu.com/?target=https%3A//people.freebsd.org/~lstewart/articles/cpumemory.pdf)





### 其他大杂烩 [深入理解虚拟内存机制 - 简书](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/13e337312651) 华盛顿大学的公开课 《 The Hardware / Software Interface 》的课程笔记。 [真棒! 20 张图揭开内存管理的迷雾,瞬间豁然开朗-技术圈](https://link.zhihu.com/?target=https%3A//jishuin.proginn.com/p/763bfbd248c0)


大量图片，更直观地理解相关概念。
[iOS Memory Deep Dive](https://link.zhihu.com/?target=https%3A//developer.apple.com/videos/play/wwdc2018/416/)
比较系统地介绍了 iOS 内存相关知识的系统介绍。
中文翻译版本：[[ WWDC2018 \] - 深入解析iOS内存 iOS Memory Deep Dive - 送码网](https://link.zhihu.com/?target=https%3A//www.songma.com/news/txtlist_i1450v.html)
[Delivering Optimized Metal Apps and Games](https://link.zhihu.com/?target=https%3A//developer.apple.com/videos/play/wwdc2019/606/)
metal 游戏开发的优化技巧，其中有一部分内存相关的内容。
中文视频[第三方内容][https://www.bilibili.com/video/av68526913/](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av68526913/)
[iOS 内存管理研究 - 知乎](https://zhuanlan.zhihu.com/p/49829766)
iOS 内存管理比较全面的介绍。

详细讲解 iOS 内存分区的概念。
[C语言的malloc()和free()函数原理【整理】_---------海阔天空-----------CSDN博客_c语言free](https://link.zhihu.com/?target=https%3A//blog.csdn.net/llhyy17/article/details/5375298)
讲解malloc()和free()的基本概念以及基本用法。


几种 malloc 实现的分析和比较。
[Learn more about oom (low memory crash) in iOS](https://link.zhihu.com/?target=https%3A//programmer.ink/think/learn-more-about-oom-low-memory-crash-in-ios.html)
非常全面的 iOS OOM 原理介绍。
[The case of iOS OOM Crashes at Compass](https://link.zhihu.com/?target=https%3A//medium.com/compass-true-north/the-case-of-ios-oom-crashes-at-compass-96ec812397e8)
比较全面的 OOM 知识介绍。
[OOM实测阈值 - benchmark.oa.com](https://link.zhihu.com/?target=http%3A//benchmark.oa.com/%3Fr%3Dindex/other)
安卓和iOS各种代表机型的实测 OOM 阈值。

1. C++内存管理

[C++ 内存分配(new，operator new)详解_WUDAIJUN的博客-CSDN博客_c++new内存](https://link.zhihu.com/?target=https%3A//blog.csdn.net/WUDAIJUN/article/details/9273339)
详细介绍了 C++ 内存分配的过程及相关函数。
[详解C++重载new, delete - 知乎](https://zhuanlan.zhihu.com/p/354046948)
讲解如何重载C++的new和delete。

1. UE4 内存管理

[Dynamic Memory Allocation | Unreal Engine Community Wiki](https://link.zhihu.com/?target=https%3A//unrealcommunity.wiki/garbage-collection-and-dynamic-memory-allocation-u29878mo)
UE4 中动态创建对象的几种方法。
[UE4内存分配器概述 - 可可西 - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/kekec/p/12012537.html)
全面介绍了 UE4 提供的各种内存分配器。
[UE4源码剖析：MallocBinned（上） - 知乎](https://zhuanlan.zhihu.com/p/75826986)
详细讲解了 FMallocBinned 的代码实现。
[Memory stomp allocator for Unreal Engine 4. | Pablo Zurita's blog](https://link.zhihu.com/?target=https%3A//pzurita.wordpress.com/2015/06/29/memory-stomp-allocator-for-unreal-engine-4/)
作者亲自讲解 FMallocStomp 的实现原理。
[Linux中mprotect()函数的用法_Roland_Sun的专栏-CSDN博客_mprotect](https://link.zhihu.com/?target=https%3A//blog.csdn.net/Roland_Sun/article/details/33728955)
设置内存属性的函数，windows 下为 VirtualProtect。
[Linux C/C++内存越界定位: 利用mprotect使程序在crash在第一现场_Life runs on code-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/thisinnocence/article/details/80025064)
利用操作系统内存保护机制第一时间发现内存问题。
[Memory Allocation Strategies - Part 3 - gingerBill](https://link.zhihu.com/?target=https%3A//www.gingerbill.org/article/2019/02/15/memory-allocation-strategies-003/)
栈式内存分配策略。
[UE4内存Profiler - 知乎](https://zhuanlan.zhihu.com/p/61366273)
memreport、MemoryProfiler2、MALLOC_LEAKDETECTION用法。
[虚幻4：智能指针基础 - 知乎](https://zhuanlan.zhihu.com/p/94198883)
智能指针的基本概念和用法。

1. UObject 对象管理

[[UE4 UObject\] UObject 的创建流程 - 知乎](https://zhuanlan.zhihu.com/p/252431932)
详细分析 UObject 的创建过程。
[【虚幻学习】NewObject过程剖析 - 知乎](https://zhuanlan.zhihu.com/p/357510279)
详细说明 NewObject 代码执行过程。
[UE4 FObjectInitializer 对象初始化器 - 知乎](https://zhuanlan.zhihu.com/p/422510443)
FObjectInitializer 原理的深度分析。
[UE4 Config配置文件详解（2017.4.1更新）_Jerish的博客-CSDN博客_ue4 配置文件](https://link.zhihu.com/?target=https%3A//blog.csdn.net/u012999985/article/details/52801264)
配置文件的格式、用法以及引擎自带的各种配置文件路径。
[配置文件 | 虚幻引擎文档](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/4.27/zh-CN/ProductionPipelines/ConfigurationFiles/)
官方文档。

1. UE4 垃圾回收

[C++中垃圾回收机制中几种经典的垃圾回收算法_不很正派的专栏-CSDN博客_c++ 垃圾回收](https://link.zhihu.com/?target=https%3A//blog.csdn.net/u012611878/article/details/78947267)
常见的垃圾回收算法。
[UE4-GarbageCollect垃圾回收机制 - 知乎](https://zhuanlan.zhihu.com/p/448412111)
非常详细的 UE4 垃圾回收原理讲解。
[虚幻引擎内功 垃圾回收 - 知乎](https://zhuanlan.zhihu.com/p/427613791)
详细讲解各种垃圾回收算法。
[UE4 垃圾回收 - 知乎](https://zhuanlan.zhihu.com/p/67055774)
详细介绍 UE4 垃圾回收的整个过程。
[虚幻4垃圾回收剖析 - 风恋残雪 - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/ghl_carmack/p/6112118.html)
垃圾回收的概念及详细代码流程。
[UE4 垃圾收集大杂烩 - 知乎](https://zhuanlan.zhihu.com/p/219588301)
UE4 垃圾回收性能优化。
[WeakObjectPtr - 知乎](https://zhuanlan.zhihu.com/p/139473097)
详细解释 WeakObjectPtr 原理。
[UE4 从UProperty到FProperty_papalqi-CSDN博客_ue4 ufield](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_23030843/article/details/117248969)
UE 4.25 将 UProperty 换成了 FProperty。
[Debugging and Optimizing Memory - Unreal Engine](https://link.zhihu.com/?target=https%3A//www.unrealengine.com/en-US/blog/debugging-and-optimizing-memory)
官方的内存优化指南。

项目实践中遇到的内存问题及解决方法。
[UE4 Low Level Memory Tracker 使用 - 知乎](https://zhuanlan.zhihu.com/p/78005333)
UE4 LLM 内存统计的方法，也可用于统计用户自定义的内存。
```

`note/UE中的旋转.md`:

```md
# UE5中的旋转：三个欧拉角Picth、Yaw、Roll及FRotator

三维变换是游戏开发中经常需要打交道的内容。平移、缩放、旋转是三种最常用的三维变换。平移用于确定物体的位置，缩放用于确定物体的大小，旋转用于确定物体的朝向。可见，这三种变换对于在游戏世界中摆放各个物体是何等的重要。

相对而言，平移、缩放较简单，但旋转较难，更需仔细研究。本文将介绍 UE 中旋转相关的知识。

## 一，三个欧拉角Picth、Yaw、Roll

UE 向开发者提供旋转物体的方式是三个欧拉角：Picth、Yaw、Roll。Pitch 是俯仰角、Yaw 是偏航角、Roll 是滚动角。通过这三个角就能控制物体的旋转，确定一个物体的朝向。

### 1.1 俯仰角Pitch

在 UE 中，俯仰角 Pitch 是指绕绿色 Y 轴（也就是方向朝右的那个轴）旋转的角。如下面所示，图1是三个欧拉角都为0时的原始图，图2是把俯仰角 Pitch 设为30度后的对比图。从图中可以看出，人物确实绕着 Y 轴旋转了。俯仰角旋转的效果，可以想象成使人前倾或后仰。

![img](https://pic4.zhimg.com/80/v2-4fd9b2056043a141cd267d1ccb1fc717_720w.webp)

图1，未旋转时的状态

![img](https://pic1.zhimg.com/80/v2-b2cb95105ad8e9e5dd72ac6db5328f88_720w.webp)

图2，俯仰角Pitch的旋转效果

## 1.2 偏航角Yaw

在 UE 中，偏航角 Yaw 是指绕蓝色 Z 轴（也就是方向朝上的那个轴）旋转的角。图3是把偏航角 Yaw 设为30度后的效果图。对比图1可以发现，偏航角 Yaw 使人物绕着 Z 轴旋转。偏航角旋转的效果，可以想象成人在原地转动。

![img](https://pic4.zhimg.com/80/v2-0e4c49f66adcf1f8317ec8742a71c0cb_720w.webp)

图3，偏航角Yaw的旋转效果

### 1.3 滚动角Roll

在 UE 中，滚动角 Roll 是指绕红色X 轴（也就是方向朝前的那个轴）旋转的角。图4是把滚动角 Roll 设为30度后的效果图。对比图1可以发现，滚动角 Roll 使人物绕着 X 轴旋转。滚动角旋转的效果，可以想象成把人放在转盘上转动。

![img](https://pic2.zhimg.com/80/v2-2127f75eac519a73d6db3350ef17e331_720w.webp)

图4，滚动角Roll的旋转效果

## 二，旋转类FRotator

FRotator 是 UE 用来封装三个欧拉角 Picth、Yaw、Roll 的类。开发者经常需要与 FRotator 打交道，就像需要和表示物体位置的 FVector 打交道一样。

### 2.1 FRotator 是三个欧拉角Picth、Yaw、Roll的封装类

FRotator 有三个成员变量：Picth、Yaw、Roll，正好是三个欧拉角。因此，我们可以说 FRotator 是封装三个欧拉角 Picth、Yaw、Roll 的类。

```cpp
struct FRotator
{
public:
    /** Rotation around the right axis (around Y axis), Looking up and down (0=Straight Ahead, +Up, -Down) */
    float Pitch; 

    /** Rotation around the up axis (around Z axis), Running in circles 0=East, +North, -South. */
    float Yaw; 

    /** Rotation around the forward axis (around X axis), Tilting your head, 0=Straight, +Clockwise, -CCW. */
    float Roll;
}
```

如下是它的构造函数，是根据三个欧拉角 Picth、Yaw、Roll 来构造出一个 FRotator。

```cpp
FORCEINLINE FRotator::FRotator( float InF ) : Pitch(InF), Yaw(InF), Roll(InF) 
{
    DiagnosticCheckNaN();
}


FORCEINLINE FRotator::FRotator( float InPitch, float InYaw, float InRoll ) : Pitch(InPitch), Yaw(InYaw), Roll(InRoll) 
{
    DiagnosticCheckNaN();
}
```

### 2.2 FRotator 多用于对外接口，FQuat 多用于内部实现

在游戏引擎内部，通常使用四元数来表示旋转，因为四元数能轻易地串接旋转以及进行旋转插值。UE 也不例外。在 UE 内部，使用 FQuat 表示四元数，并用来进行旋转计算。但是四元数并不容易直观理解，在一点上不如欧拉角。为了平衡这一矛盾，UE 就多使用 FRotator 对外提供接口，而 FQuat 多用于实现 UE 内部的功能。换言之，游戏开发者多关注 FRotator，而引擎开发者更注重 FQuat。FRotator 与 FQuat 之间的关系，可以概括为 FRotator 多用于对外接口，FQuat 多用于内部实现，且二者之间可以相互转换。

FRotator 向 FQuat 的转换，是通过 FRotator 的成员函数Quaternion()完成，其声明如下：

```cpp
    /**
     * Get Rotation as a quaternion.
     *
     * @return Rotation as a quaternion.
     */
    CORE_API FQuat Quaternion() const;
```

FQuat 向 FRotator 的转换，是通过 FQuat 的成员函数 Rotator()完成，其声明如下：

```cpp
    /** Get the FRotator representation of this Quaternion. */
    CORE_API FRotator Rotator() const;
```

在 FRotator 求逆的时候，是先转换成 FQuat，再对 FQuat 求逆，完成后再转换回 FRotator 。在这一点的实现上，FRotator 是一个对外的接口，FQuat 充当了内部实现的工具。

```cpp
FRotator FRotator::GetInverse() const
{
    return Quaternion().Inverse().Rotator();
}
```
```

`note/UE在RPC调用中对旋转角的优化.md`:

```md
 将仰角数据从 [270, 360) 映射到 [-90, 0)
		 这个颜色将会修复因为在 CharacterMovementComponent中，这个组件在GetPackedAngles（获取仰角数据）
		 这个函数为了将仰角数据（旋转数据）通过RPC网络传输时，为了减少宽带占用，将数据压缩到4字节，
		 导致我们客户端的俯视角在服务端显示确实抬头的仰视角的bug
		 在我们的程序编写中，我们习惯的角度控制是例如 -90到90，但是在虚幻引擎中，这个函数在获取这些旋转角度数据时，
		 他会将其压缩为一个无符号的整形数
		 这个压缩过程就是通过 FRotator::CompressAxisToShort(Yaw) , FRotator::CompressAxisToShort(Patch)
		 这两个函数进行的压缩处理，函数原型如下

```c++
FORCEINLINE uint32 UCharacterMovementComponent::PackYawAndPitchTo32(const float Yaw, const float Pitch)
{
	const uint32 YawShort = FRotator::CompressAxisToShort(Yaw);
	const uint32 PitchShort = FRotator::CompressAxisToShort(Pitch);
	const uint32 Rotation32 = (YawShort << 16) | PitchShort;
	return Rotation32;
}
```



​		 然后关于 这里主要的执行函数 CompressAxisToShort,原型如下
```c++
		template<typename T>
		FORCEINLINE uint16 TRotator<T>::CompressAxisToShort(T Angle)
		{
			// map [0->360) to [0->65536) and mask off any winding
			return FMath::RoundToInt(Angle * (T)65536.f / (T)360.f) & 0xFFFF;
		}
```

​		 从源码中可以看出来，这个函数这里所做的，就是将一个float的角度数据，他的数值范围是[0,360)，
​		 (Angle * (T)65536.f / (T)360.f)这串计算得到的结果是一个介于 [0, 65536)之间的浮点值
​		 RoundToInt则是进行四舍五入，将浮点数转为整形
​		 我们知道float数据是具有小数点精度的，这些精度信息是需要字节信息来进行存储的，
​		 通过将float数据mask映射到这个范围，并删除这些小数点，我们就得到了一个一个介于 [0, 65536)之间的整形值
​		 而 65535 这个值他的十六进制数正好是 0xFFFF,16bit位的最大整形数
​		 将前面的整形数与 0xFFFF 进行按位与 & 运算，得到的结果就是将传递来的浮点数按360°进行切割。
​		 意思就是，假设你传递进来361，那么在经过计算后，得到的结果其实就是1，这一轮的旋转其实和你旋转1°是一样的效果
​		 这个就是虚幻底层在调用RPC传输旋转角和俯仰角时，为了减少网络开销所做的优化
```

`note/UE基础问题.md`:

```md
## C++

### **1.new/delete与malloc/free的区别**

（1）new/delete是C++的运算符，需要编译器支持，malloc/free是C/C++语言的标准库函数，需要引用头文件"stdlib.h"。它们都可用于在堆区申请和释放动态内存，但是申请时new能够自动分配空间大小，而malloc需要计算字节数。

（2）new申请分配内存成功时返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换分配，申请失败时会抛出bac_alloc异常；malloc申请分配成功时返回的是void指针，需要进行强制类型转换，分配内存失败时返回NULL。

（3）new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数初始化成员变量，最后返回自定义类型指针，delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）；malloc/free只能动态的申请和释放内存，不在编译器控制范围之内，不能自动调用构造函数和析构函数，无法强制要求其做自定义类型对象构造和析构工作。

```cpp
// new、delete的使用
int *p = new int;
delete p;
// malloc、free的使用
#include "stdlib.h"
int *p = (int*)malloc(sizeof(int));
free(p);
```

### **2.**拷贝**构造函数与**移动**构造函数区别**

拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象，这就会有一次拷贝对象的开销，并且进行了深拷贝，就需要给对象分配地址空间。

移动构造函数首先将传递参数的内存地址空间接管，并且在原地址上进行新对象的构造，然后将内部所有指针设置为NULL，最后调用原对象的的析构函数。

```cpp
class Person{
public:
	Person():age(new int(0)){}		       //默认构造
	Person(Person& p):age(new int(*p.age)){}       //拷贝构造
	Person(Person&& p):age(p.age){ p.age = NULL; } //移动构造
	~Person(){ if (age != NULL) delete age; }      //析构函数
private:
	int* age;
};
```

### 3.面向对象的三大特性：封装、继承和多态

封装是隐藏对象的属性和实现细节，仅对外公开接口和对象进行交互，目的是降低耦合。封装性体现在类的成员可以有公有成员(public)，私有成员(private)，保护成员(protected)。公有成员是封装体与外界的一个接口，类体外的函数可以访问公有成员；私有成员只有类的成员函数才可以访问；保护成员是只有该类的成员函数和该类的派生类才可以访问的。

继承是类与类之间的一种关系，即子类继承父类的特征和行为，使得子类具有和父类相同的属性和行为。继承的好处在于子类继承了父类的属性和方法从而实现了代码的复用，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。

多态是指一个类对象的相同方法在不同情形下有不同的表现形式，即是在不同继承关系的类对象，去调用同一函数，产生了不同的行为，使得具有不同内部结构的对象可以共享相同的外部接口。C++的多态性是通过虚函数来实现的。

```cpp
#include "iostream"
class Base {
public:                                                                 //封装
	     int pry_pub;
	     virtual void Call(){std::cout << "Base Call" << std::endl;}
protected:   int pry_pro;
private:     int pry_pri;
};
class Derived :public Base {
public:
	Derived(int pub,int pro){pry_pub = pub;pry_pro = pro;}           //继承          
	void Call() override {std::cout << "Derived Call" << std::endl;} //多态
};
```

### 4.STL list容器的实现原理

STL list容器是用带有头节点的双向循环链表实现的，在序列已知的任何位置快速插入或删除元素的时间复杂度为 O(1) ，所以对需要进行大量添加或删除元素操作，而直接访问元素的需求却很少的应用场景中，建议使用 list 容器存储序列。STL list容器的迭代器是双向迭代器，包含一个可以指向 list 容器的指针，该指针还可以借助重载的 *、++、--、==、!= 等运算符，实现迭代器正确的取值、递增、递减、比较等操作。

```cpp
#include "list"
#include "iostream"
int a[] = { 1,2,3,4,5 };
std::list<int> value(a,a+5);                                               //快速插入
for (std::list<int>::iterator it = value.begin(); it != value.end(); ++it) //使用迭代器输出容器内元素
    std::cout << *it << std::endl;
```

### 5.STL map和unordered_map容器的实现原理

map：是STL的一个关联容器，元素是键值对(key-value)，内部用红黑树实现。优点是具有自动排序（按键从小到大）功能，查询、插入、删除的时间复杂度都是 O(logn) 。缺点是红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。

unordered_map：内部用哈希表（采用除留余数法构造，拉链法解决冲突）实现。优点是查找速度非常快，时间复杂度是 O(1) 。缺点是内部元素无序杂乱，建立哈希表比较耗时。

```cpp
#include "map"
std::map<int, char> key;
key.emplace(1, 'a');                                 //插入
std::map<int, char>::iterator it = key.find(1);      //查找
key.erase(1);                                        //删除
//#include "unordered_map"
//std::unordered_map<int,char> ukey;
//unordered_map的使用方法和map类似
```

### 6.define宏与const常量的区别

define宏是在预处理阶段展开，没有类型，不做类型检查，仅仅是展开，有多少地方使用就展开多少次，不会分配内存，但在程序运行阶段会有若干个拷贝。

const常量是在编译运行阶段使用，有具体的类型，在编译阶段会执行类型检查，会分配内存，在程序运行阶段只有一份拷贝，可以节省空间，避免不必要的内存分配。

```cpp
#define PI 3.14
const float PI=3.14;
```

### 7.构造函数和析构函数可以是虚函数吗

构造函数不可以是虚函数。当类中声明虚函数时，编译器会在类中生成一个虚函数表，该表是由编译器自动生成与维护的一个存储成员函数指针的数据结构，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。如果构造函数是虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。

析构函数可以且常常是虚函数。与构造函数不同，vptr已经完成初始化，析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。实现多态时以基类指针指向派生类的方式创建对象，若析构函数是虚函数(即加上virtual关键词)，delete时基类和子类都会被释放；若析构函数不是虚函数(即不加virtual关键词)，delete时只释放基类，不释放子类，会造成内存泄漏问题。

```cpp
class Base {
public:
    Base() {}
    virtual ~Base() {}
};
class Derived : public Base {
public:
    Derived() {}
    virtual ~Derived() {}
};
```

### 8.单例模式的应用场景

单例模式(Singleton Pattern)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。应用场景包括：缓存，日志，工具类，配置，线程池等。

```cpp
class Singleton {
public:
    ~Singleton() {}
    Singleton(const Singleton&) = delete;             //被=delete修饰表明这个函数被删除，即禁用了重写的拷贝构造函数
    Singleton& operator=(const Singleton&) = delete;  //禁用重写的赋值构造函数
    static Singleton& getInstance() {                 //类外获取实例对象的方法
        static Singleton instance;                    //声明局部静态变量
        return instance;
    }
private:
    Singleton() {}                                    //重写的默认构造函数私有化
};
```

## UE4

### 1.游戏模式和游戏实例

GameInstance：游戏实例，架构上凌驾于最顶端，实例里的数据不会随着关卡的切换而消失。在“项目设置 - 项目 - 地图和模式 - 游戏实例 - 游戏实例类”处修改。

GameMode：设置游戏规则。联网状态下，只存在于服务端，可以充当一个服务端，客户端不能访问。在“项目设置 - 项目 - 地图和模式 - 默认模式 - 默认游戏模式”或“世界场景设置 - 游戏模式 - 游戏模式重载”或“Config - DefaultEngine.ini - GameMapsSettings - GlobalDefaultGameMode”处均可修改。

默认Pawn：角色的外在表现类，是玩家在游戏中的物理代表，可包含自身的移动规则和其他游戏逻辑，同PlayerState，也需要通过PlayerController来访问，服务端和客户端都存在一份，同时保持同步；在GameMode中修改。

HUD：只存在于客户端；在GameMode中修改。

PlayerController：非常重要的一个类，拥有Pawn并设置其行为规则，关联了客户端和服务端，通过该类，客户端可以向服务端发送请求；在GameMode中修改。

GameState：数据的全局管理，服务端和客户端都存在一份，用来保持数据的同步，也可将其中的部分数据设置为不同步；在GameMode中修改。

PlayerState：角色数据，该类需要通过PlayerController来访问；在GameMode中修改。

### **2.动态材质实例的作用**[[1\]](https://zhuanlan.zhihu.com/p/579078025#ref_1)

动态材质实例 (MID) 是可以在游戏期间（在运行时）进行计算的实例化材质。这表示在游戏期间，您可使用脚本（经过编译的代码或蓝图可视脚本）来更改材质的参数，从而在游戏中改变该材质。这种材质的可能应用场合数不胜数，既可显示不同程度的损坏，也可更改绘图作业以混入不同皮肤纹理来回应面部表情。

### 3.**单播委托、多播委托和动态委托的区别？**

委托是一种泛型但类型安全的方式，可在C++对象上调用成员函数。可使用委托动态绑定到任意对象的成员函数，之后在该对象上调用函数，即使调用程序不知对象类型也可进行操作。

单播委托指只能绑定一个函数指针的委托，也就是当执行委托时只能触发一个唯一绑定的函数，可以绑定无返回值或有返回值的函数（最多支持八个函数参数）。

多播委托拥有大部分与单播委托相同的功能。它们只拥有对对象的弱引用，可以与结构体一起使用，可以四处轻松复制等等。多播委托可以绑定多个函数，可以远程加载/保存和触发；但多播委托函数不能使用返回值。它们最适合用来四处轻松传递一组委托。

动态委托可序列化，即可以在蓝图中使用，其函数可按命名查找，但其执行速度比常规委托慢。

```cpp
//单播委托
DECLARE_DELEGATE(FDelegate);                                             //声明
FDelegate Delegate;                                                      //定义
Delegate.ExecuteIfBound();                                               //调用
ActorReference->Delegate.BindUObject(this, &AMyActor::DelegateFunction); //绑定
//多播委托
DECLARE_MULTICAST_DELEGATE(FMulticastDelegate);
FMulticastDelegate MulticastDelegate;
MulticastDelegate.Broadcast();
ActorReference->MulticastDelegate.AddUObject(this, &AMyActor::MulticastDelegateFunction);
//动态委托
DECLARE_DYNAMIC_DELEGATE(FDynamicDelegate);
FDynamicDelegate DynamicDelegate;
DynamicDelegate.ExecuteIfBound();
ActorReference->DynamicDelegate.BindDynamic(this, &AMyActor::DynamicDelegateFunction);
```

### 4.**如何保持新建的UObject对象不被自动GC垃圾回收？**

在普通的C++类中新建UObject对象后，使用AddToRoot()函数可以保护对象不被自动回收，移除保护时使用RemoveFromRoot()并把对象指针置为nullptr即可由引擎自动回收；

```cpp
//创建时保护对象
UMyObject* MyObject=NewObject<UMyObject>();
MyObject->AddToRoot();
//交给引擎回收对象
MyObject->RemoveFromRoot();
MyObject=nullptr;
```

如果是在继承自UObject类中新建UObject对象后，使用UPROPERTY宏标记一下对象指针变量也可以保护对象不被自动回收，在该类被销毁时，新建的对象也会被引擎自动回收。

```cpp
UCLASS()
class UMyObject : public UObject{
    GENERATED_BODY()
    UPROPERTY()
    class UItemObject* ItemObject;
}
```

### 5. 三种智能指针

共享指针（TSharedPtr）允许多个该类型的指针指向同一块内存，采用引用计数器的方式，统计所有指向同一块内存的指针变量的数量，当新的指针变量生命并初始化指向同一块内存，拷贝函数拷贝和赋值操作时引用计数器会自增加，当指针变量生命周期结束调用析构时，引用计数器会自减少。引用计数器减少至0时，释放指向的内存。共享引用（TShareRef）和共享指针的区别是共享指针可以为NULL，而共享引用不能为NULL 。

弱指针（TWeakPtr`TSharedPtr`）主要是为了配合 TSharedPtr 而引入的一种智能指针，TWeakPtr 没有指针的行为，没有重载间接引用操作符(->)和解除引用操作符(*)，它可以通过 TSharedPtr 和 TSharedRef 来初始化，但只引用，不计数，不拥有内存的所有权，不会对 TSharedPtr 和 TSharedRef 的共享引用计数器产生影响，也不影响其生命周期，但会在控制块的WeakReferenceCount属性中统计弱指针引用数量。

唯一指针（TUniquePtr）仅会显式拥有其引用的对象。仅有一个唯一指针指向给定资源，因此唯一指针可转移所有权，但无法共享。复制唯一指针的任何尝试都将导致编译错误。唯一指针超出范围时，其将自动删除其所引用的对象。

```cpp
TSharedPtr<Person> sp = MakeShared<Person>();     //创建共享指针
TSharedRef<Person> sr = sp.ToSharedRef();         //创建共享引用
TWeakPtr<Person> wp = sp;                         //创建弱指针
int32 use_count = sp.GetSharedReferenceCount();   //共享指针计数
TUniquePtr<Person> up = MakeUnique<Person>(); //创建唯一指针
```

### 6.智能指针的循环引用

在使用基于引用计数的智能指针时，为了防止循环引用带来的内存泄漏问题，可以让引用链上的一方持用弱智能指针TWeakPtr。弱智能指针不会影响共享引用计数器。

### 7. 如何使用ParallelFor提高速度

ParallelFor允许我们在一分钟内对任何 for 循环进行多线程处理，从而通过在多个线程之间拆分工作来划分执行时间。

```cpp
//例1
ParallelFor(num, [&](int32 i) {sum += i; });
//例2
FCriticalSection Mutex;
ParallelFor(Input.Num(), [&](int32 Idx){
    if(Input[Idx] % 5 == 0){
        Mutex.Lock();
        Output.Add(Input[Idx]);
        Mutex.Unlock();
    }
});
```

### 8.TMap的实现原理

TMap是用基于数组的哈希表实现的，查询效率高，添加、删除效率低，查询的时间复杂度是 O(1) 。TMap的排序采用的快速排序 ， 时间复杂度为 O(nlogn) 。

|               | 数据结构 | 查询时间复杂度 | 优点                                   | 缺点                             |
| ------------- | -------- | -------------- | -------------------------------------- | -------------------------------- |
| map           | 红黑树   | O(logn)        | 内部自动排序，查询、添加、删除效率相同 | 空间占用较大                     |
| unordered_map | 哈希表   | O(1)           | 查询效率高                             | 内部元素无序杂乱添加、删除效率低 |
| TMap          | 哈希表   | O(1)           | 查询效率高                             | 内部元素无序杂乱添加、删除效率低 |

### 9.法线是存储在什么空间[[2\]](https://zhuanlan.zhihu.com/p/579078025#ref_2)

切线空间。对法线做空间变换时，若模型本身做了xyz轴上的非均匀缩放，则法线值会产生偏移，但切线并不会受到影响，所以相较于模型空间，一般常用切线空间存储法线数据。切线空间存储的是相对法线信息，在切线空间中，每个法线方向所在的坐标空间是不一样的，即是表面每点各自的切线空间，这种法线纹理其实存储了每个点在各自的切线空间中的shading法线偏移（扰动）方向，如果一个点的法线方向不变，那么在其切线空间中，新的法线方向就是z轴方向。即值为（0,0,1），映射到颜色即（0.5,0.5,1)浅蓝色。

![img](https://pic1.zhimg.com/80/v2-40fa646b804af43f7bd450b1113a41ec_720w.webp)

### 10.虚幻中有哪几种主要线程[[3\]](https://zhuanlan.zhihu.com/p/579078025#ref_3)

**游戏线程（GameThread）**：承载游戏逻辑、运行流程的工作，也是其它线程的数据发起者。在FEngineLoop::Tick函数执行每帧逻辑的更新。在引擎启动时会把GameThread的线程id存储到全局变量GGameThreadId中，且稍后会设置到TaskGraph系统中。

**渲染线程（RenderThread）**：RenderThread在TaskGraph系统中有一个任务队列，其他线程（主要是GameThread）通过宏ENQUEUE_RENDER_COMMAND向该队列中填充任务，RenderThread则不断从这个队列中取出任务来执行，从而生成与平台无关的Command List（渲染指令列表）。

**RHI线程（Render Hardware Interface Thread）**：RenderThread作为前端（frontend）产生的Command List是平台无关的，是抽象的图形API调用；而RHIThread作为后端（backend）会执行和转换渲染线程的Command List成为指定图形API的调用（称为Graphical Command），并提交到GPU执行。RHI线程的工作是转换渲染指令到指定图形API，创建、上传渲染资源到GPU。

### 11.游戏线程和渲染线程的同步[[4\]](https://zhuanlan.zhihu.com/p/579078025#ref_4)

当GameThread与RenderThread同步时，GameThread会创建一个FNullGraphTask空任务，放到RenderThread的TaskGraph队列中让其执行，在FRenderCommandFence的Wait函数中，会检查投递给RenderThread的CompletionEvent是否被执行，如果没有执行则调用GameThreadWaitForTask函数来阻塞等待。

### 12.CharacterMovementConponent如何更改移动速度

CharacterMovementComponent的工作原则是使用加速度驱动速度，通过速度表现具体Actor的移动，输入当前加速度的方向和最大加速度的百分比来更改移动速度。

### 13.多线程Task Graph

TaskGraph是UE中基于任务的并发机制。可以创建任务在指定类型的线程中执行，同时提供了等待机制，其强大之处在于可以调度一系列有依赖关系的任务，这些任务组成了一个有向无环的任务网络（DAG），并且任务的执行可以分布在不同的线程中。

### 14.后处理之bloom

泛光（Bloom）是一种现实世界中的光现象，通过它能够以较为适度的渲染性能成本极大地增加渲染图像的真实感。用肉眼观察黑暗背景下非常明亮 的物体时会看到泛光效果。泛光可以用一个高斯模糊来实现。为了提高质量，我们将多个不同半径的高斯模糊组合起来。为了获得更好的性能，我们在大大降低的分辨率下 进行很宽范围的模糊。通过改变模糊效果的组合方式，我们可以进行更多的控制，取得更高的质量。为了获得最佳的性能，应该使用高分辨率模糊（小值）来实现较窄的模糊，而主要使用低分辨率模糊 （大值）实现较宽的模糊。

### 15.后处理之轮廓描边

对需要描边的物体开启自定义深度缓存，物体所在区域会出现填充的具有深度信息的缓存区，通过后期处理对相邻像素进行采样来执行简单的深度比较，如果邻居有深度信息，但像素没有，就将其着色为轮廓线颜色。

### 16.蓝图大量连线为何会比C++慢很多[[5\]](https://zhuanlan.zhihu.com/p/579078025#ref_5)

蓝图的消耗主要是在节点之间，蓝图连线触发的消耗是一致的，但节点运行的消耗是通过C++ , 节点不同就有所不同 ，所以蓝图中连线很多时会显著降低运行效率。

### 17.模型闪烁问题如何解决

当两个面共面时，会出现闪面现象。使用UE4材质中Pixel Depth Offset节点，进行像素偏移，达到共面不闪面的效果。

### 18.虚幻内使用的光照模型

PBR，基于物理的光照。

### 19.slate中常用的控件



## 图形学

### 1.渲染管线的流程

图形渲染管线分为四个阶段：应用程序阶段、几何阶段、光栅化阶段和像素处理阶段。

（1）应用程序阶段的主要任务，是识别出潜在可视的网格实例，并把它们及其材质呈交至图形硬件以供渲染。该阶段包含：准备基本场景数据->加速算法、粗粒度剔除->设置渲染状态、准备渲染参数->输出渲染图元至显存以供渲染。

（注：应用程序阶段在**CPU**端完成，后面的所有阶段都是在**GPU**端完成）

（2）几何阶段主要负责大部分多边形操作和顶点操作，将三维空间的数据转换为二维空间的数据。该阶段包含：顶点着色->可选定点处理->投影->裁剪->屏幕映射。

（3）光栅化阶段是将图元离散化成片段的过程，其任务是找到需要绘制出的所有片段。该阶段包含：三角形设置(图元装配)->三角形遍历。

（4）逐片元着色，给每一个像素正确配色，最后绘制出整幅图像，包括像素着色和合并阶段。

### 2.Phong光照模型和Blin-Phong光照模型的区别

Phong氏光照模型其实是经验模型，参数信息是通过经验得到的。Phong模型将物体光照分为三个部分进行计算，分别是：漫反射分量、镜面高光和环境光。其中，环境光分量是用来模拟全局光照效果的，其实就是在物体光照信息基础上叠加上一个较小的光照常量，用来表示场景中其他物体反射的间接光照。Phong模型在处理高光时会出现光照不连续的情况，当光源和视点位于同一个方向时，反射光线跟观察方向可能大于90度，反射光线的分量就被消除了。

Blinn-Phong氏光照模型是对Phong氏光照模型的改进，Blinn-Phong模型在处理镜面反射时不使用观察方向和反射光线的夹角来计算，而是引入了一个新的向量：半角向量(Halfway vector)。半角向量其实很简单，就是入射光线向量L和观察方向V的中间位置（角平分线）。Blinn-Phong求高光亮度的时候使用半角向量和法向量的点积来决定高光亮度。Phong是用反射光线和视线向量的点积来求高光亮度。

### **3.延迟渲染和正向渲染的区别**

正向渲染，先执行着色计算，再执行深度测试；渲染n个物体在m个光源下的着色，复杂度为O（n*m），光源数量对计算复杂度影响大；对于正向渲染，我们通常会对一个像素运行多次片段着色器；延迟渲染，先进行深度测试，再执行着色计算；对于延迟渲染，每一个像素只会执行一次片段着色器。

### 4.深度测试在哪个阶段？

在渲染的时候，图形管线会先对每一个位置的像素存储一个深度值，称为深度缓冲，代表了该像素点在3D世界中离相机最近物体的深度值。于是在计算每一个物体的像素值的时候，都会将它的深度值和缓冲器当中的深度值进行比较，如果这个深度值小于缓冲器中的深度值，就更新深度缓冲和颜色缓冲的值，否则就丢弃。深度测试发生在片元着色器处理之后, 透明度混合之前。

5.PBR光照模型的原理

6.PBR光照模型为什么渲染的比较真实

7.有哪几种抗锯齿的方式

8.模型绕z轴旋转时的变换矩阵

## 上机编程

### 合并两个有序数组

两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你合并 nums2 到 nums1 中，使合并后的数组同样按非递减顺序排列。

```cpp
void Merge(int nums1[], int nums2[], int m, int n)
{
	int i = m - 1;		//指向数组nums1有效数据的最后一个数据下标
	int j = n - 1;		//指向数组nums2有效数据的最后一个数据下标
	int k = m + n - 1;	//指向数组nums1的最后一个数据下标
	while (i >= 0 && j >= 0)
	{
		nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];	//优先将较大数据放到nums1的后面
	}
	while (j >= 0)	nums1[k--] = nums2[j--];	//将数组nums2中的剩余数据拷贝到nums1中
}
```



# UE5中的旋转：三个欧拉角Picth、Yaw、Roll及FRotator

三维变换是游戏开发中经常需要打交道的内容。平移、缩放、旋转是三种最常用的三维变换。平移用于确定物体的位置，缩放用于确定物体的大小，旋转用于确定物体的朝向。可见，这三种变换对于在游戏世界中摆放各个物体是何等的重要。

相对而言，平移、缩放较简单，但旋转较难，更需仔细研究。本文将介绍 UE 中旋转相关的知识。

## 一，三个欧拉角Picth、Yaw、Roll

UE 向开发者提供旋转物体的方式是三个欧拉角：Picth、Yaw、Roll。Pitch 是俯仰角、Yaw 是偏航角、Roll 是滚动角。通过这三个角就能控制物体的旋转，确定一个物体的朝向。

### 1.1 俯仰角Pitch

在 UE 中，俯仰角 Pitch 是指绕绿色 Y 轴（也就是方向朝右的那个轴）旋转的角。如下面所示，图1是三个欧拉角都为0时的原始图，图2是把俯仰角 Pitch 设为30度后的对比图。从图中可以看出，人物确实绕着 Y 轴旋转了。俯仰角旋转的效果，可以想象成使人前倾或后仰。

![img](https://pic4.zhimg.com/80/v2-4fd9b2056043a141cd267d1ccb1fc717_720w.webp)

图1，未旋转时的状态

![img](https://pic1.zhimg.com/80/v2-b2cb95105ad8e9e5dd72ac6db5328f88_720w.webp)

图2，俯仰角Pitch的旋转效果

## 1.2 偏航角Yaw

在 UE 中，偏航角 Yaw 是指绕蓝色 Z 轴（也就是方向朝上的那个轴）旋转的角。图3是把偏航角 Yaw 设为30度后的效果图。对比图1可以发现，偏航角 Yaw 使人物绕着 Z 轴旋转。偏航角旋转的效果，可以想象成人在原地转动。

![img](https://pic4.zhimg.com/80/v2-0e4c49f66adcf1f8317ec8742a71c0cb_720w.webp)

图3，偏航角Yaw的旋转效果

### 1.3 滚动角Roll

在 UE 中，滚动角 Roll 是指绕红色X 轴（也就是方向朝前的那个轴）旋转的角。图4是把滚动角 Roll 设为30度后的效果图。对比图1可以发现，滚动角 Roll 使人物绕着 X 轴旋转。滚动角旋转的效果，可以想象成把人放在转盘上转动。

![img](https://pic2.zhimg.com/80/v2-2127f75eac519a73d6db3350ef17e331_720w.webp)

图4，滚动角Roll的旋转效果

## 二，旋转类FRotator

FRotator 是 UE 用来封装三个欧拉角 Picth、Yaw、Roll 的类。开发者经常需要与 FRotator 打交道，就像需要和表示物体位置的 FVector 打交道一样。

### 2.1 FRotator 是三个欧拉角Picth、Yaw、Roll的封装类

FRotator 有三个成员变量：Picth、Yaw、Roll，正好是三个欧拉角。因此，我们可以说 FRotator 是封装三个欧拉角 Picth、Yaw、Roll 的类。

```cpp
struct FRotator
{
public:
    /** Rotation around the right axis (around Y axis), Looking up and down (0=Straight Ahead, +Up, -Down) */
    float Pitch; 

    /** Rotation around the up axis (around Z axis), Running in circles 0=East, +North, -South. */
    float Yaw; 

    /** Rotation around the forward axis (around X axis), Tilting your head, 0=Straight, +Clockwise, -CCW. */
    float Roll;
}
```

如下是它的构造函数，是根据三个欧拉角 Picth、Yaw、Roll 来构造出一个 FRotator。

```cpp
FORCEINLINE FRotator::FRotator( float InF ) : Pitch(InF), Yaw(InF), Roll(InF) 
{
    DiagnosticCheckNaN();
}


FORCEINLINE FRotator::FRotator( float InPitch, float InYaw, float InRoll ) : Pitch(InPitch), Yaw(InYaw), Roll(InRoll) 
{
    DiagnosticCheckNaN();
}
```

### 2.2 FRotator 多用于对外接口，FQuat 多用于内部实现

在游戏引擎内部，通常使用四元数来表示旋转，因为四元数能轻易地串接旋转以及进行旋转插值。UE 也不例外。在 UE 内部，使用 FQuat 表示四元数，并用来进行旋转计算。但是四元数并不容易直观理解，在一点上不如欧拉角。为了平衡这一矛盾，UE 就多使用 FRotator 对外提供接口，而 FQuat 多用于实现 UE 内部的功能。换言之，游戏开发者多关注 FRotator，而引擎开发者更注重 FQuat。FRotator 与 FQuat 之间的关系，可以概括为 FRotator 多用于对外接口，FQuat 多用于内部实现，且二者之间可以相互转换。

FRotator 向 FQuat 的转换，是通过 FRotator 的成员函数Quaternion()完成，其声明如下：

```cpp
    /**
     * Get Rotation as a quaternion.
     *
     * @return Rotation as a quaternion.
     */
    CORE_API FQuat Quaternion() const;
```

FQuat 向 FRotator 的转换，是通过 FQuat 的成员函数 Rotator()完成，其声明如下：

```cpp
    /** Get the FRotator representation of this Quaternion. */
    CORE_API FRotator Rotator() const;
```

在 FRotator 求逆的时候，是先转换成 FQuat，再对 FQuat 求逆，完成后再转换回 FRotator 。在这一点的实现上，FRotator 是一个对外的接口，FQuat 充当了内部实现的工具。

```cpp
FRotator FRotator::GetInverse() const
{
    return Quaternion().Inverse().Rotator();
}
```


```

`note/UE是如何让角色动起来的.md`:

```md
# UE 是如何让角色动起来的

---

选自https://zhuanlan.zhihu.com/p/563822473

## 一、引子

在介绍角色移动之前，我们先想一个问题，时空是连续的吗？广义相对论和量子力学对此有深刻分歧。有人说由于有普朗克长度和普朗克时间的存在，时空是不连续的，存在最小的长度、最小的能量、最小的时间，一切都是普朗克单位的整数倍，不存在非普朗克整数倍的量。还有人说量子是随机分布的，或随机出现的，在不同位置之间可以不需要时间，可以无限快地“跨过”，有超距作用；还有人说无需“跨过”，只是随机出现，在两地之间“量子”完全消失，在另一地又凭空出现。我不知道时空是否是连续的，但是我知道UE会同意时空是不连续的。在UE中，我们可以理解角色移动的本质是合理的改变角色根组件的坐标位置。只是改变了坐标位置，不够自然，我们再加上移动的动画，看起来就合理了，在计算机世界里，看起来是对的那它就是对的。

## 二、SetActorLocation

在UE中让一个Actor动起来，你能想到的最直接的方法是什么？没错就是SetActorLocation，每个时空片段给它一个新的位置，只要位置之间偏差没那么夸张，它看起来就是连续运动的。

![img](https://pic4.zhimg.com/80/v2-3faf86b3f7c8b9ac613429a050400ccf_720w.webp)

UE把Actor的移动从Actor中抽离出来了，用UMovementComponent组件来负责物体的运动、碰撞等与运动相关的工作。同时UE比较贴心，给Character添加了一个UCharacterMovementComponent组件，专门来处理Character的运动工作。**UCharacterMovementComponent**继承自**UPawnMovementComponent**，UPawnMovementComponent又继承自**UNavMovementComponent**，UNavMovementComponent又继承自**UMovementComponent**。 这些移动组件的继承关系如下图。

![img](https://pic3.zhimg.com/80/v2-408f3fbfddfa94ab7429cc35802bda96_720w.webp)

图片来自网络，侵删

我们来看看UMovementComponent的注释说明，发现了一个重要的函数**SafeMoveUpdatedComponent**。

![img](https://pic4.zhimg.com/80/v2-ce0c7a30f5b5ac9465eb951fc0e696fb_720w.webp)

我们不关心碰撞，只看看到底怎么移动的，里面实现移动的是**MoveUpdatedComponent**。

![img](https://pic4.zhimg.com/80/v2-8cf3b1cda47bfece1035a20042d56e0f_720w.webp)

![img](https://pic4.zhimg.com/80/v2-e8cc327210f47ac5709caa78dc90aebf_720w.webp)

MoveUpdatedComponent其实改变的是UpdateComponent组件的位置。UpdateComponent组件是**USceneComponent**类型，我们一开始想要移动的角色的根组件也是USceneComponent类型。我们继续深入UpdateComponent的MoveComponent函数实现了什么。

![img](https://pic3.zhimg.com/80/v2-5f2ed7cc48cce302b9f8a20f04217eaa_720w.webp)

![img](https://pic4.zhimg.com/80/v2-619babeee4a9f01675f2114f30f2715b_720w.webp)

![img](https://pic1.zhimg.com/80/v2-4dc6b7b65b5658178ff1bc936e8fd240_720w.webp)

![img](https://pic3.zhimg.com/80/v2-032e8bc6edb289735bceebf5251f45b2_720w.webp)

![img](https://pic3.zhimg.com/80/v2-1d4ad1025f4bca859d870f67cea293f2_720w.webp)

可见USceneComponent提供了一个基本位置信息**ComponentToWorld**，以及改变自身及其子组件的位置的接口函数**InternalSetWorldLocationAndRotation**。
介绍Actor的底层移动原理，回到UCharacterMovementComponent组件。

[https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Networking/CharacterMovementComponent/docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Networking/CharacterMovementComponent/](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Networking/CharacterMovementComponent/)

## 三、移动 

这里来分析UE是如何让角色冻起来，在我们的游戏中有三种移动规则：

- 手动移动，通过控制摇杆（或WSAD）来控制主角的移动。
- 自动漫游移动。
- 鼠标点击屏幕角色移动到点击位置。

其中鼠标点击移动就是使用的**SetActorLocation**。让角色从当前位置插值到鼠标点击位置。

![img](https://pic1.zhimg.com/80/v2-717fdb32cbdb06d2797ebf959e33c3a8_720w.webp)

而另外两种则使用的是**AddMovementInput**。

![img](https://pic1.zhimg.com/80/v2-d3dc2803a9113649e2014632b05b6c3c_720w.webp)

![img](https://pic1.zhimg.com/80/v2-5b9415fd87706b2ffc65f246ab2a75d8_720w.webp)

### 1、AddMovementInput

接下来讲讲AddMovementInput到底是怎么回事。先贴一张更为详细的移动组件的相关类图。

![img](https://pic4.zhimg.com/80/v2-14f71aee41919cb1c29b55f3a7e0b757_720w.webp)

图片来自网络，侵删

从上图可以看到Actor绑定了一个**UInputComponent**组件，用来处理一些绑定的按键操作。

![img](https://pic2.zhimg.com/80/v2-4d46670219978c23a01f80aa9dd15ed1_720w.webp)

![img](https://pic2.zhimg.com/80/v2-c424a683ddee21d88396c39d51ae44e5_720w.webp)

我们以BP_Player_Hero（Character对应的蓝图）为例，打开BP_Player_Hero，选中Class Defaults，在Details面板，我们可以看到有一个Input分页，可以用来接受或拒绝按键输入。

![img](https://pic1.zhimg.com/80/v2-2c4c141a2caf5e73a38da39fdeeae854_720w.webp)

因为APlayerController继承自AController，而AController也继承自AActor，所以我们的BP_PC_Arena（APlayerController对应的蓝图）也有一个InputComponent组件。我们的手动操作角色移动正是利用了这个InputComponent组件。

![img](https://pic2.zhimg.com/80/v2-f38ea6e5d00a23f9144c25165f815021_720w.webp)

![img](https://pic1.zhimg.com/80/v2-4f7ea60f048d43accd6d1fe4070d1d8c_720w.webp)

接下来我们InputComponent是怎么让我们的角色移动起来的。
当我们滑动摇杆或者按下WSAD后，InputComponent会接收到信息，进而被APlayerController的**MoveForward**和**MoveRight**接受到。在MoveForward中计算出角色朝前移动的偏移量（Speed * DeltaTime * AxisValue），MoveRight同理。

![img](https://pic3.zhimg.com/80/v2-f6be03b945fe30ea4c3d0de7792872ba_720w.webp)

![img](https://pic1.zhimg.com/80/v2-8b6fbaa120fb5e8fd5df4118a033e898_720w.webp)

我们的角色继承自APawn。APawn封装了一个接口**AddMovementInput**。

![img](https://pic1.zhimg.com/80/v2-97c6d637a86fd2776b49c34d53e134ec_720w.webp)

![img](https://pic3.zhimg.com/80/v2-3e1b4fb07f41e1425da5744c8834b972_720w.webp)

![img](https://pic3.zhimg.com/80/v2-c07065914f46f4f63258ee12ae58bbc2_720w.webp)

![img](https://pic1.zhimg.com/80/v2-b9b930b0aab52690fdbf4cb5dd554d5c_720w.webp)

所以当我们按下按钮，最终会给角色身上**ControlInputVector**加上一段偏移量。

![img](https://pic2.zhimg.com/80/v2-bd65e55b9f53c8900fded8277aaee4fd_720w.webp)

可以看到ControlInputVector会被消费掉。找到是谁在消费。

![img](https://pic1.zhimg.com/80/v2-632f0a3e2d92f1de9e90a0068ebc37d8_720w.webp)

**Internal_ConsumeMovementInputVector**有两处调用。

![img](https://pic4.zhimg.com/80/v2-9b8d430c73fbd5f115b459614fada2a3_720w.webp)

![img](https://pic3.zhimg.com/80/v2-d1f8ef0635b901414995c0d69cf2852a_720w.webp)

其中**ConsumeMovementInputVector**会在APawn的Restart或UnPossessed中调用。而**UPawnMovementComponent::ConsumeInputVector**会在UCharacterMovementComponent的Tick中调用。

![img](https://pic1.zhimg.com/80/v2-c80476d29d9b62fd4fb8f544460390c0_720w.webp)

而这正是我们想找的，**我们按下按钮得到的角色偏移量被角色的UCharacterMovementComponent组件拿到了**。UCharacterMovementComponent拿到偏移量后，满足一些条件后执行**ControlledCharacterMove，**然后把Input的偏移量转换成了加速度**Acceleration**。

![img](https://pic1.zhimg.com/80/v2-72ca82ebf8d7abb749fffc98e34b1440_720w.webp)

![img](https://pic2.zhimg.com/80/v2-1497c8f1e8bc3693b8159ab7fc976e11_720w.webp)

### 2、PerformMovement

到这一步，我们也大概梳理出了移动的框架，但是移动逻辑的细节处理我们还没讲。再次打开官方文档，我们会找到**PerformMovement**。

[角色移动组件docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Networking/CharacterMovementComponent/![img](https://pic4.zhimg.com/v2-e55c6e69f964c3de317fb65685fd3737_180x120.jpg)](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Networking/CharacterMovementComponent/)

![img](https://pic1.zhimg.com/80/v2-841749400b025cdb84d9355800a380a0_720w.webp)

进入PerformMovement，找到两个我们想要的函数，**StartNewPhysics**和**PhysicsRotation**。

![img](https://pic4.zhimg.com/80/v2-95b979d8d846642908b4d2bfb8779e1f_720w.webp)

打开StartNewPhysics，因为我们的游戏是全程飞在空中，所以我们**MovementMode**设置的是**MOVE_Flying**。

![img](https://pic2.zhimg.com/80/v2-321bcfc308732644d146a5f19c77176d_720w.webp)

![img](https://pic1.zhimg.com/80/v2-1405d7dcb7a04a4456431a47f86086bc_720w.webp)

继续回到StartNewPhysics中，找到MOVE_Flying对应的**PhysFlying**。

![img](https://pic3.zhimg.com/80/v2-971e4975d56ce73721fb014f62112c8e_720w.webp)

在PhysFlying我们会找到一个我们已经讲过的函数**SafeMoveUpdatedComponent**。

![img](https://pic1.zhimg.com/80/v2-3e1a79a79baff1dc5e43e0c569dc4fd4_720w.webp)

### 3、Rotation

到这我们终于讲完了角色移动的Position，还差一个角色移动的朝向问题没说。在各种文章里我们经常看到别人说到几个变量：**bUseControllerRotationYaw、bOrientRotationToMovement、bUseControllerDesiredRotation**。我就在这踩过坑，我觉得还是有必要跟大家讲讲。
还是先回到PerformMovement中，我们还有一个函数**PhysicsRotation**没讲，如何在移动过程中改变角色朝向。

![img](https://pic4.zhimg.com/80/v2-d674861ca6fb9175970e094f3c8fb1f3_720w.webp)

![img](https://pic2.zhimg.com/80/v2-7571c03abff2bd03537111ebdf4427f9_720w.webp)

![img](https://pic3.zhimg.com/80/v2-1a9e1ccaf1c449b48fa845fc36e0dca6_720w.webp)

可以看到最后有一句
**MoveUpdatedComponent( FVector::ZeroVector, DesiredRotation, \*/\*bSweep\*/\* false );**
这里只更新角色的朝向Rotation，位置的偏移量是ZeroVector。

- **一旦bOrientRotationToMovement设置为True后，角色的朝向会转向移动的方向。**

![img](https://pic1.zhimg.com/80/v2-33f8a41e7154f17361c87a22ad81c220_720w.webp)

![img](https://pic4.zhimg.com/80/v2-b5b473b58d2a3311e80741383a4baa0f_720w.webp)

- **一旦bOrientRotationToMovement 为False，但是bUseControllerDesiredRotation设置为True。那么在角色移动中，如果Controller的朝向和角色朝向不一致，角色朝向就会平滑的按照RotationRate里配置的各个轴的旋转速率来旋转角色的Rotation到Controller的朝向。**

![img](https://pic2.zhimg.com/80/v2-cf07c90a0355d2fc6af9d304e3d2b7e5_720w.webp)

因为我们的游戏的视角是俯视角锁定视角的，角色的朝向会一直转向移动方向。所以我们采用的是**bOrientRotationToMovement**为True。

![img](https://pic3.zhimg.com/80/v2-f2bd3f4842ada7d5b983a793f3d284ae_720w.webp)

但是别忘了还有一个变量**bUseControllerRotationYaw。前面两种情况的前提是bUseControllerRotationYaw需要设为False。**

![img](https://pic4.zhimg.com/80/v2-53457d01fd0e96eb2e708fd167e2994b_720w.webp)

通常在第一人称或者第三人称，相机跟在角色身后一定位置，玩家的朝向会和Controller的朝向一致，这时候bUseControllerRotationYaw需要设为True。为啥bUseControllerRotationYaw设为True后，玩家的朝向为什么会和Controller的朝向一致？
在**APlayerController::TickActor**中有一段代码。若APlayerController中管理角色输入的对象存在，则会执行**PlayerTick**。

![img](https://pic4.zhimg.com/80/v2-639057f4a13ee79a9ac6e5bfe20fe837_720w.webp)

![img](https://pic1.zhimg.com/80/v2-637722106da24faf76e8bb5227b3c6f8_720w.webp)

在PlayerTick中会先处理玩家的输入**TickPlayerInput**，然后满足条件后会调用**UpdateRotation**。

![img](https://pic1.zhimg.com/80/v2-24485c8fae02d1e11a3966911536ca08_720w.webp)

![img](https://pic2.zhimg.com/80/v2-595a7645059a0b9aeda09bb3c1d7208d_720w.webp)

![img](https://pic1.zhimg.com/80/v2-09d1578301a1a0151a6af71ac3cb16a4_720w.webp)

在UpdateRotation中，先调用**SetControlRotation**给Controller设置好Rotation。紧接着判断Controller绑定的Pawn是否存在，存在则会调用APawn的**FaceRotation**。

![img](https://pic2.zhimg.com/80/v2-b969ebd05b865910314de24056f678f5_720w.webp)

就是在FaceRotation函数中，第三个变量bUseControllerRotationYaw开始了关键的作用。若bUseControllerRotationYaw为True，则设置角色朝向和Controller的朝向一致。

![img](https://pic4.zhimg.com/80/v2-208c25c6e127c46a57f60b8cada4eedf_720w.webp)

![img](https://pic4.zhimg.com/80/v2-d4cbabb53661405f0b92a21cdce4df2f_720w.webp)

至此，我们介绍完了UE是如何让角色移动。
```

`note/UE添加自定义的碰撞类型.md`:

```md
# UE5中添加自定义的碰撞类型

1：项目设置-引擎-碰撞

![image-20240329183038566](.\image-20240329183038566.png)

2：点击 `新建Object通道`，命名，设置想要的默认的碰撞响应

![image-20240329183201839](.\image-20240329183201839.png)

3：保存后，就可以使用了

![image-20240329183629142](.\image-20240329183629142.png)

4：如果想要将这个自定义碰撞类型加入到ECC枚举中（其实不是添加进ECC中，只是取一个未用的通道，取一个别名），我们可以在游戏文件中使用未使用的通道枚举。如下：

```c++
#pragma once

#include "CoreMinimal.h"

#define ECC_SkeletalMesh ECollisionChannel::ECC_GameTraceChannel1	// 骨骼网格 ECC_GameTraceChannel1 用于射线检测 1 代表的是 ECC_GameTraceChannel1 
#define ECC_HitBox ECollisionChannel::ECC_GameTraceChannel2		// 命中框 ECC_GameTraceChannel2 用于射线检测 2 代表的是 ECC_GameTraceChannel2

```

5：然后就可以在代码中进行使用了

```c++
for (const auto& HitCollisionBox : HitCollisionBoxes)
{
	if (HitCollisionBox.Value == nullptr) continue;

	HitCollisionBox.Value->SetCollisionObjectType(ECC_HitBox);		// 设置碰撞对象类型，这是我们自定义的碰撞通道
	HitCollisionBox.Value->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);	// 设置碰撞响应，忽略所有通道
	HitCollisionBox.Value->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);	// 设置碰撞响应，只响应我们自定义的碰撞通道
	HitCollisionBox.Value->SetCollisionEnabled(ECollisionEnabled::NoCollision);	// 设置碰撞启用，不启用碰撞
}
```


```