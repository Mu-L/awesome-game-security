Project Path: arc_TheCruZ_Apex_Legends_Driver_Cheat_7wmd2zxh

Source Tree:

```txt
arc_TheCruZ_Apex_Legends_Driver_Cheat_7wmd2zxh
├── AmazingWindow
│   ├── AmazingWindow
│   │   ├── AmazingWindow.vcxproj
│   │   ├── AmazingWindow.vcxproj.filters
│   │   └── main.cpp
│   └── AmazingWindow.sln
├── Kernel_Driver_Hack.sln
├── LocalStrunder
│   ├── LocalStrunder
│   │   ├── DirectX.cpp
│   │   ├── DirectX.h
│   │   ├── Game.cpp
│   │   ├── Game.h
│   │   ├── LocalStrunder.vcxproj
│   │   ├── LocalStrunder.vcxproj.filters
│   │   ├── custom_structs.h
│   │   ├── driver.cpp
│   │   ├── driver.h
│   │   ├── junk.h
│   │   ├── log.h
│   │   ├── main.cpp
│   │   ├── main.h
│   │   ├── math.cpp
│   │   ├── math.h
│   │   ├── offsets.h
│   │   ├── overlay.cpp
│   │   ├── overlay.h
│   │   ├── server_shared.h
│   │   ├── utils.cpp
│   │   ├── utils.h
│   │   └── vector.h
│   └── LocalStrunder.sln
├── README.MD
└── StrunderSv
    ├── StrunderSv
    │   ├── JUNK.h
    │   ├── StrunderSv.vcxproj
    │   ├── bypass.c
    │   ├── bypass.h
    │   ├── eimport.h
    │   ├── ksocket
    │   │   ├── berkeley.c
    │   │   ├── berkeley.h
    │   │   ├── ksocket.c
    │   │   └── ksocket.h
    │   ├── log.h
    │   ├── main.cpp
    │   ├── packet_handler.cpp
    │   ├── packet_handler.h
    │   ├── server.cpp
    │   ├── server.h
    │   ├── server_shared.h
    │   ├── sockets.h
    │   ├── structs.h
    │   ├── util.cpp
    │   └── util.h
    └── StrunderSv.sln

```

`AmazingWindow/AmazingWindow.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29519.87
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AmazingWindow", "AmazingWindow\AmazingWindow.vcxproj", "{68C049A1-7EA4-45D2-942C-7710AF16B1FA}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{68C049A1-7EA4-45D2-942C-7710AF16B1FA}.Debug|x64.ActiveCfg = Debug|x64
		{68C049A1-7EA4-45D2-942C-7710AF16B1FA}.Debug|x64.Build.0 = Debug|x64
		{68C049A1-7EA4-45D2-942C-7710AF16B1FA}.Release|x64.ActiveCfg = Release|x64
		{68C049A1-7EA4-45D2-942C-7710AF16B1FA}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {CA1CD6B1-E5B8-4031-A3BE-BCFCBAE43EEA}
	EndGlobalSection
EndGlobal

```

`AmazingWindow/AmazingWindow/AmazingWindow.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{68C049A1-7EA4-45D2-942C-7710AF16B1FA}</ProjectGuid>
    <RootNamespace>AmazingWindow</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`AmazingWindow/AmazingWindow/AmazingWindow.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Archivos de origen">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`AmazingWindow/AmazingWindow/main.cpp`:

```cpp
#include <Windows.h>
#include <chrono>
#include <Dwmapi.h> 
#pragma comment(lib, "dwmapi.lib")

const MARGINS margins = { -1 ,-1, -1, -1 };
const wchar_t g_szClassName[] = L"LocalStrunder";

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	WNDCLASSEX wc;
	HWND hwnd;
	MSG Msg;

	wc.cbSize = sizeof(WNDCLASSEX);
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = DefWindowProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = hInstance;
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(RGB(0,0,0));
	wc.lpszMenuName = NULL;
	wc.lpszClassName = g_szClassName;
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

	RegisterClassEx(&wc);

	hwnd = CreateWindowEx(
		WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST,
		g_szClassName,
		g_szClassName,
		WS_POPUP | WS_VISIBLE,
		0, 0, 500, 500,
		NULL, NULL, hInstance, NULL);

	SetLayeredWindowAttributes(hwnd, RGB(0,0,0), 255, LWA_ALPHA);
	DwmExtendFrameIntoClientArea(hwnd, &margins);

	while (GetMessage(&Msg, NULL, 0, 0) > 0)
	{
		TranslateMessage(&Msg);
		DispatchMessage(&Msg);
	}
	return Msg.wParam;
}
```

`Kernel_Driver_Hack.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29519.87
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StrunderSv", "StrunderSv\StrunderSv\StrunderSv.vcxproj", "{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LocalStrunder", "LocalStrunder\LocalStrunder\LocalStrunder.vcxproj", "{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AmazingWindow", "AmazingWindow\AmazingWindow\AmazingWindow.vcxproj", "{68C049A1-7EA4-45D2-942C-7710AF16B1FA}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Debug|x64.ActiveCfg = Debug|x64
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Debug|x64.Build.0 = Debug|x64
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Debug|x64.Deploy.0 = Debug|x64
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Release|x64.ActiveCfg = Release|x64
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Release|x64.Build.0 = Release|x64
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Release|x64.Deploy.0 = Release|x64
		{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}.Debug|x64.ActiveCfg = Debug|x64
		{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}.Debug|x64.Build.0 = Debug|x64
		{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}.Release|x64.ActiveCfg = Release|x64
		{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}.Release|x64.Build.0 = Release|x64
		{68C049A1-7EA4-45D2-942C-7710AF16B1FA}.Debug|x64.ActiveCfg = Debug|x64
		{68C049A1-7EA4-45D2-942C-7710AF16B1FA}.Debug|x64.Build.0 = Debug|x64
		{68C049A1-7EA4-45D2-942C-7710AF16B1FA}.Release|x64.ActiveCfg = Release|x64
		{68C049A1-7EA4-45D2-942C-7710AF16B1FA}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {CA1CD6B1-E5B8-4031-A3BE-BCFCBAE43EEA}
	EndGlobalSection
EndGlobal

```

`LocalStrunder/LocalStrunder.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29403.142
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LocalStrunder", "LocalStrunder\LocalStrunder.vcxproj", "{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}.Debug|x64.ActiveCfg = Debug|x64
		{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}.Debug|x64.Build.0 = Debug|x64
		{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}.Release|x64.ActiveCfg = Release|x64
		{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D6542325-B9BC-4057-A6CD-43137A5535C1}
	EndGlobalSection
EndGlobal

```

`LocalStrunder/LocalStrunder/DirectX.cpp`:

```cpp
#include "DirectX.h"

bool Direct::D3DInit(HWND hwnd,Direct& result)
{
	Direct res = Direct();

    if(FAILED(Direct3DCreate9Ex(D3D_SDK_VERSION, &res.dx_Object)))
        return false;

	res.dx_Params.hDeviceWindow			= hwnd;
	res.dx_Params.MultiSampleQuality	= D3DMULTISAMPLE_NONE;
	res.dx_Params.SwapEffect			= D3DSWAPEFFECT_DISCARD;
	res.dx_Params.BackBufferCount		= 1;
	res.dx_Params.BackBufferFormat		= D3DFMT_A8R8G8B8;
	res.dx_Params.BackBufferWidth		= 0;
	res.dx_Params.BackBufferHeight		= 0;
	res.dx_Params.PresentationInterval	= D3DPRESENT_INTERVAL_ONE;
	res.dx_Params.Windowed				= true;

    if(FAILED(res.dx_Object->CreateDeviceEx(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hwnd, D3DCREATE_HARDWARE_VERTEXPROCESSING, &res.dx_Params, NULL, &res.dx_Device)))
        return false;

	D3DXCreateLine(res.dx_Device, &res.dx_line);
	if (FAILED(D3DXCreateFontA(res.dx_Device, 13, 0, 400, 1, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH, "Courier", &res.dx_font))) {
		return false;
	}

	result = res;
    return true;
}

void Direct::D3DShutdown()
{
	if(dx_Device != NULL)
		dx_Device->Release();
	dx_Device = NULL;
	if(dx_Object != NULL)
		dx_Object->Release();
	dx_Object = NULL;
}

void Direct::Fill(int x, int y, int w, int h, int r, int g, int b, int a)
{
	D3DCOLOR col = D3DCOLOR_ARGB(a,r,g,b);
	D3DRECT rec = { x, y, x+w, y+h };
	dx_Device->Clear(1, &rec, D3DCLEAR_TARGET, col, 0, 0);
}

void Direct::DrawBox(int x,int y,int x2,int y2, int r, int g, int b, int a)
{
	Fill(x-1, y-1, x2+2, 1, r, g, b, a);
	Fill(x-1, y, 1, y2-1, r, g, b, a);
	Fill(x+x2, y, 1, y2-1, r, g, b, a);
	Fill(x-1, y+y2-1, x2+2, 1, r, g, b, a);
}

void Direct::DrawBox2(int x, int y, int width, int height, int r, int g, int b, int a)
{
	D3DCOLOR color = D3DCOLOR_ARGB(a, r, g, b);
	D3DCOLOR clear = D3DCOLOR_ARGB(0, 0, 0, 0);
	D3DRECT rec_paint = { x, y, x+ width, y+ height };
	D3DRECT rec_clear = { x + 1, y + 1, x + width - 1, y + height - 1 };
	dx_Device->Clear(1, &rec_paint, D3DCLEAR_TARGET, color, 0, 0);
	dx_Device->Clear(1, &rec_clear, D3DCLEAR_TARGET, clear, 0, 0);

}

void Direct::DrawString(int x, int y,int a,int r,int g,int b, LPCWSTR text)
{
	D3DCOLOR col = D3DCOLOR_ARGB(a, r, g, b);
	RECT rect;
	rect.left = x;
	rect.top = y;
	rect.right = x+wcslen(text) * 10;
	rect.bottom = y+30;
	dx_font->DrawTextW(NULL, text, -1, &rect, DT_LEFT, col);
}

void Direct::DrawLine(float x, float y, float xx, float yy, int a,int r,int g,int b) {
	D3DXVECTOR2 line[2];
	dx_line->SetWidth(1);
	line[0] = D3DXVECTOR2(x, y);
	line[1] = D3DXVECTOR2(xx, yy);
	dx_line->Draw(line, 2, D3DCOLOR_ARGB(a, r, g, b));
}
```

`LocalStrunder/LocalStrunder/DirectX.h`:

```h
#pragma once

#include <d3d9.h>
#pragma comment(lib, "d3d9.lib")
#include <d3dx9.h>
#pragma comment(lib, "d3dx9.lib")

class Direct
{
public:
	IDirect3D9Ex* dx_Object;
	IDirect3DDevice9Ex* dx_Device;
	D3DPRESENT_PARAMETERS dx_Params;
	LPD3DXLINE dx_line;
	LPD3DXFONT dx_font;

	static bool D3DInit(HWND hwnd,Direct& result);
	void D3DShutdown();
	void Fill(int x, int y, int w, int h, int r, int g, int b, int a);
	void DrawBox(int x,int y,int x2,int y2, int r, int g, int b, int a);
	void DrawBox2(int x, int y, int width, int height, int r, int g, int b, int a);
	void DrawString(int x, int y, int a, int r, int g, int b, LPCWSTR text);
	void DrawLine(float x, float y, float xx, float yy, int a, int r, int g, int b);
};
```

`LocalStrunder/LocalStrunder/Game.cpp`:

```cpp
#include "Game.h"


uintptr_t Entity::Observing(uintptr_t sock, int g_PID, uint64_t entitylist) {
	unsigned long ot = *(unsigned long*)(buffer + OFFSET_OBSERVING_TARGET);
	int index = ot & ENT_ENTRY_MASK;
	int ObserverID = index;
	if (ObserverID > 0) {
		uint64_t centity2 = driver::read<uint64_t>(sock, g_PID, entitylist + ((uint64_t)ObserverID << 5));
		return centity2;
	}
	return 0;
}
int Entity::getTeamId() {
	return *(int*)(buffer + OFFSET_TEAM);
}
int Entity::getHealth() {
	return *(int*)(buffer + OFFSET_HEALTH);
}
int Entity::getShield() {
	return *(int*)(buffer + OFFSET_SHIELD);
}
Vector Entity::getPosition() {
	return *(Vector*)(buffer + OFFSET_ORIGIN);
}
bool Entity::isPlayer() {
	return *(uint64_t*)(buffer + OFFSET_NAME) == 125780153691248;
}
Vector Entity::getBonePosition(uintptr_t sock, int g_PID, int id) {
	Vector position = getPosition();
	uintptr_t boneArray = *(uintptr_t*)(buffer + OFFSET_BONES);
	Vector bone = Vector();
	uint32_t boneloc = (id * 0x30);
	Bone bo = {};
	bo = driver::read<Bone>(sock, g_PID, boneArray + boneloc);
	bone.x = bo.x + position.x;
	bone.y = bo.y + position.y;
	bone.z = bo.z + position.z;
	return bone;
}

QAngle Entity::GetViewAngles()
{
	return *(QAngle*)(buffer + OFFSET_VIEWANGLES);
}

Vector Entity::GetViewAnglesV()
{
	return *(Vector*)(buffer + OFFSET_VIEWANGLES);
}

void Entity::SetViewAngles(uintptr_t sock, int pid, SVector angles)
{
	driver::write<SVector>(sock, pid, ptr + OFFSET_VIEWANGLES, angles);
}
void Entity::SetViewAngles(uintptr_t sock, int pid, QAngle& angles)
{
	SetViewAngles(sock, pid, SVector(angles));
}

Vector Entity::GetCamPos()
{
	return *(Vector*)(buffer + OFFSET_CAMERAPOS);
}

QAngle Entity::GetRecoil()
{
	return *(QAngle*)(buffer + OFFSET_AIMPUNCH);
}

float CalculateFov(Entity& from, Entity& target) {
	QAngle ViewAngles = from.GetViewAngles();
	Vector LocalCamera = from.GetCamPos();
	Vector EntityPosition = target.getPosition();
	QAngle Angle = Math::CalcAngle(LocalCamera, EntityPosition);
	return Math::GetFov(ViewAngles, Angle);
}

QAngle CalculateBestBoneAim(SOCKET sock, int pid, Entity& from, uintptr_t t, float max_fov, int spectators) {
	Entity target = getEntity(sock, pid, t);
	int health = target.getHealth();
	if (health < 1 || health > 100) {
		return QAngle(0, 0, 0);
	}

	Vector EntityPosition = target.getPosition();
	Vector LocalPlayerPosition = from.getPosition();
	float dist = LocalPlayerPosition.DistTo(EntityPosition);

	int bone = 2;
	if (dist < 500) {
		bone = 5;
	}

	Vector LocalCamera = from.GetCamPos();
	Vector BonePosition = target.getBonePosition(sock,pid,bone);
	QAngle CalculatedAngles = Math::CalcAngle(LocalCamera, BonePosition);
	QAngle ViewAngles = from.GetViewAngles();
	QAngle Delta = CalculatedAngles - ViewAngles;

	double fov = Math::GetFov(ViewAngles, CalculatedAngles);
	if (fov > max_fov) {
		return QAngle(0, 0, 0);
	}

	QAngle RecoilVec = from.GetRecoil();
	if (RecoilVec.x != 0 || RecoilVec.y != 0) {
		Delta -= RecoilVec;
	}

	

	double smooth = 60.0f;
	if (spectators > 0) {
		smooth = 80.0f;
	}

	Math::NormalizeAngles(Delta);
	if (fov > 2.0f || spectators>0) {
		if (Delta.x > 0.0f) {
			Delta.x /= smooth;
		}
		else {
			Delta.x = ((Delta.x * -1L) / smooth) * -1;
		}

		if (Delta.y > 0.0f) {
			Delta.y /= smooth;
		}
		else {
			Delta.y = ((Delta.y * -1L) / smooth) * -1;
		}
	}

	QAngle SmoothedAngles = ViewAngles + Delta;


	Math::NormalizeAngles(SmoothedAngles);

	return SmoothedAngles;
}

Entity getEntity(uintptr_t sock, int g_PID, uintptr_t ptr) {
	Entity entity = Entity();
	entity.ptr = ptr;
	driver::read_memory(sock, g_PID, ptr, (uintptr_t)entity.buffer, 0x2FF0);
	return entity;
}

bool WorldToScreen(Vector from, float* m_vMatrix, int targetWidth, int targetHeight, Vector& to)
{
	float w = m_vMatrix[12] * from.x + m_vMatrix[13] * from.y + m_vMatrix[14] * from.z + m_vMatrix[15];

	if (w < 0.01f) return false;

	to.x = m_vMatrix[0] * from.x + m_vMatrix[1] * from.y + m_vMatrix[2] * from.z + m_vMatrix[3];
	to.y = m_vMatrix[4] * from.x + m_vMatrix[5] * from.y + m_vMatrix[6] * from.z + m_vMatrix[7];

	float invw = 1.0f / w;
	to.x *= invw;
	to.y *= invw;

	float x = targetWidth / 2;
	float y = targetHeight / 2;

	x += 0.5 * to.x * targetWidth + 0.5;
	y -= 0.5 * to.y * targetHeight + 0.5;

	to.x = x;
	to.y = y;
	to.z = 0;

	return true;
}

```

`LocalStrunder/LocalStrunder/Game.h`:

```h
#pragma once
#include <stdio.h>
#include "driver.h"
#include "math.h"
#include "offsets.h"

#define NUM_ENT_ENTRIES			(1 << 12)
#define ENT_ENTRY_MASK			(NUM_ENT_ENTRIES - 1)

struct Bone {
	BYTE shit[0xCC];
	float x;
	BYTE shit2[0xC];
	float y;
	BYTE shit3[0xC];
	float z;
};
class Entity {
public:
	uint64_t ptr;
	BYTE buffer[0x2FF0];
	Vector getPosition();
	bool isPlayer();
	int getTeamId();
	int getHealth();
	int getShield();
	QAngle GetViewAngles();
	Vector GetCamPos();
	QAngle GetRecoil();
	Vector GetViewAnglesV();

	void SetViewAngles(uintptr_t sock, int pid, SVector angles);
	void SetViewAngles(uintptr_t sock, int pid, QAngle& angles);
	Vector getBonePosition(uintptr_t sock, int g_PID, int id);
	uintptr_t Observing(uintptr_t sock, int g_PID, uint64_t entitylist);

private:
	struct Bone {
		BYTE shit[0xCC];
		float x;
		BYTE shit2[0xC];
		float y;
		BYTE shit3[0xC];
		float z;
	};
};
Entity getEntity(uintptr_t sock, int g_PID, uintptr_t ptr);
bool WorldToScreen(Vector from, float* m_vMatrix, int targetWidth, int targetHeight, Vector& to);
//Vector GetEntityBasePosition(SOCKET sock, int pid, uintptr_t ent);
//uintptr_t GetEntityBoneArray(SOCKET sock, int pid, uintptr_t ent);
//Vector GetEntityBonePosition(SOCKET sock, int pid, uintptr_t ent, uint32_t BoneId, Vector BasePosition);
//QAngle GetViewAnglesA(SOCKET sock, int pid, uintptr_t ent);
//void SetViewAngles(SOCKET sock, int pid, uintptr_t ent, SVector angles);
//void SetViewAngles(SOCKET sock, int pid, uintptr_t ent, QAngle angles);
//Vector GetCamPos(SOCKET sock, int pid, uintptr_t ent);
float CalculateFov(Entity& from, Entity& target);
QAngle CalculateBestBoneAim(SOCKET sock, int pid, Entity& from, uintptr_t target, float max_fov, int spectators);
```

`LocalStrunder/LocalStrunder/LocalStrunder.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{9BF6CD05-63DA-49CF-905E-B82F5F24AC6E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>LocalStrunder</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <LibraryPath>$(DXSDK_DIR)Lib\x64;$(LibraryPath)</LibraryPath>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x64;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3d11.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3d11.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="DirectX.cpp" />
    <ClCompile Include="Game.cpp" />
    <ClCompile Include="overlay.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="driver.cpp" />
    <ClCompile Include="math.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
    <ClInclude Include="DirectX.h" />
    <ClInclude Include="Game.h" />
    <ClInclude Include="junk.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="main.h" />
    <ClInclude Include="offsets.h" />
    <ClInclude Include="overlay.h" />
    <ClInclude Include="custom_structs.h" />
    <ClInclude Include="math.h" />
    <ClInclude Include="server_shared.h" />
    <ClInclude Include="utils.h" />
    <ClInclude Include="vector.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`LocalStrunder/LocalStrunder/LocalStrunder.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Headers">
      <UniqueIdentifier>{09a8a2aa-6277-49bc-bb28-4446ac81fb47}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="utils.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="driver.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="math.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="DirectX.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="overlay.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="math.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="server_shared.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="vector.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="DirectX.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="overlay.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="offsets.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="main.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="junk.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="log.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="custom_structs.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Game.h">
      <Filter>Headers</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`LocalStrunder/LocalStrunder/custom_structs.h`:

```h
#pragma once

//Structs
struct Fade {
	float f1;
	float f2;
	float f3;
	float f4;
	float f5;
	float f6;
	Fade(float amount) {
		f1 = amount;
		f2 = amount;
		f3 = amount;
		f4 = amount;
		f5 = amount;
		f6 = amount;
	}
};

struct Color {
	float r;
	float g;
	float b;
	Color() {
	}
	Color(float r1, float g1, float b1) {
		r = r1;
		g = g1;
		b = b1;
	}
};
```

`LocalStrunder/LocalStrunder/driver.cpp`:

```cpp
#include "driver.h"

int driver::currentProcessId = 0;
// Link to winsock.
#pragma comment(lib, "Ws2_32")

#pragma warning(disable : 4267)

// Send request packet and wait for completion.
static bool send_packet(
	const SOCKET	connection,
	const Packet& packet,
	uint64_t& out_result)
{
	Packet completion_packet{ };

	if (send(connection, (const char*)&packet, sizeof(Packet), 0) == SOCKET_ERROR)
		return false;

	const auto result = recv(connection, (char*)&completion_packet, sizeof(Packet), 0);
	if (result < sizeof(PacketHeader) ||
		//completion_packet.header.magic != packet_magic ||
		completion_packet.header.type != PacketType::packet_completed)
		return false;

	out_result = completion_packet.data.completed.result;
	return true;
}
uint64_t driver::get_process_pid(SOCKET connection, wchar_t pname[], size_t size)
{
	J();
	Packet packet{ };

	//packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_get_pid;

	J();
	auto& data = packet.data.get_pid;
	memset(data.name, 0x00, 256);
	memcpy(data.name, pname, size*2);
	data.len = size;

	uint64_t result = 0;
	if (send_packet(connection, packet, result)) {
		
		memset(data.name, 0x00, 256);
		return result;
	}
	memset(data.name, 0x00, 256);

	return 0;
}
uint64_t driver::get_process_base_address(const SOCKET connection, const uint32_t process_id)
{
	J();
	Packet packet{ };

	//packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_get_base_address;

	J();
	auto& data = packet.data.get_base_address;
	data.process_id = process_id;

	uint64_t result = 0;
	if (send_packet(connection, packet, result))
		return result;

	return 0;
}
static uint32_t copy_memory(
	const SOCKET	connection,
	const uint32_t	src_process_id,
	const uintptr_t src_address,
	const uint32_t	dest_process_id,
	const uintptr_t	dest_address,
	const size_t	size)
{
	Packet packet{ };

	//packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_copy_memory;

	auto& data = packet.data.copy_memory;
	data.src_process_id = src_process_id;
	data.src_address = uint64_t(src_address);
	data.dest_process_id = dest_process_id;
	data.dest_address = uint64_t(dest_address);
	data.size = uint64_t(size);

	uint64_t result = 0;
	if (send_packet(connection, packet, result))
	{
		return uint32_t(result);
	}

	return 0;
}
void driver::initialize()
{
	J();
	WSADATA wsa_data;
	WSAStartup(MAKEWORD(2, 2), &wsa_data);
	currentProcessId = GetCurrentProcessId();
}



SOCKET driver::connect()
{
	J();
	SOCKADDR_IN address{ };

	address.sin_family = AF_INET;
	address.sin_addr.s_addr = htonl(server_ip);
	address.sin_port = htons(server_port);

	const auto connection = socket(AF_INET, SOCK_STREAM, 0);
	if (connection == INVALID_SOCKET)
		return INVALID_SOCKET;

	J();
	if (connect(connection, (SOCKADDR*)&address, sizeof(address)) == SOCKET_ERROR)
	{
		closesocket(connection);
		return INVALID_SOCKET;
	}

	return connection;
}

void driver::disconnect(const SOCKET connection)
{
	J();
	closesocket(connection);
}
void driver::deinitialize()
{
	J();
	WSACleanup();
}
uint32_t driver::read_memory(
	const SOCKET	connection,
	const uint32_t	process_id,
	const uintptr_t address,
	const uintptr_t buffer,
	const size_t	size)
{
	return copy_memory(connection, process_id, address, currentProcessId, buffer, size);
}

uint32_t driver::write_memory(
	const SOCKET	connection,
	const uint32_t	process_id,
	const uintptr_t address,
	const uintptr_t buffer,
	const size_t	size)
{
	return copy_memory(connection, currentProcessId, buffer, process_id, address, size);
}


```

`LocalStrunder/LocalStrunder/driver.h`:

```h
#pragma once
#include <WinSock2.h>
#include "server_shared.h"
#include "junk.h"

namespace driver
{
	void	initialize();
	void	deinitialize();
	extern int currentProcessId;
	SOCKET	connect();
	void	disconnect(SOCKET connection);

	uint32_t read_memory(SOCKET connection, uint32_t process_id, uintptr_t address, uintptr_t buffer, size_t size);
	uint32_t write_memory(SOCKET connection, uint32_t process_id, uintptr_t address, uintptr_t buffer, size_t size);
	uint64_t get_process_base_address(SOCKET connection, uint32_t process_id);
	uint64_t get_process_pid(SOCKET connection, wchar_t pname[], size_t size);

	template <typename T>
	T read(const SOCKET connection, const uint32_t process_id, const uintptr_t address)
	{		
		T buffer{ };

		read_memory(connection, process_id, address, uint64_t(&buffer), sizeof(T));

		return buffer;
	}

	template <typename T>
	void write(const SOCKET connection, const uint32_t process_id, const uintptr_t address, const T& buffer)
	{
		write_memory(connection, process_id, address, uint64_t(&buffer), sizeof(T));
	}
}
```

`LocalStrunder/LocalStrunder/junk.h`:

```h
#pragma once
//JUNK
#define J() UsefulFuntion(24567, 3324, 4537, 2345,30.2f);

inline int UsefulFuntion(int x, int y, int z, int r, float ks)
{
	ks /= 2;
	for (int i = 2; i < 8; i++)
	{
		z += 456;
		r -= 55;
		x++;
		y--;

	}
	for (int i = 0; i < 2; i++)
	{
		x++;
		y += 234;
		z -= 23;
		r += 634;
	}
	return x + z + r + y;
}
```

`LocalStrunder/LocalStrunder/log.h`:

```h
#pragma once
//LOGs
#ifdef _DEBUG
#define log(text,...) //printf(text,__VA_ARGS__)
#else
#define log(text,...)
#endif
```

`LocalStrunder/LocalStrunder/main.cpp`:

```cpp
#include "main.h"

bool active = true;
SOCKET g_Sock;
SOCKET g_Sock2;
SOCKET g_Sock3;
DWORD g_PID;
uint64_t g_Base;

uintptr_t aimentity = 0;
uintptr_t tmp_aimentity = 0;
float max = 999.0f;
int team_player = 0;
int spectators = 0;
int tmp_spectators = 0;
int playerId = 0;
int s_FOV = 15;
int toRead = 150;

unsigned long getms() {
	namespace sc = std::chrono;
	sc::milliseconds ms = sc::duration_cast<sc::milliseconds>(sc::system_clock::now().time_since_epoch());
	return ms.count();
}

void ProcessPlayer(SOCKET sock, Entity& LPlayer, Entity& target, UINT64 entitylist) {
	if (target.Observing(sock, g_PID, entitylist) == LPlayer.ptr) {
		tmp_spectators++;
		system("color 4E");
	}

	Vector EntityPosition = target.getPosition();
	Vector LocalPlayerPosition = LPlayer.getPosition();
	float dist = LocalPlayerPosition.DistTo(EntityPosition);
	if (dist > 8000.0f) return;

	int health = target.getHealth();
	if (health < 1 || health > 100)
		return;

	int entity_team = target.getTeamId();
	if (entity_team < 0 || entity_team>50 || entity_team == team_player) return;

	//driver::write<BYTE>(sock, g_PID, centity + OFFSET_GLOW_ENABLE, 1);
	//driver::write<BYTE>(sock, g_PID, centity + OFFSET_GLOW_CONTEXT, 1);
	//driver::write<Color>(sock, g_PID, centity + OFFSET_GLOW_COLORS, Color(50.0f,0.0f,0.0f));
	//driver::write<Fade>(sock, g_PID, centity + OFFSET_GLOW_FADE, Fade(FLT_MAX));
	//driver::write<float>(sock, g_PID, centity + OFFSET_GLOW_RANGE, FLT_MAX);

	float fov = CalculateFov(LPlayer, target);
	if (fov < max) {
		max = fov;
		tmp_aimentity = target.ptr;
	}
}

void DoActions() {
	SOCKET sock = g_Sock;
	J();
	unsigned long ms = getms();
	while (active)
	{
		Sleep(1);
		J();
		if (GetKeyState(0x73) & 0x8000) {
			active = false;
			break;
		}
		if (getms() - 500UL > ms) {
			uint64_t LocalPlayer = driver::read<uint64_t>(sock, g_PID, g_Base + OFFSET_LOCAL_ENT);
			if (LocalPlayer == 0) break;

			Entity LPlayer = getEntity(sock, g_PID, LocalPlayer);

			team_player = LPlayer.getTeamId();
			if (team_player < 0 || team_player>50) break;

			ms = getms();
			uint64_t entitylist = g_Base + OFFSET_ENTITYLIST;

			uint64_t baseent = driver::read<uint64_t>(sock, g_PID, entitylist);
			if (baseent == 0) break;

			max = 999.0f;
			int cc = 0;
			tmp_spectators = 0;
			int lastIndexReadedCorrectly = 0;

			for (int i = 0; i <= toRead; i++)
			{
				uint64_t centity = driver::read<uint64_t>(sock, g_PID, entitylist + ((uint64_t)i << 5));
				if (centity == 0) continue;
				if (LocalPlayer == centity) continue;

				Entity Target = getEntity(sock, g_PID, centity);
				if (!Target.isPlayer()) continue;

				cc++;
				lastIndexReadedCorrectly = i;

				ProcessPlayer(sock, LPlayer, Target, entitylist);
			}
			if (toRead == 0) {
				toRead = 150;
			}
			else if (lastIndexReadedCorrectly < toRead) {
				toRead = lastIndexReadedCorrectly;
			}
			else {
				toRead += 5;
			}
			spectators = tmp_spectators;
			if (spectators > 0) {
				system("color 4E");
			}
			else {
				system("color 07");
			}
			printf("%d pr %d sp %d tr\n", cc, spectators, toRead);
			aimentity = tmp_aimentity;
		}
	}
}

static DWORD WINAPI ALoop(void* params) {
	SOCKET sock = g_Sock3;
	while (active) {
		Sleep(1);
		if (aimentity == 0 || g_PID == 0 || g_Base == 0 || !(GetKeyState(VK_RBUTTON) & 0x8000))
			continue;
		uint64_t LocalPlayer = driver::read<uint64_t>(sock, g_PID, g_Base + OFFSET_LOCAL_ENT);
		if (LocalPlayer == 0) continue;
		Entity LPlayer = getEntity(sock, g_PID, LocalPlayer);
		//Aimbot
		QAngle Angles = CalculateBestBoneAim(sock, g_PID, LPlayer, aimentity, s_FOV, spectators==0?tmp_spectators:spectators);
		if (Angles.x == 0 && Angles.y == 0) {
			continue;
		}
		LPlayer.SetViewAngles(sock, g_PID, Angles);
	}
	return 0;
}

void render(void* ovv) {
	if (g_PID == 0 || g_Base == 0) {
		return;
	}
	Overlay* ov = (Overlay*)ovv;
	Direct dx = ov->CurrentDirectX;
	SOCKET sock = g_Sock2;

	uint64_t LocalPlayer = driver::read<uint64_t>(sock, g_PID, g_Base + OFFSET_LOCAL_ENT);
	if (LocalPlayer == 0) return;
	Entity LPlayer = getEntity(sock, g_PID, LocalPlayer);
	team_player = LPlayer.getTeamId();
	if (team_player < 0 || team_player>50) return;
	Vector LocalPlayerPosition = LPlayer.getPosition();

	uint64_t viewRenderer = driver::read<uint64_t>(sock, g_PID, g_Base + OFFSET_RENDER);
	uint64_t viewMatrix = driver::read<uint64_t>(sock, g_PID, viewRenderer + OFFSET_MATRIX);
	Matrix m = driver::read<Matrix>(sock, g_PID, viewMatrix);

	uint64_t entitylist = g_Base + OFFSET_ENTITYLIST;
	for (int i = 0; i <= toRead; i++)
	{
		uint64_t centity = driver::read<uint64_t>(sock, g_PID, entitylist + ((uint64_t)i << 5));
		if (centity == 0) continue;
		if (LocalPlayer == centity) continue;

		Entity Target = getEntity(sock, g_PID, centity);
		if (!Target.isPlayer()) continue;

		int health = Target.getHealth();
		if (health < 1 || health > 100) continue;

		int entity_team = Target.getTeamId();
		if (entity_team < 0 || entity_team>50 || entity_team == team_player) continue;

		Vector EntityPosition = Target.getPosition();
		float dist = LocalPlayerPosition.DistTo(EntityPosition);
		if (dist > 8000.0f || dist < 50.0f) continue;

		Vector bs = Vector();
		WorldToScreen(EntityPosition, m.matrix, ov->getWidth(), ov->getHeight(), bs);
		if (bs.x > 0 && bs.y > 0) {
			Vector hs = Vector();
			Vector HeadPosition = Target.getBonePosition(sock, g_PID, 8);
			WorldToScreen(HeadPosition, m.matrix, ov->getWidth(), ov->getHeight(), hs);
			float height = abs(abs(hs.y) - abs(bs.y));
			float width = height / 2.6f;
			float boxMiddle = bs.x - (width / 2);


			std::wstring distance = std::to_wstring(dist / 39.62);
			distance = distance.substr(0, distance.find('.')) + L"m";


			dx.Fill(hs.x - 2.5f, hs.y, 5, 5, 0, 0, 255, 255); //HEAD
			dx.DrawBox2(boxMiddle, hs.y, width, height, 255, 0, 0, 255); //BOX
			dx.DrawString(boxMiddle, bs.y + 1, 255, 0, 255, 0, distance.c_str());  //DISTANCE
			dx.DrawLine(ov->getWidth() / 2, ov->getHeight(), bs.x, bs.y, 255, 0, 0, 255); //LINE FROM MIDDLE SCREEN
		}
	}
}

void getPID() {

	std::wstring xw = std::wstring(L"5a");
	
	while (g_PID == 0)
	{
		if (GetKeyState(0x73) & 0x8000) {
			active = false;
			break;
		}
		printf("NP\n");
		Sleep(5000);
		std::wstring yw = (std::wstring(L"r") + xw + std::wstring(L"pe") + std::wstring(L"x.exe"));
		const wchar_t* ptr = yw.c_str();
		g_PID = driver::get_process_pid(g_Sock,(wchar_t *)ptr, yw.length());
		
		memset((void*)&ptr[0],0x00,yw.size()*2);
		yw.clear();
	}
	printf("P %d\n", g_PID);
}

bool getBase() {
	g_Base = driver::get_process_base_address(g_Sock, g_PID);
	if (g_Base == 0)
	{
		log("Failed  to get base address!");
		g_PID = 0;
		Sleep(500);
		return false;
	}
	printf("B %p\n", g_Base);
	return true;
}

int main(int argc, char** argv)
{
	if (argc > 1) {
		driver::initialize();
		g_Sock = driver::connect();
		driver::deinitialize();
		exit(0);
		return 0;
	}
	J();
	log("Connecting to driver...");
	driver::initialize();
	J();
	log("Connecting...");
	g_Sock = driver::connect();
	g_Sock2 = driver::connect();
	g_Sock3 = driver::connect();
	if (g_Sock == INVALID_SOCKET || g_Sock2 == INVALID_SOCKET || g_Sock3 == INVALID_SOCKET)
	{
		log("Connection failed!");
		Sleep(500);
		exit(0);
		return 0;
	}
	Overlay ov1 = Overlay();
	ov1.SetRender(render);
	ov1.Start();

	DWORD tid = 0;
	CreateThread(0, 0, ALoop, 0, 0, &tid);
	while (active) {
		getPID();
		if (!getBase()) continue;

		ov1.SetTargetHWND(Utils::FindMainWindow(g_PID));

		if (!ov1.isRunning()) {
			ov1.Start();
		}

		DoActions();

		g_PID = 0;
		g_Base = 0;
	}
	ov1.Clear();
	active = false;
	driver::deinitialize();
	J();
	return 0;
}

//uint64_t nextEntity = entitylist;
//while (true)
//{
//	uint64_t centity = driver::read<uint64_t>(g_Sock, g_PID, nextEntity);
//	if (centity == 0) {
//		break;
//	}

//	nextEntity = driver::read<uint64_t>(g_Sock, g_PID, nextEntity + 24);
//	if (nextEntity == 0) {
//		break;
//	}




//void ItemsLoop() {
//	printf("ilog O\n");
//	J();
//	while (active)
//	{
//		Sleep(100);
//		J();
//
//		if (GetKeyState(0x73) & 0x8000) {
//			active = false;
//			break;
//		}
//
//		if (g_PID == 0 || g_Base == 0) continue;
//
//		uint64_t LocalPlayer = driver::read<uint64_t>(g_Sock2, g_PID, g_Base + OFFSET_LOCAL_ENT);
//		if (LocalPlayer == 0) continue;
//
//		uint64_t entitylist = g_Base + OFFSET_ENTITYLIST;
//
//
//		uint64_t baseent = driver::read<uint64_t>(g_Sock2, g_PID, entitylist);
//		if (baseent == 0) continue;
//
//		int itemsGold = 0;
//		uint64_t nextEntity = entitylist;
//		while (true)
//		{
//			uint64_t centity = driver::read<uint64_t>(g_Sock2, g_PID, nextEntity);
//			if (centity == 0) {
//				continue;
//			}
//
//			nextEntity = driver::read<uint64_t>(g_Sock2, g_PID, nextEntity + 24);
//			if (nextEntity == 0) {
//				break;
//			}
//
//			if (LocalPlayer == centity) continue;
//			//int x = driver::read<int>(g_Sock, g_PID, centity + 0x2FD0);
//
//			uint64_t name = driver::read<uint64_t>(g_Sock2, g_PID, centity + OFFSET_NAME);
//			if (name == 125780153691248) {
//				continue;
//			}
//
//
//			Color u = driver::read<Color>(g_Sock2, g_PID, centity + 0x1B8);
//			if (!(u.r == 1.0f && u.g < 0.81f && u.g > 0.79f && u.b < 0.25f) &&
//				!(u.r > 0.48f && u.r < 0.50f && u.g == 0.0f && u.b == 1.0f)) {//0.490196 0.000000 1.000000
//				continue;
//			}
//			itemsGold++;
//			//Vector EntityPosition = GetEntityBasePosition(centity);
//			//Vector LocalPlayerPosition = GetEntityBasePosition(LocalPlayer);
//			//float dist = LocalPlayerPosition.DistTo(EntityPosition);
//			//if (dist > 150.0f) continue;
//
//
//			//dpm
//			//driver::write<int>(g_Sock, g_PID, centity + 0x278, 0x4D407D7E); //raton encima cosa//136 cuando no į
//
//			//driver::write<float>(g_Sock, g_PID, centity + 0x2D4, 100.0f); //IDK
//
//			//driver::write<Color>(g_Sock, g_PID, centity + 0x1B8, Color(1.0f, 0.0f, 0.0f));
//
//			//dpm2
//			driver::write<BYTE>(g_Sock2, g_PID, centity + 0x27B, 0x40);
//			driver::write<BYTE>(g_Sock2, g_PID, centity + 0x27A, 0x50); // border size
//			driver::write<BYTE>(g_Sock2, g_PID, centity + 0x279, 0x7D); // ITEM glow status
//			driver::write<BYTE>(g_Sock2, g_PID, centity + 0x278, 0x88); //raton encima cosa//0x88 cuando no į
//
//			driver::write<BYTE>(g_Sock2, g_PID, centity + 0x2D4, 0x01); //IDK
//
//
//			//driver::write<Color>(g_Sock, g_PID, centity + 0x1B8, Color(1.0f, 0.0f, 0.0f));
//
//
//		}
//		printf("%d gi\n", itemsGold);
//		
//	}
//}


				//std::ofstream myfile;
				//myfile.open("C:\\Nlog.txt", std::ios::out | std::ios::app);
				//myfile << "Ent(" << std::hex << centity << ")\n";
				//for (int offset = 0x0; offset <= 0x2FF0; offset += 0x4)
				//	myfile << std::hex << offset << " -> " << driver::read<int>(g_Sock, g_PID, centity + offset) << "\n";
				//myfile.close();
				//printf("printed\n");
```

`LocalStrunder/LocalStrunder/main.h`:

```h
#pragma once

#define _WINSOCKAPI_
#include <windows.h>
#include <time.h>
#include <chrono>
#include <fstream>
#include <iostream>
#include <WinSock2.h>
#include <thread>

#include "vector.h"
#include "math.h"
#include "offsets.h"
#include "junk.h"
#include "log.h"
#include "custom_structs.h"
#include "driver.h"
#include "utils.h"
#include "overlay.h"
//#include "DirectX.h"
#include "Game.h"

struct Matrix {
	float matrix[16];
};
```

`LocalStrunder/LocalStrunder/math.cpp`:

```cpp
#include "math.h"

void Math::NormalizeAngles(QAngle& angle)
{
	while (angle.x > 89.0f)
		angle.x -= 180.f;

	while (angle.x < -89.0f)
		angle.x += 180.f;

	while (angle.y > 180.f)
		angle.y -= 360.f;

	while (angle.y < -180.f)
		angle.y += 360.f;
}

QAngle Math::CalcAngle(const Vector& src, const Vector& dst)
{
	QAngle angle = QAngle();
	SVector delta = SVector((src.x - dst.x), (src.y - dst.y), (src.z - dst.z));

	double hyp = sqrt(delta.x*delta.x + delta.y * delta.y);

	angle.x = atan(delta.z / hyp) * (180.0f / M_PI);
	angle.y = atan(delta.y / delta.x) * (180.0f / M_PI);
	angle.z = 0;
	if (delta.x >= 0.0) angle.y += 180.0f;

	return angle;
}

double Math::GetFov(const QAngle& viewAngle, const QAngle& aimAngle)
{
	QAngle delta = aimAngle - viewAngle;
	NormalizeAngles(delta);

	return sqrt(pow(delta.x, 2.0f) + pow(delta.y, 2.0f));
}

double Math::DotProduct(const Vector& v1, const float* v2)
{
	return v1.x * v2[0] + v1.y * v2[1] + v1.z * v2[2];
}
```

`LocalStrunder/LocalStrunder/math.h`:

```h
#pragma once
#include <math.h>
#include "vector.h"

struct SVector {
	float x;
	float y;
	float z;
	SVector(float x1, float y1, float z1) {
		x = x1;
		y = y1;
		z = z1;
	}
	SVector(QAngle q) {
		x = q.x;
		y = q.y;
		z = q.z;
	}
};

namespace Math {
	void NormalizeAngles(QAngle& angle);
	double GetFov(const QAngle& viewAngle, const QAngle& aimAngle);
	double DotProduct(const Vector& v1, const float* v2);
	QAngle CalcAngle(const Vector& src, const Vector& dst);
}
```

`LocalStrunder/LocalStrunder/offsets.h`:

```h
#pragma once
//Offsets
#define OFFSET_ENTITYLIST			0x183F118
#define OFFSET_LOCAL				0x1038934
#define OFFSET_LOCAL_ENT			0x1D9AB98 //(grapple_swingPullAngle+0xA8)0x022E93F8


#define OFFSET_TEAM					0x3F0
#define OFFSET_HEALTH				0x3E0
#define OFFSET_NAME					0x521
#define OFFSET_SHIELD				0x170


#define OFFSET_ORIGIN				0x14C
#define OFFSET_BONES				0xEE0
#define OFFSET_AIMPUNCH				0x20C0
#define OFFSET_CAMERAPOS			0x1B64
#define OFFSET_VIEWANGLES			0x2188
#define OFFSET_OBSERVING_TARGET		0x2F40

#define OFFSET_MATRIX 0x1A93D0
#define OFFSET_RENDER 0xCAB13F8


//W2S pattern (view render and view matrix) 48 89 ?? ?? ?? 57 48 83 EC ?? 48 8B D9 48 8B FA 48 8B 0D ?? ?? ?? ?? 33 D2 48 8B 01 FF



//#define OFFSET_BULLET_VELOCITY		0x1C90
//#define OFFSET_ENTITY_VELOCITY		0x41C
//#define OFFSET_LAST_WEAPON			0x1704
//m_vecVelocity = 0x41C
//ViewRender = 0xD4138F0
//ViewAngle = 0x2188
//m_bleedoutState = 0x2348
//EntityCount = 0xC01BAA0
//#define OFFSET_GLOW_FADE			0x2D0
//#define OFFSET_GLOW_ENABLE			0x390
//#define OFFSET_GLOW_CONTEXT			0x310
//#define OFFSET_GLOW_FADE			0x2B8
//#define OFFSET_GLOW_FADE_MAX		(OFFSET_GLOW_FADE+0x18)
//#define OFFSET_GLOW_COLORS			0x1D0
//#define OFFSET_GLOW_MAGIC			0x278
//#define OFFSET_GLOW_RANGE			0x2FC
//#define OFFSET_GLOW_BORDER_SIZE		0x280
```

`LocalStrunder/LocalStrunder/overlay.cpp`:

```cpp
#include "overlay.h"

bool moving = false;

static DWORD WINAPI StaticPosStart(void* Param)
{
	Overlay* ov = (Overlay*)Param;
	ov->UpdatePosition();
	return 0;
}

static DWORD WINAPI StaticMessageStart(void* Param)
{
	Overlay* ov = (Overlay*)Param;
	ov->CreateOverlay();
	return 0;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
{
	switch (message)
	{
	case WM_DESTROY:
		PostQuitMessage(1);
		return 0;

	default:
		return DefWindowProc(hwnd, message, wparam, lparam);
	}

	return 0;
}

unsigned long getmsx() {
	namespace sc = std::chrono;
	sc::milliseconds ms = sc::duration_cast<sc::milliseconds>(sc::system_clock::now().time_since_epoch());
	return ms.count();
}

BOOL CALLBACK EnumWindowsCallback(HWND hwnd, LPARAM lParam) {
	wchar_t className[255] = L"";
	GetClassName(hwnd, className, 255);
	if (wcscmp(L"LocalStrunder", className) == 0) {
		Process_Informations* proc = (Process_Informations*)lParam;
		proc->overlayHWND = hwnd;
		return TRUE;
	}
	return TRUE;
}

DWORD Overlay::CreateOverlay()
{
	EnumWindows(EnumWindowsCallback, (LPARAM)&proc);
	Sleep(300);
	if (proc.overlayHWND == 0) {
		printf("ReNotFound\n");
		Sleep(1000);
		exit(0);
	}

	if (!Direct::D3DInit(proc.overlayHWND, CurrentDirectX)) {
		//CloseWindow(proc.overlayHWND);
		//UnregisterClass(proc.className, NULL);
		return 1;
	}

	if (CurrentDirectX.dx_Device == 0 ||
		CurrentDirectX.dx_Object == 0) {
		CurrentDirectX.D3DShutdown();
		//CloseWindow(proc.overlayHWND);
		//UnregisterClass(proc.className, NULL);
		return 1;
	}
	running = 1;
	DWORD ThreadID;
	CreateThread(NULL, 0, StaticPosStart, (void*)this, 0, &ThreadID);
	int rs = 255;
	int gs = 0;
	int bs = 0;
	unsigned long msx = getmsx();
	LPCWSTR title = L"Local Strunder";
	int wtime = 1000 / 20;  // fps rate limit
	while (running) {
		
		//if (PeekMessage(&proc.msg, proc.overlayHWND, NULL, NULL, PM_REMOVE))
		//{
		//	TranslateMessage(&proc.msg);
		//	DispatchMessage(&proc.msg);
		//}
		if (moving) {
			Sleep(25);
			continue;
		}
		unsigned long ms = getmsx();
		if (CurrentDirectX.dx_Device != 0) {
			try {
				CurrentDirectX.dx_Device->Clear(NULL, NULL, D3DCLEAR_TARGET, D3DCOLOR_ARGB(0, 0, 0, 0), 1.0f, NULL);
				CurrentDirectX.dx_Device->BeginScene();
				CurrentDirectX.DrawString(10, 10, 255, rs, gs, bs, title);
				Render();
				CurrentDirectX.dx_Device->EndScene();
				CurrentDirectX.dx_Device->Present(NULL, NULL, NULL, NULL);
			}
			catch (...) {
			}
		}
		unsigned long ms2 = getmsx()-ms;
		if (ms2 < wtime) {
			Sleep(wtime - ms2);
		}
		if (ms>msx+250) {
			msx = getmsx();
			if (rs == 255) {
				rs = 0;
				gs = 255;
			}
			else if (gs == 255) {
				gs = 0;
				bs = 255;
			}
			else {
				bs = 0;
				rs = 255;
			}
		}

	}
	return 0;
}

void Overlay::UpdatePosition() {
	RECT rect;
	while (running) {
		Sleep(2000);
		SetLastError(0);
		GetWindowRect(proc.targetHWND, &rect);
		if (GetLastError() == 0x00000578) { //INVALID HANDLE (Target Window closed)
			//CloseWindow(proc.overlayHWND);
			//UnregisterClass(proc.className, NULL);
			//CurrentDirectX.D3DShutdown();
			//running = FALSE;
			//return 1;
			continue;
		}
		
		if (proc.wRect.left != rect.left ||
			proc.wRect.top != rect.top ||
			proc.wRect.bottom != rect.bottom ||
			proc.wRect.right != rect.right)
		{
			moving = true;
			Sleep(100);
			if (!SetWindowPos(proc.overlayHWND, HWND_TOPMOST, rect.left, rect.top, rect.right, rect.bottom, SWP_NOACTIVATE)) {
				this->Clear();
				return;
			}
			CurrentDirectX.D3DShutdown();
			if (!Direct::D3DInit(proc.overlayHWND, CurrentDirectX)) {
				//CloseWindow(proc.overlayHWND);
				//UnregisterClass(proc.className, NULL);
				running = 0;
				return;
			}
			proc.wRect = rect;
			Sleep(100);
			moving = false;
		}
	}
}

void Overlay::SetTargetHWND(HWND hwnd) {
	proc.targetHWND = hwnd;
}

void Overlay::Start()
{
	running = 1;
	DWORD ThreadID;
	
	CreateThread(NULL, 0, StaticMessageStart, (void*)this, 0, &ThreadID);
}

void Overlay::Render() {
	(*(RenderCallbacks))(this);
}

void Overlay::SetRender(RenderCallback v) {
	RenderCallbacks = v;
}

bool Overlay::isRunning() {
	return running;
}

void Overlay::Clear() {
	running = FALSE;
	CurrentDirectX.D3DShutdown();
	//CloseWindow(proc.overlayHWND);
	//UnregisterClass(proc.className, NULL);
}

int Overlay::getWidth() {
	return proc.wRect.right - proc.wRect.left;
}
int Overlay::getHeight() {
	return proc.wRect.bottom - proc.wRect.top;
}
```

`LocalStrunder/LocalStrunder/overlay.h`:

```h
#pragma once


#include <Windows.h>
#include <WinUser.h>
#include "DirectX.h"
#include <Dwmapi.h> 
#pragma comment(lib, "dwmapi.lib")
#include <stdlib.h>
#include <vector>
#include <chrono>
#include <cwchar>

typedef void (*RenderCallback) (void* ov);

struct Process_Informations {
	HWND targetHWND;
	HWND overlayHWND;
	LPCWSTR className;
	MSG msg;
	RECT wRect;
};

class Overlay {
public:
	void Start();
	DWORD CreateOverlay();
	void Render();
	void Clear();
	void SetRender(RenderCallback render);
	bool isRunning();
	void SetTargetHWND(HWND hwnd);
	void UpdatePosition();
	int getWidth();
	int getHeight();
	Direct CurrentDirectX;
private:
	bool running;
	RenderCallback RenderCallbacks;
	Process_Informations proc;
};


```

`LocalStrunder/LocalStrunder/server_shared.h`:

```h
#pragma once
#include <cstdint>

constexpr auto server_ip = 0x7F000001; // 127.0.0.1
constexpr auto server_port = 4662;

enum class PacketType
{
	packet_copy_memory,
	packet_get_base_address,
	packet_get_pid,
	packet_completed
};

struct PacketCopyMemory
{
	uint32_t dest_process_id;
	uint64_t dest_address;

	uint32_t src_process_id;
	uint64_t src_address;

	uint32_t size;
};

struct PacketGetBaseAddress
{
	uint32_t process_id;
};

struct PacketGetPid
{
	size_t len;
	wchar_t name[256];
};

struct PackedCompleted
{
	uint64_t result;
};

struct PacketHeader
{
	//uint32_t   magic;
	PacketType type;
};

struct Packet
{
	PacketHeader header;
	union
	{
		PacketCopyMemory	 copy_memory;
		PacketGetBaseAddress get_base_address;
		PacketGetPid get_pid;
		PackedCompleted		 completed;
	} data;
};
```

`LocalStrunder/LocalStrunder/utils.cpp`:

```cpp
#include "utils.h"

BOOL is_main_window(HWND handle)
{
	return GetWindow(handle, GW_OWNER) == (HWND)0 && IsWindowVisible(handle);
}

BOOL CALLBACK enum_windows_callback(HWND handle, LPARAM lParam)
{
	handle_data& data = *(handle_data*)lParam;
	unsigned long process_id = 0;
	GetWindowThreadProcessId(handle, &process_id);
	if (data.process_id != process_id || !is_main_window(handle))
		return TRUE;
	data.window_handle = handle;
	return FALSE;
}
HWND  Utils::FindMainWindow(DWORD process_id)
{
	handle_data data;
	data.process_id = process_id;
	data.window_handle = 0;
	EnumWindows(enum_windows_callback, (LPARAM)&data);
	return data.window_handle;
}

//DWORD Utils::GetBase(DWORD PID, const std::wstring& modulename)
//{
//	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, PID);
//	DWORD dwModuleBaseAddress = 0;
//	if (hSnapshot != INVALID_HANDLE_VALUE)
//	{
//		MODULEENTRY32 ModuleEntry32 = { 0 };
//		ModuleEntry32.dwSize = sizeof(MODULEENTRY32);
//		if (Module32First(hSnapshot, &ModuleEntry32))
//		{
//			do
//			{
//				if (!modulename.compare(ModuleEntry32.szModule))
//				{
//					dwModuleBaseAddress = (DWORD)ModuleEntry32.modBaseAddr;
//					break;
//				}
//			} while (Module32Next(hSnapshot, &ModuleEntry32));
//		}
//		CloseHandle(hSnapshot);
//	}
//	return dwModuleBaseAddress;
//}

//DWORD Utils::GetPID(const std::wstring& procname)
//{
//	PROCESSENTRY32 processInfo;
//	processInfo.dwSize = sizeof(processInfo);
//
//	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
//	if (processesSnapshot == INVALID_HANDLE_VALUE) {
//		return 0;
//	}
//
//	Process32First(processesSnapshot, &processInfo);
//	if (!procname.compare(processInfo.szExeFile))
//	{
//		CloseHandle(processesSnapshot);
//		return processInfo.th32ProcessID;
//	}
//
//	while (Process32Next(processesSnapshot, &processInfo))
//	{
//		if (!procname.compare(processInfo.szExeFile))
//		{
//			CloseHandle(processesSnapshot);
//			return processInfo.th32ProcessID;
//		}
//	}
//
//	CloseHandle(processesSnapshot);
//	return 0;
//}
```

`LocalStrunder/LocalStrunder/utils.h`:

```h

#pragma once

#include <Windows.h>
//#include <TlHelp32.h>
#include <string>

struct handle_data {
	DWORD process_id;
	HWND window_handle;
};

class Utils {
public:
	//static DWORD GetPID(const std::wstring& procname);
	//static DWORD GetBase(DWORD PID, const std::wstring& modulename);
	static HWND FindMainWindow(DWORD process_id);
};
```

`LocalStrunder/LocalStrunder/vector.h`:

```h
#pragma once
#include <stdlib.h>

#define CHECK_VALID( _v ) 0
#define Assert( _exp ) ((void)0)

#define FastSqrt(x)			(sqrt)(x)

#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h

#define M_PI_F		((float)(M_PI))	// Shouldn't collide with anything.

#define M_PHI		1.61803398874989484820 // golden ratio

// NJS: Inlined to prevent floats from being autopromoted to doubles, as with the old system.
#ifndef RAD2DEG
#define RAD2DEG( x  )  ( (float)(x) * (float)(180.f / M_PI_F) )
#endif

#ifndef DEG2RAD
#define DEG2RAD( x  )  ( (float)(x) * (float)(M_PI_F / 180.f) )
#endif

// MOVEMENT INFO
enum
{
	PITCH = 0,	// up / down
	YAW,		// left / right
	ROLL		// fall over
};

// decls for aligning data

#define DECL_ALIGN(x) __attribute__((aligned(x)))


#define ALIGN16 DECL_ALIGN(16)
#define VALVE_RAND_MAX 0x7fff
#define VectorExpand(v) (v).x, (v).y, (v).z

struct matrix3x4_t
{
	matrix3x4_t() {}
	matrix3x4_t(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23)
	{
		m_flMatVal[0][0] = m00;	m_flMatVal[0][1] = m01; m_flMatVal[0][2] = m02; m_flMatVal[0][3] = m03;
		m_flMatVal[1][0] = m10;	m_flMatVal[1][1] = m11; m_flMatVal[1][2] = m12; m_flMatVal[1][3] = m13;
		m_flMatVal[2][0] = m20;	m_flMatVal[2][1] = m21; m_flMatVal[2][2] = m22; m_flMatVal[2][3] = m23;
	}

	float* operator[](int i) { Assert((i >= 0) && (i < 3)); return m_flMatVal[i]; }
	const float* operator[](int i) const { Assert((i >= 0) && (i < 3)); return m_flMatVal[i]; }
	float* Base() { return &m_flMatVal[0][0]; }
	const float* Base() const { return &m_flMatVal[0][0]; }

	float m_flMatVal[3][4];
};

class VMatrix
{
public:

	VMatrix() {}
	VMatrix(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23,
		float m30, float m31, float m32, float m33
	) {
		m[0][0] = m00;
		m[0][1] = m01;
		m[0][2] = m02;
		m[0][3] = m03;

		m[1][0] = m10;
		m[1][1] = m11;
		m[1][2] = m12;
		m[1][3] = m13;

		m[2][0] = m20;
		m[2][1] = m21;
		m[2][2] = m22;
		m[2][3] = m23;

		m[3][0] = m30;
		m[3][1] = m31;
		m[3][2] = m32;
		m[3][3] = m33;
	}



	// array access
	inline float* operator[](int i)
	{
		return m[i];
	}

	inline const float* operator[](int i) const
	{
		return m[i];
	}

	// Get a pointer to m[0][0]
	inline float* Base()
	{
		return &m[0][0];
	}

	inline const float* Base() const
	{
		return &m[0][0];
	}


public:
	// The matrix.
	float		m[4][4];
};

class Vector
{
public:
	float x, y, z;
	Vector(void);
	Vector(float X, float Y, float Z);
	void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f);
	bool IsValid() const;
	float operator[](int i) const;
	float& operator[](int i);
	inline void Zero();
	bool operator==(const Vector& v) const;
	bool operator!=(const Vector& v) const;
	inline Vector& operator+=(const Vector& v);
	inline Vector& operator-=(const Vector& v);
	inline Vector& operator*=(const Vector& v);
	inline Vector& operator*=(float s);
	inline Vector& operator/=(const Vector& v);
	inline Vector& operator/=(float s);
	inline Vector& operator+=(float fl);
	inline Vector& operator-=(float fl);
	inline float	Length() const;
	inline float LengthSqr(void) const
	{
		CHECK_VALID(*this);
		return (x * x + y * y + z * z);
	}
	bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance &&
			y > -tolerance && y < tolerance &&
			z > -tolerance && z < tolerance);
	}
	Vector	Normalize();
	float	NormalizeInPlace();
	inline float	DistTo(const Vector& vOther) const;
	inline float	DistToSqr(const Vector& vOther) const;
	float	Dot(const Vector& vOther) const;
	float	Length2D(void) const;
	float	Length2DSqr(void) const;
	Vector& operator=(const Vector& vOther);
	Vector	operator-(void) const;
	Vector	operator+(const Vector& v) const;
	Vector	operator-(const Vector& v) const;
	Vector	operator*(const Vector& v) const;
	Vector	operator/(const Vector& v) const;
	Vector	operator*(float fl) const;
	Vector	operator/(float fl) const;
	// Base address...
	float* Base();
	float const* Base() const;
};

//===============================================
inline void Vector::Init(float ix, float iy, float iz)
{
	x = ix; y = iy; z = iz;
	CHECK_VALID(*this);
}
//===============================================
inline Vector::Vector(float X, float Y, float Z)
{
	x = X; y = Y; z = Z;
	CHECK_VALID(*this);
}
//===============================================
inline Vector::Vector(void) { Zero(); }
//===============================================
inline void Vector::Zero()
{
	x = y = z = 0.0f;
}
//===============================================
inline void VectorClear(Vector& a)
{
	a.x = a.y = a.z = 0.0f;
}
//===============================================
inline Vector& Vector::operator=(const Vector& vOther)
{
	CHECK_VALID(vOther);
	x = vOther.x; y = vOther.y; z = vOther.z;
	return *this;
}
//===============================================
inline float& Vector::operator[](int i)
{
	Assert((i >= 0) && (i < 3));
	return ((float*)this)[i];
}
//===============================================
inline float Vector::operator[](int i) const
{
	Assert((i >= 0) && (i < 3));
	return ((float*)this)[i];
}
//===============================================
inline bool Vector::operator==(const Vector& src) const
{
	CHECK_VALID(src);
	CHECK_VALID(*this);
	return (src.x == x) && (src.y == y) && (src.z == z);
}
//===============================================
inline bool Vector::operator!=(const Vector& src) const
{
	CHECK_VALID(src);
	CHECK_VALID(*this);
	return (src.x != x) || (src.y != y) || (src.z != z);
}
//===============================================
inline void VectorCopy(const Vector& src, Vector& dst)
{
	CHECK_VALID(src);
	dst.x = src.x;
	dst.y = src.y;
	dst.z = src.z;
}
//===============================================
inline  Vector& Vector::operator+=(const Vector& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);
	x += v.x; y += v.y; z += v.z;
	return *this;
}
//===============================================
inline  Vector& Vector::operator-=(const Vector& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);
	x -= v.x; y -= v.y; z -= v.z;
	return *this;
}
//===============================================
inline  Vector& Vector::operator*=(float fl)
{
	x *= fl;
	y *= fl;
	z *= fl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline  Vector& Vector::operator*=(const Vector& v)
{
	CHECK_VALID(v);
	x *= v.x;
	y *= v.y;
	z *= v.z;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline Vector& Vector::operator+=(float fl)
{
	x += fl;
	y += fl;
	z += fl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline Vector& Vector::operator-=(float fl)
{
	x -= fl;
	y -= fl;
	z -= fl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline  Vector& Vector::operator/=(float fl)
{
	Assert(fl != 0.0f);
	float oofl = 1.0f / fl;
	x *= oofl;
	y *= oofl;
	z *= oofl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline  Vector& Vector::operator/=(const Vector& v)
{
	CHECK_VALID(v);
	Assert(v.x != 0.0f && v.y != 0.0f && v.z != 0.0f);
	x /= v.x;
	y /= v.y;
	z /= v.z;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline float Vector::Length(void) const
{
	CHECK_VALID(*this);

	float root = 0.0f;

	float sqsr = x * x + y * y + z * z;

	root = sqrt(sqsr);

	return root;
}
//===============================================
inline float Vector::Length2D(void) const
{
	CHECK_VALID(*this);

	float root = 0.0f;

	float sqst = x * x + y * y;

	root = sqrt(sqst);

	return root;
}
//===============================================
inline float Vector::Length2DSqr(void) const
{
	return (x * x + y * y);
}
//===============================================
inline Vector CrossProduct(const Vector& a, const Vector& b)
{
	return Vector(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
//===============================================
float Vector::DistTo(const Vector& vOther) const
{
	Vector delta;

	delta.x = x - vOther.x;
	delta.y = y - vOther.y;
	delta.z = z - vOther.z;

	return delta.Length();
}
float Vector::DistToSqr(const Vector& vOther) const
{
	Vector delta;

	delta.x = x - vOther.x;
	delta.y = y - vOther.y;
	delta.z = z - vOther.z;

	return delta.LengthSqr();
}
//===============================================
inline Vector Vector::Normalize()
{
	Vector vector;
	float length = this->Length();

	if (length != 0)
	{
		vector.x = x / length;
		vector.y = y / length;
		vector.z = z / length;
	}
	else
	{
		vector.x = vector.y = 0.0f; vector.z = 1.0f;
	}

	return vector;
}
//===============================================
inline float Vector::NormalizeInPlace()
{
	Vector& v = *this;

	float iradius = 1.f / (this->Length() + 1.192092896e-07F); //FLT_EPSILON

	v.x *= iradius;
	v.y *= iradius;
	v.z *= iradius;
}
//===============================================
inline float VectorNormalize(Vector& v)
{
	Assert(v.IsValid());
	float l = v.Length();
	if (l != 0.0f)
	{
		v /= l;
	}
	else
	{
		// FIXME:
		// Just copying the existing implemenation; shouldn't res.z == 0?
		v.x = v.y = 0.0f; v.z = 1.0f;
	}
	return l;
}
//===============================================
inline float VectorNormalize(float* v)
{
	return VectorNormalize(*(reinterpret_cast<Vector*>(v)));
}
//===============================================
inline Vector Vector::operator+(const Vector& v) const
{
	Vector res;
	res.x = x + v.x;
	res.y = y + v.y;
	res.z = z + v.z;
	return res;
}

//===============================================
inline Vector Vector::operator-(const Vector& v) const
{
	Vector res;
	res.x = x - v.x;
	res.y = y - v.y;
	res.z = z - v.z;
	return res;
}
//===============================================
inline Vector Vector::operator*(float fl) const
{
	Vector res;
	res.x = x * fl;
	res.y = y * fl;
	res.z = z * fl;
	return res;
}
//===============================================
inline Vector Vector::operator*(const Vector& v) const
{
	Vector res;
	res.x = x * v.x;
	res.y = y * v.y;
	res.z = z * v.z;
	return res;
}
//===============================================
inline Vector Vector::operator/(float fl) const
{
	Vector res;
	res.x = x / fl;
	res.y = y / fl;
	res.z = z / fl;
	return res;
}
//===============================================
inline Vector Vector::operator/(const Vector& v) const
{
	Vector res;
	res.x = x / v.x;
	res.y = y / v.y;
	res.z = z / v.z;
	return res;
}
inline float Vector::Dot(const Vector& vOther) const
{
	const Vector& a = *this;

	return(a.x * vOther.x + a.y * vOther.y + a.z * vOther.z);
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------

inline float VectorLength(const Vector& v)
{
	CHECK_VALID(v);
	return (float)FastSqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

//VECTOR SUBTRAC
inline void VectorSubtract(const Vector& a, const Vector& b, Vector& c)
{
	CHECK_VALID(a);
	CHECK_VALID(b);
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	c.z = a.z - b.z;
}

//VECTORADD
inline void VectorAdd(const Vector& a, const Vector& b, Vector& c)
{
	CHECK_VALID(a);
	CHECK_VALID(b);
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	c.z = a.z + b.z;
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
inline float* Vector::Base()
{
	return (float*)this;
}

inline float const* Vector::Base() const
{
	return (float const*)this;
}

inline void VectorMAInline(const float* start, float scale, const float* direction, float* dest)
{
	dest[0] = start[0] + direction[0] * scale;
	dest[1] = start[1] + direction[1] * scale;
	dest[2] = start[2] + direction[2] * scale;
}

inline void VectorMAInline(const Vector& start, float scale, const Vector& direction, Vector& dest)
{
	dest.x = start.x + direction.x * scale;
	dest.y = start.y + direction.y * scale;
	dest.z = start.z + direction.z * scale;
}

inline void VectorMA(const Vector& start, float scale, const Vector& direction, Vector& dest)
{
	VectorMAInline(start, scale, direction, dest);
}

inline void VectorMA(const float* start, float scale, const float* direction, float* dest)
{
	VectorMAInline(start, scale, direction, dest);
}


inline unsigned long& FloatBits(float& f)
{
	return *reinterpret_cast<unsigned long*>(&f);
}

inline bool IsFinite(float f)
{
	return ((FloatBits(f) & 0x7F800000) != 0x7F800000);
}

//=========================================================
// 2D Vector2D
//=========================================================

class Vector2D
{
public:
	// Members
	float x, y;

	// Construction/destruction
	Vector2D(void);
	Vector2D(float X, float Y);
	Vector2D(const float* pFloat);

	// Initialization
	void Init(float ix = 0.0f, float iy = 0.0f);

	// Got any nasty NAN's?
	bool IsValid() const;

	// array access...
	float operator[](int i) const;
	float& operator[](int i);

	// Base address...
	float* Base();
	float const* Base() const;

	// Initialization methods
	void Random(float minVal, float maxVal);

	// equality
	bool operator==(const Vector2D& v) const;
	bool operator!=(const Vector2D& v) const;

	// arithmetic operations
	Vector2D& operator+=(const Vector2D& v);
	Vector2D& operator-=(const Vector2D& v);
	Vector2D& operator*=(const Vector2D& v);
	Vector2D& operator*=(float s);
	Vector2D& operator/=(const Vector2D& v);
	Vector2D& operator/=(float s);

	// negate the Vector2D components
	void	Negate();

	// Get the Vector2D's magnitude.
	float	Length() const;

	// Get the Vector2D's magnitude squared.
	float	LengthSqr(void) const;

	// return true if this vector is (0,0) within tolerance
	bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance &&
			y > -tolerance && y < tolerance);
	}

	float	Normalize();

	// Normalize in place and return the old length.
	float	NormalizeInPlace();

	// Compare length.
	bool	IsLengthGreaterThan(float val) const;
	bool	IsLengthLessThan(float val) const;

	// Get the distance from this Vector2D to the other one.
	float	DistTo(const Vector2D& vOther) const;

	// Get the distance from this Vector2D to the other one squared.
	float	DistToSqr(const Vector2D& vOther) const;

	// Copy
	void	CopyToArray(float* rgfl) const;

	// Multiply, add, and assign to this (ie: *this = a + b * scalar). This
	// is about 12% faster than the actual Vector2D equation (because it's done per-component
	// rather than per-Vector2D).
	void	MulAdd(const Vector2D& a, const Vector2D& b, float scalar);

	// Dot product.
	float	Dot(const Vector2D& vOther) const;

	// assignment
	Vector2D& operator=(const Vector2D& vOther);

#ifndef VECTOR_NO_SLOW_OPERATIONS
	// copy constructors
	Vector2D(const Vector2D& vOther);

	// arithmetic operations
	Vector2D	operator-(void) const;

	Vector2D	operator+(const Vector2D& v) const;
	Vector2D	operator-(const Vector2D& v) const;
	Vector2D	operator*(const Vector2D& v) const;
	Vector2D	operator/(const Vector2D& v) const;
	Vector2D	operator*(float fl) const;
	Vector2D	operator/(float fl) const;

	// Cross product between two vectors.
	Vector2D	Cross(const Vector2D& vOther) const;

	// Returns a Vector2D with the min or max in X, Y, and Z.
	Vector2D	Min(const Vector2D& vOther) const;
	Vector2D	Max(const Vector2D& vOther) const;

#else

private:
	// No copy constructors allowed if we're in optimal mode
	Vector2D(const Vector2D& vOther);
#endif
};

//-----------------------------------------------------------------------------

const Vector2D vec2_origin(0, 0);
//const Vector2D vec2_invalid(3.40282347E+38F, 3.40282347E+38F);

//-----------------------------------------------------------------------------
// Vector2D related operations
//-----------------------------------------------------------------------------

// Vector2D clear
void Vector2DClear(Vector2D& a);

// Copy
void Vector2DCopy(const Vector2D& src, Vector2D& dst);

// Vector2D arithmetic
void Vector2DAdd(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DSubtract(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DMultiply(const Vector2D& a, float b, Vector2D& result);
void Vector2DMultiply(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DDivide(const Vector2D& a, float b, Vector2D& result);
void Vector2DDivide(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DMA(const Vector2D& start, float s, const Vector2D& dir, Vector2D& result);

// Store the min or max of each of x, y, and z into the result.
void Vector2DMin(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DMax(const Vector2D& a, const Vector2D& b, Vector2D& result);

#define Vector2DExpand( v ) (v).x, (v).y

// Normalization
float Vector2DNormalize(Vector2D& v);

// Length
float Vector2DLength(const Vector2D& v);

// Dot Product
float DotProduct2D(const Vector2D& a, const Vector2D& b);

// Linearly interpolate between two vectors
void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, float t, Vector2D& dest);


//-----------------------------------------------------------------------------
//
// Inlined Vector2D methods
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// constructors
//-----------------------------------------------------------------------------

inline Vector2D::Vector2D(void)
{
#ifdef _DEBUG
	// Initialize to NAN to catch errors
	//x = y = float_NAN;
#endif
}

inline Vector2D::Vector2D(float X, float Y)
{
	x = X; y = Y;
	Assert(IsValid());
}

inline Vector2D::Vector2D(const float* pFloat)
{
	Assert(pFloat);
	x = pFloat[0]; y = pFloat[1];
	Assert(IsValid());
}


//-----------------------------------------------------------------------------
// copy constructor
//-----------------------------------------------------------------------------

inline Vector2D::Vector2D(const Vector2D& vOther)
{
	Assert(vOther.IsValid());
	x = vOther.x; y = vOther.y;
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------

inline void Vector2D::Init(float ix, float iy)
{
	x = ix; y = iy;
	Assert(IsValid());
}

inline void Vector2D::Random(float minVal, float maxVal)
{
	x = minVal + ((float)rand() / VALVE_RAND_MAX) * (maxVal - minVal);
	y = minVal + ((float)rand() / VALVE_RAND_MAX) * (maxVal - minVal);
}

inline void Vector2DClear(Vector2D& a)
{
	a.x = a.y = 0.0f;
}

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------

inline Vector2D& Vector2D::operator=(const Vector2D& vOther)
{
	Assert(vOther.IsValid());
	x = vOther.x; y = vOther.y;
	return *this;
}

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------

inline float& Vector2D::operator[](int i)
{
	Assert((i >= 0) && (i < 2));
	return ((float*)this)[i];
}

inline float Vector2D::operator[](int i) const
{
	Assert((i >= 0) && (i < 2));
	return ((float*)this)[i];
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------

inline float* Vector2D::Base()
{
	return (float*)this;
}

inline float const* Vector2D::Base() const
{
	return (float const*)this;
}

//-----------------------------------------------------------------------------
// IsValid?
//-----------------------------------------------------------------------------

inline bool Vector2D::IsValid() const
{
	return IsFinite(x) && IsFinite(y);
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------

inline bool Vector2D::operator==(const Vector2D& src) const
{
	Assert(src.IsValid() && IsValid());
	return (src.x == x) && (src.y == y);
}

inline bool Vector2D::operator!=(const Vector2D& src) const
{
	Assert(src.IsValid() && IsValid());
	return (src.x != x) || (src.y != y);
}


//-----------------------------------------------------------------------------
// Copy
//-----------------------------------------------------------------------------

inline void Vector2DCopy(const Vector2D& src, Vector2D& dst)
{
	Assert(src.IsValid());
	dst.x = src.x;
	dst.y = src.y;
}

inline void	Vector2D::CopyToArray(float* rgfl) const
{
	Assert(IsValid());
	Assert(rgfl);
	rgfl[0] = x; rgfl[1] = y;
}

//-----------------------------------------------------------------------------
// standard math operations
//-----------------------------------------------------------------------------

inline void Vector2D::Negate()
{
	Assert(IsValid());
	x = -x; y = -y;
}

inline Vector2D& Vector2D::operator+=(const Vector2D& v)
{
	Assert(IsValid() && v.IsValid());
	x += v.x; y += v.y;
	return *this;
}

inline Vector2D& Vector2D::operator-=(const Vector2D& v)
{
	Assert(IsValid() && v.IsValid());
	x -= v.x; y -= v.y;
	return *this;
}

inline Vector2D& Vector2D::operator*=(float fl)
{
	x *= fl;
	y *= fl;
	Assert(IsValid());
	return *this;
}

inline Vector2D& Vector2D::operator*=(const Vector2D& v)
{
	x *= v.x;
	y *= v.y;
	Assert(IsValid());
	return *this;
}

inline Vector2D& Vector2D::operator/=(float fl)
{
	Assert(fl != 0.0f);
	float oofl = 1.0f / fl;
	x *= oofl;
	y *= oofl;
	Assert(IsValid());
	return *this;
}

inline Vector2D& Vector2D::operator/=(const Vector2D& v)
{
	Assert(v.x != 0.0f && v.y != 0.0f);
	x /= v.x;
	y /= v.y;
	Assert(IsValid());
	return *this;
}

inline void Vector2DAdd(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	Assert(a.IsValid() && b.IsValid());
	c.x = a.x + b.x;
	c.y = a.y + b.y;
}

inline void Vector2DSubtract(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	Assert(a.IsValid() && b.IsValid());
	c.x = a.x - b.x;
	c.y = a.y - b.y;
}

inline void Vector2DMultiply(const Vector2D& a, float b, Vector2D& c)
{
	Assert(a.IsValid() && IsFinite(b));
	c.x = a.x * b;
	c.y = a.y * b;
}

inline void Vector2DMultiply(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	Assert(a.IsValid() && b.IsValid());
	c.x = a.x * b.x;
	c.y = a.y * b.y;
}


inline void Vector2DDivide(const Vector2D& a, float b, Vector2D& c)
{
	Assert(a.IsValid());
	Assert(b != 0.0f);
	float oob = 1.0f / b;
	c.x = a.x * oob;
	c.y = a.y * oob;
}

inline void Vector2DDivide(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	Assert(a.IsValid());
	Assert((b.x != 0.0f) && (b.y != 0.0f));
	c.x = a.x / b.x;
	c.y = a.y / b.y;
}

inline void Vector2DMA(const Vector2D& start, float s, const Vector2D& dir, Vector2D& result)
{
	Assert(start.IsValid() && IsFinite(s) && dir.IsValid());
	result.x = start.x + s * dir.x;
	result.y = start.y + s * dir.y;
}

// FIXME: Remove
// For backwards compatability
inline void	Vector2D::MulAdd(const Vector2D& a, const Vector2D& b, float scalar)
{
	x = a.x + b.x * scalar;
	y = a.y + b.y * scalar;
}

inline void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, float t, Vector2D& dest)
{
	dest[0] = src1[0] + (src2[0] - src1[0]) * t;
	dest[1] = src1[1] + (src2[1] - src1[1]) * t;
}

//-----------------------------------------------------------------------------
// dot, cross
//-----------------------------------------------------------------------------
inline float DotProduct2D(const Vector2D& a, const Vector2D& b)
{
	Assert(a.IsValid() && b.IsValid());
	return(a.x * b.x + a.y * b.y);
}

// for backwards compatability
inline float Vector2D::Dot(const Vector2D& vOther) const
{
	return DotProduct2D(*this, vOther);
}


//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------
inline float Vector2DLength(const Vector2D& v)
{
	Assert(v.IsValid());
	return (float)FastSqrt(v.x * v.x + v.y * v.y);
}

inline float Vector2D::LengthSqr(void) const
{
	Assert(IsValid());
	return (x * x + y * y);
}

inline float Vector2D::NormalizeInPlace()
{
	return Vector2DNormalize(*this);
}

inline bool Vector2D::IsLengthGreaterThan(float val) const
{
	return LengthSqr() > val* val;
}

inline bool Vector2D::IsLengthLessThan(float val) const
{
	return LengthSqr() < val * val;
}

inline float Vector2D::Length(void) const
{
	return Vector2DLength(*this);
}


inline void Vector2DMin(const Vector2D& a, const Vector2D& b, Vector2D& result)
{
	result.x = (a.x < b.x) ? a.x : b.x;
	result.y = (a.y < b.y) ? a.y : b.y;
}


inline void Vector2DMax(const Vector2D& a, const Vector2D& b, Vector2D& result)
{
	result.x = (a.x > b.x) ? a.x : b.x;
	result.y = (a.y > b.y) ? a.y : b.y;
}


//-----------------------------------------------------------------------------
// Normalization
//-----------------------------------------------------------------------------
inline float Vector2DNormalize(Vector2D& v)
{
	Assert(v.IsValid());
	float l = v.Length();
	if (l != 0.0f)
	{
		v /= l;
	}
	else
	{
		v.x = v.y = 0.0f;
	}
	return l;
}


//-----------------------------------------------------------------------------
// Get the distance from this Vector2D to the other one
//-----------------------------------------------------------------------------
inline float Vector2D::DistTo(const Vector2D& vOther) const
{
	Vector2D delta;
	Vector2DSubtract(*this, vOther, delta);
	return delta.Length();
}

inline float Vector2D::DistToSqr(const Vector2D& vOther) const
{
	Vector2D delta;
	Vector2DSubtract(*this, vOther, delta);
	return delta.LengthSqr();
}


//-----------------------------------------------------------------------------
// Computes the closest point to vecTarget no farther than flMaxDist from vecStart
//-----------------------------------------------------------------------------
inline void ComputeClosestPoint2D(const Vector2D& vecStart, float flMaxDist, const Vector2D& vecTarget, Vector2D* pResult)
{
	Vector2D vecDelta;
	Vector2DSubtract(vecTarget, vecStart, vecDelta);
	float flDistSqr = vecDelta.LengthSqr();
	if (flDistSqr <= flMaxDist * flMaxDist)
	{
		*pResult = vecTarget;
	}
	else
	{
		vecDelta /= FastSqrt(flDistSqr);
		Vector2DMA(vecStart, flMaxDist, vecDelta, *pResult);
	}
}



//-----------------------------------------------------------------------------
//
// Slow methods
//
//-----------------------------------------------------------------------------

#ifndef VECTOR_NO_SLOW_OPERATIONS
#endif
//-----------------------------------------------------------------------------
// Returns a Vector2D with the min or max in X, Y, and Z.
//-----------------------------------------------------------------------------

inline Vector2D Vector2D::Min(const Vector2D& vOther) const
{
	return Vector2D(x < vOther.x ? x : vOther.x,
		y < vOther.y ? y : vOther.y);
}

inline Vector2D Vector2D::Max(const Vector2D& vOther) const
{
	return Vector2D(x > vOther.x ? x : vOther.x,
		y > vOther.y ? y : vOther.y);
}


//-----------------------------------------------------------------------------
// arithmetic operations
//-----------------------------------------------------------------------------

inline Vector2D Vector2D::operator-(void) const
{
	return Vector2D(-x, -y);
}

inline Vector2D Vector2D::operator+(const Vector2D& v) const
{
	Vector2D res;
	Vector2DAdd(*this, v, res);
	return res;
}

inline Vector2D Vector2D::operator-(const Vector2D& v) const
{
	Vector2D res;
	Vector2DSubtract(*this, v, res);
	return res;
}

inline Vector2D Vector2D::operator*(float fl) const
{
	Vector2D res;
	Vector2DMultiply(*this, fl, res);
	return res;
}

inline Vector2D Vector2D::operator*(const Vector2D& v) const
{
	Vector2D res;
	Vector2DMultiply(*this, v, res);
	return res;
}

inline Vector2D Vector2D::operator/(float fl) const
{
	Vector2D res;
	Vector2DDivide(*this, fl, res);
	return res;
}

inline Vector2D Vector2D::operator/(const Vector2D& v) const
{
	Vector2D res;
	Vector2DDivide(*this, v, res);
	return res;
}

inline Vector2D operator*(float fl, const Vector2D& v)
{
	return v * fl;
}

class QAngleByValue;
class QAngle
{
public:
	// Members
	float x, y, z;

	// Construction/destruction
	QAngle(void);
	QAngle(float X, float Y, float Z);
	//      QAngle(RadianEuler const &angles);      // evil auto type promotion!!!

	// Allow pass-by-value
	operator QAngleByValue& () { return *((QAngleByValue*)(this)); }
	operator const QAngleByValue& () const { return *((const QAngleByValue*)(this)); }

	// Initialization
	void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f);
	void Random(float minVal, float maxVal);

	// Got any nasty NAN's?
	bool IsValid() const;
	void Invalidate();

	// array access...
	float operator[](int i) const;
	float& operator[](int i);

	// Base address...
	float* Base();
	float const* Base() const;

	// equality
	bool operator==(const QAngle& v) const;
	bool operator!=(const QAngle& v) const;

	bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance &&
			y > -tolerance && y < tolerance &&
			z > -tolerance && z < tolerance);
	}

	// arithmetic operations
	QAngle& operator+=(const QAngle& v);
	QAngle& operator-=(const QAngle& v);
	QAngle& operator*=(float s);
	QAngle& operator/=(float s);

	// Get the vector's magnitude.
	float   Length() const;
	float   LengthSqr() const;

	// negate the QAngle components
	//void  Negate();

	// No assignment operators either...
	QAngle& operator=(const QAngle& src);

#ifndef VECTOR_NO_SLOW_OPERATIONS
	// copy constructors

	// arithmetic operations
	QAngle  operator-(void) const;

	QAngle  operator+(const QAngle& v) const;
	QAngle  operator-(const QAngle& v) const;
	QAngle  operator*(float fl) const;
	QAngle  operator/(float fl) const;
#else

private:
	// No copy constructors allowed if we're in optimal mode
	QAngle(const QAngle& vOther);

#endif
};

//-----------------------------------------------------------------------------
// constructors
//-----------------------------------------------------------------------------
inline QAngle::QAngle(void)
{
#ifdef _DEBUG
#ifdef VECTOR_PARANOIA
	// Initialize to NAN to catch errors
	x = y = z = VEC_T_NAN;
#endif
#endif
}

inline QAngle::QAngle(float X, float Y, float Z)
{
	x = X; y = Y; z = Z;
	CHECK_VALID(*this);
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------
inline void QAngle::Init(float ix, float iy, float iz)
{
	x = ix; y = iy; z = iz;
	CHECK_VALID(*this);
}

inline void QAngle::Random(float minVal, float maxVal)
{
	x = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	y = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	z = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	CHECK_VALID(*this);
}

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------
inline QAngle& QAngle::operator=(const QAngle& vOther)
{
	CHECK_VALID(vOther);
	x = vOther.x; y = vOther.y; z = vOther.z;
	return *this;
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------
inline bool QAngle::operator==(const QAngle& src) const
{
	CHECK_VALID(src);
	CHECK_VALID(*this);
	return (src.x == x) && (src.y == y) && (src.z == z);
}

inline bool QAngle::operator!=(const QAngle& src) const
{
	CHECK_VALID(src);
	CHECK_VALID(*this);
	return (src.x != x) || (src.y != y) || (src.z != z);
}

//-----------------------------------------------------------------------------
// standard math operations
//-----------------------------------------------------------------------------
inline QAngle& QAngle::operator+=(const QAngle& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);
	x += v.x; y += v.y; z += v.z;
	return *this;
}

inline QAngle& QAngle::operator-=(const QAngle& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);
	x -= v.x; y -= v.y; z -= v.z;
	return *this;
}

inline QAngle& QAngle::operator*=(float fl)
{
	x *= fl;
	y *= fl;
	z *= fl;
	CHECK_VALID(*this);
	return *this;
}

inline QAngle& QAngle::operator/=(float fl)
{
	Assert(fl != 0.0f);
	float oofl = 1.0f / fl;
	x *= oofl;
	y *= oofl;
	z *= oofl;
	CHECK_VALID(*this);
	return *this;
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
inline float* QAngle::Base()
{
	return (float*)this;
}

inline float const* QAngle::Base() const
{
	return (float const*)this;
}

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------
inline float& QAngle::operator[](int i)
{
	Assert((i >= 0) && (i < 3));
	return ((float*)this)[i];
}

inline float QAngle::operator[](int i) const
{
	Assert((i >= 0) && (i < 3));
	return ((float*)this)[i];
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------
inline float QAngle::Length() const
{
	CHECK_VALID(*this);
	return (float)FastSqrt(LengthSqr());
}


inline float QAngle::LengthSqr() const
{
	CHECK_VALID(*this);
	return x * x + y * y + z * z;
}


//-----------------------------------------------------------------------------
// arithmetic operations (SLOW!!)
//-----------------------------------------------------------------------------
#ifndef VECTOR_NO_SLOW_OPERATIONS

inline QAngle QAngle::operator-(void) const
{
	return QAngle(-x, -y, -z);
}

inline QAngle QAngle::operator+(const QAngle& v) const
{
	QAngle res;
	res.x = x + v.x;
	res.y = y + v.y;
	res.z = z + v.z;
	return res;
}

inline QAngle QAngle::operator-(const QAngle& v) const
{
	QAngle res;
	res.x = x - v.x;
	res.y = y - v.y;
	res.z = z - v.z;
	return res;
}

inline QAngle QAngle::operator*(float fl) const
{
	QAngle res;
	res.x = x * fl;
	res.y = y * fl;
	res.z = z * fl;
	return res;
}

inline QAngle QAngle::operator/(float fl) const
{
	QAngle res;
	res.x = x / fl;
	res.y = y / fl;
	res.z = z / fl;
	return res;
}

inline QAngle operator*(float fl, const QAngle& v)
{
	return v * fl;
}

#endif // VECTOR_NO_SLOW_OPERATIONS


//QANGLE SUBTRAC
inline void QAngleSubtract(const QAngle& a, const QAngle& b, QAngle& c)
{
	CHECK_VALID(a);
	CHECK_VALID(b);
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	c.z = a.z - b.z;
}

//QANGLEADD
inline void QAngleAdd(const QAngle& a, const QAngle& b, QAngle& c)
{
	CHECK_VALID(a);
	CHECK_VALID(b);
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	c.z = a.z + b.z;
}
```

`README.MD`:

```MD
# Kernel Driver Hack
### Designed for APEX Legends

## Components

- "StrunderSv" Kernel Driver with memory Read/Write commands by Sockets
- "LocalStrunder" CPP application to connect and send the commands and do the wallhack/aimbot
- "AmazingWindow" Simply dummy transparent application to show the wallhack in topmost

## Features

- External DirectX 9 Wallhack
- Aimbot (Writing View Angles directly in the game memory)

## How to run

- Load StrunderSv into System memory with KDMapper (Basic Vulnerable Driver Exploit)
- Run AmazingWindow
- Run LocalStrunder
- Open Apex Legends

## KDMapper

KDMapper is an application that uses a vulnerable drivers to load bad drivers into system memory as ring0

- Download: https://github.com/alxbrn/kdmapper-1803-1903


## Note: Apex Legends Have "Easy Anti Cheat" and will ban your account if you use this source without rewrite anything
```

`StrunderSv/StrunderSv.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StrunderSv", "StrunderSv\StrunderSv.vcxproj", "{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Debug|x64.ActiveCfg = Debug|x64
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Debug|x64.Build.0 = Debug|x64
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Debug|x64.Deploy.0 = Debug|x64
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Release|x64.ActiveCfg = Release|x64
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Release|x64.Build.0 = Release|x64
		{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8F6EE30C-51A9-4ECA-AFE0-E9E225F018B1}
	EndGlobalSection
EndGlobal

```

`StrunderSv/StrunderSv/JUNK.h`:

```h
#pragma once

#define J() UsefulFuntion(24567, 3324, 4537, 2345);

inline int UsefulFuntion(int x, int y, int z, int r)
{
	for (int i = 2; i < 8; i++)
	{
		z += 456;
		r -= 55;
		x++;
		y--;

	}
	for (int i = 0; i < 2; i++)
	{
		x++;
		y += 234;
		z -= 23;
		r += 634;
	}
	return x + z + r + y;
}
```

`StrunderSv/StrunderSv/StrunderSv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FE6B3C6F-FE7E-4370-9D03-5BCD148CA44B}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>StrunderSv</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>Netio.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <EntryPointSymbol>MainEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <PreprocessorDefinitions>DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>Level3</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>Netio.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <EntryPointSymbol>MainEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="bypass.c" />
    <ClCompile Include="ksocket\berkeley.c" />
    <ClCompile Include="ksocket\ksocket.c" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="packet_handler.cpp" />
    <ClCompile Include="server.cpp" />
    <ClCompile Include="util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="bypass.h" />
    <ClInclude Include="eimport.h" />
    <ClInclude Include="JUNK.h" />
    <ClInclude Include="ksocket\berkeley.h" />
    <ClInclude Include="ksocket\ksocket.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="packet_handler.h" />
    <ClInclude Include="server.h" />
    <ClInclude Include="server_shared.h" />
    <ClInclude Include="sockets.h" />
    <ClInclude Include="structs.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`StrunderSv/StrunderSv/bypass.c`:

```c



#include "bypass.h"


PVOID ResolveRelativeAddress(_In_ PVOID Instruction, _In_ ULONG OffsetOffset, _In_ ULONG InstructionSize)
{
	ULONG_PTR Instr = (ULONG_PTR)Instruction;
	LONG RipOffset = *(PLONG)(Instr + OffsetOffset);
	J();
	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

	return ResolvedAddr;
}

BOOLEAN bDataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask)
{
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'c' && *pData != *bMask)
			return 0;
	J();
	return (*szMask) == 0;
}

UINT64 FindPattern(UINT64 dwAddress, UINT64 dwLen, BYTE* bMask, char* szMask)
{
	for (UINT64 i = 0; i < dwLen; i++)
		if (bDataCompare((BYTE*)(dwAddress + i), bMask, szMask))
			return (UINT64)(dwAddress + i);
	J();
	return 0;
}

NTOSAddrs* GetNtoskrnlAddress() {
	NTOSAddrs* result = (NTOSAddrs*)DataArea.NTAddr;

	ULONG bytes = 0;
	NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
	J();
	if (!bytes)
	{
		log("Error Getting System module list size\n");
		return NULL;
	}

	PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)DataArea.NTModListData;//ExAllocatePool(NonPagedPool, bytes);
	if (modules == NULL) {
		log("Error creating pool for system module list\n");
		return NULL;
	}

	if (bytes > 409600) {
		log("Error space needed to search module ntoskrn too big\n");
		return NULL;
	}

	status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);
	J();
	if (!NT_SUCCESS(status))
	{
		log("Error reading system module list into his pool\n");
		RtlZeroMemory(DataArea.NTModListData, 409600);
		return NULL;
	}

	PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
	J();
	if (module == NULL) {
		log("Error reading modules from System module list\n");
		RtlZeroMemory(DataArea.NTModListData, 409600);
		return NULL;
	}

	RtlZeroMemory(DataArea.NTName, 4096);
	DataArea.NTName[0] = '\\';
	DataArea.NTName[1] = 'S';
	DataArea.NTName[2] = 'y';
	DataArea.NTName[3] = 's';
	DataArea.NTName[4] = 't';
	DataArea.NTName[5] = 'e';
	DataArea.NTName[6] = 'm';
	DataArea.NTName[7] = 'R';
	DataArea.NTName[8] = 'o';
	DataArea.NTName[9] = 'o';
	DataArea.NTName[10] = 't';
	DataArea.NTName[11] = '\\';
	DataArea.NTName[12] = 's';
	DataArea.NTName[13] = 'y';
	DataArea.NTName[14] = 's';
	DataArea.NTName[15] = 't';
	DataArea.NTName[16] = 'e';
	DataArea.NTName[17] = 'm';
	DataArea.NTName[18] = '3';
	DataArea.NTName[19] = '2';
	DataArea.NTName[20] = '\\';
	DataArea.NTName[21] = 'n';
	DataArea.NTName[22] = 't';
	DataArea.NTName[23] = 'o';
	DataArea.NTName[24] = 's';
	DataArea.NTName[25] = 'k';
	DataArea.NTName[26] = 'r';
	DataArea.NTName[27] = 'n';
	DataArea.NTName[28] = 'l';
	DataArea.NTName[29] = '.';
	DataArea.NTName[30] = 'e';
	DataArea.NTName[31] = 'x';
	DataArea.NTName[32] = 'e';

	uintptr_t ntoskrnlBase = 0, ntoskrnlSize = 0;
	for (ULONG i = 0; i < modules->NumberOfModules; i++)
	{
		if (!strcmp((char*)module[i].FullPathName, DataArea.NTName)) //"\\SystemRoot\\system32\\ntoskrnl.exe"
		{
			ntoskrnlBase = (UINT64)module[i].ImageBase;
			J();
			ntoskrnlSize = (UINT64)module[i].ImageSize;
			break;
		}
	}

	if (ntoskrnlBase == 0) {
		log("BWarning no ntoskrnl found");
		RtlZeroMemory(DataArea.NTName, 50);
		RtlZeroMemory(DataArea.NTModListData, 409600);
		return NULL;
	}

	RtlSecureZeroMemory(DataArea.NTName, 50);
	RtlSecureZeroMemory(DataArea.NTModListData, 409600);

	result->StartAddress = ntoskrnlBase;
	result->Size = ntoskrnlSize;

	return result;
}

uintptr_t SearchNtoskrnlPattern(BYTE* bMask, char* szMask, NTOSAddrs* ntos) {
	if (ntos == NULL) {
		ntos = GetNtoskrnlAddress();
	}
	if (ntos == NULL || ntos->StartAddress == 0 || ntos->Size == 0) {
		log("Can't get Ntoskrnl Address\n");
		return 0;
	}
	J();
	uintptr_t result = (uintptr_t)FindPattern(ntos->StartAddress, ntos->Size, bMask, szMask);

	if (result == 0) {
		log("Warning no Pattern found");
		return 0;
	}

	return result;
}

/*
BOOLEAN CleanUnloadedDrivers()
{
	ULONG bytes = 0;
	NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);

	if (!bytes)
	{
		//DbgPrintEx(0, 0, "CleanUnloadedDrivers: first NtQuerySystemInformation failed, status: 0x%x\n", status);
		return FALSE;
	}

	PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 0x454E4F45); // 'ENON'

	status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);

	if (!NT_SUCCESS(status))
	{
		//DbgPrintEx(0, 0, "CleanUnloadedDrivers: second NtQuerySystemInformation failed, status: 0x%x\n", status);
		return FALSE;
	}

	PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
	UINT64 ntoskrnlBase = 0, ntoskrnlSize = 0;

	for (ULONG i = 0; i < modules->NumberOfModules; i++)
	{
		//DbgPrintEx(0, 0, "CleanUnloadedDrivers: path: %s\n", module[i].FullPathName);

		if (!strcmp((char*)module[i].FullPathName, "\\SystemRoot\\system32\\ntoskrnl.exe"))
		{
			ntoskrnlBase = (UINT64)module[i].ImageBase;
			ntoskrnlSize = (UINT64)module[i].ImageSize;
			break;
		}
	}

	if (modules)
		ExFreePoolWithTag(modules, 0);

	if (ntoskrnlBase <= 0)
	{
		//DbgPrintEx(0, 0, "CleanUnloadedDrivers: ntoskrnlBase equals zero\n");
		return FALSE;
	}

	// NOTE: 4C 8B ? ? ? ? ? 4C 8B C9 4D 85 ? 74 + 3] + current signature address = MmUnloadedDrivers
	UINT64 mmUnloadedDriversPtr = FindPattern((UINT64)ntoskrnlBase, (UINT64)ntoskrnlSize, (BYTE*)"\x4C\x8B\x00\x00\x00\x00\x00\x4C\x8B\xC9\x4D\x85\x00\x74", "xx?????xxxxx?x");

	if (!mmUnloadedDriversPtr)
	{
		//DbgPrintEx(0, 0, "CleanUnloadedDrivers: mmUnloadedDriversPtr equals zero\n");
		return FALSE;
	}

	UINT64 mmUnloadedDrivers = (UINT64)((PUCHAR)mmUnloadedDriversPtr + *(PULONG)((PUCHAR)mmUnloadedDriversPtr + 3) + 7);

	UINT64 mmUnloadedDrivers_bufferPtr = *(UINT64*)mmUnloadedDrivers;

	//MM_UNLOADED_DRIVER* MmUnloadedDrivers = mmUnloadedDrivers_bufferPtr;
	//for (ULONG i = 0; i < 50; i++)
	//{
	//	DbgPrintEx(0,0,"[MmUnloadedDrivers] %d = %wZ\n", i, MmUnloadedDrivers[i].Name);
	//}

	// NOTE: 0x7D0 is the size of the MmUnloadedDrivers array for win 7 and above
	PVOID newBuffer = ExAllocatePoolWithTag(NonPagedPoolNx, 0x7D0, 0x54446D4D);

	if (!newBuffer)
		return FALSE;

	memset(newBuffer, 0, 0x7D0);

	// NOTE: replace MmUnloadedDrivers
	*(UINT64*)mmUnloadedDrivers = (UINT64)newBuffer;
	//DbgPrintEx(0, 0, "mmUnloadedDrivers nulled\n");
	// NOTE: clean the old buffer
	ExFreePoolWithTag((PVOID)mmUnloadedDrivers_bufferPtr, 0x54446D4D); // 'MmDT'

	return TRUE;
}
*/

FORCEINLINE
BOOLEAN
ModRemoveEntryList(
	_In_ PLIST_ENTRY Entry
)

{

	PLIST_ENTRY PrevEntry;
	PLIST_ENTRY NextEntry;

	NextEntry = Entry->Flink;
	PrevEntry = Entry->Blink;

	PrevEntry->Flink = NextEntry;
	NextEntry->Blink = PrevEntry;
	return (BOOLEAN)(PrevEntry->Flink == NextEntry);
}

UINT64 ClearCacheEntry(UNICODE_STRING name) {

	NTOSAddrs* ntos = GetNtoskrnlAddress();
	
	if (ntos == NULL || ntos->StartAddress == 0 || ntos->Size == 0) {
		log("Warning no ntoskrnl found");
		return 0;
	}
	
	
	J();
	PVOID PiDDBLockPtr = (PVOID)SearchNtoskrnlPattern((UCHAR*)"\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x4C\x8B\x8C", "ccc!!!!c!!!!ccc", ntos);
	
	J();
	if (PiDDBLockPtr == NULL) {
		log("Warning no PiDDBLockPtr found");
		return 0;
	}
	log("PiDDBLockPtr %llx", PiDDBLockPtr)

	J();
	PVOID PiDDBCacheTablePtr = (PVOID)SearchNtoskrnlPattern((UCHAR*)"\x66\x03\xD2\x48\x8D\x0D", "cccccc", ntos);
	if (PiDDBCacheTablePtr == 0) {
		log("Warning no PiDDBCacheTablePtr found");
		return 0;
	}
	log("PiDDBCacheTablePtr %llx", PiDDBCacheTablePtr)

	// DbgPrintEx(0, 0, "BlockPtr: %p  CacheTable. %p\n", ResolveRelativeAddress(PiDDBLockPtr, 3, 7), ResolveRelativeAddress(PiDDBCacheTablePtr, 6, 10));

	PERESOURCE PiDDBLock; PRTL_AVL_TABLE PiDDBCacheTable;
	J();
	PiDDBLock = (PERESOURCE)ResolveRelativeAddress(PiDDBLockPtr, 3, 7);
	J();
	PiDDBCacheTable = (PRTL_AVL_TABLE)ResolveRelativeAddress(PiDDBCacheTablePtr, 6, 10);

	PiDDBCacheTable->TableContext = (PVOID)1;

	// build a lookup entry
	PiDDBCacheEntry lookupEntry = { 0 };
	J();
	lookupEntry.DriverName = name;
	log("to clear %wZ",lookupEntry.DriverName)
	// until here all is okay (at least not crashes)

	// acquire the ddb resource lock
	if (!ExAcquireResourceExclusiveLite(PiDDBLock, TRUE)) {
		log("Can't acquire resource\n");
		return 0;
	}

	// search our entry in the table
	PiDDBCacheEntry* pFoundEntry = (PiDDBCacheEntry*)RtlLookupElementGenericTableAvl(PiDDBCacheTable, &lookupEntry);
	J();
	if (pFoundEntry == 0)
	{
		log("Not found in cache\n");
		// release the ddb resource lock
		ExReleaseResourceLite(PiDDBLock);

		return 0;
	}
	J();
	log("Found bad driver %wZ\n", pFoundEntry->DriverName);
	// first, unlink from the list
	if (!ModRemoveEntryList(&pFoundEntry->List)) {
		log("Can't unlink from list\n");
		ExReleaseResourceLite(PiDDBLock);
		return 0;
	}
	// then delete the element from the avl table
	if (!RtlDeleteElementGenericTableAvl(PiDDBCacheTable, pFoundEntry)) {
		log("Can't delete from cache\n");
		ExReleaseResourceLite(PiDDBLock);
		return 0;
	}
	J();
	// release the ddb resource lock
	ExReleaseResourceLite(PiDDBLock);

	log("Cleaned %wZ\n", name);

	ClearCacheEntry(name); // if found clear again
	J();
	return 1;
}
```

`StrunderSv/StrunderSv/bypass.h`:

```h
#pragma once

#include <ntddk.h>
#include <windef.h>
#include "structs.h"
#include "eimport.h"
#include "JUNK.h"
#include "log.h"
#include "util.h"



#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef struct _NTOSAddrs {
	uintptr_t StartAddress;
	uintptr_t Size;
} NTOSAddrs;

UINT64 ClearCacheEntry(UNICODE_STRING name);
uintptr_t SearchNtoskrnlPattern(BYTE* bMask, char* szMask, NTOSAddrs* ntos);
#ifdef __cplusplus
}
#endif // __cplusplus
```

`StrunderSv/StrunderSv/eimport.h`:

```h
#pragma once

#include <ntddk.h>

#ifdef __cplusplus
extern "C"
{
#endif

	NTKERNELAPI NTSTATUS MmCopyVirtualMemory(
		IN PEPROCESS		SourceProcess,
		IN PVOID			SourceAddress,
		IN PEPROCESS		TargetProcess,
		IN PVOID			TargetAddress,
		IN SIZE_T			BufferSize,
		IN KPROCESSOR_MODE  PreviousMode,
		OUT PSIZE_T			ReturnSize
	);

	NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(
		IN HANDLE			ProcessId,
		OUT PEPROCESS* Process
	);

	NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(
		IN PEPROCESS		Process
	);

	NTSTATUS ZwQuerySystemInformation(
		ULONG InfoClass, 
		PVOID Buffer, 
		ULONG Length, 
		PULONG ReturnLength
	);
#ifdef __cplusplus
}
#endif

```

`StrunderSv/StrunderSv/ksocket/berkeley.c`:

```c
#include "berkeley.h"
#include "ksocket.h"

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

//#define MEMORY_TAG            ' bsK'
#define SOCKETFD_MAX          128
#define TO_SOCKETFD(index)    ((index % SOCKETFD_MAX)  + 1)
#define FROM_SOCKETFD(sockfd) ((sockfd)                - 1)

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspUtilAddrInfoToAddrInfoEx(
  _In_ PADDRINFOA AddrInfo,
  _Out_ PADDRINFOEXW* AddrInfoEx
  );

NTSTATUS
NTAPI
KspUtilAddrInfoExToAddrInfo(
  _In_ PADDRINFOEXW AddrInfoEx,
  _Out_ PADDRINFOA* AddrInfo
  );

VOID
NTAPI
KspUtilFreeAddrInfo(
  _In_ PADDRINFOA AddrInfo
  );

VOID
NTAPI
KspUtilFreeAddrInfoEx(
  _In_ PADDRINFOEXW AddrInfo
  );

//////////////////////////////////////////////////////////////////////////
// Variables.
//////////////////////////////////////////////////////////////////////////

//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// This is complete bollocks and ideally it should be replaced with
// something like RTL_AVL_TABLE.
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

PKSOCKET KsArray[SOCKETFD_MAX] = { 0 };
ULONG    KsIndex = 0;

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspUtilAddrInfoExToAddrInfo(
  _In_ PADDRINFOEXW AddrInfoEx,
  _Out_ PADDRINFOA* AddrInfo
  )
{
  NTSTATUS Status;

  //
  // Convert NULL input into NULL output.
  //

  if (AddrInfoEx == NULL)
  {
    *AddrInfo = NULL;
    return STATUS_SUCCESS;
  }

  //
  // Allocate memory for the output structure.
  //

  PADDRINFOA Result = ExAllocatePool(PagedPool, sizeof(ADDRINFOA));//ExAllocatePoolWithTag(PagedPool, sizeof(ADDRINFOA), MEMORY_TAG);

  if (Result == NULL)
  {
    Status = STATUS_INSUFFICIENT_RESOURCES;
    goto Error1;
  }

  //
  // Copy numeric values.
  //

  RtlZeroMemory(Result, sizeof(ADDRINFOA));
  Result->ai_flags    = AddrInfoEx->ai_flags;
  Result->ai_family   = AddrInfoEx->ai_family;
  Result->ai_socktype = AddrInfoEx->ai_socktype;
  Result->ai_protocol = AddrInfoEx->ai_protocol;
  Result->ai_addrlen  = AddrInfoEx->ai_addrlen;

  //
  // Copy canonical name.
  //

  UNICODE_STRING CanonicalNameUnicode;
  ANSI_STRING CanonicalNameAnsi;

  if (AddrInfoEx->ai_canonname)
  {
    RtlInitUnicodeString(&CanonicalNameUnicode, AddrInfoEx->ai_canonname);
    Status = RtlUnicodeStringToAnsiString(&CanonicalNameAnsi, &CanonicalNameUnicode, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error2;
    }

    Result->ai_canonname = CanonicalNameAnsi.Buffer;
  }

  //
  // Copy address.
  //

  Result->ai_addr = AddrInfoEx->ai_addr;

  //
  // Copy the next structure (recursively).
  //

  PADDRINFOA NextAddrInfo;
  Status = KspUtilAddrInfoExToAddrInfo(AddrInfoEx->ai_next, &NextAddrInfo);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  Result->ai_next = NextAddrInfo;

  //
  // All done!
  //

  *AddrInfo = Result;

  return Status;

Error3:
  RtlFreeAnsiString(&CanonicalNameAnsi);

Error2:
  ExFreePool(Result);//ExFreePoolWithTag(Result, MEMORY_TAG);

Error1:
  return Status;
}
int recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen)
{
	UNREFERENCED_PARAMETER(addrlen);

	NTSTATUS Status;
	PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

	ULONG Length = (ULONG)len;
	Status = KsSendTo(Socket, (PVOID)buf, &Length, (ULONG)flags, (PSOCKADDR)src_addr);
	*addrlen = sizeof(SOCKADDR);

	return NT_SUCCESS(Status)
		? (int)Length
		: -1;
}

int closesocket(int sockfd)
{
	NTSTATUS Status;
	PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

	Status = KsCloseSocket(Socket);

	KsArray[FROM_SOCKETFD(sockfd)] = NULL;

	return NT_SUCCESS(Status)
		? 0
		: -1;
}

VOID
NTAPI
KspUtilFreeAddrInfo(
  _In_ PADDRINFOA AddrInfo
  )
{
  //
  // Free all structures recursively.
  //

  if (AddrInfo->ai_next)
  {
    KspUtilFreeAddrInfo(AddrInfo->ai_next);
  }

  //
  // Free the canonical name buffer.
  //

  if (AddrInfo->ai_canonname)
  {
    ANSI_STRING CanonicalName;
    RtlInitAnsiString(&CanonicalName, AddrInfo->ai_canonname);
    RtlFreeAnsiString(&CanonicalName);
  }

  //
  // Finally, free the structure itself.
  //

  ExFreePool(AddrInfo); //ExFreePoolWithTag(AddrInfo, MEMORY_TAG);

}

VOID
NTAPI
KspUtilFreeAddrInfoEx(
  _In_ PADDRINFOEXW AddrInfo
  )
{
  //
  // Free all structures recursively.
  //

  if (AddrInfo->ai_next)
  {
    KspUtilFreeAddrInfoEx(AddrInfo->ai_next);
  }

  //
  // Free the canonical name buffer.
  //

  if (AddrInfo->ai_canonname)
  {
    UNICODE_STRING CanonicalName;
    RtlInitUnicodeString(&CanonicalName, AddrInfo->ai_canonname);
    RtlFreeUnicodeString(&CanonicalName);
  }

  //
  // Finally, free the structure itself.
  //

  ExFreePool(AddrInfo);//ExFreePoolWithTag(AddrInfo, MEMORY_TAG);
}

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

UINT32 htonl(UINT32 hostlong)
{
  return RtlUlongByteSwap(hostlong);
}

UINT16 htons(UINT16 hostshort)
{
  return RtlUshortByteSwap(hostshort);
}

UINT32 ntohl(UINT32 netlong)
{
  return RtlUlongByteSwap(netlong);
}

UINT16 ntohs(UINT16 netshort)
{
  return RtlUshortByteSwap(netshort);
}
int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)
{
	NTSTATUS Status;
	PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

	PKSOCKET NewSocket;
	Status = KsAccept(Socket, &NewSocket, NULL, (PSOCKADDR)addr);
	*addrlen = sizeof(SOCKADDR);

	if (NT_SUCCESS(Status))
	{
		int newsockfd = TO_SOCKETFD(KsIndex++);

		KsArray[FROM_SOCKETFD(newsockfd)] = NewSocket;

		return newsockfd;
	}

	return -1;
}
int getaddrinfo(const char* node, const char* service, const struct addrinfo* hints, struct addrinfo** res)
{
  NTSTATUS Status;

  //
  // Convert node name to the UNICODE_STRING (if present).
  //

  ANSI_STRING NodeNameAnsi;
  UNICODE_STRING NodeNameUnicode;
  PUNICODE_STRING NodeName = NULL;

  if (node)
  {
    RtlInitAnsiString(&NodeNameAnsi, node);
    Status = RtlAnsiStringToUnicodeString(&NodeNameUnicode, &NodeNameAnsi, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error1;
    }

    NodeName = &NodeNameUnicode;
  }

  //
  // Convert service name to the UNICODE_STRING (if present).
  //

  ANSI_STRING ServiceNameAnsi;
  UNICODE_STRING ServiceNameUnicode;
  PUNICODE_STRING ServiceName = NULL;

  if (service)
  {
    RtlInitAnsiString(&ServiceNameAnsi, service);
    Status = RtlAnsiStringToUnicodeString(&ServiceNameUnicode, &ServiceNameAnsi, TRUE);

    if (!NT_SUCCESS(Status))
    {
      goto Error2;
    }

    ServiceName = &ServiceNameUnicode;
  }

  //
  // Convert "struct addrinfo" to the "ADDRINFOEXW".
  //

  PADDRINFOEXW Hints;
  Status = KspUtilAddrInfoToAddrInfoEx((PADDRINFOA)hints, &Hints);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  //
  // All data is prepared, call the underlying API.
  //

  PADDRINFOEXW Result;
  Status = KsGetAddrInfo(NodeName, ServiceName, Hints, &Result);

  //
  // Free the memory of the converted "Hints".
  //

  KspUtilFreeAddrInfoEx(Hints);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  //
  // Convert the result "ADDRINFOEXW" to the "struct addrinfo".
  //

  Status = KspUtilAddrInfoExToAddrInfo(Result, res);

  //
  // Free the original result.
  //

  KsFreeAddrInfo(Result);

  if (!NT_SUCCESS(Status))
  {
    goto Error3;
  }

  return STATUS_SUCCESS;

Error3:
  RtlFreeUnicodeString(&ServiceNameUnicode);

Error2:
  RtlFreeUnicodeString(&NodeNameUnicode);

Error1:
  return Status;
}

void freeaddrinfo(struct addrinfo *res)
{
  //
  // Call our implementation.
  //

  KspUtilFreeAddrInfo(res);
}

NTSTATUS
NTAPI
KspUtilAddrInfoToAddrInfoEx(
	_In_ PADDRINFOA AddrInfo,
	_Out_ PADDRINFOEXW* AddrInfoEx
)
{
	NTSTATUS Status;

	//
	// Convert NULL input into NULL output.
	//

	if (AddrInfo == NULL)
	{
		*AddrInfoEx = NULL;
		return STATUS_SUCCESS;
	}

	//
	// Allocate memory for the output structure.
	//

	PADDRINFOEXW Result = ExAllocatePool(PagedPool, sizeof(ADDRINFOEXW));//ExAllocatePoolWithTag(PagedPool, sizeof(ADDRINFOEXW), MEMORY_TAG);

	if (Result == NULL)
	{
		Status = STATUS_INSUFFICIENT_RESOURCES;
		goto Error1;
	}

	//
	// Copy numeric values.
	//

	RtlZeroMemory(Result, sizeof(ADDRINFOEXW));
	Result->ai_flags = AddrInfo->ai_flags;
	Result->ai_family = AddrInfo->ai_family;
	Result->ai_socktype = AddrInfo->ai_socktype;
	Result->ai_protocol = AddrInfo->ai_protocol;
	Result->ai_addrlen = AddrInfo->ai_addrlen;

	//
	// Copy canonical name.
	//

	ANSI_STRING CanonicalNameAnsi;
	UNICODE_STRING CanonicalNameUnicode;

	if (AddrInfo->ai_canonname)
	{
		RtlInitAnsiString(&CanonicalNameAnsi, AddrInfo->ai_canonname);

		Status = RtlAnsiStringToUnicodeString(&CanonicalNameUnicode, &CanonicalNameAnsi, TRUE);

		if (!NT_SUCCESS(Status))
		{
			goto Error2;
		}

		Result->ai_canonname = CanonicalNameUnicode.Buffer;
	}

	//
	// Copy address.
	//

	Result->ai_addr = AddrInfo->ai_addr;

	//
	// Copy the next structure (recursively).
	//

	PADDRINFOEXW NextAddrInfo;
	Status = KspUtilAddrInfoToAddrInfoEx(AddrInfo->ai_next, &NextAddrInfo);

	if (!NT_SUCCESS(Status))
	{
		goto Error3;
	}

	Result->ai_next = NextAddrInfo;

	//
	// All done!
	//

	*AddrInfoEx = Result;

	return Status;

Error3:
	RtlFreeAnsiString(&CanonicalNameAnsi);

Error2:
	ExFreePool(Result);//ExFreePoolWithTag(Result, MEMORY_TAG);

Error1:
	return Status;
}

int socket_connection(int domain, int type, int protocol)
{
  NTSTATUS Status;
  PKSOCKET Socket;

  Status = KsCreateConnectionSocket(
    &Socket,
    (ADDRESS_FAMILY)domain,
    (USHORT)type,
    (ULONG)protocol
    );

  if (NT_SUCCESS(Status))
  {
    int sockfd = TO_SOCKETFD(KsIndex++);

    KsArray[FROM_SOCKETFD(sockfd)] = Socket;

    return sockfd;
  }

  return -1;
}


int socket_datagram(int domain, int type, int protocol)
{
  NTSTATUS Status;
  PKSOCKET Socket;

  Status = KsCreateDatagramSocket(
    &Socket,
    (ADDRESS_FAMILY)domain,
    (USHORT)type,
    (ULONG)protocol
    );

  if (NT_SUCCESS(Status))
  {
    int sockfd = TO_SOCKETFD(KsIndex++);

    KsArray[FROM_SOCKETFD(sockfd)] = Socket;

    return sockfd;
  }

  return -1;
}

int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  Status = KsConnect(Socket, (PSOCKADDR)addr);

  return NT_SUCCESS(Status)
    ? 0
    : -1;
}

int listen(int sockfd, int backlog)
{
  UNREFERENCED_PARAMETER(sockfd);
  UNREFERENCED_PARAMETER(backlog);
  return 0;
}

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  Status = KsBind(Socket, (PSOCKADDR)addr);

  return NT_SUCCESS(Status)
    ? 0
    : -1;
}



int send(int sockfd, const void* buf, size_t len, int flags)
{
  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsSend(Socket, (PVOID)buf, &Length, (ULONG)flags);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)
{
  UNREFERENCED_PARAMETER(addrlen);

  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsSendTo(Socket, (PVOID)buf, &Length, (ULONG)flags, (PSOCKADDR)dest_addr);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int recv(int sockfd, void* buf, size_t len, int flags)
{
  NTSTATUS Status;
  PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

  ULONG Length = (ULONG)len;
  Status = KsRecv(Socket, (PVOID)buf, &Length, (ULONG)flags);

  return NT_SUCCESS(Status)
    ? (int)Length
    : -1;
}

int socket_listen(int domain, int type, int protocol)
{
	NTSTATUS Status;
	PKSOCKET Socket;

	//
	// WskSocket() returns STATUS_PROTOCOL_UNREACHABLE (0xC000023E)
	// when Protocol == 0, so coerce this value to IPPROTO_TCP here.
	//

	Status = KsCreateListenSocket(
		&Socket,
		(ADDRESS_FAMILY)domain,
		(USHORT)type,
		protocol ? (ULONG)protocol : IPPROTO_TCP
	);

	if (NT_SUCCESS(Status))
	{
		int sockfd = TO_SOCKETFD(KsIndex++);

		KsArray[FROM_SOCKETFD(sockfd)] = Socket;

		return sockfd;
	}

	return -1;
}

```

`StrunderSv/StrunderSv/ksocket/berkeley.h`:

```h
#pragma once
#include <ntddk.h>
#include <wsk.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef int       socklen_t;
typedef intptr_t  ssize_t;

UINT32 htonl(UINT32 hostlong);
UINT16 htons(UINT16 hostshort);
UINT32 ntohl(UINT32 netlong);
UINT16 ntohs(UINT16 netshort);

int getaddrinfo(const char* node, const char* service, const struct addrinfo* hints, struct addrinfo** res);
void freeaddrinfo(struct addrinfo *res);

int socket_connection(int domain, int type, int protocol);
int socket_listen(int domain, int type, int protocol);
int socket_datagram(int domain, int type, int protocol);
int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
int listen(int sockfd, int backlog);
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int send(int sockfd, const void* buf, size_t len, int flags);
int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
int recv(int sockfd, void* buf, size_t len, int flags);
int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
int closesocket(int sockfd);

#define socket  socket_connection

#ifdef __cplusplus
}
#endif

```

`StrunderSv/StrunderSv/ksocket/ksocket.c`:

```c
#include "ksocket.h"

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

//#define MEMORY_TAG            'STRU'

//////////////////////////////////////////////////////////////////////////
// Structures.
//////////////////////////////////////////////////////////////////////////

typedef struct _KSOCKET_ASYNC_CONTEXT
{
  KEVENT CompletionEvent;
  PIRP Irp;
} KSOCKET_ASYNC_CONTEXT, *PKSOCKET_ASYNC_CONTEXT;

typedef struct _KSOCKET
{
  PWSK_SOCKET	WskSocket;

  union
  {
    PVOID WskDispatch;

    PWSK_PROVIDER_CONNECTION_DISPATCH WskConnectionDispatch;
    PWSK_PROVIDER_LISTEN_DISPATCH WskListenDispatch;
    PWSK_PROVIDER_DATAGRAM_DISPATCH WskDatagramDispatch;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
    PWSK_PROVIDER_STREAM_DISPATCH WskStreamDispatch;
#endif
  };

  KSOCKET_ASYNC_CONTEXT AsyncContext;
} KSOCKET, *PKSOCKET;

//////////////////////////////////////////////////////////////////////////
// Variables.
//////////////////////////////////////////////////////////////////////////

WSK_REGISTRATION     WskRegistration;
WSK_PROVIDER_NPI     WskProvider;
WSK_CLIENT_DISPATCH  WskDispatch = { MAKE_WSK_VERSION(1,0), 0, NULL };

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspAsyncContextAllocate(
  _Out_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  );

VOID
NTAPI
KspAsyncContextFree(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  );

VOID
NTAPI
KspAsyncContextReset(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  );

NTSTATUS
NTAPI
KspAsyncContextCompletionRoutine(
  _In_ PDEVICE_OBJECT	DeviceObject,
  _In_ PIRP Irp,
  _In_ PKEVENT CompletionEvent
  );

NTSTATUS
NTAPI
KspAsyncContextWaitForCompletion(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext,
  _Inout_ PNTSTATUS Status
  );

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspAsyncContextAllocate(
  _Out_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  )
{
  //
  // Initialize the completion event.
  //

  KeInitializeEvent(
    &AsyncContext->CompletionEvent,
    SynchronizationEvent,
    FALSE
    );

  //
  // Initialize the IRP.
  //

  AsyncContext->Irp = IoAllocateIrp(1, FALSE);

  if (AsyncContext->Irp == NULL)
  {
    return STATUS_INSUFFICIENT_RESOURCES;
  }

  //
  // KspAsyncContextCompletionRoutine will set
  // the CompletionEvent.
  //

  IoSetCompletionRoutine(
    AsyncContext->Irp,
    &KspAsyncContextCompletionRoutine,
    &AsyncContext->CompletionEvent,
    TRUE,
    TRUE,
    TRUE
    );

  return STATUS_SUCCESS;
}
NTSTATUS
NTAPI
KsCreateSocket(
	_Out_ PKSOCKET* Socket,
	_In_ ADDRESS_FAMILY AddressFamily,
	_In_ USHORT SocketType,
	_In_ ULONG Protocol,
	_In_ ULONG Flags
)
{
	NTSTATUS Status;

	//
	// Allocate memory for the socket structure.
	//

	PKSOCKET NewSocket = ExAllocatePool(PagedPool, sizeof(KSOCKET));//ExAllocatePoolWithTag(PagedPool, sizeof(KSOCKET), MEMORY_TAG);

	if (!NewSocket)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	//
	// Allocate async context for the socket.
	//

	Status = KspAsyncContextAllocate(&NewSocket->AsyncContext);

	if (!NT_SUCCESS(Status))
	{
		return Status;
	}

	//
	// Create the WSK socket.
	//

	Status = WskProvider.Dispatch->WskSocket(
		WskProvider.Client,         // Client
		AddressFamily,              // AddressFamily
		SocketType,                 // SocketType
		Protocol,                   // Protocol
		Flags,                      // Flags
		NULL,                       // SocketContext
		NULL,                       // Dispatch
		NULL,                       // OwningProcess
		NULL,                       // OwningThread
		NULL,                       // SecurityDescriptor
		NewSocket->AsyncContext.Irp // Irp
	);

	KspAsyncContextWaitForCompletion(&NewSocket->AsyncContext, &Status);

	//
	// Save the socket instance and the socket dispatch table.
	//

	if (NT_SUCCESS(Status))
	{
		NewSocket->WskSocket = (PWSK_SOCKET)NewSocket->AsyncContext.Irp->IoStatus.Information;
		NewSocket->WskDispatch = (PVOID)NewSocket->WskSocket->Dispatch;

		*Socket = NewSocket;
	}

	return Status;
}
VOID
NTAPI
KspAsyncContextFree(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  )
{
  //
  // Free the IRP.
  //

  IoFreeIrp(AsyncContext->Irp);
}

VOID
NTAPI
KspAsyncContextReset(
  _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
  )
{
  //
  // If the WSK application allocated the IRP, or is reusing an IRP
  // that it previously allocated, then it must set an IoCompletion
  // routine for the IRP before calling a WSK function.  In this
  // situation, the WSK application must specify TRUE for the
  // InvokeOnSuccess, InvokeOnError, and InvokeOnCancel parameters that
  // are passed to the IoSetCompletionRoutine function to ensure that
  // the IoCompletion routine is always called. Furthermore, the IoCompletion
  // routine that is set for the IRP must always return
  // STATUS_MORE_PROCESSING_REQUIRED to terminate the completion processing
  // of the IRP.  If the WSK application is done using the IRP after the
  // IoCompletion routine has been called, then it should call the IoFreeIrp
  // function to free the IRP before returning from the IoCompletion routine.
  // If the WSK application does not free the IRP then it can reuse the IRP
  // for a call to another WSK function.
  //
  // (ref: https://docs.microsoft.com/en-us/windows-hardware/drivers/network/using-irps-with-winsock-kernel-functions)
  //

  //
  // Reset the completion event.
  //

  KeResetEvent(&AsyncContext->CompletionEvent);

  //
  // Reuse the IRP.
  //

  IoReuseIrp(AsyncContext->Irp, STATUS_UNSUCCESSFUL);

  IoSetCompletionRoutine(
    AsyncContext->Irp,
    &KspAsyncContextCompletionRoutine,
    &AsyncContext->CompletionEvent,
    TRUE,
    TRUE,
    TRUE
    );
}

NTSTATUS
NTAPI
KspAsyncContextCompletionRoutine(
  _In_ PDEVICE_OBJECT	DeviceObject,
  _In_ PIRP Irp,
  _In_ PKEVENT CompletionEvent
  )
{
  UNREFERENCED_PARAMETER(DeviceObject);
  UNREFERENCED_PARAMETER(Irp);

  KeSetEvent(CompletionEvent, IO_NO_INCREMENT, FALSE);
  return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID
NTAPI
KsDestroy(
  VOID
  )
{
  //
  // Release the provider NPI instance.
  //

  WskReleaseProviderNPI(&WskRegistration);

  //
  // Deregister as a WSK client.
  //

  WskDeregister(&WskRegistration);
}

NTSTATUS
NTAPI
KsGetAddrInfo(
  _In_ PUNICODE_STRING NodeName,
  _In_ PUNICODE_STRING ServiceName,
  _In_ PADDRINFOEXW Hints,
  _Out_ PADDRINFOEXW* Result
  )
{
  NTSTATUS Status;

  //
  // Allocate async context.
  //

  KSOCKET_ASYNC_CONTEXT AsyncContext;
  Status = KspAsyncContextAllocate(&AsyncContext);

  if (!NT_SUCCESS(Status))
  {
    return Status;
  }

  //
  // Call the WSK API.
  //

  Status = WskProvider.Dispatch->WskGetAddressInfo(
    WskProvider.Client,         // Client
    NodeName,                   // NodeName
    ServiceName,                // ServiceName
    0,                          // NameSpace
    NULL,                       // Provider
    Hints,                      // Hints
    Result,                     // Result
    NULL,                       // OwningProcess
    NULL,                       // OwningThread
    AsyncContext.Irp            // Irp
    );

  KspAsyncContextWaitForCompletion(&AsyncContext, &Status);

  //
  // Free the async context.
  //

  KspAsyncContextFree(&AsyncContext);

  return Status;
}
NTSTATUS
NTAPI
KsSendTo(
	_In_ PKSOCKET Socket,
	_In_ PVOID Buffer,
	_Inout_ PULONG Length,
	_In_ ULONG Flags,
	_In_ PSOCKADDR RemoteAddress
)
{
	return KsSendRecvUdp(Socket, Buffer, Length, Flags, RemoteAddress, TRUE);
}

NTSTATUS
NTAPI
KsRecvFrom(
	_In_ PKSOCKET Socket,
	_In_ PVOID Buffer,
	_Inout_ PULONG Length,
	_In_ ULONG Flags,
	_In_ PSOCKADDR RemoteAddress
)
{
	return KsSendRecvUdp(Socket, Buffer, Length, Flags, RemoteAddress, FALSE);
}

VOID
NTAPI
KsFreeAddrInfo(
  _In_ PADDRINFOEXW AddrInfo
  )
{
  WskProvider.Dispatch->WskFreeAddressInfo(
    WskProvider.Client,         // Client
    AddrInfo                    // AddrInfo
    );
}



NTSTATUS
NTAPI
KsCreateConnectionSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  )
{
  return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_CONNECTION_SOCKET);
}

NTSTATUS
NTAPI
KsCreateListenSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  )
{
  return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_LISTEN_SOCKET);
}

NTSTATUS
NTAPI
KsCreateDatagramSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  )
{
  return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_DATAGRAM_SOCKET);
}

NTSTATUS
NTAPI
KsCloseSocket(
  _In_ PKSOCKET Socket
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Close the WSK socket.
  //

  Status = Socket->WskConnectionDispatch->WskCloseSocket(
    Socket->WskSocket,
    Socket->AsyncContext.Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Free the async context.
  //

  KspAsyncContextFree(&Socket->AsyncContext);

  //
  // Free memory for the socket structure.
  //

  ExFreePool(Socket); //ExFreePoolWithTag(Socket, MEMORY_TAG);

  return Status;
}
NTSTATUS
NTAPI
KspAsyncContextWaitForCompletion(
	_In_ PKSOCKET_ASYNC_CONTEXT AsyncContext,
	_Inout_ PNTSTATUS Status
)
{
	if (*Status == STATUS_PENDING)
	{
		KeWaitForSingleObject(
			&AsyncContext->CompletionEvent,
			Executive,
			KernelMode,
			FALSE,
			NULL
		);

		*Status = AsyncContext->Irp->IoStatus.Status;
	}

	return *Status;
}

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KsInitialize(
	VOID
)
{
	NTSTATUS Status;

	//
	// Register as a WSK client.
	//

	WSK_CLIENT_NPI WskClient;
	WskClient.ClientContext = NULL;
	WskClient.Dispatch = &WskDispatch;

	Status = WskRegister(&WskClient, &WskRegistration);

	if (!NT_SUCCESS(Status))
	{
		return Status;
	}

	//
	// Capture the provider NPI.
	//

	return WskCaptureProviderNPI(
		&WskRegistration,
		WSK_INFINITE_WAIT,
		&WskProvider
	);
}
NTSTATUS
NTAPI
KsBind(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR LocalAddress
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Bind the socket.
  //

  Status = Socket->WskListenDispatch->WskBind(
    Socket->WskSocket,          // Socket
    LocalAddress,               // LocalAddress
    0,                          // Flags (reserved)
    Socket->AsyncContext.Irp    // Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  return Status;
}

NTSTATUS
NTAPI
KsAccept(
  _In_ PKSOCKET Socket,
  _Out_ PKSOCKET* NewSocket,
  _Out_opt_ PSOCKADDR LocalAddress,
  _Out_opt_ PSOCKADDR RemoteAddress
  )
{
  NTSTATUS Status;

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Accept the connection.
  //

  Status = Socket->WskListenDispatch->WskAccept(
    Socket->WskSocket,          // ListenSocket
    0,                          // Flags
    NULL,                       // AcceptSocketContext
    NULL,                       // AcceptSocketDispatch
    LocalAddress,               // LocalAddress
    RemoteAddress,              // RemoteAddress
    Socket->AsyncContext.Irp    // Irp
    );

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Save the socket instance and the socket dispatch table.
  //

  if (NT_SUCCESS(Status))
  {
    PKSOCKET KNewSocket = ExAllocatePool(PagedPool, sizeof(KSOCKET)); //ExAllocatePoolWithTag(PagedPool, sizeof(KSOCKET), MEMORY_TAG);

    if (!KNewSocket)
    {
      return STATUS_INSUFFICIENT_RESOURCES;
    }

    KNewSocket->WskSocket = (PWSK_SOCKET)Socket->AsyncContext.Irp->IoStatus.Information;
    KNewSocket->WskDispatch = (PVOID)KNewSocket->WskSocket->Dispatch;
    KspAsyncContextAllocate(&KNewSocket->AsyncContext);

    *NewSocket = KNewSocket;
  }

  return Status;
}



NTSTATUS
NTAPI
KsSendRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ BOOLEAN Send
  )
{
  NTSTATUS Status;

  //
  // Wrap the buffer into the "WSK buffer".
  //

  WSK_BUF WskBuffer;
  WskBuffer.Offset  = 0;
  WskBuffer.Length  = *Length;
  WskBuffer.Mdl     = IoAllocateMdl(Buffer, (ULONG)WskBuffer.Length, FALSE, FALSE, NULL);

  __try
  {
    MmProbeAndLockPages(WskBuffer.Mdl, KernelMode, IoWriteAccess);
  }
  __except (EXCEPTION_EXECUTE_HANDLER)
  {
    Status = STATUS_ACCESS_VIOLATION;
    goto Error;
  }

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Send / receive the data.
  //

  if (Send)
  {
    Status = Socket->WskConnectionDispatch->WskSend(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags
      Socket->AsyncContext.Irp  // Irp
      );
  }
  else
  {
    Status = Socket->WskConnectionDispatch->WskReceive(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags
      Socket->AsyncContext.Irp  // Irp
      );
  }

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Set the number of bytes sent / received.
  //

  if (NT_SUCCESS(Status))
  {
    *Length = (ULONG)Socket->AsyncContext.Irp->IoStatus.Information;
  }

  //
  // Free the MDL.
  //

  MmUnlockPages(WskBuffer.Mdl);

Error:
  IoFreeMdl(WskBuffer.Mdl);
  return Status;
}
NTSTATUS
NTAPI
KsConnect(
	_In_ PKSOCKET Socket,
	_In_ PSOCKADDR RemoteAddress
)
{
	NTSTATUS Status;

	//
	// Reset the async context.
	//

	KspAsyncContextReset(&Socket->AsyncContext);

	//
	// Bind the socket to the local address.
	//

	SOCKADDR_IN LocalAddress;
	LocalAddress.sin_family = AF_INET;
	LocalAddress.sin_addr.s_addr = INADDR_ANY;
	LocalAddress.sin_port = 0;

	Status = Socket->WskConnectionDispatch->WskBind(
		Socket->WskSocket,          // Socket
		(PSOCKADDR)&LocalAddress,   // LocalAddress
		0,                          // Flags (reserved)
		Socket->AsyncContext.Irp    // Irp
	);

	KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

	if (!NT_SUCCESS(Status))
	{
		return Status;
	}

	//
	// Reset the async context (again).
	//

	KspAsyncContextReset(&Socket->AsyncContext);

	//
	// Connect to the remote host.
	//
	// N.B.: Instead of calling WskSocket(), WskBind() and WskConnect(),
	// it is possible to just call WskSocketConnect().
	//

	Status = Socket->WskConnectionDispatch->WskConnect(
		Socket->WskSocket,          // Socket
		RemoteAddress,              // RemoteAddress
		0,                          // Flags (reserved)
		Socket->AsyncContext.Irp    // Irp
	);

	KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

	return Status;
}
NTSTATUS
NTAPI
KsSendRecvUdp(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress,
  _In_ BOOLEAN Send
  )
{
  NTSTATUS Status;

  //
  // Wrap the buffer into the "WSK buffer".
  //

  WSK_BUF WskBuffer;
  WskBuffer.Offset  = 0;
  WskBuffer.Length  = *Length;
  WskBuffer.Mdl     = IoAllocateMdl(Buffer, (ULONG)WskBuffer.Length, FALSE, FALSE, NULL);

  __try
  {
    MmProbeAndLockPages(WskBuffer.Mdl, KernelMode, IoWriteAccess);
  }
  __except (EXCEPTION_EXECUTE_HANDLER)
  {
    Status = STATUS_ACCESS_VIOLATION;
    goto Error;
  }

  //
  // Reset the async context.
  //

  KspAsyncContextReset(&Socket->AsyncContext);

  //
  // Send / receive the data.
  //

  if (Send)
  {
    Status = Socket->WskDatagramDispatch->WskSendTo(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags (reserved)
      RemoteAddress,            // RemoteAddress
      0,                        // ControlInfoLength
      NULL,                     // ControlInfo
      Socket->AsyncContext.Irp  // Irp
      );
  }
  else
  {
    //
    // Use #pragma prefast (suppress: ...), because SAL annotation is wrong
    // for this function.
    //
    // From MSDN:
    //   ControlLength
    //   ControlInfo
    //
    //   ... This pointer is optional and can be NULL.  If the ControlInfoLength
    //   parameter is NULL, the ControlInfo parameter should be NULL.
    //

#pragma prefast (                                                                           \
    suppress:__WARNING_INVALID_PARAM_VALUE_1,                                               \
    "If the ControlInfoLength parameter is NULL, the ControlInfo parameter should be NULL." \
    )

    Status = Socket->WskDatagramDispatch->WskReceiveFrom(
      Socket->WskSocket,        // Socket
      &WskBuffer,               // Buffer
      Flags,                    // Flags (reserved)
      RemoteAddress,            // RemoteAddress
      NULL,                     // ControlInfoLength
      NULL,                     // ControlInfo
      NULL,                     // ControlFlags
      Socket->AsyncContext.Irp  // Irp
      );
  }

  KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

  //
  // Set the number of bytes sent / received.
  //

  if (NT_SUCCESS(Status))
  {
    *Length = (ULONG)Socket->AsyncContext.Irp->IoStatus.Information;
  }

  //
  // Free the MDL.
  //

  MmUnlockPages(WskBuffer.Mdl);

Error:
  IoFreeMdl(WskBuffer.Mdl);
  return Status;
}

NTSTATUS
NTAPI
KsSend(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  )
{
  return KsSendRecv(Socket, Buffer, Length, Flags, TRUE);
}

NTSTATUS
NTAPI
KsRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  )
{
  return KsSendRecv(Socket, Buffer, Length, Flags, FALSE);
}


```

`StrunderSv/StrunderSv/ksocket/ksocket.h`:

```h
#pragma once
#include <ntddk.h>
#include <wsk.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _KSOCKET KSOCKET, *PKSOCKET;

NTSTATUS
NTAPI
KsInitialize(
  VOID
  );

VOID
NTAPI
KsDestroy(
  VOID
  );

NTSTATUS
NTAPI
KsGetAddrInfo(
  _In_ PUNICODE_STRING NodeName,
  _In_ PUNICODE_STRING ServiceName,
  _In_ PADDRINFOEXW Hints,
  _Out_ PADDRINFOEXW* Result
  );

VOID
NTAPI
KsFreeAddrInfo(
  _In_ PADDRINFOEXW AddrInfo
  );

NTSTATUS
NTAPI
KsCreateSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol,
  _In_ ULONG Flags
  );

NTSTATUS
NTAPI
KsCreateConnectionSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  );

NTSTATUS
NTAPI
KsCreateListenSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  );

NTSTATUS
NTAPI
KsCreateDatagramSocket(
  _Out_ PKSOCKET* Socket,
  _In_ ADDRESS_FAMILY AddressFamily,
  _In_ USHORT SocketType,
  _In_ ULONG Protocol
  );

NTSTATUS
NTAPI
KsCloseSocket(
  _In_ PKSOCKET Socket
  );

NTSTATUS
NTAPI
KsBind(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR LocalAddress
  );

NTSTATUS
NTAPI
KsAccept(
  _In_ PKSOCKET Socket,
  _Out_ PKSOCKET* NewSocket,
  _Out_opt_ PSOCKADDR LocalAddress,
  _Out_opt_ PSOCKADDR RemoteAddress
  );

NTSTATUS
NTAPI
KsConnect(
  _In_ PKSOCKET Socket,
  _In_ PSOCKADDR RemoteAddress
  );

NTSTATUS
NTAPI
KsSendRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ BOOLEAN Send
  );

NTSTATUS
NTAPI
KsSendRecvUdp(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress,
  _In_ BOOLEAN Send
  );

NTSTATUS
NTAPI
KsSend(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  );

NTSTATUS
NTAPI
KsRecv(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags
  );

NTSTATUS
NTAPI
KsSendTo(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress
  );

NTSTATUS
NTAPI
KsRecvFrom(
  _In_ PKSOCKET Socket,
  _In_ PVOID Buffer,
  _Inout_ PULONG Length,
  _In_ ULONG Flags,
  _In_ PSOCKADDR RemoteAddress
  );

#ifdef __cplusplus
}
#endif

```

`StrunderSv/StrunderSv/log.h`:

```h
#pragma once
//#include <ntddk.h>

#ifdef DEBUG
//#define log(text) DbgPrintEx(0, 0, text);
#define log(text,...) DbgPrintEx(0, 0, text,__VA_ARGS__);
#else
//#define log(text)
#define log(text,...)
#endif


```

`StrunderSv/StrunderSv/main.cpp`:

```cpp
#include "bypass.h"
#include "server.h"

#ifdef DEBUG
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
	__kernel_entry NTSTATUS NtQueryInformationThread(
		IN HANDLE          ThreadHandle,
		IN THREADINFOCLASS ThreadInformationClass,
		OUT PVOID          ThreadInformation,
		IN ULONG           ThreadInformationLength,
		OUT PULONG         ReturnLength
	);

	NTSTATUS
		PsSetContextThread(
			__in PETHREAD Thread,
			__in PCONTEXT ThreadContext,
			__in KPROCESSOR_MODE Mode
		);

	NTSTATUS 
		PsGetContextThread(
			__in PETHREAD Thread,
			__inout PCONTEXT ThreadContext,
			__in KPROCESSOR_MODE PreviousMode
		);

	NTSYSCALLAPI
		NTSTATUS
		NTAPI
		ZwSuspendThread(
			_In_ HANDLE ThreadHandle,
			_Out_opt_ PULONG PreviousSuspendCount
		);

	
	NTSTATUS PsLookupThreadByThreadId(
		HANDLE   ThreadId,
		PETHREAD* Thread
	);
#ifdef __cplusplus
}
#endif // __cplusplus
#endif

#ifdef DEBUG

//PspCreateThread(OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PEPROCESS ProcessPointer, OUT PCLIENT_ID ClientId OPTIONAL, IN PCONTEXT ThreadContext OPTIONAL, IN VOID* InitialTeb OPTIONAL, IN BOOLEAN CreateSuspended, IN PKSTART_ROUTINE StartRoutine OPTIONAL, IN PVOID StartContext);
typedef NTSTATUS(* _PspCreateThread)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, HANDLE, PEPROCESS, PCLIENT_ID, PCONTEXT,VOID*, BOOLEAN, PKSTART_ROUTINE, PVOID);
_PspCreateThread PspCreateThread;

typedef NTSTATUS(NTAPI*_PspGetContextThreadInternal)(PETHREAD, PCONTEXT, KPROCESSOR_MODE, KPROCESSOR_MODE, KPROCESSOR_MODE);
_PspGetContextThreadInternal PspGetContextThreadInternal;

typedef NTSTATUS(NTAPI* _PspSetContextThreadInternal)(PETHREAD, PCONTEXT, KPROCESSOR_MODE, KPROCESSOR_MODE, KPROCESSOR_MODE);
_PspSetContextThreadInternal PspSetContextThreadInternal;

typedef struct _ETHREAD
{
	unsigned char shit[0x06A0];
	PVOID Win32StartAddress;
} ETHREAD, * PETHREAD;
#endif

VOID ActiveLoop(_In_ PVOID StartContext) {
	UNICODE_STRING uniName;
	RtlInitUnicodeString(&uniName, L"\\DosDevices\\C:\\s.txt");
	while (GetGlobalActive()) {
		Sleep(2000); //Every 2 seconds check for close driver request
		if (fileExists(uniName)) {
			log("Bye\n");
			SetGlobalActive(FALSE);
			return;
		}
	}
}

void InitThreads() {
	StartThread(ActiveLoop, nullptr);
	StartThread(server_thread, nullptr);
}

#ifdef DEBUG
void TestFunction(void* params) {
	int k = 10000;
	while (k > 0) {
		Sleep(100);
		DbgPrintEx(0, 0, "im the fucking %lu\n", PsGetCurrentThreadId());
		k--;
	}
}


void NewFunction(void* params) {
	DbgPrintEx(0,0,"Thread fucked\n");
}
#endif


VOID RealM(void* args) {
	log("Driver Loading\n");
	Sleep(2000); //make sure kdmapper closed
	log("Driver Loaded\n");
	J();

	//PREPARE BUFFERED AREA
	log("To Allocate %ld bytes\n", sizeof(BasicDataArea));
	//PVOID tmpA = ExAllocatePool(NonPagedPool, sizeof(BasicDataArea));
	//PVOID tmpA = buffer3;
	//if (tmpA == nullptr) {
	//	log("Can't allocate DataArea for buffers\n");
	//	return;
	//}
	////RtlSecureZeroMemory(tmpA, sizeof(BasicDataArea));
	//SetDataArea(tmpA);
	//DataArea = {};

	UNICODE_STRING intelDrv;
	DataArea.IVDName[0] = L'i';
	DataArea.IVDName[2] = L'q';
	DataArea.IVDName[4] = L'v';
	DataArea.IVDName[6] = L'w';
	DataArea.IVDName[8] = L'6';
	DataArea.IVDName[10] = L'4';
	DataArea.IVDName[12] = L'e';
	DataArea.IVDName[14] = L'.';
	DataArea.IVDName[16] = L's';
	DataArea.IVDName[18] = L'y';
	DataArea.IVDName[20] = L's';
	RtlInitUnicodeString(&intelDrv, (PCWSTR)DataArea.IVDName);// L"iqvw64e.sys");
	J();
	const UINT64 result = ClearCacheEntry(intelDrv);

	//clear any trace about the vulnerable driver
	RtlSecureZeroMemory(intelDrv.Buffer, intelDrv.Length);
	intelDrv.Length = 0;
	intelDrv.MaximumLength = 0;
	RtlSecureZeroMemory(DataArea.IVDName, 100);
	if (result == 0) {
		log("Load cancelled, can't clean the PiDDBCache\n");
		return;
	}

	J();

#ifdef DEBUG



	PspGetContextThreadInternal = (_PspGetContextThreadInternal)SearchNtoskrnlPattern((UCHAR*)"\x40\x55\x57\x41\x54\x41\x56\x41\x57\x48\x81\xec\xf0\x01\x00", "ccccccccccccccc", NULL);
	PspSetContextThreadInternal = (_PspSetContextThreadInternal)SearchNtoskrnlPattern((UCHAR*)"\x40\x55\x41\x54\x41\x56\x48\x81\xec\xe0\x01\x00\x00", "ccccccccccccc", NULL);
	PspCreateThread = (_PspCreateThread)SearchNtoskrnlPattern((UCHAR*)"\x40\x55\x53\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x8D\xAC\x24\x90\xFE\xFF\xFF", "cccccccccccccccccccc", NULL);
	DbgPrintEx(0, 0, "PspGetContextThreadInternal = %llx\n", PspGetContextThreadInternal);
	DbgPrintEx(0, 0, "PspSetContextThreadInternal = %llx\n", PspSetContextThreadInternal);
	DbgPrintEx(0, 0, "PspCreateThread = %llx\n", PspCreateThread);


	HANDLE thread_handle = nullptr;
	CLIENT_ID xx;

	//NTSTATUS statusx = PsCreateSystemThread(&thread_handle, GENERIC_ALL, nullptr, nullptr, &xx, TestFunction, nullptr);
	//NTSTATUS statusx = PspCreateThread(&thread_handle, GENERIC_ALL, nullptr, nullptr, IoGetCurrentProcess(), nullptr/*&xx*/, nullptr, nullptr, false, TestFunction, nullptr);
	//if (NT_SUCCESS(statusx)) {
	//	DbgPrintEx(0, 0, "created as %d\n", xx.UniqueThread);
	//	PETHREAD thread;
	//	statusx = PsLookupThreadByThreadId(xx.UniqueThread,&thread);
	//	if (NT_SUCCESS(statusx)) {
	//		DbgPrintEx(0, 0, "%d-%llx\n", xx.UniqueThread, (ULONG64)TestFunction);
	//		DbgPrintEx(0, 0, "%llx\n", thread->Win32StartAddress);

	//		thread->Win32StartAddress = (PVOID)0xfffff8057b800000; //Modify StartAddress
	//		statusx = PsLookupThreadByThreadId(xx.UniqueThread, &thread);
	//		if (NT_SUCCESS(statusx)) {
	//			DbgPrintEx(0, 0, "MOD %#010x", thread->Win32StartAddress);
	//		}


	//		ULONG resultx;
	//		statusx= ZwSuspendThread(thread,&resultx);
	//		
	//		CONTEXT Ctx = { 0 };
	//		Ctx.ContextFlags = CONTEXT_ALL;
	//		statusx = -1;
	//		
	//		while (!NT_SUCCESS(statusx)) { //GetContext sometimes fails :S
	//			Sleep(1);
	//			statusx = PspGetContextThreadInternal(thread, &Ctx, KernelMode, 0, 0);
	//		}
	//		
	//		if (NT_SUCCESS(statusx)) {
	//			// Sleep(15000);
	//			DbgPrintEx(0, 0, "%llx %p\n", Ctx.Rip, KeDelayExecutionThread);
	//			Ctx.Rip = (ULONG64)NewFunction;

	//			statusx = -1;
	//			while (!NT_SUCCESS(statusx)) { //GetContext sometimes fails :S
	//				Sleep(1);
	//				statusx = PspSetContextThreadInternal(thread, &Ctx, KernelMode, 0, 0);
	//			}
	//			
	//			DbgPrintEx(0, 0, "OK\n");

	//			//Ctx.Rip=
	//			//context.Rip = (ULONG64)NewFunction;

	//			//statusx=PsSetContextThread(thread, &context, KernelMode);
	//			//if (NT_SUCCESS(statusx)) {
	//			//	//statusx = PsResumeThread(thread,&resultx);
	//			//	DbgPrintEx(0, 0, "Done");
	//			//}
	//			//else {
	//			//	return 4;
	//			//}
	//		}
	//		else {
	//			DbgPrintEx(0, 0, "%llx", statusx);
	//			return 3;
	//		}
	//	}
	//	else {
	//		return 2;
	//	}
	//	
	//	ZwClose(thread_handle);
	//	return 0;
	//}

	//return;

	//PETHREAD X = PsGetCurrentThread();
	//PCONTEXT tcontext;
	//NTSTATUS sta = PsGetContextThread(X, tcontext, KernelMode);

	//if (NT_SUCCESS(sta)) {

	//	tcontext->Header

	//}


	////HANDLE current_thread = PsGetCurrentThread()->Win32StartAddress;
	////DWORD dwStartAddress;
	//NTSTATUS status = 0;//NtQueryInformationThread(current_thread,ThreadQuerySetWin32StartAddress,&dwStartAddress,sizeof(DWORD),NULL);
	//if (NT_SUCCESS(status)) {
	//	PETHREAD X = PsGetCurrentThread();
	//	
	//	ULONG64 x2 = ((ULONG64*)X)[0x0690];
	//	//x2 = x2 + 0x0690;
	//	//PVOID x = *(PVOID*)x2;
	//	log("Start %#010x", x2);
	//}
	//else {
	//	log("NtQueryInformationThread fail %#010x",status);
	//}

#endif
	//INIT
	InitThreads();
	J();
}

extern "C" NTSTATUS MainEntry(PDRIVER_OBJECT, PUNICODE_STRING) {
	StartThread(RealM, nullptr);
	return STATUS_SUCCESS;
}




//uintptr_t pPspGetContextThreadInternal = (uintptr_t)((ULONG*)PsGetContextThread);

//pPspGetContextThreadInternal = pPspGetContextThreadInternal + 6ULL + *(int*)(pPspGetContextThreadInternal + 2); // follow the jmp to PsGetContextThread
//pPspGetContextThreadInternal = *(uintptr_t*)pPspGetContextThreadInternal;

//pPspGetContextThreadInternal += 12;  // go to the call PspGetContextThreadInternal line

//pPspGetContextThreadInternal = pPspGetContextThreadInternal + 5 + *(int*)(pPspGetContextThreadInternal + 1); // Read PspGetContextThreadInternal Addr

//PspGetContextThreadInternal = (_PspGetContextThreadInternal)pPspGetContextThreadInternal;

//DbgPrintEx(0, 0, "PspGetContextThreadInternal = %llx\n", PspGetContextThreadInternal);
```

`StrunderSv/StrunderSv/packet_handler.cpp`:

```cpp
#include "packet_handler.h"

UINT64 handle_incoming_packet(const Packet& packet)
{
	switch (packet.header.type)
	{
	case PacketType::packet_copy_memory:
		return handle_copy_memory(packet.data.copy_memory);

	case PacketType::packet_get_base_address:
		return handle_get_base_address(packet.data.get_base_address);

	case PacketType::packet_get_pid:
		return handle_get_pid(packet.data.get_pid);
	default:
		break;
	}

	return UINT64(STATUS_NOT_IMPLEMENTED);
}

// Send completion packet.
bool complete_request(const SOCKET client_connection, const UINT64 result)
{
	Packet packet{ };

	//packet.header.magic				= packet_magic;
	packet.header.type = PacketType::packet_completed;
	packet.data.completed.result = result;

	return send(client_connection, &packet, sizeof(packet), 0) != SOCKET_ERROR;
}

static UINT64 handle_copy_memory(const PacketCopyMemory& packet)
{
	PEPROCESS dest_process = nullptr;
	PEPROCESS src_process  = nullptr;

//#ifdef DEBUG
//	DbgPrintEx(0, 0, "PacketCopyMemory packet\n");
//	unsigned char* buff = (unsigned char*)&packet;
//	for (size_t i = 0; i < sizeof(PacketCopyMemory); i++) {
//		DbgPrintEx(0, 0, "%hhx", buff[i]);
//	}
//#endif // DEBUG

	
	
	if (packet.src_process_id == 0) { //ignore pid not set
		return UINT64(STATUS_INVALID_CID);
	}
	log("CPMem received from %d at %#010x to %d at %#010x", packet.src_process_id, packet.src_address, packet.dest_process_id, packet.dest_address);
	if (!NT_SUCCESS(PsLookupProcessByProcessId(HANDLE(packet.dest_process_id), &dest_process)))
	{
		J();
		return UINT64(STATUS_INVALID_CID);
	}

	if (!NT_SUCCESS(PsLookupProcessByProcessId(HANDLE(packet.src_process_id), &src_process)))
	{
		J();
		ObDereferenceObject(dest_process);
		return UINT64(STATUS_INVALID_CID);
	}
	J();
	SIZE_T   return_size = 0;
	NTSTATUS status = MmCopyVirtualMemory(
		src_process,
		(void*)packet.src_address,
		dest_process,
		(void*)packet.dest_address,
		packet.size,
		UserMode,
		&return_size
	);
	ObDereferenceObject(dest_process);
	ObDereferenceObject(src_process);

	return UINT64(status);
}

static UINT64 handle_get_base_address(const PacketGetBaseAddress& packet)
{
	PEPROCESS process = nullptr;
	
//#ifdef DEBUG
//	DbgPrintEx(0, 0, "PacketGetBaseAddress packet pid: %d\n",packet.process_id);
//	unsigned char* buff = (unsigned char*)&packet;
//	for (size_t i = 0; i < sizeof(PacketGetBaseAddress); i++) {
//		DbgPrintEx(0, 0, "%hhx", buff[i]);
//	}
//#endif // DEBUG
	
	NTSTATUS  status  = PsLookupProcessByProcessId(HANDLE(packet.process_id), &process);

	if (!NT_SUCCESS(status))
		return 0;
	J();
	UINT64 base_address = (UINT64)PsGetProcessSectionBaseAddress(process);

	log("Base Address: %#010x", base_address);

	ObDereferenceObject(process);

	return base_address;
}

static UINT64 handle_get_pid(const PacketGetPid& packet)
{
	
	HANDLE pid = FindProcessByName((wchar_t*)packet.name, packet.len);

	RtlSecureZeroMemory((PVOID)&packet.name[0], 200);

	return UINT64(pid);
}



```

`StrunderSv/StrunderSv/packet_handler.h`:

```h
#pragma once

//#include "util.h"
#include <ntddk.h>
#include "server_shared.h"
#include "sockets.h"
#include "eimport.h"
#include "JUNK.h"
#include "log.h"
#include "util.h"

static UINT64 handle_copy_memory(const PacketCopyMemory& packet);
static UINT64 handle_get_base_address(const PacketGetBaseAddress& packet);
static UINT64 handle_get_pid(const PacketGetPid& packet);
UINT64 handle_incoming_packet(const Packet& packet);
bool complete_request(const SOCKET client_connection, const UINT64 result);
```

`StrunderSv/StrunderSv/server.cpp`:

```cpp
#include "server.h"

int tc = 0;



// Connection handling thread.
static void NTAPI connection_thread(void* connection_socket)
{
	const auto client_connection = SOCKET(ULONG_PTR(connection_socket));
	log("New connection.");
	J();
	Packet packet{ };
	while (GetGlobalActive())
	{
		const auto result = recv(client_connection, (void*)&packet, sizeof(packet), 0);
		if (result <= 0)
			break;

		if (result < sizeof(PacketHeader))
			continue;

		if (!GetGlobalActive())
			break;


//#ifdef DEBUG
//		
//		DbgPrintEx(0, 0, "int size %d type size %d\n",sizeof(unsigned int),sizeof(packet.header.type));
//
//		DbgPrintEx(0, 0, "Full packet\n");
//		unsigned char* buff = (unsigned char*)&packet;
//		for (size_t i = 0; i < sizeof(packet); i++) {
//			DbgPrintEx(0, 0, "%hhx", buff[i]);
//		}
//#endif // DEBUG

		//if (packet.header.magic != packet_magic)
		//	continue;

		const auto packet_result = handle_incoming_packet(packet);
		if (!complete_request(client_connection, packet_result))
			break;
	}
	J();
	log("Connection closed.");
	closesocket(client_connection);
	tc--;
}

// Main server thread.
void NTAPI server_thread(void*)
{
	J();
	auto status = KsInitialize();
	J();
	if (!NT_SUCCESS(status))
	{
		log("Failed to initialize KSOCKET. Status code: %X.", status);
		return;
	}

	const auto listen_socket = create_listen_socket();
	if (listen_socket == INVALID_SOCKET)
	{
		log("Failed to initialize listening socket.");

		KsDestroy();
		return;
	}
	J();
	log("Listening on port %d.", server_port);

	while (GetGlobalActive())
	{
		sockaddr  socket_addr{ };
		socklen_t socket_length{ };

		while (tc > 10) {
			Sleep(1000);
		}
		if (!GetGlobalActive()) {
			break;
		}
		const auto client_connection = accept(listen_socket, &socket_addr, &socket_length);
		if (client_connection == INVALID_SOCKET)
		{
			log("Failed to accept client connection.");
			break;
		}

		HANDLE thread_handle = nullptr;
		J();
		// Create a thread that will handle connection with client.
		// TODO: Limit number of threads.
		status = StartThread(connection_thread,(void*)client_connection);

		if (!NT_SUCCESS(status))
		{
			log("Failed to create thread for handling client connection.");
			closesocket(client_connection);
			break;
		}
		tc++;
		J();
		ZwClose(thread_handle);
	}
	J();
	closesocket(listen_socket);

	SetGlobalActive(FALSE);

	while (tc > 0) {
		log("Waiting for %d active connection threads\n", tc);
		Sleep(1000);
	}
	KsDestroy();
}
static SOCKET create_listen_socket()
{
	SOCKADDR_IN address{ };

	address.sin_family = AF_INET;
	address.sin_port = htons(server_port);

	const auto listen_socket = socket_listen(AF_INET, SOCK_STREAM, 0);
	if (listen_socket == INVALID_SOCKET)
	{
		log("Failed to create listen socket.");
		return INVALID_SOCKET;
	}

	if (bind(listen_socket, (SOCKADDR*)&address, sizeof(address)) == SOCKET_ERROR)
	{
		log("Failed to bind socket.");

		closesocket(listen_socket);
		return INVALID_SOCKET;
	}

	//if (listen(listen_socket, 10) == SOCKET_ERROR)
	//{
	//	log("Failed to set socket mode to listening.");

	//	closesocket(listen_socket);
	//	return INVALID_SOCKET;
	//}

	return listen_socket;
}
```

`StrunderSv/StrunderSv/server.h`:

```h
#pragma once

#include "util.h"
#include "server_shared.h"
#include "sockets.h"
#include "packet_handler.h"
#include "log.h"




static SOCKET create_listen_socket();
static void NTAPI connection_thread(void* connection_socket);
void NTAPI server_thread(void*);
```

`StrunderSv/StrunderSv/server_shared.h`:

```h
#pragma once
//#include "util.h"
//#include <stdint.h>

//constexpr auto packet_magic = 0x12345568;
constexpr auto server_ip	= 0x7F000001; // 127.0.0.1
constexpr auto server_port  = 4662;

enum class PacketType
{
	packet_copy_memory,
	packet_get_base_address,
	packet_get_pid,
	packet_completed
};

struct PacketCopyMemory
{
	unsigned int dest_process_id;
	unsigned long long dest_address;

	unsigned int src_process_id;
	unsigned long long src_address;

	unsigned int size;
};

struct PacketGetBaseAddress
{
	unsigned int process_id;
};

struct PacketGetPid
{
	size_t len;
	wchar_t name[256];
};

struct PackedCompleted
{
	unsigned long long result;
};

struct PacketHeader
{
	//uint32_t   magic;
	PacketType type;
};

struct Packet
{
	PacketHeader header;
	union
	{
		PacketCopyMemory	 copy_memory;
		PacketGetBaseAddress get_base_address;
		PacketGetPid get_pid;
		PackedCompleted		 completed;
	} data;
};
```

`StrunderSv/StrunderSv/sockets.h`:

```h
#pragma once

extern "C"
{
	#include "ksocket/ksocket.h"
	#include "ksocket/berkeley.h"
}

typedef int SOCKET;

#define INVALID_SOCKET  (SOCKET)(-1)
#define SOCKET_ERROR            (-1)
```

`StrunderSv/StrunderSv/structs.h`:

```h
#pragma once

#include <ntddk.h>

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize; // since VISTA
	ULONG HardFaultCount; // since WIN7
	ULONG NumberOfThreadsHighWatermark; // since WIN7
	ULONGLONG CycleTime; // since WIN7
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey; // since VISTA (requires SystemExtendedProcessInformation)
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	//SYSTEM_THREAD_INFORMATION Threads[1]; // SystemProcessInformation
	// SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1]; // SystemExtendedProcessinformation
	// SYSTEM_EXTENDED_THREAD_INFORMATION + SYSTEM_PROCESS_INFORMATION_EXTENSION // SystemFullProcessInformation
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;
typedef struct _PiDDBCacheEntry
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
} PiDDBCacheEntry, * NPiDDBCacheEntry;
typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;
typedef enum system_information_class_t
{
	SystemBasicInformation = 0,
	SystemProcessorInformation = 1,             // obsolete...delete
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemPathInformation = 4,
	SystemProcessInformation = 5,
	SystemCallCountInformation = 6,
	SystemDeviceInformation = 7,
	SystemProcessorPerformanceInformation = 8,
	SystemFlagsInformation = 9,
	SystemCallTimeInformation = 10,
	SystemModuleInformation = 11,
	SystemLocksInformation = 12,
	SystemStackTraceInformation = 13,
	SystemPagedPoolInformation = 14,
	SystemNonPagedPoolInformation = 15,
	SystemHandleInformation = 16,
	SystemObjectInformation = 17,
	SystemPageFileInformation = 18,
	SystemVdmInstemulInformation = 19,
	SystemVdmBopInformation = 20,
	SystemFileCacheInformation = 21,
	SystemPoolTagInformation = 22,
	SystemInterruptInformation = 23,
	SystemDpcBehaviorInformation = 24,
	SystemFullMemoryInformation = 25,
	SystemLoadGdiDriverInformation = 26,
	SystemUnloadGdiDriverInformation = 27,
	SystemTimeAdjustmentInformation = 28,
	SystemSummaryMemoryInformation = 29,
	SystemMirrorMemoryInformation = 30,
	SystemPerformanceTraceInformation = 31,
	SystemObsolete0 = 32,
	SystemExceptionInformation = 33,
	SystemCrashDumpStateInformation = 34,
	SystemKernelDebuggerInformation = 35,
	SystemContextSwitchInformation = 36,
	SystemRegistryQuotaInformation = 37,
	SystemExtendServiceTableInformation = 38,
	SystemPrioritySeperation = 39,
	SystemVerifierAddDriverInformation = 40,
	SystemVerifierRemoveDriverInformation = 41,
	SystemProcessorIdleInformation = 42,
	SystemLegacyDriverInformation = 43,
	SystemCurrentTimeZoneInformation = 44,
	SystemLookasideInformation = 45,
	SystemTimeSlipNotification = 46,
	SystemSessionCreate = 47,
	SystemSessionDetach = 48,
	SystemSessionInformation = 49,
	SystemRangeStartInformation = 50,
	SystemVerifierInformation = 51,
	SystemVerifierThunkExtend = 52,
	SystemSessionProcessInformation = 53,
	SystemLoadGdiDriverInSystemSpace = 54,
	SystemNumaProcessorMap = 55,
	SystemPrefetcherInformation = 56,
	SystemExtendedProcessInformation = 57,
	SystemRecommendedSharedDataAlignment = 58,
	SystemComPlusPackage = 59,
	SystemNumaAvailableMemory = 60,
	SystemProcessorPowerInformation = 61,
	SystemEmulationBasicInformation = 62,
	SystemEmulationProcessorInformation = 63,
	SystemExtendedHandleInformation = 64,
	SystemLostDelayedWriteInformation = 65,
	SystemBigPoolInformation = 66,
	SystemSessionPoolTagInformation = 67,
	SystemSessionMappedViewInformation = 68,
	SystemHotpatchInformation = 69,
	SystemObjectSecurityMode = 70,
	SystemWatchdogTimerHandler = 71,
	SystemWatchdogTimerInformation = 72,
	SystemLogicalProcessorInformation = 73,
	SystemWow64SharedInformation = 74,
	SystemRegisterFirmwareTableInformationHandler = 75,
	SystemFirmwareTableInformation = 76,
	SystemModuleInformationEx = 77,
	SystemVerifierTriageInformation = 78,
	SystemSuperfetchInformation = 79,
	SystemMemoryListInformation = 80,
	SystemFileCacheInformationEx = 81,
	MaxSystemInfoClass = 82  // MaxSystemInfoClass should always be the last enum

}system_information_class;
typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;
typedef struct _MM_UNLOADED_DRIVER
{
	UNICODE_STRING 	Name;
	PVOID 			ModuleStart;
	PVOID 			ModuleEnd;
	ULONG64 		UnloadTime;
} MM_UNLOADED_DRIVER, * PMM_UNLOADED_DRIVER;
```

`StrunderSv/StrunderSv/util.cpp`:

```cpp
#include "util.h"

BOOLEAN GlobalActive = TRUE;

const char* original = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/\\";
const char* modified = "qpDWJNvXkyagT/ULHKPxumjIcGloZbhiRVOEsteQwAFr\\SBYCnMzdf";

BasicDataArea DataArea = {};

void ClearDataArea(ULONG64 start, int type) {
	ULONG64 len;
	switch (type)
	{
	case 0:
		len = 4096;
		break;
	case 1:
		len = 409600;
		break;
	case 2:
		len = 4096000;
		break;
	default:
		return;
	}
	for (ULONG64 i = start; i < len; i++)
	{
		*(BYTE*)i = 0x00;
	}
}

void SetDataArea(PVOID dataArea) {
	DataArea = *(BasicDataArea*)dataArea;
}

NTSTATUS StartThread(PKSTART_ROUTINE start_function,PVOID args) {
	HANDLE thread_handle = nullptr;

	//CONTEXT paco = CONTEXT();

	//paco.Rax = (ULONG64)start_function;

	const NTSTATUS status = PsCreateSystemThread(&thread_handle, GENERIC_ALL, nullptr, nullptr, nullptr, start_function, args);
	if (NT_SUCCESS(status)) {
		ZwClose(thread_handle);
	}
	return status;
}

BOOLEAN GetGlobalActive() {
	return GlobalActive;
}
VOID SetGlobalActive(BOOLEAN st) {
	GlobalActive = st;
}

void Translate(unsigned char* buffer, size_t len) {
	for (size_t i = 0; i < len; i++) {
		for (size_t k = 0; k < 54; k++) {
			if (buffer[i] == modified[k]) {
				buffer[i] = original[k];
			}
		}
	}
}

void Sleep(int ms) {
	LARGE_INTEGER timeout;
	timeout.QuadPart = ms* - 10000;
	KeDelayExecutionThread(KernelMode, FALSE, &timeout);
}

HANDLE FindProcessByName(wchar_t* name, size_t name_len) {

	ULONG bytes = 0;
	NTSTATUS status = ZwQuerySystemInformation(SystemProcessInformation, 0, bytes, &bytes);
	J();
	if (!bytes)
	{
		return 0;
	}

	PVOID data = DataArea.ModListDataAddr;//ExAllocatePool(NonPagedPool, bytes); //abrimos espacio para la lista de procesos
	if (data == 0) {
		return 0;
	}

	if (bytes > 409600) {
		log("Error space needed to find process by name\n");
		return NULL;
	}

	status = ZwQuerySystemInformation(SystemProcessInformation, data, bytes, &bytes);
	if (!NT_SUCCESS(status))
	{
		//ExFreePool(data);
		RtlSecureZeroMemory(DataArea.ModListDataAddr, 409600);
		return 0;
	}

	PSYSTEM_PROCESS_INFORMATION pProcess = (PSYSTEM_PROCESS_INFORMATION)data;
	J();
	log("Searching for %ws\n", name);
	while (TRUE)
	{
		if (pProcess == 0) {
			break;
		}
		
		log("Reading %wZ\n", pProcess->ImageName);
		if (&pProcess->ImageName != nullptr && pProcess->ImageName.Length == name_len*2) {
			if (memcmp(pProcess->ImageName.Buffer, name, name_len*2) == 0) {
				log("Process name: %wZ  - Process ID: %d\n", pProcess->ImageName, pProcess->UniqueProcessId);
				HANDLE id = pProcess->UniqueProcessId;
				RtlSecureZeroMemory(DataArea.ModListDataAddr, 409600);
				return id;
			}
			else {
				log("Name missmatch\n");
			}
		}
		else {
			log("Len missmatch %d vs %d\n", pProcess->ImageName.Length, name_len);
		}

		if (pProcess->NextEntryOffset == 0) {
			break;
		}

		pProcess = (PSYSTEM_PROCESS_INFORMATION)((LPBYTE)pProcess + pProcess->NextEntryOffset); // Calculate the address of the next entry.
	}
	RtlSecureZeroMemory(DataArea.ModListDataAddr, 409600);
	return 0;
}

NTSTATUS KeWriteVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size)
{
	SIZE_T Bytes;
	if (NT_SUCCESS(MmCopyVirtualMemory(PsGetCurrentProcess(), SourceAddress, Process,
		TargetAddress, Size, KernelMode, &Bytes)))
		return STATUS_SUCCESS;
	else
		return STATUS_ACCESS_DENIED;
}

NTSTATUS KeReadVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size)
{
	SIZE_T Bytes;
	if (NT_SUCCESS(MmCopyVirtualMemory(Process, SourceAddress, PsGetCurrentProcess(),
		TargetAddress, Size, KernelMode, &Bytes)))
		return STATUS_SUCCESS;
	else
		return STATUS_ACCESS_DENIED;
}

BOOLEAN write(HANDLE pid, ULONG64 addr, ULONG64 data, ULONG64 size) {
	PEPROCESS Process;
	if (NT_SUCCESS(PsLookupProcessByProcessId(pid, &Process)))
		return KeWriteVirtualMemory(Process, (PVOID)data, (PVOID)addr, size) == 0;
	return FALSE;
}

BOOLEAN read(HANDLE pid, ULONG64 addr, ULONG64 dest, ULONG64 size) {
	PEPROCESS Process;
	if (NT_SUCCESS(PsLookupProcessByProcessId(pid, &Process)))
		return KeReadVirtualMemory(Process, (PVOID)addr, (PVOID)dest, size) == 0;
	return FALSE;
}

BOOLEAN fileExists(UNICODE_STRING path) {
	HANDLE   handle;
	NTSTATUS ntstatus;
	IO_STATUS_BLOCK    ioStatusBlock;
	OBJECT_ATTRIBUTES  objAttr;

	InitializeObjectAttributes(&objAttr, &path,
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
		NULL, NULL);

	ntstatus = ZwOpenFile(&handle, GENERIC_READ, &objAttr, &ioStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL);
	if (ntstatus == STATUS_SUCCESS && handle != NULL) {
		ZwClose(handle);
		return TRUE;
	}
	return FALSE;
}
```

`StrunderSv/StrunderSv/util.h`:

```h
#pragma once
#include "log.h"
#include <ntddk.h>
#include "eimport.h"
#include "structs.h"
#include <windef.h>
#include "JUNK.h"

typedef struct _BasicDataArea {
	BYTE NTName[4096];
	//BYTE buffer1[4096];
	BYTE IVDName[4096];
	//BYTE buffer3[4096];
	BYTE NTAddr[4096];
	//BYTE buffer5[4096];
	//BYTE buffer6[4096];
	//BYTE buffer7[4096];
	//BYTE buffer8[4096];
	//BYTE buffer9[4096];
	BYTE NTModListData[409600];
	BYTE ModListDataAddr[409600];
	//BYTE BigBuffer2[409600];
	//BYTE BigestBuffer0[4096000];
	//BYTE BigestBuffer1[4096000];
	//BYTE BigestBuffer2[4096000];
} BasicDataArea;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


extern BasicDataArea DataArea;
#ifdef __cplusplus
}
#endif // __cplusplus

void ClearDataArea(ULONG64 start, int type);
void SetDataArea(PVOID dataArea);
NTSTATUS StartThread(PKSTART_ROUTINE start_function, PVOID args);
BOOLEAN GetGlobalActive();
VOID SetGlobalActive(BOOLEAN st);
void Translate(unsigned char* buffer, size_t len);
void Sleep(int ms);
HANDLE FindProcessByName(wchar_t* name, size_t name_len);
NTSTATUS KeWriteVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size);
NTSTATUS KeReadVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size);
BOOLEAN write(HANDLE pid, ULONG64 addr, ULONG64 data, ULONG64 size);
BOOLEAN read(HANDLE pid, ULONG64 addr, ULONG64 dest, ULONG64 size);
BOOLEAN fileExists(UNICODE_STRING path);
```